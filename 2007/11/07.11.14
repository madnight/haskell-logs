00:01:04 <Korollary> I think I know of a few occasions where that quote could be useful.
00:01:10 <ari> ...
00:01:46 <newsham> ?vixen what do pork steaks taste like?
00:01:52 <lambdabot> i dunno...
00:02:00 <newsham> good answer
00:03:14 <Korollary> a vixen *should* now tho
00:03:30 <newsham> but she's not gonna admit it
00:03:48 <Korollary> or maybe because pork steaks are not kosher?
00:03:59 <newsham> ?vixen I dont think they're kosher.
00:04:00 <lambdabot> you're cute. :)
00:04:24 <newsham> i know.
00:04:28 <Korollary> Pierce Brosnan has a similar line in Matador
00:04:34 <Korollary> about Margaritas
00:05:33 <Korollary> http://imdb.com/title/tt0365485/quotes
00:05:34 <lambdabot> Title: The Matador (2005) - Memorable quotes
00:06:43 <Sizur> guys and galls! i want to thank everybody in this channel. you make #haskell a very friendly and professional place.
00:06:48 <alexj> is there a haskell programming pattern for handling recursive instance declarations e.g. that all your components need show for you to implement show?
00:07:17 <xpika> is it possible to remove the package unix dependancy to allow Xmonad to work on windows?
00:07:30 <alexj> th does not give instance info so you can't do it that way.
00:08:58 <newsham> you mean you did "deriving Show" and it gave an error but didnt say what subitem wasnt showable?
00:09:24 <sjanssen> xpika: you have X11 on Windows?
00:10:04 <newsham> sjanssen: there are many X servers for win32
00:10:16 <lament> that deriving show thing is such a sham
00:10:43 <lament> clearly the compiler is able to infere which things are auto-showable
00:10:58 <firstknight> Hi, how to make a datatype which hold four elements. Howerver the first two elements must be same type and last two elements must be same type too. data Quadruple a a b b = Quadruple a a b b => is not good
00:11:20 <newsham> data Quadruple a b = Quadruple a a b b ?
00:11:22 <xpika> sjanssen: yep I have two.
00:11:26 <newsham> Quadruple Int String
00:12:46 <firstknight> newsham: that's what I am looking for. thx
00:16:46 <roconnor> firstknight: the a and b in the first ``Quadruple a b'' are similar to the variable declarations in function definitions.
00:17:36 <roconnor> the second ``Quadruple a a b b'' is the data type declaration where you can use the bound variables.
00:17:49 <roconnor> thus you could write
00:18:01 <roconnor> data Quadruple2 b a = Quadruple2 a a b b
00:18:17 <roconnor> and now Quadruple2 String Int would be isomorphic to Quadruple Int String
00:20:03 <firstknight> roconnor: I see.... thx
00:21:26 <quicksilver> alexj: that would be a metaprogramming pattern rather than a programming pattern, I guess :) Haskell is a bit short of those. I'd take a look at Derive and friends.
00:22:41 <alexj> newsham: no I mean that manually adding deriving clauses to all included types is a PITA.  You can't automate it because then you end up with duplicate instance declarations.
00:23:42 <alexj> quicksilver: if all types were guaranteed to have a Data or  new Data instance that would help a lot.
00:23:59 <alexj> but at minimum you have to handle deriving all of those item by item.
00:36:20 <Korollary> alexj: That is true for any instance you can think of. A refactoring tool would be nice for that.
00:37:26 <alexj> korollary: how would that help?
00:38:16 <Korollary> alexj: hypothetically such a tool would point you to the declarations you need to do, automating as much as possible I suppose.
00:38:29 <alexj> yeah, the compiler does that enough.
00:38:45 <dsilva> why isn't Reader defined as ReaderT Identity ?
00:38:54 <alexj> It just adds to drudgery and boilerplate or TH blocks that looks scary to the uninitiated.
00:42:55 <alexj> is there any standard class for hashvalue?
00:46:56 <faxathisia> :t Identity
00:46:57 <lambdabot> forall a. a -> Identity a
00:47:29 <faxathisia> Can you write any Monad as MonadT Identity?
00:47:38 <faxathisia> every*
00:49:01 <opqdonut> yeah basically
00:49:12 <opqdonut> as long as MonadT exists ^_^
00:49:12 <faxathisia> no special cases or anything?
00:49:32 <faxathisia> oh I see.. is there multiple possible MonadT or sometimes not a possible MonadT for a given Monad?
00:49:58 <opqdonut> well for example IOT wouldn't really work
00:50:16 <dsilva> opqdonut: then why would Reader, for example, be defined separately from ReaderT ?  http://ogi.altocumulus.org/~hallgren/Programatica/tools/pfe.cgi?Control.Monad.Reader
00:50:18 <lambdabot> Title: 15 Control.Monad.Reader 8, http://tinyurl.com/22d3lg
00:50:44 <faxathisia> why can't IOT exist?
00:51:52 <opqdonut> it's kinda intuitive but i can't explain it off-hand
00:52:54 <opqdonut> dsilva: possibly because this way it's easier to use just Reader? i'm not sure
00:54:03 <Cale> It needn't be, really.
00:54:17 <dsilva> faxathisia: because you can't run the IO monad yourself, I guess
00:54:41 <faxathisia> IO monad can only be run if you are already inside IO ?
00:55:01 <Cale> It's probably mainly for pedagogical reasons that Reader isn't defined in terms of ReaderT.
00:55:12 <dsilva> faxathisia: I assume it can only be run by the toplevel
00:55:14 <Cale> and maybe some efficiency concerns
00:55:16 <opqdonut> Cale: mhmm
00:55:23 <dsilva> Cale: oh i see
00:55:51 <xs1cht_1048723> http://www.pennergame.de/ref.php?refid=6219097
00:55:52 <lambdabot> Title: Pennergame
01:31:37 <quicksilver> Cale: I can think of two reasons
01:31:50 <quicksilver> Cale: (1) using ReaderT usefully requires non-haskell98 extensions
01:32:07 <quicksilver> Cale: (2) using ReaderT Identity directly contains a lot of annoying boilerplate
01:32:18 <Cale> Uh, but you wouldn't.
01:32:26 <Cale> The module would have
01:32:52 <quicksilver> newtype Reader r = ReaderT r Identity ?
01:33:00 <Cale> indeed
01:33:03 * quicksilver nods
01:33:10 <Cale> (with a newtype constructor)
01:33:17 <quicksilver> always forget that bit :)
01:33:33 <quicksilver> yeah, and custom monomorphic combinators.
01:33:43 <Cale> Might as well also use newtype deriving while we're at it.
01:34:14 <Cale> Otherwise much of the point in doing that would be lost.
01:34:23 * quicksilver nods
01:34:50 <quicksilver> well hypothetically if you're in haskell98 world
01:34:55 <quicksilver> you'd write them by hand
01:34:59 <quicksilver> but it's not *that* hard I guess
01:57:53 <therp> to get static parts of a foreign C struct, is it ok to use unsafePerformIO?
01:58:13 <therp> I have seen this in the X11 binding, and I'm not sure if I want to copy that
02:00:15 <schemelab> @source takeWhile
02:00:15 <lambdabot> takeWhile not available
02:01:22 <Japsu> takeWhile p (x:xs) = if p x then x : takeWhile p xs else []
02:02:44 <sjanssen> therp: I'd say it's better to err on the side of safety
02:13:26 <quicksilver> therp: using unsafePerformIO is saying "I know this struct is constant throughout the whole life of my program, so it doesn't matter when this 'peek' is performed"
02:14:03 <quicksilver> therp: unless, you also believe you understand the ghc evaluation model in which case what you are saying is "I know *exactly* when this thunk will be forced, and I know that the the value at that time is the value I want"
02:14:23 <quicksilver> the second guarantee is probably harder to convince yourself of than the first, but either will do.
02:16:54 <schemelab> Japsu: yes, I was readnig Bird/Wadler "Intro to FP" and they used foldr to do it, which seemed rather inefficient, and confusing to me at first
02:24:08 <sjanssen> interestingly, takeWhile isn't defined with foldr in GHC
02:24:14 <sjanssen> that could be a big win with foldr/build fusion
02:30:40 <dancor> why is evaluate in Control.Exception
02:31:12 <quicksilver> because it may "force" hidden exceptions to occur
02:31:49 <dancor> ok.  but it is also useful for avoiding laziness more generally right?
02:32:01 <quicksilver> maybe
02:32:08 <quicksilver> only if you understand what it does :P
02:32:26 <sjanssen> @src evaluate
02:32:26 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
02:33:38 <hpaste>  ttfh pasted "Am I missing something about type synonyms?" at http://hpaste.org/3872
02:35:35 <quicksilver> ttfh: it would be friendly to show us the error message :)
02:35:48 <sjanssen> ttfh: that might work with GHC extensions
02:36:09 <quicksilver> but can type synonyms have 'hidden' universals ?
02:36:29 <quicksilver> I would normally write that as 'Handler m'
02:37:27 <quicksilver> ttfh: I suspect not
02:37:39 <quicksilver> ttfh: the form 'Handler' suggests that Handler is a single type
02:37:41 <quicksilver> whereas, it isn't
02:37:45 <quicksilver> it's a family of types
02:37:51 <quicksilver> (over all monadIOs m)
02:41:12 <therp> quicksilver: hm you are right, this isn't a good approach. I overlooked that there is not only referential transparency that matters but the whole structure might be discarded before the thunk is forced. so time matters here.
02:41:52 <therp> quicksilver: thanks
02:43:12 <hpaste>  (anonymous) annotated "Am I missing something about type synonyms?" with "added complete error message" at http://hpaste.org/3872#a1
02:43:51 <ttfh> quicksilver: thank you, but it seems the error is about something else
02:44:16 <quicksilver> no, that error message says what I said :)
02:44:33 <quicksilver> it says type synonyms must be explicit about their polymorphism
02:44:39 <quicksilver> they can't hide constraints, either
02:44:44 <quicksilver> the best you can do is:
02:44:53 <quicksilver> type Hander = (String -> m ()) -> Int -> m ()
02:44:56 <quicksilver> and then
02:45:05 <ttfh> aha, so there can't be a constraint in a type synonym
02:45:06 <quicksilver> handleeventp :: MonadIO m => Handler m
02:45:12 <quicksilver> type Handler m = (String -> m ()) -> Int -> m ()
02:45:16 <quicksilver> is what I meant, sorry
02:45:29 <roconnor> swiert: does Conor still have a job?
02:45:41 <quicksilver> ttfh: in other words, you did two illegal things at once :)
02:46:01 <ttfh> yes, the first one was easier to understand than the second
02:46:04 <quicksilver> ;)
02:46:41 <quicksilver> the fact you can't conceal constraints in types does make constraints feel not really a "first class" part of the type system
02:46:52 <quicksilver> in a sense, a constraint is not so much part of the type
02:46:57 <quicksilver> as an extra thing around the tyep
02:47:17 <quicksilver> of course, you can conceal constraints in existentials, but that's actually different from what you're trying to do here
02:47:47 <ttfh> yes, when I wrote it I was thinking "this type is long, so I'll give it a name"
02:49:04 <ttfh> (the type in the program I was writing was longer, with more constraints)
02:50:20 * quicksilver nods
02:57:24 <fasta> What can give rise to a ThreadKilled exception?
02:57:44 <sieni> killing a thread?
02:57:47 * sieni ducks
02:58:02 <fasta> I am not aware of me explicitly killing a thread.
03:02:57 <sjanssen> fasta: ^C?
03:03:28 <fasta> sjanssen: no
03:06:42 <byorgey> ...tiny squirrels in your CPU?
03:08:48 <fasta> byorgey: or evil hackers coming into my peecee via the InterWebz or invisible unicorns breaking in to my house.
03:09:02 <byorgey> fasta: yup, that must be it
03:09:17 <byorgey> I hate those invisible unicorns.
03:09:39 <fasta> Especially the purple ones?
03:23:56 <therp> fasta: pink unicorns? oh noes!
03:26:12 <Cale> *invisible* pink unicorns
03:26:31 <Cale> They're pink, but they're also invisible, so you just have to *believe*.
03:27:02 <therp> cale: he already labeled the unicorn with the invisible adjective :)
03:28:03 <dmwit> Anyway, we *know* they're invisible.  It's just science.
03:28:06 * therp recommends http://youtube.com/watch?v=7TagemN7kkw for some spaghetti and unicorns .. and hopes that none asks what this is about
03:28:07 <lambdabot> Title: YouTube - Re: The Flying Spaghetti Monster vs the Invisible Pink Unico
03:28:10 <dmwit> I mean, you can't see them, can you?
03:29:13 <fasta> I am sure some people can see them and make a living of it.
03:31:51 <dmwit> therp: wow
03:38:36 <matthew-_> so has anyone got an EeePC yet and got xmonad running on it?
03:41:24 <DRMacIver> Is xmonad actually good for small laptops?
03:41:39 <DRMacIver> I would imagine that with something that small I'd want to be running in full screen mode all the time anyway.
03:43:16 <nominolo> :t on
03:43:21 <lambdabot> Not in scope: `on'
03:43:31 <nominolo> :t Data.Function.on
03:43:36 <lambdabot> Couldn't find qualified module.
03:43:44 <nominolo> :t Control.Function.on
03:43:44 <lambdabot> Couldn't find qualified module.
03:43:52 <nominolo> :t Function.on
03:43:52 <lambdabot> Couldn't find qualified module.
03:44:03 <nominolo> >:-(
03:44:32 <matthew-_> DRMacIver: yeah true. If it wasn't for the really low res screen, I'd be very tempted to get one. As it is, I'm only quite tempted to get one :)
03:45:07 * DRMacIver got an Asus laptop recently, but it's rather larger than that. :)
03:45:21 <dancor> i have some   lookup :: k -> m v   , which can   fail "not found"   and i want it to recursive call itself; how can i detect the fails in subcalls
03:45:26 <nominolo> @index comparing
03:45:26 <lambdabot> bzzt
03:45:53 <mauke> dancor: with a generic m, you can't
03:45:59 <mauke> why do you need to?
03:46:16 <quicksilver> dancor: use a specific monad like perhaps the maybe monad
03:46:20 <dancor> mauke: i have a Trie type that i want to define lookupAnagram for
03:46:24 <quicksilver> which encapsulates a nice simple failure
03:46:47 <dancor> quicksilver: well actually why does lookup always take a general m anyway
03:47:02 <dancor> for like Data.Map
03:47:09 <mauke> because it can
03:47:15 <dancor> and here it can't
03:47:38 <dancor> haskell creates weird dependencies
03:47:58 <dancor> like your lookup function can be weirdly monad-general iff it doesn't call itself
03:48:16 <mauke> huh? I'm pretty sure Data.Map.lookup is recursive
03:49:02 <dancor> @src Data.Map.lookup
03:49:03 <lambdabot> Source not found. You type like i drive.
03:49:05 <Cale> dancor: fail is kind of a kludge, and I recommend against its direct use.
03:49:19 <mauke> :t lookup
03:49:20 <Cale> dancor: If you want to fail in the monad, use mzero or throwError instead.
03:49:21 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:50:04 <Cale> dancor: This is because fail is a bad hack to handle failed pattern matches in do-notation.
03:50:25 <mauke> lookup x [] = fail "not found"; lookup x ((k, v) : xs) = if x == k then return v else lookup x xs  -- recursive monadic lookup
03:50:33 <mauke> just to show it's possible
03:50:54 <Cale> You can definitely write recursive monadic functions.
03:51:07 <Cale> another good example is sequence (though it doesn't fail)
03:51:55 <dancor> i'm just going to use Maybe explicitly
03:52:16 <Cale> That's a decent idea. :)
03:52:17 <dancor> maybe some day i'll be able to figure out if what i wanted was possible
03:52:36 <Cale> dancor: Sorry, I kind of joined this conversation in the middle, what was your original thing?
03:52:39 <mauke> :t maybe (fail "not found") return
03:52:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
03:52:44 <mauke> ta da
03:53:17 <Cale> oh, if you fail in the monad properly, then it will get passed upward automatically, you don't have to handle it
03:53:24 <Cale> It's like Nothing in the Maybe monad
03:53:25 <dancor> Cale: i'm trying to detect if [k] is an anagram of something inside a Trie
03:53:44 <mauke> `mplus`
03:53:45 <dancor> so i have lookupAn :: (Ord k, Monad m) => [k] -> Trie k v -> m v
03:54:11 <dancor> it fail-s in certain base cases
03:54:16 <Cale> okay
03:54:19 <dancor> and then it needs to call itself a lot
03:54:35 <dancor> i think i can do it if i demote to Maybe
03:54:43 <dancor> but i'm not sure how to handle fail if i don't
03:54:53 <Cale> You shouldn't have to worry about passing failure upward if fail is properly implemented (that is, if it's the same thing as mzero)
03:55:22 <Cale> You really should probably use mzero rather than fail, even though that gives you a MonadPlus constraint rather than Monad.
03:55:51 <Cale> There used to be MonadZero, which was perfect for this, but it was removed in an oversight of the H98 committee.
03:56:48 <dancor> ok i'll see what happens bbl
03:59:10 <titusg> What is a datakind? It seems to be used just like a datatype definition in SPJ's paper on ndexed type families...
03:59:25 <puusorsa> @pl mapM_ (\x -> a x >>= (putStrLn . show)) [1..10]
03:59:25 <lambdabot> mapM_ ((putStrLn . show =<<) . a) [1..10]
03:59:48 <puusorsa> oh.. i thought it would be mapM_ ((putStrLn . show) =<< a) [1..10]
03:59:53 <puusorsa> thanks lambdabot! :)
04:00:02 <mauke> @src print
04:00:02 <lambdabot> print x = putStrLn (show x)
04:00:05 <byorgey> titusg: kinds classify types, just as types classify values.
04:00:25 <Cale> @kind Maybe
04:00:26 <lambdabot> * -> *
04:00:30 <Cale> @kind Integer
04:00:31 <lambdabot> *
04:00:36 <Cale> @kind Reader
04:00:36 <lambdabot> * -> * -> *
04:00:39 <puusorsa> mauke, thanks. i has teh dumb today
04:00:46 <mauke> @kind ContT
04:00:46 <Cale> @kind Maybe Integer
04:00:46 <lambdabot> * -> (* -> *) -> * -> *
04:00:47 <lambdabot> *
04:01:23 <titusg> byorgey: I understand about kinds in that sense, but he has `datakind = Z | S Nat` -- what does that "do"?
04:01:58 <byorgey> titusg: I've never seen that before.  do you have a link to the paper?
04:02:39 <titusg> http://www.cse.unsw.edu.au/~chak/papers/SSPC07.html
04:02:40 <lambdabot> Title: Research Papers of Manuel Chakravarty
04:02:48 <Cale> titusg: oh, that
04:02:53 <puusorsa> so mapM_ ((print =<<) . a) [1..10]  for epic win
04:03:22 <titusg> is it part of the type families extension?
04:03:32 <Cale> datakind Nat = Z | S Nat
04:03:59 <Cale> This defines a kind called Nat which specifically consists of the types Z and S t for t of kind Nat
04:04:15 <Cale> That is, it's like data Nat = Z | S Nat, but at the type level, rather than the value level.
04:04:36 <Cale> I don't know if it's part of any existing extension or if it's been implemented in GHC at all.
04:04:38 <dmwit> Is there a name for this?
04:04:41 <dmwit> superkind, maybe?
04:04:52 <mauke> looks like user-defined kinds
04:04:58 <Taejo> is the ghc profiler a sampling or tracing profiler?
04:05:00 <byorgey> it's not a superkind, Nat is a kind.
04:05:11 <dmwit> hmmm... oh!
04:05:28 <titusg> Cale: so Nat is either the kind of Z or of S Nat?
04:05:37 <Cale> yeah
04:05:43 <Cale> and it's not the kind of any other types
04:05:52 <byorgey> Z, S Z, S (S Z), etc. are all types of kind Nat.
04:05:58 <Cale> right
04:06:20 <byorgey> uninhabited types, at that.
04:06:21 <titusg> but they all have the same saturated kind * no?
04:06:36 <byorgey> yes.
04:07:06 <Cale> um
04:07:15 <Taejo> Does List.nub take quadratic time?
04:07:35 <byorgey> Taejo: it sure does.
04:08:09 <Taejo> byorgey, is there a version that uses Ord instances and takes linearithmic time?
04:08:14 <TSC> Data.Set
04:08:24 <mauke> linearithmic!
04:08:25 <Cale> > nub [1..]
04:08:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:08:44 <TSC> fastNub = Data.Set.toList . Data.Set.fromList
04:08:47 <Cale> It's "sort of" quadratic :)
04:08:56 <Taejo> @src nub
04:08:56 <lambdabot> nub = nubBy (==)
04:09:00 <Taejo> @src nubBy
04:09:01 <lambdabot> nubBy eq []             =  []
04:09:01 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:09:27 <byorgey> Taejo: with only an Eq instance, quadratic is the best that nub can possibly do.
04:09:40 <Taejo> yes
04:09:54 <Taejo> I had assumed it took Ord instances
04:09:57 <Cale> Well, it's quadratic in the worst case, certainly, but laziness makes things a little more interesting sometimes
04:10:28 <byorgey> you can also do something like map head . group . sort if you don't want to import Data.Set.  I'm not sure how they compare performance-wise.
04:10:43 <dmwit> I think it would be fun to visit all the usual algorithms and fill in a best-case running time analysis.
04:10:47 <TSC> nub is quadratic in the number of output elements you evaluate, isn't it?
04:11:09 <dmwit> > nub [1..] -- more than quadratic in the output elements
04:11:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:11:14 <dmwit> whoops
04:11:18 <dmwit> > nub [1,1..]
04:11:22 <lambdabot> Terminated
04:11:37 <TSC> Mmmm
04:12:43 <Cale> and despite how it looks   xs /= nub xs  is a really great way to check for duplicates.
04:12:53 <quicksilver> TSC: it's only quadratic in the number of actually different values
04:13:05 <quicksilver> it is "pulling along" a progressively bigger "thunk"
04:13:08 <quicksilver> of /=s
04:13:15 <Cale> It will run as quickly as any algorithm should be able to do that.
04:13:19 <byorgey> Cale: really?  interesting.
04:13:42 <dmwit> quicksilver: I don't think that's right.
04:13:42 <quicksilver> the size of that thunk is the number of distinct values encountered so far
04:14:03 <quicksilver> so if you nub [1,1,....1,1,2]
04:14:06 <Cale> er, hmm, there might be a case in which it's not.
04:14:16 <quicksilver> your thunk only has filter (/=1) in it
04:14:22 <quicksilver> so it hasn't got particularly big
04:14:24 <dmwit> quicksilver:
04:14:31 <dmwit> nm
04:15:35 <Cale> It's pretty close to ideal anyway.
04:15:48 <Cale> In terms of practical cases.
04:15:56 <dmwit> quicksilver: I think I can construct a list that takes arbitrarily long to nub, but has only two values.  That doesn't sound quadratic to me.
04:16:13 <Beelsebob_> one could sort, group, and head... but that certanly won't work on infinite lists
04:16:25 <Cale> I suppose if you're expecting there to be a large number of duplicates of the same item in a row when there are duplicates, then that's the one case it's not so good at.
04:18:01 <quicksilver> dmwit: erm? I didn't say it was independent of list length
04:18:06 <quicksilver> dmwit: it's certainly not sublinear
04:18:21 <dmwit> Oh, okay.
04:18:32 <quicksilver> I just said, it's not quadratic in list length
04:18:39 <Taejo> so it's O(N^2 + M) where N is number of distinct and M is number of elements?
04:18:44 <quicksilver> it's O((number distinct) * (total number))
04:18:45 <quicksilver> IMO.
04:18:55 <dmwit> Taejo: s/+/*/, yes
04:19:02 <Taejo> ok
04:20:16 <dmwit> > let f [] = []; f (x:xs) = x : takeWhile (\y -> (not (elem y (f xs)))) xs in f [1,2,3,1]
04:20:17 <lambdabot>  [1]
04:20:55 <dmwit> > let f [] = []; f xs@(x:_) = x : takeWhile (\y -> (not (elem y (f xs)))) xs in f [1,2,3,1]
04:20:56 <lambdabot>  [1]
04:21:20 <dmwit> oh, bah
04:21:31 <Cale> Yeah, I suppose there really ought to be cases where map head . group . sort does way better.
04:21:35 <dmwit> > let f [] = []; f xs@(x:rest) = x : takeWhile (\y -> (not (elem y (f xs)))) rest in f [1,2,3,1]
04:21:36 <lambdabot>  Exception: stack overflow
04:21:46 <Cale> But the nub way is surprisingly good.
04:24:13 <quicksilver> well nub for example is quadratic on a completely distinct list
04:24:36 <quicksilver> whereas map head . group . sort is hopefully only n log n
04:24:52 <quicksilver> and you can also try to choose a sort algorithm which behaves well on mostly sorted data
04:24:57 <quicksilver> if you believe that is likely to be the case
04:26:48 <Cale> The constant factors are way different though.
04:30:40 <dmwit> "Perl 5.10 for People Who Aren't Totally Insane"
04:31:03 <opqdonut> isn't sort an insertion sort?
04:31:05 <opqdonut> :src sort
04:31:09 <opqdonut> ?src sort
04:31:09 <lambdabot> sort = sortBy compare
04:31:12 <opqdonut> ?src sortBy
04:31:13 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:31:15 <opqdonut> there
04:31:32 <mauke> the ?src is a lie
04:31:32 <opqdonut> so head.group.sort is O(n^2)
04:32:20 <opqdonut> yeah isn't that the report source?
04:32:29 <mauke> I think so
04:32:57 <quicksilver> opqdonut: sort is really merge, I think
04:33:04 <opqdonut> but i'd think insertion sort is the only one that has any chance of working lazily for infinite lists
04:33:11 <opqdonut> hmm
04:34:03 <dmwit> How would that allow sorting of infinite lists?
04:34:19 <quicksilver> insertion sort is sometimes described as 'online'
04:34:25 <quicksilver> you can keep feeding it data
04:34:32 <quicksilver> so it works on any prefix of an infinite list, say
04:34:52 <opqdonut> yep
04:34:54 <quicksilver> whereas quicksort and merge sort both work over the 'whole' list
04:34:58 <dmwit> Okay, yeah, but you can never get, say, the first element of the sorted infinite list.
04:35:00 <dmwit> Right?
04:35:01 <opqdonut> which was my point
04:35:03 <quicksilver> right
04:35:08 <dmwit> ok
04:35:10 <quicksilver> but you can get the first 10,000 elements, sorted
04:35:20 <quicksilver> and then get the first 10,001 cheaply
04:35:31 <dmwit> Right, okay.
04:35:58 <quicksilver> in fact, it's more-or-less the specification of an online sort
04:36:06 <quicksilver> it's hard to imagine an online sort which isn't insertion
04:36:35 <opqdonut> of course a better implementation would be to keep the data in a map
04:36:43 <opqdonut> and perform toList when a list is needed
04:37:06 <dmwit> Depends on what you mean by online.
04:37:09 <matthew-_> that is kinda an insertion sort though
04:37:26 <dmwit> I could imagine a sort that sorts the first 2^n elements.
04:37:27 <opqdonut> yeah, but with O(log(n)) insertions
04:37:32 <matthew-_> true
04:37:35 <opqdonut> instead of O(n)
04:37:58 <opqdonut> but anyway, that requires an intermediate structure which would make it useless for the prelude sort
04:41:38 <matthew-_> actually, I can't see that that would work lazily. Surely Map.fromList has to traverse the entire list.
04:42:45 <Taejo> ya
04:42:48 <Taejo> > 5 `Data.Set.member` (Data.Set.fromList [1..])
04:42:53 <opqdonut> well of course we wouldn't use fromList
04:42:53 <lambdabot> Terminated
04:43:00 <opqdonut> but fromList . take k
04:43:06 <matthew-_> ahh, gotcha
04:43:32 <opqdonut> > toList . fromList . take 10 $ [1..]
04:43:40 <lambdabot>   Not in scope: `fromList'
04:43:49 <opqdonut> > Data.Set.toList . Data.Set.fromList . take 10 $ [1..]
04:43:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:44:03 <matthew-_> > :set +s
04:44:03 <lambdabot>   parse error on input `:'
04:44:05 <matthew-_> ;)
04:49:39 <profmakx> @version
04:49:39 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
04:49:39 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:01:17 <roconnor> I have more than an applicative functor
05:01:41 <roconnor> I have that flip <$> a <*> b = b <*> a
05:01:47 <roconnor> any name for this?
05:02:08 <EvilTerran> <**>?
05:02:18 <EvilTerran> wait. never mind.
05:02:20 <roconnor> EvilTerran: I'm stating a law ;)
05:02:51 <roconnor> commutative applicative functor perhaps?
05:03:15 <roconnor> er
05:03:18 <roconnor> my law is wrong
05:03:35 <quicksilver> it doesn't appear to typecheck, to me :P
05:03:36 <roconnor> flip <$> f <*> a <*> b === f <*> b <*> a
05:03:44 <quicksilver> ah, that's better
05:03:46 <roconnor> I have that law
05:03:53 <Beelsebob_> has anyone attempted to install readline from macports since the mac ghc 6.8 got released?
05:04:01 <opqdonut> err, what applicatives does that not work for?
05:04:07 <EvilTerran> IO
05:04:10 <opqdonut> ahh
05:04:17 <roconnor> opqdonut: most monads
05:04:21 <EvilTerran> well, anything stateful
05:04:22 <quicksilver> roconnor: yes, I'd call that an commutative applicative functor
05:04:28 <ski> noncommutative ones
05:04:32 <quicksilver> one where order of effects doesn't matter
05:04:47 <quicksilver> e.g. reader
05:04:50 <roconnor> quicksilver: is that one law sufficent?
05:04:56 <roconnor> I may have other laws lurking
05:05:27 <roconnor> is it the standard way of stating that you have a commutative applicative functor?
05:06:01 <EvilTerran> ?instances-importing Control.Applicative Applicative
05:06:02 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
05:06:25 <quicksilver> roconnor: I've not heard that before, but you don't hear much about applicatives.
05:06:28 <ivanm> hey roconnor... I hope to have my ERA-based report finished within a few hours... would you be able to skim through it for me? I especially want to make sure I haven't mis-represented your work! :p
05:06:36 <quicksilver> roconnor: that's certainly common terminolgoy about monads.
05:06:51 <roconnor> ivanm: sure
05:06:58 <ivanm> thanks
05:07:03 * ivanm gets back to it
05:07:10 <roconnor> quicksilver: what is the defining property of a communative monad?
05:07:21 <roconnor> (my applicative functor is actually a monad)
05:08:17 <quicksilver> do { x <- a; y <- b; return (x,y) } === do { y <- b; x <- a; return (x,y) }
05:08:50 <quicksilver> or, if you like to be cute liftM2 = flip (liftM2.flip) or something along those lines :)
05:09:26 <roconnor> quicksilver: okay, your liftM2 law is basically the same as the law I stated.
05:09:52 <quicksilver> yes, it is
05:10:14 <EvilTerran> ?type flip.liftM2.flip
05:10:14 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => (a -> b -> c) -> m a -> m b -> m c
05:10:25 <opqdonut> yeah, not flip (liftM2.flip)
05:10:30 <opqdonut> :t flip (liftM2.flip)
05:10:31 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => m b -> (a -> b -> c) -> m a -> m c
05:11:55 <quicksilver> @pl flip' f a b c = f a c b
05:11:55 <lambdabot> flip' = (flip .)
05:12:25 <quicksilver> yeah
05:12:28 <quicksilver> it is in fact simply
05:12:35 <quicksilver> liftM2 = flip . liftM2 . flip
05:12:47 <opqdonut> liftM2.flip = flip.liftM2
05:12:51 <quicksilver> indeed :)
05:12:54 <opqdonut> :)
05:12:55 <roconnor> quicksilver: I'd rather state is as opqdonut does
05:12:56 <roconnor> :)
05:13:18 <EvilTerran> ah, yes, that's very succinct
05:13:23 <roconnor> opqdonut: it even looks commutative.
05:13:29 <opqdonut> heh ywah
05:32:25 * Beelsebob_ wonders if JaffaCake is anywhere to be foind
05:32:26 <Beelsebob_> found too
05:32:36 <Beelsebob_> the Leopard ghc install instructions need altering
06:08:27 <dataangel> Is there any difference inside a monad between putting the return value into a placeholder variable and then calling a function on that variable than calling liftM on the function and what the placeholder was set to?
06:09:07 <sannysanoff> what about "androing" binding in haskell? will it worth it? (half-seriously)
06:09:12 <sannysanoff> android
06:09:30 <kpreid> dataangel: no
06:09:43 <dataangel> @src liftM
06:09:44 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:09:49 <dataangel> oh :P
06:12:19 <nominolo> @hoogle filterM
06:12:20 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
06:12:20 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
06:12:20 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
06:12:47 <n00bie> hey guys i am writing a simple implemetationof mastermind in haskell, but I don't know how to implemen my radomize function, I wrote but i don't know how to use it
06:13:33 <nominolo> why is there no filterM in Data.Foldable?
06:14:10 <n00bie> gonna post i
06:14:12 <n00bie> t
06:14:28 <hpaste>  noob pasted "mastermind" at http://hpaste.org/3873
06:15:06 <n00bie> please i need it to work, so please help
06:15:33 <n00bie> now it takes in two inputs, but i want to change the first input to be randomized
06:15:55 <n00bie> my randomize function is already built just wanna make it work
06:16:01 <n00bie> in a loop
06:16:10 <n00bie> of about 8 - 10 times
06:16:21 <n00bie> how do i do that?
06:17:27 <Beelsebob_> build an infinite list of random numbers
06:17:30 <Beelsebob_> and then pull them off
06:17:49 <hpaste>  noob pasted "masterming (with help & about)" at http://hpaste.org/3874
06:18:12 <osfameron> the randomize function doesn't appear to be random
06:18:24 <ricky_clarkson> Smells more like tail recursion than looping (as far as there's a difference between those)
06:18:26 <Beelsebob_> no, not really
06:19:17 <n00bie> remember that it must pull a code from six colors, i implemented it that way
06:19:51 <fasta> ricky_clarkson: there is no difference between loops and tail-recursion
06:20:04 <n00bie> i got it to do that, but how do i take the first elemen [4 colors] and use it in the mastermind
06:20:11 <ricky_clarkson> fasta: Hence, "as far as there's a difference between them".
06:20:11 <fasta> ricky_clarkson: since there is no "built-in" loop in Haskell.
06:20:37 <ricky_clarkson> fasta: Based on n00bie's question, it sounds like he's gonna be thinking in loops and mutation.
06:20:37 <Beelsebob_> fasta: what's map then?
06:20:40 <Beelsebob_> :D
06:20:51 <ricky_clarkson> Beelsebob_: A function.
06:20:59 <fasta> Beelsebob_: I am not sure what you mean.
06:21:05 <Beelsebob_> that uses tail recursion to simulate loops
06:21:23 <Beelsebob_> admitedly a small sub-category of loops
06:21:25 <n00bie> the game suppose to be runned in a loop of  8 times, so i figure i would need a counter and do until 8
06:21:25 <Beelsebob_> but loops all the same
06:21:38 <fasta> Beelsebob_: so?
06:21:45 <fasta> Beelsebob_: "map" is not built-in.
06:21:46 <Beelsebob_> fasta: so it does have built in loops
06:21:47 <Beelsebob_> map is on
06:22:07 <Beelsebob_> I took built in to mean "included in the prelude"
06:22:14 <ricky_clarkson> Me too.
06:22:35 <fasta> Built-in is everything you cannot define yourself, imho.
06:23:06 <Beelsebob_> so for isn't built in in C?
06:23:15 <Beelsebob_> after all, I could define that myself
06:23:24 <mauke> Beelsebob_: I'd like to see that
06:23:33 <ricky_clarkson> The only place I've seen that kind of definition before is bash (builtins such as cd, if).
06:23:48 <Beelsebob_> mauke: it wouldn't have identical syntax, but it would work
06:24:06 <mauke> I doubt that
06:24:07 <n00bie> when randomize is implemented, how do i take one out and use it to be the code, while the user guess try to break that code
06:24:14 <fasta> Beelsebob_: for is syntax
06:24:25 <fasta> Beelsebob_: so, it's built-in.
06:24:46 <fasta> Beelsebob_: you can define a for function in C, but you cannot use the same denotation.
06:24:53 <Beelsebob_> true
06:24:59 <ricky_clarkson> fasta: You could just say that built-in is syntax, then start using 'syntax' where you previously used 'built-in', and then you could escape the terminology discussions.
06:25:07 <Beelsebob_> meh... certainly in terms of Haskell, I wouldregard "map" as being built in
06:25:12 <Beelsebob_> because it's in the prelude
06:25:20 <Beelsebob_> and there's no place you're ever going to not find the prelude
06:25:23 <n00bie> hey guys , are u gonna help me or not?
06:25:34 <fasta> ricky_clarkson: ok, "there is no syntax for loops in Haskell", would be better.
06:25:41 <Beelsebob_> fair enough
06:25:53 <Beelsebob_> n00bie: what would you like? an interactive session of 10 games?
06:25:54 <fasta> n00bie: you are discriminating the females.
06:26:06 <n00bie> if i fail this i lose my scholarship, please
06:26:24 <mauke> haha
06:26:36 <n00bie> yes interactive seesion
06:26:45 <Beelsebob_> then you want to use recursion, and IO
06:26:51 <Philippa> Beelsebob_: different value of "built in", and it's important
06:26:57 <Beelsebob_> note, the rest of your program should *not* use IO
06:27:03 <Beelsebob_> at least not in this case
06:27:09 <Beelsebob_> Philippa: indeed
06:28:21 <fasta> Beelsebob_: you can hide the Prelude.
06:28:26 <Beelsebob_> true
06:28:37 <fasta> Beelsebob_: and I do that in about every module.
06:28:44 <fasta> Beelsebob_: so, it's not a theoretical thing.
06:28:50 <Beelsebob_> fair enough
06:29:34 <stulli> is a . b the same as b >>= a ?
06:29:45 <Beelsebob_> no
06:29:48 <Beelsebob_> :t (.)
06:29:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:29:53 <Beelsebob_> :t (>>=)
06:29:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:30:10 <Beelsebob_> they're similar concepts though
06:30:28 <stulli> hm, so >>= is only for monads
06:30:32 <mauke> I'd say (>>=) is similarer to ($)
06:30:35 <Beelsebob_> yes, and it's also not composition
06:30:52 <Beelsebob_> it takes a monadic value, and a function, not two functions
06:31:02 <Beelsebob_> said monadic value may of course have been produced by using other binds though
06:31:06 <fasta> (>=>) is Kleisli composition, IIRC
06:31:27 <wli> :t (>=>)
06:31:27 <lambdabot> Not in scope: `>=>'
06:31:27 <stulli> ah, ok. thanks for explaining
06:31:50 <ToRA> Prelude Control.Monad> :t (>=>)
06:31:50 <ToRA> (>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:32:01 <ToRA> wli: it's new in 6.8
06:34:15 <dataangel> How does
06:35:00 <dataangel> err, How does endBy in parsec work? The doc says it matches 0 or more occurences of p separated by sep and ended by sep. How can the separator both separate elements and be their end?
06:36:14 <sieni> dataangel: like: a,b,c,
06:36:19 <sieni> dataangel: or?
06:36:20 <Cale> Do you mean sepEndBy?
06:36:27 <dataangel> no, endBy
06:36:58 <Cale> oh, yes
06:37:11 <Cale> right
06:37:51 <hpaste>  dataangel pasted "Why not just sepBy?" at http://hpaste.org/3875
06:37:59 <mauke> endBy x sep = many (x << sep)
06:38:00 <Cale> So you have something like "p;p;p;" where p is something matched by the first argument, and ; is something matched by the second
06:38:16 <sieni> wtf, somebody has implemented parsec in java :-o
06:38:25 <sieni> http://jparsec.codehaus.org/
06:38:25 <Cale> sepBy looks like "p;p;p" by comparison.
06:38:25 <lambdabot> Title: JParsec - Home
06:39:19 <osfameron> nice
06:39:30 <dataangel> I see, but in the context of DottedList (see the paste) I guess I'm not sure why you need endBy instead of sepBy. Couldn't you just use sepBy, then eat spaces until there's a dot?
06:40:13 <osfameron> how do you write a parser combinator in a language with no anonymous functions...
06:40:14 <Cale> yeah, you could, but this saves you from having to type that it
06:40:15 <Cale> bit*
06:40:42 <Cale> osfameron: lots of objects
06:41:23 <osfameron> Cale: well indeed.  but ouch :-)
06:41:49 <mauke> interface Function { public Object call(Object); }
06:42:12 <Cale> I'm guessing they don't quite use it monadically.
06:42:17 <dataangel> Cale: Actually, doesn't the endBy version require that there be exactly one space separating the head from the . ? That might be incorrect scheme.
06:42:47 <Cale> dataangel: spaces matches zero or more spaces, iirc.
06:43:13 <Cale> I haven't looked at it closely, but I'm guessing that JParsec looks a whole lot more like pre-monadic parser combinator libraries.
06:43:24 <Cale> at least in usage if not implementation
06:48:40 <dataangel> Cale: Oh right, I forgot spaces is passed to endBy, not ' ' :P
06:48:57 <dataangel> @src endBy
06:48:57 <lambdabot> Source not found. Just try something else.
06:49:26 <MyCatVerbs> :t mod
06:49:30 <lambdabot> forall a. (Integral a) => a -> a -> a
06:49:35 <dataangel> How does Parsec know whether or not a space is a delimiter or a terminator? Wouldn't it have to look ahead?
06:52:09 <ivanm> How is something like enumFrom defined? is there an easy way to re-define it?
06:52:20 <ADEpt> @src enumFrom
06:52:20 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:52:31 <ADEpt> @index enumFrom
06:52:31 <lambdabot> Prelude
06:53:32 <ivanm> from the looks of the ghc source, looks like the inbuilt types use special hard-coded functions, such as boundedEnumFrom, etc.
06:54:21 <mrd> @src Enum
06:54:21 <lambdabot> class  Enum a   where
06:54:21 <lambdabot>     succ                     :: a -> a
06:54:21 <lambdabot>     pred                     :: a -> a
06:54:21 <lambdabot>     toEnum                   :: Int -> a
06:54:21 <lambdabot>     fromEnum                 :: a -> Int
06:54:23 <lambdabot> [3 @more lines]
06:54:28 <mrd> @more
06:54:29 <lambdabot>     enumFrom                 :: a -> [a]
06:54:29 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
06:54:29 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
06:54:38 <MyCatVerbs> Hrmn. I have some IOArray-abusing code here and I'm not sure if it's type safe. What happens is that each element in the IOArray is a tuple of a pair of QSems and a couple of other data members.
06:54:44 <MyCatVerbs> Er, threadsafe, I mean.
06:54:55 <mrd> > enumFrom 1
06:54:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:55:00 <roconnor> @pl (\x y -> f (g x y)).
06:55:00 <lambdabot> (line 1, column 21):
06:55:00 <lambdabot> unexpected end of input
06:55:00 <lambdabot> expecting white space or simple term
06:55:01 <roconnor> @pl (\x y -> f (g x y))
06:55:01 <lambdabot> (f .) . g
06:55:04 <mrd> > iterate succ 1
06:55:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:55:22 <Ben`> how can I make GHC compile to C?
06:55:27 <mrd> @src Int enumFrom
06:55:27 <lambdabot> Source not found. There are some things that I just don't know.
06:55:27 <ivanm> well, I suppose that's one way of doing it
06:56:37 <MyCatVerbs> What happens is that two threads each readArray on the IOArray to pull the record out, then waitQSem on one of the two semaphores in it (left thread always waits on the left semaphore, right thread always waits on the right semaphore), then does something interesting with the internal values, writeArray's the updated value back in and then signalQSems the semaphore which the other thread will be looking at later.
06:57:12 <MyCatVerbs> Is that safe? I know the semaphore design is (I'm duplicating a program I've written before in C here) but I have no clue whether IOArrays can be messed around with in this fashion.
06:58:06 <sieni> A Windows C program?
06:58:20 <MyCatVerbs> sieni: nope. pthreads and POSIX semaphores on Loonix.
06:58:25 <yaxu> mapN f xs = map f $ zip [0 ..] xs -- this seems useful, is there a library function for it? (or something similar)
06:58:33 <sieni> MyCatVerbs: strange :-)
06:59:10 <MyCatVerbs> sieni: I don't use Windows machines, as a general rule.
06:59:38 <jedbrown> yaxu: zipWith ?
07:00:14 <MyCatVerbs> sieni: well, I do, but I don't. Which is to say, the only programs I ever run on 'doze boxes are web browsers (for when there isn't a better computer nearby), videogames (and those rarely, Wine gets better by the day ^_^) and SSH clients, so that I can use them as dumb-terminals to log into real computers. =D
07:11:06 <fasta> MyCatVerbs: Does Wine work better with a Windows installation?
07:11:18 <quicksilver> yaxu: not really, no. it's mapM (f <*> supply) for a certain kind of supply monad
07:11:23 <quicksilver> (applicative, actually)
07:11:31 <Zao> fasta: Irrelevant, unless you steal select DLLs from it.
07:11:31 <quicksilver> but I don't that's more useful
07:11:34 <MyCatVerbs> fasta: uh, I've only ever used it on pure Loonix boxes.
07:11:52 <fasta> Zao: yes, I referred to that practice.
07:11:55 <MyCatVerbs> fasta: you _can_ steal DLLs from a Windows installation, but AFAIK there's not much point.
07:12:11 <MyCatVerbs> fasta: I've never tried it myself, though, maybe there is? *shrug*
07:12:13 <fasta> MyCatVerbs: odd, since I never have gotten any game working on it (just to test)
07:12:34 <yaxu> ok thanks
07:12:35 <fasta> MyCatVerbs: besides solitaire ;)
07:12:46 <MyCatVerbs> fasta: I've wasted a few days here and there playing Day of Defeat on it quite happily.
07:13:04 <MyCatVerbs> Well... except for the part where I went and wasted several days. x_x
07:13:11 <yaxu> it's a bit like a for loop with an index
07:13:53 <fasta> MyCatVerbs: based on the Source engine?
07:14:37 <MyCatVerbs> fasta: no, I don't own any of the Source games. I'm led to understand that the picture for those isn't so rosy, but I don't actually know.
07:14:58 <hpaste>  matthew-_ pasted "on the expansion of fix" at http://hpaste.org/3876
07:15:01 <quicksilver> yaxu: most people would prefer to write zipWith f [0..] xs
07:15:07 <quicksilver> yaxu: than the zip version
07:15:21 <quicksilver> yaxu: (the zipWith version doesn't use tuples)
07:15:27 <matthew_-> could some ppl have a quick look at the above paste and let me know whether I've just confused myself or whether that seems about right?
07:16:42 <yaxu> quicksilver: gotcha, yes that is nicer
07:16:45 <mauke> matthew_-: that doesn't seem quite right
07:17:19 <matthew_-> mauke: well, I'm being eager, which I guess is wrong. I wasn't expecting the doubling - maybe that just happens if you are eager...?
07:17:33 <mauke> you're not sharing evaluated results
07:17:36 <MyCatVerbs> @index fix
07:17:36 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
07:18:10 <matthew_-> mauke: I don't understand what you mean by that
07:18:48 <mauke> when evaluating x = 1 : map succ x, it doesn't insert a copy of x into succ
07:19:00 <mauke> i.e. you don't get x = 1 : map succ (1 : map succ x)
07:19:14 <matthew_-> oh bugger. Then I can see that I'm wrong ;)
07:19:14 <mauke> er, into map
07:19:27 <mauke> it's just a pointer to the same thunk
07:19:31 <MyCatVerbs> See, I was so lazy, I just typed that straight into ghci.
07:19:42 <MyCatVerbs> Then let it run for a few minutes, waited to see if the output would slow down.
07:20:06 <MyCatVerbs> If it did get slower, I'd then take that as a sign that the algorithm was producing individual elements slower than O(1) each. =D
07:20:15 * MyCatVerbs <-- very very lazy. ^_^
07:20:41 * Olathe is
07:20:51 <matthew_-> mauke: ahh, ok but if we're talking conceptually rather than how the actual implemention works, am I still wrong?
07:21:04 <mauke> no
07:21:50 <mauke> x = 1 : map succ x@(1 : _) ---> x = 1 : x'@(2 : map succ x') ---> x = 1 : 2 : x''@(3 : map succ x'')
07:21:59 <mauke> ^ I think that's how the actual implementation proceeds
07:22:16 <mauke> but if you don't share results and copy everything, you still get the same values out
07:22:24 <matthew_-> yep.
07:22:27 <matthew_-> ok, thanks.
07:24:26 <matthew_-> mauke: actually, that confuses me - in "x = 1 : map succ x@(1 : _)", how can it know to throw duplicate the 1: but throw away the second map succ ? Is this just the laziness?
07:24:53 <mauke> it doesn't actually duplicate the 1:
07:25:10 <mauke> I just wrote that so I could "peek" into the structure of x
07:25:28 <quicksilver> "map suc" duplicates the 1. In the slightly strange sense that it builds a 2 out of it.
07:25:40 <quicksilver> but there is only ever 1 1.
07:25:51 <mauke> I think this could be simplified a lot by using an animated 2D diagram :-)
07:26:01 <matthew_-> nah, I get it. Cheers.
07:26:24 <quicksilver> mauke: I wish there was a program to generate attractive animated 2D diagrams like that :)
07:26:39 <quicksilver> mauke: would be really nice for explaining + understanding haskell reductions.
07:26:57 <ToRA> > 1 : map succ ( 1 : (map succ ( 1 : map succ ( 1 : []))))
07:26:58 <matthew_-> it would probably never terminate on fix programs though ;)
07:26:59 <lambdabot>  [1,2,3,4]
07:27:13 <ToRA> where [] is not [] is the expansion
07:27:29 <matthew_-> ToRA: yes, that was what I was doing - read the paste
07:27:33 <Saizan_> matthew_-: your reduction is what happens if you write fix as fix f = f (fix f)
07:27:56 <quicksilver> matthew_-: it wouldn't be intended to terminate
07:28:05 <ToRA> i did, except you were doubling the number of steps you were evaling each time
07:28:06 <quicksilver> matthew_-: it would be intended to generate an animation for you to watch :)
07:28:09 <ivanm> If you're using foldr on an infinite list, the only time it will terminate is if you're using a lazily-evaluated function, right? e.g. (&&) for and
07:28:25 <quicksilver> ivanm: all functions are lazily evaluated.
07:28:28 <matthew_-> quicksilver:)
07:28:40 <osfameron> where it's not strict on the 2nd argument you mean?
07:28:40 <mauke> "non-strict"
07:28:41 <quicksilver> ivanm: what you mean to say is that must be non-strict on the right.
07:28:45 <ivanm> osfameron: yes
07:28:54 <quicksilver> then, yes
07:29:01 <quicksilver> although even non-terminating folds can be useful
07:29:08 <quicksilver> because you can "take 10" a non-termination fold
07:29:12 <quicksilver> if it is productive.
07:29:26 <osfameron> folds can produce?
07:29:36 <ivanm> hmmm..... I'm trying to work out how to define such a function to evaluate terms in a taylor series up to a given precision
07:29:41 <scook0> osfameron: sure
07:29:44 <quicksilver> "productive" is a term meaning that although a function doesn't terminate
07:29:49 <quicksilver> it still produces constructors
07:29:55 <quicksilver> which you can consume from another function
07:29:59 <quicksilver> so it does useful work
07:30:05 <quicksilver> [1..] doesn't terminate.
07:30:08 <quicksilver> but it is productive
07:30:20 <matthew_-> > let x = 1 : map succ ( 1 : (map succ ( 1 : map succ ( 1 : x)))) in take 20 x
07:30:22 <lambdabot>  [1,2,3,4,4,5,6,7,7,8,9,10,10,11,12,13,13,14,15,16]
07:30:28 <matthew_-> ToRA: nice one ;)
07:30:54 <ToRA> matthew_-: who said [] was x?
07:30:59 <ToRA> matthew_-: ;)
07:31:05 <scook0> also, remember that folds don't have to reduce a list to a "simple" value
07:31:14 <matthew_-> @src fix
07:31:14 <lambdabot> fix f = let x = f x in x
07:31:24 <matthew_-> ToRA: Î»b :P
07:31:32 <scook0> (e.g. map is a catamorphism)
07:32:22 <ivanm> I thought catamorphisms were those that reduced lists to simple values...
07:32:47 <ivanm> *sigh* looks like I need to keep track not only of the current running total, but also the previous running total
07:33:53 <quicksilver> sounds like the state applicative to me!
07:34:02 <quicksilver> or possibly the state monad
07:34:32 <ivanm> quicksilver: needs to be simple... it's a CS paper
07:34:52 <ivanm> on how data structures can be replaced with fold-like functions
07:35:08 <ivanm> specifically with respect to Exact Real Arithmetic
07:35:44 <ivanm> here I was, thinking I could provide a concrete example using taylor series by folding over a list of terms, but I'm getting bogged down in how to terminate the fold :s
07:38:30 <roconnor> @pl \x y -> f (g x y) (h x y)
07:38:30 <lambdabot> ap (ap . (f .) . g) h
07:38:36 <roconnor> :(
07:39:40 <integral> @pl \x -> f (g x) (h x)
07:39:40 <lambdabot> liftM2 f g h
07:39:44 <integral> @type curry
07:39:45 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:39:58 <integral> curry $ liftM2 f (uncurry g) (uncurry h)
07:40:04 <roconnor> My applicative functor also has the following law
07:40:14 <byorgey> roconnor: it's liftM2 for the Reader^2 monad =)
07:40:31 <integral> @type curry $ liftM2 f (uncurry g) (uncurry h)
07:40:32 <lambdabot> Not in scope: `f'
07:40:32 <lambdabot> Not in scope: `g'
07:40:32 <lambdabot> Not in scope: `h'
07:40:38 <roconnor> const <$> x <*> y === y
07:40:43 <roconnor> I think that is right
07:40:47 <mauke> @type a b c d e f g h i j
07:40:47 <lambdabot> Not in scope: `a'
07:40:47 <lambdabot> Not in scope: `b'
07:40:47 <lambdabot> Not in scope: `c'
07:41:04 <roconnor> what does this type of applicative functor (or monad) have a name?
07:41:11 <roconnor> const <$> x <*> y === x
07:41:18 <roconnor> sorry
07:41:20 <allbery_m> @ty curry $ liftM2 ?f (uncurry ?g) (uncurry ?h)
07:41:20 <lambdabot> forall r c a b c1. (?f::c -> c1 -> r, ?g::a -> b -> c, ?h::a -> b -> c1) => a -> b -> r
07:41:37 <integral> @karma+ allbery_m
07:41:37 <lambdabot> allbery_m's karma raised to 1.
07:42:00 <yaxu> every time i rewrite this code it gets smaller
07:42:12 <yaxu> and the law of diminishing returns doesn't seem to apply
07:44:03 <byorgey> ivanm: paste some of your code, perhaps?
07:44:27 <ivanm> byorgey: OK, but I'm warning you, this code won't actually work! (it won't type check)
07:44:33 <ivanm> @paste
07:44:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:45:36 <glen_quagmire> explain this: succ = (\n f x -> f (n f x))
07:45:48 <byorgey> well, if we only let people paste working code, there wouldn't be much point, now would there? =)
07:46:06 <integral> glen_quagmire: it's an equation defining a value called succ
07:46:23 <byorgey> glen_quagmire: you know about Church numerals?
07:46:28 <glen_quagmire> integral: how come that is a successor function? it says it goes from one church numeral to another
07:46:51 <glen_quagmire> byorgey: church numerals are now many times you iterate on a function, f ?
07:46:51 * integral points at byorgey's question :-)
07:47:08 <glen_quagmire> f(x) = 1,   f(f(x)) = 2...
07:47:15 <byorgey> glen_quagmire: a church numeral is a function n which iterates another function that many times.
07:47:44 <integral> so succ has to construct  a function that iterates another function one more time than the number it is given
07:47:48 <byorgey> 1 === \n f x -> f x, 2 === \n f x -> f (f x), etc.
07:48:30 <mauke> hmm. would \n f x -> n f (f x) also work?
07:48:58 <byorgey> I think so.
07:49:08 <byorgey> @type \n f x -> f (n f x)
07:49:09 <lambdabot> forall t t1 t2. ((t1 -> t2) -> t -> t1) -> (t1 -> t2) -> t -> t2
07:49:12 <integral> that seems more obvious
07:49:19 <byorgey> @type \n f x -> n f (f x)
07:49:20 <lambdabot> forall t t1 t2. ((t -> t1) -> t1 -> t2) -> (t -> t1) -> t -> t2
07:49:22 <glen_quagmire> > (\n f x -> f (n f x)) 3 (+1) 0
07:49:24 <lambdabot>        add an instance declaration for (Num ((a -> a) -> t -> a))
07:49:34 <integral> different strictness?
07:49:53 <glen_quagmire> functional programming is too hard
07:50:09 <fozze> sicp is too hard
07:50:27 <integral> succ undefined (constant 2) undefined == 2 -- in the first definition
07:50:28 <hpaste>  mauke pasted "HList troubles" at http://hpaste.org/3877
07:50:50 <mauke> can anyone explain that error to me?
07:50:59 <ski> roconnor : the effect is discardable
07:51:58 <hpaste>  ivanm pasted "Taylor series" at http://hpaste.org/3878
07:52:37 <ivanm> byorgey: without a re-written type system, the actual code will _never_ work
07:52:47 <ivanm> since it assumes fusing the fold with the list, etc.
07:53:04 <ivanm> as it stands, that code defined there should work, kinda
07:54:30 <ivanm> if possible, I'd like to avoid using tuples...
07:54:38 <quicksilver> mauke: the problem is this dummy type a/w in your HList
07:54:55 <mauke> quicksilver: what's wrong with it?
07:55:03 <ivanm> but if I have to, I'd prefer it if the tuples are passed through the fold function rather than using zip or some such with the list
07:55:05 <quicksilver> mauke: your 'find' method doesn't mentiond 'a', so using 'find' doesn't pin down the choice of a
07:56:13 <ski> byorgey : do you want to use church numerals ?
07:56:14 <quicksilver> mauke: hmm. no. just a minute :)
07:56:29 <mauke> quicksilver: why no? :-)
07:56:31 <byorgey> ski: hm?
07:56:38 <mauke> it works if I add a w parameter to find
07:56:43 * quicksilver nods
07:56:49 <ski> byorgey : sorry, s/byorgey/ivanm/
07:56:51 <quicksilver> I wasn't explaining it well, though
07:57:24 <quicksilver> mauke: the problem is that there is, in principle, a different instance of 'find' depending on which 'a'
07:57:33 <quicksilver> mauke: but the compiler has no way of telling which you mean
07:57:42 <tim> Can anyone suggest how to synchronize with a thread (a `join' = wait until it completes)? I've been looking in Contorl.Concurrent and can't find anything.
07:57:45 <ivanm> ski: not particularly... I can do, but the g function would be taking in an Int value
07:57:49 <quicksilver> in general, if you have a method which fails to mention every type from the class head, you need a fundep
07:57:57 <quicksilver> otherwise it's too ambiguous to use.
07:58:05 <ivanm> byorgey: I've hpasted my code...
07:58:19 <mauke> can't use a fundep here because EOT has to be "polymorphic"
07:58:21 <ivanm> in case you didn't see the announcement above :p
07:58:27 <byorgey> ivanm: I did, thanks.
07:58:37 <ivanm> k
07:58:44 <dcoutts> tim: you've got to get the thread to write into an MVar, then in your main thread you take that MVar, which blocks until the other thread writes into it
07:58:48 <byorgey> ivanm: I'm looking at it... I don't know if I'll end up having any suggestions, but it's interesting to think about at least...
07:58:51 <ski> ivanm : why do you need a rewritten type-system ?
07:59:10 <dcoutts> tim: see for example http://haskell.org/~duncan/cabal/dep-experiment/JobPool.hs
07:59:13 <ivanm> ski: in actual fact, cons /= (:)...
07:59:34 <ivanm> cons x xs op b = fold op b (x:xs); nil op b = fold op b []
07:59:43 <ivanm> and type systems won't like that :p
07:59:58 <ski> ivanm : `fold' being ?
08:00:06 <ivanm> foldr, sorry
08:00:15 <dcoutts> tim: that example provides a little api with launch and collect
08:00:20 <tim> dcoutts: Many thanks.
08:00:23 <quicksilver> mauke: otherwise you have to add a dummy argument to find
08:00:24 <ivanm> I'm so used to talking about "fold" that I keep forgetting that it should actually be "foldr"
08:00:24 <ski> @type \op b -> foldr op b []
08:00:25 <lambdabot> forall a b. (a -> b -> b) -> b -> b
08:00:25 <quicksilver> mauke: of type 'a'
08:00:31 <quicksilver> mauke: to help it select the right instance
08:00:32 <ski> @type \x xs op b -> foldr op b (x:Xs)
08:00:33 <lambdabot> Not in scope: data constructor `Xs'
08:00:34 <ski> @type \x xs op b -> foldr op b (x:xs)
08:00:34 <lambdabot> forall a b. a -> [a] -> (a -> b -> b) -> b -> b
08:00:36 <mauke> quicksilver: yeah
08:00:57 <quicksilver> you can pass in (undefined `asTypeOf` a)
08:00:59 <quicksilver> sort of thing
08:01:01 <quicksilver> if you want
08:01:07 <ivanm> @type \ op b -> foldr op b []
08:01:08 <lambdabot> forall a b. (a -> b -> b) -> b -> b
08:01:15 <fons> Hi all
08:01:17 <ivanm> ^^ but they're both lists!
08:01:24 <ski> ivanm : what about it doesn't type-systems like ?
08:01:29 <ivanm> "nil" and "cons x xs" are both lists...
08:01:40 <ivanm> well, pseudo-lists...
08:01:52 <ivanm> except they both take in two parameters
08:02:22 <ski> ivanm : btw, are you sure `xs' in `cons x xs' shouldn't be a list represented in the same way as `nil' and `cons x xs' is a representation of a list ?
08:02:34 <byorgey> ivanm: I don't understand taylor_terms then.  did you create your own version of 'map' that works on these function-lists?
08:02:36 <ivanm> it is
08:02:42 <ivanm> byorgey: yes
08:02:47 <byorgey> ok
08:02:51 <ivanm> heh
08:03:16 <ski> ivanm : i.e., should `cons' take an element and an ordinary list .. or an element and a "function-list" ?
08:03:27 <ivanm> the latter
08:03:30 <ski> ok
08:03:41 <roconnor> ski: my applicative functor / monad is the nicest thing possible.  It is like the reader monad.
08:03:53 <ski> type ChurchList a = forall o. (a -> o -> o) -> o -> o
08:03:57 <ski> ivanm : try using that
08:04:00 <ivanm> map f xs = xs (\ x ys -> cons (f x) ys) []
08:04:05 <roconnor> There has to be a name for this super niceness.
08:04:34 <ski> roconnor : the property you stated above is called `discardable effect', i think
08:04:35 <ivanm> ski: you get into problems with recursive types
08:04:48 <ski> ivanm : where ?
08:05:09 * ivanm finds the actual paper dealing with this
08:05:11 <ski> (if you prefer, you can explain with church numerals instead)
08:05:28 <dataangel> Is there something in a monad for changing M a to M ()? In parsec I want to combine using <|> a Parser () with a Parser Char, but I don't actually care about the value from the Parser Char. If I were sequencing I know I could use >>, but I dunno what to do for <|>
08:05:32 <ivanm> ski: http://www.itee.uq.edu.au/~paul/tfp-papers/txt-12.pdf
08:05:40 <quicksilver> dataangel: >> return ()
08:05:51 <dataangel> that makes sense :P
08:05:54 <ivanm> I didn't look too much into that myself, just took it at face value
08:06:07 <quicksilver> dataangel: (charparser >> return ()) <|> (otherparser)
08:06:10 <ski> roconnor : there's some continuation paper that (amongst other things) shows that continuation effects in general are neither discardable nor copyable (and of course not commutative, either)
08:06:11 <roconnor> ski: what would you call  join <$> f <*> a === f <*> a <*> a  ?
08:06:19 <roconnor> ah
08:06:21 <roconnor> copyable?
08:06:22 <ski> roconnor : copyable
08:06:37 <roconnor> is there a list of these conditions somewhere?
08:06:45 <quicksilver> you might also call that affine?
08:06:46 <ivanm> ski: OK, using church numerals...
08:06:54 <ski> (roconnor : it might have been one of Hayo Thielecke's or Olivier Danvy's papers)
08:07:15 <ivanm> add n1 n2 = n1 succ n2
08:07:25 <ivanm> mul n1 n2 = n1 (add n2) zero
08:07:26 <quicksilver> dataangel: sometimes I want a combinator called 'ignore' which is "ignore foo = foo >> return ()"
08:07:31 <roconnor> so commutative, copyable, discarable monad ?
08:07:41 <quicksilver> :t let ignore foo = foo >> return () in ignore
08:07:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
08:07:52 <ivanm> ski: so: exp m n = n (mul m) (succ zero)
08:08:16 <dataangel> quicksilver: that would be nice
08:09:09 <ski> (ivanm : which part of that paper ?)
08:10:30 <ski> roconnor : i haven't seen the words applied to monads (nor idioms), but i think it's an obvious generalization
08:10:53 <ivanm> ski: I take it back... I trusted the paper, which said it didn't type check... :s
08:10:54 <roconnor> ski: you've seen them applied to continuations?
08:11:09 <ivanm> well, with regard to the church numerals, anyway...
08:11:14 <ski> roconnor : yes, to continuation effects
08:11:37 <ski> (it might be that the paper also briefly explained wrt state effects, for comparision)
08:12:06 <ski> ivanm : did you just try those declarations without type signatures ?
08:12:13 <ivanm> that's what I'm doing now...
08:12:18 <ivanm> "cannot find object file for module `main:Prelude'
08:12:18 <ivanm>     while linking an interpreted expression"
08:12:26 <ivanm> that's what I get when I actually try to use them...
08:12:58 <ski> strange error
08:13:00 <ski> @type let succ n s z = s (n s z) in succ
08:13:02 <lambdabot> forall t t1 t2. ((t -> t1) -> t2 -> t) -> (t -> t1) -> t2 -> t1
08:13:07 <ski> @type let succ n s z = n s (s z) in succ
08:13:08 <lambdabot> forall t t1 t2. ((t -> t1) -> t1 -> t2) -> (t -> t1) -> t -> t2
08:13:29 <ski> @type let succ n s z = s (n s z); add n1 n2 = n1 succ n2 in add
08:13:29 <lambdabot> forall t t1 t2 t3 t4. ((((t -> t1) -> t2 -> t) -> (t -> t1) -> t2 -> t1) -> t3 -> t4) -> t3 -> t4
08:14:03 <ski> @type let succ n s z = s (n s z); add n1 n2 = n1 succ n2; mul n1 n2 s z = n1 (add n2) z s z in mul
08:14:04 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. ((t -> t1) -> t2 -> t3 -> t2 -> t4) -> ((((t5 -> t6) -> t7 -> t5) -> (t5 -> t6) -> t7 -> t6) -> t -> t1) -> t3 -> t2 -> t4
08:14:05 <ivanm> I get that error when I try and call "let one = succ zero"
08:14:25 <ski> anyway
08:15:03 <ski> the problem i'm assuming you were having is one caused by not using rank-2 type signatures
08:15:39 <ski> one can define `type Church a = (a -> a) -> (a -> a)'
08:15:46 <ivanm> yes
08:15:48 <ivanm> something like that
08:16:15 <ski> and if one then tries to define basic arithmetic operations, the two arguments of some of the operations have different types
08:16:56 <ski> the solution (afair) was to have instead `type Church = forall a. (a -> a) -> (a -> a)'
08:17:26 <ski> (and this then cause rank-2 type signatures)
08:18:07 <mauke> newtype Church = C { unC :: Church -> Church }
08:18:28 <ivanm> ski: it doesn't help when I have a copy of the ghc Prelude.hs source file in the same folder :s
08:19:14 <ski> (mauke : that's not the same thing)
08:19:34 <mauke> :(
08:21:30 <ivanm> ski: OK, got it... exponential doesn't type check...
08:21:33 <ivanm> it gets an infinite type
08:22:37 <ski> roconnor : "Categorical Structure of Continuation Passing Style", Hayo Thielecke, PhD thesis <http://www.cs.bham.ac.uk/~hxt/research/THESIS-FINAL.ps>, chapter 6
08:23:01 <ivanm> @type let zero s z = z; succ n s z = s (n s z); add n1 n2 = n1 succ n2; mul n1 n2 = n1 (add n2) zero in exp m n = n (mul m) (succ zero)
08:23:04 <lambdabot> parse error on input `='
08:23:13 <ivanm> grrr.....
08:23:28 <ivanm> @type exp m n = let zero s z = z; succ n s z = s (n s z); add n1 n2 = n1 succ n2; mul n1 n2 = n1 (add n2) zero in n (mul m) (succ zero)
08:23:28 <lambdabot> parse error on input `='
08:23:41 <ivanm> anyway... any ideas on the taylor series front?
08:24:09 <ski> @type let zero s z = z; succ n s z = s (n s z); add n1 n2 = n1 succ n2; mul n1 n2 = n1 (add n2) zero; exp m n = n (mul m) (succ zero) in exp
08:24:10 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10. ((t -> t1) -> (t2 -> t3 -> t3) -> t4) -> ((((((t5 -> t6) -> t7 -> t5) -> (t5 -> t6) -> t7 -> t6) -> t -> t1) -> t4) -> ((t8 -> t9) -> t8 -> t9) -> t10) ->
08:24:10 <lambdabot> t10
08:26:04 <ski> @type let zero s z = z; succ :: (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a; succ n s z = s (n s z); add :: (forall a. (a -> a) -> a -> a) -> (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a; add n1 n2 = n1 succ n2; mul :: (forall a. (a -> a) -> a -> a) -> (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a; mul n1 n2 = n1 (add n2) zero; exp :: (forall a. (a -> a) -> a -> a) -> (forall a. (a -> a) -> a -> a) -> 
08:26:06 <lambdabot> parse error (possibly incorrect indentation)
08:26:10 <ivanm> @type let zero s z = z; succ n s z = s (n s z); add n1 n2 = n1 succ n2; mul n1 n2 = n1 (add n2) zero; exp m n = n (mul m) (succ zero); one = succ zero; two = succ one in exp two two
08:26:10 <lambdabot>     Occurs check: cannot construct the infinite type:
08:26:11 <lambdabot>       t = (((t1 -> t2) -> t3 -> t1) -> (t1 -> t2) -> t3 -> t2) -> t -> t
08:26:11 <lambdabot>     Probable cause: `two' is applied to too few arguments
08:26:20 <ivanm> ^^ there we are
08:26:56 <ivanm> but I really want to finish this report off and then visit the land of nod...
08:27:15 <sebell> Hmm. Can I build GHC 6.8.1 without readline by removing it from `boot-packages'?
08:29:36 <quicksilver> ivanm: there are two ways to solve this
08:29:44 <quicksilver> ivanm: in haskell98, you solve it by 'naming' the type
08:30:10 <quicksilver> ivanm: so you get all kinds of nasty Church . unChurch stuff going on
08:30:18 <ivanm> yes, which is nasty
08:30:27 <quicksilver> in GHC I think you can also solve it with rank 2 polymorphism?
08:30:41 <ivanm> GHC has rank 2 polymorphism?
08:30:48 <quicksilver> it does indeed
08:30:51 <fasta> ivanm: it has rank-N.
08:30:55 <quicksilver> but oyu have to annotate your types explicitly to use it
08:30:56 <ivanm> heh
08:31:00 <ivanm> *nod*
08:31:09 <ivanm> do you have a link on this?
08:31:26 <quicksilver> which? rank 2 types?
08:31:32 <quicksilver> it's much as you would expect
08:31:37 <quicksilver> you just use the keyword 'forall'
08:32:18 <quicksilver> GHC can even apply a polymorphic data type like Maybe to rank-N types
08:32:22 <quicksilver> if I'm not mistaken
08:32:49 <ivanm> yes, but I'll need to be able to reference this...
08:32:54 <ivanm> or is this just in the user guide?
08:33:47 <quicksilver> it is in the user fuide
08:33:53 <quicksilver> there is also a paper on how they did it
08:34:25 <ivanm> k
08:34:25 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
08:34:27 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
08:35:00 <fasta> Hmm, debugging Haskell is easier than debugging LaTeX.
08:35:09 <Saizan_> i want record syntax for gadts
08:35:12 <quicksilver> many things are.
08:35:26 <ivanm> but that's more of an aside than anything else as far as I'm concerned... my sole goal for this report is to represent how exact real arithmetic is just a bunch of functions and represent it in using the prescribed formulations
08:35:33 <quicksilver> I really thouguht you said "I want record syntax for goats"
08:35:40 <ivanm> my prof is the one who wrote the paper said it wouldn't typecheck ;-)
08:35:56 * byorgey thinks about the possibility of a LaTeX combinator library in Haskell
08:35:56 <ivanm> *that said
08:36:03 <quicksilver> yes, well he's making an important point about the limits of H-M type inference
08:36:09 <ivanm> *nod*
08:36:10 <quicksilver> and indeed, ghc doesn't claim to infer those types
08:36:12 <quicksilver> merely check them
08:36:15 <ivanm> OK
08:36:16 <quicksilver> (and implement them)
08:36:21 <ivanm> so it's definitely user beware?
08:36:35 <quicksilver> they are very useful in, e.g, the ST monad
08:36:45 <quicksilver> and existnetials are a special case of rank-2 types
08:36:49 <quicksilver> hidden behind a constructor
08:41:06 <defcons> does anyone at Glasgow University develop GHC?
08:48:42 <ivanm> @seen roconnor
08:48:42 <lambdabot> roconnor is in #haskell-blah, ##logic and #haskell. I last heard roconnor speak 37m 48s ago.
08:48:50 <ivanm> you still around, roconnor?
08:53:34 <dons> ?userrs
08:53:34 <lambdabot> Maximum users seen in #haskell: 412, currently: 393 (95.4%), active: 11 (2.8%)
08:53:57 <chessguy> hiya #haskellites
08:54:29 <quicksilver> dons: ByteString is written in three languages.
08:54:41 <quicksilver> dons: Haskell, -RULES- and unsafe/inlinePerformIO
08:54:57 <dons> heh
08:55:01 <quicksilver> dons: what are the possibilities of getting something closer to pure haskell?
08:55:05 <dons> and you forgot the cpp
08:55:05 <osfameron> *PerformIO is a different language?
08:55:11 <quicksilver> osfameron: yes. it's not haskell.
08:55:19 <quicksilver> osfameron: it's a non-portable GHC thing.
08:55:19 <dons> well, we need to do our own memory management
08:55:33 <dons> so inlinePerformIO is required (and portable to nhc  and hugs, btw)
08:55:37 <osfameron> quicksilver: ah, I see
08:55:37 <dcoutts> quicksilver: we'd want to look at using ST and heap allocated memory blocks
08:55:51 <dons> yeah. ST but with more flexibility
08:55:59 <quicksilver> dons: perhaps a few extra primitives to hide the magick behind, which could then be used in other similar projects?
08:55:59 * osfameron still thinks haskell *is* ghc...
08:56:16 <dcoutts> dons: depends if we think the zero-copy foreign aspect of ByteStrings is essential
08:56:24 <dons> right
08:56:25 <quicksilver> currently it feels like to write something "like bytestrings but different"
08:56:30 <Igloo> quicksilver: What are rules and upIO if not extra primitives?
08:56:35 <quicksilver> I'd need to re-invent a lot of these wheels
08:56:45 <quicksilver> Igloo: they are primitives, but they're not haskell primitives.
08:56:49 <Igloo> You might prefer /different/ extra primitives, of course
08:56:54 <quicksilver> Igloo: since they're not referentially transparent.
08:56:55 <Igloo> I don't understand what you mean
08:57:13 <quicksilver> you can't give unsafePerformIO a semantics in haskell which makes sense.
08:57:22 <quicksilver> you have to actually extend your notion of semantic.
08:57:29 <dcoutts> quicksilver: the primitives that ST etc are built on are not referentially transparent either :-)
08:57:34 <quicksilver> dcoutts: right.
08:57:39 <quicksilver> dcoutts: but then, ST itself is.
08:57:47 <dcoutts> and so is ByteString
08:57:49 <quicksilver> dcoutts: and ST can be used outside to do other tricks.
08:57:52 * quicksilver nods
08:57:58 <Igloo> ST doesn't allow you to write your code in a non-monadic way
08:58:03 <noteventime> What's the difference between the different Haskell compilers that are around?
08:58:06 <quicksilver> but ST feels to me like 'implement once and its done'
08:58:10 <noteventime> Why would someone not use GHC?
08:58:21 <quicksilver> whereas bytestring feeels more like 'I'd like to write something like that, but not for strings...'
08:58:44 <quicksilver> Igloo: did I answer your question? do you understand the point I'm tring to make
08:58:48 <quicksilver> I'm not arguing to be difficult :)
08:59:18 <dcoutts> quicksilver: I take your point, it'd be nicer if it were using some of the other primitives
08:59:18 <Igloo> quicksilver: Yes, but I'm not sure you can get the same performance with referentially transparent primitives
08:59:26 <quicksilver> progamming with RULES and inlinePerformIO is in some respects like programming in C: small mistakes can have massive consequences.
08:59:39 <quicksilver> it would be nice to be able to write something like bytestring without going through that pain.
08:59:46 <quicksilver> although I'm very glad for all the people who did :)
08:59:50 <dcoutts> Igloo: I think it could be faster, mainly due to using unpinned heap blocks
08:59:55 <dons> rules are ok, i think. that's quite different to the more fragile inlining stuff
09:00:15 <quicksilver> dons: rules are at least easy to check :)
09:00:28 <quicksilver> dons: at least it's obvious which property you're asserting. You might even quickcheck them, sometimes.
09:00:52 <fasta> I think RULES are a horrible hack.
09:00:55 <reqamst> dons: does Yi supports unicode?
09:01:01 <chessguy> noteventime, i think each non-GHC compiler has its own goal
09:01:05 <fasta> But I stated that earlier already :)
09:01:10 <defcons> is the !! notation for lists part of Haskell98?
09:01:19 <fasta> defcons: yes
09:01:20 <EvilTerran> ?src (!!)
09:01:20 <lambdabot> xs     !! n | n < 0 = undefined
09:01:20 <lambdabot> []     !! _         = undefined
09:01:20 <lambdabot> (x:_)  !! 0         = x
09:01:20 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:01:25 <EvilTerran> it's just an operator :)
09:01:26 <defcons> thanks fasta
09:01:56 <dons> quicksilver: i think all our rules are quickchecked
09:02:20 <quicksilver> dons: yes, I know, that was exactly my point ;)
09:03:02 <noteventime> chessguy: Yes, I figured it'd be like that. I just can't seem to find out what they are :-)
09:03:44 <noteventime> JHC seems to do some more optimisation to the code
09:04:07 <quicksilver> yhc is sometimes said to be easier to understand/hack on, I believe
09:04:20 <quicksilver> and there are reasons to prefer YHC.Core as a core interface
09:04:24 <quicksilver> I don't know the details
09:04:32 <noteventime> Ok :-) Thanks
09:04:46 <noteventime> And Hugs is just meant to be an interactive environment?
09:05:30 <fasta> noteventime: is there even a non-trivial program that runs faster in JHC?
09:05:52 <noteventime> fasta: I don't know, I've never used it
09:05:59 <dons> the weirdest view of the origin of F# i've seen yet http://vanirsystems.com/danielsblog/?p=227
09:05:59 <lambdabot> Title: Sun Microsystems and Microsoft battling again&#8230;
09:06:05 <fasta> noteventime: then why make the comment? :)
09:06:07 <roconnor> @type ap
09:06:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:06:20 <noteventime> fasta: I checked the web page
09:06:32 <roconnor> @pl \x y -> f (g x y) (h x y)
09:06:32 <lambdabot> ap (ap . (f .) . g) h
09:06:45 <noteventime> fasta: I'm only trying to figure out the different Haskell compilers' goals are
09:06:50 <fasta> noteventime: aims/=does :)
09:07:06 <roconnor> @unpl ap
09:07:07 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
09:07:17 <quicksilver> noteventime: hugs is a nice fast interpreter
09:07:26 <quicksilver> noteventime: its fans enjoy how quick it loads files
09:07:27 <noteventime> fasta: Well, I'm not interested in does at the moment ;-)
09:07:28 <roconnor> @djinn (r -> a -> b) -> (r -> a) -> r -> b
09:07:28 <lambdabot> f a b c = a c (b c)
09:07:31 <quicksilver> personally I just use ghci
09:07:44 <roconnor> That is S?
09:07:45 <dons> noteventime: there's basically just ghc for practical use. hugs is used for small jobs on windows, everyone else uses ghc/ghci
09:08:54 <roconnor> ski: I claim that copyable and discarable implies commutative.
09:09:45 <ski> very possible
09:10:23 <roconnor> how do you write flip in the SKI calculus?
09:10:31 <quicksilver> roconnor: mauke worked it out for me the other day
09:10:35 <quicksilver> roconnor: it's REALLY long
09:10:36 <reqamst> does Yi supports unicode?
09:10:44 <roconnor> quicksilver: :(
09:10:45 <quicksilver> roconnor: 2 or three lines at 80 chars
09:10:53 <roconnor> quicksilver: really?
09:10:57 * quicksilver nods
09:11:01 <ski> @src flip
09:11:02 <lambdabot> flip f x y = f y x
09:11:04 <roconnor> quicksilver: did you have I?
09:11:05 <quicksilver> well including spaces after '('
09:11:08 <quicksilver> yup
09:11:13 <roconnor> :( :(
09:11:26 <therp> that complicated? hmm
09:13:26 <roconnor> @type let s a b c = a c (b c); k a b = a in s (k (s i)) k
09:13:30 <lambdabot> Not in scope: `i'
09:13:45 <roconnor> @type let s a b c = a c (b c); k a b = a; i a = a in s (k (s i)) k
09:13:48 <lambdabot> forall t t1. t -> (t -> t1) -> t1
09:14:18 <roconnor> ah, not quite flip
09:14:20 <mauke> quicksilver: maybe there's a shorter version
09:16:25 <ski> \f. \x. \y. f y x  =  \f. \x. c (b f i) x  =  \f. b (c (b f i)) i  =  c (b b (b c (c (b b i) i))) i
09:16:28 <ski> @type let i a = a; c f g a = (f a) g; b f g a = f (g a) in c (b b (b c (c (b b i) i))) i
09:16:29 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
09:16:32 <ski> @type flip
09:16:32 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:16:54 <quicksilver> mauke: that's true :)
09:17:42 <ski> do you want the `ski'-variant, as well ?
09:18:12 <roconnor> @type let s a b c = a c (b c); k a b = a; i a = a in (k i)k
09:18:13 <lambdabot> forall t. t -> t
09:18:27 <ski> k i k  =  i
09:19:08 <roconnor> ski: the wikipage is bizare
09:19:08 <byorgey> k i _ = i, in fact =)
09:19:13 <roconnor> wikipedia page
09:19:17 <ski> which one ?
09:19:45 <roconnor> http://en.wikipedia.org/wiki/SKI_combinator_calculus
09:19:46 <lambdabot> Title: SKI combinator calculus - Wikipedia, the free encyclopedia
09:19:57 <roconnor> ski: they define a post-fix not
09:20:11 <roconnor> infix or
09:20:15 <roconnor> and postfix and
09:20:53 <roconnor> @type let s a b c = a c (b c); k a b = a; i a = a in s (k (s i)) k i
09:20:53 <lambdabot> forall t t1. ((t1 -> t1) -> t) -> t
09:20:59 <roconnor> bah
09:21:05 <ski> you want `flip' ?
09:21:31 <ski> raw or optimized ?
09:22:07 <roconnor> ski: optimized
09:22:18 <roconnor> as long as it is conertable in Coq.
09:22:23 <roconnor> convertable
09:22:59 <ricky_clarkson> convertible
09:23:21 <roconnor> really
09:23:22 <roconnor> cool
09:23:29 <roconnor> @wn convertible
09:23:30 <lambdabot> *** "convertible" wn "WordNet (r) 2.0"
09:23:30 <lambdabot> convertible
09:23:30 <lambdabot>      adj 1: capable of being exchanged for or replaced by something of
09:23:30 <lambdabot>             equal value; "convertible securities" [syn: {exchangeable}]
09:23:30 <lambdabot>             [ant: {inconvertible}]
09:23:32 <lambdabot> [10 @more lines]
09:23:59 * roconnor wonders if 1.1 million webpages can be wrong.
09:24:12 <roconnor> when 56 million are right
09:24:23 <ricky_clarkson> There are approximately 5 million Java programmers.
09:24:26 <roconnor> ski: um, are you finding flip for me?
09:24:31 <roconnor> ricky_clarkson: ;)
09:24:40 <ski> i'm trying, yes
09:24:45 <roconnor> :D
09:25:59 <mauke> S (S (K S) (S (K K) S)) (K K)?
09:26:15 <mauke> :t ap (ap (const ap) (ap (const const) ap)) (const const)
09:26:17 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
09:26:40 <mauke> @. djinn type ap (ap (const ap) (ap (const const) ap)) (const const)
09:26:40 <lambdabot> f a b c = a c b
09:26:41 <roconnor> @type let s a b c = a c (b c); k a b = a; i a = a in s (s (k s) (s (k k) s)) (k k)
09:26:42 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
09:26:46 <byorgey> we have a winner!
09:27:01 <roconnor> that's reasonably short
09:27:10 <mauke> this time I did it intuitively
09:27:32 <mauke> last time I strictly followed the rules in http://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
09:27:32 <lambdabot> http://tinyurl.com/y47ol7
09:28:01 <tibbe> @seen xerox
09:28:01 <lambdabot> xerox is in #haskell-overflow, #haskell-blah and #haskell. I don't know when xerox last spoke.
09:28:37 <ski> \f. \x. \y. f y x  =  \f. \x. s (s (k f) i) (k x)  =  \f. s (k (s (s (k f) i))) (s (k k) i)  =  s (s (k s) (s (k k) (s (k s) (s (s (k s) (s (k k) i)) (k i))))) (k (s (k k) i))
09:28:40 <ski> @type let i x = x; k c x = c; s f g x = (f x) (g x) in s (s (k s) (s (k k) (s (k s) (s (s (k s) (s (k k) i)) (k i))))) (k (s (k k) i))
09:28:40 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
09:28:58 <ski> it seems one can optimize that one quite a bit more :)
09:29:14 <roconnor> ski: how did you generate yours?
09:29:30 <ski> bottom-up traversal
09:30:08 <mauke> (s (k k) i) = k
09:30:26 <ski> \x. x  =  i
09:30:29 <dons> wow, joelr's bio is pretty amazing. :)
09:30:38 <ski> \x. c  =  k c
09:30:41 <ski> \x. (f x) (g x)  =  s (\x. f x) (\x. g x)
09:30:47 <ski> and optimizations
09:31:06 <ski> \x. (f x) g  =  s (\x. f x) (k g)
09:31:20 <ski> \x. f (g x)  =  s (k f) (\x. g x)
09:31:28 <mauke> SKI conversion is just lifting into Reader
09:31:50 <ski> roconnor : start at innermost abstractions, push inward until removed, repeat
09:33:26 <roconnor> @type let s a b c = a c (b c); k a b = a; i a = a in (s (k s) (s (k k) s)) (k k)
09:33:26 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2) -> t -> t1 -> t3 -> t2
09:33:46 <ski> (and yes, those `f x' and `g x' in the rules are meant to be matched against expressions containing `x')
09:33:47 <roconnor> @type let s a b c = a c (b c); k a b = a; i a = a in (s (k s) (s (k k) s))
09:33:47 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
09:34:03 <roconnor> ugh
09:34:14 <defcons> Is there a way I can view GHC's cvs from my browser?
09:37:19 <byorgey> defcons: GHC uses darcs, not cvs.  I don't think darcs has a web interface.
09:37:32 <byorgey> defcons: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
09:37:35 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/y3nvjj
09:37:50 <roconnor> there we go
09:38:09 <roconnor> Goal forall A B C (f:A -> B -> C) a b,
09:38:09 <roconnor>   (flip f a b) = (s (s (k (@s _ _ _)) (s (k (@k _ _)) (@s _ _ _))) (k (@k _ _))) f a b.
09:38:09 <roconnor> reflexivity.
09:38:09 <roconnor> Qed.
09:38:18 <dons> ?seen yaxu
09:38:18 <lambdabot> I saw yaxu leaving #haskell 1h 51m 16s ago, and .
09:38:18 <defcons> byorgey, I just need List.hs :(
09:38:32 <ski> roconnor : why did you want this, btw ?
09:38:44 <dons> ?tell yaxu can you add your blog to planet haskell? just ping `ibid' here with the rss feed
09:38:44 <lambdabot> Consider it noted.
09:39:13 <therp> roconnor: what's this Goal notation?
09:39:14 <ddarius> @seen shapr
09:39:14 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 11h 59m 52s ago.
09:39:15 <roconnor> ski: I have a copyable, discarable, applicative functor.
09:39:27 <byorgey> defcons: oh, in that case... the sources used to be linked from the library documentation website, but they aren't now =(
09:39:32 <byorgey> I think that will be fixed soon (?)
09:39:46 <roconnor> I want to prove it is commutative.
09:39:51 <ski> roconnor : ah
09:39:54 <defcons> damn
09:40:07 <roconnor> ski, if I am correct, the above is the proof.
09:40:14 <roconnor> or at least the heart of the proof.
09:40:36 <therp> roconnor: is this some kind of formal language? Goal ..., @s _ _ _?
09:40:48 <roconnor> therp: it is Coq.
09:40:55 <byorgey> defcons: wait, here you go: http://haskell.org/ghc/docs/6.6.1/html/libraries/base/Data-List.html
09:40:55 <lambdabot> http://tinyurl.com/ytshrj
09:41:02 <roconnor> therp: s has three type arguements that are normally implicit.
09:41:04 <byorgey> defcons: click on the "Source Code" link in the upper right
09:41:13 <defcons> thank you byorgey
09:41:31 <roconnor> therp: but when you just write s by itself, it does't know if you want to infer the implict arguments or not.
09:41:33 <therp> roconnor: ah I was looking into theorem provers last week, Coq was among the candidates, any remarks about Coq, Isabelle or PVS? (or something you can recommend)
09:41:51 <roconnor> therp: so s defaults to it's regular type.
09:42:10 <roconnor> therp: so @s means, I'll make all the arguments explicit
09:42:17 <roconnor> therp: and the _
09:42:20 <therp> roconnor: ok
09:42:29 <roconnor> therp: and the _'s in (@s _ _ _) say, please infer this parameter.
09:43:34 <therp> PVS looked best to me, but it seems orphaned.
09:43:54 <therp> just from a quick glance. I was just trying to select one theorem prover to start toying with
09:45:18 <roconnor> okay, time for dinner
09:45:30 <therp> roconnor: any experience with other theorem provers?
09:45:36 <therp> roconnor: bon appetit
09:45:40 <roconnor> therp: not really
09:45:59 <byorgey> anyone know why you wouldn't be able to define the operator (#)?
09:46:29 <byorgey> when I try to, I get a parse error on the ')'
09:46:47 <byorgey> this is with ghc 6.8.1, I'm pretty sure I've defined (#) before...
09:46:53 <Lemmih> > let (#) = flip ($) in [1..10]#length
09:46:54 <lambdabot>  10
09:47:35 <Lemmih> byorgey: Works with 6.8.1 for me.
09:47:56 <Olathe> > let (#) = (++ "!!").(>> "AA") in (#) "Hello"
09:47:56 <lambdabot>  "AAAAAAAAAA!!"
09:47:58 <Lemmih> byorgey: You're probably using -fglasgow-exts.
09:48:12 <byorgey> Lemmih: no, I'm not
09:48:28 <Lemmih> byorgey: Try '( # )'.
09:49:06 <byorgey> Lemmih: hmm, that works
09:49:25 <byorgey> also, I only get the error when loading the module into ghci.  I can compile it fine.
09:49:32 <ddarius> unboxed tuples use the syntax (# #)
09:49:54 <byorgey> hm, but should that cause (#) to fail to parse?
09:49:57 <Lemmih> byorgey: Have -fglasgow-exts in your .ghci file?
09:50:18 * byorgey smacks forehead
09:50:26 <byorgey> yes =)
09:51:19 <Lemmih> Yay, I'm the Gregory House of Haskell! :)
09:51:38 * Olathe backs away.
09:52:06 <Saizan_> ISO8859_1 is just the first 256 codepoints of unicode?
09:52:59 <mauke> yes
09:53:45 <mauke> without lambda, life would be pointless
09:54:24 <jbalint> 256?
09:54:35 <jbalint> anything above 7f is encoded into multiple bytes
09:55:04 <Syzygy-> jbalint: Doesn't that really depend on WHICH encoding you use?
09:55:10 <Syzygy-> jbalint: Or are you defaulting to UTF8?
09:55:24 <idnar> he said codepoints
09:55:29 <idnar> and I believe that's correct
09:55:44 <jbalint> ah, sorry. that i dont know. yeah Syzygy-, i was assuming :p
10:01:48 <newsham> jbalint: in utf-8 anything above 0x7f is encoded in multiple bytes.  there are other ways of transmitting unicode characters.
10:03:05 <jbalint> thanks
10:06:27 <vincenz> newsham: like in clay models?
10:07:26 <newsham> i suppose thats possible.  I dont know if that is standardized.
10:11:10 <matthew_-> one can transmit more than unicode in clay
10:11:34 <vincenz> we should standardize
10:12:58 * vincenz proposes a 5% iron solution
10:13:58 * matthew_- knows nothing about clay
10:14:43 <byorgey> hmm, does unicode include cuneiform characters?
10:15:48 <vincenz> lol
10:15:55 <vincenz> my shell just went "KABOOOOM!!!"
10:16:02 <vincenz> 'Whoops, command-not-found has crashed! '
10:19:17 <shapr> Good afternoon!
10:20:56 <shapr> ddarius: You called?
10:21:53 <chessguy> @get-slappy
10:21:53 <lambdabot> Unknown command, try @list
10:21:56 <chessguy> @get-slap
10:21:56 <lambdabot> shapr!!
10:23:04 <shapr> ?
10:25:43 <atom> the general word is that some programming languages are good for some things, and some for others. My question: how's haskell for writing AI?
10:25:55 <atom> normal, classical chess-style AI
10:27:39 <newsham> ?where whyfp
10:27:39 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
10:27:50 <newsham> that paper uses a classical chess-style AI problem as an example
10:27:50 <shapr> atom: It's just fine.
10:28:02 <atom> newsham: thanks.
10:28:23 <newsham> demonstrating how laziness is useful for search algorithms
10:28:25 <shapr> I'm probably biased, I think Haskell has beautiful abstractions that make programming much simpler.
10:28:56 <vincenz> beautifully simple :)
10:29:08 <shapr> Salut Christophe!
10:29:12 <shapr> What's up with you?
10:29:16 <atom> I'm asking because I haven't written any AI before, and I'm sort of deciding whether I should try and tackle the big problem of AI using haskell that I'm not that proficient with and learn haskell in between (hard problems is where haskell shines, right?) or if I should just slack and use... something else
10:29:19 <vincenz> Workinig :)
10:29:33 <vincenz> atom: AI is a rather broad term
10:29:51 <shapr> atom: I'd say that Haskell shines at producing clear approaches to hard problems.
10:30:01 <shapr> Hard problems are just hard :-)
10:30:05 <vincenz> shapr: and you?
10:30:13 <vincenz> shapr: ah, well I had this theory about that on my blog
10:30:16 <vincenz> problems vs solutions
10:30:23 <vincenz> easy problems, easy solutions: what you're taught in school
10:30:24 <shapr> Sounds interesting, I'll have to go check it ou.t
10:30:27 <shapr> Yeah
10:30:31 <vincenz> easy problems, complex solutions: what enterprise people do
10:30:36 <fasta> vincenz:  :)
10:30:38 <vincenz> complex problems, complex solutions: well, that's engineering
10:30:46 <vincenz> complex problems, simple solutions: science :)
10:30:49 <roconnor> @ 1 USD in YEN
10:30:52 <roconnor> @go 1 USD in YEN
10:30:54 <lambdabot> http://www.x-rates.com/d/JPY/USD/data30.html
10:30:54 <lambdabot> Title: Exchange Rates Data (American Dollar, Japanese Yen)
10:31:00 <roconnor> @go 1 USD in JPY
10:31:01 <lambdabot> 1 U.S. dollar = 109.974706 Japanese yen
10:31:05 <shapr> I think easy solutions to complex problems is genius.
10:31:10 <vincenz> and I think haskell falls in the latter :)
10:31:14 <vincenz> shapr: agreed :)
10:31:16 <fasta> That's not science.
10:31:23 <vincenz> s/science/research?
10:31:26 <MyCatVerbs> fasta: what's not science?
10:31:37 <vincenz> you're right, it's art
10:31:47 <fasta> Computer Science simplifies problems such that they don't have anything to do with actual problems anymore.
10:31:52 <shapr> atom: Anyway, I think that learning to write a chess AI in Haskell will let you learn the most in the least time.
10:31:58 <vincenz> fasta: I never said 'comp' science
10:32:07 <atom> shapr: that's a very helpful opinion
10:32:11 <fasta> vincenz: I know that.
10:32:11 <newsham> atom: if you'r ejust learning AI and your goal is to learn AI, and you dont know haskell well yet, you should probably learn it in whatever language your book/materials/etc use.
10:32:16 <vincenz> atom: anywho, what sort of AI?  Tree-explorations like chess?  Neural networks? MAchine learniing?
10:32:21 <vincenz> Image recognition?
10:32:30 <vincenz> for the latter I'd propose matlab if anything
10:32:32 <fasta> vincenz: but since science contains computer science....
10:32:33 <newsham> if you're goal is to also learn haskell, you can do it at the same time, but you're learnign two things at once
10:32:35 <atom> vincenz: tree-explorations like chess.
10:32:40 <vincenz> fasta: I disagree :)
10:32:43 <atom> newsham: that's what I'm best at
10:32:48 <shapr> atom: My specific reasoning is that Haskell strongly encourages separation of concerns, more than other languages I've used.
10:32:52 <newsham> atom: then go for it,  haskell's great. :)
10:32:52 <vincenz> fasta: computer is not science, science is based on the empirical method, compsci is not
10:32:57 <atom> newsham: I learn best if I just throw myself into the water and swim
10:32:59 <vincenz> erm, add a 'sci' in there
10:33:06 <Cale> Computer science is a misnomer. It's not really about computers, and it's not a science.
10:33:10 <vincenz> yeah
10:33:12 <shapr> atom: We have life preservers here on #haskell
10:33:17 <vincenz> it's more mathematics
10:33:17 <shapr> @botsnack
10:33:17 <lambdabot> :)
10:33:25 <atom> shapr: ?
10:33:40 <newsham> atom: for when you're trying to jump in and swim.
10:33:42 <shapr> atom: You throw yourself in the water and swim, and we'll keep you from drowning :-)
10:33:45 <MyCatVerbs> Cale: what is it, if not a science?
10:33:49 <vincenz> atom: well I think haskell is -great- to explore different heuristics with your tree-stuff that should keep code reusable
10:33:52 <vincenz> MyCatVerbs: compsci
10:33:57 <fasta> Yes, I would agree that CS is <stripe>more< like</stripe> mathematics.
10:33:59 <vincenz> oh
10:34:00 <atom> shapr: oh, that kind of life-preservers. Just used to "lifevests"
10:34:00 <vincenz> MyCatVerbs: math
10:34:04 * tibbe thinks Swedish is confusing since science includes math.
10:34:16 <MyCatVerbs> Cale: I always thought more like a funny-looking branch of mathematics, but what about all the informal methods and heuristics involved?
10:34:17 <vincenz> in general, science is based on the empirical method
10:34:17 <dylan> I like the spanish word for it, InformÃ¡tica.
10:34:18 <shapr> atom: Are you of UK area origin?
10:34:25 <MyCatVerbs> vincenz: maths. =D
10:34:29 <atom> shapr: no, Slovenia.
10:34:35 <shapr> Cool!
10:34:39 <shapr> I'm from Alabama
10:34:49 <vincenz> "observe, observe, observe, postulate, more experiments, sigma < 0.01, profit!"
10:34:53 <shapr> tibbe: Makes sense to me.
10:34:57 <atom> shapr: hehe. In that case, slovenia is between italy and croatia.
10:34:59 <vincenz> compsci lacks sigmas :)
10:35:00 <Cale> MyCatVerbs: I take the rather hard line that unless the scientific method is your primary tool of forming theories, you're not a science.
10:35:09 <newsham> shapr: you're pretty smart for a southerner ;-)
10:35:12 <fasta> vincenz: that's not true
10:35:22 <shapr> newsham: Why thank yuh Yankee!
10:35:27 <vincenz> fasta: ok, that was rather broad, but you get the idea :)  Take with grain of salt
10:35:33 * shapr throws mint juleps at newsham 
10:35:37 <fasta> vincenz: sure, I like salt.
10:35:38 <s_clv> Cale: scientists don't take the scientific method as their primary tool!
10:35:44 <shapr> Not that I've ever actually seen a mint julep.
10:35:56 <shapr> atom: Anyway, do you have any specific questions?
10:35:58 <atom> shapr: however, if you're asking because of the "lifevest" thing, I mostly read books of English origin.
10:36:03 <vincenz> s_clv: those bastards!
10:36:10 <atom> shapr: hence the register.
10:36:14 <shapr> atom: I haven't read any books of Slovenian origin. You're way ahead of me.
10:36:17 <Cale> s_clv: It's what decides whether theories stay or go, in the long run.
10:36:19 <fasta> Anyway, Haskell is quite nice for exploring a solution to a problem.
10:36:19 <s_clv> @go "Bruno Latour"
10:36:20 <lambdabot> http://en.wikipedia.org/wiki/Bruno_Latour
10:36:20 <lambdabot> Title: Bruno Latour - Wikipedia, the free encyclopedia
10:36:31 <atom> shapr: not yet... WIll in a few minutes :)
10:36:39 <shapr> Cale: I thought that was Elsevier? ;-)
10:36:45 <shapr> atom: Awright!
10:37:06 <vincenz> s_clv: :D
10:37:11 <vincenz> s/s_clv/shapr
10:37:24 <newsham> shapr- i'm actually further south than you
10:37:26 <atom> although, i'm having trouble visualising the whole thing already.
10:37:35 <newsham> although i am a yank by birth
10:37:36 <atom> shapr: are you familiar with D&D?
10:37:46 <vincenz> death and despair?
10:37:48 <crazy_coder> atom: what do you plan to implement in AI ?
10:37:56 <shapr> atom: Gary Gygax?
10:37:57 <crazy_coder> NN ?
10:38:03 <vincenz> atom: you want to use AI for D&D?
10:38:08 <MyCatVerbs> newsham: s/southener/hick/
10:38:10 <atom> yup.
10:38:16 <atom> don't get started yet :)
10:38:19 <vincenz> atom: then I propose you look at 'behaviour based intelligence'
10:38:22 <atom> it's limited, obvously
10:38:23 <vincenz> atom: not the chess-variants
10:38:32 <MyCatVerbs> Cale: fair enough, I guess
10:38:36 <vincenz> chess variants only work for closed worlds with limited set of enumerable moves
10:38:43 <MyCatVerbs> Cale: where do you draw the line on insufficient vigour, though?
10:38:51 <shapr> Yeah, but chess variants is a good way to start studying AI.
10:38:53 <atom> vincenz: in this case, there is a limited set of enumerable moves
10:39:00 <vincenz> atom: oh
10:39:04 <vincenz> atom: and a score function?
10:39:04 <shapr> There is?
10:39:10 <atom> vincenz: it's just two characters versus one another
10:39:20 <shapr> Are you talking about a computer game?
10:39:22 <atom> and they can only move in a line
10:39:26 <vincenz> atom: ok
10:39:36 <shapr> I thought you were talking about Dungeons&Dragons the role playing game.
10:39:41 * vincenz too
10:39:43 <repnop> hello :)
10:39:45 <atom> shapr: I was
10:39:52 <shapr> hi repnop, how's code?
10:40:02 <vincenz> atom: wouldn't a behaviour based intelligence with varying weights between different behaviours work better then?
10:40:07 <shapr> atom: I'm talking about D&D from 1985 or so.
10:40:11 <vincenz> atom: then you can run genetic algos to figure out ideal weights
10:40:30 <vincenz> atom: erm, the problem with D&D is that it's not deterministic...
10:40:31 <atom> shapr: well, I'm talking about the v4 that's coming out in a few months, but it's the same thing
10:40:33 <vincenz> die roll and all that
10:40:39 <repnop> shapr: new to haskell, but seems interesting.
10:40:46 <atom> vincenz: well, the tree gets very wide very fast
10:41:12 <repnop> wondering if most people use emacs with haskell-mode or something else.
10:41:19 <vincenz> repnop: some do
10:41:19 <atom> the problem is such: I get two character sheets as input and have to calculate who has the greatest chance of winning.
10:41:33 <shapr> atom: Oh, I've only seen 1st and 2nd edition.
10:41:41 <vincenz> atom: I doubt you can play that as a chess-game
10:42:01 <atom> vincenz: I'm getting very skeptic as well...
10:42:04 <vincenz> D&D is more a statistic s game
10:42:04 <shapr> atom: You can definitely give percentages though.
10:42:11 <vincenz> atom: I'd run a game X amount of times
10:42:13 <vincenz> see who wins most
10:42:14 <repnop> you have two chars and they fight?
10:42:20 <shapr> atom: It sounds really cool.
10:42:24 <atom> repnop: yeah. fluffy and steve for starters
10:42:25 * vincenz nods
10:42:33 <repnop> why not just simulate a few million runs to see who wins on avg :)
10:42:33 <shapr> atom: Good names.
10:42:34 <vincenz> fluffy obviously wins, charisma modifier ;)
10:42:38 <shapr> haha
10:43:01 <atom> steve :: Commoner, fluffy :: feral cat
10:43:06 <atom> fluffy 0wnz steve
10:43:26 <vincenz> atom: what I propose: make a few behaviours, one for each possible action.  Then randomize weights for the behaviurs, then run !m times like repnop said, varying the weights.  Keep best weights and also see who wins most on average
10:43:28 <atom> except if steve has Toughness that gives him +3HP
10:43:36 <vincenz> (and check your std-dev, to see if the comparison is good or noti)
10:43:52 <vincenz> s/!m/1M
10:44:15 <atom> vincenz: yeah, that might be a good idea. I am actually considering using genetic algorythms as an alternative, since the other objective is calculating an optimal strategy
10:44:27 <atom> with a tree-based approach, you could back-trace your steps to get it
10:44:28 <shapr> Yeah, I think that'd be really cool.
10:44:37 <shapr> You could train your D&D chars to stay alive.
10:44:42 <vincenz> atom: except that doesn't work since steps aren't deterministic, they depend on dice rolls
10:44:51 <atom> vincenz: one branch for each possible roll
10:44:55 <vincenz> o.O
10:45:01 * vincenz taps his head
10:45:07 <atom> vincenz: don't worry, most just produce two branches
10:45:14 <repnop> well how many possible moves are there per player?
10:45:16 <vincenz> they only use 1d2@?
10:45:26 * vincenz fires his typist and gets a new one
10:45:31 <vincenz> stupid RL humans
10:45:40 <repnop> depending on the size might be easier to just calculate every path rather than use a GA
10:45:47 <atom> vincenz: no, but it's only two possible outcomes... and you carry the value of the possibility
10:46:27 <atom> repnop: that varies, but I guess it's not more than about 10 possible moves per turn...
10:46:35 <vincenz> atom: perhaps such an approach might work for a limited system, but I don't see it scaling to more complex games
10:46:37 <atom> repnop: if you exclude spellcasters, and I do mean to
10:46:41 <vincenz> atom: especially if you have modifiers and all that
10:46:53 <atom> vincenz: yeah... so I'm guessing genetic algorythms
10:46:57 * vincenz nds
10:47:00 <vincenz> but not the full behaviour
10:47:06 <vincenz> only run gen algo on the weights of your behaviours
10:47:24 <vincenz> where each behaviour gets some things as input (current hp, eq, ...)
10:47:25 <atom> vincenz: of course not the whole range of behaviours
10:47:45 <atom> vincenz: just the ones in the SRD...
10:47:47 <vincenz> nono
10:47:48 * atom looks up innocently
10:47:52 <roconnor> @seen ivanm
10:47:52 <lambdabot> ivanm is in #xmonad, #haskell and #gentoo-haskell. I last heard ivanm speak 1h 42m 50s ago.
10:47:54 <newsham> there's got to be a good AI text online free somewhere
10:48:01 <vincenz> what I mean is, don't randomize the action-trace
10:48:09 <vincenz> instead define a behaviour based system, and define some common behaviours
10:48:12 <vincenz> lie "flee if hurt"
10:48:16 <vincenz> and give each random weights
10:48:20 <atom> vincenz: oh...
10:48:20 <vincenz> then gen-algo on the weights
10:48:31 <repnop> 10 moves and how long are most battles?
10:48:35 <vincenz> where you do a weighted sum to define which action
10:48:40 <atom> repnop: most monsters last 6 turns
10:48:46 <repnop> oh
10:48:52 <repnop> you might not even need to use GA
10:48:54 <atom> repnop: I have yet to see a battle that took more than 15
10:49:02 <repnop> you can calculate every possible path easily :p
10:49:04 <vincenz> e.g. "flee says" run, "aggressive" hit, "cautious" drink potion, and each has a weight as well as a confidence level
10:49:36 <vincenz> that's how they get realistic bird behaviour using only a few behaviours
10:49:36 <newsham> http://www.onlinecomputerbooks.com/free-artificial-intelligence-books.php
10:49:37 <lambdabot> Title: Free Artificial Intelligence EBooks, Download Free Artificial Intelligence Books ..., http://tinyurl.com/2on4kg
10:49:38 <vincenz> for instance
10:49:43 <vincenz> (google for "boids")
10:49:58 <atom> vincenz: i'll definitely look that up
10:50:11 <vincenz> in a sense you limit the search space to only a combination of sensible actions you predefine
10:50:16 <vincenz> you just let the gen algo define which is most important
10:50:35 <atom> vincenz: it's just that I don't see this producing something we haven't seen before
10:50:58 <atom> vincenz: I, for instance, can't see how this would be able to play a friends trip-optimized char
10:51:02 <vincenz> a second option, a bit more detailed
10:51:07 <vincenz> define a set of combinators
10:51:13 <vincenz> that work as conditions on inputs
10:51:19 <vincenz> and generate outputs for your different actions
10:51:26 <vincenz> then gen-algo on the combination of combinators
10:51:38 <vincenz> like "hurt > 50%" ... vs "hurt < 30%"
10:52:20 <atom> hm...
10:52:42 <vincenz> you -will- have to define a searchspace of behaviour
10:52:54 <vincenz> unless you don't care about actually generation behaviour
10:53:03 <vincenz> in which case you can just do 1M runs, with completely random behaviour
10:53:09 <vincenz> and see who wins most
10:53:10 <atom> vincenz: that I like better
10:53:20 <vincenz> s/generation/generating/
10:53:23 <repnop> i'm saying no need for random runs most likely
10:53:38 <atom> vincenz: actually, what I thought was this:
10:53:51 <atom> first, we randgen the 1st population of runs
10:54:07 <atom> someone wins in each run.
10:54:12 <vincenz> atom: the nice thing of having some searchspace is that you can use this to generate AIs :)
10:54:25 <vincenz> you generate beahviour iso a trace of actions
10:54:35 <atom> and then we just... weed out the worse runs and keep and mutate the better ones
10:54:48 <vincenz> atom: you'll have to experiment
10:54:53 <vincenz> and see if your space is smooth or not
10:54:56 <vincenz> I doubt that
10:55:01 <vincenz> I think you'll see high peaks
10:55:07 <vincenz> like if person X drinks "potion of invincibilty"
10:55:23 <vincenz> gen algo only works for smooth terrains with soft gradients and not too many local optima
10:55:35 <atom> vincenz: oh... haven't thought of that
10:55:46 <vincenz> atom: well you can first just see what your space looks like
10:55:50 <atom> vincenz: but you're right, it's obvious once someone points it out
10:55:54 <vincenz> do an exhaustive run on some smaller space and see if it's smooth or not
10:56:04 <atom> vincenz: my space... it's very, very mathematically unstable
10:56:08 <vincenz> right
10:56:12 <vincenz> which makes gen algo rather har
10:56:14 <vincenz> d
10:56:19 <vincenz> might as well just do pure random :)
10:56:25 <vincenz> at least you get more sample points
10:56:50 <repnop> monte carlo hehe
10:56:56 <vincenz> 'xactly
10:57:02 <vincenz> just throw steve's and fluffys at a big board
10:57:05 <vincenz> and look how many go "splat"
10:57:31 <atom> and calculate PI while I'm at it :) (circular board :))
10:58:06 <repnop> yeah i love simulations :)
10:58:15 <atom> I don't like this though
10:58:24 <vincenz> map fight $ generate 1000000000000 rounds
10:58:26 <atom> it's rather crude and I fear that it's suboptimal
10:58:36 <atom> very suboptimal
10:58:40 <vincenz> atom: check your std-dev
10:58:53 <atom> since there's but a few optimal starting sequences, for one
10:58:56 <repnop> atom: well a GA might not even give good results
10:59:04 <vincenz> atom: well then, constrain your searchspace like I told you
10:59:07 <vincenz> atom: define a few sensible behaviours
10:59:11 <vincenz> let the randomizer define how they combine
10:59:27 <repnop> over a few million random battles the better person should show up.
10:59:42 <atom> repnop: true, but not an optimal strategy
10:59:45 <repnop> and you need to write the fight logic anyways so doesn't take much :)
10:59:49 <repnop> much more
10:59:59 <vincenz> repnop: well no, it's mostly cost of execution :)
11:00:05 <vincenz> repnop: of course if you work at Google..
11:00:15 <repnop> well each battle is pretty short
11:00:20 <repnop> 16 rounds...
11:00:20 <nominolo> yow, dons is dissing 'catch' .. hehe.
11:00:28 <nominolo> (kind of)
11:00:37 <atom> repnop: unless it's two clerics :)
11:00:53 <vincenz> repeat (heal self)
11:00:59 <vincenz> (where actions alternate each other)
11:01:04 <repnop> atom: well in ruby (a slow language) i can do some finance simulations with large data sets in <1s :)
11:01:29 <atom> oh, i'm hit. cure light wounds. hit. cure light wounds. critical hit. cure MODERATE wounds
11:01:36 <vincenz> atom: no
11:01:38 <repnop> so i dont think even 100 moves of basic math is going to tax your system much per round
11:01:40 <vincenz> atom: they both do
11:01:43 <vincenz> cure light wounds
11:01:47 <vincenz> repeatedly :)
11:01:51 <roconnor> I wonder if I should define ap in terms of join or join in terms of ap.
11:01:59 <repnop> in d&d dont you have to rest before you can cast the spell again?
11:02:06 <dons> nominolo: no, i just wanted to write about the debugger :)
11:02:13 <atom> repnop: you have a number of spells per day
11:02:21 <atom> repnop: they run out of spells sooner or later
11:02:25 <nominolo> "the third one only work in theory"
11:02:31 <vincenz> atom: I'm certain there's actions they can keep doing
11:02:33 <repnop> yeah i'm just saying a single battle shouldn't take too long
11:02:49 <vincenz> repnop: says who? "move left, move right, move left, move right"
11:02:49 <nominolo> i wonder what neil would say / has said
11:02:51 <atom> repnop: yeah, between two melee characters it's certainly short
11:02:53 <dons> nominolo: yeah, i've used catch with xmonad, but since you have to make your code h98, its a bit hard
11:02:59 <repnop> should be able to do a few 100k simulations in a second at least
11:03:00 <vincenz> atom: assuming they hit :)
11:03:12 <bluestorm_> hm
11:03:22 <nominolo> dons: did you have more problems than pattern guards?
11:03:23 <atom> vincenz: on a tree-based approach, they do. you just vary the chance
11:03:25 <vincenz> [repnop, atom] `ap` #oasis
11:03:31 <roconnor> mauke: can you do join in the SKI calculus?
11:03:38 <vincenz> bit OT
11:03:40 <dons> nominolo: pattern guards are ok now, yep
11:03:46 <dons> but you need yhc
11:03:51 <dons> so its still "in theory"
11:04:15 <nominolo> so, only neil can run it for you? :)
11:04:29 <bluestorm_> i'm looking for an accessible, yet somewhat detailed, functional-language-as-a-category paper/post/mail/whatever
11:04:30 <defcons> has anyone got a copy of Haskell, the craft of functional programming handy? How am I meant to do problem 5.26 without knowing how to print?
11:04:33 <nominolo> that's certainly a bottleneck ...
11:04:49 <vincenz> defcons: @paste the problem?
11:04:58 <atom> but first, I'm gonna go write fluffy versus steve tree-based approach (only 3 possible moves per-turn, 3hp for steve, 2hp for fluffy, and steve one-shots fluffy most of the time)
11:05:10 <bluestorm_> i know the basis of this theory (category, functor and natural transformations) and have founded some documents (on the wikibook for example)
11:05:22 <defcons> vincenz, got a real book here, I'll write it out
11:05:25 <defcons> @paste
11:05:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:05:34 <mauke> :t ap ap (const id)
11:05:34 <lambdabot> forall b a. (a -> a -> b) -> a -> b
11:05:36 <bluestorm_> but i'd be looking for something a little bit deeper
11:05:36 <Phillemann> defcons: The task with the fibonacci table?
11:05:43 <defcons> Phillemann, yes
11:05:45 <atom> i'll post what I come up with and then ask for comments if everyone's still here :)
11:05:45 <mauke> roconnor: S S (K I)
11:05:48 <vincenz> atom: >> #oasis
11:06:33 <vincenz> @type ap
11:06:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:06:45 <vincenz> > [(+1)] `ap` [2]
11:06:46 <lambdabot>  [3]
11:06:55 <nominolo> @type vincenz
11:06:55 <lambdabot> Not in scope: `vincenz'
11:07:04 * vincenz sniffs
11:07:08 <defcons> Phillemann, could you tell me how to do it?
11:07:12 <byorgey> bluestorm_: this might not be as detailed as you're looking for, but it might be a place to start: http://www.alpheccar.org/en/posts/show/74
11:07:13 <lambdabot> Title: Category Theory and the category of Haskell programs : Part 1
11:07:15 <vincenz> > [(+1), (*2)] `ap` [2,5]
11:07:15 <lambdabot>  [3,6,4,10]
11:07:44 <roconnor> mauke++
11:07:45 <roconnor> mauke++
11:07:49 <nominolo>  > [(+1), (*2)] <*> [2,5]
11:08:01 <Phillemann> defcons: Since the task mentions putStr in it, why do you assume you don't know how to print?
11:08:17 <mauke> [\f -> \x -> f x x] = [\f -> [\x -> f x x]] = [\f -> S [\x -> f x] I] = [\f -> S f I] = S S (K I)
11:08:25 <defcons> Phillemann, right, didn't read properly
11:08:27 <defcons> really sorry
11:08:31 <roconnor> @pl \s -> s == s
11:08:31 <lambdabot> join (==)
11:08:44 <vincenz> @src ap
11:08:44 <lambdabot> ap = liftM2 id
11:08:58 <roconnor> @unpl ap ap (const id) (==)
11:08:59 <lambdabot> ((\ l m -> l >>= \ j -> m >>= \ i -> return (j i)) >>= \ d -> (\ _ b -> b) >>= \ c -> return (d c)) (==)
11:09:12 <roconnor> :(
11:09:31 <mauke> @. pl unpl  ap ap (const id) (==) ap ap (const id) (==)
11:09:33 <lambdabot> (id >>=) . (return .) =<< (==)
11:09:45 <roconnor> @type ap ap (const id) (==)
11:09:47 <lambdabot> forall a. (Eq a) => a -> Bool
11:09:55 <mauke> @. pl unpl  ap ap (const id) (==) ap ap (const id)
11:09:55 <lambdabot> (const id >>=) . (return .) =<< (. ((. (return .)) . (>>=))) . (>>=)
11:10:03 <byorgey> @. djinn type ap ap (const id) (==)
11:10:04 <lambdabot> f a = a == a
11:10:11 <mauke> @. pl unpl  ap ap (const id) (==) ap ap (const id) f x
11:10:11 <lambdabot> ((id >>=) . (return .) =<< (==)) ((. ((. (return .)) . (>>=))) . (>>=)) ((. ((. (return .)) . (>>=))) . (>>=)) (const id) f x
11:12:25 <bluestorm_> byorgey: thanks, looks interesting
11:12:37 <bluestorm_> (and the comments too !)
11:13:37 <s_clv> @users
11:13:37 <lambdabot> Maximum users seen in #haskell: 412, currently: 401 (97.3%), active: 20 (5.0%)
11:14:06 <byorgey> bluestorm_: note there are also Parts II and III, I think.
11:14:25 <bluestorm_> yes, i just found them
11:14:30 <byorgey> bluestorm_: ok, excellent
11:14:39 <bluestorm_> and some URL about ML too, wich is good
11:20:02 <geocalc> > sum [1.sum[1..1169]]
11:20:15 <lambdabot>   add an instance declaration for (Enum (a -> b))
11:20:16 <vincenz> geocalc: you need another .
11:20:38 <geocalc> yes my nad
11:20:46 <geocalc> b*
11:20:52 <mauke> > let f n = n * (n + 1) `div` 2 in f (f 1169)
11:20:53 <lambdabot>  233836011045
11:21:48 <geocalc> > sum [1..sum[1..1169]]
11:21:49 <lambdabot>  233836011045
11:23:11 <geocalc> how i make my ghci handle this kind of work ?
11:23:28 <mauke> you use my function
11:24:07 <geocalc> no
11:24:09 <vincenz> oh
11:24:12 <vincenz> stack overflow
11:24:14 <vincenz> LOL :)
11:24:46 <mauke> yes
11:24:54 <defcons> "n       fib n\n" ++ [show y ++ "           " ++ show (fib y) ++ "\n" | y <- [0..x]]
11:25:00 <defcons> what could be wrong with that expression?
11:25:16 <defcons> I guess show y needs to be in parens
11:25:26 <byorgey> no, show y should be ok
11:25:27 <ADEpt> defcons: incompatible types for the leftmost ++ ?
11:25:49 <defcons> ADEpt, how so?
11:25:50 <byorgey> defcons: you probably want to call 'concat' on that list.
11:26:00 <ADEpt> defcons: String ++ [String] ?
11:26:03 <daniel_larsson> You're doing (String ++ [String])
11:26:10 <defcons> aah, of course
11:26:12 <defcons> thank you
11:31:40 <geocalc> so do i have to recompile ghci or there is a launch flag ?
11:33:12 <fasta> geocalc: for what?
11:33:53 <geocalc> to have more stack
11:33:59 <roconnor> mauke: ... can we define S in terms of {join, K, (.)} ?
11:34:10 <roconnor> and id
11:34:12 <Lemmih> geocalc: +RTS -K64M
11:34:18 <roconnor> {join, K, (.), I} ?
11:34:36 <geocalc> thanks
11:34:37 <MyCatVerbs> Lemmih: massive heap, much?
11:36:12 * roconnor is tempted to prove this using quickcheck
11:36:45 <alexj> @seen ndm
11:36:46 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 19h 12m 24s ago, and .
11:39:03 <alexj> do people find the TH [!d ... |] quotes scary or are they now accepted practice?
11:39:24 <alexj> [d| .. |]
11:40:52 <monochrom> Not scary.
11:42:26 <defcons> I'm getting type problems for trying to do show (fib n)
11:43:03 <geocalc> > sum [1..sum[1..11699]]
11:43:07 <lambdabot> Terminated
11:43:47 <mrd> defcons: type of fib n is?
11:43:54 <defcons> oh never mind
11:43:55 <defcons> sorry
11:44:16 <mrd> maybe you meant concat [ ... ]
11:44:51 <mauke> :t join . flip (.) (flip (.)) . flip (.)
11:44:52 <lambdabot> forall b c a. ((a -> b) -> b -> c) -> (a -> b) -> a -> c
11:44:55 <mrd> unlines actually,
11:45:05 <alexj> monochrom: are you interacting with haskell beginners?
11:45:06 <byorgey> > let triangular n = (n * (n+1)) `div` 2 in triangular $ triangular 11699  -- geocalc
11:45:09 <lambdabot>  2341958660580825
11:45:53 <alexj> @seen igloo
11:45:53 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 42m 28s ago.
11:45:59 <monochrom> I interact with some haskell beginners here.
11:46:23 <mrd> bludgeoning is interaction, right?
11:47:03 <roconnor> mauke: you need flip :/
11:47:56 <defcons> does haskell have TCO?
11:47:59 <defcons> namely GHC
11:48:04 <monochrom> Yes.
11:48:26 <defcons> okay
11:49:57 <mauke> :t ((.) join) . flip (.) (flip (.)) . flip (.)
11:49:58 <lambdabot> forall b c a. (a -> b -> c) -> (a -> b) -> a -> c
11:50:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3880
11:51:02 <roconnor> mauke: maybe I should build everything out of {(.), id, flip, join} ?
11:51:46 <roconnor> oh and K
11:51:53 <roconnor> {(.), id, flip, join, K}
11:51:56 <roconnor> {(.), id, flip, join, const}
11:52:11 <mauke> you don't need id
11:52:24 <roconnor> mauke: true, but it is cheap to prove :)
11:52:42 <roconnor> it was part of the applicative functor laws I already made
11:53:59 <roconnor> so, commutative {- flip -}, copyable {- join -}, and discardable {- const -}
11:54:06 <roconnor> applicative functor
11:54:10 <roconnor> or monad.
12:11:22 <sethk> There is an article in Dr. Dobbs Journal (on line) about functional languages in the real world
12:13:56 <sethk> don't all comment at once.   :)
12:18:38 <roconnor> sethk: link?
12:18:58 <sethk> roconnor, you want everything?  :)  Hold on
12:20:38 <MyCatVerbs> sethk: gah, that website makes my eyes bleed. x_x
12:20:42 <sethk> roconnor, actually, it is in a newsletter.
12:20:45 <MyCatVerbs> sethk: and I haven't even *found* the article yet.
12:20:57 <sethk> roconnor, probably on the site as well, but the newsletter doesn't say, so maybe it will be there later.
12:21:03 <roconnor> :)
12:21:04 <MyCatVerbs> sethk: oh you...
12:21:08 <MyCatVerbs> Heheh.
12:21:21 * roconnor returns to proving his monad is copyable.
12:21:22 <sethk> roconnor, it has two links; one to "why functional programming matters" which we've all read, and the other to ...
12:21:41 <roconnor> boy these proofs are really obvious.
12:22:00 <sethk> the F language (http://newsletters.sdmediagroup.com/cgi-bin4/DM/y/hBE6H0GGf7f0TKJ0Fd1F0EF) and CLR (http://newsletters.sdmediagroup.com/cgi-bin4/DM/y/hBE6H0GGf7f0TKJ0Fd1G0EG)
12:22:01 <lambdabot> http://tinyurl.com/3458en
12:25:01 <pejo> Apparently going very well for the F# people, that's great!
12:25:58 <kolmodin> shapr: ping
12:26:09 <roconnor> there
12:26:19 <roconnor> done my set of combinators.
12:26:37 <roconnor> now I should be able to map any lambda expression.
12:30:26 <shapr> kolmodin: pong
12:30:53 <shapr> @seen kolmodin
12:30:53 <lambdabot> kolmodin is in #gentoo-haskell, #xmonad, #friendly-coders, #haskell and #ghc. I last heard kolmodin speak 4m 55s ago.
12:31:08 <kolmodin> shapr: you know Dario Lopez-K?sten? via chalmers?
12:31:28 <kolmodin> not that it's any of my business :D
12:31:39 <kolmodin> but he's one of my instructors in the dojo
12:32:05 <shapr> kolmodin: Yeah, sure. I met him in the Python community.
12:32:10 <kolmodin> I see
12:32:28 <shapr> The world is tightly connected :-)
12:32:29 <kolmodin> I just found our clubs group on facebook :)
12:32:34 <shapr> cool
12:32:37 <kolmodin> shapr: I notice more and more every day :)
12:33:13 <roconnor> mauke++
12:33:24 <roconnor> mauke: how do you solve all these combinators problem
12:34:19 <mauke> IN MY MIND
12:34:37 <olsner> combinator*s*? everyone knows one is enough! ;-)
12:35:51 <roconnor> olsner: :)
12:36:11 <roconnor> mauke: are you taking a course or something :P
12:36:17 <mauke> nope
12:36:25 <MyCatVerbs> olsner: what.
12:36:33 <MyCatVerbs> olsner: what single combinator is Turing-complete on its own?
12:36:46 <roconnor> MyCatVerbs: the X combinator
12:36:48 <olsner> MyCatVerbs: there are a few, one of them is called X iirc
12:36:57 <mauke> roconnor: basic abstraction elimination is explained on wikipedia
12:37:13 <roconnor> mauke: do you do a deduction on paper?
12:37:18 <MyCatVerbs> olsner: oh, nice.
12:37:26 <MyCatVerbs> roconnor, olsner: danke.
12:37:36 <mauke> no, for simple stuff I do it in the irc input line
12:37:47 <mauke> for hairy expressions I use a scratch buffer in vim
12:37:54 * roconnor will start a company called the X combinator
12:39:12 <roconnor> mauke: woah, I just reinveted the BCKW combinator system.
12:39:25 <mauke> congrats!
12:39:47 <roconnor> I guess it is a pretty natural system.
12:41:30 <mauke> yeah, C arises naturally when you try to define S in terms of B and W
12:42:34 <olsner> I just read "yeah, C arises naturally ..." and went wtf for a moment until I realized you were talking about the C combinator
12:43:07 <mauke> BCKW != BCPL
12:43:32 <roconnor> :)
12:44:13 <olsner> it is decided: my children shall all have combinator bases as their initials
12:46:09 <dmwit> What's your last name?
12:46:14 <monochrom> C arises naturally from B.
12:46:45 <monochrom> (I'm just joking!)
12:48:15 <olsner> dmwit: starts with a B, so it's certainly doable
12:51:33 <kolmodin> shapr: btw, I like your 'random #haskell quotes' on your blog  :D
12:52:28 <reqamst> @src pi
12:52:28 <lambdabot> Source not found. That's something I cannot allow to happen.
12:52:44 <dmwit> pi is in a class, I believe.
12:52:51 <roconnor> @src pi Double
12:52:52 <lambdabot> Source not found. You untyped fool!
12:52:53 <dmwit> ?src Double pi
12:52:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:53:02 <olsner> @type pi
12:53:04 <lambdabot> forall a. (Floating a) => a
12:53:12 <roconnor> @src Complex pi
12:53:12 <lambdabot> Source not found. You untyped fool!
12:54:14 <Tobsan> lol
12:54:34 <reqamst> hm
12:58:38 <mauke> where is shapr's blog?
12:59:23 <dmwit> http://shae.livejournal.com/26364.html
12:59:24 <lambdabot> Title: shae: random #haskell quotes
13:00:38 <roconnor> @wn zoetic
13:00:39 <lambdabot> No match for "zoetic".
13:02:44 <Japsu> shae, hmm
13:03:07 <Japsu> there's a character of that name in A Song of Ice and Fire, by George R. R. Martin
13:03:34 * Japsu is reading Part IV: A Feast for Crows
13:03:43 <idnar> awesome series
13:03:48 <Japsu> second that
13:07:59 <defcons> rotate ls =
13:07:59 <defcons>     [[x!!(i - 1) | x <- ls] | i <- [1..(length (head ls))]]
13:08:15 <defcons> why does this not rotate by -90 the given list?
13:08:24 <defcons> it just seems to zip things
13:08:59 <defcons> oh, wrong input
13:09:10 <shapr> kolmodin: thanks!
13:09:27 <dmwit> defcons: Have you seen transpose?
13:09:35 <defcons> dmwit, it was part of a book question
13:09:39 <dmwit> Oh, okay.
13:09:40 <defcons> but I'll have a look. Thanks
13:09:53 <dmwit> > transpose [[1,2,3], [4,5,6]]
13:09:54 <lambdabot>  [[1,4],[2,5],[3,6]]
13:10:10 <defcons> is there a quicker way of doing what I did?
13:10:12 <dmwit> Actually, I guess that's not a rotation.  Never mind.
13:12:27 <defcons> yeah, mine is transpose at the moment
13:13:09 <defcons> just needed to reverse the numbers
13:13:23 <slava> i just refactored some code and i'm debugging a few dynamic type errors :)
13:16:48 <idnar> > (map reverse) . transpose $ [[1,2,3], [4,5,6]]
13:16:49 <lambdabot>  [[4,1],[5,2],[6,3]]
13:18:04 <durdn> i know it's easy and i already saw it but i can't remember where:
13:18:06 <defcons> what does the dollar sign do?
13:18:27 <durdn> what's the function to go from [[a],[b],[c,d]] to [a,b,c,d] ?
13:18:29 <idnar> (f $ g) is just (f g), but it has low precedence
13:18:32 <mauke> @src ($)
13:18:32 <lambdabot> f $ x = f x
13:18:42 <idnar> (er, bad choice of variable names)
13:18:44 <olsner> > concat [[1],[2],[3,4]]
13:18:46 <lambdabot>  [1,2,3,4]
13:18:48 <mauke> @hoogle [[a]] -> [a]
13:18:49 <lambdabot> Prelude.concat :: [[a]] -> [a]
13:18:52 <durdn> olsner: thanks!!
13:19:26 <durdn> mauke: thanks too :)
13:20:15 <olsner> "teach a man to concatenate lists and he can concatenate lists - teach a man to use hoogle and he can do anything!"
13:20:43 <durdn> olsner: ha! i even installed lambdabot on my box
13:20:48 <defcons> are there default arguments on haskell?
13:21:00 <durdn> olsner: i just need to get smarter :)
13:29:03 <reqamst> How can I resize stack?
13:31:06 <TSC> reqamst: You mean make it bigger so that your program doesn't crash?
13:32:02 <reqamst> TSC: yeah
13:33:25 <TSC> If it's compiled with GHC, it tells you how in the "out of stack" error message when it crashes
13:33:41 <TSC> I think it's "./program +RTS -K100M", or something like that
13:34:00 <TSC> You change the "100M" to whatever size you want
13:34:00 <reqamst> TSC: No, I return "Exception: stack overflow"
13:34:38 <reqamst> TSC: I run it in GHCi.
13:34:47 <TSC> Ah
13:36:29 <TSC> I'm not sure about how to do it in ghci
13:41:33 <veerz> Whats "the haskell way" to read in a list of n integers from stdin?
13:42:00 <Japsu> getContents >>= words >>> map read
13:42:39 <dmwit> replicateM n readLn
13:42:52 <Japsu> oops,
13:43:07 <Japsu> getContents >>= (words >>> map read >>> return)
13:43:27 <Japsu> :type getContents >>= (words >>> map read >>> return)
13:43:33 <Japsu> ...
13:43:35 <Japsu> @type getContents >>= (words >>> map read >>> return)
13:43:36 <lambdabot> forall a. (Read a) => IO [a]
13:43:47 <twanvl> ?type map read . words <$> getContents
13:43:48 <lambdabot> forall a. (Read a) => IO [a]
13:43:50 <allbery_b> the : handler is very stupid and very literal.  :t not :type
13:43:55 <kolmodin> note that that consumes all of stdin..
13:43:56 <Japsu> yeah
13:44:00 <Japsu> yeah
13:44:59 <dmwit> ?hoogle Read a => IO a
13:45:00 <lambdabot> Prelude.readLn :: Read a => IO a
13:45:00 <lambdabot> System.exitFailure :: IO a
13:45:00 <lambdabot> Prelude.readIO :: Read a => String -> IO a
13:45:30 <kolmodin> some users might prefer   getContents >>= return . map read . words
13:45:52 * dmwit would prefer liftM (map read . words) getContents
13:46:02 <dmwit> (Or twanvl's use of Applicative.)
13:47:12 <ski_> (map read . words) `liftM` getContents
13:47:27 <kolmodin> aye
13:47:55 * Japsu would prefer his version
13:47:56 <Japsu> :)
13:47:59 <olsner> or (return . map read . words) =<< getContents
13:48:08 <kolmodin> so many ways to do the same thing.. :) it's like perl
13:48:10 <kolmodin> :D
13:48:18 <RayNbow> hmm... about 30% of my .hs files is Haskell code... the rest are empty lines or comments...
13:48:24 <Japsu> olsner: I find the >>> operator more intuitive and readable than .
13:48:41 <Japsu> It's just a shame that the operator isn't |
13:48:55 <kolmodin> |> like in F#
13:48:58 <olsner> yeah, >>> is more suggestive of piping than simple .
13:50:03 <dylan> > let (|>) = (++) in "foo" |> "bar"
13:50:07 <lambdabot>  "foobar"
13:50:17 <dylan> |> can be defined.
13:50:39 <kolmodin> sure :)
13:50:55 <Japsu> yeah, but | is reserved :<
13:51:51 <dmwit> No no no!
13:51:57 <dmwit> | is reserved :D
13:52:11 <dmwit> You mispronounced being happy. ;-)
13:52:19 <kolmodin> :D
13:55:53 <kolmodin> >let (|>) = flip ($) in "0 1 2 3" |> words |> map read :: [Int]
13:56:14 <dmwit> > let (|>) = flip ($) in "0 1 2 3" |> words |> map read :: [Int]
13:56:16 <lambdabot>  [0,1,2,3]
13:56:16 <conal> Unix "|" is in a way more user-friendly than our "." and ">>>", in that it composes apps with user interfaces.
13:58:10 <profmakx> how can i tell cabal to add some -optc-I (preferably globally)
14:01:46 <veerz> Japsu: sorry for the late reply
14:02:08 <veerz> the thing is that I have to read in exactly _n_ lines
14:02:35 <veerz> your example seemsto read in everything from stdin
14:02:49 <TSC> Yeah, getContents will do that
14:03:08 <veerz> s/seemsto/seems to/
14:03:18 <Lemmih> profmakx: I think there is a c-options or c-flags.
14:03:21 <TSC> Try "replicate n readLn", perhaps
14:04:08 <newsham> dmwit: hmm.. why does that associate the right way?
14:04:23 <newsham> I tried that sort of thing before and had problems without using a fixity decl
14:04:32 <lucca> is there something that works like lines/words, but is more general, like span/break?
14:04:59 <newsham> lucca: not in the std libs
14:05:24 <lucca> okay; just trying to avoid re-inventing wheels
14:05:49 <newsham> dmwit: oh, hmm.. nevermind.. what I was thinking of was slightly different.
14:06:30 <newsham> > let a $ f = f a in 1 $ (2 $ (+))
14:06:31 <lambdabot>  3
14:11:21 <hpaste>  hygge pasted "n00bquestion "where"" at http://hpaste.org/3882
14:11:27 <hygge> :)
14:11:55 <hygge> take a look at my _very_ simple problem if u like !
14:12:48 <hpaste>  pip pasted "(no title)" at http://hpaste.org/3883
14:13:47 <veerz> TSC: Could you please give me an example?
14:14:20 <shachaf> hygge: Each pattern match has its own where block.
14:14:27 <hygge> aha
14:14:36 <TSC> @type sequence (replicate 5 readLn)
14:14:37 <lambdabot> forall a. (Read a) => IO [a]
14:14:52 <hygge> shachaf, a bit ugly if i can say
14:14:58 <TSC> veerz: That will read 5 ints (one per line), for example
14:15:09 <hygge> seems unnecceray to have two where-keywords
14:15:10 <TSC> And give them as a list
14:15:49 <veerz> TSC: Ah! Thanks!
14:15:55 <TSC> You're welcome
14:15:56 <shachaf> hygge: Well, where can use arguments to the function.
14:16:24 <hygge> shachaf, aha, can u show me=
14:17:04 <shachaf> > let { f x 1 = y where y = x + 1; f x 2 = 0 } in f 1 1
14:17:04 <lambdabot>  2
14:17:27 <shachaf> Using y in the second f wouldn't make much sense, because it depends on the argument.
14:17:53 <hygge> hmm i see
14:18:03 <lucca> mmm, unintersperse
14:18:18 <hpaste>  byorgey annotated "(no title)" with "egyptian fractions: [(x,y)] and fromIntegral" at http://hpaste.org/3883#a1
14:18:30 <byorgey> someone in here paste the "egyptian fractions"?
14:19:59 <shachaf> hygge: You can use case, I guess.
14:20:49 <byorgey> hygge: in your case I would personally just use the second form.  There's no particular reason to have 'bubble' be in a where clause.
14:21:00 <byorgey> hygge: it just makes it harder to test 'bubble' by itself.
14:21:56 <byorgey> hygge: one of the great strengths of Haskell is the ability to easily test small pieces of your program by themselves, but you can't do that with pieces that are hidden inside a 'where'.
14:22:54 <hygge> ah ah
14:23:19 <hygge> i thougt it would be nice to have it "private" because the helpfunction will be to no use for other functions
14:24:42 <byorgey> hygge: right, but in this case the 'privacy' doesn't really gain you anything.
14:24:43 <hygge> it would actually dangerous to let it be used by other callers, it assums that the list has got two or more elements - this is checked in the bubblesort function
14:24:47 <hygge> ah ah
14:25:15 <byorgey> hygge: however, you can put this all in a module and not export the bubble function.
14:25:26 <hygge> ah good one
14:25:29 <byorgey> hygge: that way, the only place it could be called is from within the module.
14:25:34 <hygge> ah
14:25:56 <hygge> do you know if theres lists are in the eq class?
14:26:09 <hygge> i would like to compare my sorted list with a prooved sorting algorithm to ensure its good
14:26:15 <byorgey> yes, they are.
14:26:18 <newsham> > [1,2] == [1,2]
14:26:19 <lambdabot>  True
14:26:45 <hygge> prop_bubbleSort :: [Int] -> Bool
14:26:45 <hygge> prop_bubbleSort xs = bubbleSort xs == insertionSort xs
14:26:51 <hygge> this should work, right?
14:27:04 <byorgey> hygge: I was just going to suggest QuickCheck =)
14:27:08 <hygge> :)
14:27:30 <byorgey> the other thing you could also do is make an isSorted :: [Int] -> Bool function
14:27:41 <byorgey> and then have prop_bubbleSort xs = isSorted (bubbleSort xs)
14:27:58 <newsham> Eq a => Eq [a]
14:28:06 <hpaste>  hygge pasted "2" at http://hpaste.org/3884
14:28:24 <hygge> okey
14:28:42 <byorgey> isSorted xs = all $ zipWith (<=) xs (tail xs)
14:29:14 <hygge> that was a short one
14:29:20 <byorgey> > let isSorted xs = all $ zipWith (<=) xs (tail xs) in (isSorted [1,2,5,7,7], isSorted [1,3,4,2,6])
14:29:20 <lambdabot>  Couldn't match expected type `a -> Bool'
14:29:55 <byorgey> > let isSorted xs = and $ zipWith (<=) xs (tail xs) in (isSorted [1,2,5,7,7], isSorted [1,3,4,2,6])
14:29:57 <lambdabot>  (True,False)
14:30:02 <byorgey> and, not all
14:30:26 <newsham> isSorted [] = True; isSorted (x:xs) = all (x<=) xs && isSorted xs
14:30:37 <newsham> another approach
14:31:03 <hygge> what is "all (x<=)" ?
14:31:06 <byorgey> hygge: wow, crazy error =)
14:31:10 <hygge> mm
14:31:13 <newsham> > (5<=) 8
14:31:13 <byorgey> @type all
14:31:13 <lambdabot>  True
14:31:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:31:16 <newsham> > (5<=) 3
14:31:17 <lambdabot>  False
14:31:31 <newsham> (5<=) is the function that returns True/False if a number is or isnt greater than or equal to 5
14:31:47 <byorgey> newsham: isn't that O(n^2)?
14:31:48 <newsham> "all" is a function which sees if a predicate is true for every element in a list
14:32:09 <newsham> byorgey: would appear so
14:32:21 <hygge> why have parenthesis?
14:32:27 <hygge> > 5<=8
14:32:28 <lambdabot>  True
14:32:41 <newsham> :t (5<=)
14:32:42 <lambdabot> forall t. (Num t, Ord t) => t -> Bool
14:32:45 <newsham> :t 5 <=
14:32:46 <lambdabot> parse error (possibly incorrect indentation)
14:33:07 <Taejo> isSorted [] = True; isSorted (x:[]) = True; isSorted (x:y:ys) = x < y && sorted (y:ys)
14:33:16 <Taejo> s/</<=/
14:33:33 <ddarius> isSorted [x] = True
14:33:46 <newsham> ddarius doesnt like cons-monster
14:34:09 <byorgey> hygge: (x op) and (op x) where op is some operator (like <=) are "operator sections"
14:34:23 <byorgey> (x op) is the same as \y -> x op y
14:34:31 <byorgey> and (op x) is \y -> y op x
14:34:45 <byorgey> for example, (1+) is the function \x -> 1 + x
14:34:55 <byorgey> > map (1+) [2,3,4]
14:34:56 <lambdabot>  [3,4,5]
14:34:57 <ddarius> Actually, I think the translation is flip op x
14:35:22 <byorgey> ddarius: well, technically yes, but that doesn't help the intuition =)
14:35:39 <ddarius> It has consequences for sharing
14:36:43 <byorgey> hygge: so (5<=) is a function which takes a number and sees whether 5 is less than or equal to it.
14:37:17 <newsham> http://www.thenewsh.com/%7Enewsham/consMonster.jpg
14:38:00 <ddarius> Your mother would be proud.
14:38:05 <byorgey> hmm, anyone know the difference between the quickCheck and test functions from Test.QuickCheck?
14:38:16 <newsham> ?src flip
14:38:16 <lambdabot> flip f x y = f y x
14:38:22 <ddarius> byorgey: Use the source.
14:38:27 <hygge> okey
14:38:29 <newsham> ddarius pedantic
14:39:10 <newsham> ?unpl flip (+) 5
14:39:10 <lambdabot> (\ c -> c + 5)
14:39:26 <byorgey> hm, they're the same.
14:40:15 <s_clv> oh man.. i wish parens weren't so strictly reserved -- it would be lovely to have combinator libraries that looked like smileys
14:41:01 <newsham> maybe you can find unicode look-a-likes, clv
14:41:05 <TomMD> So how do most people manage the huge number of types in large Haskell programs?  I can understand many programs can be well summed up with few types, but sometimes it just seems like I have types coming out of my ears.
14:41:32 <hygge> newsham, i used your issorted function and the prop_bubblesort xs = issorted (bubblesort xs), and i get this
14:41:51 <hygge> *Main> quickCheck prop_bubbleSort
14:41:51 <hygge> Falsifiable, after 3 tests:
14:41:51 <hygge> [0,0,-4,0]
14:41:51 <hygge> *Main> quickCheck prop_bubbleSort
14:41:51 <hygge> *** Exception: BubbleSort.hs:(9,0)-(12,43): Non-exhaustive patterns in function bubble
14:41:52 <newsham> tom: same way as in any language.  large projects have lots of interfaces.  you try to keep em down with modularization, and document the ones you need
14:42:37 <newsham> what is bubblesort [0,0,-4,0] ?
14:42:46 <byorgey> hygge: well, there you go, you found some bugs =)
14:42:50 <hygge> :)
14:42:53 <byorgey> QuickCheck++
14:43:22 <hygge> newsham, its [-4,0,0,0]
14:43:34 <newsham> and  isSorted [-4,0,0,0] returns False?
14:43:42 <byorgey> hygge: that "Non-exhaustive patterns" error in particular means that your bubbleSort function is not honoring bubble's precondition.
14:43:55 <hygge> nope, true
14:43:56 <hygge> aha
14:43:58 <hygge> wait
14:45:08 <hygge> i comparde it to the insertionsort that didnt work with negative digigts. now i get anther errer (now im using issorted as i said above)*Main> quickCheck prop_bubbleSort
14:45:08 <hygge> *** Exception: BubbleSort.hs:(9,0)-(12,43): Non-exhaustive patterns in function bubble
14:45:20 <byorgey> TomMD: yes, I think that modularization is key: when you create some types, along with them create a bunch of functions for dealing with values of that type, with the goal being that you never have to think about the details of those types again.
14:45:49 <byorgey> hygge: what happens if you call bubbleSort on a one-element list?
14:46:10 <hygge> the same ! :D
14:46:19 <byorgey> hygge: well, figure out why =)
14:46:29 <waern_> has anyone installed latest c2hs with cabal 1.2.2.0?
14:46:32 <kolmodin> how about empty lists?
14:46:36 <hygge> passed 100 tests!
14:46:46 <byorgey> hygge: what did you change?
14:46:48 <kolmodin> waern: I have not..
14:47:42 <waern> kolmodin: you should! so you can tell me what's wrong
14:47:54 <kolmodin> hah :)
14:48:00 <kolmodin> no what I should do is go to bed
14:48:17 <kolmodin> but I'm actually trying your suggestion too :)
14:49:16 <kolmodin> waern: latest c2hs is?
14:49:27 <kolmodin> 0.15.0 ?
14:49:29 <kolmodin> right
14:49:43 <kolmodin> I've got 0.14.5 here, it seems to build
14:49:53 <kolmodin> then likely 0.15.0 works too
14:50:08 <kolmodin> your issue might be with ghc 6.8.1 if that's what you're using
14:50:11 <waern> yep
14:50:14 <kolmodin> I still have 6.6.1
14:50:21 <hygge> taejo, i tried your code, i suppose u meant issorted the lsat row too?
14:50:31 <kolmodin> so it's not actually a cabal problem, even if that's where you solve it
14:50:47 <Taejo> yes
14:51:04 <waern> kolmodin: huh?
14:51:20 <waern> kolmodin: Cabal says:  A library was specified, but no exposed modules list has been given.
14:51:30 <kolmodin> oh
14:51:33 <hygge> taejo, there must be an error, ghci says theres one at the row below (which worked before=
14:51:41 <kolmodin> waern: ok, not the problem I expected
14:51:47 <Taejo> hygge, I haven't tested it
14:51:58 <Taejo> i was just giving an idea
14:51:59 <hygge> :)
14:53:27 <kolmodin> waern: I really need some sleep now though, I'll have a look at it later. poke me tomorrow after work
14:53:43 <waern> kolmodin: ok sure :)
14:54:01 <hygge> byorgey, can u explain how your issorted works. isnt zipwidth on lists? tail xs will give just an 'a'?
14:54:18 <kolmodin> waern: nn :)
14:54:19 <daniel_larsson> tail xs gives the tail of the list, so [a]
14:54:28 <hygge> aha
14:54:29 <byorgey> hygge: no, tail xs gives a list containing all but the first element of xs.
14:54:30 <daniel_larsson> > tail [1,2,3]
14:54:33 <lambdabot>  [2,3]
14:54:36 <kolmodin> dcoutts: ^^ wrt c2hs
14:54:46 <Olathe> > last [1, 2, 3]
14:54:46 <hygge> i mixed it up with last
14:54:47 <lambdabot>  3
14:54:50 <Olathe> > last [1..]
14:54:51 <byorgey> hygge: so zip xs (tail xs) pairs up each element with the next one
14:54:53 <lambdabot> Terminated
14:55:03 <byorgey> > let xs = [1..5] in zip xs (tail xs)
14:55:04 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
14:55:20 <Olathe> @src last
14:55:20 <lambdabot> last [x]    = x
14:55:20 <lambdabot> last (_:xs) = last xs
14:55:20 <lambdabot> last []     = undefined
14:55:25 <byorgey> then we do a zipWith (<=) to make sure that in each pair of elements, the first is <= the second
14:55:38 <byorgey> > zipWith (<=) [1..5]
14:55:40 <lambdabot>  <[Integer] -> [Bool]>
14:55:46 <byorgey> > let xs = zipWith (<=) [1..5]
14:55:46 <lambdabot>  Parse error at end of input
14:55:48 <Olathe> How do you get the rest of the elements besides last ?
14:55:49 <byorgey> gah
14:55:53 <byorgey> stupid enter key =P
14:55:58 <byorgey> Olathe: init
14:56:04 <Olathe> > init [1, 2, 3]
14:56:05 <lambdabot>  [1,2]
14:56:08 <Olathe> > inits [1, 2, 3]
14:56:09 <lambdabot>  [[],[1],[1,2],[1,2,3]]
14:56:12 <Olathe> Yay !
14:56:25 <byorgey> > let xs = [1,2,3,5,2,7] in zipWith xs (tail xs)
14:56:26 <lambdabot>  Couldn't match expected type `a -> b -> c'
14:56:34 <byorgey> > let xs = [1,2,3,5,2,7] in zipWith (<=) xs (tail xs)
14:56:36 <lambdabot>  [True,True,True,False,True]
14:56:52 <Olathe> > let xs = [1,2,3,5,2,7] in zip xs (init xs)
14:56:52 <lambdabot>  [(1,1),(2,2),(3,3),(5,5),(2,2)]
14:56:55 <byorgey> hygge: that 'False' indicates the fact that the 5 and 2 are not in order.
14:57:06 <hygge> neat
14:57:21 <byorgey> hygge: and then you can probably figure out what the 'and' does =)
14:57:26 <hygge> yeah :) but we dont need zip, only zipwidth. hmm
14:57:35 <hygge> okey
14:57:56 <byorgey> that's 'zipWith' not 'Width' =)
14:58:04 <hygge> ah
14:58:06 <hygge> :)
14:58:20 <Taejo> hygge: let {isSorted (x:y:ys) = x <= y && isSorted (y:ys); isSorted _ = True}
14:58:32 <byorgey> hygge: oh, right, we don't actually need zip, I was just illustrating how the zipping worked.
14:58:41 <hygge> ah ah
14:58:51 <Taejo> byorgey, I think yours is more elegant
14:59:03 <byorgey> thanks Taejo =)
14:59:46 <reqamst> > map (/1) [1,5..11]
14:59:46 <lambdabot>  [1.0,5.0,9.0,13.0]
14:59:54 <reqamst> wtf? 13?!
15:00:02 <Olathe> 13 !
15:00:03 <byorgey> *sigh*
15:00:19 <byorgey> it's because of the retarded Enum instance for Doubles.
15:00:24 <monochrom> heheheh
15:00:25 <reqamst> I have a big problem with that. X_x
15:00:28 <Olathe> > [1,5..11]
15:00:29 <lambdabot>  [1,5,9]
15:00:30 <byorgey> try this instead:
15:00:33 <Olathe> > [1,5..11]::[Float]
15:00:33 <lambdabot>  [1.0,5.0,9.0,13.0]
15:00:40 <byorgey> > map (/1) [1,5..11] :: Rational
15:00:41 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[a]'
15:00:47 <byorgey> > map (/1) [1,5..11] :: [Rational]
15:00:47 <lambdabot>  [1%1,5%1,9%1,13%1]
15:00:51 <byorgey> erm
15:00:53 <monochrom> > ([1,5..11] :: [Int], [1,5..11] :: [Integer])
15:00:54 <lambdabot>  ([1,5,9],[1,5,9])
15:01:02 <monochrom> Now that's interesting!
15:01:05 <Olathe> > map (/1) ([1,5..11] :: [Rational])
15:01:06 <lambdabot>  [1%1,5%1,9%1,13%1]
15:01:12 <Olathe> > map (/1::Rational) ([1,5..11] :: [Rational])
15:01:13 <lambdabot>  Parse error at "::Rat..." (column 8)
15:01:16 <byorgey> > [1,5..11] :: [Rational]
15:01:16 <lambdabot>  [1%1,5%1,9%1,13%1]
15:01:19 <Olathe> > map (/(1::Rational)) ([1,5..11] :: [Rational])
15:01:19 <lambdabot>  [1%1,5%1,9%1,13%1]
15:01:22 <byorgey> le sigh
15:01:23 <Olathe> :(
15:01:28 <Olathe> Bad Haskell !
15:01:32 <Olathe> Bad !
15:01:40 <monochrom> > ['A','E'..'K']
15:01:41 <Olathe> No !
15:01:41 <lambdabot>  "AEI"
15:01:49 <sarehu> hrm...
15:01:58 <byorgey> it's because 13 is less than or equal to half of the way from 11 to (11+4)
15:02:08 <sarehu> > [1e30..]
15:02:08 <lambdabot>  [1.0e30,1.0e30,1.0e30,1.0e30,1.0e30,1.0e30,1.0e30,1.0e30,1.0e30,1.0e30,1.0e3...
15:02:12 <monochrom> Either Int,Integer,Char are stupid, or Rational,Float,Double are stupid. :)
15:03:02 <byorgey> > map (%1) ([1,5..11] :: [Integer]) :: [Rational]  -- this ought to work
15:03:05 <reqamst> Crazy.
15:03:07 <lambdabot>  [1%1,5%1,9%1]
15:03:09 <Olathe> > [Infinity..]
15:03:09 <lambdabot>  Parse error at "Infin..." (column 2)
15:03:29 <sarehu> neither are stupid
15:03:34 <ddarius> @seen shapr
15:03:34 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 1h 54m 24s ago.
15:03:41 <sarehu> > [0.1..5.1]
15:03:41 <lambdabot>  [0.1,1.1,2.1,3.1,4.1,5.1]
15:04:04 <sarehu> If you want something like that to work, you have to have /some/ approximation cutoff
15:04:13 <byorgey> sarehu: exactly.
15:04:28 <byorgey> but it leads to much weirdness.
15:04:42 <byorgey> personally, I don't think there should be an Enum instance for those types at all.
15:04:51 <monochrom> The approximation excuse doesn't apply to Rational, first of all.
15:05:01 <sarehu> yeah, if you are using enumFromTo on those, there are severe issues anyway
15:05:16 <reqamst> > map (1/) ([1,5..11] :: [Integer]) :: [Rational]
15:05:16 <lambdabot>  Couldn't match expected type `Rational'
15:05:27 <ddarius> > [1..] :: Fixed E12
15:05:27 <lambdabot>  Couldn't match expected type `Fixed E12'
15:05:40 <ddarius> > [1..] :: [Fixed E12]
15:05:40 <lambdabot>  [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004,...
15:05:44 <byorgey> reqamst: in that case you have to use % instead of /
15:05:46 <ddarius> That's broken
15:05:55 <monochrom> Second of all, [1,5..11] is so far from the machine epsilon that the approximation excuse doesn't apply either. We are not talking about [1, 1.0000000000000001..].
15:06:00 <Olathe> [1,1.000000000001..]
15:06:02 <Olathe> > [1,1.000000000001..]
15:06:03 <lambdabot>  [1.0,1.000000000001,1.0000000000020002,1.0000000000030003,1.0000000000040004...
15:06:06 <Olathe> Yay !
15:06:35 <byorgey> > 1 / 2 :: Rational  -- reqamst, this only works because the 1 and 2 get converted to Rational values by implicit fromIntegral calls.
15:06:35 <lambdabot>  1%2
15:06:50 <byorgey> > (1 :: Integer) / (2 :: Integer) -- this doesn't work.
15:06:50 <lambdabot>   add an instance declaration for (Fractional Integer)
15:06:50 <lambdabot>     In the expression:...
15:07:58 <reqamst> huh, that doesn't work!
15:08:17 <reqamst> > map (%1) ([1,5..11] :: [Integer]) :: [Rational]
15:08:18 <lambdabot>  [1%1,5%1,9%1]
15:08:21 <sarehu> imo you should calculate the top to be the last value of the list specifically -- having a rounding cutoff for Rational still makes sense because of toRational
15:08:28 <reqamst> On my local ghci.
15:08:31 <Olathe> > 1 / 2 :: Rational
15:08:31 <lambdabot> Terminated
15:08:37 <Olathe> Heh.
15:08:55 <Olathe> @let id = const 2
15:08:55 <lambdabot> Defined.
15:08:58 <Olathe> > 5 + 5
15:08:59 <lambdabot>  10
15:09:02 <Olathe> > id 3
15:09:02 <lambdabot> Terminated
15:09:06 <Olathe> @undefine
15:09:06 <lambdabot> Undefined.
15:09:21 <Olathe> If you @let something that exists, it doesn't work anymore.
15:09:51 <ddarius> @let god = god
15:09:51 <lambdabot> Defined.
15:09:53 <ddarius> > god
15:09:53 <lambdabot>  Exception: <<loop>>
15:10:19 <ddarius> Looks like it's working to me...
15:10:34 <monochrom> hehehe
15:10:35 <byorgey> god is bottom?
15:10:48 <monochrom> god inhabits every type
15:10:52 <waern> blasphemy!
15:10:59 <monochrom> omnipresence
15:11:00 <Olathe> That isn't a built-in.
15:11:09 <Olathe> @let (/) a b = 1
15:11:10 <lambdabot> Defined.
15:11:16 <waern> monochrom: hm, that's right
15:11:17 <Olathe> > 6 / 7
15:11:18 <lambdabot> Terminated
15:11:21 <monochrom> hehehehe
15:11:33 <Olathe> @let foldr a b c = 1
15:11:34 <lambdabot> Defined.
15:11:40 <Olathe> > foldr 1 2 3
15:11:40 <lambdabot> Terminated
15:11:43 <NaN_n_Curry> Can anyone help me with building GHC 6.8.1 on Linux?
15:11:44 <ddarius> > god
15:11:44 <lambdabot>  Exception: <<loop>>
15:11:46 <Olathe> @undefine
15:11:46 <lambdabot> Undefined.
15:11:50 <ddarius> Bah
15:11:53 <NaN_n_Curry> It fails with: Setup: The program happy is required but it could not be found
15:12:05 <pheaver> NaN_n_Curry: heh, install happy?
15:12:19 <pheaver> I had that error on OS X and FreeBSD, though I didn't get it until halfway through make
15:12:42 <pheaver> NaN_n_Curry: what architecture are you on?  Are you including the extra libraries?
15:12:43 <monochrom> You could install happy 1.17. It is just for one of the libraries in "extralibs". You could also consider dropping "extralibs", then you won't need happy.
15:12:56 <hashendgame> Does anyone know of a function that accesses the select(2) syscall? Google's failing me: I find documentation for modules that I can't find
15:13:01 <pheaver> Installing happy actually didn't fix my problem, I don't know why
15:13:03 <NaN_n_Curry> from the docs, I didn't think the source tarball needed it?'
15:13:12 <dons> hashendgame: forkIO / et al use select
15:13:18 <dons> hashendgame: i.e. Control.Concurrent
15:13:18 <pheaver> NaN_n_Curry: also, there is a patch in darcs that fixes this
15:13:50 <NaN_n_Curry> pheaver: I'm on Slackware 10.1, PIII-1GHz
15:13:53 <monochrom> the "extralibs" tarball needs it, that is why.
15:14:09 <pheaver> NaN_n_Curry: Try building without the extralibs
15:14:16 <pheaver> then install those later
15:14:37 <NaN_n_Curry> pheaver: OK, I'll try it without extralibs.Thanks.
15:14:42 <pheaver> or find out which extralibs doesn't work, and just remove that one
15:14:51 <pheaver> I know haskell-src is one of the ones that craps out when happy is not installed
15:15:29 <pheaver> in ghc/libraries, there is a file (I think called extra-packages), which simply lists all the extralibs
15:15:43 <pheaver> I believe you may safely remove any directory that is listed in that file
15:15:49 <hashendgame> dons: that's one way of dealing with it, but is there anything like hSelect http://www.haskell.org/ghc/docs/6.4.2/html/hslibs/Select.html in the standard library?
15:15:49 <lambdabot> Title: 9.5. Select: Synchronous I/O multiplexing
15:15:59 <pheaver> and it will no longer try to build that package when you compile ghc
15:16:09 <dons> hashendgame: probably in the unix or posix package
15:16:11 <dons> not in base
15:16:41 <NaN_n_Curry> pheaver: just configured/build/install happy, now recompiling 6.8.1
15:17:07 <dons> all the underlying Conc stuff is on top of select, and portable, so I'd use that if at all possible
15:17:14 <dons> you can wait a thread on an Fd, for exampel
15:17:50 <hashendgame> dons: Is there any compelling reason not to go the forkIO route? I'm looking at building a basic mud server or something and most of the code is select(2) based, I believe.
15:17:50 <sjanssen> concurrency is also more composable than select
15:18:07 <dons> i can't think of a reason not to use forkIO
15:18:13 <hashendgame> it could just be I'm still thinking in terms of inherited relics
15:18:28 <dons> it will be very fast, composable, and you have a lot of nice concurrency abstractions
15:18:29 <goalieca> forkIO with -threaded compile flag
15:18:33 <sjanssen> hashendgame: do you have to interface with C libraries?
15:18:46 <hashendgame> sjanssen: no
15:18:48 <sjanssen> goalieca: even the non-threaded RTS handles this well
15:18:59 <dons> ah ok. then definitely Control.Concurrent
15:19:05 <hashendgame> cheers guys
15:21:00 <sjanssen> hashendgame: plus, with forkIO you can automatically scale your application to N CPUs :)
15:21:09 <hashendgame> sjanssen: bonus!
15:21:43 <goalieca> i'm going to have to read haskells approach over. i'm taking a grad course (systems level) on multicore. would be interesting to see some ideas
15:21:56 <goalieca> well by jan when the course starts
15:22:19 <ddarius> Haskell doesn't have -an- approach
15:22:32 <dons> all your approaches belong to us
15:22:50 <Adamant> *are
15:22:51 <Zao> Yay for STM.
15:22:52 <goalieca> well lets put it this way.. all i've studied over the years is chip design really. haskell is about as high level as it gets
15:23:01 <goalieca> so.. it is quite different
15:23:09 <sjanssen> goalieca: there are lots of really good papers to read
15:23:10 <ddarius> goalieca: Not really...
15:23:49 <sjanssen> goalieca: "Haskell on a shared-memory multiprocessor" is good, so is "Composable memory transactions"
15:24:55 <goalieca> composable memory transactions is what the STM approach in haskell is all about from what i gather
15:25:00 <sjanssen> yes
15:25:08 <waern> dcoutts: ping
15:25:33 <sjanssen> "Haskell on a shared-memory multiprocessor" is about porting GHC's runtime system to multi-core
15:25:59 <goalieca> is this concurrent haskell or data parallel haskell
15:26:23 <sjanssen> not DPH
15:27:22 <hygge> bye and thx!
15:28:02 <goalieca> sjanssen, thanks, i dl'd both those papers. i also read "beautiful code" which is STM and quite a good read
16:00:30 <byorgey> @arr me hearties!
16:00:30 <lambdabot> I'll crush ye barnacles!
16:00:50 <LoganCapaldo> I have no barnacles
16:02:49 <EvilTerran> that's okay, you can borrow some of mine
16:03:10 <LoganCapaldo> under an open sea creature license?
16:03:15 <Raguel> i wonder if they're tasty
16:03:53 <Raguel> curried barnicles
16:04:21 <dons> ?yow
16:04:21 <lambdabot> Couldn't find fortune file
16:04:42 <dons> ah
16:07:38 <Raguel> mmmm .
16:07:46 <Raguel> laptop heater
16:08:12 <Raguel> aka hot water bottle with windows
16:08:17 <byorgey> I don't think barnacles would be tasty.
16:08:18 <TSC> Laptop steriliser, more likely
16:08:27 <Raguel> :P
16:08:30 <byorgey> they'd probably lacerate your tongue.
16:08:52 <Raguel> i'm not lickingit
16:09:09 <dons> ?yow
16:09:09 <lambdabot> Is this the line for the latest whimsical YUGOSLAVIAN drama which also
16:09:09 <lambdabot> makes you want to CRY and reconsider the VIETNAM WAR?
16:09:15 <lucca> sharpest thing i've tried eating was whole artichoke leaves
16:09:39 <Raguel> ooer
16:09:49 <byorgey> eek
16:09:52 <Raguel> i dun eat shap
16:10:01 <Raguel> sharp
16:10:16 <byorgey> shapr?
16:10:29 <Raguel> meh
16:10:35 <Raguel> sharpe
16:11:00 <lucca> sharpei
16:11:14 <Raguel> pei = pie?
16:11:55 <mauke> perl -pei /= perl -pie
16:11:56 <lucca> sharpei :: Dog
16:12:32 <Raguel> zzz
16:12:44 <Raguel> just can't keep awake today :(
16:12:51 <Raguel> bed then :(:(
16:12:57 <Raguel> wanted to do some more learnings
16:13:06 <Raguel> but its midnight and i fail
16:13:08 <Philippa_> late night learning has costs, unfortunately
16:13:20 <Raguel> not if you have drugs :)
16:13:31 <Raguel> ask liang
16:13:32 <byorgey> that's ok, there'll be plenty to learn tomorrow =)
16:13:41 <Raguel> oh i know
16:13:47 <Raguel> denotational semantics :)
16:14:03 <byorgey> for example.
16:14:13 <Raguel> (lectures)
16:14:29 <Raguel> but its nice to turn up to lectures having learned something in the intervining week
16:14:41 <Raguel> but ephedra ftw
16:14:52 <Raguel> it just negates the NEED for sleep
16:14:52 <Philippa_> heh, I found my old POP notes yesterday while digging up the rest of my ex's stuff
16:15:00 <Raguel> just means that boring stuff makes me zzz
16:15:10 <Raguel> its all new to me
16:15:18 <Raguel> except operational semantics - i know that now
16:15:43 <Spark> the appropriate level of abstraction
16:15:57 <Raguel> ?
16:17:03 <Raguel> wow
16:17:09 <Raguel> taking my coat off made me less sleepy :S
16:17:43 <omnId> Raguel: put it back on.
16:18:01 <Raguel> well ski jacket in bed...
16:18:16 <Raguel> anyway less sleepy=more reading \o/
16:18:20 <Raguel> reading haskell book
16:18:35 <Raguel> having done past papers
16:19:14 <dons> shapr: want to port ghc to android?
16:24:27 <dons> shapr: http://code.google.com/android/adc.html
16:24:27 <lambdabot> Title: Android Developer Challenge - Android
16:26:18 <matthew-_> nah, don't waste your time with that. Just get it working on openmoko and write a full interface to the phone for haskell
16:27:17 <matthew-_> then we can write an entire phone stack in haskell. much better than messing with that android rubbish.
16:27:20 <byorgey> dons: I'm going to be very disappointed if you don't win that $10,000,000.
16:27:24 <dons> heh
16:27:35 <dons> for porting ghc to the google jvm?
16:27:54 <dons> and porting xmonad to run on the google phone? :)
16:28:03 <byorgey> there we go =)
16:28:32 <dons> prizes for "Rethinking of traditional user interfaces" and "Humanitarian benefits"
16:28:40 <dons> porting haskell will benefit humanity greatly
16:29:14 <matthew-_> and will facilitate the rethinking of traditional user interfaces
16:29:39 <matthew-_> i.e. lazy guis: it's only displayed once you've decided which button to click on
16:31:28 <byorgey> and only the parts of windows that you actually look at get painted.
16:31:53 <sarehu> the resources devoted to eyetracking would be more than saved by painting...
16:32:07 <dons> looks like we can just cross compile, http://benno.id.au/blog/2007/11/13/android-native-apps
16:32:08 <lambdabot> Title: Benno's Website
16:32:17 <Pseudonym> Oh, I know Benno.
16:32:19 <byorgey> eyetracking?  I was thinking a neural interface.
16:32:40 <dons> go Benno!
16:32:41 <Pseudonym> In fact, drtomc was, until recently, a cow-orker of his.
16:32:50 <dons> Pseudonym: yet another nicta kernel hacker
16:32:53 <Pseudonym> Oh.
16:32:55 <Pseudonym> Different Benno.
16:33:14 <dons> he's a phd at unsw in the embedded kernel gropu
16:33:29 <dons> though i think he works for open kernel labs now, the spinoff
16:33:37 <Pseudonym> I was thinking of Benno Rice.
16:34:15 <dons> oh, and njbartlett is in on the game toohttp://neilbartlett.name/blog/2007/11/13/google-android-now-100-java-free/
16:36:38 <waern> I think you should write a program that use the phone receiver to measure the brainwaves of people
16:37:02 <waern> that would be creative ;)
16:37:06 * thoughtpolice thinks he might have convinced one of his friends to use haskell :)
16:38:17 <thoughtpolice> after being exposed to an awful, ridiculously limited language based loosely on java in our little comp sci. class, he apparently liked haskell a lot more. even installed ghc and played around.
16:38:31 <thoughtpolice> (luckily he wasn't warped or anything because that wouldn't have been cool.)
16:38:40 <dons> nice
16:38:48 <dons> so what did you tell him?
16:38:49 <byorgey> thoughtpolice++
16:38:58 <byorgey> you get a karma point for evangelism =)
16:41:11 <TomMD> "Haskell makes it twice as hard to produce a program thats ten times more powerful... not to mention reliability and maintainability benefits."
16:41:50 <dons> interesting, TomMD :)
16:42:34 <TomMD> :-)
16:42:39 <thoughtpolice> dons: we were in class and I was getting kind of pissed from being exposed to this language (it's meant as an introduction language: you can't even create methods that pass parameters to methods)
16:43:08 <thoughtpolice> anyway, I told him about it before but the other day I was pissed because I didn't have higher order functions, so today he told me how he installed ghc and played around with the interpreter a little bit
16:43:11 <dons> hmm. so it teaches you what, simple control structures ?
16:43:16 <thoughtpolice> dons: basically.
16:43:24 <dons> nice
16:43:39 <thoughtpolice> showed him some examples of code
16:43:39 <ddarius> control structures are for the weak
16:43:47 * EvilTerran is reminded of being taught oberon **shudder**
16:44:13 <thoughtpolice> in most (well, all) cases, he thought the haskell version was more concise, easier to write and less trouble
16:44:37 <thoughtpolice> i actually asked the teacher if we could just use haskell for our assignments when the rest of the class used java providing the outputs were the exact same
16:45:05 <dons> that's a good strategy sometimes
16:45:27 <dons> what did they say...
16:46:34 <shapr> dons: Very much so, I've already been asking about the bytecode format.
16:46:47 <thoughtpolice> dons: he said he'd think about it. i had him for class last year and I we agreed that I could have a little more leniency in my decisions
16:46:52 <shapr> dons: I've been looking at Andriod together with a friend of mine from Finland.
16:46:52 <thoughtpolice> so i'm about 80% sure he'll say yes
16:47:08 <dcoutts> EvilTerran: in theory oberon might be ok as a teaching language, but we never have any syntax or library references.
16:47:19 <thoughtpolice> if so it'll probably just be me and my friend hacking haskell in class, which will be fun. :)
16:47:36 <shapr> Oberon was my first alternative operating system.
16:47:44 <omnId> thoughtpolice: does the instructor understand any Haskell?
16:47:53 <dcoutts> EvilTerran: we should just use the guarded command language :-)
16:47:57 <shapr> dons: I don't think the vm spec has been released yet though.
16:48:00 <EvilTerran> dcoutts, it's a grotty little language, though
16:48:03 <thoughtpolice> omnId: no, but he's seen some of my work so he trusts me enough.
16:48:10 <EvilTerran> the string quoting rules are irretrievably broken
16:48:15 <thoughtpolice> omnId: but then again, i don't know his entire background, so I could be wrong
16:48:17 <dons> shapr: you can also run normal C apps on it, cross compiled for arm
16:48:24 <omnId> thoughtpolice: evangelism opportunity!
16:48:36 * dcoutts wrote an impl of the GCL for his undergrad project (in Haskell of course)
16:48:37 <shapr> dons: Oh, I was thinking about STG -> Dalvik
16:48:39 <EvilTerran> the use of null-terminated strings in anything other than glorified assembly (aka C) is a crime against humanity
16:48:48 <shapr> dons: How do we fit GHC into a phone?
16:48:49 <dons> ah right. a proper port :)
16:48:51 <thoughtpolice> omnId: already done. :)
16:48:54 <dons> well, we cross compile
16:49:02 <dons> i don't think you actually want ghc on the thing
16:49:07 <dons> just the runtime
16:49:07 <shapr> You think the resulting binaries would be fast enough?
16:49:09 <EvilTerran> not to mention the UPPER CASE KEYWORDS
16:49:15 <TomMD> thoughtpolice: careful! You might cause Haskell to be a huge success, then you'd have the wrath of SPJ.  "Avoid success at all costs."
16:49:16 <dcoutts> EvilTerran: yeah, that's annoying
16:49:29 <EvilTerran> the quoting rules were what annoyed me the most, tbh
16:49:36 <dcoutts> we should just use pascal
16:49:37 <EvilTerran> "foo" - string; "f" - character
16:49:54 <omnId> EvilTerran: and a one-character string?
16:50:06 <EvilTerran> omnId, no such thing
16:50:19 <shapr> dons: Do you think STG -> Dalvik would produce faster binaries than a cross compiled GHC?
16:50:21 <LoganCapaldo> there is no one character string there is only zuul
16:50:31 <thoughtpolice> TomMD: hah.
16:50:38 <EvilTerran> have to construct it with functions; there's no way to have a one-character string literal in oberon, AFAICT
16:50:44 <thoughtpolice> i'll do my best to keep the amount of popularity to a minimum
16:50:55 <EvilTerran> and no way of including newlines or tabs or anything
16:51:07 <bos> shapr: it will have an easier time interoperating, which is significant.
16:51:15 <yaw> ChilliX: Hi
16:51:17 <LoganCapaldo> I think I've said this before, but newlines are for the weak!
16:51:23 <EvilTerran> and you can only have "s in a '-quoted string, and vice-versa
16:51:52 <monochrom> I will try to have no newline in my haskell source programs.
16:51:54 <dons> shapr: well, you can't access the phone with a cross compiler
16:52:03 <dons> you'd only be able to do that via the vm
16:52:07 <LoganCapaldo> EvilTerran: is "" valid syntax?
16:52:18 <EvilTerran> in that it's the null string, yes, i think so
16:52:25 * omnId googles this Oberon thing.
16:52:27 <dons> which means a new backend (==hard) or maybe write an interpreter in java for ghci bytecode?
16:52:39 <EvilTerran> if you mean "foo""bar" = 'foo"bar', then no.
16:52:53 <monochrom> "xxx" notation is for the weak. 'x':'x':'x':[]
16:52:54 <LoganCapaldo> EvilTerran: I meant former
16:53:38 <LoganCapaldo> infix is for the weak! (:) 'x' ((:) 'x' ((:) 'x' []))
16:53:40 <omnId> monochrom: the special cased character data constructors are lame!  Cx : Cx : Cx : Nil
16:53:49 <EvilTerran> if it weren't unforgivable to have such awful quoting rules (every successful language uses some approximation of the C-style string literals for a GOOD REASON), it would almost be forgivable
16:54:02 <shapr> dons: Yeah, that would work.
16:54:12 <EvilTerran> ... well, if manipulation of strings wasn't so painful too
16:54:12 <monochrom> I agree with Cx.
16:54:15 <mauke> does common lisp count as successful?
16:54:20 <Saizan_> omnId: you mean Cons Cx (Cons Cx (Cons Cx Nil)), right?
16:54:26 <omnId> Saizan_: of course I do.
16:54:37 <EvilTerran> mauke, does it not use \ escaping?
16:54:41 <omnId> Saizan_: that's in fact what I said, you won't convince me otherwise.
16:54:46 <omnId> Saizan_: :P
16:54:53 <mauke> EvilTerran: it might, but only for " and \ itself
16:55:06 <mauke> no newlines or anything
16:55:13 <EvilTerran> well, that still counts as "some approximation". ish. ;)
16:55:14 <monochrom> quoting, unquoting, and escaping are a mess.
16:55:21 <EvilTerran> how do you get newlines in your strings?
16:55:31 <mauke> why, with sprintf!
16:55:43 <omnId> EvilTerran: some kind of chrish function and string concat?
16:55:50 <mauke> (format nil "~%") or something like that
16:56:14 <omnId> "One." ++ chr 10 ++ "Two."
16:56:22 <EvilTerran> ew
16:56:27 <omnId> [chr 10]*
16:56:38 <mauke> well, there's #\Newline  ; character constant
16:57:40 <omnId> Oh, you're talking CL?  Never used it.
16:59:15 <omnId> I was just saying, in a language lacking sane newline quoting, there's always that as a fallback.
17:00:14 <EvilTerran> it gets exceedingly painful if you have neither newline quoting nor easy string manipulation
17:00:37 <mauke> it gets easier if you don't have strings
17:00:54 <omnId> :)
17:01:10 <EvilTerran> well, unless by "easier" you mean "easier to solve a given problem involving strings"
17:01:21 <EvilTerran> which is kinda what i meant :P
17:01:52 <LoganCapaldo> lately I've started to feel like that string as a datatype is overloaded
17:01:54 <mauke> just encode your strings as numbers
17:02:08 <LoganCapaldo> We don't have Number, we have Int, Integer, Float, Double etc.
17:02:29 <LoganCapaldo> Why aren't there more variations on string?
17:02:49 <omnId> Yeah, I messed around with this one language when really getting into learning programming that effectively had two types: number and heterogenous list.
17:03:09 <LoganCapaldo> I'd like to see at least a way to distinguish between strings and text
17:03:21 <SamB_XP> omnId: strange lisp dialect?
17:03:49 <SamB_XP> LoganCapaldo: strings and text?
17:03:54 <LoganCapaldo> where text is maybe language aware (ie right to left vs. left to right etc.)
17:03:59 <omnId> SamB_XP: no, some little-known shareware imperative thingy some guy made on his own.  Euphoria it was called.
17:04:12 <LoganCapaldo> just something I'v ebeen kicking around
17:04:15 <LoganCapaldo> in my head
17:04:24 <SamB_XP> LoganCapaldo: the answer to that is that we don't have any non-sucky models for text, probably
17:04:30 <LoganCapaldo> yeah
17:04:36 <LoganCapaldo> it's probably something liek that
17:05:02 <LoganCapaldo> which is why we're still stuck with one(ish) string type
17:05:29 <EvilTerran> we've got characters vs bytes
17:05:34 <omnId> it's not a trivial problem
17:05:35 <allbery_b> until recently we didn't have string overloading the way we do for numeric overloading
17:05:36 <EvilTerran> well, vs octets
17:06:01 <LoganCapaldo> allbery_b: I was thinking in general just not haskell
17:06:06 <monochrom> What are strings?
17:06:07 <LoganCapaldo> *not just
17:06:13 <EvilTerran> gotta look out for that double-bucky ;)
17:07:16 <allbery_b> LoganCapaldo: I'd argue that, much as Perl doesn't have a firm idea of numeric types, nobody has ever had a good way to deal with multiple string-like types
17:07:38 <LoganCapaldo> allbery_b: I agree
17:07:42 <allbery_b> Haskell now having string overloading, it's in a position to e.g. fold some kind of safe-text (vs. unsafe web text) into the libraries, etc.
17:08:32 <gwern> so I was thinking of maybe starting Knuth's TAOCP, but it seems that it has a very low-level and  imperative mindset. is there any more functional or haskelly equivalent?
17:08:40 <allbery_b> anyway since nobody really had the support, nobody really thought about it.
17:09:03 <LoganCapaldo> I dunno I was think about it before I heard about IsString, but I might be weird <g>
17:09:16 <allbery_b> that said, we've already got rather divergent ideas as to how to handle numbers (cf. NumericPrelude) --- what kinds of rat's nest does multiple string-like types open?
17:09:22 <LoganCapaldo> not that I got anywhere with the thinking :)
17:10:03 <scook0> gwern: what sort of thing are you after?
17:10:22 <LoganCapaldo> My theory is that we're living in the rat's nest already
17:10:56 <gwern> scook0: datastructures and algorithms, more or less
17:10:57 <omnId> @@ @run unwords . sortBy (compare `on` map toLower) . words $ @show @yow
17:10:58 <lambdabot>  "... ... I SEATS see TOILET"
17:11:02 <LoganCapaldo> In that every program has it's own adhoc (usualy shallow) unenforced string type hierarchy
17:11:24 <scook0> gwern: for data structures, there's Okasaki
17:11:30 <gwern> not so much the more esoteric bits of FP, but stuff like functional data structures and algorithms, I suppose
17:11:41 <scook0> "purely functional data structures"
17:11:52 <gwern> scook0: hm. sounds promising.
17:11:53 * gwern googles
17:12:15 <gwern> hope there's a dead wood version. easier to read
17:12:28 <smack__> gwern: there is
17:12:40 <monochrom> I have not seen a live wood version actually.
17:12:56 <LoganCapaldo> mmm live tree books
17:13:01 <LoganCapaldo> that would be awesome
17:13:06 <gwern> a live wood version would bve problematic. you'd have to water it, and then the ink might run
17:13:16 <LoganCapaldo> I'd go out in the woods and read
17:13:20 <LoganCapaldo> climbing up it
17:13:46 <scook0> gwern: I think the electronic stuff with the same title is earlier and has less stuff in it
17:13:55 <monochrom> My desk is also dead wood.
17:13:59 <Adamant> you'd have differences between people who climb up to read and those who climb up then read on the way down.
17:14:06 <gwern> 'All source code is given in Standard ML and Haskell,' <-- that's good, the haskell part anyway
17:14:08 <scook0> monochrom: wood is murder!
17:14:34 <LoganCapaldo> Adamant: you could do both
17:14:39 <monochrom> Where do you put your keyboard on? Some dead wood?
17:14:48 <gwern> 'The description of the book says it includes source code in both ML and Haskell. Unfortunately, the body of the text uses ML exclusively, and the Haskell code is banished to an appendix. ' <-- ack!
17:14:57 <LoganCapaldo> eh
17:15:13 <LoganCapaldo> if you can read haskell you can grope your way thru ML
17:15:14 <gwern> so it was published in 1999? isn't that a bit old?
17:15:32 <scook0> gwern: didn't you say you were thinking of reading TAOCP?
17:15:38 <scook0> *that*'s old
17:15:40 <scook0> :)
17:15:48 <LoganCapaldo> scook0 with the touche!
17:15:54 <monochrom> de Bruijn's paper is 1972 and I'm going to read it now.
17:15:57 <gwern> scook0: I was under the impression FP had been moving a lot faster than the stuff Knuth was covering
17:16:03 <EvilTerran> haskell is ML with hindsight
17:16:16 <omnId> EvilTerran: quotable!
17:16:33 <TomMD> @quote erlang
17:16:33 <EvilTerran> well, go on then ;)
17:16:33 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
17:16:33 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
17:16:47 <omnId> @remember EvilTerran haskell is ML with hindsight
17:16:47 <lambdabot> I will never forget.
17:16:53 <EvilTerran> :D
17:16:53 <monochrom> The lambda calculus is 193x and you still need to know just a little bit about it before all the 2007 developments make sense.
17:17:14 <gwern> (hm. wonder how much google books will let me read)
17:17:24 <omnId> @quote EvilTerran
17:17:24 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
17:17:41 <TomMD> @quote simonm
17:17:41 <lambdabot> No quotes match. I feel much better now.
17:18:55 <newsham> tommd/lambdabot/dons: i just come her for the bot ;-)
17:19:07 <gwern> wow. the online pdf seems to date back to '96, 11 years ago
17:19:14 <LoganCapaldo> Come for the bot, stay for the conversation
17:19:35 <TomMD> newsham: I know, thats why I don't add much content.
17:19:41 <newsham> exploding bottoms :(
17:20:30 <Nafai> Has anyone made Ubuntu packages of GHC 6.8?
17:21:29 <ptolomy> Hmm. I'm working on a fun puzzle. Somebody asked me how to find the intersection between two sorted arrays, and I came up with the semi-naive O(m log n) solution (when m is the smaller), but later it occured to me that I can do better by doing a sort of parallel (as in 'over both') binary search.
17:21:41 <byorgey> Nafai: I think there are Debian packages somewhere, which is the same thing...
17:22:12 <ptolomy> it seemed like it'd be trivial to hack together (I'm using 'Window' datatypes.. just offsets and an array reference), but it is slightly harder than I expected due to my lack of consideration for terminal cases.
17:22:43 <byorgey> ptolomy: if they're sorted, can't you do O(m + n)?
17:22:47 <ptolomy> Anyway, I recommend it to anyone bored and looking for a few minutes of fun puzzle.
17:23:00 <scook0> ptolomy: yeah, can't you just do a merge?
17:23:05 <ptolomy> Oh, sure.
17:23:18 <Nafai> byorgey: I was just thinking about it because of dons' latest entry about the debugger.  I ran into the same error he demonstrated last week and some extra help would have been nice :)
17:23:32 <ptolomy> but if n is really really big and m is considerably smaller, there are better solutions.
17:23:54 <scook0> ah
17:24:05 <byorgey> Nafai: I see.  well, I'm using 6.8.1 on Ubuntu, but I may not be of much help since I compiled it from source (just for fun =).
17:24:19 <scook0> so that would be "search for each of m to see if it's in n"
17:24:26 <byorgey> ptolomy: oh, I see.
17:24:28 <kpreid> > replicate -1 'x'
17:24:29 <lambdabot>        add an instance declaration for (Num (Char -> Int -> a -> [a]))
17:24:33 <scook0> with the optimization being to remember where your last search ended
17:24:35 <kpreid> > replicate (-1) 'x'
17:24:35 <lambdabot>  ""
17:24:56 <scook0> (whereas the naive solution doesn't require that m be sorted)
17:25:30 <ptolomy> scook0: well, I believe that still ends up being O(m log n)
17:26:07 <byorgey> Nafai: how fast is your computer?
17:26:29 <byorgey> Nafai: compiling from source was actually quite painless for me, so perhaps you could go that route.
17:27:13 <Nafai> byorgey: 1.6 Ghz Core 2 Duo, so it's probably doable
17:27:55 <TomMD> I compiled from source on a Ubuntu 7.04 without pain.
17:29:02 <LoganCapaldo> +
17:29:32 <Nafai> I guess I could try that
17:29:46 <monochrom> I am on Ubuntu 6.06 but I use the generic binary. I use a hex editor to change references to libreadline4 to libreadline5. I learned that from someone here.
17:30:21 <monochrom> When 6.6.1 came out, I also built it myself.
17:30:44 <thoughtpolice> man, I had to build ghc twice to get it installed on my openbsd box. :(
17:30:55 <thoughtpolice> i compile (almost) everything from source anyway though...
17:30:59 <gwern> monochrom: um. that sounds like something you should've filed a bug report on
17:31:13 <gwern> thoughtpolice: openbsd makes you bootstrap?
17:31:15 <monochrom> No, it is alright.
17:31:44 <thoughtpolice> gwern: no, I was using ports to compile the hc-ized ghc 6.2.2 tree
17:31:48 <thoughtpolice> which I then used to compile ghc 6.6.1
17:32:14 <gwern> hc-ized?
17:32:16 <thoughtpolice> speaking of, I think I might try to port ghc 6.8.1 to dragonflybsd one of these rainy cold days coming up...
17:32:33 <thoughtpolice> gwern: when you bootstrap from hc files; that's how the openbsd port for ghc was set up, but it was dated back to 6.2.2
17:32:43 <thoughtpolice> i believe dons upgraded it to 6.6.1 sometime a while back though
17:32:57 * monochrom doesn't believe in "everything is a bug"
17:33:19 * monochrom thinks there are too many spoiled kids in the world. Everything seems a bug to them.
17:33:34 <Spark> there are some mammals too
17:34:12 <gwern> monochrom: by weight, it seems everything's either microscoper or a bug
17:34:13 <scook0> monochrom: just call it an "infelicity" and nobody will be offended :)
17:34:37 <monochrom> You make me look up infelicity.
17:35:02 <gwern> infelicity is a good word to use. I think I once used it in a darcs patch for xmonad :)
17:35:14 <LoganCapaldo> @wn infelicity
17:35:15 <lambdabot> *** "infelicity" wn "WordNet (r) 2.0"
17:35:15 <lambdabot> infelicity
17:35:15 <lambdabot>      n : inappropriate and unpleasing manner or style (especially
17:35:15 <lambdabot>          manner or style of expression) [ant: {felicity}]
17:35:17 <scook0> in Haskell circles it seems to mean "this is less than ideal, but I'm too polite to declare it a bug"
17:35:49 <Adamant> one of the problems is the open source practice of confusing "feature request" with "bug"
17:36:06 <monochrom> Actually I don't consider the linking against libreadline4 to be an infelicity either. It's totally fine with me.
17:36:34 <monochrom> Yes Adamant, and I think the root cause behind that is spoiled kids.
17:36:55 <Adamant> monochrom, I agree that these kids should get off your lawn
17:36:56 <byorgey> Nafai: yeah, that's about the same specs as mine.  the build took maybe a couple hours, so not too bad.
17:37:09 <Adamant> ;)
17:37:30 <monochrom> Well, at least now I'm getting the issue off my chest. I don't have a lawn.
17:38:15 <LoganCapaldo> I vote we start a lawn for monchrom fund
17:38:22 <monochrom> hahahaha
17:38:31 <SamB_XP> LoganCapaldo: where would he put the lawn?
17:39:03 <monochrom> software that's friendly to those who RTFM, and unfriendly to those who don't.
17:39:24 <LoganCapaldo> SamB_XP: I don't think that's any of our business frankly, and I think it's rude for you to ask.
17:39:30 <monochrom> hahah
17:39:32 <LoganCapaldo> ;)
17:39:46 <SamB_XP> LoganCapaldo: most people with no lawn also have nowhere to keep a lawn
17:40:12 <Adamant> something like OBSD. with a capacitive sensing keyboard implanted on the teeth of a living grizzly bear.
17:40:25 * omnId goes looking for a yard sale...
17:41:58 <QtPlatypus> Adamant: One of the problems of any software project is confusing "feature request" with "bug".
17:42:40 <SamB_XP> QtPlatypus: it isn't a horrible problem
17:42:55 <Adamant> QtPlatypus, look at something like Bugzilla, though. AFAIK it doesn't have a setting for "feature request".
17:42:58 <Brian`> @:t connectTo
17:42:59 <lambdabot>  There was an error in the type: (line 1, column 4):
17:42:59 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
17:43:10 <SamB_XP> the main things needed are the ability to change the summary and type of a ticket
17:43:26 <Brian`> how do I make the lambdabot display a type of a function?
17:43:40 <LoganCapaldo> :t or @type
17:43:41 <lambdabot> parse error on input `type'
17:43:42 <kpreid> :t connectTo
17:43:42 <lambdabot> Not in scope: `connectTo'
17:43:47 <kpreid> @type connectTo
17:43:47 <lambdabot> Not in scope: `connectTo'
17:43:52 <kpreid> ?type connectTo
17:43:52 <lambdabot> Not in scope: `connectTo'
17:44:07 <SamB_XP> I think bugzilla can handle feature requests when properly configured
17:44:11 <LoganCapaldo> (or ?type, I forgot that one)
17:44:29 <allbery_b> :t Network.connectTo
17:44:29 <lambdabot> Network.BSD.HostName -> Network.PortID -> IO GHC.IOBase.Handle
17:44:30 <monochrom> The problem is with "connectTo", not with :t or @type or ?type
17:44:38 <Brian`> :t Network.connecTo
17:44:38 <lambdabot> Not in scope: `Network.connecTo'
17:45:08 <LoganCapaldo> @hoogle connectTo
17:45:09 <Brian`> :t Network.connectTo
17:45:09 <lambdabot> Network.connectTo :: HostName -> PortID -> IO Handle
17:45:09 <lambdabot> Network.CGI.connectToCGIScript :: String -> PortID -> IO ()
17:45:10 <lambdabot> Network.BSD.HostName -> Network.PortID -> IO GHC.IOBase.Handle
17:45:16 <Brian`> here, I have a question
17:45:23 <Brian`> what do I know what type HostName is?
17:45:34 <Brian`> from a source code it looks like it is a String
17:45:46 <sjanssen> @hoogle HostName
17:45:46 <lambdabot> Network.HostName :: type HostName
17:45:46 <lambdabot> Network.BSD.hostName :: HostEntry -> HostName
17:45:46 <lambdabot> Network.BSD.getHostName :: IO HostName
17:45:49 <Brian`> but how come it says HostName there? how do I know the underlying type of HostName?
17:45:54 <Brian`> oh..
17:45:59 <allbery_b> it's in the docs, actually
17:46:05 <LoganCapaldo> Brian`: in ghci do :info HostName
17:46:06 <allbery_b> type HostName = String -- IIRC
17:46:11 <Brian`> aha~
17:50:27 <byorgey> @info Network.HostName
17:50:27 <lambdabot> Network.HostName
17:50:49 <byorgey> oops, I forgot that @info is useless =P
17:53:29 <Pseudonym> @id Network.HostName
17:53:29 <lambdabot>  Network.HostName
17:53:36 <Pseudonym> @info Foo.Bar
17:53:36 <lambdabot> Foo.Bar
17:53:47 <Pseudonym> @info ACTION is an idiot
17:53:47 <lambdabot>  Illegal character ''\SOH''
17:53:47 <lambdabot>  at "ACTI..." (column 1)
17:53:51 <Pseudonym> Dammit.
17:53:58 <allbery_b> heh
17:53:58 <Pseudonym> @info /me laughs
17:53:58 <lambdabot> (/ me laughs)
17:54:02 <Pseudonym> Ooh!
17:54:08 <Pseudonym> It converted it to Lisp!
17:55:56 <idnar_test> @info "ACTION is testing"
17:55:56 <lambdabot> "\SOHACTION is testing\SOH"
17:56:04 <idnar> heh
17:56:10 <idnar> darn escapes
17:56:31 <idnar> of course, most IRC clients don't seem to recognise embedded CTCPs anyway
17:56:42 <idnar> *CTCP messages
18:23:28 <hpaste>  SnailRacer pasted "GHCi trips firewall" at http://hpaste.org/3885
18:24:42 <dons> SnailRacer: hmm?
18:25:20 <SnailRacer> sometimes the firewall is being tripped by GCHi
18:25:49 <conal> if i use the LANGUAGE pragma, my code won't work with ghc-6.6.1, right?
18:26:27 <SamB_XP> the LANGUAGE pragma won't make your code not work
18:26:30 <sorear> conal: LANGUAGE is very old
18:26:33 <SamB_XP> you might need some flags though
18:26:43 <SamB_XP> sorear: not so very old
18:26:43 <sorear> ooh, a user of System.IO.UTF8!
18:26:59 <SamB_XP> but I'm pretty sure it's old enough for that ;-)
18:27:12 <conal> oh, so LANGUAGE is old but there are a lot of new extensions, and if i list those, then 6.6.1 won't compile my code?
18:27:42 <conal> i'm wondering when to switch to using LANGUAGE for all of the extensions i use.
18:27:51 <SamB_XP> conal: if 6.6.1 doesn't support those extensions it won't be able to compile the code anyway?
18:28:26 <conal> SamB_XP: i used OPTIONS -fglasgow-exts to get them.  some didn't have names and now do.
18:28:43 <SamB_XP> conal: yeah, that's the annoying thing I guess :-(
18:29:07 <conal> so my code compiled under 6.6 but stopped compiling in 6.6 when i named the extensions.
18:29:43 <conal> when i realized i'd broken my code for 6.6, i commented out all of my LANGUAGE pragmas and put back the -fglasgow-exts .
18:29:45 <sorear> yay, only 177 new messages
18:30:06 * ddarius considers doing Mark all as read
18:30:08 <TomMD> sorear: Unsubscribe from LKML
18:30:21 <dcoutts> conal: Cabal knows the new extensions and maps them back to corresponding flags in ghc-6.6, like -flagsgow-exts
18:30:49 <SamB_XP> dcoutts: but it can't do that for LANGUAGE pragmas, can it?
18:30:51 <wli> TomMD: He's missing three zeroes for that.
18:31:12 <dcoutts> conal: so if you list the extensions in the .cabal file that'll work, though they apply globally to the package, not like language pragmas which are per-module
18:31:28 <dcoutts> SamB_XP: Cabal doesn't read your code, no.
18:31:38 <SamB_XP> on the PCI list it was more like 17 messages
18:31:55 <conal> yeah, that's the catch.  i like recording language extensions in the modules rather than the .cabal
18:32:12 * sorear is on xmonad@, happs@, cvs-ghc@, glasgow-haskell-users@, haskell-cafe@, and a couple dozen less active
18:32:14 <conal> the .cabal solution won't work for ghci, will it?
18:32:19 <dcoutts> conal: no
18:32:22 <sorear> conal: {-# OPTIONS_GHC -fglasgow-exts #-} then
18:32:42 <TomMD> Call me ignorant, but I wasn't even aware there was a #happs.
18:32:53 <sorear> Ignorant!
18:33:12 <sorear> it's not that well publicized I admit
18:33:18 <TomMD> That hurts... hurts worse than evaulating [1..] in OCaml.
18:33:19 <dcoutts> conal: we're thinking of doing both, having a field in the .cabal file that says which extensions are used in the package, but not applying that extension to all modules
18:33:29 <dcoutts> so it'd serve as a declaration to the outside
18:33:52 <sorear> hurts?
18:33:53 <dcoutts> then each module can be more specific
18:34:10 <conal> i wonder: is this LANGUAGE awkwardness just a temporary problem, until 6.6 is long gone or whether new LANGUAGE extensions constructors will continue to be added.
18:34:39 <conal> dcoutts: "thinking of doing both"?  isn't that what happens now?
18:35:13 <conal> dcoutts: do you mean instead of using the "ghc-options" field?
18:35:21 <allbery_b> I think the future is {-# LANGUAGE ... #-} supported by all Haskell compilers/interpreters
18:35:29 <allbery_b> and the separate flags thing goes away
18:35:44 <conal> allbery_b: which "separate flags thing"?
18:35:55 <allbery_b> cabal needing to do mapping is a holdover from before LANGUAGE
18:36:03 <dcoutts> conal: currently the extensions one lists are then allowed in all the modules, we want to make it so that it only says which ones *may* be used in the package. Though due to the existing meaning, we probably need a second field for that.
18:36:05 <conal> oh
18:36:13 <allbery_b> and requires cabal to know too much about the compiler and implementation thereof
18:36:41 <conal> dcoutts: oh, it's a negative statement rather than positive one.
18:37:03 <dcoutts> conal: it's union vs intersection I guess
18:37:34 <conal> dcoutts: hm.  sounds tricky.  i wonder what the default would be.  none or all?
18:37:50 <dcoutts> all modules in this package use extension X vs there exists a module in this package that uses this extension
18:38:10 <dcoutts> conal: we should be able to discover the used extensions from looking at the LANGUAGE pragmas
18:38:26 <conal> dcoutts: all modules *must* use an extension??
18:38:45 <dcoutts> and as a convenience for when the extension is used in every module we have the existing extension field
18:39:06 <conal> dcoutts: which doesn't help for ghci
18:39:36 <dcoutts> conal: true, but then ghci also cannot grok pre-processors or any of the other stuff cabal does
18:39:55 <dcoutts> conal: the solution there is to get cabal to set up the ghci environment
18:40:17 <conal> dcoutts: oh, that makes sense to me.
18:40:25 <conal> dcoutts: pre-processors other than cpp?
18:40:27 <dcoutts> ie to do all the pre-processing and pass the right flags to ghci
18:40:36 <dcoutts> conal: especially FFI preprocessors
18:40:42 <dcoutts> and happy/alex etc
18:41:33 <conal> dcoutts: got it.  for instance, if i tweak my grammar and say ":reload", ghci would re-run happy and then reload the result.  is that the idea?
18:41:52 <dcoutts> conal: that's a level of integration further
18:42:16 <dcoutts> conal: but that's not impossible, if :reload called out to cabal to ensure various things were up to date
18:42:17 <conal> dcoutts: oh.  what else could ghci do for happy?
18:43:43 <dcoutts> conal: that'll need some consideration, and it depends on the make-like dependency infrastructure in cabal first
18:43:57 <dcoutts> the prototype of which is going ok so far
18:44:06 <conal> dcoutts: cool
18:44:38 <dcoutts> conal: remember we were talking about tracing programs to see which files they were reading/writing and thus depending on, I coded that up the other day :-)
18:44:59 <conal> dcoutts: wow
18:45:01 <dcoutts> it'll mostly be for debugging rules though, rather than to use all the time since it's OS specific
18:45:11 <ddarius> It sounds rather unholy.
18:45:18 <dcoutts> ddarius: just uses strace
18:45:32 <dcoutts> but it'll let us enforce dependencies strictly
18:45:33 <ddarius> dcoutts: That part's fine.  The conservative underestimate is less nice.
18:45:49 <dcoutts> ddarius: hmm?
18:46:52 <ddarius> Perhaps I don't have the context well enough.
18:47:08 <dcoutts> so when you write a make rule like:
18:47:16 <dcoutts> foo.o foo.hs : foo.hs
18:47:28 <dcoutts> and a corresponding action
18:47:43 <dcoutts> you're saying that whenever foo.hs changes you need to re-run the action
18:48:11 <dcoutts> but for overall correctness we also require that if any other files change, the action does not need to be re-run
18:48:29 <dcoutts> that is, that the list of dependencies is exhaustive / accurate
18:48:41 <Brian`> :t GHC.Handle.hSetBuffering
18:48:43 <lambdabot> GHC.IOBase.Handle -> GHC.IOBase.BufferMode -> IO ()
18:48:47 <saturday> @src minimum
18:48:47 <lambdabot> minimum [] = undefined
18:48:48 <lambdabot> minimum xs = foldl1 min xs
18:48:51 <Brian`> :t GHC.IOBase.BufferMode
18:48:51 <lambdabot>     Not in scope: data constructor `GHC.IOBase.BufferMode'
18:49:10 <dcoutts> so, then if the action goes and reads/writes other files we have to ask why it is doing that? is it an untracked dependency?
18:49:12 <ddarius> :k GHC.IOBase.BufferMode
18:49:12 <lambdabot> *
18:49:29 <LoganCapaldo> @hoogle hSetBuffering
18:49:30 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
18:49:33 <Brian`> :info GHC.IOBase.BufferMode
18:49:40 <LoganCapaldo> You might want that one instead
18:49:53 <ddarius> @src BufferMode
18:49:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:49:55 <Brian`> what's :info equivalent in lambdabot?
18:50:01 <LoganCapaldo> there is none
18:50:17 <Brian`> hm.. i'm pretty sure there is... somebody showed me
18:50:19 <ddarius> Brian`: But you could change that.
18:50:21 <Brian`> the command is different though
18:50:32 <ddarius> @index BufferMode -- this?
18:50:32 <lambdabot> bzzt
18:50:39 <LoganCapaldo> @index hSetBuffering
18:50:39 <lambdabot> System.IO
18:50:40 <Brian`> @index BufferMode
18:50:40 <lambdabot> System.IO, Graphics.Rendering.OpenGL.GL.Framebuffer, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
18:50:42 <Brian`> no
18:50:46 <LoganCapaldo> @docs System.IO
18:50:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
18:50:53 <Brian`> hm.. anyway
18:50:58 <Brian`> data GHC.IOBase.BufferMode
18:50:58 <Brian`>   = GHC.IOBase.NoBuffering
18:50:58 <Brian`>   | GHC.IOBase.LineBuffering
18:50:58 <Brian`>   | GHC.IOBase.BlockBuffering (Maybe Int)
18:51:02 <Brian`>   	-- Defined in GHC.IOBase
18:51:07 <ddarius> Brian`: There's nothing that does what GHCi's :info does in lambdabot.
18:51:14 <Brian`> how come when I do, hSetBuffering h BlockBuffering (Just 15), it says it's wrong?
18:51:37 <ddarius> Why shouldn't it?  Why is Just 15 there?
18:51:39 <Brian`> ddarius, hm.. ok i thought somebody showed me an equivalent command.. i must be wrong then..
18:51:48 <LoganCapaldo> (BlockBuffering (Just 15))
18:51:50 <Brian`> because BlockBuffering takes (Maybe Int)?
18:52:06 <ddarius> Brian`: You didn't apply BlockBuffering to Just 15
18:52:15 <sorear> Brian`: application associates to the left
18:52:47 <Brian`> oh..
18:52:53 <Brian`> so i have to have parentheses around?
18:53:12 <allbery_b> more to the point, because functions are first class in haskell, it makes sense to be able to pass BlockBuffering (a constructor, unapplied)
18:53:22 <allbery_b> so you need parens to pass an application of it to something
18:53:30 <Brian`> ah.. yeah
18:53:35 <Brian`> parenteses worked!
18:54:14 <gwern> so, is there anyway to have ghc-compiled binaries automatically use multiple cores? I have in my shell rc GHCRTS="-N4", but that seemed to cause ghci and co to piss itself
18:54:47 <gwern> or not, ghic, but anything not compiled with -threaded
18:54:48 <steveie> penis
18:54:52 <dons> gwern: you can add runtime flags into the binary using a small .c object
18:54:59 --- mode: ChanServ set +o dons
18:55:16 <steveie> penis
18:55:17 --- kick: steveie was kicked by dons (dons)
18:55:22 --- mode: ChanServ set -o dons
18:55:30 <dons> gotta clean out the ban list
18:56:14 <gwern> dons: that cure sounds worse than the disease!
18:56:22 <TomMD> ... I still like my suggestion of having users write one trivial line of Haskell to join/post/what have you
18:56:41 <TomMD> Heck, they could even get it from one of many tutorials.
18:56:46 <gvdm> bots can post haskell
18:57:00 <Brian`> oh, and also on the tutorial, h <- connectTo server (PortNumber (fromIntegral port)), it used fromIntegral. what's the purpose?
18:57:05 <Brian`> It worked without fromIntegral though...
18:57:06 <TomMD> But who would bother to write a bot/plugin just to spam one channel?
18:57:10 <Brian`> provided port = 6667
18:57:20 <gwern> TomMD: you would be surprised. #wikipedia often gets that
18:57:38 <ddarius> That's because numeric literals, e.g. 3, in Haskell translate into fromIntegral 3
18:57:44 <ddarius> So that is port = fromIntegral 6667
18:57:50 <ddarius> :t PortNumber
18:57:50 <lambdabot> Not in scope: data constructor `PortNumber'
18:57:55 <ddarius> @index PortNumber
18:57:55 <lambdabot> Network, Network.Socket, Network.BSD, Network
18:57:59 <ddarius> :t Network.PortNumber
18:57:59 <lambdabot> Network.Socket.PortNumber -> Network.PortID
18:58:07 <ddarius> :t fromIntegral
18:58:08 <lambdabot> forall a b. (Num b, Integral a) => a -> b
18:58:19 <ddarius> @instances-importing Network Num
18:58:19 <lambdabot> Double, Float, Int, Integer, PortNumber
18:58:39 <Brian`> so even if I just say port = 6667, haskell compiler automatically translates it to fromIntegral 6667?
18:58:46 <ddarius> Yes.
18:59:09 <Brian`> okay :) thanks
18:59:15 <ddarius> Sorry, actually it's fromInteger
18:59:15 <Brian`> and what's @index equivalent in ghci?
18:59:26 <ddarius> But that doesn't really make much of a difference
18:59:36 <LoganCapaldo> there isn't one
18:59:36 <Brian`> okay
18:59:51 <ddarius> fromIntegral is a general conversion routine.
19:00:08 <chessguy> 'evening #haskell-ites
19:00:16 <TSC> Hi cheeseguy
19:00:30 <LoganCapaldo> @type fromInteger . toInteger
19:00:30 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
19:00:39 <LoganCapaldo> @type fromIntegeral
19:00:39 <lambdabot> Not in scope: `fromIntegeral'
19:00:39 <ddarius> @src fromIntegral
19:00:39 <lambdabot> fromIntegral = fromInteger . toInteger
19:01:14 <ddarius> There really isn't any reason to ever use fromInteger
19:01:33 <LoganCapaldo> well you might be implementing fromIntegral :)
19:01:33 <chessguy> @quote cheese
19:01:33 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
19:01:38 <chessguy> @quote chess
19:01:39 <lambdabot> jcreigh says: <chessguy> i mean if someone says factorial should be of type String -> [(Float, Bool)], you should just tell them they're nuts  <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*
19:01:39 <lambdabot> ) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
19:02:06 <chessguy> hm, guess that quote got deleted
19:02:23 <jcreigh> I should have figured out something meaningful for the Bool value there. :)
19:03:35 <SnailRacer> let fac n = product [1..n]
19:05:28 <TSC> That's too slow; it should be "product [2..n]"
19:06:00 <SnailRacer> Yeah, it's not memoized either =)
19:06:26 <Pseudonym> And it doesn't use any functions with hashes in their names.
19:06:31 <Pseudonym> Clearly not shootout material.
19:06:32 <LoganCapaldo> let fac n = getProduct . mconcat . map Product [2..n]
19:06:40 <LoganCapaldo> let fac n = getProduct . mconcat . map Product $ [2..n]
19:06:44 <LoganCapaldo> I mean
19:07:23 <LoganCapaldo> > let fac n = getProduct . mconcat . map Product $ [2..n] in fac 5
19:07:24 <lambdabot>  120
19:07:50 <saturday> @src reverse
19:07:50 <lambdabot> reverse = foldl (flip (:)) []
19:08:13 <LoganCapaldo> > let sum n = getSum . mconcat . map Sum $ [2..n] 5 -- this pattern fascinates me
19:08:13 <lambdabot>  Parse error at end of input
19:08:24 <LoganCapaldo> > let sum n = getSum . mconcat . map Sum $ [2..n] in sum 5 -- this pattern fascinates me
19:08:24 <lambdabot>  14
19:09:34 <sjanssen> > let fac n = appEndo . mconcat . map (Endo . (*)) $ [2..n] in fac 5
19:09:35 <LoganCapaldo> > let upto n = mconcat . map (:[]) $ [2..n] in upto 5 -- this pattern fascinates me
19:09:35 <lambdabot>  [2,3,4,5]
19:09:35 <lambdabot>  <Integer -> Integer>
19:09:43 <TSC> Perhaps in the case of sum it should be [1..n], not [2..n]
19:09:50 <LoganCapaldo> true
19:10:29 <LoganCapaldo> sjanssen: I like foldr (Endo .f) id  for that :)
19:10:40 <LoganCapaldo> or something
19:10:41 <Nafai> @index mconcat
19:10:41 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
19:10:43 <LoganCapaldo> I dunno
19:10:48 <sjanssen> LoganCapaldo: it's even better with Data.Foldable.foldMap
19:11:09 <ddarius> :t foldMap
19:11:09 <lambdabot> Not in scope: `foldMap'
19:11:16 <ddarius> :t Data.Foldable.foldMap
19:11:16 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
19:11:21 <LoganCapaldo> I've been playing with Monoid / writer
19:11:21 <Nafai> Is in a function?
19:11:22 <sjanssen> > Data.Foldable.foldMap Product [1..5]
19:11:22 <lambdabot>  Product {getProduct = 120}
19:11:31 <LoganCapaldo> sjanssen: nice!
19:11:32 <ddarius> Nafai: no
19:13:05 <LoganCapaldo> my idea is to use WriterT Parser to get a "compiler" type effect
19:13:15 <LoganCapaldo> tell (Endo ...
19:14:48 <ddarius> tell Endo what?
19:15:04 <ddarius> Note that I should be ignored right now.
19:15:20 <LoganCapaldo> heh
19:16:13 <Nafai> What does 'in' do? That's kind of a hard thing to search for
19:16:21 <ddarius> Nafai: It's just syntax.
19:16:43 <LoganCapaldo> Nafai: Stop ignoring ddarius :)
19:17:06 <LoganCapaldo> in is part of let
19:17:12 <Nafai> Okay
19:17:18 <LoganCapaldo> let <bindings> in <expression>
19:17:28 <monochrom> Just like "what does comma do?"
19:17:33 <ddarius> :t (,)
19:17:35 <lambdabot> forall a b. a -> b -> (a, b)
19:17:43 <ddarius> (Back to ignoring me.)
19:17:48 <LoganCapaldo> > let a = 5 ina + 7
19:17:48 <lambdabot>  Parse error at end of input
19:17:49 <monochrom> But of course, I mean the comma in [1,2]
19:17:52 <LoganCapaldo> > let a = 5 in a + 7
19:17:53 <lambdabot>  12
19:17:55 <Nafai> Thanks
19:18:03 <LoganCapaldo> > (\a -> a + 7) 5
19:18:04 <lambdabot>  12
19:18:29 <ddarius> > let a = 1 : a in a
19:18:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:18:37 <LoganCapaldo> those two are amount the same-ish
19:18:40 <ddarius> > (\ a -> 1:a) ...
19:18:40 <lambdabot>   parse error on input `}'
19:18:48 <ddarius> > fix (\a -> 1:a)
19:18:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:18:56 <monochrom> Tony Hoare says, "punctuations don't have semantics. semantics is for the whole sentence."
19:19:03 <ddarius> Er, \a -> a
19:19:07 <LoganCapaldo> Thanks Tony!
19:19:09 <firefly> Is there a version of Parsec somewhere that uses bytestrings?
19:19:32 <ddarius> firefly: Yes.
19:19:59 <SnailRacer> let fac n = facList!!(fromInteger n) where facList = [fac' m|m<-[0..]];fac' n = if n == 0 then 1 else n*fac (n-1) in fac 5
19:20:26 <monochrom> He says this when he gives a denotational semantics to Prolog. The biggest problem is the ! cut operator. So he decides the cut operator is punctuation and shouldn't be given semantics. But you use it in various idioms; those idioms have semantics.
19:20:41 <ddarius> Cut should just die.
19:21:05 <TSC> It should be cut out of the language?
19:21:55 <ddarius> One of the progeny of Prolog should commit patricide.
19:22:07 <mrd> go twelf!
19:22:12 <monochrom> So one common use of ! is to do something like Parsec's <|>. We know how to make sense of <|>.
19:22:21 * Lewisham has lurked long enough and readies a super newbie question
19:22:42 <Lewisham> *ahem*. Hello :)
19:22:55 <ddarius> "Hello" is not a question
19:23:05 <monochrom> Is that your super newbie question? Then the answer is: "Hi!"
19:23:05 <sorear> Lewisham: you've been depriving us all these years?
19:23:25 <Lewisham> :D My question is: Is Haskell well suited for AI problems, and are there any tutorials around in AI that use Haskell?
19:23:41 <ddarius> @faq
19:23:41 <lambdabot> The answer is: Yes! Haskell can do that.
19:23:48 <monochrom> Hahahaha
19:24:01 <Lewisham> If only I had consulted the Lambda oracle first!
19:24:30 <monochrom> The "logicT" backtracking library and the "modularized search" paper may be of interest to you.
19:24:48 <Lewisham> awesome, thanks monochrom
19:25:11 <monochrom> I haven't seen machine learning stuff in Haskell.
19:25:44 <ddarius> http://www.haskell.org/haskellwiki/AI
19:25:45 <lambdabot> Title: AI - HaskellWiki
19:25:51 <monochrom> Excellent.
19:25:55 <Lewisham> yeah, I'm trying to get into AI, and Lisp and Java are great and all, but I want to learn more Haskell too (which I like a lot), so I want to combine my learnings at once
19:25:59 <ddarius> Lewisham: What does "AI" mean to you?
19:26:24 <Lewisham> good question; I'm mostly interested in search and agent research
19:26:28 <Lewisham> seeing as all AI needs search
19:26:31 <Lewisham> at some point
19:28:33 <ddarius> Hmm, I've never seen this before http://www.comp.nus.edu.sg/~lamsoonl/adom/ maybe you'll find it interesting.
19:28:39 <lambdabot> Title: ADOM: Agent Domain Of Monads
19:29:03 <Lewisham> oh yeah, that does look super interesting!
19:29:17 <Lewisham> some bed-time reading :)
19:30:22 <monochrom> the "modularized search" paper is "Modular lazy search for Constraint Satisfaction Problems"
19:30:47 <newsham> ?src putStrLn
19:30:47 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
19:31:04 <Lewisham> tomorrow's bedtime reading!
19:31:22 * Lewisham is never going to get round to finishing the Stephen Colbert book, but that might be a good thing
19:31:36 <wli> AI does not always involve search.
19:31:36 <ddarius> Stephen Colbert has a book?
19:31:46 <Lewisham> a bad one, yes
19:32:11 <wli> Some AI more closely resembles signal processing.
19:32:18 <gwern> I am american and so can you? I thought that was the other fellow's
19:32:23 <Brian`> oh you mean "You can be America" or something?
19:32:38 <Lewisham> yeah, "I Am America, and So Can You"
19:32:55 <Lewisham> gwern: That was Stewart's "America: The Book" which is orders of magnitude better
19:33:19 <Lewisham> can you see a theme in their writing? :)
19:33:45 <gwern> politics, more or less
19:34:02 <newsham> > Set.singleton 3 == Set.singleton 3
19:34:03 <lambdabot>   Not in scope: `Set.singleton'
19:34:03 * ddarius misses the DC area
19:34:17 <newsham> is Data.Set accessible to lambdabot?
19:34:22 <chessguy> ddarius, you lived in the DC area?
19:34:23 <gwern> (hm. quickchecks must be inherently serial. I can't seem to get past 170% cpu despite running many in parallel)
19:34:25 <chessguy> whereabouts?
19:34:27 <ddarius> > singleton
19:34:27 <lambdabot>   Not in scope: `singleton'
19:34:28 <gwern> :browse Data.Set
19:34:59 <ddarius> chessguy: Northern Virginia, about an hour or so from DC.  Roughly Falls Church area if that means anything.
19:34:59 <Lewisham> are haskell.org and haskell.cs.yale.edu the same site?
19:35:19 * wli suggests a brief perusal of "The Democratic Facade," long excerpts of which are available on thirdworldtraveler.com, as well as "Rollback! Right Wing Power in American Foreign Policy."
19:35:20 <chessguy> ddarius, it does indeed. i live right by dulles airport
19:35:38 <ddarius> Ah, then you probably live where I lived more specifically.  Namely Sterling.
19:35:58 <chessguy> i'm in Herndon, and working in Reston
19:36:04 <wli> (Zinn's "A People's History of the United States" might help get you started.)
19:36:08 <chessguy> nice area
19:36:19 <newsham> > Data.Set.singelton 5
19:36:20 <lambdabot>   Not in scope: `Data.Set.singelton'
19:36:26 <ddarius> I agree.  It got rather expensive in the past few years, but definitely a great place to raise a family.
19:36:51 <ddarius> I'll probably move back to that area later in my life.
19:37:15 <chessguy> yeah, the cost of living is definitely a hurdle to get over. but i've found an apartment in reston that i'm going to try to get that's only a little over $1k
19:38:00 * wli is moving to downtown Portland from suburbia.
19:38:21 <allbery_b> > Data.Set.singleton 5
19:38:22 <lambdabot>  fromList [5]
19:38:29 * Lewisham is trying to move to California from... New Zealand
19:38:33 <Lewisham> wli: What's Portland like?
19:38:35 <ddarius> chessguy: It's pretty sad that a Base Exchange (well a Commissary) in Hawaii has prices comparable to the typical commercial prices in the DC metropolitan area.
19:38:37 <hpaste>  gwern pasted "any suggestions about elegance?" at http://hpaste.org/3886
19:38:45 <chessguy> heh
19:39:02 <pheaver> right now?  kinda chilly, kinda wet, but green and pretty!
19:39:10 <gwern> for example, I'm not happy about using take n and length fs to force getChanContents
19:39:41 <pheaver> that was directed at Lewisham
19:39:52 <ddarius> Speaking of weather, Virginia should be really nice right around now.
19:40:02 <wli> Lewisham: Smaller. Slower. Nowhere near the LGBT community of LA or SF.
19:40:08 <Lewisham> pheaver: Don't bother coming to New Zealand then, it'll just remind you of home!
19:40:15 <pheaver> heh
19:40:25 * ddarius has wanted to go to New Zealand for a while now.
19:40:52 <pheaver> portland has only been home to me for a couple months... i'm originally from kansas
19:42:26 <Brian`> hey, in dropWhile (\=':'), is \=':' lambda expression?
19:42:37 <Brian`> what does \= mean?
19:42:40 <ddarius> It's a syntax error.
19:42:42 <Brian`> not equal to ..
19:42:46 <Brian`> ah... i c -_-;
19:42:53 <Brian`> haha nvm
19:42:58 <ddarius> Cripes, /= is not equal to
19:43:01 <chessguy> @src Eq
19:43:01 <lambdabot> class  Eq a  where
19:43:01 <lambdabot>     (==), (/=)   :: a -> a -> Bool
19:43:04 <Brian`> hm.. -__;
19:43:05 <wli> I went to Kansas once. I was so terrified I'd be killed I avoided contact with the natives at all costs.
19:43:08 <Brian`> i'm wrong then ;
19:43:16 <Brian`> then what is it?
19:43:56 <ddarius>  /= is \x y -> !(x == y), \= is a syntax error, \x -> x is an example of a lambda expression
19:44:53 <chessguy> ddarius, err, is that valid syntax?
19:45:00 <chessguy> the !(x==y)
19:45:15 <zeeeee> i'm trying to setup hdbc-postgresql, but i get build errors. anyone have a clue about this? http://software.complete.org/hdbc-postgresql/ticket/1
19:45:15 <lambdabot> Title: #1 (Build error) - HDBC PostgreSQL Driver
19:45:24 <ddarius> Oh cripes.  Stupid multiple programming languages.
19:45:27 <ddarius> not (x == y)
19:45:37 <chessguy> :)
19:45:54 <Brian`> hm... then does that tutorial have typo?
19:46:04 <Brian`> and also `isPrefixOf` doesn't seem to exist...
19:46:13 <ddarius> @index isPrefixOf
19:46:13 <lambdabot> Data.List
19:46:30 <ddarius> "that tutorial" isn't very specific
19:47:06 <Brian`> okay
19:51:23 <Brian`> @index exitWith
19:51:24 <lambdabot> System.Exit
19:51:35 <firefly> ddarius: I've googled some more but I still can't find anything definite re. bytestrings and parsec.
19:53:53 <ddarius> There was a Google Summer of Code project for it.
19:54:01 <chessguy> @seen xerox
19:54:02 <lambdabot> xerox is in #haskell-overflow, #haskell-blah and #haskell. I don't know when xerox last spoke.
19:54:29 <firefly> The closest is a very small parser combinator module in the style of parsec but with much, much fewer features here: http://hackage.haskell.org/~paolo/darcs/ByteStringParser/
19:54:30 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser
19:54:47 <firefly> There's also a summer of code ticket thingy: http://hackage.haskell.org/trac/summer-of-code/ticket/59
19:54:48 <lambdabot> Title: #59 (ByteString layer for Parsec) - Haskell.org Google Summer of Code - Trac
19:56:01 <firefly> It is also mentioned as a possible thing to hack on for Hac 2007 II: http://www.haskell.org/haskellwiki/Hac_2007_II
19:56:02 <lambdabot> Title: Hac 2007 II - HaskellWiki
19:56:15 <firefly> But it doesn't look like anybody actually worked on it.
19:56:33 <valis> Not too experienced and having a bit of trouble making a vector space class.  I'm running into issues with scalar multiplication with "scale :: scalar -> v -> v".  I first tried to fix it with a multi-parameter type-class but I'm failing.  Am I approaching the problem in a stupid way?
19:57:33 <ddarius> valis: Google for that on the mailing list.
19:57:39 <gwern> hey - how can I take a IO [Bool] and turn it into an [IO Bool]?
19:57:57 <valis> thanks
19:58:14 <ddarius> :t (:[]) . liftM head
19:58:16 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> [m a]
19:58:27 <Brian`> :t liftM
19:58:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:58:42 <gwern> ddarius: what the heck is that and how did you think of it so quickly?
19:59:20 <LoganCapaldo> @src liftM
19:59:21 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:59:42 <LoganCapaldo> so let f = head
19:59:47 <ddarius> gwern: It's very unlikely what you want and I just matched types.
20:00:35 <gwern> well, the head part is probably wrong, I'd venture. I want to change the type of everything in the list, not just the first entry :)
20:00:37 <ddarius> gwern: I don't think there is anything particularly pretty to do what you want.
20:00:52 <LoganCapaldo> @type map return
20:00:52 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
20:01:10 <ddarius> You can make a list of IO actions that will constantly re-execute the given one and extract the corresponding element.
20:01:21 <gwern> maybe I should rewrite the functions then...
20:01:22 <LoganCapaldo> @type xs >>= return . (map return)
20:01:22 <lambdabot> Not in scope: `xs'
20:01:32 <LoganCapaldo> @type (>>= return . (map return))
20:01:33 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Monad m) => m [a] -> m [m1 a]
20:01:43 <ddarius> You could run the action once, store it in a IORef and then not re-execute, but probably re-traverse.
20:02:20 <gwern> that sounds even worse
20:02:46 <Brian`> hey do you know where i can get this lambdabot src code?
20:02:51 <ddarius> @version
20:02:51 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
20:02:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:03:00 <Brian`> awesome
20:04:22 <LoganCapaldo> you can't build her with 6.8.1 yet fyi
20:06:21 <firefly> sjanssen: it looks like you worked on strings and possibly also parsec in the Summer of Code 2006
20:07:06 <gwern> so I have a line, 'parTest f = andTest $ parList f'. why cannot I remove 'f' from both sides? it immdeiately gives me a type error saying that andTest and parList cannot be matched up
20:07:24 <ddarius> You can change it to andTest . parList
20:07:48 <ddarius> But ($) is just id.  It's only significance is in the lexical grouping it leads to.
20:07:55 <gwern> oh.
20:08:36 <ddarius> Another way to see that this doesn't match the eta-reduction pattern is to see that it is andTest (parList f)
20:13:54 <hpaste>  gwern annotated "any suggestions about elegance?" with "much nicer. Now we have a useful module for doing QuickCheck in parallel!" at http://hpaste.org/3886#a1
20:14:21 <gwern> boy, that was a lot of work to write, but I get a real sense of accomplishment looking at it.
20:17:06 <dons> excellent gwern :)
20:17:32 <dons> ?src and
20:17:32 <lambdabot> and   =  foldr (&&) True
20:17:52 <gwern> now the only troubling thing is that testing my nuke equations only uses up at most 120% cpu. but I can worry about that later
20:17:52 <dons> :t liftM . and
20:17:54 <lambdabot>     Couldn't match expected type `a1 -> r' against inferred type `Bool'
20:17:54 <lambdabot>     In the second argument of `(.)', namely `and'
20:17:57 <dons> :t liftM and
20:17:58 <lambdabot> forall (m :: * -> *). (Monad m) => m [Bool] -> m Bool
20:18:18 <dons> gwern: andTest = liftM $ foldr (&&) True == liftM and ?
20:18:44 <gwern> dons: er. it was originally monadic, but then I wound up removing all the monadic bits
20:18:46 <dons> \m -> forkIO $ (writeChan chan) =<< (m) is unusual
20:18:54 <dons> ?pl \m -> forkIO $ (writeChan chan) =<< (m)
20:18:55 <lambdabot> forkIO . (writeChan chan =<<)
20:18:57 <dons> mm
20:19:24 <dons> \c -> forkIO $ a >>= writeChan chan
20:20:50 <nburlett> @seen alpheccar
20:20:50 <lambdabot> I haven't seen alpheccar.
20:21:47 <hpaste>  gwern annotated "any suggestions about elegance?" with "+style suggestions" at http://hpaste.org/3886#a2
20:27:06 <gwern> @src and
20:27:06 <lambdabot> and   =  foldr (&&) True
20:46:51 <firefly> @seen sjanssen
20:46:52 <lambdabot> sjanssen is in #ghc, #haskell-blah, #gentoo-haskell, #haskell-overflow, #xmonad and #haskell. I last heard sjanssen speak 1h 35m 29s ago.
20:47:10 <sjanssen> firefly: you rang?
20:47:16 <firefly> yes!
20:47:29 <firefly> do you know anything about parsec combined with bytestrings?
20:48:43 <sjanssen> firefly: I think xerox was working on this over the summer, I don't know what came of that
20:49:34 <firefly> thanks!
20:50:08 <ddarius> He definitely completed something, but I'm not sure what he did with it.
20:50:09 <firefly> Did your Summer of Code project in 2006 only have to do with bytestrings or did you also touch parsec?
20:51:10 <sjanssen> only ByteString stuff
20:51:13 <firefly> ok.
20:52:30 <soduko> is haskell reflective? as in given a method name that is already declared, can one get its type programatically?
20:52:55 <sjanssen> soduko: no
20:53:05 <sjanssen> well, not exactly
20:53:10 <rhz> It would be good if there was an absolute value function with the following type I think: realAbs :: (Num a, Real b) => a -> b
20:53:17 <sjanssen> > typeOf putStrLn
20:53:19 <ddarius> soduko: That would break referential transparency, though it could be stuffed in the IO monad to some extent.
20:53:20 <lambdabot>  [Char] -> IO ()
20:53:23 <Pseudonym> It's hard to know what you'd do with such a thing in Haskell.
20:53:32 <Taral> @ping Igloo
20:53:37 <jcreigh> The block was followed by code that inserted a row in the database and assigned rndNum and rndNum2 to columns with the same name. Later on, when the bookingId was needed, the row was retrieved using the two "random" numbers.
20:53:39 <dmwit> Since you know the types at compile time, knowing them at run-time is easy.
20:53:47 <jcreigh> gah, sorry.
20:53:52 <monochrom> hehe
20:53:59 <Taral> @seen Igloo
20:53:59 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 5h 36m 57s ago.
20:54:01 <soduko> :( tough luck. i was reading the haskell road to math and saw a funciton..
20:54:05 <jcreigh> stupid mouse freaks out every now and then.
20:54:05 <Taral> darn -- probably away :(
20:54:12 <monochrom> @remember dmwit Since you know the types at compile time, knowing them at run-time is easy.
20:54:12 <lambdabot> Okay.
20:54:21 <monochrom> I really like that. :)
20:54:29 <soduko> that constructs truth tables for boolean valued functions
20:55:17 <dmwit> soduko: Try :t at the ghci prompt.
20:55:21 <soduko> so if there is a bf: Bool -> Bool -> Bool they do some thing like and [  bf a b | a <- [ True, False] , b <- [ True, False] ]
20:55:36 <soduko> dmwit: i dont want it for me, i want it for the program.
20:56:06 <sjanssen> soduko: you want a version that will work for any number of arguments?
20:56:07 <ddarius> @pl \bf -> join (liftM2 bf) [True,False]
20:56:08 <lambdabot> flip join [True, False] . liftM2
20:56:37 <soduko> this doesnt scale generally.  i wanted to write a "meta" [ or higher order function that takes any function, finds out how many arguments it takes and create the truth table
20:56:55 <sjanssen> soduko: Haskell can do this, with type classes
20:57:00 <ddarius> soduko: There are ways of doing what you want and they don't need reflection of any sort.
20:57:15 <soduko> :) thats good news, please tell me how.
20:58:38 <soduko> liftM2           :: Monad m => (a -> b -> c) -> (m a -> m b -> m c)   so in this case i would have to know that bf takes two bools and returns one right?
20:58:59 <monochrom> wish I could point you to an Oleg writing and you could understand it. most people say they don't understand it.
20:59:09 <soduko> ill try
20:59:31 <soduko> http://okmij.org/ftp/ is this the site?
20:59:31 <lambdabot> Title: This FTP site
21:00:43 <monochrom> Yeah.
21:01:33 <ddarius> class TruthTable a where makeTruthTable :: a -> [Bool]; instance TruthTable Bool where makeTruthTable = (:[]); instance TruthTable b => TruthTable (Bool -> b) where makeTruthTable f = concatMap (makeTruthTable . f) [True,False]
21:01:54 <ddarius> That's off the top of my head.  The last makeTruthTable probably needs to be fiddled with as that's the trickiest part.
21:03:02 <monochrom> I can't find it yet. I think he posted it to a mailing list but never put it on his web page. OTOH it comes down to what ddarius says. Need "undecidable instances" "overlapping instances" etc.
21:03:06 <ddarius> :t \f -> concatMap (?g . f) [True,False]
21:03:08 <lambdabot> forall b b1. (?g::b -> [b1]) => (Bool -> b) -> [b1]
21:03:34 <ddarius> That shouldn't need undecideable or overlapping instances.
21:03:47 * ddarius has done stuff like this often and never, ever uses overlapping instances.
21:04:20 <ddarius> soduko: The same trick is used for the printf in the "standard" libraries.
21:04:21 <hpaste>  sjanssen pasted "produce tables from functions" at http://hpaste.org/3887
21:04:32 <sjanssen> soduko: ^^^
21:04:51 * soduko is reading the link
21:05:07 <soduko> and trying ot understand what ddarius wrote
21:05:23 <ddarius> soduko: It's a type level induction on the structure of the types.
21:05:36 <ddarius> soduko: Know C++?
21:05:56 <monochrom> Ah, doesn't need overlapping instances.
21:05:56 <soduko> you bet, i make my bread off of that :)
21:06:13 * monochrom wants C++ crumbles :)
21:06:21 <ddarius> soduko: Know crazy template metaprogramming stuff?
21:06:40 <monochrom> That's for crumble pies :)
21:06:41 <soduko> yeah , but not at the level of alexandrescu tho :)
21:07:05 <ddarius> This is a very simple case of something very similar to template metaprogramming.
21:07:30 <ddarius> Ironically, the type language of C++ is a lazy functional language and the type language of Haskell is a deterministic logic language.
21:07:49 <ddarius> Though now with type families it's a functional language.
21:08:21 <thoughtpolice>  /quit zzz......
21:08:25 <thoughtpolice> ?
21:08:34 <soduko> hmm..   once i figure this beast out, i should try it with templates too..
21:09:02 <sjanssen> can you do induction on function types in C++?
21:09:37 <ddarius> soduko: It's actually ridiculously easy to write a simple but surprisingly useful translator from a simple Haskell-esque language to C++ template programs.
21:09:54 <ddarius> sjanssen: I believe you'd have to explicitly "reify" them.
21:10:06 <soduko> waht is reify ?
21:10:12 <ddarius> @wn reify
21:10:12 <lambdabot> *** "reify" wn "WordNet (r) 2.0"
21:10:12 <lambdabot> reify
21:10:12 <lambdabot>      v : consider an abstract concept to be real
21:10:12 <lambdabot>      [also: {reified}]
21:10:21 <ddarius> @foldoc reify
21:10:22 <lambdabot> *** "reify" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:10:22 <lambdabot> reify
21:10:22 <lambdabot>  
21:10:22 <lambdabot>         To regard (something abstract) as a material thing.
21:10:22 <lambdabot>  
21:10:24 <lambdabot>         (1995-03-07)
21:10:26 <lambdabot>  
21:10:29 <ddarius> Bah foldoc
21:10:51 <monochrom> Not the other way round? Lifting a concrete thing to an abstract level?
21:11:25 <int-e> reflections are not real.
21:11:43 <ddarius> soduko: The "dual" to reify is reflect.
21:12:23 <monochrom> This is subtle. I'll take reify as just embed.
21:14:06 <bos> bah. why do google searches for "haskell array slice" give me perl code? i blame dominus.
21:14:23 <ddarius> I blame Larry Wall.
21:14:34 <soduko> i blame google for bad indexing
21:14:35 <bos> afaict, we don't have a way of slicing up an array.
21:15:02 <ddarius> bos: It can easily be built, but I don't think it can easily be built efficiently.
21:15:10 <bos> ddarius: yeah, exactly.
21:15:12 <monochrom> what is array slice?
21:15:41 <bos> monochrom: the idea that if you have an n-dimensional array, you can easily and efficiently get an (n-1)-dimensional projection of it.
21:15:52 <ddarius> Implementing it should not be particularly hard at all, but it's something you want already done in a library.
21:16:23 <bos> monochrom: another kind of slice is just "give me a view on elements 2 to 1000 of this linear array".
21:16:54 <bos> the first kind is the sort of thing number crunchers want, particularly fortran hackers. the second is more of a python thing.
21:18:25 <monochrom> ixmap (0,10) (\i -> (3,i)) is an example of taking out A[3, 0..10] out of A[0..10, 0..10].
21:19:00 <bos> yeah.
21:19:08 <monochrom> ixmap (0,997) (\i -> i+2) is an example of the latter.
21:19:16 <soduko> ddarius: here is what i make of your code earlier.. it seems to be equivalent to [ f True, f False]
21:19:41 <bos> monochrom: it's not exactly pretty, though.
21:19:52 <ddarius> soduko: Yes.
21:19:57 <monochrom> I have also used ixmap for rotations. I had a cube. Wanted to rotate it 90 degrees along x axis.
21:20:25 <monochrom> I have much enjoyed ixmap. It has trivialized many things.
21:20:39 <ddarius> soduko: modulo you need the recursive call to makeTruthTable
21:21:18 <ddarius> It could be written concat [makeTruthTable $ f True, makeTruthTable $ f False]
21:21:39 <monochrom> Actually, I have much enjoyed Haskell overall. It has trivialized many things. I mean it has trivialized many of what other languages consider significant concepts such as command pattern and slicing.
21:21:53 <soduko> ddarius:  thats what i was trying to get to.
21:22:16 <soduko> i must be the most outlier / wierd ahskell newbie.
21:22:36 <ddarius> soduko: Not at all.
21:22:45 <ddarius> soduko: Haskellers are a diverse and strange bunch.
21:22:47 <soduko> i understand what monads and arrows do, but i stumble every step of the way with data, type new type class and instance
21:22:54 <monochrom> It is probably nice to pre-can a couple of ixmap idioms.
21:23:33 <soduko> but then i had you and caleg helping me pretty much 1:1 understand what monads do :)
21:24:00 <bos> @hoogle bounds
21:24:00 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
21:24:00 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
21:24:00 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
21:24:22 <bos> @hoogle Ix
21:24:23 <lambdabot> Data.Ix :: module
21:24:23 <lambdabot> Ix :: module
21:24:23 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
21:26:19 <monochrom> Every Haskeller is an outlier.
21:30:59 <scook0> what's the preferred way to signal an error in TH code?
21:33:10 <whoopsbob> Hi all, I'm trying to do the project euler problems. A generalized version of problem 1 is: Find the sum of the natural numbers < `n' which are divisible by a number in the list `l'. My solution is as follows. I'm trying to learn haskell, so is this good code, or is there something more elegant? f n l = foldr (+) 0 (filter (\x -> any (\y -> mod x y  == 0) l) [1..(n - 1)])
21:34:12 <scook0> (if you're adding numbers, you might prefer foldl' to foldr)
21:34:37 <scook0> those nested lambdas look a little ugly too
21:34:46 <scook0> perhaps use a list comprehension?
21:35:22 <scook0> @pl (\y -> mod x y  == 0)
21:35:22 <lambdabot> (0 ==) . mod x
23:45:50 --- topic: '["The Haskell programming language","GHC 6.8.1 is out!! http://tinyurl.com/2nel76","http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","http://arcanux.org/lambdacats.html"]'
23:45:50 --- topic: set by dons on [Sat Nov 03 13:34:54 2007]
23:45:51 <roconnor> ivanm: http://en.wikipedia.org/wiki/Wiener_process
23:45:51 <lambdabot> Title: Wiener process - Wikipedia, the free encyclopedia
23:46:37 <shachaf> > let if' True x _ = x; if' False _ y =  y in if' undefined `seq` 5
23:46:38 <lambdabot>  5
23:46:40 <shachaf> Hmm.
23:47:03 <roconnor> ivanm: hmm, but I'm not sure it is provably uniformly continuous.
23:47:25 <roconnor> ivanm: I'm not entirely sure how to define the function.
23:47:33 <ivanm> neither am I :s
23:47:36 <shachaf> > let if' True = \x _ -> x; if' False = \_ y -> y in if' undefined `seq` 5
23:47:37 <lambdabot>  Undefined
23:47:44 <shachaf> Maybe I was thinking of that?
23:48:03 <roconnor> ivanm: Wt is almost surely continuous. :-(
23:48:09 <roconnor> that's not quite good enough.
23:48:10 <shachaf> The other definition doesn't do that because it has to match all the patterns?
23:49:28 <roconnor> ivanm: you could still define it on the rationals
23:49:35 <roconnor> it doesn't have to be continuous then
23:49:46 <ivanm> hmmm...
23:50:24 <ivanm> still can't find how to define it...
23:51:57 <sjanssen> shachaf: yes, the transformation you've just done is eta-conversion
23:52:12 <sjanssen> shachaf: it's well known that eta-conversion isn't always valid in Haskell due to seq
23:52:33 <shachaf> sjanssen: And to where. :-)
23:52:33 <roconnor> ivanm: maybe we need another idea.
23:52:48 <ivanm> I think so too :s
23:53:52 <ivanm> mandelbrot + ERA: http://intranet.cs.man.ac.uk/Intranet_subweb/library/3yrep/2007/5556467.pdf
23:53:53 <lambdabot> http://tinyurl.com/22psck
23:53:59 <ivanm> well, it has pretty graphs, anyway :p
23:54:01 <roconnor> ivanm: How about using the Haskell charts library to plot these functions?
23:54:16 <shachaf> sjanssen: So the pattern matching definition would work just as well.
23:54:32 * shachaf realizes whoopsbob was probably talking about the type signature anyway... :-)
23:54:39 <ivanm> roconnor: I'm not actually looking at implementation, remember? just the theoretic usage and how to do so
23:55:49 <roconnor> ivanm: oh right
23:55:58 <ivanm> roconnor: I think I've found the "official" site of david lester's code :o
23:56:07 <roconnor> ivanm: it's hard to find
23:56:16 <roconnor> ivanm: and it uses Haskell 1.2
23:56:22 <ivanm> ftp://ftp.cs.man.ac.uk/pub/arithmetic/
23:56:43 <ivanm> well, the only bit that didn't work for me was where it imported Complex instead of Data.Complex for the sample program
23:58:00 <roconnor> ivanm: instance Text CR where ... doesn't mess you up?
23:58:08 <ivanm> roconnor: well, mandelbrot is apparently uncomputable (at the very least, Julia sets are uncomputable)
23:58:17 <ivanm> roconnor: oh, maybe the version I got off you was already patched...
23:58:26 <roconnor> it was
23:58:46 <ivanm> that's why I didn't have any problems then :p
23:58:52 <roconnor> ivanm: some julia sets are uncomputable
23:59:01 <roconnor> ivanm: it is unknown for the mandelbrot set
23:59:10 <ivanm> *nod*
23:59:11 <roconnor> some julia sets are computable.
