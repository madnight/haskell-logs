00:03:42 <conal> anyone know a cheap alternative to "floor" on floats?  each "floor" call seems to allocate a fair amount.
00:04:30 <wli> @type floor
00:04:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:04:55 <wli> conal: Maybe check what type you're using for the result of floor
00:05:07 <wli> conal: Int ought to be the least memory-intensive.
00:05:38 <wli> conal: It will probably default to Integer
00:06:03 <conal> looking at the core, i see it calls "GHC.Float.$wproperFraction1", giving an unboxed pair of boxed numbers
00:06:18 <conal> wli: that could be.  checking...
00:06:50 <wli> conal: I turn on warnings for whenever defaulting happens so I know exactly what's happening.
00:07:06 <conal> wli: sounds very useful. how?
00:07:17 <wli> conal: It gets dragged in by -Wall
00:08:38 <conal> wli: thanks!
00:09:08 <sjanssen> wli: can you use truncate instead?
00:09:27 <sjanssen> {-# RULES "truncate/Double->Int" truncate = double2Int #-}
00:09:34 <sjanssen> double2Int calls a primop
00:09:34 <wli> sjanssen: No idea. It's conal's issue.
00:09:40 <sjanssen> oh, sorry
00:14:18 <conal> sjanssen: any reason to expect truncate to be faster?
00:14:32 <sjanssen> conal: it calls a primop :)
00:14:41 <sjanssen> {-# RULES "truncate/Double->Int" truncate = double2Int #-}
00:14:46 <takamura> hi
00:14:51 <sjanssen> double2Int   (D# x) = I# (double2Int#   x)
00:15:04 <sjanssen> conal: #'s usually mean fast
00:15:12 <conal> sjanssen: that does sound faster.  i'm afraid i want the floor semantics.
00:16:21 <conal> yoiks! truncate led to a ghc "panic!"
00:16:31 <conal> in 6.8.1
00:17:06 <sjanssen> @yow
00:17:07 <lambdabot> I haven't been married in over six years, but we had sexual counseling
00:17:07 <lambdabot> every day from Oral Roberts!!
00:17:17 <wli> Trying to do BCD addition.
00:18:11 <conal> sjanssen: where did you find that truncate/Double->Int rule?
00:18:18 <wli> http://holomorphy.com/~wli/BCD.lhs
00:18:22 <sjanssen> conal: GHC/Float.lhs
00:18:28 <conal> thx
00:20:28 <conal> i think the allocation comes from floor calling properFraction, which returns a pair.  the pair itself gets unboxed, but it contains boxed int & float.
00:25:20 <sjanssen> decodeDouble# goes through a ByteArray#, which isn't so nice
00:25:51 <zeeeee> any way to resolve a relative posix path name to an absolute one? (ie posix realpath)
00:26:45 <opqdonut> readlink -f
00:26:56 <zeeeee> opqdonut, :)
00:27:12 <opqdonut> yeah that's not haskell i know :)
00:29:10 <conal> sjanssen: do you know how to get access to functions like float2Int#, used in GHC/Float.lhs?
00:29:33 <sjanssen> conal: most of them are from GHC.Exts
00:30:52 <conal> thx.
00:31:39 <zeeeee> what are those functions#?
00:32:51 <conal> zeeeee: ghc unboxed number primitives
00:34:15 <dons> they live in the world of # kinds
00:34:27 <dons> a strange, sharp world
00:34:36 <osfameron> ouch
00:34:36 <zeeeee> ghc does not do unboxing as an optimization?
00:34:42 <dons> it sure does
00:34:45 <dons> ?src Int
00:34:45 <lambdabot> data Int = I# Int#
00:34:58 <zeeeee> is this a ghc-specific thing?
00:35:03 <dons> and jhc too
00:35:12 <dons> both support unboxed values as somewhat first class
00:36:11 <zeeeee> is boxing orthogonal laziness/thunks?
00:36:19 <zeeeee> *orthogonal to
00:36:46 <conal> what do unboxed int literals look like?
00:37:27 <dons> 1#
00:37:28 <ibid> 14#
00:37:28 <dons> 1.0#
00:37:34 <dons> "foo"#
00:37:35 <conal> thx
00:37:43 <ibid> zeeeee: not quite
00:38:01 <dons> :t "get some chars in yr data"#
00:38:03 <lambdabot> GHC.Prim.Addr#
00:38:10 <ibid> zeeeee: you can't have a lazy unboxed thing, but you can have both eager and lazy boxed things
00:38:23 <ibid> zeeeee: similarly, a thunk is always in a box
00:38:35 <dons> languages like Java have strict boxes all over
00:38:42 <ibid> (some would say, "a thunk is a box")
00:38:44 <dons> and unboxed primitive types floating around, like int
00:38:49 <ibid> yeah
00:38:50 <zeeeee> right, ok
00:39:00 <dons> ?src Integer
00:39:00 <lambdabot> data Integer = S# Int#
00:39:00 <lambdabot>              | J# Int# ByteArray#
00:39:56 <conal> i got rid of the massive allocation by replacing floor with my own version:
00:39:58 <conal> floor' x = truncate x - b2i (x < 0) where { b2i True = 1; b2i False = 0 }
00:40:23 <conal> however, i then get "ghc.exe: panic! (the 'impossible' happened)"
00:40:59 <conal> i did some manual inlining and found that the call to float2Int causes the panic.
00:41:24 <conal> replacing it i get the wrong answer but much less allocation
00:42:11 <osfameron> wrong answers are fine if you can calculate them more efficiently!
00:42:58 <conal> osfameron: these ones are wronger that i like
00:43:09 <conal> some of the wrongest i've seen
00:43:22 <osfameron> heh
00:45:36 <Korollary> b2i can be replaced by fromEnum I think. Time for a bug report nonetheless.
00:46:24 <conal> > fromEnum False
00:46:26 <lambdabot>  0
00:46:31 <conal> neat
00:46:48 <conal> Korollary: thanks.  i'm narrowing it down to make the report.
00:54:39 <hpaste>  conal pasted "truncate ghc bug" at http://hpaste.org/4039
00:54:56 <conal> would someone please try out this paste?
00:55:03 <conal> it's a 4-liner
00:56:34 <hpaste>  sjanssen annotated "truncate ghc bug" with "panic!" at http://hpaste.org/4039#a1
00:57:25 <sjanssen> conal: looks like the same problem here
00:57:39 <conal> sjanssen: thanks.  not just windows.
00:57:44 <hpaste>  Korollary annotated "truncate ghc bug" with "Ubuntu x86 ghc 6.8.1" at http://hpaste.org/4039#a2
00:58:29 <conal> Korollary: thanks
00:59:56 <tutbot> conal: run in window vista, ghc-6.8.1 same error
01:00:15 <conal> tutbot: pretty consistent then.  thx.
01:02:59 <conal> sjanssen: is "macbook" running osx?
01:03:04 <sjanssen> conal: linux
01:03:12 <conal> ok
01:05:15 <conal> bug reported.
01:05:56 <Korollary> It appears -O1 or higher breaks it.
01:06:23 <sclv> is it also a via-asm vs. via-C issue?
01:06:34 <Korollary> via-C looks ok
01:08:43 <conal> i'm off to bed.  later, all.
01:08:55 <vincenz> cya onal
01:11:59 <int-e> Korollary: http://hackage.haskell.org/trac/ghc/ticket/1910
01:12:00 <lambdabot> Title: #1910 (Native Code gen miscompiles double2Int# / float2Int# on x86_32) - GHC - T ...
01:12:35 <int-e> Korollary: it's related to -O because -O enables the rules engine and there's a rule in GHC.Float that replaces truncate by float2Int.
01:15:24 <int-e> conal: oh. you brought that up.
01:20:06 <windoze> ghc windoze distro does not have GLUT?
01:20:15 <windoze> or how can i install GLUT pack in windoze? (cabal complains about missing 'ld')
01:20:34 <windoze> that's 6.8.1
01:22:29 <sjanssen> oh, there was a thread about that on the mailing list recently
01:23:03 <sjanssen> IIRC, the resolution was to add GHC's ld.exe to your PATH
01:23:37 <windoze> thanks, i dont know why the installer did not do that
01:24:44 <sjanssen> it's a bug in Cabal that was just recently noticed
01:24:56 <sjanssen> should be fixed in the next version
01:25:06 <windoze> thanks
01:28:46 <int-e> conal: sorry. that's a different bug. I should've looked at the paste :/
01:30:51 <windoze> sjanssen: where is the ghc's ld? i gave path to bin, and it still complains
01:31:37 <windoze> it's not there
01:31:46 <sjanssen> windoze: http://hackage.haskell.org/trac/hackage/ticket/182
01:31:48 <lambdabot> Title: #182 (Cabal can't find ld.exe on windows) - Hackage - Trac
01:33:49 <windoze> thanks, that solved it. however, now i have same problem with 'sh'
01:41:30 <saturday> quick question
01:41:37 <quicksilver> quick answer: yes
01:41:39 <saturday> I have a tree data type
01:42:06 <saturday> when i name my test variable testTree it works
01:42:18 <saturday> but when i rename it to AVL it says invalid type signature
01:42:29 <quicksilver> variables can't beging with a capital letter
01:42:44 <quicksilver> initial caps denotes type, class, or constructor
01:42:48 <saturday> :D
01:42:51 <vincenz> or module
01:42:51 <nominolo> it must start with a lower-case letter
01:42:51 <osfameron> this is allegedly a good thing
01:43:05 <nominolo> it is
01:43:10 <quicksilver> vincenz: modules are in a different syntactic class anyway, so it doesn't really interfere
01:43:11 <nominolo> @quote stereo
01:43:11 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
01:43:17 <vincenz> quicksilver: hum
01:43:20 <quicksilver> @quote stereo!
01:43:20 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
01:43:45 <nominolo> heh, someone wants to avoid being highlighted ...
01:44:03 <quicksilver> that was the goal, although I think he reconfigured his irc client in the end
01:44:06 <vincenz> Reddit is such a self-feeding system
01:44:14 <vincenz> One blog post about X => 15 blog posts about X
01:44:28 <nominolo> the echo-chamber!!
01:44:50 <vincenz> And the typical progression is
01:45:13 <nominolo> hm, don't positive feedbacks usually result in chaotic behaviour?
01:45:32 <vincenz> P1: X => P2: not X, P1 is stupid => P1: response to P2 => [P3...]: P1 and P2 look from wrong angle, have to look at orthogonal angle,
01:45:50 <vincenz> current case is provability of software :)
01:46:02 <nominolo> yeah
01:46:24 <vincenz> one: provable, 2: provability is useless in practive, 3: software quality has nothing to do with provability or testing, it's design
01:46:28 <vincenz> etc..
01:46:31 <nominolo> hardware vendors use simulation to 70+%, so that tells you something ;)
01:46:48 <vincenz> 39% of all statistics are made up on the spot
01:46:51 <nominolo> and HW verification is "easy"
01:46:59 <vincenz> Not anymore
01:47:16 <vincenz> Unless you use worst-case estimates, and nowadays, that's a Bad Thing(TM)
01:47:21 <nominolo> 94.2317324% pretend an accuracy that isn't justified by the measuring techniques
01:47:40 <nominolo> that's why i quoted it
01:47:46 <vincenz> 95% have gains > 60%
01:47:46 <nominolo> it's no more easy
01:48:02 <vincenz> Yeah
01:48:08 <nominolo> though it's simpler than SW verification
01:48:08 <vincenz> Devices are getting too small to make it easy
01:48:10 <windoze> where can i get sh.exe from?
01:48:12 <vincenz> Not really
01:48:16 <vincenz> sw is deterministic :)
01:48:37 <nominolo> not really
01:48:46 * vincenz waits for the next FP storm to reddit
01:48:49 <nominolo> windoze: cygwin? mssys?
01:49:09 <windoze> do i need to install that to work with GLUT on ghc?
01:49:19 <nominolo> no idea
01:49:37 <nominolo> maybe for installation only
01:50:11 <vincenz> there's native glut afaik
01:50:16 * vincenz has used it for ocaml in the past
01:50:41 <windoze> beautiful language, but failing terribly with "platform independence" promise and package management :(
01:50:53 <windoze> vincenz: but i want to use glut from haskell
01:50:56 <nominolo> windoze: windows is a weak spot
01:51:03 <quicksilver> vincenz: I was told yesterday that there isn't a native glut on windows.
01:51:12 <vincenz> quicksilver: eh?
01:51:15 <quicksilver> vincenz: personally I was surprised but I have no idea
01:51:17 <quicksilver> vincenz: *nod*
01:51:19 <vincenz> glutXX.dll
01:51:26 <Zao> nominolo: Having finally managed to call into a ghc dll from vs9, I agree.
01:51:29 <quicksilver> vincenz: apparently you have to install, e.g., freeglut to get that.
01:51:43 <windoze> i used native glut from C on windoze years ago
01:51:43 <quicksilver> anyhow, ghc 6.6.1 used to bundle a working GLUT on windows
01:51:47 <quicksilver> 6.8.1 doesn't
01:52:05 <quicksilver> windoze: I'm only repeating what I was told. I've never used windows.
01:52:19 <quicksilver> this seems like a sad regression from 6.6 to me
01:52:38 <nominolo> Zao: would be nice if you could document it on the wiki
01:53:08 <nominolo> Zao: someone will have this problem sooner or later ...
01:53:15 <Zao> nominolo: I believe it's largely documented already though.
01:53:20 <windoze> there would be a real problem if there are games written using glut. compiler upgrade breaks it badly :/
01:53:46 <quicksilver> vincenz, windoze: http://www.haskell.org/pipermail/haskell-cafe/2007-November/035041.html
01:53:47 <lambdabot> Title: [Haskell-cafe] Tetris, http://tinyurl.com/yv4anx
01:53:56 <Zao> nominolo: I just didn't think of looking at the wiki or users guide first.
01:54:10 <quicksilver> (it's entirely possible that Jon H is wrong, but no one corrected him in that thread)
01:54:17 <nominolo> Zao: heh.  well, that's a different problem
01:54:28 <vincenz> quicksilver: s/possible/likely?
01:54:32 <quicksilver> ;)
01:54:40 <Zao> nominolo: And did the apparently common mistake of trying to link directly against the Haskell objects. (one has to stuff them into a dll through gcc)
01:54:54 <quicksilver> windoze: I think a bug report should be submitted. Do you want to or shall I?
01:55:12 <nominolo> Zao: right, you need a trampoline, i guess
01:55:16 <windoze> quicksilver: would you please :)
01:57:47 <nominolo> we file bug reports for correcting Jon H?
01:57:57 <quicksilver> nominolo: no, we file bug reports for GHC regressions.
01:58:20 <nominolo> :)
02:00:00 <quicksilver> windoze: http://hackage.haskell.org/trac/ghc/ticket/1917
02:00:01 <windoze> i guess it's time to get on my linux box to try out opengl with hask
02:00:01 <lambdabot> Title: #1917 (6.8.1 windows installer doesn't include GLUT) - GHC - Trac
02:00:11 <windoze> quicksilver: thanks! :)
02:00:16 <quicksilver> windoze: just chuck your windows box in the bin. you won't regret it.
02:00:22 <quicksilver> use it as a door stop or a foot stool.
02:00:44 <windoze> this is not my box, and i want to produce cross platform code
02:00:58 <windoze> no need to limit to one platform, even if it's linux
02:01:21 <quicksilver> well, GL/GLUT does produce cross-platform code, technically
02:01:32 <quicksilver> it's just that windows people may find it harder to install GLUT :)
02:01:58 <quicksilver> I imagine you can bundle GLUT in some appropriate way with an actual exectuable you are distributing
02:02:07 <quicksilver> although I wouldn't know how to begin doing that :)
02:02:09 <windoze> yeah :) ghc needs to do all the boring stuff, so i just press one button, and it compiles a new original kickass game for me
02:02:38 <nominolo> you can use a VM ...
02:02:51 <nominolo> at least to try things out
02:03:49 <windoze> nominolo: are you referring to coffee beans?
02:04:17 <nominolo> i am refering to VMware, parallels, etc
02:04:37 <quicksilver> you can't use a VM to try windows
02:04:40 <quicksilver> you need to pay for windows
02:04:58 <quicksilver> that would require more commitment to potential downloaders of my game than I have :)
02:05:14 <nominolo> to run Linux *on* Windows
02:05:52 <nominolo> just to get going
02:05:54 <quicksilver> ah
02:05:59 <quicksilver> well windoze has a linux box too, he said
02:06:00 <quicksilver> :)
02:06:20 <windoze> yeah
02:06:24 <quicksilver> at which point his nickname will become sadly inappropriate :(
02:06:51 <windoze> well, i'm sizur here. (i think i'm still logged on from linux box to here)
02:06:56 <nominolo> his nickname is already considered inappropriate as i found out the other day
02:07:43 <windoze> or lost connection
02:09:24 <nominolo> see the "minor rant" part: http://www.haskell.org/pipermail/cabal-devel/2007-November/001403.html
02:09:24 <lambdabot> Title: [Fwd: [Haskell-cafe] Fun with Cabal on Windows! [Stream fusion for Hackage]], http://tinyurl.com/3bozsh
02:09:49 <windoze> i started with linux last year, and windoze feels like a broken bicycle now
02:10:31 <Zao> Woohoo. Starting msys made it forkbomb rxvt terminals.
02:10:31 <quicksilver> nominolo: ndm has always been upset by that. I reserve the right to disagree with him utterly.
02:10:47 <windoze> i am and always will be against political correctness
02:11:19 <quicksilver> nominolo: I have worked 'alongside' although almost never 'with' windows for many years and I have earnt the right to despise it :)
02:11:34 <nominolo> yeah, me too
02:12:41 <nominolo> also digging into open source stuff seems more useful than digging into MS code.  it just feels better
02:13:14 <nominolo> probably because you know "if i find something wrong, i could probably fix it rather than have to live with it"
02:13:40 <windoze> you shouldnt be peeking at ms code anyway
02:13:57 <nominolo> sure, lots of framework code is accessible
02:14:02 <wolverian> heh, "abbreviating it to Win"... feels a bit iffy too, though..
02:14:09 <nominolo> you just can't do anything with it but to read it
02:14:11 <windoze> lol yeah
02:14:18 <nominolo> MS Lose
02:14:54 <windoze> they did push the market themselves for a while, you have to give them credit. just for a dev, linux is so much better
02:15:11 <nominolo> windoze: that's what i mean
02:16:05 <nominolo> also, .Net/Mono seems like a nicer VM than Java -- but they had the advantage of being second
02:16:10 <windoze> a little bit freustration here: wait for happs, wait for cabal, wait for glut...
02:16:35 <nominolo> "wait for" why?
02:16:39 <windoze> not good enough with haskell to contribute
02:16:51 <vincenz> bleh
02:17:20 <windoze> nominolo: because i met walls with each of them
02:19:06 <windoze> clearly for the size of the community, haskell has the best libs alrady. just frustrated with not having more
02:19:14 <windoze> :P
02:20:38 <windoze> going upstairs to try opengl on linux. bye
02:20:40 <quicksilver> windoze: cabal is certainly a work in progress.
02:20:51 <quicksilver> windoze: happs is deep magic and some people may find it fiddly
02:21:01 <quicksilver> windoze: glut is just fine :) it's only the windows installer at fault, nothing more serious.
02:21:08 <nominolo> quicksilver: yes, but bugs are getting fixed pretty quickly (thanks to duncan)
02:21:33 <windoze> quicksilver: i tried unsuccessfully to bundle all deps into one src for happs
02:22:26 <windoze> i think it would be much better instead of stating the extentions in .cabal, state them at the file-level
02:22:46 <windoze> then you can mashup stuff
02:27:47 <vincenz> heh, there was a pants invasion on #scheme
02:27:57 <augustss> yo!
02:28:15 <augustss> @seen heffalump
02:28:15 <lambdabot> heffalump is in #haskell and #darcs. I last heard heffalump speak 11h 33m 2s ago.
02:28:45 <nominolo> the point of stating extensions in the .cabal file is so that you know that you can't build before you try
02:29:42 <nominolo> we really want "cabal init" command that tries to create a .cabal file from all the local files
02:30:43 <waern> will it be followed by a "cabal add" that adds a module to the cabal file? :)
02:31:05 <nominolo> possible
02:31:25 <nominolo> but no "cabal record", i guess ;)
02:34:03 <augustss> cabal init would be very handy
02:35:07 <doserj> and "cabal check" that compares changes in the files with what is in the .cabal (new modules, new build-depends, etc)
02:35:50 <waern> you mean "cabal whatsnew" :-)
02:37:03 <nominolo> "cabal wassup?"
02:37:09 <Zao> Luckily, GLUT seems to still build.
02:38:38 <sizur> yeah, on linux glut is working like a knife on butter
02:38:47 <Zao> This is Vista.
02:39:13 <sizur> Zao i was getting a Cannot find: sh
02:39:16 <sizur> on xp
02:39:25 <Zao> sizur: You need msys and mingw.
02:40:02 <sizur> Zao thanks will try later
02:42:10 <quicksilver> conal: ping
02:42:15 <vincenz> quicksilver: he went
02:42:28 <quicksilver> whither?
02:42:31 <vincenz> to bed
02:42:38 <quicksilver> bah. lightweight!
02:42:40 <quicksilver> sleep is for the WEAK
02:42:57 <vincenz> quicksilver: I bet you're a productive person :)
02:43:10 <quicksilver> no, I'm a weak person :(
02:43:11 <nominolo> it's like 4 a.m. in PDT
02:43:20 <vincenz> hmm
02:43:25 <vincenz> no, nearly 3am
02:43:27 <vincenz> it's CET-9
02:43:32 <vincenz> @localtime nominolo
02:43:33 <lambdabot> Local time for nominolo is Thu Nov 22 11:42:41
02:43:45 <nominolo> @localtime dons
02:43:46 <lambdabot> Local time for dons is Thu Nov 22 02:43:45 2007
02:43:50 <Zao> sizur: And seems to work flawless.
02:50:30 <sjanssen> @pl \xs -> zip3 xs (tail xs) (tail $ tail xs)
02:50:30 <lambdabot> ap (ap zip3 tail) (tail . tail)
03:01:23 <Big_Ham> ...
03:01:35 <quicksilver> .,.
03:01:47 <Big_Ham> aha there are actually active people in here!
03:01:52 <vincenz> Nioe
03:01:55 <vincenz> We are bots
03:01:55 <TSC> Never
03:02:01 <Big_Ham> :D
03:02:03 <TSC> Please insert coin
03:02:09 <Big_Ham> and press go?
03:02:11 <opqdonut> ?botsnack
03:02:12 <lambdabot> :)
03:02:17 <opqdonut> ^.^
03:02:43 <Big_Ham> can anyone help with a defining a data type please?
03:02:53 <TSC> Of course!
03:02:55 <Zao> data Please = Kthx
03:02:58 <opqdonut> just ask
03:03:23 <vincenz> Zao: you mean KThxBye
03:03:24 <Big_Ham> Well I'm trying to define a datatype to represent a function
03:03:43 <Big_Ham> like 2 + 1 or 1+2, but using any number and any symbols
03:03:50 <Big_Ham> and it being of any length
03:03:57 <Big_Ham> but I can't use the num class
03:04:09 <TSC> Do you mean an expression?
03:04:13 <Big_Ham> yeah
03:04:24 <quicksilver> data Expr = Constant Int | Add Expr Expr | Times Expr Expr
03:04:26 <quicksilver> etc....
03:04:29 <opqdonut> yep
03:04:30 <vincenz> quicksilver: nooo
03:04:37 <Big_Ham> you just type Add and that?
03:04:40 <quicksilver> if you want to be a bit more uniform with the binary operators
03:04:45 <quicksilver> could do something like
03:04:46 <vincenz> data Exp = Constant Const | Function (Exp -> Exp -> Exp) | Application Exp Exp
03:04:49 <vincenz> :)
03:05:02 <quicksilver> data Expr = Constant Int | Binary Operator Expr Expr
03:05:07 <quicksilver> ...but then you need
03:05:12 <quicksilver> data Operator = ...
03:05:14 <vincenz> quicksilver: HOAS
03:05:14 <opqdonut> nah, you can't introspect Function (...)
03:05:20 <quicksilver> which is a list of all the binary operators
03:05:35 <quicksilver> vincenz: there's more than one way to do it, I'm just outline part of the solution space :)
03:05:44 <vincenz> quicksilver: I know :P
03:05:57 <vincenz> anywho, I haven't actually used HOAS
03:05:59 <vincenz> the simplest is
03:06:16 <roconnor_> @pl (fun x => x a)
03:06:17 <lambdabot> fun x => x a
03:06:20 <roconnor_> oops
03:06:21 <vincenz> data Exp = Const Constant | Var String | Lambda String Exp | App Exp Exp
03:06:25 <roconnor_> @pl (\x -> x a)
03:06:25 <lambdabot> ($ a)
03:06:27 <vincenz> for some values of Constant
03:06:39 <roconnor_> @type flip id.
03:06:40 <lambdabot> parse error (possibly incorrect indentation)
03:06:40 <Big_Ham> so Add Expre Expre will take 2 numbers and add them?, assuming that Expre = Integer| Add Expre Expre?
03:06:44 <roconnor_> @type flip id
03:06:44 <lambdabot> forall b c. b -> (b -> c) -> c
03:06:54 <vincenz> roconnor_: I always use $a
03:07:02 <vincenz> roconnor_: like map ($x) list_of_fs
03:07:03 <Big_Ham> $a means the same as Add?
03:07:12 <vincenz> Big_Ham: no
03:07:17 <Big_Ham> ok
03:07:31 <wli> So in real life you have more than binary ops.
03:07:57 <Big_Ham> it just uses +-*/ =
03:08:09 <Big_Ham> and you can use () as well
03:08:10 <quicksilver> Big_Ham: no, it doesn't do anything to them
03:08:16 <quicksilver> Big_Ham: it represents them
03:08:16 <wli> You have unary ops, binary ops, ternary ops, binary ops with pairs of results, and maybe a couple other things.
03:08:29 <quicksilver> Big_Ham: without doing the calculation
03:08:39 <quicksilver> Big_Ham: you're trying to represent the expression, not the result
03:08:45 <quicksilver> Big_Ham: (at least, I assumed you were)
03:08:46 <wli> And a lot of times those have various types wired into them.
03:08:55 <Big_Ham> aaaa
03:09:20 <Big_Ham> I need to represent the expression, but then be able to get a result form it
03:09:21 <Big_Ham> *from
03:09:34 <Big_Ham> but yes it is meant to represent the expression itsselfd
03:09:37 <quicksilver> yes
03:09:42 <wli> Conversion ops, for instance, will have result types different from argument types.
03:09:48 <quicksilver> so then you need a functionr to actually evalute it
03:09:50 <quicksilver> like
03:09:56 <quicksilver> evaluate :: Expr -> Int
03:09:57 <wli> Arithmetic ops mostly have the same types all the way through.
03:10:01 <Big_Ham> yep
03:10:02 <quicksilver> which folds your expression down into an Int
03:10:10 <quicksilver> which you can write easily by recursion
03:10:15 <Big_Ham> yeah, that's a question later on :D
03:10:15 <quicksilver> evaluate (Constant i) = i
03:10:24 <Big_Ham> I just couldn't get the damn datatype redefined
03:10:29 <quicksilver> evaluate (Add e1 e2) = evaluate e1 + evaluate e2
03:10:30 <quicksilver> etc
03:10:31 <vincenz> quicksilver: I wouldn't do it that way
03:10:43 <vincenz> quicksilver: introduce a 'value' type
03:10:44 <quicksilver> of course I'm making some pretty big assumptions by using Int and so forth
03:10:56 <quicksilver> but I assume you can think of ways to improve that :)
03:11:02 <Big_Ham> it can only use whole positive numbers, so I think Int's ok
03:11:05 <Big_Ham> so +1 upwards
03:13:14 <pejo> vincenz, how would you do?
03:20:51 <Big_Ham> so now I've defined these expressions, what's going to be the best way for me to display them?
03:21:11 <wli> http://holomorphy.com/~wli/Ops.lhs <-- not quite as extensible as one might want
03:21:53 <Big_Ham> ok, thank you
03:23:51 <wli> I think Ops.lhs might need/want GADT's
03:23:54 <wli> Not 100% sure.
03:24:59 <Big_Ham> ok
03:26:13 <Big_Ham> Couldn't I just concatinate the Expre with an Empty string then display it as a String?
03:26:36 <quicksilver> Big_Ham: you can't concatenate stuff with strings, unless it is strigs :)
03:26:51 <Big_Ham> ok
03:26:52 <Big_Ham> :(
03:27:01 <quicksilver> Big_Ham: you can derive show for a simple way to display them
03:27:05 <quicksilver> that's unlikely to be good enough
03:27:13 <quicksilver> you probably want to display the operators 'infix'
03:27:21 <quicksilver> that is, 1 + 3 not Add 1 3
03:27:21 <Big_Ham> I have dervied show, but it still can't infer existance
03:27:43 <Big_Ham>  that is, 1 + 3 not Add 1 3
03:27:50 <Big_Ham>  that would be better.
03:28:02 <Big_Ham> well I think that's how it's meant to be done at any rate
03:28:29 * quicksilver nods
03:28:35 <quicksilver> well you're going to have to write the code, then :P
03:28:40 <quicksilver> This is rather the point, I think
03:28:52 <Big_Ham> yep
03:29:08 <Big_Ham> but I'm not sure how to do it, going to have to hit the books mez thinks
03:29:15 <Big_Ham> thank's for your help guys!
03:31:17 <sizur> System.CPUTime, is it not thread safe?
03:32:40 <sizur> i get wierd results from getCPUTime in my opengl app
03:33:13 <quicksilver> what kind of weird?
03:33:27 <quicksilver> @index getCPUTime
03:33:28 <lambdabot> System.CPUTime
03:34:29 <sizur> it always returns the same value, no matter how long the app is running
03:34:53 <sizur> 's working fine in a non-opengl app
03:35:00 <wli> How do you represent an op that returns a pair in an expression tree like that?
03:35:02 <roconnor> @go 1 CAD in USD
03:35:02 <lambdabot> 1 Canadian dollar = 1.019056 U.S. dollars
03:35:22 <sizur> @go 1 USD in HUF
03:35:22 <lambdabot> 1 U.S. dollar = 173.040318 Hungarian forints
03:35:59 * wli is not entirely sure it's possible.
03:36:19 <wli> Some sort of DAG is required.
03:38:42 * wli fails to figure out how to represent such a DAG in a typeful manner.
03:40:37 <quicksilver> wli: sure you just have a type system
03:40:45 <quicksilver> wli: and that op returns 'pair'
03:40:50 <quicksilver> which is a compound type?
03:41:42 <wli> I shouldn't have nuked the old Ops.lhs
03:42:32 <wli> quicksilver: I had data BoolExpr = LitBool Bool | ... | IntLessEq IntExpr IntExpr | ...
03:43:07 <wli> quicksilver: And data IntExpr = LitInt Int | ... | IntCond BoolExpr IntExpr IntExpr
03:43:59 <quicksilver> wli: there are multiple possible solutions :)
03:44:13 <quicksilver> wli: you can have an 'Expr' which "doesn't know it's typed"
03:44:18 <wli> quicksilver: The trouble with pairs was that there was no way to get all the possible pair types enumerated.
03:44:21 <quicksilver> and have a typecheck function
03:44:32 <wli> quicksilver: That's what I was trying to avoid.
03:44:44 <quicksilver> right, because you don't want to be able to represent invalid Exprs
03:44:49 <quicksilver> although, that turns out to be quite hard
03:44:51 <wli> exactly
03:44:58 <quicksilver> there's almost always some way for invalid Exprs to creep in
03:45:06 <quicksilver> however, GADTs do give another possible solution
03:45:16 <quicksilver> indeed, this is one of the "textbook" GADT examples
03:45:22 <wli> which is why I brought up GADT
03:45:23 <wli> 'ss
03:45:25 <quicksilver> :)
03:45:42 <quicksilver> all of which is probably more subtle than what Big_Ham needs, though
03:45:52 <quicksilver> and to be honest, I think you need to have followed the simple paths to their conclusion
03:46:01 <quicksilver> before the need for the more complex paths becomes truly clear :)
03:46:08 <quicksilver> at least, I found *I* needed that.
03:46:25 <wli> Not sure what you're suggesting I do.
03:47:06 <sjanssen> wli: now write the parse :: String -> Expr a function for your GADT
03:47:37 <sjanssen> it is surprisingly difficult :)
03:48:00 <wli> The whole GADT question revolved around how to use GADT's to represent the expr's.
03:48:13 <wli> I'd not considered marshalling them.
03:48:52 <wli> I don't really get GADT's.
03:49:39 <quicksilver> sjanssen: can parsec/readP even do that?
03:49:51 <quicksilver> sjanssen: or do they lack a way to thread the polymorphism properly?
03:50:10 <sjanssen> quicksilver: it is even difficult to do it by hand
03:50:27 <mattam> it should be String -> exist a. Expr a right ?
03:50:39 <quicksilver> mattam: not necessarily
03:50:47 <quicksilver> mattam: it could just give an error if you demand the wrong a
03:50:52 <quicksilver> mattam: (which is probably more useful)
03:50:53 <wli> It's difficult enough for me to even understand what on earth is going on with GADT's even irrespective of marshalling.
03:50:59 <sjanssen> perhaps Maybe (Expr a) is more clear
03:51:08 <mattam> oh... but that's a type error at runtime...
03:51:20 <quicksilver> mattam: it's a source language type error
03:51:25 <quicksilver> mattam: not a haskell type error
03:51:27 <sjanssen> I don't actually know how you'd write this
03:51:46 <quicksilver> mattam: when you're writing an interpreter you expect run time type errors from the bits you're parsing :)
03:52:12 <quicksilver> sjanssen: I haven't tried, so I don't immediately see what becomes difficult. However, I do believe you :)
03:52:15 <mattam> I can't see how you can write a total haskell expression of type forall a. String -> Expr a
03:52:45 <sjanssen> data Expr a where Foo :: Expr a
03:52:55 <sjanssen> const Foo :: forall a. String -> Expr a
03:53:14 <sjanssen> :P
03:53:17 <mattam> Even a non-trivial String -> Maybe (Expr a) i'm not sure
03:53:21 <mattam> sjanssen: ...
03:56:06 <quicksilver> hmm interesting
03:56:14 <quicksilver> however, I don't have time to think about this now :)
03:56:24 * quicksilver files that in list-of-things-to-ponder
03:56:27 <mattam> he, later then :)
03:57:04 <quicksilver> sjanssen: I believe I understand the problem now :)
03:58:33 <sjanssen> mattam: I believe it is possible, but I'm not sure how
03:58:35 <wli> http://holomorphy.com/~wli/Ops.lhs <-- lambda calc as a GADT?
03:59:10 <sjanssen> perhaps using Typeable's safe cast functions
03:59:37 <quicksilver> sjanssen: it's definitely possibly using Typeable, but that feels like a nasty hack to me
03:59:49 <mattam> I don't. String -> Maybe (exist a. Expr a) is doable
03:59:53 <sjanssen> wli: that isn't a _G_ ADT, it's just an ADT using that syntax
04:00:06 <wli> What's the thing again? {-# LANGUAGE GADT #-}?
04:00:33 <sjanssen> mattam: AIUI, the exist a. part is implicit in GHC
04:00:51 * Big_Ham is back to annoy everyone
04:00:58 <quicksilver> sjanssen: on the other hand, I guess Expr a is a lie
04:01:06 <quicksilver> sjanssen: because it suggests it makes sense for any type a
04:01:16 <quicksilver> sjanssen: in practice, you expect a limited class of types 'a'
04:01:28 <quicksilver> sjanssen: so maybe it should be constrained by a typeclass anyway
04:01:42 <mattam> oh... then it's possible to write something.
04:01:42 <quicksilver> EmbeddedType a => Expr a
04:01:52 <quicksilver> and then you can use the same tricks as typeable, basically
04:02:06 <mattam> typeable gives you a typecase ?
04:02:23 <quicksilver> yes
04:02:24 <quicksilver> in effect
04:02:34 <mattam> Then everything's possible :)
04:02:37 <quicksilver> :t cast
04:02:40 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
04:02:54 <quicksilver> safe cast is a kind of one-off case
04:03:02 <sjanssen> a typecase that only works on concrete types
04:03:03 <quicksilver> if I'm not mistaken it's equivalent
04:03:08 <mattam> You can cast something as a function ?
04:03:08 <quicksilver> right
04:03:12 <wli> sjanssen: Why isn't it a true GADT?
04:03:31 <mattam> wli: you miss the parameter of Expr
04:03:41 <wli> Okay, I added one.
04:03:56 <quicksilver> wli: GADTs have constructors returning less-than-fully-general types
04:03:59 <matthew-_> @users
04:04:00 <lambdabot> Maximum users seen in #haskell: 418, currently: 370 (88.5%), active: 10 (2.7%)
04:04:05 <quicksilver> if all your constructors return the same type, it's not "G"
04:05:45 <wli> I don't see an opportunity to use that here.
04:07:28 <mattam> Think Expr Char for LitChar
04:07:49 <wli> It's not parametrized on the result type. I suppose I could do so.
04:08:47 <hpaste>  mattam pasted "A Coq version of Expr GADT" at http://hpaste.org/4040
04:10:55 <wli> I couldn't figure out how to type Tuple, Project, Constructor, Case, Apply, or Lambda.
04:12:26 <mattam> look at my paste, it should get clearer
04:12:58 <mattam> You can build a Tuple of type Expr (a, b) from an Expr a and an Expr b
04:13:27 <wli> Those would only be 2-tuples.
04:13:50 <mattam> right
04:14:39 <vincenz> you can build X-tuples out of 2-tuples
04:15:08 <mattam> With your list it gets harder, you have to have an existential package exist a. Expr a in each list cell, and the you need to fold through it to find the type of the whole tuple expr --> type level computation.
04:16:25 <mattam> Maybe you can do that with some typeclass hackery too.. i'm not sure
04:16:53 <wli> The limits happen quickly.
04:17:09 <wli> Constructor and Case similarly I take it?
04:17:36 <mattam> Case should be doable, each branch should have the same type
04:18:21 <wli> tired
04:18:48 <mattam> Yep, GADT's need type-level computations to be really useful
04:20:07 <quicksilver> well you could reflect the types down to value level too
04:20:13 <quicksilver> which I think I'd be inclined to do
04:20:20 <quicksilver> but that's boilerplate :(
04:20:25 <quicksilver> not *too* much boilerplate though.
04:21:26 <mattam> Well, it doesn't work when you want abstraction too, which you want at some point.
04:22:28 <mattam> e.g. an abstract type index A that is an instance of some class.
04:22:48 <quicksilver> 'you want at some point' may be too strong :)
04:22:55 <quicksilver> I can certainly imagine use cases which don't need that.
04:23:03 <quicksilver> 'you may want sometimes' ? :)
04:23:13 <mattam> Yes, that's what I meant
04:26:26 <UUStudent79> hello
04:26:34 <UUStudent79> anyone can help me?
04:26:46 <UUStudent79> i'm spanish, i'm in a trouble!
04:26:55 <Syzygy-> Sorry, can't do anything about you being spanish.
04:27:20 <UUStudent79> i have a problem with an exercise
04:27:33 <UUStudent79> i'm asking for help to resolve
04:27:41 <vincenz> UUStudent79: ask your question, don't ask if you can ask
04:27:52 <UUStudent79> ok
04:28:02 <UUStudent79> 1 minute, i need to translate
04:28:07 <UUStudent79> thanks!
04:28:11 <Botje> right
04:28:12 <vincenz> and use @paste for code
04:28:52 <Botje> you think he'd have translated it to english if it was so important
04:29:25 <vincenz> no, we first have to be hooked into the helping process an then wait
04:29:30 <vincenz> it increases our anticipation to help him :)
04:29:33 <Botje> busy wait, even
04:30:34 <EvilTerran> people might be unwilling to offer to help if they don't know what they're offering to help with
04:30:42 <Botje> heh
04:30:49 <UUStudent79> what?
04:30:51 <Botje> maybe he's translating the description for his thesis
04:30:58 <Botje> "TOO LATE YOU SAID YOU'D HELP ME!"
04:31:00 <UUStudent79> how i need to use @?
04:31:07 <Big_Ham> @paste
04:31:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:31:13 <UUStudent79> ok! thnaks
04:31:22 <UUStudent79> i'm finishing... wait please!
04:31:31 <Big_Ham> check
04:32:01 * vincenz continues busy-waiting
04:32:29 <vincenz> UUStudent79: asking people to wait is silly, there's > 300 people in the channel, I'm certain some will be around when you actually ask your question. . And in general, people are all too eager to help in this channel
04:32:31 <Botje> everytime you busy-wait, SPJ kills a kitten.
04:32:33 <vincenz> As shown by
04:32:34 <vincenz> @quote stereo!
04:32:34 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
04:32:42 <Botje> the stereo quote is back?!
04:32:44 * Botje dances
04:32:48 <vincenz> Botje: notice !
04:33:29 * opqdonut dances
04:33:30 <opqdonut> yay
04:33:31 <opqdonut> stereo
04:33:43 * Big_Ham is waiting for Dolby 5.1
04:33:44 <UUStudent79> well
04:33:48 <UUStudent79> here I go!
04:33:49 <opqdonut> tho we need the "dolby surround" quote also
04:33:56 <UUStudent79> @In the next type to representate lists:
04:33:56 <Big_Ham> 5.1 ftw
04:33:57 <lambdabot> No match for "the".
04:33:57 <lambdabot>  
04:33:57 <lambdabot> *** "next" wn "WordNet (r) 2.0"
04:33:57 <lambdabot> next
04:33:57 <lambdabot>      adj 1: nearest in space or position; immediately adjoining without
04:33:59 <lambdabot> [35 @more lines]
04:34:03 <vincenz> wtf
04:34:07 <UUStudent79> @
04:34:10 <vincenz> @paste
04:34:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:34:21 <UUStudent79> uf, line per line?
04:34:31 <UUStudent79> i'm so silly
04:34:38 <vincenz> no
04:34:40 <vincenz> go to pastesite
04:34:42 <vincenz> past everything there
04:34:47 <vincenz> pastebot gives us the link
04:34:53 <UUStudent79> ok, lets try it again!
04:35:17 * vincenz looks at SPJ killing more kittens with STM
04:35:28 <UUStudent79> http://hpaste,org ???
04:35:40 <UUStudent79> http://hpaste.org ???
04:35:45 <vincenz> that is what it said
04:35:49 <UUStudent79> ok
04:36:11 <UUStudent79> ok
04:36:15 <UUStudent79> im there
04:36:15 <opqdonut> :D
04:36:17 <UUStudent79> and now?
04:36:23 <vincenz> minchia
04:36:38 <vincenz> http:/hpaste.org/new
04:36:42 <UUStudent79> ok
04:36:46 <vincenz> Paste your stuff in the window and click the button at the bottom
04:36:58 <vincenz> and no need to give us a live feed of what you're doing, this is irc, not jotter
04:37:53 <UUStudent79> ok, sorry
04:38:21 <nominolo> @google jotter
04:38:22 <lambdabot> http://www.jotter.com/
04:38:22 <lambdabot> Title: Jotter Technologies Inc.
04:38:49 <hpaste>  UUStudent79 pasted "List Haskell" at http://hpaste.org/4041
04:39:19 <UUStudent79> i've finished!!
04:39:21 <UUStudent79> haha
04:39:41 <vincenz> nominolo: whatever they call thta thing where you .... oh twitter!
04:40:17 <vincenz> UUStudent79: sounds like homework
04:40:36 <quicksilver> clearly, since he had to translate the exercise from spanish :)
04:40:37 <UUStudent79> not exactly
04:40:41 <ari> vincenz: I'd rather expect that from someone whose nick is UUStudent79 :p
04:40:47 <UUStudent79> is a part of a groupwork
04:40:54 <osfameron> @pl (\a b -> (a==b, a))
04:40:54 <lambdabot> flip =<< ((,) .) . (==)
04:41:01 <osfameron> eeeeek!
04:41:06 <quicksilver> UUStudent79: well, you will have to define length by recurstion
04:41:12 <osfameron> can I do that with an arrow operator more legible?
04:41:16 <osfameron> *legibly
04:41:19 <hpaste>  vincenz annotated "List Haskell" with "fix" at http://hpaste.org/4041#a1
04:41:42 <quicksilver> UUStudent79: and by the three cases, U, V, and :+:
04:41:46 <vincenz> seems more like a list than a tree tbh
04:41:51 <vincenz> erm
04:41:53 <vincenz> tree than a list
04:41:55 <quicksilver> UUStudent79: I presume V is supposed to be empty
04:42:07 <quicksilver> UUStudent79: so I'm guessing mylength V = 0 is a good start
04:42:30 <quicksilver> vincenz: I would gather from the name it is a representation of a list as a tree :)
04:42:47 <UUStudent79> well, take it easy
04:42:57 <hpaste>  vincenz annotated "List Haskell" with "hints for UUStudent" at http://hpaste.org/4041#a2
04:42:58 <UUStudent79> sorry, but im spanish, my english is so bad
04:43:03 <vincenz> UUStudent79: look at that link
04:43:05 <quicksilver> vincenz: I daresay it's an exercise in writing recursion functions, with an alternate list rep as an example
04:43:23 <UUStudent79> ok, thanks vincez, i will
04:43:28 <vincenz> UUStudent79: that should give you more than enough hints
04:44:02 <vincenz> along with what quicksilver said
04:44:02 <EvilTerran> (\a b -> (a==b, a)) = (\a b -> (==b) &&& id $ a) = flip (\b -> (==b) &&& id) = flip ((&&& id) . (==))
04:44:10 <EvilTerran> osfameron, any better?
04:44:19 <EvilTerran> > flip ((&&& id) . (==)) 1 2
04:44:21 <lambdabot>  (False,1)
04:44:34 <vincenz> erm
04:44:51 <UUStudent79> http://hpaste.org/4041#a2 --> this link dont works
04:45:00 <vincenz> works for me
04:45:03 <nominolo> > (first (==5)) (5,2)
04:45:04 <quicksilver> osfameron: you could write it as a micture of uncurry, fst, and ==
04:45:11 <lambdabot>  (True,2)
04:45:12 <osfameron> EvilTerran: shiny
04:45:15 <quicksilver> osfameron: I don't think it wold lok all that nice :)
04:45:20 <Big_Ham> UUstudent79, worked for me
04:45:22 <osfameron> quicksilver: hehe
04:45:34 <quicksilver> I think your initial lambda form was clear enough
04:46:03 <Big_Ham> I still can't get my Expressions to display, it says cannot infer existance in all but one case.
04:46:05 <osfameron> quicksilver: I'm looking at Ranguard's problem for initial substring matching: "abcde" and "abc123"
04:46:12 <hpaste>  Big_Ham pasted "work" at http://hpaste.org/4042
04:46:13 <nominolo> > (encurry $ first (==5)) 5 2
04:46:14 <lambdabot>   Not in scope: `encurry'
04:46:18 <osfameron> > > map snd . takeWhile fst . zipWith (\a b -> (a==b, a)) $ "abcde" "abc123"
04:46:19 <nominolo> > (uncurry $ first (==5)) 5 2
04:46:19 <lambdabot>   parse error on input `>'
04:46:19 <lambdabot>  Couldn't match expected type `b -> c'
04:46:20 <EvilTerran> osfameron, or ((,) =<<) . (==)
04:46:28 <UUStudent79> Big_Ham what do you say?
04:46:34 <EvilTerran> (((,) =<<) . (==)) 1 2
04:46:37 <EvilTerran> > (((,) =<<) . (==)) 1 2
04:46:37 <nominolo> > (curry $ first (==5)) 5 2
04:46:37 <lambdabot>  (False,2)
04:46:38 <lambdabot>  (True,2)
04:46:39 <Big_Ham> the link works
04:46:46 <osfameron> I always get into trouble trying to compose 1 arg functions with 2 arg functions...
04:46:52 <Big_Ham> and I can't get my expressions to display on my work
04:46:58 * osfameron runs away in fear from EvilTerran 
04:47:01 <EvilTerran> nominolo, he's splitting the a across both sides of the tuple
04:47:16 <nominolo> oh
04:47:30 <vincenz> UUStudent79: go to the same link you sent us, refresh and scroll down
04:47:33 <EvilTerran> ((,) =<< (==b)) is, er, relatively self-explanitory
04:47:48 <UUStudent79> ok, i will try again, thanks vincenz
04:48:19 <nominolo> do we have (.) = fmap now?
04:48:21 <EvilTerran> @type (,) =<< (==(5::Int))
04:48:22 <lambdabot> Int -> (Bool, Int)
04:48:32 <vincenz> nominolo: I think in Applicative
04:48:44 <nominolo> evil ...
04:48:51 <EvilTerran> yeah =]
04:48:53 <UUStudent79> now it works, thanks again vincenz
04:48:56 <vincenz> you do know what will happen, right?
04:48:58 <nominolo> i always get confused about fmap
04:48:59 <vincenz> Eventually
04:49:02 <EvilTerran> i'd go for the arrow version, though
04:49:09 <vincenz> everything of haskell will boil down into a single SUPER-meta type class
04:49:10 <int-e> hmm? I thought we have a Control.Category now which has a (.) which is *not* fmap.
04:49:12 <vincenz> with one operation: 42
04:49:16 <nominolo> i found that "reach inside" seems to be a good metaphor, though
04:49:16 <vincenz> or ($)
04:49:48 <nominolo> vincenz: no,no flip ($)
04:50:00 <Big_Ham> Does anyone have any idea's as to why I can't get my Expressions to display?
04:50:04 <vincenz> if you want $ to be addition
04:50:12 <vincenz> a $ 5 :: Sum Int
04:50:17 <vincenz> if you want it to be multiplication
04:50:20 <vincenz> 4$ 5 :: Mul Int
04:50:40 <nominolo> if you want to see absurdly abstracted code take a look at the UU parser combinators
04:50:41 <vincenz> and obviusly ($) is the generalisation of (.) :)
04:50:47 <UUStudent79> another question: the best O.S. to works with Curry or Haskell is ubuntu?
04:51:05 <EvilTerran> that's a matter of opinion
04:51:11 <EvilTerran> I get by fine on windows XP (mostly)
04:51:17 <nominolo> UUStudent79: depends on which libraries you need
04:51:17 <UUStudent79> XP?
04:51:26 <nominolo> 95!
04:51:30 <nominolo> ME!
04:51:31 <sciolizer> Big_Ham: works fine for me: display (Add (Lit 5) (Lit 6)) --> "(5 + 6)"
04:51:50 <EvilTerran> ... yes. XP. http://www.microsoft.com/windows/products/windowsxp/
04:52:23 <UUStudent79> ok, thanks a lot everyone!
04:52:27 <EvilTerran> however, more haskell-related stuff works on linux
04:52:28 <UUStudent79> time to lunch!
04:52:39 <EvilTerran> so I occasionally switch to Fedora for that
04:53:20 <vincenz> there's a new version of windows, it's a combination of CE, ME and NT: Windows CEMENT: guaranteed to be slower than molasses
04:53:27 * int-e still wonders why his mail to the libraries mailing list about Control.Category got only one reply so far :/
04:54:08 <quicksilver> int-e: I wasn't sure what to add, although I saw your point
04:54:39 <hpaste>  osfameron pasted "Common prefix" at http://hpaste.org/4043
04:55:25 * osfameron tries with the EvilVersion...
04:55:50 <hpaste>  vincenz annotated "Common prefix" with "nicer" at http://hpaste.org/4043#a1
04:55:58 <int-e> quicksilver: I was hoping for a few votes, "I'm unhappy, too" or "I actually like the change".
04:55:58 <vincenz> osfameron: like that?
04:56:18 <int-e> quicksilver: maybe I should've made it a proposal. maybe I'll do that next week.
04:56:23 <quicksilver> int-e: *nod*
04:56:37 <osfameron> vincenz: ooo, I didn't see that version.
04:56:39 <vincenz> int-e: what's it about?
04:56:39 <quicksilver> osfameron: yeah, I was going to suggest something like vincenz's version
04:56:50 <osfameron> vincenz: as it happens, I don't understand why that would work
04:56:53 <vincenz> osfameron: I like the .:
04:57:00 <vincenz> osfameron: erm
04:57:01 <vincenz> @type uncurry
04:57:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:57:04 <vincenz> @type uncurry (==)
04:57:05 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
04:57:07 <vincenz> :)
04:57:12 <osfameron> ah ok
04:57:18 <osfameron> I hadn't seen the zip at the end
04:57:26 <osfameron> working back along the pipeline it makes sense
04:59:16 <vincenz> osfameron: why 8 and not 9 like .?
04:59:24 <int-e> vincenz: short story, there's a module Control.Category in the darcs head of the base library and Control.Arrow uses it. This breaks HXT for example. Long story at http://www.haskell.org/pipermail/libraries/2007-November/008593.html
04:59:25 <lambdabot> Title: Control.Category in base, http://tinyurl.com/22jtop
04:59:37 <vincenz> Oh right
04:59:39 <osfameron> vincenz: cos it gave me an error when I tried with 9 :-)
04:59:49 * vincenz read that, though I don't see what the 'proposal' would be then
05:00:28 <osfameron> vincenz: is (.:) defined somewhere?  I really can't be arsed with jumping through hoops to compose with a 2-arg function, I want to abstract it
05:00:41 <vincenz> quicksilver: in a way it's a shame you have to zip and then fst, it's not exactly efficient
05:00:55 * vincenz wishes there was foldr2 and unfoldr2
05:01:06 <vincenz> @type (.)
05:01:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:01:10 <vincenz> @type (.) . (.)
05:01:11 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:01:17 <vincenz> @hoogle forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:01:18 <lambdabot> Did you mean: Forall a b c A1. (b -> c) -> (a -> A1 -> b) -> a -> A1 -> c
05:01:24 <osfameron> yeah, I didn't want to zip the same value together, which is why I moved to the zipWith version
05:01:25 <vincenz> @hoogle (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:01:26 <lambdabot> Did you mean: (b -> c) -> (a -> A1 -> b) -> a -> A1 -> c
05:01:34 <vincenz> @hoogle (b -> c) -> (a -> d -> b) -> a -> d -> c
05:01:35 <lambdabot> No matches, try a more general search
05:01:37 * vincenz groans
05:01:37 <int-e> vincenz: Well the proposal would be to revert that patch. It's a rather negative proposal but I really don't like breaking existing packages for no visible gain.
05:01:46 <vincenz> int-e: true
05:02:45 <vincenz> commonPrefix (x:xs) (y:ys) | x == y = x:commonPrefix xs ys
05:02:55 <vincenz>                              | otherwise = commonPrefix xs yss
05:03:02 <vincenz>  .. _ _ = ][
05:03:06 <vincenz> s/][/[]
05:10:04 <osfameron> vincenz: I think it shouldn't recurse into commonPrefix in the otherwise case though
05:10:16 <vincenz> oh, good point
05:10:16 <vincenz> []
05:10:28 * vincenz is currently stressed about a presentation he has to give, hence the mistake
05:10:45 <osfameron> ah, break a leg!
05:10:52 <vincenz> while I get on stage?
05:11:03 * osfameron wonders what foldr2 would do...
05:11:12 <vincenz> it'd be like foldr
05:11:14 <vincenz> @type foldr
05:11:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:11:37 <vincenz> (a -> c -> b -> b) -> b -> [a] -> [c] -> b
05:12:00 <vincenz> boo on the non-unified ordering of parameters, that always trips me up
05:12:05 <vincenz> it's not even consistent with foldl
05:12:47 <osfameron> as in (a->c->b->b) instead of (a->b->c->c) ?
05:12:58 <vincenz> no as in
05:13:11 <vincenz> (A -> b -> b) -> b -> [A] -> b
05:13:16 <vincenz> should've been
05:13:23 <vincenz> (A -> b -> b) -> [A] -> b -> b
05:13:30 <ricky_clarkson> :t foldl
05:13:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:13:33 <osfameron> ah ok
05:13:38 <ricky_clarkson> Seems consistent.
05:13:42 <vincenz> ricky_clarkson: no it's not
05:13:50 <vincenz> ricky_clarkson: in foldr the list value is first, in foldl it's second
05:14:05 <vincenz> notice how they flip the names of the types, (due to ordering) which makes you think it's consistent
05:14:24 <vincenz> @type foldr
05:14:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:14:25 <vincenz> @type foldl
05:14:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:14:55 <vincenz> the inconsistency is in the function passed to the fold
05:15:07 <ricky_clarkson> > foldl (/) 1 [2]
05:15:09 <lambdabot>  0.5
05:15:19 <ricky_clarkson> > foldr (/) 1 [2]
05:15:19 <lambdabot>  2.0
05:15:28 <ricky_clarkson> I think the above shows why.
05:15:56 <vincenz> ricky_clarkson: except that in most cases, you're working with multi-typed fold-functions and then it's annoying to remember the ordering
05:16:27 <vincenz> anywho
05:16:34 <vincenz> pov differ
05:17:19 <ricky_clarkson> in foldr the initial value (1 above) is on the end of the hof's parameter list, i.e., on the rhs.  It seems to make sene to me, though I haven't thought it through.
05:17:57 <vincenz> ricky_clarkson: it's less obvious for non-numeric functions
05:18:14 <vincenz> and there, I'd prefer consistency then
05:19:06 <vincenz> > foldr (/) 1 [2,3]
05:19:08 <lambdabot>  0.6666666666666666
05:19:20 <ricky_clarkson> @pl f a xs -> foldr (flip f) a xs
05:19:20 <lambdabot> (line 1, column 8):
05:19:21 <lambdabot> unexpected ">" or "-"
05:19:21 <lambdabot> expecting variable, "(", operator or end of input
05:19:29 <ricky_clarkson> @pl \f a xs -> foldr (flip f) a xs
05:19:30 <lambdabot> foldr . flip
05:20:10 <ricky_clarkson> > let flipper=foldr . flip in flipper (/) 1 [2,3]
05:20:12 <lambdabot>  0.16666666666666666
05:25:27 <quicksilver> vincenz: I think the function is the right way round.
05:25:38 <quicksilver> vincenz: but the 'initial value' and lists could be swapped, in the foldr case.
05:26:01 <quicksilver> so we'd have foldr (/) [2] 1 === 2.0
05:26:07 <quicksilver> which looks more sensible in many ways
05:27:10 <EvilTerran> however, it'd move foldr from the mechanical design of fold functions in general
05:28:06 <EvilTerran> it's nice to be able to look at the data decleration and be able to deduce the type of the fold from that pretty much directly
05:28:43 <ricky_clarkson> I'm not sure that moving the arguments around would preclude that.
05:28:44 <quicksilver> EvilTerran: true, and that's probably why they don't do it
05:28:54 <quicksilver> EvilTerran: but, on the other hand, foldl isn't a fold in that sense
05:29:00 <EvilTerran> mm, true
05:29:24 <EvilTerran> ricky_clarkson, well, it'd get rid of the :: ... -> Foo a -> b, for one
05:29:48 <EvilTerran> which is also kinda useful WRT partial application
05:30:11 <EvilTerran> (foldr f e) is more generally useful than (foldr f xs) would be
05:30:50 <ricky_clarkson> Yes, it's kinda irritating that you can only partially apply in the order the function comes in, unless you use flip.
05:31:37 * resiak declares the state of Haskell packaging in Ubuntu to be "abysmal"
05:31:39 <sieni> @pl \f x y z -> f z x y
05:31:39 <lambdabot> (flip .) . flip
05:31:46 <ricky_clarkson> As opposed to Scala's '_', or Scheme's <>.  (foldl f <> e) returns a lambda to supply the missing <>.
05:31:48 <sieni> @pl \f x y z -> f y z x
05:31:48 <lambdabot> flip . (flip .)
05:32:20 <quicksilver> ricky_clarkson: this idea is discussed once in a while
05:32:26 <quicksilver> ricky_clarkson: it's not very scalable
05:32:39 <EvilTerran> could we make an operator to approximate that kind of behaviour?
05:33:04 <ricky_clarkson> quicksilver: Why is that?
05:33:55 <EvilTerran> (f <> x) y = f y x, say
05:34:00 <dcoutts> resiak: yes, I've observed that. Do you know any reason why that might be?
05:34:14 <quicksilver> ricky_clarkson: http://www.haskell.org/pipermail/haskell-cafe/2007-July/027848.html
05:34:18 <lambdabot> Title: [Haskell-cafe] Haskell's "partial application" (not currying!) versus Business O ..., http://tinyurl.com/32bckl
05:34:19 <quicksilver> ricky_clarkson: see also conor's reply
05:34:25 <resiak> dcoutts: it's probably because they just grab debian unstable's packages at a random time and shove them in their repo
05:34:33 <resiak> dcoutts: no-one seems to actually maintain haskell stuff in Ubuntu
05:35:04 <resiak> in other news, installing -doc packages doesn't work: haddock can't read the .haddock file.  probably for a similar reason.
05:35:06 <EvilTerran> if you made it left-associative, then (f <> x <> y) z = f z x y, so you could skip over multiple parameters
05:35:11 * osfameron is surprised more haskellers aren't on ubuntu
05:35:28 <quicksilver> osfameron: ubuntu is swahili for 'can't install debian'
05:35:35 <quicksilver> osfameron: most haskellers can, in fact, install debian :)
05:35:53 <quicksilver> (most haskellers which want to use linux at all, I suppose I mean)
05:36:15 <osfameron> quicksilver: heh.  I'm the sort of ignorant linuxer that found ubuntu just did enough of what I wanted without lots of faffing
05:36:38 <EvilTerran> you could maybe have (f <><> x) y z = f y z x, too, although i haven't worked out the behaviour under associativity etc
05:36:43 <osfameron> quicksilver: I got debian to install on laptop and desktop, but would have had to faff about with monitor and other hardware things, all of which I really really hate doing
05:36:52 <Cale> Actually, Ubuntu is really nice. I ran debian for 5 years, which should be long enough to give you some idea that I can install and run it :)
05:37:00 <EvilTerran> or there may be some more primative operator that could do that job, maybe in conjunction with <>
05:37:01 <quicksilver> I was joking :)
05:37:29 <quicksilver> I mean, have have a mac laptop mosltly because I'm too lazy to spend the time that getting kernel drivers talking to laptop hardware normally requires.
05:37:34 <quicksilver> that's even worse :P
05:37:37 <resiak> Cale: the state of some packages in universe is terrible, though
05:38:22 <ricky_clarkson> quicksilver: Interesting, but I can't see why it's not scalable, from that.
05:38:22 <Cale> Everything's working reasonably well for me :)
05:39:01 <quicksilver> ricky_clarkson: nested subexpressions and using more than once
05:39:06 <quicksilver> ricky_clarkson: is the point.
05:39:22 <quicksilver> ricky_clarkson: as conor's reply shows, if you adopt reasonable conventions you can cope with a large class of cases
05:39:24 <ricky_clarkson> quicksilver: I don't get the semantics for nesting.  Using more than one seems straight-forward.
05:39:36 <quicksilver> ricky_clarkson: not more than one. More then *once*
05:39:52 <quicksilver> ricky_clarkson: how do you represent \x y -> x * (y + x) ?
05:40:15 <ricky_clarkson> I wouldn't bother. ;)
05:40:28 <ricky_clarkson> If pushed I'd suggest some kind of \1 syntax, like in regexes.
05:40:38 <quicksilver> right
05:40:46 <quicksilver> but isn't \1 a bit like "x" ?
05:40:54 <quicksilver> and that takes us back to lambda abstractions :)
05:41:00 <ricky_clarkson> Yes, hence "I wouldn't bother". ;)
05:41:08 <quicksilver> if you're pushed, you end up reinventing exactly what lambda abstractions are.
05:41:31 <quicksilver> ricky_clarkson: as for the nesting one, consider this:
05:41:37 <quicksilver> map (1+?) [1,2,3,4]
05:41:40 <quicksilver> ok, that's a start?
05:41:51 <quicksilver> now I want to abstract that whole thing by the last element, the 4
05:41:53 <ricky_clarkson> If you ever have to explicitly type <> it gets ugly.  I've written the following in Scala before:
05:41:59 <quicksilver> map (1+?) [1,2,3,?]
05:42:01 <ricky_clarkson> (_: Int)+(_: Int)
05:42:12 <quicksilver> ^^ how do I make it clear that the two ?s are at 'different levels'
05:42:45 <resiak> Cale: on gusty, at least, libghc6-haskelldb-dev has a hard dependency on ghc < 6.6, making it uninstallable.
05:42:56 <ricky_clarkson> quicksilver: I don't know why you need to.
05:43:13 <quicksilver> ricky_clarkson: because I'm trying to give a function argument to map
05:43:19 <quicksilver> not a number
05:43:19 <ricky_clarkson> seems that should return a \x y -> map (1+x) [1,2,3,y]
05:43:26 <quicksilver> that's not what I want, though
05:43:37 <quicksilver> I want \y -> map (\x -> 1+x) [1,2,3,y]
05:44:40 <ricky_clarkson> Oh, then the ? in (1+?) seems to be parsed in a different context to [1,2,3,?].
05:44:51 <quicksilver> yes
05:44:54 <ricky_clarkson> (sorry for misreading just now)
05:44:57 <Cale> ricky_clarkson: this is the problem, there's no way to tell :)
05:45:00 <quicksilver> that's the root of the problem
05:45:16 <quicksilver> so, you have to somehow indicate the "scope of" the ?
05:45:31 <quicksilver> Conor suggests, in his reply to my message, a special bracket like {} for it.
05:45:31 <ricky_clarkson> You mean you need to know whether to expect a function or a value before you can scope the "?"?
05:45:42 <quicksilver> ricky_clarkson: that's not what I meant, no.
05:45:55 <quicksilver> ricky_clarkson: you could hack it into the type inferrer but that would be *very* painful
05:46:09 <quicksilver> my suggestion is that you always want to know what the scope is, before you start inferring types.
05:46:14 <ricky_clarkson> Then I will read those emails again, more slowly.
05:46:16 <quicksilver> ;)
05:46:25 <Cale> From the lengthy discussions about features of this sort on the mailing lists in the past, I'm pretty convinced that anything more powerful than basic operator sections is pretty much going to be horribly confusing.
05:46:36 <EvilTerran> how about scoping ?s to the innermost \?
05:46:44 <EvilTerran> and making (\-> ...) valid syntax
05:47:04 <quicksilver> EvilTerran: that works fine, but what have you really gained over full lambda notation then?
05:47:08 <Cale> Seriously, at that point, would it kill you to use x rather than ?
05:47:19 <EvilTerran> well, if you have a lot of ?s...
05:47:21 <quicksilver> (\-> x+?) is this so much better than (\y->x+y)
05:47:30 <EvilTerran> okay, how about (\ x+?)?
05:47:52 <ricky_clarkson> It seems a goal is point-free without flip.
05:47:59 <EvilTerran> any ambiguities over what \ a -> goes with could be easily resolved with brackets, if there were any
05:48:29 <quicksilver> ricky_clarkson: but surely the ? are points, aren't they?
05:48:33 <quicksilver> they look like points to me...
05:50:35 <ricky_clarkson> I'll rephrase.  Lambdas without repetition, without flip.
05:50:50 <osfameron> yuck, flip
05:51:06 <osfameron> isn't getting rid of repetition what arrows abstract?
05:51:13 <osfameron> (if you mean repetition of points)
05:51:54 <ricky_clarkson> Ok, show me x*y*10+x*x without repeating x?  (I have not learned arrows yet)
05:55:08 <quicksilver> @pl \x y -> x*y*10 + x*x
05:55:08 <lambdabot> ap (flip . ((+) .) . flip flip 10 . ((*) .) . (*)) (join (*))
05:55:50 <opqdonut> > let y=2; x=3 in liftM2 (+) (join (*)) ((y*).(10*)) $ x
05:55:52 <lambdabot>  69
05:55:55 <opqdonut> there ya go
05:56:13 <osfameron> oh bejaysis
05:56:16 <EvilTerran> @pl \y -> liftM2 (+) (^2) ((*10)(y*))
05:56:17 <lambdabot> liftM2 (+) (^ 2) . (10 *) . (*)
05:56:30 <EvilTerran> better?
05:56:47 <EvilTerran> er, wait
05:56:55 <EvilTerran> @pl \y -> liftM2 (+) (^2) ((10*).(y*))
05:56:55 <lambdabot> liftM2 (+) (^ 2) . ((10 *) .) . (*)
05:57:05 <EvilTerran> @pl \y -> liftM2 (+) (^2) (((10*y)*))
05:57:05 <lambdabot> liftM2 (+) (^ 2) . (*) . (10 *)
05:57:27 <osfameron> and not an arrow or a flip in sight
05:57:40 <EvilTerran> just a little abuse of reader
05:57:57 <osfameron> reader?!
05:58:10 * osfameron swoons
05:58:11 <EvilTerran> liftM2 is in the reader monad
05:58:19 <opqdonut> yep
05:58:43 <opqdonut> note: that's the same as i had earlier
05:58:48 <osfameron> where did the reader monad come from?
05:58:55 <quicksilver> osfameron: functions
05:58:55 <EvilTerran> liftM2 f g h x = f (g x) (h x)
05:59:02 <quicksilver> osfameron: functions are the reader monad
05:59:06 <EvilTerran> Reader r a = r -> a
05:59:10 <osfameron> quicksilver: oh!
05:59:25 <osfameron> quicksilver: this is like Monsieur Jourdain learning that he knows how to speak prose...
06:00:14 <quicksilver> > liftM2 (++) (",bar"++) (++"baz") "foo"
06:00:22 <lambdabot>  ",barfoofoobaz"
06:00:30 <quicksilver> osfameron: that may or may not help :)
06:00:48 <quicksilver> osfameron: liftM2 in the reader (function) monad applies two functions to the same value
06:01:00 <quicksilver> osfameron: and then combines the two results with the binary function you supplied
06:04:55 <osfameron> quicksilver: ah, ok.  that seems to make some sense. I'd have to play with it more
06:15:21 <roconnor> @pl \x y => (imp (Qle x y))
06:15:21 <lambdabot> (line 1, column 6):
06:15:22 <lambdabot> unexpected "="
06:15:22 <lambdabot> expecting pattern or "->"
06:15:26 <roconnor> @pl \x y -> (imp (Qle x y))
06:15:26 <lambdabot> (imp .) . Qle
06:18:44 <harlekin> dons: ping
06:25:38 <hpaste>  Orchid pasted "So elegant... yet so wrong." at http://hpaste.org/4044
06:27:19 <hpaste>  Orchid annotated "So elegant... yet so wrong." with "Solution #1" at http://hpaste.org/4044#a1
06:29:04 <hpaste>  Orchid annotated "So elegant... yet so wrong." with "Solution #2" at http://hpaste.org/4044#a2
06:30:07 <quicksilver> :t Control.Exception.bracket
06:30:14 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:31:59 <hpaste>  quicksilver annotated "So elegant... yet so wrong." with "less ugly?" at http://hpaste.org/4044#a3
06:36:29 <hpaste>  quicksilver annotated "So elegant... yet so wrong." with "(no title)" at http://hpaste.org/4044#a4
06:37:22 <hpaste>  quicksilver annotated "So elegant... yet so wrong." with "(no title)" at http://hpaste.org/4044#a5
06:44:37 <hpaste>  oerjan annotated "So elegant... yet so wrong." with "perhaps this?" at http://hpaste.org/4044#a6
06:49:03 <hpaste>  tphyahoo-haskel pasted "stupid (probably) syntax error in otherwise clause, can someone tell me what's wrong?" at http://hpaste.org/4045
06:51:17 <sorear> tphyahoo-haskell: Where scopes over guards, so it has to be last (and what it defines are visible in *all* the guarded bodies)
06:54:33 <hpaste>  tphyahoo-haskel annotated "stupid (probably) syntax error in otherwise clause, can someone tell me what's wrong?" with "syntax error caused by where clause... but I don't know why." at http://hpaste.org/4045#a1
06:55:28 <hpaste>  Orchid annotated "stupid (probably) syntax error in otherwise clause, can someone tell me what's wrong?" with "Where?" at http://hpaste.org/4045#a2
06:55:46 <sorear> @seen tphyahoo-haskell
06:55:46 <lambdabot> tphyahoo-haskell is in #haskell. I don't know when tphyahoo-haskell last spoke.
06:56:43 <hpaste>  sorear annotated "stupid (probably) syntax error in otherwise clause, can someone tell me what's wrong?" with "Where are *you* reading?" at http://hpaste.org/4045#a3
06:59:59 <hpaste>  tphyahoo-haskel annotated "stupid (probably) syntax error in otherwise clause, can someone tell me what's wrong?" with "seems you're not allowed to use a where clause on the right side of an individual pattern guard, onl" at http://hpaste.org/4045#a4
07:00:32 <tphyahoo-haskell> only at the end, after all the pattern guards.
07:00:37 <tphyahoo-haskell> (hpaste cut me off)
07:02:44 <tphyahoo-haskell> sorear: I missed your explanation, I'm reading #haskell. sorry.
07:03:03 <sorear> oh. sorry
07:21:01 <phlpp> hi
07:33:11 <noecksit> hello, how would it be possible to put a debugging print statement inside of a function?
07:33:29 <oerjan> :t Debug.Trace.trace
07:33:31 <lambdabot> forall a. String -> a -> a
07:33:43 <alexj> @seen igloo
07:33:43 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 1h 2m 27s ago.
07:34:07 <noecksit> oerjan: so tracing it would be the only way?
07:35:58 <oerjan> um, trace _is_ a debugging print function
07:36:16 <byorgey> noecksit: no, trace does exactly what you want.  wherever you want to print something out, you replace x (say) with 'trace "foo" x'
07:36:28 <quicksilver> noecksit: it's not necessarily a great way to debug a lazy language, though.
07:36:37 <byorgey> hi phlpp
07:36:37 <quicksilver> I must admit I've never used it.
07:36:42 <quicksilver> (maybe that says more about me)
07:38:36 <noecksit> how would i have access to trace, through "import Debug.Trace.trace"?
07:38:55 <pejo> quicksilver, how do you debug your programs?
07:39:20 <quicksilver> noecksit: import Debug.Trace
07:39:23 <quicksilver> pejo: in ghci
07:39:32 <quicksilver> pejo: I type a function and see if it does what I wanted
07:39:38 <quicksilver> if it doesn't, I try a smaller example.
07:39:44 <quicksilver> I find this much more efficient.
07:42:16 <Saizan> operations like shiftR shouldn't be effected by the machine endian order, right?
07:42:23 <pejo> Well, if it works for you. Even with a small testcase I usually have a hard time to isolate bugs, but that probably says more about me than the debugging techniques.
07:42:32 <Saizan> "affected"
07:42:33 <oerjan> :t shiftR
07:42:34 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:44:22 <quicksilver> Saizan: indeed not.
07:44:32 <dcoutts_> @seen dons
07:44:32 <lambdabot> dons is in #haskell, #ghc and #xmonad. I last heard dons speak 7h 5m 32s ago.
07:44:46 <quicksilver> pejo: well when you have a bug, you must have a function which isn't working rigt. that's how you know it's a bug
07:44:56 <quicksilver> pejo: so I attempt to run all the 'subfunctions' of the function
07:45:02 <quicksilver> and see if they do what I expected...
07:45:03 <quicksilver> etc
07:47:04 <pejo> quicksilver, wouldn't it be nifty to have say.. breakpoints so you know if whatever you're implementing took the wrong turn somewhere? :-)
07:47:54 * osfameron has never had much luck with interactive debuggers (since playing with the Visual Basic one years ago)
07:47:59 <quicksilver> pejo: probably, and the new ghci has breakpoints
07:48:06 <quicksilver> pejo: btu I've never felt the lack...
07:48:28 <quicksilver> I do sometimes add putStrLns into code which is in IO anyway
07:48:37 <quicksilver> since it feels appropriate there
07:48:49 <quicksilver> but I've never felt the need for putStrLns in pure code, a.k.a. trace
07:48:50 <pejo> quicksilver, nods, I'm eager to test 6.8 - lots of very interesting improvements.
07:49:01 <quicksilver> I guess my pure functions normally have obvious specifications
07:49:08 <quicksilver> so it's rather easy to test them
07:54:10 <wmind> is it ok to be in both, sml and haskell?
07:54:36 <wmind> or will people just ignore me/make fun me
07:55:04 <Tobsan> i would say nobody cares :P
07:55:17 <wmind> :)
07:55:22 <quicksilver> people are unlikely to even notice, unless you point it out
07:55:24 <osfameron> wmind: I think knowing other languages is usually considered a good thing
07:55:38 <Tobsan> indeed it is
07:55:40 <quicksilver> I should point out that sml sux0rs while haskell r0x0rs, though.
07:55:41 <wmind> osfameron:  you should try mentioning basic
07:55:54 <osfameron> wmind: hey, all the cool kids use Visual Basic these days :-)
07:56:02 <wmind> and smoke weed
07:56:03 <wmind> ;)
07:56:05 <osfameron> (Tang, Meijer, er, well, that's it actually, but pretty cool)
07:56:24 <quicksilver> Tang uses VB?
07:56:29 <quicksilver> I feel betrayed!
07:56:47 <osfameron> quicksilver: probably not that mcuh.  But iirc she had a talk on how it was actually surprisingly cool
07:57:06 * quicksilver mutters something about making deals with the devil
07:58:08 <noteventime> I still don't get why people use VB.net, how is it any different from using, for example, python with glade and pygtk?
07:58:16 <osfameron> quicksilver: http://use.perl.org/~autrijus/journal/27416 mentions "VB Rocketh"
07:58:17 <lambdabot> Title: Journal of autrijus (1505)
07:58:53 <osfameron> but I can't find the slides anymore
07:58:54 <sorear> 'autrijus'?
07:59:03 <osfameron> Audrey's old name
07:59:06 <sorear> yeah
07:59:13 <sorear> just... noticing
07:59:40 <sorear> maybe (s)he was so embarrased about using VB that (s)he had to change his name :P
08:04:22 <quicksilver> noteventime: the key differences would be windows API support and a powerful bundled API
08:04:40 <quicksilver> and a million 'learn VB in 35 seconds' books, I guess
08:04:47 <quicksilver> all with brightly coloured covers and CDs in the back cover
08:04:52 <noteventime> Haha
08:05:07 <noteventime> Is windows API support even a positive thing?
08:06:31 <quicksilver> noteventime: for me, isn't a non-thing. It literally makes no diffrence, because I wouldn't use it.
08:06:40 <quicksilver> noteventime: for the people who use it, presumablye, it's a positive.
08:06:46 <noteventime> :-)
08:08:46 <osfameron> if you need to speak to .Net APIs then I can imagine VB.Net being great (like VB6 was basically a good way to speak to COM)
08:09:11 <quicksilver> I can't imagine preferring it to C#
08:09:21 <quicksilver> but then, I can't really imagine using it at all :)
08:09:30 <osfameron> but VB.Net really isn't the same as VB6.  It has Linq and lots of functional goodness in it
08:10:02 <noteventime> Both C# and F# seem to be better alternatives
08:11:05 <RayNbow> didn't some Dutch guy called Erik Meijer put some functional influence in VB9? :p
08:27:28 <zmonk> suppose I have two tree data types:
08:27:31 <zmonk> data T1 a = Nil1 | Node1 a (T1 a)
08:27:31 <zmonk> data T2 a b = Nil2 | Node2 a b (T2 a b) (T2 a b)
08:27:31 <zmonk>  
08:28:06 <oerjan> the first one looks more like a list
08:28:10 <zmonk> now I want a typeclass that says that I can do an in-order traversal of the nodes in any tree:
08:28:32 <quicksilver> zmonk: Foldable says that, in a way
08:28:35 <idnar> a unary tree!
08:28:40 <oerjan> Data.Traverse
08:28:46 <idnar> heh
08:28:47 <zmonk> oerjan: yes, no matter, the point is that one has 2 params, and one only one
08:28:47 <oerjan> er, Traversable
08:28:48 <quicksilver> zmonk: at least, Foldable says there is a traversal
08:28:54 <zmonk> class T t where
08:28:54 <zmonk>     preorder :: t a -> [a]
08:28:54 <zmonk>  
08:29:03 <quicksilver> it doesn't say that ti's in-order particuarly
08:29:14 <quicksilver> zmonk: yes, that's equivalent to foldable
08:29:15 <zmonk> now say that in an in-order traversal of "T2" trees, I don't care about the "b" elements
08:29:20 <quicksilver> (although this may not be obvious)
08:29:35 <zmonk> but how do I write the instance declaration for T2 ?
08:29:40 <oerjan> i'd say Foldable _defines_ the order
08:29:40 <zmonk> instance T (T2 a) where
08:29:40 <zmonk>     preorder = t2preorder
08:29:40 <zmonk>  
08:29:51 <quicksilver> zmonk: you wrote T2 wrong
08:30:00 <quicksilver> zmonk: you either need T2 b a
08:30:08 <quicksilver> zmonk: or you need a newtype which reverses the params
08:30:23 <zmonk> but it's not possible from the given types?
08:30:34 <quicksilver> zmonk: not without a newtype, no
08:31:00 <zmonk> how would that look? I than have another type, T3, and for that I can write the instance declaration?
08:31:20 <quicksilver> zmonk: newtype T2' b a = T2' (T2 a b)
08:31:31 <quicksilver> instance T (T2' b) where ...
08:31:58 <quicksilver> zmonk: a newtype with the params reversed, basically :)
08:32:16 <zmonk> yeah right; that's a pity however, because I have to change the type declaration for already defined functions, if any.
08:32:49 <quicksilver> I agree
08:35:23 <ddarius> You could probably do something with multiparameter type classes or associated types.
08:35:50 <zmonk> but these are extensions to the typesystem, not standard, right?
08:36:11 <ddarius> Correct.
08:39:09 <zmonk> but haw can we be sure there is no way to state this in the standard? Where is the rule that states that all instances must be of the same "order" of polymorphism? (after all, that's the problem right, that T1 only has order 1, and T2 "two-dimensional" polymorphism?)
08:39:10 <ski> newtype Flip f b a = MkF {unF :: f a b}
08:39:27 <ski> (ouch .. blinkenlichts)
08:41:20 <Brian``> :t Identity
08:41:22 <lambdabot> forall a. a -> Identity a
08:41:58 <alexj> @seen igloo
08:41:58 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 2h 10m 42s ago.
08:42:13 <mauke> @shot web
08:42:13 <lambdabot> "web"
08:42:24 <Brian``> @srd Identity
08:42:24 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
08:42:35 <Brian``> @src Identity
08:42:35 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
08:42:53 <Brian``> wow! how did lambdabot know I had a typo when I typed @srd?
08:43:06 <mauke> it can read your mind over IRC
08:43:06 <quicksilver> it has automatically spelling correction
08:43:13 <Brian``> @sr Identity
08:43:13 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
08:43:14 <zmonk> argh I got dropped!
08:43:14 <quicksilver> occasionally used for humuours effect
08:43:18 <ski> zmonk : "all instances must be of the same \"order\" of polymorphism?"
08:43:19 <Brian``> that's cool
08:43:22 <quicksilver> @losers
08:43:22 <lambdabot> Maximum users seen in #haskell: 418, currently: 377 (90.2%), active: 10 (2.7%)
08:43:28 <zmonk> so that was the problem, right, the different order of polymorphism?
08:43:31 <Brian``> @seen Brian`
08:43:32 <lambdabot> I saw Brian` leaving #haskell 35m 9s ago, and .
08:43:33 <ddarius> zmonk: No
08:43:38 <Brian``> @seen Brian``
08:43:38 <lambdabot> You are in #haskell. I last heard you speak just now.
08:43:40 <zmonk> instead?
08:43:43 <quicksilver> zmonk: it's not about that so much as partial type application
08:43:50 <mauke> @shapr mauke
08:43:50 * lambdabot submits mauke's email address to a dozen spam lists
08:43:56 <Saizan> zmonk: i think you mean kind
08:43:58 <quicksilver> we don't have true type-level lambdas
08:44:19 <ddarius> quicksilver: We don't have fake ones either
08:44:19 <Saizan> @kind Int
08:44:20 <lambdabot> *
08:44:23 <zmonk> quicksilver: yes, with that it would be trivial: flip ... etc.
08:44:30 <Saizan> @kind Maybe
08:44:30 <lambdabot> * -> *
08:44:38 <mauke> ddarius: we don't?
08:44:46 <quicksilver> ddarius: well stuff like the Flip trick is a bit like a tpe level lambda
08:44:51 <Brian``> which module does Identity function reside in?
08:44:55 <quicksilver> at least, that's what I meant
08:44:59 <ski> zmonk : the problem is that the argument of `T' must have kind `* -> *', and you have `T2 :: * -> * -> *', so you can make `T2 a :: * -> *', but `(\a -> T2 a b) :: * -> *', which is what you want, is not allowed
08:44:59 <quicksilver> @index Identity
08:44:59 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
08:45:03 <quicksilver> Brian``: ^^
08:45:07 <Brian``> thanks quicksilver :)
08:45:08 <zmonk> but still, the "dimension" matters, because in this case, it's clear that the "b" parameter of T2 doesn't matter!
08:45:11 <Brian``> hey quicksilver
08:45:12 <Brian``> are you korean?
08:45:16 <quicksilver> no
08:45:18 <quicksilver> should I be?
08:45:31 <Brian``> oh nvm i was confused with another guy
08:45:33 <Brian``> gimmesilver
08:45:34 <Brian``> lol
08:45:38 <osfameron> quicksilver: if the answer is yes, what will you do?
08:45:44 <Brian``> that guy had some haskell blog in korean.. that's why
08:45:52 <ddarius> zmonk: As I said, no, the kind doesn't matter.
08:46:29 <quicksilver> osfameron: feel bad, I guess
08:46:56 <zmonk> ddarius: the kind is *all* that matters - what else would make it fail? ski explained it correctly, I think.
08:47:29 <ski> zmonk : you want `preorder :: T2 a b -> [a]', how are you going to write that of the form `preorder :: t a -> [a]', for some `t'
08:47:30 <ddarius> zmonk: Without the kind being greater than two the issue doesn't come up, but the issue is the inability to flip arguments not "different" kinds.
08:48:06 <ski> zmonk : in the case you'd instead wanted `preorder :: T2 b a -> [a]', we can write that of the form `preorder :: t a -> [a]', by setting `t' to `T2 b'
08:48:56 <zmonk> yes, exactly. but unfortunately, that's not what I want. so yes, we'd need functions on the type level for that.
08:49:04 * quicksilver nods
08:49:19 <quicksilver> you could remove the restriction that it be of the form t a
08:49:21 <quicksilver> and just use
08:49:28 <ski> we have functions on the type-level (namely type constructors)
08:49:36 <quicksilver> class T s t where preorder :: t -> [s]
08:49:51 <ski> possibly with a FD or AT
08:49:53 <quicksilver> possibly with a fundep
08:49:54 <zmonk> quicksilver: very true, but then T1 cannot be an instance
08:49:56 <quicksilver> right
08:50:03 <quicksilver> zmonk: sure it can
08:50:04 <ddarius> zmonk: Yes it could be.
08:50:07 <zmonk> how?
08:50:10 <ddarius> This is what I suggested earlier.
08:50:17 <ski> instance T a (T1 a) where
08:50:20 <puusorsa> is there an easy way to generate a global index for all stuff that has local haddock documentation?  --gen-index looks a bit like it could help
08:50:47 <zmonk> ddarius: sorry I missed that - I'm trying it
08:51:10 <ddarius> zmonk: You didn't miss it.  You asked me if it requires extensions which it does.
08:52:00 <hpaste>  thomas pasted "Don't know how to fix this (possibly incorrect indentation)" at http://hpaste.org/4046
08:52:06 <zmonk> oh that, so yes, quicksilver that needs extensions!
08:52:52 <mauke> who is thomas?
08:53:05 <ski> whoever he is, he's missing an `else'
08:53:12 <mauke> yep
08:53:30 <mauke> and possibly isAlpha
08:53:33 <quicksilver> and do the | need to line up?
08:53:38 <mauke> I don't think so
08:53:45 <quicksilver> no, probably not
08:53:52 <quicksilver> they are delimeters in themselves
08:53:57 <quicksilver> looks nicer if they do, though :)
08:54:15 <ddarius> quicksilver: You know what would look even nicer, not using guards for that
08:54:23 <mauke> > let f x | x < 0 = "foo" | x < 1 = "bar" | True = "baz" in f 42
08:54:24 <lambdabot>  "baz"
08:54:26 * ddarius always hates if b then True else False
08:54:34 <ski> eta-reduce !
08:55:18 <ski> wb zmonk
08:55:22 <vincenz> mauke: s/True/otherwise
08:55:32 <mauke> vincenz: that's not confusing enough
08:55:35 <quicksilver> zmonk: to answer your last point, yes, it needs extensions
08:55:36 <zmonk> ski: what do you mean "wb"?
08:55:40 <quicksilver> welcome back
08:55:59 <zmonk> why did I leave?
08:56:00 <vincenz> warnor bros
08:56:13 <vincenz> zmonk: that's an existential question like "why did the chicken cross the road"
08:56:29 <zmonk> no I mean, what did you see as error message from me?
08:56:35 <zmonk> (I didn't leave intentionally)
08:56:52 <vincenz> 17:55 -!- zmonk [n=user@chello062178240212.3.14.tuwien.teleweb.at] has joined  #haskell
08:56:59 <vincenz> 17:56 < zmonk> no I mean, what did you see as error message from me?
08:57:36 <zmonk> hm, that doesn't explain why the client quit. Well, Emacs isn't what it used to be any more...
08:57:57 <mauke>  -!- .quit zmonk [Remote closed the connection]
08:58:19 <zmonk> mauke: thanks! (strange...)
08:58:37 <puusorsa> .. there is. horrible commandline though
09:01:55 <vincenz> what's the symbol for set-deletion?
09:02:01 <ddarius> Usually \
09:02:04 <ddarius> or -
09:02:14 <ddarius> Or are you asking for the one in Haskell?
09:02:20 <quicksilver> in maths, I've seen \ most often
09:02:27 <vincenz> I mean in latex
09:02:32 <RayNbow> in Haskell it's (\\)
09:02:32 * vincenz is doing some z-specification stuff
09:02:53 <vincenz> quicksilver: you a math-buff?
09:02:54 <phlpp> > let f x | x < 0 = "foo" | x > 1 = "bar" | True = "baz" in f 42
09:02:57 <lambdabot>  "bar"
09:03:10 <quicksilver> vincenz: maybe. Once upona  time. I have a degree in it.
09:03:12 <vincenz> hmm
09:03:16 <vincenz> mind if I bother in #oasis?
09:03:19 <quicksilver> I'm pretty sure there is a latex symbol for set minus
09:03:20 <quicksilver> sure
09:03:30 <quicksilver> which looks like a backslash but has different spacing, basically
09:03:35 <quicksilver> \setminus, perhaps?
09:03:41 <ddarius> 
09:03:45 <ddarius> Yes setminus
09:03:54 <ddarius> At least according to the LaTeX SCIM mode
09:04:06 <mauke> argh.
09:04:15 <mauke> I need a terminal font with all unicode characters
09:04:33 <ddarius> mauke: That came out as something other than \
09:04:47 <ddarius> Oh, I guess it is slightly different looking in my font.
09:05:18 <mauke> it's a black square which means my font doesn't have it
09:08:37 <hpaste>  #haskell annotated "Don't know how to fix this (possibly incorrect indentation)" with "comments" at http://hpaste.org/4046#a1
09:09:55 <ddarius> "When IRC Channels Attack"
09:14:06 <conal> quicksilver: pong
09:14:11 <kaol> would people find functional programming less scary if we called it "value-oriented programming"?
09:14:26 <conal> kaol: i bet they would
09:14:42 <mauke> abstraction-oriented programming!
09:14:53 <conal> and it's a more accurate name.  functional programming is all about values, not all about functions.
09:14:59 <_ry> stupid question: what is a "list comprehension" mean?
09:15:05 <quicksilver> conal: damn. What was I going to ask you?
09:15:13 <mauke> _ry: [ ] with | in it
09:15:16 <conal> :)
09:15:17 <Botje> it's something of the form [ x * 2 | x <- [1..50]
09:15:28 <ddarius> Only with more brackets
09:15:28 <byorgey> _ry: not a stupid question =)
09:15:34 <_ry> ah! okay.
09:15:34 <sieni> kaol: why would that matter? playing word games can only confuse stupid people and I'm not sure if stupid people are needed in the functional programming community
09:15:40 <ski> Functional Programming : Protecting Values from Mutilation !
09:15:40 <byorgey> > [ x * 2 | x <- [1..5] ]
09:15:41 <lambdabot>  [2,4,6,8,10]
09:16:01 <ddarius> Since 1933
09:16:16 <byorgey> > [ (x,y) | x <- [1..6], y <- [3..13], y > 2*x ]
09:16:17 <lambdabot>  [(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13),(2,5)...
09:16:18 <LPhas> >[(a,b) | a <- [1..3], b <- ['a','b','c']]
09:16:28 <ski> ddarius : why ?
09:16:42 <quicksilver> conal: Ah yes. I wanted to talk to you about this time-based animation lark.
09:16:43 <byorgey> LPhas: need a space after the '>'
09:16:50 <LPhas> byorgey: yes :p
09:16:54 <byorgey> LPhas: =)
09:16:55 <quicksilver> conal: I wrote some animation combinators for some stuff I'm writing.
09:16:55 <LPhas> > [(a,b) | a <- [1..3], b <- ['a','b','c']]
09:16:55 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
09:16:57 <ddarius> ski: Why what? (I kind of get your question, just not why it is phrased as "Why?")
09:17:10 <ski> ddarius : what happened 1933 ?
09:17:14 <bakert> what's the best intro to quickcheck?
09:17:16 <quicksilver> conal: there is purely time-based ones, which are simple and elegant, and framerate independent
09:17:26 <_ry> in the list comprehension is the "<-" supposed to be like  in mathematics (read as belongs to)
09:17:32 <ddarius> ski: It's just some random date in the 30's around the time Alonzo made the lambda calculus.
09:17:38 <byorgey> bakert: the original paper on quickcheck is an excellent introduction.
09:17:42 <quicksilver> conal: but sometimes I need stateful ones; things like a particle systems which evolve
09:17:50 <mauke> _ry: yes, more or less
09:17:52 <ski> (ddarius : surely not "The Calculi of Lambda-conversion" (which is sitting in front of me), that's dated 1941)
09:17:54 <quicksilver> conal: I can't work out how to make those resolution independent
09:17:55 <ddarius> _ry: Yes, the term comes from set comprehension
09:17:57 <mauke> but it's guaranteed to run in order
09:18:00 <byorgey> @where quickcheck
09:18:00 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
09:18:03 <quicksilver> conal: because they evolve by one 'tick' each time you ask them to.
09:18:09 <byorgey> bakert: the paper is linked from there, I think ^^^
09:18:12 <ddarius> ski: That didn't come out of nowhere.
09:18:16 <_ry> this is not the same "<-" as in do blocks?
09:18:19 <ddarius> _ry:
09:18:24 <conal> quicksilver: can you describe them via differential equations?
09:18:26 <ddarius> _ry: 
09:18:32 <ddarius> _ry: Actually...
09:18:34 <mauke> _ry: the "<-" in do block is an extension of that idea
09:18:34 <conal> in other words, continuous state
09:18:43 <quicksilver> conal: not easily with the abstration I'm using
09:18:45 <quicksilver> conal: maybe I should
09:18:50 <ski> (ddarius : i supposed so .. hence i wondered what relevant came before)
09:19:01 <quicksilver> conal: but sometimes discontinuous things happen
09:19:07 <mauke> you can always translate a list comprehension to do-notation
09:19:12 <ddarius> ski: I thought there was something in the 30's but I'd have to looke
09:19:17 <_ry> mauke: ah okay.
09:19:19 <quicksilver> conal: like: on the first "Tick" after z>3, this particle turns into this kind of thing
09:19:51 <conal> quicksilver: how about simple after z>3 and drop the tick.
09:19:57 <ddarius> In fact the translation is almost trivial.
09:20:02 <quicksilver> conal: hmm
09:20:29 <quicksilver> conal: there is logic to that
09:20:37 <conal> quicksilver: simpler spec & more accurate results.
09:20:39 <quicksilver> conal: also, some of these things have randomness too
09:21:06 * vincenz proposes #oasis for a less spammy discussion channel
09:21:09 * vincenz whistles innocently
09:21:17 <ddarius> There is some calculus stuff for discontinuous functions; I forgot the name of it.
09:21:24 <conal> quicksilver: for instance?
09:21:31 <ddarius> I wonder how that would work out.
09:21:34 <quicksilver> conal: I'm concerned that, although it might be a simpler spec, it would be more cumbersome for users of the combinators
09:21:35 <vincenz> quicksilver: you could ntroduce a random stream
09:21:41 <quicksilver> but maybe that means I got the combinators wrong.
09:22:02 <quicksilver> conal: like a particle which, when it explodes, generates a random number of new particles with random velocities.
09:22:17 <vincenz> quicksilver: for random you use a random TV
09:22:20 <vincenz> erm
09:22:21 <vincenz> stream
09:22:23 <vincenz> s/TV/stream
09:22:45 <vincenz> so random velocity is not such an issue, the random number of particles..
09:23:13 <conal> quicksilver: i like vincenz's suggestion, though i'd go for a random flow (continuous)
09:23:31 * quicksilver nods
09:23:45 <vincenz> This reminds me a lot of flapjax
09:23:51 <quicksilver> I will think further.
09:23:52 <vincenz> basically everything is a stream (user inputs too)
09:23:53 <conal> quicksilver: have you read the Fran / FRP papers?
09:24:01 <quicksilver> conal: yes, but not recently.
09:24:03 <conal> vincenz: discrete or continuous?
09:24:08 <vincenz> conal: I think it's poll-based
09:24:12 <vincenz> underneath
09:24:16 <vincenz> so continuous to the user
09:24:23 <vincenz> like you say
09:24:23 <conal> vincenz: i'm glad.
09:24:26 <vincenz> box.x = mouse.x * 5
09:24:36 <vincenz> and then your little box will move with your mouse
09:25:05 <conal> quicksilver: i'm interested in revisiting & redesigning FRP.  it'd be fun & helpful for me to continue chatting about what you're up to, as your ideas evolve.
09:25:21 <quicksilver> conal: OK, well I have some real work to do for a bit :)
09:25:25 <vincenz> conal: are you continuous or discrete based?
09:25:28 <quicksilver> conal: I'll catch you again when I have a chance.
09:25:37 <quicksilver> conal: and perhaps show you some code so you can see what I'm talking about
09:25:39 <conal> vincenz: neat.  i'm pretty sure flapjax descended from fran
09:25:49 <conal> vincenz: continuous, always!
09:25:55 <conal> quicksilver: do
09:26:04 <vincenz> conal: is 'event-based' processing possible in such a systm?
09:26:08 <vincenz> conal: if every event is meaningful
09:26:14 <vincenz> (think a videostream with motion compensation)
09:26:16 <conal> vincenz: certainly
09:26:19 <vincenz> (or a network protocol)
09:26:52 <conal> continuous time, with not-necessarily-continuous functions
09:27:04 <hpaste>  puusorsa pasted "script to generate index for all local haddock docs" at http://hpaste.org/4047
09:27:09 <vincenz> conal: so how do you deal with stream 'b' depending on stream 'a' but not generating events as often?
09:27:33 <vincenz> And I guess in a sense this combinator approach is specifying the data-flow?
09:27:36 <conal> vincenz, quicksilver: see http://conal.net/Fran/tutorial.htm for a feel of Fran programming.
09:27:36 <lambdabot> Title: Composing Reactive Animations
09:27:49 <conal> vincenz: yes.  but with continuous time.
09:27:50 <pitecus>  Language.Haskell.Parser.parseModule returns ParseResult HsModule, but there seems to be no function to get the the HsModule from the ParseResult
09:27:54 <puusorsa> dunno if there was a better way, but that does the job and at least for me is a big help
09:28:22 <vincenz> conal: since there is no notion of time, I do not see how you deal with different rates of certain streams.
09:28:30 <vincenz> someone asked me about this stuff and I wasn't able to answer him there
09:28:44 <conal> vincenz: no notion of time where?
09:28:58 <pitecus> forget it, i was misspelling the constructor name
09:29:00 <vincenz> well that's under the hood of your values
09:29:01 <conal> vincenz: FRP has continuous flows and discrete event streams.  two algebras nicely related
09:29:16 <vincenz> perhaps I miss the knowledge of the discrete one then
09:29:48 <conal> vincenz: what's an example of the two different rates?  so i know whether it's an event thing or a flow thing.
09:30:05 <vincenz> assume stream 'A' is input (network packets), and stream 'B' is basically data-packets (By glueing some network packets together after dropping headers)
09:30:16 <vincenz> B will flow slower than A
09:31:17 <vincenz> now if you have a stream 'C' that for some reason depends both on the data packets (B) as well as the headers (A) (e.g: you want to tag your data with their original location) how do yo correlate two streams in one combinator that flow at different speeds)
09:31:18 <conal> vincenz: got it.  it's an event (discrete) thing.  there are simple combinators for mapping, filtering and accumulation.  filtering drops event occurrences.
09:31:30 <vincenz> conal: rght but you lose notion of time
09:31:38 <vincenz> if now I have stream C, ..
09:32:04 <vincenz> how do you relate two speeds of flow?
09:32:30 <vincenz> accumulation is more than just a fold I presume?
09:32:33 <conal> vincenz: i'd introduce a flow -- a step function.  and then snapshot it according to an event stream.
09:32:53 <conal> vincenz: accumulation is a scan
09:32:59 <vincenz> hmm
09:33:02 <vincenz> so this is not possible
09:33:12 <conal> what's not possible?
09:33:16 <vincenz> [1,2,3,4,5,6,7,8,9] - FOO -> [[1,2,3], [4,5,6,7], [8,9]]
09:33:18 <vincenz> ?
09:33:55 <vincenz> or, if you want
09:34:12 <vincenz> [1,2,3,4,5,6,7,8,9] - FOO -> [1+2+3, 4+5+6+7, 8+9]
09:34:24 <conal> vincenz: both examples are doable.
09:34:30 <MisterN> shouldn't this return an infinite list of zeros? let s ~(x : y) = (x : y); l = l in map (\_ -> 0) (s l)
09:34:44 <vincenz> so it's more than just a scanl?
09:35:02 <mauke> I thought let patterns were alway lazy
09:35:04 <conal> vincenz: yes.  scanl is just one tool
09:35:07 <vincenz> .me nods
09:35:08 <vincenz> ok
09:35:19 <ddarius> mauke: They are but that is a parameter.
09:35:19 <vincenz> Thanks for the explanation
09:35:21 <MisterN> mauke: dunno, it doesn't return what i expect anyways.
09:35:28 <mauke> oh, d'oh
09:35:30 <ddarius> MisterN: And no.
09:35:38 <conal> vincenz: sure
09:35:39 <MisterN> what did i get wrong?
09:35:42 <mauke> does that even typecheck?
09:35:46 <MisterN> yeah
09:35:52 <ddarius> Well, give me a sec.
09:35:56 <MisterN> it returns [0Stack overflow]
09:36:03 <ski> mauke : mayhaps you wanted `s ~(x : y) = x : s y' ??
09:36:10 <mauke> makes sense, it loops in l
09:36:22 <ski> s/mauke/MisterN/
09:36:27 <ddarius> MisterN: When map looks at y it will force it.
09:36:28 <mauke> s is a fake identity
09:36:32 <MisterN> ski: ah, sure
09:36:44 <MisterN> thank you
09:36:53 <ski> `s' was a partial identity
09:37:23 <ski> hm
09:37:26 <ddarius> Using the recursive definition of s should work.
09:37:33 <MisterN>  let s ~(x : y) = (x : s y); l = l in map (\_ -> 0) (s l)
09:37:36 <MisterN> works great
09:37:50 <ski> actually, not partial itself
09:37:54 <ddarius> Of course, fix (0:) would be a much better way of getting that...
09:38:10 <MisterN> yeah, but i wanted to check out partial matching :)
09:38:19 <mauke> > map (const 0) (liftM2 (:) head tail [])
09:38:20 <lambdabot>  Exception: Prelude.tail: empty list
09:38:44 <mauke> > map (const 0) (fix (\f -> liftM2 (:) head (f . tail)) [])
09:38:44 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:39:12 <ski> MisterN : with your old `s', you basically had `s (fix _|_)  =  s _|_  =  _|_ : _|_' which is not the same as `repeat _|_'
09:39:23 <MisterN> ski: yeah, i know :)
09:39:36 <MisterN> well, i did not know. but now i do
09:39:40 <ski> (:
09:40:14 <MisterN> s lacks a match for [] :D
09:40:23 <bakert> hmm ... broken link on http://haskell.org/haskellwiki/Introduction_to_QuickCheck to library docs.  is Test.QuickCheck being moved to Debug.QuickCheck or is that the old name?
09:40:37 <bakert> not sure where to correct the link to point at
09:40:39 <ski> MisterN : it cannot have one, if to use lazy matching
09:40:55 <MisterN> ooh
09:41:06 <MisterN> so s [] = s _|_?
09:41:36 <mauke> that code works with any list as long as it has the right type
09:41:39 <mauke> which is [a]
09:41:54 <mauke> s never really looks at the list elements
09:41:59 <ski> s []  =  let x:y = [] in x : s y  =  _|_ : s _|_  =  _|_ : _|_ : s _|_  =  ...
09:43:24 <MisterN> so lazy pattern matching returns _|_ if it can't match at all?
09:43:35 <ddarius> MisterN: No.
09:43:37 <ski> it just defers matching
09:44:02 <ddarius> > let f ~(Just x) = 3 in f Nothing
09:44:03 <lambdabot>  3
09:44:37 <MisterN> > > let f ~(Just x) = x in f Nothing
09:44:37 <lambdabot>   parse error on input `>'
09:44:39 <MisterN> > let f ~(Just x) = x in f Nothing
09:44:40 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
09:45:10 <ski> if the lazy pattern `~(x : xs)' is matched against some value, say `v', then the pattern-matching succeeds immediately, binding `x' and `xs' to computations, that when forced, will try to match `v' against `x : xs' and extract the appropriate part
09:45:11 <newsham> happy thanksgiving everyone.
09:45:40 <thoughtpolice> newsham: indeedy. :)
09:46:26 <MisterN> ski: and because map (\_ -> 0) doesn't check, it just assumes an infinite list?
09:46:41 <ski> `map' does check the list skeleton
09:46:55 <MisterN> which is given because of s
09:47:16 <ski> but, (the revised) `s' unconditionally returns an infinite list, so `map' traverses this list just fine
09:47:21 <ski> *nod*
09:47:52 <davidL> hmmm, what version of happy do I need to build to build ghc-6.8.1? Preprocessing library haskell-src-1.0.1.1...
09:47:55 <davidL> Setup: The program happy is required but it could not be found
09:48:31 <davidL> I have happy-1.16
09:49:44 <bakert> how can i express that my list of type [(x, Integer)] may only have one entry for any given x?  use a different data structure?
09:49:58 <byorgey> bakert: use a Map.
09:50:05 <bakert> yeah i thought you were going to say that :(
09:50:13 <byorgey> bakert: what's so :( about that?
09:50:46 <byorgey> > M.fromList [("foo", 3), ("bar", 6)]
09:50:48 <lambdabot>  fromList [("bar",6),("foo",3)]
09:50:50 <bakert> i'm not sure really.  i think just because I've changed the representation of this stuff so many times.  hoepfully i am learning
09:50:51 <bakert> :)
09:51:11 <byorgey> > M.fromList [("foo", 3), ("bar", 6), ("foo", 9)]
09:51:11 <lambdabot>  fromList [("bar",6),("foo",9)]
09:51:23 <bakert> yeah i need to use a map
09:51:26 <byorgey> easy as pi!
09:51:26 <bakert> from the beginning
09:51:31 <byorgey> pumpkin pi, of course
09:51:32 <bakert> pi is not easy!
09:51:43 <bakert> 22 / 7 is even quite hard
09:52:06 <byorgey> heh, pie isn't particularly easy either =)
09:52:16 <byorgey> I've always wondered where that expression came from...
09:52:20 <mauke> > 355/113
09:52:20 <bakert> this is quite cool though because it means QuickCheck has pointed out a problem in my code
09:52:22 <lambdabot>  3.1415929203539825
09:52:28 <byorgey> bakert: awesome!
09:52:42 <bakert> falsifiable after 2 tests: [("hello", -1), ("hello", 3)]
09:52:43 <bakert> :)
09:53:00 <bakert> so i will treat it as a victory!
09:53:17 <davidL> this is an odd thing about haskell-src, it needs happy to build but happy is not listed as a dependency--according to the docs, the non-darcs ghc provides a version of happy to build with
09:53:17 <vincenz> bakert: you specify such things in your preconditions
09:53:32 <vincenz> prop x y = foo x y ==> test x y
09:53:36 <bakert> vincenz: you mean in quickCheck?
09:53:38 <vincenz> yah
09:53:43 <vincenz> then of course
09:53:51 <vincenz> all your producers of your data structures
09:53:54 <vincenz> you check this foo property
09:54:09 <vincenz> basically you make it a post-condition of producers, and a pre-condition of consumers
09:54:14 <bakert> i just have Arbitrary and == so far
09:54:15 <vincenz> and specify ths in your testcases
09:54:21 <bakert> but i will get to ==> soon!
09:54:35 <bakert> (after i have rewritten my code to use a map :) )
09:54:59 <vincenz> @quickcheck foo x y = x > 0 && y > 0 ==>  x + y > 0
09:54:59 <lambdabot> Unknown command, try @list
09:55:00 <ski> > (0 :+ (-1)) * log (-1)
09:55:00 <lambdabot>  (-3.141592653589793) :+ -0.0
09:55:03 <vincenz> @check foo x y = x > 0 && y > 0 ==>  x + y > 0
09:55:03 <lambdabot>  Parse error at "=" (column 9)
09:55:13 <vincenz> @check \x y -> x > 0 && y > 0 ==>  x + y > 0
09:55:14 <lambdabot>  Add a type signature
09:55:20 <vincenz> @check \x y -> x > 0 && (y :: Int) > 0 ==>  x + y > 0
09:55:20 <lambdabot>  Arguments exhausted after 299 tests.
09:55:25 <bakert> coolio
09:55:31 <vincenz> well you get the ideae
09:55:33 <vincenz> @check \x y -> x > 0 && (y :: Int) > 0 ==>  x + y > 0
09:55:34 <lambdabot>  Arguments exhausted after 260 tests.
09:56:00 <mauke> @scheck \x y -> x > 0 && (y :: Int) > 0 ==>  x + y > 0
09:56:00 <lambdabot>   Completed 169 test(s) without failure.  But 133 did not meet ==> condition.
09:56:02 <bakert> i need to try and think of things that aren't obviously true about my code :)
09:56:13 <byorgey> > map floor . iterate (recip . ap (-) (fromIntegral . floor)) $ pi
09:56:14 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,3,3,23,1,1,7,4,35,1,1,1,2,3,3,3,3,1,1,14,6,4,...
09:56:31 <ddarius> Hmm, there is a term for the discontinuous calculus pioneered by Olga Oleinik that I can't think of.
09:56:33 <vincenz> what's recip
09:56:38 <vincenz> @type recip
09:56:38 <ddarius> 1/x
09:56:39 <lambdabot> forall a. (Fractional a) => a -> a
09:56:41 <vincenz> oh
09:56:47 <ski> > map recip [1..]
09:56:47 <lambdabot>  [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285...
09:57:04 <bakert> i remember getting a calculator with reciprocal on it when i was 11.  exciting.
09:57:23 <vincenz> heh, the claculator I got excited over was the HP48Gx
09:57:31 <ski> (ddarius : i assume not `difference calculus' ?)
09:57:36 <vincenz> "oh my god, 65k of memory!"
09:57:52 <ddarius> ski: That's not it, I'm pretty sure.
09:58:26 <ddarius> ski: It was more about non-linear (partial) differential equations.  It would involve things like conservation laws and entropy conditions.
09:58:59 <ski> sounds scary
09:59:22 <MisterN> > (let s ~(x : y) = (x : s y); l = l in s l) >> [1,2,3]
09:59:23 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
09:59:24 <ski> (if the inventor was named `Olga', surely it must be !)
09:59:26 <MisterN> yay
09:59:41 <MisterN> partial matching AND monads :D
10:00:32 <xerox> > [(),()..] >> [1,2,3]
10:00:36 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:00:56 <byorgey> what, there's an Enum instance for () ?!
10:01:01 <ski> sure
10:01:02 <Cale> > repeat () >> [1,2,3]
10:01:03 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:01:06 <ski> > [()..()]
10:01:07 <lambdabot>  [()]
10:01:09 <ski> > [(),()..()]
10:01:10 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
10:01:11 <byorgey> > cycle [1,2,3]
10:01:12 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:01:45 <Cale> That enumFromThenTo is a bit questionable.
10:01:51 <sieni> byorgey: makes sense :-)
10:01:58 <ToRA> > fix ((1:) . (2:) . (3:))
10:02:03 <mauke> > [0,0 ..0]
10:02:03 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:02:03 <sieni> no it's not
10:02:05 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:02:18 <MisterN> hey, you're having fun with lists, i see :)
10:02:23 <Spark> > cycle "fail "
10:02:27 <xerox> > fix . (++) $ [1,2,3]
10:02:41 <lambdabot>  "fail fail fail fail fail fail fail fail fail fail fail fail fail fail fail ...
10:02:46 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:03:00 <MisterN> > show fix (1:)
10:03:01 <lambdabot>  Couldn't match expected type `([t1] -> [t1]) -> t'
10:03:07 <sieni> succ "abc"
10:03:08 <MisterN> > show $ fix (1:)
10:03:08 <lambdabot>  "[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:03:17 <sieni> > succ "abc"
10:03:18 <lambdabot>   add an instance declaration for (Enum [Char])
10:03:18 <lambdabot>     In the expression: succ "...
10:03:20 <matthew_-> someone mute Spark. We normally leave him gagged in the office
10:03:22 <sieni> blah
10:03:37 <sieni> > succ 'a'
10:03:37 <lambdabot>  'b'
10:03:44 <davidL> > succ 'z'
10:03:45 <lambdabot>  '{'
10:04:19 <MisterN> > succ ()
10:04:20 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
10:04:52 <mauke> > [minBound .. maxBound] :: [()]
10:04:52 <lambdabot>  [()]
10:04:56 <sieni> I wonder why you couldn't have lexicographic ordering for [Foo] by default if Foo is in Enum
10:05:33 <newsham> are there any articles on "fix" on the hawiki?
10:05:36 <sieni> but it's anyway true that one-element set has a canonical ordering :-)
10:05:40 <ddarius> newsham: Probably
10:05:58 <ToRA> > concat . unfoldr (Just . join (,)) $ [1,2,3]
10:05:59 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:06:50 <MisterN> infinite ways to get a simple infinite list
10:06:51 <Spark> > [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
10:06:51 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:07:00 <Spark> everything is finite
10:07:48 <ToRA> ok last one
10:07:51 <ToRA> > unfoldr (Just . (succ &&& id) . (`mod` 3) . succ ) $ 1
10:07:51 <lambdabot>  [3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1...
10:07:57 <ddarius> > iterate (\x -> x - 2/x) 1
10:07:58 <lambdabot>  [1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0...
10:07:58 <matthew_-> wah!
10:08:08 <ddarius> > iterate (\x -> 0.5*(x - 2/x)) 1
10:08:09 <lambdabot>  [1.0,-0.5,1.75,0.30357142857142855,-3.1423319327731094,-1.252930967222256,0....
10:08:20 <ddarius> > iterate (\x -> x - 0.5*(x - 2/x)) 1
10:08:34 <lambdabot>  [1.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.41421356...
10:08:46 <mcp_> let f s=[Leaf i|i<-[1..2]]++[Node i l r|i<-[1..2],l<-s,r<-s];l=take 102$zip[1..]((f.f.f)[])in take 5[(i,j)|(i,ti)<-l,(j,tj)<-l,ti<tj]
10:09:24 <matthew_-> ahh, the hello world of the functional comunity
10:09:25 <mcp_> creates some trees with nodes and leafs, and compares them (ti<tj). I'd like to know which trees it generates/compares. Where can i add a print there?
10:09:30 <newsham> ?let fac1 r 0 = 1; fac1 r n = n * r (n-1)
10:09:33 <lambdabot> Defined.
10:09:44 <Spark> i like whitespace too
10:09:59 <newsham> > iterate (flip fac1 5) (const (-1))
10:10:00 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t
10:10:00 <lambdabot>     Probabl...
10:10:08 <newsham> > iterate (flip fac1 5) (const (negate 1))
10:10:08 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t
10:10:08 <lambdabot>     Probabl...
10:11:03 <newsham> > (f.f.f.f.f.f) (const (-1)) 5
10:11:03 <lambdabot>   Not in scope: `f'
10:11:11 <newsham> > let fac1 = f in (f.f.f.f.f.f) (const (-1)) 5
10:11:12 <lambdabot>   Not in scope: `f'
10:11:19 <newsham> > let f=fac1 in (f.f.f.f.f.f) (const (-1)) 5
10:11:20 <lambdabot>  120
10:12:34 <newsham> > (flip fac1 5) (const (-1))
10:12:35 <lambdabot>  -5
10:14:10 <newsham> > map (\f -> f 5) $ iterate fact1 (const (-1))
10:14:10 <lambdabot>   Not in scope: `fact1'
10:14:11 <ddarius> > iterate (\x -> 2*x - 0.3*x*x) 1
10:14:12 <lambdabot>  [1.0,1.7,2.533,3.1411733,3.322255689810133,3.333296519077525,3.3333333329267...
10:14:16 <newsham> > map (\f -> f 5) $ iterate fac1 (const (-1))
10:14:17 <lambdabot>  [-1,-5,-20,-60,-120,-120,120,120,120,120,120,120,120,120,120,120,120,120,120...
10:14:20 <ddarius> > recip 0.3
10:14:21 <lambdabot>  3.3333333333333335
10:16:21 <mauke> > iterate (\x -> -1.5 * x^2 + 5.5 * x - 2) 1
10:16:22 <lambdabot>  [1.0,2.0,3.0,1.0,2.0,3.0,1.0,2.0,3.0,1.0,2.0,3.0,1.0,2.0,3.0,1.0,2.0,3.0,1.0...
10:17:23 <mauke> > iterate (\x -> (11 * x - 3 * x^2) `div` 2 - 2) 1
10:17:24 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:17:54 <ToRA> > map (succ . (`mod` 3)) [1..]
10:17:54 <lambdabot>  [2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3...
10:17:58 <Spark> fail
10:18:02 <newsham> attractive, mauke.
10:18:11 <matthew_-> mauke: wins the girl again :)
10:18:39 <Spark> not with those floating point numbers
10:20:01 <wave`Fixx|BNC768> WRAARRRR!!! I'm the Tomato Monstahhhhh! WRAARRRR!!!
10:20:03 <wave`Fixx|BNC768> WRAARRRR!!! I has the Cookies Tooo! WRAARRRR!!!
10:20:05 <wave`Fixx|BNC768> WRAARRRR!!! I'm the Tomato Monstahhhhh! WRAARRRR!!!
10:20:06 <mauke> algebra'd
10:20:17 <Botje> wave`Fixx|BNC768: tell us how you really feel.
10:20:40 <mauke> heh, that's a registered nick
10:21:20 <MisterN> i think i know how he feels
10:21:44 <bakert> so if i want to sort a map by the values i turn it into a list and use sortBy?
10:22:12 <mauke> a map is already sorted
10:22:32 <mauke> toAscList
10:22:40 <bakert> by keys though, right?
10:22:42 <mauke> oh, oops
10:22:49 <mauke> yeah, you want values. sorry :/
10:22:52 <bakert> :)
10:23:11 <MisterN> invert it? :)
10:23:26 <bakert> could do
10:23:43 <MisterN> depends on the performance of sortBy :)
10:23:59 <bakert> i don't think this is going to be performance senstiive whatever i do
10:24:07 <bakert> so i have freedom in that regard
10:24:12 <bakert> would like to just keep it simple
10:24:42 <bakert> if i invert it i will lose dupes of values
10:24:50 <bakert> so i could only invert it after turning it into a list
10:24:52 <bakert> so that is out :)
10:24:59 <davidL> > let i = (0:+1) in realPart $ exp (pi*i)+1
10:25:00 <lambdabot>  0.0
10:25:31 <MisterN> bakert: you could forbid dupes :)
10:25:34 <MisterN> by royal act
10:28:16 <ddarius> davidL: Were you expecting something else?
10:29:29 <davidL> nope
10:31:07 <davidL> I didn't realize Data.Complex existed until now
10:31:34 <bakert> how do you write a literal Data.Map?  write the [(k, v)] list and use fromList?
10:32:05 <newsham> http://hpaste.org/4048
10:33:00 <ddarius> bakert: Usually yes.
10:33:21 <bakert> that's going to make some of my lines wrap where before they did not.  which makes me sad.
10:33:32 <ddarius> > Data.Map.fromList [(1,2),(3,4)]
10:33:33 <lambdabot>   Not in scope: `Data.Map.fromList'
10:34:55 <Cale> newsham: fact isn't (f.f.f. ... .f), it's more like (f.f.f. ...)
10:35:06 <newsham> yup i just noticed that myself.
10:35:09 <Cale> (that is, a nonterminating composition of f's)
10:35:23 <davidL> what version of happy is needed to build haskell-src?
10:35:54 <dcoutts_> davidL: any recent one will do I expect
10:35:56 <newsham> danke cale
10:40:06 <bakert> what is the disadvantage to running with -fno_monomorphism_restriction
10:40:21 <bakert> ?
10:40:24 <wli> bakert: Life not sucking.
10:40:31 <bakert> :)
10:42:23 <wli> bakert: The monomorphism restriction sucks.  If you're tired of types being surprisingly less general than expected.
10:42:46 <newsham> i just cast to void*
10:42:51 <bakert> i'm not sure i understand it that fully.  it just seems to stop my program working every so often :)
10:43:02 <bakert> and if i do what the compiler suggests it goes away :)
10:43:16 <wli> bakert: That is, if you're tired of types being surprisingly less general than expected, get rid of the monomorphism restriction.
10:43:16 <bakert> so i was thinking of adding it permanently to my runhaskell wrapper script
10:43:33 <bakert> runhaskell -Wall -Werror -fno-warn-missing-signatures -fno-warn-name-shadowing -fno-monomorphism-restriction $*
10:43:43 <bakert> that's where i'm at.
10:43:54 <bakert> i call it "rh"
10:44:02 <wli> bakert: Probably best to use a LANGUAGE pragma.
10:44:04 <Olathe> Is there a set release date for ghc 6.8.2 ?
10:44:15 <bakert> wli: is that the headings that go in the source file?
10:44:15 <dcoutts_> Olathe: not exactly, we expect a week or two
10:44:21 <Olathe> Ahh, cool.
10:44:34 <wli> bakert: Yeah. I don't know how to use the pragmas, though.
10:45:05 <newsham> isnt the biggest downside possible loss of compatibility to other compilers?
10:45:18 <bakert> good point
10:48:08 <pitecus> I'm trying to use Language.Haskell.Parser
10:48:08 <bakert> I have [("foo", 1), ("bar", 7)] and I get:    Warning: Defaulting the following constraint(s) to type `Integer'
10:48:22 <pitecus> it has a function to parse a whole module
10:48:35 <pitecus> but I cant figure out how i can parse just an expression
10:48:38 <bakert> if i put [("foo", 1), ("bar", 7)] :: [(String, Integer)]  it works fine
10:49:01 <bakert> but explicitly declaring the type of the function that consumes the list (instead) still displays the warning?
10:49:04 <mrd> the monomorphism restriction will prevent you from compiling programs which might do certain kinds of repeated unnecessary computation
10:50:26 <bakert> it's back in.  not fixing it caused confusion elsewhere :)
10:51:24 <bakert> wahey ... everything is working, with Data.Map.  small pleasures ...
10:51:35 * byorgey high-fives bakert
10:51:54 * bakert grins
10:52:13 <bakert> right, back to quickcheck!
10:52:21 <conal> osfameron: i just read your "recursive average" blog post (http://osfameron.vox.com/library/post/haskell-snippet---recursive-average.htm ).  there's also a nice one-pass variation where you average the numbers as you go rather than at the end.  i use the average-as-you-go trick for anti-aliasing on pixels with 8-bit components, to avoid overflow.
10:52:23 <lambdabot> http://tinyurl.com/3b5dy4
10:53:00 <ddarius> The running average
10:53:53 <mauke> sub avg { sum @_ / @_ } doesn't work
10:56:38 <newsham> > uncurry (/) . foldr (\n -> (+n) *** (+1)) (0, 0) [1,2,3,4,5]
10:56:40 <lambdabot>  Couldn't match expected type `a -> (a1, a1)'
10:56:43 <cedricshock> Say I have a tuple that's a record, is there any beautiful way to statically prove that a function of that tuple isn't dependent on some of its attributes? (and not need to deal, by hand with 2^arity types).
10:56:53 <newsham> > (uncurry (/) . foldr (\n -> (+n) *** (+1)) (0, 0)) [1,2,3,4,5]
10:56:54 <lambdabot>  3.0
10:57:41 <mauke> > (uncurry (/) . foldr ((*** (+1)) . (+)) (0, 0)) [1,2,3,4,5]
10:57:42 <lambdabot>  3.0
10:58:00 <ddarius> If each component had it's own type variable, then a function that was completely polymorphic in a particular type variable would be independent of it.
10:58:23 <pitecus> GHCI is complaining that a package is hidden
10:58:30 <pitecus> How can I unhide it?
10:58:53 <ddarius> Alternatively, if you encode extensible record types then your function just won't refer to the fields it doesn't use.  See e.g. OOHaskell
10:58:54 <doserj> are you installing using Cabal?
10:59:32 <pitecus> no just trying to load a module in GHCi
10:59:44 <doserj> ghc-pkg expose <packagename>
10:59:45 <dmwit> ghc-pkg enable
10:59:58 <pitecus> from ghci?
11:00:05 <doserj> from the command line
11:00:06 <dmwit> command line
11:00:14 <newsham> is osfameron here?
11:00:15 <dmwit> doserj: *poke*
11:00:17 <pitecus> ok
11:00:19 <doserj> he
11:00:35 <bakert> how can i define Arbitrary for Data.Map/
11:00:36 <bakert> ?
11:00:40 <ski> conal : how does that work ?
11:00:45 <cedricshock> ddarius: I wan't to know from outside that the function doesn't use a field, so that the dependency graph of changes to say a set of records can be calculated.
11:01:30 <byorgey> bakert: with fromList?
11:01:41 <ddarius> cedricshock: If you don't have any control of the type, there is no way you can tell from the outside alone.  You could do some runtime tests.
11:02:09 <conal> ski: the trick is how to combine the average of n numbers with another number and get the average of the n+1 numbers.
11:02:10 <bakert> instance Arbitrary Map where ... gives "    `Map' is not applied to enough type arguments"
11:02:24 <conal> ski: without knowing what the n numbers are
11:02:31 <byorgey> something like arbitrary = do { keys <- arbitrary; values <- arbitrary; liftM M.fromList (zip keys values) } perhaps?
11:02:39 <puusorsa> has anyone got haskore to compile with ghc 6.6.1? it seems to depend on a lot of outdated stuff :(
11:02:40 <bakert> instance Arbitrary Map String Integer where ... gives " Illegal instance declaration for `Arbitrary Statistics'
11:02:41 <bakert>         (The instance type must be of form (T a b c)
11:02:41 <bakert>          where T is not a synonym, and a,b,c are distinct type variables)
11:02:46 <ski> conal : i assume you keep a running counter ?
11:02:55 <puusorsa> like http://www.cse.unsw.edu.au/~dons/code/fps
11:02:57 <lambdabot> Title: Index of /~dons/code/fps
11:02:58 <byorgey> bakert: you need parens around (Map String Integer).
11:02:59 <conal> ski: yes.
11:03:16 <byorgey> bakert: you may also need -fglasgow-exts
11:03:23 <bakert> oh, how come?
11:03:41 <ddarius> A silly restriction of H98.
11:04:04 <byorgey> I think {-# LANGUAGE FlexibleInstances #-} is the particular LANGUAGE pragma you need?
11:04:12 <conal> ski: i've never seen the trick described.  probably re-discovered many times.
11:04:12 <ddarius> Something like that.
11:04:32 <xerox> > uncurry (/) . foldr ((*** (+1)) . (+)) (0,0) $ [1..10]
11:04:32 <bakert> byorgey: does that work in ghci?
11:04:33 <lambdabot>  5.5
11:04:34 <ddarius> conal, ski: It's just algebra.  You can also view it from a signal processing perspective.
11:04:54 <newsham> conal: whats the trick?
11:05:00 <bakert> seems to
11:05:07 <bakert> byorgey: thanks
11:05:22 <bakert> should i worry about including that and find another way?  or just plough on?
11:05:29 <newsham> btw, this thread on haskell-cafe talks about the foldr/arrows method and includes some optimizations and timing measurements: http://www.mail-archive.com/haskell-cafe@haskell.org/msg31053.html
11:05:30 <lambdabot> Title: [Haskell-cafe] Fusing foldr's, http://tinyurl.com/2vn5eq
11:05:38 <conal> newsham: if you know (A/n) and b, how do you make (A+b)/(n+1)?
11:05:47 <ddarius> Moving Average Filters http://www.dspguide.com/ch15/5.htm
11:05:48 <lambdabot> Title: Recursive Implementation
11:05:51 <newsham> yah
11:06:14 <ddarius> (This is more toward conal's original statement.)
11:06:40 <newsham> boo to large sidelobes
11:06:55 <bakert> how do you tell an arbitrary instance to use other arbitrary definitions to build up a composite type?
11:07:42 <geocalc> eval
11:07:47 <cedricshock> ddarius: A neat type constraint would be a union of literal values, I guess this could easily be constructed by template haskell from the union type easily. The real solution is probably that there are a lot more things I want to be able to show about these functions, and an interesting arrow or monad can do it better.
11:07:54 <ski> > map snd $ scanl (\(i,s) x -> let i' = succ i in (i',(s*i + x) / i')) (1,1) [2,3,4,5,6]
11:07:55 <lambdabot>  [1.0,1.5,2.0,2.5,3.0,3.5]
11:07:57 <newsham> ddarius: a well designed IIR would be much nicer and more efficient.
11:08:49 <conal> ski: in that def, s*i would overflow
11:09:40 <conal> ski: i mean theoretically, for low-precision fixpoint numbers, as in graphics
11:10:10 <bakert> does anyone know any "for dummies" documentation of QuickCheck's Arbitrary typeclass?
11:10:22 <bakert> this just fries my head: http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html#18
11:11:31 <newsham> http://en.wikipedia.org/wiki/Infinite_impulse_response
11:11:43 <newsham> put two or three of those together and you're in business
11:12:03 <ski> (ddarius : is that FORTRAN ?)
11:12:31 <ddarius> ski: Either FORTRAN or BASIC
11:13:52 <newsham> looks like BASIC
11:14:13 <newsham> weird "I%" never had % in the basics i've used
11:14:20 <bakert> how can i call arbitrary from this definition when in another arbitrary definiton for another type?  -- instance Arbitrary String where arbitrary = oneof $ map return ["hi", "hello", "yo"]
11:14:41 <bakert> so that my new arbitrary gets a random one of those values for it's String part
11:14:46 <bakert> ??
11:14:51 <Saizan> bakert: you just use arbitrary with type String
11:15:19 <bakert> instance Arbitrary (Map String Integer) where arbitrary = ... ??
11:15:30 <Saizan> i.e. data Foo = Foo String; instance Arbitrary Foo where arbitrary = Foo arbitraty
11:16:08 <Saizan> mh, maybe fmap Foo arbitrary
11:16:13 <Saizan> ?type arbitrary
11:16:14 <lambdabot> Not in scope: `arbitrary'
11:16:32 <bakert> ?type Test.QuickCheck.arbitrary
11:16:33 <lambdabot> forall a. (Test.QuickCheck.Arbitrary a) => Test.QuickCheck.Gen a
11:16:43 <Saizan> ok
11:17:10 <bakert>     arbitrary = fmap (Map String Integer) arbitrary
11:17:11 <bakert> ??
11:17:30 <Saizan> so for exampe instance Arbitrary (Map String Integer) where arbitrary = do s <- arbitrary; i <- arbitrary; return $ fromList [(s,i)]
11:17:44 <Saizan> arbitrary will build a random singleton map
11:17:51 <bakert> golly
11:18:01 <bakert> and type inference makes sure the right arbitrary is called
11:18:02 <bakert> ?
11:18:06 <Saizan> yes
11:18:12 <bakert> that's very clever :)
11:18:15 <Saizan> well, dispatch on types
11:18:35 <Saizan> in haskell you can dispatch on the return type, not only on the arguments
11:19:47 <conal> > let lerp x a b = x*a + (1-x)*b
11:19:47 <lambdabot>  Parse error at end of input
11:20:01 <conal> @ let lerp x a b = x*a + (1-x)*b
11:20:13 <conal> @let lerp x a b = x*a + (1-x)*b
11:20:14 <lambdabot> <local>:34:0:     Warning: Pattern match(es) are overlapped              In t...
11:20:33 <conal> > lerp (1/3) 2 3
11:20:35 <lambdabot>  2.6666666666666665
11:21:18 <conal> > scanl (\(i,s) x -> let i' = succ i in (i',lerp (recip i') s x)) (1,1) [2,3,4,5,6]
11:21:18 <lambdabot>  [(1.0,1.0),(2.0,1.5),(3.0,2.5),(4.0,3.625),(5.0,4.725),(6.0,5.7875)]
11:23:05 <newsham> thats a first-order low pass filter
11:24:55 <newsham> wait, hmm.. you're changing the factor at each step.
11:25:04 <newsham> weird
11:26:02 <faxathisia> greetings
11:26:05 <dons> http://programming.reddit.com/info/617p6/comments/
11:26:13 <dons> `Don't fear the Monads! (functions, composition, monoids, monads) :: Video (channel9.msdn.com)'
11:26:52 <Olathe> (-402.53 secs, 279049556 bytes)
11:26:55 <Olathe> My code is FAST !
11:27:04 <mux> faxathisia: ping
11:27:11 <faxathisia> hi mux
11:27:18 <newsham> conal: what is that computing?
11:27:33 <mux> hi :) justy wanted to say that the link you gave the other day is perfect, I just solved problem 80 with it
11:27:46 <ddarius> Gah! Freakin' ACM
11:27:48 <conal> newsham: stream of average of values seen so far
11:27:50 <mux> for computing exact decimal digits of irrational square root
11:28:01 <faxathisia> mux: oh nice will you show me it
11:28:05 <monochrom> ACM is fine. What's wrong?
11:28:05 <mux> sure
11:28:07 <newsham> conal: the avg is 4, no 6
11:28:25 <newsham> 2+3+4+5+6 = 20,  20/5 = 4
11:28:26 <mux> faxathisia: the code isn't very pretty, I didn't spend much in cleaning it yet, just put the answer in project euler :-)
11:28:32 <dons> wow, look how linq et al drive people to haskell, http://ms-os.com/showthread.php?t=116050
11:28:34 <mux> I'll paste it onto hpaste
11:28:34 <lambdabot> Title: Broadening ones horizons - MS OS - Microsoft Forum to Usenet Gateway
11:28:37 <newsham> err not 5.7xxx
11:29:10 <conal> newsham: sure enough.
11:29:10 <monochrom> haha, Microsoft Forum to Usenet Gateway. The right thing to do!
11:29:21 <hpaste>  mux pasted "project euler 80" at http://hpaste.org/4049
11:29:25 <bakert> OK cool that is all working lovely.  How to I ramp it up and have random-sized arbitrary maps?
11:29:28 <mux> faxathisia: here
11:29:43 * monochrom disbelieves with "web forum" software. What's wrong with nntp and the freedom of choice in client-side presentation?
11:30:21 <newsham> mono: whats wrong with nntp is efficiency.
11:30:35 <monochrom> I think people hate freedom of choice.
11:30:40 <newsham> everyone downloads and archives all articles
11:30:47 <lament> plenty of things wrong with nntp, but it would be nice to have some common non-web-based protocol, something like RSS, for web forums
11:31:08 <newsham> yah, i'm not gonna defend web forums :)
11:31:16 <lament> people don't hate freedom of choice, which is why RSS exists
11:31:52 <monochrom> Does RSS include a posting protocol?
11:32:02 <faxathisia> mux: cool :p
11:32:03 <mux> faxathisia: first cleanup is to use splitAt instead of take 2 foo and later drop 2 foo :-)
11:32:11 <faxathisia> It doesn't produce infinite digits though
11:32:16 <newsham> whats even more awesomester: having to sign up to a new service to reply to someones blog
11:32:23 <mux> faxathisia: uh? it should
11:32:31 <mux> and as far as I can see, it does
11:32:31 <lament> newsham: yeah, that's just fantastic
11:32:49 <mux> oh no, it hangs at some point indeed
11:32:52 <mux> hmm
11:33:20 <mux> not sure why, but at least it is able to spout the first 100 digits =)
11:33:23 <faxathisia> somewhere between 3 and 4 hundrd digits
11:33:34 <faxathisia> did you see maukes one liner?
11:33:36 <faxathisia> for the sqrt of 2
11:33:45 <mux> oh no, please show
11:33:48 <faxathisia> > let l f x=case f x of{Left r->r;Right y->l f y};s(v,d,c)|v<d=Left(v,c)|True=Right(v-d,d+2,c+1);f n r=let(v,c)=l s(n*100,r*20+1,0)in chr(fromInteger c+48):f v(r*10+c)in f 1 1
11:33:49 <lambdabot>  "414213562373095048801688724209698078569671875376948073176679737990732478462...
11:34:05 <mux> but that's only for sqrt 2?
11:34:37 <faxathisia> I don't know how it works
11:37:15 <b_jonas> > isPunctuation '$'
11:37:16 <lambdabot>  False
11:37:19 <b_jonas> why is that false?
11:37:56 <mauke> bug
11:37:57 <sieni> @src isPunctuation
11:37:57 <lambdabot> Source not found.
11:38:01 <sieni> :-(
11:38:22 <mux> well I'd say $ isn't punctuation; but I don't know what's the definition of isPunctuation
11:38:34 <mauke> oh, oops
11:38:43 <b_jonas> > filter isPunctuation $ map toEnum [32..128]
11:38:44 <lambdabot>  "!\"#%&'()*,-./:;?@[\\]_{}"
11:38:50 <mauke> Selects Unicode punctuation characters, including various kinds of connectors, brackets and quotes.
11:38:56 <ddarius> Check the Unicode reference.  Doesn't it define which things are punctuation and which aren't (as far as it's concerned)?
11:39:06 <mauke> it's not the same as ispunct(3)
11:39:25 <mauke> > isSymbol '$'
11:39:26 <lambdabot>  True
11:39:33 <b_jonas> mauke: it can't be the same, ispunct is for locales, not for unicode
11:39:56 <b_jonas> but yes, I'd like something like ispunct
11:40:04 <b_jonas> and ideally I'd like chars, not Chars
11:40:37 <conal> okay -- here's a fixed averages:
11:40:40 <conal> > scanl (\ av (i,x) -> lerp (recip i) x av) 0 (zip [1..] [1..5])
11:40:41 <lambdabot>   Not in scope: `lerp'
11:40:44 <mauke> ispunct c = not (isAlphaNum c || isSpace c)
11:40:48 <conal> @let lerp x a b = x*a + (1-x)*b
11:40:50 <lambdabot> Defined.
11:40:52 <conal> > scanl (\ av (i,x) -> lerp (recip i) x av) 0 (zip [1..] [1..5])
11:40:52 <lambdabot>  [0.0,1.0,1.5,2.0,2.5,3.0]
11:40:57 <mauke> er
11:40:59 <b_jonas> mauke: thanks, I guess I'll use something like that
11:41:07 <b_jonas> except that I also need not control charactesr
11:41:23 <bakert> I need to do something like take (randomNumFrom 0 10) listOfLotsOf { s <- arbitrary; i <- arbitrary; (s, i) }
11:41:26 <mauke> ispunct c = printable c && not (isAlphaNum c || isSpace c)
11:41:27 <b_jonas> or maybe it's better if I explicitly type out the list of punct characters I need here
11:41:41 <b_jonas> it's only approx 32 chars afterall
11:41:46 <bakert> :t replicateM
11:41:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:41:59 <faxathisia> @let lerp x a b = a + (b-a)*x
11:41:59 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
11:42:01 <b_jonas> mauke: isPrint?
11:42:13 <mauke> yes
11:42:27 <b_jonas> > let ispunct c = isPrint c && not (isAlphaNum c || isSpace c) in filter ispunct $ map toEnum [32..128]
11:42:27 <lambdabot>  "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
11:42:58 <ddarius> 1.2GB!
11:43:21 <b_jonas> ok, now I don't know whether to use that or type out the 32 of them (without apostrophe, which is a string marker)
11:43:25 <conal> faxathisia: thanks.  takes out a multiply and still doesn't overflow.
11:43:30 <bakert> So how do I fit a do { } block inside a call to replicateM i wonder
11:43:41 <conal> faxathisia: although b-a could go negative
11:43:48 <b_jonas> it's for the J parser
11:43:59 <faxathisia> negative is ok :)
11:44:00 <ddarius> bakert: Just do it...
11:44:03 <mauke> > replicateM 2 (do { x <- [1,2,3]; return x; })
11:44:03 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
11:44:09 <bakert> oh cool
11:44:15 <bakert> that was easy :)
11:44:16 <faxathisia> b_jonas: are you writing a J interpreter in haskell
11:44:18 <mauke> or $
11:44:34 <ddarius> bakert: A common "trick" is to do replicateM 2 $ do\n ...
11:44:35 <b_jonas> faxathisia: at least I'm trying
11:44:39 <b_jonas> I'm not sure I'll finish it
11:44:39 <faxathisia> b_jonas: :D
11:44:40 <conal> faxathisia: sure, usually.  but for graphics, the numbers are often 8-bit non-negative fix-point reps
11:44:49 <ddarius> bakert: but, yeah, do blocks are just values
11:44:50 <faxathisia> I hope you release whatever does get created
11:44:52 <ddarius> like everything else
11:45:12 <bakert> ?hoogle replicateM
11:45:14 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
11:45:14 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
11:45:20 <faxathisia> conal: ohh, I see the motivation for the other def now
11:45:34 <faxathisia> conal: although it goes from b to a which I find odd :p
11:46:07 <b_jonas> thanks for the help anyway, mauke
11:46:37 <conal> faxathisia: yeah, i guess that is odd.
11:47:06 <conal> faxathisia: i probably did lerp the other way in pan.
11:47:10 <conal> (from b to a)
11:47:16 <conal> (i mean, from a to b)
11:47:22 <faxathisia> What's pan
11:47:32 <conal> @where pan
11:47:33 <lambdabot> I know nothing about pan.
11:47:37 <conal> @where Pan
11:47:40 <lambdabot> I know nothing about pan.
11:47:48 <conal> @where+ pan http://conal.net/Pan
11:47:49 <lambdabot> Done.
11:48:19 <faxathisia> Ooooo
11:48:30 <conal> faxathisia: it was a language & optimizing compiler for interactive image synthesis.  infinite & continuous imagery.
11:48:31 <faxathisia> I've watched a video about this
11:48:37 <b_jonas> oh, I think I also want underscore not be a punctation character
11:48:47 <faxathisia> I wonder if that was you giving the presentation?
11:49:10 <ddarius> faxathisia: Did it look like him?
11:49:16 <faxathisia> I don't know :p
11:49:27 <conal> faxathisia: hm... oh -- i gave a presentation at UW in 01 or so.  it's on video.
11:49:29 <faxathisia> anyway that Pan is really cool
11:49:37 <conal> i didn't have a beard then.
11:50:31 <alexj> @seen igloo
11:50:45 <Olathe> lambdabot is dead :(
11:50:52 <conal> faxathisia: this?  http://www.uwtv.org/programs/displayevent.aspx?rID=2124&fID=368
11:51:01 <faxathisia> yeah :D
11:51:03 <faxathisia> That was great
11:51:19 <conal> thanks! :)
11:51:45 <conal> i have a newer version of pan, called pajama.  it compiles into java code.
11:51:47 <conal> @where pajama
11:52:01 <faxathisia> I saw on the pan page
11:52:14 <gwern> hm. I think I didn't set up darcs well.
11:52:19 <conal> oh, lb dead. :(
11:52:51 <ddarius> Long live lambdabot
11:53:02 * Olathe sobs.
11:53:05 <faxathisia> oh this is cool :D
11:53:05 <faxathisia> http://conal.net/Pajama/galleries/crop.htm
11:53:09 <gwern> so I have darcs initialized in src/, controlling stuff in ./ and src/Monadius/, but I've realized I actually want to have darcs one level further up. do I just initialize on level up and pull from the old one?
11:53:12 <ski> ddarius : too early
11:55:14 <conal> faxathisia: i'd like to get pajama cleaned up & released.  one catch is that there's some old code i did at microsoft.  i've been waiting until GADTs & class constraints work better together, as i think that combo will make rewriting the code rep and optimizer worthwhile.
11:56:30 <conal> i was a bad boy and went way over my satellite bandwidth limit, installing ubuntu updates.  now i'm smacked down to 100kbps for a few days.
11:57:19 <conal> no dsl/cable here in the woods.  but it's gorgeous & worth it.
12:00:43 <dons> conal: :) oh well.
12:00:51 <dons> you'll have to get into ascii art :)
12:01:27 * ddarius starts wondering if he even has 1.2GB free on this partition...
12:01:57 <ddarius> Looks like it.
12:02:08 <conal> dons: it also motivates me to want to replace all web formats (html, jpeg, etc) with higly-factored (safe) haskell code.
12:03:02 <conal> and adaptive/incremental computation over the web.
12:03:22 <conal> "the higher-order web"
12:03:38 <ddarius> A web of webs?
12:04:29 <conal> ddarius: not what i had in mind, but a neat idea.  maybe with "web" as alternative to zipper.
12:05:17 <ski> http://citeseer.ist.psu.edu/hinze01web.html
12:05:29 <conal> ski: yeah, that.
12:10:02 <puusorsa> halp!
12:10:25 <puusorsa> somebody please fix haskore to work with current ghc etc, seems like too much work for me :)
12:12:31 <dons> puusorsa: hmm. its unmaintained, afaik.
12:12:37 <dons> puusorsa: so you might have to do it!
12:12:42 <dons> we shoudl get it cabalised.
12:12:50 <dons> a great work like that, it would be a shame to have it bitrot
12:13:26 <ddarius> > iterate (2*x - 1.5*x*x) 1
12:13:33 <puusorsa> dons, i AM doing it
12:13:36 <ddarius> Doh
12:13:43 <puusorsa> though i'm doing it wrong
12:13:46 <dons> great, puusorsa !
12:13:55 <puusorsa> been for two hours or something
12:14:09 <puusorsa> event-list has changed
12:14:11 <ddarius> dons: Das Bot ist kaput
12:14:58 <puusorsa> tried doing some simple changes to it so i wouldn't have to do so much for haskore, but now i'm thinking that might be wrong
12:15:15 <puusorsa> any idea how active event-list is ?
12:15:58 <dons> There are screens on: 18402.pts-6.haskell	(Dead ???) 13692.pts-6.haskell	(Dead ???)
12:16:04 <dons> weird. haven't seen that before
12:16:17 <chris2> building ghc on a brand new macbook, how long will it roughly take?
12:16:38 <ski> dons : are the processes still running ?
12:16:39 <dons> hmm 2 cores?
12:16:44 <puusorsa> screen -ls, screen -wipe etc
12:16:44 <chris2> yes, 2gb ram
12:16:54 <dons> should be pretty fast. 10-30mins
12:16:55 <chris2> 2.2ghz
12:16:59 <chris2> really
12:16:59 <ddarius> chris2 not long if you are talking about GHC 6.8.1
12:17:03 <ddarius> or newer
12:17:09 <chris2> let's see what macport has
12:17:28 <chris2> 6.6.1, argh
12:17:38 <puusorsa> haskore is so great that i feel someone who knows what (s)he's doing should fix it instead of me, but if no one else really is doing it i guess i'll have to :/
12:17:49 <dons> puusorsa: maybe ask on -cafe@
12:17:52 <chris2> 6.8 is faster because of pointer tagging?
12:17:54 <dons> there was a move to remaintain it
12:17:55 <dons> chris2: yeah
12:18:33 <chris2> ghc-devel is 6.7
12:18:36 <ddarius> Ah crap.
12:18:43 * ddarius should have started this download with wget.
12:18:52 <puusorsa> #haskell-cafe? or website?
12:19:02 <ddarius> Maybe things will work out.
12:19:16 <ddarius> haskell-cafe@haskell.org
12:19:34 <puusorsa> thanks
12:19:56 <dons> ?uptime
12:19:56 <lambdabot> uptime: 3m 23s, longest uptime: 1m 10d 23h 44m 29s
12:20:00 <dons> > 1+@
12:20:00 <lambdabot>   parse error on input `}'
12:20:01 <dons> > 1+2
12:20:04 <ddarius> defining a monad is a daunting challenge?
12:20:16 <lambdabot>  thread killed
12:20:22 <dons> hmm
12:20:26 <mux> @undef
12:20:39 <lambdabot> Undefined.
12:20:43 <dons> > 1+2
12:20:43 <lambdabot>  3
12:20:48 <mux> hehe
12:20:50 <dons> mmm
12:20:59 <dons> that doesn't look good
12:21:03 <mux> I have similar problems with my LB regularly
12:21:07 <dons> mux?
12:21:10 <mux> @undef always fixes it
12:21:15 <lambdabot> Undefined.
12:21:25 <mux> @src reverse
12:21:25 <lambdabot> reverse = foldl (flip (:)) []
12:21:26 <dons> never seen that
12:21:29 <mux> it's all good now
12:21:37 <faxathisia> what does @undef do?
12:21:49 <mux> it empties the local definitions introduced with @let
12:22:13 <dmwit> Note for the unwary: it empties *all* local definitions.
12:23:05 <mux> I should have a look at L.hs next time this happens
12:23:09 <faxathisia> :(
12:23:24 <faxathisia> I keep thinking stuff makes sense then I try to code it and discover it doesn't :p
12:23:37 <Olathe> > foldr (+) 0 [1..1000000]
12:23:37 <ddarius> faxathisia: How do you know?
12:23:37 <lambdabot>  Exception: stack overflow
12:23:42 <Olathe> > foldb (+) 0 [1..1000000]
12:23:43 <lambdabot>  500000500000
12:23:47 <Olathe> Heh
12:23:53 <mux> foldb ?!
12:23:58 <Olathe> foldb !
12:24:02 <mux> :t foldb
12:24:02 <lambdabot> Not in scope: `foldb'
12:24:06 <faxathisia> ddarius: How do I know it doesn't make sense? because there seems to be contradictions when I think about actually writing executable code
12:24:09 <b_jonas> > foldl (+) 0 [1..1000000]
12:24:10 <Olathe> foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
12:24:10 <lambdabot>  Exception: stack overflow
12:24:25 <mux> > foldl' (+) 0 [1..1000000]
12:24:26 <lambdabot>  500000500000
12:24:35 <Olathe> @src foldl'
12:24:35 <lambdabot> foldl' f a []     = a
12:24:35 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:24:41 <Olathe> @src seq
12:24:41 <lambdabot> Source not found. My mind is going. I can feel it.
12:24:43 <idnar> @src foldb
12:24:43 <lambdabot> Source not found. :(
12:24:47 <faxathisia> > 1000000*(1000000+1)/2
12:24:48 <lambdabot>  5.000005e11
12:24:48 <mux> seq is a primitive
12:24:49 <Olathe> :(
12:24:55 <b_jonas> > foldl' (+) 0 [1..1000000]
12:24:56 <lambdabot>  500000500000
12:25:41 <Olathe> > div (1000000*(1000000+1)) 2
12:25:41 <lambdabot>  500000500000
12:26:30 <faxathisia> I need to have taken a class in semantics or something :/
12:27:00 <geocalc> why ?
12:27:32 <shachaf> Is code.haskell.org down?
12:27:43 <Olathe> > let sumInterval a b = div ((b - a + 1)*(a + b)) 2 in sumInterval 1 1000000
12:27:44 <lambdabot>  500000500000
12:27:46 <zeeeee> what's System.Posix.Resource? what does it mean by posix resource limits?
12:28:48 <mux> zeeeee: the standard POSIX resource limits (on memory, cpu time, etc)
12:28:56 <mux> see getrlimit() and setrlimit()
12:29:09 <zeeeee> oh, thanks
12:29:15 <mux> you're welcome
12:29:44 <zeeeee> i was seeking something that would tell me how much memory the current haskell process was using
12:30:04 <mux> you'd be better off using memory profiling for that, I think
12:30:36 <zeeeee> mux, there's no way to get this info programmatically?
12:31:29 <mux> hmm, I suppose you could dive into GHC internals, there may be something you could use
12:32:14 <faxathisia> geocalc: In order to properly understand the semantics of a language I want to write an interpreter for
12:32:15 <zeeeee> well, i can always parse the output of `ps`
12:32:20 <mux> or use something either Windows-specific or POSIX-specific, or..
12:32:30 <dons> zeeeee: it would be interesting to bind to the rts internal tick profiling stuff
12:33:03 <zeeeee> dons, what's that?
12:33:58 <ddarius> faxathisia: Have you written interpreters for other languages before?
12:34:16 <monochrom> Pick a very simple dumb language.
12:35:07 <faxathisia> ddarius: yeah I have some and a couple small ones in haskell too
12:35:08 * wli is clueless as to how to deal with imperative access to memory, including arrays.
12:35:23 <wli> This being in the context of interpreters.
12:35:53 <olsner> wli: interpreting an imperative language in haskell?
12:35:56 <monochrom> You could write a very slow interpreter. It could interpret arrays as functions.
12:36:02 <wli> olsner: Yes.
12:36:12 <faxathisia> I used a Data.Map it's probably very slow
12:36:28 <olsner> eval = unsafePerformIO . eval'
12:36:30 <olsner> :P
12:36:37 <faxathisia> ddarius: I wanna know if there is some mechanical way to turn operational semantics charts like http://www.usenix.org/events/sec05/tech/full_papers/altekar/altekar_html/taint_flow.jpg into code
12:36:38 <lambdabot> http://tinyurl.com/yqfxqy
12:36:38 <wli> It was doing it with monads that stumped me. There's probably a trick.
12:36:39 <monochrom> You could use ST and therefore real arrays for real arrays. :)
12:36:56 <faxathisia> wli: someone here showed me a really great text
12:37:21 <wli> It's obvious how to do them in isolation but it didn't fit with the monad transformer stack well at all.
12:37:22 <faxathisia> I'm not certain it addresses the same issue but incase it does http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
12:38:10 <ddarius> faxathisia: There is.
12:38:25 <wli> I'm not looking at the issue right now, and X is proving impossible to set up on my laptop, and so on and so forth.
12:39:57 <faxathisia> I understand the declarative meaning but It's hard to encode as haskell
12:40:04 <faxathisia> (not that particular one)
12:40:17 <faxathisia> ddarius: is there a name for it or any idea what I should look up ?
12:42:10 <dikini> faxathisia: logic? something like logicT?
12:42:19 <bakert> data Foo = Bar | Baz | Quux
12:42:22 <ddarius> faxathisia: 2BIG I think is a system that does some of the kind of stuff you'd be interested in
12:42:26 <monochrom> There are two kinds of operational semantics: big step and small step.
12:42:35 <bakert> is there anyway to get a list of the constructors of Foo without deriving Enum
12:42:35 <bakert> ?
12:42:40 <wli> monochrom: Interesting. Tell me more.
12:42:43 <bakert> (or hardcoding a list :)
12:42:44 <faxathisia> dikini: I think it's not applicable
12:42:57 <ddarius> There are two kinds of semantics: operational and denotational (which is sometimes called big-step operational semantics)
12:43:00 <monochrom> Small step is easy to code up because it is the single-step transition.
12:43:06 * faxathisia ddarius: thanks I'm gonna check it out
12:43:16 <ddarius> (There is also axiomatic semantics, action semantics, algebraic semantics ...)
12:43:20 <mux> bakert: I don't think so; any reason you don't want to derive Enum?
12:43:56 <bakert> mux: i suppose not.  i think i was mixing the meaning of Ord and Enum in my head
12:44:05 <faxathisia> I started reading TAPL again as well
12:44:08 <faxathisia> but I don't think it helped
12:44:10 <wli> How do these operational semantics relate to virtual machines like the STG machine or the (\nu, G) machine?
12:44:14 <mux> TAPL is great
12:44:28 <faxathisia> oh yeah I mean I learned tonnes the first time I read it
12:44:35 <ddarius> faxathisia: You might find http://www.brics.dk/RS/03/Abs/BRICS-RS-03-Abs/BRICS-RS-03-Abs.html#BRICS-RS-03-13 and http://www.brics.dk/RS/03/Abs/BRICS-RS-03-Abs/BRICS-RS-03-Abs.html#BRICS-RS-03-14 and the other papers spawned from them interesting in a related vein.
12:44:38 <lambdabot> Title: BRICS Research Series, Abstracts, 2003, http://tinyurl.com/2bora7
12:44:51 <bakert> mux: one problem i have with deriving Enum is Foo = Bar | Baz | Quux String ... that doesn't work?
12:45:26 <faxathisia> cool :D cheers
12:45:46 <bakert> non-nullary constructors.  but i'm not sure what i expect the compiler to do about that :()
12:45:55 <mux> bakert: nope, that won't work, you need only nullary constructors
12:45:58 <wli> The thing that always stumped me is where they come up with the virtual machines.
12:46:16 <andyjgill> @seen dons
12:46:16 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 13m 46s ago.
12:46:29 <mux> bakert: but if you end up with that ADT, it might be interesting to see if it wouldn't be best to split it, or change it somehow
12:46:30 <ddarius> wli: One (new and) mechanical! way is described in the papers I just linked faxathisia too.
12:47:06 <bakert> mux: it has cost me much pain to get to that ADT :)  i think it is right for what i am doing.  so i will just hardcode a few examples in my quick check stuff i think.
12:47:23 <wli> Brilliant. Just when I can't get into X.
12:47:25 <dikini> faxathisia: http://citeseer.ist.psu.edu/hutton98fold.html has easy to read and understand examples
12:47:25 <lambdabot> Title: Fold and Unfold for Program Semantics - Hutton (ResearchIndex)
12:47:32 <dons> andyjgill: yo!
12:47:38 <dikini> faxathisia: it worked for me :)
12:48:07 <faxathisia> dikini: thanks
12:48:15 <faxathisia> I got a fair bit to read now :D
12:49:13 <dikini> faxathisia: have you done sicp?
12:49:35 <faxathisia> well I watched the videos :p
12:50:53 <nickatnite> hey guys, how do i compare two lists returning the amount that occurs in the first list, but is in the wrong position
12:50:54 <dikini> the last few chapters are the basics of implementing evaluators based on both small and big step operational semantics, if I remember correctly
12:51:23 <nickatnite> example [1,2,3] [1,3,2] would give 1 in right place and 2 in wrong
12:51:28 <monochrom> Big step goes like: "suppose E's answer is v, then f(E)'s answer is v+1". It talks more about the final answer than the intermediate steps. It is harder to code up because you have to first recover the intermediate steps. OK I may be wrong in the last sentence; you may use recursion and continuation to code up easily.
12:51:45 <ddarius> nickatnite: zip them together and filter
12:51:50 <faxathisia> ahh
12:51:59 <faxathisia> I think then I have some big step semantic diagrams
12:52:30 <ddarius> The papers I linked to by Danvy and co. show how you can mechanically link operational and denotational semantics.
12:52:49 <monochrom> Anyway, if you have a small step semantics, you code it up like "loop over state, keep mutating state as per transition rules, until the rule says you can stop".
12:53:02 <nickatnite> hey guys, how do i compare two lists returning the amount that occurs in the first list, but is in the wrong position
12:53:12 <ddarius> nickatnite: I already told you.
12:53:24 <nickatnite> > how?
12:53:31 <lambdabot>   parse error on input `}'
12:53:34 <nickatnite> how?
12:53:38 <ddarius> nickatnite: zip them together and filter
12:53:58 <monochrom> And perhaps big step is easier to link up with denotational semantics. If you have a denotational semantics, you write a structural recursive interpreter instead of a loop.
12:54:12 <ddarius> big-step -is- denotational semantics
12:54:25 <nickatnite>  filter (same) (zip [1,2,3][1,3,2])
12:54:41 <ddarius> Yes.  Then a fst . head to get the appropriate element.
12:54:42 <nickatnite>  filter (occurs) (zip [1,2,3][1,3,2])
12:54:43 <faxathisia> : uncurry ==
12:54:43 <monochrom> I wouldn't equate them. They can still be made different.
12:54:48 <faxathisia> :t uncurry (==)
12:54:51 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
12:55:19 <nickatnite>  > filter (fst.head) (zip [1,2,3][1,3,2])
12:55:53 <faxathisia> > length . filter (uncurry (==)) $ zip [1,2,3] [1,3,2]
12:55:54 <lambdabot>  1
12:56:02 <ddarius> > fst $ head $ filter (uncurry (==)) $ zip [1,2,3] [1,3,2]
12:56:02 <lambdabot>  1
12:56:13 <ddarius> > fst $ head $ filter (not . uncurry (==)) $ zip [1,2,3] [1,3,2]
12:56:13 <lambdabot>  2
12:56:31 <nickatnite> any easier way?
12:56:36 <nickatnite> so i can understand?
12:56:58 <ddarius> You could use list comprehensions instead which would be perhaps a bit clearer
12:56:58 <faxathisia> > zip [1,2,3] [4,5,6]
12:56:58 <lambdabot>  [(1,4),(2,5),(3,6)]
12:57:24 <nickatnite> i understand that
12:57:26 <ddarius> > [x | (x,y) <- zip [1,2,3] [1,3,2], x /= y]
12:57:26 <nickatnite> part
12:57:27 <lambdabot>  [2,3]
12:57:32 <ddarius> > head [x | (x,y) <- zip [1,2,3] [1,3,2], x /= y]
12:57:33 <lambdabot>  2
12:58:08 <ddarius> > head [x | x <- [1,2,3] | y <- [1,3,2], x /= y]
12:58:08 <lambdabot>  Parse error at "|" (column 24)
12:58:22 <ddarius> That would be using parallel list comprehensions, an extension in GHC
12:58:41 <ddarius> not . uncurry (==) can be replaced with uncurry (/=)
12:59:49 <nickatnite> >zipWith (/=) [1,2,3,4][4,2,1,1]
13:00:00 <nickatnite> > zipWith (/=) [1,2,3,4][4,2,1,1]
13:00:00 <lambdabot>  [True,False,True,True]
13:00:29 <faxathisia> zipWith f == map (uncurry f) . zip  [ I think ? ]
13:00:53 <sclv> ?src zipWith
13:00:53 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:00:53 <lambdabot> zipWith _ _      _      = []
13:00:58 <ddarius> faxathisia: True
13:01:03 <ddarius> @free zipWith
13:01:03 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
13:01:09 <nickatnite> > fst.head (zipWith (/=) [1,2,3,4][4,2,1,1])
13:01:10 <lambdabot>  Couldn't match expected type `a -> (a1, b)'
13:01:45 <nickatnite> > head [x | (x,y) <- zip [5,2,3,1] [1,3,2,5], x /= y]
13:01:45 <lambdabot>  5
13:02:27 <nickatnite> why am i getting 5?
13:02:46 <nickatnite> i am suppose to get 4
13:02:48 <ddarius> That's the value in the first list at the first place where the two lists differ.
13:03:01 <ddarius> You want a count.
13:03:08 <nickatnite> yes
13:03:11 * ddarius misinterpreted "amount"
13:03:13 <EvilTerran> > length [x|...]
13:03:13 <lambdabot>  Parse error at "]" (column 14)
13:03:54 <nickatnite> > length (head [x | (x,y) <- zip [5,2,3,1] [1,3,2,5], x /= y])
13:03:55 <lambdabot>   add an instance declaration for (Num [a])
13:03:55 <lambdabot>     In the expression: 5
13:03:58 <ddarius> If you replace head with length you get the number that differ point-wise
13:04:12 <faxathisia> :t mapM2
13:04:12 <lambdabot> Not in scope: `mapM2'
13:04:16 <faxathisia> :2 filterM2
13:04:18 <faxathisia> :t filterM2
13:04:19 <lambdabot> Not in scope: `filterM2'
13:04:20 <nickatnite> > length  [x | (x,y) <- zip [5,2,3,1] [1,3,2,5], x /= y]
13:04:21 <lambdabot>  4
13:04:26 <nickatnite> ok
13:04:29 <mux> > length . filter id $ zipWith (/=) [1..5] [5..1]
13:04:29 <lambdabot>  0
13:04:42 <mux> > length . filter id $ zipWith (==) [1..5] [5..1]
13:04:42 <lambdabot>  0
13:04:54 <ski> (parallel list comprehensions are in hugs, as well)
13:04:56 <mux> heh, expected.
13:05:31 <faxathisia> @src filter
13:05:31 <lambdabot> filter _ []     = []
13:05:31 <lambdabot> filter p (x:xs)
13:05:31 <lambdabot>     | p x       = x : filter p xs
13:05:31 <lambdabot>     | otherwise = filter p xs
13:05:45 <davidL> > id False
13:05:45 <lambdabot>  False
13:06:05 <mux> or filter p xs = [ x |x <- xs, p x ]
13:06:38 <faxathisia> > let filter2 f = filter (uncurry f) . zip in filter2 (==) [1,2,3] [1,3,2]
13:06:38 <lambdabot>  Couldn't match expected type `[(a, b)]'
13:07:19 <ddarius> > let filter2 f = (filter (uncurry f) .) . zip in filter2 (==) [1,2,3] [1,3,2]
13:07:20 <lambdabot>  [(1,1)]
13:09:59 <fxr> y00
13:10:06 <dmwit> Hiya fxr!
13:10:23 <fxr> I'm happy just solved my hxt problems
13:10:38 <dmwit> Oh, cool, what was wrong?
13:11:30 <fxr> oh my misunderstandings...
13:12:08 <EvilTerran> hm...
13:14:51 <pitecus> Any idea what that means:
13:14:52 <pitecus> /home/gchrupala/lib/morfette-0.0/ghc-6.6.1/GramLab/Morfette/Features/Tagging.hi
13:14:52 <pitecus> Declaration for FeatureSpec
13:14:52 <pitecus> Constructor GramLab.Morfette.Features.Tagging.FS:
13:14:52 <pitecus>   Can't find interface-file declaration for GramLab.Morfette.Features.Common.OR
13:14:52 <pitecus>     Probable cause: bug in .hi-boot file, or inconsistent .hi file
13:14:54 <pitecus>     Use -ddump-if-trace to get an idea of which file caused the error
13:14:56 <pitecus> Cannot continue after interface file error
13:15:38 <ski> mutually recursive modules
13:15:56 <pitecus> Hm
13:16:14 <idnar> To understand recursion, you must first understand recursion.
13:16:24 <pitecus> I dont get it, the package compiled and installed correctly
13:16:26 <mauke> ... or know someone who understands recursion
13:16:30 <faxathisia> To understand recursion yo must understand induction :P
13:16:32 <pitecus> Im just calling it from a script
13:16:43 <ski> to break cycles, ghc requires one to write a `*.hi-boot' file
13:16:53 <ski> probably there's some inconsistence there
13:17:05 <ski> s/inconsistence/inconsistency/
13:17:19 <pitecus> ski wouldnt that be detected when i try to compile the package?
13:17:42 <ski> isn't that what you're doing ?
13:18:05 <pitecus> no
13:18:29 <pitecus> i just try to run a script which uses a module from the package the package
13:18:29 <integral> @type local
13:18:31 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
13:20:31 * ski is not sure
13:20:31 <bakert> :t Test.QuickCheck.==>
13:20:32 <lambdabot> parse error on input `Test.QuickCheck.==>'
13:20:38 <bakert> :t (Test.QuickCheck.==>)
13:20:38 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
13:20:56 <bakert> well now what is a Test.QuickCheck.Property?
13:21:01 <bakert> ?src Test.QuickCheck.Property
13:21:01 <lambdabot> Source not found.
13:21:09 <bakert> not a Bool
13:21:29 <bakert> the example in the manual is prop_Insert x xs = ordered xs ==> ordered (insert x xs)
13:21:33 <bakert> but that must be out of date
13:21:49 <bakert> hmmm
13:22:10 <twanvl> Property is approximatly Gen Bool
13:23:23 <newsham> :t Test.QuickCheck.(==>)
13:23:24 <lambdabot> Couldn't find qualified module.
13:23:34 <newsham> ?hoogle (==>)
13:23:35 <lambdabot> Did you mean: (==>)
13:23:35 <lambdabot> Prelude.undefined :: a
13:23:35 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:23:42 <mauke> lern2syntax
13:23:53 <bakert> :t (Test.QuickCheck.==>)
13:23:53 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
13:24:21 <newsham> oh it worked earlier.. heh
13:24:36 <bakert> twanvl: so how do i get one?  a Property i mean, from a Bool?
13:24:50 <twanvl> ?type Test.QuickCheck.property
13:24:50 <bakert> or does it not work like that?
13:24:50 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> Test.QuickCheck.Property
13:25:13 <newsham> bakert: you can quickcheck a -> Bool
13:25:55 <twanvl> the second argument of ( ==>) is any Testable, so also a plain Bool
13:25:57 <newsham> ?check \x -> (x :: Int) == x
13:25:58 <lambdabot>  OK, passed 500 tests.
13:26:09 <bakert> i have a thing that might be true that has a Bool value.  and the ==> operator. and a check that should be true if the first bit is true.  but i can't work out how to glue them together
13:26:16 <bakert> so f ==> g
13:26:18 <byorgey> bakert: a Bool is a Property, I think.
13:26:22 <bakert> is no good
13:26:25 <ski> @check True ==> (True ==> True)
13:26:26 <lambdabot>  OK, passed 500 tests.
13:26:30 <newsham> prop_ConvConv2 xs ys = length xs > 0 && length ys > 0 ==> conv xs ys == conv2 xs ys
13:26:32 <bakert>   Couldn't match expected type `Bool'
13:26:32 <bakert>            against inferred type `Property'
13:26:32 <bakert>    
13:26:34 <pitecus> It seems I have to add the modules to exposed-modules in tha cabal file and reinstall to be able to run that script, very weird
13:26:42 <mauke> newsham: try more parens
13:26:46 <faxathisia> @check False ==> False
13:26:47 <lambdabot>  Arguments exhausted after 0 tests.
13:26:52 <bakert> huh
13:27:00 <bakert> ok so something else is going on than what i think :)
13:27:01 <byorgey> bakert: er, I mean, a Property can store a Bool... something like taht.
13:27:11 <byorgey> bakert: if you paste your code I could take a look
13:27:36 <bakert> it is pretty horrible :)
13:27:38 <newsham> ?check \xs -> length xs > 0 ==> length (tail xs) == length (xs :: [Int])
13:27:39 <faxathisia> those papers were really interesting
13:27:39 <bakert> ?paste
13:27:39 <lambdabot>  Falsifiable, after 0 tests: [-1]
13:27:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:27:46 <byorgey> bakert: oh, wait, twanvl showed it above: a Bool is a Testable, which is the type class I was thinking of
13:27:48 <newsham> ?check \xs -> length xs > 0 ==> length (tail xs) == length (xs :: [Int]) - 1
13:27:49 <lambdabot>  OK, passed 500 tests.
13:27:52 <hpaste>  bakert pasted "property testing" at http://hpaste.org/4050
13:28:05 <byorgey> bakert: the 'property' function takes any Testable into a Property
13:28:08 <bakert> please don't beat me :)
13:28:15 <bakert> byorgey: ah
13:28:16 <MisterN> @hoogle property
13:28:16 <bakert> i see
13:28:22 <lambdabot> Test.QuickCheck.property :: Testable a => a -> Property
13:28:22 <lambdabot> Test.QuickCheck.Property :: data Property
13:28:44 <newsham> bakert: missing a newline in there?
13:29:06 <byorgey> bakert: right, since you are using a ==>, the return type of your function should be Property, not Bool
13:29:06 <bakert> newsham: probably :)
13:29:15 <bakert> oh cripes
13:29:16 <byorgey> @type (==>)
13:29:16 <lambdabot> Not in scope: `==>'
13:29:29 <byorgey> @type (Test.QuickCheck.(==>))
13:29:29 <lambdabot> Couldn't find qualified module.
13:29:41 <byorgey> @type (Test.QuickCheck.==>)
13:29:45 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
13:29:59 <bakert> byorgey: that seems to have fixed it.  thanks
13:30:08 <byorgey> bakert: sure
13:31:19 <bakert> ?hoogle a -> Data.Map a _ -> Bool
13:31:19 <lambdabot> No matches, try a more general search
13:31:23 <faxathisia> I enjoyed the read but I am still stuck :|
13:31:47 <ski> @check \b -> property b == b
13:31:48 <lambdabot>        add an instance declaration for (Arbitrary Property, Show Property)   ...
13:32:02 <ddarius> faxathisia: Which and stuck where?
13:32:41 <faxathisia> ddarius: I liked those docs, really interesting but I think I described the problem I had badly
13:34:02 <faxathisia> ddarius: basically this is what I am stuck on http://img229.imageshack.us/img229/2059/picture1dg1.png
13:34:42 <ddarius> faxathisia: In what way are you stuck?
13:35:09 <faxathisia> just in writing the actual haskell code to evaluate this set of rules
13:35:39 <faxathisia> I already got every other language construct
13:36:48 <ddarius> View the  _expr e  v as a notational variant of let v = evalExpr e 
13:39:32 <faxathisia> do you think that the entire thing 'from e1 do s1 loop s2 until e2' is skipped in the case that e1 evaluates to false?
13:39:42 <faxathisia> or would that be a type error or some kind of runtime error
13:40:02 <ddarius> Presumably it is skipped.
13:40:15 <ddarius> Essentially, those would correspond roughly to guards
13:41:19 <faxathisia> ok that makes sense :)
13:41:53 <faxathisia> is it clear though, how to determine whether to run Loop1Base or Loop1Rec?
13:41:57 <ddarius> Is there another rule for _stmt on from ...
13:42:12 <faxathisia> no this everything relating to frmo do loop until
13:43:44 <ddarius> faxathisia: Technically, no.
13:44:56 <ddarius> But presumably the intent is to try Loop1Rec before falling back onto Loop1Base
13:45:12 <faxathisia> ohh
13:45:14 <faxathisia> I see
13:45:25 <faxathisia> Alright, I'll try to do that, thanks very much :D
13:45:50 <ddarius> As far as I can tell from what you've provided though, there is nothing stopping you from always using Loop1Base.
13:46:08 <ddarius> (or both even)
13:46:50 <faxathisia> since Loop1Base always succeeds then, is-true? v2, will be the thing which forces entry into the central recursion
13:47:19 <faxathisia> and from then, the recursion rules themselves have a similar guard to force more recursion
13:47:23 <faxathisia> it seems.. form what you said
13:47:30 <faxathisia> which does seem quite reasonable
13:47:38 <faxathisia> as an interpretation of this
13:49:36 <bakert> ?hoogle a -> a -> [a] -> Int
13:49:42 <lambdabot> No matches, try a more general search
13:49:45 <bakert> ?hoogle a -> a -> [a] -> Bool
13:49:45 <lambdabot> No matches, try a more general search
13:50:01 <ddarius> Actually, I guess LoopMain stops you from using Loop1Base except in the appropriate cases.
13:50:08 <ddarius> Namely the second is-true? there
13:51:59 <oerjan> bakert: what are you looking for? (not elem or elemIndex, which take only one a?)
13:52:15 <bakert> oerjan: i want to know which of two elements comes first in a list
13:52:29 <oerjan> oh
13:52:36 <ddarius> bakert: You could use find for that.
13:52:37 <faxathisia> Does this sound a reasonable implementation then..
13:52:50 <oerjan> are you sure they are both in the list?
13:52:53 <bakert> yes
13:53:03 <faxathisia> I can have a rule for each clause, which is returning a Maybe type
13:53:23 <faxathisia> for dealing with guards?
13:53:27 <oerjan> > elemIndex 3 . dropWhile (/= 4) $ [1..10]
13:53:28 <lambdabot>  Nothing
13:53:35 <oerjan> > elemIndex 3 . dropWhile (/= 2) $ [1..10]
13:53:35 <lambdabot>  Just 1
13:53:46 <MisterN> > dropWhile (/= 2) $ [1..10]
13:53:46 <lambdabot>  [2,3,4,5,6,7,8,9,10]
13:53:54 <bakert> interesting
13:53:55 <MisterN> > dropWhile (/= 4) $ [1..10]
13:53:56 <lambdabot>  [4,5,6,7,8,9,10]
13:54:00 <bakert> or i can fromJust on a find
13:54:15 <TSC> fromJust on elemIndex might be more useful
13:54:19 <bakert> or i can compare two elemIndex's
13:54:29 <bakert> :t elemIndex
13:54:30 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
13:54:44 <bakert> :t find
13:54:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:54:49 <bakert> same difference
13:54:53 <TSC> ?
13:54:55 <bakert> oh no
13:54:59 <bakert> it is better with find
13:55:00 <TSC> find doesn't give the index (:
13:55:09 <bakert> oh yeah
13:55:11 <bakert> :)
13:55:19 <bakert> i was thinking it was going to return the first one
13:55:25 <oerjan> > head . find (`elem` [3,4]) $ [1..10]
13:55:27 <bakert> i would have to say (== a || == b)
13:55:32 <bakert> as the f
13:55:34 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe a1'
13:55:38 <TSC> Oh, yeah, you could do that
13:55:57 <oerjan> > find (`elem` [3,4]) $ [1..10]
13:55:57 <ddarius> faxathisia: Usually each "judgement" _whatever will correspond to a function.  If you want to return a Maybe value then one of them would have to return a Maybe value in it's type.  That said, you shouldn't need to do that, it should work out being the "obvious" code for implementing a loop.
13:55:57 <lambdabot>  Just 3
13:56:07 <bakert> oerjans are getting better :)
13:56:37 <faxathisia> ddarius: There is no obvious code for me
13:56:46 <oerjan> > fromJust . find (`elem` [3,4]) $ [1..10]
13:56:46 <lambdabot>  3
13:56:49 <ddarius> !paste
13:56:49 <hpaste> Haskell paste bin: http://hpaste.org/
13:58:29 <bakert> before a b ss = (fromJust $ find (`elem` [a, b]) ss) == a
13:58:56 <bakert> thanks oerjan.
14:15:20 <hpaste>  dikini pasted "can you give me any critique on this, please" at http://hpaste.org/4051
14:15:29 <hpaste>  ddarius pasted "semantics" at http://hpaste.org/4052
14:16:34 <dikini> it is for safer 'erlang style' processes, MBox is just a wrapper around Chan
14:17:19 <Botje> dikini: why the IO (IO c) ?
14:17:27 <Botje> if you leave off the return it's IO c
14:17:53 <dikini> yep, that's a typo on me :(
14:18:03 <RayNbow> @src all
14:18:03 <lambdabot> all p =  and . map p
14:18:25 <dikini> I copied the types from ghci to remind me what am I to do later :)
14:18:36 <RayNbow> @src and
14:18:36 <lambdabot> and   =  foldr (&&) True
14:20:22 <bakert> :t all
14:20:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:20:36 <bakert> > all (== 3) [1,2,3]
14:20:40 <lambdabot>  False
14:20:46 <bakert> > all (== 3) [3,3,3]
14:20:46 <lambdabot>  True
14:20:51 <bakert> well ain't that neat
14:22:42 <Olathe> > (repeat 1) ++ [3]
14:22:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:23:07 <sieni> > 7 + 2
14:23:07 <lambdabot>  9
14:23:35 <mauke> > 1/3 + 1/3 + 1/3 + 1/3 :: Rational
14:23:35 <lambdabot>  4%3
14:25:03 <augustss> @src all
14:25:03 <lambdabot> all p =  and . map p
14:26:54 <ddarius> faxathisia: I'm wondering if the first is-false? and perhaps the second in Loop2Rec should be is-true?
14:27:20 <faxathisia> ddarius: in your paste or in the diagram?
14:29:11 <Olathe> > foldr ((++) . repeat) [] [1..]
14:29:19 <ddarius> faxathisia: In the diagram.
14:29:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:29:42 <ddarius> faxathisia: I.e. I would think it would look like LoopMain
14:32:35 <Olathe> > cycle $ foldr ((++) . repeat) [] [1..10]
14:32:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:32:38 <Olathe> > cycle $ foldr ((++) . repeat) [] [1..]
14:32:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:32:45 <Olathe> Take that, enumerability !
14:33:55 * oerjan hands Olathe some transfinite ordinals
14:34:45 * monochrom loves omega+1 i.e. +1
14:42:02 <ddarius> I'm feeling more confident that it should be.
14:43:45 <faxathisia> hmm
14:43:49 <faxathisia> you know I hope so :D
14:44:08 <faxathisia> cause them I could blame my confusion on it
14:54:10 <hpaste>  ddarius annotated "semantics" with "let's be more direct" at http://hpaste.org/4052#a1
14:54:37 <ddarius> faxathisia: I'm pretty sure that annotation is faithful to the diagram.
14:55:08 <faxathisia> should they both recurse into evalLoop2?
14:55:25 <ddarius> Er no.
14:56:30 <hpaste>  ddarius annotated "semantics" with "fixed" at http://hpaste.org/4052#a2
14:58:47 <ddarius> Well it might not be quite faithful.
14:59:36 <Heziva> Hello augustss sorry to bother you again....
14:59:55 <augustss> yes?
15:00:21 <Heziva> I've sent you a pm...
15:01:01 <geocalc> hovasy
15:02:04 <faxathisia> ddarius: so you compose Loop1Base and Loop1Rec together?
15:02:48 <ddarius> faxathisia: Yes.  As I said, usually each judgement is it's own function and the different uses of it are clauses/cases of that function.
15:04:09 <waern> you mean "cabal whatsnew" :-)
15:04:13 <waern> oops
15:04:29 <waern> wrong window
15:05:56 <dibblego> let ifEmptyElse [] b _ = b; ifEmptyElse xs _ f = f xs -- what's a nicer way of writing this? can MonadZero help?
15:06:49 <ddarius> faxathisia: Anyway, as written the code will execute an arbitrary number of statements to get state s'', but then might throw those mutations away if evalExpr e1 s'' is True.  This is odd.
15:07:09 <Olathe> let ifEmptyElse [] b _ = b; ifEmptyElse _ _ c = c
15:07:12 <Olathe> Oh.
15:07:15 <ddarius> (also with these changes the code is no longer tail recursive which is also odd.)
15:07:18 <Olathe> Never mind.
15:07:55 <faxathisia> ddarius: The entire language is reversible so every construct has an inverse (I already have a program inverter for example) so that should explain no TCO and hopefully other oddness?
15:08:33 <ddarius> faxathisia: In English, what are the semantics of the from e1 do s1 loop s2 until e2 statement?
15:09:43 <hpaste>  faxathisia annotated "semantics" with "textual description" at http://hpaste.org/4052#a3
15:10:11 <hpaste>  faxathisia annotated "semantics" with "textual description (fixed ligature problems)" at http://hpaste.org/4052#a4
15:10:22 <faxathisia> that's just directly from this paper
15:10:40 <faxathisia> I don't really understand it because it seems to contradict the operational semantics :|
15:17:33 <ddarius> Well that explains one question I was having.
15:24:28 <ddarius> faxathisia: Anyway, one of my points with my first "odd" comment is that we don't need that second check if we already know evalExpr e1 s'' will be False.
15:26:40 <ddarius> That would be the case if Loop2Rec used is-true? instead of is-false? in it's first check (and we always tried Loop2Rec before trying Loop2Base)
15:26:45 <faxathisia> ah
15:27:25 <faxathisia> I think that it is a consistency check.. e.g. if it wasn't how we expected then the program (that I am interpreting) is incorrect (not reversible)
15:28:06 <ddarius> Presumably the language doesn't let you write irreversible programs?
15:28:20 <faxathisia> I think so yeah
15:28:41 <faxathisia> I have got an assertion in if .. fi for that reason
15:28:54 <ski> no `launchNuclearMissiles' ?
15:31:02 <ddarius> Anyway, there should be a way of formulating it where you don't need to save the entire state of the program.
15:41:49 <pitecus> How can I tell ghci where to look for .so files?
15:42:17 <sorear> LD_LIBRARY_PATH?
15:44:31 <pitecus> thanks
16:07:22 <cedricshock> How strong is the Prelude Ord? Is it required that Ord only compare to EQ if the arguments would pattern match?
16:09:09 <oerjan> i don't think so.
16:09:44 <oerjan> after all, parametricity probably implies that if all you know about a type is its Ord instance, you cannot tell if the user has cheated
16:09:45 <scook0> most of the prelude classes don't explicitly specify any laws
16:10:45 <scook0> e.g. there's no explicit requirement that a == b implies (a `compare` b) == EQ
16:10:55 <oerjan> however, i assume that is intended
16:11:03 <oerjan> always to be true
16:11:19 <scook0> indeed
16:11:30 <scook0> but it's curious that it's never mentioned
16:11:51 <oerjan> so i would say, Eq requires an equivalence relation
16:12:06 <oerjan> and Ord should be a total order after you take the quotient by that
16:12:18 <oerjan> ignoring undefined cases
16:13:37 <oerjan> however some of the *By functions have possible useful cases where you don't assume it
16:13:55 <oerjan> e.g. groupBy by something non-reflexive
16:15:07 <oerjan> > groupBy (\c1 c2 -> isAlphaNum c1 && isAlphaNum c2) "is(x2:r5)useful"
16:15:17 <lambdabot>  ["is","(","x2",":","r5",")","useful"]
16:15:45 <oerjan> er that didn't really show it
16:16:04 <oerjan> > groupBy (\c1 c2 -> isAlphaNum c1 && isAlphaNum c2) "((lispy stuff)here)"
16:16:09 <lambdabot>  ["(","(","lispy"," ","stuff",")","here",")"]
16:18:12 <ddarius> I believe it is stated that Ord should be a total order (though that still means that (==) could be something different and this isn't enforced in any way)
16:19:03 <dibblego> ?instances Monoid
16:19:04 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
16:19:15 <dibblego> ?src (a -> b) Monoid
16:19:15 <lambdabot> Source not found. Just try something else.
16:19:37 <oerjan> ?src -> mappend
16:19:37 <lambdabot> Source not found. Take a stress pill and think things over.
16:20:01 <oerjan> (i think that's the right syntax)
16:20:33 <oerjan> i think it just lifts the mappend for b pointwise to a -> b
16:21:18 <ddarius> @src Monoid
16:21:19 <lambdabot> class Monoid a where
16:21:19 <lambdabot>     mempty  :: a
16:21:19 <lambdabot>     mappend :: a -> a -> a
16:21:19 <lambdabot>     mconcat :: [a] -> a
16:21:26 <dibblego> mappend f g x = f x `mappend` g x
16:21:35 <oerjan> > (id `mappend` reverse) "test"
16:21:36 <lambdabot>  "testtset"
16:22:33 * ddarius endeavors to find a case to use mempty as const [
16:22:35 <ddarius> ]
16:24:14 <dibblego> how on earth does mappend take 3 arguments like that?
16:24:27 <ddarius> Set a = b -> c
16:25:50 <oerjan> > ((==)<*>reverse)"testset"
16:25:52 <lambdabot>  True
16:31:18 <noobi1> n
16:31:27 <gwern> I've been wondering. How do you fix the GHC warnings that 'Warning: Defaulting the following constraint(s) to type `Integer'
16:31:33 <vincenz> @type <*>
16:31:34 <lambdabot> parse error on input `<*>'
16:31:38 <vincenz> @type (<*>)
16:31:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:31:40 <vincenz> @type ap
16:31:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:33:14 <noobi1> i want to create a functionn name inlist that test one list against another to see if both list have the same element and if they r in the right pos
16:33:41 <vincenz> 'right' pos?
16:34:11 <noobi1> example test [1,2,3,4][4,2,3,6] would show 2 in right pos and 1 in wrong
16:34:51 <vincenz> and 6?
16:34:56 <vincenz> what about the 6 in there?
16:35:03 <vincenz> your problem is ill-specified
16:35:14 <noobi1> 6 is not in the first list so would be 0
16:35:50 <noobi1> it is like matching it with the first
16:36:21 <cbrad> anyone know how to easily profile an executable that is being build by cabal
16:36:23 <oerjan> we don't usually use 0 as error result in haskell
16:36:30 <noobi1> which is in the right place, wrong and not in the first list
16:36:32 <cbrad> that has the GHC-Options: threaded
16:36:51 <cbrad> given that threaded and profiling don't go together :-)
16:41:17 <noobi1> any help?
16:42:01 <twanvl> noobi1: Do you have an idea for algorithm to do that?
16:42:09 <noobi1> yes
16:42:15 <noobi1> gonna post it
16:42:32 <oerjan> !paste
16:42:32 <hpaste> Haskell paste bin: http://hpaste.org/
16:45:14 <hpaste>  boob pasted "list" at http://hpaste.org/4053
16:45:30 <noobi1> this is what i have
16:47:01 <oerjan> noobi1: seems to miss an | otherwise case
16:47:31 <noobi1> don't know what to put
16:47:48 <oerjan> er, i guess you need x < y and x > y cases
16:47:54 <gwern> @pl innerProduct a b = realPart $ a * (conjugate b)
16:47:54 <lambdabot> innerProduct = (realPart .) . (. conjugate) . (*)
16:48:08 <gwern> @pl padding pad minLen str = replicate (minLen - length str) pad ++ str
16:48:09 <lambdabot> padding = flip flip id . (liftM2 (++) .) . flip (flip . (replicate .) . (. length) . (-))
16:48:32 <hpaste>  noob annotated "list" with "list" at http://hpaste.org/4053#a1
16:50:47 <noobi1> i want to find which is in the list but wrong position
16:51:06 <oerjan> noobi1: i think you might want to write a function to separate the lists in three parts, one with everything in common at the right position and the others what's left of each list.
16:51:20 <noobi1> how?
16:52:03 <oerjan> it would resemble white' somewhat
16:52:09 <oerjan> but return a triple
16:52:31 <mgsloan> > let pig = concatMap ((\(a, b) -> b ++ a ++ "ay ") . break (flip elem "aeiou")) . words in pig "hello world"
16:52:33 <lambdabot>  "ellohay orldway "
16:52:35 <oerjan> once you have that function, you can pass the leftovers to w
16:53:05 <hpaste>  noob annotated "list" with "list" at http://hpaste.org/4053#a2
16:53:19 <ddarius> Hmm.  The "Microsoft school" of functional programming will be... interesting.
16:55:03 <noobi1>  oerjan: how do i separate it
16:55:13 <oerjan> noobi1: say occurs [1,2,3,4] [4,2,3,6] should return ([2,3],[1,4],[4,6])
16:56:08 <noobi1> ??
16:56:11 * mgsloan thinks you must have transposed your [ and ( in that return value..
16:56:16 <noobi1> don't understand
16:56:32 <oerjan> i.e. the first part of the triple is the list of everything in the right place
16:56:43 <oerjan> the second part, the leftovers from the first list
16:56:48 <mgsloan> oh
16:56:51 <mgsloan> nevermind then
16:56:57 <oerjan> the third part, the leftovers from the second list
16:57:07 <noobi1> ok
16:58:50 <noobi1> so ow do i go about doing it?
16:58:52 <ddarius> What is the origin of pig latin?
16:59:07 <mgsloan> ?wikipedia pig latin
16:59:07 <lambdabot> No Result Found.
17:00:05 <oerjan> you use recursion similar to the occurs you already have, but building triples instead of numbers
17:00:21 <ddarius> This guy is more insane than I thought.
17:01:22 <oerjan> you will probably want a pattern match for the recursion: where (match, left1, left2) = occurs xs ys
17:03:22 <noobi1> could u give me a sample code to work with?
17:03:27 <oerjan> then you need to return a similar triple, but with x and y added in
17:03:53 <oerjan> i'll give you the x == y line
17:04:17 <oerjan>    | x==y = (x:match, left1, left2)
17:05:57 <gwern> @src fromInteger
17:05:57 <lambdabot> Source not found.
17:06:28 <geocalc> @src chr
17:06:28 <lambdabot> Source not found. It can only be attributed to human error.
17:06:35 <gwern> strange. it's supposed to be in the Prelude
17:06:45 <mgsloan> fromInteger is defined in instances
17:06:59 <oerjan> it's just toEnum with restricted type
17:07:09 <oerjan> (chr that is)
17:07:12 <ddarius> Jeezum crow!
17:07:16 <noobi1> i did this to get the corret
17:07:21 <noobi1> pos
17:07:23 <noobi1> white [] [] = []
17:07:24 <noobi1> white (x:xs) (y:ys)
17:07:24 <noobi1> 			|(x == y) = x : y : (white xs ys)
17:07:24 <noobi1> 			|otherwise = white xs ys
17:08:13 <geocalc> ?
17:08:31 <Brian``> @src StdGen
17:08:32 <lambdabot> Source not found.
17:08:36 <oerjan> noobi1: ok, you are doing something entirely different from what i suggested
17:08:38 <Brian``> @src RandomR
17:08:38 <lambdabot> Source not found. :(
17:08:42 <hpaste>  (anonymous) annotated "list" with "(no title)" at http://hpaste.org/4053#a3
17:08:42 <Brian``> @src randomR
17:08:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:08:46 <mgsloan> gwern - also, the base numeric instances are internal
17:09:02 <gwern> @pl rleDecode a = show $ concatMap (uncurry replicate) a
17:09:02 <lambdabot> rleDecode = show . (uncurry replicate =<<)
17:09:18 <gwern> it never fails to amaze me how a list is a monad
17:09:26 <noobi1> import Data.List
17:09:26 <noobi1> white [] [] = []
17:09:26 <noobi1> white (x:xs) (y:ys)
17:09:26 <noobi1> 			|(x == y) = x : (white xs ys)
17:09:26 <noobi1> 			|otherwise = white xs ys
17:09:48 <noobi1> this gets the right position
17:10:40 <oerjan> yep, that calculates the list i suggested would be the first part of the triple
17:12:05 <oerjan> but you need to get the leftover parts in order to pass them to w
17:13:27 <oerjan> i guess you can calculate them with two different functions if you want
17:13:27 <ddarius> @seen dons
17:13:27 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 4h 25m 55s ago.
17:14:22 <oerjan> noobi1: basically write a function just like your white, except it keeps x if it's _different_ from y
17:15:01 <geocalc> white [] (y:ys) = ?
17:15:07 <noobi1> ok
17:16:38 <noobi1> i use /= to get values other matchin
17:16:45 <oerjan> yep
17:17:09 <geocalc> for the subset problem you have more todo
17:17:37 <oerjan> not much more, that function + w gives nearly all he needs
17:19:11 <geocalc> i mean the 1 million dollars subset problem
17:19:42 <gwern> > read "1" :: Int
17:19:44 <lambdabot>  1
17:19:51 <gwern> > read "11111" :: [Int]
17:19:52 <lambdabot>  Exception: Prelude.read: no parse
17:20:27 <geocalc> map it
17:20:33 <noobi1> white [1,2,3,6][5,2,3,1], i got [1,6]
17:20:41 <oerjan> or use digitToInt
17:20:51 <mgsloan> > (map read . words) "11 12 13" :: [Int]
17:20:52 <lambdabot>  [11,12,13]
17:21:05 <oerjan> noobi1: good, er btw i meant you to keep the original white as _well_
17:21:09 <oerjan> you need both
17:21:27 <gwern>  > (map read . words) "11,12,13" :: [Int]
17:21:42 <gwern> guess words doesn't split on punctuation then?
17:21:47 <oerjan> nope
17:21:53 <oerjan> however
17:22:02 <mgsloan> you had a space before >
17:22:04 <oerjan> > read "[11,12,13]" :: [Int]
17:22:05 <lambdabot>  [11,12,13]
17:22:10 <mgsloan> LB should really strip away preceding whitespace..
17:22:16 <mgsloan> hehe
17:22:20 <gwern> oerjan: ah. that is good, yes
17:23:21 <noobi1> can i use the elem function to check the 5?
17:23:56 <oerjan> noobi1: just call your function with the arguments switched, should give you [5,1]
17:23:58 <noobi1> elem 5 [1,2,3,6]
17:24:19 <oerjan> noobi1: well yes you can do that too
17:24:26 <noobi1> args switched?
17:25:06 <oerjan> if white [1,2,3,6][5,2,3,1] == [1,6] then white [5,2,3,1][1,2,3,6] == [5,1] i assume
17:25:33 <noobi1> ok
17:26:00 <gwern> @src (&&&)
17:26:00 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
17:26:19 <oerjan> there are some set functions in Data.List if you may use them
17:26:28 <noobi1> i want to return a integer
17:26:41 <noobi1> length of the list
17:26:53 <oerjan> > [1,6] `intersect` [5,1]
17:27:04 <lambdabot>  [1]
17:27:15 <dibblego> > [1,6] `intersect` [5,4,1]
17:27:15 <lambdabot>  [1]
17:27:17 <oerjan> noobi1: it's easy to apply length after you have found the list you want
17:27:53 <noobi1> ok
17:27:56 <oerjan> > length [1,6]
17:27:57 <lambdabot>  2
17:27:58 <liyang> But that's morally corrupt! Lists aren't sets!
17:29:21 * oerjan hands liyang some rosy glasses
17:29:32 <Pseudonym> For some access patterns, lists are a good representation of sets.
17:29:45 <Pseudonym> But yeah.  Better to newtype-wrapper it.
17:30:04 <Olathe> > let green = green' 0 where green' n (x:xs) (y:ys) = green' (n + (if x == y then 1 else 0)) xs ys; green' n _ _ = n in green [1,2,3,6] [5,2,3,1]
17:30:19 <lambdabot>  thread killed
17:30:22 <oerjan> > [3,2,1] `intersect` [1,2,5]
17:30:22 <lambdabot>  [2,1]
17:30:24 <Olathe> > let green = green' 0 where green' n (x:xs) (y:ys) = green' (n + (if x == y then 1 else 0)) xs ys; green' n _ _ = n in green [1,2,3,6] [5,2,3,1]
17:30:24 <lambdabot>  2
17:30:41 <Olathe> > let green = green' 0 where green' n (x:xs) (y:ys) = green' (n + (if x == y then 0 else 1)) xs ys; green' n _ _ = n in green [1,2,3,6] [5,2,3,1]
17:30:42 <lambdabot>  2
17:30:56 <liyang> If you could put an ordering on the elements, best to use Data.Set instead. :3
17:31:46 <Olathe> > let green = green' 0 where green' n (x:xs) (y:ys) = green' (if x == y then n else n + 1) xs ys; green' n _ _ = n in green [1,2,3,6] [5,2,3,1]
17:31:46 <lambdabot>  2
17:31:48 <oerjan> things might get even more complicated if they're multisets
17:32:52 <liyang> um, I think my morally corrupt comment is based around the above usage of lists -- where they're really multisets.
17:33:47 <oerjan> > [1,1,2] `intersect` [1,3,4] -- is this corrupt too?
17:33:48 <lambdabot>  [1,1]
17:34:02 * oerjan needs some rosy glasses himself
17:34:08 <liyang> But anyway, a multiset on X is really X `Map` Integer. (Where again, you need Ord X, at least in Haskell.)
17:34:31 <liyang> oerjan: yes. That is. IMO. :-/
17:34:36 * wli mutters something about intensional ordering.
17:34:41 <Olathe> @where botdeath
17:34:42 * lambdabot dies.
17:34:53 <Olathe> That's the penalty for such immorality !
17:35:36 <Olathe> > let trueIntersect = nub.intersect in [1,1,2] `trueIntersect` [1,3,4]
17:35:46 <lambdabot>  Couldn't match expected type `[a]'
17:35:51 <Olathe> Bah.
17:36:22 <byorgey> > let trueIntersect = (nub.).intersect in [1,1,2] `trueIntersect` [1,3,4]
17:36:23 <lambdabot>  [1]
17:36:28 <Olathe> Lies.
17:36:46 <Olathe> @unpl nub.intersect
17:36:46 <lambdabot> (\ c -> nub (intersect c))
17:36:54 <Olathe> Ahh.
17:37:04 <Olathe> @unpl (nub.).intersect
17:37:04 <lambdabot> (\ d g -> nub (intersect d g))
17:37:10 <byorgey> or, if you prefer:
17:37:22 <byorgey> > let trueIntersect = ((.).(.)) nub intersect in [1,1,2] `trueIntersect` [1,3,4]
17:37:23 <lambdabot>  [1]
17:37:23 <oerjan> otoh a multiset intersect is exactly what noobi1's w function does...
17:37:39 <liyang> > [1,1,2,3] `intersect` [1,1,2,2] -- my intuitive defn of intersect on multisets would give [1,1,2] (but not necessarily in that order.)
17:37:40 <lambdabot>  [1,1,2]
17:37:47 <liyang> oh. Wow.
17:38:11 <oerjan> liyang: it's not quite reliable
17:38:21 <oerjan> >  [1,1,2,3] `intersect` [1,2]
17:38:22 <lambdabot>  [1,1,2]
17:38:31 <noobi1> how do i filter out the ones that are not in the sec meaning [1,2,3,4][1,2,3,5] = 5
17:38:43 <liyang> Right. I'm not sure what intersect is doing now.
17:39:05 <noobi1> using the elem function
17:39:11 <oerjan> noobi1: can you use the \\ operator?
17:39:59 <noobi1> ???
17:40:04 <noobi1> how
17:40:23 <oerjan> > [1,5] \\ [1,4]
17:40:29 <lambdabot>  [5]
17:40:51 <noobi1> it should be four
17:41:00 <noobi1>  []//[]
17:41:07 <oerjan> > [1,4] \\ [1,5]
17:41:13 <byorgey> well, just reverse the order
17:41:18 <lambdabot>  [4]
17:41:18 <noobi1> ok
17:41:41 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' [1,1,2,3] [1,1,5,2]
17:41:42 <lambdabot>  [1,1,2]
17:41:52 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' [1,2,5] [1,1,2,3]
17:41:52 <lambdabot>  [1,2]
17:42:01 <Olathe> Take that, nonmultiset intersect !
17:42:08 <wli> > let (x:xs) `iSect` ys | x `elem` ys = x : (filter (/= x) xs `iSect` filter (/= x) ys) | otherwise = filter (/= x) xs `iSect` filter (/= x) ys in [1, 3 .. 27] `iSect` [2, 7 .. 27]
17:42:09 <lambdabot>   Non-exhaustive patterns in function iSect
17:42:33 <liyang> > let mintersect = Map.intersectionWith min in Map.fromList [(1,2),(2,1),(3,1)] `mintersect` Map.fromList [(1,1),(2,1)]
17:42:34 <lambdabot>   Not in scope: `Map.fromList'
17:42:35 <wli> > let (x:xs) `iSect` ys | x `elem` ys = x : (filter (/= x) xs `iSect` filter (/= x) ys) | otherwise = filter (/= x) xs `iSect` filter (/= x) ys ; [] `iSect` _ = [] in [1, 3 .. 27] `iSect` [2, 7 .. 27]
17:42:35 <lambdabot>  [7,17,27]
17:42:43 <liyang> Damn you, lambdabot.
17:42:44 <noobi1> Olathe:  can u make that simple
17:42:49 <Olathe> Make what simple ?
17:43:01 <liyang> > let mintersect = Data.Map.intersectionWith min in Data.Map.fromList [(1,2),(2,1),(3,1)] `mintersect` Data.Map.fromList [(1,1),(2,1)]
17:43:04 <lambdabot>   Not in scope: `Data.Map.fromList'
17:43:05 <oerjan> liyang: > uses M for some reason
17:43:13 <liyang> *sigh*
17:43:29 <liyang> > let mintersect = M.intersectionWith min in M.fromList [(1,2),(2,1),(3,1)] `mintersect` M.fromList [(1,1),(2,1)]
17:43:30 <lambdabot>  fromList [(1,1),(2,1)]
17:43:51 <liyang> That looks reasonable to me. :3
17:44:23 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' [1,1,2,5] [1,2,3]
17:44:24 <lambdabot>  [1,2]
17:45:32 <oerjan> Olathe: that's just noobi1's w function essentially
17:46:24 <noobi1> Olathe, can u make it simpleer
17:46:35 <liyang> (stick it through @pl)
17:47:29 <noobi1> noob basic, something digesive
17:47:33 <noobi1> easily
17:48:12 * liyang reads scrollback to see what noobi1 actually wanted
17:48:19 <cjay> does someone know a library for holding data in a synchronized state over a network?
17:48:55 <cjay> so that a user of that library doesn't need to implement a protocol for keeping data in sync
17:49:05 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in \a b -> intersect' a b == intersect' b a
17:49:06 <lambdabot>  <[Integer] -> [Integer] -> Bool>
17:49:16 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in \a b -> (intersect' a b) == (intersect' b a)
17:49:16 <lambdabot> Unbalanced parentheses
17:49:20 <Olathe> Unbalanced ?
17:50:02 <byorgey> odd
17:50:15 <byorgey> parens look balanced to me...
17:50:30 <Olathe> They are balanced.
17:50:32 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in \a b -> (intersect' a b) == intersect' b a
17:50:32 <lambdabot> Unbalanced parentheses
17:50:43 <Olathe> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in \a b -> intersect' a b == (intersect' b a)
17:50:45 <lambdabot>  <[Integer] -> [Integer] -> Bool>
17:51:02 <Olathe> Moral law 12928321: Never parenthesize intersect' a b !
17:51:24 <liyang> noobi1: if the terminology makes sense to you -- is what you want essentially multiset (or bag) intersection?
17:51:47 <oerjan> > \x -> (null x) == True
17:51:47 <byorgey> Olathe: try running that through QuickCheck?
17:51:49 <lambdabot>  Add a type signature
17:51:55 * liyang isn't sure what `similarities' meant in the hpaste bin
17:52:15 <oerjan> > let y = 2 in \x -> (chr x) == 'a'
17:52:17 <lambdabot>  <Int -> Bool>
17:52:33 <Olathe> byorgey: I was trying to.
17:52:56 <Olathe> But then lambdabot became unbalanced.
17:53:10 <Olathe> I'm worried that if I try to check anything, it will explode.
17:53:12 <byorgey> @check \x y -> let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' x y == (intersect' y x)
17:53:13 <lambdabot>  Add a type signature
17:53:32 <byorgey> @check \(x :: [Integer]) y -> let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' x y == (intersect' y x)
17:53:32 <lambdabot>  Parse error in pattern at "y" (column 19)
17:53:38 <Olathe> @check \x y -> let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' x::[Char] y == (intersect' y x)
17:53:38 <lambdabot>  Parse error at "==" (column 253)
17:53:38 <oerjan> > let y = 2 where z = 4 in \x t -> (chr x) == (chr t)
17:53:39 <lambdabot>  <Int -> Int -> Bool>
17:54:05 <Olathe> @check \x y -> let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in (==) (intersect' x::[Char] y) (intersect' y x)
17:54:05 <lambdabot> Unbalanced parentheses
17:54:09 <Olathe> Lies.
17:54:11 <byorgey> @check \x y -> let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' (x::[Integer]) y == (intersect' y x)
17:54:12 <lambdabot>  OK, passed 500 tests.
17:54:18 <byorgey> \o/
17:55:16 <qwr> Olathe: you should worry, when lambdabot comen unbalanced AND self-aware ;)
17:55:27 <gwern> I have a question. is there any free darcs hosting anywhere? I've hacked a lot on Monadius, cleaning up and cabalizing it, and I'd like to let other people work on itm but I don't have hosting of my own
17:55:35 <qwr> comes
17:55:49 <Olathe> I'm just worried that, if it starts to spin really fast, parts of it will come flying off into the channel.
17:56:07 <byorgey> gwern: there's code.haskell.org
17:56:07 <liyang> Olathe: look, given you're sorting all that stuff and everything, you may as well use a unique representation for your multisets. i.e. Map _ Integer.
17:56:49 <gwern> byorgey: firefox can't connect to http://code.haskell.org/
17:57:01 <byorgey> hmm, yes, it seems to be down ATM =(
17:57:17 <noobi1> trying to get olathe code running using guards but getting a error
17:57:26 <noobi1> intersect' a b = intersect'' (sort a) (sort b)
17:57:27 <noobi1> 			|(a == b) = a: (intersect'' as bs)
17:57:27 <noobi1>                         |(a < b)  = intersect'' as bbs
17:57:27 <noobi1>                         |otherwise = intersect'' aas bs;
17:57:27 <noobi1> 						where intersect'' aas@(a:as) bbs@(b:bs)
17:57:27 <noobi1> 						
17:57:35 <allbery_b> IIRC signup foo is on community.haskell.org (also down)
17:57:38 <gwern> byorgey: well, what's normally there?
17:57:42 <noobi1> what's wrong?
17:57:56 <byorgey> noobi1: you can't have any expressions before the guard like that.
17:57:59 <Olathe> noobi1: The guards are for intersect'', not intersect'.
17:58:17 <liyang> (What's wrong? The definition is too long.)
17:58:36 <byorgey> gwern: free haskell project hosting =)
17:58:57 <Olathe> liyang: That sounds like a good idea.
17:59:01 <Olathe> Let's see.
17:59:05 <byorgey> gwern: you can request an account at http://community.haskell.org/admin/account_request.html  (when it comes back up)
17:59:09 <noobi1> ??
17:59:23 <gwern> any idea when it'll come back up?
17:59:41 <byorgey> no.  I'm not even sure who's in charge of it.
17:59:48 <hpaste>  olathe pasted "your function - please anotate" at http://hpaste.org/4054
17:59:55 <byorgey> heck, I'm not even sure where it's physically located.  Galois perhaps?
17:59:57 <gwern> oh. that's not good.
18:00:04 <Olathe> I pasted that ?
18:00:08 <noobi1> please state where the errs are
18:00:10 <Olathe> I don't remember pasting that.
18:00:22 <noobi1> i was rewriting it
18:00:28 <byorgey> Olathe: hpastes are not authenticated. =)
18:00:29 <noobi1> using ur name, sorry
18:00:30 <gwern> ping claims it's at community.haskell.org or 72.249.126.23
18:01:00 <noobi1> can u edit it to work please
18:01:05 <gwern> looks like somewhere in texas?
18:01:27 <gwern> (dallas is in the hostname of the last few hops)
18:02:09 <gwern> intersect'' (sort a) (sort b)  <-- weird, can you do that? Have arbitrary functions in the args?
18:02:11 <oerjan> > i'' (i') -- minimalized bug
18:02:11 <lambdabot> Unbalanced parentheses
18:03:15 <ddarius> > (i')
18:03:15 <lambdabot>   Not in scope: `i''
18:03:24 <liyang> > let massage = map (flip (,) 1) ; whip = concatMap (uncurry replicate) ; mintersect x y = whip $ M.intersectionWith min (massage x) (massage y) in [1,1,2,5] `mintersect` [1,2,1,3]
18:03:25 <lambdabot>  Couldn't match expected type `M.Map k a'
18:03:26 <ddarius> > i'(i')
18:03:26 <lambdabot>   Not in scope: `i''
18:03:29 <ddarius> > i''(i')
18:03:29 <lambdabot> Unbalanced parentheses
18:03:53 <oerjan> i told you i'd minimalized it :D
18:04:18 <ddarius> > ' '(i')
18:04:18 <lambdabot>   Not in scope: `i''
18:04:25 <ddarius> > ''(i')
18:04:25 <lambdabot>  Improperly terminated character constant at "''(i'..." (column 1)
18:04:28 <liyang> > let massage = M.fromList . map (flip (,) 1) ; whip = concatMap (uncurry replicate) . M.toList ; mintersect x y = whip $ M.intersectionWith min (massage x) (massage y) in [1,1,2,5] `mintersect` [1,2,1,3]
18:04:29 <lambdabot>  [1,1,1]
18:04:36 <liyang> :3
18:04:40 <liyang> That went a bit wrong.
18:05:09 <liyang> > let massage = M.fromList . map (flip (,) 1) ; whip = concatMap (uncurry (flip replicate)) . M.toList ; mintersect x y = whip $ M.intersectionWith min (massage x) (massage y) in [1,1,2,5] `mintersect` [1,2,1,3]
18:05:11 <lambdabot>  [1,2]
18:05:21 <liyang> (and so did that.)
18:06:10 <noobi1> how can i recursively do something eight times
18:06:45 <oerjan> > iterate (+1) 5 !! 8
18:06:47 <lambdabot>  13
18:07:03 <noobi1> i IO
18:07:08 <noobi1> it's a IO
18:07:15 <dibblego> :t iterate
18:07:16 <oerjan> replicateM
18:07:20 <lambdabot> forall a. (a -> a) -> a -> [a]
18:07:50 <oerjan> > runWriter $ replicateM 8 $ tell "hi"
18:07:54 <lambdabot>  ([(),(),(),(),(),(),(),()],"hihihihihihihihi")
18:08:36 <oerjan> > runWriter $ replicateM_ 8 $ tell "hi"
18:08:37 <lambdabot>  ((),"hihihihihihihihi")
18:08:45 <noobi1> can i say in haskell count = 0 in haskell in a IO do while count /= 8 count = count +1
18:09:02 <oerjan> (i use tell and the Writer monad only because lambdabot doesn't do IO)
18:09:18 <noobi1> hears the code
18:09:23 <oerjan> @faq
18:09:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:09:27 <noobi1> i want it to do seven times
18:09:40 <oerjan> although it doesn't necessarily mean it's a good idea
18:09:59 <oerjan> noobi1: replicateM_ might be what you want
18:10:14 <hpaste>  noob pasted "do know how to iterate, please help" at http://hpaste.org/4055
18:10:34 <noobi1> look at the code and anotate please
18:10:56 <ddarius> http://channel9.msdn.com/ShowPost.aspx?PostID=358968 Get your OO-style hype for FP!
18:10:57 <lambdabot> Title: Brian Beckman: Don't fear the Monads
18:11:39 <noobi1> help!!! please
18:12:15 <noobi1> i need it to do it 8 times, then ask the user if the want to start over or type e to end
18:12:17 <noobi1> please
18:12:19 <liyang> > let massage = foldr (uncurry $ Data.Map.insertWith (+)) Data.Map.empty . map (flip (,) 1) ; whip = concatMap (uncurry $ flip replicate) . Data.Map.toList ; mintersect x y = whip $ Data.Map.intersectionWith min (massage x) (massage y) in [1,1,2,5] `mintersect` [1,2,1,3]
18:12:24 <lambdabot>   Not in scope: `Data.Map.intersectionWith'
18:12:53 <liyang> > let massage = foldr (uncurry $ M.insertWith (+)) M.empty . map (flip (,) 1) ; whip = concatMap (uncurry $ flip replicate) . M.toList ; mintersect x y = whip $ M.intersectionWith min (massage x) (massage y) in [1,1,2,5] `mintersect` [1,2,1,3]
18:12:54 <lambdabot>  [1,1,2]
18:12:59 <liyang> Grr.
18:13:04 <liyang> Bed. Night night.
18:13:06 <oerjan> argh! pressing esc removed everything i wrote
18:13:44 <liyang> I developed a strong hatred for computers a long time ago. It's something I encourage others in.
18:14:56 <oerjan> noobi1: the simplest is probably to make tries and argument to the mastermind function
18:15:20 <noobi1> can u aid me in doing this
18:15:31 <noobi1> u could anotate ur advice
18:17:37 <noobi1> r u helping?
18:17:51 <hpaste>  oerjan annotated "do know how to iterate, please help" with "adding parameter" at http://hpaste.org/4055#a1
18:18:41 <oerjan> there were some tabs in it, may have messed up indentation
18:19:03 <oerjan> also i don't think it handles the final return value right
18:19:07 <qwr> noobi1: iteration is a special case of recursion ;)
18:19:15 <noobi1> thats cool
18:20:15 <noobi1> does the user have to enter the amount of tries?
18:21:00 <oerjan> only if you want to
18:21:22 <noobi1> i dont want them to
18:21:56 <oerjan> just call mastermind atries from the main function or something, i guess
18:22:15 <oerjan> er...
18:23:16 <noobi1> getting an error
18:25:25 <oerjan> do you want the mastermind function to return the list of guesses at the end?  some of the branches do, some don't
18:25:40 <noobi1> no just loop
18:25:45 <oerjan> ok
18:25:45 <noobi1> 8 times
18:27:20 <qwr> mapM_ (const mastermind) [1..8]
18:27:52 <oerjan> qwr: with an exit check
18:27:54 <noobi1> how?
18:27:59 <ddarius> replicateM 8 mastermind
18:28:09 <noobi1> please just anotate
18:28:12 <ddarius> Well replicateM_ if it exists
18:28:14 <ddarius> :t replicateM
18:28:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:28:18 <ddarius> :t replicateM_
18:28:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
18:28:19 <noobi1> i learn better with codes
18:28:21 <ddarius> Yay
18:28:27 <hpaste>  oerjan annotated "do know how to iterate, please help" with "closer to correct?" at http://hpaste.org/4055#a2
18:28:58 <oerjan> i removed the tabs for reduced frustration :)
18:29:00 <lekro> is the "hFlush stdout" necessary?
18:29:51 <oerjan> lekro: probably not, but i am not sure if line buffering is guaranteed
18:29:54 <noobi1> nope
18:30:38 <noobi1> i don't want to have to enter mastermind 8
18:30:48 <noobi1> just mastermind
18:30:51 <oerjan> *sigh*
18:31:07 <noobi1> please help me
18:31:17 <noobi1> and i won't bother u guys any more
18:31:47 <hpaste>  oerjan annotated "do know how to iterate, please help" with "thus?" at http://hpaste.org/4055#a3
18:32:35 <oerjan> you might want to move the initial banner printing from loop to mastermind
18:32:38 <oerjan> *mmloop
18:33:25 <geocalc> sure
18:33:48 <noobi1> just want to say thanks to u all for helping
18:33:53 <noobi1> sorry for being a nag
18:34:17 <geocalc> nag !
18:34:32 <noobi1> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' [1,1,2,5] [1,2,3]
18:34:36 <lambdabot>  [1,2]
18:35:15 <noobi1> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' [1,1,2,5] [1,2,3,6]
18:35:18 <lambdabot>  [1,2]
18:35:55 <noobi1> > let intersect' a b = intersect'' (sort a) (sort b) where intersect'' aas@(a:as) bbs@(b:bs) = if (a == b) then a:(intersect'' as bs) else if (a < b) then intersect'' as bbs else intersect'' aas bs; intersect'' _ _ = [] in intersect' [1,2,3,5] [1,2,3,6]
18:35:57 <lambdabot>  [1,2,3]
18:36:08 <geocalc> http://www.nag.com/
18:36:08 <lambdabot> Title: Numerical Algorithms Group
18:36:27 <thoughtpolice> hm, anybody want to give me some criticisms here? http://programming.reddit.com/info/6189y/comments/
18:36:46 <thoughtpolice> in particular i feel the shunting yard algo is kind of contrived but anything's appreciated.
18:36:58 <thoughtpolice> er, convoluted. i feel it could have been done better
18:39:24 <ddarius> thoughtpolice: 503
18:40:36 <geocalc> http://www.cs.utexas.edu/users/flame/
18:40:36 <lambdabot> Title: FLAME Homepage
18:40:56 <thoughtpolice> ddarius: http://programming.reddit.com/info/6189y/comments/ ?
18:41:37 <noobi1> how long before a banned is lifted?
18:41:56 <reffje> they never get lifted
18:42:14 <noobi1> banned 4 life
18:42:16 <noobi1> ?
18:42:32 <geocalc> lol
18:42:32 <reffje> oh wow, actually it seems like my bans were lifted
18:42:36 <reffje> so i guess they do get lifted
18:42:51 <reffje> but they were there for a long time
18:42:57 <Lycurgus> did your IP change>
18:43:05 <reffje> they banned my nickname
18:43:06 <Lycurgus> s/>/?/
18:43:10 <reffje> but i changed nickname
18:43:17 <sjanssen> every once and a while, an op will go through and delete stale bans
18:43:52 <noobi1> my fren was banned
18:43:57 <ddarius> thoughtpolice: No, the actual site.
18:44:18 <noobi1> even wen he use a diff nickname, it is a ip banned
18:44:37 <thoughtpolice> ddarius: hm. my host has been sketchy lately. :(
18:44:49 <davidL> thoughtpolice: did you get my email? :-]
18:45:10 <sjanssen> noobi1: who is your friend?
18:45:27 <thoughtpolice> davidL: yeah, on the snarf length note I haven't looked into it, admittingly.
18:45:32 <noobi1> ferron
18:45:40 <thoughtpolice> davidL: i accept patches though. haven't worked on that sniffer in a while, really
18:45:45 <noobi1> codename n00b
18:45:52 <geocalc> i saw once a fai ban
18:46:00 <thoughtpolice> ddarius: the site seems to fluxuate in and out of 503s, try again in a few minutes is all I can say.
18:46:10 <davidL> thoughtpolice: I'm thinking that the maximum snarf length is the MTU which is generally 1500 so that isn't an issue
18:49:43 <noobi1>  oerjan: is there a way to say you have got n turns left
18:49:59 <noobi1> would (show atries) work?
18:50:37 <geocalc> why not
18:51:03 <noobi1> would it say 8-7-6-5-4-3-2-1
18:51:05 <noobi1> ?
18:51:08 <noobi1> just asking
18:51:48 <geocalc> it should if you want
18:54:45 <noobi1> ok
18:55:55 <oerjan> noobi1: tries not atries
18:56:18 <noobi1> oh sorry
18:56:33 <oerjan> although it would say 7-6-5-4-3-2-1-0
19:00:10 <noobi1> putStrLn "You got" ++ show tries
19:02:10 <Pseudonym> putStrLn ("You got " ++ show tries)
19:02:11 <Pseudonym> Or:
19:02:16 <Pseudonym> putStrLn $ "You got " ++ show tries
19:05:30 <monochrom> printf "You got %d\n" tries
19:06:52 <noobi1> most of u are familiar with the mastermind game right
19:07:06 <noobi1> ??
19:07:10 <monochrom> No.
19:07:29 <geocalc> lol
19:08:01 <dibblego> yeah I play it with my 6 year old
19:08:12 <noobi1> i want to create a function that check two list [1,2,3,4][4,2,3,1] and return the length of those that in a the first list but in the wrong position
19:08:17 <noobi1> can u help me
19:09:11 <ddarius> thoughtpolice: What was the purpose of the blog post?
19:09:29 <noobi1> [1,2,3,4][4,2,3,1] correct = 2 wrong but in list 1 = length [1,4]
19:09:47 <dibblego> noobi1, you might want a levenshtein distance function
19:09:58 <noobi1> ???
19:10:12 <geocalc> n00b "the return"
19:10:14 <dibblego> noobi1, you're trying to find how much difference is between the two lists, right?
19:10:59 <dibblego> maybe not actually
19:11:31 <noobi1> yes
19:12:06 <noobi1> remember if it is in sec list and not in fst it is not valid
19:14:03 <oerjan> noobi1: i thought your second version of the w function did that
19:14:17 <ddarius> thoughtpolice: Pull addStack out and use pattern matching.  If you really don't want it to be top level, push parser' down.
19:14:52 <oerjan> provided you remove those that are in the right position first
19:15:01 <ddarius> thoughtpolice: Alternatively, you can make a big table with all this stuff and have lexer and parser be pretty generic.
19:16:01 <ddarius> thoughtpolice: Something with entries perhaps like ('*',TMul,Multiply,2,gmul)
19:16:15 <thoughtpolice> ddarius: nothing, it was just a random blog on something I thought someone else might find interesting (i've been pretty bored lately)
19:16:18 <geocalc> oerjan=<< i think he want many advices
19:16:18 <noobi1> i want it to show the one's that are in the wrong position
19:16:49 <noobi1> i am getting a prelude.read parse err
19:17:07 <noobi1> what's that?
19:17:36 <geocalc> oops
19:17:41 <oerjan> noobi1: it means you passed a string that doesn't contain a number, or something
19:19:04 <oerjan> to read
19:19:10 <noobi1> i created  a data type
19:19:14 <noobi1> exampe
19:19:15 <ddarius> > read "otsnheau" :: Int
19:19:17 <lambdabot>  Exception: Prelude.read: no parse
19:19:31 <noobi1> data me = Cy | Ty
19:19:44 <noobi1> becuase i wnt to allow lower case values
19:19:48 <noobi1> i did
19:20:12 <noobi1> cy, ty :: me
19:20:20 <noobi1> cy = Cy
19:20:39 <noobi1>  data me = Cy | Ty deriving (read, show)
19:20:46 <noobi1> getting an error
19:20:49 <geocalc> >toLower "2"
19:20:49 <TSC> read "cy" won't work, even then
19:21:03 <geocalc> > toLower "2"
19:21:08 <noobi1> how can i get it to work
19:21:08 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:21:10 <oerjan> unfortunately, deriving Read only considers the actual data definition
19:21:15 <TSC> You could provide your own Read instance to accept lowercase strings
19:21:21 <noobi1> ok
19:21:48 <TSC> For a simple data type like that it should be straightforward
19:22:16 <geocalc> > toLower "237"
19:22:21 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:22:42 <dibblego> ?src mapM_
19:22:42 <lambdabot> mapM_ f as = sequence_ (map f as)
19:22:46 <noobi1> how can i get it to work
19:22:48 <dibblego> ?src sequence_
19:22:49 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:23:10 <dibblego> ?type (>>)
19:23:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:23:14 <davidL> > map toLower "237"
19:23:15 <lambdabot>  "237"
19:23:20 <noobi1> data cannot add lower case values
19:23:47 <TSC> noobi1: Don't change the data declaration; just give your own instance of Read instead of deriving it automatically
19:24:03 <TSC> instance Read Me where read = ...
19:24:20 <TSC> So you provide the translation from a String into a value of your data type
19:24:25 <oerjan> instance Read Me where readsPrec _ (c1:c2:rest) = case map toLower [c1,c2] of "cy" -> (Cy,rest); "ty" -> (Ty,rest)
19:24:27 <noobi1> give me a more definitive example please
19:25:11 <oerjan> er, instance Read Me where readsPrec _ (c1:c2:rest) = case map toLower [c1,c2] of "cy" -> [(Cy,rest)]; "ty" -> [(Ty,rest)]; _ -> []
19:25:37 <oerjan> i think
19:26:45 <thoughtpolice> ddarius: thanks for the input though. first thing i ever wrote that compiled anything, so i went for the simplest solution possible
19:26:51 <noobi1> think
19:27:15 <geocalc> "" toUper ="2"
19:28:04 <hpaste>  noob pasted "help" at http://hpaste.org/4056
19:28:38 <oerjan> noobi1: edit? it looks fine to me
19:28:44 <TSC> noobi1: That's not the most precise question I've ever seen
19:29:06 <ddarius> thoughtpolice: The lexer can probably be simplified to just map toToken . words
19:29:22 <noobi1> i want to be able to enter the values in both lower and uppercase
19:29:32 <noobi1> that is cy or Cy
19:29:42 <noobi1> and it still work
19:31:50 <TSC> noobi1: oerjan gave the code (or close to it) that should do it
19:32:13 <ddarius> thoughtpolice: If you are interested in something more complex, writing a Forth should be reasonbly straightforward and allow you to produce better code.
19:32:56 <lament> writing a forth in haskell?
19:33:10 <ddarius> lament: Using harpy, yes.
19:33:14 <thoughtpolice> ddarius: cool. i've been playing with factor and meaning to read 'thinking forth' anyway so it could be worth a look.
19:33:23 <thoughtpolice> something more advanced with harpy would be fun too
19:35:18 <keseldude> hey
19:35:36 <hpaste>  oerjan annotated "help" with "instance" at http://hpaste.org/4056#a1
19:36:13 <oerjan> noobi1: only works for two-character color names, though
19:36:48 <Sabejias> >2 + 2
19:37:02 <Sabejias> > 2 + 2
19:37:03 <lambdabot>  4
19:37:08 <noobi1> cool
19:37:23 <noobi1> my colors ar only two chr names
19:37:34 <Sabejias> > pi
19:37:39 <lambdabot>  3.141592653589793
19:37:47 <Sabejias> that's amazing
19:37:53 <ddarius> ...
19:38:35 <oerjan> > let fib = 1:1:zipWith(+)fib(tail fib) in fib -- obligatory demonstration
19:38:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:38:49 <Sabejias> > Integrate[x*cosx,x]
19:38:49 <lambdabot>   Not in scope: `x'
19:38:52 <ddarius> > iterate (\x -> x - 0.5*(x-3/x)) 1
19:38:52 <lambdabot>  [1.0,2.0,1.75,1.7321428571428572,1.7320508100147276,1.7320508075688772,1.732...
19:39:12 <Sabejias> > Integrate[x*cosx, x]
19:39:12 <noobi1>  levenshtein distance function, i want to use it to get the wrong positions between fst and snd
19:39:12 <lambdabot>   Not in scope: `x'
19:39:26 <oerjan> Sabejias: it's not Mathematica, but Haskell.  (mbot over at #math has Mathematica too)
19:39:37 <Sabejias> > map Char.toUpper "hello world"
19:39:37 <lambdabot>  "HELLO WORLD"
19:39:57 <Sabejias> ?vixen what is your name?
19:39:57 <lambdabot> My name is Emily
19:40:34 <lament> ?vixen do anonymous functions turn you on?
19:40:34 <lambdabot> fun fun fun!
19:41:54 <oerjan> noobi1: levenshtein distance is not right for the Mastermind _i_ know
19:42:27 <dibblego> noobi1, I retract, you don't want leneshtein
19:42:31 <dibblego> *levenshtein
19:43:44 <oerjan> noobi1: your w function is pretty good for getting the wrong position ones provided you first remove the ones with right position.  hm, actually you don't need to, you could just subtract the numbers
19:44:50 <oerjan> yeah i think w and white together give you what you need
19:45:58 <oerjan> i don't quite remember.  are the white pegs for showing things in wrong position or in right position?
19:46:23 <oerjan> w is sort of all matches, then
19:47:44 <noobi1> i am gone use characters
19:48:17 <oerjan> hm, i looked it up on wikipedia, i don't recall colored pegs only black ones
19:48:32 <dibblego> white is correct position
19:48:49 <noobi1> ["cy","yw","bk","gr"] ["cy","bk","yw","bl"]
19:49:34 <noobi1> 1 red 2 white bl is discarded cuz it is not in the first list
19:49:47 <oerjan> dibblego: wikipedia disagrees
19:50:27 <dibblego> oh crap; that's a slightly different game to the one I was even thinking of
19:51:21 <oerjan> oh wait the picture shows only one color of peg
19:51:39 <oerjan> then it's essentially the same as with black ones
19:51:48 <noobi1> yes
19:52:03 <noobi1> red is the equiv of blck
19:54:24 <noobi1> any help
19:55:04 <oerjan> noobi1: you've got nearly all on hpaste i'll just put it together
19:55:58 <gwern> anyone know whether there's a faster distance formula than sqrt(sq(a-b)+sq(c-d))?
19:56:15 <mgsloan> you can use different norms
19:56:17 <lament> yes, don't take the square root :)
19:56:35 <lament> then you can still compare what's closer
19:56:40 <monochrom> rational trigonometry says don't take the square root too :)
19:56:56 <mgsloan> L1 norm, aka manhatten distance, is (a-b) + (c-d)
19:57:03 <noobi1> ok
19:57:20 <oerjan> mgsloan: don't forget to take abs
19:57:25 <mgsloan> oh, right
19:57:43 <gwern> mgsloan: so how does that differ in meaning from the usual distance formula?
19:57:44 <mgsloan> there's also the Linfinity norm, which is abs(max(a-b, c-d))
19:58:14 <mgsloan> it's a different norm..
19:58:23 <ddarius> gwern: The Manhattan distance is the distance if you could only move EW/NS and not diagonally.
19:58:26 <mgsloan> it's a distance statistic, but its not classical distance
19:58:38 <gwern> ddarius: ah. interesting. so a board-game distance
19:59:10 <mgsloan> err, actually Linfinity is max(abs(a-b), abs(c-d))
19:59:12 <oerjan> noobi1: hm, seems white should be named red instead
19:59:53 <gwern> ok. thanks for the advice
19:59:56 <gwern> night everyone
20:00:54 <hpaste>  oerjan annotated "list" with "summarized" at http://hpaste.org/4053#a4
20:01:33 <mgsloan> heh, I guess L1/2 would be (sqrt(a-b) + sqrt(c-d))^2
20:04:20 <mgsloan> with abs nested in those sqrts
20:04:41 <Pseudonym> Yes.
20:06:38 <noobi1> nice
20:06:40 <noobi1> thanks
20:06:47 <noobi1> i can't believe it
20:07:10 <noobi1> i wrote the code, but didn't know how to put it together, thanks
20:07:27 <oerjan> :)
20:07:35 <Pseudonym> Oh, hang on.
20:07:48 <Pseudonym> L1/2, or in general Lp where p < 1, doesn't obey the triangle inequality.
20:07:52 <int-e> mgsloan: but it wouldn't be a metric, the triangle inequality fails for (0,0), (0,1), (1,1)
20:07:57 <Pseudonym> There you go.
20:08:08 <noobi1> oerjan: hey for the 8 loop, when it ends suppose i want to give the user the choice to restart
20:08:37 <noobi1> the 8 turns what must be added?
20:09:38 <oerjan> noobi1: you can call the mastermind function again
20:09:51 <noobi1> ok
20:10:39 <oerjan> you can do that from itself too
20:12:11 <noobi1> itself
20:12:33 <oerjan> another recursion
20:12:40 <noobi1> putStrLn "do you want to start a new game"
20:12:51 <wli> What's this game stuff?
20:12:52 <noobi1> mmloop (tries-1)
20:13:05 <noobi1> http://hpaste.org/4055
20:13:19 <oerjan> well you would want to read the answer and check it, i guess
20:13:53 <oerjan> not mmloop i think, you can just call mastermind
20:14:04 <geocalc> you can also write "welcome to oerjan mastermind"
20:14:08 <oerjan> it takes care of calling mmloop at the beginning
20:14:19 <noobi1> ok
20:15:10 <noobi1> don't really understand can u anotate?
20:15:39 <noobi1> sorry for botheringu guys
20:15:49 <noobi1> know u have better things to do
20:16:19 <geocalc> @time noobi1
20:16:47 <hpaste>  oerjan annotated "do know how to iterate, please help" with "restart" at http://hpaste.org/4055#a4
20:18:03 <oerjan> @bot
20:18:03 <lambdabot> :)
20:18:50 <noobi1> should i do this after the rest of the code right
20:19:28 <oerjan> i meant that to be the whole mastermind function
20:19:58 <oerjan> the rest is done by mmloop etc.
20:24:29 <wli> Maybe I should try Connect 4 to keep my mind off X until I get some idea of what to do.
20:26:23 <hpaste>  (anonymous) annotated "do know how to iterate, please help" with "(no title)" at http://hpaste.org/4055#a5
20:26:39 <noobi1> look at that
20:26:45 <noobi1> is that ok?
20:27:08 <oerjan> that works too
20:27:35 <dons> ?users
20:27:35 <lambdabot> Maximum users seen in #haskell: 401, currently: 364 (90.8%), active: 12 (3.3%)
20:27:46 <dons> so lambdabot is up
20:28:44 <noobi1> thanks for hwlping me oerjan, even though i have been a pain in the rear
20:28:44 <oerjan> though she seems to have got amnesia again, that number was higher last i noticed
20:31:05 <oerjan> noobi1: perfectly fine, i was just being bored otherwise :)
20:31:25 <wli> What's the LANGUAGE bit to allow signatures in patterns...
20:31:26 <TSC> Yeah, it's been up to 424
20:31:36 <ddarius> dons: Did you actually watch that Brian Beckman video?
20:31:52 <dons> ddarius: i started downloading it, then went off to a thanksgiving dinner
20:31:58 <dons> i read the comments though :)
20:32:03 <oerjan> TSC: it lost that a while ago, down to 418 or something, but now it has fallen again
20:32:28 <dons> ddarius: why?
20:33:10 <Saizan> wli: PatternSignatures
20:33:57 <wli> Does ghc6.6 not recognize it?
20:34:07 <ddarius> dons: OO-style hype for monads.
20:34:37 <Saizan> wli: probably not, i've not seen it until recently
20:35:10 <dibblego> ddarius, I watched it; it's a pretty dumbed down explanation - something we need around here
20:35:51 <dons> ddarius: any news is good news :)
20:35:56 <ddarius> dibblego: Dumbed-down would be okay, but he emphasizes totally the wrong things.  It also doesn't really explain anything.
20:36:17 <ddarius> dons: It is probably better than nothing.
20:36:19 <dons> ddarius: please write a better article, so we can distribute that instead
20:36:23 <dibblego> ddarius, what do you think was emphasised that shouldn't have been?
20:36:31 <dons> history is made by those who blog
20:37:07 <dibblego> ddarius, really, I'm just tired of telling my colleagues to stop forcing me to write the same thing over and over because they don't know what a monad is - so it appeals to me, because it appeals to them
20:38:05 <ddarius> Also, I'm confident that GHC beats C# in speed a lot of time.
20:38:20 <dons> it's a bug if we don't
20:38:33 <wli> Where's the OO-style hype for monads?
20:38:43 <ddarius> @google Beckman on monads
20:38:44 <lambdabot> http://channel9.msdn.com/showpost.aspx?postid=230438
20:38:44 <lambdabot> Title: Brian Beckman: Monads, Monoids, and Mort
20:38:48 <Cale> wli: Check back in 20 years :)
20:38:49 <ddarius> Er not that one.
20:39:08 <ddarius> http://channel9.msdn.com/ShowPost.aspx?PostID=358968
20:39:09 <lambdabot> Title: Brian Beckman: Don't fear the Monads
20:39:18 <salierix> I just watched that.
20:39:23 <Cale> I had to stop watching that halfway through
20:39:53 <wli> Holy cow! MSDN?
20:39:58 <Cale> He's trying so hard, and yet it was just too painful.
20:40:07 <salierix> I have to say that if I didn't already know something about monads it would have made no sense at all.
20:40:11 <ddarius> dibblego: Composability is important, but the kind of closure he was talking about isn't so much in the way we get that.
20:40:20 <dons> i'm just happy seb sylvan is hanging out on reddit
20:40:29 <Cale> salierix: right.
20:40:35 <Pseudonym> Who?
20:40:37 <ddarius> dons: Do you think that's the sylvan in the comments on Channel 9?
20:40:39 <wli> Oh, this is hilarious. A monad tutorial on MSDN.
20:40:39 <Korollary> Cale: I actually quit watching in minute 1 lol
20:40:44 <dons> ddarius: i reckon so
20:40:53 <nuncanada> Monads is just a way to lose structure.... :)
20:41:03 <ddarius> dibblego: Also, purity is more the thing to get composability, not monads.
20:41:08 <dons> yeah, applicatives forever!
20:41:28 <dibblego> ddarius, yeah I agree; I've been trying to hammer home composability in this Scala project that I am working on with a colleague
20:41:32 <Cale> Korollary: yeah, I really care to see what people are saying about the stuff, but oy...
20:41:44 <salierix> wli, there has been a few functional programming videos posted on channel 9 recently.
20:41:46 <dons> re. C#, Haskell speed, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=csharp
20:41:47 <conal> the key to composition is to keep interface (GUI or IO) code separate from functionality.
20:41:47 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2gnksc
20:41:49 <dibblego> ddarius, every once in a while, I use >>= instead of flatMap (aka concatMap) just to scare him :)
20:41:56 <ddarius> Cale: That is why I watch these kinds of things.
20:42:04 <dons> dibblego: :)
20:42:17 <Cale> They should have got Simon to explain.
20:42:21 <ddarius> dibblego: That brings up another thing, if he wanted it why didn't he just define Kleisli composition and talk in terms of that!
20:42:30 <salierix> What? Still no 6.8.1 in gentoo?
20:42:33 <ddarius> Cale: That would be awesome and actually useful even for the "Morts".
20:42:34 <dibblego> ddarius, because that scares people away
20:43:09 <ddarius> dibblego: His whole argument is that (>>=)'s type scares people away because it isn't (>=>)'s type
20:43:17 <ddarius> :t (>=>)
20:43:18 <lambdabot> Not in scope: `>=>'
20:43:20 <Korollary> I'm also getting a bit annoyed with the precursor statements that go "Now because of multicores, we care about FP." Bah.
20:43:30 <ddarius> :t \f g a -> f a >>= g
20:43:32 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
20:43:57 <dibblego> ddarius, perhaps; but if it appeals to the stupids, then it's a good thing afaic
20:44:03 <dibblego> Korollary, me too
20:44:04 <salierix> >>= never confused me... I find that's the easiest part.
20:44:14 <Cale> I think the easiest way to get people fully up to speed about monads is to just explain to them what combinator libraries are about first.
20:44:28 <conal> Korollary: why bah?
20:44:35 <Cale> Because if you don't understand that, it's really what you're going to trip over.
20:44:36 <ddarius> salierix: Indeed, (>>=) is the odd thing.  Kleisli composition is what mathematicians usually use.
20:44:56 <Cale> Or mu and eta directly.
20:45:02 <Cale> (join and return)
20:45:16 <dibblego> I watched someone naturally write >>= in terms of fmap/join the other day
20:45:27 <Cale> x >>= f = join (fmap f x)
20:45:39 <dibblego> i.e. someone who had never heard the term monad
20:45:41 <ddarius> dibblego: I will give him credit for emphasizing "just following the types"
20:45:46 <noobi1> the graphics lib, does it work in winhugs 2006?
20:45:47 <Cale> oh, yes, they can do that :)
20:46:15 <Cale> When I was teaching monads to my girlfriend, she had me turn everything into an exercise, so she did that :)
20:46:50 <Cale> You can basically just use the types to figure it out :)
20:47:06 <Philippa> using >>= everywhere actually shoots some applications right in the foot - it's better if you can do things in a 'first order' manner if you can, because you can do analyses on that
20:47:13 <ddarius> Indeed.  Replace your programmers with @djinn
20:47:25 <wli> Cale: What's this about teacing your girlfriend monads?
20:48:01 <ddarius> dons: This blog series that was linked to in the comments is actually rather good: http://www.atrevido.net/blog/2007/08/12/Practical+Functional+C+Part+I.aspx
20:48:01 <lambdabot> Title: [Giagnocavo]Michael::Write() - Practical Functional C# - Part I, http://tinyurl.com/yw2ten
20:48:02 <Korollary> conal: It's as if they're saying that if it wasn't for performance, they wouldn't touch FP while Haskell & Scheme people have been using it despite past performance issues.
20:48:36 <Cale> wli: She was learning Haskell a while back?
20:48:57 <dons> "we need pure FP for performance reasons" ;)
20:49:07 <conal> Korollary: so they're missing out on the elegance & clarity benefits.
20:49:13 <Cale> dons: we do, and it's so awesome to be able to tell people that :)
20:49:35 <wli> So FP is the next OO, only it's got actual substance behind it.
20:49:48 <Cale> wli: She's another mathy though, so she had a pretty easy time with it. :)
20:49:55 <Korollary> Not until a major FP framework appears imho
20:49:58 <ddarius> wli: OO was better than what preceded it.
20:50:06 <mlh> Cale: so you should turn the exercises into a book and make big bucks
20:50:47 <salierix> I wonder for how many people OO means C++?
20:50:58 <Pseudonym> Almost nobody.
20:51:03 <Pseudonym> For a lot of people it means Java, though.
20:51:06 <Korollary> Java
20:51:39 <conal> before FP catches on, i hope we hurry up and figure out how to do *genuinely* functional programming, rather than this IO stuff.
20:51:41 <Pseudonym> But I know what you mean.  A lot of languages borrowed C++'s object model.
20:51:46 <nuncanada> We have to wait for the Haskell Rails
20:51:52 <salierix> I never had any need to ever learn java.
20:52:09 <Philippa> almost nobody any more, but...
20:52:28 <int-e> conal: do you want to go back to  main :: [Reply] -> [Request] ?
20:52:29 <Philippa> nuncanada: that's going to be a long wait, in many ways good FP's about not needing a single big framework
20:52:52 <conal> int-e: that one didn't work out too well, so no.  something better.
20:53:11 <Cale> I actually don't mind monadic IO, but I sort of think IO should be a GADT.
20:53:18 <conal> int-e: for instance replace that model with functional events & flows.
20:53:26 <Cale> and values typed in IO should be inspectable.
20:53:38 <Philippa> yeah, there's always room for a spare phantom type parameter
20:53:56 <salierix> What do you mean by inspectable?
20:53:57 <Philippa> conal: bad idea. Build that model on top of the IO monad
20:54:22 <ddarius> salierix: Read the Unimo paper.
20:54:26 <Philippa> let the IO monad be in some sense "close to the target platform"
20:54:33 <conal> Philippa: i'm going for semantic tractability, and i don't know how to get that on top of IO.
20:54:37 <Cale> http://hpaste.org/3673 -- like this
20:54:47 <nuncanada> Philippa, nobody needs a big framework, it's more of a social thing, than a real necessity
20:54:55 <Philippa> then you're screwed either way, no? You're stuck with the host platform whatever you do
20:55:25 <Cale> However, I don't know how efficiently one could compile things like that, which makes me a little hesitant about it.
20:55:26 <Philippa> otherwise it's just a matter of runProg :: MyThing -> IO foo
20:55:41 <Cale> But it's at least theoretically doable.
20:56:22 <Philippa> you could build a haskell implementation that did it, and even allowed you to deliberately have non-inspectable composite actions
20:56:45 <Cale> IO as an arrow would be more inspectable. The formulation I have there has the issue that bind takes a function on its right side, so you can't see inside that without applying the function.
20:56:50 <davidL> are there haskell bindings for libpng?
20:56:54 <conal> if i look at the type of main, i know that the program has something to do with the state of the physical universe.  i'd like something a lot more specific.
20:57:39 <Philippa> so look to what the dependent types folks're doing
20:57:45 <salierix> What is the point of Haskell prime if its goals are so minor? Doesn't Haskell already work fine?
20:57:49 <Cale> conal: Well, at least at present, you can formulate restricted monads in terms of IO using the module system.
20:57:58 <Philippa> salierix: what do you mean by Haskell?
20:58:04 <Philippa> Haskell 98? GHC Haskell?
20:58:06 <Cale> salierix: The point is to write down what current implementations are doing.
20:58:22 <Cale> salierix: so that they have some chance of doing something similar to one another
20:58:39 <dons> salierix: it has forced standardisation and documentation and portability, for a start (which is important for commercial use)
20:58:55 <Saizan> are there benchmarks for Control.Concurrent.Chan?
20:59:01 <Cale> It's not to add features. That's what GHC and all the other implementations do on their own. You don't standardise something for which you don't have an implementation.
20:59:13 <dons> Saizan: no. its on top of MVar, which is super fast though
20:59:27 <dons> its really just 2 MVars with a list in each. so what's to benchmark? :)
20:59:33 <Cale> (which is why the specification of typeclasses in Haskell 98 was so conservative)
20:59:45 <salierix> I think it's safe to say that Haskell = GHC at this point.
20:59:54 <Saizan> dons: yes, but i've written a custom variant and wanted to compare :)
21:00:04 <dons> its only a small subset of GHC actually in wide use
21:00:12 <dons> and we've identified a lot of the dodgy parts
21:00:18 <Cale> Sort of, but what GHC? GHC has lots of switches you can turn on and off, many of which do poorly-specified things.
21:00:19 <Philippa> salierix: many of us don't, and think it's thoroughly unsafe for it to end up that way
21:00:44 <Philippa> I don't think SPJ or JaffaCake want to end up BDFLs
21:00:52 <Cale> There are people who want to use Haskell to write programs which they can prove are correct.
21:00:59 <salierix> Philippa, I agree.
21:01:08 <Cale> It's impossible to do that when the implementation isn't bound to following certain rules.
21:01:10 <int-e> dons: it's actually many MVars, there's one in each 'list' element.
21:01:17 <dons> hmm...
21:01:34 <dons> data Chan a
21:01:34 <dons>  = Chan (MVar (Stream a))
21:01:35 <dons>         (MVar (Stream a))
21:01:43 <dons> type Stream a = MVar (ChItem a)
21:01:44 <dons> data ChItem a = ChItem a (Stream a)
21:01:46 <dons> :)
21:01:49 <int-e> yeah that.
21:02:04 <dons> i forgot the mvar list!
21:02:18 <salierix> I don't like the unsafe functions... it seems like cheating.
21:02:34 <dons> usually the lists are pretty short, so that shouldn't be too problematic
21:02:35 <int-e> there's a reason for the indirections, too, which have to do with dupChan.
21:02:45 <dons> yeah, dupChan is a bit sneaky
21:03:06 <Cale> salierix: right. The best way to think of the unsafe* functions is as hooks into the compiler. They let you extend the language without having to recompile GHC.
21:03:46 <dons> without having to extend the type system :)
21:04:01 <Cale> Really, I think GHC should be much more noisy about unsafe functions, requiring an extra flag at compile time for any module which uses them, and another flag if you don't want modules importing that module to have the same issue.
21:04:07 <dons> what is unsafe in haskell is considered completely harmless in other languages
21:04:10 <dons> which is odd and funny
21:04:10 <int-e> dons, and of course the two MVars in the Chan point to the same list. One to the start and one to the end.
21:04:23 <dons> yep
21:05:43 <Cale> (and don't allow that to just go into the {#- OPTIONS_GHC ... #-}, or else that just defeats the point of having such a flag)
21:05:44 <Philippa> Cale: agreed
21:06:34 <Philippa> or allow it but have it generate a warning without a third flag, possibly
21:06:44 <mgsloan> hmm, the online help for random is blank
21:07:13 <mgsloan> actually, the online help for quite a few things is blank
21:08:18 <mgsloan> http://haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.0/Random.html
21:08:24 <mgsloan> http://haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.0/List.html
21:08:30 <Saizan> Cale: unless you add a proff in the comments that it's safe?:)
21:09:30 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/random-1.0.0.0/System-Random.html
21:09:40 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
21:10:07 <mgsloan> well, the links here are wrong then - http://haskell.org/ghc/docs/latest/html/libraries/index.html
21:10:12 <Saizan> mgsloan: haddock maybe doesn't import declarations across modules?
21:10:17 <Cale> Saizan: well, I don't know how easy it would be to prove safety in general, but essentially force the programmer to assert that it's okay at compile time, and since they might not have read the code, don't give them an easy way out ;)
21:10:51 <Saizan> mgsloan: no, you just clicked on the old name for those modules
21:10:59 <mgsloan> ah
21:11:27 <Saizan> s/across modules/across packages/
21:12:26 <Cale> For example, with lambdabot, it's not safe to just allow us to import modules from IRC, because then we could import System.IO.Unsafe and mess with Don's machine.
21:13:11 <Cale> But if this flag were in place, it would be possible to consider allowing imports. Importing System.IO.Unsafe would just generate errors, because lambdabot wouldn't supply the flag.
21:13:28 <ddarius> O'Caml people want dynamic typing?
21:13:47 <lament> Cale: this is the same kind of thinking that led to Java's exception, which you must either catch or declare. In practice, in Java it only leads to empty catch blocks, and here it would lead to replacing ghc with a shell script running ghc with the unsafe flag. Approaches like this don't work.
21:14:05 <Cale> lament: Well, anyone who does that is stupid.
21:14:40 <Cale> lament: It's not like they could do that on Don's machine remotely (well, if they could, then he has worse problems)
21:16:35 <Cale> lament: Of course, programmers would add the switch to their build scripts or cabal files, but that's basically where it belongs.
21:17:23 <Cale> If someone later tries to transplant the unsafe module to a new project, they'll be alerted to the possible security problem.
21:18:15 <conal> any OpenGLers around?
21:18:24 <conal> i have a texturing question.
21:18:54 <monochrom> Recursion is unsafe unless you turn on a flag.
21:21:26 <Cale> hehe
21:21:46 <Cale> I don't think Haskell's type system is sufficient for that to be reasonable yet.
21:22:36 <oerjan> @quote coq
21:22:36 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
21:22:36 <lambdabot> science problem. ;-)
21:23:28 <Cale> Yeah, and you have that funny issue that nontermination is indistinguishable from running for combinatorially large amounts of time :)
21:26:01 <Cale> let f0 x = (x,x); f1 x = f0 (f0 x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x) in f4
21:27:08 <Cale> Somehow, GHC's output of that type goes rather well with the music I'm presently listening to :)
21:28:08 <lament> maybe you should listen to better music :)
21:29:03 <sclv> hah. just improved fasta by 15% -- it still doesn't move us up a spot though. :-(
21:30:54 <thoughtpolice> hm, anybody aware of how to get the GHC.PArr stuff working in 6.8? i was trying something like 'mapP (+1) [:1..3:]' but i'm getting syntax errors. i guess the wiki needs to be updated as well?
21:31:59 <Cale> lament: True, I'm getting a bit tired of it :) I've been listening to Steve Reich's "Music for 18 Musicians"
21:32:49 <thoughtpolice> ah, there we go. simply forgot the -fparr flag :)
21:33:06 <Korollary> Steve Reich is New Age, right?
21:33:09 <Korollary> oops
21:33:10 <Korollary> my bad
21:33:21 <noobi1> heys guys i want to close a window in haskell, but after i want it to run a funtion could return (the_function)
21:34:01 <Cale> Time to listen to something denser. I think I'll go with Krantz :)
21:34:17 <Cale> noobi1: What GUI library?
21:34:33 <Cale> noobi1: and I don't really understand that question
21:34:43 <Cale> (grammatically, even)
21:34:50 <noobi1> hgl
21:35:56 <Cale> Well, there's closeWindow, right?
21:36:09 <Cale> You pass it a window, and it closes it? :)
21:36:58 <Cale> For doing stuff afterward, well, you're in IO, so just add another line to your do-block.
21:37:09 <Cale> Perhaps I don't understand the question. :)
21:37:21 <noobi1> yeah, but i want it to run a function after it closes
21:39:09 <Cale> do closeWindow w; somethingElse
21:39:40 <Cale> Is that not what you mean?
21:40:25 <noobi1> gonna try
21:41:33 <ddarius> Brian Beck's blog seems better.  Nice set of links in the "Programming" sidebar.  And links to LtU in the posts.
21:42:03 <wli> I wish I could see it in a GUI.
21:43:51 <noobi1> it didn't work
21:48:58 <bos> i've been trying to figure out how to get a useful zipper of a list of lists [[a]].
21:49:13 <noobi1> :R
21:49:21 <bos> and i have reluctantly concluded that i don't know how to do this.
21:49:48 <Cale> bos: What should it do?
21:49:55 <bos> the goal would be to be able to move "up" and "down" as well as left and right.
21:49:55 <wli> bos: I've had that experience with several things I actually managed to do a number of years ago.
21:50:12 <Cale> oh, that sort of zipper, okay
21:50:37 <sclv> bos: so left and right would be traversing an inner list, and up and down would be stepping laterally between them?
21:50:41 <bos> but i can't think of an efficient way to move up or down while maintaining the same offset into the current list.
21:50:51 <sclv> essentially you're walking around on a grid, right?
21:50:52 <bos> sclv: yes.
21:51:34 <Cale> Isn't the construction of a zipper just differentiation?
21:52:05 <bos> it is, but you don't get a *useful* zipper.
21:52:14 <Pseudonym> Never?
21:52:32 <bos> you get a zipper where moving up or down gives you a handle on the head of the neighbouring list.
21:52:34 <sclv> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
21:52:35 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
21:52:46 <sclv> Maybe some useful stuff there?
21:52:48 <bos> sclv: that's just a single list.
21:53:00 <sclv> in the discussion they talk about generalizing to a 2d grid
21:55:02 <sclv> bos: isn't there almost a type issue involved as well? you don't "know" the other lists have sufficient length.
21:55:30 <bos> sclv: that's not very important.
21:56:12 <sclv> do you need to represent your structure as [[a]] or could you represent it as nodes joined in a grid to begin with?
21:57:33 <oerjan> perhaps nested rectangles?
21:58:22 <bos> the closest i came was data Zipper a = Zipper [a] [a] [[a]] [[a]], where the first two lists are left and right, and the next two up and down.
21:59:50 <bos> in despair, i asked apfelmus yesterday, who knows a lot more about zippers than i do, and he came up with this, too.
22:00:14 <sclv> hmm.. you could also have a "zipper of zippers" where you kept a distinct state on every row?
22:00:24 <sclv> which would be a different kind of useful.
22:00:40 <sclv> this is what xmonad does, right?
22:01:25 <bos> no, xmonad just uses a zipper over a list to represent the current focus.
22:01:49 <bos> where each element contains the state of that desktop.
22:02:33 <sjanssen> what about Zipper (Zipper a)
22:02:37 <oerjan> isn't the problem essentially that the 2d graph has too many cycles to be approximated by trees, and so zippers don't realy work
22:02:49 <sjanssen> where Zipper is the usual left, focus, right data type
22:03:11 <dons> "MPlayer crashed by bad usage of CPU/FPU/RAM"
22:03:19 <dons> unusual error message
22:03:23 <sclv> bos: but there's also a zipper of workspaces.
22:03:34 <bos> sclv: that's the one i was referring to.
22:03:35 <oerjan> unless there is some kind of zipper that _does_ work for general graphs with cycles
22:03:37 <sjanssen> hmm, except that makes movement within a list O(n) wrt. the number of lists
22:03:51 <jeffz> dons, I think that's handling sigsegv.
22:04:36 <bos> oerjan: a zipper "works", it just doesn't do what i want efficiently :-)
22:05:21 <sjanssen> bos: do you update cells in the zipper?
22:05:40 <sclv> a zipper algorithm that didn't get tangled in a 2d grid shouldn't be that difficult to implement.
22:05:59 <oerjan> bos: do you rearrange the topology or does every cell stay in a fixed position relative to the others?
22:07:50 <bos> sjanssen: yes
22:07:55 <bos> oerjan: it's a fixed grid
22:08:06 <sclv> every time you move "left" or "up" you do so by backtracking first -- so its potentially O (max m n) for a m x n grid, but still... thats only the degenerate case.
22:08:08 <noobi1> hey guys anyone know to run a program after closing a widows in soegraphics
22:08:10 <noobi1> ??
22:08:51 <sjanssen> bos: I'd just turn it into Map (Int, Int) a :(
22:09:14 <bos> sjanssen: :-( indeed
22:09:21 <oerjan> i think if you nested squares (NW, NE, SW, SE) you should be able to move efficiently on _average_ (better than log n at each step as a Map gives)
22:10:00 <ddarius_> bos: I wonder if Hinze's web paper might be better.  I bet not.  Personally I don't think this is doable nicely. (if this didn't get through)
22:10:14 <bos> ddarius_: yes, didn't get through
22:10:36 <bos> ddarius_: the type-indexed types paper?
22:10:47 <ddarius> @google Hinze Weaving a web
22:10:48 <lambdabot> http://citeseer.ist.psu.edu/609884.html
22:10:48 <lambdabot> Title: Weaving a Web (ResearchIndex)
22:10:56 <oerjan> what's the term - amortized time
22:13:01 <bos> ddarius: cute
22:14:31 <sjanssen> bos: is it possible to use Data.Sequence rather than []?
22:14:47 <bos> sjanssen: sure
22:15:32 <bos> sjanssen: but i was intending to use [[]] specifically for the ability to work with a zipper
22:15:50 <sjanssen> bos: that could be O(1) to move within a list and O(log i) to move between two lists
22:16:14 <bos> sjanssen: mind, what i'm doing is convolving an image, and the kernel i'm using is separable. i could just zipper in 1-d, transpose, then zipper in 1-d again.
22:18:31 <ddarius> Don't no one get your hopes up, but any recommendations for a good "blog" site.  The only criteria I can think of at this time would be ideally easy LaTeX/mathml support and syntax highlighting.
22:19:57 <sjanssen> ddarius: I'd like to blog in literate Haskell
22:20:27 <bos> ddarius: wordpress.com supports latex equations
22:20:50 <bos> blogger is blocked by reddit, so don't use that
22:21:06 <ddarius> Being blocked by reddit may appeal to me.
22:21:29 <bos> heh.
22:44:48 <xpika> does anyone know how to change the cursor icon in gtk2hs?
22:45:28 <allbery_b> last I checked there were no bindings for that
22:45:49 <allbery_b> (gtk has them, gtk2hs doesn't expose them to haskell)
22:46:17 <xpika> does this mean I have to call C?
22:46:46 <allbery_b> you would have to prooduce your own binding to the gtk functions, yes
22:47:08 <newsham> this "dont fear the monads" video started out promisingly, but I am pretty disappointed
22:47:56 <Cale> newsham: I had to stop halfway through myself
22:48:06 <newsham> it never really says what an "M" is, why you would want an M, and glosses over lots of other important stuff
22:48:13 <wli> "M"?
22:48:18 <ddarius> :t return
22:48:19 <newsham> a -> M a
22:48:19 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:48:19 <ddarius> That m
22:48:54 <newsham> "people get confused about monads because they dont see this extra lambda that is left off"
22:48:59 <xpika> is gdk part of gtk?
22:49:02 <newsham> I dont think thats true at all
22:49:12 <allbery_b> xpika: yes
22:49:26 <newsham> xpika: yah, kinda sorta.. its a lower level layer that gtk is built on
22:49:31 <int-e> eh? which "extra lambda"?
22:49:32 <wli> I actually vaguely agree with the statement about the hidden lambda.
22:49:38 <allbery_b> ==newsham
22:49:52 <wli> I can't watch the video until I get X running, though.
22:49:52 <allbery_b> gdk is the low level stuff closer to the implementation, gtk is the high level stuff
22:49:54 <newsham> int-e:  "\a -> (f a >>= \a -> g a)
22:50:45 <newsham> allbery: what am I equal to?
22:51:29 <allbery_b> 'agree with'
22:51:34 <newsham> aha
22:51:57 <newsham> newsham deriving Eq
22:52:01 <allbery_b> (I've been sing that here for over a year, I think, at what point do I need to give up and stick a faq page in my /whois? :> )
22:53:10 <ddarius> newshaM: Indeed, I think it's exactly the opposite.  (>>=) is the odd thing out that was invented to make monads more comprehensible.
22:53:43 <zeeeee> i'm trying to create a cabal package, but i can't figure out how to write my build-depends. i tried unix, unix-1.0, unix=1.0, unix>1.0, unix>=1.0, etc., and i'm always getting either a parse error or "Could not find module `System.Posix.Files': it is a member of package unix-1.0, which is hidden"
22:54:20 <zeeeee> (building outside cabal works fine of course)
22:54:22 <allbery_b> are you reding the Setup.lhs configure after each chage?>
22:54:28 <allbery_b> bleh
22:54:47 <allbery_b> are you redoing the "runhaskell Setup.lhs configure" after each change?
22:54:49 * int-e got confused about monads because it's a big word (although it has only five letters) so when I saw one, I wonder where the monad is. And it's really very little, it's "just" sequencing.
22:54:57 <newsham> ddarius: what would be the non weird alternative?
22:55:06 <zeeeee> allbery_b, no, thanks
22:55:27 <allbery_b> that's when the cabal file is read and turned into configuration information for ghc
22:55:55 <int-e> (that notion of sequencing bears another discussion of course)
22:56:15 <zeeeee> allbery_b, yeah, i was confused because i didn't see anything where it would save its state - your comment made me look harder and i found a dot-file
22:56:25 <ddarius> newsham: Kleisli composition or join/fmap
22:56:59 <quicksilver> @seen conal
22:56:59 <lambdabot> I saw conal leaving #haskell and #ghc 52m 44s ago, and .
22:57:03 <newsham> i'm not that familiar with join (except "join (*)" :)
22:57:05 <newsham> ?src join
22:57:05 <lambdabot> join x =  x >>= id
22:57:07 <ddarius> newsham: Kleisli composition, which is trivial to define, seems to be exactly what he wants.  I have no idea why he felt the need to stick with (>>=)
22:57:26 <shapr> @yow !
22:57:26 <lambdabot> A wide-eyed, innocent UNICORN, poised delicately in a MEADOW filled
22:57:26 <lambdabot> with LILACS, LOLLIPOPS & small CHILDREN at the HUSH of twilight??
22:57:34 <newsham> dd: "arrows are not scary" doesnt make a good talk title?
22:57:52 <zeeeee> do package creators typically use >= or = for their build-depends versions?
22:57:59 <newsham> "what arrows are, why you should be afraid of them and why you shouldnt be afraid of them"? :)
22:57:59 <ddarius> newsham: In category theory, usually monads are defined as a triple (T,,) where  = join and  = return
22:58:07 <shapr> newsham: I like it!
22:58:34 <quicksilver> newsham: I've always found join more interesting to think about than bind
22:58:49 <newsham> i hope to findthat sometimes soon, too :)
22:58:56 <quicksilver> at least, with List, Maybe, IO and State (e.g.) I find join gives a good picture of what the monad is doing
22:58:58 <newsham> ?src [] join
22:58:58 <lambdabot> Source not found. You type like i drive.
22:58:58 <zeeeee> i wish there were some way to say "depend on any version that doesn't change its interface from version __" (i think most schemes maintain major+minor to denote this)
22:59:01 <int-e> "take a computation that returns a computation, run it, then run the resulting computation."
22:59:06 <int-e> == join
22:59:52 <newsham> is there a graph reason for the "join" name?
23:00:05 <newsham> when I hear "join" I think "fork" and things splitting and coming together
23:00:07 <ddarius> newsham: Well for lists, join = concat
23:00:25 <newsham> > join "ab" "cd"
23:00:27 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
23:00:38 <newsham> > join ["ab", "cd"]
23:00:39 <lambdabot>  "abcd"
23:01:25 <newsham> :type join
23:01:36 <newsham> ?type join
23:01:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:02:26 <newsham> is there a common example of join for IO?
23:03:14 <mgsloan> well, imagine if an IO action returned an IO action... like you have an IO action that queries the top of an undo stack
23:03:33 <mgsloan> pop_undo :: IO (IO ())
23:04:59 <mgsloan> (join pop_undo) would yield an action which undoes the last thing on the undo stack
23:06:27 <mgsloan> (in the process, popping it)
23:24:06 <quicksilver> newsham: it joins together staged actions
23:24:22 <quicksilver> newsham: consider do { putStrLn "hello" ; return (putStrLn "world") }
23:24:38 <quicksilver> newsham: that does one action, then returns another undone, so its type is IO (IO ())
23:24:44 <quicksilver> newsham: join just does them both
23:46:07 <newsham> qs: but that relied on using bind.
23:46:50 <Cale> newsham: hm?
23:47:09 <ddarius> newsham: The most obvious example of using join is defining (>>=)  m >>= f = join (fmap f m)
23:47:35 <newsham> join (do putStrLn "hello" return (putStrLn "world"))
23:48:37 <Cale> I think join's name is pretty clear from its type :)
23:48:40 <Cale> :t join
23:48:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:48:58 <newsham> :t fmap (\x -> putStrLn "world") (putStrLn "hello")
23:48:59 <lambdabot> IO (IO ())
23:49:02 <Cale> You're joining the two levels of structure together somehow.
23:49:08 <newsham> :t join $ fmap (\x -> putStrLn "world") (putStrLn "hello")
23:49:08 <lambdabot> IO ()
23:49:11 <newsham> makes sense
23:49:17 <Cale> Sort of like removing indirection.
23:49:34 <ddarius> That last statement is fine.  join "flattens" the computation.
23:49:45 <dons> http://programming.reddit.com/info/618nq/details
23:49:51 <dons> `erlang style concurrency in haskell ( part II ) '
23:50:00 <ddarius> For lists (and in fact most free algebras, e.g. polynomials) quite literally
23:50:40 <ddarius> Another potential perspective is  is presumably named after "multiplication".
23:50:45 <newsham> i must sleep off this tryptophin.  happy thanksgiving everyone. g'nite
23:54:20 <olsner> remind me, mu == join, right?
23:54:40 <Cale> yep
23:56:49 * wli is a big fan of join/fmap/return triples.
