00:00:01 <salierix> I can't decide how to store my chess game state.... as IORefs or thread it with a State monad.
00:00:04 <slava> so has ghc been ported to windows ce?
00:00:36 <goalieca> what is diff on wince. It is mostly arm i figure.. but what about the binary fomart
00:00:39 <goalieca> format*
00:00:56 <slava> its like desktop windows but with a few differences
00:01:10 <slava> no 'current directory', no drive letters, no environment variables
00:01:15 <slava> no overlapped io
00:01:22 <slava> everything is unicode so the *A functions are gone
00:01:40 <goalieca> no drive letters!? yay! that is my biggest gripe with windows
00:02:09 <goalieca> but from the sounds of it.. it is a flat directory model?
00:02:19 <slava> no, its hierarchical
00:02:25 <ac> interesting. cabal install arrows produces the same error UNTIL I install the Stream package manually. I think I should be able to narrow this down with enough experimentation
00:02:27 <slava> but your program doesn't have a cwd. all paths you pass to system apis are absolute
00:03:12 <goalieca> so if you want to load a data file.. you must know where your program is installed.
00:04:14 <slava> you can get the path to the current exe from the system and look at the parent dir of that
00:04:25 <slava> also you cannot look up symbols at runtime (like dlsym()) if they're in an exe
00:04:36 <slava> this is a weird limitation because it works for symbol lookup from dlls
00:04:43 <slava> and a dll is an exe with a single bit flipped in the header
00:06:39 <olsner> are you sure that's not just a linker thing? does it work when taking an ordinary exe, flipping the bit in the header and treating it as a dll?
00:16:25 <hpaste>  Mibori pasted "Linked" at http://hpaste.org/3761
00:18:27 <hpaste>  M annotated "Linked" with "(no title)" at http://hpaste.org/3761#a1
00:23:32 <Nafai> Project Euler is fun
00:23:42 <Nafai> Though my methods are way slow
00:27:02 <TSC> There's a new problem in a few hours
00:27:26 <TSC> I enjoy them too, even though I understand very few of them (:
00:27:40 <Nafai> I just started tonight, only on #3
00:27:58 <Nafai> Haven't yet got an answer though, my code is running slow
00:28:24 <TSC> Oh, I understand the first couple (:
00:28:25 <RayNbow> are we talking about ProjectEuler?
00:28:31 <Nafai> Yeah
00:29:04 <RayNbow> I'm stuck at #12
00:29:54 <RayNbow> I haven't spent some time recently on that problem, but I found out my divisors function is way too slow :p
00:30:06 <TSC> Problems 3 and 12 are closely related, I'd say
00:30:44 <Nafai> Yeah
00:30:57 <RayNbow> #3 can be solved quickly by some form of trial division
00:31:25 <Nafai> My brute force method is certainly too slow
00:31:31 <Sizur> thanks for the reference to ProjectEuler :)
00:32:00 <RayNbow> Nafai: what's your approach?
00:32:56 <Nafai> http://hpaste.org/3760
00:33:29 <RayNbow> ah
00:33:52 <RayNbow> that's slow because you're testing a lot of numbers
00:33:56 <Nafai> Yeah
00:34:56 <RayNbow> Nafai, here's a hint... take a piece of paper
00:35:08 <RayNbow> and write down what prime factors actually are :)
00:35:33 <quicksilver> the general theme of project euler is that the completely naive approach will be too lwlo
00:35:47 <quicksilver> slow, that is
00:36:04 <quicksilver> so you have to use a mixture of computing power and thought :)
00:36:04 <b_jonas> Wsrc mapM
00:36:07 <b_jonas> @src mapM
00:36:08 <lambdabot> mapM f as = sequence (map f as)
00:36:19 <quicksilver> and, in some cases, your solutions to earlier problems
00:36:22 <b_jonas> @src sequence
00:36:22 <lambdabot> sequence ms = foldr k (return []) ms
00:36:22 <lambdabot>     where
00:36:22 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
00:36:35 <b_jonas> @t mapM
00:36:35 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:36:39 <b_jonas> @type mapM
00:36:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:37:07 <omnId> sequence [x,y,z] = do x' <- x; y' <- y; z' <- z; return [x',y',z']
00:37:13 <omnId> and similarly for other size lists.
00:37:28 <b_jonas> I see
00:37:37 * Nafai thinks about this problem as he hits the sack
00:37:44 <Nafai> RayNbow: Thanks for the hint
00:37:45 <RayNbow> Nafai, n = p1 * p2 * p3 * p4 * ... * pk <-- something to dream about
00:37:46 <b_jonas> so mapM evaluates the elements from left to right
00:37:54 <RayNbow> you're welcome :)
00:37:59 <omnId> map gives you a list of actions, sequence hooks 'em together, collecting the results.
00:38:05 <Cale> Oy, @src's definition of sequence annoys me
00:38:14 <b_jonas> so if I do it in a MonadError, I'll get the first error
00:38:28 <omnId> Cale: you'd prefer liftM2 (:)?
00:38:30 <Cale> sequence [] = return []; sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:38:34 <Cale> Or yeah,
00:38:51 <Cale> sequence = foldr (liftM2 (:)) (return [])
00:39:53 <b_jonas> yeahl, liftM2 (:)
00:40:00 <b_jonas> I think that might be what I need
00:40:16 <b_jonas> though it might be better if I just write it out by hane
00:42:20 <b_jonas> @src's definition is good because it shows clearly which order the list is evaluated: head first
00:42:20 <lambdabot> Source not found. I feel much better now.
00:42:26 <quicksilver> I don't think the liftM2 defintion of sequence would be right for @src. I think of equence as being more primitive than liftM2. Or at the same level, maybe.
00:42:51 <b_jonas> really?
00:42:58 <quicksilver> yes
00:42:59 <omnId> @src liftM2
00:43:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:43:03 <omnId> b_jonas: liftM2 says that too.
00:43:04 <shachaf> quicksilver: sequence is for monads, liftM2 is for Applicatives.
00:43:16 <quicksilver> sequence is for applicatices, shachaf
00:43:27 <shachaf> Oh, oops.
00:43:33 <b_jonas> I've no idea what an Applicative is
00:43:35 <quicksilver> sequence is the motivating combinator for the invention of applicatives :)
00:43:36 <shachaf> Right, sorry.
00:43:39 <EvilTerran> liftM2 f x y = f <$> x <*> y --?
00:43:43 <b_jonas> and as it has a do, it seems to me that it's for monads
00:43:45 <omnId> b_jonas: between a Functor and a Monad
00:43:46 * shachaf feels silly.
00:43:53 <omnId> b_jonas: i.e. not-quite-a-monad
00:43:53 <shachaf> EvilTerran: That's liftA2.
00:44:01 <EvilTerran> indeed.
00:44:31 <salierix> Is it "ok" to use IORefs? Or are they bad form?
00:44:32 <EvilTerran> @src liftA2
00:44:32 <lambdabot> liftA2 f a b = f <$> a <*> b
00:44:37 <b_jonas> I mean, liftM2 has "M" in it
00:44:42 <EvilTerran> and how!
00:44:53 <b_jonas> ("P" for Pooh)
00:45:21 <omnId> salierix: I'd probably prefer using State for your problem.
00:46:38 <EvilTerran> b_jonas, functors have fmap, applicative functors also have return (well, "pure"), monoidal applicative functors (monads) also have bind. as i understand it.
00:46:51 <shachaf> EvilTerran: return and ap.
00:47:08 <b_jonas> but...
00:47:13 <b_jonas> what's fmap with monads?
00:47:17 <omnId> salierix: it's good for connecting the fiddly bits in the middle that *need* the state, while still allowing you to run it for a simple pure interface.
00:47:19 <EvilTerran> liftM
00:47:27 <EvilTerran> ?type fmap
00:47:31 <EvilTerran> ?type liftM
00:47:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:47:36 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:47:36 <omnId> b_jonas: liftM
00:47:37 <b_jonas> I don't really know what fmap means, apart from that it's a generalization of map
00:47:42 <shachaf> b_jonas: fmap, hopefully.
00:47:52 <shachaf> > fmap (+1) (Just 5)
00:47:53 <lambdabot>  Just 6
00:47:56 <shachaf> > fmap (+1) Nothing
00:47:57 <lambdabot>  Nothing
00:48:25 <shachaf> b_jonas: Just look at the type.
00:48:27 <shachaf> @ty fmap
00:48:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:48:29 <omnId> b_jonas: if the Monad class subclassed Functor like it should have, there'd be no need for liftM since fmap would already be there.
00:48:42 <omnId> @ty liftM
00:48:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:48:50 <shachaf> omnId: (And fmap would be called map anyway. :-) )
00:49:11 <b_jonas> but it doesn't do that because then you'd have to write an instance Functor for every monad
00:49:26 <b_jonas> hmm
00:49:35 <omnId> b_jonas: which isn't much of a burden, really
00:49:55 <omnId> instance Functor SomeType where fmap f x = x >>= return . f -- bam!
00:50:10 <salierix> omnId, but everywhere I want to use my State is in the IO monad already.
00:50:15 <b_jonas> but then newbies like me would have to learn that as well to define monads
00:50:20 <shachaf> instance Functor M where fmap = liftM -- :-)
00:50:22 <salierix> I mean IORef, not State.
00:50:57 <omnId> shachaf: I'm working in a theoretical world where liftM need not exist :)
00:51:11 <b_jonas> I was happy enough when I could write the two methods (>>= and return) for an ErrorT clone
00:51:20 <shachaf> omnId: Except as a handy tool for monad implementors. :-)
00:51:29 <quicksilver> salierix: still better to avoid IORefs unless needed
00:51:35 <shachaf> liftA exists, after all.
00:51:39 <quicksilver> salierix: makes your types more explicit
00:52:00 <omnId> shachaf: defaultFmapMonad might make a better name in that case.
00:52:09 <quicksilver> which makes your code easier to understand and maintain
00:52:26 <b_jonas> @src ap
00:52:26 <lambdabot> ap = liftM2 id
00:52:37 <b_jonas> ah, tricky
00:52:54 <b_jonas> so it's the S combinator for (->) monads
00:53:06 <omnId> liftM2 ($) is probably more intentfully transparent.
00:53:14 <salierix> I don't get it...
00:53:21 <omnId> b_jonas: it's S in the ((->) r) monad, yes :)
00:53:51 * shachaf wishes (r ->) worked.
00:54:07 <shachaf> b_jonas: In Applicative, ap is (<*>).
00:54:24 <b_jonas> I wish ghci had a way to show any kind of object reasonable even if I don't derive show for it
00:54:25 <sjanssen> shachaf: yes, we demand type sections!
00:55:02 <shachaf> sjanssen: Any reason it shouldn't work?
00:55:20 <sjanssen> shachaf: well, I guess (-> r) is invalid
00:55:26 <sjanssen> but we should allow (r ->)
00:55:52 <shachaf> (-> r) = (Flip (->) r) -- :-)
00:56:05 <omnId> you'd need type lambda's or a standard newtype Flip a b c = a c b
00:56:09 <omnId> yeah
00:56:12 <b_jonas> is it bad to derive Show in my objects just to ease debugging, even if I don't actually want to show them in the program
00:56:13 <b_jonas> ?
00:56:27 <quicksilver> in fact, I think the only time IORefs are needed is when using IO () callbacks.
00:56:32 <sjanssen> b_jonas: that's fine
00:56:33 * shachaf wonders what (-> r) would be.
00:56:35 <omnId> b_jonas: I do it anyways :)
00:56:38 <b_jonas> ok
00:56:41 <quicksilver> b_jonas: yes, it's annoying. And no, it's not bad.,
00:56:55 <b_jonas> can I derive Show for a data with a function field?
00:57:02 <sjanssen> b_jonas: you may see tiny increases in compilation time and binary size, but nothing to sweat over
00:57:04 <quicksilver> but really, the compiler chain should generate a kind of DebugShow all of its own
00:57:14 <quicksilver> b_jonas: you can't derive one, no. You can write one.
00:57:21 <osfameron> bos: cute!  does the "guard" set it in the maybe monad?
00:57:22 <b_jonas> I'll have to write one
00:57:28 <b_jonas> I definitely need such a data
00:57:35 <osfameron> @src guard
00:57:36 <lambdabot> guard True  =  return ()
00:57:36 <lambdabot> guard False =  mzero
00:57:40 <omnId> b_jonas: deriving Show requires Show for all fields
00:57:43 <quicksilver> osfameron: no, guard works in any monadplus
00:57:52 <omnId> b_jonas: you could import Text.Show.Functions
00:57:59 <quicksilver> osfameron: but maybe is probably the most natural one to use it in.
00:57:59 <osfameron> :t \a b->guard (a `isPrefixOf` b) >> drop (length a) b
00:58:07 <osfameron> mah
00:58:08 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
00:58:09 <omnId> which has: instance Show (a -> b) where show _ = "<function>"
00:58:27 <quicksilver> osfameron: ah yes, it makes quite a lot of sense in [] too
00:59:05 <b_jonas> omnId: ah yes, good idea
00:59:40 <shachaf> > show (+1) -- lambdabot's is nicer. :-)
00:59:42 <lambdabot>  "<Integer -> Integer>"
00:59:46 <osfameron> ah, so what does it return if the guard fails...
00:59:57 <shachaf> osfameron: mzero.
01:00:11 <omnId> @src guard
01:00:11 <lambdabot> guard True  =  return ()
01:00:11 <lambdabot> guard False =  mzero
01:00:13 <osfameron> which for liust is [] ?
01:00:18 <omnId> @src [] mzero
01:00:19 <lambdabot> mzero = []
01:00:21 <sjanssen> > mzero :: [Int]
01:00:22 <lambdabot>  []
01:00:25 <b_jonas> shachaf: I can just :s +t if I want to know the types
01:00:26 <omnId> :)
01:00:31 <b_jonas> or ask for the :t of anything
01:00:31 <shachaf> @go monadplus laws
01:00:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell/MonadPlus
01:00:47 <osfameron> ah, so actually that isn't quite the type that I need
01:00:53 <shachaf> mzero >>= f  =  mzero
01:00:59 <osfameron> I want to know a) if it was a prefix, and b) what the remainder is in that case
01:01:16 <osfameron> but it's very cute nonetheless
01:01:42 <omnId> osfameron: Maybe String, with Nothing if it's not prefix?
01:02:03 <b_jonas> btw, can one write a function like mapM which builds a list inside a monad using monad lists?
01:02:04 <osfameron> yeah, I think so
01:02:22 <salierix> Why does runState return a pair instead of just a value?
01:02:32 <shachaf> b_jonas: You mean, mapM in applicative?
01:02:36 <omnId> salierix: final state value.
01:02:38 <shachaf> salierix: State and return value.
01:02:42 <sjanssen> salierix: because you might want the resulting state too
01:02:42 <b_jonas> no
01:02:44 <shachaf> @ty execState
01:02:45 <b_jonas> I mean,
01:02:45 <lambdabot> forall s a. State s a -> s -> s
01:02:51 <b_jonas> to implement the same function
01:02:53 <shachaf> @ty evalState
01:02:55 <lambdabot> forall s a. State s a -> s -> a
01:03:03 <b_jonas> but using lists as a monad inthe implementation
01:03:24 <omnId> > runState (do x <- get ; modify (+1) ; return (x*2)) 3
01:03:25 <lambdabot>  (6,4)
01:03:31 <b_jonas> because you can write map in that way
01:03:36 <b_jonas> but I'd like to know about mapM
01:04:08 <shachaf> mapM f = sequence . yourmap f -- ? :-)
01:04:20 <omnId> @src evalState
01:04:20 <lambdabot> Source not found. You type like i drive.
01:04:46 <salierix> But shouldn't the final state be concidered the "value"?
01:04:49 <shachaf> omnId: evalState just uses runState.
01:04:58 <quicksilver> salierix: to 'use state' you don't necessarily have to use the builtin State monad
01:04:59 <omnId> evalState x s = fst (runState x s) ; execState = snd (runState x s) -- use these if you want
01:05:03 <shachaf> salierix: Not what's returned from the function.
01:05:04 <quicksilver> I often don't bother
01:05:30 <visof> can i do modeling with Haskell ? especially for physics?
01:05:32 <quicksilver> I just use "MyState -> IO ()" <-- readonly in the state, "MyState -> IO MyState" -> r/w
01:05:49 <omnId> salierix: do you understand the runState expression I gave?
01:05:55 <quicksilver> I find the mtl state lib is just extra typing for no great reward :)
01:06:03 <doserj> @faq
01:06:03 <lambdabot> The answer is: Yes! Haskell can do that.
01:06:22 <visof> simulation?
01:06:59 <sjanssen> quicksilver: IMO, there's a certain point where manually plumbing the state becomes burdensome
01:07:00 <b_jonas> by the way, if you juxtapose a pageful of these very general and abstract library functions, with some parenthesis, 1. does the result compile with reasonable chance, 2. if so, do you get an AI if you run it?
01:07:01 <salierix> omnId, I know how to get the state and value using execState and evalState but I was just wondering why.
01:07:34 <doserj> http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Physics
01:07:37 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/37jtrh
01:08:11 <shachaf> salierix: return 5 :: IO Int -- You care about the value here, right?
01:08:26 <doserj> visof: you can do anything, but whether you'll find ready-made libraries for just your task is a different issue
01:08:35 <quicksilver> sjanssen: Yes, about the point when you define a bunch of cool custom combinators you want to use
01:08:46 <salierix> shachaf, sure.
01:09:03 <sjanssen> s/define/import
01:09:07 <sjanssen> s/custom/standard
01:09:09 <sjanssen> :)
01:09:19 <Cale> salierix: well, it wouldn't be a monad anymore if that was the case
01:09:30 <Cale> (If there were no additional return value)
01:09:34 <quicksilver> sjanssen: but the standard combinators are verbose and pointless
01:09:49 <quicksilver> sjanssen: I've *never* wanted to use get and set
01:09:56 <salierix> Cale, there isn't just one return value, there are two.
01:09:58 <quicksilver> they're just code noise and extra lines
01:10:23 <Cale> salierix: You're not quite supposed to think of it like that though.
01:10:38 <Cale> salierix: There's one return value, and a state that's being manipulated alongside that.
01:10:44 <sjanssen> quicksilver: then define your combinators in terms of get/put/modify, I'm sure you'll save lines in that case
01:10:47 <quicksilver> sjanssen: and, there is no standard combinator to lift reader into state
01:10:51 <quicksilver> sjanssen: right.
01:10:59 <quicksilver> sjanssen: which is what I said.
01:11:10 <Cale> Of course, it's internally implemented using functions of type s -> (s,a), which looks like it has two return values, but that's the implementation.
01:11:11 <quicksilver> sjanssen: "about the point when you define a bunch of cool custom combinators you want to use"
01:12:02 <quicksilver> similarly I find ReadertT a real pain, and don't bother to use it
01:12:03 <sjanssen> quicksilver: my main point was "in terms of" :)
01:12:13 <Cale> salierix: Does that make sense?
01:12:23 <sjanssen> quicksilver: you can at least use State to avoid writing return and >>= repeatedly
01:12:25 <quicksilver> that would be easier if everything in the standard lib was MonadIO so I didn't need to liftIO, at least
01:12:50 <Cale> salierix: When you see the type State s a, you can think of a value of that type as being some computation which manipulates a value of type s while producing a value of type a.
01:13:03 <Cale> (State s) is the monad here
01:13:18 <salierix> Yeah... but I'm really having trouble with dealing with mutable state even though I know how the State monad works now.
01:13:19 <shachaf> salierix: Saying there are two return values is like saying f = print 1 >> return 2 has two return values: One is the change in stdout, one is 2.
01:13:28 <quicksilver> I think it is quite instructive, anyway, to write your code in terms of MyState -> IO MyState
01:13:45 <quicksilver> and then you begin to see when you might want a 'real' state monad.
01:13:46 <salierix> I mean that I have trouble trying to design my program.
01:14:07 <quicksilver> sjanssen: true, but you replace the return and >>= noise with runStateT noise, in my expereince.
01:14:09 <Cale> salierix: well, you never really have to use the State monad, but it's something which sometimes makes things clearer.
01:14:26 <sjanssen> quicksilver: there shouldn't be more than one or two runStateT's in your program
01:14:41 <Cale> salierix: If you find that you're threading a value through a computation as it's updated, that probably calls for the State monad.
01:14:53 <quicksilver> sjanssen: there is at lesat one per IO () callback ;)
01:15:06 <sjanssen> quicksilver: isn't it really easy to make mistakes with the MyState -> IO MyState?
01:15:10 <goalieca> heh. so forkIO only spawns a "concurrent haskell thread"
01:15:13 <goalieca> why not a process
01:15:13 <salierix> I need so many little pieces of program state.
01:15:26 <Cale> For example, try writing the program which takes a binary tree, and relabels the nodes from left to right with the numbers 1, up to the number of nodes.
01:15:33 <sjanssen> goalieca: why would we want a process?
01:15:34 <roconnor> who is bluespec?
01:15:39 <roconnor> @who bluespec
01:15:39 <lambdabot> Maybe you meant: echo ghc show thx what wn
01:15:41 <Cale> That is:  relabel :: Tree a -> Tree Integer
01:15:42 <roconnor> @what bluespec
01:15:42 <lambdabot> I know nothing about bluespec.
01:15:47 <Cale> where, say
01:15:59 <goalieca> sjanssen, there are reasons.
01:16:05 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
01:16:14 <quicksilver> sjanssen: I don't find it so.
01:16:21 <sjanssen> goalieca: there is also System.Posix for the usual fork()
01:16:32 <goalieca> ty
01:16:35 <sjanssen> quicksilver: you never mix s with s'?
01:16:36 <Cale> You can do it with pure code, but you'll find out quickly why that's kind of annoying :)
01:17:11 <Cale> Using the state monad helps you manage the "next label to apply".
01:17:45 <salierix> What's the Cont monad used for?
01:18:20 <omnId> @kind Cont
01:18:21 <lambdabot> * -> * -> *
01:18:32 <quicksilver> sjanssen: oh, I see. Yes, that kind of mistake is possible.
01:18:34 <omnId> @unmtl Cont k a
01:18:34 <lambdabot> (a -> k) -> k
01:18:42 <roconnor> salierix: the Cont monad is used for speeding up other monads :)
01:18:50 <quicksilver> sjanssen: I try pretty hard to avoid using s'
01:18:58 <quicksilver> sjanssen: but I agree that's a fair point
01:19:04 <Cale> It's used very sparingly. It gives you first-class continuations, essentially. That is, you're allowed to capture "the rest of the computation" and pass that as a parameter to a function.
01:19:09 <roconnor> salierix: and other things too.
01:19:23 <quicksilver> roconnor: newtype GoFasterStripe = Cont
01:19:29 <quicksilver> hmm maybe it should be red
01:19:35 <quicksilver> red monads go faster!
01:19:36 <Cale> Which you can use to create wacky control structures, including first-class goto labels.
01:19:45 <roconnor> quicksilver: it was red for me because you used my name :D
01:19:54 <scook0> quicksilver: make it a phantom type, parameterized on colour
01:19:55 <quicksilver> ;)
01:20:06 <omnId> @src Cont return
01:20:06 <lambdabot> return a = Cont ($ a)
01:20:15 <quicksilver> salierix: the most common usage of Cont is to give something like C's "break"
01:20:23 <sjanssen> what color should we paint the phantom bikeshed?
01:20:24 <quicksilver> salierix: it's capable of much more complex stuff though
01:20:31 <Cale> > getCC :: MonadCont m => m (m a)
01:20:31 <Cale> > getCC = callCC (\c -> let x = c x in return x)
01:20:31 <Cale> > getCC' :: MonadCont m => a -> m (a, a -> m b)
01:20:31 <Cale> > getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
01:20:31 <lambdabot>  Parse error at "=" (column 7)
01:20:31 <lambdabot>  Parse error at "=" (column 11)
01:20:32 <omnId> @type runCont
01:20:32 <lambdabot>   Not in scope: `getCC'
01:20:33 <lambdabot>   Not in scope: `getCC''
01:20:33 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
01:20:35 <Cale> whoops :)
01:20:50 <quicksilver> has anyone seen any interesting applications of cont which use the same continuation more than ones?
01:21:00 <omnId> > runCont (return 1) (*2)
01:21:01 <lambdabot>  2
01:21:14 <quicksilver> s/ones/once/
01:21:22 <reinierrr> > runCont (return 3) (*2)
01:21:23 <lambdabot>  6
01:21:29 * omnId has never really used CPS before, just going by the types =)
01:21:33 <Cale> Depends on what you mean by "more than once"
01:22:19 <Cale> getCC there is kind of taking the fixed point of the continuation
01:22:50 <Cale> which lets you write infinite loops :)
01:23:08 <Cale> Or finite loops in any monad which incorporates some state as well.
01:23:10 <omnId> @type getCC
01:23:11 <lambdabot> Not in scope: `getCC'
01:23:28 <Cale> It's not in the libraries, but it should be.
01:23:28 <omnId> @type Control.Monad.Cont.getCC
01:23:29 <lambdabot> Not in scope: `Control.Monad.Cont.getCC'
01:23:41 <Cale> I gave it above there.
01:23:44 <Cale> getCC :: MonadCont m => m (m a)
01:23:54 <omnId> @let getCC = callCC (\c -> return (fix c))
01:23:54 <lambdabot> <local>:4:8:     Ambiguous type variable `m' in the constraint:       `MonadC...
01:24:26 <b_jonas> hmm
01:24:35 <omnId> hmm indeed!
01:24:43 <b_jonas> I'll have to think about how to carry the interpreter states around the parts of the interpreter
01:24:45 <Cale> @let getCC :: MonadCont m => m (m a); getCC = callCC (return . fix)
01:24:47 <lambdabot> Defined.
01:25:02 * omnId is acting mechanically, don't pretend I understand what I'm doing!  :D
01:25:24 <omnId> oooooooh.
01:29:10 <b_jonas> so... one possibility is this state monad wrapper over io
01:29:24 <omnId> > runCont (do k <- getCC; k) id
01:29:25 <lambdabot>  Exception: <<loop>>
01:29:32 <b_jonas> so then I'll be in a monad that wraps an Either, a State, and an IO together
01:30:34 <reinierrr> b_jonas: that shouldn't be too big a problem, i think
01:30:39 <b_jonas> what's the difference between these two Control.Monad.State wrapper modules?
01:30:42 <omnId> @unmtl ErrorT e (StateT s IO) a
01:30:43 <lambdabot> s -> IO (Either e a, s)
01:30:49 <omnId> @unmtl StateT s (ErrorT e IO) a
01:30:49 <lambdabot> s -> IO (Either e (a, s))
01:30:50 <reinierrr> b_jonas: when you define something like runIO = lift . lift
01:31:05 <b_jonas> reinierrr: probably not, because I'll always use IO and the State together
01:31:10 <b_jonas> never just State
01:31:48 <b_jonas> omnId: yes, something like that
01:31:59 <omnId> b_jonas: which?
01:32:14 <b_jonas> Control.Monad.State.Lazy and Control.Monad.State.Strict
01:32:32 <b_jonas> or if there's some other module I should use, then that too
01:32:37 <omnId> do you want to still be able to have a final state even if something goes wrong?
01:32:43 <reinierrr> 	b_jonas: you could define a function runIOWithState :: (StateType -> IO a) -> IO a?
01:33:12 <omnId> b_jonas: which of (ErrorT e (StateT s IO)) and (StateT s (ErrorT e IO)) do you want?
01:33:21 <b_jonas> omnId: if by something goes wrong, you mean that when I throwError, then yes I need the state
01:33:34 <b_jonas> I want ErrorT e (StateT s IO)
01:34:44 <b_jonas> reinierrr: I don't get that question
01:35:39 <b_jonas> if the state has multiple parts, I should use these magical braced datas, right?
01:35:49 <b_jonas> so I can change only one of them
01:35:57 <omnId> if you mean records, then sure :)
01:36:32 <b_jonas> yes, those
01:36:44 <reinierrr> b_jonas: I meant whether a function with that type wouldn't let you do IO with the state
01:37:05 <omnId> rec { field2 = val } is just sugar for: case rec of Constr field1 _ field3 -> Constr field1 val field3
01:37:05 <roconnor> *L* magical braced datas
01:37:23 * roconnor likes magic
01:41:54 <omnId> @@ @run reverse @show @protontorpedo
01:41:55 <lambdabot>  "gnidliub sorcam rof melborp a si gnipyt citats dias maharg luap"
01:43:37 <b_jonas> reinierrr: you mean that the state had IORefs and the like?
01:43:56 <b_jonas> because then yes, that's the other possibility I have to think about
01:44:13 <b_jonas> I've no idea if it's better than a StateT
01:47:26 <quicksilver> roconnor: that magic isn't magic enough, though
01:47:33 <b_jonas> yeah
01:47:36 <b_jonas> I don't like real magic
01:47:44 <omnId> @let half get xs = get (length xs `div` 2) xs
01:47:46 <lambdabot> Defined.
01:47:47 <quicksilver> roconnor: it would be nice magic if it gave decent 'modify' syntax too
01:47:47 <b_jonas> that's why I'm trying haskell
01:48:00 <b_jonas> it doesn't have those ugly magical bits like the dynamic languages
01:48:07 <omnId> @@ (@run half take @show @brain)(@run half drop @show @ghc)
01:48:08 <b_jonas> and I'm not talking about impurities here
01:48:09 <lambdabot>  "I think so, Brain, bu" "-incoherent-instances"
01:48:12 <b_jonas> just syntax stupidities
01:49:12 <b_jonas> and I want static typing for once
01:49:32 <salierix> What does this mean?
01:49:34 <salierix> Could not find module `Data.Array.IO':  it is a member of package array-0.1.0.0, which is hidden
01:49:34 <omnId> @@ (@read @run wordsWise (half take) @show @brain)(@read @run wordsWise (half drop) @show @ghc)
01:49:37 <lambdabot>   class declarations (via superclasses)
01:50:32 <sjanssen> salierix: it means the package hasn't been ported to GHC 6.8.1 yet.  Add array to the build-depends field in the .cabal file
01:51:03 <b_jonas> so _that's_ why IO arrays aren't documented
01:53:44 <omnId> @@ (@read @run wordsWise (take 6) @show @brain)(@read @run wordsWise (drop 2) @show @ghc)
01:53:44 <ac> What's a good template system?
01:53:46 <lambdabot>  I think so, Brain, but, the Malformed constructor signature
01:53:58 * omnId stops
01:54:07 <salierix> A lot of the programs listed on the wiki seem broken by ghc updates.
01:55:52 <sjanssen> salierix: yes, give them a few weeks to catch up
01:56:28 <quicksilver> ac: template in the sense of "chunks of text with a few substituable variables" ?
01:56:35 <sjanssen> salierix: actually, you mean example code on the wiki is broken?
01:56:36 <quicksilver> ac: or template in the sense of metaprogamming?
01:57:01 <salierix> sjanssen, http://www.haskell.org/haskellwiki/Applications_and_libraries
01:57:02 <lambdabot> Title: Applications and libraries - HaskellWiki
01:58:06 <salierix> A lot of them aren't active anymore and won't be updated.
01:58:26 <omnId> @let doubleQuote a b c d = printf "@@ (@read @run wordsWise (%s) @show @%s)(@read @run wordsWise (%s) @show @%s)" a b c d :: String
01:58:27 <lambdabot> Defined.
01:58:29 <dcoutts> salierix: if they're on hackage we can fix simple issues in their .cabal files
01:58:46 <dcoutts> like adding missing split-base deps
01:58:47 <omnId> @@ @@ @read @run doubleQuote "take 6" "brain" "take 2" "ghc"
01:58:48 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
01:58:55 <ac> quicksilver: the former. Just want simple string construction with maybe a tiny bit of code in mixed in
01:59:17 <ac> quicksilver: mainly want file includes
01:59:23 <omnId> :)
01:59:29 <b_jonas> wtf
01:59:48 <reinierrr> what's so wtf?
01:59:52 <quicksilver> ac: there are no good template libraries. Among the bad ones, Template::Toolkit is my favourite. :)
01:59:59 <quicksilver> ac: I'm not aware of a popular haskell one.
02:00:07 <omnId> @@ @@ @read @run doubleQuote "take 6" "brain" "drop 2" "ghc"
02:00:09 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
02:00:10 <ac> quicksilver: yeah, I was hoping for a Haskell one ;)
02:00:16 <omnId> :/
02:00:42 <salierix> Did HGL used to be part of ghc?
02:01:42 <b_jonas> reinierrr: messing with imports
02:01:52 <b_jonas> got an 'Ambiguous occurrence ' error
02:02:22 <quicksilver> salierix: no
02:02:52 <b_jonas> but it turns out that the Data.Array module has the Array definition of array functions, not the IArray ones
02:03:05 <quicksilver> salierix: very few libraries are 'part of ghc'. But HGL is not even distributed in the big extralibds bundle I don't think so.
02:03:12 <omnId> @let brainghc = doubleQuote "take 6" "brain" "take 12 . drop 2" "ghc"
02:03:14 <lambdabot> Defined.
02:03:24 <quicksilver> b_jonas: Array is a monomorphic interface, for simplicity if you don't like classes.
02:03:34 <quicksilver> b_jonas: IArray is a typeclass interface (see also MArray)
02:03:50 * ac installs libtemplate-perl
02:04:11 <b_jonas> yes, but I need the IArray interface
02:04:17 <b_jonas> because I'd like to use Unboxed arrays
02:04:22 <b_jonas> and well as normal arrays
02:04:31 <b_jonas> so I imported Data.Array.Unboxed instead
02:04:37 * quicksilver nods
02:05:06 <salierix> I'm looking at that 3d engine frag and I he uses an awful lot of IORefs..
02:05:12 <quicksilver> b_jonas: yes, use Data.Array.IArray and Data.Array.Unboxed
02:05:28 <quicksilver> salierix: poor style, in my opinion :) but I'm not pretending it doesn't work.
02:05:34 <quicksilver> there are lots of ways to write your code.
02:06:04 <b_jonas> so can you point me to the difference between Control.Monad.State.Lazy and Control.Monad.State.Strict
02:06:12 <b_jonas> or how to tell which one I need?
02:06:23 <quicksilver> to be honest, I don't htink you should care, for now
02:06:28 <quicksilver> just use Control.Monad.State
02:06:31 <sjanssen> b_jonas: just use the default Control.Monad.State for now
02:06:36 <quicksilver> don't try to digest too much at once :)
02:06:48 <b_jonas> Control.Monad.State doesn't tell any exports in the documentation though
02:06:49 <sjanssen> IIRC, Lazy is the default
02:07:00 <quicksilver> the difference is that the lazy version can build up a big thunk in the state, whereas the strict version keeps the state forced.
02:07:01 <b_jonas> so how do I use it?
02:07:45 <omnId> @@ @@ @read @run brainghc
02:07:45 <sjanssen> b_jonas: use the docs for .Lazy
02:07:46 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
02:07:51 <b_jonas> ok
02:07:51 <quicksilver> b_jonas: Control.Monad.State has one export, as the docs show.
02:07:55 <sjanssen> and .Class
02:07:58 <quicksilver> b_jonas: it exports Control.Monad.State.Lazy :)
02:08:24 <b_jonas> oh, it exports a whole module?
02:08:29 <quicksilver> right
02:08:30 <b_jonas> hmm
02:08:35 <b_jonas> ok, thanks
02:11:06 <b_jonas> 'Could not find module `Control.Monad.Error.Class':'
02:11:41 <b_jonas> but I have installed mtl, haven't I?
02:11:49 * b_jonas checks
02:13:12 <b_jonas> I have. wierd.
02:13:27 <b_jonas> do I need to do something after installing it from deb so that ghc would find it?
02:13:51 <earthy> -package mtl ?
02:14:08 <quicksilver> are you using ghc --make ?
02:14:21 <quicksilver> you should never need -package for ordinary programming work, if you use --make
02:17:00 <omnId> @@ @@ @read "@quote"
02:17:00 <lambdabot>  int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
02:18:12 <goalieca> @src finally
02:18:13 <lambdabot> a `finally` sequel = block $ do
02:18:13 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
02:18:13 <lambdabot>     sequel
02:18:13 <lambdabot>     return r
02:19:04 <quicksilver> it's much as you would imagine except in a first pass I'd probably forget the block/unblock or put it slightly in the wrong place :)
02:19:18 <b_jonas> quicksilver: no, ghci
02:19:34 <quicksilver> then that's very odd
02:19:39 <b_jonas> I'm not compiling it yet, I don't have a complete program
02:19:43 <alexj> @seen igloo
02:19:44 <lambdabot> igloo is in #ghc, #darcs and #haskell. I don't know when igloo last spoke.
02:19:44 <b_jonas> want to try some functions out
02:23:46 <b_jonas> wait
02:23:55 <b_jonas> apparently it can load Control.Monad.Error
02:23:57 <b_jonas> just not .Class
02:24:08 <b_jonas> it seems I don't even need .Class
02:24:59 <ac> does cabal have a dependency system like make?
02:25:04 <quicksilver> yes
02:25:09 <quicksilver> well I don't know about "like make"
02:25:12 <quicksilver> it's on a different level
02:25:21 <nominolo> ac, it will
02:25:28 <quicksilver> it doesn't have a dependency system which checks if files are modified and recompile them
02:25:29 <nominolo> ac: but atm we use ghc --make
02:25:32 <quicksilver> (ghc does that on its own)
02:25:51 <quicksilver> it has a dependency system which knows which other packages it needs to compile this one
02:26:03 <ac> does anybody know of a system that doesn't have such an annoying syntax as gnu make?
02:26:05 <nominolo> ac: we want to add one to cabal, so we can compile in parallel where possible
02:26:42 <quicksilver> ac: scons? aegis? ant?
02:26:49 <quicksilver> there are any number of 'improved make clones'
02:27:01 <ac> I figured, just wanted a recommendation
02:27:21 <nominolo> ndm says SCons is not working very well ..
02:27:37 <nominolo> i can't tell, i've never used any of those
02:27:44 <quicksilver> personally I cope with make
02:27:47 <quicksilver> but I'm used to it
02:27:53 <quicksilver> and ghc does most of the work :)
02:28:37 <ac> quicksilver: I'm actually using it to build a website. I've used make in the past for this
02:28:59 <ac> quicksilver: I think I used xslt for the templating, but I've gotten sick of xslt
02:28:59 <b_jonas> how does this definition work:
02:29:03 <b_jonas> class Monad m => MonadError e m | m -> e where
02:29:08 <b_jonas> I can't parse that
02:29:28 <b_jonas> is that a multi-parameter class?
02:30:16 <sjanssen> b_jonas: yes, and a functional dependency
02:30:22 <b_jonas> oh damn
02:30:26 <b_jonas> I don't want any of those
02:31:15 <b_jonas> @type throwError
02:31:23 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
02:31:36 <b_jonas> I'd like to declare a function like that that works inside any MonadError
02:32:02 <b_jonas> I'm trying
02:32:08 <b_jonas> throwJError :: (MonadError Ball m) => JErrorEnum -> m a;
02:32:15 <b_jonas> throwJError x = throwError $ BallJError x;
02:32:35 <b_jonas> here BallJError :: JErrorEnum -> Ball
02:33:01 <b_jonas> and I'm getting the error 'Non type-variable argument in the constraint: MonadError Ball m' for the declaration of throwJError
02:33:31 <b_jonas> how do I declare that function right/
02:33:44 <sjanssen> b_jonas: is -fglasgow-exts on?
02:33:49 <b_jonas> no
02:33:59 <sjanssen> try hat
02:34:01 <sjanssen> that
02:34:41 <b_jonas> ah, it compiled that way
02:34:42 <b_jonas> thanks
02:35:27 <b_jonas> at least, it gave errors for different parts of the code
02:47:16 <fasta> A certain method is executed in a state monad where a certain value exists (i.e. gets foo) will work in the do block before the call to the method. But the method has a type signature that states that the method should work for all monads, not just MonadState <foo bar>. Since I only want to use this for debugging, is there a way to not change the signature of the method(currently the compiler states that I need to create a larger context for that method
02:49:40 <quicksilver> not that I can think of
02:49:51 <quicksilver> if the type signature says it's polymorphic over all monads
02:49:54 <quicksilver> you can't get at the state
02:50:07 <quicksilver> why is it a problem to add MonadState to the type sig for now?
02:50:26 <fasta> quicksilver: I use it to debug some code.
02:50:42 <fasta> quicksilver: I.e. I debug a specific case.
02:51:50 <fasta> quicksilver: functors do solve this problem in e.g. OCaml, right?
02:51:59 <quicksilver> I don't think so.
02:52:05 <quicksilver> It is possible I don't understand you.
02:52:19 <quicksilver> you can't call 'gets' without a monadstate context
02:53:09 <fasta> I could also just pass everything as a function and not use type classes, but that would be messy.
02:53:30 <fasta> I am essentially using type classes as a kind of global function, now.
02:54:15 <salierix> Can case expressions have guards?
02:55:13 <fasta>  >case () of | 1==1 = True
02:55:24 <fasta>  > case () of _  | 1==1 = True
02:55:56 <fasta>  > case () of _  | 1==1 -> True
02:56:14 <fasta> salierix: the last one works, I don't use it that often.
02:58:39 * fasta doesn't like the existence of = and -> 
02:59:05 <b_jonas> oh, so there's a MonadState, not only a MonadError
02:59:29 <b_jonas> so that's why someone said yesterday that I can write all these functions that work in monads polymorphically over the monad
02:59:39 <b_jonas> funny
02:59:44 <fasta> There's also MonadCont
02:59:50 <fasta> And MonadWriter
02:59:56 <fasta> And a MonadReader (etc)
03:01:16 <b_jonas> and the instances for these are defined in such a way that the functions operating on them (throwError, get, put) are automatically lifted to the right level of nested monads, right?
03:01:20 <b_jonas> that's nice
03:01:25 <b_jonas> but it's also scary
03:01:59 <b_jonas> because it means that you could write a program working in a deep nesting of monads and don't even know what exact monads are around you
03:02:05 <b_jonas> the type checker figures that out for you
03:02:39 <quicksilver> yes
03:02:45 <quicksilver> but it means you can write state-only code
03:02:50 <quicksilver> which you can use with pure State
03:02:54 <quicksilver> and also with StateT IO
03:02:54 <EvilTerran> fasta, it might be possible to do something with overlapping instances so you could have, say, maybeGet and maybePut
03:02:59 <b_jonas> you are in a maze of twisty little monads, all alike
03:03:00 <quicksilver> (the most common two cases)
03:03:03 <nominolo> hm, what is the random number generator called, that works outside of IO ?
03:03:07 <reinierrr> but that's cool, not scary. Now I finally know how someone managed to layer 6 monads to write a simple embedded domain-specific language :)
03:03:10 <EvilTerran> it'd quite likely involve incoherent instances, actually...
03:03:20 <EvilTerran> never mind :P
03:03:21 <quicksilver> EvilTerran: ya, you could have MonadMaybeState
03:03:31 <b_jonas> and... is there something like MonadIO too
03:03:38 <quicksilver> EvilTerran: but I reall don't like incoherent or indeed overlapping instances
03:03:41 <b_jonas> with methods that lift to IO automatically?
03:03:46 <Saizan> ?src MonadIO
03:03:47 <lambdabot> Source not found. Do you think like you type?
03:03:49 <quicksilver> b_jonas: yes, and it's called MonadIO :)
03:04:00 <b_jonas> what module?
03:04:09 <horchata> i wonder if someone would be willing to critique http://paste.lisp.org/display/50570
03:04:14 <Saizan> Control.Monad.IO
03:04:15 <b_jonas> Control.Monad.Trans
03:05:10 <b_jonas> nice
03:05:20 <EvilTerran> quicksilver, oh right. i'm surprised you don't need at least overlapping.
03:05:23 <b_jonas> so this is the point of mtl!
03:05:27 <quicksilver> horchata: 'foldl (+) 0' is so common that it has a amee: 'sum'
03:05:35 <quicksilver> erm
03:05:38 <quicksilver> s/amee/name/
03:05:49 <horchata> quicksilver: ha, i was wondering thx
03:06:39 <b_jonas> cool
03:07:05 <quicksilver> EvilTerran: mtl needs overlapping, in fact
03:07:13 <quicksilver> EvilTerran: just to do the lifting it already does
03:07:16 <quicksilver> EvilTerran: I don't like it ;(
03:07:23 <EvilTerran> i *thought* so!
03:07:34 <quicksilver> EvilTerran: the mtl instances don't even make sense
03:07:44 <quicksilver> StateT a (StateT b Foo)
03:07:50 <quicksilver> which monadstate instance do we use there?
03:07:52 <EvilTerran> although it might be possible to do MaybeState without having overlapping in *that* module, owing to the way LANGUAGE extensions are scoped
03:08:02 <b_jonas> quicksilver:
03:08:04 <Saizan> quicksilver: a
03:08:08 <b_jonas> :k MonadState
03:08:09 <lambdabot> Class `MonadState' used as a type
03:08:16 <quicksilver> EvilTerran: personally I think the fundep in monadstate is a mistake.
03:08:21 <EvilTerran> quicksilver, neither, surely? looks rather incoherent to me
03:08:22 <b_jonas> anyway, it's a multiparameter thing
03:08:38 <quicksilver> b_jonas: yes, but it only supports one state type
03:08:47 <quicksilver> Saizan: I know there is a consistent answer. But I don't like it.
03:09:03 <quicksilver> Saizan: it relies on understanding which order overlaps are resolved in.
03:09:05 <b_jonas> can't it choose the right one to lift to depending on the type?
03:09:17 <quicksilver> b_jonas: that's what I meant when I said the fundep in monadstate is a mistake :)
03:09:20 <Saizan> well, simply there's no MonadState s m => MonadState s (StateT a m) instance
03:09:22 <visof> what are the differencies between haskell and scheme?
03:09:46 <quicksilver> visof: a type system.
03:10:00 <b_jonas> visof: haskell is strictly typed an pure (lazy referentially transparential)
03:10:03 <quicksilver> b_jonas: without the fundep, it could.
03:10:16 <b_jonas> quicksilver: I see
03:10:30 <quicksilver> I wrote a class called MonadContains for a questioner in this channel which did exactlyt hat
03:10:31 <b_jonas> I'm not actually sure it could do that even without fundep
03:10:33 <EvilTerran> visof, we have syntax :D
03:10:36 <b_jonas> but I can take your word
03:10:37 <quicksilver> it was, basically, MonadState without the fundep.
03:10:48 <quicksilver> well I used explicit instances
03:10:50 <nominolo> @ho MonadState
03:10:51 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
03:10:52 <quicksilver> not instance scehmes.
03:11:13 <quicksilver> in many cases I think mtl should be viewed as a worked example rather than a library.
03:11:19 <visof> EvilTerran what do you mean?
03:11:23 <quicksilver> I don't really like the overlaps or the instance schemes.
03:11:32 <quicksilver> although they're convenient for toy examples.
03:12:09 <EvilTerran> visof, s-expressions were originally invented as a handy way of representing a syntax tree. it just happened that some people were masochistic enough to write 'em directly.
03:12:33 <wli> Then how about a version of the MTL directly usable as a library?
03:12:34 <Saizan> i wonder how many type annotation you'd usually have to insert without the fundep
03:12:35 <EvilTerran> *we*, on the other hand, have if/then/else as a syntactic construct, infix operators, list comprehensions, blahblahblah
03:12:37 <b_jonas> EvilTerran: haskell doesn't have such a complicated sytanx either
03:13:00 <EvilTerran> b_jonas, i only said we had *some* syntax, not a *lot* of syntax.
03:13:01 <b_jonas> and some parts that are more complicated come from the type system
03:13:11 <EvilTerran> i think haskell's fairly near the sweet spot in that regard
03:13:56 <b_jonas> on the other hand, haskell is lazy which avoids the most common use of macros (implicit abstrcting)
03:14:22 <quicksilver> Saizan: quite a lot if you just use get and set
03:14:37 <b_jonas> like, you can have "if" as a function instead of a macro
03:14:38 <quicksilver> Saizan: but none if you use custom primitive
03:14:48 <quicksilver> Saizan: which is the way god intended custom monads to be used :)
03:14:50 <sannysanoff> hi gentlemen, little question, how to convert Data.Sequence to List ? i maybe missed something..
03:14:57 <quicksilver> sannysanoff: toList
03:15:06 <quicksilver> sannysanoff: the reason you missed it, is it's in Data.Foldable
03:15:15 <quicksilver> sannysanoff: I keep meaning to write a wiki page about that :)
03:15:18 <sannysanoff> ok, thanks! will see
03:15:22 <wli> quicksilver: The MTL looks like it DTRT much of the time to me.
03:15:47 <quicksilver> wli: it's the instance schemes I object to.
03:15:59 <wli> quicksilver: Not sure what you mean there.
03:16:01 <quicksilver> wli: I think
03:16:08 <quicksilver> wli: they require overlaps
03:16:21 <quicksilver> which is always a bad sign, IMO.
03:16:40 <sjanssen> quicksilver: the library doesn't actually use overlapping instances
03:16:46 <quicksilver> sjanssen: it doens't?
03:16:53 <quicksilver> then I must have badly misunderstood something
03:16:56 <b_jonas> DTRT?
03:16:56 <quicksilver> I was sure it did?
03:17:00 <sjanssen> it does have O(n^2) instances
03:17:40 <quicksilver> hrm
03:17:42 <sjanssen> rather, O(c*t) where c is the number of classes and t is the number of transformers
03:17:45 * quicksilver nods
03:18:11 <quicksilver> I now feel confused :)
03:18:17 <quicksilver> I'm sure I spotted an overlap.
03:18:21 <quicksilver> I must have been wrong.
03:18:27 <quicksilver> I apologise to the mtl for my harsh word.
03:18:27 <OceanSpray> This is my first attempt at an all nighter.
03:18:28 <quicksilver> s
03:19:16 <quicksilver> sjanssen: I do *wish* that the standard IO primitives were all in MonadIO though
03:19:30 <sjanssen> quicksilver: yes, that would be really useful
03:19:33 <Sizur> is there a function in prelude to fold over infinite lists that takes termination clause?
03:19:43 <b_jonas> quicksilver: but IO has lots of primitives
03:19:46 <wli> quicksilver: The Prelude and a fair number of compiler intrinsics need a rotoroot.
03:19:53 <b_jonas> I mean, all the operating system stuff is there
03:20:00 <b_jonas> it's potentially infinite
03:20:18 <b_jonas> IO is ever-growing unlike some other monads like state
03:20:25 <sjanssen> at least all of System.IO could be covered
03:20:30 <wli> quicksilver: BTW http://holomorphy.com/~wli/LiftedIO.hs
03:20:41 <sjanssen> and something could be done for FFI declarations
03:20:50 <b_jonas> sjanssen: then people would be complaining why their favourite function is not there
03:21:07 <b_jonas> with interpreters I keep complaining why there's no wrapper of some unix functions
03:21:32 <sjanssen> b_jonas: there are a finite number of intrinsic IO operations, plus FFI imports
03:21:59 <sjanssen> we could allow MonadIO for FFI imports, and give all the intrinsics MonadIO
03:22:12 * quicksilver nods
03:22:15 <quicksilver> that would really help
03:22:24 <quicksilver> it would make me more likely to use ReaderT IO
03:22:25 * wli points to http://holomorphy.com/~wli/LiftedIO.hs
03:22:30 <fasta> wli: that would look nicer with TH.
03:22:35 <b_jonas> sjanssen: by intristic, do you mean the ones that don't interact with the kernel, like iORef, IOArray, etc?
03:22:41 <quicksilver> currently I find readerT IO adds more gunk that it saves
03:23:06 <b_jonas> I don't know what's implemented as FFI and what isn't
03:23:11 <b_jonas> I'm not familiar with the internals
03:23:21 <sjanssen> b_jonas: basically, things that must be implemented in terms of compiler internals
03:23:34 <sjanssen> like Handle IO
03:23:44 <quicksilver> b_jonas: 'intrinsic' in this sense, means written by the compiler authors
03:23:52 <quicksilver> as opposed to written in pure haskell by any old library author
03:24:08 <quicksilver> however you can 'liftIO' both kinds just as well.
03:24:12 <Saizan> quicksilver: maybe you confused overlapping with undecidable instances, which mtl indeed uses
03:24:20 <b_jonas> dunno
03:24:24 <wli> do notation desugaring, list/monad comprehension desugaring, etc.
03:24:44 <b_jonas> I don't feel the need of this because the interpreter I'm writing is supposed to use IO primitives in few places
03:24:47 <quicksilver> Saizan: hmm maybe. But the mtl stuff isn't really undecidable, is it? Just fails the coverage condition?
03:25:02 <quicksilver> b_jonas: if you have few enough primitives to lift your own, it's no problem at all
03:25:08 <quicksilver> but try it when you're using openGL
03:25:09 * quicksilver shivers
03:25:32 <b_jonas> quicksilver: yeah, that's it
03:25:39 <b_jonas> then it would be bad
03:26:00 <sjanssen> quicksilver: we have to do quite a bit of lifting in xmonad.  So much that we've shortened liftIO to io
03:26:45 <quicksilver> sjanssen: *nod*
03:26:52 <quicksilver> sjanssen: then you've experienced what I mean
03:27:29 <sjanssen> maybe we should just rewrite the X11 lib to use MonadIO everywhere :)
03:29:31 <hpaste>  quicksilver pasted "example of ReaderST which isn't" at http://hpaste.org/3762
03:29:40 <sjanssen> hmm, ubiquitous MonadIO would quickly run afoul of the DMR
03:30:08 <quicksilver> sjanssen: see my paste. Logically that's in ReaderT IO, out of the 5 lines there, three use the 'read-only state' object 'st'
03:30:28 <quicksilver> sjanssen: but if I fix those three, I have to add liftio $ to the other two
03:30:30 <quicksilver> just annoying :)
03:31:07 <wli> How could the O(c*t) problem be addressed?
03:31:18 <sjanssen> wli: overlapping instances
03:31:24 <SamB_XP> the what?
03:31:31 <SamB_XP> speed of light times time?
03:31:35 <wli> sjanssen: ouch
03:31:52 <wli> O(classes*transformers)
03:32:08 <SamB_XP> ah
03:33:28 <quicksilver> sjanssen: having said that, I'd decided to refactor all that code to use a custom monad anyway as an experiment. I'll see how much the lifts annoy me.
03:34:02 <b_jonas> quicksilver: you can use mtl with a specific monad
03:34:08 <b_jonas> I'm planning to do that
03:34:14 <b_jonas> I'll use only two monads all over the code
03:34:31 <quicksilver> cale will tell you it's best to newtype them
03:34:36 <quicksilver> and I agree with him
03:34:40 <b_jonas> I'm newtyping them
03:34:58 <b_jonas> um no
03:35:02 <b_jonas> I'm typeing them
03:35:04 <b_jonas> not newtypeing
03:35:06 <wli> quicksilver: Could you re-describe your ideas for integrating MPTC and/or typeclasses in general with module systems?
03:35:10 <b_jonas> the transformer does the newtype
03:35:24 <quicksilver> wli: are you expecting me to remember something I said several days ago?
03:35:33 * quicksilver struggles to sort through the inside of his head
03:36:17 <wli> quicksilver: There's some kind of instance selection problem with modules vs. typeclasses that occurs even with the current weak module system.
03:36:19 <b_jonas> type Hope = Either Ball; -- is the purer monad I use
03:36:27 <quicksilver> Cale: where's your "the right way to do monad transformers? I can't find it"
03:36:34 <b_jonas> and I haven't yet started the other, but it will be something like
03:36:50 <quicksilver> wli: ah, that one
03:37:01 <quicksilver> wli: I'm in favour of a lexical instance selection primitive
03:37:06 <b_jonas> type Something1 = ErrorT Ball (StateT Something2 IO)
03:37:17 <b_jonas> why'd I newtype them?
03:37:24 <quicksilver> with (Int using Monoid Additive) (1 `mappend` 3)
03:37:26 <wli> quicksilver: I don't understand the original problem to begin with.
03:37:28 <quicksilver> something like that
03:37:55 <quicksilver> well the problem is that there are in general, many sensible ways to make types instances of classes
03:38:06 <quicksilver> for example, a generic "StateT BigBundleOfState IO"
03:38:13 <sjanssen> quicksilver: "lexical instance selection primitive"?  Like 'case' over types, or something you add to the context of your function?
03:38:21 <quicksilver> is a sensible MonadState for any 'LittlePieceOfState'
03:38:47 <quicksilver> so you want to be able to run sub-ctions which apply to all the little bits of state
03:38:51 <quicksilver> using lenses and stuff
03:38:55 <quicksilver> just one monadstate instance doesn't really cut it
03:38:56 <b_jonas> "well the problem is that there are in general, many sensible ways to make types instances of classes" -- reminds me to http://xkcd.com/309/
03:38:57 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
03:39:15 <quicksilver> sjanssen: it just (lexically) changes which instance to use
03:39:28 * SamB_XP almost wishes xkcd comics had names in the <TITLE> tags
03:39:37 <quicksilver> sjanssen: so, suppose f :: (Monoid m) => m -> String
03:39:57 <b_jonas> hey, now that state thing isn't a problem with the whole transformer thingy
03:40:07 <quicksilver> sjanssen: and I write "with (Int using Monoid Additive) { f (3 :: Int) }
03:40:11 <b_jonas> that only wants a generalization of MonadState
03:40:19 <quicksilver> sjanssen: then, it has to pass a dictionary to 'f'
03:40:24 <b_jonas> or maybe I can't see the abstract from your example
03:40:38 <quicksilver> sjanssen: normally haskell assumes there is only one Monoid instance for Int, by definition
03:40:50 <quicksilver> sjanssen: my 'with' construct brings a different 'default dictionary' in scope
03:40:53 <quicksilver> sjanssen: make sense?
03:40:57 <sjanssen> yes
03:40:58 <SamB_XP> b_jonas: where are we going to get a non nerd?
03:41:09 <wli> quicksilver: Basically manual selection for overlapping typeclasses.
03:41:21 <quicksilver> wli: overlapping or not. Yes. Manual selection for typeclasses :)
03:41:31 <quicksilver> I'm not suggesting the automatic selection goes away
03:41:37 <quicksilver> just this is added as another mechanism
03:41:45 <wli> quicksilver: The non-overlapping case would be inferenceable anyway.
03:41:58 <quicksilver> so I can say with ([a] using Monad ZipList) { do .... }
03:42:13 <quicksilver> but still keep the 'normal' monad instance for [] around for most of hte code
03:42:50 <sjanssen> the typical way to do this is via newtype wrappers
03:42:56 <quicksilver> yes
03:43:01 <quicksilver> but I find that a bit noisy
03:43:16 <quicksilver> the MonadState example is more interesting, really
03:43:20 <sjanssen> yes
03:43:22 <quicksilver> StateT BigBundleOfState IO
03:43:31 <quicksilver> is instances of MonadState and MonadReader in all sorts of ways
03:43:53 <quicksilver> you can patch it together with lifting functions currently
03:44:00 <b_jonas> I think it's time that I add a formatter before I write the other parts of the parser
03:44:02 <quicksilver> but I think it could be more pleasant than it is
03:44:09 <SamB_XP> quicksilver: are you going to implement this?
03:44:22 <b_jonas> because my lexer function now lexes "'foo'" to Right [JWordDatum (JDatumNoun (JNounOut [3] (JNounChar (array (0,2) [(0,102),(1,111),(2,111)]))))]
03:44:27 <quicksilver> SamB_XP: I lack the knowledge of ghc internals to implement anything
03:44:34 <b_jonas> and it should really be one more level of contructors in that
03:44:41 <b_jonas> which I'll only add later
03:44:49 <quicksilver> b_jonas: that looks more like a parse than a lex to me :)
03:44:53 <SamB_XP> quicksilver: you could implement it in a toy language
03:45:03 <quicksilver> I might at least write it into a proper proposal
03:45:09 <quicksilver> so cleverer people than me could find holes in it
03:45:18 <quicksilver> there is a paper about completely manual instance selection
03:45:22 <b_jonas> quicksilver: it's like scheme or postscript: it reads code to stuff that's like data the code works with
03:45:29 <wli> I'd settle for undoing the Prelude f**ktardation with the fail method and removal of Monad0, and reinstating monad comprehensions.
03:45:36 <b_jonas> but as it's not recursive, I call it lex
03:45:41 <b_jonas> that is, it won't lex me a tree
03:45:43 <quicksilver> b_jonas: *nod* I read your comments the other day in scrollback :)
03:46:13 <b_jonas> hmm, all of postscript, logo, and lisp can read trees
03:46:20 <b_jonas> only J can't
03:46:27 <b_jonas> that's strange
03:46:46 <b_jonas> so I have to write the formatter now
03:46:56 <b_jonas> and only then add the other rules to the lexer
03:47:33 <SamB_XP> logo can read trees?
03:48:09 <b_jonas> I think it can but I'm not sure
03:49:29 <quicksilver> logo is a different syntax for lisp, isn't it?
03:49:39 <wli> quicksilver: How would module systems fit into the picture here?
03:49:39 <b_jonas> not really I think
03:49:57 <b_jonas> some say that, but some say that of other languages like ruby as well
03:50:24 <wli> quicksilver: Would you use them to bring instances into scope if instances were scoped, hideable, etc., and local imports were possible?
03:50:26 <quicksilver> wli: well you'd need to be able to name instances and export several
03:50:37 <quicksilver> wli: and modules would be able to export a default instance too
03:50:40 <SamB_XP> it's more true with logo, I think
03:50:50 <quicksilver> and you'd get a compile-time error if two different defaults came in scope
03:50:51 <quicksilver> I guess
03:50:57 <quicksilver> (or perhaps, only when you tried to use it)
03:51:06 <wli> quicksilver: Sounds like a plan to me.
03:51:39 <wli> quicksilver: Just have to learn enough of the ghc api to implement it, I guess.
03:51:42 <sannysanoff> quicksilver, i'm back, thanks, it worked out. I expected Data.Sequence to re-export it, now will not ;-)
03:52:34 <quicksilver> sannysanoff: yes, when using Data.Sequence you have to look also in Data.Foldable and Traversable for useful methods.
03:52:49 <quicksilver> (it's also an instance of Monoid but it does give new names to mempty and mappend)
03:53:44 <wli> quicksilver: Probably a far longer-term goal than removing Monad's fail method, reinstating Monad0, and turning list comprehensions back into monad comprehensions and pattern match failures in do blocks into Monad0 constraints.
03:54:49 <b_jonas> wow, you want to make a whole new haskell language, not just a new mtl?
03:54:49 <quicksilver> wli: well the it might be less contentious though :)
03:55:05 <quicksilver> after all, all those things you mentioned were discussed and explicitly rejected
03:55:08 <quicksilver> not simply not implemented
03:55:47 <wli> quicksilver: Bringing monad comprehensions back is explicitly blessed AIUI.
03:55:50 <SamB_XP> quicksilver: what things were specifically rejected?
03:56:45 <quicksilver> SamB_XP: monad comprehensions, pattern match failures giving monad0 contraints, removing monad's fail.
03:57:00 <SamB_XP> quicksilver: what the heck are you talking about?
03:57:05 <quicksilver> these were all features in certain versions of haskell
03:57:09 <SamB_XP> oh, that
03:57:11 <quicksilver> but removed before haskell98
03:57:14 <SamB_XP> THAT
03:57:17 <SamB_XP> yeah
03:57:21 <SamB_XP> that happened, but...
03:57:30 <SamB_XP> does anyone still think it was a good idea?
03:57:40 <quicksilver> I was under the impression they did.
03:57:49 <quicksilver> After all it's a trivial change in ghc and it hasn't been made.
03:57:58 <wli> Who precisely is still arguing in their favor? AIUI there's broad consensus that those decisions were errors.
03:58:00 <quicksilver> monad comprehensions, at least, is trivial.
03:58:14 <sjanssen> none of these are trivial when you consider backwards compatibility
03:58:17 <SamB_XP> we should just trash Haskell 98
03:58:30 <quicksilver> sjanssen: well monad comprehensions alone don't break old code
03:58:33 <wli> SamB_XP: No, we should set a new standard.
03:58:36 <quicksilver> and the others could be off-by-default options
03:58:38 <quicksilver> as a start
03:58:52 <sjanssen> quicksilver: are you sure?  In the presence of the DMR?
03:59:07 <quicksilver> sjanssen: maybe you need a DMR hack to default to [] :)
03:59:22 <quicksilver> maybe they should all be off-by-default options
03:59:38 <SamB_XP> quicksilver: it's hard to introduce MonadZero without breaking everything
03:59:39 <wli> I thought the DMR could be wholly abandoned.
04:00:01 <SamB_XP> I thought dmr was the R in K&R
04:00:36 <mauke> dennis monad ritchie
04:00:51 <wli> Dreaded Monomorphism Restriction
04:01:32 <sjanssen> it would also be difficult to remove fail with a flag
04:01:42 <dcoutts_> I don't see why the MR is so bad, all it needs is a type annotation to use the value polymorphicly
04:02:16 <dcoutts_> and doesn't ghc's error message these days indicate that it is due to the MR and you can add a type sig or use a flag
04:02:23 <SamB_XP> dcoutts: if we had type holes it might not be so bad
04:02:37 <sjanssen> dcoutts_: it can be annoying when you're writing a quick hack
04:02:58 <wli> -fno-monomorphism-restriction is standard here.
04:03:14 <wli> I've not seen it in ages because I've explicitly turned it off.
04:03:29 <wli> For all use, practical or otherwise.
04:03:33 <dcoutts_> sjanssen: we need those IDEs that apply the fixes for us, importing modules, adding type sigs to turn off the MR etc etc :-)
04:04:33 <wli> Structure editors?
04:04:55 <sjanssen> wli: not necessarily.  Even eclipse can do the sort of fixes dcoutts_ mentions
04:05:37 <dcoutts_> eg when the compiler suggests a fix, the IDE should allow you to apply that fix by clicking a button
04:05:47 <sjanssen> eclipse's fixes are pretty amazing, IMO
04:05:54 <dcoutts_> like importing a module is an easy one
04:06:06 <dcoutts_> or a specific thing from a module
04:06:22 <dcoutts_> or if it's available with compatible types from several modules, then presenting a list
04:06:28 <ricky_clarkson> Eclipse's are rubbish compared to IDEA's.
04:07:29 <ricky_clarkson> Hmm, wrong channel.  Is there a workable plugin for Haskell for Eclipse these days?
04:08:05 <sjanssen> eclipsefp, I have no idea if it is "workable"
04:08:30 <sjanssen> for the record, I was talking about Eclipse's Java fixes
04:08:37 <quicksilver> it's certainly not clever like the java mode is
04:08:54 <ricky_clarkson> Me too, not realising that I was in #haskell.  IDEA shits on Eclipse from a great height for editing Java.
04:10:22 <sjanssen> that only enhances my point: we have nothing like that for Haskell
04:11:14 <sjanssen> can you imagine the possibilities?
04:11:45 <sjanssen> "You've written a type signature but not a function body, would you like djinn to write one for you?"
04:12:26 <ricky_clarkson> That sounds too much like the Office paperclip.
04:12:29 * ricky_clarkson gets aggressive.
04:12:52 <sjanssen> right, the real error message would be less conversational
04:13:06 <ricky_clarkson> Why do people write these things for Eclipse, and not, say, for emacs?
04:13:19 <SamB_XP> also, it would probably only happen if you tried to compile?
04:13:30 <mauke> "It looks like you're trying to write an EDSL"
04:14:16 <ricky_clarkson> Naughty programmer.  Ints are not Integers.  Right, back to yaht for you.
04:14:29 <SamB_XP> that would be like "it looks like you're trying to write a document" in word
04:15:39 <ricky_clarkson> I like code-aware editors, but I think they have a stagnating effect.  For example, a prototype for Java 7 came out recently, and most interested parties won't try it until their IDE supports it.
04:16:20 <ivanm> heh
04:16:39 * ivanm prefers text editors... but _good_ text editors with syntax highlighting, etc.
04:16:54 <ivanm> could never stand using IDEs... too much hassle
04:17:43 <ricky_clarkson> At the moment for Java I use emacs most of the time, and IDEA when I want code awareness.  Haskell seems a more vim-ish language somehow.
04:17:58 <ivanm> "vim-ish" ?
04:18:19 * ivanm uses emacs + JDE + ECB for java when he can't get away with not using java
04:18:31 <nominolo> we're working on "code-awareness" for Yi, but we need more workforce of course
04:18:38 <ricky_clarkson> Closer to C in some way.  I'm not sure what I mean.
04:18:44 * wli uses nvi-1.79
04:19:32 <ivanm> wli: is nvi that volatile that the version number is required to specify what you use? :p
04:20:05 <ivanm> nominolo: would this code awareness be haskell specific?
04:20:46 <wli> ivanm: point
04:20:48 <nominolo> ivanm: yes.  well, the framework would probably become generic someday, but we start with haskell-support
04:21:02 <ivanm> *nod*
04:21:31 * wli feels that nvi-1.79 is bloated, though. There are perl -related extensions he never uses, for instance.
04:21:40 <ricky_clarkson> ivanm: ECB led me towards the semantic bovinator.  Fantastic name.
04:21:42 <nominolo> atm, it's only jyp working on it.  i'll try to catch up on his work
04:21:55 <ivanm> so is this code awareness as in intricately knowing haskell so that it acts as a programmer's aid? or programmed knowlege of syntax as you'd find in e.g. emacs?
04:21:58 <wolverian> wli, can't you compile it with only the core bits in? vim lets you do that
04:22:23 <ivanm> ricky_clarkson: I have issues with the bovinator... keeps throwing up weird errors every now and again... and it's almost useless for haskell
04:22:37 <wli> wolverian: I always turn it off if/when I compile it myself, but its mere presence in the codebase offends me.
04:22:46 <wolverian> wli, ah, so you're insane.
04:22:50 <wolverian> check.
04:22:55 <nominolo> ivanm: my personal goal is the possibility for a structural editor, type-directed completion and such
04:22:58 <wli> wolverian: Pretty much, yeah.
04:23:09 <wolverian> wli, unless you maintain the codebase :)
04:23:17 <ivanm> nominolo: what do you mean by "structural editor"? as in folding, etc.?
04:23:26 <nominolo> ivanm: and of course refactoring support
04:23:41 * ivanm wishes he could get folding mode in emacs working with haskell :s
04:23:51 <nominolo> ivanm: structural editor basically means, your program is always spyntactically correct
04:24:10 <ivanm> and I wonder how much of a help refactoring support would be with haskell...
04:24:13 <wolverian> makes me think of epigram
04:24:22 <ivanm> nominolo: so it checks that it compiles?
04:24:23 <nominolo> ivanm: and you have operations like delete/cut/copy expressions
04:24:29 <nominolo> ivanm: no
04:24:33 <ivanm> hmmm...
04:24:36 <wolverian> ivanm, no, you edit the structure instead of characters.
04:24:38 <wolverian> think DOM.
04:24:44 <ivanm> DOM = ?
04:24:51 <wolverian> document object tree :)
04:25:03 <wli> s/tree/model/
04:25:05 <ivanm> so M stands for Tree?
04:25:06 <wolverian> er
04:25:06 <ivanm> heh
04:25:14 <wolverian> yeah, I'm high on painkillers
04:26:16 <nominolo> ivanm: your editor doesn't work on characters or words, but on the syntactical structure of your document
04:26:48 * ivanm still isn't sure that he gets what that means...
04:26:51 <wli> Usually semantics are taken into account as well.
04:26:58 <ivanm> @go DOM wikipedia
04:27:01 <lambdabot> http://en.wikipedia.org/wiki/DOM
04:27:01 <lambdabot> Title: Dom - Wikipedia, the free encyclopedia
04:27:12 <ivanm> @go structural editor wikipedia
04:27:14 <lambdabot> http://en.wikipedia.org/wiki/Sam_(text_editor)
04:27:23 <ivanm> I don't think that's the right one :p
04:28:44 <wolverian> http://en.wikipedia.org/wiki/Structural_editor
04:29:21 <ivanm> yeah, I ended up finding it
04:29:59 <ivanm> from what I understand, I'm not exactly sure how helpful it would be...
04:30:19 <ivanm> since AFAICT it basically means that the editor can tell where the start and end of functions are...
04:30:50 <mauke> your typical text editor gives you lines of characters to edit: [String]
04:31:02 <mauke> I imagine a structural editor would let you work on the AST
04:31:17 <ivanm> AST = ?
04:31:26 <quicksilver> paredit is a structural editing mode for emacs
04:31:31 <ricky_clarkson> It could look like a text editor while it does so.
04:31:34 <wolverian> ivanm, it's certainly useful in a limited sense for e.g. docbook documents. texmacs is also a good example.
04:31:34 <quicksilver> it even works with haskell, to an extent.
04:31:52 <ricky_clarkson> ivanm: That's really a term worth googling, but.. abstract syntax tree.
04:31:59 <quicksilver> mauke: doesn't let you work on an *A* ST, but rather a concrete syntax tree
04:32:02 * ivanm looks up paredit
04:32:28 <ivanm> ricky_clarkson: there is quite possibly many different terms for which AST could stand for
04:33:44 <nominolo> isn't concrete syntax the actual program text?
04:33:55 <dcoutts_> yep
04:34:06 <nominolo> well, the point is:  for Yi we try to have it optional
04:34:20 <ivanm> *nod*
04:34:38 <nominolo> ie. either Yi tries to make sense of what you write, or you make sure it always is (syntactically) correct
04:35:00 <nominolo> jyp wants the former, I the latter :)
04:35:09 <nominolo> but we can use the same tools to do that ..
04:35:29 <quicksilver> the simple things you need are stuff like always closing blocks at the same time you open them, etc
04:35:42 <ivanm> quicksilver: does paredit work with haskell out of the box? or are there extra tweaks required?
04:36:12 <quicksilver> it works out of the box
04:36:19 <quicksilver> but some things it does are slightly surprising :)
04:36:19 <nominolo> should work out of the box, but, eg, C-k is working on sexps
04:36:27 <ricky_clarkson> Huh?  I thought paredit was for sexprs only.
04:36:28 <quicksilver> I even use it on perl code
04:36:31 <nominolo> instead on lines
04:36:36 <quicksilver> ricky_clarkson: many people do. They are all wrong.
04:36:45 <quicksilver> "sexp" is actually abused
04:36:45 <ivanm> what kind of suprising things?
04:36:58 <quicksilver> ivanm: if you use M-S to splice, it reindents stuff oddly
04:37:00 <ivanm> I gather that it makes usage of standard parenthesis difficult...
04:37:23 <nominolo> no
04:37:23 <quicksilver> it may get confused by certain chars which are special in lisp but not in haskell
04:37:34 <quicksilver> still it's lovely for editing, e.g., [(a,b)] literals
04:37:44 <quicksilver> really nice to have all your layers of brackets automatic
04:37:46 <ivanm> quicksilver: "splice"?
04:37:56 <quicksilver> ivanm: ((a b) c d) ----> (a b c d)
04:38:17 <quicksilver> well, the more common case is (a (b) c) --> (a b c) I guess
04:38:19 <ivanm> ahhh, k
04:38:54 <nominolo> there's also things like:  (a b c) d ---> (a b c d)
04:40:22 <nominolo> for example if you want to put parens around something:  a b c d -"("--> () a b c d --"C-Right"-->  (a) b c d --"C-Right"---> (a b) c d
04:40:40 <nominolo> parens always stay balanced
04:41:13 <ivanm> hmmm...
04:41:15 <nominolo> and if you press ")" it jumps to the closing paren and re-indents your code
04:41:30 <nominolo> but for haskell, that might screw up your code
04:41:51 <ricky_clarkson> Presumably something like paredit would let you have lisp with optional parens, without being able to get bugs during code editing.
04:42:52 <nominolo> lisp with optional parens?  isn't that haskell?
04:43:17 <fasta> Can I compose two StateT's?
04:43:28 <nominolo> (foo bar (baz a b c)) ==> foo bar (baz a b c)
04:43:42 <nominolo> fasta: not nicely
04:44:00 <fasta> nominolo: how can it be done nicely?
04:44:06 <nominolo> well, they can be distinguished by the type
04:44:06 <fasta> nominolo: not nicely*
04:44:21 <fasta> nominolo: i.e. can I use lift?
04:44:23 <nominolo> hm, could work
04:44:57 <nominolo> since MonadState has an 's' parameter this might actually work
04:45:00 <matthew_-> @where agda
04:45:01 <lambdabot> http://tinyurl.com/yp6zsr
04:45:10 <nominolo> fasta: you don't even need lift
04:46:01 <fasta> nominolo: are you saying that 1 <- get; "1" <- get should work?
04:46:24 <nominolo> fasta: i think it should
04:47:01 <ToRA> > (flip evalStateT False . flip evalStateT "hi" $ (lift get) >>= (\x -> if x then  get else get)) :: Maybe String
04:47:04 <lambdabot>  Just "hi"
04:47:18 <ToRA> you need the lift
04:47:27 <freepenguin> hi
04:51:04 <nominolo> right
04:51:23 <nominolo> well, you can have getInner = get ;  getOuter = lift . get
04:51:38 <nominolo> er, other way round
04:51:58 <ToRA> you can also write a typeclass ala liftIO if all the types in the states are unique
04:52:10 <roconnor> fasta: http://hpaste.org/3202
04:52:24 <ToRA> tho the effort involved in terms of thought and writing instances might be more than just getInner/getOuter methods
04:56:07 <quicksilver> just write the correct primitives
04:56:11 <quicksilver> to get at the right state
04:56:26 <quicksilver> (although the typeclass tora speaks of is just monadstate with the fundep removed)
04:58:07 <ToRA> and if you remove that fundep then it will break if you try and layer two mstates with the same component type?
04:58:14 <quicksilver> correct
04:58:20 <quicksilver> although you could solve that with a newtype
04:58:24 <quicksilver> if you were so inclined
04:58:25 <quicksilver> http://hpaste.org/3202
04:58:30 <quicksilver> ^^ here's one I made earlier
04:58:40 <ToRA> yeah
04:58:54 <quicksilver> I'm not actually suggesting this as a sensible technique
04:58:59 <quicksilver> just commenting on possibilities
04:59:09 <quicksilver> I would recommedn custom typeclasses personally
04:59:17 <quicksilver> 'MonadDoesThis' and 'MonadDoesThat'
04:59:26 <quicksilver> and writing instances for the stacks you use
04:59:43 <ToRA> very little point in layering directly state over state tho, it's only useful if you have some control-flow mtrans inbetween?
04:59:55 <quicksilver> well
05:00:02 <quicksilver> it's useful to allow more polymorphism
05:00:11 <quicksilver> some of your code might only need one of the state stacks
05:00:14 <quicksilver> some of it, the other
05:00:16 <quicksilver> and some of it, both
05:00:25 <fasta> ToRA: the code in state monad A is written independently of state monad B.
05:07:02 <ToRA> fasta: ah ok
05:08:55 <ToRA> fasta: is your code in state monad A depending on a StateT A y, or just a MonadState A m => ?
05:11:14 <fasta> ToRA: I use evalStateT and runStateT, so two times StateT.
05:11:50 <fasta> The issue really is that I would like to use type classes, but I don't want to specify the type :)
05:12:02 <hpaste>  ToRA pasted "v.simple state monads with different stacks" at http://hpaste.org/3764
05:12:40 <ToRA> so it's not like the pattern in the paste?  where foo1 is under stack A, foo2 is in stack B and test is the glue that uses both together?
05:13:52 <fasta> ToRA: the stack is the same, but I call a type class method in the deepest monad.
05:15:14 <ToRA> so foo1 and foo2 both (for example) would need another constraint on the m (e.g. MonadIO or MonadError)?
05:15:39 <fasta> ToRA: of a custom class, yes
05:15:48 <ToRA> ok
05:16:36 <fasta> ToRA: I also have a MonadST contraints on it.
05:16:41 <fasta> constraint*
05:17:48 <ToRA> heh, that sounds like quite a big stack :)
05:20:28 <fasta> ToRA: no, the stack is only 2 high.
05:20:46 <fasta> ToRA: it just has quite a lot constraints which make refactoring it a nightmare.
05:21:37 <ToRA> ah
05:22:22 <ToRA> what's this for, outta curiosity?
05:22:30 <ttfh> if I have "data Bug = Bug { id :: Int ..." and the id should be unique within a database of bugs, is there some clever way of enforcing this?
05:22:52 <fasta> ToRA: although semantically, I only want to make a small change(showing some information that is stored in a reference for which I need the "outer-state").
05:27:30 <quicksilver> ttfh: yes. Don't store the id in the bug
05:27:32 <ttfh> I'm thinking about using a typeclass "SequenceMonad" or something, which keeps track of unique IDs, and then I would have "makeBug :: (SequenceMonad m) => ..."
05:27:42 <quicksilver> ttfh: instead, store pairs (id,Bug) in a Map
05:27:48 <quicksilver> or other isomorphic object
05:28:28 <ttfh> quicksilver: hmm, that seems way better :-)
05:30:09 <fasta> I noticed that augustsson used let a lot in his ray tracer code. Is that just his style or is it more efficient not to group let's(which would surprise me greatly)?
05:30:24 <fasta> lets*
05:31:48 <pejo> fasta, didn't he translate the ocaml source straight off?
05:32:28 <fasta> pejo: I suppose that must be the reason then.
05:33:02 * faxathisia waves, hello
05:34:58 <quicksilver> fasta: let grouping certainly doesn't make any different. haskell floats them out if it can anyway.
05:35:06 <quicksilver> s/haskell/ghc/
05:35:38 <fasta> quicksilver: what exactly is let floating?
05:36:03 <fasta> quicksilver: is that what the let macro does in Scheme?
05:36:19 <quicksilver> moving lets out to enclosing renaming as needed obviously
05:42:45 <pejo> quicksilver, is it the simplifyer that does that?
05:42:46 <nominolo> hm, what is Data.FiniteMap?
05:43:27 <fasta> nominolo: Old for Data.Map
05:43:42 <nominolo> i see
05:44:19 <quicksilver> pejo: I don't know the names of the different bits
05:45:09 <pejo> quicksilver, the reasoning behind doing it is that it might expose other optimisation opportunities though?
05:45:25 <fasta> quicksilver: can you give a simple example of that?
05:47:14 <yrlnry> The type elaboration algorithm in ML is nominally exponential time.  Did Haskell repair this somehow, or was it considered unimportant?
05:48:07 <fasta> yrlnry: unimportant
05:48:17 <yrlnry> Makes sense.
05:49:02 <yrlnry> So the same pathological examples will blow up the Haskell algorithm also?
05:49:54 <fasta> yrlnry: If it uses the same algorithm, yes.
05:50:05 <fasta> yrlnry: otherwise there are some other examples.
05:50:39 <yrlnry> Thanks.
05:51:57 <fasta> yrlnry: do you know by heart a pathological example?
05:52:38 <yrlnry> Not offhand, but I know it has to do with  binding polymorphic functions in "let" and then using them in multiple ways in the body.
05:53:25 <quicksilver> haskell doesn't permit that
05:53:32 <quicksilver> haskell lets bind monmorphically
05:53:41 <yrlnry> Oh, really?
05:53:44 <quicksilver> yup
05:53:55 <ddarius> quicksilver: What are you talking about?
05:54:09 <quicksilver> oh, is it lambda that bind monmorphically?
05:54:13 <ddarius> There you go.
05:54:16 * quicksilver apologises
05:54:18 <yrlnry> you can't  let f x= x in (f 13, f true) ?
05:54:19 <quicksilver> :)
05:54:32 <ddarius> > let f x = x in (f 13, f True)
05:54:34 <lambdabot>  (13,True)
05:54:41 <yrlnry> Okay then.
05:56:28 <ddarius> :t (\f -> (f 13, f True)) id
05:56:29 <lambdabot>     No instance for (Num Bool)
05:56:29 <lambdabot>       arising from the literal `13' at <interactive>:1:10-11
05:56:29 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
05:57:08 <ddarius> :t ((\f -> (f 13, f True)) :: (forall a. a -> a) -> (Int,Bool)) id
05:57:10 <lambdabot> (Int, Bool)
05:58:25 <quicksilver> ddarius: but that last is a ghc extension, correct?
05:58:40 <ddarius> Well, not just GHC, but yes it's not Haskell 98.
05:58:56 * quicksilver nods
06:00:48 <yrlnry> > :t let a x = x in let b = (a, a) in let c = (b, b) in let d = (c, c) in let e = (d, d) in (e, e)
06:00:49 <lambdabot>  Parse error at "let" (column 4)
06:01:28 <quicksilver> yes, you can get exponential blowup in the size of the type error, too :)
06:01:37 <quicksilver> as in, the size of the ascii description of the error
06:01:51 <yrlnry> That wasn't supposed to be an error.
06:02:02 <quicksilver> :t let a x = x in let b = (a, a) in let c = (b, b) in let d = (c, c) in let e = (d, d) in (e, e)
06:02:04 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31. (((((t -> t, t1 -> t1), (t2 -> t2, t3 -> t3)), ((t4 -> t4, t5 -> t5), (t6
06:02:04 <lambdabot> -> t6, t7 -> t7))), (((t8 -> t8, t9 -> t9), (t10 -> t10, t11 -> t11)), ((t12 -> t12, t13 -> t13), (t14 -> t14, t15 -> t15)))), ((((t16 -> t16, t17 -> t17), (t18 -> t18, t19 -> t19)), ((t20 -> t20,
06:02:04 <lambdabot> t21 -> t21), (t22 -> t22, t23 -> t23))), (((t24 -> t24, t25 -> t25), (t26 -> t26, t27 -> t27)), ((t28 -> t28, t29 -> t29), (t30 -> t30, t31 -> t31)))))
06:02:10 <ivanm> gah!
06:02:18 <ivanm> @slap quicksilver and yrlnry
06:02:19 * lambdabot will count to five...
06:02:28 <quicksilver> no, but there are similar kinds of construct which are
06:02:35 <ivanm> is that an example of lambda-spam? :p
06:02:40 <quicksilver> and produce errors exponential in size from the source string
06:02:48 <yrlnry> What did I do wrong  in my example?
06:03:02 <yrlnry> Oh, the leading >?
06:03:08 <yrlnry> :t 13
06:03:09 <lambdabot> forall t. (Num t) => t
06:03:13 <yrlnry> Okay.
06:04:07 <ddarius> Incidentally, there is no reason to nest the lets.
06:04:28 <yrlnry> Oh, sure.
06:04:59 <yrlnry> <yrlnry> > let a x = x in let b = (a, a) in let c = (b, b) in let d = (c, c) in let e = (d, d) in (e, e)
06:04:59 <yrlnry> <lambdabot>  Add a type signature
06:05:02 <yrlnry> Ha ha!
06:05:22 <ddarius> :t let dup x = (x,x); y = dup . dup . dup . dup $ () in y
06:05:23 <lambdabot> (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))
06:12:04 <twanvl> ?type let a x = (x,x) ; b = a . a ; c = b . b in c . c $ ()
06:12:06 <lambdabot> (((((((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((
06:12:06 <lambdabot> ), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))))), (((((((), ()),
06:12:06 <lambdabot>  ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ())
06:12:06 <lambdabot> ), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))))), ((((((((), ()), ((), ())), ((
06:12:09 <lambdabot> (), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ())), (((), ()),
06:12:12 <lambdabot> [3 @more lines]
06:12:23 <Botje> argh!
06:12:27 <masak> beautiful...
06:12:31 <psykon> this is what people mean when they whine about parenthesis
06:12:46 <quicksilver> psykon: that's actually the lisp code for hello world!
06:13:04 <ivanm> lol
06:13:09 <psykon> oh, wrong channel
06:13:11 <psykon> :D
06:14:05 <ac> gnu make actually isn't all that bad. The only part I don't like is the stupid literal tab dependency
06:16:53 <faxathisia> @more
06:16:53 <lambdabot> ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))))), (((((((), ()), ((), ())), (((), ()), ((), ()
06:16:53 <lambdabot> ))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ())), (((), ()), ((), ()))), ((((
06:16:53 <lambdabot> ), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))))))
06:17:04 <matthew_-> it's really pretty in ghci
06:17:15 <matthew_-> 18 lines long
06:17:34 <faxathisia> That's not lisp.. It typechecks :p
06:17:38 <ac> what IS that nonsense?
06:18:02 <fasta> ac: it's as much a function as id.
06:18:07 <Olathe> It's an instance of ((), ....
06:18:38 <matthew_-> it's not id. it's a constructor applied to ()
06:18:39 <Olathe> On second thought, 'tis a silly place.
06:18:51 <ddarius> ac: Type checking Haskell is exponential or super-exponential.
06:19:31 <matthew_-> oh yeah, am I right in thinking that ghc 6.10 is going to use a full constraint solver in the type checker?
06:20:00 <ac> ddarius: ah I get it. I took a closer look at the definition up there
06:20:43 <ac> > dup 3
06:20:43 <lambdabot>   Not in scope: `dup'
06:22:11 <ac> > let trip x = (x,x,x); crud = trip . trip . trip . trip $ 1 in crud
06:22:12 <lambdabot>  ((((1,1,1),(1,1,1),(1,1,1)),((1,1,1),(1,1,1),(1,1,1)),((1,1,1),(1,1,1),(1,1,...
06:22:38 <quicksilver> ddarius: but fortunately, not down axes we normally move very far down
06:22:41 <mux> wli: around?
06:23:02 <quicksilver> ddarius: it's not exponential in "number of lines of source code" or "number of types defined"
06:23:08 <quicksilver> that would be bad news indeed.
06:23:11 <ac> @more
06:23:15 <mux> @let convergents as = let gen x0 x1 = drop 2 . fix (\f as -> x0:x1:zipWith3 (\a x y -> x + a * y) as (f as) (tail (f as))); numerators = gen 0 1; denominators = gen 1 0 in zipWith (%) (numerators as) (denominators as)
06:23:16 <lambdabot> <local>:8:0:     Warning: Pattern match(es) are overlapped              In th...
06:23:25 <mux> > convergents [3,7,15,1,292]
06:23:27 <lambdabot>  [3%1,22%7,333%106,355%113,103993%33102]
06:23:34 <mux> > pi - (103993/33102)
06:23:35 <lambdabot>  5.778906242426274e-10
06:23:56 <mux> > convergents (1:repeat 2)
06:24:00 <lambdabot> Terminated
06:24:12 <mux> I don't get why lambdabot fails to process infinite lists when it works in ghci here
06:25:06 <quicksilver> mux: it's time limited
06:25:14 <quicksilver> mux: you didn't produce 80 characters fast enough
06:25:19 <quicksilver> mux: so it gave up, I imagine
06:25:27 <mux> hmmm, that's possible
06:25:43 <mux> though I don't know yet why this code gets so slow so soon
06:25:49 <quicksilver> lambdabot runs until (a) 3 seconds are up in which case it writes "Terminatied"
06:26:04 <quicksilver> or (b) it produces 80 characters, in which case it prints those and stops it
06:26:15 <mux> too bad it doesn't print < 80 chars
06:26:19 * quicksilver nods
06:26:29 <quicksilver> agreed
06:26:34 <quicksilver> shouldn't be hard to change I imagine
06:28:32 <faxathisia> :t convergents
06:28:34 <lambdabot> forall a. (Integral a) => [a] -> [Ratio a]
06:30:08 <quicksilver> !
06:30:12 <faxathisia> > let f = (\x -> [(x,x,x,x)]) in f$f$f$f$f()
06:30:14 <lambdabot>  [([([([([((),(),(),())],[((),(),(),())],[((),(),(),())],[((),(),(),())])],[(...
06:30:15 <quicksilver>  ? :t can see local definitions now?
06:30:29 <quicksilver> I thought when we tried that earlier today it couldn't?
06:31:11 <quicksilver> @type convergents
06:31:13 <lambdabot> forall a. (Integral a) => [a] -> [Ratio a]
06:31:17 * quicksilver looks baffled
06:31:31 <quicksilver> ah, maybe it's only if the L. version shadows a prelude function it gets upset
06:31:33 <quicksilver> @type on
06:31:35 <lambdabot> forall t1 t2 t. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
06:31:39 <quicksilver> @type L.on
06:31:41 <lambdabot> forall t1 t2 t. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
06:31:47 * quicksilver doesn't understand
06:37:06 <sioraiocht> @src any
06:37:06 <lambdabot> any p =  or . map p
06:37:14 * quicksilver feels tempted to killfile someone on haskell-cafe for the first time ever.
06:37:24 <sioraiocht> quicksilver: ?
06:37:43 <quicksilver> not directed at you :)
06:38:01 <sioraiocht> oh well that's good, given I never post on haskell-cafe, hehe
06:38:18 * sjanssen wants to know
06:38:28 <quicksilver> sjanssen: jerzy
06:40:13 <sioraiocht> from..More on fibonacci numbres?
06:40:18 <quicksilver> yeah
06:40:52 <sioraiocht> who is Andrew Bromage and why does he drop this name?
06:41:07 <quicksilver> andrew bromage is a smart haskell hacker :)
06:41:28 <quicksilver> wrote a fair amount of the good stuff on the old wiki, for example
06:41:39 <sioraiocht> ah
06:41:53 <sioraiocht> still, x name dropping x
06:51:22 <ac> how do I make everything depend on the Makefile, using gnu make?
06:52:36 <ac> sorry for being OT
06:53:28 <dylan> it should by default
06:53:33 <dylan> I thought.
06:54:11 <ac> huh. not a big deal, as I'm not going to be changing my makefile much. I can just make a clean rule
06:54:17 <ac> er, target
06:55:07 <hpaste>  Orchid pasted "An IOError examiner" at http://hpaste.org/3766
06:56:11 <mux> @undef convergents
06:56:13 <lambdabot> Undefined.
06:56:33 <mux> @let convergents = tail . scanl (\x y -> recip x + y) 1
06:56:36 <lambdabot> Defined.
06:56:51 <mux> > take 10 $ convergents (1:repeat 2)
06:56:53 <lambdabot>  [2.0,2.5,2.4,2.4166666666666665,2.413793103448276,2.414285714285714,2.414201...
06:57:02 <mux> > take 10 $ convergents (1:repeat 2) :: [Rational]
06:57:03 <lambdabot>  Couldn't match expected type `Rational'
06:57:15 <mux> > (take 10 $ convergents (1:repeat 2)) :: [Rational]
06:57:16 <lambdabot>  Couldn't match expected type `Rational'
06:58:44 <pitecus> has anyone used the hint package?
06:59:04 <pitecus> Is is reasonably easy to evaluate haskell code with it?
06:59:26 <mux> @undef convergents
06:59:29 <lambdabot> Undefined.
06:59:58 <mux> @let convergents = tail . scanl (\x y -> recip x + y) 1 . map fromIntegral
06:59:59 <lambdabot> Defined.
07:00:04 <mux> > take 10 $ convergents (1:repeat 2) :: [Rational]
07:00:05 <lambdabot>  Couldn't match expected type `Rational'
07:00:23 <mux> @undef convergents
07:00:25 <lambdabot> Undefined.
07:00:43 <mux> @let convergents = tail . scanl (\x y -> recip x + y) 1 :: Integral a => [a] -> [Rational]
07:00:44 <lambdabot> Couldn't match expected type `Rational'
07:00:54 <mux> @let convergents = tail . scanl (\x y -> recip x + y) 1 . map fromIntegral :: Integral a => [a] -> [Rational]
07:00:57 <lambdabot> Defined.
07:01:04 <mux> > take 10 $ convergents (1:repeat 2)
07:01:06 <lambdabot>  [2%1,5%2,12%5,29%12,70%29,169%70,408%169,985%408,2378%985,5741%2378]
07:01:12 <mux> finally! that was hard :)
07:01:55 <quicksilver> ;)
07:02:17 <mux> > map (abs . (- (sqrt 2))) $ convergents (1:repeat 2)
07:02:18 <lambdabot>        add an instance declaration for (Floating (Rational -> b))
07:02:44 <mux> > map (abs . (- (sqrt 2)) . realToFrac) $ convergents (1:repeat 2)
07:02:45 <lambdabot>   add an instance declaration for (Floating (b -> c))
07:03:07 <mux> > map (abs . (subtract (sqrt 2)) . realToFrac) $ convergents (1:repeat 2)
07:03:08 <lambdabot>  [0.5857864376269049,1.0857864376269049,0.9857864376269048,1.0024531042935714...
07:03:25 <mux> damnit!
07:03:32 <mux> > map (abs . (flip subtract (sqrt 2)) . realToFrac) $ convergents (1:repeat 2)
07:03:34 <lambdabot>  [0.5857864376269049,1.0857864376269049,0.9857864376269048,1.0024531042935714...
07:04:22 <pitecus> Any idea what that's about: Setup.hs: haskell-src.cabal:15: Invalid syntax (no colon after field name)
07:04:59 <Toxaris> mux: abs(x-y) == abs(y-x) :-)
07:05:09 <mux> that's not my problem
07:05:16 <mux> the convergents function is still wrong
07:05:49 <mux> it should converge at sqrt 2 for [1,2,2,2,2...] :-)
07:06:00 <mux> and it's converging at 1 + sqrt 2
07:06:07 <mux> I've got something backwards
07:06:08 <doserj> pitecus: it means you need a newer version of Cabal
07:06:30 <pitecus> that sucks
07:06:40 <pitecus> my version is pretty new
07:16:34 * ac would like a Haskell EDSL to replace GNU make
07:16:44 * ac changes his mind about GNU make not being all that bad
07:17:43 <dcoutts_> ac: we're working on that for Cabal
07:18:09 <ac> dcoutts_: :)
07:18:37 <ac> dcoutts_: Did you see my messages about cabal-install errors?
07:18:52 <dcoutts_> ac: dist/Conftest.c?
07:18:56 <ac> dcoutts_: yeah
07:19:01 <dcoutts_> yep, we know about that one
07:19:16 <ac> dcoutts_: is there an easy solution?
07:19:45 <dcoutts_> use Cabal-1.2.1 or the latest darcs cabal HEAD or hack around it in cabal-install or mkdir dist
07:20:16 <ac> dcoutts_: ah figures. I'll try the latest cabal
07:20:48 <ac> dcoutts_: I suppose I should have grabbed the most recent version from darcs before I reported a bug, but dons told me you'd want to hear
07:21:24 <dcoutts_> ac: it's a pitty it didn't work with the cabal that we released with ghc-6.8
07:21:42 <dcoutts_> we introduced a late change in the Cabal lib and didn't test it with cabal-install
07:22:15 <ac> dcoutts_: are you saying cabal-install works just fine with 6.8.1 as long as you have the latest Cabal from darcs?
07:22:18 <salierix> Why doesn't Random have any documentation?
07:22:39 <dcoutts_> ac: yes, or with the slightly older Cabal-1.2.1 from hackage
07:24:28 <ac> are there links in hackage to darcs repositories that I haven't found?
07:26:59 <dcoutts_> ac: no, we don't have any links in hackage to darcs repos yet, there is a proposal to let people add darcs urls in their .cabal files which hackage could then report
07:27:38 <dcoutts_> but we need a proper design that caters for various issues, like not being darcs-specific, we should allow urls for other systems
07:28:01 <dcoutts_> and what about branches, or what about when a package is not at the top level within a repo etc
07:28:02 <ac> dcoutts_: Why not just the full command?
07:28:04 <dcoutts_> details details
07:28:18 <dcoutts_> ac: darcs-repo: rm -rf /
07:28:24 <dcoutts_> that's why :-)
07:28:34 <ac> good point :-P
07:29:03 <ac> no utility should actually execute it though, it's just a string for people to look at
07:29:28 <dcoutts_> well, it would be really nice to have links to the darcs repo on hackage and to do things like darcs-graph etc
07:29:38 <ac> dcoutts_: I bet gentoo has answers
07:30:02 <ac> or at least you could get some ideas from the emerge system
07:30:18 <doserj> dcoutts_: it would also be nice to have the upload date in hackage
07:31:04 <dcoutts_> doserj: that one is easy, we've got the logs
07:31:12 <dcoutts_> doserj: grab the hackage code and send a patch
07:31:21 <doserj> :)
07:31:48 <dcoutts_> doserj: darcs get --partial http://darcs.haskell.org/hackage-scripts/
07:31:51 <lambdabot> Title: Index of /hackage-scripts
07:32:04 <ac> question: how many packages are broken with 6.8.1?
07:32:13 <dcoutts_> ac: answer: most
07:32:29 <dcoutts_> ac: actually in gentoo we just use different url vars for each kind of source control system
07:32:47 <dcoutts_> eg: EDARCS_REPOSITORY="http://darcs.haskell.org/packages/Cabal"
07:32:49 <doserj> btw, what is the reason for cabal-install to put files in <package>-<version>/ghc-<version>/<package>-<version>/ghc-<version>/ ?
07:32:50 <lambdabot> Title: Index of /packages/Cabal
07:33:22 <dcoutts_> doserj: that's a bug, it should be just <package>-<version>/ghc-<version>/
07:33:25 <ac> I was a little curious about that too
07:33:45 <doserj> dcoutts_: a known bug?
07:34:54 <ac> dcoutts_: the gentoo solution seems pretty reasonable. There's the obvious improvement of splitting it up, with "repository: http://....." and "repository_system: darcs"
07:35:20 <dcoutts_> doserj: hmm, I'm not sure it's got a ticket. Please report it.
07:36:43 <ac> I can't imagine why a package would have multiple VC systems ;)
07:37:38 <dcoutts_> ac: it's not that a single package could have several, but different packages could have different ones, and it'd be nice not to have to add a new field name for each system
07:37:47 <dcoutts_> doserj: no, it's not been reported.
07:37:58 <doserj> ok
07:38:03 <dcoutts_> http://hackage.haskell.org/trac/hackage/
07:38:06 <lambdabot> Title: Hackage - Trac
07:40:58 <ac> dcoutts_: yeah, that's why I suggested splitting it in to two fields
07:42:19 <dcoutts_> ac: ok, and we also need to be able to say that a package actually lives at some location below the root of the repo
07:42:41 <dcoutts_> ac: since people will often keep a collection of related packages in the same repo
07:43:06 <dcoutts_> perhaps 3 separate fields is the right thing to do there
07:43:19 <ac> dcoutts_: couldn't you just add the path to the end of the repository_url attribute? Or do not all VC systems work like that?
07:43:34 <dcoutts_> ac: no, they don't, eg darcs
07:43:44 <dcoutts_> or indeed cvs iirc
07:44:10 <ac> dcoutts_: ah, three attributes would be the way then. To do anything interesting, you'd have to have special code for each value of repository_system
07:44:34 <quicksilver> yes
07:44:40 <quicksilver> or, special code for some values
07:44:44 <quicksilver> the ones you know about :)
07:44:53 <quicksilver> and do nothing except apologise in the other
07:45:04 <dcoutts_> right
07:45:34 <ac> and hope a zealot of some VC system left out doesn't kill you in the night
07:45:59 <dcoutts_> so hackage would tell you interesting things if you use darcs and otherwise just provide a url, perhaps not even clickable since not all svc systems have human readable content if you follow their urls
07:47:10 <dcoutts_> so what should the field names be?
07:48:30 <dcoutts_> version-control-url:  version-control-type:   version-control-subdir:   ?
07:49:15 <dcoutts_> eg,  version-control-url: http://darcs.haskell.org/gtk2hs/ version-control-type: darcs   version-control-subdir: gtk
07:49:16 <lambdabot> Title: Index of /gtk2hs
07:49:45 <dcoutts_> that gives us the full url + local path to find the gtk.cabal file
07:50:02 <ac> sounds good to me. Maybe version-control-system as opposed to "type" because I'd expect type to classify the version-control
07:50:11 <dcoutts_> ok
07:50:38 <dcoutts_> and then the other thing is, should the url point to the HEAD branch, or the branch from which this release was made?
07:50:47 <dcoutts_> or should we let people supply both?
07:51:03 <Syzygy-> So ... I want to traverse something of type Tree (data Tree = Leaf | Node [Tree]), and I want to end up printing graphviz edges for eahc of the edges in this tree. This would require me to label all nodes and leaves with something. How do I do that easily?
07:51:05 <dcoutts_> and can that be done just in a url for all the systems?
07:51:46 <dcoutts_> Syzygy-: enumerate them with a preorder traversal then use http://haskell.org/~duncan/WriteDotGraph.hs
07:51:50 <ac> Hum, I have no idea. I've only used two VCs
07:52:22 <ac> I like the idea of supplying both
07:52:24 <pitecus> I updated Cabal, now my own packages break, aaaah
07:52:37 <ac> But then you're up to 4 or 5 attibutes
07:52:38 <Syzygy-> Preorder traversal??
07:52:43 <dcoutts_> pitecus: good time to fix you package then :-)
07:52:48 <dcoutts_> you/your
07:52:50 <salierix> What's better, foldr or foldl?
07:52:58 <pitecus> Setup.hs: At least the following dependencies are missing:
07:52:58 <pitecus>     utf8-string -any, binary -any, maxent -any, gramlab-lib -any
07:53:03 <dcoutts_> salierix: depends on the context, which is why we have both.
07:53:04 <pitecus> dcoutts, all those are installed
07:53:20 <pitecus> Do I have to reinstall them just coz I updated cabal???
07:53:26 <dcoutts_> pitecus: but probably only in your --user package db. try configure --user
07:53:35 <dcoutts_> the default being --global
07:53:54 <dcoutts_> though we're considering changing the default to --user since it trips people up
07:54:00 <pitecus> dcoutts, ok
07:54:19 <ac> dcoutts_: with ghc-pkg?
07:54:32 <dcoutts_> ac: huh?
07:54:34 <pitecus> ok that worked
07:54:36 <ac> nevermind
08:02:42 <salierix> How do I convert a Char to an Int?
08:02:53 <reinierrr> salierix: fromEnum
08:03:42 <Lemmih> ?hoogle Char -> Int
08:03:43 <lambdabot> Char.digitToInt :: Char -> Int
08:03:43 <lambdabot> Char.ord :: Char -> Int
08:04:39 <nominolo> @seen dons
08:04:39 <lambdabot> dons is in #haskell-overflow, #ghc, #xmonad and #haskell. I last heard dons speak 17s ago.
08:07:20 <dons> nominolo: ?
08:09:30 <Syzygy-> Stupid question: how do I actually use Data.Tree? As in how do I write a Data.Tree.Node instantiation?
08:09:59 <viklund> Node "stuff" []
08:10:04 <Syzygy-> Ah.
08:10:42 <quicksilver> the funny think about trees
08:10:48 <quicksilver> is that, IMO, you normally need to write your own :)
08:10:59 <quicksilver> all these choices about values at leaves or values at branches
08:11:38 <quicksilver> and I'm not sure that Data.Tree brings any very exciting reusable library functions with it
08:12:01 <quicksilver> unless the clever BF functions
08:12:18 <dcoutts_> and the unfold tree functions and the pretty printing
08:12:49 <dcoutts_> and simple stuff like flattening
08:14:37 <Syzygy-> dcoutts_: Can I do a preorder traversal numbering of nodes and leaves of my tree once I have converted it to a Data.Tree.Tree () ?
08:14:46 <Syzygy-> (as in obvious, easy, precooked way?)
08:16:34 <salierix> Is there a function that will apply a a function to the elements to two lists and make a new list out of the results? Or should I just use map and zip?
08:16:49 <quicksilver> salierix: zipWith
08:16:56 <dcoutts_> Syzygy-: not an obvious easy precooked way
08:17:46 <dcoutts_> Syzygy-: but you could do it in an obvious primitive recursive way, pass the node id down and accumulate edges as you go
08:17:48 <salierix> quicksilver, excellent, thanks.
08:20:30 <dcoutts_> Syzygy-: graph (Node a ts) = [ (a,b) | Node b _ <- ts ] ++ concatMap graph ts
08:20:46 <dcoutts_> graph :: Tree t -> [(t, t)]
08:21:45 <dcoutts_> Syzygy-: combined with the function I gave you earlier you get:
08:21:46 <dcoutts_> writeDotGraph . graph :: Show a => Tree a -> String
08:22:02 <dcoutts_> erm Eq a too
08:23:32 <Toxaris> why is =<< defined but not <<?
08:24:06 <Syzygy-> dcoutts_: That part isn't really my problem. My problem is getting the node ids enumerated to begin with. (it doesn't look as if this code snippet really does that)
08:24:31 <pjd> Toxaris: probably because =<< is naturally reads like a kind of fmap
08:24:32 <dcoutts_> Syzygy-: no, I skipped that. It's not necessary if the node labels are distinct
08:25:05 <Syzygy-> dcoutts_: And that's just the thing.
08:25:11 <Syzygy-> I start out with a completely unlabeled tree.
08:25:25 <Syzygy-> And labeling only ever matters for graph output. Nothing else.
08:26:23 <pjd> s/ is//
08:26:35 <dcoutts_> Syzygy-: oh you're using a Tree ()
08:27:14 <Syzygy-> Basically, yeah.
08:27:29 <Syzygy-> (I'm really using data Tree = Leaf | Node [Tree], but it's isomorphic)
08:29:35 <dcoutts_> Syzygy-: then you need to thread a node count through it
08:29:58 <Toxaris> pjd: I'm actually using << together with <*>, wich is fmap, in parsing a simple language:
08:29:58 <Toxaris>       return X    << char 'X'
08:29:58 <Toxaris>   <|> return Var  <*> anychar
08:29:59 <Syzygy-> And that's exactly what I've been scratching my head over all the time now. :P
08:31:09 <quicksilver> Syzygy-: I wrote a zipwith for arbitrary traversables
08:31:17 <quicksilver> Syzygy-: then you could just zipWith mytree [1..]
08:32:31 <Syzygy-> quicksilver: That sounds nice. You have it somewhere I can get at it?
08:32:48 <ski> quicksilver : with what return type ?
08:32:53 <twanvl> Toxaris: I would write:  X <$ char 'X' <|> Var <$> anyChar
08:33:07 <pjd> Toxaris: <$> is fmap
08:33:38 <pjd> return foo <*> bar is foo <$> bar
08:34:19 <quicksilver> ski: the return type is the "traversable on the left"
08:34:20 <roconnor> @go 1 CAD in USD
08:34:21 <lambdabot> 1 Canadian dollar = 1.092896 U.S. dollars
08:34:26 <quicksilver> Syzygy-: just fetching it
08:34:26 <roconnor> @go 1 AUD in USD
08:34:27 <lambdabot> 1 Australian dollar = 0.9347 U.S. dollars
08:35:10 <pjd> Toxaris: and return X << char 'x' would be X <$ char 'x', i think
08:35:12 <profmakx> @go 1 EUR in USD
08:35:13 <lambdabot> 1 Euro = 1.4646 U.S. dollars
08:35:40 <pjd> (oh, twanvl already said)
08:35:59 <Toxaris> <$ sounds good, thanks. I know about <*> vs. <$>
08:36:05 <hpaste>  quicksilver pasted "zipWith Traversable" at http://hpaste.org/3768
08:36:23 <quicksilver> Syzygy-: there.
08:36:36 <quicksilver> ski: zipWithTF :: (Traversable t,Foldable f) => (a -> b -> c) -> t a -> f b -> t c
08:37:23 <ski> *nod*
08:42:04 <b_jonas> apparently haskell folks really like < and > signs. lots of operators contain them, and they're also used in the punctations -> <- =>
08:42:15 <quicksilver> yeah :)
08:42:21 <matthew_-> they're pretty
08:42:23 <quicksilver> well they're a nice way of indicating direction
08:42:36 <quicksilver> and if you use both, it indicates symettricality
08:42:44 <quicksilver> and they're a nice way of 'decorating' a symbol
08:42:46 <matthew_-> and they're about 50 different pairs of brackets in unicode.
08:42:50 <quicksilver> to indicate some kind of lift
08:43:05 <b_jonas> and you can't use ( [ { for directions, because they're not symbol chars, right?
08:43:27 <Syzygy-> quicksilver: Thanks!!
08:43:27 <quicksilver> correct
08:43:31 <quicksilver> Syzygy-: is it useful?
08:43:37 <quicksilver> Syzygy-: it struck me as a real gap in the library
08:43:50 <quicksilver> Syzygy-: I plan to put it on the wiki, I'm writing an article about foldable and traversable
08:46:02 <dcoutts_> graph :: Int -> Tree () -> (Int, [(Int, Int)])
08:46:02 <dcoutts_> graph n (Node a ts) =
08:46:02 <dcoutts_>   let (n', edges) = mapAccumR graph (n + length ts) ts
08:46:02 <dcoutts_>    in (n', [ (n,n') | (n',_) <- zip [n..] ts ] ++ concat edges)
08:46:20 <dcoutts_> Syzygy-: ^^ it typechecks, I've not tested it
08:47:19 <dcoutts_> use it like: snd . graph 0
08:49:19 <IW32> anyone knows the bulls and cows game ?
08:50:07 <basti_> apparently not
08:51:32 <hpaste>  Nafai pasted "What's wrong with my primeFactors function?" at http://hpaste.org/3769
08:52:19 <Nafai> I can't figure out what's wrong in that paste from the error messages ghc is giving me
08:52:47 <Nafai> Especially given I use the same expression it complains about elsewhere
08:53:17 <twanvl> sqrt requires that the argument is a Floating, which Integer is not
08:53:52 <IW32> do u guys know mastermind, I am trying to implement it in haskell
08:54:30 <basti_> IW32: yes i know mastermind.
08:54:45 <Nafai> twanvl: Then why doesn't it complain in isPrime?
08:54:58 <Syzygy-> quicksilver: It's useful.
08:55:14 <basti_> :t floor
08:55:16 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:55:21 <Syzygy-> dcoutts_: I haven't tried your code. I got things to do what I wanted with your previous graph code, and quicksilvers traversal.
08:55:25 <basti_> Nafai: see the type of "floor"
08:55:36 <twanvl> Nafai: could you add the error message?
08:55:39 <dons> ?users
08:55:40 <lambdabot> Maximum users seen in #haskell: 424, currently: 398 (93.9%), active: 19 (4.8%)
08:55:42 <dons> ?yow!
08:55:43 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes JUST
08:55:43 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
08:55:54 <Nafai> twanvl: Sure
08:56:27 <roconnor> > let isPrime x = (2^(x-1) == 1 && 3^(x-1) == 1) in [(a,isPrime a) | a <- [2..]]
08:56:29 <lambdabot>  [(2,False),(3,False),(4,False),(5,False),(6,False),(7,False),(8,False),(9,Fa...
08:56:57 <hpaste>  Nafai annotated "What's wrong with my primeFactors function?" with "(no title)" at http://hpaste.org/3769#a1
08:57:01 <basti_> roconnor?
08:57:29 <Nafai> Dang it, I've got a meeting
08:57:35 <Nafai> Be back in a while, I'll check the back log
08:57:37 <pejo> dons, did you blog that quickcheck stuff you were talking about btw? (Is your blog changing url?)
08:57:39 <roconnor> > let isPrime x = (2^(x-1) `mod` x == 1 && 3^(x-1) `mod` x == 1) in [(a,isPrime a) | a <- [2..]]
08:57:41 <lambdabot>  [(2,False),(3,False),(4,False),(5,True),(6,False),(7,True),(8,False),(9,Fals...
08:57:52 <IW32> i want to implement it in haskell
08:58:02 <roconnor> > let isPrime x = (x `elem` [2,3]) || (2^(x-1) `mod` x == 1 && 3^(x-1) `mod` x == 1) in [(a,isPrime a) | a <- [2..]]
08:58:04 <lambdabot>  [(2,True),(3,True),(4,False),(5,True),(6,False),(7,True),(8,False),(9,False)...
08:58:37 <IW32> can I have some assistanc
08:58:40 <IW32> e
08:59:03 <roconnor> > let isPrime x = (x `elem` [2,3]) || (2^(x-1) `mod` x == 1 && 3^(x-1) `mod` x == 1) in [(a,isPrime a) | a <- [10..]]
08:59:05 <lambdabot>  [(10,False),(11,True),(12,False),(13,True),(14,False),(15,False),(16,False),...
08:59:09 <pejo> iw32, how far have you gotten, and what is the current problem?
08:59:11 <b_jonas> IW32: do you want to implement the active or the passive player?
09:02:19 <basti_> btw, i guess prolog would be better suited to solving prolog-like problems.
09:12:01 <Pastorn> > let tits = (.) . (.)
09:12:01 <lambdabot>  Parse error at end of input
09:12:07 <Pastorn> whut?
09:12:21 <Pastorn> > let tits = ((.) . (.))
09:12:21 <lambdabot>  Parse error at end of input
09:12:37 <Lemmih> Pastorn: let ... in ...
09:12:39 <balodja> "let ... in ..." or "@let"
09:12:47 <Pastorn> @let tits = ((.) . (.))
09:12:49 <lambdabot> Defined.
09:12:54 <Pastorn> awsum :D
09:12:57 <b_jonas> :t tits
09:12:59 <lambdabot> Not in scope: `tits'
09:13:05 <b_jonas> @type tits
09:13:06 <lambdabot> Not in scope: `tits'
09:13:16 <b_jonas> > tits
09:13:17 <lambdabot>  Add a type signature
09:13:34 <visof> can i find tutorial videos for learning haskell like SICP videos?
09:14:55 <salierix> There are the haskell video lectures from Germany.
09:15:09 <salierix> It's in english though.
09:15:34 <visof> link?
09:15:46 <newsham> ?seen pseudonym
09:15:46 <lambdabot> I saw pseudonym leaving #ghc, #haskell-blah and #haskell 10h 19m 27s ago, and .
09:15:55 <salierix> http://www.haskell.org/haskellwiki/Video_presentations
09:15:57 <lambdabot> Title: Video presentations - HaskellWiki
09:16:17 <salierix> It's the one called "Lecture Functional Programming"
09:16:23 <newsham> what was the mcilroy/pike/sqweak discussion about?  the mcilroy paper on power series in haskell?
09:17:15 <salierix> You want to download the VXX videos not the UXX ones.
09:17:44 <ski> > let foo = (^ 2) `L.tits` (*) in 3 `foo` 4  -- b_jonas
09:17:45 <lambdabot>  144
09:19:13 <titusg> why would ghci ignore the options in my lhs file?
09:19:39 <titusg> I have %options ghci -fglasgow-exts at the top of the file but it's ignored
09:20:56 <titusg> Or I suppose it is because I get errors re phantom types saying '-fglasgow-exts permits this'
09:23:16 <Cale> hmm
09:23:40 * Cale wonders who said his name
09:23:49 <Cale> I should set a longer scrollback ;)
09:24:13 <Lycurgus> "Logs: http://tunes.org/~nef/logs/haskell/"
09:24:14 <lambdabot> Title: Index of /~nef/logs/haskell
09:24:32 <Cale> I'll just grep my huge log file on disk
09:26:41 <Cale> aha
09:27:07 <Cale> quicksilver: It's here http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
09:27:10 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
09:28:06 <Cale> Hehe, my log file for #haskell is nearly 150 MB
09:29:08 <Cale> hmm, and this doesn't even go back all the way. I must have cleared it out at some point
09:29:53 <titusg> do you guys use literate scripts? Anyone know What I need to do to get ghci to recognise the options?
09:29:59 <quicksilver> Cale: thank you
09:30:09 <quicksilver> Cale: google didn't find it. bad google.
09:30:32 <Cale> Oh, titusg: {-# OPTIONS_GHC -fglasgow-exts #-}
09:30:56 <titusg> Cale, isn't that when non-literate?
09:31:12 <Cale> Yeah, but it should still work in literate scripts.
09:31:28 <Cale> Put it inside the first code block
09:31:33 <byorgey> titusg: the %options ghci, IIRC, only applies to code that is dynamically evaluated using \eval or \perform.
09:31:49 <Cale> quicksilver: that would be because of my robots.txt
09:32:06 <quicksilver> Cale: Ah. But if google can't see it, it doens't exist!
09:32:17 <quicksilver> Cale: maybe it could bear being on haskellwiki too?
09:32:25 <quicksilver> or at least *linked* form haskellwiki
09:32:30 <titusg> Cale, right you are. thx
09:33:43 <Cale> Sure. :)
09:33:56 <Cale> It ought to be linked from there
09:34:14 <Cale> titusg: no problem
09:35:15 <Cale> http://haskell.org/haskellwiki/Blog_articles/Monads -- in fact is is linked from here
09:35:16 <lambdabot> Title: Blog articles/Monads - HaskellWiki
09:35:51 <quicksilver> Cale: yeah, you're right
09:36:06 <quicksilver> Cale: rather strasngel, the haskell wiki doesn't have a page 'on' transformers than I can see
09:47:39 <boyscared> @type .
09:47:40 <lambdabot> parse error on input `.'
09:47:57 <twanvl> ?type (.)
09:47:58 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:49:01 <quicksilver> @type (Prelude..)
09:49:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:49:06 <quicksilver> ^^ lovely syntax!
09:49:34 <fasta> quicksilver: you can tell ghc to never show them, except in types where it's relevant.
09:50:11 <njbartlett_> So is anybody working on a Mac OS distribution for GHC 6.8.1?
09:50:29 <fasta> njbartlett_: I think that is a FAQ already :D
09:50:52 <fasta> njbartlett_: you should subscribe to ghc-users
09:50:59 <fasta> (or just read it online)
09:51:06 <quicksilver> fasta: no, I meant the ..
09:51:11 <quicksilver> njbartlett_: it has already been released
09:51:15 <fasta> quicksilver: I saw what you mean
09:51:17 <quicksilver> njbartlett_: (for tiger)
09:51:19 <fasta> quicksilver: meant
09:51:30 <quicksilver> ah, I thought you thought I meant the foralls :)
09:51:32 <fasta> quicksilver: You mean that the *Prelude* version shouldn't show  it
09:51:41 <fasta> quicksilver: right?
09:51:52 <quicksilver> I just meant that "Prelude.." is a horrible way to have to refer to a symbol
09:52:32 <fasta> quicksilver: oh, well, can't have everything, I guess.
09:52:41 <fasta> quicksilver: unless you have a better idea..
09:53:10 <quicksilver> I think using . as a hierarchy separator was not the best plan.
09:53:18 <quicksilver> But it's done now. And it doesn't matter that much.
09:53:42 <fasta> quicksilver: What would have been a better separator?
09:53:45 <fasta> quicksilver: space?
09:54:11 <quicksilver> perhaps we should have quoted the whole thing
09:54:19 <quicksilver> (not in import decls, but when used in code)
09:54:35 <quicksilver> or perhaps ;
09:54:41 <quicksilver> at least that's not used very often
09:54:44 <fasta> All the import Foo;import Bar is also rather annoying.
09:54:49 <fasta> Just import <indent>
09:54:51 <fasta>    Foo
09:54:53 <fasta>       Bar
09:54:59 <quicksilver> yeah, that would be nice
09:55:05 <fasta> Er, well, with the same amount of indentation.
09:55:18 <fasta> That's how Scheme does it.
09:55:27 <fasta> Or rather one of the Scheme implementations.
09:55:31 <quicksilver> I didn't htink scheme had significant indentation?
09:55:38 <fasta> There are language purists here.
09:55:52 <Cale> I like | as a module path separator.
09:55:53 <njbartlett_> Ah... <sigh>, MacPorts :-(
09:55:54 <fasta> quicksilver: no, it doesn't, but with ParEdit it's basically the same.
09:56:05 * quicksilver nods
09:56:17 <quicksilver> Cale: yeah, that would work
09:56:42 <Cale> Of course, then we'd have Prelude|||
09:56:48 <quicksilver> :)
09:57:01 <quicksilver> I like the idea of char which is forbidden from occuring in operators
09:57:07 <quicksilver> so Prelude;||
09:57:09 <quicksilver> looks ok to me
09:57:17 <b_jonas> is there a collector monad that has a special verb to collect a value and a run verb to run the monad returning the list of the collected values?
09:57:18 <Cale> hmm...
09:57:25 <fasta> I don't think Prelude.. is _that_ badd.
09:57:28 <fasta> bad*
09:57:31 <Cale> You'd have to be careful with the translation of layout though :)
09:57:34 <byorgey> b_jonas: Writer?
09:57:40 <twanvl> do { return Prelude;x }
09:57:48 <fasta> byorgey: yes, Writer.
09:57:52 <quicksilver> well we'd apply the "space hack" to ;
09:57:56 <quicksilver> just like we have to .
09:57:58 <Cale> I really don't like . as a module path separator simply because it's confusing as hell in composition chains.
09:58:08 <quicksilver> I think people use "." a *lot* more than ;
09:58:15 <quicksilver> and when I do use ; I'm likely to put spaces around it
09:58:25 <fasta> quicksilver: it's about the combination of the two.
09:58:30 <quicksilver> whereas it annoys me to put spaces around .
09:58:32 <twanvl> what about `
09:58:33 <fasta> quicksilver: I rarely do Prelude..
09:58:39 <quicksilver> yeah, that is true :)
09:58:53 <quicksilver> but if we had a "proper" . which was fmap
09:58:58 <quicksilver> then sometimes we'd need to
09:59:04 <twanvl> Prelude`.
09:59:04 <basti_> we have all the unicode codespace...
09:59:17 <basti_> how about ?
09:59:18 <b_jonas> byorgey: dunno, the docs don't tell what taht does
09:59:20 <Cale> ` is what Mathematica uses
09:59:34 <quicksilver> is ` legal currently for operators?
09:59:43 <Syzygy-> Cale: And it's horribly uncomfortable on every non-english keyboard...
09:59:58 <quicksilver> :: would work, as well
10:00:00 <byorgey> @src Writer
10:00:01 <lambdabot> Source not found. You speak an infinite deal of nothing
10:00:07 <Cale> quicksilver: well, it's what creates infix operators
10:00:09 <twanvl> > let (*`) = 1
10:00:09 <lambdabot>  Parse error at "`)" (column 7)
10:00:13 <quicksilver> Cale: ah, yes. Hmm.
10:00:20 <basti_> | maybe
10:00:26 <quicksilver> that was cale's suggestion
10:00:29 <basti_> oh, you discussed that already
10:00:29 * Syzygy- had a revelation during his Sydney visit - when using an english keyboard, all of a sudden it became clear both why people think ` is a good programming character, and why people'd write things like "don`t"
10:00:30 <Cale> I think | is a good one
10:00:31 <quicksilver> my favourite is still ;
10:00:38 <roconnor> I though we were going replace the . with `fmap` :)
10:00:45 <basti_> or #
10:00:58 <twanvl> import Control|Monad|List looks a bit strange
10:00:59 * byorgey is partial to $$*^@-- as a module separator
10:01:11 <Syzygy-> byorgey: o.O
10:01:17 <basti_> maybe we use some ascii art
10:01:18 <quicksilver> import Control;Monad;List
10:01:20 <Philippa_> not !"@$?
10:01:21 <basti_> --/--<@
10:01:28 <Syzygy-> import Control$$*^@--Monad$$*^@--List
10:01:28 <quicksilver> import Control::Monad::List
10:01:34 <byorgey> Philippa_: that one's nice too.
10:01:38 <twanvl> both of these look too much like importing three modules
10:01:43 <b_jonas> isn't that -'-,-<@
10:01:53 <Cale> Syzygy-: It's right up in the corner of the keyboard. It's a little uncomfortably far for an apostrophe, but not as a symbol character.
10:01:54 <quicksilver> twanvl: :: looks fine to people used to C++ or perl, I guess :)
10:02:03 <basti_> \
10:02:07 <twanvl> yes, but it is horrible for Haskell
10:02:27 <basti_> or "?"
10:02:29 <pejo> Syzygy, where is the ` located?
10:02:44 <Syzygy-> Cale: My point exactly. This holds true for english keyboards. Almost all other european characters have it as a diacritic - producing it is a process of pressing first the ['`]-key, and then space to get the input mechanism to stop waiting for a vowel.
10:03:13 <byorgey> b_jonas: I'm pretty sure Writer is what you're looking for.  There's a function 'tell' that collects a value, and functions like runWriter/execWriter to run a computation in the Writer monad and extract stuff at the end.
10:03:32 <Syzygy-> And until I had worked extensively with english keyboards, I couldn't imagine how anyone could be so stupid as to actually seriously consider using that symbol for anything...
10:04:26 <_andre> hello
10:04:32 <basti_> people tend to use "nodeadkeys" though, which alleviates the situation
10:04:34 <Cale> hello
10:04:37 <basti_> that is, people using the right OS
10:04:37 <basti_> ;)
10:04:42 <_andre> does anyone know about the 'ThatAnnoyingIOType' article from the wiki?
10:04:43 <basti_> hi _andre
10:04:49 <basti_> sure
10:04:55 <Cale> Yeah, I think I remember that
10:04:57 <_andre> found a reference to it in the mailing list archives but it gives me a 404
10:04:57 <Syzygy-> basti_: Only I write several different languages on one single keyboard. I don't have  mapped normally, so nodeadkeys kills my normal usage pattern.
10:05:05 <Cale> _andre: yes, it was on the old wiki
10:05:15 <basti_> Syzygy-: thats sad, then
10:05:17 <_andre> does it still exist?
10:05:21 <Cale> _andre: I'm not sure that's been archived anywhere, you could try archive.org
10:05:25 <_andre> the article, i mean
10:05:27 <_andre> oh, ok
10:05:30 <_andre> i'll have a look
10:05:33 <_andre> ty :)
10:05:48 <byorgey> _andre: are you looking for that specific article, or are you looking for info on the IO monad in general?
10:05:51 <Syzygy-> basti_: I also don't have  and  mapped without deadkeys - and these are actually used in my main language...
10:05:53 <basti_> http://haskell.org/wikisnapshot/ThatAnnoyingIoType.html
10:05:54 <lambdabot> Title: ThatAnnoyingIoType
10:05:57 <basti_> there it is
10:06:01 <Cale> aha!
10:06:20 <basti_> Syzygy-: should i pity you now or something? ^^
10:06:38 <_andre> byorgey: info on the IO monad in general
10:06:40 <basti_> i admit, its a bit hard to type french without dead keys
10:06:45 <_andre> actually info on monads in general
10:06:54 <basti_> monads are scripts.
10:06:54 <Syzygy-> basti_: I'm not fishing for sympathy. I'm describing a not extremely unusual usecase in which many syntax choices that are commonly done becoming exceedingly uncomfortable to use.
10:06:58 <_andre> like every n00b i guess :p
10:07:23 <b_jonas> byorgey: thanks
10:07:25 <basti_> Syzygy-: i see your point, but i got used to bear with that...
10:07:32 <Syzygy-> So pitying me - not so much. Avoiding ' and ^ and ~ things would be nicer.
10:07:32 <_andre> byorgey: thatnks for the link! scripts?
10:07:40 <Syzygy-> Sorry. that should have been `
10:08:22 <byorgey> _andre: well, in that case there are other articles on the current wiki too: e.g. http://haskell.org/haskellwiki/Introduction_to_IO and http://haskell.org/haskellwiki/IO_inside
10:08:23 <lambdabot> Title: Introduction to IO - HaskellWiki
10:08:27 <basti_> _andre: usually, you can understand a monadic value (like IO Int or ST Int) as a "script" calculating a value (an int in this case)
10:08:36 <Syzygy-> basti_: Almost everyone who works a lot with programming outside the anglophonic world will have learnt to cope. Including me. That's not quite the point I'm making.
10:08:38 <Arnar> hey guys.. I have somewhat of a generic problem that I'm thinking what is the best way to solve..
10:09:08 <basti_> Syzygy-: i guess its impossible to make a good choice for a non-letter character present on any keyboard...
10:09:13 <byorgey> Arnar: ok, shoot.
10:09:15 <Arnar> basically I have a non-deterministic transition system, implemented by a function with the type  trans :: Config -> [Config]
10:09:34 <Arnar> trans taking "one step" in the transition system, yielding all possibilities
10:09:39 <Arnar> now, Config is a showable type..
10:10:24 <Arnar> what I'd like is a program that executes trans recursively until it hits a "terminal" configuration (which closes each branch) - and along they way outputs the dot source to draw the execution tree :)
10:10:45 <basti_> thats hard.
10:10:47 <basti_> ^^
10:10:55 <EvilTerran> dot source?
10:11:04 <Syzygy-> EvilTerran: graphviz
10:11:13 <Arnar> EvilTerran: dot is this program (part of the graphviz package) that draws directed graphs
10:11:15 <Syzygy-> Arnar: You'll need more information saved than just all possible steps to go to by that.
10:11:44 <Arnar> Syzygy-: what information?
10:11:47 <Syzygy-> Arnar: You could, though, build yourself a Tree and then use all the helpful stuff I got from people today in here to generate the source.
10:11:50 <Arnar> basically I have one initial Config
10:11:57 <Syzygy-> Arnar: HOW to go from one config to the next.
10:11:58 <basti_> it depends on how you implement that
10:11:59 <Arnar> trans returns what configs are it's children
10:12:07 <Arnar> Syzygy-: that's what trans does
10:12:10 <Syzygy-> Arnar: Or do you want to continue until no Config anywhere updates?
10:12:25 <Arnar> Syzygy-: there is a predicate on configs "isFinal"
10:12:33 <Arnar> Syzygy-: execution stops when such a configuration is hit..
10:12:36 <byorgey> yeah, use unfoldTree from Data.Tree
10:12:58 <Syzygy-> Arnar: Build a tree, of type Tree Config. Then use http://haskell.org/~duncan/WriteDotGraph.hs to generate a dot file.
10:13:10 <Arnar> Syzygy-: brilliant..
10:13:11 <Arnar> thanks
10:13:37 <hpaste>  Syzygy- pasted "Tree to graph" at http://hpaste.org/3770
10:13:41 <Syzygy-> You'll also need that one.
10:14:13 <dcoutts> and it assumes your tree node labels are unique
10:14:15 <Arnar> what is T in that paste?
10:14:23 <Arnar> dcoutts: oh, mine may not be unique
10:14:24 <dcoutts> Data.Tree
10:14:52 <dcoutts> Arnar: then you'll need a different function to convert your Tree to a list of edges
10:15:13 <Arnar> dcoutts: ok, makes sense
10:15:32 <Syzygy-> Actually.
10:15:56 <Syzygy-> The traversable zipWith lets you uniquify all the edges.
10:16:15 <Syzygy-> http://hpaste.org/3768
10:16:30 * Nafai is back, trying to figure out his Haskell code
10:16:38 <Syzygy-> Just do > zipZF myTree [1..]
10:16:39 <dcoutts> yep, though then you'll also need to modify the writeDotGraph function to take separate edge keys and labels
10:16:42 <Arnar> thanks..
10:16:48 <Syzygy-> dcoutts: Point.
10:16:54 <Arnar> of course..
10:16:58 <Arnar> on secound thought though..
10:17:03 <Syzygy-> It is, however, a decent base to build on. :)
10:17:07 <dcoutts> since it currently assumes (Show node, Eq node)
10:17:08 <Arnar> maybe I'll draw identical nodes as one node..
10:17:22 <Syzygy-> Arnar: In that case you'll be happy as is.
10:17:22 <Arnar> makes more sense in my case actually
10:17:28 <cognominal_> is there emacs bindings for the ghci debugger functionnalities?
10:17:30 <byorgey> Nafai: got questions?
10:17:31 <Arnar> excellent.
10:17:33 <Arnar> thankgs guys
10:17:49 <dcoutts> Arnar, Syzygy-: or you could make a node data type that shows the label and Eq's the key
10:18:21 <dcoutts> data GNode = GNode String Int  for example
10:18:23 <Nafai> byorgey: Just trying to get this working:
10:18:28 <Nafai> byorgey: Just trying to get this working: http://hpaste.org/3769
10:19:13 <byorgey> Nafai: you need to add a 'fromIntegral' call on n before you call sqrt
10:20:29 * Nafai tries
10:24:09 <byorgey> Nafai: that will fix your type errors but I don't think isPrime is correct.  For example, isPrime 2 == False.
10:24:39 <Nafai> Yeah, looking at that now
10:25:44 <byorgey> also, 1 is usually considered not to be prime, but that's just a minor issue.
10:26:01 <Nafai> True
10:26:24 <Nafai> I think I have it fixed now
10:27:12 <hpaste>  Nafai annotated "What's wrong with my primeFactors function?" with "Working version" at http://hpaste.org/3769#a2
10:27:18 <Nafai> I think that's it
10:27:34 <Nafai> Any comments?
10:28:00 <byorgey> yup, that looks right to me
10:28:58 <Nafai> Algorithm aside, is there a more idiomatic Haskell way of doing this?
10:29:07 <byorgey> there's probably a more combinator-ish (i.e. less explicitly recursive-ish) way of writing _isPrime
10:29:46 <byorgey> i.e. making a list of possible divisors and asking whether any of them divide n, rather than explicitly recursing and incrementing a parameter to check each divisor
10:30:21 <Nafai> I had an original iterative version in Python that I was trying to translate and this seemed somewhat natural
10:31:18 <Nafai> I'm not quite picturing what you said
10:31:33 <byorgey> just a minute, I'll annotate it
10:31:48 <Nafai> Thanks!
10:31:56 <Nafai> New to Haskell and all...
10:32:14 <slava> hey Nafai :)
10:32:38 <Nafai> Hey slava
10:33:26 <hpaste>  byorgey annotated "What's wrong with my primeFactors function?" with "using list combinators instead of explicit recursion" at http://hpaste.org/3769#a3
10:34:03 <byorgey> Nafai: no shame in that =)
10:34:25 <slava> Nafai: how's life in austin?
10:35:21 <byorgey> Nafai: does that make sense?  Note aside from being shorter, it also has the benefit that there's less room for fiddly edge-case errors like putting x >= y instead of x > y
10:38:12 * Nafai looks
10:38:25 <Nafai> slava: Things are good, work is boring...I really shouldn't be writing Haskell code at work :(
10:38:44 <dons> why?
10:38:48 <dons> i do! :)
10:38:51 <slava> heh
10:39:04 <Nafai> dons: Lucky :)
10:39:06 <newsham> hey dons, what was the discussion about assange?
10:40:23 <Nafai> byorgey: Yeah, that makes sense, really clean too
10:41:28 <mtp> hi everyone
10:42:41 <Nafai> I guess I'll use Project Euler as an excuse to learn Haskell
10:43:02 <mtp> I'm writing a small parser, using parsec, for a MIPS-like assembly dialect. I've got data constructors for registers and the like, but I'm trying to write Show statements for my LoopLabel type, which is Maybe String
10:43:21 <slava> assemblers are fun
10:43:53 <mtp> slava: it's not actually an assembler; i have to simulate Tomasulo's Algorithm.
10:44:06 <slava> sounds very academic :)
10:44:08 <mtp> yeah :)
10:45:28 <liyang> mtp: you could just deriving (Show) that.
10:45:55 <bos> mtp: Maybe and String are already instances of Show
10:46:14 <mtp> liyang: the problem is I want to have it be "loop:" if it's Just String, but don't want to parse it like that if I don't have to
10:46:16 <bos> that's why this works:
10:46:19 <bos> > Just "foo"
10:46:20 <lambdabot>  Just "foo"
10:46:28 * liyang 's ears perks up on hearing MIPS assembly. But only because he has to teach it.
10:46:40 <bos> mtp: use a newtype for that
10:46:52 <liyang> oh i c. What bos said.
10:47:00 <bos> mtp: newtype LoopLabel = LoopLabel (Maybe String)
10:47:10 <mtp> ah, thanks :)
10:47:11 <bos> you can then derive a Show instance for that type
10:47:25 <twanvl> you should maybe use a pretty printing library instead
10:47:26 <liyang> You can use the deriving clause to get all the instances for Maybe String back, automagically.
10:47:27 <slava> liyang: ARM is the best :)
10:47:37 <liyang> slava: the choice wasn't mine.
10:47:40 <liyang> :3
10:48:56 <liyang> slava: and in fact, students do ask why they're not being taught ARM. Putting aside the fact that all assembly languages are the same at the end of the day. I just point to the PSP and that seems to shut them up.
10:49:05 <slava> psp is mips?
10:49:11 <liyang> Apparently so.
10:49:12 <slava> arm is interesting because it has some unusual features
10:50:15 <liyang> Yes but we're using Hennessey and Patterson (or some other ordering of those two names), which seems a reasonable book. We weren't able to find a reasonable book for ARM or anything else.
10:50:44 <slava> oh well
10:50:49 <slava> i learned ARM assembly from the specs :)
10:51:16 <mtp> Hennesy and Patterson is the book we're using :)
10:51:18 <bos> mips is also more open than arm, which is helpful in a teaching environment.
10:52:07 <liyang> slava: I'd love to suggest to the module convener that we just hand the students a copy of the MIPS specs too (as I did for various other archs back in the day), but I fear there might be a student uprising.
10:52:34 <liyang> And frankly, the numbers don't work out in our favour.
10:55:44 <victor_rx1950> hi, somebody building/porting 6.8.1 under freebsd 7 ?
10:56:05 <victor_rx1950> ghc*
10:56:10 <ChrisD> Intel MacOSX [leopard] users around?
11:00:03 <MyCatSchemes> slava: I've never tried doing that with anything bigger than a Z80. :)
11:00:05 <njbartlett_> ChrisD: Yup
11:00:59 <ChrisD> njbartlett: I'm trying to install Chilli's 6.8.1 package, and there's a problem locating /opt/local/lib/libgmp.3.dylib.
11:01:31 <njbartlett_> Oh, you found a 6.8.1 package for Mac. Funny I was just looking for exactly that myself
11:01:36 <ChrisD> njbartlett: It's a clean install of Leopard onto an intel Macbook.  Can you provide guidance?
11:01:49 <pejo> ChrisD, is /opt/local/lib/libgmp.3.dylib there?
11:01:56 <fritte> Hey gents, newbie here. I'd like to split a list with one element into many elements (for example [14356] into [1,4,3,5,6]) and I was hoping that someone would be kind enouth to help me out.
11:02:20 <ChrisD> njbartlett: I found it at  http://www.cse.unsw.edu.au/~chak/haskell/ghc-6.8.1-i386-apple-darwin.tar.bz2
11:02:22 <lambdabot> http://tinyurl.com/294bhe
11:02:29 <njbartlett_> ChrisD: I doubt I can provide guidance, I'm even more in the dark. I can try it on my machine and tell you what happens, though
11:03:00 <ChrisD> njbartlett: /opt doesn't exist -- my experience says thats a default location appropriate for SUN and SGI machines
11:03:24 <njbartlett_> ChrisD: Ah, do you have MacPorts? That creates an /opt
11:03:30 <dylan> /opt/local is a macports thing
11:04:05 <ChrisD> I guess this is a macports-based install then.
11:05:23 <araujo> hello
11:07:01 <joed> ChrisD: I think it relies on readline from MacPorts
11:08:31 <opqdonut> how did strict fields work again?
11:08:57 <ChrisD> all: thanks very much; I'll need to go off and install macports first.
11:09:22 <byorgey> hey araujo
11:09:52 <byorgey> opqdonut: you mean strict fields in an algebraic data type?
11:09:57 <opqdonut> yep
11:10:22 <byorgey> opqdonut: just prepend ! (and enable the relevant extensions... LANGUAGE BangPatterns, I think)
11:10:32 <opqdonut> ah
11:11:03 <opqdonut> {-#LANGUAGE BangPatterns -} ?
11:12:21 <byorgey> yup, I think so
11:12:33 <byorgey> uh, but with #-} instead of -}
11:13:21 <dons> ;
11:14:24 <shapr> @yow !
11:14:24 <opqdonut> yeps
11:14:25 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
11:14:30 <shapr> mmm, goldie hawn
11:14:46 <jonafan> she's like 100 years old
11:15:27 <shapr> jonafan: Hey, older chix can be hot.
11:15:33 <opqdonut> eh
11:15:40 <opqdonut> should bang patterns work with named fields?
11:17:12 <byorgey> opqdonut: sure
11:17:28 <byorgey> opqdonut: the ! should go right before the type
11:17:40 <opqdonut> yeah so i guessed
11:17:48 <opqdonut> parse error on input `::!'
11:17:57 <opqdonut> ah, whitespace fixed it
11:18:06 <byorgey> yeah, that's what I was going to suggest
11:18:19 <opqdonut> :)
11:18:35 <opqdonut> some of the extensions seem quite fragile syntax-wise
11:18:55 <hpaste>  sclv pasted "Widefinder using SMP parallelism" at http://hpaste.org/3772
11:21:10 <b_jonas> oh damn
11:22:54 <byorgey> b_jonas: what's the matter?
11:23:10 <b_jonas> I found out that J accepts numbers starting with a decimal dot
11:23:14 <opqdonut> ah, 20-fold performance increase
11:23:29 <b_jonas> that complicates the number parser a bit
11:23:38 <byorgey> b_jonas: ah, indeed =P
11:23:48 <opqdonut> anyone know why making the fields of a recursive datatype strict improved performance
11:23:56 <scodil> !ping dcoutts, or anyone who's built gtk2hs recently
11:23:59 <opqdonut> when the structure is used only inside the strict state monad
11:24:03 <b_jonas> especially because there are other tokens starting with a dot
11:24:42 <b_jonas> > read ".1" :: Double
11:24:44 <lambdabot>  Exception: Prelude.read: no parse
11:24:48 <byorgey> opqdonut: hmm... perhaps because even the 'strict' state monad only evaluates the state to WHNF?
11:24:49 <b_jonas> > read "1." :: Double
11:24:51 <lambdabot>  Exception: Prelude.read: no parse
11:24:54 <b_jonas> > read "1.1" :: Double
11:24:56 <lambdabot>  1.1
11:25:15 <luqui> I've got a C function like void foo(char** ptr) { *ptr = "bar"; } ; How do I call this function using FFI?
11:25:22 <byorgey> opqdonut: I'm not actually sure, that's just a guess
11:25:26 <luqui> presumably returning IO String
11:25:39 * ski learned numbers starting with dot, when starting programming
11:25:41 <b_jonas> so I need to prepend and append a '0' before reading
11:26:16 <scodil> luqui: what is that C function supposed to do?
11:26:35 <luqui> scodil, it does some actions and then returns a string using that convention
11:27:02 <luqui> (takes some other parameters too, but it's that convention that I'm struggling with)
11:27:03 <b_jonas> and obviously a lone dot is nut a number so I need to check for that
11:27:19 <opqdonut> byorgey: WHNF?
11:27:24 <opqdonut> (sorry, was afk for a while)
11:27:25 <scodil> luqui: i think you'd have to allocate memory for the string in haskell, then pass that pointer and fill it in C
11:27:26 <ski> > (read "1.2E10",read "01.2E100") :: (Double,Double)  -- b_jonas, watch out
11:27:27 <lambdabot>  (1.2e10,1.2e100)
11:27:39 <byorgey> opqdonut: sorry, Weak Head Normal Form
11:27:56 <byorgey> opqdonut: i.e. evaluated just enough to know what the top-level constructor is
11:28:03 <opqdonut> yeah, that might be
11:28:09 <b_jonas> ski: sure, I append it to the right part
11:28:10 <opqdonut> well, now it's strict and life smiles
11:28:17 <byorgey> yup, sounds good =)
11:28:18 <luqui> scodil, it seems like a want a Ptr (Ptr Char), which is like pointerTo nullPtr, but there is no pointerTo afaict
11:28:31 <b_jonas> I have several functions calling each other:
11:28:56 <b_jonas> one removes the special cases which start with a digit/underscore/dot but aren't actually a number,
11:29:02 <luqui> scodil, or are you saying I need to write a little C wrapper around it?
11:29:05 <scodil> luqui: if your C function is 'returning' a string, you should just pass in a char* and fill the contents using strcpy()
11:29:23 <scodil> i assumed what you wrote was psuedo-C, because it doesn't do what i think you think it does
11:29:27 <b_jonas> one parses a complex number by combining one or two reals parsed with the next one
11:29:45 <b_jonas> one that parses a real number by reading the string parsed by the next function,
11:29:56 <luqui> scodil, no, that's correct: it assigns the pointer I give it to some memory it owns...
11:29:57 <luqui> very strange
11:30:06 <luqui> it wants me to copy the data out as soon as i get it
11:30:15 <b_jonas> one that parses a real number to a string by calling the next function, and if an 'e' follows, calling the second next function,
11:30:40 <b_jonas> one that parses a real number without an 'e' by calling the next function once or twice,
11:30:48 <b_jonas> and one that parses an integer
11:30:53 <b_jonas> and I forgot the sign handling
11:30:59 <b_jonas> which is one more function
11:32:07 <scodil> luqui: Foreign.Marshal has functions to convert C strings into Haskell Strings, so you probably could write a Haskell wrapper that reads from ptr and converts it into a Haskell string
11:32:25 <luqui> I don't know how to give it the ptr in the first place though
11:32:34 <luqui> How do I make a pointer to a null pointer?
11:33:10 <scodil> luqui: so this function your calling, it insists on returning a pointer by reference, rather than by value?
11:33:19 <scodil> because returning by value seems so much easier
11:33:43 <luqui> scodil, yes it does
11:33:44 <scodil> void* foo() { return ptr; }    rather than   void foo(void** p) { *p = ptr; }
11:33:46 <luqui> it's in a library
11:33:57 <luqui> (and it doesn't actually return void, it returns some other information in the return value)
11:34:01 <scodil> ok then in your haskell wrapper allocate a single pointer for it to write to
11:34:06 <scodil> using alloca
11:34:13 <luqui> alloca eh?
11:34:15 <scodil> i think
11:34:18 <scodil> not sure if that's safe
11:34:32 <scodil> with respect to the GC
11:34:33 <scodil> i think it is
11:34:45 <luqui> that's what I was looking for, thanks
11:35:54 <b_jonas> and I'll have to add infinities and nans as well
11:39:48 <mgsloan> anyone know of a decent matrix lib, particularly one with graphics in mind
11:40:04 <nominolo> gsl?
11:40:20 <mgsloan> there's a haskell wrapper for it?
11:40:24 <nominolo> but graphics is 4x4 at most, isn't it?
11:40:26 <nominolo> yep
11:40:33 <nominolo> fairly complete one actually
11:40:40 <nominolo> @go GSL haskell
11:40:45 <lambdabot> http://dis.um.es/~alberto/hmatrix/matrix.html
11:40:45 <lambdabot> Title: Matrix Computations in Haskell based on the GSL
11:40:57 <mgsloan> well, actually I also need a 5x5
11:41:19 <mgsloan> for some physics calcs, and this is just 2d physics, hehe
11:41:28 * byorgey compiles GHC 6.8.1! =D
11:41:33 <mgsloan> thanks
11:42:15 <nominolo> i haven't used it.  hope it's useful to you
11:42:32 <dons> byorgey: ? on ppc/10.5?
11:42:50 <byorgey> dons: uh, no
11:44:03 <byorgey> dons: there's probably some sort of debian package that's already built that I could try to wrangle into place but this seemed like more fun =)
11:47:00 <opqdonut> what's the best way to locate stack overflows?
11:47:01 <RayNbow> hmm, is it just me or is research.microsoft.com down?
11:47:30 <chr1s> RayNbow: no, it's not just you.
11:47:41 <chr1s> it's been down for a couple of hours now.
11:48:23 <bos> opqdonut: profiling often helps
11:48:37 <opqdonut> yeah well i'm none the wiser
11:48:43 <opqdonut> this is only with large inputs and so on
11:48:49 <byorgey> opqdonut: step 1: locate computer. step 2: open it up and locate the memory chip(s). step 3: ...  ;)
11:48:51 <opqdonut> nothing trivially stupid
11:49:04 <opqdonut> byorgey: ;)
11:49:28 <zarvok> \set
11:49:30 <zarvok> oops...
11:49:32 <opqdonut> :)
11:49:50 <RayNbow> chr1s: ah, thx
11:59:47 <phlpp> hi!
12:00:44 <byorgey> hi phlpp =)
12:02:33 <alar> here is one thing I don't understand: fmap is simply a composition of (>>=) and return, but it is defined only for Functors, while (>>=) and return are defined for every Monad
12:03:18 <balodja> Monad is a Functor
12:03:19 <ski> every monad is a functor
12:03:25 <phlpp> not every functor is a monad
12:03:27 <byorgey> alar: fmap is more general than a composition of (>>=) and return though.
12:03:33 <phlpp> or sth. like this
12:03:33 <phlpp> :D
12:03:38 <EvilTerran> fmap is *not* "simply a composition ..."
12:03:51 <EvilTerran> for monads, it can be expessed that way, but that's liftM, not fmap
12:03:57 <phlpp> or i think there was a difference in the pure mathematical sense
12:04:06 <alar> every Monad is a Functor?
12:04:18 <ski> yes
12:04:19 <EvilTerran> a monoidal applicative functor, at that
12:04:29 <ski> for comonads, `fmap' can be expressed in a different way
12:04:29 <byorgey> alar: in a mathematical sense, yes, although not necessarily in Haskell, unfortunately.
12:04:31 <omnId> alar: or should be, anyway.  H98's Monad class doesn't inherit its Functor class, strangely
12:04:34 <EvilTerran> but don't think too hard about that
12:04:41 <Toxaris> alar: mathematically speaking, yes, but this truth is not reflected in haskell typeclasses
12:04:46 <balodja> every monad is moreover a pair of functors :)
12:05:07 <phlpp> do you mean you understand all this category theory stuff? :F
12:05:14 <ski> (balodja : adjunction situation, eh ?)
12:05:50 <balodja> yep
12:06:16 <_andre> say i have x :: Map String (Map String Float) and a function f that takes a string and this map of maps, and returns the corresponding map
12:06:16 <quicksilver> EvilTerran: are you sure monads are monoidal functors? which tensor are they monoidal over?
12:06:29 <ski> (balodja : isn't that only up to equivalence of the other category, or something like that ?)
12:06:31 <_andre> why is the type "String -> Map String t -> Map String Float" wrong?
12:06:36 <EvilTerran> er. i'm just repeating what i'm told. :)
12:06:55 <EvilTerran> i may be wrong. what adjective would you use to distinguish them from plain Applicatives?
12:07:05 <quicksilver> monadic
12:07:06 <omnId> @type M.lookup (undefined :: Map String (Map String Int))
12:07:07 <quicksilver> :)
12:07:08 <lambdabot> Couldn't find qualified module.
12:07:09 <EvilTerran> bah
12:07:28 <EvilTerran> they're monadic doohickeys too, though. that's no fun.
12:07:36 <byorgey> _andre: a function with that type would need to be able to return a Map String Float for *any* type t.
12:07:49 <byorgey> _andre: but that's obviously impossible, unless you just return an empty map.
12:08:00 <quicksilver> or a constant map, etc
12:08:06 <byorgey> right.
12:08:21 <quicksilver> or map which generates floats entirely from the String key but ignores the 't' parts
12:08:27 <quicksilver> either way, the 't' part can't contribute
12:08:43 <_andre> hmm
12:09:21 <_andre> i thought it just meant "returns a map from strings to floats"
12:09:36 <byorgey> _andre: that's what the Map String Float at the end means.
12:09:58 <byorgey> _andre: but the Map String t in the middle means, "this function works on maps from String to *anything*".
12:10:27 <ski> `forall t. String -> Map String t -> Map String Float' means "take a string, and a map from string to *anything*, and return a map from string to float"
12:10:28 <byorgey> _andre: you probably want to spell it out explicitly: something like String -> Map String (Map String Float) -> Map String Float
12:11:17 <quicksilver> @type \s m -> Data.Map.map (const (1::Float)) m
12:11:18 <lambdabot> forall t a k. t -> Data.Map.Map k a -> Data.Map.Map k Float
12:11:21 <quicksilver> just to be difficulat :)
12:11:28 <_andre> i tried that
12:11:30 <quicksilver> that has a generalisation of _andre's type :)
12:11:35 <_andre>     Couldn't match expected type `Float'
12:11:35 <_andre>            against inferred type `Map String Float'
12:11:56 <byorgey> _andre: maybe paste your code?
12:11:59 <byorgey> !hpaste
12:12:06 <byorgey> !paste
12:12:06 <hpaste> Haskell paste bin: http://hpaste.org/
12:12:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3774
12:13:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3776
12:13:16 <_andre> the latter :p
12:14:43 <byorgey> hm, my guess is that the do-notation is confusing you.
12:14:53 <_andre> probably
12:15:16 <byorgey> the <- line extracts x from the monad but the return puts it right back in.
12:15:44 <byorgey> _andre: what do you want it to do if the key is not found?
12:15:49 <omnId> (do x <- action ; return x)  =  action
12:15:54 <omnId> this is one of the monad laws
12:16:19 <_andre> throwing an error would be ok
12:16:50 <ski> @. pl undo (do x <- action; return x)
12:16:51 <lambdabot> action
12:16:58 <hpaste>  byorgey annotated "(no title)" with "pattern matching on Maybe" at http://hpaste.org/3774#a1
12:17:09 <byorgey> _andre: you could do something like that ^^
12:17:27 <byorgey> _andre: you could also use the fromJust function in Data.Maybe which essentially does exactly the same thing.
12:18:09 <omnId> or (fromMaybe (error "blah!") (lookup ...))
12:18:49 <shapr> mmm code!
12:18:51 <ski> @type Data.Maybe.fromJust
12:18:52 <lambdabot> forall a. Maybe a -> a
12:18:53 <ski> @type Data.Maybe.fromMaybe
12:18:54 <lambdabot> forall a. a -> Maybe a -> a
12:18:55 <_andre> thanks!
12:18:56 <byorgey> _andre: using do notation like you had means that the result of your function must be some monadic value (such as, for example, Maybe foo), but you just wanted it to be a Map
12:19:07 <_andre> yeah
12:19:19 <_andre> i didn't notice lookup returned a Maybe type
12:19:33 <omnId> @type Data.Map.lookup
12:19:34 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
12:19:38 <omnId> @instances Monad
12:19:39 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:19:45 <omnId> not just a Maybe type :)
12:19:45 <_andre> ah
12:19:51 <byorgey> _andre: well... it doesn't exactly =)
12:19:52 <_andre> :)
12:20:08 <_andre> oh well... at least i understand it now
12:20:10 <_andre> thanks guys!
12:20:11 <byorgey> _andre: but Maybe is usually the most useful monad to have it in
12:20:37 <omnId> > Data.Map.lookup 3 (Data.Map.fromList [(1,'a'),(2,'b')]) :: [Char]
12:20:37 <lambdabot>   Not in scope: `Data.Map.fromList'
12:21:03 <omnId> lambdabot: really?
12:21:10 <opqdonut> wtf?!?! +RTS -hb makes my program segv??
12:21:15 <_andre> heh
12:21:21 <_andre> gotta run.. .thanks again
12:21:35 <opqdonut> tho after execution has ended i guess
12:26:08 <byorgey> wow, ghc-6.8.1 is compiling itself now.  nifty. =)
12:27:51 <mrd> > M.lookup 3 (M.fromList [(1,'a'),(2,'b')]) :: [Char]
12:27:53 <lambdabot>  ""
12:30:54 <byorgey> > M.lookup 3 (M.fromList [(1,'a')]) :: (Int -> Char)
12:30:56 <lambdabot>  <Int -> Char>
12:31:19 <byorgey> @src (->) Monad
12:31:19 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:31:32 <byorgey> @src ((->) r) Monad
12:31:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:31:38 <omnId> @src (->) return
12:31:38 <lambdabot> return = const
12:31:43 <omnId> @src (->) (>>=)
12:31:43 <lambdabot> f >>= k = \ r -> k (f r) r
12:31:58 <byorgey> @src (->) fail
12:31:58 <lambdabot> Source not found. :(
12:32:09 <byorgey> that's what I was wondering about
12:32:35 <omnId> byorgey: speake not of that abomination!
12:32:56 <omnId> @source Control.Monad.Instances
12:32:57 <lambdabot> Control.Monad.Instances not available
12:33:06 <byorgey> omnId: heh, I know.  but isn't that what lookup calls when it doesn't find the thing being looked up?
12:33:17 <byorgey> > (M.lookup 3 (M.fromList [(1,'a')]) :: (Int -> Char)) 6
12:33:19 <lambdabot>  Exception: Data.Map.lookup: Key not found
12:33:23 <byorgey> ah, ok
12:35:41 * ski wonders why docs on `Control.Monad.Cont.callCC' talks about "*escape* continuations"
12:35:57 <b_jonas> @hoogle [Maybe a] -> Maybe [a]
12:35:58 <lambdabot> No matches, try a more general search
12:36:02 <quicksilver> b_jonas: sequence
12:36:11 <b_jonas> I thought it has to be some monad thing
12:36:12 <b_jonas> thanks
12:36:25 <quicksilver> > sequence [Just 3, Just 4, Just 5, Just 10]
12:36:27 <lambdabot>  Just [3,4,5,10]
12:36:30 <quicksilver> > sequence [Just 3, Just 4, Just 5, Just 10,Nothing]
12:36:31 <lambdabot>  Nothing
12:36:37 <quicksilver> assuming that's what you want :)
12:36:48 <quicksilver> see also 'catMaybes' for something slightly different
12:36:59 <ski> @type Data.Maybe.catMaybes
12:37:01 <lambdabot> forall a. [Maybe a] -> [a]
12:37:19 <Toxaris> > msum [Just 3, Just 4, Just 5, Just 10, Nothing] -- or this?
12:37:20 <lambdabot>  Just 3
12:37:34 * Toxaris says nonsense :(
12:37:51 <omnId> ((->) r) just inherits fail = error: http://darcs.haskell.org/packages/base/Control/Monad/Instances.hs
12:38:29 <quicksilver> msum is 'first success' semantics
12:38:32 <byorgey> omnId: got it.  I guess that makes sense.
12:38:45 <byorgey> by which I mean 'makes the least nonsense'.
12:39:10 <Toxaris> quicksilver: for [], it's all successes
12:39:11 <byorgey> woo, ghc compile is done!
12:39:23 <b_jonas> I want the former
12:39:36 <b_jonas> that is, sequence
12:40:22 <quicksilver> Toxaris: yes. [] is a different kind of MonadPlus to Maybe
12:40:31 <quicksilver> Toxaris: Maybe is a so-called 'OrElse' MonadPlus
12:40:41 <quicksilver> Toxaris: [] is a 'non-determinism' MonadPlus
12:40:46 <quicksilver> they're rather different in character
12:41:26 <mtp> i'm having a brainfart today, how do you join an a string to an array?
12:41:33 <alexj_> @seen igloo
12:41:34 <lambdabot> igloo is in #ghc, #darcs and #haskell. I last heard igloo speak 16m 19s ago.
12:41:40 <quicksilver> mtp: array? or list?
12:41:46 <mtp> i have "map show [things]"
12:41:48 <Toxaris> hehe yes I know, just mixed up what in [Maybe a] is the monad...
12:42:08 <quicksilver> mtp: sounds like you have a list of strings, [String]
12:42:14 <byorgey> mtp: perhaps you want concat?
12:42:16 <mtp> quicksilver: yes, a list, sorry.
12:42:20 <quicksilver> mtp: what do you want to do with them?
12:42:28 <quicksilver> concat joins them all together
12:42:35 <quicksilver> unlines joins them all together with newlines inbetween
12:42:37 <mtp> i want to join them together with a tab
12:42:51 <quicksilver> concat . intersperse "\t"
12:43:15 <byorgey> > concat . intersperse "\t" . map show $ [1..3]
12:43:16 <mtp> concat . intersperse "\t" map show [a,b,c], then?
12:43:16 <lambdabot>  "1\t2\t3"
12:43:23 <mtp> ok
12:43:34 <mtp> thanks :)
12:43:34 <b_jonas> @src guard
12:43:35 <lambdabot> guard True  =  return ()
12:43:35 <lambdabot> guard False =  mzero
12:43:37 <quicksilver> mtp: concat . intersperse "\t" (map show [a,b,c])
12:43:39 <byorgey> mtp: modulo some parentheses, yes =)
12:43:43 <quicksilver> mtp: or, concat . intersperse "\t" $ map show [a,b,c]
12:43:49 <b_jonas> @src Maybe mzero
12:43:50 <lambdabot> mzero = Nothing
12:43:51 <quicksilver> mtp: or, concat . intersperse "\t" . map show  $ [a,b,c]
12:43:53 <Toxaris> quicksilver: is there some theoretical background for this distinction? are there more classes then []-like and Maybe-like? can the (mempty, mplus)-facet be seen independently of the (return, >>)-facet?
12:44:04 <quicksilver> depending how you like to view your pipelines
12:44:07 <quicksilver> Toxaris: yes
12:44:22 <EvilTerran> you could consider Monad + Monoid = MonadPlus
12:44:29 <mtp> thanks quicksilver and byorgey :)
12:44:36 <EvilTerran> mempty = mzero, mappend = mplus
12:44:41 <byorgey> mtp: you're welcome!
12:44:42 <quicksilver> Toxaris: http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
12:44:43 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
12:44:56 <quicksilver> EvilTerran: no, we are discussing the two different 'kinds' of MonadPlus
12:45:10 <EvilTerran> I was answering the "can the (mempty, mplus)-facet be seen independently of the (return, >>)-facet?" bit
12:45:11 <quicksilver> EvilTerran: two different possible ways the Monoid part might interact with the Monad part
12:45:35 <EvilTerran> although either that mempty should've been an mzero or the mplus an mappend, but regardless...
12:46:49 <b_jonas> so how's this? is ::-qualified expressions an extension or is only ::-qualified patterns like that?
12:47:00 <ski> the latter
12:47:15 <b_jonas> EvilTerran: I'm checking if guard does what I want for Monads
12:47:59 <EvilTerran> b
12:48:10 <EvilTerran> b_jonas, i'm pretty sure :: in expressions is h98
12:49:08 <b_jonas> for Maybes I meant
12:49:13 <b_jonas> ok, thanks
12:49:54 <Lemmih> Igloo: ping.
12:50:17 <EvilTerran> @src guard
12:50:17 <lambdabot> guard True  =  return ()
12:50:17 <lambdabot> guard False =  mzero
12:50:38 <omnId> @src Maybe mzero
12:50:38 <lambdabot> mzero = Nothing
12:50:53 <b_jonas> yes, that's what I typed too
12:50:54 <omnId> return = Just, of course :)
12:51:29 <quicksilver> I use guard in maybes to enforce a series of rules
12:51:47 <quicksilver> guard (this must be true) ; guard (that must be true) ; guard (check this as well) ; return answer
12:51:54 <Toxaris> quicksilver: thanks for the link, it helps a lot, except for: could there be other Monad-Monoid combinations? i find it interesting that (the proposed) MonadPlus is specified in terms of >>=, and the proposed MonadOr in terms of return. is that important?
12:53:24 <quicksilver> Toxaris: I think you might imagine others, yes
12:53:29 <quicksilver> Toxaris: those are the most obvious choices
12:54:14 <b_jonas> I used it like this:
12:54:31 <quicksilver> Toxaris: it's not clear to me why they don't talk about the relationship between morelse and >>=. Maybe I haven't thought hard enough.
12:54:36 <hpaste>  b_jonas pasted "cdblFromExactlyInt" at http://hpaste.org/3777
12:55:09 <hpaste>  b_jonas annotated "cdblFromExactlyInt" with "(no title)" at http://hpaste.org/3777#a1
12:55:23 <quicksilver> b_jonas: yes, that kind of thing
12:55:55 <quicksilver> b_jonas: you're not really using 'z', why not move (x :+ y) into the LHS of the definiton?
12:56:04 <b_jonas> ah yes, I could do that
12:56:27 <b_jonas> thanks
12:56:29 <idnar> hmm, I want to read "morelse" as "morals"
12:56:35 <byorgey> even if you were using the z, you could write z@(x :+ y)
12:56:48 <idnar> morelse -> more else -> morals
12:57:05 <b_jonas> and it has to be renamed to cdblToExactlyInt
12:57:10 <byorgey> morelse -> moreels -> moray eels
12:57:18 <b_jonas> or fromCdblExactlyInt
12:57:20 <b_jonas> or something
12:57:51 <quicksilver> b_jonas: I would note that '== 0' may not be particularly sensible on Double
12:57:59 <quicksilver> b_jonas: due to rounding errors building up
12:58:03 <b_jonas> quicksilver: yes, but
12:58:06 <b_jonas> here it is sensible
12:58:09 <quicksilver> ok :)
12:58:13 <b_jonas> the lexer needs this oen
12:58:16 <quicksilver> as long as its noted!
12:58:27 <b_jonas> it's noted by the word "Exactly"
12:58:35 <b_jonas> I'll also need a non-exact variant
12:58:47 <Toxaris> isn't the difference between mplus and morelse like the difference between "symmetrical choice" and "biased choice" in parser combinator libs?
12:58:49 <b_jonas> for using complex numbers as array indexing
12:59:09 <b_jonas> (different kind of numbers are implicitly converted in J)
12:59:20 <EvilTerran> Toxaris, not really, i think they're both left-biased
12:59:42 <b_jonas> not only array indexing, but also other integer things
13:01:45 <Toxaris> > [1, 2] `mplus` [3, 4] -- from left-biased, I would expect [1, 2] only
13:01:47 <lambdabot>  [1,2,3,4]
13:02:06 <quicksilver> mplus is 'nondeterministic choice'
13:02:10 <quicksilver> i.e. don't choose
13:02:12 <Toxaris> but maybe i'm not understanding the precise meaning of the biased choice operation
13:02:15 <quicksilver> carry on with all variants
13:02:57 <EvilTerran> well, in the Maybe case, it's left-biased
13:04:38 <Toxaris> EvilTerran: I don't think a MonadPlus instance satisfying Left Distribution is possible for Maybe
13:05:00 <Toxaris> EvilTerran: so there can only be the left-biased morelse-operator for Maybe
13:05:25 <EvilTerran> "mplus: an associative operation"
13:05:44 <EvilTerran> "mzero: the identity of mplus. It should also satisfy the equations mzero >>= f  =  mzero; v >> mzero   =  mzero"
13:05:52 <quicksilver> EvilTerran: we're looking at http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
13:05:53 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
13:06:04 <EvilTerran> oh, right. i was quoting @docs Control.Monad
13:06:04 <quicksilver> EvilTerran: which recommends stronger laws for mplus
13:06:07 <EvilTerran> i'll go look at that
13:06:18 <quicksilver> in order to distinguish between the two 'kinds' of monadplus
13:07:08 <EvilTerran> ahh
13:09:38 <Cale> also, most MonadPlus instances would also be MonadOrElse instances, in a different way
13:11:31 <Toxaris> wouldn't (<|>) and (<||) be better names for mplus and morelse? would it be possible to unify Control.Applicative.(<|>) and this new (<|>), it should mean the same thing anyway, shouldn't it?
13:13:14 <quicksilver> my copy of the Control.Applicative docs tells rather little about the expected semantics of <|>
13:13:15 <ski> i guess it depends on which laws are expected to hold
13:13:26 <quicksilver> by 'rather little' I mean 'almost nothing'
13:13:28 <quicksilver> only that it's a monoid
13:13:31 <quicksilver> so I'd have to guess :)
13:13:57 <quicksilver> "morelse" seems like a non-applicative idea to me, though
13:14:09 <quicksilver> so I'm guessing <|> is more like to be non-deterministic choice
13:14:25 <twanvl> "Alternative" already sounds very orElsey
13:14:34 <quicksilver> you'd think so, wouldn't you?
13:14:39 <Toxaris> > "ab" <|> "cd"
13:14:41 <lambdabot>  "abcd"
13:14:54 <quicksilver> but 'alternatives in parallel' sounds very non-determinismy to me
13:15:05 <quicksilver> and in applicative stuff happens 'in parallel'
13:15:16 <ski> *nod*
13:15:17 <quicksilver> in the sense that applicative actions don't affect each other
13:15:26 <twanvl> Perhaps orElse should be BiasedAlternative
13:15:32 <quicksilver> yeah
13:15:37 <quicksilver> orElse means 'try me first then me'
13:15:40 <quicksilver> it's like `catch`
13:15:52 <quicksilver> but, I'm working entirely on intuition here
13:15:58 <quicksilver> and not on any actual documented laws ;)
13:16:01 <quicksilver> so I could be way off
13:17:29 <ski> actually, the result of an applicative action can't be used in a "parallel" action, however that is not the case here, only internal "upwards" combination of the results of both parts, no "side-ways" passing of information
13:18:03 <quicksilver> yes
13:18:07 <ski> so i think there could be a `MonadElse' variant for `Applicative'
13:18:08 <b_jonas> quicksilver: the docs apparently think the reader is familiar with obscure category theory notions
13:18:21 <quicksilver> b_jonas: which docs?
13:18:27 <quicksilver> Applicative doesn't really have docs, does it?
13:18:37 <b_jonas> "quicksilver: my copy of the Control.Applicative docs tells rather little about the expected semantics of <|>"
13:18:41 <quicksilver> :)
13:18:43 <quicksilver> right
13:18:49 <ski> "(Technically, a strong lax monoidal functor.)"
13:18:52 <quicksilver> ah yes
13:18:56 <quicksilver> but that is in brackets
13:19:03 <quicksilver> obviously you're not expected to know what it means :)
13:19:27 <Toxaris> and it doesn't help with Alternative, does it?
13:19:40 <ski> nope
13:19:43 <omnId> "You're not expected to understand this."
13:20:05 <b_jonas> exactly
13:20:08 <Toxaris> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf doesn't tell about Alternative too
13:20:16 <quicksilver> I know what lax means.
13:20:21 <quicksilver> I used to know what strong meant, but no longer.
13:20:25 <quicksilver> My brain is old and tired.
13:21:18 <sizur> how can i zip orderly initinte lists?
13:21:35 <quicksilver> > zip [1..] [2..]
13:21:37 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
13:21:40 <quicksilver> looks ok to me?
13:21:44 <quicksilver> what appears to be the problem, sir?
13:22:15 <sizur> > zip [1..] [5..]
13:22:16 <lambdabot>  [(1,5),(2,6),(3,7),(4,8),(5,9),(6,10),(7,11),(8,12),(9,13),(10,14),(11,15),(...
13:22:32 <byorgey> sizur: is that what you want?  or do you mean merge?
13:22:58 <sizur> @type merge
13:22:59 <lambdabot> Not in scope: `merge'
13:23:00 <ski> i suppose `optional',`some',`many' are borrowed from parsers ?
13:23:12 <sizur> byorgey: merge then
13:23:16 <byorgey> sizur: well, it doesn't exist, but not too hard to write
13:23:23 <omnId> @go site:hpaste.org hamming cale
13:23:25 <lambdabot> http://hpaste.org/486
13:23:25 <lambdabot> Title: Hamming numbers - hpaste
13:23:44 <Cale> heh
13:23:52 <byorgey> sizur: there's merge ^^  =)
13:24:05 <byorgey> it's the (#) function defined there
13:24:12 <omnId> ^ I believe that has an ordered merge operator
13:24:42 <omnId> Cale: sorry for the ping =)
13:24:48 <sizur> thanks a lot
13:24:51 <quicksilver> let {merge [] xs = xs; merge xs [] = xs; merge (x:xs) (y:ys) = if x<y then x : merge xs (y:ys) else y : merge (x:xs) ys} in merge [1..] [5..]
13:24:52 <byorgey> note, that version *requires* the lists to be infinite, but it's not too hard to add some base cases to deal with empty lists
13:24:53 <b_jonas> @hoogle (a->b->c->d)->c->a->b->d
13:24:54 <lambdabot> No matches, try a more general search
13:24:59 <quicksilver> > let {merge [] xs = xs; merge xs [] = xs; merge (x:xs) (y:ys) = if x<y then x : merge xs (y:ys) else y : merge (x:xs) ys} in merge [1..] [5..]
13:25:01 <lambdabot>  [1,2,3,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17...
13:25:12 <sizur> this is it!
13:25:19 <quicksilver> some people like to twist around xs and ys in the recursive case
13:25:25 <quicksilver> for a certain kind of fairness condition
13:25:26 <sizur> can you nub an infinite l?
13:25:30 <quicksilver> depends if you care
13:25:39 <quicksilver> sizur: not with the prelude function nub, no
13:25:45 <quicksilver> sizur: but it's easy to write your own
13:25:58 <sizur> if it's ordered like that, yeah
13:26:02 <quicksilver> (assuming sorted)
13:26:08 <Toxaris> > nub [1..]
13:26:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:26:22 <b_jonas> @pl \f->z->x->y->f x y z
13:26:22 <lambdabot> (line 1, column 6):
13:26:22 <lambdabot> unexpected ">" or "-"
13:26:22 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
13:26:25 <quicksilver> oh
13:26:29 <quicksilver> maybe prelude nub is safe?
13:26:32 <b_jonas> @pl \f z x y -> f x y z
13:26:32 <lambdabot> flip . (flip .)
13:26:39 <quicksilver> perhaps I misremembered what it does
13:26:43 <quicksilver> @src nub
13:26:43 <lambdabot> nub = nubBy (==)
13:26:48 <quicksilver> @src nubBy
13:26:48 <lambdabot> nubBy eq []             =  []
13:26:48 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:26:50 <Toxaris> > nub ([1..10] ++ [1..])
13:26:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:26:53 <b_jonas> > nub [3 1 4 1 5] ++ [1..]
13:26:53 <omnId> > nub (cycle [1..5]) -- _|_ after the first 5
13:26:54 <lambdabot>        add an instance declaration for (Num (t -> t1 -> t2 -> t3 -> a))
13:26:55 <lambdabot>     I...
13:26:58 <lambdabot> Terminated
13:27:01 <b_jonas> > nub $ [3 1 4 1 5] ++ [1..]
13:27:02 <lambdabot>        add an instance declaration for (Num (t -> t1 -> t2 -> t3 -> a))
13:27:02 <lambdabot>     I...
13:27:06 <sizur> > let {merge [] xs = xs; merge xs [] = xs; merge (x:xs) (y:ys) = if x<y then x : merge xs (y:ys) else y : merge (x:xs) ys} in nub merge [1..] [5..]
13:27:07 <lambdabot>  Couldn't match expected type `[a]'
13:27:08 <quicksilver> ah yes
13:27:13 <sizur> > let {merge [] xs = xs; merge xs [] = xs; merge (x:xs) (y:ys) = if x<y then x : merge xs (y:ys) else y : merge (x:xs) ys} in nub $ merge [1..] [5..]
13:27:14 <quicksilver> it accumulates a bit thunk of previously seen items
13:27:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:27:14 <ski> > take 5 $ nub (cycle [1..5])
13:27:16 <lambdabot>  [1,2,3,4,5]
13:27:18 <b_jonas> > nub $ [3 1 4 1 5] ++ [1..] :: [Int]
13:27:19 <lambdabot>        add an instance declaration for (Num (t -> t1 -> t2 -> t3 -> Int))
13:27:19 <sizur> perfecto!
13:27:19 <lambdabot>    ...
13:27:19 <quicksilver> so it works
13:27:23 <quicksilver> but it's a bit daft
13:27:33 <quicksilver> custom version which exploits orderign would be better
13:27:37 <b_jonas> > nub $ [3, 1, 4, 1, 5] ++ [(1 :: Int)..]
13:27:39 <lambdabot>  [3,1,4,5,2,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:27:40 <quicksilver> (run in constant space instead of linear space)
13:27:43 <b_jonas> there
13:28:15 <exDM69> @src nub
13:28:15 <lambdabot> nub = nubBy (==)
13:28:31 <int-e> > nubBy (((== 0) .) . flip mod) [2..]
13:28:32 <Toxaris> quicksilver: exploits ordering? we are talking about nub'ing an ordered list? what about something like   map head . group  then?
13:28:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:28:44 <sizur> arent these functions good enough to be included into List?
13:28:54 <b_jonas> group?
13:28:58 <b_jonas> @src group
13:28:58 <lambdabot> group = groupBy (==)
13:29:04 <int-e> > nubBy (((> 1) .) . gcd) [2..]
13:29:06 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:29:13 <b_jonas> wow
13:29:18 <omnId> > group "aaabbacccaaaabbb"
13:29:19 <lambdabot>  ["aaa","bb","a","ccc","aaaa","bbb"]
13:30:06 <b_jonas> languages with large standard libraries rock
13:30:15 <quicksilver> Toxaris: yes. map head . group is precisely the algorithm I was talking about.
13:30:28 <largo1> @seen lispy
13:30:28 <lambdabot> I saw lispy leaving ##logic, #ghc, #darcs, #xmonad, #haskell-blah, #haskell and #haskell-soc 1d 16h 18m 52s ago, and .
13:30:30 <omnId> Haskell likes teh lists :)
13:30:31 <quicksilver> b_jonas: actually I think haskell has a surprisingly small but remarkably expressive standard library.
13:30:37 <quicksilver> b_jonas: well, it's not *that* small.
13:30:45 <ddarius> quicksilver: "surprisingly"?
13:30:46 <b_jonas> yep, the standard is small
13:30:47 <quicksilver> but compared to, say, Java or .NET it's tiny
13:30:53 <quicksilver> and get remarkably expressive
13:31:01 <quicksilver> ddarius: surprising relative to its expressiveness, I meant
13:31:02 <b_jonas> the libraries bundled with ghc are the ones that are large
13:31:09 <b_jonas> but well-built
13:31:11 <b_jonas> which is nice
13:31:28 <lekro> is there a way to create a generic F_p type for finite fields (where p is a prime integer, for a start)? I'd like to be able to distinguish between F_2 and F_3 on the type level, that's why I don't see a straight-foward method
13:31:42 <newsham> yah but haskell libraries dont even have ssl for example
13:31:55 <omnId> lekro: type level naturals, at a first guess.
13:32:05 <sizur> newsham: proxy ssl
13:32:14 <lekro> e.g., you can only multiply F_p's of the same type in a meaningful way
13:32:36 <quicksilver> newsham: ssl should be done by hardware anyway :P
13:32:48 <quicksilver> I'm mostly joking. I take your point.
13:32:49 <newsham> wow.. it should?  blah
13:33:17 <quicksilver> certainly if you're in the web server business, you want something else to do the SSL not your poor apache process
13:33:27 <quicksilver> but at the client end, you need SSL libs, I agree
13:33:50 <quicksilver> I doubt it would take all that much to get HsOpenSSL up to scratch
13:33:54 <quicksilver> but I haven't tried :)
13:34:00 <lekro> omnId: hm, I read something about that. those are basically peano numbers, aren't they?
13:34:01 <newsham> maybe you meant to say that the encryption should be done in hardware?
13:34:26 <omnId> lekro: afaiu
13:34:47 <newsham> bindings to C libs are good and all... but the reason I'm using haskell is because c bugs are dangerous.
13:34:53 <lekro> omnId: but is it possible to translate larger numbers (like, more than one decimal digit) into this system?
13:35:01 <quicksilver> hmm there is hsgnutls, too
13:35:07 <opqdonut> lekro: of course
13:35:13 * ski wonders how hard it could be to define a `Prime' class
13:35:13 <newsham> yes there is, we were discussing the std libs.
13:35:14 <opqdonut> arbitary naturals
13:35:29 <lekro> opqdonut: how would that look like?
13:35:32 <mrd> newsham: SSL isn't exactly something to take lightly in implementation
13:35:40 <quicksilver> newsham: 'std' isn't well defined for haskell
13:35:47 <newsham> mrd: I know.  neither is a large C implementation of it ;-)
13:35:55 <mrd> sadly
13:35:57 <quicksilver> newsham: ghc bundles a bunch of libraries mostly out of habit
13:36:04 <quicksilver> they aren't "Standard" particularly
13:36:10 <pejo> lekro, you might be interested in "Polytopes & Polytypes: Generic Isosurfacing & Functional programming" - they show how to get dimensionality checks through phantom types.
13:36:20 <newsham> qs: i'm not sure exactly what you're arguing
13:36:21 <ski> S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))  -- numeral for 12
13:36:27 <opqdonut> jep
13:36:28 <omnId> data Z; data S a; then the type S (S (S Z)) would represent a typelevel 3.
13:36:29 <pejo> lekro, there might be a better source around for this though, I just don't happen to know one.
13:36:31 <lekro> ski: that's what I was afraid of
13:36:38 <newsham> ski: you want to enforce primality in the type system?
13:36:41 <quicksilver> newsham: I'm saying that stuff on hackage isn't any less "Standard" than stuff that comes with GHC.
13:36:53 <quicksilver> lekro: you can use Binary instead
13:36:57 <lekro> ski: I can't type the numbers that way
13:37:00 <newsham> qs: its not fair to cmpare hackage to say java std libs.
13:37:11 <newsham> any more than it is fair to compare h98 libs to cpan
13:37:13 <quicksilver> lekro: then 12 is merely I(I(O(O Z)))
13:37:21 <ski> lekro : there's an alternative, like `D (D Z D2) D1' -- or something .. base 10
13:37:31 <quicksilver> newsham: right. Now I don't know what *you're* saying.
13:37:33 <newsham> cheaper by the DZ
13:37:46 <quicksilver> newsham: I thought you were criticising me for mentioning hackage libs in my quest for an SSL lib
13:37:53 <newsham> [11:29] < quicksilver> b_jonas: actually I think haskell has a surprisingly small but remarkably expressive standard library.
13:37:59 <newsham> [11:30] < newsham> yah but haskell libraries dont even have ssl for example
13:38:01 <newsham> thats all
13:38:04 <newsham> not apples/apples
13:38:06 * quicksilver nods
13:38:16 <quicksilver> I stand by my statement :)
13:38:16 <ski> newsham : lekro for some reason wanted only finite fields of prime order
13:38:22 <quicksilver> I think it's very expressive for its size.
13:38:37 <quicksilver> notwithstanding it's failure to
13:38:39 <quicksilver> contain SSL
13:38:45 <quicksilver> (and plenty of other useful stuff)
13:38:49 <pejo> lekro, (they ditched the kind encoding people are talking about here due to it being too complex).
13:39:13 <newsham> can you encode division in haskell (ghc-extensions) types?
13:39:35 <quicksilver> you could encode certain kinds of computable division, yes
13:39:44 <sizur> newsham: what do you need ssl lib for? if it's for https, then simply use a proxy
13:40:00 <quicksilver> haskell types are pretty much finite set theory
13:40:03 <lekro> ski: well, it'd be OK also if primality is not enforced. First, I'm only looking for a way to distinguish different finite field through their types
13:40:05 <newsham> sizur: I dont need ssl.
13:40:09 <quicksilver> anything you can encode in finite sets, you can encode in haskel types
13:40:11 <newsham> *sigh*
13:40:12 <mrd> http://okmij.org/ftp/Haskell/types.html#peano-arithm
13:40:13 <lambdabot> Title: Haskell Programming: Types
13:40:14 <quicksilver> but it wouldn't be fun.
13:40:33 <mrd> oleg dun it
13:40:38 <lekro> ski: so that no two elements of different fields can get accidentally added or multiplied
13:40:42 <ski> @quote oleg
13:40:43 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
13:40:46 <mrd> Binary Type Arithmetic
13:40:53 <ddarius> With -fallow-undecideable-instances, Haskell's type system is Turing-complete.
13:41:10 <newsham> mrd: thanks.  I need to learn this fundeps stuff
13:41:17 <quicksilver> ddarius: not that you need turing complete for division, of course.
13:41:23 <quicksilver> but yes, absolutel.
13:41:27 <ddarius> quicksilver: True.
13:41:30 <newsham> ddarius: does it support dependant types?
13:41:37 <quicksilver> it can encode them.
13:41:38 <ddarius> newsham: FunDeps are allegedly on their way out.
13:41:43 <ddarius> newsham: No.
13:41:51 <quicksilver> but encoding general dependent types is a nightmare.
13:42:03 <quicksilver> and not recommended as a useful technique!
13:42:08 <mrd> 1. fun deps, 2. ??, 3. Profit!
13:42:14 <quicksilver> 2. madness
13:42:18 <ddarius> You can reify and reflect between type and value level things, but it's not dependent types and it's not pleasant.
13:42:20 <bos> 2. ATs
13:42:43 <ddarius> (Well, relative to dependent types, it's actually not all that bad otherwise.)
13:43:04 <Toxaris> for a finite (small) number of different finite fields, you don't need no type level arithmetic, phantom types should be enough, shouldn't they?
13:43:10 <sizur> quicksilver: can you make that merge take a [[]]?
13:43:32 <quicksilver> sizur: infinite list of infinite lists requires a different strategy
13:43:45 <quicksilver> sizur: you need to traverse diagonally to guarantee you make progres
13:43:49 <quicksilver> erm
13:43:56 <quicksilver> and you can't keep them ordered
13:44:01 <mrd> strange question: if you're working on a many-way machine and 2 of the CPU cores run much slower than the others, what do you suspect?
13:44:03 <quicksilver> so, the short answer is "no".
13:44:14 <newsham> i'm kinda interested in how hard it would be to encode some arithmetic (naturals) proofs in a similar way as the logic proofs I have using curry-howard
13:44:17 <quicksilver> mrd: two of the cores are downloading porn?
13:44:27 <mrd> i think we've ruled that out
13:44:31 * quicksilver ponders
13:44:38 <pejo> mrd, all interrupts are directed to those cores?
13:44:40 <b_jonas> mrd: 2 of how much?
13:44:43 * mrd wonders what kind of porn a core would download so much of?  hard-core?
13:44:47 <newsham> someone should write an article with arithmetic proofs in haskell types ;-)
13:44:48 <sizur> quicksilver: why cannot you keep em ordered if each is ordered from the start?
13:44:50 <mrd> b_jonas: 2 of 8 in this case
13:44:52 <quicksilver> mrd: unusually high level of hardware exceptions
13:45:00 <mrd> pejo: no idea
13:45:04 <b_jonas> mrd: that's strange
13:45:05 <quicksilver> sizur: because you never know for sure that a lower item does occur in a later list
13:45:14 <pejo> mrd, what OS is it for starters, and what is the machine doing?
13:45:15 <b_jonas> 2 of 4 I could understand
13:45:26 <quicksilver> sizur: suppose you've checked the first item of the firs million lists
13:45:27 <b_jonas> maybe those are used by some other processes?
13:45:27 <mrd> ok, so it's Fedora, and the machine is idle right now during testing
13:45:38 <mrd> and i believe it's 4 dual-cores
13:45:39 <quicksilver> sizur: and the smallest is 2
13:45:50 <sizur> quicksilver: ok yes, it needs to be a finite list of infinite lists
13:45:55 <quicksilver> sizur: how can you be sure that there isn't a "1" waiting in the two-millionth
13:45:56 <sjanssen> mrd: NUMA?
13:46:03 <quicksilver> sizur: yeah. Then you can do it.
13:46:12 <mrd> xeons
13:46:32 <sizur> quicksilver: thanks for the explanation :)
13:46:36 <mrd> i'd imagine numa, but i don't know
13:47:01 <mrd> pejo: how could i tell about the interrupts?
13:47:48 <mrd> looking at proc/interrupts
13:47:51 <quicksilver> sizur: it will still be fairly slow
13:48:01 <quicksilver> sizur: you keep the list-of-lists sorted, by their first element
13:48:13 <quicksilver> sizur: you take the first of the first (which must be the lowest, by definition)
13:48:25 <quicksilver> sizur: then you "push" that list back up until it's in the right place
13:48:28 <quicksilver> sizur: and continue
13:48:56 <sizur> quicksilver: thanks, let me try my hand at implementation
13:51:35 <newsham> mrd: where's rsa?
13:53:32 <pejo> mrd, well, yeah, that's where I would look. But I have no idea what is unusually high for that kind of box.
13:53:45 <pejo> mrd, nor how to trace it, unless you have something like Dtrace in Linux.
13:53:46 <mrd> cpu0 handles all of the timer interrupts
13:53:51 <mrd> hmm
13:53:55 <mrd> newsham: err?
13:54:16 <mrd> oh RSA in the type system
13:54:19 <mrd> its around there somewhere
13:54:19 <pejo> mrd, well, the interrupts aren't supposed to be distributed among all CPU's, so that part is normal.
13:54:35 <shapr> @quote RSA
13:54:35 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
13:54:37 <mrd> pejo: yea i don't see anything particularly striking about it
13:54:38 <pejo> This feels like stuff wli could answer.
13:54:50 * mrd pokes around some more
13:54:54 <mrd> @go Dtrace
13:54:56 <lambdabot> http://www.sun.com/bigadmin/content/dtrace/
13:54:56 <lambdabot> Title: BigAdmin: DTrace
13:55:09 <flux> what would type level RSA implementation allow, has that been discussed?-)
13:55:17 <esap> encapsulation?
13:56:03 <flux> I find it difficult to think in practical terms..
13:56:06 <ski> esap : ?
13:56:50 <esap> ski: RSA in type level would be like a strong form of encapsulation.
13:57:52 <ski> in that it only runs at compile-time ?
13:58:15 <scvr> ~
13:59:00 <flux> so, you would publish an interface that has been encrypted with the private part of the key, and if you have the public part of the key, you can make your code compile against it?
13:59:01 <esap> well it could be used to hide the actual type of a value.
13:59:53 <shapr> dons: Hey, why don't we have a haskell browser plugin like the squeak browser plugin?
14:00:58 <newsham> mrd: that peano math article hints at rsa and then leaves it as an exercise :(
14:01:08 <esap> ski: A type RSA(X) would be some type y, from which X is not recoverable without the key.
14:01:10 <mrd> newsham: gosh i'm pretty sure i actually saw it somewhere
14:01:11 * SamB wishes wireshark had an "ignore internet radio" mode
14:01:30 <shapr> SamB: You can filter it out.
14:01:44 <ski> esap : ah .. interesting
14:02:32 <newsham> esap: RSA is invertible.  its just expensive.
14:02:39 <newsham> "not recoverable without the key" is incorrect
14:02:47 <hpaste>  lekro pasted "generic instance" at http://hpaste.org/3778
14:02:51 <lekro> what's the problem with this code? If I ensure that I don't write instance Foo Int or something, it shouldn't be ambiguous
14:02:59 <esap> newsham: ok, where recovering the type X is expensive.
14:03:05 <ddarius> lekro: YOu can't ensure that.
14:03:12 <lekro> hm.
14:03:21 <lekro> can I make ghc to ensure that?
14:03:53 <hpaste>  chessguy pasted "surely this can be simplified" at http://hpaste.org/3779
14:03:57 <ddarius> Effectively no.
14:04:04 <chessguy> apparently my brain is on strike
14:04:07 <quicksilver> shapr: because we'd need a VM?
14:04:15 <quicksilver> shapr: and someone to turn that VM into a browser plugin?
14:04:32 <RayNbow> http://web.archive.org/web/20070221213913/http://research.microsoft.com/~simonpj/Papers/marktoberdorf/mark.pdf <-- gotta love web.archive.org :)
14:04:33 <quicksilver> shapr: I think compiling to an existing VM (flash?) might be an easier job.
14:04:34 <lambdabot> http://tinyurl.com/225v2f
14:04:38 <ddarius> chessguy: Use guards clearly.
14:04:58 <chessguy> ddarius, yeah, but i'm not sure what the minimal set of conditions that i need to check are
14:05:01 <chessguy> err, is
14:05:03 <lekro> ddarius: I'm just thinking how you would go and implement classes like Ring, Field etc., where it'd make sense to make an instance Num a => Ring a
14:05:05 <esap> basically what you need to do to recover a type X from RSA(X) is to prove that the value has that type. That's as hard as you want encapsulation to be. Proof is sufficient to open it.
14:05:07 <newsham> quick: why do you need a vm?
14:05:13 <TSC> chessguy: For that case, maybe "and" would help
14:05:19 <hpaste>  glguy annotated "surely this can be simplified" with "simpler?" at http://hpaste.org/3779#a1
14:05:35 <ddarius> lekro: Reimplementing Num altogether is the best asnwer.
14:05:37 <newsham> shapr: yhc can compile to javascript, no?
14:05:50 <hpaste>  glguy annotated "surely this can be simplified" with "no guards?" at http://hpaste.org/3779#a2
14:05:57 <shapr> newsham: I think so
14:06:08 <newsham> shapr: so plugin not needed.  js already widespread adopted
14:06:19 <quicksilver> yes, JS is another possible VM target
14:06:26 <quicksilver> ISTR there are limitations in the JS backend
14:06:33 <quicksilver> (of course JS = ecmascript = flash...)
14:06:38 <quicksilver> so there might be a pathway there
14:06:49 <quicksilver> we could do sexier graphics with flash :)
14:07:18 <newsham> there's no reason you need to have a VM to support a language in a browser
14:07:25 <newsham> an interpretter or compiler would be fine
14:08:02 <chessguy> glguy, your first paste's guard should be b && c && d, yes?
14:08:07 <esap> Working type level encryption is basically the same thing to software as black holes are to physics.
14:08:13 <glguy> chessguy: yeah
14:09:10 <flux> esap, well, should work with c++ templates, no?-)
14:09:15 <newsham> esap: I dont like that analogy.  blackholes are figments of our mathematical models extrapolated to domains in which the equations are known not to hold.
14:09:22 <flux> --max-template-level=99999999
14:09:35 <newsham> type level encryption is just another example of computation
14:09:38 <hpaste>  glguy annotated "surely this can be simplified" with "without case :)" at http://hpaste.org/3779#a3
14:09:40 <esap> newsham: Well so is encryption. Nobody knows if encryption is possible.
14:09:42 <Arnar> hey guys..
14:09:51 <shapr> hi Arnar
14:09:57 <faxathisia> esap: What do you mean?
14:10:04 <newsham> i know that encryption is possible.
14:10:10 <Arnar> anyone know of a GUI for digging down Tree-s (a la data.Tree)
14:10:10 <esap> newsham: It might be that P=NP which would basically make all current encryption algorithms easy to solve :-)
14:10:22 <glguy> asymmetric ones at least
14:10:27 <newsham> not sure what that has to do with black holes or encryption in types
14:10:28 <faxathisia> Why would P=NP make it easy ?
14:10:36 <Arnar> i.e. allowing the user to explore trees, potentially infinite so it'd have to be lazy
14:10:39 <quicksilver> well it would make it "polynomial time"
14:10:39 <faxathisia> can you e.g. factorize numbers really fast if P = NP?
14:10:45 <quicksilver> some polynomials are quite slow
14:10:49 <mrd> because it is not known whether factorization is in P, but it is in NP
14:10:53 <quicksilver> I don't much like N^3 algorithms myself
14:10:59 <newsham> also, is there analysis of traditional s-p networks (ie. DES, AES, etc.) if P=NP?
14:11:02 <faxathisia> oh really :S
14:11:04 <ddarius> faxathisia: Theoretically fast, not necessarily practically
14:11:13 <faxathisia> hmm how come factorizing is NP?
14:11:16 <mrd> however it is possible for P /= NP but factorization is in P
14:11:18 <newsham> is there any advantage to breaking s-p networks if P=NP?
14:11:19 <Arnar> N <- not necessarily fast.. could be n^1000
14:11:26 <quicksilver> Arnar: quite
14:11:32 <faxathisia> mrd: I thought that's a contradiction ?
14:11:48 <mrd> factorization-decision happens to be in NP and coNP because you can check a Yes or No answer in polynomial time
14:11:52 <reffje> this year's summer of code t-shirts don't look very good, imho
14:11:56 <esap> faxathisia: you can guess the key with a non-deterministic algorithm.
14:11:56 <reffje> they have FLOWERS on them
14:11:59 <ddarius> Haskell's type checking algorithm is theoretically slow, but practically fast.
14:12:01 <Arnar> mean P of course, not N (what's that? :)
14:12:03 <newsham> not all encryption is based on NP-hard problems.
14:12:14 <dmwit> faxathisia: NP is not necessarily the same as NP-complete.
14:12:23 <esap> newsham:_
14:12:28 <dmwit> faxathisia: All problems in P are also (trivially) in NP...
14:12:31 <mrd> in fact, I don't know of any encryption based on NP-hard problems
14:12:36 <Arnar> so how about 'em GUIs, no one done something like that?
14:12:39 <encryptio> argh, hilight madness!
14:12:52 <quicksilver> newsham: most encryption is not based on NP-hard. Or not known NP-hard, at least.
14:12:59 <quicksilver> newsham: factorization is not known to be NP-hard.
14:13:03 <newsham> mrd: I was under the impression that some schemes are provably NP-hard.
14:13:07 <quicksilver> although certainly some people believe it is.
14:13:10 <mrd> faxathisia: P is a subset of NP union coNP, which is why some think factorization may turn out to also be in P
14:13:25 <newsham> or perhaps provably as hard as factorization. hmm..
14:13:32 <faxathisia> oh alright
14:13:49 <dmwit> Wasn't there recently some really surprising progress on this front?
14:13:52 <quicksilver> U wiykd
14:13:55 <quicksilver> sorry :)
14:14:14 <esap> dmwit: you mean the result that PRIMES is in P?
14:14:40 <dmwit> esap: Yeah, maybe that was it.  I don't recall very strongly. =P
14:14:45 <scvr> there was an encryption algorithm based on the knapsack problem, but it turned out to be broken.
14:15:18 <mrd> PRIME is in P but it's a good example of a polynomial time algo that is too slow for real use =)
14:15:21 <quicksilver> newsham: according to the ssh.com faq, which is readable if not authoritative, there have been some attempts to use NP-hard problems for cryptography, but not successfully.
14:15:30 <faxathisia> What's the difference between NP and NP-complete?
14:15:44 <quicksilver> faxathisia: if it's NP-complete, it can be transformed to solve any other NP problem
14:15:45 <mrd> a problem is NP-complete if it is NP-hard and in NP
14:15:56 <mrd> a problem is NP-hard if all problems in NP can be poly-time mapping reduced to it
14:16:10 <faxathisia> ahh ok
14:16:26 <quicksilver> so if one NP-complete problem turns out to be P
14:16:28 <quicksilver> then they all are
14:16:34 <faxathisia> So no one has yet.. transformed integer factorization problem into e.g. travelling salesman?
14:16:35 <mrd> yep
14:16:37 <flux> encryptio, luckily you're not called 'np'
14:16:55 <mrd> faxathisia: no that's easy
14:16:59 <mrd> it's the other way that no one has done
14:17:15 <quicksilver> however, it seems to me fairly likely that P =/= NP
14:17:19 <encryptio> flux: lol
14:17:21 <mrd> the other way would be significant also because it would collapse NP and coNP
14:17:43 <newsham> well if qs is sure p /= np, thats good enough for me!
14:17:55 <newsham> btw, ia32 has a bp and bnp instruction, so you can test for yourself.
14:17:58 <faxathisia> mrd: Why is that?
14:18:02 <esap> most researchers I think believe P =/= NP, if for no other reason it's because there would be stunning consequences if it happened that P=NP.
14:18:06 <mrd> faxathisia: because factoring-decision is in both
14:18:17 <faxathisia> ahh ok
14:18:19 <faxathisia> I see :D
14:18:20 <newsham> if i recall correctly there are stunning results if p = np and if p != np
14:19:05 <esap> newsham: well that may be true. What should people believe then? That it's undecidable?
14:19:23 <mrd> the whole polynomial hierarchy collapses if P=NP
14:20:29 <newsham> I have two programs and one of them answers p=np correctly.  I just dont know which one it is.
14:20:49 <scvr> does the other halt?
14:20:57 <newsham> they both halt immediately
14:21:05 <esap> I think I saw some paper that claimed that P=NP question is the same as asking if existential quantification and fixed points have the same expressive power.
14:21:17 <mrd> scvr: one program is "True" and the other is "False"
14:21:39 <scvr> mrd: but how do you know which is which?
14:21:44 <newsham> I dont.
14:21:47 <esap> newsham: there are more than two possible answers to P=NP question.
14:21:58 <mrd> Maybe Bool
14:22:05 <newsham> I dont think there are.
14:22:17 <mrd> actually, Bool in Haskell is lifted anyhow, so it's got 3 inhabitants
14:22:44 <esap> newsham: It could be undecidable. Or the question could be meaningless.
14:23:11 <Toxaris> esap: what's a meaningless question?
14:23:19 <newsham> I dont think thats the case, but I can write a third program just in case.
14:23:20 <esap> Toxaris: P=NP
14:24:30 <Toxaris> esap: what does it mean for a question to be meaningless?
14:24:44 <newsham> toxaris: is this statement true or false?  "this statement is false" ?
14:24:49 <quicksilver> there are precisely two possible answers to P=NP
14:24:54 <quicksilver> it is not contradictory
14:25:02 <quicksilver> it is a valid statement of a well understood set theory
14:25:05 <esap> Toxaris: It means that it hasn't been defined exactly enough that it could be answered.
14:25:07 <mrd> meaningless usually refers to ill-defined or contradictory
14:25:20 <quicksilver> it is either True or False
14:25:20 <mrd> the latter case would make it trivial to "prove" however
14:25:26 <quicksilver> though certainly we may never know
14:25:31 <marceau> quicksilver: does there exist a proof that it is not undecidable?
14:25:34 <mrd> it can be unprovable
14:25:59 <newsham> what does it mean for a proposition to be undecidable?
14:26:04 <jonafan> does unprovable mean it's neither true or false?
14:26:07 <dmwit> marceau: Well, I'm sure there is a proof that is decidable, but I guess that's not what you meant.
14:26:13 <RayNbow> would P=NP if time travel would be relatively simple? :p
14:26:13 <mrd> well proof and truth are separate things
14:26:15 <jonafan> i don't think it does
14:26:17 <dmwit> jonafan: No, it just means we can't prove it one way or another.
14:26:26 <jonafan> right
14:26:28 <newsham> algorithms are decidable/undecidable.
14:26:31 <mrd> I like constructive logic, which means that true statements must have proofs
14:26:41 <mrd> no proof, no truth
14:26:42 <jonafan> so it's not true/false/unknown
14:26:46 <quicksilver> marceau: I didn't say it wasn't undecidable. I said it was either true or false.
14:26:48 <newsham> mrd: only truths expressable in that logic.
14:26:51 <jonafan> it's true/false and unknown
14:26:56 <marceau> dmwit: source?
14:27:04 <quicksilver> marceau: it may, indeed, be undecidable in particular formal systems
14:27:14 <quicksilver> or may be independent of the axioms of ZF
14:27:18 <quicksilver> but I very much doubt that
14:27:27 <marceau> qs: I understand, but has it been proven that it is decidable in a system that does not assume it as an axiom?
14:27:35 <quicksilver> good question.
14:27:39 <dmwit> marceau: How about the proof of "a and b implies a"?  There's only four possible values to try, it has to be decidable.
14:28:00 <newsham> dmwit: when you say "only four possibilities" you are assuming excluded-middle, no?
14:28:02 <mrd> with values you're introducing the idea of a model
14:28:08 <newsham> excluded-middle is not true in all logics
14:28:14 <dmwit> meh
14:28:21 <marceau> or in all categories
14:28:27 <dmwit> So, pick the logic where it does hold.
14:28:32 <newsham> heh
14:28:38 <dmwit> marceau is claiming that *no* proof is decidable.
14:28:46 <shapr> Can he prove that? =)
14:28:49 <marceau> haha
14:28:49 <dmwit> All you have to do is find one to disprove that claim. =)
14:29:21 <newsham> I'm confused to how decidability can apply to a proof.
14:29:28 <esap> It could be that P=NP depends on some powerful axiom (e.g. axiom of choice, existence of measurable cardinals etc.)
14:29:28 <newsham> decidability applies to algorithms right?
14:29:32 <dmwit> newsham: Me too.
14:29:40 <marceau> curry-howard
14:29:50 <Toxaris> is it meaningless to prove that there are no proofs?
14:29:55 <newsham> I understand curry-howard.. but wouldnt undecidability relate to properties of a proof?
14:29:57 <mrd> the question is: "Is there a proof of Foo?" the answer can be "Yes", "No" or '
14:29:59 <newsham> not the existence of a proof?
14:30:00 <mrd> "undecidable"
14:30:13 <sannysanoff> quicksilver, hi again, I am memory profiling my program, and in .hp files I get only few first samples, can I do something about it (i need 1 minute or profiling, get 2-10 secs only)
14:30:14 <mrd> proofs are programs in a constructive logic
14:30:37 <quicksilver> marceau: check the following link for a discussion of this which seems fairly good
14:30:45 <quicksilver> @go P=NP axioms of ZF
14:30:48 <lambdabot> http://www.scottaaronson.com/papers/pnp.pdf
14:30:53 <marceau> qs: thanks
14:30:58 <quicksilver> marceau: I only spent 5 minutes reading it
14:31:00 <mrd> that reminds me.  i think that guy is speaking here in an hour.
14:31:05 <quicksilver> but it is, indeed, a good question that you asked.
14:31:10 <esap> newsham: Undecidable means there is no algorithm that solves the problem. For example, the problem whether an arbitrary computer program given as input will ever terminate is undecidable.
14:31:38 <newsham> esap: right.  and we're not talkign about algorithms for solving an arbitrary class of problems
14:31:46 <mrd> then again there's also the xkcd guy
14:31:48 <newsham> such as "does machine M halt on input X" for all M,x
14:31:53 <hpaste>  mtp pasted "(no title)" at http://hpaste.org/3780
14:31:56 <quicksilver> esap: that's a computer scientist's definition of undecidable
14:32:09 <quicksilver> esap: if a mathematician uses the phrase he sometimes means something different
14:32:19 <quicksilver> "independent of the axioms of this formal theory"
14:32:23 <quicksilver> (normally ZF or ZFC)
14:32:41 <mtp> bos: around? I tried the newtype thing you suggested, and it doesn't seem to quite work.
14:32:48 <bos> mtp: oh?
14:33:01 <mtp> ie, i can't seem to Show it properly
14:33:03 <quicksilver> sannysanoff: I don't know much about profiling I'm afraid :(
14:33:12 <mtp> cf the paste I just sent
14:33:20 <sannysanoff> quicksilver, ;-(
14:33:33 <esap> quicksilver: right, though I'm not sure the term 'undecidable' is actually used for that purpose. I would say "independent of the axioms of ZFC" instead.
14:33:46 <sannysanoff> please help, I am memory profiling my program with ghc, and in .hp files I get only few first samples, can I do something about it (i need 1 minute or profiling, get 2-10 secs only)
14:34:03 <marceau> esap: it's generally what mathematicians mean when they say undecidable
14:34:08 <quicksilver> esap: yes, independent might be more popular. But undecidable is also used.
14:34:12 <quicksilver> esap: especially in context
14:34:17 <quicksilver> esap: "undecidable within PA"
14:34:19 <esap> quicksilver: ok
14:34:22 <quicksilver> "undecidable within ZF"
14:35:33 <hpaste>  bos annotated "(no title)" with "(no title)" at http://hpaste.org/3780#a1
14:35:40 <bos> mtp: there's your fix
14:35:45 <mtp> bos: ahh, thanks
14:36:10 <mtp> this haskell thing is slowly starting to make more and more sense, and i'm loving it <3
14:36:18 <bos> a newtype declaration gives you a constructor that you have to wrap/unwrap, just like a data declaration
14:36:58 * esap got to get some sleep....
14:38:12 <bos> any cabal hackers around?
14:39:59 <nominolo> *wave*
14:40:01 <TomM2> Now that I have a haskell.org account, where is the public directory for my darcs repo?
14:40:20 <bos> nominolo: turns out i was able to answer my own question, i think
14:40:22 <pgavin> TomM2: you got a haskell.org account?
14:40:25 <sjanssen> TomM2: code.haskell.org?
14:40:28 <TomM2> code.haskell.org
14:40:29 <TomM2> yes
14:40:30 <pgavin> ah
14:40:41 <sjanssen> TomM2: /srv/code/yourprojectname
14:41:03 <TomM2> Oh yes, I must choose a project name... hummm
14:41:15 <sw17ch_> so, after all the haskell hacking i've been doing... i've been taking stuff like lambdas for granted...
14:41:26 <shapr> sw17ch_: yeah?
14:41:28 <sw17ch_> so, when i have a C++ assignment... and i want a function local to one other function... i can't do it :(
14:41:47 * nominolo goes back to hibernation
14:41:48 <sjanssen> TomM2: you could also put it under ~/public_html/ if you don't want to request a project
14:41:58 <sw17ch_> i just want to define a function to be used 4 times in another function... and then have it vanish
14:42:04 <TomM2> sjanssen: that sounds good, thanks
14:42:05 * sw17ch_ is spoilt
14:42:49 <omnId> sw17ch_: you could give it a name and pass a function pointer, I guess.
14:43:36 <quicksilver> sw17ch_: g++ supports local functons
14:43:50 <sw17ch_> quicksilver: do tell
14:44:06 <bos> quicksilver: you're thinking of gcc, not g++
14:44:14 <bos> the c++ compiler doesn't implement that extension
14:44:22 <quicksilver> bos: really?
14:44:24 <quicksilver> oh, that's sad
14:44:26 <quicksilver> g++--
14:44:42 <bos> it's fine by me. local functions are a pain in the ass.
14:44:56 <omnId> @karma g++
14:44:56 <lambdabot> g++ has a karma of -1
14:45:20 <omnId> @karma g
14:45:20 <lambdabot> g has a karma of 18
14:45:28 <sw17ch_> @karma c
14:45:28 <lambdabot> c has a karma of 15
14:45:36 <sw17ch_> @karma d
14:45:37 <lambdabot> d has a karma of 0
14:45:40 <sw17ch_> poor d
14:45:50 <sw17ch_> @karma a
14:45:50 <lambdabot> a has a karma of 1
14:46:21 <bitwiseshiftleft> question: i'm trying to switch to 6.8.1, and i've just compiled HaXml, and it's telling me  Bad interface file: /home/software/lib/ghc-6.8.1/imports/HaXml/Text/XML/HaXml/Parse.hi
14:46:22 <bitwiseshiftleft>         Something is amiss; requested module  HaXml-1.13.2:Text.XML.HaXml.Parse differs from name found in the interface file HaXml:Text.XML.HaXml.Parse
14:46:24 <bos> gcc generates a trampoline on the fly to implement local functions, which is slow and fugly.
14:46:32 <sjanssen> we have a few exceptions for C, etc., should g be one of those exceptions too?
14:46:39 <bos> bitwiseshiftleft: did you clean out the old build?
14:46:47 <bitwiseshiftleft> bos: there was no old build
14:46:52 <sw17ch_> bos: and since this is a high performance computing project... that would be bad. (yes, i know it's c++, it's part of the assignment)
14:47:00 <bitwiseshiftleft> oh, you mean of my app.  yes
14:48:17 <bos> sw17ch_: in c++, the idiom would be to use function objects anyway. they're very verbose, though.
14:49:08 <sw17ch_> bos: i've never even heard of them :)
14:49:38 <bos> sw17ch_: enjoy your ignorance while it lasts
14:49:59 <shapr> Ignorance is bliss. But it never lasts!
14:52:04 <nominolo> @karma police
14:52:05 <lambdabot> police has a karma of 0
14:52:47 <sw17ch_> bos: hopefully the world grows up and drops all other languages for haskell
14:54:58 <dons> oh, i'd be happy with any pure, H-M typed functional language with type classes and monadic effects
14:55:09 <dons> doesn't have to be Haskell
14:55:12 <pgavin> sw17ch_: if that were possible we'd have world peace too
14:55:29 <pgavin> dons: but it *would* be haskell :)
14:55:44 <bitwiseshiftleft> i really think haskell could be a lot better with some standard library changes
14:55:44 <mtp> hmm
14:55:47 <dons> well, it could also be Timber, hmm, or Epigram
14:55:52 <shapr> bitwiseshiftleft: Like what?
14:56:02 <pgavin> dons: I was kidding :)
14:56:08 <Toxaris> dons: you don't require non-strictness?
14:56:13 <dons> nope :)
14:56:28 <dons> i write strict haskell most of the time anyway
14:56:46 <bitwiseshiftleft> shapr: better exceptions, better strings (6.8.1 is a start on that though), better file IO operations, that sort of thing
14:56:53 <shapr> Propose them!
14:57:03 <bitwiseshiftleft> most of them are proposed
14:57:16 <bitwiseshiftleft> oh, and IO being ST RealWorld again would be nice
14:57:58 <ski> fall-through `case's !
14:58:12 <pgavin> ski: eww :)
14:58:27 <bitwiseshiftleft> i'm not sure what that would even mean
14:58:35 <bitwiseshiftleft> since case's in haskell can bind variables
14:58:36 <Philippa_> bitwiseshiftleft: is stToIO really that big a burden?
14:58:46 <pgavin> bitwiseshiftleft: what benefit does IO being ST RealWorld give you?
14:58:56 <ski> pgavin : well, i'm not thinking exactly like `C's, if that's what you think ;)
14:59:02 <Adamant> what are some good resources that explain strictness in Haskell?
14:59:03 <bitwiseshiftleft> well, for one thing, it reduces by one the already fairly large number of ways to do references
14:59:12 <Lemmih> Oh, ghc-6.8.1 is out. I should release ppcore.
14:59:51 <pgavin> bitwiseshiftleft: ok, so how do you keep someone from doing realworld = runSt $ do someIOStuff
14:59:51 <Adamant> YAHT's coverage didn't really help me understand it very well.
15:00:07 <quicksilver> pgavin: the type of runSt forbits it
15:00:20 <pgavin> quicksilver: oh, right...
15:00:24 <quicksilver> pgavin: runST can only run things in forall s . ST s
15:00:41 <quicksilver> I'm not sure I see the benefit myself
15:00:49 <bitwiseshiftleft> mostly just cleanliness
15:00:57 <bitwiseshiftleft> why shouldn't IO be ST RealWorld
15:00:57 <quicksilver> I meant, in ghc IO is something very close to ST RealWorld#
15:01:03 <ski> pgavin : there was some example a newbie hpasted that i think could have benefitted by said feature
15:01:07 <quicksilver> but that's not the only way you can imagine implementing it
15:01:38 <Cale> http://hpaste.org/3673
15:01:40 <ddarius> Even the SPJ isn't all that keen on it.
15:01:47 <ddarius> I doubt Simon Marlow is either.
15:02:00 <Cale> That paste is something like how I envision IO
15:02:06 <quicksilver> right
15:02:20 <quicksilver> fully abstract
15:02:25 <quicksilver> that's the "free IO monad"
15:02:26 <dons> i think that's how swiert envisages it too :)
15:02:31 <quicksilver> over the primitives we have :)
15:02:38 <dons> Cale: you've read the beauty and the beast paper?
15:02:39 * ddarius would probably use continuations.
15:02:43 <Cale> dons: nope
15:02:45 <dons> oh!
15:03:04 <gwern> has anyone been able to build MissingH with the new cabal?
15:03:05 <quicksilver> bitwiseshiftleft: IORef and STref are both to be discouraged.
15:03:22 <hpaste>  Lokomersd pasted "seiko replacement watch band" at http://hpaste.org/3781
15:03:23 <bitwiseshiftleft> quicksilver: uh, why?
15:03:29 <quicksilver> because they're ugly
15:03:35 <ddarius> dons: The question and answer at the very end of Swierstra's talk is excellent.
15:03:36 <quicksilver> and encourage weak typing
15:03:41 <Cale> dons: why? Is it good?
15:03:44 <bitwiseshiftleft> maybe they need to be prettified instead of being discouraged
15:03:49 <dons> http://www.cs.nott.ac.uk/~txa/publ/beast.pdf
15:03:51 <bitwiseshiftleft> how do they encourage weak tying?
15:03:53 <bitwiseshiftleft> *typing?
15:03:57 <ddarius> Cale: I recommend the Haskell Workshop video.
15:04:01 <quicksilver> they encourage you to write IO ()
15:04:03 <Philippa_> ...how does STRef encourage weak typing? IORef I can understand because it encourages the "do it all in IO" pattern
15:04:07 <quicksilver> or IORef a -> IO ()
15:04:17 <ddarius> Cale: There is a perfect question with a perfect answer.
15:04:19 <quicksilver> instead of StateT a IO ()
15:04:41 <dons> Cale, data IO a = GetChar (Char -> IO a) | ........ | Return a
15:04:46 <quicksilver> Philippa_: same reason. STRef encourages you to lexically bind these weird 'reference' things and bind them in closures.
15:04:49 <hpaste>  sizur pasted "merge" at http://hpaste.org/3782
15:04:53 <dons> then they add file system and concurrency stuff
15:05:00 <quicksilver> Philippa_: instead of declaring in your types the state you use.
15:05:15 <dons> and mutable refs
15:05:18 <ddarius> quicksilver doesn't like existentials.
15:05:20 <Cale> dons: That's a little different from what I have, but interesting :)
15:05:32 <Philippa_> actually it tells you that the state I'm using is a heap. Occasionally it'd nice to be able to say the heap's monomorphic, but other than that, no
15:05:37 <quicksilver> as far as I understand it, the only advantage of them is that they might permit mutation.
15:05:40 <dons> Cale, well, an abstract, intepretable, QuickCheckable IO :)
15:05:46 <Cale> right
15:05:47 <quicksilver> Philippa_: yeah, that's good way of saying it
15:05:59 <quicksilver> Philippa_: I think those cases when you really need a heap are quite rare.
15:06:04 <Philippa_> right. Thing is, I tend to use them when the state I'm using is indeed a heap
15:06:08 <quicksilver> Philippa_: in those cases, sure, it's a good solution
15:06:22 <quicksilver> ddarius: ?
15:06:32 <Philippa_> I think it's a reasonable one when you're stitching together lots of pieces of state that want to get handed off into StateTs for some processes, too
15:06:35 <quicksilver> ddarius: I don't like unsafe lazy IO and I don't like overuse of references.
15:06:44 <quicksilver> ddarius: I quite like existentials though!
15:06:47 <Cale> That has  GetChar :: (Char -> IO a) -> IO a
15:06:57 <ski> quicksilver : passing around `STRef s a's is no different from passing around indices into lists/maps/arrays
15:06:59 <thetallguy> Mmmm... QuickCheckable IO
15:07:12 <quicksilver> (I don't like people using typeclasses when they should use explicity dictionaries)
15:07:12 <thetallguy> I'll have to read that in detail.  I'd passed it over first time.
15:07:14 <Cale> I suppose it doesn't require GADTs that way :)
15:07:25 <ddarius> quicksilver: I don't know how lazy IO got into this (/me wonders what safe lazy IO is), but with existentials I can hide the state I'm using.
15:07:47 <Philippa_> ski: almost. You can't grab the heap out of an ST computation at the end
15:07:59 <quicksilver> ski: which is a practice I would also discourage
15:08:12 <quicksilver> ski: I would recommend passing around the actual data, rather than a 'pointer' to it
15:08:20 <quicksilver> whether it be index, STRef or Map key
15:08:35 <Philippa_> yeah, that's not much help when I'm writing a typechecker
15:08:40 <quicksilver> I'm not saying tehre are *never* cases when they are right
15:08:48 <quicksilver> I'm saying that I think they get overused
15:08:56 <Philippa_> you're not bothering to qualify what kinds of cases you think might be justified either though
15:09:00 <bitwiseshiftleft> quicksilver: fair enough
15:09:02 <quicksilver> I agree with Philippa_ that, when you want a heap.
15:09:10 <quicksilver> Philippa_: Yes, I am, I'm agreeing with you.
15:09:13 <quicksilver> when you want a heap.
15:09:26 <quicksilver> and when the kind of heap which STRef gives you is the right sort, too.
15:09:30 <ski> quicksilver : if you can pass around the data itself in a natural way, then yes .. but i think there can be cases where you do want (some kind of) references
15:09:38 <quicksilver> ski: agreed.
15:09:44 <Philippa_> like when the references are part of the problem domain
15:10:07 <bitwiseshiftleft> or like, when you want to maintain an inherently stateful object
15:10:11 <ski> Philippa_ : *nod* (that's why i just said "passing around", and not anything about the actual use of the data ;)
15:10:23 <quicksilver> there are cases when the problem domain merits a more precise implementation of heap than the generic one STRefs give you too
15:10:32 <ddarius> bitwiseshiftleft: That doesn't require references.
15:10:34 <ski> or cyclic structures, with updates
15:10:38 <quicksilver> like you want to restrict newSTRef in some way.
15:10:48 <Philippa_> yeah. Usually what you want then is an ST wrapper though
15:11:03 <Philippa_> I've built that when I want a monomorphic heap plenty of times
15:11:18 <augustss> howdy!
15:11:24 <dons> hey augustss!
15:11:25 <quicksilver> I think what I'm trying to say
15:11:28 <ddarius> Philippa_: You should only need to build it once.
15:11:31 <quicksilver> badly as usual cos it's the end of the week
15:11:33 <Philippa_> 'lo augustss
15:11:35 <hpaste>  sizur annotated "merge" with "merge2" at http://hpaste.org/3782#a1
15:11:43 <quicksilver> is that STRef is a good model for a heap with new-reference semantics
15:11:43 <dons> augustss: great benchmarking article. we should do more of those.
15:11:44 <Philippa_> ddarius: it's so quick that sometimes I cba to find where I saved the last version
15:11:44 <augustss> dons: I'm only one state away from you :)
15:11:49 <thetallguy> augustss: aren't you in NYC?  Illegal to say howdy from there.
15:11:54 <dons> oh! hmm. south or east, I wonder :)
15:11:57 <quicksilver> it's a poor model for generically passing chunks of state around.
15:11:57 <dons> or north...
15:12:08 <ddarius> Philippa_: Yeah, I know.  I don't know how many Point/Vector/etc. classes I've implemented.
15:12:09 <thetallguy> D'oh!
15:12:16 <augustss> I'm in Idaho.  Howdy is not only legal, but mandatory.
15:12:21 <thetallguy> lol
15:12:27 <dons> oh, so that was going to be my last guess
15:12:32 <dons> :)
15:12:34 <thetallguy> fair enough
15:12:42 <ddarius> augustss: Why are you in Idaho?
15:13:00 <augustss> Visiting my wife's relatives (she's here too).
15:13:16 <dons> do we have any haskell programmers in Idaho?
15:13:21 <dons> other than augustss
15:13:23 <augustss> Got broadband installed just hours ago out here in nowhere.
15:13:34 <TomM2> How about ones from Idaho?
15:13:38 <thetallguy> let me guess: Couer de laine?
15:13:46 <TomM2> Couer d'Alene
15:13:50 <augustss> thetallguy: Elba
15:14:02 <augustss> Elba has about 25 people
15:14:03 <thetallguy> phew
15:14:13 <ddarius> All in-laws of you?
15:14:22 <thetallguy> So, she's a native then
15:14:24 <augustss> Some
15:14:41 <augustss> TomM2: where are you?
15:15:12 <thetallguy> Ah, just up the road from SLC, UT
15:15:15 <TomM2> Augustss: I am now on the East coast, but I was born and raised in CdA, ID.  I hope to get back to the Northwest reasonable soon.
15:15:29 <augustss> TomM2: oh, ok
15:15:36 <thetallguy> BTW, I second the motion on nice benchmarking article
15:15:39 <ddarius> TomM2: Where East Coast?
15:15:51 <augustss> thetallguy: just up the road, yep.  about 2 hours
15:16:02 <TomM2> ddarius: Just north of DC.
15:16:15 <thetallguy> Ah, thanks TomM2, I was just lookig up the spelling
15:16:24 <dons> shapr: see this, http://royal.pingdom.com/?p=212 ?
15:16:25 <lambdabot> Title: Royal Pingdom  The weirdest hardware you can find a web server on
15:16:33 <ddarius> TomM2: Should be a decent, if expensive, area.    I don't know as much about the Maryland side.
15:16:48 <augustss> I'll do another benchmark when I find another ridiculous claim about Haskell. :)
15:16:50 <dons> ghc 6.8 is getting rather good reviews
15:16:58 <Heffalump> it is indeed
15:17:05 <dons> i don't think i've seen such a response to a new release
15:17:07 <TomM2> ddarius: Seeing as I am used to CdA and small Idaho town, I don't like how you have to drive to get anywhere here.
15:17:22 <TomM2> dons: Blame pointer tagging :-)
15:17:27 <thetallguy> augustss: stepcut forwarded me some angry comments on your blog defending C++
15:17:32 <dons> no one cared when 6.6 got an smp runtime, for example :)
15:17:43 <dons> though they liked the bytestrings-in-base that came with 6.6
15:17:43 <thetallguy> augustss: very amusing.
15:18:06 <augustss> thetallguy: I'm waiting for the much improved C++ code :)
15:18:18 <Philippa_> dons: I didn't say anything but I liked the SMP runtime, I just wasn't doing anything with it
15:18:23 <dons> yeah, the C++ guys get really rattled.
15:18:27 <thetallguy> dons: I really liked the note from BlueSpec
15:18:28 <Philippa_> I'm liking the debugger a lot, it's saving me time already
15:18:43 <ddarius> Oh noes!
15:18:54 <thetallguy> augustss: Yeah, I bet you aren't holding your breath while you wait.
15:18:57 <dons> yeah. i should put out one saying galois's code is forfty percent faster, and 87% more beautiful with 6.8
15:19:11 <augustss> Now we need to get Krasimir to make a Visual Haskell for 6.8
15:19:27 <nominolo> hm, is there a link to that discussion/article?
15:19:33 * ski likes http://www.cs.chalmers.se/~augustss/pics/haskel.gif
15:19:38 <thetallguy> 87% more beautiful?  You'd need to give examples
15:20:02 <mrd> ghc 6.8 helped me lose 20 lbs!
15:20:11 <augustss> ski: yes, I think it's great!
15:20:19 <dons> http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
15:20:22 <lambdabot> Title: Things that amuse me, http://tinyurl.com/25sj6t
15:20:23 <dons> nominolo: ^
15:21:01 <augustss> But a lot of the comments were on reddit
15:21:56 <nominolo> thx
15:21:57 <augustss> Reddit has deteriorated.  There used to be 5 Haskell posts a day.
15:22:04 <augustss> dons must be slacking off.
15:22:10 <nominolo> heh
15:22:22 <thetallguy> Does anyone know of the equivalent of HaXml's DtdToHaskell, but for XSD Schema?
15:22:47 <nominolo> well, Xmonad ain't the New Thing anymore
15:22:58 <bitwiseshiftleft> speaking of HaXml, has anyone gotten it to install on 6.8.1?
15:23:30 <thetallguy> bitwiseshiftleft: haven't tried yet
15:23:36 <thetallguy> maybe in a few days
15:23:38 <Heffalump> build, or install?
15:23:49 <Heffalump> 1.13.2 builds fine on 6.8.1
15:23:55 <bitwiseshiftleft> Heffalump: actually, I can get it to build and install, but I can't compile with it
15:24:00 <Heffalump> I think it installs ok too, but I'm not certain about that.
15:24:07 <newsham> you look a lot like arithmetic shift left
15:24:11 <ski> augustss : (i may have asked about this before, but) is HBC available somewhere (seeing that the chalmers ftp server seems to be no more)
15:24:12 * Heffalump thinks more carefully; yes, it does.
15:24:13 <newsham> any relation?
15:24:17 <bitwiseshiftleft> i get Bad interface file, something is amiss, etc
15:24:29 <Heffalump> bad interface file implies you've built with the wrong compiler, generally.
15:24:34 <bitwiseshiftleft> newsham: arithmetic and logical shift left are the same
15:24:49 <Heffalump> bitwiseshiftleft: I think that's newsham's point.
15:24:54 <augustss> ski: hmmmm, I'm not sure
15:25:21 <bitwiseshiftleft> Heffalump: hmm
15:25:22 <augustss> ski: I only have it on a few of my machines myself
15:25:37 <bitwiseshiftleft> Heffalump: i used 6.8.1 to compile both
15:25:53 <dons> doesn't help that blogspot is blocked from reddit. http://programming.reddit.com/info/60938/details
15:25:54 <lambdabot> Title: programming: The pure, typed lambda calculus and Haskell : augustss.blogspot.com
15:25:58 <newsham> just my two bits.  carry on.
15:26:20 <dons> nominolo: oh, there's a big xmonad release coming up :)
15:26:31 <dons> but yeah, we need to find a new core system tool to do rewrite
15:26:53 <augustss> dons: I complained to the reddit gods about blogspot being blocked and they claimed it wasn't true
15:27:01 <dons> bah. its blocked.
15:27:24 <dons> i couldn't submit just then, for example
15:27:38 * nominolo is betting on Yi for the next haskell killer-app
15:27:40 <augustss> Have you complained to them?
15:27:56 <dons> nominolo: oh, man. needs developers and direction :)
15:27:57 <nominolo> though we need to get off the ground first,
15:28:00 <dons> yeah :)
15:28:02 <dons> augustss: nope.
15:28:02 * TomM2 is betting on a black horse
15:28:15 <nominolo> but jyp and I seem to share a very similar vision
15:28:19 <Nafai> Easy question....How do I append an item to a list?  Kind of the opposite of ::?
15:28:25 <newsham> does yi use curses or termcap yet?
15:28:25 <nominolo> so that's a start :)
15:28:26 <dons> nominolo: ok.good. that's important
15:28:27 <sjanssen> Nafai: xs ++ [x]
15:28:37 <dons> newsham: it has used both for a while, and gtk
15:28:56 <faxathisia> @pl reverse . reverse
15:28:56 <lambdabot> reverse . reverse
15:28:56 <newsham> i saw the gtk last i looked, but last i looked it was vty.  interesting.
15:28:57 <nominolo> i currently can't get it to work with either gtk or vty ;)
15:29:00 <Nafai> sjanssen: Thanks!
15:29:28 <Skyp> mrd: Hello ;) I am trying to fix up things from yesterday, and I am at the point you mentioned about constructs like = if ..., where I should use guards... I tried to search for that but I couldn't find sth. appropriate... do you have a simple example for me what you meant?
15:29:44 <dons> at least tinyurl works, we get downmods, http://programming.reddit.com/info/60938/details :)
15:29:45 <lambdabot> Title: programming: The pure, typed lambda calculus and Haskell : augustss.blogspot.com
15:30:14 <LoganCapaldo>  ooo new augustss post?
15:30:32 <nominolo> and so long ...
15:31:07 <byorgey> dons, nominolo: I might be interested in helping with Yi development, in about a month or so.
15:31:11 <augustss> dons: yeah, I don't get the tinyurl downmods, but there's no accounting for taste
15:31:23 <Heffalump> do people lose karma for downmods?
15:31:35 <nominolo> byorgey: any particular interests?
15:31:39 <LoganCapaldo> I wonder if you would get less downmods if you used the preview version of the tinyurl
15:32:01 <Heffalump> we could make a redirector for blogspot
15:32:04 <newsham> "id Int 5" ??  you can do that in ghc?
15:32:29 <augustss> Who says that's Haskell?
15:32:30 <idnar> > id Int 5
15:32:31 <lambdabot>   Not in scope: data constructor `Int'
15:32:32 <Heffalump> newsham: well, you could make Int into a data constructor by defining some type
15:32:36 <nominolo> newsham: no, the typecheckor does this for you
15:32:36 <Trinithis> Haskell's Circle > Pascal's Triangle
15:32:49 <newsham> he talks about using haskell syntax so I thought he was saying its haskell
15:32:51 <Heffalump> ah, explicit type params
15:33:06 <byorgey> nominolo: not really, I haven't really looked at it.  I just think it's a nifty idea and I'd like to help.
15:33:29 <augustss> newsham: It's the Haskell syntax for application :)
15:33:51 <nominolo> byorgey: ok, cool.  well, any help is appreciated.  just take a look at what we've got and pick something.
15:33:55 <newsham> but your own language/parser/evaluator
15:33:56 <LoganCapaldo> > id 5 :: Int -- you could do this in haskell...
15:33:57 <lambdabot>  5
15:34:09 <LoganCapaldo> I mean ghc
15:34:17 <byorgey> nominolo: yup, will do.
15:34:42 <mtp> hmm
15:34:58 <mtp> is there a way I can use certain pieces of Parsec.Token without using the whole LanguageDef stuff?
15:35:17 <mtp> I just want to use "number"
15:36:04 <Toxaris> mtp: you could use one of the predefined LanguageDef's
15:36:11 <ski> augustss : hm, now that i look around, i actually find `darcs get http://darcs.augustsson.net/Darcs/hbc' and `darcs get http://www.cse.unsw.edu.au/~dons/code/hbc' in my links file (so i had asked about it before) .. for some reason i hadn't gotten them, though
15:36:19 <mtp> Toxaris: I .. suppose
15:36:24 <LoganCapaldo> @hoogle number
15:36:25 <lambdabot> Network.PortNumber :: PortNumber -> PortID
15:36:25 <lambdabot> Network.PortNumber :: data PortNumber
15:36:25 <lambdabot> Network.BSD.getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
15:36:33 <augustss> ski: heh
15:36:57 <mtp> the whole makeTokenParser kind of scares me at the moment
15:37:14 <ddarius> mtp: Why?
15:37:15 <Lemmih> dons: What do you think: http://darcs.haskell.org/~lemmih/ppcore/Example.hs
15:37:21 <bitwiseshiftleft> so i think the HaXml thing is a version issue
15:37:38 <bitwiseshiftleft> like, cabal is not correctly annotating which version of the file it's installed
15:37:53 <bitwiseshiftleft> which is why the bad interface file thing comes up
15:38:12 <mtp> ddarius: i'm not quite sure how to make it work, is all :P
15:38:24 <nominolo> bitwiseshiftleft: hm. actually, it should
15:38:37 <nominolo> bitwiseshiftleft: do you overwrite some install path or something?
15:38:45 <mtp> oh..
15:38:54 <newsham> agust: is the "previous blog entry" you reference "simpler, easier" ?
15:39:03 <mtp> okay, i shouldn't read haskell docs at midnight after a full pot of tea.
15:39:19 <Lemmih> dons: Found out that 'divInt' isn't completely optimal while writing that example.
15:39:26 <Toxaris> mtp: there's an example at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#makeTokenParser wich is pretty clear
15:39:29 <lambdabot> http://tinyurl.com/2p5p89
15:40:02 <mtp> Toxaris: yeah, i just scrolled up in the page there and noticed how that worked
15:40:09 <faxathisia> I would like to have deriving TokenParser
15:40:09 <mtp> Forgive my n00bity. :)
15:40:24 <faxathisia> it should be possible with Template Haskell?
15:40:41 <EvilTerran> not literally, but the same effect can be achieved
15:40:48 <EvilTerran> you may find SYB easier, mind
15:40:48 <bitwiseshiftleft> nominolo: yes, i did overwrite the install path.  it's all installed in /home/software
15:41:01 <augustss> newsham: yes?
15:41:13 <augustss> newsham: I mean, yes.
15:41:15 <bitwiseshiftleft> nominolo: does that screw things up?
15:41:16 <newsham> danke
15:41:17 <faxathisia> What is SYB?
15:41:26 <nominolo> bitwiseshiftleft: does it create per-ghc-version subdirectories?
15:41:30 <Heffalump> scrap your boilerplate
15:41:31 <ski> @where syb
15:41:31 <lambdabot> http://www.cs.vu.nl/boilerplate
15:41:41 <nominolo> bitwiseshiftleft: or throw it all into one?
15:42:09 <bitwiseshiftleft> nominolo: it tosses it into ~/lib/ghc-6.8.1/imports/HaXml/Text/...
15:42:13 <faxathisia> oh wow
15:42:30 <newsham> aug: utf-8 lambdas would look perdy ;-)
15:42:39 <newsham> (and foralls)
15:43:03 <bitwiseshiftleft> newsham: and composition operator
15:43:08 <nominolo> bitwiseshiftleft: you can use certain wildcards
15:43:12 <EvilTerran> and most other operators
15:43:21 <nominolo> hm
15:43:21 <bitwiseshiftleft> nominolo: how so?
15:43:26 <nominolo> http://www.haskell.org/ghc/docs/latest/html/Cabal/builders.html#setup-configure-paths
15:43:28 <lambdabot> Title: 3. Building and installing a package, http://tinyurl.com/ox63q
15:43:34 <nominolo> er
15:43:39 <Lemmih> dons: Found out that 'divInt' isn't completely optimal while writing that example.
15:43:40 <nominolo> sorry, not wildcards
15:43:44 <EvilTerran> -> <- * => /= <= >= ...
15:43:46 <nominolo> "variables"
15:44:37 <bitwiseshiftleft> nominolo: ok, so like which of those 50 flags should I change?
15:45:08 <nominolo> good question.
15:47:33 <LoganCapaldo> augustss++
15:47:33 <bitwiseshiftleft> the exact error is     Bad interface file: /home/software/lib/ghc-6.8.1/imports/HaXml/Text/XML/HaXml/Parse.hi
15:47:33 <bitwiseshiftleft>         Something is amiss; requested module  HaXml-1.13.2:Text.XML.HaXml.Parse differs from name found in the interface file HaXml:Text.XML.HaXml.Parse
15:47:47 <augustss> newsham: yes.  You can add the Unicode chars.  It should take about 5 minutes. :)
15:48:01 <nominolo> bitwiseshiftleft: did you use: --prefix=/home/software ?
15:48:06 <bitwiseshiftleft> nominolo: yes
15:48:09 <nominolo> and nothing else?
15:48:18 <newsham> you are too kind :)
15:48:20 <bitwiseshiftleft> and --buildwith=ghc
15:48:41 <bitwiseshiftleft> ghc here is ghc-6.8.1, installed in /home/software
15:50:05 <nominolo> hm, it should put them into ~/lib/HaXml-1.13.2/ghc-6.8.1/
15:50:43 <dons> Lemmih: do you have QuickChecks for it?
15:50:54 <dons> :)
15:51:17 <dons> Lemmih: is the intent to replace the old one?
15:52:03 <Lemmih> dons: No, Yes.
15:52:04 <nominolo> bitwiseshiftleft: you can try and see the cabal output with -v3
15:52:07 <newsham> > exp pi - pi
15:52:09 <lambdabot>  19.999099979189474
15:52:14 <dons> Lemmih: i'll have a look at it some more.
15:52:43 <newsham> > 9**2 + 19**2/2
15:52:44 <lambdabot>  261.5
15:53:05 <newsham> > 9**2 + 19**2/22
15:53:06 <lambdabot>  97.4090909090909
15:53:33 <nominolo> > exp pi
15:53:35 <lambdabot>  23.140692632779267
15:53:49 <Lemmih> dons: The ghc path is currently hard-coded and it doesn't understand cabal files.
15:53:50 <bitwiseshiftleft> nominolo: where should i put the -v3
15:54:05 <nominolo> after runhaskell Setup.lhs configure
15:54:13 <newsham> > (9**2 + 19**2/22)**0.25
15:54:14 <dons> Lemmih: hmm?
15:54:15 <lambdabot>  3.1415926525826463
15:54:21 <nominolo> and install if you want
15:54:58 <augustss> > log (20 + pi) - pi
15:55:00 <lambdabot>  3.8892669412149417e-5
15:55:27 <newsham> > let i = (0 :+ 1) in exp (pi*i) - pi
15:55:28 <lambdabot>  (-4.141592653589793) :+ 1.2246063538223773e-16
15:55:37 <dons> Lemmih: so you want function do you want to reimplement? the 'div' method on Int?
15:55:38 <Lemmih> dons: It's not exactly ready for prime time use is what I'm trying to say.
15:55:49 <dons>     div     x@(I8# x#) y@(I8# y#)
15:55:49 <dons>         | y == 0                     = divZeroError
15:55:49 <dons>         | x == minBound && y == (-1) = overflowError
15:55:50 <dons>         | otherwise                  = I8# (narrow8Int# (x# `divInt#` y#))
15:55:55 <dons> is the one you want to replace?
15:56:02 <Lemmih> dons: Oh, right. Yes.
15:56:49 <dons> oh, on Int8 though?
15:56:57 <Lemmih> dons: On all ints.
15:56:58 <dons> oh,sorry.
15:57:43 <dons> and the change is to flip the order of the tests?
15:59:07 <bitwiseshiftleft> nominolo: huh.  so if i compile with runhaskell Setup.hs configure
15:59:07 <Lemmih> Yes, it depends on the implementation of '&&'. Not checking 'x' if 'y' is known is faster.
15:59:16 <bitwiseshiftleft> it works differently
15:59:29 <bitwiseshiftleft> if i build with runhaskell Setup.hs build, it complains:
15:59:30 <bitwiseshiftleft>     Could not find module `Text.PrettyPrint.HughesPJ':
15:59:30 <bitwiseshiftleft>       it is a member of package pretty-1.0.0.0, which is hidden
16:00:28 <dons> you need to add pretty as a dependency in the .cabal file
16:00:55 <nominolo> how did you install it before?
16:01:06 <bitwiseshiftleft> ./configure, make, make install
16:01:24 <Cale> I love how it's capable of detecting that pretty is a dependency, but not capable of adding it as a dependency for you. :)
16:01:36 <nominolo> hm.  maybe that picked up an old version of GHC (and thus cabal)?
16:01:51 <bitwiseshiftleft> nominolo: possibly
16:01:53 <nominolo> or, it's a separate built process
16:02:19 <bitwiseshiftleft> i think it's totally separate
16:02:26 <Cale> (of course, if it did, it would sometimes be wrong about it)
16:02:27 <nominolo> most Makefiles nowadays just call into Cabal
16:02:55 <nominolo> but Cabal can use autoconf
16:05:09 <bitwiseshiftleft> well, building now
16:05:18 <bitwiseshiftleft> let's see how long that takes
16:05:44 <augustss> Well, ghc 6.8.1 is out.  Time to use 6.9 then.
16:06:16 <bitwiseshiftleft> ding!
16:06:21 <bitwiseshiftleft> it works, thanks for the help
16:06:51 <dcoutts> @tell scodil ask me again about your gtk2hs build problems
16:06:51 <lambdabot> Consider it noted.
16:07:19 <nominolo> bitwiseshiftleft: in a while cabal-install should work nicely on most packages
16:07:27 <nominolo> bitwiseshiftleft: that's much nicer
16:09:12 <tehgeekmeister> how does one access ghci from the haskell mode in emacs?  or should i ask in #emacs?
16:09:36 <dons> Lemmih: just running it on maxBound tests
16:09:49 <dons> Lemmih: but I think we'd need real timing data
16:09:52 <TSC> tehgeekmeister: C-c C-l ?
16:09:56 <dons> since i get identical code in other tests
16:09:59 <TSC> That loads the current file into ghci
16:10:04 <nominolo> tehgeekmeister: C-c C-l
16:10:09 <dons> main = check defaultConfig {configMaxTest = maxBound :: Int} (\n m -> m /= 0 ==> n `newDiv` m == n `oldDiv` m)
16:10:10 <nominolo> and C-c C-b
16:10:12 <tehgeekmeister> okay
16:11:34 <Lemmih> dons: x && y  =  y && x, no? Screw quickcheck, let's prove correctness.
16:11:35 <dcoutts> Cale: actually when we have Cabal do proper dependency chasing it will be able to tell you exactly what deps you're missing (or if it's ambiguous tell you which packages you could pick)
16:11:43 <bitwiseshiftleft> wow, ghc-6.8.1 is like 5 hojillion times faster than ghc-6.6.1
16:11:51 <ddarius> Lemmih: No.
16:11:54 <Skyp> hm, is there a standard function to set the n-th element of a list to a certain value?
16:12:03 <Lemmih> ddarius: x and y are strict.
16:12:09 <ddarius> Skyp: No, because that would be stupid.
16:12:10 <Cale> dcoutts: yeah, that would be good :)
16:12:11 <dons> Lemmih: i get scared about the code generator
16:12:11 <ski> Skyp : wjy do you want that ?
16:12:12 <dcoutts> Cale: and from there we could do things like have cabal autogenerate you a basic .cabal file
16:12:18 <dons> when doing low levelish things
16:12:21 <ski> s/wjy/why/
16:12:28 <dcoutts> Cale: like dons's mkcabal, but more sophisticated
16:12:37 <byorgey> ddarius: hey, go easy =)
16:12:45 <itaiz> newb syntax question:
16:13:02 <dcoutts> Cale: or even do quick'n'dirty builds without any .cabal file at all, like ghc --make but with support for pre-processors and haddock etc
16:13:04 <itaiz> where can i find out what "class (Monad m) => MonadError e m | m -> e where ..." means?
16:13:07 <omnId> byorgey: he always seems to have a chip on his shoulder.
16:13:13 <Nafai> Okay.  Let's say I have [a] and (a -> Bool), is there a straightforward way of returning the first a from [a] that returns True from the function?
16:13:19 <Skyp> hm, why is this so stupid? I consider this a standard operation on lists ;)
16:13:20 <Cale> Skyp: the reason that you usually don't want to just modify the nth element of a list is that it is an O(n) operation
16:13:26 <itaiz> specifically, i'm unfamiliar with the "|" notation in the class declaration.
16:13:32 <TSC> Skyp: take n xs ++ [replacementElement] ++ drop (n+1) xs, but it's linear time
16:13:33 <byorgey> itaiz: the #haskell IRC channel is a good place =)
16:13:38 <Cale> You have to reconstruct the first n cons-cells of the list in order to do that.
16:13:40 <omnId> itaiz: functional dependencies
16:13:42 <byorgey> itaiz: that's a functional dependency.
16:13:47 <LoganCapaldo> @hoogle a -> Int -> [a] -> [a]
16:13:48 <lambdabot> No matches, try a more general search
16:14:09 <byorgey> itaiz: the | m -> e says that each concrete instance of m should uniquely determine a concrete instance of e.
16:14:14 <Cale> It's a more common operation on arrays, and it is explicitly supported there.
16:14:18 <ski> itaiz : http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
16:14:20 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
16:14:42 <Cale> Of course, you can write your own, but you should be aware of this if you're going to be doing lots of updates to a list like that.
16:14:48 <byorgey> itaiz: in other words, you shouldn't be able to have two different instances of MonadError with the same type for e but different types for m.
16:14:51 <dons> looks like QuickCheck has a space leak
16:14:53 <Toxaris> > find even [3, 5, 7, 8, 9. 10] -- Nafai
16:14:54 <lambdabot>   add an instance declaration for (Num (a -> b))
16:14:56 <Skyp> ok, thanks
16:15:01 <itaiz> excellent, thanks!
16:15:06 <Toxaris> > find even [3, 5, 7, 8, 9, 10] -- Nafai
16:15:07 <lambdabot>  Just 8
16:15:15 <Nafai> Toxaris: Thanks!
16:15:22 <omnId> @type 9. 10
16:15:23 <lambdabot> forall c a. (Num (b -> c), Num (a -> b)) => a -> c
16:15:35 <omnId> @index find
16:15:35 <lambdabot> Data.List
16:15:51 <Cale> [ if n == 4 then 'o' else x | (n,x) <- zip [0..] "Hellp" ]
16:15:52 <Cale> > [ if n == 4 then 'o' else x | (n,x) <- zip [0..] "Hellp" ]
16:15:54 <lambdabot>  "Hello"
16:15:57 <dons> oh, interesting memory is doubling in chunmks
16:16:21 <byorgey> itaiz: AIUI, functional dependencies will soon be deprecated when type families are fully implemented
16:16:39 <Cale> That's one convenient way to do it, but it's a bit more costly than necessary. The advantage is that generalisations of it are probably cheaper.
16:17:05 <Cale> Or at the very least easier to write.
16:17:32 <byorgey> more generally you can have something like mapWithIndex :: ((a,Int) -> b) -> [a] -> [b]
16:18:01 <Toxaris> > zipWith ($) (replicate 4 id ++ const 'o' ++ repeat id) "Hellp"
16:18:01 <lambdabot>  Couldn't match expected type `[a -> a]'
16:18:08 <Toxaris> > zipWith ($) (replicate 4 id ++ [const 'o'] ++ repeat id) "Hellp"
16:18:09 <lambdabot>  "Hello"
16:19:53 <LoganCapaldo> mapWithIndex :: (a -> Int -> b) -> [a] -> [b] ;)
16:20:27 <omnId> @type \f xs -> zipWith ($) f xs [0..]
16:20:28 <lambdabot>     Couldn't match expected type `[t1] -> t'
16:20:28 <lambdabot>            against inferred type `[b]'
16:20:28 <lambdabot>     In the expression: zipWith ($) f xs ([0 .. ])
16:20:34 <dons> yeah, space leak in QuickCheck1.
16:20:37 <dons> fixed in QC2
16:20:39 <omnId> @type \f xs -> zipWith f xs [0..]
16:20:40 <lambdabot> forall a b c. (Num b, Enum b) => (a -> b -> c) -> [a] -> [c]
16:20:51 <dons> its still a bit leaky, but not so bad. who wrote this code?
16:20:52 <omnId> @type \f xs -> zipWith f xs [0::Int..]
16:20:53 <lambdabot> parse error on input `Int..'
16:20:56 <omnId> @type \f xs -> zipWith f xs [(0::Int)..]
16:20:57 <lambdabot> forall a c. (a -> Int -> c) -> [a] -> [c]
16:21:02 <omnId> there
16:21:26 <byorgey> > let mapWithIndex f = map (uncurry f) . zipWith [0..] ; replace n x = mapWithIndex (\a ix -> if ix == n then x else a) in replace 4 'o' "Hellp"
16:21:27 <lambdabot>  Couldn't match expected type `a -> b -> c'
16:21:31 <omnId> @pl \f x y z -> f z x y
16:21:31 <lambdabot> (flip .) . flip
16:21:43 <ski> (!!<-) :: [a] -> Int -> (a -> a) -> [a]
16:22:54 <byorgey> ski: I like it =)
16:23:41 <ski>   update (Sudoku rows) (j,i) newCell = Sudoku $
16:23:41 <ski>     rows !!<- j $ \row     ->
16:23:41 <ski>     row  !!<- i $ \oldCell ->
16:23:41 <ski>     newCell
16:23:55 <omnId> ([1,2,3] !!<- 2) (*2) == [1,2,6]?
16:23:56 <ski> byorgey : i constructed it to be able to write that
16:24:06 <byorgey> ski: I see, sweet
16:24:07 <ski> omnId : *nod*
16:25:01 <ddarius> With rebindable syntax...
16:25:35 <dons> QC2 is a lot slower.
16:26:36 <wintereagle> @help
16:26:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:26:45 <wintereagle> @list
16:26:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:27:24 <omnId> wintereagle: lambdabot also listens to /msgs if you want to explore
16:28:08 <omnId> @@ @@ @read @run brainghc
16:28:09 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
16:28:20 <ski> (for some reason, though, the TA didn't like my continuation-based looping and collection combinators)
16:28:48 <augustss> @figlet hello?
16:28:48 <lambdabot> Couldn't run the figlet command.
16:29:25 <augustss> @fresh
16:29:25 <lambdabot> Han
16:29:29 <ski> istr figlet was removed
16:29:35 <augustss> @fresh
16:29:35 <lambdabot> Hao
16:29:45 <augustss> And what did figlet do?
16:29:59 <Toxaris> > let sequenceA = foldr (\x y -> (:) <$> x <*> y) (pure []) in sequenceA ["ab", "cd"]
16:30:00 <lambdabot> Terminated
16:30:03 <ski> http://www.figlet.org/
16:30:04 <lambdabot> Title: FIGlet - hosted by PLiG
16:30:10 <faxathisia> What is the date that he Curry-Howard isomorphism has been first published?
16:30:13 <ski> augustss : something like that
16:31:32 <Toxaris> > let sequenceA = foldr (\x y -> (:) <$> x <*> y) (pure []) in sequenceA ["ab", "cd"] -- works at home :(
16:31:33 <lambdabot> Terminated
16:31:39 <shachaf> pure is coming from Arrow.
16:31:43 <omnId> heh, seems it would be a noisy plugin
16:31:43 <shachaf> (And there's a liftA2.)
16:31:47 <ski> Prelude Control.Applicative> let sequenceA = foldr (\x y -> (:) <$> x <*> y) (pure []) in sequenceA ["ab", "cd"]
16:31:50 <ski> ["ac","ad","bc","bd"]
16:32:14 <ski> pure :: (Applicative f) => a -> f a
16:32:14 <shachaf> > let sequenceA = foldr (liftA2 (:)) (Control.Applicative.pure []) in sequenceA ["ab", "cd"]
16:32:16 <lambdabot>  ["ac","ad","bc","bd"]
16:32:24 <ski> ah :)
16:32:25 <shachaf> @ty Control.Arow.Pure
16:32:26 <omnId> > let seq = foldr (liftA2 (:)) (Control.Applicative.pure []) in seq ["ab","cd"]
16:32:27 <lambdabot>  ["ac","ad","bc","bd"]
16:32:28 <lambdabot> Couldn't find qualified module.
16:32:29 <shachaf> @ty Control.Arrow.Pure
16:32:30 <lambdabot>     Not in scope: data constructor `Control.Arrow.Pure'
16:32:36 <omnId> shachaf: jinx!
16:32:41 <ski> shachaf : one more time
16:32:51 <shachaf> @ty Control.Arrow.pure -- :-)
16:32:53 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
16:33:23 <ski> (`pure' could be called `liftA0')
16:33:47 <omnId> and liftA2 could be called amap2
16:33:55 <Toxaris> ok, so my question is: is there a module with functions like sequenceA, like the various little helpers in Control.Monad?
16:34:00 <shachaf> omnId: Or just map2?
16:34:07 <Nafai> I'm trying to figure out Maybe
16:34:21 <ski> omnId : or possibly 'zipWith'
16:34:21 <shachaf> omnId: map2 could be either zipWith or liftA2, I guess.
16:34:46 <shachaf> Toxaris: Ideally, those would be in Control.Applicative. :-)
16:35:12 <Nafai> How do I get a out from something that returns "Maybe a"
16:35:14 <dons> Lemmih: ok, no failures so far, looks like the code gen is ok. but testing boundary cases would be useful.
16:35:17 <dons> http://galois.com/~dons/tmp/Div.hs
16:35:20 <ski> Nafai : `case'
16:35:23 <omnId> > liftA2 (+) [1,2] [3,4,5] -- liftA2 in [] doesn't seem to do anything particularly zippy to me.
16:35:25 <lambdabot>  [4,5,6,5,6,7]
16:35:28 <dons> Lemmih: what you really need to do is show some timing data and instructions generated
16:35:34 <shachaf> omnId: See ZipList.
16:35:49 <omnId> shachaf: yes I know
16:36:05 <ski> > case lookup 3 [(0,'a'),(3,'b'),(2,'c')] of Nothing -> "nope"; Just c -> c:[]
16:36:06 <lambdabot>  "b"
16:36:07 <omnId> shachaf: just seems an odd name choice for it.
16:36:20 <byorgey> Nafai: the most straightforward way is to do a pattern match (either in a function argument, or case statement)
16:36:38 <ski> omnId : that's the list idiom, you want the ziplist idiom
16:37:04 * Nafai looks
16:37:08 <omnId> ski: yes, so why would zipWith be a good name for liftA2?
16:37:09 <shachaf> omnId: ski was saying that zipWith could possibly be called amap2, maybe?
16:37:38 <byorgey> > liftA2 (+) (ZipList [1,2]) (ZipList [3,4,5])
16:37:38 <lambdabot>   add an instance declaration for (Show (ZipList a))
16:37:54 <shachaf> > getZipList $ liftA2 (+) (ZipList [1,2]) (ZipList [3,4,5])
16:37:56 <lambdabot>  [4,6]
16:38:01 <ski> shachaf : i was saying `liftA2' could maybe be called `zipWith'
16:38:02 <omnId> oh, the other way 'round
16:38:04 <Toxaris> shachaf: I take this as "no, write them yourself". but i disagree, in my opinion: ideally, class Applicative f => Monad f, and one set of functions would be enough
16:38:14 <shachaf> ski: Oh.
16:38:19 <shachaf> Toxaris: Yes, that's what I was saying.
16:38:35 <shachaf> Toxaris: sequence and friends would be only in Control.Applicative.
16:38:58 <omnId> @type Data.Foldable.sequence
16:39:00 <lambdabot> Not in scope: `Data.Foldable.sequence'
16:39:07 <Toxaris> shachaf: oh I see, so ideally, we wouldn't disagree
16:39:11 <ski> shachaf : reason was just that when i read `map2', i'm thinking of a zipping map (c.f. `map' in scheme)
16:39:39 <shachaf> Data.Foldable just has sequence_ and sequenceA_.
16:40:03 <shachaf> ski: Yes. But liftA2 shouldn't be called zipWith.
16:40:25 <shachaf> @ty Data.Traversable.sequence
16:40:27 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
16:41:03 <omnId> could that be restricted to Applicative?
16:41:21 <ski> @type Data.Traversable.sequenceA
16:41:22 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
16:41:29 <hpaste>  Lemmih pasted "Faster 'div'" at http://hpaste.org/3783
16:41:36 <omnId> I suppose so :)
16:41:38 <gwern> dons: quickCheckWith in darcs quickcheck?
16:41:44 <ski> `Data.Traversable.sequence' is just convenience for monads which haven't been declared idioms, i suppose
16:41:49 <dons> gwern: yep
16:41:57 <dons> code.haskell.org/QuickCheck
16:41:58 <Toxaris> oh cool, so basically I want Data.Traversable.sequenceA?
16:45:15 * gwern wonders if there's a reason there are so many warnings when compiling darcs quickcheck. did 6.8 come with many new warnings or something?
16:45:33 <dons> its fine. i just turned on -Wall
16:45:37 <dons> previously we didn't use -Wall
16:45:49 <Lemmih> dons: I'm not sure it's actually faster.
16:46:38 <LoganCapaldo> > sequence [[1, 2, 3], [4,5]]
16:46:40 <lambdabot>  [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
16:47:31 <Toxaris> now that I'm looking at Data.Traversable, I realize that I want traverse :)
16:47:35 <gwern> dons: would it be a waste of time to go through and fix some warnings?
16:48:04 <dons> nope
16:48:10 <dons> it would be useful
16:49:23 <gwern> that's interesting. quickcheck has no provisions for parallelism? grepping doesn't seem to turn up anything
16:49:44 <gwern> (I find this odd because it seems to me that testing pure functions should be embarassingly parallel)
16:52:00 <byorgey> gwern: well, generating the arbitrary test data takes place within a generator monad that threads through state for the RNG...
16:52:23 <byorgey> but I guess you could test multiple different functions in parallel
16:53:23 <gwern> byorgey: ok, so have the generator produce an infinite list; 'take n' from the list, map a function over the returned list that forks and returns True or False; then fold 'and' into the list
16:53:44 <gwern> I'm far from any sort of expert like those who wrote quickcheck, but it seems pretty straightforward
16:53:49 <shachaf> @ty all -- gwern?
16:53:49 <ikegami--> gwern: Hello, and sorry for my mistake about your reply
16:53:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:53:54 <shachaf> Oops.
16:53:58 <EvilTerran> @src all
16:53:58 <lambdabot> all p =  and . map p
16:53:59 * shachaf misread, sorry.
16:54:06 <byorgey> gwern: yeah, it seems like that would work.
16:54:10 <ski> byorgey : actually, the RNG seed is not state-threaded though, but split and passed pnly downwards
16:54:11 <gwern> ikegami--: what? which mistake was that?
16:54:25 <ikegami--> gwern: about flymake-mode on emacs
16:54:37 <gwern> oh. thought I recognized that name
16:54:47 <gwern> ikegami--: incidentally, did the regexp changes to the wiki work?
16:55:10 <gwern> I figured they would since haskell-mode suggests using them, iirc, but emacs always worries me because stuff can not work so easily...
16:55:11 <ikegami--> gwern: yes, I changed many times
16:55:12 <ski> (byorgey : see the monad instance of `Gen' at <http://www.cs.chalmers.se/~rjmh/QuickCheck/QuickCheck.hs>)
16:55:58 <salierix> If I have a program with lots of state, do I just pack everything in a new data type and use the State monad or is there a better way?
16:56:30 <byorgey> ski: ah, you're right.  your point being that you don't have to sequence the tests, as long as you generate all the split seeds in a list first?  or something like that?
16:56:44 <ski> @index split
16:56:44 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
16:56:51 <ski> @type System.Random.split
16:56:53 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
16:56:56 <byorgey> salierix: that sounds like a good way to me.
16:57:02 <kpreid> salierix: check out the ST monad, too
16:57:06 <ski> byorgey : you split once for each `(>>=)'
16:57:21 <byorgey> ski: right.
16:57:29 <gwern> @pl foo x y = I# (x `divInt#` y)
16:57:30 <lambdabot> (line 1, column 9):
16:57:30 <lambdabot> unexpected "="
16:57:30 <lambdabot> expecting variable, "(", operator or end of input
16:57:35 <ski> (so i don't see where any list comes into this)
16:57:38 <salierix> kpreid, what does ST do?
16:58:05 <kpreid> salierix: it lets you have mutable variables within a region of your program
16:58:29 <salierix> kpreid, how is that different than State?
16:58:30 <ski> salierix : it gives you a way of dynamically allocating new pieces of state, of any type, giving you an index/reference byy which you can use it inside the monad
16:58:37 <gwern> @pl foo x y = I (divInt x y)
16:58:37 <lambdabot> foo = (I .) . divInt
16:58:39 <kpreid> salierix: so if your mutations are of a shape that doesn't pack nicely into a single state value, it's useful
16:59:02 <ski> `State' is for a fixed state type
16:59:04 <kpreid> salierix: State gives you *one* state variable; ST gives you many which you can pass around
16:59:11 * dmwit wishes for a Set monad
16:59:23 <ski> `ST' is for dynamically allocating new pieces of state as you go along
16:59:37 <dmwit> instance Eq a where x == y = False -- degenerate to the non-determinism monad if there's no current Eq instance
17:00:38 <salierix> Sounds useful... are there any examples on how to use ST?
17:01:09 <ski> (you could dynamically allocate state pieces with `State' by having e.g. a list/tree/map that you extend dynamically .. however i don't think one can get new pieces of state of arbitrary types this way)
17:02:13 <dmwit> > negate False
17:02:16 <lambdabot>   add an instance declaration for (Num Bool)
17:02:16 <lambdabot>     In the expression: negate Fa...
17:02:34 <byorgey> dmwit: have you looked at http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros ?
17:02:36 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
17:02:59 <ski> salierix : <http://www.haskell.org/haskellwiki/Monad/ST> seems to say a little
17:03:36 <dmwit> Yeah, but it's a lot to include in a very small test program. =)
17:03:47 <byorgey> dmwit: fair enough =)
17:06:37 <gwern> Lemmih: what flags did you use to get http://hpaste.org/3783 ?
17:07:50 <Lemmih> gwern: ppcore + -O2 -fglasgow-exts.
17:07:56 <LoganCapaldo> I was trying to think of a way to get an unsafeCoerce dealy that would just add class contexts but I don't think that would fly since by the time you did that yo couldn't figure out what dictionary you needed (I think)
17:08:10 <mtp> argh
17:08:53 <mtp> I'm going to have to entirely redo how I handle whitespace because of using the makeTokenParser parsers :/
17:09:11 <gwern> ppcore? that's a new one on me
17:09:53 * gwern wonders if it's really necessary in 'y == (-1) && x == minBound' to check y is -1
17:16:49 <dmwit> Whoops, ReaderT b [] and ListT (Reader b) are the same thing.
17:17:10 <dmwit> I want a monad that reads from a non-deterministic environment... is this possible?
17:17:10 <augustss> Whoops?
17:17:13 <twb> Is there a dedicated yi channel?
17:17:14 * dmwit thinks for a second
17:18:40 <Beelsebob> dmwit: IO may or may not do that depending on if you believe in quantom theory or not
17:18:42 <Beelsebob> :P
17:18:54 <dmwit> Beelsebob: Wrong environment. =)
17:19:06 <gwern> twb: if there is, I'd yell at'em to get it to work with 6.8 :)
17:20:10 <gwern> (to be fair, Eval.hs errors out on something to do with regexs, so it might be library problems and not actually ghc)
17:20:29 <Toxaris> dmwit: do you want a choice point everytime the environment is asked?
17:20:40 <dmwit> yep
17:20:47 <twb> gwern: that's alleged on the homepage
17:21:28 <twb> Anyway, I wanted to report that `yi .' shows the directory, by `yi -f gtk .' shows it "twice", i.e. two copies of the listing one after the other
17:21:40 <twb> Also it's hella slow to boot
17:21:45 <mtp> bleh
17:21:54 <mtp> Can I override a function in another module, ruby style?
17:22:02 <Toxaris> dmwit: then i would try ReaderT [Env] [a]
17:22:18 <LoganCapaldo> @type Prelude.lookup
17:22:19 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:22:19 <dmwit> Toxaris: Thanks, that's what I'll do.
17:22:26 <LoganCapaldo> @type M.lookup
17:22:26 <gwern> 'it's now possible to change any part of the Yi codebase and see the result with a mere 'M-x reconfigE' (take that, Steve Yegge :))' <-- heh. I bet most people have no idea what that's talking about
17:22:26 <Toxaris> dmwit: and using a custom ask action
17:22:27 <lambdabot> Couldn't find qualified module.
17:22:35 <LoganCapaldo> @type Data.Map.lookup
17:22:36 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
17:22:44 <gwern> twb: I think that might be because of the architecture
17:22:53 <twb> gwern: you mean AMD64?
17:23:25 <gwern> twb: no, the recompile strategy it and xmonad use for configuring and modifying dynamically
17:23:31 <twb> gwern: OK
17:23:56 <byorgey> mtp: sure, just do something like: import Foo hiding (bar) ... bar = blah blah...
17:24:03 <gwern> xmonad always struck me as being very fast to load up even with the recompile architecture, so it just might be Yi is older and not as well written? dunno
17:24:11 <mtp> byorgey: that doesn't work for things that it doesn't export :)
17:24:22 * gwern can't install or use yi >.< so this is sorta hearsay
17:24:28 <mtp> I want to override parsec's lexeme with one that doesn't call whiteSpace. :P
17:24:32 <Toxaris> dmwit: like myask = head . lift ask (not sure about lift here)
17:24:51 <twb> Also, large (5MB) files seem to take a looong time to open
17:24:54 <Toxaris> dmwit: normally, ask would have type [[Env]] and always returning a singleton list
17:25:16 <byorgey> mtp: so lexeme isn't actually exported by parsec, it's just used internally?
17:25:24 <mtp> byorgey: yeah :P
17:25:32 <mtp> actually, wait, I think I found the non-lexeme version of what I wanted..
17:25:39 <byorgey> mtp: oh.  yeah, that's not really possible, unfortunately...
17:25:43 <byorgey> mtp: oh good!
17:25:58 <Cale> gwern: What is that talking about?
17:26:04 <Toxaris> dmwit: by head you get non-deterministically returned single Env instead
17:26:22 <Cale> gwern: Did Yegge write something about Haskell not allowing for hot-pluggable code?
17:26:56 <twb> Cale: it's a pretty safe bet
17:27:01 <twb> Yegge writes lots of things
17:27:23 <gwern> Cale: he wrote a long post about how he liked dynamic languages best because they allowed for organic growth and extension and uptimes of years and years and that static typing even advanced static typing struck him as creating intricate clockwork mechanisms that were brittle and would crash
17:27:31 <gwern> (to summarize briefly)
17:27:42 <Toxaris> mtp: you could try calling makeTokenParser with a LanguageDef wich defines everything as non-Whitespace
17:28:06 <mtp> Toxaris: i'm using it so I don't have to parse numbers myself
17:28:21 <mtp> and it looks like it doesn't export "int", which is the non-lexeme "integer"
17:28:30 <Cale> I never really understood why people are so crazy about his writing.
17:29:08 <ivanm> he writes the occasional good articles
17:29:45 <mtp> wrt "hot-pluggable" -- oh, well, i'm not going to _expect_ it to work like that, i was just.. hoping, i guess :)
17:30:36 <gwern> Cale: his articles were very good for the time
17:30:54 <gwern> I mean, back in 99 or whenever he started posting, who else were you going to read?
17:31:01 <Toxaris> mtp: I just looked it up and realised that you can't define what's whitespace and what's not. too bad.
17:31:11 <mtp> I guess I could just yank the bits out of the file and include them in my code. :)
17:31:19 <Cale> Paul Graham also seems to write really long-winded articles which could be summarized much more briefly, and people love it. Maybe there's a trick to that.
17:32:20 <twb> Cale: only silly people listen to pg
17:32:38 <faxathisia> He writes really bad books about lisp :P
17:32:47 <faxathisia> I read two they are awful
17:32:50 <twb> esr and joel whatshisname are other examples
17:33:07 <gwern> (these days, anyway...)
17:33:21 <twb> I liked _On Lisp_, but it should have been called _Dirty Things I Did With Macros_
17:33:23 <gwern> esr hasn't been taken srsly in ages
17:33:28 <faxathisia> twb: haha
17:33:44 <mtp> twb: that's what I've seen it referred to as, actually :P
17:33:48 <twb> gwern: hehe, he's fixing vc.el in Emacs' CVS so it supports distributed changeset SCMs
17:34:56 <gwern> twb: ...what? isn't vc.el really hardwired for centralized RCSs?
17:35:03 <twb> gwern: currently, yes
17:35:15 <gwern> (for that matter, shouldn't he be working somewhere? I thought his stocks turned out to be worthless)
17:35:42 <twb> Who cares?
17:36:57 <gwern> 'where' clauses are lexically scoped, right, with the innermost definition of x taking precedence?
17:37:12 <dmwit> Cool, you really can make all possible three-input boolean functions out of a demuxer and a few not gates!
17:37:18 * dmwit does a jig
17:37:22 <shapr> Hey, I just had an interesting idea. A Haskell coding contest where the top three entries are not viewable, but all the lower scored entries are viewable. Score would be determined by combination of performance and source length.
17:37:28 <ddarius> Spolsky
17:38:01 <Cale> Why not just make all the entries viewable?
17:38:03 <shapr> I think that would encourage creative solutions because contestants would have to guess what the top entries are doing.
17:38:08 <Cale> hmm
17:38:26 <shapr> Sort of like simulated annealing on a social level.
17:38:32 <twb> It would sound like cronyism to me
17:38:36 <dmwit> Oh, so even incomplete solutions would be visible?
17:38:40 <twb> "Jim won, but we won't tell you WHY"
17:38:54 <shapr> twb: If an entry gets knocked out of the top three, it's visible.
17:38:56 <tehgeekmeister> is there a function to find nth roots in the prelude (or standard libraries)?
17:39:02 <dmwit> twb: I think the competition would be ongoing.
17:39:06 <ddarius> tehgeekmeister: **
17:39:10 <LoganCapaldo> I don't know that everyone wouldn't end up clustering around soln. #4
17:39:17 <shapr> twb: And the scoring wouldn't be done by humans, the scoring algorithm would be documented.
17:39:17 <twb> I strongly support full disclosure
17:39:25 <tehgeekmeister> ddarius: roots?  isn't that exponentiation?
17:39:32 <mtp> Hmm
17:39:32 <Cale> > 2**(1/2)
17:39:33 <ddarius> tehgeekmeister: Yes it is.
17:39:34 <lambdabot>  1.4142135623730951
17:39:39 <mtp> that appears to not have been my problem.
17:39:42 <shapr> twb: Yeah, but that often leads to iterations of one solution rather than new approaches.
17:39:42 <Cale> > 2**(1/3)
17:39:42 <tehgeekmeister> oh, right.
17:39:43 <lambdabot>  1.2599210498948732
17:39:48 <tehgeekmeister> i forgot about that.
17:39:54 <twb> Apart from anything else, open processes make things easier -- no copy protection, no acls, no proof of identity...
17:40:16 <twb> shapr: that would be why we're all still using a first-priciples sorting algorithm?
17:40:18 <dmwit> shapr: At first I was with you, but the more I think about it, the less I agree.
17:40:20 <shapr> twb: How would you encourage creative aproaches rather than iterations?
17:40:27 <shapr> dmwit: Why so?
17:40:37 <twb> You're not encouraging creative approaches
17:40:49 <twb> You're simply discouraging incremental improvement
17:40:56 <twb> By hiding information.
17:40:58 <dmwit> If there is a really revolutionary approach that steals the top place, people won't bother doing that one anymore.  They'll know they can't beat that approach without coming up with something even more radical.
17:41:03 <shapr> You could incrementally improve the lower-scoring approaches.
17:41:29 <dmwit> (Just a guess, and I don't have any psychology data to back it up.)
17:41:31 <shapr> dmwit: Ok, what if scores and memory and allocation profiles were available?
17:41:44 <twb> I just don't see how it would HELP anyone to hide information.
17:42:04 <twb> You're going to end up with contestants re-inventing the hidden algorithm instead of improving on it
17:42:17 <shapr> In that case, then it won't be hidden.
17:42:30 <twb> Only if 3 people reinvent it
17:42:42 <twb> Then the fourth one would be un-hidden, by your proposed rule
17:43:19 <shapr> I think that memory and allocation profiles would give enough clues to somewhat recreate a solution.
17:43:25 <shapr> I think it'd be a fun puzzle approach.
17:44:05 <shapr> Cale: What do you think?
17:44:14 <shapr> I have two nays so far :-)
17:44:43 <shapr> Anyone else have an opinion?
17:44:45 <twb> I should point out that my opinions aren't worth much.
17:44:56 <shapr> twb: The same could be said of mine...
17:45:13 <Cale> Well, it might be interesting, but if I was building something like that, I'd probably just make everything completely open.
17:45:45 <shapr> You don't think that would encourage purely iterative improvments?
17:46:10 <ddarius> It really doesn't matter.
17:46:30 <ddarius> If enough people participate, not everyone is just going to try to make a better version of the best version.
17:46:30 <Cale> Well, if someone could find a non-iterative improvement, they might be able to do much better.
17:46:39 <shapr> ddarius: That's true.
17:46:44 <gwern> shapr: if you want to encourage a variety of designs, encourage a variety of designs, don't try to approximate it
17:46:54 <shapr> gwern: Yeah, that's a good point.
17:47:06 <shapr> But how?
17:47:06 <gwern> do something like include a score for 'dffierence' from other entries
17:47:14 <gwern> the more different it is from a high-ranked entry, the more points
17:47:35 <shapr> How would you quantify that?
17:47:40 <gwern> shapr: well, offhand I'd say go with something like an edit or hamming distance based on the Core representations
17:48:05 <gwern> (so that way people couldn't do stuff like point or de-point everything even though they compile down to the same thing)
17:48:40 <shapr> Hm, that would work.. just add the hamming distances from the top three entries.
17:49:28 <shapr> But that would affect which entries are the top three.. I wonder if you'd need the hamming distance from all other entries?
17:50:01 <Toxaris> would that mean that your entry is scored worse if I choose to duplicate it?
17:50:10 <shapr> Yeah, it would. hm
17:50:19 <gwern> you could, but I'm not sure it's necessary to include the worst ones - I mean, if you can take a really bad one and improve it slightly to make it competitive with the best, than you should get points for that
17:50:37 <Toxaris> gwern: that's interesting
17:50:45 <gwern> Toxaris: perhaps take the uniqueness at the time of submission, so it isn't transitive
17:50:50 * ddarius doesn't know what is wrong with incremental improvement.
17:51:06 <shapr> ddarius: Nothing's wrong with it, I was just trying to think of other approaches.
17:51:21 <LoganCapaldo> incremental isn't as dramatic as a sudden breakthrough. That's what's wrong with incremental improvement :)
17:51:28 <gwern> ie, I submit novel design a, scoring 20 points for uniqueness, and you submit design b, copied from me, and B is compared with A (but A's uniqueness score is readonly) and gets 1 or 2 points, say
17:51:41 <dons> augustss: oh I hadn't seen jdh's comment at the end of your blog!
17:51:44 <ddarius> LoganCapaldo: When is drama a good thing outside of Mexican soap operas?
17:51:49 <dons> "ur results agree for your legacy system. On my 64-bit machine, you Haskell is almost twice as fast as the current implementations and shorter to boot. That makes Haskell much more competitive!"
17:51:50 <gwern> I'm not sure how you'd do revisions though... say you submit A', that would get compared to A and B...
17:52:26 <dmwit> dons: Oh, cool!
17:52:48 <dons> against ocaml and C++. yay augustss , yay ghc 6.8
17:53:05 <shapr> gwern: Sounds like it'd get too complicated.
17:53:17 <TomM2> Good news! The latest pureMD5 just benchmarked at 2.9 to 3.5x the speed of md5sum (it varies, but hey, I'm running stuff).
17:53:18 <shapr> Perhaps the simple full-disclosure approach is best.
17:53:23 <dons> awesome TomM2 !
17:53:27 <dons> i just got your mail.
17:53:39 <dons> so I'm pretty happy with that for an initial effort.
17:53:40 <shapr> Now I just need a 6.8.1 deb so I can set this up on my server.
17:53:58 <dons> shapr: did you see my 'weird webserver' link earlier today?
17:54:10 <TomM2> dons: Let me know if you have any ideas.  I'd be happy to do some tweaking, but don't know what I'd do from here.
17:54:18 <dons> yeah, time to read core and asm :)
17:54:27 <shapr> dons: The tiny serial port pluggy?
17:54:28 <gwern> shapr: complicated idea
17:54:28 <dons> and thing about the cost of various ops
17:54:31 <dons> shapr: yeah, et al
17:54:39 <TomM2> Sounds like a plan
17:54:49 <shapr> dons: They missed one, there's a tiny linux system that's the size of an Ethernet plug.
17:54:57 <shapr> Though I don't remember what it's called.
17:55:05 <hpaste>  dmwit pasted "any comments on style/approach?" at http://hpaste.org/3784
17:55:20 <shapr> dons: Nah, cost of various ops?
17:55:29 * dmwit risks exposing his code to the critical eyes of #haskell
17:55:49 <sjanssen> dmwit: ahh, it's horrible!
17:55:55 <sjanssen> ze goggles, zey do notzing!
17:55:56 <ac> whenever I'm making a tree widget, I can never figure out what to call the plus/minus thingies... can't call it an expander because it unexpands too
17:55:59 <sjanssen> :P
17:56:02 <dmwit> hahhaha
17:56:22 <dmwit> Aww, shucks, I even commented... =P
17:56:30 <gwern> dmwit: that's terrible. be an hero: murder/suicide
17:56:33 <shapr> dons: Ah, augustss' post?
17:56:46 <ac> what the shell should I call them?
17:56:56 <LoganCapaldo> a toggle?
17:57:15 <ac> LoganCapaldo: that's so unspecific. "toggle" could toggle anything
17:57:29 <LoganCapaldo> plus/minus thingy?
17:57:38 <LoganCapaldo> expansion toggle?
17:57:44 <ac> yeah, vis_toggler
17:57:46 <shapr> dons: Ok, what post about the cost of various ops?
17:57:47 <TomM2> Just don't call it a monad!
17:57:49 <dmwit> ac: curtan
17:57:49 <gwern> dons: I've been meaning to ask you about http://galois.com/~dons/tmp/Div.hs
17:57:52 <dmwit> +i
17:58:08 <sjanssen> dmwit: I like replicateM 3 [True, False] :)
17:58:20 <augustss> dons: yeah, jdh made a small admission about Haskell.  Unprecedented!
17:58:22 <dmwit> sjanssen: Yeah, I got it from you. =)
17:58:33 <astrolabe> shapr: How about a time delay before the code is disclosed?  Gives a reward of time at the top for the effort of inovation.
17:58:39 <gwern> dons: in '        | y == (-1) && x == minBound = overflowError', is the == -1 really necessary? I've had two quickchecks running for like an hour now testing what happens when you remove that check, and I haven't seen any errors yet
17:58:40 <faxathisia> > replicateM 3 [True, False]
17:58:42 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
17:59:00 <shapr> astrolabe: Hm, that might work.
17:59:55 <ddarius> dmwit: Why not just use nub?
17:59:57 <Toxaris> dmwit: I would consider x, y :: T bad style
18:00:42 <ddarius> augustss: It does imply that he might not be completely crazy.
18:00:49 <dmwit> ddarius: I don't know, I thought it might be marginally faster this way.
18:00:53 <dmwit> Toxaris: Hmm, okay.
18:01:16 <dmwit> > 8 ^ 6 -- number of entries in the list
18:01:18 <lambdabot>  262144
18:01:29 <ddarius> dmwit: It is faster, but probably not worth the bother.
18:01:37 <dmwit> ok
18:01:39 <Toxaris> > 1 -- number of times this program is run
18:01:40 <lambdabot>  1
18:01:44 <dmwit> heh
18:01:56 <dmwit> true
18:02:27 <sjanssen> it's not like "map head . group . sort" is incredibly taxing to type
18:02:28 <ddarius> dmwit: I don't "see why you wanted something short"
18:02:47 <faxathisia> :t map head . group . sort
18:02:48 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:03:28 <ddarius> sjanssen: I'm less concerned about the typing.
18:03:54 <sjanssen> gwern: yes, the y == (-1) check is needed
18:04:28 <sjanssen> gwern: remove it, then compare "newDiv minBound 1" with oldDiv
18:05:28 <sjanssen> > (minBound, maxBound) :: (Int, Int)
18:05:29 <lambdabot>  (-2147483648,2147483647)
18:05:37 <sjanssen> gwern: ^^^ is why that is necessary
18:06:35 <gwern> hm. -9223372036854775808 versus an arithmetic exception. I guess that is different then
18:09:11 <sorear> augustss++
18:51:53 <hpaste>  dfranke pasted "This is fugly" at http://hpaste.org/3785
18:51:55 <dfranke> ^^^ Am I losing my mind, or did it used to be possible to create multiple named records with field names in common as long as their type was the same, instead of resorting to this crap?
18:53:12 <Korollary> I think you can have two labels with the same type as part of two alternatives for the same data type.
18:53:36 <dfranke> ah, maybe that's what I'm thinking of.
18:55:01 <byorgey> dfranke: GHC 6.8.1 now supports what you want, I think: http://haskell.org/ghc/docs/6.8.1/html/users_guide/syntax-extns.html#disambiguate-fields
18:55:02 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/28aqkn
18:55:47 <dfranke> byorgey: no, I looked at that... that only works for resolving conflicts between unqualified names imported from different modules.
18:56:29 <byorgey> dfranke: ok, then I guess I don't understand exactly what you want
18:56:52 <dfranke> byorgey: that, without the "different modules" part.
18:57:56 <byorgey> dfranke: ah, ok.  really, it only works if the records are in different modules?  weird.
18:58:10 <dfranke> so I can write data Foo = Foo { a :: Int, b :: Int} ; data Bar = Bar { a :: Int, b :: Int}, and get out an ad-hoc typeclass with a and b as methods.
18:59:02 <Cale> huh...
18:59:04 <Cale> GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
18:59:04 <Cale> Loading package base ... linking ... done.
18:59:04 <Cale> foo.hs:
18:59:04 <Cale>     unknown flags in  {-# OPTIONS #-} pragma: -fdisambiguate-record-fields
18:59:05 <lambdabot> Title: The Glasgow Haskell Compiler
18:59:06 <byorgey> dfranke: but that would still be less general than a typeclass, since you couldn't e.g. write a function which would work on either Foo or Bar.
18:59:40 <dfranke> Cale: yeah, I noticed that the other day.  I was meaning to report it as a bug.
18:59:43 <byorgey> the disambiguation only works if you're constructing/pattern matching on an explicit data constructor.
19:00:08 <Cale> It also fails when passed as a commandline option. Does the thing just not exist?
19:00:18 <dfranke> it does not.  The -X version does exist.
19:00:41 <Cale> -XDisambiguateRecordFields then?
19:00:44 <dfranke> yup
19:01:06 <byorgey> ...which makes sense given the switch from -f to -X for language options.  guess the documentation is wrong.
19:01:08 <Cale> It also only seems to work if the two datatypes are declared in separate modules.
19:01:33 <Korollary> yeah it's all about namespace resolution
19:01:34 <byorgey> Cale: yes, that was dfranke's point.  I don't see any reason why that should be the case, do you?
19:01:49 <byorgey> hm, ok, wait, I see
19:02:02 <byorgey> maybe... I think =)
19:02:09 <Cale> Yeah, I can see why it's the case, however it's possible that they should try harder to work around that.
19:02:22 <byorgey> ok, right =)
19:02:31 <Cale> It's that the disambiguation is really just qualifying some names automatically.
19:03:05 <byorgey> although personally I don't see that much use for doing it with data types in the same module.
19:03:22 <dfranke> maybe the Right Thing is just to implement the ad-hoc typeclass creation in TH.
19:03:23 <Cale> dfranke's example is all right
19:05:43 <Cale> What we *really* need though are proper records.
19:05:54 <Cale> That is, some kind of row polymorphism.
19:06:27 <Cale> Personally, I'm a fan of Daan's proposal, semantics-wise.
19:06:52 <Cale> The syntax he uses is kinda bad though.
19:07:54 <dfranke> FWIW, this is one of the two things that made me dislike OCaml.
19:08:22 <dfranke> and without typeclasses I wasn't even able to do the hack that I pasted.
19:09:05 <dfranke> (the other was absence of generic arithmetic)
19:10:46 <Cale> I think maybe the biggest sticking point in adding records to Haskell is what syntax to use for record selection.
19:11:29 <dfranke> is there something so terrible about foo.bar?
19:11:34 <Cale> yes
19:11:52 <Cale> It's highly overloaded as it is and looks like function composition.
19:12:11 <Cale> Maybe foo{bar} would work
19:12:16 <Korollary> once we all edit in unicode, this all will go away
19:12:41 <Cale> Keyboards will probably not grow several hundred more keys anytime soon.
19:12:48 <dfranke> I put unicode characters in comments a lot.
19:12:56 <dfranke> I'm not usually sadisitic enough to put them in identifiers.
19:12:58 <dfranke> usually.
19:13:14 <Brian`> hello
19:13:15 <Cale> I can type the composition ring in a few keystrokes, and yet I'd still prefer to type .
19:13:18 <ricky_clarkson> dons: Are you posting tinyurls to reddit to get around the ban on posting blogspot links?  Has reddit said anything about that?
19:14:14 <Cale> With SCIM turned on, it's just \ci followed by a space.
19:14:17 <dfranke> I like emacs's TeX input method.
19:14:33 <Brian`> what's so special about emacs's TeX input method?
19:14:46 <Cale> Yeah, SCIM is like that but with wider scope.
19:15:12 <Cale> (that \ci is a disambiguating prefix of \circ)
19:16:19 <dfranke> I can't wait for emacs 23, though.  Then I'll be able to use a decent font that has all the glyphs I want.
19:16:56 <Cale> My emacs uses FreeType, I think.
19:17:10 <dfranke> you must be using a snapshot then.
19:17:17 <Cale> yes
19:17:50 <Cale> There's a repository for ubuntu packages of it.
19:17:52 <dfranke> maybe I should check it out again.  I tried a CVS version about a year ago but it was crashy.
19:18:23 <Cale> I'm not completely sure if it's crashy, as I haven't used emacs much lately.
19:18:46 <Cale> But it didn't crash in the few times I've used it since I installed it.
19:19:05 <dfranke> wha?  Do you use something different for editing Haskell?
19:19:17 <Cale> I mostly use vim.
19:19:38 <dfranke> oif
19:19:39 <Cale> Sometimes I'll use emacs if I'm editing something for a long time.
19:19:54 <dfranke> I emacs for any edit larger than two lines.
19:20:08 <dfranke> for tiny stuff I'll use vim.
19:20:37 <dfranke> unless I'm on a system where I don't have my emacs customizations and vi isn't vim.  Then I use ed :-)
19:21:12 <Cale> I wish emacs was customisable in a sane language.
19:21:25 <dfranke> what's so insane about elisp?
19:21:26 <goalieca> how do i "and" two integers in haskell
19:21:29 <Cale> Or vim, for that matter.
19:21:34 <Cale> It's dynamically scoped.
19:21:35 <byorgey> Cale: hear, hear!
19:22:04 <dfranke> goalieca: what do you mean?  as in bitwise and?
19:22:05 <byorgey> goalieca: bitwise?  use (.&.) from Data.Bits
19:22:19 <goalieca> ya. ty
19:23:01 <dfranke> eh, I've never done anything sufficiently complex that it mattered.
19:23:25 <dfranke> I've written a couple modes but they've pretty much consisted of library calls and not much else.
19:23:52 <dfranke> well, I guess RPAL mode was a little more than that.
19:24:00 <dfranke> but it still didn't matter.
19:24:42 <byorgey> this is why we need to work on Yi.
19:26:12 <sorear> what's really wrong with elisp?  does dynamic scoping actually hurt you?
19:26:43 <thetallguy> yes
19:30:30 <gwern> sorear: plus, the core isn't very good. the analysis (for optimizations and warnings and that sort of thing), speed, maintainability and all that stuff is pretty bad. rms has long wanted to redo it in guile, but I think the failure of every attempt to rewrite emacs has somewhat deterred him from really doing much
19:30:45 <gwern> I suspect guile's general lack of success hasn't helped :)
19:32:56 <dfranke> guile isn't exactly any sort of speed demon.
19:34:03 <dfranke> mostly because it's a pure interpreter.  No bytecode.
19:34:15 <davidL> why does lambdabot.cabal.plugins have fps as a dependency? I thought that was in base
19:34:35 <allbery_m> there should be a separate .cabal for 6.6+
19:34:47 <allbery_m> the default .cabal is for 6.4
19:35:20 <davidL> the readme says to use labdabot.cabal.plugins if you want to evaluate expressions such as > 2 + 2
19:35:25 <allbery_m> (and I suspect .cabal.plugins wasn't updated because for a long time hs-plugins didn't work on anything later than 6.4)
19:36:53 <davidL> will it be able to evaluate expressions with the normal cabal build?
19:36:58 <sorear> yes
19:37:12 <sorear> .plugins is for @load @unload @reload
19:37:25 <sorear> which haven't worked for as long as I can remember
19:37:31 <sorear> davidL: sounds like you are trying to use the hopelessly obsolete hackage version
19:37:42 <davidL> no this is a darcs version
19:37:56 <allbery_m> which darcs?
19:37:58 <davidL> http://code.haskell.org/lambdabot/
19:38:00 <lambdabot> Title: Index of /lambdabot
19:38:05 <sorear> davidL: also, I highly don't recommend trying to build lambdabot, it isn't fun.  You can use /msg if you don't want to bug the channel
19:38:06 <ddarius> @version
19:38:06 <lambdabot> lambdabot 4p575, GHC 6.6 (Linux i686 2.66GHz)
19:38:06 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:38:45 <davidL> who will I /msg?
19:38:58 <allbery_m> lambdabot
19:39:02 <sorear> lambdabot!
19:39:14 <sorear>  /msg lambdabot > 1 + 1
19:39:24 <allbery_m> so you can use LB without annoying the channel
19:39:34 <davidL> ohh, yeah I knew that
19:39:50 <allbery_m> (this is especially convenient if your irc client creates tabs for messages)
19:40:02 <sorear> goa doesn't work either, so if that's why you were trying...
19:56:55 <davidL> I was able to build lambdabot, but whenever I try to do > 2 + 3 I get: <lambdabot> Plugin `eval' failed with: Data.ByteString.last: empty ByteString
19:57:33 <Cale> davidL: That usually means runplugs either isn't built properly, or isn't where lambdabot is looking for it.
19:59:26 <davidL> I see scripts/RunPlugs.hs
20:00:04 <Cale> Look in dist/ for a binary
20:00:44 <davidL> yeah it's in there
20:00:51 <Cale> Run it and type 1 + 1
20:00:59 <Cale> and see if it works
20:01:25 <davidL> Failed to load interface for `ShowQ':
20:01:49 <Cale> hmm
20:02:46 <Cale> Honestly, that module isn't so useful. I always just ended up removing the import of that from the RunPlugs.hs code
20:03:04 <Cale> extras   = ["ShowQ","ShowFun","L","LargeWord"]
20:03:07 <Cale> replace with
20:03:17 <Cale> extras   = []
20:03:47 <davidL> and run ./build again?
20:03:52 <Cale> yeah
20:04:50 <Cale> I'm not completely sure what's needed to get those imports to work, as I don't know what's in the module path.
20:05:10 <Cale> (dons would be a better person for help with this)
20:06:16 <davidL> runplugs: /usr/local/lib/ghc/HSbase.o: unknown symbol `memcpy'
20:06:17 <davidL> runplugs: user error (resolvedObjs failed.)
20:06:22 <davidL> :-[
20:06:35 <Cale> Which version of GHC are you running, btw?
20:06:41 <davidL> 6.6.1
20:06:45 <Cale> oh, hmm...
20:07:50 <Cale> I'm not sure what that message would mean.
20:08:58 <davidL> could it be because I'm running amd64?
20:09:26 <Cale> I don't know. I think hs-plugins is usually reasonably portable.
20:09:49 <Cale> dons: You around?
20:09:57 <Cale> @seen dons
20:09:58 <lambdabot> dons is in #ghc, #xmonad and #haskell. I last heard dons speak 2h 15m 26s ago.
20:15:48 <glguy> Nafai: foldl1 lcm
20:16:01 <Nafai> Yes
20:16:09 <glguy> I was just reading through the pastes
20:16:12 <Nafai> Heh :)
20:16:23 <Nafai> I'm trying to understand how that works :)
20:17:48 <byorgey> Nafai: you might find this helpful: http://haskell.org/haskellwiki/Fold
20:17:49 <lambdabot> Title: Fold - HaskellWiki
20:18:41 * Nafai reads
20:23:55 <davidL> err, I accidently unregistered cabal-1.1.6.2, how can I register it again?
20:30:15 <byorgey> ghc-pkg register
20:31:18 <davidL> I couldn't find where the old cabal was to I just downloaded it
20:40:05 <dfranke> Alright, this is starting to get on my nerves...
20:40:23 <dfranke> The prefix "unsafe" ought to be reserved for functions capable of causing a segfault.
20:40:33 <dfranke> Not for this:
20:40:39 <dfranke> A variety of head for non-empty ByteStrings. unsafeHead omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.
20:40:55 <dfranke> If that's unsafe, then (/) ought to be named unsafeDivide.
20:41:37 <sorear> dfranke: unsafeHead can cause a segfault
20:41:42 <goalieca> @src zipWithM
20:41:42 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
20:42:05 <dfranke> sorear: eep, really?
20:42:24 <goalieca> @src zipWith3
20:42:25 <lambdabot> Source not found. My brain just exploded
20:42:34 <sorear> dfranke: really.  BS.head [] throws an exception, BS.unsafeHead [] crashes or returns garbage
20:42:47 <dfranke> hrmph.  Alright.
20:42:58 <sorear> unsafeHead just does data[0] without checking if the data pointer points to any data
20:43:21 <sorear> in all realistic situations my money is on 'silently returns garbage', but segfaults aren't impossible
20:44:32 * dfranke seeks out another target for his wrath...
20:45:33 * joed hands dfranke income tax and single moms without support
20:46:16 <dfranke> http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Coll.html#v%3AunsafeInsertMin
20:46:18 <lambdabot> http://tinyurl.com/yqhl6z
20:51:34 <dmwit> ?where happs
20:51:35 <lambdabot> http://happs.org
21:02:19 <goalieca> @zipWith
21:02:20 <lambdabot> Unknown command, try @list
21:02:28 <goalieca> @src zipWith
21:02:28 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:02:28 <lambdabot> zipWith _ _      _      = []
21:04:59 <twb> In yi, can one customize the modeline colour?  That cyan is really annoying.
21:07:34 <sorear> People use yi!?
21:07:37 <sorear> @seen jyp
21:07:37 <lambdabot> I saw jyp leaving #xmonad and #haskell 24d 8h 42m 7s ago, and .
21:27:15 <Bacta> I suppose I better start studying for Haskell now
21:27:45 <goalieca> whoah. this is freaky: a.out: thread blocked indefinitely
21:27:53 <goalieca> does that mean it found a deadlock!?
21:28:06 <byorgey> Bacta: that would be wise.  you want to be sure you're ready when the revolution comes.
21:28:11 <Bacta> yep and your OS is using the Ostrich algorithm
21:28:53 <Bacta> byorgey: I like functional languages but I doubt they will unseat OO languages anytime soon
21:29:41 <byorgey> Bacta: I was mostly joking, it's just that your statement sounded funny out of the blue =)
21:29:58 <Bacta> yeah :P
21:30:06 <Bacta> It's for my programming languages exam on Wednesday
21:30:14 <Bacta> I have to study for compiler construction, prolog and haskell
21:31:03 <joed> Well, you have ample time to put out an objective statement then.
21:32:49 <Bacta> I do like it more than Prolog
21:32:52 <Bacta> Prolog is a bitch :(
21:35:32 <byorgey> Bacta: well, feel free to ask questions here of course =)
21:35:45 <Nafai> Hrm
21:37:51 <Cale> Bacta: Don't be too sure. The imperative OO languages don't really have anywhere close to as reasonable a solution to concurrency.
21:38:47 <Nafai> So I want to iterate through a list, looking at each element and the four after it, I'm not quite sure of the way to do this
21:39:02 <Cale> tails first
21:39:05 <Cale> then map :)
21:39:22 <Cale> > map (take 4) . tails $ [1..10]
21:39:24 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
21:39:38 <Cale> er, maybe you want take 5 :)
21:39:49 <Nafai> Interesting
21:40:14 <Nafai> @index tails
21:40:14 <lambdabot> Data.List
21:40:24 <augustss> @src tails
21:40:24 <lambdabot> tails []         = [[]]
21:40:24 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
21:48:35 <Nafai> Wow
21:48:41 <Nafai> The Haskell is really starting to flow for me
21:49:08 <Nafai> Mind you, I'm not dealing with Monads yet :)
21:49:36 <Nafai> Time for bed
21:49:48 <byorgey> night Nafai
22:18:26 <dfranke> Is there a way to get haddock to generate hyperlinks to haskell.org docs for types from the standard library?
22:36:28 <chadz> zn.ak.
22:38:53 <user317> does loch work with ghc 6.8.1?
22:39:04 <user317> i keep getting Debug.Trace.Location.failure instead of a stacktrace
22:41:18 <sjanssen> user317: ping dons, he may know
22:46:14 <puusorsa> @pl  (\a b -> a:b:[])
22:46:14 <lambdabot> (. return) . (:)
22:53:59 <NuBeowulf> > sum x [] = ]
22:54:00 <lambdabot>  Parse error at "=" (column 10)
22:54:07 <NuBeowulf> > sum x ]
22:54:07 <lambdabot>  Parse error at "]" (column 7)
22:54:19 <NuBeowulf> > sum x [] = []
22:54:19 <lambdabot>  Parse error at "=" (column 10)
22:54:24 <dfranke> thestarslookdown: you just made something explode in my brain.  I had just started Ar Hyd Y Nos as you joined the channel.
22:54:33 <dfranke> started humming*
22:55:13 <Cale> NuBeowulf: if you're trying to declare the function sum, that's not quite what lambdabot is looking for there
22:55:55 <Cale> NuBeowulf: You can use @let to make declarations in lambdabot, but unless I'm mistaken, the whole declaration of the function has to be put together on one line. (Hmm... I might be wrong about that.)
22:56:02 <Cale> @let f [] = 0
22:56:05 <lambdabot> Defined.
22:56:10 <NuBeowulf> ok, thanks
22:56:12 <Cale> @let f (x:xs) = 1 + f xs
22:56:15 <lambdabot> Defined.
22:56:18 <Cale> > f [1,2,3]
22:56:20 <lambdabot>  3
22:56:23 <Cale> oh, cool :)
22:56:43 <lekro> > f []
22:56:44 <lambdabot>  0
22:56:45 <NuBeowulf> cute lamdabot
22:56:53 <Porges> > f [1..]
22:56:57 <lambdabot> Terminated
22:58:56 <dfranke> @let f = f
22:58:56 <lambdabot> <local>:5:0:     Equations for `f' have different numbers of arguments       ...
23:03:13 <ddarius> My understanding of let is it just sticks the stuff in the file.
23:05:20 <user317> does forkIO consider a blocked hGetContents a yield?
23:05:48 <sjanssen> user317: yes, the thread manager handles blocking IO correctly
23:10:15 <NuBeowulf> @let sum x [] = 0
23:10:24 <lambdabot> Defined.
23:10:43 <NuBeowulf> @let sum x:xs = x + sum xs
23:10:43 <lambdabot>  Parse error in pattern
23:11:15 <NuBeowulf> @let sum (x:xs) = x + sum xs
23:11:16 <lambdabot> <local>:8:17:     Ambiguous occurrence `sum'     It could refer to either `su...
23:11:48 <NuBeowulf> hmm, ambiguous occurrence
23:12:15 <Porges> sum is in the prelude already
23:13:05 <ari> > sum [1..5]
23:13:06 <lambdabot> Terminated
23:13:18 * ari scratches head
23:13:21 <ari> @undefine sum
23:13:23 <lambdabot> Undefined.
23:13:26 <ari> > sum [1..5]
23:13:27 <lambdabot>  15
23:14:17 <Cale> @let sum' [] = 0
23:14:18 <lambdabot> Defined.
23:14:24 <NuBeowulf> will all functions definded by us been kept permanently?
23:14:24 <Cale> @let sum' (x:xs) = x + sum' xs
23:14:26 <lambdabot> Defined.
23:14:31 <Cale> > sum' [1..10]
23:14:32 <lambdabot>  55
23:14:37 <NuBeowulf> ok
23:14:49 <Cale> no, they get cleared out by @undefine
23:14:56 <Cale> @undefine
23:14:58 <lambdabot> Undefined.
23:15:01 <Olathe> Nooo !
23:15:03 <Olathe> My functions !
23:15:09 <Olathe> ;)
23:15:15 <NuBeowulf> ha
23:15:51 <Cale> > undefined
23:15:52 <lambdabot>  Undefined
23:16:25 <Porges> @let times n action = return ()
23:16:27 <lambdabot> Defined.
23:16:35 <NuBeowulf> the "undefine" command means to clear all functions?
23:16:46 <Porges> @undefine times
23:16:48 <lambdabot> Undefined.
23:16:57 <Porges> @poke lambdabot
23:16:57 <lambdabot> Maybe you meant: more vote
23:19:41 <Olathe> @let a = 5
23:19:45 <lambdabot> Defined.
23:19:46 <Olathe> @let b = 6
23:19:48 <lambdabot> Defined.
23:19:48 <Olathe> > [a, b]
23:19:50 <lambdabot>  [5,6]
23:19:54 <Olathe> @undefine a
23:19:56 <lambdabot> Undefined.
23:19:57 <Olathe> > b
23:19:58 <lambdabot>   Not in scope: `b'
23:20:10 <Olathe> It undefines everything.
23:23:37 <Porges> @request-feature
23:23:37 <lambdabot> Unknown command, try @list
23:24:23 <NuBeowulf> so someone ruins your functions just recently
23:25:25 <Olathe> Me ?
23:26:15 <NuBeowulf> errrrrrr....... ignore it
23:34:37 <falconair> i'm reading about comonads and the signature of 'coreturn' is given as "w a->a" and an example is given as "hGetChar' :: OI Handle -> Char" ...
23:34:39 <falconair>  i thought the whole point of keeping values from the environment in IO monad was to keep the 'toxic' parts of a program separate from pure parts, doesn't coreturn mix up toxic and pure parts?
23:36:17 <Cale> falconair: yes, that system is completely broken.
23:36:49 <falconair> Cale, you mean comonads can't be safely used in haskell?
23:36:54 <Cale> Unless you want to go so far as to split the world every time a value gets duplicated.
23:37:04 <Cale> IO just isn't a comonad.
23:37:31 <Cale> (since you can't practically have arbitrarily many tty's, filesystems, etc.
23:37:31 <Cale> )
23:37:33 <falconair> right, I was comparing what I have read about IO to what I am now reading about OI
23:38:31 <falconair> so comonads imply arbitrarily many tty's and filesystems (where as monads reference a 'single' world)?
23:38:37 <Cale> yeah
23:39:21 <Cale> Because you can extract a value from an OI, then go on and do some other stuff, and then extract from that same OI again.
23:39:30 <Cale> and they had better give the same result
23:40:28 <falconair> ...so in a single world model, once you extract something from OI, it should no longer be extractable...but the ability to do it many times means many worlds ... is that the idea?
23:40:45 <Cale> Yeah
23:41:35 <Cale> you shouldn't really have access to that OI anymore once it's used up, but you still do.
23:41:36 <Cale>         comain :: OI a -> ()
23:41:36 <Cale>         comain w
23:41:36 <Cale>             = coeval (w .>> show (a,b) =>> stdPutStrLn)
23:41:36 <Cale>             where
23:41:38 <Cale>                 a = coeval (w .>> () =>> stdGetChar)
23:41:40 <Cale>                 b = coeval (w .>> () =>> stdGetChar)
23:42:03 <Cale> See, a and b are defined identically, so they really ought to have the same value.
23:43:20 <Cale> So in order not to break referential transparency, the system would somehow have to hang on to the value which was read forever.
23:43:26 <falconair> so what does that mean from using comonads to represent values coming in from the network and working with them as if they were some sort of dataflow streams (rather than using yampa style arrows) ... the system is unworkable according to haskell's semantics?
23:43:31 <Cale> With stdPutChar, it's even worse.
23:44:24 <Cale> Well, comonads are good at manipulating streams, once they can be thought of as pure streams.
23:45:06 <Cale> The example I gave there isn't even really the worst one
23:45:15 <Cale> stdPutStrLn :: OI String -> ()
23:46:01 <Cale> So consider what happens when we take the w which is passed to comain and do the same thing as above, but with stdPutStrLn
23:46:22 <Cale> (say, with different strings)
23:46:38 <Cale> Then we'll have printed two different strings to the same initial state context.
23:47:28 <falconair> say i have two streams coming in, "currency" and "stock", in order to get the current price I multiply the last value of stock by currency ...
23:47:29 <Cale> So obviously, this can't be done if they're on the same tty, which characters do we actually print?
23:47:30 <falconair> if I get 10 stock updates for each currency update -- I am multiplying 10 stock prices with the SAME currency price ... that should be possible in pure streams, correct?
23:48:01 <falconair> s/should/shouldn't
23:48:10 <Cale> What's the last value of the stream? :)
23:48:37 <falconair> oh...let's say "the most recent value"
23:49:03 <Cale> yeah, there's no notion of which value is the most recent with pure streams. However, you could timestamp the entries as they come in.
23:49:26 <Cale> and then use the timestamps to work out in a pure way which things go with which.
23:50:41 <falconair> i think what I am trying to do is that if I try to get the "next" value off a network stream, instead of blocking, it just gives me the value it returned the last time I did "next" ... a little confusing
23:50:59 <falconair> I think this is the difference between Signals and Events in the FRP world
23:51:57 <Cale> That's kind of a funky thing to do with a stream coming off the network...
23:52:28 <Cale> You could make it work.
23:52:48 <falconair> that is usually what is done in the financial markets, the most recent price is the "current" price (only slightly simplified)
23:53:19 <Cale> okay
23:53:53 <falconair> thanks, I have to think about this a bit more
23:54:08 <Cale> You might have an arrow library.
23:54:37 <falconair> sorry?
23:54:51 <Cale> Ah, arrows: http://haskell.org/arrows/
23:54:52 <lambdabot> Title: Arrows: A General Interface to Computation
23:55:59 <falconair> i spent some time trying to figure out Yampa and arrows, while I was getting confused with *** and &&&, I noticed that comonads might be the essence of dataflow :)  that's why i started reading about them
23:56:00 <Cale> It could also be handled with a plain monad, I suppose, but the sorts of things going on here sound kind of arrow-like.
23:56:26 <Cale> http://cs.ioc.ee/~tarmo/papers/essence.pdf
23:57:01 <falconair> hm...i'll take another look at arrows then, thanks
23:58:51 <Cale> f &&& g is like taking a single input stream and letting it flow through both f and g in parallel
23:59:45 <Cale> f *** g produces an arrow with two inputs and two outputs where f is applied to the first input, and g is applied to the second
