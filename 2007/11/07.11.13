00:00:57 <gvdm> get stoned and then lie in bed *about* to go to sleep, then you will find the solution
00:01:11 <faxathisia> heh
00:02:40 <johnnowak> faxathisia: start over
00:02:48 <Korollary> read other people's code
00:03:58 <gvdm> does anybody else find that they make architectural breakthroughs in the bed on the verge of sleep?
00:04:08 <johnnowak> yes
00:04:27 <Korollary> Somehow your total breakthroughs are still zero in the morning, eh?
00:04:32 <johnnowak> i think it's because you're so tired you don't have that filter that stops all your stupid ideas
00:05:06 <faxathisia> gvdm: also in that state sometimes notice something totally new in a piece of music, I guess that it's for a similar reason
00:05:24 <gvdm> faxathisia: I'd be inclined to agree
00:07:37 <ray> i once wrote a massive amount of code while in bed with the flu
00:07:44 <ray> except it turned out it was all a hallucination
00:10:15 <goalieca> i wrote my thesis last year while under the flu
00:10:19 <goalieca> and defended it while i had a cold
00:10:28 <goalieca> this year i'm getting my damn flu shot
00:14:01 <Korollary> ouch
00:20:30 <roconnor> I used to solve combinatorics problems while asleep
00:20:48 <roconnor> I took naps in the middle of my combinatorics exams
00:21:31 <Korollary> deliberately I suppose?
00:21:42 <roconnor> yep
00:21:50 <roconnor> I solved all the problem I could
00:21:57 <roconnor> took a 15 minute nap
00:22:05 <roconnor> then solved the remaining problems.
00:24:05 <Korollary> I can't take a 15 minute nap.
00:24:08 <Korollary> You win.
00:24:30 <psykon> that's... weird
00:35:15 <ricky_clarkson> roconnor: Nice.  I used to sleep during lessons and wake with the answers whenever the teacher asked.  The odd thing was that I'd give answers in terms of things they hadn't covered yet. ;)
00:37:52 <faxathisia> Are there any haskell stuff about simple program transformation online?
00:39:23 <sjanssen> can anyone recommend some good synonyms for get and set?  I'm writing a little functional references library, and I don't want to clash with the names in Control.Monad.State
00:40:09 <scodil> load/store
00:40:24 <faxathisia> accept/present, retrieve/store
00:40:51 <faxathisia> lookup/assign
00:42:18 <faxathisia> Has anyone written a CPS converter for a language or anything like this in haskell?
00:43:00 <johnnowak> sjanssen: read/write
00:43:39 <scodil> does anyone know where the overhead from ForeignPtr comes from? I always thought it was just from withForeignPtr, but even after getting the plain Ptr, accessing is still slower, and someone uses extra heap
00:44:05 <scodil> er, and someHOW uses extra heap
00:44:14 <pitecus> I'm trying to install the hint package and I get this: $ runghc Setup configure --user --prefix=$HOME
00:44:14 <pitecus> Setup.lhs:23:43: Not in scope: `compilerPath'
00:48:01 <kfish> sjanssen: peek/poke
00:49:28 <sclv> sjannsen -- fget and fset?
00:50:24 <sclv> alternately gt and st
00:50:56 <sjanssen> read, lookup, peek, poke are all used by the standard libraries
00:51:03 <sjanssen> (though I do like peek and poke)
00:51:12 <Korollary> scribble and peruse
00:52:27 <scodil> aloha and mahalo
00:52:36 <sjanssen> can_has, i_has_a?
00:52:43 <ray> observe and disserve
00:53:00 <sjanssen> split and swallow?
00:53:02 <sclv> snarf and barf
00:53:11 <scodil> sclv wins
00:54:36 <dikini> weird - mahalo in bulgarian means pendulum, in hawaiian something divine...
00:55:02 <dikini> thanks?
01:00:48 <quicksilver> friend of mine is using the ubuntu ghc packages, and -threaded doesn't seem to work
01:01:56 <quicksilver> complains it can't find HSrts
01:02:08 <sjanssen> x86?
01:02:08 <quicksilver> apart from that, it seems to compile and run code fine, though..
01:02:13 <quicksilver> no.
01:02:16 <quicksilver> iBook G4
01:02:20 <quicksilver> so ppc running ubuntu
01:02:43 <sjanssen> people have complained that ghci doesn't work in that distribution
01:02:48 <quicksilver> hmm
01:02:57 <quicksilver> does ghci also use the threaded RTS? I think it does
01:03:03 <quicksilver> that sounds consistent then
01:03:08 <sjanssen> though PPC Linux does support ghci
01:04:37 <quicksilver> I'll ask him if ghci works
01:12:52 <Japsu> @pl \x -> trace (show x) x
01:12:52 <lambdabot> trace =<< show
01:13:00 <Japsu> :o
01:13:33 <quicksilver> good old (r->) monad
01:14:36 <quicksilver> I love the way googling for "ghc bugs" takes you to the known bug list for ghc 2.0...
01:16:26 <Japsu> that monad never ceases to baffle me
01:16:31 <Japsu> I need to code something with it.
01:16:58 <quicksilver> it abstracts the plumbing of passing the same parameter to a bunch of stuff
01:17:09 <quicksilver> like suppose your app has this big global Config object
01:17:20 <quicksilver> which everything (potentially) needs
01:17:30 <quicksilver> that's what the reader monad (r->) is for
01:17:42 <quicksilver> although in many cases ReaderT is likely to be more useful
01:17:49 <quicksilver> since you quite often have other effects going on
01:23:25 <Japsu> or parsec ^^
01:23:46 <quicksilver> in parsec you'd be tempted to be lazy and use the built-in state thing
01:23:51 <quicksilver> even though parts of it were read-only
01:36:21 <faxathisia> > map fst $ iterate (\(x,y)->(y,x+y)) (1,1)
01:36:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:36:46 <faxathisia> > nubBy(((>1).).gcd)[2..]
01:36:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
01:37:54 <geocalc> wow faxou
01:38:38 <faxathisia> > [ (x, y, z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2 ]
01:38:39 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(7,24,25),(15,20,...
01:39:58 <opqdonut> > fix ((1:).(1:).(zipWith (+) =<< tail))
01:40:00 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:40:06 <faxathisia> :D
01:40:15 <opqdonut> i think i win your iterate solution
01:40:27 <faxathisia> It's the only one I wrote myself ;p
01:40:35 <faxathisia> > iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
01:40:35 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
01:41:23 <opqdonut> ah, haven't seen the pascal triangle before
01:41:32 <opqdonut> (as a oneliner)
01:41:41 <faxathisia> > fix ((1:) . (>>= \x -> [1+x, 1/(1+x)]))
01:41:44 <lambdabot>  [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.333333...
01:41:56 <faxathisia> > fix ((1:) . (>>= \x -> [1+x, 1/(1+x)])) :: [Rational]
01:41:57 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
01:45:26 <Japsu> > let fact n = product [1..n]; nCr n r = (fact n) / (fact r * fact (n-r)); row n = map (nCr n) [1..n] in map row [1..]
01:45:28 <lambdabot>  [[1.0],[2.0,1.0],[3.0,3.0,1.0],[4.0,6.0,4.0,1.0],[5.0,10.0,10.0,5.0,1.0],[6....
01:45:36 <Japsu> err, no.
01:46:09 <opqdonut> you need [0..n]
01:46:19 <opqdonut> and `div`
01:46:26 <Japsu> > let fact n = product [1..n]; nCr n r = (fact n) `div` (fact r * fact (n-r)); row n = map (nCr n) [0..n] in map row [1..]
01:46:27 <lambdabot>  [[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7...
01:46:30 <Japsu> yeah
01:47:07 <opqdonut> but it's kinda pointless as that doesn't use the inherent memoization that the zipWith one does
01:47:08 <Japsu> > let fact n = product [1..n]; nCr n r = (fact n) `div` (fact r * fact (n-r)); row n = map (nCr n) [0..n] in map row [0..]
01:47:08 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
01:47:16 <faxathisia> cool :D
01:47:47 <faxathisia> map $ map odd -> seirpinski ?
01:47:59 <opqdonut> yeah i'd guess
01:48:26 <opqdonut> and map (`mod` k) gives other interesting shapes
01:49:27 <ttfh> if I have one "serving" thread and several client threads that send messages to the serving thread thru a Control.Concurrent.Chan, what would be the best way of letting the serving thread answer back to the right client thread? using one Chan for each thread or one broadcast Chan where the client threads would have to understand which messages are for them?
01:49:44 <opqdonut> one chan per thread
01:49:48 <opqdonut> i'd say
01:49:48 <ttfh> alright
01:50:54 <ttfh> So the client threads can create their own Chans and send them along with the message maybe?
01:51:30 <Japsu> nah, just create a return channel for each thread as your fork them
01:51:36 * quicksilver nods
01:51:40 <quicksilver> I agree with japsu
01:51:48 <quicksilver> make new Chans just before each fork
01:52:06 <sclv> if you just need to communicate back once, maybe they could pass an MVar?
01:52:08 <sjanssen> or you can pass an IO () callback
01:53:19 <sjanssen> a callback is the most flexible, but you have to trust your clients to not pass something stupid
01:53:31 <ttfh> Japsu: but do you suggest that the clients send their messages to the serving thread using separate channels as well?
01:54:19 <roconnor> @src map2
01:54:19 <lambdabot> Source not found. stty: unknown mode: doofus
01:54:23 <roconnor> @src liftM2
01:54:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:55:15 <faxathisia> > liftM2 (,) [1,2,3] [4,5,6]
01:55:17 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:55:51 <ttfh> sjanssen: that seems like a good idea, the client threads will just be outputting some message anyway
01:56:03 <Japsu> ttfh: you can multiplex that direction if you want, but I think it's easier to have one channel pair per thread
01:56:12 <Japsu> or well,
01:57:11 <ttfh> Japsu: I liked the "one channel"-idea because then I can just have a list of events from the clients to fold over
01:58:03 <swiert> does anyone here know who's writes heisenbug.blogspot.com?
01:58:24 <Japsu> yeah well now that I think of it, having multiple channels talk to the serving thread would result in polling trickery
01:59:16 <dikini> swiert: he was here last night
01:59:16 <ttfh> but will passing a Chan thru another Chan cause some weirdness?
01:59:24 <Japsu> why would it? ;)
01:59:50 <Japsu> hmm
02:00:08 <Japsu> wonder if there's a way to wait for messages on multiple channels
02:00:11 <swiert> dikini: Interesting blogpost.
02:00:17 <swiert> Too bad I missed him.
02:00:40 <dikini> gabor I think
02:01:09 <Japsu> give it a list of channels and have it return the first channel that gets written to
02:01:14 <dcoutts> swiert: btw, what's the eta on the TMR? I'm eager to read about the SoC projects :-)
02:01:23 <dikini> swiert: he is preparing a paper on that, afaik
02:02:43 <swiert> dcoutts: I've been slacking a bit. I need to edit one last article, finish the editorial, get the green light from the authors, then I'll release.
02:02:49 <roconnor> swiert: was it interesting?
02:02:49 <ttfh> Japsu: yes, why would it, but I'm used to there being fineprint somewhere saying "If you combine features in this particular way, all hell will break loose" :-)
02:02:53 <swiert> so that should be finished beginning of next week.
02:02:57 <dcoutts> swiert: cool :-)
02:03:23 <roconnor> swiert: I didn't quite grasp the point of thirsts
02:03:26 <ttfh> Japsu: you could roll your own using isEmptyChan?
02:03:36 <swiert> roconnor: Yep. There's three articles: Jason Dagit on darcs conflicts; nominolo on Cabal Configurations; and mboes on the nhc type checker.
02:03:59 <swiert> roconnor: Conor's been kicking around with similar ideas lately. He'll be talking about them at Fun in the afternoon next week Thursday.
02:04:07 <ttfh> Japsu: no, that doesn't work, never mind
02:04:58 <swiert> roconnor: I think these Thrists pop up quite a lot in dependentl typed programming. You take the reflexive-transitive closure of a relation instead of constructing a list.
02:05:23 <swiert> roconnor: Nil corresponds to refl; Cons to trans.
02:09:31 <Japsu>  ~.
02:12:09 <roconnor> hmm
02:12:56 <opqdonut> Japsu: fail
02:13:31 <Japsu> opqdonut: there is no fail, only temporary lack of success
02:13:40 <opqdonut> the correct spell is of course ^U^M~.^M
02:13:55 <opqdonut> (or ~ . with deadkeys)
02:14:17 <Japsu> three strokes at the down arrow are a perfectly good substitute for your ^U
02:27:43 <jz1078> hello everybody
02:28:01 <opqdonut> hi
02:28:06 <jz1078> why is function like everythingBut :: GenericQ Bool -> (r -> r -> r) -> GenericQ r -> GenericQ r not included in syb?
02:28:26 <opqdonut> syb?
02:28:36 <jz1078> i suppose it could be implemented by others, but don't know how
02:28:41 <jz1078> Data.Generics
02:30:04 <jz1078> like everywereBut, but for querying
02:34:23 <hpaste>  Shurique pasted "Cabal errors" at http://hpaste.org/3843
02:34:39 <Shurique> I'm getting this error when doing "runhaskell Setup.hs configure" with several different packages, after installing GHC 6.8.1 (OSX)
02:34:51 <Shurique> anyone know what might be wrong?
02:35:54 <quicksilver> Shurique: looks like wrong version of cabal
02:35:56 <sjanssen> Shurique: the package uses hooks that don't work with your newer version of Cabal
02:37:12 <Shurique> ah, is it possible to have multiple versions of Cabal installed and switch between them for different packages?
02:37:49 <dcoutts> Shurique: yes
02:38:08 <dcoutts> Shurique: ghc --make Setup.hs -package Cabal-x.y.z
02:38:47 <Shurique> I'll try that, thanks!
02:49:59 <pitecus> Any idea how to fix this: Setup.lhs:23:43: Not in scope: `compilerPath'
02:50:29 <sjanssen> wow, we've got a FAQ of the night!
02:50:50 <sjanssen> pitecus: Setup.lhs depends on a version of Cabal older than the one you've got
02:51:48 <pitecus> sjanssen, I updated cabal because the package that im trying to install needed another package, and that other packaged needed a new Cabal version
02:52:04 <pitecus> Isnt that weird?
02:52:18 <sjanssen> pitecus: hackage is in a state of transition at the moment
02:53:36 <sjanssen> some packages need Cabal 1.2 to manage dependencies on 6.6 and 6.8, but other packages use Cabal hooks that aren't present in 1.2
02:56:21 <pitecus> so what is one supposed to do until the packages get fixed?
02:56:57 <earthy> deliver 2 cabal files and have the Setup.lhs figure out which cabal is present? :)
02:57:46 <pitecus> earthy, I just want to install some stuff from hackage
02:57:55 <earthy> oh. then you're pretty much up shit creek
02:57:57 <sjanssen> pitecus: you can have both versions installed at the same time, and use -package flags to chose which one is used
03:02:10 <pitecus> thanks
04:28:26 <corby>  /msg NickServ IDENTIFY corby
04:28:50 <corby>  /msg NickServ set password
04:28:56 <quicksilver> ;)
04:29:15 <corby>  /msg NickServ IDENTIFY corby
04:29:20 <yaxu> careful corby
04:29:30 <corby> saw that, oops
04:29:37 <yaxu> :)
04:31:26 <RayNbow> never copy/paste IRC commands into a chat window ;)
04:31:33 <RayNbow> it's safer to paste them into the status window
04:33:50 <visof> can i make website with Haskell?
04:34:10 <visof> by Haskell*
04:34:17 <faxathisia> good afternoon
04:34:40 <matthew_-> visof: yep, this has been done
04:35:16 <visof>  a link for website that make by Haskell?
04:35:24 <visof> that be made*
04:35:46 <nominolo> *are made with Haskell ;)
04:36:15 <matthew_-> well, wellquite.org is static but generated through a number of haskell programs
04:36:34 <nominolo> what does haskell.org run on?
04:37:03 <TomMD> courage
04:37:09 <matthew_-> fumes
04:37:27 <yaxu> X-Powered-By: PHP/4.3.2
04:37:37 <TSC> What about hpaste?
04:37:57 <cjay> hpaste uses happs
04:38:01 <cjay> @where happs
04:38:01 <lambdabot> http://happs.org
04:39:43 <visof> matthew_ how can you update the information in static website?
04:40:02 <matthew_-> I write text file
04:41:39 <visof> well, i want to make my website with Haskell
04:41:55 <visof> what  should  i do?
04:42:08 <nominolo> use happs
04:42:27 <matthew_-> or define what "make my website with Haskell" means
04:42:42 <matthew_-> using yi to write html would be making a website with Haskell
04:42:49 <nominolo> heh
04:43:32 <nominolo> it doesn't have html/xml syntax highlighting, yet
04:44:11 <hpaste>  faxathisia pasted "execute" at http://hpaste.org/3844
04:44:34 <faxathisia> I just wanted to ask is this the best way to write?
04:45:13 <faxathisia> I have got IO monad for reading from file, then Maybe monad in case I couldn't parse
04:45:24 <faxathisia> so basically... is this sensible :p
04:46:11 <pjd> nominolo: how does yi approach syntax highlighting?
04:48:33 <nominolo> pjd: using a lexer that returns a list of styles which then get added as an overlay
04:48:41 <matthew_-> vi >>= yi >>= why >>= not >>= emacs
04:49:17 <faxathisia> nobody comments?
04:49:32 <b_jonas> hi
04:49:39 <faxathisia> hey b_jonas
04:49:54 <sjanssen> faxathisia: it's reasonable, though I'd try to reduce the numer of 'returns'
04:49:59 <b_jonas> I'd like a floating-point formatter
04:50:06 <b_jonas> I looked at Numeric.showGFloat
04:50:15 <nominolo> faxathisia: the alternatie would be a MaybeT monad transformer
04:50:40 <faxathisia> ok can I reduce the number of returns using MaybeT?
04:50:55 <b_jonas> but I want one like c printf's "%.6g" where the precision specifies the total number of significant digits shown even when it shows the number in standard format not exponential
04:50:59 <sjanssen> MaybeT will probably complicate this simple code
04:51:17 <faxathisia> @src printf
04:51:17 <lambdabot> Source not found. Maybe you made a typo?
04:51:18 <nominolo> sjanssen: it adds a liftIO to the file-reading
04:51:24 <faxathisia> hmm
04:51:27 <nominolo> and removes a return
04:51:49 <sjanssen> nominolo: we'd have to see the rest of the program to know
04:52:01 <faxathisia> b_jonas: maybe you can use Tex.printf  http://cvs.haskell.org/Hugs/pages/libraries/base/Text-Printf.html
04:52:03 <nominolo> but of course the function will have type MaybeT, yes
04:52:08 <b_jonas> also I'd like it to use standard format from about 1e-4 instead of about 1e-2
04:52:14 <sjanssen> if the whole program can be MaybeT, it makes sense.  Otherwise ...
04:52:20 * osfameron is trying to work through http://sigfpe.blogspot.com/2007/04/trivial-monad.html
04:52:21 <lambdabot> Title: A Neighborhood of Infinity: The Trivial Monad
04:52:27 <osfameron> but the examples don't run
04:52:31 <osfameron> Ambiguous occurrence `fmap'
04:52:34 <osfameron> etc.
04:53:04 <quicksilver> osfameron: import Prelude hiding (fmap)
04:53:17 <quicksilver> osfameron: and go ahead and hide any more symbols which sigfpe redefines
04:53:18 <osfameron> quicksilver: ta
04:54:27 <osfameron> quicksilver: I still get that error in ghci
04:54:34 <quicksilver> hmph
04:54:35 <osfameron> quicksilver: do I have to hide it from the interactive session too?
04:54:40 <quicksilver> yes
04:54:46 <quicksilver> you can achieve that by loading a file which hides it :)
04:54:53 <quicksilver> that's the only way I know of, actualy
04:54:59 <hpaste>  faxathisia annotated "execute" with "I can remove a return this way" at http://hpaste.org/3844#a1
04:55:00 <osfameron> well I just did
04:55:07 <quicksilver> then that's odd
04:55:07 <faxathisia> but I don't know if this is better
04:55:07 <osfameron> as in I loaded "trivial.hs" which had that import
04:55:21 <osfameron> the code works fine within trivial.hs, but not in ghci
04:56:05 <osfameron> given his exhortation to "Try it in an interactive Haskell session" I'm sure there's something obvious I'm missing
04:56:31 <hpaste>  sjanssen annotated "execute" with "one long line" at http://hpaste.org/3844#a2
04:56:40 <faxathisia> haha
04:56:47 <faxathisia> sjanssen: cool
04:56:59 <faxathisia> :t fmap . fmap
04:57:01 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:57:12 <hpaste>  b_jonas pasted "Text.Printf?" at http://hpaste.org/3845
04:57:23 <b_jonas> faxathisia: look at that one
04:57:30 <b_jonas> what am I doing wrong?
04:57:35 <faxathisia> > (Text.Printf.printf "%g" 0.01) :: String
04:57:36 <lambdabot>  "1.0e-2"
04:57:42 <faxathisia> try :: String
04:57:51 <b_jonas> ah thanks
04:58:03 <faxathisia> the printf keeps retuning a new functions until you tell it to be a string
04:58:07 <b_jonas> why do they have to use this variable argument magic?
04:58:12 <faxathisia> so that's how it is variadic I think
04:58:21 <faxathisia> b_jonas: seems the only point in printf is the magic :p
04:58:53 <matthew_-> in haskell, that's certainly true. In C, avoids security issues
04:59:15 <b_jonas> faxathisia: yeah, that's true
04:59:19 <hpaste>  sjanssen annotated "execute" with "split into a where clause for better readability" at http://hpaste.org/3844#a3
04:59:20 <faxathisia> I don't even wanna see "C" and "security" issues in the same planet :p
04:59:28 <matthew_-> it's also the typical example used in lots of dependently typed languages
04:59:40 <b_jonas> still, that doesn't help
04:59:42 <matthew_-> eg cayenne and omega have papers that talk about printf
04:59:50 <b_jonas> Prelude> Text.Printf.printf "%.6g" 1e6 :: String
04:59:50 <b_jonas> "1000000.000000"
05:00:01 <faxathisia> sjanssen: Why did you fmap . fmap?
05:00:11 <b_jonas> it seems to use just showGFloat
05:00:24 <b_jonas> I want the behaviour of %g in C
05:00:32 <b_jonas> which uses the precision argument differently from %f
05:00:42 <faxathisia> b_jonas: you could call sprintf over FFI? :/
05:01:06 <b_jonas> :/
05:01:09 <sjanssen> faxathisia: because we want to want to map into two functors
05:01:13 <sjanssen> @type fmap . fmap
05:01:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:01:16 <b_jonas> yeah, I could
05:01:23 <b_jonas> but then I had to learn FFI
05:01:25 <faxathisia> the functors are interp and programAST?
05:01:27 <matthew_-> you'd have to go from Float to CFloat first, and the probably some pointer or somtehing, I think.
05:01:40 <sjanssen> faxathisia: f is IO and f1 is Maybe
05:01:46 <faxathisia> Oh
05:01:51 <sjanssen> faxathisia: no, Functors are types
05:01:55 <matthew_-> b_jonas: you could try converting to a fixed point repersentation
05:02:07 <faxathisia> Functor is a subset of Monad?
05:02:11 <quicksilver> yes
05:02:26 <quicksilver> it's just the ability to "Apply pure functions inside"
05:02:35 <b_jonas> matthew-_: sorry?
05:02:54 <quicksilver> in monad notation, "fmap f x" is do { xx <- x; return (f x) }
05:03:00 <quicksilver> also known as liftM
05:03:12 <faxathisia> :T liftM
05:03:17 <quicksilver> :t liftM
05:03:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:03:18 <quicksilver> :t fmap
05:03:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:03:25 <quicksilver> same thing, except specialised to monads
05:03:35 <faxathisia> so cool
05:03:44 <quicksilver> for any of the standard Monads, fmap == liftM
05:03:51 <quicksilver> (and any custom monads, it really should be!)
05:04:30 <osfameron> quicksilver: I may have been talking shite, sorry
05:04:49 <quicksilver> osfameron: that's OK. I do it all the time :)
05:05:30 <faxathisia> but I'm told Couldn't match expected type `(->) a' against inferred type `IO'
05:06:44 <faxathisia> oho (fmap.fmap) interp $ programAST file
05:07:02 <pjd> note that if a custom Monad instance isn't a Functor instance, you can use WrappedMonad
05:07:02 <b_jonas> maybe I should showFFloat then parse that to significand and exponent, then if the exponent is between -4 and 5, remove the exponent and scale the string by hand
05:07:53 <sjanssen> faxathisia: oops.  I'd say 'fmap (fmap interp) $ programAST file' is more clear
05:07:57 <matthew_-> ok folks of #haskell, if we wanted to write a persistent version of Data.Map, what would we do?
05:08:18 <faxathisia> sjanssen: ahh!
05:08:21 <faxathisia> ok thanks
05:08:35 <matthew_-> i.e. what would be good to nick from the RDBMS world in order to make it damn fast?
05:16:38 <faxathisia> when you have, if <condition> then <foo> else <bar>
05:16:50 <faxathisia> What do call the value of <condition> which is either True or False?
05:17:17 <Saizan_> b?
05:17:42 <b_jonas> condition
05:17:54 <b_jonas> really
05:18:21 <b_jonas> and in 'case foo of { ...', foo is called "scrutinee" or something like that
05:20:17 <osfameron> @unpl  bind (return . f)
05:20:17 <lambdabot> bind (\ c -> return (f c))
05:21:44 <faxathisia> ok
05:22:43 <hpaste>  faxathisia annotated "execute" with "interpret change" at http://hpaste.org/3844#a4
05:22:54 <faxathisia> I had to add a check on a post condition to this bit of code
05:23:12 <faxathisia> and since doing that I think I made the code a lot harder to understand :/
05:23:22 <faxathisia> does that seem true
05:24:22 <faxathisia> (and if the second version is harder to read.. any idea how to improve it)
05:24:52 <Saizan_> what does isTrue do?
05:25:13 <faxathisia> isTrue just turns a number into a boolean, so 0 is False and every other number is True
05:25:21 <faxathisia> isTrue x = x /= 0
05:25:22 <EvilTerran> (/=0)
05:25:58 <faxathisia> hm EvilTerran I like yours better :p
05:26:11 <faxathisia> isTrue = (/= 0)
05:26:44 <faxathisia> oh..
05:26:55 <faxathisia> I think I should make/use some kind of assert function
05:30:13 <Saizan_> maybe monad with guards and mplus?
05:30:29 <faxathisia> oh yeah :D
05:30:33 <faxathisia> I'll try that
05:31:48 <visof> what is the meaning of purely functional?
05:32:16 <quicksilver> visof: the result of a function depends only on its arguments
05:34:14 <hpaste>  Saizan annotated "execute" with "my try" at http://hpaste.org/3844#a5
05:34:37 <visof> aren't functions in languages like c,c++,python ... same?
05:35:04 <Toxaris> visof: consider the getChar function, wich reads a char from the terminal
05:35:13 <faxathisia> visof: int f() { static int x = 0; return ++x; }
05:35:21 <Saizan_> visof: no, you can still do I/O or modify "global" variables
05:36:06 <puusorsa> nice, yi now needs ghc 6.8
05:36:23 <puusorsa> any idea when moving to 6.8 fixes more stuff than it breaks?
05:36:28 <faxathisia> visof: returns a different  number each time in C, so it is using side effects and not a function
05:37:03 <quicksilver> puusorsa: not today :)
05:37:26 <puusorsa> right. didn't want yi anyway..
05:37:52 <visof> faxathisia do this program by Haskell?
05:39:19 <faxathisia> visof: That didn't make any sense
05:39:42 <faxathisia> visof: Do you want to see equivalent haskell code?
05:39:48 <visof> ya
05:40:04 <quicksilver> visof: in haskell the function would take a parameter which was an IORef
05:40:09 <quicksilver> it would have type
05:40:15 <quicksilver> f :: IORef Int -> IO ()
05:40:17 <quicksilver> most likely
05:40:23 <quicksilver> (there would be other ways to do it)
05:40:27 <Toxaris> f :: IORef Int -> IO Int
05:40:34 <quicksilver> yeah, that too :)
05:40:58 <Toxaris> f :: Int -> Int; f = succ; :)
05:42:12 <faxathisia> :t newIORef
05:42:14 <lambdabot> Not in scope: `newIORef'
05:42:28 <Toxaris> visof: that means, you would try to avoid such code in Haskell, and instead pass the int to be changed as argument to the function. if this is not handy enough, there are tricks to "hide" the argument passing.
05:42:34 <quicksilver> :t Data.IORef.newIORef
05:42:35 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
05:42:56 <b_jonas> tricks? just one trick, the do notation
05:43:06 <b_jonas> oh, and monad transformers
05:43:10 <b_jonas> then it's indeed tricks
05:43:16 <quicksilver> no, the do notation is not part of the trick
05:43:24 <quicksilver> monads are part of the trick
05:43:28 <quicksilver> but do notation is not needed
05:43:34 <quicksilver> (it just looks nicer, to some people)
05:45:59 <visof> hence we can t do the iteration in Haskell
05:46:11 <visof> Recursion too
05:46:22 <visof> or what?
05:46:36 <puusorsa> recursion is not possible in haskell?
05:46:45 <puusorsa> are you sure?
05:46:46 <quicksilver> it's a bit hard to pin down what "iteration" exactly is supposed to mean
05:46:48 <Toxaris> b_jonas: the obvious trick is to define a EDSL for handling of State, maybe using Monad, Arrow or Applicative as interface. I don't know if there are other tricks.
05:46:54 <osfameron> quicksilver: ok, I can hide (>>=) etc. to get those exercises to work
05:47:01 <quicksilver> it's true that recursion is the only primitive way to loop.
05:47:13 <quicksilver> but some uses of it look like "iteration" to me
05:47:16 <osfameron> quicksilver: but if I try to write with the syntactic sugar, then the ; desugars to GHC.Base's (>>=) rather than mine
05:47:32 <quicksilver> forM [1..9] (\n -> print n)
05:47:38 <quicksilver> ^^ in my book, that's iteration
05:47:47 <quicksilver> although, the construct I'm using is defined by recursion, sure.
05:48:00 <osfameron> ah!  He mentioned that the code fails to compile at the *end* of the tutorial.
05:48:01 <quicksilver> osfameron: ghci -fno-implicit-prelude, perhaps
05:48:15 <quicksilver> osfameron: I'm not sure if that works in ghci. It works in compiled code.
05:48:57 <osfameron> quicksilver: yep, that works
05:49:41 <osfameron> quicksilver: so would writing W in terms of instances of Monad and Functor... which I've just got to :-)
05:50:07 <osfameron> (sadly, the osfameron monad is imperative and tries to execute tutorial tasks in order)
05:50:24 <quicksilver> ;)
05:50:56 <quicksilver>  > osfameron *** [* Error : fails to commute *]
05:51:49 <osfameron> (funnily enough I will soon be teleworking 3 weeks per month, which is very much *not* commuting...)
05:55:00 <faxathisia> @docs newIORef
05:55:00 <lambdabot> newIORef not available
05:56:16 <quicksilver> @docs Data.IORef
05:56:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
05:56:22 <corby> r
05:56:24 <quicksilver> however, I note that @docs is currently broken :)
05:56:36 <faxathisia> :(
05:58:34 <faxathisia> :/
05:58:37 <faxathisia> visof: I can't do it
05:58:52 <faxathisia> I mean other than saving a file to disk...
06:01:09 <faxathisia> @src getStdGen
06:01:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:01:18 <faxathisia> @src Random.getStdGen
06:01:18 <lambdabot> Source not found. You speak an infinite deal of nothing
06:01:52 <faxathisia> "There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad."
06:04:27 <Saizan_> faxathisia?
06:04:35 <faxathisia> f = unsafePerformIO $ getStdRandom (randomR (1,6))
06:04:47 <faxathisia> it just gives the same value each time
06:05:06 <faxathisia> I don't know how it works enough to break it.
06:12:11 <jaj> Hi! I want to parse strings where the first characters represent a number which I would like to extract. The number can be either an int or a float. Currently I'm using parsec (in a rather clumsy way) to do it. Is that overkill? Is there an easier way to achieve this?
06:13:44 <Toxaris> > reads "1.543nonsense" :: [(Float, String)]
06:13:46 <lambdabot>  [(1.543,"nonsense")]
06:14:13 <Toxaris> or makeTokenParser to use parsec in a not-so-clumsy way
06:14:20 <Olathe> That's a bit of nonsense.
06:16:59 <jaj> I'm currently doing this http://hpaste.org/3846 to parse a float, which is about as clumsy as you can get
06:17:28 <jaj> Toxaris, you're solution is perfect, thanks!
06:26:19 <garfield_cat> is there an easy way to exchange a list's index and value? eg  turn [3,0,2,1,4] to [1,3,2,0,4]
06:29:11 <jberg> i don't understand that transformation
06:29:29 <hpaste>  b_jonas pasted "custon float format" at http://hpaste.org/3847
06:29:32 <b_jonas> ok, I've almost got what I want
06:30:39 <ari> > let l = [3,0,2,1,4] in map (`elemIndex` l) [0..4]
06:30:40 <lambdabot>  [Just 1,Just 3,Just 2,Just 0,Just 4]
06:30:47 <b_jonas> I now only have to change it so it strips the zeros from the end of numbers
06:31:14 <ari> Yeah, I know, it is rather ineffient
06:31:43 <b_jonas> and to strip the dot if all fraction digits are stripped
06:31:57 <b_jonas> how do you remove any suffix of zeros from a string?
06:32:13 <quicksilver> > map snd. sortBy (comparing fst) . map (\(a,b) -> (b,a)) . zip [0..] $ [3,0,2,1,4
06:32:13 <lambdabot>  Parse error at end of input
06:32:18 <quicksilver> > map snd. sortBy (comparing fst) . map (\(a,b) -> (b,a)) . zip [0..] $ [3,0,2,1,4]
06:32:20 <lambdabot>  [1,3,2,0,4]
06:32:27 <quicksilver> garfield_cat: like that, perhaps?
06:32:57 <quicksilver> > map fst . sortBy (comparing snd) . zip [0..] $ [3,0,2,1,4]
06:32:58 <lambdabot>  [1,3,2,0,4]
06:33:05 <quicksilver> ^^ this time without the gratuitious 'swap'
06:33:33 <ari> quicksilver++
06:33:44 <garfield_cat> quite complex...I'm just start to learn haskell
06:33:54 <quicksilver> garfield_cat: try it step by step then
06:34:03 <quicksilver> > zip [0..] [3,0,2,1,4]
06:34:03 <lambdabot>  [(0,3),(1,0),(2,2),(3,1),(4,4)]
06:34:09 <quicksilver> ^^ this just pairs up items with their index
06:34:22 <garfield_cat> en
06:34:26 <quicksilver> then the sortBy (comparing snd) sorts them by value (not index)
06:34:30 <quicksilver> and map fst extracts the indexes
06:35:47 <b_jonas> it must be simple
06:36:08 <Toxaris> > elems . array (0, 4) . flip zip [0..] $ [3,0,2,1,4]
06:36:08 <lambdabot>  [1,3,2,0,4]
06:36:35 <garfield_cat> i think i understand it now
06:37:11 <garfield_cat> u are all smart guys
06:37:20 <fasta> Is @pl available in a program that doesn't require more than a few minutes to install?
06:37:27 <quicksilver> don't think so, no
06:38:41 <b_jonas> fasta: you can use it in private message to lambdabot though
06:41:10 <b_jonas> please help me
06:41:20 <b_jonas> how do I remove trailing zeros from a String?
06:41:52 <osfameron> reverse . dropWhile (=='0') . reverse   ?
06:41:57 <Toxaris> > reverse . dropWhile (== '0') . reverse $ "1.110000"
06:42:04 <lambdabot>  "1.11"
06:42:07 <b_jonas> hmm, that would work
06:42:12 <b_jonas> so I need to reverse?
06:42:42 <fasta> b_jonas: you don't have to, it just won't work asymptotically faster if you do it any other way
06:42:55 <b_jonas> yeah, makes sense
06:43:15 <fasta> b_jonas: and assumping a sufficiently smart compiler it should work just as fast.
06:43:21 <fasta> assuming*
06:44:37 <osfameron> maybe with a bytestring there is a better way?
06:45:03 <fasta> A bytestring isn't mutable either.
06:45:13 <Toxaris> but substring is O(1)
06:45:30 <b_jonas> this will usually be called for short strings
06:45:32 <osfameron> you could read it as an integer and then show it?
06:45:39 <fasta> Toxaris: ?
06:45:39 <osfameron> er, as a number
06:45:42 <b_jonas> so I don't want to mess with bytestrings and stuff
06:46:25 <b_jonas> osfameron: dunno.... that will fail in the rare case when you want lots of decimals though
06:46:27 <Toxaris> fasta: you want to know why that is or why that helps?
06:49:38 <quicksilver> there is nothing wrong with osfameron's way
06:49:43 <quicksilver> reversing a short string is fine
06:49:52 <quicksilver> O(n) doesn't matter if n is only about 20, after all :P
06:49:56 <b_jonas> sure
06:49:58 <b_jonas> I'll use that
06:50:48 <Toxaris> removing trailing zeros from some string can't be sublinear, you have to process at least all those trailing zeros to check that they are indeed zeros and trailing
06:52:19 <quicksilver> Toxaris: sure it can, if you have a pointer to the end of the string
06:52:22 <hpaste>  b_jonas annotated "custon float format" with "remove trailing zeros and trailing dots" at http://hpaste.org/3847#a2
06:53:00 <b_jonas> that's almost good, I now only have to replace minus signs with underbars, but that's trivial
06:53:08 <Toxaris> so O(n) runtime is fine, but with [Char] you have to rebuild the whole string, but with ByteString you can reuse the underlying Word8-Array
06:53:25 <b_jonas> hmm no
06:53:31 <b_jonas> it actually doesn't work for negatives
06:54:34 <Toxaris> quicksilver: why would that help?
06:55:25 <quicksilver> Toxaris: pointer to the end of the string. If it's not a 0, nothing to remove.
06:55:29 <quicksilver> Toxaris: O(1) time taken :)
06:56:33 <b_jonas> I have to check for the sign
06:56:40 <Toxaris> quicksilver: consider "1." ++ replicate n '0'
06:56:48 <osfameron> you could do it without reversing.  You keep an accumulator of the string up to the last non-zero, then the zeros, and concat the zeros if you come across another non-zero
06:57:11 <quicksilver> Toxaris: yes, but it's O(number of zeros)
06:57:13 <matthew_-> it's still O(n) though
06:57:17 <quicksilver> Toxaris: not O(nummber of chars)
06:57:23 <quicksilver> Toxaris: that's quite a lot better, potentially
06:57:49 <Toxaris> quicksilver: but is it sublinear?
06:58:01 <quicksilver> yes
06:58:05 <quicksilver> it's O(number of zeros
06:58:10 <quicksilver> that's sublinear in length of string
06:59:18 <Toxaris> if you say that... I can't see it immediately
07:00:13 <quicksilver> what sublinear means depends what you think 'n' is supposed to be
07:00:21 <quicksilver> in complex problems it's less that obvious what 'n' is
07:00:41 <quicksilver> however, when you're dealing with a string, it's sensible to take n = length of string
07:00:51 <Toxaris> quicksilver: sure, that was what I meant
07:02:37 <stulli> @src minimum
07:02:37 <lambdabot> minimum [] = undefined
07:02:37 <lambdabot> minimum xs = foldl1 min xs
07:02:58 <stulli> @source minimum
07:02:58 <lambdabot> minimum not available
07:04:37 <visof> what is monad?
07:05:11 <visof> please simple explanation
07:07:26 <osfameron> visof: I've just worked through http://sigfpe.blogspot.com/2007/04/trivial-monad.html which isn't too bad at *showing* them
07:07:27 <lambdabot> Title: A Neighborhood of Infinity: The 6bae Trivial Monad
07:07:37 <osfameron> 6bae?
07:08:07 <hpaste>  b_jonas annotated "custon float format" with "handles sign properly too" at http://hpaste.org/3847#a3
07:10:05 <stulli> @source delete
07:10:05 <lambdabot> delete not available
07:11:36 <quicksilver> visof: a monad is a way of encapsulating 'effects'
07:11:45 <quicksilver> visof: a (pure) function only returns a value
07:11:58 <quicksilver> visof: a monadic action not only returns a value but also has some 'effect'
07:12:02 <quicksilver> visof: e.g. it does some IO
07:12:10 <quicksilver> or, perhaps it can throw an exception
07:12:29 <stulli> @source List.minimum
07:12:29 <lambdabot> List.minimum not available
07:12:37 <stulli> this doesnt work :/
07:12:52 <Saizan_> @source Data.List
07:12:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
07:12:59 <Toxaris> quicksilver: let's say n(s) = <length of s> and m(s) = <number of trailing zeros of s>. then the question is: is there N(c) for every c so that m(s) < c * n(s) for every s we may want to process with n(s) > N(c). if yes, m(s) grows sublinear in n(s).
07:13:05 <Saizan_> even if the link is broken now, probably
07:13:11 <Toxaris> quicksilver: correct?
07:13:38 <stulli> Saizan: i got it, thanks
07:16:32 <Toxaris> quicksilver: since this depends on what s we may want to process (in our case: strings representing floating point numbers), I do not yet see if it holds or not.
07:17:49 <quicksilver> Toxaris: well yes, it depends what assumptions you make about your input data
07:27:03 <mauke> bah, why is there no type debugger
07:28:03 <b_jonas_> lol
07:28:06 <b_jonas_> how would that work?
07:28:35 <mauke>  Couldn't match kind `?' against `* -> *'; When matching the kinds of `t :: ?' and `t1 :: * -> *'; Expected type: t1; Inferred type: t; In the pattern: Toggle _
07:28:43 <mauke> I don't know but that error message doesn't really help me
07:29:35 <faxathisia> kinds are to types as ___ is to kinds?
07:29:40 <faxathisia> does there exist a ___?
07:29:53 <matthew_-> kinds are to types as types are to values
07:30:04 <b_jonas> mauke: adding explicit type declarations make type error messages clearer in my experience: perhaps try adding explicit kind annotations
07:30:08 <faxathisia> what about in the other direction?
07:30:31 <mauke> b_jonas: where?
07:30:31 <matthew_-> err, yep, that holds too
07:30:48 <faxathisia> values <- types <- kinds <- [what goes here?]
07:31:09 <integral> nothing in haskell
07:32:01 <matthew_-> but in, eg, Omega, you don't really have kinds. You just have endless layers of types
07:32:31 <b_jonas> mauke: at the middle. you find the place of the error by binary search
07:32:39 * integral remembers Coq having some annoying kind system
07:32:44 <matthew_-> the distinction between types and kinds isn't really necessary. You just end up saying "sets of these things are 'typed' by this thing at he next layer up"
07:32:46 <mauke> there is no middle :/
07:33:19 <swiert> faxathisia: after kinds comes "super-kinds"
07:34:02 <faxathisia> What is Omega?
07:34:20 <matthew_-> Tim Sheard's sorta-dependently-typed-language
07:34:25 <swiert> faxathisia: An experimental language, mainly developed by Tim Sheard.
07:34:46 <swiert> @go putting curry howard to work
07:34:47 <lambdabot> http://web.cecs.pdx.edu/~sheard/papers/PutCurryHoward2WorkFinalVersion.ps
07:34:57 <matthew_-> it uses index types which gives you this (potentially) endless heirarchy of value-classifiers
07:36:29 <byorgey> faxathisia: I believe I have heard the word 'sort' used in the context of classifying kinds, but there's not really a standard.
07:37:22 <byorgey> (^^ actually, I think where I read 'sort' used in that way was in that paper.
07:37:45 <matthew_-> what does agda do? Is it a full mixing of types and values a la epigram or is it a strict heirarchy like omega?
07:39:58 <swiert> matthew_-: agda has proper dependent types a la epigram.
07:41:02 <mrd> @remember VerityStob SPJ is the Michael Palin of the functional programming world.
07:41:16 <lambdabot> I will never forget.
07:41:25 <faxathisia> lol
07:43:13 <byorgey> heh.
07:43:21 <nominolo> oh, so lambdabot now has a more reliaable persistent store?
07:43:30 <mauke> @quote
07:43:30 <lambdabot> erg0t says: lambdabot, tu nick seria el nombre ideal para un postre
07:43:57 <byorgey> @babel es en  lambdabot, tu nick seria el nombre ideal para un postre
07:43:57 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
07:44:02 <byorgey> grr
07:44:48 <mauke> "Your nickname would be the ideal name for a dessert"
07:45:27 <Sizur> i have problem doing a levelorder traversal over a binary tree
07:46:12 <byorgey> Sizur: maybe Data.Tree.levels might help?
07:46:23 <byorgey> Sizur: what's your problem?
07:46:36 <Sizur> byorgey: it izznt bynary, and i would like to know how to do it functinally
07:46:42 <swiert> Is there a package containing an implementation of tries somewhere?
07:46:44 <Sizur> binary*
07:46:56 <Sizur> functionaly*
07:47:01 <mrd> isn't*
07:47:29 <Sizur> i have this: data Tree = Fruit Integer | Branch Tree Tree
07:47:43 <byorgey> hehe, Fruit =)
07:47:51 <mrd> i likey
07:47:53 <byorgey> ok
07:48:04 <mrd> Leaves are boring
07:48:09 <matthew_-> "It's time to make like a Tree and Node"
07:48:17 <byorgey> so, non-empty trees with data at the leav...er, fruits
07:48:35 <Sizur> now how to traverse that in levelorder (note: normal algorithm uses side effect of working with additional structure)
07:49:02 <nominolo> swiert: tell me if you find one ;)
07:49:25 <matthew_-> Sizur: you want a breadth-first traversal
07:49:35 <byorgey> Sizur: first, I'd implement a function levels :: Tree -> [[Integer]]
07:49:39 <byorgey> then map over that
07:49:43 <Sizur> matthew_-: yeah
07:50:01 <Sizur> byorgey: that's great, but i'm stuck at the levels function
07:50:03 <hpaste>  arnuld pasted "dzen2" at http://hpaste.org/3849
07:50:10 <swiert> nominolo: Will do.
07:50:14 <byorgey> Sizur: just a sec, I'll paste something
07:50:19 <Sizur> byorgey: thanks
07:50:32 <quicksilver> levels (Fruit i) = [[i]]
07:50:34 <matthew_-> well, normally, with depth first, you recurse directly on the children. With breadth first, you just have to delay that until you've done everything at the current level
07:50:59 <quicksilver> levels (Branch t1 t2) = zipWith (++) (levels t1) (levels t2)
07:51:01 <mrd> you work off a queue instead
07:51:02 <quicksilver> something along those lines
07:51:11 <Sizur> quicksilver: doesnt work
07:51:14 <quicksilver> you might want to push the branchs down a level
07:51:24 <matthew_-> indeed. You have two lists - the things to visit at the current level, and then the things to visit at the next level
07:51:24 <quicksilver> in fact, I'm sure you do :)
07:51:34 <quicksilver> levels (Branch t1 t2) = [] : zipWith (++) (levels t1) (levels t2)
07:51:38 <quicksilver> that looks better
07:51:42 <matthew_-> and when the former is empty, the later becomes the former and you recurse
07:53:19 <Sizur> quicksilver: it doesnt work
07:53:27 <byorgey> quicksilver: that's what I came up with, it doesn't quite work...
07:53:38 <nominolo> swiert: oh, the collections package has a Truie
07:53:42 <nominolo> *Trie
07:53:57 <faxathisia> quicksilver: Woah
07:54:03 <nominolo> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections-0.3
07:54:06 <lambdabot> http://tinyurl.com/yt7z4y
07:54:14 <twanvl> you need something other than zipWith
07:54:29 <nominolo> swiert: though, it didn't build, when i tried yesterday
07:54:53 <byorgey> yeah, you need a modified zipWith that doesn't truncate the longer list to the length of the shorter
07:54:55 <nominolo> swiert: despite fixing the .cabal.  i got some type error, too
07:55:02 <conal> where's the collections repo?
07:55:37 <twanvl> zipWith' f [] ys = ys ; zipWith' f xs [] = xs ; zipWith' f (x:xs) (y:ys) = f x y : zipWith' xs ys
07:56:01 <nominolo> conal: no idea. could ask jyp
07:56:10 <conal> nominolo: will do.
07:56:56 <quicksilver> Sizur: for future reference, I'm unlikely to help someone who simply repeats
07:57:04 <quicksilver> "it doesn't work"
07:57:08 <quicksilver> without giving more details
07:57:10 <hpaste>  byorgey pasted "binary tree levels" at http://hpaste.org/3850
07:57:32 <byorgey> that ought to do it
07:57:46 <quicksilver> byorgey: oh yeah, that problem
07:57:51 <Sizur> nice one twanvl! just an error in the last function
07:58:03 <quicksilver> byorgey: replaves levels t1 in the recursive call with levels t1 ++ repeat []
07:58:06 <twanvl> oops, forgot the f
07:58:14 <quicksilver> erm
07:58:18 <quicksilver> is that good enough?
07:58:20 <quicksilver> I forget
07:58:24 <byorgey> quicksilver: why?
07:58:29 <Sizur> thanks byorgey! that's perfect
07:58:31 <byorgey> oh, I see what you're saying
07:58:34 <quicksilver> no, not quite good enough
07:58:38 <byorgey> quicksilver: but that means levels will return an infinite list
07:58:51 <quicksilver> byorgey: no it won't, it will return a level t2 - length list
07:58:53 <quicksilver>  :)
07:59:13 <byorgey> oh, right
07:59:16 <quicksilver> I thik I once worked out a neat trick for this 'zipWith by longer list' behaviour
07:59:23 <byorgey> I was thinking of putting the repeat [] in the base case =)
07:59:23 <quicksilver> but I have currently forgotten it
07:59:52 <Sizur> quicksilver: same for levels t2?
08:00:20 <Sizur> no
08:00:23 <swiert> nominolo: Thanks - I'll look into it.
08:01:28 <Sizur> it does return seem to not terminate with that mod
08:01:49 <quicksilver> Sizur: no, if you do it for both, you get an infinite list
08:02:06 <quicksilver> I can't remember what hack I used last time :)
08:02:10 <wli> data AtLeastOneOf t1 t2 = OnlyLeft t1 | OnlyRight t2 | Both t1 t2 ; zip' :: [t1] -> [t2] -> [AtLeastOneOf t1 t2]
08:02:19 <faxathisia> I wanna get this damn self interpreter to work :p
08:02:19 <swiert> nominolo: Edison also has some stuff on Patricia trees and TernaryTries.
08:02:20 <byorgey> and in this case, you can't just do a (takeWhile (not . null)), since some of the levels could legitimately be empty.
08:02:24 <faxathisia> It's hard :|
08:02:32 <faxathisia> a lot of work
08:02:34 <Sizur> quicksilver: i did it for one and i get infinite
08:03:00 <Sizur> twanvl's original works fine
08:04:24 <quicksilver> byorgey: yeah, that's it, I think
08:04:33 <quicksilver> byorgey: I think I used takeWhile not null last time
08:04:37 <quicksilver> byorgey: (slightly different problem)
08:04:40 <faxathisia> I keep having like
08:04:45 <hpaste>  matthew-_ pasted "tree traversal" at http://hpaste.org/3851
08:05:00 <faxathisia> frobFoos = concat . map frobFoo
08:05:14 <matthew_-> Sizur: there you go. That works.
08:05:20 <byorgey> quicksilver: right.
08:05:32 <faxathisia> anyone else noticed this in coding?
08:05:47 <byorgey> faxathisia: concatMap?
08:05:52 <faxathisia> @src concatMap
08:05:52 <lambdabot> concatMap f = foldr ((++) . f) []
08:06:02 <faxathisia> hm
08:06:04 <nominolo> swiert: han
08:06:05 <byorgey> concatMap f = concat . map f
08:06:07 <mauke> @src concat
08:06:07 <lambdabot> concat = foldr (++) []
08:06:08 <nominolo> oops
08:06:13 <nominolo> swiert: have a link?
08:06:24 <faxathisia> Do you just like
08:06:33 <faxathisia> replace all with concatMap?
08:06:37 <faxathisia> so there is less functions defned
08:06:49 <byorgey> faxathisia: it's a matter of taste/style.
08:06:52 <swiert> nominolo: http://hackage.haskell.org/packages/archive/EdisonCore/1.2.1/doc/html/Data-Edison-Assoc-TernaryTrie.html
08:06:53 <lambdabot> http://tinyurl.com/26jxty
08:06:59 <faxathisia> no I don't think will improve here
08:07:26 <hpaste>  arnuld pasted "shell function" at http://hpaste.org/3852
08:07:36 <byorgey> faxathisia: for one-off sorts of things, I'd just inline 'concatMap foo', but if I was using it a lot I might define it as a separate function.
08:07:42 <faxathisia> ah ok
08:07:45 <faxathisia> yeah, I am in that situation
08:09:26 <Saizan_> > let zipWith' f xs ys = zipWith f xs ys ++ uncurry (++) . last . zip (tails xs) (tails ys) in zipWith' (+) [1..6] [1..3]
08:09:28 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:09:44 <Saizan_> > let zipWith' f xs ys = zipWith f xs ys ++ (uncurry (++) . last . zip (tails xs)) (tails ys) in zipWith' (+) [1..6] [1..3]
08:09:45 <lambdabot>  [2,4,6,4,5,6]
08:10:58 <Sizur> how do i enable flags in the source again? {- Options -flag -}?
08:11:00 <hpaste>  faxathisia pasted "some possible derivation?" at http://hpaste.org/3853
08:11:17 <Saizan_> {-# OPTIONS -flag #-}
08:11:35 <faxathisia> Another question I have is .. If I wanted to try and make a deriving TokenParser or something like that
08:11:38 <byorgey> Sizur: or {-# LANGUAGE LanguageOption #-} depending what flags
08:11:43 <faxathisia> do you use TemplateHaskell or something else?
08:12:00 <faxathisia> I pased an example of what I wanted to do automatically
08:12:03 <faxathisia> pasted*
08:13:06 <Saizan_> faxathisia: what's the part that changes?
08:13:09 <faxathisia> well
08:13:17 <faxathisia> I want to remove all this lexToken and lexExactToken
08:13:23 <faxathisia> replacing with deriving TokenParser
08:13:41 <Sizur> byorgey: s/LANGUAGE/ghc/ ?
08:14:13 <byorgey> Sizur: no, you literally type LANGUAGE
08:14:26 <byorgey> Sizur: that's for compiler-independent options
08:14:51 <matthew_-> or just cheat, be lazy and chuck -fglasgow-exts up there :0
08:15:00 <byorgey> Sizur: such as UndecidableInstances, BangPatterns, ...
08:15:04 <quicksilver> LANGUAGE is the preferred way
08:15:16 <quicksilver> since we like to pretend that there is more than one haskell system out there
08:15:38 <Saizan_> faxathisia: you've to rewrite those functions for other datatypes? if not i don't see the advantage of writing a macro
08:16:17 <matthew_-> I would certainly prefer to publish / ship code with language pragmas, but for idle development, I generally can't be bothered to work out which features I'm using
08:16:54 <faxathisia> Saizan_: yeah you're right
08:17:08 <faxathisia> And to rewrite I would only have to change the types I guess
08:17:53 <fasta> I don't really see the point of language pragmas as AFAIK, the same program doesn't work in different ways with different pragmas currently.
08:18:49 <hpaste>  matthew-_ annotated "tree traversal" with "and showing it works..." at http://hpaste.org/3851#a1
08:19:00 <fasta> (and that implies that it's a computable function, which implies it's redundant information(noise))
08:20:04 <Saizan_> it's the same as cabal's build-depends, it's to specify what your program needs
08:27:30 <dcoutts> fasta: 1. that's not true for some pragmas and 2. even for pragmas that are strict extensions it makes a lot of sense to be clear about which extensions are being used so we can say something about the portability of the program.
08:29:00 <fasta> dcoutts: Can you give an example of a program that does something different with different options?
08:29:08 <dcoutts> fasta: bang patterns
08:29:19 <dcoutts> fasta: a ! b = 3
08:29:43 <fasta> dcoutts: that's not a program, that's an expression.
08:30:01 <dcoutts> that could define the ! operator or a function a with a strict b argument
08:30:04 <fasta> Well, an equation.
08:30:04 <dcoutts> it is a program
08:30:09 <faxathisia> is there a difference between program and expression?
08:30:13 <faxathisia> in the context of haskell
08:30:27 <dcoutts> faxathisia: programs are a collection of declarations
08:30:28 <fasta> dcoutts: I doubt you can make a program that actually compiles in both ways.
08:30:36 <fasta> dcoutts: that's what I mean by "program".
08:30:37 <chessguy> doesn't a program  have to have a main?
08:30:44 <faxathisia> and declaration is composed of expressions?
08:31:09 <osfameron> a program can be compiled to an executable
08:31:35 <dcoutts> fasta: what are you going to do? complete backtracking turning on or off language features until you find an interpretation where it compiles?
08:32:17 <fasta> dcoutts: you are not answering my question.
08:32:32 <dcoutts> fasta: I gave you a program that did what you asked
08:32:41 <fasta> dcoutts: no, that's not a program.
08:32:45 <dcoutts> it is!
08:32:53 <faxathisia> *grr*
08:32:55 <quicksilver> module Dccouts where { a ! b = 3 }
08:33:02 <quicksilver> is a perfectly well formed haskell module
08:33:05 <Beelsebob> okay, Colin Runciman wins
08:33:08 <quicksilver> which could be separately compiled
08:33:11 <fasta> Yes, it's a module. Not a program.
08:33:34 <quicksilver> so you'd need a compiler which was prepared to go back and recompile modules?
08:33:34 <sclv> fasta: also, what if your program compiles because the compiler "turned on" undecidable instances for you but you really didn't want them, so its just hiding a big?
08:33:39 <sclv> s/big/bug/
08:33:41 <dcoutts> fasta: echo "a ! b = 3" > bar.hs && echo ":browse" | ghci bar.hs && echo ":browse" | ghci -fbang-patterns bar.hs
08:33:50 <fasta> sclv: you try with both options, of course.
08:33:59 <quicksilver> when it later discovered that they didn't work with the options you chose in the way it needed to type-check a different module?
08:34:54 <fasta> quicksilver: you assuming the existence of a program that I asked dcoutts to provide now.
08:34:58 <fasta> are *
08:35:19 <matthew_-> dcoutts: *Main> syntax:  :browse <module> ;)
08:35:28 <fasta> matthew_-: no
08:35:35 <fasta> matthew_-: that has been changed :)
08:35:40 <dcoutts> mattam: in ghc-6.8 :browse without a module uses the current module
08:35:42 <hpaste>  gwern pasted "parallelizing QuickCheck" at http://hpaste.org/3854
08:35:47 <matthew_-> oh, sorry.
08:36:11 <fasta> dcoutts: I don't see how your example should convince me.
08:36:30 <gwern> I was thinking of using forkIO, but that doesn't tell me what the ultimate result of the test was
08:36:54 <hpaste>  mauke pasted "for fasta" at http://hpaste.org/3855
08:37:03 <gwern> anyone have any idea how I could run the tests in parallel? can't use `par` because it's in IO, and forkIO doesn't woprk per previous
08:37:08 <MyCatVerbs> Where's forkIO defined, anyway? I can't find it in the HHL. >>
08:37:20 <matthew_-> gwern: use an MVar to get the result back?
08:37:24 <MyCatVerbs> Wait, nevermind.
08:37:34 <gwern> Control.Concurrent, I think
08:37:57 <matthew_-> either an MVar or a Chan would work, I'd expect
08:38:03 <gwern> matthew_-: a what?
08:38:18 <matthew_-> Control.Concurrent.MVar, Control.Concurrent.Chan
08:38:24 <MyCatVerbs> gwern: danke.
08:38:30 <gwern> oh dear. I'm not familiar with those at all
08:38:35 <gwern> guess I have some reading to do
08:39:18 <matthew_-> well, MVar is just a shared cell. Chan is a chain of MVars. They're talked about in Tackling the Awkward squad by SPJ
08:39:30 <matthew_-> @go tackling the awkward squad
08:39:31 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
08:39:32 <lambdabot> Title: Simon Peyton Jones: papers
08:39:52 <dcoutts> fasta: ok, so it's difficult to make a program that has a main that compiles both ways and gives different results. That doesn't affect my second point however.
08:40:01 <faxathisia> Should I use foldl or foldr? :)
08:40:06 <gwern> I don't suppose there's any function in mvar which says 'do all this is parallel and hand me a list of results? :(
08:40:07 <fasta> mauke: thanks, for ending the discussion in such an efficient way.
08:40:16 <fasta> dcoutts: mauke's example is correct.
08:40:56 <dcoutts> cunning
08:41:06 <fasta> dcoutts: yes, it does affect your second point, since computing the minimum requirements is a matter of log (number of options)
08:41:22 <fasta> dcoutts: (in that case, but that case isn't true)
08:41:41 <dcoutts> fasta: and requires compiler that supports all of the extensions
08:41:52 <matthew_-> gwern: no, but it's not that hard to write one. Just create a channel first and then make all the functions that are going to be passed to forkIO aware of it. Then mapM_ forkIO on them and get all the children to write their results to the channel
08:41:57 <dcoutts> so you can't tell by looking if it'll work with another compiler
08:42:27 <matthew_-> gwern: then the parent thread just pulls results out of the channel and counts how many it's seen. When it's seen as many as there should be (== # children), it can die
08:42:29 <fasta> dcoutts: you can let your stupid compiler X run with all options enabled first.
08:42:51 <fasta> dcoutts: if it fails, either the program is broken or the compiler doesn't support enough options.
08:42:52 <gwern> matthew_-: if I define a temporary function and pass it the mvar and the other necessary functions, and forkIO it, is the modification to the mvar 'visible' to the main test function?
08:43:17 <dcoutts> fasta: but there's no way to know which one it does not support. It'd make for a great error message.
08:43:19 <gwern> *modification the forkIO'd function will make
08:43:26 <fasta> dcoutts: but this discussion is pointless now mauke proved it's non-sensical to talk about it further.
08:44:11 <quicksilver> fasta: no. I'm not assume anything.
08:44:13 <dcoutts> fasta: but even if it were not ambiguous, the redundancy is important.
08:44:34 <quicksilver> fasta: I gave you one example. dcoutts' example. We explained how it compiled differently under two different sets of options
08:44:37 <dcoutts> 'tis a slightly silly discussion though :-)
08:44:41 <quicksilver> fasta: this could be part of a larger program.
08:45:05 <dcoutts> quicksilver: mauke had a cunning larger program see http://hpaste.org/3855
08:45:09 <quicksilver> fasta: if it was, the only resolution would be to recompile that module later, under different assumptions, if it turned out not to to provide the right types under the ones you chose.
08:45:11 <fasta> quicksilver: mauke established that, yes, but until that point it was merely an assertion, imho.
08:45:46 <quicksilver> no, even without mauke's clever example
08:45:49 <matthew_-> gwern: yes, the purpose of MVars is that they allow you to pass values between threads
08:45:51 <quicksilver> it was clear from my example
08:46:04 <quicksilver> since under one set of options, Dcoutts exported the symbol 'a'
08:46:10 <matthew_-> gwern: they are shared mutable cells
08:46:16 <quicksilver> and under another set of options, it exported the symbol (1)
08:46:20 <quicksilver> (!0
08:46:22 <quicksilver> (!)
08:46:24 <quicksilver> gah :)
08:49:00 <hpaste>  gwern annotated "parallelizing QuickCheck" with "using channels. still not quite there" at http://hpaste.org/3854#a1
08:50:18 <faxathisia> Is there often a more haskell like way to write a fold with a case inside it?
08:50:51 <byorgey> faxathisia: can you give an example?
08:50:52 <fasta> quicksilver: yes, but that only moves the problem, I think.
08:51:06 <faxathisia> yeah
08:51:08 <faxathisia> I have written this
08:51:23 <hpaste>  faxathisia pasted "fold ( case )" at http://hpaste.org/3856
08:51:43 <faxathisia> and I wonder if I using techniques which are best avoided?
08:52:14 <byorgey> faxathisia: I think it would be clearer if you split out the function being used in the fold into a top-level function, defined via pattern matching.
08:52:33 <faxathisia> but then I have to give it a name :((
08:52:41 <faxathisia> ok I'll try, thank you :)
08:54:05 <matthew_-> gwern: where's the forkIO ?
08:54:38 <gwern> matthew_-: I decided to try leave the parallelizing until it compiled
08:54:44 <quicksilver> faxathisia: doesn't have to be top-level if you don't want to
08:54:52 <faxathisia> ah true
08:54:55 <quicksilver> faxathisia: just define it a local 'where' or 'let' if that's more appropriate
08:54:59 <byorgey> quicksilver, good point
08:55:00 <faxathisia> still gotta name it though :p
08:55:01 <faxathisia> which is hard
08:55:13 <quicksilver> I think what you've written is fine
08:55:16 * quicksilver shrugs
08:55:26 <quicksilver> making it a local definition is only going to move some -> into =
08:55:49 <quicksilver> I would personall align the commas and brackets in those 2-tuples though
08:56:30 <matthew_-> gwern: ahh ok. so I'm confused as to how you're trying to do this. I would try to create a function, let's call it f, that knows of the chan and, when executed, performs the test and writes the result into the chan. So then the main thread just creates one chan, creates all your f's with that chan and the test parameters and forkIOs them. Then it listens to the chan to collect the results.
08:56:43 <hpaste>  quicksilver annotated "fold ( case )" with "some alignment" at http://hpaste.org/3856#a1
08:57:20 <hpaste>  gwern annotated "parallelizing QuickCheck" with "still not there" at http://hpaste.org/3854#a2
08:58:16 <matthew_-> gwern: ahh, I'm blind. That is what you're doing ;)
08:59:07 <faxathisia> ok
08:59:20 <faxathisia> quicksilver: interesting
08:59:23 <faxathisia> that seems more readable
08:59:24 <matthew_-> gwern: but won't getChanContents return an infinite list which will forever block for more input?
08:59:30 <gwern> yeah... I think the middle line is fine, but I'm having trouble with the return
08:59:35 <matthew_-> gwern: you'll need to count the results back in
08:59:39 <mauke> what are Typeable instances of existential types supposed to look like?
08:59:43 <gwern> 'return $ (liftM and) $ (getChanContents chan)' *seems* like it'll work, but it doesn't
08:59:51 <hpaste>  faxathisia annotated "fold ( case )" with "using where for comparison" at http://hpaste.org/3856#a2
08:59:52 <matthew_-> just drop the return
09:00:11 <faxathisia> now I don't know what to do :/
09:00:27 <gwern> like '(liftM and) >> (getChanContents chan)'?
09:00:31 <matthew_-> no
09:00:35 <gwern> oh, wait, I see what I did wrong
09:00:38 <matthew_-> liftM and $ getChanContents chan
09:00:39 <matthew_-> gwern: you don't want the return. But my point above still stands - that approach won't work at runtime
09:00:42 <gwern> that should be a >>= shouldn't it
09:01:22 <matthew_-> (\ch -> liftM and $ getChanContents ch) :: Chan Bool -> IO Bool
09:02:24 <ToRA> the >>= version is  \ch -> getChanContents ch >>= return . and
09:02:57 <ToRA> but liftM is nicer and can even be made into
09:02:59 <ToRA> liftM and . getChanContents
09:03:30 <matthew_-> yes. Just a shame it'll just block forever at runtime
09:03:35 <gwern> I don't follow. what's the lambda being run by?
09:03:55 <matthew_-> no no, it's not. just drop the lambda and use chan
09:04:20 <hpaste>  matthew-_ annotated "parallelizing QuickCheck" with "like this..." at http://hpaste.org/3854#a3
09:04:52 <reqamst> > map (2/) [3,6]
09:05:06 <lambdabot>  [0.6666666666666666,0.3333333333333333]
09:05:20 <ToRA> matthew_-: er, no it won't
09:05:25 <hpaste>  byorgey annotated "fold ( case )" with "more alignment/cleanup" at http://hpaste.org/3856#a3
09:05:41 <ToRA> it'll block until someone sends down a False
09:05:45 <byorgey> faxathisia: I prefer that way, but there's definitely no right or wrong answer in this case.
09:06:09 <matthew_-> ToRA: super. So you either know that it's still working or that it's succeeded. Valuable information
09:06:14 <quicksilver> faxathisia: I don't see any reason to prefer the where form to the explicit case, in this particular example
09:06:15 <hpaste>  gwern annotated "parallelizing QuickCheck" with "compile error" at http://hpaste.org/3854#a4
09:06:20 <chessguy> hm, what determines the precision of those divisions?
09:06:37 <matthew_-> oh, join
09:06:41 <faxathisia> yeah
09:06:46 <ToRA> matthew_-: ah, my bad, i missed the context
09:06:47 <faxathisia> thanks a lot everyone
09:06:55 <faxathisia> I just like to see the different approaches
09:07:03 <gwern> matthew_-: seems to not compile
09:07:14 <matthew_-> gwern: doh, drop the $
09:07:37 <byorgey> chessguy: evil gnomes
09:08:26 <byorgey> > map (2/) [3,6] :: Rational    -- infinite precision!
09:08:26 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[t]'
09:08:37 <byorgey> > map (2/) [3,6] :: [Rational]    -- infinite precision!  but correct this time!
09:08:38 <lambdabot>  [2%3,1%3]
09:09:01 <matthew_-> @where quickCheckWith
09:09:01 <lambdabot> I know nothing about quickcheckwith.
09:09:35 <matthew_-> gwern: it would help if you posted more of the code so that others could try to make it compile ;)
09:09:40 <gwern> matthew_-: amusingly, that doesn't compile either
09:09:45 <gwern> matthew_-: alright
09:10:04 <desegnis> chessguy: more precisely, defaulting rules
09:10:05 <hpaste>  gwern annotated "parallelizing QuickCheck" with "whole file" at http://hpaste.org/3854#a5
09:10:18 <chessguy> oh, i thought defaulting was just for types
09:11:29 <desegnis> Well, the types determine the precision.
09:11:51 <desegnis> As well as the implementation (via the Num class, obviously)
09:12:19 <dons> dcoutts: how's ghc 6.8 going on gentoo?
09:12:26 <chessguy> @type map (2/) [3]
09:12:28 <lambdabot> forall t. (Fractional t) => [t]
09:12:29 <dons> i'm getting some great results with shootout programs in testing ... :)
09:12:40 <dcoutts> dons: :-)
09:12:54 <dons> 30% faster nsieve-bits, for example
09:12:55 <matthew_-> gwern: the error suggests that quickCheckWith is in the IO monad
09:12:57 <desegnis> chessguy: Alright, the Fractional class then.
09:13:08 <dcoutts> dons: we don't expect 6.8.1 to go into portage, but we hope to get 6.8.2 in soon after it is released
09:13:09 <gwern> matthew_-: yes
09:13:13 <matthew_-> so do mapM_ (\n -> forkIO $ (writeChan chan) =<< (quickCheckWith n 1 1000 t)) [100..1000]
09:13:34 <matthew_-> then it should at least compile.
09:13:41 <dons> we should be very good with e.g. nsieve-bits now, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
09:13:42 <lambdabot> Title: nsieve-bits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/sxpth
09:13:46 <ToRA> and the other line wants to be of the form of liftM (and . take xyz) for some suitable value of xyz?
09:13:54 <dcoutts> dons: the main impediment is packages not building with 6.8.x
09:14:04 <dons> right
09:14:05 <matthew_-> xyz == length [100..1000]
09:14:15 <gwern> matthew_-: it does indeed compile now
09:14:34 <gwern> dcoutts: a lot of packages don't build. it's unfortunate
09:14:47 <dcoutts> gwern: yeah, tell me about it :-)
09:14:52 <gwern> like, I sent in darcs patches for the cabal files for regex-base and regex-posix, and the author hasn't touched them yet
09:15:03 <dons> the hackage ones should be updated though, gwern
09:15:17 <dons> oh, maybe no regex* (to be backwards compat)
09:15:19 <gwern> and Goerzen's HSH and MissingH? he hasn't yet replied to my email telling him his fancy cabal stuff is very broken
09:15:20 <dcoutts> gwern: yes, for those packages there are versions that build with 6.8
09:15:27 <dcoutts> gwern: the 0.7x.0.x series
09:15:32 <titusg> :pl \x ys -> (10*x) +ys
09:16:07 <titusg> @pl \x ys -> (10*x) +ys
09:16:07 <lambdabot> (+) . (10 *)
09:16:21 <dcoutts> dons: we need some hackage testing infrastructure. I'd make cabal-install report build results as that'd give us large distributed testing.
09:17:09 <dcoutts> gwern: heh, you can ask jgoerzen now :-)
09:17:21 <dons> right.
09:17:55 * gwern is too scared too. I'm not too good at this haskell thing, and I always worry I'm wrong when I email someone to tell'em something's broken
09:17:59 <gwern> *to
09:18:16 <dons> anyone remember the old ghc logo?
09:18:41 <matthew_-> gwern: haskellers are friendly people. And personally I like people moaning about my libraries - it at least indicates others are using 'em
09:18:47 <dons> i just found my old copy, for nostalgia purposes, http://www.cse.unsw.edu.au/~dons/images/happy-dino.jpg
09:18:59 <dons> i say we should bring back the happy dinosaur!
09:19:26 <swiert> dons: google images did turn up some interesting results: http://www.midwestwrestling.com/championshipbelts/GHC_Jr_Tags.jpg
09:19:37 <faxathisia> haha
09:19:44 <swiert> those would look good on Simon
09:19:57 <gwern> matthew_-: alas, I don't have quite that confidence
09:20:03 <dons> heh
09:20:07 <dons> swiert: awesome!
09:20:20 <dons> "heavyweight tags" sounds like a good paper
09:22:26 <chessguy> someone needs to photoshop a cat into one of those pictures
09:22:52 <matthew_-> is there a cats module on hackage yet containing all the cat images?
09:27:00 <dons> chessguy: ask Pseudonym when he wakes up
09:27:17 <chessguy> dons, it was mostly a joke
09:28:04 <gwern> well. my test function certainly produces some lovely garbage on the screen
09:28:35 <chessguy> gwern, don't forget to turn on garbage collection
09:28:50 <gwern> 'alsMiafkieaPbolseR e(ala f1t.e8r1 86148 1t8ees-t2s
09:29:37 <byorgey> hehe, awesome!
09:29:40 <matthew_-> gwern: yep, that's probably the prints from each thread being nicely interleaved
09:29:50 <gwern> matthew_-: well, obviously
09:30:29 <gwern> hm. ghci seems to be single-threaded, so it's just running on the one core
09:30:44 <matthew_-> even with -N 785946843
09:30:45 <matthew_-> ?
09:31:28 <matthew_-> ghci-6.6.1 +RTS -N2 -RTS might give you 2 OS threads
09:31:48 <chessguy> anybody know where there's a copy of the @quote database?
09:32:00 <matthew_-> you may also need -threaded
09:32:11 <chessguy> i'm looking for one that gwern will definitely appreciate
09:32:12 <allbery_m> I thought the interpreter had some limitations like that
09:32:22 <gwern> alas, my ghci ignores the -N option
09:32:28 <gwern> and if you go +RTS -N4 it is still unhappy
09:32:34 <gwern> wait, do we need to close the +RTS?
09:32:40 <allbery_m> no
09:32:47 <Zao> chessguy: On the humor page, I believe.
09:33:03 <Phillemann> I've got a function taking two arguments and I want to apply this function on a list of pairs. How do I do that?
09:33:14 <mauke> map (uncurry f)
09:33:20 <gwern> zip sounds likely
09:33:36 <gwern> (or am I thinking of zipWith?)
09:33:54 <chessguy> Zao, the link nthere is to a binary file
09:34:00 <matthew_-> gwern - even with -threaded aswell?
09:34:15 <matthew_-> I'm not sure if that's implied by the -N
09:34:20 <Zao> chessguy: It's the quote _database_.
09:34:41 <chessguy> Zao, but there's a plaintext version somewhere
09:34:48 <gwern> matthew_-: ah, I compiled the binary using ghc with -threaded, but I don't think I passed that flag to ghci
09:35:11 <gwern> 'Warning: -debug, -threaded and -ticky are ignored by GHCi
09:35:14 <gwern> aw
09:35:31 <allbery_m> you should just be able to run unzip on the binary db
09:36:08 <gwern> what's a quick way to force main not to exit?
09:36:08 <matthew_-> gwern: bummer. I guess you'll have to stick with compiling it.
09:36:21 <matthew_-> threadSleep 10000000000000000000000000
09:36:30 <matthew_-> err, that might be threadWait
09:36:43 <quicksilver> you would need to supply threaded when you compiled ghci
09:36:45 <quicksilver> not when you run it
09:36:49 <matthew_-> threadDelay
09:36:54 <quicksilver> however, I thought ghci was, in fact, compiled with -threaded
09:37:06 <quicksilver> that is, I thought it used the threaded RTS
09:37:28 <gwern> quicksilver: dunno man. this was gentoo's 6.8 I installed
09:37:46 <quicksilver> there is a new fancy ghc 6.8 option
09:37:50 <quicksilver> to show you the RTS
09:37:52 <quicksilver> don't know what it is
09:37:58 <quicksilver> mentioned in the release notes, I think
09:39:15 <faxathisia> :t uncurry
09:39:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:39:44 <faxathisia> Is it not possible to have uncurry type (a -> ... -> c) -> (a, ...) -> c
09:39:49 <faxathisia> by some kind of magic
09:40:00 <quicksilver> no
09:40:08 <quicksilver> because the type system is not magic
09:40:11 <quicksilver> it is a type system
09:40:12 <quicksilver> ;)
09:40:20 <quicksilver> and it has simple and strict rules
09:40:30 <quicksilver> however, you could play with typeclasses
09:40:38 <matthew_-> but yes, you could probably make it work.
09:40:40 <quicksilver> and have a *method* rather than function
09:40:46 <faxathisia> with typeclasses I could do a finite number of them?
09:40:52 <quicksilver> and you could probably have the method inhabit all those types
09:41:05 <quicksilver> you can do infinite numbers with typeclasses in some cases
09:41:06 <matthew_-> you can do an infinite number of them if you get recursion in the type class instance context working
09:41:14 <quicksilver> although n-tuples won't work
09:41:19 <faxathisia> ok
09:41:19 <quicksilver> nested 2-tuples might
09:42:29 <matthew_-> hmmm, given that you can do both heterogeneous lists and write safeHead on it, I'm pretty sure it could work on n-tuples. You may have to redefine n-tuples though ;)
09:42:47 <matthew_-> unless they're deeply magic...
09:43:06 <quicksilver> heterogenous lists are nested 2-tuples :P
09:43:18 <quicksilver> precisely for this reason.
09:43:21 <matthew_-> oh yeah. I knew that.
09:43:22 <faxathisia> if they just allow '...' in the type system... and infer code from it
09:43:26 <quicksilver> n-tuples are not 'regular'
09:43:29 * matthew_- munches some humble pie
09:44:17 <gwern> is it possible on a 4-core machine to use more than 100% cpu time (according to top) w/o being parallel?
09:44:51 <matthew_-> in top, press 1 and then you'll see loading per core
09:44:53 <MyCatVerbs> gwern: not unless top has a rounding error. :)
09:45:44 <gwern> i've heard top is not very reliable
09:47:08 <matthew_-> well, you could use something like xosview or some other cpu monitor
09:47:08 <smtms> gwern, I think you can get 400% with 4 cores
09:47:26 <matthew_-> the loadavg is certainly 1 per core
09:47:44 <matthew_-> (the one that uptime and /proc/loadavg gives)
09:50:29 <sclv> :t uncurry . uncurry . uncurry . uncurry
09:50:30 <lambdabot> forall b c b1 b2 a b3. (a -> b3 -> b2 -> b1 -> b -> c) -> ((((a, b3), b2), b1), b) -> c
09:51:38 <gwern> well, I guess it's parallel then
09:51:55 * gwern sighs. I guess that's enough programming t'day
09:52:01 <gwern> thanks for all the help matthew_-
09:52:43 <matthew_-> gwern: np. allowed me to procrastinate for a while ;)
09:53:23 <Lycurgus> gwern! from wikipedia?
09:54:12 <quicksilver> matthew_-: arguably with just a little language support, n-tuples could be regular
09:54:17 <quicksilver> matthew_-: and this would be nice
09:54:25 <quicksilver> matthew_-: but... it's not really very important either :)
09:54:34 <MyCatVerbs> quicksilver: you're putting fiber in your tuples?
09:55:15 <quicksilver> ;)
09:57:27 <hpaste>  Toxaris pasted "somewhat different bfs tree traversal" at http://hpaste.org/3857
09:57:52 <gwern> Lycurgus: yes
09:58:25 <Lycurgus> gwern: sorry pinged you there as you replied.
09:59:19 <matthew_-> Toxaris: you should be able to supply a function to my breadthFirstFold that does the same - I think mine is strictly more general
10:00:01 <matthew_-> actually, ignore all of that. I'm wrong
10:02:29 <Toxaris> matthew-_: i don't like the ... ++ [x, y] bit of your version
10:03:32 <matthew_-> Toxaris: yeah - I hate the use of ++. I really like yours though - the recursion / fixedpoint on result is nice
10:06:03 <Toxaris> matthew-_: just spent an hour to come up with the pred n / succ n trick to end the recursion
10:07:06 <matthew_-> yeah I can believe that. I'm still struggling to get my head round it. Now change it to use fix ;)
10:11:12 <fozze> i'm wanting to start learning haskell, where's a good place to start?
10:11:31 <matthew_-> @where yaht
10:11:31 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:11:50 <matthew_-> fozze: try reading those - they're well known and liked tutorials
10:12:10 <Toxaris> matthew-_: something like:   bfs t = fix ((t :) . bfs' 1)? but i'm not sure
10:12:31 <Toxaris> matthew-_: or fix (bfs ' 1 . (t:))?
10:13:00 <Taejo> is there a function like \f xs ys -> (map f xs) ++ ys without the append?
10:13:30 <Taejo> I mean a standard one, cause I can roll my own easily
10:13:54 <matthew_-> @hoogle (a -> b) -> [a] -> [b] -> [b]
10:13:55 <lambdabot> No matches, try a more general search
10:14:03 <matthew_-> Taejo: don't think so
10:14:16 <matthew_-> Toxaris: what's that "'" in there?
10:14:29 <matthew_-> oh, ignore that, I'm being dumb
10:16:03 <stulli> How do i simplify something like this: huhu a = bubSort $ bubSort $ bubSort $ bubSort $ bubSort $ bubSort $ bubSort $ bubSort $ bubSort $ bubSort a ?
10:16:14 <Toxaris> matthew-_: :) well, I've to leave now, enough time invested for eating fruits
10:16:46 <Toxaris> stulli: huhu a = foldr ($) a [replicate 15 bubSort]
10:17:25 <Toxaris> stulli: iterate bubSort a !! 15
10:17:42 <stulli> wow, thanks
10:18:14 <stulli> Haskell is so... different :)
10:18:22 <Toxaris> but if bubSort does what it sounds like, then bubSort . bubSort == bubSort?
10:18:34 <Taejo> @pl mapa f = flip $ foldr ((:).f)
10:18:34 <lambdabot> mapa = flip . foldr . ((:) .)
10:18:36 <ToRA> > iterate tail "arrrgh!"
10:18:38 <lambdabot>  Exception: Prelude.tail: empty list
10:19:28 <stulli> Toxaris: Im trying to make a bubble sort to get used to haskell
10:19:49 <Toxaris> stulli: but what's the point of applying it multiple times?
10:20:05 <Toxaris> sorting a sorted list will not change anything
10:20:13 <stulli> well, bubSort isnt bubble sort, only 1 step of it
10:20:14 <byorgey> maybe it just does a single pass?
10:20:18 <byorgey> right
10:20:48 <wy> ski: hey!
10:20:53 <stulli> i wasnt aware i would need another function, so i called it bubSort :)
10:21:15 <Taejo> @src repeat
10:21:15 <lambdabot> repeat x = xs where xs = x : xs
10:21:39 <Taejo> to me, the obvious implementation is repeat x = x:(repeat x)
10:21:50 <Taejo> is there a reason the one in the prelude is better?
10:21:58 <allbery_m> sharing?
10:22:07 <byorgey> then maybe you want something like 'find sorted (iterate bubSort a)'
10:22:12 <faxathisia> > (fix (:)) 1
10:22:13 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
10:22:13 <lambdabot>     Pro...
10:22:13 <olsner> > take 20 $ fix ('a':)
10:22:14 <lambdabot>  "aaaaaaaaaaaaaaaaaaaa"
10:22:15 <mauke> Taejo: runs in constant memory
10:22:16 <faxathisia> :O
10:22:22 <byorgey> and implement a function 'sorted' which tells you whether a list is sorted or not
10:22:31 <Taejo> mauke, why does mine not?
10:22:49 <mauke> because it calls repeat x again, which allocates more list cells
10:22:50 <olsner> @ty fix (:)
10:22:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
10:22:51 <lambdabot>     Probable cause: `:' is applied to too few arguments
10:22:51 <lambdabot>     In the first argument of `fix', namely `(:)'
10:23:08 <Taejo> mauke, got you
10:23:20 <stulli> byorgey: Yeah, i was thinking about something like that, but i do one step after another :)
10:23:58 <wy> ski: Why does <> distribute over \/ ?
10:24:08 <byorgey> stulli: sure. =)  my point is that if you're doing bubble sort, you don't know in advance how many times you'll have to run bubSort
10:24:24 <faxathisia> what is <>?
10:24:34 <faxathisia> I guess \/ is disjunction
10:24:39 <byorgey> stulli: so you can just do (iterate bubSort a), which constructs the infinite list of applying bubSort repeatedly, and look for the first list that's sorted.
10:25:50 <stulli> byorgey: I will try
10:26:01 <byorgey> stulli: using something like replicate or !! means you have to know exactly how many times you need to run it, so you might do too few (=> incorrect) or too many (=> inefficient).
10:26:24 <faxathisia> wy: does <> mean does not equal?
10:26:26 <wy> faxathisia: yes. I'm continuing the topic last night. <> is the modal logic possibility
10:27:00 <faxathisia> oh I see
10:27:02 <faxathisia> ok
10:27:21 <wy> Do you know why?
10:27:46 <faxathisia> No.. sorry :(
10:27:50 <faxathisia> I just wanted to look itup
10:33:41 <ddarius> @bot
10:33:41 <lambdabot> :)
10:37:26 <faxathisia> @quote type
10:37:26 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
10:38:30 <olsner> @quote faxathisia
10:38:30 <lambdabot> No quotes match.
10:39:00 <stulli> byorgey: iterate gives me a error: "Term : iterate bubSort a Type : [[Int]] Does not match : [Int]"
10:39:38 <stulli> the function is defined as [Int] -> [Int]
10:39:56 <byorgey> stulli: hm, well, iterate bubSort a should have type [[Int]], but it seems you are using it in a way that expects [Int].
10:40:04 <byorgey> @type iterate
10:40:11 <lambdabot> forall a. (a -> a) -> a -> [a]
10:40:36 <byorgey> stulli: in what context are you using iterate?
10:41:46 <stulli> byorgey: huhu a	| sorted a = a; | otherwise =  iterate bubSort a; where bubSort is [Int]->[Int]
10:42:13 <byorgey> stulli: ah, ok, I think you are confused about how iterate works
10:42:19 <EvilTerran> @src iterate
10:42:19 <lambdabot> iterate f x =  x : iterate f (f x)
10:42:29 <byorgey> > iterate (+2) 5
10:42:31 <lambdabot>  [5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,...
10:42:55 <byorgey> iterate f x creates the infinite list [x, f x, f (f x), f (f (f x)), ...]
10:43:16 <stulli> ah, i see
10:43:23 <byorgey> stulli: in your case you probably want otherwise = huhu (bubSort a)
10:43:28 <desegnis> stully: Also, you can leave iterate away and write | otherwise = huhu (bubSort a)
10:43:45 <desegnis> s/stully/stulli
10:45:04 <byorgey> stulli: using iterate, you would want something like  huhu = fromJust . find sorted . iterate bubSort, but that's a bit more advanced
10:45:15 <byorgey> stulli: you should use whatever makes sense to you =)
10:45:24 <reqamst> Does ghc have command similar to @src?
10:45:32 <byorgey> reqamst: no.
10:45:54 <stulli> thanks for the help, things get clearer now. Its only my 3rd day with Haskell
10:46:32 <byorgey> stulli: great, you're doing well =)
10:47:14 <byorgey> reqamst: there used to be GOA (GHCi On Acid) which was essentially ghci + lambdabot, but AFAIK it currently doesn't compile.
10:54:53 <alexj> @seen igloo
10:54:53 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 3h 5m 19s ago.
10:55:22 <Nafai> Hey byorgey!
10:55:32 <byorgey> hey Nafai!
10:55:36 <byorgey> how's it going?
10:56:18 <Nafai> byorgey: Good, work is boring...but otherwise good
10:56:27 <byorgey> heh, same here
10:56:37 <Nafai> I finished #12, though I admit I "cheated" slightly
10:56:58 <Nafai> I used the implementation for finding primes and prime factors for #3 (I think) that was on the Haskell Wiki
10:57:19 <byorgey> nice
10:57:24 <Nafai> And I found an algorithm for finding the number of divisors a number has -- which I never would have figured out
10:57:26 <byorgey> well, I won't tell anyone =)
10:57:37 <Nafai> And I went from not finishing in 30 minutes to taking only 8 seconds
10:57:39 <Nafai> Pretty amazing :)
10:57:55 <byorgey> awesome =)
10:58:24 <byorgey> it's all about the algorithms...
10:58:32 <Nafai> Yeah
10:58:46 * MyCatVerbs wonders if programs making heavy use of Control.Concurrent on Unix could be made faster if the select()-based mechanism for dealing with IO from forkIO'd threads was replaced with something like epoll, or whatever it is they implemented on Solaris.
10:58:51 <Nafai> Oh, that reminds me
10:59:43 <Nafai> Is there a function (or more appropriate idiom) for counting the number of times an item is in a list other than this: length $ filter (==n) list ?
11:00:46 <byorgey> no, that's pretty much it.
11:01:03 <byorgey> although you can obviously roll your own such function easily =)
11:01:10 <Nafai> Yeah, I did
11:05:26 * byorgey is off to write a college recommendation
11:13:38 <Phillemann> Is there a way to trace what a program does? In an imperative language I'd just insert some print commands here and there, but in Haskell...
11:14:19 <klugez> @index trace
11:14:19 <lambdabot> Debug.Trace
11:14:38 <klugez> Phillemann: Use that.
11:14:45 <Nafai> I've been wondering that myself
11:14:53 <MyCatVerbs> :t trace
11:14:55 <lambdabot> Not in scope: `trace'
11:15:00 <Phillemann> I'll take a look at that.
11:15:07 <MyCatVerbs> Gah.
11:15:35 <puusorsa> :t Debug.Trace
11:15:35 <lambdabot> Couldn't find qualified module.
11:15:38 * integral copies subexpressions into ghci and pokes them
11:15:39 <Zao> It's new in 6.8.1, isn't it?
11:15:43 <puusorsa> :hoogle trace
11:15:59 <MyCatVerbs> Does what you want, anyway. Prints a string to the terminal with unsafePerformIO when the expression it's in is evaluated. Handy, but it's preferrable to get away without using it if you can.
11:16:12 <MyCatVerbs> Zao: nah, I've used it in 6.6
11:16:19 <puusorsa> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
11:16:20 <lambdabot> http://tinyurl.com/y4usfz
11:16:21 <puusorsa> nice ..
11:16:23 <MyCatVerbs> Zao: not sure when it was added, though.
11:17:12 <stulli> @source Data.Prelude
11:17:12 <lambdabot> Data.Prelude not available
11:17:45 <stulli> @source Data.List
11:17:45 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:19:13 <stulli> @source Prelude
11:19:13 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
11:20:02 <shapr> @yow !
11:20:02 <lambdabot> Couldn't find fortune file
11:20:05 <shapr> aww
11:20:06 <shapr> @quote
11:20:06 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
11:20:06 <lambdabot> squad, but he declined.
11:20:08 <shapr> hah
11:21:06 <Phillemann> Ah, works great, thanks. :)
11:21:50 <gwern> @src replicateM_
11:21:50 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
11:22:05 <gwern> @src sequence_
11:22:05 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:25:34 <shapr> Is there a ghc 6.8 deb?
11:25:47 <defcons> hello
11:25:50 <shapr> Hiya defcons
11:25:56 <defcons> how is type equivalence checked in haskell?
11:26:11 <defcons> I'd like to check if a list is a list of ints
11:26:31 <swiert> defcons: Haskell is statically typed.
11:26:59 <swiert> that is, the compiler knows straight away if a list is a list of ints.
11:27:30 <defcons> yes
11:27:56 <swiert> so you should never worry about checking if a list happens to be a list of ints.
11:28:02 <defcons> okay
11:28:02 <swiert> does that answer your question?
11:28:06 <defcons> yes, thank you
11:28:15 <swiert> no probs.
11:28:32 <swiert> feel free to ask, if you have any other questions.
11:28:57 <defcons> isPrime x = 2  == length . divisors x
11:29:07 <defcons> divisors returns [Int]
11:29:19 <defcons> I'm wondering why I'm getting an error
11:29:29 <swiert> it has to do with the function composition.
11:29:36 <swiert> try: length (divisors x)
11:29:55 <allbery_m> or (length . divisors) x
11:30:12 <swiert> Haskell parses "length . (divisors x)" - but "divisors x" isn't a function.
11:30:17 <CosmicRay> shapr!
11:30:44 <shapr> CosmicRay!
11:31:20 <defcons> aah, tanks allbery_m
11:31:21 <defcons> thanks*
11:31:49 <CosmicRay> shapr: how goes it?
11:35:56 <shapr> CosmicRay: Code is slowly flowing, how goes it with you?
11:36:33 <CosmicRay> good to hear.  similar here really.  I've been distracted by too many things, such as the book and Jabber ;-)
11:37:02 <shapr> CosmicRay: I read that Google's Android uses their own custom virtual machine that isn't exactly a sun java virtual machine, thus getting around the license restrictions. My wonder is whether that vm is a better STG target than the jvm.
11:37:09 <shapr> But I haven't found any technical details yet.
11:37:18 <shapr> CosmicRay: You could add me on jabber and I could distract you even more!
11:37:40 <CosmicRay> oh!  what's your jabber address?
11:37:49 <shapr> For gmail, it's shae.erisson
11:38:00 <shapr> At vo.com I'm shae
11:38:13 <CosmicRay> you have an invite
11:38:20 <Nafai> It looks like the android virtual machine is register based
11:38:27 <CosmicRay> what is vo.com?
11:38:30 <Nafai> vs stack based that the JVM is, I believe
11:38:48 <shapr> CosmicRay: That's HAppS LLC
11:38:54 <shapr> Nafai: Where did you find that info?
11:38:56 <shapr> I'd like to read more.
11:39:29 <CosmicRay> shapr: ahh.  which do you prefer to use?
11:39:37 <shapr> gmail
11:39:40 <CosmicRay> ok.
11:39:44 <shapr> Then I can do voice chat when my 770 is online :-)
11:39:44 <Nafai> shapr: http://code.google.com/android/what-is-android.html <- Under the "Android Runtime"
11:39:45 <lambdabot> Title: What is Android? - Android
11:39:57 <CosmicRay> shapr: ahh, I've got my eye on an 810 ;-)
11:40:04 <Nafai> Plus I read another blog entry (can't remember where) that made the comparison
11:40:06 <CosmicRay> I hope to figure out a way to point it to my own jabber server
11:40:22 <shapr> Does google talk support jabber conferencing?
11:40:32 <MyCatVerbs> shapr: you could add *me* on Jabber and I'd distract you with pointless questions... or I would, if I hadn't lost my jabber account details.
11:40:35 <Nafai> shapr: http://neilbartlett.name/blog/2007/11/13/google-android-now-100-java-free/
11:40:51 <wolverian> Nafai, interesting. now parrot isn't the only one anymore :)
11:40:54 <shapr> CosmicRay: I can connect to my jabber accounts from my 770, and it's running the N800 software.
11:41:02 <shapr> MyCatVerbs: find your jabber details!
11:41:08 <CosmicRay> bummer.
11:41:27 <shapr> CosmicRay: So you should be able to connect to your own jabber server just fine.
11:41:53 <integral> wolverian: should parrot users jump ship to a VM that's supported by Google?
11:42:49 <shapr> Are there any jabber conferencing servers that I can use from my gtalk account?
11:43:44 <newsham> interesting compilers type problem/solution: http://www.links.org/?p=271
11:44:01 <newsham> embed untrusted javascript without (hopefully) security concerns
11:44:36 <newsham> is gtalk jabber based?
11:44:40 <CosmicRay> shapr: oh, I misread.  you *CAN* connect.  excellent.
11:44:52 <shapr> newsham: yup
11:45:05 <newsham> does gtalk support tls?
11:45:13 <shapr> yes
11:45:17 <shapr> Er, SSL, I think.
11:45:20 <wolverian> integral, depends on how much they've invested in parrot right now, and how well it is working for them, I guess.
11:45:24 <shapr> @users
11:45:25 <lambdabot> Maximum users seen in #haskell: 412, currently: 387 (93.9%), active: 18 (4.7%)
11:46:04 <CosmicRay> nice.
11:46:10 <CosmicRay> that is more than #debian or #debian-devel have.
11:46:35 <shapr> #haskell is the 12th largest channel on freenode last I heard.
11:47:06 <pejo> shapr, only a bunch of linux channels that are larger?
11:48:09 <conal> shapr: your 770 is running 800 software?
11:48:51 <MyCatVerbs> shapr: good plan. I know the account name, I've just forgotten its password.
11:48:57 <MyCatVerbs> shapr: oops. =D
11:49:17 <integral> wolverian: yeah.
11:49:17 <shapr> conal: Yeah, I installed the OS2007 Hacker's Edition, but quite a few things don't work now.
11:49:28 <CosmicRay> heh
11:49:47 <conal> shapr: do you like it otherwise?  what doesn't work?
11:50:09 <shapr> pejo: Seems that #php, ##c++, ##c, #perl, #python, and #ruby-lang are larger than #haskell - http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
11:50:10 <CosmicRay> I am not entirely sure I grok the relationship between maemo and nokia.  someone was stating that nokioa would publish os2008 on maemo.org as a firmware update for n800 users, but isn't maemo a generic multi-device project?
11:50:10 <lambdabot> Title: Search IRC, displaying all channels on freenode
11:50:12 <integral> perl > haskell :-P (496 > 389)
11:51:34 <shapr> conal: Alarms don't work, the browser crashes a lot, the RSS reader crashes, every few days I get spurious reboots for no reason. The battery dies sometimes when the alarm should sound, it's probably an infinite loop somewhere. Most of this stuff did work at first, and stopped for no reason I can find.
11:51:53 <conal> shapr: urp
11:52:27 <shapr> OS2007 has lots of cool new and nifty features, but don't depend on it to do useful stuff.
11:52:31 <shapr> Not on the 770 at least.
11:52:43 <shapr> On the other hand, buy.com has the N800 for $250 USD last I checked.
11:53:00 <CosmicRay> thye keyboard on the n810 will be a winner.
11:53:05 <CosmicRay> we may deploy them as work devices
11:53:14 <thetallguy> conal: stepcut and SO both like the N770 for reading papers.
11:53:16 <shapr> Have you tried that keyboard?
11:53:22 <CosmicRay> no
11:53:22 * notsmack is waiting to replace his 770s with 810s
11:53:36 <shapr> notsmack: Is the 810s the model with WiMax?
11:53:46 <CosmicRay> they don't have wimax on any model yet
11:53:48 <notsmack> shapr: not sure about wimax
11:54:06 <thetallguy> conal: did you get your algorithm?
11:54:44 <shapr> CosmicRay: But that's the next iteration they're planning... It'll be released sometime in 2008 they say. I think Sprint will be Nokia's partner for that, since they're the only US wireless provider that's doing WiMax.
11:54:49 <shapr> at least, afaik
11:54:54 <CosmicRay> yes, I have heard this.
11:55:35 <conal> thetallguy: not really.  lots of interesting input, though, and particularly a helpful reference to a Chris Okasaki paper, which I'm reading now.
11:56:14 <thetallguy> conal: I have one designed in my head, not sure I'm going to take the time to flesh it out.
11:56:22 <thetallguy> conal: not sure if it will work, either
11:56:37 <notsmack> i don't suppose anybody's gotten haskell working on maemo yet?
11:56:54 <thetallguy> is maemo the nokia stuff?
11:56:55 <shapr> stepcut built ghc 6.4 on the 770
11:57:14 <thetallguy> yes, stepcut, but not registerized
11:57:31 <thetallguy> and still a bunch of problems.  like libgmp
11:57:39 <notsmack> interesting
11:57:51 <thetallguy> but he did get the basics up and running.
11:57:52 <thetallguy> ghc
11:58:03 <conal> thetallguy: that's fine.  it's a bit of a silly place to optimize right now.  the infinite stream is for progressively subdivided arrays of samples.  each level is twice the size of the previous (or 4 times in 2D).  so i won't index very far into the list.
11:58:21 <shapr> stepcut also said to leave your 770 plugged in, and don't expect to be able to use it for a long time.
11:58:22 <thetallguy> The sort of halfopen nature of the platform started to bug him, I think.
11:58:57 <thetallguy> conal: I wondered.  That's why I suggested arrays
11:59:33 <shapr> thetallguy: Yeah, that bugs me too.
11:59:40 <conal> thetallguy: i still wouldn't go for finite.  and arrays are stricter than i'm looking for.
11:59:44 <notsmack> is it the same amount of effort to just cross-compile for it?
11:59:49 <shapr> thetallguy: I wish the 770 and maemo were both open enough that OS2007 worked correctly.
11:59:56 <thetallguy> conal: so you might read and cache 512 values, then if you miss a cache hit, start a binary tree of arrays
12:00:00 <thetallguy> not suggesting finite.
12:00:17 <conal> Hm.  About Android: I have a compiler from Pan-like imagery to Java.  Maybe it could be adapted to Android.
12:00:25 <thetallguy> conal: suggesting S (Array a), where S is some indexed structure
12:01:07 <conal> thetallguy: wouldn't it be simpler to make the cache part of the tree
12:01:54 <thetallguy> conal: Someone made a Haskell library for  handling ranges, but I can't find it.  But it seemed like putting blocks of values into that structure would be enough.
12:02:20 <thetallguy> conal: the tree is the cache
12:02:45 <thetallguy> conal: I just envision a hybrid.
12:02:55 <thetallguy> conal: anyway, fun to think about.  Thanks for the puzzle.
12:03:19 <conal> thetallguy: sure.
12:03:27 <defcons> what is the equivalent of $$ in ghci?
12:04:25 <shapr> thetallguy: Interval something, yeah?
12:04:53 <olsner> what's $$?
12:04:57 <notsmack> defcons: what are you trying to do?
12:05:16 <thetallguy> http://haskell.readscheme.org/servlets/cite.ss?pattern=Neto-AFP1998
12:05:33 <thetallguy> I don't think that's it.
12:05:46 <thetallguy> Ou est le bot?
12:06:25 <defcons> notsmack, previous evaluated value
12:06:28 <shapr> lambdabot: @yow
12:06:29 <lambdabot> Couldn't find fortune file
12:06:30 <defcons> it's apparently in Hugs
12:06:33 <shapr> @quote
12:06:33 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
12:06:37 <shapr> hahaha!
12:07:09 <mrd> also means: afraid of text
12:07:33 <mrd> and in some locations: unable to start installer for unknown reason
12:07:53 <CosmicRay> haha
12:08:02 <defcons> haha
12:08:21 <aref> Hey. I'm horribly new to Haskell, and can't for the life of me figure out why this (http://hpaste.org/3858) won't work. Anyone willing to point out what should be done here?
12:08:39 <mrd> well it doesn't do anything
12:09:00 <mrd> maybe you meant to print (fibonacci 10) ?
12:09:19 <thetallguy> put a print $ in front of your fibonnacci 10
12:09:31 <aref> mrd: I guess I would mean that :D
12:10:22 <aref> Now would you look at that. Excellent. What's the difference between print (fibonacci 10) and print $ fibonacci 10?
12:10:31 <mrd> nothing really
12:10:32 <notsmack> aref: none
12:10:42 <Zao> aref: $ is function application with a low precedence.
12:11:09 <mrd> print fibonacci 10  ==  (print fibonacci) 10
12:11:11 <mrd> bad
12:11:12 <thetallguy> @src ($)
12:11:12 <lambdabot> f $ x = f x
12:11:17 <aref> I see. Well thanks guys, back to reading then (this just annoyed me to such a degree I had to ask)
12:11:37 <thetallguy> @src print
12:11:37 <lambdabot> print x = putStrLn (show x)
12:13:38 <phlpp> hi!
12:13:48 <thetallguy> @yow
12:13:48 <lambdabot> Couldn't find fortune file
12:13:55 <thetallguy> D'oh!
12:14:01 <thetallguy> I saw shapr do that twice.
12:15:38 <shapr> @quote
12:15:38 <lambdabot> types says: A good type system is like a set of tests, except they're actuallly proofs
12:16:04 <thetallguy> Hah!  Found it on hackage: http://hackage.haskell.org/packages/archive/Ranged-sets/0.1.1/Ranged-sets.cabal
12:16:06 <lambdabot> http://tinyurl.com/34p7xz
12:16:30 <shapr> I like the latest lambdacats pic, I feel that pretty regularly.
12:17:07 <thetallguy> conal: for your semi-infinite list cache:  use a Ranged-set of arrays of fixed size as your cache
12:24:00 <conal> thetallguy: do you have a reference for Ranged-set?
12:42:15 <veerz> hi, I'm new to haskell and fighting with its type system - http://hpaste.org/3859 - could someone have a look please?
12:43:36 <dmwit> veerz: div takes Ints, I think.
12:43:38 <dmwit> :t div
12:43:43 <lambdabot> forall a. (Integral a) => a -> a -> a
12:43:49 <dmwit> Whoop, hold on.
12:44:04 <dmwit> oh
12:44:07 <Taejo> veerz, I think your problem is precedence
12:44:10 <dmwit> print unitfractions a b
12:44:13 <Nafai> veerz: Try either putting a $ between print and unitfractions or enclosing unifractions a b in parens
12:44:17 <dmwit> Is interpreted as
12:44:19 <Taejo> you want print (unitfractions a b)
12:44:22 <dmwit> (print unitfractions) a b.
12:44:25 <dmwit> But you want
12:44:31 <dmwit> print (unitfractions a b)
12:44:52 <veerz> Ok, that helps
12:44:56 <veerz> thanks
12:46:41 <Maenad> can someone show me an example of haskell code that would loop through an array of strings (10 of them are in the array) and print them off to screen?
12:47:01 <puusorsa> really an array and not a list?
12:48:10 <puusorsa> mapM_ printStrLn ["some", "strings", "here"]
12:48:15 <dmwit> Maenad: mapM printStrLn -- ;-)
12:49:48 <Cale> putStrLn
12:50:29 <thetallguy> conal: it's on hackage.  Scroll up a bit for the link
12:50:30 <puusorsa> exactly
12:50:33 <puusorsa> i has the dumb today
12:50:36 <gwern> maybe you could abuse 'show'?
12:50:41 <dmwit> Or maybe one of
12:50:50 <dmwit> putStrLn . unwords / putStrLn . unlines
12:51:04 <gwern> puusorsa: 'kant haskell today'? :)
12:53:58 <gwern> matthew-_: I feel stupid now. You were right, the laziness of getChanContents did turn out to be a problem
12:56:46 <conal> thetallguy: thanks.  i'd missed your earlier link.  i don't see how ranged sets would apply.  what do you have in mind?
12:59:42 <gwern> what's the best way to run a list of IO Bool functions and return true iff all are true?
13:00:19 <dmwit> :t all
13:00:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:00:28 <dmwit> almost
13:00:32 <Zao> :t and
13:00:33 <lambdabot> [Bool] -> Bool
13:00:46 <dmwit> That was my next guess. =)
13:01:12 <Zao> sequence_ to evaluate them, and on the resulting list?
13:01:33 <gwern> @src sequence
13:01:34 <lambdabot> sequence ms = foldr k (return []) ms
13:01:34 <lambdabot>     where
13:01:34 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:01:48 <gwern> :t sequence
13:01:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:02:20 <dmwit> Actually, depending on your semantics, that may not be what you want.
13:02:32 <dmwit> Do you want it to stop evaluating IO actions after the first False?
13:02:41 <gwern> might as well
13:02:47 <dmwit> In that case you'll need to use foldM (liftM (&&)) or something like that.
13:02:54 <dmwit> :t foldM
13:02:54 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:02:59 <gwern> hmm.
13:03:37 <dmwit> I wonder if something even closer exists.
13:04:22 <dmwit> Hmmm, actually that might not be quite right either.
13:04:23 <dmwit> heh
13:05:08 <gwern> couldn't match b->Bool with inferred Bool
13:05:25 <dmwit> :t foldM (liftM (&&)) (return False)
13:05:25 <lambdabot>     Couldn't match expected type `b -> Bool'
13:05:25 <lambdabot>            against inferred type `Bool'
13:05:25 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
13:05:41 <dmwit> :t foldM (liftM2 (&&)) (return False)
13:05:41 <lambdabot>     Couldn't match expected type `m Bool' against inferred type `Bool'
13:05:41 <lambdabot>       Expected type: m Bool -> m Bool -> m (m Bool)
13:05:41 <lambdabot>       Inferred type: m Bool -> m Bool -> m Bool
13:05:57 <doserj> @type foldr (liftM2 (&&)) (return True)
13:05:57 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
13:06:55 <gwern> :t (return True)
13:06:56 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool
13:07:35 <ikegami--> morning
13:08:16 <gwern> afternoon
13:08:56 <ikegami--> gwern: have you tried the latest flymake-mode for Haskell?
13:09:08 <ikegami--> I wish it will work for you
13:09:32 <gwern> ikegami--: what's the latest? the last time I looked at the wiki, 'twas pretty messy and unclear what's what
13:09:52 <thetallguy> conal: you want to access your list by index, right?
13:10:24 <ikegami--> gwern: I mean today's instruction : http://www.emacswiki.org/cgi-bin/emacs/FlymakeHaskell
13:10:31 <roconnor> @type <*>
13:10:31 <lambdabot> Title: EmacsWiki: FlymakeHaskell
13:10:32 <lambdabot> parse error on input `<*>'
13:10:34 <gwern> test = foldr (liftM2 (&&)) (return True) [kpaTest, psiTest, energyTest, thermalMaxTest, timeMaxTest]
13:10:36 <gwern> ugly but works
13:10:36 <roconnor> @type (<*>)
13:10:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:10:43 <conal> thetallguy: yes
13:11:19 <conal> wheee -- applicative functors!
13:11:27 <gwern> ikegami--: I mean, for example, is that perl script still necessary?
13:11:41 <thetallguy> so your cache would look like ranges (0,511), (512,1024)..., each of which would have an array attached with an array containing that range
13:12:29 <roconnor> @type (\f a b -> f <*> a <*> b)
13:12:30 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
13:12:47 <roconnor> @pl (\f a b -> f <*> a <*> b)
13:12:47 <lambdabot> ((<*>) .) . (<*>)
13:13:13 <roconnor> @type (let (.:) = (.) . (.) in <*> .: <*>
13:13:13 <lambdabot> parse error on input `<*>'
13:13:23 <ikegami--> gwern: the perl script maybe not necessary if the original flymake-mode will change in the future
13:13:23 <roconnor> @type (let (.:) = (.) . (.) in (<*>) .: (<*>))
13:13:24 <lambdabot> forall a b (f :: * -> *) a1. (Applicative f) => f (a1 -> a -> b) -> f a1 -> f a -> f b
13:13:36 <roconnor> @type (let (.:) = (.) . (.) in (<*>) .: (<*>) .: (<*>))
13:13:37 <lambdabot> forall a b a1 (f :: * -> *) a2. (Applicative f) => f (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
13:14:40 <conal> thetallguy: isn't ranged-set just a representation of the set of indices?  i don't know how that would help.
13:14:51 <roconnor> @type (<$>)
13:14:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:15:03 <roconnor> oh, for Functors.
13:15:20 <thetallguy> conal: then I don't understand what you're after I think
13:15:56 <hpaste>  gwern annotated "parallelizing QuickCheck" with "finished version" at http://hpaste.org/3854#a6
13:17:41 <conal> thetallguy: okay.  thanks anyway.  i'll bring it up again later if i'm still looking for help later.
13:17:52 <gwern> ah. feels good that that is done. now, need to verify it does parallelize, clean it up, and figure out if or how to add it into QuickCheck
13:18:07 <dibblego> ?hoogle (Monad m) => m [b] -> (b -> m c) -> m [c]
13:18:08 <lambdabot> No matches, try a more general search
13:18:15 <gwern> :t sequenceM_
13:18:16 <lambdabot> Not in scope: `sequenceM_'
13:18:16 <dibblego> ?type mapM
13:18:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:18:21 <dibblego> ah cheers
13:18:25 <gwern> :t sequence_
13:18:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
13:18:50 <ikegami--> parallelize QuickCheck is cool
13:19:09 <Heffalump> gwern: yes, do it!
13:19:15 <Heffalump> (in answer to "if")
13:19:51 <gwern> Heffalump: I'm not a very good haskell programmer, and the output is very messy. it may not be a good thing for my code to go into a widely used library like quickcheck
13:23:06 * sorear receives 221 messages overnight...
13:23:26 <gwern> interesting. top reports 101% usage even though I passed +RTS -N1 -RTS
13:23:51 <fasta> gwern: I had a similar thing on some intel thingie with 2 cores.
13:23:57 <lament> sorear: sounds like haskell-cafe
13:24:11 <sorear> cvs-ghc actually
13:24:27 <gwern> fasta: 4 cores here. I'm running the -N4 one now
13:24:28 <sorear> (mostly cvs-ghc that is - I use a single merged threadview)
13:25:00 <RiX0R> Hi
13:25:08 <RiX0R> Can anyone help me?
13:25:13 <fasta> gwern: (using only one of them actively, but maybe the RTS did run multiple threads)
13:25:19 <Botje> RiX0R: yes!
13:25:22 <fasta> RiX0R: no
13:25:23 <thetallguy> RiXOR: Hard to say.
13:25:30 <Cale> RiX0R: Not unless we know what's wrong! :)
13:25:31 <RiX0R> I'm trying to install the fastcgi package but when I do runhaskell Setup.lsh configure, I get hte following error:
13:25:35 <fasta> RiX0R: you need to ask a meaningful question first
13:25:38 <gwern> I'm a little disapointed, though. -N1 maxes out at 101%, and -N4 at ~130%
13:25:42 <RiX0R> Setup.lhs: fastcgi.cabal:12: 'Executable' stanza starting with field 'flag small_base
13:25:42 <RiX0R> description'
13:25:56 <RiX0R> Thanks guys, I was getting to the explanation... :)
13:25:58 <allbery_m> you need a newer Cabal
13:25:58 <Cale> hehe
13:26:08 <RiX0R> I figured
13:26:15 <RiX0R> But I got mine from Debian which is very convenient
13:26:27 <allbery_m> (supporting both older and newer ghc requires a lot more work than the older Cabal package is capable of doing)
13:26:30 <fasta> RiX0R: Debian lags very inconveniently
13:26:31 <thetallguy> not very convenient if it doesn't work.
13:27:12 <RiX0R> That's true of course :)
13:27:19 <RiX0R> But I'm afraid I'll end up in dependency hell
13:27:30 <thetallguy> Yup, that's Debian.
13:27:41 <Cale> hm?
13:27:43 <fasta> No, that's not Debian.
13:27:53 <RiX0R> I meant: without the automatic package manager
13:28:08 <allbery_m> sadly, dependency hell is all but guaranted these days.  the major downside of the recent library breakup
13:28:10 <chessguy> so, use a real distro?
13:28:11 * chessguy dives for cover
13:28:12 <fasta> RiX0R: you just find some way to install Cabal and then install anything else with cabal-install
13:28:33 <Cale> chessguy: what do you use?
13:28:34 * Botje fills the cover with concrete
13:28:51 <chessguy> oh, i don't use linux at the moment, i was just trying to start a flamewar
13:28:51 <fasta> RiX0R: when something doesn't work, you report it in the bug tracking system of cabal-install or for the package containing the bug.
13:28:52 <chessguy> :)
13:29:01 <alexj> @seen ndm
13:29:02 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 21h 4m 40s ago, and .
13:29:09 <fasta> chessguy: Debian also runs on some BSD's.
13:29:10 <gwern> fasta: does cabal-install really work? I tried that out a week ago and it seemed pretty buggy
13:29:18 <RiX0R> fasta: Sure, but I want to make sure there's a real bug first... don't want to complain for nothing
13:29:19 <Cale> gwern: It works great
13:29:25 <fasta> gwern: a week ago it did work for me
13:29:29 <RiX0R> And the fastcgi package is not in Debian, so I don't have much to complain about there :(
13:29:30 <fasta> No, it doesn't work great.
13:29:32 <Cale> gwern: However, if built with Cabal-1.2.2.0, it's broken.
13:29:32 <fasta> It works.
13:29:42 <chessguy> the thought has occurred to me to get one of those macs that comes with xp installed in a vm
13:29:46 <gwern> Cale: ah, that must be it
13:29:51 <Cale> You have to build it with 1.2.1 or HEAD for it to work.
13:30:18 <doserj> it only works as good as the packages in hackage are up to date.
13:30:21 <Cale> Thereafter, you can reinstall 1.2.2.0, and it'll be fine.
13:30:33 <fasta> Great would be that I just did import Data.Foobar and when Data.Foobar doesn't exist it would look on Cabal to see whether there's such a package and tell me: Hi, do you want to install that package and continue with your work?
13:30:46 <dibblego> (liftM2 (>)) x y -- can I use less () somehow?
13:30:52 <Cale> Except that modules and packages aren't the same thing.
13:30:54 <byorgey> fasta: that would be pretty awesome =)
13:31:02 <fasta> There's zero integration currently, so it's not "great".
13:31:04 <RiX0R> If I install everything with Cabal, I'll be compiling the libraries right? So I need a lot of memory? Because I'm kind of working on a box with very little mem
13:31:06 <Cale> But eventually, it will be doing something like that :)
13:31:09 <byorgey> dibblego: liftM2 (>) x y should be fine.
13:31:10 <allbery_m> liftM2 (>) $ x y -- ?
13:31:25 <fasta> cabal-install is a very simple program and it's good that some people took the time to write the damn thing.
13:31:28 <gwern> fasta: dude, ubuntu has that (for packages) but they're building on literally years/decades of work
13:31:33 <dibblego> ah yes it is; I was more thinking of getting rid of (>) those ones
13:31:41 <Cale> allbery_m: nope :)
13:31:46 <gwern> *work in packaging
13:31:46 <fasta> gwern: dude?
13:31:52 <byorgey> dibblego: oh. no, then =)
13:31:53 <allbery_m> no, operators need the () when used as functions
13:32:01 <dibblego> np, cheers
13:32:02 <fasta> gwern: I don't really see your point though.
13:32:04 <Cale> allbery_m: That'd be liftM2 (>) (x y)
13:32:06 <gwern> (well, aren't you a dude?)
13:32:08 <byorgey> dibblego: let gt = (>) in liftM2 gt x y ?
13:32:26 <fasta> gwern: the features cabal-install needs to have are not difficult to implemtn.
13:32:29 <fasta> implement*
13:32:32 <dibblego> byorgey, it's not a big deal, I'll live with it :)
13:32:38 <allbery_m> yeh
13:33:30 <gwern> fasta: my point is that it takes an incredible amount of work to get to that point, and even then it's not perfect or great. case in point, debian's been working on packaging since, what, '92, or 15 years ago, and only lately has the 'you typed emacs but emacs is not installed. Would you like to install it?' feature been worth a damn enough for any distro to enable it by default and not as just another odd package
13:34:01 <fasta> gwern: Debian does not have that enabled, AFAIK.
13:34:17 <daniel_larsson> fasta: ubuntu does however
13:34:19 <fasta> gwern: I disagree that it takes a lot of work.
13:34:22 <fasta> daniel_larsson: I know that.
13:34:24 <gwern> fasta: ubuntu does, why I said 'distro'
13:34:42 <gwern> 'for any distro' includes ubuntu
13:34:49 <byorgey> if you can't get rid of 'em, just move 'em somewhere else =)
13:35:22 <fasta> gwern: the only thing that takes a lot of work in Debian is the mass of packages and renewed dependencies.
13:36:16 <fasta> gwern: Apt has quite a lot of tools, but there's nothing difficult about it. Everything required to implement it has been documented and does not take rocket science.
13:38:48 <roconnor> What are the applicative functor laws?
13:39:08 <fasta> In fact, someone(that is 1 person) implemented a smarter Apt, IIRC.
13:39:30 <sorear> roconnor: it says in the original paper
13:39:37 <sorear> @go Applicative programmming with effects
13:39:43 <sorear> @go Applicative programming with effects
13:39:44 <lambdabot> http://www.citeulike.org/user/zednenem/article/465691
13:39:44 <lambdabot> Title: CiteULike: Applicative Programming with Effects
13:39:45 <lambdabot> http://www.citeulike.org/user/zednenem/article/465691
13:39:45 <lambdabot> Title: CiteULike: Applicative Programming with Effects
13:39:51 <gwern> fasta: the Nix system?
13:39:56 <fasta> gwern: no
13:40:14 <roconnor> sorear: thanks
13:40:24 <fasta> gwern: just a reimplementation of Apt, but using smarter heuristics as the problem is NP-Complete.
13:40:51 <doserj> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Definition
13:41:26 <gwern> doesn't surprise me. I always figured it would be NP-complete or something as dependencies and stuff struck me as forming a graph
13:41:29 <roconnor> bah, uncurried functions
13:41:34 <roconnor> :(
13:41:46 <gwern> fasta: remember anything else about it?
13:41:55 <olsner> what's NP-complete about apt?
13:42:17 <roconnor> oh wait, there is a non-catatorical set of laws at the begining
13:42:18 <roconnor> :)
13:42:22 <fasta> gwern: no, I would have to search for it again.
13:44:12 <roconnor> @type (pure (.))
13:44:14 <lambdabot>     Ambiguous occurrence `pure'
13:44:14 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
13:44:14 <lambdabot>                           or `pure', imported from Control.Arrow
13:44:23 <roconnor> @type (Control.Applicative.pure (.))
13:44:23 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f ((b -> c) -> (a -> b) -> a -> c)
13:45:19 <dibblego> ?hoogle [a] -> a -> Bool
13:45:20 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
13:45:20 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
13:45:33 <dibblego> ?hoogle (Eq a) -> [a] -> a -> Bool
13:45:33 <lambdabot> No matches, try a more general search
13:45:39 <dibblego> ?hoogle (Eq a) => [a] -> a -> Bool
13:45:39 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
13:45:39 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
13:46:16 <roconnor> @pl (\f -> f x)
13:46:16 <lambdabot> ($ x)
13:46:30 <dibblego> ?hoogle [Bool] -> Bool
13:46:30 <lambdabot> Prelude.and :: [Bool] -> Bool
13:46:30 <lambdabot> Prelude.or :: [Bool] -> Bool
13:48:10 <defcons> how do I get the type definition of a function from prelude?
13:48:26 <nominolo> :t length
13:48:27 <lambdabot> forall a. [a] -> Int
13:48:31 <defcons> thanks
13:50:42 <roconnor> I wonder if I can define ideom brackets in Coq.
13:52:37 <byorgey> roconnor: would it motivate you if I said you can't?
13:53:23 <fasta> Using GHC makes me thing my machine is slow.
13:53:29 <fasta> think*
13:57:39 <Cale> fasta: What's your machine?
13:57:59 <fasta> Cale: 2800+ 1GB
13:59:06 <Cale> Hmm, that shouldn't be too much slower than my P4 2.4 GHz machine.
13:59:41 <KatieHuber> 2001 called, they want their computers back
14:00:22 <fasta> AFAIK, the best machines available now are not 4 times faster.
14:00:41 <fasta> (anything less is barely noticable, I guess)
14:01:27 <KatieHuber> compilation is the one thing where I *do* notice "minor" speed increases in CPUs
14:02:14 <Cale> Well, interestingly enough, I had one core from a Core 2 Duo running at 1.8 GHz do something in 6:30 what took my P4 2.4 GHz 19 minutes to do.
14:02:34 <KatieHuber> also, Core 2 seems to be *much* faster (MHz for MHz) at running GHC-compiled Haskell than previous Intel designs (eg. Core)
14:02:46 <fasta> Cale: AFAIK, an 2800+ is about the same as an 2.8P4.
14:02:48 <KatieHuber> yay for dynamic branch prediction ;)
14:03:45 <ptolomy> Are there any stable parser-combinators that use ByteString? I've been refactoring and improving a somewhat hacked up recursive descent bytestring parser I made, and I'm gradually converging on a crappy monadic parser combinator framework.. if there already exists a non-crappy one, I think I should use that instead.
14:05:25 <mrd> @where parsec-bytestring
14:05:25 <lambdabot> I know nothing about parsec-bytestring.
14:06:33 <TSC> I think you can use parsec, if you're prepared to do tokenising beforehand
14:07:04 <TSC> alex (the tokeniser) supports bytestring
14:07:12 <byorgey> wasn't xerox working on such a thing for SOC?
14:07:16 <sorear> ptolomy: there's Data.Binary.Get
14:07:18 <ptolomy> Hmm... I suppose I'm really just tokenisign anyway..
14:07:25 <ptolomy> I should check out Alex.
14:17:26 <dibblego> ?hoogle (Monad m) => m Bool -> t -> t -> m t
14:17:26 <lambdabot> No matches, try a more general search
14:17:33 <dibblego> is there if inside a monad?
14:17:57 <Botje> if .. then .. else works just fine inside a do block
14:18:36 <dibblego> do block, schmoo block :)
14:19:51 <conal> dibblego: i guess you mean as in your the type m Bool -> t -> ... .  i don't think there's any such standard definition, but easy to define.
14:19:57 <Toxaris> but if-then-else in a do-block works like (Bool -> m a -> m a -> m a), not (m Bool -> t -> t -> m t)
14:20:33 <dibblego> ?type \cond x y -> cond >>= if cond then x else y
14:20:34 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m a'
14:20:34 <lambdabot>     In the predicate expression: cond
14:20:34 <lambdabot>     In the second argument of `(>>=)', namely `if cond then x else y'
14:20:42 <dibblego> ?type \cond x y -> cond >>= return (if cond then x else y)
14:20:43 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m a'
14:20:43 <lambdabot>     In the predicate expression: cond
14:20:43 <lambdabot>     In the first argument of `return', namely `(if cond then x else y)'
14:21:12 <conal> ?type \cond x y -> cond >>= \ c -> return (if c then x else y)
14:21:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> b -> b -> m b
14:21:18 <dibblego> ?type \cond x y -> cond >>= \c -> return (if c then x else y)
14:21:19 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> b -> b -> m b
14:21:24 <olsner> :t return . (if' =<<)
14:21:24 <lambdabot> Not in scope: `if''
14:21:57 <conal> ?type \cond x y -> fmap (\ c -> if c then x else y) cond
14:21:58 <lambdabot> forall b (f :: * -> *). (Functor f) => f Bool -> b -> b -> f b
14:22:43 <conal> dibblego: the fmap one works and is more general than you were looking for.
14:22:54 <dibblego> cheers
14:23:02 <conal> ?pl \cond x y -> fmap (\ c -> if c then x else y) cond
14:23:02 <lambdabot> flip (flip . (fmap .) . flip . flip if')
14:23:07 <conal> yoiks!
14:24:00 <noteventime> Shouldn't it be posslbe to make functional programs take advantage of multiple processors implicitly?
14:24:21 <shapr> noteventime: If you use a graph reduction viewpoint, then yes.
14:25:03 <dibblego> ?hoogle ifM
14:25:04 <lambdabot> Network.Socket.throwSocketErrorIfMinus1_ :: Num a => String -> IO a -> IO ()
14:25:04 <lambdabot> System.Directory.createDirectoryIfMissing :: Bool -> FilePath -> IO ()
14:25:04 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
14:25:05 <noteventime> shapr: I have no idea about how GHC works :-) I just figured that the memory access problem would go away
14:25:22 <shapr> What memory access problem?
14:25:54 <noteventime> shapr: In imperative programming languages you always have the problem with multiple threads trying to access memory at the same time
14:26:16 <noteventime> So you have all the problems with dead-locks and mutexes
14:26:23 <shapr> Oh you mean write to memory at the same time.
14:26:27 <dibblego> actually, I wanted ifM :: m Bool -> m t -> m t -> m t after all that
14:27:30 <Toxaris> :t let if' c t e = if c then t else e in liftM3 if'
14:27:31 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
14:27:40 <shapr> noteventime: Men funktionel sprk bara skapa, dem byter inte...
14:27:47 <dibblego> where does if' exist?
14:27:58 <dibblego> ?hoogle if'
14:27:59 <lambdabot> No matches found
14:28:14 <Toxaris> dibblego: nowhere, afaik
14:28:17 <conal> and more generally, liftA3
14:28:44 <shapr> noteventime: Purely functional languages only create new values, never modify existing values.
14:28:44 <conal> it'd be handy to have if' in the prelude or standard lib
14:28:49 <noteventime> shapr: Det jag menar, d borde vll problemet med minnestkomst frsvinna, eftersom minnesanvndningen r deterministisk :-)
14:28:51 <TomMD> noteventime: The problems don't cease to exist, but I feel the solutions are more obvious.  Message passing, mutex/mutable variables, and STM (my favorite) are all available methods.
14:29:06 <noteventime> shapr: That's my point
14:29:25 <noteventime> Shouldn't the compiler be able to create all the needed safety features automatically
14:29:34 <noteventime> As there is no manual memory access
14:29:47 <shapr> noteventime: That's somewhat true...
14:30:15 <noteventime> I know nothing about compiler construction, so I may be way off. Maybe I should study Erlang
14:30:27 <Toxaris> :t let if' c t e = if c then t else e in liftA c t e
14:30:28 <lambdabot> Not in scope: `c'
14:30:28 <lambdabot> Not in scope: `t'
14:30:28 <lambdabot> Not in scope: `e'
14:30:36 <shapr> noteventime: I think you should also study Erlang, but Haskell is worthwhile!
14:30:41 <Toxaris> :t let if' c t e = if c then t else e in liftA if'
14:30:41 <lambdabot> forall t (f :: * -> *). (Applicative f) => f Bool -> f (t -> t -> t)
14:30:52 * Toxaris doesnt know what he does
14:30:58 <noteventime> shapr: I'm currently learning Haskell :-) I will go with it first
14:31:06 <shapr> noteventime: Are at Chalmers?
14:31:08 <shachaf> Toxaris: liftA?
14:31:08 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
14:31:23 <Olathe> @messages
14:31:23 <lambdabot> You don't have any new messages.
14:31:24 <noteventime> shapr: No, I'm planning to go to Uppsala
14:31:33 <Olathe> Lies.
14:31:37 <shachaf> Toxaris: Is there a point in that?
14:31:44 <shapr> Ah, Chalmers is pretty much the Mecca of Haskellers.
14:31:46 <pejo> noteventime, they might teach Erlang in some course there actually.
14:32:04 <shachaf> You may have been thinking of liftA3 or fmap, but liftA isn't that useful.
14:32:06 <noteventime> pejo: I know there's a course in functional programming, I think they use some ML variant though
14:32:09 <noteventime> Sadly
14:32:21 <shapr> noteventime: There are quite a few people from Chalmers here on #haskell.
14:32:34 <Tobsan> oh
14:32:40 <noteventime> shapr: I was planning on Chalmers when I was younger
14:32:43 <Tobsan> just to clarify, i do not study at chalmers...
14:32:55 <pejo> noteventime, I spoke to someone who did their "senior project" or something like that in Erlang - his entire class did that actually. Of course, this was a couple of years ago, so that might have changed.
14:32:56 <Tobsan> even though i have a chalmers account
14:33:07 <noteventime> shapr: I realised Uppsala would be better for doing theoretical computer science :-)
14:33:08 <dons> ?bug
14:33:08 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:33:12 <Toxaris> shachaf, dibblego: I wanted to point out that there is another usefull value of (m Bool -> m a -> m a -> m a) wich, unlike my definition above, doesn't evalute the non-choosen action
14:33:16 <shachaf> @ty let if' True x _ = x; if' False _ y = y in liftA3 if'
14:33:16 <lambdabot> forall b (f :: * -> *). (Applicative f) => f Bool -> f b -> f b -> f b
14:33:17 <shapr> noteventime: Anyway, CPUs of today are not based on graph reduction, so Haskell is compiled into something more procedural.
14:33:38 <noteventime> Sure, but GHC knows more about the problem than the C-compiler does
14:33:40 <shachaf> No, that's not it.
14:33:49 <noteventime> the program*
14:34:01 <shapr> noteventime: Yeah, I agree.
14:34:16 <Toxaris> shachaf, dibblego: but obviously, for this other value m has to be a Monad, not only Applicative, since the evaluation of the action depends on the returned Bool
14:34:16 <noteventime> Could be an interesting thing to study
14:34:32 <shapr> noteventime: Right now GHC has two flavors of parallelism, explicit is well-supported, and implicit is getting there.
14:35:02 <shapr> noteventime: You can explicitly spawn off a computation using forkIO and it will run on another core, that's the explicit flavor.
14:35:13 <noteventime> Interesting, I'll check them out when I have a better understanding of the language
14:35:22 <newsham> blog subject I'd love to see:  small piece of haskell code (factorial?) written down, data types translated, lambda lifted, mapped onto spineless-tagless g-machine, and then onto ia32 instructions.
14:35:28 <shapr> noteventime: The implicit parallelism is based on nested data parallelism, which is pretty much how graphics cards work.
14:35:43 <shapr> newsham: That would be nifty.
14:35:54 <newsham> with notes on how the translation was done, whatever ghc flags were used to get intermediate reps, etc
14:36:15 <newsham> (or other haskell compiler, doesnt have to be ghc)
14:36:24 <noteventime> shapr: Thanks for the info :-) Exactly what I was wondering about. You wouldn't have anything to read on the subject?
14:36:27 <gwern> I thought implicit only got you like double speed even if you assumed no overhead?
14:36:29 <shachaf> @ty \b t f -> b >>= (\x -> if x then t else f) -- You mean this?
14:36:29 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
14:37:07 <shapr> noteventime: Yeah, let me find the papers...
14:37:24 <shapr> ghc-smp - http://research.microsoft.com/~tharris/papers/2005-haskell.pdf
14:38:28 <shapr> noteventime: The implicit flavor is here http://www.cse.unsw.edu.au/~chak/papers/CLPKM07.html
14:38:34 <lambdabot> Title: Research Papers of Manuel Chakravarty
14:38:54 <noteventime> shapr: Thanks
14:38:54 <conal> Toxaris: good point about Monad vs Applicative in this example.  liftA3 (and liftM3) would execute both branches.
14:39:02 <Toxaris> shachaf: yes.
14:39:14 <shapr> noteventime: Those papers will probably be easier to understand once you're familiar with Haskell.
14:39:36 <shapr> noteventime: But feel free to ask questions about anything Haskell related.
14:39:42 <noteventime> shapr: I figured I'd save them anyway, so I know where I have them :-)
14:39:54 <noteventime> it*
14:39:55 <shapr> If you lose them, you can here on #haskell.
14:40:01 <shapr> ask*
14:40:04 <noteventime> shapr: Thanks again :-)
14:40:04 <shapr> gah, I'm dropping words
14:40:22 <newsham> just delivering them out of order
14:40:32 <newsham> shapr does not guarantee ordered delivery
14:40:32 <noteventime> Lol, by far the most helpful programming language related IRC-channel I've ever been on :-)
14:40:55 <noteventime> I remember the few tries I had in #c++
14:42:15 <gwern> well, to be fair, I think the #c++ regulars are burnt out
14:42:22 <TomMD> They make a sharp-c-plus-plus language?
14:42:39 <gwern> it can't be fun trying to deal with all the people who need help especially in a language like C++...
14:42:49 <hashendgame> tommd: you can stab yourself as well as shoot yourself in the foot with it
14:43:05 <gwern> in parallel
14:43:07 <newsham> prob a much higher ratio of academia/industry in here than c++
14:45:37 <shapr> noteventime: We're lucky, the Haskell programming industry hasn't yet exploded with newbies.
14:46:28 <dons> jedbrown: http://hackage.haskell.org/trac/ghc/ticket/1889
14:46:30 <lambdabot> Title: #1889 (Regression in concurrency performance from ghc 6.6 to 6.8) - GHC - Trac
14:46:52 <dons> jedbrown: also, i was asked by the shootout guys to document your code some more, which i did (there's a submission adding more docs)
14:46:53 <noteventime> shapr: Somehow I feel that it will take some time before Functional programming languages get that problem
14:46:57 <gwern> let's hope haskell doesn't explode for a few more years. let the various libraries and tool mature some more
14:47:26 <noteventime> When it explodes there'll probably something more interesting around :-)
14:47:33 <sorear> agreed
14:47:45 <ddarius> @bot
14:47:45 <lambdabot> :)
14:48:46 <newsham> prob wont explode as long as they keep breaking compatibility every new release :)
14:49:11 <dons> :P
14:49:39 <ddarius> Ingenius!  Avoid legacy code by forcing it to upgrade every release.
14:49:45 <dons> i love it.
14:49:45 <newsham> its true
14:50:25 <newsham> now if I can just give away a free haskell program to some large corpoation and charge them for each upgrade
15:02:34 <Cale> dons: Has the new concurrency system using PTM gone into 6.8?
15:05:18 <TomMD> Cale: You aren't expecting that to become any sort of default RTS, are you?  As far as I understand it, the performance is not sufficient for S. Marlow to switch.  Do you have information I haven't seen?  Will it be a compile time option?
15:05:40 <Cale> I don't know.
15:07:26 <Cale> I read the paper about it, and it seemed from that like they were happy with the system, despite the hit in performance.
15:21:01 <newsham> hrm.. instead of having "#ifdef __GLASGOW_HASKELL__\n,Typeable, Data\n#endif" all over the libs, why not #ifdef __GLASGOW_HASKELL__\n#define GHCTYPABLEDAT ,Typeable,Data\n#else\n#define GHCTYPABLEDAT\n#endif ?
15:23:02 <sorear> newsham: it would be too logical
15:23:45 <newsham> ifdef most abused language construct ever :(
15:24:26 <kawfee> shit, I got hot iron on my plastic button =[
15:25:52 <gwern>                    liftM (and . take n) $ getChanContents chan
15:26:08 <kawfee> wick with lots of solder paste works better
15:26:15 <gwern> that bothers me. is there any better way of forcing all teh stuff out of getChanContents?
15:27:02 <kawfee> lots of solder paste on my device wont do anything will it?
15:27:15 <kawfee> it's like covering it with a layer
15:27:19 <sorear> kawfee: you're aware this is #haskell?
15:27:19 <LoganCapaldo> @type getChanContents
15:27:20 <lambdabot> Not in scope: `getChanContents'
15:27:26 <kawfee> oops
15:27:28 <kawfee> heh
15:27:31 <kawfee> lol
15:27:34 <gwern> Control.Concurrent.getChanContents
15:27:47 <gwern> er, Concurrent.Chan
15:27:50 <sorear> gwern: you *cant* force all the stuff out of getChanContents!
15:28:05 <gwern> sorear: well, all the stuff I put in it then :)
15:28:07 <kawfee> sorear thanks
15:28:16 <sorear> gwern: it returns an infinite list!
15:28:33 <LoganCapaldo> reallyReallyDeepSeq? :)
15:28:57 <LoganCapaldo> @hoogle getChanContents
15:28:58 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
15:30:44 <LoganCapaldo> getChanContents = something like do { x <- readChan chan ; xs <- getChanContents chan ; return (x:xs) } ?
15:31:03 * LoganCapaldo wonders if readChan is called readChan
15:31:10 <LoganCapaldo> @hoogle readChan
15:31:10 <lambdabot> Control.Concurrent.Chan.readChan :: Chan a -> IO a
15:31:17 <LoganCapaldo> hey whdday know
15:31:23 * LoganCapaldo feels smart
15:31:44 <LoganCapaldo> Although maybe I just feel like the people who designed Control.Concurrent are smart
15:32:07 <LoganCapaldo> @hoogle Chan a -> Bool
15:32:07 <lambdabot> No matches, try a more general search
15:32:13 <LoganCapaldo> @hoogle Chan a -> IO Bool
15:32:13 <lambdabot> Control.Concurrent.Chan.isEmptyChan :: Chan a -> IO Bool
15:34:03 <LoganCapaldo> let slurpChan c = do { v <- readChan c ; if isEmptyChan c then return [v] else return (v:(slurpChan c)) } -- this so can't be right
15:35:04 <Saizan_> you've to synchronize with the writers to expect any deterministic behaviour
15:35:12 <Saizan_> with slurpChan i mean
15:35:30 <LoganCapaldo> let slurpChan c = do { v <- readChan c ; if isEmptyChan c then return [v] else do { vs <- slurpChan c ; return (v:vs) } -- still wrong but should at least typecheck now
15:36:13 <LoganCapaldo> Maybe you don't want a chan but an MVar [a] ?
15:36:28 <LoganCapaldo> just throwing out ideas
15:36:37 <Saizan_> isEmptyChan c :: IO Bool
15:37:04 <LoganCapaldo> d'oh
15:37:13 <dons> ?bug
15:37:13 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:38:05 <LoganCapaldo> let slurpChan c = do { v <- readChan c ; empty <- isEmptyChan c ; if empty then return [v] else do { vs <- slurpChan c ; return (v:vs) } -- I don't know why I feel compelled to do this
15:39:14 <Saizan_> ?hoogle MVar a
15:39:14 <lambdabot> No matches, try a more general search
15:39:21 <Saizan_> ?hoogle (MVar a)
15:39:21 <lambdabot> No matches, try a more general search
15:39:24 <Saizan_> ?hoogle MVar
15:39:25 <lambdabot> Control.Concurrent.MVar :: module
15:39:25 <lambdabot> GHC.Conc.MVar :: data MVar a
15:39:25 <lambdabot> Control.Concurrent.STM.TMVar :: module
15:40:44 <ptolomy> http://programming.reddit.com/info/60ggc/comments/c02gmcf  <- eep. "Scheme is tricky, so they dumbed it down to get ML, which is amenable to simpler type systems".. *boggle*
15:41:02 <newsham> heh
15:41:43 <LoganCapaldo> well yes a type system where types don't change at runtime and where values don't change their types at runtime is "simpler" <g>
15:42:15 * LoganCapaldo makes joke
15:42:18 <newsham> the internet is like an infinite stream of @keal
15:43:35 <LoganCapaldo> @hoogle readMVar
15:43:36 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
15:43:56 <newsham> ?keal
15:43:56 <lambdabot> haskell always said undefined
15:44:10 <LoganCapaldo> haskell isn't always on time
15:44:21 <Cale> @keal
15:44:21 <lambdabot> haskell always said undefined
15:44:23 <Cale> @keal
15:44:23 <lambdabot> ghc need to have plugin that allow copy paste in xp
15:44:27 <Cale> @keal
15:44:27 <lambdabot> better be atleast 16x16 color with extended ascii set
15:44:40 <LoganCapaldo> the copy paste one actually made sense to me
15:44:58 <LoganCapaldo> if he was talking about what I think he was talking about
15:45:08 <LoganCapaldo> should I now be scared?
15:45:29 <LoganCapaldo> @keal haul
15:45:29 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
15:46:04 <byorgey> @. elite keal
15:46:04 <lambdabot> i DON7 re4L|Y EA7 \/EGE7aB13s UN|3S5 (hee5e IS a vE9E+4B1E
15:46:05 <newsham> ghc needs to support copy and paste?
15:46:25 <TomMD> @quote 1337
15:46:26 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
15:46:29 <newsham> no ghc does not.  the terminal needs to and does support copy and paste
15:46:31 <LoganCapaldo> newsham: would you like to explain my theory about what he wa referring to?
15:46:37 <LoganCapaldo> ah nvm
15:46:38 <newsham> yes please!
15:46:50 <LoganCapaldo> seems liek you already know :)
15:47:22 <newsham> just that by default in cmd consoleyou need to select menu "mark" and menu "paste" to do operations
15:47:26 <newsham> unless you turn on quick edit mode
15:47:42 <Saizan_> ?type let forkIO' m = do { mv <- Control.Concurrent.newEmptyMVar; Control.Concurrent.forkIO $ m >>= \v -> Control.Concurrent.putMVar mv v; return mv }; parSequence ms =  mapM Control.Concurrent.takeMVar  =<< mapM forkIO' ms in parSequence -- gwern, you might use this instead of a Chan
15:47:43 <lambdabot> forall a. [IO a] -> IO [a]
15:48:21 <Ben`> how can I make a(n infinite) list with all the combinations of letters? eg. starting a, b, c, then aa, ab, ac then ba, bb, bc, etc.
15:48:52 <byorgey> Peyton-Jones, S. and Wadler, P. "Copy and Paste: A Framework for Value-Based Sharing Semantics in Haskell Programs"
15:48:56 <LoganCapaldo> > [ [a,b] | a <- ['a'..] , b <- ['a'..] ]
15:48:58 <lambdabot>  ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao",...
15:49:15 <Japsu> hmm, why does Peyton-Jones sound so familiar
15:49:20 <mrd> > sequence (replicate 2 ['a'..'z'])
15:49:21 <LoganCapaldo> byorgey: you are devious
15:49:30 <Japsu> oh.
15:49:30 <LoganCapaldo> that's a real paper isn't it?
15:49:31 <lambdabot>  ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao",...
15:49:31 <Japsu> right.
15:49:32 <Japsu> STM.
15:49:52 <byorgey> LoganCapaldo: sure it is, let me find the link...
15:49:55 <Japsu> @where stm
15:49:55 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
15:50:00 <Saizan_> > concatMap (flip replicateM ['a'..'z']) [1..]
15:50:01 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
15:50:19 <Ben`> Saizan_: thanks :)
15:51:10 <LoganCapaldo> > ['a'..]
15:51:10 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
15:51:30 <newsham> "" is a combination of "a..z"
15:51:44 <Saizan_> > concatMap (flip replicateM ['a'..'z']) [0..]
15:51:44 <lambdabot>  ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r",...
15:51:45 <byorgey> LoganCapaldo: here it is, http: //tinyurl.com/gmenh
15:51:50 <newsham> > concatMap (flip replicateM ['a'..'c']) [0..]
15:51:50 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
15:52:42 <LoganCapaldo> byorgey: thanks. (I think?)
15:52:52 <byorgey> hehe =)
15:53:42 <LoganCapaldo>  I so misread Ben`'s original question
15:54:06 <LoganCapaldo> and as trying to figue out why the ehck you guys started starting with a, b, c...
15:54:42 <LoganCapaldo> > iterate succ "a"
15:54:42 <lambdabot>   add an instance declaration for (Enum [Char])
15:54:47 <LoganCapaldo> blast
15:54:53 <mrd> > iterate succ 'a'
15:54:53 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
15:55:00 <LoganCapaldo> nah
15:55:06 <LoganCapaldo> not the definition of succ I wanted
15:55:32 <mrd> > succ (1,2)
15:55:32 <lambdabot>   add an instance declaration for (Enum (t, t1))
15:55:32 <lambdabot>     In the expression: succ ...
15:55:34 <LoganCapaldo> barring syntactically differences and the fact that ruby doesn't have iterate, that woulda worked perfectly in ruby
15:55:40 <mrd> succy
15:57:06 <Saizan_> LoganCapaldo: won't it include symbols like {, too?
15:57:14 <LoganCapaldo> that it would
15:57:16 <LoganCapaldo> nvm
15:58:28 <Saizan_> an instance for Enum a => Enum [a] would be nice :)
15:59:02 <Saizan_> uhm, + Bounded
15:59:36 <LoganCapaldo> yep i was thinking that
15:59:48 * LoganCapaldo tries it out
16:00:19 <LoganCapaldo> hmm
16:00:25 <newsham> "PLT Scheme is the cancer that is turning impressionable young minds into pulp. I had to work with it for a semester and I tell you it's the worst crock of shit I have ever come across. Hell, even Logo is more useful"
16:00:26 <LoganCapaldo> pred woudn't make much sense
16:00:37 <LoganCapaldo> oh no it would work
16:00:38 <newsham> you wonder why people bother going to school to learn programming when they hate it so much
16:00:52 <conal> newsham: what didn't you like about PLT Scheme?
16:01:04 <LoganCapaldo> toEnum and fromEnum might be bizzare
16:01:11 <Philippa> conal: it was a quote, I doubt it's newsham's opinion
16:01:14 <jeffz> newsham: who are you quoting?
16:01:32 <newsham> some stupid reddit thread: http://programming.reddit.com/info/60ggc/comments/
16:01:38 <conal> Philippa: oops.  thanks.
16:01:39 <newsham> it was an amusing read but I think i'm dumber now
16:02:26 <mrd> a language cannot be useful without curly braces
16:02:41 <lament> quite a lot of very smart people think anything outside the mainstream is a waste of time
16:02:57 <mrd> they must be very very smart
16:03:21 <lament> some of them are
16:03:24 <TomMD> Damn side languages - they should all go away.
16:03:58 <newsham> being forced to learn scheme and c++ and whatever else is part of the charm of going to school
16:04:27 <lament> sure, but you don't have to like it
16:04:31 <TomMD> Lets list all the hated side languages... or better yet - lets just list the ones that have a direct impact on us and call the rest a waste.  Haskell... C and Cmm by extention... F# due to close relation... OCAML for its contributing thoughts and for comparative benchmarking.... I'm running out of languages...
16:04:51 <mrd> C, C++ are side languages?
16:05:00 <newsham> lament: you dont have to, but you should probably reevaluate your school and career if you dont
16:05:13 <TomMD> mrd: No, "... list the ones that have a direct impact on us... "
16:05:16 <lament> newsham: well, you certainly don't have to like scheme
16:05:37 <newsham> its not like learning and using scheme is hard
16:05:37 <mrd> lament: the only excuse is that you prefer typed lambda calculus
16:05:42 <Botje> like haskell instead!
16:06:07 <newsham> if you dislike learning new languages, computers are probably not for you.
16:06:11 <dons> heh
16:06:14 <newsham> because by the time you retire you'll probably learn about 30more
16:06:16 <lament> newsham: sure, if you find it hard then you perhaps should reevaluate your career. But you don't have to like it :)
16:06:23 <Philippa> mrd: or syntax
16:07:03 <lament> newsham: consider: a parallel discussion could be going on in ##C++ with a similar comment about how terrible C++ is. And everybody is outraged.
16:07:09 <mrd> people who hates lisp for its syntax strike me as people who would hate cars because they are hard to push
16:07:26 <lament> newsham: it's a religious issue more than anything else.
16:07:32 <dons> mrd, that's an interesting one.
16:07:41 <ptolomy> Hm.. is there a name for the oft-flawed mindset that says, "Big deal, language X doesn't have feature Y, but it is trivial to add"..  when feature Y can be hacked (to various degrees of success) into almost any language, but most of the value is in standardization and an already-existing implementation.
16:07:52 <lament> mrd: you're saying that programmers don't normally have to deal with lisp's syntax?
16:07:53 <dons> mrd, isn't it more about hating cars because they're not as pretty as bicycles?
16:08:05 <newsham> I would rather not code in C++, but programming in c++ is still loads omre fun than not programming.
16:08:09 <Philippa> or rather, because they make bad bicycles and you want a bicycle
16:08:10 * dons tries to understand mrd's argument
16:08:12 <newsham> and learning it isnt terribly hard
16:08:13 <mrd> well perhaps.  but my point is more that -- you're not supposed to be pushing a car
16:08:31 <dons> and you're not supposed to be doing what with lisp parens, by that analogy?
16:08:31 <lament> but you _are_ supposed to be using lisp's syntax, you can't really avoid that...
16:08:33 <TomMD> Your not supposed to by typing syntax?  I've been doing it all wrong?
16:08:36 <mrd> right
16:08:38 <Philippa> no, I'm supposed to be pushing something else. Therefore scheme isn't appropriate
16:08:49 <Philippa> and thus I don't like it for what I'm doing. Perfectly reasonable
16:08:51 <mrd> oh, you're not supposed to be dealing with them yourself
16:08:57 <mrd> they're for structured editors
16:08:59 <lament> i have to agree with dons, cars are definitely less pretty than bicycles
16:09:09 <lament> mrd: you have to be _looking_ at the ugly mess!
16:09:14 <mrd> not really
16:09:15 <newsham> you've obviously never drooled over a porsche
16:09:19 * ptolomy likes syntax.
16:09:26 <lament> newsham: i have, but it's not the same
16:09:36 <Philippa> mrd: my problem isn't "OMG the parens!", so a structured editor isn't going to fix it
16:09:47 <Philippa> my preferred syntactic style'll still benefit from access to one if you've got one handy...
16:09:47 <mrd> I can practice a lot more editor-fu with lisp syntax than haskell.  but haskell makes up for that in other ways.
16:10:06 <Philippa> that's because your editors suck and need lisp syntax as a crutch
16:10:09 <ptolomy> In lisp, everything looks like a tree of tokens to the editor, which is nice. However, in lisp, everything looks like a tree of tokens to me, which isn't nice.
16:10:10 <lament> Lisp syntax is optimized for computers. Haskell syntax is optimized for humans.
16:10:14 <lament> <3 haskell haskell haskell
16:10:50 <lament> ptolomy: we pretty much said the same thing :)
16:10:55 <mrd> unfortunately haskell-style syntax comes with its own set of problems, like for example, when you want to add new features
16:10:57 <ptolomy> lament: Indeedy.
16:11:20 <newsham> how about a simple lisp/scheme preprocessor that automatically closes parenthesis using layout rules?
16:11:30 <lament> mrd: i thought it's more the lack of macros that prevented that?
16:11:37 <Cale> newsham: those exist
16:11:44 <Philippa> yeah, though it's misleading to pretend that we couldn't have syntax macros that worked neatly
16:11:52 <newsham> (also is an turing-complete editor a prerequisite, phila? ;-)
16:11:56 <mrd> it's a lot harder
16:12:37 <ptolomy> In almost every case that I've seen, I prefer a language with a human-oriented syntax that I can't arbitrarily extend but conveniently flexible semantics to a language in which I can write macros to do anything but has a machine-oriented syntax.
16:13:19 <mrd> i still don't accept that haskell-style syntax is necessarily human oriented
16:13:28 <mrd> we're used to it, so it's us-oriented
16:13:34 <ptolomy> That's true.
16:13:40 <lament> i think it's mathematician-oriented.
16:13:55 <mrd> it doesn't really look like mathematics on paper
16:13:58 <TomMD> Not entirely - any time I try to show a non-Haskeller code they wonder why the <- vs =.  Why the 'do' is needed, etc etc.
16:13:59 <Philippa> there're a number of aspects that're reasonably human-oriented
16:14:01 <mrd> not for complicated things
16:14:04 <lament> it does look like mathematics in ascii to me
16:14:28 <mrd> this becomes glaringly obvious when i translate papers into haskell code
16:14:29 <Philippa> TomMD: yeah, but they're actually wondering about the semantics
16:14:29 <newsham> mrd: it is definitely easier to deal with than a fully parenthesized linearization of the abstract syntax trees.
16:14:33 <ptolomy> Syntax is the user-interface to a language... a familiar interface is a nicer interface than an unfamiliar one unless there is a significant difference in the nature of the thing.
16:14:42 <newsham> so its "more human oriented" than such things
16:15:04 <newsham> (not that parenthesized ast's are unusable)
16:15:04 <lament> ptolomy: yes, people use the same argument to claim that all languages should look like C.
16:15:08 <mrd> let me say, sometimes it's nice not to have precedence parsing errors =)
16:15:25 <lament> i suppose haskell does look like c, it has curly brackets and semicolons ;)
16:15:37 <ptolomy> lament: Certainly. And, languages that look like C tend to do better. Since people are used to C-like languages, languages should probably look like C unless there is a compelling reason not to.
16:15:44 <Philippa> mrd: things like having both the equational syntax and lambdas, let and where etc are very much human touches. The same can be said about how the concrete syntax for pattern-matching and construction/application match up
16:15:46 <TomMD> Philippa: Thats kind of my point.  Even if I explain WHY it is there, they can still see three ways to make a compiler work with what they consider cleaner syntax (Hey, Axe that let and just have the compiler figure it out based on = or <-... or hey, axe that <- and... or hey, just assume a 'do' when...)
16:15:47 <mrd> i have a friend who defensively parenthesizes everything. in java even.
16:15:55 <lament> ptolomy: as far as i'm concerned, a compelling reason is called "Python" :)
16:16:03 <ptolomy> lament: Same here. :)
16:16:11 <mrd> yea pattern-matching being so well supported is definitely quite nice. it's also a liability though.
16:16:12 <newsham> you might trick a C programmer for 3 minutes, but they catch on when you say IO a or Monad.
16:16:20 <mrd> pattern-matching was supposed to come with
16:16:25 <mrd> 'views' to preserve abstractions
16:16:41 <nominolo> :t (***)
16:16:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:17:10 <nominolo> :t (&&&)
16:17:11 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:17:26 <Philippa> yeah. The reasons it's taken so long to sort out're semantic though
16:17:43 * ptolomy has stuck himself with lists numerous times as a result of the seduction of pattern matching.
16:17:48 <nominolo> :t (***) :: (~>) a b
16:17:48 <lambdabot>     Couldn't match expected type `~>' (a rigid variable)
16:17:49 <lambdabot>            against inferred type `(->)'
16:17:49 <lambdabot>       `~>' is bound by the polymorphic type
16:18:41 <nominolo> @hoogle a -> (a,a)
16:18:41 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
16:18:41 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
16:19:05 <twanvl> :t (***) :: (Arrow (~>)) => (a ~> b) -> (a' ~> b') -> ((a,a') ~> (b,b'))
16:19:06 <lambdabot> forall (~> :: * -> * -> *) a b a' b'. (Arrow ~>) => ~> a b -> ~> a' b' -> ~> (a, a') (b, b')
16:19:23 <mrd> i'd like to be able to use capital greek letters as variable names
16:19:34 <mrd> everyone calls alphabets \Sigma, but that won't fly
16:20:53 <mrd> also, screw the ASCII nonsense.  I want subscripts, superscripts, and 2-D syntax =)
16:21:05 <newsham> mrd: cant use you capital sigma in languages that take utf-8 input?
16:21:08 <ptolomy> This is out of left field, but anybody know what the chances are of GHC or some other major haskell compiler using a better record system?
16:21:37 <Philippa> hugs /has/ a better record system unless they took it out
16:21:39 <mrd> newsham: well i mean in Haskell
16:22:00 <Philippa> granted it's an interpreter rather than a compiler
16:22:17 <ptolomy> Oh. Well then.
16:22:20 * ptolomy re-examines the hugs notes.
16:22:22 <ptolomy> Trex?
16:22:52 <newsham> %format capsigma = "\Sigma" ?
16:23:27 <newsham> (I wish lhs2tex worked in win32)
16:23:53 <Philippa> that's the one, yeah
16:24:46 <hpaste>  LoganCapaldo pasted "instance (Eq a, Enum a, Bounded a) => Enum [a]" at http://hpaste.org/3860
16:24:50 <mrd> yea i should make an lhs2TeX-on-the-fly mode
16:25:21 <newsham> can you make Led do something like that?
16:25:45 <mrd> there's an emacs mode for LaTeX which does something like that already
16:26:19 <newsham> it shows rendered dvi?
16:26:48 <mrd> it keeps the dvi up to date
16:26:54 <mrd> no i think it displays in another window
16:27:25 <mrd> i mean you can get almost the same effect just by hitting C-c C-c compulsively.  i really don't know if it helps in any other fashion.
16:28:40 <Saizan_> i think it's inline
16:33:56 <pejo> mrd, auctex?
16:34:02 <pejo> With preview-something.
16:35:23 <ivanm> preview-latex
16:37:51 <newsham> does lhs2tex build in ghc6.8.1?
16:38:01 <newsham> Setup.hs:8:7: Could not find module `Distribution.Program':
16:38:17 <Zao> newsham: Too old cabal?
16:38:25 <newsham> 6.8.1 comes with new cabal
16:38:47 <Cale> unfortunately, it's also a broken cabal
16:38:58 <newsham> whats the proper solution?
16:39:22 <Cale> Well, it's not *too* broken. It's just that cabal-install will be broken if built with it.
16:39:56 <Cale> You can switch to Cabal-1.2.1 in order to build cabal-install, and things should be okay.
16:40:49 <Cale> hmm, I wonder where Distribution.Program is
16:41:12 <Cale> There's Distribution.Simple.Program
16:43:06 <dcoutts> nominolo: I've pushed the recent cabal make changes
16:43:31 <dcoutts> nominolo: I've not pushed all the commentary but I've still got it locally
16:48:40 <nominolo> k
16:56:48 <hpaste>  LoganCapaldo annotated "instance (Eq a, Enum a, Bounded a) => Enum [a]" with "Definition for succList that actualyl makes sense. Also cunning newtype derivery" at http://hpaste.org/3860#a1
16:57:23 <KatieHuber> damn, Data.Array is slow :/
16:58:08 <Pseudonym> At what?
16:58:18 <KatieHuber> dunno :)
16:58:23 <Pseudonym> :-)
16:58:31 <Pseudonym> Updates are inefficient, obviously.
16:58:35 <KatieHuber> I replaced [[a]] with Array (Int, Int) a
16:58:40 <KatieHuber> and it's a lot slower
16:58:45 <KatieHuber> I'm doing a bunch of updates, that could be it
16:59:05 <mrd> i switched from uarrays to parallel unlifted arrays with much better results
16:59:07 <KatieHuber> the code is shorter, and I know how to get diagonal slices, which I was having trouble with with [[a]]
16:59:28 <conal> mrd: what are "unlifted" arrays?
16:59:50 <mrd> strict, i suspect
16:59:51 <conal> mrd: and do you mean ChilliX's ndp stuff?
16:59:53 <mrd> yes
17:00:03 <conal> thanks
17:00:17 <mrd> but i took advantage of the fact that i didn't need diagonal slices :/
17:00:31 <mrd> so is ChilliX the guy to bug about what's up with Segmented arrays? =)
17:00:56 <conal> "Segmented"?
17:01:27 <mrd> an array broken up into 'segments' to simulate 2d arrays
17:01:47 <conal> ah
17:02:32 <mrd> i was pleasantly surprised with how fast the UArrs were, but GHC didn't indicate any parallel computation was taking place
17:04:12 <mrd> then i ran into that runtime system bug (which i've filed now)
17:06:38 <delaril> hi guys. can anyone tell me why this isn't valid? http://hpaste.org/3861
17:07:06 <mrd> valid in what way
17:07:21 <mrd> well it won't type
17:07:29 <Mr_Awesome> do b and (head b) have the same type?
17:07:30 <mrd> because type of 'b' is not the same as type of 'head b'
17:08:07 <delaril> mrd: oh.
17:08:17 <mrd> it's not a mapping function.  and you can invoke head on [] possibly.  and length is a bad idea.
17:09:05 <delaril> mrd: well, of course it's not finished.
17:09:38 <hpaste>  lekro pasted "basic numerals, undecidable instance" at http://hpaste.org/3862
17:09:41 <lekro> hi. what's an undecidable instance and why is there one in this code?
17:10:17 <delaril> mrd: why is length a bad idea?
17:10:28 <mrd> delaril: because it traverses the list
17:11:21 <delaril> mrd: this is bad because it takes more time, and won't work on infinite lists?
17:11:31 <mrd> lekro: well because the definition of the 2nd instance of Add depends on something of the same size
17:11:35 <mrd> delaril: basically
17:12:18 <mrd> lekro: if you're familiar with inductive definitions, you know its probably a bad idea to define something in terms of the same "size" thing
17:12:29 <mrd> ie. not a subterm
17:12:42 <lekro> well, a gets smaller
17:12:44 <delaril> hm. I think it's a bit strange for YAHT to have me define a mapping function, without really explaining the mapping function.
17:13:04 <mrd> lekro: ghc can't tell
17:13:07 <lekro> and b gets greater, so in lexicographical order the whole thing is "smaller"
17:13:36 <mrd> delaril: write something with this type: (a -> b) -> [a] -> [b]
17:14:25 <mrd> and since it is recursive, remember that it needs a base case for [] and a recursive case for (x:xs)
17:15:05 <KatieHuber> using UArray is a lot faster than just Array
17:15:06 <mrd> lekro: well, the undecidable instances flag tells ghc to not prove termination
17:15:17 <KatieHuber> still slower than [[a]] though :/
17:15:24 <mrd> yea it helps
17:15:32 <mrd> didn't help me, for some reason, when i tried it
17:15:41 <mrd> but usually
17:16:45 <curris> Hi, i'm trying to run lambdabot in ubuntu but i "cannot satisfy dependency haskell-src-any"
17:16:48 <lekro> hm, with instance (Add a b c) => Add (Succ a) b (Succ c) but ghc tells me (the Coverage Condition fails for one of the functional dependencies). why is that?
17:17:00 <lekro> -but
17:17:56 <delaril> mrd: aaaah, it all became much clearer. I never really wrapped my head around that (x:xs) bit, so I didn't consider it
17:19:06 <Saizan_> the coverage condition is another heuristic to guarantee termination of the type checker/inferrer, it checks that for every fundep a -> b the type you use as b is conteined in the type you use as a
17:19:42 <Saizan_> "contained", like e.g. s is contained in (State s)
17:20:47 <lekro> so can I write something like class Add a b c | a b -> c at all? c would (nearly) always be greater than a and greater than b, so neither a nor b will contain the type c
17:22:50 <Saizan_> well you can allow undecidable instances, but maybe i'm missremembering the condition
17:25:03 <Saizan_> The Coverage Condition. For each functional dependency, tvsleft -> tvsright, of the class, every type variable in S(tvsright) must appear in S(tvsleft), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance declaration.
17:25:10 <dibblego> ?src liftM2
17:25:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:26:28 <Saizan_> lekro: basically is what i said but restricted to type variables
17:26:30 <newsham> > let (+^) = liftM2 (+) in ((+3) +^ (*2)) 5
17:26:32 <lambdabot>  18
17:30:00 <delaril> mrd: wow, that was a lot simpler than I thought
17:30:07 <delaril> I think I have it now
17:34:31 <delaril> right. I feel like I just wasted the last two hours completely :P
17:36:37 <mrd> you learned something
17:36:51 <mrd> @src map
17:36:51 <lambdabot> map _ []     = []
17:36:51 <lambdabot> map f (x:xs) = f x : map f xs
17:37:31 <chessguy> @src >>= State
17:37:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:38:14 <mrd> don't mind lambdabot, she's testy
17:38:21 <newsham> ?src State (>>=)
17:38:21 <lambdabot> Source not found. Wrong!  You cheating scum!
17:38:23 <chessguy> whoops, i closed the wrong window
17:38:33 <newsham> ?src (State a) (>>=)
17:38:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:38:48 <mrd> ?src [] (>>=)
17:38:49 <lambdabot> m >>= k     = foldr ((++) . k) [] m
17:38:57 <chessguy> @src State
17:38:57 <lambdabot> Source not found. My mind is going. I can feel it.
17:39:11 <delaril> mrd: indeed, I did.
17:39:51 <nburlett> hey all
17:39:56 <nburlett> quick parsec question...
17:40:14 <nburlett> if I try to parse a number into an Int, and the number is invalid, I get prelude errors...
17:40:20 <nburlett> what's the best way to force a parsec error instead?
17:40:23 <mrd> using read?
17:40:31 <nburlett> mrd: yes
17:40:42 <newsham> design your parser so that read can never fail
17:40:46 <newsham> or dont use read to convert to an int
17:40:47 <mrd> er, well (1) use the Token lexer for parsing numbers, (2) use reads
17:41:03 <mrd> > reads "a" :: Int
17:41:05 <lambdabot>  Couldn't match expected type `Int'
17:41:11 <mrd> > reads "a" :: [(Int,String)]
17:41:13 <lambdabot>  []
17:41:24 <newsham> > foldl (\a b -> a*10+ord b) 0 "12345"
17:41:25 <lambdabot>  545673
17:41:33 <mrd> @hoogle natural
17:41:33 <lambdabot> Text.ParserCombinators.Parsec.Token.natural :: TokenParser st -> CharParser st Integer
17:41:33 <lambdabot> Text.ParserCombinators.Parsec.Token.naturalOrFloat :: TokenParser st -> CharParser st (Either Integer Double)
17:41:39 <newsham> > foldl (\a b -> a*10+(ord b-48)) 0 "12345"
17:41:39 <lambdabot>  12345
17:43:07 <nburlett> hm, so if I use reads, and I get back [], I can do something with Parsec to turn that into the right stuff
17:43:18 <mrd> like a failure?
17:43:18 <nburlett> or, I can import that Token.natural
17:43:24 <nburlett> mrd: yeah, like failure
17:43:46 <mrd> the Token combinators lex the input as well
17:43:48 <newsham> > parse (liftM (foldl (\a b -> a*10+(ord b-48)) 0) (many digit)) "" "234"
17:43:48 <lambdabot>   Not in scope: `digit'
17:44:05 <mrd> they all take a first parameter which is a language definition
17:45:10 <nburlett> oh, so I can't just use them directly within Parser?
17:45:17 <mrd> you can
17:45:29 <mrd> they are CharParsers
17:45:47 <newsham> nburlett: why is your parser accepting characters that can cause reads to fail?
17:45:56 <nburlett> newsham: good question :->
17:46:34 <nburlett> newsham: actually, that's an even better answer...
17:46:37 * nburlett smacks self on head
17:48:58 <wy> hello
17:49:20 <wy> ski_: hey
17:50:53 <wy> ski_: I managed to get it done without using possibility operators
17:51:15 <newsham> is there a function that turns Nothing into fail msg ?
17:51:22 <newsham> and Just a into a?
17:51:35 <conal> maybe
17:51:37 <newsham> ?hoogle Maybe a -> a
17:51:38 <lambdabot> Maybe.fromJust :: Maybe a -> a
17:51:38 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
17:51:38 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:51:38 <conal> ?ty maybe
17:51:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:52:18 <conal> newsham: fromMaybe
17:53:13 <newsham> maybe (fail "not a valid integer") id (str2int xs)   ?
17:54:03 <conal> :ty fail
17:54:12 <conal> ?ty fail
17:54:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
17:54:28 <wy> Can anyone explain to me why some code has this kind of manipulation on random seeds? for examle: seed = seed/p ?
17:54:35 <conal> newsham: are you in a monad?
17:54:36 <newsham> ahh..  s/id/return/
17:54:37 <ChilliX> mrd: You are using package ndp?
17:54:45 <conal> newsham: that'd do
17:55:21 <newsham> fromJustWithFail msg mb = maybe (fail msg) return mb
17:55:37 <conal> newsham: butare you really in a monad??  or is str2int a plain old function?
17:55:56 <newsham> str2int is a pure String -> Maybe Int
17:56:23 <conal> so no need for fail/return
17:57:06 <shachaf> Just use error?
17:57:18 <newsham> hypothetical situation: you're in a parser, you have a string, you want to convert that to an integer (and you were sloppy, so "read" can fail), if it fails you want to "fail", if it doesnt you want to "return" the integer value
17:57:50 <shachaf> newsham: Oh, so you do want return/fail, no?
17:57:53 <conal> newsham: i see.  fail & perhaps try another branch
17:58:10 <shachaf> Didn't ndm had a library which had that?
17:58:16 <shachaf> s/had/have/
17:59:35 <newsham> (many digit) >>= \ds -> fromJustWithFail "bad integer" (str2int ds)
17:59:59 <shachaf> newsham: That's not fromJustWithFail, though.
18:00:05 <Toxaris> newsham: have you written str2int yourself?
18:00:12 <newsham> :type \msg mb -> maybe (fail msg) return mb
18:00:17 <shachaf> newsham: That's returnFromJustWithFail.
18:00:41 <newsham> well it has to be a "return" if it can also "fail" :)
18:01:16 <ddarius_> :t maybe mzero return
18:01:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
18:01:19 <Toxaris> newsham: if yes, I would consider changing it's type from (String -> Maybe Int) to (Monad m => String -> m Int)
18:01:53 <Toxaris> newsham: then it would work out-of-the-box with every monad
18:02:47 <shachaf> Toxaris: That still won't give newsham the right fail message.
18:03:13 <newsham> whats the interactive command to make it not give modules in the prompt?
18:03:54 <Toxaris> shachaf: if he cares about sensible error messages, he could unslobby his parser so that read never fails :)
18:03:57 <newsham> (ghci)
18:05:22 <Toxaris> or use <?> to set some higher-level error message in the parsec part of the code
18:06:54 <shachaf> newsham: :set prompt
18:07:07 <shachaf> newsham: %s is replaced by the list of modules.
18:23:15 <hpaste>  newsham pasted "maybe sillyness with parser" at http://hpaste.org/3863
18:35:35 <newsham> why is "let xx = liftM2 (+)" an ambiguity error in ghci?
18:37:43 <ddarius> :t liftM2 (+)
18:37:47 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
18:38:19 <ari> Monomorphism restriction?
18:38:22 <ddarius> > let f = id in (f "a",f 'a')
18:38:24 <lambdabot>  ("a",'a')
18:40:30 <Beelsebob_> > let g h = h h 4 in g id
18:40:30 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
18:40:30 <lambdabot>     ...
18:40:36 <Beelsebob_> there you go
18:41:01 <Beelsebob_> oh wait
18:41:03 <Beelsebob_> brackets
18:41:09 <Beelsebob_> > let g h = h (h 4) in g id
18:41:10 <lambdabot>  4
18:41:12 <Beelsebob_> o.O
18:41:16 <Sprinky> Hey #haskell, I'm having a hard time building xmonad from the darcs branch
18:41:17 <Beelsebob_> that passes the type system?
18:41:29 <Beelsebob_> > let g h = (h h) 4 in g id
18:41:29 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
18:41:29 <lambdabot>     ...
18:41:37 <Sprinky> When I try building it, it tells me it can't find the Graphics.X11.Xinerama module.
18:41:40 <Beelsebob_> no, was right the fist time
18:42:02 <dmwit> Beelsebob_: I'm confused about that.
18:42:23 <Beelsebob_> dmwit: yeh, I'm being a moron, it actually needs Rank-2 types
18:42:29 <dmwit> g id 4 = (g id) 4 = (id (id 4)) 4 = (id 4) 4 = 4 4 = ???
18:42:32 <Beelsebob_> not monomorphism
18:42:35 <allbery_b> Sprinky: what version of the X11 module do you have installed?
18:42:38 <Beelsebob_> or lack of
18:42:49 <allbery_b> older ghc comes with an old X11 module which isn't sufficient for current xmonad
18:43:02 <newsham> g id id = (g id) id = (id (id id)) id = (id id) id = id id = id
18:43:07 <dmwit> Beelsebob_: Oh, never mind, I see what you did there.
18:43:10 <Beelsebob_> dmwit: what type does h have
18:43:12 <allbery_b> (the additions used to be in x11-extras but that was merged to create the new version of x11)
18:43:28 <Beelsebob_> dmwit: interesting example... unfortunately, completely irrelevant
18:43:32 <Beelsebob_> :)
18:44:12 <allbery_b> h's type is forall a. a -> a
18:44:23 <Sprinky> allbery_b: I'm using the darcs branch for that as well
18:44:31 <allbery_b> for which?
18:44:37 <Sprinky> For X11
18:44:54 <allbery_b> the x11 module is in darcs but not conveniently so, last I checked
18:45:06 <Sprinky> Well, I've got it, and it built.
18:45:15 <allbery_b> x11-extras is there but out of date and possibly the wrong namespace
18:45:24 <allbery_b> what does ghc-pkg list say about it?
18:45:32 <Sprinky> About X11?
18:45:49 <allbery_b> yes
18:46:10 <Sprinky> I've got versions 1.3.0 and the darcs version 1.3.0.20071111
18:46:41 <allbery_b> both?  does the error message for the "missing" module say anything about multiple modules?
18:46:52 <allbery_b> or perhaps hidden ones?
18:48:17 <Sprinky> Ah, I see that Setup.lhs is looking at version 1.3.0 and not the darcs version of X11.
18:48:23 <Sprinky> Would hiding X11-1.3.0 work?
18:48:58 <ivanm> someone gave me a link last week with the bibtex reference for the haskell 98 report, but I can't find it :s
18:49:13 <ivanm> anyone know of a good/official bibtex reference for it?
18:49:14 <allbery_b> or editing the cabal file to specifically use 1.3.0.20071111
18:49:39 <Sprinky> It's set to look for that version.
18:49:46 <Sprinky> In build-depends at least.
18:53:47 <jtxx000> hey, is there a "while" function for monads in the standard library somewhere or do i have to write my own
18:54:06 <TomMD> ?hoogle while
18:54:06 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
18:54:06 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
18:54:06 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
18:54:22 <dmwit> mapM, forM, forever, when, until
18:54:37 <ari> :t until
18:54:37 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
18:54:48 <dmwit> Whoops, not until. =/
18:55:11 <ddarius> "while" doesn't mean something specific enough (or it means something you really wouldn't want)
18:55:17 <dmwit> > forever Nothing -- hmm...
18:55:18 <lambdabot>   Not in scope: `forever'
18:56:02 <dmwit> > fix (>>) Nothing
18:56:03 <lambdabot>      Occurs check: cannot construct the infinite type: m = (->) (m b)
18:56:03 <lambdabot>     Pro...
18:56:12 <dmwit> bah
18:56:20 <dmwit> > fix . (>>) $ Nothing
18:56:21 <lambdabot>  Nothing
18:56:23 <dmwit> neat
18:56:23 <ddarius> There you go.
18:56:35 <ddarius> forever = fix . (>>)
18:56:59 <ddarius> Which brings up mfix
18:58:34 <jtxx000> all i want to do is read in lines from a socket until the EOF
18:59:02 <jtxx000> i really don't trust getContents, it seems like an abuse of lazyness
18:59:34 <dmwit> But if there were a library while, it would be just as lazy.
18:59:42 <ddarius> :t unfoldM
18:59:43 <dmwit> Almost everything in the libraries are lazy.
18:59:43 <lambdabot> Not in scope: `unfoldM'
18:59:48 <ddarius> :t unfoldrM
18:59:48 <lambdabot> Not in scope: `unfoldrM'
18:59:57 <dmwit> ?hoogle unfold
18:59:57 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
18:59:57 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
18:59:57 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
19:00:01 <ddarius> dmwit: Lazy IO isn't the same as lazyness
19:00:12 <dmwit> hmm
19:00:12 <dmwit> ok
19:00:39 <jtxx000> yea, lazy IO makes me uneasy
19:01:15 <jtxx000> i suppose i could just define
19:01:15 <jtxx000> while cond f = when cond $ f >> while cond f
19:01:28 <jtxx000> but i'd rather use a standard library call if there is one
19:02:28 <ddarius> There's nothing that's exactly that, but I'm not sure that is exactly what you want.  Don't you want to do something with the stuff you read in? or is it done "record"-wise?
19:03:28 <jtxx000> every line is a record
19:04:02 <jtxx000> and is processed and then sent off
19:05:08 <Pseudonym> http://www.haskell.org/haskellwiki/Let_vs._Where <- Less NPOV, now.
19:05:09 <lambdabot> Title: Let vs. Where - HaskellWiki
19:05:40 <chessguy> @type when
19:05:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:05:52 <chessguy> jtxx000, i don't think that will work, will it?
19:06:00 <chessguy> cond isn't monadic, so its value will never change
19:06:49 <chessguy> @type while cond f = when cond $ f >> while cond f
19:06:49 <lambdabot> parse error on input `='
19:06:58 <jtxx000> ah, you're right
19:07:06 <chessguy> @type let while cond f = when cond $ f >> while cond f in while
19:07:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m ()
19:07:10 <jtxx000> i thought when took a monad as the bool
19:07:15 <newsham> ?src foldM
19:07:15 <lambdabot> foldM _ a []     = return a
19:07:15 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
19:07:21 <ddarius> :t liftM when
19:07:21 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
19:07:29 <chessguy> @hoogle whileM
19:07:29 <lambdabot> No matches found
19:07:37 <ddarius> Pseudonym: When did NPOV become a requirement for the Haskell Wiki?
19:08:33 <allbery_b> someone requested it for that article on -cafe
19:08:37 <Pseudonym> It's not a requirement, but it is a virtue.
19:08:55 <Pseudonym> Where "NPOV" here means "fairly representing the opinions of good Haskell programmers everywhere".
19:09:19 <ddarius> allbery_b: And I was considering sending the same question on haskell-cafe.
19:09:31 <chessguy> @type let whileM p f x = forM (liftM not . p) f x in whileM
19:09:32 <lambdabot>     Couldn't match expected type `[a]'
19:09:32 <lambdabot>            against inferred type `a1 -> m Bool'
19:09:32 <lambdabot>     In the first argument of `forM', namely `((liftM not) . p)'
19:09:37 <ddarius> Pseudonym: But, but if f' isn't top-level should I use a let or a where to nest it?
19:10:00 <chessguy> @type let whileM p f x = forM_ (liftM not . p) f x in whileM
19:10:00 <lambdabot>     Couldn't match expected type `[a]'
19:10:00 <lambdabot>            against inferred type `a1 -> m Bool'
19:10:00 <lambdabot>     In the first argument of `forM_', namely `((liftM not) . p)'
19:10:06 <Pseudonym> I believe I mentioned that,.
19:10:19 <Pseudonym> The other option is simply not to export it.
19:10:49 <jtxx000> @type let while cond f = cond >>= (`when` (while cond f))
19:10:50 <lambdabot> <command line>:
19:10:50 <lambdabot>     Could not find module `L':
19:10:50 <lambdabot>       Use -v to see a list of the files searched for.
19:10:54 <ddarius> Pseudonym: No, you gave the option not direction.
19:10:57 <Pseudonym> Ah, right.
19:11:02 <Pseudonym> I mentioned you could use either.
19:11:25 <chessguy> @type let while cond f = cond >>= (`when` (while cond f)) in while
19:11:25 <lambdabot> forall (m :: * -> *) t. (Monad m) => m Bool -> t -> m ()
19:11:37 <Pseudonym> Interestingly, whichever one you use, GHC is going to do the worker-wrapper translation for you anyway.
19:12:13 * ddarius makes light of the whole silliness of this "debate"
19:12:42 <Pseudonym> Of course.
19:12:46 <chessguy> jtxx000, http://osfameron.vox.com/library/post/for-loops-in-haskell.html may interest you, particularly the comments
19:12:50 <Pseudonym> The thing is, it _is_ a style question.
19:12:54 <ddarius> The only strong unenforced rule for let/where is not to mix them.
19:13:12 <Pseudonym> And, let's face it, style is something you don't learn from rules.
19:13:17 * mrd mixes them and flaunts it
19:13:23 <Pseudonym> You learn it by having to maintain code that's written with bad style.
19:13:55 <ddarius> Pseudonym: Yes, but using let (or using where) isn't bad style.
19:13:59 <Brian`> hi guys,
19:14:15 <Brian`> what book/websites do you recommend me to learn about Category Theory?
19:14:23 <Pseudonym> I agree.  But some uses of let are bad style, and some uses of where are bad style.
19:14:28 <Pseudonym> Brian: Where are you at now?
19:14:31 <ddarius> Brian`: Why do you want to learn Category Theory?
19:14:46 <ddarius> Pseudonym: Definitely, but that isn't what this debate is.
19:14:55 <Brian`> ddarius: I thought it would be more helpful to know Haskell better..
19:15:09 <ddarius> Brian`: Not really.  At least not for day to day programming.
19:15:25 <Pseudonym> It is good for the soul, though.
19:15:51 <ddarius> "Begone points!  The Lord commands you, begone!"
19:16:13 <mrd> Category soup is good for the tummy
19:16:38 <chessguy> @remember mrd Category soup is good for the tummy
19:16:38 <lambdabot> Done.
19:16:39 <ddarius>    delicious
19:17:00 <Brian`> lol
19:17:42 <ddarius> (Wow, that did actually work out better than I originally thought)
19:17:58 <firefly> Brian: http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717
19:18:00 <lambdabot> http://tinyurl.com/yv7c8v
19:18:07 <firefly> "Basic Category Theory for Computer Scientists"
19:18:41 <Brian`> cool, thanks firefly
19:18:44 * ddarius points out that comultiplication usually uses 
19:18:58 <mrd> that book is pretty technical though, so
19:19:08 <ddarius> So?
19:19:12 <mrd> nu
19:19:19 <Pseudonym> Brian: Are you starting from scratch?
19:19:50 <Brian`> Pseudonym: what do you mean by from scratch?
19:20:06 <ddarius> Brian`: What math/logic/computer science do you know?
19:20:06 <Korollary> I would go for the freely available stuff online first before spending actual money. Maybe you wont find the subject so interesting.
19:20:10 <Pseudonym> I mean have you never seen any category theory before?
19:20:13 <Pseudonym> What algebra have you done?
19:20:25 <Brian`> hm.. not much
19:20:28 <Pseudonym> Are you at a university with a well-stocked library and interlibrary loan facilities?
19:20:29 <Brian`> i'm just an undergraduate student..
19:20:32 <Pseudonym> Ah!
19:20:36 <Pseudonym> Then start borrowing!
19:20:48 <Brian`> from library?
19:21:04 <firefly> or fellow students
19:21:04 <mrd> or from other students.  perhaps while informing them.
19:21:05 * ddarius does recommend Category Theory for the Working Mathematician if you don't mind doing background work.
19:21:13 <Pseudonym> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/0521478170
19:21:16 <lambdabot> http://tinyurl.com/2xn93k
19:21:22 <Pseudonym> Personal opinion, that's the best one to start with.
19:21:33 <Brian`> cool :)
19:21:41 <Pseudonym> But if you're an undergrad rather than an high school student, you won't need to do the exercises much.
19:21:48 <Pseudonym> Just go through the material, then get a decent book.
19:21:51 <firefly> Before you buy, you should google for courses on category theory and look through the PDFs on their homepages.
19:22:09 <Pseudonym> firefly: If you've got a university library at your disposal, you don't NEED to buy.
19:22:13 <Pseudonym> Yet.
19:22:19 <ddarius> There are quite a few introductions to category theory online, several aimed at computer scientists.
19:22:32 <Brian`> okay.
19:22:38 <firefly> I'm still very happy to have the dragon book.
19:22:49 <Pseudonym> Me too.  Though isn't there a new edition?
19:22:50 <Brian`> I'm just wondering, what are your guys background?
19:22:55 <Brian`> like having master or phd degree?
19:22:58 <firefly> And a first edition of Tanenbaum on Networks.
19:23:00 <Brian`> working as a fulltime employee at some company?
19:23:04 <Pseudonym> Postgrad dropout.
19:23:26 <mrd> b.s.
19:23:34 <ddarius> Brian`: There are people here who are in high school, people with no college, people with degrees in not computer science, people with computer science degrees of various levels etc.
19:23:47 <Brian`> i c..
19:24:02 * chessguy has an undergrad in CS, but isn't doing anything interesting with it...yet
19:24:17 * ddarius has pretty much no college
19:25:17 <Pseudonym> I am still working at a university, though.  Doing nanotech firmware stuff.
19:25:43 <Brian`> cool~ which university are you working at?
19:25:51 <Pseudonym> RMIT
19:26:04 <Pseudonym> Which you probably haven't heard of.
19:26:29 <Brian`> no.. haven't heard of it
19:26:41 <Brian`> but just a quick google search told me it's in Australia?
19:26:48 <Pseudonym> Yeah.  Imagine a cross between MIT and a polytechnik design school.
19:26:59 <ddarius> Very convenient for Pseudonym, as he, also, is in Australia.
19:27:00 <Pseudonym> That's pretty much RMIT.
19:27:03 <Pseudonym> Yes!
19:27:08 <Brian`> :)
19:27:13 <Brian`> anyone living in new york?
19:27:18 <newsham> hmm, what happened to "PLT Online"?
19:27:22 <Pseudonym> 18 million, last I heard.
19:27:28 <Pseudonym> So yeah.
19:27:29 <newsham> they had several books about category theory and related topics
19:27:29 <ddarius> @wiki Haskell user locations
19:27:29 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_user_locations
19:27:36 <newsham> all online for free
19:27:37 <mrd> nobody lives there its too crowded
19:28:25 <newsham> http://www.cs.uu.nl/wiki/Techno/ProgrammingLanguageTheoryTextsOnline
19:28:26 <Pseudonym> You know, this should be redone as a kmz.
19:28:27 <lambdabot> Title: Techno / Programming Language Theory Texts Online, http://tinyurl.com/37xq5g
19:28:48 * ddarius knows neither what "this" nor what "kmz" is.
19:29:24 <Pseudonym> I'm suggesting that Haskell_user_locations should be ported to Google Earth.
19:29:44 <ddarius> Probably.
19:29:55 <Korollary> newsham: franka must have moved it or something
19:30:01 <newsham> do peole still use google earth?
19:30:09 <newsham> kor: yah, I think that wiki is the new reincarnation
19:30:30 <Pseudonym> I use it to give people directions all the time.
19:31:29 <newsham> you guys are keeping a list of icbm coordinaes to all know haskell programmers?
19:31:41 <firefly> I was just browsing through the XMonad sources and sat this:
19:31:43 <firefly> -- | A 'trace' for the X monad. Logs a string to stderr. The result may
19:31:43 <firefly> -- be found in your .xsession-errors file
19:31:43 <firefly> trace :: String -> X ()
19:31:43 <firefly> trace msg = io $! do hPutStrLn stderr msg; hFlush stderr
19:31:53 * ddarius isn't on that list, but then he isn't all that productive either.
19:31:54 <firefly> Why would they ever need to explicitly flush stderr?
19:32:09 <firefly> It normally autoflushes after each write, doesn't it?
19:32:17 <firefly> That's the normal rule in C, anyway.
19:32:28 <ddarius> And if things aren't "normal"
19:33:48 <firefly> who from the outside of the program can tell the program's I/O library to change its buffering mode?
19:34:12 <ddarius> firefly: xmonad is configured via Haskell code
19:34:26 <newsham> does anyone have a rendered map of this userlocation data online?
19:34:44 <ddarius> newsham: There used to be, I don't know if there still is.
19:34:59 <firefly> yes, but once you let people do that, you have to accept that they might want to do really dumb things.
19:34:59 <hpaste>  dataangel pasted "a little parsec help? :)" at http://hpaste.org/3865
19:35:57 <newsham> dataangle: whats the problem?
19:36:36 * Pseudonym isn't that productive either, FWIW
19:36:48 <Pseudonym> I write more lines of opinion than Haskell code these days.
19:37:06 <dataangel> newsham: I describe it in the comment at the top of the paste. I'm trying to parse binary and octal numbers based on a prefix, but parsec won't let me have both work at the same time (parsing binary breaks octal and vice versa). I'm probably thinking incorrectly about how the parsers combine or something
19:37:33 <newsham> are you familiar with "try" ?
19:37:42 <newsham> wait, nevemrind, you shouldnt need try
19:37:48 <firefly> (or choice)
19:37:51 <dataangel> newsham: In other languages in the context of exceptions ;p
19:38:01 <newsham> ahh, yes, you need "try"
19:38:12 <Pseudonym> There is no try.
19:38:17 <newsham> try parseBinNumber <|> parseOct Number
19:38:20 <newsham> err. whats it called?
19:38:25 <newsham> the backtracking operator in parsec
19:38:36 <firefly> it means "try this parser and see if it works".  If it doesn't you wan't get an error message and the next parser after the <|> will be tried instead.
19:38:47 <dataangel> I thought the behavior was that <|> was sort of like "parser or". So it would try each and pick the one that succeeded.
19:39:12 <newsham> data angel: the problem is after parsing at least one char (ie. "#") it doesnt try any other alternations
19:39:29 <newsham> since you have two items with a shared prefix ("#") you need to backtrack slightly
19:39:32 <newsham> after failing to match one
19:40:30 <firefly> dataangel: only if they begin with different characters.
19:40:30 <newsham> its called "try" in the parsec documentation (http://legacy.cs.uu.nl/daan/download/parsec/parsec.html)  is that not the name in the standard libs now?
19:40:37 <dataangel> newsham: Err, weird. Why would you want it to work that way? I mean as like a parsec design thing
19:40:51 <EvilTerran> efficiency?
19:40:54 <firefly> why wouldn't it?  It's not weird at all.
19:40:57 <newsham> dataangel: backtracking is expensive and it makes you explicitely ask for it?
19:41:12 <newsham> firefly: correctness over efficiency would suggest trying all alternations until one worked
19:41:18 <firefly> NO!
19:41:36 <newsham> no?
19:41:36 <firefly> Sometimes you might want to control which one is tried when.
19:41:47 <newsham> thats not what alternation means.
19:41:51 <EvilTerran> if "when" matters, haskell is not the language for you
19:42:01 <newsham> which is fine, as long as you are clear that <|> is not alternation.
19:42:15 <firefly> EvilTerran: in order to end up with the desired parse, I mean.
19:42:16 <newsham> but it is a valid design point
19:42:26 <dataangel> firefly: Dunno, try all paths just seems like a natural model for a parse
19:42:27 <dataangel> r
19:42:39 <EvilTerran> dataangel, see ReadP
19:42:41 <newsham> another valid design point would be to try all alternations and return all matches as valid parses
19:43:02 <newsham> just because one design point was picked doesnt mean the others are not valid and interesting
19:43:16 <firefly> absolutely right -- that's what GLR gives you.
19:43:26 <firefly> Happy can do that.  Even Bison can do that.
19:44:01 <newsham> doing all would be pretty inefficient in a recursive descent though...
19:44:09 <firefly> Sometimes backtracking parsers are just easier to work with than having to throw away the undesired parses later in the process.
19:44:18 <newsham> *nod*
19:44:52 <newsham> side-effect bearing parsers are kind of a pain to deal with when you have non-determinism :)
19:45:31 <newsham> so is there no "try" in the parsec in the std libs?
19:45:42 <firefly> yes, there is.
19:46:02 <firefly> The parser I've been playing with in the last two weeks use it.
19:46:15 <newsham> ahh, Text.ParserCombinators.Parsec.Prim.try
19:46:23 <newsham> why did someone say there's no "try"?
19:46:24 <chessguy> @hoogle try
19:46:25 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
19:46:25 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
19:46:25 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
19:46:45 <newsham> there is only do?
19:47:06 <EvilTerran> @go do or do not, there is no try
19:47:17 <lambdabot> http://www.quotedb.com/quotes/42
19:47:17 <lambdabot> Title: Do, or do not. There is no 'try.' by Jedi Master Yoda
19:47:23 <newsham> dataangel: you got your stuff working?
19:47:24 <wli> I've been itching for GLR parser combinators for some time.
19:47:42 <newsham> why not just a GLR parser generator?
19:47:53 <newsham> I think it would be fun to write on in haskell
19:48:21 <dataangel> newsham: yes, thanks :)
19:48:49 <wli> GLR parser generators (a) have been done and (b) are nowhere near as useful esp. when the grammar is generated on the fly for whatever reason.
19:48:52 <firefly> How about the debugging support that the Utrecht parser combinator libraries are supposed to have?
19:48:54 <firefly> http://www.cs.uu.nl/wiki/HUT/ParserCombinatorsFAQ
19:48:55 <lambdabot> Title: HUT / Parser Combinators FAQ
19:49:03 <firefly> Look at the bottom of the web page
19:49:14 * firefly wants that for Parsec
19:49:15 <newsham> wli: how about writing a different <|> that parsed [a] instead of a?
19:50:02 <wli> newsham: -EWTF???
19:51:18 <newsham> instead of  Parser a <|> Parser a -> Parser a    define   Parser a <||> Parser a -> Parser [a] ?
19:51:28 <newsham> err, I guess that doesnt directly compose.
19:51:45 <newsham> Parser [a] <||> Parser a -> Parser [a]
19:52:17 <newsham> and a lifter for Parser a -> Parser [a]  (liftM return)
19:52:23 <wli> The suggestion has what could be called "relevance issues."
19:52:58 <newsham> care to go into more detail?
19:53:43 <wli> I'm not sure how much detail there is to go into beyond "This has absolutely nothing to do with GLR parser combinators."
19:54:15 <newsham> hmm.. I guess you need to alter the bind combinator too..
19:54:21 <Brian`> hey, in http://www.cse.unsw.edu.au/~dons/data/Prelude.html how come == and /= are defined in terms of the other? isn't it recursive definition? does it still work?
19:54:22 <lambdabot> Title: Haskell 98 Prelude
19:54:26 <newsham> but anyway, all of the modifications to parsec are pretty straightforward
19:54:36 <ddarius> Brian`: Those are defaults.
19:54:46 <newsham> at least for normal parsing (error productions might be more of a headache?)
19:55:04 <Brian`> ddarius: but at least one of them must be defined, not in terms of the other, right?
19:55:10 <newsham> brian: so that instances are free to define only one instead of having to define both
19:55:13 <ddarius> Yes (ish)
19:55:26 <Brian`> k that makes sense :)
19:56:33 <wli> Mostly it seems that one needs to do something like pArrows with enough tagging to reconstruct the grammar from a graph search of the data structure built from the combinators. "The modifications to Parsec" seem to be unrelated.
19:56:57 <wli> As does the combinator mentioned elsewhere.
19:57:43 <newsham> why do you need to tag at all?  its context-free.
19:58:22 <wli> To terminate in the presence of cycles.
19:58:24 <newsham> if a particular grammar item can result in several parses, those can all be used to replace the non-terminal.
19:58:49 <newsham> oh, you want to handle arbitrary grammars including degenerate ones?
19:58:58 <newsham> I think you could make a simple GLR that didnt handle degenerate cases pretty easily
19:59:06 <newsham> are the degenerate cases worth worrying about?
19:59:16 <wli> The data structure built by the combinators may have cycles.
19:59:56 <wli> newsham: Correct handling of boundary cases are what distinguish correct from incorrect programs, but that is unrelated to the issue at hand.
20:01:03 <newsham> I think the more difficult problem with GLRs is handling side effects while parsing an ambiguous grammar.
20:01:18 <newsham> if you don't handle any side effects when parsing at all then you might as well use a parser generator
20:01:34 <newsham> since the benefit of combinator-based parsing is the ability to intersperse side effects
20:01:55 <newsham> ie. the fixity example you gave last month
20:02:03 <wli> You expect programs to invoke happy and then dynamically link the code in?
20:02:23 <newsham> no, I dont expect that programs should alter their grammar at runtime ;-)
20:02:48 <wli> newsham: Then you essentially ban parser combinators.
20:02:59 <newsham> [18:00] < newsham> if you don't handle any side effects when parsing at all then you might as well use a parser generator
20:03:21 <newsham> also there's no reason you couldnt invoke a parser generator at runtime.
20:03:38 <newsham> just because happy doesnt have a runtime API (I assume thats the case based on your comments) doesnt mean it couldnt
20:03:56 <newsham> I have a parser generator that can be accessed at runtime just fine
20:04:22 <newsham> (its not written in/for haskell)
20:04:33 <wli> Let's try dogslow, dynamic linking, needing someplace to put the generated lib and the hassle of dynamically loading it, etc.
20:04:38 <gwern> dons: I still don't quite understand. why does strictly reading a file into memory not result in constant usage? as each entry is converted to int and summed, that much more could be gced
20:04:42 <newsham> you dont need dynamic linking.
20:04:55 <dons> gwern: it would load the whole file with getContents
20:04:56 <newsham> parser generators usually generate a table that is used to drive a parsing generator
20:05:01 <dons> i.e. O(n) allocation at startup
20:05:09 <wli> newsham: Then how are you supposed to load the code generated by the parser generator?
20:05:10 <newsham> generating a table and using it at runtime without serializing it is actually easier than spitting it out to a file
20:05:15 <gwern> dons: right. and then it's constant from there
20:05:24 <newsham> err.. drive a parsing engine...
20:05:26 <gwern> of course memory usage is going to increase at the beginning...
20:06:01 <dons> yes, which is against the rules.
20:06:09 <newsham> you can generate code instead of a table, but thats the exception rather than the norm (and makes more sense in low level languages like C (with gotos) and assembly)
20:06:11 <dons> (i have previously submitted such entries)
20:06:32 <wli> newsham: That would be fantastic. Real parser generators are not usable in such a fashion and most of the meaningful code related to the parsing algorithm is spewed out in strings.
20:06:53 <gwern> hm. well, if you're sure. it's a pity, because that cut something like 30% off runtime for me
20:07:15 <gwern> dons: incidentally, who was it thatw as working on parallel QuickCheck? I think I have some workable code I'd like to get his feedback on
20:07:20 <newsham> wli: perhaps happy should be split up into a cmd line utility, a table generator and a parsing engine.
20:07:37 <newsham> to allow programmers easy access to it at runtime while still supporting the legacy mode
20:07:53 <dataangel> How do I get 'show' to parse escaped characters? For example, putStrLn $ show "hello\n" doesn't actually put a newline at the end even though putStrLn "hello\n" does.
20:08:25 <gwern> dataangel: putStrLn automatically puts a newline at the end, iirc. what does putStr 'hello\n' do?
20:09:02 <newsham> show converts the string to its ascii representation.
20:09:11 <dataangel> gwern: It does a line break as expected
20:09:32 <gwern> @src putStrLn
20:09:32 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
20:09:35 <newsham> ie. with quotes and escaped quoting for the strange characters
20:09:50 <gwern> hm. so I would expect 'putStrLn' that string to result in two newlines
20:10:09 <newsham> dataangel: perhaps you dont want the "show"
20:12:18 <wli> newsham: If you're not spitting out code that has to be compiled but instead allow the parse to proceed directly, you've got parser combinators, not a parser generator.
20:12:26 <dataangel> it's confusing because I have it taking a string with the escape slash and the escape character as actual distinct characters, but then returning the real escape, so ["\\", "t"] should become '\t'. But show seems to be interpreting '\t' as ["\\", "t"].
20:13:12 <newsham> wli: not entirely.  parsec for example is based on combinator functions.  but parser generators usually take in a data representation of the grammar and do a bunch of processing on that data representation and spit out a table of actions for a parsing engine.
20:13:28 <newsham> they dont really work like combinators
20:13:40 <newsham> i mean, you could have some generators which do work that way.
20:13:44 <newsham> but the ones I'm aware of dont.
20:13:45 <hpaste>  dataangel pasted "function to parse escape chars" at http://hpaste.org/3866
20:14:06 <wli> newsham: According to your definition, I want a parser generator that works at runtime.
20:14:37 <newsham> wli: yes.  the "spit out" doesnt have to be a serialization to a disk file
20:14:47 <newsham> the "spit out" could just be the return of an API function
20:15:12 <wli> newsham: Why would it ever need to do locking with disk files? All it wants to do is output it to a file, not use lockfiles.
20:15:24 <newsham> huh?
20:15:52 <newsham> oh.. serialization == marshalling to a data stream.  not locking.
20:15:54 <newsham> sorry.
20:16:22 <newsham> "you dont have to spit the table out ot a file as code"
20:16:33 <dataangel> I think my problem is I start with ["\\", "t"], and my parser transforms it to '\t', but then show translates it back to ["\\", "t"], which is bizarre
20:16:44 <wli> Well, that's basically my definition of a parser generator.
20:16:48 <newsham> tab = genParser grammar;  tree = runParseEngine tab input
20:16:52 <dataangel> > show '\n'
20:16:56 <lambdabot>  "'\\n'"
20:17:17 <dataangel> what the heck is '\\n'? That can't be a single character.
20:17:29 <newsham> "\\" represents the backslash character
20:17:30 <shachaf> dataangel: The \ is escaped.
20:17:38 <shachaf> dataangel: Because it's a string.
20:17:54 <Zao> Things shown with show are usually suitable to be read with read.
20:18:00 <newsham> data angel: I dont think "show" does what you might think it does.
20:18:03 <wli> newsham: Those would be used on the results of parser combinators while still being able to call them parser combinators tc.
20:18:34 <newsham> wli: parser combinators mean someting very specific.  using combinator functions to bulid bigger parsers out of smaller parsers.
20:18:46 <newsham> that doesnt describe what most parser generators do (even the ones that dont write out to disk)
20:19:35 <dataangel> oh right show converts to string...
20:19:37 <newsham> but it sounds like our disagreement is entirely about semantics.
20:19:55 <dataangel> I guess that example makes sense but the behavior in my code is still weird...
20:19:56 <wli> newsham: Use the parser combinators to build up a grammar-describing structure. etc.
20:20:51 <dataangel> I think you're right, I don't want the show here :)
20:21:36 <newsham> wli: sounds like grammar combinators.
20:21:45 <newsham> ie Gram <|> Gram -> Gram
20:23:26 <wli> newsham: That structure may be cyclic, so tag nodes in order to feasibly search in finite time. A postprocessing pass is required to convert that to a directly usable grammar. Then apply GLR.
20:29:44 <wli> So they wouldn't quite be "grammar combinators" either.
20:37:49 <dataangel> What's the best way to do a case insensitive string comparison?
20:38:17 <newsham> > map toUpper "test" == "TEST"
20:38:20 <lambdabot>  True
20:38:32 <shachaf> newsham: That's probably not the best.
20:38:40 <shachaf> newsham: At least use toLower.
20:38:48 <faxathisia> ((==) `on` (map toLower))
20:38:50 <newsham> why at least use toLower?
20:39:06 <faxathisia> > ((==) `on` (map toLower)) "HeLLo" "hElLo"
20:39:06 <lambdabot>  True
20:39:33 <newsham> if you have string constants, `on` will be slower, no?
20:39:46 <faxathisia> I would not imagine that `on` is slower
20:39:53 <faxathisia> If it becomes a real problem.. maybe
20:40:05 <newsham> by doing maps over both strings instead of just one
20:40:29 <shachaf> newsham: There was a discussion about that on -cafe at one point.
20:42:38 <Spark> is toUpper just a bit op or does it know about locales and stuff
20:43:10 <newsham> ?src toUpper
20:43:10 <lambdabot> Source not found. :(
20:43:57 <faxathisia> shachaf: What did they say?
20:44:08 <shachaf> faxathisia: Trying to find it.
20:44:25 <shachaf> faxathisia: Some letters have two uppercase or lowercase versions, I think.
20:44:38 <faxathisia> oh :S
20:44:53 <newsham> interesting
20:46:58 <dataangel> Why is toLower better than toUpper?
20:48:15 <lament> because upper case is ugly!
20:48:34 <newsham> all the more reason it stands out so well in your srcs :)
20:49:20 <gwern> @src toLower
20:49:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:49:52 <shachaf> dataangel: Neither is good for true case-insensitive comparisons.
20:50:48 <hpaste>  dataangel pasted "Two questions on parse char function" at http://hpaste.org/3867
20:50:57 <dataangel> shachaf: why?
20:52:39 <zeeeee> i'm writing an ftp client using ftphs, which uses Network (connectTCP, etc). to deal with failures, i'd like to be able to abort blocking operations. how should i do this?
20:52:48 <dataangel> shachaf: nm, just read on trac about alternate languages :)
20:53:17 <zeeeee> i can think of a few approaches: (1) the sure-fire way is to use the low-level Network.Socket for non-blocking io. can't reuse ftphs, must rewrite everything from scratch
20:53:25 <zeeeee> (2) use async exceptions
20:53:32 <zeeeee> however, i'm not sure if that's safe to use
20:53:37 <zeeeee> (for this purpose)
20:53:49 <shachaf> dataangel: Are you sure you aren't mixing up the two sides of the ->?
20:53:52 * dataangel wonders if there's some way to parse "space" and "newline" instead of parsing a whole word then matching them
20:54:12 <shachaf> Or, rather, you want to map toLower?
20:54:23 <dataangel> shachaf: Err, I don't think so. If they write "#\space" it should become ' '
20:54:29 <dataangel> oh yeah :P
20:54:32 <zeeeee> and i'm not entirely sure *how* to use it (how to limit the async exceptions to occur only in certain points, namely the blocking ops)
20:54:37 <shachaf> Right, I was confused by the toLower.
20:54:43 <shachaf> (That only works on Chars.)
20:54:47 <dataangel> just fixed it
20:54:51 <dataangel> still get the syntax error oddly
20:54:58 <dataangel> wonder if emacs is messing up
20:55:00 <shachaf> Also, try to avoid length.
20:55:09 <newsham> wli: http://hpaste.org/3868 ?
20:55:13 <zeeeee> (earlier, by safety, i'm referring to the state of things in IO)
20:55:29 <dsilva> is there a guide to mixing different monads?
20:55:38 <zeeeee> anyway, hints would be appreciated
20:55:42 <shachaf> dsilva: You mean monad transformers?
20:55:52 <dsilva> shachaf: no idea on the terminology
20:56:06 <dsilva> shachaf: i mean a situation where I'm using MonadReader and IO together, for example
20:56:15 <shachaf> @hoogle ReaderT
20:56:16 <lambdabot> Control.Monad.Reader.ReaderT :: r -> m a -> ReaderT r m a
20:56:16 <lambdabot> Control.Monad.Reader.ReaderT :: newtype ReaderT r m a
20:56:16 <lambdabot> Control.Monad.Reader.mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
20:56:35 <dsilva> shachaf: say, if I want to implement a recursive 'ls' where the current directory is implicit in the Reader but I want 'ls' to print as it goes
20:57:26 <dibblego> dsilva, use System.FilePath.Find, it rocks (thanks bos!)
20:57:47 <newsham> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
20:57:48 <lambdabot> Title: Monad Transformers Step by Step
20:58:27 <newsham> has an example using ReaderT with IO
20:58:29 <dsilva> dibblego: looks cool, but the point was for me to learn about dynamically scoped variables in haskell
20:58:31 <hpaste>  dataangel pasted "How is this implementation of parseCharacter? No use of 'length'" at http://hpaste.org/3869
20:58:41 <dibblego> dsilva, righto then :)
20:59:02 <dsilva> cool, thanks for the pointers :)
20:59:51 <newsham> data: do you want to parser zero characters as well?
21:00:28 <dataangel> newsham: You mean if #\ is followed by 0 characters, or something else?
21:00:40 <dataangel> err, followed by no characters I mean
21:00:40 <newsham> data: "many" will parser zero or more instances
21:01:07 <newsham> why not do:     parseSpace :: Parser Char; parseSpace = string "space" >> return ' '
21:01:10 <dataangel> newsham: If it parses 0 of them, the case match will fail so it'll be OK right?
21:01:26 <newsham> parseNewline = string "newline" >> return '\n'
21:01:50 <newsham> parseChar = string "#\\" <|> parseNewline <|> parseSpace
21:01:50 <dons> ?users
21:01:50 <lambdabot> Maximum users seen in #haskell: 412, currently: 359 (87.1%), active: 12 (3.3%)
21:02:03 <dons> hey kids. how's the lambdas today?
21:02:08 <dons> beta reducing?
21:02:16 <newsham> err..   do { string "#\\";  parseNewline <|> parseSpace }
21:02:30 * faxathisia waves to dons
21:02:38 <dons> hey faxathisia !
21:02:40 <Zao> dons: Y are you asking? :)
21:02:46 <faxathisia> lol
21:02:50 <shachaf> dons: Always.
21:02:56 <dons> Zao: :)
21:03:06 <dataangel> newsham: because you have to account for when just a plain old character follows instead of the words 'space' or 'newline'
21:03:09 <newsham> oops, I forgot an alternative for a single character
21:03:37 <dons> so anyone played with the ghci debugger yet?
21:03:39 <newsham> <|> anyChar
21:03:47 <dons> you can backtrace exceptions... :)
21:03:52 <dons> shapr: tried it?
21:03:52 <newsham> dons: as soon as ghci runs on my freebsd :(
21:04:05 <dataangel> newsham: Dose the order of <|> matter? So if <|> anyChar is put last, it'll check for space and newline first?
21:04:06 <Zao> newsham: ghci runs on my freebsd.
21:04:14 <shachaf> dataangel: Yes.
21:04:19 <shachaf> newsham: What's the problem?
21:04:21 <dataangel> noice :D
21:04:22 <newsham> zao: you arent running amd64 version
21:04:27 <Zao> Oh right.
21:04:43 <Zao> newsham: I doubt that my P4 would like that one much.
21:04:53 <newsham> data: yes, order is important.
21:05:09 <newsham> and you need to use   try parseSpace <|> try parseNewline <|> anyChar
21:05:15 <newsham> because of the prefix thing again.
21:05:17 <newsham> oops
21:06:09 <newsham> so   #\newline will be '\n and  #\n will be n
21:06:11 <newsham> yes?
21:07:46 <zeeeee> i'm writing an ftp client using ftphs, which uses Network (connectTCP, etc). to deal with failures, i'd like to be able to abort blocking operations. if i rewrite everything from scratch, i can do anything (eg non-blocking sockets), but to reuse ftphs, will asyncexceptions do? i wouldn't know how to use them in this case (to limit the scope of the exceptions to certain points), and also whether they're safe (leave stuff in IO in  a consi
21:07:46 <zeeeee> stent state)
21:09:17 <shapr> dons: No, but it sounds awesome.
21:10:04 <dons> shapr: i'm going to write a little blog post to illustrate it
21:10:07 <zeeeee> (alternatively, if there are any networking libs that speak ftp, i'd love to know)
21:10:14 <zeeeee> *any other
21:10:15 <dons> you catch the exception, and then step back through the source to find it
21:10:17 <shapr> dons: Good idea
21:10:21 <uebayasi> cjs, hey hey
21:10:26 <dfranke> Well, I quit my job today.
21:10:28 <zeeeee> **any other, that also support async io
21:10:31 <dons> dfranke: wow.
21:10:36 <dfranke> Off to work on my Haskell-based startup full-time.
21:10:36 <dons> dfranke: doing something else instead?
21:10:41 <dons> double wow
21:11:04 <dons> what are you going to work on?!
21:11:41 <dfranke> A distributed RDBMS.
21:12:07 <dons> be sure to lean on the community :)
21:12:38 <dons> you get to give a talk at CUFP next year now :)
21:13:02 <zeeeee> (amazingly, when i use forkIO to get 2 threads, and call a blocking operation like connectTCP in one, the other can continue to run - can anyone explain this magic?)
21:13:23 <dons> its not blocking the haskell runtime?
21:13:25 <weitzman> Is there a simple command to list all the cabal packages you have installed?
21:13:30 <dons> ghc-pkg list
21:13:33 <weitzman> Thanks
21:13:43 <shapr> Where's the darcs repo for mtl?
21:13:47 <weitzman> Well then, me and Setup.lhs are having a disagreement
21:13:54 <zeeeee> dons, it doesn't seem to be
21:14:03 <zeeeee> dons, i *seem* to remember reading somewhere about this
21:14:22 <weitzman> On the one hand, ghc-pkg says  /home/weitzman/.ghc/i386-linux-6.8.1/package.conf:   X11-1.3.0, X11-extras-0.4
21:14:23 <dons> shapr: darcs.haskell.org/packages/mtl ?
21:14:27 <zeeeee> a post by simon marlow, something about how blocking ops actually spawn new os threads
21:14:30 <dons> weitzman: --user ?
21:14:34 <shapr> dons: Ah, I didn't try /packages/
21:14:35 <weitzman> On the other, xmonad Setup.lhs says Setup.lhs: At least the following dependencies are missing:
21:14:35 <weitzman>     X11 ==1.3.0
21:14:35 <zeeeee> which is kinda disturbing
21:14:45 <dons> weitzman: build with --user
21:14:49 <dons> its a new cabal tightening
21:14:50 <weitzman> I'm not at the build yet
21:14:53 <weitzman> I did configure
21:15:00 <dons> if you install as user (X11), you need to configure as --user, xmonad
21:15:02 <weitzman> Bu that fixed it
21:15:07 <weitzman> *t
21:15:08 <weitzman> Thanks
21:15:13 <dons> since it won't search the user database by default
21:15:17 <dons> dcoutts: ^^ why?
21:15:23 <dons> lots of users trip over this
21:15:37 <dons> apparently xmonad is the only thing making people install libraries as --user :)
21:15:55 <weitzman> Oh dear. "Could not find module `Data.Set'" I don't like where this is going
21:15:59 <dons> containers
21:16:04 <weitzman> Is "hidden"
21:16:05 <dons> you on 6.8? but not with darcs xmonad?
21:16:16 <weitzman> I have 6.8.1
21:16:20 <weitzman> I believe
21:16:21 <dons> which then requries 'containers' added to the build-depends file
21:16:24 <dons> then you should be fine
21:16:37 <weitzman> Where do I find this build-depends file?
21:16:40 <dons> 6.8/xmonad 0.4.1 is supported in #haskell only
21:16:43 <dons> in the .cabal file for xmonad
21:16:49 <dons> it has a line build-depends: (sorry)
21:18:41 <weitzman> dons++
21:19:35 <newsham> zeee: you sure the underlying implementation doesnt just use select to simulate the blocking action on a non-blocking handle?
21:20:13 <zeeeee> newsham, are you asking about impl of ftphs or of network?
21:20:18 <zeeeee> i know ftphs uses connecttcp
21:20:32 <newsham> your "can anyone explain this behavior" quesiton
21:20:37 <zeeeee> i don't know how connecttcp is written, but i assume it's blocking
21:21:16 * allbery_b is under the impression that actual blocking is VeryBad so it gets converted into something that allows other threads to run
21:21:34 <zeeeee> allbery_b, that would actually be VeryCool
21:21:38 <allbery_b> so it blocks the thread it's in but others continue to run.
21:21:58 <allbery_b> you could use strace/ktrace/truss/whatever to verify if you cared
21:22:12 <zeeeee> i think i will
21:22:27 <zeeeee> but that was more of a side question for me :)
21:23:10 <allbery_b> basically the ghc runtime will do most blocking stuff as nonblocking when it can and forks a new OS-level thread when it can't to make sure the runtime itself doesn't block
21:23:17 <dons> shapr: so i just intentionally broke hscolour, adding a head [] way deep down
21:23:30 <shapr> Whyso?
21:23:31 <dons> then loaded up ghci, ran main, dropped into the debugger, back traced ,and found the bug
21:23:35 <shapr> ohh
21:23:36 <shapr> cool!
21:23:39 <dons> blog time
21:24:08 <zeeeee> allbery_b, hold on. how does it fork a new thread when it's currently inside a blocking syscall?
21:24:18 <dons> *Main> :trace main
21:24:25 <dons> Stopped at <exception thrown>
21:24:25 <dons> _exception :: e = GHC.IOBase.IOException
21:24:32 <dons> [<exception thrown>] *Main> :hist
21:24:32 <dons> -1  : readColourPrefs (Language/Haskell/HsColour/Colourise.hs:42:14-21)
21:25:20 <allbery_b> it doesn't.  blocking syscalls are expected to be tagged as such (via FFI) so that the runtime knows to fork a new OS thread to invoke them
21:25:34 <shapr> dons: That'll be way useful in daily work.
21:25:45 <allbery_b> if you don't do so, the runtime will indeed block... but this is considered VeryEvil
21:25:46 <dons> shapr: yeah
21:26:07 <allbery_b> I suspect the ghc folks would spank anyone caught doing so in a released library
21:27:27 <allbery_b> because you're violating a fundamental assumption of the ghc threading model
21:28:09 <zeeeee> allbery_b, so the rts maintains an unbounded thread pool for blocking calls?
21:29:10 <allbery_b> not sure.  I was under the vague impression that there was a single OS thread dedicated to blocking FFI calls (created when needed)
21:29:24 <allbery_b> which implies serialization
21:29:47 <allbery_b> but this is probably a question for someone like Igloo (?) who knows more about the implementation
21:30:11 <allbery_b> what I know is just enough to have reasonable certainty that if I do something that will block, it will only block the Haskell thread it is invoked in
21:30:49 <zeeeee> ok, i found the thread i was thinking of: http://www.nabble.com/Unbound-threads-and-FFI-t741787.html
21:30:50 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Unbound threads and FFI
21:31:28 <Pseudonym> http://arxiv.org/abs/0711.2010
21:33:15 <allbery_b> ok, that seems to say there are multiple OS threads as needed if a call cannot be made nonblocking
21:33:21 <shapr> I have a long involved question...
21:34:04 <allbery_b> the key here is that socket connect *can* be made nonblocking; a proper implementation will set the socket nonblock and use select() to check for readiness, so it isn't necessary to spawn a new OS thread
21:34:16 <zeeeee> right
21:34:17 <shapr> Problem: HAppS saves a transaction into an on-disk log before the transaction is executed. Users create state transforming functions, but those can't be serialized.
21:34:17 <allbery_b> but I don't know the actual implementation of the library you're using
21:34:40 <dons> what's the most beutiful 5 line haskell fragment people can think of?
21:34:45 <zeeeee> allbery_b, well, it just uses Network.*, so that still holds
21:35:09 <shapr> So HAppS uses Template Haskell to create a datatype with constructors that represent those functions. Then another layer of functions is created that handles that extra fluff.
21:35:12 <dons> he who provides this 5 lines will be cited as having immaculate taste in my blog today... :)
21:35:13 <zeeeee> dons, i think it starts with: x <- newIORef
21:35:19 <dons> boo, not zeeeee
21:36:03 <shapr> But I have this vague intuition that the extra two layers might be gotten rid of if arrows were used instead.
21:36:45 <shapr> And I'm trying to work through this intuition... any advice or suggestions?
21:36:54 * dons goes with some stream fusion code :P
21:37:04 <Pseudonym> dons, there's a problem with that.
21:37:11 <Pseudonym> Are you using the source code, or the generated code?
21:37:14 <Pseudonym> Or the implementation?
21:37:16 <dons> source please
21:37:25 * Pseudonym is looking
21:37:41 <dons> for markup purposes (i'm showing how to debug head [] failures, in hscolour, which needs code to markup)
21:38:11 <shapr> Is my idea completely full of codswallop?
21:39:08 <mrd> perhaps something involving runCont
21:39:22 <dons> i think Pseudonym probably has some nice mathy stuff hany
21:39:24 <dons> handy
21:39:27 <dons> let's see..
21:39:50 <Pseudonym> Not a lot in 5 lines, though.
21:40:09 <dons> well, 5-10 fragment. just something cute
21:40:16 <mrd> what haskell function exceeds 4 lines anyhow
21:40:47 <dons> good point, mrd
21:43:41 <Pseudonym> It's longer than 10 lines, but I love this:
21:43:43 <Pseudonym> http://andrew.bromage.org/darcs/simpleCompiler/
21:43:44 <lambdabot> Title: Index of /darcs/simpleCompiler
21:43:50 <Pseudonym> It's a compiler.  To assembler.
21:44:21 <Pseudonym> In, like, 150 odd lines of code including the run-time system.
21:44:26 <Pseudonym> Of course, it only compiles integers.
21:44:28 <Pseudonym> But still.
21:45:27 <ivanm> what do you mean by only compiling integers?
21:45:38 <ivanm> you mean it converts integers to machine equivalent?
21:45:42 <mrd> > read "123" :: Int
21:45:42 <lambdabot>  123
21:45:53 <Pseudonym> I mean it compiles the equivalent of:
21:46:00 <Pseudonym> int foo() { return 42; }
21:46:04 <Korollary> > unread "Int" :: 123
21:46:04 <lambdabot>  Parse error at "123" (column 17)
21:46:13 <Pseudonym> You give it 42, and it generates and compiles assembler to do that.
21:46:24 <mrd> Korollary: twisted!
21:46:27 <ivanm> so it only does returning functions?
21:46:38 <Pseudonym> It was an exercise to see how much code you need to generate and compile assembler.
21:47:22 <Heffalump> pre-Harpy?
21:47:25 <dons> its very nice, but a bit long :)
21:47:32 <dons> you should get a blog, Pseudonym :)
21:47:42 <Pseudonym> Nobody tell dons where my blog is, okay?
21:47:49 <ivanm> heh
21:48:33 <dons> if its not on planet haskel, it doesn't exist. aggregators be damned
21:48:57 <Pseudonym> Aggregators _are_ damned, but they do the job.
21:49:08 * dons writes aggregators for a living 
21:49:10 <dons> oh the irony
21:49:33 <Korollary> seriously?
21:49:51 <Pseudonym> That's not irony, it's hypocrisy.
21:49:51 <dons> http://galois.com/xdomain_projects.php
21:49:51 <lambdabot> Title: Cross Domain Technology Services
21:50:09 <ivanm> dons: so only haskell-related blogs on planet haskell exist? so, what about all those haskell blogs not on planet haskell? or non-haskell blogs?
21:50:55 <Pseudonym> I'm curious how the "blogosphere" section of HWN gets compiled.
21:50:56 <dons> only blogs on planet haskell exist, yes.
21:50:57 <Korollary> They exist in #haskell-blah
21:51:07 <dons> Pseudonym: rss aggregator :)
21:51:14 <Pseudonym> Aha!
21:51:15 <ivanm> heh
21:51:22 <Pseudonym> So HWN be damned by association.
21:52:02 * dons goes back to blogging
21:52:12 <ivanm> is damnation a recursive function? i.e. if f is damned and f relates to g, does g automatically become damned?
21:52:44 <Korollary> that's transitive
21:52:53 <ivanm> whoops, yes, you're right
21:52:58 <Korollary> sort of
21:53:05 <Korollary> no it's symmetric
21:53:13 <Korollary> my brain is a mush right now
21:53:26 <ivanm> isn't symmetric "if f damns g, then g damns f" ?
21:53:39 <ivanm> closure?
21:53:55 <Korollary> ok, there are two relations
21:54:03 <Korollary> being damned and being related to another entity
21:54:20 <ivanm> *nod*
21:54:22 <Korollary> maybe it's an equivalence class?
21:54:26 <ivanm> hmmm...
21:54:46 <Korollary> the class of the damned
21:55:20 <Pseudonym> Oh, I'd forgotten this.
21:55:26 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 100
21:55:28 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
21:55:56 <faxathisia> :O!!!!
21:55:58 <ivanm> that's ugly
21:56:02 <Pseudonym> It is!
21:56:03 <faxathisia> Pseudonym: Cool!!
21:56:10 <ivanm> but yes, definitely cool
21:56:13 <faxathisia> is it infinite?
21:56:20 <Pseudonym> That number at the end, the 100.
21:56:24 <Pseudonym> That's the number of digits you request.
21:56:26 <OceanSpray> what the hell is it?
21:56:27 <faxathisia> :(
21:56:33 <ivanm> does that relate at all to the lazy pi paper? http://users.info.unicaen.fr/~karczma/arpap/lazypi.ps.gz
21:56:37 <faxathisia> how od you make it infintie
21:56:38 <ivanm> OceanSpray: digits of pi
21:56:39 <Pseudonym> I don't know.
21:56:39 <OceanSpray> OH
21:56:46 <Pseudonym> Not having read that paper.
21:56:53 <ivanm> heh
21:57:10 <ivanm> faxathisia: remove the "take d" ?
21:57:18 <faxathisia> > (fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])
21:57:19 <lambdabot>   Not in scope: `d'
21:57:46 <ivanm> d appears to be a precision parameter
21:58:02 <ivanm> so any more than d digits probably isn't going to be accurate
21:58:07 <Pseudonym> let { z a b c d xs'@(x:xs) = let t=a`div`c in if all (>0) [a,b,c,d] && t == b `div` d then t : z (16*(a-c*t)) (16*(b-d*t)) c d xs' else z (x*a+b) a (x*c+d) c xs; let f n=1:1:n:f(n+1) } in z 1 0 0 1 $ [2,1,2]++f 4
21:58:08 <goalieca> faxathisia, my eyes!
21:58:18 <Pseudonym> > let { z a b c d xs'@(x:xs) = let t=a`div`c in if all (>0) [a,b,c,d] && t == b `div` d then t : z (16*(a-c*t)) (16*(b-d*t)) c d xs' else z (x*a+b) a (x*c+d) c xs; let f n=1:1:n:f(n+1) } in z 1 0 0 1 $ [2,1,2]++f 4
21:58:18 <lambdabot>  Parse error at "let" (column 163)
21:58:21 <ivanm> heh
21:58:28 <Pseudonym> > let { z a b c d xs'@(x:xs) = let t=a`div`c in if all (>0) [a,b,c,d] && t == b `div` d then t : z (16*(a-c*t)) (16*(b-d*t)) c d xs' else z (x*a+b) a (x*c+d) c xs; f n=1:1:n:f(n+1) } in z 1 0 0 1 $ [2,1,2]++f 4
21:58:29 <lambdabot>  [2,11,7,14,1,0,4,11,4,7,8,12,8,0,3,12,3,8,5,3,9,15,15,12,3,9,3,14,6,15,6,9,6...
21:58:32 <Pseudonym> Hmm.
21:58:34 <faxathisia> :o
21:58:36 <Pseudonym> That's not what I expected.
21:58:39 <ivanm> Pseudonym: how long did it take you to obfuscate it? :p
21:58:49 <Pseudonym> Oh, it's base 16!
21:58:52 <ivanm> heh
21:59:07 <Pseudonym> > let { z a b c d xs'@(x:xs) = let t=a`div`c in if all (>0) [a,b,c,d] && t == b `div` d then t : z (10*(a-c*t)) (10*(b-d*t)) c d xs' else z (x*a+b) a (x*c+d) c xs; f n=1:1:n:f(n+1) } in z 1 0 0 1 $ [2,1,2]++f 4
21:59:08 <lambdabot>  [2,7,1,8,2,7,7,2,5,7,9,7,7,0,0,7,4,1,8,4,4,0,0,9,1,1,1,8,2,4,6,8,1,1,7,6,9,0...
21:59:10 <Pseudonym> Better.
21:59:14 <Pseudonym> Except it's also wrong.
21:59:16 <Pseudonym> Hmm.
21:59:39 <ivanm> Pseudonym: is the code wrong, or your expectations? :p
21:59:50 <Pseudonym> Well, that's not "e".
22:00:15 <faxathisia> Pseudonym: close enough
22:00:16 <ivanm> oh, I thought you were still going for pi
22:00:18 <faxathisia> :p
22:00:25 <geezusfreeek> interesting... trying to build old-locale says "unknown package: old-locale-1.0.0.0"
22:00:37 <ivanm> it's 2.7<something> ... looks like e to me!
22:01:18 <shachaf> ivanm: Hey, it was right to 5 digits!
22:01:37 <ivanm> wow!
22:01:46 <ivanm> > exp(1) -- what is the value of e anyway?
22:01:47 <lambdabot>  2.718281828459045
22:02:25 <Pseudonym> Oh, here's a simulation of a M94 cipher machine.
22:02:38 <Pseudonym> Unfortunately, the wheel settings blow out the amount of code.
22:02:42 <zeeeee> does there exist anything similar to channel-based process calculi (eg csp, join) for haskell? (including bounded chans, two-phase-commits for par, would also be nice to have guards)
22:02:44 <shachaf> > let x = 10000000000 in (1 + 1/x) ** x
22:02:45 <lambdabot>  2.718282052690854
22:02:53 <shachaf> Hmm.
22:05:12 <faxathisia> > map (\x->(1 + 1/x) ** x) [1..]
22:05:13 <lambdabot>  [2.0,2.25,2.37037037037037,2.44140625,2.4883199999999994,2.5216263717421135,...
22:05:27 <faxathisia> cool
22:06:56 <zeeeee> separate question: can i select on chans?
22:07:21 <Pseudonym> @let zenoSequence f h = f h : zenoSequence f (h * 0.5)
22:07:25 <lambdabot> Defined.
22:08:00 <ivanm> OK, you've defined it... now use it!
22:08:02 <zeeeee> hm, never mind on the latter: the CH paper says there is no choice
22:08:10 <zeeeee> no 'choice'
22:08:58 <Pseudonym> @let accellerateZenoSequence seq p = let { p2 = 2^p; p21 = p2 - 1 } in zipWith (\rh rh2 -> (p2 * rh2 - rh) / 2p1) seq (tail seq)
22:08:59 <lambdabot> <local>:6:105: Not in scope: `p1'
22:09:05 <Pseudonym> @let accellerateZenoSequence seq p = let { p2 = 2^p; p21 = p2 - 1 } in zipWith (\rh rh2 -> (p2 * rh2 - rh) / p21) seq (tail seq)
22:09:12 <lambdabot> Defined.
22:10:11 <pheaver> are there environment variables I can set instead of using --with-readline-include and --with-readline-libraries in my ./configure script?
22:10:25 <Pseudonym> @let makeZenoTableau xs p q = let seqs xs ord = xs : seqs (accelerateZenoSequence xs order) (order + q) in seqs xs p
22:10:25 <lambdabot> <local>:7:54: Not in scope: `accelerateZenoSequence'  <local>:7:80: Not in sc...
22:10:29 <pheaver> (I'm building ghc-6.8, or at least trying heh)
22:10:39 <Pseudonym> @let makeZenoTableau xs p q = let seqs xs ord = xs : seqs (accellerateZenoSequence xs order) (order + q) in seqs xs p
22:10:39 <lambdabot> <local>:7:81: Not in scope: `order'  <local>:7:89: Not in scope: `order'
22:10:46 <pheaver> something like LIBRARY_PATH?
22:10:46 <Pseudonym> @let makeZenoTableau xs p q = let seqs xs ord = xs : seqs (accellerateZenoSequence xs ord) (ord + q) in seqs xs p
22:10:50 <hpaste>  (anonymous) pasted "mastermind" at http://hpaste.org/3870
22:10:57 <lambdabot> Defined.
22:11:11 <Pseudonym> @let richardsonSequence xs p q = map head (makeZenoTableau xs p q)
22:11:11 <lambdabot> Defined.
22:11:17 <Pseudonym> Now.
22:11:33 <Pseudonym> @let eseq () = map (\x->(1 + 1/x) ** x) [1..]
22:11:35 <lambdabot> Defined.
22:11:46 <Pseudonym> > eseq ()
22:11:59 <Korollary> pheaver: which OS?
22:12:11 <pheaver> Mac OS X Tiger
22:12:22 <Pseudonym> ?botsnack
22:12:22 <lambdabot> :)
22:12:28 <pheaver> my readline is in /opt, I installed it with ports
22:12:33 <Pseudonym> > eseq ()
22:12:33 <lambdabot>  [2.0,2.25,2.37037037037037,2.44140625,2.4883199999999994,2.5216263717421135,...
22:12:40 <faxathisia> hehe
22:12:44 <Pseudonym> > richardsonSequence (eseq ()) 2 2
22:12:44 <lambdabot>  [2.0,2.3333333333333335,2.415637860082304,2.469566921418773,2.50729723628622...
22:12:50 <Pseudonym> Hmm.
22:12:54 <Pseudonym> > richardsonSequence (eseq ()) 8 8
22:12:57 <lambdabot>  [2.0,2.2509803921568627,2.3708442400156593,2.4416859072853727,2.488504692706...
22:13:07 <Pseudonym> > richardsonSequence (eseq ()) 1 1
22:13:08 <lambdabot>  [2.0,2.5,2.487654320987653,2.524250440917109,2.547598043503819,2.56594097388...
22:13:15 <Pseudonym> Doesn't seem to help much.
22:13:20 <Pseudonym> > eseq () !! 100
22:13:21 <lambdabot>  2.7049459774851603
22:13:23 <faxathisia> what is richardson sequence?
22:13:27 <Pseudonym> > richardsonSequence (eseq ()) 2 2 !! 100
22:13:28 <lambdabot>  2.7050015434305825
22:13:36 <Pseudonym> It's for accellerating the convergence of sequences.
22:14:16 <ivanm> Pseudonym: so are you going to clear lambdabot's memory once you've finished playing/showing off? :p
22:14:23 <Korollary> pheaver: I don't see a flag for readline like the one for gmp
22:14:28 <Pseudonym> ivanm: Nope.
22:14:36 <Pseudonym> You will note I was careful to make eseq not a CAF.
22:14:46 * Pseudonym is careful!
22:14:47 <ivanm> by using the () ?
22:14:50 <Pseudonym> Yup.
22:15:01 <pheaver> well, the configure script in the readline package definitely has --with-readline-libraries and --with-readline-include options
22:15:16 <pheaver> and usually those kinds of things can be set using some PATH-like environment variables
22:15:21 <ivanm> what difference would it have made (in practical terms) if eseq _was_ a CAF?
22:15:38 <Pseudonym> ivanm: Well, if it used the same interpreter, it wouldn't get garbage collected.
22:15:50 <ivanm> ahhh
22:15:55 <pheaver> for example, I used C_INCLUDE_PATH when building ghc-6.8.1 on OS X, because some C header files were in strange places
22:15:59 <ivanm> so it would have _really_ screwed up the RAM usage?
22:16:08 <Pseudonym> @let archimedes s = (sqrt (sqrt (4 - s*s) + 2)) / s
22:16:10 <lambdabot> Defined.
22:16:21 <Pseudonym> > iterate archimedes (sqrt 2)
22:16:26 <lambdabot>  [1.4142135623730951,1.3065629648763764,1.4347781755773157,1.283894315555275,...
22:16:48 <sclv> > filter (uncurry (>)) $ zipWith (,) (1:eseq()) ((eseq()))
22:16:49 <lambdabot>  [(2.7182715600522247,2.718271560051149),(2.718271603081561,2.718271603080836...
22:16:55 <Korollary> pheaver: There's an extra-gcc-opts file generated. Maybe you can stuff the include path in there.
22:17:08 <geezusfreeek> anybody know why "runhaskell Setup.hs configure" would return "unknown package: old-locale-1.0.0.0" (which is what I'm trying to build)?
22:17:26 <pheaver> ah, nevermind, thanks
22:17:35 <allbery_b> pheaver: LD_LIBRARY_PATH (which does *not* work like the Linux/Solaris/*BSD variable of the same name!)
22:17:43 <allbery_b> but that still leaves uyou with include file locations
22:17:47 <hpaste>  davidL pasted "can this be cleaned up a bit?" at http://hpaste.org/3871
22:17:49 <Pseudonym> > zipWith (\sl sn -> sl * 0.5 * (2*n)) (iterate archimedes (sqrt 2)) [4..]
22:17:49 <allbery_b> better to just use the configure options
22:17:50 <lambdabot>   Not in scope: `n'
22:17:57 <Pseudonym> > zipWith (\sl sn -> sl * 0.5 * (2*sn)) (iterate archimedes (sqrt 2)) [4..]
22:17:58 <lambdabot>  [5.656854249492381,6.532814824381882,8.608669053463894,8.987260208886925,11....
22:18:23 <pheaver> allbery_b: yeah I tried that, it didn't work
22:18:32 <firefly> can forkIO fail?
22:18:36 <pheaver> allbery_b: but, for the hell of it, I tried LIBRARY_PATH just now, and that worked :)
22:18:45 <allbery_b> (the OSX equivalent of the ELF-standard LD_LIBRARY_PATH is DYLD_LIBRARY_PATH)
22:19:32 <Pseudonym> > zipWith (\sl sn -> sl * 0.5 * (2^sn)) (iterate archimedes (sqrt 2)) [2..]
22:19:33 <lambdabot>  [2.8284271247461903,5.226251859505505,11.478225404618525,20.5423090488844,46...
22:20:03 <davidL> can someone take a quick look at my paste, it's really short :-)
22:20:21 <Pseudonym> @let archimedes' s = 2 / sqrt (2 + sqrt (4 - s * s))
22:20:29 <lambdabot> Defined.
22:20:30 <Pseudonym> > zipWith (\sl sn -> sl * 0.5 * (2^sn)) (iterate archimedes' (sqrt 2)) [2..]
22:20:32 <lambdabot>  [2.8284271247461903,4.329568801169576,8.338545614101836,16.620474758397084,3...
22:21:16 <allbery_b> firefly: it's not supposed to, although I suspect you could run out of memory or something
22:21:21 <allbery_b> haskell threads are not bounded
22:21:46 <Pseudonym> @let archimedesReally s = s / sqrt (2 + sqrt (4 - s * s))
22:21:48 <lambdabot> Defined.
22:21:56 <Pseudonym> Better.
22:22:13 <Pseudonym> @let pseries () = zipWith (\sl sn -> sl * 0.5 * (2^sn)) (iterate archimedesReally (sqrt 2)) [2..]
22:22:14 <lambdabot> Defined.
22:22:15 <sclv> @pl \x -> head x == a -- always a first step
22:22:15 <lambdabot> (a ==) . head
22:22:16 <Pseudonym> > piseries ()
22:22:16 <lambdabot>   Not in scope: `piseries'
22:22:24 <Pseudonym> > piseries ()
22:22:25 <lambdabot>   Not in scope: `piseries'
22:22:32 <Pseudonym> > pseries ()
22:22:33 <lambdabot>  [2.8284271247461903,3.0614674589207183,3.1214451522580524,3.1365484905459393...
22:22:40 <Pseudonym> > richardsonSequence (pseries ()) 2 2
22:22:49 <lambdabot>  [2.8284271247461903,3.1391475703122276,3.1415903931299374,3.141592653286045,...
22:23:03 <faxathisia> nice
22:23:04 <Pseudonym> > richardsonSequence (richardsonSequence (pseries ()) 2 2) 4 4
22:23:05 <lambdabot>  [2.8284271247461903,3.1598622666832967,3.1416822322248485,3.141592152778826,...
22:23:24 <Pseudonym> > richardsonSequence (richardsonSequence (pseries ()) 2 2) 2 2
22:23:26 <lambdabot>  [2.8284271247461903,3.2427210521675733,3.1357169084181695,3.1416317418957616...
22:23:34 <Pseudonym> OK, looks like the first is best.
22:23:40 <Pseudonym> Actually, none of this beats:
22:23:45 <Pseudonym> > iterate (\x -> x + sin x) 3
22:23:46 <lambdabot>  [3.0,3.1411200080598674,3.1415926535721956,3.141592653589793,3.1415926535897...
22:24:00 <sclv> also davidL, are you sure it won't infer that n is an int?
22:24:29 <dfranke> Pseudonym: I'm pretty sure that's the shortest program for computing pi ever written.
22:24:49 <Heffalump> > 4 * atan 1
22:24:51 <lambdabot>  3.141592653589793
22:25:11 <dfranke> that doesn't count.
22:25:17 <Heffalump> why not?
22:25:19 <dfranke> That's not computing pi, that's recalling pi from a library.
22:25:22 <faxathisia> in maxima
22:25:23 <wli> Why does iterate (\x -> x + sin x) 3 work?
22:25:23 <faxathisia> %pi
22:25:31 <sclv> actually i think using trig functions in general shouldn't count
22:25:33 <faxathisia> that is shorter :p
22:25:35 <Pseudonym> I'm not sure why you'd disallow atan but allow sin.
22:25:38 <Heffalump> and sin has no built-in knowledge of pi whereas atan does?
22:25:42 <Heffalump> indeed.
22:25:52 <firefly> forkOS apparently can, it'll call fail "Cannot create OS thread." in such cases (ghc 6.6.1)
22:25:57 <wli> sin(x) typically  has argument reduction rules for such.
22:26:08 <wli> Ones involving the value of pi.
22:26:23 <allbery_b> yes, but you're not supposed to call forkOS usually
22:26:36 <dfranke> ok, fair enough.  But the one above still wins.
22:26:41 <Pseudonym> > pi
22:26:43 <lambdabot>  3.141592653589793
22:26:45 <allbery_b> the simons will throw sharp pointy lambdas at you if you do
22:27:22 <Pseudonym> Still, the Richardson sequence stuff, if you can decode it from all those @lets, is pretty elegant.
22:27:25 <firefly> why would that be worse than forkIO?
22:27:27 <Pseudonym> dons, hint hint.
22:28:14 <firefly> If I know something will execute faster in more actual threads even if the machine only has a single CPU?  (due to disk I/O stuff, for example)
22:28:15 <wli> There's something about contractiveness.
22:28:58 <allbery_b> in that case you use +RTS -N(numthreads)
22:29:13 <allbery_b> if you use forkOS you take control of the thread away from the haskell runtime
22:29:21 <allbery_b> and potentially complicate e.g. garbage collection
22:29:28 <firefly> well, not quite all the way from the RTS?
22:29:41 <firefly> doesn't 6.8.1 have concurrent gc anyway?
22:29:50 <allbery_b> forkIO is integrated and if you use +RTS -N# then the RTS will multiplex haskellthreads onto OS threads without breaking things
22:30:01 <sclv> davidL: one last thing, is that lots of the "do" statements in the last function are extraneous because they're introducing a one line block
22:30:21 <firefly> ah, but I might not necessarily want just any haskell thread to interfere with the disk I/O threads.
22:30:27 * allbery_b does not recall the recent discussion on -cafe about it, but the upshot was that forkOS was a very, very bad thing to do to the haskell RTS and it caused all sorts of problems
22:30:50 <firefly> But say I decide to use forkIO.  Can I do the RTS -Nx thing from within a Haskell program?
22:30:51 <davidL> sclv: you mean in the if statements?
22:31:11 <sclv> yep
22:32:03 <davidL> oh, I suppose so, because I don't have anything under them that needs to be sequenced
22:32:06 <sclv> also you might find =<< more natureal
22:32:11 <sclv> er, natural
22:32:58 <davidL> is that the same thing with the arguements flipped?
22:34:00 <sclv> yep -- it'll let your lines flow a bit more clearly
22:34:48 <dons> http://programming.reddit.com/info/60jir/comments/ :)
22:35:06 <davidL> so there's nothing I can do about having to do this 3 times: putStrLn (show(length words2) ++ " possibilites")
22:35:06 <dons> ?bot
22:35:06 <lambdabot> :)
22:35:14 <dons> "A Practical Haskell Debugger: Time Travelling to Find Partial Functions "
22:35:32 <sclv> actually -- why are you taking things out of the IO monad with >>= then putting them back in with return anyway?
22:36:07 <sclv> (only to extract them again with <- !)
22:36:53 <davidL> you mean like here?: n <- getLine >>= return . read :: IO Int
22:38:11 <brad_> how can i bootstrap a fresh ghc install on a freebsd box? i am getting the "cannot determine current directory" configure error....
22:40:06 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions testing
22:40:07 <lambdabot> Title: Haskell hacking
22:40:12 <dons> ah good. lambdabot's weird
22:40:48 <davidL> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions :)
22:40:49 <lambdabot> Title: Haskell hacking
22:42:38 <sclv> ?ty getLine >>= return . read
22:42:39 <lambdabot> forall b. (Read b) => IO b
22:42:46 <sclv> ?ty fmap read $ getLine
22:42:47 <lambdabot> forall a. (Read a) => IO a
22:43:10 <sclv> ?ty liftM read $ getLine
22:43:10 <lambdabot> forall a. (Read a) => IO a
22:43:51 <sclv> ?ty read <$> getLine -- nicest style yet
22:43:51 <lambdabot> forall a. (Read a) => IO a
22:44:55 <brad_> is there any way to build ghc from source without a binary build or other ghc being first installed? this is on freebsd 7, trying to install 6.8.1...ghc has been marked broken on freebsd 7 so i cannot install the port
22:45:13 <faxathisia> :t (<$>)
22:45:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:45:20 <faxathisia> :t [(<$>)]
22:45:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
22:45:35 <davidL> I don't need :: IO Int?
22:45:52 <Korollary> brad_: There's what's called a registerized build process.
22:46:02 <sclv> davidL -- not if you use it clearly as an int elsewhere, which I think you do, then the compiler figures it out for you
22:46:47 <brad_> Korollary - is that when you add: "GhcUnregisterised=YES" and "SplitObjs=NO" to mk/build.mk?
22:47:09 <davidL> @index (<$>)
22:47:09 <lambdabot> bzzt
22:47:23 <davidL> @hoogle (<$>)
22:47:24 <lambdabot> Did you mean: (<$>)
22:47:24 <lambdabot> Prelude.undefined :: a
22:47:24 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
22:47:41 <sclv> davidL: it's just `fmap` and its in Control.Applicative
22:47:54 <davidL> thanks
22:47:59 <Korollary> brad_: http://hackage.haskell.org/trac/ghc/wiki/Building/Unregisterised
22:48:00 <lambdabot> Title: Building/Unregisterised - GHC - Trac
22:48:14 <nburlett_> uh oh.. I seem to have forgotten my hackage password ;-<
22:48:40 <brad_> thanks Korollary!
22:48:43 <brad_> i will try that out
22:49:17 <brad_> by the way, once you have an unregistered build, can you use that to make a normal build?
22:50:33 <thetallguy> dons: I love the marketing in this line:      that relies on some invariant in your code  you forgot to write a QuickCheck property for.
22:51:26 <thetallguy> dons: one out of four men forget to use quickcheck.  Buy our debugger!
22:51:54 <nburlett_> so, who knows how to recover my hackage password?
22:52:29 <Korollary> brad_: I think so, but you'll eventually want a registerized build. It should be possible because the arch and OS information should exist already.
22:52:39 <dons> thetallguy: :)
22:53:01 <Korollary> head is evil
22:53:08 <dons> you've seen the xmonad talk -- gotta keep hammering away at it: bugs are properties you didn't think about
22:53:33 <dons> Korollary: yeah, i wanted to keep away from that line though, since its beginners who'll hit this issue
22:53:37 <dons> before they learn how to use HList
22:53:53 <hpaste>  davidL annotated "can this be cleaned up a bit?" with "thanks sclv" at http://hpaste.org/3871#a1
22:53:55 <thetallguy> the Linspire hardware detector got that (O'Caml equiv) message all the time.
22:54:09 <dons> mm
22:54:12 <thetallguy> Need a lambdacat using HList.
22:54:18 <dons> heh
22:54:37 <thetallguy> but I think the ASPCA would be after us
22:55:38 <dons> thetallguy: you've seen Pseudonym's http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/03#cat ?
22:55:39 <lambdabot> Title: Haskell hacking
22:56:33 <thetallguy> dons: yes.  I was thinking similar, but more explicitly on HList
22:56:45 <brad_> is there any way around the configure step error: "utils/pwd/pwd: No such file or directory" ???
22:57:25 <quicksilver> dons, Korollary: I don't think head is that evil, and I don't think HList is the right answer if it is.
22:57:28 <thetallguy> dons: I want to try this picture again, see if I can get Maddie to look more like a lambda.  http://stockwits.com/Photos/Maddie/p_IMG_1140.JPG.html
22:57:29 <lambdabot> Title:
22:57:36 <quicksilver> I favour something lightweight like catch
22:58:16 <Korollary> I favor catch, too. But head masks the unhandled case.
22:58:39 <quicksilver> Yes. So, I suppose, it's only evil if you don't know what you're doing.
22:58:57 <quicksilver> If you do know what you're doing it documents the fact that you, the programmer, believe that can never happen
22:59:25 <dons> quicksilver: i agree, i favor catch too, and take 1
22:59:51 <dons> catch isn't ghc-compliant, which is a pity
23:00:09 <quicksilver> take 1 isn't always better, though. If the result [] is nonsense to the rest of your program then you might as well get head to throw the exception as anything else :)
23:00:10 <dons> $ grep head XMonad/*.hs
23:00:11 <dons> $
23:00:41 * quicksilver nods
23:00:51 <Korollary> brad_: That's a configure step? It looks like it fails to build that binary with your existing compiler.
23:00:53 <quicksilver> I must admit, I use it seldom myself.
23:01:25 <dons> anyway, the post is to just nail a coffin in that reason to not use haskell for serious work. we all write total functions with isabelle proofs anyway
23:01:29 <brad_> yes Korollary, this is in ./configure...it seems this is also listed here: http://hackage.haskell.org/trac/ghc/ticket/1860
23:01:30 <lambdabot> Title: #1860 (GMP dyn link dependencies in binary distributions) - GHC - Trac
23:01:39 <brad_> strange
23:02:36 <Korollary> dons: I don't use debuggers for C++ work. That's a lame argument anyway.
23:07:19 <goalieca> debuggers work best for assembly :-)
23:09:17 <Korollary> goalieca: Montreal 3 - 2 Toronto in OT
23:09:27 <Korollary> err 4-3
23:10:06 <dufflebunk> Looks like the online Monad docs are blank: http://haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.0/Monad.html
23:10:08 <lambdabot> http://tinyurl.com/24t9gt
23:10:45 <goalieca> Korollary, yep. i saw it! toronto's d-men were sloppy all game
23:10:58 <goalieca> and the OT goal was pure awesome. price >> raycroft
23:12:42 <Korollary> Raycroft had one good save where he stretched to keep the wraparound out
23:12:52 <goalieca> oh. that toe save was good
23:13:54 <dons> dufflebunk: the links have changed.
23:13:59 <dons> dufflebunk: try Control.Monad in base
23:14:43 <Flynsarmy> Could someone explain what foldl does? I read the description on haskell.org but didn't understand it :S
23:14:59 <dufflebunk> Ah, ok. The hoogle link pointed me there.
23:15:36 <Korollary> Flynsarmy: http://cale.yi.org/index.php/Fold_Diagrams
23:15:36 <lambdabot> Title: Fold Diagrams - CaleWiki
23:15:45 <Flynsarmy> Korollary: Thanks
23:16:11 <dufflebunk> Wow, that makes it look really complicated.
23:16:47 <goalieca> it is easier to think of it as an "accumulate" function instead (when first learning)
23:18:09 <dons> Flynsarmy: a loop with an accumulating value
23:18:22 <dons> > foldl (+) 0 [1..10]
23:18:23 <Korollary> It's no more complicated. The diagram shows what the list actually looks like and what foldl actually does with it.
23:18:25 <lambdabot>  55
23:18:30 <dufflebunk> I just remember with an example: foldl (+) 10 [1,2,3] becomes foldl (+) (10+1) [2, 3]
23:20:02 <Flynsarmy> Aha! Thanks guys :)
23:22:06 <Flynsarmy> dons: foldl will remove the first item in the list and add the result to that whereas foldr will do it to the end?
23:22:22 <dons> yep
23:22:28 <Flynsarmy> dons thanks :)
23:22:47 <dons> most of these funny higher order functions are just special loops like that
23:23:07 <dons> rather than having some loop syntax in the language, we just use functions for different kinds of loops
23:23:15 <Flynsarmy> Got a uni exam on Haskell tomorrow. i've been meaning to find out what foldl and foldr do for ages but kept forgetting
23:23:16 <Cale> > foldl (flip (:)) [] [1..3]
23:23:17 <lambdabot>  [3,2,1]
23:23:31 <Cale> I almost always use the diagrams to picture it :)
23:24:53 <Cale> > foldr (\x xs -> concat ["(f ", x, " ", xs, ")"]) "z" ["1","2","3","4","5"]
23:24:54 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
23:25:42 <Cale> > foldl (\x y -> concat ["(f ", x, " ", y, ")"]) "z" ["1","2","3","4","5"]
23:25:44 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
23:27:23 <Cale> Well, really, for foldr, I use what that diagram embodies: foldr f z replaces each (:) in the list it's given with f and the [] at the end with z
23:27:49 <Cale> > foldr (\x xs -> concat ["(", x, ":", xs, ")"]) "[]" ["1","2","3","4","5"]
23:27:49 <lambdabot>  "(1:(2:(3:(4:(5:[])))))"
23:28:13 <dufflebunk> Can someone explain the difference between forM and forM_?
23:28:14 <mtp> Hmm
23:28:20 <mtp> how do I escape the Parser monad?
23:28:36 <mtp> ie, get rid of the Right insns and just return insns?
23:29:58 <quicksilver> dufflebunk: forM_ throws away the results
23:30:04 <quicksilver> dufflebunk: forM keeps them
23:30:18 <quicksilver> (in a list of results)
23:30:44 <dufflebunk> quicksilver: throws them away... but still does the IO?
23:31:09 <quicksilver> dufflebunk: exactly
23:31:15 <quicksilver> dufflebunk: and whatever other effects that monad might have
23:31:34 * dufflebunk is dipping his toe in the tepid water of Monads via the Data.Binary module
23:31:59 <Korollary> There are gentler ways like Maybe, List
23:32:16 <goalieca> stm is quite handy
23:32:25 * roconnor shoves dufflebunk into the water
23:32:31 <roconnor> :)
23:32:38 <Korollary> goalieca: stm is handy but what the hell do I do with it?
23:32:47 <dons> i'm so disapointed my debugging article got voted down, http://programming.reddit.com/info/60jir/details hint hiint
23:32:55 <dufflebunk> I can use Maybe, but it doesn't teach me how to get useful stuff done. I have a c program that parses a binary file, and I want to see how to do it in Haskell.
23:32:57 <Korollary> dons: deal with it
23:33:06 <dons> Korollary: I'm trying to.
23:33:12 <dufflebunk> I have  aperl version a madman wrote that does it too ;)
23:33:28 <Korollary> dufflebunk: ok, how about Parsec then?
23:33:45 <Korollary> binary files are awkward
23:34:14 <faxathisia> dons: now there is 4 upvotes :p
23:34:36 <dufflebunk> Korollary: I don't know... the binary format has file offsets and stuff... pointers to other sections of the file
23:34:50 <dufflebunk> can Parsec handle that sort of thing?
23:35:01 <dons> faxathisia: much better :)
23:35:05 <dons> thanks guys
23:35:18 <quicksilver> dons++ # stuffing the ballot box with style
23:35:23 <dons> sweet
23:35:26 <faxathisia> I don't think I can turn an infinite continued fraction into an infinite list of digits..
23:35:34 <faxathisia> Not without actually recomputing the entire thing for each digit :|
23:35:34 <dons> the wisdom of the crowd, quicksilver :)
23:35:45 <Korollary> dufflebunk: ow. You can do stateful parsing with parsec. It's just not the best kind of training exercise.
23:36:13 <quicksilver> faxathisia: you can, but you need to prove something about terms beyond a certain point definitely not contributing to certain decimal places
23:36:17 <quicksilver> faxathisia: it's not trivial :)
23:36:20 <roconnor> dons: head [] ?
23:36:29 <dufflebunk> Korollary: Ok, thanks. I'll stick with manual parsing then.
23:36:30 <quicksilver> faxathisia: although there is surely lots written about it in the googlesphere
23:37:06 <jeffz> dons: you could always hire out the storm botnet to push it up a million points.
23:37:29 <Korollary> or mechanical turk
23:38:28 <dons> roconnor: tail [] ?
23:38:57 <goalieca> > liftM (+1) Nothing
23:38:59 <lambdabot>  Nothing
23:39:02 <goalieca> > liftM (+1) Just 2
23:39:04 <lambdabot>   add an instance declaration for (Num (Maybe a))
23:39:08 <goalieca> > liftM (+1) (Just 2)
23:39:09 <lambdabot>  Just 3
23:39:13 <goalieca> :0
23:39:39 <goalieca> i always find that neat. i had exception handling to death.
23:39:42 <goalieca> hate*
23:39:50 <roconnor> dons: did you really have head [] in your code?
23:40:01 <Korollary> goalieca: it's exception punting mostly
23:40:16 <dons> roconnor: no, i inserted it into hscolour, in order to find it with the debugger
23:40:24 <roconnor> :)
23:40:25 <roconnor> whew
23:40:51 <roconnor> dons: I guess I should have asked ``Did you really havea bug in a Haskell program'' ;)
23:40:55 <dons> i did it 18 months ago, and no one found it, so i thought i'd reveal it today
23:41:02 <Korollary> *cough* lambdabot *cough*
23:41:09 <dons> no, i joke.
23:41:21 <dons> and yeah, lambdabot's a lovely bot glued together with sticky bugs
23:41:41 <sjanssen> @remember dons lambdabot's a lovely bot glued together with sticky bugs
23:41:41 <lambdabot> Nice!
23:41:52 <goalieca> clearly you are not using enough static typing :P
23:42:04 <Korollary> types should be more static
23:42:18 <Korollary> they're too dynamic right now
23:42:45 <goalieca> but they are all resolved at compile time at least
23:42:59 <roconnor> ``a -> b'' could be anything!!
23:43:21 <roconnor> @djinn a -> b
23:43:21 <lambdabot> -- f cannot be realized.
23:43:25 <goalieca> which is why you define a type class
23:43:31 <Korollary> a -> m b is an invitation to a disaster
23:43:41 <sjanssen> roconnor: a -> b *can't* be anything :P
23:43:46 <goalieca> @type print
23:43:48 <lambdabot> forall a. (Show a) => a -> IO ()
23:43:48 <roconnor> ;)
23:44:31 <roconnor> @type throw
23:44:32 <lambdabot> Not in scope: `throw'
23:45:45 <roconnor> @type throwError
23:45:46 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
23:46:01 <roconnor> bah, constraints
23:46:10 <Korollary> error is pretty lax
23:47:07 <roconnor> Imagine a world without constraints.
23:47:16 <roconnor> scheme, python?
23:47:25 <faxathisia> what constraints?
23:47:35 <roconnor> (MonadError e m) =>
23:47:48 <faxathisia> I never thought of that as a constraint..
23:47:57 <faxathisia> well I suppose it is
23:47:58 <quicksilver> that's what it's called :)
23:48:16 <faxathisia> so you want unsafePerformError? :p
23:48:17 <quicksilver> without it, e and m could be any types at all (subject to kinding)
23:48:51 <roconnor> faxathisia: you probably have a better point of view
23:48:53 <sorear> woah, sorear@scannedinavian.com is receiving spam
23:49:10 <roconnor> faxathisia: (MonadError e m) => is more like a bundle of extra functions available for use.
23:49:52 <Korollary> sorear: that's pretty likely considering that they may occur in quoted emails
23:50:04 <jeffz> it appears on google too...
23:50:05 <Korollary> I mean sorear and the domain name
23:50:53 <Korollary> now, rushlimbaugh@scannedinavian.com getting spam would be interesting.
23:51:55 <dons> faxathisia: did you spend a day talking to gavino? :)
23:52:44 <dons> http://bootiack.livejournal.com/11758.html i see the logs faxathisia ;) this guy has his own lambdabot command, be careful :)
23:52:44 <lambdabot> Title: bootiack: more fun lispcafe rocks perlcafe too
23:53:44 <alexj> @seen ndm
23:53:44 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 7h 29m 23s ago, and .
23:54:00 <alexj> anyone here worked with uniplate?
23:54:44 <faxathisia> dons: I invite him to #lispcafe and we talked about logic programming
23:55:36 <faxathisia> strange someone is posting chatlogs on livejournal
23:56:59 <dons> ?protontorpedo
23:56:59 <lambdabot> is haskell doomed to be a mysql driver?
23:57:04 <dons> do you know gavino?
23:57:05 <dons> ?protontorpedo
23:57:05 <lambdabot> so haskell is free?
23:57:08 <dons> ?protontorpedo
23:57:09 <lambdabot> is haskell better than APL or perl or clisp?
23:57:20 <dons> he's trolled us for years...
23:59:47 <newsham> ?keal
23:59:48 <lambdabot> pork steaks taste like dick
