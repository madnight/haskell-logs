00:00:42 <sjanssen> dikini: gg must get a random generator from somewhere
00:01:03 <sjanssen> the good news is that once you've gotten a StdGen, you don't need to use IO to get numbers out of it
00:10:02 <dikini> that makes makes for a rally strange recursion in g
00:10:18 <dikini> oops the h - helper
00:12:36 <dikini> I reckon I'm overdoing it, again
00:13:14 <sjanssen> you can also use a Monad to thread your random generator around
00:14:16 <dikini> do you have an example? I'm still quite new with all this?
00:14:41 <allbery_m> haskellwiki/New_monads ?
00:14:54 <allbery_m> there's a nice Random monad in there
00:14:55 <sjanssen> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
00:14:56 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
00:15:08 <allbery_m> yeh, that
00:16:54 <scook0> incidentally, MonadRandom is also on hackage
00:18:13 <dikini> thanks
00:21:00 <faxathisia> @src ?djinn
00:21:00 <lambdabot> Source not found. Just try something else.
00:21:10 <hpaste>  dikini annotated "I'm out of ideas, can you help?" with "without a monad?" at http://hpaste.org/3748#a1
00:21:15 <faxathisia> ?djinn Int -> Int
00:21:15 <lambdabot> f a = a
00:21:44 <dikini> I'm curious if there could be a cleaner solution that that
00:24:11 <sjanssen> dikini: that looks pretty good
00:25:26 <dikini> cheers, I'll look into the monad business, but I still have to get my head around them, reading is fine, but speaking is another matter
00:36:44 <alexj> @seen igloo
00:36:44 <lambdabot> I saw igloo leaving #ghc, #darcs and #haskell 3h 23m 55s ago, and .
00:48:00 <sjanssen> hmm, I wonder if a random Applicative is more useful than a Monad?
00:51:42 <faxathisia> hey "The problem is uncannily similar to that of overlapping instances with functional dependencies in Haskell."
00:51:53 <faxathisia> What is that problem?
00:52:02 <faxathisia> I mean the haskell one
00:55:12 <kfish> faxathisia, are you reading about undecidability?
00:56:17 <faxathisia> about kanren logic programming
00:56:34 <faxathisia> the comment was in relation to having a logical predicate whoes meaning changes whether or not some parameters are instantiated
01:01:04 <kfish> "Our method can typecheck more [Haskell] programs than it is currently possible in Haskell."
01:01:36 <kfish> that's an olegfact if ever i saw one
01:02:10 <kfish> http://kanren.sourceforge.net/
01:02:11 <lambdabot> Title: A declarative logic programming system
01:02:14 <faxathisia> :D
01:03:23 <faxathisia> There's a really nice paper on a simple type inference program for scheme, since they wrote it logically when you run it backwards it works like djinn
01:03:32 <faxathisia> (using kanren)
01:04:23 <sjanssen> aww, my instance breaks Applicative's laws :(
01:06:45 <kfish> 関連 [かんれん] /(n,suf) relation/connection/relevance/
01:15:13 <quicksilver> sjanssen: I think a random applicative instance is, by definition, 'less' useful than a monad
01:15:37 <quicksilver> sjanssen: unless you can think of some functionality you'd like to have in the random applicative which monads aren't capable of...
01:16:48 <hpaste>  sjanssen pasted "random (not) applicative" at http://hpaste.org/3749
01:17:43 <sjanssen> quicksilver: I think the State-based random monad over sequentializes code
01:18:11 <quicksilver> sjanssen: but since all monads are applicative
01:18:16 <quicksilver> (including, for example, State)
01:18:22 <sjanssen> because the generator is passed sequentially
01:18:25 <quicksilver> you are always free to use a monad in an applicative fashion
01:18:28 <quicksilver> if you choose
01:18:54 <quicksilver> foo <$> rnd1 <*> rnd2 <*> pure purefn <*> rnd3
01:19:01 <sjanssen> quicksilver: yes, of course Monad subsumes Applicative.  My proposal is "more useful" because it is lazier
01:19:31 <quicksilver> sjanssen: applicatives are no less 'sequential' than monads, though
01:19:38 <quicksilver> indeed, 'sequence' is the very essence of applicative
01:19:47 <quicksilver> applicatives are unable to express general wiring diagrams
01:19:56 <sjanssen> the types in Applicative do give you a bit more freedom
01:19:58 <quicksilver> you can't wire the output of one effect into the input of the next
01:20:06 <quicksilver> but the effects are still quite definitely sequences
01:20:23 <sjanssen> but the laws take away that freedom :(
01:20:32 <sjanssen> quicksilver: you should just look at my code
01:20:49 <quicksilver> :)
01:20:50 <sjanssen> if my Rand was an Applicative, it would be very useful
01:21:29 <quicksilver> why? what is this extra laziness of which you speak?
01:21:54 <quicksilver> (yes, I am reading your code)
01:22:19 <quicksilver> you mean you don't have to evaluate "all of" f just to get the new randomgen out
01:22:22 <quicksilver> I can see that
01:22:25 * quicksilver nods
01:22:30 <quicksilver> but I can't quite see why that would matter?
01:23:41 <quicksilver> I think your instance "morally" satisfies the laws, personally
01:24:43 <quicksilver> extra randomgen splits don't "matter" in some sense
01:25:04 <quicksilver> (the same sense in which Random is a commutative monad even though it isn't technically)
01:25:40 <hpaste>  sjanssen annotated "random (not) applicative" with "demo" at http://hpaste.org/3749#a1
01:25:59 <sjanssen> try doing demo with State
01:26:47 <quicksilver> ah, I understand
01:26:49 <quicksilver> interesting
01:26:50 <mux> dcoutts: yes, why?
01:27:47 <quicksilver> sjanssen: I have a total programmer's intuition, I miss out on infinite list examples sometimes :)
01:29:36 <sjanssen> this could also be a (law-breaking) Monad
01:34:58 <hpaste>  sjanssen annotated "random (not) applicative" with "Rand as a (law-breaking) Monad" at http://hpaste.org/3749#a2
01:36:54 <quicksilver> sjanssen: depending if you think it's OK to only satisfy laws up to "observability"
01:37:05 <quicksilver> sjanssen: and depending how you define observability for Random
01:37:11 <sjanssen> right
01:37:22 <sjanssen> I do agree on the "moral" standpoint
01:39:13 * mux notes many project euler problems lends themselves very well to haskell
01:41:13 <doserj> only the simple ones :) the other ones require some real number theory, besides haskell.
01:42:37 <mux> cfrac = foldr1 (\x y -> x + 1 / y)
01:42:39 <mux> cute :)
01:43:52 <quicksilver> doserj: yeah, but haskell does make the computery bits simpler
01:44:32 <doserj> true, of course. But that was a tautology, and does not only apply to project euler :)
01:47:53 <b_jonas> I don't do projecteuler, but do other problems where I use a computer to do some quick calculation (esp with numbers)
01:48:13 <b_jonas> amd then I use the J programming language which is good for quick throw-away computations
01:48:47 <faxathisia> the J solutions for euler are really beautiful
01:49:05 <b_jonas> I don't know if they always are
01:49:11 <b_jonas> there are some things I find difficult in J
01:49:12 <faxathisia> all the ones I saw
01:49:25 <b_jonas> but in those cases I don't use J
01:49:55 <doserj> I don't speak J, but I guess most are essentially the same as the haskell ones, only with each haskell function replaced by a single character
01:50:46 <faxathisia> doserj: I don't think so really
01:51:20 <b_jonas> sort of, but not exactly
01:51:30 <b_jonas> they both use pointfree style
01:52:18 <b_jonas> an example I've done is http://www.jsoftware.com/jwiki/Essays/ConnectedFigures
01:52:22 <lambdabot> Title: Essays/ConnectedFigures - J Wiki
01:53:15 <b_jonas> but the most useful are of course the ones I don't even save
01:53:22 <b_jonas> just calculate and throw away
01:58:08 <mux> cfrac :: Integral a => [a] -> Ratio a
01:58:08 <mux> cfrac = foldr1 (\x y -> x + 1 / y) . map (% 1)
01:58:11 <mux> any comments?
01:59:13 <faxathisia>  > cfrac (take 50 $ repeat 1) where cfrac = foldr1 (\x y -> x + 1 / y) . map (% 1)
01:59:31 <quicksilver> mux: instead of map (%1) you could just use map fromIntegral
01:59:47 <faxathisia> lambdabot: It's not that hard
01:59:58 <quicksilver> mux: or map toRational
02:00:01 <mux> quicksilver: *nods* that makes sense, thanks
02:00:19 <doserj> faxathisia: it is, if you write a space at the front...
02:00:25 <quicksilver> but I thik fromIntegral is most right here
02:00:28 <faxathisia> aww :(
02:00:36 <mux> @let cfrac = foldr1 (\x y -> x + 1 / y) . map fromIntegral
02:00:47 <lambdabot> Defined.
02:01:06 <mux> > realToFrac . cfrac $ 1 : replicate 10 2
02:01:07 <lambdabot>  1.4142135516460548
02:01:12 <mux> > realToFrac . cfrac $ 1 : replicate 20 2
02:01:13 <lambdabot>  1.414213562373095
02:01:18 <mux> > realToFrac . cfrac $ 1 : replicate 30 2
02:01:20 <lambdabot>  1.4142135623730951
02:01:23 <mux> > sqrt 2
02:01:24 <lambdabot>  1.4142135623730951
02:01:29 <mux> yay.
02:01:34 <faxathisia> > realToFrac . cfrac $ 1 : replicate 30 1
02:01:35 <lambdabot>  1.6180339887496482
02:01:50 <faxathisia> > (/2) (1+sqrt 5)
02:01:51 <lambdabot>  1.618033988749895
02:02:10 <faxathisia> nice
02:03:30 <mux> > cfrac [4,2,6,7] == 415/93
02:03:32 <mux> err
02:03:32 <lambdabot>  False
02:03:34 <mux> > cfrac [4,2,6,7] == 415%93
02:03:35 <lambdabot>  Couldn't match expected type `Double'
02:03:45 <mux> what the
02:04:22 <faxathisia> > cfrac [1,1,1,1,1] :: Rational
02:04:23 <lambdabot>  Couldn't match expected type `Rational'
02:04:24 <mux> ah, damn, since I didn't have a type annotation, lambdabot didn't see that cfrac is supposed to return a Ratio
02:04:38 <mux> > cfrac [4,2,6,7] :: Ratio Integer
02:04:39 <lambdabot>  Couldn't match expected type `Ratio Integer'
02:05:05 <mux> > 415/93
02:05:06 <lambdabot>  4.462365591397849
02:05:17 <mux> > realToFrac . cfrac $ [4,2,6,7]
02:05:18 <lambdabot>  4.46236559139785
02:05:53 <mux> @users
02:05:53 <lambdabot> Maximum users seen in #haskell: 424, currently: 363 (85.6%), active: 8 (2.2%)
02:13:11 <hpaste>  Ryan pasted "words function help....." at http://hpaste.org/3750
02:17:09 <Sizur> emacs or xemacs?
02:18:15 <doserj> > (^2) . cfrac . take 20 $ 1:1:concat [[1,1,4*x+1] | x <- [1..]]
02:18:17 <lambdabot>  2.7182818284590455
02:18:47 <doserj> > exp 1
02:18:48 <lambdabot>  2.718281828459045
02:19:06 <sieni> Sizur: http://www.zedlopez.com/strangeloopiness/2007/04/tolerance.html
02:19:11 <lambdabot> Title: Strange Loopiness: Tolerance
02:19:53 <b_jonas> Ryan: you forgot to define  rStrings2Results when the second arg is the empty list
02:20:20 <Sizur> sieni: rofl that's a good one
02:20:29 <b_jonas> no, wait, there are worse problems with it than that
02:21:44 <b_jonas> don't you want something like 'rStrings2Results :: (String -> String) -> [String] -> [String]' ?
02:21:53 <b_jonas> or maybe I don't get what you want to do exactly
02:21:59 <Sizur> seriously, i'm new to emacs, can you have same haskell mode in both?
02:27:35 <doserj> > map (\k -> (exp 1)**(1/k)) [1..5]
02:27:37 <lambdabot>  [2.718281828459045,1.6487212707001282,1.3956124250860895,1.2840254166877414,...
02:27:48 <doserj> > map (\k -> cfrac $ concat [[1,(2*x+1)*k-1,1] | x <- [0..20]]) [1..5]
02:27:49 <lambdabot>  [2.7182818284590455,1.6487212707001282,1.3956124250860895,1.2840254166877414...
02:28:53 <mux> @let cfrac' = foldr1 (\x y -> x + 1 / y) . map (%1) -- forcing a Ratio a type
02:29:06 <lambdabot> Defined.
02:29:08 <mux> > cfrac' [4,2,6,7)
02:29:09 <lambdabot> Unbalanced parentheses
02:29:12 <mux> > cfrac' [4,2,6,7]
02:29:13 <lambdabot>  415%93
02:41:08 <doserj> > (cfrac $ concat [[1,2*n+1]|n<-[0..20]]) - tan 1
02:41:10 <lambdabot>  6.19079440489223e-17
02:54:34 <mwc_> hey, what's the utility producing transcripts of a command line utility? Need it to file a proper ghc bug report...
02:55:40 <b_jonas> script (for the characters echoed to the terminal) or, better, the log feature of screen (which stores the characters appearing on the console)
02:56:19 <mwc_> b_jonas: that's the one. I always apropos for transcript, and can never find it
02:56:22 <b_jonas> screen -L
03:05:20 <hpaste>  Orchid pasted "Refactor required" at http://hpaste.org/3751
03:11:40 <hpaste>  quicksilver annotated "Refactor required" with "possible improvment" at http://hpaste.org/3751#a1
03:23:43 <hpaste>  sizur annotated "Refactor required" with "(no title)" at http://hpaste.org/3751#a2
03:24:30 <dcoutts> mux: oh, I was looking for someone to try the gtk2hs release on *BSD. I didn't manage to test it there before the release.
03:24:30 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:27:28 <b_jonas> why are normal (boxed) io arrays missing from here ---> http://haskell.org/ghc/docs/latest/html/libraries/array-0.1.0.0/Data-Array-IO.html
03:27:30 <lambdabot> http://tinyurl.com/2f4jb6
03:27:41 <b_jonas> do those not exist, or just not documented?
03:31:11 <b_jonas> :k IOArray
03:31:15 <lambdabot>     Not in scope: type constructor or class `IOArray'
03:31:20 <b_jonas> :k IOUArray
03:31:22 <lambdabot>     Not in scope: type constructor or class `IOUArray'
03:31:43 <b_jonas> :k Data.Array.IO.IOUArray
03:31:44 <lambdabot> * -> * -> *
03:31:47 <b_jonas> :k Data.Array.IO.IOArray
03:31:48 <lambdabot> * -> * -> *
03:31:53 <b_jonas> so it does exist at least
03:32:09 <hpaste>  sizur annotated "Refactor required" with "more refunctoring" at http://hpaste.org/3751#a3
03:32:13 <wieczyk> hi
03:32:24 <wieczyk> are someone here ?
03:32:51 <b_jonas> these arrays are wierd
03:33:43 <wieczyk> Can someone help me to write some program in haskell to generate lists ? for example: for 3 elements [0,0,0] [0,0,1] [0,1,0] [0,1,1] [1,0,0] [1,0,1] [1,1,0] [1,1,1].
03:33:59 <wieczyk> my brain wanted to use loops, but i dont have loops ;]
03:35:08 <dikini> wieczyk: you have recursion and recursive little helpers like foldl, map, in your case best look at the unfolds
03:35:50 <Sizur> anamorphisms? :P
03:35:53 <dikini> and relatatives like iterate
03:35:58 <doserj> there is also list comprehension
03:36:26 <wieczyk> i know, but i dont have idea how to do this. I am learnign progfun on my univ, but my brain is too much influeced by imperativ programming ;]
03:36:32 <Sizur> list comprehention is easy, but you have to know the number of 'elements' at compilation time
03:37:01 <b_jonas> Sizur: you can use recursion with list comprehensions
03:37:19 <doserj> the programmable list comprehension is called Monad :)
03:37:25 <Sizur> b_jonas: that gives me a headache :P
03:37:34 <wieczyk> Monad ? hmm.
03:37:45 <b_jonas> Sizur: yeah, there's not much point to do that
03:37:46 <wieczyk> Hmm
03:37:51 <b_jonas> I'd just use map with recursions
03:37:52 <idnar> > [x ++ y ++ z | x <- [0,1]; y <- [0,1]; z <- [0,1]]
03:37:52 <lambdabot>  Parse error at ";" (column 26)
03:37:56 <b_jonas> let's try
03:38:01 <idnar> > [x ++ y ++ z | x <- [0,1], y <- [0,1], z <- [0,1]]
03:38:02 <lambdabot>   add an instance declaration for (Num [a])
03:38:02 <lambdabot>     In the expression: 1
03:38:02 <lambdabot>     In a...
03:38:11 <idnar> ag, oops
03:38:13 <wieczyk> But i need to write function for n elements.
03:38:19 <idnar> > [[x,y,z] | x <- [0,1], y <- [0,1], z <- [0,1]]
03:38:20 <wieczyk> Maybe i will try do some easy recursion
03:38:20 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
03:38:34 <doserj> > replicateM 3 [0,1]
03:38:35 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
03:38:45 <wieczyk> o, thanks.
03:38:47 <Sizur> nice
03:38:47 <b_jonas> > let { f x = map (0:) x ++ map (1:) x; } in f f f [[0]]
03:38:48 <lambdabot>  Couldn't match expected type `[[t]]'
03:38:54 <ricky_clarkson> @source replicateM
03:38:54 <lambdabot> replicateM not available
03:38:57 <idnar> heh
03:39:03 <b_jonas> > let { f x = map (0:) x ++ map (1:) x; } in f . f . f [[0]]
03:39:04 <lambdabot>  Couldn't match expected type `a -> [[t]]'
03:39:08 <Sizur> > replicateM 2 [0,1,2]
03:39:08 <b_jonas> > let { f x = map (0:) x ++ map (1:) x; } in f . f . f $ [[0]]
03:39:10 <lambdabot>  [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
03:39:10 <lambdabot>  [[0,0,0,0],[0,0,1,0],[0,1,0,0],[0,1,1,0],[1,0,0,0],[1,0,1,0],[1,1,0,0],[1,1,...
03:39:19 <b_jonas> > let { f x = map (0:) x ++ map (1:) x; } in f . f . f $ [[]]
03:39:20 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
03:39:28 <wieczyk> whoa, i need to learn much of f. programming
03:39:39 <wieczyk> do you know some sites where i can read some articles etc etc ?
03:40:56 <b_jonas> J programmers disagree in whether (>,{3$<i.2) or (#:i.2^3) is the better way to do this
03:41:47 <ricky_clarkson> Wow, that's hard to read.  Must be really powerful!
03:41:53 <ricky_clarkson> @quote newsham
03:41:53 <lambdabot> newsham says: over here in america we take people with all sorts of names (except mohammed)
03:42:10 <Sizur> lol
03:42:47 <idnar> > iterate (\ys -> [(x:y) | x <- [0,1], y <- ys]) [[]] !! 3
03:42:49 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
03:43:02 <Sizur> i like replicateM better
03:43:10 <Sizur> @type replicateM
03:43:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:43:44 <ricky_clarkson> @quote Newsham's
03:43:44 <lambdabot> newsham says: Newsham's Law: the more powerful the abstraction, the more unclear it is until you understand it :)
03:44:38 <b_jonas> ricky_clarkson: lol
03:44:52 <b_jonas> there's no powerful abstraction in those statements though
03:46:30 <b_jonas> there's no pointfree or stuff like that either as in some complicated J statements I write
03:47:22 <b_jonas> you could do it with map and stuff too, if you wanted
03:48:50 <wieczyk> What do you think about this solution:
03:49:03 <wieczyk> I will have function: gen(n)
03:49:42 <wieczyk> and gen_aux(n)
03:49:44 <b_jonas> like (([:,/0 1,"0 1/])^:3 i.1 0)
03:49:58 <wieczyk> gen_aux(n,lists) <- this
03:50:55 <wieczyk> gen_aux is working recursive [ with tail recursion ]: is generating two lists for every list in lists: list_from_lists::1 and lists_from_lists::0 and is calling gen_aux(n-1,new_lists);
03:51:01 <wieczyk> gen(n) is usig gen_aux
03:51:02 <wieczyk> ?
03:51:10 <wieczyk> it is 'funtcional' solution ?
03:53:14 <b_jonas> try to write it in haskell, if it's easy to, it's probably functional
03:54:27 <wieczyk> i need to use ocaml in univ.
03:54:32 <wieczyk> Haskell in next semester ;]
03:55:11 <wieczyk> but i have almost write this.
03:55:32 <wieczyk> btw: do you know some resources with can help to learn functional paradigm ?
03:55:51 <ricky_clarkson> wieczyk: sicp
03:56:26 <b_jonas> or HOP
03:57:19 <b_jonas> @src (->) (>>=)
03:57:19 <lambdabot> f >>= k = \ r -> k (f r) r
03:57:22 <b_jonas> @src (->) return
03:57:22 <lambdabot> return = const
03:57:51 <b_jonas> I gotta figure out what that's for
03:58:49 <wieczyk> sicp ?
03:59:15 <b_jonas> @google sicp
03:59:17 <lambdabot> http://mitpress.mit.edu/sicp/
03:59:17 <lambdabot> Title: Welcome to the SICP Web Site
03:59:40 <ricky_clarkson> wieczyk: If you have questions like "sicp ?" it's probably better to go and work in a supermarket. ;)
04:00:39 <b_jonas> I mean, instance Monad ((->) r) looks completely unclear to me, so it must be a powerful abstraction according to that law you quoted
04:01:50 <wieczyk> and what is a HOP ?
04:02:20 <osfameron> book on functional programming with Perl
04:02:28 <b_jonas> http://perl.plover.com/hop/
04:02:29 <lambdabot> Title: Higher-Order Perl
04:02:34 <wieczyk> thanks
04:05:18 <wieczyk> ok, cya
04:05:20 <wieczyk> thanks for help ;]
04:07:44 <SamB_XP> b_jonas: it isn't as abstract as it could be
04:20:11 <mux> dcoutts: okay, I'll give it a try and let you know
04:20:20 <dcoutts> mux: thanks!
04:26:48 <joelr1> good day
04:27:56 <mux> > cfrac' (1:replicate 10 2)
04:27:58 <lambdabot>  8119%5741
04:28:06 <mux> 8119/5741
04:28:12 <mux> > 8119/5741
04:28:13 <lambdabot>  1.4142135516460548
04:28:18 <mux> > sqrt 2
04:28:20 <lambdabot>  1.4142135623730951
04:28:29 <mux> > cfrac' (1:replicate 30 2)
04:28:30 <lambdabot>  367296043199%259717522849
04:28:30 <joelr1> is anyone using colloquy? how do you make it show the # of people in a channel?
04:28:36 <wli> You should be able to get a sequence of convergents.
04:28:45 <mux> > 367296043199/259717522849
04:28:47 <lambdabot>  1.4142135623730951
04:29:37 <wli> Your current lower and upper bounds should differ by the reciprocal of the product of their denominators.
04:30:22 <mux> wli: pardon me, but were you talking to me? :-)
04:30:41 <wli> Yes.
04:31:07 <mux> well, I don't know what is a sequence of convergents
04:31:25 <wli> wikipedia should walk you right through it all. It's very straightforward.
04:31:46 <wli> Their continued fraction article has enough to do it and then some.
04:32:07 <mux> are you saying my cfrac functon isn't working?
04:32:17 <mux> yeah well I coded this function basing myself on wikipedia
04:33:06 <wli> mux: Why not use the recurrence in http://en.wikipedia.org/wiki/Continued_fraction#Some_useful_theorems
04:33:08 <mux> > [ cfrac' (1:replicate n 2) | n <- [1..30] ]
04:33:09 <lambdabot> http://tinyurl.com/y7ojve
04:33:10 <lambdabot>  [3%2,7%5,17%12,41%29,99%70,239%169,577%408,1393%985,3363%2378,8119%5741,1960...
04:33:48 <mux> wli: here's my code:
04:33:49 <mux> cfrac :: Integral a => [a] -> Ratio a
04:33:49 <mux> cfrac = foldr1 (\x y -> x + 1 / y) . map fromIntegral
04:33:53 <mux> is there a problem with that?
04:35:25 <wli> mux: I'd use the recurrences for the numerators and denominators.
04:37:31 <mux> wli: oh ok, you mean you would use the formulas to calculate each numerator/denominator at once?
04:38:13 <mux> like hn/kn = an*h(n-1)+h(n-2)/an*k(n-1)+k(n-2)
04:38:17 <mux> wli: this one?
04:39:11 <mux> dcoutts: mmm, huge build failure for gtk2hs :-/
04:39:21 <dcoutts> oh :-(
04:39:23 <dcoutts> @hpaste ?
04:39:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:39:36 <SamB_XP> mux: what do you mean huge?
04:39:38 <mux> yeah, doing that
04:39:51 <hpaste>  mux pasted "gtk2hs" at http://hpaste.org/3752
04:40:00 <mux> I've trimmed it down, there's more of it
04:40:22 <dcoutts> mux: what gcc version is that?
04:40:46 <hpaste>  mux annotated "gtk2hs" with "weird?" at http://hpaste.org/3752#a1
04:40:59 <mux> dcoutts: 4.2.1
04:41:15 <dcoutts> mux: yeah, I think you'll have to ./configure --disable-split-objs
04:41:30 <mux> yeah, was going to try that
04:41:33 <dcoutts> mux: ghc 6.6 at least does not like gcc-4.2
04:41:34 <mux> fine then, let's go
04:41:55 <dcoutts> 6.8.x might be happy with gcc-4.2
04:42:22 <matthew_-> @seen holzensp
04:42:22 <lambdabot> I saw holzensp leaving #haskell 19h 52m 51s ago, and .
04:42:23 <dcoutts> what changed was that in gcc 4.2 they allowed top level function reordering, which messed up the split markers that ghc used to to the split-objs
04:42:33 <wli> > let cfrac as = let f u v = let xs = u : v : zipWith (+) xs (zipWith (*) as $ tail xs) in xs ; hs = f 0 1 ; ks = f 1 0 in drop 2 $ zipWith (/) hs ks in take 10 $ cfrac (repeat 1) :: [Rational]
04:42:41 <lambdabot>  [1%1,2%1,3%2,5%3,8%5,13%8,21%13,34%21,55%34,89%55]
04:42:57 <dcoutts> mux: the workaround (applied in ghc 6.8) was to use -fno-top-level-reorder instead of -fno-unit-at-a-time
04:43:13 <mux> I could stick this gcc flag in the .cabal file then?
04:43:19 * SamB wonders why one of his friends sent him a file called DUI.mid
04:43:31 <wli> > let cfrac as = let f u v = let xs = u : v : zipWith (+) xs (zipWith (*) as $ tail xs) in xs ; hs = f 0 1 ; ks = f 1 0 in drop 2 $ zipWith (/) hs ks in take 10 $ cfrac (1 : repeat 2) :: [Rational]
04:43:33 <lambdabot>  [1%1,3%2,7%5,17%12,41%29,99%70,239%169,577%408,1393%985,3363%2378]
04:43:52 <mux> > [ cfrac' (1:replicate n 2) | n <- [1..] ]
04:43:53 <lambdabot>  [3%2,7%5,17%12,41%29,99%70,239%169,577%408,1393%985,3363%2378,8119%5741,1960...
04:44:19 <SamB> whoa...
04:44:27 <wli> mux: Now time them. ;)
04:44:27 <dcoutts> mux: it's not that simple unfortunately, we tried that. It didn't work.
04:44:42 <SamB> they just made another branch of ZSNES
04:44:44 <pejo> dcoutts, don't they reorder for performance? Or is the NCG the 'supported' way for performance nowdays?
04:44:47 <mux> wli: heh, I'm sure yours is faster, since it avoids Data.Ratio stuff :-)
04:44:49 <SamB> I thought they had sworn off branching!
04:45:12 <mux> wli: I like the fact that my code is the simplest expression of the definition of continued fractions
04:45:21 <mux> dcoutts: ok
04:45:37 <wli> mux: Not just that. It doesn't recapitulate the entire call stack for each depth of fractions.
04:45:37 <dcoutts> pejo: it was gcc that was reordering. ghc also does some munging of the gcc output (the evil mangler). Yes, the NCG is going to be the high perf backend in future.
04:45:46 <mux> wli: yeah right
04:47:22 <SamB> then we can ditch the mangler, right?
04:48:04 <mux> dcoutts: heh, ghc just core dumped on me, trying to build Drag.hs
04:48:15 <dcoutts> :-(
04:48:23 <mux> nevermind, that must have been my cpu heating too much
04:48:29 <mux> I restarted it and it went fine
04:48:32 <dcoutts> heh
04:48:52 <mux> those C2D laptops are nice, impressively fast, but they heat quite a lot
04:51:59 <SamB_XP> wow, my desktop is a mess
04:52:06 <SamB_XP> I think I had four firefox installers on it
04:52:16 <quicksilver> dcoutts: NCG is C-- -> native, right? not core -> native?
04:52:44 <dcoutts> quicksilver: core -> C-- -> native. Yes.
04:52:49 * quicksilver nods
04:52:59 <quicksilver> dcoutts: I wonder why the C-- -> native part isn't unbundled
04:53:04 <quicksilver> seems like it ought to be conceptually separate
04:53:18 <quicksilver> and certainly that's the message from SPJ's motivational seminars on C--
04:53:20 <wli> mux: How about scanl1 (\x y -> y + recip x) . map fromIntegral ?
04:53:57 <dcoutts> quicksilver: it's only a C-- subset
04:54:04 <quicksilver> dcoutts: hmm
04:54:08 <dcoutts> and it currently knows too much about ghc stuff
04:54:13 * quicksilver nods
04:54:23 <quicksilver> so it kind of isn't C-- at all :)
04:54:35 <bartw> why c-- at all then ? why not straight to asm ?
04:54:54 <quicksilver> bartw: to separate clearly the part you need to reimplement for different hardwares
04:55:03 <quicksilver> bartw: rather than having to rewrite all of GHC for each chip :)
04:55:07 <dcoutts> bartw: it's a good intermediate representation
04:56:16 <pejo> Isn't Core some System F variant?
04:56:26 <bartw> ah right
04:56:31 <dcoutts> pejo: yep
04:56:41 <dcoutts> system Fc iirc
04:56:56 <dcoutts> system F extended with type coercions
04:57:03 <bartw> working on my own compiler, goign straight to pe binaries, but without an optimizer it doesn't seem hard to change platforms
04:57:12 <pejo> I can see why you would want C-- from a debugging pov atleast then.
04:57:33 <SamB_XP> bartw: it probably ought to involve less GHC knowlege, too
04:57:40 <dcoutts> it also allows part of the rts and certain primitives to be written in C-- and compiled directly by ghc
04:57:49 <SamB_XP> standard C-- also seems to have an awful lot of features
04:58:03 <mux> dcoutts: build terminated fine
04:58:12 <dcoutts> mux: great, thanks
04:59:16 <mux> wli: that makes a lot of sense if you want to generate the full list of numerators/denominators indeed
04:59:52 <mux> @check \x -> recip x == 1 / (x :: Rational)
04:59:54 <lambdabot>  Exception: Ratio.%: zero denominator
05:00:02 <mux> @check \x -> x /= 0 ==> recip x == 1 / (x :: Rational)
05:00:04 <lambdabot>  OK, passed 500 tests.
05:00:17 * mux hearts quickcheck
05:01:03 <ivanm> how does quickcheck work? generates a whole bunch of random input data and tries it on the test?
05:01:44 <TSC> Yes, starting with "smaller" input
05:01:46 <opqdonut> yep
05:02:14 <ivanm> *nod*
05:02:24 <ivanm> TSC: so how do you define "smaller" input?
05:02:33 <SamB> isn't there a paper?
05:02:37 <bartw> does it include some sensible non random data too ?
05:02:46 <ivanm> in this case, is smaller like 1, or like -1000 ?
05:02:47 <bartw> -1 0 1 maxint that sort of thing ?
05:02:47 <TSC> Depends on the input type; for lists, fewer elements; for integers, smaller magnitude, etc.
05:03:01 <ivanm> ahhh, thought so
05:03:03 <wli> mux: You can always get at things using (!!) or similar.
05:03:17 <SamB> notice how 1 is narrower than -1000
05:03:26 <TSC> You can define your own idea of random input and smallness, of course
05:03:56 <TSC> bartw: I don't think it has any notion of boundary cases
05:04:06 <mux> wli: yes
05:04:11 <wli> mux: Or use scanl vs. scanl1
05:05:22 <mux> wli: I actually used scanr1
05:05:39 <wli> Sounds good.
05:05:54 <bringert> does anyone have an example program using the X11 package?
05:05:54 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
05:05:59 <bringert> hello world is enough
05:06:03 <TSC> xmonad? (:
05:06:08 <mux> wli: but I've got the list reversed
05:06:23 <bringert> TSC: heh
05:06:24 <mux> > scanr1 (\x y -> x + recip y) [1,2,2,2]
05:06:27 <lambdabot>  [1.4166666666666667,2.4,2.5,2.0]
05:06:42 <mux> > scanr1 (\x y -> x + recip y) $ map (%1) [1,2,2,2]
05:06:43 <bringert> I was looking for more of an application rather than a window manager
05:06:44 <lambdabot>  [17%12,12%5,5%2,2%1]
05:06:49 <fasta> bringert: xmonad?
05:07:08 <mux> hmm, it's no good
05:07:12 <fasta> bringert: oh, never mind
05:08:38 <quicksilver> bringert: why would an application use the x11 package? :)
05:08:45 <quicksilver> bringert: Xlib is a terrible, terrible toolkit
05:08:54 <quicksilver> bringert: you only use it if you're writing something low level like a window manager
05:09:24 <bringert> quicksilver: sure. it'm just doing some debugging. I've tried a wxHaskell program and and OpenGL program and they both segfault. I want to see if it's X/Haskell-related, or something else
05:09:31 * quicksilver nods
05:09:55 <quicksilver> but, that is I think why you won't find one easily
05:10:07 <bringert> true
05:10:17 <bringert> there should be one in the X11 repo, but there isn't
05:10:26 <quicksilver> bringert: ah!
05:10:31 <quicksilver> http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell
05:10:33 <lambdabot> Title: X window programming in Haskell - HaskellWiki, http://tinyurl.com/2bpml8
05:10:38 <quicksilver> ^^ I believe the above has your answer
05:10:50 <quicksilver> setTextProperty dpy win "Hello World" wM_NAME
05:10:52 <quicksilver> ;)
05:11:02 <bringert> quicksilver: thanks!
05:13:53 <takamura> hi
05:14:49 <ivanm> is this an acceptable form for writing map: map' f xs = do x <- xs ; let y = f x; return y
05:15:04 <ivanm> I'm wanting to use it as an example
05:15:09 <ivanm> it looks the same to me...
05:15:30 <scook0> that's a pretty enterprising definition of map
05:15:54 <quicksilver> ivanm: I can't imagine the monad in which that corresponds to 'map'
05:15:56 <Saizan> ?src liftM
05:15:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:16:08 <ivanm> quicksilver: for lists
05:16:09 <quicksilver> erm
05:16:12 <quicksilver> yes I can :)
05:16:12 <scook0> quicksilver: ye list monad
05:16:15 * quicksilver slaps himself
05:16:28 <quicksilver> Yes, I agree.
05:16:33 <quicksilver> the let statement is a bit odd
05:16:37 <ivanm> I'm using it as an example of how functions rip data out of data structures, do something to them, and put them back in again
05:16:41 <quicksilver> but presumably that's part of your example
05:16:42 * quicksilver nods
05:16:47 <ivanm> yeah, it is
05:17:15 <scook0> I don't think it's a very good definition for *actual use*
05:17:20 <scook0> but it's certainly interesting
05:17:33 <ivanm> no, it's not for actual use
05:17:53 <ivanm> I'm writing up a paper about how data structures should be replaced by functions
05:18:00 <scook0> it essentially defines map as a trivial case of concatMap
05:18:06 <ivanm> *nod*
05:18:53 <doserj> scook0: it is essentially the default definition for fmap in Monads, if that would be possible in Haskell...
05:19:28 <scook0> doserj: yeah, I figured that out, but I wasted time trying to come up with the actual (short) definition
05:19:34 <scook0> :)
05:21:12 <quicksilver> xs >>= return . f
05:21:24 <fasta> ivanm: how do you mean "should"?
05:21:31 <quicksilver> I believe, although I can't remember the precedences and if that needs brackets
05:21:42 <fasta> ivanm: and by data structures, don't you mean pure functional data structures?
05:21:43 <ivanm> fasta: I didn't say I agreed with it, that's just the topic :p
05:21:53 <ivanm> no
05:21:57 <scook0> map' f xs = [ f x | x <- xs ] -- :)
05:22:22 <fasta> ivanm: so... that would mean you did something new.
05:22:27 <ivanm> it's kind of the extension of FP, where functions are first class data, so that now functions are most data
05:22:42 <ivanm> fasta: it's for a professor of mine, it's his grand theory of FP :p
05:23:00 <fasta> ivanm: how can you fake a mutable tree with it?
05:23:04 <ivanm> fasta: see here: http://www.itee.uq.edu.au/~paul
05:23:05 <lambdabot> Title: Paul Bailes
05:23:14 <ivanm> it's not a perfect theory :p
05:23:34 <ivanm> but it's about how you replace data structures with their "characteristic functions"
05:23:46 <ivanm> which are all some kind of fold
05:24:03 <scook0> bananas!
05:24:07 <fasta> ivanm: I wrote a fold in the ST monad for my mutable tree.
05:24:34 <fasta> ivanm: but I don't see (other than a naieve way that only works in theory) an efficient way to get rid of ST.
05:24:34 <ivanm> fasta: as in instead of the tree?
05:24:42 <ivanm> exactly! :p
05:24:46 <ivanm> it's only theory
05:24:52 <ivanm> for starters, it's untypeable
05:25:09 <fasta> ivanm: the "theory" I implemented, is completely trivial.
05:25:29 <fasta> ivanm: so, I might hope that this is about something else.
05:25:41 <dikini> ivanm: like pure scheme?
05:26:01 <ivanm> dikini: not quite
05:26:05 <ivanm> fasta: OK... consider sets
05:26:59 <ivanm> let's say we have: data Set a = Empty | Singleton a | Union (Set a) (Set a)
05:27:09 <ivanm> the "characteristic function" on sets is a membership test
05:27:19 <ivanm> so: member :: Set a -> Bool
05:27:44 <EvilTerran> or, what you're thinking, Set a = a -> Bool?
05:27:49 <ivanm> I mean: member :: (Eq a) => Set a -> a -> Bool
05:27:54 <ivanm> yeah ;-)
05:28:10 <EvilTerran> union s t x = s x || t x; etcetc
05:28:29 <ivanm> member Empty _ = False; member (Singleton e) x = x == e; member (Union s1 s2) x = (member s1 x) || (member s2 x)
05:28:33 <ivanm> yeah
05:29:02 <EvilTerran> sounds rather like church encodings
05:29:03 <ivanm> so, let's combine the data structure (Set a) with the characteristic function (member)
05:29:09 <ivanm> we write: member s x = s x
05:29:44 <ivanm> where: empty x = False; (singleton e) x = x == e; (union s1 s2) x == (member s1 x) || (member s2 x)
05:30:05 <EvilTerran> although the normal church encoding for lists (representing a list xs as (\f e -> foldr f e xs)) has always struck me as a bit off
05:30:39 <EvilTerran> as it makes, eg, O(1) tail impossible
05:30:47 <ivanm> and that's what I mean by replacing data structures with functions... somehow create meta-functions that define a "data structure" by their fold-like characteristic functions
05:31:12 <ivanm> and yes, church-encoding-based lists, bools, numerals, etc. all fit into this scheme
05:31:14 <EvilTerran> (\f e -> case xs of x:xs -> f x xs; [] -> e) seems more sensible
05:31:41 <EvilTerran> seeing as it's still fairly straightforward to write a foldr using that definition and fix
05:31:43 <ivanm> so an implicit split?
05:31:48 <scook0> EvilTerran: foldr is the "obvious" choice, though
05:32:00 <ivanm> don't forget, efficiency is an implementation problem :p
05:32:02 <EvilTerran> i think unwrapping only the outermost constructor is far more obvious
05:32:10 <ivanm> fasta: anyway, that's the kind of stuff I'm aiming at
05:32:17 <fasta> ivanm: I don't see how this will help faking mutability.
05:32:22 <ivanm> it's not
05:32:29 <fasta> ivanm: which you need to implement some data structures.
05:32:41 <ivanm> this isn't intended to be the be-all and end-all
05:33:03 <fasta> ivanm: I said: so this is for pure functional data structures only and then you said no.
05:33:17 <fasta> ivanm: AFAICS, it is.
05:33:19 <ivanm> oh, I misunderstood your question
05:33:32 <ivanm> don't know what I was thinking :s
05:33:45 <fasta> And AFAICS, you are just using the closures to store the data.
05:33:46 <EvilTerran> if you were to mechanically convert an algebraic data type decleration into a church-encoding of the type, it'd seem far more natural to me for the encoding to take a function for each constructor, and apply the appropriate function directly to the constructor's parameters
05:33:51 <ivanm> yes
05:33:55 <Toxaris> ivanm: what has "(union s1 s2) x == (member s1 x) || (member s2 x)" to do with chuch-encoding-style data representation? it looks very much like union being a constructor-like function, but function-valued and not value-valued?
05:34:24 <ivanm> Toxaris: this is what my prof calls an "impure platonic combinator", with church-based ones being "pure platonic combinators"
05:34:24 <EvilTerran> not doing any fancy-schmancy recursion if the type happens to be recursive
05:34:26 <fasta> And, imho, it looks like a bad idea, but I would be happy to be proven wrong.
05:34:34 <ivanm> impure has to store some data and know what it is, pure doesn't
05:34:45 <Toxaris> ivanm: and shouldn't it be "(union s1 s2) x == s1 x || s2 x", without calls to member?
05:35:05 <ivanm> fasta: looks like a bad idea to me too, but it was the only haskellish project I could find :p
05:35:18 <ivanm> Toxaris: that's how he defined it... *shrug*
05:35:43 <ivanm> fasta: though with your mutable tree example, is it mutable solely for efficiency purposes? or is there uses when a purely functional tree won't suffice?
05:35:57 <dikini> asynchronous processes and messaging reflect references and mutability quite well, imo
05:36:39 <fasta> ivanm: "solely for efficiency purposes"? If efficiency didn't matter, why wouldn't we just only write specs and let theorem provers build the programs?
05:37:10 <fasta> ivanm: It's the same reason you use an array as opposed to a list when you want fast "find element by index".
05:37:44 <Philippa> EvilTerran: avoiding fix has useful theoretical properties
05:38:30 <EvilTerran> it's just moving the recursion around, though
05:38:31 <ivanm> fasta: I'm not denegrating efficiency... I'm just asking if there was some deep, theoretical purpose or something for mutability
05:38:55 <Philippa> no, it's not
05:39:00 <fasta> ivanm: I am certain that mutability in an amortized sense is not needed.
05:39:05 <Philippa> primitive recursion is different to general recursion
05:39:06 <fasta> ivanm: (in theory)
05:39:15 <EvilTerran> okay, you've lost me
05:39:17 <ivanm> and if there were times when you absolutely _had_ to do something in a mutable structure because it wouldn't work any other way
05:39:23 <ivanm> *nod*
05:39:30 <Philippa> you can build lists and foldr without needing a fixpoint at all
05:39:57 <EvilTerran> ah, i think i see
05:40:07 <Philippa> yeah. So you can have foldr in a total language
05:40:34 <EvilTerran> for one thing, it's easier to prove the termination of an application of a foldr-style church-encoded list
05:40:43 <EvilTerran> than it is to do the same once fix rears its ugly head
05:41:00 <EvilTerran> (assuming fix wasn't involved in defining the list in the first place)
05:42:37 <Philippa> right, if the list itself doesn't terminate that's different. But if you can build it as a primitive recursive function, you've essentially just proven it terminates
05:44:31 <EvilTerran> also, the normal church encoding works in the simply-typed \calc, doesn't it?
05:44:42 <EvilTerran> while one requiring fix clearly wouldn't
05:46:13 <quicksilver> yes
05:46:25 <quicksilver> the _inductive_ data type of lists doesn't contain those infinite ones
05:46:44 <quicksilver> in languages like haskell, we take quite a liberty in the sense that we work with what look inductive data types
05:46:54 <quicksilver> and then we allow them to actually be infinite after all :)
05:46:58 <quicksilver> which is cheating, semantically
05:47:16 <quicksilver> s/what look/what 'look like'/
05:47:18 <EvilTerran> well, it's through allowing recursive definitions
05:47:43 <EvilTerran> it's the price we pay for turing-completeness ;)
05:49:21 <quicksilver> we could do much better though
05:49:28 <quicksilver> we could contain general recursion
05:49:31 <quicksilver> and only use it when we really want to
05:49:46 <quicksilver> which, I suspect, would turn out to be not that often
05:49:51 <quicksilver> q.v. epigram
05:50:10 <doserj> charity ftw!
05:51:32 <quicksilver> haskell programmers recurse for charity?
05:52:17 <fasta> Is there any difference between Coq and Epigram of interest?
05:52:26 <swiert> fasta: yes!
05:52:53 <quicksilver> i think they have very little in common
05:53:06 <swiert> Coq is a proof assistant (which includes a simply-typed language); Epigram is a dependently typed programming language.
05:53:17 * SamB_XP wonders if you can restart the print spooler on XP...
05:53:34 <fasta> swiert: AFAIK, you can do program extraction in Coq and write efficient programs.
05:53:42 <ivanm> quicksilver: are they actually infinite? or do we allow them the _ability_ to be infinite?
05:53:46 <swiert> quicksilver: they focus is a bit different, but the underlying type theory is fairly similar.
05:53:59 <quicksilver> ivanm: which?
05:54:11 <ivanm> lists
05:54:15 <fasta> swiert: and AFAIK, the COC is about the most powerful you can get.
05:54:20 <ivanm> if they were indeed infinite, then we couldn't do anything with them... just saying [1..] would freeze  your computer
05:54:32 <quicksilver> data [] a = [] | a : [a]
05:54:41 <quicksilver> "looks like" an inductive data type
05:54:47 <quicksilver> as used commonly in the literature
05:54:50 <ivanm> we never actually "create" an infinite data structure
05:54:55 <swiert> fasta: sure. But there are a still programs you can't really write nicley in Coq's programming language.
05:54:58 <quicksilver> however, [1..] is not a member of that data type
05:55:07 <ivanm> it isn't?
05:55:14 <quicksilver> not of that *inductive* type, no
05:55:22 <ivanm> so what is it then?
05:55:24 <fasta> swiert: I guess the same holds for Epigram(e.g. those which require mutability).
05:55:27 <quicksilver> inductive types are defined formally as a union
05:55:40 <quicksilver> and that union (in this case) contains members of every finite length
05:55:46 <ivanm> *nod*
05:55:47 <quicksilver> but it does not include anything infinite
05:55:48 <doserj> it is a member of "codata [] a = [] | a: [a]"
05:55:53 <quicksilver> right
05:56:02 <swiert> fasta: Have you ever tried programming in Coq?
05:56:03 <fasta> swiert: but maybe you can write more easily in Epigram.
05:56:14 <quicksilver> so we pretend our data is data but actually it's a mix of data and codata
05:56:20 <swiert> It's not much fun, really.
05:56:21 <ivanm> doserj: so that is the list of all possible lists?
05:56:38 <quicksilver> ivanm: I think it's fair to say that [1..] is "really created"
05:56:45 <quicksilver> the fact that it's lazily generated doesn't matter
05:56:48 <quicksilver> it's "real"
05:56:56 <quicksilver> of course, some operations on it don't terminate
05:56:59 <doserj> ivanm: that's the type of all possible ending, possibly infinite lists
05:57:01 <ivanm> true, in that you can use it
05:57:06 <quicksilver> but I don't think that reduces its reality
05:57:15 <fasta> swiert: I have seen some programs that got extracted, proved some simple things, but didn't make an actual program.
05:57:29 <quicksilver> there is no law that says a computer must store a data element in its entirety at any one moment in time
05:57:30 <ivanm> doserj: so how does it differ from what quicksilver had above?
05:57:43 <ivanm> how does codata differ from data ?
05:57:47 <doserj> ivanm: the "co" in codata
05:57:51 <ivanm> heh
05:57:56 <ivanm> which means???
05:58:05 <doserj> data means inductive type
05:58:11 <ivanm> OK...
05:58:13 <doserj> codata means coinductive type
05:58:21 <doserj> only in haskell, data means both
05:58:25 <ivanm> and the difference between inductive and coinductive is?
05:58:33 <swiert> fasta: as soon as you start using any interesting data types (like vectors of a fixed length), it becomes a real uphill struggle to write any programs.
05:59:04 <doserj> ivanm: inductive uses the least fixpoint, coinductive uses the greates fixpoint.
05:59:12 <fasta> swiert: ok, but I am also interested in mutable types. Is there some idea of how to add that to Epigram or any programming language in that class?
05:59:32 <ivanm> doserj: take it as read that my CS background is severely lacking... what does that mean?
05:59:36 <swiert> fasta: "mutable types" as in doing IO?
05:59:42 <fasta> swiert: no, as in ST.
05:59:55 <mauke> > fix ((0:).succ)
05:59:56 <lambdabot>   add an instance declaration for (Enum [t])
06:00:03 <doserj> for our example, as was said, the "inductive list type" only includes finite lists
06:00:05 <mauke> > fix ((0:).map succ)
06:00:06 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:00:23 <doserj> whereas the "coinductive list type" also includes the infinite ones
06:00:44 <ivanm> yes, you said that... but what is the rationale behind the split?
06:01:10 <swiert> fasta: sure. There are a few ideas in the "Beauty in the Beast" paper.
06:01:50 <fasta> swiert: anything that would give non-amortized O(1) mutable operations?
06:02:01 <quicksilver> there is no O(1)! they have lied to you.
06:02:10 <doserj> ivanm: you can prove more things about your program, if you differentiate between them
06:02:22 <fasta> quicksilver: yes, I know.
06:02:32 <fasta> quicksilver: O(time to get something from memory)
06:02:39 <Syzygy-> How do I write a class assertion for a type signature that proscribes Eq for both a and b?
06:02:51 <Syzygy-> So something like f :: Eq a,b => a -> b -> (a,b)
06:02:57 <ivanm> doserj: so atm, its technically an arbitrary split? like how in maths "infinity" isn't a member of the reals, but is a useful concept in some cases?
06:03:00 <Toxaris> Syzygy-: (Eq a, Eq b) => ...
06:03:14 <swiert> fasta: isn't that what ST does?
06:03:31 <fasta> swiert: yes, that's why I could use Haskell.
06:03:34 <doserj> ivanm: it is not an arbitrary split. they are fundamentally different things
06:03:44 <fasta> swiert: but I would like to encode proofs more easily.
06:04:04 <ivanm> doserj: OK, didn't quite mean arbitrary...
06:04:10 <fasta> swiert: and those invariants need to reason about mutable types too.
06:04:19 <Toxaris> ivanm: it's like in math not arbitrary :)
06:04:25 <ivanm> heh
06:04:32 <doserj> ivanm: for example, the haskell list type does not fullfill the monad laws...
06:04:33 <ivanm> though how is a potentially infinite list different from a finite list?
06:04:35 <swiert> fasta: then you need to wait 5 years for a proper dependently typed language, I'm afraid.
06:04:44 <ivanm> doserj: it doesn't? then how come its a monad?
06:04:46 <swiert> or struggle your way through Coq.
06:04:59 <fasta> swiert: most people doing a Phd say that ;)
06:05:10 <Toxaris> ivanm: e.g. you can't count the elements of the potentially infinite list
06:05:15 <fasta> swiert: after 5 years they are done and gone with the wind :)
06:05:17 <doserj> ivanm: the subset of finite lists do fullfill them, but this is not expressible in haskell
06:05:37 <ivanm> Toxaris: yes... but that's a practical issue, not a theoretical one, is it not?
06:05:37 <dikini> ivanm: http://citeseer.ist.psu.edu/jacobs97tutorial.html
06:05:39 <lambdabot> Title: A Tutorial on (Co)Algebras and (Co)Induction - Jacobs, Rutten (ResearchIndex)
06:05:40 <ivanm> doserj: OK
06:06:30 <Toxaris> ivanm: you can't prove a property of it's elements by induction
06:06:41 <ivanm> k
06:06:55 <Toxaris> ivanm: wich is basically the same thing, but sounds more theoretical
06:07:02 <ivanm> lol
06:07:08 <swiert> fasta: I don't think that's entirely fair. There are a lot of problems facing the "main-stream" adoption of dependent types.
06:07:41 <fasta> swiert: it does happen with most research languages, though.
06:07:45 <swiert> fasta: Although there are a few different systems out there at the moment, we'll need more time before we can have anything remotely as "real-world" as Haskell is at the moment.
06:07:57 <ivanm> dikini: thanks
06:07:59 <wli> swiert: Interesting. Do tell.
06:09:11 <swiert> wli: what would you like to know?
06:09:38 <wli> Well, given the MPTC, module, and H98 permascrewed the Prelude issues, Haskell's got its own fish to fry.
06:09:57 <ivanm> doserj, Toxaris, dikini: OK, thanks for putting up with me about this :p
06:10:04 * ivanm feels his bed calling him
06:10:06 <ivanm> g'night all!
06:10:13 <wli> swiert: What the barriers are wrt. dependently-typed languages.
06:10:38 <dikini> ivanm: i'm having trouble putting all that togeter myself ;-)
06:10:47 <ivanm> heh
06:11:02 <swiert> wli: proper treatment of IO, right definition of equality, technological challenges (generics, IDE, refactoring all become terribly important), not to mention recursion, coinductive data types,...
06:11:09 <ivanm> dikini: get the feeling they're making all this up out of spite? :p
06:11:16 <dikini> yep
06:11:26 <ivanm> heh
06:11:40 <swiert> wli: and we need someone to write a wicked fast compiler.
06:12:50 <wli> swiert: If that's the level of problem things are stuck on, 5 years doesn't sound like enough.
06:12:58 <Toxaris> ivanm, dikini: not too sure, either. i think i've understand inductive data types, though, so i can go on to co-understand co-inductive data types, now
06:13:35 <Philippa> wli: depends what you want in 5 years
06:13:52 <Philippa> you won't get the equivalent of haskell now, the equivalent of haskell 98 may be another matter
06:14:24 <fasta> Is there any problem with just stealing monadic IO from Haskell?
06:14:32 <Philippa> fasta: how do you reason about it?
06:14:46 <Philippa> that is, you can do it, but it's not necessarily any more useful than having Haskell
06:14:51 * wli needs to see past the Prelude damage wrt. H98.
06:15:00 <fasta> You formalize every possible output device (e.g. console).
06:15:10 <Philippa> fasta: yeah. Have fun with that.
06:15:17 <dikini> well, so far my intuition tells me it is something like base case + constructor vs solution space + destructor (peeler? ;) -> they complement each other, by making a larger set of definitions possible
06:15:19 <Philippa> incidentally, output isn't enough
06:15:24 <fasta> (and input device)
06:15:35 <Philippa> you have to formalise the entire host platform
06:15:52 <fasta> Philippa: only whatever you interface with.
06:15:59 <swiert> fasta: Yes and no.
06:16:16 <wli> initial vs. final algebras
06:16:23 <Philippa> fasta: you get to abstract a little, yes
06:16:27 <swiert> A dependently type language needs to perform evaluation at runtime. You need to be a bit careful about things.
06:16:31 <Philippa> wli: no, initial algebras and final coalgebras
06:17:05 <swiert> Besides, you want may want to prove how your IO programs behave. Just calling a C function through the FFI doesn't say anything about its behaviour.
06:17:26 <fasta> swiert: who said anything about C?
06:17:36 <Philippa> fasta: anybody interacting with a real OS
06:17:55 <fasta> The first step would be a self-contained universe that works.
06:18:05 <Philippa> we call that "pure computation"
06:18:07 <swiert> fasta: Or any other foreign language. C is the canonical example. How else are you going to update memory/fork threads/throw exceptions etc.
06:18:10 <fasta> After that you can do hairy things.
06:18:32 <fasta> Philippa: is ST also "pure computation"?
06:18:44 <Philippa> in a significant sense, yes
06:19:08 <Philippa> I have a suspicion I can implement a slow ST in System Fc, for example
06:19:34 <fasta> Philippa: how slow?
06:19:56 <swiert> It depends on your definition of pure, really. I would only call things pure if they correspond to lambda terms.
06:19:59 <Philippa> slow enough you don't want to use it. But give me linear types or something similar as well...
06:20:49 <wli> swiert: One could always emit syscall traps directly and so bypass C.
06:20:51 <Philippa> I tend to go with "can be denoted by a mathematical function"
06:21:05 <Philippa> wli: solves nothing
06:21:14 <Philippa> the problem isn't the calling conventions
06:21:24 <swiert> wli: sure. but the point is as soon as you talk to another language, you don't know what that language is going to do.
06:21:28 <fasta> Philippa: every state change can be denoted by a mathematical function.
06:21:35 <mux> wli: I wouldn't do that; it would be bad as nowadays there are several different calling conventions, even on the same OS (int 0x80, SYSENTER, SYSCALL..)
06:21:58 <Philippa> fasta: only if you're working with a naive set theory :-)
06:22:06 <swiert> You can prove map f . map g = map (f . g) in Haskell by just expanding definitions; you can't really prove anything about IORefs, for instance.
06:22:09 <wli> mux: Oh, I know.
06:22:27 <fasta> Anyway, I wouldn't care for the slightest bit of backwards-compatibility in a _research_ project where you don't understand everything yet.
06:22:50 <fasta> Philippa: what naieve set theory?
06:23:11 <Philippa> fasta: we're not talking about compatability with haskell, we're talking about being able to run on actual real-world systems. Y'know, actually getting to see "Hello World" on your screen
06:23:57 <fasta> Philippa: yes, but telling "we have no IDEs" is no reason why a programming language cannot be used.
06:24:49 <Philippa> so go play with Coq already
06:24:57 <Philippa> the question wasn't "can this be used at all?"
06:26:27 <swiert> fasta: Well - one of problems with dependent types is that if you start writing a function using lists, decide you want to use vectors (lists indexed by length), you need to rewrite all your code.
06:26:45 <swiert> having some sort of refactoring support/generics becomes pretty important for any non-trivial program!
06:26:57 <Philippa> yeah, I've had that issue even in Haskell. Sometimes you can't help thinking one or two of the old lisp ideas were rather useful
06:27:47 <fasta> swiert: it seems a solution to that is trivial.
06:28:23 <pejo> fasta, refactoring isn't trivial.
06:28:42 <fasta> In Haskell I encountered that problem with lists and then decided to use foldable so I could switch easily later on.
06:29:38 <Philippa> congratulations, you just abstracted away from some proof-relevant type info
06:29:55 <Philippa> that's part of the problem
06:30:37 <fasta> If you write your program against a foldable, you say it should work for all foldables.
06:30:42 <Toxaris> shouldn't the proof-relevant type info be part of the Foldable-class, then?
06:30:57 <fasta> I don't see where you throw away information.
06:31:48 <Philippa> fasta: yeah. Unfortunately it turns out you need that info further down the pipe
06:32:07 <fasta> Philippa: what information?
06:32:48 <Philippa> stuff you'd think of as phantom types
06:35:54 <Philippa> the exact details don't really matter: what's important is that you're going to find you need to structure types differently and the kinds of abstraction that come with generic programming get important because sometimes "can be coerced to list" isn't good enough
06:49:28 <jatqceer> if I use `fun x = exp x + exp x', would ghc be smart enough to only evaluate `exp x' once?
06:50:19 <Philippa> jatqceer: try it and see. I'm guessing yes, with optimisation on. If you really need to do CSE yourself, try fun x = let ex = exp x in ex + ex
06:50:51 <doserj> or 2*exp x ...
06:51:14 <mauke> http://www.haskell.org/haskellwiki/Performance/GHC#Common_subexpressions
06:51:17 <lambdabot> Title: Performance/GHC - HaskellWiki, http://tinyurl.com/yduwfl
06:51:18 <Philippa> doserj: doesn't generalise, somehow I don't think the question's about the one function :-)
06:52:20 <Philippa> mauke: cheers, I really ought to poke around the wiki more!
06:53:38 <Saizan> has anyone used binary's Get monad to parse packets from the network?
06:54:36 <jatqceer> Philippa: what if the form become complicated, like `fun x = exp (pi - x) + sin (exp (pi - x))'
06:54:38 <wli> mux: Now try Engel expansions. ;)
06:56:24 <jatqceer> Philippa: the question is how do I try and what should I look at
06:58:28 <Philippa> jatqceer: read the wiki page mauke linked to
07:00:52 <cognominal_> I am reading the  6.8.1 release announcement and I am confused: what is the diff between the base, the core and the boot libraries?
07:01:40 <jatqceer> Philippa, mauke: thanks
07:01:44 <cognominal_> in Perl the core libraries are those bound with the main distro
07:03:23 <Saizan> it's the same, the core libraries are the ones bundled with ghc
07:04:07 <Saizan> mmh maybe i'm wrong, those should be the boot?
07:04:33 <Igloo> The ones in teh main source tarball are the boot libraries
07:05:19 <Igloo> core is something else; there's a wiki page somewhere describing what
07:05:25 <cognominal_> so the base are the ones in the extra bundle?
07:05:37 <Igloo> No, those are extralibs
07:05:44 <Igloo> base is a library (one of the bootlibs)
07:06:38 <cognominal_> is 6.8.1 know to compile with leopard?
07:06:44 <araujo> morning
07:09:15 <doserj> boot -> required to build ghc; core -> standard libraries normally shipped with the compiler; base -> one package in core; does that sum it up?
07:10:04 <cognominal_> ok
07:11:49 <Igloo> I don't think core is right. I think it's libraries that are /always/ shipped with the compiler, BICBW
07:12:40 <cognominal_> "These used to be called “core libraries”, but we now call them “boot libraries” (or, more precisely, “GHC boot libraries”) instead."
07:12:42 <pa-ching> currently I have a bunch of "instance Show <SomeType> where ..." blocks in a row, each with an unrelated type... is it possible for me to merge those into one big block?
07:13:19 <mauke> do you really need custom Show instances?
07:13:32 <pa-ching> Not sure
07:13:37 <pa-ching> tried deriving Show
07:13:48 <pa-ching> but then ended up implementing everything anyways
07:14:23 <pa-ching> couldn't figure out how to get the right "show" qualified properly in the case though hehe.
07:15:16 <Philippa> pa-ching: you can't merge them
07:15:28 <pa-ching> Philippa: OK, thanks
07:15:29 <Philippa> what you can do sometimes is write an instance for "all instances of another typeclass"
07:15:37 <pa-ching> hmm
07:15:38 <Philippa> or some other polymorphic type
07:34:43 <tt33> is there to handle a user hitting the return key with this simple bit of code: http://pastebin.com/d20eb3c81
07:34:57 <tt33> (is there a way to handle)
07:35:21 <hpaste>  alar pasted "tail rec?" at http://hpaste.org/3753
07:35:29 <mauke> sure, check whether tmp == ""
07:36:53 <Beelsebob> tt33: I'm not sure what you're trying to do
07:37:00 <Beelsebob> first off, putStr requires a String
07:37:09 <Beelsebob> so your read function is converting a String to a String
07:37:13 <Beelsebob> which seems rather pointless
07:37:30 <Beelsebob> main = do tmp <- getLine; putStr tmp -- does the same
07:37:40 <shachaf> alar: mapM?
07:37:55 <tt33> oh, I understand now.  I'm sorry, I was confused
07:37:58 <tt33> thanks for your help
07:37:59 <swiert> @seen lispy
07:37:59 <lambdabot> I saw lispy leaving ##logic, #ghc, #darcs, #xmonad, #haskell-blah, #haskell and #haskell-soc 10h 26m 23s ago, and .
07:38:14 <Toxaris> > read "test" :: String -- Beelsebob
07:38:17 <lambdabot>  Exception: Prelude.read: no parse
07:38:25 <Toxaris> > read "\"test\"" :: String -- but this works
07:38:27 <lambdabot>  "test"
07:38:37 <mux> this is really neat: http://covector.blogspot.com/2007/10/functional-augmented-reality.html
07:38:38 <Beelsebob> Toxaris: oh, okay, it strips off the quotes
07:38:40 <lambdabot> Title: vanishing points: functional augmented reality, http://tinyurl.com/2mb4gz
07:39:17 <Beelsebob> tt33: the point of read is to convert a String into any other data type you want
07:39:31 <Beelsebob> so for example read "[1,2,3]" :: [Int] results in [1,2,3]
07:39:47 <tt33> ok, thank you :)
07:39:59 <Beelsebob> essentially, it parses it... in a fairly naïve way
07:43:51 <quicksilver> > read ['a','b','c'] :: [Char]
07:43:52 <lambdabot>  Exception: Prelude.read: no parse
07:43:55 <quicksilver> hah!
07:44:02 <quicksilver> take that, parametric polymorphism
07:44:21 <quicksilver> I see your supposedly sane functorial constructors, and I raise you incoherent instances!
07:44:24 <vincenz> quicksilver: erm duh
07:44:27 <swiert> is there some way to lookup what a particular patch did to a darcs repos?
07:44:29 <shachaf> > read (['a','b','c'] :: [Char])
07:44:31 <lambdabot>  Exception: Prelude.read: no parse
07:44:33 <quicksilver> > read "['a','b','c']" :: [Char]
07:44:34 <lambdabot>  "abc"
07:44:36 <quicksilver> ;)
07:44:40 <quicksilver> typo ftw!
07:44:46 <quicksilver> that's interesting
07:44:46 <vincenz> quicksilver: yeah :)
07:44:50 <quicksilver> read accepts both formats
07:44:57 <quicksilver> curious
07:45:03 <ToRA> > read ['"','a','b','c','"'] :: [Char]
07:45:03 <quicksilver> I mean, I'm glad it does
07:45:04 <lambdabot>  "abc"
07:45:08 <quicksilver> but slightly surprised
07:45:13 <vincenz> quicksilver: hyper :)
07:45:35 <quicksilver> me? hyper? MYWARGH!
07:45:38 * quicksilver passes out in a puddle
07:46:02 <b_jonas> I realized why IArray is not in the haskell report
07:46:21 <b_jonas> it's not allowed by the report language
07:46:34 <b_jonas> 'class IArray a e where'
07:47:13 <quicksilver> yes
07:47:18 <quicksilver> it's an MPTC
07:47:44 <quicksilver> you could formulate it as a single-parameter one, though
07:47:56 <quicksilver> if you dropped the clever index stuff
07:49:31 <quicksilver> (isn't it IArray a i e ?)
07:49:33 <hpaste>  matthew-_ pasted "base 10 numbers on lists..." at http://hpaste.org/3754
07:49:36 <matthew_-> quicksilver: ok, the paste, I think requires closed type classes. Do you agree and if you think it can be done with GADTs, where do they go?
07:50:33 <quicksilver> matthew_-: hmm. take me a moment to digest that.
07:54:11 <pejo> swiert, if you're pulling you can (p)rint it.
07:54:29 <quicksilver> matthew_-: I'm a bit too busy at work to digest that. The main point is that instead of having a typeclass Foo a b c, you have a data type Foo a b c.
07:54:42 <swiert> pejo: but after I've pulled them in?
07:55:05 <swiert> Ah. I can unrecord and view them maybe...
07:55:14 <quicksilver> matthew_-: instead of having an instance on concrete types Foo A B C, you have a constructor FooABC :: Foo A B C
07:55:41 <pejo> swiert, well, you can atleast unpull -i (interactive) and print it then.
07:55:48 <b_jonas> oh on!
07:55:56 <swiert> pejo: good point.
07:56:01 <b_jonas> there's no unboxed array for Complex Double?
07:56:02 <b_jonas> why?
07:56:03 <pejo> swiert, sorry, don't really know the answer to your question - I just dabble with darcs.
07:56:11 <matthew_-> quicksilver: right, but the maths in types relies on recursion with instances, and I'm not sure how that can work out in GADTs
07:56:14 <quicksilver> matthew_-: instead of having an instance scheme Foo Int b c => Foo [Int] b c, you have a unary constructor FooIntList :: Foo Int b c -> Foo [Int] b c
07:56:14 <swiert> pejo: yeah me too.
07:56:30 <b_jonas> why do do few language developpers support complex numbers?
07:56:32 <b_jonas> why?
07:56:47 <swiert> pejo: thanks again for hosting the HW talks btw.
07:56:50 <swiert> pejo++
07:56:53 <quicksilver> b_jonas: you can use storablearray, that's unboxed.
07:57:05 <b_jonas> what's that?
07:57:14 <b_jonas> oh
07:57:14 <pejo> swiert, oh, glad to help!
07:57:16 <quicksilver> it's an uboxed array for any Storable type
07:57:24 <Olathe> b_jonas: Complex numbers are rarely needed.
07:57:26 <quicksilver> Complex Double is storable
07:57:35 <b_jonas> I'd like an immutable array, not an io one
07:57:42 <quicksilver> matthew_-: well non-nullary constructors give you recursion schemes
07:57:57 <quicksilver> b_jonas: you are quite free to treat storablearrays as immutable
07:58:11 <quicksilver> at least, I think you are
07:58:18 <quicksilver> hmm
07:58:18 <b_jonas> quicksilver: but can I read them without IO?
07:58:22 <quicksilver> odd
07:58:33 <b_jonas> I doubt I can, that wouldn't be pure
07:58:33 <quicksilver> there doesn't seem to be an IArray instance for them
07:58:37 <quicksilver> bah, I don't know what not
07:58:40 <quicksilver> why not
07:59:04 <b_jonas> becaues it's an io one
07:59:16 <b_jonas> an io action can change it
07:59:28 <quicksilver> it would be quite possible to write a version of 'withStorableArray' which gave an IArray interface to it
07:59:31 <quicksilver> I don't know why they didn't
08:00:24 <b_jonas> I guess I'll just use one or two (UArray i Double)s
08:01:35 <Cale> Well, you can use freeze and thaw to convert, no?
08:02:00 <quicksilver> ah!
08:02:02 <quicksilver> Cale++
08:02:11 <b_jonas> Cale: dunno, it might still be inconvenient that I can't create one without io
08:02:17 <b_jonas> I'm not sure if I'll need that
08:02:51 <matthew_-> quicksilver: but all of that means that I have to construct the proof/instances myself - I can't rely on the type checker doing the work for me
08:03:27 <b_jonas> and I'm not sure I want to figure out how it works anyway. these names like "Ptr" are frightening
08:04:18 <quicksilver> matthew_-: hmm. I haven't thought hard enough about it to be confident. :) Maybe you're right.
08:04:57 <matthew_-> well, I've just redone reverse and reverse' as GADTs, and now I can't do testReverse...
08:10:10 <geocalc> what is the best lib to change the light of all my gnome icons if any ?
08:13:19 <geocalc> dont answer all in the same time !
08:21:13 <Cale> geocalc: Gnome icons are in at least two formats.
08:21:36 <Cale> There's PNG and SVG icons.
08:21:52 <geocalc> yes
08:24:30 <geocalc> the question is can i do that with haskell ?
08:25:20 <Cale> I don't know if there's a library built for editing SVGs in Haskell. I have a binding to Imlib2, which would work for PNGs
08:25:39 <Cale> However, it's probably more sensible just to look for commandline tools for doing that.
08:26:09 <geocalc> mmh ok thanks Cale
08:26:10 <mux> you can render SVGs easily with cairo
08:26:28 <mux> or output SVGs from cairo surfaces
08:26:34 <Cale> hmm
08:26:44 <flux> cairo goes both ways, it produces vector graphics also?
08:27:10 <geocalc> interesting
08:27:33 <flux> because I thought it only generates bitmap graphics
08:27:56 <flux> perhaps I need to revisit the documentation, because it would be just perfect :)
08:30:37 <quicksilver> flux: cairo can produce vector output
08:30:42 <quicksilver> flux: SVG, PDF or PS
08:30:46 <quicksilver> (in recent versions)
08:37:44 <Saul_> @src sort
08:37:44 <lambdabot> sort = sortBy compare
08:37:57 <Saul_> @src sortBy
08:37:57 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:38:20 <Saul_> @src insertBy
08:38:20 <lambdabot> insertBy _   x [] = [x]
08:38:20 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
08:38:20 <lambdabot>                                  GT -> y : insertBy cmp x ys'
08:38:20 <lambdabot>                                  _  -> x : ys
08:41:50 <Cale> Saul_: don't worry, it's not actually implemented like that ;)
08:42:06 <Cale> (just in a semantically equivalent way)
08:42:27 <Cale> I believe it's actually a mergesort.
08:42:36 <NuBeowulf> cute lambdabot
08:43:02 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:43:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:43:14 <Saul_> Cale: I'm not really worried about the implementation, I need a nice formal specification of sort so I can derive a function for it (assignment for school)
08:43:48 <wli> > let cfrac = scanl ((+) . recip) 1 . map fromIntegral in take 10 $ cfrac $ repeat 1 :: [Rational]
08:43:49 <lambdabot>  [1%1,2%1,3%2,5%3,8%5,13%8,21%13,34%21,55%34,89%55]
08:45:05 <Cale> > let cfrac = scanl ((+) . recip) 1 . map fromIntegral in map denominator . cfrac $ repeat 1
08:45:07 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:46:49 <quicksilver> Saul_: that's insertBy definition is pretty good, specfication-wise
08:47:00 <quicksilver> Saul_: it's quite easy to prove by induction that it works
08:49:12 <doserj> sort xs = head . filter isSorted . permutations $ xs -- *cough*
08:49:30 <daniel_larsson> hehe
08:50:18 <quicksilver> doserj++
08:50:51 <Cale> But is it a stable sort?
08:50:53 <osfameron> @index permutations
08:50:53 <lambdabot> bzzt
08:51:08 <Saul_> quicksilver: it's useful sure, but how do I reverse engineer a specification from it?
08:51:11 <quicksilver> then you refine that by defining a new version of permutations which, by construction, can only produce sorted output
08:51:20 <wli> > let fib :: Int -> Integer ; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] ; fib' :: (Integer, Integer) -> Bool -> (Integer, Integer) ; fib' (f, g) p = let s = f*f + g*g in if p then (f * (f + 2 * g), s) else (s, g * (2 * f - g)) in length . show $ fib 99
08:51:20 <quicksilver> and which sort do you get?
08:51:21 <lambdabot>  21
08:51:48 <doserj> quicksilver: that depends on your refinement method, of course
08:52:12 * quicksilver nods
08:52:31 <wli> (try it on 999, or 9999, or 99999, or 999999, and see how long it takes)
08:52:37 <mauke> http://rafb.net/p/eL03Ho78.html
08:52:38 <lambdabot> Title: Nopaste - No description
08:52:51 <quicksilver> it's fairly easy to imagine how you get quicksort that way, for example
08:57:39 <doserj> http://citeseer.ist.psu.edu/579.html
08:57:41 <lambdabot> Title: Top-down Synthesis of Sorting Algorithms - Lau (ResearchIndex)
08:57:54 <quicksilver> heh
08:58:01 <quicksilver> shoul dhave guessed someone would have written a paper on it
08:58:18 <quicksilver> Saul_: just submit that paper for your class. Add your name to the top as a co-author ;)
08:59:23 <NuBeowulf> http://www.yahoo.com
08:59:24 <lambdabot> Title: Yahoo!
08:59:39 <Saul_> quicksilver: I'll check it out
08:59:46 <Saul_> quicksilver: thanks
09:01:36 <Saul_> quicksilver: (for the sake of simplicity, we assume that there are no repeated members in te list) :(
09:28:38 <byorgey> @yow !
09:28:38 <lambdabot> Once, there was NO fun ... This was before MENU planning, FASHION
09:28:39 <lambdabot> statements or NAUTILUS equipment ... Then, in 1985 ... FUN was
09:28:39 <lambdabot> completely encoded in this tiny MICROCHIP ... It contain 14,768 vaguely
09:28:39 <lambdabot> amusing SIT-COM pilots!!  We had to wait FOUR BILLION years but we
09:28:39 <lambdabot> finally got JERRY LEWIS, MTV and a large selection of creme-filled
09:28:40 <lambdabot> snack cakes!
09:34:50 <ski> Natural Deduction for Intuitionistic Non-Commutative Linear Logic !
09:36:20 <dons> wow, byorgey. i think that's the longest yow ever
09:36:22 <Olathe> We need Perfectly Cromulent logics.
09:36:30 <byorgey> w00t!
09:36:30 <dons> ?users
09:36:30 <lambdabot> Maximum users seen in #haskell: 424, currently: 383 (90.3%), active: 11 (2.9%)
09:36:33 <dons> ?yptime
09:36:33 <lambdabot> uptime: 3d 22h 34m, longest uptime: 1m 10d 23h 44m 29s
09:36:40 <byorgey> dons: it's all in the wrist
09:37:13 <Olathe> Heheh
09:55:52 <osfameron> is there a version of isPrefixOf that returns the list after the prefix?
09:56:20 <bos> no.
09:56:28 <osfameron> so, er (Eq a) => [a] -> [a] -> Maybe [a]
09:56:58 <osfameron> ah well, easy enough to write
09:56:59 <osfameron> ta
09:57:42 * ski murmurs something about append and prolog
09:59:12 <bos> osfameron: \a b->guard (a `isPrefixOf` b) >> drop (length a) b
09:59:55 <bos> more or less something like that.
10:04:43 <inverselimit> Howdy.  Can anyone recommend a Haskell book? I'm not sure which offering is the right level.  I am a phD mathematician (so category theory is my friend), reasonably experienced programmer, main language has been python.  Thanks!
10:06:46 <bos> inverselimit: there aren't any haskell books yet that assume you can already program, unfortunately.
10:07:13 <bos> this is out of print, but good: http://web.comlab.ox.ac.uk/oucl/publications/books/functional/
10:07:15 <lambdabot> Title: Introduction to Functional Programming
10:07:20 * ski liked `Haskell: The Craft of Functional Programming', by Simon Thompson
10:07:57 <bos> also http://www.cs.nott.ac.uk/~gmh/book.html
10:07:58 <lambdabot> Title: Programming in Haskell
10:09:03 <bos> inverselimit: of those, the bird book is probably the least basic
10:10:33 <ski> (inverselimit : was that the same as direct limit ?)
10:12:14 <inverselimit> Thanks
10:13:26 <Cale> inverselimit: The tutorials online are not so bad. If they're going too slow, you can reasonably try to skip over stuff. If you already have some experience with functional programming, the "Gentle Introduction" is not so bad. (But it's not that gentle if you don't.)
10:13:53 <Cale> The wikibook and YAHT are reasonable.
10:14:49 <Cale> Knowing category theory helps in understanding the ideas behind the abstractions we use, but I'm not sure how much it helps with the details of programming. ;)
10:15:26 <sieni> Cale: I would disagree
10:16:12 <Cale> Well, I knew (some) category theory before I started learning Haskell, so I don't know what it's like to try without it. :)
10:16:31 <sieni> Cale: I think the only point of category theory w.r.t. haskell is that somebody noted that for example a monad is actually a (quite obscure) category theoretical construction and then people started perhaps trying some other things
10:17:05 <Cale> Well, we steal most of our abstractions from category theory.
10:17:13 <Cale> For example, algebraic types.
10:17:26 <sieni> Cale: well, I know some category theory, having a ph.d. in mathematics, but still I prefer to think the monad abstraction in a more straightforward way
10:17:45 <inverselimit> FOr me I guess it was part of the appeal -- read the "Don't panic" monad thing, full of diagrams, and thought, here was a language that mathematicians should like.
10:17:53 <ddarius> sieni: Monads aren't the only uses of category theory in Haskell
10:18:25 <ddarius> inverselimit: Comparatively, it is, but it is still a far cry from mathematics.
10:18:32 <Cale> Well, yes, there's always more to do when you move from the general categorical description of something to the concrete case of a particular category.
10:18:35 <sieni> I think more interesting part of mathematics relevant to haskell is type theory
10:18:53 <Cale> For example, studying group theory from a purely categorical standpoint is kind of crazy.
10:19:03 <ddarius> I do agree, that by and far knowing category theory will help very little in learning Haskell.
10:19:19 <ddarius> Simply having a mathematical background, though, should make it simpler.
10:20:05 <sieni> I knew quite a bit of mathematical logic before and reading "types and programming languages" opened quite a treasure trove of things I hadn't encountered before or thought about
10:20:12 <ddarius> Cale: What?!  But, but it's tripleable and then you have monad algebras and ...
10:21:59 <Cale> It would be pretty bizarre to have a purely category-theoretic description of Haskell's category of types and Haskell functions.
10:22:04 <matthew_-> quicksilver: it seems, having spent several hours on this, that it can be done, but you end up explicitly passing around proof witnesses which rapidly gets very painful. existentials don't help either...
10:22:25 <ddarius> inverselimit: You may well like Haskell more than Python, but, if you are hoping for executable math ...
10:22:39 <ddarius> Cale: Why?
10:22:57 <Cale> ddarius: Well, perhaps strange to work with, anyway.
10:23:09 <Cale> I see that the netsplits are still going on.
10:23:16 <inverselimit> Not hoping for executable math-- just compileable :)
10:23:26 <Cale> :)
10:23:30 <ddarius> Cale: Probably a pain in the rear, as the category of Haskell types and functions isn't all that nice categorically.
10:23:46 <Cale> It does come closer to executable mathematics than most other practical languages.
10:23:48 <ddarius> Anyway, they probably expect me to return to work.
10:24:12 <Cale> Especially with the ability to work with infinite structures.
10:24:37 <Cale> However, I was slightly annoyed the first time product [1,1..] didn't finish in finite time. :)
10:25:10 <hpaste>  matthew-_ annotated "base 10 numbers on lists..." with "trying to use gadts to simulate closed type classes" at http://hpaste.org/3754#a1
10:25:18 <matthew_-> feel free, anyone, to finish off that paste...
10:28:01 * Cale considers turning off join/part messages.
10:28:26 <b_jonas> Cale: it's just that one of the servers died
10:28:31 <b_jonas> and every client is reconnecting
10:28:35 <b_jonas> slowly
10:28:35 <Cale> I know
10:29:08 <Cale> Freenode's been under a DOS attack, I'm not sure that's been stopped.
10:33:04 <b_jonas> I have a further question about error monads
10:33:29 <b_jonas> I now understand how ErrorT works
10:33:56 <Saizan> but?
10:34:01 <b_jonas> Firstly, is it a good style to have parts in my code which don't need io so are in an Either e monad;
10:34:26 <Philippa> it is, definitely
10:34:28 <Cale> sure
10:34:29 <b_jonas> and other parts which use an ErrorT-like wrapper
10:34:34 <Philippa> keeping out of the IO monad is generally a good idea
10:34:56 <Philippa> and that's still the case there, yeah. It's potentially a little tricky at the boundaries if the Error monad's not on the bottom of the stack, but still
10:35:17 <b_jonas> (newtype ErrorMonad a = IO (Either MyExceptionClass a)
10:35:28 <Philippa> it's "a little tricky" rather than not doable
10:36:53 <b_jonas> in that case, I need a function that returns an Either in the underlying IO monad of the ErrorT
10:37:06 <MyCatSchemes> Holy netsplit, packetman!
10:37:22 <b_jonas> that is, it either raises an exception in the error monad, or returns
10:37:33 <Cale> It's also possible to write code polymorphically
10:37:35 <Saizan> ?type let liftError e = either throwError return e in liftError
10:37:37 <lambdabot> forall a b (m :: * -> *). (MonadError a m) => Either a b -> m b
10:37:43 <ptolomy>  hehe. Anyone see Xavier Leroy's most recent message to the Ocaml mailing list?
10:37:51 <puusorsa> no
10:37:56 <puusorsa> have you?
10:37:56 <b_jonas> Saizan: yes, exactly
10:38:07 <b_jonas> Cale: that is?
10:38:25 <ptolomy> puusorsa:  There was a running contest for "shortest bit of ocaml code that causes a segfault (bug)"
10:38:49 <b_jonas> lol
10:38:53 <ptolomy> puusorsa: After a few of these, he responded with a message entitled "STOP" where he makes it very clear that he's angry at people for airing dirty laundry in public
10:38:53 <Cale> b_jonas: That is rather than Either e a, using (MonadError e m) => m a
10:38:54 <Saizan> b_jonas: you can write your actions as simply MonadError e m, without using a specific instance
10:39:37 <Cale> b_jonas: Then the code will nicely specialise to Either and to ErrorT'd monads.
10:39:38 <ptolomy> "You're just demonstrated out that this practice is very effective at pissing me off. Are you satisfied?"
10:40:07 <Philippa> to which I can't help but think the correct response is "no, you haven't actually exploded yet"
10:40:28 <b_jonas> Cale: hmm
10:40:43 <b_jonas> but then I'm not getting out of IO
10:40:54 <Philippa> you are type-wise, which is what matters
10:40:56 <b_jonas> though it could make sense for higher-order functions (like mapM)
10:41:08 <Philippa> the important bit is not requiring IO
10:41:19 <Philippa> ending up having a type variable instantiate to IO isn't the same thing
10:41:25 <b_jonas> which I might want to call either in IO or non-IO depending on the function I pass to it
10:41:26 <Cale> b_jonas: Something of type (MonadError e m) => m a, that is, which is truly polymorphic, cannot do IO.
10:41:54 <b_jonas> Cale: sure, but to really get it out to IO, I'll still need Saizan's function
10:42:01 <Cale> I suppose I should write that as  forall m. (MonadError e m) => m a
10:42:18 <Cale> why?
10:42:38 * ski laments `MonadError e (Either e)'
10:42:47 <Cale> Saizan's function turns an Either e a into one of these.
10:43:01 <Cale> ski: yeah, it's kind of sad.
10:43:10 <b_jonas> Cale: I guess the compiler can optimize my code better if I instantiate the function in non-io
10:43:14 <b_jonas> but I might just be wrong
10:43:15 <Cale> (the Error e constraint)
10:43:41 <Cale> b_jonas: hmm...
10:44:20 <Cale> b_jonas: What is the computation you're doing, and what IO do you have wrapped around it?
10:44:37 <b_jonas> Cale: I'm trying to write an interpreter
10:44:46 <b_jonas> I'd mostly use the state part of the IO
10:44:52 <b_jonas> that is, IORefs
10:45:10 <b_jonas> but I'm interpretting an impure language
10:45:21 <b_jonas> so any function in that language can do any side effect
10:46:17 <Cale> Okay.
10:46:46 <b_jonas> I'll probably be lazy and not finish the interpreter
10:46:52 <b_jonas> but still I want to try
10:46:52 <Cale> So I'd tend to think of such an interpreter as mapping from some (possibly annotated) abstract syntax trees for the language to IO actions.
10:47:18 <b_jonas> the part I'm writing now is the lexer
10:47:26 <olsner> @users
10:47:28 <b_jonas> which is pure, but can raise errors
10:47:36 <Cale> Right, keep that out of IO.
10:48:22 <Cale> It probably doesn't even matter how you handle that. If Either works for you, then go for it.
10:48:50 <Cale> You'll probably run the lexer in just one line at the top level of your program, and handle the error case from there.
10:48:53 <b_jonas> but there'll be other smaller pure parts too
10:49:02 <b_jonas> um, no
10:49:12 <Cale> no?
10:49:13 <b_jonas> I'm interpretting J so I don't have a choice of making it so elegant
10:49:24 <b_jonas> I'll have to call the lexer from inside in ugly ways
10:49:26 <Cale> hmm
10:49:29 <Cale> Why is that?
10:49:40 <Cale> (I'm not terribly familiar with J)
10:49:45 <b_jonas> J functions can call the lexer
10:49:56 <b_jonas> and they actually do it a lot
10:49:56 <Cale> hmm
10:50:10 <b_jonas> the lexer gets a line as input
10:50:16 <b_jonas> (J is line-oriented)
10:50:34 <b_jonas> and it outputs a list of words
10:51:11 <Cale> okay
10:51:24 <Cale> and theresome J verb
10:51:27 <Cale> whoops
10:51:36 <Cale> and there's some J verb for lexing a string?
10:52:52 <b_jonas> no (or not importantly)
10:52:58 <Cale> hmm
10:53:00 <b_jonas> there's one for evalling a string
10:53:06 <b_jonas> which lexes it and then interprets it
10:53:20 <b_jonas> the J interpreter is quite wierd
10:53:23 <Cale> okay
10:53:40 <b_jonas> but there's something that's done more frequently than that:
10:54:14 <b_jonas> you have to know that J is somewhat like logo or postscript or lisp in that the data and code are made of mostly the same things
10:54:31 <Cale> okay
10:54:39 <b_jonas> so when you lex a line, you get a list of words
10:54:50 <lambdabot> Maximum users seen in #haskell: 424, currently: 73 (17.2%), active: 5 (6.8%)
10:54:55 <lambdabot> Maximum users seen in #haskell: 424, currently: 393 (92.7%), active: 9 (2.3%)
10:54:59 <b_jonas> a word is either a j datum (the kind of which the program manipulates)
10:55:32 <b_jonas> or a (variable) name (which might be qualified with a namespace, but that's not important),
10:55:58 <b_jonas> or one of the four special words (parenthesis and assignment marks)
10:56:04 <b_jonas> or a control word
10:56:18 <olsner> hehe, 'tis fun to PM @users to lambdabot: Maximum users seen in olsner: 0, currently: 0 (NaN%), active: 0 (NaN%)
10:56:34 <b_jonas> now the top level of J works by lexing a line to a list of such tokens (comments are thrown away)
10:56:58 <Cale> olsner: right, because essentially when you PM someone, you're sending to a channel whose name is their name.
10:57:02 <b_jonas> and then repeatedly applying the ten-some rules that operate on the words list locallly
10:57:24 <Cale> all right
10:57:32 <olsner> hmm... but then couldn't it just as well be "Maximum users seen in lambdabot"?
10:57:41 <b_jonas> the most common rules are like this: left-paren datum right-paren => datum
10:58:32 <b_jonas> [datums are one of four parts of speech: nouns, verbs, adverbs, and conjunctions]
10:58:59 <b_jonas> so there is a rule like verb noun => application-of-verb-to-noun
10:59:15 <b_jonas> and noun verb noun => application of verb to two nounts
10:59:22 <b_jonas> that is, prefix and infix function calls
10:59:36 <Cale> right
10:59:58 <b_jonas> these both depend on the kind of words on the left though, because there are some contexts where these cannot be applied
11:00:02 <Cale> So isn't the line lexed all at once, and then you operate on the string of tokens?
11:00:07 <b_jonas> yes
11:00:22 <b_jonas> but the trick comes in expiicit function defnitions
11:01:00 <b_jonas> J has only dynamic scope, not lexical scope
11:01:29 <b_jonas> and because of this, explicit functions are made from strings or lists of strings
11:01:48 <b_jonas> there's an operator that turns a string or list of string to an explicitly defined verb
11:02:15 <b_jonas> when that verb is called, the content of those strings are lexed and executed
11:02:27 <b_jonas> obviously, they're lexed when you create the function
11:02:37 <b_jonas> and executed when you call the function
11:03:14 <b_jonas> the body of such a function is executed linewise
11:04:27 <b_jonas> there are of course stuff that complicates this a bit, but this is the main point
11:05:03 <Cale> Still, that is a pretty clear application of the lexer. I wouldn't worry too much about how well the monads mix.
11:05:48 <b_jonas> so you mean I could put the lexer in IO as well?
11:05:58 <lambdabot> Maximum users seen in #haskell: 424, currently: 65 (15.3%), active: 3 (4.6%)
11:06:19 <Cale> b_jonas: Nah, I'm saying do it in whatever makes the most sense.
11:06:49 <Cale> If it makes sense to write it in Either, then that's great. A parsing monad might be overkill, but then again may also be handy.
11:06:49 <b_jonas> I also want to make some of the inner array-manipulating functions non-io
11:07:08 <b_jonas> and some of those have to return errors
11:07:16 <b_jonas> hmm maybe not
11:07:21 <lament> is J the ascii APL?
11:07:22 <b_jonas> yes they have to
11:07:24 <b_jonas> type errors
11:07:32 <byorgey> lament: essentially, yes
11:07:34 <b_jonas> lament: yes. but with more higher-order functions
11:08:00 <Cale> Parsec is nice in that it gives nice-looking parsing errors for almost free.
11:15:53 <psnively> Hi guys. Does anyone know if Alex builds with Cabal 1.2.2?
11:16:06 <dcoutts_> psnively: yes, alex-2.2
11:16:10 <dcoutts_> get it from hackage
11:16:11 <psnively> Basically, I'm having the devil's own time bootstrapping 6.8.1.
11:16:17 <b_jonas> what's the point of the methods of Error?
11:16:24 <psnively> Ah, thanks, dcoutts_.
11:16:30 <quicksilver> b_jonas: you mean 'fromString' ?
11:16:39 <b_jonas> strMsg
11:16:42 <dcoutts_> psnively: ghc-6.8.1 does not require alex or happy to be installed as it includes pre-generated parser and lexer code.
11:16:46 <quicksilver> b_jonas: yeah, that's it
11:16:55 <quicksilver> b_jonas: to make it fit into the stupid stupid Monad class
11:17:01 <quicksilver> b_jonas: with it's 'fail' method
11:17:02 <quicksilver> :)
11:17:10 <b_jonas> oh, fail
11:17:13 <psnively> dcoutts_: I roll d20 to disbelieve. Not only does it require happy, it complains even when I have happy installed. :-)
11:17:35 <dcoutts_> psnively: you're not building the extralibs tarball too are you?
11:17:56 <dcoutts_> psnively: I know it doesn't need alex & happy as I've built it on a machine without either. :-)
11:18:13 <psnively> Good point... I actually am including the extralibs.
11:18:55 <Olathe> Could someone make a tool to automatically do what is necessary to bootstrap ghc ?
11:20:18 <psnively> So you're saying "Don't." :-)
11:20:24 <b_jonas> Olathe: ask debian
11:22:35 <dons> "2. Our Haskell code was roughly 33% faster (relative to ghc 6.6.1). It
11:22:35 <dons> seems that pointer-tagging made a big difference for our code base
11:22:35 <dons> (since, if I'm reading the release notes correctly, constructor
11:22:35 <dons> specialization isn't in yet).
11:22:36 <dons> "
11:22:42 <dons> 6.8 rocks
11:24:38 <mrd> is there going to be an effort to integrate ndp with 6.8?
11:26:46 <b_jonas> so what are good names for my exception type, the Either of that exception type, and the ErrorT .. IO of that exception type? my guesses are Ball, Hope, and IOHope
11:26:51 <dons> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/13059
11:26:53 <dons> awesome
11:28:06 <Nafai> That is awesome, getting a 33% speed-up just by upgrading compilers
11:28:11 <profmakx> can I somehow install packages with "broken" ghci? runhaskell Setup.lhs does not work obviously
11:28:33 <mrd> you can compile Setup.lhs
11:29:59 <pitecus> There isnt any way of serializing functions is there?
11:30:22 <dons> http://programming.reddit.com/info/605l0/comments/  :)
11:30:52 <profmakx> hm
11:33:48 <shapr> I want my internet back!
11:34:15 <Olathe> Sorry.
11:34:22 * Olathe hands shapr his Internet.
11:34:39 <dons> freenode is a bit sick
11:35:19 <profmakx> duh
11:35:23 <profmakx> -package Cabal helped
11:35:28 <profmakx> thanks mrd
11:35:55 <Cale> It's being DOS attacked, apparently.
11:36:15 <dons> that's disappointing
11:36:19 <RayNbow> does anyone know a good book to complement this one? http://ecx.images-amazon.com/images/I/518D7CKQHSL._SS500_.jpg
11:36:26 <Saizan> ?index UArray
11:36:26 <lambdabot> Data.Array.Unboxed
11:36:36 <RayNbow> or should I use web resources for more advanced topics?
11:36:46 <Cale> Web resources and papers.
11:37:06 <Cale> Most of the advanced material on Haskell is in the form of research papers.
11:37:07 <dcoutts_> RayNbow: yes, what Cale says. There are only really intro books at the moment.
11:37:10 <lament> somebody ought to write a book called "The Cruft Of Functional Programming"
11:37:18 <dcoutts_> heh
11:37:46 <RayNbow> ah thx
11:38:07 <Olathe> Kraft Functional Programming
11:38:11 <b_jonas> Cruft, not craft?
11:38:15 * RayNbow feels like there is so much to learn about functional programming...
11:38:52 <MyCatSchemes> Gah. How on Earth do I get darcs to roll back to a specific previous version, please? I've FUBAR'd something here and recorded it anyway and I need to throw it out the window, non-destructively if possible. x_x
11:39:43 <Saizan> DiffArrays are 30% slower with 6.8.1, but it doesn't matter to me since plain UArray is faster anyway :)
11:40:05 <Cale> MyCatSchemes: well, you can unrecord.
11:40:10 <dcoutts_> MyCatSchemes: make a backup using cp -r of the whole repo, then use darcs unrecord
11:40:36 <dcoutts_> MyCatSchemes: you can use darcs changes | less to look back through the changes, or with -v to see the content too
11:40:46 <lament> Olathe: :D
11:41:07 <dons> DiffArrays always run slower :)
11:41:45 <Saizan> dons: and get worse in every release?:)
11:41:59 <dcoutts_> Saizan: yeah, it's a hint not to use them :-)
11:42:03 <dons> no one maintains the impl.
11:42:13 <dons> or stress tests it...
11:42:16 <Octoploid> Darcs does not compile with ghc 6.8.1. I get :configure: error: Couldnt figure out how to call GHC.Handle.openFd! Any hints?
11:42:19 <dcoutts_> (or cares)
11:42:21 <dons> very few base modules get stress tested :(
11:42:37 <dcoutts_> Octoploid: get an updated darcs
11:42:51 <Octoploid> dcoutts_: Tried that same error...
11:43:11 <Cale> http://searchirc.com/network/freenode -- heh, you can see the damage here.
11:43:12 <lambdabot> Title: Search IRC, displaying network information for freenode
11:43:13 <psnively> darcs rollback
11:43:27 <psnively> MyCatSchemes: darcs rollback
11:43:28 <dcoutts_> Octoploid: will have to wait til they release a darcs update then.
11:43:35 <dcoutts_> Octoploid: or build it with an older ghc.
11:43:45 <Octoploid> dcoutts_: Thanks.
11:43:57 <dons> Cale: ?
11:44:08 <MyCatSchemes> psnively: yeah, that sounds like it *ought* to do what I'm after, but it doesn't.
11:44:23 <psnively> Er, how so, MyCatSchemes?
11:44:25 <Cale> dons: look at the last day or so on that graph where the number of users and chans drops off with little spikes
11:44:30 <dons> diff arrays in ocaml, dcoutts_ http://www.lri.fr/~filliatr/ftp/ocaml/ds/parray.ml.html
11:44:54 <dons> Cale: ah, text mode browser :) now i see.
11:45:22 <MyCatSchemes> psnively: it refuses to touch any patch older than a certain one (that'd been darcs pull'd from someone else's repo), instead outputting a shitload of "skipping depended-upon patch" messages. Which is silly, since I've already rolled back that particular patch.
11:46:00 <dcoutts_> dons: that impl doesn't look like it GC's old unreachable generations
11:46:16 <shachaf> irssi is claiming that someone pung me.
11:46:17 <dcoutts_> dons: the ghc impl uses weak pointers to do that I think
11:46:17 <psnively> MyCatSchemes: OK. Then I would darcs changes -v on that patch, write the inverse by hand, and record it.
11:46:36 <shachaf> Was that over here?
11:48:04 <dons> dcoutts_: its a lib we could revisit sometime
11:48:14 <dcoutts_> dons: I reviewed a paper the other day for a technique to do inplace updates in a Haskell-like language and then checking for safety with something like uniqueness types
11:48:17 <MyCatSchemes> psnively: "by hand" <-- no, that would defeat the point of using darcs in the first place. x_x
11:48:23 <MyCatSchemes> Unrecord worked, anyway.
11:48:26 <dons> dcoutts_: oh, static checking?
11:48:30 <dons> with an external tool?
11:48:37 <shachaf> Oh, never mind, it was the global notice.
11:48:40 <dcoutts_> dons: no, in a type system extension
11:48:41 * dons dreams of unsafePerformIO-lint
11:48:56 <psnively> MyCatSchemes: OK, then.
11:49:09 <dcoutts_> dons: so you can annotate re-uses of individual constructors, using @ patterns on the RHS of a function.
11:49:13 <dons> mmm
11:49:28 <dons> that sounds cool. optional uniqueness annotations?
11:49:31 <dcoutts_> dons: so you can say, create this new value, overwriting this old one
11:49:59 <dcoutts_> dons: then that induces some uniqueness types on the stuff and the system checks if they're satisfied
11:50:05 <MyCatSchemes> Heh. Uniqueness types *and* monads in one language? =D
11:50:20 <dcoutts_> dons: and you can always get back the persistent version by erasing the @ annotations
11:50:23 * psnively head explodes.
11:50:52 <dcoutts_> dons: so it's not like Clean's system when the uniqeness types infect the whole design
11:50:56 <dons> that's cool, dcoutts_.
11:51:01 <dons> yes, which is much more feasible
11:51:07 <dons> can you send me the link to the paper?
11:51:10 <dcoutts_> dons: you can always escape by using the non-unique version at the cost of some space
11:51:15 <dons> right
11:51:25 <dcoutts_> dons: it's not published yet
11:51:33 <dons> oh, under review ?
11:51:36 <dcoutts_> yes
11:51:46 * dcoutts_ checks if it's available on some home page...
11:53:01 <MyCatSchemes> dcoutts: so if you use the non-unique version too, you get a copy?
11:53:16 <dcoutts_> MyCatSchemes: right, the normal semantics
11:53:25 <MyCatSchemes> How handeh.
11:53:38 * Philippa would like to see the paper whenever it's available too
11:53:42 <dcoutts_> the normal system is old heap nodes are never modified and just GC'd
11:53:50 <MyCatSchemes> Pity we can't do that with the IO monad, but copying the universe is nontrivial. =D
11:54:02 <MyCatSchemes> Anyway. Foods! Before I go insane with hunger.
11:54:03 <dcoutts_> so this allows for example a unique reverse that uses constant heap space
11:54:10 <dons> dcoutts_: had you seen this benchmark, btw, http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
11:54:19 <dons> double arrays doing rather well (finally!)
11:54:28 * dcoutts_ checks
11:54:45 <dons> required Ptr Double in the end. but beats C.
11:54:53 * dons loves it when that happens
11:54:59 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
11:55:42 <dcoutts_> dons: it's a bit sad that we cannot use ordinary UArrays
11:56:09 <dons> right. there was a 10% slow down with STUArrays . but that was all pre-6.8
11:56:14 <dcoutts_> why is manually peeking & poking faster?
11:56:18 <dcoutts_> it really should not be
11:56:26 <dcoutts_> so long as we're doing unsafe indexing
11:56:26 <dons> the optimiser was getting confused.
11:56:34 <dons> we should redo the list benchmarks with 6.8 ..
11:56:42 <dons> i bet they're entirely obsolete now :)
11:56:51 <dcoutts_> heh
11:57:22 <dons> is 6.8.1 in gentoo yet?
11:57:26 <dcoutts_> yes
11:57:31 <dcoutts_> well, the overlay
11:57:40 <dons> oh, great! i'll tell igouy
11:57:44 <dons> and we can get it on the shootout
11:57:50 <dcoutts_> not in the main portage tree yet, too many packages do not build
11:57:59 <earthy> I also like how it's awfully close to th C++, even in memusage
11:58:06 <dcoutts_> dons: I expect he wants to use it from portage
11:58:12 <dons> "we don't even have a Gentoo ebuild for GHC 6.8.1 yet" ?
11:58:17 <dons> does that mean portage?
11:58:21 <dcoutts_> probably
11:58:40 <olsner> I think "ebuilds" are the thingies they put in the "portage"
11:58:42 <dcoutts_> dons: see, it's all very well us providing an ebuild for 6.8.1 but if all other packages then break...
11:58:48 <dcoutts_> unhappy users
11:58:59 <dons> this thread, http://programming.reddit.com/info/5zzmu/comments/c02ejjy
11:59:01 <lambdabot> Title: programming: Benchmarking ray tracing: Haskell vs. OCaml: the Haskell programs a ...
11:59:09 <dons> is igouy, from the shootout, asking about gentoo
12:00:05 <dcoutts_> dons: ah, well you're welcome to tell him that we've been working on it since well before the release, but we like to make sure everything works
12:00:34 <dons> ok.
12:00:42 <dcoutts_> on the current trajectory only 6.8.2 will make it into portage
12:01:05 <dcoutts_> since atm, loads of packages break with 6.8.1 and the docs don't get built properly.
12:01:15 <dcoutts_> no inter-package links
12:01:40 <quicksilver> they also don't mention inter-package instances. Which is unsurprising in a sense, but still an annoying regression from 6.6
12:02:09 <quicksilver> bah
12:02:12 <dcoutts_> quicksilver: we'll have to wait for haddock-2.0 for that I think
12:02:15 <dons> ok
12:02:16 * quicksilver nods
12:02:18 <quicksilver> heh
12:02:23 <quicksilver> only lost half our dcoutts_es
12:02:25 <quicksilver> that's good
12:02:46 <quicksilver> hurrah for unsafeDuplicateDCoutts#
12:03:06 <dcoutts_> heh heh
12:03:10 <dcoutts_> hia dcoutts
12:05:38 <dons> heh
12:06:30 <pitecus> I'm trying to write a Binary instance for an existential type, this line: get = get >>= return . Foo causes some errors about ambiguous type variables
12:06:56 <dons> scary
12:07:05 <quicksilver> pitecus: more likfely to be able to help if you show us what the error is ;)
12:07:13 <dons> serialising existentials is hard :) de-serialising is harder though
12:07:24 <quicksilver> that would more often be written as liftM get Foo
12:07:28 <dons> perhaps you can push the Binary methods into the existential interface?
12:07:29 <quicksilver> or get `liftM` Foo
12:07:37 <quicksilver> or get <$> Foo
12:07:44 <dons> yeah, the latter, but flipped
12:07:46 <quicksilver> erm
12:07:50 <quicksilver> the other way around
12:07:52 <quicksilver> all of them :)
12:07:57 <dons> is the nicest way of writing Binary instances, imo
12:08:07 <pitecus> I'm a bit lost
12:08:07 <quicksilver> liftM Foo get, Foo `liftM` get, Foo <$> get
12:08:29 <quicksilver> pitecus: well, Foo is a constructor for an existential
12:08:38 <quicksilver> pitecus: so it can take *any* type inside
12:08:41 <shachaf> quicksilver: You forgot fmap and liftA. :-)
12:08:41 <quicksilver> (perhaps bounded
12:08:52 <quicksilver> so it doesn't know which 'get' instance to use
12:08:56 <quicksilver> "inside" Foo
12:09:07 <quicksilver> short verions: serialising existentials is hard
12:09:10 <quicksilver> as dons said :)
12:09:18 <Cale> pitecus: what operations does the existential type support?
12:09:26 <quicksilver> you probably need to explicity write out some tag
12:09:34 <pitecus> Ord a, Eq a, Show a, Binary a
12:09:35 <quicksilver> to help you construct the right type on the way back in
12:10:03 <Cale> wait, if it already supports Binary...
12:10:17 <quicksilver> Cale: you still can't tell which type you have ;)
12:10:27 <pitecus> I mean the stuff inside supports Binary
12:10:28 <Cale> oh, right
12:10:28 <quicksilver> Cale: you need to tell "get" which Binary a type to "get"
12:10:36 <quicksilver> (or, you need to tell the type checker)
12:10:36 <Cale> You could just pick one though.
12:10:43 <quicksilver> and if it's wrong?
12:10:48 <quicksilver> if he wrote out a Bar
12:10:49 <Cale> Well, it shouldn't be.
12:10:55 <quicksilver> and tries to load as a Bazzle?
12:11:05 <quicksilver> well lets be more concrete
12:11:05 <Cale> Because you're not supposed to care what type it was ;)
12:11:22 <dons> dcoutts_: we might have to dig up that faster binary versoin you worked on
12:11:26 <Cale> Otherwise you wouldn't have used an existential.
12:11:35 <dons> and get the stream fusion bytestring branch together
12:11:37 <Cale> However, I admit this is kinda questionable :)
12:11:41 <dons> looks like i have a use case.. :)
12:11:49 <pitecus> So I have to find out the type and write a tag for each possible type?
12:12:02 <quicksilver> pitecus: I don't know another way
12:12:03 <Cale> pitecus: well, yes, or don't use existentials
12:12:13 <quicksilver> which amounts to limiting yourself to a finite list of types
12:12:14 <dcoutts_> dons: oh yes? what's the use case?
12:12:17 <Cale> It would be easier to use a tagged union.
12:12:20 <quicksilver> which amounts to using a finite ADT
12:12:24 <quicksilver> instead of an existential
12:12:28 <pitecus> I see
12:12:32 <dcoutts_> dons: or is it top secret? :-)
12:12:37 <quicksilver> but it does "localise" the finiteness in one module
12:12:43 <quicksilver> which might or might not be handy
12:12:57 <dons> yeah, i think so unfortunately. there's hardware, and kernels and similar involved
12:13:03 <dcoutts_> dons: I should send you the binary code I had. I'm supposed to be busy with writing up
12:13:23 <dons> yep. me too. but i could do with a copy of the code at least
12:13:35 <pitecus> I could use a record with functions inside but I cant serialize that either
12:13:44 <dons> dcoutts_: so, going to visit next summer for an internship? :)
12:14:37 <dcoutts_> dons: I've had no response since replying to Isaac about my work intentions
12:15:00 <shapr> Does anyone know how to post to google groups from a non-subscribed address? Is there some way to allow shae@scannedinavian.com to post even though I'm subscribed as shae.erisson@gmail.com ?
12:15:06 <pitecus> I could use a record with functions inside but I cant serialize that either
12:15:47 <RayNbow> man... it's been a while since I've experienced frequent splits on an IRC server :p
12:15:52 <Cale> pitecus: right, that's essentially what the existential type is
12:16:07 <Cale> pitecus: It's just an automatically-constructed set of functions.
12:16:30 <dons> dcoutts_: oh!
12:16:38 <dons> dcoutts_: let me personally kick isaac for you then.
12:16:45 <pitecus> Having to use a sum type here is a bit unwieldy, Cale
12:16:57 <Cale> How many cases do you have?
12:17:38 <Cale> It's hard to design a binary format for an arbitrary selection and number of types without knowing what those are going to be.
12:17:39 <dcoutts_> dons: are my /privmsgs not getting through to you? has freenode turned them off I wonder
12:17:41 <RayNbow> last time I can remember was when I was still frequenting UnderNET
12:17:46 <dons> hmm
12:19:01 <pitecus> Cale, I dont know in advance how many cases there will be, thats the thing
12:19:19 <pitecus> Would using read work?
12:19:21 <Cale> But if you only have  Ord a, Eq a, Show a, Binary a...
12:19:36 <Cale> Well, I suppose that's not *quite* the same as just having Strings.
12:19:51 <Cale> In that the ordering might be different.
12:20:12 <pitecus> no there is a function that is supposed to work with this type
12:21:03 <Cale> actually, having Ord in an existential is not all that useful usually.
12:21:40 <Cale> Because you need more than one value to be able to compare, and if you only store one value of that type in your existential, then you can't actually ever apply the Ord methods.
12:22:02 <Cale> (Or Eq)
12:22:10 <Cale> But I don't know what the rest of your type looks like.
12:22:38 <shapr> pitecus: HAppS serializes functions by autocreating matching types for them.
12:22:39 <shapr> That ends up looking a bit weird though, types are created for state transformer functions, then another layer of functions is created that transparently deals with the two underlying layers.
12:23:19 <Cale> Well, you can apply them, but x < x usually has a pretty obvious result ;)
12:24:40 <pitecus> You cant compare two existentials even if the type inside is the same?
12:25:38 <earthy> do you have proof that the type is the same?
12:25:41 <stepcut> pitecus: how would the compiler know the type inside them is the same?
12:25:41 <Cale> Because you can't know that the types are equal.
12:25:50 <earthy> proof that the compiler understands?
12:25:51 <Cale> Types are a compile time thing.
12:26:04 <Cale> They're thrown away by compilation.
12:26:27 <Cale> So there's no way to know at runtime that those two things had the same type and that it's okay to compare them.
12:26:57 <earthy> actually, that is stated a bit strongly
12:27:05 <Cale> Perhaps a bit ;)
12:27:14 <earthy> there are ways, but they're ugly and require Data.Typeable.
12:27:19 <Cale> The point of existential types though is to discard type information.
12:28:15 <Cale> Data.Typeable is just a way of reifying that type information into values, so that you have some indication of what the types were.
12:28:38 * earthy nods
12:28:44 <pitecus> I can write the compare method in terms of show or something
12:29:08 <quicksilver> earthy: no, even with Data.Typeable, I think
12:29:22 <Cale> When you discard type information, you're discarding your permissions to apply various functions.
12:29:49 <Cale> Well, you still can't apply Ord even with Typeable.
12:29:49 <quicksilver> earthy: if you have Data.Typeable then you, at runtime, may be able to establish that two values which were trapped in an existential are in fact of the same type
12:29:58 * earthy nods
12:30:08 <quicksilver> earthy: but there is no way of feeding that knowledge back the compiler at compile time
12:30:15 <quicksilver> to let it permit you to use == on them
12:30:17 * earthy nods again
12:30:18 <pitecus> Cale, I just implement the compare instance method the way it works for me, I dont get what the probelm is here
12:30:37 <quicksilver> pitecus: forget everything you know about haskell.
12:30:37 <Cale> pitecus: sure, but you'll have nothing to apply it to.
12:30:40 <quicksilver> forget about typeclasses
12:30:44 <quicksilver> forget about binary
12:30:49 <quicksilver> just asnwer this question:
12:30:54 <quicksilver> you're reading binary data from a file
12:30:56 <quicksilver> it's just bits
12:31:01 <quicksilver> you don't know what it's supposed to represent
12:31:04 <quicksilver> how will you find out?
12:31:06 <pitecus> *Main> (Foo 1) `compare` (Foo "0")
12:31:06 <pitecus> GT
12:31:12 <quicksilver> how do you choose what to construct out of the bits
12:31:20 <earthy> unfortunately, what you just said makes Data.Dynamic impossible. :P
12:31:25 <earthy> so there is a way.
12:31:30 <Olathe> It obviously represents an integer.
12:31:33 <quicksilver> earthy: no, Data.Dynamic is fine.
12:31:40 <pitecus> with this instance:
12:31:41 <quicksilver> earthy: because enough information sticks around
12:31:41 <pitecus> instance Ord  Foo   where (Foo x) `compare` (Foo y) = show x `compare` show y
12:31:47 <quicksilver> earthy: it's trapped in the Typeable instance
12:31:55 <quicksilver> earthy: but you can't save your whole typeable dictionary to disk
12:31:56 <Olathe> > 5
12:32:00 <quicksilver> earthy: we can't write out functions :)
12:32:06 <Olathe> lambdabot :(
12:32:11 <psnively> Hey guys... anyone have any idea why I get this on Leopard:
12:32:12 <psnively> snark:~ psnively$ ghci
12:32:13 <psnively> GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
12:32:13 <psnively> ghc-6.8.1:
12:32:13 <psnively> Loading package base ... linking ... ghc-6.8.1: unable to load package `base'
12:32:15 <pitecus> So what is it that I can't apply??
12:32:21 * earthy nods
12:32:38 <psnively> Er, also /usr/local/lib/ghc-6.8.1/lib/base-3.0.0.0/HSbase-3.0.0.0.o: unknown symbol `_environ'
12:32:42 <Cale> Data.Dynamic *is* impossible
12:32:49 <earthy> but still, am I misunderstanding cast?
12:32:51 <quicksilver> earthy: another way of saying what we're saying, is that you can't write a serializer/deserializer for Data.Dynamic.
12:32:51 <Cale> It cheats :)
12:33:09 <quicksilver> until you can write haskell code to disk
12:33:11 <Cale> Data.Dynamic uses unsafeCoerce.
12:33:14 <earthy> cast :: (Typeable a, Typeable b) => a -> Maybe b
12:33:16 <quicksilver> as in, unexecuted thunks
12:33:39 <quicksilver> Cale: and it knows its safe to do so because of the typeable dictionary it's carrying around
12:33:40 <pitecus> I can see that deserialization is hard, but I dont understand the problem with having an Ord instance
12:33:57 <quicksilver> pitecus: having an ord instance is fine
12:34:07 <quicksilver> pitecus: what cale was talking about was using the 'underlying' ord instance
12:34:15 <quicksilver> of the thiings inside the existential
12:34:32 <pitecus> Ah
12:34:35 <pitecus> I get it now
12:34:36 <dcoutts_> earthy: btw, did you get the new gtk2hs installer to work?
12:34:41 <Cale> data E = forall a. (Ord a) => E a
12:34:42 <Cale> say
12:34:48 <earthy> dcoutts: haven't tried yet. that's for tomorrow
12:34:58 <Cale> There's no way to write a meaningful Ord instance for that.
12:35:06 <Olathe> @botsnack
12:35:08 <dcoutts_> earthy: right'o, let me know if you run into any problems
12:35:20 <earthy> (the windows machine is at the office, and I haven't been there today, due to business at the OUNL headoffice (which is two 1/2 hours' travel away)
12:35:22 <earthy> )
12:35:40 <earthy> that is 2h30
12:35:44 * earthy is tired....
12:37:32 <psnively> Any thoughts on the unknown symbol '_environ' in HSbase in my 6.8.1 install on Leopard?
12:38:31 <gwern> has anyone tried the haskell FlyMake emacs code that popped up on cafe?
12:38:36 <dcoutts_> psnively: there's a bunch of emails about that on the ghc users list
12:38:38 <gwern> (doesn't seem to work for me)
12:38:52 <psnively> Thanks, dcoutts_.
12:39:19 <jonafan> stop doing that, heinlein
12:40:51 <quicksilver> gah
12:40:57 <quicksilver> stupid skiddies
12:54:26 <quicksilver> dons: why do you think nominolo saw a 10x improvement recompiling dpiponi's code with 6.8.x over 6.6.x ?
12:57:30 <dcoutts_> quicksilver: something that dramatic might be a fixed simplifier bug or spec constr
12:58:43 <dons> quicksilver: oh, he did?
12:58:58 <dons> a 10x slow down vs. C in that code sounds like a bug,  to me.
12:59:05 <dons> so maybe the optimiser was just not doing the right job
12:59:08 <dons> and that's fixed in 6.8
12:59:37 <quicksilver> dons: yeah. third post by thomas schilling, 19:24 in my time zone
12:59:47 <quicksilver> I can link you to the archive if your email client doesnt have it :)
13:00:01 <quicksilver> dcoutts_: dont' think it can be spec constr in this case
13:00:09 <quicksilver> dcoutts_: simplifier bug sounds plausible
13:00:36 <dons> yep.
13:00:41 <dons> 7s to 0.7s
13:01:03 <quicksilver> good news anyhow
13:01:23 <dons> yep
13:01:24 <quicksilver> the 'naive' code jumps from 15-20x slower to 1.5-2x slower
13:01:29 <quicksilver> that's a much better starting place
13:01:30 <dons> a 10x slow down is /always/ a bug
13:01:36 <dons> esp. in low level code like this.
13:01:44 <dons> there's nothing on the shootout that bad.
13:01:45 <quicksilver> and that's without c flags and so on
13:01:52 <dons> i'd expect about 2-4x for a first effort
13:01:56 <quicksilver> I bet excess-precision wins a chunk
13:01:59 <nominolo> i guess it's the register allocator
13:02:00 <dons> yep. its huge
13:02:07 <quicksilver> in my expereience of double loops, it wins 20-3%
13:02:14 <nominolo> or code generator in general
13:02:14 <quicksilver> if you're doing double primops like + or *
13:02:22 <dons> nominolo: for your speedup?
13:02:26 <quicksilver> nominolo: 6.8 doesn't have the new register allocator!
13:02:27 <dons> i think its more likely the optimiser
13:02:31 <nominolo> oh
13:02:36 <nominolo> well then ...
13:02:36 <quicksilver> that's not even definite for 6.10...
13:02:39 <quicksilver> it's not finished yet
13:02:40 <dcoutts_> it does, just not on by default
13:02:43 <quicksilver> oh?
13:02:52 * quicksilver blushes for his foolish words
13:02:57 <quicksilver> I thought it was still work in progress?
13:02:59 <dcoutts_> I can't remember the name of the flag
13:03:06 <dcoutts_> quicksilver: it is, sort of
13:03:23 <gwern> has anyone gotten emacs flymake working for haskell?
13:03:36 <dcoutts_> quicksilver: replacing the instruction scheduler is something you don't do without a lot of testing, and it was a bit close to the release
13:03:46 <dcoutts_> erm register allocator
13:04:17 <quicksilver> I'm now terribly keen to see how 6.8.x affects my CPU bound perlin noise generator
13:04:37 <quicksilver> but not quite keen enough to embark on compiling it :)
13:05:14 <dcoutts_> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/NCG/RegisterAllocator
13:05:17 <lambdabot> Title: Commentary/Compiler/Backends/NCG/RegisterAllocator - GHC - Trac, http://tinyurl.com/32mc2g
13:05:31 <dcoutts_> try -fregs-graph
13:05:56 <dcoutts_> nominolo, dons: that'd be interesting ^^
13:06:26 <nominolo> k
13:06:36 <dcoutts_> though apparently it doesn't make a huge difference yet since the C-- bits cannot generate code that uses enough registers for the new allocator to be really effective
13:06:38 <quicksilver> dcoutts_: thanks
13:07:06 <dcoutts_> that needs the improved C-- CPS transform
13:07:23 <quicksilver> dcoutts_: currently though fast FPU code has to go via C, because C-- -> asm doesn't generator FPU register code, does it?
13:07:36 <dcoutts_> dunno
13:07:44 <quicksilver> dons?
13:08:02 <nominolo> dcoutts_: no change
13:08:07 <dons> right
13:08:15 <dcoutts_> certainly -fasm can generate FPU code, but I don't expect it's very good
13:08:33 <dons> i think its ok on amd64, but we don't get sse code
13:09:01 <nominolo> dcoutts_: well, slightly faster on average
13:09:09 * quicksilver runs his only amd64 in 32bit userland
13:09:15 <quicksilver> so can't play with that :)
13:09:37 <quicksilver> some funky way to generate SSE2 and similar instructions
13:09:42 <quicksilver> or altivec
13:09:52 <quicksilver> even if you have to use special purpose types to kick it off
13:09:55 <quicksilver> would be fun to have
13:10:02 <nominolo> dcoutts_: interestingly, though.  -fvia-C is slower
13:10:21 <quicksilver> nominolo: try -fexcess-precision
13:10:36 <quicksilver> nominolo: that's normally my biggest single speedup when I try to play this game
13:11:44 <dons> yep. and in (is it) 6.6 it has to be in a pragma
13:11:49 <nominolo> quicksilver: right, but it doesn't do *that* much FP
13:11:50 <dons> but in 6.6.1 i think it works on the command line.
13:12:52 <Excedrin> what's the new style of OPTIONS_GHC
13:13:56 <nominolo> !paste
13:13:56 <hpaste> Haskell paste bin: http://hpaste.org/
13:20:31 <nominolo> hm, how do i find the main loop in the haskell program?
13:22:00 <allbery_b> Excedrin: {-# LANGUAGE ... #-} (I think that's what you're asking)
13:23:06 <Lycurgus> is it anticipated that when the other feature (descriptor tagging iirc) there will be a similar performance boost and would that be in 6.9 or what?
13:23:20 <Excedrin> I vaguely recall some change from {-# OPTIONS_GHC -fbang-patterns #-} to something, is it {-# LANGUAGE -fbang-patterns #-} now?
13:24:01 <Lycurgus> s/when ... there/when ... goes in there/
13:25:04 <allbery_b> it'll be something like BangPatterns but not sure what specifically it wants there
13:25:17 <allbery_b> (the idea is to not hardcode ghc-specific options)
13:26:15 <omnId> Excedrin: {-# LANGUAGE BangPatterns #-}, see Language.Haskell.Extension
13:26:16 <quicksilver> Lycurgus: pointer tagging is in 6.8 if that's what you mean
13:26:20 <Excedrin> thanks
13:26:27 <quicksilver> Lycurgus: 6.8 brings pointer tagging and specconstr
13:26:39 <quicksilver> Lycurgus: which appear to be around 10% speedup on GHC itself
13:26:46 <quicksilver> which may or may not be typical of other code :)
13:27:00 <hpaste>  nominolo pasted "ghc-bench inner loop comparision" at http://hpaste.org/3757
13:27:17 <Lycurgus> quicksilver: got it, thx.
13:28:02 <dcoutts_> nominolo: there's also -fregs-iterative
13:28:39 <dcoutts_> nominolo: however most of that annoying code is shuffling stuff between the stack and registers
13:28:42 <quicksilver> Lycurgus: what's slated for 6.10 is an improvement of the native code gen
13:28:49 <quicksilver> Lycurgus: which is at a lower level than all this stuff
13:28:54 <dcoutts_> which is the fault of the STG -> C-- bit
13:29:07 <quicksilver> Lycurgus: pointer tagging/spec constr are optimisations at the level of core/stg
13:29:57 <nominolo> dcoutts_: yeah, it looks way too complicated
13:30:15 <quicksilver> hard to follow that assembly very well without knowing the where those realtive offsets point to
13:30:20 <quicksilver> (s1n7_info + X)
13:30:39 <dcoutts_> nominolo: it's because even tail recursive functions do not turn into real loops, they always push args onto the stack, call to self and pop again
13:30:43 <nominolo> quicksilver: the symbol before that is the real address
13:30:54 <nominolo> quicksilver: the number, i mean
13:30:56 <quicksilver> nominolo: *doh* obvioys now :)
13:31:19 <nominolo> nominolo: i fell into that same trap
13:31:46 <nominolo> dcoutts_: is it hard to detect "real" loops ?
13:31:51 <Lycurgus> so dramtic performance improvements should be expected in 6.10 vs. 6.6?
13:31:59 <Lycurgus> a
13:32:04 <Lycurgus> generally
13:32:08 <dcoutts_> nominolo: that's what the C-- CPS transform is supposed to do
13:32:33 <nominolo> dcoutts_: ah, i see.  i'd *love" to work on this one
13:32:55 <dcoutts_> nominolo: talk to JaffaCake & get an internship as MS
13:33:06 <dcoutts_> nominolo: they'd like people to work on this stuff
13:33:41 <nominolo> dcoutts_: yeah.  but you can't apply there at a spare minute .. :)
13:34:04 <dcoutts_> nominolo: no, you need 3 months spare, any time from February
13:34:18 <nominolo> dcoutts_: never wrote a "personal research statement"
13:34:38 <dcoutts_> nominolo: if it's a project they're proposing it's rather easier
13:34:41 <nominolo> dcoutts_: i' plan for may-july
13:34:46 <dcoutts_> cool
13:35:07 <quicksilver> interesting
13:35:11 * dcoutts_ disappears
13:35:15 <quicksilver> the C code there is working 'directly' on the array
13:35:25 <Cale> Lycurgus: vs. 6.8 you mean?
13:37:10 <quicksilver> ah, so's the haskell version
13:37:13 <quicksilver> that's not the problem
13:37:17 <Lycurgus> no, I meant 6.6, haven't upgraded to 6.8 yet.
13:37:39 <quicksilver> the haskell version is using eax as a direct pointer, the C code is using it as a relative pointer
13:37:44 <quicksilver> still, that shouldn't matter much
13:37:50 <nominolo> quicksilver: i wonder if SSE would be even faster.  though, it's really pointless for this kind of benchmark. it's probably mem-bounded anyways
13:38:07 <quicksilver> nominolo: well the interesting point about this benchmark
13:38:18 <quicksilver> nominolo: is it shows how much garbage ghc puts around your tight loop
13:38:30 <quicksilver> nominolo: the 'faddl,fstpl' bit is fie :)
13:38:39 <quicksilver> nominolo: everything else goings a bit wrong
13:38:48 <nominolo> quicksilver: heh, yep
13:39:11 <quicksilver> it's also a bit weird that the haskell code has 5 exit points
13:39:14 <Cale> Lycurgus: People are seeing ~15% speedups with 6.8 over 6.6 already. Bluespec just reported that their codebase runs 33% faster in 6.8
13:39:18 <quicksilver> are some of those bounds checking or something?
13:39:26 <quicksilver> Cale: bluespec?
13:39:35 <Cale> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/13059
13:39:39 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/yum9yq
13:40:09 <nominolo> quicksilver: i really don't know.  i think it's a very direct translation of the STG code, which uses a lot of "case .. of"
13:40:13 <quicksilver> Cale: oh, very interesting
13:40:27 <nominolo> quicksilver: and those just get translated to some assembly branches
13:40:55 <Lycurgus> Cale: great. I have to be conservative about upgrades as I deal with a lot of packages.
13:41:50 <nominolo> Cale: nice
13:44:05 <quicksilver> nominolo: I dunno. Most of the 'cases' you see in STG code only have one branch.
13:44:17 <quicksilver> nominolo: they either generate no code at all, or just an indirect load.
13:44:36 <Lycurgus> did tunes.org become the log server due to ircbrowse going out of operation?
13:44:43 <quicksilver> mind you, I don't know about the internals of array
13:45:10 <L29Ah> reprocessing library haskell-src-1.0.1.1...
13:45:10 <L29Ah> Setup: The program happy is required but it could not be found
13:45:22 <L29Ah> $ which happy
13:45:22 <L29Ah> /usr/bin/happy
13:45:27 <L29Ah> wtf?
13:45:31 <quicksilver> nominolo: I'm intrigued by the number of 'add' statements in the haskell-generated code.
13:46:00 <Cale> Lycurgus: "become"? tunes.org has been logging #haskell since 2004.
13:46:07 <quicksilver> nominolo: I think it isn't CSE'ing the two (i+1)s
13:46:19 <Cale> L29Ah: hmm
13:46:29 <Cale> L29Ah: someone else had that problem too
13:47:48 <nominolo> L29Ah: can you try runhaskell Setup.lhs configure -v3 and paste the output?
13:47:50 <Lycurgus> Cale: yeah but there was a sort of line of descent from meme for the freenode CS channels and some browsing tools to ircbrowse.
13:48:23 <L29Ah> nominolo: where ;)
13:48:27 <L29Ah> ?
13:48:47 <lament> it's funny how the Tunes project actually does useful stuff
13:48:47 <nominolo> L29Ah: what system are you on?  what did you do to get this error msg?
13:48:52 <lament> logging channels :)
13:48:59 <SamB> Lycurgus: didn't meme used to use tunes.org logs?
13:49:23 <L29Ah> Gentoo Linux, $ make (ghc 6.8.1)
13:50:00 <SamB> hmm, where'd cmeme go? clog is still here...
13:50:11 <Lycurgus> SamB: doesn't look like it. Tunes seems to be just a file server.
13:50:29 <nominolo> L29Ah: oh. ok
13:50:32 <SamB> Lycurgus: ... which had logs
13:50:37 <SamB> which maybe meme used to use?
13:50:40 <SamB> before cmeme?
13:50:45 <nominolo> L29Ah: then maybe you can ask on #gentoo-haskell ?
13:50:49 <SamB> or maybe not, I don't know...
13:50:51 <Cale> L29Ah: I'd recommend not building ghc yourself, if it can be avoided.
13:51:04 <Cale> L29Ah: Just get the generic linux binary and install that.
13:51:46 <L29Ah> Cale: why not? I'd like to compile all the stuff I'm going to have in my system myself
13:51:49 <nominolo> Cale is very conscious about our environment :)
13:52:01 <Cale> L29Ah: because it's a waste of time
13:52:04 <Cale> (and heat)
13:52:22 <shapr> mmm, code
13:52:30 <SamB> L29Ah: you would need to use the binaries anyway
13:52:32 <Cale> Unless you're going to be hacking on GHC sometime soon, or are on a platform where a binary doesn't exist.
13:52:33 <SamB> to compile GHC
13:52:40 <Cale> Right.
13:52:43 <SamB> you might as well just use them for using...
13:52:57 <L29Ah> SamB: I have GHC 6.6.1 installed. What else? ;)
13:53:18 <SamB> okay, that would probably work :-)
13:53:20 <SamB> but still
13:53:28 <SamB> why compile it?
13:53:34 <Cale> It's generally fiddly and unnecessary.
13:54:00 * Lycurgus evaluates searchirc.com, looks adequate.
13:54:36 <quicksilver> nominolo: I would love to have enough time to grok enough pieces of the compilation pipeline to really follow those thoughts through ;)
13:54:43 <quicksilver> nominolo: but, alas, not tonight :)
13:54:46 <Cale> It's a much better idea to leave compilation up to the people who wrote the software in general anyway, since they're much more likely to know how it ought to be built.
13:54:59 <SamB> hmm, why does searching for my name bring me to amazon.com?
13:55:08 <nominolo> quicksilver: yeah, me too
13:55:31 <calvins> is there any way to manipulate a data constructor argument before the value is created, but hide that manipulation for clients that use the constructor. I don't think so, but perhaps there's some extension I haven't heard of.
13:55:33 <SamB> why does amazon think I have pearly whites?
13:55:47 <nominolo> SamB: you are a famous author!
13:55:49 <calvins> hide *from*
13:56:03 <Cale> calvins: The module system>
13:56:04 <Cale> ?
13:56:19 <mauke> calvins: use a helper function
13:56:20 <calvins> Cale: but then I can't expose the constructor
13:56:24 <mauke> right
13:56:28 <calvins> I want clients to be able to pattern match
13:56:36 <Cale> right, you can't do that
13:56:41 <SamB> nominolo: no
13:56:42 <calvins> but I want to manipulate the constructor arg before the value is created
13:56:46 <SamB> that's certainly not it
13:56:47 <mauke> you want case Foo x of Foo y -> x /= y?
13:56:53 <SamB> it brings up some kind of profile page
13:56:58 <mauke> sounds evil
13:57:43 <Cale> There used to be a feature like that in early versions of Haskell and Miranda, but for some reason it was removed.
13:57:53 <SamB> oh good, it isn't displaying my email address for all to see
13:58:01 <calvins> hmm, seems like a pretty common need:
13:58:08 <SamB> I had to log out fully to see this, however
13:58:14 <Cale> You could specify arbitrary rewrite rules which would be applied when constructing values.
13:58:27 <calvins> I want to let clients have all the pattern matching goodness, but I need to pre-process the value
13:58:33 <calvins> that sounds like exactly what I need
13:58:35 <SamB> Cale: hmm?
13:58:42 <SamB> that sounds pretty crazy for Haskell
13:58:50 <Cale> So for example, you could have an ordered list type which kept itself sorted, and pattern matching on a cons would always give you the minimum element.
13:59:08 <SamB> maybe O'Cult is a better language for that, eh?
13:59:15 <Cale> why?
13:59:30 <SamB> O'Cult is based on that
13:59:36 <SamB> rewrite rules, I mean...
13:59:49 <Cale> Um, it is?
13:59:51 <quicksilver> calvins: it is sometimes suggested under the name 'readonly constructors' or suchlike
13:59:59 <calvins> Cale: and there's no ghc extension that provides that sort of capability that you're aware of?
14:00:05 <quicksilver> calvins: as a stop gap, you can make the type opaque, but provide a view
14:00:12 <quicksilver> calvins: and you can pattern match on the view
14:00:12 <SamB> Cale: please tell me you don't just read the first three letters and ignore the rest?
14:00:40 <calvins> quicksilver: sounds promising, i haven't used views yet, but will look into it
14:00:49 <quicksilver> calvins: it's not a real language feature
14:00:54 <Cale> SamB: Does this language have a website?
14:00:54 <quicksilver> calvins: just the name of a technique
14:01:10 <quicksilver> calvins: e.g. sequences have two views, ViewL and ViewR
14:01:19 <quicksilver> calvins: which make them 'look like' lists from the left or right ends
14:01:26 <omnId> though there is a new 'view patterns' feature, which is tangentially related.
14:01:27 <quicksilver> calvins: and you can pattern match on them
14:01:33 <SamB> Cale: boundvariable.org
14:01:34 <quicksilver> omnId: is that actually implemented?
14:01:46 <omnId> quicksilver: I heard it here!
14:01:58 <Cale> SamB: Oh, one of those languages.
14:02:06 <SamB> Cale: yes, one of those
14:02:17 <calvins> great, I will look at sequence and see if that technique will work for me
14:02:24 <omnId> @go ghc trac view patterns
14:02:26 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
14:02:26 <lambdabot> Title: ViewPatterns - GHC - Trac
14:02:56 <SamB> some hope that O'Cult' will lose the "least needed, most heeded" rule
14:03:17 <quicksilver> omnId: that says 'planned to implement'
14:03:31 <quicksilver> omnId: not 'imlemented in 6.8...'
14:03:44 <omnId> quicksilver: I heard someone in channel mention a patch summary.
14:03:50 * quicksilver nds
14:04:01 <calvins> ah, that page explains it well. the syntax is a little clunky for the moment (without the view pattern extension), but that definitely will work for me
14:04:18 * quicksilver nods
14:04:19 <calvins> thanks so much
14:04:25 <calvins> ++quicksilver
14:04:30 <quicksilver> calvins: views are often called "toList" :)
14:04:31 <omnId> calvins: even without the new syntax, you could do: f x = case view x of ...
14:04:37 <calvins> ++Cale
14:04:37 <quicksilver> because that's often what they are
14:04:48 <omnId> @karma Cale
14:04:48 <lambdabot> Cale has a karma of 50
14:04:50 <omnId> ++Cale
14:04:51 <omnId> @karma Cale
14:04:51 <quicksilver> arguables 'elems' is a view of Data.Set
14:04:51 <lambdabot> Cale has a karma of 50
14:04:56 <omnId> postfix :)
14:05:03 <quicksilver> and 'assocs' is a view of Data.Map
14:05:04 <calvins> yeah, that's what I saw in that page. it just requires the extra case, which is a bit clunky, but it works
14:05:29 <Cale> @karma dons
14:05:29 <lambdabot> dons has a karma of 139
14:05:35 <quicksilver> I suppose any function which is obviously one half of an isomorphism...
14:06:14 <calvins> In my case, I take a bytestring argument to a constructor, but I want to preprocess it into a canonical format
14:06:15 <quicksilver> @karma dcoutts
14:06:15 <lambdabot> dcoutts has a karma of 44
14:06:39 <shapr> And well deserved it is!
14:07:03 <calvins> ++omnId
14:07:21 <quicksilver> @karma shapr
14:07:21 <lambdabot> shapr has a karma of 40
14:07:26 <quicksilver> so close
14:07:40 <omnId> calvins: postfix :)  quicksilver++ Cale++
14:07:41 <shapr> dcoutts writes more code :-)
14:07:54 <dcoutts> heh
14:08:07 <Cale> omnId++
14:08:25 <quicksilver> :)
14:08:49 <calvins> oops,
14:08:51 <calvins> Cale++
14:08:57 <calvins> quicksilver++
14:09:12 <quicksilver> @karma nmessenger
14:09:12 <lambdabot> nmessenger has a karma of 2
14:09:18 <quicksilver> ^^ omnId's lost karma
14:09:26 <quicksilver> @karma omniscientIdiot
14:09:26 <lambdabot> omniscientIdiot has a karma of 0
14:09:27 <omnId> :D
14:09:29 <quicksilver> ah, none there
14:09:31 <omnId> you've found me out!
14:09:40 <quicksilver> you admitted it in an email
14:09:54 <quicksilver> I find it very hard to remember important things like my wallet
14:10:05 <quicksilver> but very easy to remember email address -> irc nick associations
14:10:07 <quicksilver> go figure :)
14:10:14 <shapr> I have a solution for that. I keep all of my important stuff in my pants, and when I switch to another pair of pants I just move everything over.
14:10:53 <Botje> shapr: so you have a stop and copy dressing routine?
14:11:03 <shapr> Something like that, yeah.
14:11:25 <shapr> Though more often it's just stop... and then start thinking about something I've been studying.
14:11:32 <quicksilver> it's more efficient to have a generational algorithm
14:11:39 <shapr> And then my siblings come in and say "PUT ON SOME PANTS boy!"
14:11:44 <quicksilver> whenever you change your pants, you move everything to your jacket
14:11:48 <quicksilver> (which you change less often)
14:12:05 <omnId> shapr: yow!
14:12:13 <lament> Or just never switch pants.
14:12:14 <shapr> @yow !
14:12:14 <lambdabot> Didn't I buy a 1951 Packard from you last March in Cairo?
14:12:27 <shapr> My SIBLINGS told me to put on some PANTS!
14:12:38 <omnId> @@ @run wordsWise sortNoCase' @show @yow
14:12:39 <lambdabot>   Not in scope: `sortNoCase''
14:12:44 <omnId> :(
14:12:52 <omnId> @let wordsWise f = unwords . f . words
14:12:56 <lambdabot> Defined.
14:13:46 <omnId> @let sortNoCase = sortBy (\x y -> compare (map toLower x) (map toLower y))
14:13:49 <lambdabot> Defined.
14:13:51 <omnId> @@ @run wordsWise sortNoCase' @show @yow
14:13:52 <lambdabot>   Not in scope: `sortNoCase''
14:13:55 <omnId> @@ @run wordsWise sortNoCase @show @yow
14:13:56 <lambdabot>  "... CHILDREN. don't FRANK his I like or SINATRA"
14:14:01 * omnId finally succeeds
14:14:20 <quicksilver> what does the @@ do?
14:14:26 <omnId> @help @
14:14:27 <lambdabot>  @ [args].
14:14:27 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
14:14:27 <lambdabot>  The commands are right associative.
14:14:27 <lambdabot>  For example:    @ @pl @undo code
14:14:27 <lambdabot>  is the same as: @ (@pl (@undo code))
14:14:51 <omnId>  @., only AWESOME
14:14:54 * quicksilver nods
14:15:25 <omnId> @let on f g x y = g x `f` g y -- just to get it out of the way :)
14:15:29 <lambdabot> Defined.
14:16:36 <omnId> @@ @babel es en @babel fr es @babel en es It is delicious cake.  You must eat it.
14:16:38 <lambdabot>   It is delicious cake. You must eat it.
14:16:46 <omnId> !
14:17:23 <quicksilver> I think babel have put in some hacks to make roundtrips more reliable than they really area
14:17:32 <quicksilver> I've seen a few round trips do better than they should
14:17:43 <quicksilver> (or, than they used to)
14:17:50 <olsner> but where did it translate fr -> es? I think something's wonky here
14:18:02 <omnId> oops
14:18:08 <omnId> @@ @babel es en @babel fr es @babel en fr It is delicious cake.  You must eat it.
14:18:10 <lambdabot>   It is delicious cake. They must eat it.
14:18:24 <omnId> A little better.
14:18:36 <olsner> @@ @babel nl en @babel fr nl @babel fr es @babel en fr It is delicious cake.  You must eat it.
14:18:39 <lambdabot>   ASH tarta deliciosa. Deben comerlo.
14:18:43 <shapr> Um, yeah!
14:18:55 <olsner> @@ @babel nl en @babel es nl @babel fr es @babel en fr It is delicious cake.  You must eat it.
14:18:56 <lambdabot> Plugin `compose' failed with: Prelude.head: empty list
14:19:55 <omnId> @@ @babel es en @babel fr es @babel en fr The spirit is willing, but the flesh is weak.
14:19:55 <scvr> ?hoogle Monad m => m [a] -> [m a]
14:19:57 <lambdabot>   The spirit is arranged, but the meat is little.
14:19:57 <lambdabot> Prelude.repeat :: a -> [a]
14:20:12 <olsner> @help babel
14:20:12 <lambdabot> babel <lang1> <lang2> <phrase>.
14:20:12 <lambdabot> Translate a phrase in lang1 to lang2.
14:20:12 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
14:20:52 <omnId> scvr: hrm, you looking for a backwards sequence?
14:21:44 <omnId> @type sequence
14:21:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:22:05 <olsner> > (sequence ^ -1) Just "silly"
14:22:05 <lambdabot>      precedence parsing error
14:22:05 <lambdabot>         cannot mix `(^)' [infixr 8] and prefix ...
14:22:33 <scvr> olsner: yep -- I sort of coded myself into a corner and I'm still not handy with monad combinators
14:22:51 <lament> is m [a] -> [m a] even possible?
14:22:53 <omnId> liftM (map return) gets you close.
14:23:04 <scvr> ?ty liftM (map return)
14:23:05 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 [a] -> m1 [m a]
14:23:12 <dibblego> lament, looks like sequence to me
14:23:19 <twanvl> perhaps sequence from Data.Traversable?
14:23:23 <dibblego> oh, nothing
14:23:38 <lament> i don't think it's possible in the general case
14:23:51 <olsner> does djinn do monads? :P
14:24:15 <Botje> @djinn [[a]] -> [[a]]
14:24:16 <lambdabot> f a = a
14:24:20 <Botje> it does the list monad :]
14:24:28 <Cale> It's possible, but not in the way you might want it to be.
14:24:35 <olsner> @djinn Maybe [a] -> [Maybe a]
14:24:35 <lambdabot> -- f cannot be realized.
14:25:15 <olsner> I guess the closest thing you could get in general is m [m a]
14:25:15 <Cale> :t \x -> [liftM (!!n) x | n <- [0..]]
14:25:17 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> [m a]
14:25:43 <twanvl> > Data.Traversable.sequence $ Just [1,2,3]
14:25:44 <lambdabot>  [Just 1,Just 2,Just 3]
14:25:47 <mauke> :t (: []) . liftM head
14:25:49 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> [m a]
14:29:06 <Cale> @djinn Maybe a -> a -> a
14:29:06 <lambdabot> f a b =
14:29:07 <lambdabot>     case a of
14:29:07 <lambdabot>     Nothing -> b
14:29:07 <lambdabot>     Just c -> c
14:29:20 <Cale> @djinn Maybe (Maybe a) -> Maybe a -> a -> a
14:29:20 <lambdabot> f a b c =
14:29:20 <lambdabot>     case a of
14:29:20 <lambdabot>     Nothing -> c
14:29:20 <lambdabot>     Just d -> case d of
14:29:20 <lambdabot>               Nothing -> c
14:29:22 <lambdabot>               Just e -> case b of
14:29:24 <lambdabot>                         Nothing -> e
14:29:26 <lambdabot>                         Just f -> f
14:29:45 <hpaste>  sclv pasted "Trying to get the types to match up" at http://hpaste.org/3758
14:31:15 <scvr> any ideas, guys?
14:31:30 <Cale> I'm not clear on what you're intending to do.
14:31:46 <omnId> scvr: could you put the (takeMVar =<<) . doChunk in the liftM?
14:31:47 <thoughtpolice> is there any way to daemonize haskell processes? or would it require a basic ffi wrap around the daemon() call?
14:31:51 <twanvl> ?type map liftM
14:31:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => [a1 -> r] -> [m a1 -> m r]
14:32:06 <scvr> omnID -- doChunk needs to be in IO to create an mvar
14:32:11 <puusorsa> how do i get Everything installed so that in emacs i can press C-c something and it jumps to the definition
14:32:33 <fasta> puusorsa: that doesn't exist perfectly.
14:32:48 <puusorsa> it really needs to start existing sometime soon
14:33:01 <puusorsa> would make everything so much easier
14:33:16 <puusorsa> and even idiots like me could write working code :)
14:33:26 <scvr> Cale: I'm trying to read the file serially, and fork a new thread every 512 lines each of which will then be processed further and fold the maps up into a big map -- a varient solution to the widefinder thing
14:35:30 <Cale> return being applied to liftM and (foldr1 $ M.unionWith (+)) is a little questionable there
14:36:04 <Cale> :t return liftM
14:36:05 <lambdabot> forall a1 r (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 ((a1 -> r) -> m a1 -> m r)
14:36:23 <scvr> Cale: there's a whole bunch questionable -- but I haven't even gotten as far as fixing up the types in that part of the problem yet.
14:36:33 <Cale> Use do-notation.
14:36:33 <olsner> :t return liftM (foldr1 (+))
14:36:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:36:46 <Cale> and name some intermediate results
14:36:47 <scvr> yeah, starting with the do notation now. probably the simplest way.
14:36:56 <scvr> walk before running, etc. etc.
14:37:43 <olsner> hmm... so return liftM turned into return for the (a ->) monad, i.e. const liftM?
14:37:47 * omnId was doing the same.
14:37:58 <Cale> Yeah, actually, if Control.Monad.Reader/Control.Monad.Instances is imported, I suppose return = const
14:38:17 <omnId> maybe he meant (return $ liftM ...)
14:38:27 <Cale> So yeah, return liftM (foldr1 $ M.unionWith (+)) = liftM
14:38:27 <quicksilver> Control.Monad.Reader is a great obfuscator
14:38:41 <quicksilver> or a great example of how careless overloading can be an obfuscator
14:38:48 <scvr> yow
14:39:10 <olsner> didn't there use to be an obfuscated haskell code contest?
14:39:15 <SamB> only if you use the (e ->) instance...
14:39:15 <Cale> It's not necessarily obfuscatory. It just turns some otherwise invalid code into valid but possibly confusing code.
14:39:25 <SamB> olsner: yeah
14:39:26 <quicksilver> Cale: yeah, that's what I mean
14:39:40 <quicksilver> Cale: careless overloading turns invalid code into surprising but valid code
14:39:57 <Cale> I still think it deserves to be in the Prelude.
14:40:08 <quicksilver> rather like equirecursive types make everything typecheck?
14:40:12 <quicksilver> or something like that
14:40:16 <SamB> that sounds like a bad thing to put in Prelude
14:40:18 <quicksilver> maybe equirecursive isn't strong enough
14:40:26 <SamB> that sounds like exactly the kind of thing NOT to put in Prelude
14:40:32 <olsner> [perl] turns [all ascii strings] into surprising but valid code
14:40:41 <SamB> olsner: not all
14:40:45 <SamB> only a large number
14:40:54 <thetallguy> Anyone know of something similar to HaXml.DtdToHaskell, but for XML Schema?
14:41:21 <Cale> SamB: what/
14:41:22 <Cale> ?
14:41:32 <Cale> The ((->) e) instances for Monad and Functor?
14:41:38 <SamB> Cale: yes
14:41:43 <Cale> Why shouldn't it be?
14:41:46 <SamB> since they can be so confusing if you use them by accident
14:42:01 <olsner> actually, it would be fun to have a comparison of languages based on the percentage of all possible inputs they accept as valid programs
14:42:02 <quicksilver> Cale: because it makes 'return' typecheck in so many more positions
14:42:02 <thetallguy> I found this blog, which looks like it is going in the correct direction: http://blogs.msdn.com/ralflammel/archive/2006/07/28/681041.aspx
14:42:03 <lambdabot> Title: Grammarware, Haskellware, XMLware : XML Schema for Haskell programmers
14:42:10 <quicksilver> Cale: and putting return in the wrong place is a common newbie mistake
14:42:20 <Cale> Not more than it's worth though.
14:42:22 <SamB> Perl does accept some infinite inputs as valid programs
14:42:25 <thetallguy> but not conversion tool similar to DtdToHaskell
14:42:30 <SamB> in finite time, no less
14:42:39 <Cale> Those instances are extremely useful.
14:42:53 <quicksilver> Cale: very. I don't think it's much to ask to import something to use them, though
14:42:55 <SamB> Cale: yes. which is why they should be kept in a nearby closet
14:42:58 <quicksilver> Cale: and I think it saves confusion
14:43:03 <Cale> Maybe in Control.Monad
14:43:06 <TSC> puusorsa: You can do a good job with emacs + tags
14:43:18 <Cale> Having to import a whole separate module is annoying though.
14:43:26 <TSC> puusorsa: etags doesn't support haskell, but you can get by with even a very stupid regex, e.g.
14:43:27 <olsner> let import Control.Monad.Instances in return liftM (...)
14:43:30 <quicksilver> TSC: you can do a pretty good job with regexp isearch :P
14:43:41 <TSC> etags --language=none --regex='/^\([^ ]+\) ::/\1/' *.hs
14:43:43 <quicksilver> TSC: since definitions generally start in column 0
14:43:47 <puusorsa> doesnt lambdabot do something like that
14:43:50 <quicksilver> TSC: but did you know about hasktags?
14:43:52 <Cale> There's Hasktags
14:43:54 <puusorsa> @source liftM
14:43:54 <lambdabot> liftM not available
14:44:07 <puusorsa> apparently not anymore at least
14:44:13 <twanvl> ?src liftM
14:44:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:44:15 <SamB> TSC: yeah, really, did you think only etags could generate etags files?
14:44:24 <puusorsa> right
14:44:27 <TSC> Ah, I think I'd heard of it but forgotten
14:45:06 <Cale> I think I would personally be happiest with the Monad and Functor instances of ((->) e) moved to the prelude and fmap renamed to (.)
14:45:26 <Cale> (as well as map)
14:45:40 <SamB> you are trying to scare away all the newbies, aren't you?
14:46:00 <Cale> We can teach them about functors and monads.
14:46:15 <omnId> aha!  Cale wants to enforce the "avoid success" mantra!
14:46:17 <quicksilver> with the right hand he giveth, and with the left he taketh away!
14:46:44 <Cale> It'll be confusing for a couple hours at most.
14:46:54 <SamB> Cale: it's easier if we don't have to start in on that right off...
14:47:06 <Skyp> Hm, what do you consider the most elegant way to get all but the last element of a list? I a stuck with (\x -> (fst.splitAt ((length x)-1)) x) at the moment, but probably there's sth. better...
14:47:08 <SamB> @src (.)
14:47:08 <lambdabot> (.) f g x = f (g x)
14:47:12 <olsner> fmap as (.)? so fmap (reverse.lines) getContents would be reverse . lines . getContents?
14:47:18 <Botje> Skyp: init
14:47:35 <omnId> > (\xs -> zipWith const xs (drop 1 xs)) [1..8]
14:47:43 <lambdabot>  [1,2,3,4,5,6,7]
14:47:52 <opqdonut> > init [1..8]
14:47:53 <lambdabot>  [1,2,3,4,5,6,7]
14:47:56 <lament> SamB: newbies would want to learn IO asap anyway?
14:47:57 <Skyp> oh... init ;)
14:48:00 <Skyp> thx ;)
14:48:03 <Skyp> *blush*
14:48:03 <omnId> :)
14:48:16 <lament> SamB: which is... a monad? And yet everybody seems to manage just fine?
14:48:38 <omnId> > (\n xs -> zipWith const xs (drop n xs)) 3 [1..8]
14:48:39 <lambdabot>  [1,2,3,4,5]
14:49:14 <omnId> @let backdrop n = zipWith const `ap` drop n
14:49:17 <quicksilver> lament: if you think newbies manage 'just fine' with the IO monad, you're not in the same reality I'm in :)
14:49:17 <lambdabot> Defined.
14:49:34 <dons> dcoutts: see my last mail on Dan Piponi's thread. unsafePerformIO kills spectralnorm.hs. i wonder if we should look at exactly why
14:49:52 <dcoutts> hmm
14:50:14 <ddarius> quicksilver: My experience is most of their trouble is more with the typechecker than the IO monad directly.
14:50:20 <quicksilver> Cale: I quite like that proposal to allow multiple definitions without conflict if they are, in fact, the *same* definition up to generalisation.
14:50:55 <quicksilver> Cale: so Monad.. could be fmap, and Prelude.. would be Monad.. specialised to (r->)
14:50:55 <SamB> ddarius: or with the idea that they have to keep stuff in the monad
14:51:17 <SamB> what happens in the monad... stays in the monad...
14:51:27 <quicksilver> 2nd rule of monad club?
14:51:40 <dons> nice.
14:51:44 <Skyp> Hm, as I understand it, there cannot be a function which gives the first element of an n-tuple in haskell due to the type system, is that right?
14:51:53 <dons> ?remember SamB what happens in the monad... stays in the monad...
14:51:53 <lambdabot> It is stored.
14:52:04 <omnId> > (\(x,_,_,_,_) -> x) (1,2,3,4,5)
14:52:05 <lambdabot>  1
14:52:10 <quicksilver> Skyp: not a single function, no. There could be a typeclass method.
14:52:48 <Skyp> quicksilver: ok, but this typeclass-method could also work only up to a fixed limit, right?
14:53:04 <quicksilver> Skyp: unless the compiler contained a special hack yeah
14:53:08 <omnId> polymorphism over different tuple sizes doesn't immediately strike me as that useful.
14:53:23 <Skyp> No, not really, just trying to understand closely
14:53:23 <quicksilver> omnId: 'tuplemap' would be very useful
14:53:43 <lament> quicksilver: why?
14:53:54 <quicksilver> omnId: I often write [x,y,z] <- mapM foo [1,2,3]
14:53:58 <quicksilver> for some action 'foo'
14:54:08 <quicksilver> and I know those two lists are statically the same length
14:54:13 <wli> http://holomorphy.com/~wli/Untuple.hs
14:54:23 <ddarius> Clearly we should have a 'deriving Functor'
14:54:26 <quicksilver> would be nicer to be allowed to write (x,y,z) <- tmapM foo (1,2,3)
14:55:09 <hpaste>  scvr annotated "Trying to get the types to match up" with "Solved it!" at http://hpaste.org/3758#a1
14:55:16 <SamB> I started a library to provide this functionality... but I stopped when I realized I hadn't a clue how to make Derive derive the instances properly...
14:55:34 <SamB> and it still would have had size limits
14:55:48 <quicksilver> SamB: in principle it would be a rather small compiler hack
14:55:56 <lament> quicksilver: looks like you want Array?
14:56:03 <quicksilver> SamB: to automatically generate 'enough' instances for whichever program it was compiling
14:56:06 <quicksilver> lament: yuck, no
14:56:12 <quicksilver> lament: I just want three names, x y z
14:56:13 <Skyp> But how useful is a haskell-program that only works with a hacked compiler ;)
14:56:28 <quicksilver> lament: bound to the output of 3 actions
14:56:28 <ddarius> Skyp: As useful as any other program
14:56:31 <quicksilver> which are obviously similar
14:56:36 <SamB> ddarius: not a bit
14:56:38 <Skyp> ddarius: I doubt...
14:56:44 <quicksilver> Skyp: if this hack was useful, it might become a ghc extension
14:56:57 <quicksilver> it's quite natural to ask for the ability to derive instances of an infinite family of types
14:56:57 <lament> quicksilver: i mean, you want Array integrated into the syntax :) Since you want a homogenous data structure of fixed length...
14:57:02 <ddarius> The user only cares about the binary not how the binary was made.
14:57:07 <SamB> ddarius: haven't you heard of all the dead systems based on hacked Haskell compilers?
14:57:10 <quicksilver> (although only a finite number for any given program
14:57:23 <SamB> ddarius: most Haskell programs are libraries
14:57:33 <ddarius> Those are libraries not programs.
14:58:02 <SamB> no, they are libraries of programs
14:58:39 <Skyp> ddarius: If you decide to write a program alone and distribute solely the binary, then it doesn't matter, I agree...
14:58:51 <SamB> but who the heck codes alone?
14:59:03 * ddarius raises his hand.
14:59:37 <abell> ddarius: Me too :-)
15:00:29 * Skyp thinks about what happened to lisp ;)
15:00:34 <abell> About this fixed length array thing, I think one could use couples to come to something interesting
15:01:02 <abell> Using ( a, ( b, ( c, () ) ) ) instead of ( a, b, c )
15:01:10 <pitecus> The cabal sdist command only includes the Main.hs file in my tarball
15:01:26 <ddarius> abell: At that point writing [a,b,c] is certainly nicer and probably faster.
15:01:47 <abell> But you lose warranties on array length
15:02:27 <ddarius> I get my money back if the array is the wrong length?
15:02:51 <abell> Exactly. Since haskell is free, though ... ;-)
15:03:14 <Toxaris> couldn't the compiler find out that [x, y] <- map f [1, 2, 3] always fails? (by inlining map and comparing the statically known structure of the lists)?
15:05:15 <ricky_clarkson> Toxaris: Unless you can generalise that it seems a waste of effort to add the special case.
15:05:41 <ricky_clarkson> iow, unless "even-length list of numbers" is a type it's not worth the compiler thinking about (I think).
15:07:24 <ddarius> ricky_clarkson: See refinement types.
15:08:11 <omnId> newtype LenList n a = LL [a] -- with 'n' a phantom type
15:08:47 <SamB> and plans to do so forever?
15:08:51 <SamB> actually, I think hacked compilers are pretty inconvenient even for that...
15:11:15 <Toxaris> ricky_clarkson: I don't see what you mean. I'm proposing a kind of static plausibility check for pattern matches. how is this related to dependent types? pattern matching is not really related to typing, after all.
15:12:38 <quicksilver> Toxaris: yes.
15:12:53 <quicksilver> Toxaris: you're just talking about expanding multiple case branches at once
15:13:01 <quicksilver> Toxaris: that's perfectly feasible in priciple
15:13:21 <quicksilver> the hard part, I imagine, is for the compiler to work out when it's worth bothering with :)
15:16:18 <Toxaris> > let True = False in "test"
15:16:20 <lambdabot>  "test"
15:16:31 <mauke> haha
15:16:48 <Toxaris> > let Just x = Nothing in x
15:16:49 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just x
15:17:38 <Toxaris> quicksilver: we are talking about statically finding this error, aren't we? (at least I thing I am)
15:17:45 <Arnar> hey folks..
15:18:22 <Arnar> is there something in the prelude that parititons a list according to a predicate on the items..
15:18:54 <aspect> can anyone point me to an example of a rank-3 polymorphic function?
15:19:25 <dibblego> I am working with someone in Scala, who has used Ruby on Rails and we keep rewriting RoR crap; also, he insists on using pattern matching all the time instead of HOFs because it "aids readability" - has anyone else found themselves in this predicament?
15:19:27 <Arnar> sth. like [a] -> ([a], [a])
15:20:00 <thetallguy> dibblego: I'd be interested in an example of that.
15:20:11 <Toxaris> > partition even [1..10] -- Arnar
15:20:12 <dibblego> thetallguy, an example of what exactly?
15:20:12 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
15:20:29 <thetallguy> dibblego: I have a friend who likes RoR who is interesting in haskell, but needs some convincing
15:20:39 <Arnar> :index partition
15:20:51 <dibblego> thetallguy, oh right; I think it's just the discipline thing and breaking the imperative programming mindset
15:20:54 <thetallguy> dibblego: an example of where he uses re's an dyou would use fof
15:21:04 <thetallguy> s/fof/hog
15:21:06 <Arnar> Toxaris: thanks.. but not in scope
15:21:08 <thetallguy> s/hog/hof
15:21:12 <Arnar> I forget lambdabot prefix..
15:21:17 <dibblego> thepointer_, wtf?
15:21:30 <dibblego> er, thetallguy
15:21:32 <Toxaris> Arnar: it lives in Data.List I think
15:21:38 <dibblego> thetallguy, sorry, I'm foncused now
15:21:49 <thetallguy> dibblego: I don't see RE's as particularly imperative
15:21:57 <thetallguy> dibblego: untyped, perhaps
15:22:01 <dibblego> thetallguy, no, I mean that as well
15:22:09 <dibblego> thetallguy, two separate issues
15:22:19 <Arnar> Toxaris++ thanks
15:22:27 <Arnar> !index partition
15:22:56 <Arnar> ?index partition
15:22:56 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
15:23:01 <Arnar> ah
15:23:11 <thetallguy> dibblego: Gotcha.  On the first issue, can you give an example of something you rewrote?
15:23:13 <puusorsa> what's HOF?
15:23:21 <thetallguy> higher order functions
15:23:23 <Toxaris> puusorsa: Higher Order Functions
15:23:27 <puusorsa> oh of course
15:23:51 <dibblego> thetallguy, For example, I am converting his Option/Some/None code to things like getOrElse (I don't know the Haskell name, but of type : Maybe a -> a -> a)
15:24:00 <sieni> puusorsa: you are getting there
15:24:38 <Toxaris> it's called (flip fromMaybe) in Haskell
15:24:49 <thetallguy> no, that's maybe, isn't it?
15:24:59 <puusorsa> sieni, i doubt that
15:25:04 <dibblego> ?hoogle Maybe a -> a -> a
15:25:05 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
15:25:05 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
15:25:14 <dibblego> fromMaybe
15:25:29 <puusorsa> unless by 'there' you mean drunk
15:25:54 <thetallguy> No, you're right
15:26:02 <puusorsa> maybe i should forget trying to understand haskell, get a lobotomy and start doing php
15:26:06 <thetallguy> similary
15:26:18 <thetallguy> similar
15:26:20 <dibblego> but there's also the imperative mindset, which is far more difficult to break
15:26:29 <dibblego> but very frustrabating to sit next to and try to do some damn work
15:26:34 <lament> you mean the common sense mindset? :)
15:26:45 <puusorsa> common sense isn't that common
15:27:28 <SamB> what I like is people who can't understand mutable variables
15:27:28 <thetallguy> dibblego: yes.  you need to find something you can do as a result of sing your form of coding that he can't do as fast
15:28:19 <dibblego> thetallguy, we also spend hours writing code that I just feel like deleting
15:33:35 <wli> I've practically already had a lobotomy.
15:33:50 <Arnar> ?index intersperse
15:33:50 <lambdabot> Data.List
15:33:56 <Arnar> :t intersperse
15:34:01 <lambdabot> forall a. a -> [a] -> [a]
15:36:08 <omnId> > intersperse '!' "harbl"
15:36:09 <lambdabot>  "h!a!r!b!l"
15:37:01 <lament> wli: did it improve your php skills?
15:37:37 * LoganCapaldo renames intersperse to sprinkle
15:37:38 <wli> No.
15:37:43 <kawfee> wli!
15:37:49 <kawfee> it's you!
15:37:51 <lament> it's all lies then
15:37:52 <puusorsa> funny stuff.. 5 minutes after i whined about how stupid php is i was offered work
15:37:56 <puusorsa> php development
15:38:01 <olsner> LoganCapaldo: sprinkle is the new intercalate, is it?
15:38:01 <kawfee> wli why on earth would you want to touch PHP?
15:38:31 * lament hands puusorsa a trepan
15:38:43 * omnId likes 'intercat' for 'intercalate'
15:38:44 <puusorsa> "do you know sql?" "yes" .. "how about php?" "well, if i started drinking for a few weeks or got a lobotomy, sure"
15:39:07 <olsner> so you rejected the php dev. job then?
15:39:08 <LoganCapaldo> > let sprinkle = intersperse ; on = id ; stars = '*' in sprinkle stars `on` "the sky"
15:39:10 <lambdabot>  "t*h*e* *s*k*y"
15:39:42 <olsner> @remember LoganCapaldo > let sprinkle = intersperse ; on = id ; stars = '*' in sprinkle stars `on` "the sky"
15:39:43 <lambdabot> Okay.
15:39:59 <puusorsa> not really. turned out doing it in php isn't neccessary
15:40:24 <shachaf> LoganCapaldo: Using `on` isn't really fair.
15:40:24 <olsner> ah, so you converted the php job into a haskell job?
15:40:27 <puusorsa> might even do it in haskell
15:40:30 <puusorsa> yes
15:40:32 <shachaf> @let on f g x y = g x `f` g y
15:40:32 <lambdabot> <local>:9:0:     Multiple declarations of `L.on'     Declared at: <local>:7:0...
15:41:21 <puusorsa> or maybe. might be i never get around to actually doing the stuff. already have a job or five...
15:41:35 <LoganCapaldo> @type on
15:41:37 <lambdabot> Not in scope: `on'
15:41:39 <omnId> > ((*) `on` (+2)) 3 2
15:41:40 <lambdabot>  20
15:41:55 <LoganCapaldo> I wish @type knew about @let
15:42:03 <LoganCapaldo> @type L.on -- or does it?
15:42:05 <lambdabot>     Interface file inconsistency:
15:42:05 <lambdabot>       home-package module `L' is mentioned,
15:42:05 <lambdabot>       but does not appear in the dependencies of the interface
15:42:05 <omnId> > on :: ()
15:42:06 <lambdabot>  Couldn't match expected type `()'
15:42:16 <LoganCapaldo> omnId: nice one! :)
15:42:30 <LoganCapaldo> didn't work but was well played
15:42:31 <omnId> LoganCapaldo: didn't get enough of the error message, though
15:43:34 <olsner> so, which bug will get fixed first? @type working on @let or displaying more lines of error message? ;-)
15:43:46 <LoganCapaldo> I use that technique with people instead of compilers sometimes :)
15:44:22 <omnId> LoganCapaldo: tell them something patently false so they will educate you?  :)
15:44:42 <olsner> it relies on the people correcting you actually knowing better, though
15:44:44 <shachaf> I wish you could see what was in @let.
15:45:07 <shachaf> And that @src worked with it.
15:45:22 <kpreid> I wish that @undefine was selective
15:45:26 <shachaf> (And that @src had nicer implementations.)
15:45:41 <shachaf> I wish @let could work with data and friends.
15:46:07 <omnId> I want a pony
15:46:16 <ricky_clarkson> I wish @djinn worked with monads.
15:46:59 <shachaf> ricky_clarkson: Which monads?
15:47:00 <ddarius> kpreid: Make it.
15:47:04 <ddarius> @fact pony
15:47:05 <lambdabot> I know nothing about pony
15:47:08 <ddarius> @where pony
15:47:08 <lambdabot> I know nothing about pony.
15:47:17 <ricky_clarkson> shachaf: list, at least.
15:47:21 <pjd> @have pony
15:47:21 <lambdabot> Not enough privileges
15:47:25 <ddarius> @fact pony?
15:47:25 <shachaf> ricky_clarkson: Sure: f _ = [].
15:47:26 <lambdabot> I know nothing about pony?
15:47:39 <shachaf> ricky_clarkson: For @djinn, [] = Maybe.
15:47:43 <ricky_clarkson> @djinn a -> [a]
15:47:43 <lambdabot> -- f cannot be realized.
15:47:50 <shachaf> @djinn a -> Maybe a
15:47:50 <lambdabot> f = Just
15:47:54 <shachaf> @djinn a -> Maybe b
15:47:54 <lambdabot> f _ = Nothing
15:49:35 <shachaf> ricky_clarkson: Which djinn-interesting monads don't have a zero?
15:49:47 <shachaf> @instances Monad
15:49:48 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:50:24 <lament> @djinn pony
15:50:24 <lambdabot> -- f cannot be realized.
15:51:16 <chessguy> @quote pony
15:51:16 <lambdabot> No quotes match. The more you drive -- the dumber you get.
15:51:20 <ricky_clarkson> shachaf: Sure, if you know what you're doing you can use djinn and pretend it could handle lists.
15:51:25 <lament> @yow pony
15:51:25 <lambdabot> Where do your SOCKS go when you lose them in th' WASHER?
15:51:44 <shachaf> ricky_clarkson: A list is no different from a Maybe, though.
15:51:54 <ricky_clarkson> I see that.
15:51:56 <lament> @vixen pony
15:51:57 <lambdabot> i hate it when i get stuck with chatting with a bot!
15:52:06 <shachaf> @brain pony
15:52:07 <lambdabot> Has it ever occurred to you, Pinklet, that your scarf is
15:52:07 <lambdabot> constricting the bloodflow to your head?
15:52:26 <lament> @karma pony
15:52:27 <lambdabot> pony has a karma of 0
15:52:33 <lament> pony++
15:52:51 <olsner> @help brain
15:52:51 <lambdabot> brain. Pinky and the Brain
15:52:56 <olsner> @brain
15:52:56 <lambdabot> Promise me something, Pinky. Never breed.
15:53:06 <olsner> @keal
15:53:07 <lambdabot> nsa prevent me from returning to math on efnet
15:53:28 <shachaf> @protontorpedo
15:53:29 <lambdabot> is it nicer than APL?
15:53:49 <Toxaris> your pony ate my free lunch :(
15:53:49 <omnId> @@ @elite @run wordsWise (map reverse) @show keal
15:53:51 <lambdabot>  "1a3K"
15:54:00 <omnId> :)
15:54:01 <omnId> @@ @elite @run wordsWise (map reverse) @show @keal
15:54:03 <lambdabot>  "toB Sm3E$ 55ELezu"
15:54:21 <omnId> :O
15:54:28 <thepointer_> <dibblego> thepointer_, wtf? <-- hi?
15:54:28 <omnId> how dare keal insult LB!
15:54:35 <omnId> thepointer_: typo
15:55:04 <dibblego> thepointer_, sorry, there are a few the* around here
15:55:33 <omnId> more of a "tabo", I'd actually imagine :)
15:56:37 <lament> we should all prefix our nicks with the.
15:56:49 <lament> it would be freenodelike.
15:56:58 <olsner> that'd be "the the day"
16:02:15 * sorear wishes jerzy.karczmarczuk would use more linefeeds
16:04:51 <LoganCapaldo> linefeeds are for the weak!
16:05:24 <sorear> there is a line, between merely being different and rebuking proper english
16:05:58 <dons> jerzy's so much fun :)
16:06:25 <byorgey> ? I'm confused.  looks like plenty of linefeeds to me...
16:06:35 <Skyp> Ok, my turing-machine is quite complete now... I would like to present it to some people at my company who are interested in haskell, so I tried to write it as clean as I can... Unfortunately I am not very firm in this language myself ;) Perhaps someone is bored and wants to have a look: http://shodan.dereference.de/turing.hs
16:08:16 <ddarius> Why do you want a Turing machine?
16:08:28 <mrd> case insn@getinsn insns insnr
16:08:41 <LoganCapaldo> because writting a LC interpeter in Hskell would be too obvious :)
16:08:54 <mrd> proves haskell is turing complete!
16:09:13 <ddarius> If you must write something in that general vicinity, there are far more interesting things.
16:09:39 <mrd> if all you do is " = if ..." then use guards
16:09:47 <mrd> [x] instead of x:[]
16:09:59 <LoganCapaldo> I would do Set, Test, Halt etc. But my criticisms are purely cosmetic as usual :)
16:10:22 <LoganCapaldo> also
16:10:35 <LoganCapaldo> I woudln't use tuples in the defn. of Insn
16:10:46 <LoganCapaldo> Set Int Int Char Int
16:10:49 <LoganCapaldo> etc.
16:11:07 * LoganCapaldo wonders if Skyp is a refugee from ML
16:11:34 <Skyp> Hm, no, I'm not ;)
16:11:38 <mrd> yea does look vaguely like oit
16:11:39 <mrd> it
16:11:47 <mrd> getinsnid isn = case insn of ...
16:11:49 <Skyp> pure coincidence ;)
16:11:54 <mrd> pointless case
16:12:11 <mrd> modulo typo
16:12:28 <Skyp> mrd: hm, how should I write it then?
16:12:43 <mrd> getinsnid (L (nr,_,_)) = nr
16:12:58 <mrd> well, besides the fact that the whole function looks like its begging for records
16:13:12 <Toxaris> Insn would benefit from record syntax
16:13:18 <Skyp> ah, ok ;)
16:13:43 <LoganCapaldo> hehe
16:13:43 <mrd> records would allow you to derive the function insnid from the datatype definition directly
16:14:04 <Toxaris> do not use tabstops in source files :)
16:14:08 <LoganCapaldo> getinsid insn = ir insn -- if you used record :)
16:14:18 <LoganCapaldo> *records
16:14:29 <mrd> data Insn = L { isnid :: Int , ... } | R { isnid :: Int, ... } | ...
16:15:47 <Toxaris> getinsn xs nr = (xs ++ repeat (HALT 0)) !! nr
16:15:47 <Skyp> Yes, the instruction-finding is the ugliest part in the code at the moment...
16:16:18 <Toxaris> aproximately :)
16:16:58 <chessguy> @pl getinsn xs nr = (xs ++ repeat (HALT 0)) !! nr
16:16:58 <lambdabot> getinsn = (!!) . (++ repeat (HALT 0))
16:17:09 <Toxaris> why are instructions numbered?
16:17:31 <ddarius> Why the tuples?  Why the single letter top-level names?  Why aren't the *aux functions local?
16:17:37 <Skyp> Toxaris: because the numbers should not necessarily be consecutive
16:18:19 <puusorsa> wanna?
16:18:23 <Toxaris> Skyp: ok then you can't use (!!) of course, but you can use find
16:19:19 <Toxaris> getinsn xs nr = fromMaybe (Halt 0) (find ((nr ==) . getinsnid) xs)
16:19:27 <Skyp> ddarius: To be honest, I didn't think of not using tuples ;) What is wrong with the top-level names? you mean l,r etc is not expressingly enough?
16:20:00 <Skyp> local functions are the (\x ->...)-syntax, right?
16:20:27 <ambiotic>  I'm just getting into Haskell, and I've got a simple question. Is there a way to get around whitespace and indentation if you really feel like it? For oneliners that get a bit hairy and that sort of thing
16:20:42 <Toxaris> > let toplevel x = local x where local x = 2 * x in toplevel 21
16:20:43 <omnId> Skyp: f x = ... where localfunction y = ...
16:20:44 <lambdabot>  42
16:20:48 <mrd> ambiotic: { ... ; ... }
16:21:08 <ddarius> Skyp: What omnId said, you can also do it for rb and lb.
16:21:15 <ddarius> (which are also horribly named)
16:21:40 <ambiotic> mrd; thank you
16:22:01 <Skyp> ok, the names are quite short, but they closely resemble a script on turing-machines my colleagues work with ;)
16:22:22 <mrd> people actually work with turing machines?
16:22:41 <Skyp> Hehe, just for educational purposes of course ;)
16:23:00 <ddarius> Skyp: Ignoring for a second the record suggestion, you can write your data type as data Insn = L Int Int Int | R Int Int Int | etc.
16:23:13 <ddarius> In fact, it would probably be better to make those strict.
16:23:24 <Skyp> Ok
16:23:25 <ddarius> And it would be beneficial to use the record suggestion as well.
16:24:07 <dons> sorear: i agree: there's no point reimplementing md5 in haskell, just fill buffers with the ffi
16:24:35 <ddarius> dons: But we should be able to readily enough.
16:24:38 <wli> Well, there is a point to reimplementing a lot of things, namely NDP.
16:24:57 <dons> ddarius: yep. it servers as a benchmark for the state of the compiler
16:25:03 <wli> (esp. linear algebra)
16:25:09 <dons> for anyone with money on the line, just bind and fill a bytestring
16:25:16 <ddarius> Agreed.
16:25:30 <dons> hence i used openssl when it mattered for my job
16:25:31 <Skyp> Ok, thank you very much for your suggestions, I'll try to implement them ;)
16:25:37 <Toxaris> Skyp: Band representation looks odd. what about reversing the first list to avoid the use of init and last?
16:25:55 <dons> sorear: you're a little abrupt in that email, btw.
16:26:06 * ddarius hasn't look at it closely, but zipper! ?
16:26:11 <sorear> abrupt?
16:26:18 <dons> -O3 is fixed in 6.8 btw.
16:26:20 <ddarius> dons: Are we worried about hurt feelings?
16:26:27 <sorear> oh, that's a relief
16:26:36 <Skyp> Toxaris: Hm, I am not sure I understand what you mean ;)
16:26:39 <dons> just encouraging people not to use the word "stupid" ever, in any technmical forum
16:27:09 <Toxaris> Skyp: If I understand your encoding, correct, ("abc", 'd', "efg") is the band "abcdefg" with pointer to 'd'?
16:27:19 <ddarius> Does this count as a technical forum? (#haskell that is)
16:27:20 <Skyp> yes, right
16:27:34 <Toxaris> Skyp: I (and ddarius) suggest to encode it as ("cba", 'd', "efg")
16:28:07 <Toxaris> so you can access the "neigherhood" of 'd' efficient
16:28:15 <dons> ddarius: sure.
16:28:21 <ddarius> init/last = bad
16:28:23 <dons> though its not as bad as -cafe@
16:28:26 <ddarius> dons: drat
16:28:56 <Skyp> Hm, right! Then just the output decoder had to reverse that string
16:29:02 <Toxaris> Skyp: this is called a zipper, invented by Huet and very usefull
16:29:24 * ddarius usually takes Thumper's mother's advice.
16:29:47 <Skyp> Thanks, I'll try to do it that way
16:30:35 <Toxaris> Skyp: in Haskell you can even model infinite Turing machine bands: ("cba" ++ repeat ' ', 'd', "efg" ++ repeat ' ')
16:30:44 <Toxaris> or whatever is approbiate instead of ' '
16:31:04 <doctormach> Has anyone been able to get a 64-bit version of ghc working on Mac OS X?
16:31:11 <Toxaris> this may be a problem with output, but could make your lb and rb function very cute
16:31:34 <Skyp> Oh, nice! I did that in the r/l-functions now, but that is much better of course
16:32:14 <Toxaris> what's the point of showcasing Haskell and not using infinite lists
16:32:43 <Toxaris> Skyp: interested in more ideas, or is it enough for the moment?
16:32:56 <Skyp> Toxaris: I'd be glad!
16:33:50 <Toxaris> you have various functions working on only one band in a list of bands. these have a common structure (main function to select band, subfunction to do actual work)
16:34:22 <Toxaris> you generalize the main functions so you need only one of them
16:35:08 <Toxaris> something of type   (a -> a) -> Int -> [a] -> [a]
16:35:38 <Skyp> Ah, I understand... with an infinite list of bands I can even eliminate the special case of 'set' adding more bands manually
16:35:42 <Skyp> right?
16:36:06 <LoganCapaldo> Haskell kills edge cases dead.
16:36:21 <LoganCapaldo> 'by eliminating edges!!
16:37:00 <Toxaris> Skyp: yep should work
16:37:26 <Toxaris> so you can use the same "main function for band selection" for set again
16:37:36 <SamB_XP> LoganCapaldo: since when
16:37:52 <LoganCapaldo> SamB_XP: slogans don't have to be true
16:38:02 <Toxaris> rule of thumb: a haskell program is done if nothing is left of it
16:38:05 <SamB_XP> you're confusing programming with politics
16:38:08 <SamB_XP> or marketing
16:38:15 <Skyp> nice rule ;))
16:38:20 <ddarius> Actually Haskell and Haskell code does tend to cleanly avoid edge cases.
16:38:31 <SamB_XP> ddarius: yeah
16:38:34 <SamB_XP> I guess
16:38:39 <SamB_XP> what's an edge case again?
16:38:43 <SL> I am looking for some example code on how to use Data.Array.IO (mutable boxed Arrays)?
16:39:36 <SamB_XP> SL: what? example code?
16:39:43 <SamB_XP> can't you read the source of the module or something?
16:40:13 <sjanssen> SL: http://www.haskell.org/haskellwiki/Modern_array_libraries#Mutable_IO_arrays_.28module_Data.Array.IO.29
16:40:15 <lambdabot> Title: Arrays - HaskellWiki, http://tinyurl.com/2hpyfg
16:41:02 <SL> yes, I know this
16:41:10 <chessguy> > head [] -- edge case
16:41:12 <lambdabot>  Exception: Prelude.head: empty list
16:41:13 <SamB_XP> SL: what more do you need?
16:43:00 <Toxaris> chessguy: exactly this edge case was avoided by my suggestion to use infinite lists :)
16:44:14 <Toxaris> why is there no standard List type without base case?
16:44:14 <Olathe> _|_ has no members at all !
16:44:15 <SL> SamB, hm, actually I have problems using it in a IO monad
16:44:36 <SamB_XP> SL: really?
16:44:41 <SamB_XP> I always have problems with ST
16:44:53 * SamB_XP hugs unsafePerformIO
16:45:09 <Olathe> @where _|_
16:45:09 <lambdabot> I know nothing about _|_.
16:45:11 <SamB_XP> @hoogle unsafeFreeze
16:45:12 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
16:45:17 <SamB_XP> I hug that too
16:45:43 <Olathe> @where+ _|_ http://en.wikipedia.org/wiki/Bottom_type
16:45:43 <lambdabot> It is stored.
16:45:45 <Olathe> @where _|_
16:45:45 <lambdabot> http://en.wikipedia.org/wiki/Bottom_type
16:46:13 <LoganCapaldo> @slap _|_
16:46:13 * lambdabot jabs _|_ with a C pointer
16:46:21 <LoganCapaldo> oh dear god
16:46:25 <LoganCapaldo> that's terrifying
16:46:31 <LoganCapaldo> I'm sorry
16:47:05 <Olathe> @where botdeath
16:47:05 * lambdabot dies.
16:47:19 <monochrom> Please don't die.
16:47:41 <LoganCapaldo> @ressurect
16:47:42 <lambdabot> Unknown command, try @list
16:47:47 <chessguy> Toxaris> why is there no standard List type without base case? you mean like data List = Node | Cons Node List ?
16:47:54 <Olathe> @where botlife
16:47:54 * lambdabot lives.
16:48:14 <monochrom> Interesting.
16:48:25 <monochrom> "the bot is dead. long live the bot!" ? :)
16:48:25 <LoganCapaldo> chessguy: I think he meant like data List a = Cons a (List a)
16:48:31 <Olathe> Heheh
16:48:36 <chessguy> err, yeah, that
16:48:51 <LoganCapaldo> (iow no empty value)
16:49:09 <wli> data NonEmptyList t = Singleton t | NonEmptyCons t (NonEmptyList t)
16:49:25 <Toxaris> chessguy: yes what LoganCapaldo said
16:51:58 <SL> SamB_XP, is there a more convienent method to access a IOArray, like (//) for immutable Arrays?
16:52:20 <SamB_XP> mutable arrays are rarely convenient
16:52:38 <ddarius> / is convenient?
16:52:54 <ddarius> doh
16:53:24 <alar> "
16:53:27 <alar> @bot
16:53:28 <lambdabot> :)
16:53:35 <Olathe> @b
16:53:36 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . ? @ v
16:53:40 <Olathe> @maybe
16:53:41 <lambdabot> Unknown command, try @list
16:53:45 <Cale> You could write a /// operator which would (roughly) mapM writeArray over a list of changes
16:53:49 <Olathe> @bo
16:53:49 <lambdabot> :)
16:56:46 <chessguy> @peep
16:56:47 <lambdabot> Maybe you meant: help seen temp
16:56:53 <chessguy> @quote
16:56:53 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
16:56:57 <SL> ok, lets say I want to write some backtracking algorithm which operates on a 2d array of some values. Is there a better approach for this than using mutable arrays?
16:57:10 <chessguy> @where sudoku
16:57:10 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
16:57:17 <chessguy> SL, i'd say that's a good start :)
16:59:20 <lament> i'm getting more and more proud of having never written a sudoku solver
16:59:46 * shachaf never wro... Oops, never mind.
17:00:25 <SL> they are using Data.Array.Diff
17:00:26 <lament> see ;)
17:00:48 <sorear> I've never done it!
17:00:57 <SamB_XP> me either
17:01:05 <SamB_XP> I don't know how and I don't really care
17:01:06 <idnar> or me
17:01:21 <sorear> SL: Write a program which outputs C and feed it into GCC.
17:01:37 <SL> C is boring
17:01:49 <sorear> C generated using Haskell is less so.
17:02:18 <idnar> write a program which outputs FORTRAN and feed it into g77
17:03:01 <vincenz> Haskell generated using C even less
17:04:10 <LoganCapaldo> what about C compiling to Haskel...
17:04:18 <vincenz> easy
17:04:31 <LoganCapaldo> written in cobol
17:04:33 <QtPlatypus> Wouldn't it be more fun to target one of gcc's internal reprepresentations?
17:04:43 <vincenz> LoganCapaldo: and running on the um interpreter?
17:04:50 <LoganCapaldo> we're talking about fun? I thought we were inventing new tortures?
17:04:54 <vincenz> QtPlatypus: not possible
17:05:00 <vincenz> QtPlatypus: I asked the gcc guys for this for another reason
17:05:06 <vincenz> QtPlatypus: the internal representations are not readable
17:05:21 <vincenz> in fact
17:05:23 <vincenz> you can't even dump it
17:05:32 <vincenz> since some things (like central tables) aren't dumped
17:05:47 <vincenz> which is annoying
17:08:35 <Lycurgus> fun/torture it's subjective. There is a COBOL 2002.
17:09:16 <Botje> there's also a windows 2003, what's your point? :)
17:09:16 <Lycurgus> ah, and a gcc-COBOL.
17:10:11 <thoughtp1lice> can anybody explain (in laymans terms) what the new type families addition gives us? i've tried reading over the paper by chak & co, but I'm still not exactly getting it (since 6.8 is out now I guess it's worth looking at?)
17:10:11 <Lycurgus> a COBOL-Haskell translator, operating in the right context is an interesting concept, commercially.
17:10:25 <LoganCapaldo> no no
17:10:32 <LoganCapaldo> not a cobol haskell translator
17:10:48 <LoganCapaldo> a C->Haskell translator written in COBOL
17:11:06 <TSC> Err, sorear, I think you're wrong on cafe about the O2/O3 thing
17:11:06 <Lycurgus> yeah, I was ignoring that.
17:12:02 <TSC> (never mind, I see it on -blah)
17:12:14 <sorear> thoughtp1lice: /nick thoughtpolice?
17:12:36 <thoughtpolice> didn't notice :x
17:12:57 <monochrom> CONVERT c TO haskell GIVING result
17:13:01 <monochrom> * :)
17:13:23 <sorear> Is the * a bullet-hole?
17:13:24 <monochrom> Oh bother, forgot the period!
17:13:28 <monochrom> comment.
17:13:33 <monochrom> http://www.csis.ul.ie/COBOL/examples/Accept/Multiplier.htm
17:13:34 <lambdabot> Title: ACCEPT, DISPLAY and MULTIPLY example program
17:15:52 <SL> so, the idea to write a sudoku solver in haskell seems to be quite popular
17:17:15 <chessguy> SL, it's an interesting problem
17:17:57 <SL> not really
17:18:23 <chessguy> well, apparently enough people think it is
17:18:25 <SL> its just the problem which is known as exact cover
17:18:39 <ray> it's a pretty easy problem
17:18:53 <ray> but you could have weird methods that make it more interesting
17:19:12 <SL> yes, I tought, well, I've never written a real application in haskell, lets do so by writing a sudoku solver
17:19:45 <ray> yeah, that's a good idea
17:22:18 <Lycurgus> FTR: OpenCOBOL.
17:22:42 <hays> anyone in here a computability wonk?
17:23:00 <sorear> ?web1913 wonk
17:23:01 <lambdabot> No match for "wonk".
17:23:04 <sorear> ?
17:23:09 <chessguy> @jargon wonk
17:23:10 <lambdabot> No match for "wonk".
17:23:17 <omnId> @all-dicts wonk
17:23:18 <lambdabot> *** "wonk" wn "WordNet (r) 2.0"
17:23:18 <lambdabot> wonk
17:23:18 <lambdabot>      n : an insignificant student who is ridiculed as being affected
17:23:18 <lambdabot>          or studying excessively [syn: {swot}, {grind}, {nerd}, {dweeb}]
17:23:22 <sorear> hays: Just ask your question.
17:23:24 <hays> wonk==genius/exceptional at
17:23:31 <sorear> then yes
17:23:35 * chessguy agrees with sorear
17:23:38 <sorear> but PLEASE just ask your question
17:24:00 <sorear> asking if blah blah blah is here, is a total waste of everybody's time
17:24:17 <hays> My question is off topic.  I'll ask it here.  I am trying to figure out how powerful a spreadsheet is in terms of computation.  No recursion or self-reference, and no scripting over the top of it.
17:24:19 <sorear> good thing you didn't ask on #math, that's an /ignoring offense there
17:24:30 <chessguy> sorear, only to TRWBW
17:24:45 <Lycurgus> and X geek/nerd/<asshole-term-of-derision-of-choice> raises hackels
17:25:06 <hays> I've only heard wonk in a good context..  surprised to see that definition
17:25:16 <sorear> hays: Sub-turing, since it is emulable by an always-halting TM
17:25:30 <hays> sorear, yeah, I agree with that
17:26:15 <hays> And I think its >= a finite state machine
17:26:35 <hays> although I would have trouble proving it
17:27:48 <hays> does arithmetic require a pushdown automata?
17:28:13 <Lycurgus> uh-oh
17:28:32 <mrd> how much of arithmetic?
17:29:55 <mrd> natural numbers with addition and multiplication is enough to recover self-reference
17:30:10 <hays> hmm
17:30:25 <mrd> however most computer programs do not feature the infinite set of natural numbers ;)
17:30:51 <chessguy> > [1..[
17:30:51 <lambdabot>  Parse error at end of input
17:30:53 <chessguy> > [1..]
17:30:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:31:01 <sorear> mrd: I think you also need quantifiers, the expression fragment of arithmetic is very much decidable
17:31:18 <mrd> well sure, but without quantifiers there's not much to ask
17:31:46 <hays> well im trying to bound the computational "power" of a spreadsheet
17:31:58 <hays> I agree with < turing machine
17:32:15 <lament> spreadsheets don't have quantifiers
17:32:24 <Freed> Hi, I have a little problem installing haskell-mtl, When compiling Setup.hs it says: Could not find module `Distribution.Setup':it is a member of package Cabal-1.1.6.2, which is hidden
17:32:27 <lament> i was thinking about writing a spreadsheet in haskell at one point
17:32:28 <hays> they do have if statements though
17:32:36 <lament> the spreadsheet would of course be infinite
17:32:47 <mrd> if there are variables, there are quantifiers
17:32:53 <sorear> @go pivotal haskell
17:32:55 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal/
17:32:56 <lambdabot> Title: Pivotal home page
17:32:57 <Freed> I tried editing the cabal file to put Cabal in build-depends but that doesn't work
17:33:04 <sorear> mrd: lambda, not for-all
17:34:11 <hays> mrd, there are no variables.. everything is constant
17:34:25 <TomM2> ... except MVars ...
17:34:29 <TomM2> ... and TVars ...
17:34:43 <hays> every cell is either a constant or a function of another cell, and no cell is a function of itself directly or indirectly
17:35:17 <idnar> lament: a multi-dimensional spreadsheet?
17:35:27 <hays> A spreadsheet sure feels like a FSM and nothing more.  I just have no idea how to prove that
17:35:41 <lament> idnar: no, a regular spreadsheet, so 2d
17:36:04 <lament> just infinitely big/lazily evaluated
17:36:15 <hays> the spreadsheet could be 1-D and I don't think it would change the answer
17:36:31 <idnar> lament: multi-dimensional is where it's at! ;)
17:37:16 <lament> that's not a spreadsheet anymore, and have fun displaying it
17:37:52 <idnar> lament: I'm thinking of this sort of thing: http://www.quantrix.com/
17:37:53 <lambdabot> Title: Quantrix | Business Modeling & Analytics Software | Financial Modeling | Data Mo ...
17:38:06 <idnar> multi-dimensional is perhaps an inaccurate term
17:38:14 <hays> well a countably infinite spreadsheet in 2-D is just as big as one in 1-D
17:38:36 <lament> oh god, what a website
17:39:36 <lament> and why does somebody named "Notrix" leave when something named "Quantrix" is mentioned?
17:39:50 <idnar> heehee
17:39:54 <QtPlatypus> One could simulate turing mechean quite trivally in a countably infinite spreadsheet.
17:39:56 <idnar> hmm, maybe http://en.wikipedia.org/wiki/Lotus_Improv is a better link
17:39:57 <lambdabot> Title: Lotus Improv - Wikipedia, the free encyclopedia
17:40:10 <hays> Qt how
17:40:15 <lament> QtPlatypus: yes?
17:42:02 <Freed> Am I asking this in the wrong room?
17:42:48 <Lemmih> Freed: Use --make.
17:43:05 <Freed> I did that
17:43:20 <QtPlatypus> You set up a cell for "current state" and anouther for "head possision".  You then create a table for next state.  All the other cells representing your state contain basically the function (if the readhead cell is pointing at me update the state and the readhead pointer accroding to the state table)
17:43:48 <Lemmih> Freed: Don't compile Setup.lhs?
17:44:20 <lament> QtPlatypus: that sounds like one step of operation of the turing machine
17:44:32 <QtPlatypus> Though I think it might be easyer to make an abicaus mechean in spreadsheets and use that equivlerncy to get to a turing machine.
17:44:54 <lament> You can also perform one step with regular expressions, but regular expressions aren't TC
17:44:56 <Freed> using runghc it won't work either but I am running ghc 6.7
17:45:02 <monochrom> Nice, QtPlatypus.
17:45:05 <QtPlatypus> lament: And spreadsheets repeat untill they resolve.
17:45:13 <QtPlatypus> Or can be made to.
17:45:52 <monochrom> Yeah, spreadsheet program keeps reiterating as long as some cell is changed last time.
17:46:05 <lament> oh, then of course they're tc
17:46:34 <lament> what happens if it doesn't halt?
17:46:47 <monochrom> Then it doesn't halt. :)
17:46:56 <lament> does Excel crash? :)
17:46:56 <Freed> since 6.7 there is split archive depedency or so i have to update cabal files since base doesn't cover everything anymore
17:49:45 <Freed> there is no lhs only a Setup.hs
17:51:07 <monochrom> Open Office implements a similar cycle detection as GHC's black hole detection. Perhaps Excel does too.
17:52:25 <monochrom> This was my experiment: B1 is =IF(C1=0;0;B1+1) , then try making C1 0, and try making C1 1.
17:54:38 <idnar> Excel stops as soon as it finds a circular reference
17:54:47 <idnar> you can manually iterate the calculation, though
17:55:16 <idnar> you get asked if you want to disable auto calculation, and then you can manually mash "calculate now" which runs one iteration, or something like that
17:57:58 <monochrom> what is the command to write into another cell?
17:58:06 <shapr> Yay, HaskellNet compiles.
17:58:17 <EvilTerran> monochrom, there isn't one
17:58:42 <monochrom> Then QtPlatypus's scheme lacks that.
17:59:02 <EvilTerran> think of each cell as a variable in a purely functional language
17:59:55 <EvilTerran> in excel, you can't even do so via VBA - everything's read-only for scripts invoked from cell formulas
18:02:06 <lament> that shouldn't affect turing-completeness
18:02:39 <EvilTerran> what affects turing-completeness is the lack of iteration or recursion
18:02:53 <EvilTerran> without going into VBA, which is clearly turing-complete
18:03:14 <EvilTerran> you can, however, fake it by using one of the dimensions of the table as "time"
18:03:17 <lament> if, as people say, evaluation continues as long as some cells were updated, that's enough for TC
18:03:36 <EvilTerran> i think that depends on your configuration, but isn't so by default
18:03:39 <shapr> Does hackage have tags or some way to say that a library has been tested with GHC 6.8.1, GHC 6.6.1, or other compiler/version combinations?
18:04:02 <lament> EvilTerran: in which case it's not TC of course
18:04:23 * EvilTerran has experimented with giving each variable its own column, and expressing an iterative algorithm by each cell referring to values in the row above
18:04:51 <lament> iteratively applied regexes are turing-complete, a single application isn't; this seems to be a similar case
18:04:57 <EvilTerran> you can get some vaguely interesting pictures with conditional-formatting-wise background colours
18:05:35 <Freed> when using verbose i get hiding package Cabal-1.1.6.2 to avoid conflict with later version Cabal-1.2.0
18:05:55 <blakkino> hello
18:06:02 <lament> EvilTerran: hee, should be very easy to do 1d CA
18:06:06 <shapr> hiya blakkino
18:06:13 <blakkino> someone know how to workaround the "darcs: Command not found" when doing darcs push..
18:06:13 <EvilTerran> indeed
18:06:14 <blakkino> :)
18:06:26 <lament> which makes spreadsheets TC according to _some_ definitions
18:06:31 <shapr> blakkino: Does that mean darcs is missing on the server side?
18:06:41 <EvilTerran> lament, well, only if you're allowed tables of arbitary size
18:06:47 <blakkino> shapr, it is not missing but i installed it on my ~./bin
18:07:03 <blakkino> and the startup script isn't called
18:07:04 <EvilTerran> and that's tantamount to an infinite program
18:07:20 <shapr> blakkino: Are you using bash?
18:07:31 <blakkino> also /.ssh/environment is disabled
18:07:33 <sorear> just use a Real Programming Language(tm)
18:07:53 <blakkino> i'm not using bash but i don't think that this matter (darcs doesn't execute bash, correct?)
18:07:58 <lament> EvilTerran: a guy from #esoteric just got some money from Wolfram for proving that a particular CA is TC. He used infinite, repeating initial conditions in the proof
18:08:02 <shapr> blakkino: I don't know
18:08:07 <monochrom> Shouldn't it be: Real Programming Language(tc) ? :)
18:08:10 <blakkino> it does use ssh to directly executed the remote darcs i think
18:08:15 <Freed> what do I have to change to use the older 1.1.6.2  ?
18:08:17 <shapr> I don't know how the path is setup for a non-interactive shell.
18:08:29 <EvilTerran> i believe finite excel spreadsheets cannot be turing-complete without iterating circular references, even if each cell is allowed to contain infinite data
18:08:37 <EvilTerran> i may be mistaken, though. it just seems likely.
18:08:58 <EvilTerran> lament, i heard about that CA. hadn't read up on it, though
18:09:32 <monochrom> If you can write a program to decide "does it halt", then "it" is not turing complete. :)
18:09:33 <blakkino> shapr, i think only someone that had the same problem can help me :)
18:09:35 <TomM2> > "ping"
18:09:36 <lambdabot>  "ping"
18:09:55 <blakkino> :|
18:09:57 <TomM2> @let ping _ = "pong"
18:10:02 <lambdabot> Defined.
18:10:23 <ivanm> > ping "foo"
18:10:24 <lambdabot>  "pong"
18:10:34 <TomM2> >ping undefined
18:10:41 <ivanm> > ping
18:10:42 <lambdabot>  Add a type signature
18:10:50 <ivanm> heh
18:10:50 <sorear> > ping()
18:10:52 <lambdabot>  "pong"
18:10:58 <ivanm> > ping undefined
18:10:59 <lambdabot>  "pong"
18:11:07 <ivanm> TomM2: need a space after the ">"
18:12:11 <TomM2> sorear: I appriciate the fact that you are being practical, not fanatical, on the ML - but I also have found it funny how over ~6 months there were 3 questions about a "pure" Haskell  MD5 function and the response was always 'use FFI'.  Hence I had some fun and made one.
18:12:44 <sorear> okay, if it was fun I don't mind
18:14:04 * EvilTerran looked into writing a mersenne twister library, but decided that just FFIing the normal C library would by far be a better solution
18:14:27 <EvilTerran> ...and then I didn't bother, 'cos that's nowhere near as interesting as learning enough about a new and funky algorithm to reimplement it
18:14:38 <lament> That should be in the FAQ.
18:14:48 <lament> "Yes. Haskell can do it. Use FFI."
18:15:25 <ivanm> lament: not always true...
18:15:49 <ivanm> Q: "In language Foo, you can implement functionality Bar.  Can Haskell do the same?"
18:16:08 <ivanm> A: "Yes, but why bother? Just steal Foo's Bar, and wrap it in an FFI call."
18:16:14 <mauke> yes, it can implement Bar in Foo. then use the FFI to call it
18:16:21 <monochrom> A: "No, FFI does not mean Foo Function Interface. It has to be C, not Foo."
18:16:41 <lament> Foo Functions!
18:16:58 <ivanm> monochrom: heh
18:17:01 <ivanm> true
18:17:07 <TomM2> mauke: But you might not always want to do that... things like TLS can screw you up.  Also, if it does any sort of IO then you best make sure your 'function' reflects that.
18:17:12 <sorear> monochrom: No, it's Foo Functions.  GHC only implements C, and that's a grievous bug
18:17:14 <ivanm> though I thought you could use the FFI for any language? or is it only for C functions?
18:17:37 <ivanm> what about, for example, Fortran functions, like in LAPACK?
18:17:37 <sorear> ivanm: any language, but GHC doesn't support others :(
18:17:45 <sorear> ivanm: sure, you can do that
18:17:45 <lament> let's log a bug for every language GHC doesn't support
18:17:51 <ivanm> sorear: ahhh..... implementation problem then? :p
18:18:03 <monochrom> I only see the FFI Report mention C, Java, Pascal.
18:18:12 <scook0> if your foreign language can export with C linkage, you might get away with it
18:18:44 <ivanm> lament: map (\ lang -> create_bug ("GHC should support language " ++ (show lang))) [machine_code...]
18:18:58 <lament> at least FFI supports brainfuck
18:19:01 <ivanm> lol
18:19:04 <scook0> (e.g. you can bind to extern "C" C++ code, even though GHC doesn't support C++ FFI)
18:19:10 <idnar> writing, say, a Python FFI, would probably be fairly tricky
18:19:15 <lament> brainfuck doesn't have any function, so there's nothing to interface, therefore it already works!
18:19:30 <lament> *functions, although function is always true.
18:19:43 <lament> s/always/also and i just can't type.
18:19:54 <dropdrive> idnar: By Python FFI, do you mean calling Haskell from Python?
18:20:01 <monochrom> IMO "any function" is more correct than "any functions".
18:20:02 <idnar> dropdrive: calling Python from Haskell
18:20:11 <scook0> idnar: you might get pretty far by creating bindings for PyObject* functionality
18:20:14 <idnar> that could have been worded better, I guess
18:20:31 <idnar> scook0: hmm, I guess binding to the Python C API would be pretty nice, actually
18:20:43 <lament> monochrom: that's arguable. While the fact that Brainfuck has no functions isn't.
18:21:05 <monochrom> I also think "no function" is more correct than "no functions".
18:22:03 * lament contemplates vehemently arguing the usefulness of brainfuck
18:23:52 <calvins> monochrom: so you think "he doesn't own any car" is more correct than "...cars"?
18:24:00 <monochrom> Right.
18:24:14 <calvins> are you a native English speaker, because that sounds very wrong to me?
18:24:35 <monochrom> I learned that from some other native English speakers.
18:24:42 <shapr> I think both are correct, but I'd say "He doesn't own any cars."
18:24:42 <dylan> "any car" sounds right to me.
18:24:45 <calvins> i'm pretty sure that's wrong
18:24:50 <idnar> the plural is more commonly used in conjunction with zero, but I'm not sure if using the singular is incorrect per se
18:24:51 <calvins> "she doesn't have any pencils"
18:24:56 <calvins> she doesn't have any pencil
18:25:01 <calvins> it depends on the type of noun
18:25:04 <idnar> or rather, let me amend that
18:25:07 <calvins> if it's something concrete
18:25:10 <idnar> the plural is more commonly used by native speakers
18:25:20 <calvins> like pencil of function, it would take the plural
18:25:37 <lament> monochrom: "brainfuck has no function" means "brainfuck is useless"
18:25:44 <calvins> if it's an abstract noun like money, then it doesn't have a plural form, so you say money
18:25:46 <lament> monochrom: "brainfuck has no functions" means there're no functions in brainfuck
18:25:51 <mrd> "she doesn't have any pants"
18:25:59 <Thomas2> "he doesn't own a car", no?
18:26:02 <mrd> no singular !
18:26:02 <idnar> calvins: money does have a plural form
18:26:05 <dropdrive> idnar: Just out of curiosity, if I wanted to call Haskell from CPython, would I have to "go through C"?
18:26:17 <idnar> calvins: the reason why you don't use it is that money is measured, not counted
18:26:32 <calvins> idnar: okay, wrong terminology
18:26:46 <calvins> but function is in the same category as pencil and not money
18:26:58 <idnar> dropdrive: I guess in theory you could build a higher-level interface
18:26:59 <calvins> nless monochrom meant it's useless
18:27:07 <Lycurgus> "monies" refers (in English) to various exchange mechanisms, eg. cash, check, gold, etc.
18:27:13 <idnar> dropdrive: that's been done with, say, Java and Python
18:27:31 <idnar> calvins: the question is whether zero is singular or plural
18:27:35 <lament> calvins: the terminology is "countable noun"
18:28:57 <calvins> right, money is an uncountable noun when you use it in the sense of having cash in your pocket
18:29:03 <calvins> function is a countable noun
18:31:09 <Lycurgus> the typical usage of "monies" is as a legelese specifying varying forms that sum to a value assessment for consideration in a contract
18:31:39 <lament> calvins: i have to say that referring to functionality, "has no function" seems more correct.
18:31:47 <dropdrive> idnar: Interesting, thanks!
18:31:59 <calvins_> lament: i agree if that's what you mean
18:32:10 <lament> also "has no car"
18:32:15 * idnar digs through wikipedia
18:32:16 <calvins_> i thought he meant that it the language lacks functions
18:32:30 <lament> "has no car" but "doesn't have any cars"
18:32:32 <idnar> "Languages having only a singular and plural form may still differ in their treatment of zero. For example, in English, German, Dutch, Italian, Spanish and Portuguese, the plural form is used for zero or more than one, and the singular for one thing only."
18:32:46 <idnar> unfortunately it doesn't expand on that at all
18:34:56 <calvins_> lambdabot: yeah, interesting observation that it is singular for 'has no car' vs 'doesn't have a car' vs 'doesn't have any siblings'
18:35:16 <calvins_> oops, i meant lament
18:35:18 <calvins_> no lambdabot
18:35:30 <idnar> I think that's because "has a car" can be used in two different ways
18:35:56 <calvins_> "she has no car" sounds to me like the context is understood...
18:36:01 <calvins_> that we are talking about cars
18:36:11 <calvins_> and we are answering the question "does she have a car?"
18:36:15 <calvins_> or something like that
18:36:20 <idnar> there's the sense of possessing an object with wheels, and there's the sense of having a means of vehicular transportation
18:36:45 <idnar> although, I guess that's not really it
18:36:50 <calvins_> yeah, i wasn't even thinking of the second sense in this case
18:37:10 <idnar> for some reason, "I have no sibling" sounds more wrong than "I have no car" or "I have no pencil"
18:37:22 <calvins_> yeah, to me too
18:37:25 <idnar> but I'm not sure why
18:37:46 <calvins_> it could be that way because of prototypical usage
18:37:58 <calvins_> that we seldom here sibling as a single word
18:38:07 <calvins_> and so it sounds off when we do
18:38:20 <calvins_> i can't see any grammatical difference
18:38:44 <idnar> "I have a sibling who works at Microsoft" seems fine though, so I'm not sure that's it
18:39:07 <calvins_> yeah, you're right
18:39:29 <idnar> maybe it does have something to do with "attribute form" vs. "belongings form"
18:39:31 <mauke> siblings aren't idempotent
18:39:38 <idnar> for example, you say "I have no home", not "I have no homes"
18:39:47 <mauke> cars and pencils are, more or less
18:39:59 <calvins_> well, if you were directly asked, do you have a sibling, then it would sound more okay to say, I have no sibling.
18:40:21 <calvins_> but most of the time, you'd be asked, do you have (any) siblings?
18:40:30 <idnar> calvins: I'd probably answer: No, I don't [have a sibling]
18:40:50 <Lycurgus> idnar: are you a native speaker of English?
18:40:54 <calvins_> hm, i wouldn't. i'd just say "no", "no, i don't".
18:40:57 <idnar> Lycurgus: yes
18:41:06 <calvins_> where are you from, idnar?
18:41:15 <calvins_> which english?
18:41:18 <idnar> calvins: well, I bracketed the last bit because I probably wouldn't say it, but it's essentially implied
18:41:20 <calvins_> there are so many
18:41:51 <idnar> I'm from South Africa; my English is probably more British than American (I tend to favour British spelling, for example)
18:42:02 <calvins_> if you were asked in the plural, surely the plural would be implied if you didn't state it?
18:43:10 <Lycurgus> English is comparatively uniform.
18:43:29 <calvins_> my english is mostly american, but i was born and grew up in england until 12, so sometimes there are non-americanisms that creep into my speech
18:43:40 <idnar> calvins: sure
18:44:03 <calvins_> Lycurgus: that's not so at all. There is great diversity, assuming we're talking about spoken rather than formal, written language.
18:44:16 <idnar> calvins: what I mean is, the exchange "Do you have a sibling?"  "No, I don't [have a sibling]" seems natural. "I have no sibling" would seem less natural as a reply to that question
18:44:42 <idnar> calvins: if someone I knew replied in that fashion, I would probably assume they were making a reference to the movie "The Princess Bride" ;)
18:45:15 <Lycurgus> yes I meant to exclude speech differences. Even there though the uniformity is greater than any other language with comparable numbers. The fact that I can't understand teh dialog ...
18:45:28 <Lycurgus> .. on Eastenders not withstanding.
18:45:54 <idnar> (there's a fairly famous quote from one of the scenes that goes something like: "Give us the gate key."   "I have no gate key."   "Fezzik, tear his arms off.   "Oh you mean *this* gate key!")
18:48:26 <Lycurgus> idnar: you would agree that American and British English are closer than Afrikanns and Nederlands?
18:48:43 <monochrom> hahaha
18:49:18 <gvdm> they are
18:49:39 <gvdm> (2 cents)
18:49:39 <lament> afrikaans is a separate language, so i'm not sure why you're even asking this.
18:50:01 <gvdm> hey, I can understand people (somewhat) speaking dutch
18:50:08 <gvdm> just not very well at all
18:50:24 <gvdm> (afrikaans is mother tongue)
18:50:31 <shapr> Afrikaans is very close to Dutch in my opinion.
18:50:42 <idnar> Lycurgus: certainly
18:50:48 <Lycurgus> you probably could if you listened to Radion Nederlands for a few days
18:50:51 <gvdm> except for the bits of english, french and malay it has
18:51:14 <gvdm> oh, and some indonesian (I think)
18:51:16 <joed> gvdm: Is there not like about a century of disparate evolution as well?
18:51:22 <gvdm> yep
18:51:33 <lament> it is considered a separate language by everybody. Whereas American and British English are considered separate only by a few fringe linguists
18:51:35 <gvdm> more
18:51:44 <idnar> my knowledge of Afrikaans helps my understanding of German almost as much as it helps my understanding of Dutch
18:51:45 <gvdm> (than a century)
18:51:59 <gvdm> and I would agree that dutch and afrikaans are separate languages
18:52:11 <joed> gvdm: What I thought, I discussed this the other night with friends from Johannesburg.
18:52:12 <calvins_> lament: American and British English are separate *dialects*
18:52:22 <idnar> (I speak Afrikaans reasonably well, German and Dutch not at all, although I can make out some words here and there)
18:53:05 <gvdm> I have german grandmother as well (not that I really ever speak to her in german, did do german for a few years of school, then promptly forgot it all)
18:53:24 <Lycurgus> yes, but if Afrikaans was your first language I think it would be different
18:53:34 <gvdm> but language decays if you don't use it, and I've been mainly speaking english for over the last decade
18:53:52 <lament> of course there's the problem - as soon as dialects become sufficiently different, they're now called separate languages :)
18:53:59 <shapr> I learned a bit of Dutch over ten years ago, but that and learning Swedish means I can understand Afrikaans passably well.
18:54:02 <calvins_> dialect<-->language is a spectrum though
18:54:59 <calvins_> lament: yeah, that's what i meant, i have loads of lag over the network today
18:55:16 <joed> shapr: I'm Swedish and lived in Germany for 7 years, I have a lot of south african expat friends, being fluent in both does not really help me with more than simple phrases.
18:55:43 <gvdm> its good for vocab, you can better *guess* at the meaning of words
18:56:06 <gvdm> like knowing latin will help you guess at lots meanings of words
18:56:11 <calvins_> Most Americans, for example, will not be able to understand somebody from Glasgow, only a few words here and there...
18:56:27 <joed> Right, but trying to read a paper is easier than following conversation.
18:56:43 <shapr> joed: Weird, I was able to understand the Afrikaans I heard on the plane.
18:56:52 <ivanm> @src foldr
18:56:52 <lambdabot> foldr k z xs = go xs
18:56:52 <lambdabot>     where go []     = z
18:56:52 <lambdabot>           go (y:ys) = y `k` go ys
18:57:01 <joed> shapr: I may be much dumber :)
18:57:05 <ivanm> ^^ why is this defined using a helper function rather than directly?
18:57:11 <ivanm> is there a practical difference?
18:57:16 <ddarius> ivanm: To spite you.
18:57:19 <ivanm> lol
18:57:28 <shapr> joed: I haven't seen any dumb people hang around for long on #haskell ;-)
18:57:33 <idnar> well, there are parts of Afrikaans and Dutch that are pretty similar, I guess
18:57:37 <ddarius> ivanm: It's the worker/wrapper transform.  But semantically, there is no difference.
18:57:44 <idnar> what gets really confusing is when the same word is used with completely different meanings
18:57:48 * shapr hugs ddarius 
18:57:48 <joed> shapr: :*
18:57:51 <ivanm> ddarius: *nod*... just that normally you see fold defined directly, so that threw me for a bit
18:57:52 <ddarius> Gift
18:57:58 <shapr> ddarius: Hey, I lost your number...
18:58:02 <shapr> I wanted to call you recently.
18:58:04 <ddarius> shapr: What?!
18:58:12 <idnar> unsafePerformPhoneCall
18:58:16 <shapr> I know, it was silly :-(
18:58:17 <calvins_> idnar: yeah, when i first moved to america, people laughed when in school i asked for a rubber
18:58:27 <ddarius> My phone broke and I replaced it and I still have your number.
18:58:30 <idnar> calvins_: haha
18:58:37 <allbery_m> call him what?  *badumcrash*
18:58:37 <gvdm> england is pretty extreme, they have a massive amount of variation in the language, severely different dialects over quite small geographical distances
18:58:37 <gvdm> I've been told that if you've lived in england you can tell where someone comes from by how they speak
18:58:38 <shapr> Oh, you have a new number?
18:58:43 <ivanm> calvins_: lol... silly yanks
18:58:51 <ddarius> shapr: No.
18:59:01 <ivanm> gvdm: and how does that differ from, say, China?
18:59:18 <idnar> calvins_: for a long time here, the usual term for a so-called 3.5" floppy disk was a "stiffy disk" or a "stiffy"
18:59:19 <gvdm> ivanm: I know nothing about language variation in china
18:59:19 <lament> very easy, they don't speak English in China
18:59:26 <ivanm> heh
18:59:41 <calvins_> idnar: haha, that sounds funny to my american ears
19:00:11 <ivanm> gvdm: apparently in China, you need one translator who does Mandarin <-> English, another who does Mandarin <-> regional dialect and a third who does regional dialect <-> local dialect
19:00:14 <gvdm> the contrast I was making was more with countries like the US, austrialia, NZ, etc, these countries have much less variation in their language
19:00:22 <Freed> Now i get: setup: ghc version >=6.2 is required but the version of /usr/local/bin/ghc could not be determined.           while i am executing ./setup configure
19:00:36 <calvins_> yeah, some of the chinese dialects are mutually unintelligible
19:00:37 <ivanm> gvdm: I disagree to an extent
19:00:40 <idnar> (a 5.25" disk is actually floppy, a 3.5" one doesn't flop around, so it's a stiffy, naturally! personally I always thought the term was stupid, even aside from unintended connotations)
19:00:40 <gvdm> countries like china and england have a lot more history and *local* culture
19:00:47 <lament> ivanm: or you could just have a local dialect->English translator instead.
19:00:50 <ivanm> since there's always geographical variation
19:00:54 <ivanm> lament: much harder to get
19:01:02 <ivanm> especially in small country towns, etc.
19:01:30 <lament> http://en.wikipedia.org/wiki/Regional_accents_of_English_speakers
19:01:32 <lambdabot> Title: Regional accents of English - Wikipedia, the free encyclopedia
19:01:33 <dylan> there's not a shortage of communities that have weird dialects, or entirely different languages, in north america...
19:03:06 <idnar> I find it amusing that most Americans say my accent sounds British, and most people from the UK say that it sounds American
19:03:41 <shapr> My siblings (we're all from Alabama) say I sound Finnish.
19:04:07 <idnar> I was born and grew up in Zimbabwe around quite a few US expats, so my accent used to have an American twist to it, but I think that's mostly long since vanished
19:04:14 <ivanm> people say my accent sounds Aussie :p
19:04:20 <ddarius> shapr: They know what Fins sound like?
19:04:41 <calvins> idnar: most Americans are not very good at distinguishing between accents, and British tends to be the default bin for anything that's not American-sounding
19:04:53 <idnar> calvins: indeed
19:05:03 <shapr> ddarius: They heard some Finns on the news, and they said I sound like that.
19:05:15 <idnar> more problematically, most Americans seem to have a hard time understanding my accent, especially when I talk fast as I tend to do
19:05:26 <shapr> idnar: Give me your number, I'll tell you what I think :-)
19:05:52 <idnar> heh
19:06:26 <sorear> shapr: well you DID spend N years in NE europe
19:06:39 <shapr> sorear: Yeah, true. I learned to speak "Internation English" there.
19:06:44 <calvins> there's the beer I sometimes drink from Anderson Valley, in California. They apparently have a pretty strange dialect that is used in combination with English: http://www.avbc.com/visit/jonnem.html
19:06:46 <lambdabot> Title: Boontling - Anderson Valley's Unique Lingo
19:07:19 <calvins_> though i still am not convinced that they didn't just make it all up as a tourist attraction
19:08:06 <ddarius> "Come listen to the funny talking people"
19:08:07 <idnar> it's funny how some people change their accent, and others don't; a friend of mine (along with his family) moved to Australia several years ago, and he still sounds exactly the same as he did before he moved, but his (older) sister now sounds like she was born and bred in Australia
19:08:27 <calvins_> idnar: it makes a huge difference how old you are when you move
19:08:39 <TSC> Crikey!
19:08:51 <dylan> australians are fun. A friend of mine spent a few days here, and my wife and I picked up the accent for the follwoing week...
19:08:51 <idnar> calvins_: I would have expected a younger person to be affected more than an older person, though
19:08:57 <calvins_> my brother was 10, and I was 12, when we moved, and he lost his very quickly, while mine was much slower to change
19:09:19 <idnar> then again, I guess some people adapt their accent depending on who they talk to
19:09:23 <calvins_> yeah, i have 3 cousins who moved out here, and they followed the same pattern
19:09:51 <idnar> oh well, I should get some sleep before the sun rises again
19:10:02 <calvins_> goodnight
19:10:29 <gwern> now this is interesting. I've built and installed cabal-install, so why when I go '~/bin/bin/cabal fetch regex-base' does it error with cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
19:10:49 <shapr> idnar: Yeah, I moved all around the USA for my first sixteen years, and I learned to change accents to match my conversation partner.
19:10:57 <shapr> idnar: But that irritates Aussies sometimes :-)
19:11:19 <blackdog>  shapr: only because your aussie accent is atrocious :)
19:11:31 * shapr throws a dropbear at blackdog 
19:11:45 <TSC> Did it help with the sheilas?
19:11:49 <ddarius> I haven't had to deal with it too much, but I doubt I'd change my accent to match people.  I talk somewhat odd even to people who share my accent.
19:12:18 <shapr> In my opinion, accent changing is just a part of fitting what you have to say to your audience.
19:12:35 <calvins_> shapr: if you can do it well, that's an awesome skill to have
19:12:59 <idnar> so what do two accent-changers do when they talk to each other?
19:13:04 <shapr> Specific cases are: 'don't talk about lambda calculus to your girlfriend, sibling, etc' and 'when people ask how technical devices work, don't tell them, they don't really want to know'
19:13:13 * ddarius has a somewhat different accent when speaking foreign languages though.
19:13:14 <dylan> idnar: it's very very annoying.
19:13:29 <Olathe> It would have been much more convincing to them if you called all the men Bruce.
19:13:47 <ddarius> idnar: iterate until they reach a fixpoint
19:13:51 <shapr> ddarius: yeah!
19:13:53 <idnar> something that seems obvious to me, but a lot of people seem to find weird, is that I shift my accent when pronouncing a word or name from a different language
19:14:00 <shapr> idnar: Oh, me too!
19:15:03 <shapr> idnar: But there's a lot of cool stuff related to that. I dated a German girl a decade ago who learned about Geology here in the USA. When she moved back to Germany, she translated all of her German Geology notes into English to study them. On the other hand, she learned Math in German, so she translated all of her English math stuff into German to study it.
19:15:22 <idnar> haha, crazy
19:15:26 <joed> For you with accents that read a lot, how often do you wrongly pronounce words you commonly see in writing that seldom are used in every day language?
19:15:36 <shapr> On a related note, the fastest way to read text is to completely bypass mental pronunciation.
19:15:51 <sw17ch> how does one do that?
19:15:54 <ddarius> shapr: Indeed, but I find that very unsatisfying.
19:15:59 <joed> My wife hates me doing it, as she is an english major.
19:16:04 <ddarius> sw17ch: Read paragraphs/pages at a time.
19:16:05 <omnId> joed: like "monad" for instnace? :)
19:16:15 <idnar> I never learned to read using mental pronunciation
19:16:16 <shapr> ddarius: I've always read that way, I find that doing anything verbal related while reading really slows me down.
19:16:24 <joed> omnId: Hah
19:16:27 <shapr> ddarius: Of course, that led to a weird discussion with Heffalump once..
19:16:32 <idnar> if I have to do it that way for some reason, I find it very awkward and unnatural
19:16:45 <ddarius> shapr: I agree that it really slows one down, but I personally find it unenjoyable.
19:16:51 <shapr> Well, do what you like :-)
19:17:01 <ddarius> I do.
19:17:12 <idnar> when it comes to "informational" text, I tend to skip rapidly, jumping back as necessary to fill in things I miss
19:17:42 <idnar> and for "story" type text (novels or whatever), I'm not really consciously aware of the text once I get into it, I'm mentally focused on imagining the story
19:18:16 <ddarius> Yay cerebral cortex
19:18:21 <calvins_> I just read somewhere recently that Kleene, as in "Kleene star" is supposed to be pronounced as clay-knee. I've never heard it but have only read it, so i always heard it as 'clean'.
19:18:33 <idnar> as far as pronunciation goes, I seem to have a talent for correctly determining the pronunciation of words I've never seen before
19:18:41 <omnId> @remember ddarius Yay cerebral cortex
19:18:42 <lambdabot> Good to know.
19:18:51 <idnar> although that only goes for the languages I'm reasonably familiar with
19:18:58 <calvins_> anybody else heard clay-knee as the pronunciation of Kleene?
19:19:20 <ddarius> idnar: Same here.
19:19:28 <joed> I'm reasonably familiar with english, but seem to have a knack for saying some weird shit.
19:19:32 <ddarius> Except for French which I refuse to pronounce correctly.
19:19:34 <lucca> i've heard clah-knee
19:19:40 <idnar> calvins_: Wikipedia says "Kleene pronounced his last name IPA: /ˈkleɪni/. /ˈkliːni/ and /ˈkliːn/ are common mispronunciations."
19:20:26 * ddarius decides to still say "clean"
19:20:47 <idnar> heh
19:23:07 * omnId flings a schwa at ddarius
19:23:27 <gvdm> hmm, in my formal methods course it was pronounced clean-nie
19:24:04 <gvdm> wait, according to those IPA symbols I mayb be right
19:24:20 <gvdm> hmm, how much of that bit of LING211 can I remember...
19:24:28 <idnar> clean-nie is /ˈkliːni/, I believe
19:24:54 <gvdm> yes, but having that second syllable was the bit I was thinking about
19:25:11 <gvdm> as opposed to 'clean', one syllable
19:25:17 <idnar> ah
19:26:11 <gvdm> despite messing up the vowels a bit more (because as english speakers, shifting the vowels is less damaging to the understandability of a word than changing consonants)
19:27:18 <joed> gvdm: The terminator effect?
19:27:34 * gwern growls. goddamn hackage version of regex-posix - doesn't declare dependences in .cabal, uses outdated bytestring module names...
19:27:38 <gvdm> whatever, I can just remember something like that from my ling course
19:28:57 <gwern> oh, that's just great. where the hell did Data.ByteString.Base's unsafeUseAsCString go?
19:31:04 <TSC> Data.ByteString.Unsafe ?
19:32:01 <gwern> no idea. I've decided to avoid hackage for now and start installing stuff out of their darcs repos
19:33:42 <gwern> even darcs regex-posix has the packages problems! ghc 6.8.1 giveth and taketh away...
19:38:32 <ivanm> I tried looking up "define:fusion" in google in the hope of finding the FP definition... wikipedia threw up a whole heap of results, none of which were what I'd consider the "default" definition, i.e. atomic fusion :s
19:39:26 <Korollary> the default should be gilette fusion. Five blades, dude.
19:39:44 <gwern> ivanm: afraid the closest you'll get to FP fusion is [[loop fusion]]
19:39:54 <ivanm> *nod*
19:40:00 <ddarius> Gilette has never been able to best its own Mach 3
19:40:24 <Raguel> anyone know any good philosophy channels btw?
19:40:36 <monochrom> #haskell-blah :)
19:40:44 <Raguel> #haskell-blah
19:40:50 <Raguel> erm that meant to say /join
19:40:53 <Korollary> but, what is a "channel"?
19:41:01 <ivanm> gwern: even on haskell.org, the closest I can find is "correctness of short cut fusion" :s
19:41:10 <ivanm> Korollary: you're in one right now! :p
19:41:22 <monochrom> "what is a channel" is harder to answer than "what is a monad" or "what is Num"...
19:41:40 <gwern> ivanm: look for the ByteString papers; I think they do a lot of fusion
19:41:50 <ivanm> *nod*
19:43:21 <sjanssen> ivanm: fusion is the process of eliminating an intermediate data structure by merging data production and data consumption
19:43:35 <ivanm> sjanssen: *nod*
20:17:07 <ac_> @seen thoughtpolice
20:17:07 <lambdabot> thoughtpolice is in #perl6 and #haskell. I last heard thoughtpolice speak 3h 4m 31s ago.
20:22:35 <thoughtpolice> ac: you called?
20:23:41 <ac> yeah, I have kind of a nebulous question
20:23:56 <Pseudonym> ac: The answer is mu.  Hope this helps!
20:23:57 <mrd> a collection of dust and gas?
20:24:18 <ac> thoughtpolice: I'm wondering how it would be possible to load several plugins that all depend on another plugin
20:25:06 <thoughtpolice> ac: load-time dependency checks?
20:25:28 <ac> thoughtpolice: Say you have 3 plugins a, b, and c that all depend on foo. Would each a, b, and c use hsplugins to load foo?
20:26:24 <thoughtpolice> ac: like in my bot? all plugins found in Plugins/ are loaded on startup and on a reboot
20:26:50 <thoughtpolice> (a 'plugin' is basically any file ending with .hs in that dir, as far as my loader is concerned)
20:27:04 <ac> but what if two of the plugins in the Plugin directory depended on a third one in there?
20:27:47 <ac> I guess that's a silly question. You could just create a module and import it from the plugins
20:27:53 <thoughtpolice> yeah
20:27:56 <ac> and the dependency resolver will load it
20:29:03 <thoughtpolice> now if they aren't imported but you still depend on it, at that point you could probably put a 'dependencies' field inside your plugin datatype which specifies which plugins it needs, and if it isn't present, just unload the module
20:29:31 <thoughtpolice> but for the most part if you just use imports it should be fine; the rts' linker will resolve everything just fine.
20:30:13 <ac> I don't understand that second-to-last statement
20:31:24 <ac> are you saying how you could create code that would behave differently if a certain module was present?
20:31:43 <ac> er, I mean, a plugin that would behave differently if another plugin was present? That would just be a subplugin...
20:33:01 <thoughtpolice> ac: no, just how you could create a form of inter-plugin dependencies, so if a plugin isn't there or it fails to load properly, it won't be loaded either
20:33:39 <ac> why not just make that dependency a module, and have both plugins import it?
20:33:50 <thoughtpolice> you can go about it whatever way you want
20:34:36 <ac> I guess that way might not be the best, because you'd have to package the module with both plugins (if it's a product, with separately distributed plugins)
20:34:50 <ac> nevermind. I'm making no sense
20:35:08 <thoughtpolice> nah, I get what you're saying and it's a good question. in my case, if a plugin works and offers some functionality, I just add it to the repo :)
20:35:24 <thoughtpolice> because in my bots case, it's functionality is severely lacking in case you couldn't tell
20:35:42 <ac> thoughtpolice: I haven't compiled it yet, I'm just reading the source :P
20:36:16 <thoughtpolice> ac: i know there're corner cases in 0.3 i didn't quite cover or take into account; the plugin timeout thing you mentioned yesterday is a good example.
20:36:43 <thoughtpolice> aside from me, i doubt anybody else has really looked at the code, so I haven't had many outside comments
20:36:47 <thoughtpolice> so all are appreciated.
20:36:58 <ac> thoughtpolice: I think I'm actually going to implement this, because I want to set up a bot for a channel where several people might be adding plugins of suspect quality
20:37:20 <ac> thoughtpolice: (the timeout thing that is)
20:37:49 <thoughtpolice> once I get the ability to continue development on ghc 6.8 I'll probably start working on an 0.4 release which I have some ideas for
20:38:10 <thoughtpolice> namely take advantage of more robust idioms, tests, a better plugin interface, etc. etc..
20:38:16 <thoughtpolice> so please, keep giving me ideas. :)
20:39:01 <TomM2> > ping undefined
20:39:03 <lambdabot>  "pong"
20:39:17 <chessguy> what the...
20:39:20 <chessguy> > ping
20:39:21 <lambdabot>  Add a type signature
20:39:27 <chessguy> @type ping
20:39:28 <lambdabot> Not in scope: `ping'
20:39:31 <chessguy> ...
20:39:35 <shachaf> @undefine
20:39:37 <lambdabot> Undefined.
20:39:40 <chessguy> > ping
20:39:43 <lambdabot>   Not in scope: `ping'
20:39:46 <chessguy> ah
20:39:59 <shachaf> @let on f g x y = g x `f` g y
20:39:59 <ac> > ping undefined
20:40:01 <lambdabot> Defined.
20:40:02 <lambdabot>   Not in scope: `ping'
20:40:17 <shachaf> @let s x y z = x z (y z); k x _ = x; i x = x
20:40:19 <lambdabot> Defined.
20:40:26 <thoughtpolice> ac: also if you want to submit any patches for something like timeout functionality, i'll accept them.
20:41:21 <thoughtpolice> because like I said, I don't have 6.6 anymore, so I can't exactly test these things or addon for right now. your word that it works is good enough to make it in. :)
20:41:40 <dons> thoughtpolice: is your goal to have a lambdabot replacement, btw?
20:41:50 <dons> and do you want to port lambdabot plugins across... :)
20:41:54 <ac> thoughtpolice: No, it's far, far more sillier
20:41:58 <dons> or just hack on lambdabot :)
20:42:19 <thoughtpolice> dons: no, just something fun to hack on
20:42:30 <thoughtpolice> besides, I never actually wrote an IRC bot so I figure it'd be something I could have fun with
20:42:33 <thoughtpolice> :)
20:42:45 <ac> I'm not sure what kind of functionality lambdabot has, and what I want is simple enough that I think hacking it together will be faster than figuring out lambdabot. Plus I'll learn a little bit
20:42:47 <dons> ah well
20:43:01 <joed> Heh
20:43:18 <dons> oh, if you want haskell-ish plugins, grabbing them from lambdabot will save 6 months work
20:43:29 <ac> is it really that hard?
20:43:40 <joed> Yes/No/Maybe
20:43:45 <thoughtpolice> lambdabot's easily built a lot better than my little baby is. if it gets any substantial or worthwile functionality though we'll have to set up a gladiator match between the two.
20:43:52 <dons> ac, oh, the functionality in all the extensions is a lot of work
20:43:56 <dons> most of a haskell IDE is in there
20:44:31 <ac> dons: I have no intention of being able to interpret haskell comands
20:44:49 <ac> dons: like '>', "@type", etc
20:44:51 <dons> ac, i was more addressing my comments at thoughtpolice though, since i know he has some big bot underway :)
20:44:58 <thoughtpolice> but I expect that won't happen until I keep working on it and get it to the point where it's not hacked together for the most part.
20:44:59 <dons> ac, btw, have you read the irc bot tutorial?
20:45:11 <ac> dons: it's on my list
20:45:14 <dons> ah :)
20:45:18 <dons> its rather nice, imo :)
20:45:40 <thoughtpolice> also, yes, the idea was to rip lambdabot's commands if I ever got the time. i should also mention the 0.1 version of my bot took a lot of ideas from your tutorial, dons. there's even a shoutout in there iirc.
20:45:44 <chessguy> yeah right dons, i bet you haven't even read it
20:45:47 <ac> does it devote some time to working with plugins?
20:45:47 <thoughtpolice> so dons++
20:45:48 <thoughtpolice> :)
20:45:53 <dons> is it just me, or does it annoy anyone else when politicians describe trivial arguments as "merely playing semantics" :)
20:45:58 <joed> Some smart guy wrote that right?
20:46:06 <chessguy> joed, very smart
20:46:10 <dibblego> politicians or any kind of intellectual fraudsters?
20:46:14 <dons> dibblego: :)
20:46:19 <joed> chessguy:  What I thought.
20:46:20 <dibblego> ;)
20:46:22 <dons> don't play semantics, dibblego
20:46:32 <Pseudonym> Unless they're formal semantics.
20:46:53 <Korollary> I am usually annoyed by the word semantics
20:47:05 <Pseudonym> In what sense do you mean "semantics"?
20:47:07 <dons> value semantics, that's what we're missing
20:47:20 <Korollary> oh yeah. Value semantics is my favorite phrase nowadays.
20:47:21 <dons> values, and their semantics, will be at the core of my platform
20:47:27 <chessguy> i used to play semantics when i was in high school. even took lessons for a while. but then when i got to college, i stopped practicing and got rusty. now, i haven't picked up a semantic in years
20:47:32 <ac> dons: my current idea (which may be how thoughtpolice's and lambdabot is implemented) is to have a static core that loads a module that connects to the irc server. This module then loads all the rest of the bot's plugins
20:47:34 <Korollary> I value semantics and children.
20:48:02 <Pseudonym> I might run on a Semantic Values platform.
20:48:02 <ac> so it should be possible to update the behaviour of the part that connects to irc, without it losing a connection
20:48:06 <Spark> but i only eat children
20:48:41 <chessguy> Spark, now there's a campaign promise that nobody will hold you to!
20:48:42 <Korollary> I resent this anti-semantic allegations.
20:48:47 <thoughtpolice> ac: yeah that's the approach my bot takes. i load plugins before forking threads, so when a reboot occurs aside from the main dynamic app, new plugins are loaded too.
20:48:59 <Spark> chessguy: there's always one
20:49:03 <monochrom> "you're playing with semantics" is playing with semantics.
20:49:16 <ac> thoughtpolice: so the part that hands commands off to plugins can be updated while the bot stays in the channel?
20:49:19 <chessguy> on that note...
20:49:34 <dons> ac, yep, that's exactly how lambdabot works
20:49:45 <dons> check the paper 'dynamic applications from the ground up'
20:49:46 <ac> well cool, looks like I have plenty of code to work wtith
20:49:51 <ac> dons: I already read that
20:49:52 <joed> dons, hard to be a dad ehe.
20:49:59 <ac> dons: otherwise I wouldn't have had that idea
20:50:02 <dons> ah :)
20:50:15 <ac> dons: I read your other hsplugins paper too
20:50:17 <thoughtpolice> ac: yep
20:50:26 <thoughtpolice> ac: the only part of my bot that can't be upgraded at runtime is the code in Main.hs
20:50:32 <thoughtpolice> everything else can be changed whenever it's online
20:51:13 <thoughtpolice> generally before reloading code I always run 'ghci -fglasgow-exts IMain.hs' to make sure everything fits together.
20:51:47 <Korollary> you could put that in your .ghcrc iirc
20:52:35 <dons> you can do the core too, by serialising the state and feeding it in to a reforked core. but its rarely worth it. just stick the dynamic loader in the static core
20:52:53 <thoughtpolice> yeah
20:53:04 <thoughtpolice> i haven't had to change Main.hs much since I first put it in the repository
20:53:17 <thoughtpolice> maybe like, two changes?
20:53:51 <dons> :)
20:53:53 <ac> thoughtpolice: ok, so now I have to ask how does your code differ from lambdabot? I imagine yours will be easier to use because it's smaller
20:54:14 <thoughtpolice> ac: notably it isn't written by haskell gurus.
20:54:21 <thoughtpolice> that's the major thing that comes to mind. ;)
20:54:21 <dons> lambdabot's not either :)
20:54:24 <Trinithis> @seen pjd
20:54:24 <lambdabot> pjd is in #haskell. I last heard pjd speak 5h 7m 3s ago.
20:54:31 <ddarius> thoughtpolice: Only parts of lambdabot are written by Haskell gurus.
20:54:41 <dons> i'm not sure those parts are still there
20:54:53 <dons> there's not a lot of code in there i'd quote, beyond the module system
20:54:54 <Thomas2> isn't that always the way? :-)
20:54:58 <dons> which i think is Pseudonym's work
20:55:04 <thoughtpolice> hah.
20:55:17 <dons> Pseudonym: did you come up with the Plugin class for lifting export lists into the value level?
20:55:23 <ddarius> I don't think Pseudonym did much at all after making the original core.
20:55:25 <dons> sorry Module class
20:55:26 <thoughtpolice> well, i guess to put it another way, mine is probably a little less sophisticated.
20:55:28 <Trinithis> I have a simple question: is the ' in foldr' pronounced prime or what?
20:55:33 <dons> maybe that was Heffalump ?
20:55:40 <dons> i know he's to blame for the monad stack
20:55:43 <ac> is there documentation for lambdabot's source?
20:55:51 <dons> ddarius: you wrote the big lambda evaluator, iirc?
20:55:53 <TSC> Trinithis: I think most people would call it 'prime'
20:55:56 <Pseudonym> The module system has been pretty much gutted, too.
20:55:57 <ddarius> dons: Yes.
20:55:59 <dons> ac, nope. it was written in a time before language
20:56:10 <Trinithis> tsc: ok
20:56:15 * ddarius has no idea what the insides of lambdabot look like now.
20:56:15 <thoughtpolice> when there was only haskell?
20:56:22 <dons> right
20:56:24 <Pseudonym> I _think_ the only thing left of mine is some of the IRC monad stuff, and maybe the protocol parser stuff.
20:56:26 <dons> before the dawn of time
20:56:31 <ddarius> I think it has been completely changed twice since I last really looked.
20:56:34 <dons> there was only referential transparency
20:56:45 <ddarius> Then something changed.
20:56:53 <thoughtpolice> then the RealWorld happened
20:56:54 <dons> then the devil shot the arrow of time, leading to imperative programming
20:56:58 <dons> and the world was corrupted
20:57:40 <dibblego> I received an award from work last year for invalidating imperative programming using astrophysics
20:57:43 <thoughtpolice> ac: anyway, for the most part I couldn't tell you since i haven't looked too far into lambdabot's guts. i would imagine most of the functionality (i.e. plugins) could be replicated pretty easily though...
20:57:46 <dons> dibblego: :)
20:57:49 <Trinithis> dons: and then waht?
20:57:57 <dibblego> and I referred to the arrow of time too
20:58:01 <thoughtpolice> in terms of insides though, I have no idea.
20:58:11 <dons> the good knights of the order of the lazy lambda have been guarding the true light of purity
20:58:28 <dons> waiting for the time to ride forth, and deliver us from our own corruptoin
20:58:50 <dons> its only a matter of time and cpus
20:59:04 <dons> dibblego: instance Arrow Time where ?
20:59:09 <dons> instance ArrowLoop Time where ... !
20:59:23 <thoughtpolice> dons: tell me, when're you going to get around writing an epic tale about the fight against impurity and injustices in the land of code?
20:59:36 <dons> :)
20:59:57 * ac will be quite happy when cabal-install works with 6.8.1
21:00:19 <ac> lambdabot must not compile with 6.8.1 though, because it uses hsplugins
21:00:33 <thoughtpolice> ac: nope, neither does infinity. :(
21:00:39 <dons> ac, right. you comment out the plugins dep
21:00:46 <Trinithis> How does Lisp compare to Haskell?
21:00:47 <ivanm> does anyone here use those fancy symbol-replacement settings for the listing package in LaTeX listed on the literate programming page?
21:00:58 <thoughtpolice> dons: we can have the mythical shield of quickcheck and the sword of monad. or something catchy like that.
21:01:15 <ddarius> Trinithis: It doesn't.
21:01:20 <Trinithis> lol
21:01:49 <Pseudonym> Lisp isn't a member of Ord.
21:01:51 <Trinithis> Even though I'm very new to Haskell, it's perhaps beginning to become one of my favorites
21:02:24 <shachaf> Pseudonym: Nor is Haskell.
21:02:25 <dons> they're quite different. haskell is a solution to many of the downsides of lisp, in essence
21:02:32 <ac> how in the world does ghc pound my hard drive when I don't have ANY swap mounted?
21:02:36 <ddarius> shachaf: Indeed.
21:02:48 <shachaf> @faq :-)
21:02:49 <lambdabot> The answer is: Yes! Haskell can do that.
21:02:55 <sw17ch> Trinithis: same thing happened for me
21:03:05 <Trinithis> :D
21:03:10 <sw17ch> i spent a few days with it, and was dumbstruck...
21:03:14 <ivanm> Pseudonym, shachaf: surely you mean that the datatype Programming_Language isn't an instance of Ord?
21:03:19 <sw17ch> which soon turned into not quite as dumb... but still very dumb
21:03:20 <Trinithis> Anyone here like ANY imperative language more than Haskell?
21:03:28 <sw17ch> now i'm almost able to use it on larger projects =)
21:03:45 <dons> Trinithis: silly, haskell is the world's finest imperative language :)
21:03:49 <ivanm> :D
21:03:51 <dons> since statements are first class
21:03:58 <dons> and the semi-colon is programmable
21:04:12 <dons> try doing that in Java :)
21:04:20 * bos builds a new fedora 6.8.1 candidate
21:04:26 <shachaf> ivanm: Haskell isn't a type?
21:04:32 <sw17ch> dons: you've made your point... any one who uses any language besides Haskell is wasting their time :P
21:04:44 <Trinithis> dons: ugly anyonymous objects serving as functions....
21:04:50 <ivanm> shachaf: surely Haskell is just a value in the Programming_Language type?
21:04:51 <Pseudonym> Trinithis: I wouldn't say "like", but I find some imperative languages more useful in some circumstances.
21:05:04 <Pseudonym> I hate all languages, I just happen to hate Haskell less.
21:05:10 * ac wishes linux (or SOME OS) would manage resources intelligently, like hardware
21:05:12 <ivanm> sw17ch: anyone who _by choice_ uses any language besides Haskell is wasting their time :p
21:05:14 <dons> sw17ch: the key is the word "like"
21:05:16 <ac> is there a "top" for hard drive usage?
21:05:22 <sw17ch> dons: ;)
21:05:30 <dons> its hard to like first order imperative languages with hard coded state and IO monads
21:05:30 <ivanm> ac: but then development would stop!
21:05:32 <bos> i like three languages pretty well: haskell, c, and python
21:05:34 <sw17ch> i wish i could sqeeze haskell into 32k of memory
21:05:38 <shachaf> ivanm: It could be a type.
21:05:59 <Pseudonym> I must say, I prefer C++ to C.
21:06:03 <ac> ivanm: what do you mean? It drives me nuts when my computer becomes unusable due to disk access. WTF is using it?
21:06:04 <ivanm> shachaf: in that case, you couldn't compare it to any other language since they would be of different types, and you can't compare types
21:06:08 <ddarius> Yay C++
21:06:13 <bos> Pseudonym: you mustn't have used it enough then
21:06:19 <Pseudonym> C or C++>?
21:06:22 <bos> c++
21:06:23 <Pseudonym> I've used them both a lot.
21:06:28 <Trinithis> I like Java more than C++
21:06:29 <shachaf> data Haskell = Haskell. :-) (No, you're right.)
21:06:35 <ivanm> ac: if an OS was fixed so that it used resources intelligently, then all the devs maintaining that OS would be out of a job!
21:06:36 <ivanm> ;-)
21:06:45 <Pseudonym> C++ is essentially C with more stuff.  So at the very least, it's as capable as C.
21:06:48 <Pseudonym> And it's more type-safe.
21:07:00 <bos> c++ is one of those large-system languages where everyone thinks they're working on the same project, but they're not
21:07:04 <shachaf> f >>= a . haskell . c =<< g -- 32k?
21:07:07 <ac> whoa, it was firefox
21:07:13 <Pseudonym> There are only two disadvantages to C++.
21:07:14 <Trinithis> ivanm... use type coercion to comp langs
21:07:19 * ac slaps firefox
21:07:21 <dons> shachaf: :)
21:07:21 <byorgey> just like an accordion is essentially a piano with more stuff.
21:07:22 <Pseudonym> 1. It doesn't work well in really small systems.
21:07:24 <Thomas2> yeah, it's often firefox
21:07:33 <Pseudonym> 2. A lot of people write really, really atrocious C++.
21:07:33 <ac> (where "slap" is killall)
21:07:48 <shubalub> is there good C++?
21:07:52 <Pseudonym> Sure.
21:07:52 <mauke> C++ is not more type-safe. it has implicit pointer conversions.
21:08:00 <ivanm> Trinithis: hmmm??? in that case, comp langs would be a type of types...
21:08:08 <bos> i've never seen good C++ code.
21:08:11 <mauke> its biggest disadvantage (IMO) is its insane complexity
21:08:18 <ivanm> Trinithis: or at the very least a type class...
21:08:19 <Pseudonym> mauke: C++ is more type safe, you can avoid them by avoiding raw pointers.
21:08:20 <byorgey> ivanm: yes, a kind.
21:08:20 <Trinithis> ivanm: cast the laguage types
21:08:29 <Trinithis> ivanm: bad joke....
21:08:32 <bos> the closest approximation is code that heavily uses the STL, and such code ends up just awful.
21:08:34 <ivanm> yes, it was
21:08:41 <mauke> Pseudonym: you can't avoid pointers
21:08:47 <ivanm> @hoogle cast
21:08:48 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
21:08:48 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
21:08:48 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
21:08:57 <ivanm> oh, wait, there is a cast function...
21:08:57 <Pseudonym> mauke: You can localise their use.
21:08:58 <Trinithis> What about C#? I havent learned that baby. Hows that to C++ or java
21:09:08 <ivanm> Trinithis: too OS dependent for my liking
21:09:10 <shubalub> it beats the shit out of C++
21:09:12 <ddarius> C# is better than Java.
21:09:18 <Pseudonym> C# is better than Java, yes.
21:09:24 <mauke> Pseudonym: how do you make data structures without pointers?
21:09:30 <ivanm> ddarius: how much of that is because C# could learn from Java's mistakes?
21:09:34 <shubalub> but (not that I have extensive experience) I have heard that it has gotten really huge lately
21:09:39 <Pseudonym> mauke: I can't believe you just asked that on #haskell.
21:09:45 <ivanm> besides, the intended market is slightly different...
21:09:48 <ddarius> ivanm: Java knew well enough to avoid the mistakes it made.
21:09:50 <newsham> mauke: references?
21:09:53 <Trinithis> C# should be easy to learn if you know Java well, right?
21:09:58 <ivanm> ddarius: heh, true
21:10:05 <ivanm> Trinithis: relatively easy, apparently
21:10:08 <ddarius> Trinithis: More or less.
21:10:16 <Pseudonym> C++ has pointer-like classes which you can use or make your own.
21:10:21 <ddarius> Trinithis: They are very similar, but C# is noticeably better.
21:10:22 <Pseudonym> That you can't do implicit conversions on.
21:10:23 <thoughtpolice> Trinithis: it would probably just mostly be getting used to .net libs, I would think.
21:10:27 <Trinithis> the only thing that kept me from C# was the UpperCamelCase for methods... yuck
21:10:31 <Pseudonym> And they do reference-counting or whatever.
21:10:33 <thoughtpolice> but i'm not a java nor c# expert. :(
21:10:34 <mauke> newsham: references can't be null and C++ has no variant types
21:10:40 <shubalub> they put smart pointers in the language now?
21:10:58 <Pseudonym> BTW, when I say "C++" I implicitly assume you have Boost.
21:11:12 <Pseudonym> Because starting a C++ project today without Boost is a waste of time.
21:11:33 <Trinithis> Pseudonym: what does Boost do?
21:11:42 <shubalub> I looked at Boost once, and Boost::Spirit made my eyes bleed
21:11:57 <shubalub> also no Boost for class projects :(..
21:12:10 <thoughtpolice> Trinithis: it's a set of C++ libraries. some are under review for inclusion in the next c++ standard iirc.
21:12:20 <Pseudonym> Yeah.
21:12:21 <Pseudonym> That.
21:12:24 <thoughtpolice> http://boost.org i believe
21:12:25 <lambdabot> Title: Boost C++ Libraries
21:12:30 <thoughtpolice> well there you go
21:12:33 <Pseudonym> Reference-counting smart pointers are going in the next standard.
21:12:43 <Pseudonym> They might even be in TR1.
21:12:49 <Trinithis> bookmarked
21:13:09 <thoughtpolice> i've never had the pleasure (or pain?) of really using c++ so I couldn't comment too much.
21:13:14 <Trinithis> "Reference-counting smart pointers" sounds neat
21:13:27 <Trinithis> sounds like psuedo-garbage collection?
21:13:30 <Pseudonym> For the record, I used to make all of the arguments against C++ that I still hear.
21:13:38 <Pseudonym> Until I actually used C++ for something serious.
21:13:42 <mauke> http://yosefk.com/c++fqa/
21:13:43 <lambdabot> Title: C++ FQA Lite: Main page
21:14:11 <newsham> i've used c++ and still dont like it :)
21:14:14 <shubalub> yeah, from what I can tell a lot of the recent work in C++ is an attempt to avoid manual memory management without actually having a garbage collector
21:14:25 <Pseudonym> A lot of valid complaints can be made against C++, but it hits a sweet spot.
21:14:37 <newsham> you can build your own refcounting pointers without any builtins
21:14:45 <newsham> the antlr c++ parser used it for example.
21:14:57 <Pseudonym> BTW, I agree with you on Spirit.
21:15:05 <Pseudonym> It's a cool hack, but I'd never use it for anything serious.
21:15:43 <bos> i would agree that C++ hits a sweet spot only if you have a genius gang of highly disciplined alexey stepanov clones.  if you try to do anything ambitious with mere mortals, you're screwed.
21:15:59 <Pseudonym> Pshaw.  Who hires mere mortals?
21:16:04 <mrd> bos: ie. google?
21:16:06 <thoughtpolice> other mortals?
21:16:12 <Pseudonym> Do we find mere mortals here on #haskell?  I don't think so.
21:16:13 <lament> Pseudonym: i kinda hope somebody does, or i'm screwed
21:16:16 <newsham> i've seen enough mega c++ commercial hits technical failures turned java rewrites
21:16:35 <Pseudonym> If you want VB script kiddies, you know where to find them.  Just look under the floorboards.
21:16:46 <mrd> where we stashed the bodies?
21:16:51 <shubalub> in what situation are you best off with C++?
21:16:54 <newsham> just too many ways for mere mortals to hang themselves and let the naughty people in
21:16:58 <bos> mrd: google used to have enough smart people that they can coast for a while. the smart has been heavily diluted.
21:17:13 <Nafai> I recently re-read an early version of "The Design and Evolution of C++"
21:17:17 <Pseudonym> newsham: "C++ commercial hits technical failures turned Java rewrites" sounds like classic Fred Brooks.
21:17:24 <Trinithis> Meh, to hell with C++ or any other high-level language. We need to go back to the days of punch cards
21:17:26 <Nafai> Much of Stroustrup's ideas seemed in anthithesis to Haskell
21:17:28 <newsham> I dont know Fred Brooks.
21:17:30 <Pseudonym> The C++ version being the throw-away copy.
21:17:49 <mrd> the "Mythical" man month indeed
21:17:50 <Pseudonym> Screw punch cards, let's go back to key switches.
21:17:52 <newsham> *nod* it definitely got the companies paid and funded enough to do the rewrite
21:18:06 <Trinithis> psudo: qft
21:18:08 <newsham> the rewrite and transition were long and expensive, but definitely funded, so you cant argue with that
21:18:15 <lament> I always, always misread it as the mythical man mouth.
21:18:28 <lament> or moth.
21:18:36 <Pseudonym> Admittedly, if the version in Java worked fine, it suggests that C++ was the wrong language for the project in the first place.
21:18:41 <newsham> but you can also write something in ruby and get funded ;-)
21:18:46 <mrd> lament: that is indeed mythical!
21:19:03 <lament> there was some movie about man-moths...
21:19:09 <newsham> pseudo: *shrug* large commercial web applications that you've probably used before.
21:19:11 <joed> And you still all argue this.. Heh
21:19:15 <dibblego> we're doing lots of ruby junk lately sadly
21:19:26 <Pseudonym> Web applications work at the speed of the network, duh.
21:19:30 <newsham> seems like c++ should be the write language.. perhaps not all the technologies were a good fit though (ie. large, forking cgi)
21:19:33 <Pseudonym> You rarely need to count cycles there.
21:19:35 <lament> Pseudonym: if only that were true
21:19:48 <lament> Pseudonym: you must not have used any web applications
21:19:51 <newsham> heh
21:19:56 <Pseudonym> Heh.
21:19:59 <newsham> right.. scaling is never an issue in large web apps!
21:20:16 <newsham> s/write/right/
21:20:25 <mrd> scaling is for mountaineers
21:20:30 <thoughtpolice> now that I've been exposed to haskell for the past year or so I think once I finally get a job programming I'll be kind of pissed.
21:20:32 <lament> scaling is for fish!
21:20:33 <newsham> anyway, the higher up the semantic ladder you can get your developrs to climb...
21:20:46 <newsham> the less you gotta pay someone to come in and help you clean up your mess
21:20:56 <monochrom> the fewer developers who attain there
21:20:59 <ddarius> thoughtpolice: So don't get a job programming.
21:21:01 <johnnowak> thoughtpolice: i think you're being overly optimistic
21:21:03 <lament> newsham: is that another way of saying "Write in Java to begin with"? :)
21:21:07 <Trinithis> out of curiousity, is haskell suited for large scale apps
21:21:11 <newsham> lament: something like that.
21:21:15 <Pseudonym> lament: Good $DEITY, no.
21:21:22 <lament> @faq is haskell suited for large scale apps?
21:21:22 <lambdabot> The answer is: Yes! Haskell can do that.
21:21:25 <Pseudonym> How far up the semantic ladder do you think Java is?
21:21:27 <joed> holy shit.
21:21:30 <newsham> I'm not huge fan of java either, but GC is a big step forward for most developers
21:21:40 <newsham> pseudo: not terribly high
21:21:46 <Pseudonym> Right.  It's below Modula-3.
21:21:55 <Pseudonym> And Modula-3 isn't that high.
21:22:00 <byorgey> joed: ?
21:22:04 <Trinithis> anyone like javascript? that's got your lovely first-class funcs
21:22:05 <newsham> you cant hire an army of modula 3 developers
21:22:18 <thoughtpolice> johnnowak: you would describe it as?
21:22:20 <Pseudonym> But if you could, you'd get some kick-arse code.
21:22:24 <ddarius> Trinithis: Lacks TCO and lexical scoping.
21:22:29 <lament> javascript is a fun language, unfortunately it's used for web programming, which is the worst thing ever.
21:22:41 <Nafai> I think the whole "We can't hire developers who know this" argument is lame
21:22:44 <Trinithis> ddarius: no idea what you just said
21:22:46 <thoughtpolice> ddarius: i'll just become a code ninja in the mountains
21:22:49 <Trinithis> ddarius: lol
21:22:58 <newsham> if you're a large mega software developer you have a significant fraction of your developers in china and india.
21:23:01 <shubalub> Nafai: even when it's valid?
21:23:04 <Nafai> If it's the right technology, use it!  Good developers are supposed to learn on the job, aren't they?
21:23:09 <newsham> and they're coding in c++ and java and perl and php and god knows what else
21:23:10 <byorgey> thoughtpolice: that would be awesome.
21:23:13 <newsham> but not in modula-3
21:23:14 <Trinithis> lament: the worst thing about js is internet explorere
21:23:28 <lament> Trinithis: that's one of the worst things.
21:23:33 <Trinithis> lament: and that it can't be compiled... or at least to my knowledge
21:23:38 <newsham> and you're not talking about a small team of the cream of the crop
21:24:02 <thoughtpolice> byorgey: i'll let you know how it goes. i figure i'll live off of much fruit and occasionally go steal people's wireless in the unsuspecting towns below.
21:24:02 <newsham> lament: i'm not terribly fond of javascript
21:24:03 <shubalub> Nafai: I expect experience with C++/Java/C# is not a good predictor of ability with Haskell (or any other significantly different language)
21:24:10 <Trinithis> well igtg
21:24:14 <Trinithis> fun chatting
21:24:14 <lament> newsham: it's better than most mainstream things
21:24:15 <Trinithis> cya
21:24:23 <byorgey> bye Trinithis
21:24:24 <Pseudonym> Fare well.
21:24:29 <shubalub> Nafai: so you would end up paying for a bunch of training on people you don't even know they're worth spending money on
21:24:53 <newsham> lament: it has its strong points.. but the argument passing, the pseudo-object system and (in popular web platforms) the lack of coroutines or threads...
21:24:57 <newsham> are pretty bad :(
21:25:03 <lament> shubalub: or he could hire me! That's why i'm a math major :)
21:25:25 <Moosefish> newsham: It does a great job for what it was design for. Too bad that's what it's used for. (Javascript, that is)
21:25:26 <shubalub> I didn't regret picking CS for my major, until I tried to learn Haskell
21:25:38 <Nafai> shubalub: True.
21:25:53 <lament> "If I can learn analysis, don't you think i can learn your stupid language as well?"
21:26:01 <newsham> moose: designed for as in interactive client-side web logic?  what about graphics drawing primitives (being fixed) and threads?
21:26:11 <newsham> writing all your code in a CPS is a royal pain
21:26:13 <Moosefish> newsham: Designed to replace the <blink> tag.
21:26:17 <mrd> lament: not really, since many hardcore mathematicians turn out to be horrible programmers
21:26:26 <byorgey> thoughtpolice: sounds good.  you could do some stream processing, climb some trees, and of course, hunt for gophers with Arrows.
21:26:30 <johnnowak> thoughtpolice: it all depends on your personality really. you might enjoy it.
21:26:39 <newsham> lament: lucky.. i wish i was a math major.
21:27:06 <lament> mrd: i'm guessing about the same percentage as CS majors? :)
21:27:11 <thoughtpolice> johnnowak: i might be being a little overexaggerating. i've never been hired for programming, so on a first time, I have no idea how I'll deal with it. probably just try to go with the flow as easy as possible
21:27:11 <mrd> likely
21:27:19 <rhz> http://www.cse.unsw.edu.au/~rubenz/repos/Harmony/Harmony.hs - SATB Harmonisation using backtracking if anyone wants to look at it. Needs LilyPond to process output.
21:27:32 <newsham> if only i lived at my mothers, was single, and could just play with math all day long ;-)
21:27:33 <Pseudonym> Ooh, cool.
21:27:38 <ddarius> People outside of the mathematics community tend to overestimate people inside it.
21:28:03 <monochrom> math major is still different from hardcore mathematician. moreover it may be the mainstream language, not the mathematician, that causes horrible programming.
21:28:14 <lament> newsham: you'd just complain about not having a girlfriend all the time?
21:28:20 <byorgey> rhz: neat!
21:28:25 <newsham> i have a wife, a mortgage, a job and all that jazz
21:28:38 <byorgey> rhz: maybe I'll have some time to play around with it a bit tomorrow...
21:28:47 <rhz> byorgey: ok, thanks
21:28:51 <shubalub> monochrom: re horrible programming, see C++
21:28:57 <newsham> i like that russian guy who spent the last dozen years working on math problems at his mom house, won a big award and didnt even want to show up to get the award
21:29:10 <mrd> he should have taken the money, for his mother at least
21:29:19 <mrd> silly principles getting in the way
21:29:31 <thoughtpolice> byorgey: i will also train to be purely functional as much as possible.
21:29:32 <newsham> (not that I dont love my wife, my house and my job... but math requires more devotion than evenings and weekends)
21:30:20 <ddarius> newsham: You don't think mathematicians have wives and homes and jobs?
21:30:47 <monochrom> hehe, be careful what you ask :)
21:31:17 <monochrom> I think most mathematicians get spouses and homes and jobs quite some time after graduation.
21:31:29 <newsham> perhaps james harris simons is a better role model for math
21:31:57 <newsham> ddarius: most important mathematicians make their big accomplishments before 30
21:32:23 <newsham> http://en.wikipedia.org/wiki/James_Harris_Simons
21:32:24 <lambdabot> Title: James Harris Simons - Wikipedia, the free encyclopedia
21:33:03 <byorgey> instance Monad CodeNinja where return = kill ; (>>=) = flip out
21:33:17 <lament> just as long as your role model isn't Galois
21:33:23 <newsham> look at sir isaac newton for example.
21:33:29 <newsham> never slept with a woman in his life
21:33:43 <Moosefish> but once he was dead, man I tell you...
21:33:55 <newsham> true
21:34:13 <newsham> anyway, enough chat.   good eve.
21:35:03 <lament> not sure how whoever made that claim could possibly prove it
21:35:12 * byorgey -> bed
21:37:44 <IW32>  /msg nickserv set unfiltered on
21:38:23 <IW32> how do i implement a scrolling window using the HGL library
21:38:36 * bos updates the stringsearch library to work with ghc 6.8.1
21:39:51 <IW32> is it even possible to make a self scrolling window using the HGL library ?
21:40:20 <Cale> Possibly not. It's really a very simplistic library.
21:40:33 <IW32> ???
21:40:50 <IW32> so r u sayng it can't be done
21:41:00 <Cale> I don't actually know HGL all that well.
21:41:08 <IW32> o
21:41:17 <Cale> But it wouldn't surprise me if it wasn't something built in.
21:41:25 <dons> anyone know Julian Assange?
21:41:29 <IW32> i am writing mastermind game in HGL
21:41:32 <Cale> Now, you might be able to design your own scroll bars...
21:41:47 <Cale> Isn't a mastermind board a fixed size?
21:41:49 <dons> i thought i recognised his name here, http://wikileaks.org/wiki/US_Military_Equipment_in_Iraq_%282007%29 and yes, he hangs out on the haskell mailing list.
21:41:51 <lambdabot> Title: US Military Equipment in Iraq (2007) - Wikileaks, http://tinyurl.com/3daqlg
21:41:52 <Pseudonym> dons: My brother does, quite well.
21:42:07 <Pseudonym> I've met him a couple of times.
21:42:15 <dons> oh, interesting.
21:42:16 <IW32> i want to creat a window that pops up when help is type displaying the guide for playing the game
21:42:19 <dons> small world.
21:42:27 <Pseudonym> You've read "Underground"?
21:43:03 <Pseudonym> http://www.underground-book.com/
21:43:04 <lambdabot> Title: Underground: Hacking, madness and obsession on the electronic frontier
21:43:08 <dons> oh, a long time ago. yes.
21:43:12 <Pseudonym> Yeah.
21:43:21 <Pseudonym> He's one of the characters in the book.
21:44:04 <dons> interesting FP hacker :)
21:44:08 <Pseudonym> Yeah.
21:44:52 <monochrom> Haskell helps build a better Iraq? :)
21:44:54 <Pseudonym> Greg (my brother) was co-adminning a server with one of the other guys mentioned in the book.
21:45:10 <Pseudonym> And they gave Julian root access, because they knew he'd take it anyway.
21:45:15 <Pseudonym> Figured it'd be easier that way.
21:45:48 <lament> hah
21:46:52 <Cale> IW32: well, you could certainly do something with pages of text, at least.
21:47:20 <dfranke> Wow, this is the most cryptic response I have ever gotten out of ?pl
21:47:31 <dons> heh
21:47:32 <dfranke> ?pl foo x = (0 - fst x, snd x)
21:47:33 <lambdabot> foo = first ((-) 0)
21:47:40 <IW32> seems u ave a limited knowledge
21:47:45 <dons> looks ok to me
21:47:47 <dons> ?src first
21:47:47 <lambdabot> Source not found. stty: unknown mode: doofus
21:47:52 <IW32> i'll do some googling
21:47:59 <dons> > first (+1) $ (1,1)
21:48:00 <lambdabot>  (2,1)
21:48:11 <dons> its a newish idiom
21:48:19 <dfranke> yeah, I know
21:48:21 <dfranke> it's from arrows
21:48:24 <dons> not one you see outside #haskell very often
21:48:32 <mauke> first negate
21:48:37 <Pseudonym> Oh, it's amazing who hangs out on the mailing list.
21:48:37 <dfranke> but I never expected to see it used on the (->) arrow
21:48:43 <Pseudonym> I was shocked to see a post from Doug McIlroy.
21:48:46 <dons> yes!
21:48:51 <Pseudonym> In retrospect, perhaps not so shocking.
21:48:57 <dons> yeah, that was very interesting
21:49:15 <Pseudonym> We'll probably find that someone is really Dennis Ritchie in disguise or something.
21:49:27 <dons> :)
21:49:34 <ddarius> There are quite a few people you wouldn't immediately think of as being on the haskell mailing list.
21:49:49 <lament> Britney Spears
21:49:57 <ddarius> lament: Indeed!
21:50:41 * thoughtpolice --status=sleep
21:51:39 <dons> do the lisppaste guys know we haven't used their channel in 9 months? http://paste.lisp.org/list/haskell
21:52:02 <dfranke> The strangest instance I've ever had of not expecting to have someone listening was when Kevin Poulson emailed me in reply to a /. comment I made.
21:52:13 <dons> heh
21:52:27 * Pseudonym laughs
21:52:34 <Pseudonym> That happened to me on Usenet once, only it was Rob Pike.
21:53:01 <dfranke> It was several years back when the sendmail site got cracked and a trojan got inserted into the sources.
21:53:14 <dfranke> I got infected by it.
21:53:19 <bos> Pseudonym: http://www.cs.dartmouth.edu/~doug/powser.html
21:53:19 <lambdabot> Title: Power serious
21:53:36 <bos> though perhaps you've already seen that
21:53:50 <dfranke> I reverse-engineered the trojan and posted the IP of site that it reported back to.
21:54:18 * ddarius would be surprised if Pseudonym hadn't.
21:54:27 * sorear has gotten e-mail from Bill Gosper (okay, it was a list message for a cellular-automaton program I'm semi-involved with)
21:54:29 <Pseudonym> Yeah, seen it.
21:54:40 <dfranke> and Poulson emailed me asking to quote me in an article about it.
21:54:46 <Pseudonym> It's a reimplementation of something he did in Squeak, only much more succinctly.
21:55:16 <ddarius> The circle is closed.
21:56:18 <ddarius> @google "Squinting at Power Series"
21:56:24 <lambdabot> http://plan9.bell-labs.com/who/rsc/thread/squint.pdf
21:58:12 <sarehu> oh man, sometimes I can be a moron:   xs = map someFunction [0..12] ; gs = map (fst . (xs !!)) [0..12]
21:59:31 <lament> are we bragging about famous people? I took a course with Chris Pressey!
21:59:51 <ac> what's "fps", and where can I get it (lambdabot depends on it)
22:00:03 <sarehu> pff, I used a theorem by Euclid.
22:00:21 <dons> ac, are you using the darcs version of lambdabot?
22:00:24 <dons> ?version
22:00:25 <lambdabot> lambdabot 4p575, GHC 6.6 (Linux i686 2.66GHz)
22:00:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:00:45 <monochrom> I met Michael Jackson.
22:00:49 <Pseudonym> Actually, we're marvelling about the famous people who hang around Haskell.
22:00:57 <ac> dons: no the hackage version. Also, if you're providing plugins as source code, how much of ghc do you need installed on the target machine?
22:01:07 <ac> dons: I assume all of it
22:01:09 <monochrom> OK, just Haskell? I met Simon Peyton Jones.
22:01:15 <Pseudonym> I met Phil Wadler.
22:01:33 <monochrom> Damn, I met all the imperative people but not quite the functional people.
22:01:57 <mauke> I met Simon Peyton Jones _and_ Phil Wadler
22:02:02 <mauke> on the same day!
22:02:04 <Pseudonym> Woo!
22:02:06 <monochrom> (imperative people = Hoare, Dijkstra, Back, ...)
22:02:11 <luqui> I meet imperative people all the time, functioal people seem to be rare ;-)
22:02:22 <dfranke> I know Paul Graham pretty well, but I haven't met any of the Haskell patriarchs in person.
22:02:22 <Pseudonym> So who knows their Erdos number?
22:02:30 <ddarius> Me, me!
22:02:38 <luqui> Infinity!
22:02:38 <Pseudonym> What is it?
22:02:52 <Pseudonym> Mine is a mere 5.
22:02:52 <ddarius> Same as luqui's.
22:02:54 <dfranke> Mine would be 4 if I'd gotten around to cleaning up a preprint before I graduated.
22:03:01 <dfranke> instead it's undefined.
22:03:59 * ddarius could probably change his Erdos number, with some effort, pretty quickly.
22:04:03 <dfranke> occasionally somebody auctions 1 + their Erdos number on eBay.
22:04:10 <dons> dfranke: me too, well i think mine is 6, but it would have been 4. ah well :|
22:05:30 * kfish considers a wiki-style arxiv for "papers that didn't quite get finished on time"
22:05:36 <dons> :)
22:06:09 <dons> how about an alternative erdos web for collaborations that didn't quite get finished
22:06:52 <kfish> dons: yeah if you extend the numbering into the "imaginary" plane
22:07:06 <monochrom> hahaha
22:07:11 <dfranke> I do have a well-defined Zimmerman number though.
22:07:26 <dfranke> I think it's 5.
22:07:42 <puusorsa> the law of fives is never wrong
22:07:52 <dfranke> Eris be praised.
22:07:53 <Pseudonym> More to the point, who has a Kevin Bacon number?
22:08:09 <monochrom> You are making me hungry. :)
22:08:10 <Pseudonym> If some of my software was used on a movie, does that count?
22:08:17 * Pseudonym didn't get a screen credit, of course
22:08:30 <kfish> Pseudonym, metoo!
22:08:38 <Pseudonym> Which one>?
22:08:40 <Pseudonym> Or ones?
22:09:13 <kfish> some pixar ones a few years back ...
22:09:21 <ddarius> What is with you computer graphics people and Haskell?
22:09:24 <Pseudonym> Cool.
22:09:40 <Pseudonym> In what capacity, if I may ask?
22:10:10 <kfish> sound effects / synchronisation
22:10:18 <Pseudonym> Cool.
22:10:24 <kfish> i wrote a sound editor (sweep) which they used for a few years
22:10:28 * Pseudonym wrote a RIB parser
22:10:33 <Pseudonym> For a commercial product.
22:10:41 <Pseudonym> Probably still in use.
22:10:49 <ddarius> You wrote sweep?
22:10:52 <Pseudonym> I know about the Matrix sequels and Orange County.
22:10:57 <Pseudonym> Probably others.
22:11:01 <kfish> ddarius, yah
22:11:18 <Pseudonym> Woo, cool.
22:11:19 <dfranke> I have a Bacon number if you allow home movies and remove the starring requirement.
22:11:22 <Pseudonym> That sweep, yes.
22:11:32 <dfranke> I have a cousin who was an extra in the remake of The Poseidon Adevnture.
22:11:58 <Pseudonym> Oh, yeah, I have friends who were extras in Queen of the Damned.
22:12:38 <Heffalump> Pseudonym: 3 (Erdos number, that is)
22:12:41 <Pseudonym> And I personally swore under my breath at a film crew who left cables in my personal space, when I lived at one location where Muggers was being filmed.
22:12:43 <lament> so what's everybody's dons number?
22:12:52 <dfranke> I know some people who were interviewed in Wordplay.
22:13:01 <Pseudonym> Heffalump: Cool, that's almost certainly the highest on the channel.
22:13:20 <ddarius> Unless the undead cadaver of Erdos is here.
22:13:38 <Pseudonym> If you pick up an unsolved problem of Erdos, can you credit him as a co-author?
22:13:41 <Heffalump> oh, and I met him once
22:13:58 <ac> Who's the expert on lambdabot?
22:14:08 <lambdabot> I am.
22:14:15 * Korollary shivers
22:14:17 <ac> uncanny.
22:14:26 <ac> lambdabot: how easy would it be to strip out most of your dependencies?
22:14:31 <zombie_erdos> braaaaaanes
22:14:34 <ac> lambdabot: and all your features
22:14:49 <Pseudonym> zombie_erdos: You already have more brains than the rest of us put together.
22:14:59 * allbery_m has a stripped-down lb already
22:15:05 <lambdabot> Then I'd just be "main".
22:15:27 <kfish> lambdabot, and wouldn't that feel, peaceful?
22:15:29 <ddarius> main = loadModules [] -- excitement!
22:15:31 <ac> allbery_b: with just the plugin system?
22:15:38 <Korollary> main = main
22:15:41 <shachaf> lambdabot: Are you a were-human or something like that?
22:15:54 * ddarius heads off to bed.
22:16:14 <allbery_m> yep.  minimal plugins too; I'm using it in channels that have no interest in Haskell per se, it was just more convenient for me than trying to hack up an eggdrop
22:16:32 <lambdabot> shachaf: If you want one of those, talk to zombie_erdos.
22:16:32 <ac> allbery_b: do you have a repository I can get?
22:16:40 <allbery_m> no :(
22:16:51 <ac> allbery_b: a tar.gz?
22:17:07 <ac> lambdabot: how do you feel about people copying you and messing with your internals?
22:17:22 <lambdabot> Oddly pleased.
22:17:23 <allbery_m> the repo is (1) on local disk (2) somewhat hacked up for local preferences (3) out of sync because I pulled newer LB source on top of it
22:17:36 <omnId> lambdabot: you are open source after all.
22:17:45 <allbery_m> and in any case, it's not a major change, juust excluded lots of modules and reduced deps to match
22:18:03 <ac> allbery_b: ok, I'll see what I can do
22:18:12 <allbery_m> (don't think you need hs-plugins if you don't use @run; ;no need for hoogle if you omit that plugin; etc.)
22:18:33 <ac> allbery_b: what's @run?
22:18:33 <allbery_m> much of it is automatic although I think it always wants hs-plugins (try editing it out of the .cabal)
22:18:42 <allbery_m> @run is the full name of >
22:18:42 <lambdabot>  Parse error at "of" (column 18)
22:18:48 <allbery_m> heh
22:18:53 <allbery_m> > [1..]
22:18:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:18:58 <omnId> @run length [1..]
22:18:58 <allbery_m> @run [1..]
22:19:00 <ac> allbery_b: I want hsplugins
22:19:02 <lambdabot> Terminated
22:19:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:19:12 <monochrom> @run length encoding
22:19:13 <lambdabot>   Not in scope: `encoding'
22:19:43 <sarehu> > 2 .|. 3
22:19:44 <lambdabot>  Add a type signature
22:19:50 <sarehu> > 2 .|. 3 :: Int
22:19:51 <lambdabot>  3
22:20:11 <allbery_m> but I left out the hoogle plugin and it didn't ask me to install hoogle
22:20:29 <allbery_m> no hacking needed aside from editing Modules.hs to remove unwanted modules
22:21:43 <ac> allbery_b: cool
22:22:25 <sorear> allbery_m: what's with the 'm'?
22:22:48 <allbery_m> my campus desktop machine fell over so I'm on from my home mac
22:23:15 <allbery_m> I'm not sure why freenode hasn't noticed the lack of responsiveness; it pings but doesn't do anything else.  (buggy kernel, vfs livelock)
22:23:46 <allbery_m> load average is something like 750,,, all stuck in disk wait
22:30:24 <sorear> you are aware of /msg nickserv help ghost?
22:30:45 <luqui> what is the difference between Foreign.Ptr and Foreign.ForeignPtr?
22:31:07 <sorear> ForeignPtr has a finalizer
22:31:15 <sorear> and is much much much more heavyweight
22:37:21 <sjanssen> luqui: as sorear mentions, ForeignPtr has a finalizer, an action that is executed when there are no more references to it
22:38:02 <sjanssen> luqui: free() is the typical finalizer, which gives you some automatic memory management for memory locations
22:39:45 <ac> lambdabot: why does your build say I'm missing arrows dependency, when Control.Arrow comes with GHC 6.6?
22:40:20 <sorear> ac: huh?
22:40:31 <sorear> ac: your question is non sequiter
22:40:54 <sorear> ac: it's like asking why Control.Arrow doesn't satisfy opengl
22:40:57 <ac> sorear: So? non sequitors are at home on IRC
22:41:35 <ac> sorear: does the dependency "arrows -any" have nothing to do with Control.Arrow?
22:41:40 <sorear> no.
22:41:48 <sorear> er
22:41:49 <sorear> yes.
22:42:17 <ac> sorear: ok. Just wanted to know if installing arrows from hackage would cause duplicate libraries
22:42:22 <sorear> well, they're both related to the abstract 'arrow' concept, but arrows is a full modifier library
22:42:29 <sorear> like mtl vs. Prelude.Monad
22:42:42 <ac> ok that makes sense
22:49:36 <Korollary> Excellent webpage, slava
22:50:35 <dons> yeah, truly great
22:50:38 <dons> slava++
22:50:56 <OceanSpray> what link?
22:51:08 <dons> let's get it on the reddit frontpage!
22:51:16 <dons> http://programming.reddit.com/info/606v5/comments/
22:51:17 <lambdabot> Title: programming: Check out Slava Pestov's awesome retro webpage!
22:51:20 <dons> ?users
22:51:21 <lambdabot> Maximum users seen in #haskell: 424, currently: 359 (84.7%), active: 18 (5.0%)
22:51:29 <dons> 350 up mods would do it!!
22:51:53 <dons> come on #haskell, spread your love around :)
22:52:14 <slava> i don't see why that was even posted on reddit
22:52:28 <lament> oh god, that's the worst site ever. good job!
22:52:32 <slava> i post genuinely interesting things which hover around 0 points
22:52:34 <dons> talk to schwarzwald :)
22:52:50 <dons> slava: pop culture reddit
22:52:52 <Korollary> I get downmodded for stating googleable facts
22:53:10 <slava> don't even try to convince them that 0.9... == 1
22:53:28 <dons> oh, bulat says "it's a whole new era in low-level ghc programming"
22:53:36 <dons> yay, we finally convinced bulat you can write fast ghc code
22:53:41 <OceanSpray> "Lie algebra cohomology"
22:53:56 <OceanSpray> does that have anything to do with making dishonest statements?
22:54:00 <Pseudonym> Sorry, I don't understand why reddit moderation points are important.
22:55:37 <kfish> OceanSpray!! write me an oggz-comment manpage ;-)
22:55:55 <OceanSpray> oh man.
22:56:15 <kfish> lol
22:56:17 <Pseudonym> Anyway, must away.
22:56:18 <ac> how do I make cabal install put things in the system lib directory, or why is this not done by default?
22:56:18 <Pseudonym> Nytol!
22:56:26 <OceanSpray> There is no cabal.
22:56:33 <dons> ac, because the system lib dir is not writable by default
22:56:45 <dons> so in the interest of having things 'just work' --user is the default
22:56:51 <OceanSpray> kfish, sorry
22:56:57 <OceanSpray> I'm kind of busy.
22:57:08 * ac sees the --global option :P
22:57:08 <slava> dons: is galois hiring? :)
22:57:20 <dons> slava: they are, yes. i think they always are
22:57:29 <OceanSpray> college apps, homework, tests, academic decathlon,
22:57:34 <dons> and we're getting a new website in a week or so
22:57:36 <OceanSpray> general shit happening.
22:57:38 <dons> something not quite so 1998.
22:57:44 <slava> something 1994??
22:57:51 <slava> nice
22:57:52 <dons> if only!
22:58:40 <kfish> OceanSpray, no worries, we'll plan a release schedule ... on ogg-dev, later :-)
22:59:38 <slava> dons: what exactly do you do?
22:59:45 <Lycurgus> who owns Galois?
22:59:47 <slava> you being your company
23:00:04 <dons> oh, high assurance software. haskell + proofs
23:00:06 <Korollary> top sekrit
23:00:14 <dons> for people who need that kind of thing
23:01:59 <ac> how does cabal install --user register things in GHC's package database?
23:02:00 <kfish> as opposed to software that falls apart randomly, and no-one's sure what it does
23:02:51 <dons> pretty much, yeah
23:04:00 <Korollary> ac: it registers it in the user's database
23:04:24 <dons> ac, yeah, there's a user database in your .cabal/ dir
23:06:56 <ac> huh, the "cabal: dist/Conftest.c: openFile: does not exist" reappeared. What did I do?
23:07:26 <dons> ah, is that on a mac, by chance?
23:07:40 <ac> ubuntu
23:07:42 <slava> dons: haskell.org really needs a hit counter and a guest book
23:07:42 <willu> Hi all...       Is there any way to install ghc on MacOS 10.5 without using MacPorts?
23:07:49 <slava> dons: maybe a marquee too
23:07:52 <dons> no? ok. please report it to cabal-devel@
23:08:04 <dons> slava: oh, it does have secret wiki counter.
23:08:11 <ac> it's probably user error
23:08:13 <dons> but we're going more for classic 1998, than 1994 old school
23:08:23 <dons> ac, no, its a bug others have mentoined
23:08:29 <slava> in 4 years, 1998 will be the new 1994
23:08:30 <dons> there should be no user errors :)
23:08:36 <dons> slava: let's hope!
23:09:49 <dfranke> ok, I'm having way too much fun with SYB
23:10:03 <Korollary> willu: x86?
23:10:13 <willu> yeah - x86
23:10:14 <ac> dons: this is odd though, because I installed two packages before it started producing that error this time
23:10:14 <dfranke> I just wrote the function (\(x,y) -> (-x,-y)) as (everywhere . mkT negate)
23:10:24 * Lycurgus thinks e heard the Leopard port of ghc was broken/incomplete.
23:10:28 <dons> ac, oh , its reproducible?
23:10:30 <dons> definitely report it please
23:10:39 <ac> dons: I will try to reproduce it
23:10:50 <ac> by uninstalling cabal-install
23:11:05 <ac> how do I do that, btw?
23:11:13 <Lycurgus> (but I maybe be confusing it with sbcl)
23:11:29 <Korollary> willu: Have you seen http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/13017
23:11:31 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/384ek8
23:11:56 <willu> yup - and it failed
23:12:17 <Korollary> willu: Ah ok. I don't have a mac myself.
23:15:23 <ac> dons: it only shows that error for certain packages, like QuickCheck, and logict for example. It did not with arrows
23:15:45 <dons> mm. please report to dcoutts :)
23:20:54 <quicksilver> @remember slava haskell.org really needs a hit counter and a guest book ... maybe a marquee too
23:20:54 <lambdabot> I will never forget.
23:27:22 <omnId> @@ @elite @run wordsWise (map reverse) @show @keal
23:27:24 <lambdabot>  "NA( lL3xzA|-| 3pIP 3HT \/\/Ar l4noit4Rri noiT4UqE49em oTNi NA 9O|4NA 3cIved"
23:31:00 <ac> I did send a message to cabal-devel, but now somehow the behavior changed.
23:31:41 <ac> I double checked that installing arrows indeed worked, by unregistering it and reinstalling with cabal. But now installing arrows produces the same error, and also I can't unregister it using ghc-pkg
23:32:02 * ac is experiencing package weirdness
23:33:01 <ac> where's the hidden state?
23:33:39 <ac> perhaps it's my system clock? ;)
23:34:46 <ac> also interesting to note is that before cabal install would either download the package or note that it's cached. Now it's producing the error before it even does that
23:40:10 <andersjanmyr> I'm new here so I don't know the protocol, I have a question on STM. Is it ok to just ask?
23:40:38 <quicksilver> andersjanmyr: yes. Just ask.
23:40:43 <puusorsa> i've never seen a channel where it's better to ask if you can ask than just ask
23:40:49 <quicksilver> not that I'm promising to know the answer :)
23:41:13 <ac> interesting. I deleted /usr/local/lib/Cabal*, and now cabal is broken entirely. Building things results in "Could not find module `Distribution.Simple'", but I have libghc6-cabal-dev installed, so it should be able to find it in /usr/lib/haskell-packages/ghc6/lib/Cabal
23:41:41 <ac> perhaps cabal-install was using the wrong cabal library this whole time
23:41:58 <ac> from my old 6.8.0 install
23:42:50 <andersjanmyr> Ok, thanks! I have written a dining philosopher program to test STM, but the output gets garbled. I believe this is because the IO is not inside the transaction. Is there anything I can do about this?
23:46:46 <goalieca> andersjanmyr, ? i don't believe stm has locking so there are enough forks for everyone aren't there :P
23:47:36 <perspectivet> is there anything library function like to strtok for haskell?
23:47:53 <perspectivet> ie split a string on delimiters while dropping the delimiters
23:49:09 <kfish> perspectivet, http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html
23:49:12 <lambdabot> Title: The Julipedia: A split function in Haskell, http://tinyurl.com/fhss7
23:49:55 <goalieca> i figure such a function would be trivial in haskell: ie list processing
23:50:33 <omnId> perspectivet: there's words and lines for the " " and "\n" cases.
23:50:48 <goalieca> but if delim is a "list" then wouldn't  "c in delim" work fine
23:51:40 <perspectivet> ok, thx.  Was wondering of there was a standard solution.
23:51:47 <perspectivet> rolling my own
23:51:50 <andersjanmyr> goalieca, but the transaction should still fail and retry until the forks are available.
23:51:52 <omnId> > words "quick brown fox"
23:51:53 <lambdabot>  ["quick","brown","fox"]
23:52:15 <omnId> @go site:hpaste.org wordsBy
23:52:17 <lambdabot> http://hpaste.org/3418
23:52:17 <lambdabot> Title: wordsBy function - hpaste
23:52:20 <sjanssen> andersjanmyr: you'll probably have to put an MVar around IO
23:52:30 <goalieca> andersjanmyr, okay i suppose that is true. But doesn't haskell automatically "Retry"
23:53:35 <andersjanmyr> sjanssen, do you mean TVar?
23:53:56 <sjanssen> andersjanmyr: I mean MVar
23:54:53 <sjanssen> eg. do atomically (takeforks); x <- takeMVar iolock; putStrLn "I EATED A RICE"; putMVar iolock; dinesomemore
23:55:34 <sjanssen> andersjanmyr: we have to do our own locking for stdout, because the IO system doesn't
23:55:45 <andersjanmyr> goalieca, haskell automatically retries if I call check, which is the sam as if not [condition] retry.
23:56:23 <sjanssen> andersjanmyr: you could also write to a TChan every time a philosopher successfully eats, then have one thread read that TChan and print the messages
23:56:29 <andersjanmyr> sjanssen, ok thanks. I'll try that.
23:56:40 <perspectivet> omnId: thx
23:56:54 <sjanssen> andersjanmyr: though contention on the TChan may cause your philosophers to retry more frequently than you'd like
23:57:40 <andersjanmyr> sjanssen, thanks I guess I have to get back to reading some more documentation.
23:58:25 <goalieca> andersjanmyr, you have inspired me to try and write a solution of my own.
23:58:32 <goalieca> i really haven't played with STM ever
23:58:46 <goalieca> it is just too bulky for embedded systems
23:59:47 <andersjanmyr> goalieca, I'm glad I could inspere you :)
