00:00:20 <goalieca> no. it was in the 3rd right at the end of the game
00:00:29 <goalieca> he slashed.. got ejected.. will now be under review
00:02:54 <Korollary> excellent
00:05:22 <goalieca> does ghc optimize 2^ as <<
00:08:18 <int-e> no
00:10:35 <sjanssen> dons: what's up with "import LanguageShootout" in http://shootout.alioth.debian.org/gp4/benchmark.php?test=meteor&lang=clean&id=0
00:10:36 <lambdabot> Title: meteor-contest Clean program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/2atnm3
00:10:45 <goalieca> because nsieve uses (2^)
00:10:54 <goalieca> the c++ and others use <<
00:10:59 <goalieca> that would be a huge savings
00:12:01 <int-e> @type Data.Bits.shiftL
00:12:04 <lambdabot> forall a. (Bits a) => a -> Int -> a
00:13:08 <dons> sjanssen: isaac's perogative as shootout maintainer and clean afficionado?
00:13:37 <dons> goalieca: its only run 3 times though
00:13:47 <dons> good piont though
00:15:14 <sjanssen> dons: seems like cheating to me
00:15:41 <goalieca> dons: the haskell version is only off the c++ version (the current leader) by fractions of a second ;)
00:16:09 <dons> ah
00:16:18 <dons> good point
00:16:35 <dons> compiler flags can help there
00:19:08 <dons> goalieca++ looks to be a slight win!
00:22:11 <goalieca> dons :-)
00:34:07 <goalieca> :t io
00:34:08 <lambdabot> Not in scope: `io'
00:34:38 <goalieca> whoops
01:36:37 * hgolden is away: sleep
03:14:49 <olsner> hmm... that "type-level insanity" article was basically just prolog programming... but it didn't seem to realize that itself
03:16:22 <olsner> it could've been written as a simple syntactical translator from prolog (or a dialect of prolog) into the haskell type system
03:17:26 <oerjan> i recall someone mentioning that the haskell type system doesn't give full unification
03:18:55 <sjanssen> I don't think the code was very prologish
03:19:07 <sjanssen> all of it was essentially functional
03:19:20 <olsner> hmm, I guess it wouldn't be exactly the same thing as prolog, just something similar to prolog
03:19:39 <sjanssen> http://code.haskell.org/~sjanssen/instantinsanity/instantinsanitytf.hs
03:19:40 <lambdabot> http://tinyurl.com/2pjl7f
03:20:11 <sjanssen> there's a solution in type families, which demonstrates that the solution is quite functional
03:20:59 <oerjan> maybe the restriction is somewhat like Mercury's modes - only deterministic modes being allowed?
03:28:21 <roconnor> ugh, late binding
03:29:53 <roconnor> Which is worse, dynamic dispatch or late binding?
03:30:59 <Cale> Isn't dynamic dispatch a kind of late binding?
03:31:21 <Botje> smalltalk does the former, java does the latter
03:31:28 <Botje> they're both not-very-worse
03:31:36 <roconnor> Cale: :) I was thinking of asking if they were sort of the same thing.
03:32:27 <roconnor> Botje: I've been thinking that dynamic dispatch makes reasoning about code difficult or impossible.
03:32:44 <Botje> you'd think so
03:32:57 <Botje> but people seem to have no or little difficulties with smalltalk
03:33:04 <olsner> as I understand things, "late" binding means any binding done at runtime, and I guess dynamic dispatch is an implementation
03:33:32 <Botje> I think it's mostly convention
03:33:44 <Botje> "RULE THE FIRST: YOU DO NOT ALTER BASE CLASSES"
03:34:44 <Cale> roconnor: Well, so long as you use it as existential types would let you, it's sane enough.
03:35:53 <Pseudonym> Yeah, existential types + typeclasses aren't hard to reason about.
03:35:54 <Pseudonym> BUT.
03:36:02 <roconnor> Cale: so dynamic distpatch is usually used in the way that Haskell does ``static disptach'' through the class mechanism?
03:36:05 <Pseudonym> It's possibly because Haskell typeclasses tend to be closely tied to algebras.
03:36:38 <roconnor> oh, but with existential types, the dispatch is dynamic.
03:36:44 <Cale> roconnor: Whether it's actually usually used that way, I'm not sure. In fact, I'd be willing to bet you'd find a lot of indiscretions.
03:37:28 <roconnor> Cale: do you find bugs in the same places?
03:37:31 <roconnor> :)
03:37:35 <Cale> I suspect that you do :)
03:37:47 <Cale> (well, not always)
03:39:33 <roconnor> Cale: are you still in Waterloo?
03:39:38 <Cale> Nope
03:39:48 <Cale> I'm in Brantford
03:39:49 <roconnor> oh, where are you?
03:39:53 <roconnor> oh okay
03:39:58 <Cale> Just a 3/4 hour drive or so.
03:40:07 <roconnor> I was going to be in Waterloo sometime next year
03:40:10 <roconnor> to visit
03:40:13 <Cale> cool
03:40:27 <roconnor> no concrete plans yet though.
03:40:40 <rolly1975> is that Waterloo ON?
03:40:43 <Cale> yes
03:40:48 <rolly1975> i love that place
03:40:51 <rolly1975> used to work there
03:40:59 <rolly1975> for a little bit
03:41:05 <rolly1975> too cold tho :-)
03:41:56 <Cale> Waterloo somehow manages to get way more weather than Brantford, even though they're pretty close.
03:54:32 <roconnor> I'm supposed to give a 20 min talk about haskell/functional programming in December.
03:54:52 <roconnor> I'm thinking of calling it ``The Imperative of Functional Programming''
03:55:11 <Pseudonym> Lambda: The Ultimate Lecture Topic
03:55:56 <roconnor> I'm thinking about talking about how I use various monads for solving various problems.
03:56:44 <rolly1975> does anyone have any good real world case studies where people use fp successfully?
03:56:56 <rolly1975> i can think of a couple, but not  a huge amount
03:57:08 <rolly1975> i know one hedge fund that uses it
03:57:15 <rolly1975> and a couple of other companies
03:57:26 <rolly1975> otherwise seems to be mainly academic community
03:57:49 <rolly1975> i heard that goldman sachs are thinking of phasing out their inhouse fp language for new projects
03:57:55 <rolly1975> which is a shame :-(
03:58:24 <olsner> rolly1975: but what are they phasing in in its place?
03:58:25 <johnnowak> why is there often this concern about "real-world" use?
03:58:51 <rolly1975> java / c#
03:59:16 <rolly1975> possibly down to being able to find people easily to support it
03:59:22 <roconnor> I use FP to solve problem rather than to write big systems.
03:59:25 <rolly1975> i dont know the exact reasoning
04:00:39 <roconnor> I want to use http://programming.reddit.com/info/24p2c/comments/c24pc5 as my first motivating example.
04:02:42 <rolly1975> i see someone submitted an R version of that
04:03:03 <cizra> Once again, I must admit Haskell has bested me in writing stuff the other party doesn't understand.
04:03:19 <rolly1975> i guess if you class R as a functional language then that is a good real world usage example
04:03:41 <Cale> rolly1975: There is a somewhat outdated, but very favourable paper from a while back with a real world study involving a geometry server, comparing implementations across a number of languages.
04:04:03 <rolly1975> Cale: really? do you know where i can find that?
04:04:04 <cizra> http://pastie.caboo.se/119118 -- the last line gives a syntax error. Anyone care to peek at it?
04:04:04 <lambdabot> Title: #119118 - Pastie
04:04:15 <Cale> http://haskell.org/papers/NSWC/jfp.ps
04:04:24 <ivanm> roconnor: thanks for your help over the past few weeks
04:04:26 <roconnor> Cale: this is different from the US military study?
04:04:29 <ivanm> roconnor++
04:04:40 <roconnor> ivanm: no problem.  Sorry I didn't have any applications for ERA. :)
04:04:46 <Cale> cizra: Your last line is equivalent to  rotations a = rot2 (3 [1, 2, 3] [])
04:04:55 <cizra> Yes. Is that wrong?
04:05:03 <cizra> rot2 is supposed to take 3 arguments.
04:05:12 <Cale> 3 is being applied as a function to [1,2,3] and []
04:05:20 <cizra> How many times to rotate, what to rotate and where to stick the results..
04:05:25 <Cale> Just delete the $
04:05:48 <cizra> Oh, a different error now.
04:05:50 <ivanm> roconnor: I ended up making some B$ about how it could be good in apps where you need variable accuracy, but whilst operations are fast getting values would be slow.. and a quick comparison to algebraic arithmetic
04:06:00 <Cale> !paste
04:06:01 <hpaste> Haskell paste bin: http://hpaste.org/
04:07:04 <Cale> ah, I see
04:07:18 <Cale> the type that you've given rotations is more general than the implementation you've provided
04:07:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3925
04:08:05 <Cale> right
04:08:20 <Cale> That list [1,2,3] isn't very general
04:08:31 <cizra> hmm?
04:08:52 <Cale> Well, rotations is supposed to take *any* list
04:08:55 <Cale> and return a list of lists
04:08:59 <cizra> yep
04:09:05 <Cale> of *any* type
04:09:09 <cizra> I hardcoded some values to debug it.
04:09:14 <cizra> Seems it didn't work out too well.
04:09:20 <Cale> But [1,2,3] isn't a list of any type whatsoever
04:09:46 <Cale> You could comment out the type signature.
04:09:57 <cizra> When I replaced that [1, 2, 3] with a, it works perfectly.
04:10:01 <Cale> yes :)
04:10:19 <cizra> and 3 with length a - 1
04:11:21 <hpaste>  ddvlad pasted "GHC failing. Should I ask OS support  instead?" at http://hpaste.org/3926
04:11:37 <Cale> ddvlad: --make
04:11:56 <Cale> ghc --make socket.hs
04:12:15 <Cale> That'll figure out that you need the network package
04:12:23 <Cale> Otherwise you could probably do  -package network
04:12:25 <ddvlad> Cale: I completely overlooked that, sorry. All my previous tries were without other packages.
04:12:34 <ddvlad> thank you very much
04:12:37 <ddvlad> Cale++
04:12:39 <Cale> No problem
04:13:05 <Cale> --make should probably be the default anyway :)
04:13:11 <roconnor> @bab nl en vertraging
04:13:15 <lambdabot>   delay
04:16:49 <Cale> cizra: that's a very strange implementation...
04:18:05 <zeloran> hey
04:18:10 <zeloran> some haskell guru here ?
04:18:14 <Cale> lots
04:18:23 <zeloran> :)
04:18:29 <zeloran> is i ok to paste here?
04:18:34 <Cale> !paste
04:18:34 <hpaste> Haskell paste bin: http://hpaste.org/
04:18:43 <Pseudonym> "Haskell guru" is _slightly_ redundant.
04:18:56 <cizra> Cale: What's strange about it?
04:19:05 <cizra> Cale: I'm a Haskell newbie, so don't expect much..
04:19:34 <olsner> I imagine haskell newbies are better than most other kinds of newbies
04:19:40 <Cale> well, all the appends to the ends of lists are best avoided
04:19:59 <Cale> Also, just the way in which the problem has been broken down
04:20:04 <Taejo> @src concat
04:20:04 <lambdabot> concat = foldr (++) []
04:20:06 <Cale> I'd start out by writing:
04:20:21 <Cale> rot [] = []; rot (x:xs) = xs ++ [x]
04:20:32 <hpaste>  zeloran pasted "Scanner" at http://hpaste.org/3927
04:20:55 <Cale> then use iterate on that
04:21:01 <zeloran> so my problem is
04:21:06 <zeloran> i have to write a scanner
04:21:12 <Cale> > let rot [] = []; rot (x:xs) = xs ++ [x] in iterate rot [1,2,3]
04:21:13 <zeloran> for my university
04:21:21 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,...
04:21:26 <zeloran> i wrote a function scan2 (see paste)
04:21:35 <Pseudonym> zeloran: This is a great way to design this, BTW.
04:21:39 <zeloran> it's able to scan for numbers = list of digits
04:21:40 <olsner> > let rot [] = []; rot (x:xs) = xs ++ [x] in liftM2 take length (iterate rot) [1,2,3]
04:21:40 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
04:21:54 <Pseudonym> However, I'd call it something more meaningful than "scan2".
04:22:02 <zeloran> but i want to make the function scan2 generic
04:22:10 <zeloran> so that it can scan for anything
04:22:12 <zeloran> i want
04:22:22 <zeloran> lets say for number, variables
04:22:24 <zeloran> and more
04:22:35 <Pseudonym> zeloran: Have you considered takeWhile/dropWhile?
04:22:47 <zeloran> now?
04:22:49 <zeloran> no?
04:23:01 <zeloran> is it easier todo with?
04:23:28 <cizra> Cale: Well, my way doesn't require me to know much about standard library (;
04:23:35 <olsner> scan2 is basically takeWhile, dropWhile and read
04:23:41 <Pseudonym> Yeah.
04:23:46 <Pseudonym> That's what I was going to say.
04:23:53 <Cale> cizra: yeah, but still, you can write the equivalent of iterate fairly easily
04:23:53 <zeloran> o yes i see
04:24:02 <zeloran> didn'T know about that function :)
04:24:17 <zeloran> but the problem is another @ pseudo
04:24:29 <Cale> rotations 0 xs = []; rotations n xs = xs : rotations (n-1) (rot xs)
04:24:36 <zeloran> you see line 19 for example?
04:24:38 <Cale> Something like that, for instance.
04:24:46 <Pseudonym> THe lines aren't numbered.  Just a moment,.
04:25:05 <olsner> str2@(x:xs)?
04:25:06 <zeloran> i do "= Num (read str1)"...
04:25:11 <zeloran> i want to make i generic
04:25:12 <Pseudonym> zeloran: Right.
04:25:14 <cizra> Cale: There's always a way to make it better.
04:25:19 <Cale> :)
04:25:20 <Pseudonym> Well, "read" is generic.
04:25:23 <zeloran> so that i can add an additional parameter
04:25:27 <Cale> cizra: That's pretty true :)
04:25:32 <zeloran> so i can use it for anything
04:25:35 <zeloran> not only Num
04:25:44 <zeloran> got it?
04:25:52 <olsner> zeloran: so have it take a function the produces Symbol from String, then apply it to whatever it finds in the end
04:26:04 <zeloran> yes :)
04:26:16 <zeloran> so i can call scan2 with multiple options
04:26:20 <zeloran> like scan for number
04:26:26 <zeloran> scan for variable
04:26:36 <Cale> cizra: But in general, I suggest trying to avoid (++) wherever you can, in favour of (:), since xs ++ ys ends up taking O(length xs) steps to fully evaluate.
04:26:40 <zeloran> by giving to additional parameters
04:26:43 <Cale> @src (++)
04:26:44 <lambdabot> (++) []     ys = ys
04:26:44 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
04:26:55 <Pseudonym> OK.,
04:27:02 <Pseudonym> So you pass in "read" as an argument,
04:27:09 <zeloran> the list of characters that the symbol consists of
04:27:17 <zeloran> and what typ it then should be
04:27:24 <zeloran> i did not get it work
04:27:34 <zeloran> i will show you how i tried
04:27:38 <Pseudonym> OK
04:27:39 <zeloran> one moment pls
04:28:17 <hpaste>  zeloran pasted "Scanner" at http://hpaste.org/3928
04:28:40 <zeloran> so sym1 should save the typ
04:28:49 <Pseudonym> How about this instead:
04:28:56 <zeloran> and set1 the chars
04:28:59 <Cale> Does someone here have a working copy of lambdabot from darcs which they can build?
04:29:01 <Pseudonym> scan2 :: (String -> Symbol) -> ...
04:29:22 <zeloran> for example number = "0123456789" @number
04:29:24 <Pseudonym> So, for example, you could call:
04:29:31 <Pseudonym> scan2 (Num . read) ...
04:29:46 <Cale> (It won't build with 6.8.1 and I'd like to make absolutely sure that the patch to the State/source file I'm about to commit is valid.)
04:30:02 <zeloran> can you make the hole function ?
04:30:09 <zeloran> i'm really new to haskell
04:30:18 <Pseudonym> Sorry, hole function?
04:30:28 <olsner> probably meant whole
04:30:34 <Pseudonym> Ah, right.
04:30:35 <zeloran> oh sorry
04:30:36 <zeloran> xD
04:30:42 <zeloran> yes stupid mistake
04:30:50 <zeloran> whole of course
04:30:51 <Pseudonym> Well...
04:31:10 <Pseudonym> The type signature you know.
04:31:11 <Pseudonym> Then:
04:31:30 <Pseudonym> scan2 f set str1 str2@(x:xs) ....
04:31:32 <Pseudonym> As before.
04:31:35 <Pseudonym> The second rule:
04:31:54 <Pseudonym> scan2 f _ str1 _ = [f str1]
04:35:38 <zeloran> hmm one question
04:35:52 <zeloran> scan (x:str) | isDigit x = takeWhile (`isDigit`) x:str
04:35:56 <zeloran> whats wrong?
04:36:44 <Pseudonym> :t takeWhile
04:36:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:36:54 <Botje> zeloran: why the `` around isDigit?
04:37:07 <Pseudonym> Thing 2: takeWhile takes a list as an argument.
04:37:09 <olsner> f a x:str = (f a x):str
04:37:13 <Pseudonym> You're giving it a single character.
04:37:21 <Pseudonym> Thing 3: takeWhile returns a string.
04:37:33 <Pseudonym> You presumably want to return a list of symbols.
04:37:44 <Pseudonym> THing 4: Don't you want to call scan recursively?
04:37:56 <zeloran> scan (x:str) | isDigit x = takeWhile (isDigit) (x:str)
04:37:58 <zeloran> ?
04:38:12 <olsner> the parens around isDigit are unnecessary
04:38:23 <zeloran> okay
04:38:42 <olsner> and you want to recurse on the rest of the string after the number
04:39:04 <desegnis> zeloran: Also, (x : takeWhile isDigit str) would be more succint
04:39:29 <desegnis> Since you know already that (isDigit x )
04:41:12 <olsner> heh, telling us the incorrect solution basically lured us into write everything for him ;-)
04:41:49 <Elifant> hello all. is anyone interested in generalized version of HughesPJ pretty-printer?
04:43:16 <Pseudonym> olsner: That often works.
04:43:26 <Pseudonym> More likely to help if you show evidence that you've tried.
04:43:34 <oerjan> olsner: there's a quote about that somewhere (i don't think it was lambdabot)
04:43:57 * lambdabot clears throat
04:44:11 <lambdabot> Act smart, and we do your work for you!
04:44:22 <olsner> Pseudonym: yeah, but I didn't even notice until after it was already done
04:45:10 <oerjan> @remember lambdabot Act smart, and we do your work for you!
04:45:10 <lambdabot> It is stored.
04:45:36 <EvilTerran> it's the #haskell version of "linux sucks, it doesn't even do <x>!"
04:45:45 <Pseudonym> ?faq
04:45:45 <lambdabot> The answer is: Yes! Haskell can do that.
04:46:46 <hpaste>  zeloran pasted "Scanner3" at http://hpaste.org/3929
04:46:56 <zeloran> new try xD
04:47:06 <zeloran> still one problem
04:47:24 <EvilTerran> zeloran, incidentally, we tend to use the "annotate" link on previous pastes when pasting new versions, so they're all grouped together and easy to compare
04:47:49 <zeloran> scan ".123." resolves to [Dot,Num 123,Num 23,Num 3,Dot] instead of [Dot,Num 123,Dot]
04:47:59 <Pseudonym> Ah.
04:48:03 <olsner> zeloran: [a]++xs is just a slower way to write a:xs
04:48:06 <Pseudonym> You need to scan (dropWhile isDigit str)
04:48:07 <zeloran> thx Terran, i will do it this way
04:48:11 <cizra> Hm. Can I add stuff to Chars? myChar + 3, for example
04:48:13 <Pseudonym> In the recursive call.
04:48:21 <EvilTerran> > succ 'a'
04:48:32 <lambdabot>  'b'
04:49:19 <EvilTerran> > toEnum.(+3).fromEnum $ 'a' :: Char
04:49:20 <lambdabot>  'd'
04:49:34 <zeloran> wow it works :)
04:49:46 <EvilTerran> cizra, you can't directly, as Char is not an instance of Num
04:49:51 <cizra> OK
04:49:59 <EvilTerran> however, you can do so via its Enum instance, as I've done above
04:50:15 <EvilTerran> > chr.(+3).ord $ 'a'
04:50:16 <lambdabot>  'd'
04:50:22 <EvilTerran> or that
04:50:38 <Jaak> @type \f -> toEnum.f.fromEnum
04:50:39 <lambdabot> forall a a1. (Enum a, Enum a1) => (Int -> Int) -> a1 -> a
04:51:02 <EvilTerran> chr = toEnum and ord = fromEnum anyway, only with more specific types
04:51:25 <integral> it's a shame functions aren't invertible with, conjugate f g = (invert f) . g . f
04:51:42 <zeloran> are takeWhile and dropWhile inbuild functions?
04:51:48 <EvilTerran> ?src takeWhile
04:51:49 <lambdabot> takeWhile _ []                 =  []
04:51:49 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
04:51:49 <lambdabot>                    | otherwise =  []
04:51:53 <olsner> @index takeWhile
04:51:53 <lambdabot> Data.List, Prelude
04:51:57 <EvilTerran> in a word, no. very little's built in
04:52:03 <EvilTerran> ?src (&&)
04:52:03 <lambdabot> True  && x = x
04:52:03 <lambdabot> False && _ = False
04:52:07 <EvilTerran> ?src Bool
04:52:08 <lambdabot> data Bool = False | True deriving (Eq, Ord)
04:52:10 <EvilTerran> etc
04:52:39 <EvilTerran> but it's in the Prelude, so is available by default, if that's what you mean
04:52:59 <EvilTerran> hm...
04:53:00 <EvilTerran> ?src ()
04:53:00 <lambdabot> data () = ()
04:53:04 <EvilTerran> :D
04:53:34 <desegnis> Oh, that last one is a fake.
04:53:46 <EvilTerran> yeah, i figured
04:54:18 <EvilTerran> ?src Int
04:54:18 <lambdabot> data Int = I# Int#
04:54:31 <EvilTerran> ... okay, that's enough of that.
04:55:05 <desegnis> That one isn't, though. GHC internals merely.
04:55:10 <Jaak> @src Integer
04:55:10 <lambdabot> data Integer = S# Int#
04:55:10 <lambdabot>              | J# Int# ByteArray#
04:55:43 <EvilTerran> indeed, desegnis. i think, though, for introducing someone to the language, the () definition is more useful than the Int one
04:56:02 <desegnis> Definitely.
04:56:09 <Pseudonym> ?src Bool
04:56:09 <lambdabot> data Bool = False | True deriving (Eq, Ord)
04:56:25 <EvilTerran> doesn't Bool derive Enum and Ix (and some others?) too?
04:56:41 <Pseudonym> Apparently not.
04:56:46 <Pseudonym> I'd think Enum, Bounded, Ix.
04:57:11 <EvilTerran> ?where prelude
04:57:11 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
04:57:29 <olsner> @pl \str -> Num (read (x : takeWhile isDigit str)) : scan (dropWhile isDigit str)
04:57:30 <lambdabot> ap ((:) . Num . read . (x :) . takeWhile isDigit) (scan . dropWhile isDigit)
04:57:31 <desegnis> Maybe they just aren't derived (although they behave as if derived... strange)
04:57:47 <EvilTerran> data  Bool  =  False | True     deriving (Eq, Ord, Enum, Read, Show, Bounded)
04:58:09 <EvilTerran> according to that thar page from the report
04:58:13 <oerjan> @instances-importing Data.Ix Ix
04:58:13 <Pseudonym> Right.
04:58:14 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
04:58:18 <Pseudonym> Oh.,
04:58:23 <Pseudonym> Right, maybe it's module ordering.
04:58:30 <Pseudonym> Because GHC splits up the Prelude.
04:58:37 <Pseudonym> Perhaps Ix isn't defined yet.
04:59:12 <oerjan> is Ix derivable at all?
04:59:31 <olsner> @ty ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
04:59:32 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
04:59:36 <Pseudonym> ?src Ix
04:59:36 <lambdabot> class (Ord a) => Ix a where
04:59:36 <lambdabot>     range           :: (a,a) -> [a]
04:59:36 <lambdabot>     index           :: (a,a) -> a -> Int
04:59:36 <lambdabot>     inRange         :: (a,a) -> a -> Bool
04:59:36 <lambdabot>     rangeSize       :: (a,a) -> Int
05:00:05 <Pseudonym> It would be if it's an Enum type.
05:00:27 <EvilTerran> much like you'd need an Eq type to derive Ord on it
05:00:30 <oerjan> i mean, by the standard
05:01:09 <oerjan> nope. "Eq, Ord, Enum, Bounded, Show, or Read"
05:06:03 <olsner> btw, lambdacats must be one of the funniest thing I've ever seen
05:06:21 <olsner> @where lambdacats
05:06:21 <lambdabot> http://arcanux.org/lambdacats.html
05:12:07 <Igloo> dons: I don't think so, BICBW
05:15:04 <benny> http://arcanux.org/lambdacats_3.html - lazy evaluation, I don't get it
05:15:05 <lambdabot> Title: Lambdacats
05:15:47 <cizra> benny: Well, maybe a hint that you can make kids anytime, but the results happen on the most unexpected and unconvenient moment?
05:19:30 <olsner> @quote slack
05:19:30 <lambdabot> No quotes match. I feel much better now.
05:20:01 <oerjan> how can you feel better without slack???
05:20:20 <olsner> perhaps she's a masochist
05:22:16 <cizra> Lambdabot is a she?
05:22:32 <oerjan> @vixen are you female?
05:22:32 <lambdabot> i truely am
05:22:48 <cizra> Ooh, cool.
05:23:23 <olsner> whatever use a bot has for a sexual identity... but if she wants it she can have it
05:24:21 <lambdabot> I yam what I yam.
05:24:46 <qrck> yadda yadda yadda
05:25:43 <visof> Prelude> let r = 0
05:25:43 <visof> Prelude> let area r = pi * r ^ 2
05:25:43 <visof> Prelude> area 5
05:25:51 <visof> is this program right?
05:26:08 <visof> area must be equal 0
05:26:17 <Pseudonym> No.
05:26:24 <Pseudonym> r is an argument to area
05:26:41 <visof> and r here equal to 0
05:26:51 <idnar> you passed 5 to area
05:26:59 <oerjan> those two r's are independent
05:27:08 <visof> oh
05:27:15 <oerjan> different scopes
05:27:19 <visof> i understood
05:27:43 <visof> bom bom bom baba
05:28:59 <Nicu> how can i filter under the IO monad? All my tries with lift filter failed
05:29:09 <Pseudonym> Sleep for me.
05:29:10 <Pseudonym> Nytol
05:29:18 <aleator> nicu: filterM ?
05:30:04 <Nicu> Oh, so easy :-)
05:30:05 <zeloran> n8
05:30:42 <zeloran> when i have to chars (h1:h2) is there anyway to convert them to int?
05:31:12 <faxathisia> fromEnum or chr
05:31:20 <faxathisia> and maybe add them..
05:31:38 <zeloran> can read help me?
05:31:40 <Nicu> @aleator: thanks
05:31:40 <lambdabot> Unknown command, try @list
05:32:04 <oerjan> > chr 'A'
05:32:05 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
05:32:13 <oerjan> > ord 'A'
05:32:14 <lambdabot>  65
05:32:42 <oerjan> > digitToInt 'A'
05:32:43 <lambdabot>  10
05:33:23 <oerjan> > read "25" :: Int
05:33:24 <lambdabot>  25
05:36:26 <geocalc> > IntToDigit 98
05:36:26 <lambdabot>   Not in scope: data constructor `IntToDigit'
05:36:44 <oerjan> > show 98
05:36:45 <lambdabot>  "98"
05:37:18 <oerjan> > intToDigit 14
05:37:19 <lambdabot>  'e'
05:37:27 <oerjan> > intToDigit 16
05:37:27 <lambdabot>  Exception: Char.intToDigit: not a digit 16
05:37:41 <geocalc> > chr 98
05:37:42 <lambdabot>  'b'
05:38:35 <geocalc> > map chr [1..128]
05:38:35 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ET...
05:38:44 <idnar> heh
05:39:05 <ray> > map chr [0..127]
05:39:06 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
05:39:09 <ray> better
05:39:24 <geocalc> utf8
05:39:32 <oerjan> > ['\NUL' ..]
05:39:33 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
05:40:10 <Olathe> > ['A'..'Z'] ++ ['a'..'z']
05:40:11 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
05:40:33 <olsner> > map chr [22,63,32,6,33]
05:40:34 <lambdabot>  "\SYN? \ACK!"
05:40:42 <Olathe> Heheh
05:41:51 <olsner> all that's left is finding a really clever function to produce [22,63,32,6,33], then @pl-ing it into oblivion.. sprinkle a few monads in there and the deed is complete
05:44:22 <Olathe> > "take 5 $ foldl' (flip $ scanl (+)) (repeat 0) " ++ show (untower [22,63,32,6,33])
05:44:22 <lambdabot>  "take 5 $ foldl' (flip $ scanl (+)) (repeat 0) [-29,77,-72,41,22]"
05:44:30 <Olathe> > take 5 $ foldl' (flip $ scanl (+)) (repeat 0) [-29,77,-72,41,22]
05:44:31 <lambdabot>  [22,63,32,6,33]
05:45:44 <olsner> @src untower
05:45:44 <lambdabot> Source not found. My mind is going. I can feel it.
05:46:20 <olsner> well, hmm, the reverse function of that fold/scan obviously
05:47:05 * byorgey brain go boom!
05:47:49 <oerjan> i recall the reverse was a bit more complicated
05:49:25 <oerjan> > foldl' (flip $ scanl (+)) (repeat 0) [2,1]
05:49:26 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
05:49:45 <oerjan> > foldl' (flip $ scanl (+)) (repeat 0) [1,2,1]
05:49:46 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
05:49:58 <xerox> triangular numbers!
05:50:12 <oerjan> > foldl' (flip $ scanl (+)) (repeat 0) [2,1,1]
05:50:13 <lambdabot>  [1,2,5,10,17,26,37,50,65,82,101,122,145,170,197,226,257,290,325,362,401,442,...
05:50:22 <oerjan> > foldl' (flip $ scanl (+)) (repeat 0) [2,1,0]
05:50:22 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
05:53:24 <olsner> @ty scanl (+)
05:53:25 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
05:53:28 <oerjan> > map head $ iterate (zipWith(-) . tail) $ foldl' (flip $ scanl (+)) (repeat 0) [2,1,0]
05:53:28 <lambdabot>  Couldn't match expected type `[a]'
05:54:11 <oerjan> > map head $ iterate (join $ zipWith(-) . tail) $ foldl' (flip $ scanl (+)) (repeat 0) [2,1,0]
05:54:13 <lambdabot>  [0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:56:21 <oerjan> > map head . takeWhile (not . null) . iterate (join $ zipWith(-) . tail) $ take 5 $ foldl' (flip $ scanl (+)) (repeat 0) [2,1,0]
05:56:24 <lambdabot>  [0,1,2,0,0]
05:57:31 <oerjan> > map head . takeWhile (not . null) . iterate (join $ zipWith(-) . tail) $ [22,63,32,6,33]
05:57:31 <lambdabot>  [22,41,-72,77,-29]
05:59:36 <EvilTerran> join $ zipWith (-) . tail = join $ fmap (zipWith (-)) tail = zipWith (-) =<< tail
05:59:37 <oerjan> @let tower l = foldl' (flip $ scanl (+)) (repeat 0) l
05:59:38 <lambdabot> <local>:5:0:     Multiple declarations of `L.tower'     Declared at: <local>:...
05:59:49 <oerjan> oh
05:59:54 <oerjan> > untower
05:59:54 <lambdabot>  <[Integer] -> [Integer]>
06:00:26 <oerjan> silly me, didn't realize it was there
06:00:35 <oerjan> > untower [22,63,32,6,33]
06:00:36 <lambdabot>  [-29,77,-72,41,22]
06:01:05 <oerjan> > tower [-29,77,-72,41,22]
06:01:05 <lambdabot>  [22,63,32,6,33,132,293,477,616,613,342,-352,-1653,-3774,-6957,-11473,-17622,...
06:01:25 <geocalc> oops
06:01:25 <olsner> but it's a shame you can't get the source back from @let after the fact
06:01:31 <olsner> @src L.tower
06:01:31 <lambdabot> Source not found. stty: unknown mode: doofus
06:01:45 <olsner> @type tower
06:01:48 <lambdabot> Not in scope: `tower'
06:01:53 <oerjan> i just recalled it from several weeks ago
06:02:51 <olsner> oh! there it is... it disappeared in the bot-spam
06:03:41 <EvilTerran> hm... how does one pronounce the .nl name "Oege"?
06:04:08 <EvilTerran> (sorry, off-topic, i know, but it's tangentially related to haskell, i assure you)
06:04:09 <astrolabe> Space leaks in C#? http://www.codeproject.com/showcase/IfOnlyWedUsedANTSProfiler.asp
06:04:09 <lambdabot> Title: If Only We’d Used ANTS Profiler Earlier... - The Code Project - Product Showcase
06:05:17 <oerjan> as a general rule, i don't try to pronounce dutch names :D
06:05:31 <MyCatVerbs> oerjan: I hate Dijkstra.
06:05:42 <MyCatVerbs> oerjan: absolutely loathe the guy.
06:06:06 <MyCatVerbs> oerjan: why the *fuck* does the damn bastard have to be so completely unpronouncable!? =D
06:07:23 <EvilTerran> that's easy to pronounce, though; "ee doubleyuu dee"
06:07:46 <geocalc> simple just say you
06:07:48 <desegnis> EvilTerran: Probably ['u:É£É™]
06:08:11 <EvilTerran> desegnis, i'm afraid you've out-unicoded my font
06:08:13 <olsner> MyCatVerbs: isn't it just deekstra? or dykestra?
06:08:30 <EvilTerran> olsner, i believe it's dykestra
06:08:30 <astrolabe> You mean it's not pronounced DICK-STRA?
06:08:41 <geocalc> !
06:09:09 <olsner> I've always read ij as "probably 'ee' or 'eye'"
06:09:50 <astrolabe> To me it is clear that the j was a typo made by one of his distant ancestors.
06:10:18 <oerjan> alas, no.  i hear "ij" is considered a single letter in dutch
06:11:45 <pejo> There's plenty of dutch people around here, should just ask them.
06:11:45 <olsner> astrolabe: hmm, I thought reference-hogging was a well-known problem in java/c#-land
06:11:56 <desegnis> EvilTerran, that's a pity. anyway, it's a long oo [u], followed by a sound similar to Scottish ch in loch (or German ch in ach, or Spanish j in Juan), followed by a shwa
06:11:58 * EvilTerran can only remember how to spell it because "ijk" happen to be in alphabetical order
06:12:15 <oerjan> pejo: no! let's WRESTLE the LANGUAGE out of their HANDS!
06:12:25 <xerox> ijk=-1
06:12:36 <desegnis> (That's only according to dutch spelling rules, though. I don't know that particular name.)
06:12:53 <olsner> xerox: D(-1)stra :P
06:13:18 <xerox> haha.
06:13:20 <astrolabe> heh
06:13:44 <EvilTerran> desegnis, ah, thanks. i'll try to remember that... it'll probably be closer than anything i'd've guessed myself
06:14:28 <scook0> I remember hearing that it was pronounced "dekstra"
06:15:21 <olsner> DECK-stra? I guess that works too
06:15:21 <qrck> schach dijkstra lochness ?
06:15:28 <qrck> +w ?
06:15:33 <qrck> lol
06:15:35 <desegnis> Dutch ij is indeed pronounced like eye. (Or aye, in some dialects.)
06:17:43 <visof> when i compile this program :
06:17:46 <visof> main = do
06:17:46 <visof>   putStrLn "Please enter your name: "
06:17:46 <visof>   name <- getLine
06:17:46 <visof>   putStrLn ("Hello, " ++ name ++ ", how are you?")
06:17:52 <visof> i have error?
06:17:58 <olsner> desegnis: isn't aye pronounced like eye?
06:18:13 <faxathisia> visof: Such as?
06:18:27 <geocalc> aÃ¯
06:19:01 <visof> faxathisia   <no location info>: can't find file: vanfun.hs
06:19:01 <visof> Failed, modules loaded: none.
06:19:30 <geocalc> bad ghc
06:19:31 <faxathisia> looks like you have saved the file in a different place I guess?
06:19:36 <visof> varfun.hs:1:7: Empty 'do' construct
06:19:36 <visof> Failed, modules loaded: none.
06:19:42 <desegnis> olsner: Merriam-Webster online pronounces aye like in bay, IPA É›Éª. Of course, if you pronounce bay like I'd pronounce buy, ...
06:20:08 <faxathisia> visof: why don't you hpaste the cdoe
06:20:20 <olsner> oh, aye is ay as in bay..
06:20:40 <geocalc> Ã¨
06:20:48 <visof> i put it above
06:20:53 <visof> did you see it?
06:20:57 <faxathisia> visof: yes
06:21:03 <LPhas> anyone knows why Data.Bytestring.Base is disappeared?
06:21:32 <Lemmih> LPhas: It's Data.ByteString.{Internal|Unsafe} now.
06:22:04 <astrolabe> visof: Could you hpaste it anyway?
06:22:07 <astrolabe> @paste
06:22:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:22:16 <geocalc> LPhas=<< look at the change log of ghc
06:23:12 <hpaste>  visof pasted "first haskell program" at http://hpaste.org/3930
06:23:43 <faxathisia> visof: It works fine for me, How did you try to load it?
06:23:48 <LPhas> Lemmih: i imported both Internal and Unsafe but i can't find packAddress :| hmp3 seems broken
06:24:05 <Lemmih> LPhas: packAddress is no more.
06:25:06 <visof> faxathisia i had  varfun.hs:1:8: Empty 'do' construct     Failed, modules loaded: none.
06:25:16 <faxathisia> visof: How did you try to load the program?
06:25:36 <visof> :l varfun.hs
06:25:38 <astrolabe> visof: What line did you type to call the compiler.
06:25:42 <visof> in ghci
06:25:46 <astrolabe> Ah
06:26:05 <geocalc> bad ghc
06:26:09 <faxathisia> visof: all I can say is check the file was saved .. and you're in the right directory
06:27:46 <visof> it run
06:36:44 <Cale> !paste
06:36:44 <hpaste> Haskell paste bin: http://hpaste.org/
06:36:47 <visof> @paste
06:36:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:37:00 <Cale> yeah, paste the code from your file :)
06:37:02 <LPhas> Lemmih: @#%Â£$ hmp3 uses packaddress
06:37:06 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3931
06:37:39 <hpaste>  visof pasted "help" at http://hpaste.org/3932
06:37:51 <visof> please help
06:38:15 <visof> i had error with this
06:38:41 <LoganCapaldo> @type (*)
06:38:43 <lambdabot> forall a. (Num a) => a -> a -> a
06:38:49 <LoganCapaldo> @type getLine
06:38:50 <lambdabot> IO String
06:38:55 <LoganCapaldo> @type readLn
06:38:56 <lambdabot> forall a. (Read a) => IO a
06:39:00 <LoganCapaldo> ^^
06:39:42 <LoganCapaldo> You want readLn not getLine. getLine will always give you a string and you can't multiply or divide strings
06:39:50 <LoganCapaldo> > "abc" * "z" / 2
06:39:51 <lambdabot>   add an instance declaration for (Fractional [Char])
06:39:51 <lambdabot>     In the expression: ...
06:40:07 <visof> oh
06:40:13 <xerox> ?type read <$> getLine
06:40:14 <MyCatVerbs> olsner: I'm really bad at pronouncing names *anyway*.
06:40:14 <lambdabot> forall a. (Read a) => IO a
06:40:23 <visof> can i use show rather than pustrln?
06:40:25 <MyCatVerbs> olsner: EWD is just... pathalogical to me. :)
06:40:46 <MyCatVerbs> visof: show converts something to a string. putStrLn takes a string at puts it to standard output.
06:40:47 <LoganCapaldo> you can use show in conjunction with putStrLn
06:41:02 <MyCatVerbs> visof: most commonly, you use them together.
06:41:52 <LoganCapaldo> eg putStrLn ("I am " ++ (show 23))
06:42:02 <MyCatVerbs> :t let printonaline x = putStrLn (show x)
06:42:03 <lambdabot> <local>:5:0:
06:42:03 <lambdabot>     Multiple declarations of `L.tower'
06:42:03 <lambdabot>     Declared at: <local>:1:0
06:42:14 <MyCatVerbs> ...what the Hell? *pokes lambdabot*
06:42:23 <visof> haha
06:42:24 <LoganCapaldo> L.tower?
06:42:33 <LoganCapaldo> what's tower?
06:42:34 <EvilTerran> ?src print
06:42:34 <lambdabot> print x = putStrLn (show x)
06:42:52 <olsner> MyCatVerbs: and then we only discuseed the surname... Edsger Wybe - chew on that one for a while!
06:42:55 <MyCatVerbs> > putStrLn ("By the power of... " ++ "Greyskull!")
06:42:56 <lambdabot>  <IO ()>
06:43:14 <MyCatVerbs> Heh, whoopsy, forgot that \bot isn't ghci. >_>
06:43:17 <MyCatVerbs> olsner: AIIIIEEEEE!
06:43:30 <byorgey> :t let q = 3 in q
06:43:30 <lambdabot> forall t. (Num t) => t
06:43:54 <byorgey> :t let printonaline x = putStrLn (show x)
06:43:55 <lambdabot> <local>:5:0:
06:43:55 <lambdabot>     Multiple declarations of `L.tower'
06:43:55 <lambdabot>     Declared at: <local>:1:0
06:44:09 <byorgey> :t let foo x = putStrLn x
06:44:10 <lambdabot> <local>:5:0:
06:44:10 <lambdabot>     Multiple declarations of `L.tower'
06:44:10 <lambdabot>     Declared at: <local>:1:0
06:44:24 <byorgey> ok, that's seriously weird
06:44:40 <byorgey> oh, well, there's no 'in'
06:44:43 <LoganCapaldo> @type L.tower
06:44:44 <lambdabot>     Interface file inconsistency:
06:44:44 <lambdabot>       home-package module `L' is mentioned,
06:44:44 <lambdabot>       but does not appear in the dependencies of the interface
06:44:55 <LoganCapaldo> madness
06:44:58 <byorgey> but you'd think it would give a better error message
06:45:05 <byorgey> :t let foo x = putStrLn x in foo
06:45:06 <lambdabot> String -> IO ()
06:45:19 <EvilTerran> it'd probably go away if we @undef
06:45:27 <visof> putStrLn ("the area of the triangle is : " ++ (show result)
06:45:34 <visof> is this the right?
06:45:42 * LoganCapaldo hands visof a )
06:45:46 <LoganCapaldo> you dropped this :)
06:45:53 <visof> ok
06:45:58 * EvilTerran steals the ), and visof's first (, and gives him a $ instead
06:45:58 <LoganCapaldo> but yes
06:46:11 <EvilTerran> ;)
06:46:18 <visof> haha
06:47:02 * olsner then @pl's it into putStrLn . ("..." ++) . show $ result
06:47:10 <visof> varfun.hs:6:7: parse error on input `='
06:47:11 <visof> Failed, modules loaded: none.
06:47:23 <visof> i had this when compiled the program
06:47:24 <visof> ?
06:47:43 <LoganCapaldo> let result = ...
06:47:49 <LoganCapaldo> not result = ...
06:47:55 <hpaste>  visof pasted "help" at http://hpaste.org/3933
06:47:58 <LoganCapaldo> you dneed the let in the do block
06:48:04 <visof> ok
06:48:21 <hpaste>  zigong pasted "config.hs" at http://hpaste.org/3934
06:50:13 <visof> i had errors
06:50:27 <visof> can some one type the right code then paste it
06:50:28 <visof> ?
06:52:09 <desegnis> visof: Indent lines 2-7.
06:52:33 <LoganCapaldo> shouldn't need to
06:53:01 <Saizan_> however it lacks a let, and some read-s
06:53:11 <LoganCapaldo> yes
06:53:17 <LoganCapaldo> bu we went over that already
06:53:26 <visof> LoganCapaldo please wrtie the right code
06:53:29 * LoganCapaldo assumes hes chaged his code
06:53:36 <hpaste>  zigong pasted "config.hs" at http://hpaste.org/3935
06:53:56 <desegnis> Oh, you're right obout the indent, LoganCapaldo. So I learnt something again
06:54:04 <EvilTerran> visof, if we write all your code for you, how will you learn?
06:54:08 <hpaste>  byorgey annotated "help" with "use readLn and let" at http://hpaste.org/3933#a1
06:54:22 <LoganCapaldo> visof: can you annoate your paste with the changes yu made?
06:55:03 <hpaste>  visof pasted "help" at http://hpaste.org/3936
06:55:12 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3937
06:55:15 <byorgey> visof: is there some particular tutorial or book you are going through?
06:55:30 <visof> wikibook
06:55:35 <EvilTerran> #haskell is not the magic code genie. we won't be infinitely helpful, no matter how patient we may first appear.
06:55:54 <LoganCapaldo> visof: ok that's some progress, but result doesn't need the parameters
06:56:28 <LoganCapaldo> what you had before result = bae * height / 2 was ok, you just needed the let result = base ...
06:56:47 <LoganCapaldo> but you still haven't fixed your input
06:56:52 <matthew-_> @seen njbartlett
06:56:53 <lambdabot> I saw njbartlett leaving #scala and #haskell 1h 56m 22s ago, and .
06:56:55 <hpaste>  visof pasted "help" at http://hpaste.org/3938
06:57:03 <LoganCapaldo> you either need to read those strings or use readLn
06:57:28 <LoganCapaldo> ok you could do it like that he
06:58:43 <hpaste>  LoganCapaldo annotated "help" with "(no title)" at http://hpaste.org/3938#a1
06:59:04 <faxathisia> @hoogle (a -> Bool) -> [a] -> Bool
06:59:05 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
06:59:05 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
06:59:23 <EvilTerran> visof, could you use "annotate" on an existing paste instead of creating a new paste every time? you're clogging up the "recent pastes" list a bit there.
06:59:41 <EvilTerran> and that way we could more easily compare different versions of your code
07:00:22 <visof> EvilTerran ok and sorry
07:00:46 <visof> LoganCapaldo why we  use read here?
07:02:24 <LoganCapaldo> getLine gives you an IO String
07:02:43 <LoganCapaldo> as I mentioned before you can't add subtract or divide strings
07:02:55 <geocalc> visof=<< finnish your tutorial alone ;)
07:03:07 <LoganCapaldo> read is one way of converting a string into a number (whether an Int, Double, etc.)
07:03:24 <visof> geocalc ok
07:03:26 <LoganCapaldo> > "2" + "3"
07:03:27 <lambdabot>   add an instance declaration for (Num [Char])
07:03:27 <lambdabot>     In the expression: "2" + "...
07:03:37 <LoganCapaldo> > (read "2") + (read "3")
07:03:38 <lambdabot>  5
07:03:44 <Saizan_> geocalc: questions are welcomed here.
07:03:58 <visof> thanks LoganCapaldo
07:04:28 <faxathisia> > ((+) `on` read) "2" "3"
07:04:29 <lambdabot>  5
07:05:11 <geocalc> i know but the evidence is visof must read his tutorial too Saizan_
07:05:44 <EvilTerran> Saizan_, yes, but questions without any apparent comprehension of the previous answers start to get rather tedious
07:06:55 <EvilTerran> i'm sure i've seen people kicked out of here before for expecting us to do their work for them
07:07:10 <visof> i don 't read aboput "Read function before" but in the exercise of  Haskell/Simple input and output section need it
07:07:20 <visof> about*
07:07:42 <visof> is this English make sense?
07:08:09 <faxathisia> visof: not really.. Which tutorial is it?
07:08:29 <visof> http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output
07:08:30 <lambdabot> Title: Haskell/Simple input and output - Wikibooks, collection of open-content textbook ...
07:08:42 <vincenz> EvilTerran: homework people aren't kicked, simply told we do not help
07:08:57 <faxathisia> visof: it says here, "Hint: you can use the function read to convert user strings like "3.3" into numbers like 3.3 and function show to convert a number into string."
07:09:05 <visof> this isn't home work
07:09:26 <faxathisia> visof: So I think you expected to look up the functions 'read' and 'show'
07:09:32 <vincenz> anywho
07:09:44 <faxathisia> visof: e.g. http://www.zvon.org/other/haskell/Outputprelude/read_f.html
07:09:44 <lambdabot> Title: Haskell : read
07:09:50 <vincenz> Saizan_, EvilTerran: The way to handle such questions is to help them structure their thoughts instead of providing pieces of the answer :)
07:09:50 <EvilTerran> i guess the person i was thinking of was being rather obnoxious in other ways, too (impatient, so repeating questions when people didn't answer immediately, iirc)
07:10:10 <geocalc> and use :t visof
07:10:17 <vincenz> Then when they have -specific- questions like "function to do x" (aka api questions) do you answer thos
07:10:34 <EvilTerran> quite
07:10:40 <EvilTerran> or steer them to hoogle ;)
07:10:45 <vincenz> right :)
07:10:57 <vincenz> give a man fish, he has food for one day, teach him how to fish, he can eat for a lifetime
07:11:17 <vincenz> visof: what are you supposed to do?
07:11:26 <LoganCapaldo> I generaly prefer more than just a fish for my day's food allowance but I may be a glutton
07:11:53 <EvilTerran> tuna?
07:11:56 <vincenz> LoganCapaldo: it's a famous quota
07:11:58 <visof> i will learn to fish
07:12:01 <vincenz> s/e-a
07:12:17 <vincenz> visof: No I mean, you should destructure your problem in a set of sub problems, then try to solve each piece
07:12:24 <vincenz> visof: so write down, step by step what you think the program should do :)
07:12:27 <LoganCapaldo> vincenz: I know, I was just making ajoke :)
07:12:32 <vincenz> :)
07:12:47 <EvilTerran> hehe, "famous quota"... "can I have some more fish, please?" "no, damnit! you only get one!"
07:12:49 <visof> vincenz ok
07:12:58 <faxathisia> visof: Did what I say help
07:13:00 <faxathisia> visof: ?
07:13:04 <vincenz> hehe
07:13:13 <Toxaris> "give a man fish" doesn't say anything about how many fish he get
07:13:30 <Toxaris> (as far as i understand english)
07:13:39 <visof> faxathisia ya
07:13:47 <EvilTerran> it's often misquoted as "give a man a fish...", though
07:13:48 <vincenz> Toxaris: I forgot the 'a'
07:13:53 <vincenz> no I misquoted :)
07:14:02 <LoganCapaldo> yeah but I think that was just a misquoting, I've usually heard it as if you give a man _a_ fish
07:14:05 <EvilTerran> i've seen both with approximately even frequency.
07:14:13 <EvilTerran> i prefer the fire version, actually
07:14:27 <vincenz> give a man fire, he burns himself for a day, teach him how to make a fire, he burns himself every day?
07:14:27 <LoganCapaldo> warm for the rest of his life :)
07:14:31 <qrck> give a man a rod or an net ....
07:14:36 <EvilTerran> "give a man fire, and he'll be warm for a night. set a man on fire, and he'll be warm for the rest of his life"
07:14:43 <vincenz> LOL
07:14:44 <qrck> keep your stinky fishes to yourselves....
07:14:45 <qrck> lol
07:14:55 <olsner> EvilTerran: famous quota, lol
07:15:09 <vincenz> typo on my part :
07:15:10 <vincenz> |
07:19:07 * faxathisia wonders what techniques to use to solve minesweeper..
07:19:25 <faxathisia> It's very easy with logic programming but possibly not the most efficient
07:19:40 <qrck> sheep techniques
07:19:48 <qrck> you send them first over the fields....
07:19:51 <qrck> lol
07:19:53 <faxathisia> hehe
07:19:53 <qrck> then bang
07:20:00 <qrck> and you have food
07:20:01 <qrck> lol
07:20:08 <LoganCapaldo> yeah but every bang you loose points
07:21:32 <qrck> buuuut i can make points myself.....
07:21:36 <qrck> lol
07:21:44 <qrck> LOL
07:47:28 <defcons> @hoogle [a] -> Bool
07:47:29 <lambdabot> Prelude.null :: [a] -> Bool
07:47:29 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
07:47:29 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
07:49:19 <pitecus> if I have data type like "data Foo a = MakeFoo { slot :: a }" how can I do an export so that slot can be used to get the value out of a record but not to change it?
07:49:47 <shachaf> pitecus: You could write your own slot function.
07:50:11 <pitecus> shachaf, i see
07:50:54 <shachaf> pitecus: (There might be a better way.)
07:51:04 <allbery_b> and don't export the constructor MakeFoo, just the type
07:51:38 <allbery_b> actually I thnk you can just export Foo (slot)
07:51:43 <pitecus> allbery_b, yes I knew that one
07:52:12 <allbery_b> hm, wait, record update syntax might still work in that case
07:52:15 <byorgey> but in that case can you say 'foo {slot = x}'
07:52:17 <byorgey> right
07:52:55 <pitecus> yeah that was my problem
07:53:50 <byorgey> I think shachaf's suggestion is good.  In general, the solution to this sort of problem is, just export the type (not any of its constructors etc.) and then export other functions to allow whatever operations on it you want.
07:54:37 <pitecus> OK thanks
08:01:03 <defcons> module Shop
08:01:04 <defcons> import Prelude hiding (lookup)
08:01:07 <defcons> what is wrong with my syntax?
08:01:22 <shachaf> defcons: The where is missing.
08:01:26 <shachaf> defcons: module Show where.
08:01:30 <defcons> aah, comes after where?
08:01:32 <defcons> okay thanks
08:01:38 <shachaf> s/w/p/
08:02:09 <Toxaris> shachaf: module Shop phere?
08:02:27 <shachaf> Toxaris: I didn't say s/w/p/g, did I?
08:02:41 <defcons> module Shop where
08:02:41 <defcons>     import Prelude hiding (lookup)
08:02:45 <defcons> still not loading
08:03:17 <shachaf> defcons: That works for me.
08:03:33 <defcons> I have type definitions afterwards
08:03:40 <defcons> could this be because of indentation?
08:03:40 <shachaf> defcons: If you have code after the import, you shouldn't indent the import.
08:04:00 <Toxaris> shachaf: hmm ok.
08:04:03 <defcons> okay works thanks
08:08:45 <Gizgiz> filled.inbox@gmail.comfilled.inbox@gmail.com
08:09:00 <defcons> wtf
08:24:19 <sorear> @seen bringert
08:24:19 <lambdabot> I saw bringert leaving #ghc and #haskell 1h 13m 15s ago, and .
08:29:34 <vincenz> re
08:30:16 <Saizan_> has anyone written something like Data.Binary.GetT IO with a privitive to add more bytes to the Get stream?
08:31:17 <puusorsa> if i have something like: data Foo = Foo SomeType SomeOtherType AndSoOn, and have a list of strings, all parts of foo are instances of read, how can i get from [String] to Foo with least typing?
08:32:25 <IW32> can a counter be set in haskell to do a opertion n number of times ?
08:32:52 <Saizan_> IW32: we usually use replicate or replicateM
08:32:55 <Saizan_> ?type replicate
08:33:06 <Saizan_> bot gone?
08:33:11 <lambdabot> thread killed
08:33:15 <puusorsa> funny how hard things are easy in haskell and something like this that should be easy aren't immediatly obvious
08:33:36 <IW32> i am building a game but i want the user to have only 8 tries
08:33:57 <sorear> IW32: pass around a value triesLeft
08:34:14 <vincenz> puusorsa: list of string or a string?
08:34:34 <IW32> i define let tries = 8, do play the game then tries = tries - 1, can that be done
08:34:36 <IW32> ?
08:34:53 <geocalc> what game IW32 ?
08:34:55 <thetallguy> or use a list [7,6..0]
08:34:56 <sorear> IW32: uhuh?  let tries = 8 isn't even valid syntax
08:34:57 <vincenz> puusorsa: something like
08:35:01 <vincenz> let [a,b,c] =list
08:35:02 <puusorsa> well, tab limited string to begin with, but i split it so it's a list of strings
08:35:09 <vincenz>   in Foo (read a) (reaad b) (read c)
08:35:17 <sorear> puusorsa: read . (" Foo"++) . intercalate " "
08:35:18 <vincenz> puusorsa: oh, there's an easier way
08:35:18 <puusorsa> ..thanks
08:35:23 <vincenz> sorear: what sorear said
08:35:27 <vincenz> asusming
08:35:27 <puusorsa> sorear, thanks!
08:35:32 <sorear> "Foo " rather
08:35:32 <vincenz> there's no problems with priorities
08:35:40 <vincenz> sorear: was just going to propose that :)
08:36:12 <puusorsa> the Foo (read a) (read b) ... i figured out but i was hoping there was something better
08:36:18 <vincenz> the issue with
08:36:24 <vincenz> read ("foo " ++ ..)
08:36:28 <vincenz> is if your data is like
08:36:35 <vincenz> "Bar Bim" "Bom"
08:36:40 <vincenz> you'd need parens around the first then
08:36:46 <vincenz> you can always do
08:37:13 <IW32> what about tries = 8 , tries = tries - 1, i'm using A KINDA INTERACTIVE THING
08:37:14 <vincenz> read . ("Foo " ++) . intercalate " " . map (\x -> '(':x ++ ")")
08:37:46 <Saizan_> > let tries = tries -1 in tries
08:37:50 <lambdabot>  Exception: <<loop>>
08:38:18 <vincenz> you need a state monad
08:38:23 <sorear> no!
08:38:35 <sorear> you just need to pass around the values.
08:38:35 <vincenz> eh?
08:38:42 <vincenz> sorear: state monad does that :)
08:38:47 <vincenz> s -> (a, s)
08:38:47 <sorear> foo triesLeft = ... foo (triesLeft - 1)
08:39:16 <sorear> vincenz: and also massively obfuscates code, I wouldn't use it unless there is some compelling reason like "My code is already in IO"
08:39:26 <vincenz> sorear: that's a matter of opinion
08:39:39 <sorear> vincenz: besides, this person thinks "let tries = 8" is valid syntax, I don't think he's ready for monads
08:39:48 <vincenz> sorear: idem
08:39:49 <dylan> hrm, any examples of using STArrays?/
08:39:56 <faxathisia> let tries = 8 is valid ? :S
08:40:05 <chessguy> > let tries = 8 in tries;
08:40:05 <lambdabot>  Parse error at ";" (column 23)
08:40:12 <chessguy> > let tries = 8 in tries
08:40:13 <lambdabot>  8
08:41:09 <sorear> chessguy: I said "let tries = 8", not "let tries = 8 in <expr>"
08:41:19 <chessguy> details, details
08:41:36 <faxathisia> > (0,0) <= (1,-1)
08:41:37 <lambdabot>  True
08:41:41 <faxathisia> bah!
08:41:41 <sorear> faxathisia: not in Haskell expressions (yes in GHCi, do)
08:41:43 <dbueno> Hi, all: I compiled a program with -O2 -prof -auto-all and ran it with +RTS -p: the .prof file produced says "$f9" is the function with the highest overall cost centre; what does $f9 mean?
08:42:16 <sorear> dbueno: Can't say without more data.
08:42:26 <faxathisia> How do you check if a coordinate (Int,Int) is inside a rectangle ((Int,Int),(Int,Int)) ? :|
08:42:28 <dbueno> I can't find the answer in ch. 6 (at least not in the first few sections) and googling is not revealing anything useful.
08:42:34 <dbueno> sorear: Such as?
08:43:00 <sorear> dbueno: The complete source code, so I can run the compiler and examine the dumps.  $f9 is a gensym.
08:43:31 <dbueno> sorear: I figured it was; how can I find out to which expression it corresponds?  Which dumps are you referring to?
08:44:19 <faxathisia> When I say rectangle.. I mean N-dimensional
08:44:22 <faxathisia> sorry
08:44:30 <faxathisia> not just 2
08:44:33 <sorear> dbueno: -ddump-simpl.  you'll find a function named $f9, figure out what it does and determine what in the source code does it.
08:44:41 <dbueno> sorear: Thanks.
08:44:43 <byorgey> faxathisia: so you actually have n-tuples?
08:44:57 <sorear> dbueno: also, report a @bug, the compiler really should be tracking SCCs better...
08:45:01 <sorear> @bug
08:45:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
08:45:06 <sorear> erm
08:45:11 <faxathisia> They are always 2 tuples hm :|
08:45:15 <IW32> let tries = 8 then -1 each time, when it at zero the came ends
08:45:23 <faxathisia> I think I should just write this for the 2x2 case and ignore generality
08:45:24 <IW32> think that would ork?
08:45:25 <Saizan_> is hGetChar guaranteed to read only one byte from the handle?
08:45:30 <sorear> http://hackage.haskell.org/trac/ghc/wiki/ReportABug
08:45:32 <lambdabot> Title: ReportABug - GHC - Trac
08:45:45 <faxathisia> IW32: No I don't think that would work
08:46:06 <faxathisia> IW32:  what language[s] are you coming from?
08:46:08 <sorear> Saizan_: No, it's guaranteed to read one character.  In GHC this is a byte, in Hugs it uses your locale.
08:46:23 <sorear> e.g. a UTF8 sequence for en_US.UTF8
08:46:35 <byorgey> faxathisia: create a newtype and write your own Ord instance?
08:46:43 <faxathisia> byorgey: :|
08:46:49 <sorear> Saizan_: If you want binary IO, use hGetBuf and/or Data.ByteString
08:46:55 <byorgey> faxathisia: the Ord instance for tuples uses lexicographic ordering
08:47:03 <sorear> byorgey: pfft, that's not a total order
08:47:25 <Saizan_> sorear: it's a bit ugly to read a singleton ByteString to just get a Word8..
08:47:34 <byorgey> sorear: who says Ord instances have to define total orders?
08:47:56 <sorear> Saizan_: I agree.  Tell that to the library maintainers.
08:48:23 <dbueno> sorear: It looks like $f9 is a typeclass instance.  I should file a bug that some name better than $f9 should be reported in profiling?
08:48:34 <sorear> byorgey: Section 6.3.2 of the Haskell 98 Language and Libraries Report
08:48:44 <byorgey> sorear: oh.
08:49:09 <Toxaris> byorgey: the documentation ("The Ord class is used for totally ordered datatypes.") and the result type of the Ord-methods. What should (a < b) return if a and b are not comparable?
08:49:45 <sorear> dbueno: Oooh, smells like http://hackage.haskell.org/trac/ghc/ticket/1641
08:49:46 <lambdabot> Title: #1641 (Binders generated by instance deriving are affected by -auto-all) - GHC - ...
08:49:49 <Toxaris> and more important, what should compare a b return?
08:50:12 <faxathisia> @hoogle [m a] -> [a]
08:50:13 <lambdabot> Prelude.cycle :: [a] -> [a]
08:50:13 <lambdabot> Prelude.init :: [a] -> [a]
08:50:13 <lambdabot> Prelude.reverse :: [a] -> [a]
08:50:20 <faxathisia> @hoogle Monad m => [m a] -> [a]
08:50:20 <lambdabot> Prelude.cycle :: [a] -> [a]
08:50:20 <lambdabot> Prelude.init :: [a] -> [a]
08:50:20 <lambdabot> Prelude.reverse :: [a] -> [a]
08:50:23 <faxathisia> huh? :|
08:50:27 <byorgey> Toxaris: well, a < b could just return False (being careful not to assume that means a >= b) but good point with 'compare'.
08:50:37 <dbueno> sorear: I'm not deriving the instance, but it does look similar.
08:50:49 <byorgey> faxathisia: so, define your own POrd class and make an instance of it =)
08:50:52 <vincenz> a <= b === a `compare` b == LT
08:50:57 <vincenz> a <= b === a `compare` b == LT || EQ
08:51:06 <vincenz> byorgey: Maybe Ordering :)
08:51:17 <byorgey> vincenz: right =)
08:51:18 <faxathisia> byorgey: I think it's probably slow.. but I found indices which lists all indices so I just do an elem check to see if I am in bounds
08:51:27 <vincenz> byorgey: or if you're evil
08:51:27 <faxathisia> I'll just replace it if is really slow later on
08:51:30 <vincenz> (Monad m) => m Ordering
08:51:38 <byorgey> faxathisia: yeah, that sounds pretty slow... =)
08:51:44 <Toxaris> byorgey: but a < b should be not (a >= b) according to default implementations
08:51:48 <byorgey> O(n) instead of O(1)
08:51:48 <faxathisia> @hoogle (Monad m) => [m a] -> m [a]
08:51:49 <lambdabot> Prelude.head :: [a] -> a
08:51:49 <lambdabot> Prelude.last :: [a] -> a
08:51:54 <faxathisia> argh
08:52:03 <vincenz> faxathisia: sequence
08:52:06 <vincenz> @type sequence
08:52:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:52:12 <faxathisia> sequence doesn't do the right thing
08:52:16 <byorgey> Toxaris: I know.  You'd just have to make sure to override all the defaults.
08:52:18 <vincenz> faxathisia: then be more specific
08:52:30 <faxathisia> I don't think I can be more specific in the type system
08:52:30 <Jaak> [m a] -> [a] -- doesnt make much sense
08:52:32 <vincenz> faxathisia: in terms of monads, it doesn, it executes actions left to right as expected
08:52:44 <byorgey> Toxaris: mind you, I'm convinced it's not a good idea, I'm just saying it could almost-sort of work =)
08:53:00 <IW32> > foo triesLeft = ... foo (triesLeft - 1)
08:53:00 <lambdabot>  Parse error at "=" (column 15)
08:53:16 <Toxaris> byorgey: hehe ok :)
08:53:52 <sorear> faxathisia: then don't describe it with types, use English :P
08:54:09 <LoganCapaldo> @type concat
08:54:10 <lambdabot> forall a. [[a]] -> [a]
08:54:19 <LoganCapaldo> let m = [] :)
08:54:31 <faxathisia> to turn [Just 1, Nothing, Just 2] into [1,2]
08:54:34 <Jaak> @type join
08:54:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:54:39 <faxathisia> Is there a better way than concatMap (\x -> case x of Just y -> [y] ; _->[]) ?
08:54:43 <Jaak> maybe this is what you are looking for
08:54:53 <LoganCapaldo> > catMaybes [Just 1, Nothing, Just 2]
08:54:54 <lambdabot>  [1,2]
08:55:04 <LoganCapaldo> it's not monadic :)
08:55:05 <faxathisia> @src catMaybes
08:55:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
08:55:11 <faxathisia> aha :D
08:55:11 <LoganCapaldo> don't get stuck in any boxes
08:55:16 <faxathisia> ok great thanks
08:55:16 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3940
08:55:17 <Toxaris> @hoogle [Maybe x] -> [x]
08:55:18 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
08:55:18 <LoganCapaldo> @type catMaybes
08:55:19 <lambdabot> forall a. [Maybe a] -> [a]
08:55:23 <IW32> @hoogle elem
08:55:23 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
08:55:23 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
08:55:23 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
08:55:59 <LoganCapaldo> incidently
08:56:09 <LoganCapaldo> @hoogle [Maybe a] -> [a]
08:56:09 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
08:56:20 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3941
08:56:28 <LoganCapaldo> there was a way to get more specific in the type system, you just weren't using it :)
08:57:52 <Toxaris> comp = uncurry from that hpaste above
08:58:55 <Toxaris> > inRange ((1, 1), (3, 3)) (2, 2)
08:58:57 <lambdabot>  True
08:59:24 <vincenz> this is the wrong abstractin
08:59:26 <vincenz> don't use lists
08:59:28 <vincenz> usee tuples
08:59:33 <vincenz> or your points might not all have the same dimensionality
08:59:35 <vincenz> and once you have tuples
08:59:38 <vincenz> you can use Ix
08:59:42 <vincenz> to do inRange
08:59:42 <Corun> Oh, er, oops
08:59:44 <vincenz> like Toxaris showed
08:59:53 <Corun> Er er, I didn't mean my pastes to go in to #haskell
08:59:59 <LoganCapaldo> lol
09:00:05 <vincenz> Corun: now you have feedback :)
09:00:06 <LoganCapaldo> hlp unasked for!
09:00:11 <Toxaris> #haskell sees everything
09:00:17 <faxathisia> @src Ix
09:00:17 <lambdabot> class (Ord a) => Ix a where
09:00:17 <lambdabot>     range           :: (a,a) -> [a]
09:00:17 <lambdabot>     index           :: (a,a) -> a -> Int
09:00:17 <lambdabot>     inRange         :: (a,a) -> a -> Bool
09:00:17 <lambdabot>     rangeSize       :: (a,a) -> Int
09:00:50 <LoganCapaldo> > range (-3, -1)
09:00:51 <lambdabot>  [-3,-2,-1]
09:00:57 <LoganCapaldo> > range (-1, -3)
09:00:57 <lambdabot>  []
09:01:02 <faxathisia> :D
09:01:03 <faxathisia> > inRange ((0,0),(3,3)) (1,-1)
09:01:03 <lambdabot>  False
09:01:10 <Corun> Cool
09:01:12 <faxathisia> now I can make things not ridiculously slow
09:01:50 <Corun> Well fax, I helped by getting #haskell to help. Accidentally, that is :-)
09:04:05 <Corun> > putStr "I guess these things can't be in IO for lambdabot?"
09:04:06 <lambdabot>  <IO ()>
09:04:06 <sorear> Corun: For future reference, you can prevent announces by dechecking the Announce box.
09:04:26 <Corun> Heh, thanks :-)
09:04:48 <Corun> I'd blindly assumed that it wouldn't be checked by default :-)
09:05:21 <EvilTerran> @help run
09:05:21 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:06:08 <sorear> Corun: It used to be like that, but we had problems with people not announcing. :P
09:06:22 <Corun> Doh :-)
09:06:27 <LoganCapaldo> can't win for loosing
09:06:32 <sorear> *losing
09:06:47 <LoganCapaldo> yeah I couldn't decide what to do there
09:06:47 <Corun> *loo-singing
09:07:00 <LoganCapaldo> at first I was gonna do lossing
09:07:07 <LoganCapaldo> but that didn't seem right
09:07:41 * EvilTerran notes that it's kinda annoying that the student version of geometer's sketchpad won't work without the CD in
09:07:53 * EvilTerran has a music CD playing =/
09:09:29 <LoganCapaldo> msuic CD?
09:09:33 <LoganCapaldo> what are those?
09:09:44 <LoganCapaldo> I really can't type today
09:13:16 <sorear> EvilTerran: Write yourself a clone of GSK in Haskell.  I've been meaning to do that for a while - it shouldn't be hard.
09:13:29 <EvilTerran> it's on my to-do list
09:13:35 <EvilTerran> along with about a million other things ;)
09:14:46 <EvilTerran> actually, on a similar vein, i've been meaning to look into algebraic geometry
09:14:51 <EvilTerran> (or is it geometric algebra?)
09:15:16 <LoganCapaldo> geometric algebraiy
09:15:47 <sorear> EvilTerran: Both are real, and very different.
09:15:57 <EvilTerran> =/
09:16:14 <sorear> Algebraic geometry is solutions of polynomials - lines, circles, elliptic curves, &c
09:16:46 <sorear> Geometric algebra is vectors, oriented areas, pseudoscalars, Clifford algebras, &
09:17:04 <EvilTerran> <headsplode>
09:17:07 <LoganCapaldo> Clifford the big red dog?
09:18:09 <EvilTerran> what?
09:18:17 <LoganCapaldo> nvm
09:21:16 <bilboquet> Newbie question: what does it mean when I run 'runhaskell Setup.lhs configure' and I get 'Unknown field 'hs-source-dirs''?
09:21:59 <EvilTerran> i think it means that Setup.hs is written for a newer version of cabal than what you've got
09:23:01 <bilboquet> how do I update my cabal version?
09:26:13 <EvilTerran> i'm not sure... i just downloaded a new version of GHC when i hit a similar problem, and that came with a new cabal ;)
09:30:57 <LoganCapaldo> > sequence [ (+1), (*2) ] $ 7
09:30:58 <lambdabot>  [8,14]
09:32:56 <byorgey> bilboquet: you can get the newest version from hackage.
09:32:58 <byorgey> @where hackage
09:32:58 <lambdabot> http://hackage.haskell.org/
09:34:01 <reqamst> Or from darcs http://darcs.haskell.org/cabal
09:34:02 <lambdabot> Title: Index of /cabal
09:34:48 <LoganCapaldo> @type sequence [(*2)]
09:34:49 <lambdabot> forall a. (Num a) => a -> [a]
09:35:15 <LoganCapaldo> Ah reader monad
09:35:39 <LoganCapaldo> definitely my favorite
09:36:50 <hpaste>  davidL annotated "lambdabot + runplugs problems" with "same problem on i386" at http://hpaste.org/3795#a1
09:40:13 <davidL> what could this be?: runplugs: /usr/local/lib/ghc/HSbase.o: unknown symbol `memcpy'
09:41:22 <byorgey> davidL: I've seen others with that same problem.  what version of ghc are you using?
09:41:43 <davidL> byorgey: GHC 6.6.1
09:42:16 <byorgey> hmm, I don't know then. =(
09:42:18 <LoganCapaldo> not 6.6.6, the relase of teh beast?
09:42:48 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3942
09:43:13 <hircus> LoganCapaldo: I remembered waiting with anticipation for Intel's 666 MHz Pentium III, only to be disappointed when they go to 667 instead
09:43:59 <puusorsa> couldn't you underclock it by one mhz?
09:44:07 <davidL> it first happened on amd64 so I tried it on i386 but same problem, now I don't know where to go, could it be the OS's fault?
09:44:53 <LoganCapaldo> hmm unknown sysmbol memcpy sounds like linker isuses
09:46:00 <LoganCapaldo> is memcpy not in libc on openbsd maybe?
09:46:09 <LoganCapaldo> (that would be odd)
09:47:12 <hircus> davidL: what OS are you compiling on?
09:47:19 <davidL> hircus: openbsd 4.2
09:47:44 <hircus> and you're just building from the official port (is there one?)
09:48:23 <davidL> everything is built, the error occurs when I try to use runplugs
09:49:04 <LoganCapaldo> I guess runplugs compiles and links things "on demand"?
09:50:17 <gianluca`> @type group
09:50:19 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
09:51:04 <faxathisia> where is the list of everything 'deriving' can do?
09:52:20 <davidL> lambdabot.cabal says "The following only work if plugins are enabled", how do I enable plugins?
09:52:38 <sorear> davidL: You don't, the feature has been broken for a very long time.
09:53:20 <LoganCapaldo> http://www.haskell.org/onlinereport/derived.html
09:53:20 <lambdabot> Title: The Haskell 98 Report: Derived Instances
09:53:29 <faxathisia> ohh
09:53:32 <faxathisia> LoganCapaldo: thank you
09:53:41 <davidL> > 2+2 -- sorear: then how come this works?
09:53:42 <lambdabot>  4
09:53:51 <davidL> @version
09:53:51 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
09:53:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:54:00 <sorear> davidL: that's different from plugins being enabled
09:54:08 <byorgey> faxathisia: and also http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
09:54:10 <lambdabot> Title: 8.5. Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
09:54:13 <sorear> davidL: even though it also uses hs-plugins (the library)
09:54:33 <davidL> sorear: when I try to use eval it always says terminated
09:54:34 <faxathisia> cool cheers byorgey
09:54:36 <LoganCapaldo> faxathisia: note that that doesn't consider ghc extensions (eg deriving Typeable etc.)
09:54:51 <sorear> davidL: then runplugs must not be working
09:55:16 <sorear> davidL: I really don't recommend trying to install lambdabot, it's a major pain and offers no benefit
09:55:27 <faxathisia> so there is no deriving constructor predicates
09:55:43 <LoganCapaldo> faxathisia: Hmm?
09:55:44 <byorgey> faxathisia: what do you mean?
09:55:51 <faxathisia> I wrote data SweeperCell = Unknown | Bomb | Known Int
09:55:52 <davidL> sorear: right, it's not, and runplugs is one of the things in under lambdabot.cabal that says plugins must be enabled
09:56:01 <faxathisia> and then, bomb Bomb = True ; bomb _    = False
09:56:03 <faxathisia> for each one
09:56:27 <gianluca`> @type span
09:56:28 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:56:33 <LoganCapaldo> Oh yes, deriving does not magically write code like that for you :)
09:56:48 <faxathisia> could it though?
09:57:01 <LoganCapaldo> and if it could you'd have to somehow define an appropaite type class
09:57:04 <EvilTerran> well, deriving Eq would provide something similar for the parameterless constructors
09:57:16 <LoganCapaldo> which would be at least as much typing
09:57:33 <LoganCapaldo> it's not a general purpose code generation mechanism
09:58:04 <davidL> sorear: well I was trying to get the bot on a different server but I guess I'll try creating my own bot
09:58:31 <EvilTerran> if there were a class ConstructorEq a where (~~) :: a -> a -> Bool -- or something, it might make sense to do deriving on that
09:59:12 <LoganCapaldo> EvilTerran: even then you'd nstill have to do bomb = (Bomb ~~)
09:59:16 <EvilTerran> so you could then say (x ~~ Known undefined), and any Known would match
09:59:31 <faxathisia> I like that
09:59:43 <EvilTerran> LoganCapaldo, yes, but you could dispense with defining the predicates altogether
09:59:52 <faxathisia> I need to update some of my code to use undefined :)
09:59:58 <faxathisia> I had [] and 0 and things before
10:00:06 <EvilTerran> faxathisia, alternatively, there's almost certainly something snazzy you can do with SYB
10:00:21 <EvilTerran> and it should be possible to make something generic in templatehaskell
10:01:08 <EvilTerran> data Cell = Unknown | Bomb | Known Int; $(constructorPredicates ''Cell)
10:05:29 <twanvl> I believe Data.Derive has something for this
10:05:49 <faxathisia> (==) `on` toConstr
10:05:58 <faxathisia> is one possibility I guess
10:06:23 <EvilTerran> being sure to type-constrain it to the same Typeable instance on both sides
10:06:34 <EvilTerran> ?type toConstr
10:06:35 <lambdabot> Not in scope: `toConstr'
10:06:51 <faxathisia> :t (==) `on` Data.Generics.toConstr
10:06:52 <lambdabot> Not in scope: `on'
10:07:01 <faxathisia> @let (*) `on` f = \x y -> f x * f y
10:07:02 <lambdabot> <local>:5:4:     Multiple declarations of `L.on'     Declared at: <local>:2:0...
10:07:05 <faxathisia> phoo
10:07:15 <EvilTerran> > (==) `on` Data.Generics.toConstr
10:07:15 <lambdabot>  Add a type signature
10:07:42 <EvilTerran> > toConstr False == toConstr Nothing
10:07:42 <lambdabot>   Not in scope: `toConstr'
10:07:44 <faxathisia> :t let (*) `on` f = \x y -> f x * f y in (==) `on` Data.Generics.toConstr
10:07:44 <lambdabot> forall t. (Data.Generics.Basics.Data t) => t -> t -> Bool
10:07:52 <EvilTerran> > Data.Generics.toConstr False == Data.Generics.toConstr Nothing
10:07:53 <lambdabot>  Add a type signature
10:07:55 <twanvl> data Cell = Unknown | Bomb | Known Int deriving ({-! Is !-})
10:08:08 <faxathisia> :o
10:08:10 <EvilTerran> > Data.Generics.toConstr False == Data.Generics.toConstr (Nothing :: Maybe Int)
10:08:11 <lambdabot>  True
10:08:11 <faxathisia> what does that do
10:08:16 <EvilTerran> there we go
10:09:09 <EvilTerran> the {-!...!-} are part of the syntax for some code-generation thing; i forget which
10:09:22 <twanvl> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
10:09:23 <lambdabot> Title: Data.Derive: A User Manual
10:09:50 <faxathisia> cool :D
10:17:40 <paczesiowa> > x
10:17:41 <lambdabot>   Not in scope: `x'
10:17:44 <paczesiowa> > default
10:17:45 <lambdabot>  Parse error at "defau..." (column 1)
10:17:48 <faxathisia> I got a really big sparse matrix.....
10:18:00 <faxathisia> Is there a solver in haskell for those?
10:18:23 <paczesiowa> what's default ?
10:18:36 <paczesiowa> > let default = 1 in default
10:18:36 <lambdabot>  Parse error at "defau..." (column 5)
10:20:08 <asl> has anyone else been having trouble installing hslogger?
10:20:26 <asl> it's Setup.hs doesn't typecheck
10:22:23 <paczesiowa> > undefined
10:22:25 <lambdabot>  Undefined
10:22:35 <paczesiowa> > error "Undefined"
10:22:35 <lambdabot>  Exception: Undefined
10:23:27 <vincenz> > error "Exception: Undefined"
10:23:28 <lambdabot>  Exception: Exception: Undefined
10:24:17 * EvilTerran grumbles
10:24:39 <desegnis> paczesiowa: The keyword is â€œdefaulting rulesâ€, as in 1 + 2 (defaults to Integer)
10:24:58 <LoganCapaldo> > error undefined
10:24:59 <lambdabot>  Undefined
10:25:06 <EvilTerran> GSK's "angle bisector" primative is stoopid. it only creates a line infinite in one direction; the internal angle. this means it can't cope with straight angles
10:25:24 <EvilTerran> if it just made a line infinite in both directions, that wouldn't need to be a special case >:[
10:26:53 <EvilTerran> desegnis, i think the question is "why is using 'default' as a variable name a parse error?"
10:29:02 <LoganCapaldo> and the answer is, same reason using data as a variable name is a parse error
10:29:19 <LoganCapaldo> > let data = "make sure I'm not lying" in data
10:29:20 <lambdabot>  Parse error at "data" (column 5)
10:29:21 <paczesiowa> desegnis: thanks!
10:29:34 <EvilTerran> but where's it used as a keyword?
10:29:40 * EvilTerran goes to look at the report
10:31:41 <EvilTerran> http://haskell.org/onlinereport/decls.html#sect4.3.4 <- well, there's something i didn't know before
10:31:53 <desegnis> EvilTerran: You might still ask that question about the parse error. And we could ask, too, why class, type, or data are not allowed as identifiers, given that the context should keep things apart.
10:33:55 <LoganCapaldo> well data as an identifier would be icky
10:34:02 <LoganCapaldo> data x = x * 2
10:35:43 <newsham> am I the only one who feels that the distinction between top-level (function decls, data type decls) and not top level (ie. do-context used by ghci) feels unnatural?
10:36:02 <newsham> (ie. "why cant I define data types in ghci?")
10:36:09 <paczesiowa> too bad, that we can't use default as an identifier, it tells it all. they should use some stupid words for never-to-be-used keywords
10:36:34 <newsham> __default__
10:36:37 <newsham> ;-)
10:37:11 <hircus> what is 'default'  used for in Haskell, actually?
10:38:00 <newsham> __data__ List a = Null | Cons a (List a);  __let__ x = __if__ null xs __then__ 0 __else__ head xs
10:38:46 <LoganCapaldo> actually data as anidentifier gets even worse than my example
10:39:02 <salierix> What's a "space leak"?
10:39:22 <basti_> salierix: when you allocate memory, but never deallocate it.
10:39:24 <newsham> when the garbage collector doesnt pick up your trash
10:39:25 <LoganCapaldo> data X = x -- parse error in a data decl. or pattern mattching against the constructor x in the definition of the data function?
10:39:25 <vincenz> salierix: it's when time flattens and some of the universe leaks out
10:39:28 <newsham> it starts to pile up
10:39:32 <LoganCapaldo> oh wait
10:39:33 <paczesiowa> newsham: we use lets, ifs and datas all the time, how many times have you used default?
10:39:35 <LoganCapaldo> nvm
10:39:45 <LoganCapaldo> no unvm
10:40:01 <salierix> So it's like a memory leak then?
10:40:16 <basti_> synonymous i'd say
10:40:25 <sw17ch> random question, has any one ever tried to use GHCi as a shell?
10:40:30 <sw17ch> in place of say, bash
10:40:35 <paczesiowa> I would like too
10:40:47 <paczesiowa> *to
10:40:50 <LoganCapaldo> data Y = X ; data X = X -- even though you can come up with a valid intpretation of this with daa as an identifier you can't say it's not confusing as hell
10:41:13 <grahamhutton> andyg: morning!
10:41:14 <xerox> data () = ()
10:41:15 <paczesiowa> but we would need to add some sugar for running external (like ls)
10:41:15 <vincenz> LoganCapaldo: not really
10:41:23 <vincenz> foo Y = X
10:41:26 <sw17ch> paczesiowa: agreed
10:41:26 <vincenz> foo X = X
10:41:55 <LoganCapaldo> except the first one isn't foo
10:41:58 <vincenz> @quote syntactic sugar
10:41:58 <lambdabot> No quotes for this person. :(
10:42:00 <LoganCapaldo> it's declaring the type Y
10:42:07 <vincenz> LoganCapaldo: says who
10:42:14 <LoganCapaldo> says my confusing example :)
10:42:29 <vincenz> LoganCapaldo: then your example makes no sense, even in a language that allows data as identifier
10:42:34 <vincenz> LoganCapaldo: you just made an inconsistent langauge
10:43:07 <LoganCapaldo> My point is that allowing data to be an identifier in haskell in addition to being a keyword can creat confusing situations
10:43:12 <paczesiowa> I wanted to write my own shell (I hate bash), but I realised that ghci has almost all of wanted features (just running external apps, and colored output is missing)
10:43:34 <paczesiowa> >>= is | :P
10:44:05 <LoganCapaldo> which is why generally you don't have languages where keywords can also be identifiers
10:45:05 <LoganCapaldo> am i making sense yet?
10:46:11 <LoganCapaldo> data X = Y -- are defining a function or a new datatype? Well it depends...
10:46:44 <newsham> let ls = system "/cygwin/bin/ls"; ls
10:47:24 <LoganCapaldo> @hoogle runInteractiveProcess
10:47:25 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
10:47:35 <paczesiowa> who would use that?
10:47:41 <paczesiowa> system "cd dir"
10:47:42 <newsham> logan: yah, that seems like too much typing and pipeing
10:47:46 <oerjan> newsham: i think you need {} brackets
10:48:10 <oerjan> otherwise the let doesn't end before you use the ls
10:48:25 <paczesiowa> I think that is we type "ls" and there is no ls function then shell should search $PATH and system it
10:48:26 <newsham> i actually typed them on separate lines in ghci but wanted to spare the channel the newline
10:48:31 <sw17ch> @index system
10:48:31 <lambdabot> System.Cmd
10:48:36 <newsham> but now spent more lines explaining it than it would have taken to dump it
10:48:43 <oerjan> heh :)
10:49:11 <paczesiowa> newsham: and how about ls -l ?
10:49:32 <newsham> > let ll = system "/cygwin/bin/ls -l"
10:49:32 <lambdabot>  Parse error at end of input
10:49:56 <newsham> ;-)
10:50:01 <grahamhutton> @seen andyg
10:50:02 <lambdabot> I haven't seen andyg.
10:50:19 <grahamhutton> @seen andyjgill
10:50:19 <lambdabot> andyjgill is in #darcs, #haskell and #ghc. I don't know when andyjgill last spoke.
10:50:25 <paczesiowa> ok, let wget_switch1 file= system $ "wget -switch1" ++ file
10:50:30 <andyjgill> Hi graham
10:51:00 <sw17ch> paczesiowa: i'm afraid we may have started something :(
10:51:01 <grahamhutton> hi andy!  don't you better things to do on saturday than hang out here :-)  (same applies to me...)
10:51:01 <defcons> is a lot of a lot of general-use software written with the do monad?
10:52:45 <newsham> the great thing about "system" is that you can botch it up with spaces
10:53:01 <newsham> wget_switch1 "test this out"
10:53:10 <newsham> also shell metacharacters
10:53:33 <newsham> wget_switch1 "test;this&out|touch /tmp/gotcha"
10:53:47 <paczesiowa> the whole point is to get rid of bash:P
10:54:18 <newsham> good idea, get rid of that bloated gnu shell.  run lean/mean ghci instead ;-)
10:54:30 <sw17ch> > let wc = system . (\x -> "/usr/bin/wc " ++ x)
10:54:30 <lambdabot>  Parse error at end of input
10:54:46 <sw17ch> > wc "-l .bash_history"
10:54:47 <lambdabot>   Not in scope: `wc'
10:54:49 <newsham> ?pl (\x -> "/usr/bin/wc " ++ x)
10:54:49 <lambdabot> ("/usr/bin/wc " ++)
10:55:38 <oerjan> defcons: you mean IO? do is not _a_ monad, it works in all of them
10:56:05 <oerjan> and all haskell programs need to be IO at the top
10:56:06 <newsham> do is just the sweatener you put in your monad
10:56:14 <sw17ch> is there a chance that we have a way of dropping the ""'s?
10:56:39 <newsham> you could write a parser for it.
10:56:45 <newsham> then you have a shell :)
10:57:15 <LoganCapaldo> sw17ch: :cmd
10:57:18 <LoganCapaldo> perhaps
10:57:37 <LoganCapaldo> sorry
10:57:37 <newsham> http://haskell.org/haskellwiki/Simple_unix_tools
10:57:39 <LoganCapaldo> I mean :def
10:57:40 <paczesiowa> you mean, parse it and transform to equivalent haskell code and run?
10:57:59 <defcons> oerjan, I so people doing a lot of do things
10:58:12 <defcons> okay
10:58:46 <byorgey> defcons: 'do' notation is what is known as 'syntactic sugar'... i.e. just a nicer way of writing certain things.
10:58:46 <andyjgill> grahamhutton: I'm actually applying for jobs, and writing cover letters.
10:59:02 <byorgey> defcons: underneath, it gets translated into monad bind operators >>= and >>.
10:59:26 <sw17ch> paczesiowa: yes =)
10:59:48 <byorgey> @undo do { x <- getLine; putStrLn "Hello " ++ x }
10:59:49 <lambdabot> getLine >>= \ x -> putStrLn "Hello " ++ x
10:59:53 <paczesiowa> that seems easy, and doesn't involve hacking ghci
11:00:04 <byorgey> defcons: you can play around with the translation from do-notation using @undo ^^
11:00:10 <paczesiowa> but we loose tab completition
11:00:16 <shapr> Does ghc use SIMD instructions in the asm backend?
11:00:59 <sw17ch> paczesiowa: good one
11:01:41 <paczesiowa> but if tab-compl is the only thing we loose, it should be easy to implement it ourself
11:01:52 <sw17ch> paczesiowa: true
11:02:14 <sw17ch> paczesiowa: i'd love to map things across files :)
11:02:23 <paczesiowa> ?
11:02:25 <sw17ch> or perhaps foldr a command
11:02:39 <Heffalump> shapr: I doubt it
11:02:39 <defcons> byorgey, okay
11:02:44 <newsham> sw17ch: xargs
11:02:45 <sw17ch> map ls [*."txt"]
11:02:50 <defcons> byorgey, I guess I'll understand when I get to it in my book
11:02:54 <sw17ch> newsham: yes, i know... but it's not as cool =)
11:03:10 <newsham> xargs is very cool
11:03:20 <byorgey> defcons: sure =)
11:03:33 <paczesiowa> I'd love to write if [ $x = "1 2 3" ] and not to look for errors for hours, because types mismatch
11:03:34 <sw17ch> newsham: imagine how cool the exec map would be then =)
11:04:05 <paczesiowa> isn't xargs bind for list monad?
11:04:26 <dons> shapr: nope
11:04:31 <newsham> find . -name _darcs -prune -o \( -name '*.hs' -print0 \) |xargs -0 grep -n "$@"
11:05:35 <sorear> re.
11:05:57 <ddarius> dons, Heffalump: It uses something other than the FPU ops right?
11:06:00 <sorear> davidL: you could ask a bot admin to get the existing lb to connect... :)
11:06:16 <paczesiowa> newsham: I don't like this style, you need to learn each application, remember different syntax for every app, with haskell-shell you could just use basic find and do the rest with one general language
11:06:55 <tehgeekmeister> how long do hpastes live?
11:07:02 <ddarius> tehgeekmeister: Indefinitely.
11:07:03 <Saizan_> forever.
11:07:08 <tehgeekmeister> okay.
11:07:13 <defcons> prove it :p
11:07:14 <paczesiowa> I can't even remember how to write for statements in bash in one line using ';'
11:07:15 <EvilTerran> indefinitely but not infinitely, i think
11:07:16 <newsham> yah, why would you want to mix and match a large set of small tools that compose well with each other
11:07:22 <ari> Indefinitely until someone removes them
11:07:31 <EvilTerran> unless they're spam
11:07:37 <newsham> when you could build a large system to do all of the tasks that anyone would ever want to do (why would they want to do anything other than the ones we let them?)?
11:08:02 <ricky_clarkson> paczesiowa: I know this is sad, but:
11:08:05 <ricky_clarkson> > let spellItRight=ap ((++) . take 2) (drop 3) in spellItRight "loose"
11:08:09 <lambdabot>  "lose"
11:08:14 <newsham> for f in *; do echo $f; done
11:08:23 <paczesiowa> ricky_clarkson: sorry, my english is bad:-(
11:08:27 <grahamhutton> andyjgill: notts jobs adverts should be out any day now, with FP explicitly mentioned.
11:08:30 <newsham> *shrug* I guess if you cant remember how to use your shell, you're best off not using it.
11:08:33 <oerjan> tehgeekmeister: i think someone said something like that hpaste does not preserve pastes that have neither author nor title
11:09:01 <sw17ch> bash for loops are the black magic needed to baffle freshmen at my school =)
11:09:05 <tehgeekmeister> oerjan: okay.
11:09:14 <paczesiowa> newsham: you can look at all Data.List.* as small tools, you can do everything with them
11:09:30 <sw17ch> but then again, grep -lrn --color "(\.*)" .
11:09:31 <sw17ch> will too
11:10:04 <sorear> tehgeekmeister: indefinitely until we add features to hpaste, since this dumb system can't handle upgrades in a remotely sane way
11:10:07 <davidL> sorear: I wouldn't want to disturb the existing lambdabot, she is much too precious
11:10:21 <newsham> a shell is designed for the specific purpose of running unix utilities and composing them together.
11:10:32 <newsham> ghci is not.
11:10:42 <paczesiowa> I think it could be
11:10:43 <sorear> davidL: hah
11:11:16 <paczesiowa> we can make using "cd dir" as easy as in bash, and simplify for and while cosntructs
11:11:44 <paczesiowa> s/can/could
11:11:49 <newsham> and I can make bash run haskell code... but that doesnt mean I should.
11:12:31 <newsham> I guess the proof is in the pudding.. go for it.. if it works out, great.
11:12:32 <paczesiowa> I don't want to force you to. I just would like to use that kind of shell
11:13:31 <geocalc> make ghc-linux so
11:14:42 <Saizan_> paczesiowa: there has been various attempts to build an haskell-based shell, unfortunately not so mantained
11:14:48 <puusorsa> mmmm.. pudding..
11:14:50 <ricky_clarkson> Why not make such file-manipulation stuff within Haskell instead?
11:15:05 <newsham> http://haskell.org/haskellwiki/Simple_unix_tools
11:15:07 <ddarius> "the Center for Hybrid and Embedded Software Systems"
11:15:54 <paczesiowa> Saizan_: I know there is hsh, but it looks like regular shell - only written in haskell. I want something haskellish
11:16:17 <paczesiowa> huh, haskellish would be a good name for such a shell
11:16:29 <Saizan_> paczesiowa: me too, we should write it sometime :)
11:16:32 <ricky_clarkson> hashish
11:16:45 <newsham> code first name second?
11:17:03 <geocalc> ghchish
11:17:36 <davidL> newsham: cool name = motivation!
11:17:49 <ddarius> hash is the name of the other one
11:17:52 <paczesiowa> laziness = name first and maybe (just maybe) code second
11:18:01 <newsham> Maybe Code
11:18:04 <ddarius> There is also a Clean one, but I'm not sure how serious they made it.  It was interesting though.
11:18:21 <geocalc> ^_^
11:18:22 <ddarius> Name -> Maybe Code; Code -> Name
11:18:49 <newsham> in the time it takes you to figure out a cool name, you could have learned how to use "for" in bash, with spare time to read up on find(1) and xargs(1)
11:19:17 <ddarius> And you'd still gouge your eyes out when writing or reading any remotely complicated shell script.
11:19:18 <geocalc> hehe
11:19:26 <Saizan_> newsham: arrgh imperative loop! vade retro! :)
11:19:48 <newsham> saizan: you're not going to have imperative looping in your haskell shell?
11:19:56 <paczesiowa> newsham: I could, but I'm going to forget it anyway
11:20:08 <Saizan_> newsham: nah, just mapM
11:20:09 <ricky_clarkson> I know how to use for, find and xargs, but I really don't like the idea of accidentally deleting/overwriting/losing files while trying to create a 'flattened' version of a tree of directories.
11:20:34 <ricky_clarkson> ..that's the kind of thing I'd be worried about using bash for.
11:22:15 <newsham> saizan: i imagine that almost all for loops that people write in sh are mapM (very very rarely forM or worse)
11:22:48 <paczesiowa> I was writing today bash script, which would first wget smth, and then some imperative for stuff, I had to fire it up , wait for download just to see types don't match later in the code.
11:24:13 <Saizan_> newsham: what i mostly don't like about bash is the syntax, i agree that it does its job, but i think i'd like an haskell DSL more
11:24:28 <dons> paczesiowa: sounds like you need static typing
11:24:33 <newsham> saizan: interactively or for scripting?  or both?
11:24:42 <ddarius> Um
11:24:44 <ddarius> @src forM
11:24:44 <lambdabot> forM = flip mapM
11:24:45 <Saizan_> both
11:24:47 <paczesiowa> dons: yes, I love static typing!
11:24:57 <newsham> i think merging shell-like features into an interactive haskell environment would be very hard to do
11:25:16 <ddarius> newsham: Why?
11:25:26 <newsham> ie. conveniences like not having to quote things, automatic globbing, variable argument flags, etc.
11:25:40 <paczesiowa> so make fun of my programming skills, not of my (stupid anyway) ideas:P
11:26:08 <ddarius> newsham: It would be very little trouble to have a "pre-processor" for such things.
11:26:22 <newsham> ls -1 *.c >>= grep -n magic >>= return.sort.words   ?
11:26:52 <newsham> ddarius: *nod* I imagine that would be the approach.. I jus tthink getting a syntax that works and is still convenient would be the hard part
11:27:14 <ddarius> newsham: To a point, that is in large part the whole issues with shells in general
11:27:38 <newsham> there are some shells with very simple and very convenient syntaxes
11:28:01 <newsham> "rc" comes to mind
11:29:40 <newsham> (extended by "es" for functional programmers who need their fix)
11:30:19 <ddarius> > fix (1:)
11:30:24 <newsham> http://www.webcom.com/~haahr/es/es-usenix-winter93.html
11:30:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:30:29 <lambdabot> Title: Es: A shell with higher-order functions
11:31:05 <newsham> http://plan9.bell-labs.com/sys/doc/rc.pdf
11:32:15 <dons> http://programming.reddit.com/info/60ty3/comments/
11:32:46 <dons> `Haskell as an alternative to Perl for scripting tasks'
11:34:01 <lament> sounds extremely inflammatory
11:34:03 <reqamst> Interesting.
11:34:26 <reqamst> But I can't imagine it.
11:34:30 <lament> yeah, and the article says nothing about using haskell for scripting tasks
11:34:35 <lament> i can't imagine it either.
11:35:01 <dons> strange.
11:35:01 * hgolden is back
11:35:10 <dons> lament, you're being inflammatory :)
11:35:26 <lament> dons: not as much as the article :)
11:35:31 <dons> hmm?
11:35:51 <dons> did you read it? its not inflammatory, on my reading
11:35:58 <lament> i've read it
11:36:03 <dons> it seems quite positive that haskell is used succesfully for system tasks
11:36:12 <dons> or is asserting that inflammatory now?
11:36:21 <dons> do you have a particular criticism?
11:36:23 <lament> the problem with the article is that it really contains nothing specific
11:36:28 <lament> about using haskell for scripting
11:36:40 <dons> that's not inflammatory, just vague
11:36:45 <lament> well, right
11:36:52 <lament> what makes it inflammatory is the title
11:37:08 <dons> why?
11:37:15 <dons> its about using haskell in a domain perl normally gets used in
11:37:19 <dons> seems like a reasonable title
11:37:21 <Saizan_> "and another one, integrated pattern matching, is of course what Perl is well known for." <-- he confused pattern matching with regexes?
11:37:22 <thetallguy> Anyone familiar with escaping strings in HaXml?
11:37:28 <dons> Saizan_: yes.
11:38:03 <pejo> The advantage with perl is that normally the type system doesn't get in the way.
11:38:07 <lament> dons: first of all, the article doesn't even talk about perl. If haskell is to be an alternative to perl, it should be explained what makes it better.
11:38:12 <pejo> ;)
11:38:17 <dons> pejo: :)
11:38:23 <thetallguy> I'm trying to construct a cdata element, but the quotes keep getting escaped and put outside the cdata elements.
11:38:25 <dons> lament: i think you want a different article
11:38:45 <lament> yes, i expect a different article when i see that title
11:38:53 <dons> fwiw, i use haskell for all my scripting tasks, since the scripts don't break later -- they're not as fragile as shell or perl
11:39:02 <lament> it would go, "look at this ugly perl script. Now look at this pretty and simple haskell script!"
11:39:04 <dons> and you can compile them to much faster code
11:39:05 <lament> and so on
11:39:10 <paczesiowa> thetallguy: Network.URI has funs to escape strings
11:39:30 <Mauke> I find haskell extremely fragile for scripting
11:39:37 <thetallguy> paczesiowa: Hmm...  Interesting thought.
11:39:43 <dons> Mauke: oh, that's interesting. why?
11:39:44 <Korollary> I write scripts in haskell, too, but in general you can't beat perl.
11:39:54 <newsham> dons: I think for most of what people use scripts for, compiling or interpretting would be pretty similar performance since they're IO bound.
11:39:56 <dons> the other issue is that scripts don't scale in perl
11:39:59 <Mauke> nearly no control over unix syscall stuff
11:40:00 <dons> but they typically do need to anyway
11:40:23 <pejo> dons, I don't think you're entirely fair to sh/perl now. Scripts rarely break in that sense in my experience.
11:40:28 <Mauke> I typically want file descriptors, dup, fork, exec, etc
11:40:28 <newsham> definitely scaling is an issue.  if you write a small script in perl and it gets too large, its going to be a pain to maintain.
11:40:35 <dons> pejo: oh, i find things break a lot due to invalid regexes
11:40:43 <dons> and funny error conditions
11:41:00 <newsham> mauke: most scripting languages dont give you syscall access.
11:41:05 <Mauke> perl does
11:41:22 <pejo> dons, so your 'fragile' really means that it's easy to write a script that doesn't work?
11:41:22 <newsham> have you considered FFI bindings for syscalls?
11:41:28 <dons> seems everyone has a different idea of what 'scripting' is
11:41:29 <pejo> dons, not that it breaks after a while?
11:41:39 <Mauke> newsham: why bother when I can just use perl?
11:41:40 <dons> pejo: right. its fragile :)
11:41:41 <ddarius> lament: There are examples of ugly perl scripts and shorter cleaner and more robust Haskell equivalents.
11:41:51 <newsham> mauke: no reason, if you're fine using perl.
11:42:05 <dons> people are sensitive about perl these days, i've noticed
11:42:08 <vaehid32> can i ask a newbie question about return types in the interpreter
11:42:11 <Mauke> dons: 'scripting' here means text/data munging and running other programs
11:42:13 <vwx> hello
11:42:13 <newsham> ddarius: haskell can look pretty "ugly" too
11:42:14 <dons> vaehid32: please do!
11:42:18 <Mauke> i.e. glue
11:42:20 <newsham> beauty is in the eye of the beholder
11:42:34 <dons> Mauke: text munging is a parsing/pretty printing problem
11:42:41 <pejo> dons, fragile could just as well be interpreted as "it breaks down after a while". But sure - lots of foot shooting possible with perl. Swiss army chainsaw.
11:42:45 <ddarius> newsham: I agree re your first comment, but shorter and more robust are less subjective.
11:42:47 <lament> let's see, the article sort of randomly mentions features of haskell: list comprehensions (is this really important? And perl has no alternative?), pattern matching support (what?), static typing (this is a big one, granted, but not particularly unique to haskell), ghci (perl has a REPL too), compilation (not really an issue for scripts most of the time); that's it
11:43:00 <vaehid32> ok, i have a function of type :: IO [String] -- when it completes nothing is printed (I'm using hugs)
11:43:01 <vaehid32> is this normal?
11:43:04 <dons> lament: and reports experience of someone who happily uses it
11:43:07 <lament> that's the entire informative content of the article wrt haskell
11:43:16 <dons> vaehid32: the return is discarded
11:43:22 <vaehid32> ok that's what i thought
11:43:23 <vaehid32> thanks!
11:43:30 <dons> you can pipe it into print though
11:43:34 <dons> x >>= print
11:43:35 <Mauke> dons: yeah, and regex integration makes simple parsing very easy
11:43:38 <vaehid32> hmmm ok
11:43:44 <vaehid32> i was using mapM_ printLn
11:43:45 <vaehid32> i think
11:43:46 <ddarius> lament: You shouldn't be going to blog posts for "informative content"
11:43:57 <vwx> anyone here familiar with gtk2hs?
11:44:10 <dons> i think lament's initial characterisatoin of it as inflammatory threw the discussion off
11:44:16 <lament> heh
11:44:31 <newsham> mauke: but not usually very robust.  people use regexp to do quick'n'dirty parsing (its great for that) but their parsers are usually wrong (it might ont matter for their small problem, but when they extend it to a general solution, it does)
11:44:56 <Mauke> newsham: my regexes aren't wrong
11:45:14 <Korollary> It all depends on where you draw the line between script and serious program with serious error handling and correctness
11:45:19 <pejo> newsham, what feature of Haskell makes people write correct parsers?
11:45:19 <dons> yeah
11:45:37 <ddarius> pejo: What feature of Haskell makes people write correct code?
11:45:37 <newsham> you only parse languages that are parsable by pcre's?
11:45:38 <dons> pejo: parsing combinators are easier than regexes for parsing
11:45:52 <ddarius> newsham: All languages are parseable by pcres
11:45:53 <Mauke> dons: haha. no.
11:45:58 <newsham> dons: I dunno about that :)
11:46:00 <lament> dons: none of those features satisfy the implicit requirement (as promised by the title) of 1) being demonstratively useful for scripting, and 2) not being present in Perl; but what really makes it inflammatory is lack of demonstration, ie lack of proof that any of these features are any good
11:46:16 <dons> oh, its inflammatory by what it leaves out!
11:46:17 <lament> "this guy likes it" is no proof
11:46:30 <dons> and the fact he gives you no proof is infuriating, eh?
11:46:33 <pejo> ddarius, one could argue that the type system catches certain classes of errors. I'm just not convinced that a type system helps for typical sysadmin tasks.
11:46:35 <reqamst> Probably Haskell is better than Perl as scripting language, but anyone can show me real example?
11:46:45 <lament> dons: consider the reverse case: "Perl is better for scripting because it has sigils"
11:46:50 <newsham> ddarius: pcre's are turing complete?
11:46:56 <lament> dons: that's called a troll...
11:47:13 <dons> reqamst: there's *lots* , since people use it for this all the time. in my experience, its the robustness and scalabity, and performance that matter.
11:47:33 <vaehid32> don: that >>= trick is neat thanks...     this is my first time on this channel -- very busy!
11:47:34 <paczesiowa> newsham: I heard sed with s/ is, so probably yes
11:47:39 <ddarius> lament: He says "Maybe it's time for more system administrators to look at Haskell", not "And thus clearly Haskell is better in all ways than Perl which should be immediately abandoned".
11:47:41 <vaehid32> is there a beginner version of this channel?
11:47:43 <dons> here's darcs-graph, for example,
11:47:43 <lament> "Haskell's pattern matching support was another plus for him." vs. "Perl's sigil support was anotehr plus for him"
11:47:44 <dons>   http://code.haskell.org/~dons/code/darcs-graph/Graph.hs
11:47:55 <Korollary> If performance does matter that much, it's not a script per se.
11:47:57 <dons> which was some 10x faster than the perl program it replaced
11:48:07 <LoganCapaldo> peopel don't use Haskell as a scripting language. People use perl as a general purpose language.
11:48:07 <ddarius> newsham: I believe so.  Certainly, the actual ones in perl are.
11:48:09 <dons> and has been remakably stable
11:48:10 * LoganCapaldo ducks
11:48:33 <ddarius> vaehid32: #haskell
11:48:49 <vaehid32> ah
11:48:56 <ddarius> vaehid32: This channel varies in busyness.
11:48:56 <dons> vaehid32: feel free to ask any questions here
11:49:00 <LoganCapaldo> vaehid32: you should see the "advanced"channel :)
11:49:06 <vaehid32> haha oh no
11:49:08 <Korollary> vaehid32: it just takes long to begin
11:49:27 <ddarius> However, if you need someplace more quiet to work out a specific issue, there are satellite channels for that after you ask here.
11:49:40 <vaehid32> i see
11:49:56 <newsham> oh weird, perl regexps have evals
11:50:05 <newsham> didnt know about that one
11:50:07 <ddarius> @seen lambdabot
11:50:07 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
11:50:22 <Mauke> newsham: don't worry, that feature is broken
11:50:43 <vaehid32> what's haskell-blah?
11:50:53 <lament> off-topic
11:50:55 <ddarius>  /topic #haskell-blah
11:51:00 <vaehid32> thanks
11:51:05 <ddarius> Or @topic #haskell-blah
11:51:21 <lament> @topic unicycling
11:51:21 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join oeis todo type
11:51:21 <vaehid32> @topic #haskell-blah
11:51:22 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join oeis todo type
11:51:22 <ddarius> (is that the right lambdabot command? @topic-tell?  I forget)
11:51:25 <reqamst> dons: But Perl is avaible practically everywhere (on almost every unix based server and desktop), Haskell unfortunately not.
11:51:38 <dons> sure, there's lots of issues here.
11:51:49 <dons> one sys admin is happily using haskell, and many others in here
11:51:55 <dons> i think that's a good experience report, nice to know
11:52:19 <lament> sure
11:52:21 <dons> sys admins can presumably install ghc
11:52:27 <vaehid32> thanks for the help, i'm going to go sign up for the mailing lists
11:52:28 <ddarius> And of course there's Linspire or whatever it's called now.
11:52:38 <LoganCapaldo> @topic-tell #haskell-blah
11:52:38 <lambdabot> Anything BUT Haskell (especially SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first words: "Ooh, functional programmers
11:52:38 <lambdabot> are so hot" -|- current topic: "Sorry, we've closed for lunch !"
11:52:40 <lament> vaehid32: careful, you're gonna be swamped with mail
11:52:48 <dylan> ghc usually has to be installed machines I admin, as I require darcs. <g>
11:52:49 <geocalc> @oeis
11:52:50 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
11:53:05 <ddarius> @oeis 0 1 1 2 3
11:53:06 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
11:53:06 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:53:09 <Mauke> heh
11:53:13 <dons> anyway, its completely unfair to characterise that article as inflammatory, its a gentle report: "Haskell seems to have made the life of this one administrator quite a bit easier, and might do the same for others"
11:53:19 <dons> that's not pushy
11:53:28 <Mauke> my rot13 is written in perl
11:53:30 <dons> "Although itway arounds no doubt not ideal for all users"
11:53:30 <pejo> ddarius, their situation is closer to a developer, rather than sysadmin, in a certain sense.
11:53:33 <dons> grr
11:53:39 <dons> i hate how irssi expands '
11:53:39 <Mauke> I wonder what the Haskell version would look like :-)
11:54:01 <dons> rot13 is surprisingly inelegant
11:54:07 <dons> i don't think i've seen a nice one
11:54:14 <dons> all that ascii arith and rounding
11:54:35 <lament> dons: consider the reverse case, something like "Perl as an alternative to haskell for parsing", with contents like "Perl's advanced features such as sigils and dynamic typing really helped me write a parser"
11:54:51 <Mauke> here's the perl version: perl -p 'y/a-zA-Z/n-za-mN-ZA-M/'
11:54:57 <Mauke> er, -pe
11:55:04 <dons> maybe i'm not as highly strunge as your, lament :)
11:56:24 <Korollary> It's not likely going to convince sysadmins who don't already know haskell.
11:56:44 <ddarius> dylan: darcs doesn't require ghc
12:00:20 <dons> maybe the question is: do you want to keep writing perl for scripting for another 10 years?
12:00:31 <dons> or can we do something better
12:00:46 <newsham> btw, does haskell come on OLPC laptops?  has anyone tried to get something on their?  (maybe hugs would be most appropriate)
12:01:24 <newsham> dons: if your definition of script is something 40 lines or less, I would have no problem writing perl scripts for the next 40 (personally, I would do it with shell/sed/awk and friends, though)
12:01:43 <newsham> for small things it works quite well.
12:02:17 <dons> ghc compiles for olpc quite fine.
12:02:21 <dons> we've had xmonad on the olpc
12:02:41 <lament> i thought the idea was to give children access to information, not to make their heads explode
12:02:59 <ddarius> newsham: I can do more things with Haskell in 40 lines or less and usually cleaner than I can with Perl (but then I dump perl from my head after every time I learn it)
12:03:00 <lament> dons: does it run at usable speed?
12:03:07 <dons> olpc?
12:03:17 <ddarius> lament: Huh?
12:03:18 <lament> well, xmonad specifically
12:03:22 <Mauke> ddarius: I accept your challenge
12:03:23 <newsham> dons: www.laptop.org
12:03:30 <ddarius> xmonad is one of the fastest wms
12:03:41 <dons> yeah, that's a weird question.
12:03:45 <ddarius> Not that it would need to be.
12:03:49 <newsham> ddarius: for a 10 line script, "cleaner" isnt necessarily important.
12:03:59 <newsham> the only real measure is how long it took you to put it together
12:04:08 <sattom> About 2 years ago, I stumbled upon sample exam questions about typed lambda calculus on the web. They were in plain TXT format, and I remember that they were deep, exceptionally well-thought ought and also self-referential ("are 5 and 6 distinct questions" etc.), and covered CH-isomorphism, confluence etc.. Now I cannot locate them anymore - has anyone an idea? Sorry that it's so vague.
12:04:08 <Korollary> 40 line scripts don't do much, or anything complicated.
12:04:10 <ddarius> newsham: So?  It's still nice and I mean easier too or at least comparably as easy.
12:04:11 <puusorsa> write-only code .. nice ..
12:04:16 <Mauke> here's a real program: http://rafb.net/p/dm0lxS20.html
12:04:16 <lambdabot> Title: Nopaste - No description
12:04:25 <Mauke> anyone want to rewrite it in haskell? :-)
12:04:32 <newsham> ddarius: if you can do it faster in haskell, then thats the argument.
12:04:35 <ddarius> Mauke: Are you going to try to trick me into learning Perl yet again?
12:04:57 <Mauke> come on, it's practically self documenting :-)
12:05:10 <lament> so apparently XO (the olpc laptop) comes with Python, Javascript, Squeak and Logo.
12:05:15 <ddarius> sattom: Are you thinking about Lectures on the Curry-Howard Isomorphism?
12:05:33 <sattom> ddarius: that was certainly one part, but it also covered other topics
12:05:54 <dons> lament: yeah, strange. and you ask if xmonad is fast enough? ;)
12:06:03 <newsham> mauke: that doesnt seem that hard to rewrite
12:06:04 <ddarius> sattom: So does the Lectures on the Curry-Howard Isomorphism.
12:06:07 <lament> dons: yeah, good point
12:06:12 <ddarius> mauke: It's also more than 40 lines.
12:06:13 <dons> http://xmonad.org/images/photo-cjb-olpc.png btw.
12:06:24 <Korollary> ddarius: He said sample exam questions, tho.
12:06:32 <sattom> ddarius: where is the lecture you mean?
12:06:45 <Korollary> lecture notes
12:06:48 <ddarius> The lectures have exercises and do have questions like that.
12:06:50 <Mauke> ddarius: not if you remove docs and empty lines!
12:06:55 <lament> i'm almost considering buying the XO just because it's a small laptop with a black-and-white screen <3
12:06:57 <ddarius> @google "Lectures on the Curry-Howard Isomorphism"
12:06:58 <lambdabot> http://citeseer.ist.psu.edu/519604.html
12:06:58 <lambdabot> Title: Lectures on the Curry-Howard Isomorphism - Srensen, Urzyczyn (ResearchIndex)
12:07:01 <Korollary> @go lectures on the curry-howard isomorphism urzycn
12:07:02 <lambdabot> No Result Found.
12:07:15 <Korollary> Bah I had no chance remembering that name right
12:07:16 <newsham> lament: the give-one-get-one program started this past monday.
12:07:21 <newsham> the money goes to a good cause
12:07:28 <lament> yeah, i know
12:07:41 <newsham> i put in my order
12:07:51 <newsham> i'm hoping it works as a good pdf reader
12:08:09 <hpaste>  LoganCapaldo pasted "Another inelegant rot13 (no rounding or ascii arith though)" at http://hpaste.org/3944
12:08:15 <MisterN> hi. sorry for this all-too-simple question, but why doesn't this exit on EOF? http://paste.lisp.org/display/50995
12:08:19 <lament> yeah, it should be a nice "electronic book"
12:08:25 <vwx> does ghc --make have a -j parallel version?
12:08:58 <dons> ?check \c xs -> findIndex (== c) xs == findElem (c::Int) xs
12:08:58 <lambdabot>   Not in scope: `findElem'
12:09:05 <dons> ?check \c xs -> findIndex (== c) xs == elemIndex (c::Int) xs
12:09:06 <lambdabot>  OK, passed 500 tests.
12:09:09 <sattom> ddarius: that wasn't it; it was a web page with a TXT file of exam questions, I don't think there were any lecture notes online, but 12 or so really great questions touching on many topics
12:09:12 <dons> LoganCapaldo: ^
12:09:12 <lament> olpc's description of javascript: "Javascript is a Lisp-like object-oriented language with a C-like syntax"
12:09:18 <dons> man
12:09:32 <dons> no wonder the lisp guys are so bitter
12:10:05 <newsham> but it has lambda expressions!
12:10:08 <newsham> ;-)
12:10:18 <Korollary> how is it lisp like?
12:10:19 <Mauke> LoganCapaldo: that lowercases all input. and it doesn't have a main program.
12:10:34 <LoganCapaldo> Yes it's lousy
12:10:40 <LoganCapaldo> but it shouldn't have a main program
12:10:43 <newsham> kor: I think "lisp-like" is code for "has lambda expressions" (more realistically has closures and first class functions)
12:10:45 <LoganCapaldo> because its a module
12:10:46 <ddarius> Korollary: In some regards it's not all that far from Common Lisp.
12:10:48 <LoganCapaldo> reuse!
12:11:00 <Mauke> LoganCapaldo: I don't need a module, I need a rot13 script
12:11:21 <puusorsa> and preserving case would be nice
12:11:38 <Korollary> I think they mean CLOS-like.
12:12:22 <Korollary> obviously the kids of the 3rd world will all be indoctrinated in OO goodness.
12:12:41 <ddarius> newsham: What's the difference between a "closure" and a "first class function"?
12:12:50 <dons> well, at least they'll get lambdas
12:13:01 <Mauke> GNU C has closures but no first class functions
12:13:06 <ddarius>  Î»s âˆ€
12:13:32 <Korollary> Eh?
12:13:56 <swiert> @seen nominolo
12:13:57 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I don't know when nominolo last spoke.
12:14:03 <swiert> @seen mboes
12:14:04 <lambdabot> I haven't seen mboes.
12:14:19 <swiert> @seen lispy
12:14:20 <lambdabot> lispy is in ##logic, #xmonad, #haskell-soc, #haskell-blah, #haskell, #ghc and #darcs. I don't know when lispy last spoke.
12:14:25 <nominolo> swiert: i have one small patch i send it to you in a sec
12:14:38 <newsham> > > let f c = if isLower c then (chr.(+97).(`mod` 26).(+13).(subtract 97).ord) c else c in map f "test123"
12:14:38 <lambdabot>   parse error on input `>'
12:14:42 <newsham> > let f c = if isLower c then (chr.(+97).(`mod` 26).(+13).(subtract 97).ord) c else c in map f "test123"
12:14:42 <lambdabot>  "grfg123"
12:14:51 <swiert> nominolo: great. Are you happy with the rest of the article?
12:15:18 <newsham> ddarius: first class function is a function that can be passed around, closure is a function with an environmen attached to it?
12:15:22 <nominolo> swiert: what do you mean?
12:15:38 <swiert> nominolo: Is it ok with you if I release the issue?
12:15:49 <swiert> nominolo: or do you have more things you'd like to fix?
12:15:55 <ddarius> newsham: You mean like the difference between C function pointers and actual higher order functions?
12:15:59 <nominolo> swiert: oh, right sure, after the minor fixes
12:16:09 <newsham> ddarius: thats what I was getting at.
12:16:14 <swiert> nominolo: ok. Thanks.
12:18:00 <swiert> nominolo: Sorry I took so long to edit everything.
12:18:06 <hpaste>  LoganCapaldo annotated "Another inelegant rot13 (no rounding or ascii arith though)" with "Now with mainprog and case preservation" at http://hpaste.org/3944#a1
12:18:46 <newsham> ddarius: wait.. uh.. higher order?  thats just a function that takes functions, no?  you can do that in C, too.
12:18:51 <newsham> that doesnt imply closures.
12:19:28 <puusorsa> +
12:19:33 <ddarius> newsham: It does to me, at least in a language with lexical scoping which C is.
12:19:39 <nominolo> swiert: np
12:19:46 <Cheery> I have a bit peculiar problem
12:19:58 <ddarius> Also functions that return functions are higher order functions.
12:20:00 <Mauke> LoganCapaldo: that doesn't accept filenames as command line arguments
12:20:19 <Cheery> I have a set of symbols, {S, S', S''...} from which some symbols are known
12:20:26 <newsham> int id(int x) { return x; }     returnId() { return id; }
12:20:40 <Cheery> recognition of symbols depend from known symbols
12:21:00 <LoganCapaldo> Mauke: Ok?
12:21:23 <newsham> void foreach(f, data, len) { for(i=0; i<len; i++) f(data[i]); }
12:21:29 <newsham> both higher order.  no closures
12:21:32 <Cheery> then I have relations, like: A&B -> C, D -> C
12:21:48 * LoganCapaldo didn't realize there was a requirements list
12:22:05 <Cheery> the relations can be cyclic and very complex
12:22:23 <Mauke> LoganCapaldo: well, there's this perl one-liner I'm currently using :-)
12:22:46 <nominolo> swiert: ok, sent
12:22:46 <Cheery> how to remove symbols and relations that obsolete when a relation vanishes?
12:23:11 <LoganCapaldo> Oh well I wasn't trying to beat a perl one liner with haskell. I just thought cycle would be a fun way to avoid doing modular arithemtic :)
12:23:20 <ddarius> newsham: Write curry and uncurry.
12:23:20 <lament> man, OLPC interface guidelines sound so cool
12:23:23 <lament> http://wiki.laptop.org/go/OLPC_Human_Interface_Guidelines/The_Laptop_Experience#The_Journal
12:23:24 <lambdabot> Title: OLPC Human Interface Guidelines/The Laptop Experience - OLPCWiki, http://tinyurl.com/2jadfu
12:23:29 <pejo> newsham, I'd go with ddarius, he's usually right.
12:23:39 <newsham> ddarius: what does that prove?
12:23:42 <ddarius> pejo: It's a matter of definition.
12:24:59 <newsham> pejo: past performance is no guarantee of future success.
12:25:58 <dons> is anyone else scared by the fact   that the princeton's darpa challenge robot truck runs on C#
12:26:09 <newsham> the definition of "higher order function" isnt "can write curry and uncurry"
12:26:11 <nominolo> dons: why?
12:26:32 <Cheery> just wondering whether there's simple solution to such weird relations that won't need garbage collection
12:26:33 <allbery_b> not especially.  you'd prefer java?  c++?
12:26:41 <thetallguy> dons: yes, but...
12:26:44 <dons> seems like a place you'd want a bit of high assurnace
12:26:50 <nominolo> C# isn't that bad.  though having to pay $200+ for a profiler is weird
12:26:53 <dons> but oh well, they lost due to a memory leak
12:26:58 <goalieca> everytime i c# i have to p/invoke
12:27:00 <goalieca> and the gc sucks
12:27:05 <dons> i guess  they couldn't afford the profiler
12:27:09 <thetallguy> dons: I'm also scared by the whole handling of memory in Haskell
12:27:14 <dons> http://www.codeproject.com/showcase/IfOnlyWedUsedANTSProfiler.asp
12:27:15 <lambdabot> Title: If Only We’d Used ANTS Profiler Earlier... - The Code Project - Product Showcase
12:27:16 <newsham> "In mathematics and computer science, higher-order functions or functionals are functions which do at least one of the following: * take one or more funcitons as an input, * output a function"
12:27:29 <thetallguy> dons: I think it's the runtime that scares me.
12:27:33 <nominolo> dons: haskell wouldn't necessarily have helped with their particular problm
12:27:34 <dons> thetallguy: yeah. bring back timber, andy gill's strict haskell :)
12:27:42 <dons> nominolo: indeed
12:27:44 <newsham> I've already shown that C has higher order functions.
12:28:05 <thetallguy> dons: I haven't looked at the whole 'rewrite the runtime' project, but I should.
12:28:13 <allbery_b> but can you compose them on the fly?
12:28:16 <thetallguy> dons: don't know about timber, I will have to look for that.
12:28:38 <nominolo> if you have a strict haskell, do you still need monads?
12:28:44 <pejo> thetallguy, a bit early for adoption yet.
12:29:21 <newsham> nom: monads are needed (for side effects) because of purity, no?
12:29:42 <goalieca> more or less
12:30:01 <thetallguy> pejo: Depends on whther you want to adopt something full grown or not.
12:30:03 <newsham> so if you get rid of non-strict, but keep purity, still need em.
12:30:15 <nominolo> they're a way to structure FP code to model various side effects.  but you could use them for more.
12:30:33 <pejo> thetallguy, heh. Ok. Knock yourself out.
12:30:34 <MisterN> newsham: i don't think strict monads would work
12:31:01 <nominolo> guess i answered my own question ...
12:31:35 <thetallguy> pejo:  Just a joke.  Still reading.
12:32:52 <thetallguy> dons:  Oh yes, I remember seeing this.  Interesting stuff.  Thanks for the reminder.
12:33:25 <dmwit> Name the number one advantage of pattern matching.
12:33:41 <dmwit> (I chose "it simplifies complicated logic flows".)
12:33:50 <thetallguy> dmwit: Rorschach tests?
12:34:10 <geocalc> he
12:34:16 <dmwit> haha
12:34:32 <thetallguy> dmwit: improved textile sales?
12:34:50 <dmwit> Ok, ok, I'll write my own evangelism.
12:34:52 <dmwit> =P
12:34:58 <ricky_clarkson> dmwit: Pattern matching is a direct implementation of what you would otherwise write in a roundabout way.
12:35:01 <thetallguy> dmwit: tapping into our cognitive spatial mapping?
12:35:09 <ricky_clarkson> E.g., visitor pattern
12:36:30 <thetallguy> all the links at OGI are dying.
12:36:57 <pejo> thetallguy, looking for anything in particular?
12:37:54 <thetallguy> pejo: I was following the Timbot link, but this is the third of fourth link I've found in the last few months that is broken, all OGI
12:38:17 <thetallguy> pejo: One was Andy Gill's html combinator paper, which is referenced from the haddock docs'
12:38:40 <pejo> thetallguy, http://web.cecs.pdx.edu/~mpj/timbot/
12:38:41 <lambdabot> Title: Timbot, the Project Timber Robot
12:38:54 <thetallguy> The problem with referencing papers from haddock is the copyright transition.
12:39:30 <thetallguy> pejo: thanks, but the real question on my mind is, who to talk to about getting all of them restored?
12:40:48 <pejo> thetallguy, sorry, can't help you there.
12:41:30 <hpaste>  LoganCapaldo annotated "Another inelegant rot13 (no rounding or ascii arith though)" with "removed artifacts of my thought process" at http://hpaste.org/3944#a2
12:43:03 <gmh33> hi #haskell
12:43:04 <sorear> why would anyone use *haskell* for rot13, when you can just to tr 'a-zA-Z' 'n-za-mN-ZA-M'  (or for that matter, rot13)
12:43:08 <sorear> hello?
12:43:31 <gmh33> is ghc ported to ppc / OSX 10.5 yet?
12:43:39 <Cale_> sorear: because it's a good exercise?
12:43:47 <LoganCapaldo> sorear: because I can be pretty sure I got it right?
12:44:51 <phlpp> hi
12:48:09 <dons> gmh33: hmm. unknown. there's an open ticket for it on the bug tracker. chekc there for   the latest advice
12:48:27 <gmh33> dons: thanks
12:51:52 <Saizan_> in networking code, is it better style to use ErrorT IO or just IO with exceptions?
12:55:31 <dylan> @tell ddarius darcs requires ghc on gentoo.
12:55:32 <lambdabot> Consider it noted.
12:56:23 <newsham> sorear: how about  "tr (['a'..'z']++['A'..'Z']) (['n'..'z']++['a'..'m']++['N'..'Z']++['A'..'M']) ?
12:56:44 <newsham> where tr finds the index, if it exists, and uses the char at that index in the repl list?
12:56:51 <sorear> newsham: ick
12:59:36 <byorgey> Saizan_: I would think it's always better to use ErrorT than exceptions...
13:01:15 <reqamst> newsham: you can write somethink like that ;)
13:03:28 <hpaste>  LoganCapaldo annotated "Another inelegant rot13 (no rounding or ascii arith though)" with "it's now equivalent to the perl one liner. (I think :))." at http://hpaste.org/3944#a3
13:04:36 <basile> Hello All, I am Basile Starynkevitch, a newbie in Haskell (but familiar with Ocaml)
13:04:56 <dobblego> hello basile
13:05:49 <basile> I am ashamed to ask such a basic thing, but how should I compile the http://www.geocities.com/laitenberger/haskell/CGI/Counter.hs.html on Debian/Sid with ghc6
13:05:50 <lambdabot> Title: Counter.hs
13:07:22 <basile> I downloaded the example as counter.hs, installed the libghc6-cgi-dev package, and did ghc6 --make -v   counter.hs
13:07:44 <basile> so I got the Could not find module `CGI' message
13:08:03 <basile> Obviously I have to specify some search path for the CGI module
13:08:23 <hpaste>  newsham pasted "rot13. < reqamst> newsham: you can write somethink like that ;)" at http://hpaste.org/3945
13:10:44 <LoganCapaldo> basile: I think the name of the module has changed from CGI to Network.CGI
13:11:14 <LoganCapaldo> So I would try import Network.CGI first
13:12:55 <basile> Thanks for the tip. I changed the 3rd line of counter.hs to import Network.CGI
13:13:19 <LoganCapaldo> did it work? :)
13:13:29 <basile> Half worked.
13:13:35 <LoganCapaldo> ooo progress :)
13:13:43 <basile> I'm getting
13:13:43 <basile> *** Renamer/typechecker:
13:13:43 <basile> counter.hs:7:7: Not in scope: `wrapper'
13:14:09 <basile> Line 7 is main = wrapper counter
13:14:17 <cyberix> Can I create a parameter less lambda function?
13:15:07 <Olathe> > let x = 5 in x
13:15:09 <lambdabot>  5
13:15:16 <mrd> cyberix: all functions take precisely one parameter
13:15:19 <basile> BTW, is there some quick compare of Ocaml vs Haskell somewhere?
13:15:22 <mrd> you can ignore the parameter
13:15:22 <Olathe> x is, effectively, a parameterless lambda.
13:15:55 <Olathe> Or...
13:15:56 <Olathe> > 5
13:15:56 <mrd> you don't need functions to delay computation.  haskell does it by default.
13:15:58 <lambdabot>  5
13:16:02 <Olathe> 5 is a parameterless lambda.
13:16:15 <cyberix> It just feels stupid to define \x->True
13:16:23 <mrd> > const True
13:16:24 <lambdabot>  Add a type signature
13:16:27 <dobblego> cyberix, const True
13:16:38 <Olathe> @pl \x -> True
13:16:38 <lambdabot> const True
13:16:46 <dobblego> cyberix, \_ -> x is equivalent to const x
13:16:49 <Olathe> @pl sometimes gives nice, concise things.
13:16:50 <lambdabot> (line 1, column 21):
13:16:50 <lambdabot> unexpected ","
13:16:50 <lambdabot> expecting variable, "(", operator or end of input
13:17:07 <cyberix> Wow
13:17:11 <cyberix> Thanks :-)
13:17:24 <newsham> ?src const
13:17:24 <lambdabot> const x _ = x
13:17:27 <Olathe> No problem.
13:17:55 <vincenz> @hoogle a -> b -> b
13:17:56 <lambdabot> Prelude.const :: a -> b -> a
13:17:56 <lambdabot> Prelude.seq :: a -> b -> b
13:17:56 <lambdabot> Control.Parallel.par :: a -> b -> b
13:18:53 <LoganCapaldo> basile: seems like the module has changed somewhat since that was written
13:18:57 <LoganCapaldo> http://cvs.haskell.org/Hugs/pages/libraries/network/Network-CGI.html
13:18:59 <lambdabot> http://tinyurl.com/2td5eq
13:19:01 <LoganCapaldo> theres a wrapper
13:19:06 <LoganCapaldo> but it has a different type
13:20:34 <basile> Do you know where can I dowlload the source of this current CGI library, to understand how to build the examples, please?
13:21:00 <sorear> !source Network.CGI
13:21:08 <sorear> @source Network.CGI
13:21:08 <lambdabot> http://darcs.haskell.org/packages/network/Network/CGI.hs
13:21:16 <newsham> ghc docs dont have src link anymore :(
13:21:17 <Lemmih> basile: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cgi
13:23:20 <basile> Thanks, I downloaded it, but apparently no examples there...
13:26:03 <Lemmih> basile: hello world: main = runCGI $ output "Hello world"
13:27:19 <Lemmih> basile: or: main = runCGI $ do setHeader "Context-Type" "text/html"; output "<h1>Hello world</h1>"
13:29:17 <basile> Lemmih: thanks! Don't work as expected.
13:29:35 <basile> my hellocgi.hs file is
13:29:44 <basile> module Main (main) where
13:29:44 <basile> import Network.CGI
13:29:44 <basile> import Maybe(fromMaybe)
13:29:44 <basile> main :: IO ()
13:29:44 <basile> main = runCGI $ output "Hello world"
13:30:24 <basile> compiling it with  ghc6    hellocgi.hs gives
13:30:54 <basile> hellocgi.o: In function `r1gJ_info':
13:30:55 <basile> (.text+0x56): undefined reference to `mtlzm1zi0zi1_ControlziMonadziTrans_zdf1_closure'
13:30:55 <basile> hellocgi.o: In function `r1gL_info':
13:30:55 <basile> (.text+0xb6): undefined reference to `cgizm3001zi1zi1_NetworkziCGIziMonad_zdf3_closure'
13:30:55 <basile> hellocgi.o: In function `r1gN_info':
13:30:55 <basile> (.text+0x11a): undefined reference to `cgizm3001zi1zi1_NetworkziCGI_output_closure'
13:30:57 <basile> hellocgi.o: In function `r1gP_info':
13:30:59 <basile> (.text+0x17e): undefined reference to `cgizm3001zi1zi1_NetworkziCGI_runCGI_closure'
13:31:00 <Lemmih> basile: Use --make.
13:31:01 <basile> hellocgi.o: In function `r1gP_info':
13:31:15 <Lemmih> basile: And paste errors&code on hpaste.org
13:31:15 <basile> A big thanks!
13:31:55 <basile> Sorry for having pasted it here!
13:32:09 <basile> BTW --make is enough to get it.
13:33:00 <basile> Do any people recommend an Haskell tutorial for people knowing a bit functional programming
13:33:13 <dons> basile: probably yaht
13:33:14 <basile> (I am fluent both in Ocaml & CommonLisp, if it matters)
13:33:15 <dons> ?where yaht
13:33:15 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:33:23 <dons> oh, you should be fine then. ocaml will definitely help
13:33:30 <dons> you'll only have purity to get used to
13:34:54 <basile> Another dumb question: what are the options to selectively link static libraries.
13:35:06 <Luntain> i'm stuck, import Parsec inside WinHugs gives unexpected keyword "import"
13:35:16 <mrd> Luntain: import doesn't work on the prompt
13:35:28 <basile> The point is that my web hosting company (a cheap one) has only very basic *.so, so I'll better link most of them statically
13:35:36 <Luntain> I want to use Parsec, what should I do then?
13:35:47 <newsham> :module +Parsec ?
13:35:54 <ski> iirc, add it with "module manager" at the menu
13:35:55 <mrd> well in ghci you can :m +mod, but in hugs not sure
13:35:59 <newsham> :help lists the interactive meta commands
13:36:15 <mrd> or put it in a file and load that
13:36:24 <sorear> basile: GHC doesn't support dynamic linking, so no need to worry :)
13:36:35 <Luntain> :module +Parsec
13:36:36 <Luntain> ERROR - Cannot find module "+Parsec"
13:37:05 <newsham> :m +Text.ParserCombinators.Parsec ?
13:37:16 <basile> sorear: Fine for me but ldd of the hellocgi gives also libgmp.so.3 which I am not sure to have
13:37:24 * ski is not sure hugs supports the `+' annotations
13:37:45 <ski> Luntain : did you try "module manager" at the menu ?
13:37:48 <Lemmih> basile: -opt-c -s, I think.
13:37:49 <sorear> basile: Oh.  -optl-static maybe
13:38:07 <LoganCapaldo> is dynaic linking on the "todo list" at all for ghc?
13:38:09 <sorear> basile: also, ls /usr/lib - libgmp is very common
13:38:10 <basile> Thanks to all of you for your tremendous patience.
13:38:13 <sorear> LoganCapaldo: yes
13:38:25 <basile> Bye, I'll come back later!
13:38:31 <sorear> LoganCapaldo: chat with therp for a status report - it's actually mostly implemented
13:40:21 <vwx> hello, i'm adding gdk_screen_width_mm() function to gtk2hs, but what should it be called in haskell? screenWidthMM?
13:41:27 <LoganCapaldo> vwx: sounds good to me :)
13:41:45 <LoganCapaldo> not that my opinion matters
13:41:56 <byorgey> what's the "mm" stand for?
13:42:09 <vwx> millimeters
13:42:10 <LoganCapaldo> millimeter (guees?)
13:42:18 <byorgey> ahhh
13:42:49 <byorgey> I might do screenWidth_mm, but I could go either way
13:43:08 <byorgey> I'm sure there are those who would yell at me for mixing CamelCase and under_scores
13:43:22 <vwx> i haven't seen any functions so far in gtk2hs that have an underscore
13:43:36 <byorgey> yeah... it's not very common in Haskell names
13:43:56 <byorgey> the only reason I suggested that is because the standard abbreviation for mm is lowercase
13:44:07 <mightybyte> [xfgk
13:44:14 <byorgey> screenWidthMM is fine =)
13:44:18 <MisterN> how about screenWidth returning a mm-constructor?
13:44:19 <LoganCapaldo> a more interestoing quest might be, whats it's haskell return type gonna be?
13:45:18 <vwx> MisterN: there already is a gdk_screen_width() (screenWidth) function that returns width in pixels
13:45:51 <MisterN> vwx: hmm. bad.
13:45:52 <vwx> LoganCapalo: in gtk api it is gint, which everywhere else in gtk2hs is Int, so it will return Int
13:46:21 <LoganCapaldo> vwx: whay not newtype Millimeters = MM Int ?
13:46:44 * kfish keeps thinking of chocolate
13:46:49 <LoganCapaldo> deriving (Num, Eq, Ord, Show, Read)
13:47:20 <vwx> LoganCapalo: I think that might be unnecessary complexity
13:47:45 <vwx> LoganCapalo: besides, this is a function that almost no one uses
13:47:57 <LoganCapaldo> I think not doing that is unecessary simplification :)
13:48:15 <MisterN> out of curiosity... what would be the most haskellish way to return screen dimensions in pixels and millimeters?
13:48:16 <LoganCapaldo> not that my opinion matters :)
13:50:16 <kfish> with different types for pixels and mm, you could just provide toPixels and toMillimeters converters, and hide gdk_screen_width_mm() :-)
13:50:56 <kfish> and the equivalent would be "toMillimeters width" or whatever
13:51:37 <LoganCapaldo> well the problem with convertors for Pixels -> Millimeters is that you need to know resolution / dpi
13:52:00 <LoganCapaldo> So it makes sense to have two screen width functions IMO
13:55:15 <kfish> is the dpi (dpmm :-) different to screen_width / screen_width_mm ?
13:58:14 <vwx> i'm getting width: 1280, width_mm: 342
13:58:25 <vwx> height: 1024, height_mm: 271
13:59:06 <vwx> so the horizontal dpi is even different from the vertical dpi
14:00:58 <doserj> > (1280/342)-(1024/271)
14:00:59 <lambdabot>  -3.590772749832771e-2
14:01:03 <ihope> Ello. I'm trying to build lambdabot, and I'm getting "Setup.hs: cannot satisfy dependency network-any"
14:01:23 <ihope> > (1280/342)-(1024/271) :: Rational
14:01:23 <lambdabot>  (-1664)%46341
14:01:27 <dons> you'll need the network package from hackage, ihope
14:01:37 <dons> good to see  you back, too :)
14:01:48 <shachaf> dons: Does lambdabot work under GHC 6.8, by the way?
14:02:05 <dons> i've not been able to build it with 6.8 yet
14:03:55 <kfish> vwx, true, pixels are not square
14:05:56 <kfish> at this point the haskell nutcase goes and defines different types for vertical and horizontal pixel counts, and uses them for all positioning and dimensions
14:07:25 <slava> on what display hardware are pixels not square?
14:07:26 <slava> apple lisa? :)
14:07:38 <dons> heh
14:07:39 <allbery_b> lots of modern monitors, sadly
14:07:46 <slava> really? what about lcd?
14:07:59 <allbery_b> including lcd
14:08:01 <dons> i'd like hexagonal pixels
14:08:08 <byorgey> slava: go measure your monitor =)
14:08:26 <kfish> dons: to confuse bumblebees?
14:09:02 <dons> that would be part of the plan, yes, kfish
14:09:03 <slava> to confuse lesser programmers
14:09:13 <allbery_b> they're not outrageously rectangular, but they are generally not square
14:09:20 <dons> i've always had problems with bees
14:10:02 <allbery_b> you should do well in the US, then, as most of our bees are dead
14:10:06 <visof> is  X [Int] / Y [Int] acceptable ?
14:10:07 * Nafai just bought CTMCP
14:10:25 <visof> X and Y are Functions
14:10:33 <visof> that be applied on list
14:10:47 <allbery_b> between the african import bees, the mystery virus(?), and various other killers
14:11:23 <kfish> visof, what are the return types of X and Y? X, Y :: [Int] -> ??
14:11:38 <visof> Int
14:11:56 <doserj> @type (/)
14:11:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:12:27 <byorgey> Nafai: what's that?
14:12:35 <doserj> @instances Fractional
14:12:35 <lambdabot> Double, Float
14:13:21 <visof> > sum [1,2,3] / product [2,3,4]
14:13:21 <lambdabot>  0.25
14:13:56 <doserj> > sum [1::Int,2,3] / product [2,3,4]
14:13:57 <lambdabot>   add an instance declaration for (Fractional Int)
14:13:57 <lambdabot>     In the expression: (su...
14:14:50 <hircus> doserj: Int can't be fractional, by definition? does Haskell has a Rational type?
14:14:55 <visof> > let x y = sum y / product y in x [1,2,3]
14:14:55 <lambdabot>  1.0
14:14:59 <hircus> (if not you could easily define it)
14:15:17 <doserj> > 1/2 :: Rational
14:15:17 <lambdabot>  1%2
14:16:30 <Nafai> byorgey: "Concepts, Techniques, and Models of Computer Programming"
14:16:36 <visof> > let average  y = sum y / length y in x [1,2,3]
14:16:36 <lambdabot>   Not in scope: `x'
14:16:40 <Nafai> It's a textbook that has been compared to SICP
14:16:46 <visof> > let average  y = sum y / length y in average [1,2,3]
14:16:47 <lambdabot>   add an instance declaration for (Fractional Int)
14:16:47 <lambdabot>     In the expression: (su...
14:17:06 <byorgey> Nafai: cool.  who's the author(s)?
14:17:29 <allbery_b> :t genericLength
14:17:30 <lambdabot> forall b i. (Num i) => [b] -> i
14:17:43 <Nafai> Peter Van Roy and Seif Haridi
14:18:06 <LoganCapaldo> @type \y -> sum y / genericLength y
14:18:07 <lambdabot> forall a. (Fractional a) => [a] -> a
14:20:15 <ski> @where CTM
14:20:15 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
14:20:36 <geocalc> ^^
14:21:22 <dons> hi grahamhutton
14:21:30 <grahamhutton> hi don
14:28:57 <visof> @type show
14:28:57 <lambdabot> forall a. (Show a) => a -> String
14:32:39 <phlpp> @index isInfixOf
14:32:39 <lambdabot> bzzt
14:32:44 <dons> ?tiny-url
14:32:44 <lambdabot> Url not valid.
14:32:44 <phlpp> @index (isInfixOf)
14:32:45 <lambdabot> bzzt
14:32:46 <dons> ?tiny-url http://sigfpe.blogspot.com/2007/11/whats-all-this-e8-stuff-about-then-part.html
14:32:46 <lambdabot> http://tinyurl.com/35vpbe
14:32:49 <phlpp> @index `isInfixOf`
14:32:49 <lambdabot> bzzt
14:32:54 <phlpp> eh?
14:33:07 <dons> sigfpe on E8, yay! http://programming.reddit.com/info/60u88/comments/
14:33:08 <phlpp> @hoogle isInfixOf
14:33:08 <lambdabot> No matches found
14:33:22 <phlpp> strange
14:33:28 <ihope> @hoogle infix
14:33:29 <lambdabot> Prelude.infix :: keyword
14:33:29 <lambdabot> Data.Generics.Basics.Infix :: Fixity
14:33:29 <lambdabot> Text.ParserCombinators.Parsec.Expr.Infix :: GenParser t st (a -> a -> a) -> Assoc -> Operator t st a
14:33:39 <LoganCapaldo> @type any isPrefixOf . tails
14:33:39 <lambdabot>     Couldn't match expected type `Bool'
14:33:39 <lambdabot>            against inferred type `[a] -> Bool'
14:33:39 <lambdabot>     In the first argument of `any', namely `isPrefixOf'
14:33:46 <dons> so i'm waiting for Control.E8 to be written
14:34:05 <ihope> @type (any, isPrefixOf)
14:34:06 <lambdabot> forall a a1. (Eq a1) => ((a -> Bool) -> [a] -> Bool, [a1] -> [a1] -> Bool)
14:34:21 <LoganCapaldo> @type \xs xss -> any (isPrefixOf xs)  (tails xss)
14:34:22 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:34:38 <ihope> @pl \xs xss -> any (isPrefixOf xs)  (tails xss)
14:34:39 <lambdabot> (. tails) . any . isPrefixOf
14:34:42 <phlpp> @index isPrefixOf
14:34:42 <lambdabot> Data.List
14:34:47 <phlpp> so der is no isInfixOf?
14:34:53 <phlpp> anymore?
14:35:00 <LoganCapaldo> there isn't one yet
14:35:09 <LoganCapaldo> UI believe is the actual answer
14:38:39 <phlpp> is there something like replacing a string? in the simple version, it would be nice, if i have some function f, looks for a string in an other string and replaces the string found by an other string
14:39:22 <dons> no, but you can do it pretty quickly with splitAt and so on
14:39:27 <phlpp> so something like we have "foobar", and i'm looking for "oob" and want to replace it by "x", the function should return "fxbar".  i thought i could write such a function with the help of isInfixOf
14:39:33 <phlpp> but it's not that what i want
14:39:43 <phlpp> ok, i'll look at this stuff
14:39:48 <phlpp> +have a
14:40:10 <phlpp> @hoogle splitAt
14:40:10 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
14:40:10 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
14:40:10 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
14:40:19 <phlpp> @doc splitAt
14:40:19 <lambdabot> splitAt not available
14:41:19 <davidL> @doc Data.List
14:41:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
14:43:32 <dikini> @Â£$%  ghc6.8.1 is bleeding fast!
14:43:32 <lambdabot> Unknown command, try @list
14:45:02 <LoganCapaldo> > let replace needle replacement haystack = if null haystack then [] else (if needle `isPrefixOf` haystack then replacement ++ (drop (length needle) haystack) else (head haystack):(replace needle replacement (tail haystack))) in replace "world" "universe" "Hello, world!"
14:45:03 <lambdabot>  "Hello, universe!"
14:45:21 <LoganCapaldo> yes for some bizzare reason I used nested ifs
14:45:44 <matthew-_> @seen njbartlett
14:45:45 <lambdabot> njbartlett is in #scala and #haskell. I don't know when njbartlett last spoke.
14:45:56 <njbartlett> You rang?
14:46:19 <matthew-_> yes. did you video the last hug talk?
14:46:23 <matthew-_> (sorry I couldn't be there)
14:46:43 <njbartlett> Yes I did
14:46:57 <matthew-_> ahh. Have you uploaded it to me?
14:47:06 <njbartlett> No problems. I still have to do all the editing and encoding crap though. It takes bloody ages
14:47:30 <matthew-_> ahh ok. Well give me a shout when it's done - just stick it in monotone like before and I'll host it happily
14:47:38 <njbartlett> Thanks very much
14:47:55 <njbartlett> I meant to have a chat with you after the Armstrong talk but it went on a bit long
14:48:11 <matthew-_> it certainly did. I've just written it up at wellquite.org actually
14:48:20 <njbartlett> And I've just read it
14:48:32 <matthew-_> though it's not really focussed just on his talk...
14:48:40 <matthew-_> ahh! it was /you/ who read it ;)
14:48:55 <njbartlett> Well I presume Matthias did as well, since he linked to it ;-)
14:49:10 <matthew-_> yeah. it seems likely.
14:49:37 <njbartlett> So, I need to find a speaker and subject for the HUG in January
14:49:58 <njbartlett> Anybody here in UK?
14:49:58 <matthew-_> true.
14:50:06 <chessguy> @seen sigfpe
14:50:06 <lambdabot> I haven't seen sigfpe.
14:50:20 <chessguy> @seen dpiponi
14:50:20 <lambdabot> I haven't seen dpiponi.
14:50:34 <njbartlett> @seen ndm
14:50:34 <lambdabot> I haven't seen ndm.
14:50:45 <chessguy> @seen chessguy
14:50:45 <lambdabot> You are in #haskell. I last heard you speak just now.
14:50:50 <chessguy> ok, just making sure
14:50:55 <dikini> njbartlett: yep, why?
14:51:40 <njbartlett> dikini: I organise the London Haskell User Group. I'm looking for a speaker to talk about pretty much anything to do with Haskell, sometime in January.
14:51:45 <dikini> but I'm no speaker, sorry, missed that bit :(
14:51:54 <njbartlett> dikini: And if that's not your cup of tea, maybe you're just like to come along anyway?
14:52:02 <ddarius> njbartlett: There are tons of people here (though not necessarily here right now) in the UK.
14:52:02 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
14:52:41 <dikini> njbartlett: I might, depends on how busy I am at the time, is there a url?
14:52:41 <njbartlett> ddarius: Yeah I'm sure there are. Just wondering who was about right at this minute.
14:52:50 <njbartlett> dikini: londonhug.net
14:53:23 <njbartlett> dikini: We've just had a meeting though, so we haven't scheduled the next one yet.
14:54:12 <dikini> njbartlett: now worries, I'll plug it in my reader
14:54:28 <njbartlett> Great :-)
14:54:36 <vwx> @seen dcoutts_
14:54:36 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
14:55:43 <ddarius> @seen dons
14:55:43 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 3m 18s ago.
14:55:48 <ddarius> @seen SyntaxNinja
14:55:48 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 21h 51m 48s ago, and .
14:56:13 <dons> ddarius: ?
14:56:36 <njbartlett> Okay here's another idea, and anybody can answer this one, not just people near London. What Haskell-related subjects would you like to hear about, assuming a reasonably knowledgeable speaker could be found to talk about it?
14:57:04 <ddarius> dons: Is there a possibility for Galois providing a venue for AmeroHaskell somewhere in Portland? and/or who else should I talk to (not necessarily Galois related)?
14:57:28 <chessguy> AmeroHaskell?
14:57:29 <dons> mm. yes, that's possible. in fact, we've just set up a PDX Haskell user's group last week
14:57:40 <dons> so hmm. possible, possible
14:57:40 <ddarius> @wiki AmeroHaskell
14:57:40 <lambdabot> http://www.haskell.org/haskellwiki/AmeroHaskell
14:58:07 <ddarius> Currently, shapr and I are probably looking at a January or maybe February time-frame.
14:58:25 <ddarius> Probably only a few days and < 50 people, probably more around 20 or so.
14:58:41 <chessguy> err, if it's for haskellers in SE USA, why is the possible location listed as Portland?
14:59:14 <dons> :)
14:59:16 <ddarius> chessguy: Originally, it was hoped for that, but looking at the people who listed interest and the availability of venues, Portland seems like a much better place for the majority.
14:59:24 <njbartlett> dons: Surely a Portland Haskell user's group is either (a) entirely Galois or (b) mostly Galois and a few people who are looking for a job at Galois :-)
14:59:26 <dons> all your lambdas belong to portland
14:59:44 <dons> njbartlett: galois, PSU, intel and random hackers in the city
15:00:05 <ddarius> dons: How big is the PDX Haskell user's group?
15:00:31 <dons> well, we had 10 for the unplanned intiial meeting. so i'd say 20+ (it has started as a fork of the local ruby group + galois and psu)
15:00:45 <dons> we'll see who comes to the first meeting, after it gets announced
15:01:06 <ddarius> Well, I imagine essentially all of them would go to AmeroHaskell if it gets on its feet and is in Portland.
15:01:27 <dons> i'd say a fair few would go
15:01:30 <dikini> does anyone have any estimate how many people use/speak haskell?
15:01:38 <ddarius> dikini: No.
15:01:43 <njbartlett> Wow, Portland is really a hotbed of furtive functional programming
15:01:48 <vwx> 200,000
15:01:49 <ddarius> dikini: People have probably significant underestimates though.
15:01:51 <chessguy> i might go if it was actually in the SE
15:01:58 <chessguy> but not if it's all the way in portland
15:02:04 <ddarius> dikini: The best bet would be to try to extrapolate something from the GHC downloads.
15:02:13 <dons> dikini: we taught 500 a year for 10 years in sydney how to program haskell, and that's just one uni, one course
15:02:30 <dons> ddarius: and hugs, which is still used in schools
15:02:43 <ddarius> chessguy: SE would be much easier for shapr and I and a few others, but there just doesn't seem to be enough demand or anyone with access to a good (read free) place.
15:02:48 <lament> most of those 500 probably hate haskell?
15:02:58 <dons> lament: you're a grump today
15:03:10 <lament> i know the reactions of people learning scheme in uni
15:03:12 <ddarius> dons: GHC downloads are probably a good indicator of people who are more serious about Haskell.
15:03:12 <njbartlett> dons: Yeah but on the other hand I was taught SML at uni and now it is completely absent from my brain.
15:03:13 <LoganCapaldo> It's beause he doesn't like imitting pronouns
15:03:17 <dons> ddarius: yep
15:03:18 <LoganCapaldo> *omitting
15:04:15 <dikini> ddarius: no idea about the downloads, based on #haskell/#drupal population ratio and number of drupal users... a very indecent estimate would be 300000 :)
15:07:15 <dons> well, based on irc stats, there's more haskell than ruby users :)
15:07:18 <dons> i love statistics
15:07:29 <dons> we're also more attractive
15:07:41 <ihope> Well, I have network-2.1.0.0 downloaded from HackageDB. Now what do I do with it?
15:07:56 * ddarius doesn't think he's seen too many (any?) ruby users.
15:08:02 <dons> build and install (e.g. untar, cabal configure;build;install)
15:08:39 <dons> #haskell, avg 374, #ruby-lang , avg 364
15:09:00 <dons> next above us is #python, avg: 401
15:09:02 <dons> we can do it!
15:09:29 <ddarius> dons: We will before long.  Especially when the next killer Haskell app comes out.
15:09:41 <Nafai> ddarius: What will that be? :)
15:10:01 <ddarius> Nafai: If I knew what it would be, I'd work on it.
15:10:10 <dons> yeah, i'd like to see some new things
15:10:14 <dons> xmonad is boring now
15:10:37 <dons> i'm over darcs
15:10:42 <Nafai> Yeah, honestly the two "big" Haskell applications are xmonad and darcs
15:10:43 <dons> pugs is dead
15:10:45 <dons> what's new?
15:10:46 <Nafai> We need something else!
15:10:50 <LoganCapaldo> what you mean my rot13 program isn't the killer app for haskell? :(
15:11:27 <ihope> We need a very generic AI program in Haskell!
15:11:35 <ddarius> ihope: Get on it!
15:11:40 <ihope> And by generic, I probably mean general.
15:11:40 <chessguy> ai :: Problem -> Solution
15:12:08 <chessguy> ihope, the correct term is "strong AI"
15:12:08 <LoganCapaldo> type Solution = Problem
15:12:08 <waern> haskell game engine on the ps3!
15:12:12 <ddarius> ai :: RandomRamblings -> Problem
15:12:14 <ihope> I have Artificial Intelligence: A Modern Approach beside me. I'm kind of looking at the chapter 1 exercises.
15:12:18 <ihope> Oh yes, strong AI.
15:12:21 <ddarius> Problem -> Solution is relatively easy.
15:12:46 <ihope> Is the Riemann hypothesis easily expressible as a Problem?
15:12:57 <ddarius> ihope: Relatively, yes.
15:13:00 <dons> i want Control.E8
15:13:05 <dons> anyone working on that? :)
15:13:10 <dons> i'm sure there's a paper in there somewhere
15:13:23 <reqamst> What is Control.E8?
15:13:25 <LoganCapaldo> What's E8?
15:13:30 <ihope> Does that mean solving it is relatively easy? :-)
15:13:32 <ddarius> What's Control?
15:13:45 <LoganCapaldo> soemthing I have none of!
15:13:47 <LoganCapaldo> :)
15:13:57 <chessguy> @quote control
15:13:58 <lambdabot> dcoutts says: I'm confident but lacking style and control [about skiing]
15:14:10 <LoganCapaldo> @go E8
15:14:11 <lambdabot> http://en.wikipedia.org/wiki/E8_(mathematics)
15:14:11 <lambdabot> Title: E8 (mathematics) - Wikipedia, the free encyclopedia
15:14:11 * ddarius recommends the Bad Religion song "No Control" (on the album No Control) to LoganCapaldo 
15:14:42 * ihope creates a file called ai.hs and puts "module AI where" at the top of it
15:14:47 <ihope> I'm halfway done, right?
15:14:50 <LoganCapaldo> dons: This wikipedia article is scaring me
15:14:51 <chessguy> heh
15:15:02 <ddarius> ihope: Yep.  The rest of the program should only take one line so...
15:15:09 <ihope> Yeah!
15:15:17 <chessguy> @remember ihope /me creates a file called ai.hs and puts "module AI where" at the top of it. I'm halfway done, right?
15:15:17 <lambdabot> I will remember.
15:15:23 <dons> LoganCapaldo: i figure monads for control are trivial, delimited continuations are passe, comonads make me yawn
15:15:28 <dons> E8 is where its at
15:17:02 <ihope> main = do args <- getArgs; runAI args where runAI (x:xs) = ...; runAI [] = putStrLn usageNotes; usageNotes = "..."
15:17:33 <Luntain> possiblity of using not yet defined name is interesting, where could I learn more about it?
15:17:33 <Luntain> foo = bar + 1
15:17:33 <Luntain> bar = 1
15:17:41 <Skyp> hm... is it possible in haskell to have a function with a variable number of parameters? imagine a function f which takes another function g (which can take 1,2,3,... parameters) as first parameter and passes the rest of the parameters to g... can that be done?
15:18:17 <LoganCapaldo> > printf "Var args are %s" "A pain in the neck" :: String
15:18:20 <lambdabot>  "Var args are A pain in the neck"
15:18:37 <LoganCapaldo> > printf "%d + %d = 4" 3 1:: String
15:18:38 <lambdabot>  "3 + 1 = 4"
15:18:40 <ihope> Luntain: if I understand what you mean, there's really not much to it; there simply isn't a restriction stating that a declaration can only refer to things defined in previous declarations.
15:18:50 <ihope> Oh my.
15:18:54 <ihope> @type printf
15:18:56 <lambdabot> forall r. (PrintfType r) => String -> r
15:19:03 <ihope> What could I expect...
15:19:17 <ihope> > printf "%s" 3 :: String
15:19:18 <lambdabot>  Exception: Printf.printf: bad argument
15:19:22 <ddarius> Skyp: There are a couple of ways.  The simplest would be just to have the function take a list of parameters.
15:19:23 <LoganCapaldo> Skyp: yes but it requires type class hackery
15:19:45 <LoganCapaldo> or do waht ddarius says
15:20:51 <Skyp> Hm, using a list would be an option, but I would like to avoid that... LoganCapaldo, what should I search for to use varargs?
15:21:10 <LoganCapaldo> you could look at the printf source
15:21:12 <Luntain> ihope: it is different to any other lang I know
15:21:13 <shapr> @yow !
15:21:14 <lambdabot> Sometime in 1993 NANCY SINATRA will lead a BLOODLESS COUP on GUAM!!
15:21:31 <shapr> Yow! Polyvariadic arguments!
15:21:40 <ddarius> shapr: I'm starting to compose an AmeroHaskell email for haskell and haskell-cafe hoping to see if there is more interest.
15:22:04 <Skyp> Hm, ok... I fear this is simple example, but I will have a look ;)
15:22:07 <Skyp> thx ;)
15:22:08 <LoganCapaldo> amerohaskell? where? cn i come?
15:22:12 <shapr> ddarius: yay!
15:22:20 <shapr> LoganCapaldo: Portland, Jan or Feb, depending on interest, and yes.
15:22:26 <ihope> Luntain: do you feel there's something about it that you don't know?
15:22:48 <Nafai> Hey shapr!
15:22:56 <ddarius> shapr: I'm going to see if there might be more interest anyway, but mention that otherwise something intended for Portland and Jan/Feb is in mind.
15:22:57 <shapr> Hiya Nafai!
15:23:04 <ddarius> (more interest for other places in the US)
15:23:04 <shapr> ddarius: Good idea!
15:23:35 <shapr> I'll be happily surprised if there's a center of interest anywhere outside of Portland.
15:24:12 <shapr> I'd estimate (from what dons said earlier) that Portland itself has 20 people who'd show up, and I'd estimate there's about that number in the rest of the US who might show up.
15:24:59 <shapr> On the other hand, maybe there's more interest than that, your email should tell us!
15:25:15 <dons> ah, so now i have ghc 6.8.1 built with specconstr patch
15:25:20 * dons hopes for more speeds!
15:26:19 * Heffalump looks forward to the results
15:26:46 <ihope> ai :: Monad m => Environment m -> Strategy m
15:27:04 <ihope> Now let's define Environment and Strategy.
15:27:31 <LoganCapaldo> erm
15:27:41 <LoganCapaldo> methinks that function is mis-kinded
15:27:54 <LoganCapaldo> well may be no
15:28:00 <ihope> Environment, Strategy :: (* -> *) -> *
15:29:21 <shapr> ihope: ooh, this looks interesting.
15:29:22 <LoganCapaldo> newtype Environment m = Env (m (Environment m)) ?
15:29:39 <shapr> ihope: Why not have them as monad transformers?
15:30:04 <ihope> Environment and Strategy as monad transformers? Interesting.
15:30:44 <shapr> That might make for composable Strategy monads, yes?
15:30:48 <ihope> Environment m a would be an environment accessible via m and eventually returning a, I guess.
15:31:01 <ihope> Sounds good.
15:31:24 <ihope> What's this about composing Strategy monads?
15:32:26 <shapr> Well, why not?
15:32:47 <LoganCapaldo> why not indeed
15:33:01 <ihope> Strategy m (Strategy m) a -> Strategy m a, hmm...
15:33:09 <shapr> A navigation monad could be wrapped around a problem solving monad.
15:33:18 <shapr> I'm thinking about writing bots for tremulous, of course.
15:33:22 <ihope> I guess a strategy for producing a strategy is indeed a strategy.
15:33:29 <ihope> tremulous, you say?
15:33:32 <shapr> First get to the enemy, then attack the enemy.
15:33:37 * ihope nods
15:33:42 <Japsu> bots for tremulous IN HASKELL?!?
15:33:46 <shapr> Japsu: Well, why not?
15:33:49 <Japsu> ;)
15:33:55 <shapr> Japsu: Have you ever written AI in C?
15:33:56 <LoganCapaldo> @go tremulous
15:33:57 <lambdabot> http://www.tremulous.net/
15:33:57 <lambdabot> Title: T R E M U L O U S :: NEWS
15:34:00 <Japsu> shapr: nope
15:34:08 <shapr> Japsu: Me neither, but I don't want to start!
15:34:10 <Japsu> but well, tremulous bots in hs would be really cool
15:34:21 <ihope> And I guess an environment returning an environment can be interpreted as an environment.
15:35:04 <shapr> ihope: Would be so that location of the ai in map itself could be dealt with by one monad, and location of the players dealt with by another monad?
15:36:00 <ihope> I think the monad m would be something like TremulousIO.
15:36:19 <ihope> A Strategy TremulousIO () is a strategy for Tremulous.
15:36:23 <shapr> I'm just wondering how EnvironmentT would be useful.
15:37:19 <ihope> I guess an environment is sort of like a function from perception to action.
15:38:28 <ihope> Environment m p d a: m is the monad that's required for converting d, the decision, into p, the perception, and either returning a or continuing on.
15:38:47 <ihope> (p d m a, I guess, if it should be a monad transformer.)
15:39:38 <ihope> Environment should probably include some description of the environment, not just the functions.
15:40:39 <ihope> So that a Strategy for playing in a chess Environment wouldn't have to learn the rules of chess by playing.
15:41:48 <shapr> ihope: It sounds cool, is there any code?
15:41:49 <LoganCapaldo> but that's cheating! I had to learn the rule sfor chess by playing :)
15:42:38 <ihope> Well, instead of p and d, maybe there should be some general perception/action expression thingy.
15:42:49 <ddarius> Email away
15:42:53 <ihope> data Perception = Perception String [Perception]
15:43:59 <ihope> I guess decisions would have the same structure.
15:44:26 <ihope> No code; it's still in the thought stage.
15:44:53 <ihope> Environment is essentially a description of an environment, and it takes many words to be able to describe absolutely everything.
15:45:27 <ihope> How do you say "is the Riemann hypothesis true?" in Environment?
15:46:19 <ihope> Strategy should be much simpler, consisting only of the functions.
15:48:22 <ihope> My first guess: data Strategy m a = Strategy (m (Perception, Integer) -> m (Decision, Strategy m a)) | Stop (m a)
15:48:40 <ihope> The Integer is the reward/punishment.
15:52:22 <ddarius> Anyone interested in AmeroHaskell and who might be able to provide a talk on something, I added a section for that to the AmeroHaskell wiki page ( http://www.haskell.org/haskellwiki/AmeroHaskell )  Additions would be appreciated.
15:52:23 <lambdabot> Title: AmeroHaskell - HaskellWiki
15:55:00 <dons> i love cabal install
15:55:17 <hpaste>  dikini pasted "(no title)" at http://hpaste.org/3946
15:55:59 <reqamst> Why?
15:56:02 <dikini> can I express this algorithm better, I think out of brain cells?
15:56:30 <ddarius> Pseudonym: What's up with the combinatorial identity?
15:57:12 <ddarius> dons: Will mkcabal magically make projects mixed with C magically trivial?
15:58:18 <LoganCapaldo> Is MkCabal a fast food resturant?
15:58:50 <Pseudonym> @remember LoganCapaldo Is MkCabal a fast food resturant?
15:58:51 <lambdabot> Okay.
15:58:56 <dons> ddarius: nope. its way underdeveloped
15:59:02 <dons> C is easy though, cabal can handle it
16:01:41 <vwx> i'm having trouble adding a new module to gtk2hs
16:06:16 <heatsink> Is there a (Floating a, Floating b) => a -> b in the prelude?
16:06:43 <heatsink> ....somewhere else would be okay too.
16:06:49 <ddarius> @hoogle (Floating a, Floating b) => a -> b
16:06:50 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
16:06:50 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
16:06:50 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
16:06:58 <basti_> o.0
16:07:15 <ddarius> @src Real
16:07:16 <lambdabot> class  (Num a, Ord a) => Real a  where
16:07:16 <lambdabot>     toRational      ::  a -> Rational
16:07:20 <ddarius> @src RealFrac
16:07:20 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
16:07:20 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
16:07:20 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
16:07:30 <Nafai> Is there a more idiotmatic way to add two lists together than "map (uncurry (+)) $ zip list1 list2" ?
16:07:34 <ddarius> :t fromRational . toRational
16:07:36 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
16:07:48 <heatsink> Nafai: zipWith
16:07:52 <ddarius> Nafai: zipWith (+)
16:08:00 <ddarius> @free zipWith
16:08:01 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
16:08:01 <Nafai> Nice
16:08:04 <Nafai> Thanks
16:08:41 <heatsink> > fromRational (toRational (1/3 :: Double)) :: Float
16:08:43 <lambdabot>  0.33333334
16:08:43 <ddarius> :t \f -> map (uncurry f) . zip
16:08:43 <lambdabot>     Couldn't match expected type `[(a, b)]'
16:08:43 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
16:08:43 <lambdabot>     In the second argument of `(.)', namely `zip'
16:09:24 <ddarius> heatsink: I think there is something like fromRational . toRational similarly to fromIntegral = fromInteger . toInteger, but I don't recall what it is called.
16:09:49 <ddarius> @hoogle zipWith
16:09:50 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:09:50 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
16:09:50 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
16:10:01 <heatsink> thx darius.
16:10:28 <heatsink> > toRational (1/3)
16:10:28 <lambdabot> Terminated
16:10:33 <heatsink> huh?
16:10:39 <ddarius> @undefine
16:10:40 <lambdabot> Undefined.
16:10:44 <ddarius> > toRational (1/3)
16:10:44 <lambdabot>  6004799503160661%18014398509481984
16:11:10 <MisterN> heh
16:11:22 <MisterN> @type toRational
16:11:22 <lambdabot> forall a. (Real a) => a -> Rational
16:11:24 <newsham> unrational
16:11:24 <ddarius> Nafai: zipWith is in a family that starts, repeat, map, zipWith, zipWith3, ... etc
16:11:56 <ddarius> It defaults to Double and then does a conversion from Double -> Rational which apparently results in that rational number
16:14:28 <ddarius> Does one need special permissions to revert a page on haskellwiki?
16:15:40 <vwx> how can i add a prefix to all the constructors of an enum in c2hs?
16:17:03 <marceau> > toRational(0.333333333333)
16:17:04 <lambdabot>  6004799503154657%18014398509481984
16:17:12 <marceau> > toRational(0.33)
16:17:13 <lambdabot>  5944751508129055%18014398509481984
16:17:45 <wli> They're not exactly representible.
16:17:52 <wli> You want BCD floating point.
16:17:55 <ddarius> > 1%3
16:17:56 <lambdabot>  1%3
16:18:25 <newsham> > 3 * (5944751508129055%18014398509481984)
16:18:26 <lambdabot>  17834254524387165%18014398509481984
16:18:30 * wli is working on it.
16:18:39 <wli> http://holomorphy.com/~wli/BCD.lhs
16:19:19 <Pseudonym> GMP floats are also good.
16:19:32 <newsham> > fromRational $ 3 * (5944751508129055%18014398509481984) :: Float
16:19:33 <lambdabot>  0.99
16:20:07 <dons> ddarius: not really
16:20:15 <dons> there's political issues, of course
16:20:17 <newsham> > fromRational $ 3 * (toRational (1/3)) :: Float
16:20:17 <lambdabot>  1.0
16:20:21 <MisterN> > (fromRational $ 3 * (5944751508129055%18014398509481984) - 1) :: Float
16:20:21 <lambdabot>  -1.0e-2
16:20:22 <ddarius> So just edit it to an old version?
16:20:43 <marceau>  > fromRational $ 3 * (6004799503160661%18014398509481984) :: Float
16:20:49 <Pseudonym> This paper is co-authored by a Pixar guy named "Maxwell Planck".
16:20:57 * Pseudonym can only imagine the ribbing he gets about that
16:21:04 <dons> mm
16:21:34 <ddarius> What's wrong with Planck?
16:21:45 <Pseudonym> Just having a name that's like a famous person.
16:21:46 <heatsink> He's a physicist?
16:21:54 <Pseudonym> No.
16:22:02 <Pseudonym> But he's a scientist at Pixar.
16:22:09 <newsham> could be worse.. "michael bolton"
16:22:19 <Pseudonym> I was thinking that, yeah.
16:22:47 <Olathe> Michael Jackson.
16:22:55 <Pseudonym> I was thinking that, too.
16:22:59 <wli> There's a British poet named that.
16:23:00 <Pseudonym> Jackson Standard Design
16:23:08 <wli> (Michael Jackson, that is.)
16:23:13 <newsham> ("why should I have to change?  he's the ass clown")
16:23:13 <Pseudonym> (Do people learn JSD any more?)
16:23:42 <Pseudonym> Jackson System Development
16:23:45 <Pseudonym> That's it.
16:23:48 <Pseudonym> http://en.wikipedia.org/wiki/Michael_A._Jackson
16:23:57 <Olathe> Pseudonym: Never heard of it.
16:24:23 <augustss> I think JSD fell out of fashion
16:24:28 <Pseudonym> YEah.
16:24:41 <Pseudonym> I think it was replaced by OOAD pretty much everywhere in academia.
16:24:45 <newsham> i have a book about whisk{ey,y} by michael jackson
16:27:30 <ddvlad> is there an elegant way to read an array of Ints from the keyboard? some one-line jewel that will drop my jaw to the ground?
16:27:56 <dons> from the keyboard?
16:28:12 <Korollary> or standard input?
16:28:24 <wli> ddvlad: do { a :: Array Int Int <- readLn ; print a }
16:28:26 <ddvlad> standard input, sorry
16:28:33 <dons> yep, without { } :)
16:28:42 <dons> 'read' is what you're looking for
16:29:18 <dons> Prelude> x :: [Int] <- readLn
16:29:18 <dons> [1,2,3,4]
16:29:19 <dons> [1,2,3,4]
16:29:49 <ddvlad> so, if I get this straight, lists implement class Read?
16:30:00 <chessguy> @instances Read
16:30:00 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
16:30:02 <shachaf> ddvlad: Wait, do you want a list or an array?
16:30:17 * dons guess list
16:30:18 <newsham> > map read (words "1 2 3 4 5") :: [Int]
16:30:19 <lambdabot>  [1,2,3,4,5]
16:30:39 <newsham> if its space-separated format
16:30:42 <ddvlad> shachaf: list, sorry. i'm coming from C mostly
16:31:16 <dons> that's fine :)
16:31:21 <dons> welcome to the other side
16:31:36 * chessguy always catches himself talking about 'lists' in javascript
16:31:36 <dons> do you have a sense for how to do this now?
16:31:45 <ddvlad> dons: the other side is tempting but hard to grasp
16:31:49 <shachaf> @quote other.side
16:31:49 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
16:31:59 <chessguy> @quote other
16:31:59 <lambdabot> Conor says: We could all sit in a long line with laptops, and talk to each other on #haskell
16:31:59 <Korollary> ddvlad: which tutorial or book are you following?
16:32:02 <dons> ddvlad: won't take long. being here is worth 25% i reckon
16:32:35 <ddvlad> dons: it takes long because school goes the other way -- all C, Java, assembly and the like
16:33:11 <dons> oh, that's a pity. a bit too 1994 for my taste
16:33:12 <ddarius> Assembly is nice.
16:33:13 <ddvlad> Korollary: nothing right now, read a bit of the wikibook, "haskell for c programmers", "all about monads" (almost done), and a few other minor things
16:33:21 <newsham> dddv: how vocational
16:33:38 <ddvlad> dons: i was in first grade in 1994, but i still agree :-(
16:33:59 <ddarius> Wow, you kids.
16:34:10 <dons> heh
16:34:17 <Korollary> kids are teh future!
16:34:28 <Pseudonym> Well hell, I was an undergrad in 1994, and they tought us JSD.
16:34:30 <ddvlad> ddarius: assembly is nice, but not tasm. i was hoping to learn integration with gcc and all
16:34:37 <Pseudonym> Which was a bit too 1974 for my taste.
16:34:38 <ddarius> I loved tasm.
16:34:46 <ddvlad> "loved"
16:34:51 <Nafai> What's JSD?
16:34:59 <Korollary> tasm was better than masm iirc. I don't think I loved it per se.
16:35:00 <ddarius> I haven't hacked too much assembly and I'd probably use nasm nowadays.
16:35:11 <ddarius> (too much assembly recently)
16:35:23 <ddvlad> i have to boot windows or run dosbox for assembly work alone, since i'll probably have to memorise some interrupts as well
16:35:29 <ddarius> Continuation passing style steals most of the allure of assembly.
16:35:40 <Nafai> The only assembly I've done significantly is MIPS stuff in my architectures and compilers courses
16:35:46 <Korollary> ddarius: what is assembly's allure for you?
16:35:58 <Pseudonym> We did 68k in the early 90s.
16:36:15 <defcons> Pseudonym, wow, you must be old
16:36:18 <ddarius> Korollary: Back in the day, the direct hardware access was nice.  But generally, interesting control structures that you couldn't easily get in C.
16:36:21 <Korollary> I wrote 68k on an Amiga and 386 on PCs
16:36:24 <ddarius> Yep, Pseudonym is an old man.
16:36:26 <Pseudonym> Well, I had a Sun 3/50 on my desk.
16:36:28 <defcons> :D
16:36:32 <newsham> pseudo: lucky.  68k is the cadillac of assembly (i hear vax is nicer, but i'm not that old)
16:36:34 <Pseudonym> Mind you, it got passed down the foodchain.
16:36:46 <Pseudonym> I like that analogy.
16:36:59 <Pseudonym> 68k is pretty, shiny and guzzles like anything.
16:37:07 <Korollary> 68k certainly is better than 386
16:37:13 <ddarius> By that analogy what is x86?
16:37:19 <wli> I've always been partial to MIPS.
16:37:22 <newsham> ever see massalin's superoptimizer paper for 68k?
16:37:26 <hpaste>  conal pasted "Tree variations: top-down/bottom-up, binary, rose, finite/infinite" at http://hpaste.org/3948
16:37:29 <Pseudonym> x86 defies analogy
16:37:37 <defcons> it's the lamborghini merciolago of course!
16:37:38 <Pseudonym> Yeah.
16:37:41 <Pseudonym> That was a good paper.
16:37:45 <Korollary> x86 is an overly succesful engineering solution
16:37:58 <newsham> x86 is as to organically grown city dating back to 1500s
16:38:02 <Pseudonym> How would you describe an over-zealous Z80 that got added to over the years?
16:38:10 <Pseudonym> It's like a truck with a two-stroke engine.
16:38:33 <wli> Cue Dijkstra on reasoning by analogy and the Middle Ages.
16:38:36 <Pseudonym> OK, that's unfair.
16:38:45 <Pseudonym> The 8086 was a mostly clean break from the 8085.
16:39:10 <MisterN> x86-64 works. use that.
16:39:30 <ddarius> The Itanium had a lot of cool looking stuff in it.
16:39:43 <Pseudonym> Yeah, well...
16:39:47 <conal> i've been playing with nested types and ways to refactor trees.  some fun.  see the paste.
16:39:58 <ddarius> conal: Nested data types are massively underused.
16:40:05 <Pseudonym> I can imagine some benefit to the IA64, but...
16:40:10 <ddarius> conal: We have polymorphic recursion, we should use it.
16:40:11 <heatsink> yeah, but they put it in the Itanium before they figured out how to do good out-of-order execution on x86.
16:40:12 <newsham> organic growth aint pretty.  you end up with weird things like appendicitus
16:40:18 <Pseudonym> I think that languages like C compile poorly to it.
16:40:28 <repnop> ix86 is funny
16:40:32 <repnop> rep nop = thread lock? :p
16:40:32 <defcons> I want functional ASM
16:40:34 <defcons> AND NOW
16:40:35 * LoganCapaldo writes C++ on itanium
16:40:51 <Pseudonym> LoganCapaldo: And the AMD64 beats the pants off it, no doubt.
16:40:56 <vwx> anyone here from gtk2hs?
16:40:59 <repnop> well delay the current thread not lock :)
16:41:04 <newsham> defcons: does it have to support side effects?
16:41:14 <ddarius> Pseudonym: The Itanium does look like it would take a lot of effort to compile to well.
16:41:24 <Pseudonym> Only for traditional languages.
16:41:26 <Pseudonym> I suspect.
16:41:27 <LoganCapaldo> Pseudonym: well once VMS gets ported to AMD64 maybe :)
16:41:39 <LoganCapaldo> til then I can't compare
16:41:41 <Pseudonym> LoganCapaldo: I am so, so sorry for you.
16:41:41 <MisterN> Pseudonym: unfortunately those are used heavily.
16:41:44 <MisterN> duh.
16:41:46 <heatsink> ddarius: For Haskell code, or in general?
16:41:54 <ddarius> heatsink: In general.
16:42:11 <conal> ddarius: agreed!
16:42:19 <wli> There will never be another architecture ever again. x86-64 is the last architecture. We are now stuck with x86 forever.
16:42:20 <heatsink> Yeah, it does.  The compiler needs to do all the scheduling that out-of-order does automagically at runtime.
16:42:26 <defcons> newsham, do it in a monad :p
16:42:30 <Pseudonym> MisterN: I'm not defending the Itanium here.
16:42:53 <MisterN> Pseudonym: good
16:43:01 <MisterN> wli: well
16:43:06 <Pseudonym> But, for example, I can imagine an IA64 implementation (perhaps not the Itanium specifically) which does better on High Performance Fortran-like code, for example.
16:43:11 <MisterN> wli: possibly there will be a 128-bit architecture
16:43:18 <Pseudonym> Where you can extract a lot of parallelism.
16:43:19 <MisterN> but x86-64 is indeed quite practical
16:43:44 <idnar> wli: sparc will save us!!!!111oneone
16:43:56 <geocalc> lol
16:44:19 <wli> x86-64 is a horror. It's like Leatherface from the Texas Chainsaw Massacre becoming Secretary General of the UN.
16:44:47 <repnop> well at least they added more registers
16:44:51 <twanvl> conal: what about Monad instances?
16:45:29 <heatsink> Pseudonym: ia64 significantly outperforms x86 on tight loops if you can software pipeline them.  Does pretty good on ALU-heavy code in general.
16:45:36 <SamB> huh. mozilla seems to have regressed
16:45:46 <newsham> how about an integer processor that supports a large array of integer iorefs?
16:45:55 * ddarius misses Firebird.
16:46:02 <newsham> and lets you index into this array to alter individual ioref integers?
16:46:10 <geocalc> wli abacus is for you ;)
16:46:13 <newsham> with a functional unit that supports integer operations?
16:46:18 <MisterN> wli: why's x86-64 so bad for you?
16:46:22 <conal> twanvl: oh yeah.  i don't use monads much.
16:46:24 * SamB installed iceape and it looks like Netscape 4
16:46:47 <Philippa> MisterN: because it's an x86 derivative
16:46:52 <ddarius> I liked Netscape 4 at the time.
16:46:54 <conal> twanvl: i don't know if any of these types are monads
16:46:56 <wli> MisterN: Floating point is still gravely abnormal, tons of register class oddities and other integer register nastiness, etc.
16:47:07 <Philippa> it's the bastard child of decades worth of hardware hacks
16:47:14 <ddarius> conal: I'd have to look closer, but I imagine most of them are.
16:47:31 <MisterN> wli: floating point? SSE works and that's all i care about
16:47:38 <conal> ddarius: please do.  my guess is none.
16:47:44 <MisterN> wli: registers are always messy, aren't they?
16:47:58 <wli> MisterN: Not on properly constructed architectures.
16:48:03 <ddarius> Darn it.  I was about to play guitar.
16:48:11 <MisterN> wli: lol
16:48:12 <newsham> mistern: there are cleaner system designs.
16:48:13 <MisterN> wli: dream on
16:48:14 <dons> ?seen nad
16:48:14 <lambdabot> I haven't seen nad.
16:48:28 <MisterN> newsham: so? serious advantages?
16:48:37 <Philippa> newsham: there're probably cleaner system designs at the bottom of cesspits
16:48:50 <newsham> what do you mean "so?"  you just hinted that "they're always messy" and I said "no they're not"
16:48:53 <newsham> there is no "so"
16:48:56 <Pseudonym> WHy don't we just program in MMIX.
16:49:06 <Philippa> MisterN: ease of code generation and assembly coding?
16:49:17 <Philippa> which translates into faster and more correct code
16:49:39 <Pseudonym> Actually, for cleanliness, I think you can't go far past Alpha.
16:49:44 <ddarius> conal: You'd probably have to add the Empty constructor to them (or some kind of singleton) and then it should be straight forward.
16:49:50 <newsham> not all tomatos have five wheels and a bull horn
16:49:52 <wli> Alpha would've been nice.
16:49:54 <ddarius> Comonads can probably be done immediately on what is there.
16:50:06 <MisterN> Philippa: oh, i didn't know that compilers have any difficulties dealing with x86-64 ;)
16:50:19 <wli> I can't be arsed with IA64.
16:50:22 * LoganCapaldo also programs C++ on alpha
16:50:29 <newsham> mistern: how about disassemblers?
16:50:34 <LoganCapaldo> I am the king of dead archs! :)
16:50:40 <newsham> how about binary translators?
16:50:47 <MisterN> newsham: how about don't care?
16:50:58 <Philippa> how about STFU then?
16:50:58 <Pseudonym> newsham: Hell, the x86 does binary translation in hardware.
16:50:58 <wli> I weep every day and night for Alpha.
16:51:01 <newsham> would you rather write a disassembler for em64t or sparc?
16:51:08 * repnop would rather use IDA :p
16:51:10 <idnar> we may be stuck with x86-64, but that doesn't mean we have to like it
16:51:14 <hpaste>  (anonymous) annotated "GHC failing. Should I ask OS support  instead?" with "(no title)" at http://hpaste.org/3926#a1
16:51:23 <MisterN> idnar: hating it is a waste of time
16:51:33 <Philippa> if you don't care that's fine, but it also means you're not in a position to complain at people who do care
16:51:34 <Pseudonym> High performance computing happens despite the x86 ISA, not because of it.
16:51:35 <idnar> MisterN: it doesn't require any time at all
16:51:39 <MisterN> it works well enough and it isn't _seriously_ flawed
16:51:39 <idnar> MisterN: it's just a state of mind ;)
16:51:48 <MisterN> no, it slows you down
16:51:56 <MisterN> and it requires a few time-slots of its own
16:52:02 <newsham> stupid internet argument.  "XXX sucks"  "no it doesnt" "yes it does and here's how"  "I dont care"
16:52:02 <Philippa> what would count as "seriously flawed" in your book?
16:52:07 <newsham> g'bye
16:52:11 <idnar> MisterN: you might say that C "works well enough" and isn't "seriously flawed", so why bother with Haskell or any other language?
16:52:12 <wli> If Intel would've gone with Alpha instead of that iA64 bullcrap the state of computing would be 10 years ahead of where it is today.
16:52:28 <MisterN> idnar: other languages give us serious advantages
16:52:29 <Pseudonym> MisterN: Hardware manufacturers have approached high-profile Haskellers asking them what the next generation of CPUs would do that they don't know.
16:52:30 <Philippa> wli: that's a bit of an overstatement. Market forces suck sometimes
16:52:34 <Pseudonym> Not just Haskellers, of course.
16:52:37 <MisterN> cleanliness is no real advantage in assembly
16:52:40 <Pseudonym> Java, ML, whatever.
16:52:41 <Philippa> now, if Alpha had taken off sufficiently...
16:52:44 <newsham> wli: I thikn 10 yrs is a little generous, dont you?
16:52:52 <SamB> wli: well, it seems unlikely that it would be behind where it is today
16:52:53 <geocalc> stuck on your nigthmare
16:52:56 <idnar> MisterN: making compilers not have to jump through insane hoops to generate good code is a serious advantage
16:53:00 <Pseudonym> The point is: If you didn't think about this, you wouldn't have an answer.
16:53:04 <SamB> but I'm doubtful as to how well alpha would have taken...
16:53:11 <MisterN> idnar: but the compilers already have those hoops
16:53:15 <wli> I don't believe in "market forces." There are only the super-rich dictating to everyone else.
16:53:28 <idnar> MisterN: well, they're still busy building the hoops
16:53:29 <ddarius> MisteN: Are you crazy?
16:53:32 <heatsink> Pseudonym: It's an interesting qn. Do you have an answer?
16:53:34 <newsham> heh.  yes, its a grand scheme of rich people
16:53:44 <Philippa> wli: even then there's the issue of which super-rich people got the final say
16:53:44 <SamB> wli: it seems to have one of the same biggest "drawbacks" as ia64
16:53:46 <Pseudonym> heatsink: I have a couple of suggestions.
16:54:03 * heatsink listens
16:54:04 <Pseudonym> The #1 feature asked for by Lisp implementors is trapping arithmetic.
16:54:05 <idnar> MisterN: and there's a maintenance cost to all those hoops; along with a tax on future improvements
16:54:11 <dons> dcoutts_:
16:54:11 <dons> $ c
16:54:12 <dons> cabal-setup: 'parseField' called on a non-field.  This is a bug.
16:54:12 <SamB> wli: arguably, the super-rich are just really really really strong market forces
16:54:15 <Pseudonym> Trap on integer overflow.
16:54:19 <MisterN> and there's a HUGE cost to changing architecture
16:54:33 <idnar> MisterN: it also makes it harder to build faster CPUs
16:54:36 <Pseudonym> A year or so ago, I'd have said transactional caches/store buffers.
16:54:40 <repnop> an ia32 frontend to intel/amd chips doesn't use much die space
16:54:40 <Pseudonym> But Sun is actually doing that now.
16:54:54 <dons> dcoutts_: missing library: keyword
16:55:18 <MisterN> idnar: well, if there is an architecture much much better than x86-64, go for it
16:55:24 <Pseudonym> Apart from that, I'm not sure.  Maybe some facility for pointer tag extraction?
16:55:28 <wli> Philippa: Range TLB flushing. void flush_tlb(unsigned addr_space, vaddr_t start, size_t len);
16:55:30 <Pseudonym> In one cycle?
16:56:07 <SamB> Pseudonym: that reminds me of so many of x86's instructions...
16:56:21 <Pseudonym> I think that one of the most unfortunate pieces of design in modern CPUs is the status flag.
16:56:28 <Pseudonym> Like, say, the carry flag.
16:56:31 <idnar> I thought "the super-rich dictating to everyone else" was basically the definition of market forces
16:56:33 <SamB> I agree
16:56:43 <davidL> dons: have you ever used runplugs on openbsd?
16:56:49 <Pseudonym> It's an effective serialisation of code which doesn't need to be serialised.
16:56:52 <SamB> MMIX carries it to an extreme with no less than 32 seperate special-purpose registers
16:57:11 <SamB> 26 of which, I think, I have one letter names...
16:57:17 <Philippa> Pseudonym: that's a tricky one if you want to keep word size and integer size in step though
16:57:26 <MisterN> i always wonder why people thing market forces are something to believe in
16:57:29 <Pseudonym> Philippa: Nope.
16:57:35 <MisterN> it's something to understand goddamnit
16:57:41 <Pseudonym> Imagine you had an IA64-like flag register.
16:57:55 <Pseudonym> And instead of using a single carry flag, you could say which flag the carry goes into.
16:57:56 <MisterN> -thing+think
16:58:15 <Philippa> fair enough - IOW, add a pile of 1bit regs
16:58:18 <Pseudonym> Yeah.
16:58:32 <SamB> or a pile of status registers
16:58:33 <Pseudonym> Or, alternatively, specify a second "result register" which received either 0 or 1.
16:58:33 <LoganCapaldo> mm pile
16:58:42 <Pseudonym> Doesn't the MIPS do that?
16:59:04 <LoganCapaldo> I want to specify a result address (continuation)
16:59:17 <SamB> oooh, the Z machine does that ;-)
16:59:22 <LoganCapaldo> add dest, src1, src2, jsucc, jfail
16:59:50 <Pseudonym> LoganCapaldo: Ouch.
16:59:56 <Pseudonym> That's going to hurt.
17:00:00 <dons> davidL: sure.
17:00:02 <Philippa> LoganCapaldo: you know that "subtract and branch if not zero" is turing complete on its own? :-)
17:00:04 <Pseudonym> In a pipeline-stall kind of way.
17:00:14 <SamB> LoganCapaldo: how is add going to fail?
17:00:21 <Philippa> Pseudonym: you can take a good guess at PC+1 in most cases though
17:00:24 <SamB> also why can't it just go to the next instruction on success
17:00:29 <idnar> SamB: overflow
17:00:34 <idnar> (I guess?)
17:00:56 <davidL> dons: I get some error like unknown symbol memcpy, http://hpaste.org/3795
17:00:59 * LoganCapaldo continues to fail at making jokes in this channel
17:01:09 <heatsink> Pseudonym: What would we do with transactions?  Add them as a programming language feature?
17:01:20 <wli> There was a 12-issue MIPS at one point.
17:01:25 <ihope> > fail "at making jokes in this channel"
17:01:26 <lambdabot>   add an instance declaration for (Show (m a))
17:01:28 <wli> They called it "the Beast."
17:01:39 <ihope> What an interesting error.
17:01:53 <idnar> :t fail "at making jokes in this channel"
17:01:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
17:02:00 <idnar> heh
17:02:08 <SamB> how many could it commit?
17:02:09 <twanvl> conal: perhaps you should abstract out the 'a' in each node, data TreeT = TreeT (f (TreeT f a)) {- aka Mu -}, then for what now is (TreeT f), you get (TreeT ((,) a `O` f)). You can also put values in the leaves, with (TreeT (Either a `O` f))
17:02:50 <Pseudonym> heatsink: Well, there are plenty of CPU operations that don't have native language support.
17:02:53 <Pseudonym> e.g. cache barriers
17:03:03 <Pseudonym> So I can imagine it as a library.
17:03:16 <Pseudonym> However... here's my idea circa a year ago.
17:03:24 <Pseudonym> What if you didn't allow pipeline stalls at all?
17:03:36 <Pseudonym> If a branch is mispredicted, you abort the transaction and try again.
17:03:43 <Pseudonym> Or a page fault.
17:03:52 <wli> Pseudonym: Just overprovision functional units or something.
17:04:02 <heatsink> Pseudonym: checkpointing processors taken to the extreme?
17:04:39 <allbery_b> sun2, anyone?
17:04:52 <SamB> Pseudonym: how is that going to stop you from stalling on a memory write?
17:04:54 <wli> heh
17:05:05 <SamB> or read
17:05:08 <wli> Memory reads stall more often.
17:05:13 <Pseudonym> SamB: You start a cache read, and abort the transaction.
17:05:22 <Pseudonym> I'm thinking really micro-transations here.
17:05:28 <SamB> what happens instead of stalling?
17:05:29 <Pseudonym> Like, smaller than a basic block.
17:05:36 <wli> You just need insanely deep read/write queues.
17:05:57 <Pseudonym> Well, you issue a fix for whatever caused the stall.
17:06:03 <Pseudonym> e.g. a cache I/O
17:06:06 <SamB> that sounds like stalling
17:06:21 <wli> It's not stalling until the memory units' queues are full.
17:06:28 <Pseudonym> But, rather than waiting, you just kill whatever is in the ROB and any memory writes that it did.
17:06:48 <Pseudonym> Then start issuing something else.  Like, say, another hyperthread.
17:07:21 <Pseudonym> And yeah, it sounds expensive, but you have to consider that precise traps are expensive at the moment.
17:07:25 <SamB> what if the predicted target had issued a write to a memory-mapped hardware register, followed by a read of that same register?
17:07:34 <SamB> what happens then?
17:07:46 <Pseudonym> SamB: The write wouldn't be comitted until you completed the transaction.
17:07:56 <SamB> and the read?
17:08:14 <Pseudonym> SamB: There would surely be a cache barrier between those two instructions, no?
17:08:22 <Pseudonym> That's effectively a commit.
17:08:25 <SamB> ... how is that not a stall?
17:08:25 <wli> bbiaw. I need a shredder, groceries, and some kind of bullcrap (clothes, NFI what else) for a Krav Maga class tomorrow.
17:09:35 <Pseudonym> SamB: Guessing for a moment that hyperthreads make sense here...
17:09:41 <conal> twanvl: i like that suggestion.  thanks.
17:09:41 <Pseudonym> You don't stall on commit.
17:10:00 <Pseudonym> What you do is schedule another hyperthread, which runs until the first thread completes its commit.
17:10:17 <Pseudonym> So the thread stalls, but the pipeline doesn't.
17:10:19 <SamB> that sure sounds like a stall to MEEE
17:10:49 <wli> Tha's not very useful. Just get memory units with really deep queues.
17:11:14 <Pseudonym> wli: As SamB points out, that doesn't help with atomic memory operations.
17:11:16 <wli> So they don't stall until you get 1024 outstanding reads.
17:11:38 <Pseudonym> I/O and synchronisation, mostly.
17:20:00 <hpaste>  ddarius annotated "Tree variations: top-down/bottom-up, binary, rose, finite/infinite" with "stab at monads for these trees (untested)" at http://hpaste.org/3948#a1
17:20:33 <dons> get yr stream fusions, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion
17:20:35 <lambdabot> http://tinyurl.com/38larw
17:20:41 <dons> dcoutts_: ^
17:22:44 <dons> $ cabal install stream-fusion
17:22:58 <dons> Building stream-fusion-0.1...
17:23:02 <dons> Registering stream-fusion-0.1...
17:23:06 <dons> cabal install roxors
17:24:04 <Lemmih> cabal = cabal-setup + cabal-install?
17:24:20 <dons> yep (i think cabal-setup is in there now)
17:24:34 <ddarius> conal: Those probably only satisfy the monad laws up to some "observation" function a la the Tree monad and a traversal.
17:24:51 <shapr> w00!
17:25:08 <ddarius> x11@
17:26:12 <dons> need a little blog post about using the stream fusion package, with some cabal install tossed in
17:26:28 <Korollary> dons: why don't we just hire a PR firm?
17:26:43 <dons> good idea. worked for ruby
17:26:44 <Korollary> "Paris Hilton seen transforming monads"
17:26:45 <ddarius> Because dons is cheaper.
17:27:00 <dons> its kind of pointless to do all this work, if no one knows about it.
17:27:06 <dons> and python's boring.
17:27:08 <andyjgill> Why pay a PR firm when we have a bot to do it for us.
17:27:31 <dons> oh, i should run hpc on the stream-fusion testsuite
17:27:38 <lambdabot> Haskell iz teh r0Xx0Rz!!!!eleven!
17:27:42 <dons> since it has all the laziness properties as well, which would be quite curious
17:27:48 <ddarius> What?! You don't run HPC on all your code?
17:27:49 <vwx> any gtk2hs devs here?
17:27:55 <dons> ddarius: well, it was written pre-hpc
17:28:01 <ddarius> Excuses.
17:28:03 <dons> so mostly guess work about coverage
17:28:04 <cwitte> I just had a problem with cabal and I just wanted to know if it is a known problem: I was trying to install a package that needed cabal >1.2 (it had CabalVersion: >=1.2 in the cabal file) , and I only had 1.1.3, but instead of giving me a useful error message like you need a newer version of cabal I ended up getting an error about something wrong with the executeable stanza (presumably some kind of parse error)
17:28:22 <dons> yeah, cabal 1.1.3 won't give good errors about versions
17:28:24 <dons> that's known.
17:28:30 <dons> something about 'executable stanzas' and so on
17:28:44 <dons> 1.2 and better do give good errors for this case
17:29:03 <cwitte> thanks dons
17:30:14 <heatsink> Pseudonym: So what's the point of eliminating pipeline stalls?  To do more useful work?
17:30:16 <dons> there's a lovely SML impl too, of just the raw combinators (not the rules, or list library versions), http://mlton.org/pipermail/mlton-user/2007-April/001091.html
17:30:16 <lambdabot> Title: [MLton-user] Stream Fusion
17:30:40 <hpaste>  conal annotated "Tree variations: top-down/bottom-up, binary, rose, finite/infinite" with "Mu and bottom-up puzzle" at http://hpaste.org/3948#a2
17:30:48 <LoganCapaldo> Where's the Stream Fission?
17:31:10 <dons> mm, split up single loops into lots of little ones, eh?
17:31:40 <ddarius> dons: Um... is it useful without the RULES?
17:32:07 <dons> ddarius: you have to write in terms of the combinators alone. i'm not sure how they get the fusion rule to fire
17:32:21 <dons> ah, they manually fuse it
17:32:35 <dons> i.e. write in terms of the Stream data type directly
17:33:03 <ddarius> dons: Doesn't that defeat the point?
17:33:17 <dons> depend on the goal
17:33:24 <dons> maybe they just want to write fast code
17:33:38 <dons> the stream type we use is in the mlton prelude now, i noticed
17:33:49 <ddarius> Interesting.
17:33:51 <dons> so they care about speed so much they want people writing these things directly
17:34:18 <LoganCapaldo> heh
17:34:30 <LoganCapaldo> .. must .. be .. better .. than .. C ...
17:34:32 <dons> "the Extended Basis library now includes a scaled down
17:34:32 <dons> implementation of streams using a universal type:"
17:34:42 <dons> http://mlton.org/cgi-bin/viewsvn.cgi/mltonlib/trunk/com/ssh/extended-basis/unstable/detail/sequence/stream.sml?view=auto
17:34:47 <lambdabot> Title: Repository - markup - svn: mltonlib/trunk/com/ssh/extended-basis/unstable/detail ..., http://tinyurl.com/35u7j5
17:34:52 * LoganCapaldo pants heavily from manual stream fusion
17:35:16 <hpaste>  conal annotated "Tree variations: top-down/bottom-up, binary, rose, finite/infinite" with "combined top-down & bottom-up" at http://hpaste.org/3948#a3
17:37:47 <dataangel> I know you can define map in terms of fold like so: map f x = fold (\x xs -> f x : xs) [] -- But is there anyway to replace the lambda with a composition of f and (:)? Feels like there should be some version of compose that works that way
17:38:20 <dons> sure
17:38:29 <dons> ?pl x xs -> f x : xs
17:38:30 <lambdabot> (line 1, column 6):
17:38:30 <lambdabot> unexpected ">" or "-"
17:38:30 <lambdabot> expecting variable, "(", operator or end of input
17:38:35 <dons> ?pl \x xs -> f x : xs
17:38:35 <lambdabot> (:) . f
17:38:35 <allbery_b> @pl \x xs -> f x : xs
17:38:36 <lambdabot> (:) . f
17:38:40 <dons> even lambdabot can do it :)
17:38:54 <dons> so your intuition was right
17:38:56 <dataangel> What is @pl?
17:39:07 <Olathe> @help pl
17:39:07 <lambdabot> pointless <expr>. Play with pointfree code.
17:39:07 <dons> a term rewriting tool for haskell
17:39:20 <dataangel> ah
17:39:21 <ihope> @pl \x y z -> x z (y z)
17:39:21 <lambdabot> ap
17:39:23 <Olathe> It's a completely pointless tool.
17:39:32 <ihope> Is not!
17:39:35 <dons> @unpl (:) . f
17:39:35 <lambdabot> (\ c -> ((:)) (f c))
17:39:36 <Olathe> ;)
17:39:40 <ihope> @pl Olathe
17:39:40 <lambdabot> Olathe
17:39:45 <ihope> See, you're already pointless.
17:39:48 <dons> hah
17:39:57 <dataangel> I tried that actually but it didn't work for my example
17:40:24 <Olathe> ;(
17:40:29 <dataangel> > foldr ((:) . (+1)) 0 [1..5]
17:40:31 <lambdabot>   add an instance declaration for (Num [a])
17:40:41 <dataangel> How do I do that? :P
17:40:48 <ddarius> @free foldr
17:40:49 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
17:41:16 <Olathe> >
17:41:20 <ddarius> foldr (:) [] is id so stick that in and solve
17:41:25 <ihope> dataangel: that error, in other words, is "[a] is not a Num", meaning a list is not a number.
17:41:28 <Olathe> > foldr ((:) . (+1)) [0] [1..5]
17:41:31 <lambdabot>  [2,3,4,5,6,0]
17:41:33 <dataangel> > foldr ((:) . (+1)) [] [1..5]
17:41:34 <lambdabot>  [2,3,4,5,6]
17:41:38 <dataangel> ah noice
17:41:45 <Olathe> > map (+1) [1..5]
17:41:46 <lambdabot>  [2,3,4,5,6]
17:41:49 <dataangel> I misread the error
17:42:00 <Olathe> > [2..6]
17:42:00 <lambdabot>  [2,3,4,5,6]
17:42:04 <dataangel> I thought it was complaining that 1 was of type Num a instead of something specific, and annotating it with Int didn't help
17:42:23 <Olathe> > foldl ((:) . (+1)) [] [1..5]
17:42:24 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:42:24 <lambdabot>       Expected...
17:42:29 <Olathe> Lies.
17:42:53 <Olathe> @pl \x -> [x]
17:42:53 <lambdabot> return
17:42:54 <ihope> I know @pl once gave me an expression containing fix id.
17:42:58 <ihope> Gee, thanks.
17:43:09 <Olathe> > foldl ((++) . return . (+1)) [] [1..5]
17:43:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:43:09 <lambdabot>       Expected...
17:43:18 <ihope> And no, my input wasn't \x -> x x :-P
17:43:36 <LoganCapaldo> @unpl fix id
17:43:36 <lambdabot> fix (\ a -> a)
17:43:47 <LoganCapaldo> @pl fix (\a -> a)
17:43:47 <lambdabot> fix id
17:43:57 <Olathe> @unpl Olathe
17:43:57 <lambdabot> Olathe
17:44:02 <LoganCapaldo> was your input fix (\a -> a)?
17:44:09 <Olathe> I'm both pointless and unpointless.
17:44:19 <LoganCapaldo> @pl (\x -> Olathe x)
17:44:20 <lambdabot> Olathe
17:45:18 <Olathe> @help unpl
17:45:18 <lambdabot> pointful <expr>. Make code pointier.
17:45:28 <Olathe> I'm maximally pointy.
17:46:24 <LoganCapaldo> it only thinks your maximally pointy because it assumes you're a constructor with no arguments
17:46:29 <dataangel> Are haskell compilers smart enough to combine folds over the same data into single folds returning tuples? (one iteration versus many)
17:46:43 <Olathe> LoganCapaldo: I have no arguments against that.
17:46:47 <sjanssen> dataangel: not generally
17:47:16 <dataangel> sjanssen: generally the compilers or generally for different kinds of folds?
17:47:18 <ddarius> dataangel: That isn't always a win if not done carefully.
17:47:25 <dataangel> ddarius: why not?
17:47:28 <ddarius> @google Haskell tupling transform
17:47:29 <lambdabot> http://fi.mimuw.edu.pl/abs69.html
17:47:29 <lambdabot> Title: FI Abstracts, vol. 69
17:47:38 <sjanssen> dataangel: I don't know of any compilers that do that
17:48:03 <dataangel> unfortunately that link has no paper to d/l
17:48:06 * dataangel looks around
17:48:12 <dons> dataangel: well, that's a fusion transformation
17:48:25 <dataangel> sjanssen: but it's the coolest thing I've read about fold so far... waaaaaaah
17:48:40 <ddarius> I'd have to find the paper that discusses it, but it that probably taken more effort then I'm willing to put out.
17:49:16 * ddarius read everything on fold fusion and just folds initial/final (co)algebras etc. when he was first staring Haskell.
17:49:22 <ddarius> There is tons of cool stuff out there.
17:49:41 <ddarius> @google Initial algebras are enough
17:49:42 <lambdabot> http://crab.rutgers.edu/~pjohann/tlca07-rev.pdf
17:49:52 <sjanssen> dataangel: it wouldn't be hard to make a small combinator library to combine folds
17:50:17 <Olathe> Is there a tuple to list function ?
17:50:44 <ddarius> Olathe: It would have to be a family/type class of them, and it wouldn't be generally useful.
17:50:55 <Olathe> Ahh.
17:51:29 <LoganCapaldo> @type return ("sure there is", 2, Just True)
17:51:30 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m ([Char], t, Maybe Bool)
17:51:40 <LoganCapaldo> :)
17:52:04 <dataangel> ddarius: any other recommended reading from when you started? ;)
17:52:09 <Olathe> > (return (3, 4, 5))::[Int]
17:52:10 <lambdabot>  Couldn't match expected type `Int'
17:52:15 <Olathe> :|
17:52:27 <Olathe> > (return (3, 4, 5))::[(Int, Int, Int)]
17:52:28 <lambdabot>  [(3,4,5)]
17:52:31 <ddarius> dataangel: That paper wasn't from when I started (/me started around 2002) but it is an awesome paper if you understand it.
17:52:36 <LoganCapaldo> see, tuple to list
17:52:58 <dataangel> tuple to list of tuple, but not tuple to list
17:53:34 <dataangel> ddarius: I'm reading the "tutorial on the universality and expressiveness of fold" ATM
17:53:42 <ddarius> That's a nice paper.
17:55:56 <hpaste>  heatsink pasted "Haskell smilies (just for fun)" at http://hpaste.org/3950
17:56:35 <ddarius> dataangel: The Bananas, Lenses and Barbed Wire paper is always good
17:57:47 <LoganCapaldo> heatsink: impressive
17:58:00 <heatsink> thx :)
17:58:07 <LoganCapaldo> but what's an OwO face?
17:58:22 <heatsink> An owl, I think.
17:58:22 <ddarius> dataangel: Give me a sec and I'll give you a few other good ones hopefully.
18:02:56 <dataangel> ddarius: sweet
18:03:30 <ddarius> dataangel: Bananas in Space and Revisiting Catamorphisms over Datatypes with Embedded Functions (the latter led to proof techniques for use in things like Coq), Merging Monads and Folds for Functional Programming, Dealing with Large Bananas, Recursion Schemes from Comonads, Calculating Functional Programs (for the "CT" behind this)
18:04:47 * heatsink giggles at the banana-related titles
18:08:06 <dataangel> sweet, I expect when I get done with these I'll be a fold rocket scientist
18:08:52 <ddarius> Follow the bibliography and the keywords that come up.  There's a lot more than that and plenty of related things.  Most of those aren't even directly about fusion.
18:22:32 * SamB wonders why he has /lib/libselinux.so.1
18:34:18 <dons> here's a bit about the new stream fusion lib, and how you'd use it, http://article.gmane.org/gmane.comp.lang.haskell.cafe/31816
18:34:19 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:35:22 <sorear> yay!
18:36:10 <dons> hope to get bytestring out on top of this soonish.
18:37:52 <sjanssen> dons: why hide all the Data.Stream functions from haddock?
18:38:05 <dons> bang patterns all over :(
18:38:07 <sjanssen> dons: shouldn't developers be able to use this API?
18:38:09 <dons> so haddock can't mark any of it up
18:38:19 <dons> developers definitely should, yes.
18:38:24 <ddarius> dons: I want that to reduce to if n < 0 then 0 else n
18:38:30 <sjanssen> dons: oh, okay
18:38:43 <dons> ddarius: add a rule for sum . replicate
18:38:58 <dons> and some strictness analysis to spot that it isn't infinite
18:39:03 <sjanssen> dons: it almost gives the impression that it's an internal API, maybe you should mention that it's hidden due to haddock limitations?
18:39:11 <dons> ah mm.
18:39:17 <ddarius> dons: How would that be infinite?
18:39:18 <dons> i'd like to find a haddock that knows about bang patterns
18:39:22 <dons> well, bottom.
18:39:43 <dons> a lot of nice rules like this could be written if we knew things were strict :)
18:40:32 <dons> at least there's no lists at all in the final code
18:40:37 <dons> i should have highlighted that
18:40:45 <sjanssen> dons: where's the darcs repo?
18:40:59 <dons> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/streams/list
18:41:01 <lambdabot> Title: Index of /~dons/code/streams/list
18:41:03 <dons> see the web page http://www.cse.unsw.edu.au/~dons/streams.html
18:41:04 <lambdabot> Title: Data.List.Stream
18:41:34 <dons> i don't want to #ifndef __HADDOCK__ all the code
18:41:51 <sjanssen> yeah
18:42:06 <sjanssen> is haddock-ghc ready yet?
18:42:27 <dons> not sure. we should ask waern et al (is that who's working on it?)
18:42:57 <ihope> Maybe there's a token that's defined by editors so you can put an #ifdef around the #ifndef! :-P
18:43:03 <dons> also, it probably wants 6.8.1 with the env
18:43:08 <dons> env' spec constr patch
18:43:15 <dons> to be worthwhile.
18:43:48 <dons> the  big use is bytestring though, since that's a lot lot more expensive to do intermediate structures.
18:54:39 <cyberix> Why is the let needed in Guess.hs example at http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics ?
18:55:48 <mrd> hm, could something like LibTomMath be used in place of GMP for GHC?  It's public domain.
18:56:19 <ddarius> If the effort is put out, sure.
18:57:02 <mrd> cyberix: where does it say it is necessary?
18:59:47 <allbery_b> it's not needed; it just saves having to type (and. hopefully, execute) "read guess" multiple times
19:16:04 <dataangel> @src foldl
19:16:04 <lambdabot> foldl f z xs = lgo z xs
19:16:04 <lambdabot>     where lgo z []     =  z
19:16:04 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
19:16:54 <dataangel> why not just foldl f v [] = v and foldl f v (x:xs) = f (myfoldl f v xs) x ?
19:17:56 <ddarius> Worker/wrapper transform if I'm not mistaken.
19:18:26 <shachaf> You mean foldl f v (x:xs) = foldl f (f v x) xs, right?
19:20:06 <dons> you get the best code from ghc with the manual worker/wrapper split here
19:20:48 <hircus> basically lambda-unlifting should always be done whenever possible, for efficiency?
19:22:25 <dons> hmm, i'm not sure i'd say that.
19:22:33 <dons> but in this case, a lovely loop is going to compile nicely
19:23:27 <hircus> dons: and the compiler is more likely to recognise a loop if all the arguments in a tail call change?
19:24:01 <dons> let's see what ghc produces for the shorter versoin
19:47:02 <user317> how do i convert from a float to a double?
19:49:29 <dons> > realToFrac (pi :: Float) :: Double
19:49:32 <lambdabot>  3.1415927410125732
19:50:50 <ddarius> :t realToFrac
19:50:52 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
19:50:54 <ddarius> There it is.
19:58:46 <user317> there is a ghc.float.float2Double
20:01:14 <ddarius> user317: dons already gave you the proper function
20:01:32 <user317> whats wrong with that one?
20:03:09 <dons> realToFrac is the one :)
20:03:17 <dons> ?let x = pi :: Float
20:03:20 <lambdabot> Defined.
20:03:23 <dons> > realToFrac x :: Double
20:03:26 <lambdabot>  3.1415927410125732
20:03:39 <shachaf> > pi :: Double
20:03:40 <lambdabot>  3.141592653589793
20:03:49 <dons> :)
20:03:50 <shachaf> > pi :: Float
20:03:51 <lambdabot>  3.1415927
20:04:11 <davidL> ?ty pi
20:04:12 <lambdabot> forall a. (Floating a) => a
20:04:15 <dons> pi == 3 is good enough for me :)
20:04:24 <mtp_> pfff
20:04:31 <dons> > realToFrac (22/7 :: Rational)
20:04:32 <lambdabot>  3.142857142857143
20:05:14 <idnar> pi :: Integer
20:05:17 <idnar> > pi :: Integer
20:05:18 <lambdabot>   add an instance declaration for (Floating Integer)
20:05:18 <lambdabot>     In the expression: p...
20:05:22 <idnar> ah
20:05:22 <davidL> > pi - realToFrac (22/7 :: Rational)
20:05:23 <lambdabot>  -1.2644892673496777e-3
20:05:36 <idnar> hmm, what's that other one
20:06:08 <dfranke_> Meh... my head hasn't exploded recently.  Somebody point me in the direction of some new bits of deep magic.  I'm running out of material just from working my way through the standard libraries.
20:06:51 <dons> mm
20:06:53 <idnar> > pi - realToFrac (355 / 113 :: Rational)
20:06:53 <lambdabot>  -2.667641894049666e-7
20:06:56 <davidL> > sin pi
20:06:57 <lambdabot>  1.2246063538223773e-16
20:07:30 <dons> sigfpe's new one, dfranke_ , http://sigfpe.blogspot.com/2007/11/whats-all-this-e8-stuff-about-then-part.html
20:07:32 <lambdabot> Title: A Neighborhood of Infinity: What's all this E8 stuff about then? Part 1., http://tinyurl.com/35vpbe
20:08:01 <allbery_b> that wasn't very head-explodey.  I mean, I understood it...
20:08:10 <allbery_b> <-- bear of very little brain
20:09:51 <dfranke_> mmm, getting there.  Any mathier introduction to Lie algebras?
20:10:04 <dfranke_> I already grok basic group theory.
20:11:41 <allbery_b> @go Lie algebras
20:11:42 <lambdabot> http://en.wikipedia.org/wiki/Lie_algebra
20:11:42 <lambdabot> Title: Lie algebra - Wikipedia, the free encyclopedia
20:12:52 <ddarius> user317: One is a standard function, the other is GHC specific.
20:14:01 <sorear> dfranke_: yes, lie algebras are very good.  I have no idea what they are.
20:15:46 <dfranke_> sorear: well, the Wikipedia page seems to comprehensible, at least if you already know what a vector space is.
20:16:17 <sorear> I should say, I have no idea what the point is.
20:16:56 <dfranke_> apparently, the point is that you can do something resembling calculus with them.
20:17:55 <allbery_b> that's where dpiponi's article comes in.  I presume he'll be expanding into that in the next part (at which point my brain *will* probably explode)
20:18:25 <dfranke_> The page doesn't seem very enlightening though.  It doesn't explain why the axioms of a Lie algebra are necessary or sufficient for doing calculus.
20:19:47 <dfranke_> meh, if I'm going to dig into this sort of thing I should probably go finish reading Categories for the Working Mathematician instead.
20:20:41 <allbery_b> it's that they enable calculus on Lie groups; might be better to search from there, since the wikipedia page seems more interested in the general case where a Lie algebra doesn't necessarily describe any Lie groups
20:20:51 <ddarius> Categories for the Working Mathematician is enjoyable.  It's lighter than I expected.
20:21:09 <dfranke_> ddarius: this must be some strange definition of "light" of which I wasn't previously aware.
20:21:19 <ddarius> Unfortunately, it didn't have much that I hadn't seen elsewhere.  Certainly nothing revealing.
20:21:40 <ddarius> dfranke_: Compare to, say, Toposes, Triples and Theories.
20:22:22 <ddarius> That said, Categories for the Working Mathematician does have together a lot of stuff that I had to put together from several sources.
20:23:01 <ddarius> Basic Concepts of Enriched Category Theory is a great boon.
20:23:46 <ddarius> @where stats
20:23:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
20:32:57 <hpaste>  gwern pasted "xmonad crash, ltrace" at http://hpaste.org/3951
20:34:00 <hpaste>  gwern annotated "xmonad crash, ltrace" with "the rest" at http://hpaste.org/3951#a1
20:39:30 <ramza3> general comment: I wonder why no-one or company set out to make a better emacs.  emacs is awesome
20:40:02 <allbery_b> several have.
20:41:02 <allbery_b> xemacs (previously lemacs) was one such; there have also been several emacs-with-other-extension-languages attempts (e.g. epsilon)
20:41:53 <allbery_b> also BRIEF was in that latter chance, IIRC
20:42:15 <allbery_b> (was a very popular programmer's editor in the PC world for a long time)
20:43:58 <ramza3> those seemed like emacs clones and I am fine with emacs emacs, but there are times I work with other IDEs and wish they had the plug-in and command shortcuts like emacs.  The modern IDEs seem to have gone the route of visual studio
20:44:51 <allbery_b> that's the way the PC world went
20:45:20 <allbery_b> there's a reason I used past tense on BRIEF and said "attempts" for e.g. epsilon
20:45:48 <allbery_b> that kind of editor just doesn't "work" for the vast majority of folks, it seems.
20:46:24 <allbery_b> power users appreciate emacs-like editors; but there aren't that many power users out there buying stuff
20:59:08 <slava> hi ramza3
20:59:27 <slava> ramza3: i use jedit. its better than emacs :)
21:00:05 <ramza3> slava: hehe, never heard of it.
21:00:29 <ramza3> slava: just kidding
21:06:07 <repnop> should reword better to prefer :)
21:15:56 <iesahin> hi all
21:16:13 <iesahin> i'm trying to take sqrt of an Int
21:16:38 <iesahin> and ghci complains that no instance for (Floating Int)
21:16:47 <dons> right, you can see in the type of sqrt:
21:16:50 <dons> :t sqrt
21:16:59 <lambdabot> forall a. (Floating a) => a -> a
21:17:06 <dons> so it only works on types in the Floating class
21:17:09 <dons> ?instances Floating
21:17:14 <dons> which doesn't include Int.
21:17:16 <iesahin> and i couldn't find a way to "convert" Integral to Floating?
21:17:16 <lambdabot> Double, Float
21:17:21 <dons> so what we have to do is convert them :)
21:17:28 <iesahin> :)
21:17:29 <dons> and that function is fromIntegral
21:17:34 <dons> ?hoogle a -> b
21:17:35 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:17:35 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
21:17:35 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
21:17:42 <dons> ah, bit too vague for hoogle
21:17:48 <dons> > fromIntegral 1 :: Double
21:17:49 <lambdabot>  1.0
21:17:51 <allbery_b> :t fromIntegral
21:17:51 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:18:06 <dons> ?hoogle Num b => a -> b
21:18:06 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:18:06 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
21:18:06 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
21:18:15 <dons> nope. silly hold hoogle
21:18:22 <iesahin> I checked hoogle, but I couldn't figure out that in the list
21:18:24 <allbery_b> doens't hoogle mishandle class constraints still?
21:18:24 <dons> iesahin: so did that answer your question?
21:18:34 <dons> > sqrt (fromIntegral 4)
21:18:34 <lambdabot>  2.0
21:18:38 <iesahin> thank you, yes :)
21:18:58 <dons> good. i think newer hoogle can find fromIntegral, but it is definitely hard to find
21:19:01 <ddarius> > sqrt 4
21:19:02 <lambdabot>  2.0
21:19:03 <dons> important to remember though
21:19:15 <dons> as is realToFrac, which works for floating-ish types
21:19:26 <ddarius> Why not fromReal?
21:19:52 <Saizan_> ?type fromReal
21:19:52 <iesahin> because Int is not Real ?
21:19:53 <lambdabot> Not in scope: `fromReal'
21:19:56 <dons> the comittee didn't talk to each other about it?
21:20:11 <allbery_b> @instances Real
21:20:11 <lambdabot> Double, Float, Int, Integer
21:20:12 <iesahin> ok, I misunderstood
21:20:27 <dons> :t realToFrac
21:20:27 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
21:20:38 <allbery_b> ("Real" in Haskell doesn't mean like the real numbers of math, but rather concrete types)
21:20:50 <iesahin> so why sqrt expects Floating instead of Real?
21:21:16 <allbery_b> because Floating means (in essence) types understood by an FPU
21:21:22 <allbery_b> which means Float or Double
21:21:23 <ddarius> iesahin: Because the sqrt of an integer isn't an integer
21:21:50 <dons> so there's no sqrt on Rational though
21:21:57 <Saizan_> maybe dumb question: can you concurrently write and read on the same Handle? it's attached to a Socket in this case
21:22:09 <dons> Saizan_: yeah, you have to open it ReadWriteMode
21:22:17 <allbery_b> you could in theory do sqrt :: Real a, Floating b => a -> b but that's not a fundamental operation
21:22:27 <iesahin> ok, thanks a lot
21:23:04 <dons> sure, iesahin. feel free to ask questions any time you like
21:23:52 <allbery_b> btw, the numeric hierarchy is a fertile source of arguments over how things "should" work
21:24:13 <dfranke> allbery_b: exhibit A, today's mailing list thread :-)
21:24:21 <wli> Everyone agrees it's broken.
21:24:47 <dons> people should do alternative class hierarchies, and put them in libraries!
21:24:55 <dfranke> I'm a fan of NumericPrelude.
21:24:57 <dons> why I can't get numericPrelude from hackage, I don't know
21:25:06 <dons> and until its there, no one will use it.
21:25:06 <dfranke> dons: jinx.
21:25:15 <wli> dons: It needs compiler intrinsics changes.
21:25:26 <dons> it can surely be usable without that
21:25:28 <allbery_b> @wiki Mathematical_prelude_discussion
21:25:29 <lambdabot> http://www.haskell.org/haskellwiki/Mathematical_prelude_discussion
21:25:31 <Olathe> @where numbertypes
21:25:31 <lambdabot> Do not like !
21:25:35 <wli> dons: No, it can't.
21:25:46 <wli> dons: Numeric literals have wrong types etc. otherwise.
21:26:01 <dons> ah right.
21:26:08 <dons> so that makes it a little tricky
21:26:24 <xpik2> does anyone know how to pipe from std err? ie. make | wc
21:26:27 <dons> its sort of like ByteString then. new ops, new types, have to be introduced specially
21:26:28 <dfranke> wli: it breaks defaulting sometimes, but it stell pretty much works.
21:26:37 <dfranke> still*
21:26:41 <dons> xpik2: you want to read stderr?
21:26:49 <dons> write to it?
21:26:54 <xpik2> dons: read
21:27:02 <dons> oh, in the shell?
21:27:04 <allbery_b> easiest is make 2>&1 | wc
21:27:09 <dons>  foo 2>&1 | bar
21:27:23 <allbery_b> (assuming a bourne shell-ish; make |& wc in csh/tcsh
21:27:24 <dons> they need arrows notation
21:27:25 <xpik2> dons: I'll try that
21:27:37 <allbery_b> sh can do stderr only but it's painful
21:27:44 <allbery_b> csh can do it but it's even more painful
21:27:47 <wli> dfranke: It breaks down somewhere. I've lost too much intelligence from whatever is going on to know/remember/understand how.
21:27:57 <dfranke> dons: hey, that would be a really cool Haskell library to write.
21:28:01 <xpik2> dons: allbery_b: nice
21:28:16 <dons> dfranke: arrow notation for shell pipes?
21:28:20 <dfranke> dons: yeah
21:28:25 <dons> i agree :)
21:29:14 <wli> dfranke: I think partly when trying to handle unsigned literals.
21:29:20 <dmwit> We need a shell with more general redirection.
21:29:26 <dfranke> dons: you could get into some mischief with ArrowLoop...
21:29:53 <dons> seems like it would be fun
21:30:00 <dons> what with those lazy buffers all over
21:30:02 <dmwit> Like, redirecting an environment variable to stdin, or redirecting to an argument position.
21:30:08 <dons> == lazy bytestrings ftw
21:30:24 <dmwit> Think I could make a research project out of it? =P
21:30:35 <boyscared> @type (.)
21:30:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:30:54 <dfranke> ah hell, I guess I have time for a quick diversion from my startup.
21:30:57 <dons> dmwit: there'd be a small paper there, perhaps
21:31:01 <dfranke> and it might be useful anyway.
21:31:15 <boyscared> @type (.) (.)
21:31:15 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
21:31:26 <dons> it would be. i wrote a similar thing for list functions, using | as >>= here, http://www.cse.unsw.edu.au/~dons/h4sh.html
21:31:27 <lambdabot> Title: h4sh
21:31:36 <dons> there's definitely room for more haskell / shell cross-over
21:32:10 <boyscared> @type (:)
21:32:11 <lambdabot> forall a. a -> [a] -> [a]
21:32:54 <boyscared> @type (:) (:)
21:32:54 <lambdabot> forall a. [a -> [a] -> [a]] -> [a -> [a] -> [a]]
21:32:59 <dfranke> maybe even a Haskell-based shell.
21:33:30 <dfranke> Hash?  Haskshell?  Hell?
21:33:39 <wli> There's already one of those.
21:33:45 <allbery_b> there's already a hashell I think
21:33:49 <boyscared> hashell
21:33:55 <ehaas> can i ask a quick noob question
21:34:02 <allbery_b> ask away
21:34:07 <ehaas> is this the best way to do what i'm trying to do:
21:34:09 <boyscared> http://www.haskell.org/hashell/
21:34:10 <lambdabot> Title: Hashell :: Home Page
21:34:11 <ehaas> reductionMap n f l = (f $ take n l) : (reductionMap n f $ drop n l)
21:34:37 <ehaas> i want to take a list, break it into sublists of length n, apply a fold to each sublist, and form a new list
21:34:38 <dfranke> looks abandoned to me.
21:34:58 <int-e> > map (take 5) (iterate (drop 5) [1..])
21:34:59 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
21:35:16 <int-e> add a (takeWhile (not . null)) in the middle for good measure.
21:35:45 <int-e> > map (take 5) . takeWhile (not . null)) . iterate (drop 5) $ [1..13]
21:35:46 <lambdabot> Unbalanced parentheses
21:35:51 <int-e> > map (take 5) . takeWhile (not . null) . iterate (drop 5) $ [1..13]
21:35:52 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13]]
21:36:04 <ehaas> nice....thanks
21:36:16 <ehaas> i know the list will be length multiple  of n, would i still need the not . null?
21:36:34 <ddarius> > map (take 5) . iterate (drop 5) $ [1..13]
21:36:35 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13],[],[],[],[],[],[],[],[],[],[],[],[],[],...
21:36:53 <int-e> the  takeWhile  filters out those empty lists.
21:37:07 <ehaas> i see
21:37:13 <ddarius> If we had chunk it would just be map f . chunk n
21:37:33 <ehaas> yes
21:37:35 <ehaas> heheh
21:37:50 <ehaas> chunk is exactly the function i was looking for
21:38:14 <ddarius> It is a very commonly requested function.  You can find an implementation on the wiki somewhere or another.
21:38:24 <ddarius> (Not that it is hard to (re)write.)
21:44:35 <ddarius> @let chunk n xs = case splitAt n xs of (c,[]) -> [c]; (c,xs') -> c:chunk n xs'
21:44:37 <lambdabot> Defined.
21:44:45 <ddarius> > chunk [1..13]
21:44:46 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
21:44:48 <ddarius> > chunk 5 [1..13]
21:44:48 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13]]
21:45:01 <ddarius> > chunk 5 [1..]
21:45:13 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
21:45:42 <sjanssen> @type \n -> unfoldr (liftM2 (>>) (guard . not . null) (splitAt n))
21:45:43 <lambdabot>     Couldn't match expected type `Maybe'
21:45:43 <lambdabot>            against inferred type `(,) [a]'
21:45:43 <lambdabot>       Expected type: [a] -> Maybe (a1, [a])
21:46:21 <ddarius> What should chunk n [] return?
21:46:36 <ddarius> What should chunk 0 xs return?
21:46:48 <Saizan_> @type \n -> unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt n))
21:46:48 <lambdabot> forall a. Int -> [a] -> [[a]]
21:47:50 <sjanssen> bah, return
21:48:10 <goltrpoat> @let chunk2 n = takeWhile (not . null) . unfoldr (Just . splitAt n)
21:48:11 <lambdabot> Defined.
21:48:19 <goltrpoat> > chunk2 5 [1..13]
21:48:20 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13]]
21:48:35 <ddarius> > chunk 0 [1..13]
21:48:35 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
21:48:42 <ddarius> > chunk2 0 [1..13]
21:48:42 <lambdabot>  []
21:48:51 <ddarius> > chunk 5 []
21:48:52 <lambdabot>  [[]]
21:48:56 <ddarius> > chunk2 5 []
21:48:56 <lambdabot>  []
21:48:59 <goltrpoat> ah right.
21:49:07 <ddarius> "ah right"?
21:49:21 <goltrpoat> not . null is too general.
21:50:19 <goltrpoat> or.. i guess depends on what you want to do with the function to begin with :)
21:52:24 <ehaas> nothing too outrageous...just some math
21:52:29 <AE35> hey, i am just learning haskell and am trying to declare a type and having problems.  getting confused by data/type .   I need to declare DB as a 4 tuple of [(String, String, Interger, String)]
21:55:27 <dons> AE35: a list of 4-tuples?
21:56:15 <dons> type T = [(String,String,Integer,String)] -- creates a type alias T, exactly the same as a list of 4-tuples
21:56:50 <dons> data is for declaring new structures, or augmenting them, not reusing an existing one
22:03:40 <dfranke> okay, this is going to be cool...
22:03:44 <wli> db :: [(String, String, Integer, String)]
22:03:47 <wli> db = []
22:03:55 <dfranke> I can use the type system to encode how many input and output pipes a process is expecting...
22:03:58 <dfranke> fun with type operators!
22:04:36 <dons> statically checked shell pipes, eh?
22:04:44 <dfranke> yup!
22:04:49 <dons> the well typed shell is surely not far away
22:05:05 <dons> and tee is &&& ?
22:06:02 <dfranke> yup
22:06:07 <dons> cat x | (grep "yes" &&& cat f)
22:06:23 <dons> lovely
22:07:36 <shachaf> dons: cat x | cat f?
22:07:48 <ehaas> what does that do, for someone not familiar with arrows
22:08:19 <wli> Is | usable as an operator?
22:08:19 <shachaf> f &&& g = \x -> (f x, g x)
22:08:23 <shachaf> wli: No.
22:08:29 <shachaf> ehaas: For the (->) arrow.
22:08:37 <wli> I wonder what dons had in mind.
22:08:48 <wli> I used to call (&&&) zipF.
22:08:51 <shachaf> wli: Pseudo-syntax. :-)
22:09:22 <mgsloan> > let a +- b = (a+b, a-b) in 5 +- 3
22:09:22 <lambdabot>  (8,2)
22:09:59 <dons> shachaf: sorry, cat > f
22:10:16 <shachaf> dons: Oh.
22:10:25 <ehaas> got it
22:12:22 <wli> > let a +- b = uncurry min &&& uncurry max $ (a + b, a - b) in 5 +- 3
22:12:33 <lambdabot>  (2,8)
22:12:36 <mgsloan>  heh
22:14:02 <wli> I'd prefer
22:14:54 <wli> > let x +- y = let x' = x + y ; y' = x - y in (min x' y', max x' y')
22:14:54 <lambdabot>  Parse error at end of input
22:15:04 <wli> > let x +- y = let x' = x + y ; y' = x - y in (min x' y', max x' y') in 5 +- 3
22:15:04 <lambdabot>  (2,8)
22:15:14 <mgsloan>  > let (+-) = \x -> (uncurry min &&& uncurry max) . ((x+) &&& (x-)) in 5 +- 3
22:15:27 <mgsloan> > let (+-) = \x -> (uncurry min &&& uncurry max) . ((x+) &&& (x-)) in 5 +- 3
22:15:28 <lambdabot>  (2,8)
22:15:38 <shachaf> I'd prefer to keep the order with (+-).
22:15:49 <shachaf> As opposed to (-+).
22:16:31 <hircus> wli: is &&& something the lambdabot has predefined but Haskell itself does not?
22:16:48 <mgsloan> it's in Control.Arrow
22:16:51 <shachaf> hircus: Look in Control.Arrow.
22:16:54 <int-e> > let (+-) = ((uncurry min &&& uncurry max) .) . liftM2 (&&&) (+) (-) in 5 +- 3 -- pointlessly pointfree
22:16:55 <lambdabot>  (2,8)
22:17:01 <mgsloan> lol
22:17:10 <shachaf> hircus: It's more general than functions -- it works on any Arrow.
22:17:13 <hircus> mgsloan: aha yes
22:17:14 <shachaf> @ty liftM2 (,)
22:17:19 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
22:17:44 <hircus> shachaf: yes. I've used them briefly once, need to look them up again. thanks!
22:18:02 <dfranke> I think I'll name my PipeArrow b c -> b -> IO c function "plumb".
22:18:07 <ddarius> @index (&&&)
22:18:07 <lambdabot> Control.Arrow
22:19:19 <hircus> @index flip
22:19:19 <lambdabot> Prelude
22:19:28 <int-e> > let (+-) = ((minimum &&& maximum) .) . sequence . sequence [(+),(-)] in 5 +- 3 -- do you want lists with that?
22:19:29 <lambdabot>  (2,8)
22:22:03 <hircus> int-e: obfuscated Haskell contest entrant :)
22:24:03 <hpaste>  int-e pasted "meteor puzzle - aiming for compact code (it's slower than the shootout entries)" at http://hpaste.org/3952
22:24:11 <dons> int-e: ah!
22:24:18 <dons> someone is finally having a look!
22:24:27 <dons> ?pl \(y,x) -> (y-dy,x-dx)
22:24:27 <lambdabot> subtract dy *** subtract dx
22:24:49 <int-e> hircus: take this and rename the identifiers, should be fairly obfuscated. :)
22:24:53 <dons> very short. nice work int-e
22:25:09 <dons> readIO is a good replacement return . read
22:27:04 <wli> I won't win any obfuscated or short Haskell contests with identifiers like transferTallyWeight or ballotsToTransfer.
22:29:12 <repnop> wli: the good news is in 6 months from now you'll be able to understand what you wrote :)
22:30:00 <wli> Actually I'm looking at something I wrote in August that I don't understand despite the long variable names.
22:31:35 <repnop> haha :)
22:32:23 <wli> I seriously wonder if I had a stroke or something without realizing it. This is way over the top.
22:34:05 <hircus> int-e: nice
22:34:16 <int-e> dons, heh, meteor-contest is missing from the submit form :/
22:35:08 <shachaf> dons: @pl knows about (***) but not (&&&)?
22:35:22 <shachaf> > scanl1 (+) [1,2,4,8,16]
22:35:24 <lambdabot>  [1,3,7,15,31]
22:36:19 <repnop> wli: i feel the same way in one of my classes, i studied many things but right now i cannot recall any of it...and thats just a span of 2 months :)
22:36:23 <wli> iterate (scanl1 (+)) [1..]
22:37:08 <dons> int-e: surely not!
22:37:16 <dons> shachaf: its a bit pre-arrows
22:37:24 <dons> i think @pl introduced the tupling idioms from arrows, actually
22:38:03 <shachaf> dons: @pl uses liftM2 (,) instead, right?
22:38:13 <shachaf> @pl \x -> (f x,g x)
22:38:13 <lambdabot> liftM2 (,) f g
22:38:35 <dons> int-e: hmm, pick a different category, such as "None"
22:38:44 <dons> shachaf: yeah, it could do with some new rules
22:43:20 <dfranke> Hmm, what's the appropriate classification for this?  Control.Arrow.Pipe, or System.Posix.PipeArrow?
22:44:34 <Olathe> What do I have to do in ghci to get 1%1 to work ?
22:44:43 <int-e> :m +Data.Ratio
22:44:58 <Olathe> Thanks.
22:45:14 <int-e> dons: yeah that's what I've done.
22:47:59 <hircus> int-e: what are ratios exactly? they seem to behave like rational numbers but not quite
22:48:16 <hircus> can't do (1%5) * (10%3), but I can do (1%5) * 10
22:48:43 <int-e> >  (1%5) * (10%3)
22:48:45 <lambdabot>  2%3
22:48:51 <int-e> @type 10
22:48:51 <lambdabot> forall t. (Num t) => t
22:49:09 <int-e> hircus: the first works; the second works because numeric literals are polymorphic.
22:51:31 <hircus> int-e: weird... oh. wait. silly me
22:51:54 <hircus> order of precedence.. I didn't parenthesized (1%5) and (10%3) when I typed it
22:53:57 <vaehid32> can i ask a GHC question in this channel?
22:54:06 <dmwit> yes
22:54:25 <dmwit> Also, if it is very GHC-specific (as in about the implementation of the compiler), see #ghc.
22:54:44 <vaehid32> when i add the line "import IO" to my file, i get the following error:
22:54:44 <vaehid32> ./NcrGreeting.hi: openBinaryFile: permission denied (Permission denied)
22:55:00 <repnop> i hate to sound stupid (but i am when it comes to haskell) are there that major of differences between ghc, hugs, or others?
22:55:04 <vaehid32> when i remove 'import IO' the error mesage goes away
22:55:48 <vaehid32> i've used hugs for a few weeks, this is my first experience with GHC
22:55:49 <hpaste>  steven_ashley pasted "class instances" at http://hpaste.org/3953
22:55:55 <int-e> repnop: hugs is an interpreter, ghc is a compiler. ghc supports many extensions, hugs supports fewer. both do Haskell 98 just fine.
22:56:08 <repnop> i've mostly used ghc
22:56:24 <vaehid32> not sure what a .hi file is
22:56:31 <vaehid32> intermediate representation maybe?
22:56:34 <mgsloan> do many people use hugs?
22:56:47 <int-e> vaehid32: ghc creates .hi files to store information about the interfaces of compiled modules.
22:56:48 <vaehid32> my class is required to use hugs
22:56:50 <vaehid32> i like it
22:57:01 <sjanssen> mgsloan: students, mostly
22:57:33 <mgsloan> ah
22:57:37 <dons> ghc is the serious implementation
22:57:37 <shachaf> sjanssen: Is there a reason for that, by the way?
22:57:39 <dons> hugs is more for teaching
22:57:46 <dons> but even that's a bit doubtful now
22:58:01 <sjanssen> shachaf: tradition, smaller footprint, I imagine
22:58:03 <steven_ashley> hi guys, I have a class definition and I am trying to code an instance that generalises across another class. my example http://hpaste.org/3953 has a fuzz function :: a -> [a] and I am trying to declare a default instance for everything of class bounded
22:58:23 <repnop> i can test stuff in ghci but everything i've learned so far just gives errors in hugs
22:58:25 <sjanssen> it's also written in pure C, so porting is no problem
22:58:36 <steven_ashley> I dont know if this is possible as if I declare two of these, and if some data type implements both classes, then which implementation does it use*
22:58:45 <repnop> something as simple as let f x = x even
22:58:49 <dons> repnop: hmm, you can't type top level declarations in hugs, nor load .hi files
22:58:50 <steven_ashley> any help would be appreciated :)
22:58:54 <repnop> ah
22:58:56 <dons> repnop: so you have to load them from .hs files
22:58:57 <repnop> io
22:59:01 <repnop> i'm going to stick with ghc :)
22:59:03 <sjanssen> steven_ashley: you can use a feature known as "overlapping instances", though this is somewhat discouraged
22:59:05 <dons> i would :)
22:59:27 <dons> vaehid32: try importing System.IO, or removing the .hi file
22:59:34 <sjanssen> steven_ashley: you'd write "instance Bounded a => Fuzz a where ..."
22:59:38 <repnop> i like the language, but i have so much to learn still
22:59:50 <steven_ashley> cheers :)
23:00:08 <vaehid32> dons: removing the .hi file worked thanks
23:00:47 <repnop> steven_ashley: you been using it for awhile?
23:01:26 <steven_ashley> haskell? yeah but usually not the more exotic features :)
23:01:40 <repnop> i like the idea of lazy evaluation of function arguments :)
23:01:47 <repnop> for infinite data structures
23:02:07 <dons> very useful
23:02:14 <dons> > take 10 [1..]
23:02:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:02:21 <repnop> i'm mostly interested in simulations so very useful
23:02:28 <dons> means you don't have to think about bounds very often
23:02:34 <dons> unlike with a strict for loop
23:04:06 <wli> Well, you can simulate it all with a lib, but you end up with writing to a lazy FP language's RTS's interface in C or asm that way.
23:04:09 <vaehid32> when you compile a module with GHC,  is it the function called 'main' that executes when the compiled program is invoked?
23:04:28 <sjanssen> vaehid32: yep, the function called main in the module called Main
23:04:37 <vaehid32> ok thank you
23:04:39 <repnop> well for simulations i mean with regards to finance
23:04:44 <repnop> so monte carlo and such
23:04:53 <repnop> inf data lists are useful for that :)
23:05:35 <hircus> repnop: Haskell in the financial sector? neat
23:05:50 <repnop> why not? performance seems decent enough
23:06:06 <vaehid32> are flushes required after every putStr in GHC?
23:06:20 <hircus> repnop: sure -- not doubting its performance, just surprised that it's already adopted
23:06:21 <vaehid32> the compiled version of my program seems to not move until i hit a newline
23:06:25 <hpaste>  (anonymous) annotated "class instances" with "(no title)" at http://hpaste.org/3953#a1
23:06:33 <dons> most of the commercial users of haskell are banks
23:06:37 <repnop> hircus: well i'm solo, don't run a hedge fund etc
23:06:38 <sjanssen> vaehid32: stdin/out are line buffered by default
23:06:40 <steven_ashley> opps :P
23:06:46 <vaehid32> hmm
23:06:46 <repnop> so much freedom in what language i use
23:06:50 <wli> I don't know enough for that.
23:07:08 <wli> I can't make heads or tails of Ito integrals, martingales, etc.
23:07:23 <sjanssen> vaehid32: you can use hSetBuffering to change that, or just hFlush when you need to
23:07:27 <repnop> i've always used C++ but i'd rather learn a higher level language so i could focus on what i wanted rather than the details of memory management etc
23:07:38 * ddarius has relatively recently been interested in the stochastic calculus.
23:07:41 <hircus> saw an ad not too long ago looking for OCaml (and other FP language) programmers for a finance consultancy, so I guess Haskell makes sense too
23:08:02 <vaehid32> is the call 'hFlush stdout' ?
23:08:14 <ddarius> http://www.haskell.org/haskellwiki/Haskell_in_industry
23:08:15 <lambdabot> Title: Haskell in industry - HaskellWiki
23:08:26 <repnop> in finance there are many niche languages laso
23:08:28 <repnop> er also
23:08:31 <repnop> like k :)
23:08:52 <hircus> k .. sounds familiar
23:08:59 <wli> ddarius: You'll probably be an expert in it before I understand the most basic lemmas.
23:09:04 <vaehid32> a variant of APL
23:09:05 <vaehid32> oh dear!
23:09:07 <hircus> as long as they don't use the X combinator
23:09:21 <repnop> its only niche is the financial sector really
23:09:31 <hircus> vaehid32: typeable with a normal keyboard, I hope? :)
23:09:35 <repnop> closed source, and they don't even give it to the public anymore
23:09:36 <vaehid32> ha
23:09:39 <repnop> yeah it uses ascii :)
23:09:46 <ramza3> does anyone know if with parsec, there is an end of line token?
23:09:49 <vaehid32> i like special-character languages, call me crazy
23:09:55 <vaehid32> orthogonal lexemes please
23:09:57 <hircus> repnop: interesting. it's not used in Chemistry?
23:10:06 <ddarius> ramza3: eof
23:10:09 <hircus> vaehid32: check out Fortress :)
23:10:15 <repnop> hircus: i don't know, most of the k community seemed to focus on quant finance
23:10:16 <ddarius> @index eof
23:10:16 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec
23:10:25 <ddarius> :t Text.ParserCombinators.Parsec.eof
23:10:27 <lambdabot> forall tok st. (Show tok) => Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
23:10:30 <steven_ashley> ramza3: newline
23:10:42 <vaehid32> fortran with matlab notation?
23:10:48 <vaehid32> isn't steele working on that/
23:10:52 <repnop> but i'd rather learn a language that is open :)
23:11:03 <hircus> vaehid32: yeah. Fortran running on a VM, with UTF-8 variable names
23:11:08 <vaehid32> hmm
23:11:13 <repnop> even if k is great, it has a tiny community of a few hundred people :p
23:11:20 <ramza3> @index newline
23:11:20 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
23:11:24 <hircus> they don't have a compiler yet.. they have an interpreter that can be only compiled with a Sun JDK
23:11:29 <Olathe> > let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in foldb (+) 0 [1..100]
23:11:30 <lambdabot>  5050
23:11:40 <hircus> (even Red Hat's IcedTea, which is OpenJDK + classpath fixes, does not work)
23:11:46 <ramza3> dons: is parsec covered in your book
23:11:55 <wli> Fortran running on a VM is kind of pointless. You don't take the restrictions to run slow like in a VM.
23:12:11 <steven_ashley> ramza: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html <- is a pretty good refererence
23:12:18 <hircus> the fun thing from Fortress is that you can declare units for your variables, and it will take care of conversion, e.g. metric -> Imperial
23:12:39 <ddarius> hircus: That's relatively easy to do.
23:12:39 <ehaas> nasa could have used that a few years ago
23:12:42 <repnop> hircus: that would have saved that one space program a few million dollars eh ;)
23:12:43 <vaehid32> ha
23:12:46 <hircus> wli: this is a Sun language, so I guess they like their JIT optimizations :)
23:12:50 <wli> The whole point of continuing to use Fortran is for autoparallelization and alias analysis games.
23:12:52 <repnop> ehaas: yeah :)
23:13:01 <Olathe> > let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in take 50 $ show $ foldr (+) 0 $ map (1%) [1..13107]
23:13:04 <hircus> for long-running scientific apps, I don't know, it might even pay off
23:13:06 <lambdabot> Terminated
23:13:08 <Olathe> > let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in take 50 $ show $ foldb (+) 0 $ map (1%) [1..13107]
23:13:08 <lambdabot>  "67974577937826463594722444600306617269227504080656"
23:13:13 <vaehid32> and an installed base of 40 years
23:13:13 <Olathe> foldb is much faster
23:13:17 <hircus> repnop: exactly :) probably how they got their grant
23:13:38 <Olathe> > let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in take 50 $ show $ foldl (+) 0 $ map (1%) [1..13107]
23:13:41 <lambdabot> Terminated
23:13:44 <repnop> is there a page to explain haskell typing system in depth?
23:14:04 <Olathe> @let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
23:14:04 <ehaas> repnop: you mean book? :)
23:14:06 <lambdabot> Defined.
23:14:06 <repnop> page/book
23:14:11 <repnop> book is good also :)
23:14:12 <wli> repnop: Mark Jones' "Typing Haskell in Haskell" paper.
23:14:24 <repnop> wli: thanks :)
23:14:30 <Olathe> > take 50 $ show $ foldb (+) 0 $ map (1%) [1..13107]
23:14:31 <lambdabot>  "67974577937826463594722444600306617269227504080656"
23:14:37 <vaehid32> wow that k language looks hairy
23:14:44 <repnop> yeah k isn't friendly
23:14:48 <repnop> but it is efficient
23:14:54 <repnop> kdb fits in the l1 cache ;)
23:15:00 <Olathe> Is there a built-in version of foldb ?
23:15:00 <vaehid32> really
23:15:02 <repnop> dunno about kdb+
23:15:08 <repnop> yeah
23:15:24 <repnop> kdb+ allows a lot of steam processing though
23:15:31 <wli> No idea. I can't figure out anything of what went on after Olathe's lambdabot bits.
23:15:40 <int-e> Olathe: none that I know of, but it would be nice to have.
23:15:54 <wli> What's steam processing?
23:16:28 <repnop> well for this it would be tick data that is always updated
23:16:51 <hircus> repnop: stream, you mean?
23:16:56 <repnop> stream yeah
23:17:00 <repnop> mistype
23:17:05 <repnop> didn't notice :)
23:17:51 <hircus> ah, that's where I've heard of K -- an NYU prof teaches a course in it
23:18:03 <repnop> hircus: really?
23:18:09 <repnop> for a quant finance course or what?
23:18:17 <hircus> repnop: yup: http://www.cs.nyu.edu/courses/fall02/G22.3033-007/kintro.html
23:18:18 <lambdabot> Title: Lectures of Dennis Shasha
23:18:45 <hircus> I think he has connections with Wall Street firms
23:18:49 <repnop> k is interesting but very niche
23:19:07 <repnop> but if you need to work on arrays of data it is nice
23:19:14 <hircus> writes fun math puzzle books too, if you're interested
23:19:21 <hircus> any freely-downloadable implementations?
23:19:47 <repnop>  i think you can use archive.org to download k 3
23:20:03 <repnop> i still have my dl from years ago
23:20:55 <hircus> eek. look at the language shootout section : http://vrabi.web.elte.hu/k/
23:21:32 <repnop>  but honestly if you aren't looking for a quant finance job k is useless
23:22:08 <repnop> even then might be better sticking with other langs
23:22:19 <hircus> repnop: interesting to look at, I guess, though not to do serious stuff in
23:22:33 <repnop> well if they were more willing to allow devs to leanr it
23:22:38 <repnop> and provide the latest version
23:22:44 <repnop> but they aren't friendly to devs
23:22:49 <repnop> unless you want to email them etc
23:23:21 <hircus> wonder how they get new developers if there is not even a trial version for download
23:23:27 <wli> I've run out of time.
23:23:31 <repnop> the money :p
23:23:38 <repnop> many quant jobs are like 150k/yr
23:23:41 <repnop> people will learn k for that
23:24:22 <stulli> @src toEnum
23:24:23 <lambdabot> Source not found. That's something I cannot allow to happen.
23:25:26 <hircus> ah ok. nothing to do with this other K, which is the chemistry one I found when searching: http://asterion.rockefeller.edu/marcelo/K/k.html
23:25:26 <lambdabot> Title: The K Language.
23:26:20 <repnop> but i think you'd be better off learning haskell in the long run :)
23:26:24 <repnop> seems more useful
23:27:35 <repnop> but if you really wanna try it, i'd look for kdbsetup.exe online then run it in a vm :)
23:27:56 <hircus> oh, I found a download -- it's conveniently linked from Wikipedia's page
23:28:01 <repnop> haha
23:28:06 <repnop> i have the md5 sum for the latest kdbsetup.exe
23:28:11 <hircus> linux and windows versions
23:28:21 <repnop> 3d886666415b361425103bc5c41695e1  kdbsetup.exe
23:28:31 <hircus> I'm on Linux though. so the md5sum won't match
23:28:35 <repnop> ah
23:28:40 <repnop> yeah i dont have the linux version
23:28:53 <repnop> only recently i felt it was worth switching to linux on the desktop :)
23:28:58 <repnop> i18n requirements form e
23:28:58 <hircus> hm
23:29:00 <repnop> for me
23:29:10 <hircus> downloaded the Windows version, MD5 is a794d28e09...
23:29:24 <hircus> this is from 2005. how old is your version?
23:29:33 <hircus> not that timestamps can be trusted
23:30:06 <repnop> my version is 3.2 2004-06-29
23:30:23 <repnop> l
23:30:27 <repnop> ls
23:30:36 <repnop> bah wine fails to run it
23:31:16 <repnop> honestly you should avoid studing it
23:31:18 <repnop> studying it
23:31:20 <hircus> K 3.2 2005-06-25 Copyright (C) 1993-2004 Kx Systems
23:31:31 <hircus> scary that they didn't fix the copyright year
23:31:39 <repnop> haha :)
23:31:43 <repnop> their market doesn't care
23:31:58 <hircus> won't study it .. but might be fun to reverse-engineer the compiler :P
23:32:02 <hircus> or steal some features anyway
23:32:24 <repnop> mostly fortune 500 companies
23:32:44 <repnop> there is a kuro5hin post about it that should explain the basics of the lang
23:33:05 <repnop> http://www.kuro5hin.org/?op=displaystory;sid=2002/11/14/22741/791
23:33:06 <lambdabot> Title: A Shallow Introduction to the K Programming Language || kuro5hin.org
23:33:18 <repnop> yep
23:33:22 <hircus> presumably it's almost never used without the matching database .. how good is the db?
23:33:24 <repnop> damnit responding to a bot
23:33:39 <repnop> well in finance you only get so many updates per sec...
23:33:48 <repnop> but kdb is high performance
23:33:58 * int-e is slightly unhappy about having Control.Category in the base libs. (at least with ghc head).
23:33:59 <hircus> compared to.. Oracle, DB2, Postgresql?
23:34:12 <repnop> beats them for the market
23:34:15 <hircus> now, a Haskell DB interface would be neat
23:34:22 <hircus> something as transparent as LINQ :)
23:34:26 <wli> I thought I had a gym bag.
23:34:37 <repnop> but you cannot get kbd+ if you aren't serious
23:34:41 <repnop> it as realtick support
23:34:44 <repnop> it has
23:34:46 <hircus> so .. what's the characteristic for a financial DB. loads of reads but infrequent updates?
23:34:51 <int-e> first, Control.Arrow doesn't even export (>>>) and (<<<) anymore (that's easily fixed of course), secondly, it breaks all external Arrow instances, which makes building, say, hxt a pain.
23:34:54 <hircus> realtick ..
23:35:02 <repnop> well nasdaq restricts the max updates per second
23:35:07 <repnop> they package it now...
23:35:23 <repnop> so you get bursted updates
23:35:26 <hircus> so it's a regulatory limitation..
23:35:36 <repnop> depends on the market
23:35:40 <repnop> i use the IB api mostly
23:35:50 <repnop> which doesn't inform the client of missed data
23:35:52 <hircus> and KDB handles bursts better?
23:36:01 <repnop> kdb handles it fine yeah
23:36:12 <repnop> i don't know about kdb+ i haven't used it
23:36:18 <repnop> i gave up on using k years ago
23:36:22 <dfranke> @index Fd
23:36:22 <lambdabot> System.Posix.Types, System.Posix, System.Posix.Types, System.Posix
23:36:34 <repnop> doesn't seem worthwhile
23:36:39 <RyanT5000> what's the deal with hoogle?
23:36:46 <RyanT5000> all the links it produces are dead
23:36:55 <RyanT5000> or rather, some
23:37:05 <RyanT5000> specifically, those to MTL docs
23:37:21 <RyanT5000> "The requested URL /ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html was not found on this server."
23:37:25 * wli is more concerned with the Malliavin calculus and stochastic diffeq's than any of that.
23:38:25 <allbery_b> hoogle is missing a bunch of useful updates
23:38:37 * wli seems unlikely to learn anything though.
23:38:39 <allbery_b> notably the one that catches that all the libraries are now versone
23:38:40 <allbery_b> d
23:38:57 <RyanT5000> hm
23:39:01 <RyanT5000> lame
23:39:35 <allbery_b> (6.8.1 has, more or less, broken the haskell world.  *sigh*)
23:41:29 <wli> It figures.
23:44:19 <wli> Now I try to figure out how to burn ISO disk images to CD's in Lose32.
23:46:05 <wli> Well, XP really.
23:55:01 <ddarius> int-e: What's this Control.Category nonsense?
23:55:18 <int-e> I'm writing a mail to libraries mailing list.
23:55:55 * ddarius should subscribe to that list.
23:58:37 * hgolden is away: sleep
