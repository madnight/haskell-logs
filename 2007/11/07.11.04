00:01:32 <dmwit> Why does the FFI require C header files to be named ".h"?
00:01:36 <dmwit> Just as a sanity check?
00:01:53 <dmwit> (I'm sure it has never been and never will be a problem, it just seemed a bit odd.)
00:05:12 <goalieca> > take 1 $ take (10^6) [1..]
00:05:19 <goalieca> not very lazy..
00:06:05 <goalieca> hmm.. wtf is lambdabot anyways.
00:06:10 <dmwit> goalieca: Seems lazy on my machine.
00:07:50 <dfranke> mine too.   take 1 $ take (2^62) [1..] returns a result quickly for me.
00:09:45 <goalieca> yeah nm. another problem was causing it
00:16:27 <pmdboi> hi, are there any mirrors for the ghc 6.8.1 source?
00:16:32 <pmdboi> haskell.org isn't responding for me
00:17:35 <Cale> Heh, 6.8.1 seems to be pretty popular.
00:17:49 <pmdboi> apparently :)
00:18:08 <Cale> I have the x86 binary.
00:18:12 <Cale> (for linux)
00:18:18 <dfranke> Cale: would you send it my way please?
00:18:26 <dfranke> Cale: I have the source but I can't build the docs.
00:19:02 <Cale> http://cale.yi.org/autoshare/ghc-6.8.1-i386-unknown-linux.tar.bz2
00:19:25 <dfranke> danke
00:22:35 <salierix> haskell.org is still down?
00:22:46 <dfranke> yup.
00:23:11 <dfranke> salierix: do you need to download 6.8.1?
00:23:14 <salierix> Is ghc 6.8.1 mirrored anywhere?
00:23:21 <salierix> dfranke, yeah.
00:23:22 <dons> its not down, just slow
00:23:33 <dons> due to hmm, people downloading stuff and reading announcements
00:23:35 <dfranke> http://dfranke.us/ghc-6.8.1-src.tar.bz2
00:23:43 <pmdboi> yay
00:23:45 <pmdboi> thanks dfranke :)
00:23:50 <dfranke> http://dfranke.us/ghc-6.8.1-src-extralibs.tar.bz2
00:24:01 <salierix> Who knew haskell was this popular...
00:24:04 <dfranke> dons: connection-timing-out slow.
00:24:10 <dfranke> aka down.
00:24:19 <Cale> Maybe they'll do the next release as a torrent.
00:24:31 <pmdboi> salierix: it's been reddited :)
00:24:33 <dons> yep
00:24:50 <dons> its more popular than it used to be
00:25:21 <Cale> I wonder how many more people visit reddit than vote on articles
00:25:50 <salierix> I still can't get a handle on monads except for the IO monad, which is pretty simple.
00:26:12 <Cale> Okay, so let's look at some others :)
00:26:37 <salierix> State on the other hand.
00:26:39 <Cale> I think a really good example is the list monad
00:26:53 <Cale> return x = [x]
00:27:01 <Cale> xs >>= f = concat (map f xs)
00:27:21 <Cale> So we have things like:
00:27:34 <Cale> > [1,2,3] >>= \x -> [x,x*10]
00:27:41 <dons> http://www.tiobe.com/tpci.htm
00:27:49 <dons> :D haskell doubled its percent last month
00:27:51 <Cale> lambdabot...
00:27:58 <dons> now ahead of bash
00:28:15 <dons> ocaml's dropped out of the top 50.
00:28:18 <dfranke> Cale: lambdabot seems to be passed out drunk today.\
00:28:29 <dons> so haskell's gone from 49 to 33 in the last 12 months, according to tiobe
00:28:35 <Cale> > [1,2,3] >>= \x -> [x,x*10]
00:28:55 <salierix> Isn't it difficult to remember what bind does on all the monads?
00:28:58 <Cale> heh, don't tell me my own bot is passed out as well...
00:29:24 <Cale> salierix: well, it always does something reasonable
00:29:35 <Cale> anyway, that would give [1,10,2,20,3,30]
00:30:06 <Cale> In the list monad, computations are lists, and running a list picks an element from it in all possible ways
00:30:33 <Cale> So we pick something from 1,2,3, call that x, and then pick either x or x*10
00:30:36 <dons> functional languages up 1% last month
00:30:47 <dfranke> Wow, VB is the third most popular language?
00:30:50 <dfranke> That saddens me.
00:30:52 <Cale> and do that in all possible ways, and you get [1,10,2,20,3,30]
00:31:07 <salierix> What about the State monad? That seems to be the only I'm having the most trouble with.
00:31:10 <dons> dfranke: based on hits for the phrase "foo programming" on google and other sites (including youtube...)
00:31:11 <Cale> okay
00:31:24 <salierix> I don't know how it's use or what it does...
00:31:34 <dons> dfranke: that's their methodology. some enough blog links to reddit over time pays off.... ;)
00:32:07 <Cale> A value of type (State s a) represents a computation which manipulates (reads/writes) a state of type s, before resulting in a value of type a
00:32:29 <dfranke> dons: I'll bet COBOL is significantly more popular than that index would indicate.
00:32:30 <pmdboi> do i need an existing ghc to build ghc?
00:32:37 <Cale> pmdboi: yes
00:32:40 <pmdboi> :(
00:32:49 <dons> dfranke: quite possibly. and lua seems implausibly high
00:32:58 <Cale> pmdboi: What platform are you on? Usually you should try avoiding building GHC yourself.
00:32:59 <dfranke> COBOL was the #1 language until just a few years ago.
00:33:01 <dons> is it the scripting language in some major game? yielding lots of hits?
00:33:04 <pmdboi> cale: os x 10.5
00:33:17 <salierix> lua is used in a few big games.
00:33:34 <dfranke> dons: so does D
00:33:37 <dons> yes.
00:33:47 <dons> its an odd list
00:33:49 <Cale> pmdboi: hmm... I suppose you just have to grab the previous version first, or wait a little bit for one of the OS X GHC builders to put something up.
00:34:01 <dfranke> and WTF is ABAP?
00:34:03 <pmdboi> yep, probably
00:34:12 <dons> but i'm glad haskell is trending in the right direction. position was just rude
00:34:35 <dons> and its cumulative -- the link count rarely goes down
00:34:38 * wli would expect Ada and Fortran to be quite high.
00:34:45 <pmdboi> can ghc be built with hugs?
00:34:46 <wli> Where's the ranking?
00:34:51 <Cale> pmdboi: no
00:34:51 <dons> http://www.tiobe.com/tpci.htm
00:34:54 <pmdboi> ok
00:34:57 <pmdboi> would be trippy :)
00:35:01 <dons> haskell up 2 positions in the last 4 weeks
00:35:30 <dfranke> COBOL's positive delta looks fishy though.
00:35:38 <wli> The list is utterly bizarre.
00:35:55 <Cale> TIOBE's list is insane.
00:35:58 <dons> you can buy the trend data over time from these guys :)
00:36:10 <wli> PL/SQL helps my cause, I suppose.
00:36:14 <dons> they make money tracking google's count for the phase "haskell programming" et al.
00:36:42 <wli> Though I, like my former boss (now my 2nd level mgr.) would rather see Prolog than PL/SQL.
00:36:50 <Cale> I bet Logo has a higher position than it should.
00:37:14 <Cale> Picking a language name which is also a common word seems like a good way to cheat their methodology
00:37:46 <pmdboi> cale: i've been compiling several open-source compilers/interpreters for leopard
00:37:46 <Cale> Well, hmm, Icon isn't doing as good as you'd think in that case though
00:37:53 <pmdboi> since neither fink nor macports seem to have caught up
00:37:57 <dons> is delphi a commercial pascal or something?
00:38:01 <Cale> yes
00:38:06 <Cale> by Borland
00:38:12 <pmdboi> i don't think even one has compiled without having to be patched somehow
00:38:14 <dfranke> IRC channel population is probably a pretty good gague of the languages that hackers use.
00:38:15 <Cale> I used it in highschool
00:38:19 <dons> ah. must be exciting.
00:38:29 <dons> dfranke: yeah. that's a much more interesting list :)
00:38:53 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
00:39:15 <scook0> reminds me of that "irc channel clustering graph" somebody made a while back
00:39:29 <salierix> 349 people here but only a handful actually talk.
00:39:31 <scook0> linking channels with many inhabitants in common
00:39:33 <dfranke> though it probably overrepresents Haskell and Perl because their communities are so friendly.
00:39:39 <dons> php > perl > C > python > c++ > haskell > ruby > math
00:39:52 <dons> good for spotting linux distros on the rise too, like arch
00:39:52 <scook0> dons: be sure to qualify that statement! ;)
00:39:55 <dons> :)
00:40:04 <wli> Ada is larger than given credit for.
00:40:13 <dons> java's way down the community list.
00:40:26 <dons> xmonad has more users than ocaml, by this metric :)
00:40:30 <scook0> is anybody excited about Ada, though?
00:40:31 <dons> ?users xmonad
00:40:32 <mbot> Unknown command, try @list
00:40:36 <wli> This is not to say that I'm a fan of Ada or that it should really be all that far up in the rankings.
00:40:38 <dons> ah
00:40:50 <salierix> I tried xmonad but I don't think it's ready for normal use yet.
00:40:51 <scook0> my impression is that it mostly gets used for Serious Business
00:40:53 <wli> scook0: Not really. Just lots of defense contracts involved.
00:41:05 <dons> i'm so glad we're staying ahead of ruby-lang
00:41:08 <scook0> makes sense, given its heritage
00:41:15 <sjanssen> salierix: why?
00:41:20 <dfranke> dons: It could be true.  I've met a lot of xmonad users who don't know the first thing about Haskell.
00:41:26 <dons> me too
00:41:31 <dons> its quite cool.
00:41:47 <dfranke> Though it would be unusable to me if I didn't know Haskell.
00:41:56 <dons> i encourage everyone to get out there and write good haskell apps for nice markets
00:42:12 <Korollary> nice or niche?
00:42:12 <salierix> sjanssen, it segfaulted on my once and another time I lost my keyboard input.
00:42:25 <dons> nice niche ones in Nice
00:42:40 <dons> salierix: a segfault? when?
00:42:44 <Korollary> Nice the language or the city?
00:42:46 <dons> please report such a thing!
00:43:00 <salierix> Yesterday using 0.4
00:43:05 <dons> salierix: we consider it very much ready for primetime.
00:43:07 <dfranke> I'm still using 0.2.  I should really get around to upgrading.
00:43:13 <Cale> Who is running lambdabot now?
00:43:16 <wli> I do Linux kernel stuff full-time. I've still got uses for Haskell but am not up to the task of a major app.
00:43:18 <dons> ok, please report what you compiled it with, and under what conditions it failed
00:43:31 <dons> salierix: since we've had /no/ other such reports, this is very intriguing.
00:43:45 <dons> if you can get a core dump, and back trace, and any details about unusual things in your system
00:43:49 <dons> that would be really helpful
00:44:11 <sjanssen> salierix: do you use the program 'unclutter'?
00:44:18 <salierix> unclutter?
00:44:28 <dons> guess not.
00:44:29 <sjanssen> I'll take that as a 'no'
00:44:40 <dons> salierix: do you know where to report the bug to?
00:44:54 <salierix> No...
00:45:02 <dons> http://code.google.com/p/xmonad/issues/list here plesae
00:45:17 <salierix> Another problem is that only the left alt key seems to work as a hotkey.
00:45:19 <dons> with as much information as possible about the crash
00:45:31 <dons> in particular, a gdb trace of any core file produced
00:45:43 <dons> that depends on your keyboard
00:45:49 <wli> dons: I'll probably get more data analysis stuff going now that I've got GSLHaskell/HSSL in my toolbelt.
00:45:51 <dons> and how xmodmap has been used.
00:45:56 <dons> wli, cool!
00:46:33 <wli> dons: Maybe. It's dull in practice. Just linear regression most of the time. Maybe some principal components analysis but doubtful even that much.
00:47:09 <dons> salierix: do you have everything you need to submit the report?
00:47:29 <dons> its hard for us to improve things unless those who have problems report them :) otherwise all we hear is good news
00:47:37 <salierix> No, I have no other information other than the fact that it segfaulted. Sorry.
00:47:44 <dons> can you reproduce it?
00:48:00 <dons> and is there a core dump? which ghc were you using, on which arch, and with which precise library versions.
00:48:09 <dons> including which version of X11, and any apps running at the time.
00:48:13 <wli> dons: (This would largely be preexisting infrastructure/etc. applied to concrete data collection problems in various one-off apps/scripts/etc. vs. building up new stuff for libraries, sorry.)
00:48:14 <dons> that kind of information
00:48:17 <dfranke> I find that keyboard-controlled tiling window managers are basically a necessity when you have enough pixels.
00:48:32 <dfranke> I have three 22" monitors.  Mousing takes forever.
00:48:43 <dons> yeah, big monitors make a difference
00:48:53 <dons> since there's just so much physical space to cover
00:48:53 <salierix> There might have been a core dump but it's gone now. I deleted my ghc 6.6.1 installation in my home directory.
00:49:11 <Korollary> dfranke: Are you using CAD software?
00:49:17 <dfranke> Korollary: no
00:49:37 <dons> salierix: well, that's a bit frustrating. we can't do much about it without more information.
00:49:40 <Korollary> So what do you do with three 22" monitors?
00:49:52 <dfranke> write code.
00:49:54 <dons> if you feel up to attempting again to reproduce the issue, i'd be greatful
00:50:40 <salierix> Oh another problem is that running mplayer fullscreen seemed to cause a lookup after awhile.
00:50:53 <dfranke> a few emacs windows take up one screen, a firefox window or two takes up another, rxvt and anything miscellaneous on the third.
00:52:30 <salierix> I'll install xmonad again after I get ghc 6.8.1 up and running.
00:53:08 <dons> ok. note that ghc 6.8 isn't officially supported yet by xmonad
00:53:27 <salierix> Does it compile?
00:53:43 <misterbeebee> If i've already built ghc-6.8.1 without extralibs, is it safe to copy extralibs into my source tree later and make again? and will that build only extralibs or rebuild everything again?
00:53:59 <scodil> anyone have a problem is 6.8.1 not finding libgmp when linking?
00:54:14 <scodil> a problem _with_ 6.8.1
00:54:19 <dons> scodil: on a bsd system likely you'll need to incldue the path to /usr/local/lib
00:54:34 <scodil> ok what about debian/ubuntu?
00:54:43 <wli> I run X so I can cram more xterms on my screen.
00:54:45 <dons> salierix: it won't find the 'containers' library, so you need to add that to your .cabal file
00:54:57 <dons> scodil: haven't seen any reports. do you have libgmp installed?
00:55:02 <scodil> yes
00:55:19 <dons> try the #ghc guys, or report it on trac, with the faliure message
00:56:05 <sjanssen> scodil: on a Mac?
00:57:18 <scodil> sjanssen: amd64
00:57:29 <scodil> ubuntu
00:57:39 <dons> where does libgmp live on that machine?
00:57:45 <scodil> /usr/lib
00:57:46 <dons> /usr/lib/libgmp* ?
00:57:46 <sjanssen> scodil: no comment in that case
00:57:49 <Korollary> Weirdest thing. I can't use checkinstall to create a debian pkg because installPackage segfaults. Blah.
00:58:08 <scodil> /usr/lib/libgmp.so.3.4.1, linked to by libgmp.so.3
00:58:25 <dons> so its there. maybe you mangled mk/build.mk ?
00:58:32 <dons> is there a 32/64 bit issue?
00:58:46 <dons> did it detect the wrong arch/platform?
00:58:47 <scodil> no i don't think so. very few 32 bit libraries installed
00:59:01 <dons> is it trying to link against  the wrong libs though?
00:59:04 <scodil> not sure actually
00:59:07 <scodil> let me look
00:59:22 <scodil> where would it say that?
01:01:14 <scodil> ./configure sees only x86_64-uknown-linux-gnu
01:03:09 <scodil> whoa ok. mk/config.mk says "HaveLibGmp=NO" but ./configure totally says it finds it
01:04:11 <salierix> Is any work still being done on a haskell ide?
01:04:39 <bos> @where eclipsefp
01:04:39 <mbot> I know nothing about eclipsefp.
01:04:48 <bos> @where+ eclipsefp http://eclipsefp.sourceforge.net/
01:04:49 <mbot> Done.
01:04:51 <bos> see above.
01:06:35 <salierix> Is it any good?
01:07:54 <dfranke> holy crap... my System.Posix.Semaphore and System.Posix.SharedMem contributions got accepted into the codebase.  I didn't realize that.
01:08:39 <wli> Congrats.
01:09:41 <Cale> salierix: oh, I was going to tell you more about the State monad
01:10:33 <Cale> salierix: Changing state can be simulated in a pure language by simply passing around a parameter representing the state.
01:10:44 <salierix> Oh yeah.
01:11:17 <Cale> That is, we can represent a computation which acts on a state of type s, producing a value of type a, just using a function of type s -> (s,a)
01:11:34 <Cale> That is, it takes an initial state, and produces a final state along with a result of type a
01:12:07 <Cale> If we define:
01:12:11 <scodil> ./configure says "checking for __gmpz_fdiv_qr in -lgmp3... no"  anyone know anything about that? Does 6.8.1 depend on gmp4? It says it only needs 2 or better
01:12:27 <Cale> newtype State s a = State { runState :: s -> (s,a) }
01:12:54 <Cale> then we get an extractor function:  runState :: (State s a) -> s -> (s,a)
01:13:18 <salierix> I'm with you so far.
01:14:00 <Cale> okay, so thought of another way runState will take our wrapped-up State computation, along with an initial state and compute the final state and result
01:14:15 <Cale> return :: a -> State s a
01:14:37 <Cale> return x is supposed to produce a computation which does nothing but returns x as its result
01:14:41 <Cale> So:
01:14:52 <Cale> return x = State (\s -> (s,x))
01:15:19 <bos> >1
01:15:26 <bos> is lambdabot dead?
01:15:32 <bos> @seen lambdabot
01:15:33 <mbot> Unknown command, try @list
01:15:35 <Cale> Before tackling >>=, I think it's good to look at >> first
01:16:06 <Cale> If x and y are computations, then x >> y is the computation which runs x, then runs y, returning y's result.
01:16:09 <Cale> So:
01:16:29 <salierix> I'm finding that return difficult to parse.
01:16:40 <Cale> return x = State (\s -> (s,x))
01:16:43 <Cale> this line?
01:16:46 <salierix> Yes.
01:17:07 <Cale> State is the data constructor for the type State s a
01:17:19 <Cale> it takes a function of type s -> (s,a) as a parameter
01:17:34 <Cale> and simply wraps it up into a value of type State s a
01:17:46 <salierix> Oh that's right.
01:17:56 <Cale> (\s -> (s,x)) is the function which takes s, and produces the pair (s,x)
01:18:08 <Cale> that is, the initial state is carried through to the final state unaffected
01:18:15 <Cale> and x is the "result"
01:18:52 <salierix> Please continue with >>
01:18:56 <Cale> okay
01:19:05 <Cale> So we have something like:
01:19:14 <Cale> x >> y = State (\s -> ...)
01:19:35 <Cale> Now, we have to run x
01:19:58 <Cale> We only have one possible initial state to run x with at this point, which is s
01:20:18 <Cale> x >> y = State (\s -> let (s',v) = runState x s in ...)
01:20:38 <Cale> and when we run x, we'll get a new state s'
01:20:43 <Cale> along with a value v
01:21:03 <Cale> x >> y is supposed to throw away the result of running x, so we won't use v
01:21:33 <Cale> However, to preserve the illusion that state is getting updated in sequence, we'll carry the final state from running x through as the initial state to run y
01:21:54 <Cale> so:
01:22:03 <Cale> x >> y = State (\s -> let (s',v) = runState x s in runState y s')
01:22:36 <salierix> Interesting.
01:22:59 <Cale> So that makes sense?
01:23:18 <salierix> What do get and put do?
01:23:29 <Cale> get :: State s s
01:23:42 <oerjan> @src State get
01:23:43 <mbot> Source not found. Sorry.
01:23:55 <Cale> It results in the current state, and doesn't affect the state
01:24:01 <Cale> get = State (\s -> (s,s))
01:24:45 <Cale> Eventually, we don't want to have to work directly with these functions s -> (s,a), but rather with return, bind, get and put
01:25:08 <Cale> put x  simply changes the state to x
01:25:21 <Cale> put :: s -> State s ()
01:25:36 <Cale> put x = State (\s -> (x,()))
01:25:53 <Cale> So it throws away its initial state and replaces it with x
01:26:04 <ADEpt> hello! what's with haskell.org? is it down?
01:26:15 <Cale> ADEpt: it's overloaded from the GHC release
01:26:19 <salierix> What is the value used for?
01:26:19 <dmwit> ?fact slow?
01:26:20 <mbot> I know nothing about slow?
01:26:46 <Cale> salierix: () is just the empty tuple, it's used whenever you don't have anything interesting
01:26:46 <misterbeebee> @fact slow
01:26:46 <mbot> I know nothing about slow
01:26:57 <dmwit> Wrong bot. =)
01:27:05 <Cale> lambdabot is also seemingly dead
01:27:08 <scodil> anyone built gtk2hs with 6.8.1?
01:27:23 <Cale> oh, and I know why mbot is not working w.r.t. haskell evaluation too ;)
01:27:28 <ADEpt> Cale: so, 6.8.1 is out?
01:27:33 <Cale> (It needs to be recompiled with 6.8.1)
01:27:34 <Cale> yes
01:27:37 * ADEpt heads to haskell.org
01:27:40 <ADEpt> oh wait ...
01:27:43 <dottedmag> :))
01:27:45 <Cale> Haskell.org is really slow :)
01:27:52 <Cale> It's up, it's just very very slow
01:27:57 <Cale> What platform?
01:28:09 <Cale> dfranke and I have some mirrors :)
01:28:16 <newsham> nobody torrent'd yet?
01:28:24 <dfranke> http://dfranke.us/ghc-6.8.1-src.tar.bz2
01:28:26 <dmwit> Actually, just laggy.  Responding to a connection request takes a long time, but then the data transfer itself seems quite spunky.
01:28:29 <dfranke> http://dfranke.us/ghc-6.8.1-src-extralibs.tar.bz2
01:28:33 <Cale> http://cale.yi.org/autoshare/ghc-6.8.1-i386-unknown-linux.tar.bz2
01:28:34 <salierix> Where can I find the implementation of State in the library source?
01:28:38 <dfranke> we don't need no steenking torrents.
01:28:55 <Cale> salierix: Control.Monad.State
01:29:02 <Cale> salierix: in the mtl package
01:29:12 <Cale> oh, we didn't do >>=
01:29:19 <ADEpt> Cale: thnx for the URL
01:29:28 <Cale> x >> y = State (\s -> let (s',v) = runState x s in runState y s')
01:29:55 <salierix> Control.Monad.State seems empty.
01:30:01 <Cale> hmm
01:30:14 <Cale> what does it import?
01:30:15 <oerjan> it probably just imports State.Lazy
01:30:20 <Cale> ah, right
01:30:25 <Cale> hehe, things moving around ;)
01:30:50 <oerjan> there is also a State.Strict which does some seq'ing
01:31:01 <scodil> anyone built c2hs with 6.8.1?
01:31:17 <Cale> So the difference between >> and >>= was that >>= used the result of the first computation, taking a function as its right parameter
01:31:33 <Cale> salierix: So perhaps you can even guess how to write >>= on your own :)
01:36:05 <salierix> Hmm...
01:37:30 <salierix> x >>= y = State (\s -> let s' = runState x s in y s')
01:37:31 <salierix> ??
01:38:03 <Cale> you'll still have two runStates
01:38:08 <dmwit> salierix: Remember, runState produces a tuple.
01:38:21 <Cale> and yes, remember that :)
01:38:31 <Cale> x >> y = State (\s -> let (s',v) = runState x s in runState y s')
01:38:38 <Cale> So here, v got thrown away
01:39:09 <Cale> we want to make sure to use it to build the computation which follows, along with the function we have as the right parameter of >>=
01:40:31 <Cale> that is, in  x >>= f, we should use f along with v to build what was y :)
01:41:27 <scodil> I'm getting an error that says Data.Map can't be found because package containers-0.1.0.0 is hidden
01:42:06 <Cale> scodil: which ghc are you using?
01:42:08 <dfranke> just add it to the cabal file.
01:42:14 <scodil> 6.8.1
01:43:21 <salierix> Heh, i'm lost.
01:43:25 <Cale> salierix: okay
01:43:32 <Cale> So...
01:43:47 <Cale> x >>= f = State (\s -> let (s',v) = runState x s in ...)
01:43:53 <Cale> it's the same up to there
01:44:18 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
01:44:41 <Cale> So v :: a, and f :: a -> State s b
01:44:56 <Cale> and we need a pair of type (s,b)
01:45:14 <Cale> (because we're writing the State s b value which is being returned)
01:45:22 <Cale> We can apply f to v
01:45:32 <Cale> and that gives us a State s b
01:45:37 <Cale> and then we can run that
01:45:38 * dmwit thinks . o O ( We need a (State s b), but we have an (a) and an (a -> State s b).  What should we do?)
01:45:58 <Cale> dmwit: well, we really need an (s,b)
01:46:14 <Cale> so...
01:46:16 <salierix> Oh
01:46:26 <Cale> x >>= f = State (\s -> let (s',v) = runState x s in runState (f v) s')
01:46:42 <Cale> x >> y = State (\s -> let (s',v) = runState x s in runState y s')
01:46:48 <Cale> (just for comparison)
01:46:52 <salierix> Ah.
01:47:23 <Cale> Rather than being given the next computation, we use the function we're given to build it.
01:47:42 <salierix> You don't happen to have the 64bit version of ghc 6.8.1 do you?
01:47:47 <Cale> nope
01:48:42 <salierix> I hope haskell.org is back up soon.
01:49:09 <Cale> yeah
01:49:25 <salierix> Thanks for the lesson :)
01:49:32 <dmwit> I hope so too, for more than just the new bling of 6.8.
01:49:58 <dmwit> There's a lot of docs on haskell.org!  I didn't really realize how much I used that site until it went down. =P
01:50:20 <salierix> Or put the ghc stuff on it's own server so it doesn't take down the haskell wiki.
01:50:22 <Cale> salierix: So it makes sense how that works? We're essentially building a simple embedded programming language out of functions. Now that we have return, (>>=), get and put, we don't need to look underneath the State data constructor anymore
01:50:32 <Cale> Someone should create a torrent
01:50:45 <scook0> dmwit: yeah, the frustrating thing is that the extra load affects even those of us who aren't upgrading immediately
01:51:00 <Jiten> internet archive doesn't have a copy of haskell.org?
01:51:06 <Jiten> or google cache
01:51:12 <dmwit> Jiten: Of course, there are ways to get the information.
01:51:49 <oerjan> the strange thing is that google is slow when you ask it about haskell.org :(
01:51:58 <oerjan> at least it was a while ago
01:52:35 <scook0> I wonder if the troubles are due to excessive download transfer, or just excessive client interest ...
01:52:52 <oerjan> and the internet archive has a > 6 months lag
01:52:57 <salierix> Why is State better than using an IORef or something?
01:53:06 <dmwit> salierix: It isn't in IO. ;-)
01:53:34 <dmwit> As strange as it sounds, you can write pure (i.e. referentially transparent) functions that make use of stateful computations.
01:53:35 <salierix> But the State keeps getting copied when it's updated doesn't it?
01:53:39 <scook0> salierix: you know that a value of type State s a won't send network traffic, or delete files, or anything ;)
01:54:07 <scook0> depends on what you mean by "copied"
01:54:39 <Cale> not quite
01:54:40 <scook0> and yeah, eventually you might want to take a look at the ST monad
01:54:44 <Cale> It's simply passed around
01:54:55 <Cale> (and since it's a pointer, that's cheap)
01:55:13 <Cale> Of course, if you modify the state, the modified state gets passed around and the old one GC'd
01:55:35 <Cale> (maybe not completely GC'd if the new one refers to parts of the old one)
01:55:57 <scook0> but in that case you've saved some copying effort
01:56:11 * dmwit wonders if anyone ever made a transformer stack like (StateT s1 (State s2)) as an optimization.
01:56:13 <scook0> so it's a net win
01:56:39 <scook0> I remember at one point being frustrated that MonadState uses fundeps
01:56:49 <salierix> fundeps?
01:56:56 <scook0> so you couldn't have multiple state types in the same monad stack
01:57:04 <scook0> "functional dependencies"
01:57:05 <sjanssen> scook0: MonadState would be useless without them
01:57:05 <Cale> You'd be more frustrated if it didn't though, I think.
01:57:24 <scook0> sjanssen: really? how?
01:57:46 <sjanssen> scook0: you have to annotate subterms very frequently
01:57:54 <sjanssen> s/you/you would
01:58:00 <salierix> What does "functional dependencies" mean in this context?
01:58:09 <scook0> my idea was that the context would determine which state was being read/written
01:58:23 <Cale> salierix: the operations get and put have been generalised and put into a typeclass
01:58:34 <scook0> since I never actually managed to get it working, I have no idea whether it would have been frustrating or not to use
01:58:37 <sjanssen> salierix: they're hints to the compiler to reduce ambiguities during type inference
01:58:41 <Cale> salierix: class MonadState s m
01:58:55 <Cale> class MonadState s m | m -> s where ...
01:59:10 <Cale> The "| m -> s" is called a functional dependency
01:59:20 <Cale> and means that the type m determines the type s uniquely
01:59:32 <Cale> That is, if you have a state monad, you know which state type it has.
01:59:59 <Cale> It also means you can't declare more than one instance of MonadState for a given monad.
01:00:25 <Cale> But it helps the typechecker so that it can figure out which implementations of get and put it needs for your given monad.
01:00:28 <KatieHuber> anyone know offhand how to convert Double -> CDouble ?
01:00:37 <Cale> realToFrac?
01:00:50 <KatieHuber> ta
01:01:24 <salierix> Two class parameters?
01:01:28 <Cale> yeah
01:01:43 <Cale> Multiparameter type classes can be seen as relating multiple types to one another
01:01:53 <Cale> with some functionality that goes between them
01:02:12 <Cale> In this case, the relationship is the state monad and its state type
01:02:38 <oerjan> @instances-importing Control.Monad.State MonadState
01:02:48 <mbot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
01:03:20 <Cale> heh, without the constraints, that's kind of a silly list
01:03:48 <salierix> What are the most useful build in monads?
01:04:06 <oerjan> most of those instances only lift another state monad up through a monad transformer
01:04:09 <salierix> built it
01:04:19 <dmwit> I think it's list, IO, State, in that order.
01:04:32 <Cale> By built in, do you mean in the libraries?
01:04:39 <salierix> Yeah
01:04:45 <Cale> IO and ST are really the only two monads with special compiler support.
01:05:01 <dmwit> list?
01:05:03 <Cale> I also really like the monad ((->) e) (that is, functions from a fixed type e)
01:05:13 <oerjan> dmwit: []
01:05:13 <wli> IO = ST RealWorld?
01:05:21 <sjanssen> @src IO
01:05:21 <mbot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:05:21 <dmwit> Oh, I guess list isn't really special.
01:05:23 <Cale> Well, list has syntax, but the monad instance is nothing special.
01:05:43 <sjanssen> wli: yes, in GHC
01:05:54 <sjanssen> @src ST
01:05:54 <mbot> newtype ST s a = ST (STRep s a)
01:06:02 <sjanssen> @src STRep
01:06:02 <mbot> type STRep s a = State# s -> (# State# s, a #)
01:06:51 <dmwit> Cale: Do you use the ((->) r) monad for anything other than cute composition tricks?
01:07:16 <Cale> Well, the various Control.Monad functions do handy things
01:07:18 <dmwit> (This is not meant to be an attack, I'm honestly interested in uses for it.)
01:07:36 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
01:07:42 <sjanssen> dmwit: Reader (which is the function monad with a different name) is really useful
01:07:45 <Cale> grrr
01:07:55 <Cale> [5,7,10,25,32]
01:08:27 <wli> Where is CDouble?
01:08:35 <sjanssen> Foreign.C.Types
01:08:38 <oerjan> @index CDouble
01:08:39 <mbot> Unknown command, try @list
01:08:50 <dmwit> :t [id, (+2), (*2), (^2), (2^)] `ap` 5
01:08:57 <dmwit> :t [id, (+2), (*2), (^2), (2^)] `ap` [5]
01:09:02 <mbot> L.hs:40:7:
01:09:02 <mbot>     Could not find module `Math.OEIS':
01:09:02 <mbot> L.hs:40:7:
01:09:02 <mbot>     Could not find module `Math.OEIS':
01:09:06 <Cale> heh
01:09:18 <oerjan> oh dear
01:09:57 * Cale cabal installs some stuff
01:10:57 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
01:11:04 <Cale> er...
01:11:07 <Cale> :t [id, (+2), (*2), (^2), (2^)] `ap` [5]
01:11:09 <mbot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
01:11:10 <mbot> [2 of 2] Compiling L                ( L.hs, interpreted )
01:11:17 <Cale> um, what?
01:11:28 <Cale> hehe
01:11:37 <dmwit> yikes
01:11:48 <dmwit> That's an even odder type that I was figuring. =)
01:11:48 <opqdonut> ?bot
01:11:48 <mbot> :)
01:12:35 * Cale updates lambdabot :)
01:13:02 <wli> Cale: HSSL Is also nice but probably needs some minor cleanups to avoid clashes with standard names for things like e.g. join
01:13:29 <Cale> hm?
01:13:33 <wli> At least I'm hog wild about it.
01:14:02 <Cale> What is that?
01:14:10 <oerjan> updating? i thought that Math.OEIS thing was added to lambdabot just the other day?
01:14:18 <wli> Cale: Numerical methods for numerical linear algebra, special functions, optimization, integration, and differentiation.
01:14:33 <Cale> oerjan: I'd added it to mbot as soon as that module came out
01:14:49 * wli has no idea what Math.OEIS is.
01:15:06 <dmwit> Do you know what the OEIS is?
01:15:07 <oerjan> oh right, mbot probably needs it more than ordinary lambdabot :)
01:15:13 <dmwit> ?go OEIS
01:15:14 <mbot> http://www.research.att.com/~njas/sequences/
01:15:14 <mbot> Title: The On-Line Encyclopedia of Integer Sequences
01:15:35 <Cale> wli: cool
01:15:49 <wli> Okay, given that that's OEIS, what's Math.OEIS do?
01:15:55 <Cale> damn, plugins doesn't compile directly off of hackage
01:16:33 <Cale> also, just got the x86_64 binary for ghc
01:16:51 <Cale> http://cale.yi.org/autoshare/ghc-6.8.1-x86_64-unknown-linux.tar.bz2
01:17:02 <salierix> Thanks.
01:17:14 <dmwit> wli: It extends lists like [2,3,5] to lists like [2,3,5,7,11,13,17,...]
01:17:39 <dmwit> (roughly)
01:17:42 <Cale> of course, only finitely many terms
01:17:43 <wli> dmwit: i.e. given the initial terms of a sequence it guesses how to extend it?
01:17:56 <Cale> It also does complete OEIS database lookups
01:18:02 <Cale> broken nicely into fields
01:18:59 <oerjan> as in fields of records or as in fields of mathematics?
01:21:29 <Cale> records
01:22:09 <Cale> oh right, crap, plugins will need updating... maybe the darcs version will work
01:22:37 <wli> I wonder what else there is under the Math.* hierarchy.
01:22:42 <dmwit> Cale is descending the dependency chain...
01:23:00 <oerjan> will he ever return?
01:23:22 <sclv> no he never returned. he's the coder who never returned. (all together now)
01:23:46 * oerjan doesn't know that reference.
01:23:58 <sclv> @go "charlie on the mta"
01:23:59 <mbot> http://www.mit.edu/~jdreed/t/charlie.html
01:23:59 <mbot> Title: Charlie on the M.T.A.
01:25:11 <wli> Something is deeply wrong here.
01:25:19 <wli> > let facs, nDerange :: [Integer] ; facs = 1 : scanl1 (*) [1..] ; nDerange = tail . map numerator . zipWith (*) (map fromInteger facs) . scanl1 (+) . zipWith (*) (cycle [1, -1]) $ (map (recip . fromInteger) facs :: [Rational]) in take 10 nDerange
01:25:27 <Cale> src/Language/Hi/FastString.hs:207:8:
01:25:27 <Cale>     Constructor `STArray' should have 4 arguments, but has been given 3
01:25:36 <Cale> blah
01:25:44 <wli> *mbot* Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
01:25:56 <Cale> yeah, that's expected
01:26:09 <Cale> given that I don't have hs-plugins installed
01:26:30 <wli> That'll do it.
01:26:40 <Cale> and it doesn't compile with 6.8.1
01:26:47 <Cale> So I'm out of luck for now.
01:27:46 <Cale> Is nobody going to download the x86_64 6.8.1 from me?
01:29:18 <wli> I've already got more recents darcs version(s) of ghc and if I were to go x86-64 I'd need an x86-64 binary built for 32-bit Debian userspace.
01:31:41 <salierix> Cale, I will in a few minutes.
01:36:47 <goalieca> Cale, i'm dl'ing it
01:37:10 <Cale> cool
01:38:05 <goalieca> ubuntu still has me using 6.6
01:38:15 <goalieca> last time i built ghc.. it took forever.
01:38:18 <goalieca> so thanks!
01:38:32 <dmwit> 6.6 was the last stable release, so it isn't that old.
01:38:46 <Cale> well, 6.6.1
01:38:50 <dmwit> 6.<even> are stable releases, 6.<odd> are unstable ones.
01:39:01 <dmwit> Okay, yeah, 6.6.1.
01:39:13 <ivanm> I thought 6.8.0 is an unstable release...
01:39:20 <Cale> 6.even.0 apparently are pre-release testing
01:39:26 <ivanm> *nod*
01:39:54 * dmwit just hates seeing distributions being castrated for "only having 6.6".
01:40:27 <goalieca> ya. gutsy doesn't even have kde4 yet :(
01:40:33 <goalieca> :P
01:40:38 <dmwit> heh
01:40:53 <salierix> gentoo only has 6.4.2
01:41:04 <Cale> I'm going to switch distributions. This doesn't even come with Duke Nukem Forever.
01:41:46 * arcatan wants 6.8
01:41:57 <arcatan> it has to be something cool if haskell.org is down
01:42:00 <Cale> arcatan: which platform?
01:42:11 <dmwit> arcatan: Make Cale happy, say x86_64. =)
01:42:20 <Cale> I have x86 as well
01:42:22 <Cale> (linux)
01:42:26 <arcatan> nah, x86 Linux
01:42:42 <Cale> http://cale.yi.org/autoshare/ghc-6.8.1-i386-unknown-linux.tar.bz2
01:43:08 <goalieca> remember the old irc days which had announce and download bots
01:43:09 <Cale> I just downloaded the 64 bit so that other people could get it from me.
01:43:09 <b_jonas> so it's not just unreachable from here. good.
01:43:14 <salierix> I took the 64bit plunge a few months ago.
01:44:39 <Cale> b_jonas: It's not completely unreachable, it's just slow.
01:45:02 <dottedmag> Cale: it's slow up to connection timeouts on proxies.
01:45:36 <dmwit> If it takes more than 8 seconds, it's as good as unreachable.
01:45:57 <dmwit> </statistic type="worthless">
01:47:02 <ivanm> dmwit: shouldn't the slash go at the closing brace?
01:47:38 <dmwit> No, but the opening tag should have the attribute.
01:48:18 <wli> I'm more than happy to go 64-bit if/when there's a nondisruptive migration path to it. Otherwise... wait until there is one. Wait years. Decades. Don't ever migrate if a nondisruptive migration path never materializes.
01:48:49 <b_jonas> I'm too lazy to go to 64 bit as well
01:48:56 <b_jonas> because the only motivator is speed.
01:49:05 <wli> I'm not lazy. I'm risk-averse.
01:49:09 <Cale> I'm too cheap to go to 64 bit.
01:49:13 <goalieca> b_jonas, just wait till you have 8gb of ram
01:49:28 <b_jonas> Previously, I've installed completely new systems on my home computer because the previous one had problems.
01:49:50 <b_jonas> At those times, I always had double-booting between the two systems.
01:49:53 <wli> If I can't apt-get upgrade to it, it's never going to happen.
01:50:17 <dmwit> There will never be a software upgrade that turns your 32-bit machine into a 64-bit one.
01:50:26 <b_jonas> Used the previous one if I needed to do something urgently and I haven't yet set it up in the new system.
01:50:38 <dmwit> As a kernel hacker, you must be close enough to the hardware to know this.
01:51:10 <b_jonas> But now the 32-bit debian works perfectly so there's nothing to motivate me like there was when I changed from a messed-up system.
01:51:15 <Cale> dmwit: Never? Okay, maybe not in time.
01:51:55 <b_jonas> (By messed up, I mean that _I_ have irrevocable messed those systems up.)
01:52:00 <salierix> Run your 32bit machine in a VM.
01:52:05 <Plareplane> people might go 64bit when 4gb ram becomes a common consumer configuration?
01:52:17 * Cale imagines a 32-bit architecture machine with built with self-modifying nanotech.
01:52:30 <dmwit> Borg!
01:53:24 <dmwit> There became more than 4 billion of them, so they *had* to just to keep track of their population!
01:53:25 <dmwit> =)
01:53:54 <salierix> No, they just use big nums.
01:54:32 <b_jonas> goalieca: you know, if I need lots of speed (and memory) for some computation, I use the machines in the university because they have more money for computers than me.
01:54:40 <b_jonas> And they are running a 64-bit os.
01:55:22 <quicksilver> 64-bit, in isolation, makes things slower
01:55:35 <quicksilver> and there are various hacks to access more than 4G on a 32 bit machine
01:55:39 <quicksilver> inelegant hacks, but they work
01:55:52 <goalieca> b_jonas, i do to.. but sometimes i just can't wait for the queue when all i need to do is a 6 minute op
01:57:36 <quicksilver> then again, 64bit seems to be happening piecemeal
01:57:57 <quicksilver> I have one mchine at home which is Athlon XP architecture, but I run a 32-bit userland on it
01:58:19 <quicksilver> I have another which is intel core 2 duo/santa rosa which is also 'partly 64bit' in a sense
02:00:20 <b_jonas> quicksilver: not "in isolation", but x86_64 did a good job in not being slower than x86 if you recompile everything to 64 bit, because 32 bit operations are supported well
02:00:36 <b_jonas> it suits the assumption that int is 32 bit large well
02:01:19 <b_jonas> as for hacks to access more than 4G, you have to case that to two parts:
02:01:51 <b_jonas> there are good hacks to access more than 4G of physical memory (it's like xms used to be in the dos days but with less problems)
02:02:24 <b_jonas> but having more than 4G (or 3G or whatever) of address space in a process, there are hacks but they're very bad and slow
02:05:38 <phlpp> hi!
02:13:50 <Zao> So, who forgot to feed the server hamster?
02:14:59 <geocalc> @where ghc 6.8.1
02:14:59 <mbot> I know nothing about ghc.
02:15:14 <Zao> I put up my 6.8.1 tarballs at http://www.acc.umu.se/~zao/ghc/
02:15:21 <Zao> source only, that is.
02:15:41 <geocalc> thanks
02:23:19 <Karle> Hi
02:24:26 <TSC> Hi
02:26:11 <geocalc> Zao=<< where i untar extralibs ?
02:26:43 <Zao> geocalc: Both has ghc-6.8.1 as their dir, so just untar the src one first, then the src-extralibs in the same place.
02:27:06 <Zao> I'd link you to the compiling guide, but the site is down :)
02:27:24 <geocalc> i saw
02:28:46 <Karle> hi shapr
02:29:46 <dmwit> Seen on an online forum: "There are Just 1 types of people, Nothing and those who understand monads - newsham"
02:30:44 <Zao> http://web.archive.org/web/20070425042116/hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources http://web.archive.org/web/20070624014249/hackage.haskell.org/trac/ghc/wiki/Building/Hacking
02:31:32 <geocalc> thanks again Zao
02:32:07 <Karle> hi TSC
02:32:12 <Heffalump> does the 6.8.1 release really have left-to-right impredicative instantiation? I thought SPJ removed that again before release, but the release notes mention it.
02:35:04 <Karle> hi sek
02:37:27 <oerjan> i think Control.Monad.ST.runST $ return () would test that...
02:37:50 <salierix> Excellent, haskell.org is back up.
02:39:15 <DRMacIver> What exactly *is* left-to-right impredicative instantiation?
02:48:09 <Karle> hi oerjan
02:49:04 <oerjan> hi
02:50:31 <b_jonas> Ah look, haskell.org now loads for me
02:50:36 <johnnowak> finally
02:51:18 * b_jonas imagines the rush resulting my statement bringing the server down again
03:03:57 <Lemmih> shapr: ping.
03:04:35 <Zao> Lemmih: I believe one can leave messages through lambdabot, or through memoserv.
03:04:57 <opqdonut> @help tell
03:04:58 <mbot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
03:04:59 <opqdonut> like so
03:05:17 <oerjan> except lambdabot is not working
03:06:16 <ivanm> roconnor: ping!
03:07:05 <opqdonut> ?get-shapr
03:07:06 <mbot> shapr!!
03:07:09 <opqdonut> :))
03:13:43 <salierix> The hssdl package on hackagedb still doesn't work :(
03:14:07 <roconnor> ivanm: ack
03:14:31 <ivanm> just a query with your fewdigits code... how do you actually show your reals?
03:14:54 <roconnor> well various ways
03:15:20 <roconnor> of course you can't really print a real number
03:15:32 <roconnor> you could compute an approximation as a rational
03:15:38 <roconnor> and then print that
03:16:01 <roconnor> but there may be a function called answer that does something nice
03:16:02 <ivanm> *nod*
03:16:16 <ivanm> just that your "instance show creal" just spits out an error message
03:16:47 <roconnor> yep
03:17:16 <roconnor> so there is a function answer :: Integer -> CReal -> String
03:17:52 <ivanm> ahhh, k
03:17:54 <roconnor> hmm
03:17:58 <ivanm> with the Integer being the precision?
03:18:12 <roconnor> n is the number of decimal places you want to print.
03:18:23 <ivanm> which is what I meant :p
03:18:28 <roconnor> now that I look at it
03:18:39 <roconnor> "x10^-"++(show n) should be replaced with "x10^"++(show (-n))
03:18:43 <roconnor> but whatever
03:18:48 <ivanm> though I see all you do is whack a "x10^-<param>" on the end
03:18:53 <ivanm> heh
03:19:20 <roconnor> feel free to write you own more sophisticated version.
03:19:22 <roconnor> ;)
03:19:52 <ivanm> lol
03:20:13 <ivanm> yeah, I'm having to write at least the bare-bone outline of a fold-based one (i.e. more functions, less data)
03:20:32 <roconnor> maybe "e"++(show (-n)) would be best
03:20:44 <roconnor> It would be something that would be parsable.
03:21:06 <ivanm> *nod*
03:21:08 <roconnor> > read "31415e-4"::Double
03:21:23 <roconnor> @bot
03:21:23 <mbot> :)
03:21:29 <roconnor> > read "31415e-4"::Double
03:21:31 <oklopol> > read "my ass"::Double
03:21:34 * oklopol is so clever
03:22:15 <dottedmag> < Cale> oh, and I know why mbot is not working w.r.t. haskell evaluation too ;)
03:22:39 <ivanm> what's happened to lambdabot?
03:22:56 <roconnor> probably ghc 6.8.1 happened to lambdabot :(
03:22:57 <roconnor> not sure
03:23:30 <roconnor> ivanm: "e"++(show (-n)) is way better
03:23:39 <ivanm> heh
03:23:48 <roconnor> I think I will probably rename it to showCReal
03:23:54 <ivanm> and yeah, it probably is... especially with the "x" you had for times in there
03:23:56 <ivanm> *nod*
03:24:14 <ivanm> though it'd be nice if you did something like david lester did by actually printing it as a real...
03:24:49 <ivanm> if only you could print functions... having to provide a default precision param to use with show isn't that great idea IMHO
03:26:40 <roconnor> ivanm: I suppose I could make a stream
03:26:49 <roconnor> well, it'd be hard
03:26:54 <ivanm> a stream?
03:27:02 <roconnor> an infinite list of characters
03:27:05 <ivanm> as in an infinite string representation of the creal?
03:27:09 <ivanm> *nod*
03:27:11 <roconnor> but it would be hard to be productive
03:27:15 <ivanm> yeah
03:27:21 <roconnor> and still use the standard decimal number system
03:27:26 <ivanm> true
03:29:59 <trippo_> uhm, how do I write "\x y -> 1 + max x y" point-free style?
03:30:12 <mauke> @pl \x y -> 1 + max x y
03:30:12 <mbot> ((1 +) .) . max
03:30:27 <trippo_> mauke: thanks
03:30:48 <trippo_> but I don't like that very much :-)
03:30:53 <pjd> (1+) `dot` max
03:31:02 <mauke> succ `dot` max
03:31:12 <trippo_> that's better
03:31:13 <mauke> where dot = (.) . (.)
03:32:09 <pjd> succ .. max, if you could
03:32:18 <trippo_> I can continue adding .'s to generalize it, right? like (.) . (.) . (.)
03:32:23 <opqdonut> > curry ((+1) . uncurry max) $ 1 2
03:32:23 <mauke> yes
03:32:36 <mauke>  3
03:32:40 <opqdonut> yep
03:33:08 <mauke> @run 42
03:33:08 <mbot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
03:33:20 <ivanm> roconnor: you wouldn't happen to have a pdf or something of boehms "Exact real arithmetic: A case study in higher order programming", would you?
03:33:44 <ivanm> doesn't matter, just managed to find one! :D
03:33:59 <roconnor> ivanm: you can pull from my repo to get the new showCReal implemenation.
03:34:32 <ivanm> k, thanks
03:35:19 <roconnor> pjd: we often neme (.:) = (.) . (.)  on #haskell.
03:35:23 <roconnor> name
03:35:58 <roconnor> (.::) = (.) . (.) . (.)
03:36:00 <roconnor> etc
03:36:37 <roconnor> I need to get my cabal build process working again.
03:39:46 <ivanm> roconnor: is this your darcs repo: http://r6.ca/FewDigits ?
03:39:56 <ivanm> because it says there are no remote changes to pull in :s
03:42:42 <trippo_> @pl \_ x y -> 1 + max x y
03:42:42 <mbot> const (((1 +) .) . max)
03:42:44 <roconnor> oops
03:42:47 <roconnor> I forgot to mirror
03:43:07 <roconnor> I guess I should add a darcs hook
03:43:32 <roconnor> ivanm: should be there now.
03:43:45 <ivanm> heh
03:53:43 <trippo_> About funny composition operators: are there (semi-)standard names for them? Maybe in category theory?
03:55:48 <ivanm> roconnor: so, in your equality testing, how does that work? if proveNonZeroFrom goes into an infinite loop if it has an input parameter of 0, how will it produce an output of 0?
03:57:15 <roconnor> ivanm: equality testion only produces False or _|_
03:57:20 <roconnor> testing
03:57:35 <ivanm> ahhh
03:57:42 <roconnor> it's not so useful
03:57:49 <ivanm> so if it produces _|_ then its true?
03:57:58 <roconnor> yes
03:59:33 <ivanm> so why is it that if I try calling proveNonZero 0, ghci gets frozen, but for equality testing it just goes to bottom?
03:59:56 <roconnor> frozen is bottom
04:00:09 <ivanm> *nod*
04:00:18 <ivanm> but since ghci is interactive, it stays frozen?
04:00:37 <ivanm> that's just an implementation issue, I assume (implementation of the compiler/interpreter, not of your code)
04:00:41 <roconnor> at any given time ghci doesn't know that it is bottom yet.
04:01:03 <roconnor> so the computation must go on.
04:01:26 <roconnor> you will get the same effect for equality testing
04:02:07 <ivanm> equality testing seems to work...
04:02:19 <ivanm> wait... that could be because it's not using CReals...
04:02:36 <roconnor> ICReals can sometime return True for eqaulity
04:02:41 <ivanm> no, you're right
04:02:48 <ivanm> whats the difference between CReal and ICReal?
04:03:11 <roconnor> ICReal is layerd on top of CReal.
04:03:31 <roconnor> it attempts to be faster by keeping track of upper and lower bounds of the real number
04:04:29 <ivanm> *nod*
04:10:45 <geocalc> Zao=<< i have 2 error with your source 1) dist/build/.depend: no such file or drectory 2) unrecognised flag -02 in [make.library.base] what to do ?
04:11:57 <Karle> a newbie needs help again
04:13:08 <arcatan> please ask
04:13:35 <Karle> I compiled my program ... when I tried to test it... not really working
04:15:43 <hpaste>  Karle pasted "system" at http://hpaste.org/3637
04:17:16 <Karle> arcatan, I tested it with "system (Prst(U,250,UP"first"):-NullS)  (Prst(U,4,UP"third"):-NullS)"
04:17:49 <Karle> (
04:17:49 <Karle> Program error: pattern match failure: update_table [head (give_adr_port (Prst (U,250,UP "first")))] (Prst (U,4,UP "third"))
04:18:55 <geocalc> Zao=<< it was just 'O' and not '0'
04:21:20 <arcatan> Karle: well, uh, you have update_table defined with [] as the first argument, but not you're obviously calling it with something else in update2_table
04:22:15 <Karle> i see
04:23:08 <Karle> arcatan, what is your recommendation?
04:23:51 <arcatan> um... define what happens when update_table is called with non-empty Table as an argument?
04:26:43 <Zao> geocalc: Heh :
04:26:46 <Karle> let me see
04:29:21 <Karle> alright thanks
04:54:36 <ddvlad> @doc ReaderT
04:54:37 <mbot> ReaderT not available
04:55:40 <mauke> @docs Control.Monad.Reader
04:55:41 <mbot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
04:57:44 <trippo_> @pl \x y z -> x `max` y `max` z
04:57:45 <mbot> (max .) . max
05:01:07 <scook0> @undo
05:01:07 <mbot> Maybe you meant: unpf unpl
05:01:41 <roconnor> > maximum [1,2,3]
05:01:45 <trippo_> sometimes I wuold like to have dependent types
05:01:57 <trippo_> s/wuold/would
05:02:29 <pierre-> i'm trying to install packages via cabal-install but i get following for any package: 'cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)'
05:02:40 <pierre-> what this strange error could mean?
05:02:43 <roconnor> cabal-install works?
05:03:29 <pierre-> i thought so :-)
05:03:54 <roconnor> a few months ago it didn't work, but I know people work working on it during the Hackathon
05:04:11 <volk> anyone know where I can find haskell implementation of neighbor joining algorithm?
05:09:46 <roconnor> java has enumerations?!
05:09:56 <EvilTerran> yes. yes it does.
05:10:13 <EvilTerran> they're full-blown classes, too, so you can do all kinds of funk with them
05:10:31 <roconnor> damn, making enumerations in java was such a pain before
05:10:40 <EvilTerran> don't worry, tho, not even my OOP lecturer knows about 'em ;)
05:10:58 <roconnor> I haven't touched java for like 7 years
05:11:03 <roconnor> apparently a lot has changed.
05:11:17 <roconnor> Last I remember they added inner and anonymous classes.
05:11:22 <ivanm> don't worry, it's still a pain
05:11:26 <roconnor> then I learned haskell
05:11:32 <EvilTerran> ivanm, that's definitely true
05:11:34 <scook0> 1.5 added a bunch of new stuff, like enums and generics
05:11:45 <ivanm> java has for-each loops... which are just about useless
05:11:59 * EvilTerran finds the lack of byref parameters or references very annoying
05:12:09 <hpaste>  jeff pasted "haskell rose tree" at http://hpaste.org/3638
05:12:32 <bartw> EvilTerran: hmz, never felt the need for thoe
05:12:43 <EvilTerran> class Ptr<T> { public T to; } // :D
05:12:48 * scook0 sighs
05:13:10 <EvilTerran> bartw, i imagine, in the real world, people won't ask you to implement things like mutable binary search trees
05:14:12 <bartw> usually the collections stuff is done a few projects earlier and just work, so no
05:15:00 <EvilTerran> quite. that's what those gargantuan standard libraries are for.
05:15:37 <bartw> those are hardly complete, but the cost of writing custom datastructurs is amortized over several projects
05:15:47 <Karle> hi again
05:16:17 <bauchus> in a glut example I saw this operator for manipulation an IORef: ioref $~ (+ inc). Where is the operator $~ defined? Thanks.
05:16:34 <Karle> can you explain this code? I dont really understand.
05:17:38 <hpaste>  Karle pasted "code" at http://hpaste.org/3639
05:20:03 <desegnis> bauchus: http://haskell.org/ghc/docs/latest/html/libraries/doc-index-36.html
05:21:59 <bauchus> desegnis: thank you
05:26:12 <Karle> no one is available
05:26:14 <Karle> :)
05:26:38 <desegnis> bauchus: Out of curiosity, do you know what's the purpose of that module? (StateVar)
05:27:01 <Heffalump> Karle: what needs to be explained?
05:28:27 <Karle> hi Heffalump  http://hpaste.org/3639
05:28:42 <Heffalump> yes, I read that
05:28:46 <Heffalump> what don't you understand?
05:28:49 <Karle> ok
05:29:03 <Karle> the second paragraph
05:29:22 <Karle> starting from []
05:29:33 <Heffalump> a CACHE is a list of CACHELEMs
05:29:45 <Karle> yes
05:30:55 <Karle> from add_to_cache_fn::CACHE->PKG->CACHE
05:32:20 <Heffalump> ok, so the next line is just pattern-matching
05:32:37 <Heffalump> if the first argument is an empty list and the second argument is a tuple, then the right-hand side gets returned
05:33:06 <bauchus> desegnis: i found $~ in this example: http://darcs.haskell.org/packages/GLUT/examples/RedBook/CubeMap.hs. See definition of State, mkstate and move.  This is a nice way for updating an IORef. But the complete purpose of Module StateVar itself, I don't understand (yet).
05:33:47 <Karle> yes
05:34:26 <Karle> nh
05:34:36 <Karle> Heffalump : cache@(elem@(op',var1',var2',_):cx) pkg@(id,op,var1,var2,result)
05:36:31 <Heffalump> those are 'as' patterns
05:36:44 <Heffalump> x@pattern causes a pattern-match against pattern
05:37:23 <Heffalump> and also binds the entire value to x
05:37:40 <Heffalump> so if the pattern matches, then the right hand side is used, and x is bound to the value that was being matched against
05:37:59 <fasta> "unable to list source for <exception thrown>" <- how do I list source for it?
05:38:41 <Karle> i understand more from the last sentense :)
05:39:09 <Karle> so if x is found then the right hand side is used?
05:39:45 <desegnis> bauchus: Yes, I understand the syntactical handiness of $= and $~. But I wonder (as maybe you do, too) why the GL libraries include a datatype StateVar, which is only a very general interface to the functionality of IORefs
05:44:40 <desegnis> Karle: The thing about the right-hand side is valid for pattern-matching in general, not special to as-patterns.
05:46:53 <Karle> desegnis : thanks
05:46:54 <desegnis> Karle: Consider fac 0 = 1; fac n@(m + 1) = n * fac m
05:47:24 <desegnis> (Although people don't like m+1 patterns very much, but it's nice for demonstration here)
05:49:28 <desegnis> Both n and m can be used on the right-hand side of the second equation.
05:51:29 <Karle> desegnis : it is much clearer now
05:52:25 <Karle> thanks
05:52:27 <bauchus> does anybody knows OpenGL? i thought it would be fun to write an 3D-Pacman clone. Unfortunatly my PacMan shows some artefacts. Does anybody know why? my code: darcs get http://ibgs.christoph-bauer.net/~fridolin/topkata/ ; Keyboard: 1: Toggle Wireframe/Solid Pacman, b,f: translation (z). 2xb -> looks good.
06:02:14 <TomMD> @messages
06:02:14 <mbot> You don't have any new messages.
06:04:51 <olsner> @tell TomMD You didn't have any new messages.
06:04:51 <mbot> Consider it noted.
06:05:18 <TomMD> Thanks nmess
06:05:19 <mbot> TomMD: You have 1 new message. '/msg mbot @messages' to read it.
06:05:24 <TomMD> shutup bot
06:05:28 <TomMD> @messages
06:05:28 <mbot> olsner said 37s ago: You didn't have any new messages.
06:05:33 <olsner> ;-)
06:05:52 <TomMD> @tell mbot I am here, you don't need to relay messages for me.
06:05:52 <mbot> Nice try ;)
06:07:02 <fasta> Is there a relatively simple way to program a tree implemented with references s.t. it is statically known that no pattern match failures will ever occur?
06:07:36 <fasta> (The different types of nodes have different fields)
06:07:46 <TomMD> Anyone know where the pcap repo is?  Is there one?
06:08:13 <terminalX> hey s guys i am installing a library for ghc and i am geting an errr
06:08:47 <terminalX> Setup.lhs: ld is required but it could not be found
06:08:58 <terminalX> whats that ???
06:09:00 <fasta> terminalX: OS?
06:09:00 <TomMD> terminalX: `which ld`
06:09:13 <terminalX> windows
06:09:18 <TomMD> ah, nevermind
06:09:34 <terminalX> i am using ghc 6.8.1
06:09:43 <fasta> terminalX: what library?
06:10:03 <fasta> terminalX: it's better if you ask a complete question, so that we don't have to guess.
06:10:12 <terminalX> it worked on debian seemlessly, but windows just *****************, if u understand asterisks
06:10:19 <terminalX> HGL
06:10:40 <terminalX> and HTTP-Simple
06:10:49 <araujo> hello
06:11:02 <rey_> bauchus: your definition of prod looks wrong. otherwise I can't help
06:11:20 <terminalX> any help
06:12:04 <fasta> terminalX: did it work with 6.8.1 under Debian?
06:12:25 <TomMD> @let invert "heaven" = "hell"
06:12:25 <mbot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
06:12:34 <TomMD> ?
06:12:52 <terminalX> yep
06:13:04 <Saizan_> terminalX: do you have ghc-installation-dir/bin in your %Path% ?
06:13:05 <Zao> Coding Haskell suddenly got much more fun now that the hoogle-linekd docs are broken.
06:13:27 <TomMD> Zao: Build local ones
06:13:46 <TomMD> make html-docs or runhaskell Setup.[l]hs haddock
06:13:58 <fasta> terminalX: I can't help you since I haven't done Windows Haskell development for quite some time (after I discovered *nix is supported better).
06:14:14 <yitz> hi all. what's up with the bot?
06:14:17 <Zao> TomMD: Do you know how large those will be, approx?
06:14:17 <terminalX> i guess windows aint't good nothing but playing games. I just wanted to write a stock updater and needed the library because i ain't at home and the rain is pouring
06:14:33 <terminalX> yeah i understand
06:14:36 <terminalX> well thanks
06:14:38 <fasta> terminalX: Windows is like a VCR.
06:14:40 <terminalX> later
06:14:56 <terminalX> no windows is like a junk yard
06:14:59 <fasta> You get a few buttons to play with and that's it.
06:15:10 <TomMD> Zao: 15MB for ghc 6.6.1 docs.
06:16:01 <yitz> @bots
06:16:01 <mbot> :)
06:16:02 <fasta> terminalX: there are Windows users on the mailing lists, though
06:16:10 <yitz> @help
06:16:11 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:16:59 <Zao> bauchus: Enable depth testing?
06:17:28 <terminalX> nah. It's my friends junk not mine
06:17:51 <fasta> How do you search for the use of a record accessor foo in a module containing lots of times the word "foo", but for example also in comments?
06:18:04 <terminalX> just gonna wait till i reach home and boot up my baby and have this code run in minutes
06:18:26 <yitz> @pl \x -> all (length x ==) $ map length x
06:18:26 <mbot> ap (all . (==) . length) (map length)
06:18:36 <fasta> That's about the most important thing I don't like about Haskell on *nix; the crappy tools.
06:18:50 <Zao> bauchus: Consider doing: initialDisplayMode $= [DoubleBuffered, WithDepthBuffer]
06:18:56 <yitz> hmm. sounds like lambdabot. but won't answer /msg. wassup?
06:19:45 <Zao> bauchus: And then also clear the depth buffer at :138
06:20:09 <LoganCapaldo> yitz: you're not identified
06:20:42 * yitz ponders his identity
06:21:19 <Zao> bauchus: Anyhow, it's clipping against the near clip plane. Either move the mesh into the scene, or adjust the near plane a bit.
06:22:24 <Zao> bauchus: If I grok the frustum line right, your near plane is at 1.5 now. Try say 0.1 or so.
06:24:29 <LoganCapaldo> yitz: /msg nickserv identify your_password. If you don't have one /msg nickserv help register
06:26:15 <sioraiocht> erm, how do I solve this message
06:26:16 <sioraiocht> > runghc Setup.lhs
06:26:16 <sioraiocht> Setup.lhs:9:7:
06:26:16 <sioraiocht>     Could not find module `Distribution.Simple.Program':
06:26:16 <sioraiocht>       Use -v to see a list of the files searched for.
06:26:35 <yitz> is lambdabot gone forever?
06:27:13 <dcoutts> sioraiocht: it means the package needs to be updated for cabal-1.2 and probably for ghc-6.8 too
06:27:18 <dcoutts> sioraiocht: what package is it?
06:27:23 <sioraiocht> happy
06:27:24 <bauchus> Zao: thanks for the hints
06:27:32 <dcoutts> sioraiocht: use the latest happy package
06:27:35 <sioraiocht> I'm trying to compile ghc 6.8, and it said I need happy
06:27:46 <sioraiocht> i thought i was...
06:27:55 <dcoutts> sioraiocht: if you got the ghc tarball you don't need happy
06:28:11 <sw17ch> sioraiocht: ghc 6.8 is qualified as a therapist
06:28:48 <LoganCapaldo> ghc uses happy to parse haskell?
06:28:53 <dcoutts> sioraiocht: are you using the ghc-6.8.1 tarball or the darcs version? you almost certainly want to use the 6.8.1 tarball
06:28:59 <sioraiocht> Setup: The program happy is required but it could not be found
06:28:59 <sioraiocht> make[1]: *** [haskell-src/GNUmakefile] Error 1
06:29:00 <sioraiocht> make: *** [stage1] Error 2
06:29:01 <sioraiocht> the tarball
06:29:25 <dcoutts> sioraiocht: the 6.8.1 tarball? that'd be pretty odd
06:29:43 <dcoutts> it should have bundled the pre-generated .hs files and thus not need happy
06:29:48 <sioraiocht> hrm
06:29:56 <dcoutts> sioraiocht: you didn't make distclean or something ?
06:30:10 <dcoutts> sioraiocht: ohh, you're using the extralibs too
06:30:14 <sioraiocht> yes
06:30:15 <sioraiocht> heh
06:30:22 <sioraiocht> should I not?
06:30:26 <dcoutts> sioraiocht: the haskell-src needs happy probably, though ghc itself does not
06:30:31 <sioraiocht> aha
06:31:08 <sioraiocht> i got happy 1.17...that's the newest isn't it?
06:31:12 <dcoutts> yes
06:31:23 <dcoutts> and that depends on cabal-1.2
06:31:47 <sioraiocht> and let me guess, i need darcs to get that? =p
06:31:49 <dcoutts> which comes with ghc-6.8, but also works with older versions of ghc
06:32:03 <dcoutts> no, cabal-1.2.2.0 is on hackage
06:32:07 <sioraiocht> w00t
06:32:11 <dcoutts> and included in ghc-6.8.1
06:32:22 <sioraiocht> ah
06:32:46 <dcoutts> so perhaps it's just simpler to build without the extralibs and then build the ones you need later
06:32:54 <dcoutts> afterall they're all on hackage
06:33:17 <dcoutts> so if you've got cabal-install, you can just:
06:33:18 <dcoutts>  $ cabal install happy
06:33:21 <dcoutts>  $ cabal install haskell-src
06:33:31 <fasta> dcoutts: since when does that work?
06:33:52 <dcoutts> fasta: since cabal-install-0.4.0 which has been on hackage for a week or two
06:33:55 <ToRA|home> dcoutts: do you know anything about:
06:33:59 <ToRA|home> >cabal fetch moo
06:33:59 <ToRA|home> cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
06:34:10 <dcoutts> fasta: it's not perfect or feature complete, we'd like feedback
06:34:37 <dcoutts> ToRA|home: that's with cabal-install ?
06:34:46 <fasta> dcoutts: first suggestion: make --version work
06:34:46 <ToRA|home> yeah
06:35:01 <ToRA|home> dcoutts: it works fine if i do mkdir dist first
06:35:08 <dcoutts> ToRA|home: it's configuring ghc I guess, and that needs a dist dir.
06:35:23 <fasta> dcoutts: since, I have no idea what version is installed now.
06:35:40 <dcoutts> ToRA|home: it was a recent change in cabal, I guess we need to fix cabal-install, please report it at:
06:35:51 <dcoutts> hackage.haskell.org/trac/hackage/
06:36:21 <ToRA|home> dcoutts: will do
06:36:21 <dcoutts> fasta: ^^ please file your feature requests so we do not forget them
06:36:33 <dcoutts> component 'cabal-install'
06:37:04 <pierre-> ToRA: i just managed to get this working
06:37:16 <pierre-> i'll send a patch to cabal soon
06:37:17 <fasta> dcoutts: how to authenticate?
06:37:22 <fasta> dcoutts: can I register?
06:37:28 <fasta> dcoutts: guest guest doesn't work
06:37:31 <ToRA|home> pierre-: ok cool, ta
06:37:42 <dcoutts> fasta: it says: guest haskell'
06:37:44 <dcoutts> iirc
06:38:06 <dcoutts> yes, that's what it says on http://hackage.haskell.org/trac/hackage/
06:38:20 <dcoutts> we should probably make that more prominent
06:38:22 <fasta> dcoutts: doesn't work for me
06:38:42 <dcoutts> fasta: with the ' at the end of "haskell'"
06:39:05 <fasta> dcoutts: oh, I read over that.
06:39:26 <fasta> dcoutts: I am in ;)
06:40:19 <fasta> dcoutts: GHC version field needs to be updated too
06:40:27 <fasta> dcoutts: It doesn't include 6.8
06:40:55 <keseldude> What's a good beginner project to learn haskell? I'm reading YaHT, but I feel that unless I read the whole thing in one day, I won't remember everything from the beginning and I want something to tie it all together.
06:41:31 <sioraiocht> dcoutts: thanks, i think i got it all sorted
06:42:19 <Zao> bauchus: You can take a look at my horrible source at http://www.acc.umu.se/~zao/Hastris-trunk/
06:42:35 <Zao> bauchus: Most of the GL code is in Hastris.hs, FancyUI.hs and Texture.hs
06:42:40 <Zao> Beware of dragons.
06:42:51 <desegnis> keseldude: You may do some Project Euler tasks in Haskell. Maths and Haskell fit together, and once you've solved an Euler problem, you can have a look at other's (Haskell) solutions in the fora
06:43:07 <keseldude> I've thought about that
06:43:32 <jorik808> how fast is haskell ?
06:43:36 <keseldude> In C, for example, the classic thing is to make an address book/calendar
06:43:41 <Zao> jorik808: Quite.
06:43:54 <jorik808> i mean, suppose i wanted to do sound synthesis ... that's like 44100 samples per second
06:44:11 <jorik808> do some processing on them too
06:44:31 <fasta> jorik808: don't you need a real-time OS for that, ideally?
06:44:46 <dcoutts> fasta: ok, ta
06:45:11 <jorik808> fasta: naaah... look at programs like reason, ableton, etc ...
06:45:28 <jorik808> i need something a "bit" like that
06:45:56 <olsner> I think what most sound processing software does is keep a large enough buffer that it doesn't need real-time, just a fast enough computer
06:46:04 <jorik808> the libraries i want to use (DSSI, LADSPA, libsndfile, rtaudio) are all in C/C++
06:46:55 <jorik808> olsner, excactly
06:47:09 <fasta> jorik808: how did you learn about sound algorithms?
06:47:21 <jorik808> so ... iam thinking ... maybe i'll do it in haskell, with greencard
06:47:37 <jorik808> fasta: college
06:47:43 <fasta> jorik808: EE?
06:47:53 <jorik808> i dunno ... im in brussels
06:48:09 <fasta> jorik808: You can tell in Dutch.
06:48:30 <jorik808> computer wetenschappen (software systemen)
06:48:35 <jorik808> aan de VUB
06:48:40 <olsner> sounds like computer science
06:48:55 <jorik808> i have to help some guy who's making his doctoraat
06:49:04 <fasta> jorik808: what book do you use?
06:49:12 <sioraiocht> living in europe has made me realise I am going to have to learn more languages... -_-
06:49:39 <sioraiocht> and this is just more proof =p
06:49:54 <olsner> sioraiocht: I'm on my way to unlearning my native tongue, growing more english by the week
06:50:00 <jorik808> no book lolz, i just talked to him and searched the internet for the libraries
06:50:17 <sioraiocht> olsner: lol, your native tongue is swedish, right?
06:50:22 <olsner> sioraiocht: you too?
06:50:23 <pejo> jorik808, the greencard webpages don't mention anything after 2003. You might be interested in c2hs perhaps?
06:50:26 <fasta> I suspect most sound algorithms are pretty easy, since sound chips can only do a few things.
06:50:29 <jorik808> i don't really need to do the sound "processing" myself, i'll use DSSI and LADSPA as hosts for VST(i)'s
06:51:01 <pejo> sioraiocht, why would you have to learn more languages because you live in europe?
06:51:02 <fasta> It's the mapping from application to chip that's the hard part, I guess.
06:51:15 <sioraiocht> pejo: because I keep encountering people that prefer to speak in french or german
06:51:31 <sioraiocht> pejo: and I only speak English and Spanish, and a smattering of irish and armenian
06:51:53 <jorik808> fasta, not excactly
06:51:53 <pejo> sioraiocht, speak spanish to them, that will teach 'em!
06:52:05 <sioraiocht> lol
06:52:34 <jorik808> fasta: the sound card just takes LPCM (which can be generated with libsndfile, but is basically a stream of samples (= integers))
06:53:09 <fasta> Heh, I don't even know what LPCM is, other than I need to raise PCM to hear anything in ALSA.
06:53:13 <olsner> sioraiocht: but since you already know the three large language groups germanic, romance and slavic (if armenian is slavic and not semitic), so you should be halfway there to speaking everything except finnish and hungarian
06:53:31 <jorik808> fasta, (linear) pulse code modulation
06:54:03 <sioraiocht> olsner: armenian is classified by it's own family, it only descends from older versions of iteslf until you get to i think Proto-IE
06:54:18 <sioraiocht> olsner: but yes, I should be okay learning german and french at some point
06:54:23 <jorik808> sound is basically a wave, at regular intervals (thus the L for linear) you measure the wave. LPCM is a stream of these measurements
06:54:38 <jorik808> although it can carry more channels (eg for stereo)
06:54:49 <olsner> yeah, just found wikipedia... how did you end up learning armenian?
06:54:51 <Zao> In which the samples will be interleaved.
06:55:47 <yitz> and irish is celtic, of course
06:56:08 <fasta> jorik808: c2hs is not as automatic as you would want, though.
06:56:30 <fasta> jorik808: it has been used for lots of C-bindings, OTOH.
06:56:41 <jorik808> ah yes i saw that page too
06:57:00 <jorik808> i don't know why i "decided" on greencard ... maybe because it was hosted on haskell.org
06:57:08 <jorik808> greencard isn't really automatic either though
06:57:15 <jorik808> but it looked pretty nice
06:57:43 <fasta> jorik808: it also probably doesn't work anymore.
06:58:14 <jorik808> haskell changed ?
06:58:26 <fasta> jorik808: no, but implementations do.
06:59:17 <jorik808> i mean if they had something working back in 2003 ... what changed that it doesn't work in 2007 anymore ?
06:59:30 <nominolo> @seen swiert
06:59:30 <mbot> Unknown command, try @list
06:59:46 <fasta> If they wrote everything in H98, then it probably works, but I don't think they did.
06:59:47 <jorik808> if it had been used for lots of C-bindings
07:00:04 <fasta> c2hs been used by lots of C-bindings.
07:00:04 <jorik808> im gunna check it out
07:00:11 <jorik808> aah oh
07:00:15 <nominolo> what's up with lambdabot?
07:01:49 <TomMD> Someone told it to compile prelude - I haven't seen it since.
07:02:25 <nominolo> hm, guess she's busy then ..
07:03:08 <sorear> @bot
07:03:08 <mbot> :)
07:03:14 <sorear-lambdabot> :)
07:03:22 <sorear> oh.
07:03:25 <sorear> sorear-lambdabot: @quit
07:03:40 <nominolo> @list
07:03:40 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:03:48 <nominolo> @help seen
07:03:48 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:04:11 <sorear> @list-all
07:04:11 <mbot> Not enough privileges
07:04:13 <sorear> bah
07:04:18 <sorear> @list dummy
07:04:19 <mbot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
07:04:28 <sorear> @list karma
07:04:28 <mbot> karma provides: karma karma+ karma- karma-all
07:04:35 <nominolo> @help get-shapr
07:04:35 <mbot> get-shapr. Summon shapr instantly
07:05:05 <nominolo> @thx
07:05:05 <mbot> you are welcome
07:05:10 <sorear> nominolo: mbot is a massively stripped-down lambdabot.  pretty much everything but > is disabled, and % is added
07:05:26 <nominolo> %ls
07:05:31 <sorear> % D[Sin[1/x]*x^2, x]
07:05:34 <mbot> sorear: -Cos[x^(-1)] + 2*x*Sin[x^(-1)]
07:05:40 <nominolo> oh, cool
07:05:41 <sorear> three guesses what it does
07:05:56 <nominolo> mathematica shell?
07:06:00 <sorear> yes.
07:06:19 <fasta> Isn't that in breach with the license?
07:06:41 <wli> H98 means no MTL, which kind of defeast the point of using Haskell.
07:07:18 <nominolo> wli: you can encode your preferred monad datatype using functions ;)
07:08:11 <wli> Doing code transformations by hand defeats the point of using a compiler altogether.
07:09:00 <TomMD> sorear: I've patched up a darcs copy of the pcap bindings for 6.8.  Do you want me to send that in, or are you on it?
07:09:26 <sorear> TomMD: I have nothing to do with the pcap bindings.
07:09:33 <TomMD> no?  I must be confused.
07:09:45 <sorear> What name are you looking for?
07:10:12 <TomMD> Nevermind, bos, not sorear.  Doh.
07:15:13 <Karle> hello again
07:15:19 <Karle> hello agin
07:15:31 <sorear> hello!
07:15:32 <sorear> hello!
07:15:51 <Karle> I need help again
07:15:58 <Karle> sorear: Can you help?
07:17:15 <desegnis> Karle: Just type your question and hope that someone will answer.
07:17:47 <Karle> findport::[Pkg] -> [Table] -> [([Pkg],[Pkg])]
07:17:47 <Karle> findport [(t,d,y)]  [a,p]
07:17:47 <Karle>       | ( p == C) = [([t,d,y],[])]
07:17:47 <Karle>       | otherwise = [([],[t,d,y])]
07:18:51 <Karle> type Table = [(Address,Port)]
07:19:16 <Karle> type Pkg = (Pkgtype,Address,Payload)
07:19:22 <sorear> Karle: Why do you have [(t,d,y)] on the second line?
07:20:05 <desegnis> Karle: You only handle one-element lists in findport. Why do you have lists everywhere at all?
07:20:09 <Karle> sorear, because I want to be more specific... since I am comparing one element in Table to C
07:20:30 <Karle> It was assigned by the problem
07:20:33 <sorear> Karle: Well, what if there are multiple elements in the list?
07:21:11 <desegnis> Karle: I still suppose you meant [(a,p)] instead of [a,p]
07:21:40 <desegnis> Hm, that is, I don't suppose still, I suppose right now
07:22:17 <Karle> I changed to [(a,p)]
07:22:27 <Karle> this is the error message
07:22:30 <Karle> *** Term           : [(a,p)]
07:22:30 <Karle> *** Type           : [(a,b)]
07:22:30 <Karle> *** Does not match : [Table]
07:22:47 <Karle> it does not match [Table]
07:23:39 <desegnis> Obviously. You didn't define Table to be like (a,b)
07:25:31 <sorear> Karle: Does findport take a list of tables?  Or just one?
07:27:16 <Karle> sorear , according to findport::[Pkg] -> [Table] -> [([Pkg],[Pkg])]
07:27:38 <Karle> I think so
07:27:44 <psnively> Good morning, Haskellites! Has anyone else had trouble building 6.8.1 from source using 6.6.1 because ld crashes (!) with a bus error after compiling Parsec's Token file?
07:27:56 <sorear> Karle: I mean I think you got the type signature wrong
07:28:28 <sorear> psnively: bus errors in ld?  sounds like a hardware problem.  If you try again, does it crash in the same place?
07:28:46 <psnively> Yes, it's consistent. And yes, it's weird. :-)
07:28:54 <Karle> sorear , no [] for Table?
07:28:57 <Saizan_> psnively: i had problems with ld since it used so much memory that it got killed, solved with SplitObjs = NO in mk/build.mk
07:29:17 <psnively> Saizan_: Huh. OK, thanks.
07:29:31 <olsner> bus error is the same as a segmentation fault on some platforms
07:29:31 <sorear> Karle: I was thinking [Pkg] -> Table -> [([Pkg],[Pkg])], yes.
07:30:09 <psnively> olsner: Right. This is PPC G4. 32-bit.
07:30:31 <Karle> that was from the hint of the problem.... :) I think so that I gotta change
07:30:41 <psnively> Saizan_: So, er... cp mk/build.mk.sample mk/build.mk, then add "SplitObjs = NO" somewhere?
07:31:01 <olsner> oh, bus error is also pointer alignment error on platforms where that matters (and I think PPC is one of them)
07:31:49 <psnively> Nah, the PPC just gets slow on misalignments. You're thinking of its predecessor, the venerable 680x0 family. :-D
07:32:25 <pejo> psnively, are you building as root or a user? (is this macos x?)
07:32:48 <Karle> thanks for the help
07:32:50 <psnively> It is Mac OS X. Building as me (Administrative user, but not root).
07:33:56 <pejo> psnively, could you be running out of your user limits perhaps? "ulimit -a" lists them, but I'm not sure how to increase them.
07:34:20 <psnively> I guess that's possible, but it doesn't seem likely.
07:34:48 <Saizan_> psnively: yes
07:34:51 <psnively> Hmmmm... should I set SRC_HC_OPTS to use -H64m?
07:34:55 <pejo> Well, either that or the splitobjs workaround as Saizan suggested.
07:35:10 <psnively> What does SplitObjs do, actually?
07:36:10 <Saizan_> SplitObjs = NO Object splitting causes each module to be split into smaller pieces in the final library, to reduce executable sizes when linking against the library. It can be quite time and memory-consuming, so turn it off when you're hacking.
07:36:21 <Saizan_> from http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking
07:36:40 <psnively> OK, thanks!
07:36:49 <psnively> Any idea what reasonable ulimit settings would be?
07:38:08 <shapr> Lemmih: pong
07:38:22 <psnively> Morning, shapr!
07:38:37 <TomMD> @localtime psnively
07:38:38 <mbot> Local time for psnively is 2007-11-04 07:38:37 -0800
07:38:52 <psnively> :-D
07:38:57 <b_jonas> @search Control.Monad.Error
07:38:58 <mbot> Unknown command, try @list
07:39:00 <TomMD> US West coast?  Good pick.
07:39:01 <b_jonas> @list
07:39:01 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:39:19 <b_jonas> @hoogle Control.Monad.Error
07:39:20 <mbot> http://cvs.haskell.org/Hugs/pages/libraries/mtl/Control-Monad-Error.html
07:39:47 <psnively> Kind of a weird arc: first I went to Silicon Valley, then to Los Angeles.
07:40:18 <TomMD> Well, it isn't Oregon, but I forgive you.
07:40:40 * wli is in PDX
07:41:08 <TomMD> wli: I envy you.
07:41:20 <psnively> The Oregonians hate it when Californians move up there. ;-)
07:41:40 <TomMD> So do us Idahoans ;-)
07:43:01 <psnively> You guys can't even buy your own potatoes. Feh. :-)
07:45:00 <psnively> OK. So if I sudo build this, does my potential ulimit problem go away? Or do I still need to look at my ulimits?
07:45:55 <shapr> Good morning psnively
07:46:23 <psnively> Yo!
07:46:26 <pejo> psnively, no ulimit problems if you sudo. (I think the default ones are sane usually)
07:47:35 <psnively> sudo ulimit -s 65535
07:47:52 <mauke> what the
07:47:58 <psnively> ulimit: stack size: cannot modify limit: Invalid argument
07:48:07 <pejo> psnively, that doesn't propagate down to "your" shell, unfortunately.
07:48:18 <psnively> Oh. Heh.
07:48:50 <pejo> (I just had a fight with the same thing, I ended up su:ing back to myself after sudo:ing bash and fixing the ulimit manually. I'm sure there is a correct way to do this).
07:48:51 <psnively> sudo -s, then ulimit?
07:49:00 <psnively> OK
07:49:16 <Zao> ulimit only changes the limits of the currently running shell.
07:49:52 <Zao> I usually just set my limits from the .tcshrc
07:49:59 <psnively> OK, I sudo -s, ulimit -s 65535, and now ./configure && make -j2
07:50:09 <psnively> Wish me luck. :-D
07:50:48 <Notrix> is it good style to use $ instead of a huge amount of brackets ?
07:51:28 <mauke> the official #haskell style is foo . bar . baz $ x
07:51:51 <mauke> s/the official #haskell/my/ :-)
07:52:02 <olsner> an excessive amount of $ is also ugly, so it's really just a matter of taste
07:52:14 <psnively> I thought pointless was the official style. ;-)
07:52:22 <mauke> oh, right
07:52:59 <olsner> let fooTheBaredBazOf = foo . bar . baz in fooTheBaredBazOf x
07:55:18 <petekaz> Does anyone have a link to the recent intro to haskell cartoon/comic?
07:56:15 <psnively> Morning, ddarius!
07:56:40 <shapr> mmm, applicative functors
07:56:50 <wli> I thought the official #haskell style was monad transformer stacks.
07:57:41 <olsner> monad transformer stacks?
07:57:49 <mauke> http://quotes.burntelectrons.org/3046
07:58:07 <ddarius> psnively: Morning
07:58:40 <TomMD> @quote simonpj
07:58:40 <mbot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
07:58:41 * psnively has his mind blown by "Lightweight monadic regions in vanilla Haskell."
07:58:58 <psnively> Er... but he did it anyway?
07:59:15 <TomMD> @quote simonpj
07:59:15 <mbot> simonpj says: You may not like this but this should work..
07:59:31 <fasta> @quote simonpj
07:59:31 <mbot> simonpj says: You may not like this but this should work..
07:59:37 <fasta> @quote simonpj
07:59:37 <mbot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
07:59:37 <Saizan_> psnively: oleg paper?
07:59:52 <psnively> Saizan_: Of course. :-D
08:00:09 <swiert> @seen lispy
08:00:09 <mbot> Unknown command, try @list
08:00:22 <swiert> hmm. What happened to lambdabot?
08:01:03 <TomMD> As I said before: it is busy compiling the prelude, so look for it next weekend.
08:09:03 <b_jonas> there are so many lambdabot clones running out there that I doubt it would be a problem
08:10:14 <ddarius> ... until they attack!
08:11:29 <b_jonas> I like bots
08:12:04 <ddarius> Maybe they'll keep you as a lapdog.
08:12:26 <b_jonas> :)
08:13:05 <b_jonas> I prefer imagining myself as the commander of a bot army than a lapdog.
08:15:05 <olsner> that's just what they want you to believe!
08:15:15 <conal> i wonder why packCStringLen became an IO function in 6.8.1.  Anyone here know?
08:16:01 <mauke> @index packCStringLen
08:16:01 <mbot> Unknown command, try @list
08:24:09 <doserj> http://www.nabble.com/Unsafe-aspects-of-ByteString-t3132078.html
08:25:09 <dcoutts> doserj: hmm?
08:25:23 <dcoutts> doserj: those issues are fixed in the current bytestring package
08:25:58 <Saizan_> a perf build of ghc should compile the libraries with -O2, right?
08:27:08 <dcoutts> Saizan_: -O2 is not always necessary, -O is the default for distribution builds in cabal
08:27:47 <doserj> dcoutts: that was a reply to conal's question
08:27:51 <dcoutts> -O2 has a bunch of more experimental optimisations which help some code but it takes a lot longer to compile and can give more code bloat
08:27:55 <psnively> But I think the standard libraries build more aggressively, right?
08:27:56 <dcoutts> doserj: oh ok
08:29:06 <Saizan_> dcoutts: well, it's just that i have a program that runs 30% slower if compiled with 6.8.1, so i wanted to make sure everything was optimized as much as it can
08:29:34 <Saizan_> 6.8.1 compiles it much faster, btw
08:29:53 <dcoutts> Saizan_: and you've tried building your own app with -O and -O2 and tried -fvia-C ?
08:29:59 <Saizan_> yes
08:30:13 <dcoutts> did -fvia-C make any difference?
08:30:17 <Saizan_> no
08:30:18 <TomMD> And I get almost 50% better performance out of 6.8.1 on one of my programs :-)
08:30:40 <Saizan_> dcoutts: it's mtl+array code
08:30:55 <b_jonas> this at least shows that ghc is actively developped
08:31:15 <psnively> Someone thought GHC wasn't actively developed???
08:31:28 <b_jonas> no
08:31:36 <dcoutts> b_jonas: there are 3 full time devs and dozens of active helpers
08:32:01 <b_jonas> that's good
08:32:27 <dcoutts> Saizan_: I'm not sure what the default is for the ghc boot libs, if it's -O or -O2. I can check in a min.
08:32:49 <Saizan_> thanks
08:54:06 <conal> doserj: thanks.  just noticed your link about packCString.
08:58:41 <conal> oh -- wait.  in the last note (by dons) in http://www.nabble.com/Unsafe-aspects-of-ByteString-t3132078.html, i read "The following will be safe, copying across the C/Haskell boundary by default: packCString :: CString -> IO ByteString; ...".  If copied, why IO?
09:00:49 <doserj> because it depends on the time when you copy
09:02:23 <conal> doserj: oh, of course.
09:05:14 <olsner> @quote
09:05:14 <mbot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
09:05:40 <wli> Hagfish are scarier.
09:05:55 <wli> At least as far as agnathans go.
09:06:41 <newsham> ?where+ weapons http://www.coxar.pwp.blueyonder.co.uk/
09:06:41 <mbot> Nice!
09:08:28 <olsner> "An adult hagfish can secrete enough slime to turn a large bucket of water into gel in a matter of minutes."
09:09:17 <wli> Also witness the way they attack their prey.
09:09:30 <TomMD> "An adult Haskell programmer can use enough libraries to turn off all potential users in a matter of minutes."
09:09:55 <TomMD> s/user enough libraries/add enough dependencies
09:10:15 <Botje> dependencies are only a problem until cabal can resolve them.
09:10:41 <Botje> (speaking of which: is there a place where I can follow said cabal extensions?)
09:10:47 <TomMD> Will CABAL ever be able to solve non-Haskell dependencies?  I doubt it.
09:11:18 <Botje> that depends on the OS, of course
09:11:36 <Cale> TomMD: yeah, but it solves the problem with Haskell users and dependencies ;)
09:11:40 <TomMD> Exactly, a binding libraries dependence on the 'c' libraries existence for headers is just an open issue.
09:12:10 <newsham> i think there are plans for free F# clinics for recovering Haskell dependency
09:12:24 <Cale> I suppose that cabal could be programmed to deal with various distributions packaging systems.
09:12:38 <Cale> (like apt/emerge/etc.)
09:13:01 <TomMD> It makes me wonder if someone should build an apt like tool for Windows.
09:13:13 <Cale> Microsoft should, it's their OS.
09:13:29 <wli> AIUI Microsoft has to some extent.
09:13:41 <TomMD> Well, I was thinking more like one to install misc. open source applications.
09:14:46 <Arnia> Hm... I'm not happy with this paper. I've tried to use category theory to provide a semantics for RDF but I don't think I've explained it properly (the possible retort being that it is impossible to explain the use of category theory in a way people who haven't studied it can understand)
09:15:17 <Arnia> Don't suppose there are willing victims... err... reviewers here?
09:15:17 <dcoutts> Cale: there are tools to generate distro packages from cabal packages
09:15:18 <Cale> Ah, so omnId = nmessenger!
09:15:21 <psnively> Nor is it clear that RDF has a category-theoretic semantics.
09:15:26 <dcoutts> for at least, ebuild, rpm, deb
09:15:33 <Cale> dcoutts: which is pretty nice
09:15:36 <olsner> is that RDF as in the xml format under RSS?
09:16:18 <Cale> dcoutts: I think TomMD was referring to the other direction of interaction, where Cabal would use apt/etc. to install required C library packages.
09:16:19 <idnar> RDF/XML is just a particular serialization of RDF :P
09:16:32 <TomMD> Cale: Correct.
09:16:34 <dcoutts> Cale: ah yes
09:16:38 <Arnia> idnar: indeed
09:16:39 <dcoutts> that's a bit harder
09:16:44 <Cale> yeah
09:16:45 <Arnia> idnar: and hardly the nicest one
09:17:15 <dcoutts> Cale, TomMD: first thing is to make cabal packages declare the common name of the foreign packages they depend upon
09:17:24 <Arnia> (ironically my supervisor was part of the RDF working group and now he is encouraging me to tear up the work he did... not quite sure what to make of that)
09:17:46 <dcoutts> Cale, TomMD: then have some distro-specific mechanism of mapping those to native packages
09:18:04 <dcoutts> doing it automatically is probably too hard to do accurately
09:18:23 <Arnia> psnively: well, I've diverged from the model-theoretic semantics of RDF in some places but I think such divergences are 'minimal' (in the sense that they make it more coherent whilst breaking as little as possible)
09:18:36 <newsham> it seems kind of silly to make cabal do so much
09:18:53 <david__> hi all! I'm looking for how to call an haskell function from C. I've looking around but I can't understand the best method and the one still supported. can someone help me please? tnx!
09:18:57 <Arnia> psnively: I'm trying to eliminate the semantic layer cake we have going on atm with OWL having an entirely different semantics to RDF
09:19:06 <TomMD> newsham: It seems kind of silly to make the user do it instead.
09:19:10 <Arnia> (whilst also breaking the dependency on set theory)
09:19:40 <newsham> tommd: so you think its less silly to have every build platform know about every package management scheme on every operating system?
09:19:49 <mauke> david__: in what context? is your main program still in haskell?
09:19:51 <sorear> @where ffi
09:19:51 <mbot> I know nothing about ffi.
09:20:09 <psnively> Arnia: Good luck with that. :-)
09:20:12 <david__> mauke: no. my main program is in C (or C++)
09:20:28 <david__> in haskell I've only a function (for now)
09:20:35 <psnively> And what's wrong with set theory?
09:20:42 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
09:20:42 <LoganCapaldo> I think that if something like this were to be done It would make more sense for the debian people to mod cabal to be apt aware, teh gentoo people to mod cabal to be portage aware, etc. etc.
09:20:46 <newsham> what could possibly go wrong?
09:20:58 <LoganCapaldo> not that that would ever happen
09:21:12 <TomMD> newsham: There is room yet for a common tool with a common naming scheme for packages.
09:21:50 <Skyp> Hello ;) I have a probably stupid problem with the haskell type system... What am I missing here: http://nopaste.com/p/aaZSRSznp
09:21:53 <Arnia> psnively: they're defined extensionally
09:21:54 <david__> mauke: tnx :) I have a try!
09:22:35 <newsham> tommd: and what if I have software packages installed outside of the package managemetn system?
09:22:39 <sorear> Skyp: should be 'type Elem = Char'
09:22:56 <sorear> Skyp: 'data Elem = Char' defines a singleton type whose only member is named Char
09:23:04 <Arnia> I have a problem where I have partial evidence from multiple sources with different weights which is a combination of both intentional and extensional knowledge and which varies from perspective to perspective in a non-accessible fashion (i.e. it is relativist not objectivist)
09:23:10 <TomMD> newsham: I wouldn't expect the build systems grabbing of foreign packages to be a default thing.
09:23:19 <Skyp> sorear: ok, hm... the problem is, I want to have "data Elem = Char | Blank" there later
09:23:26 <newsham> tommd: how do you plan to get redhat and debian and freebsd ports and openbsd ports and * to all use the sam epackage names?
09:23:43 <mauke> Skyp: no, you want data Elem = SomeChar Char | Blank
09:23:45 <sorear> Skyp: Would that contain 'a', 'b', 'c', ... and blank?
09:23:55 <Skyp> right
09:23:57 <newsham> "hi, redhat, I know you already have names for your packages, but could you kindly change them all?"
09:23:58 <TomMD> newsham: It would have to be a different namespace.
09:24:01 <mauke> also known as type Elem = Maybe Char
09:24:03 <sorear> Skyp: what mauke said
09:24:06 <psnively> Arnia: Ah so. Sounds like a good situation for a Bayesian Belief Net. :-D
09:24:18 <LoganCapaldo> for them to all have the same names all their packages would also have to hve the same granularity
09:24:39 <newsham> each tool should do one thing and one thing well.
09:24:43 <Skyp> hm, if I have "data Elem = Foo Char | Blank" it gives me the same error
09:24:45 <LoganCapaldo> even if it was in a seperate namespace
09:24:45 <newsham> installing debians is not cabals strong point
09:24:58 <TomMD> newsham: Its just a translation table.  Data.Map.Map CommonPackageName [(Distro, Distro Name)]
09:25:21 <newsham> tommd: ahh, i had no idea it was so simple.
09:25:24 <Arnia> psnively: no, alas not. Bayesian inference doesn't account for different evidence weights (i.e. a belief which is based on ten tests should be weighted less than one which is based on a hundred) For this you need two-component truth values.
09:25:24 <mauke> Skyp: because 'x' has type Char, not Elem
09:25:26 <newsham> nevermind then, I remove all of my objections
09:25:56 <LoganCapaldo> again that assumes 1 to 1, some packaging systems break things up more, others glob more stuff into the same package
09:26:09 <newsham> even redhat has trouble keeping track of redhat packages
09:26:10 <Skyp> mauke: ok, but what is the "SomeChar Char" good for, if 'x' is not accepted?
09:26:21 <newsham> I fail to see how cabal maintainers or haskell package maintainers are going to do it
09:26:22 <sorear> Skyp: SomeChar 'x' is
09:26:28 <TomMD> newsham: I am assuming plenty, I know.  like a) distro has that package  b) distros package name won't change too much c) distro has a command line install tool like apt/emerge/yum etc etc.
09:26:29 <mauke> it's for making branch of Elem that can store a Char
09:26:34 <mauke> you still have to call the constructor
09:26:42 <diotalevi> So how well does a GHC program compare to a C++ when most of the work is doing sums and set lookups. You know, for instance, perl is a about two orders of magnitude slower. How's GHC?
09:27:10 <Skyp> Ok, I begin to understand... thanks!
09:27:21 <sorear> diotalevi: Benchmark it.  (My money is on one-order-of-magnitude, but I have no numbers)
09:27:22 <psnively> Arnia: Hmmm. No weighted Bayesian Belief Nets? If you say so...
09:27:30 <Arnia> psnively: unfortunately there is little agreement on inference rules for such systems. So I'm trying to build my own set of rules from first principles. Not easy and I have 17 months left
09:27:44 <psnively> Arnia: I see. Sounds interesting!
09:27:46 <Arnia> psnively: Pei Wang (who has done the most research in this field) has a nice paper explaining why
09:28:02 <psnively> Nice!
09:28:24 <diotalevi> sorear, I just want to know the rule of thumb. I'd rather not benchmark the difference now.
09:28:52 <ddarius> diotalevi: The difference depends largely on you.
09:29:17 <diotalevi> Ok?
09:29:32 <diotalevi> I define it as being infinitely faster. Huzzah!
09:29:46 <newsham> dio: thank you!
09:29:48 <glguy>  When trying to build ghc 6.8.1 I get the following error when building parsec: http://mult.ifario.us/articles/2006/10/17/ghc-6-6-and-mac-os-x-readline-quick-fix
09:29:51 <glguy> hmm
09:29:55 <glguy> collect2: ld terminated with signal 10 [Bus error]
09:30:10 <glguy> Anyone know what causes such an error
09:30:13 <sorear> someone already complained
09:30:19 <sorear> go talk to @bug
09:31:02 <sioraiocht> anyone had any problems with GHCi 6.8.1
09:31:03 <sioraiocht> ?
09:31:20 <newsham> sior: yah, crashes for me in freebsd/amd64.. but thats to be expected
09:32:12 <psnively> glguy: I have that problem as well.
09:33:06 <glguy> @bug
09:33:06 <mbot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:33:10 <sioraiocht> newsham: it does for me too
09:33:23 <sioraiocht> Loading package base ... linking ... ghc-6.8.1: unable to load package `base'
09:33:26 <sioraiocht> i'm in leopard
09:33:44 <puusorsa> poor cat
09:33:49 * psnively is also in Leopard, on 32-bit PPC.
09:34:00 <sioraiocht> psnively: same problem?
09:34:23 <psnively> Yes, trying to link Token in Parsec.
09:34:24 <newsham> sio: different type of issue.
09:34:29 <sioraiocht> ah
09:34:31 <sioraiocht> well
09:34:32 <sioraiocht> :(
09:34:35 <ddarius> puusorsa: Why would it be poor for a cat to have it's belly full?  Except digesting a computer is probably difficult.
09:35:04 <puusorsa> oh, belly .. somehow i thought you were refering to the other end of its digestive tract..
09:35:19 <david__> sioraiocht: I use ghc 6.6.1 on leopard
09:35:26 <sioraiocht> 6.6.1 works fine
09:36:01 <sioraiocht> really, i'm curious
09:36:07 <sioraiocht> is this issue my fault or shoudl I report it/complain
09:36:09 <darinm> sioraiocht: I get the same error
09:36:12 <sioraiocht> okay
09:36:16 <david__> I've tried to compile 6.8.1 few weeks ago on leopard beta but it didn't compile
09:37:00 <raxas> sioraiocht: only problem I had so far with ghci 6.8.1 on linux/amd64 is missing ascii art logo :)P
09:37:06 <david__> but i didn't investigate a lot... because I found a working 6.6.1
09:37:24 <darinm> so are there any reports of people getting 6.8.1 to work at all on leopard?
09:37:48 <darinm> actually, compiling with ghc works for me, just ghci doesn't load
09:38:17 <sioraiocht> darinm: same here!
09:38:22 <david__> are you compiling by hands or via port?
09:38:49 <darinm> by hand.  I don't think there is a macport 6.8.1 yet, is there?
09:38:51 <david__> because in port you can fine a 'devel version'. you can try
09:38:53 <newsham> by hand?  that would be a lot of work, takes my cpu hours ;-)
09:39:15 <darinm> yeah but devel version is different
09:39:38 <david__> http://ghc-devel.darwinports.com/
09:39:42 <david__> is a 6.7
09:39:45 <david__> sorrry
09:47:05 <Karle> hi
09:51:21 <|Steve|> Is there something wrong with lambdabot? It's not responding to me.
09:51:36 <|Steve|> @pl \f g x -> (f (g x), g (f x))
09:51:37 <psnively> Lambdabot is indexing the new prelude.
09:51:37 <mbot> ap (ap . (liftM2 (,) .) . (.)) (flip (.))
09:51:43 <|Steve|> Ah, there we go.
09:51:52 <|Steve|> Oh, that's mbot. heh
09:51:52 <allbery_b> guess that answers that question (sort of)
09:51:54 <psnively> Oh. :-)
09:53:15 <Olathe> @src (+)
09:53:15 <mbot> Source not found. Where did you learn to type?
09:53:38 <sioraiocht> from your mom, mbot
09:54:01 <newsham> ?vixen from your mom
09:54:01 <mbot> Unknown command, try @list
09:54:06 <newsham> aww
09:54:31 <Olathe> You've failed me for the last time, mbot !
09:54:32 <TuringFlunkee> bitchfight with a bot, not a good idea
09:54:34 <Olathe> @where botdeath
09:54:34 * mbot dies.
09:55:07 <TuringFlunkee> @src Prelude
09:55:07 <mbot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:55:22 <phlpp> @src flip
09:55:23 <mbot> flip f x y = f y x
10:01:04 <ari> ?users
10:01:04 <mbot> Unknown command, try @list
10:01:58 <TuringFlunkee> @src foldr
10:01:58 <mbot> foldr k z xs = go xs
10:01:58 <mbot>     where go []     = z
10:01:58 <mbot>           go (y:ys) = y `k` go ys
10:03:34 <Cale> TuringFlunkee:
10:03:39 <Cale> foldr f z [] = z
10:03:51 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
10:04:52 <Cale> foldr f z can be seen as replacing the list constructors (:) and [] with f and z respectively.
10:05:08 <fasta> I want to generate some Haskell code that is essentially a serialization of a run-time value. What's the best way to do that?
10:06:12 <newsham> Show?  Binary?
10:06:30 <allbery_b> suppose that depends on what you want to do with the serialized value, and what kind of value it is
10:06:33 <Lycurgus> Cale: thanks.
10:06:33 <fasta> newsham: It's a structure based on STRef.
10:06:44 <ddarius> foldr (+) z [] = z; foldr (+) z (x:xs) x + foldr (+) z xs
10:06:55 <fasta> allbery_b: I just want to execute that value such that I can test it in isolation.
10:06:57 <ddarius> +=
10:07:09 <newsham> fasta: can you make a Show/Read instance for it?
10:07:29 <Cale> fasta: you mean you want to serialise thunks?
10:07:35 <fasta> newsham: by definition, no.
10:07:43 <fasta> newsham: It's a value that only exists in the ST monad
10:07:57 <fasta> Cale: no
10:08:13 <ddarius> fasta: It's completely unclear what you are trying to do.  "execute that value" makes no sense.
10:08:15 <Cale> ah, okay, so it's some datastructure put together with STRefs
10:08:32 <Cale> well, you can write an ST computation for serialising/deserialising it.
10:08:49 <Cale> It's about as hard as serialising a graph structure in an imperative language.
10:09:01 <fasta> Cale: yes, I know that, but I need to generate code for doing so.
10:09:06 * allbery_b wonders if needing to sneak something out of an ST indicates "you're doing it wrong"
10:09:17 <Cale> allbery_b: not necessarily.
10:09:30 <ddarius> allbery_b: It can be fine.
10:09:44 <allbery_b> can be, yes.  hence "wondering"
10:09:46 <fasta> Cale: I can generate a string, but I might also use some library.
10:10:00 <fasta> Cale: but code generation based on strings is rather ....
10:10:41 <ddarius> Okay, so you want to generate serialization code?
10:10:42 <Cale> I don't think any library currently exists which does that. It's sort of a neat idea though. Maybe something combining Data.Generics with ST
10:11:53 <fasta> ddarius: I want a function with type MyRefBasedStructure -> ST s String, where the String can be pasted into a Haskell file and executed to get the same structure binded to some monadic variable.
10:12:00 <|Steve|> @pl \f x -> (x, f x)
10:12:00 <mbot> ap (,)
10:12:11 <|Steve|> > ap (,) (5+) 6
10:12:38 <ddarius> fasta: That's a lot clearer than what you were saying earlier.
10:12:40 <|Steve|> Hello computer?
10:12:55 <fasta> ddarius: to me it seemed obvious, but obviously it wasn't.
10:12:57 <ddarius> mbot /= lambdabot
10:13:00 <Cale> ah, okay, so you actually want to generate Haskell code proper
10:13:00 <|Steve|> mbot doesn't like me.
10:13:10 <phlpp> > putStrLn "Hi"
10:13:14 <phlpp> :>
10:13:14 <|Steve|> ddarius: Maybe not, but mbot normally likes my haskell.
10:13:16 <Cale> Not just some string together with a Haskell function for reconstructing the value.
10:13:32 <Cale> |Steve|: hs-plugins doesn't work with 6.8.1
10:13:35 <|Steve|> <mbot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
10:13:38 <|Steve|> Ah.
10:13:51 <fasta> Cale: I want a more efficient program to generate the same structure.
10:14:01 <|Steve|> Well, when I try using ap (,) it doesn't work at all for me in hugs.
10:14:13 <fasta> Cale: currently it takes 5 minutes to create that structure, because it's an intermediate value.
10:14:28 <Cale> |Steve|: Import Control.Monad.Reader or Control.Monad.Instances
10:14:58 <fasta> Cale: I just want to have that value in isolation, so that I can correct an error.
10:15:02 <|Steve|> Cale: Ah, thanks.
10:15:47 <Cale> fasta: I have to run, but it's a neat idea. I might try putting something together when I get back.
10:16:08 <fasta> Cale: I doubt you can make something useful in less than a day.
10:16:57 <ddarius> fasta: It is still basically serializing the reference graph.  Using mdo and using the TH AST or some other it should be pretty straightforward to do.
10:17:52 <fasta> ddarius: in the special case of a tree, ok, but the general case is not that trivial.
10:18:23 <ddarius> fasta: I said "graph" and it isn't as trivial as a tree, but it's still well-known how to handle it and not difficult.
10:18:34 <fasta> ddarius: that only works if you know the graph, right?>
10:18:51 <fasta> ddarius: given a bunch of references: how do you find the graph?
10:19:26 <ddarius> All you have to do is traverse the data structure keeping track of which references you've seen (or if you can somehow marking them as "null")
10:19:26 <fasta> Hmm, actually, that's not so difficult.
10:20:10 <fasta> The problem is that references can only be compared for equality.
10:20:18 <fasta> It's going to be one inefficient mess.
10:21:09 <newsham> watching hughes/quickcheck/erlang talk.  it strikes me that he's spending most of his time demonstrating how hard it is to write specifications ;-)
10:21:39 <ddarius> fasta: If you can mark them as "visited" somehow, then it becomes linear in the number of nodes.
10:22:22 <fasta> ddarius: "somehow"
10:22:27 <fasta> ddarius: that's the problem
10:23:20 <twanvl> You could try making a small wrapper around STRef and the ST monad that gives each reference a unique integer
10:23:20 <ddarius> If you have some value that you know doesn't occur then you can have the STRef point to that.
10:23:39 <fasta> twanvl: I proposed that already
10:23:48 <fasta> twanvl: it was rejected
10:24:04 <fasta> twanvl: and thus your solution currently isn't a general solution
10:25:01 <fasta> ddarius: ok, that sounds like a hacky solution (better than nothing)
10:25:18 <fasta> Still, not completely general
10:25:39 <twanvl> fasta: you mean because you can no longer use normal STRefs?
10:25:44 <ddarius> The only way twanvl's idea is not "completely general" is that it requires you to change the format.
10:25:58 <fasta> twanvl: right
10:26:04 <twanvl> that could be just a matter of changing two imports
10:26:11 <ddarius> You can use normal STRefs you just have them reference a (Int,A) instead of just A
10:26:40 <ddarius> Similarly the approach of marking nodes as "visited" could be done by referencing a Maybe A or (Either A A) instead of just A.
10:26:51 <fasta> twanvl: I think it are more than two imports, but otherwise, yes.
10:27:32 <ddarius> You could also use StablePtrs or something convertible to IntPtr which should be Ord.
10:27:41 <ddarius> (or close enough to it)
10:27:54 <fasta> " it's still well-known how to handle it and not difficult." <- it doesn't seem like it.
10:28:27 <ddarius> fasta: It's extremely well-known and tricky but not hard how to serialize a graph structure.
10:28:30 <taruti> Does GHC 6.8.1 support creating shared libraries on x86-linux?
10:28:40 <fasta> ddarius: It's not about the graph structure.
10:28:50 <fasta> ddarius: It's about _getting_ the graph structure.
10:29:10 <ddarius> The data structure -is- the graph structure.
10:29:35 <ddarius> You want to do it efficiently using a data structure that isn't set up for it and are unwilling to change it.
10:29:48 <twanvl> fasta: does the thing pointed to by the STRef support Ord?
10:29:53 <fasta> ddarius: yes, that was the problem specification.
10:30:16 <fasta> twanvl: yes, but you cannot use that.
10:30:34 <fasta> Changing the problem usually makes it easier.
10:30:36 <twanvl> you could make a  Map a [(STRef a,Int)]
10:30:45 <fasta> twanvl: what would that solve?
10:30:59 <david__> do you know why for all my "foreign export" I get the "Invalid type signature" error? sould I import some library?
10:31:01 <fasta> twanvl: non-unique Int?
10:31:10 <twanvl> a unique int
10:31:25 <ddarius> fasta: It's not the specification you were saying telling us and further if that's the case, then the problem is the same as trying to make fast dense matrices using lists of lists.  The wrong data structure is the wrong data structure.
10:31:25 <mauke> david__: what's the type signature?
10:31:26 <twanvl> The simple way would be [(STRef a, Int)]
10:32:09 <david__> mauke: I'm trying some example from the documentation like: foreign export ccall foo :: Int -> IO Int
10:32:12 <newsham> is the data structure large enough that serializing efficiency is important?
10:32:29 <twanvl> then looking up an STRef takes O(n) time, making the total serialization O(n^2)
10:32:33 <newsham> can you walk it once using Eq to build up an efficient graph repr and then serialize on that?
10:32:44 <david__> I think i miss something. sould I run it with ghci?
10:33:18 <ddarius> newsham: Why wouldn't you just serialize it in that first walk anyway?
10:33:18 <mauke> david__: did you enable FFI support?
10:33:20 <newsham> O(n^2) isnt an issue when n is small :)
10:33:32 <mauke> because "foreign" isn't a keyword in H98
10:33:44 <david__> mauke: emm.. this is a good question... I took a pre-compiled package :'(
10:34:01 <mauke> huh? how can you get compile errors if it's already compiled?
10:34:17 <newsham> could you tag your objects in a way that makes them Ord?
10:35:00 <david__> ok.. I just try to compile ghc with FFI support! .... ufff :'(
10:35:08 <mauke> whu?
10:35:19 <mauke> just put something like {-# LANGUAGE ForeignFunctionInterface #-} at the top of your source file
10:35:30 <mauke> or {-# OPTIONS_GHC -fffi #-}
10:35:44 <Saizan_> ghc has FFI support by default, you just have to enable FFI when compiling your program
10:36:07 <ddarius> newsham: If the data structure could be changed, the most efficient and also simplest thing to do would be to add a visited bit.
10:36:11 <david__> yeah ;)
10:36:29 <newsham> ddarius: if you can mutate.  ord would be decent even if you cant mutate
10:36:45 <Karle> hi
10:36:46 <ddarius> newsham: The structure is clearly mutable.
10:37:11 <twanvl> ddarius: just a visited bit is not enough
10:37:13 <david__> it works !!!! tnx!! :D
10:37:20 <newsham> twanvl: why not?
10:38:42 <twanvl> you need a way to make two references point to the same cell, so that cell needs to be identifyable
10:39:02 <ddarius> Indeed, for serializing you need more than a visited bit, but simply an Int would be fine
10:39:39 <ddarius> (at least if you want to have a "one" pass approach)
10:44:29 <SamB> hmm?
10:44:33 <SamB> what more is needed?
10:52:20 <dfranke> oh yay, looks like the siege is over.
10:56:25 <SideFFect> ahh finally, the haskell channel
10:56:29 <dons> welcome!
10:56:50 <thetallguy> welcome, even with a handle like that!
10:57:03 <SideFFect> me? lol
10:57:11 <dons> :)
10:57:17 <thetallguy> Like a red flag to a bull.
10:57:28 <SideFFect> is this the right place to get haskell help? its been driving me crazy :(
10:57:35 <SideFFect> well, syntactically at least
10:57:36 <thetallguy> It is
10:57:52 <thetallguy> fire away
10:58:10 <SideFFect> alright, well, my assignment for school is to make a binary search algorithm
10:58:19 <SideFFect> he gave us the search algo in imperitive style
10:58:21 <thetallguy> don't even bother to ask if anyone can answer a question, just sign on and post
10:58:45 <SideFFect> and we have to implement it in haskell, but in the SAME style as its written in imperitive
10:58:50 <SideFFect> (heh I will next time)
10:58:53 <thetallguy> oogh
10:59:14 <mauke> pull out the IORefs!
10:59:15 <dons> well, there's not that many ways to do binary search anyway
10:59:18 <SideFFect> I got it declared, the types are set, what it inputs/outputs is set...empty list is taken care of
10:59:20 <mauke> huhu
10:59:25 <SideFFect> but I think its my thought process
10:59:29 <SideFFect> and heh I know
10:59:32 <salierix> Morning.
10:59:51 <SideFFect> can I paste what I have so far?
10:59:53 <mauke> SideFFect: you probably have a loop and variables whose values change in the loop
11:00:00 <thetallguy> hpaste.org
11:00:10 <dons> ?paste :)
11:00:10 <mbot> Haskell pastebin: http://hpaste.org/new
11:00:39 <SideFFect> module Bsearch
11:00:39 <SideFFect> 	where
11:00:39 <SideFFect> bsearch :: Integer -> [Integer] -> Integer
11:00:39 <SideFFect> bsearch _ [] = -1
11:00:39 <SideFFect> bsearch x (ys) = do
11:00:40 <SideFFect> 	j <- head (ys)
11:00:42 <SideFFect> 	k <- last (ys)
11:00:44 <SideFFect> 	--if (k /= j+1) then h <- (j+k)/2
11:00:46 <SideFFect> 	--else -2
11:00:48 <dons> oh, 'do'?
11:00:55 <mauke> do looks wrong
11:00:57 <SideFFect> im not even sure if I need the do
11:00:58 <SideFFect> yeah
11:01:02 <dons> its not monadic, so no 'do' notation here I think.
11:01:11 <mauke> 'do' is syntactic sugar for calls to >>=
11:01:15 <dons> paste the code into the paste bind at hpaste.org
11:01:22 <mauke> I don't think you want >>= here
11:01:23 <SideFFect> alright gimme a sec
11:01:37 <newsham> in fairness, his name is "sideffect"
11:01:48 <idnar_> id monad!
11:02:07 <salierix> What's "bottom"?
11:02:28 <newsham> > tail [1..] -- bottom
11:02:38 <puusorsa> opposite of "top"
11:02:45 <fasta> twanvl: the problem with that approach is still that it is inefficient.
11:02:49 <Mr_Awesome> i believe its a flavor of quark
11:02:57 <dons> mbot: @part #haskell
11:02:59 <newsham> bottom: 
11:03:04 <mauke> @babel de en quark
11:03:05 <swiert> newsham: no. tail [1..] is just [2..]
11:03:06 <dons> ?uptime
11:03:10 <swiert> bottom is last [1..]
11:03:11 <lambdabot>   quark
11:03:11 <newsham> oops
11:03:12 <newsham> hehe
11:03:15 <newsham> i meant "last"
11:03:19 <lambdabot> uptime: 37s, longest uptime: 1m 10d 23h 44m 29s
11:03:20 <dfranke> salierix: bottom is a symbol used to represent a computation that is undefined or doesn't terminate.
11:03:31 <Karle> Hi
11:03:32 <thetallguy> Also, it looks like you might be doing arithmetic on values as if they were indices?
11:03:41 <hpaste>  SideFFect pasted "Bsearch" at http://hpaste.org/3641
11:03:51 <SideFFect> there we go :P
11:03:54 <Karle> does anyone know untimed dataflow model in Haskell?
11:03:56 <salierix> Oh.
11:04:01 <newsham> sid: is this homework?
11:04:08 <thetallguy> yes
11:04:31 <Karle> thetallguy, you do?
11:04:54 <thetallguy> Karle: sorry, that as an answer to newsham about homework
11:05:01 <Karle> ok
11:05:05 <dfranke> Karle: are you talking about the Li/Zdancewic paper?
11:05:16 <SideFFect> sid to me?
11:05:18 <thetallguy> Karle:  There are some papers about dataflow referenced from Hughes Arrow paper
11:05:19 <SideFFect> oh sorry
11:05:27 <SideFFect> yeah its homework...I dont want asnwers, just help
11:05:27 <newsham> side: instead of using "do" and "j <- " you should probably be using "let var = expr in ..."
11:05:46 <swiert> Karle: There's also "The essence of data flow programming" by Tarmo Uustalu.
11:05:49 <faxathisia> hey
11:05:55 <SideFFect> I can use that for both? let j = head (ys), k = last (ys)
11:05:56 <swiert> If you're not afreaid of comonads...
11:06:22 <desegnis> SideFFect: ; instead of ,
11:06:33 <fasta> Ok, simpler question: what is the best way to generate Haskell code in a Haskell program? Language.Haskell.Syntax?
11:06:40 <SideFFect> ah, didnt know the semicolan thing heh
11:06:40 <faxathisia> > let (j:k) = [a,b,c] in (j,k)
11:06:42 <lambdabot>   Not in scope: `c'
11:06:45 <Karle> swiert, thanks
11:06:51 <faxathisia> > let (j:k) = [1,2,3] in (j,k)
11:06:52 <lambdabot>  (1,[2,3])
11:06:58 <faxathisia> ah, yeah, you can do it this way too
11:07:18 <faxathisia> oh last != rest oops
11:07:26 <dikini> I have a problem in http://hpaste.org/3642?lines=true , as far as I understand it is to do with under defining BeeT, but I want to keep it generic, is there a way around it
11:07:31 <SideFFect> wait im confused whos helping whom here :p
11:07:32 <desegnis> SideFFect: Actually a linebreak is what you usually use instead of a semicolon. You just have to take care about indentation then.
11:07:43 <SideFFect> yeah indentation is annoying heh
11:07:43 <newsham> you dont need the semicolon if you put the items on separate lines
11:07:56 <b_jonas> I can't read that ifelse statement though
11:08:09 <faxathisia> @docs Data.map
11:08:09 <lambdabot> Data.map not available
11:08:32 <SideFFect> look, I'll paste the code that the teacher wants and maybe it'll help understand better?
11:08:32 <desegnis> Btw, lambdabot, nice to see you're back
11:08:36 <swiert> dikini: Try adding Eq dom =>
11:08:50 <smack_> is SPJ's NDP video still around?
11:08:52 <newsham> you should probably write it:  if expr <newline><indent>then expr<newline<indent>else expr
11:08:59 <dons> smack_: should be on the videos page of haskell.org
11:09:00 <dfranke> SideFFect: if you aren't already, then you should be using emacs with http://haskell.org/haskell-mode/, and if you're writing literate code, http://dfranke.us/latex-lhs-mode.el
11:09:01 <lambdabot> Title: Haskell Mode for Emacs
11:09:12 <hpaste>  SideFFect pasted "Imperative_Bsearch" at http://hpaste.org/3643
11:09:18 <SideFFect> there we go :P
11:09:25 <SideFFect> im using GHCI
11:09:45 <dfranke> oy.  Don't use GHCI for multiline programs.
11:09:47 <smack_> dons: Ah, thanks.
11:10:01 * smack_ corrects the link from Blog_articles/Parallel
11:10:01 <SideFFect> yeah its a pain...im on windows tho, so no EMACS for me :P
11:10:09 <dfranke> Emacs has a windows port.
11:10:11 <thetallguy> cygwin
11:10:15 <dfranke> It works well.
11:10:21 <sieni> SideFFect: emacs works fine on windows
11:10:22 <SideFFect> I installed cygwin a while ago...isnt it like 1 gb?
11:10:23 <b_jonas> SideFFect: how does do work in that code?
11:10:26 <newsham> sideffect: so your professor gave you a bunch of definitions (DPL?) for things like ":=" ?
11:10:29 <dfranke> you don't need cygwin
11:10:45 <dfranke> ftp://ftp.gnu.org/gnu/emacs/windows
11:10:50 * smack_ gives up at the 'login required' page
11:10:50 <SideFFect> yeah his way or writing things is weird
11:11:01 <SideFFect> of*
11:11:16 <b_jonas> is that "do" a while loop with the condition right after "do"?
11:11:17 <newsham> oh, this DPL is a different language
11:11:39 <SideFFect> yeah its just a "made-up" mix of languages
11:11:44 <SideFFect> like the if/fi
11:11:48 <SideFFect> if starts, fi ends
11:11:50 <SideFFect> type thing
11:11:53 <newsham> and you want to implement that directly in Haskell?
11:11:54 <eventualbuddha> ooh, i like made-up languages
11:11:57 <SideFFect> hehe
11:11:57 <b_jonas> me too
11:12:01 <newsham> or do you want to write it in functional Haskell?
11:12:11 <SideFFect> yeah thats what he asked...I think my algorithm is ok...just my syntax
11:12:12 <faxathisia> write a DPL interpreter
11:12:12 <b_jonas> I once wrote an interpreter for some pseudocode someone used
11:12:17 <SideFFect> functional haskell
11:12:22 <allbery_b> if/fi, shades of algol68
11:12:22 <b_jonas> so I can prove the pseudocode is buggy
11:12:26 <newsham> doing this in an imperative way in Haskell is not really beginner stuff
11:12:30 <faxathisia> b_jonas: hahaha
11:12:42 <SideFFect> nono, he wants it functionally thought out
11:12:53 <b_jonas> anyway, SideFFect, if you said you need to write that in the same imperative way, then why are you calling the function recursively?
11:12:53 <SideFFect> thats the whole class, understanding why functional languages are good
11:13:03 <thetallguy> SideFFect: no, you're algorithm is confusing indices and elements.
11:13:19 <b_jonas> faxathisia: http://www.math.bme.hu/~ambrus/pu/psz-snapshot.tgz, though poorly documented and abandonned
11:13:26 <newsham> sideeffect: do you know the "take" command?
11:13:30 <faxathisia> b_jonas: cheers :D
11:13:35 <newsham> > take 5 "this is a test"
11:13:36 <lambdabot>  "this "
11:13:39 <SideFFect> yeah takes 1 or 2 or wtv elements from haed of list
11:13:43 <newsham> (also opposite "drop")
11:13:55 <b_jonas> hey, lambdabot is up?
11:13:59 <newsham> so you should be able to use take/drop to split up your list without working with indices
11:14:17 <SideFFect> but he wants us to use indices...thats the way the imperitive code works
11:14:35 <SideFFect> he wants us to define a[j] and a [k] and then divide them and get a[h]
11:14:38 <newsham> are you sure he "wants" you to?
11:14:48 <b_jonas> faxathisia: http://www.math.bme.hu/~ambrus/pu/olvashato/ is worse than that because I actually used it, while I abandonned that interpreter and never actually used it
11:14:49 <lambdabot> Title: Olvashato compiler
11:14:53 <SideFFect> yeah
11:14:57 <desegnis> There's not much point in working without indices if the idea of the algorithm is to split the list/array into two halves.
11:14:57 <olsner> does haskell have dependent types?
11:15:18 <hpaste>  SideFFect pasted "Teacher_wants" at http://hpaste.org/3644
11:15:18 <thetallguy> SideFFect: yes, but head(ys) does not give you an index
11:15:24 <SideFFect> thats what teacher wants
11:15:26 <dfranke> olsner: nope, but you can fake it.
11:15:28 <b_jonas> SideFFect: so he wants you to use recursion, or some imperative kind of loop?
11:15:28 <newsham> desegnis: well i meant more of   length xs / 2
11:15:49 <thetallguy> SideFFect: it gives you the first element of the list
11:16:13 <olsner> dfranke: with e.g. type-encoded values?
11:16:17 <newsham> side: anyway, back to your code.  you're taking elements out of the list (head/last) and then treating them as indices.
11:16:22 <newsham> the elements in the list arent the indices.
11:16:30 <newsham> the indices of the head/last are 0 and length xs - 1
11:16:31 <b_jonas> I see. recursion.
11:16:43 <dfranke> olsner: basically.  Use singleton types instead of values, and typeclasses instead of types.
11:16:44 <SideFFect> yeah, but all I want to do is find a given number from an array?
11:16:51 <SideFFect> and the array goes from 1-100 only
11:17:01 <newsham> also [Integer] isnt an array of integers
11:17:07 <olsner> hmm, but doesn't that mean that value-dependent types can always be emulated in a language with type-dependent types?
11:17:15 <b_jonas> well then I agree with dons, you probably don't want to use haskell's "do"
11:17:16 <SideFFect> I know, I want my output to just be a 1 true or -1 false
11:17:45 <SideFFect> and [integer] is a list right?
11:17:48 <olsner> ... collapsing the lambda-cube into a lambda-square
11:17:55 <dfranke> olsner: sure, given sufficient Greenspuning, you can do it in Brainf***.
11:17:58 <b_jonas> 1 true or -1 false? is that from quantum computing or something?
11:18:03 <SideFFect> lol no
11:18:05 <SideFFect> just easier for me
11:18:23 <salierix> So how long do you think it will take for the computer language shootout guys to switch to ghc 6.8.1?
11:18:39 <dons> until its in gentoo
11:18:46 <desegnis> SideFFect: In Haskell there is True and False.
11:18:54 <b_jonas> SideFFect: I recommend that you take the imperative code and turn to loop to a tail recursion if possile
11:18:58 <salierix> dons, gentoo still uses ghc 6.4.2
11:19:03 <newsham> side: you can also use True/False, which are of type Bool
11:19:07 <SideFFect> yeah then my output has to be of type bool right?
11:19:09 <SideFFect> yeah heh
11:19:25 <dons> SideFFect: yes, loops become recursion, use True/False instead of 1 et al, and don't use do-notation -- its a purely function program
11:19:30 <b_jonas> that is, make a function that will do the same thing as the do loop and below (but not the assignment above that loop
11:19:37 <desegnis> SideFFect: The DPL code seems to return the index of the value that is found.
11:19:41 <newsham> why dont you start with your existing program, rewriting it using proper indentation and using let instead of do/<-
11:20:06 <newsham> then ask the next question once you find that not to be properly working :)
11:20:06 <SideFFect> I tried using let, gave me weird errors
11:20:09 <SideFFect> hehe
11:20:25 <Karle> I could not find what is wrong with this error message
11:20:26 <SideFFect> I tried let j = head (ys)
11:20:30 <dons> SideFFect: you're doing it wrong :) time to start over, perhaps with a haskell syntax guide?
11:20:33 <SideFFect> but then how do I print j, just as a test?
11:20:35 <Karle> could you please take a look?
11:20:38 <dons> main = print j
11:20:40 <b_jonas> the main body of that function should be an "if" that checks that condition in the original "do"
11:20:43 <dons> print the result at the end
11:20:54 <newsham> > (\ys -> let j = head ys in (j+3)) [5,3,2]
11:20:55 <b_jonas> and then if it's true it does the computations in the loop body then recalls the function
11:20:56 <dfranke> ?hoogle trace
11:20:58 <lambdabot> Debug.Trace.trace :: String -> a -> a
11:20:58 <SideFFect> ive read many guides...Yet Another Haskell Tutorial...but still im confused
11:20:58 <lambdabot> Debug.Trace :: module
11:20:58 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
11:21:01 <newsham> oh, no bot
11:21:03 <lambdabot>  8
11:21:08 <SideFFect> lemme try
11:21:08 <b_jonas> in the else branch, it should do the things below the if loop
11:21:11 <SideFFect> one sec
11:21:11 <b_jonas> below the do loop
11:21:17 <newsham> side: you need an "in" after the "let var = expr"
11:21:46 <SideFFect> do I type = let j = head (ys) on same line?
11:21:50 <newsham> you could also do:   let var = expr<newline><indent to under "var">var2 = expr2 in ...
11:22:05 <salierix> What does this mean?
11:22:06 <salierix> newtype State s a = State { runState :: (s -> (a, s)) }
11:22:15 <dons> > let j = head [1..] in j
11:22:17 <lambdabot>  1
11:22:33 <hpaste>  Karle pasted "code" at http://hpaste.org/3645
11:22:45 <SideFFect> but I take in a user generated array dont I? so I cant specify it myself?
11:22:54 <dons> salierix: State s a is equivalent to s -> (a, s), but is treated as a distinct type
11:22:56 <desegnis> salierix: It declares a newtype called State that wraps a function of type (s -> (a,s)).
11:23:10 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/3642#a1
11:23:53 <salierix> None of the tutorials I've read talk about using newtype in that way...
11:23:59 <dikini> swiert: thanks, http://hpaste.org/3642#a1 seems to compile
11:24:01 <SideFFect> is this wrong?
11:24:01 <SideFFect> bsearch x (ys) = let j = head (ys) in j
11:24:01 <SideFFect> 	print j
11:24:15 <faxathisia> let j = head (ys) in j
11:24:19 <faxathisia> head (ys)
11:24:20 <mauke> too many parens
11:24:38 <desegnis> salierix: What is different? Do you mean the record syntax (the braces)?
11:24:39 <newsham> side: bsearch cant both return "j" and also "print j"
11:24:43 <Karle> mauke, fo rme?
11:24:43 <newsham> in fact, bsearch cant print j at all
11:24:55 <Karle> mauke, for me?
11:25:02 <salierix> desegnis, yeah, what would runState do?
11:25:17 <mauke> Karle: no
11:25:20 <newsham> side: expr<newline>expr   doesnt mean run two expressions in haskell
11:25:23 <SideFFect> so its bsearch x (ys) = let then newline?
11:25:43 <SideFFect> or bsearch x (ys) = newline let j = etc
11:25:47 <jsnx> consider:  list = (stuff, meta) : [  ]
11:25:49 <desegnis> salierix: Fire up ghci and check the type of runState (it's a function)
11:25:51 <jsnx> oops, sorry
11:25:58 <jsnx> hit the wrong button
11:26:11 <newsham> side: your earlier example ("in j") was correct up to that point.  just the newline-indent-"print j" is wrong
11:26:45 <newsham> "bsearch x (ys) = let j = head (ys) in j"  is valid
11:27:00 <SideFFect> all on one line?
11:27:03 <salierix> No ghci ascii art! :(
11:27:05 <newsham> sure, thats fine
11:27:18 <newsham> you could also have done:   "in<newline><indent>j"
11:27:33 <SideFFect> I did that, and then <indent> print j and gave me error
11:27:42 <newsham> yah, like I said, you cant print j
11:27:54 <SideFFect> so how do I test to make sure its right?
11:28:03 <newsham> when you say "in j" it means return the value j.
11:28:07 <newsham> you cant do anything after that.
11:28:09 <SideFFect> ah
11:28:19 <newsham> and since you're in pure functional code, you cant print anyway
11:28:24 <newsham> printing is a side effect.. you cant use it
11:28:33 <SideFFect> heheh
11:28:34 <desegnis> salierix, It's indeed no art ;)
11:28:42 <SideFFect> ok, the head shows now
11:28:53 <SideFFect> now I gotta do the same for the last element
11:29:08 <SideFFect> the teacher said we can use this too (list) !! 0
11:29:15 <SideFFect> but its zero indexing so harder to count
11:29:16 <newsham> it makes about as much sense as when you say:   "return j printf("hello world");" in C
11:29:26 <SideFFect> heh yeah doesnt make much sense there
11:29:53 <newsham> are you new to computer science?  you should probably start getting used to counting from zero now
11:30:03 <newsham> because you'll be doing it for the rest of your CS career
11:30:04 <SideFFect> can you believe this is a university 300 level course and the full class is confused with haskell
11:30:12 <SideFFect> nono, ive been thru enuff :p
11:30:30 <faxathisia> SideFFect: I can imagine people being confused
11:30:51 <newsham> i can especially imagine people being confused if the professor shows you a bunch of imperative code and then says "go do this in haskell"
11:30:54 <fasta> newsham: Counting from zero is not always best.
11:30:57 <faxathisia> SideFFect: especially in computing classes
11:31:00 <SideFFect> lol yeah
11:31:03 <SideFFect> hes not too "sane"
11:31:08 <fasta> newsham: people wrote articles about it(e.g. Dijkstra, IIRC)
11:31:08 <newsham> fasta: i know, but in this case its not particularly hard
11:31:20 <fasta> newsham: oh, counting from any number is trivial.
11:31:26 <faxathisia> fasta: It is very useful in most cases
11:31:53 <desegnis> SideFFect: I would suspect, too, that the professor who gave you this task is not a good functional programmer, and not an excellent teacher either
11:31:55 <SideFFect> ok so I can continue to write = let j = head (ys); k = tail (ys)
11:32:06 <SamB> zero and one are the choices that are most often nice, I think...
11:32:16 <faxathisia> SideFFect: let (j:k) = ys
11:32:16 <fasta> faxathisia: unless you are a world-famous computer scientist, I don't care for an IRC discussion about this topic.
11:32:20 <desegnis> SideFFect: Note that your j and k are the first and last element of the list.
11:32:21 <SideFFect> yep that worked
11:32:29 <SideFFect> yeah thats what I wanted
11:32:34 <SideFFect> now I have to divide j and k
11:32:35 <desegnis> SideFFect: Wait, that's wrong what I said
11:32:39 <faxathisia> fasta: why are you here?
11:32:59 <SamB> faxathisia: to talk about other topics, presumably
11:33:18 <desegnis> SideFFect: Sorry. Your j is the first element of the list, and k is the rest of the list. (If you use tail. Maybe you wanted last instead)
11:33:20 <SamB> or maybe to talk to world-famous computer scientists!
11:33:23 <fasta> I just love other people answering questions for me :) Thank you SamB
11:33:29 <SideFFect> yeah im using last
11:33:45 <SideFFect> I just need to define the range that ill be sub-dividing by half each time
11:33:51 <desegnis> SideFFect: Note, though, that this does not help you approximating the reference algorithm
11:34:16 <b_jonas> but you need the average of the two indices, not the two values
11:34:18 <b_jonas> don't forget that
11:34:26 <jsnx> fasta: i am world famous computer scientist
11:34:27 <b_jonas> j should be the indives
11:34:29 <SideFFect> average? I just need to find the middle?
11:34:46 <jsnx> fasta: very 'high' in my country
11:34:46 <SamB> (though possibly you should make restrictions on the quality of the computer scientist, rather than how well-known he/she is)
11:34:47 <b_jonas> doesn't the imperative code do that?
11:34:58 <SideFFect> heh it doesnt like fractions does it :P
11:34:58 <newsham> fasta: unless you are an 18 year old girl, I dont want to talk to you about indixing either.
11:35:07 <b_jonas> 'h := (j+k) div 2'
11:35:15 <SideFFect> ah
11:35:19 <jsnx> newsham: !!
11:35:25 <b_jonas> and there j and k are indices, not elements of the list
11:35:32 <desegnis> SideFFect: The average of two numbers is in the middle between them. Always.
11:35:44 <SideFFect> indices? but they'
11:35:48 <SamB> newsham: why would you want to talk to 18 year-old girls about that?
11:35:50 <SideFFect> they're still part of the list
11:35:55 <newsham> jsnx: dont tell me you're a world famouse computer scientist AND an 18 year old girl?
11:36:06 <b_jonas> are they?
11:36:08 <SideFFect> I keep getting an error about fractions
11:36:15 <SideFFect> h = (j+k) div 2 in h
11:36:15 <b_jonas> look at how j and k are initialized
11:36:19 <newsham> samb: it seems boring subjects are more bearable when the other person is an 18 year old girl
11:36:26 <mauke> SideFFect: div (j+k) 2
11:36:31 <SideFFect> well yeah, j and k are just numbers
11:36:35 <b_jonas> 'j,k := 1,n'
11:36:39 <b_jonas> are those parts of the list?
11:36:44 <b_jonas> or array or whatever
11:36:53 <b_jonas> array it says
11:36:58 <SideFFect> well, if you count them, they should be if the list goes from 1 - n
11:36:59 <SideFFect> :P
11:37:01 <sieni> newsham: no they are not
11:37:12 <b_jonas> but...
11:37:13 <SamB> a world-famous 18-year-old female computer scientist would be ... surprising
11:37:24 <SideFFect> yeah in engineering theres 5 girls
11:37:38 <desegnis> SideFFect: If the list goes from 1 to n, you wouldn't need an algorithm any more. The list contains arbitrary numbers, sorted.
11:37:39 <SamB> newsham: how old are you?
11:37:45 <newsham> samb: 36?
11:37:54 <sieni> newsham: you are not sure?
11:38:00 <newsham> sometimes
11:38:18 <paczesiowa> he doesn't know if he should count from 0 or 1
11:38:20 <SamB> what is it about talking to 18-year-olds?
11:38:36 <SideFFect> the teacher wants the code to run like this For test cases, one might try:
11:38:36 <SideFFect> - Find  4 in [1,2,3, ... ,100]
11:38:36 <SideFFect> - Find  1 in [1,2,3, ... ,100]
11:38:36 <SideFFect> - Find 57 in [1,2,3, ... ,100]
11:38:49 <newsham> pac: I do count from zero.. I didnt turn one until after the first year
11:38:50 <SideFFect> so im guessing its always 1-100
11:39:00 <paczesiowa> newsham: :P
11:39:04 <SamB> SideFFect: those are examples
11:39:08 <SideFFect> yes they are :p
11:39:10 <newsham> samb: facetious remarks.
11:39:10 <desegnis> SideFFect: Then the answers are 4, 1, 57. (if you index from 1)
11:39:35 <desegnis> SideFFect: So obviously, no algorithm needed.
11:39:47 <SamB> SideFFect: but he doesn't say he won't try it with [0..]
11:39:55 <SideFFect> true
11:40:00 <SideFFect> and true
11:40:07 <SamB> well, maybe he said somewhere that the list would be finite
11:40:15 <david__> sorry! another question about FFI. I've got this haskell function:  calculateAPDF :: (RealFrac a) => (a->a) -> a -> [(a, a)] and this export declaration foreign export ccall "calculate_apdf" calculateAPDF :: (Float -> Float) -> Float -> [(Float, Float)]. The problem is that the haskell function takes another function as parameter. How can I translate it as export declaration?
11:40:19 <newsham> > elemIndex 4 [0..100]
11:40:21 <lambdabot>  Just 4
11:40:26 <newsham> > elemIndex 55 [0..100]
11:40:28 <lambdabot>  Just 55
11:40:31 <newsham> > elemIndex 155 [0..100]
11:40:33 <lambdabot>  Nothing
11:40:45 <SideFFect> ah he wants this
11:40:46 <SideFFect> The output of the correct program has the form:
11:40:46 <SideFFect>   Item 7 was found in position 4.
11:40:46 <SideFFect>   Item 7 was not found.
11:41:14 <david__> I can change the haskell function to accept a String instead of the function passed as parameter. but I don't know then how to use the String
11:41:36 <david__> for instance... the passing function sould be a math function (like 1+x**8)
11:43:17 <salierix> I'm starting to get a handle on monads but next I have to learn about monad transformers :(
11:43:23 <SideFFect> why do I get a match error
11:43:25 <SideFFect> for the div
11:44:02 <SideFFect> "Couldnt match expected type 't1 -> t2 -> t'
11:44:17 <david__> Now I have this error: "Unacceptable argument type in foreign declaration: Float -> Float". I know ... is right because my declaration on export is wrong. but... how can I translate it? :(
11:44:20 <Olathe> > let thingy item list = thingy' item (elemIndex item list) where thingy' item Nothing = "Item " ++ (show item) ++ " was not found."; thingy' item (Just pos) = "Item " ++ (show item) ++ " was found in position " ++ (show pos) ++ "." in thingy 1000 [0..100]
11:44:22 <lambdabot>  "Item 1000 was not found."
11:44:32 <desegnis> Side: Please state your problem clearly. There is no div in front of my eyes.
11:44:49 <SideFFect> k = last(ys); h = ((j+k) div 2) in h
11:44:56 <SideFFect> continuation of my code
11:45:00 <SideFFect> produces that error...
11:45:15 <b_jonas> SideFFect: http://hpaste.org/3643 says 'Consider a sorted array of integers (a[1] <= a[2] <= ... <= a[n])'
11:45:19 <newsham> (j+k) div 2    is bad syntax
11:45:22 <b_jonas> it doesn't say it's always 1..100
11:45:27 <SideFFect> yeah I know
11:45:28 <desegnis> SideFFect: Look back what mauke said.
11:45:41 * olsner hat Hunger
11:45:41 <ddarius> If you understand monads, monad transformers are straightforward.
11:45:47 <SideFFect> mauke? ill check
11:46:05 <SideFFect> ah
11:46:06 <Olathe> > let thingy item list = thingy' item (elemIndex item list) where thingy' item Nothing = "Item " ++ (show item) ++ " was not found."; thingy' item (Just pos) = "Item " ++ (show item) ++ " was found in position " ++ (show pos) ++ "." in thingy 2 [1..100]
11:46:08 <lambdabot>  "Item 2 was found in position 1."
11:46:14 <SideFFect> its a function
11:46:18 <SideFFect> div (j+k) 2
11:46:26 <idnar> (j+k) `div` 2
11:47:08 <paczesiowa> j+k `div` 2
11:47:43 <mauke> paczesiowa: unlikely
11:47:53 <newsham> side: what material did you guys read to learn Haskell?  how far have you gotten?
11:47:58 <SideFFect> ah that works
11:48:07 <SideFFect> well the teacher gives us random functions on board
11:48:11 <SideFFect> like map, take2 and etc
11:48:14 <SideFFect> defines them
11:48:21 <SideFFect> tutorial is also random functions
11:48:23 <SideFFect> and thats it
11:48:48 <newsham> so no written materials?
11:48:54 <SideFFect> the midterm was 100% haskell, and the final will be too
11:49:09 <SideFFect> nope, we have a book, but theres half a paragraph of haskell in it
11:49:09 <mauke> sounds awesome
11:49:14 <SideFFect> lol not really
11:49:21 <mauke> for me, I mean :-)
11:49:21 <SideFFect> some guy left after 2 min in the midterm
11:49:28 <SideFFect> he stood up, handed in his paper, and left
11:49:28 <Zao> newsham: Random internet guides, Hoogle, some of YAHT, the hopengl tutorial.
11:49:45 <newsham> it seems like you don't have a solid background in basics like "let" yet.  I think you'd find this a lot easier to do if you covered some intro tutorial first
11:50:00 <SideFFect> they gave us one example of it
11:50:03 <b_jonas> I hate how ghci says "[1 of 1] Compiling Main" -- it looks so much like an error message to me
11:50:07 <SideFFect> my school is retarded, always has been
11:50:11 <dons> SideFFect: there's lots of good tutorials on haskell.org
11:50:28 <SideFFect> yeah I should go over those...Ive read 1-2 of them
11:50:29 <dons> you can pretty much become an expert in the language by reading everything from there.
11:50:33 <dons> ?where yaht
11:50:33 <SideFFect> I read YAHT too
11:50:34 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:50:50 <Olathe> > let thingy item list = "Item " ++ (show item) ++ " was " ++ (thingy' (elemIndex item list)) ++ "." where thingy' Nothing = "not found"; thingy' (Just pos) = "found in position " ++ (show pos) in [thingy 2 [1..100], thingy 1000 [1..100]]
11:50:52 <lambdabot>  ["Item 2 was found in position 1.","Item 1000 was not found."]
11:50:55 <newsham> http://www.haskell.org/haskellwiki/Learning_Haskell  has a lot of useful material.  I would recommend "two dozen short lessons"
11:50:57 <lambdabot> Title: Learning Haskell - HaskellWiki
11:51:02 <desegnis> b_jonas: I hate more that Cabal's `Setup.hs configure` includes messages about things that are not found, when there is no error at all
11:51:11 <ddarius> If you want to become an expert read everything from here http://www.haskell.org/haskellwiki/Research_papers (eventually)
11:51:12 <lambdabot> Title: Research papers - HaskellWiki
11:51:34 <b_jonas> @hoogle liftM1
11:51:35 <lambdabot> No matches found
11:51:35 <SideFFect> I think the 2 dozen paper is gone?
11:51:51 <newsham> ?go two dozen short haskell
11:51:54 <lambdabot> http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
11:51:54 <lambdabot> Title: Two Dozen Short Lessons in Haskell
11:52:14 <newsham> oh, blah, no longer present :(
11:52:17 <SideFFect> yeah :(
11:52:19 <b_jonas> @i liftM1
11:52:19 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
11:52:24 <b_jonas> @source liftM1
11:52:25 <lambdabot> liftM1 not available
11:52:31 <b_jonas> @src liftM1
11:52:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:52:35 <paczesiowa> @src liftM
11:52:35 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:52:47 <b_jonas> ah, that's the problem
11:52:48 <b_jonas> thanks
11:52:59 <newsham> I would go with YAHT then. you said you already looked at it a little..
11:53:09 <SideFFect> even then i got confused heh
11:53:29 <SideFFect> and hm, now I get what someone was saying about my j and k being indices and not array pointers
11:53:53 <SideFFect> because if I divide the first and last numbers by 2
11:53:58 <SideFFect> if the array is 2 - 8
11:54:01 <SideFFect> that gives 5
11:54:08 <newsham> > head [5,3,2,1,0]
11:54:09 <SideFFect> but what if theres no 5 in the array
11:54:10 <SideFFect> sigh
11:54:10 <lambdabot>  5
11:54:18 <newsham> notice that 5 is the head, but 0 is its index
11:54:32 <chessguy> 2 - 8 = 5? in what universe?
11:54:34 <newsham> you are setting j to the head of the list, and then you are pretending its the index to the head of the list
11:54:42 <SideFFect> 2+8 / 2 = 5
11:55:14 <idnar> chessguy: I think he means indices 2 through 8
11:55:15 <newsham> if you look at the bsearch algorithm your professor gave you, j and k are used as indices to the list, and are not members in the list
11:55:16 <SideFFect> yeah true newsham
11:55:21 <SideFFect> im just setting it to a number
11:55:42 <newsham> this is much more apparent if you look at a list that contains elements that arent integers.
11:55:59 <newsham> > head "testing"  -- you cant even do arithmetic on this value
11:56:01 <lambdabot>  't'
11:56:05 <SideFFect> so isnt his program wrong then?
11:56:25 <newsham> why is his program wrong?
11:56:28 <SideFFect> it will only work with lists that are orderered and have one of each number
11:56:39 <SideFFect> not a list like 2,4,5,8
11:56:43 <magnusth> what's up with Hoogle tonight? the links to standard functions (e.g. putStrLn) are 404 :(
11:56:44 <newsham> his program is supposed to work on ordered lists
11:56:44 <Olathe> > 't' + 1
11:56:45 <lambdabot>   add an instance declaration for (Num Char)
11:56:45 <lambdabot>     In the expression: 't' + 1
11:56:45 <lambdabot>  ...
11:56:46 <newsham> thats the problem description
11:57:02 <newsham> the whole point of binary search is that binary search lets you quickly search a sorted list
11:57:15 <SideFFect> yeah by reducing the amount it has to look thru
11:57:23 <SideFFect> each time its called
11:57:32 <idnar> it should work fine on [2,4,5,8] though
11:57:39 <idnar> because that's ordered
11:57:58 <magnusth> @hoogle putstrln
11:57:59 <lambdabot> Prelude.putStrLn :: String -> IO ()
11:57:59 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
11:57:59 <SideFFect> what if I had a list of [2,3,6,8]
11:58:04 <newsham> lets walk through [2,4,5,8] in his code.  lets do indexed from one.
11:58:05 <SideFFect> which gives h = 5
11:58:06 <Olathe> Is it possible to guess the randomly-named variable lambdabot uses in order to confuse it ?
11:58:09 <newsham> he sets j to 1 and k to 4.
11:58:11 <SideFFect> but theres no 5 to find
11:58:22 <SideFFect> or im getting confused and need to take a step back for a moment
11:58:27 <Olathe> (13:57.36) (lambdabot) In the expression: let pjb = 't' + 1 in take 2048 (show pjb)
11:58:31 <newsham> then as long as 1+1 <> 4, he does:   h = 1+4 divide by 2 = 5 / 2 = 2
11:58:36 <SideFFect> k would be 8?
11:58:44 <dylan> LOL!! "In case you didn't realise .. programming is *primarily* a commercial (for money) activity which is *primarily* intended to support commercial or governmental activity"
11:58:45 <idnar> SideFFect: I think you're getting confused between the values of the array, and the indices
11:58:56 <SideFFect> i think so too
11:59:03 <newsham> then he does if x < a[2] then k = 2;  else if x >= a[2] then j = 2
11:59:13 <idnar> SideFFect: the values of that array are 2, 4, 5, and 8; the indices are 1, 2, 3, 4 (assumsing 1-based indexing)
11:59:22 <dylan> that's like saying "... breating is *primarily* a commercial (for money) activity which is ...."
11:59:23 <newsham> side: nope, k is set to n, the highest index in the list.
11:59:27 <newsham> a[1] <= x < a[n]
11:59:30 <newsham> n is the index
11:59:30 <SideFFect> ah sorry getting confused about indices
11:59:39 <SideFFect> get it now
11:59:47 <magnusth> @index putstrln
11:59:47 <lambdabot> bzzt
11:59:48 <SideFFect> well that part at least
11:59:52 <b_jonas> I guess I understand how to convert any imperative program to haskell by putting everything in IO do blocks,
11:59:57 <newsham> so you see j and k arent taken from the list at all
12:00:01 <fasta> What's the course name Algorithms 101 with Haskell?
12:00:03 <newsham> they are just positions in the list
12:00:05 <magnusth> @url putstrln
12:00:06 <lambdabot> I know nothing about putstrln.
12:00:12 <b_jonas> now I only need to learn when there's a better translation.
12:00:22 <SideFFect> one sec, lemme try to sort this in my head... hehe
12:00:41 <newsham> the easiest way to sort this out in your head is to start with your professors code, and do a full example, by hand
12:00:43 <SamB> b_jonas: have you seen the funky C ESDL?
12:00:45 <newsham> as if you wree the computer
12:00:52 <SamB> it, of course, does crazy shit with typeclasses
12:00:52 <newsham> try it with 2,4,5,8
12:00:59 <SideFFect> thats wjhat im trying now with my list 2 4 5 8 :D
12:00:59 <newsham> and search for "3" and "5"
12:01:04 <magnusth> :where putStrLn
12:01:10 <SideFFect> im trying to find 4, then ill try 3 and 5
12:01:33 <b_jonas> SamB: no, what's that/
12:01:34 <magnusth> @where putStrLn
12:01:34 <lambdabot> I know nothing about putstrln.
12:01:49 <SamB> what was that blog called
12:01:51 <fasta> b_jonas: Lennart's blog
12:01:55 <Korollary> @index putStrLn
12:01:55 <lambdabot> System.IO, Prelude
12:01:59 <b_jonas> url?
12:02:04 <fasta> b_jonas: google
12:02:29 <SamB> @google lennart C haskell
12:02:31 <lambdabot> http://groups.google.com/group/fa.haskell/msg/9768f6b0d9c9262d
12:02:31 <lambdabot> Title: Composition Operator - fa.haskell | Google Groups
12:02:34 <SamB> hmm
12:02:39 <magnusth> Korollary, I was hoping to find the haddock page for System.IO.Prelude... hoogle links seem to be broken today :(
12:02:55 <SamB> @google things that amuse me
12:02:58 <lambdabot> http://randomreality.blogware.com/blog/ThingsThatAmuseMe
12:02:58 <lambdabot> Title: Random Acts Of Reality :: Things That Amuse Me...
12:03:02 <SamB> @google things that amuse me haskell
12:03:04 <lambdabot> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
12:03:04 <lambdabot> Title: Things that amuse me
12:03:12 <sorear> magnusth: all the urls have changed
12:03:18 <omnId> yeah, I was sure it was augustss's
12:03:25 <magnusth> sorear, where have they moved to?
12:03:31 <sorear> google?
12:03:43 <sorear> @go site:haskell.org Prelude putStrLn
12:03:45 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html
12:03:52 <sorear> @go site:haskell.org inurl:Prelude putStrLn
12:03:54 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
12:03:54 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
12:04:00 <SamB> heh
12:04:05 <SamB> that should be useful anyway
12:04:13 <sorear> read that, it's MUCH better than the haddocks
12:04:31 <magnusth> sorear, 404
12:04:34 <SamB> sorear: but did you find it on purpose?
12:04:47 <SamB> magnusth: on the report?
12:04:54 <magnusth> SamB, yes
12:05:07 <monochrom> I don't get 404.
12:05:13 <magnusth> "The requested URL /ghc/docs/latest/html/users_guide/ch03s04.html was not found on this server."
12:05:20 <b_jonas> hmm
12:05:49 <monochrom> I see, you did not mean "yes, on the report".
12:06:16 <SamB> so... where is the users guide now?
12:06:42 <monochrom> only "ch03s04.html" is the problem.
12:06:52 <SamB> ah
12:07:04 <magnusth> monochrom, what's the name of the chapter then?
12:07:36 <monochrom> I am not sure what section is intended, so I can't know.
12:07:51 <SamB> http://haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
12:07:52 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2wj9jo
12:08:07 <SamB> that, at least, is a section of the same number
12:08:23 <SamB> and it seems likely that it would contain a putStrLn...
12:08:30 <b_jonas> funny.
12:08:39 <SamB> I found it by, um, clicking the link in the table of contents
12:08:46 <SamB> which is found at http://haskell.org/ghc/docs/latest/html/users_guide/
12:08:47 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.8.1
12:09:13 <magnusth> ah, well, I don't want to read about interactive evaluation, I want to get the prelude haddock page, and the links from hoogle are all broken
12:09:33 <SideFFect> ah I get where my algo was wrong
12:09:44 <SideFFect> but how do I search by a(h)?
12:09:45 <SamB> so, what does it do now? generate filenames based on the internal section names?
12:09:46 <SideFFect> in haskell
12:09:55 <monochrom> I still have 6.6.1 user guide and I can testify that 3.4 is also "interactive evaluation" there. :)
12:10:12 <newsham> what does "search by a(h)" mean?
12:10:22 <desegnis> magnusth: What's wrong with http://haskell.org/ghc/docs/latest/html ?
12:10:23 <lambdabot> Title: GHC Documentation
12:10:26 <newsham> you mean do an indexed lookup?
12:10:28 <SamB> I hope they aren't going to start changing those names now
12:10:30 <SideFFect> he compares x < a[h], then k = h
12:10:33 <newsham> > "testing" !! 2
12:10:34 <lambdabot>  's'
12:10:53 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html  is haddocks
12:11:09 <SideFFect> it makes sense, but I have to get a way to store the location of the array, not just numbers
12:11:11 <SideFFect> as I was doing
12:11:38 <SamB> location of array?
12:11:40 <magnusth> so, Hoogle's CGI for looking up haddock pages is broken... I suspect it's a result of versioned base libaries :)
12:11:44 <SamB> what in the...?
12:11:47 <newsham> I dont understand what you mean by "store the location of the array"
12:11:59 <SamB> Haskell arrays aren't located anywhere
12:11:59 <desegnis> magnusth, right
12:12:02 <SamB> they just are
12:12:12 <mauke> SamB: he means indices
12:12:13 <newsham> samb: I think he means the indices
12:12:17 <SideFFect> wait wait... ugh im confusing myself again
12:12:17 <mauke> I hope
12:12:27 <magnusth> anyone know where I can report a bug on hoogle?
12:12:34 <SideFFect> sigh... :P
12:12:35 <Karle> I need help :-)
12:12:42 <Karle> Can anyone please help me?
12:12:48 <dons> magnusth: to ndm
12:12:53 <SamB> magnusth: what sort of bug?
12:12:57 <newsham> I think its amusing that his professor is having them do binary search on lists.
12:13:02 <SamB> most of them are known by now, I think...
12:13:07 <dons> newsham: :)
12:13:13 <SamB> newsham: why?
12:13:15 <monochrom> Some Haskell professors are incompetent.
12:13:19 <SideFFect> amusing? not for me lol
12:13:22 <desegnis> magnusth: I think that's a kind of bug that you don't need to report... The Hoogle creator sometimes is on #haskell, isn't he?
12:13:55 <newsham> samb: because indexing into a list is linear
12:13:57 <SamB> he should do a linear search and then argue that he's just written an accelerated binary search
12:13:59 <monochrom> It is predicted by the Law of Large Numbers. :)
12:14:19 <SamB> monochrom: I wasn't aware said law was applicable to Haskell
12:14:32 <magnusth> SamB, go to hoogle, put in "putStrLn" and follow the link to haddock
12:14:49 <SamB> magnusth: I'm sure he'll notice it soon enough on his own
12:15:02 <SamB> I wouldn't bother to email him or anything
12:15:40 <magnusth> dons, SamB, I'll send him an email anyway.. I feel crippled without being able to follow links in Hoogle
12:15:59 <newsham> side: when you're done your implementaiton, you should read up on haskell arrays, rewrite it using arrays, and then tell your professor why doing it on lists is a bad idea
12:16:02 <omnId> @seen ndm
12:16:03 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 3d 4h 35m 29s ago, and .
12:16:22 <SamB> hmm, I suppose someone had better do it then...
12:16:37 <SideFFect> im really beginning to hate my teacher lol
12:16:43 <dons> magnusth: definitely
12:16:52 <monochrom> Just don't hate Haskell. :)
12:17:04 <SideFFect> at least not in this room I wont :P
12:17:08 <newsham> side: you should thank him.  learning something on your own will give you a deeper understanding :)
12:17:23 <SideFFect> with 17 credits I dont have time for deeper understandings :P
12:17:25 <SamB> SideFFect: you could use an array instead of a list or something
12:17:28 <SideFFect> I need to graduate heh
12:17:35 <newsham> awww...  this is supposed to be fun.
12:17:37 <SamB> damn schools these days
12:17:45 <SideFFect> how do I use arrays in haskell?
12:17:49 <monochrom> naw. damn graduation.
12:17:58 <SamB> well, okay, maybe not the schools
12:18:01 <SideFFect> I know, I like programming
12:18:05 <SideFFect> but this is annoying me :P
12:18:08 <SamB> damn health care
12:18:14 <SideFFect> free for us canucks :D
12:18:31 <SamB> SideFFect: well WTH are you under so much pressure to graduate for then?
12:18:40 <SideFFect> what do you mean?
12:18:44 <SideFFect> its my last term?
12:18:52 <SamB> does it have to be?
12:18:55 <SideFFect> I needed this class to grad
12:18:58 <SideFFect> no it doesnt
12:19:00 <newsham> > let a = array (0,4) "test" in a ! 3
12:19:05 <SideFFect> but why postpone it?
12:19:08 <lambdabot>  Couldn't match expected type `(t, e)' against inferred type `Char'
12:19:08 <omg911> SideEffect: which school are you at ?
12:19:18 <monochrom> > let myarray = Data.Array.array (0,2) [(2, "hey"), (0, "hello"), (1, "world")] in myarray ! 1
12:19:20 <lambdabot>  "world"
12:19:21 <SideFFect> Concordia, in montreal, Quebec
12:19:34 <LoganCapaldo> So I had a thought about IsString
12:19:40 <monochrom> That is an example of creating and then reading an array.
12:19:40 <newsham> oops, forgot to zip it
12:19:42 <omg911> oh nice.. i wish we had a haskell course
12:19:46 <LoganCapaldo> instance IsString ShowS anyone?
12:19:49 <SideFFect> I wish we didnt :P
12:20:00 <SideFFect> or a better teacher
12:20:05 <SamB> SideFFect: you should wish you had a teacher who gave sane assignments
12:20:14 <omg911> i have to learn and motivate myself on my own
12:20:17 <SideFFect> newsham: whats that you posted?
12:20:17 <LoganCapaldo> (or instance DList Char(
12:20:27 <newsham> mine was broken.  see monochrom's
12:20:48 <SideFFect> is there a way to take in a user-typed array?
12:20:56 <SamB> binary searching lists... that's, what, O(n*log n)?
12:21:13 <magnusth> ndm has listed his email as a short piece of haskell code: "ndmitchell" ++ [chr 64] ++ reverse "liamg" ++ [chr 46] ++ "com"
12:21:20 <desegnis> > Data.Array.listArray (0,4) "hello"
12:21:22 <lambdabot>  array (0,4) [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
12:21:35 <Olathe> > chr 64
12:21:36 <lambdabot>  '@'
12:21:39 <omnId> LoganCapaldo: ooh!  instance IsString ShowS where fromString = showString
12:21:42 <Olathe> > ord '@'
12:21:43 <lambdabot>  64
12:21:48 <SideFFect> too much code being typed :p
12:21:56 <omnId> LoganCapaldo: then we get juxtapositioned concat!
12:21:57 <SamB> hmm. I suppose it depends how you do it...
12:22:07 <SamB> but it can't be better than O(n)
12:22:10 <Olathe> @scheck \a -> a == (chr.ord) a
12:22:11 <lambdabot>   Completed 7 test(s) without failure.
12:22:13 <magnusth> I've seen others do the same thing... does anyone here have a more obfuscated way of listing their address?
12:22:14 <Olathe> @check \a -> a == (chr.ord) a
12:22:16 <lambdabot>  OK, passed 500 tests.
12:22:17 <omnId> LoganCapaldo: "strings" "next" "to" "each" "other!"
12:22:25 <SamB> I think you can do binary searches of lists in O(n)
12:22:33 <Karle> hi omnId
12:22:39 <omnId> LoganCapaldo: the first four become ShowS's, the last a String.
12:22:45 <omnId> hello, Karle
12:22:45 <SamB> but I think the constant factor is worse than linear searches
12:22:49 <magnusth> chr ''
12:23:03 <omnId> Karle: just paste your question
12:23:12 <Karle> omnId, ok thanks
12:23:15 <magnusth> map chr ""
12:23:22 <newsham> side: when you pick the 5th element out of a list it has to walk over the first four.  when you pick the fifth element out of an array it just goes right to the fifth element
12:23:23 <SamB> plus you need to keep the list in memory when you do a binary search ;-)
12:23:26 <magnusth> > map chr ""
12:23:27 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
12:23:33 <omnId> @type chr
12:23:34 <lambdabot> Int -> Char
12:23:36 <omnId> you want ord
12:23:38 <magnusth> > map ord ""
12:23:39 <lambdabot>  [229]
12:24:03 <Olathe> > chr 198349839024803924
12:24:04 <lambdabot>  Exception: Prelude.chr: bad argument
12:24:11 <Olathe> So there is a limit.
12:24:12 <magnusth> omnId, interesting, what system is the evaluation performed on?
12:24:24 <omnId> magnusth: hm?
12:24:41 <omnId> magnusth: you mean what box LB lives on?
12:24:43 <magnusth> omnId, map ord "" -> [195,165] on my system
12:24:56 <newsham> > chr 65535
12:24:57 <lambdabot>  '\65535'
12:25:00 <newsham> > chr 65536
12:25:01 <lambdabot>  '\65536'
12:25:04 <magnusth> > ord ''
12:25:05 <lambdabot>  Improperly terminated character constant at "''" (column 5)
12:25:05 <omnId> > chr 229
12:25:06 <lambdabot>  '\229'
12:25:10 <SamB> magnusth: lambdabot does not deal well with UTF-8
12:25:17 <Olathe> > chr (2^10000000000000000)
12:25:18 <lambdabot>  '\NUL'
12:25:27 <Olathe> But there isn't a limit :(
12:25:28 <newsham> > chr 2147483648
12:25:29 <lambdabot>  Exception: Prelude.chr: bad argument
12:25:33 <newsham> > chr 2147483647
12:25:34 <magnusth> SamB, that's what made me curious :)
12:25:34 <lambdabot>  Exception: Prelude.chr: bad argument
12:25:46 <Olathe> chr is insane !
12:25:48 <omnId> > maxBound :: Char -- newsham
12:25:49 <lambdabot>  '\1114111'
12:25:54 <SamB> magnusth: I believe lambdabot doesn't know UTF-8 exists
12:25:56 <newsham> omni: danke
12:26:17 <magnusth> > map (chr . ord) ""
12:26:18 <lambdabot>  "\229"
12:26:41 <Olathe> @version
12:26:41 <lambdabot> lambdabot 4p575, GHC 6.6 (Linux i686 2.66GHz)
12:26:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:26:43 <hpaste>  Karle pasted "help" at http://hpaste.org/3646
12:26:46 <magnusth> > map (chr . ord) "a"
12:26:48 <lambdabot>  "a"
12:27:51 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3646#a1
12:27:58 <omnId> Prelude> map Data.Char.ord ""
12:27:59 <omnId> [229] -- but I'm using a crappy Windows terminal
12:29:21 <monochrom> > chr 4294967361
12:29:21 <Olathe> > 2^32
12:29:23 <lambdabot>  'A'
12:29:23 <lambdabot>  4294967296
12:29:26 <monochrom> hehehehe!
12:29:40 <Olathe> > ord '\1114111'
12:29:40 <lambdabot>  Character constant out of range at "'\111..." (column 5)
12:29:48 <Olathe> > ord '\1114110'
12:29:48 <lambdabot>  Character constant out of range at "'\111..." (column 5)
12:29:55 <omnId> Olathe: the parser's a little broken
12:29:56 <Olathe> :|
12:29:59 <Olathe> Ahh.
12:30:07 <TomMD> @botsnacks
12:30:08 <lambdabot> :)
12:30:12 <TomMD> He's back!
12:30:12 <lambdabot> TomMD: You have 1 new message. '/msg lambdabot @messages' to read it.
12:30:12 <Karle> omnId, I have posted on Hpaste :)
12:30:19 <SideFFect> wait a sec...we never learned how to use arrays so how can he ask us that for the assignment?
12:30:40 <omnId> TomMD: "He"?  You're not talking about LB are you?
12:30:48 <TomMD> I am ;-)
12:30:49 <monochrom> not for the assignment. for education. self-education.
12:30:52 <omnId> @quote female
12:30:53 <lambdabot> lambdabot says: Of course i'm female
12:31:07 <TomMD> Yes yes, I remembered when you exclaimed.
12:31:35 <newsham> ?quote feeling
12:31:35 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
12:31:36 <omnId> Karle: what are the two Int's that zipWithU requires?
12:31:50 <SideFFect> still, its not quite fair dropping us into a new language and saying, here, learn it all youself, have fun!
12:32:00 <SideFFect> why am I paying the school then?
12:32:03 <SideFFect> i can do that myself
12:32:11 <Karle> omnId, it does not say in my manual
12:32:26 <omnId> Karle: then I'm sorry, but I cannot really help you :(
12:32:37 <Karle> no problem omnId
12:32:42 <swiert> SideFFect: have you considered building a binary search tree and using that?
12:32:52 <SamB> SideFFect: yes but can you give yourself college credit for that?
12:33:00 <magnusth> @where hprint
12:33:00 <lambdabot> I know nothing about hprint.
12:33:06 <monochrom> The assignment only requires lists. We are saying you may learn arrays as a side interest.
12:33:25 <SideFFect> um why pay to have them not help us?
12:33:28 <SamB> perhaps the teacher doesn't realize that lists aren't arrays?
12:33:38 <SideFFect> I think he doesnt realize that yes
12:33:48 <monochrom> Or more generally, the assignment only requires what the school has taught you. We are saying you may learn more as a side interest.
12:34:00 <SideFFect> I know, and I would not mind, had I have the time
12:34:01 <SamB> perhaps someone else had been intended to teach the class...
12:34:13 <SideFFect> but I dont and I HOPED school would have prepared me for the assignments
12:34:33 <ddarius> The law of revealed preference
12:34:43 <ddarius> s/law/principle
12:35:09 <SamB> SideFFect: well, who's fault is it that you don't have the time?
12:35:34 <SideFFect> of course, mine
12:35:54 <monochrom> I wouldn't say "fault". But I would say, perhaps you should review your rationale for staying in school and paying, as you said.
12:36:03 <SideFFect> well one last term
12:36:13 <SideFFect> I just want to leave, give my school the finger, and thats that
12:36:28 * LoganCapaldo feels funny because he's been at this haskell thing for several months (maybe a year or more?) and he still hasn't found a compelling reason to learn to use arrays in haskell
12:36:33 <monochrom> You can do that now.
12:36:45 <monochrom> But you won't get the diploma.
12:36:47 <fasta> I have a datatype containing a . Is there any way I can write a derived Show instance of that to a file that is readable by e.g. VIM or Emacs or anything else? I have written the obvious code, but it shows a question mark in the file.
12:36:57 <monochrom> So it comes down to: you're paying for that sheet of paper.
12:37:02 <newsham> stay in school, learn lots of cool stuff..  work is hard and doesn't always give you the ability to choose your persuis ;-)
12:37:06 <newsham> persuits
12:37:06 <SamB> SideFFect: maybe they had this class prepared as a special treat for people who feal that way ;-)
12:37:26 <SamB> man is my spelling bad
12:37:28 <SideFFect> heh maybe
12:37:34 <mauke> LoganCapaldo: http://www.spoj.pl/problems/FOOL/ ?
12:37:39 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem FOOL
12:37:40 <liyang> fasta: you may need to fiddle with the various termencoding and fileencoding settings in Vim.
12:37:56 <fasta> liyang: and for Emacs?
12:38:03 <SamB> it just seems that, if you can afford to go to school longer, you ought to consider it
12:38:08 <liyang> fasta: my hands aren't big enough.
12:38:08 <ddarius> LoganCapaldo: Arrays aren't usually what you want.
12:38:26 <b_jonas> I'd like to know how exceptions work in haskell
12:38:30 <me> hello=
12:38:30 <lambdabot> me: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:38:36 <b_jonas> is there some writeup explaining that/
12:38:45 <b_jonas> ?
12:38:50 <fasta> b_jonas: abortive continuations, AFAIK.
12:38:50 <ddarius> b_jonas: The report explains Haskell 98 exceptions.
12:38:51 <mauke> fasta: you mean show x gives you a string containing '\948'?
12:38:53 <SamB> @google imprecise exceptions haskell
12:38:55 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/imprecise-exn.htm
12:38:55 <lambdabot> Title: Simon Peyton Jones: papers
12:39:08 <fasta> mauke: that's what happens in Haskell mode in Emacs, yes.
12:39:08 <monochrom> Yes, LoganCapaldo, arrays are overrated. Only real use is linear algebra. All other uses are false uses, encodings (sometimes obfuscated) of other data structures. For example, I have seen C programmers encoding graphs into arrays. Subsequently their graph algorithms are also slow.
12:39:15 <b_jonas> "7.3  Exception Handling in the I/O Monad"
12:39:17 <b_jonas> that must be it
12:39:23 <fasta> mauke: but when I do writeFile .... and do cat I see a question mark.
12:39:26 <mauke> fasta: how do you print that? using the string functions in System.IO?
12:39:31 <b_jonas> is that limited to io exceptions or can I define my own exception types with that?
12:39:33 <mauke> yeah, those are broken
12:39:43 <fasta> mauke: what isn't broken?
12:39:44 <mauke> you have to do your own encoding
12:39:47 <liyang> fasta: oh. It's actually writing out a question mark to the file...(?)
12:40:05 <fasta> liyang: I have no idea what it is doing, since I didn't write the compiler.
12:40:26 <ddarius> b_jonas: For Haskell 98 exceptions, you are pretty limited.
12:40:26 <b_jonas> monochrom: arrays are overrated but I think you're underrating them
12:40:39 <liyang> hexdump the file. See if it's a question mark or some encoding of your character.
12:40:42 <fasta> (and I always forget the hex tools to see what it contains exactly, since I rarely need them)
12:40:47 <fasta> liyang: :)
12:40:55 <liyang> fasta: xxd if you're on a unixy system.
12:41:09 <fasta> liyang: yes, I found it
12:41:13 <b_jonas> ddarius: what should I use if I want to define my own exceptions then?
12:41:23 <mauke> open file in vim, move cursor on character, ga
12:41:32 <fasta> http://paste.debian.net/41490
12:41:34 <liyang> (xxd comes with Vim. Vim uses it to hexedit files.)
12:41:50 <mauke> great, but that hexdump is hard to read
12:42:04 <ddarius> b_jonas: If you want to stick to Haskell 98, you can use an exception monad.  If you don't mind being GHC specific, it supports exceptions quite a bit more, though even then often an exception monad is the best approach.
12:42:08 <fasta> hex 00b4
12:42:15 <mauke> U+00B4 (0xc2 0xb4): ACUTE ACCENT []
12:42:30 <fasta> mauke: right, that's what VIM displays
12:42:36 <fasta> mauke: but it's not the delta.
12:42:43 <b_jonas> ddarius: by exception monad, you mean treating raising an exception an impure operation, right/
12:42:45 <_ry> how do i flush stdout?
12:42:51 <mauke> fasta: because there's no delta in your file
12:43:12 <desegnis> U+03B4 GREEK SMALL LETTER DELTA
12:43:15 <ddarius> b_jonas: I don't know what you mean by that, but I'm suspecting the answer is no, that is not what I mean.
12:43:27 <desegnis> So the lower bits are identical
12:43:29 <ddarius> b_jonas: I mean like using Maybe or Either or ErrorT.
12:43:36 <fasta> mauke: writeFile file (show foo) where foo is a datatype containing delta.
12:43:44 <mauke> fasta: yes, I know
12:43:52 <SamB> http://research.microsoft.com/Users/simonpj/Papers/imprecise-exn.htm talks about what REALLY happens...
12:43:54 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/38yur4
12:44:06 <b_jonas> @where ErrorT
12:44:06 <lambdabot> I know nothing about errort.
12:44:09 <LoganCapaldo> mauke: that problem doesn't seem like a reason to use arrays in haskell, but maybe I'm just not seeing it?
12:44:15 <ddarius> @index ErrorT
12:44:15 <lambdabot> Control.Monad.Error, Control.Monad.Error
12:44:16 <b_jonas> @src ErrorT
12:44:16 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
12:44:17 <mauke> LoganCapaldo: how would you solve it?
12:44:33 <fasta> mauke: ok, sorry, so is there anyway currently that enables me to write such a string to a file and see a delta?
12:44:35 <omnId> _ry: something like: hFlush stdout
12:44:39 <omnId> @index hFlush
12:44:39 <lambdabot> System.IO
12:44:41 <desegnis> I guess that ghc realizes that the delta is one UTF-8 character, but later forgets that it's actually an UTF-8 character.
12:44:42 <omnId> @index stdout
12:44:42 <lambdabot> System.IO
12:44:49 <omnId> _ry: yeah, that's it :)
12:44:50 <b_jonas> Control.Monad.Error... that's not included with ghc 6.6
12:44:52 <mauke> fasta: yes, do your own encoding. or find a library that does it for you.
12:44:57 <b_jonas> am I using an ancient version?
12:45:00 <monochrom> writeFile doesn't produce UTF-8. It produces ISO-8859-1. It throws away higher bits.
12:45:00 <mauke> desegnis: there's no such thing as an UTF-8 character
12:45:02 <ddarius> b_jonas: It's in the mtl package.
12:45:09 <monochrom> Note that show, OTOH, is correct.
12:45:20 <ddarius> b_jonas: I believe they stop distributing it with GHC 6.6.  Otherwise, it's extremely old.
12:45:26 * LoganCapaldo feels like he's being tricked somehow
12:45:30 <desegnis> mauke: Right, I meant: the two bytes represent one character
12:45:30 <ddarius> (The mtl package that is.
12:45:45 <fasta> mauke: Yes, you said so, but I doesn't that require me to read the specification for lots of formats?
12:45:48 <mauke> desegnis: haskell never has two bytes there
12:45:50 <dons> if you need utf8, use the utf8-string package on hackage
12:45:56 <mauke> fasta: only for the one you want to generate
12:46:04 <monochrom> Too much noise.
12:46:07 <mauke> and utf8 is relatively simple to generate yourself
12:46:11 <SamB> fasta: no
12:46:22 * b_jonas installs mtl
12:46:23 <SamB> you could read the really short and sweet UTF-8 manpage though
12:46:34 <desegnis> mauke: Er, I supposed that the delta is UTF-8 encoded in fasta's code.
12:46:43 <SamB> that should be enough to convince you that there is no such thing as a UTF-8 character
12:46:44 <fasta> So, I just grab the utf8-string package and be done with it.
12:46:46 <mauke> desegnis: it isn't
12:46:47 <fasta> Thanks dons
12:46:48 <ddarius> b_jonas: The mtl package is something that you will be using constantly.
12:47:00 <desegnis> mauke: Then my comments were irrelevant.
12:47:25 <fox86> hmm, i am having some type problems: http://hpaste.org/3647 ... any idea?
12:47:26 <_ry> how do you access command line arguments in haskell?
12:47:44 <mauke> _ry: System.Environment.getArgs or something like that
12:47:54 <ddarius> @index getArgs
12:47:54 <lambdabot> System.Environment
12:47:59 <LoganCapaldo> mauke: I'd probably try to use ReadP. Can I ask how you'd use an array?
12:48:02 <mauke> quick and dirty utf-8 encoder: http://rafb.net/p/Lo9Wam80.html
12:48:03 <lambdabot> Title: Nopaste - No description
12:48:16 <mauke> LoganCapaldo: is ReadP a non-deterministic parser?
12:48:21 <LoganCapaldo> yar
12:48:25 <desegnis> (And I now realize that the UTF-8 representation would have been 0xceb4, so I was still wrong somewhere else)
12:48:31 <mauke> LoganCapaldo: using lists for backtracking?
12:48:43 <trippo_> fox86: solveQuadratic :: Double -> Double -> Double -> (Double, Double) I guess
12:49:21 <mauke> because I tried that and it was much too slow
12:49:27 <LoganCapaldo> I don't think it backtracks so much as as tries everything upfront but yeah
12:49:29 <b_jonas> is there some type issue stopping one from having exceptions of the type you define in just IO without an extra monad?
12:50:03 <dons> nope.
12:50:09 <mauke> http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Exception.html
12:50:10 <LoganCapaldo> How'd you use an array?
12:50:11 <lambdabot> http://tinyurl.com/337c2e
12:50:11 <dons> see throwDyn et al
12:50:14 <mauke> DynException
12:50:18 <dons> ?index throwDyn
12:50:18 <lambdabot> Control.Exception
12:50:30 <mauke> LoganCapaldo: for caching intermediate parse results
12:50:54 <mauke> dynamic programming, etc
12:50:59 <LoganCapaldo> So packrat style?
12:51:12 <mauke> no idea :-)
12:51:17 <b_jonas> hmm
12:51:20 <b_jonas> so there is a type issue
12:51:23 <mauke> I don't know how packrat parsing works
12:51:37 <b_jonas> but they've put a typeable exception to go around that
12:51:45 <SamB> mauke: well, you have an n*m table
12:52:48 <SamB> n is the length of the input, m is the number of nonterminals
12:53:48 <SamB> each store tells what happens when you try to parse that nonterminal there
12:53:52 <SamB> er.
12:53:56 <SamB> s/store/cell/
12:54:13 <SamB> we
12:54:25 <omnId> b_jonas: not really an issue, just a workaround since the provided Exception type isn't extendable.  The (Either YourException) and (ErrorT YourException m) monads give you flexibility.
12:54:27 <SamB> well, I guess it's actually (n+1)*m
12:54:27 <salierix> Can haskell run code from a shared library written in C?
12:54:39 <SamB> salierix: with the FFI, yes
12:55:16 <SamB> though you might need to write some C to handle some of the details
12:55:35 <salierix> That's fine. Any good tutorials on using the FFI?
12:55:53 <mauke> @where ffi
12:55:53 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
12:56:00 <SamB> tutorials?
12:56:15 <mauke> ITYM papers!
12:56:32 <SamB> or possibly layered tools
12:56:45 <salierix> Wha?
12:57:45 <SamB> we don't know of any tutorials in using the FFI directly that are available in HTML
12:58:18 <SamB> well, I don't, anyway
12:59:03 <fasta> What is the default installation directory for documentation for cabal installed packages?
12:59:31 <SamB> fasta: did you install the documentation?
12:59:44 <fasta> SamB: I just did cabal install <package>
12:59:56 <SamB> did you *build* the documentation?
13:00:23 <fasta> SamB: Ok, so it didn't.
13:00:58 <fasta> SamB: I kind of assumed that it did, since it would be kind of pointless not to build it, I guess.
13:01:51 <fasta> It seems there's no option for cabal install to do so... which means I still need to do it by hand...
13:04:11 <SideFFect> can I go back in time and punch the haskell maker in the face? :D
13:04:30 <fasta> SideFFect: you don't need to go back in time for that.
13:04:40 <SamB> fasta: maybe you should see how dh_haskell does it
13:04:43 <fasta> SideFFect: I doubt you will win against all those people though.
13:04:48 <dons> SideFFect: where are you stuck now?
13:04:54 <dons> did you get your loops working?
13:04:54 <fasta> SamB: dh_haskell?
13:05:06 <dons> hackathon photos from kolmodin, http://picasaweb.google.com/kolmodin/Freiburg2007/photo#5128755348269266082
13:05:09 <lambdabot> Title: Picasa Web Albums - Lennart Kolmodin - Freiburg 2007, http://tinyurl.com/2ao87m
13:05:21 <SideFFect> stuck...I think I need to restart, because I cant do my assign with lists, and if I do, I need to do ALOT more work then my algo is now
13:05:33 <SideFFect> we didnt learn arrays yet so I doubt we need to use them
13:05:34 <ari> SideFFect: If you're making a monad and don't know how to implement fail, feel free to enter the time machine :)
13:05:36 <dons> aren't you supposed to use lists in the haskell version?
13:05:41 <SideFFect> hehe
13:05:59 <SideFFect> yeah but im not sure how to read positions of lists and ugh :P
13:06:05 <SamB> fasta: or, at least, how existing debianized haskell libraries install documentation...
13:06:10 <dons> SideFFect: !! is the operator
13:06:14 <dons> > "haskell" !! 3
13:06:15 <mauke> SideFFect: list !! index
13:06:15 <lambdabot>  'k'
13:06:23 <SideFFect> yeah he told us that
13:06:28 <dons> you should really read Data.List too
13:06:38 <dons> so you know what functions are available on the data you're working with
13:06:39 <SamB> if anyone knows how, won't it be Igloo?
13:06:40 <dons> ?docs Data.List
13:06:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:06:43 <fasta> SamB: runhaskell Setup.lhs haddock, or something like that
13:06:46 <SideFFect> but then first I have to get the length of the list in order to find the last element
13:06:55 <mauke> SideFFect: length
13:06:56 <SamB> fasta: that builds them nicely enough
13:07:05 <dons> > length "haskell"
13:07:06 <lambdabot>  7
13:07:15 <fasta> SamB: but it requires me to do the exact same step again.
13:07:17 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
13:07:18 <SideFFect> heh love the bot
13:07:18 <lambdabot> http://tinyurl.com/2lz9qt
13:07:24 <dons> > let s = "haskell"; n = length "haskell" in s !! (n-1)
13:07:26 <lambdabot>  'l'
13:07:36 <fasta> SamB: usability can be trivially better.
13:07:52 <SamB> fasta: I don't doubt it
13:07:53 <fox86> trippo_: thanks. now i get wrong numbers, but atleast it produces some
13:08:11 <LoganCapaldo> oh happy day
13:08:21 <LoganCapaldo> my ghc finally finished compiling
13:08:22 <salierix> Why was Data.FiniteMap changed to Data.Map? Looks like a lot of the function names were changed too
13:08:46 <liyang> salierix: making people normal.
13:08:46 <salierix> LoganCapaldo, you actually compiled it?
13:09:16 <dons> > let s = "haskell"; n = length "abc" in s !! (n-1)
13:09:17 <LoganCapaldo> indeed
13:09:18 <lambdabot>  's'
13:09:28 <dons> > let s = "abc"; n = length s in s !! (n-1)
13:09:29 <fasta> GHC is easy to compile when it's not broken :)
13:09:30 <lambdabot>  'c'
13:09:31 <dons> :}
13:09:34 <fox86> not sure why this gives me bad values? http://hpaste.org/3647#a2
13:09:37 <LoganCapaldo> for their were no binaries for my platform
13:09:49 <LoganCapaldo> and I am relatively impatient <g>
13:10:04 <SamB> salierix: and types, even!
13:10:08 <salierix> LoganCapaldo, what's your platform?
13:10:17 <LoganCapaldo> os x ppc
13:10:18 <SamB> salierix: why are you asking this question in 2007?
13:10:31 <salierix> SamB, What question?
13:10:55 <mauke> fox86: precedence
13:10:57 <SamB> about Data.FiniteMap being replaced with Data.Map
13:11:09 <mauke> fox86: b / 2 * a is equivalent to (b / 2) * a
13:11:25 <salierix> SamB, because programs are still around that haven't been updated to use Data.Map?
13:11:47 <SamB> salierix: really?
13:11:54 <mauke> not for long, as they don't compile anymore!
13:11:57 <SamB> what programs?
13:12:13 <fasta> Of course there are programs, they are just not widely available.
13:12:19 <SamB> well, okay
13:12:26 <fasta> And are now actively gathering dust
13:12:27 <SamB> I expect I wrote some and haven't updated them
13:12:39 <SamB> but I think mine are gathering dust passively
13:12:54 <salierix> I wanted to try the Nethack clone I found in the "Applications and libraries" section of haskell.org
13:13:04 <SamB> oh
13:13:06 <dons> ?users
13:13:06 <lambdabot> Maximum users seen in #haskell: 424, currently: 396 (93.4%), active: 25 (6.3%)
13:13:24 <fox86> mauke: aah. thank you. i thought * had higher precedence than /
13:13:41 <mauke> I don't think any language does that
13:13:55 <thoughtpolice> dons: hm just wondering, since you're probably getting lambdabot up to speed for 6.8.1, are there any plans for upgrading hs-plugins at this point, or am i kind of SOL currently?
13:14:51 <b_jonas> mauke: there is
13:14:58 <b_jonas> gwbasic is documentedly like that
13:15:04 <SamB> thoughtpolice: I heard that the plan was that GHC would provide hs-plugins with the mechanisms it needs, so that hs-plugins won't need updating every GHC release
13:15:13 <b_jonas> but you can regard any language that only has + - * / as that
13:15:30 <b_jonas> even though it's traditionally described as / and * having the same precedence
13:16:24 <SamB> thoughtpolice: however I am not sure when this plan is supposed to come to fruition ;-)
13:16:40 <b_jonas> (a*b)/c and a*(b/c) are mathematically equivalent, though they're not if you use floats or integers
13:16:51 <b_jonas> so either parsing of a*b/c makes sense
13:16:58 <mauke> we're talking about a/b*c
13:17:09 <thoughtpolice> SamB: the ghc-api lib I released should work on GHC 6.8 with some patches I haven't applied yet, and it provides basic eval and plugin-like facilities,
13:17:14 <b_jonas> gwbasic will parse it as a*(b/c) and c as (a*b)/c
13:17:19 <thoughtpolice> the main reason I ask is because the irc bot i'm working on also does hot code swapping,
13:17:29 <thoughtpolice> but I haven't figured out quite how to do this with the GHC API itself yet,
13:17:29 <b_jonas> mauke: hmm
13:17:30 <b_jonas> I see
13:17:41 <b_jonas> indeed you said "* had higher precedence"
13:17:42 <b_jonas> sorry
13:17:47 <thoughtpolice> although it does seem to be possible.
13:17:55 <SamB> thoughtpolice: I'm not sure what interface they were planning for hs-plugins to use...
13:17:56 <b_jonas> that's rarer but exists
13:17:58 <thoughtpolice> i'll probably have to spend some time under compiler/main
13:18:10 <salierix> Will the next GHC release be 7.0 or 6.10?
13:18:34 <b_jonas> actually I've only heared of languages where an implicit multiplication has higher precedence than * or /
13:18:34 <SamB> who knows?
13:18:34 <fasta> Wow, the first library that did something useful for me besides base :)
13:18:35 <thoughtpolice> the main thing is unloading resident modules from memory
13:18:55 <SamB> I guess either way the development branch would probably be called 6.9?
13:18:57 <ddvlad> hi, how can i convert from an Integer to an Int? assuming the value is sufficienly small to fit in an Int
13:19:03 <thoughtpolice> once I can do that with the API the lib should be able to work like I need it to, I guess
13:19:05 <mauke> ddvlad: fromInteger
13:19:27 <ddvlad> mauke: fromInteger 3 gives me an Integer
13:19:40 <mauke> > length "" + fromInteger 3
13:19:41 <liyang> > fromInteger 3 :: Int
13:19:49 <lambdabot>  3
13:19:50 <lambdabot>  3
13:19:51 <mauke> no, it doesn't
13:19:57 <b_jonas> liyang: take care, that's a ghc extension
13:20:02 <liyang> Hm. Which 3 is my 3? ...
13:20:07 <thoughtpolice> in any case I'm just wondering. :) i'll keep a copy of ghc 6.6 around for a while so I can still build and work on my IRC bot
13:20:16 <ddvlad> hmm... i'll check
13:20:19 <b_jonas> :t fromInteger 3
13:20:20 <lambdabot> forall a. (Num a) => a
13:20:37 <liyang> b_jonas: yarrh.
13:20:38 <fasta> salierix: 6.10
13:20:41 <b_jonas> > let x :: Int; x = fromInteger 3 in x
13:20:43 <lambdabot>  3
13:20:51 <ddvlad> ok, fromInteger 3 :: Int works
13:20:52 <faxathisia> Hi
13:20:53 <b_jonas> liyang: a useful one, I admit
13:20:54 <ddvlad> thank you
13:20:58 <LoganCapaldo> b_jonas: it is? Sad face.
13:21:12 <b_jonas> LoganCapaldo: so I've heared
13:21:21 <faxathisia> > (empty ! 0) :: Int -- gives me this exception
13:21:22 <lambdabot> Terminated
13:21:39 <fasta> I am not sure how large the difference should be to call anything 7.0, since the difference between 6.2 and 6.8 is gigantic already.
13:21:52 <faxathisia> Does it seem wise to (since I want the default value to be 0) create a new operator which returns a default?
13:21:59 <faxathisia> in the case that the key is not in the map
13:22:31 <mauke> foo = findWithDefault 0
13:22:54 <faxathisia> ohh great, thanks very much mauke
13:25:46 <SamB> now at this point we could get into a philosophical discussion about whether or not that counts as a new operator...
13:26:06 <ari> :t findWithDefault
13:26:07 <lambdabot> Not in scope: `findWithDefault'
13:26:07 <SamB> probably after s/operator/function/
13:26:18 <faxathisia> I was probably going to find something which looks like ! to use.. but findWithDefault is a better name :)
13:26:28 <faxathisia> and especially since it already exists
13:26:29 <ari> :t Data.Map.findWithDefault
13:26:30 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
13:26:42 * ari sees
13:26:56 <JFT> Hello all, I have a question regarding strictness annotation (if that's how it is called :P)
13:27:29 <SamB> JFT: yes?
13:27:32 <JFT> Are strictness annotation, when used in "struct" always an optimisation?
13:27:49 <JFT> or are they required to get a specific semantic meaning?
13:27:51 <SamB> if they were... why would we have them?
13:28:02 <SamB> always an optimization, I mean
13:28:20 <JFT> I'm not following you there ...
13:28:44 <dons> they're not always an optimisation
13:28:50 <mauke> if they were just an optimization, the compiler could simply add them everywhere
13:29:06 <dons> but they do let you hint at a particular evaluation order that might be better than the compiler picks
13:29:17 <dons> esp. if you're doing low level code, and have empirical data handy
13:29:32 <dons> so you tend to see them in low level programs, or more rarely, when strictness analysis fails in the compiler
13:29:38 <JFT> I have 2 exemple at hands
13:29:39 <SamB> and they also allow you to ask the compiler to {-# UNPACK #-} stuff...
13:29:53 <JFT> file:///Users/jftremblay/Documents/Documentation/Lang/Haskell/libraries/parsec/Text-ParserCombinators-Parsec-Error.html
13:29:58 <dons> yes, they rule out bottom in the type,meaning the compiler can do a few alternative optimisations
13:30:09 <JFT> oups I meant to post the parsec GHC doc page
13:30:19 <JFT> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec-2.1.0.0/Text-ParserCombinators-Parsec-Error.html
13:30:20 <lambdabot> http://tinyurl.com/2jgv5x
13:30:38 <JFT> Message is defined with strictness annotation there
13:31:00 <JFT> how can it be "guessed" (if it can) whether they are an optimization or required?
13:31:13 <SamB> very carefully!
13:31:19 <JFT> The Yampa Arcade paper also used them
13:31:24 <JFT> for the game state objects
13:31:34 <dons> yes, with experience, and a knowledge of the runtime semantics and compilation process
13:31:49 <JFT> any reading I could do to enlight me ?
13:31:57 <SamB> ... I do not know of any cases, aside from unsafe*, where they are actually needed in theory...
13:32:10 <JFT> SamB: Interesting!
13:32:25 <SamB> or, that is, where strictness is needed
13:33:03 <JFT> Would you conccur with that Don?
13:33:09 <SamB> of course, in theory, the stack can have indefinate size...
13:33:19 <joelr1> good evening! has anyone built ghc 6.8 on leopard?
13:33:25 <joelr1> i'm gettng "ghc-pkg: dependency readline doesn't exist "
13:33:26 <JFT> sure but then it becomes "optimization" :P
13:33:37 <joelr1> when building without extra libraries
13:33:47 <faxathisia> @hoogle XOR
13:33:48 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
13:33:50 <SamB> so yeah, what dons said
13:33:54 <JFT> joelr1: sorrry still on Tiger
13:33:59 <faxathisia> @pl Data.Bits.xor 1 2
13:33:59 <lambdabot> Data . Bits . xor 1 2
13:34:09 <faxathisia> -_-
13:34:17 <faxathisia> is there an operator for xor?
13:34:18 <SamB> you will learn them with experience and knowlege of the secret semantics of haskell
13:34:26 <sjanssen> JFT: strictness annotations can and do change the semantics of programs
13:34:26 <dmwit> joelr1: The build process is seeing the system's readline before the (gnu) readline, even if you have it installed.
13:34:28 <omnId>  @pl no liek qualifications
13:34:38 <dmwit> joelr1: Let me take a look at my logs, some other people have solved this problem recently.
13:34:48 <salierix> Just what is unsafePerformIO?
13:34:49 <omnId> faxathisia: for logical xor between Bools, use (/=)
13:34:49 <joelr1> dmwit: awesome
13:35:00 <faxathisia> I need to a bitwise xor though
13:35:09 <omnId> faxathisia: then use Data.Bits.xor
13:35:12 <SamB> sjanssen: yes, but if your program worked with them, and didn't do anything unsafe, it ought to work without them... oh... except for hGetContents...
13:35:13 <faxathisia> ok thanks
13:35:21 <omnId> > Data.Bits.xor 5 3
13:35:25 <lambdabot>  Add a type signature
13:35:30 <omnId> > Data.Bits.xor 5 3 :: Int
13:35:31 <lambdabot>  6
13:35:44 <Olathe> > Data.Bits.xor 5 3 :: Maybe Char
13:35:45 <lambdabot>   add an instance declaration for (Bits (Maybe Char))
13:35:45 <lambdabot>     In the expression: ...
13:35:50 <dmwit>  Nov 03 23:50:43 <glguy> http://mult.ifario.us/articles/2006/10/17/ghc-6-6-and-mac-os-x-readline-quick-fix
13:35:52 <omnId> @instances Bits
13:35:52 <lambdabot> Title: mult.ifario.us : GHC 6.6 and Mac OS X Readline Quick Fix, http://tinyurl.com/34yzc3
13:35:53 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
13:36:00 <omnId> @instances-importing Data.Bists Bits
13:36:01 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
13:36:01 <dmwit> joelr1: See that page, maybe?
13:36:02 <omnId> @instances-importing Data.Bits Bits
13:36:03 <lambdabot> Int, Integer
13:36:12 <omnId> @instances-importing Data.Bits Data.Int Data.Word Bits
13:36:13 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
13:36:17 <omnId> :)
13:36:23 <JFT> salierix: unsafePerformIO allows you to "extract" something out of the IO Monad, i.e. execute an IO action and return the undecorated result
13:36:32 <Olathe> Word !
13:36:38 <joelr1> dmwit: hmm... so it's the same issue then? did you build on leopard with that fix?
13:36:43 <faxathisia> huh
13:36:46 <dmwit> joelr1: I'm on Linux.
13:37:08 <joelr1> dmwit: ok, thanks then
13:37:19 <faxathisia> > (65536 + 1, 65536 + 1) :: (Int16, Word16)
13:37:21 <lambdabot>  (1,1)
13:37:28 <salierix> I thought you can't get something out of an IO monad?
13:37:28 <faxathisia> What's the difference between Int16 and Word16 ?
13:37:29 <LoganCapaldo> I did export READLINE_CFLAGS=-I/approp/path ; export READLINE_LDFLAGS=-L/approp/path
13:37:37 <LoganCapaldo> but I don't have leopard
13:37:49 <omnId> salierix: right, this is not referentially transparent, though, so you should largely not use it.  At the *very* least learn how GHC performs IO actions before using unsafePerformIO
13:37:51 <joelr1> LoganCapaldo: on leopard?
13:37:56 <joelr1> LoganCapaldo: i see
13:37:57 <SamB> salierix: not without proving that it is safe
13:38:05 <mauke> > (65536, 65536) :: (Int16, Word16)
13:38:06 <lambdabot>  (0,0)
13:38:07 <joelr1> LoganCapaldo: but you did get the same error, right?
13:38:08 <omnId> salierix: that's why it has the long ugly name.
13:38:09 <doctormach> joelr1: I'm building on Leopard right now with that fix, but it's not done so I don't know if it works or not
13:38:15 <mauke> > (65535, 65535) :: (Int16, Word16)
13:38:16 <salierix> Why does it exist at all?
13:38:16 <lambdabot>  (-1,65535)
13:38:22 <joelr1> doctormach: did you get to stage2?
13:38:24 <omnId> salierix: teh hax
13:38:26 <faxathisia> mauke: Aha! Thank you
13:38:30 <SamB> salierix: or at least accepting the responsibility of proving it
13:38:44 <joelr1> doctormach: this is where the error happens, right at the beginning. if you are seeing stage2 in the command lines then you are past it
13:39:02 <joelr1> btw, is it just me or is ghc building quite a bit faster?
13:39:02 <doctormach> joelr1: I'm not to stage2 yet
13:39:12 <SamB> salierix: well, it's handy for implementing things like arrays and packed strings and...
13:39:16 <JFT> SamB: Don: Thanks for the explanation, it's still a bit fuzzy in my mind, from what I grasp, unless dealing with IO monad strictness annotation are purely optimization...
13:39:19 <salierix> SamB, what do you mean by "safe"?
13:39:34 <Karle> hi sek
13:39:45 <SamB> salierix: well, that it will do what you want
13:40:00 * b_jonas stares at Control.Monad.Error
13:40:01 <b_jonas> docs
13:40:08 <sek> hiya Karle
13:40:17 <scsibug> joelr1: fyi, i've built 6.8.1 on leopard for intel/ppc
13:40:17 <SamB> salierix: this is of course very hard given that the semantics of unsafePerformIO have probably not yet been decided...
13:40:33 <joelr1> scsibug: did you use ./configure --with-readline-includes=/usr/local/include \
13:40:33 <joelr1>             --with-readline-libraries=/usr/local/lib ?
13:41:08 <SamB> the easiest thing is when you can prove that it will always return the same thing
13:41:18 <JFT> salierix: when you are operating in the IO monad (without exiting it) whatever you do is going to stay "consistent", if you use unsafePerformIO if you take lazyness into account you could "think" that you have wrote a file before reading it to realise it never happen (from that I understood :P)
13:41:36 <scsibug> joelr1: indeed I did.  The hard part was actually getting readline to compile.
13:41:51 <SamB> JFT: or you could evaluate the same expression twice and get two different values
13:41:59 <LoganCapaldo>  /me had had realine installed from fink
13:42:05 <LoganCapaldo> wow
13:42:06 <joelr1> scsibug: i don't get it. did you use /usr/include/... ? if so then you were using the system readline, no? then what were you building?
13:42:22 <JFT> SamB: oh yes.. Unsafe is dangerous :P
13:42:35 <salierix> I ask because I saw that hmp3 seems to use it for a global variable.
13:42:36 <scsibug> joelr1: you can see some more verbose notes at http://scsibug.com/2007/11/03/ghc-681-darwinppc-build/
13:42:38 <lambdabot> Title: scsibug.com  GHC 6.8.1 OS X Builds
13:42:46 <SamB> it could confuse the compiler when that happens
13:43:02 <SamB> more importantly, you could try to evaluate the same expression twice and get one value
13:43:12 <SamB> because the compiler decided to evaluate it only once
13:43:14 <jakub2007> hi I am writing a simple cgi program I have my cgiMain :: CGI CGIResult as per documentation but now i want do some IO inside it hower I'm gettin    Couldn't match expected type `CGIT IO t'
13:43:14 <jakub2007>            against inferred type `IO a'
13:43:14 <jakub2007> g
13:43:15 <omnId> salierix: in essence, using unsafePerformIO forces you to think about the actual evaluation order of your program, and given that it's not very narrowly specified so the compiler can do magical things, this is very hard.
13:43:23 <SamB> but you wanted two different values
13:43:36 <LoganCapaldo> jakub2007: lift
13:43:42 <LoganCapaldo> @type lift
13:43:43 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:44:06 <omnId> lift :: IO a -> CGI a
13:44:06 <faxathisia> hmm
13:44:25 <LoganCapaldo> omnId: I said that already <g>
13:44:25 <faxathisia> I'd like to ask someones opinion on what's better out of two ways to write this
13:44:26 <joelr1> scsibug: so you did not have readline and thus built and installed it in /usr/include? i'm clearly missing something
13:44:27 <scsibug> joelr1: so, I used /usr/local/include, and the readline was one that I built from scratch, not apple's.
13:44:38 <omnId> LoganCapaldo: yeah, just specifying more simply :)
13:44:53 <joelr1> scsibug: why a new one? why not apple's?
13:44:57 <LoganCapaldo> apple's readline is a rebranded libedit IIRC
13:44:57 <scsibug> joelr1: I had readline installed as a framework, but could not get GHC to accept that.
13:45:13 <scsibug> joelr1: as logan just said, apple's is crippled
13:45:22 <joelr1> scsibug: gotcha
13:45:24 <hpaste>  faxathisia pasted "which is the better way?" at http://hpaste.org/3648
13:45:32 <SamB> at least now I think it has been decided that unsafePerformIO should evaluate it's argument a WHOLE number of times
13:45:32 <faxathisia> Any thoughts please? :|
13:45:38 <joelr1> scsibug: i must point to /opt/local/include/... then since i have readline from darwinports
13:45:39 <SamB> er... run, I mean
13:45:50 <scsibug> joelr1: sounds right
13:45:57 <SamB> that is, the argument won't be aborted because of blackholing anymore...
13:46:21 <JFT> Thanks for the help guys gotta run
13:46:42 <monochrom> faxathisia: I like the second personally - I like factorings - but this case is small enough that it doesn't matter alot.
13:46:43 <omnId> faxathisia: maybe if you factor the ugly case into its own name, I'd probably go with the case -> functions.
13:46:43 <jakub2007> thanks for the lift pointer. Did anybody else noticed that there is a problem with haskell website. For example this returns 404. -> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Trans.html
13:46:45 <lambdabot> http://tinyurl.com/yqbbla
13:47:05 <TomMD> jakub2007: Yeah, several people mentioned it.
13:47:12 <omnId> faxathisia: name it opToFun or something.
13:47:24 <dmwit> f AssignAdd = (+); f AssignSub = (-); f AssignXOR = Data.Bits.xor
13:47:36 <omnId> f op = case op of ...
13:47:47 <dmwit> Then you can use (insert lval (f op) ctx), it looks nicer.
13:48:08 <omnId> fromOp, maybe?
13:48:27 <faxathisia> Ah yeah
13:48:34 <faxathisia> This is an improvement on both
13:48:38 <dmwit> Well, it would have to be (fromOp op prev mutator), but basically what I was saying.
13:48:56 <faxathisia> Wouldn't it be fromOp op $ prev mutator ?
13:49:09 <monochrom> (x y) z t = x y z t
13:49:18 <faxathisia> ah :D
13:49:24 <faxathisia> ok great
13:49:44 <faxathisia> that currying thing is nice
13:49:58 <omnId> and, given the choice, I usually use 'where' over 'let', but that's a stylistic thing :3
13:50:34 <monochrom> I use "let" on prime seconds, "where" otherwise. :)
13:51:20 <hpaste>  faxathisia annotated "which is the better way?" with "where" at http://hpaste.org/3648#a1
13:51:28 <faxathisia> That's a lot better :D
13:51:43 <faxathisia> do you think I indent it right
13:52:29 <monochrom> Probably not. Move "where" to the left, but still a bit from the right margin.
13:52:46 <faxathisia> :S where?
13:52:56 <hpaste>  omnId annotated "which is the better way?" with "you don't have to put it in another definition, unless it gets used elsewhere" at http://hpaste.org/3648#a2
13:53:01 <monochrom> OTOH I haven't really used the full entirety of the layout rules to deduce that.
13:53:14 <mauke> faxathisia: your indentation looks ok to me
13:53:34 <mauke> but you can put the "where" anywhere you want (as long as it's not in the very first column)
13:53:47 <mauke> (you could even put it at the end of the previous line)
13:54:02 <monochrom> Alright, nice.
13:54:09 <omnId> faxathisia: layout only effects the definitions inside the 'where' clause, pat = expr where decls itself is layoutless.
13:54:11 <b_jonas> @src Either return
13:54:11 <lambdabot> return        = Right
13:54:27 <faxathisia> thanks a lot everyone
13:54:42 <b_jonas> so that's how they use Either as monads
13:54:50 <b_jonas> @src Either (>>=)
13:54:50 <lambdabot> Left  l >>= _ = Left l
13:54:50 <lambdabot> Right r >>= k = k r
13:55:23 <b_jonas> it's like Maybe but Left carries the error
13:55:31 <P_D> Anybody know what happened to ghc's --mk-dll flag?
13:55:31 <omnId> right values pass through, wrong values persist.
13:55:33 <omnId> :)
13:55:39 <mauke> @src Maybe (>>=)
13:55:40 <lambdabot> (Just x) >>= k      = k x
13:55:40 <lambdabot> Nothing  >>= _      = Nothing
13:56:24 <b_jonas> yep, that's the same
13:56:26 <omnId> Left "whatever" =~= Nothing;  Right value =~= Just value
13:56:38 <b_jonas> @src Bool (>>=)
13:56:38 <lambdabot> Source not found. Where did you learn to type?
13:57:01 <omnId> b_jonas: wrong kind :)
13:57:22 <b_jonas> omnId: oh yes, that's true
13:57:28 <omnId> monads are (* -> *), like Maybe and Either e, Bool is *.
13:58:17 <monochrom> When we say "the Either monad" we're just being casual. Of course it is "the Either a monad".
13:58:17 <mauke> @src (->) (>>=)
13:58:17 <lambdabot> f >>= k = \ r -> k (f r) r
13:58:20 <omnId> you could make a phantom-typed Boolish, type, though.  I don't imagine its monad instance would be terribly useful.
13:58:30 <ddarius> You could make a Const t monad for any given type t which would be a Haskell monad and a categorical monad but not a computational monad a la Moggi.
13:59:05 <SamB> ddarius: hmm?
13:59:32 <omnId> ddarius: where's the definition of these Moggi monads?  I'm interested.
13:59:37 <b_jonas> monochrom: yep
13:59:41 <ddarius> @google Moggi Notions of Computation
13:59:43 <b_jonas> but @src doesn't like that syntax
13:59:44 <lambdabot> http://citeseer.ist.psu.edu/moggi89notions.html
13:59:44 <lambdabot> Title: Notions of Computation and Monads - Moggi (ResearchIndex)
13:59:51 <SamB> oh, does a computational monad need to have some difference between return 'a' and return 'b'?
13:59:57 <ddarius> The only reason it wouldn't be a computational monad is because return wouldn't be a mono.
14:00:04 <ddarius> SamB: Yes.
14:00:07 <chessguy> @pl \f k r -> k (f r) r
14:00:07 <lambdabot> flip flip id . (ap .) . flip (.)
14:00:22 <chessguy> @pl \r -> k (f r) r
14:00:23 <lambdabot> k =<< f
14:00:33 <ddarius> Specifically, a computational monad is a strong monad with a mono unit.
14:00:33 <SamB> ddarius: so are there any useful monads that aren't computational monads?
14:01:04 <smtms> what's the best book on monads?
14:01:09 <ddarius> SamB: In Haskell all monads are strong and Const is pretty much the only one with a non-mono return.
14:01:09 <SamB> oh great
14:01:18 <SamB> this wikipedia articile is a bunch of abstract nonsense
14:01:32 <dons> smtms: hmm. book?
14:01:34 <ddarius> mmm abstract nonsense
14:01:42 <dons> smtms: there's some good papers. particularly by wadler
14:02:00 <SamB> I can't read these diagrams yet
14:02:09 <ddarius> SamB: Which article?
14:02:19 <SamB> http://en.wikipedia.org/wiki/Strong_monad
14:03:05 <dons> smtms: http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Monads :)
14:03:07 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/fgd83
14:03:13 <ddarius> SamB: Well, as far as the diagrams are concerned, all they do is display equations in a different form.  Every pair of paths that start at the same point and end at the same point is an equation.
14:03:17 <omnId> somewhat unrelatedly, I was very surprised the "Category Theory for Java programmers" article on proggit was pretty easy to understand and (to someone who doesn't know :) correct-sounding.
14:03:27 <nornagon> a strong monad is one that can lift a car!
14:03:27 <SamB> ddarius: thet helps little
14:03:34 <SamB> I wouldn't be able to read the equations either
14:03:38 <dons> in particular, `Comprehending monads', `Imperative functional programming', and `Monads for functional programming'
14:03:50 <LoganCapaldo> omnId: every time I saw java syntax my eyes started glazing over. :)
14:04:04 <SamB> LoganCapaldo: that's normal
14:04:14 <ddarius> SamB: E.g. t;T() =  where (;) is flip (.)
14:04:17 <SamB> that's why it is called "for Java programmers"
14:04:23 <omnId> one sec, afk
14:04:39 <SamB> if it was for normal people...
14:05:36 <darinm> anyone here know anything about external core?
14:05:53 <SamB> I have a feeling it doesn't work as advertised?
14:06:12 <SamB> also, it is uglier than internal core
14:06:15 <darinm> well, that's what I'm wondering :)
14:06:30 <SamB> what bug have you found?
14:07:23 <darinm> none specifically.  I have some code which relies on internal core in 6.6.1, which is broken with 6.8.1.  I'm wondering if it's better to target external core, or fix my bugs with internal core
14:07:42 <ddarius> SamB: Part of the problem with that article is that it implicitly assumes you know that  and  are the natural transformations that witness association and left unit of the tensor product 
14:07:44 <darinm> last I heard external core had some probs, but I don't know if they're fixed in 6.8.1 or not
14:08:20 <SamB> ddarius: I don't think stating that would help me much
14:08:32 <SamB> my eyes start to glaze over when I see a commutative diagram
14:09:11 <drtomc> Hi All! Is anyone here familiar with Chakravarty's Lazy Lexing?
14:09:32 <dons> drtomc: yeah
14:09:32 <SamB> is that the Lazy Lexing in Lazy Lexing is Fast?
14:09:35 <dons> yep.
14:09:43 <dons> the ctk lexer combinators
14:09:50 <SamB> I think I might have a copy under my dirty laundry
14:09:56 <SamB> which I should wash some of...
14:10:03 <drtomc> Hi dons! I've got a curly case that I'm not sure how to handle.
14:10:08 <b_jonas> @where liftIO
14:10:08 <lambdabot> I know nothing about liftio.
14:10:13 <b_jonas> @src liftIO
14:10:14 <lambdabot> Source not found. :(
14:10:15 <TSC> @index liftIO
14:10:16 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:10:38 <b_jonas> but which one documents it?
14:10:43 <drtomc> Consider the regex: (a `plus` epsilon >|< a `star` b)
14:11:16 <drtomc> It comes up in a reasonable definition of numbers: digit+ | digit*.digit+
14:11:35 <thoughtpolice> b_jonas: http://haskell.org/ghc/docs/latest/html/libraries/mtl-1.1.0.0/Control-Monad-Trans.html
14:11:36 <lambdabot> http://tinyurl.com/34nv75
14:11:37 <ddarius> SamB: Those particular diagrams are fairly busy.  They could be made less.
14:11:59 <SamB> yes, they are pretty busy
14:12:18 <drtomc> My implementation (which follows the paper very closely, modulo bugs in the paper) can't hack it because of the way >|< is implemented.
14:12:30 <b_jonas> ah, so that's a method
14:12:33 <thoughtpolice> liftIO just lifts an IO action into your monad transformer, iirc it's just a little more efficient to use if your 'outermost' monad is IO, you can just as well use lift
14:12:41 <drtomc> lhs >|< rhs = \l -> lhs l >||< rhs l
14:12:41 <drtomc> lhs >|< rhs = \l -> lhs l >||< rhs l
14:12:41 <drtomc> lhs >|< rhs = \l -> lhs l >||< rhs l
14:12:48 <LoganCapaldo> it's recursive too isn't it?
14:12:55 <drtomc> (paste bug, sorry)
14:12:58 <matthew--> evening folks.
14:13:11 <SamB> drtomc: so... have you looked at the CTK version?
14:13:26 <drtomc> Where is it? I have not heard of it before.
14:13:27 <ddarius> :t liftIO
14:13:28 <b_jonas> @src ErrorT liftIO
14:13:34 <matthew--> so, I've been trying to think about would it would mean to have a pure, referentially transparent operationg system
14:13:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:13:35 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:13:42 <SamB> drtomc: it is some kind of virus
14:13:43 <LoganCapaldo> liftIO :: IO a -> FooT (BarT (BazT IO a) vs. lift . lift . lift :: ... that same type
14:14:04 <drtomc> SamB: :-)
14:14:18 <SamB> http://www.cse.unsw.edu.au/~chak/haskell/ctk/
14:14:19 <lambdabot> Title: A Compiler Toolkit in Haskell
14:14:20 <SideFFect> is it legal to write this: let h = (j+k) `div` 2 in | x < h bsearch etc etc?
14:14:29 <SideFFect> I have 3 cases to test for
14:14:36 <b_jonas> I see
14:14:44 <b_jonas> so it might lift several steps recursively
14:14:45 <matthew--> consider the average server running some sort of webserver. Why not have a cache of the last known values so that if the same http request came in, you serve it directly if you know the restof the RealWorld hasn't changed
14:14:55 <b_jonas> and it's an identity for IO?
14:15:32 <ddarius> matthew--: Isn't that already done nowadays when it is deemed useful.
14:15:54 <matthew--> ddarius: sure, but let's say that it's your typical LAMP site.
14:15:54 <dmwit> SideFFect: How about
14:16:20 <dmwit> case (cmp x ((j+k) `div` 2)) of LT ->... EQ ->... GT ->...
14:16:22 <matthew--> ddarius: if the "world" hasn't changed, then why are you calling apache to call php to call mysql to generate the page ?
14:16:23 <SamB> matthew--: you are welcome to try to write an instance for Eq RealWorld
14:16:39 <dmwit> SideFFect: Or, more idiomatically,
14:16:44 <matthew--> SamB: but if you're the operating system, it might be possible
14:16:46 <SideFFect> hmm true
14:16:47 <LoganCapaldo> b_jonas: It couldn't be an indity for IO, IO is not a monad transformer
14:17:01 <dmwit> maybe you want a function that does (j+k) `div` 2 for you, and pass that value rather than j and k?
14:17:01 <SamB> matthew--: the operating system is least in a position to do that...
14:17:08 <ddarius> matthew--: Isn't this what web server accelerators already do?
14:17:15 <SideFFect> no I need j and k
14:17:21 <SideFFect> and h is the middle of the two
14:17:28 <matthew--> ddarius: err, maybe, but I'm thinking more generally...
14:17:31 <SideFFect> then I need to compare h to a user specified x
14:17:31 <matthew--> SamB: why?
14:17:49 <b_jonas> LoganCapaldo: hmm
14:18:08 <matthew--> SamB: any action that a program does that is any sort of modification to the real world has to go through the kernel
14:18:21 <matthew--> SamB: so that it's just a matter of tagging where data goes...
14:18:30 <matthew--> s/that/then
14:18:44 <matthew--> SamB: or am I overlooking a very obvious problem?
14:19:07 <SamB> matthew--: the kernel hasn't the slightest idea what the program cares about
14:19:23 <matthew--> SamB: but assume that all programs are Haskell
14:19:26 <chessguy> SideFFect, it might be helpful if you actually show us what you're doing
14:19:36 <SideFFect> one sec
14:19:37 <SamB> matthew--: even so
14:19:54 <SamB> this might almost work with STM...
14:19:57 <chessguy> @karma matthew
14:19:57 <lambdabot> matthew has a karma of 0
14:20:03 <SamB> or something like it...
14:20:07 <hpaste>  SideFFect pasted "Bsearch_new" at http://hpaste.org/3649
14:20:17 <SideFFect> pasted
14:20:29 <SideFFect> its a binary search
14:20:31 <matthew--> SamB: also assume no shared memory
14:20:36 <faxathisia> D:
14:20:38 <faxathisia> Ambiguous occurrence `LT'
14:20:47 <faxathisia> should I rename mine?
14:20:51 <drtomc> Right, so I've looked at the ctk version, and the behaviour is the same.
14:20:54 <SamB> matthew--: that is something I cannot do
14:21:12 <dmwit> SideFFect: I think you might be mildly confused. =)
14:21:13 <matthew--> SamB: gah, good point.
14:21:27 <chessguy> dmwit, i think he's majorly confused :)
14:21:37 <SamB> I might be able to manage assuming no mutable shared memory
14:21:39 <faxathisia> SideFFect: you can write bsearch x (j:ys), so you don't have to call head
14:21:44 <ninjawarrior82> #ut
14:21:46 <chessguy> SideFFect, for one thing, what are you expecting bsearch to return?
14:21:48 <matthew--> SamB: that'll do
14:21:50 <SideFFect> why am I confused?
14:22:05 <dmwit> SideFFect: As written, that function returns the average of the first and last elements in the list.
14:22:13 <faxathisia> SideFFect: you know like : is consing lists
14:22:19 <drtomc> In fact, if you define "str" as a sequence of +> ops, the exprn: str "012" >|< str "013" gives the same error on the string "012".
14:22:20 <SideFFect> yes, I know what it returns, I wrote it
14:22:23 <SamB> matthew--: how is the kernel to know what files relate to what HTTP requests?
14:22:24 <faxathisia> SideFFect: e.g. 1:[2,3,4] == [1,2,3,4]
14:22:29 <dmwit> SideFFect: Is that what you really want?
14:22:29 <SideFFect> im just asking how to compare x to h now
14:22:47 <chessguy> SideFFect, and we're telling you that you're totally going about it the wrong way
14:22:49 <SideFFect> its what the teacher wants
14:22:58 <faxathisia> x == h
14:23:07 * b_jonas reads http://www.haskell.org/all_about_monads/html/transformers.html
14:23:08 <lambdabot> Title: Monad transformers
14:23:19 <SideFFect> im just asking how I compare things after the in operator
14:23:20 <Olathe> More than meets the eye !
14:23:20 <dmwit> b_jonas: Nice, that's a really good one.
14:23:30 <matthew--> SamB: you'd have to tag every action that goes through "IO" (well, something like it), and produce a log. Then the kernel will see "same data on network, the result depended on these files, those files haven't changed, so spew out the same result"
14:23:40 <matthew--> SamB: so almost a variant of STM I guess
14:24:37 <SideFFect> teacher wants this in haskell
14:24:37 <dmwit> SideFFect: What should be the final result of "bsearch 5 [3,4,5,7,10,20]", for a correctly written bsearch?
14:24:38 <SideFFect> http://hpaste.org/3643
14:24:54 <SideFFect> im not saying my program is complete
14:25:12 <b_jonas> so a monad transformer is a monad
14:25:17 <matthew--> SamB: or for message passing microkernels (think L4(ka) or better), I think this is easier as you just log the messages that go around
14:25:22 <b_jonas> no it isn't
14:25:22 <hpaste>  chessguy annotated "Bsearch_new" with "A simpler way of saying the same thing, even though it's still not what you want..." at http://hpaste.org/3649#a1
14:25:24 <b_jonas> hmm
14:25:39 <b_jonas> a monad transformer creates a monad from a monad
14:25:47 <LoganCapaldo> :)
14:25:51 <Olathe> Robots in disguise !
14:26:05 <SideFFect> hm lemme see that
14:26:06 <dmwit> SideFFect: You should notice that in your Haskell version, "j" and "k" are values from the array, while in the DPL version, they are *indices* to the array.
14:26:26 <SideFFect> yeah...im not sure how to make them into indices
14:26:29 <dmwit> SideFFect: But in any case, you almost certainly don't want to use indices here.
14:26:30 <chessguy> dmwit, DPL?
14:26:36 <b_jonas> that's too high a kind for me to imagine
14:26:46 <dmwit> chessguy: /me shrugs -- see paste 3643
14:26:57 <chessguy> SideFFect, you still haven't anwered my question about what you want the bsearch function to return
14:27:05 <ddarius> :k ErrorT
14:27:06 <lambdabot> * -> (* -> *) -> * -> *
14:27:18 <SideFFect> oh...for me I just want it to return a value...1 if found, -1 if not found
14:27:27 <matthew--> incidentally, have ppl read Dan Bernstein's recent paper - http://cr.yp.to/qmail/qmailsec-20071101.pdf - I find it quite hard to read as anything other than an endorsement of Haskell and similar languages
14:27:33 <SideFFect> but the teacher wants it to display where the number is located in the list
14:27:36 <SideFFect> but one step at a time
14:27:52 <ddarius> b_jonas: One thing to note, is that there is not much difference between the type level and the value level except that the type level is quite a bit more restricted than the value level.
14:28:14 <b_jonas> pity the example at Control.Monad.Error isn't really good
14:28:28 <SideFFect> chessguy: thanks that is much simpler
14:28:35 <SideFFect> for that at least
14:28:36 <b_jonas> because the first example just does the IO outside the error monad
14:29:02 <dmwit> SideFFect: You really want to divide your list in half.  See if you can figure out how to do that.
14:29:20 <dmwit> (That's what the "h := (j+k) div 2" step is doing in the DPL version, if you follow closely.)
14:29:29 <chessguy> SideFFect, sounds to me like you want to solve the problem recursively
14:29:30 <b_jonas> I don't get this
14:30:06 <dmwit> SideFFect: See if you can write a function "divideInHalf :: [a] -> ([a], [a])" that returns the first and second halves of a list, respectively.
14:30:08 <b_jonas> so the second example does the IO inside the error monad
14:30:16 <SideFFect> yeah I know, I have to read the value halfway thru, and see if tis bigger or smaller then x
14:31:09 <SideFFect> cant I just take the length, divide by two, and then return that many digits?
14:31:20 <b_jonas> SideFFect: no,
14:31:21 <SideFFect> er, indices
14:31:42 <dmwit> Be careful about differentiating between indices and values.
14:31:43 <mauke> no?
14:31:51 <b_jonas> you have to transform the while loop in imperative example to a tail recursion,
14:32:10 <SideFFect> count the # of items in a list, divide by 2... then take the number and show that many as a new list
14:32:17 <b_jonas> passing the valuies of j and k to the recursive function instead of modifeing them
14:32:22 <dmwit> Okay, see if you can write that.
14:32:48 <SideFFect> serious? or saying it as in, its not possible but have fun you're bugging us?
14:33:00 <dmwit> SideFFect: No, it is the first step I would do.
14:33:07 <SideFFect> alright, ill try
14:33:25 <dmwit> SideFFect: Write a function "firstHalf :: [a] -> [a]" and a function "secondHalf :: [a] -> [a]" so that "firstHalf xs ++ secondHalf xs == xs".
14:34:17 <dfranke> dons: just an FYI: I'm about to try running it, but xmonad-0.4.1 seems to build fine for me with ghc-6.8.1, modulo having to add the containers package to xmonad.cabal
14:34:53 <SideFFect> ill try :P
14:35:01 <b_jonas> I think I'll try to write an error handling thing without using MonadTrans first, to see if I understand it
14:35:07 <dons> dfranke: yep, that should be all that is required
14:35:13 <dons> dfranke: i use 6.8 snapshots all the time
14:35:17 <b_jonas> that is, by using IO and Either
14:35:18 <Saizan_> ?src ErrorT
14:35:18 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
14:35:47 <b_jonas> good night now
14:35:53 <ddarius> Which is to say, ErrorT e IO a is just IO (Either e a)
14:38:27 <SideFFect> this doesnt return the length?
14:38:28 <SideFFect> bsearch x (ys) = let h = length ys in h
14:38:42 <SideFFect> it gives an error when compiling
14:38:59 <mauke> what's the error?
14:39:18 <dons> bsearch x ys = length ys
14:39:20 <dmwit> Int vs. Integer
14:39:27 <SideFFect> yeah exactly
14:39:28 <SideFFect> :P
14:39:29 <mauke> oh, explicit type signature?
14:39:36 <dmwit> SideFFect: length returns an Int, not an Integer. =/
14:39:40 <Olathe> bsearch on linked lists is the work of SATAN !
14:39:45 <SideFFect> lol isnt it the same?
14:39:53 <Pseudonym> It depends on the linked list.
14:39:54 <mauke> no, they're different types
14:40:01 <Pseudonym> Binary search on skip lists is easy.
14:40:02 <chessguy> SideFFect, you seem to have a propensity for overkill on the let blocks
14:40:07 <SideFFect> int and integer are diff?
14:40:10 <dmwit> No, Int's are machine-sized, Integers are arbitrarily large.
14:40:11 <dons> SideFFect: yes.
14:40:12 <SideFFect> wow haskell IS evil
14:40:16 <dmwit> > 2^32 :: Int
14:40:21 <lambdabot>  0
14:40:26 <dons> no, it provides unbounded integers, and machine integers, as different types
14:40:26 <sorear> @remember Olathe bsearch on linked lists is the work of SATAN !
14:40:26 <dmwit> > 2^32 :: Integer
14:40:27 <lambdabot> Done.
14:40:27 <Pseudonym> Evil in a good way, in this case.
14:40:28 <dons> with different names
14:40:28 <lambdabot>  4294967296
14:40:37 <dons> > 2^1000
14:40:38 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
14:40:42 <dons> > 2^1000 :: Int -- see
14:40:44 <lambdabot>  0
14:40:46 <mauke> > 2^1000 :: Double
14:40:47 <lambdabot>  1.0715086071862674e301
14:40:54 * sorear is a member of the association for eleminating Int
14:40:57 <dons> :)
14:41:02 <dons> sorear: you and Cale eh?
14:41:06 <Pseudonym> Int is a necessary evil.
14:41:06 <dons> ;)
14:41:20 <SideFFect> we never learned this
14:41:21 <sorear> We agree on a lot of things.
14:41:25 <SideFFect> that int and integer are diff
14:41:32 <Pseudonym> Although, calling it Int64 or Int32 isn't a dumb idea.
14:41:32 <SideFFect> for haskell that is
14:41:37 <dons> SideFFect: i think yor teacher is expecting a bit of self-study?
14:41:42 <SideFFect> long and short int
14:41:44 <SideFFect> makes more sense
14:41:49 <Pseudonym> No.
14:41:54 <SideFFect> no, hes just odd
14:41:54 <Pseudonym> long and short int could be anything.
14:42:00 <dmwit> That implies long and short from C, which is not correct.
14:42:11 <Olathe> Word !
14:42:14 <Pseudonym> There are minimum sizes for long and short.
14:42:21 <Pseudonym> But no fixed sizes.
14:42:34 <Pseudonym> Int makes a certain amount of historical sense.
14:42:42 <Pseudonym> It comes from a time when tags were combined with values.
14:43:15 <dfranke> dons: aighty, seems to work great.
14:43:26 <dons> cool.
14:43:26 <dfranke> dons: and gimp is no longer on crack :-)
14:43:32 <dons> we might remove the containers dependency too
14:43:41 <dons> dfranke: yeah :)
14:43:47 <dfranke> what?  Why would you do that?
14:44:01 <dons> oh, just use lists instead of Map. so then users don't need to upgrade cabal
14:44:06 <SideFFect> can someone tell me how they would divide a list into two?
14:44:15 <dons> SideFFect: how would you do it?
14:44:19 <dons> abstractly, that is.
14:44:24 <SideFFect> im sick of this language...too much to learn for one dumb assignment
14:44:27 <Olathe> I know how I'd do it, but I'm evil.
14:44:29 <SideFFect> I can do this imperitively
14:44:36 <SideFFect> functionally can kiss my @ss
14:44:37 <SideFFect> heh
14:44:43 <chessguy> SideFFect, "count the # of items in a list, divide by 2... then take the number and show that many as a new list"
14:44:45 <dfranke> hmm, I wouldn't do that.  Trading off good design for backward compatibility is rarely a win.
14:44:46 <dons> how would you do it imperatively?
14:45:13 <dfranke> the ghc nonsense will sort itself out in good time.
14:45:17 <dons> i don't think this is an especially `functional' problem, splitting a list.
14:45:22 <SideFFect> thanks for quoting me chessguy...
14:45:44 <chessguy> SideFFect, so what's the problem? what part of that do you not know how to do?
14:45:45 <SideFFect> you guys are very cryptic with your answers
14:45:58 <chessguy> SideFFect, you need to ask better questions :)
14:46:01 <dmwit> dons: The ultimate goal is bsearch (returning the index of a particular element).  It's not a particularly functional problem as a whole, I think.
14:46:04 <Olathe> SideFFect: The lobster in the sanitarium has the answer at noon !
14:46:10 <dfranke> SideFFect: five pounds of flax!
14:46:13 <SideFFect> ill wait till 12 then
14:46:19 <sorear> > ap splitAt ((`div` 2) . length)  [1..20]
14:46:20 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
14:46:29 <chessguy> @slap sorear
14:46:29 * lambdabot pokes sorear in the eye
14:46:30 <dons> SideFFect: well, we're to some extent encouraging you to think about the solution some more
14:46:34 <sorear> > ap (flip splitAt) ((`div` 2) . length)  [1..20]
14:46:35 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
14:46:39 <sorear> there
14:46:40 <dons> since all the tools you need, you've seen already
14:47:05 <chessguy> what's a sanitarium anyway?
14:47:12 <chessguy> @all-dict sanitarium
14:47:14 <lambdabot> *** "Sanitarium" gcide "The Collaborative International Dictionary of English v.0.48"
14:47:14 <lambdabot> Sanitarium \San`i*ta"ri*um\, n. [NL. See {Sanitary}.]
14:47:14 <lambdabot>    A health station or retreat; a sanatorium. "A sanitarium for
14:47:14 <lambdabot>    troops." --L. Oliphant.
14:47:14 <lambdabot>    [1913 Webster]
14:47:16 <lambdabot> [6 @more lines]
14:47:16 <LoganCapaldo> S combinator
14:47:18 <SideFFect> yes but you guys have done this for many years...its easy to say I have all the tools
14:47:33 <dons> so how would you split a list, can you walk through the steps?
14:47:45 <chessguy> SideFFect, whining isn't going to help you. you could start progressing by answering some of our questions
14:48:05 <SideFFect> when did I whine?
14:48:23 <SideFFect> how about I pay someone to write this crappy thing for me? paypal is up for grabs :D
14:48:29 <dmwit> no
14:48:34 <chessguy> not going to happen
14:48:35 <SideFFect> one no
14:48:37 <SideFFect> 2 no's
14:48:45 * magnusth thinks laziness is cool, but somewhat evil
14:48:47 <dons> no. but you can begin by explaining how you'd imagine splitting a list.
14:48:52 <oerjan> > join (splitAt.(`div`2).length) $ [1..20]
14:48:53 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
14:49:04 <SideFFect> see, you guys write code ive never seen before
14:49:09 <dons> SideFFect: there's several professional teachers in here, willing to give you time, if you start by describing how you'd split the list :)
14:49:15 <SideFFect> how can I do something if I wasnt taught the commands for it?
14:49:26 <dons> that's an interesting questoin.
14:49:28 <chessguy> dons, apparently he'd rather complain about not getting any help
14:49:31 <Heffalump> learn them for yourself, perhaps?
14:49:32 <dmwit> SideFFect: Those people are showing off for us, not giving good solutions.
14:49:32 <dfranke> dons: btw, is there any magic snippet of code for warping my cursor to a given physical display?
14:49:43 <oerjan> SideFFect: we're just being facetious.  we don't want to write you something you can just turn in directly for your homework, you see...
14:49:50 <dons> dfranke: hmm. is there a Warp.hs module in xmc?
14:50:06 <SideFFect> I know, but writing cryptic answers and saying, how would I do it, doesnt answer questions
14:50:18 <dons> SideFFect: yes, for one thing, we're following the homework policy, http://haskell.org/haskellwiki/Homework_help
14:50:19 <lambdabot> Title: Homework help - HaskellWiki
14:50:19 <SideFFect> not that im not appreciative...but dont post questions to questions
14:50:21 <chessguy> SideFFect, we're not here to do your homework for you
14:50:24 <dons> which requires guiding you towards your own solution
14:50:30 <SideFFect> chessguy, I never asked that
14:50:31 <dons> rather than just showing the answer.
14:50:35 <dmwit> dfranke: You can get the geometry, then warp to a specific (pixel) location.
14:50:36 <SideFFect> besides the paypal comment
14:50:38 <dons> SideFFect: so, let's do this. how to split a list.
14:50:52 <dons> SideFFect: explain what steps are required to split a list, in the notation of your choice.
14:51:00 <dfranke> dons: ah, indeed so.
14:51:16 <SideFFect> I take the length of the list....say [1..10] giving 10
14:51:21 <SideFFect> then, I divide by 2
14:51:24 <chessguy> dons, unless it's like ancient assyrian or something
14:51:28 <SideFFect> gives 5 elements on each side
14:51:34 <dons> yep.
14:51:39 <dons> and then?
14:51:45 <SideFFect> then I could count 5 elements, stop, make a new list, and count another 5
14:51:57 <dons> ok, that'll do.
14:52:02 <dons> so how do you take the length of the list in haskell?
14:52:05 <dons> :)
14:52:11 <SideFFect> length [ys]
14:52:25 <mauke> tr/[]//d
14:52:30 <P_D> > length [1]
14:52:31 <dons> almost, given some list 'xs', you just call length on that variable,   length xs
14:52:32 <lambdabot>  1
14:52:38 <dons> > let s = "foo" in   length s
14:52:39 <lambdabot>  3
14:52:46 <dons> ok. so now how to divide that by 2?
14:52:52 <LoganCapaldo> hmm
14:53:10 <LoganCapaldo> > let ys = [1,2,3,4] in liftM length [ys]
14:53:11 <lambdabot>  [4]
14:53:20 <dons> LoganCapaldo: no no. please no fancy code atm.
14:53:27 <chessguy> @slap LoganCapaldo
14:53:28 <lambdabot> stop telling me what to do
14:53:41 <SideFFect> I could do as I did, let h = length xs; z = h `div` 2
14:53:41 <chessguy> uh-oh, the bot is mutinying
14:53:43 <SideFFect> no?
14:53:43 <P_D> > let ys = [1,2,3,4] in liftM id [ys]
14:53:45 <lambdabot>  [[1,2,3,4]]
14:53:47 <dons> SideFFect: yep, that looks good.
14:53:55 <dons> so something like:
14:54:03 <mauke> P_D: liftM == map
14:54:15 <P_D> @src liftM
14:54:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:54:21 <dons> > let lengthDiv2 xs =   let h = length xs in h `div` 2    in lengthDiv2 "haskell"
14:54:22 <lambdabot>  3
14:54:46 <SideFFect> yeah
14:54:48 <Karle> hello all
14:54:55 <P_D> @type liftM
14:54:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:55:02 <dons> SideFFect: so now we've got 'h' with the right value, how do we get the first 'h' elements off our list?
14:55:17 <dons> hint: this you could do by hand, or with a library function
14:55:26 <omnId> so 'z' is half the length of the list.  Do you know the function that takes some number of elements from a list?
14:55:28 <SideFFect> take 3?
14:55:33 <dons> yeah, take is good.
14:55:41 <omnId> right!, but take z is what you want.
14:55:43 <dons> > let lengthDiv2 xs =   let h = length xs in h `div` 2    in take (lengthDiv2 "haskell")
14:55:44 <lambdabot>  Add a type signature
14:55:56 <dons> > let lengthDiv2 xs =   let h = length xs in h `div` 2    in take (lengthDiv2 "haskell") "haskell" -- :)
14:55:57 <lambdabot>  "has"
14:56:05 <SideFFect> but then how do I take the second half?
14:56:05 <mauke> I can has kell?
14:56:09 <SideFFect> take only takes from the start
14:56:14 <dons> SideFFect: well, what's the opposite of take?
14:56:19 <dons> have a guess :)
14:56:21 <SideFFect> is it drop?
14:56:23 <dons> yep!
14:56:25 <SideFFect> ahh
14:56:35 <SideFFect> so drop h will give the last h elements
14:56:40 <mauke> not quite
14:56:41 <dons> so you can (take 3 xs, drop 3 xs) yeah?
14:56:51 <LoganCapaldo> @remember mauke I can has kell?
14:56:51 <lambdabot> It is stored.
14:56:54 <SideFFect> so far yes
14:56:58 <mauke> drop h gives you everything except the first h elements
14:57:08 <SideFFect> ohh
14:57:10 <mauke> > drop 2 "haskell"
14:57:11 <lambdabot>  "skell"
14:57:11 <dons> > let lengthDiv2 xs =   let h = length xs in h `div` 2    in let n = lengthDiv2 "haskell" in (take n "haskell", drop n "haskell")
14:57:12 <SideFFect> thats how it works
14:57:13 <lambdabot>  ("has","kell")
14:57:19 <Karle> hi oerjan
14:57:27 <Karle> how are you?
14:57:30 <SideFFect> hm...very intereesting
14:57:30 <dons> SideFFect: and in fact, this combination of drop, take is so common, there's a function in the libraries for it:
14:57:31 <omnId> there's a library function that combines take and drop, FYI.
14:57:34 <dons> ?src splitAt
14:57:34 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
14:57:39 <omnId> darnit, dons!
14:57:45 <dons> > let lengthDiv2 xs =   let h = length xs in h `div` 2    in let n = lengthDiv2 "haskell" in splitAt n "haskell"
14:57:46 <lambdabot>  ("has","kell")
14:57:48 <Olathe> > let split xs = split' xs xs; split' (a:bs) (_:_:cs) = let (qs,rs) = split' bs cs in (a:qs, rs); split' bs _ = ([], bs) in map (\n -> split [1..n]) [1..10]
14:57:49 <lambdabot>  [([],[1]),([1],[2]),([1],[2,3]),([1,2],[3,4]),([1,2],[3,4,5]),([1,2,3],[4,5,...
14:58:07 <SideFFect> interesting
14:58:09 <dons> SideFFect: so that's it really, use splitAt with the initial length, to split your list in two.
14:58:27 <dons> do you think you could now write that down as a single function, splitIn2 that takes a list, and returns it split into two pieces?
14:58:27 <oerjan> hi Karle
14:58:39 <chessguy> dons, don't you mean splitAt with lengthDiv2?
14:58:43 <dons> right.
14:58:45 <SideFFect> returns meaning showing it on screen?
14:59:02 <dons> well, I mean a single function that accepts a list as an argument, and returns 2 lists as its result
14:59:10 <dons> what would be the type of that function, by the way?
14:59:15 <mauke> "returns" == "evaluates to"
14:59:17 <omnId> "returns" meaning the value given by the expression (spiltIn2 someList)
14:59:35 <Olathe> @hoogle [a] -> ([a], [a])
14:59:36 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
14:59:36 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
14:59:36 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:59:42 <Karle> oerjan, I soon will start asking again... tonight I gotta implement basically the same but with untimed dataflow model
14:59:46 <Olathe> @src break
14:59:46 <lambdabot> break p =  span (not . p)
14:59:47 <dons> SideFFect: can you give the Haskell type for such a function?
14:59:57 <Olathe> @src List.partition
14:59:58 <lambdabot> Source not found. Take a stress pill and think things over.
15:00:00 <omnId> SideFFect: the showing on the screen only happens because your interpreter turns it into a string and prints that string.
15:00:23 <SideFFect> I didnt get what you wanted dons?
15:00:36 <omnId> what's the type of splitIn2?
15:00:41 <dons> SideFFect: can you write down the type declaration of the function splitIn2
15:00:47 <omnId> it takes a ____ and gives a ___
15:00:48 <dons> splitIn2 :: .... ?
15:00:50 <chessguy> @pl \ls -> splitAt (length ls `div` 2) ls
15:00:51 <lambdabot> splitAt =<< (`div` 2) . length
15:00:52 <SideFFect> type? is [Integer] isnt it?
15:00:58 <dons> well, it takes a list, yes.
15:01:05 <SideFFect> and returns 2 lists
15:01:05 <dons> splitInt2 :: [Integer] -> ...
15:01:11 <dons> right, so how do you write that as a type?
15:01:16 <SideFFect> hm
15:01:22 <RayNbow> dons, [a] -> ([a],[a])?
15:01:24 <omnId> do you know the pair type?
15:01:33 <dons> RayNbow: yep, that's good.
15:01:35 <SideFFect> ah I was wondering if brackets could be used
15:01:35 <faxathisia> @hoogle [a] -> [([a],[a])]
15:01:36 <lambdabot> No matches, try a more general search
15:01:41 <dons> SideFFect: right.
15:01:42 <omnId> RayNbow: right, but we're teaching SideFFect :P
15:01:45 <oerjan> chessguy: we've already established that it's join(splitAt.(`div`2).length)
15:01:48 <dons> you use the 'tuple' or 'pair' type
15:01:49 <faxathisia> @hoogle [a] -> ([a],[a])
15:01:50 <RayNbow> oh, sorry :p
15:01:50 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
15:01:50 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:01:50 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:02:06 <dons> so the entire type is splitIn2 :: [Integer] -> ([Integer], [Integer])
15:02:10 <dons> does that makes sense SideFFect ?
15:02:15 <SideFFect> very much actually
15:02:22 <dons> in fact, as RayNbow pointed out, there's no need to restrict it to lists of Integers
15:02:25 <dons> since it will work on any lists
15:02:33 <omnId> lists of *any* type of thing.
15:02:33 <dons> so we can use a 'polymorphic' type (not so scary, but scary name)
15:02:52 <omnId> splitIn2 :: [a] -> ([a], [a])
15:02:53 <dons> splitIn2 :: [a] -> ([a], [a])
15:02:55 <Olathe> > let split xs = split' xs xs; split' (a:bs) (_:_:cs) = let (qs,rs) = split' bs cs in (a:qs, rs); split' bs _ = ([], bs) in split "Haskell is quite spiffy !"
15:02:56 <lambdabot>  ("Haskell is q","uite spiffy !")
15:03:00 <SideFFect> now that the list is divided into two... can I compare a value to see in which list it resides?
15:03:11 <dons> you could, yes.
15:03:18 <dons> you'd have to search first one, then the other
15:03:31 <dmwit> dons: He gets to assume an initially sorted list.
15:03:35 <omnId> SideFFect: there are some library functions for finding existance and index for list elements.
15:03:35 <dons> ah ok.
15:03:45 <dons> yes, if its already sorted, that's even simpler
15:04:03 <SideFFect> yeah, but he didnt say anything about doubles
15:04:12 <SideFFect> I dont think there is tho
15:04:18 <SideFFect> doubles in the list I mean
15:05:12 <omnId> well, if it's a [Integer], then no, there wouldn't be :)
15:05:16 <oerjan> > splitAt =<< (`div` 2) . length $ [1..20]
15:05:17 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
15:05:36 <dmwit> omnId: ... that was a *really* bad pun.
15:05:45 <hpaste>  dons pasted "example splitIn2" at http://hpaste.org/3651
15:05:47 <omnId> dmwit: pun?
15:05:49 * chessguy giggles
15:05:52 <oerjan> > join (splitAt.(`div`2).length) $ [1..20]
15:05:53 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
15:05:54 <Olathe> Heheh
15:05:54 <LoganCapaldo> oooooooooooo
15:05:55 <dons> SideFFect: ^^ so there's an example of the entire function
15:05:58 <LoganCapaldo> that was terrible
15:05:58 <dmwit> omnId: He means doubles as in, [3, 3], not [3.0].
15:06:04 <dons> SideFFect: which also shows the use of 'where' to declare variables
15:06:05 <omnId> oh, right.
15:06:07 <dons> similar to 'let'
15:06:11 <bos> dear peanut gallery, i solicit your opinion.
15:06:12 <LoganCapaldo> dmwit: why did you point that out?
15:06:13 * omnId misunderstood :)
15:06:21 <LoganCapaldo> my brain hurts now
15:06:22 <chessguy> accidental puns are the best kind :)
15:06:29 <oerjan> oh right, fmap = (.) in ->
15:06:31 <omnId> (\xs -> splitAt (length xs `div` 2) xs) [1..20] -- showoffs >_>
15:06:34 <dmwit> Hi, bos!
15:06:35 <omnId> > (\xs -> splitAt (length xs `div` 2) xs) [1..20] -- showoffs >_>
15:06:36 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
15:06:37 <bos> why do people often use fmap as an operator, as in (1+) `fmap` [1,2,3], but just about never use map in the same way?
15:06:40 <SideFFect> my brain hurted a while ago
15:07:04 <SideFFect> well still does heh
15:07:04 * chessguy tosses a few peanuts in bos' direction
15:07:18 <TSC> Because in that case they're thinking of fmap as (.), which naturally goes in the middle
15:07:24 <dons> bos, I find it improves readibitliy by breaking up the sentence too
15:07:32 <dons> though <$> is a bit nicer again
15:07:37 <bos> aye.
15:07:45 <dons> whereas prefix is for lispers
15:08:09 <dons> some people I respect don't like this idiom though (heh)
15:08:12 <omnId> it's fun to write all operators prefix in a sea of parens!  Looks quite lispy!
15:08:16 <ddarius> I don't like using `fmap` or `liftM`.
15:08:23 <bos> you don't?
15:08:24 <ddarius> I think it's ridiculous.
15:08:27 <dons> such as ddarius and sjanssen. its the new n+k :)
15:08:44 <ddarius> <$> is fine though.
15:08:49 <faxathisia> What's the news n+k?
15:08:59 <faxathisia> I don't understand I though <$> is just an operator
15:09:22 <omnId> faxathisia: it's disliked in the same way people dislike n+k patterns.
15:09:28 <dcoutts> faxathisia: dons means as a thing for people to argue over
15:09:41 <SideFFect> ok so split is done...it now takes a list from the user and divides it
15:09:53 <jaj> I'm definitely lacking basic haskell knowledge. I have a function "getData :: IO String" and I just set "main = getData". When I load the module in ghci and type "main" it outputs what I expect, however when I compile the program and run it it doesn't print anything :/
15:09:58 <faxathisia> I don't understand what you are talking about
15:10:00 * dons waits for someone to write "Idioms considered a harmful idiom"
15:10:14 <faxathisia> What is the new thing which is bad
15:10:17 <omnId> jaj: do stuff <- getData; print stuff
15:10:25 <ddarius> faxathisia: Using fmap or liftM infix.
15:10:25 <Olathe> "'considered harmful' considered harmful"
15:10:26 <dons> ('Idioms' were a former name for applicative functors, for those who forget)
15:10:27 <SideFFect> now, if I wish to find where a certain value is...I need to see which lists head has the bigger value, compare it, and then work with that list
15:10:33 <chessguy> jaj, main must be of type IO ()
15:10:33 <dmwit> jaj: main = getData >>= putStrLn
15:10:35 <SideFFect> recursively breaking it up right?
15:10:46 <omnId> jaj: main should have type IO (), and print does the printing.  ghci will insert the print for you.
15:10:49 <faxathisia> hmm
15:10:51 <dons> SideFFect: yep.
15:11:02 <dons> SideFFect: so you'd do an if-then-else switch
15:11:07 * ddarius reads fmap f xs the same way he reads map f xs, as map f over xs so f `fmap` xs makes no sense.
15:11:15 <dmwit> jaj: GHCi prints it because it evaluates the IO action and sees that it is not (), printing it as a convenience to the user.
15:11:15 <SideFFect> lets see if I can get that
15:11:15 <dons> and then pick one or the other list to search recursively
15:11:31 <dons> SideFFect: also, you better think about your base case -- when do you stop?
15:11:33 <jaj> omnId, thanks!
15:11:40 * ddarius similarly reads liftM f as lift f to a monadic function so again f `liftM` xs would make no sense.
15:11:43 <bos> i think `fmap` is just a teeny weeny meme, then.
15:11:48 <dons> yep
15:12:04 <dons> i note that i never saw this idiom until @pl started using it..
15:12:04 <SideFFect> the teacher wants us to stop when one list is only one bigger then the other
15:12:05 <LoganCapaldo> There's no STT is there?
15:12:16 <SideFFect> meaning j /= k+1
15:12:16 <SamB> didn't people stop arguing about n+k long ago?
15:12:26 <LoganCapaldo> n+k is awesome!
15:12:30 <ddarius> LoganCapaldo: No if I understand what you are asking.
15:12:30 * LoganCapaldo ducks
15:12:34 <Olathe> n+k is the work of SATAN !
15:12:39 <SamB> LoganCapaldo: you are kidding, right?
15:12:40 * Olathe gets out his pitchfork.
15:12:47 <dons> all the energy has gone out of the n+k debate
15:12:49 <dons> no one cares now
15:12:54 <Olathe> Oh.
15:12:54 <faxathisia> what about  `mplus` ?
15:12:55 * omnId throws Olathe into GHC evaluator.
15:12:56 <SamB> I care
15:12:58 * Olathe deflates suddenly.
15:12:59 <chessguy> flamewar >>= LoganCapaldo
15:13:00 <SamB> mildly
15:13:01 <ddarius> That's because the Report says it's to be avoided.
15:13:11 <SamB> I want it to go away sometime
15:13:29 <SamB> I don't particularly care when, though
15:13:33 <faxathisia> is `mplus` ok?
15:13:34 <goalieca> heh
15:13:35 <SamB> it doesn't bight me very often
15:13:43 <LoganCapaldo> let (++) = mplus
15:13:44 <SideFFect> back to teaching sideffect :D
15:14:25 <ddarius> Of course Haskell Reports have been saying it's on its way out for over a decade now.
15:14:38 <ddarius> faxathisia: Yes.
15:14:39 * wli would like 1.3 -style bits like Functor's method to be map vs. fmap and MonadPlus' method to be (++) vs. mplus.
15:14:41 <omnId> view patterns, like (nplus 1 -> n) with nplus k n | k <= n = Just (n-k) | otherwise = Nothing, subsume n+k nicely.
15:14:46 <SideFFect> I can make a function that takes 2 values, say find x ys = splitIn2 ys
15:14:53 <SideFFect> but then how would I use my x with that?
15:15:21 <dons> so you'd save the result of splitting the list into two variables
15:15:34 <dons> and then test which one to search recursively
15:15:40 <Olathe> SideFFect: find x ys = let (as, bs) = splitIn2 ys in ...
15:15:56 <SideFFect> I see
15:15:57 <Olathe> Then, the left half is in the variable as, the right half is in bs.
15:16:06 <SideFFect> brb
15:16:41 <Karle> Why the compiler pointed error out to the line which does not contain anything?
15:16:42 <SideFFect> this is interesting...im learning more here then 9 weeks of this term
15:16:59 <chessguy> SideFFect, that's typical for this channel
15:17:08 <SideFFect> all he taught us was definitions of functions, map, etc
15:17:09 <dmwit> Karle: Probably some indentation error or so earlier in the file.
15:17:13 <SideFFect> not how to write a program
15:17:25 <dmwit> Karle: Care to paste?
15:17:29 <monochrom> That is typical of any programming course.
15:17:35 <monochrom> Any language.
15:17:39 <SideFFect> thanks guys, I appreciate it
15:17:51 <SideFFect> thats not true, ive taken courses that really explain things
15:18:01 <SideFFect> like learning java for the first time
15:18:04 <dons> yeah, it depends on the views of the teacher
15:18:04 <SideFFect> it all depends on the teacher
15:18:06 <monochrom> Right, but did I say typical?
15:18:13 <dons> i always started with firing up ghc and vim.
15:18:15 <omnId> "typical" not "alway true" :)
15:18:22 <SideFFect> heh
15:18:24 <omnId> +s*
15:18:27 <dons> even when i was teaching perl..
15:18:32 <monochrom> PLEASE READ :)
15:18:59 <ddarius> What did you use GHC for when teaching Perl?
15:19:09 <LoganCapaldo> pugs
15:19:11 <dons> nope
15:19:30 <dons> just explaining types/semantics of perl functions, and prototyping
15:19:43 <dons> and testing
15:19:57 <SideFFect> when I make my haskell file
15:19:59 <hpaste>  Karle pasted "help" at http://hpaste.org/3652
15:20:13 <SideFFect> what comes first? the find or the splitIn2 definition?
15:20:26 <dons> so basically haskell as a pseudocode for perl, with clearer foundations
15:20:26 <SamB> SideFFect: what is this "first" business?
15:20:30 <monochrom> Come to think of it, my English and Chinese teachers seldom taught how to compose.
15:20:32 <ddarius> It doesn't matter?
15:20:36 <ddarius> er -?
15:20:37 <SideFFect> oh ok
15:20:39 <dons> SideFFect: it doesn't matter, as peopel say
15:20:47 <SideFFect> dunno thought there was a certain way haskell read the code
15:20:50 <dons> there's no assumed top-to-bottom evaluation order.
15:20:59 <SideFFect> like if something is defined before another it wont work
15:20:59 <dons> so you can structure it as you see fit
15:21:03 <dons> nope.
15:21:09 <SideFFect> but since its functions they just call one another anyways
15:21:10 <ddarius> declarations aren't evaluated
15:21:12 <dons> > let x = y ; y = 1 in x -- see
15:21:14 <monochrom> There is no "declare before use" rule.
15:21:15 <SamB> SideFFect: as long as you use valid syntax
15:21:20 <dons> my poor bot
15:21:20 <lambdabot>  1
15:21:25 <SideFFect> yeah which is a pain in its own
15:21:27 <SideFFect> the syntax
15:21:32 <SideFFect> usign GHCI
15:21:33 <oerjan> Karle: must be right after that maybe.  type errors give the line at the beginning of a large expression sometimes, i think
15:21:43 <dons> programming is pain, SideFFect :)
15:21:56 <SideFFect> heh nah, I like it...OpenGL, C++, I dont mind
15:21:58 <dons> it can be bad, sharp pain, or just a dull ache
15:22:01 <SamB> but, I mean, it isn't like Python where your code is read and executed "statement" by "statement"
15:22:03 <ddarius> Apparently dons is both sadistic and masochistic.
15:22:13 <Karle> oerjan, ok
15:22:14 <dons> ok, so you're into masochism
15:22:23 <SideFFect> hehe
15:22:31 <SideFFect> nah just into becoming a game programmer
15:22:46 <omnId> learning Haskell is a delightful pain that leads into payoff.
15:22:47 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3652#a1
15:22:51 <ddarius> SideFFect: THat will probably pass.
15:22:58 <SamB> SideFFect: indeed
15:23:05 <SideFFect> but its not used in sensitive programming though
15:23:12 <dons> omnId: and all about delayed gratification
15:23:20 <ddarius> "sensitive"?
15:23:20 <SamB> that's like the most highly concentrated form of pain known to programmerkind
15:23:26 <SideFFect> haskell isnt good for say, calculating how a plane wing should rotate to adjust w/ wind speed
15:23:30 <dons> oh?
15:23:32 <SamB> well, besides "pain due to idiots"
15:23:33 <SideFFect> thats what our teacher said at least
15:23:36 <dons> oh, you mean real time ?
15:23:40 <SideFFect> and all teachers agree
15:23:40 <SideFFect> yeah
15:23:48 <Karle> omnId, tell me more please about paying off :)
15:23:52 <SideFFect> imperative is more real-time
15:23:53 <SamB> well, you don't want to just write haskell for that
15:23:56 <dons> real time systems are fairly specialised
15:24:01 <SideFFect> haskell is great for calculating small adjustments
15:24:03 <dons> some people use haskell for soft real time though
15:24:03 <oerjan> Karle: but, i see no [pk,ad,pa] in there?
15:24:03 <SideFFect> and stuff
15:24:10 <ddarius> imperative is not more real-time
15:24:19 <SideFFect> is it faster?
15:24:20 <SamB> you don't want the Haskell code on the plane, no
15:24:23 <omnId> Karle: it helps if you're doing it out of fun instead of towards a grade :)
15:24:30 <LoganCapaldo> the snakes might confuse it
15:24:33 <faxathisia> SideFFect: "imperative is more real-time" I don't agree with that
15:24:34 <SideFFect> heh
15:24:35 <SideFFect> :P
15:24:40 <faxathisia> SideFFect: But how do you draw that conclusion?
15:24:47 <SideFFect> my teacher did, not me
15:24:48 <Olathe> Samuel L Jackson certainly will.
15:24:54 <faxathisia> SideFFect: What was his reasons?
15:24:57 <SideFFect> I know nothing of the language, I just saw it 7 weeks ago
15:24:58 <dons> haskell's rather good for sensitive situations, but garbage collection and hard real time systems are an open question, iirc
15:25:23 <Karle> omnId, I agree for me it is not so fun.... a newbie who has to do quite complicated thing
15:25:24 <ddarius> dons: No they're not.
15:25:28 <SamB> "sensitive situations" being?
15:25:29 <SideFFect> no reasons, he just said"You dont want haskell controlling a full plane"
15:25:29 <LoganCapaldo> region inference + real time systems?
15:25:35 <dons> i've seen haskell used to control an accelerator in a solar car, in real time
15:25:40 <faxathisia> SideFFect: And you didn't attack him ?
15:25:41 <dons> so perhaps its not so bad :)
15:25:48 <SideFFect> I didnt know if he was right or wrong
15:25:52 <SideFFect> so I couldnt say :P
15:25:53 <faxathisia> SideFFect: :p I always ask someone for reasons if I can't figure them out myself
15:25:54 <Karle> oerjan, i will the line
15:25:57 <Olathe> I've seen Haskell used to split a list clean in half with its bare hands !
15:26:02 <SideFFect> hehe
15:26:09 <SamB> dons: solar cars are expected to be reliable now?
15:26:20 <LoganCapaldo> it's good to ask for reasoning even if you can come up with some on your own. you might be wrong
15:26:27 <dons> SamB: that was part of it, yes.
15:26:30 <SamB> dons: I hope it wasn't also controlling the brake?
15:26:44 <LoganCapaldo> mmm lazily evaluated braking
15:27:00 <SideFFect> heh
15:27:04 <dons> it would work out the resistance on the tyre, and accelerate or break to ensure the speed remained constant (e.g. when climbing hills)
15:27:13 <SideFFect> if its lazily evaluated, the breaks will always be on, just in case
15:27:14 <omnId> I read a comment on proggit that Lava, for example, used Haskell to express tight embedded things that compile to low level stuff.
15:27:14 <SideFFect> :P
15:27:15 <dons> all compiled with nhc, onto an arm device
15:27:25 <SamB> dons: but the break pedal?
15:27:29 <SamB> er.
15:27:31 <SamB> brake
15:27:33 <SamB> Whatever
15:27:37 <ddarius> brake
15:27:44 <Olathe> Ctrl-Brake
15:27:46 <ddarius> omnId: Lava is a hardware description language.
15:28:00 <omnId> ddarius: cool.
15:28:04 <SamB> ddarius: apparantly someone hacked it to make C code too...
15:28:10 <Karle> oerjan... I cannot find the line ... a bit strange
15:28:22 <SamB> I think there was a TMR article about it
15:28:41 <omnId> Karle: is there any line that look like [pk,ad,pa], and are you sure you've saved recently? :)
15:30:05 <Karle> omnId : yes I just compiled my old code from last night which consists [pk,ad,pa]
15:30:07 <oerjan> so, haskell is quite usable for _generating_ real-time programs, apparently
15:30:23 <Karle> :)
15:30:46 <oerjan> Karle: has the error disappeared then?
15:31:07 <ddarius> Certainly, full Haskell is inappropriate for hard real-time programs, but a cut-down version could be used.  This is, incidentally, more or less the case with the vast majority of other languages.
15:31:20 <SideFFect> if its so useful, why dont more ppl use it? or its because of big bad MS as our teacher says
15:31:27 <SamB> ddarius: how about BF
15:31:29 <SideFFect> that if MS decided we all should use haskell, we all would
15:31:45 <Olathe> Heheh
15:31:49 <omnId> SideFFect: Simon Peyton Jones, big daddy of GHC, works for MS research.
15:31:51 <SamB> big bad MS pays for Haskell...
15:31:52 <LoganCapaldo> I use a cutodwn version of itanium assembly for my hard real time systems :)
15:31:54 <faxathisia> SideFFect: I think you should murder your teacher
15:32:01 <ddarius> SideFFect: Microsoft just productized F#, a language based on O'Caml and related to the Haskell family.
15:32:03 <SideFFect> maybe a Visual Haskell ++?
15:32:04 <faxathisia> SideFFect: Or at least slaughter him with questions
15:32:04 <SideFFect> lol
15:32:06 <Olathe> C# is not something I'm using.
15:32:09 <dons> ddarius: did you just say 'productized' ?
15:32:18 <SideFFect> oh they did? I'll tell my teach heh
15:32:19 <ddarius> Also a lot of ideas that are making their ways into C# are from Haskell.
15:32:22 <Karle> :-) sorry guys ... after late nights working on haskell... It turned out that I work on another file which has similar name
15:32:29 <LoganCapaldo> productized is a perfectly cromulent word
15:32:29 <SamB> dons: it's like murderizing
15:32:32 <SamB> only less extreme
15:32:41 <oerjan> Karle: heh :)
15:32:51 * omnId pokes LoganCapaldo 
15:33:08 <SideFFect> ok, now I have my find function taking in a value and a list and outputting the list divided into 2
15:33:13 <SideFFect> now onto comparing :P
15:33:47 <oerjan> Karle: btw you usually want your file name to start with a capital, like the corresponding module name (although for Main it usually doesn't matter)
15:33:49 <SideFFect> man I wish id found this channel sooner
15:34:06 <SideFFect> would have saved me 2-3 days of grief
15:34:08 <ddarius> SideFFect: It's not like it is hidden.
15:34:21 <Karle> oerjan : thanks for the tip!
15:34:30 <Olathe> > let split xs = split' xs xs; split' (a:bs) (_:_:cs) = let (l,qs,rs) = split' bs cs in (l + 1, a:qs, rs); split' bs _ = (0, [], bs) in split "Haskell is quite spiffy !"
15:34:32 <lambdabot>  (12,"Haskell is q","uite spiffy !")
15:34:34 <SideFFect> I know, I like to try until all my ideas run dry then go nuts looking for help
15:34:50 <ddarius> That seems false.
15:34:52 * ddarius watches a movie.
15:35:04 <SideFFect> Olathe whats the 12 from?
15:35:04 <LoganCapaldo> SideFFect: that's a bad habit
15:35:20 <faxathisia> one thing I love about haskell is being able to call functions and variables with a prime in the name like x'
15:35:23 <SideFFect> well, I thought I had enuff tools/resources from the teacher
15:35:23 <Olathe> SideFFect: The number of items on the left.
15:35:29 <SideFFect> ahh I see
15:36:05 <LoganCapaldo> > let faxathisiaLike'sThisFeature = True in ()
15:36:06 <lambdabot>  ()
15:36:26 <ninjawarrior82> can someone just give me a little help please
15:36:28 <ninjawarrior82> if you have a list of strings like this ["A","B","C"] is it possible to simply output them as "A B C" as opposed to the standard ["A","B","C"]?
15:36:31 <Olathe> statement >>= killBadApostrophe
15:36:33 <SideFFect> all I want to do is play Bioshock and Guitar Hero 3
15:36:34 <SideFFect> sigh...
15:36:35 <omnId> LoganCapaldo: no apostrophe in the present perfect conjugation!
15:36:36 <mauke> ninjawarrior82: unwords
15:36:42 <ninjawarrior82> cheers
15:36:44 <faxathisia> LoganCapaldo:D
15:36:52 <ninjawarrior82> i knew it was simple i just couldnt remember it!
15:37:01 <Olathe> @src unwords
15:37:01 <lambdabot> unwords [] = ""
15:37:01 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
15:37:06 <ddarius> SideFFect: Try to find a job where that is what you do.
15:37:09 <omnId> ninjawarrior82: check the Data.List docs for stuff like that.
15:37:15 <SideFFect> that doesnt pay much :P
15:37:40 <olsner> LoganCapaldo doesn't know his english morphology :(
15:38:03 <LoganCapaldo> me speak english good
15:38:04 <oerjan> Data.List is your friend, and eventually Control.Monad too once you wrap your brain around it
15:38:14 <omnId> LoganCapaldo: it's spelled 'gud', get it right.
15:38:38 <LoganCapaldo> Me only fail grammar me good speller.
15:38:56 <oerjan> omnId: don't take the name of the Lord in vain!
15:39:49 <ddarius> Mosquitos are proof positive that God does not exist.
15:40:06 <SamB> what if God was annoyed with us
15:40:38 <conal> what if god is a mosquito?
15:40:42 <SideFFect> guys, can I put an if statement after an in statement?
15:40:50 <oerjan> SideFFect: sure
15:40:55 <ddarius> There are no if statements.
15:40:55 <SamB> what's an if statement?
15:40:55 <SideFFect> alrighty
15:40:59 <nornagon> conal: don't be silly, god is the mosquito *combinator*
15:40:59 <SamB> what's an in statement?
15:41:01 <SideFFect> new line or same line?
15:41:02 <oerjan> except they're expressions, not statements
15:41:03 <LoganCapaldo> yes except if is not a statement
15:41:17 <nornagon> His type is parametric over all mosquitoes
15:41:19 <omnId> SideFFect: "if expression", it's a lot like C's (test ? val1 : val2)
15:41:27 <dmwit> SideFFect: Warning: #haskell is extremely pedantic.
15:41:30 <faxathisia> let foo = bar in if baz then quux else ...
15:41:31 <SideFFect> does anyone have a good interpreter I can work in?
15:41:32 <faxathisia> run out of words :(
15:41:39 <SideFFect> GHCI is very fussy w/ indents and stuff
15:41:42 <omnId> SideFFect: ghci or hugs
15:41:44 <SamB> dmwit: sometimes
15:41:44 <faxathisia> SideFFect: Use a text file
15:41:49 <Olathe> ghci !
15:41:49 <faxathisia> SideFFect: You can juts :load myCode
15:41:57 <SamB> we've given up on the "statements aren't statements" thing, I think
15:42:00 <faxathisia> SideFFect: in ghci :D
15:42:00 <SideFFect> using GHCI?
15:42:03 <dmwit> SamB: I believe you just proved my point. =)
15:42:04 <SideFFect> ah nice!
15:42:05 <ddarius> dmwit: To some extent, there is significance to the pedantry.
15:42:11 <SideFFect> so I dont need the silly tabs then?
15:42:20 <Olathe> The Pedantry Pageantry !
15:42:29 <LoganCapaldo> > let ifIsAStatement = False in (if ifIsAStatement then "you couldn't " else "you could ") ++ "do this"
15:42:31 <lambdabot>  "you could do this"
15:42:32 <omnId> Olathe: say that five time fast.
15:42:36 <conal> nornagon: yeah -- that is more likely
15:42:52 <faxathisia> What is a statement?
15:42:55 <SideFFect> faxathisia: I dont need tabs in the text file do I?
15:43:07 <faxathisia> SideFFect: I don't think I ever have tabs in my code
15:43:14 <SideFFect> cool ill try it thanks
15:43:24 <dmwit> SideFFect: Tabs, no, whitespace or explicit braces, yes.
15:43:29 <SamB> > let ifIsAStatement = False in (if ifIsAStatement then "you can't " else "you can ") ++ "do this"
15:43:30 <lambdabot>  "you can do this"
15:43:43 <oerjan> SideFFect: haskell is indentation-based, everywhere.  although you _can_ replace indentation blocks by { ; } brackets
15:43:54 <omnId> but you *can* do that, so both clause would be "you can't"
15:43:57 <LoganCapaldo> I think my lack of grasp of english is well-established at this point
15:43:58 <omnId> s*
15:44:08 <omnId> darnit I'm having trouble with plurals tonight.
15:44:09 <SamB> omnId: what?
15:44:13 <SamB> I don't understand you
15:44:25 <faxathisia> SamB: I don't understand :/
15:44:34 <SamB> if if was a statement, you would get a syntax error
15:44:36 <faxathisia> Is statement defined in haskell
15:44:52 <dibblego> where did System.Directory go from 6.8.1?
15:44:59 <ddarius> faxathisia: do-notation arguably introduces statements.
15:45:08 <ddarius> But in a rather weak way.
15:45:16 <SamB> are they called Stmts or something?
15:45:23 <omnId> SamB: right, I guess my englishy reading of that expression confused me a bit.
15:45:28 <omnId> SamB: in TH they are.
15:45:33 <faxathisia> ah ok
15:45:36 <SideFFect> ghci cant find my text file?
15:45:54 <SideFFect> im at the prelude screen and i type :load Split2
15:45:59 <omnId> SideFFect: is ghci in the right directory?
15:46:00 <dmwit> SideFFect: :l Split2.hs
15:46:02 <SideFFect> but could not find module it says
15:46:11 <SideFFect> its a text file tho
15:46:14 <dmwit> You have to give a file name.
15:46:19 <SideFFect> or does it have to be a .hs file?
15:46:20 <LoganCapaldo> you can also do ghci spli2.hs
15:46:21 <faxathisia> > ((Control.Monad.liftM (1+)) (do return 1)) :: Maybe Int
15:46:23 <lambdabot>  Just 2
15:46:31 <dmwit> SideFFect: It can be in any file, but you have to give the entire file name.
15:46:39 <SideFFect> i did
15:46:43 <SideFFect> :load Split2.txt
15:46:43 <faxathisia> so ;/
15:46:46 <SamB> and if you want to be able to import it it should be a .hs file
15:46:52 <faxathisia> What is a statement
15:47:02 <faxathisia> I don't see why do is different than if
15:47:05 <omnId> Prelude> :! echo main = putStrLn "blah" > test.txt
15:47:05 <omnId> Prelude> :l test.txt
15:47:05 <omnId> <command line>:
15:47:05 <omnId>     Could not find module `test.txt':
15:47:25 <omnId> Prelude> :! echo main = putStrLn "blah" > test.txt
15:47:25 <omnId> Prelude> :l test.txt
15:47:25 <omnId> <command line>:
15:47:25 <omnId>     Could not find module `test.txt':
15:47:26 <SideFFect> so whats the problem?
15:47:28 <omnId> oops
15:47:30 <oerjan> SideFFect: btw on indentation, most of use prefer to use editors that automatically turn tabs into spaces, for haskell
15:47:36 <hpaste>  Harry pasted "Data.Tree" at http://hpaste.org/3654
15:47:37 <omnId> Prelude> :! ren test.txt test.hs
15:47:37 <omnId> Prelude> :l test.hs
15:47:37 <omnId> [1 of 1] Compiling Main             ( test.hs, interpreted )
15:47:37 <omnId> Ok, modules loaded: Main.
15:47:41 <omnId> there we are.
15:47:54 <dmwit> huh
15:47:54 <SideFFect> ah has to be .hs? but then it needs the indents then
15:48:04 <omnId> what indents?
15:48:38 <Olathe> Tabs are the work of evil, evil people.
15:48:39 <SamB> SideFFect: you could use {;}
15:48:44 <Karle> this one is complicated for me
15:48:53 <SideFFect> with the brackets?
15:48:58 <LoganCapaldo> with the backets
15:49:03 <SideFFect> alrighty
15:49:04 <LoganCapaldo> and the semicolons
15:49:09 <SideFFect> heh yes
15:49:45 <dmwit> SideFFect: I'm not sure why you would prefer backets and semicolons to indentation.
15:49:50 <dmwit> Do you have a reason?
15:50:16 <SideFFect> im not sure how many indents each takes
15:50:19 <SideFFect> like per command
15:50:25 <SideFFect> ive seen some have 2 and some have 1
15:50:30 <omnId> ?
15:50:34 <mauke> haskell doesn't care
15:50:42 <mauke> use how many you want
15:50:45 <omnId> indeed, he's dead
15:50:47 <LoganCapaldo> haskell doesn't care as long as you are consistent
15:50:49 <dmwit> As long as you are consistent, it doesn't matter.
15:50:52 <SideFFect> ah
15:50:55 <oerjan> SideFFect: the amount of indentation doesn't matter, it's just whether things are indented more or the same
15:51:05 <dmwit> (or less)
15:51:14 <SideFFect> parse error on 'if'
15:51:21 <dmwit> ?hpaste
15:51:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:51:29 <hpaste>  Karle pasted "Please help" at http://hpaste.org/3655
15:51:58 <hpaste>  SideFFect pasted "trytryagain" at http://hpaste.org/3656
15:52:02 <SamB> http://www.haskell.org/onlinereport/lexemes.html#sect2.7
15:52:03 <SideFFect> pasted
15:52:03 <lambdabot> Title: Haskell 98 Lexical Structure
15:52:24 <SideFFect> I was just seeing the way it works
15:52:31 <faxathisia> SideFFect: putStrLn is not the same as C printf
15:52:44 <oerjan> Karle: what is the type of scanU?
15:53:16 <Karle> scanU :: (a -> Int) -> (a -> [b] -> a) -> a -> Signal b -> Signal a
15:53:33 <omnId> SideFFect: '(as, bs) if x < ...' is not a correctly formed expression.  Delete the (as, bs)
15:53:48 <agl> trying to port to 6.8.1 I get a syntax error at the first "->" in 'foreign import ccall unsafe "memcpy" _copy_in :: ByteArray# -> Ptr () -> CSize -> IO ()' - I could understand an error if ByteArray# had moved - but a syntax error?
15:54:23 <SideFFect> I took off the last (as,bs) now parse error for indentation
15:54:25 <SideFFect> sigh
15:54:25 <dons> agl: or missing -fglasgow-exts?
15:54:28 <ddarius> faxathisia: It's not 'do' that is the statement it is the 'a <- m' statements.
15:54:38 <mauke> SideFFect: you're missing an 'else'
15:54:42 <omnId> SideFFect: the if needs an else clasuse
15:54:43 <oerjan> Karle: that 1 looks fishy, it's at the place of an argument that should be a function
15:54:45 <faxathisia> ddarius: Oh ok
15:54:48 <SideFFect> oh yeah
15:54:49 <agl> dons:  it's not the first foreign import in the file - do I need glasgow-exts for anything else there?
15:54:52 <omnId> excuse me, *sniffle*
15:54:53 <SideFFect> each if needs a then else
15:55:07 <agl> dons:  (e.g. the previous imports work ok)
15:55:08 <Karle> oerjan, I agree
15:55:10 <dons> agl, and a -fffi or -XForeignFunctionInterface or some such
15:55:12 <Raguel> anyone know any good math channels?
15:55:15 <dons> agl: oh.
15:55:20 <mauke> agl: for the #
15:55:21 <dons> probably the # char
15:55:25 <omnId> Raguel: #math?
15:55:27 <Raguel> specifically matrixes
15:55:31 <SideFFect> works now thanks :P
15:55:33 <Raguel> what node is that on
15:55:34 <Raguel> thing
15:55:49 <agl> dons:  ok, I'll give that a shot
15:55:58 <omnId> hm?  can't you just /join #math?
15:56:10 <oerjan> Karle: also, shouldn't update_pr take an argument? (you _might_ be doing pointfree style, but...)
15:56:13 <Raguel> there we go :)
15:56:52 <Karle> update_pr should take an argument .. yes
15:57:49 <Karle> oerjan, I think it is pointfree style like you said
15:58:04 <oerjan> oh, you didn't write that yourself
15:58:43 <dons> base 3.0! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/base-3.0.0.0 :)
15:58:45 <lambdabot> http://tinyurl.com/2j8gbh
15:58:58 <oerjan> Karle: a hunch, should the 1 be after update?
15:59:10 <Karle> oerjan, it is a part of instruction given
15:59:37 <oerjan> they give you buggy programs to fix? o_O
15:59:49 <omnId> > splitAt (0 `div` 2) [] -- SideFFect, I think your [] case for the splitIn2 function isn't neccessary.
15:59:51 <lambdabot>  ([],[])
16:00:05 <agl> dons:  thanks, that worked - now I just need to figure out which -X value it is
16:00:53 <LoganCapaldo> oerjan: that sounds liek a great idea. it's what I do all day at work anyway, might as well get some training in :)
16:00:59 <Notrix> is there a good way using pattern matching to check if a list given in parameter to a function has just an element ?
16:01:06 <Notrix> x:[] sounds rubbish :s
16:01:09 <dons> [a]
16:01:15 <oerjan> Karle: what are the types of gma and update?
16:01:25 <omnId> (x:[]) and [a] are the same, many prefer the second.
16:01:41 <Notrix> okay so i'll use the second one :), thank you
16:01:46 <Karle> update:: Table-> [Pkg]-> Table
16:01:47 <omnId> f xs | length xs == 1 = ... -- hehe
16:01:47 <sioraiocht> @src fix
16:01:48 <lambdabot> fix f = let x = f x in x
16:02:18 <Karle> gma:: a -> Int
16:02:58 <hpaste>  oerjan annotated "Please help" with "types" at http://hpaste.org/3655#a1
16:04:51 <oerjan> gma has the right type
16:05:19 <oerjan> if 1 is moved after update, things still aren't quite right
16:05:22 <oerjan> but better
16:05:32 <faxathisia> What does this mean Equations for `evalOper' have different numbers of arguments ?:|
16:05:33 <sioraiocht> @type fix f = let x = f x in x
16:05:34 <lambdabot> parse error on input `='
16:05:50 <sioraiocht> @type (\ f -> let x = f x in x)
16:05:51 <lambdabot> forall t. (t -> t) -> t
16:05:53 <dons> faxathisia: you've defined them in a couple of places with different numbers of arguments
16:05:59 <Karle> oerjan, it was recommended to use "update_pr = scanU gma update []"
16:06:07 <faxathisia> dons: Why is that a problem?
16:06:14 <Karle> oerjan, what do you think about it?
16:06:23 <oerjan> that sounds much better
16:06:51 <Karle> :)
16:06:59 <dons> faxathisia: you can't infer a type for the function if it has different numbers of arguments
16:07:10 <dons> (basically)
16:07:50 <faxathisia> I don't think I understand how haskell does type inferrence for this then
16:08:09 <dons> what's the type of your function?
16:08:14 <Karle> oerjan, it seems that the types are not matched
16:08:15 <Notrix> is it possible to have a list of function ?
16:08:19 <dons> Notrix: sure
16:08:25 <faxathisia> evalOper :: Oper -> Int -> Int -> Int
16:08:26 <LoganCapaldo> Notrix: absoutely
16:08:26 <oerjan> but you need update :: Table -> [[(Pkg,Pkg)]] -> Table or something like that
16:08:27 <omnId> @type [id, (+1), (/2)]
16:08:29 <lambdabot> forall a. (Fractional a) => [a -> a]
16:08:34 <dons> > map ($4) [id, (+1), (*2)]
16:08:36 <lambdabot>  [4,5,8]
16:08:38 <dons> omnId: how interesting :)
16:08:43 <dons> we chose almost the same examples
16:08:45 <faxathisia> Sometimes I wish I could write evalOper Add = (+)
16:08:46 * omnId channels dons
16:08:50 <faxathisia> and other times evalOper Equal x y = if x == y then 1 else 0
16:09:06 <dons> faxathisia: you'll need to put the patterns in, unfortunately
16:09:23 <Notrix> when i try to stock the function in a list, i have an error (of course), because it tries to apply this function
16:09:29 <Notrix> ex : [cos,sin]
16:09:31 <oerjan> yes, i think that would be it
16:09:32 <faxathisia> dons: ok thank you
16:09:33 <dons> :t cos
16:09:34 <dons> :t sin
16:09:35 <LoganCapaldo> evalOper Equal = (fromEnum .) . (==)
16:09:35 <lambdabot> forall a. (Floating a) => a -> a
16:09:35 <lambdabot> forall a. (Floating a) => a -> a
16:09:39 <omnId> faxathisia: or else move the one with more arguments to lambdas on the rhs
16:09:39 <dons> :t [cos, sin]
16:09:41 <lambdabot> forall a. (Floating a) => [a -> a]
16:09:50 <dons> map ($ pi) [cos, sin]
16:09:50 <hpaste>  Karle annotated "Please help" with "Please help" at http://hpaste.org/3655#a2
16:09:56 <dons> > map ($ pi) [cos, sin]
16:09:57 <lambdabot>  [-1.0,1.2246063538223773e-16]
16:10:09 <omnId> > sequence [cos, sin] pi
16:10:10 <lambdabot>  [-1.0,1.2246063538223773e-16]
16:10:28 <faxathisia> now the hard part
16:10:34 <faxathisia> choosing to do it all point free or not :p
16:10:37 <Notrix> oh it means i've got another error in my code :p
16:11:01 <Notrix> how would you stock the (*) function ?
16:11:18 <omnId> "stock"?
16:11:30 <omnId> the functions need to have the same type.
16:11:32 <Notrix> > map (\x 3 x 4) [(*)]
16:11:32 <lambdabot>  Parse error at ")" (column 14)
16:11:42 <Notrix> > map (\x -> 3 x 4) [(*)]
16:11:42 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> b))
16:11:43 <lambdabot>     In...
16:11:44 <Karle> oerjan, let me think a bit
16:11:48 <omnId> Notrix: `x`
16:11:56 <Notrix> > map (\x -> x 3 4) [(*)]
16:11:57 <lambdabot>  [12]
16:12:02 <Notrix> whoaw :)
16:12:07 <omnId> :D
16:12:14 <Notrix> haskell is so nice
16:12:19 <oerjan> Karle: yeah, that's because of update's wrong type which i just mentioned, i think
16:12:32 <omnId> @pl \f -> f x y
16:12:32 <lambdabot> flip ($ x) y
16:12:48 <omnId> map (flip ($ 3) 4) [(*)]
16:12:50 <omnId> > map (flip ($ 3) 4) [(*)]
16:12:51 <lambdabot>  [12]
16:13:21 <omnId> obfuscation++
16:13:48 <Notrix> haha :p
16:13:59 <Notrix> i've got so much to learn
16:14:23 <faxathisia> omg!
16:14:35 <faxathisia> I just had the most incredible haskell moment :D
16:14:36 <omnId> lessee, flip f x y = f y x, so (flip ($ 3) 4) (*) = ($ 3) (*) 4
16:14:42 <dons> faxathisia: ?
16:14:46 <omnId> = ((*) $ 3) 4
16:14:49 <omnId> = (*) 3 4
16:14:53 <dfranke> @unpl ((.).(.))
16:14:54 <lambdabot> (\ i b c f -> i (b c f))
16:15:03 <faxathisia> dons: I spent 2 days writing this code and it's worked the first time I run it
16:15:08 <faxathisia> dons: Only possible with haskell :D
16:15:10 <omnId> faxathisia: hahaha
16:15:17 <dons> faxathisia: :D
16:15:24 <dfranke> faxathisia: yeah, but the key word is "run" :-)
16:15:28 <Karle> oerjan, what is compared to what? I am abit confused? one is update_pr and?
16:15:33 <dons> the type checker is your guide through the murky land of code
16:15:35 <faxathisia> hehe
16:15:45 <faxathisia> dons: totally
16:15:46 <omnId> faxathisia: it's a rush, isn't it?
16:16:17 <omnId> "HOLY SHIT.  YOU'RE SUPPOSED TO NOT WORK YET!  DON'T YOU KNOW THE RULES?"
16:16:18 <faxathisia> omnId: yeah I love it
16:16:21 <dfranke> @unpl (.)(.)(.)(.)(.)
16:16:22 <lambdabot> (\ f i k l -> f (i (k l)))
16:16:23 <faxathisia> hahaha
16:16:36 <dons> faxathisia: and you budgeted for another 2 days of debugging.
16:16:40 <dons> now you'll just have to go to the beach.
16:16:43 <dons> how sad :)
16:16:55 <oerjan> Karle: one is the type you have given explicitly, the other is the type the compiler inferred from its definition
16:17:38 <Karle> oerjan , the things after =
16:17:52 <oerjan> yep
16:18:30 <omg911> @src liftM
16:18:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:18:57 <Karle> oerjan, any suggestions to match them?
16:19:24 <oerjan> Karle: i already said that above:
16:19:37 <oerjan> "but you need update :: Table -> [[(Pkg,Pkg)]] -> Table or something like that
16:20:22 <oerjan> (exactly like that, i think)
16:21:05 <Karle> oerjan , thanks
16:21:13 <omg911> > newtype Tree a = Leaf a | Branch (Tree a) (Tree a)
16:21:13 <lambdabot>  Parse error at "newty..." (column 1)
16:21:32 <hpaste>  Harry annotated "Data.Tree" with "PLEASE HELP>>>>" at http://hpaste.org/3654#a1
16:21:32 <LoganCapaldo> omg911: lb doesn't do type decls. also you'd use data there
16:21:54 <TSC> Is there a way to remove a user-locally-installed version of GHC that I built from the source?
16:21:56 <omg911> ok
16:22:05 <Karle> oerjan, it accepts the code , thanks!
16:22:07 <LoganCapaldo> newtypes can only have one constructor with one argument
16:22:15 <oerjan> :)
16:22:20 <hpaste>  Harry pasted "PLEASE HELP ME" at http://hpaste.org/3657
16:23:33 <omnId> Harry, erm, you have a get children function, and get parents isn't possible given a child.
16:24:12 <Karle> oerjan, I ran into update errors
16:24:13 <omnId> (are you even here?)
16:24:22 <oerjan> omnId: i don't think he means tree children
16:24:39 <oerjan> it's a tree with genealogy information isn't it
16:24:43 <omnId> oerjan: so all descendants?
16:24:56 <omnId> oh
16:25:03 <omnId> hrm...
16:26:14 <hpaste>  Karle annotated "Please help" with "Please help" at http://hpaste.org/3655#a3
16:27:06 <omnId> that's a highly non-normal
16:27:13 <omnId> Tree type too :)
16:27:20 <omg911> so what's the first a for in "...Node a [(Tree a)]"? to garantee node as at least one child?
16:27:53 <smack_> omg911: there's a value at each node
16:27:55 <omnId> omg911: if you have a Tree of Persons, the a puts a Person at each Node
16:28:24 <omnId> Empty is subsumed by list nil, and Left by Node a [], btw.
16:28:31 <omg911> oh i see now :)
16:28:38 <omnId> Leaf*
16:28:50 <omnId> @src Tree
16:28:50 <lambdabot> Source not found. My brain just exploded
16:28:56 <oerjan> Karle: [[(Pkg,Pkg)]], you're missing parentheses
16:30:13 * oerjan is still suspicious at head, since that throws away all of a list except the first element
16:31:07 <Karle> oerjan, and how should I modify the rest .. my guess is to [] them
16:31:15 <SideFFect> guys, how do I compare an element to a list and ask if its bigger then the head and smaller then the last?
16:31:33 <SideFFect> if x > head ys && x < last ys ?
16:31:43 <omnId> SideFFect: looks good.
16:31:43 <SideFFect> not sure how and is handled in haskell
16:31:47 <SideFFect> yeah?
16:31:48 <SideFFect> cool
16:31:51 <oerjan> Karle: putting [] on all the right sides certainly will make it well-typed but also is unlikely to be what you want it to _do_
16:32:03 <omnId> SideFFect: it'll explode on empty ys, though
16:32:06 <omnId> > head []
16:32:15 <lambdabot>  Exception: Prelude.head: empty list
16:32:28 <SideFFect> I have a test for empty list before it reaches that point tho
16:32:34 <omnId> good
16:32:45 <SideFFect> lets see it work...one sec
16:33:03 <omnId> you might also want (>=) and (<=) if your checking for existence in the list.
16:33:10 <omnId> you're*
16:34:05 <oerjan> SideFFect: btw you should avoid comparing to the last one unless you have to
16:34:24 <oerjan> this was a binary search, wasn't it?
16:34:35 <SideFFect> cool worked :D
16:34:36 <omnId> @. id @ @run unwords . filter (all isUpper) . words $ @show @yow
16:34:38 <lambdabot>   "I"
16:34:40 <omnId> @. id @ @run unwords . filter (all isUpper) . words $ @show @yow
16:34:41 <SideFFect> yeah binary search
16:34:41 <lambdabot>   "NATHAN PARENTS VOIDED COLLAPSED CHAINSAWS MONEY MACHINES PILLS SKIMPY GRASS...
16:34:52 <oerjan> which is silly with lists anyhow.
16:35:04 <faxathisia> :O
16:35:05 <SideFFect> im just trying to get a good way to determine which list to work with
16:35:13 <faxathisia> omnId: Woah!!
16:35:14 <faxathisia> awesome
16:35:25 <omnId> indeed, twanvl++ for @@
16:35:56 <Karle> oerjan, another severe problem
16:36:14 <omnId> @@ @run "checking if the public @@ fix has been incorporated yet"
16:36:16 <lambdabot>  "checking if the public @@ fix has been incorporated yet"
16:36:19 <omnId> cool
16:36:23 <oerjan> ooh
16:36:30 <SideFFect> can we have an if then if nest?
16:36:34 <SideFFect> or just if then else if
16:36:35 <omnId> no more @. id @ @run :)
16:36:40 <oerjan> SideFFect: certainly
16:36:48 <SideFFect> cool
16:36:49 <SideFFect> :D
16:37:17 <hpaste>  Karle annotated "Please help" with "Please help" at http://hpaste.org/3655#a4
16:38:04 <oerjan> Karle: er, if you change the type of a function you also need to change the definition.
16:39:54 <oerjan> i have this hunch that maybe what update really should do is to look at _all_ the Pkg's in the list it is given, and incorporate them into the table with an actual _search_ for if there is already a corresponding item there.
16:39:55 <omnId> @let upperWords s = unwords . filter (all isUpper) . words $ s
16:39:59 <Karle> oerjan, yes....
16:40:04 <lambdabot> Defined.
16:40:09 <oerjan> in which case the code as given is rather too simple
16:40:37 <omnId> @let wordsWise f = unwords . f . words
16:40:46 <Karle> oerjan, it is what i am trying to implement
16:40:48 <lambdabot> Defined.
16:40:53 <omnId> @@ @run wordsWise sortNoCase' @show @yow
16:40:55 <lambdabot>  "be feels is it like potato salad So this to what"
16:41:02 <faxathisia> oh my :D
16:41:18 <oerjan> also, it seems to me not every Pkg actually contains a Port at all
16:41:47 <Karle> oerjan not all Pkg
16:42:38 <Karle> oerjan, you can see it all
16:42:41 <Botje> ooh
16:42:47 <oerjan> you might want an update function that only handles a _single_ Pkg, and use it to build another that works on a list
16:43:38 <Karle> yes
16:43:50 <oerjan> update1 :: Table -> Pkg -> Table, essentially.  it should also take care of the case when there is no Port.
16:44:43 <oerjan> once you have that you can use a foldl' to handle [Pkg], for example.
16:45:45 <oerjan> update2 :: Table -> (Pkg,Pkg) -> Table also seems like something you need
16:46:26 <oerjan> foldl' used _twice_ on that should give you [[(Pkg,Pkg)]] which you were just working on
16:48:45 <oerjan> (by give you, i mean give you an update version which uses that type and which you can use in update_pr)
16:49:46 <Karle> oerjan, I see... but I am not quite understand about foldl
16:50:09 <oerjan> > foldl' (+) 0 [1,5,7]
16:50:10 <lambdabot>  13
16:50:29 <SideFFect> I like this bot...good way to test code :P
16:50:30 <Karle> thanks
16:50:34 <oerjan> foldl' is a general function for accumulating updates from left to right in a list
16:50:46 <Cale> Who is running lambdabot?
16:50:52 <oerjan> (foldr does so from right to left instead)
16:50:57 <oerjan> dons i think
16:51:00 <Cale> Is hs-plugins working with 6.8.1 yet?
16:51:16 <Cale> Oh, yes it seems he still is :)
16:51:17 <oerjan> not last i heard but that was yesterday
16:51:17 <olsner> > (foldr (-) 0 &&& foldl (-) 0) [1,5,7]
16:51:19 <lambdabot>  (3,-13)
16:51:39 <Cale> Yeah, I tried it yesterday. Don would be the guy to know how to fix it though :)
16:52:11 <omnId> > foldl' (\x y -> concat ["(", x, ") + ", y]) "0" ["1", "5", "7"]
16:52:12 <lambdabot>  "(((0) + 1) + 5) + 7"
16:52:37 <Olathe> > foldr (\x y -> concat ["(", x, ") + ", y]) "0" ["1", "5", "7"]
16:52:38 <lambdabot>  "(1) + (5) + (7) + 0"
16:52:39 <salierix> Why does the State monad have both a state and a value instead of just a state?
16:52:51 <oerjan> salierix: every monad has a value
16:52:56 <sjanssen> salierix: all monads have a value
16:52:56 <faxathisia> > fix (\x -> concat ["1+1/(", x, ")"])
16:52:58 <lambdabot>  "1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(...
16:52:59 <oerjan> it's part of the definition
16:53:25 <omnId> > foldl' (\x y -> "f ("++x++") ("++y++")") "0" ["1", "5", "7"]
16:53:27 <lambdabot>  "f (f (f (0) (1)) (5)) (7)"
16:53:29 <omnId> > foldr (\x y -> "f ("++x++") ("++y++")") "0" ["1", "5", "7"]
16:53:30 <lambdabot>  "f (1) (f (5) (f (7) (0)))"
16:53:32 <Olathe> > repeat "1+1/("
16:53:34 <lambdabot>  ["1+1/(","1+1/(","1+1/(","1+1/(","1+1/(","1+1/(","1+1/(","1+1/(","1+1/(","1+...
16:53:38 <Olathe> Lies.
16:53:49 <salierix> I mean, why State Int Int instead of just State Int?
16:53:52 <faxathisia> Olathe: mismatched paranthesis at infinity :D
16:53:56 <Karle> oerjan, can you write those ideas on Hpaste? :)
16:54:02 <Olathe> faxathisia: Prove it :)
16:54:05 <faxathisia> haha
16:54:21 <Cale> salierix: For each type s, the (partially applied) type constructor (State s) is a monad.
16:54:25 <omnId> Olathe: cycle maybe?
16:54:32 <Olathe> > cycle "1+1/("
16:54:33 <lambdabot>  "1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(...
16:54:35 <Olathe> Yes :)
16:54:48 <omnId> = concat . repeat
16:54:52 <monochrom> "Maybe is a monad."  That means actions are of type Maybe Int, Maybe Bool, Maybe X, Maybe Y, ...
16:54:55 <Cale> salierix: The parameter to that type constructor is the result type of the state computation. The type s is the type of state that it manipulates while working.
16:55:22 <monochrom> "Either String is a monad." That means actions are of type Either String Int, Either String Bool, Either String X, Either String Y, ...
16:55:51 <monochrom> "State Int is a monad." That means actions are of type State Int Int, State Int Bool, State Int X, State Int Y, ...
16:55:55 <omnId> "IO is a monad" That means acitons are of type IO Int, IO Bool, IO X, IO Y, ...
16:56:44 <Olathe> Maybe State Maybe State ()
16:57:02 <monochrom> If "State Int" is your monad, "return True" has type State Int Bool.
16:57:09 <omnId> @unmtl Maybe (State a (Maybe (State b c)))
16:57:09 <lambdabot> Maybe (State a (Maybe (State b c)))
16:57:14 <mauke_> "(e ->) is a monad"
16:57:21 <olsner> @help unmtl
16:57:21 <lambdabot> unroll mtl monads
16:57:25 <olsner> @help mtl
16:57:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:57:38 <omnId> @unmtl State s a
16:57:38 <lambdabot> s -> (a, s)
16:57:39 <Olathe> > "(e ->) is a monad" >>= (\x -> 'A')
16:57:40 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Char'
16:57:43 <Olathe> :(
16:57:46 <monochrom> It probably only unrolls the topmost.
16:57:46 <hpaste>  oerjan annotated "Please help" with "building update functions gradually" at http://hpaste.org/3655#a5
16:57:54 <omnId> Olathe: "A"
16:58:01 <Olathe> > "(e ->) is a monad" >>= (\x -> "A")
16:58:01 <SideFFect> hm idea needed
16:58:02 <lambdabot>  "AAAAAAAAAAAAAAAAA"
16:58:06 <Olathe> AAhh !@
16:58:13 <Olathe> Yes, merged lists.
16:58:25 <oerjan> eek
16:58:25 <SideFFect> if I compare my x to two lists... should I start by comparing it to the second list?
16:58:36 <SideFFect> like x > head bs
16:58:39 <SideFFect> or?
16:58:55 <hpaste>  oerjan annotated "Please help" with "Correction" at http://hpaste.org/3655#a6
16:58:56 <omnId> SideFFect: in your case with the binary seach, probably yes.
16:58:58 <SideFFect> then if its not greater equal to head of second list, then it must be in first list
16:59:03 <Cale> SideFFect: what do you mean comparing to two lists?
16:59:03 <SideFFect> cool ill do that
16:59:18 <mauke_> @kind ContT
16:59:19 <lambdabot> * -> (* -> *) -> * -> *
16:59:20 <SideFFect> cale:binary search
16:59:22 <omnId> Cale: binary search, and yes lists are required in the problem statement.
16:59:29 <Cale> ah
16:59:43 <Karle> oerjan, thanks!
16:59:45 <omnId> @unmtl ContT a m b
16:59:45 <lambdabot> (b -> m a) -> m a
16:59:51 <mauke_> @unmtl ContT k (StateT s IO) a
16:59:51 <lambdabot> (a -> s -> IO (k, s)) -> s -> IO (k, s)
17:00:03 <Olathe> @help unmtl
17:00:04 <lambdabot> unroll mtl monads
17:00:11 <Notrix> http://www.pizdaus.com/pics/lhVRq4A6JW4Y.jpg
17:00:14 <Cale> Be careful about the empty list case
17:00:37 <mauke_> Notrix: where did you get that url?
17:00:46 <salierix> What's a good resource for learning monad transformers?
17:00:56 <Notrix> mauke_, on a perl channel :)
17:01:02 <SideFFect> yep, its taken care of already the empty list :D
17:01:08 <mauke_> magnet #perl?
17:01:23 <Notrix> #perlfr
17:01:40 <monochrom> I have no girl magnet. I'm a perl magnet.
17:01:48 <Cale> SideFFect: yeah, 'head' is kind of a dangerous function, it's usually a good idea to use pattern matching instead to make sure that you always have all cases handled
17:01:51 <SideFFect> girls like perls
17:01:55 <Notrix> i found it funny so i wanted other people to see it :)
17:02:07 <mwc> salierix: monad transformers are best understood as one monad enveloping another
17:02:10 <mauke> Notrix: who pasted it?
17:02:13 <Notrix> lol
17:02:16 <SideFFect> well, Ill see how this works, and if not, then ill use pattern matching if I can :P
17:02:19 <mwc> so say, you put State around IO
17:02:22 <Notrix> mauke, why is it so important ?
17:02:23 <Cale> salierix: "All about monads" has a section on them, though the examples leave something to be desired.
17:02:26 <mwc> and you can run the other monad, and be left with the inner
17:02:45 <mauke> Notrix: because I saw it in a different perl channel, and now I want to know how urls flow on irc :-)
17:02:52 <Cale> salierix: Once you actually understand how monad transformers work, I have a little tutorial on the "right way" to use them.
17:03:10 <monochrom> The haskell wikibook at http://en.wikibooks.org/wiki/Haskell has monad transformers. Bird's functional programming book has monad transformers.
17:03:16 <Notrix> mauke, Maddingue on #perlfr
17:03:42 <Cale> How's the wikibook on monad transformers? I don't think I've read that part. Last I checked the monad section was still quite weak.
17:03:46 <mauke> ah hah. Maddingue is also in magnet #perl.
17:04:09 <monochrom> I think it's ok.
17:04:38 <Notrix> mauke, yeah he's a perl lover as well :)
17:05:45 <SideFFect> how do I use cases instead of if's?
17:05:55 <Cale> case x of
17:06:00 <SideFFect> ah thanks
17:06:02 <SideFFect> :D
17:06:04 <Cale>   pattern -> ...
17:06:08 <faxathisia> if x then y else z, case x of True -> y ; not otherwise -> z
17:06:15 <faxathisia> er
17:06:23 <faxathisia> I think I meant False
17:06:25 <omnId> False -> 2
17:06:43 <Cale> yeah, not otherwise isn't a valid pattern, though it is equal to False
17:06:44 <omnId> not otherwise would be False, but not in a pattern :)
17:06:54 * omnId pokes Cale 
17:06:55 <kowey> Cale: I'm still quite embarrassed about the monad transformers chapter (I mixed in some All about monads with my own notes)
17:07:51 <omnId> @@ @run wordsWise (map toUpper) @show @brain
17:07:59 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
17:08:03 <omnId> :(
17:08:13 <omnId> @@ @run map toUpper @show @brain
17:08:15 <lambdabot>  "WELL, I THINK SO, BRAIN, BUT I CAN'T MEMORIZE A WHOLE OPERA IN YIDDISH."
17:08:16 <kowey> also, I think apfelmus would really appreciate your comments on the completely-rewritten monads chapter
17:08:22 <dmwit> wordsWise f = unwords . f . words?
17:08:25 <omnId> yes
17:08:33 <dmwit> ?pl \f -> unwords . f . words
17:08:33 <lambdabot> (unwords .) . (. words)
17:08:45 <dmwit> That's pretty.
17:08:57 <dmwit> ...well, that's prettier than I was expecting.
17:09:14 <omnId> > ((unwords.).(.words)) sort "quick brown fox jumps lazy dog"
17:09:15 <lambdabot>  "brown dog fox jumps lazy quick"
17:09:29 <ivanm> that almost makes sense...
17:09:44 <dmwit> > ((unwords.).(.words)) reverse "this was a programming puzzle for an interview"
17:09:46 <lambdabot>  "interview an for puzzle programming a was this"
17:09:54 <dmwit> Actually, not quite that.
17:10:17 <dmwit> > ((unwords.).(.words)) (map reverse) "this was a programming puzzle for an interview"
17:10:19 <lambdabot>  "siht saw a gnimmargorp elzzup rof na weivretni"
17:10:42 <omnId> gnimmargorp is a great nick!
17:10:50 <ivanm> heh
17:11:01 <idnar> it sounds like something from an H P Lovecraft novel
17:11:48 <omnId> @@ @run wordsWise (map reverse) @show @keal
17:11:50 <lambdabot>  "eht ]asn[ neve ekam thgil neerg htob syaw ecno"
17:12:25 <omnId> @remember laek eht ]asn[ neve ekam thgil neerg htob syaw ecno
17:12:26 <lambdabot> It is stored.
17:12:52 <Olathe> O-o
17:13:29 <glguy> ah, good, quote list pollution
17:13:37 <omnId> :)
17:13:52 <omnId> if you hate it go ahead and @forget it :)
17:14:05 <oerjan> @@ @read @elite @run wordsWise (map reverse) @show @keal
17:14:06 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
17:14:30 <oerjan> bah
17:14:30 <olsner> the [nsa] even make light green both ways once?
17:14:31 <omnId> @forget laek eht ]asn[ neve ekam thgil neerg htob syaw ecno
17:14:31 <lambdabot> Done.
17:14:33 <oerjan> oh, right
17:14:43 <Olathe> @. elite @@ @run wordsWise (map reverse) @show @keal
17:14:43 <lambdabot> Plugin `compose' failed with: Unknown command: "@@"
17:14:47 <Olathe> :(
17:14:50 <omnId> olsner: only slightly less nonsensical
17:14:52 <oerjan> @@ @elite @read @run wordsWise (map reverse) @show @keal
17:14:53 <lambdabot>  i D3en |-|tAm y1Dn3irph rE|iP/\/\Oc 0t e|IpMoC R0f M\/J R0 |-|Sa|ph
17:14:58 <Olathe> @. elite . @@ @run wordsWise (map reverse) @show @keal
17:14:58 <lambdabot> Plugin `compose' failed with: Unknown command: "@@"
17:15:21 <idnar> y1Dn3irph?
17:15:33 <Karle> what is going on?
17:15:34 <omnId> friendly
17:15:38 <omnId> idnar: ^
17:15:45 <idnar> oh right, I see
17:15:58 <idnar> elite happens after the reverse
17:16:08 <SideFFect> parse error
17:16:12 <Olathe> @. and @@ suck
17:16:12 <lambdabot> Plugin `compose' failed with: Unknown command: "and"
17:16:14 <olsner> i need math phriendly compiler to compile for jvm or phlash
17:16:19 <SideFFect> case x of
17:16:19 <SideFFect> 	x == head (bs) -> 45
17:16:26 <SideFFect> just to try and print 45
17:16:28 <olsner> this was funny ;-)
17:16:53 <monochrom> You can't have arbitrary expressions in the pattern part.
17:16:54 <SideFFect> if it matches that is
17:17:03 <olsner> @help @
17:17:03 <lambdabot>  @ [args].
17:17:03 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
17:17:03 <lambdabot>  The commands are right associative.
17:17:03 <lambdabot>  For example:    @ @pl @undo code
17:17:03 <lambdabot>  is the same as: @ (@pl (@undo code))
17:17:07 <Cale> case xs of
17:17:11 <Cale>   [] -> ...
17:17:15 <SideFFect> how do I output something then?
17:17:23 <salierix> newtype State s a = State { runState :: s -> (a, s) }
17:17:23 <Cale>   (y:ys) -> ...
17:17:30 <SideFFect> like if x matches the head of bs then output True lets say
17:17:35 <salierix> Any reason why that's (a,s) instead of (s,a)?
17:17:44 <idnar> @help .
17:17:44 <lambdabot> . <cmd1> <cmd2> [args].
17:17:44 <lambdabot> . [or compose] is the composition of two plugins
17:17:44 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
17:17:46 <Cale> x == head bs
17:17:47 <omnId> salierix: hysterical raisons
17:17:47 <oerjan> SideFFect: you can use   _ | x == head (bs) -> 45
17:18:10 <SideFFect> isnt the _ meaning matches anything?
17:18:10 <olsner> hysterical?
17:18:17 <Cale> salierix: yeah, (s,a) would be more elegant (for a rather subtle reason), but that's how it is in the library
17:18:20 <olsner> oh, historical reasons
17:18:25 <omnId> :)
17:18:34 <Cale> SideFFect: _ is a pattern which matches anything
17:18:55 <olsner> you've been drinking too much of that cactus juice, omnId
17:19:09 <Cale> SideFFect: if you just want an expression which is True when x is the head of bs, then x == head bs will do. However, this will die when bs is empty.
17:19:14 <omnId> olsner: just imitating dons.  It's a favorite of his :)
17:19:40 <Cale> (not (null bs) && x == head bs) is safer of course
17:19:54 <salierix> What's the difference between Reader and State?
17:20:00 <Cale> f x [] = False
17:20:03 <omnId> @unmtl Reader r a
17:20:04 <lambdabot> r -> a
17:20:06 <oerjan> SideFFect: _ matches anything then the | ... part gives an extra condition which is a boolean expression
17:20:07 <Cale> f x (b:bs) = x == b
17:20:08 <omnId> @unmtl State s a
17:20:08 <lambdabot> s -> (a, s)
17:20:24 <omnId> Reader doesn't result in an updated state.
17:20:28 <Cale> salierix: Reader is like only the input half of State
17:20:42 <SideFFect> whoa...if not equal I get Error! non exhaustive something in case
17:20:44 <QtPlatypus>   
17:20:52 <omnId> QtPlatypus:
17:21:00 <nornagon> how does randomRIO :: (Int, Int) -> IO Int work?
17:21:01 <monochrom> Yes, you have to say what to do if not equal, too.
17:21:16 <SideFFect> ah true
17:21:29 <nornagon> how do you get a balanced distribution of random numbers in a given range from a stream of random bits?
17:21:34 <monochrom> IMO the imperative language's "if x then y" construct, without the else part, is very brain-damaging.
17:21:52 <omnId> if x then y [else do-nothing]
17:22:35 <monochrom> Aha, but if the "then" part is a boolean, the "else" part needs to be a boolean too.
17:22:39 <Korollary> monochrom: it's braindamaging with the else branch as well as long as it's a statement.
17:23:04 <olsner> I think I accidentily made something that was almost runMaybeT just before without realizing I could've learned and used monad transformers
17:23:07 <oerjan> nornagon: one simple way is to first get a distribution in a range whose length is a power of 2
17:23:22 <SideFFect> now im confused
17:23:30 <oerjan> then you redo that until you get something which is in your smaller range
17:23:35 <SideFFect> case x of _ | x == head (bs) -> 45
17:23:39 <nornagon> oerjan: ew :/
17:23:41 <SideFFect> does that compare x to anything?
17:23:42 <SideFFect> or?
17:23:49 <Cale> yes, it compares it to head bs
17:24:03 <Cale> But if the guard fails, what should be returned?
17:24:04 <SideFFect> so how do I write if its not equal?
17:24:04 <monochrom> Korollary: Fortunately, that one is easier to fix, by saying "statements are predicates", so the "then" branch has a predicate, and the "else" branch has a predicate, and "do nothing" is also translated to a predicate too.
17:24:05 <nornagon> @src randomR
17:24:05 <lambdabot> Source not found. It can only be attributed to human error.
17:24:14 <Cale> | otherwise -> ...
17:24:19 <SideFFect> ohh
17:24:23 <Cale> (line up the pipe symbols)
17:24:33 <SideFFect> man my brain is gone...simple solution thanks
17:24:34 <Cale> Or you could just write:
17:24:45 <Cale> case bs of
17:24:48 <Cale>   [] -> ...
17:24:57 <Cale>   (b:bs) | x == b -> ...
17:25:05 <Cale>          | otherwise -> ...
17:25:15 <oerjan> @src Random
17:25:16 <lambdabot> class Random a where
17:25:16 <lambdabot>   random    :: RandomGen g => g -> (a, g)
17:25:16 <lambdabot>   randoms   :: RandomGen g => g -> [a]
17:25:16 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
17:25:16 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
17:25:18 <lambdabot>   randomRIO :: (a,a) -> IO a
17:25:20 <lambdabot>   randomIO  :: IO a
17:25:34 <oerjan> nornagon: randomR is different for each type
17:26:04 <nornagon> right
17:26:11 <SideFFect> oops infinite loop lol
17:26:19 <oerjan> Cale: you don't actually need to line up |'s
17:26:35 <Cale> oerjan: I know that.
17:26:42 <oerjan> although it's of course prettier if it is on several lines
17:27:00 <Cale> You're also less likely to produce something which is actually incorrectly laid out.
17:27:17 <olsner> wow, StateT s [] is a cool monad
17:27:25 <Cale> olsner: yes it is :)
17:27:40 <oerjan> olsner: yeah
17:28:18 <nornagon> oerjan: i would do this with floating-point random numbers, but the platform i'm coding for has no fp acceleration :)
17:28:24 <olsner> can't wait to find a nail to use my new-found monad transformer hammer on!
17:28:27 <SideFFect> isnt there a way to write if x == head (bs) then True else if x > head (bs) then find x bs else
17:28:32 <SideFFect> too many nested if's no?
17:29:07 <Cale> yeah, multiple guards work well for that
17:29:08 <olsner> you could add more _ | condition -> value clauses to a case expression
17:29:15 <Cale> look at the code I wrote for you above
17:29:35 <Cale> case bs of
17:29:35 <Cale>   [] -> ...
17:29:35 <Cale>   (b:bs) | x == b -> ...
17:29:35 <Cale>          | otherwise -> ...
17:29:48 <Cale> Just add a case to the guards there where x > b
17:30:16 <SideFFect> empty list returns error ok and b:bs takes the head of bs and comapres it to x
17:30:16 <bos> is there a handy Functor instance for (->) e around anywhere?
17:30:28 <SideFFect> and then otherwise would recursivley call find x bs right?
17:30:49 <Cale> Perhaps. What is it that you're really trying to do?
17:30:50 <Karle> oerjan, not very easy
17:30:56 <oerjan> > fmap (+) (+1) 1
17:31:01 <Cale> Is this an implementation of find?
17:31:04 <lambdabot>  <Integer -> Integer>
17:31:25 <oerjan> > fmap (+1) (+1) 1
17:31:27 <lambdabot>  3
17:31:36 <Cale> Can you give an overview description of the behaviour you want?
17:31:41 <SideFFect> trying to implement a binary search
17:31:43 <oerjan> bos: look in Control.Monad.Instances
17:31:53 <bos> oerjan: thanks
17:31:57 <SideFFect> take a list, divide it in two, see where the x should be, search that list, divide in 2
17:31:58 <SideFFect> etc
17:32:12 <Cale> okay, and the list is guaranteed ordered?
17:32:15 <SideFFect> yep
17:32:17 <Cale> okay
17:32:32 <Cale> I take it you already have a function to split the list in two?
17:32:37 <SideFFect> yep!
17:32:41 <Cale> all right
17:33:31 <Cale> Are you just supposed to return whether or not x is in the list?
17:34:35 <Cale> that is,  find x bs  is True if x is in bs and False otherwise?
17:35:00 <SideFFect> well he wants us to say what position its in as well
17:35:03 <SideFFect> but one thing at a time
17:35:03 <oerjan> @quote learning.curve
17:35:03 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:35:07 <Cale> okay
17:35:25 <Cale> So,
17:35:47 <Cale> find x [] = False
17:35:53 <oerjan> @quote curve
17:35:53 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
17:36:06 <SideFFect> yeah
17:36:48 <Cale> Does your splitting function guarantee there's an element in the right hand part, if there's an element in the list?
17:37:22 <Cale> That is, can we do  (ls, r:rs) = split bs
17:37:23 <Cale> ?
17:37:39 <Cale> (under the assumption that bs isn't empty)
17:38:12 <SideFFect> what do you mean? it takes in a list and divides it into 2
17:38:19 <Cale> yes
17:38:19 <SideFFect> 1,2,3,4,5 becomes 1,2  3,4,5
17:38:25 <Cale> okay
17:38:31 <Cale> what does [5] become?
17:38:47 <SideFFect> never tried lol
17:38:51 <Cale> try it :)
17:38:54 <SideFFect> but I dont think he'll test for that
17:38:56 <SideFFect> one sec doorbell
17:39:01 <Cale> No, it's important :)
17:39:08 <Cale> We will test for that
17:39:15 <Cale> because it'll come up in a recursive call
17:40:00 <Cale> ideally, it'd be  ([],[5])
17:40:35 <Cale> but it might be ([5],[]), which would be more frustrating for us
17:41:50 <SideFFect> testing
17:42:09 <SideFFect> [], [5]
17:42:45 <SideFFect> brb gf at door
17:43:32 <Olathe> Code at computer > girlfriend at door
17:44:46 <Olathe> Unfortunately, Haskell's philosophy differs.
17:44:48 <Olathe> > sort ["Code at computer", "girlfriend at door"]
17:44:49 <lambdabot>  ["Code at computer","girlfriend at door"]
17:45:03 <faxathisia> lol
17:46:03 <faxathisia> I think I'll write a parser tommorow for this language
17:46:21 <faxathisia> It's like haskell indentation sensitive..
17:46:30 <SideFFect> lol
17:46:34 <SideFFect> ok back shes eating :p
17:46:36 <faxathisia> I thought I probably use parsec?
17:46:45 <faxathisia> sounds good?
17:47:14 <faxathisia> im not sure how to parse indentation ;s
17:47:50 <SideFFect> you there cale?
17:47:52 <Cale> yep
17:48:02 <SideFFect> alrighty, back to testing :P
17:48:04 <Cale> okay
17:48:37 <SideFFect> where were we?
17:48:43 <Cale> So, this means that (with all likelihood) we can assume that if the input list is nonempty, the second component returned by split is nonempty
17:48:56 <SideFFect> yep
17:49:01 <Cale> Which means that (ls, r:rs) = split bs
17:49:02 <olsner> > sort ["code at computer", "Girlfriend at door"]
17:49:04 <lambdabot>  ["Girlfriend at door","code at computer"]
17:49:07 <Cale> is a safe pattern match
17:49:19 <SideFFect> yeah
17:49:21 <Cale> (so long as we know that bs isn't empty)
17:49:27 <Cale> So:
17:49:33 <Cale> find x bs = ...
17:49:41 <Cale>   where (ls, r:rs) = split bs
17:49:47 <olsner> Olathe: see, now haskell's got the priorities right ;-)
17:49:52 <SideFFect> heh
17:50:05 <Olathe> Heheh
17:50:17 <monochrom> Hahaha
17:51:22 <SideFFect> my code reads as find x ys = let (as,bs) = splitIn2 ys in...
17:52:04 <Cale> Yeah, but we know bs is nonempty, so long as we separately handle the empty case for find
17:52:23 <Cale> also, the where clause will turn out to be more convenient, since where scopes over guards
17:52:47 <Cale> Which means we can add a few guards to find here without having a needless case expression
17:53:46 <SideFFect> hows that accomplished then?
17:54:08 <Cale> find x bs | x < r = ...
17:54:16 <Cale>           | x == r = ...
17:54:22 <Cale>           | x > r = ...
17:54:31 <Cale>   where (ls, r:rs) = split bs
17:56:09 <Cale> (If my girlfriend were at the door, she wouldn't be sixteen thousand kilometres away.)
17:56:17 <soduko> > :t split
17:56:24 <lambdabot>   parse error on input `:'
17:56:26 <SideFFect> wow I think that works!
17:56:26 <Cale> split is a function in his code
17:56:27 <SideFFect> one sec
17:56:41 <soduko> oh
17:56:57 <Cale> It would have type [a] -> ([a],[a])
17:56:57 <monochrom> She is at the door and sixteen thousand km away. You just have to measure the right circle. :)
17:57:10 <Cale> Or the right door?
17:57:17 <monochrom> Err, nevermind.
17:57:43 <monochrom> I wanted to say that even your door is sixteen thousand km away by measuring the right circle.
17:58:27 <Cale> Maybe along some loxodromic spiral?
17:59:02 <lament> that's one hell of a restraining order
17:59:05 <monochrom> Say, if something is 1km to the east of you, then it's also a long long distance west of you.
17:59:52 <Cale> lament: haha
18:00:03 <Cale> lament: We must remain at antipodes at all times.
18:00:11 <SideFFect> now we test all cases...
18:00:14 <monochrom> hahaha
18:04:23 <SideFFect> ahh works, just had to add some stuff
18:04:46 <SideFFect> oh wait, gotta add last test case, for anything else its False
18:05:25 <SideFFect> damn not as easy as I thought
18:05:34 <SideFFect> cant I just add a last line
18:05:38 <SideFFect> | _ = False?
18:05:51 <SideFFect> meaning for anything else its false
18:06:05 <monochrom> goodie goodie, glad you are making progress. Just make sure you align things properly - the alignments are important.
18:06:07 <oerjan> | otherwise = False
18:06:17 <SideFFect> i actually type otherwise?
18:06:20 <jcreigh> SideFFect: right
18:06:20 <oerjan> yep
18:06:23 <SideFFect> oh heh
18:06:26 <SideFFect> thanks!
18:06:31 <monochrom> After | you need a boolean expression.
18:06:44 <monochrom> otherwise is defined to be True.
18:06:44 <jcreigh> note that there's nothing magic about "otherwise"...it's simply defined in Prelude as "otherwise = True"
18:07:16 <SideFFect> I get a irrefutable pattern failed when I type find 4 [1,2,3]
18:07:48 <oerjan> SideFFect: did you remember to make a find ... [] case?
18:07:56 <dino-> Huh, I think I made a silly assumpution that otherwise was some kind of keyword.
18:08:12 <faxathisia> dino-: I made the assumption to o
18:08:20 <SideFFect> ohh no find [] case
18:08:22 <monochrom> > let otherwise = "False" in otherwise ++ " Prophet"
18:08:31 <lambdabot>  "False Prophet"
18:08:36 <oerjan> dino-: it's easy in haskell where so many things that are keywords in other languages can be defined
18:08:49 <dino-> Very exciting that there's not much language in Haskell at all. Much of what we use is written in it, code like anything else we may write.
18:09:08 <monochrom> Only Scheme is more amenable than Haskell.
18:09:22 <monochrom> (Err, should also include Lisp there.)
18:09:25 <faxathisia> monochrom: and Prolog and TCL
18:09:42 <faxathisia> monochrom: and a billion other languages I haven't heard of :p
18:09:45 <monochrom> Hehe, ok ok...
18:09:59 <SideFFect> nice works :D
18:10:05 <SideFFect> thanks guys :D
18:10:23 <SideFFect> now I gotta change it to list the position, but after 7 hrs of this, m brain beends rest
18:10:27 <SideFFect> needs*
18:11:33 <Karle> need help again
18:11:36 <Karle> :)
18:14:08 <oerjan> aye?
18:14:36 <hpaste>  Karle pasted "help please" at http://hpaste.org/3658
18:15:16 <Karle> oerjan, i could not implement the code :(
18:16:38 <oerjan> um, that update has the type i suggested for updateLL2
18:17:10 <oerjan> update2_table is none of those i suggested
18:17:35 <Karle> I was from yesterday...
18:17:41 <Karle> It was
18:18:01 <Karle> you suggested
18:19:25 <oerjan> well it was suggested to fit the type update _originally_ had, which today we found did not fit into update_pr
18:19:46 <oerjan> the thing that fits into update_pr is the updateLL2 i suggested
18:20:41 <Karle> updateLL2 :: Table -> [[(Pkg,Pkg)]] -> Table
18:20:42 <Karle> updateLL2 = foldl' updateL2
18:21:50 <desp> any ideas what darcs has been doing for the past 15 minutes of CPU time?
18:22:01 <oerjan> there are just so many types with lists and/or pairs of Pkg's flying around, it's easy to get confused
18:22:15 <desp> how long should it take to pull 248 patches?
18:22:48 <Karle> oerjan, it is .. yes
18:22:51 <dons> desp: xmonad?
18:23:19 <desp> dons: updating my version of gentoo-haskell after a month of being busy
18:24:38 <hpaste>  oerjan annotated "help please" with "perhaps this?" at http://hpaste.org/3658#a1
18:24:52 <oerjan> adding another one that fits the _old_ type of update
18:25:11 <oerjan> and may be closer to what it actually should do
18:26:20 <Karle> what did you mention about update1 and update2?
18:26:43 <oerjan> update1 would be the basic building block, which updates a table with a _single_ Pkg
18:26:44 <Karle> thanks for your help...
18:27:22 <oerjan> from this all the others with lists and pairs are just a matter of chaining things together
18:27:59 <faxathisia> I'm really stuck :S
18:28:14 <faxathisia> except it's understanding these semantic diagrams not really haskell
18:28:35 <Karle> that is very confusing most of the time
18:28:51 <oerjan> lists would use foldl' and pairs could use something resembling the code for update2_table, excepting taking (s1,s2) as a single argument instead of separately
18:29:10 <faxathisia> someone should write a book like TaPL which use haskell :D
18:29:13 <desp> ok, I give up. I'm going to pull these patches one by one
18:29:14 <oerjan> assuming you really are supposed to update with both Pkg's in a pair
18:29:42 <Karle> yes
18:31:10 <oerjan> btw update (update t s1) s2 can be written as foldl' update t [s1,s2]
18:31:49 <oerjan> so it's sort of all foldl'
18:32:02 <Karle> i see
18:32:29 <Karle> update1 :: Table -> Pkg -> Table
18:32:29 <Karle> update1 t (x,y,z)
18:32:29 <Karle>              |(x == U) = t
18:32:29 <Karle>              |otherwise = []
18:32:45 <Karle> my update1 looks like this ... what do you think?
18:33:01 <oerjan> that's a start.  but i really thing that [] should be a search and replace in t
18:33:14 <oerjan> *think
18:34:13 <oerjan> actually, isn't it z that contains the port if any?
18:34:40 <Karle> yes
18:34:46 <ivanm> does anyone know where I can grab a copy of symalg?
18:35:00 <ivanm> the link at http://www.rbjones.com/rbjpub/cs/cs011.htm doesn't work :s
18:35:02 <oerjan> i think this all requires carefully thinking about what is supposed to be the result when you update a table with a package.  the types are not enough to determine that.
18:35:03 <lambdabot> Title: Implementation of Computation with Reals
18:35:09 <Karle> (ID,Port)
18:36:06 <oerjan> not what type it should have, but exactly what should be replaced, and what should happen in the cases when there is no Port given
18:36:30 <Olathe> Reals are mostly imaginary, unfortunately.
18:36:43 <soduko> i am learning music[ guitar] , and naturally looked for how i could generate music with haskell and found haskore,
18:36:56 <soduko> but unfortunately there is no active community around it :(
18:37:35 <soduko> there is somethign for java:  jmusic , but i really dont like java since since i started learning haskell!
18:37:49 <oerjan> for example if you have a table that already contains something, and you add a package with a _different_ Id, then you probably shouldn't throw away the original items in the table
18:37:52 <soduko> tough conundrum
18:38:45 <newsham> soduko: i have a fretboard program in C (you could port it ot haskell if you wanted)
18:38:50 <oerjan> but all this requires knowing the actual problem specification, which cannot all be given in the types
18:39:02 <soduko> newsham: i would love to give that a try
18:39:06 <Karle> yes I understand
18:39:07 <Olathe> Are any music file formats easy to write ?
18:39:08 <newsham> http://www.thenewsh.com/%7Enewsham/progs/fretboard.c and http://www.thenewsh.com/%7Enewsham/progs/chords.txt
18:39:20 <Karle> it is not so well-defined problem ....
18:39:34 <Karle> basically I can define it myself
18:39:43 <Pseudonym> Is the problem of guitar fingering an "interesting" problem, mathematically speaking?
18:40:09 <soduko> Olathe:  easiest is WAV its just PCM
18:40:23 <soduko> but its for sound, not music
18:40:56 <newsham> pseudo: no, its very straight forward.
18:41:10 <newsham> if you want interesting + music, signal processing is very neat.
18:41:37 <Pseudonym> I'm more interested in something symbolic.
18:41:44 <Pseudonym> Like Bach-style harmonisation.
18:42:06 <lament> newsham: oh wow, your program creates chords?
18:42:27 <lament> i mean chord fingerings for guitar?
18:42:32 <oerjan> Karle: hm... am i right that if the PkgType is RTD or U then Payload must be RTDP and UP respectively?
18:42:33 <newsham> pseudo: there's some semi-interesting things about how the scales work.. scales are just an aproximation to what the real tones should be
18:42:41 <newsham> lament: yah, chord and scale fingerings
18:42:55 <soduko> Pseudonym: it is "interesting" kinesthetically.. i am able to play single notes, but chords are a nightmare!
18:42:58 <lament> newsham: nice, how do you choose between different voicings?
18:43:16 <oerjan> (which makes PkgType sort of redundant)
18:43:17 <newsham> lament: it enumerates all possible positions for the notes in the fret ranges you request
18:43:25 <newsham> its up to a human to pick out a particular fingering from those
18:43:28 <lament> newsham: ah, so it's pretty stupid
18:43:34 <lament> i have a program like that as well, in python :)
18:43:37 <newsham> yah, very basic, but useful
18:43:38 <Pseudonym> newsham: Sure.
18:43:50 <Karle> oerjan : the other way around
18:43:57 <lament> i was thinking about having a program actually come up with chords... then you need some sort of a "difficulty" function to sort a list of possible voicings with
18:44:00 <Pseudonym> Fretless instrumentalists have the advantage there.
18:44:04 <Pseudonym> You can actually play in tune./
18:44:04 <lament> the function would take a chord and return how difficult it is
18:44:07 <newsham> lament: its kind of nice in that you can spell out any chords or scales (it takes a key and a list of intervals)
18:44:08 <Karle> if pkgtype is U payload is UP
18:44:22 <Pseudonym> Your inferior bad-tempered scale offends me.
18:44:22 <newsham> ie "maj3 p5 aug9"
18:44:35 <lament> Pseudonym: the problem of guitar fingering is certainly interesting, imo
18:44:42 <Karle> if pkgtype RTD then payload is RTDP
18:44:44 <oerjan> that's what i said
18:44:55 <Pseudonym> It occurred to me that if you have a chord sequence, some renderings of the chords would be more efficient than others.
18:45:00 <lament> Pseudonym: right
18:45:06 <lament> Pseudonym: it's an optimization problem
18:45:12 <newsham> my keyboard does well-tempered (and other non-well-tempered scales)
18:45:17 <Pseudonym> That also works for pieces that aren't just chords, too.
18:45:17 <Karle> hehe ... sorry then I must be very tired
18:45:23 <newsham> i would love to get a fretless guitar for doing weird scales
18:45:28 <lament> Pseudonym: right
18:45:36 <lament> Pseudonym: the thing is, it's hard to figure out the thing to optimize
18:45:40 <newsham> err.. does pure intonation and other non-well-tempered
18:45:45 <Pseudonym> Right/
18:45:58 <oerjan> anyway in that case the part of update1 other than the [] looks fine to me
18:46:01 <soduko> lament: i would like to see that too, do you have a link?
18:46:10 <lament> for chords, you want to minimize their difficulty (level of stretch), and in general you want to minimize distance between notes and the number of position switching
18:46:21 <Karle> yes
18:46:28 <Pseudonym> And you want to rule out physically impossible fingerings.
18:46:28 <lament> soduko: my program?
18:46:29 <newsham> lament: you might like the chord primer that accompanies the fretboard program
18:46:37 <lament> Pseudonym: right, which is subjective
18:46:43 <lament> newsham: oh, i know a bunch of stuff about chords
18:47:01 <Pseudonym> Right.
18:47:11 <pmdboi> ./find-chords --stretch=yngwie
18:47:11 * Pseudonym thinks he'll stick to his cello
18:47:27 <newsham> pseudo: eh, I dunno.. honstly I think its silly to rule out fingerings.. if you're experienced at the guitar you'll see the patterns you want right away, and also you're often not playing all strings for chords, so you want to see your various possibilities that might not make sense for a complete voicing
18:47:42 * oerjan needs food
18:47:45 <newsham> also you might want to shift between several voicings
18:47:53 <lament> newsham: right, but, for example, consider a program that would come up with optimal fingerings for a classical guitar piece
18:48:10 <lament> newsham: that shit is very, very complex and optimal fingerings are often far from trivial to find, by a human
18:48:15 <newsham> most pieces written for the guitar already have annotations for preferred fingerings
18:48:26 <lament> oh, sure
18:48:32 <Pseudonym> That's assuming you're using someone else's piece.
18:48:44 <Pseudonym> I do music theory, and I might like to write something.
18:48:48 <Pseudonym> But I don't play guitar.
18:48:51 <newsham> if you wrote the piece yourself, you should know the finger ;-)
18:48:58 <lament> newsham: but perhaps it's not originally for guitar... lots of reasons why there woludn't be fingerings
18:49:04 <newsham> if you're writing a piece as a non-guitarist, I can see that being useful to some degree
18:49:07 <lament> newsham: if you wrote it in your head, you dont necessarily know the fingerings
18:49:18 <newsham> if you're arranging a non-guitar piece, perhaps more so
18:49:24 <lament> although guitar players tend to rely a lot on physical properties of the instrument
18:49:27 <Pseudonym> And don't say "just learn guitar".  Orchestrators handle whole symphony orchestras without knowing how to play all the instruments.
18:49:40 <lament> (playing "stuff that fits" instead of "stuff that sounds better")
18:49:54 <lament> it would be a really cool program to have, i seriously considered writing it
18:50:05 <lament> but 1) it seems like so much work 2) you would have to feed music notation to it
18:50:06 <newsham> pseudo: right, but you dont write music for an instrument without knowing at least some of the idiosynchracies of that instrument
18:50:10 <lament> 2) is the bigger problem :)
18:50:18 <lament> newsham: actually people do.
18:50:21 <lament> all the time
18:50:24 <Pseudonym> newsham: Actually, you'd be shocked.
18:50:31 <Pseudonym> I know people in the business.
18:50:33 <newsham> s/dont/shouldnt/
18:50:36 <Pseudonym> Who do orchestrations for shows, movies etc.
18:50:57 <Pseudonym> A friend of mine is starting up a business to do, essentially, music copying and sanity checking.
18:51:07 <lament> it's a pleasure to play stuff written by composers who were also guitarists (or just well-arranged stuff), it fits the instrument so well.
18:51:12 <Pseudonym> The sanity checking is the thing I'm curious about semi-automating.
18:51:16 <newsham> brauer ++
18:51:18 <lament> On the other hand, though, Bach is an important part of the classical guitar repertoire
18:51:25 <lament> and Bach never wrote for guitar
18:51:33 <Pseudonym> Bach never wrote for the piano, either.
18:51:41 <newsham> yah, bach lute pieces are the suck to play
18:51:42 <lament> so obviously all those pieces are composed _without_ consideration for the idiosyncracies of the instrument
18:51:46 <soduko> the other issue is with people like me, who are very new to western music and instruments, but have songs in their head.  hehe given the choice i would be a very good haskore performer.. much better than a guitar performer
18:52:03 * Cale listens to John Scofield and Wayne Krantz :)
18:52:03 <lament> which is why 1) they're quite difficult to play and 2) it would be nice to have a program to find optimal fingerings :)
18:52:05 <Pseudonym> Yeah, real orchestrators come out with some blunders sometimes.
18:52:23 <Pseudonym> Like an oboe player having to switch to the cor anglais very, very quickly.
18:52:34 <lament> Pseudonym: bach wrote for piano in the same sense that shakespeare wrote in English
18:52:43 <Pseudonym> lament: Interesting take on it.
18:52:47 <newsham> i dont know nothing about oboe
18:52:59 <soduko> optimization goals, 1. minimum number of fingers to move. 2. minimum over all movement. 3. minimum stretch. 4. minum number of non open notes
18:52:59 <lament> Pseudonym: it's the one most classical musicians I know implicitly share
18:53:07 <newsham> also stop playing bach, its 2007 ;-)
18:53:24 <Pseudonym> Yeah, we should all be playing modern classical music, like Britney!
18:53:35 <lament> i like her "Gimme Gimme" song
18:53:43 <Pseudonym> You're joking, right?
18:53:47 <lament> no
18:53:56 <Pseudonym> Or do you like it in the same way that you like looking at traffic accidents?
18:54:11 <lament> no, i like a lot of stuff
18:54:14 <newsham> leo brauer, modern, good, and guitar.  what more could you want?
18:54:20 <Pseudonym> I like a lot of stuff, too.
18:54:21 <pmdboi> soduko: if you limit the goals to adjacent chords then you could just pose it as shortest path on a DAG
18:54:30 <newsham> debussy is nice on guitar if you want something older
18:54:43 <lament> i'm mainly into playing brazilian music
18:54:43 <newsham> (simplified arrangements of course)
18:54:48 <newsham> cool!
18:54:49 <pmdboi> i mean, give a metric for the "distance" between two chord fingerings
18:54:55 <newsham> do you know carlos barbosa-lima?
18:54:55 <Cale> http://cale.yi.org/autoshare/06%20-%20Signals.mp3 -- something for guitarists :)
18:54:57 <Olathe> Music from solving common computer science problems.
18:55:02 <lament> pmdboi: it's harder to find the metric for stretch
18:55:03 <pmdboi> and then generate your graph
18:55:26 <lament> pmdboi: i think to find stretch, you need to have some sort of a simplified model of the hand
18:55:28 <newsham> http://www.carmapro.com/cbl/cblindex.htm
18:55:29 <pmdboi> lament: you can model it angularly :)
18:55:29 <lambdabot> Title: Official Carlos Barbosa-Lima Website
18:55:33 <lament> and once you have that, "distance" is found automatically
18:55:36 <Cale> (That's Wayne Krantz)
18:55:39 <lament> because you know where your hand is
18:55:48 <pmdboi> stretching my hand right now it looks like there's about 80 degrees max between index and little finger
18:55:49 <lament> pmdboi: i'm not sure that works
18:56:01 <lament> or rather that it's enough
18:56:11 <pmdboi> it's worth a shot
18:56:28 <pmdboi> you'd also want to consider fingers being too close
18:56:31 <newsham> take piece + hand model spit out an ideal tuning and fingering?
18:56:42 <pmdboi> like, three fingers on a fret is only easy if the fret is wide (i.e., high up on the fretboard)
18:56:47 <soduko> heres a thought, metric_for_stretch note = home_position `distance` note
18:56:50 <pmdboi> but you're not going to fit all three fingers on the 14th fret
18:56:56 <dmwit> Stretch test: type an 'a' with your index finger and the farthest key on the home-row you can touch without removing your index finger.
18:57:07 <Cale> al
18:57:11 <lament> soduko: that's not enough
18:57:14 * dmwit can get to ';'
18:57:30 <soduko> lament: i agree, but thats a start
18:57:37 <newsham> a/k or a/l
18:57:50 <Cale> I can do ; as well, but only if I'm just touching the corner of the a, not the middle.
18:57:50 <pmdboi> so really you're minimizing two different things: (1) the cost of each individual chord, and (2) the cost of moving between each pair of adjacent chords
18:58:00 <lament> i have "as"
18:58:07 <lament> pmdboi: correct
18:58:11 <newsham> pmdboi: also the use of open strings for prominant notes.
18:58:19 <soduko> pmdboi: not necessarily that strategy 2) could lead ot local minima
18:58:27 <lament> the cost of moving includes the distance in position but also things like "fingers that don't move at all" and "fingers which move together as a group to another location"
18:58:30 <newsham> also for certain styles of music you want to select the distance up the fretboard for tone
18:58:36 <newsham> (ie. rounder/mellower tons higher on the fretboard)
18:58:42 <pmdboi> newsham: then just put that into (1)
18:59:02 <pmdboi> lower-numbered frets = lower cost
18:59:11 <newsham> and certain fingers do vibrato better than others
18:59:25 <soduko> pmdboi: for me middle of the board is the most accessible => least cost
18:59:47 <pmdboi> right, your cost function is very tweakable
18:59:56 <newsham> also if there are fast alternations between two adjacent notes its best to avoid string changes
18:59:58 <lament> it all depends, some decisions are strictly for a human
19:00:00 <pmdboi> but once you have that you should get something interesting by just getting the path of least cost
19:00:08 <lament> ie whether to avoid open strings or not
19:00:22 <pmdboi> where least cost = sum of costs of all chords and costs of all adjacent chord pairs
19:00:24 <Cale> If anyone liked Signals, here's another from the same album http://cale.yi.org/autoshare/01%20-%20Alliance.mp3
19:00:27 <lament> and whether to avoid small intervals or not
19:00:28 <newsham> i'd say thewhole problem is best left to a human :)
19:00:29 <soduko> is the duration of a note a factor in the cost?
19:00:44 <pmdboi> soduko: i'd say so... if a note is short it's not as important for the chord to be correct
19:00:58 <pmdboi> so if you consider slightly incorrect chords, you could lower their cost on short notes
19:01:01 <pmdboi> depending on how many notes are off
19:01:05 <pmdboi> and how harmonic the off notes are
19:01:20 <pmdboi> it's an interesting problem :)
19:01:22 <lament> for example consider chords x5767x and x5463x... the first one is easier to play but sometimes you want the sound of the second one
19:01:35 <newsham> soduko: it can be.. for example, can you hold a sustained note while there is motion in other voices, can you provide good vibrato for the long note in the proper fingering?  do you prefer a long open ringing of an open string for the long note?
19:02:10 <lament> (and of course xx0333, which is perhaps the easiest)
19:02:35 <pmdboi> the "slightly incorrect" thing might actually help if you're really lazy
19:02:36 <dcoutts> @seen dons
19:02:36 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 1s ago.
19:02:37 <newsham> xx0 10 12 :)
19:02:43 <pmdboi> (lazy guitar-wise, not programmer-wise)
19:02:44 <lament> oh oh oh oh i have an idea
19:02:49 <ddarius> Cale: WHere is this coming from?
19:02:49 <dcoutts> dons: can I run something by you?
19:02:54 <dons> sure
19:02:54 <lament> have a neural net or something do it!
19:02:54 <soduko> barre chords change the default  nut position, and have different costs
19:02:57 <Cale> ddarius: this music?
19:03:01 <ddarius> Cale: yes.
19:03:06 <lament> it generates all possible voicings for a chord
19:03:14 <lament> and you pick the one you prefer
19:03:15 <Cale> ddarius: It's Wayne Krantz from the album "Signals"
19:03:17 <lament> and then it learns from you
19:03:22 <lament> benefit: it's personalized
19:03:26 <hpaste>  dcoutts pasted "package maintainers: updating your packages to work with ghc-6.8" at http://hpaste.org/3659
19:03:28 <dcoutts> dons: ^^
19:03:30 <lament> and will find the stuff that _you_ prefer
19:03:32 <dmwit> lament: Neural nets are so outdated... ;-)
19:03:36 <pmdboi> like, going between 320033 and x32033 is easier than 320033 and x32010, even though the former isn't strictly G C
19:03:53 <dcoutts> dons: I want to send that (or something like it) to the haskell list & haskell-cafe
19:04:03 <newsham> dcoutts: thats hard to read w/o line wraps
19:04:10 <dcoutts> newsham: oops
19:04:20 <newsham> (raw's slightly better)
19:04:27 <dcoutts> dons: I've already seen two packages updated on hackage in a way that will only work with ghc-6.8, not 6.6 :-(
19:04:43 <soduko> would a markov matrix of sufficiently deep order would be better than a neural net  for that purpose
19:04:45 <dcoutts> ie just adding a dep on new split base packages rather than using configurations
19:04:54 <pmdboi> lament: a student once approached his master and said "i have a problem that requires learning. i think i'll use a neural net to solve it"
19:04:58 <pmdboi> the master said "now you have two problems"
19:05:06 <dons> ok, that looks ok.
19:05:10 <lament> that's not an argument :)
19:05:22 <lament> neural nets are 1) great 2) in use for a bunch of stuff
19:05:37 <lament> and in any case it doesn't have to be a neural net, that was just an example
19:05:44 <newsham> dcoutts: does hackage do auto-builds?
19:05:48 <lament> but some learning technique, not position-evaluating technique
19:05:51 <dcoutts> newsham: yep
19:06:01 <newsham> would be nifty if they emailed out "you broke your 6.6 compat!"
19:06:26 <hpaste>  dcoutts annotated "package maintainers: updating your packages to work with ghc-6.8" with "word wrapped" at http://hpaste.org/3659#a1
19:06:51 <dcoutts> newsham: indeed, but it only tests after upload, not synchronously, so it does not reject ones that fail to build
19:07:08 <dcoutts> newsham: it could I suppose do an ad-hoc check on the package
19:07:26 <dcoutts> ie if it depends unconditionally on one of the new split base packages
19:08:29 <faxathisia> I got two data types
19:08:41 <newsham> after is still way better than not.
19:09:04 <faxathisia> say, A and B. Is it silly to try to make a function A -> A and B -> B which has the same name?
19:09:17 <faxathisia> (I'm guessing one uses a typeclass to do that)
19:10:47 <dmwit> Cale: I'm having fun trying to put my cube in this position: http://cale.yi.org/autoshare/Rubik-z1.png
19:11:01 <shachaf> faxathisia: class C a where f :: a -> a; instance C A where f = ...; instance C B = ... -- ?
19:11:15 <shachaf> I mean, instance C B where f = ...
19:11:21 <Cale> dmwit: :)
19:11:34 <Olathe> Those colors are ewwish.
19:11:37 <Cale> dmwit: ah, so you're the Stanford.edu ;)
19:12:00 <dmwit> heh
19:12:00 <dmwit> yeah
19:12:07 <faxathisia> shachaf: ok cool
19:12:11 <dmwit> The hilarious thing is how far from solved it looks in any given position.
19:12:11 <faxathisia> but do you think it's a good idea?
19:12:37 <shachaf> faxathisia: That depends on what you're doing, I guess.
19:12:46 <soduko> newsham: your program looks good:)
19:13:16 <faxathisia> well I have a type for statements, and a type for a procedure.. and I was wondering if I should use two or one function to invert them
19:14:34 * faxathisia gives upand decides to use two:S
19:15:20 <pmdboi> hmm, segfault on compiling ghc 6.8.1 :(
19:16:22 <dmwit> Got it!
19:16:46 <soduko> are there other users of haskore?
19:16:51 <dcoutts> pmdboi: that can be due to dodgy memory, it's worth trying again. If the error is repeatable report it, if it happens again at a different point in the build then use a utility to check your RAM.
19:17:39 <Olathe> But if my memory is dodgy, how will I remember to do that ?
19:17:52 <dcoutts> hah hah :-)
19:18:13 <dcoutts> dons: ok, sent, thanks for taking a look
19:18:21 <sjanssen> dcoutts: I've got a question about the configurations example at http://www.haskell.org/haskellwiki/Upgrading_packages
19:18:22 * SamB_XP wants a phone with more txt memory
19:18:23 <lambdabot> Title: Upgrading packages - HaskellWiki
19:18:33 <dcoutts> sjanssen: yes?
19:18:41 <sjanssen> dcoutts: is the value of the 'splitValue' flag chosen automatically somehow?
19:18:50 <dcoutts> sjanssen: yes
19:19:31 <newsham> soduko: ty
19:19:32 <soduko> what is the equivalent of dir() of python for ghci ? kinda like :browse to see what the loaded modules are and what they expose
19:19:38 <ddarius> SamB_XP: I don't understand why they don't.
19:19:52 <ddarius> SamB_XP: For some reason they won't use the other memory available.
19:20:26 <SamB_XP> perhaps my phone is written in Pascal
19:20:51 <sjanssen> dcoutts: oh, so 'if' is backwards, basically? :P
19:21:07 <dmwit> soduko: :info
19:21:35 <dmwit> and :type ;-)
19:21:47 <soduko> but it wants a thing as an argument
19:21:54 <pmdboi> dcoutts: it looks like it might be a GMP thing on my end
19:21:55 <soduko> Prelude> :info
19:21:56 <soduko> syntax: ':i <thing-you-want-info-about>'
19:22:17 <soduko> i want to what things  are availalbe to ask info about
19:22:29 <dmwit> soduko: Okay, the in what way do you want it to be different from :browse?
19:23:06 <soduko> just give with no args to see what modules are available
19:23:27 <omnId> soduko: nothing in ghci that I know of, but there's always the haddocks.
19:23:34 <soduko> in python if you do a dir() you can see the current state of the "dictionary"
19:23:41 <bparkis> I was reading something that makes an interesting point... in mathematics it is normal to refer to things like "the plane" or "the circle" in the abstract, without reference to any specific plane or circle
19:23:48 * pmdboi does "make clean"
19:23:50 * pmdboi cries
19:23:57 <dcoutts> sjanssen: it uses backtracking to find a suitable setting for all the flags
19:24:15 <dcoutts> sjanssen: but the flags can also be set by the user
19:24:17 * dcoutts -> bad
19:24:22 <dcoutts> oops :-)
19:24:25 * dcoutts -> bed
19:24:32 <sjanssen> dcoutts: thanks, goodnight
19:24:33 <omnId> freudian typo
19:24:43 <dcoutts> omnId: quite :-)
19:24:45 <bparkis> the guy makes the point that a circle could be the unit circle with center 0 in the plane, or a topological circle formed through connected line segments, or the real numbers modulo 1
19:25:00 <bparkis> and that for many purposes it doesn't matter which of these it is
19:25:38 <bparkis> I think that if mathematics has something like this in common usage, programming languages should have it too  (maybe some do)
19:25:57 <ddarius> It's called an abstract data type.
19:26:23 <Karle> hi
19:26:37 <Karle> I cannot compile foldl'
19:26:46 <Karle> which library do I need?
19:26:49 <newsham> still languages make you pick a particular instance.  i always thought it would be more interesting if you could overspecify the problem (as well as underspecify the problem) and still have it compilable.
19:26:54 <ddarius> @index foldl'
19:26:54 <lambdabot> Data.List
19:27:07 <newsham> ie. by having it ask you how to disambiguate (or defaulting) or providing undefined implementations for an interface
19:27:47 <omnId> Karle: import Data.List
19:28:00 <ddarius> @version
19:28:00 <Karle> thanks omnId
19:28:01 <lambdabot> lambdabot 4p575, GHC 6.6 (Linux i686 2.66GHz)
19:28:01 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:28:53 <SamB_XP> you know, there's something deeply wrong when a web browser gets a 404 trying to load about:blank...
19:29:34 <bparkis> in mathematics you could construct some arbitrary object and explain certain properties of it, and then give an argument and say "therefore this is a circle, so now i'll use this theorem that has to do with circles"
19:30:09 <newsham> instance Circle MyThing where ?
19:30:12 <ddarius> bparkis: Again, as I said, that's called an abstract data type (and related things) in the programming world.
19:30:22 <omnId> in Haskell you give a class and some operations on types in that class, with some optional laws that the operations must follow.
19:30:23 <bparkis> not because the object was a priori of a circle type, but because you yourself gave a justification, after having created it, of what it was
19:30:47 <newsham> bparkis: sounds pretty similar to how type classes and instances work.
19:31:12 <newsham> you make up some random crazy class and later say "oh, btw, it obeys the monad laws, and here is how it is a monad"
19:31:20 <newsham> (except there is no burden of proof for enforcing the laws)
19:32:00 <newsham> i guess with a stronger type system you could require it to obey the monad laws by requiring a proof at the same time as you define the operations?
19:32:10 <ddarius> newsham: Yes.
19:32:39 <ddarius> newsham: The OBJ family is pretty interesting in that regard.
19:32:55 <newsham> obj?
19:33:06 <ddarius> @google OBJ3
19:33:08 <lambdabot> http://kind.ucd.ie/products/opensource/OBJ3/
19:33:08 <lambdabot> Title: KindSoftware
19:33:16 <ddarius> @google OBJ3 Goguen
19:33:17 <lambdabot> http://www.cse.ucsd.edu/users/goguen/sys/obj.html
19:33:18 <lambdabot> Title: OBJ Family: OBJ3 CafeOBJ Maude Kumo FOOPS Eqlog
19:34:09 <newsham> how does OBJ* compare with say Agda or Coq?
19:34:46 <ddarius> OBJ is not a theorem prover or proof assistant.
19:35:08 <Karle> bye ....
19:35:16 <ddarius> It's not dependently typed.
19:35:58 <ddarius> Dependent types are almost certainly the way to go for this type of thing, but OBJ is nevertheless interesting
19:36:29 <newsham> danke.  unfort dont think I have time to look into this one in more detail.
19:36:51 <soduko> how to know the pwd from within ghci ?
19:36:59 <omnId> soduko: :! pwd
19:37:08 <omnId> :! to shell out
19:37:59 * ddarius watches omnId shell out cash.
19:38:24 * omnId would prefer shelling out bash
19:39:13 <newsham> cash is king
19:41:48 <ivanm> is there a nicer way to apply a function to both elements in a pair than to do (f *** f) (or indeed manually apply them) ?
19:42:03 <ivanm> I seem to recall using either ap or liftM, but can't remember
19:42:50 <ddarius> @pl \f (x,y) -> (f x, f y)
19:42:50 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
19:42:52 <soduko> omnId: thanks
19:43:44 <ivanm> ddarius: yeah, I tried that with lambdabot already, but that's even worse :s
19:44:24 <soduko> how to know the full type? for example if i give :t song2 the output is song2 :: T . how do i know if it is Haskore.Music.GeneralMIDI.T or Haskore.Melody.T
19:44:26 <omnId> ivanm: try curry and uncurry
19:44:31 <bparkis> I actually don't even mean with respect to types... i mean construct an arbitrary object and claim it's a circle, or more reasonably for programming, claim it's sorted, for instance--a property of the actual value, not of its type
19:44:41 <oerjan> ivanm: join(***)
19:44:56 <bparkis> claiming that a value has a type even though the value's type is not of that type
19:45:26 <soduko> bparkis: thats  interesting, because you can do that in most languages..
19:45:56 <omnId> soduko: hrm... what odd type names.   Try :m -Haskore.Whatever to unload some modules so they'll be qualified.
19:45:59 <soduko> general OOP terminology: create an interface that responds to all the properties you want o reason over
19:46:38 <soduko> omnId: how can i see a list of the loaded modules?
19:46:42 <ddarius> bparkis: You could make an abstract data type of sorted sequences.
19:47:29 <soduko> that is just the representation part , the reason part is also similar. you dont actually need to be tied to an instance.
19:47:31 <omnId> soduko: they're listed to the left the the > prompt, but it doesn't show modules which are themselves imported into one of these.
19:47:50 <soduko> that just shows Flip
19:48:59 <ivanm> omnId: not sure how that applies...
19:49:02 <ivanm> oerjan: thanks!
19:49:02 <bparkis> but ddarius the property that a set is sorted can't be checked except at runtime, unless you have a full proof checking system as part of your language and a proof
19:49:05 <ivanm> @type join
19:49:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:49:44 <bparkis> and runtime checking isn't the best because then your program could fail
19:50:06 <oerjan> join(***) is essentially <$> for pairs, uncurry(***) is <*>
19:50:20 <ivanm> what's <$> and <*> ?
19:50:25 <omnId> @type uncurry (<*>)
19:50:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (f (a -> b), f a) -> f b
19:50:29 <omnId> @type uncurry (***)
19:50:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
19:50:33 <ddarius> bparkis: The property that a binary tree is a binary search tree can't be checked except at run-time either (typically
19:50:35 <hpaste>  soduko pasted "type inference issue" at http://hpaste.org/3661
19:50:40 <soduko> ok i give up i need some help.
19:50:50 <newsham> hmm.. hoogle needs to be updated?
19:51:05 <bparkis> but it can be proved by a human prior to runtime, and proof checkers exist
19:51:09 <oerjan> ivanm: <$> is a synonym for fmap, used with the Applicative method <*>
19:51:16 <faxathisia> :(
19:51:17 <ivanm> *nod*
19:51:20 <ddarius> bparkis: So can the fact that a certain sequence is sorted.
19:51:25 <ivanm> when did they come in?
19:51:29 <bparkis> also true
19:51:29 <ivanm> any particular library?
19:51:30 <faxathisia> I have to reorder my data types if they derive Show?
19:51:42 <ddarius> faxathisia: Huh?
19:51:53 <faxathisia> oops turns out you don't I was confused
19:51:56 <bparkis> but the proof + proof checker isn't implemented as a type check as part of the programming language
19:51:56 <oerjan> if you defined newtype Pair a = Pair (a,a) then you could make Pair an Applicative instance with those
19:52:06 <ddarius> bparkis: It could be.
19:52:15 <bparkis> yes it could
19:52:18 <ddarius> bparkis: But if it isn't, you fall back on run-time checks.
19:52:47 <newsham> > fmap (+1) (3,2)
19:52:48 <bparkis> an uneasy solution
19:52:49 <lambdabot>  (3,3)
19:53:11 <ddarius> bparkis: They'd be necessary anyway to check input.
19:53:13 <newsham> ?src ((,) a) fmap
19:53:13 <lambdabot> Source not found. :(
19:53:18 <newsham> ?src (,) fmap
19:53:19 <lambdabot> fmap f (x,y) = (x, f y)
19:53:30 <newsham> :(
19:53:37 <newsham> weird choice
19:53:42 <omnId> newsham: the kind.
19:53:52 <bparkis> no, you'd prove that your input filter only allows well formed expressions through
19:54:01 <omnId> you'd need data Pair a = Pair a a, if you want the other fmap
19:54:04 <ddarius> bparkis: Yes, and the input filter would be the run-time check.
19:54:20 <ddarius> bparkis: You can't prove that the user only inputs well-formed expressions.
19:54:25 <bparkis> ok, but that's unavoidable
19:54:29 <ddarius> Exactly.
19:54:36 <ddarius> Hence "necessary anyway"
19:54:53 <bparkis> ideally you want to prove as much as you can about the behavior of your program, and have that checked automatically
19:55:10 <bparkis> as part of the type system
19:55:31 <oerjan> ivanm: Control.Applicative
19:55:41 <ddarius> bparkis: Ideally you would want that for free.  Currently the feeling is that the costs outweigh the benefits (whether this feeling is justified or not is a different question)
19:56:07 <newsham> bparkis: type system for haskell makes some types of specs you'd want ot use hard or impossible to write
19:56:46 <ddarius> Proving something is harder than verifying it.
19:56:48 <newsham> but it seems like there's a bunch of more researchy type systems where people are doing more specs in the type system
19:58:34 <bparkis> i read a while ago about something called chi or xi, a Common Lisp variant with a flexible type system
19:58:46 <ddarius> Thinking of Qi?
19:58:56 <bparkis> qi yeah
19:59:11 <ddarius> bparkis: Once the type system is Turing-complete then you can encode any properties.
19:59:41 <ddarius> Of course checking the proofs becomes harder then...
20:00:21 <ivanm> does @source work for functions defined in the prelude?
20:00:22 <bparkis> automatically generating them becomes harder, checking them by computer is still possible
20:00:40 <faxathisia> you get a new stage of programming
20:00:50 <faxathisia> The bit where you prove the program you just described can be written :D
20:00:55 <bparkis> in haskell the computer both generates proofs for type checks, and checks them
20:01:25 <mrd> it's possible to give up decidable type checking
20:01:34 <bparkis> but strictly speaking all it really needs to do is check, if it has an expressive enough notation and a human writes the proof
20:01:49 <newsham> dont most research systems still stick to decidable type systems?
20:02:09 <oerjan> ivanm: do you mean @src? they're different commands, @source takes a module
20:02:15 <oerjan> and gives a URL
20:02:17 <mrd> generally
20:02:24 <ivanm> heh, yeah
20:02:42 <ivanm> and I was using @src... but typed @source here when I asked
20:03:25 <faxathisia> Can I ask for some advice on this please
20:03:31 <faxathisia> findProcedureNamed name = (!!0) . filter (\(Procedure proc _) -> proc == name)
20:03:44 <oerjan> ivanm: @src has many Prelude functions but all sorts of unpredictable omissions
20:03:49 <faxathisia> I just take a list of procedures and find the first with a given name
20:03:53 <oerjan> @src map
20:03:53 <lambdabot> map _ []     = []
20:03:53 <lambdabot> map f (x:xs) = f x : map f xs
20:03:57 <ivanm> *nod*
20:03:59 <omnId> @src find
20:03:59 <lambdabot> find p          = listToMaybe . filter p
20:04:04 <bparkis> it's simple for a computer to check that the types match, if the human gives the proof that they do
20:04:06 <faxathisia> wondering how you would actually write it though
20:04:10 <faxathisia> since my version sucks
20:04:11 <ivanm> I guess ones that are used as part of an instance declaration would be ommitted?
20:04:13 <bparkis> all the computer has to do is verify the human's proof
20:04:15 <omnId> faxathisia: ^
20:04:38 <bparkis> even if the language the human uses to write the proof is too expressive for the computer to come up with its own proof
20:04:39 <faxathisia> omnId: and like just produce an error when I get Nothing?
20:04:40 <oerjan> ivanm: not necessarily, the syntax is:
20:04:46 <oerjan> @src [] >>=
20:04:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:04:51 <oerjan> @src [] (>>=)
20:04:51 <lambdabot> m >>= k     = foldr ((++) . k) [] m
20:04:58 <ivanm> *nod*
20:05:22 <bparkis> like what if you used Mizar as the type system for your language
20:05:27 <omnId> faxathisia: you're writing an interpreter of some kind?
20:05:28 <bparkis> that would be possible
20:05:31 <faxathisia> omnId: yeah
20:05:46 <omnId> faxathisia: it'd be an error, you'll have to handle it somewhere.
20:05:46 <oerjan> ivanm: however not everything has source, some is primitive.  and longer functions are missing.
20:05:49 <ddarius> Proof checking is much easier than theorem proving, but it still requires the proof language to be strongly normalizing in general.
20:06:02 <oerjan> @src (^)
20:06:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:06:07 <faxathisia> error "Procedure not found"
20:06:11 <faxathisia> Like that seems ok?
20:06:27 <ddarius> E.g. proof carrying code and related fields use systems like LF as the language of proofs.  The proof checker for LF is relatively simple, but the language is still strongly normalizing.
20:06:29 <ivanm> oerjan: yeah, that's what I was afraid of... I wanted to see how quotRem was defined, but it's probably inbuilt :s
20:06:48 <omnId> faxathisia: I guess, depends how you want to handle it.
20:06:58 <faxathisia> I don't really know about that stuff
20:07:22 <faxathisia> I think I can just error to give up immediatly
20:07:28 <oerjan> @src Integral
20:07:28 <lambdabot> class  (Real a, Enum a) => Integral a  where
20:07:28 <lambdabot>     quot, rem, div, mod :: a -> a -> a
20:07:28 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
20:07:28 <lambdabot>     toInteger           :: a -> Integer
20:07:35 <oerjan> ivanm: it's a method
20:07:57 <faxathisia> @index find
20:07:57 <oerjan> although some method have defaults, which may be in @src.
20:07:58 <lambdabot> Data.List
20:07:58 <bparkis> Mizar uses a full featured set theory
20:08:13 <oerjan> instances for numeric types rarely have source
20:08:18 <ivanm> well, quotRem is one of those required for a minimal implementation of an instance...
20:08:21 <oerjan> afaiu
20:08:31 <ivanm> and yes, that's what I figured
20:08:52 <oerjan> ivanm: however, you can go delve into ghc source if you want
20:09:01 <oerjan> @source Prelude
20:09:01 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
20:09:20 <ddarius> bparkis: And Coq uses the entire calculus of inductive constructions.
20:09:23 <ivanm> tried looking there... quotRem shows up only for an export listing, AFAICT
20:09:33 <oerjan> although you'll probably need to trace a bunch of imports
20:09:50 <oerjan> right, it's imported from somewhere more primitive
20:09:59 <oerjan> @src Int quotRem
20:10:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:10:11 <ivanm> *shrug* oh well
20:10:29 <bparkis> i'm not sure what 'strongly normalizing' means in this context
20:10:39 <ddarius> bparkis: The same thing it means in any contetx.
20:11:10 <bparkis> Mizar's set theory is undecidable, it's ZF with one extra axiom
20:11:46 <bparkis> what is 'normal form' for a statement in set theory?
20:12:49 <dmwit> :t any
20:12:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:13:06 <oerjan> @src Int
20:13:07 <lambdabot> data Int = I# Int#
20:13:35 <faxathisia> Like
20:13:36 <faxathisia> r
20:13:45 <faxathisia> case find (\(Procedure proc _)->proc==name) env of -- This?
20:14:02 <dmwit> > \xs ys -> any (uncurry (<=)) [(x, y) | x <- xs, y <- ys]
20:14:04 <lambdabot>  <[Integer] -> [Integer] -> Bool>
20:14:18 <oerjan> ivanm: btw quotRem eventually turns into a dedicated assembler instruction iirc
20:14:20 <faxathisia> would be, find (==(Procedure name _)) env
20:14:27 <faxathisia> maybe nicer
20:14:43 <ivanm> oerjan: heh, that'd be right
20:14:44 <ivanm> thanks anyway
20:14:47 <oerjan> it's been discussed before, because divMod doesn't
20:15:27 <ivanm> hmmmm
20:15:48 <bparkis> checking logical inferences is usually easier than reducing an expression to normal form
20:16:40 <oerjan> (on i86)
20:16:40 <faxathisia> Any other way to write (\(Procedure proc _)->proc==name)
20:17:28 <oerjan> and Integer uses the gmp library
20:18:24 <oerjan> faxathisia: you could define Procedure with record syntax, so the proc field has a name
20:18:25 <ddarius> You don't have to normalize to check a proof, in fact, knowing that a proof language is strongly normalizing makes that possible.
20:18:42 <oerjan> then you could use (==name).procField
20:19:06 <faxathisia> hey I like that
20:19:15 <faxathisia> I'll do that, thanks
20:19:49 <soduko> :) at last!!! i got some music from haskore :)  just a cMaj scale , now to figure out what else can be done :D
20:20:45 <bparkis> well I don't know what you mean, anyway though it's a technical point, main idea is clear, you could use a full featured proof checker as your type system if you really wanted to although it would be more work to use
20:21:07 <ddarius> bparkis: And such things exist.  In fact, that is kind of what Agda is aiming for.
20:21:21 <ddarius> All this is very well known.
20:22:23 <bparkis> I think what I was originally getting at is reverse generalization
20:22:47 <faxathisia> :|
20:22:57 <bparkis> instead of always writing code that's abstract, you might write code that is concrete, and then claim it is abstract in a certain way and use it in the abstract way from there on
20:22:57 <faxathisia> I just realized something difficult
20:22:58 <oerjan> hm?
20:23:47 <oerjan> hm?
20:23:57 <bparkis> such as, instead of starting with a general type of sorted arrays for some relation, you start with specifics and then later on claim abstract properties of the things you have mad
20:23:58 <bparkis> made
20:24:16 <faxathisia> (ugh I thought it was difficult to write a show instance for an AST which prints out code indented but then I just realized it's trivial because show can call another function)
20:24:57 <bparkis> it seems like haskell (and most languages) requires you to write code abstraction-first if you want it to be used in an abstract way
20:26:10 <bparkis> whereas in math, you sometimes start with concrete things and only after some discourse mention that they have some abstract structure
20:26:47 <oerjan> bparkis: but that sounds like instances, which haskell can add in afterthought
20:27:24 <bparkis> instances only work if you have defined a type for the values you are working with, which is still abstraction first
20:28:26 <soduko> how can i map a char to a function of the same name? eg: f str o d = map (\n-> Note (func n) o d ) str
20:28:28 <bparkis> you might be working with values in basic types like lists or integers, you don't want to add an instance there, but you might still want to note an abstraction
20:28:54 <soduko> n is a char but also the name of a funcion. eg: "ceg"  is a string but c , e and g are also funcitons
20:29:17 <ddarius> bparkis: You need something to witness that "abstraction".  Maybe you want to look at something like refinement types.
20:29:29 <dmwit> soduko: Maybe write a "case"?
20:29:30 <oerjan> soduko: you need some map from names to functions
20:29:32 <faxathisia> soduko: fromChar 'c' = c ; fromChar 'e' = e -- I think it's the only way
20:29:38 <dmwit> yeah
20:29:47 <dmwit> Going backwards is harder. =)
20:30:33 <soduko> hmm. that is what i wanted to avoid:( but no problem, basically i am trying to generate sequences of notes,
20:30:45 <newsham> data Note = A | B | C | D | E | F | G deriving (Show,Read)
20:30:54 <oerjan> soduko: you can also make a list of pairs, may be more compact
20:31:00 <dmwit> Oooo, deriving read. sneaky
20:31:01 <newsham> read (show C)
20:31:13 <faxathisia> :o
20:31:17 <soduko> and i can write a function to permute a given list and generate a lot of music.
20:31:24 <soduko> what does read do?
20:31:29 <newsham> > read '3' :: Int
20:31:33 <dmwit> > read "3" :: Int
20:31:34 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
20:31:35 <lambdabot>  3
20:32:02 <newsham> read is the almost-inverse of show
20:32:16 <soduko> haskore denies a data PitchClass = Cf | C | Cs | Df | ...
20:32:22 <soduko> but it is not enumerable..
20:32:37 <faxathisia> you can write an instance for Enum on it I think ?
20:32:39 <dmwit> s/denies/defines/?
20:32:46 <newsham> compare Cs Df
20:32:47 <oerjan> > read "[(3,5,\"argle\",[1.0,2.0])]" :: [(Int,Integer,String,[Double])]
20:32:49 <lambdabot>  [(3,5,"argle",[1.0,2.0])]
20:33:14 <faxathisia> > fix (show . read)
20:33:16 <lambdabot>  Exception: <<loop>>
20:33:29 <dmwit> > fix show
20:33:30 <soduko> deriving ( EQ, Ord, Ix, Show, Read)
20:33:30 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:33:33 <faxathisia> > fix read
20:33:34 <lambdabot>  Exception: <<loop>>
20:33:38 <oerjan> soduko: i remember ghc 6.8.1 has a separable deriving declaration now
20:34:04 <oerjan> so you might actually do deriving Enum PitchClass
20:34:11 <soduko> oerjan: what does that mean
20:34:18 <dmwit> soduko: Oh, perfect, so you can just use the Read instance.
20:34:36 <newsham> > group $ fix read
20:34:38 <lambdabot>  Exception: <<loop>>
20:34:38 <dmwit> oerjan: It's not a good idea for notes; c sharp is not one (half-)step below d flat, for example.
20:34:48 <newsham> > group $ fix show
20:34:49 <dmwit> > map length . group . fix $ show
20:34:49 <bparkis> this is actually, now that i think about it, sort of a rehash of something i was talking about earlier--suppose you have a function that sorts integers and you want to get it to sort grid points by their x-coordinate
20:34:50 <lambdabot>  ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\\...
20:34:53 <lambdabot> Terminated
20:35:08 <oerjan> dmwit: i just realized that
20:35:37 <bparkis> is there any way where it might be plausible to lift your function up to be used more generally, even though it was written with a very narrow type signature?
20:35:57 <soduko> > read "C"::String
20:35:59 <lambdabot>  Exception: Prelude.read: no parse
20:36:02 <dmwit> bparkis: Usually the lift is in the other direction.
20:36:04 <bparkis> again doing that would be concrete first, abstract second, the reverse order that you normally do it
20:36:04 <dmwit> :t sortBy
20:36:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:36:12 <oerjan> soduko: it means you can derive instances automatically for a library type someone if someone forgot one
20:36:16 <oerjan> i assume
20:36:16 <newsham> > map (length.filter (=='\\')) $ group $ fix show
20:36:20 <lambdabot> Terminated
20:36:24 <faxathisia> > read "\"C\""::String
20:36:24 <bparkis> yes dmwit but it is often convenient to do it in the opposite order
20:36:24 <oerjan> *-someone
20:36:25 <lambdabot>  "C"
20:37:08 <bparkis> requiring you to write a fully general sort algorithm, even when its essence is just sorting integers
20:37:14 <newsham> > map (length.(filter (=='\\'))) $ group $ fix show
20:37:18 <lambdabot> Terminated
20:37:21 <newsham> hrm
20:38:06 <soduko> ok folks, thanks a lot, im off to dinner now, hopefully ill figure out how to generate a sequence of music :) then on to markov chains, and lots of "inspired" music
20:38:15 <faxathisia> Do you think Parsec is the good choice for parsing a language which has I-exp like haskell and python?
20:38:21 <dmwit> > take 4 . map length . group $ fix show
20:38:22 <lambdabot>  [1,1,1,3]
20:38:27 <bparkis> that is the normal order requires you to write a more general sort algorithm, the reverse order might allow you to write a concrete algorithm that deals with integers and then use it for other things
20:38:28 <dmwit> > take 8 . map length . group $ fix show
20:38:35 <lambdabot>  [1,1,1,3,1,7,1,15]
20:38:45 <shachaf> lambdabot takes some number of character from a string before showing it.
20:38:59 <dmwit> newsham: It takes too long to get far enough in the list for lambdabot to show it. =P
20:39:00 <shachaf> > [1,2,undefined]
20:39:02 <lambdabot>  Undefined
20:39:11 <ddarius> bparkis: In programming we have to actually witness and manage these abstractions.
20:39:18 <bparkis> but i haven't been able to figure out if that is in any way plausible, to lift a concrete function into an abstract one--but the thing is that's what you would do in mathematics
20:39:26 <newsham> what is the function for the number of backslashes?
20:39:40 <dmwit> 2^n-1
20:39:48 <andyjgill> classic question: I'm looking for a small example of a problem that can show how Haskell uses functional thinking with an imperative shell round it. Any ideas?
20:39:56 <bparkis> in programming we do have to think abstraction first but i'm wondering is that an essential part of programming or just an artifact of us not having the right tools?
20:40:10 <dmwit> andyjgill: xmonad?
20:40:15 <newsham> doesnt look like 2^n-1
20:40:24 <newsham> ?hoogle fix
20:40:24 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:40:24 <lambdabot> Control.Monad.Fix :: module
20:40:24 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:40:31 <dmwit> newsham: Remember, there's interspersed 1's for the \" character.
20:40:39 <andyjgill> to long,  I want to write a ~20 line implementation
20:40:43 <shachaf> andyjgill: Any interact example, maybe?
20:40:53 <dmwit> andyjgill: How about the Unix shell commands?
20:41:08 <andyjgill> Ahh. thats an idea.
20:41:13 <dmwit> http://haskell.org/haskellwiki/Simple_Unix_tools
20:41:13 <shachaf> dmwit: That's what I meant.
20:41:14 <lambdabot> Title: Simple Unix tools - HaskellWiki
20:41:21 <newsham> > take 8 $ map (length . filter (=='\\')) $ group $ fix show
20:41:23 <lambdabot>  [0,1,0,3,0,7,0,15]
20:41:23 <bparkis> from a practical standpoint it's frequent that someone writes a specific, single-purpose algorithm and then wants to adapt it to do something similar but more general
20:41:33 <newsham> ahh, there it is
20:42:23 <bparkis> it may be a pipe dream
20:42:43 <faxathisia> in that simple unix tools thing, how many lines of C code is used to write those programs?
20:42:57 <ddarius> bparkis: People -usually- write a specific single-purpose algorithm and then abstract from there.
20:43:09 <bparkis> _manually_ abstract from there
20:43:31 <dibblego> I used to do that, but I try not to when I can
20:43:36 <bparkis> meaning write an entirely new function based on the experience of the old
20:44:24 <dmwit> faxathisia: That question is flawed.
20:44:29 <SamB> hmm. this twitter client makes twitter look like IRC
20:44:34 <SamB> ttyter by name
20:44:37 <faxathisia> dmwit: hm why?
20:44:41 <dmwit> faxathisia: For example, do you count the lines of code it takes to write "map" or "reverse"?
20:45:15 <bparkis> i.e. is it theoretically possible to say to the algorithm "look at these ordered pairs as just their x coordinate, and sort them as if that's all they were"
20:45:25 <faxathisia> dmwit: I was just wondering about the C code
20:45:30 <faxathisia> dmwit: I guess no one did a count
20:45:51 <dmwit> bparkis: Sure, map fst.
20:45:59 <bparkis> and somehow, out of that, get the sorted ordered pairs (not just the sorted x coordinates)
20:46:25 <dmwit> bparkis: Your function has to at the very least be able to sort pairs.  This is true in every language I can think of.
20:46:43 <newsham> fax: those simple unix replacement commands are not functionally equivalent to the tools they claim to replace.
20:46:57 <newsham> so comparing loc in that example wouldnt be very meaningful
20:47:13 <omnId> sortBy (\(x1, _) (x2, _) -> compare x1 x2)
20:47:24 <omnId> sortBy (compare `on` fst)
20:47:27 <newsham> (also writing a cat function is less work than writing a cat command, with cmd line parsing)
20:47:45 <dmwit> bparkis: To be honest, I really don't know why you're spending so many brain cycles on this.
20:48:03 <bparkis> because you think it is impossible, and you could be right
20:48:08 <dmwit> bparkis: The kind of refactoring you're talking about is trivial with HOFs.
20:48:25 <bparkis> but to do that you have to write your sort algorithm with generalization in mind
20:48:37 <dmwit> Not really.
20:48:40 <dmwit> Just write it normally.
20:48:43 <dmwit> Afterwards, generalize it.
20:48:45 <dmwit> No problem.
20:48:48 <bparkis> you have to give it an extra parameter when you write it--that's abstraction first and it is boilerplate
20:49:08 <ddarius> bparkis: It's not boilerplate because you have to tell it what you mean.
20:49:29 <ddarius> And that extra parameter is the witnessing and managing the abstraction that I was talking about earlier.
20:50:21 <bparkis> suppose you determined some new sorting algorithm for integers that no one has seen before, and wrote it down in a concrete form that only works on integers, then said "ok and now use my algorithm to sort these people by age"
20:50:38 <bparkis> would anyone not know what you meant?
20:51:09 <bparkis> in English you can do that with no ambiguity, you can't do it in any PL I know
20:51:32 <omnId> I usually don't write sorting algorithms in English.
20:51:35 <dmwit> Sure you can.  You just added a parameter: the mapping from people to age.
20:51:51 <dmwit> So do the same thing in your code: allow a mapping from objects to their comparable parts.
20:52:35 <bparkis> but you'd have to add code in your algorithm to do the data munging, shuffling the people around with the integers
20:52:47 <bparkis> so you're not just adding a parameter you're going inside your algorithm and changing it
20:53:05 <bparkis> which is more complicated than just saying "sort the people by age"
20:53:10 * dmwit suspects that this argument could go around in circles for quite a while without producing any interesting new ideas
20:53:13 <ddarius> bparkis: Obviously adding a parameter implies changing the implementation of the algorithm in all but the trivial case.
20:53:31 <bparkis> that is obvious
20:53:38 <faxathisia> your function takes [Int] but you have [Person] and Person -> Int
20:53:44 <omnId> "just saying" "sort the people by age" is not as trivial as you may think.
20:53:53 <oerjan> bparkis: it might be that your algorithm _couldn't_ be used to sort people by age, because it ignores the difference between things having the same sort key to the extent of duplicating one for the other
20:54:21 <faxathisia> it should be possible to (with language support) automatically convert the function to apply the function to the element whenever it requires the property of Integers
20:54:50 <bparkis> your function is intsort :: [Int] -> [Int] and let's say you had sortBy :: ([a] -> [a]) -> [(a, b)] -> [(a, b)]
20:55:17 <bparkis> the types would at least match up if you tried sortBy intsort [...somelist...]
20:56:18 <bparkis> so is there any inherent reason why the function sortBy can't be written?
20:56:41 <dmwit> faxathisia: Disagree.  How would you convert, i.e., (map (+1))?
20:56:52 <faxathisia> dmwit: to what?
20:57:02 <ddarius> @free ([a] -> [a])
20:57:03 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
20:57:07 <faxathisia> increase everyones age?
20:57:22 <ddarius> @free f :: ([a] -> [a]) -> [(a,b)] -> [(a,b)]
20:57:22 <lambdabot> $map g . k = p . $map g => $map ($map_Pair g h) . f k = f p . $map ($map_Pair g h)
20:57:36 <shachaf> faxathisia: Would you need Int -> Person for that too?
20:57:44 <dmwit> faxathisia: You have (map (+1)) :: [Int] -> [Int], and you have xs :: [Person], and you have f :: Person -> Int.  How would you combine these to make something sensible?
20:58:18 <dmwit> faxathisia: My point is that there just isn't enough information there to know what the result of combining these ought to be.
20:58:30 <dmwit> faxathisia: You need more information, and bparkis seems to be saying you don't.
20:58:41 <faxathisia> dmwit: I see how you can do it
20:58:48 <bparkis> that's why I think this is a potentially fruitful line of thought... either you come up with a good reason why indeed sortBy can't be written, which increases your understanding, or you find out how to write sortBy, which increases your understanding
20:58:50 <faxathisia> dmwit: you replace every operation on the elements of the list which uses the Int property, to work on f
20:59:09 <faxathisia> dmwit: And every operation on the list/list elements which do not use the int proprty can be generlized
20:59:12 <dmwit> faxathisia: Fail.  You don't have a reverse mapping  g :: Person -> Int -> (new) Person.
20:59:21 <faxathisia> dmwit: not fail, this is trivial
20:59:51 <oerjan> faxathisia: what if there are two people with the same age?
20:59:57 <faxathisia> oh you wanted [Person] -> [Person]
21:00:03 <faxathisia> instead of [Person] -> [Int]
21:00:15 <dmwit> faxathisia: What you have just described is exactly equivalent to using a map first, which is *already doable*.
21:00:42 <faxathisia> you need to pass another function
21:00:54 <faxathisia> yeah g
21:01:00 <dmwit> So we're in agreement.
21:01:27 <bparkis> in fact you can write sortBy
21:01:34 <dmwit> bparkis: I think the problem I have is that there are just too many ways to abstract any given function.
21:01:35 <bparkis> it's just inefficient
21:01:38 <faxathisia> I think with language support it's quite simple
21:01:47 <dmwit> There's no way for the compiler to know which one you want unless you say so.
21:01:54 <bparkis> you can write sortBy by taking the first elements of each pair of the list
21:02:01 <faxathisia> You should be able to replace data types with different types and some functions too
21:02:18 <bparkis> and generating a new list that has those elements uniquified (no duplicates) but in the same order otherwise
21:02:26 <oerjan> @let badSort :: [Int] -> [Int]; badSort l = concat [replicate n x | (n,x) <- (length &&& head).group.sort $ l]
21:02:27 <lambdabot> Couldn't match expected type `[t]'
21:02:28 <faxathisia> I can't see any reason why this couldn't be done automatically
21:02:32 <oerjan> gah
21:02:33 <bparkis> then send that list to your sort function (in this case intsort)
21:02:46 <newsham> lots of things that shouldnt be done automatically could be done automatically
21:02:53 <newsham> like  "3" + 5
21:02:55 <bparkis> then examine the order that the sort function returned that list in, and perform the same transformation on your input list of pairs
21:03:07 <faxathisia> newsham: That's extremely useful in certain languages
21:03:15 <newsham> heh.. if you say so.
21:03:24 <dmwit> faxathisia: Why is that more useful than
21:03:27 <dmwit> read "3" + 5
21:03:27 <newsham> $x + 0 *cough*
21:03:28 <bparkis> that's not asymptotically less efficient, it's actually only O(n) extra overhead
21:03:33 <dmwit> > read "3" + 5
21:03:35 <lambdabot>  8
21:03:37 <bparkis> but it is needlessly inefficient
21:03:50 <newsham> fax: anyway, if you think its useful, there are languages out there for you :)
21:04:19 <faxathisia> newsham: ..yeah.. I use several programming languages regularly
21:04:19 <shachaf> bparkis: Can you write sortBy, then?
21:04:32 <dmwit> bparkis: You are assuming that the only operations done are motions.  But in general the operations could have addition, or multiplication, or transfiguration, and there's no natural mapping from those things back onto Person data structures.
21:04:33 <faxathisia> newsham: you say that like it's a bad thing :/
21:04:49 <dmwit> Except for transfiguration. =)
21:04:57 <bparkis> actually performing the same transformation on your input list of pairs could be difficult, that might be n log n
21:05:22 <newsham> fax: no, most of us use several programming languages.
21:05:23 <bparkis> well, maybe
21:05:31 <newsham> I just dont like to see bad ideas borrowed from them ;-)
21:06:23 <oerjan> @let badSort :: [Int] -> [Int]; badSort l = concat [replicate n x | (n,x) <- map(length &&& head).group.sort $ l]
21:06:36 <lambdabot> Defined.
21:06:39 <newsham> i'm probably being overly opinionated right now.
21:07:09 <Pseudonym> Opinionated?  Here?  Get out!
21:07:30 <oerjan> there, a sorting algorithm which throws away all except one duplicate, then replicates it.  that works fine on Ints, but on People by age? no.
21:07:45 <dmwit> [replicate n x | (n, x) <- map (length &&& head) . group xs] == xs
21:07:53 <bparkis> well the sortBy function I described would work with any sorting algorithm
21:07:57 <soduko> what does this mean? Prelude> :b Haskore.Music
21:07:58 <soduko> type T note = Media.List.T (Primitive note)
21:08:01 <bparkis> no matter what the sorting algorithm did
21:08:06 <dmwit> oerjan: Oh, I see what you were shooting for.
21:08:23 <faxathisia> newsham: fwiw I agree the implicit coercing is -horrible- in most cases but I find it really useful for some specific stuff
21:08:24 <soduko> what is Primitive note?
21:08:36 <dmwit> bparkis: I'm pretty sure oerjan just showed that you what you ask for is not possible.
21:08:47 <bparkis> dmwit: i already said how you could write sortBy
21:08:55 <shachaf> bparkis: Could you write it, then?
21:08:59 <oerjan> > badSort . take 20 $ cycle [1..5]
21:09:00 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5]
21:09:01 <dmwit> bparkis: Yes?  And how would it handle oerjan's example, then?
21:09:02 <bparkis> yes i could
21:09:17 <bparkis> did you read how i said you could do it
21:09:26 <bparkis> it would handle oerjans example so long as it is a correct sort
21:09:51 <dmwit> Oh, whoops, you're right.  Sorry.
21:09:51 <shachaf> bparkis: It is a correct sort, on Ints.
21:10:42 <oerjan> soduko: should be a Primitive type defined somewhere.  note is the type parameter to T
21:10:44 <dmwit> bparkis: That is, in my opinion, a Bad Way to add this kind of abstraction.
21:10:49 <bparkis> indeed
21:11:01 <bparkis> i'm not saying it's good, i'm just saying it is at least possible
21:11:08 <bparkis> so maybe it could be made good
21:11:10 <dmwit> It is significantly more work than simply refactoring your sort to take a function parameter, and much much slower to boot.
21:11:26 <bparkis> much slower indeed
21:11:34 <bparkis> but i disagree about the more work part
21:11:47 <soduko> so in in teh code one should be able to substitue T cs with Media.List.T ( Primitive cs) right?
21:11:58 <dmwit> You would have to write a "fooBy" for every function you wanted to generalize.
21:12:04 <dmwit> That is more work.
21:12:13 <bparkis> because you could write a sortBy function that handled all of the abstraction of sorting, and it would make many concrete sorting functions abstract
21:12:38 <sjanssen> bparkis: it is trivial to turn any concrete sort into a sortBy function
21:12:44 <bparkis> if you had 10 sorting functions, they could all be non-abstract, and one sortBy would make them all abstract
21:12:45 <sjanssen> it could be mechanized, even
21:12:49 <oerjan> bparkis: the thing is, to make your sortBy work you have to know more than the denotation of the original sort function.  Essentially you need to use your idea of how a generalized sort should work, which is not determined solely by what the original sort function does
21:13:58 <bparkis> true
21:14:01 <oerjan> soduko: right
21:14:12 <bparkis> but it is adding abstraction so that might be inescapable--might.
21:14:28 <soduko> oerjan: thx
21:15:53 <faxathisia> Is there a really really simple version of haskell or something written in haskell
21:15:58 <faxathisia> for trying out ideas?
21:16:17 <ddarius> faxathisia: There's various core languages, the lambda calculi, and baskell.
21:18:01 <faxathisia> ah cool
21:22:58 <omnId> @@ @run map toUpper @show @brain
21:22:59 <lambdabot>  "PROMISE ME SOMETHING, PINKY. NEVER BREED."
21:25:15 <oerjan> @@ @run unwords . sort $ (words @show @brain) ++ (words @show @yow)
21:25:15 <lambdabot>  Unbalanced parentheses
21:25:29 <oerjan> huh
21:25:31 <omnId> lol
21:25:58 <oerjan> @@ @run unwords . sort $ words (@show @brain) ++ words (@show @yow)
21:26:01 <lambdabot>  "And Brain, I I I'd Macarena. Oooh, average bowling but eat furthermore, is ...
21:26:14 <omnId> LOL
21:26:40 <Korollary> well done
21:27:17 <omnId> "And Brain, I I I'd Macarena." should be the topic.
21:27:36 <oerjan> @brain Macarena
21:27:36 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
21:27:59 <oerjan> hm, no regexp lookup?
21:28:14 <oerjan> @list brain
21:28:14 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
21:28:16 <faxathisia> @@ @brain ++ @brain
21:28:16 <lambdabot>  I think so, Brain! But ruby-studded stockings would be mighty uncomfortable wouldn't they?
21:28:34 <faxathisia> @@ (@show @brain) ++ (@show @brain)
21:28:34 <lambdabot>  "I think so, Brain, but I don't think Kaye Ballard's in the union." ++ "But where are we going to find a duck and a hose at this hour?"
21:28:50 <omnId> faxathisia: @run
21:28:57 <Korollary> @@ @ghc ++ @brain
21:28:57 <lambdabot> Plugin `compose' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
21:29:09 <oerjan> @help ghc
21:29:09 <lambdabot> ghc. Choice quotes from GHC.
21:29:18 * faxathisia wonders how to check if a string contains a substring :S
21:29:26 <omnId> @@ @run (@show @ghc) ++ (@show @brain)
21:29:27 <lambdabot>  "ghc says: Unable to mmap( MAP_FIXED ) for Jump IslandsI think so, Brain, bu...
21:29:31 <oerjan> :t isInfixOf
21:29:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
21:35:06 <oerjan> @@ @run let w = words (@show @ghc) ++ words (@show @brain); l = length w in unwords . take (l `div` 2) . drop (l `div` 4) $ w
21:35:08 <lambdabot>  "I think so, Commander Brain from Outer Space! But do we"
21:35:32 <oerjan> @@ @run let w = words (@show @ghc) ++ words (@show @brain); l = length w in unwords . take (l `div` 2) . drop (l `div` 4) $ w
21:35:33 <lambdabot>  "so, Brain, but a codpiece made from a real fish would get"
21:35:40 <oerjan> @ghc
21:35:41 <lambdabot> ghc says: Kind error
21:35:46 <oerjan> @ghc
21:35:46 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
21:37:17 <faxathisia> @@ @run filter (Data.List.isInfixOf "uncomfortable") [(@show @brain),(@show @brain),(@show @brain),(@show @brain),(@show @brain),(@show @brain),(@show @brain),(@show @brain)]
21:37:18 <lambdabot>  []
21:37:31 <oerjan> @@ @run let g = words (@show @ghc); b = words (@show @brain); lg = length g; lb = length b in unwords . take ((lg+lb)`div` 2) . drop (lg `div` 2) $ b ++ g
21:37:33 <lambdabot>  "into giant Swiss leaderhosen-clad dancing yodelers. Talk about"
21:37:40 <omnId> @@ @run concat . concat . transpose $ [words (@show @ghc), words (@show @brain)]
21:37:41 <lambdabot>  "ghcAresays:youmagicponderingnumberwhatmismatch:I'mold/corruptpondering?inte...
21:37:48 <oerjan> @@ @run let g = words (@show @ghc); b = words (@show @brain); lg = length g; lb = length b in unwords . take ((lg+lb)`div` 2) . drop (lg `div` 2) $ g ++ b
21:37:50 <lambdabot>  "in type or class declaration"
21:37:53 <omnId> @@ @run unwords . concat . transpose $ [words (@show @ghc), words (@show @brain)]
21:37:54 <lambdabot>  "ghc Wuh, says: I parse think error so, (possibly Brain, incorrect but inden...
21:38:28 <oerjan> oh wait
21:38:43 <omnId> @@ @run unwords . concat . transpose $ [drop 2 $ words (@show @ghc), words (@show @brain)]
21:38:44 <lambdabot>  "parse I error think (possibly so, incorrect Brain, indentation) but we're a...
21:39:07 <dons> kids these days
21:39:12 <omnId> =)
21:39:24 <puusorsa> ghc should habe that kinda error messages
21:39:32 * omnId likes to play with his toys.
21:39:48 <oerjan> @@ @run let g = words (@show @ghc); b = words (@show @brain); lg = length g; lb = length b in unwords $ take (lb `div` 2) b ++ drop (lg `div` 2) g
21:39:50 <lambdabot>  "Promise me something, not return its parent type"
21:39:55 <Korollary> lol
21:39:57 <omnId> BAHAHAHA
21:40:22 <oerjan> finally :)
21:40:30 <oerjan> @@ @run let g = words (@show @ghc); b = words (@show @brain); lg = length g; lb = length b in unwords $ take (lb `div` 2) b ++ drop (lg `div` 2) g
21:40:31 <lambdabot>  "Now, Pinky, if by any chance you are captured during this mission, remember...
21:40:39 <oerjan> oops
21:40:54 <oerjan> @@ @run let g = words (@show @ghc); b = words (@show @brain); lg = length g; lb = length b in unwords $ take (lb `div` 2) b ++ drop (lg `div` 2) g
21:40:56 <lambdabot>  "I think so, Brain! How much deeper would CAFs unsupported, forcing UPD inst...
21:41:12 <omnId> fscking ROFL.
21:41:35 <faxathisia> @@ @run unwords . reverse . words (@show @vixen)
21:41:36 <lambdabot>  Couldn't match expected type `a -> [a1]'
21:42:01 <oerjan> *lightbulb*
21:42:14 <omnId> faxathisia: parens around the composed function, or $
21:42:21 <faxathisia> @@ @run unwords . reverse . words $ (@show @vixen)
21:42:22 <lambdabot>  "uhuh"
21:42:26 * omnId watches oerjan intently
21:42:45 <omnId> faxathisia: ask vixen something after @vixen
21:45:13 <oerjan> @@ (@read @run let b = words (@show @brain) in unwords.take(length b `div` 2)$b) (@read @run let g = words (@show @ghc) in unwords.drop(length g `div` 2)$g)
21:45:16 <lambdabot>  If I could reach  a2AN} (* -> *) -> * -> *
21:45:39 <oerjan> @@ (@read @run let b = words (@show @brain) in unwords.take(length b `div` 2)$b) (@read @run let g = words (@show @ghc) in unwords.drop(length g `div` 2)$g)
21:45:41 <lambdabot>  I think so, Brain,  brain just exploded.
21:46:01 * omnId dies
21:46:26 <oerjan> um was there any ghc in that?
21:46:34 <oerjan> @@ (@read @run let b = words (@show @brain) in unwords.take(length b `div` 2)$b) (@read @run let g = words (@show @ghc) in unwords.drop(length g `div` 2)$g)
21:46:37 <lambdabot>  I think so, Brain,  cannot construct the infinite type
21:47:35 <omnId> @let halve xs = take (length xs `div` 2) xs
21:47:46 <lambdabot> Defined.
21:49:18 <oerjan> @let evlah xs = drop (length xs `div` 2) xs
21:49:25 <lambdabot> Defined.
21:51:04 <oerjan> @@ (@read @run unwords.halve.words$(@show @brain)) (@read @run unwords.evlah.words$(@show @ghc))
21:51:06 <lambdabot>    CAFs unsupported, forcing UPD instead
21:51:26 <oerjan> @@ (@read @run unwords.halve.words$(@show @brain)) (@read @run unwords.evlah.words$(@show @ghc))
21:51:28 <lambdabot>  I think so, Brain, but isn't  variables) not allowed in instance declarations
21:51:35 <sjanssen> heh
21:51:38 <omnId> I have a wordsWise f = unwords . f . words
21:51:39 <dons> heh
21:52:01 <dons> lambdabot is nuts
21:52:24 <oerjan> @@ (@read @run wordsWise halve (@show @brain)) (@read @run wordsWise evlah (@show @ghc))
21:52:24 <newsham> omni: good name, i've used that often
21:52:26 <lambdabot>  I think so, Brain, but how would  to allow multi-parameter classes
21:52:47 * wli peers.
21:53:23 <oerjan> @@ (@read @run wordsWise halve (@show @keal)) (@read @run wordsWise evlah (@show @yow))
21:53:25 <lambdabot>  can you make a macro that builds the expression accoridng to a  those MODULAR LOVE UNITS??
21:53:53 <oerjan> @@ (@read @run wordsWise halve (@show @keal))(@read @run wordsWise evlah (@show @yow))
21:53:55 <lambdabot>  haskell always your SNOOPY POSTER!!
21:54:14 <omnId> oh god... so much funny...
21:54:37 <faxathisia> haha
21:55:39 <sjanssen> @remember kealyow can you make a macro that builds the expression accoridng to a  those MODULAR LOVE UNITS??
21:55:39 <lambdabot> Nice!
21:55:53 <sjanssen> @remember kealyow haskell always your SNOOPY POSTER!!
21:55:53 <lambdabot> Good to know.
21:55:54 <QtPlatypus> Is there a name for the way python and haskell use whitespace to express code structure?
21:55:56 <sjanssen> @flush
21:56:08 <omnId> QtPlatypus: layout
21:56:10 <wli> Layout.
21:56:49 <omnId> LB needs no more modules.  She is now complete.
21:56:55 <newsham> ?keal
21:56:56 <lambdabot> my proof show math is broken right now
21:58:25 <goalieca> ?goalieca
21:58:25 <lambdabot> Unknown command, try @list
21:58:31 <goalieca> ?quote goalieca
21:58:31 <lambdabot> No quotes match. It can only be attributed to human error.
21:58:35 <goalieca> woohoo
22:00:22 <omnId> @@ (@read @run wordsWise halve @show @quote goalieca)(@read @run wordsWise evlah @show @keal)
22:00:24 <lambdabot>  No quotes match. map gives fpu infinite list?
22:32:36 <dibblego> what files are placed where, when I perform a make install with GHC?
22:49:12 <Zao> dibblego: Lots of them, in wherever you specified as --prefix.
22:49:40 <Zao> dibblego: Some wrapper scripts in bin, lots and lots of libs in lib, some man pages and whatnot too, I suppose.
22:49:44 <dibblego> I've found files in /usr/local/bin and /usr/local/lib
22:50:00 <dibblego> ghc 6.8.1 really screwed me over
22:50:05 <dibblego> I'm trying to start fresh
22:50:33 <Zao> dibblego: If you have the tree around, make install and redirect the output to a file, and mangle that to get a list of files?
22:50:47 <dibblego> yeah I'll try something like that, thanks
22:57:25 <dibblego> every time I try to compile FileManip-0.2 I get Could not find module `System.Directory':
22:57:25 <dibblego>       it is a member of package directory-1.0.0.0, which is hidden
22:57:35 <dibblego> with GHC 6.8.1
22:58:16 <dibblego> what can I do about it?
22:58:25 <sjanssen> add directory to the build-depends
22:58:43 <dibblego> what is build-depends?
22:58:55 <dibblego> you mean, rebuild GHC 6.8.1?
22:59:11 <oerjan> a field in the .cabal file, i think
22:59:17 <sjanssen> dibblego: it's a line in the .cabal file
22:59:43 <dibblego> are you referring to the .cabal file for FileManip?
22:59:49 <geocalc> try "runhaskell Setup build -v"
23:00:12 <sjanssen> dibblego: yes
23:00:39 <hpaste>  dibblego pasted "runhaskell Setup.lhs build -v" at http://hpaste.org/3662
23:01:31 <sjanssen> we're going to need a wiki page for this issue...
23:01:55 <dibblego> that would be good :)
23:02:13 <dibblego> gah, now it's Data.ByteString.Lazy.Char8
23:02:19 <geocalc> remove the hide all package
23:02:41 <dibblego> the what?
23:02:58 <geocalc> the flag
23:03:00 <sjanssen> dibblego: same with bytestring
23:03:11 <dibblego> I added bytestring to build-depends, then it barfed completely
23:03:41 <hpaste>  dibblego pasted "added directory, bytestring" at http://hpaste.org/3663
23:03:58 <dibblego> I might just go back to 6.6.1 if I can
23:04:19 <Zao> sjanssen: 6.8.1 split base a bit, didn't it?
23:04:26 <sjanssen> Zao: that is correct
23:04:57 <Zao> I've run into the reverse, where cabals depended on directory and containers, when I had 6.6.1.
23:05:30 <oerjan> there is a list of which modules went to which new packages in the release notes, i recall
23:06:42 <sjanssen> dibblego: change the first line of System/FilePath/Manip.hs to {-# LANGUAGE FlexibleInstances, TypeSynonymInstances #-}
23:06:57 <sjanssen> dibblego: most Cabal packages will have these issues for a few weeks
23:07:06 <dibblego> righto, I'll try that
23:07:14 <geocalc> copy paste dibblego :: /usr/local/bin/ghc -package-name FileManip-0.2 --make -i -idist/build/autogen -idist/build -i. -Idist/build -odir dist/build -hidir dist/build -stubdir dist/build -package base-3.0.0.0 -package filepath-1.1.0.0 -package mtl-1.1.0.0 -package unix-2.2.0.0 -O -Wall -O2 System.FilePath.Find System.FilePath.Glob System.FilePath.GlobPattern System.FilePath.Manip
23:07:50 <sjanssen> dibblego: if you don't want to spend the time debugging them, you might want to stick with 6.6 for awhile
23:07:56 <sjanssen> geocalc: *very* bad advice
23:08:14 <geocalc> why ?
23:08:38 <sjanssen> geocalc: GHC/Cabal needs the package dependencies to link executables
23:09:01 <sjanssen> the compile and install will go through, but executables that use FileManip won't link correctly
23:09:31 <dibblego> that worked, cheers
23:09:57 <Zao> "worked"
23:10:20 <dibblego> I was able to load a file that uses FileManip into ghci 6.8.1 :)
23:10:35 <geocalc> at #ghc they tell me to remove the flag -hide* so it is bad
23:13:30 <bos> dibblego: i'll update the package soon.
23:13:43 <dibblego> bos, thanks; I must say, it is very well written :)
23:13:43 <bos> i just built the official ghc 6.8.1 for fedora.
23:13:49 <bos> thanks!
23:14:05 <dibblego> all I needed to do was update the .cabal file and add that pragma that sjanssen mentioned
23:14:26 <sjanssen> bos: aww, I was about to send a patch :)
23:14:36 <sjanssen> geocalc: oh, that's advice from #ghc?
23:14:45 <sjanssen> geocalc: it's possible that I'm incorrect
23:14:48 <geocalc> yes
23:15:46 <geocalc> if it worke it lool better your way sjanssen
23:15:57 <geocalc> +e*
23:16:17 <geocalc> look*
23:16:38 <geocalc> bad fingers !!!
23:18:13 <sjanssen> geocalc: OOC, who gave that advice?
23:18:43 <geocalc> i don't remember
23:24:00 <Zao> geocalc: http://www.acc.umu.se/~zao/geocalc.log
23:24:06 <Zao> That conversation?
23:25:46 <geocalc> not sure but if yes i'm surelly crazy Zao
23:26:01 <sjanssen> geocalc: I think you became a bit confused by sorear's obscure explanation :)
23:26:21 <geocalc> mmh
23:27:51 <sjanssen> the best answer to your question, "is there a file where i can expose modules ?" is, "yes, in the build-depends field of the .cabal file"
23:27:56 <sjanssen> ;)
23:29:56 <geocalc> this answer is good sjanssen
23:36:41 <dibblego> ?hoogle (Monad m) => [m a] -> m [a]
23:36:42 <lambdabot> Prelude.head :: [a] -> a
23:36:42 <lambdabot> Prelude.last :: [a] -> a
23:37:24 <dibblego> what's that function again?
23:37:45 <sjanssen> sequence
23:37:49 <dibblego> that's it ta
23:38:04 <b_jonas> @fp \f -> let r = do { f; r; } in r
23:38:04 <lambdabot> \f -> let r = do { f; r; } in r not available
23:38:15 <b_jonas> @pl \f -> let r = do { f; r; } in r
23:38:15 <lambdabot> (line 1, column 18):
23:38:15 <lambdabot> unexpected "{"
23:38:15 <lambdabot> expecting variable, "(", operator, ";" or "in"
23:38:29 <b_jonas> @pl \f -> let r = f >> r in r
23:38:29 <lambdabot> fix . (>>)
23:39:03 <b_jonas> @src fix
23:39:03 <lambdabot> fix f = let x = f x in x
23:39:08 <b_jonas> @i fix
23:39:09 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
23:39:13 <b_jonas> @where fix
23:39:13 <lambdabot> I know nothing about fix.
23:39:20 <b_jonas> @index fix
23:39:20 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
23:39:44 <oerjan> @@ @pl @undo \f -> let r = do { f; r; } in r
23:39:45 <lambdabot>  (line 1, column 12):
23:39:45 <lambdabot> unexpected "{"
23:39:45 <lambdabot> expecting natural, identifier or "in"
23:39:58 <oerjan> huh
23:40:05 <oerjan> @undo \f -> let r = do { f; r; } in r
23:40:05 <lambdabot> \ f -> let { r = f >> r} in r
23:41:22 <dibblego> ?type join
23:41:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:42:49 <b_jonas> @pl \f -> let { r = do { f; r; }; } in r
23:42:49 <lambdabot> (line 1, column 11):
23:42:49 <lambdabot> unexpected "{"
23:42:49 <lambdabot> expecting natural, identifier or "in"
23:43:33 <oerjan>  @pl understands neither { } nor do notation
23:43:53 <oerjan>  @undo can remove do notation but not the { } for the let
23:43:54 <b_jonas> I might just be typing invalid syntax you know
23:44:00 <b_jonas> I'm not good in haskell syntx yet
23:44:18 <oerjan> i'm not sure about the semicolon
23:44:44 <oerjan> in haskell ; is mainly separating, not terminating
23:44:48 <omnId> > let { x = 1; } in x
23:44:50 <lambdabot>  1
23:44:53 <omnId> empty decl.
23:45:09 <oerjan> > do { return [] ; }
23:45:10 <lambdabot>   add an instance declaration for (Show (t [a]))
23:45:19 <oerjan> > do { [] ; }
23:45:20 <lambdabot>  []
23:45:33 <oerjan> ok so they are both allowed
23:46:06 <oerjan> but anyway if you want @pl to understand, remove the { } around let, which are redundant in let in anyhow
23:46:33 <oerjan> @@ @pl @undo \f -> let  r = do { f; r; } in r
23:46:33 <lambdabot>  (line 1, column 12):
23:46:33 <lambdabot> unexpected "{"
23:46:33 <lambdabot> expecting natural, identifier or "in"
23:46:43 <oerjan> gah
23:46:49 <oerjan> @undo \f -> let  r = do { f; r; } in r
23:46:49 <lambdabot> \ f -> let { r = f >> r} in r
23:46:56 <glguy> how do I start building ghc using the existing ghc-inplace
23:47:01 <glguy> instead of recreating it
23:47:04 <oerjan> ok it's worse than that, @undo actually but it _in_
23:49:02 <b_jonas> pardon?
23:49:25 <oerjan> the {}'s in the let
23:49:43 <oerjan> er, what?
23:50:56 <b_jonas> I can't parse "@undo actually but it _in_"
23:51:23 <oerjan> eh, *put
23:51:50 <oerjan> s/but/put/
23:52:01 <b_jonas> but the {} around the let were there, just invisible. it's expanded the do.
23:52:16 <b_jonas> @undo \f -> let { r = do { f; r; } in r
23:52:16 <lambdabot>  Parse error at "in" (column 30)
23:52:19 <b_jonas> @undo \f -> let { r = do { f; r; }; } in r
23:52:19 <lambdabot> \ f -> let { r = f >> r} in r
23:52:23 <oerjan> yes.  the problem is @pl doesn't understand {}
23:52:37 <b_jonas> wtf
23:52:43 <b_jonas> @pl \ f -> let { r = f >> r} in r
23:52:44 <lambdabot> (line 1, column 12):
23:52:44 <lambdabot> unexpected "{"
23:52:44 <lambdabot> expecting natural, identifier or "in"
23:52:58 <b_jonas> I thought it just didn't understand "do"
23:53:02 <oerjan> it has a very strange parser
23:53:03 <b_jonas> this is stupid from it
23:53:08 <oerjan> not that either
23:53:26 <b_jonas> well, weird at least
23:53:32 <b_jonas> it has to have a custom parser of course
23:56:15 <b_jonas> anyway, I thought this ErrorT stuff over this night
23:56:20 <b_jonas> and I think I understand it now
23:56:30 <b_jonas> It also helped me understand a bit more of monads.
23:59:08 <dmwit> ?pl \f -> let r = f >> r in r
23:59:09 <lambdabot> fix . (>>)
23:59:47 <dibblego> do some people prefer to use >>=  (or >> or whatever) over do-notation?
