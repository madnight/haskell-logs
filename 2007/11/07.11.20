00:00:32 <dons> tuples are special
00:01:10 <osfameron> "special", yeah...
00:02:04 <osfameron> I was just trying to write something prettier than (\s -> (s,r)), no biggy
00:02:46 <sclv>  @pl \s -> (s,r)
00:03:13 <sclv> flip (,) r
00:03:34 <osfameron> oo, of course, currying instead of sectioning
00:03:36 <osfameron> ta
00:14:36 <lokadin_> what is the = called in Haskell?
00:14:48 <dmwit> bind
00:15:00 <dmwit> or maybe "equals" ;-)
00:15:06 <lokadin_> the one that is between function and function definition
00:15:24 <lokadin_> function arg1 arg2 = arg1 * arg2
00:15:34 <lokadin_> that equal sign
00:15:55 <lokadin_> it's the same as a dot in lambda calculus
00:16:06 <lokadin_> i think anyways
00:16:28 <dmwit> Yes, Haskell is very close to the lambda calculus.
00:16:38 <dmwit> Well... it's close to the typed lambda calculus. =)
00:17:23 <lokadin_> hmmm
00:17:35 <lokadin_> kk well i was making a language of my own
00:17:35 <lokadin_> just figuring stuff out
00:20:18 <hpaste>  osfameron pasted "getPrefixMap" at http://hpaste.org/3988
00:20:39 * osfameron was quite pleased at how this came together - the prelude's list functions are really very cute
00:22:59 * osfameron waits for someone to show how this can be done as a one-liner...
00:24:27 <ivanm> osfameron: getPrefixes could possibly be made as one long big ugly let-based one-liner...
00:24:28 <ivanm> :p
00:24:55 <osfameron> oh, I can write ugly code by myself :-)
00:25:00 <ivanm> :D
00:25:43 <lekro> > flip map [0..100] (fst . randomR (0,2) . mkStdGen)
00:25:43 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
00:25:48 <lekro> why do I only get 2 here?
00:28:11 <doserj> lekro: because you are always using the same stdgen
00:28:26 <lekro> am I?
00:28:46 <lekro> I thought that's what mkStdGen is for
00:29:18 <opqdonut> > nub $ flip map [0,256..65536] (fst . randomR (0,2) . mkStdGen)
00:29:20 <lambdabot>  [2,1]
00:29:35 <lekro> (I'm not actually calling mkStdGen that often, I'm trying to locate my error better)
00:29:40 <opqdonut> 0..100 is way too little entropy
00:29:45 <doserj> oh
00:33:05 <lekro> opqdonut: I also get only 2's for 0..1000. But my problem seems to be something else because I don't call mkStdGen that often
00:33:23 <hpaste>  qwzybug pasted "Type error I don't understand" at http://hpaste.org/3989
00:33:38 <opqdonut> lekro: newStdGen is much better than using custom seeds
00:33:43 <qwzybug> I don't see why I'm getting a type error on that paste, if anyone wants to help out a super-noob
00:33:45 <opqdonut> unless you need reproducibility
00:33:55 <lekro> opqdonut: I need reproducibility
00:34:13 <opqdonut> ok
00:36:43 <doserj> qwzybug: try it without the type signature for lev. maybe the error msg is clearer then.
00:36:54 <qwzybug> mmm, good idea
00:37:29 <doserj> basically, the type you claim for lev is simply wrong. lev cannot be typed at all in Haskell, because the type of the result depends on the input n
00:37:38 <qwzybug> doserj: it's still expecting to return [[a]] instead of [a]...
00:37:43 <qwzybug> hmm, that's interesting.
00:38:12 <qwzybug> but when I do the recursion 'by hand' in the interpreter, it's perfectly alright (for example, powerset (powerset []))
00:38:41 <doserj> for each n, it can be given a seperate type, yes. But they are all different
00:39:01 <qwzybug> I guess I can see that.
00:39:26 <skew> how are you planning to use the results?
00:39:27 <qwzybug> can I define a type recursively for it, as say Froth, which could be either an empty list or a list of froth?
00:39:29 <doserj> your type signature claims that lev can return a list of a's, for any a.
00:39:58 <doserj> but it can only return [[[..[[a]]..]]]
00:39:59 <skew> qwzybug: yes, and you should probably even define it uniformly
00:40:10 <qwzybug> skew: I'm tinkering around with modeling the iterative conception of list (a la Boolos or Godel) in code... haskell seemed like a good fit for it
00:40:27 <skew> Powerlist l = Here l | Higher (Powerlist [l])
00:40:39 <qwzybug> doserj: can I write types like that? :)
00:40:57 <qwzybug> (wups, iterative conception of set above)
00:41:10 <qwzybug> hmm, I think I see what that's doing
00:53:22 <mcp_> is it possible to use options '|' in a where clause?
00:53:46 <sciolizer> yes. But why don't you just try it. :)
00:54:04 <mcp_> sciolizer, i get a compiler error and try to figure out why
00:54:11 <sciolizer> @hpaste
00:54:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:55:40 <mcp_> sciolizer, thx, but i dont want this list to save all of my problems (you save most of them though).
00:56:34 <sciolizer> ha ha. Does the compiler say it's a syntax error. I thought I was certain that you could use options '|' in a where clause but now I'm not so sure. And I'm finding out the hard way by browsing the Haskell 98 report. :)
00:58:34 <ivanm> I think it is...
00:58:39 <ivanm> depends how...
00:59:12 <hpaste>  (anonymous) pasted "yes it's possible to use options '|' in a where clause" at http://hpaste.org/3990
01:03:43 <ski> lokadin_ : `equals' or `is equal to'
01:04:04 <hpaste>  mcp_ pasted "i give up. Do you see an error here?" at http://hpaste.org/3991
01:04:35 <mcp_> the compiler says Syntax error in declaration (unexpected `}', possibly due to bad layout)
01:04:42 <mcp_> doesnt really help i think
01:04:55 <opqdonut> nested where clauses i'd say
01:04:58 <opqdonut> you don't need them
01:05:22 <opqdonut> you can define incNodes in the same where-blovk
01:05:26 <mcp_> can i just put tem into one where clause? in a specific order?
01:05:33 <mcp_> incNodes first?
01:05:38 <opqdonut> order doesn't matter
01:06:03 <ski> the `|' should be more indented than the preceding `nodes'
01:06:19 <mcp_> yes, that whas the problem. nesete where does not work. thx
01:06:35 <ski> (the nested `where's should be ok, i think)
01:07:03 <opqdonut> > let a = b; b = 1:a in take 5 a  -- all definitions from a let or where block are available right from the start of the block, enabling (mutually) recursive defs like this
01:07:05 <lambdabot>  [1,1,1,1,1]
01:07:13 <sciolizer> This may be separate, but what's with the length(incNodes) and the head(incNodes)?
01:07:47 <ski> you also have a close paren missing at the last line
01:09:18 <hpaste>  (anonymous) annotated "i give up. Do you see an error here?" with "(no title)" at http://hpaste.org/3991#a1
01:09:25 <mcp_> ski, that was a pase accident.
01:09:43 <ski> (ok)
01:12:25 <Sizur> if i want to show an Int in a specific base, i need to use the internal showIntAtBase?
01:12:52 <Sizur> or is there another show for that?
01:13:22 <matthew-_> am I right in thinking that ghc converts programs to some form of lambda calculus before doing the "rest" of the work?
01:13:53 <opqdonut> yeah, lambda calculus with lets iirc
01:14:16 <matthew-_> is there some way that I can get ghc to dump that representation out?
01:14:30 <wli> There's core, then there's System F_c. Everything at every stage is dumpable AIUI.
01:14:37 <matthew-_> cool.
01:14:48 <matthew-_> yeah, I thought it was some variant of System F
01:16:18 <matthew-_> presumeably at that point only FFI calls are magic - everything else should be expandable?
01:16:32 <skew> I think most of the interesting optimizations happen in Core, rewrite rules and the simplifier and stuff like that
01:17:18 <matthew-_> yeah I don't care about the optimisations at the moment. I'm just thinking about where to stick type system extensions
01:17:52 <therp> on the way from Haskell->Core
01:18:31 <therp> I guess an extension would have to involve type inference, type checking and desugaring.
01:18:47 <therp> these steps happen before Core.
01:19:51 <matthew-_> right. but academically, it would be defined on Î»-calc and then that would offer a reasonable route in
01:21:56 <quicksilver> Sizur: I don't think showIntAtBase is 'internal'
01:22:17 <quicksilver> matthew-_: if your type system extension is expressible in System Fc, then you apply it before you get to core
01:22:29 <quicksilver> matthew-_: if it's not expressible in Fc you're going to have to change Core...
01:23:18 <matthew-_> quicksilver: thanks for the clarification. Fc is before Core right?
01:23:41 <matthew-_> maybe I should actually just read the ghc wiki rather that irritating you lot with dumb questions...
01:26:34 <Sizur> quicksilver:  thanks. just that for standard base representation, i still need to define the extended digits and append empty string to showIntAtBase
01:26:48 <bakert> does the ((->) r) monad have a more pronounceable name?
01:27:01 <skew> Reader r
01:27:12 <skew> up to isomorphism
01:28:03 <sieni> what's wrong with left-parenthesis-left-parenthesis-dash-bigger-than-right-parenthesis-r-right-parenthesis-monad?
01:28:24 <quicksilver> matthew-_: Fc is core, roughly
01:28:53 <quicksilver> bakert: 'reader' or 'environment'
01:31:22 <ketil> Morning!
01:31:43 <ketil> Does GHC heap profiling still have a problem accounting for arrays?
01:32:09 <ketil> I run out of memory (+RTS -M3500M) but the heap profile only shows 250Mb in use.
01:33:02 <ketil> Makes things kinda hard to debug....
01:33:29 <skew> man, somebody needs to teach Coq about local type inference, and updating the environment with information from dependent pattern matches
01:33:36 <ski> (bakert : `r'-environment)
01:33:49 <bakert> tks
01:34:17 <ski> (also `Reader r' as skew said)
01:52:04 * wli thinks about side effects while watching an emerge world spin.
01:53:03 <wli> In C, the struggle with side effects seems to be centered largely around handling failures esp. IO failures, and propagating error returns.
01:53:11 <ketil> JaffaCake, arrays are now (heap-) profiled correctly, yes?
01:53:28 <ketil> ("now" meaning 6.8.1)
01:53:31 <JaffaCake> I think so, yes
01:53:57 <ketil> I'm running out of memory, but the -hd profile shows only 250Mb in use.  Puzzled.
01:54:00 <wli> I think there's an issue with propagating IO error returns.
01:54:19 <osfameron> wli: also with action at a distance with global state
01:54:26 * ketil has to run, but will be back later.
01:54:46 <JaffaCake> ketil: sounds strange, we should investigate
01:55:02 <wli> osfameron: That one doesn't translate much to Haskell, but the error returns from IO are an issue with library design.
01:57:46 <goalieca> how does the gc factor into this?
01:58:20 <wli> goalieca: Not 100% sure. It looks like it's not easily possible to isolate allocations within IO monads so error returns are possible.
01:59:36 <wli> goalieca: Maybe in some idealized fantasy world memory allocations could always be pushed to where IO forces them so they'd appear as IO errors.
02:00:27 <goalieca> can haskell do mmap?
02:00:49 <goalieca> it would seem counter to everything if it could
02:01:03 <wli> goalieca: It can be done directly as a library affair AIUI (basically Ptr allocation etc.).
02:01:47 <osfameron> wli: yeah, I guess error handling is something that's often less smooth than it should be
02:02:47 <opqdonut> how ugly is returning data with "hidden" unique ids from a pure function (via unsafePerformIO mkUnique)
02:03:25 <opqdonut> handling this "properly" would add IO to my monad stack which is complex enough already
02:04:54 <wli> osfameron: I think the real problem with fixing the base libraries' IO error handling is that it basically wants the MTL.
02:05:08 <wli> osfameron: And it's far from backward-compatible.
02:05:33 <osfameron> so haskell-prime is a good opportunity to fix that and the number classes and the unary-minus handling and other various warts ?
02:05:40 <quicksilver> opqdonut: someone made a very interesting post about that some months back
02:05:48 <opqdonut> oh?
02:06:14 <opqdonut> i could just encapsulate accessing the id so that the api presented is pure
02:06:26 <wli> osfameron: Not at all. Haskell' is a conservative, mostly-backward-compatible extension. This would be radical, i.e. the diametric opposite of conservative.
02:07:06 <opqdonut> the ids are needed only for an Ord instance needed for keeping the data in a Set
02:07:38 <osfameron> wli: ah, ok.  I had the idea that ' wasn't 100% concerned with backwards compatibility, not read up much about it.
02:10:04 <wli> osfameron: Your impression is somewhat right but its spirit is far from revolutionary AIUI. I suspect more info as to what Haskell' is about might help here.
02:10:34 <quicksilver> opqdonut: quick search through my -cafe archives and I can't find it :( can't remember the right keyword, sorry.
02:10:45 <opqdonut> can you summarize?
02:12:05 <opqdonut> maybe i could pass around the sets instead of "raw" data, that would probably hide the Ord instance sufficiently
02:12:32 <wli> osfameron: The Haskell' wiki I think says a good bit here.
02:15:49 <wli> osfameron: It also looks like the issues are largely decided.
02:16:15 <osfameron> wli: got an url?
02:16:36 <wli> osfameron: The Future of Haskell link from the haskell.org homepage
02:16:51 <wli> osfameron: Then from there, go to the Haskell' wiki.
02:16:58 <osfameron> wli: thanks
02:17:43 <wli> osfameron: Huge caveat: I'm not involved with it in any way. I don't know anything about it personally other than what I can dredge up off the web.
02:19:10 <Taejo> @src maximum
02:19:10 <lambdabot> maximum [] = undefined
02:19:10 <lambdabot> maximum xs = foldl1 max xs
02:20:46 <wli> I wish I had minions.
02:21:08 <opqdonut> Mui. Japsu
02:21:15 <Japsu> Mui. opqdonut
02:22:53 <osfameron> mmm, minions...
02:24:53 * opqdonut reporting in
02:25:01 <Japsu> ;D
02:25:21 <sieni> moshi moshi
02:25:29 <wli> I'd like a minion to restore monad comprehensions. ;)
02:25:46 <opqdonut> and make (.) fmap while he's at it?
02:26:23 <wli> (.) as fmap is not as important because it doesn't require compiler intrinsics support.
02:26:49 <ketil> JaffaCake, I used -i5, so it's possible it allocated tons of memory in a short time, perhaps?  Running a smaller data set now with default -i, but of course, gv takes about a week to render it...
02:27:02 <wli> Basically the type of a comprehension comes about from the desugaring.
02:27:16 <JaffaCake> ketil: ok
02:27:39 <wli> As things now stand, the desugaring yields a monomorphic type constructor (the list type constructor).
02:28:39 <wli> Restoring monad comprehensions would desugar it so the type constructor is Monad m => m
02:28:45 <hpaste>  ketil pasted "suspected memory gobbler" at http://hpaste.org/3993
02:29:22 <wli> This is actually a bit nastier than one would expect. The code is floating around compiler/deSugar/ somewhere.
02:29:48 <ketil> (That's just the current suspect, I'm still waiting for gv to render a graph that hopefully will point to the real culprit.  If anybody sees any obvious badness with the pasted code, feel free to holler)
02:30:16 <wli> The trick here is that one has to undo certain tricks done specially for lists and the "collateral damage" extends beyond the file in compiler/deSugar/
02:30:27 <wli> opqdonut: Still with me?
02:31:36 <opqdonut> yeah
02:32:11 <opqdonut> aren't those the normal arguments against monad comprehensions: complexity and poor performance
02:32:21 <wli> It also seems (to me) that one has to bring back Monad0 in order to bring back monad comprehensions, though it's not entirely obvious if the fail method in Monad suffices somehow.
02:32:39 <wli> Or, rather, could suffice somehow.
02:32:55 <skew> or if you even want to do that!
02:33:07 <wli> opqdonut: It has to be optional to fly.
02:33:31 <skew> It's annoying to have to define fail for everything
02:34:09 <quicksilver> wli: surely you can use fail?
02:34:36 <wli> opqdonut: No clue if it performs poorly. Complexity of implementation is a very different thing from complexity of use. Also, all the "complexity" here is mostly an artifact of having to unravel assumptions that have crept in all over.
02:34:48 <quicksilver> wli: desugar a boolean guard to if foo then return () else fail "oops"
02:35:04 <wli> quicksilver: Sounds plausible.
02:36:29 <quicksilver> wli: I mean, personally I'd prefer Monad0, obviously :)
02:36:37 <quicksilver> but I think you can use fail
02:37:32 <opqdonut> Monad0 defined mzero?
02:37:41 <wli> It defined zero
02:37:50 <opqdonut> ahhh
02:38:02 <wli> Since renamed to mzero and inappropriately shoved into MonadPlus
02:38:10 <wli> Whose mplus used to be (++)
02:38:25 <opqdonut> yes
02:38:36 <opqdonut> monadplus is ugly i have to admit
02:38:51 <opqdonut> (so is Monoid grrrr)
02:38:55 <wli> Erase the scars of H98.
02:40:26 <quicksilver> I think maybe I'd prefer (++) to be mappend than mplus
02:40:43 <quicksilver> I think I'm more often aware of using Monoids than MonadPlusses
02:41:17 <doserj> but that#s not compatible with Data.List.++
02:42:31 <doserj> or do you want sth. like instance MonadPlus m => Monoid (m a)?
02:42:50 <opqdonut> of course it is
02:42:54 <opqdonut> mappend for list is (++)
02:43:13 <doserj> mappend for list is a kind error
02:43:17 <opqdonut> the point is having monadplus m and monoid (m a) different monoids
02:43:29 <opqdonut> > [1,2] `mappend` [3]
02:43:31 <lambdabot>  [1,2,3]
02:43:37 <opqdonut> > [1,2] `mplus` [3]
02:43:37 <lambdabot>  [1,2,3]
02:44:51 <quicksilver> doserj: sure it is. Data.List.++ is one of my favourite monoids :)
02:45:15 <idnar> :t mappend
02:45:16 <lambdabot> forall a. (Monoid a) => a -> a -> a
02:48:11 <opqdonut> why oh why can't the monoid operation be a nice short infix
02:48:24 <byorgey> opqdonut: hear, hear!
02:48:42 <quicksilver> opqdonut: right. that's what we were saying :)
02:49:22 <doserj> import Prelude hiding ((+)) ; let (+) = mappend ; class Monoid a => Num a where ...-- *cough*
02:49:27 <b_jonas> opqdonut: why, you can define one
02:49:56 <b_jonas> you can even try, like
02:50:33 <b_jonas> (%%) = mplus
02:50:35 <b_jonas> or something
02:50:42 <b_jonas> um, mappend
02:50:46 <opqdonut> yeah i was thinking of (+) but that would make it unlike (*) in a not-very-nice way
02:51:00 <b_jonas> only, of course, you ahve ot use mappend in instances
02:51:14 <opqdonut> of course having scoped instances or instance selection would let us have (Num,+) and (Num,*) monoids
02:51:27 <quicksilver> yes
02:51:45 <b_jonas> opqdonut: well, there's Sum and Product newtypes for that
02:52:06 <opqdonut> yeah i know
02:52:20 <mux> they ain't very convenient to use
02:52:31 <visof> hello
02:52:34 <b_jonas> yeah, because you have to extract them
02:52:49 <byorgey> hi visof
02:53:10 <b_jonas> you can of course locally hide any operator to use it as an alias to mappend
02:53:46 <mux> > appEndo (Endo (+1) `mappend` Endo (+2)) 3
02:53:47 <lambdabot>  6
02:54:08 <quicksilver> 'appEndo' sounds like a harry potter spell
02:54:12 <visof> now i run programs in console mode , i want to make interface for my programs with Haskell
02:54:13 <mux> heh
02:54:18 <visof> how can i make that?
02:54:48 <b_jonas> > appSum (((+1) `mappend` (+2)) (Sum 3))
02:54:49 <lambdabot>   Not in scope: `appSum'
02:55:07 <b_jonas> > getSum (((+1) `mappend` (+2)) (Sum 3))
02:55:07 <lambdabot>   add an instance declaration for (Num (Sum a))
02:55:22 <b_jonas> hmm
02:55:37 <b_jonas> > getSum (((`mappend` 1) `mappend` (`mappend` 2)) (Sum 3))
02:55:38 <lambdabot>   add an instance declaration for (Num (Sum a))
02:55:39 <byorgey> @where gtk2hs
02:55:39 <lambdabot> http://haskell.org/gtk2hs/
02:55:44 <byorgey> visof: try that? ^^
02:55:56 <visof> ok
02:55:57 <mux> > getSum (Sum 3 `mappend` Sum 2) 3
02:55:59 <b_jonas> > getSum (((mappend (Sum 1)) `mappend` (mappend (Sum 2))) (Sum 3))
02:56:07 <lambdabot>   add an instance declaration for (Num (t -> a))
02:56:08 <lambdabot>  9
02:56:12 <mux> > getSum (Sum 3 `mappend` Sum 2)
02:56:12 <lambdabot>  5
02:56:48 <b_jonas> but teh best one is
02:56:51 <b_jonas> > mappend ()()
02:56:52 <lambdabot>  ()
02:57:15 <byorgey> @remember quicksilver 'appEndo' sounds like a harry potter spell
02:57:15 <lambdabot> Done.
02:57:17 <b_jonas> anyway, what's Monoid useful for, really?
02:57:19 <mux> > getSum (mconcat . map Sum $ [1,2,3,4])
02:57:25 <lambdabot>  10
02:58:08 <visof> byorgey after i install this library, what do i do?
02:58:20 <b_jonas> for example, instead of
02:58:22 <byorgey> visof: I don't know, I've never used it.  read the documentation.
02:58:30 <b_jonas> > Sum 3 `monoid` Sum 7
02:58:30 <lambdabot>   Not in scope: `monoid'
02:58:30 <visof> ok
02:58:39 <b_jonas> > Sum 3 `mappend` Sum 7
02:58:39 <lambdabot>  Sum {getSum = 10}
02:58:42 <b_jonas> isn't it easier to
02:58:51 <b_jonas> > (3+) . (7+)
02:58:51 <lambdabot>  <Integer -> Integer>
02:59:04 <b_jonas> there you represent a number as (n+) instead of (Sum n)
02:59:16 <b_jonas> and that works for any monoid obviously
02:59:38 <mux> I don' think Sum or Product are of any real use, but it would be lame not to have them if we have a Monoid type-class :-)
02:59:42 <byorgey> @go finger trees
02:59:44 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
02:59:44 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
02:59:49 <byorgey> b_jonas: for an example of a nice use of the Monoid class, see that paper.
03:00:13 <b_jonas> ok, will look
03:01:07 <byorgey> each node in the fingertree gets annotated with a 'measure' or 'cost' that is a Monoid.  by instantiating it with different monoid instances, different behavior is obtained.
03:01:32 <byorgey> something like that, it's been a while since I read it
03:01:56 <b_jonas> cost? isn't this normal 2-3 trees?
03:02:11 * b_jonas reads
03:02:46 <b_jonas> I also have to read http://birrell.org/andrew/papers/ImplementingCVs.pdf because I really want to know now how condition variables are implemented
03:05:08 <ddvlad> is it me or is it just a pain to install haskell-related things on gentoo?
03:05:54 <ddvlad> i mean, 6.6 is marked testing, 6.8 is in an overlay, all 6.6-related things are also testing (and i don't want to use ~x86 globally)
03:06:47 <ski> (mayhaps #gentoo-haskell can provide answers ?)
03:07:06 <ddvlad> hmm... didn't know about them
03:09:33 * wli didn't notice anything special happening. It looked to me like the usual distros-are-downrev affair.
03:10:16 <ddvlad> i was thinking of giving debian a try. gentoo has more and more problems with portage
03:10:20 <b_jonas> I'm lazy to read all that
03:10:32 <b_jonas> it seems like one of those tricky self-organizing trees
03:10:35 <b_jonas> sorry
03:10:39 <wli> ddvlad: I don't see 6.8 at all.
03:11:10 <ddvlad> wli: i tried to, but packages were missing or broken. i know i barely installed xmonad using 6.6
03:11:28 <ddvlad> (but don't have the time to learn enough to make the switch from wmii)
03:11:37 <wli> ddvlad: I don't see xmonad at all.
03:11:57 <ddvlad> i think it's only in the haskell overlay
03:12:11 <wli> ddvlad: I've never heard of overlays.
03:12:18 <ddvlad> sorry, i read "I don't use" insead of "I don't see"
03:12:49 <ddvlad> wli: i'm not much of an expert myself, but basically they're collections of very unstable or topic-specific packages
03:13:20 <ddvlad> emerge layman and then run layman -a haskell, but be warned that i've had misc troubles when using it
03:13:28 <wli> Okay.
03:13:42 <ddvlad> (of course, that's just one account -- it's nice that gentoo is trying)
03:14:04 <byorgey> b_jonas: you can probably skip to the part where they talk about Monoid.  but in any case, it doesn't matter to me whether you read it or not. =)
03:14:27 <wli> layman -a haskell gives me a nonexistence error.
03:14:40 <b_jonas> I rather continue writing this interpreter thingy
03:14:44 <osfameron> heh, Vox swallows another code comment...
03:14:57 <b_jonas> how do you spell intercalate
03:16:00 <b_jonas> ah, apparently that's a new addittion
03:16:06 <Sizur> noob question: how to make m a -> b -> m (a,b)
03:16:35 <quicksilver> Sizur: foo ma b = do a <- ma; return (a,b)
03:16:43 <ddvlad> wli: i think you first have to update the list. just a moment
03:16:59 <Sizur> quicksilver: does it work is m is IO?
03:17:01 <Sizur> if*
03:17:11 <roconnor> @type liftM (,)
03:17:12 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> (a1, b))
03:17:18 <quicksilver> Sizur: there are neat/ugly pointfree versions but that shows the pattern
03:17:24 <quicksilver> Sizur: yes, that works for any monad
03:18:05 <ddvlad> wli: http://gentoo-wiki.com/Portage_Overlay_Listing#Introduction should get things started -- i know that's what helped me
03:18:06 <quicksilver> Sizur: do notation is precisely the language of operations you can do in any monad.
03:18:06 <lambdabot> Title: Portage Overlay Listing - Gentoo Linux Wiki
03:19:17 <roconnor> @type liftM . (,)
03:19:19 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m (a, a1)
03:19:37 <roconnor> @type flip (liftM . (flip (,)))
03:19:38 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> a1 -> m (a, a1)
03:21:30 <Sizur> roconnor: thanks :) still not familiar with lift's
03:21:46 <quicksilver> Sizur: I would recommend the do/return version personally :)
03:21:58 * roconnor also recommends do/return
03:22:14 <Sizur> quicksilver: yeah i understand the do notation. lifts will come in handy later with reactive programming
03:22:26 * quicksilver shrugs
03:22:38 <quicksilver> lifts are never anything more or less than 'short'hand
03:22:42 <quicksilver> and they're not necessarily short
03:22:50 <quicksilver> especially when flips get mixed in
03:22:56 <Sizur> ok
03:23:32 <roconnor> @type flip (fmap . (flip (,)))
03:23:33 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => f a -> a1 -> f (a, a1)
03:24:15 <Sizur> but IO is not a Functor :P
03:24:26 <quicksilver> :t \ma b -> (,) <$> ma <*> pure b
03:24:27 <lambdabot>     Ambiguous occurrence `pure'
03:24:27 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
03:24:27 <lambdabot>                           or `pure', imported from Control.Arrow
03:24:37 <quicksilver> Sizur: guess again!
03:24:45 <quicksilver> :t \ma b -> (,) <$> ma <*> Control.Applicative.pure b
03:24:46 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> a1 -> f (a, a1)
03:24:58 <quicksilver> ^^ that's applicative notation for the same thing.
03:25:01 <wli> instance MonadError IOError IO might be nice.
03:25:01 <Sizur> Monad and a Functor
03:25:07 <quicksilver> Sizur: all monads are functors
03:25:12 <quicksilver> Sizur: and, all monads are applicatives.
03:25:54 <Sizur> Monad does not inherit Functor in the standard, right?
03:25:57 <quicksilver> no
03:26:04 <wli> A better-thought-out error handling infrastructure in general.
03:26:08 <quicksilver> a fact which annoys many people
03:26:23 <Sizur> but it separates the concepts, and that's good
03:26:46 <Sizur> you can have a Monad without it being a Functor, or is that braking the Monad definition?
03:27:10 <Sizur> not according to monadic laws as i remember reading
03:27:51 <quicksilver> Sizur: you can't, no
03:27:53 <skew> A Monad must be a functor
03:28:02 <skew> mathematically, if not in the Haskell type classes
03:28:03 <quicksilver> Sizur: Functor follows from Monad (and so do the Functor laws)
03:28:14 <quicksilver> Sizur: you define fmap = liftM
03:28:19 <Sizur> ok :)
03:28:22 <quicksilver> Sizur: and you find the functor laws follow from the monad laws
03:29:35 <wli> I'd define liftM = fmap, but never mind that.
03:29:50 <wli> Another scar of H98; fmap used to be just map.
03:32:51 <firefly> can anybody help me understand the machine code that ghc generates?
03:33:42 <wli> Maybe it'd be easier to hack hugs' intrinsics.
03:33:50 <skew> firefly: why?
03:34:32 <firefly> curiosity + it will probably help me internalize a better performance model for haskell.
03:34:48 <skew> oh, then you probably want to read some of the implementation papers
03:34:54 <wli> quicksilver: Functor logically precedes Monad AFAICT.
03:35:08 <wli> quicksilver: Basically the Functor laws are a subset of those of Monad.
03:35:38 <skew> I think dons actually looks at the assembly for performance sometimes...
03:36:05 <firefly> that's what I thought.  I even think I saw a blog post of his about it but I can't seem to find it now.
03:36:12 <wli> quicksilver: So fmap = liftM is truly backward.
03:36:51 <quicksilver> wli: I do agree :)
03:37:03 <quicksilver> wli: I was only explaining to Sizur how to "prove" that all monads are functors
03:37:29 <skew> hmm, there used to be some links to papers about GHC
03:38:36 <firefly> there are plenty, not least on SPJ's homepage -- but to what degree are they still relevant?  besides, many of them don't go all the way down to assembly.
03:39:02 <skew> most are still pretty much relevant
03:40:49 <skew> high-level optimizations are really important
03:40:59 <skew> like the specilializer and rewrite rules
03:41:48 <firefly> I looked at a executable for a small parser I wrote with Parsec and many of the entry points were called XXXX_info -- and I have no idea what the intention behind is or what the code does.  The machine code is /really/ strange.
03:41:48 <wli> I think ghc is getting so good that the only things in its way are the low-level optimizations.
03:42:06 <skew> Between "Haskell on a shared-memory multiprocessor" and "Faster laziness using dynamic pointer tagging" you ought to be able to work out most of the ideas - oh, the developer wiki has some good runtime stuff too
03:42:17 <firefly> (a_n_ executable, of course.  I am not an American!)
03:42:39 <wli> This is probably not an entirely accurate characterization but anyhow.
03:42:51 <skew> yeah, the machine code will be pretty strange. Those are the info tables, which point *after* important metadata about functions, and right into the entry code
03:43:03 <firefly> How much of "The Spineless tagless G-machine" is still relevant?
03:43:10 <skew> almost all of it
03:43:21 <firefly> good!
03:43:35 <skew> but modified a bit
03:43:58 <skew> the SMP stuff adds another header word, pointer tagging plays around with the code pointer
03:44:27 <skew> the thesis stuff might have been written way back when they were using "push-enter"
03:45:02 <skew> If you get that level of organiziation the machine code might start to make sense
03:45:54 <b_jonas> I'm wondering on how to represent functions in this interpreter
03:45:57 <firefly> Good!  I've just downloaded "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine Version 2.5"
03:46:13 <skew> All sorts of things like the FFI, weak pointers, the garbage collector, etc are pretty much orthogonal to the organization of plain Haskell code
03:46:25 <b_jonas> there are primitive functions and composite functions built from other functions and stuff
03:47:08 <firefly> sure.
03:47:30 <b_jonas> I'm wondering if it's worth to separate primitives and complex functions
03:48:13 <firefly> I just want to have a fighting chance of mapping a piece of machine code back to the source code :)
03:48:36 <b_jonas> because for primitive functions (of which there are some fifty) I have to store all data anyway in some way, so it might be worth to store all of it in them
03:48:53 <skew> you will of course need to use -ddump-simpl and read core
03:48:55 <b_jonas> but for composite functions, I'm not sure it's worth that
03:49:14 <skew> supposedly at some stage it actually corresponds pretty closely to machine code, but I forget how that goes
03:49:19 <b_jonas> otoh, as haskell is lazy, it might not be so bad
03:49:41 <firefly> sure.  I have looked a little bit at the core stuff but not much yet.
03:49:44 <skew> like there are some sorts of local lambdas that turn into jumps to basic blocks, lets become memory allocations, etc.
03:49:55 <firefly> sure.
03:50:00 <b_jonas> hmm
03:50:34 <firefly> I have the ML Kit tech reports on the shelf and I have read Compiling with Continuations.
03:50:56 <firefly> Shouldn't be too hard to get the haskell stuff, too, once I know where to start :)
03:53:04 <wli> If you do a CPS transform, then strict vs. lazy is less of an issue, no?
03:53:48 <opqdonut> that's how i've understood it, yes
03:54:03 <pejo> b_jonas, isn't primitive operations strict?
03:54:49 <cbrad> I seeing GHC 6.8.1 produce different results depending on whether I use -O2 or not
03:55:14 <cbrad> just posted an example to the haskell-cafe
03:55:17 <cbrad> http://article.gmane.org/gmane.comp.lang.haskell.cafe/31942
03:55:18 <lambdabot> Title: Gmane -- Mail To News And Back Again
03:55:46 <pejo> firefly, are you trying to read stuff output from some intermediate debugging format in ghc, or do you want to know how lazy evaluation works?
03:56:00 <firefly> I want to make a fast compiler ;)
03:56:08 <b_jonas> pejo: they're strict
03:56:08 <pejo> firefly, for a lazy language?
03:56:22 <b_jonas> but they have some meta-data stuff
03:56:36 <b_jonas> I'll use a data that has multiple fields
03:56:36 <firefly> no, for X++, an awful object-oriented language used in Microsoft Dynamics AX
03:56:50 <pejo> b_jonas, oh, your concern was about the meta-data stuff carried aroudn in the interpreter?
03:56:53 <b_jonas> of which the most important is a haskell function that tells what the function does exactly
03:56:56 <b_jonas> pejo: yes
03:57:03 <b_jonas> but it's not that bad,
03:57:06 <firefly> (previously called Axapta, from Navision, before Microsoft bought them)
03:57:19 <b_jonas> because the meta-data is only about three fields (the exact number might change later)
03:57:20 <firefly> And before the fusion, Damgaard Data A/S.
03:57:33 <b_jonas> and they can be filled out lazily
03:57:37 <firefly> It's a Danish company/Microsoft subsidiary.
03:57:59 <b_jonas> btw, should I call the monad I'm working in Outcome or Action or what?
03:58:04 <firefly> The product is for largish companies to keep track of their inventory, sales, work in progress, accounts, you name it.
03:58:10 <pejo> Bummer. Another meeting. Sorry, bbl.
03:58:20 <firefly> I figured it would be fun to have a go at it :)
03:58:33 <b_jonas> it's ErrorT Ball (StateT ... IO)
03:58:50 <b_jonas> the tyle of the state var I'll have to name later
04:00:12 <b_jonas> oh, I hate naming things
04:00:16 <b_jonas> it's so difficult
04:00:45 <wli> I still don't understand the STG machine well enough to implement it in C.
04:00:57 <wli> I could probably do the pj-lester-book machines, though.
04:03:42 <hpaste>  Gtewasd pasted "replica coach handbags and purses" at http://hpaste.org/3995
04:04:04 <wli> Feh, Coach. I stick to Dolce & Gabbana.
04:05:24 <wli> One thing I don't get is how constructors get assigned numeric values for use in low-level representations.
04:08:39 <wli> It seems like you have to do it globally, which doesn't play well with separate compilation.
04:10:12 <ttfh> I think haskell is slowly ruining my life, when I work(as in get paid) with other languages it's just not inspiring anymore
04:13:23 <doserj> quit you job, start a business using Haskell, solve the software crisis, get rich. Inspired now? :)
04:15:12 <ttfh> doserj: Oh, I didn't think of that, thank you :-)
04:15:28 <wli> If I were to start a business, software would probably be rather tangential to it (though present in some form).
04:16:08 <ttfh> quit your job: easy
04:16:19 <ttfh> start a business: doable
04:16:31 <ttfh> solve the software crisis: ?
04:18:09 <ttfh> actually the idea has entered my mind before(starting a business, not solving the software crisis), but I think business is about selling stuff more than anything, and since I'm not good at selling stuff, I don't think I'd do very well
04:19:26 <matthew_-> this ghc api thing doesn't make ghc pluggable does it? It's just allowing me to programmatically call ghc right?
04:20:09 <ttfh> (Even if I was a brilliant programmer, which I'm not)
04:21:12 <wli> My thought on business is that it's mostly vacuuming up the proceeds of state intervention on behalf of the wealthy. In an economically declining region/nation/etc., that mostly means internal policing against "social unrest," such as people who inspire other people to vote the wrong way etc.
04:21:57 <wli> So some sort of data mining and/or data analysis affair to smoke out Leftists would be the business model I'd shoot for.
04:22:11 <hpaste>  sizur pasted "polymorphic cli args parser" at http://hpaste.org/3996
04:22:16 <geocalc> ttfh=<< solve the software crisis is simple : do a programming bot
04:23:23 <ricky_clarkson> Hit the power button, and go and learn plumbing.
04:23:34 <SamB_XP> some people actually manage to part the wealthy from some of their money *honestly*
04:24:02 <geocalc> money money ...
04:24:23 <Itkovian> How does one split a list into pieces of size k, preferably in a single line statement?
04:24:37 <wli> SamB_XP: Behind every great fortune is a great crime.
04:24:40 <Itkovian> e.g., [1..9] -> [1,2,3] ,[ 4,5,6],[7,8,9]
04:25:22 <geocalc> Itkovian=<< look yesterday log
04:25:30 <Itkovian> thx
04:25:49 <wli> Itkovian: \n -> takeWhile (not . null) . iterate (take n)
04:25:55 <ricky_clarkson> @hoogle [a] -> Integer -> [[a]]
04:25:55 <lambdabot> No matches, try a more general search
04:26:13 <sciolizer> @type splitAt
04:26:14 <lambdabot> forall a. Int -> [a] -> ([a], [a])
04:26:26 <doserj> \n ->  takeWhile (not . null) . unfoldr (Just . splitAt n)
04:26:39 <Itkovian> thx all
04:26:51 <SamB_XP> wli: what is that supposed to do?
04:28:24 <ricky_clarkson> @hoogle [a] -> Int -> [[a]]
04:28:24 <lambdabot> No matches, try a more general search
04:28:51 <ricky_clarkson> Oh, I misread splitAt.
04:40:04 <quicksilver> wli: I think you mean takeWhile (not.nul) . map (take n) . iterate (drop n)
04:40:25 <wli> Point.
04:41:15 <firefly> I think these GHC Hackathon 2006 videos are useful for understanding how ghc compiles:
04:41:16 <firefly> http://hackage.haskell.org/trac/ghc/wiki/AboutVideos
04:41:18 <lambdabot> Title: AboutVideos - GHC - Trac
04:41:26 <bakert> is there any way to make lambdabot do a ?pl that only removes the last arg?
04:41:42 <bakert> (removing both is pretty incomprehensible in this particular case)
04:41:47 <quicksilver> bakert: in some cases, you can not make the other arguments arguments
04:41:50 <quicksilver> just make them names
04:41:54 <firefly> The paper "The Glasgow Haskell compiler: a technical overview" also seems useful, despite being old (1992).
04:41:58 <quicksilver> bakert: otherwise, learn to to it yourself :P
04:42:07 <SamB_XP> ... 15 years old?
04:42:08 <bakert> this is me teaching myself! :)
04:43:00 <firefly> And this page about C--: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
04:43:02 <lambdabot> Title: Commentary/Compiler/CmmType - GHC - Trac, http://tinyurl.com/3xlar9
04:43:05 <quicksilver> @pl \a -> foo b c (g a) d
04:43:05 <lambdabot> flip (foo b c . g) d
04:43:05 <bakert> quicksilver: when you say make them names, what do you mean? :)
04:43:10 <quicksilver> bakert: that's what I mean
04:43:14 <bakert> ah thanks!
04:43:19 <quicksilver> bakert: do you see, I didn't make b,c,d arguments
04:43:25 <quicksilver> bakert: so @pl left them alone
04:43:25 <bakert> got it
04:43:27 <firefly> ghc seems to use C-- as the last intermediate language so at least some part of the older papers are outdated.
04:43:58 <SamB_XP> firefly: there have been many changes in the past 15 years, I'm sure ;-)
04:44:01 <bakert> ah yes that's much better.  thanks quicksilver!!!
04:44:02 <osfameron> @index (><)
04:44:07 <SamB_XP> though perhaps less than I would expect
04:44:08 <lambdabot> Data.Graph.Inductive.Query.Monad, Data.Graph.Inductive.Query, Data.Graph.Inductive
04:44:11 <resiak> @index ^__^
04:44:12 <lambdabot> bzzt
04:44:15 <resiak> :(
04:44:28 <firefly> Absolutely!  I'm throwing the links in here so that others can google them from the IRC logs.
04:45:17 <SamB_XP> I think probably the IRC logs don't google well anymore now that they bombproofed google?
04:47:26 <bakert> ?pl (\x -> (f x) && (g x))
04:47:26 <lambdabot> liftM2 (&&) f g
04:48:45 <doserj> unfortunately, f `liftM2 (&&)` g doesn't work :)
04:49:18 <bakert> oh hello i am in the channel.  oops.  i thought i was chatting to lambdabot!
04:50:18 <bakert> i am slowly coming round to the idea of liftM2 and the reader r monad
04:51:07 <bakert> my brain has nearly stretched far enough :)
04:51:31 <SamB_XP> bakert: heh. you weren't spammy or anything
04:52:14 <doserj> bakert: you now how in maths people define (f+g)(x) := f(x) + g(x)?
04:52:54 <bakert> doserj: not a maths whizz, unfortunately, but that makes sense
04:53:15 <SamB_XP> maths can get away with so much ad-hoc stuff
04:53:23 <doserj> that is exactly what liftM2 formalizes
04:53:41 <doserj> (in the reader monad)
04:54:01 <bakert> i think one thing i am not getting is how the reader monad is there
04:54:03 <SamB_XP> > liftM2 (+) sin cos 1
04:54:04 <lambdabot>  1.3817732906760363
04:54:15 <bakert> is it just implicit in everything somehow?
04:54:20 <SamB_XP> bakert: it's the ((->) r) version
04:54:41 <doserj> bakert: the type inference algorithm finds out that it can only be the reader monad
04:54:51 <bakert> so reader r is implied by the presence of -> in the type sig?
04:54:57 <bakert> ???
04:55:04 <SamB_XP> @instances MonadReader
04:55:05 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
04:55:40 <SamB_XP> most of those just lift MonadReader through a T...
04:55:41 <bakert> so the use of liftM2 tells the compiler that there is some monady shenanigans going on
04:55:51 <doserj> @type liftM2
04:55:51 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:55:57 <bakert> and it looks at what i've handed it and says well you must mean reader r?
04:56:00 <SamB_XP> bakert: well, monady stuff
04:56:51 <SamB_XP> bakert: what did you hand it?
04:57:05 <bakert> (&&) f g
04:57:07 <bakert> :)
04:57:11 <SamB_XP> ah.
04:57:21 <SamB_XP> what are f and g?
04:57:34 <bakert> -> Bool
04:57:39 <bakert> :)
04:57:43 <SamB_XP> well... yeah....
04:58:09 <bakert> liftM2 (&&) f g
04:58:11 <SamB_XP> @type liftM2 (&&) odd (<10)
04:58:11 <lambdabot> forall a. (Integral a) => a -> Bool
04:58:14 <bakert> seems to be enough info on it's own
04:58:20 <bakert> for ?pl to work out what's what
04:58:23 <SamB_XP> lits see...
04:58:30 <SamB_XP> @type odd
04:58:31 <lambdabot> forall a. (Integral a) => a -> Bool
04:59:35 <doserj> bakert: you didn't give f g to @pl. you gave \x -> (f x) && (g x) to @pl. so pl can see, that f, g must be functions
04:59:43 <bakert> oh yeah
04:59:44 <bakert> oop
04:59:46 <bakert> !
04:59:52 <SamB_XP> well, it figures out that you are using the ((->) r) monad when it tries to unify "m a1" with "(Integral a) => a -> Bool"
04:59:59 <bakert> the liftM2 stuff was the output of ?pl
05:00:23 <SamB_XP> the typechecker, I mean
05:00:44 <doserj> @type \f g -> liftM2 (&&) f g
05:00:44 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
05:00:54 <doserj> here we don't know the monad yet
05:01:12 <bakert> i see
05:01:14 <bakert> so something in
05:01:21 <SamB_XP> of course, that "m a1" isn't precisely what the typechecker actually deals in... but I'm not sure if what it does deal in can be displayed...
05:01:22 <bakert> \x -> f x &&
05:01:28 <bakert> *scratch that ^^
05:01:38 <SamB_XP> anyway...
05:01:51 <bakert> something in (\x -> (f x) && (g x)) implies the reader monad?
05:01:58 <SamB_XP> bakert: no
05:02:01 <bakert> oh
05:02:11 <Botje> unifying m a with Int -> Bool does
05:02:18 <Botje> it binds a to Bool and m to Int ->
05:02:50 <SamB_XP> bakert: pl just knows that there is an instance Monad (r ->) (neglecting the invalidity of this syntax)
05:03:21 <bakert> ok.  so (anything ->) or ((->) r) in the proper syntax is always an instead of the reader monad.
05:03:34 <bakert> so any time i use a -> i am using the reader monad implicitly?
05:03:35 <SamB_XP> bakert: hmm?
05:03:44 <bakert> s/instead/instance/g
05:03:46 <bakert> :(
05:03:58 <quicksilver> bakert: only if you use something with a monadic type signature
05:04:00 <Botje> no, only when you apply monadic functions to "normal" functions
05:04:02 <SamB_XP> bakert: well... I wouldn't say that you were USING the monad
05:04:02 <quicksilver> bakert: it's like this:
05:04:17 <quicksilver> when you use something like 'liftM2' or do notation, or sequence, or mapM
05:04:23 <quicksilver> you tell the compiler you're using a Monad
05:04:32 <SamB_XP> but you use types that can be considered monadic every time you use a function, yes...
05:04:33 <quicksilver> when it actually generates code, it tries to decide which monad
05:04:36 <quicksilver> so it looks at the type
05:04:43 <quicksilver> if the type is IO a, then it's the IO monad!
05:04:54 <quicksilver> if the type is a -> b, it's the (->) r monad
05:05:01 <quicksilver> if the type is [a], it's the list monad
05:05:01 <quicksilver> etc
05:05:02 <SamB_XP> the (->) a monad
05:05:08 <quicksilver> indeed ;)
05:05:18 <SamB_XP> keep your variables straight ;-P
05:05:38 <bakert> so the reader stuff only happens in my code /because/ i use liftM2.  it's not there lurking ready to be used.
05:05:52 <bakert> i actually bring it in by including a call to liftM2
05:06:02 <SamB_XP> bakert: well. defining "lurking"
05:06:04 <bakert> but i can do this any time.  so it is kind of "latent"
05:06:05 <SamB_XP> er./
05:06:08 <SamB_XP> *define
05:06:40 <bakert> latent but not lurking!  i mean, the bind function of the reader monad for example never gets called implicitly unless i do something like liftM2
05:06:55 <quicksilver> bakert: indeed not
05:07:06 <quicksilver> bakert: the bind function gets called excatly when you tell it to get called
05:07:10 <bakert> but i could chuck all sorts of code at liftM2 and it would work out from types that i meant the reader monad (if i do)
05:07:17 <quicksilver> bakert: e.g. by using a function which is defined in terms of bind
05:07:23 <quicksilver> (liftM2 could be defined in terms of bind)
05:07:28 <bakert> so that's what i mean by it kind of being latent
05:07:41 <SamB> bakert: well, remember that (r ->) is not the same as Reader r ;-)
05:08:00 <bakert> did this kind of stuff take you guys ages to get or are you all mathematicians where there are equivalents?
05:08:38 <SamB> it didn't take me ages to understand the ((->) r) monad
05:08:38 <bakert> don't get me wrong, i like it.  it is stretching my brain.  but it's weird after such a long time of programming to feel so clueless!!!
05:08:56 <SamB> but I still have trouble working out exactly what is going on when it is used, often
05:09:02 <quicksilver> I think you're struggling more with the nature of typeclasses and overloading
05:09:08 <bakert> that is possible
05:09:11 <quicksilver> than anything to do with moands or reader
05:09:23 <quicksilver> typeclasses permit the compiler to choose which code to run based on the type
05:09:26 <bakert> i have only slightly used typeclasses in my own code.  which is a sign it isn't fully ingrained yet.
05:09:35 <quicksilver> so it chooses to run reader code when it sees ->, IO code when it sees IO, etc
05:09:47 <SamB> I struggled with monads until I gave up trying to say what a monad is ;-P
05:09:48 <quicksilver> Monad is perhaps slightly more confusing because it's "higher kinded"
05:09:59 <quicksilver> I.e. [] is a monad, but [] isn't a type
05:10:07 <quicksilver> [Int] is a type
05:10:10 <SamB> that reminds me...
05:10:27 <araujo> bakert, you only need an advanced pdh to understand monads
05:10:33 <SamB> I really want to be able to call :kind on typeclasses ;-)
05:10:33 <araujo> :-)
05:10:44 <bakert> yes, IO i just about get but [] as a monad makes me realize i have a way to go with monads
05:10:57 <araujo> hah
05:11:04 <bakert> i should probably try and remember what the other operations than bind are for monads
05:11:12 <bakert> so i can think about what each might be for []
05:11:19 <SamB> return
05:11:21 <bakert> (or just look it up and try and understand)
05:11:27 <bakert> oh yes return, and something else?
05:11:33 <araujo> bakert, well, i think the best is to understand monads abstractly in theory
05:11:37 <SamB> join
05:11:49 <quicksilver> it is just return and bind, needed to define one
05:11:59 <quicksilver> but personally I find return and join easier to understand
05:12:06 <quicksilver> (you can define join from bind or bind from join)
05:12:13 <bakert> i have a vague sense of bind.  what is join?
05:12:32 <SamB> unfortunately Haskell doesn't handle this for you :-(
05:12:38 <SamB> @type join
05:12:38 <araujo> bakert, monads are very abstract, but that's what helps to use them in many ways.
05:12:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:13:17 * osfameron keeps on wondering if bakert is a monad transformer...
05:13:17 <lambdabot> osfameron: You have 1 new message. '/msg lambdabot @messages' to read it.
05:13:23 <quicksilver> > join [[1,2,3],[4,5,6],[7]]
05:13:25 <lambdabot>  [1,2,3,4,5,6,7]
05:13:36 <quicksilver> bakert: ^^ I find that example explains join...
05:14:02 <opqdonut> > sequence [[1,2,3],[4,5,6],[7]]
05:14:04 <lambdabot>  [[1,4,7],[1,5,7],[1,6,7],[2,4,7],[2,5,7],[2,6,7],[3,4,7],[3,5,7],[3,6,7]]
05:14:45 <bakert> quicksilver: that seems very obvious, in the context of lists.  but what can it mean for say the reader monad to have a join?
05:14:45 <osfameron> doserj: ah, thanks, I had a feeling I'd get those the wrong way around...
05:15:02 <bakert> osfameron: that joke is almost to haskelly for me to get :)
05:15:32 <quicksilver> bakert: well m (m a) for the reader monad is r -> r -> a
05:15:37 <osfameron> bakert: yeah, me neither.  It just reminded me of classes I've seen (but don't know how to use) like ReaderT etc.
05:15:38 <opqdonut> ?src join
05:15:43 <lambdabot> join x =  x >>= id
05:15:43 <quicksilver> bakert: join says "use the same value of 'r' in both places"
05:15:49 <SamB> hooray
05:15:54 <opqdonut> > join (+) $ 2
05:16:04 <lambdabot>  4
05:16:15 <SamB> all the GHC tickets that I've made are closed, except the ones where I've been too vague ;-)
05:16:58 <bakert> i thought join had a different definition for each monad?  not one definition?
05:17:08 <bakert> oh iseee
05:17:16 <bakert> the different definitions of bind will see to that
05:17:29 <SamB> sometimes it would be nice to define join instead of bind
05:20:04 <EvilRanter> wouldn't you need something else as well as join and return?
05:20:19 <SamB> why?
05:20:22 <SamB> @type join
05:20:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:20:28 <SamB> @type return
05:20:28 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:20:35 <EvilRanter> m >>= f = ???
05:20:42 <SamB> @type (>>=)
05:20:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:20:56 <idnar> @type join . return
05:20:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
05:21:01 <idnar> @type return . join
05:21:02 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
05:21:08 <EvilRanter> i think you'd need ap or fmap as well
05:21:11 <idnar> er.
05:21:16 <idnar> nevermind me
05:21:20 <SamB> @djinn bind :: (m (m a) -> m a) -> (a -> m a) -> m a -> (a -> m b) -> m b
05:21:20 <lambdabot> Cannot parse command
05:21:20 <idnar> @type fmap
05:21:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:21:41 <SamB> @djinn (m (m a) -> m a) -> (a -> m a) -> m a -> (a -> m b) -> m b
05:21:42 <lambdabot> -- f cannot be realized.
05:21:48 <SamB> hmm
05:21:49 <EvilRanter> i don't think @djinn does monads
05:22:02 <idnar> wouldn't join go with fmap, not return?
05:22:05 <SamB> oh.
05:22:06 <EvilRanter> @list djinn
05:22:06 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
05:22:09 <SamB> was that how it worked?
05:22:10 <EvilRanter> @djinn-env
05:22:10 <lambdabot> data () = ()
05:22:10 <lambdabot> data Either a b = Left a | Right b
05:22:10 <lambdabot> data Maybe a = Nothing | Just a
05:22:10 <lambdabot> data Bool = False | True
05:22:10 <lambdabot> data Void
05:22:13 <lambdabot> type Not x = x -> Void
05:22:15 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:22:17 <doserj> @djinn can't do higher-kinded types
05:22:17 <lambdabot> Cannot parse command
05:22:24 <EvilRanter> hehe
05:22:38 <SamB> @djinn ((a -> b) -> (m a -> m b)) -> (m (m a) -> m a) -> (a -> m a) -> m a -> (a -> m b) -> m b
05:22:38 <lambdabot> -- f cannot be realized.
05:22:40 <EvilRanter> @type (fmap, join)
05:22:41 <lambdabot> forall a b (f :: * -> *) (m :: * -> *) a1. (Functor f, Monad m) => ((a -> b) -> f a -> f b, m (m a1) -> m a1)
05:23:27 <SamB> @djinn (a -> m a) -> ((a -> b) -> (m a -> m b)) -> (m (m a) -> m a) -> (a -> m a) -> m a -> (a -> m b) -> m b
05:23:27 <lambdabot> -- f cannot be realized.
05:23:34 <SamB> okay, I give up then
05:23:56 <EvilRanter> @type \x -> fmap (const x) undefined -- here's return, i guess
05:23:57 <lambdabot> forall a (f :: * -> *). (Functor f) => a -> f a
05:24:03 <quicksilver> djinn doesn't have any rules for monads
05:24:24 <EvilRanter> @type \m f -> join (fmap f m) -- and bind (?)
05:24:24 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
05:24:48 <quicksilver> EvilRanter: no, fmap (const x) undefined is not likely to be a good choice for return :)
05:24:49 <EvilRanter> ?type ap
05:24:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:24:59 <EvilRanter> quicksilver, i thought it seemed unlikely
05:25:22 <EvilRanter> the normal alternative to return+bind is return+join+ap, iirc...
05:25:51 <bakert> ?src ap
05:25:51 <lambdabot> ap = liftM2 id
05:26:06 <bakert> so you'd need to redefine that?
05:26:25 <quicksilver> EvilRanter: return + join + fmap, surely?
05:26:33 <EvilRanter> is it fmap? i can never remember
05:26:34 <quicksilver> you don't need ap
05:26:48 <quicksilver> from a maths point of view it makes sense to assume fmap
05:26:55 <quicksilver> since these things are 'obviously' functors
05:27:52 <EvilRanter> true... anyway, you could move join+fmap into the Monad class with their current defs as defaults, and give (>>=) the appropriate default def in terms of them, and then you could choose which to define yourself
05:28:03 <bakert> I have: data Foo = Bar | Baz | Quux.  I also have: f Bar = "Hi"; f Baz = "Hullo"; f Quux = "Yo"
05:28:22 <resiak> Why is (>>=) :: m a -> (a -> m b) -> b used rather than some other operator :: (a -> m b) -> (b -> m c) -> (a -> m c) as bind?
05:28:27 <bakert> what's the right way to ensure that every constructor of Foo has a corresponding f entry?
05:28:54 <opqdonut> bakert: quickcheck?-)
05:29:04 <opqdonut> doesn't that generate a warning in ghc?
05:29:08 <quicksilver> bakert: there is a warnin for incomplete pattern matches
05:29:09 <opqdonut> or am i misremembering
05:29:12 <EvilRanter> resiak, blame maths, iirc
05:29:30 <quicksilver> resiak: because >>= is what you want!
05:29:34 <EvilRanter> although the operator you mention exists in ghc 6.8; it's called >=>
05:29:40 <bakert> aha.  cool.  so how i've done it is right.  i don't need typeclasses or anything like that that it don't understand properly yet?  great!
05:29:56 <resiak> EvilRanter: right
05:30:00 <quicksilver> getLine >>= (\a -> putStrLn $ "You wrote " ++ a)
05:30:17 <bakert> EvilRanter: colloquy just turned whatever you typed into a little demon char that i've never seen before (like it does with smileys) -- was that intentional????
05:30:34 <EvilRanter> hm... >>= is definable in terms of >=>, isn't it?
05:30:38 <EvilRanter> bakert, it most definitely wasn't
05:30:39 <resiak> quicksilver: sure, but it seems like IO is unusual in that there are lots of :: IO a actions
05:30:44 <resiak> EvilRanter: sure, and vice-versa
05:30:56 <EvilRanter> bakert, &gt;=&gt;
05:30:59 <quicksilver> resiak: I find that typical rather than unusual :)
05:31:00 <resiak> Bird uses >=> (but he spells it <> IIRC) in Intro to FP
05:31:15 <resiak> quicksilver: but but it's not very pointless!
05:31:16 <quicksilver> resiak: but, basicaly >>= is what do-notation is
05:31:21 <resiak> sure
05:31:22 <quicksilver> that's the reason
05:31:27 <bakert> EvilRanter: that is cool.  i may define all known smileys as interesting haskell functions.  when i get better at haskell
05:31:44 <resiak> but when i'm not using do notation I seem to want >=> more often.  maybe i should just use do notation more :)
05:31:48 <EvilRanter> unfortunately, a lot of 'em use ()s (or []s)
05:33:02 <osfameron> @src (>=>)
05:33:02 <lambdabot> Source not found. Are you on drugs?
05:33:08 <bakert> (\o/) = ...
05:33:12 <bakert> :)
05:34:23 <bakert> interestingly for my non-exhaustive patterns i get no error unless i hit a case where it is not there when i get an exception.  is that because i am using runhaskell and not compiling?
05:35:09 <bakert> hmmm no
05:35:18 <bakert> if i build a binary with cabal i get no warning either
05:35:36 <bakert> perhaps i do need quickcheck
05:35:47 <bakert> unless there is some way to make the compiler look for incomplete patterns?
05:35:58 <Taejo> bakert, isn't -fwarn-incomplete-patterns what you want?
05:36:06 <bakert> sounds good :)
05:36:19 <bakert> i'm sort of surprised that isn't on by default
05:36:52 <bakert> is there some "treat warnings as errors and warn me about everything" type setting i can use?
05:37:06 <doserj> -Wall -Werror
05:37:39 <bakert> thanks
05:38:52 <bakert> doserj: wow that's cool.  my program is completely broken and i never knew :)
05:39:28 <doserj> beware what you ask for, you might get it :)
05:39:47 <bakert> this is going to insist on a type signature for every function, isn't it?
05:39:56 <bakert> i guess that some people would actually consider that /bad/ style?
05:40:01 <bakert> or maybe not?
05:41:11 <bakert> although the fact that there is a function in my code that i cannot begin to work out the type signature for is a little alarming.
05:41:24 <bakert> that will teach me for embracing functional references ...
05:41:39 <doserj> ghc should tell you the type for it, doesn't it?
05:42:38 <quicksilver> bakert: I am one of those who urges caution in type signaturing everything
05:42:50 <quicksilver> bakert: sometimes your type signature is not as abstract as you want
05:43:04 <quicksilver> and writing it down gives you one more thing to change, if you refactor
05:44:02 <EvilRanter> OTOH, it may encourage you to revise your design into a better-factored form, so the types *are* all appropriately abstract
05:44:57 <quicksilver> in some cases
05:45:06 <EvilRanter> indeed. "may".
05:48:46 <Taejo> what is the default stack size in ghci?
05:51:05 <bakert> doserj: yes, it does - thanks.  i need to use ghci more.
05:52:19 <bakert> right, one file in to converting my program to -Wall -Werror i've decided that type signaturing everything is definitely a no-no.
05:55:00 <bakert> ?docs ghc
05:55:00 <lambdabot> ghc not available
06:21:28 <Inspico> Hi :)
06:22:32 <swiert> hi Inspico
06:24:38 <b_jonas> If I define a function that recognizes keywords in string form like 'f "if" = KwIf; f "while" = KwWhile; f "def" = KwDef;'..., can I hope that the haskell compiler will optimize that better than just a linear search?
06:25:26 <Botje> don't get your hopes up :)
06:25:27 <DRMacIver> I would expect it to.
06:25:30 <matthew_-> no.
06:25:36 <DRMacIver> But obviously I'm wrong. :(
06:25:49 <matthew_-> it's just a straight patternmatch
06:25:52 <Botje> b_jonas: you could stick them in a Map or Trie
06:26:00 <Botje> and the have f do a lookup there
06:26:09 <DRMacIver> matthew_-: Yes, but I would expect a sensible compiler to compile straight pattern matches to decision trees...
06:26:16 <Botje> although optimizing string pattern matches in the compiler would be nice
06:26:21 <b_jonas> Botje: which Trie?
06:26:27 <Botje> b_jonas: Data.Trie? :p
06:26:40 <Botje> I believe that's the one I used some time back
06:26:43 <b_jonas> @doc Data.Trie
06:26:44 <lambdabot> Data.Trie not available
06:26:49 <matthew_-> DRMacIver: a) order's important. b) it doesn't know they're mutually exclusive except in some cases
06:27:09 <matthew_-> although none of that prevents what you're suggesting :)
06:27:12 <b_jonas> not here: http://haskell.org/ghc/docs/latest/html/libraries/index.html
06:27:18 <b_jonas> anyway, I'll use a map then
06:27:19 <DRMacIver> matthew_-: I didn't say it was trivial. :)
06:27:29 <Botje> very odd
06:27:31 <Botje> oh well
06:27:34 <Botje> a map is good too
06:28:49 <quicksilver> b_jonas: don't bother
06:28:54 <quicksilver> b_jonas: linear search is faster :P
06:29:08 <b_jonas> quicksilver: I'm recognizing J primitives
06:29:11 <quicksilver> (presumably your language doesn't have 100,000 or more distinct keywords?)
06:29:14 <b_jonas> which are mostly punctation
06:29:24 <b_jonas> it has about 100 such punctation thingies
06:29:25 <Botje> bah
06:29:42 <Botje> b_jonas: you've been reading my mind, haven't you? I was thinking of implementing J in haskell yesterday :p
06:29:57 <dcoutts_> quicksilver: have you ever seen lolcode? it's getting more and more distinct multi-word keywords :-)
06:29:58 <b_jonas> which all have the form [[:punct:]][.:]*|[[:alpha:]][.:]+
06:30:05 <quicksilver> b_jonas: I seriously doubt that pattern match would turn out to be too slow...
06:30:10 <matthew_-> I don't know of the language "haskell yesterday" :p
06:30:34 <b_jonas> quicksilver: ok
06:30:42 <b_jonas> now I don't know which one of you to listen to
06:31:02 <matthew_-> he who shouts the loudest
06:31:13 <quicksilver> b_jonas: you are prematurely optimising. don't.
06:31:24 <quicksilver> in the first instance, optimise for ease of program-writing
06:31:27 <quicksilver> your time is more important.
06:31:36 <b_jonas> quicksilver: on the other hand, a pattern match would lead to code duplication:
06:31:48 <quicksilver> Only optimise for runtime once you have identified something which runs too slowly.
06:31:54 <b_jonas> primitiveLookup "$" = Just VerbShape;
06:31:59 <b_jonas> primitiveLookup "+" = Just VerbAdd;
06:32:01 <b_jonas> all those Justs
06:32:06 <b_jonas> because obviously there has to be a
06:32:17 <b_jonas> primitiveLookup _ = Nothing
06:32:18 <b_jonas> at the end
06:32:21 * quicksilver nods
06:32:22 <matthew_-> you could stick the Just on the front and then join
06:32:32 <matthew_-> err, no. that's wrong.
06:32:36 * matthew_- sits down again
06:32:37 <quicksilver> b_jonas: I'd probably write
06:33:01 <quicksilver> primitiveLookup k = lookup k [("$",VerbShape),
06:33:08 <quicksilver> ("+",VerbAdd")
06:33:10 <quicksilver> ....
06:33:25 <b_jonas> @info lookup
06:33:25 <lambdabot> lookup
06:33:25 <quicksilver> well without that stray quote :)
06:33:34 <b_jonas> damn useful
06:33:39 <quicksilver> b_jonas: lookup looks up into assoc-lists
06:33:51 <b_jonas> now that must be good
06:33:54 <quicksilver> then, if it ever was too slow, you could just change
06:33:58 <b_jonas> because it's surely implemented in a fast way
06:34:02 <b_jonas> I mean, it can build a map
06:34:05 <quicksilver> no, it can't
06:34:11 <quicksilver> because that would require an Ord constraint :)
06:34:16 <quicksilver> it's linear search
06:34:21 <quicksilver> but really, linear search isn't so bad
06:34:22 <quicksilver> !
06:34:32 <quicksilver> if it ever does become too slow, it's easy to fix
06:34:34 <b_jonas> ok
06:34:52 <b_jonas> and after all, I should be calling that function rarely
06:34:59 <quicksilver> primitiveLookup k = let l = Map.fromList [("$",VerbShape)....]
06:35:04 <quicksilver> in Map.lookup k l
06:35:28 <quicksilver> so you go from assoc-lists to maps with just an extra 1 line or code, or so.
06:35:28 <b_jonas> because in most practicaly code, I'll only look up primitives only once in any code
06:35:42 <DRMacIver> quicksilver: Surely that way of doing it is the worst of all possible worlds? :)
06:35:55 <DRMacIver> quicksilver: Because you're doing a linear scan to build a map to look up from each time you call the method...
06:36:10 <DRMacIver> (i.e. l isn't shared between invocations because it's not at the top level)
06:36:31 <quicksilver> DRMacIver: bah, typo
06:36:42 <quicksilver> primitiveLookup = let l = Map.fromList [....]
06:36:48 <quicksilver> in \k -> Map.lookup k l
06:36:57 <quicksilver> and now l is shared, as I intended :)
06:37:03 <DRMacIver> Hm
06:37:13 <DRMacIver> Ah, yes.
06:37:22 <DRMacIver> I was wondering for a second why that was the case, but I see now
06:37:23 <quicksilver> good point, though
06:37:24 <b_jonas> ok, I'll use lookup from List then
06:38:08 <mauke> isn't ghc smart enough to float l to the top?
06:38:25 <quicksilver> mauke: I don't believe so, no
06:38:34 <quicksilver> mauke: isn't that the much maligned "full laziness transform?"
06:38:37 <b_jonas> mauke: that's what I asked last time, and they said no
06:38:42 <mauke> :(
06:38:43 <quicksilver> ISTR there are reasons why you wouldn't want to do it
06:38:51 <quicksilver> but I don't know what they are
06:38:54 <b_jonas> they replied with some mail that said there was some bad interaction with lazyness
06:38:58 <mauke> would a where binding be any different?
06:39:05 <b_jonas> that it could in some cases increase runtime
06:39:15 <b_jonas> or memory useage, I can't remember
06:39:20 <b_jonas> the point is that it's not done
06:39:27 <DRMacIver> Memory usage.
06:39:28 <quicksilver> mauke: I would imagine not. where is just sugar for let
06:40:12 <DRMacIver> The idea is that if you have a large datastructure and two expressions which use it, one might thunk a lot more of the datastructure than the other while being much shorter lived.
06:40:45 <DRMacIver> But the sharing would prevent the large amount of unneeded thunked data from being garbage collected
06:40:58 <DRMacIver> Or something like that. :)
07:15:09 <sw17ch> is there a good way to "show" a function?
07:16:11 <mauke> no
07:16:20 <sw17ch> is there a bad way?
07:16:26 <ricky_clarkson> > (+1)==(+1)
07:16:27 <lambdabot>   add an instance declaration for (Eq (a -> a))
07:16:27 <lambdabot>     In the expression: ((+ 1)...
07:17:49 <byorgey> sw17ch: sure.  instance Show (a->b) where show f = "func"
07:18:19 <byorgey> sw17ch: =)  seriously though, there is a way to just show the type of the function using Data.Typeable, let me see if I can find it...
07:18:49 <sw17ch> I forget why I was even asking this... but now i'm curious
07:20:43 <quicksilver> the problem is that Show means (at least) two things
07:21:03 <quicksilver> on the one hand it is a inefficient but practical serialisation format
07:21:08 <quicksilver> and on the other hand, it's a debugging aid
07:21:13 <sw17ch> ah! that's what it was
07:21:15 <quicksilver> those are not entirely aligned
07:21:18 <sw17ch> serialization of functions =)
07:21:43 <quicksilver> if you're trying to serialise, then writing Show for arbitrary a->b is not possible
07:21:50 <quicksilver> if you're just trying to get debug info
07:21:53 <quicksilver> then showing the type seems sane
07:22:34 <sw17ch> ah, alright. I was just thinking that if you could serialize functions, it would make for some really interesting "plugin" methods
07:22:59 <b_jonas> there's the Text.Show.Functions module
07:23:17 <b_jonas> but it doesn't really show functions
07:23:56 <sw17ch> ah, alright. well, time for class... thanks for the answers
07:24:03 <b_jonas> I use it to show algebraic data with functions inside
07:27:05 <mauke> What's yellow, and equivalent to the Axiom of Choice?
07:27:26 <mauke> Zorn's Lemon.
07:29:45 <explicitjelly> in a monad, how do I compose a non-monadic function with a monadic one, again?
07:30:03 <explicitjelly> pretty basic, but I forgot 8)
07:31:30 <b_jonas> compose how exactly?
07:32:37 <b_jonas> maybe you mean like 'do { x <- getLine; reverse x }'
07:33:00 <Liskni_si> or reverse `fmap` getLine
07:33:20 <Liskni_si> (and you're missing a return there as well)
07:34:13 <bakert> can i replace this with something less horrible:     x <- choose (1, 6); x' <- choose (1, 6); x'' <- choose (1, 6)
07:34:34 <bakert> (choose is from QuickCheck and gets a random number within the stated bounds)
07:34:43 <bakert> do {     x <- choose (1, 6); x' <- choose (1, 6); x'' <- choose (1, 6) }
07:34:47 <bakert> to be accurate
07:34:50 <b_jonas> Liskni_si: ah yeah
07:35:00 <b_jonas> so it's do { x <- getLine; return x }
07:35:26 <b_jonas> no wait
07:35:27 <b_jonas> it's not
07:35:32 <Liskni_si> return $ reverse x
07:35:32 <b_jonas> anyway, don't listen to me
07:35:42 <Lemmih> bakert: do [x,x',x''] <- replicateM 3 (choose (1,6)) ?
07:35:52 <quicksilver> bakert: [x,x',x''] <- replicateM 3 $ choose (1,6)
07:35:53 <quicksilver> bah
07:35:56 <quicksilver> beaten to it :)
07:36:04 <bakert> looks interesting Lemmih ... let me investigate replicateM ... thanks qs also!
07:39:03 <bakert> ?src replicateM
07:39:04 <lambdabot> replicateM n x = sequence (replicate n x)
07:39:57 <bakert> ?pl     [x, x', x''] <- replicateM 3 $ choose (1,6)
07:39:57 <lambdabot> [x, x', x''] <- replicateM 3 $ choose (1, 6)
07:40:04 <explicitjelly> fmap! thanks
07:40:23 <idnar> bakert: there aren't any points in that code
07:40:27 <bakert> oh ye gods i'm in the channel again :(
07:40:35 <bakert> displaying my ignorance! :)
07:40:40 <idnar> teehee
07:40:54 <explicitjelly> although in this case I think I prefer
07:40:59 <explicitjelly> results <- fmap head $ quickQuery...
07:41:18 <osfameron> bakert: blog it for posterity!
07:41:33 <bakert> what, my ignorance?
07:42:01 <osfameron> bakert: I'm not taking the mickey - I think there should be more noddy-level haskell blogs... so that I have some company :-)
07:42:58 <bakert> osfameron: i wrote up some stuff about HAppS 0.8 a while ago.  but it has since been superceded :(  i'm a bit sensitive (on my blog anyway) about my general haskell ignorance
07:43:04 <bakert> i have written up the odd bit here and there
07:43:07 <bakert> http://bluebones.net
07:43:08 <lambdabot> Title: bluebones.net - Adventures in Computer Programming
07:43:18 <osfameron> click
07:45:19 <osfameron> I find being ignorant on a blog quite useful :-)
07:46:44 <bakert> yes i have had some good corrections to the stuff i have posted :)
07:53:09 <Phillemann> I'm trying to follow the Haskell IRC bot tutorial but "ghc Bot.hs" gives me undefined references to some "Network..." functions.
07:53:39 <mrd> might need to install the network library package
07:53:46 <mrd> you using something like debian
07:53:52 <Phillemann> mrd: Yes, that's what I did.
07:54:15 <mrd> yea you'll need libghc6-network-dev
07:54:19 <Phillemann> Version 2.1.0.0
07:54:33 <Phillemann> But gentoo also offers an "alternative version".
07:54:40 <Phillemann> I could try that.
07:54:51 <mrd> hmm
07:54:53 <mrd> do ghc-pkg list
07:55:49 <Phillemann> Says network-2.1.0.0
07:56:20 <mrd> odd
07:56:23 <mrd> oh
07:56:29 <mrd> ghc --make Bot.hs
07:56:41 <mrd> or -package network
07:56:42 <Phillemann> Oh.
07:56:45 <edrx> (warning: very basic question ahead!) I am trying to compile epigram here, but the makefile calls this: "ghc -package lang ...", which gives this error: "ghc-6.6: unknown package: lang". from where would this "lang" come from if it were installed? what do I need to install? or: which files do I need to search for in the debian respositories to discover what to install when some package "xxx" is missing?
07:56:48 * mrd smacks self
07:56:50 <Phillemann> --make Bot.hs actually did the trick.
07:57:01 <Phillemann> I thought that would be the same as just ghc Bot.hs.
07:57:03 <mrd> yea that autoloads pkgs
07:57:21 <mrd> no, make does "smart" dep resolution
07:57:27 <Phillemann> Ah, okay.
07:57:52 <mrd> where's the tutorial?
07:58:20 <Phillemann> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
07:58:31 <Phillemann> And yes, it says ghc --make there. ;)
08:00:07 <dcoutts_> edrx: that package is ages old, you either want a correspondingly old ghc, like 6.4.2, or you want to look at updating the thing you're compiling to not use the old lang package any more.
08:01:01 <edrx> dcoutts_: hm, I can try to use the epigram from cvs instead, then...
08:01:37 <edrx> the .tar.gz that I downloaded is from 2006
08:02:11 <dcoutts_> edrx: or try building it with ghc-6.4.2
08:02:13 <edrx> I'll get the recent version and I'll be back in a few minutes asking non-obsolete questions. thanks
08:02:31 <edrx> dcoutts_: "it" = lang:
08:02:32 <edrx> ?
08:03:06 <dcoutts_> edrx: no, epigram. ghc-6.4.2 still included the old lang package. It was finally dropped in 6.6.
08:03:23 <dcoutts_> hia SyntaxNinja
08:06:33 <explicitjelly> shag?
08:06:40 <shag> jo
08:06:44 <shag> :)
08:06:56 <explicitjelly> der shag? 8)
08:07:01 <shag> jib
08:07:14 <mauke> zomg, don't cross the channels!
08:07:22 <explicitjelly> shag, was machstn du hier?
08:07:35 <edrx> dcoutts_: I don't know if installing a full old ghc here is going to be easy... do you think that things should work if I just download a "lang" from somewhere and make the new ghc 6.6 be aware of it?
08:08:24 <dcoutts_> edrx: I very much doubt it would build with a new ghc. It'd be easier to modify epigram to not use it.
08:10:47 <edrx> aw, scary. 8-| I don't even have much time to play with these things now... I dropped out from academia and I'm in the real world now, and I can only be a mathematician when commuting, or in the shower, or at lunchtime
08:11:21 <swiert> edrx: You may want to look at other languages besides Epigram.
08:11:30 <SyntaxNinja> hi dcoutts
08:11:40 <swiert> edrx: Agda2 is pretty well maintained and does more or less the same as Epigram 1.
08:12:33 <swiert> edrx: http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php
08:12:35 <lambdabot> Title: 14 The Agda Wiki - Main 4b
08:14:42 <edrx> swiert: I'm downloading it... thanks
08:15:30 <mauke> parsec's try CONFUSES and INFURIATES ME
08:15:33 <swiert> edrx: It's not documented very well - but there are loads of interesting examples, and a few short tutorials that come with the source.
08:16:35 <edrx> can it be used from emacs, like epigram?
08:16:51 <swiert> edrx: it comes with an emacs mode - which is a bit like epigram.
08:17:01 <ari> edrx: Mathematics is an illusion, mathematics an lunchtime doubly so
08:17:04 <swiert> edrx: but it also has a command-line ghci-like interface.
08:20:20 <dcoutts_> mauke: that's because it's not composeable
08:22:07 <edrx> ari: "...The rate of population growth, resource extraction, destruction of species, is unparalleled. We live in a totally anomalous time. It's actually quite impossible t to make any generalizations about history, the past or the future, human nature, or anything else, on the basis of our present experience. It stands outside of the mainstream. It's an anomaly. People say, ``We've got to be realistic about the way t
08:22:07 <edrx> hings *are*.'' But the way things for now *are* aren't real. It's a temporary situation." (Gary Snyder, the "East/West Journal" interview, 1977)
08:22:23 <edrx> work is an illusion, but it pays the bills.
08:22:32 <edrx> lunch is real, though.
08:22:41 <defcons> hello
08:22:41 <edrx> well, lemme compile agda2. brb.
08:22:45 <defcons> what is wrong with my zip3 function?
08:22:53 <defcons> myz3 :: [a] -> [b] -> [c] -> [(a,b,c)]
08:22:54 <defcons> myz3 (x:xs) (y:ys) (z:zs)
08:22:54 <defcons>     | or [null item | item <- [x,y,z]] = []
08:22:54 <defcons>     | otherwise = (x,y,z) : (myz3 xs ys zs)
08:23:16 <mauke> dcoutts_: the code I'm looking at is  parseTest (try (char 'a' >> char 'x')) "ab"
08:23:45 <mauke> it complains about an unexpected "b" at column 1, which is clearly nonsense
08:23:56 <byorgey> defcons: asking whether the first element of a list is null is not the same as asking whether the list is null.
08:24:22 <defcons> that was dumb
08:24:36 <defcons> thanks
08:24:43 <byorgey> defcons: sure =)
08:25:21 <dcoutts_> mauke: why is that nonsense? "ab" cannot be parsed as 'a' followed by an 'x'
08:26:01 <dcoutts_> mauke: are you trying to find the longest prefix that could be extended to be a correct parse?
08:26:08 <mauke> the error location is wrong. it should say column 2 or 'unexpected "ab"'
08:26:18 <defcons> byorgey, what is wrong with [null item | item <- [x:xs,y:ys,z:zs]] ?
08:26:24 <dcoutts_> mauke: oh, you mean because it's counting from 0?
08:26:29 <mauke> it isn't
08:26:45 <byorgey> defcons: if you pattern match on (x:xs), that already guarantees that the list *isn't* empty.
08:26:59 <defcons> ok
08:27:04 <byorgey> (x:xs) only matches lists which have at least one element (x) followed by the reset (which may be empty).
08:27:09 <byorgey> *rest
08:27:27 <defcons> I tried [xs,ys,zs], but still got a type error
08:27:47 <byorgey> defcons: you can either pattern match on the empty list directly, something like myz3 [] _ _ = []; myz3 _ [] _ = []... and so on
08:27:47 <dcoutts_> mauke: parseTest (try (char 'a' >> char 'x') <?> "foobar") "ab"
08:28:13 <mauke> parse error at (line 1, column 1): unexpected "b"
08:28:16 <mauke> it's still wrong
08:28:21 <byorgey> defcons: or you could do myz3 xs ys zs | or [null lst | lst <- [xs,ys,zs]] = []
08:28:35 <byorgey> defcons: but the first (direct pattern-matching) is probably the more idiomatic.
08:29:03 <defcons> yeah I thought about the pattern matching
08:29:30 <defcons> okay then
08:29:55 <phlpp> hi
08:30:06 <dcoutts_> mauke: yes, I see. It's reporting the location at the backtracking point, but the unexpected token at the point where the parse could not be extended.
08:30:27 <mauke> it's even more confusing if you replace char 'a' by something more complex
08:31:01 <dcoutts_> mauke: I bet. and if you take out the try it gives the right location.
08:31:22 <mauke> yes
08:32:16 <edrx> swiert: the README in the agda2 package says that it needs "binary-0.3" and "zlib-0.3", but versions 0.4/0.4.1/0.4.0.1 of these things exist. should I use the 0.3s or the latest ones?
08:32:17 <dcoutts_> mauke: on the other hand it'd be rather confusing to say unexpected 'a' when there is an 'a' there.
08:32:45 <mauke> yeah, it should report the correct location :-)
08:33:24 <dcoutts_> yeah, I guess so. report it to the libraries list.
08:36:11 <fasta> Can one have a monad transformer stack containing both ST and IO?
08:38:58 <swiert> edrx: Use binary-0.3
08:39:07 <swiert> I think there's a problem with the latest version...
08:39:20 <dcoutts_> swiert: really? what is that?
08:39:24 <edrx> swiert: thanks!
08:39:35 <dcoutts_> swiert: if there's a problem I need to know so I can fix it! :-)
08:40:17 <swiert> dcoutts_: Hang on - I'm confused. You needed the latest version from darcs.
08:40:35 <swiert> The one on Hackage didn't work.
08:40:50 <dcoutts_> swiert: the latest version of binary from darcs?
08:41:18 <swiert> dcoutts: Yes - but that was a few months ago.
08:41:38 <swiert> You needed 0.3, but that wasn't on Hackage at the time.
08:41:47 <dcoutts_> swiert: the latest binary from darcs is exactly the 0.4.1 that is on hackage. There have been no patches since.
08:42:20 <swiert> dcoutts_: Sorry - I'm not being very clear. I ran into this problem a few months ago.
08:42:47 <dcoutts_> swiert: ok, well let us know if you have any problems with the current ones on hackage.
08:42:49 <swiert> I'm sure it'll work now - but a few months ago you needed to check out the binary from darcs as opposed to the one on Hackage.
08:43:00 <swiert> dcoutts_: sure. will do.
08:48:21 <dons> swiert: lovely work on the soc/tmr
08:48:24 <osfameron> :t (***)
08:48:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:49:29 <swiert> dons: Thanks!
08:49:42 <swiert> I'm glad to ship it finally.
08:49:59 <swiert> summer's been over for a while now :)
08:50:04 <matthew_-> gah. :set +s doesn't give timings for the type checking phase
08:50:40 <byorgey> osfameron: =)
08:51:21 <faxathisia> Any recommendations of particularly good haskell code to read, other than xmonad and LogicT?
08:52:51 <aref> is there any way to time a function execution in ghci?
08:53:11 <matthew_-> aref: yes type :set +s into ghci
08:53:21 <osfameron> byorgey: hehe
08:53:24 <matthew_-> it'll then give you timings
08:53:46 <aref> matthew_-: excellent, thank you :)
08:55:09 <dons> faxathisia: read the functional pearl papers?
08:55:24 <faxathisia> ah ok
08:55:33 <faxathisia> I read 2 I think they are cool
08:55:34 <TuringTest> ^%%@$#@ unsafeUseAsCStringLen @#$@%$%
08:55:52 <sorear> TuringTest: NULL points to a perfectly legitimate 0-byte block
08:55:58 <TuringTest> :)
08:56:07 <sorear> TuringTest: why are you indexing outside of a memory block?
08:56:21 <TuringTest> I was passing a pointer to the c-library of PCRE
08:56:22 <shapr> Heya TuringTest, long time no see! How's code?
08:56:30 <sorear> TuringTest: if this were C-land, demons would be flying out of your nose right now
08:56:31 <TuringTest> shapr: null pointer
08:56:47 <shapr> Whoa, painful
08:56:49 <sorear> TuringTest: if PCRE breaks when passed (NULL, 0) that's a bug in PCRE
08:57:01 <sorear> TuringTest: that's a *perfectly* legitimate ""
08:57:08 <TuringTest> sorear: I am catching the null pointer in Haskell, not passing it to PCRE.
08:57:09 <newsham> unless the API says you must not pass it a NULL pointer
08:57:20 <sorear> TuringTest: why?
08:57:28 <TuringTest> sorear: paranoia
08:57:33 <dons> TuringTest: yes, i don't understand what the problem was (and why don't we get  the same result with useAsCStringLen ?)
08:57:53 <TuringTest> dons: useAsCStringLen _never_ returns a null pointer
08:58:05 <dons> but when it returns an empty string it should, no?
08:58:09 <sorear> dons: we don't get the same result with useAsCStringLen because the latter copies
08:58:12 <TuringTest> dons: I just read the latest code, and that is how it looked at least.
08:58:27 <dons> oh, it will return a pointer with length 0 in its len field
08:58:28 <TuringTest> dons: Hmmm.....
08:58:29 <sorear> TuringTest: why is the null pointer a problem?
08:58:30 <newsham> the empty string is a pointer to the byte NUL
08:58:35 <newsham> no?
08:58:39 <dons> right.
08:58:53 <sorear> newsham: we're talking about (address,length) strings here
08:59:01 <sorear> newsham: and (NULL,0) is a perfectly good ""
08:59:04 <newsham> oh.
08:59:18 <dons> empty :: ByteString
08:59:19 <dons> empty = PS nullForeignPtr 0 0
08:59:23 <TuringTest> If I understood the code , I would not be in this mess.  I will go and read it some more
08:59:32 <TuringTest> dons: yep, that's the null
08:59:33 <newsham> sorear: are you sure its documented thusly?  just because it makes perfect sense to you doesnt mean its valid.
08:59:58 <sorear> TuringTest: I don't understand why you're even CHECKING for null pointers
09:00:18 <oboudry> Chris, don't worry about my last e-mail. My mistake, the regex-pcre patch is working properly.
09:00:20 <TuringTest> sorear: If I don't check then I have to be sure I know how the c code will respond.
09:00:30 <TuringTest> sorear: So I am pulling up the PCRE documentation right now
09:00:41 <TuringTest> oboudry:  Hooray!  the patch worked!
09:00:43 <dmead> huzzah!
09:00:48 <dons> so there's different behaviour from C when its passed a pointer to a string with length 0, and a nullPtr with length 0?
09:00:51 <sorear> TuringTest: then why aren't you also checking for "2kdkncjkek"?  do you know how the C code will respond to that?
09:01:13 <oboudry> I probably left a non-working copy of my app in the path.
09:01:21 <oboudry> Sorry for the misinformation.
09:01:41 <dcoutts_> lots of C code does behave differently with null pointers vs pointer to 0-length null terminated C string. It's not that unreasonable.
09:02:00 <dons> yeah, if that's the case here, that's an interesting issue
09:02:04 <TuringTest> pcre takes a pointer and a length
09:02:13 <dons> it makes unsafeUseAs* a little more unsafe, i think
09:02:23 <dons> since you'll need to be aware that nullPtr is used for the empty string
09:02:37 <dcoutts_> dons: it does? hmm, that doesn't seem good.
09:02:51 <dons> well, there must be  lots of cases where our 'empty' gets passed to C
09:03:06 <dons> empty = PS nullForeignPtr 0 0
09:03:08 <dcoutts_> dons: oh, it's only the unsafeUseAs*, that's not so bad. How about the ordinary safe ones?
09:03:19 <sorear> dons: why is this a problem?  unsafeUseAsCStringLen returns a length, and unsafeUseAsCString returns something NUL-terminated
09:03:27 <sorear> dcoutts_: why is this a problem?
09:03:30 <dons> useAsCString (PS fp o l) action = do
09:03:30 <dons>  allocaBytes (l+1) $ \buf ->
09:03:30 <dons>    withForeignPtr fp $ \p -> do
09:03:30 <dons>      memcpy buf (p `plusPtr` o) (fromIntegral l)
09:03:30 <dons>      pokeByteOff buf l (0::Word8)
09:03:32 <dons>      action (castPtr buf)
09:03:35 <dons> is ok.
09:03:36 <sorear> dcoutts_: the safe ones copy
09:03:42 <dcoutts_> and null-terminate
09:04:35 <dons> sorear: it seems like it can be a problem on the C side, where the strings (0,0) /= (_,0)
09:04:49 <sorear> dons: /=?  really?
09:05:03 <sorear> I'd say any code that distinguishes the two is buggy
09:05:17 <dons> let's see what TuringTest works out is going on
09:05:33 <dcoutts_> dons: I guess we should just document the unsafeUse functions to say that for 0 length strings, theres no guarantee if the pointer points anywhere, it might be null it might not.
09:05:43 <dons> right
09:06:21 <sorear> dcoutts_: why does it matter if the pointer points anywhere?  you aren't supposed to index outside of the returned block anyway
09:06:27 <TuringTest> dons: What are you asking me?
09:06:48 <sorear> dons: turingtest beleives (irrationally IMO) that pcre will make a distinction with (0,0)
09:06:48 <dcoutts_> sorear: who knows what C code does :-)
09:07:01 <dons> right, that's what I want to know.
09:07:08 <TuringTest> sorear: I am reading "man pcreapi" right now.
09:07:22 <TuringTest> sorear: It returns PCRE_ERROR_NULL if the subject is null
09:07:35 <TuringTest> sorear: So PCRE claims it will fail on a null pointer
09:07:45 <sorear> TuringTest: pcre special-casing (0,0) is about as ridiculous as pcre special-casing "eijfwowfeonlj"... oh it DOES?!
09:07:54 <dons> yeah, so C functions that fail on null need to be lifted to Maybe, really.
09:08:02 <sorear> TuringTest: that's a bug, IMO
09:08:06 <quicksilver> no it isn't
09:08:10 <dons> sorear: C is like that.
09:08:14 <sorear> okay, a misfeature
09:08:14 <TuringTest> sorear: PCRE_ERROR_NULL (-2)   Either code or subject was passed as NULL, or ovector was NULL and ovecsize was not zero.
09:08:14 <quicksilver> a null point is NOT the same as an empty string
09:08:15 <dons> they don't have  Maybe a
09:08:32 <quicksilver> some C APIs may treat null pointers as empty strings
09:08:34 <quicksilver> but they don't have to
09:08:38 <sorear> quicksilver: you think we're talking about C strings
09:08:39 <TuringTest> sorear: The prevent NULL to prevent lazy programmers from using NULL
09:08:42 <sorear> quicksilver: we aren't
09:08:47 <quicksilver> sorear: I do indeed.
09:08:56 <sorear> quicksilver: (address, length) pairs
09:08:58 <quicksilver> I think TuringTest is talking about C strings.
09:09:07 <sorear> quicksilver: no null termination in the current context
09:09:09 <TuringTest> quicksilver: No ... (adresss, length) is what PCRE takes
09:09:10 <dmwit> No, everybody is talking about (address, length) pairs.
09:09:15 <quicksilver> ah, I see
09:09:16 <sorear> NULL is not a valid ASCIZ form
09:09:25 <quicksilver> even so...
09:09:33 <quicksilver> code might use NULL to signify something else
09:09:39 <quicksilver> C APIs use null to signify all kinds of things...
09:09:42 <newsham> sorear: a specified API thats different than the one you want it to be is not a bug.
09:09:49 <dmwit> right
09:09:52 <dons> yes, you should copy if there's any risk that the C code will fail on nullPtr
09:10:03 <sorear> newsham: yeah, it's documented, so it's just a horrid misfeature
09:10:04 <TuringTest> Summary: I am right that I cannot pass NULL to PCRE and I do not want to memcpy everything, so I must use unsafeUseAsCStringLen and I must replace NULL with a valid pointer.
09:10:05 <dons> i.e. useAs* not unsafeUseAs*
09:10:15 <newsham> sorear: thats a more realistic statement.
09:10:25 <dons> TuringTest: right. so that's ok for now.
09:10:30 <TuringTest> So my fixed code is doing precisely what it needs to do.
09:10:35 <TuringTest> :)
09:10:35 <dons> allocate a pointer you can use to some bytes for the empty string
09:10:54 <dons> we need docs for this issue though. and maybe even move away from using nullPtr internally for the empty bytestring caf
09:11:12 <TuringTest> dons: My code was posted in the mailing list announcement if you want to see how I make a valid pointer.
09:11:12 <dons> as much as i hate C's type system infecting haskell code ;)
09:11:16 <dcoutts_> dons: I think the nullPtr is fine
09:11:40 <roconnor> @go 1 CAD in USD
09:11:41 <lambdabot> 1 Canadian dollar = 1.018953 U.S. dollars
09:11:44 <dons> dcoutts_: ok. so then these unsafeAs* need some more docs, andan example of why / how you'd sub out nullPtr
09:11:55 <dcoutts_> dons: yes.
09:11:58 <TuringTest> dons: I would be pleased at more precise documentation about returning nullPtr.  The current documentation forced me to read the code.
09:12:32 <dons> yeah. unsafe* are unsafe :)
09:12:51 <dons> its a good issue report.
09:13:11 <newsham> null2empty NULL = empty; nul2empty s = s
09:13:53 <TuringTest> oboudry: If you have any suggestions for API changes to regex-* then I would be happy to read them.
09:14:01 <mauke> denull NULL = nullPtr `plusPtr` 1234
09:15:03 <oboudry> TuringTest: OK, for the moment I really like the API. I will let you know if I have any suggestions.
09:15:23 <dons> another lovely day in portland, 1 degree to 7.
09:15:37 * dons wonders what the weather's like in sydney
09:15:54 <shapr> It's hot!
09:15:59 <dons> oh, 27 degrees.
09:16:09 <dons> ?go 27 C in F
09:16:09 <lambdabot> 27 degrees Celsius = 80.6 degrees Fahrenheit
09:16:22 <dons> this northern hemisphere is weird
09:16:24 <shapr> dons: Did you get two summers in a row, or two winters?
09:16:30 <dons> two winters!
09:17:41 <BMeph> Sydney isn't going to be hot in November, except maybe in the middle of the day. Come late January, February... o_O
09:17:45 <kalmar> does the IsString class (and associated flag) make it so that, e.g. "a" :: IsString a => a?
09:17:56 <dcoutts_> dons: Australian winter is hardly winter :-)
09:18:05 <sorear> kalmar: with -foverloaded-strings, yes
09:18:12 <kalmar> sorear: that is super cool
09:18:14 <dons> yes, that's true dcoutts_
09:18:16 <Syzygy-> BMeph: I thought Sydney was hot in mid-september.
09:18:22 <kalmar> I wish had thought of that a bit earlier
09:18:33 <kalmar> thanks
09:18:48 <sorear> Prelude> :t "x"
09:18:48 <sorear> "x" :: [Char]
09:18:53 <sorear> Prelude> :set -XOverloadedStrings
09:18:53 <sorear> Prelude> :t "x"
09:18:53 <sorear> "x" :: (Data.String.IsString t) => t
09:19:00 <BMeph> If by "hot" you mean "hotter than it is in August," then sure, it's hot... ;p
09:19:11 <shapr> I've never been to Sydney, but I'd like to visit.
09:19:31 <Syzygy-> BMeph: By "hot" I mean "I feel slightly uncomfortable outside at noon, even when wearing shorts and tshirt, and I start to care very actively about hydration."
09:19:51 <dmwit> dons: I'm applying to UNSW now; got any tips? =P
09:19:56 <shapr> Syzygy-: Come to Alabama :-)
09:20:05 <Syzygy-> shapr: How does it compare to Stockholm?
09:20:15 <aref> I'm trying to construct a new datatype Quad, which should hold 4 elements, 2 and 2 alike ie: data Quad a a b b = Quad a a b b, but I'm getting conflicting types-error. how should I be going about this?
09:20:22 <shapr> Syzygy-: Yesterday it was too hot for walking around outside here.
09:20:33 <matthew_-> aref: data Quad a b = Quad a a b b
09:20:34 <Syzygy-> Oh joy. :-/
09:20:42 <shapr> Syzygy-: In the summer, the streets melt.
09:20:48 <matthew_-> aref: the same type var can't appear more than once on the lhs
09:20:50 <Syzygy-> shapr: We get that in Stockholm too, occasionally.
09:20:58 <aref> matthew_-: oh, I see, that's rather logical. thanks.
09:20:59 <Syzygy-> But only the tar repair strips.
09:21:14 <shapr> New streets melt and sag into puddles here.
09:21:21 <shapr> It's like walking on taffy or something.
09:21:28 <Syzygy-> (happy hardcore REALLY is not a very good choice for thesis work music)
09:21:32 <Syzygy-> shapr: Yikes.
09:21:36 <BMeph> Bah, if it ain't 40, it ain't hot. ;p
09:21:44 <Syzygy-> BMeph: Hot starts at 25.
09:21:52 <matthew_-> aref: or you can declare it as a GADT in which case it'd look something like: data Quad :: * -> * -> * where Quad :: a -> a -> b -> b -> Quad a b
09:21:52 <shapr> @go 40c in f
09:21:53 <lambdabot> 40 degrees Celsius = 104 degrees Fahrenheit
09:21:58 <newsham> dons: its 80F here pretty much every day of the year
09:22:05 <Syzygy-> @go 80f in c
09:22:05 <lambdabot> 80 degrees Fahrenheit = 26.6666667 degrees Celsius
09:22:09 <shapr> BMeph: Yeah, we get that.
09:22:25 <shapr> I'm not sure what the average high temp is for summer days.
09:22:26 <matthew_-> aref: personally, I think GADTs are much more consistent and clearer than normal data type declarations, but they're not supported outside of GHC.
09:22:33 <aref> matthew_-: I think I need to grasp the basics before I go all out party-style like that
09:22:36 <aref> :)
09:22:41 <matthew_-> np :)
09:23:27 <newsham> its 70F now (723a) we're going up to 82F
09:23:44 <Baughn> Is "haskell road to logic, maths and programming" at all useful to someone who's already relatively conversant with the language?
09:24:24 <newsham> baughn: its not a haskell book, its a math book that uses haskell sometimes
09:24:25 <shapr> Baughn: I enjoyed the parts I read.
09:24:49 <newsham> if you want a math book, its decent
09:24:59 <Baughn> Hmm. *Which* maths?
09:25:30 <oboudry> baughn: I agree with newsham. Bought it but it teaches more math than Haskell
09:25:33 <newsham> several.  predicate calculus, some number theory, some polynomial and power series stuff
09:25:37 <newsham> it kinda jumps around
09:25:43 <Baughn> Sounds useful
09:26:00 <newsham> http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
09:26:03 <Baughn> OKay, I'll take the chance. ^^;
09:26:14 <newsham> dunno if thats supposed to be online or not :)  but there you have it
09:26:18 * Baughn blinks
09:26:21 <newsham> that might give you enough preview to know if you want it
09:26:41 <Baughn> It would. Thanks. :)
09:26:43 <newsham> also a handy reference even if you do buy it
09:29:49 <bakert> QuickCheck.  Those Arbitrary instance definitions must get awfully boring.  Can it work out anything automatically?
09:31:05 <shapr> Most of the time you can build instances out of something that already has instances.
09:31:42 <BMeph> It's dated three-and-a-half years ago, so if it weren't supposed to be online, they've had some time to correct that... :)
09:31:45 <shapr> bakert: Got anything specific you want to be an instance of Arbitrary?
09:31:58 <byorgey> bakert: they aren't that bad.  I don't know how you'd derive any automatically, since the semantics of Arbitrary instances depend a lot on the problem domain rather than just the shape of the data type.
09:32:06 <bakert> shapr: my Character record class.  it's big and holds lots of things :)
09:32:24 <Saizan> bakert: http://hackage.haskell.org/packages/archive/derive/0.1/doc/html/Data-Derive-Arbitrary2.html
09:32:26 <lambdabot> http://tinyurl.com/25m7cl
09:32:48 <bakert> Saizan: interesting
09:32:57 <byorgey> oh, huh, I didn't know about that!
09:33:14 <newsham> I did a bunch of the haskell road predicate calculus proofs using haskell types (curry-howard).
09:33:28 <newsham> you'd think a haskell book woulda promoted that ;-)
09:34:09 <swiert> coq on a PS3 people: http://pauillac.inria.fr/pipermail/coq-club/2007/003221.html
09:34:10 <lambdabot> Title: [Coq-Club] Coq on Playstation 3
09:34:35 <shapr> swiert: Nifty!
09:35:02 <swiert> shapr: a whole new meaning to "toy dependently typed programming language"
09:35:14 <faxathisia> :o
09:35:40 <dmwit> heh
09:35:44 <shapr> :-)
09:39:09 <geocalc> asumming you have money to waste in buying a ps3
09:39:51 <swiert> That's what "equipment expenses" on grant proposals are for :)
09:41:58 <Taejo> is there an easy way to convert a number to a binary string?
09:42:17 <newsham> know how to convert a number to a base 10 string?
09:42:24 <newsham> its pretty similar going to a base 256 string
09:42:44 <geocalc> not every one is student swiert
09:42:50 <Taejo> newsham, show
09:43:04 <newsham> taejo: i mean, how to do it yourself without using "show"
09:43:19 <faxathisia> > reverse $ map (`mod` 2) $ takeWhile (>0) $ iterate (`div` 2) 35486
09:43:22 <Taejo> ah, newsham, I have no trouble doing it without a built-in function
09:43:22 <lambdabot>  [1,0,0,0,1,0,1,0,1,0,0,1,1,1,1,0]
09:43:50 <mauke> showIntAtBase
09:43:50 <newsham> unfold (\n -> guard (n/=0) >> return (n`mod`10, n`div`10)) 3456
09:43:53 <newsham> > unfold (\n -> guard (n/=0) >> return (n`mod`10, n`div`10)) 3456
09:43:54 <lambdabot>   Not in scope: `unfold'
09:43:59 <newsham> > unfoldr (\n -> guard (n/=0) >> return (n`mod`10, n`div`10)) 3456
09:44:00 <lambdabot>  [6,5,4,3]
09:44:17 <byorgey> @type showIntAtBase
09:44:18 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:44:22 <faxathisia> newsham: When you said base 10.. I thought you mean binary :S
09:44:23 <dcoutts_> showIntAtBase 2 (\bit -> case bit of 0 -> '0'; 1 -> '1') 7 ""
09:44:25 <faxathisia> I can't imagine why
09:44:26 <dcoutts_> > showIntAtBase 2 (\bit -> case bit of 0 -> '0'; 1 -> '1') 7 ""
09:44:26 <lambdabot>  "111"
09:44:33 <newsham> > unfoldr (\n -> guard (n/=0) >> return (chr (n`mod`256), n`div`256)) 3456
09:44:33 <lambdabot>  "\128\r"
09:44:36 <faxathisia> > reverse $ map (`mod` 10) $ takeWhile (>0) $ iterate (`div` 10) 35486
09:44:36 <dcoutts_> > showIntAtBase 2 (\bit -> case bit of 0 -> '0'; 1 -> '1') 8 ""
09:44:37 <lambdabot>  "1000"
09:44:37 <lambdabot>  [3,5,4,8,6]
09:45:03 <newsham> > reverse $ map (`mod` 10) $ takeWhile (>0) $ iterate (`div` 10) 350486
09:45:05 <lambdabot>  [3,5,0,4,8,6]
09:45:05 <Taejo> showIntAtBase is what I sought, although faxathisia's way is very elegant
09:45:23 <byorgey> > showIntAtBase 2 ("01"!!) 94 ""
09:45:24 <lambdabot>  "1011110"
09:46:00 <swiert> geocalc: I wasn't being particularly serious.
09:46:10 <geocalc> ok
09:46:15 <BMeph> "There are 10 kinds of people out there..." ;p
09:46:22 <faxathisia> hehe
09:46:55 <hrehf> hi - hmmm, sry if im asking dumb questions, but i don't really know how to look up this stuff yet - is there a function that takes a string and converts it into a corresponding Num (i know of Char.digitToInt, but that isn't doing all of the work)
09:47:10 <faxathisia> hrehf: read :: String -> Int
09:47:22 <byorgey> @type read
09:47:23 <lambdabot> forall a. (Read a) => String -> a
09:47:32 <faxathisia> > (read "354 for example") :: Int
09:47:33 <lambdabot>  Exception: Prelude.read: no parse
09:47:37 <faxathisia> :|
09:47:46 <Taejo> hrehf, hoogle is a good place to look: you can search for functions by their type signature
09:47:46 <mauke> > read "354"
09:47:47 <lambdabot>  354
09:47:47 <byorgey> hrehf: the function 'read' can turn a String into anything that is "readable", which includes Int, Integer, Double, etc.
09:47:50 <allbery_b> you're thinking reads :)
09:48:05 <byorgey> > read "12.5" :: Double
09:48:06 <lambdabot>  12.5
09:48:14 <hrehf> Taejo oh, nice, will try next time ;)
09:48:26 <byorgey> @hoogle String -> a
09:48:26 <lambdabot> Prelude.error :: String -> a
09:48:26 <lambdabot> Debug.Trace.trace :: String -> a -> a
09:48:26 <lambdabot> Prelude.fail :: Monad m => String -> m a
09:48:34 <hrehf> faxathisia, byorgey thanks a lot!
09:48:42 <byorgey> hrehf: you're welcome =)
09:49:32 <dmwit> The second 'h' in "hrehf" makes me uncomfortable.
09:50:19 <mauke> IÃ IÃ FTAHGN
09:50:31 <allbery_b> take two <a> and call a doctor?
09:50:36 <hrehf> dmwit haha
09:50:41 <faxathisia> hmm
09:50:43 <dmwit> ha
09:50:49 <faxathisia> is there a name for 'fear of mismatched parantheis"
09:51:04 <dmwit> lisphobia
09:51:08 <allbery_b> "schemer"?
09:51:09 <geocalc> > read "3.7" :: Quad
09:51:11 <lambdabot>   Not in scope: type constructor or class `Quad'
09:51:17 <hrehf> dmwit the missing i in .. wait j/k :)
09:51:32 <dmwit> hrehf: Yeah. =)
09:51:39 <newsham> fax: I think that falls under OCD
09:51:42 <dmwit> Misspellings seem to be a good way to pick a handle. =)
09:51:45 <newsham> along with "fear of an untied shoelace"
09:51:52 <dcoutts_> faxathisia: how about misparenphobia
09:52:10 <dmwit> ?quote lisp
09:52:11 <lambdabot> twb says: I liked _On Lisp_, but it should have been called _Dirty Things I Did With Macros_
09:52:21 <hrehf> dmwit indeed, though mine is just some weird foreign language thing :)
09:52:32 * hrehf returns to work
09:52:41 <dmwit> ?quote parentheses
09:52:41 <lambdabot> No quotes match. Maybe you made a typo?
09:52:52 <dmwit> ...
09:52:54 <dmwit> ?quote :)
09:52:54 <lambdabot> Cale says: I should actually think before coding, but the type system is so good :)
09:55:37 <Saizan> withSocketsDo should be used only one time per program or subsequent calls are idempotent?
09:57:01 <Botje> Saizan: yes, it's to tell windows "THIS APP USES SOCKETS."
09:57:34 <dmwit> Does this text look... different to anybody? :
09:57:38 <dmwit> ?quote love.operator
09:57:38 <lambdabot> monochrom says:  (<3) is the Haskell love operator :)
09:59:46 <ricky_clarkson> > let (<3) x="I <3 "++x in (<3) "chocolate"
09:59:46 <lambdabot>  Parse error in pattern at "in" (column 23)
09:59:47 <Saizan> Botje: so if i call it multiple times windows will get mad at me or not?
09:59:53 <mauke> ï¼¨ï¼¥ï¼¬ï¼¬ï¼¯ ï¼©ï¼³ ï¼´ï¼¨ï¼©ï¼³ ï¼´ï¼¨ï¼©ï¼®ï¼§ ï¼¯ï¼®ï¼
10:00:10 <dcoutts_> heh
10:00:27 <mux> anyone knows how to generate the exact infinite decimal digits of an irrational square root?
10:00:33 <dcoutts_> who added that to Unicode, and what were they thinking?
10:00:41 <newsham> ï¼¨ï½ï½ï¼ï¼­ï½ï½ï½ï½ï¼ï¼ï½ï½ï½ï½ï¼ï½ï¼ï½ï½ï½ï½ï½ï½ï¼ï½ï½ï½ï½ï½ï½
10:01:16 <mauke> what are those U+FF00's?
10:02:15 <sieni> mauke: some unicode code points?
10:02:27 <Botje> Saizan: nah, it's cool
10:02:28 <faxathisia> > iterate (\x -> (x+2/x)/2) 1
10:02:31 <lambdabot>  [1.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.41421356...
10:02:42 <alexj> @seen igloo
10:02:42 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 46m 23s ago.
10:02:52 <mauke> sieni: yeah, but are they real characters? they're not in my font
10:02:58 <newsham> mauke: wide ascii "hey mauke, thats pretty snazzy"
10:03:12 <faxathisia> mux: I wonder if there is a way to turn an infinite continued fraction into an infinite list of digits
10:03:14 <allbery_b> double width presentation forms, I think the standard calls them
10:03:23 <ricky_clarkson> > fix (\x -> (x+2/x)/2) 1
10:03:24 <lambdabot>   add an instance declaration for (Fractional (t -> a))
10:03:24 <lambdabot>     In the expression...
10:03:27 <mauke> I can see the letters but the spaces are borked
10:03:29 <mux> faxathisia: I wonder that too :-)
10:03:42 <ricky_clarkson> faxathisia: Depends how you generate the digits.
10:03:45 <mux> I already have code to generate the infinite continued fraction for a square root :)
10:03:59 <mux> faxathisia: but if there's a way, it looks non-trivial
10:04:10 <newsham> I used wide spaces, too
10:04:13 <newsham> which some fonts show as a box
10:04:23 <faxathisia> I believe it is non-trivial indeed :)
10:04:24 <ricky_clarkson> > 0:repeat 3
10:04:26 <faxathisia> I couldn't figure it out
10:04:27 <lambdabot>  [0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
10:04:45 <ricky_clarkson> There, 1/3 as an infinite stream of digits. ;)
10:04:48 <idnar> heh
10:04:54 <faxathisia> ricky_clarkson: 1+1/(2+1/(2+1/...)) is an example of a continued fraction
10:04:54 <mux> ricky_clarkson: nah you're only approximating the square root but you an't be sure of how many digits you have correct
10:05:04 <faxathisia> ricky_clarkson: for the square root of to
10:05:06 <dmwit> :t foldr (const (1+)) 0
10:05:07 <mux> (1:repeat 2) is the cfrac for sqrt 2
10:05:14 <lambdabot> forall t a. (Num t) => [a] -> t
10:05:22 <ricky_clarkson> mux: I didn't know it was particularly for root 2.
10:05:31 <mux> @let convergents = let convergents' (n0,n1) (d0,d1) (a:as) = let n = a * n1 + n0; d = a * d1 + d0 in (n % d) : convergents' (n1,n) (d1,d) as; convergents' _ _ [] = [] in convergents' (0,1) (1,0)
10:05:34 <lambdabot> Defined.
10:05:43 <mux> > convergents (1:repeat 2)
10:05:44 <lambdabot>  [1%1,3%2,7%5,17%12,41%29,99%70,239%169,577%408,1393%985,3363%2378,8119%5741,...
10:05:45 <allbery_b> ah, there it is.  "Halfwidth and Fullwidth Forms"
10:06:06 <mux> > 8119/5741
10:06:07 <lambdabot>  1.4142135516460548
10:06:10 <mux> > sqrt 2
10:06:11 <lambdabot>  1.4142135623730951
10:06:34 <newsham> ricky: hmm.. you sure thats not  SUM_1^\inf 3*x^n ?
10:06:56 <ricky_clarkson> newsham: No, especially as I don't know what that is.
10:07:08 <mux> > convergents (repeat 1)
10:07:13 <newsham> 3x + 3x*x + 3x*x*x + 3 x*x*x*x + ...
10:07:13 <lambdabot>  [1%1,2%1,3%2,5%3,8%5,13%8,21%13,34%21,55%34,89%55,144%89,233%144,377%233,610...
10:07:21 <mux> > 377/233
10:07:23 <lambdabot>  1.6180257510729614
10:07:25 <mux> > exp 1
10:07:26 <lambdabot>  2.718281828459045
10:07:29 <mux> err
10:07:35 <dmwit> phi
10:07:36 <mux> > (1 + sqrt 5)/2
10:07:37 <lambdabot>  1.618033988749895
10:07:38 <mux> yeah :)
10:07:40 <faxathisia> mux: what about this http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit_by_digit_calculation
10:07:41 <lambdabot> http://tinyurl.com/yk6zgb
10:07:51 <mux> I've gtg, bbl&
10:08:09 <ricky_clarkson> > sqrt 8/2
10:08:09 <lambdabot>  1.4142135623730951
10:08:40 <lokadin_> how do you drop the end of the string?
10:08:52 <faxathisia> lokadin_: you can use 'take'
10:09:01 <ricky_clarkson> take 3 "hello"
10:09:01 <bakert> > take 4 "hello"
10:09:02 <lambdabot>  "hell"
10:09:03 <lokadin_> kk
10:09:06 <lokadin_> thanks
10:09:10 <faxathisia> > take 5 "hello"
10:09:12 <lambdabot>  "hello"
10:09:47 <matveev> and how do you drop trailing zeroes from the list?
10:10:13 <faxathisia> > reverse. dropWhile (=='0') . reverse "1234560000"
10:10:17 <lambdabot>  Couldn't match expected type `a -> [Char]'
10:10:41 <faxathisia> oops
10:10:48 <faxathisia> > reverse.dropWhile (=='0').reverse $ "1234560000"
10:10:51 <lambdabot>  "123456"
10:11:01 <faxathisia> I don't know if there maybe another easier way though?
10:11:10 <ricky_clarkson> :t takeWhile
10:11:13 <bakert> you could take until the first 0
10:11:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:11:25 <newsham> if there are no internal zeros
10:11:25 <bakert> ah.  what he said.
10:11:38 <ricky_clarkson> > takeWhile (=='0') "1234560000"
10:11:38 <alexj> @seen ndm
10:11:39 <lambdabot> I haven't seen ndm.
10:11:41 <lambdabot>  ""
10:11:45 <ricky_clarkson> bah
10:11:52 <faxathisia> > takeWhile (/='0') "12034560000"
10:11:52 <lambdabot>  "12"
10:11:52 <newsham> > takeWhile (/='0') "12345000"
10:11:53 <lambdabot>  "12345"
10:11:55 <newsham> > takeWhile (/='0') "120345000"
10:11:56 <lambdabot>  "12"
10:11:56 <mauke> :t let l f x=case f x of Left r->r;Right y->l f y;s(v,d,c)|v<d=Left(v,c)|True=Right(v-d,d+2,c+1);f n r=let(v,c)=l s(n*100,r*20+1,0)in chr(fromInteger c+48):f v(r*10+c)in f
10:11:57 <lambdabot> parse error on input `='
10:12:06 <newsham> > reverse.dropWhile (=='0').reverse $ "120345000"
10:12:07 <lambdabot>  "120345"
10:12:20 <newsham> not exactly the same
10:12:27 <mauke> :t let l f x=case f x of Left r->r;Right y->l f y;s(v,d,c)|v<d=Left(v,c)|True=Right(v-d,d+2,c+1);f n r=let{(v,c)=l s(n*100,r*20+1,0)}in chr(fromInteger c+48):f v(r*10+c)in f
10:12:27 <lambdabot> parse error on input `='
10:12:56 <matveev> thanks! But two times reverse is probably an overkill?
10:13:15 <faxathisia> is it?
10:13:38 <newsham> implement it without using reverse, count the operations
10:14:01 <mauke> > let l f x=case f x of{Left r->r;Right y->l f y};s(v,d,c)|v<d=Left(v,c)|True=Right(v-d,d+2,c+1);f n r=let(v,c)=l s(n*100,r*20+1,0)in chr(fromInteger c+48):f v(r*10+c)in f 1 1
10:14:03 <lambdabot>  "414213562373095048801688724209698078569671875376948073176679737990732478462...
10:14:04 <matveev> people say reverse is O(n)
10:14:07 <bakert> chomp p = reverse . dropWhile (== p) . reverse
10:14:10 <faxathisia> Woah :O
10:14:19 <byorgey> matveev: yup
10:14:20 <newsham> matveev: so is scanning to the end of the string
10:14:31 <faxathisia> what the hell
10:14:34 <newsham> so is constructing a new string without the tail element
10:14:51 <mauke> > let l f x=case f x of{Left r->r;Right y->l f y};s(v,d,c)|v<d=Left(v,c)|True=Right(v-d,d+2,c+1);f n r=let(v,c)=l s(n*100,r*20+1,0)in chr(fromInteger c+48):f v(r*10+c)in "1." ++ f 1 1
10:14:54 <lambdabot>  "1.4142135623730950488016887242096980785696718753769480731766797379907324784...
10:15:03 <newsham> chopping things off the tail of a list isnt a cheap operation
10:15:24 <balodja> mauke: that's omg! what algorithm do you use?
10:15:41 <mauke> one I found on wikipedia, more or less
10:15:53 <matveev> I see. Need to feel it, though.
10:16:32 <newsham> matveev: if you represent your list in reverse you can get rid of both reverses :)
10:16:50 <dmwit> matveev: It's hard to think of a language where that operation is not O(n).
10:17:25 <newsham> dmwit: if String = (array of char, length),  then removing trailing zeros is O(number of zeros)
10:17:48 <dmwit> newsham: What language uses that representation by default?
10:17:57 <mauke> perl
10:18:06 <Deewiant> D
10:18:08 <mauke> c++
10:18:14 <newsham> lots of IBMPC BIOS calls use pointer/length, no?
10:18:19 <newsham> its been a long time...
10:18:20 <Deewiant> C++ only in the library
10:18:25 <dmwit> Well, I guess C++ if you count the string class.
10:18:32 <dmwit> Okay, so there are some languages that do it. =)
10:18:58 <int-e> > let i x = let s n = (div (x-1) n + n+1) `div` 2; t n | n == s n = n | True = t (s n) in t 1 in i (2*10^1000)
10:18:59 <lambdabot>  1414213562373095048801688724209698078569671875376948073176679737990732478462...
10:18:59 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
10:19:12 <newsham> also if you represent yoru lists with snoc instead of cons, dropping trailing zeros is O(number of zeros)
10:19:28 <dmwit> Yes, if you use a different representation, this can be better.
10:19:57 <faxathisia> Pascal
10:20:23 <newsham> many of the unicode interfaces to the NT kernel use pointer/length/maxlength
10:31:03 <hpaste>  firefly pasted "simple bytestring example, counts bytes" at http://hpaste.org/3998
10:32:02 <hpaste>  firefly pasted "GHC Core for cnt' (main loop)" at http://hpaste.org/3999
10:33:14 <Saizan> in the Put monad, what's the most reasonable to put n bytes of tha same value? replicateM n (putWord8 b) or build a ByteString and use putByteString?
10:33:18 <hpaste>  firefly pasted "main loop in assembly" at http://hpaste.org/4000
10:34:03 <dcoutts_> Saizan: doesn't matter really.
10:34:57 <dcoutts_> firefly: yep, silly indirect jumps
10:35:00 <Saizan> ok :)
10:35:04 <dcoutts_> firefly: perfect core code though
10:35:07 <hpaste>  firefly pasted "command lines used with bytestring example" at http://hpaste.org/4001
10:35:26 <firefly> very silly, aren't they?
10:36:06 <firefly> using -fvia-C generates similar code that happens to take about 50% more time to execute (Athlon64 3000+)
10:36:25 <dons> the core code is perfect
10:36:52 <firefly> yes, I don't complain about the core code at all!
10:36:59 <dcoutts_> firefly: fortunately ghc HQ are working on these low level things now, mostly by getting in more interns and expert visitors
10:37:03 <dons> so what does -fasm look like?
10:37:10 <dons> you could make a bug report :)
10:37:20 <dons> give 'em the hurry up
10:37:21 <dcoutts_> dons: I think that is -fasm
10:37:42 <dons> "nice src, perfect core, suxors asm. plz fix kthx"
10:37:45 <dcoutts_> firefly: yes, that is a nice simple test case actually.
10:38:16 <dcoutts_> perfectly reasonable to post that as a ghc perf bug. It's not a bug they don't know about, but it'd be a nice one for them to test.
10:38:16 <firefly> I just think it's a pity that the optimizer(s) in ghc do so much -- combined with the heroic annotation magic (and other hard core stuff in ByteString) goes so far -- and then the final bit is lost due to naÃ¯ve machine code generation.
10:38:17 <dons> it would be worth to submit, just to get it in the test suite
10:38:25 <dons> yep.
10:38:43 <dons> we could beat ocaml daily, i reckon, with just a small improvement to the code generator
10:38:51 <dcoutts_> firefly: btw, you should be able to get the same core with just B.foldl' (+) 0
10:38:51 <dons> because the frontend is doing so well
10:39:27 <firefly> dcoutts: I wanted to NOT do anything more magic than what ByteString already does.
10:40:56 <firefly> dcoutts: it is -fasm (it's the default mode)
10:41:05 <dcoutts_> firefly: actually I'm a bit surprised that the code you used worked so well given that tail tests for the BS not being null.
10:41:45 <dcoutts_> firefly: so ghc is doing more magic in that example than in B.foldl' (+) 0  :-)
10:42:08 <hpaste>  firefly pasted "cnt' with -fvia-C" at http://hpaste.org/4002
10:42:14 <dcoutts_> because it's eliminating an extra test that is not present in the B.foldl' as that was written manually using unsafeTail
10:43:15 <dons> oh hmm
10:43:18 <hpaste>  firefly annotated "command lines used with bytestring example" with "added -fvia-C version" at http://hpaste.org/4001#a1
10:43:21 <dons> that's interesting
10:43:40 <dcoutts_> I wonder if that's call pattern specialisation that's eliminating that safe tail test
10:45:14 <dcoutts_> dons: does that sound plausible, or is it something else in the simplifier...
10:45:31 <dons> i'm not sure. i'm surprised it does so well, actually :)
10:45:39 <dons> see what -ddump-simpl-stats says
10:46:00 <dons> i don't think its specconstr, is it?
10:46:08 <dcoutts_> no, maybe not
10:46:11 <dons> there's no constructor on strict bytestrings to match on for null
10:46:31 <hpaste>  firefly pasted "cnt'/bytestrings, -ddump-simpl-stats" at http://hpaste.org/4003
10:46:35 <dons> the compiler sure loves these strict structures
10:46:39 <dozer> can operator overloading be used with monadic functions?
10:46:47 <dcoutts_> it amounts to: case x <= 0 of True -> e1; False -> case x <= 0 of True -> e2; False -> e3
10:47:01 <dcoutts_> becoming just case x <= 0 of True -> e1; False -> e3
10:47:06 <dons> lots of KnownBranch , that's interesting
10:47:11 <dcoutts_> right
10:47:19 <dcoutts_> it's KnownBranch, that's what this is
10:47:19 <dozer> so could I for example bind a->State s b to (.^)?
10:47:41 <dcoutts_> dons: and I suspect it's only because we're using *exactly* the same test in null as in tail/head
10:47:54 <dons> ah maybe
10:47:56 <dcoutts_> null (PS _ _ l) = l <= 0
10:48:02 <dcoutts_> head (PS x s l)
10:48:03 <dcoutts_>     | l <= 0    = errorEmptyList "head"
10:48:03 <dcoutts_>     | otherwise = ...
10:48:08 <dcoutts_> tail :: ByteString -> ByteString
10:48:09 <dcoutts_> tail (PS p s l)
10:48:09 <dcoutts_>     | l <= 0    = errorEmptyList "tail"
10:48:09 <dcoutts_>     | otherwise = ...
10:48:16 <dons> we get much worse code in 6.6.1
10:48:25 <dcoutts_> an extra case I bet right?
10:48:39 <dcoutts_> from using tail vs unsafeTail
10:48:47 <firefly> should I rerun under 6.6.1 and paste that code in, too?
10:49:21 <firefly> can I pass flags to gcc somehow when I use -fvia-C?
10:49:24 <dons> oh, helps if i turn on -O2
10:49:28 <dons> -optc-O2
10:49:48 <dcoutts_> dons: I'm only interested in the core really for this one
10:50:27 <firefly> thanks.  What if I tell gcc to do unit-at-a-time compilation?  that might make it visible to gcc that it doesn't need to spill/load all the time so the inner loop might become better.
10:50:38 <dons> the worker is the same, actually
10:50:53 <dons> a loop, unboxed, checking for len 0
10:51:18 <dons> rather good effort for ghc to remove sort that tail check/null check
10:51:44 <firefly> how does ghc know what C compiler to invoke?  CC env var + default to 'gcc' in current path?
10:51:52 <dons> env,yeah
10:52:40 <firefly> so "CC=gcc-4.x ghc -fvia-C -O2 -optc-xxx --make ..." should let me play :)
10:52:55 <dcoutts_> firefly: no, -funit-at-a-time would not help. Indeed ghc uses -fno-unit-at-a-time because it breaks things :-)
10:53:02 <firefly> damn :(
10:53:14 <dcoutts_> firefly: anyway, ghc strips the function entry and exit points off of all functions
10:53:32 <firefly> how do I tell ghc to dump the C code it passes to gcc (when compiling with -fvia-C)?
10:53:44 <dcoutts_> firefly: -ddump-hc iirc
10:53:50 <firefly> oh, yeah, right, it does funny things with the assembly output.
10:54:00 <dcoutts_> see the ghc manual for all the -ddump-* flags
10:54:46 <dcoutts_> firefly: the problem with that stack reloading is in the STG -> CMM pass, though it could also be solved in a CMM -> CMM pass. That's what ghc HQ are working on I believe.
10:54:52 <firefly> I don't want to use -funit-at-a-time to crumble everything into one big function.  I wanted to use it to let gcc have enough static knowledge about the program to know that nobody else needs to look at the "thunk variables" so they all can stay in registers.
10:55:06 <dcoutts_> a CMM -> CMM pass to turn tail recursive calls into proper loops
10:55:42 <dcoutts_> firefly: I really don't think you'll get very far with getting gcc to do a better job on the C code ghc produces.
10:56:05 <dcoutts_> ghc needs to produce better CMM (and thus better C or direct asm code)
10:56:13 <firefly> (CMM = C--, which I haven't looked at in years)
10:56:46 <firefly> -ddump-flatC sounds like what I want.
10:57:39 <dcoutts_> firefly: or look at the cmm code, it's often neater than the C code.
10:59:00 <MyCatVerbs> firefly: surely you want Cmajor?
10:59:16 <MyCatVerbs> firefly: Cflat will just sound dreadful, and all the ballroom dancers will get depressed listening to it.
11:00:03 <firefly> possibly.  -ddump-flatC doesn't seem to do anything, anyway :(
11:00:22 <MyCatVerbs> Possibly I was joking.
11:00:41 <MyCatVerbs> Uh, unless that was *you* making a joke that just went over my head.
11:00:55 <MyCatVerbs> Quite possible, my sense of humour is broken right now.
11:01:14 <hrehf> hmmm, what's wrong with 'parseFile filename = do file <- readFile "test"'? -> Couldn't match expected type `[t]' against inferred type `IO String'
11:04:37 <byorgey> hrehf: did you give parseFile an explicit type signature?
11:05:38 <hrehf> byorgey hm, yes, it was String -> [Float], but IO String -> [Float] pops up the same error :(
11:05:41 <firefly> nope, I don't see how I can dump the C code :(
11:06:01 <firefly> -ddump-flatC doesn't seem to do anything in 6.8.1 or 6.6.1.
11:06:28 <byorgey> hrehf: looks like the type should be something like String -> IO String to me
11:06:45 <byorgey> @type readFile
11:06:47 <lambdabot> FilePath -> IO String
11:07:04 <firefly> MyCatVerbs: I did get the joke (C flat, C sharp, minor, major, etc).  Was just to busy thinking about how to dump out the intermediate C code.
11:07:17 <byorgey> hrehf: what are you trying to do?
11:07:35 <byorgey> hrehf: maybe it would be good if you pasted your code.
11:07:37 <byorgey> @paste
11:07:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:07:55 <hrehf> byorgey just trying to read a file and call a function on the resulting sdtring, then return the result
11:08:33 <byorgey> hrehf: ok, but since you are reading from a file, the result will have to be in the IO monad.
11:09:54 <hrehf> byorgey hmmmm, http://hpaste.org/4004
11:10:29 <newsham> what do you want to do with the floats when you parse them?
11:10:43 <hrehf> (and i need a way to make the print "" dissappear, or maybe i didn't yet understand the part in the wikibook)
11:10:58 <hrehf> newsham various stuff, transform polar coordinates, etc
11:11:19 <newsham> if you get rid of the "print """ and change "parseLines file" to "return (parseLines file)" it might be what you want
11:11:29 <newsham> read the file, parse the results, set the result to the parsed results
11:11:46 <newsham> the "return" will turn [Float] into "IO [Float]"
11:12:09 <newsham> your last line in the do-block needs to be an IO action with the proper result value
11:12:18 <hrehf> hm, do i still keep the -> IO String -> part?
11:12:33 <hrehf> yeah, i really have to read up on the do/action/monads
11:12:37 <newsham> parseFile will take a String and return an IO [Float]
11:12:43 <hpaste>  byorgey annotated "(no title)" with "try this" at http://hpaste.org/4004#a1
11:12:59 <byorgey> ^^^ what newsham said =)
11:13:04 <newsham> the do-block basically combines together a series of IO actions, and gives you the result of the last one.
11:13:34 <byorgey> I think a better way to say it is that it combines together a series of IO actions into one big IO action.
11:13:37 <hrehf> ah, that makes a lot of sense - and it works now, thanks!
11:13:56 <newsham> so:   do { file<- readFile filename; return (parseLines file) }  combines together "readFile filename" (an IO String) and "return (parseLines file)" (an IO [Float])
11:14:10 <newsham> into a larger  IO [Float]   action
11:14:48 <hrehf> hmmm, could i just return the IO String from readFile and feed it into parseLines?
11:14:54 <newsham> although I think you might be better off just doing all of the IO in main, using a pure function to do all the processing, and then printing out the result of the pure function in main
11:15:08 <newsham> that way you have a very small set of IO code wrapping a lot of pure code
11:15:34 <hrehf> newsham yeah, but i have to read in lots of files, and i'd like to seperate that out a bit more
11:15:34 <dmwit> hrehf: Yes, but you would need to "lift" parseLines into the IO monad first.
11:15:43 <newsham> main = do { data <- readFile filename; print (process data) }
11:15:49 <newsham> then all of the "process" code can be ignorant of IO
11:15:56 <newsham> I see.
11:15:59 <dmwit> :t liftM
11:16:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:16:10 <newsham> ?src liftM
11:16:10 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:16:24 <newsham> liftM is just a small helper for that do-block pattern
11:16:44 <newsham> ie, your parseFile function is   liftM parseLines (readFile filename)
11:16:49 * hrehf reads
11:16:51 <newsham> (see how it lines up with your code?)
11:17:42 <newsham> in your block "m1" is "readFile filename",  "x1" is "file" and "f" is "parseLines"
11:18:25 <newsham> hrehf: can you explain what you're doing with all of the files?
11:18:27 <hrehf> ah
11:18:50 <newsham> you might be able to use a helper such as mapM
11:19:36 <newsham> ie:   datas <- mapM readFile [fn1, fn2, fn3, fn4]
11:19:56 <hrehf> newsham yes of course, it's a set of scan data from a laser scanner of a robot, each file represents one scan, i have to calculate x/y world values for each file and later average on each 'scanline', etc
11:20:09 <newsham> would bind datas to a list of four strings, each containing the file contents of your files fn1, fn2, fn3 and fn4
11:20:18 <MyCatVerbs> firefly: perhaps the joke was not funny. :(
11:20:30 * oerjan thinks mapM readFile looks scary
11:20:49 <oerjan> easy to run out of fd's
11:21:07 <newsham> so you could do   main = do { let files = whatever; data <- mapM readFile files; let results = map process data; mapM_ print results }
11:21:08 <Jaak> huh. mapM readFile is quite nice
11:21:17 <newsham> and then still have your "process" be all pure code.
11:21:20 <newsham> for example
11:21:26 <hpaste>  firefly pasted "C code as fed to gcc" at http://hpaste.org/4005
11:21:51 <firefly> ghc generates astonishingly ugly C code :(
11:22:02 <hrehf> newsham wow, yeah, that is a lot more elegant
11:22:13 <dons> firefly: its an asm really
11:22:28 <newsham> the "let" statements are for binding the results from a pure calculation
11:22:28 <firefly> yeah...
11:22:36 <newsham> and the "var <- ..." are the IO action results
11:23:10 <newsham> mapM runs "readFile" on each of the files.  mapM_ runs "print" on each of the results, but doesnt collect the return value from print
11:23:20 <newsham> (mapM collects results, mapM_ doesnt collect results)
11:23:46 <oerjan> hrehf: mapM_ (print . process . readFile) files if you want to be even more elegant
11:24:01 <newsham> yah even better
11:24:16 <newsham> except you need a liftM in there, no?
11:24:21 <oerjan> er yeah
11:24:41 <hrehf> ;)
11:24:42 <newsham> print / readFile are IO, process is pure
11:24:53 <hrehf> so i need liftM on both ?
11:25:01 <hrehf> or waity, the other way round
11:25:16 <oerjan> the new <=< should be nice for such things
11:25:29 <newsham> mapM_ (\fn -> do data <- readFile; print (process data)) files
11:25:47 <oerjan> mapM_ (print . process <=< readFile) files iiuc
11:25:54 <dons> nice
11:25:58 <newsham> oerjan: thats not beginner code
11:26:03 <dons> i've not seen <=< used in here
11:26:08 <faxathisia> :t (<=<)
11:26:14 <lambdabot> Not in scope: `<=<'
11:26:15 <oerjan> it's new in 6.8.1
11:26:18 <oerjan> iiuc
11:26:22 <dons> yep
11:26:26 <dons> along with forever
11:26:40 <faxathisia> wherre is it documented?
11:26:53 <oerjan> @docs Control.Monad
11:26:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
11:27:00 <faxathisia> :(
11:27:14 <newsham> hrehf: the simplest way to do what they're saying would be to define a helper "processFile fn = do data <- readFile; print (process data)"
11:27:26 <newsham> then "main = mapM_ processFile [list, of, file, names]"
11:28:48 <newsham> if you're an imperative programmer, a nice analogy to a for loop is:    main = forM_ [list,of,file,names] (\fn -> do data <- readFile fn; print (process data))"
11:28:59 <newsham> forM_ is just mapM_ with the arguments in a different order
11:29:08 <newsham> but it reads similarly to a for loop in imperative languages
11:29:15 <hrehf> map is fine ;)
11:29:44 <newsham> (or more like a "foreach" loop)
11:30:08 <hrehf> hehe, lots of stuff to read up & try out
11:30:30 <newsham> when you're starting out i think its usually easiest to try to isolate the IO stuff into a few small simple functions
11:30:36 <newsham> until you get the hang of monads
11:30:47 <hrehf> yeah, sounds like a good idea
11:31:33 <hrehf> thanks for all the input btw, _very_ nice to have such a friendly channel!
11:31:45 <newsham> good luck and have fun
11:32:00 <hrehf> ;)
11:33:21 <sorear> @users
11:33:22 <lambdabot> Maximum users seen in #haskell: 418, currently: 406 (97.1%), active: 19 (4.7%)
11:34:45 <conal> Hey -- my recent Google techtalk is up on YouTube: http://www.youtube.com/watch?v=faJ8N0giqzw . "Tangible Functional Programming: a modern marriage of usability and composability"
11:34:47 <lambdabot> Title: YouTube - Tangible Functional Programming
11:35:07 <Jaak> sweet
11:35:18 <byorgey> conal: awesome!
11:35:25 <conal> :)
11:35:38 * byorgey fights the temptation to watch it right now
11:36:16 <Orphi> !seen dcoutts
11:36:23 <dcoutts_> @yarr!
11:36:23 <lambdabot> This is the END for you, you gutter-crawling cur!
11:36:32 <Orphi> lolz!
11:36:35 <dcoutts_> hia Orphi
11:36:41 <Orphi> well, it kinda worked anyways... lol
11:36:44 <Orphi> hi Duncan.
11:36:56 <Orphi> do you still need somebody to test this Cabal bug?
11:36:59 <conal> i redesigned my icfp talk.  in the new version i relate to the original unix philosophy, which unix couldn't really fulfill.
11:37:17 <dcoutts_> Orphi: the windows ld.exe one?
11:37:27 <Orphi> ye
11:37:46 <dmwit> conal: How long is the talk, finally, about an hour?
11:38:08 * dcoutts_ checks cabal-devel mailing list to see if anyone has tested already...
11:38:23 <conal> dmwit: yes.  aboutu an hour.
11:39:22 <dcoutts_> Orphi: nope, nobody else has checked it yet
11:39:28 <dcoutts_> Orphi: so that'd be great if you could
11:39:43 <Orphi> dcoutts_: okies, what do I need to do to install HEAD then? :-}
11:39:59 <bos> conal: how did your google talk go?
11:40:05 <dcoutts_> Orphi: darcs get --partial http://darcs.haskell.org/cabal/
11:40:10 <lambdabot> Title: Index of /cabal
11:40:18 * Orphi does it...
11:40:24 <conal> bos: well, i think.  i had a good time, and had some some conversations afterward.
11:40:32 <bos> conal: great!
11:40:45 <dcoutts_> Orphi: then do the ordinary stuff, runghc Setup.hs configure
11:41:09 <dcoutts_> Orphi: in fact that command on it's own should be enough to check, especially if you use -v to see which ld.exe it found.
11:41:10 <conal> and it (and the intel & apple versions the next two days) got me more revved up about the idea of composable apps.
11:41:41 <bos> conal: excellent
11:41:45 <Orphi> dcoutts_: so it'll be trying to configure itself using itself?
11:41:51 <dcoutts_> Orphi: yes.
11:41:54 <conal> bos: yeah.  thanks again for the help.
11:42:03 <Orphi> dcoutts_: what, before it's installed itself? heh
11:42:08 <Orphi> hmm... I'm confusing myself....
11:42:15 <newsham> "which unix couldn't really fulfill"  wow.  thems fightin' words :)
11:42:25 <Orphi> wow, that darcs get took *ages*! :-.
11:42:30 <dcoutts_> Orphi: that's how we bootstrap Cabal. It uses it's own source tree so does not depend on any existing installation.
11:42:42 <newsham> i look forward to watching your talk
11:42:46 <Orphi> dcoutts_: 31337.
11:42:57 <Orphi> dcoutts_: ok, I'm going to press the button now...
11:43:24 <dcoutts_> Orphi: expect it to be initially slow, since runghc has to interpret all the Cabal code
11:43:30 <dcoutts_> some ~35 modules
11:43:40 <Orphi> dcoutts_: configure reports no errors.
11:43:54 <dcoutts_> Orphi: run with -v and see where it finds ld.exe
11:44:00 * Orphi does it
11:44:25 * Orphi scrolls many pages of output
11:44:52 <conal> newsham: i really love the unix vision, especially as doug mcilroy expressed it.  and i don't think it can work with explicit IO code mixed in with functionality.
11:45:10 <Orphi> dcoutts_: "Using ld found on system at: C:\ghc\ghc-6.8.1\gcc-lib\ld.exe"
11:45:21 <conal> and IO programming in Haskell doesn't really help
11:45:30 <dcoutts_> Orphi: and that dir is not in your %PATH% correct?
11:45:42 <Orphi> dcoutts_: not at the moment it isn't, no.
11:45:52 <dcoutts_> Orphi: ok great. Thanks very much.
11:45:59 <newsham> conal: unix tools compose pretty nicely.  they're not really aiming to have nice distributive/associative proerties so you can optimize over them.
11:46:11 <Orphi> dcoutts_: are you going to announce the good news to haskell-cafe, or shall I? ;-)
11:46:45 <dcoutts_> Orphi: feel free. I've sent the patch to be validated so it'll get into the next release which will come with ghc-6.8.2
11:46:52 <newsham> also it all worked a lot nicer when people actually believe in the unix vision ;-)
11:46:58 <newsham> believed
11:47:13 <Orphi> dcoutts_: any reason why I can't actually install the cabal 1.3 I just configured?
11:47:27 <Orphi> dcoutts_: you know, so I won't have this particular problem again? ;-)
11:48:06 <dcoutts_> Orphi: If I were you, I'd stick with the Cabal-1.2 branch since we promise api stability there. 1.3 is the development branch
11:48:17 <Orphi> dcoutts_: ok, will do.
11:48:22 <Orphi> dcoutts_: thanks for fixing ;-)
11:48:45 <dcoutts_> Orphi: so if you want to get that fix in the stable version, darcs get the 1.2 branch and push the patch over.
11:49:22 <dcoutts_> or wait a bit and we'll get the patch into the 1.2 branch soonish
11:49:26 <Orphi> dcoutts_: weeee, decentralised changeset management. lol
11:49:44 <dcoutts_> yep
11:49:51 <conal> newsham: it's more than just optimization.  lack of GUIs & graphics, only linear composition, everything-is-char-stream, ...
11:50:07 <sorear> but everything IS a char stream
11:50:14 <dmwit> Noes!
11:50:25 <dmwit> The video broke about 15 minutes in.
11:50:34 <Orphi> dcoutts_: well, given how little I use Cabal, I'll wait for the stable update. it only takes a path twiddle to work round...
11:50:56 <newsham> *nod*  you can get non-linear (but acyclic) composition pretty easily (some shells support it).  GUI I getyour point.  powershell (monad shell) supports non-char streams as do a few other experimental system.
11:51:04 <newsham> but I should watch your video before trying to argue :)
11:51:07 <dcoutts_> Orphi: do you use cabal-install too btw? We're looking for windows testers and developers for that.
11:51:23 <Orphi> dcoutts_: "what is cabal-install?"
11:51:41 <dcoutts_> Orphi: it's a tool for downloading and installing package from hackage.
11:51:53 <dcoutts_> eg: cabal install zlib
11:52:03 <Orphi> chase depends?
11:52:05 <dcoutts_> yep
11:52:11 <Orphi> most optimal...
11:52:35 <Orphi> doesn't that require that package names be unique?
11:52:45 <dcoutts_> on hackage they are.
11:52:52 <Orphi> already?
11:53:08 <Orphi> I thought I remembered there being at least 4 packages all called "binary"...
11:53:37 <dcoutts_> Orphi: there are several versions of binary and there are some other libs for dealing with binary stuff but with different package names
11:54:18 <Orphi> wait... "Binary", "New Binary" and "Alt Binary" or something, IIRC
11:54:27 <dmwit> conal: I find this talk very interesting.
11:54:34 <newsham> I cant believe its not Binary
11:54:35 <sorear> Orphi: only binary is called binary
11:54:47 <Orphi> sorear: lol, ok.
11:54:50 <sorear> Orphi: newbinary isn't called binary - it's called newbinary
11:54:59 <sorear> Orphi: altbinary isn't called binary - it's called altbinary
11:55:15 <sorear> Orphi: ghcbinary isn't called binary - it's called ghcbinary
11:55:30 <Orphi> sorear: my point being, there are several libraries with very similar names, and I find it a tad confusing...
11:55:31 <dmwit> I have recently also been thinking about all the different ways that programs get information (pipes, environment variables, command-line arguments, GUI input...) and how to redirect these things between programs, so this is relevant to my interests. =)
11:55:33 <conal> dmwit: i'm glad!
11:55:34 <dcoutts_> $ cabal list binary
11:55:35 <dcoutts_> binary [0.2, 0.3, 0.4, 0.4.1]      Binary serialization for Haskell values using lazy ByteStrings
11:55:35 <dcoutts_> NewBinary [0.1]                    A binary I/O library
11:56:00 <dcoutts_> Orphi: it does searching too :-)  ^^^
11:56:06 <sorear> Orphi: that's your problem to deal with.  cabal-install doesn't get confused by names that are merely similar, since it uses exact matches
11:56:29 <matthew-_> so since computers don't get confused, humans shouldn't either?
11:56:43 <newsham> plan9 has a few composable mechanisms besides pipes..  for example the acme editor integrates shell command processing with cut&paste and command clicks
11:57:01 <dmwit> conal: I've been trying to come up with a (text) language for doing this kind of redirection, but using a GUI for it instead is an intriguing idea.
11:57:08 <newsham> or the plumbing mechanism abstracts the concept of clicking on things to invoke actions
11:57:21 <Orphi> dcoutts_: so how do I get this marvelous tool?
11:57:29 <Orphi> dcoutts_: cabal-install cabal-install? ;-)
11:57:49 <dcoutts_> Orphi: if you had cabal-install then yes, that'd work :-)
11:58:00 <dcoutts_> otherwise get it manually from hackage
11:58:06 * dcoutts_ disappears
11:58:27 <conal> dmwit: and the composition framework is much more general than GUIs.  See the DeepArrow and TV libraries.
11:58:39 <Orphi> mmm... impressive.
11:58:51 <Orphi> wish *I* could dissappear like that sometimes!
11:59:57 <dmwit> Okay, I'll have a look.
12:00:23 <dmwit> I can't guarantee I'll understand it, though. =)
12:00:38 <dmwit> I've only just read my first paper on Arrows yesterday.
12:01:46 <Inspico> @seen augustss
12:01:47 <lambdabot> I saw augustss leaving #haskell 23h 38m 13s ago, and .
12:01:51 <Inspico> hmm
12:01:58 <kmonz> can I have a type class with functions that operate on tuples OR lists of elements of some type, and impose constraints on the ELEMENTS of those tuples or lists?
12:02:24 <thetallguy> Could someone with a working 6.8.1 on a Unix system verify that this returns True in ghci?  System.Posix.User.getAllUserEntries >> System.Posix.User.getAllUserEntries >>= return . (/= [])
12:03:02 <Zao> Define "unix"?
12:03:17 <firefly> it's true here (on 6.8.1, ubuntu feisty fawn)
12:03:18 <Zao> True on FreeBSD x86 at least.
12:03:19 <newsham> operating system written by the research group at bell labs
12:03:28 <thetallguy> anything with Posix
12:03:39 <thetallguy> Zao: thanks.
12:04:12 <sorear> thetallguy: I've seen that in the tracker
12:04:13 <thetallguy> firefly: perfect, thanks as well.
12:04:23 <thetallguy> sorear: yes, I saw it was marked fixed
12:04:42 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1279
12:04:43 <sorear> oh
12:04:44 <lambdabot> Title: #1279 (System.Posix.User.getAllUserEntries should call setpwent) - GHC - Trac
12:04:45 <thetallguy> sorear: just wanted to verify, but my machine with 6.8.1 is down.
12:05:20 <thetallguy> it was most puzzling when I ran it on 6.6 and it gave an empty list the second time.
12:05:44 <thetallguy> I'd forgotten all about that behavior of getpwent.
12:07:18 <Orphi> @yarr!
12:07:18 <lambdabot> Well Ahoy! thar.
12:07:24 <newsham> conal: not sure if you can receive private messages, but I sent some to you (might go into a different window)
12:07:24 <Orphi> lolz!
12:07:38 <dmwit> conal: I haven't gotten very far in the talk, so maybe you answer this later.
12:08:17 <dmwit> conal: Does your idea extend to dealing with interfaces that may, say, do a database update when the user clicks a button or something?
12:09:06 <dmwit> conal: Say, in bug-tracking program or something, where there's some dialog for creating a new bug.
12:11:23 <conal> dmwit: i think so.  the first step is to tease out the semantic part from the interface part.
12:12:01 <alexj> @seen alex
12:12:01 <lambdabot> I haven't seen alex.
12:12:39 <dmwit> Well, even if we just look at displaying a list of bugs (which seems to have a clear semantic/interface divide), the problem I see is that the display needs to vary by time.
12:13:03 <sorear> Iskandor: /whois newsham
12:13:07 <sorear> beh
12:13:13 <newsham> hi!
12:13:39 <conal> dmwit: what's the problem with time-varyin?
12:13:42 <thetallguy> tuples suck.
12:13:48 <conal> time-varying?
12:13:49 <Orphi> lol. who needs lambdabot? just hell HEY DONS!!
12:13:59 <Orphi> or whatever.
12:14:02 <sorear> Orphi: dons has a job now
12:14:21 <dmwit> Well... I'm not sure.  I mean, you wouldn't send time as an argument to the function...
12:14:42 <Orphi> sorear: I just picked the first name that came into my head, that's all...
12:15:00 <dmwit> I mean, you would have a function of type Username -> IO [Bug] or something.  The IO bit isn't a problem?
12:16:08 <dmwit> I guess I should hold my questions until I really understand what is going on. =P
12:17:32 <conal> dmwit: IO is always a problem for composability.  the less IO the more composable.  if necessary, Eros can handle any Haskell type, including IO.
12:17:48 <noecksit> hello, after a while of thinking, i think i realized how to make the merge program work for two files
12:18:20 <faxathisia> grahamhutton: I just read your paper on solving Coundown problems :D
12:18:26 <faxathisia> That was really fun, thanks for it!
12:18:40 <noecksit> i need to find the longest common subsequence of all the lines that the two lists have in common and put that in a different list
12:18:47 <thetallguy> @src uncurry
12:18:47 <lambdabot> uncurry f p = f (fst p) (snd p)
12:18:52 <grahamhutton> hi faxathisia --- glad you enjoyed it; I had a lot of fun doing this!
12:18:57 <firefly> dons, dcoutts: after playing a bit more I can make the C backend a bit faster with -optc -fstrict-aliasing, which probably breaks all sorts of things in interesting subtle ways.
12:19:10 <firefly> But it does turn out to be slightly faster than the native backend!
12:19:41 <noecksit> then i would search through the first list, and anything up to the first occurance of the common LCS would be included in the final list
12:20:03 <grahamhutton> faxathisia: you may also like Richard Bird's paper on sudoku, which along similar lines.
12:20:13 <faxathisia> cool
12:20:14 <noecksit> then stop and wait for the other file to do the same, until it reaches the LCS again
12:20:19 <faxathisia> that might help actually
12:20:32 <zeeeee> to make something like hGetContents strict, is there any less verbose way than the following (or defining this strict version for every such function)? ...; x <- hGetContents h; x `seq` return (); ...
12:20:44 <faxathisia> (I'm trying to solve minesweeper in a faster way than outputting prolog code and running that :p)
12:20:47 <noecksit> then finally include the line in the LCS, and repeat over again from where i stopped
12:21:19 <noecksit> now all i need to get started is find out how to implement longest common subsequence in haskell
12:21:22 <oerjan> zeeeee: actually that won't even work
12:21:35 <oerjan> you need length x `seq` or something
12:21:51 <grahamhutton> faxathisia: there is a page about various minesweeper implementions in Haskell
12:21:52 <grahamhutton> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Games/
12:21:53 <lambdabot> Title: Minesweeper in Haskell
12:22:10 <oerjan> :t rnf
12:22:12 <faxathisia> oh cool
12:22:13 <lambdabot> forall a. (NFData a) => a -> Done
12:22:15 <faxathisia> grahamhutton: thanks!
12:22:51 <zeeeee> oerjan, hm. you're right. all the more motivation for my question :)
12:23:12 <hpaste>  firefly pasted "fastest bytestring test with C backend" at http://hpaste.org/4006
12:24:15 <oerjan> zeeeee: you could use the strict bytestring version
12:24:18 <byorgey> noecksit: maybe you'd find this interesting: http://alangloria.blogspot.com/2006/11/okay.html
12:24:19 <lambdabot> Title: As L approaches Hack-Level
12:25:42 <zeeeee> oerjan, i know, but that was really to ask about any lazily evaluated functions in IO
12:25:48 <thetallguy> @pl \(x,(y,z)) -> (x,y,z)
12:25:48 <lambdabot> uncurry ((`ap` snd) . (. fst) . (,,))
12:27:06 <noecksit> wow, i was just looking at this example
12:27:16 <noecksit> thats actually how i got inspired by the LCS
12:27:41 <oerjan> :t liftM (`using` rnf)
12:27:42 <lambdabot> forall a1 (m :: * -> *). (NFData a1, Monad m) => m a1 -> m a1
12:28:14 <oerjan> zeeeee: i think those Control.Parallel.Strategies might do what you want
12:28:23 <oerjan> *functions might
12:29:03 <oerjan> or wait...
12:29:28 <oerjan> it still might not actually force the evaluation of the result
12:32:28 <dmead> hmm
12:32:37 <dmead> i'm trying to implement takewhile in C
12:32:50 <faxathisia> dmead: on what datastructure?
12:32:59 <dmead> a linked list
12:33:19 <faxathisia> @src takeWhile
12:33:20 <lambdabot> takeWhile _ []                 =  []
12:33:20 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
12:33:20 <lambdabot>                    | otherwise =  []
12:33:34 <dmead> right right
12:33:35 <faxathisia> remember to use goto instead of recursion in C :p
12:33:38 <dmead> :P
12:33:41 <dmead> hmm
12:33:45 <oerjan> :t evaluate
12:33:46 <lambdabot> Not in scope: `evaluate'
12:33:56 <faxathisia> (since c is stupid and doesn't define TCO)
12:33:57 <byorgey> dmead: unfortunately, you can't get any sharing, you'll have to clone all the nodes you take...
12:34:02 <oerjan> :t System.IO.evaluate
12:34:03 <lambdabot> Not in scope: `System.IO.evaluate'
12:34:10 <oerjan> oh well
12:34:22 <dmead> byorgey, correct because i want it to return a new list
12:34:33 <newsham> takeWhile(node *n, pred_t p) { if(n && p(n)) { return newNode(n->data, takeWhile(n->next, p)); } return 0; }
12:35:26 <dmead> but i'm doing it with void pointers, so im at a loss on how to copy the data pointed to buy a pair of void*
12:35:38 <faxathisia> assignment
12:36:13 <bos> Data.Array.IArray's ixmap is one of the great underdocumented haskell functions.
12:36:16 <faxathisia> you can't copy a block of memory pointed to, unless you know how big it is
12:36:21 <dmead> right
12:36:24 <dmead> le sigh
12:36:36 <newsham> dmead: you dont have to copy the data, you can copy the pointers
12:36:47 <dmead> i don't want to copy the pointers
12:36:54 <dmead> there should be a brand new list returned
12:36:59 <kscaldef> dmead: sounds like your list structure needs to know how to make a copy of the data
12:37:05 <dmead> indeed
12:37:08 <MacGuges> I've run into a configure problem with darcs. I'd like to try xmonad, I'm new to haskell, and I use gentoo. I got this error, 'configure: error: Couldnt figure out how to call GHC.Handle.openFd!' Can anyone shed some light on this?
12:37:08 <dmead> hmm
12:37:15 <newsham> then erhaps you want to specify a generic object type that either has ref counting or has a size field
12:37:54 <dmead> yea
12:38:05 <dmead> and i suppose it's not exactly takewhile
12:38:49 <dmead> takewhile terminates on the first occurrence of an item that doesn't match the given criteria
12:38:50 <noecksit> would two dimensional arrays in Haskell would be implemented as lists inside lists?
12:39:03 <dmead> yea
12:39:06 <dmead> [[a]]
12:39:11 <dmead> is a list of list of type a
12:39:12 <dmwit> MacGuges: Try #xmonad.
12:39:25 <newsham> noe: thats one way to go.  there are lots of options.
12:39:27 <MacGuges> dmwit: ok, thanks
12:39:28 <faxathisia> noecksit: It's just a 1D array, but they are index by 2 tuples instead of Inteegers
12:39:35 <dmead> yea
12:39:35 <newsham> for example, you could make an array indexed by tuples
12:39:38 <dmead> arrays would be faster
12:40:05 <noecksit> i just wanted to know whether something like [1..2][3..4] were possible
12:40:12 <dmead> yea sure
12:40:23 <dmead> > [[1..3],[3..5]]
12:40:25 <lambdabot>  [[1,2,3],[3,4,5]]
12:40:37 <faxathisia> noecksit: What does [1..2][3..4] mean?
12:40:38 <dmead> etc
12:40:58 <faxathisia> Do you want to find the cartesian product?
12:41:01 <dmead> > [[1..10],[11..20]]
12:41:02 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20]]
12:41:03 <dmwit> > [(i, j) | i <- [1..2], j <- [3..4]]
12:41:03 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
12:41:04 <vwx> @seen Lemmih
12:41:04 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 5h 5m 22s ago.
12:41:26 * shapr hugs Lemmih 
12:41:27 <dmwit> > do { i <- [1..2]; j <- [3..4]; return (i, j) }
12:41:27 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
12:41:36 <dmead> > listM2 (,) [1..10] [11..20]
12:41:37 <lambdabot>   Not in scope: `listM2'
12:41:40 <dmead> > liftM2 (,) [1..10] [11..20]
12:41:41 <lambdabot>  [(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20),(2,11...
12:42:04 <firefly> Doesn't hgc pay a performance penalty on Pentium 4 because it places data tables very close to code?
12:42:14 <dmwit> Yeah, liftM2 (,) works for everything but infinite lists.
12:42:22 <thetallguy> @pl \(w,(x,(y,z))) -> (w,x,y,z)
12:42:24 <dmead> > liftM2 (,) [1..] [11..]
12:42:24 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . (,,,))
12:42:25 <lambdabot>  [(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20),(1,21...
12:42:41 <noecksit> nah, i just wanted to know how i can create a two dimensional list where is can access their elements by their index
12:42:45 <dmwit> dmead: It never gets to (2,11).
12:42:49 <firefly> I seem to recall a performance bug in an older version of gcc because it did something like that for jump tables it used in switch/case statements.
12:42:58 <aref> in defining a data type Quadruple (data Quad a b = Quad a a b b), is there any place that describes types in Haskell in a clear and concise way? I'm having trouble grasping why a b = a a b b
12:43:00 <dmead> dmwit, it's still correct though :P
12:43:00 <faxathisia> noecksit: You can use Array
12:43:09 <dmwit> dmead: I don't consider that to be correct.
12:43:11 <faxathisia> noecksit: whic hhis like arr ! (row,col)
12:43:13 <dmead> :P
12:43:14 <firefly> But maybe the ghc tables aren't referenced all that often?
12:43:19 <faxathisia> noecksit: or (listOfLists!!0)!!3
12:43:21 <dmwit> dmead: I should be able to reach any finite tuple in finite time.
12:43:57 <faxathisia> aref: Quad is parameterized on two types a and b (any types a and b)
12:44:02 <dmead> i suppose
12:44:09 <allbery_b> aref: try the wikibook?
12:44:18 <faxathisia> aref: And (Quad a a b b) is a particualr type of Quad, which data layed out in that way
12:44:31 <faxathisia> aref: Just like you you could do (Quad Int Int Double Double)
12:44:34 <allbery_b> in any case it's data typename typeparams = constructor type ...
12:44:38 <noecksit> i think (n!!0)!!0 works!
12:44:39 <dmead> what would you guys call takewhile if it didn't terminate when a comparison failed?
12:44:49 <dmead> and just kept going down the list till it was done
12:44:50 <faxathisia> dmead: rubbish
12:44:52 <allbery_b> given your type params are a and b, they only need to be named once in the type params section
12:44:59 <faxathisia> dmead: oh .. that would be terminating
12:45:01 <allbery_b> where they're used, you use them as needed
12:45:19 <dmead> faxathisia, right, i'm just wondering why that function isn't in the stdlib
12:45:20 <aref> hm, I think I see :)
12:45:23 <dmead> it seems much more useful
12:45:26 <allbery_b> @where wikibook
12:45:26 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:45:42 <dmwit> dmead: filter?
12:45:54 <dmead> ?src filter
12:45:54 <lambdabot> filter _ []     = []
12:45:55 <lambdabot> filter p (x:xs)
12:45:55 <lambdabot>     | p x       = x : filter p xs
12:45:55 <lambdabot>     | otherwise = filter p xs
12:45:56 <dmead> ahh
12:49:21 <Taejo> @pl foldr (\x xs -> if p x then x:xs else xs) [] xs
12:49:21 <lambdabot> foldr (join . ap ((.) . if' . p) (:)) [] xs
12:50:03 <Taejo> @pl filter p xs = foldr (\x xs -> if p x then x:xs else xs) [] xs
12:50:04 <lambdabot> filter = flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
12:51:10 <Taejo> is there a reason filter is defined recursively rather than as a fold?
12:51:58 <dmwit> It's only specified recursively.
12:52:06 <dmwit> I believe that actual implementation is much hairier.
12:52:37 <dmwit> Or... less hairy, depending on how you look at it. =)
12:52:51 <faxathisia> @unpl (((.) . if')
12:52:51 <lambdabot> Unbalanced parentheses
12:52:56 <faxathisia> @unpl (((.) . if'))
12:52:56 <lambdabot> (\ f b c -> if' f (b c))
12:53:26 <faxathisia> @unpl (((.).(.)).((.).(.)))
12:53:26 <lambdabot> (\ o b c f i l -> o (b c f i l))
12:53:27 <Taejo> dmwit, in Hugs's prelude: filter p xs       = [ x | x <- xs, p x ]
12:53:43 <dmwit> Taejo: Very pretty. =)
12:53:50 <thetallguy> @pl \(v, (w,(x,(y,z)))) -> (v,w,x,y,z)
12:53:53 <lambdabot> ap ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (,,,,) . fst) snd
12:53:53 <lambdabot> optimization suspended, use @pl-resume to continue.
12:54:17 <Taejo> but don't list comprehensions get de-sugared to filter and map?
12:54:24 * sjanssen tries to understand http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fixpoint-0.1
12:54:26 <lambdabot> http://tinyurl.com/22f8bv
12:54:41 <newsham> "guis are types"  neat.  I want djinn for guis
12:54:42 <sjanssen> Taejo: they're desugared to concatMap, actually
12:54:42 <hpaste>  geocalc pasted "ghc-ld error" at http://hpaste.org/4007
12:56:27 <geocalc> seb
12:57:39 <geocalc> sebell ^
12:58:51 <sebell> geocalc: I see your paste
12:59:46 <sebell> geocalc: I don't know what the problem is off-hand, and I don't have access to a *NIX machine at the moment (at work) to test
13:00:18 <geocalc> ok
13:03:39 <allbery_b> we need more details
13:04:42 <zeeeee> how do i invoke garbage collection?
13:05:00 <zeeeee> (ghc, if it matters)
13:05:06 <Botje> you can't
13:05:14 <Botje> at least I think you can't
13:05:18 <zeeeee> ridiculous! :)
13:05:20 <Botje> @hoogle garbage
13:05:21 <lambdabot> No matches found
13:05:25 <Botje> @hoogle gc
13:05:25 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
13:05:25 <lambdabot> Data.Typeable.gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
13:05:25 <lambdabot> Data.Typeable.gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
13:05:26 <geocalc> > takewhile anyone can help
13:05:27 <lambdabot>   Not in scope: `help'
13:05:32 <sjanssen> System.Mem.gcsomethingsomething
13:05:50 <geocalc> mmh
13:05:50 <oerjan> @hoogle performGC
13:05:50 <lambdabot> System.Mem.performGC :: IO ()
13:05:52 <zeeeee> sweet
13:05:53 <zeeeee> thanks!
13:06:08 <Botje> it's cheating if you already know the name :)
13:06:08 <defcons> what is genericIndex?
13:06:33 <oerjan> Botje: i just didn't care to write the rest
13:06:53 <oerjan> defcons: !!
13:07:05 <oerjan> except not restricted to Int
13:07:08 <defcons> apparently they have different type definitions
13:07:10 <defcons> aah
13:07:15 <defcons> so you can do floats, I'm guessing
13:07:20 <dmwit> Botje: ?hoogle IO () is a bad idea. =P
13:07:30 <sjanssen> @hoogle IO ()
13:07:30 <allbery_b> :t genericIndex
13:07:30 <lambdabot> Control.Concurrent.yield :: IO ()
13:07:30 <lambdabot> Distribution.Simple.defaultMain :: IO ()
13:07:30 <lambdabot> System.Mem.performGC :: IO ()
13:07:31 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
13:07:32 <Botje> that's a given
13:07:40 <oerjan> defcons: Integer, more likely
13:07:43 <allbery_b> nope, Integral, not Num
13:08:18 <defcons> what is Integral in haskell sense?
13:08:37 <oerjan> @instances-importing Data.Word Data.Int Integral
13:08:38 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
13:08:39 <allbery_b> any type that has distinct values (unlike, say, floats)
13:08:46 <geocalc> not rat
13:08:46 <sieni> defcons: a type class?
13:08:52 <allbery_b> also Foreign.C.Types
13:08:56 <dmwit> ?src Integral
13:08:56 <lambdabot> class  (Real a, Enum a) => Integral a  where
13:08:56 <lambdabot>     quot, rem, div, mod :: a -> a -> a
13:08:56 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
13:08:56 <lambdabot>     toInteger           :: a -> Integer
13:09:01 <sieni> allbery_b: well, floats have distinct values
13:09:12 <allbery_b> @instances-mporting Data.Word Data.Int Foreign.C.Types Integral
13:09:15 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Int16, Int32, Int64, Int8,
13:09:15 <lambdabot> Integer, Word, Word16, Word32, Word64, Word8
13:09:26 <sieni> allbery_b: they are of the form a*2^b, where a and b are integers
13:09:47 <allbery_b> I think I phrased that wrong
13:10:08 <oerjan> mostly Integrals are subsets of Integers in some way
13:10:09 <allbery_b> types that don't have the "for some values you can't count on x+1 /= x" problem
13:10:18 <oerjan> although overflow may be handled variously
13:18:23 * sorear has never heard of histomorphisms or zygomorphisms
13:18:34 <dons> now you have
13:18:49 <stevan> what's up with all the broken urls to haskell.org?
13:18:52 <sorear> defcons: an Euclidean integral domain
13:19:06 <defcons> ok
13:19:35 <sorear> meh, another steve-class nick, this is getting confusing
13:20:42 * steveclass cackles evilly
13:20:52 <oerjan> stevan: probably to the old wiki which was removed?
13:21:16 <stevan> ?source Data.Tree
13:21:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
13:21:27 <stevan> 404
13:22:00 <allbery_b> yeh, @source hasn't been updated
13:22:03 <sorear> we've got Monnier, Ljungstrand, O'Rear, Holdermanns, now Andjelkovic...
13:22:37 <allbery_b> http://haskell.org/ghc/docs/latest/html/libraries/containers-0.1.0.0/Data-Tree.html
13:22:38 <lambdabot> http://tinyurl.com/2rvuay
13:22:41 <oerjan> oh that
13:22:52 <allbery_b> there's a source link on the page (upper right hand corner)
13:23:04 <oerjan> stevan: the main docs page is still in the same place
13:23:16 <oerjan> and has the new links
13:23:19 <oerjan> @docs
13:23:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:28:04 <noecksit> does haskell care about indentation?
13:28:12 <allbery_b> yes
13:28:51 <dons> though it is optional, pretty much everyone uses explicit whitespace layout
13:28:51 <allbery_b> you can override it but by default indentation is used to avoid the need for brackets
13:28:53 <newsham> its a very caring language
13:29:04 <_ry> is there a "heredoc" in haskell?
13:29:15 <noecksit> ok, i have a function which apparently has wrong indentation rules
13:29:21 <dons> ?paste it
13:29:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:29:32 <dons> _ry: not directly, but there are multiline string literals
13:29:36 <dons> and other idioms for them
13:29:37 <Cale> _ry: no, but I usually use the unlines function with a list.
13:29:45 <araujo> Hello
13:29:51 <dons> hey araujo
13:30:02 <oerjan> _ry: only in hugs
13:30:07 <araujo> Hi there dons
13:30:11 <araujo> :-)
13:30:31 <allbery_b> someone hacked up heredocs in ghc using TH at onepoint, check -cafe archives
13:30:35 <dons> oerjan: hugs has here docs?
13:30:49 <oerjan> dons: yep
13:33:23 <hpaste>  (anonymous) pasted "lcslength" at http://hpaste.org/4009
13:33:42 <noecksit> oh, thats mine! cool
13:34:10 <oerjan> noecksit: (1) if requires else (2) functions must start with a small letter
13:34:48 <oerjan> er, lower case
13:35:07 <noecksit> oerjan: oh ok
13:35:27 <oerjan> upper case is for data type constructors
13:35:38 <atom> hi everyone... what's the list concatenation operator in haskell?
13:35:42 <tuukkah> is there a ghc backport for debian somewhere?
13:35:43 <oerjan> ++
13:35:51 <atom> oh, right :)
13:36:07 <atom> i should have remebered strings are lists of chars
13:37:06 <_ry> is there a printf?
13:37:14 <_ry> @index printf
13:37:14 <lambdabot> Text.Printf
13:37:16 <sorear> tuukkah: don't know, but ghc 6.6.1 at least is a fairly painless build (haven't tried 6.8.1, and of course you'll need ghc6 or no)
13:37:24 <Saizan> tuukkah: there are 6.8.1 debs on haskell-unsafe
13:37:34 <dons> yeah, though people usually string concatentation or prettyprinting libs instead
13:39:45 <tuukkah> sorear, even a painless build is a bit too much in some cases :-(
13:39:59 <noecksit> in my lcs_length function above, how would i be able to specify the whole list as opposed to referring either to the head or tail?
13:40:47 <oerjan> noecksit: al@(a:as)
13:41:36 <oerjan> then al is the whole list
13:41:43 <noecksit> looks strange but ill try it, thanx oerjan
13:41:43 <tuukkah> Saizan, can you give me the right uri? i find only older ones at haskell-unsafe.alioth.debian.org
13:42:11 <_ry> dons: what's a prettyprint lib?
13:42:22 <oerjan> var@pattern means to match the pattern to a value and additionally make var the whole value
13:43:13 <atom> funny... I can't find how the boolean and and or operators are written in haskell... for instance, if I want to write a guard saying | var1 == 1 && var2 == 2... how is the && written?
13:43:26 <resiak> > True && False
13:43:28 <lambdabot>  False
13:43:29 <oerjan> exactly like that
13:43:35 <atom> ok, perfect :)
13:43:45 <Saizan> tuukkah: oh, it seems they are only for amd64 http://haskell-unsafe.alioth.debian.org/archive/amd64/unstable/g/ghc6/
13:43:45 <atom> c-conventions
13:43:51 <lambdabot> Title: Index of /archive/amd64/unstable/g/ghc6, http://tinyurl.com/3xt48d
13:43:55 <dons> _ry: Text.Pretty
13:44:00 <dons> for printing documents nicely
13:44:03 <dons> more than 1 line
13:44:03 <_ry> @src fst
13:44:03 <lambdabot> fst (x,_) =  x
13:44:20 <oerjan> atom: and and or themselves do entire lists
13:44:36 <atom> oerjan: I'm not sure I know what you mean
13:44:40 <ddarius> :t and
13:44:41 <lambdabot> [Bool] -> Bool
13:44:46 <oerjan> > and [True,True,False]
13:44:47 <lambdabot>  False
13:44:54 <atom> oh.
13:44:58 <atom> cool
13:45:00 <ddarius> @src and
13:45:00 <lambdabot> and   =  foldr (&&) True
13:45:42 <oerjan> atom: also, laziness makes them all shortcut like in C
13:46:20 <_ry> another stupid question - how do i get the nth element of a list?
13:46:21 <atom> oerjan: nice. I just hope haskell REALLY optimizes all code, because I have a recursive tree that would greatly profit from caching the intermediate results...
13:46:27 <Lemmih> _ry: (!!)
13:46:44 <hrehf> hmmm, what's a wrong with foobar = map (printf "test%d") [0..5] ?
13:46:53 <oerjan> atom: there is rarely memoizing unless you arrange for it explicitly
13:46:54 <_ry> oh i thought you were exclaiming at me :)
13:47:08 <ddarius> _ry: He should be exclaiming at you.
13:47:13 <_ry> :)
13:47:29 <atom> oerjan: I'm sure I'll be a lot better off just writing the code and than coming to you guys to fix it :)
13:47:35 <oerjan> but all references to a variable are shared
13:47:43 <hpaste>  noecksit annotated "lcslength" with "lcslength" at http://hpaste.org/4009#a1
13:48:04 <tuukkah> Saizan, ok, thanks!
13:48:16 <noecksit> oerjan: is what im doing allowed?
13:48:28 <atom> i'll have the code ready in half an hour or so... I hope someone'll be able to take a look at it and tell me how poorly it is written.
13:48:43 <oerjan> _ry: btw taking the nth element of a list for several n is rarely the right thing to do
13:49:22 <oerjan> noecksit: no no, i meant to replace the (a:as) you already had
13:49:40 <oerjan> it's a pattern not an expression
13:50:28 <tuukkah> of course one can just write (a:as) to get the original list
13:50:35 <sebell> hrehf: You need to add a type declaration.. look at instances of PrintfType perhaps
13:50:51 <oerjan> and then use just al and bl where you have put the @ pattern now
13:51:22 <hrehf> sebell aaah, so 1 is interpretet as a Num, so printf doesn't know how to convert it?
13:51:23 <noecksit> so would i have to redeclare lcs_length with new parameters? cause i wanted to include the whole list in the else part
13:51:28 <oerjan> tuukkah: loses sharing though
13:51:51 <sebell> hrehf: There's type-hackery in PrintF that the compiler isn't smart enough to support IIRC
13:51:56 <sebell> (in some situations)
13:52:14 <hrehf> ah, ok. Thanks!
13:52:23 <oerjan> noecksit: yep, just use lcs_Length (a:as) (b:bd) =
13:52:23 <tuukkah> noecksit, al@(a:as) gives you all three bindings: al, a, as
13:52:28 <oerjan> er, darn
13:52:45 <oerjan> lcs_Length al@(a:as) bl@(b:bd) =
13:53:55 <noecksit> or couldn't i just have "lcs_length al bl = " and that would give me the whole list? or it probably wouldnt know which definition to apply to
13:54:37 <noecksit> oh, i see what you mean, i would replace that whole definition, sorry
13:54:45 <oerjan> noecksit: that gives you the whole list but then you would need to split it up if you want to look at the parts
13:58:55 <oboudry> hi all, is there a way to use bytestring with unicode data?
13:59:07 <sjanssen> oboudry: not really
13:59:17 <sjanssen> there is another library you can try, CompactString
13:59:46 <oboudry> ok I'll look at it. Thanks.
14:00:30 <Lemmih> CompactString is precisely a way to use bytestrings with unicode data, no?
14:01:45 <oboudry> I tried to play in ghc loading utf8 file, but it looks like everything is converted back to latin1 automatically.
14:01:53 <alec> dons: your email address in the X11 library is wrong, 'darcs send' goes to dons@galois.org
14:03:23 <SamB> what is dons' email now? dons@galois.com?
14:03:37 <sorear> oboudry: there is no conversion going on
14:03:45 <sorear> oboudry: source code is in utf8, always
14:03:55 <sorear> oboudry: terminal and file IO is latin1, always
14:04:08 <sorear> oboudry: what you want is 'utf8-string' on hackage
14:04:09 <SamB> for now
14:04:21 <dons> alec: ah
14:04:44 <SamB> but we have no clue what the heck we really want to do with encodings for anything but source files...
14:04:55 <dons> fixed.
14:05:06 <sorear> galois is a nonprofit? :P
14:05:07 <sjanssen> I have a clue
14:05:12 <sjanssen> everybody is just stupid :)
14:05:16 <Lemmih> sorear: Not if he wants ByteStrings.
14:05:16 <SamB> sjanssen: okay
14:05:19 <SamB> what was your clue?
14:05:34 <sjanssen> Handle should use the encoding according to your locale
14:05:42 <SamB> WRONG ANSWER
14:05:49 <hpaste>  oboudry pasted "Utf-8 to latin1 conversion" at http://hpaste.org/4010
14:05:51 <sjanssen> unless the handle is opened with one of the binary functions
14:05:52 <SamB> that is DISGUSTING
14:06:10 <sjanssen> there should be functions to create handles with another encoding
14:06:13 <sjanssen> SamB: why?
14:06:19 <sjanssen> SamB: it is unix convention, no?
14:06:22 <sorear> oboudry: "Byte"string
14:06:27 <sorear> oboudry: it holds BYTES
14:06:34 <sorear> oboudry: not characters
14:06:44 <SamB> unix convention is to have very spotty support for locales, I think
14:07:01 <oboudry> sorear: look at the hpaste http://hpaste.org/4010 there is a conversion between utf8 and latin1?
14:07:03 <sjanssen> I want to know why you think this is bad
14:07:07 <SamB> anyway unix is stupid
14:07:08 <sorear> oboudry: No.
14:07:09 <oboudry> sorear: ok for byte ;-)
14:07:13 <Lemmih> sorear: Compact strings, then.
14:07:16 <SamB> see, this is what I meant about nobody having any clue
14:08:37 <SamB> anyway, if you fopen a file and fread what's in it, that never does any conversion
14:09:00 <sjanssen> yes, those correspond to our binary IO functions
14:09:03 <quicksilver> sjanssen: the locale you have when you open a file
14:09:12 <quicksilver> sjanssen: bears no obvious relationship to the encoding
14:09:20 <quicksilver> (someone else may have saved it!)
14:09:29 <quicksilver> so using locale to determine encoding is very dodgy
14:09:39 <SamB> yes, that's essentially what I mean ;-)
14:10:02 <SamB> I think plan9 got this right
14:10:21 <sjanssen> can you agree that locale is clearly the correct encoding for stdin/out when attached to a TTY?
14:10:31 <SamB> yes
14:10:40 <sjanssen> SamB: plan9 only used UTF-8, right?
14:10:46 <SamB> sjanssen: correct!
14:10:59 <SamB> trashing everything else is really the only sensible approach
14:11:01 <sjanssen> SamB: that is not an option, GHC can't enforce that policy
14:11:14 <SamB> I realize the problem is NOT GHC's fault
14:11:31 <oboudry> sorear: I still don't understand why I get \233 (latin1 for Ã©) when I use a string defined in the code and \195\169 when it's read through readFile.
14:11:35 <sjanssen> not to mention that it isn't convention at all on the Windows platform
14:12:04 <SamB> yeah.
14:12:13 <SamB> I think I could fix that...
14:12:16 <sjanssen> so I think that is a non-starter
14:12:39 <SamB> well, maybe not QUITE. but most US software would work...
14:12:44 <sjanssen> if we're going to provide encodings, we have to consider at least UTF-8 and UTF-16.  Probably latin1 too
14:13:15 <sorear> oboudry: a FILE contains BYTES
14:13:23 <sorear> oboudry: a STRING contains CHARACTERS
14:13:24 <kscaldef_> Asian encodings are a good idea too
14:13:40 <SamB> kscaldef: them asians can tell us what to do about that
14:13:44 <sjanssen> perhaps openFile can use one of the popular heuristics for automatically determining the encoding
14:13:44 <sorear> oboudry: you have to convert bytes into characters somehow
14:14:15 <sorear> oboudry: readFile uses one way, source code uses another
14:14:24 <oboudry> sorear: ok
14:14:43 <davidL> sorear: what do you think about the sieve of atkin?
14:15:14 <quicksilver> I would be in favour of the very simplistic approach that all text IO uses UTF8 by default
14:15:18 <Saizan> oboudry: literal strings are parsed as utf-8 and converted to unicode codepoints, that just happen to correspond to latin1 for the initial 256
14:15:19 <sorear> davidL: it's pretty pointless, nobody needs a consequitive list of prime numbers
14:15:20 <bparkis> why are formal methods in computer programming considered more expensive?
14:15:27 <oboudry> sorear: I was just expecting the source code to be handled the same way as the readFile function does.
14:15:27 <davidL> sorear: haha
14:15:28 <quicksilver> and all binary IO gives rise to Byte / [Byte]
14:15:31 <quicksilver> (not char at all)
14:15:41 <quicksilver> it would be gravy to have an interface for other encodings
14:15:43 <bparkis> is it because of the expense of hiring people who can do them, or are competent people using formal methods actually less productive than competent people not using them?
14:15:49 <quicksilver> but just UTF8-everywhere would be better than now
14:16:16 <quicksilver> oboudry: A reasonable expectation :) Just happens to be wrong :(
14:16:19 <SamB> bparkis: because you can't pay idiots to do it?
14:16:26 <oboudry> saizan: thanks for the precision
14:16:27 <oboudry> ;-)
14:16:28 <sjanssen> UTF8 everywhere is a very Unix-centric point of view
14:16:44 <bparkis> right but is it just that formal methods demand more expensive programmers, or is it also that the programmers actually work slower than they would otherwise?
14:16:59 <sjanssen> quicksilver: I do agree strongly wrt. your binary IO point
14:17:21 <bparkis> because intuitively, when you prove properties of your program, all you are doing is thinking rigorously about its behavior which you should be doing anyway whether or not you write that thought down
14:17:21 <quicksilver> bparkis: fans of formal methods believe them to be an overall win
14:17:45 <quicksilver> bparkis: when you factor in debugging time / refactoring time / time spent correcting serious errors
14:18:13 <quicksilver> bparkis: however it's a hard case to make, and does require particular skills from your staff
14:18:15 <sjanssen> in GHC, putChar's type is a blatant lie :(
14:18:20 <quicksilver> sjanssen: yeah :(
14:19:40 <quicksilver> sjanssen: also, the standard libs don't actualy have get/putByte functions 'explicitly'
14:19:53 <quicksilver> sjanssen: you can build them using toEnum/fromEnum which just feels realy wrong
14:20:02 <sramsay> bparkis: traditionally formal methods have been targeted at doing "more" than usual methods, so you had a better product at the end of it but it typically took longer
14:20:51 <sramsay> bparkis: more recently tho formal methods people are showing that you can do achieve the same result as with usual methods, but cheaper/quicker
14:21:08 <bparkis> do you know about any study to that effect?
14:21:13 <kscaldef_> what are "the usual methods" in this context?
14:21:22 <sramsay> non-formal methods :-)
14:21:40 <kscaldef_> that's pretty broad
14:21:56 <sjanssen> quicksilver: it is somewhat more honest to use hGetBuf/hPutBuf
14:22:18 <quicksilver> sjanssen: but less convenient :)
14:22:50 <sramsay> http://cat.inist.fr/?aModele=afficheN&cpsidt=17707419
14:22:51 <lambdabot> Title: CAT.INIST
14:22:53 <quicksilver> kscaldef_: the normal comparison is versus rigorous, but non-formal, engineering
14:22:56 <kscaldef_> for example, unit tests with 100% coverage are not a "formal method", but proponents of that approach would make basically the same claims with respect to "other methods"
14:23:07 <sramsay> was some work we did at qinetiq in this area
14:24:01 <sjanssen> putByte h x = with x $ \p -> hPutBuf h p 1 -- easy as pie, quicksilver :P
14:24:05 <SamB> kscaldef: what the heck is 100% coverage?
14:24:22 <SamB> it tests that the units work correctly in 100% of cases?
14:24:23 <Saizan> sjanssen: getByte?
14:24:45 <quicksilver> SamB: normally 100% coverage is 100 of lines of code tested
14:24:46 <kscaldef_> code coverage
14:24:54 <SamB> but tested for WHAT????
14:25:09 * quicksilver shrugs
14:25:21 <kscaldef_> line coverage at a minimum, preferably also branch & conditional coverage
14:25:44 <sjanssen> getByte h = alloca $ do n <- hGetBuf h p 1; if n /= 1 then raise eof exception else peek p -- a little more difficult
14:25:47 <SamB> so, you could get 100% coverage and still have really bad bugs in there?
14:25:52 <kscaldef_> but, yes, the tests need to test the requirements as well as exercise the code
14:25:55 <sjanssen> getByte h = alloca $ \p -> do n <- hGetBuf h p 1; if n /= 1 then raise eof exception else peek p -- oops
14:26:13 <glguy> 100% coverage is good for proving your program *doesn't* work :)
14:26:25 <SamB> yeah ;-)
14:26:37 <SamB> the typechecker is good at that too, though
14:27:04 <glguy> why use a built in type checker when you could write unit tests to do the same for a smaller number of situations?
14:27:21 <SamB> because you have too much time on your hands?
14:27:31 <kscaldef_> you're arguing against a position that I'm not taking
14:27:51 <quicksilver> but too strongly, perhaps
14:27:51 * glguy is just screwing around and encouraging SamB
14:27:53 <SamB> but how do you get 100% requirement coverage?
14:28:01 <dibblego> they're not actually; it just looks like it to you (I was about to write something about it!)
14:28:02 <kscaldef_> but, do you not use quickcheck?
14:28:11 <quicksilver> 100% code coverage is not a meaningless statistic
14:28:25 <SamB> quicksilver: I realize that
14:28:30 <quicksilver> having every line of your code covered by some test is a good thiing
14:28:36 <SamB> yes
14:28:39 <quicksilver> it remains to check it's a useful test :)
14:28:42 <glguy> it means every line of your program works in at least one case
14:28:48 <phlpp_> n8
14:29:29 <SamB> it means a heck of a lot less in Haskell than in Python, though
14:29:47 <dibblego> often times, the metric of '100% code coverage' is erroneously elevated in status and meaning, though it is not entirely meaningless
14:29:51 <kscaldef_> SamB: you have to start with a complete, consistent requirement doc, I suppose
14:29:52 <SamB> in Python, you could have lurking typos
14:30:03 <kscaldef_> I look forward to encountering such a thing one day :-(
14:30:08 <dibblego> ksandstr, a -> a
14:30:16 <dibblego> ?djinn a -> a
14:30:17 <lambdabot> f a = a
14:30:24 <faxathisia> ?djinn a -> b
14:30:25 <lambdabot> -- f cannot be realized.
14:30:33 <dibblego> kscaldef, there's your first :)
14:30:46 <SamB> kscaldef: hehehe
14:30:53 <kscaldef_> you'll pay me to implement that?
14:31:09 <SamB> kscaldef: no!
14:31:11 <davidL> > map (\[x,y] -> (x,y)) $ replicateM 2 [1..5] -- is there a better way to write this?
14:31:13 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
14:31:17 <SamB> we could have @djinn do it
14:31:28 <dibblego> no, a machine did it for me, since it was unambiguous
14:31:33 <oerjan> :t \x -> undefined `asTypeOf` x
14:31:34 <lambdabot> forall a. a -> a
14:31:35 <SamB> and trivial
14:31:37 <glguy> > liftM2 (,) [1..5] [1..5]
14:31:38 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
14:32:00 <glguy> > liftM2 (,) `join` [1..5]
14:32:00 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
14:32:02 <SamB> dibblego: merely being unambiguous does not necessarily allow @djinn to do it ;-)
14:32:11 <dibblego> SamB, I know, sadly :)
14:32:44 <davidL> glguy: thanks
14:33:10 <oerjan> merely allowing @djinn to do it does not mean being unambiguous
14:33:13 <SamB> see, in formal methods, you still need to discover the requirements
14:33:32 <quicksilver> > (,) <$> [1..5] <*> [1..5]
14:33:33 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
14:33:38 <oerjan> @djinn a -> a -> a
14:33:39 <lambdabot> f _ a = a
14:33:42 <quicksilver> if you like the applicative combinators ;)
14:33:57 <kscaldef_> of course, the reason requirements docs are hardly ever complete and consistent is that if the people writing them could do that, they would be programmers
14:34:02 <SamB> it's just that you try to specify them in such a way that you can use them to prove that the program meets the requirements
14:34:32 <SamB> of course, this is flat out impossible in crypto...
14:34:33 <dibblego> kscaldef, it's because they use a horrible language with a poor type system, called English
14:34:46 <SamB> they don't even know it very well
14:34:51 <kscaldef_> indeed
14:35:33 <SamB> I got an email today from the Student Government Association that said "in lieu of" instead of "in light of"
14:35:43 <SamB> or was it yesterday/...
14:35:48 <SamB> well, I read it today ;-)
14:36:37 <sramsay> we are quite lucky, we get a formal spec and code and our job is to show a refinement
14:37:05 <mattam> sramsay: where are you working?
14:37:12 <sramsay> qinetiq
14:37:30 <sramsay> they have a small formal methods group
14:38:24 <hrehf> are the haskell trigonometry functions using parameters in radiant?
14:38:32 <faxathisia> @src sin
14:38:32 <lambdabot> Source not found.
14:38:40 <sjanssen> hrehf: yes
14:38:54 <sjanssen> well, radians actually ;)
14:39:00 <hrehf> ^^
14:39:03 <SamB> hrehf: yeah, what he said
14:39:10 <davidL> glguy: does that only work on ghc 6.8.1?
14:39:22 <hrehf> hehe, ok http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Prelude.html#v%3Asin doesn't say anything about that, but maybe i'm somwehere wrong :)
14:39:23 <lambdabot> http://tinyurl.com/yqz9gj
14:39:31 <SamB> hrehf: and to clarify, those aren't numbers you are computing with
14:39:42 <SamB> those are temperamental approximations
14:39:45 <tuomov> hmm... is there a way to have 'weak' references (and associated finalizers)?
14:39:55 <sjanssen> tuomov: yes, see System.Mem.Weak
14:40:01 <faxathisia> SamB: ?!
14:40:03 <hrehf> SamB hm, could you explain what you mean?
14:40:04 <glguy> davidL: no
14:40:18 <SamB> hrehf: in other words... floating point is screwy
14:40:21 <ddarius> Practically every implementation of trigonometric functions for programming languages uses radians.
14:40:27 <glguy> import Control.Monad.Instances  iirc
14:40:42 <davidL> ah ok
14:40:42 <glguy> if you wanted to use "join" like that
14:40:48 <SamB> ddarius: why do you suppose that is?
14:40:57 <SamB> it seems almost too smart for most languages...
14:40:57 <ddarius> SamB: Because degrees are retarded.
14:40:58 <hrehf> SamB oh, yeah :( (or is fp in haskell worse/more difficult than in other languages?)
14:41:09 <tuomov> of course, channels that ends get notified of when the other end closes, would be even nicer..
14:41:14 <SamB> fp in haskell is GREAT
14:41:21 <SamB> as long as you mean Functional Programming
14:41:29 <tuomov> i.e. approximation of unix processes communicating between pipes within haskell..
14:41:32 <sjanssen> tuomov: such a thing would not be hard to write
14:41:33 <hrehf> SamB floating point numbers :)
14:41:39 <ddarius> hrehf: Floating point is exactly the same.
14:41:44 <SamB> no, Haskell's floating point is not worse than in most other languages
14:41:52 <hrehf> k, thanks again ;)
14:42:19 <sjanssen> tuomov: it can be simulated with Chan (Maybe a), where Nothing is sent in lieu of EOF
14:42:20 <SamB> particular assembly languages may have slightly better support...
14:42:45 <tuomov> hoogle doesn't seem to find system.mem.weak..
14:42:56 <tuomov> sjanssen: but you need a lot of wrappers..
14:43:26 <sjanssen> tuomov: what, 10 functions?
14:44:18 <tuomov> sjanssen: I mean, notified when the thread dies..
14:44:26 <sjanssen> oh, when the thread dies
14:44:35 <sjanssen> somewhat more difficult
14:44:49 <tuomov> to free data the thread has a lock on etc.
14:44:51 <sjanssen> tuomov: threads receive an exception when they're blocked indefinitely, perhaps you can use this?
14:45:43 <atom> what's the function to get the list length?
14:46:04 <firefly> length
14:46:14 <araujo> > length [1 .. 9]
14:46:19 <lambdabot>  9
14:46:19 <sjanssen> tuomov: (GHC knows a thread is blocked indefinitely when it is waiting on an MVar that no live thread has a reference to)
14:46:20 * atom makes wary face.
14:46:23 <TomMD> > genericLength [1..200]
14:46:23 <lambdabot>  200
14:46:26 <atom> I feel stupid :)
14:46:43 <faxathisia> atom: http://www.zvon.org/other/haskell/Outputlist/index.html
14:46:43 <lambdabot> Title: Zvon - Haskell Reference
14:46:47 <atom> what's the difference betw. genericLength and length?
14:46:53 <TomMD> atom: the type
14:46:55 <sjanssen> atom: just the type
14:47:05 <dons> > genericLength "haskell" :: Rational
14:47:05 <lambdabot>  7%1
14:47:11 <dons> > genericLength "haskell" :: Double
14:47:11 <lambdabot>  7.0
14:47:12 <TomMD> length :: [a] -> Int  while genericLength :: Num a => [b] -> a
14:47:14 <dons> > genericLength "haskell" :: Word8
14:47:14 <lambdabot>  7
14:47:52 <sjanssen> > length "haskell" :: Double
14:47:52 <lambdabot>  Couldn't match expected type `Double' against inferred type `Int'
14:48:00 <tuomov> sjanssen: I'd hate polling a zillion MVars, so that would still demand a wrapper thread
14:48:08 <sebell> > length [1..300[
14:48:08 <lambdabot>  Parse error at end of input
14:48:11 <sebell> > length [1..300]
14:48:12 <lambdabot>  300
14:48:21 <sjanssen> tuomov: Chans are MVars underneath
14:48:33 <TomMD> atom: it is a real pain, when making serialization libraries, to call 'fromIntegral' all the time, so I find generic functions useful.
14:49:03 <tuomov> so a thread has one 'incoming' chan or so, where it gets all its requests, as well as notifies when another thread has closed
14:49:35 <atom> if I need some parameter to be between length list and sum list, should I make a function that returns both as a tuple to avoid traversing the list twice, or should I just use both functions?
14:49:37 <sjanssen> tuomov: ah, yes, a wrapper is required
14:49:59 <sjanssen> atom: how long is the list?
14:50:26 <atom> sjanssen: differs. not long, usually, but if I were in C i'd call it an inner-loop function.
14:50:33 <tuomov> Not that I'm necessarily against of having such a wrapepr.. just trying to figure out the best way to do this
14:50:36 <atom> meaning it's gonna be needed a lot
14:50:57 <TomMD> would Data.Stream help with that, dons?
14:51:19 <tuomov> exploiting the GC (through System.Mem.Weak) is one alternative
14:51:22 <sjanssen> atom: probably a good idea to do one pass, then
14:51:35 <tuomov> although a 'lagged' one
14:51:43 <atom> sjanssen: I thought the haskell compiler would be smart enough to do such short optimizations itself...
14:51:44 <sjanssen> tuomov: a simple wrapper over forkIO seems better
14:51:57 <atom> the more I think about haskell, the more I see how it makes optimization hard...
14:51:58 <sjanssen> atom: not in this case :(
14:52:54 <TomMD> atom: I think, but am not sure, that the new 'Data.Stream' library will automatically optimize this paticular case.  That library will be the new default 'Data.List' library some day (we hope).
14:53:19 <TomMD> @where fusion
14:53:19 <lambdabot> I know nothing about fusion.
14:53:24 <TomMD> @where streamfusion
14:53:24 <lambdabot> I know nothing about streamfusion.
14:53:28 <atom> hm...
14:53:30 <sjanssen> tuomov: eg. spawnProcess :: Chan a -> (Chan a -> IO ()) -> IO (); spawnProcess c m = forkIO (do m c; writeChan c "foo")
14:54:07 <TomMD> @remember fusion http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
14:54:07 <lambdabot> Good to know.
14:54:14 <sjanssen> TomMD: I don't think even stream fusion will do this automatically
14:54:27 <Pseudonym> ?where cold-fusion
14:54:27 <lambdabot> I know nothing about cold-fusion.
14:54:32 <TomMD> No? damn
14:54:44 <Pseudonym> ?where tokomak?
14:54:44 <lambdabot> I know nothing about tokomak?.
14:54:57 <tuomov> actually, it might work best to model a 'connection' has two threads...
14:54:59 <allbery_b> TomMD: @remember is for @quote; @where+ is for @where
14:55:04 <sjanssen> atom: while GHC can't do this optimization for you, it is trivial to do it by hand
14:55:13 <tuomov> s/has/as/
14:55:21 <atom> I mean, theoretically, haskell should see taht there are some functions that traverse the whole list and the same list, it should just stick them into the same loop
14:55:23 <TomMD> allbery_b: damn again, and thanks
14:55:30 <tuomov> if those connections can actually check on a chan and see that the other end is no longer there
14:55:33 <hpaste>  sjanssen pasted "manual combination of foldl" at http://hpaste.org/4012
14:55:34 <tuomov> (or mvar)
14:55:53 <atom> what's the point of having pure functions and immutable datatypes if you're not smart enough to do such stuff
14:55:56 <TomMD> @where+ fusion http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
14:55:56 <lambdabot> Nice!
15:00:55 <tuomov> bah, netsplit
15:01:05 <Pseudonym> So, what shall we talk about?
15:01:05 --- mode: irc.freenode.net set +o ChanServ
15:02:02 <Pseudonym> @botsnack
15:02:42 <shapr> Ya know, I wish darcs repos for packages were all on the same server. I keep forgetting whether a particular thing is on code.haskell.org darcs.haskell.org or www.haskell.org
15:02:50 <tuomov> sjanssen: any documentation of this thread indefinite blocking exception?
15:02:58 <Pseudonym> shapr: What you need is an abstraction layer.
15:03:05 <tuomov> doesn't seem to be in the http://haskell.org/ghc/docs/latest/html/libraries/ Control.Concurrent docs
15:03:14 <sjanssen> tuomov: there might be something in Control.Exception
15:03:29 <shapr> y0 lispy!
15:03:32 <shapr> Mistah Dagit!
15:03:54 <tuomov> ah, AsyncException / ThreadKilled
15:04:22 <SamB_XP> hey, there I go!
15:04:23 <tuomov> should imho be mentioned in Control.concurren ttoo
15:04:26 * SamB_XP points at SamB
15:04:33 * Pseudonym feels dizzy
15:05:01 <tuomov> hmm.. or is that it..
15:05:30 <Pseudonym> Anyway, what would be cool here is for some place (presumably hackage) to work something like a tracker.
15:05:48 <tuomov> Exception / BlockedOnDeadMVar actually
15:05:49 <Pseudonym> Hackage is, after all, a central repository of stuff.
15:05:50 <SamB_XP> oh, torrents of Haskell goodness!
15:06:06 <Pseudonym> So you just query that, and it directs you to the right repo.
15:06:41 <Pseudonym> ?botsnack
15:07:13 <SamB_XP> hey, here I come again!
15:07:38 <lambdabot> :)
15:15:26 <shapr> whee!
15:15:50 <shapr> Pseudonym: Yeah, I wish hackage were a bt tracker.
15:16:47 <_ry> how do i test if a list contains an element?
15:16:54 <ddarius> :t elem
15:16:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
15:17:02 <Pseudonym> And moreover, because patches are independent, there's an "obvious" unit to P2P.
15:17:04 <_ry> thanks
15:17:22 <faxathisia> _ry: more stuff here http://www.zvon.org/other/haskell/Outputlist/index.html
15:17:22 <lambdabot> Title: Zvon - Haskell Reference
15:17:35 <Pseudonym> You'd need some kind of message integrity system.  Say, hash every patch.
15:17:59 <Pseudonym> Woo!  P2P repo checkout.
15:18:08 <Pseudonym> (And on that note, the bar closed.)
15:19:04 <Olathe> > false
15:19:19 <Olathe> @slap lambdabot
15:19:25 <dibblego> is lambdabot broke?
15:19:29 <lambdabot>  True
15:19:32 <faxathisia> hahaha
15:19:37 <dibblego> heh
15:19:41 * lambdabot is overcome by a sudden desire to hurt lambdabot
15:19:42 * Pseudonym laughs
15:19:54 <atom> @paste
15:19:55 <sjanssen> I don't think darcs would work with bittorrent very well: the files are too small
15:20:00 <atom> @where paste
15:20:20 <Pseudonym> Race condition exploit, here we come.
15:20:21 <Pseudonym> > false
15:20:22 <Pseudonym> Is lambdabot an idiot?
15:20:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:20:24 <lambdabot> http://hpaste.org/new
15:20:33 <lambdabot>  True
15:20:34 <Pseudonym> Hmm.
15:20:41 <Pseudonym> That didn't work out so well.
15:20:51 <Pseudonym> > false
15:20:52 <Pseudonym> Is lambdabot an idiot?
15:20:59 <faxathisia> > not false
15:21:13 <hpaste>  atom pasted "Can anyone help translate this into haskell?" at http://hpaste.org/4013
15:21:16 <Pseudonym> > not (not otherwise)
15:21:28 <atom> hpaste
15:21:53 <atom> I'm pretty much stumped about how I could do this in haskell efficiently
15:21:56 <Pseudonym> @dice 2d6
15:22:03 <lambdabot>  False
15:22:03 <lambdabot>  True
15:22:03 <lambdabot> 2d6 => 10
15:22:03 <lambdabot>  True
15:22:11 <Pseudonym> lambdabot: Took your time.
15:23:16 <TSC> atom: Do you want to use exactly the same algorithm?
15:23:59 <atom> TSC: no, i'd actually prefer it if I could calculate it roll-value by roll-value, it's just that this is the fastest way and the simplest way I could come up with it in C/C++
15:24:28 <atom> TSC: since haskell doesn't have mutable datatypes, the out-array is pretty much out of the question
15:24:45 <LoganCapaldo> evening typing fans
15:24:46 <atom> I don't care about the actual algorythm used, as long as it's comparably fast
15:25:00 * Pseudonym can't follow what this is upposed to do
15:25:20 <Pseudonym> You have a bunch of n_i-sided dice.
15:25:25 <Pseudonym> Where n_i are given.
15:25:29 <atom> yes
15:25:34 <Pseudonym> Then... what?
15:25:45 <atom> and then you need to calculate the probability that a particular roll will occur
15:26:01 <Pseudonym> Oh, the probability that a particular _sum_ will occur.
15:26:06 <atom> Pseudonym: actually not probability, as that would be a fraction, but the times that a particular roll occurs
15:26:11 <atom> Pseudonym: yeah.
15:26:13 <TSC> frequency
15:26:21 <atom> TSC: nailed it.
15:27:02 <atom> and I don't want to hear the words monte-carlo :)
15:27:09 <LoganCapaldo> out array? runSTArray ?
15:27:21 <Pseudonym> So you want to compute this exactly.
15:27:26 <LoganCapaldo> he said, having no idea what he missed
15:27:30 <atom> Pseudonym: yes.
15:27:42 <atom> LoganCapaldo: http://hpaste.org/4013
15:27:52 <atom> LoganCapaldo: i'm trying to translate this c++ code into haskell
15:28:09 <atom> and in C++, an in-out variable is the intuitive thing to use
15:28:12 <ddarius> atom: You can write Fortran in any language, including Haskell.
15:28:19 * ddarius disagrees with that statement...
15:28:33 <atom> ddarius: at least in this case
15:28:53 <LoganCapaldo> mmm instance Monad Fortran where ...
15:29:10 <atom> ddarius: and unfortunately, fortran is something I would rather not give in to
15:29:11 <faxathisia> atom: I recommend to scrap the code
15:29:26 <faxathisia> atom: And just write the code as it would be written naturally
15:29:35 <Pseudonym> @let combs [] = [[]]
15:29:38 <lambdabot> Defined.
15:29:41 <atom> faxathisia: it's written as "what I want to do". I threw it together in 5 minutes
15:29:47 <hpaste>  TSC annotated "Can anyone help translate this into haskell?" with "simple way" at http://hpaste.org/4013#a1
15:29:51 <atom> faxathisia: so I could demonstrate it to you guys
15:30:05 <Pseudonym> Hang on.
15:30:10 <Pseudonym> @let sums [] = [0]
15:30:13 <lambdabot> Defined.
15:30:14 <kscaldef_> atom: you want to figure out the frequency of a single roll, or all frequencies?
15:30:20 <ddarius> atom: The Fortran comment is a saying.  It has a stereotypical form.
15:30:23 <Pseudonym> @let sums (d:ds) = [ x + y | x <- [1..d], y <- sums ds ]
15:30:25 <lambdabot> Defined.
15:30:36 <Pseudonym> > filter (==12) (sums [6,6,6])
15:30:37 <lambdabot>  [12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12]
15:30:43 <atom> kscaldef: I'm gonna need all of them eventually
15:30:44 <Pseudonym> > length $ filter (==12) (sums [6,6,6])
15:30:45 <lambdabot>  25
15:30:56 <atom> kscaldef: so I don't want to repeat the calculation if that can be avoided
15:31:05 <LoganCapaldo> > count (== 12) (sums [6,6,6])
15:31:05 <lambdabot>   Not in scope: `count'
15:31:09 <LoganCapaldo> blast
15:31:15 <Pseudonym> With stream fusion, I reckon that's a pretty good direct algorithm.
15:31:16 <Pseudonym> BUT.
15:31:24 <Pseudonym> You may be better off computing this combinatorially.
15:31:25 <atom> kscaldef: however, if a single frequency can be computed without computing the others in the process, i'm all for it
15:31:30 <twanvl> > let addDie n m = M.fromListWith (+) [ (a+b,f) | (a,f) <- M.toList m, b <- [1..n] ]; dice = foldr addDie (M.singleton 0 1) in dice [6,6]
15:31:30 <lambdabot>  fromList [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,5),(9,4),(10,3),(11,2),(12,1)]
15:31:34 <augustss> > sums [6,6]
15:31:34 <lambdabot>  [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11,12]
15:31:36 <kscaldef_> gotcha.  If you only wanted the result for one total, I'm pretty sure you can do it more efficiently
15:31:48 <ddarius> Where's Cale when you need him?
15:31:53 <LoganCapaldo> @let count p = foldr (\x n -> if p x then n + 1 else n)
15:31:54 <lambdabot> Defined.
15:31:57 <LoganCapaldo> > count (== 12) (sums [6,6,6])
15:31:58 <lambdabot>   add an instance declaration for (Num [t])
15:31:58 <lambdabot>     In the expression: count ((==...
15:31:58 <kscaldef_> but, if you want them all, I'm not sure, this might be most efficient
15:32:15 <LoganCapaldo> @let count p = foldr (\x n -> if p x then n + 1 else n) 0
15:32:15 <lambdabot> <local>:15:0:     Warning: Pattern match(es) are overlapped              In t...
15:32:22 <LoganCapaldo> doh
15:32:23 <Pseudonym> Actually, you can optimise some base cases.
15:32:25 <LoganCapaldo> I fail
15:32:28 <zeeeee> help: i have newInterruptPair :: (Typeable e) => IO ((IO a -> IO a), (e -> IO ())), where the fst is an "interruptible" wrapper to specify that an IO call is interruptible. the snd is "interrupt" to send an async exception to a running interruptible. however, (i think) interruptible can only take on one type signature, which precludes me from using interruptible on (say) both readFile and waitForProcess. any suggestions around this?
15:33:03 <Cale> ddarius: hm?
15:33:12 <zeeeee> actually, i can simplify my above question by not mentioning the async exceptions/interrupts - this is purely a question about typing
15:34:16 <chessguy> @mavis_beacon
15:34:17 <lambdabot> Unknown command, try @list
15:34:18 <atom> hm... I'm not sure I understand all this code :) The thing is, twanvl gave something that can't compute it for an arbitrary number of dies...
15:34:24 <Pseudonym> @let countSum s _ | s <= 0 = 0
15:34:25 <Pseudonym> @let countSum s [] = if s == 0 then 1 else 0
15:34:26 <Pseudonym> @let countSum s (d:ds) = sum [ countSum (s-x) ds | x <- [1..min d s] ]
15:34:26 <lambdabot> Defined.
15:34:27 <lambdabot> Defined.
15:34:28 <lambdabot> Defined.
15:34:34 <Pseudonym> > countSum 12 [6,6,6]
15:34:35 <lambdabot>  0
15:34:37 <Pseudonym> Hmm.
15:34:37 <ddarius> Cale: atom's problem
15:34:40 <twanvl> atom: it gets a list of dice
15:35:02 <Pseudonym> D'oh!
15:35:16 <Pseudonym> @let countSum' s [] = if s == 0 then 1 else 0
15:35:16 <Pseudonym> @let countSum' s _ | s <= 0 = 0
15:35:17 <Pseudonym> @let countSum' s (d:ds) = sum [ countSum' (s-x) ds | x <- [1..min d s] ]
15:35:18 <lambdabot> Defined.
15:35:19 <lambdabot> Defined.
15:35:20 <lambdabot> Defined.
15:35:21 <Pseudonym> > countSum' 12 [6,6,6]
15:35:22 <atom> twanvl: or I'm just not haskell-foo savy enough to get it
15:35:22 <lambdabot>  25
15:35:26 <Pseudonym> Better.
15:35:34 <LoganCapaldo>  @let is so unforgiving
15:35:38 <Pseudonym> Yes.
15:35:40 <zeeeee> help: i have f :: Int -> (IO b -> IO b), but i'd like the returned function to be polymorphic, so that i can do eg: let g = f 0; g (readFile ..); g (waitForProcess ..)
15:36:12 <zeeeee> i'm not sure how to get around this typing problem
15:36:28 <Pseudonym> Actually, that second line isn't necessary.
15:36:30 <ddarius> zeeeee: Give the type you mean.
15:36:36 <zeeeee> ddarius, ?
15:36:40 <atom> > countSum' 1 [6]
15:36:41 <lambdabot>  1
15:36:45 <atom> > countSum' 2 [6]
15:36:45 <lambdabot>  1
15:36:50 <atom> > countSum' 2 [6,6]
15:36:50 <lambdabot>  1
15:36:55 <atom> > countSum' 0 [6,6]
15:36:55 <lambdabot>  0
15:36:58 <atom> > countSum' 3 [6,6]
15:36:58 <lambdabot>  2
15:37:05 <ddarius> zeeeee: If you want the first component to be polymorphic, make it so.
15:37:06 <atom> well, seems to work. I don't get how though
15:37:15 <paczesiowa> if I have 'foreign import ccall "system_encoding.h get_system_encoding"' where should I put these two files? can ghc compile them when needed or do I have to make .o file first?
15:37:20 <zeeeee> ddarius, what's the first component?
15:37:20 <Pseudonym> @let diceProblem s [] = if s == 0 then 1 else 0
15:37:21 <Pseudonym> @let diceProblem s (d:ds) = sum [diceProblem (s-x) ds | x <- [1..min d s] ]
15:37:22 <lambdabot> Defined.
15:37:23 <lambdabot> Defined.
15:37:25 <Pseudonym> That's a simpler version.
15:37:32 <atom> Pseudonym: mind explaining it?
15:37:37 <Pseudonym> atom: Well, think about the empty dice case first.
15:37:40 <newsham> pacz: cabal can be told to compile them
15:37:43 <Pseudonym> The only sum you can get from no dice is zero.
15:37:51 <atom> that's easy enough, yeah
15:37:55 <Pseudonym> And vice verse.
15:37:57 <Pseudonym> versa
15:38:02 <Pseudonym> OK.
15:38:06 <paczesiowa> newsham: I don't want to use cabal right now
15:38:06 <Pseudonym> Now the other case.
15:38:10 <ddarius> zeeeee: I was referring to your original statement.
15:38:13 <Pseudonym> If you have one die, d.
15:38:14 <zeeeee> ddarius, if you meant the Int, i don't care about it; that's just there to avoid the monomorphism restriction
15:38:21 <hpaste>  twanvl annotated "Can anyone help translate this into haskell?" with "fast algorithm explained" at http://hpaste.org/4013#a2
15:38:21 <atom> uh-huh
15:38:21 <newsham> pacz: then pass it in the .c files on the cmd line to ghc
15:38:22 <Pseudonym> And a bunch of other dice ds.
15:38:29 <atom> I came that far...
15:38:30 <Pseudonym> Then how many ways are there to form a sum s?
15:38:31 <newsham> s/it//
15:38:34 <atom> 1
15:38:37 <zeeeee> ddarius, yeah, i'd like to make that polymorphic; how do i type it so?
15:38:45 <Pseudonym> Suppose it was this:
15:38:53 <LoganCapaldo> ddarius: I get the feeling like he want b to vary. like f 0 :: (Io Int -> IO Int) , f 1 :: (IO () -> IO ())
15:38:56 <Pseudonym> diceProblem s (d:ds) = sum [diceProblem (s-x) ds | x <- [1..d] ]
15:39:03 <Pseudonym> Right?
15:39:07 <atom> yeah.
15:39:07 <Pseudonym> You pick a value of d, call it x.
15:39:16 <atom> k
15:39:23 <Pseudonym> Then the number of ways to form s given that the value of d is x, is diceProblem (s-x) ds
15:39:35 <Pseudonym> Make sense?
15:39:46 <atom> not yet, or otherwise i'd get it.
15:39:46 <paczesiowa> newsham: if I pass .c file with .hs file ghci fails to find module "*.c" if I try to compile .c file with ghc there are linker errors
15:39:49 <Pseudonym> :-)
15:39:56 <Pseudonym> OK.
15:40:04 <atom> wait, let me think first
15:40:06 <Pseudonym> Suppose you're trying to compute the number of ways to get a sum of 3 from 2d6.
15:40:12 <zeeeee> LoganCapaldo, i guess ddarius was referring to the first version of my question; for the second, yes, i need the b to vary, but *after* f has returned g
15:40:27 <newsham> oh, i meant for compilation.  for ghci I'm not sure.. maybe pass in the .o files?
15:40:30 <newsham> i've never used ghci with ffi
15:41:04 <LoganCapaldo> zeeeee: I don't think you can do it.
15:41:12 <newsham> [1 | x<-[1..6], y<-[1..6], x+y==3]
15:41:14 <newsham> > [1 | x<-[1..6], y<-[1..6], x+y==3]
15:41:16 <lambdabot>  [1,1]
15:41:19 <atom> Pseudonym: oh, I get what you did. You did the same thing I did, only with lots less code :)
15:41:20 <ddarius> :t undefined :: Int -> (forall b. IO b -> IO b) -- should be the same as without the forall
15:41:20 <lambdabot> forall b. Int -> IO b -> IO b
15:41:23 <Pseudonym> Right.
15:41:42 <Pseudonym> And the "min" is to cull out values of the dice that would definitely overflow.
15:42:01 <atom> Pseudonym: only... this isn't optimal. It works though.
15:42:09 <Pseudonym> No, it's not optimal.
15:42:22 <Pseudonym> Optimal would involve combinatorics.
15:42:26 <atom> Pseudonym: you still count all possible rolls.
15:42:27 <zeeeee> this is related to the old: let f i = (i 3, i "3")
15:42:29 <paczesiowa> how do I compile .c file with ghc? it's really simple (imports only it's header, one function) and ghc file.c fails to link it
15:42:32 <atom> Pseudonym: I don't think so, somehow...
15:42:43 <atom> Pseudonym: I don't know how to model this with combinatorics
15:42:58 <zeeeee> i is restricted to take on a single type, even if you pass in something polymorphic like id
15:43:06 <zeeeee> so there's no way around this?
15:43:06 <atom> Pseudonym: because the problem is NP-hard I think
15:43:08 <ddarius> > let f :: (forall a. a -> a) -> (Int,String); f i = (i 3, i "3")
15:43:08 <lambdabot>  Parse error at "." (column 19)
15:43:08 <newsham> ghc --make foo.hs foo.c bar.c ?
15:43:13 <ddarius> > let f :: (forall a. a -> a) -> (Int,String); f i = (i 3, i "3") in f id
15:43:13 <lambdabot>  Parse error at "." (column 19)
15:43:16 <Pseudonym> atom: No, it's not.
15:43:25 <Pseudonym> Finding out WHICH rolls is probably NP-something.
15:43:29 <Pseudonym> But finding the NUMBER probably isn't.
15:43:30 <sjanssen> @where cabal-install
15:43:31 <lambdabot> I know nothing about cabal-install.
15:43:32 <sjanssen> bah
15:43:33 <newsham> might need -fffi or something?
15:43:46 <atom> Pseudonym: isn't this the old "can I get these to sum to zero" problem?
15:43:55 <Pseudonym> Nope.
15:43:59 <newsham> knapsack problem?
15:44:02 <sjanssen> @where+ cabal-install http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
15:44:02 <lambdabot> I will never forget.
15:44:04 <Pseudonym> The thing that makes that NP-hard is negative numbers.
15:44:13 <atom> newsham: I think knapsack is something else
15:44:14 <Pseudonym> And again...
15:44:22 <Pseudonym> You're not interested in WHICH rolls sum to s.
15:44:27 <Pseudonym> You're only interested in how many.
15:44:28 <atom> Pseudonym: that's true.
15:44:54 <atom> Pseudonym: now, I could probably model this if all dice rolled were the same.
15:45:07 <atom> Pseudonym: since they're different, I'm stumped
15:45:25 <ddarius> This is where Cale is supposed to come in.
15:45:42 <LoganCapaldo> ddarius, zeeeee your f i example works in a file
15:45:43 <zeeeee> ddarius, haha
15:45:48 <LoganCapaldo> with -fglasgow-exts anyway
15:46:06 <newsham> pacz: did you look at any of the examples on the wiki?
15:46:10 <paczesiowa> newsham: using ghci --make, it compiled all the files but it dropped back to shell, so next invocation of ghci (without --make) loaded it ok
15:46:20 <Cale> Um, you want to model rolling of arbitrary dice?
15:46:47 <newsham> pacz: you could have probably just done "gcc -c file.c"
15:46:51 <newsham> to get the .o you needed
15:47:19 <Cale> Represent the die with faces a_1,...,a_n by the polynomial x^(a_1) + ... + x^(a_n). You can then model the rolling of multiple dice by the product of the corresponding polynomials.
15:47:36 <Cale> Then the coefficient of x^n in the product is the number of ways to roll an n.
15:47:45 <paczesiowa> newsham: I would like to have one haskell file which can be loaded with ghci or runhaskell, on *nix and windows
15:47:47 <zeeeee> ddarius, oh wow, that was it
15:47:51 <zeeeee> forall a.
15:48:02 <atom> Pseudonym: mind if I use the exact code fragment you posted?
15:48:04 <dibblego> @video
15:48:06 <lambdabot> eh?
15:48:15 <Cale> Does that make sense? Is it remotely what you're looking for?
15:48:15 <Pseudonym> atom: Not at all.
15:48:18 <zeeeee> newInterruptPair :: (Typeable e) => IO ((forall a. IO a -> IO a), (e -> IO ()))
15:48:19 <newsham> and you dont want to use cabal because... ?
15:48:21 <atom> Pseudonym: thanks
15:48:22 <Cale> Sorry that I've been a little distracted.
15:48:28 <LoganCapaldo> 6.8.1 says you can use just -XTypeOperators
15:48:37 <Pseudonym> The case of two dice is straightforward.
15:48:44 <Pseudonym> And the case of all equal dice is straightforward.
15:48:58 <LoganCapaldo> oh wait
15:49:01 <newsham> cale: is there a list convolution function in libs?
15:49:02 <LoganCapaldo> it was confused
15:49:07 <LoganCapaldo> don't listen to me :)
15:49:14 <paczesiowa> newsham: how do I tell windows people to run cabal commands? they double-click and expect it to work
15:49:28 <newsham> cabal is *the* portable way to build packages
15:49:33 <Cale> Not that I'm aware of.
15:49:41 <Cale> But it's pretty easy to do.
15:49:54 <ihope> You could make a batch file for Windows.
15:50:06 <newsham> pacz: use cabal to build a binary package for your windows users?
15:50:14 <newsham> does cabal have an option for building a windows installer?
15:50:16 <paczesiowa> java .jar files are double-clickable in windows and linux
15:50:35 * ddarius remembers doing convolution in some crack headed way once.
15:51:05 <atom> Pseudonym: hm... do you think these could be somehow concatenated?
15:51:09 <atom> Pseudonym: like... multiplying probabilities?
15:51:20 <LoganCapaldo> ISTR .(l)hs are double clickable in windows too ...
15:51:41 <ddarius> Something involving a parameterized "powerlist" function.
15:51:47 <LoganCapaldo> Maybe if platform is windows and no command line arguments then configure setup install ?
15:51:50 <Cale> % With[{d = Function[n, Sum[x^k,{k,1,n}]]}, Expand[d[6] d[8] d[12]]]
15:51:52 <mbot> Cale: x^3 + 3*x^4 + 6*x^5 + 10*x^6 + 15*x^7 + 21*x^8 + 27*x^9 + 33*x^10 + 38*x^11 + 42*x^12 + 45*x^13 + 47*x^14 + 47*x^15 + 45*x^16 + 42*x^17 + 38*x^18 + 33*x^19 + 27*x^20 + 21*x^21 + 15*x^22 + 10*x^
15:51:52 <mbot> 23 + 6*x^24 + 3*x^25 + x^26
15:51:52 <lambdabot> mbot: You have 1 new message. '/msg lambdabot @messages' to read it.
15:51:59 <Cale> heh
15:52:29 <newsham> cale: you're basically saying to use list convolution to do this.  wouldnt that be a lot easier to write/view than pretending its a polynomial?
15:52:42 <Cale> Well, it's naturally polynomial multiplication.
15:53:03 <newsham> sure, but its the same operation and [1,1,1] is easier to read :)
15:53:13 <LoganCapaldo> mbot: I find your addressing of responses to the querent fascinating and wish to subscribe to your newsletter
15:53:24 <atom> freenode is very shaky today...
15:53:36 <newsham> let (*) = conv, die=[1,1,1,1,1,1] in (die*die*die*die)!!4
15:53:39 <zeeeee> is there a way to discard an IO return type aside from (>> return ())?
15:53:46 <newsham> is basically what you're saying, yes?
15:54:04 <dibblego> zeeeee, what happens in the monad, stays in the monad
15:54:04 <LoganCapaldo> zeeeee: how else would you expect to do it?
15:54:04 <Cale> So for example, in that response, the 47 x^14 means that there are 47 ways to roll a 14 with a d6, d8 and d12
15:54:35 <LoganCapaldo> I mean any other way would have to be equivalent to (>> return ()) right?
15:54:36 <Cale> newsham: sort of?
15:54:43 <Cale> newsham: My dice were all different.
15:54:54 <newsham> let d n = replicate n 1 in (d 6 * d 8 * d 12) !! 14
15:55:02 <Cale> But yes, multiplication is convolution of the coefficient lists.
15:55:07 <newsham> where (*) = convolution
15:55:22 <LoganCapaldo> > let m_ a = a >> return () ;)
15:55:22 <lambdabot> Unbalanced parentheses
15:55:23 <mbot>  Unbalanced parenthesis
15:55:30 <LoganCapaldo> wow
15:55:34 <LoganCapaldo> thanks mbot
15:55:37 <newsham> ?bot attack
15:55:37 <lambdabot> :)
15:55:37 <mbot> :)
15:55:47 <faxathisia> > 1+1
15:55:50 <lambdabot>  2
15:56:00 <LoganCapaldo> > let a = 1 in a
15:56:00 <lambdabot>  1
15:56:02 <faxathisia> O_o
15:56:05 <LoganCapaldo> > let a = 1 in a -- )
15:56:06 <lambdabot>  1
15:56:06 <mbot>  Unbalanced parenthesis
15:56:06 <faxathisia> )
15:56:12 <faxathisia> >:)
15:56:19 <LoganCapaldo> mbot: I think you are a little confused
15:56:21 <Cale> mbot: @part
15:56:22 <mbot> Plugin `system' failed with: IRCRaised Prelude.last: empty list
15:56:24 <ddarius> Does balancing naturally imply plural?  I.e. who was right lambdabot or mbot?
15:56:29 <Cale> oh, great
15:56:35 <faxathisia> haha
15:56:38 <Cale> heh
15:56:52 <ddarius> mbot: @part #haskell
15:56:52 <mbot> Not enough privileges
15:57:05 <Pseudonym> ?where ?where
15:57:05 <lambdabot> ?where ?where
15:57:06 <mbot> ?where
15:57:06 <mbot> ?where
15:57:06 <lambdabot>  @where <key>, return element associated with key
15:57:06 <lambdabot>  @where <key>, return element associated with key
15:57:07 <Japsu> Which version of GHC does the current lambdabot head require?
15:57:21 <faxathisia> woah!
15:57:22 <Japsu> I mean, I'm stuck with 6.6.1, can I safely darcs pull?
15:57:34 <Olathe> > 5
15:57:35 <lambdabot>  5
15:57:36 <Pseudonym> ?where ?where
15:57:36 <lambdabot> ?where ?where
15:57:36 <mbot> ?where ?where
15:57:36 <mbot> ?where ?where
15:57:37 <lambdabot> ?where ?where
15:57:37 <lambdabot> ?where ?where
15:57:37 <mbot> ?where ?where
15:57:37 <mbot> ?where ?where
15:57:37 <lambdabot> ?where ?where
15:57:38 <lambdabot> ?where ?where
15:57:38 <mbot> ?where ?where
15:57:38 <mbot> ?where ?where
15:57:38 <Pseudonym> Woo!
15:57:39 <lambdabot> ?where ?where
15:57:40 <mbot> ?where ?where
15:57:41 <lambdabot> ?where ?where
15:57:42 <Japsu> :DDDDD
15:57:42 <mbot> ?where ?where
15:57:43 <lambdabot> ?where ?where
15:57:43 <ihope> My.
15:57:44 <mbot> ?where ?where
15:57:45 <lambdabot> ?where ?where
15:57:46 <mbot> ?where ?where
15:57:47 <lambdabot> ?where ?where
15:57:48 <mbot> ?where ?where
15:57:49 <lambdabot> ?where ?where
15:57:49 <faxathisia> > [1..]
15:57:50 <mbot> ?where ?where
15:57:51 <lambdabot> ?where ?where
15:57:51 <Olathe> :(
15:57:52 <Pseudonym> ?part #haskell
15:57:53 <mbot> ?where ?where
15:57:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:57:54 <mbot> Not enough privileges
15:57:55 <lambdabot> ?where ?where
15:57:56 <mbot> ?where ?where
15:58:03 <newsham> good job
15:58:06 <Pseudonym> OK.
15:58:11 <Pseudonym> Nobody do that, k?
15:58:14 <atom> Cale: thanks... I looked your posts over
15:58:14 <Olathe> > 5
15:58:15 <lambdabot>  5
15:58:19 <ihope> Okay :-)
15:58:20 <atom> Cale: at last...
15:58:21 <faxathisia> Pseudonym cool
15:58:23 <faxathisia> :D
15:58:58 <atom> Cale: but there's a problem. I'm gonna have to stare at that for quite some time again to actually get it. That polynomial was pretty scary :)
15:59:24 <ddarius> That polynomial was just an example.
15:59:53 <atom> ddarius: was the code that generated it valid haskell?
15:59:59 <atom> or was it a lambdabot ext?
16:00:15 <newsham> whats a short convolution implementation?
16:00:29 <newsham> [sum (zipWidth (*) xs ys) | ... ]
16:00:31 <ddarius> atom: It was mathematica, but it would be easy to implement in Haskell as well.
16:00:46 <atom> ddarius: oh, ok...
16:01:08 <Japsu> Whose idea was ?where+ ?where ?where ?where, anyway? ;D
16:01:25 <LoganCapaldo> @v
16:01:25 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:01:26 <mbot> Just 'J'
16:01:29 <ddarius> Japsu: Russell's
16:01:33 <Japsu> lol
16:01:59 <faxathisia> mbot: What??
16:02:06 <atom> as far as functional programming goes, I'm a noob, so I guess it's understandable that I won't get stuff, but still, it's not something I like doing, not getting stuff :)
16:02:26 <Olathe> @v
16:02:26 <lambdabot> Just 'J'
16:02:27 <mbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:02:30 <Olathe> O-o
16:02:35 <faxathisia> ...
16:02:48 <dmwit> They probably both have the @v plugin.
16:02:53 <faxathisia> @quote :)
16:02:53 <lambdabot> DRMacIver says: So basically the lambda calculus is a demonstration that verbing weirds language? :)
16:02:54 <mbot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
16:03:08 <faxathisia> @@ @@
16:03:22 <dmwit> ...that's nasty
16:03:26 <dmwit> ?botsnack
16:03:27 <lambdabot> :)
16:03:27 <mbot> :)
16:03:32 <Japsu> newsham: http://hpaste.org/3083 -- non-short convolution ;)
16:03:46 <oerjan> @@ @v
16:03:47 <lambdabot>  Just 'J'
16:03:47 <LoganCapaldo> > let { f i :: (forall a. a -> a) -> (Int,String) ; f i = (i 3, i "3") } in f id -- or was it just because Language.Haskell runs interference?
16:03:48 <lambdabot>  Parse error at "::" (column 11)
16:03:48 <mbot>  Parse error
16:04:10 <atom> Cale: I get it... It now feels strange I haven't thought of that earlyer
16:04:21 <atom> earlier, even :)
16:04:45 <oerjan> LoganCapaldo: > essentially only does H98
16:05:02 <zeeeee> dibblego, LoganCapaldo i guess i meant if there's a standard discard f = f >> return ()
16:05:25 <oerjan> :t (*>)
16:05:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:05:29 <mbot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
16:05:29 <mbot> [2 of 2] Compiling L                ( L.hs, interpreted )
16:05:39 <SamB_XP> @type liftM (const ())
16:05:40 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m ()
16:05:42 <mbot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
16:05:42 <mbot> [2 of 2] Compiling L                ( L.hs, interpreted )
16:05:48 <dmwit> :t let do_ = (>> return ()) in do_
16:05:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:05:51 <mbot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
16:05:51 <mbot> [2 of 2] Compiling L                ( L.hs, interpreted )
16:05:57 <LoganCapaldo> mbot: dude.
16:05:59 <Olathe> ["devils", "djinn-env", "djinn-ver", "eval", "poll-remove", "v", "vera", "version", "vixen", "vote"]
16:06:13 <faxathisia> lol
16:06:17 <dmwit> Ooo, two vixens!
16:06:20 <dmwit> ?vixen
16:06:20 <lambdabot> Uh-huh
16:06:21 <mbot> Unknown command, try @list
16:06:24 <faxathisia> :(
16:06:41 <dmwit> ?vixen I can solve a Rubik's cube in under fifteen seconds!
16:06:42 <mbot> Unknown command, try @list
16:06:44 <lambdabot> have you ever scubadived?
16:06:45 <dmwit> dang
16:06:54 <faxathisia> @@ > "huh"
16:06:55 <lambdabot>  > "huh"
16:07:11 <oerjan> :t (() <$)
16:07:11 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
16:07:14 <LoganCapaldo> @@ run "huh"
16:07:14 <lambdabot>  run "huh"
16:07:14 <mbot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
16:07:14 <mbot> [2 of 2] Compiling L                ( L.hs, interpreted )
16:07:15 <Olathe> None of those produce Just 'J' on lambdabot.
16:07:28 <zeeeee> dmwit, that's a good name
16:07:29 <dmwit> @@ @type (() <$)
16:07:29 <lambdabot>  forall (f :: * -> *) b. (Functor f) => f b -> f ()
16:07:36 <faxathisia> What is Just 'J'?
16:07:37 <zeeeee> do_
16:07:50 <dmwit> thx
16:07:51 <LoganCapaldo> mbot's favorite programming language?
16:08:06 <faxathisia> @@ ?quote :)
16:08:06 <lambdabot>  geezusfreeek says: "i was half hoping lambdabot would lie and make something up :)"
16:08:49 <sjanssen> mbot: @part #haskell
16:08:49 <mbot> Not enough privileges
16:09:12 <sjanssen> Cale: can you make mbot go away?
16:09:33 * shapr boings cheerfully
16:09:47 * LoganCapaldo wants to see an mbot lmabdabot death match
16:09:56 <faxathisia> @quote hurt
16:09:56 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
16:09:57 <mbot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
16:09:57 <mbot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
16:10:06 <shapr> hah
16:10:10 <Olathe> > listToMaybe "Just 'J'"
16:10:11 <lambdabot>  Just 'J'
16:10:33 <SamB_XP> this theory may or may not have a lot to say about ZSNES
16:10:40 <oerjan> o_O
16:10:56 <LoganCapaldo> hehehhe
16:11:03 <ihope> Oh, that listToMaybe's cute :-)
16:11:04 <LoganCapaldo> Olathe++
16:11:17 <resiak> how does that work?
16:11:39 <oerjan> > listToMaybe "thus"
16:11:40 <lambdabot>  Just 't'
16:11:46 <Olathe> > let mHead = listToMaybe in map mHead [[], [1..]]
16:11:47 <lambdabot>  [Nothing,Just 1]
16:11:47 <resiak> oh
16:11:49 <resiak> cute
16:11:50 <SamB_XP> the first 'J' is the 'J' it uses
16:12:26 <LoganCapaldo> @remember Olathe > listToMaybe "Just 'J'"
16:12:26 <lambdabot> It is forever etched in my memory.
16:12:27 <mbot> Okay.
16:12:41 <faxathisia> @quote listToMaybe
16:12:41 <lambdabot> Olathe says: > listToMaybe "Just 'J'"
16:12:42 <mbot> Olathe says: > listToMaybe "Just 'J'"
16:12:44 <ddarius> @check read "Just 'J'" == listToMaybe "Just 'J'"
16:12:45 <mbot> Plugin `check' failed with: IRCRaised Data.ByteString.last: empty ByteString
16:12:46 <lambdabot>  OK, passed 500 tests.
16:13:06 <LoganCapaldo> oh this is just bizzare
16:13:09 * faxathisia struggles not to @remember @quote
16:14:12 <hpaste>  newsham pasted "rolling dice (d6,d8,d12) to get 14" at http://hpaste.org/4014
16:14:24 <LoganCapaldo> > listToEither "Right 'R'"
16:14:36 <lambdabot>   Not in scope: `listToEither'
16:14:41 <LoganCapaldo> haha only kidding
16:15:16 <LoganCapaldo> @let listToEither [] = Left () ; listToEither (x:_) = Right x
16:15:17 <mbot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
16:15:19 <newsham> hmm.. not the same answer as cale's is it?
16:15:31 <lambdabot> thread killed
16:15:36 <LoganCapaldo> fne
16:15:41 <LoganCapaldo> *fine
16:15:47 <zeeeee> "let handleDyn b h = catchDyn h b; handleDyn (putStrLn . show) (...)" gives me "Ambiguous type variable 'exception' in the constraints: Typeable exception and Show exception" ... i can't figure out how to appease the type checker, i've tried adding myriad types to the handler
16:16:04 <faxathisia> @remember @quote foobarbaz
16:16:04 <lambdabot> It is forever etched in my memory.
16:16:04 <mbot> Good to know.
16:16:33 <oerjan> > (return.head) "Right 'R'" :: Either () Char
16:16:34 <lambdabot>   add an instance declaration for (Error ())
16:16:39 <LoganCapaldo> lambdabot: You keep using that word. I do not think it means what you think it means.
16:16:40 <oerjan> > (return.head) "Right 'R'" :: Either String Char
16:16:41 <lambdabot>  Right 'R'
16:16:41 <newsham> first my indexing is off by one...
16:16:52 <newsham> index 0 == roll #1
16:18:13 <LoganCapaldo> oerjan: well done. I think the listToMaybe had more cognitive dissonance though
16:19:02 --- mode: ChanServ set +o Cale
16:19:14 --- kick: mbot was kicked by Cale (Cale)
16:19:20 --- mode: Cale set -o Cale
16:19:31 <Cale> (The system module is broken)
16:20:26 <atom> Cale: thanks a lot for that polynomial multiplication thing, it really opened my eyes.
16:20:33 <newsham> hmm. my code is broken.
16:20:36 <Cale> no problem
16:20:57 <sjanssen> @ask dcoutts I want 'Setup ghci'.  Do you think this would be fairly easy?  Would such a patch be accepted?
16:20:57 <lambdabot> Consider it noted.
16:21:05 <atom> Cale: I still have to figure out how to write that in haskell, but don't tell me.
16:21:14 <Cale> all right :)
16:21:50 <atom> i'll be around later tomorrow, now i'm hitting the sack
16:21:57 <atom> have fun everyone
16:24:28 <newsham> ok, phew, my convolutio code gives the right answer now
16:25:55 <newsham> ?let conv xs ys = [sum (zipWith (*) xs y) | y <- tails (replicate (length xs - 1) 0 ++ reverse ys)]
16:25:59 <lambdabot> Defined.
16:26:06 <newsham> ?let die n = 0 : replicate n 1
16:26:08 <lambdabot> Defined.
16:26:14 <sutats> Say I have a function printTime, and I want to call it every second in a loop. What's the Haskell way of doing something like that?
16:26:22 <newsham> > let (*) = conv in (die 6 * die 8 * die 12) !! 14
16:26:22 <lambdabot>  47
16:27:06 <SamB_XP> sutats: ... haskell way?
16:27:12 <SamB_XP> that's so timey!
16:27:18 <newsham> sutat: forkIO a thread that is an infinite loop that sleeps and then runs the action?
16:28:45 <Cale> If you don't care about doing anything else while that's going on of course you can skip the forkIO. However, you'll still need threadDelay.
16:28:50 <sutats> SamB_XP: Well, I'm new to Haskell, so the only method of doing that would be something like "while (1) { ...; sleep 1; }
16:29:10 <sjanssen> sutats: import Control.Concurrent (threadDelay)
16:29:24 <dcoutts> sjanssen: I think it would not be that easy, but yes it would be accepted. We've thought about this a little before.
16:29:24 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
16:29:35 <sutats> Ah, okay, I'll check that out. Thanks.
16:29:39 <sjanssen> dcoutts: oh, what are the difficulties?
16:29:40 <oerjan> sutats: there's a forever in the newest Control.Monad
16:29:47 <Cale> loop = do printTime; threadDelay (10^6); loop
16:30:08 <sjanssen> dcoutts: can't one just replace 'ghc --make' with 'ghci'?
16:30:12 <sutats> oerjan: How would that look?
16:30:15 <oerjan> forever (printTime >> threadDelay (10^6))
16:30:18 <dcoutts> sjanssen: well I suppose most of it would be the same as the ghc build bit, ie pre-process everything and launch ghci with similar parameters
16:30:20 <Cale> Then you can "forkIO loop", and it'll run in a separate thread.
16:30:53 <oerjan> (>> is just a shorter version of do ... ; ... really)
16:31:23 <sutats> Ah, this is all good stuff to know, thanks.
16:31:31 <dcoutts> sjanssen: you'd also want to set up the ghci environment so that :reload calls out to cabal to re-prepreprocess
16:32:19 <dcoutts> sjanssen: and you couldn't call it cabal ghci :-) has to be more generic so it could reasonably be implemented for hugs/yhc
16:32:41 <SamB_XP> dcoutts: let them get their own shorthands
16:32:45 <LoganCapaldo> cabalist?
16:32:52 <newsham> why not just cabal install yoru package before calling ghci?
16:33:09 <dcoutts> newsham: interactive development
16:33:19 <newsham> oh
16:33:28 <SamB_XP> how about "cabal ghci" just be shorthand for "cabal interactive", maybe with some flags?
16:33:34 <sjanssen> dcoutts: alternatively, does the API expose enough information to write a client program that does this?
16:33:40 <newsham> isnt that something that emacs should do? ;-)
16:33:46 <nominolo> "cabal prompt"
16:34:04 <nominolo> "cabal shell"
16:34:08 <dcoutts> sjanssen: maybe, but I think it's nicer to be kept together so it doesn't get out of sync
16:34:13 <SamB_XP> "cabal shell" is also good
16:34:15 <twanvl> "cabal interact"
16:39:11 <shapr> Seems that the array package from hackage is broken.
16:40:12 <LoganCapaldo> cabal develop!
16:40:23 <LoganCapaldo> (the ! is part of the command)
16:44:39 <shapr> Bah, I found a bug in the darcs version of cabal. If you use 'cabal install --global $PACKAGE" the dependencies are installed as --user
16:45:52 <LoganCapaldo> that's not a bug, it's a security feature! :)
16:46:31 * SamB_XP wishes he had work study this semester, at least in terms of getting money on a regular basis...
16:47:28 <SamB_XP> LoganCapaldo: you do realize that would be a PITA to get past shells?
16:47:38 <LoganCapaldo> yeah
16:47:41 <LoganCapaldo> it's unfortunate
16:50:01 <shapr> cabal-get is lovely
16:52:27 <shapr> Er actually, I think --global doesn't work at all.
16:52:39 <ddarius> cabal-fetch
16:52:42 <ddarius> cabal-rollover
16:52:48 <puusorsa> cabal-playdead
16:53:25 * shapr grumbles
16:53:57 <LoganCapaldo> cabal-cabal
16:54:08 <nominolo> there is no cabal
16:54:31 <nominolo> cabal-tinc
16:54:36 <puusorsa> but the bavarian cabal
16:54:50 <LoganCapaldo> cabal-illuminate
16:55:52 <shapr> Yes, it seems that --global doesn't work at all.
16:56:14 * shapr grumbles
16:56:29 <newsham> > conv [1] [1,2,3,4,5]
16:56:39 <lambdabot>  [5,4,3,2,1,0]
16:56:42 <newsham> bzzzt wrong.
16:56:44 <newsham> :(
16:56:51 <shapr> @type conv
16:56:52 <lambdabot> Not in scope: `conv'
16:56:55 <shapr> ?
16:56:57 <shapr> @index conv
16:56:57 <lambdabot> bzzt
16:57:05 <newsham> I did a ?let earlier.
16:57:09 <shapr> oh
16:57:13 <shapr> @src conv
16:57:14 <lambdabot> Source not found. There are some things that I just don't know.
16:57:16 <shapr> foo
16:57:16 <newsham> fixed impl at: http://hpaste.org/4014#a4
16:57:43 <shapr> Looks like fetch doesn't work either.
16:59:37 <shapr> Also, "cabal install $FOO" should probably have --user by default, otherwise it doesn't actually work. The build-deps for $FOO are all built with --user, but $FOO itself only looks in the global package list. But then, I'm doing this all as root on an EC2 instance.
16:59:42 <shapr> That may be part of the problem.
17:01:33 <newsham> > take 5 $ iterate (conv [1,1]) [1]
17:01:35 <lambdabot>  [[1],[1,1,0],[0,1,2,1,0],[0,1,3,3,1,0,0],[0,0,1,4,6,4,1,0,0]]
17:02:30 <newsham> ?let conv xs ys = tail [sum (zipWith (*) xs y) | y <- reverse (tails (replicate (length xs - 1) 0 ++ reverse ys))]
17:02:30 <lambdabot> <local>:29:0:     Multiple declarations of `L.conv'     Declared at: <local>:...
17:02:38 <newsham> ?let conv2 xs ys = tail [sum (zipWith (*) xs y) | y <- reverse (tails (replicate (length xs - 1) 0 ++ reverse ys))]
17:02:41 <lambdabot> Defined.
17:02:46 <newsham> > take 5 $ iterate (conv2 [1,1]) [1]
17:02:47 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
17:08:35 <zeeeee> does ghc include unused code in the resulting binary? (i always end up with massive binaries, even for the most trivial programs)
17:09:54 <Olathe> What is the thing supposed to compute ?
17:10:40 <oerjan> zeeeee: i think it depends on whether ghc's libraries are built with a --split-objs option
17:11:33 <Olathe> Oh.
17:11:36 <zeeeee> oerjan, so short of rebuilding ghc with --split-objs or running 'strip', there are no easy ways to make my binaries smaller
17:13:32 <oerjan> there ought to be someone here who knows this better than I...
17:16:02 <LoganCapaldo> explicit import lists might help
17:16:07 * LoganCapaldo is guessing
17:16:46 <ddarius> The GHC user's guide gives some tips.
17:19:33 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/smaller.html
17:19:58 <oerjan> @bot
17:19:59 <lambdabot> :)
17:20:06 <Olathe> @b
17:20:06 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . ? @ v
17:20:08 <Olathe> @bo
17:20:08 <lambdabot> :)
17:20:32 <oerjan> @boo
17:20:33 <lambdabot> Maybe you meant: bf bug todo yow
17:22:25 <Olathe> @botsrock
17:22:25 <lambdabot> :)
17:22:40 <lament> @botsmack
17:22:40 <lambdabot> :)
17:26:27 <Olathe> @botack
17:26:27 <lambdabot> :)
17:26:29 <Olathe> @botnak
17:26:29 <lambdabot> :)
17:26:41 <Olathe> Should be :(
17:29:30 <dons> a fixed MaybeT just got uploaded to hackage
17:30:23 <LoganCapaldo> MaybeT was broken?
17:30:25 * dons hacks lambdas all day
17:30:27 <dons> import Control.Monad
17:30:27 <dons> import Control.Monad.Maybe
17:30:27 <dons> import Control.Monad.State
17:30:27 <dons> import Control.Monad.Writer
17:30:29 <dons> import Control.Arrow
17:30:32 <dons> import Control.Applicative
17:30:38 <dons> that's ur real world haskell right there!
17:30:47 <dons> (*ssh. proprietary codez)
17:31:03 <dons> LoganCapaldo: oh, just abuild error
17:31:11 <LoganCapaldo> ah
17:31:29 <LoganCapaldo> a bug woulda been impressive
17:31:37 <dons> :) scary thought
17:31:47 <dons> who knows, maybe there's a strictness bug .
17:31:50 <dons> very hard to say
17:34:22 <zeeeee> is there a cheap way to get the localhost's hostname? (aside from runInteractiveCommand "hostname -i")
17:34:37 <dons> something in System.Posix.* iirc
17:35:00 <LoganCapaldo> @hoogle getHostName
17:35:00 <lambdabot> Network.BSD.getHostName :: IO HostName
17:35:08 <dons> :t System.Posix.Unistd.gethostname
17:35:09 <lambdabot> Not in scope: `System.Posix.Unistd.gethostname'
17:35:22 <dons> ?hoogle gethostname
17:35:22 <lambdabot> Network.BSD.getHostName :: IO HostName
17:36:10 <hpaste>  (anonymous) annotated "Can anyone help translate this into haskell?" with "(no title)" at http://hpaste.org/4013#a3
17:36:23 <zeeeee> dons, i'm looking at the index and can't find anything like it in system posix
17:46:04 <allbery_b> gethostname, while in Network.BSD, is not really a network function
17:46:30 <allbery_b> and gethosname(3) / sethostname(3) are the libc equivalent of the hostname command
17:47:33 <allbery_b> the ip address (gnu extension) is not portably available
17:48:55 <allbery_b> you ca use gethostbyname (or Network.BSD version thereof) or you can write sysdep code to obtain it from ifconfig stuff; this can't be done in Haskell in general (and almost certainly not on linux; easier to use "ip addr list")
17:55:48 <zeeeee> allbery_b, 'ip addr list'?
17:57:27 <shapr> Shouldn't the array package from hackage build?
17:57:38 * shapr grumbles
17:58:57 <shapr> Where's the darcs repo for the array package?
17:59:41 <sjanssen> shapr: you shouldn't have to build it
18:00:07 <sjanssen> arrays are in base in GHC 6.6, and it comes by default in 6.8
18:00:37 <shapr> Oh, hm
18:00:51 <allbery_b> zeeeee: I assumed linux because hostname -i is a linux/gnu-ism.  ifconfig works on most systems but can be unreliable on linux; "ip addr list" tells the whole story
18:00:52 <shapr> I installed ghc6 from haskell-unsafe, it doesn't think it has array.
18:01:14 <allbery_b> if that's ghc6.8.1 then array was unbundled
18:01:18 <zeeeee> allbery_b, i don't understand what "ip addr list" means
18:01:25 <sjanssen> ah, I didn't know that
18:01:26 <allbery_b> it's a system command
18:01:39 <allbery_b> you'll need to use runInteractiveCommand
18:01:41 <zeeeee> ah
18:02:09 <allbery_b> again, the equivalent of gethostbyname(gethstname()) is probably good enough, but it depends on what your'e doing
18:05:12 <zeeeee> i'd like to parameterize (argv) what were previously some global constants, but it seems then i'll either need to introduce an arg to each function, or move all the functions defs somewhere under main's lex scope (where i parse argv), or use iox = unsafePerformIO $ newIORef _ ... writeIORef iox parsed ... x = unsafePerformIO $ readIORef iox ... are there any better suggestions?
18:05:46 <sjanssen> zeeeee: do *not* define a function like iox
18:05:51 <zeeeee> sjanssen, ok..
18:06:23 <sjanssen> zeeeee: the compiler may decide to share that single IORef, which is very very unsafe
18:06:27 <shapr> Weird, array builds on my desktop, but not on the EC2 instance.
18:06:37 <zeeeee> sjanssen, (i have seen such code before, that's why i thought of it)
18:06:49 <sjanssen> shapr: is the EC2 instance running ghc 6.8?
18:06:59 <shapr> Yeah, from haskell-unsafe
18:07:08 <shapr> But, so is my desktop.
18:07:47 <zeeeee> sjanssen, hm, do you mean that it's unsafe if the compiler decides *not* to share the ioref, and instead duplicate it?
18:07:48 * SamB_XP wonders why firefox doesn't dither images in 16-bit mode...
18:07:59 <zeeeee> duplicate/reevaluate/etc
18:08:16 <sjanssen> zeeeee: it is okay to write "foo = unsafePerformIO (newIORef "blah")", but it is not a great idea to factor out the unsafePerformIO . newIORef part
18:08:40 <shapr> sjanssen: Ah, my desktop has base-3.0.0.0 but the ec2 instance has base-2.1.1.1
18:09:26 <sjanssen> shapr: oh, that sounds like GHC 6.8 before the 6.8.1 release
18:09:32 <shapr> Ah crap
18:10:04 <sjanssen> zeeeee: hrm, I was confused about your code, sorry
18:10:22 <shapr> Does this mean I have to build ghc from soure? :-/
18:10:32 <zeeeee> sjanssen, so, disregard the above? :)
18:10:45 <sjanssen> zeeeee: yes, that is the safe version, but it makes all Haskell lovers squirm ;)
18:11:03 <zeeeee> sjanssen, i don't know what else to do, other than my first two suggestions, which just seem terrible
18:11:14 <sjanssen> zeeeee: to be extra safe, add NOINLINE
18:11:47 <sjanssen> zeeeee: another option is to move your program into a ReaderT MyVars IO
18:12:18 <zeeeee> sjanssen, thus changing all the functions to be monadic?
18:12:31 <sjanssen> zeeeee: yes, unfortunately
18:13:02 <zeeeee> i'd think that would make haskell lovers squirm even more
18:13:24 <sjanssen> you can cut out the IO part if the code is pure
18:13:30 <sjanssen> just Reader MyVars
18:13:54 <zeeeee> nonetheless...
18:14:25 <SamB_XP> ST?
18:15:17 <SamB_XP> oh, wait, nevermind...
18:15:33 * SamB_XP thinks GHC does that unsafePerformIO thing too...
18:16:17 <sjanssen> GHC has plenty of crufty code
18:16:40 <SamB_XP> true, dat
18:16:55 <SamB_XP> GHC seems to predate the Monadic Revolution, even
18:17:14 <SamB_XP> rather like nhc ;-)
18:17:20 <sjanssen> heh, nhc
18:17:28 <SamB_XP> at least, however, GHC has recovered from this problem
18:17:43 <SamB_XP> nyhc has not
18:17:53 <LoganCapaldo> pre monad haskell musta been a really really strange place
18:18:17 <SamB_XP> well, I'm inferring this from the bindFoo and thenFoo functions still found in some obscure code...
18:18:47 <sjanssen> SamB_XP: right, monadic code that isn't 'Monad'ic
18:19:05 <SamB_XP> nyhc has some things that are *so* close to being monadic, but aren't quite
18:19:10 <SamB_XP> this is really maddening :-(
18:19:17 <zeeeee> are there any haskell libs for parsing command-line args?
18:19:38 <LoganCapaldo> parsec?
18:19:43 <LoganCapaldo> :p
18:19:54 <sjanssen> zeeeee: System.Console.GetOpt is one
18:22:49 <zeeeee> sjanssen, thanks... i missed that
18:29:15 <wli> CPS as usual.
18:29:29 <sjanssen> hmm?
18:29:49 <wli> The pre-monadic code in nhc, yhc, et al.
18:32:59 <hpaste>  (anonymous) annotated "Can anyone help translate this into haskell?" with "(no title)" at http://hpaste.org/4013#a4
18:33:24 <Pseudonym> Sorry, that was me.
18:33:27 <Pseudonym> And I should note:
18:33:28 <Pseudonym> *Main> diceProblem 100 [50,50,50,50,50,50,50,50,50,50]
18:33:28 <Pseudonym> 276763048
18:33:29 <Pseudonym> (0.08 secs, 5974000 bytes)
18:34:16 <Pseudonym> Yay Karatsuba multiplication.
18:35:11 <wli> What's Karatsuba multiplication?
18:35:16 <Pseudonym> That. :-)
18:35:30 <Pseudonym> Suppose you have A = A0 + A1x and B = B0 + B1x
18:35:31 <Pseudonym> For some x.
18:35:45 <Pseudonym> Suppose: X = A0 B0 and Y = A1 B1
18:35:48 <wli> I'm stuck without X so browsing isn't possible in earnest at the moment.
18:36:07 <Olathe> Isn't diceProblem solvable with dynamic programming ?
18:36:16 <Pseudonym> Then: AB = X + Yx^2 + ((A0+A1)(B0+B1) - X - Y)x
18:36:33 <Pseudonym> The point being that you can compute AB with three multiplications rather than the traditional four.
18:36:44 <Pseudonym> Apply recursively, and you have Karatsuba multiplication.
18:38:56 <wli> Is there work ongoing to straighten out the gentoo situation?
18:39:57 <wli> Things are a bit hairy there.
18:40:07 <goalieca> the nice thing about linux is that there are so many other choices
18:40:13 <Pseudonym> Hmm.
18:40:16 <Pseudonym> Code is wrong somewhere.
19:06:22 <Brian`> @undo \a -> do { a' <- a; return (f a') }
19:06:23 <lambdabot> \ a -> a >>= \ a' -> return (f a')
19:08:43 <soduko> > :t return
19:08:45 <lambdabot>   parse error on input `:'
19:08:50 <wolverian> :t return
19:08:51 <soduko> >:t return
19:08:51 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:09:09 <wolverian> too many prefixes!
19:09:23 <soduko> is teh above code to unreturn?
19:09:54 <soduko> how do we achieve unreturn::( Monad m ) => ma -> a
19:10:14 <wolverian> we don't. :)
19:11:17 <sjanssen> soduko: there is no way to write unreturn
19:12:10 <glguy> ?seen dons
19:12:11 <lambdabot> dons is in #haskell, #ghc and #xmonad. I last heard dons speak 1h 36m 48s ago.
19:12:17 <soduko> today i ran into a problem.. i have a text file, that is kind of a hierarchy.. i wanted to construct an xml file from that..
19:13:21 <wolverian> yes, XML is a problem.
19:13:47 <soduko> readFile "text.txt"  returns a IO String  so i struggled a lot with the do notation and bind >>=
19:13:55 <soduko> finallly figured out what to do :)
19:14:10 <skew> what to *do*?
19:14:16 <glguy> is soduko a variation of sudoku?
19:14:19 <soduko> pun intended
19:14:33 <soduko> its a spelling mistake:) kindof like google
19:14:42 <dibblego> soduko, think of IO being a container that is slightly misnamed (it should be called FileSystem)
19:14:55 <dibblego> FileSystem String is "a FileSystem containing a String"
19:14:58 <skew> dibblego: no, the code is working!
19:15:09 <dibblego> oh wait, sorry
19:17:29 <soduko> but im still kinda confused..
19:19:36 <soduko> if you want the contents of a file, fr fn= do x<- readFile fn ; return x
19:19:49 <soduko> but :t fr
19:19:51 <soduko> fr :: FilePath -> IO String
19:19:55 <ddarius> readFile fn
19:20:09 <ddarius> fr = readFile
19:20:11 <soduko> within the do x is a string
19:20:52 <skew> then if you want to do stuff with a string
19:21:15 <skew> do x <- fr fn; let results = doStuffWithAString x; print results
19:21:33 <newsham> > let (*) = conv2; d = 0:replicate 50 [1] in (d*d*d*d*d*d*d*d*d*d)!!100
19:21:35 <lambdabot>   add an instance declaration for (Num [t])
19:21:35 <lambdabot>     In the expression: conv2
19:21:35 <lambdabot>     ...
19:21:47 <soduko> skew: i did some thing similar, but used a where clause also
19:21:54 <newsham> > let (*) = conv2; d = 0:replicate 50 1 in (d*d*d*d*d*d*d*d*d*d)!!100
19:21:55 <skew> sure, whatever
19:21:56 <lambdabot>  1710486389304
19:21:56 <dibblego> do we have consensus yet on whether teaching do or >>= is the preferred first option? (I know which side I am on)
19:22:17 <ddarius> dibblego: It depends on the didactic approach.
19:22:19 <skew> dibblego: how about the hardcore category theory?
19:22:29 <skew> dibblego: can I say Kleisli category?
19:22:32 <soduko> but what buggered me is teh do notation worked, but i could not bind to a funciton it kept giving me an error about the argument not being  IO b
19:22:48 <newsham> dibble: we'll settle that right after we settle israeli/palestinian, catholic/protestant and emacs/vi
19:22:52 <soduko> dibblego: i prefer >>=
19:22:56 <soduko> do is sugar.
19:23:09 <soduko> vi :)
19:23:46 <glguy> you were thinking of windows/linux/emacs
19:23:54 <skew> what about binding to a function?
19:24:23 <soduko> readFile fn >>= func
19:24:41 <skew> oh, that was probably complaining about the result
19:24:45 <glguy> I typicaly don't find cases to use >>= over =<<
19:24:53 <newsham> can we change it to do,lift,bind ?
19:25:06 <dibblego> I still don't see why =<< is so much better than >>=
19:25:17 <glguy> it is application
19:25:22 <glguy> you write : f x
19:25:27 <glguy> and you write: g =<< m
19:25:28 <soduko> teh signature of func is (a -> m b)
19:25:31 <dibblego> ?src =<<
19:25:31 <lambdabot> f =<< x = x >>= f
19:25:41 <skew> is m something other than IO?
19:25:50 <dibblego> skew, very often, yes
19:26:28 <ddarius> In some categorical literature (more CS literature using CT), it is common to use f^* to turn f : A -> M B into f^* : M A -> M B which corresponds to (f =<<)
19:26:42 <ddarius> :t (=<<)
19:26:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:26:53 <newsham> (return (3 + y) <- y/) =<< readInt   readInt >>= (\y -> return (3 + y))
19:27:15 <glguy> :t ap
19:27:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:27:20 <glguy> :t (=<<)
19:27:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:27:26 <soduko> so it has to be some thing like func::string->IO String
19:27:46 <skew> soduko: if you want to connect it to readfile
19:28:01 <skew> the moands have to match up across a bind
19:28:09 <soduko> yeah
19:28:39 <newsham> print =<< 4 <+ (read_ (getArgs !!> 0) *^ read_ (getArgs !!> 1))
19:29:10 <newsham> print 4 + read (getArgs!!0) * read (getArgs!!1)
19:29:11 <SamB_XP> yeah, you can't say "[1] >>= print" ;-P
19:31:28 <newsham> http://www.thenewsh.com/%7Enewsham/Hats.pdf
19:31:34 <soduko> but XML in haskell is not simple.  there is HaXML and a few others, but not easy to get to
19:31:41 <newsham> =<< goes in "the right direction"
19:32:00 <ddarius> "Not easy to get to"?
19:32:08 <newsham> alexj's talk said XML works reallywell with haskell and SYB.
19:32:11 <soduko> difficult ot use
19:32:13 <soduko> for me
19:32:23 <soduko> SYB?
19:32:24 <newsham> might wanna look at happs libs?
19:32:29 <newsham> scrap-your-boilerplate
19:33:20 <Saizan> happs uses HaXml and adds a class for Xml serialization
19:33:35 <glguy> hxt and haxml are more like application frameworks than xml libraries
19:34:29 <glguy> we use something much lighter at work
19:34:36 <Saizan> and neither use bytestring!
19:34:39 <soduko> is it sharable?
19:34:51 <glguy> "soon"
19:35:05 <glguy> someone's been trying to push it out the door
19:35:09 <glguy> I think its a matter of doing it
19:35:27 <skew> soduko: if you're just generating simple XML you may not even need a library at all
19:35:42 <skew> glguy: where is work that you write Haskell?
19:36:04 <glguy> galois
19:36:08 <skew> ah
19:36:08 <goalieca> skew, but it helps if you want to read xml
19:36:12 <soduko> i made my own set of small functions. take  a string and return a wrapped string etc.
19:40:09 * glguy wonders why visiting gmail makes programming.reddit crash firefox
19:43:37 <goalieca> javascript
19:43:43 <goalieca> the new gmail abuses javascript
19:52:04 <hpaste>  zeeeee pasted "how do i make a global variable based on an unsafePerformIO (readIORef ...) to be evaluated on an up" at http://hpaste.org/4015
19:52:29 <nelhage_> Are hoogle's broken links a known issue?
19:53:30 <nelhage> (into ghc's library documentation)
19:55:31 <sjanssen> yes
19:56:00 <sjanssen> they broke with GHC's 6.8.1 release, ndm hasn't fixed them yet
19:56:09 <zeeeee> urgh, my question was: how do i make a global variable based on an unsafePerformIO (readIORef ...) to be evaluated on an updated IORef?
19:56:59 <zeeeee> (this ties into that problem i brought up earlier)
19:59:51 <shachaf> The GHC manual also has broken links.
20:00:09 <shachaf> Do people know about those (I'm guessing they do)?
20:01:00 <sjanssen> zeeeee: you can't
20:02:19 <zeeeee> oh, man...
20:02:49 <shachaf> (I mean user's guide, of course.)
20:03:11 <Cale> shachaf: I don't know. You might submit a trac ticket if there isn't one.
20:03:13 <sjanssen> plus, you're doing something very sketchy -- you should not use unsafePerformIO to break referential transparency
20:03:24 <zeeeee> sjanssen, i thought we had agreed earlier that this was viable
20:03:46 <sjanssen> zeeeee: I didn't realize that you would change the variables later on
20:03:59 <zeeeee> sjanssen, oh, no
20:04:03 <zeeeee> i'm not changing them later on
20:04:11 <Cale> zeeeee: Using unsafePerformIO should really only be done if you understand GHC rather well.
20:04:11 <zeeeee> i want to initialize them once
20:04:30 <zeeeee> Cale, so unsafePerformIO is implementation-dependent?
20:04:34 <Cale> Yes.
20:05:00 <shachaf> zeeeee: unsafePerformIO doesn't exist. :-)
20:05:02 <zeeeee> this was to avoid either adding an arg to every function, or making everything into a Reader
20:05:02 <sjanssen> and difficult to understand in the presence of lazy evaluation
20:05:08 <Cale> Interactions with optimisations can be confusing.
20:05:18 <Cale> zeeeee: I suggest adding an arg.
20:05:41 <Cale> zeeeee: after all, if your functions actually depend on that value, it should be a parameter.
20:06:04 <zeeeee> Cale, the functions depend on a lot of other values, eg map
20:06:25 <Cale> Is the value a compile-time constant?
20:06:44 <Cale> (if so, then why do you need to do IO to get it?)
20:07:09 <skew> (or, do the IO in a macro)
20:07:13 <zeeeee> Cale, that's the problem - it's not, which is why i had this whole dilemma about adding an arg to everything, or moving everything into main's lex scope, or Reader, ... or unsafePerformIO
20:07:32 <zeeeee> skew, huh?
20:07:43 <Cale> I think usually adding an arg to the things which need the value is usually not so bad.
20:08:25 <skew> Template Haskell and splice it in, if the value is known when you compile
20:08:36 <zeeeee> skew, nope, it's argv
20:09:10 <skew> why shouldn't you be passing that around?
20:09:14 <zeeeee> i thought i'd seen this trick done in yi before
20:09:33 <zeeeee> skew, because that's a lot of passing around
20:09:33 <sjanssen> zeeeee: you shouldn't use an IORef here
20:10:03 <shachaf> Hmm, it looks like there is a ticket, never mind.
20:10:10 <zeeeee> the variables were treated pretty much as constants; the program grew; recently i decided to parameterize the constants
20:10:20 <sjanssen> zeeeee: if you *insist* on doing this, parse the arguments in the binding for the variable
20:10:32 <Cale> Right, which is exactly the sort of refactoring which using an IORef is bad for.
20:11:41 <Cale> If at some point your global constant IORef is not supposed to be a constant, then you'll end up turning it into a function parameter anyway.
20:11:57 <Cale> So it's usually better to get that out of the way sooner rather than later.
20:12:18 <zeeeee> ok
20:15:37 <ddarius> For all you people who've not been doing Haskell all that long, consider what C code would look like if they used the Haskell convention of labelling "unsafe" functions with "unsafe".
20:17:04 <shapr> hah
20:17:15 <zeeeee> ddarius, nothing would be labeled... everything is already in IO
20:17:35 <skew> oh, that's not the only sort of unsafety
20:17:36 <ddarius> zeeeee: Not every IO function is labeled with unsafe in Haskell.
20:18:15 * ddarius misunderstood what zeeeee was getting at, luckily skew did.
20:18:53 <skew> only unsafe{Perform,Interleave,Inline}IO get the label because they break referential trasnparency
20:19:12 <skew> think unsafeCoerce#, unsafeIndex, unsafe.
20:19:12 <sjanssen> and worse
20:19:14 <ddarius> skew: You can break type safety with unsafePerformIO/inlinePerformIO
20:19:45 <ddarius> It's hard to get worse than unsafeCoerce#
20:20:17 <skew> well, they don't break type safety unless you try
20:20:45 <ddarius> If by try you mean accidentally have a polymorphic "global" variable, no, not all.
20:20:51 <ddarius> +at
20:20:54 <Saizan> ?type inlinePerformIO
20:20:57 <lambdabot> Not in scope: `inlinePerformIO'
20:21:12 <skew> and things like unsafeCoerce# don't break referential transparency except as a side effect of breaking memory safety unless you try
20:21:30 <hpaste>  thetallguy pasted "Doc beside" at http://hpaste.org/4016
20:22:44 <thetallguy> Anyone know the answer to the question in that paste?
20:23:14 <skew> anyway, the punchline is you'd have to all the operator unsafe->, beacuse of unchecked nulls
20:24:37 <Cale> Oh, that reminds me, I should make up a Cabal package for Wadler's prettyprinting combinators.
20:24:53 <skew> has anyone by any chance tried combining CIL and Caduceus for verifying messy C?
20:25:12 <thetallguy> Cale: do they produce   a c\n b d   in the above example?
20:25:59 <Cale> I'm pretty sure they don't have a columnar mode, if that's what you're asking.
20:26:10 <thetallguy> okay.
20:26:38 <thetallguy> I wrote a table operator for HughesPJ, so I'll publish that to see if anyone is interested.
20:28:51 <user317> anyone know what the cabal: dist/Conftest.c: openFile: does not exist (No such file or directory) means
20:30:36 <zeeeee> what are haskell's main bottlenecks in benchmark game-type workloads? (this question was asked at least once before on the mailing list, but a while back)
20:31:12 <user317> zeeeee, everything compared to C is a bottle neck :)
20:32:54 <skew> I don't remeber anyone having serious game-type benchmark programs
20:33:39 <skew> glxgears ran frame for frame with the C, once you code up the vertex arrays and so on. Maybe somebody profiled Frag?
20:33:42 <zeeeee> skew, er, that should be "benchmark game"-type workloads (formerly language shootout)
20:34:12 <skew> Ah, not sure what those are after 6.8.1
20:34:35 <skew> used to be low level code generation, especially loop optimizations and not stupidly spilling registers
20:34:55 <zeeeee> right, apparently 6.8 brought some efficient code gen
20:37:11 <skew> will vectorization even be useful on any of those problems?
20:42:38 <Philippa> skew: Yampa performs pretty badly in Frag
20:47:50 <goalieca> bloody hell. shootout loss
20:48:13 <Korollary> yeahh
20:48:37 <dons> goalieca?
20:48:46 <Korollary> hockey
20:48:49 <dons> ah
20:49:03 <dons> crazy kids
20:49:20 * Korollary hipchecks dons
20:49:37 * goalieca joins in Hansen Bros style
20:49:56 * dons tosses down a sandshoe crusher at Korollary 
20:50:05 <dons> and hooks goalieca for six
20:50:33 <Saizan> user317: that yyou should have Cabal >= 1.3 to compile cabal-install
20:50:48 <goalieca> dons hooking? seriously?
20:50:52 * goalieca drops gloves
20:52:04 <dons> i grew up watching viv richards
20:52:38 <goalieca> heh. i had to look that up
20:52:42 <dons> aka the master blaster
20:52:44 <user317> Saizan, 1.3? or 1.2?
20:52:52 <Saizan> 1.3
20:52:54 * goalieca should have gone to whl. university was overrated :P
20:53:06 * goalieca knows not what this cricket it
20:53:21 <TSC> It's a game for gentlemen
20:53:51 <goalieca> well when i was in australia i recall them having a single match on tv all day
20:54:00 <goalieca> and all week
20:54:11 <dons> its great! :)
20:55:19 <Cale> hmm
20:55:40 <goalieca> so exciting they could interview a fielder during play
20:55:48 <Cale> I wonder whether I'm actually allowed to BSD license this code, given that it's basically taken verbatim from this paper.
20:56:11 <goalieca> Cale, what licence was the paper published under
20:56:13 <skew> what does it do?
20:56:26 <dons> Cale: is that wadler's ppr?
20:56:29 <skew> you could get somebody else to come up with some code, and have them publish it
20:56:39 <dons> is it different to leijan's one (or is that an extn of wadler's?)
20:56:51 <newsham> cale: describe it to someone, let them write it in perl, then write an implementation bsaed on that :)
20:56:53 <dons> wadler won't care though
20:56:56 <Cale> dons: yes
20:57:06 <dons> Cale: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/wl-pprint-1.0
20:57:07 <lambdabot> http://tinyurl.com/2lrovs
20:57:15 <dons> "This is a pretty printing library based on Wadler's paper A Prettier Printer."
20:57:25 <Cale> oh, I didn't see that :)
20:57:53 <Cale> That's probably the same.
20:58:05 <glguy> dons: remember that hotel employee I called "non-native"?
20:58:12 <dons> oh, yes.
20:58:26 <glguy> he sent my gameboy to Beaverton, OB
20:58:31 <glguy> wtf state is "OB"
20:58:33 <dons> OB? is that a state?
20:58:37 <dons> heh
20:58:38 <Cale> ahaha
20:58:41 <glguy> and he had the wrong zip code
20:58:48 <dons> oh, who needs those
20:58:50 <glguy> i don't really know how it got to me
20:58:58 <glguy> (didn't have my name on it either :) )
20:59:04 <dons> by the power of the postal service!
20:59:08 <Cale> What did it actually have right?
20:59:17 <glguy> the street address and city
20:59:30 <dons> they use the stasi's database software
20:59:36 <glguy> ?
20:59:58 <Cale> It might be that you're in the only city of that name with that particular street address.
21:00:12 <dons> the east german secret police, who know everything about everyone
21:01:28 <glguy> 1337 Haskell Way
21:01:37 <newsham> http://www.imdb.com/title/tt0405094/
21:01:37 <lambdabot> Title: Leben der Anderen, Das (2006)
21:02:04 <newsham> I hear that the post office is known to deliver some pretty impressively misaddressed mail
21:02:15 <newsham> ie. people who put puzzles on their envelope instead of the address
21:02:25 <newsham> some usps guy cracks the puzzle and delivers it
21:02:34 <Cale> hehe
21:02:37 <skew> what else are you going to do at the post office?
21:02:40 <newsham> guess you get that kinda free time when working for the gubmint
21:02:42 <glguy> I saw a story about a guy in England that draw a map
21:02:51 <glguy> and put an X where the guy was thought to have lived
21:02:53 <glguy> and his name
21:02:57 <glguy> drew*
21:03:17 <newsham> i think i heard about that one on tv
21:03:24 <dons> glguy: yes, that's a great movie
21:03:32 <dons> glguy: its showing downtown still, actually
21:03:32 <glguy> oh, that's a movie?
21:03:44 <Cale> I heard about a person in England who only put a vague description of the guy, and the name of the military brigade he used to belong to, and it was correctly delivered :)
21:04:03 <glguy> I need friends in england with interesting pasts to send mail to
21:04:05 <dons> glguy: oh, sorry, http://www.imdb.com/title/tt0405094/
21:04:06 <lambdabot> Title: Leben der Anderen, Das (2006)
21:04:07 <newsham> Beaverton, OB == Beaverton, OR?
21:04:16 <glguy> newsham: yeah
21:04:20 <newsham> excellent film.
21:04:26 <glguy> newsham: I can understand how they made the connection
21:04:28 <dibblego> my Dad, whose nickname is Kermit, had a letter delivered when he lived in a small town addressed as 'Kermit'
21:04:36 <glguy> I just thought it was an interesting choice of states
21:05:24 <newsham> sounds like it could be part of canadia, gl.
21:05:43 <skew> It will be soon ...
21:05:59 <glguy> canada isn't going to buy its freedom no matter what the exchange rate
21:08:33 <nanothief> hey all, I'm having a problem with case expressions in one of my haskell functions, pattern matching overlapping
21:08:45 <nanothief> http://hpaste.org/4017 <-- code and error message
21:08:49 <allbery_b> let the dollar crash a bit more and it can buy the US.  except it'd then have to sell at a loss to china or something
21:09:02 <dons> if it gets high enough, .ca and .au can buy out california
21:09:15 <dons> we can have vacations there, and get more movies made about cricket
21:09:38 <allbery_b> nanothief: beginChar doesn't do a comparison, it creates a new local variable and assigns the char to it
21:09:39 <glguy> What's cricket?
21:09:58 <dons> ?slap glguy
21:09:58 * lambdabot throws some pointy lambdas at glguy
21:10:00 <newsham> glg: they cant buy nearly as much this week as last week, anyway
21:10:01 <allbery_b> so it always succeeds and the _ -> will never match
21:10:06 <dons> i'm going to bring my cricket bat in tomorrow
21:10:07 <newsham> down to below $1.02 for a loon
21:10:12 <dons> newsham: wow.
21:10:13 <glguy> dons: I won't be in
21:10:19 <dons> is no one coming in tomorrow?
21:10:22 <nanothief> allbery_b: how do i compare against beginChar then?
21:10:26 <dons> what is this weird vacation?!?
21:10:30 <dmwit> dons: You are... =P
21:10:32 <allbery_b> use an if comparison
21:10:33 <newsham> dons: first thanksgiving?
21:10:44 <glguy> dons: you can give thanks for the day off
21:10:48 <dufflebunk> So there's some documentation: http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/System-IO.html  and a line in it says, "The offset i is given in terms of 8-bit bytes."
21:10:49 <lambdabot> http://tinyurl.com/2uqgyq
21:10:51 <allbery_b> x == y is not a partern match; case is not appropriate
21:10:58 <dufflebunk> Aren't all bytes 8 bits?
21:11:09 <dmwit> nope
21:11:19 * dons just makes types check all day
21:11:19 <dmwit> Some bytes are 9 bits, and some are 6.
21:11:26 <dmwit> It really depends on the architecture.
21:11:36 <allbery_b> I would say it effectively is, these days; I think most of the weird archs have been retired by now
21:11:41 <dmwit> yeah
21:12:02 <allbery_b> really, does anyone have a working PDP10 in their closet?  (and can afford the electricity to run it?!)
21:12:23 <dons> the openbsd guys have a couple of vaxen that are pretty big and hot
21:12:29 <newsham> http://neil.franklin.ch/Projects/PDP-10/
21:12:31 <lambdabot> Title: PDP-10 Clone Microprocessor in an FPGA
21:12:38 <ddarius> allbery_b: I think someone has a PDP-1
21:12:48 <nanothief> allbery_b: ok thanks
21:13:35 <newsham> i always thought it would be fun to build a pdp8 clone
21:13:37 <dmwit> I think the point is that someone who doesn't already know that some bytes are not 8 bits doesn't really have to worry about it anyway.
21:13:42 <newsham> simple instruction set except for the IO stuff
21:14:46 <dons> "HP and its authorized service partners continues to support VAX customers worldwide" -- wow
21:14:56 <nanothief> allbery_b: i just tried replacing beginChar with '<' and it worked. So I'm still a bit confused to why this isn't working (I'm fairly new to haskell)
21:15:20 <allbery_b> if it's a constant, it's a pattern.  but the rules of pattern matches don't treat variables that way
21:15:21 <ddarius> case is a binding construct.  That beginChar is shadowing the outer one.
21:15:21 <dons> "VAX systems still available"
21:15:37 <dufflebunk> dons: isn't that like saying they support Enigma customers woldwide?
21:15:41 <allbery_b> a variable does not substitute an existing value; it introduces a new binding
21:15:50 <allbery_b> which you can then use in the code after the ->
21:16:06 <dons> "HP will continue to offer a range of VAX systems and options. Your investment is safe, and you can continue to run your business until you are ready to migrate to another platform"
21:16:07 <newsham> If you havent switched to Charon, probably time to do so :)
21:16:14 <newsham> http://www.softresint.com/charon-vax/
21:16:14 <allbery_b> it's the trivial case of matching a constructor and catching the value in a variable
21:16:15 <lambdabot> Title: SRI - VAX Virtualization
21:16:46 <dons> that's cool
21:16:51 <nanothief> allbery_b: ok so the beginChar in the case doesn't look at the beginChar defined previously, but creates a new variable
21:17:06 <allbery_b> that is, case foo of bar -> ... is treated the same as case foo of (Bar bar) -> ... --- in bith cases bar is treted as a new variable and gets the value in that "slot"
21:17:10 <newsham> there's also free vax emulators (notably simh) but they're not officially supported platforms.
21:17:49 <ddarius> nanothief: yes
21:18:00 <nanothief> allbery_b: ok thanks (again) :)
21:18:05 <newsham> who wouldnt want vmx running on their wince pocket computer
21:18:08 <newsham> vms
21:18:22 <allbery_b> yep.  so you need to use something like if foo == bar if you want the existing bar
21:19:33 <allbery_b> newsham:  remember, vms == (wnt) ++ (and all current windows is one way or another based on NT...)
21:19:54 <newsham> for some definition of "based on"
21:20:23 <allbery_b> hence "one way or another"
21:20:39 <newsham> ie. roughly in the same sense that mach was "based on" unix.
21:22:00 <QtPlatypus> Doese NT have the versioned file system concept that vms had?
21:22:36 * wifs vaguely recalls some journaling features in ntfs
21:22:49 <newsham> qt: no.
21:23:15 <newsham> ntfs does journaling.  it also has alternate streams (you could use them to write diff versions of the same files if you wanted to)
21:50:25 <shapr> newsham: Or hide stuff
21:50:36 <phlpp> hi
21:58:16 <hpaste>  glguy pasted "knucleotide in factor" at http://hpaste.org/4018
21:58:58 <user317> does anyone know what forum software nabble uses?
21:59:05 <zeeeee> when i try: fmap fileSize (getFileStatus "/") `catch` return 0
21:59:25 <zeeeee> i get: No instance for (Num (IO FileOffset))
21:59:37 <zeeeee> i think it's something really obvious
21:59:44 <zeeeee> but i've been staring at this too long
21:59:44 <glguy> :t fileSize
21:59:47 <lambdabot> Not in scope: `fileSize'
21:59:59 <zeeeee> FileStatus -> FileOffset, iirc
22:00:05 <glguy> in IO
22:00:13 <glguy> FileOffset isn't a "Num"
22:00:16 <glguy> so you can't "return 0"
22:00:22 <zeeeee> glguy, then what to do?
22:01:21 <glguy> ?index fileSize
22:01:22 <lambdabot> System.Posix.Files, System.Posix
22:01:25 <zeeeee> (and no, it's not in IO)
22:02:01 <zeeeee> i tried fromIntegral 0
22:02:24 <Saizan> uhm, const (return 0) ?
22:02:35 <zeeeee> Saizan, you see!
22:02:40 <zeeeee> i knew it was really obvious
22:02:43 <glguy> bah, I typed tha tout at first
22:02:57 <glguy> (but second guess myself at the Num instance :(
22:03:02 <Saizan> ?type catch
22:03:03 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
22:03:25 <thetallguy> ?index getWidth
22:03:25 <lambdabot> bzzt
22:07:18 <dons> glguy: so are you going to submit a meteor-contest entry?
22:07:25 <dons> in haskell :)
22:07:39 <glguy> lol, you and your qualifiers
22:08:01 <dons> you don't get paid to write in Factor ;)
22:08:09 <glguy> that's partially true ;)
22:08:10 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=meteor&lang=all
22:08:12 <lambdabot> Title: meteor-contest benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer La ..., http://tinyurl.com/38xbh9
22:08:16 <dons> fix that ^^
22:08:30 <dons> and i'll buy you lunch
22:09:10 <glguy> dons: did you see my hpaste ?
22:09:11 <Korollary> does ghc have a -Oboughtyoulunch ?
22:09:36 <goalieca> dons how long does it take for code changes to make its way into the contest
22:09:37 <dons> i saw a pretty knucleotide entry
22:09:39 <glguy> there are restaurants that accept Haskell code as payment around Galois
22:09:49 <glguy> dons: yeah, that one
22:11:48 <dons> how's it perform?
22:12:09 <dons> does factor have a custom slava optimiser?
22:12:17 <glguy> dons: I haven't run it on anything larger than the sample input
22:12:36 <glguy> and I've chosen readability over performance when presented with a choice
22:12:52 <glguy> I was mostly interested in getting my head back into Factor than winning the benchmark
22:12:59 <glguy> There is an "optimizing compiler"
22:13:04 <glguy> and a "non-optimizing one"
22:13:06 <glguy> for JIT
22:13:45 <glguy> on my computer, on the sample input set: 273 ms run / 8 ms GC time
22:14:46 <sjanssen> glguy: how do you like factor?
22:15:23 <glguy> I think its pretty awesome
22:15:28 <sjanssen> why?
22:15:51 <glguy> I like the whole forth meets lisp idea of it
22:15:57 <glguy> the repl is pretty nice
22:16:11 <glguy> lots of libraries to play with
22:17:01 <glguy> enables interesting implementations like local variables as a library
22:17:41 <ddarius> sjanssen: I installed factor but haven't really played with it, but from looking at it I think it takes the best from Forth and Joy fixing many of my, at least, issues with Forth.
22:17:51 <ddarius> (Namely, it's way of handling control structures.)
22:17:55 <glguy> to me it is lisp done right
22:18:34 <ddarius> I don't really relate it to lisp, but I haven't played with it much.
22:20:23 <zeeeee> is there any way to convert between ProcessID and ProcessHandle?
22:20:29 <glguy> it supports the same blurred line between programs and data
22:21:05 <ddarius> glguy: So does Forth.
22:21:16 <dons> zeeeee: yes. hmm
22:21:37 <glguy> ddarius: I don't know enough about Forth to relate it well then :)
22:21:38 <dons> type ProcessID      = CPid
22:22:54 <dons> data ProcessHandle__ = OpenHandle PHANDLE | ClosedHandle ExitCode
22:22:58 <dons> type PHANDLE = CPid
22:23:23 <zeeeee> hm
22:23:35 <dons> hmm
22:23:49 <dons> Utils.hs:pid2phdl :: ProcessID -> ProcessHandle
22:23:50 <dons> Utils.hs:pid2phdl pid = unsafePerformIO $ mkProcessHandle pid
22:24:15 <dons> (in hmp3)
22:24:36 <dons> looks like that's from -package process System.Process.Internals
22:25:16 <zeeeee> dons, -package?
22:25:36 <dons> in the process package
22:25:40 <dons> you can find mkProcessHandle
22:25:46 <zeeeee> oh
22:26:17 <dons> which looks like the way to go
22:27:30 <glguy> dons: Would you say that Haskell quenches all of your language curiosity then?
22:27:39 <glguy> no room left to explore?
22:28:03 <ddarius> That's a bizarre question.
22:28:05 <zeeeee> dons, it's strange how the process package intersects with the std lib, but also has stuff that's not in the std lib
22:28:16 <zeeeee> (process has System.Process)
22:28:26 <zeeeee> and Cmd
22:28:34 <zeeeee> but Internals is not in stdlib
22:28:36 <glguy> ddarius: not *that* bizarre, he's been giving me trouble about it lately :-p
22:28:44 <sjanssen> zeeeee: what version of GHC are you using?
22:28:57 <zeeeee> sjanssen, 6.6, but i'm looking at the latest docs online
22:29:12 <dons> glguy: oh, no :) epigram, coq, ftw!
22:29:38 <dons> glguy: i just know you have lots of energy, so hope to farm off some jobs to you :)
22:29:42 <sjanssen> zeeeee: the process package is new in 6.8, it's all modules migrated from the old base package
22:29:45 <dons> like keeping the shootout going :)
22:30:38 <zeeeee> sjanssen, so the latest docs are out of sync?
22:30:40 <dons> glguy: the other thing you can do is extend haskell. :)
22:30:48 <dons> making it faster is a good exercise in language exploration
22:30:57 <dons> + you get to write papers about the result
22:30:59 <sjanssen> zeeeee: no, why do you ask?
22:31:19 <glguy> dons: paper production doesn't really interest me
22:31:20 <zeeeee> sjanssen, System.Process.Internals is not listed
22:31:35 <ddarius> zeeeee: Probably for a reason...
22:31:47 <sjanssen> zeeeee: ohh, that.  Since it's an internal API, it isn't listed in the documentation
22:31:52 <dons> glguy: well, if you're ever bored, i've a big stack of exploratory todos :)
22:31:57 * wli is interested in Mercury, Cayenne, and Curry, too.
22:32:12 <zeeeee> others are, though, eg system.posix.process.internals
22:32:38 * araujo packs wli into an IO monad to avoid him going somewhere else
22:33:29 * wli also does all his day-to-day programming in C.
22:49:28 <firefly> dons, we talked yesterday (my yesterday) about ghc and the backend.
22:49:36 <firefly> Do you have more info I can look at?
22:50:07 <dons> about the code generator?
22:50:09 <firefly> I don't see anything yet about a better backend in the darcs changelog for ghc -- is it in "semiprivate" repos?
22:50:10 <firefly> yeah.
22:50:23 <dons> yes, let me look up some things..
22:50:36 <firefly> Or is the plan just to make a better Cmm backend and nothing much has actually been done yet?
22:50:57 <dons> no, there's been work on Cmm and on a new register allocator
22:51:28 <firefly> (darcs took a completely inordinate amount of time to get the whole ghc repository -- I think it downloaded about 5 patches a second :( )
22:51:34 * firefly uses Mercurial now
22:51:47 <dons> ok, so ben's register allocator work, http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING072?action=download&upname=lippmeier072.txt
22:51:50 <lambdabot> http://tinyurl.com/38rzrz
22:52:09 <dons> and then the rest should be on the ghc wiki
22:52:14 <dons> that link actually isn't what i wanted
22:52:19 <dons> its just an overview of his talk
22:53:14 <dons> firefly: so i'd go to cvs-ghc@ and to  http://hackage.haskell.org/trac/ghc/wiki/Commentary
22:53:15 <lambdabot> Title: Commentary - GHC - Trac
22:53:53 <dons> and look at the tickets for working on the backend
22:54:44 <firefly> ok, then I /have/ actually looked at it all :)
22:55:00 <firefly> It just seems more vague from the outside :/
22:55:42 <dons> there should be a fair bit of documentation, but maybe a bit dispersed.
22:55:44 <firefly> cvs-ghc has lots of commit mails but very little discussion (compared to cairo, linux, X, xcb mailing lists)
22:55:59 <dons> right, its taking place at microsoft HQ, in this case
22:56:03 <dons> and via phone calls and irc
22:56:06 <dons> you on #ghc ?
22:56:11 <firefly> yes
22:56:22 <firefly> not much happening there.
22:56:39 <dons> to start work on things, pick tickets off the ghc bug list to do with backend stuff, and see what you can do
22:56:46 <dons> and discuss on cvs-ghc@
22:56:48 <firefly> ok.
22:57:10 <firefly> The backend is really letting ghc down :/
22:57:12 <dons> it might be fun to get hold of the clean compiler too, and present comparative asm for similar code
22:57:20 <dons> it would definitely help motivate backend work
22:57:21 <firefly> or just mlton ;)
22:57:29 <dons> yeah, mlton is good
22:58:34 <firefly> A project I have been slowly working on for years is a text-mode "full screen" debugger (really a Turbo Debugger clone) so I have looked a bit at DWARF.
22:58:57 <firefly> Wouldn't it be cool to have ghc play well with DWARF symbols?
22:59:34 <dons> for debugging?
22:59:36 <firefly> If the C++ Concepts extension really is like type classes (as Philip Wadler states in a talk I watched yesterday on google video) then they are going to need some of the same extensions.
22:59:41 <firefly> Yes.  And profiling.
22:59:54 <dons> yeah, concepts are much like type classes
23:00:09 <firefly> My experience a decade ago was that Turbo Debugger often was more productive for optimization work than Turbo Profiler.
23:00:22 <dons> mm. yes.
23:00:30 <dons> there's some interesting interplay there
23:00:39 <dons> the profiler is a key tool with ghc
23:00:48 <firefly> or am I the only one who's interested in DWARF?
23:00:50 <dons> but the debugger is quite new, and not used anywhere near as much
23:01:08 <firefly> debuggers and profilers are generally a problem on Linux :(
23:01:58 <sjanssen> firefly: I think C and Haskell need very different debuggers
23:02:15 <firefly> I am not so sure.
23:02:45 <goalieca> debugging c is mostly following state
23:02:52 <goalieca> haskell works with thunks.
23:03:20 <sjanssen> yes, laziness is a big problem
23:04:20 <dons> SingHaskell! http://taichi.ddns.comp.nus.edu.sg/taichiwiki/SingHaskell2007
23:04:21 <lambdabot> Title: SingHaskell2007 - TaichiWiki
23:11:32 <dmwit> Oh, false hopes!
23:11:56 <dmwit> SingHaskell has no musical association at all.
23:17:12 <goalieca> hmm. sounds like a perfect event for karaoke
23:18:02 <firefly> This is probably the closest commit http://www.haskell.org/pipermail/cvs-ghc/2007-August/037492.html
23:18:03 <lambdabot> Title: patch applied (ghc): Add graph coloring register allocator.
23:18:36 <wli> Graph coloring doesn't perform all that well when you're super-register-starved.
23:20:04 <firefly> there are some other register allocation patches in the public ghc repo from Lippmeier.
23:20:12 * allbery_b seems to recall gcc adding graph coloring several years back and becoming spectacularly suckful on x86
23:20:48 <firefly> come on, you've got six register you can play with almost freely :)
23:21:09 <firefly> (ESP is used for the real stack, EBP for ghc's data stack)
23:21:33 <wli> firefly: Not at all. The way registers get nailed on x86 cuts it down to 3 usable registers or less.
23:22:07 <firefly>  /almost/ freely.  There are a few instructions that are more constrained -- and addressing modes that are more constrained.
23:22:31 <firefly> most is rather free two-address code.
23:22:39 <wli> firefly: Now try taking them into account in any meaningful way.
23:24:00 <srihari> er, would someone know why ghci (6.8.1, windows) gives me a parse error for ":t GHC.Prim.unsafeCoerce#"?
23:24:10 <firefly> pretend you can use them freely, generate extra moves as necessary, remove the moves afterwards, seekretly use the registers in an order that tends to make more of the register moves superfluous so they can be removed.
23:24:10 <glguy> no -fglasgow-exts ?
23:24:40 <firefly> that seems to be pretty much the standard approach and works ok.
23:24:43 <srihari> glguy: ah, okay - so how do I add it to the Extensions required for cabal?
23:25:51 <srihari> or do I just put it in Ghc-Options? (I'm trying to build EdisonCore using 6.8.1, which complains a bit)
23:26:16 <glguy> I'd probably put it in the ghc-options
23:26:21 <glguy> I don't know what extension that uses
23:26:29 <srihari> yup, that works, thanks much!
23:26:52 <quicksilver> MagicHash, I think
23:29:10 <srihari> quicksilver: thanks! MagicHash it is, and now I've got to find out the other extensions required to (-glasgow-exts hides that rather nicely) :)
23:42:57 <osfameron> morning all
23:43:36 <osfameron> how do we normally represent a state variable (not necessarily State monad)?
23:43:45 <osfameron> coming from Perl I'd think a hash (e.g. Data.Map)
23:43:58 <dons> a state variable?
23:44:07 <osfameron> but Maps are homogenous, so I'm thinking I'd define a new type to hold all the info
23:44:16 <osfameron> hmmm, like a "Game State" container
23:44:26 <dons> a record type?
23:44:36 <osfameron> yes, that sort of thing
23:44:44 <dons> data GameState = GameState { players :: Int  , board :: IntMap }
23:44:44 <osfameron> where each record might be of a different type
23:44:47 <firefly> a record or a tuple.  Depends on what you need.
23:44:59 <dons> then your app runs in StateT IO a
23:45:19 <dons> or ReaderT GameReadOnlyValues (StateT GameState IO) a
23:45:28 <dons> the type of interactive, stateful programs
23:46:02 <osfameron> I'm not familiar with the  Instance { record ::Type, record :: Type } syntax  (that is, I've seen it, but I don't know how it works... is that a GADT?)
23:46:53 <firefly> just type annotations.
23:46:56 <dons> no no, just a usual haskell data type
23:47:00 <dons> but with labels for fields
23:47:05 <dons> data T = T A B C
23:47:16 <firefly> instead of annotating the whole thing, the fields are annotated individually ("locally") which reads better.
23:47:21 <dons> data T =  T { field1 :: A, field2 :: B , field3  :: C }
23:47:44 <osfameron> ah, ok.  That looks nicer for some types
23:47:46 <dons> the field names are also accessors for those fields
23:47:52 <dons> so that you caan write:   field2 x
23:47:55 <dons> which extracts field2 from x
23:48:02 <dons> x.field2 , essentially
23:48:06 <osfameron> so you don't pattern match on record types in the same way ?
23:48:17 <dons> you can, yep
23:48:26 <dons> f (T { x = field2 }) = x
23:48:35 <dons> meaning, you can even leave off fields you don't care about
23:48:38 <wli> f (T {  a = field1, b = field2, ... }) = ...
23:48:41 <osfameron> ah, cute
23:48:43 <dons> f (T _ x _) = ..
23:48:50 <dons> is the other option, but not as flexible
23:49:09 <osfameron> with the items in the same order you declared them?
23:49:12 <dons> since if you add a new field, you have to update your pattern
23:49:13 <dons> yep
23:49:26 <dons> just positional matching on the structs fields
23:49:33 <osfameron> and how do you modify a field?  (I mean, how do you create a clone, just updating one field, of course)
23:49:46 <dons> f x = x { field2 = 7 }
23:50:00 <dons> so that would set field2 to 7, returning a copy
23:50:14 <dons> hmm. where's a good example program
23:50:17 <osfameron> cute syntax
23:50:48 <firefly> osfameron: it makes for very nice code when you use GTK+/Gnome from Haskell (gtk2hs)
23:51:18 <firefly> very clean, both compared to C and to Perl GTK+ code :)
23:51:20 <osfameron> firefly:  cool!  I-ve never played with that
23:51:42 <dons> probably the main complaint about record syntax is that the labels aren't first class values
23:51:50 <dons> you can't pass a label into a generic modify function
23:52:03 <dons> and that field accessors have the same scope as the type
23:52:10 <osfameron> ah!  I saw a reference to first-class labels on the haskell-prime wiki, and didn't understand it
23:52:11 <firefly> the GTK+/Gnome bindings use records extensively to give "options" to various methods.
23:52:26 <dons> yeah, its great for updatable types
23:52:27 <dmwit> Is this because the label would have to have two different types, one for updating and one for selecting?
23:52:31 <dons> e.g. xmonad's config file
23:52:40 <dons> is populated with defaults, and users selectively update those htey care about
23:52:53 <dons> main = dzen $ \conf -> xmonad $ conf { borderWidth        = 2 , terminal           = "term" , normalBorderColor  = "#cccccc" , focusedBorderColor = "#cd8b00" }
23:53:02 <dons> jsut overrides only a few defaults
23:53:10 <osfameron> it looks rather like the anonymous class syntax in Java
23:53:21 <osfameron> but for a record rather than a class
23:54:15 <osfameron> thanks for the info, that looks exactly what I need, and very comprehensible
23:54:49 <osfameron> (now I'm just scared of the StateT IO stuff, which I think I might just ignore for the moment until it becomes obvious how it will help me refactor the mess I get myself into :-)
23:56:09 <firefly> I looked at monad transformers yesterday (or was it the day before?) and they are really not scary.
23:56:29 <firefly> The trick is to think of the monads as a stack (or an onion, with layers).
23:57:07 <firefly> You normally work with the uppermost (outermost) layer, in this case the state monad, but you can also access the one below it (IO) by using the lift function.
23:57:09 <osfameron> firefly: see, the thing with the ole' semicolon separator in imperative languages is that nobody ever has to think about it, explain it, or compare it to an onion :-)
23:57:21 <firefly> err... Pascal?
23:57:44 <firefly> I think it's been proven without a doubt that terminators work better than separators for statements :)
23:58:01 <osfameron> terminators?
23:58:03 <firefly> can you explain to a beginner why there must not be a semi-colon before 'else' in Pascal?
23:58:41 <lament> yes
23:59:01 <firefly> once you understand a bit about grammar and once you've seen the BNF (or equivalent "race track" diagrams) it becomes clear but until then it seems like a twisted exception just put in to spite you.
23:59:11 <osfameron> can't remember enough pascal sorry... in Perl things are quite straight forward (they're optional when it makes sense to be.  Actually, I think semicolons may be one of the few really comprehensible things about Perl :-)
23:59:46 * firefly thinks there are too many ways of doing it -- think of what the poor cat has to go through!
