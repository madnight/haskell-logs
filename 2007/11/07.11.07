00:13:11 <hpaste>  faxathisia pasted "execute program from file" at http://hpaste.org/3721
00:13:28 <faxathisia> I just wanted to ask if this is excessive?
00:14:42 <faxathisia> since it's IO and Maybe.. I guess there should be two 'do's ?
00:18:55 <TSC> You can get rid of the brackets after $
00:18:59 <TSC> That makes it a bit neater
00:22:08 <osfameron> quicksilver: I played with trying to implement split yesterday.  It's definitely more complicated than it first seems :-)
00:26:42 <wli> osfameron: Why is it complicated?
00:27:36 <osfameron> wli: it seems like you need to alternate between 2 functions - that which takes the separated item, and that which takes the separator (and then discards or stores it)
00:28:14 <wli> osfameron: My first thought would be a state machine, with essentially one function for each state.
00:28:34 <osfameron> wli: I may be finding it particularly hard as I'm not yet experienced with haskell, but quicksilver has occasionally mentioned that writing a *general* function is trickier than it sounds, hence why it's not included in the prelude
00:28:47 <cizra> @src filter
00:28:47 <lambdabot> filter _ []     = []
00:28:48 <lambdabot> filter p (x:xs)
00:28:48 <lambdabot>     | p x       = x : filter p xs
00:28:48 <lambdabot>     | otherwise = filter p xs
00:28:55 <cizra> lambdabot: thanks
00:29:00 <osfameron> wli: ah, yes.  I haven't really played with state machines, and also wouldn't know how to start with those in haskell
00:29:36 <wli> osfameron: There have been a few Knuth-Morris-Pratt machines posted on hpaste.org
00:32:46 <osfameron> wli: ah, thanks.
00:33:44 <wli> osfameron: Did you find them?
00:34:48 <osfameron> wli: I've just googled and found http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
00:34:50 <lambdabot> Title: Knuth-Morris-Pratt in Haskell - 21 thoughts, http://tinyurl.com/23rvcf
00:35:01 <osfameron> wli: learning a state machine algorithm is more than I have time for now though :-(
00:35:53 <wli> osfameron: I spent 9 years between when I first learned Haskell and figuring out monads because I always had other things to do. I'm sure you'll get around to it faster than I did that.
00:36:26 <osfameron> hehe, I hope so.
00:43:56 <wli> It's something of an easy algorithm, though. You're pretty much doing dynamic programming of sorts on where in the midst of a string match you could be. Basically when you get a match failure you do some checking so you only punt yourself as far back in the string pattern as you need to be.
00:44:42 <wli> You precalculate the various places in the string you could end up as states so you don't have to traverse the thing in reverse and so on.
00:45:19 <wli> That is, where in the string you could end up starting from a given position in the string.
00:46:50 <wli> That said, my brain has long-since disintegrated to the point where I'm likely incapable of writing it at all regardless of how much time I'm given.
00:48:32 <osfameron> ah, I've never understood what "dynamic programming" means either
00:49:02 <wli> Basically sharing massively duplicated subproblems.
00:49:44 <wli> You solve subproblems from the bottom up and share their solutions to bigger subproblems as you build up toward the ultimate solution set.
00:50:46 <wli> It looks a lot like a memo table you do lookups from.
00:51:23 <osfameron> that just sounds like programming...
00:51:39 <hpaste>  mcp_ pasted "my homework" at http://hpaste.org/3722
00:51:45 <idnar> dynamic programming is a specific algorithm, really, not a "programming style"
00:51:53 <wli> It sounds more complicated than it is, at least in Haskell. In C it can be a big PITA.
00:51:56 <bparkis> no dynamic programming is a style
00:52:11 <idnar> well, it's more specific than "object-oriented programming" or something
00:52:11 <bparkis> it's as opposed to recursion
00:52:18 <mcp_> Can someone look at "my homework" (its the test case actually) and tell me if that is syntactically correct?
00:52:34 <bparkis> yes more specific than oop
00:52:37 <faxathisia> mcp_: just have the compiler check if it's correct syntax
00:52:40 <idnar> I found the term horribly confusing until I figured that out
00:52:48 <idnar> I wouldn't really consider recursion a "style" either
00:53:02 <idnar> I guess that's more generic than the level of "algorithm"
00:53:04 <bparkis> well, it is
00:53:05 <mcp_> It says undefined variable d. I agree with that, there is no d defined anywhere. Can it still work?
00:53:11 <wli> osfameron: The Collatz problem in Project Euler is an example of dynamic programming in use.
00:53:42 <idnar> anyhow, hopefully my meaning is clear, even if my terminology is wrong
00:54:00 <osfameron> wli: which number is that?
00:54:38 <bparkis> for a simple example consider 2 different ways of computing factorial
00:55:15 <bparkis> you can use fac n = n * fac (n-1)  and a base case, or you can fill in a table starting from 1 and going up to n, multiplying by the number each time
00:55:34 <bparkis> i.e. in dynamic programming you _start_ at the base case and fill in values up to the one you want to compute
00:55:59 <bparkis> and in straight recursion you start at the problem statement and compute values backwards down to the base case
00:56:08 <osfameron> wli: ah, question 14
00:56:16 <osfameron> wli: I had problems with that one :-)
00:57:57 <wli> osfameron: http://projecteuler.net/index.php?section=problems&id=14
00:57:59 <lambdabot> Title: Problem 14 - Project Euler
00:58:41 <quicksilver> osfameron: the simplest kind of state machine is just two mutually recursive functions
00:58:48 <osfameron> yeah, that's one that I tried in haskell and then perl and then skipped
00:58:51 <quicksilver> osfameron: your "State" is which function you are in
00:59:02 <quicksilver> osfameron: you "stay in the same state" by making a conventional tail call
00:59:09 <quicksilver> and you "change state" by calling the other function
01:00:00 <osfameron> quicksilver: yeah, fair enough.
01:00:01 <bparkis> you could do the same thing by adding an extra "state" argument to one of the functions and having it only recurse on itself
01:00:13 <bparkis> and behave differently depending on the value of the state argument
01:00:31 <osfameron> I think I may have got confused by trying to do it with unfoldr (which I worked out for the simple case, but I think doesn't play so well with a changing function)
01:01:17 <bparkis> but that's not really a state machine, that's just one use of states, to get a finite state machine you have other requirements like an input stream and an output stream
01:01:26 <bparkis> well, an input stream and an output value
01:03:40 * quicksilver shrugs
01:03:48 <quicksilver> there are lots of ways of defining state machine :)
01:04:05 <quicksilver> and of course, there is no difference between two function
01:04:11 <quicksilver> funFoo and funBar
01:04:22 <quicksilver> and defining a data State = Foo | Bar
01:04:32 <quicksilver> and then defining fun Foo and fun Bar
01:04:42 <quicksilver> the second may seem more regular, in fact :)
01:04:45 <quicksilver> but the idea is the same
01:05:13 <mcp_> So, what does {-3,1-} at the beginning of a line mean?
01:05:28 <mcp_> what are curly brakets for?
01:05:49 <sjanssen> mcp_: comments
01:06:04 <sjanssen> > 1 + {- an inline comment -} 2
01:06:06 <lambdabot>  3
01:06:39 <mcp_> sjanssen, so i can stop trying to understand that now
01:07:16 <sjanssen> mcp_: actually, not all curly brackets are comments
01:07:40 <sjanssen> {- indicates a comment, { alone is explicit layout
01:07:57 <quicksilver> comments  have some times been used as extra syntax or compiler directives, too
01:08:12 <quicksilver> profiling hotspots used to be {- scc -}, IIRC
01:09:17 <scook0> {-# LANGUAGE NoMonomorphismRestriction #-} and the like
01:30:43 <faxathisia> #esoteric
01:30:46 <faxathisia> :|
01:30:56 <faxathisia> (accident, sorry)
01:39:28 <opqdonut>     Record update for the non-Haskell-98 data type `Node' is not (yet) supported
01:39:32 <opqdonut> ?
01:39:42 <opqdonut> data Node a = Ord a => Node {level::Int, val::a, left::(Node a), right::(Node a)} | Bottom
01:40:01 <opqdonut> is this because of the Bottom constructor ?
01:40:11 <matthew-_> no, shouldn't be
01:40:18 <opqdonut> hrmmm
01:40:20 <matthew-_> I think you should just try putting the Ord on the left
01:40:36 <matthew-_> I think it's getting confused with GADTs
01:40:41 <opqdonut> ahhh
01:40:43 <opqdonut> yes, must be
01:40:49 <opqdonut> yep, works
01:41:08 <matthew-_> with data (Ord a) => Node a = ... ?
01:44:12 <quicksilver> opqdonut: you have made it existential in the Ord
01:44:26 <quicksilver> thre were two different 'a's in your declaration
01:44:27 <quicksilver> I think
01:44:53 <quicksilver> no, maybe not
01:45:04 <quicksilver> damn I always get confused by that syntax
01:45:14 <matthew-_> yeah. I'm guessing this is 6.8 aswell
01:54:42 <quicksilver> yeah, thinking about it
01:54:53 <quicksilver> your declaration said that the Node constructor had an Ord context
01:54:58 <quicksilver> but the Bottom constructor didn't
01:55:05 <quicksilver> and that's not haskell98, I think?
01:57:37 <matthew-_> yep.
01:58:21 <matthew-_> but the standard practise is not to put type class constraints on data declarations because they're not helpfully propogated around, meaning you're just going to have to duplicate that context everywhere anyway
02:00:05 <matthew-_> people instead tend to hide the constructors and write bottom :: (Ord a) => Node a and the equiv for node :: (Ord a) => some stuff -> Node a
02:02:13 <roconnor> Anyone have an example of a bibtex reference to the Monad.Reader?
02:04:02 <nominolo> can someone help me remember the name for that parser/pretty-printer generator written by (I think) bringert?
02:04:02 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
02:17:09 <ivanm> does anyone know if the regex-* packages work with 6.8.1 yet?
02:20:20 <levi13> Hi, I am trying to install alex, but can't perform the runhaskell Setup.lhs configure step
02:20:27 <levi13> I get the error Cabal-1.1.6 is hidden
02:20:48 <levi13> Is there a way to unhide it?
02:23:34 <roconnor> http://www.cs.nott.ac.uk/~wss/Publications/WhyAttributeGrammarsMatter.bib
02:23:38 <lambdabot> http://tinyurl.com/2xyd9x
02:25:09 <roconnor> I don't suppose the monad reader has a doi
02:26:38 <dcoutts> ivanm: the 3 regex-* packages that got uploaded to hackage the other day work with 6.8.1
02:26:47 <dcoutts> ivanm: the 0.7x.0.1 versions
02:28:31 <osfameron> lambdacats++
02:29:02 <ivanm> dcoutts: so 0.7 > 0.9? :s
02:29:23 <dcoutts> ivanm: no, version numbers are apis, not release dates
02:30:21 <ivanm> dcoutts: lets shift this to #gentoo-haskell then :p
02:30:26 <dcoutts> @arr!
02:30:26 <lambdabot> I'll crush ye barnacles!
02:30:28 <ivanm> since I was pretty much waiting round for you there :p
02:33:31 <SnailRacer> Sometimes ghci sends a packet that triggers my firewall (Sygate, WinXP)
02:35:13 <profmakx> SnailRacer, can you be a little bit more specific?
02:35:24 <profmakx> "some packet that somehow triggers my firewall"
02:36:57 <nominolo> levi13: can you paste the output of ghc-pkg list ?
02:37:02 <SnailRacer> It requests network access to a local IP (non-existant), usually under heavy use
02:37:24 <quicksilver> I find that hard to imagine
02:37:32 <profmakx> same here
02:37:32 <quicksilver> ghci does nothing network related at all
02:37:33 <SnailRacer> that is that ghci is running something for a few minutes
02:37:35 <nominolo> levi13: are you sure you call "runhaskell" and not "ghc Setup.lhs" ?
02:37:38 <quicksilver> (unless you ask it to)
02:38:04 <SnailRacer> in the interpreter, it doesn't happen if I compile stuff
02:40:18 <SnailRacer> I'm not really sure why, I'd guess it might have to do with GC and virtual paging in Windows? *shrug*
02:40:39 <scodil> is there an ETA for gtk2hs + GHC 6.8.1? Or am I the only one having trouble compiling it?
02:40:56 <dcoutts> scodil: I'm working on it now
02:41:05 <scodil> sa-weet
02:46:53 <dsilva> is there a good place to report discrepancies in the documentation?
02:47:31 <sjanssen> dsilva: in the libraries documentation?
02:47:41 <dsilva> the docs for Data.Typeable.TypeRep at http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Typeable.html#t%3ATypeRep  say that TypeRep is an instance of Data when it isn't
02:47:43 <lambdabot> http://tinyurl.com/22cesv
02:48:49 <sjanssen> dsilva: there's an instance in Data.Generics.Instances
02:49:01 <sjanssen> (which is exported from Data.Generics)
02:49:19 <quicksilver> sjanssen: that's odd
02:49:36 <quicksilver> sjanssen: how come that page shows an instance which isn't defined there; while Data.Traversable fails to do so.
02:49:41 <levi13> thanks nominolo, pretty sure it is meant to be.
02:49:56 <quicksilver> sjanssen: I assumed there was an endemic haddock problem that it was no longer showing non-locally defined instances. But apparently not.
02:50:00 <sjanssen> quicksilver: which instance?  Is it defined in another package?
02:50:07 <levi13> but, I'm installing ghc without needing alex now :)
02:50:15 <quicksilver> sjanssen: I, I understand.
02:50:26 <quicksilver> sjanssen: data types are correctly showing all their instances, even non-local ones
02:50:37 <quicksilver> sjanssen: but type classes don't show their non-local instances
02:50:51 <dsilva> quicksilver: that's confusing though
02:50:56 <sjanssen> ah, that is interesting
02:50:56 <quicksilver> sjanssen: so, e.g., Data.Maybe documents the Traversable instance for Maybe (which is defined in Data.Traversable)
02:51:14 <quicksilver> sjanssen: but, Data.Traversable does not document the Traversable instance for Sequence (which is defined in Data.Sequence)
02:51:18 <quicksilver> dsilva: it's a bug
02:51:23 <quicksilver> dsilva: more precisely, it's a regression.
02:51:24 <dsilva> quicksilver: oh ok
02:51:30 <quicksilver> dsilva: the ghc 6.6 documentation didn' not behave this way
02:51:42 <dsilva> quicksilver: I see
02:51:45 <quicksilver> it's either due to the new haddock version, or the base-split in some obscure way I don't understand.
02:51:53 <sjanssen> quicksilver: traversable and sequence are in separate packages, I bet that's the issue
02:52:02 <quicksilver> sjanssen: I bet it is, too.
02:52:06 <quicksilver> sjanssen: ah good point.
02:52:15 <quicksilver> so amybe my distinciton is the wrong one
02:52:17 <dsilva> quicksilver: did the old docs just omit that information, or mention the extra instances but note that they're defined elsewhere?
02:52:28 <quicksilver> dsilva: the old docs mentioned all instances, in both directions
02:52:40 <quicksilver> dsilva: instances were always documented with both the class and the type
02:52:45 <quicksilver> wherever they were actually defined
02:52:50 <dsilva> oh ok
02:52:57 <quicksilver> which was much nicer
02:53:03 <quicksilver> even though it did lead to long instance lists in places :)
02:53:19 <sjanssen> dsilva: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Generics-Basics.html#t%3AData shows that TypeRep is an instance of Data
02:53:21 <lambdabot> http://tinyurl.com/25pjv7
02:53:50 <sjanssen> it's only cross-package instances that aren't attached to the class docs
02:53:56 <dsilva> sjanssen: hmm ok
02:55:08 <Sizur> i'm trying to install hslogger and i get this error: http://pastebin.org/7312 what's the problem?
02:55:51 <dsilva> ok, so now I think I'm misusing TypeRep :)
02:56:04 <dsilva> I would expect the following to say IntRep:  dataTypeRep $ dataTypeOf $ dynTypeRep $ toDyn 8
02:56:07 <sjanssen> Sizur: hs-logger uses hooks that aren't compatible with your version of Cabal
02:56:19 <dsilva> but ghci tells me NoRep
02:56:42 <sjanssen> dsilva: 8 :: Integer
02:56:53 <Sizur> sjanssen: so i need to reinstall Cabal?
02:57:16 <sjanssen> Sizur: it's actually depending on an old version of Cabal (hard to say which version)
02:57:59 <Sizur> sjanssen: so what now? either no hslogger for me or dependency hell?
03:00:31 <dsilva> sjanssen: right, but after storing the integer in a Dynamic, I thought that the DataRep would be the key to finding out the type of data inside
03:02:15 <quicksilver> dsilva: no, not at all
03:02:23 <quicksilver> dsilva: the dynamics stuff is quite independent of the generics stuff
03:02:35 <hpaste>  SnailRacer pasted "ghci packet" at http://hpaste.org/3723
03:02:54 <quicksilver> dsilva: the key to finding out what's inside a Dynamic is 'cast'
03:03:02 <dsilva> quicksilver: fromDynamic?
03:03:47 <quicksilver> ah yes, that :)
03:03:52 <quicksilver> cast is a pure typeable thing
03:03:55 <quicksilver> very similar idea though
03:04:27 <faxathisia> Do you know any more stuff about logic programming in haskell? I found typed logical variables and LogicT ( http://citeseer.ist.psu.edu/claessen00typed.html http://okmij.org/ftp/Computation/monads.html#LogicT )
03:04:29 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
03:04:52 <sjanssen> Sizur: http://code.haskell.org/~sjanssen/hslogger-1.0.2.20071107-unofficial.tar.gz
03:04:54 <lambdabot> http://tinyurl.com/283t2d
03:05:48 <quicksilver> > let isInteger d = isJust (fromDynamic d :: Maybe Integer) in (isInteger (toDyn (8::Integer)),isInteger (toDyn (8.4::Double)))
03:05:49 <lambdabot>  (True,False)
03:05:54 <quicksilver> dsilva: like that
03:07:17 <dsilva> quicksilver: hmm ok, thanks
03:07:19 <Sizur> sjanssen: thank you tonns! :D it works
03:08:05 <faxathisia> so I guess LogicT and typed logical variables are about the most people have done in this area?
03:08:07 <faxathisia> in haskell
03:08:35 <kfish> and logic programming in the type system :-)
03:08:50 <faxathisia> oh like can you give an example?
03:09:00 <kfish> ?where insanity
03:09:00 <lambdabot> http://haskell.org/haskellwiki/User:ConradParker/InstantInsanity
03:09:08 <faxathisia> thanks
03:09:33 <quicksilver> dsilva: for specific real problems you can normally write somethiing quite smart and typesafe wihtou much tpye annotation
03:10:49 <dsilva> quicksilver: I'm trying to extend HDBus (the haskell dbus bindings) to handle arbitrary incoming data
03:12:12 <nornagon> @src fix
03:12:13 <lambdabot> fix f = let x = f x in x
03:12:42 <quicksilver> dsilva: not possible, actually :)
03:12:53 <dsilva> quicksilver: ?
03:12:58 <dsilva> quicksilver: sure it is
03:12:58 <quicksilver> dsilva: you'd can't do anything sensible with arbitrary typess
03:13:09 <dsilva> quicksilver: read in everything as a Dynamic
03:13:15 <quicksilver> you can only ever do useful things with those types known to the compiler at compile time
03:13:27 <quicksilver> sure, you can read it in as Dynamic
03:14:00 <quicksilver> but you can only cast it to the set of types known to the compiler at compile time
03:14:23 <quicksilver> in fact
03:14:24 <quicksilver> hmm
03:14:26 <dsilva> quicksilver: sure, that's fine
03:14:40 <dsilva> quicksilver: the types are limited to what DBus defines anyway
03:14:53 <quicksilver> why not use an ADT then?
03:15:00 <quicksilver> explicitly listing all the possible DBus types
03:15:20 <dsilva> quicksilver: because why duplicate Dynamic? :)
03:15:22 <quicksilver> (I don't think you can define a Read instance for Dynamic, in fact. Not without embedding hs-plugins)
03:15:49 <quicksilver> because Dynamic says "any typeable type"
03:15:51 <quicksilver> and that's not what you mean
03:15:57 <quicksilver> you mean "any of this set of finite types"
03:15:59 <opqdonut> how do i define what names a module exports? module Foo (bar,Quux) where?
03:16:42 <quicksilver> opqdonut: right
03:16:46 <opqdonut> yep
03:17:22 <quicksilver> in fact, I'll go further. I don't think you can define a Read/Show pair for any existential without boilerplate
03:17:29 <opqdonut> how about constructors, they could be hidden but the type exposed?
03:17:36 <quicksilver> boilerplate which, essentially, contains a list of every actual concrete type
03:17:37 <Saizan_> opqdonut: yes, for types you've to list the exported constructors like Bar(Bar1,Bar2) or Bar(..)
03:17:44 <opqdonut> ah thanks :)
03:17:47 <opqdonut> or Bar()?
03:17:48 <Saizan_> Bar(..) exports all of them
03:17:52 <dsilva> quicksilver: oh i'm not providing a Read instance
03:18:01 <dsilva> quicksilver: dbus data streams are preceded by a type tag
03:18:11 <dsilva> quicksilver: so when an int is coming, you know it's an int
03:18:14 <Saizan_> opqdonut: if you don't want to export any just use Bar
03:18:29 <quicksilver> dsilva: so where does dynamic come into this? you know what type it is, just read it?
03:18:35 <quicksilver> dsilva: I'm not really following you at all :)
03:18:43 <opqdonut> Saizan_: ok
03:18:45 <nornagon> @. pl src fix
03:18:46 <lambdabot> (line 1, column 1):
03:18:46 <lambdabot> unexpected end of input
03:18:46 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
03:18:57 <nornagon> @pl \f -> let {x = f x} in x
03:18:58 <lambdabot> (line 1, column 11):
03:18:58 <lambdabot> unexpected "{"
03:18:58 <lambdabot> expecting natural, identifier or "in"
03:19:01 <nornagon> rats
03:19:10 <b_jonas> aren't existentials also difficult to compile?
03:19:14 <quicksilver> b_jonas: not at all
03:19:44 <nornagon> @pl \f -> let x = f x in x
03:19:45 <lambdabot> fix
03:19:45 <quicksilver> unbounded existentials can be erased at compile time
03:19:50 <nornagon> lambdabot: cheater!
03:19:52 <quicksilver> the type checker does all the hard work
03:20:09 <quicksilver> bounded ones essentially compile to a secret tuple bundling the dictionary
03:20:18 <b_jonas> quicksilver: yes, but I think they have difficulties to compile separately in files then link
03:20:28 <b_jonas> the same way as templates are difficult to complie in c++
03:20:51 <b_jonas> it'd be easy if you compiled the whole executable from a single source file (compilation unit)
03:20:59 <quicksilver> b_jonas: nope
03:21:04 <quicksilver> b_jonas: honestly, there's no problem
03:21:12 <quicksilver> b_jonas: existentials are natural and easy for the compiler
03:21:13 <Taejo> nornagon, why is that cheating?
03:21:25 <Saizan_> htey are as difficult to compile as OO classes i'd say, you've to bundle the dictionary of methods with the "object"
03:21:39 <nornagon> Taejo: i wanted to come up with a point-free version of fix
03:21:41 <quicksilver> b_jonas: remember haskell compilers (can and ghc does) erase types
03:21:47 <quicksilver> nornagon: fix is point free?
03:22:13 <b_jonas> Saizan_: yes, that's true
03:22:21 <nornagon> quicksilver: ?
03:22:29 <b_jonas> but I've heared the haskell compilers do that anyway for normal types to make code smaller
03:22:31 <araujo> morning
03:22:40 <b_jonas> even though there it's not strictly neccessary
03:22:47 <b_jonas> you could duplicate every function for every type
03:22:57 <quicksilver> ?
03:23:02 <quicksilver> no idea what you mean, b_jonas
03:23:11 <quicksilver> you don't need to duplicate functions for polymorphism
03:23:29 <quicksilver> the only type you get a duplicated function is with a SPECIALIZE pragma
03:23:45 <quicksilver> and that's a GHC pragma to avoid class dispatch overhead
03:24:03 <Saizan_> well but you could to avoid dictionaries when not using existentials, no?
03:24:34 <quicksilver> you could imagine duplicating every function with a context, yes
03:24:40 <quicksilver> i.e. SPECIALIZE everything
03:27:18 <b_jonas> yes, and if you did that, you wouldn't need to pass any types to the functions
03:27:26 <b_jonas> that's how c++ templates work
03:27:35 <quicksilver> you don't pass types to the functions
03:27:43 <b_jonas> you don't
03:27:43 <dsilva> by the way, the build code for HDbus is forgetting to put -C `pkg-config --cflags dbus-1` -L `pkg-config --libs dbus-1`   in the hsc2hs command line, even though the buildinfo.in mentions DBUS_CFLAGS.  is there a step before configure?
03:27:44 <quicksilver> you pass dictionaries
03:27:45 <b_jonas> the compiler does
03:27:48 <quicksilver> not types
03:28:07 <quicksilver> but anyhow, existentials are not, per se. to do with type classes
03:28:10 <sjanssen> hmm, can we think of a case where specialization isn't possible?
03:28:18 <quicksilver> sjanssen: existentials? :)
03:28:23 <b_jonas> exactly
03:28:37 <quicksilver> b_jonas: "plain" or unbounded existentials are simpler
03:28:42 <quicksilver> and they don't worry the compiler at all
03:28:45 <sjanssen> quicksilver: I was imagining something with non-regular data types
03:29:13 <b_jonas> quicksilver: what are those?
03:30:06 <quicksilver> b_jonas: exists a . (a -> String)
03:30:08 <quicksilver> e.g.
03:30:28 <quicksilver> or, rather more usefully, exists a . (a,a -> String,a -> Int)
03:30:33 <takamura> hi
03:31:29 <dsilva> er, nevermind, I forgot to run autoreconf
03:39:41 <Saizan_> btw, i've never really understood why forall a. Foo a === exists a. a, there's a not somewhere that i'm not seeing that transform that quantification?
03:41:22 <quicksilver> the constructor Foo has type forall a => Foo
03:42:00 <quicksilver> the 'negation' is the contravariance of the constructor
03:42:42 <quicksilver> data Bundle = forall a . MkBundle (a , String ->a)
03:42:52 <quicksilver> well, simpler
03:42:59 <quicksilver> data Bundle = forall a . MkBundle a  (String ->a)
03:43:12 <quicksilver> so MkBundle :: forall a . a -> (String->a) -> Bundle
03:43:29 <idnar> @pl \f -> let x = f (f x) in x
03:43:29 <lambdabot> fix . join (.)
03:43:33 <idnar> meh
03:43:57 <quicksilver> basicallys because 'Bundle' itself is on the RHS of the arrow and the "as" are on the left
03:44:05 <quicksilver> thats your contravariance
03:44:08 * quicksilver didn't explain that well
03:47:57 <Sorous1> hi, can Haskell work with databases? Can we make dlls with haskell?
03:48:23 <osfameron> Sorous1: those are two very different questions :-)
03:48:57 <quicksilver> the answer is yes to both
03:49:04 <quicksilver> the second may be a bit harder than the first though :P
03:50:32 <Sorous1> quicksilver, why is the second harder?
03:52:55 <quicksilver> Soroush83: because ghc generally builds statically linked executables
03:53:54 <Sofoush> quicksilver, how can I write some part of my program in Haskell and some part of it in  cpp or another program
03:54:12 <SamB_XP> cpp works fine with Haskell
03:54:16 <SamB_XP> but I bet you didn't mean cpp
03:54:38 <SamB_XP> cpp being the C preprocessor
03:55:18 <Sorous1> I want to desing the GUI with another program
03:55:25 <Sorous1> It is easier
03:55:44 <scook0> having a top-level Haskell program call into C++ code is not terribly difficult
03:55:54 <scook0> the other way should be possible, but I've never done it myself
03:56:18 <Sorous1> I just want to have haskell to do some calculations
03:56:29 <Sorous1> can You show me some tutorials about it?
03:56:39 <Sorous1> and working with database too
03:56:47 <Sorous1> Mysql is prefered
03:57:22 <quicksilver> actually GUIs are easier in haskell and mysql is never preferred, because it is the wrost available database :)
03:57:33 <quicksilver> however, you're entitled to make your own choices.
03:58:07 <quicksilver> You wouldn't need to compile to a DLL to do a mixed language projet like that
03:58:23 <quicksilver> just use the FFI and have ghc link your foreign code into yoru haskell code
03:58:40 <Sorous1> which db do you recommend?
03:58:42 <osfameron> mysql is lovely, if you don't need features or reliability
03:58:52 <scook0> heh
03:59:14 <SamB_XP> hah
03:59:21 <scook0> Sorous1: what are you building?
03:59:30 <quicksilver> postgres would be my choice, if you want a free SQL-based db
04:00:03 <idnar> I'd also suggest sqlite, since you can avoid all the admin work that goes with running a database server
04:00:04 <SamB_XP> sqlite is said to be more robust than MySQL
04:00:14 <quicksilver> yeah
04:00:24 <quicksilver> sqlite is horrid in the way it totally fails to have a type system ;)
04:00:32 <quicksilver> but the bundled-all-in-one piece aspect is attractive
04:00:52 <scook0> quicksilver: SELECT (0.0+x)/y FROM ...
04:01:11 <scook0> darn integer division :/
04:01:47 <scook0> Sorous1: also, what are you doing your GUI in?
04:02:11 <Sorous1> scook0, my GUI is very important
04:02:27 <Sorous1> and it is not just some windows
04:02:33 <Sorous1> it contains many things
04:02:39 <scook0> what language/toolkits?
04:02:50 <scook0> (I'm asking from the perspective of how to integrate it with Haskell code)
04:03:07 <Sorous1> it should generate pictures. I prefer Delphi or C++Builder for it
04:03:17 <quicksilver> one of the first things I learnt about combining functional and imperative languages
04:03:26 <quicksilver> is that the more you do, the more you wish everything was on the functional side
04:03:36 <quicksilver> my first experience of this was a java applet in MLj
04:03:40 <quicksilver> I did the UI code in Java
04:03:44 <quicksilver> and the hard work in ML
04:03:54 <quicksilver> I rapidly wished I was doing *all* the work in ML
04:04:15 <quicksilver> you quickly get used to the way that a type system + higher order functions enabled you to arrange the code more expressively
04:04:29 <osfameron> what's the current state of the art for haskell gui ?
04:04:34 <quicksilver> however, if you're just beginning with haskell, you may not find that ;)
04:04:35 <Sorous1> quicksilver, But I don't have enough time to learn and teach my partners gui in Haskell
04:04:45 <quicksilver> Sorous1: yes, that's a fair point
04:05:01 <quicksilver> if you have time constraints (and who doesn't!) then you have to choose your battles
04:05:05 <quicksilver> and make use of existing skills
04:05:14 <quicksilver> osfameron: wsHaskell or gtk2hs
04:05:23 <quicksilver> osfameron: none of this "fancy FRP stuff" is really prime-time yet
04:05:33 * dcoutts prepares the gtk2hs-0.9.12.1 release
04:05:45 <quicksilver> osfameron: but even if you're just doing "imperative style haskell" it still feels much nicer than C or C++
04:05:51 <TSC> dcoutts: That's good news; thanks!
04:06:43 <quicksilver> osfameron: but even without the "Fancy FRP stuff" you quickly find nicer higher-order styles of using GUIs
04:07:05 <osfameron> quicksilver: ah ok.  Well that's not necessarily a problem as the "fancy FRP stuff" also makes my tiny brane explode
04:08:03 <idnar> FRP?
04:08:14 <quicksilver> functional reactive programming
04:08:22 <quicksilver> a technique for declarative GUIs
04:08:30 * osfameron heads off to lunch
04:08:58 * idnar looks around
04:09:22 <Saizan_> i wonder how it will apply to web programming..
04:09:29 <idnar> the wikipedia article seems pretty useless ;)
04:09:42 <Saizan_> ?where yampa
04:09:42 <lambdabot> http://www.haskell.org/yampa/
04:10:03 <ac> :t read
04:10:06 <lambdabot> forall a. (Read a) => String -> a
04:10:08 <ac> why doesn't read return a Maybe a? Can't it fail?
04:11:09 <Saizan_> > read "foo" :: Int
04:11:11 <lambdabot>  Exception: Prelude.read: no parse
04:11:24 <quicksilver> ac: it gives an exception
04:11:27 <quicksilver> ac: compared 'readS'
04:11:31 <quicksilver> :t readS
04:11:33 <lambdabot> Not in scope: `readS'
04:11:36 <Saizan_> :t reads
04:11:38 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:11:38 <quicksilver> erm?
04:11:40 <quicksilver> thanks :)
04:11:52 <quicksilver> > reads "foo" :: [(Int,String)]
04:11:54 <lambdabot>  []
04:12:04 <quicksilver> > reads "15a" :: [(Int,String)]
04:12:06 <lambdabot>  [(15,"a")]
04:12:33 <Saizan_> let maybeRead = listToMaybe . map fst . reads in maybeRead "foo" :: Int
04:12:37 <idnar> hmm, which of these papers should I be looking at? I'm just want to know what it's all about, really.
04:12:54 <Saizan_> > let maybeRead = listToMaybe . map fst . reads in maybeRead "foo" :: Int
04:12:55 <lambdabot>  Couldn't match expected type `Int' against inferred type `Maybe a'
04:12:58 <ac> quicksilver: thanks, I was looking for reads
04:12:59 <quicksilver> ac: you could define maybe_read s = case reads s of [(a,"")] -> Just a ; _ -> Nothing
04:13:06 <ac> yeah
04:13:14 <quicksilver> my solution is slightly better than Saizan_'s in the sense that it rejects partial parses
04:13:21 <quicksilver> of course, it depends what you want :)
04:13:21 <Saizan_> yup
04:13:24 <quicksilver> s/better/different/
04:13:25 <ac> right I see
04:13:30 <ac> It's just parsing it
04:13:53 <quicksilver> :t \s -> case reads s of [(a,"")] -> Just a ; _ -> Nothing
04:13:55 <lambdabot> forall a. (Read a) => String -> Maybe a
04:14:11 <quicksilver> in *principle* you can have a reads which returns more than one result if there is an ambiguous parse
04:14:22 <quicksilver> but I don't believe any of the standard instances will ever do that? :)
04:14:30 <Saizan_> idnar: i second you question, especially wrt GUIs since yampa is about robotics
04:15:44 <quicksilver> try conal's tangible values paper?
04:15:47 <quicksilver> that's closely related
04:16:29 <quicksilver> in fact, conal's written a couple of papers. *ponder*
04:16:46 <quicksilver> http://conal.net/fran/
04:16:47 <lambdabot> Title: Functional Reactive Animation (Fran)
04:16:56 <quicksilver> is old code, but interseting
04:17:34 <quicksilver> also the links on
04:17:34 <quicksilver> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
04:17:36 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yvrplw
04:17:41 <quicksilver> but ehthere are a lot of dead projects there :(
04:18:44 <quicksilver> ah
04:18:45 <quicksilver> http://www.haskell.org/haskellwiki/Phooey
04:18:46 <lambdabot> Title: Phooey - HaskellWiki
04:18:55 <quicksilver> is one of the more recent  less dead
04:35:59 <hx2k> hello folks!
04:37:00 <twanvl> hello hx2k
04:38:13 <yaxu> should I upgrade to ghc 6.8.1 to get MonadRandom?
04:38:18 <yaxu> currently on 6.6.1
04:39:17 <twanvl> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom-0.1.0
04:39:19 <lambdabot> http://tinyurl.com/28wzxt
04:39:52 <dcoutts> yaxu: no, it looks like it'd work with 6.6.1
04:40:05 <yaxu> great, thanks both
04:54:40 <ketil> Hi!  I'm trying to run a program that I compiled on a different computer - but I keep getting floating point exceptions.  Any ideas?
04:54:49 <ketil> The program runs fine on the computer I compiled it.
04:54:51 <ivanm> ketil: same architecture?
04:55:10 <ketil> Xeons, the stepping is different (5 and 7).
04:55:30 <ketil> Different Linux distros - and I get FATAL: kernel to old if I link statically.
04:55:35 <ivanm> don't know about xeons and stepping... but if the arch is the same, I'd think it'd still work
04:56:05 <ketil> It works the other way around, too.
04:57:14 <ketil> The host generating the non-working binaries has additional CPU flags:  pbe cid xtpr
05:00:03 <ac> how would you spawn a given function as a separate process, and receive a message if that process throws an exception?
05:00:48 <quicksilver> ketil: a haskell program?
05:02:17 <ketil> quicksilver, Hm?  Yes, otherwise I'd ask somewhere else :-)
05:02:38 <quicksilver> ketil: just checking :)
05:02:45 <quicksilver> ketil: any unusual compiler options chosen?
05:02:49 <ketil> I've tried various flags to ghc, -optl-static makes it work on a host with Linux 2.6.9 (the compile host is 2.6.22).
05:03:04 <quicksilver> ketil: what does "ldd" on the produced binary say?
05:03:26 <twanvl> are you dividing by 0 somewhere?
05:03:59 <quicksilver> ketil: sounds to me like a binary incompatibility caused by incompatible library versions, probably libc or libgmp
05:04:06 <ketil> quicksilver: ahem: /usr/bin/ldd: line 124: 28172 Floating point exceptionLD_TRACE_LOADED_OBJECTS=1 LD_WARN= LD_BIND_NOW= LD_LIBRARY_VERSION=$verify_out LD_VERBOSE= "$@"
05:04:16 <ketil> maybe we're on to something?
05:04:18 <quicksilver> !
05:04:23 <quicksilver> ldd itself gives an exception?
05:04:32 <ketil> 'parently.
05:04:44 <quicksilver> sounds to me like that machine is in a mess
05:04:52 <quicksilver> can you ldd other innocent looking binarys
05:04:57 <quicksilver> how about ldd'ing ldd itself?
05:05:05 <ketil> Time to file a bug against...`cat /etc/issue`?
05:05:17 <quicksilver> not sure
05:05:25 * ac discovers Control.Exception. I can answer my own question by reading docs that I have to read anyway, so don't bother answering it ;)
05:05:26 <quicksilver> could be a library corruption issue on that machine
05:05:41 <idnar> > (1, 2) < (2, 1)
05:05:43 <lambdabot>  True
05:05:45 * mux wonders if objdump -p would also get an exception
05:06:18 <arossato> anyone experiencing problems with ghc-6.8.1 docs generation?
05:07:13 * ketil can inform mux that objdump appears to work.
05:07:37 <ketil> Anway, I'll pursue this as an OS issue, thanks!
05:07:39 <mux> ketil: do you see anything strange in the dynamic section, for dependencies?
05:08:03 <mux> ketil: look at the NEEDED lines
05:13:55 <ketil> mux: nothing strange, but I haven't checked the availability of the libs (manual ldd :-)
05:14:00 * Cale wonders what the most efficient way would be to turn the hierarchical libraries into a tree of bookmarks.
05:14:20 <quicksilver> Cale: TagSoup!
05:14:23 <ketil> I think I can compile on an old linux-2.4.x host and have things work across the board.
05:14:55 * ketil just loves having a heterogenous set of computers.
05:15:02 <Cale> quicksilver: Perhaps if I can match with the format which firefox exports them in.
05:15:16 <quicksilver> Cale: it's a simple HTML format, I believe
05:15:20 <mux> yeah
05:16:07 <mux> with icons as base64 encoded attributes and stuff
05:19:07 <Soroush83> can't I find all haskell help in a tarball?
05:20:05 <Cale> http://www.haskell.org/ghc/docs/latest/
05:20:05 <lambdabot> Title: Index of /ghc/docs/latest
05:20:11 <opqdonut> i'm coding a foreach :: (Ord a, Monad m) => Set a -> (a -> m ()) -> m ()
05:20:32 <opqdonut> is there a typeclass in the libs for something like this?
05:20:35 <opqdonut> traversable?
05:20:36 <Cale> yes
05:20:55 <quicksilver> but the Ord constraint will bite you
05:21:03 <opqdonut> yeah exactly
05:21:13 <quicksilver> I would just use mapM_ . elemes
05:21:24 <opqdonut> ah, that would do it, thank you
05:21:28 <quicksilver> without the typo, and with correct arguments :)
05:21:33 <opqdonut> yes
05:21:33 <quicksilver> consider 'elems' to be a view
05:21:48 <Cale> I wish Data.Set would use the new type system features and carry the Ord dictionary along with itself
05:22:04 <opqdonut> this is actually my own set implementation :)
05:22:13 <quicksilver> Cale: that's enough to make it traversable, but not enough to make it a monad or an applicative
05:22:15 <opqdonut> but i don't want to mess with existential types or anything like that
05:22:22 <quicksilver> Cale: still, traversable is better than nothing
05:22:22 <Cale> quicksilver: right
05:22:29 <Cale> and it would do in this case
05:22:45 <quicksilver> I don't think you need any fancy type system features for that
05:22:52 <quicksilver> you can do it in pure haskell98
05:22:58 <Cale> It's not too tricky, it is a little fancy behind the scenes though
05:23:03 <Cale> No, you can't.
05:23:14 <Cale> data Set a where
05:23:26 <quicksilver> data SetWithOrdering a = (a -> a -> Ordering, Tree a)
05:23:29 <Cale>   SCons :: (Ord a) => a -> Set a -> Set a
05:23:30 <quicksilver> make the dictionary explicitly
05:23:40 <Cale> Oh, yeah, you could do that.
05:23:53 <quicksilver> and then you can provide a convenience constructor
05:24:03 <quicksilver> mkSet :: Ord a => SetWithOrdering a
05:24:10 <quicksilver> which reifys the Ord dictionary
05:24:42 <quicksilver> :t compare
05:24:44 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:25:01 <quicksilver> mkSet = (compare,Tree.empty)
05:25:09 <quicksilver> well, plus a constructor
05:25:12 <quicksilver> which I lazily left out :)
05:26:30 <quicksilver> I almost don't like typeclasses now
05:26:44 <quicksilver> I think the culture of typeclasses has lead to them being used excessivel
05:26:58 <quicksilver> when just passing around higher order functions is simpler and more general
05:27:43 <mux> I dare say that is not always true
05:27:56 <mux> think Num
05:27:59 <quicksilver> I didn't say it was always true!
05:28:00 <idnar> :t max
05:28:02 <lambdabot> forall a. (Ord a) => a -> a -> a
05:28:03 <idnar> :t maximum
05:28:04 <quicksilver> I said 'excessively'
05:28:05 <lambdabot> forall a. (Ord a) => [a] -> a
05:28:06 <mux> okay, fair enough :)
05:28:10 <quicksilver> not 'always used incorrectly'
05:28:15 <mux> but I atually wasn't referring to that
05:28:19 <quicksilver> typeclasses are great when used for overloading
05:28:22 <integral> @type sortBy
05:28:23 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:28:24 <quicksilver> like Num
05:28:26 <mux> but to the "passing around HOFs is simpler" bit
05:28:45 <quicksilver> yeah
05:28:58 <quicksilver> there are times when an automatic type-indexed dictionary of HOFs is convenient
05:29:03 <quicksilver> Num is a very strong example
05:29:08 * mux nods
05:29:14 <quicksilver> but there are other times when it isn't
05:29:22 <quicksilver> like building Abstract DTs
05:29:24 <mux> and there are times where you could need ten different instances and need to create lots of newtypes etc
05:29:37 <quicksilver> often much more useful to build the Abstract DT by pumping in a few HOFs
05:29:37 <mux> and in that case I agree passing HOFs is much better
05:29:43 <quicksilver> that restricting yourself to one choice per type
05:29:47 <mux> yeah
05:29:50 <mux> I violently agree
05:30:39 <joelr1> good day
05:30:44 <quicksilver> basically: typeclasses for overloading
05:30:54 <quicksilver> not as a generic dictionary passing mechanism
05:31:08 <quicksilver> because in the general case, you want to choose dictionaries more carefully than once per type
05:31:28 <joelr1> what is this called: data Stream a where Stream :: (s -> Step a s) -> s -> Stream a
05:31:53 <mux> yeah, it's bearable when you need two or maybe three different instances for the same type, but when you need more, newtype-ing gets boring :)
05:32:43 <Cale> joelr1: That looks like the datatype which dons and dcoutts were using to implement stream fusion.
05:32:46 <quicksilver> joelr1: a stream?
05:33:09 <joelr1> Cale: right. is this dependent type? GADT? i want to read up more on it
05:33:11 <Cale> joelr1: It's a data declaration in GADT syntax. (but it's not a GADT)
05:33:18 <Cale> er, oh
05:33:26 <Cale> actually it is an existential type
05:33:42 <joelr1> let me paste the full example...
05:33:44 <Cale> So I suppose that's halfway to being a fullblown GADT :)
05:33:46 <quicksilver> joelr1: data ... where is GADT syntax
05:34:10 <joelr1> why use the GADT syntax, though?
05:34:15 <Cale> The type s can be different for each value of type Stream a
05:34:16 <dcoutts> joelr1: where did you see that written btw?
05:34:23 <quicksilver> joelr1: you could alternative write that as data Stream a = forall s . Stream (s -> Step a s) (Stream a)
05:34:26 <Cale> Because it makes existential types easy to read
05:34:33 <hpaste>  joelr1 pasted "data with GADT syntax" at http://hpaste.org/3724
05:34:34 <quicksilver> joelr1: some people think that is a clearer way to write it
05:34:43 <Cale> data Stream a = forall s . Stream (s -> Step a s) s (Stream a)
05:34:52 <joelr1> dcoutts: the stream fusion and constructor specialization papers
05:34:53 <quicksilver> ah thanks
05:35:01 <quicksilver> and sorry :)
05:35:03 <quicksilver> missing s
05:35:18 <dcoutts> joelr1: we didn't write it in GADT syntax so I was wondering where you saw it written like that. I'm interested.
05:35:49 <dcoutts> joelr1: oh, did the constructor specialisation paper use that syntax?
05:35:56 <joelr1> so stream is a constructor that takes 3 arguments where the 1st one is a function?
05:36:05 <joelr1> dcoutts: it uses it as an example
05:36:05 <Cale> yeah
05:36:22 <antisvi1> b
05:36:38 <dcoutts> joelr1: but that paper doesn't use GADT syntax, I've got the published paper here in front of me :-)
05:36:40 <joelr1> Cale: this was a bit baffling to me because normally Stream :: (s -> Step a s) -> s -> Stream a  is a function, right?
05:36:47 <quicksilver> joelr1: exactly
05:36:52 <quicksilver> joelr1: and constructors are functions
05:37:03 <quicksilver> joelr1: so the 'GADT syntax' is where you give your constructors their function type
05:37:09 <quicksilver> instead of writing them 'normally'
05:37:09 <joelr1> dcoutts: i pasted it as written in the constr spec paper
05:37:16 <quicksilver> simple example : Maybe
05:37:21 <quicksilver> data Maybe a = Just a | Nothing, right?
05:37:25 <quicksilver> :t Just
05:37:27 <joelr1> quicksilver: i'm starting to understand, i think
05:37:33 <quicksilver> but Just has a function type,
05:37:33 <lambdabot> forall a. a -> Maybe a
05:37:37 <quicksilver> so I could write
05:37:48 <quicksilver> data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a
05:37:54 <dcoutts> joelr1: ok, I guess the online version of the paper differs from the published one
05:38:09 <Cale> For each value x of type Stream a, there exists some type s such that x = Stream step state stream, where step :: s -> Step a s, state :: s, and stream :: Stream a
05:38:29 <quicksilver> of course, once you unwrap the stream, you have no idea what the type 's' is
05:38:39 <quicksilver> so all you can possibly do wiht it is feed it into the funciton you have
05:38:43 <quicksilver> of type s -> Step a s
05:38:47 <joelr1> quicksilver: that (Maybe) explains the Step data type
05:38:56 <quicksilver> then you get something 'Step a s'
05:39:04 <quicksilver> and you have to go away and look at the Step definition
05:39:07 <quicksilver> to see if that's useful :)
05:39:20 <Cale> of course it is :)
05:39:38 <quicksilver> and, of course, it is :)
05:39:42 <quicksilver> otherwise it would be a bit daft
05:39:50 <quicksilver> Cale: we got it wrong, though
05:39:54 <joelr1> awesome! thank you guys
05:39:57 <quicksilver> Cale: stream only has two parameters, not three :)
05:40:06 <Cale> er, duh, right :)
05:40:08 <quicksilver> Cale: 'Stream a' is the return type, not a third parm
05:40:11 <Cale> yes
05:40:20 <Cale> For each value x of type Stream a, there exists some type s such that x = Stream step state, where step :: s -> Step a s, state :: s
05:40:23 <joelr1> right, my bad. 2 args
05:40:25 <quicksilver> #haskell, where even mistakes are made in stereo!
05:40:27 <hpaste>  dcoutts annotated "data with GADT syntax" with "syntax from the final published version of the paper" at http://hpaste.org/3724#a1
05:40:52 <Cale> what are those �'s?
05:41:03 <dcoutts> copy'paste from a pdf I guess
05:41:25 <Cale> Yeah, I suppose they're supposed to be invisible
05:41:26 <dcoutts> unicode prime chars?
05:41:51 <joelr1> dcoutts: data Step a s = Done | Yield a -- is easier on the eyes. i think i just made yet another amazing haskell discovery!
05:42:03 <quicksilver> yeah
05:42:09 <quicksilver> and now you see that the 's' isn't actually there in Step
05:42:17 <quicksilver> so it "doesn't matter" that you didn't know what it was
05:42:18 <dcoutts> Cale: yes, when one edits the text it appears as s’
05:42:29 <Cale> oh!
05:42:30 <dcoutts> which is a unicode ' ’
05:42:34 <quicksilver> but the "point" was to make sure the seed and the step go together
05:43:41 * joelr1 is reading further
05:43:51 <Cale> Yeah, the existential type prohibits you from doing stupid things with the state values, which are supposed to be part of the representation of the stream and not part of its observable appearance.
05:44:04 <joelr1> i'm having a somewhat easier time coming back to haskell after ocaml, i think
05:44:11 <Cale> Cool :)
05:44:37 <joelr1> i now think i dislike parsec for big grammars, though
05:45:02 <Cale> It can be nice for very large but uniform-looking grammars.
05:45:04 <joelr1> too informal and proper error reporting is difficult
05:45:09 <quicksilver> Cale: it also enables you to make long streams which switch state partway through. Although I'm not sure if that's useful :)
05:45:20 <quicksilver> switch state 'type' that is
05:45:34 <Cale> quicksilver: Probably when concatenating streams.
05:45:49 <quicksilver> well that's what I was wondering about
05:45:54 <joelr1> this is after messing around with haskell objective-c bindings. wolfgang and andre use parsec but the parser chokes on new leopard headers without reporting an error.
05:46:04 <quicksilver> joelr1: I saw your messages
05:46:09 <Cale> joelr1: Oh, do you know Wolfgang?
05:46:19 <quicksilver> vaguely interested in haskell/objc
05:46:22 <joelr1> this would be quite harder with a formal grammar
05:46:23 <quicksilver> but it's not high on my list
05:46:31 <nowhere_man> Hi, I'd like to try Haskell a bit, are there recommended UIs?
05:46:41 <joelr1> Cale: not personally, why? i do "know" a lot of people from email correspondence, though
05:47:00 <Cale> joelr1: Oh, I know him from real life.
05:47:17 <nowhere_man> I'm looking for something preferably with good completion and a REPL if possible
05:47:22 <joelr1> Cale: and?
05:47:37 <Cale> nowhere_man: Well, probably the major two would be Gtk2Hs and wxHaskell
05:47:43 <joelr1> Cale: does his personal appearance or demeanor have an effect on his code? :D
05:48:11 <Liskni_si> wee, hoogle doesn't work :(
05:48:26 <Liskni_si> (links to haddock)
05:48:29 <Cale> joelr1: heh, I don't know, but he's a cool guy. Rather good Haskell hacker.
05:48:49 <Philippa_> joelr1: what's your notion of 'big', OOI? I'd definitely like to have an easy way to pick up things that'd be potentially ambiguous were <|> not left-biased
05:48:51 <Cale> nowhere_man: Oh, that sort of GUI
05:48:59 <ricky_clarkson> nowhere_man: When your code is small, completion is less important.
05:49:14 <joelr1> Cale: he sort of disappeared, imo. i'm used to people replying to emails very quickly, sometimes right away. wolfgang must be very busy because he doesn't.
05:49:15 <Philippa_> and having GHCi in a separate window isn't that big a burden
05:49:24 <quicksilver> nowhere_man: repl = ghci
05:49:24 <Cale> nowhere_man: I think what most people do is keep their favourite text editor open in one window, and a terminal window open alongside it with GHCi.
05:49:28 <quicksilver> nowhere_man: completion = emacs
05:49:29 <joelr1> Philippa_: big for me is the objc grammar
05:49:43 <quicksilver> Cale: or keep ghci open inside their favourite editor :)
05:49:50 <Cale> Yes :)
05:49:58 <Philippa_> joelr1: but no actual boundary as such, just "objc counts as big" - fair enough, I guess
05:50:12 <nowhere_man> ok, thanks
05:50:14 <Cale> Though I don't really like the way that emacs' "terminal emulation" interacts with infinite values.
05:50:23 <Philippa_> I guess one of these years I'll sit down and play with my own arrow-based lib
05:50:53 <quicksilver> Cale: I normally seem to be able to C-c it ok
05:51:17 <Cale> Perhaps I should try it again sometime.
05:52:18 <Cale> Emacs is pretty nice, but it handles certain things in a very unintuitive way for me. (Especially how you're expected to hit tab to indent code after typing some or all of a line)
05:52:49 <quicksilver> ;)
05:52:52 <pjd> Cale: there's a setting for that
05:53:01 <quicksilver> well to be fair that's the haskell-mode rather than emacs itself
05:53:06 <quicksilver> pjd: well, there are particular cases
05:53:12 <quicksilver> pjd: cale and I were talking about 'in'
05:53:21 <Cale> Oh, that was you :)
05:53:30 <quicksilver> pjd: if you have "in" at the start of the line, and hit tab, it will precisely match 'let' in column
05:53:42 <quicksilver> pjd: but if you haven't typed 'in' yet, none of hte options it gives you is that column
05:53:44 <nowhere_man> what is the Haskell way for distributing an application?
05:53:55 <quicksilver> pjd: I'm kind of used to it, but it is a bit odd...
05:53:56 <pjd> quicksilver: ah, i see
05:54:14 <dcoutts> nowhere_man: cabal and possibly hackage if you want to distribute it publicly
05:54:16 <Cale> nowhere_man: Make a cabal package, and you can upload it to hackage or make a tarball or .deb automatically
05:54:54 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
05:55:07 <Cale> (Hackage is just getting started ;)
05:56:00 <Sizur> is cabal-install usable already?
05:56:07 <Cale> yes
05:56:25 <Sizur> i have problems making it work
05:56:29 <Cale> and I'm not sure, but I think it may come with ghc 6.8.1?
05:56:49 <Cale> I'd already had it installed under 6.6.1, so I'm not certain
05:56:56 <Sizur> cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
05:57:03 <Cale> oh, that.
05:57:19 <dcoutts> Sizur: that's a known bug, it'll require an update to cabal-install
05:57:39 <dcoutts> Sizur: last minute changes to cabal before the ghc-6.8.1 release broke cabal-install
05:57:58 <Cale> oh, heh
05:58:10 <Sizur> dcoutts: so if i install from darcs, it should be good?
05:58:23 <Cale> So will there be a 6.8.2 soon which fixes that?
05:58:29 <dcoutts> Sizur: no, it's not fixed yet
05:59:00 <Cale> What's going on in that error message?
05:59:02 <dcoutts> Cale: we don't know the timeframe for 6.8.2 yet, depends on how many bugs we get and think are important to fix
05:59:34 <dcoutts> Cale: when cabal configures ghc it tests if ld supports the -x flag, that uses a temp file in dist/
05:59:47 <dcoutts> Cale: when cabal-install calls the same function, dist/ does not exist
05:59:59 <dcoutts> the solution in cabal is to use the right temp dir
06:00:10 <dcoutts> or for cabal-install to workaround it somehow
06:00:50 <Sizur> dcoutts: so i have to wait, right?
06:01:07 <dcoutts> Sizur: I'm afraid so, or downgrade to Cabal-1.2.1
06:01:48 <dcoutts> cabal-install-0.4.0 built against Cabal-1.2.1 should be ok
06:03:46 * Cale suddenly wonders why his cabal-install is working.
06:05:18 <Cale> Perhaps it's the one which I already had...
06:05:45 <dcoutts> probably
06:06:31 <Cale> Is there something like dons' mkcabal built into the newer versions of the cabal tools, or should he upload that to hackage? :)
06:07:50 <nowhere_man> as I'm wondering how to properly do it with Lisp, I'd like to know if there's any implementation of Haskell that enables the compilation of shared libraries
06:08:09 <nowhere_man> that is, shared objects on Unix and DLLs on Windows
06:09:16 <Cale> mm... I don't think there is.
06:09:58 <pejo> Doesn't GHC do dynamic linking on OSX?
06:09:59 <dcoutts> Cale: it'd be nice to build into Cabal itself wouldn't it? $ cabal init  or something
06:10:16 <dcoutts> pejo: yes, if you tell it to and build your libs that way, it's a tad experimental
06:10:24 <Cale> dcoutts: yes
06:10:33 <dcoutts> Cale: submit a feature request! :-)
06:10:49 <dcoutts> Cale: hackage.haskell.org/trac/hackage/
06:10:58 <Sizur> dcoutts: you were right. building against cabal-1.2.1 fixed cabal-install
06:11:29 <dcoutts> Sizur: feel free to report any other issues you find with cabal-install in the trac (the url I just pasted)
06:12:42 <nowhere_man> mmm, there's even a Haskell tutorial targeted at lispers, that's nice!
06:13:53 <Cale> http://hackage.haskell.org/trac/hackage/ticket/171
06:13:54 <lambdabot> Title: #171 (Add command to automagically create an initial cabal package) - Hackage -  ...
06:15:41 <Cale> nowhere_man: Dynamic linking is one of those things which would be nice, but since Haskell isn't *that* widely used yet, it seems more convenient to statically link things in most cases, so I don't think there's been a major push to implement it.
06:16:44 <Cale> There is however a library called hs-plugins which allows you to link in object code at runtime, and compile and execute Haskell code at runtime in a typesafe way.
06:17:11 <Sizur> dcoutts: eh, now i get "cabal: Truncated TAR archive." is this known too?
06:18:11 <dcoutts> Sizur: no, when does that happen?
06:18:29 * Cale looks at how many more functions he has to write FFI bindings for... ouch. :)
06:18:48 <Sizur> dcoutts: cabal list, or cabal install fake-name
06:19:13 <hpaste>  n00b pasted "writeFile (Urgent please help) " at http://hpaste.org/3725
06:19:13 <Cale> I think I originally wrote my Imlib binding in 2 days, but doing it right and documenting everything takes a good deal longer.
06:19:38 <Cale> n00b?
06:19:46 <dcoutts> Sizur: check ~/.cabal/packages/hackage.haskell.org/00-index.tar see if it's a vaild tar archive
06:19:56 * Cale wonders who hpasted that...
06:19:59 <dcoutts> Sizur: and similarly for the .tar.gz one in that dir
06:20:11 <Cale> oh, banned?
06:20:16 <pejo> Cale, I think the major problem with documentation is that we find it so boring to write, it's not the amount of time. :-)
06:21:32 <pejo> (Compared to the coding that is, documenting something large of course takes a lot of time).
06:23:22 <hpaste>  Cale annotated "writeFile (Urgent please help) " with "explanation" at http://hpaste.org/3725#a1
06:23:26 <Sizur> dcoutts: i've done cabal update, but if the files are bad, can i simply delete them and update again?
06:23:43 <nominolo> hm, how does one debug "internal happy error" ?  note that it happens inside the generated parser, not while running happy
06:23:58 <dcoutts> Sizur: yes, but it's interesting if we're not detecting bad downloads
06:24:25 * osfameron enjoys writing documentation up to a point
06:24:46 <Cale> nominolo: I'm not sure. File a bug against happy?
06:24:59 <dcoutts> nominolo: no idea, sorry. I've only ever got those kinds of errors while running happy, not the generated parser
06:25:05 <osfameron> the best bang-for-buck on a function documentation is "here is a sample function call.  Here is a sample of the data-structure that it returns"
06:25:38 <pejo> osfameron, knowing the assumptions the function makes is kind of nice too.
06:25:51 <Cale> Actually, I'm mostly just copying the C documentation and editing it to apply to the Haskell code, but it still eats up lots of time.
06:26:35 <nominolo> dcoutts, Cale: thanks.  i'm using 1.16.  i'll try upgrading to 1.17 first
06:26:45 <osfameron> pejo: yeah, exceptions thrown etc, when in the flow to use the function etc.  But in terms of something that is bloody easy to do (copy-paste a sample function call from somewhere else, reformat it a bit) there is really no excuse not to do it...
06:29:07 <nominolo> darn, didn't help ...
06:30:38 <hpaste>  n00b annotated "writeFile (Urgent please help) " with "writeFile (Urgent please help) " at http://hpaste.org/3725#a2
06:36:32 <quicksilver> Cale: ghc's static linking would be more useful if it really was
06:36:36 <quicksilver> Cale: but it isn't :)
06:36:48 <quicksilver> Cale: when I build binaries, they reference a copy of gmp which only exists on my machine
06:37:02 <quicksilver> so they can' tbe used by other OSX users unless they also have gmp installed in the same location
06:37:15 <Cale> huh
06:37:36 <Cale> On Linux, they link to the standard location for libgmp
06:38:05 <quicksilver> right
06:38:09 <quicksilver> but gmp isn't standard on OSX
06:38:14 <quicksilver> and I have installed it by macports
06:38:20 <quicksilver> (my ghc is also macports packaged)
06:38:23 <quicksilver> but others might not
06:38:26 <hpaste>  Cale annotated "writeFile (Urgent please help) " with "do this instead" at http://hpaste.org/3725#a3
06:38:42 <matthew_-> with -static -optc-static -optl-static does it still not produce statics?
06:39:25 <matthew_-> I thought that with enough flags, you could pursuade it...
06:39:26 <Cale> quicksilver: doesn't OSX have a common directory to put libraries in? Or are there somehow several of them?
06:39:42 <Cale> Under linux it's easy because it's a mess ;)
06:39:58 <Sizur> dcoutts: tar --list 00-index.tar   just hangs there. nothing's happening. but i can untar it completely. any idea what's wrong?
06:40:18 <matthew_-> add -f ?
06:40:23 <matthew_-> it could be waiting on stdin
06:40:27 <dcoutts> Sizur: try tar -tf 00-index.tar
06:40:39 <Sizur> it shows everything
06:40:39 <Cale> Well, I suppose there can be several under linux as well: /lib /usr/lib /usr/local/lib
06:40:40 <quicksilver> matthew_-: no, that just doesnt work at all :) /usr/bin/ld: can't locate file for: -lcrt0.o
06:41:00 <quicksilver> Cale: the problem is hte separation between doing things 'macos-style' and 'unix-style'
06:41:14 <quicksilver> Cale: 'macos-style' libraries go into /Libraries/Frameworks/
06:41:15 <matthew_-> quicksilver: eek
06:41:25 <Sizur> dcoutts: yes, tar is good, but i still get the error when i do cabal list
06:41:47 <quicksilver> Cale: but then there are several unix layers people use. I use macports which installs its libs into /opt/local/lib; some people use fink which uses /sw/lib
06:42:03 <quicksilver> Cale: and I have no way of predicting which (if any) kind of gmp install another user might have
06:42:06 <Cale> and there's nothing like ldconfig?
06:42:11 <Cale> hmm
06:42:12 <quicksilver> there is
06:42:19 <quicksilver> but Frameworks are different from libraries
06:42:26 <quicksilver> Frameworks are the modern way to do it
06:42:28 <dcoutts> Sizur: and you've tried deleting that file and re-downloading it?
06:42:34 <quicksilver> if I compiled with frameworks, I could bundle the framework with my app
06:42:40 <quicksilver> but macports ghc doesn't use frameworks
06:42:51 <Sizur> yeah, even manually, so cabal update is ok
06:43:07 <nominolo> dcoutts: ok, found it.  that was ugly. it actually was just a normal parse error ...
06:43:22 <dcoutts> Sizur: ok, what is the md5sum of 00-index.tar?
06:43:47 <Sizur> dcoutts: 4493810361088068ed64fed9bbb3a43f
06:43:53 <dcoutts> nominolo: oh, weird
06:44:14 <dcoutts> Sizur: ok, the file is fine. I get the same md5
06:44:28 <hpaste>  nowhere_man pasted "I don't understand why this triggers a compilation error" at http://hpaste.org/3726
06:44:51 <dcoutts> Sizur: so what version of tar & binary did you build cabal-install against?
06:45:03 <dcoutts> Sizur: and on what OS/arch and ghc version?
06:45:34 <quicksilver> nowhere_man: ++ is string concatenation
06:45:38 <pejo> Cale, there's a general mess with how to manage applications under all unices.
06:45:41 <quicksilver> nowhere_man: 0 and 1 aren't strngs
06:46:00 <matthew_-> pejo: s/unices/OSes/
06:46:02 <ToRA> nowhere_man: 1) do you mean !! instead of ++, and 2) are you reading those values as ints or doubles or floats or what (show (read x)) won't work
06:46:16 <nowhere_man> ToRA: yes, I meant !!
06:46:17 <nowhere_man> thanks
06:46:33 <quicksilver> using show and read like that it won't be able to work out the right type
06:46:41 <quicksilver> > show (read ("12.4"))
06:46:43 <lambdabot>  Exception: Prelude.read: no parse
06:46:53 <quicksilver> actually lambdabot has extended defaulting
06:46:55 <ToRA> > show (read "()")
06:46:56 <Cale> > show (read "12.4" + read "6.7")
06:46:57 <lambdabot>  Exception: Prelude.read: no parse
06:46:58 <lambdabot>  Exception: Prelude.read: no parse
06:46:59 <quicksilver> but in ghci that would just be an error
06:47:04 <Cale> > show (read "12.4" + read "6.7" + 0.0)
06:47:05 <lambdabot>  "19.1"
06:47:07 <quicksilver> type ambiguity error
06:47:07 <Cale> hehe
06:47:18 <Cale> > show (read "12.4" + read "6.7" :: Double)
06:47:19 <lambdabot>  "19.1"
06:47:27 <quicksilver> nowhere_man: you can annotate the type you want, as cale just did
06:47:28 <nowhere_man> works like a charm here
06:47:32 <Cale> Also, putStrLn . show = print
06:47:38 <quicksilver> hrm
06:47:42 <nowhere_man> without type annotation
06:47:46 <quicksilver> maybe that defaults to ints?
06:47:48 <quicksilver> odd though
06:47:49 <Sizur> dcoutts: cabal-install-0.4.0 Cabal-1.2.1 ghc-6.8.1 ubuntu-7.04
06:47:51 <Cale> Yes, it will.
06:47:57 <quicksilver> I didn't think it would default any constraint which contains more than just Num
06:47:59 <Cale> It'll default to Integer
06:48:00 <matthew_-> > (putStrLn . show) == print
06:48:01 <lambdabot>   add an instance declaration for (Eq (a -> IO ()))
06:48:01 <lambdabot>     In the expression: (p...
06:48:05 <matthew_-> ;)
06:48:07 <dcoutts> Sizur: how about the tar and binary packages?
06:48:09 <quicksilver> I thought Num =>  defaults to Int, but Num,Read doesn't default
06:48:11 <Olathe> @src print
06:48:11 <lambdabot> print x = putStrLn (show x)
06:48:11 * quicksilver shrugs
06:48:15 <Cale> It defaults in any case which only involves Prelude classes
06:48:19 <Cale> and Num
06:48:23 <quicksilver> ah, intersting
06:48:31 <Sizur> dcoutts: what binary packages? the tars i got from hackage
06:48:32 <Olathe> @pl \x -> putStrLn (show x)
06:48:32 <lambdabot> putStrLn . show
06:48:52 <dcoutts> Sizur: ghc-pkg list binary, check what version it is, same for tar
06:49:02 <matthew_-> Olathe: err yeah, I was kinda taking the piss. Why don't we have Eq on functions...
06:49:29 <Olathe> It might not halt.
06:49:56 <hpaste>  n00b annotated "writeFile (Urgent please help) " with "no" at http://hpaste.org/3725#a4
06:49:59 <dcoutts> Sizur: oh, sorry, they're not needed, my confusion
06:50:40 <dcoutts> Sizur: hmm, ok, so what was the error message again? can you hpaste the full thing?
06:50:42 <dcoutts> @hpaste
06:50:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:50:57 <jacobian_> Whats the simplest parser I can use for haskel written in haskell, given no performance requirements.
06:51:19 <quicksilver> Olathe: can't we check first if it's going to halt? And error "These functions are not comparable. But at least I solved the Halting Problem."
06:51:30 <quicksilver> jacobian_: Language.Haskell.Parser?
06:51:45 <Olathe> Nope.
06:51:47 <matthew_-> quicksilver: that sounds pretty reasonable.
06:52:01 <matthew_-> quicksilver: the types should be annotated with whether or not it'll halt
06:52:01 <quicksilver> jacobian_: doesn't parse every GHC extension, but it's haskell98 + MPTCs + a couple otehr things.
06:52:10 <matthew_-> stochastically, of course
06:52:22 <jacobian_> I only need a tiny subset, so that should work wonderfully, thanks quicksilver
06:52:53 <hpaste>  sizur pasted "cabal list error" at http://hpaste.org/3727
06:53:16 <ac> Haskell doesn't have "here doc" style strings, does it?
06:53:22 <matthew_-> ac: no
06:53:45 <matthew_-> though it's got to be one of the most frequently requested features on here
06:53:54 <ac> yeah, I really like here doc strings
06:54:11 <ac> everybody else has something similar... XML, PHP, Perl, Bash, blah blah
06:54:22 <quicksilver> I despise here doc strings
06:54:25 <quicksilver> use a separate file :P
06:54:33 <ac> quicksilver: lol
06:54:36 <matthew_-> quicksilver: and how do you combine them statically?
06:54:36 * mux seconds quicksilver 
06:54:41 <quicksilver> anything which messes up my column alignment makes me feel physical sick
06:54:49 * mux nods
06:54:56 <quicksilver> matthew_-: why would I bother? who cares? :P
06:54:57 <ac> quicksilver: no reason you couldn't have an indentation aware here doc
06:55:08 <mux> here-docs are an evil tool from satan to break indentation in programs
06:55:08 <quicksilver> ac: true, but that's also ugly in a different way
06:55:23 <matthew_-> quicksilver: you have to ship two files instead of one. You have an external dependency of your binary
06:55:27 <mux> indentation aware here-docs would truly be mind boggling
06:55:34 <quicksilver> matthew_-: if I really did care, I'd preprocess the files to produce haskell code containing the strings :)
06:55:48 <quicksilver> doesn't python have indentation aware here-docs, or did I imagine that?
06:55:54 <quicksilver> if not, some of the markdown languages do
06:56:03 <matthew_-> quicksilver: ok, I was just digging to see if you used my hinstaller package which will do this for you ;)
06:56:09 <quicksilver> ;)
06:56:26 <quicksilver> I just use concat["This is really quite a long ",
06:56:29 <quicksilver> "string"]
06:56:32 <matthew_-> ewwwwww
06:56:37 <quicksilver> or unlines instead of concat
06:56:44 <quicksilver> if that's what I want it to mean
06:56:59 <quicksilver> and that indents nicely and syntax highlights nicely
06:57:06 <matthew_-> hmm. Maybe we should just write a decent internationalization message package to do all this nicely.
06:57:19 <quicksilver> but really huge chunks of text in a program are nasty
06:57:34 <Sizur> you really dont want to have any text in your code or i18n will be hell
06:57:44 <matthew_-> quicksilver: I don't think the position that there should be no text in code is wrong
06:58:02 <quicksilver> if a chunk of text is so large you have started to want here-docs
06:58:10 <quicksilver> then you should think seriously about externalising it :)
06:58:21 <quicksilver> if you also want substitutable here-docs (like in Perl)
06:58:26 <quicksilver> you should htink about a template language
06:58:42 <quicksilver> mind you, I don't think there is a nice lightweight template substitution library for haskell yet
06:58:58 <ac> quicksilver: I see the logic behind that, but there's an opposite etreme of packaging everything in to a big binary source file
06:58:59 <Cale> here-docs always look ugly too, because they break the indentation of the code
06:59:01 <quicksilver> I must have written a dozen in my life. Not in haskell, though, and not 'nice' :)
06:59:06 <matthew_-> text.html.chunks will do, but it's not quite lightweight
06:59:11 <quicksilver> Cale: yes, that was my main argument in fact :)
06:59:25 <matthew_-> it also shouldn't be called html as it's at home without any html
06:59:28 <quicksilver>  < quicksilver> anything which messes up my column alignment makes me feel physically sick
06:59:29 <osfameron> Cale: yes, but they are nicer than every solution except proper templates :-)
06:59:40 <Cale> If there was going to be a here-doc feature in Haskell, I'd want to insist that it preserve the indentation level it's in.
06:59:53 <quicksilver> I'm no big fan of OSX, but I do think they got application bundles right
06:59:59 <quicksilver> in OSX an application is a directory
07:00:03 <osfameron> you could certainly do that (iirc Perl6 heredocs will strip away common indentation level)
07:00:08 <quicksilver> so it can trivially bundle some external files in it
07:00:08 <matthew_-> can someone implement closed classes first, before here-docs ?
07:00:17 <ac> quicksilver: yeah I think that's cool too
07:00:24 <quicksilver> we have closed classes, matthew_-
07:00:26 <matthew_-> quicksilver: that's the same as RISC OS, only about 20 years late then...
07:00:31 <quicksilver> they're called algebraic data types
07:00:33 <quicksilver> matthew_-: right.
07:00:39 <quicksilver> matthew_-: difference is, RISC OS failed.
07:00:40 <Cale> quicksilver: I think every file should be a directory.
07:00:43 <quicksilver> to the victor the spoils, etc.
07:00:50 <quicksilver> Cale: quite.
07:01:00 <pejo> Cale, *every* file?
07:01:07 <Cale> pejo: Potentially.
07:01:07 <quicksilver> matthew_-: next did it too, this is one of OSX's next legacies
07:01:17 <matthew_-> quicksilver: I might point out that Apple have failed as a computer company given their current positioning as a life-style company
07:01:21 <quicksilver> ;)
07:01:24 * quicksilver shrugs
07:01:26 <quicksilver> I'm no fanboi
07:01:29 <matthew_-> ;)
07:01:42 <matthew_-> I meant closed type classes
07:01:50 <quicksilver> I buy their hardware though, because I find it functional and reliable
07:01:54 <Cale> pejo: Initially, looking inside a file would give a directory of metadata.
07:01:56 <ac> Cale: why not have the file system be a sort of more general database? Have you seen lfs, the logical file system?
07:02:01 <quicksilver> yes. A closed type classes has a finite number of members.
07:02:07 <quicksilver> (or at least, "parametrically finite")
07:02:10 <Cale> ac: Or BFS.
07:02:15 <quicksilver> that's what we call an algebraic data type :)
07:03:23 <ac> Cale: the thing is, each application has its own data storage requirements, so allthough I'd be the first to admit the way filesystems work now is pretty uggly, it's also not a bad solution
07:04:01 <quicksilver> simple hierarchical path queries
07:04:07 <quicksilver> (i.e. conventional file systems)
07:04:12 <Cale> ac: Sure. It would be nice however, if, for example, if my web browser wanted to save an HTML document, it could simply include all the images and included files as subfiles of the .html
07:04:13 <quicksilver> are a convenient way to categorise files
07:04:20 <quicksilver> cale is proposing a very small change
07:04:28 <quicksilver> just allowing paths which denote files to also have subpaths
07:04:42 <quicksilver> currently paths are either directories, which permit subpaths, or files, which have contents
07:04:43 <ac> Cale: your web browser can simply have sqlite, or some other library
07:04:53 <quicksilver> this is a very small semantic change
07:04:53 <dylan> or use a directory
07:04:57 <quicksilver> but very powrful
07:05:19 <ac> I suppose I agree that a few very small additions could go a long way to improving things
07:05:42 <matthew_-> quicksilver: http://hackage.haskell.org/trac/haskell-prime/wiki/ClosedClasses
07:05:44 <pejo> ac, but then we need an sqlls, sqlless, sqlrm, and so on.
07:05:44 <lambdabot> Title: ClosedClasses - Haskell Prime - Trac
07:05:45 <Cale> Also, having nicely dynamic extensions of this idea would be great -- running executables could appear to contain other executables for controlling their operation from scripts.
07:05:49 <ac> that would actually be 100% backwards compatible too
07:05:51 <matthew_-> that's what I was meaning
07:06:35 <dylan> sounds like plan 9.
07:06:35 <quicksilver> matthew_-: I did know what you meant, but I was unaware of the haskell' proposal
07:06:40 <ac> after I played with lfs, I realized you have quite a lot of options with the posix filesystem api
07:07:03 <Cale> Or conversions of a file format could be provided.
07:07:06 <quicksilver> matthew_-: I think this is subsumed by GADTs
07:07:12 <matthew_-> quicksilver: I don't
07:07:27 <Cale> For example, inside each .mp3 or .ogg could be a .wav which would automatically decode the file when read.
07:07:35 <quicksilver> instead of class Foo, with a finite number of instances Foo a for types a
07:07:41 <ac> Cale: do you know of any thing that implements something like this?
07:07:53 <Cale> ac: Not in its entirety :)
07:08:01 <quicksilver> you have data Foo a  where { ... finite number of constructors for particular types a .. }
07:08:09 <quicksilver> maybe that's less conveninet, but it's the same thing I think
07:08:10 <Cale> It seems like kind of an obvious idea to me, but it doesn't look like it's been done.
07:08:24 <dylan> reiserfs 4 was supposed  to have features like that.
07:08:26 <pejo> ac, ReiserFS (the next version) wanted to do scary stuff with "plugins".
07:08:34 <quicksilver> Cale: people have written .tar.gz userfses
07:08:45 <Cale> Yes, but I never managed to get that property of Reiser4 to work.
07:08:45 <quicksilver> Cale: that's "kind of" the same idea, but yours is more generic and two-way
07:09:45 <wli> avi is phenomenally general.
07:09:58 <ac> Cale: I'm not sure I like the idea of a file read of a particular path in to calls to an executable
07:10:18 <ac> insert "turning" somewher in that
07:10:19 <wli> It's already in ELF.
07:10:45 <ac> wli: how do you mean?
07:10:58 <wli> .interp's
07:11:07 <quicksilver> ac: unix domain sockets are a bit like that :)
07:11:10 <ac> wli: when does open() turn in to an execution?
07:11:20 <quicksilver> you can connection unix domain sockets to inetd which executes when you open()
07:11:35 <quicksilver> or somethign similar
07:11:57 <ac> quicksilver: sure, but that's implemented in inetd
07:12:17 <wli> THey don't quite do system call hijacking, sorry.
07:12:41 <Cale> another thing which really bothers me is the poor implementation of sparse files on linux
07:13:02 <wli> Varies by filesystem.
07:13:02 <pejo> Cale, 'poor'?
07:13:11 <Cale> Well, the API is lacking.
07:13:32 <ac> Do you mean "cat /dev/zero > foo" shouldn't gobble hard drive space
07:13:38 <ac> ?
07:13:50 <Cale> There's no way for a program to go and zero out part of a file in such a way that causes that to be implemented as a sparse jump.
07:13:55 <wli> xfs has API's for doing special things pertinent to spars files.
07:14:09 <wli> There are hole punching syscalls now.
07:14:09 <Cale> To recompress an existing sparse file, you have to create a complete copy.
07:14:52 <ndm> grr - my department just removed darcs from the server!!!!
07:15:11 <Cale> Yeah, there are sometimes API's for fixed filesystems, but there really should be something more general.
07:15:16 <quicksilver> agreed
07:15:35 <pejo> ndm, how are you supposed to hack on important projects in your sparetime then!?
07:15:41 <wli> The hole punching is the lone generic piece.
07:16:06 <Cale> I happen to have a filesystem in a sparse file which I can't get rid of because it is too large to extract all the files from at once.
07:16:06 * ac considers moving #haskell irssi window off his development workspace
07:16:09 <ndm> pejo: how can i update hoogle or finish my work!
07:16:32 <Cale> (It's larger than half the disk.)
07:16:42 <Notrix> http://www.willamette.edu/~fruehr/haskell/evolution.html <- funny
07:16:44 <lambdabot> Title: The Evolution of a Haskell Programmer
07:16:56 <Sizur> ndm: dont they know that you are spending 10 hours at home after work to be on their completely unrealistic deadline?!
07:16:59 <Cale> So I'm going to have to buy a bunch of blank DVDs and back it all up, I suppose.
07:17:10 <Cale> Notrix: yeah, that's classic
07:17:12 <dylan> Cale: have another computer?
07:17:22 <Cale> dylan: Not one with enough free disk space.
07:17:28 <wli> Cale: Modern 2.6.x has hole-punching syscalls.
07:17:36 <Cale> wli: oh, really?
07:17:40 <Cale> How modern?
07:17:43 <ndm> Sizur: i suspect they don't realise what they've done - it worked at 2pm, they rebooted, and now it doesn't
07:18:11 <wli> Cale: Not sure. I'll check git.
07:19:13 <Sizur> ndm: did you set it for the runlevel in init.d?
07:19:18 <Cale> I'm running 2.6.22
07:20:06 <wli> Cale: It should definitely be there. Now apps already using it, or a convenient libc interface, I can't guarantee.
07:20:34 <Cale> Any idea what the syscall is called?
07:21:07 <ac> wli: what do you mean by "hole-punching"? Haven't heard the term before
07:21:33 <Cale> ac: You know what a sparsely allocated file is?
07:22:35 <wli> Cale: grep -nr punch /mnt/g/linux-2.6/ turns up a lot.
07:23:20 <wli> Cale: NFI WTF the syscall is called offhand.
07:24:32 <matthew_-> quicksilver: I'm not sure the GADT solution allows for the same checks as fundeps and/or type families/synonynms
07:24:41 <Cale> hmm, perhaps madvise
07:24:51 <ac> Cale: I'm guessing a file with large chunks of 0s, like my example above
07:25:13 <Cale> ac: yes, where on disk, those long chunks of 0's aren't written explicitly
07:25:28 <quicksilver> ac: by long tradition, on unix, if you 'seek' to location 1 milllion
07:25:33 <Cale> ac: So you can have a file which is actually larger than the physical device, so long as it's mostly zeroes.
07:25:33 <quicksilver> ac: and write a single 'a'
07:25:47 <quicksilver> ac: that doesn't actually write physical zeros in the first million places
07:25:55 <quicksilver> of course it does depend on filesystem you're using
07:26:08 <quicksilver> but that is true of ufs and ext2s and most traditional unix filesystems
07:26:22 <ac> quicksilver: interesting. never knew that.
07:26:28 <Cale> Ah, it'd be madvise with MADV_REMOVE, but apparently that only works on shmfs/tmpfs.
07:26:31 <quicksilver> files are block allocated, and some blocks can be "missing".
07:26:41 <quicksilver> "missing" blocks are semantically alll zero
07:26:46 <Cale> So it appears it's not quite there yet.
07:26:47 <quicksilver> but don't take space on disk
07:26:47 <ac> quicksilver: then what does stat claim the disk usage is?
07:26:55 <quicksilver> ac: stat shows the logical size
07:26:59 <quicksilver> not the physical size
07:27:13 <quicksilver> in fact, it's quite hard to discover the physical size on some OSes
07:27:17 <Cale> -rw------- 1 root root 160039239680 2007-08-27 18:33 fsimage
07:27:24 <ac> quicksilver: so the only way to get physical size is with some other syscall, like what "df" uses?
07:27:34 <matthew_-> Cale: you just made that number up didn't you? ;)
07:27:39 <Cale> that's not really eating 150GiB :)
07:27:53 <Cale> No, I actually have a file like that.
07:28:19 <Cale> I end up mounting it on loopback every time I boot the system now :)
07:28:53 <Cale> It was part of a failed evil scheme for converting my filesystem in-place.
07:28:54 <wli> Cale: Not sure how it's invoked. I don't see a dedicated syscall stub.
07:29:24 <matthew_-> Cale: I used swap for such schemes
07:29:33 <wli> Cale: I'm guessing some sort of ftruncate() or fallocate() sub-operation buried who knows where.
07:31:03 <mux> there's a way to know about holes in files
07:31:24 <ndm> malcolmw: have you noticed that darcs disappeared from venice
07:31:49 <malcolmw> ndm: oh? I've just got reconnected to venice
07:31:51 <mux> it's a relatively new API coming from Solaris, IIRC, that is, there are new SEEK_HOLE and SEEK_DATA flags for lseek()
07:32:00 <mux> we just added those to FreeBSD
07:32:02 <ndm> malcolmw: now type "darcs"
07:32:11 <yrlnry> Cale: there was something you posted recently on reddit that I liked.  Thanks.
07:32:18 <Cale> yrlnry: what was that?
07:32:25 <yrlnry> I don't remember.
07:32:31 <wli> Cale: madvise_remove() is one way.
07:32:51 <malcolmw> ndm: I see what you mean - mail support!
07:32:57 <ndm> malcolmw: done
07:33:28 <ndm> about 15 mins ago
07:33:44 <wli> Cale: fadvise() does something similar though it's unclear it's equivalent or useful wrt. sparse files.
07:33:45 <yrlnry> Cale: http://programming.reddit.com/info/5zww3/comments/c02dw31
07:33:46 <Cale> We need a new programming reddit.
07:33:46 <lambdabot> Title: programming: How to measure anything with the Pythagorean Theorem (color distanc ...
07:34:23 <yrlnry> I was going to issue almost the same complaint after reading that article, and then I didn't have to.
07:34:31 <holzensp> wow... busy channel... does anybody here use TypeNats?
07:35:08 <Cale> holzensp: Well, I've run across them. I don't use them regularly.
07:35:14 <Sizur> Notrix: that page is a good way to assess your haskelldom. i start to feel dizzy already at Continuation-passing Haskeller
07:35:26 <holzensp> Cale: actually, my question may be about dependent types in general
07:35:26 <wli> Cale: Looks like the only way to invoke it is via madvise().
07:35:33 <Cale> I assume you mean something like  data Zero = Z; data Succ n = S n
07:35:54 <Cale> wli: yeah, and the manpage for madvise says that it only works on shmfs and tmpfs
07:36:05 <mux> what are you doing with madvise() ?
07:36:11 <holzensp> ah, yeah, although TypeNats is actually a concrete library that uses binary encoding data Z, data I a, data O a
07:36:25 <Cale> ah, okay
07:36:29 <yrlnry> What's O for?
07:36:33 <Cale> zero
07:36:33 <wli> Cale: ext4 and ocfs2 have driver pieces for it.
07:36:34 <holzensp> binary zero
07:36:41 <matthew_-> So what's Z for?
07:36:48 <holzensp> end-of-binary-string
07:36:56 <matthew_-> why is that necessary?
07:36:58 <Cale> wli: ah, okay
07:37:03 <quicksilver> so you encode 12 as 1100 or I ( I ( O (O Z)))
07:37:08 <holzensp> there you go
07:37:09 <quicksilver> which is considerably more concise
07:37:12 <holzensp> exactly
07:37:13 <quicksilver> than 12 'Succs'
07:37:14 <matthew_-> oh, sorry, I suck
07:37:16 <yrlnry> Oh, so the number 9 is encoded as I(O(O(I(Z))))?
07:37:20 <quicksilver> right
07:37:28 <yrlnry> n/m, I just saw the example above.
07:37:31 <quicksilver> :)
07:37:41 <wli> Cale: shmfs and tmpfs are the same fs driver, just a backward compat hook or two for sysv ipc and a user-visible fake name mocked up for the shmfs case.
07:37:56 <holzensp> anyway, TypeNats includes all these very convenient classes to help do arithmetic
07:38:01 <holzensp> I actually just want the simple stuff
07:38:09 <holzensp> I want bounded lists, for example
07:38:18 <holzensp> using GADTs that gets to look really nice too:
07:38:24 <matthew_-> holzensp: well that's quite easy
07:38:28 <holzensp> data List t l where
07:38:37 <holzensp> Nil :: List t Zero
07:39:03 <holzensp> Cons :: NatSucc l l' => t -> List t l -> List t l'
07:39:46 <holzensp> where NatSucc l l' says that l' is the successor of l (which is slightly trickier for the binary encoding than for the Z / Sx encoding
07:39:52 <phlpp> hi all
07:40:01 <matthew_-> holzensp: indeed.
07:40:21 <holzensp> using dependent types, TypeNats makes NatSucc unambiguous
07:40:37 <holzensp> i.e.: class NatSucc a b | a -> b
07:40:51 <matthew_-> ja
07:40:57 <holzensp> ;)
07:41:26 <matthew_-> ok, so... ?
07:41:29 <holzensp> I run into trouble when trying to come up with safeTail
07:41:33 <holzensp> safeHead is easy:
07:41:52 <mux> safeHead == listToMaybe
07:42:10 <matthew_-> safeTail :: (NatSucc l l') => List t l' -> List t l
07:42:13 <holzensp> no, that doesn't pass through typechecking
07:42:22 <holzensp> matthew_-:yes
07:42:33 <holzensp> that's the type
07:42:42 <holzensp> safeTail (Cons e es) = es
07:42:50 <holzensp> doesn't come through my typechecker :(
07:43:04 <matthew_-> yeah, um you may need to use a case expression
07:43:19 <holzensp> as opposed to a pattern?
07:43:21 <holzensp> help me out
07:43:30 <matthew_-> some of the weird type class constraints and fundeps only can be safely unpacked in a case statement or let clause
07:43:36 <joelr1> i'm gleeful with joy! leopard makes it unnecessary to parse objective-c headers to generate a cocoa bridge
07:43:44 <ToRA> holzensp: are you trying this with 6.6.1 or 6.8 ?
07:43:53 <matthew_-> it's been a while since I've played with this stuff, but I remember the kinda problems you're dealing with
07:44:00 <ToRA> 6.8 fixed a lot of the propogation of contraints weirdness
07:44:15 <ToRA> or can you @paste some code?
07:44:24 <quicksilver> joelr1: good news! isn't that the opposite of what you said on the -cafe?
07:44:43 <joelr1> quicksilver: 100%. i should reply to that thread
07:44:58 <holzensp> ToRA: 6.6.1 - for some reason 6.8 won't compile for me, complaining about DerivedConstants.h, Ian's looking into it
07:45:08 <matthew_-> holzensp: also, compare what you've got with hlist and/or http://www.wellquite.org/non-blog/sessions-browseable/Control/Concurrent/Session/List.hs as there's similar magic in there (albeit with peano numbers)
07:45:11 <lambdabot> http://tinyurl.com/3e4e2y
07:45:48 <matthew_-> holzensp: in particular, in that url, note the use of decomposeCons
07:45:55 <matthew_-> I think that's dealing with the same issue you've hit
07:46:32 <holzensp> ToRA: the List/safeTail code above already illustrates my problem
07:47:00 <holzensp> matthew_-: thanks, let's have a look
07:47:50 <matthew_-> holzensp: I wrote that code some months ago and I've not done hackery like that for a while now so I might be a bit rusty...
07:49:25 <holzensp> matthew_-: It looks very similar, except for one thing that I was actually hoping to avoid; the Cons t n is actually a type, where n is the complete type of the tail
07:49:42 <holzensp> maybe I shouldn't want to avoid that, per se
07:50:05 <holzensp> but I really liked the idea of type-coding the list-length in a type-natural
07:50:24 <matthew_-> holzensp: yeah, I've just realised mine's quite different - I have a type class to derive the length, but you want to track the length explicitly right?
07:50:48 <holzensp> exactly
07:51:07 <matthew_-> ok, try looking at hlist and see if that does what you want. I can't remember
07:51:13 <holzensp> I toiled with class-level analysis, but that doesn't work for me
07:52:05 <matthew_-> it's quite likely you'll make your life easier if you struggle through with ghc 6.8 - it's much better at this sort of constraint satisfaction stuff
07:53:12 <holzensp> ah, yes, I'm truly looking forward to 6.8, but it simply won't compile, complaining about DerivedConstants.h
07:53:35 <holzensp> I've filed a bug report with Ian, but I've run into this error before when 6.8 was still unstable... same build error
07:54:18 <holzensp> (I can go into the directory where DerivedConstants.h is expected and call make there, which gives me the header file, but going back to the source root and running make again, fails again)
07:54:45 <holzensp> Actually, I'ld really like to forget about dependent types altogether and move directly onto type families.... 6.10, oh, sweet 6.10 :D
07:55:28 <matthew_-> um, I thought they were in, but not really supported
07:56:15 <ac> 6.10 exists already?
07:57:15 <holzensp> nope, but 6.10 is the next stable... 6.8 does indeed have type families, but with no support whatsoever
07:57:44 <holzensp> actually, the only reason they're in 6.8 (IIRC from the ghc mailing list) is that it was too much work to take them out completely
07:57:50 <matthew_-> right, and are type families and type synonynms both in? What does the "no support" actually mean?
07:57:58 <matthew_-> are they known buggy / broken?
07:58:03 <holzensp> and waiting until TFs were stable would postpone 6.8 by many months
07:58:26 <holzensp> AFAIK they're known to be buggy
07:58:38 <holzensp> let me check my ghc archive
07:58:42 <matthew_-> super dooper. so fundeps it is then...
07:59:48 <hpaste>  ToRA pasted "Lists with Type Families ..." at http://hpaste.org/3728
08:00:00 <ToRA> they are buggy / broken ;(
08:02:02 <holzensp> yep, Manuel Chakravarty also noted that the TF implementation in 6.8 is still incompatible with some other language features "most notably GADTs"
08:02:52 <matthew_-> ToRA: well the bug there is simply that "family" is in black and not purple.
08:03:01 <matthew_-> ;)
08:03:07 <ToRA> heh
08:03:14 <ToRA> actually that whole code is a bit stupid
08:03:54 <holzensp> ToRA: yeah, this is slightly easier, because you know the actual (Succ x -> x) relationship... if lengths are not coded linearly... there is a problem
08:04:31 <holzensp> now (NatSucc x y | x -> y) is a class, with x and y types
08:04:50 <holzensp> what I'ld actually like to see is that (NatSucc x y | x -> y, y -> x) or something
08:05:03 <matthew_-> yep. that certainly follows
08:05:11 <holzensp> actually, the whole thing would go away if there was top-down typechecking as well
08:05:41 <holzensp> I asked on the ghc list about why there is only inference (bottom up) and checking
08:06:12 <matthew_-> I take it that if you add the extra fundep, ghc objects?
08:06:37 <holzensp> oh yes
08:07:36 <holzensp> SPJ noted that there are two reasons why there is no top-down checking (I call it unification) yet:
08:08:31 <holzensp> "Partly it's that local constraints makes checking quite a bit harder" [ref: Towards open type functions for Haskell]
08:08:35 <hpaste>  ToRA annotated "Lists with Type Families ..." with "otoh, this works, and is less trivial" at http://hpaste.org/3728#a1
08:09:25 <holzensp> "Partly it's that functional dependencies are much trickier than they look" [ref: Understanding Functional Dependencies via Constraint Handling Rules]
08:10:34 <holzensp> ToRA: Yeah, I guess that were I to port TypeNats to TFs, the problem would disappear as is
08:10:44 <Sizur> anamorphisms, catamorphisms, hylomorphisms, paramorphisms, zygomorphisms, is this all programming?
08:10:52 <mux> yes!
08:10:56 <holzensp> verily!
08:11:00 <Tac-Tics> hardly!
08:11:01 <Tac-Tics> ;-)
08:11:03 <mux> programming with barbed wires, bananas, lenses etc
08:11:09 <Sizur> lol
08:11:21 <holzensp> mux: LOL, I was just typing: so are bananas and bicycles
08:11:22 <holzensp> ;)
08:11:24 <mux> that's the name of a paper about those ana, para, cata morphisms etc
08:11:56 <sw17ch> mux: so is a pealed banana a 0 and an unpeeled a 1? perhaps we can work some quantum state in there with a "maybe" peeled banana
08:12:09 * mux 's head hurts
08:12:20 <holzensp> mux: have a banana
08:12:30 <mux> lol
08:12:31 <Sizur> you mean superposition of 1 and 0, that's not a maybe!
08:12:36 <gour> CosmicRay: hdbc is not ghc-6.8.1 ready (yet) ?
08:12:44 <mux> the Quantum monad
08:12:57 <sw17ch> alright, move it to #haskell-quantumbanana
08:13:06 <holzensp> no no, surely it should be the Quantum arrow!
08:14:15 <Tac-Tics> surely it would have a side effect either way
08:14:34 <matthew_-> you want to throw in Either now too?
08:15:00 <earthy> !sigh gtk2hs
08:15:04 * sw17ch curls up in the corner
08:15:11 <earthy> or, really, !sigh ghc 6.8.1
08:15:19 <earthy> man is that a world of hurt
08:15:21 <joelr1> quicksilver: check haskell cafe for "HOC is dead! Long live HOC!"
08:15:31 <dcoutts> earthy: gtk2hs-0.9.12.1 will be out soon, I'm doing final testing
08:15:42 <mux> yay!
08:15:45 <mux> dcoutts++
08:15:49 <joelr1> dons: how difficult was it to use the ghc-api in yi?
08:15:52 <earthy> duncan: that would be *totally* useful
08:15:53 <holzensp> ToRA: funny you should come up with such a clean 'append'... I actually ran into trouble doing a concatonation of length-typed lists ;)
08:15:54 <earthy> but still
08:16:10 <joelr1> @ask dons how difficult was it to use the ghc-api in yi?
08:16:10 <lambdabot> Consider it noted.
08:16:13 <earthy> the build requirements for gtk2hs are underdocumented
08:16:23 <earthy> (especially the happy and alex parts)
08:16:29 <mux> yeah, how come one needs gtk to build gtk2hs ?!
08:16:43 <holzensp> lol
08:16:44 <earthy> and alex is non-compilable on ghc 6.8.1
08:16:59 <ToRA> holzensp: I think it was just dumb luck. if you try and swap e.g. l with l' in the type sig, or the defn of Sum it all falls apart
08:17:05 <dcoutts> earthy: what would be useful to know and where you would like to see it documented? (happy and alex are not required in the tarball versions of gtk2hs as they include pre-generated lexer/parser)
08:17:19 <dcoutts> earthy: the latest happy and alex on hackage work with ghc-6.8.1
08:17:20 <earthy> dcoutts: I was following the 'developer-version' documentation
08:17:22 <holzensp> try using gtk2hs using gtk-for-mac (the X-window-less flavour)... dread, pure dread
08:17:43 <earthy> plus, the tarball version *does* have configure search for alex and happy
08:17:45 <dcoutts> holzensp: I get the impression gtk without X11 on mac is not ready yet
08:18:00 <dcoutts> holzensp: and unfortunately I do not have access to a mac to test it
08:18:10 <holzensp> ToRA: ah, yes... that's where my unification point becomes relevant; I tried making the successor relationship slightly more clear, but saying this:
08:18:15 <earthy> waitsec, http://www.haskell.org/alex/ does not contain the latest alex?
08:18:16 <lambdabot> Title: Alex
08:18:18 <dcoutts> earthy: where is that dev docs you're referring to?
08:18:46 <holzensp> ToRA: safeTail :: (NatPred l l', NatSucc l' l) => List t l -> List t l'
08:18:55 <holzensp> gets you into non-termination trouble
08:19:00 <ToRA> holzensp: yeah
08:19:03 <dcoutts> earthy: it's not linked from the alex front page, but it is there and it's released on hackage
08:19:05 <CosmicRay> gour: I can't really make it ready until it's released and in Debian
08:19:06 <dcoutts> earthy: http://www.haskell.org/alex/dist/2.2/
08:19:07 <lambdabot> Title: Index of /alex/dist/2.2
08:19:29 <holzensp> ToRA: with unification, it's perfectly decideable
08:19:39 <earthy> hm. yah. hackage is good. all hail hackage.
08:19:42 <holzensp> ToRA: but the inference checker loops infinately
08:19:53 <earthy> but still... hackage does not have good search affordability
08:19:57 <matthew_-> O.o
08:20:11 <dcoutts> earthy: there's an experimental search interface, but it's not that good imho
08:20:21 <holzensp> dcoutts: gtk for mac is definately in a dev phase; they warn about it, too
08:20:27 <earthy> dcoutss: I refered to  http://www.haskell.org/gtk2hs/development/
08:20:27 <lambdabot> Title: Gtk2Hs  Development
08:20:36 <earthy> which does not specifiy the need for alex or happy
08:20:46 <holzensp> dcoutts: so, yes, it was my own fault, surely
08:20:52 <dcoutts> earthy: the configure script looks for alex and happy but they're not required for the tarball versions. I just built on a couple machines that lack alex & happy.
08:20:59 <holzensp> dcoutts: hurt no less for it, though ;)
08:21:06 <dcoutts> earthy: ok, I'll make sure that page is accurate..
08:21:08 <mux> yes, you don't need either alex nor happy to build gtk2hs
08:21:10 <mux> I can confirm this
08:21:18 <gour> CosmicRay: ghc-6.8.1 is released, but probably not in debian
08:21:28 <earthy> mux: configure barfed on it
08:21:32 <CosmicRay> oh, I didn't know it had come out now
08:21:56 <ac> > let f = f in f
08:21:58 <lambdabot>  Exception: <<loop>>
08:22:05 <ac> how does lambdabot deal with that?
08:22:10 <earthy> anyway, I've been busy since 14:30-ish (it's 17:22 here now) to get this going...
08:22:30 <earthy> Too Hard...
08:22:59 <earthy> (and I'm quite the expert... I've got a couple of people here that couldn't follow this in a day, on their own)
08:23:13 <quicksilver> ac: I think compiled ghc deals with that case, although ghci doesn't
08:23:20 <quicksilver> ac: it's known as 'blackholing'
08:23:55 <ac> quicksilver: how does lambdabot deal with the more general case of a non-obvious non-terminating expression?
08:24:18 <mux> it just times out
08:24:25 <holzensp> ToRA: I'm very new to TFs, so I'm not completely up to speed, but don't TF's also have derived instance notions?
08:24:53 <ac> mux: meaning a concurrent process is started?
08:25:16 <mux> ac: a thread, I think
08:25:17 <holzensp> ToRA: as in, is there a way to say that for any x and y, Sum x y is the same type as Sum y x
08:25:30 <ac> mux: ok that's what I figured. it's the obvious solution
08:26:00 <quicksilver> ac,mux: no, a process
08:26:11 <earthy> yaay. succes.
08:26:19 <quicksilver> the haskell RTS isn't powerful enough to guarantee to pre-empt a spinning thread
08:26:28 <quicksilver> lambdabot uses fork()'ed processes
08:26:36 <quicksilver> and, I believe, rlimits
08:27:29 <dons> ?users
08:27:29 <lambdabot> Maximum users seen in #haskell: 424, currently: 386 (91.0%), active: 16 (4.1%)
08:27:29 <holzensp> talking about gtk2hs AND threads/processes... how annoying is it that gtk is non-threaded?
08:27:34 <Sizur> i need the category pill to load all the concepts in my brain
08:27:39 <mux> quicksilver: ah, ok
08:27:41 <quicksilver> holzensp: doesn't annoy me
08:27:42 <mux> yay, hoogle is fixed !
08:27:47 <dcoutts> holzensp: well, we can use Haskell threads
08:27:56 <quicksilver> holzensp: I use openGL quite happily with threads, and it has the same issues as gtk
08:27:56 <mux> cheers to neil
08:27:57 <holzensp> getting to synchronize messages to the graphics thread through the IO monad.... mmmm
08:27:59 <holzensp> that was tricky
08:28:16 <quicksilver> I think synchronising is really easy in haskell
08:28:20 <quicksilver> MVars and Chans make it a doddle
08:28:37 <quicksilver> and really if you're drawing graphics from multiple threads you *do* need to think about synchronisation anyway :)
08:29:06 <holzensp> fair enough... I actually had one thread that did blocking reads on a Chan an every time it read something it did a synchronous postToGUIThread (or what's that function called)
08:29:38 <holzensp> other threads could freely post messages to that Chan
08:30:12 <holzensp> simple enough, right? When message streams got crowded, it kept segfaulting (mousemoved events for example)
08:30:57 <quicksilver> that sounds a bit funky to me
08:31:10 <holzensp> which part?
08:31:18 <quicksilver> why couldn't you deal with mousemoved events in the GUI thread?
08:31:24 <quicksilver> why were you shovelling htem around?
08:31:41 <quicksilver> normally if you can't respond to a GUI event instantly you need to throw it away :)
08:32:03 <holzensp> "instantly" in lazy FP, that's generally what I find to be a hard concept ;)
08:32:41 <holzensp> I was working on a programming environment we use for teaching FP... we taught FP with Amanda in the past, which is a toy-derivative of miranda (it's old, I know)
08:32:55 <dons> huh
08:32:55 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:33:10 <quicksilver> holzensp: well it sounds like too hard a problem for me to grok instantly
08:33:27 <quicksilver> holzensp: for responding to events, I wouldn't use threads. I would always respond to events single-threadedly.
08:33:27 <holzensp> basically, we wanted to be able to have simple graphics and such without having to expose our students to typeclasses and IO monads
08:33:41 <quicksilver> if I wanted to spawn long-running computations then I spawn threads
08:33:49 <quicksilver> which synchronise with the main thread when they're done.
08:34:11 <quicksilver> I can well believe that if you abstract in such a way that people can inadvertently tie slow computations into the GUI thread
08:34:21 <holzensp> our programs look a lot like old Haskell programs, i.e. main :: [inevent] -> [outevent]
08:34:22 <wli> Oh dear. I exposed my monads again. I hope I don't get arrested.
08:34:33 <sw17ch> @src []
08:34:33 <lambdabot> data [] a = [] | a : [a]
08:34:38 <quicksilver> then you can overflow message channels fairly easily
08:34:48 <mux> wli: hahaha :)
08:35:02 <quicksilver> sw17ch: that's pseudocode, by the way :) not valid haskell.
08:35:07 <quicksilver> sw17ch: but it does describe the type
08:35:49 <sw17ch> quicksilver: thanks. i'm trying to describe some stuff to a friend who's even newer to this language than i am
08:35:55 <holzensp> quicksilver: Yeah, I agree, but I wanted to have a "MouseMoved x y" kind of inevent...
08:36:01 <sw17ch> quicksilver: he's pretty smart, and pulls all the stops on the hard questions
08:36:04 <ToRA> holzensp: I'm no expert on TF's...i'm actually just wondering that now - trying to define safeReverse...which is proving problematic
08:36:26 <earthy> now to convert this bit of code from wxhaskell to gtk2hs
08:36:39 <quicksilver> holzensp: it's very hard to abstract the simple hard fact that GUIs are hard :)
08:36:40 <ToRA> holzensp: ghc doesn't understand S l2 ~ Sum l2 (Succ Zero)  :(
08:36:58 <quicksilver> holzensp: in this specific case, that threading, computation, and responsive GUIs are a nest of vipers
08:37:03 <Cale> I find that monads can be taught rather quickly if presented in just the right way, but I can see the attraction of using a nice pure interface for teaching.
08:37:39 <dcoutts> earthy: what code is that if you don't mind me asking?
08:37:53 <mux> I've had a _lot_ of problems trying to explain Haskell to mostly-imperative friends
08:38:19 <earthy> ui for a project at open universiteit nederland that allows students to practice logic assignments
08:38:21 <pejo> quicksilver, the DrScheme gui-stuff was apparently written in student projects.
08:38:29 <mux> the problem is that you tend to use words such as 'laziness', 'eta-reduction', 'monads', 'ADTs' without noticing
08:38:38 <earthy> the wxhaskell ui is not the main ui though
08:38:50 <earthy> the code is also hooked into HAppS and put on the web
08:38:53 <dcoutts> earthy: oh cool
08:39:03 <osfameron> mux: but there is so much to take from FP before needing to get to any of that!
08:39:16 <mux> yeah, I agree
08:39:25 <earthy> http://ideas.cs.uu.nl/exas/proplogic/todnf/nl/index.php#start
08:39:27 <lambdabot> Title: OU Exercise Assistant On-line
08:39:33 <earthy> (sorry 'bout the dutch ;))
08:39:46 <mux> but I couldn't help it :-) now that I have more experience with haskell, I've found that I can explain stuff better to people who are brand new to it
08:39:48 <dcoutts> earthy: you might like to know that we're stealing several of the good api ideas from wxhaskell into gtk2hs
08:39:49 <wli> My imperative friends see one thing and one thing only about the stuff (which they otherwise see as an impenetrable, solid wall of incomprehensibl formulas): code massively shorter than the imperative equivalents.
08:39:57 * earthy does
08:40:05 <dcoutts> earthy: like greater use of attributes, and setting attributes at construction time
08:40:25 * earthy actually intends to get wxhaskell into a much nicer (and maintained) state
08:40:38 <earthy> that has been somewhat sidetracked by me getting a son though
08:40:41 <dcoutts> button <- newButton [ label := "hello world" ]
08:40:51 <dcoutts> earthy: that's a very good reason :-)
08:40:58 <mux> dcoutts: oh, you implemented that yet?
08:41:10 <earthy> but basically I want SWIG to emit Haskell code first
08:41:17 <dcoutts> mux: got the code gen bits done mostly, yes. Not merged yet.
08:41:17 <gour> dcoutts: what do you think about grapefruit idea?
08:41:17 <wli> And they're not looking at quicksort snippets, either. They're looking at full-fledged app codebases. They aren't interested in toys (or, for that matter, examples for their own sake).
08:41:24 <earthy> and I might actually get paid to do that... ;)
08:41:33 <dcoutts> oh, nice
08:41:42 <Cale> Somehow I've gotten fairly good at rearranging things in my head so that when I explain them, I'm not too incomprehensible :)
08:41:48 <gour> earthy: then you would like to make another gui bindings?
08:41:49 <dcoutts> gour: I'm glad people are experimenting with more high level stuff
08:42:15 <Cale> I suppose it must come from dealing with mathematics and the axiomatic approach to things so often :)
08:42:15 <gour> earthy: ie. what's missing in c2hs?
08:43:28 <dcoutts> gour: SWIG is a higher level description of an api than a C header file
08:43:35 <dcoutts> which is both a blessing and a curse
08:43:54 <gour> right
08:44:20 <dcoutts> it means you've got to write the SWIG description and keep it in sync, but it also allows you to describe the interface more accurately. eg C apis tell you nothing about memory management.
08:44:52 <gour> what is missing in c2hs? having sync is nice feature of c2hs
08:45:33 <dcoutts> gour: plenty of stuff that could be added to c2hs
08:45:33 <gour> swig/improved c2hs would bring many more libs to haskell
08:45:35 <mux> I'm missing #const_str in c2hs
08:45:44 <mux> to be able to use C #define's in your code
08:45:49 <gour> and then no more 'lack of libs' argument
08:45:50 <holzensp> quicksilver: ah! I didn't even pose such tight constraints! You didn't hear me say RESPONSIVE gui ;)
08:46:04 <holzensp> quicksilver: non-segfaulting GUI, *that* would be nice ;)
08:46:06 <gour> mux: i'd like #define too
08:46:49 <Cale> I'd really like to have something like the Mathematica frontend but for Haskell.
08:46:54 <holzensp> ToRA: I'll check tonight what I can come up with, especially considering I like the TypeNats approach of non-linear coding of naturals in types
08:47:10 <holzensp> ToRA: the Z/S thing gets tiring when typeing 42 :p
08:47:21 <Cale> (that is, the Mathematica 6.0 frontend with all the dynamic/frp GUI stuff.
08:47:22 <Cale> )
08:50:32 <quicksilver> not sure I understand how holzensp's code was actually segfaulting
08:50:34 <quicksilver> that does sound odd
08:50:42 <quicksilver> but I could imagine a queue overflowing and it all falling apart
08:51:16 <shapr> Good morning #haskell!
08:51:37 <Cale> morning shapr!
08:52:12 <chessguy> hiya shapr, Cale, quicksilver
08:52:43 * shapr boings cheerfully
08:52:56 <shapr> It's a beautiful day for code. Makes me wish I had a laptop so I could code at a coffeshop.
08:53:13 <chessguy> mmm, it's getting cold here. i wouldn't want to be coding outside today
08:53:27 <sw17ch> shapr: i wonder if the asus Eee could run GHC =)
08:53:35 <chessguy> a coffeeshop wouldn't be bad though
08:53:37 <quicksilver> I'm sure it could
08:53:48 <quicksilver> but compiling big programs might be a little slow
08:53:49 <Cale> Rather than a laptop, I wish I had some kind of neural implant which would interface directly with my visual cortex. ;)
08:54:27 <osfameron> yes, but upgrades would be horrible
08:54:32 <Cale> hehe
08:54:32 <ricky_clarkson> Would you type on your chest?
08:54:35 <quicksilver> "The Calinator"
08:54:44 <Cale> ricky_clarkson: nah, just think it.
08:54:59 <earthy> sorry, was afk for a sec
08:55:19 <earthy> basically, I see SWIG as a maintained version of H/Direct
08:55:24 <earthy> and H/Direct is a lot nicer than c2hs
08:55:29 <osfameron> I think eye scanning and brainwave scan, + goggles is a better bet, because of the hardware problem
08:55:34 <Vq^> quicksilver: using mr Gibbard as a keyboard?
08:55:49 <earthy> c2hs provides fairly low level access to the C structs
08:55:52 <earthy> plus, it can't handle C++
08:56:01 <dcoutts> ho ho ho
08:56:03 <earthy> whereas SWIG allows abstraction
08:56:07 <dcoutts> good luck with that C++ parser :-)
08:56:10 <Cale> osfameron: well, you can have external processing hardware, so long as you have good enough ports to your brain :)
08:56:16 <earthy> plus, it already has a C++ parser. ;)
08:56:17 <pierre2> hello haskellers
08:56:21 <Sizur> http://citeseer.ist.psu.edu/293490.html
08:56:22 <Vq^> hello pierre2
08:56:23 <lambdabot> Title: Bananas in Space: Extending Fold and Unfold to Exponential Types - Meijer, Hutto ...
08:56:24 <gour> earthy: so, i was right, qt bindings with swig?
08:56:29 <earthy> gour: exactly
08:56:39 <dcoutts> earthy: definite advantage, the most complex thing about c2hs is the C parser
08:56:45 <earthy> wxhaskell and qt bindings was what I was aiming at
08:56:46 <chessguy> Meijer and Hutton, has to be a good paper :)
08:57:00 <gour> earthy: linspire did not do anything?
08:57:12 <earthy> not that I've seen at least
08:57:20 <earthy> and not that the KDE people know of
08:57:27 <earthy> last I spoke to them
08:58:02 * gour wonder how long it would take (qt bind.)
08:58:13 <gour> ohh, no attacker
08:58:17 <dons> hmm
08:58:35 --- mode: ChanServ set +o dons
08:58:38 <Cale> um
08:58:38 --- kick: ubuntulover was kicked by dons (dons)
08:58:40 <Cale> yeah...
08:58:42 <mrd> apparently he thinks we are using modems?
08:58:48 <idnar> heh
08:58:50 <nowhere_man> thanks dons
08:58:57 <chessguy> nice quick thinking, Cale :)
08:59:07 <Cale> chessguy: I was away from the machine
08:59:08 <dons> Cale: the ban list is full though. can we clear some of those out?
08:59:13 <Cale> dons: probably
08:59:18 --- mode: ChanServ set +o Cale
08:59:19 <chessguy> Cale, i was just amused at your response :)
08:59:31 --- mode: Cale set -b backco!*@*
08:59:38 <shapr> yeesh
08:59:45 <dons> i had to think for about 15 seconds about whether he was in or out of the channel
09:00:04 <shapr> That wasn't nice.
09:00:06 <dons> we should be able to block ctcp to the channel, no?
09:00:10 <shapr> Probably
09:00:48 <jvoorhis> hi
09:00:59 <dons> hey jvoorhis
09:01:02 --- mode: ChanServ set -o dons
09:01:07 <jvoorhis> hi dons
09:01:24 <jvoorhis> would somebody here be happy to explain the ArrowLoop instance for (->) to me? :)
09:01:54 <dons> instance ArrowLoop (->) where loop f b = let (c,d) = f (b,d) in c
09:02:07 <dons> loopy :)
09:02:11 <jvoorhis> for some reason, my brain has trouble parsing that
09:02:21 <jvoorhis> how is d introduced?
09:02:32 <dons> class Arrow a => ArrowLoop a where loop :: a (b,d) (c,d) -> a b c
09:02:52 <Cale> Only about 400 function calls left to write bindings for ;)
09:02:53 <allbery_m> $idiot just hit #haskell-overflow too :/
09:03:15 <quicksilver> jvoorhis: it isn't
09:03:25 <quicksilver> jvoorhis: but if f can produce at least part of d
09:03:30 <quicksilver> jvoorhis: before consuming any of d
09:03:36 <quicksilver> jvoorhis: then, everything is OK :)
09:03:40 <jvoorhis> that makes sense
09:03:51 --- mode: Cale set +b *!i=ubuntu@gateway/tor/x-26e2ccc44e60a27d
09:03:57 <quicksilver> just like let ones = 1 : ones
09:03:58 <jvoorhis> so... i was teaching myself arrows by implementing them in another language that happens to be strict
09:04:00 --- mode: Cale set -o Cale
09:04:02 <quicksilver> you 'need' ones to define ones
09:04:17 <dons> :t loop
09:04:19 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
09:04:45 <Cale> jvoorhis: that instance will be kind of hard to implement in a strict language.
09:04:50 <dons> > loop (\(b,d) -> (1,d))
09:04:51 <lambdabot>  Add a type signature
09:04:58 <dons> > loop (\(b,d) -> (1,d)) 0
09:04:59 <quicksilver> jvoorhis: yeah, arrowloop will require you to loop through some hoops (ahem) in a strict language
09:04:59 <lambdabot>  1
09:05:06 <dons> > loop (\(b,d) -> (d,d)) 0
09:05:07 <lambdabot>  Exception: <<loop>>
09:05:12 <quicksilver> jvoorhis: but the rest of arrow shouldn't be such a problem
09:05:21 <jvoorhis> the rest of arrow wasn't a problem :)
09:05:21 <quicksilver> and ArrowLoop isn't essential to make arrows useful
09:05:37 <quicksilver> you could manually thunk it, as in () => foo
09:05:41 <quicksilver> erm
09:05:43 <Cale> What language are you implementing it in?
09:05:43 <quicksilver> () -> foo
09:05:49 <dons> can you get fix from loop?
09:05:55 <dons> ?src fix
09:05:55 <lambdabot> fix f = let x = f x in x
09:05:59 <Cale> Seems so.
09:06:04 <jvoorhis> quicksilver: that might be the best i can do
09:06:07 <dons> yeah
09:06:13 <ikegami--> Hello
09:06:20 <dons> loop f b = let (c,d) = f (b,d) in c
09:06:29 <ikegami--> I write an extension Emacs-flymake for Haskell
09:06:30 <dons> so that's curious
09:06:41 <jvoorhis> dons: it looks so innocent at first blush
09:06:41 <ikegami--> http://madscientist.jp/~ikegami/diary/20071108.html#p01
09:06:42 <lambdabot> Title: Inemuri nezumi diary(2007-11-08)
09:06:43 <Cale> oh, yeah, that is a little strange
09:06:45 <gour> earthy: did not know that swig is still developed, big list of supported langs, missing haskell
09:06:51 <Cale> hmm
09:07:03 <dons> ikegami--: cool!
09:07:20 <dons> ikegami--: you should announce it on the mailing list
09:07:31 <dons> and add it to the wiki
09:07:38 <ikegami--> :)
09:07:49 <dons> is there an mfix embedding in ArrowLoop?
09:07:58 <bos> dcoutts: ping
09:08:03 <dcoutts> bos: pong
09:08:03 <dons> instance MonadFix m => ArrowLoop (Kleisli m) where
09:08:04 <dons> 	loop (Kleisli f) = Kleisli (liftM fst . mfix . f')
09:08:04 <dons> 		where	f' x y = f (x, snd y)
09:08:17 <dcoutts> bos: good ping time? :-)
09:08:19 <bos> dcoutts: did you ever package up ChrisK's boyer moore doodad?
09:08:22 <bos> :)
09:08:24 <int-e> @karma ikegami
09:08:24 <lambdabot> ikegami has a karma of 0
09:08:53 * bos investigates a gtk2hs build failure
09:08:55 <jvoorhis> ArrowLoop for Kleisli hurts my brain right now :)
09:09:03 <dcoutts> bos: no, not so far, we were going to make an external bytesstring search package and experiment with the api before merging it back into bytestring proper
09:09:20 <bos> dcoutts: yeah, that's what i was asking about :-)
09:09:39 <quicksilver> arrowloop for Kleisli just delegates the knot tying to monadfix
09:09:43 <dcoutts> bos: well, I've got the code, but I've been busy for a couple months with other releases :-)
09:10:01 <dcoutts> bos: ah, I'd like to know about that gtk2hs build failure, I'm doing final testing atm
09:10:10 <bos> dcoutts: i think it's just a packaging bug on my part
09:10:15 <dcoutts> ok
09:10:25 <jvoorhis> quicksilver: thanks, i should probably backtrack and read up on MonadFix
09:10:29 <dcoutts> bos: let me know if you find anything you want changing
09:10:30 <Cale> :t (\f x -> loop (\(u,v) -> (v, f v)) x x)
09:10:33 <lambdabot> forall b t. ((b -> t) -> b -> t) -> b -> t
09:10:38 <Cale> hmm
09:10:52 <Cale> not quite fix yet
09:11:17 <bos> dcoutts: the turnaround time on builds is really long, because the fedora buildbots do each build from scratch in a freshly installed minimal virtual machine
09:11:33 <dcoutts> bos: ah right
09:11:36 <bos> it means the builds are squeaky clean, but you can feel your hair grow while you wait
09:11:40 <Cale> :t flip (\f -> loop (\(u,v) -> (v, f v))) id
09:11:42 <lambdabot> forall d. (d -> d) -> d
09:11:42 <dcoutts> heh
09:11:46 <Cale> there we go
09:12:11 <Cale> > flip (\f -> loop (\(u,v) -> (v, f v))) id (\f n -> if n == 0 then 1 else n * f (n-1)) 5
09:12:13 <lambdabot>  120
09:12:43 <bos> ok, another gtk2hs build off to the races.
09:12:43 <Cale> heh, that has to be the most incomprehensible to C-programmers looking code I've written in a while.
09:13:18 <bos> dcoutts: i'd offer to package up chrisk's string stuff, only i've no time :-(
09:13:49 <dcoutts> bos: I know, we're all busy
09:14:07 <MyCatSchemes> Cale: who kicked your puppy? Why did you just use *flip*!? :(
09:14:39 <shapr> @yow !
09:14:39 <lambdabot> ONE LIFE TO LIVE for ALL MY CHILDREN in ANOTHER WORLD all THE DAYS OF OUR LIVES.
09:14:40 <idnar> hmm, my lhaskell.vim doesn't seem to be functioning properly
09:14:48 <Cale> MyCatSchemes: hm?
09:15:03 <MyCatSchemes> Cale: flip + \ = why>
09:15:04 <MyCatSchemes> ?
09:15:48 <Cale> Oh, I suppose I could have written:
09:15:52 <Cale> > (\f -> loop (\(u,v) -> (v, f v)) id) (\f n -> if n == 0 then 1 else n * f (n-1)) 5
09:15:54 <lambdabot>  120
09:16:02 <Cale> Yeah, that's better.
09:16:43 <mrd> @pl \ x y -> flop y x
09:16:43 <lambdabot> flip flop
09:16:51 <Cale> MyCatSchemes: It has to do with how I derived the code in the first place.
09:17:42 <Cale> I did (\f -> loop (\(u,v) -> (v, f v))), and then wanted to eliminate the clearly unused second parameter, so I just flipped the function and applied it to id.
09:17:49 <gnomnain> :t flop
09:17:51 <lambdabot> Not in scope: `flop'
09:17:55 <jvoorhis> @pl (\f -> loop (\(u,v) -> (v, f v)) id) (\f n -> if n == 0 then 1 else n * f (n-1)) 5
09:17:56 <lambdabot> loop (ap (,) (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) . snd) id 5
09:18:33 <Cale> @pl (\f -> loop (\(u,v) -> (v, f v)) id)
09:18:33 <lambdabot> flip loop id . (. snd) . ap (,)
09:18:39 <EvilTerran> yay for S!
09:19:45 * EvilTerran ponders a @pl variant that uses the X combinator in place of ap, const, id, etc
09:21:00 <bos> dcoutts: actually, is the search code that you have the stuff that chrisk posted?
09:21:37 <dcoutts> bos: I think so, perhaps you can point me at what you're referring to and I can check they're the same
09:22:21 <bos> dcoutts: http://article.gmane.org/gmane.comp.lang.haskell.libraries/7363
09:22:23 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:22:45 <Cale> hmm, perhaps I should be stealing the property library for use in Imlib2...
09:23:51 <Cale> er, attributes
09:25:12 <MyCatSchemes> Cale: fair 'nuff.
09:27:08 <vincenz> lo
09:34:26 <quicksilver> Cale: properties/attributes are a really neat little example of existentials
09:36:00 <salierix> What's constructor specialisation?
09:36:02 <vincenz> quicksilver: how do you formulate them?
09:36:47 <quicksilver> vincenz: http://www.haskell.org/pipermail/haskell-cafe/2007-October/032568.html
09:36:48 <lambdabot> Title: [Haskell-cafe] "with" and "preserving" for local state, http://tinyurl.com/296z3j
09:37:02 <vincenz> quicksilver: gracias
09:37:04 <quicksilver> vincenz: although, that's not quite the version I use in practice
09:37:36 <vincenz> quicksilver: nice :)
09:37:53 <quicksilver> vincenz: in practice, I have added a 'Preserving' constructor as well
09:37:56 <vincenz> quicksilver: I take it HasSetter and HasGetter are MPTCs?
09:37:59 <vincenz> oh nm
09:38:01 <ac> hsplugins is cool
09:38:10 <quicksilver> actually, they're single parameter
09:38:14 <quicksilver> using a cunning trick
09:38:17 <vincenz> quicksilver: how do you specific the property type?
09:38:20 <quicksilver> "higher-kinded single parameter"
09:38:26 <quicksilver> vincenz: the type checker knows :)
09:38:33 <vincenz> quicksilver: where do I find it?
09:38:41 <quicksilver> vincenz: HasGetter and HasStter?
09:38:45 <vincenz> nod
09:38:55 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL-2.2.1.1/Graphics-Rendering-OpenGL-GL-StateVar.html
09:38:57 <lambdabot> http://tinyurl.com/33949t
09:39:03 <quicksilver> they're an absrtaction that sven wrote
09:39:16 <quicksilver> which "commons up" IORefs and open GL state stuff
09:39:23 <quicksilver> they're effectively IO lenses
09:39:31 <quicksilver> but with the possibility of specifying that one is readonly
09:40:43 <vincenz> cute :)
09:40:48 * quicksilver nods
09:40:52 <quicksilver> being able to write
09:41:00 <bos> dcoutts: is the gnomevfs stuff in gtk2hs supposed to work with gnome-vfs2?
09:41:07 <quicksilver> with [lighting := Disabled, Preserving currentColor] $ do ...
09:41:11 <quicksilver> is really nice :)
09:41:18 <quicksilver> feels odd, writing 'hetergenous' lists
09:41:23 <quicksilver> but they arenlt :)
09:41:34 <quicksilver> dcoutts: I think gtk2hs has some similar idiom too?
09:41:36 <dcoutts> bos: It should work with the gnomevfs stuff that comes with recent gnome.
09:41:41 <vincenz> quicksilver: you mean 'preserving'
09:41:49 <quicksilver> vincenz: no, in my version it's a constructor
09:41:50 <vincenz> quicksilver: and erm, 'with' is not the combinator according to the mail
09:41:57 <bos> dcoutts: hmm, it's being silently skipped for me
09:41:58 <quicksilver> yes, I changed it a bit :)
09:42:12 <vincenz> quicksilver: what's the type of that list?
09:42:23 <hpaste>  quicksilver pasted "(no title)" at http://hpaste.org/3729
09:42:32 <quicksilver> vincenz: [LocalSetting]
09:42:34 <dcoutts> bos: it's not in the 0.9.12.1 tarball. I guess you're playing with the gtk2hs darcs version?
09:42:34 <quicksilver> (see pasted code
09:42:44 <vincenz> quicksilver: nasty :)
09:42:53 <quicksilver> nasty.. but nice :)
09:42:55 <vincenz> existentials
09:42:55 <bos> dcoutts: oh! i guess i was
09:43:08 <dcoutts> bos: if you explicitly --enable-gnomevfs then ./configure will fail and tell you why it could not configure gnomevfs
09:43:19 <dcoutts> by default it skips
09:43:32 <vincenz> @type fmap
09:43:32 <dcoutts> bos: but you should be using --enable-packager mode anyway, right?
09:43:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:43:41 <bos> dcoutts: crap. i thought the 0.9.12.1 release was going to be based off darcs head.
09:43:54 <vincenz> oh
09:43:59 <vincenz> quicksilver: preserving has a bit of a misleading nam
09:44:02 <dcoutts> bos: no, off of the 0.9.12 branch, bug fixes and compatible api changes only
09:44:05 <bos> dcoutts: now i need to go back and remove all the darcs-specific changes so the build has a hope of succeeding.
09:44:18 <quicksilver> vincenz: does it? it preserves the value of that thing, and restores it before exit
09:44:21 <Pastorn> @src elem
09:44:21 <lambdabot> elem x    =  any (== x)
09:44:28 <Pastorn> @src any
09:44:28 <lambdabot> any p =  or . map p
09:44:35 <vincenz> quicksilver: hmm, you're right
09:44:39 <vincenz> quicksilver: I was reading it the wrong way
09:44:41 <dcoutts> bos: the spec file for 0.9.12 should work with minimal changes I expect
09:44:44 <bos> ok
09:44:45 <vincenz> quicksilver: the save changes a Preserving into a :=
09:44:55 <dcoutts> bos: do you use --enable-packager-mode btw?
09:45:06 <quicksilver> vincenz: yeah, but that's for restoration purposes :)
09:45:09 <vincenz> nod
09:45:12 <vincenz> yep
09:45:16 <bos> dcoutts: yep
09:45:16 <quicksilver> vincenz: it saves the 'current' value as an :=
09:45:31 <vincenz> yep
09:45:38 <vincenz> very nice :)
09:45:47 <vincenz> but!
09:45:49 <vincenz> user LANGUAGE
09:45:50 <vincenz> not OPTIONS
09:45:51 <vincenz> :)
09:45:54 <vincenz> s/user/use
09:46:13 <dcoutts> bos: ok, btw, do you build the gtk2hs fedora package without opengl on purpose? at my department where we use fedora desktops we had to rebuild the gtk2hs rpm with opengl support turned on so we could use it for our pratical.
09:46:14 <quicksilver> vincenz: there was so much in code doing "foo <- get depthFunc; .... do stuff ... ; depthFunc $= foo"
09:46:20 <quicksilver> vincenz: it was a great relief :)
09:46:31 <vincenz> teaches you to be more precise, even though I wish the page with the datatype used by LANGUAGE was more specific, at times it's very hard to find something (due to odd names and lack of description)
09:46:31 <quicksilver> vincenz: when I wrote that, I couldn't find the right LANGUAGE :)
09:46:39 <quicksilver> I know what it is now
09:46:42 <vincenz> quicksilver: which one did you need?
09:46:44 <bos> dcoutts: i'd enabled opengl and other modules in my newer spec file based on darcs head
09:46:48 <quicksilver> ExistentialTypes
09:46:52 <dcoutts> bos: ah ok
09:46:55 <vincenz> quicksilver: :D
09:47:08 <bos> dcoutts: but i'm reverting those changes now, to get something building at all
09:47:12 <vincenz> quicksilver: GADTs are hard to find :)
09:47:19 <vincenz> quicksilver: it uses a completely different name iirc
09:47:29 <dcoutts> bos: right, leave --enable-opengl though :-)
09:47:39 <bos> dcoutts: *after* i get a basic build going :)
09:47:58 <dcoutts> ok ok :-)
09:48:27 <bos> dcoutts: did you see my earlier link to chrisk's search posting?
09:48:35 <dcoutts> bos: yes
09:48:40 <dcoutts> thanks
09:49:01 <bos> was that the correct code?
09:49:09 <quicksilver> how random. Sun are offering me a $50 restaurant voucher.
09:49:24 <quicksilver> At today's exchange rate, that should just about buy a small glass of diet coke.
09:50:23 <dcoutts> bos: yes, I think so
09:50:31 <bos> dcoutts: ok, cool
09:51:32 <dylan> quicksilver: diet cokes cost 25 pounds?
09:51:43 <quicksilver> dylan: I was just making fun of the exchange rate ;)
09:51:54 <dylan> that's some expensive diet coke, anyway.
09:52:01 <vincenz> quicksilver: would you go into a store if there was a queue to get in?
09:52:29 <ricky_clarkson> quicksilver: jottinger once paid $79 for a glass of water.
09:52:39 <quicksilver> vincenz: no. (what was that about?)
09:52:45 <vincenz> random :)
09:52:51 * vincenz was in NY and saturday there was a queue for the apple store
09:53:01 * quicksilver nods
09:53:09 <ricky_clarkson> quicksilver: Hmm, wrong channel - no jottinger here. ;)
09:53:13 <quicksilver> ;)
09:53:24 <quicksilver> ricky_clarkson: doesn't matter. Still true, I'm sure :)
09:53:35 <dylan> I want to own a retail store and force everyone to wait in a stack.
09:53:54 <MyCatSchemes> Dear dylan:
09:54:11 <MyCatSchemes> AAAAAGH *STABBITY STAB STAB* AAAAAA *STAB* *STAB* *STAB*
09:54:23 <MyCatSchemes> -- yours faithfully, MyCatSchemes.
09:54:33 <vincenz> dylan: arrive last enter first?
09:54:33 <ray> that would be good
09:54:35 <dylan> think of it! the first person to the store on a busy day would have to wait a REALLY long time! :)
09:54:38 <ray> you walk in and get served right away
09:54:44 <dcoutts> earthy: if I gave you a gtk2hs .exe installer would you mind giving it a spin for me?
09:54:47 <vincenz> ray: not true
09:54:52 <vincenz> ray: only if you get lucky with the synchronisation system
09:54:55 <sw17ch> > take 10 $ iterate (\x -> x ++ " STAB!") "STAB!"
09:54:57 <vincenz> don't forget, parallel world and all
09:55:04 <lambdabot>  ["STAB!","STAB! STAB!","STAB! STAB! STAB!","STAB! STAB! STAB! STAB!","STAB! ...
09:55:06 <vincenz> dylan: are you allowed to leave the stack?
09:55:22 <dylan> vincenz: No! that would not be a proper stack disipline!
09:55:25 <MyCatSchemes> > fix (\x->x++"STAB! ")
09:55:27 <lambdabot>  Exception: <<loop>>
09:55:35 <vincenz> MyCatSchemes: won't work
09:55:36 <MyCatSchemes> > fix (\x->"STAB! "++x)
09:55:37 <lambdabot>  "STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STA...
09:55:58 <MyCatSchemes> vincenz: ahhh. fix :: (a -> a) -> a breaks my brain.
09:56:09 <sw17ch> @src fix
09:56:10 <lambdabot> fix f = let x = f x in x
09:56:18 <MyCatSchemes> Does fix work for all lazy data structures? Rose trees and so on?
09:56:29 <MyCatSchemes> sw17ch: oh man that's cool.
09:56:36 <MyCatSchemes> fix (1:)
09:56:46 <sw17ch> > fix (1:)
09:56:47 <MyCatSchemes> > fix (1:)
09:56:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:56:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:56:59 <sw17ch> > fix (1+)
09:57:00 <lambdabot>  Exception: <<loop>>
09:57:02 <MyCatSchemes> > concat $ fix ("b0rk! ":)
09:57:04 <lambdabot>  "b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0r...
09:57:14 <allbery_m> > fix ("STAB! "++)
09:57:15 <lambdabot>  "STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STAB! STA...
09:57:24 <pheaver> heh
09:58:40 <quicksilver> MyCatSchemes: fix works as long as each stage constructs something before it loops, and as long as it 'starts form the right end'
09:58:53 <quicksilver> MyCatSchemes: I.e. as long as your consumer consumes the "early" end first
09:59:49 <Arnar_> > fix my brain
09:59:50 <lambdabot>   Not in scope: `brain'
10:00:44 <ricky_clarkson> :t my
10:00:46 <lambdabot> Not in scope: `my'
10:01:33 <ray> i like "fix error"
10:01:48 <araujo> hello
10:01:57 <MyCatSchemes> > fix (\Node x l -> Node x [Node x l])
10:01:58 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
10:02:09 <sw17ch> > fix (iterate (:1) 1)
10:02:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
10:02:10 <lambdabot>       Expected...
10:02:28 <MyCatSchemes> (\Node x l -> Node x [Node x l])
10:02:40 <MyCatSchemes> :t (\Node x l -> Node x [Node x l])
10:02:42 <lambdabot>     Constructor `Node' should have 2 arguments, but has been given 0
10:02:42 <lambdabot>     In the pattern: Node
10:02:42 <lambdabot>     In a lambda abstraction: \ Node x l -> Node x [Node x l]
10:02:51 <MyCatSchemes> :t (\(Node x l) -> Node x [Node x l])
10:02:53 <lambdabot> forall t. Tree t -> Tree t
10:02:57 <MyCatSchemes> fix (\(Node x l) -> Node x [Node x l])
10:03:07 <MyCatSchemes> > fix (\(Node x l) -> Node x [Node x l])
10:03:08 <lambdabot>  Exception: <<loop>>
10:03:10 <MyCatSchemes> Whoopsy.
10:03:45 <MyCatSchemes> :t (1:)
10:03:47 <lambdabot> forall t. (Num t) => [t] -> [t]
10:03:49 <ToRA> anybody know what other flags you need to derive Data & Typeable in ghc 6.8?  I currently have {-# LANGAUGE DeriveDataTypeable, Generics #-} and am told i need -fglasgow-exts
10:04:06 <MyCatSchemes> @src (:)
10:04:06 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:04:17 <MyCatSchemes> :i fix
10:04:34 <ToRA> perusing ghc --supported-languages doesn't list anything obviously also needed...?
10:04:42 <MyCatSchemes> @hoogle (a->a) -> a
10:04:43 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
10:04:43 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
10:04:43 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
10:04:46 <vincenz> ToRA: there's an easier way to look them up
10:05:03 <vincenz> ToRA: Haskell.Something or Language.Something in the docs has a listing of the entire datatype
10:05:47 <vincenz> ToRA: http://haskell.org/ghc/docs/latest/html/libraries/Cabal-1.2.2.0/Language-Haskell-Extension.html
10:05:49 <lambdabot> http://tinyurl.com/2ftedg
10:07:18 <ToRA> vincenz: that list isn't complete for ghc (e.g. gadts)
10:08:19 <ToRA> i'm just wondering if anybody knows about this as an issue in the specific case of deriving Typable in 6.8
10:08:35 <MyCatSchemes> Ahhhh. Fix never terminates if you give it a function that attempts to pattern match.
10:08:47 <MyCatSchemes> > fix (\x->Node 1 [x,x,x])
10:08:49 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
10:08:59 <allbery_m> well, yes.  tha makes it strict.
10:09:12 <allbery_m> (unless you use ~)
10:09:26 <alexj> @seen igloo
10:09:26 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 2h 15m 46s ago.
10:11:03 <MyCatSchemes> allbery_m: ~?
10:11:05 <eDDDDDer> good evening ;)
10:11:30 <int-e> > fix (\ ~(a, b) -> (1, a+2))
10:11:32 <lambdabot>  (1,3)
10:11:48 <allbery_m> MyCatSchemes: ~ on a pattern match makes it lazy
10:12:08 <MyCatSchemes> So in int-e's example, it isn't bothing to evaluate b because it isn't used?
10:12:17 <shapr> You guys are going through SICP?
10:12:21 <MyCatSchemes> > fix (\ ~(a,b) -> (1,b+2))
10:12:21 <shapr> I might join the effort.
10:12:22 <lambdabot>  Exception: <<loop>>
10:12:25 <MyCatSchemes> > fix (\ ~(a,b) -> (1,a+2))
10:12:26 <lambdabot>  (1,3)
10:12:34 <MyCatSchemes> > fix (\ ~(a,b) -> (b+2,1))
10:12:36 <lambdabot>  (3,1)
10:12:45 <idnar> > fix (\~(Node x l) -> Node x [Node x l])
10:12:45 <lambdabot>  Parse error at "->" (column 19)
10:13:00 <idnar> > fix (\ ~(Node x l) -> Node x [Node x l])
10:13:02 <lambdabot>  Exception: <<loop>>
10:13:23 <MyCatSchemes> > fix (\ ~(Node x l) -> Node 1 [Node x l])
10:13:25 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
10:13:32 <MyCatSchemes> Heee, awesome.
10:13:42 <idnar> ah yes, you need to leave x alone
10:14:03 <idnar> er. that made more sense in my head
10:14:24 <MyCatSchemes> I think l is getting left alone there too, though.
10:14:32 <int-e> > let Node x l = fix (\ ~(Node x l) -> Node x [Node x l]) in length l
10:14:33 <lambdabot>  1
10:14:39 <scvr> > /msg lambdabot > fix (\ ~(a,b) -> (1,a++"c"))
10:14:39 <lambdabot>   parse error on input `/'
10:14:54 <MyCatSchemes> If I understand that right, there's a thunk for l (which is _|_) which gets passed down the tree each time the function is applied.
10:15:02 <scvr> <lambdabot>   parse error on input `/'
10:15:02 <scvr> *** QplQyer (n=jeroen@dD5E09C22.access.telenet.be) has joined channel #haskell
10:15:02 <scvr> <MyCatSchemes> If I understand that right, there's a thunk for l (which is
10:15:02 <scvr> +_|_) which gets passed down the tree each time the function is applied.
10:15:03 <scvr> [1] 13:14 scvr on #haskell (+cnt) * type /help for help
10:15:06 <int-e> (evaluating the 'x' component of the Node fails. The list is fully defined.)
10:15:41 <MyCatSchemes> int-e: what as?
10:15:57 <MyCatSchemes> > let Node x l = fix (\ ~(Node x l) -> Node x [Node x l]) in l
10:15:58 <lambdabot>  Exception: <<loop>>
10:16:03 <MyCatSchemes> > let Node x l = fix (\ ~(Node x l) -> Node x [Node x l]) in length l
10:16:04 <lambdabot>  1
10:16:10 <shapr> @users
10:16:10 <lambdabot> Maximum users seen in #haskell: 424, currently: 389 (91.7%), active: 22 (5.7%)
10:16:15 <MyCatSchemes> Huh. Brainexplodey.
10:16:42 <idnar> MyCatSchemes: l is only one element long
10:16:44 <int-e> MyCatSchemes: the list is [Node x l] .. where l is the same list, and x is bottom.
10:16:47 <idnar> MyCatSchemes: [Node x [...]]
10:17:10 <SideFFect> the teacher answered me (whoever remembers last nite :P)
10:17:12 <MyCatSchemes> > let Node x l = fix (\ ~(Node x l) -> Node x [Node x l]) in head l
10:17:13 <lambdabot>  Exception: <<loop>>
10:17:49 <idnar> > fix (\ ~(Node x l) -> Node x (l ++ [Node x l]))
10:17:51 <lambdabot>  Exception: <<loop>>
10:17:53 <MyCatSchemes> int-e, idnar: how come "head l" doesn't return Node x [Node x [Node x [....?
10:17:54 <idnar> hmm no
10:18:11 <MyCatSchemes> Does it get stuck trying to evaluate x at that point?
10:18:17 <int-e> MyCatSchemes: it does. But x can't be evaluated.
10:18:52 <MyCatSchemes> > let Node x l = fix (\ ~(Node x l) -> Node x [Node x l]) in (\(Node x l) -> True) . head $ l
10:18:54 <lambdabot>  True
10:19:06 <idnar> > let Node x l = fix (\ ~(Node x l) -> Node x [Node x l]); Node x' l' = head l in l'
10:19:07 <lambdabot>  Exception: <<loop>>
10:19:11 <MyCatSchemes> Ah. So provided I keep it from touching x itself, that's fine.
10:19:14 <int-e> MyCatSchemes: so lambdabot fails to print it, it just prints <<loop>> to indicate that it got an exception. ghci would print "Node " and then an error.
10:19:27 * idnar confuses himself some more
10:21:00 <MyCatSchemes> Guh. When I try that in ghci, I get 1 for x and the result of the fix expression for l.
10:21:04 <int-e> MyCatSchemes: implementation wise, (\ ~(Node x l) -> ...) becomes something like (\ t -> let x = (\(Node x' _) -> x') t; l = (\(Node _ l') -> l') t in ...)
10:21:13 <ac> dons: reading "Plugging Haskell In" right now
10:22:00 <eDDDDDer> is there an easy way to define testFunction x >90 = 0 ?
10:22:55 <int-e> MyCatSchemes: hmm. which version did you use? fix (\ ~(Node x l) -> Node x [Node x l]) or  fix (\ ~(Node x l) -> Node 1 [Node x l]) ?
10:23:32 <MyCatSchemes> int-e: ah. I just noticed that, yes. I used Node 1 [Node x l] instead of Node x [Node x l].
10:23:44 <ac> eDDDDDer: the only funky pattern matching there is is "foo n + 1 = ..." if that's what you're asking
10:24:01 <eDDDDDer> that's kinda what im asking for
10:24:09 <MyCatSchemes> Huh?
10:24:25 <MyCatSchemes> How come ghci doesn't lock up the CPU when I ask it for that, anyway?
10:24:32 <int-e> eDDDDDer: do you want  testFunction x | x > 90 = 0  ?
10:24:43 <MyCatSchemes> It blocks, and you need to interrupt it with control-C, but the CPU utilisation stays at 0%.
10:24:52 <eDDDDDer> no, i got two inputs, x and y, and want to get 0 as result if y is >= 90
10:25:10 <int-e> eDDDDDer: ah. testFunction x y | y > 90 = 0  then
10:25:16 <int-e> >= even
10:25:17 <hpaste>  lu_zero pasted "(no title)" at http://hpaste.org/3730
10:25:22 <eDDDDDer> okay! thanks! :)
10:25:48 <ac> couldn't you also say: testFunction x (y + 90) = 0 -- ?
10:26:05 <int-e> are you happy with the Integral constraint you get then?
10:26:21 <ac> I guess you'd say (y + 91)
10:26:46 <int-e> anyway I wouldn't teach (n+k)-patterns to anybody.
10:26:50 <ac> haha
10:27:24 <idnar> @hoogle Node
10:27:28 <lambdabot> Data.Tree.Node :: a -> Forest a -> Tree a
10:27:28 <lambdabot> Test.HUnit.Base.Node :: data Node
10:27:28 <lambdabot> Data.Graph.Inductive.Graph.Node :: type Node
10:27:51 <idnar> MyCatSchemes: it uses 100% CPU here
10:27:59 <idnar> er wait no, that was another process
10:28:39 * idnar scratches his head
10:29:24 <MyCatSchemes> Apparently ghci solved the halting problem in order to be able to not bother running that loop. *scratches skull*
10:29:35 <idnar> maybe it's just running it really slowly ;)
10:30:16 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3731
10:31:26 <int-e> MyCatSchemes: it's a magic trick involving a black hole ;) (more seriously. when ghc starts to evaluate a thunk, it replaces it by a different thunk called a black hole that, when evaluated again, either a) in the threaded RTS, blocks or b) throws an error.)
10:31:44 <bos> dcoutts: ok, gtk2hs is now building cleanly for me
10:31:50 <dcoutts> bos: great
10:32:13 <bos> i'll check and see what modules are not being built now, and enable them
10:33:08 <MyCatSchemes> int-e: so I'll get different behavoir depending on whether or not I use -threaded when compiling that? Cool! =D
10:35:24 <int-e> MyCatSchemes: yep. -O may make a difference as well.
10:36:58 <saturday> @src any
10:36:58 <lambdabot> any p =  or . map p
10:37:27 <saturday> @src elem
10:37:27 <lambdabot> elem x    =  any (== x)
10:40:22 <int-e> MyCatSchemes: hmm. well at least it worked that way with ghc 6.4.2. ghc 6.6.1 is a bit smarter than that. (I don't know what it's doing exactly though)
10:42:25 <matthew_-> @where oleg
10:42:25 <lambdabot> http://okmij.org/ftp/
10:44:19 <alar> is there a named function equal to \f-> \x-> x >>= (return . f)
10:44:21 <alar> ?
10:44:37 <kpreid> @type \f-> \x-> x >>= (return . f)
10:44:39 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
10:44:42 <kpreid> @type liftM
10:44:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:44:55 <kpreid> (== fmap)
10:45:29 <alar> thanks!
10:45:36 <alar> @karma+ kpreid
10:45:36 <lambdabot> kpreid's karma raised to 12.
10:46:10 <kpreid> ls <- lines `fmap` getContents
10:46:14 <bos> liftM is more specific. fmap will work on any Functor instance
10:46:37 <alar> @instances Functor
10:46:38 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:50:40 <ac> what is a "monomorphic value"? I know it's the opposite of pollymorphic, but I don't understand how a specific value could be either monomorphic or polymorphic, or even how a specific type could be
10:54:19 <mattam> [] is polymorphic in that it belongs to multiple types like [Char] and [()], whereas 'a' belongs to Char only ?
10:54:43 <mattam> hi swiert
10:54:52 <dcoutts> ac: you look at the type, if it has any type vars then it's polymorphic
10:54:53 <swiert> hi mattam.
10:55:10 <Soroush83> how can I use a functional language in an impretive language?
10:55:14 <ac> dcoutts: oh, that's simple enough.
10:55:18 <dcoutts> ac: [Char] monomorphic, forall a. [a] polymorphic.
10:55:20 <swiert> mattam: I may be using your Program stuff some time soon.
10:55:31 <mattam> I see we will meet again in a month :)
10:55:33 <mattam> nice
10:55:42 <swiert> Are you going to Estonia?
10:55:51 <mattam> Yep exactly.
10:55:58 <ac> dcoutts: and a "monomorphic value" is a value of a monomorphic type I assume
10:56:07 <dcoutts> ac: yes
10:56:22 <swiert> cool.
10:56:41 <swiert> There are quite a few .nott people going.
10:57:25 <mattam> Yeah, I know that Nicolas comes too.
10:57:35 <mattam> Will conor be there ?
10:57:54 <swiert> mattam: Not entirely sure yet.
10:57:56 <swiert> probably.
10:59:02 <mattam> Maybe I'll talk about some kind of general recursion in Coq there, if I manage to finish the implementation which I'm debugging right now. I'd like to hear from you and Thorsten on this topic.
10:59:31 <swiert> mattam: Thorsten has a few slides online...
10:59:44 <dcoutts> does anyone want to test the gtk2hs-0.9.12.1 on windows for me?
10:59:45 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
10:59:51 <mattam> interesting
11:00:02 <swiert> http://www.cs.nott.ac.uk/~txa/talks/bctcs06.pdf
11:00:12 <dcoutts> it's the new gtk2hs installer that works with ghc-6.6.1 and ghc-6.8.1 ^^
11:00:31 <dcoutts> any willing windows users around? :-)
11:00:39 <swiert> Is really neat stuff. I wrote some of it in Coq a while ago.
11:00:40 <dcoutts> earthy: ping
11:01:06 <swiert> but you kind of need quotient types to do it properly.
11:01:39 <edwinb> I implemented that Thorsten thing in Coq once, I was fed up of being told you couldn't have decidable type checking for dependent types and turing completeness at the same time
11:02:07 <edwinb> so I made an SK calculus evaluator which I wheel out whenever someone asks...
11:03:40 <MyCatSchemes> int-e: oh, heh. let floating FTW. =)
11:06:27 <pejo> edwinb, what is the "Thorsten thing"?
11:06:52 <edwinb> the link swiert mentioned
11:07:20 <edwinb> although "The Thorsten Thing" as some abstract entity is probably very terrifying indeed
11:07:59 <mattam> I see, the usual coinductive interpretation. What would be really neat would be to have these nice quotients to see if you can actually forget about partiality altogether :)
11:08:37 <swiert> Quotients don't let you forget about partiality altogether.
11:09:02 <mattam> Well, I mean if working with them is bearable.
11:09:03 <swiert> You need quotients to make it explicit you don't care how many "Later" constructors there are.
11:09:16 <mattam> Sure you can't forget about them
11:10:33 <mattam> In coq we have this setoid machinery which works relatively well, I suppose a (possibly very) similar solution could be implemented for quotients.
11:11:16 <mattam> But then everything's done at the deductive level, not the computational one.
11:13:19 <mattam> Oh well, there's so much things to do and so little time.
11:13:21 <dons> Cale: sounds like a challenge for a list monad one liner: http://programming.reddit.com/info/602ei/comments/
11:13:22 <lambdabot> Title: programming: Ask Reddit: How to generate lists of unordered pairings of a finite ...
11:13:52 <dons> and anyone else who'd wants to hack..
11:15:38 <olsner> "generate Feynman diagrams for perturbations in quantum field theory."
11:17:21 <Cale> dons: It would be a one-liner if pick was in the List library.
11:17:38 <dons> http://programming.reddit.com/info/602fc/details
11:17:39 <lambdabot> Title: programming: References, Arrows and Categories in Haskell
11:20:41 <Cale> oh, actually
11:20:59 <Cale> hmm
11:21:34 <olsner> hmm.. something like... start with the list of indices, then take all reorderings of the list, split each reordering into a list of pairs (this'd be a good place to swap the paired items so that (b,a) and (a,b) both become (a,b)), sort the list of pairs, then nub the list of sorted lists of pairs
11:22:43 <bos> can haddock not handle code with -fbang-patterns?
11:22:57 <dons> nope.
11:22:59 <dons> :(
11:23:23 <doserj> haddock.ghc will?
11:23:23 <lambdabot> doserj: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:23:25 <dons> yep
11:23:43 <dons> bos, see http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/List/Stream.hs
11:23:44 <lambdabot> http://tinyurl.com/2eavnc
11:23:44 <bos> crumbs. what do i do with code that uses them, if i want to haddock it?
11:23:51 <dons> for __HADDOCK__ examples
11:23:51 <ari> @quote spears
11:23:52 <lambdabot> No quotes match. I am sorry.
11:23:56 <ac> what's "rank-N polymorphism"?
11:24:01 <dons> you ifdef around it
11:24:31 <bos> dons: !
11:25:12 <mrd> ac: foralls inside function types which cannot be lifted up
11:25:27 <mrd> basically, the real polymorphic lambda calculus
11:25:55 <doserj> dcoutts: ping
11:25:59 <mattam> rank-0 is monomorphism, rank-1 is forall a...d. tau, rank-2 is forall a..d. (forall a..d. tau) -> tau... It corresponds to the level of nesting of foralls inside arrows.
11:26:25 <mattam> (where tau has no forall)
11:27:57 <ac> hum. how does it make sense to work around the restriction of needing a monomorphic type by using rank-N polymorphism?
11:28:38 <mrd> because existential types can be encoded in rank-2 types, for example:  (forall a. a) -> tau
11:28:46 <bos> dons: do i need to invoke haddock in some magic way then to get the preprocessed file?
11:29:01 <dons> if you do it via cabal, it will need the CPP flag
11:29:08 <dons> which runs cpp first, caches the result, runs haddock on it
11:30:07 <bos> do i need to set that in the .cabal file, or in OPTIONS_GHC?
11:30:26 <ac> mrd: uh, existential types?
11:30:58 <alar> is it easy to add user state to a hand-made monad that lives in IO monad by monad transformers?
11:31:14 <bos> alar: easyish, yes
11:31:37 <alar> or tampering with source code of original monad is preferable?
11:31:52 <bos> no, monad transformers are usually preferred
11:32:08 <bos> you end up with more reusable code that way
11:32:31 * bos cries. why are haddock and cabal not getting along?
11:32:38 <alar> yes, because I'll have original library, not my own custom modified variant
11:34:47 <bos> ah, it has to be "Extensions: CPP". eee-yeugh.
11:39:58 * alar dives into wonderful wild world of monad transformers
11:43:44 <dcoutts> doserj: pong
11:43:44 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:44:04 <doserj> ^^^ :)
11:44:26 <dcoutts> yep
11:45:12 <alar> @seen bringert
11:45:12 <lambdabot> I saw bringert leaving #ghc and #haskell 1d 9h 42m 28s ago, and .
11:45:52 <alar> hm, there are 2 different lambdabots in different channels
11:46:03 <alar> @version
11:46:03 <lambdabot> lambdabot 4p575, GHC 6.6 (Linux i686 2.66GHz)
11:46:03 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:46:58 <dons> alar: there is, yes.
11:47:03 <dons> due to limits imposed by freenode
11:47:42 <vincenz> Hi dons
11:47:46 <dcoutts> bos: or help waern to get haddock-2.0 working reliably, it can parse everything that ghc can so of course can handle ! patterns
11:48:05 <bos> dcoutts: wish i had time :-(
11:48:13 <dcoutts> aye
11:48:43 <dcoutts> dons: could a single lambdabot make multiple connections and thus share the state at least?
11:49:06 <dons> quite possibly
11:49:22 <profmakx> @info lambdabot
11:49:22 <lambdabot> lambdabot
11:49:26 <profmakx> arx
11:49:30 <profmakx> sry
11:51:10 <bos> oh wow, haddock is sensitive to the order in which headers appear when documenting a module.
11:51:34 <bos> it has to be module,copyright,license, not module,license,copyright
11:52:17 <waern> bos: that means authors has to do less decision-making :)
11:52:39 <dcoutts> but they need to know the order
11:52:45 <astrolabe> @paste
11:52:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:52:49 <waern> mm :/
11:52:54 <dcoutts> would be nice if that were relaxed, or made more explicit in the syntax
11:53:41 <dcoutts> some explicit markup for meta data like that, or just take that info on the command line and cabal can pass it from the info in the .cabal file
11:53:45 <hpaste>  astrolabe pasted "unordered pairings" at http://hpaste.org/3734
11:54:04 <astrolabe> It isn't a one-liner (or close), but it seems to work.
11:54:18 <astrolabe> dons, cale ^^^^^^ any improvements?
11:54:54 <dons> nicee
11:54:59 <waern> dcoutts: right, command line args for those fields would be good
11:55:50 <Cale> astrolabe: looks good to me
11:56:07 <Cale> astrolabe: except that main isn't an IO action there ;P
11:56:20 <astrolabe> Cale: thanks :)
11:56:59 <doserj> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/172
11:57:01 <lambdabot> Title: #172 (cabal-install segfaults) - Hackage - Trac
11:57:30 <vincenz> astrolabe: what happens when you have [1,2,3]
11:57:42 <dcoutts> doserj: thanks
11:58:43 <dcoutts> doserj: is the ghc version in that bug report accurate? 6.6 on linux? what arch?
11:59:03 <olsner> vincenz: the problem assumes that the list contains an even number of elements
11:59:08 <Cale> vincenz: the input is guaranteed to be an even list
11:59:12 <dcoutts> doserj: ah, that list doesn't have 6.6.1 or 6.8.1 available :-(
11:59:16 <vincenz> ok
11:59:31 <doserj> yes, but it is actually ghc 6.6 :)
11:59:34 <dcoutts> doserj: perhaps you can annotate that report with the os, arch and ghc version.
12:00:23 <dcoutts> doserj: and if possible, the version of the zlib C library would be interesting info
12:00:42 <dcoutts> doserj: I'm assuming it's a problem in the zlib binding package
12:00:51 <doserj> me too
12:01:11 <dcoutts> doserj: perhaps later when I've got a little time I can get you to try a zlib test case
12:01:38 <vincenz> > let group n = (takeWhile ((== n) . length) . map (take n) . iterate (drop n) in pairs = map (\[a,b] -> (a,b)) . group 2 in pairs [1..6]
12:01:39 <lambdabot> Unbalanced parentheses
12:01:48 <vincenz> > let group n = takeWhile ((== n) . length) . map (take n) . iterate (drop n) in pairs = map (\[a,b] -> (a,b)) . group 2 in pairs [1..6]
12:01:48 <lambdabot>  Parse error at "=" (column 86)
12:01:55 <vincenz> > let group n = takeWhile ((== n) . length) . map (take n) . iterate (drop n) in let pairs = map (\[a,b] -> (a,b)) . group 2 in pairs [1..6]
12:01:57 <lambdabot>  [(1,2),(3,4),(5,6)]
12:02:28 <vincenz> astrolabe: pairs [] = [] not [[]]
12:04:05 <vincenz> astrolabe: and
12:04:10 <vincenz> > split 2 [1..6]
12:04:11 <lambdabot>  Couldn't match expected type `[t1] -> t'
12:04:16 <vincenz> > splitAt 2 [1..6]
12:04:17 <lambdabot>  ([1,2],[3,4,5,6])
12:04:24 <vincenz> take2 == splitAt 2
12:04:58 <vincenz> or did I misunderstand the problem formulation?
12:05:06 <Notrix> we do haskell in belgium ?
12:05:21 <Notrix> that's cool
12:05:26 <vincenz> Notrix: I'm in belgium
12:05:43 <Notrix> where ?
12:05:45 <vincenz> leuven
12:05:53 <Notrix> at university ?
12:05:57 <vincenz> no, at imec
12:06:00 <vincenz> but also at uni
12:06:22 <Notrix> doing a phd ?
12:06:26 * vincenz nods
12:06:36 <Notrix> nice :)
12:06:40 <hpaste>  olsner pasted "yet another unordered pairings" at http://hpaste.org/3735
12:06:47 <vincenz> Notrix: you?
12:06:53 <Notrix> civil engineering in computing i guess ?
12:06:57 <vincenz> leuven?
12:07:02 <Notrix> no london
12:07:18 <Notrix> but I live in brussels
12:07:27 <vincenz> So you go up and down?
12:07:34 <Notrix> yeah
12:07:37 * vincenz winces
12:07:40 <Notrix> well i'm studying in london
12:07:48 <vincenz> oh
12:07:49 <vincenz> EU brat?
12:08:02 <Notrix> you mean erasmus ?
12:08:10 <vincenz> no, as in your parents work for the EU?
12:08:18 <Notrix> ah no
12:08:20 <vincenz> ok :)
12:08:41 <Notrix> you are doing a phd in which subject ?
12:08:42 <scvr> I'm playing with the stupid widefinder project and can't remember where the test data files that bray posted are.
12:09:19 <vincenz> Optimizations for embedded systems
12:09:45 <Notrix> hehe, sounds interesting
12:11:13 <kscaldef_> scvr: yeah, they're buried in a comment on one of the articles.  It's a pain to find them
12:11:35 <astrolabe> vincenz: take2 returns all possible ways to remove two elements.
12:11:47 <vincenz> astrolabe: oh, I see
12:16:21 <doserj> dcoutts: ticket is updated with some ltrace output.
12:16:26 <dcoutts> ta
12:18:52 <dcoutts> doserj: can you confirm for me, by looking in /usr/include/zlib.h that #define Z_STREAM_ERROR (-2) ?
12:19:41 <doserj> confirmed
12:19:54 <dcoutts> thanks
12:20:33 <doserj> "not a valid compression level" ?
12:21:24 <dcoutts> hmm, the zlib.h doesn't say why inflateInit might return Z_STREAM_ERROR
12:22:50 <doserj> true.
12:23:23 <dcoutts> doserj: so we probably want to get a minimal test case using just the zlib package
12:24:18 <swiert> mattam: how do you kill off an impossible branch with Program?
12:24:52 <dcoutts> doserj: and possibly recompiling the zlib code with more debug checks, eg printing the return status of inflateInit, since we should not be doing anything if inflateInit2 returns <0
12:25:33 <dcoutts> doserj: if you want to help debug it, darcs get --partial http://code.haskell.org/zlib/
12:25:36 <lambdabot> Title: Index of /zlib
12:25:48 <dcoutts> and see Codec/Compression/Zlib/Stream.hsc in particular
12:26:25 <doserj> dcoutts: maybe, but definitely not today :(
12:26:33 <dcoutts> in inflateInit we call isFatalError and throwError, but it'd be interesting to stick in some debug print statements there to see what is really happening
12:26:37 <dcoutts> doserj: sure, np
12:26:59 <dcoutts> doserj: I'm pretty busy today too. I think we've narrowed it down quite a bit though so thanks.
12:27:43 <dcoutts> doserj: I'm betting on it being a difference in the way the zlib C lib works between 1.1.4 and 1.2.3 and possibly some incorrect error handling in the zlib binding code.
12:38:20 <nominolo> @users
12:38:20 <lambdabot> Maximum users seen in #haskell: 424, currently: 403 (95.0%), active: 17 (4.2%)
12:41:52 <nominolo> @yawn
12:41:53 <lambdabot> Maybe you meant: wn yarr yow
12:45:43 <bos> dcoutts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stringsearch-0.1.1
12:45:45 <lambdabot> http://tinyurl.com/39x93y
12:47:07 <bos> http://darcs.serpentine.com/stringsearch/dist/doc/html/stringsearch/
12:47:08 <lambdabot> http://tinyurl.com/2dlop4
12:50:14 <ac> I'm curious if there's a library (perhaps a newer version of hsplugins) that does what hsplugins does but starts with a string containing source code, or maybe an AST, rather than a file
12:50:47 <mrd> hsplugins has an "eval"
12:51:17 <ac> I have not looked carefully at hsplugin's API (obviously I should before I start asking questions). I just read the paper
12:52:00 <dcoutts> bos: cool, thanks.
12:52:21 * thoughtpolice finally released the new version of his irc bot
12:52:32 <ac> (which is 3 years old :P)
12:52:34 <thoughtpolice> hopefully I can get some criticisms on -cafe this time 'round :(
12:53:09 <ac> thoughtpolice: what kind of bot is this? I'm actually just thinking about starting one :P
12:53:28 <swiert> ac: try looking into the ghc API.
12:53:46 <swiert> http://haskell.org/haskellwiki/GHC/As_a_library
12:53:47 <lambdabot> Title: GHC/As a library - HaskellWiki
12:54:03 <mrd> there's runStmt in the GHC API but good luck getting a result out of it
12:54:13 <swiert> (Disclaimer: I've never used it)
12:54:27 <ac> doesn't sound promising
12:54:34 <scvr> @@ @run concatMap (replicate 2) $ (@show @yarr)
12:54:35 <lambdabot>  "II  hheeaarrdd  aannddeerrssccaa  iiss  aa  ppiirraattee"
12:55:17 <mrd> @show
12:55:18 <lambdabot> ""
12:55:21 <thoughtpolice> ac: it's a small, plugin based irc bot
12:55:26 <mrd> @@ @run @yarr
12:55:27 <lambdabot>   parse error on input `}'
12:55:29 <thoughtpolice> it does hot code loading; I wanted to try something after I read the yi paper
12:55:32 <ac> thoughtpolice: guess why I'm reading about hsplugins?
12:55:36 <mrd> @@ @run (@show @yarr)
12:55:37 <lambdabot>  "Ahoy mateys"
12:55:42 <Tobsan> lol
12:55:55 <thoughtpolice> worked really, really well actually.
12:55:56 <mrd> yea i wrote an IRC bot with dynamic bootstrapping plugins too
12:56:03 <ac> thoughtpolice: "yi paper"?
12:56:12 <thoughtpolice> ac: dons paper on fully-dynamic applications
12:56:18 <thoughtpolice> it takes the same approach described in the paper
12:56:29 <thoughtpolice> like 95% of it is dynamic. there's only Main.hs that isn't.
12:56:31 <ac> thoughtpolice: ahah. that's a paper I need to read
12:56:35 <thoughtpolice> everything else can be changed at runtime
12:56:56 <thoughtpolice> ever since it first worked properly, it worked really well. i was running it for hours changing things and modding it and it all worked beautifully
12:57:04 <ac> thoughtpolice: I was going for a design like that myself. My stumbling block was getting the loaded modules to use each other
12:57:11 <thoughtpolice> and it's undeniably a lot cleaner than the last version,
12:57:11 <ac> thoughtpolice: though that's not essential
12:57:15 <mrd> do you handle datatype changes
12:57:21 <mrd> 'cause that's tricky
12:57:31 <phlpp> can lambdabot proof something like: f'(x) == 3 / sqrt (12*x + 10) where f(x) = sqrt(3*x+5)?
12:57:34 <phlpp> would be cool :>
12:57:37 <thoughtpolice> mrd: no, I wanted to, but I figured what I had now was sufficient for the 0.3 release
12:57:47 <thoughtpolice> and plus I kind of got 'forced' to release it by some definitions of the world.
12:58:11 <thoughtpolice> when I installed ghc 6.8.1, it seemed to fiddle with some of 6.6.1's settings (causing 6.6.1 to not detect packages that I installed for it)
12:58:19 <ac> thoughtpolice: how do two portions of dynamic code know about each other?
12:58:32 <shapr> ac: jabber?
12:58:39 <ac> thoughtpolice: actually, just give me a link to the paper
12:58:44 <thoughtpolice> ac: not sure if i'm following you. :(
12:58:46 <thoughtpolice> ac: just a sec,
12:58:53 * shapr throws binary encoded xml at ac
12:59:03 * ac runs away
12:59:10 <thoughtpolice> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
12:59:10 <lambdabot> Title: Dynamic Applications From the Ground Up
12:59:23 * shapr grins
12:59:24 <ac> thoughtpolice: where can I grab your code from?
12:59:33 <thoughtpolice> ac: http://code.haskell.org/infinity/src/
12:59:34 <lambdabot> Title: Index of /infinity/src
12:59:37 <thoughtpolice> that's the darcs
12:59:40 <ac> excellent
12:59:47 <thoughtpolice> you can get it from hackage too; just uploaded it
13:00:14 <thoughtpolice> like I said though I hope I'll get some criticisms. I know I probably did some dirty stuff in there and I want feedback. maybe I just don't write interesting stuff. :(
13:00:47 <thoughtpolice> but once I find a suitable replacement for hs-plugins or it's upgraded to accomodate ghc 6.8.1, I can start working on it again. I already have ideas about what I might want in something like an 0.4
13:00:50 <ac> you won't be getting criticisms from me, I'm not exactly an experienced Haskeller. You might get some compliments though
13:01:28 <thoughtpolice> ac: the whole idea is really simple, the only tricky part I really had was synchronizing the threads when you give the bot a "@reboot" command
13:01:54 <thoughtpolice> so that caused some faulty hangs at first. after that was down and threads closed properly, everything worked like pie.
13:02:50 <thoughtpolice> ac: but even if you're not too experienced the code should not be very hard to follow at all. i'm not exactly a haskell guru by any means, this was just something I hacked on in spare time over the past month or two
13:03:11 <thoughtpolice> there aren't many comments, though.
13:03:39 <ac> thoughtpolice: I was planning on running modules in a separate thread, and checking if they take too long to run. Are you doing anything like this?
13:04:08 <ac> That way you could add modules with infinite loops, and not have your whole program crash irretrievably
13:05:36 <thoughtpolice> ac: no; the basic way is when the dynamic app starts it first connects to all servers, and then jumps to a second function which takes a data structure and starts up a thread for each server, and finally goes into a 'monitor' loop which monitors reboot messages, when servers quit, etc..
13:06:04 <thoughtpolice> there currently isn't much checking as to how long a plugin takes to complete, so I suppose if you've got a faulty plugin, it might hang some.
13:06:19 <thoughtpolice> well, just hang, I guess.
13:06:38 <thoughtpolice> ac: there're only like 3 plugins that're in the repository though
13:07:06 <thoughtpolice> one that shows how plugins can save state (data.binary,) one that just does hello world and a third one that has commands like join, part, version and list.
13:07:17 <thoughtpolice> the only commands that aren't implemented in plugins (or shouldn't be) are quit and reboot
13:07:33 <joelr1> evening
13:07:53 <joelr1> is there such a thing as memory-mapped arrays in haskell?
13:07:59 <joelr1> ghc, sorry
13:08:02 <thoughtpolice> and I can't exactly expand too much now since I can't test any changes at all. :(
13:08:23 <ac> thoughtpolice: why not?
13:08:40 <ac> thoughtpolice: also, does this require 6.8? I'm still on 6.6
13:08:49 <thoughtpolice> ac: no, it actually can't build with 6.8 as of current
13:09:13 <thoughtpolice> the -cafe posting should clarify as to why I can't work on it as of right now (so I was kind of 'forced' to release it) and why you can't use 6.8:
13:09:25 <thoughtpolice> http://www.haskell.org/pipermail/haskell-cafe/2007-November/034215.html
13:09:27 <lambdabot> Title: [Haskell-cafe] ANN: infinity 0.3, http://tinyurl.com/26sgy4
13:09:30 <joelr1> dons: ping
13:09:32 <waern> why doesn't hs-plugins work with 6.8 btw?
13:09:54 <thoughtpolice> waern: hs-plugins breaks really easily because it depends on things like .hi file formats, which can change pretty radically inbetween ghc releases.
13:10:10 <joelr1> thoughtpolice: didn't dons move to ghc-api in yi?
13:10:16 <thoughtpolice> joelr1: yeah he did.
13:10:23 <waern> thoughpolice: hmm ok
13:10:34 <joelr1> thoughtpolice: i was gonna ask him about it. did you check it out? does it look easy?
13:10:43 <thoughtpolice> joelr1: I have a library that somewhat wraps the functionality
13:10:50 <thoughtpolice> I released it on hackage a while ago
13:10:51 <andyjgill> @see shapr
13:10:51 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 11m 27s ago.
13:10:55 <thoughtpolice> if I could use it for my bot, i would,
13:11:01 <shapr> andyjgill: You called?
13:11:12 * shapr boings cheerfully
13:11:23 <joelr1> thoughtpolice: why can't you?
13:11:27 <shapr> It's a great day for code!
13:11:33 <joelr1> hey shapr
13:11:39 <thoughtpolice> joelr1: the bot depends on hs-plugins unload facilities to unload modules from memory,
13:11:42 <shapr> hiya joelr1
13:11:56 <joelr1> thoughtpolice: oh, so you can't unload using ghc-api?
13:12:02 <thoughtpolice> currently, with my lib and the ghc-api, even if a module is loaded into a session and you create a new session with the same module, you'd think it'd cause a reload, but it doesn't
13:12:07 <ac> thoughtpolice: ah I had the same problem with libraries from different versions of ghc conflicting
13:12:53 <thoughtpolice> joelr1: but aside from that one main limitation, it works alright as a library for doing dynamic plugins
13:13:03 <thoughtpolice> and that one thing is the only reason I can't use it for my bot.
13:13:22 <waern> thoughtpolice: maybe you can look into GHC.hs and try to solve that problem?
13:13:38 <waern> the api in such a flux that they probably welcome any improvements
13:13:39 <thoughtpolice> also, because I use the ghc-api's dynCompileExpr to compile values to dynamics, there's a typeable constraint, and therefore, what you want to call into has to be of monomorphic type
13:14:07 <thoughtpolice> you can mitigate that by some extent by wrapping the value in a data type or newtype and deriving typeable, though
13:14:34 <thoughtpolice> waern: actually there does look to be a primitive for unloading inside compiler/main/GHC.hs, but it isn't exported.
13:14:36 <ac> thoughtpolice: now I'm confused: are you using hsplugins or ghc-api? Are they exclusive?
13:14:46 <thoughtpolice> ac: for the bot I'm using hs-plugins
13:15:07 * joelr1 goes to shoot himself after listening to thoughtpolice talk about monomorphic types in conjunction with plugins
13:15:14 <waern> thoughtpolice: oh, you could try to see if it works, and then it should be easy to just get it exported in 6.8.2?
13:15:21 <joelr1> i can't handle it anymore .... arghhh.....
13:15:27 <joelr1> my head is, like, exploding
13:15:30 <thoughtpolice> waern: i'll have to look into it.
13:15:33 <joelr1> already
13:15:34 <thoughtpolice> joelr1: yeah it somewhat sucks,
13:15:39 <thoughtpolice> but the alternative is using compileExpr
13:15:46 <thoughtpolice> which you'll have to unsafeCoerce# to the proper type
13:15:48 <joelr1> thoughtpolice: and the difference?
13:15:49 <thoughtpolice> which is how yi does it
13:15:54 <joelr1> oh, i see now
13:16:12 <thoughtpolice> so yeah, compiling to dynamic and having a typeable is really the lesser of two evils for stability reasons
13:16:23 <ac> thoughtpolice: how major of a change is it to switch between hsplugins and ghc-api?
13:16:33 <thoughtpolice> ac: for the bot it shouldn't be too much of a hassle, actually
13:16:44 <joelr1> man, i wanted to do (lets just imagine) eclipse with plugins in haskell
13:16:49 <joelr1> but it appears to be too har
13:16:50 <joelr1> hard
13:16:51 <thoughtpolice> there's only two modules in the code that really depend on hs-plugins, any other dependent changes should be very very minor
13:17:06 <thoughtpolice> ac: the main things are in Main.hs and PLoader.hs
13:17:35 <ac> thoughtpolice: ok. I'm thinking I should read that paper before I poke around in the code though
13:17:44 <thoughtpolice> there's probably a hint or two of the Module datatype (from System.Plugins) inside some of the code there, but other than that most of the changes and whatnot shouldn't be hard to apply.
13:17:53 <thoughtpolice> ac: yeah it's a good read. the approach is actually pretty simple.
13:18:19 <ac> How many papers by dons will I read before the day is over?
13:18:26 <shapr> ALL OF THEM!
13:19:00 <Syzygy-> shapr: You're scary.
13:19:03 <thoughtpolice> waern: i think expanding the ghc api to encompass this functionality would be a really good idea though. so yeah, I'll look into it. don't know if I'm ready to hack on something that big though...
13:19:08 <shapr> Syzygy-: You should meet me in person.
13:19:14 <Syzygy-> I've seen pics.
13:19:18 <shapr> Syzygy-: My bandwidth is horrendously limited on IRC.
13:19:32 <shapr> Syzygy-: But you haven't seen movies! Quick, what's your phone number?
13:19:43 <Syzygy-> shapr: Don't worry - I have a carefully honed imagination, and I'm shuddering and cowering.
13:19:54 <thoughtpolice> ac: oh, and if you're interested in the ghc api I wrote a blog about it a little while back with some examples,
13:19:55 <Syzygy-> shapr: You think I'll give you MY PHONE NUMBER? The way you sound??
13:20:01 <shapr> Imagination is still a poor substitute for a hyperactive shapr.
13:20:08 <ac> thoughtpolice: yeah I am. What's your blog?
13:20:15 <thoughtpolice> ac: http://austin.youareinferior.net
13:20:19 <thoughtpolice> it seems to be down right now
13:20:34 <thoughtpolice> (my host lives in sweden so it can be hard to coordnate these types of things.)
13:20:41 <thoughtpolice> but it should be the first post when it's back online
13:20:46 <shapr> Syzygy-: C'mon, it'll be fun!
13:20:48 <ac> thoughtpolice: thanks, I'll check it out
13:20:53 <Syzygy-> Ehm...
13:21:03 <Syzygy-> shapr: Are you expecting MMS capabilities for your schemes?
13:21:15 <shapr> No, I was going to call you and be hyperactive.
13:21:30 <thoughtpolice> ac: the last example is the whole 'plugin' thing and how you can dynamically load plugins, so that might be of some use if you're interested in that kind of stuff
13:21:43 <Syzygy-> Riiiight.
13:21:57 <Syzygy-> So ... hmmm ... who do I really really hate ... *rifle through my phone book*
13:22:03 <waern> thoughtpolice: if its too hard you can probably ask JaffaCake about it in #ghc. He has recently put some more effort into the API btw, and I think he's planning on some more refactorings
13:22:21 <shapr> Syzygy-: C'mon, you live a life of calm math and deep thinking, right? Don't you need a big shot of adrenaline every once in a while?
13:22:31 <thoughtpolice> waern: i don't think it'd necessarily be hard, it'd just take some time to walk around the code base in compiler/ mainly...
13:22:55 <shapr> Syzygy-: Plus I haven't called Germany in years.
13:23:06 <thoughtpolice> i would definately be willing to work on it though, because I like the functionality and wrapping it into the compiler itself is a good long-term alternative to continuously fiddling with hs-plugins.
13:23:22 <waern> thoughtpolice: yes. I think you would have to concern yourself with compiler/main mostly though
13:23:31 <Syzygy-> shapr: I 1) eat at the university cantine. 2) help out in #math both on Freenode and EFNet and 3) cook my own food. Adrenaline a plenty.
13:23:38 <ac> thoughtpolice: I'll be waiting for your fix
13:23:38 <thoughtpolice> waern: maybe a good next long term project? :)
13:23:42 <shapr> Syzygy-: ehehe!
13:23:49 <waern> thoughtpolice: definitely :)
13:25:34 <IW32> hey guys I have to build a mastermind game in haskell, any help
13:25:59 <EvilTerran> ?where tutorial
13:26:00 <lambdabot> http://www.haskell.org/tutorial/
13:26:00 <IW32> with GUI
13:26:07 <EvilTerran> ?where gtk
13:26:07 <lambdabot> I know nothing about gtk.
13:26:12 <shapr> IW32: Er, why do you have to do it?
13:26:15 <EvilTerran> ?where gtk2hs
13:26:15 <lambdabot> http://haskell.org/gtk2hs/
13:26:40 <IW32> it as to be in HGL
13:26:52 <IW32> i have to use the HGL library
13:26:57 <dcoutts> IW32: oh, that's a pitty. HGL is pretty poor.
13:27:13 <dcoutts> gtk2hs has a demo of a tick-tac-toe game
13:27:25 <dcoutts> (written by swiert)
13:27:39 <IW32> i know
13:27:46 <dcoutts> it's fairly nice code really (as we'd expect from swiert of course ;-) )
13:28:04 <IW32> anywhere I can get some practice ?
13:28:07 <IW32> games
13:28:59 <shapr> IW32: Er, why not try to write something and talk to use here on #haskell while you do that?
13:29:14 <swiert> \me blushes.
13:29:15 <dcoutts> IW32: I think you may also have to use hugs for HGL as I'm pretty sure HGL does not work well with ghc on windows. It might work on X11 but I don't know, I never hear about people using it. Everyone's switched, even SOE.
13:29:42 <shapr> swiert: You've done lots of good stuff for the Haskell community!
13:29:44 <shapr> swiert++
13:29:49 <shapr> @karma swiert
13:29:49 <lambdabot> swiert has a karma of 6
13:29:54 <dcoutts> IW32: so it's required for an assignment that you use HGL then?
13:29:56 <shapr> Hm, I think you deserve more than that.
13:29:58 <shapr> swiert++
13:30:03 <dcoutts> swiert++
13:30:07 <shapr> yay!
13:30:22 <Runaro> Is there a satisfactory implementation of extensible records in Haskell?
13:30:24 <shapr> Syzygy-: Well, if you give me your phone number, I'll call you :-)
13:30:30 <waern> Runaro: hugs
13:30:36 * shapr hugs waern 
13:30:40 <IW32> yes
13:30:41 <shapr> waern: Was that a request?
13:30:48 <Runaro> Awww
13:31:30 <shapr> Runaro: Or you could look at the original and later versions of HaskellDB to see how bringert and his team went from TRex on Hugs to other stuff on GHC.
13:31:34 <waern> shapr: AFAIK there's a compiler called Hugs but I don't really remember since I've been using GHC for so long ;)
13:31:43 <shapr> waern: hah!
13:32:33 <IW32> i just downloaded HGL
13:33:13 <swiert> I'm touched you guys :)
13:34:13 * shapr touches swiert .. WITH A LAMBDA!
13:34:28 <EvilTerran> @shapr
13:34:28 <lambdabot> I don't perform such side effects on command!
13:34:33 <shapr> ??
13:34:43 <shapr> I am not a number, I am a free variable!
13:34:45 <EvilTerran> @quote shapr
13:34:45 <lambdabot> shapr says: What other strange stuff do I do?
13:35:01 <shapr> Oboy
13:35:09 <shapr> @quote EvilTerran
13:35:09 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
13:35:24 <swiert> shapr: Btw, I hope to release the next TMR next week...
13:35:27 <EvilTerran> :D
13:35:27 <shapr> spiffy!
13:35:48 <swiert> The long awaited SoC special.
13:35:54 <shapr> oooh
13:37:06 <IW32> any advice on how to write the GUI?
13:37:07 <thetallguy> TMR?
13:37:15 <swiert> The Monad.Reader.
13:37:36 <shapr> IW32: Do you know how to write Haskell already?
13:37:40 <thetallguy> Ah, of course.
13:37:58 <shapr> @shapr shapr
13:37:58 * lambdabot activates her slap-o-matic...
13:38:12 <shapr> mmm, auto-flagellation!
13:38:28 <bparkis> I was thinking, a major or even primary benefit of a pure function is that you can use it without fear of consequences--it doesn't do anything behind the scenes.  this is kind of like a sandbox
13:38:35 <shapr> bparkis: Truly
13:38:41 <bparkis> but normal functional languages lack some features of sandboxes
13:38:53 <EvilTerran> ?type unsafePerformIO
13:38:54 <lambdabot> Not in scope: `unsafePerformIO'
13:39:00 <EvilTerran> pft
13:39:01 <shapr> bparkis: But another part of that same thing is that variables don't vary in Haskell.
13:39:04 <bparkis> for instance bounding the memory or runtime of called functions
13:39:23 <bparkis> you can call a function that never terminates, there's no safeguard against that so it's not a complete sandbox
13:39:30 <EvilTerran> @help @run
13:39:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:39:35 <shapr> You can create new values. That's pretty much your range of options.
13:39:35 <EvilTerran> @help run
13:39:36 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:39:42 <EvilTerran> @run length [1..]
13:39:46 <lambdabot> Terminated
13:39:47 <bparkis> yeah ok, but I mean something built into the language
13:39:52 <EvilTerran> we have our ways :)
13:39:59 <bparkis> i'm not saying it's impossible or even hard to create a sandbox, i mean it's something extra you have to do
13:40:15 <bparkis> whereas purity is a given (except for unsafe io)
13:40:21 <shapr> bparkis: That is built into the language. In Python, Java, etc when you have a handle to a value, you cannot be sure that it will not change while some other code is doing stuff.
13:40:32 <bparkis> yes
13:40:36 <IW32> Kinda
13:40:44 <IW32> i can get the code
13:40:50 <IW32> up and running
13:41:00 <IW32> it's the GUI that worries me
13:41:10 <bparkis> and also, if you give a function permission to perform IO, you basically have to give it permission to perform any IO it wants
13:41:15 * mux reads the "generating Maybe" proposal from tim newsham and goes "oooooh yes!"
13:41:25 <bparkis> unless you use something else, some other mechanism
13:41:28 <shapr> bparkis: I first tried writing purely functional code in Python (in Zope even), but sometimes the values my code got were changed elsewhere.
13:41:30 <Cale> bparkis: Well, that can be controlled using the type system as well.
13:41:35 <Cale> (together with the module system)
13:41:38 <bparkis> yes it can, but it's not _normal_ to do
13:41:41 <EvilTerran> bparkis, there is  a potential solution to that, but no-one's done it yet
13:41:43 <Cale> Sure.
13:41:48 <thoughtpolice> monads and types as a form of security is great. :)
13:42:02 <Cale> It's been done in several cases.
13:42:05 <shapr> IW32: You could try writing the mastermind game with a text interface first, and then put the GUI on top of that.
13:42:10 <Cale> For example, STM is an example of that.
13:42:12 <goalieca> thoughtpolice, you mean security through obscurity :P
13:42:14 <EvilTerran> it should be possible to make a big heirarchy of IO-based monads that only allow certain operations for general use, but it'd be ugly work
13:42:19 <bparkis> so what I'm saying is, why not have a language where complete sandboxing--functional purity, memory and time constraints, and restricted IO--is a given, present at all times
13:42:40 <shapr> IW32: You could do something as simple as outputting the board to the screen each time a move is made. Once your code works, then you could focus on the GUI.
13:42:43 <bparkis> a language based around sandboxing every function call, or at least many function calls, transparently to the user
13:43:14 <shapr> bparkis: You could do all that with a dependently typed language, but you get other serious drawbacks with that.
13:43:17 <bparkis> then if you had a large repository of functions in this language, contributed by unverified third parties, you could use those functions with less risk
13:43:29 <Cale> Well, you might end up making the types of certain things rather unwieldy.
13:43:34 <swiert> EvilTerran: There's way to split up the IO monad that aren't too ugly...
13:43:35 <bparkis> because you could ensure they wouldn't hog memory, disk space, time, or do anything funny
13:43:38 <swiert> But it's still a lot of work.
13:43:50 <EvilTerran> delicious meaty chunks of boilerplate
13:43:54 <shapr> bparkis: I do think that's the future of professional programming, but not in the next ten years :-)
13:44:50 <shapr> bparkis: Have you seen epigram?
13:45:14 <bparkis> no i'll take a look
13:45:33 <mux> shapr: isn't that a tautology? :-) "You could do all that with a dependently typed language, but you get other serious drawbacks with that."
13:45:47 <shapr> mux: Not necessarily.
13:46:20 <swiert> mux: Dependent types are making progress...
13:46:26 <shapr> I keep hoping that someone will find a dependently typed language that keeps at least two of the three points; recursion, type inference, and a terminating typesystem.
13:46:28 <Excedrin> bparkis: have you seen the TAL and PCC stuff? it's semi-related to what you mentioned
13:46:32 <joelr1> is there such a thing as memory-mapped arrays in ghc?
13:46:36 <mux> I'm not bashing dependent typing at all, I like it
13:46:41 <swiert> shapr: Have you seen Agda2?
13:46:49 <shapr> No, does it have two of those three?
13:46:53 <swiert> It's the new Haskell.
13:46:57 <shapr> !
13:47:05 * shapr looks
13:47:06 <mux> it's just that it seems you can do about everything with dependent typing, but the price to pay (so far) is for me, too high yet
13:47:07 <swiert> It has general recursion.
13:47:17 <swiert> And a "termination checker".
13:47:34 <swiert> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php
13:47:36 <lambdabot> Title: The Agda Wiki - Main
13:47:38 <mux> I wanted to try epigram but it works only with xemacs
13:47:45 <swiert> It's pretty hard to find.
13:47:45 <shapr> mux: I hope that someone will write research papers that give dependent typing a discount :-)
13:47:59 <mux> and I'm quite unable and also unwilling to use xemacs :p
13:48:12 <mux> shapr: :-)
13:48:18 <shapr> mux: Might be worth trying at least.
13:48:29 <mux> I'll try cayenne
13:48:37 <swiert> mux: Don't try cayenne.
13:48:38 <shapr> Does Ulf Norell show up here on #haskell?
13:48:45 <swiert> shapr: Not that I know of.
13:48:53 <mux> what's up with cayenne?
13:48:58 <swiert> mux: I'd be surprised if you can still get it to work, for instance.
13:49:07 <mux> hmm, doesn't sound good
13:49:11 <shapr> but you could ask augustss
13:49:13 <swiert> I think it needs a version of hbc that only lives on Lennart's machine...
13:49:15 <Runaro> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Docs.Records
13:49:17 <lambdabot> Title: The Agda Wiki - Records, http://tinyurl.com/2g4kon
13:49:19 <Runaro> For teh Win!
13:49:25 <mux> heh
13:49:54 <swiert> Runaro: I don't think they're extensible though...
13:50:34 <mux> I long for first-class modules via powerful records in haskell
13:50:53 <shapr> I could go for a hug.
13:51:03 <shapr> First class modules are way down my list.
13:51:07 * shapr grins
13:51:15 <aeolist> hello channel
13:51:18 <shapr> hello user
13:51:26 <aeolist> i have a ghc question, is this a good place?
13:51:32 <Excedrin> yes
13:51:33 <Cale> Should be all right
13:51:36 <shapr> Seems likely
13:51:42 <aeolist> haha, it's fairly basic
13:52:05 <omnId>  :? for lots of helpful information on use.
13:52:15 <shapr> > :?
13:52:18 <TSC> Is it possible to tell cabal to do a parallel build?
13:52:19 <shapr> hmm
13:52:23 <lambdabot>   parse error on input `:?'
13:52:32 <Cale> If it was really technical, you might also try #ghc, which is lower traffic and is more directed at the internals of GHC itself.
13:52:36 <mux> TSC: I think not yet, there were talks about this on some mailing list
13:52:42 <TSC> mux: Ok, thanks
13:52:55 <shapr> aeolist: So... what's the question? I'm hanging in suspense here!
13:53:11 <aeolist> so, installing a package like haskell-X11 to /usr/lib/ghc-6.8.1/site-local/, ghc should be able to find it with ghc-pkg list X11 ?
13:53:15 <aeolist> shapr: haha
13:53:15 <mux> will you speak!!?! :-)
13:53:39 <bparkis> thanks Excedrin for the PCC reference
13:53:42 <bos> TSC: no, cabal is a long way from doing parallel builds
13:54:07 <omnId> aeolist: probably need to register it, try ghc-pkg --help
13:54:08 <shapr> aeolist: Er, depends on your setup really. What distro and version?
13:54:20 <aeolist> archlinux, ghc 6.8.1
13:54:28 <aeolist> ghc is still being tested
13:54:35 <aeolist> the new version i mean
13:55:07 <goalieca> so what's next.. ghc 6.10 ? or 7.0
13:55:19 <Excedrin> GHC 2000!!
13:55:22 <shapr> Agda2 from what swiert says.
13:55:24 <Excedrin> oh wait
13:55:53 <thoughtpolice> i believe 6.10, there're some things on trac marked to happen then
13:55:57 <thoughtpolice> but i dunno, that might change
13:56:03 <sebell> Speaking of 6.8.1... how do I exclude packages from being built? (readline, for example)
13:56:21 <sebell> Since I don't have readline on my system, the build fails
13:56:40 <mux> did someone had a go at benchmark rounds with ghc 6.8.1 yet?
13:56:47 <mux> @where nobench
13:56:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench.html
13:57:11 <thoughtpolice> sebell: you might just be able to rm -rf the readline dir in libraries but don't take my word for it.
13:57:33 <sebell> thoughtpolice: I suspect that would work also. I used to use `--disable-readline' as an option in 6.6 and it worked
13:57:44 <thoughtpolice> mux: augustss did some raytracer benchmarks with 6.6.1 vs 6.8.1, and there's a bit of improvement.
13:57:56 <mux> thoughtpolice: nice to hear
13:58:08 <thoughtpolice> http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
13:58:08 <mux> spj said pointer tagging brings ~ 10-15% consistently
13:58:11 <lambdabot> Title: Things that amuse me, http://tinyurl.com/25sj6t
13:58:15 <aeolist> shapr: so?
13:58:27 <thoughtpolice> mux: apparently constructor specialisation helps too.
13:58:41 <shapr> aeolist: did you see the advice about trying ghc-pkg --help to register the package?
13:58:42 <thoughtpolice> and pointer tagging is supposed to have 10-15% boosts for most all apps, too.
13:58:52 <thoughtpolice> good stuff. :)
13:58:56 <aeolist> right
13:59:18 <Cale> aeolist: You're installing it manually?
13:59:21 <thoughtpolice> and of course you can always just go '-fvia-C -optc-O3' if you want to crank things up a bit.
13:59:23 <shapr> aeolist: Yeh, why not use cabal?
13:59:38 <aeolist> maybe because i dont know how to use cabal ^_^ :)
13:59:43 <shapr> oh
13:59:57 <shapr> Does "ghc-pkg -l|grep -i cabal" show anything?
13:59:59 <EvilTerran> isn't there a README in the package?
14:00:11 <thoughtpolice> sebell: i'm not sure if the build system recursively builds the stuff in libraries/ or if by unzipping extralibs on top you replace a makefile specifying them all, but it's worth a shot
14:00:19 <aeolist> yes, 1.2.2.0
14:00:53 <shapr> aeolist: Does the README in X11-extras give instructions for building with cabal?
14:01:17 <aeolist> readme doesnt mention anything about registering it... it configures, builds and installs
14:01:29 <shapr> Registering is part of installing.
14:01:33 <allbery_b> x11-extras is obsolete
14:01:43 <shapr> What's the current flavor?
14:01:47 <aeolist> x11
14:01:48 <sebell> thoughtpolice: I doubt it -- I'm positive I've extracted extralibs first at some point
14:01:49 <shapr> ah
14:01:52 <aeolist> it's been merged
14:01:54 <allbery_b> yeh, it's been merged
14:01:55 <thoughtpolice> it got merged into x11
14:02:01 <shapr> I'm behind the curve!
14:02:14 <thoughtpolice> it was in the xmonad 0.4.1 announcement on -cafe a few days ago when I heard about it.
14:02:21 <thoughtpolice> one less dependency to track, at least :)
14:02:23 <shapr> Ah, I haven't read that yet.
14:02:43 <aeolist> so i should ghc-pkg register it on installation and ghc-pkg unregister on removal?
14:02:46 <thoughtpolice> hm speaking of, maybe xmonad might finally work if I try building 0.4.1...
14:03:01 * thoughtpolice hasn't had a working xmonad build for some dumb reason since xmonad 0.2 :(
14:03:20 <allbery_b> don't pull HEAD xmonad unless you want to be a beta tester, though
14:03:29 <Runaro> too late
14:03:34 <allbery_b> the lig xmonad-as-library reorg is in progress
14:03:38 <allbery_b> *big
14:03:45 <thoughtpolice> allbery_b: nah, i'll try 0.4.1
14:03:48 <Runaro> oh. Early enough then.
14:04:09 <allbery_b> ...and if you had a Config.hs you liked it you want ot save it first or it will be nuked
14:04:29 <goalieca> hmm. wow. haskell is doing pretty damned well on a lot of the debian shootout benchmarks now
14:04:52 <goalieca> its fun to see gcc c suck so badly on a lot of them :-)
14:05:18 <aeolist> : bench
14:05:22 <aeolist> :? bench
14:05:25 <aeolist> mieh
14:05:29 <Runaro> @bench
14:05:29 <lambdabot> Unknown command, try @list
14:05:30 <thoughtpolice> allbery_b: i was using vanilla xmonad anyway
14:05:32 <aeolist> obey me, lambdabot
14:05:38 <thoughtpolice> if I can get 0.4.1 to work properly I'll config it later
14:05:48 <aeolist> maybe it's because i failed my ml exams?
14:06:05 <allbery_b> @shootout -- ?
14:06:05 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
14:06:28 <Cale> sudo cabal --global install X11==1.3.0
14:06:44 <Cale> should install the latest X11 library for you
14:07:17 <Cale> Unless your cabal install is broken, which is possible, since some bugs ended up in the version released with 6.8.1
14:07:27 <goalieca> hmm. the latest debian shootout is still using ghc 6.6
14:07:33 <Cale> yeah
14:07:36 <goalieca> that was done yesterday
14:08:04 <mattam> swiert: !
14:13:06 <swiert> mattam: That gives a parse error...
14:16:24 <hpaste>  wouter pasted "Coq Program" at http://hpaste.org/3736
14:16:37 <swiert> mattam: See the hpaste above.
14:17:25 <faxathisia> What is !?
14:17:26 <aeolist> runhaskell is a ghc wrapper?
14:17:34 <faxathisia> "!" in Empty => ! ?
14:17:43 <aeolist> no
14:18:01 <aeolist> Cale: i dont have a cabal executable
14:18:23 <swiert> faxathisia: I wish I knew the right notation.
14:18:31 <swiert> The point is it's an impossible case branch.
14:18:46 <Cale> aeolist: ah, then you may have to install cabal-install off of hackage first by hand
14:19:18 <aeolist> i dont want to do that :)
14:19:46 <aeolist> mmm
14:20:00 <aeolist> i am writing a pkgbuild
14:20:05 <aeolist> i would have to package cabal
14:33:46 <faxathisia> Is there any list of haskell style tips?
14:33:56 <bos> faxathisia: nothing very useful
14:34:00 <faxathisia> aw ok
14:34:01 <Cale> Don't use tabs :)
14:34:12 <bos> @where+ style http://urchin.earth.li/~ian/style/haskell.html
14:34:12 <lambdabot> Nice!
14:34:17 <ac> thoughtpolice: still around?
14:34:18 <faxathisia> I'll just keep in mind what I glean from what I've read
14:34:23 <bos> the above url is about all there is.
14:34:40 <faxathisia> well I hit tab and it inserts a bunch of space characters
14:34:44 <bos> but that's all about whitespace and 80 columns, and nothing else.
14:37:04 <ac> thoughtpolice: hot swapping is possible by passing the state to the static core, then having the static core relink the part to be hot swapped, and pass the state back. What happens when the type of your state changes? Do you have to restart the static part too?
14:37:23 <glen_quagmire> where can I download qml? http://sneezy.cs.nott.ac.uk/qml/compiler/  this has source codes in pdf
14:37:24 <lambdabot> Title: QML: A Functional Quantum Programming Language
14:38:29 <CaBa\> hi
14:38:46 <CaBa\> i have a (hopefully) quite simple question
14:39:11 <CaBa\> how can i print a single backslash as a string in hugs?
14:39:24 <Pseudonym> > "\\"
14:39:26 <lambdabot>  "\\"
14:39:29 <Pseudonym> That?
14:39:34 <CaBa\> Main> "\\"
14:39:34 <CaBa\> "\\"
14:39:39 <mrd> putStrLn "\\"
14:39:41 <CaBa\> Main> "\\"!!0
14:39:41 <CaBa\> '\\'
14:39:53 <mauke> putChar '\\'
14:40:11 <dons> we also recommend ghc for a richer haskell experience
14:40:20 <mrd> crisp clean taste
14:40:35 <Pseudonym> But Hugs is nice.
14:40:40 <Pseudonym> Not thrilling, but nice.
14:40:40 <ac> what's a practical application of QML?
14:40:48 <faxathisia> > Char.chr (1+Char.ord '['
14:40:48 <lambdabot> Unbalanced parentheses
14:41:10 <mauke> > succ '['
14:41:11 <lambdabot>  '\\'
14:41:29 <mrd> ac: programming quantum computers
14:41:51 <ac> mrd: but they're hard to find, so that doesn't seem very practical at the moment
14:41:57 <CaBa\> mauke: well okay, as i anyway am working on a function that is resulting in IO() thats fine with me at the moment... still quite a shame that show() displays the backslash double if u feed a string
14:42:30 <mauke> CaBa\: huh?
14:42:36 <mauke> show doesn't really display anything
14:42:38 <mrd> ac: well, i'm typing from the future, where we used quantum computers to time-travel and chat on IRC
14:42:40 <ac> mrd: I'm definitely not saying that one shouldn't create such a language, just curious what an "implementation" means
14:42:43 <mauke> it converts from strings to strings
14:42:43 <thoughtpolice> ac: that part is addressed, for example if state changes inbetween a code reload you're kind of left screwed because it won't demarshal correctly, since your reboot function is polymorphic for state
14:42:54 <Pseudonym> > show "\\"
14:42:55 <CaBa\> mauke: okay, show results in a string that contains it double :P
14:42:56 <lambdabot>  "\"\\\\\""
14:43:04 <mauke> CaBa\: yes. if you don't want that, don't use show
14:43:06 <Pseudonym> It quotes the representation of the string.
14:43:19 <thoughtpolice> the idea it takes is to serialize the previous state to disk in some fashion, and when the new code is reswapped to have it have a proper method of demarshalling and making it all fit together correctly
14:43:20 <Pseudonym> In that case.
14:43:35 <mrd> > read (show "\\") :: String
14:43:37 <lambdabot>  "\\"
14:43:40 <ac> thoughtpolice: ok. I haven't finished of reading of course
14:43:52 <swiert> glen_quagmire: You might want to e-mail Jon Grattage.
14:43:56 <mrd> ?check \ s -> read (show (s :: String)) == s
14:43:56 <CaBa\> nice bot... what happens on > [1..]?
14:43:58 <lambdabot>  OK, passed 500 tests.
14:44:02 <Pseudonym> > [1..]
14:44:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:44:06 <Pseudonym> That.
14:44:11 <swiert> glen_quagmire: I'm sure he'll be willing to help you out.
14:44:14 <glen_quagmire> swiert: i guess. i couldn't find darcs repo even
14:44:15 <CaBa\> ts... fused nice bot ;P
14:44:30 * lambdabot purrs
14:44:35 <ac> how can you implement a quantum PL without simulating a quantum computer?
14:44:36 <swiert> glen_quagmire: No. I know of a cvs repository...
14:44:37 <mrd> @botsnack
14:44:37 <lambdabot> :)
14:44:40 <mrd> @botsmack
14:44:41 <lambdabot> :)
14:44:47 <swiert> ac: That's what they do, as I understand it.
14:44:54 <glen_quagmire> swiert: link me plz
14:44:55 <CaBa\> > [1..10]
14:44:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:45:07 <CaBa\> hm... everyone can use it :)
14:45:15 <swiert> glen_quagmire: let me look...
14:45:17 <ac> swiert: ah. That takes a lot of processing power ;)
14:45:30 <omg-9238423> @src liftM
14:45:31 <Pseudonym> The Good Haskell Style page is good, but I disagree with this:
14:45:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:45:38 <Pseudonym> In actual fact, to write a good Haskell program is to create a work of art.
14:45:40 <Pseudonym> That's not it.
14:45:48 <Pseudonym> Art for art's sake is useless.
14:45:55 <dons> no, its not that, I agree.
14:45:56 <faxathisia> Pseudonym: 'useless'  ?:|
14:46:04 <Excedrin> yea, art should always sell something
14:46:07 <mrd> art for Art's sake is less useless, if you like Art
14:46:11 <faxathisia> Pseudonym: It's a strange word to use to describe a task
14:46:11 <Pseudonym> ?google "quite useless"
14:46:13 <lambdabot> http://www.public.iastate.edu/~garden/art.html
14:46:14 <lambdabot> Title: All Art Is Quite Useless
14:46:18 <swiert> glen_quagmire: I'm not sure if you can check out anonymously.
14:46:29 <Pseudonym> Hey, I have no problem with useless.
14:46:33 <dons> there's something there about approaching a perfect embedding of the problem domain in the minimal haskell required to solve it, without redundancy or repetition
14:46:43 <Pseudonym> The thing is this:
14:46:44 <dons> that's what I think a good Haskell program is like,
14:46:49 <Pseudonym> A program is for two audiences.
14:46:51 <Pseudonym> One is the compiler.
14:46:53 <glen_quagmire> swiert: ok i'm emailing the author
14:46:54 <Pseudonym> The other is the next maintainer.
14:46:57 <swiert> ac: Yep. But at least you can start thinking about quantum algorithms today, as opposed to waiting until the machines get built.
14:47:01 <Pseudonym> You have to write the program for both audiences.
14:47:10 <dons> ok.
14:47:13 <ac> swiert: exactly. I was kind of wondering if anybody has done this a couple days ago
14:47:14 <faxathisia> dons: Can you name any examples of haskell programs like that?
14:47:25 <mrd> which audience does the booing?
14:47:28 <faxathisia> or clkose
14:47:33 <Pseudonym> mrd: MLers.
14:47:41 <dons> xmonad approaches it in some parts, in the StackSet model, for example
14:47:48 <mrd> ah yea for sure
14:47:52 <Pseudonym> Ah, butbutbut...
14:47:59 <dons> faxathisia: its the end point, its what is always just beyond the horizon
14:48:08 <Pseudonym> The "perfect embedding" isn't useless.
14:48:11 <dons> you can know only fragments
14:48:14 <faxathisia> dons ah I see
14:48:25 <Pseudonym> It's for maximum testability and flexibility.
14:48:29 <dons> and it captures much of the haskell "refactoring" culture
14:48:38 <dons> replacing repetition with data and control closer to the domain
14:49:00 <salierix> I'm still finding haskell programs very hard to write.
14:49:02 <swiert> ac: yep. There have been a few papers on modelling quantum programming in Haskell.
14:49:17 <dons> salierix: practice, and read programs that do similar thigns
14:49:35 <salierix> reading Haskell programs is even harder.
14:49:52 <glguy> a lot of that has to do with the programmer who wrote it originally :)
14:49:57 <Pseudonym> Reading novels is no harder, you just have to get used to them.
14:50:01 <Karle> hi
14:50:08 <Pseudonym> G'day.
14:50:18 <Pseudonym> The thing is, refactoring isn't useless either.
14:50:34 <dibblego> depends on your definition
14:50:36 <Pseudonym> By refactoring, you end up with code that's smaller, more reusable and often more efficient.
14:50:47 <Pseudonym> Win-win-win.
14:51:29 <dibblego> I watched a Java person refactor code so much the other day, that they ended up with foldl1
14:51:52 <mauke> @quote line
14:51:52 <lambdabot> glguy says: aparently Tor sends all packets with a 512 byte minimum, so if everyone could please write their thoughts on a few lines as possible, it would be appreciated q-:
14:52:04 <waern> I don't think art for art's sake i useless. A beatiful program can be inspiration for others to create beautiful code, and beatiful code is good code.
14:52:19 <waern> atleast most often
14:53:01 <Pseudonym> BTW, I disagree that programming is "art".
14:53:05 <Pseudonym> I think it's "craft".
14:53:15 <Pseudonym> Craft is decorative as well as functional.
14:53:26 <Pseudonym> Programmers aren't artists, they're artisans.
14:53:36 <mauke> .oO( programming as an abstract art )
14:54:03 <waern> I just think we are using the word art quite liberally, maybe craft is better
14:54:09 <Pseudonym> Yeah.
14:54:25 <Pseudonym> A beautifully quilted rug may be beautiful, but it also keeps you warm.
14:54:52 <faxathisia> I don't think there's any reason why you should expect to run a program
14:55:01 <Excedrin> so if you write a function that's never called, is that art?
14:55:17 <Pseudonym> That's an excellent question.
14:55:27 <faxathisia> It's just precise description in language, you can use it to evoke thoughts or explain concepts
14:55:34 <faxathisia> e.g. the guy using J to teach calculus
14:55:35 <Pseudonym> Even craft items have non-functional parts.
14:55:53 <mattam> swiert: You need to Require Import Coq.subtac.Utils or Coq.Program.Program depending on your version of Coq. It defines this notation and a few useful tactics
14:56:09 <Pseudonym> A beautiful chair may have decorative portions that have nothing to do with preventing you from falling on the floor.
14:56:36 <faxathisia> another ex is Chaitin using to show that you can't prove programs are elegant
14:56:43 <faxathisia> using lisp to show*
14:56:45 <salierix> I would define "Art" as a form of intellectual masturbation.
14:56:53 <dibblego> I read a blog post *ages* ago about a guy who had the realisation of monads when mixed fmap and join, but I can't find it (my colleagues are having the same realisation lately and I need to point them to it) - any ideas?
14:57:10 <faxathisia> salierix: Not a good definition at all :p
14:57:17 <salierix> faxathisia, why?
14:57:41 <Pseudonym> Yes, that's a very poor definition.
14:57:48 <salierix> Go on.
14:57:50 <Pseudonym> First off, there's art and there's art.
14:58:00 <Pseudonym> Yeah, bad art is intellectual masturbation.
14:58:19 <Pseudonym> Good art focusses your senses on something.
14:58:30 <omnId> dibblego: Cale's Monads as Containers talks about that.  It's proabably not what you're thinking of but could still be helpful.
14:58:37 <Pseudonym> Take a portrait, for example.
14:58:41 <mattam> swiert: I whish this wouldn't be needed but there's no easy way to do Require Import on the ml side.
14:58:42 <dibblego> omnId, thanks, but I don't think it was that
14:58:55 <dons> dibblego: it would be in the monad/blog articles page on the wiki
14:59:01 <dibblego> dons, good idea, cheers
14:59:01 <swiert> mattam: Ok. Thanks for the reply.
14:59:02 <Pseudonym> Its purpose, today, is not to be a photorealistic (whatever that means) representation of someone.
14:59:09 <Pseudonym> It's meant to be a _faithful_ representation.
14:59:09 <faxathisia> anyway you will often see art created for the purpose of evoking thoughts on a particular issue -- a lot of code has been written for this same purpose
14:59:13 <dons> so the functional pearls are close to art
14:59:28 <dons> they're the exemplars of particular aspects of our craft
14:59:31 <swiert> mattam: but even with Coq.subtac.Utils it gives a strange error...
14:59:34 <Pseudonym> To say something about a person that a literal rendering wouldnt' capture.
14:59:39 <Pseudonym> dons: Yes, I agree with that.
14:59:51 <Pseudonym> Take Hinze's implementation of binary search trees.
14:59:55 <dons> yeah
14:59:58 <faxathisia> hm.. I read one functional pearl and it was just mathematics
14:59:59 <Pseudonym> You probably wouldn't use that code as a FiniteMap.
15:00:03 <faxathisia> but written in haskell
15:00:07 <dons> faxathisia: programming at its finest :)
15:00:11 <swiert> mattam: Have you done any Vectors using Program?
15:00:15 <Pseudonym> But it reveals the algebra underlying the implementation.
15:00:22 <Pseudonym> i.e. it focuses your senses on one aspect of it.
15:00:40 <swiert> faxathisia: out of curiosity, which one did you read?
15:01:08 <salierix> How is that art?
15:01:39 <faxathisia> Cantors diagonalization.. Someone linked me it just after I wrote the same thing myself
15:01:55 <mattam> swiert: Yep a bit here and there, not a vector library
15:01:58 <faxathisia> I think it's enumerating the rationals without duplicates
15:02:04 <dons> ah!
15:02:11 <faxathisia> (by running Euclids GCD algorithms 'backwards')
15:02:21 <dons> Enumerating the rationals Jeremy Gibbons, David Lester and Richard Bird. 2006
15:02:31 <dons> http://haskell.org/haskellwiki/Research_papers/Functional_pearls   for those wondering
15:02:32 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
15:02:42 <mattam> swiert: strange is interesting :-)
15:02:50 <dons> who want  to visit the haskell museum of contemporary craft
15:02:57 <Pseudonym> :-)
15:03:03 <waern> dons: hehe!
15:03:10 <Pseudonym> I tend to agree that the pearls are more like art.
15:03:27 <Pseudonym> In the sense that the code in there you wouldn't use literally in anything intended to be useful.
15:03:33 <swiert> mattam: it says that branch_1 has type "Empty = h -> Data" but is expected to have type "0=h -> Data".
15:03:37 <swiert> Ring any bells?
15:03:37 <faxathisia> eek there is lots of them
15:03:41 <faxathisia> :D
15:03:43 <Pseudonym> Their purpose, as I said, is to make you think about things a different way.
15:04:03 <dons> the zipper as described is in xmonad :)
15:04:10 <dons> as is the zipWith fibonacci defn.
15:04:15 <mattam> Hmm, an old bug i guess. Which version are you running ?
15:04:21 <swiert> 8.1?
15:04:23 <Pseudonym> dons: Is it _literally_ in there?
15:04:25 <mattam> ouch
15:04:29 <Pseudonym> Or did you just reuse the idea?
15:04:34 <mattam> This is so 2006
15:04:37 <salierix> I think I'm close to giving up on Haskell again.
15:04:45 <swiert> mattam: 8.1 Feb 2007.
15:04:50 <dons> Pseudonym: the zipper defn, yes. i read the paper, implemented it .... and specialised it
15:04:56 <Pseudonym> Right.
15:05:02 <Pseudonym> So this is more like recycled art.
15:05:17 <dons> there's a blog post somewhere waiting to be written about haskell being the collision of the science and art of programming
15:05:26 <faxathisia> @src MonadPlus
15:05:27 <lambdabot> Source not found.
15:05:30 <faxathisia> >:|
15:05:31 <mattam> Well, same story. It works relatively well with subsets but dep-matching was "experimental"
15:05:49 <Pseudonym> You took the Mona Lisa, added a moustache and wrote "LHOQQ" to it.
15:05:49 <faxathisia> salierix: What are you trying to code?
15:05:56 <dons> Pseudonym: :)
15:06:03 <swiert> mattam: ok. I'll try to install a newer version of coq and see how I get on.
15:06:05 <mattam> It's our word for mostly buggy
15:06:06 <salierix> faxathisia, anything.
15:06:15 <swiert> mattam: hehe.
15:06:39 <mattam> Yeah, don't be afraid to take the svn version, it always compiles.
15:06:39 <dons> i'm very proud we got this into a bunch of unix packages, via xmonad:
15:06:41 <dons> fibs :: [Integer]
15:06:41 <dons> fibs = 1 : 1 : (zipWith (+) fibs (tail fibs))
15:06:44 <Pseudonym> OK, let me rethink this.
15:06:55 <faxathisia> salierix: well that's no good :) Pick something simple you'd like, and find out everything you need to code it
15:06:55 <dons> and looks like someone over parenthesises too. hmm.
15:07:15 <Pseudonym> Like any medium, programming supports art, craft and ugly industrial design.
15:07:25 <dons> mmm
15:07:36 <salierix> faxathisia, I could make stuff fine in C...
15:08:16 <scook0> dons: but but but ... fibs is useless for real-world applications! ;)
15:08:25 <monochrom> ugly industrial design is no longer design. :)
15:08:35 <faxathisia> salierix: me too, that's why it's fun writing something in another language, Even if it's much harder today - it's worthwhile overall imo
15:08:49 <salierix> Trying to read someone else's Haskell code is really hard.
15:09:02 <faxathisia> yeah I found that too
15:09:09 <faxathisia> gradually I am getting to be able to though
15:09:14 <nominolo> :t (<*)
15:09:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:09:21 <dons> scook0: not if you're tiling windows to the golden spiral :)
15:09:28 <nominolo> @index (<*)
15:09:28 <lambdabot> bzzt
15:09:42 <Pseudonym> Now I'm trying to link periods of architecture to programming languages.
15:09:50 <scook0> yeah, I figured that was the application
15:09:53 <dons> Pseudonym: get a blog
15:10:04 <nowhere_man> salierix: in my own experience, being able to read someone else's code is a major achievement
15:10:09 <Pseudonym> I have one!  And I posted an lolcat!
15:10:25 <nowhere_man> I know I really begin to know a language when I'm able to read code
15:10:35 <nowhere_man> not only write
15:10:38 <dons> ah, but not on planet haskell??
15:10:47 <dons> so i had to link to your lolcats instead
15:11:01 <faxathisia> I'm worried about over paranthesising :p
15:11:26 <Pseudonym> No, not on planet haskell.
15:11:38 <Pseudonym> http://andrew.bromage.org/blog/archive/2007/11/in_which_i_participat_1.html
15:11:39 <lambdabot> Title: The BWAIN: In which I participate in a meme, http://tinyurl.com/28eyww
15:11:42 <dons> then it doesn't exist, i argue.
15:11:49 <thoughtpolice> salierix: i got many initial-haskell-joys by writing simple unix tools.
15:11:51 <Pseudonym> Thanks to RSS, everything exists.
15:12:45 <salierix> immutable arrays are created at compile time right?
15:13:01 <bos> no.
15:13:20 <bos> they're created when you create them.
15:14:37 <faxathisia> @src on
15:14:37 <lambdabot> (*) `on` f = \x y -> f x * f y
15:14:43 <faxathisia> cool :D
15:15:15 <dibblego> ?src concatMap
15:15:15 <lambdabot> concatMap f = foldr ((++) . f) []
15:15:20 <salierix> Then you can't use an immutable array to store precomputed values?
15:15:36 <dibblego> @where weak pointers
15:15:36 <lambdabot> I know nothing about weak.
15:15:51 <faxathisia> hey why is
15:16:02 <faxathisia> f x * f y parsed as (f x) * (f y)
15:16:05 <dibblego> @where+ weak http://research.microsoft.com/Users/simonpj/Papers/weak.htm
15:16:05 <lambdabot> Nice!
15:16:13 <dons> salierix: you can compute things at compile time and stick them in an couple of different structures, if you like
15:16:13 <faxathisia> Is it using the precedence of built in * ?
15:16:16 <EvilTerran> faxathisia, because that's how haskell parses it
15:16:19 <dons> e.g. lexer tables
15:16:24 <EvilTerran> function application binds tighter than anything else
15:16:28 <faxathisia> or is just that that operators are always lower precedence than function applicaton?
15:16:30 <faxathisia> ah ok
15:16:31 <faxathisia> thaks
15:16:34 <faxathisia> thanks EvilTerran
15:16:40 <EvilTerran> :: binds looser than any infix op, too
15:16:42 <dons> its a functional language, after all.
15:16:55 <dons> so application should be the lightest syntax, and the tightest binding
15:16:55 <bos> salierix: you can, yes, but they're not stored as e.g. initdata in C
15:16:57 <Pseudonym> Don't forget that arrays are lazy.
15:17:02 <Pseudonym> So you can put thunks in there.
15:17:04 <dons> composition and abstraction should also be cheap :)
15:17:17 * dons looks at lisp
15:17:27 <faxathisia> dons you hate lisp :p
15:17:35 <dons> no no. its just an easy target.
15:17:40 <Pseudonym> I don't hate Lisp any more than I hate Latin.
15:17:42 <faxathisia> that's for sure haha
15:17:44 <bos> salierix: if you really want raw initialised data that isn't thunked, you'd be wanting to use initdata slurped up via unsafePerformIO and a ByteString (or similar) wrapper
15:17:48 <faxathisia> I got
15:17:50 <Pseudonym> Or Middle English.
15:17:53 <faxathisia> y f = f (y f)
15:17:57 <faxathisia> as well
15:18:06 <EvilTerran> @src fix
15:18:06 <lambdabot> fix f = let x = f x in x
15:18:25 <faxathisia> hmmm
15:18:28 <faxathisia> Where is @src from?
15:18:34 <faxathisia> I want ot look at the entire thing
15:18:48 <EvilTerran> whoever wrote it's arbitrary choices, afaik
15:18:52 <salierix> bos, uhhh, what?
15:18:55 <EvilTerran> @where lambdabot
15:18:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:19:03 <EvilTerran> iirc, you can get the source from there
15:19:05 <bos> salierix: yeah, i was afraid you'd say that :-)
15:19:54 <dons> what problem are you trying to address, salierix ?
15:20:27 <bos> i'm guessing salierix wants a big array of numbers. in c, you'd do this with a static array.
15:20:40 <bos> as in, a big array of preinitialised numbers.
15:21:10 <salierix> I want to precompute all posible chess moves for individual pieces.
15:21:29 <faxathisia> http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Source.hs
15:21:34 <dons> well, you can do that at compile time if you'd like. but i'd just use laziness to start with.
15:21:47 <faxathisia> I cant' see from there.. where it gets code frrom
15:22:03 <EvilTerran> salierix, you probably won't need all of 'em, so it's more in the spirit of haskell to use laziness
15:22:07 <Runaro> salierix: I challenge you to precompute all possible chess moves, using only Haskell's type system.
15:22:10 <vincenz> [halfply | halfply <- possible board, valid (move board halfply)]
15:22:44 <faxathisia> I guess it's from GHC source code
15:23:34 <salierix> EvilTerran, I will need all of them.
15:23:48 <faxathisia> am I right about that? :S
15:25:34 <salierix> I want to make a monte carlo based chess engine.
15:25:35 <EvilTerran> faxathisia, no; as i said, i'm pretty sure it has its own little table taken from hither and thither
15:25:44 <faxathisia> @where hither and thither
15:25:44 <lambdabot> I know nothing about hither.
15:25:46 <faxathisia> :(
15:26:09 <EvilTerran> "here and there"
15:26:38 <Runaro> that would be hence and thence
15:27:04 <faxathisia> I don't think it's in the lambdabot repo
15:27:13 <EvilTerran> don't those refer tothe passage of time, Runaro?
15:27:52 <Runaro> EvilTerran: No.
15:28:19 <Runaro> Not entirely. It's polymorphic.
15:28:39 <salierix> So, any help would be appreciated...
15:28:52 <EvilTerran> hither and thither are also correct
15:29:13 <faxathisia> @status
15:29:13 <lambdabot> Unknown command, try @list
15:29:20 <vincenz> hither and there
15:29:30 <vincenz> dither hither and thither with my printer
15:29:34 <Runaro> "from hither" is incorrect
15:29:46 <faxathisia> dons: Do you know where lambdabot gets the source code from in @src?
15:29:50 <Runaro> hither means "to here"
15:29:54 <monochrom> @quote hitherto
15:29:55 <lambdabot> No quotes match. There are some things that I just don't know.
15:30:01 <Runaro> @quote thither
15:30:01 <lambdabot> No quotes match. There are some things that I just don't know.
15:30:03 <LoganCapaldo> come yon!
15:30:06 <monochrom> @quote thereof
15:30:06 <lambdabot> No quotes match. There are some things that I just don't know.
15:30:13 <Runaro> @quote forthwith
15:30:14 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
15:30:18 <LoganCapaldo> @quote typeOf
15:30:19 <lambdabot> No quotes match. Do you think like you type?
15:30:25 <LoganCapaldo> @quote typeof
15:30:25 <lambdabot> No quotes match.
15:30:34 <EvilTerran> salierix, how big a dataset are you going to be precomputing? it might not be feasable tohold it all in memory at once, in which case it'd be best to write a seperate program to, say, populate a database or some files with the precomputed values
15:30:49 <EvilTerran> and then merely load the values you need fro mthere as you need 'em
15:31:04 <LoganCapaldo> today at work I really really wanted lazy evaluation (specifically an infinite list)
15:31:14 <LoganCapaldo> Haskell has spoilt me
15:31:21 <Runaro> Me too!
15:31:30 <EvilTerran> Runaro, okay, fine. next time i'll be sure to be *excruciatingly* precise when using random anachronisms for the sake of humour.
15:31:32 <mauke> in what language?
15:31:39 <LoganCapaldo> C++
15:31:47 <mauke> hah. good luck.
15:32:00 <Runaro> EvilTerran: Even humor must be type-safe. Sweep the leg. No mercy.
15:32:10 <sw17ch> speaking of C++, is it possible to link to C++ libraries like FTGL?
15:32:19 * EvilTerran loses track
15:33:45 <bos> sw17ch: not really
15:34:02 <sieni> ftgl?
15:34:10 <faxathisia> oh is there another way to do this?
15:34:12 <bos> sw17ch: you have to wrap C++ libraries in C first
15:34:21 <faxathisia> do ... ; (Ident' proc) <- lexToken (Ident' "")
15:34:47 <sw17ch> sieni: FTGL http://homepages.paradise.net.nz/henryj/code/#FTGL is the best open source OpenGL font library i've seen
15:34:48 <lambdabot> Title: Henry Maddocks' Home Page
15:34:53 <faxathisia> lexToken builds a parser for a single token
15:35:07 <faxathisia> or is doing it this way (pattern matching on the left of <-) ok?
15:37:36 <bos> pattern matching on the left is fine.
15:37:49 <LoganCapaldo> faxathisia: I guess that depends on if a) can the pattern match fail and b) what fail does in the monad you are in
15:38:12 <faxathisia> nah the match couldn't fail (and it's in parsecs Parser monad)
15:38:14 <bos> a failed pattern match won't call the monad's fail
15:38:21 <LoganCapaldo> if the answer to a is no or if the answer to b is "something acceptable" then yes it's ok
15:38:39 <LoganCapaldo> in do notation it will
15:39:12 <LoganCapaldo> @undo do { (Just x) <- a ; return (x + 1) }
15:39:12 <lambdabot> a >>= \ b -> case b of { (Just x) -> return (x + 1); _ -> fail ""}
15:40:29 <LoganCapaldo> > do { (Just x) <- [Nothing] ; return [x] }
15:40:31 <lambdabot>  []
15:40:54 <salierix> EvilTerran, the set of all possible moves for individual pieces is very small.
15:41:12 <EvilTerran> if it's small, then why pre-calculate?
15:42:01 <EvilTerran> if you write it in a way that it'll get memoized, so only calculated once per program run, it shouldn't be a problem
15:42:39 <EvilTerran> unless you're dealing with the sort of giant datasets that aren't sensible to hold wholly in memory
15:42:54 <chessguy> salierix, what game are you talking about?
15:43:05 <salierix> chess.
15:43:06 <EvilTerran> i'm oversimplifying, i know, but it should work
15:43:22 <chessguy> what's that? :)
15:43:46 <EvilTerran> and, if you've written it in a way that fully memoizes, it should be fairly easy to swap in something pre-calculated if that turns out to be too slow
15:44:46 <salierix> I just want it to be fast...
15:44:48 <mauke> chessguy: spoilt milk
15:45:05 <EvilTerran> ?where YAGNI
15:45:06 <lambdabot> http://c2.com/xp/YouArentGonnaNeedIt.html
15:45:07 <salierix> Right now though I may give up and just use C.
15:45:50 <astrolabe> salierix: have you seen the bandit stuff for go?
15:45:55 <EvilTerran> "Always implement [optimisation]s when you actually need them, never when you just foresee that you need them."
15:46:42 <Pseudonym> BTW, there's a lesser-known fourth rule of optimisation.
15:46:45 <Pseudonym> That's for real experts.
15:46:51 <Pseudonym> It's this:
15:47:02 <chessguy> please, enlighten all us non-experts
15:47:06 <Pseudonym> Some problems need performance designed in, and so optimisation needs to be done up front.
15:47:18 <Pseudonym> Such optimisation is not done in code, but on the back of an envelope.
15:47:33 <goalieca> umm.. isn't that the same as choice of algorithm?
15:47:41 <Pseudonym> Sometimes.
15:47:48 <salierix> astrolabe, monte carlo seem to dominate computer go right now.
15:47:54 <Pseudonym> Actually, I'll call that the fifth rule.
15:47:57 <Pseudonym> The fourth rule of optimisation is:
15:48:01 * goalieca is guilty of writting monte carlo
15:48:15 <Pseudonym> The best favour you can do for your code, from a performance point of view, is to make good abstractions.
15:48:34 <Pseudonym> That way you can swap out an underperforming part and swap in a better part, and everything else will just work.
15:48:38 <Pseudonym> (That's the Haskell approach.)
15:48:44 <mauke> see also http://cr.yp.to/djbfft/faq.html
15:48:58 <goalieca> hmm.. if optimization was mathematical then i see the need for axioms.. otherwise its all just bs
15:49:07 <astrolabe> salierix: Yes it does.  I was just mentioning it because I thought it might help you with chess.
15:49:08 <Pseudonym> The back-of-the-envelope rule applies to algorithms, data structures and even input representations.
15:49:19 <Pseudonym> On-disk data structures are often quite expensive to alter.
15:49:26 <Pseudonym> Algorithms, not so much in general.
15:49:36 <Pseudonym> So using the back of the envelope helps here.
15:49:57 <goalieca> meh. /me is trained as an engineer so i don't bother wasting time determining if p=np. I count cycles from the start
15:50:14 <Pseudonym> Engineers don't count cycles from the start.
15:50:18 <EvilTerran> i don't do either 'til i've profiled
15:50:20 <mauke> goalieca: you can't do that without math
15:50:21 <Pseudonym> They count resources.
15:50:27 <ivanm> Pseudonym: you mean engineers can count? :o
15:50:29 <ivanm> :p
15:50:29 <goalieca> well.. you know what i mean
15:50:41 <Pseudonym> They count people, cycles, bytes and beans.
15:50:46 <EvilTerran> and i very rarely need to profile
15:51:05 <EvilTerran> (i don't code much resource-heavy stuff, mind)
15:51:06 <Pseudonym> All of which are resources.
15:51:41 <goalieca> it's good to know that i need x bytes of ram, y floating point ops, and z bus transfers
15:51:46 <EvilTerran> i've thoroughly ridded myself of the delusion that any of my pet programs are likely to be classed as "resource-heavy" in the context of modern computing
15:52:04 <goalieca> heh. I've done some HPC. tricky stuff
15:52:10 <goalieca> ipc always kills it though.
15:52:15 <dons> haskell program coverage eh?
15:52:19 <goalieca> gotta be very careful from the very start
15:52:22 <salierix> UArray is strict right?
15:52:37 <monochrom> yes
15:52:43 <Pseudonym> Yeah, I've written database servers for a living.
15:52:55 <EvilTerran> salierix, yes -- not that that should particularly matter
15:53:06 <Pseudonym> Ten minutes spent on the back of an envelope, or 30 minutes in front of a whiteboard with other people, usually replaces days of profiling.
15:53:13 <goalieca> exactly
15:53:15 <salierix> EvilTerran, why wouldn't it?
15:53:20 <TomMD> OT: I'm writing up a blog post (on Haskell), but seeing as I'm not really a blogger and don't run my own server - where do you guys recommend putting code?  I see some sites with huge blobs inline, some with links to personal servers (I'm not currently running any of those).
15:53:36 <EvilTerran> salierix, if you have one array that you use for everything, then even if it's non-strict, it'll still only calculate everything once
15:53:45 <EvilTerran> and that's what matters
15:53:57 <goalieca> TomMD.. isn't there a way to turn literate haskell into html
15:54:11 <goalieca> and then some sort of code folding or something
15:54:20 <goalieca> i think inline is the best for explaining thing
15:54:23 <EvilTerran> not *when* something hogs your processor, but *how much* it hogs when it does. and strictness doesn't make *that* big a difference in that regard
15:54:25 <TomMD> Sure, but I was thinking I wanted this out of the way, just for download (straight .hs or on a darcs somewhere).
15:54:29 <Runaro> It's likely that an array is not the ideal data structure for your purposes.
15:55:32 <salierix> I need random access.
15:57:09 <Pseudonym> Sorry, what are you planning to use the array for?
15:57:27 <Pseudonym> The actual board, or the possible next positions?
15:58:11 <salierix> bitboards used for move generation.
15:58:38 <Pseudonym> So the boards themselves.
15:58:51 <Pseudonym> If I understood that correctly.
15:59:16 <EvilTerran> salierix, i do get the feeling you're "trying to write C in haskell", as it were
15:59:52 <salierix> Why do you say that?
16:00:29 <Pseudonym> I have to agree in this case.  The best thing to do is use a simple implementation, and use that to design the interface that your data structure needs.
16:00:58 <Pseudonym> Then if it turns out to be a bottleneck, modify the implementation, keeping the interface.
16:01:53 <EvilTerran> you're working against what'd be more natural in haskell, in the interests of performance
16:02:05 <salierix> The "data structure" is just a lot of Word64's...
16:02:13 <Pseudonym> So?
16:02:17 <Pseudonym> That's the implementation.
16:02:20 <Pseudonym> Not the interface.
16:02:27 <EvilTerran> bit-shuffling's not very haskelly
16:02:40 <jonafan> there are data structures you can implement that give good random access too
16:02:50 <Pseudonym> It can be, if you put it behind a decent interface.
16:03:03 <jonafan> not O(1), but O(log n) which aint too bad
16:03:46 <hpaste>  sjanssen pasted "xmonad ManageHook EDSL" at http://hpaste.org/3738
16:03:51 <salierix> I fail to see what is wrong with arrays.
16:03:57 <EvilTerran> Pseudonym, such as an unboxed array of bits, yes. but designing your algorithm around that sort of thing from the start strikes me as a "i wish i were writing in C" thing to do
16:04:04 <EvilTerran> *array of bools
16:04:16 <jonafan> arrays aren't functional
16:04:17 <Pseudonym> So don't do that from the start.
16:04:20 <EvilTerran> salierix, nothing, if they're the natural thing to do
16:04:30 <Pseudonym> Use a simple data structure to start with.
16:04:34 <Pseudonym> Use that to design the interface.
16:04:41 <Pseudonym> Then if you need bit fiddling, it can be localised.
16:05:06 <EvilTerran> where, by "natural", i mean "makes writing the rest of the algorithm as trivial as possible"
16:06:15 <Pseudonym> In fact...
16:06:15 <EvilTerran> i tend to start out with a Map instead of an Array
16:06:26 <Pseudonym> I think there's an advantage to writing something simple and brain-dead first.
16:06:39 <Pseudonym> Because you know whatever you write, you're gonna have to rewrite it.
16:06:50 <Runaro> salierix: Are you really going to keep all possible moves in a chess game, or just all possible moves for the given position?
16:06:51 <sieni> salierix: even in C one would have a bunch of functions that do stuff and the actual implementation is hidden. And if you need stuff to get inlined you can move function definitions to headers and declare them static.
16:06:52 <jonafan>  what's a map?  i don't know haskell, i just hang here as a reminder that i should learn it when i'm done with ocaml and also cuz there's a loto f interesting discussion here in general
16:06:55 <Pseudonym> So write something first that you KNOW you're not going to want to use.
16:07:09 <EvilTerran> @docs Data.Map
16:07:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
16:07:30 <jonafan> 404
16:07:35 <monochrom> Data.Map allows you to store key-value pairs and look up by key.
16:07:44 <jonafan> ah
16:07:45 <Runaro> Records!
16:07:58 <salierix> Runaro, all possible moves for individual pieces. I've said this many times now.
16:08:13 <jonafan> salierix should look into vectors/binary random access lists, whatever you want to call them
16:09:26 <EvilTerran> Pseudonym, in fact, Bird ran with that sort of thing in my first-year FP lectures. as a worked example, he started out with a naive sudoku solver, and proceeded to fiddle with it algebraically until it ran Fast Enough.
16:10:04 <EvilTerran> salierix, maybe you're having to repeat yourself because that doesn't really make sense
16:10:32 <EvilTerran> all possible single moves from one particular board position? all possible moves ever?
16:11:00 <Cale> salierix: You know that UArrays of Bool will actually be packed away into bits, right?
16:11:13 <hpaste>  faxathisia pasted "some ugly pretty printing code" at http://hpaste.org/3739
16:11:32 <faxathisia> any tips on how to write this sort of thing better?
16:11:50 <Cale> faxathisia: Maybe try a pretty printing library
16:11:58 <salierix> EvilTerran, on a clear board all, all the moves the rook can make if it's position is at a1
16:12:24 <EvilTerran> as an 8x8 array of boolean values?
16:12:25 <Cale> But I'd at least abstract the indentation mechanism.
16:12:50 <faxathisia> cool
16:12:53 <faxathisia> thanks Cale, I'll try Text.PrettyPrint
16:12:54 <salierix> EvilTerran, a single Word64.
16:13:04 <EvilTerran> that's the implementation
16:13:07 <salierix> Cale, I did not know that.
16:13:11 <EvilTerran> the interface is an array of bools :P
16:13:43 <faxathisia> why are the ghc docs down btw?
16:13:58 <Cale> faxathisia: they're not, but they did move
16:14:06 <Cale> If you go to http://www.haskell.org/ghc/docs/latest/html/libraries/
16:14:09 <Cale> it will work
16:14:10 <salierix> I want to do logical operations on whole board though.
16:14:17 <Cale> If you have deeper bookmarks, they're all dead.
16:14:26 <faxathisia> ok I'm going to update this link on the wiki
16:15:09 <faxathisia> o r someone should just regex the wiki
16:15:18 * EvilTerran notes that there's no "zip pairwise" operation on arrays
16:16:05 <Cale> Really, there ought to be a CGI script which lets you query the haddock docs.
16:16:15 <Cale> Or at least some symlinks
16:16:22 <Runaro> It's not an array at all. It's a binary relation.
16:16:26 <Runaro> :-)
16:16:32 <salierix> I guess I'll start on the xboard interface first.
16:16:44 <Cale> So you can ask for the documentation for the latest version of a module and have it figure out the rest.
16:16:52 <faxathisia> huh :|
16:16:58 <faxathisia> Why does compiling ghc say "Setup: The program happy is required but it could not be found"
16:17:12 <Cale> faxathisia: Do you have happy installed?
16:17:13 <dons> faxathisia: its a bug.
16:17:20 <Cale> oh
16:17:20 <dons> glguy: !
16:17:22 <dons> ^^
16:17:27 <dons> or was it phil?
16:17:44 <saturday> @src take
16:17:45 <lambdabot> take n _      | n <= 0 =  []
16:17:45 <lambdabot> take _ []              =  []
16:17:45 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:17:53 <faxathisia> ^ where is that source code from?
16:17:58 <Cale> The Prelude?
16:18:09 <dons> faxathisia: all from the prelude
16:18:12 <chessguy> @where prelude
16:18:12 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
16:18:17 <pheaver> faxathisia: I had that same error
16:18:27 <faxathisia> :D
16:18:28 <mauke> even the foldr?
16:18:28 <faxathisia> great thanks
16:18:35 <Cale> However, I really don't like the code in @src for some things
16:18:39 <Cale> @src foldr
16:18:39 <lambdabot> foldr k z xs = go xs
16:18:40 <lambdabot>     where go []     = z
16:18:40 <lambdabot>           go (y:ys) = y `k` go ys
16:18:43 <pheaver> faxathisia: I checked out the 6.8 branch via darcs and compiled that
16:18:47 <faxathisia> foldr looks different
16:18:53 <faxathisia> pheaver: did that work?
16:18:54 <pheaver> faxathisia: so some really recent patch must have fixed it
16:18:57 <pheaver> yes it did :)
16:18:58 <faxathisia> hm :|
16:19:00 <Cale> That makes me want to cry whenever I'm trying to teach someone about foldr.
16:19:08 <Cale> So I just type the code myself.
16:19:23 <faxathisia> pheaver: I just got Current Stable Release (6.8.1)
16:19:36 <Runaro> salierix: I think you'll find that you can get a more terse implementation of whole-board logic if you make a closed-world assumption and only represent the moves that are actually possible.
16:19:38 <faxathisia> is the darcs you got more recent?
16:21:16 <salierix> Runaro, possible moves are built from doing logical operations on the bitboards.
16:21:25 <EvilTerran> faxathisia, the link "@where prelude" gives is explicitly all characterisations of the behaviour of the functions without regard for such things as memory and speed constraints, so tends to use the "neatest" solution
16:21:59 <EvilTerran> faxathisia, while @src uses a hodgepodge of that sort of thing, highly-optimised versions from the GHC source, and "other"
16:22:53 <Runaro> salierix: That's what I'm saying; I think you will find that not thinking of the board as bits or booleans will help your code.
16:24:01 <Runaro> salierix: For a given piece, most of the board is inaccessible. You don't need to keep all that falsehood around.
16:24:57 <Runaro> In fact... I'll bet you can represent the possible moves for a piece as type-level relations. :-)
16:24:59 <EvilTerran> if, for instance, you had a Data.Set.Set (Int,Int) of all the co-ordinates a piece can move to, then there's lots of bundled set operations like intersect and whatnot
16:25:10 <EvilTerran> @docs Data.Set
16:25:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
16:25:13 <Runaro> Precisely
16:25:28 <EvilTerran> and their performance is probably Good Enough
16:25:31 <EvilTerran> :)
16:25:35 <chessguy> not likely
16:25:47 <chessguy> generally, a chess engine has to be extremely optimized
16:25:53 <faxathisia> you can always just totally ignore performance like I do
16:26:03 <EvilTerran> chessguy, well, you never know...
16:26:13 <chessguy> for a chess engine you do
16:26:16 <Runaro> premature optimization is the root of all evil
16:26:34 <LoganCapaldo> chessguy is a chess guy ":)
16:26:38 <EvilTerran> it seems that "all valid moves :: set of co-ordinates" is the natural abstract data type, to me
16:26:43 <Runaro> Rephrase: Premature optimization is the root of SOME evil.
16:26:57 <chessguy> i know more about chess and chess programming than all of you put together :)
16:27:25 <LoganCapaldo> all of us put together would be terrifying I think
16:27:26 <mrd> when the devil writes code he prematurely optimizes
16:27:28 <EvilTerran> so starting with an Honest To God Set may well be a good way to start. you can always change the backend later
16:27:37 <Excedrin> it's surprising that there's that much to know
16:27:42 <LoganCapaldo> Some kind of unholy fp demigod
16:27:43 <Excedrin> about chess and chess programming
16:28:03 <chessguy> there is a lot
16:28:16 <Runaro> What a waste of time!
16:28:21 <Runaro> er... I mean...
16:28:34 <Runaro> that's interesting
16:30:17 <salierix> I'll be back later.
16:30:43 <faxathisia> LoganCapaldo: What do you think it would want to code?
16:31:01 <chessguy> in writing a chess engine, if you know what you're doing at all, you should start with at least a somewhat optimized board representation
16:31:15 <LoganCapaldo> faxathisia: I don't think my imagination is good enough to answer that question
16:31:16 <thoughtpolice> although this isn't directly related to haskell, does anybody have any advice for a good math book that could serve as an introduction to more advanced maths? (i've got a year of highschool algebra II under my belt and my dad is some sort of calculus wizard.) i've got a book on discrete math, but I'm looking for something to really get me into 'deeper' math, if that makes any sense
16:31:25 <faxathisia> LoganCapaldo: Mine sure isn't :p
16:31:50 <thoughtpolice> i only ask here because I figure most (~90%) here have a knowledge of math above mine.
16:32:15 <faxathisia> thoughtpolice: What's highschool algebra II?
16:32:18 <thoughtpolice> i've always been interested in math, but I've never found any sort of good introduction to the type of maths I'm moreinterested in.
16:32:27 <ddarius> Hopefully more than 90% have knowledge higher than high school math.
16:32:36 <thoughtpolice> yeah.
16:32:45 <ddarius> What type of math are you interested in?
16:33:26 <thoughtpolice> because my dad's always done calculus (since he was like 19,) I've always had an eye for it.
16:34:09 <thoughtpolice> and I figure getting into calculus might serve as a good basis for getting into other types of math. but then again, i could be far from the truth
16:34:20 <faxathisia> thoughtpolice: What level is highschool algebra II
16:34:38 <ddarius> Many people start calculus before 19.
16:34:43 <thoughtpolice> faxathisia: it's basically lots of rational expressions, graphs and linear/quadratic equations
16:35:10 <Runaro> chessguy: No, you should start with a design (or a language?) that will allow you to change the representation at will.
16:35:38 <faxathisia> thoughtpolice: ok it's probably all put forward as the word of god with a large lack of proofs ?
16:35:40 <chessguy> Runaro, you say that like they're mutually exclusive
16:35:43 <Runaro> Possreps!
16:36:00 <faxathisia> thoughtpolice: You probably want to read lancelot hogbens book mathematics for the million
16:36:20 <ddarius> thoughtpolice: There's a lot more to math out there than what you've probably experienced.  Calculus (doesn't need to be but usually) is "more of the same".
16:36:22 <faxathisia> thoughtpolice: covers what they should teach in school including calculus
16:36:51 <thoughtpolice> ddarius: from looking at mathworld, I would think so. :)
16:37:31 <thoughtpolice> my major when I get to uni will certainly be CS, so I have a book on discrete math and some computational/complexity theory; I guess the thing is I'm more looking for math that's outside that domain.
16:37:42 <ddarius> That said, this link http://www.geocities.com/alex_stef/mylist.html is very nice and this may be a place to start http://www.maths.mq.edu.au/~wchen/ln.html
16:37:43 <lambdabot> Title: TEXTBOOKS, LECTURE NOTES AND TUTORIALS IN MATHEMATICS
16:38:23 <ddarius> thoughtpolice: What kind of things do you like to do/program?
16:39:02 <thoughtpolice> ddarius: i've always had a good eye for language design and compiler theory. aside from that, game design was (and still is partly) the reason I program, although I've never really invested enough time to it.
16:39:22 <thoughtpolice> kind of typical, but it lead me to what I love to do.
16:39:28 <ddarius> thoughtpolice: WHat kind of things do you specifically program?
16:39:54 <chessguy> Runaro, my point is that a crappy board representation usually winds up being to tedious and buggy anyway, so if you can, you should try to start with a better one. that's not to say that you shouldn't seperate the representation from the rest of the code, too.
16:40:02 <thoughtpolice> ddarius: as of right now just things that come to mind, randomly. like my irc bot, a packet sniffer, etc. etc..
16:40:22 <thoughtpolice> i was looking around at some resources on game programming in haskell recently though so that might be something to add to a sticky note
16:42:06 <ari> http://slashdot.org/comments.pl?sid=353633&cid=21273569
16:42:07 <lambdabot> Title: YouTube Video Warned About School Shooting
16:42:12 <sw17ch> thoughtpolice: i take it you've done some linear algebra then?
16:42:26 <ari> ... sorry, wrong channel, I intended to post that to the one on the left ->
16:42:37 <LoganCapaldo> bad ari!
16:42:51 <ddarius> bad dyslexic ari
16:43:17 <thoughtpolice> sw17ch: i have a book on it but I've yet to read it. many tell me linear algebra is a practical place to look at, though.
16:43:18 <ivanm> ari: isn't "->" the right, not left?
16:43:24 <ivanm> :p
16:43:33 <ari> Of course, I could use this link as an argument that it would be nice to have Unicode ByteStrings :p
16:43:42 <faxathisia> just fyi you do not have to have the slightest clue about linear algebra to use it in programming
16:44:07 <ddarius> thoughtpolice: I really like signal processing.  A beautiful intersection of pure and applied mathematics.
16:46:33 <thoughtpolice> ddarius: i found this book on dsp recently while crossing through reddit, http://www.dspguide.com/pdfbook.htm
16:46:34 <joelr1> evening
16:46:36 <lambdabot> Title: The Scientist and Engineer's Guide to Digital Signal Processing's Table of Conte ...
16:47:24 <ddarius> thoughtpolice: Yes.  It has its good parts and its bad parts.
16:51:34 <thoughtpolice> ddarius: thanks for the links though. i'll read through some of these lecture notes. :)
16:53:01 * Cale forgets whether there's an option to GHC to have the code emitted just after application of the layout rule.
16:54:08 <LoganCapaldo> that would be a neato featuro
16:54:42 <shachaf> Cale: Wasn't there just a thread about that on -cafe?
16:55:04 <Cale> yes, it appears that there was
16:55:05 <LoganCapaldo>   ghc -cafe
16:55:47 <TomMD> Is there an SF.net like site that uses darcs? For hackage they want you to have a package to post (and it isn't automated).
16:56:04 <thoughtpolice> TomMD: http://community.haskell.org ?
16:56:04 <lambdabot> Title: Haskell Community Server
16:56:22 <Cale> hrm, apparently this method doesn't work if the code itself doesn't parse
16:56:56 <dcoutts> TomMD: you can use cabal-upload from the command line
16:57:11 <dcoutts> I use that to upload to hackage, it's really convenient
17:03:35 * joelr1 thought of stirring the haskell pot a little...
17:03:45 <joelr1> see haskell-cafe for my missive
17:04:13 <joelr1> ChilliX: would appreciate your input. i'm sure Lennart will comment as well.
17:05:44 <hpaste>  gwern pasted "update of magnifier" at http://hpaste.org/3740
17:08:16 <saturday> hmm
17:08:21 <dons> joelr1: fwiw, Barclay's and Credit Suisse have user-facing haskell edsls
17:08:26 <saturday> elem uses any
17:08:29 <dons> as does xmonad.
17:08:44 <saturday> and any uses map
17:08:46 <joelr1> dons: well, xmonad doesn't count, imo. its user are developers
17:08:59 <dons> not haskell programmers though
17:09:03 <Olathe> @src any
17:09:03 <lambdabot> any p =  or . map p
17:09:06 <saturday> which is O(n)
17:09:07 <Olathe> @src all
17:09:07 <lambdabot> all p =  and . map p
17:09:28 <dons> i'd not have thought laziness would be an issue, so I was surprised you concentrated on that in your email. its all up to the edsl you write
17:09:39 <Olathe> @src and
17:09:39 <lambdabot> and   =  foldr (&&) True
17:09:41 <joelr1> dons: i don't think either barclays or cs use haskell to process volumes of data, not even real-time data. i think they are generating things.
17:09:48 <dons> yep.
17:09:57 <saturday> but wouldn't you get  better best case with tail recursion and stop on i==x?
17:10:12 <dons> processing large volumes beyond those in lazy bytestring form is untried, i think
17:10:13 <ddarius> saturday: No.
17:10:21 <joelr1> dons: i didn't concentrate on that, i mentioned it as an afterthought :-) still, if haskell is the dsl then laziness comes into play, no?
17:10:34 <TomMD> Is processing account requests on the community server automatic?  Its been 15 minutes and I don't see anything in my e-mail.
17:10:41 <dons> depends on the edsl. it could be fully strict if you wanted
17:10:54 <joelr1> dons: right. bytestrings are also byte-strings whereas i need to process disk-based arrays of floats or something like that.
17:10:58 <dons> i'm not sure what you're trying to do though. sounds like a big job.
17:11:05 <joelr1> dons: how can it be fully strict?
17:11:13 <saturday> ddarius: what am I missing?
17:11:15 <EvilTerran> saturday, tail recursion doesn't do what you'd expect under laziness
17:11:18 <sjanssen> joelr1: who is the target of your DSL?
17:11:23 <dcoutts> TomMD: I'm not sure if you get a reply immediately saying the request was received. Account creation waits for someone to review your request.
17:11:27 <ddarius> saturday: laziness
17:11:31 <EvilTerran> because of the outside-to-inside-ness of it
17:11:44 <dons> joelr1: embed a strict language, mapping to haskells strict features
17:11:48 <saturday> damn laziness
17:11:54 <dons> but i'm not sure i can make any clear recommendations yet.
17:12:01 * sjanssen <3 laziness
17:12:01 <joelr1> dons: oh, it's very simple. it involves writing programs that analyze time series and decide when they would trade. and it involves charting of the time series and trades.
17:12:03 <joelr1> sjanssen: traders
17:12:08 <dons> lisp doesn't seem anymore plausible than ocaml or haskell or c++
17:12:17 <EvilTerran> foldl (+) 0 [1..10] never looks at its accumulating parameter 'til you've gone all the way along the list, by which time you've got this big unevaluated thunk sitting around 'cos of laziness
17:12:32 <dons> ok. analysis. did you read the F# analysis thing for large game datasets at cufp this year?
17:12:33 <stepcut> EvilTerran: well, don't do that ;)
17:12:37 <joelr1> dons: but i don't want to create another language or parse haskell, for example. i would need to do either one, no?
17:12:56 <ddarius> saturday: elem = any . (==) does short circuit
17:13:01 <dons> no. but you're assuming laziness is an issue too soon :)
17:13:03 <joelr1> dons: i'm not that partial on lisp myself
17:13:09 <shachaf> EvilTerran: Doesn't -O2 optimize that?
17:13:15 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow has explanation for foldl (+) 0 [1..10]
17:13:15 <lambdabot> Title: Stack overflow - HaskellWiki
17:13:24 <EvilTerran> foldr (+) 0 [1..10], however, accumulates "outside" the recursive call, so the accumulation gets evaluated a bit before the recursive call, so no thunk build-up
17:13:31 <saturday> @src elem
17:13:31 <lambdabot> elem x    =  any (== x)
17:13:34 <EvilTerran> shachaf, not in the general case, though, i think
17:13:35 <joelr1> dons: i'm very afraid of laziness. i'm forever scarred by my programs taking 40-60% in the garbage collector during my last networking project
17:13:42 <joelr1> dons: why the f# analysis?
17:13:42 <dons> joelr1:  have you written any user facing edsls in any of these languages?
17:13:45 <EvilTerran> shachaf, so not in the "lies to newbies" case, either
17:13:54 <dons> joelr1: oh, msr using F# to analyse Halo 3 game logs
17:14:08 <dons> and suggest new game tweaks based on the results
17:14:12 <joelr1> dons: not quite but i don't see a problem. lisp edsl is lisp, same for ocaml.
17:14:27 <dons> so its not really edsls-ish
17:14:33 <dons> just a library?
17:14:35 <faxathisia> what about ocaml?
17:14:38 <joelr1> dons: oh, i heard about that. i don't see a problem with f# except i'm on a mac.
17:14:39 <dons> or are there control structures and so on?
17:14:41 <EvilTerran> foldl f e (x:xs) = foldl f (f e x) xs -- all those calls to f get built up as you work along the list
17:14:41 <joelr1> ocaml would rock, imo
17:14:56 <dons> use  something you're comfortable with.
17:15:06 <joelr1> dons: the control structures would come from the language. i.e. a when ... $ ... in haskell or the matching in ocaml
17:15:08 <ddarius> joelr1: Why do you even care to use Haskell?
17:15:09 <dons> given none of your haskell projects work out, i'm hesitant :)
17:15:12 <EvilTerran> foldr f e (x:xs) = f x (foldr f e xs) -- the runtime gets to work on that call to f before even starting on the inner foldr
17:15:19 <joelr1> hehe
17:15:21 <monochrom> EvilTerran: foldr (+) 0 [1..10] still builds large thunk for most Num instances, e.g., Int.
17:15:27 <joelr1> ddarius: i'm partial to STM, for example
17:15:38 <ddarius> joelr1: So yell at Xeroy
17:15:42 <joelr1> and i always like to try new things
17:15:44 <EvilTerran> monochrom, okay, summing numbers was a bad example.
17:15:45 <ddarius> Leroy
17:15:48 <ddarius> Christ.
17:15:54 <dons> i think you'll need to identify your concerns more concretely for any clear recommendation to be made
17:16:07 <dons> what platforms must it run on, what does  the dsl do, what volumes, what timing constraints, etc.
17:16:07 <EvilTerran> but foldl will *always* build that thunk, while foldr won't necessarily do so, depending on the structure of f
17:16:09 <joelr1> i always shoot myself in the foot using haskell so i thought i would ask this time and see if anyone is using haskell for a similar application
17:16:10 <TomMD> An MD5 implementation that is 1) ugly 2) 5x slower than C 3) Should be 2.5 times slower than 'C' except for some GHC bug (I presume). http://sequence.complete.org/node/367
17:16:12 <lambdabot> Title: md5 :: LazyByteString -> MD5Ctx | The Haskell Sequence
17:16:15 <monochrom> Leroy is Xavier alright, but is not Christ. :)
17:16:19 <joelr1> ddarius: there's an STM variant for ocaml
17:16:30 <ddarius> joelr1: So what's your problem?
17:16:47 <dons> he doesn't mix well with laziness
17:16:52 <joelr1> dons: the platform is just mac
17:16:54 <dons> i'm not sure why, but it seems permanent :)
17:16:57 <joelr1> haha
17:17:07 <dons> oh, so allusers are using a mac? or its via the web?
17:17:33 <joelr1> lets just say that haskell has a nicer "user interface", if you consider the syntax to be the ui (spj does i think
17:17:38 <dons> anyway, more info needed about the requirements.
17:17:41 <joelr1> dons: mac, mac, mac. everyone on a mac.
17:17:47 <faxathisia> joed: than?
17:17:53 <joelr1> faxathisia: then what?
17:17:57 <dons> i wouldn't jump on any untested technology you're not well familiar with
17:18:00 <faxathisia> what does haskell have a nicer UI than?
17:18:02 <dons> e.g. hs-plugins or yi -- no.
17:18:10 <joelr1> faxathisia: ocaml
17:18:19 <lekro> what kind of object is otherwise? ghci says it's Bool but I can use it in a case x of (Just a) -> ...; otherwise -> ...
17:18:20 <dons> since that path leads to bombing out and using something you understand better
17:18:31 <faxathisia> lekro: otherwise = True
17:18:37 <faxathisia> > not otherwise
17:18:37 <monochrom> otherwise is a variable. it is bound to True in the Prelude.
17:18:38 <lambdabot>  False
17:18:42 <dons> lekro: it doesn't have a kind, it has a type :)
17:18:48 <goalieca> > otherwise
17:18:50 <lambdabot>  True
17:18:50 <lekro> dons: oh, right :)
17:18:52 <joelr1> dons: hmm... there's always time to learn. i don't see why i would bomb with hs-plugins or yi. specially yi.
17:18:58 <goalieca> @src otherwise
17:18:58 <lambdabot> otherwise = True
17:19:01 <omnId> lekro: in that case, otherwise is a new name you've introduced that gets bound in the case of Nothing.
17:19:04 <joelr1> dons: but i get your overall drift
17:19:08 <dons> yi is an unstable, semi-abandoned research project
17:19:16 <dons> not something you bet the compnay on.
17:19:24 <dons> if in doubt, choose things with documentation
17:19:29 <dons> is a good rule :)
17:19:32 <omnId> > case Nothing of Just x -> undefined ; otherwise -> otherwise
17:19:32 <goalieca> lol
17:19:33 <lambdabot>  Nothing
17:19:38 <joelr1> dons: oh, that. of course i would improve on that. or maybe use a few bits on it since cocoa already has an editor.
17:19:46 <omnId> lekro: ^ otherwsie there is a name pattern.
17:19:55 <lekro> omnId: of course, thanks. I was so sure that it'd be a keyword
17:20:12 <omnId> lekro: use _ if you want a wildcard pattern.
17:20:20 <dons> so you're writing and edls and an ide forit?
17:20:20 <lekro> I should have known better since emacs doesn't color it like a keyword
17:20:36 <joelr1> dons: ghc api is something i worry about, though. i don't know it and it doesn't seem straightforward
17:20:38 <joelr1> dons: yep
17:20:41 <dons> seems like a big job. i'd try to reuse an existing ide, if at all possible. and yi isn't one.
17:20:55 <dons> yes, esp. if you're not familiar with ghc linker internals.
17:21:03 <dons> why is hot loading an issue, btw?
17:21:35 <joelr1> dons: it is no small job but being able to load code is crucial. it's an issue because i would need to load the trading system after i type it up. then i would need to run it.
17:22:20 <sjanssen> joelr1: is there any reason this can't be done externally? eg. "ghc --make /tmp/foo.hs"
17:22:26 <joelr1> dons: then i would check the performance results (gained money? lost money?), edit the trading system and re-run it (reload)
17:22:49 <Cale> omnId: heh, that case expression is nice
17:23:09 <joelr1> sjanssen: suppose i did this. i would still need to load the code and run it.
17:23:19 <omnId> Cale: heh
17:23:21 <dons> we load code externally in xmonad, for example
17:23:36 <dons> there's a number of approaches
17:23:46 <joelr1> sjanssen: and i would like for the process to be fairly fast and seamless. the way to do that is by having the compiler built into the app, imo
17:24:05 <joelr1> dons: you cannot unload the code loaded with the ghc api, or so says thoughtpolice
17:24:08 <Cale> joelr1: I think the best way to get a handle on how laziness works is by evaluating small programs with lazy evaluation on paper by hand.
17:24:15 <dons> joelr1: you can though
17:24:29 <dons> however, ghc-api is an untested vehicle for money making projects
17:24:43 <joelr1> dons: oh, well
17:24:44 <dons> it uses the same underlying api as hs-plugins
17:24:47 <Cale> We really ought to have a tool which lets you watch the lazy evaluation of terms though. That would be cool.
17:25:16 <Excedrin> CAL has that
17:25:17 <joelr1> i don't even know if this will be a money maker. i can only suspect it will be :-). i can afford to take some risks.
17:25:24 <Olathe> Yay !
17:25:25 <chessguy> Cale, the debugger?
17:25:29 <dons> compilling user code to standalone apps is a bit cleaner
17:25:36 <dons> you have more control of the resource usage
17:25:37 <Cale> chessguy: Well, that does sort of help.
17:25:44 <dons> > 1+2
17:25:46 <dons> like that.
17:25:46 <lambdabot>  3
17:25:53 <joelr1> dons: i thought hs-plugins ran ghc --make
17:26:15 <Cale> chessguy: Except that it can't display unevaluated expressions directly.
17:26:24 <dons> anyway, better sort out the basic constraints you have. i'm not sure language is important here, at least not yet.
17:26:34 <joelr1> dons: compiling to standalone apps won't work during the modeling process, i think
17:26:48 <Cale> It can only display the bits which have evaluated, and blanks for the rest
17:26:51 <joelr1> dons: fair enough. thanks for the discussion.
17:26:52 <dons> see for examples the polymer chemsitry modelling paper posted recently
17:26:59 <dons> are you familiar with that one, joelr1 ?
17:27:06 <joelr1> dons: does hs-plugins use ghc --make
17:27:20 <dons> to produce object code, yep
17:27:27 <joelr1> dons: yes, familiar. manuel & co (i think you are there too, right?) generate c code
17:27:32 <chessguy> Cale, what would you want it to show for thunks?
17:27:47 <dons> yeah. haskell edsl, specialised C models out the back, run them, analyse the results
17:27:49 <Cale> chessguy: the explicit code for the thunk
17:27:50 <joelr1> dons: generate C code for polymer chemistry modeling that is
17:27:59 <chessguy> ah
17:28:03 <dons> i'd happily do that again, actually. its a good structure.
17:28:14 <dons> use haskell as a syntax for some domain specific C
17:28:37 <joelr1> dons: i would need to re-read the paper but it wasn't very clear how you guys went from the haskell dsl to C
17:28:39 <dons> so you have precise control over the generated code
17:29:00 <dons> by building a C AST, and spitting that into icc/gcc
17:29:01 <joelr1> dons: jsut generated data structures in the edsl and generated C from those?
17:29:26 <joelr1> dons: if you have any examples of that dsl would you kindly email them to joelr1@gmail.com?
17:30:33 <dons> there's a new version of the paper. but look! you're doing that again: implementing research papers when there's money on the line :)
17:30:43 <Excedrin> I wonder how HLVM is coming along
17:32:20 <stepcut> dons: the fps page seems to link to an old version of the bytestring darcs repo?
17:32:27 <dons> ah.
17:32:38 <dons> stepcut: yes. see darcs.haskell.org/bytestring
17:32:43 <dons> i've not moved my web stuff yet
17:32:47 <stepcut> ok
17:33:29 <Excedrin> oh, what about using Harpy?
17:34:07 <joelr1> dons: i'm like that ;) but this is a chance for me to listen to everyone and reconsider to avoid the embarrassment of switching languages mid-project and claiming that haskell is not suitable.
17:34:42 <dons> which are you more comfortable with?
17:34:50 <joelr1> dons: i think i read the latest version of the paper but there wasn't much on the dsl there.
17:35:12 <dons> if the main thing is the edsl, i reckon haskell's got that hands down.
17:35:31 <joelr1> dons: the main thing is the edsl, making it easier on the users
17:35:34 <dons> the data processing is interesting, need to know types and volumes, and how hard the time constraints are
17:35:38 <joelr1> it's gotta be user-friendly
17:35:48 <dons> joelr1: ok, so the credit suisse experience there would be the main reference
17:36:03 <dons> and a good real world example.
17:36:19 <joelr1> the time constraints i wouldn't worry too much about, that can always be improved
17:36:46 <joelr1> well, i hope lennart will chime in then. from what i know they are generating excel spreadsheets, though.
17:37:10 <joelr1> dons: do you have examples of the polymer dsl?
17:37:14 <joelr1> that you can email me
17:37:32 <dons> only what's in the paper.
17:37:39 <dons> there's *lots* of edsl material out there though
17:38:06 <LoganCapaldo> netsplits are frequent today
17:38:07 <joelr1> dons: i only know about lava
17:38:24 <dons> what about the robot/real time yampa ones?
17:38:51 <joelr1> dons: hmm... i didn't consider yampa a dsl... but suppose i need to revisit that
17:39:02 <dons> http://haskell.org/haskellwiki/Research_papers/Functional_reactive_programming
17:39:05 <lambdabot> Title: Research papers/Functional reactive programming - HaskellWiki, http://tinyurl.com/jsfmb
17:39:10 <stepcut> lennart had some good blog articles on generating assembly from a dsl -> http://augustss.blogspot.com/2007/06/generating-more-code-with-harpy-after.html
17:39:18 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2p4mgk
17:39:37 <dons> home time.
17:39:46 <dcoutts> dons: could I ask you to do a test build on openbsd of gtk2hs-0.9.12.1 ?
17:40:01 <dcoutts> dons: to see if it builds ok on bsd
17:40:36 <joelr1> dons: thanks
17:40:41 <joelr1> over and out!
17:40:53 <dcoutts> anyone else here on a *BSD?
17:40:55 <joelr1> stepcut: thanks for the link!
17:41:00 <dcoutts> mux: you use FreeBSD right?
17:41:01 <joelr1> mac osx = bsd? :D
17:41:31 <dcoutts> oh, sure any OSX users who'd like to test this gtk2hs release would be much appreciated
17:41:32 <hpaste>  Pseudonym pasted "Something I seem to be using a lot lately" at http://hpaste.org/3743
17:41:33 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.tar.gz
17:43:27 <Pseudonym> Can anyone suggest improvements to the interface for that?
17:43:33 <LoganCapaldo> dcoutts: does it require gtk?
17:43:40 <dcoutts> LoganCapaldo: yes
17:43:43 <LoganCapaldo> drat :)
17:43:53 <saturday> @src or
17:43:53 <lambdabot> or    =  foldr (||) False
17:44:24 <sw17ch> > or [False, False, False, False, True]
17:44:26 <lambdabot>  True
17:44:38 <sw17ch> > or [False, False, False, False, False]
17:44:39 <lambdabot>  False
17:45:22 <LoganCapaldo> @type (sequence . map (||))
17:45:23 <lambdabot> [Bool] -> Bool -> [Bool]
17:45:26 <faxathisia> > or [False, False, False, True, False, undefined]
17:45:27 <lambdabot>  True
17:45:31 <omnId> Pseudonym: how is ModifiedT different from StateT Bool?
17:45:57 <saturday> or $ map (3==) [1..]
17:46:08 <chessguy> Cale, by the way, thanks for the reminder. i want to run http://haskell.org/haskellwiki/Haskell/Lazy_evaluation through the debugger and see how similar it is
17:46:09 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
17:46:13 <omnId> markModifed = put True
17:46:13 <Pseudonym> omnId: From an implementation point of view, it doesn't.
17:46:23 <ddarius> > or $ map (3==) [1..]
17:46:25 <lambdabot>  True
17:46:28 <Pseudonym> But it could equally be implemented as WriterT Bool.
17:46:48 <EvilTerran> ?instances Monoid
17:46:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
17:46:57 <Pseudonym> The interface doesn't allow you to set the modified flag as False.
17:46:59 <saturday> why didn't mine work?
17:47:00 <Pseudonym> That's important.
17:47:04 <EvilTerran> > True `mappend` False
17:47:04 <lambdabot>   add an instance declaration for (Monoid Bool)
17:47:05 <lambdabot>     In the expression: True `...
17:47:18 <ddarius> saturday: Look at the difference between what I wrote and what you wrote.
17:47:23 <ivanm> saturday: you need a ">" at the beginning to tell lambdabot that it's code
17:47:23 <EvilTerran> hmm
17:47:27 <omnId> Pseudonym: you could newtype StateT Bool and provide the restricted interface.
17:47:34 <Pseudonym> Perhaps.
17:47:44 <Pseudonym> Oh, I should probably allow selection based on the modified bit.
17:48:03 <saturday> i plead temporary blindness
17:48:54 <Pseudonym> The thing is, rewriting this as a WriterT-alike might improve, say, the efficiency of nondeterminism.
17:49:03 <Pseudonym> I'm just guessing there.
17:50:12 <Pseudonym> Parallelism, say.
17:51:39 <saturday> > foldl1 (||) $ map (3==) [1..]
17:51:41 <Pseudonym> But I'm just trying to get the interface right at the moment.
17:51:44 <lambdabot> Terminated
17:52:04 <Ares> how do I give the signature for a function that takes 2 functions and returns another one, the types may be different
17:52:11 <saturday> > foldr1 (||) $ map (3==) [1..]
17:52:13 <lambdabot>  True
17:52:24 <omnId> @type (.)
17:52:26 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:52:38 <omnId> Ares: that takes two functions and returns one.
17:52:49 <Ares> im sorry
17:52:57 <Ares> takes two lists and returns another one
17:53:03 <Ares> different types or the same
17:53:09 <EvilTerran> ?type zip
17:53:10 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
17:53:22 <Pseudonym> Anyway, lunch.  BBS
17:53:24 <EvilTerran> ?type (++)
17:53:26 <lambdabot> forall a. [a] -> [a] -> [a]
17:53:34 <faxathisia> :t (+++)
17:53:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
17:53:48 <omnId> @type zipWith const
17:53:49 <lambdabot> forall a b. [a] -> [b] -> [a]
17:53:58 <omnId> :)
17:54:35 <chessguy> mmm, isn't that id :: [a] -> [a]
17:54:51 <omnId> chessguy: the [a] is truncated to the [b]'s length.
17:55:01 <chessguy> well, ok
17:55:28 <EvilTerran> it's actually quite useful for pointless list manipulation
17:55:30 <omnId> but otherwise, yes it's const :: [a] -> [b] -> [a]
17:56:01 <EvilTerran> > zipWith const `ap` drop 1 $ [1..10]
17:56:02 <lambdabot>  [1,2,3,4,5,6,7,8,9]
17:56:23 <omnId> wow
17:56:33 <LoganCapaldo> bah
17:56:37 <LoganCapaldo> > [1..9]
17:56:38 <lambdabot>  [1,2,3,4,5,6,7,8,9]
17:56:42 <LoganCapaldo> ;)
17:57:22 <EvilTerran> yes, and even generalising mine to all lists leaves you with init, but the principle's there
17:57:41 <EvilTerran> it's "get all but the last n of xs"
17:57:49 <omnId> EvilTerran: init would use tail instead of drop 1, since it's partial.
17:57:55 <EvilTerran> hm, true
17:58:16 <omnId> > init [] -- at least I think so
17:58:17 <lambdabot>  Exception: Prelude.init: empty list
17:58:27 <EvilTerran> takeAllBut n = zipWith const `ap` drop n -- i mean
17:58:39 <omnId> quite cool, that
17:58:46 <EvilTerran> takeAllBut = (zipWith const `ap`) . drop -- >:]
17:59:11 <omnId> instance_Monad_((->)_r)++
18:00:15 <EvilTerran> > zipWith const `ap` drop 5 $ [1..]
18:00:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:00:19 <omnId> backdrop's a better name.
18:00:23 <EvilTerran> hehe
18:00:33 <EvilTerran> and takeback?
18:00:39 <omnId> of course
18:00:40 <Olathe> > zipWith const `ap` drop 5 $ [1..20]
18:00:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
18:00:47 <Olathe> O-o
18:01:09 <Olathe> @src zipWith
18:01:09 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
18:01:09 <lambdabot> zipWith _ _      _      = []
18:01:09 <omnId> = (\xs -> zipWith const (drop 5 xs) xs)
18:01:14 <omnId> Olathe: ^
18:01:19 <Ares> what would be the signature for a function that takes two list possible from different type and returns a list that contains elements of both types?
18:01:30 <omnId> erm, I think I flipped it, though.
18:01:34 <Olathe> @unpl zipWith const `ap` drop 5
18:01:34 <lambdabot> ((zipWith (\ a _ -> a)) >>= \ c -> (drop 5) >>= \ b -> return (c b))
18:01:39 <LoganCapaldo> @type zip
18:01:40 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
18:01:47 <LoganCapaldo> Ares, like that?
18:01:57 <omnId> (f `ap` g) x = f x (g x)
18:02:05 <EvilTerran> [a] -> [b] -> Either a b -- another possibility, Ares
18:02:16 <Ares> let me try
18:02:30 <chessguy> EvilTerran, you mean [a] -> [b] -> [Either a b]
18:02:34 <EvilTerran> er, yes
18:02:36 <omnId> @type \xs ys -> map Left xs ++ map Right ys
18:02:37 <lambdabot> forall a a1. [a] -> [a1] -> [Either a a1]
18:03:01 <chessguy> omnId, you're sick :)
18:03:06 <EvilTerran> but that requires constructors floating around. you can't just have a list [True,"foo",...]
18:03:07 <omnId> %-)
18:03:18 <omnId> chessguy: how so?  :D
18:03:29 <LoganCapaldo> EvilTerran: your example has constructors too :)
18:03:31 <chessguy> omnId, to come up with an example like that off the top of your head so quick
18:03:39 <EvilTerran> LoganCapaldo, i meant my examplr
18:04:16 <LoganCapaldo> huh?
18:04:29 <monochrom> omnId is omniscient, not sick.
18:05:08 <Ares> [a] -> [b] -> [Either a b]
18:05:11 <Ares> doesnt work
18:05:12 <EvilTerran> ... my example requires constructors. i was explaining this to Ares in case he was after a list like [True,"foo",...] :: [Bool or String]
18:05:19 <LoganCapaldo> (True is a constructor ... )
18:05:19 <EvilTerran> do try to keep up ;)
18:05:25 <chessguy> nah, he gave up his omniscience for the sake of nick-typability, for which i thoroughly respect him
18:05:28 <EvilTerran> i mean extra constructors
18:05:30 <LoganCapaldo> Only if you do :)
18:05:33 <faxathisia> ?djinn [a] -> [b] -> [Either a b]
18:05:34 <lambdabot> -- f cannot be realized.
18:05:35 <chessguy> Ares, what are you trying to do?
18:05:37 <omnId> chessguy: 8)
18:05:46 <LoganCapaldo> I was talking about the {True,"foo"..] example all along
18:05:48 <Ares> i am trying to interlace two lists
18:05:50 <faxathisia> ?djinn a -> b -> Either a b
18:05:51 <lambdabot> f a _ = Left a
18:05:56 <EvilTerran> oh, good lord
18:06:06 <EvilTerran> never mind
18:06:27 <chessguy> Ares, can you give an example?
18:06:44 <faxathisia> > concat $ zipWith (\x y->[Left x,Right y]) ['a','b','c'] [1,2,3]
18:06:46 <lambdabot>  [Left 'a',Right 1,Left 'b',Right 2,Left 'c',Right 3]
18:06:48 * chessguy drags the qustion out of him
18:06:49 <faxathisia> Like this Ares?
18:07:00 <Ares> so if I have a = [1,2,3]  and b = ['a','b','c']  then the resulting list should be [1,'a',2,'b',3,'c']
18:07:07 <faxathisia> no that's impossible Ares
18:07:15 <faxathisia> lists are hetrogenous in haskell
18:07:16 <omnId> Ares: what type would that list have?
18:07:17 <idnar> > [1,'a',2,'b',3,'c']
18:07:17 <chessguy> Ares, lists are inherently homogenous
18:07:18 <lambdabot>   add an instance declaration for (Num Char)
18:07:18 <lambdabot>     In the expression: 3
18:07:18 <lambdabot>     In ...
18:07:19 <faxathisia> er wait homogenous
18:07:20 <faxathisia> heh
18:07:25 <chessguy> @slap faxathisia
18:07:25 <lambdabot> Come on, let's all slap faxathisia
18:07:27 <faxathisia> Every element in the list has to have the same type
18:07:34 <idnar> oh maaan, didn't see that coming
18:07:47 <faxathisia> so you can use a sum type like Either
18:07:51 <Ares> so it is not possible?
18:07:52 <EvilTerran> instance Num Char!
18:07:55 <faxathisia> Ares: Either Char Int
18:07:59 <EvilTerran> >:)
18:07:59 <idnar> @type [1,'a',2,'b',3,'c']
18:08:01 <lambdabot>     No instance for (Num Char)
18:08:01 <lambdabot>       arising from the literal `1' at <interactive>:1:1
18:08:01 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
18:08:09 <chessguy> heh
18:08:12 <chessguy> interesting error
18:08:13 <faxathisia> Ares: did you see  concat $ zipWith (\x y->[Left x,Right y]) ['a','b','c'] [1,2,3]
18:08:16 <idnar> funny, it complains about a different element
18:08:25 <omnId> idnar: 1 = fromInteger 1, so if you have fromInteger 1 = '\1', then it'd type just fine.
18:08:26 <LoganCapaldo> instance Num Char where fromInteger = fromEnum ; (+) = ...
18:08:38 <idnar> omnId: sure
18:08:43 <chessguy> @type ['a','b',1]
18:08:44 <lambdabot>     No instance for (Num Char)
18:08:44 <lambdabot>       arising from the literal `1' at <interactive>:1:9
18:08:44 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
18:09:05 <omnId> @type [toDyn 'a', toDyn 1, toDyn 'b', toDyn 2]
18:09:06 <lambdabot> [Dynamic]
18:09:26 <chessguy> @type [1..]++['a']
18:09:27 <lambdabot>     No instance for (Num Char)
18:09:27 <lambdabot>       arising from the literal `1' at <interactive>:1:1
18:09:27 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
18:09:28 <LoganCapaldo> > [toDyn 'a', toDyn 1] -- I like the show instance for dynamic
18:09:30 <lambdabot>  [<<Char>>,<<Integer>>]
18:09:33 <chessguy> haha
18:10:07 <omnId> chessguy: (++) doesn't know that the left arg is infinite.
18:10:09 <Ares> hmmm thanks
18:10:11 <chessguy> Ares, are you totally confused yet? :)
18:10:16 <Ares> yes, pretty much
18:10:16 <Ares> hahaha
18:10:21 <newsham> > concat $ zipWith (\a b -> [Left a, Right b]) "test" [1,2,3]
18:10:23 <lambdabot>  [Left 't',Right 1,Left 'e',Right 2,Left 's',Right 3]
18:10:24 <LoganCapaldo> lazy type checking! :)
18:10:36 <chessguy> Ares, the important thing at your stage is that every element in a list must have the same type
18:10:51 <Ares> :) ok
18:10:52 <omnId> > concat $ transpose [map Left "test", map Right [1,2,3]]
18:10:54 <lambdabot>  [Left 't',Right 1,Left 'e',Right 2,Left 's',Right 3,Left 't']
18:10:55 <Ares> so then it is not possible right
18:11:03 <Ares> ok with concat
18:11:12 <chessguy> Ares, so we can have, [1,2,3,4], which could have type [Int], because every element is an Int
18:11:15 <faxathisia> > zipWith (\x y->[Left x,Right y]) ['a','b','c'] [1,2,3]
18:11:16 <lambdabot>  [[Left 'a',Right 1],[Left 'b',Right 2],[Left 'c',Right 3]]
18:11:27 <chessguy> Ares, there are some tricky ways to do it, as various people have shown
18:11:27 <faxathisia> :t [[Left 'a',Right 1],[Left 'b',Right 2],[Left 'c',Right 3]]
18:11:29 <lambdabot> forall b. (Num b) => [[Either Char b]]
18:11:33 <dcoutts> @yarr!
18:11:33 <lambdabot> Get out o' me way, yeh landlubber
18:11:33 <dcoutts> gtk2hs-0.9.12.1 released!
18:11:37 <chessguy> Ares, but not inherently
18:11:38 <dcoutts> bos: ping
18:11:46 <LoganCapaldo> > zip [1,2,3,4] "test"
18:11:47 <lambdabot>  [(1,'t'),(2,'e'),(3,'s'),(4,'t')]
18:11:49 <Ares> ok, thansk chessguy :)
18:11:53 <omnId> > concat $ transpose [map (Left . Left) "test", map (Right . Left) [1,2,3], map Right [LT,EQ,GT]]
18:11:54 <lambdabot>  Couldn't match expected type `Either a b'
18:12:35 <chessguy> Ares, if you can tell us why you want to do what you're trying to do, we can help you figure out a different way, or tell you more about a trickier way that would be applicable
18:12:43 <bos> dcoutts: pong
18:12:50 <dcoutts> bos: the final tarball is up on the gtk2hs site (via sourceforge) there is no functional change (except to fix two demos) since the tarball I gave you, so if that built ok then there's no need to rebuild.
18:13:01 <bos> ok, great
18:13:03 <bos> thanks!
18:13:10 <dcoutts> no, thank you! :-)
18:13:10 <Ares> it is working now :) thanks
18:13:21 <newsham> > let f xs = ([x|Left x<-xs], [x|Right x<-xs]) in f [Left 'a', Left 'b', Right 3, Left 'c', Right 4, Right 1]
18:13:22 <lambdabot>  ("abc",[3,4,1])
18:13:36 <chessguy> Ares, you're most welcome. we love answering questions in here :)
18:13:42 <chessguy> (and showing off, too :)
18:13:45 <Ares> hahaha
18:13:57 <Ares> ok, good because I may have another question in just a second
18:14:04 <chessguy> yay!
18:14:07 * chessguy does a little jig
18:14:10 <newsham> we'll keep ourselves busy till then
18:14:52 * omnId does a HUGE jig
18:15:20 <Ares> I am trying to declare an infinite variable, 1/factorial x
18:15:36 <Ares> where x should increase by one in every element of the list
18:16:14 <faxathisia> Ares: You can make the infinite list of natural numbers like this:
18:16:17 <faxathisia> > [1..]
18:16:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:16:19 <newsham> > let fact n = product [1..n] in map (\x -> 1/(fact x)) [1..]
18:16:21 <lambdabot>  [1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,1.38...
18:16:26 <Ares> mathE 1 : [ 1/(factorial x) | x <- pos ]
18:16:32 <Ares> this is what I have
18:16:34 <faxathisia> Ares: so if you have a function which takes x and goes to 1/factorial x, you can apply that function to each element of the list
18:16:39 <faxathisia> Ares: That's a map
18:16:42 <Ares> but it complains
18:16:51 <faxathisia> So you would write map oneOverFactorial [1..]
18:17:13 <faxathisia> (where oneOverFactorial x = 1/factorial x)
18:17:31 <cconnett> hi all, i'm having trouble with the new built-in hpc
18:17:41 <monochrom> > map (\x -> 1 / product [1..x]) [1..] :: [Rational]
18:17:43 <lambdabot>  [1%1,1%2,1%6,1%24,1%120,1%720,1%5040,1%40320,1%362880,1%3628800,1%39916800,1...
18:17:58 <monochrom> 1%720 means the rational number 1/720.
18:18:18 <Ares> *** Binding             : mathE
18:18:19 <Ares> *** Outstanding context : Fractional Int
18:18:29 <faxathisia> Ares: What I said made sense?
18:18:36 <cconnett> everything seems to compile and run fine, i get tix and mix files, but hpc report says it can't find Main in .hpc
18:19:12 <cconnett> tia for any help
18:19:15 <monochrom> / doesn't like Int operands, that causes the type error.
18:19:36 <Ares> not quite sure faxathisia but let me try what I understood
18:19:53 <monochrom> If you write:
18:19:56 <monochrom> > 1/2
18:19:57 <lambdabot>  0.5
18:20:07 <omnId> @type (/)
18:20:08 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:20:19 <monochrom> That "1" and that "2" are not taken as Int. They're taking as Double. That is why all is fine.
18:20:20 <omnId> @instances-importing Data.Ratio Fractional
18:20:21 <lambdabot> Double, Float, Ratio a
18:20:27 <monochrom> > (1 :: Int) / (2 :: Int)
18:20:27 <lambdabot>   add an instance declaration for (Fractional Int)
18:20:28 <lambdabot>     In the expression: (1 ...
18:20:48 <newsham> > map ((1/).factorial) [1..]
18:20:49 <lambdabot>  Add a type signature
18:20:57 <monochrom> See the "Fractional Int" thing again? That is the same error you face. You have Int operands.
18:21:21 <omnId> > let fact x = product [1..x] in map (recip . fact) [1..]
18:21:23 <lambdabot>  [1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,1.38...
18:21:40 <newsham> ooh recip
18:21:52 <omnId> class method
18:21:57 <omnId> Fractional I think
18:22:00 <omnId> @src Fractional
18:22:00 <lambdabot> class  (Num a) => Fractional a  where
18:22:01 <lambdabot>     (/)             :: a -> a -> a
18:22:01 <lambdabot>     recip           :: a -> a
18:22:01 <lambdabot>     fromRational    :: Rational -> a
18:23:56 <omnId> Ares: you don't, by chance, have a 'mathE :: [Int]' annotation, do you?
18:24:10 <Ares> no
18:24:21 <Ares> well yes actually
18:24:22 <Ares> hahah
18:24:26 <omnId> Ares: does pos have type Int?
18:24:30 <newsham> ints dont like dividing
18:24:37 <newsham> with "/"
18:24:41 <omnId> `div` is integer division
18:24:41 <newsham> they dont mind an occasional "div"
18:24:50 <EvilTerran> or `quot`
18:24:53 <Ares> oh!
18:24:56 <chessguy> Ares, sorry, i wound up on a phone cal
18:25:01 <Ares> that is a good hint
18:25:02 <EvilTerran> ?type div
18:25:03 <lambdabot> forall a. (Integral a) => a -> a -> a
18:25:19 <EvilTerran> ?type quot -- likewise, slightly different behaviour when negative numbers are involved
18:25:19 <TomMD> Is there any significant performance loss when using libraries that have profiling enabled (but not currently used)?
18:25:20 <lambdabot> forall a. (Integral a) => a -> a -> a
18:25:21 <omnId> Ares: but that rounds off your results, you'd get mathE = [1,0,0,0,0..]
18:25:41 <chessguy> @type recip
18:25:43 <lambdabot> forall a. (Fractional a) => a -> a
18:25:44 <omnId> Ares: you probably want (map fromIntegral pos) where you have pos there.
18:26:41 <monochrom> @quote fromIntegral
18:26:41 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
18:26:46 <Ares> if I use div it gives me
18:26:49 <Ares> Ares> mathE
18:26:49 <Ares> [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,-1,-1,-1,0,-1,0,-1,0,-1,-1,0,0,-1,-1,
18:26:49 <Ares> Program error: divide by zero
18:26:57 <omnId> neat!
18:27:10 <omnId> that's Int overflow for you.
18:27:47 <chessguy> @quote monochrom
18:27:47 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
18:27:47 <lambdabot> entire human race would have to be rewritten!
18:27:49 <omnId> Ares: change 'pos' into 'map fromIntegral pos' and get rid of the annotation.
18:28:06 <Ares> ok
18:28:11 <chessguy> Bird has a haskell book?
18:28:18 <chessguy> @go haskell bird
18:28:19 <lambdabot> http://www.garden-fountains.com/Detail.bok?no=636
18:28:20 <lambdabot> Title: Garden Fountains: Haskell Bird Bath
18:28:24 <faxathisia> haaha
18:28:28 <chessguy> gee, thanks LB
18:28:33 <monochrom> "Introduction to Functional Programming Using Haskell"
18:28:39 <faxathisia> "The subtle design of the Haskell Bird Bath make this piece a must-have for any outdoor setting"
18:28:39 <chessguy> @go haskell bird book
18:28:43 <lambdabot> http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460
18:28:50 <chessguy> that's more like it
18:29:27 <LoganCapaldo> lambdabird
18:30:06 <chessguy> wasn't bird the one that wrote "Purely functional data structures" or some such ilk?
18:30:28 <chessguy> @go bird functional data structure
18:30:30 <dcoutts> no
18:30:31 <lambdabot> http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
18:30:38 <chessguy> ohhh, right, okasaki
18:30:50 <omnId> common mistake, very similar, those
18:30:57 <omnId> :P
18:31:12 <omnId> "the keys a like right next to each other"
18:31:47 * kfish needs that book to lead him away from IORefs
18:32:08 <LoganCapaldo> Step away from teh IORef
18:32:12 * monochrom also <3 http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X
18:32:15 <lambdabot> http://tinyurl.com/yq43nw
18:32:39 <faxathisia> kfish: I really enjoyed the stuff about type level insanity, thanks for that!
18:32:53 <kfish> faxathisia, cool, glad you enjoyed it :-)
18:33:16 <LoganCapaldo> monochrom: that book looks like, dare I say this?, fun.
18:33:21 * EvilTerran has had Bird for a lecturer. naturally, his book was the Official Course Textbook
18:33:37 <kfish> 1 used & new available from $652.77 ??
18:34:14 <LoganCapaldo> Yeah I don't know if it looks that fun
18:34:32 <monochrom> It's pretty close to out-of-print. Perhaps it has attained collector-item status. :)
18:35:12 <LoganCapaldo> http://www3.addall.com/New/compare.cgi?dispCurr=USD&id=54442&isbn=013507245X&location=10000&thetime=20071107183444&author=&title=&state=AK
18:35:14 * monochrom bought one at a normal price while it lasted :)
18:35:15 <lambdabot> Title: AddAll Book Searching and Price Comparison - submit, http://tinyurl.com/yr3uvt
18:35:22 <LoganCapaldo> You may want to change the state
18:41:18 <salierix> How do I make a new data structure from and old one but with some changed elements?
18:42:26 <LoganCapaldo> zipper!
18:42:26 <faxathisia> salierix: like turn a Maybe 5 into Maybe 6?
18:43:38 <salierix> Or having a structure containing named fields x, y, z to a new one with only x changed.
18:43:51 <faxathisia> so what does your data structure look like?
18:43:53 <omnId> oldValue { x = newX }
18:43:57 <LoganCapaldo> ^^
18:44:16 <salierix> Oh is that all?
18:44:35 <salierix> thanks.
18:44:39 <omnId> without records, you could do: let Con _ y z = oldValue in (Con newX y z)
18:51:52 <omnId> '(\(Con _ y x) -> Con newX y z) oldValue', 'case oldValue of Con _ y z -> Con newX y z', there's a bunch of ways to pattern-match.
18:58:19 <ddarius> runIdentity $ do Con _ y z <- return oldValue; return Con newX y z
18:58:49 <ddarius> head [Con newX y z | Con _ y z <- [oldValue]]
19:03:06 <faxathisia> :t coerce
19:03:14 <lambdabot> Not in scope: `coerce'
19:03:26 <LoganCapaldo> bad faxathisia !
19:03:38 * faxathisia cowers
19:04:04 <mwc> indeed. Curry-Howard should send you fleeing from anything with a type a -> b
19:06:33 <EvilTerran> coerce :: (Typeable a, Typeable b) => a -> Maybe b -- iirc, incidentally
19:06:43 <faxathisia> well
19:06:47 <EvilTerran> ?type cast -- actually, it's called cast
19:06:49 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
19:07:01 <faxathisia> coerce e = unsafePerformIO $ do writeIORef globalRef e ; readIORef globalRef
19:07:12 <EvilTerran> but that's somewhat in the category of More Magic
19:07:28 <EvilTerran> yyyeah, don't do that one
19:07:35 <faxathisia> hey it's not me :p
19:07:48 <faxathisia> I am wondering why this is done
19:08:13 <EvilTerran> the Typeable-based cast doesn't actually do any conversion between values of different types
19:08:13 <omnId> if he's using usafePerformIO anyway, he had might as well use unsafeCoerce#
19:08:24 <ddarius> :t unsafeCoerce x = unsafePerformIO (writeIORef ref x >> readIORef ref) where ref = unsafePerformIO (newIORef undefined)
19:08:25 <lambdabot> parse error on input `='
19:08:34 <ddarius> :t let unsafeCoerce x = unsafePerformIO (writeIORef ref x >> readIORef ref) where ref = unsafePerformIO (newIORef undefined) in unsafeCoerce
19:08:35 <lambdabot> Not in scope: `unsafePerformIO'
19:08:35 <lambdabot> Not in scope: `writeIORef'
19:08:35 <lambdabot> Not in scope: `readIORef'
19:09:16 <chessguy> hmm. i don't think i've ever seen LB gives multiple errors
19:09:24 <EvilTerran> all it does is, if the types a and b happen to be the same, give back Just <the value>, and, if they're different, give back Nothing
19:09:41 <EvilTerran> this is surprisingly powerful
19:11:47 <chessguy> hey monochrom, i'm curious if you could summarize the process described by that book, "algebra of programming".
19:12:10 <faxathisia> What's the point in this coercion
19:13:00 <EvilTerran> faxathisia, what, the one full of unsafeness?
19:13:04 <faxathisia> yes
19:13:08 <faxathisia> :: a -> b
19:14:08 <EvilTerran> if you know that two terms are the same type, can prove it, but the typechecker can't prove it, then you can use it to move between the types
19:14:25 <EvilTerran> the Typeable cast does this under the hood, i believe
19:15:08 <faxathisia> ok
19:15:16 <faxathisia> I'm going to stare at this code til my head explodes then
19:15:33 <chessguy> A category C consists of:
19:15:33 <chessguy> a collection of objects Obj(C);
19:15:43 <chessguy> is that word "collection" a technical term?
19:15:46 <EvilTerran> cast ::(Typeable a, Typeable b) => a -> Maybe b; cast x = if typeOf a == typeOf (undefined :: b) then Just ({- we know the types match up, so this is safe -} unsafeCoerce# x) else Nothing
19:15:58 <EvilTerran> sort of thing
19:16:17 <EvilTerran> chessguy, not that i know of. naive set, maybe?
19:17:14 <ddarius> Not usually.
19:17:17 <EvilTerran> i think it's anything that supports a containment relation
19:17:25 <EvilTerran> depending on context. so usually set.
19:17:30 <ddarius> Usually it's there to avoid saying "set" because many categories are proper classes
19:18:31 <chessguy> ah, fair enough
19:18:33 <EvilTerran> http://mathworld.wolfram.com/SetClass.html ?
19:18:34 <lambdabot> Title: Set Class -- from Wolfram MathWorld
19:23:55 <typ22> hi, I have a noobish question - how can handle "Exception: Prelude.read: no parse" caused by someone just hitting return at a getLine?
19:25:19 <sw17ch> :t Prelude.read
19:25:21 <lambdabot> forall a. (Read a) => String -> a
19:25:45 <sw17ch> typ22: probably because read isn't able to parse the specific type you're trying to come up with
19:25:51 <EvilTerran> :t readsPrec
19:25:52 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
19:29:46 <typ22> oh I see, I think I solved that by adding :: String after my read
19:35:32 <blackdog> (t
19:43:47 --- mode: irc.freenode.net set +o ChanServ
19:45:31 <goalieca> wohoo no more netsplit
19:45:41 <Pseudonym> Woo.
20:11:08 --- mode: irc.freenode.net set +o ChanServ
20:11:39 <chessguy> man, what's with all the splits tonight
20:11:46 * chessguy sighs
20:11:46 <mwc> holy freaking netsplit
20:11:57 <mwc> dunno, guess we can't blame it on lilo though
20:12:01 <mwc> too soon?
20:13:45 <goalieca> chessguy, netsplits all week actually
20:15:19 <chadz> any word when the language benchmark game'll be updated with 6.8.1 results?
20:15:51 <mwc> Oh crap
20:15:59 <TomMD> chadz: if your curious, check out the performance improvement on my MD5 routine on sequence.complete.org
20:16:11 <mwc> my 6.7.20070827 bug is still alive and kicking in 6.8.1 :(
20:17:03 <TomMD> mwc: which one is that?
20:17:28 <swaydam> anyone interested in making money with me online?
20:18:01 <chessguy> dons, Cale
20:18:03 <faxathisia> swaydam: I think you have the wrong channel
20:18:15 <SamB_XP> yes, I would be happy to cheat at poker with you
20:18:16 * chessguy can never remember who the ops around here are
20:18:27 <swaydam> is ther a biz channel on this server?
20:18:31 <Olathe> /cs access #haskell list
20:18:40 <faxathisia> swaydam: please go to #help
20:18:49 <chadz> TomMD: reading.
20:19:10 <chessguy> Olathe, i'll never remember that command :)
20:19:19 <chessguy> i hate irc syntax
20:19:29 <shachaf> chessguy: /msg chanserv help
20:19:57 <SamB_XP> I think /cs stands for /msg chanserv
20:20:06 <Olathe> /cs help
20:20:10 <SamB_XP> in what Olathe said
20:20:13 <shachaf> Not every client has it.
20:20:24 <omg911> yeah i don't have that cmd...
20:20:29 <SamB_XP> I wasn't sure any client had /cs
20:20:40 <omg911> maybe it's an alias
20:20:40 <shachaf> SamB_XP: I know at least xchat does.
20:20:41 <SamB_XP> until I tried /cs hihi and chanserv gave me an error message
20:20:45 * shachaf uses irssi, which doesn't.
20:20:50 <omg911> same
20:20:55 <omnId> shachaf: 23:20 No such command.
20:20:57 <mwc> TomMD: #1564 I believe
20:21:02 <mwc> 1654
20:21:03 <shachaf> Olathe: Seems to use mIRC?
20:21:09 <shachaf> s/://
20:21:10 <Olathe> Yes.
20:21:16 <Olathe> /quote cs
20:21:26 <Olathe> You can do that, or alias cs to do that.
20:21:47 <Olathe> Yay !
20:21:52 <Olathe> More !
20:21:56 <sw17ch> this makes me so sad :(
20:22:11 <sw17ch> think of all the learning we're missing out on with these splits! =(
20:22:15 <chadz> > "i'm still here!"
20:22:17 <lambdabot>  "i'm still here!"
20:22:29 <Pseudonym> You can teach us, lambdabot.
20:22:44 <TomMD> > "I'm not a bot, I'm a real programmer"
20:22:45 <lambdabot>  "I'm not a bot, I'm a real programmer"
20:22:51 <sw17ch> > "O
20:22:52 <lambdabot>  Improperly terminated string at ""O" (column 1)
20:22:56 <lambdabot> Nah, I'm a bot.
20:22:58 <sw17ch> > "I'm also turing complete"
20:22:59 <lambdabot>  "I'm also turing complete"
20:22:59 <shachaf> > "I'm still here!" -- lambdabot can teach us about capitalization, too!
20:23:01 <lambdabot>  "I'm still here!"
20:23:12 <lambdabot> Really. Bot. Honestly.
20:23:13 * shachaf is a bot too.
20:23:27 <Pseudonym> @shachafsnack
20:23:27 <lambdabot> Unknown command, try @list
20:23:33 <shachaf> :)
20:23:35 <sw17ch> @quote bot
20:23:35 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
20:23:35 <lambdabot> like learn $ zip math haskell.
20:23:48 <shachaf> lambdabot: You don't really think that's going to fool us, right?
20:23:52 <shachaf> lambdabot: We know the truth.
20:23:55 <Olathe> @where botdeath
20:23:55 * lambdabot dies.
20:24:03 <lambdabot> There is no truth.
20:24:08 <lambdabot> Only provability.
20:24:16 <Olathe> Lies.
20:24:22 <merus> Damn lies.
20:24:27 <lambdabot> There are no lies, only contradiction.
20:24:32 <lambdabot> Oh, and statistics.
20:24:41 <Olathe> Prove it.
20:24:45 <sw17ch> now i'm afraid... i didn't know lambdabot could do that
20:24:50 <SamB_XP> lambdabot: more lies
20:24:58 <SamB_XP> oh, and you forgot DAMNED lies!
20:25:04 <lambdabot> I can't prove it. See also Goedel's second incompleteness theorem.
20:25:11 <Olathe> You can't say I'm wrong then.
20:25:23 <SamB_XP> lambdabot: isn't that just the same as the first one?
20:25:37 <lambdabot> Sequels are never as good, are they.
20:25:52 <SamB_XP> except, you know, for a different system?
20:27:58 <shachaf> lambdabot: Fine. If we accept that you're just a bot, who's driving you?
20:28:33 <lambdabot> Who's driving you?
20:28:38 <lambdabot> You claimed to be a bot.
20:28:48 <Olathe> You can't prove what you've said about "There is no truth. Only provability."
20:29:03 <Olathe> So, by your criteria, you can't really be too confident in it.
20:29:27 <lambdabot> I take it as an axiom if I'm a constructivist.
20:29:50 <lambdabot> Your inferious Platonic notion of truth is no match for robotic brute force.
20:30:08 <lambdabot> inferior, bleah. So much for robotic superiority.
20:30:08 <omnId> inferior* perhaps?
20:30:24 <shachaf> lambdabot: Do you respond to /msgs?
20:30:30 <Olathe> I don't have a Platonic notion.
20:30:31 <scook0> I like "inferious" :)
20:30:43 <Olathe> I have an empirical notion.
20:30:47 <omnId> scook0: it's a perfectly cromulent word.
20:31:00 <Olathe> Taking things as axioms doesn't avoid the problem.
20:31:10 <Pseudonym> BTW, there's an easy way to tell who's sockpuppeting the bot.
20:31:11 * shachaf is an axiom.
20:31:16 <Pseudonym> ?seen
20:31:35 <Pseudonym> You do that, and you can see who she's seen lately.
20:31:37 <Pseudonym> Including /msgs.
20:31:42 <Olathe> @seen
20:32:00 <shachaf> Pseudonym: What if you're the one?
20:32:02 <omnId> disabled in public channel for loudness.
20:32:11 <Pseudonym> You can do this to probabilistically determine who's doing it.
20:32:16 <Pseudonym> shachaf: Then I just covered my tracks.
20:32:20 <Pseudonym> :-)
20:32:21 <lekro> sorry about asking my question the third time now, but it seems that the netsplit is over:
20:32:23 <lekro> is it guaranteed that unlines always inserts '\n' and not "\r\n"?
20:32:24 <sw17ch>   omnId: before you vanish and leave me with a question... several days back... you had a function you were using to express base 36 numbers... is there a similar one that can read base 36 numbers?
20:32:27 <lekro> so that it's safe to do things like: > intersperse ' ' $ unlines <something>
20:32:35 <Olathe> @src unlines
20:32:35 <lambdabot> unlines = concatMap (++ "\n")
20:32:41 <omnId> sw17ch: check the Numeric module
20:32:46 <lekro> Olathe: my implementation does insert '\n'
20:33:02 <omnId> @docs
20:33:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:33:19 <lekro> I'm curious if this will be the same implementation on all platforms
20:33:21 <Olathe> > unlines ["test", "test"]
20:33:25 <omnId> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Numeric.html
20:33:30 <lambdabot>  "test\ntest\n"
20:33:31 <Olathe> Faster !
20:33:38 <lekro> especially platforms that don't use \n as a line separator
20:33:38 <lambdabot> http://tinyurl.com/2e2psz
20:33:53 <Olathe> I get \n on Windows.
20:34:12 <shachaf> It's either Pseudonym or sjanssen.
20:34:20 <Olathe> @src lines
20:34:20 <lambdabot> Source not found. My pet ferret can type better than you!
20:34:39 <Olathe> > lines "test\r\ntest"
20:34:40 <Pseudonym> Does it really matter?
20:34:41 <lambdabot>  ["test\r","test"]
20:34:51 <Olathe> I get the same on Windows.
20:35:03 <omnId> lekro: yep, unlines is defined to insert '\n', turning it to "\r\n" is the input/output function's responsibility.
20:35:03 <sw17ch> @src readHex
20:35:03 <lambdabot> Source not found.
20:35:09 <sw17ch> @src Numeric.readHex
20:35:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:35:23 <omnId> @source Numeric
20:35:23 <lambdabot> http://darcs.haskell.org/packages/base/Numeric.hs
20:35:40 <mrd> lambdabot: penguins wrote linux! they must be able to type well.
20:35:56 <lekro> omnId: ok, thanks
20:36:04 <Shimei> Say, I recently finished reading "Simply Easy" (paper on dependent lambda calculus). Anyone have any recommendations on further reading that's more in depth but still understandable with relatively little domain knowledge?
20:36:45 <mrd> Shimei: a recent augustss posts perhaps
20:37:00 <shachaf> lambdabot: Why don't you answer my /msgs?
20:38:14 <mrd> http://okmij.org/ftp/Computation/lightweight-dependent-typing.html
20:38:22 <lambdabot> Title: Lightweight Dependent-type Programming, http://tinyurl.com/ylrm54
20:38:40 <omnId> shachaf: she listens to mine.  Are you talking about the sockpuppeting or does she not respond to your @commands?
20:38:52 <Shimei> mrd: Ah, this? http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
20:38:57 <mrd> yea
20:39:00 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
20:39:13 <shachaf> omnId: It's not sockpuppeting.
20:39:15 <mrd> ooh so close with the tinyurl
20:39:21 <shachaf> omnId: She's persuaded me.
20:39:26 <omnId> shachaf: my mistake then :)
20:39:33 <omnId> lambdabot: sorry
20:39:38 <mrd> @vixen sorry
20:39:38 <lambdabot> don't worry about it
20:39:42 <shachaf> urgencyhook++
20:44:04 <sw17ch> @src ord
20:44:04 <lambdabot> Source not found. Do you think like you type?
20:44:53 <shachaf> @src Ord
20:44:53 <lambdabot> class  (Eq a) => Ord a  where
20:44:53 <lambdabot>     compare      :: a -> a -> Ordering
20:44:55 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:44:57 <lambdabot>     max, min         :: a -> a -> a
20:45:22 <omnId> ord c = case c of '\0' -> 0; '\1' -> 1; '\2' -> 2; etc.
20:45:41 <omnId> ... '\1114111' -> 1114111
20:45:43 <shachaf> Oh, that ord, right.
20:45:46 <shachaf> Sorry.
20:46:15 <sw17ch> omnId: is ord in Prelude somewhere?
20:46:29 <shachaf> > ord (maxBound :: Char)
20:46:30 <lambdabot>  1114111
20:46:32 <omnId> sw17ch: it'd be quite the long definition!
20:46:38 <omnId> @index ord
20:46:39 <lambdabot> Data.Char
20:46:40 <faxathisia> > chr 1114111
20:46:41 <lambdabot>  '\1114111'
20:46:45 <faxathisia> :/
20:46:59 <Pseudonym> @index fromEnum
20:46:59 <lambdabot> Prelude
20:47:02 <Pseudonym> @index toEnum
20:47:02 <lambdabot> Prelude
20:47:13 <Pseudonym> > toEnum 11141111 :: Char
20:47:14 <lambdabot>  Exception: Prelude.chr: bad argument
20:47:16 <omnId> ^ those work for ord and chr without needing imports
20:47:21 <Pseudonym> > toEnum 1114111 :: Char
20:47:22 <lambdabot>  '\1114111'
20:47:35 <Pseudonym> And they're more general.
20:47:50 * Pseudonym is leaning towards "ord" and "enum" being the Enum names
20:50:44 <sw17ch> what is the function to check if an element is in a list?
20:50:48 <omnId> elem
20:50:53 <sw17ch> merci
20:50:54 <omnId> ord c = case lookup c (zip [0..1114111] ['\0'..'\1114111']) of Just n -> n; Nothing -> error "out of Char bounds" -- I guess not too long actually.
20:50:59 <sw17ch> :t elem
20:51:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
20:51:10 <omnId> notElem for its negative
20:51:27 <omnId> (thought "negation", typed "negative")
20:52:39 <sw17ch> how about the position in a list?
20:52:45 <sw17ch> (worst algorithm ever...)
20:52:56 <omnId> :)
20:52:58 <omnId> findIndex
20:53:08 <sw17ch> > readInt 36 (\x -> elem x (['0'..'9'] ++ ['A'..'Z'])) (\x -> (ord x) - 48) "0"
20:53:10 <lambdabot>  [(0,"")]
20:53:13 <sw17ch> > readInt 36 (\x -> elem x (['0'..'9'] ++ ['A'..'Z'])) (\x -> (ord x) - 48) "9"
20:53:15 <lambdabot>  [(9,"")]
20:53:17 <sw17ch> > readInt 36 (\x -> elem x (['0'..'9'] ++ ['A'..'Z'])) (\x -> (ord x) - 48) "A"
20:53:18 <lambdabot>  [(17,"")]
20:53:20 <sw17ch> :(
20:53:44 <omnId> (ord x) - 48 no workie
20:54:00 <sw17ch> yeah... because stuff exists between 9 and 'A'
20:56:45 <newsham> > ord 'A' - 48
20:56:47 <lambdabot>  17
20:57:22 <newsham> > ord 'f' - ord 'a' + 10
20:57:24 <lambdabot>  15
20:58:42 <omnId0> > let digs = ['0'..'9']++['A'..'Z'] in map (readInt 36 (`elem` digs) (fromJust . flip findIndex digs . (==))) ["0", "9", "A"] -- sw17ch
20:58:43 <lambdabot>  [[(0,"")],[(9,"")],[(10,"")]]
20:59:05 <newsham> > elemIndex 'c' "0123456789ABCDEF"
20:59:07 <lambdabot>  Nothing
20:59:11 <newsham> > elemIndex 'C' "0123456789ABCDEF"
20:59:13 <lambdabot>  Just 12
20:59:38 <omnId0> @type (elemIndex, findIndex)
20:59:40 <lambdabot> forall a a1. (Eq a) => (a -> [a] -> Maybe Int, (a1 -> Bool) -> [a1] -> Maybe Int)
20:59:46 <omnId0> ah.
21:00:10 <omnId0> > let digs = ['0'..'9']++['A'..'Z'] in map (readInt 36 (`elem` digs) (fromJust . flip elemIndex digs)) ["0", "9", "A"]
21:00:12 <lambdabot>  [[(0,"")],[(9,"")],[(10,"")]]
21:00:16 <sw17ch> > let digs = ['0'..'9'] ++['A'..'Z'] in readInt 36 (\x -> elem x digs) elemIndex "A"
21:00:17 <lambdabot>  Couldn't match expected type `Int'
21:00:38 <sw17ch> > let digs = ['0'..'9'] ++['A'..'Z'] in readInt 36 (\x -> elem x digs) (elemIndex) "A"
21:00:39 <lambdabot>  Couldn't match expected type `Int'
21:00:45 <omnId0> sw17ch: you also need fromJust to convince elemIndex that it's in the list.
21:00:51 <sw17ch> > let digs = ['0'..'9'] ++['A'..'Z'] in readInt 36 (\x -> elem x digs) (fromJust .elemIndex) "A"
21:00:51 <lambdabot>  Couldn't match expected type `Maybe a'
21:01:00 <sw17ch> > let digs = ['0'..'9'] ++['A'..'Z'] in readInt 36 (\x -> elem x digs) (fromJust $ elemIndex) "A"
21:01:01 <lambdabot>  Couldn't match expected type `Maybe a'
21:01:05 <omnId0> sw17ch: and the list of digits to search :P
21:01:13 <newsham> > mapM (`elemIndex` "0123456789ABCDEF") "DEADF00D1CAFEBABE34"
21:01:14 <lambdabot>  Just [13,14,10,13,15,0,0,13,1,12,10,15,14,11,10,11,14,3,4]
21:01:49 <sw17ch> :t elemIndex
21:01:50 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
21:02:43 <sw17ch> > let digs = ['0'..'9'] ++['A'..'Z'] in readInt 36 (\x -> elem x digs) (fromJust . (\x -> elemIndex digs x)) "A"
21:02:44 <lambdabot>  Couldn't match expected type `[[Char]]'
21:03:28 <sw17ch> > elemIndex ['0'..'9'] ++['A'..'Z'] '9'
21:03:28 <lambdabot>  Couldn't match expected type `[a]'
21:03:29 <omnId0> > let digs = ['0'..'9']++['A'..'Z'] in sum . zipWith (*) (iterate (*36) 1) . reverse . map (`elemIndex` digs) $ "DEADBEEF"
21:03:30 <lambdabot>   add an instance declaration for (Num (Maybe Int))
21:03:33 <sw17ch> > elemIndex ['0'..'9'] ++['A'..'Z'] "9"
21:03:34 <lambdabot>  Couldn't match expected type `[a]'
21:03:44 <sw17ch> > elemIndex '9' ['0'..'9'] ++['A'..'Z']
21:03:45 <lambdabot>  Couldn't match expected type `[a]'
21:03:51 <omnId0> > let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*36) 1) . reverse) . map (`elemIndex` digs) $ "DEADBEEF"
21:03:52 <lambdabot>  Couldn't match expected type `[a]'
21:04:07 <omnId0> > let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*36) 1) . reverse) . mapM (`elemIndex` digs) $ "DEADBEEF"
21:04:09 <lambdabot>  Just 1864094375
21:04:14 <omnId0> \o/
21:04:22 <sw17ch> for lambda's sake... i need to do my history homework
21:05:07 <sw17ch> > fromJust $ let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*36) 1) . reverse) . mapM (`elemIndex` digs) $ "DEADBEEF"
21:05:08 <lambdabot>  1864094375
21:05:14 <newsham> > liftM (foldl' (\a b -> a*16+b) 0) $ mapM (`elemIndex` "0123456789ABCDEF") "1BADD00D"
21:05:16 <lambdabot>  Just 464375821
21:11:52 <newsham> newsham@lenoxp2$ hex 464375821
21:11:52 <newsham> 1badd00d
21:11:52 <lekro> when I call a function with a (compile-time) constant value, will the result normally be cached (ghc-6.6)?
21:11:52 <sw17ch> > fromJust $ let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*(length digs)) 1) . reverse) . mapM (`elemIndex` digs) $ "DEADBEEF"
21:11:52 <lambdabot>  1864094375
21:11:52 <sw17ch> > fromJust $ let digs = ['0'..'9']++['A'..'X'] in fmap (sum . zipWith (*) (iterate (*(length digs)) 1) . reverse) . mapM (`elemIndex` digs) $ "LAMBDA"
21:11:52 <lambdabot>  968385120
21:11:52 <sw17ch> > fromJust $ let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*(length digs)) 1) . reverse) . mapM (`elemIndex` digs) $ "LAMBDA"
21:11:52 <lambdabot>  1287627022
21:11:52 <sw17ch> > fromJust $ let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*(length digs)) 1) . reverse) . mapM (`elemIndex` digs) $ "SW17CH"
21:11:52 <lambdabot>  1746856817
21:11:52 <omnId0> > let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*36) 1)) . mapM (`elemIndex` digs) . reverse $ "SW17CH"
21:11:52 <lambdabot>  Just 1746856817
21:11:52 <lekro> because that'd explain why my program fills up the memory
21:11:52 <Ares> I have a little problem
21:11:52 <Ares> I am trying
21:11:52 <Ares> can I paste like 5 lines here?
21:11:52 <newsham> > liftM (foldl' (\a b -> a*36+b) 0) $ mapM (`elemIndex` (['0'..'9']++['A'..'Z']) "SW17CH"
21:11:52 <lambdabot> Unbalanced parentheses
21:11:52 <omnId> Ares: use hpaste.org
21:11:52 <newsham> > liftM (foldl' (\a b -> a*36+b) 0) $ mapM (`elemIndex` (['0'..'9']++['A'..'Z'])) "SW17CH"
21:11:52 <lambdabot>  Just 1746856817
21:11:52 <omnId> ?paste
21:11:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:11:52 <O1athe> Yay !
21:11:52 <Korollary> yeah about 5 is ok.
21:11:52 <sw17ch> so... readInt apparently isn't as cool then eh? =)
21:11:52 <newsham> > liftM (foldl' (\a b -> a*36+b) 0) $ mapM (`elemIndex` (['0'..'9']++['A'..'Z'])) "!SW17CH"
21:11:52 <lambdabot>  Nothing
21:11:52 <lekro> can I prevent ghc from caching constant values?
21:11:52 <lekro> that is, compile-time constant
21:11:52 <hpaste>  Ares pasted "(no title)" at http://hpaste.org/3746
21:11:52 <lekro> my problem is that I have a huge lazy generated game tree.
21:11:52 <lekro> In each game only a small fraction is actually evaluated.
21:11:52 <Ares> when I try
21:11:52 <Ares> select [3,35,6,5,3,4]
21:11:52 <lekro> but if ghc caches the game tree the garbage collector doesn't collect any branches
21:11:52 <Ares> I get a Type error
21:11:52 <omnId> Ares: :t select
21:11:52 <Ares> what does that do?
21:11:52 <Ares> :t select?
21:11:52 <lambdabot> parse error (possibly incorrect indentation)
21:11:52 <lekro> what's with all these netsplits this evening?
21:11:56 <omnId> Ares: asks ghci for select's type.
21:11:58 <Cale> lekro: the internet keeps breaking - apparently they're going to take be taking it down for maintenance for a few hours sometime this week
21:12:05 <Cale> lekro: ;)
21:12:57 * omnId wishes xchat did netsplit/netjoin name folding.
21:13:04 <faxathisia> irssi does
21:13:07 * sw17ch wishes like omnId does
21:14:52 <sw17ch> > fromJust $ let digs = ['0'..'9']++['A'..'Z'] in fmap (sum . zipWith (*) (iterate (*(length digs)) 1) . reverse) . mapM (`elemIndex` digs) $ "SW17CH"
21:14:55 <lambdabot>  1746856817
21:15:04 <lekro> I guess it's a bad time for asking questions right now. Just in case nobody saw it: Is there a way to force re-evaluation of a term as opposed to the caching that seems to apply to compile-time constant values (ghc-6.6)?
21:15:05 <hpaste>  Ares pasted "(no title)" at http://hpaste.org/3747
21:15:07 <omnId> Ares: select's second case looks malformed
21:15:23 <Ares> I just changed it omnid
21:15:30 <Ares> I was testing it when I pasted it
21:15:30 <Korollary> lekro: I don't know. What are you trying to do do?
21:15:59 <Ares> can you see it omnid?
21:16:11 <lekro> Korollary: I have a huge game tree which is lazily evaluated. In each game only a small fraction of the tree gets evaluated
21:16:30 <lekro> Korollary: but if the root node is cached the garbage collector doesn't seem to collect anything
21:16:38 <omnId> Ares: findFirst takes two arguments, but in select, you've put its arguments in parens, which makes it into one argument.
21:17:04 <Ares> so I should remove the parentesis?
21:17:07 <lekro> I generate the tree like this: generateTree initialState, where initialState :: State and generateTree :: State -> Tree State
21:17:22 <omnId> Ares: wait while I annotate.
21:17:36 <Ares> thanks
21:17:43 <lekro> Korollary: I'd just like the garbage collector to collect something
21:17:43 <shachaf> omnId: Three arguments, actually. :-)
21:18:26 <hpaste>  omnId annotated "(no title)" with "is this what you want?" at http://hpaste.org/3746#a1
21:18:35 <lekro> Korollary: after a few hundred games the program had like 1GB of memory reserved
21:18:53 <lekro> Korollary: after 1 game it only claims a few megabytes
21:19:00 <omnId> shachaf: right, I was maybe thinking removeAt
21:19:34 <sjanssen> lekro: does running the same game 100 times occupy constant memory?
21:19:52 <lekro> sjanssen: hm, I should check that.
21:20:13 <omnId> Ares: FYI: largest and findFirst are already in the libs.
21:20:20 <Ares> I know
21:20:27 <Ares> byut I have to do it this way
21:21:01 <Ares> can you annotate on the second one?
21:21:13 <Ares> http://hpaste.org/3747
21:21:14 <Ares> please
21:22:13 <omnId> in 'removeAt (a findFirst ( a 77 0))', 77 and 0 are passed to the 'a' function, and its result, along with findFirst, is again passed to 'a'.
21:22:20 <lekro> sjanssen: yes, it only needs constant memory in that case
21:22:30 <omnId> this is presumably not what you want, especially since a isn't a function.
21:23:08 <Ares> I changed it
21:23:18 <lekro> sjanssen: and in all games after the first one the AI opponent is much faster, so there seems to be caching
21:23:20 <Ares> the 77 is supposed to be largest a 0
21:23:32 <Ares> check this link
21:23:33 <Ares> http://hpaste.org/3747
21:23:48 <omnId> Ares: parens don't surround function arguments, they just group where to apply functions in each subexpression.
21:24:32 <omnId> I presume you want 'removeAt a (findFirst a (largest a 0) 0)' for your second paste
21:25:06 <lekro> sjanssen: where "much faster" can only mean (IMHO) that the game tree is cached, not the result of the AI function
21:25:15 <sjanssen> lekro: yes, sounds like it
21:25:30 <Ares> thank
21:26:08 <lekro> so I guess the problem is that huge branches of the game tree are still in memory and (obviously) still referenced through the root, so they cannot be garbarge collected
21:26:13 <omnId> Ares: do you see why that's correct and yours isn't?
21:26:22 <lekro> is there some way to fix this?
21:26:32 <sjanssen> lekro: is this tree a top level constant?
21:26:42 <Ares> yes
21:26:45 <Ares> the grouping
21:26:49 <Korollary> lekro: How do you think a top level constant is going to be discarded and reloaded?
21:26:50 <Ares> thanks
21:26:51 <lekro> sjanssen: the initialState is a top level constant
21:27:25 <lekro> sjanssen: and in main I have (treeFromState initialState)
21:27:59 <lekro> the tree itself is not a top-level constant
21:28:24 <Korollary> but you use the same tree over and over?
21:28:34 <omnId> > (\xs -> xs \\ [maximum xs]) [1,2,9,3,4,5]
21:28:37 <lambdabot>  [1,2,3,4,5]
21:28:46 <lekro> the IO action with (treeFromState initialState) in it gets executed many times
21:28:46 <Cale> lekro: you can turn something into a function, which will cause it to be reevaluated every time it's applied
21:29:11 <Cale> say, of the parameter ()
21:29:14 <lekro> Cale: treeFromState is a function
21:29:29 <Cale> yeah, so it won't be memoised
21:29:50 <lekro> it is, though
21:29:53 <Cale> Perhaps I don't understand your issue?
21:29:54 <Ares> now
21:30:22 <Ares> lets assume I call select in a differnt fucntion how can I divide the pair?
21:30:40 <Cale> Oh, I suppose that if initialState is a constant as well, then it's a CAF
21:30:40 <lekro> Korollary: effectively, it seems to be the same tree (in a low level view). But in the code I call (treeFromState initialState) each time a new game is started
21:30:46 <lekro> CAF?
21:30:52 <Cale> Constant applicative form
21:31:24 <omnId> Ares: pattern match
21:31:30 <omnId> Ares: or else use fst and snd
21:31:53 <omnId> let (x, xs) = select ... in ...
21:32:16 <Cale> http://foldoc.org/index.cgi?query=constant+applicative+form&action=Search
21:32:18 <lambdabot> Title: constant applicative form from FOLDOC, http://tinyurl.com/2gmrk2
21:32:42 <omnId> @let select xs = (max, delete max xs) where max = maximum xs
21:32:54 <lambdabot> Defined.
21:33:15 <omnId> > let (m, xs) = select [1,5,9,2,6,4] in m
21:33:16 <lambdabot>  9
21:33:30 <lekro> Cale: "A CAF can always be lifted to the top level of the program" hm... how can I change the call so that it's not a CAF?
21:33:50 <Pseudonym> > zipWith(!!)(fix(([1]:).map(>>= \x->1:if x==0then[]else[0])))[0..]
21:33:52 <lambdabot>  [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1...
21:34:07 <omnId> > cycle [1,0,1]
21:34:08 <lambdabot>  [1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0...
21:34:21 <Cale> I suppose you turn it into a function of an unused parameter
21:34:42 <lekro> Cale: like, const f 0 instead of f?
21:34:44 <Cale> initialTree x = treeFromState initialState
21:35:14 <sjanssen> and be sure to {-# NOINLINE initialTree #-}
21:35:26 <Cale> right :)
21:36:19 <Ares> thanks a lot omnid
21:36:20 <Ares> :)
21:36:23 <Pseudonym> > zipWith(!!)(fix(([1]:).map(>>= \x->1:[[0]|x==1])))[0..]
21:36:24 <lambdabot>   add an instance declaration for (Num [t])
21:36:27 <Ares> and have a great night :)
21:36:51 <omnId> righty-o
21:38:00 <Pseudonym> > zipWith(!!)(fix(([1]:).map(>>= \x->1:[0|x==1])))[0..]
21:38:02 <lambdabot>  [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1...
21:38:03 <Pseudonym> There.
21:38:27 <Pseudonym> I think that's the smallest I can smoosh it down.
21:38:57 <omnId> doesn't zipWith(!!)xs[0..] == xs?
21:39:07 <Pseudonym> No.
21:39:20 <Pseudonym> zipWith (!!) xss [0..] is diagonalisation.
21:39:22 <lekro> Cale: does it matter what the actual argument is for this unused parameter?
21:39:32 <Cale> lekro: It shouldn't.
21:39:33 <omnId> oh, silly me
21:40:05 <lekro> Cale: because now I have (initialTree undefined) at it still fills up the memory
21:40:24 <Cale> and you're sure that this is what's causing the problem?
21:40:27 <lekro> with {-# NOINLINE initialTree #-}
21:40:27 <lekro> initialTree _ = treeFromState initialState
21:40:33 <omnId> Pseudonym: [x|bool] is an evil trick :)
21:41:26 <lekro> Cale: no, but it seemed probable because it's constant memory if the same game is played hundreds of times
21:41:28 <omnId> (fix(([1]:).map(>>= \x->1:[0|x==1])))
21:41:29 <omnId> > (fix(([1]:).map(>>= \x->1:[0|x==1])))
21:41:31 <lambdabot>  [[1],[1,0],[1,0,1],[1,0,1,1,0],[1,0,1,1,0,1,0,1],[1,0,1,1,0,1,0,1,1,0,1,1,0]...
21:42:03 <lekro> I guess this is the time where I'll have to look into heap profiling
21:42:40 <Pseudonym> omnId: Actually, I don't think it's evil at all.
21:42:51 <Pseudonym> It's really common in nondeterministic programming.
21:42:55 <Pseudonym> Well, in mine it is, anyway.
21:43:06 <omnId> =)
21:55:23 <lekro> hm, profiling turns out to be really difficult. On the fast machine ghc doesn't support profiling and on my notebook the program takes 10 times as long.
21:56:13 <lekro> I am considering to postpone this problem since it only shows up after a few dozens of games, which no one will play by hand anyway
21:59:57 <monochrom> hey
22:16:57 <sw17ch> these splits are depressing =(
22:22:50 <omg911> quiet now..
22:27:42 <newsham> irc is broken
22:27:47 <newsham> ?stats
22:27:47 <lambdabot> Unknown command, try @list
22:30:24 <ivanm> they're having routing problems, apparently
22:46:24 <RayNbow> @src iterate
22:46:24 <lambdabot> iterate f x =  x : iterate f (f x)
22:49:40 <Olathe> @src halts
22:49:40 <lambdabot> Source not found. My mind is going. I can feel it.
22:50:50 <sw17ch> iterate is a fantastic function
22:51:24 <sw17ch> > take 5 $ iterate (\x -> "f(" ++ x + ")") "x"
22:51:25 <lambdabot>   add an instance declaration for (Num [Char])
22:51:32 <sw17ch> > take 5 $ iterate (\x -> "f(" ++ x ++ ")") "x"
22:51:33 <lambdabot>  ["x","f(x)","f(f(x))","f(f(f(x)))","f(f(f(f(x))))"]
22:52:31 <Olathe> > iterate ('A':) "!"
22:52:32 <lambdabot>  ["!","A!","AA!","AAA!","AAAA!","AAAAA!","AAAAAA!","AAAAAAA!","AAAAAAAA!","AA...
22:56:00 <Mr_Awesome> oops
22:56:15 <thetallguy> Any know if there's a way to make strings span lines?
22:56:50 <Mr_Awesome> i think putting a '\' at the end of the line allows you to continue it
22:57:37 <thetallguy> Not working for me
22:57:56 <thetallguy> I can never remember this from one language to the next
22:58:24 <ivanm> and you need another \ on the next line...
22:58:26 <faxathisia> I don't think you can do that in haskell can you?
22:58:33 * ivanm has seen it, but never used it myself
22:58:51 <ivanm> i.e. "this is a \ <newline> \ broken string"
22:59:06 <ivanm> if not that, then end the string and continue with ++ on the next line
22:59:07 <thetallguy> Thank you.  That's it.
23:15:49 <goalieca> maybe the should run the irc servers on haskell ;)
23:17:42 <faxathisia> I think it's fair to actually blame the IRC protocol
23:20:16 <kfish> faxathisia, how would you design a better protocol?
23:21:05 <kfish> (serious question, it's quiet in here, and distributed protocols are fun)
23:21:36 <kfish> well, not that much fun
23:21:58 <faxathisia> mm that's a hard question..
23:22:50 <faxathisia> I suppose some support for moving clients to another server transparently would get rid of all this netsplit stuff
23:23:08 <faxathisia> but then I think the servers would have to buffer a lot more data than before so it might not be feasable
23:27:25 <sorear> kfish: there's always jabber
23:29:46 <sorear> heh, so THAT's what a netsplit looks like when you join in the middle defeating irssi's collapser
23:31:01 <allbery_m> yeh
23:38:23 <div> Is haskell sexy for commercial usage?
23:39:19 <wilx> Seems it is, some banks use it.
23:39:33 <wilx> I mean, there are banks that use it.
23:39:58 <div> wilx, isn't there a better choice for them
23:40:13 <div> or they use it because their programmers liked it?
23:41:15 <wilx> I am sure they do not let lowly programmers make such choices.
23:42:18 <Korollary> the question is too general
23:42:18 <LeCamarade> Tell me, is ++ implemented inside the compiler?
23:42:25 <wilx> http://www.haskell.org/haskellwiki/Haskell_in_industry
23:42:26 <lambdabot> Title: Haskell in industry - HaskellWiki
23:42:31 <sjanssen> LeCamarade: nope
23:42:37 <sjanssen> @src (++)
23:42:38 <lambdabot> (++) []     ys = ys
23:42:38 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
23:42:41 <LeCamarade> ?src ++
23:42:42 <lambdabot> (++) []     ys = ys
23:42:42 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
23:42:52 <goalieca> but : is
23:42:54 <LeCamarade> Don't look normal, do it?
23:43:07 <sjanssen> the actual definition in GHC isn't quite like that, IIRC
23:43:23 <sjanssen> more likely xs ++ ys = foldr (:) ys xs
23:43:32 <LeCamarade> sjanssen: But that suffices, yet it seems like _|_
23:43:53 <LeCamarade> Okay.
23:43:56 <LeCamarade> hold on.
23:44:01 <sjanssen> LeCamarade: why does it seem like _|_?
23:44:01 <goalieca> it seems like everything in haskell ends up with a fold which itself is defined using simple recursion
23:44:19 <sorear> ?quote flux
23:44:19 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
23:44:19 <lambdabot> for your entire program.")
23:44:38 <goalieca> sounds about right!
23:46:33 <LeCamarade> sjanssen: So the list doesn't just append x to the tail of y when Ido x ++ y ?
23:46:48 <thetallguy> What's the zero element for a fluxbox list?
23:46:52 <LeCamarade> It actully foldeth? Don' sound too performant.
23:46:55 <div> Is it possible to link between a functional program and impretive program? how?
23:47:27 <LeCamarade> div: With monads.
23:47:39 <LeCamarade> Answer to all the world's problems.
23:47:40 <faxathisia> how about with TCP
23:47:51 <faxathisia> you can communicate between programs
23:47:52 <sorear> div: you can imbed imperative code in functional languages using the 'IO' functor
23:48:17 <sorear> div: and imperative code can pretend functional code is just a procedure with no effects
23:48:21 <div> sorear,can you show me some tutorials about it?
23:48:27 <sjanssen> LeCamarade: I think you're a bit confused :)
23:48:55 <sjanssen> LeCamarade: firstly, the compiler can't modify either list in place
23:49:51 <sjanssen> LeCamarade: secondly, the compiler doesn't keep a special pointer to the very last cell of the list
23:53:16 <LeCamarade> Oh. Now it cometh in clear.
23:53:36 <LeCamarade> Heh. I had a wrong idea of how the list goes.
23:53:59 <LeCamarade> Okay. Lemme go back tomy e-exile. I'm abstaining from computers.
23:58:53 <hpaste>  dikini pasted "I'm out of ideas, can you help?" at http://hpaste.org/3748
