00:19:02 * srid looks around
00:20:05 <Spark> in operational semantics, where blah ⇝ blah'
00:20:10 <Spark> what is blah' usually called?
00:20:12 <Spark> the target?
00:20:26 <Spark> (small step operational semantics)
00:20:39 <Spark> i keep thinking the reduct, but in this case i think that's actually "blah"
00:20:39 <dobblego> codomain?
00:20:55 <Spark> i mean the particular thing, that blah happened to reduce to
00:21:28 <Spark> "the reduction" would correspond to the whole judgement "blah ⇝ blah'", right?
00:24:06 <rue> Spark: Just as an aside, that looks like  "blah ae-box-box blah'" to me with my archaic IRC client and may be the case for others
00:24:34 <Spark> i think in latex it is \Rightsquigarrow
00:24:47 <Spark> or just \rightsquigarrow
00:24:54 <Spark> it's not double thickness
00:25:06 <Spark> not that it matters, people tend to use whatever arrow they feel like :)
00:27:35 <oerjan> Spark: at least for lambda calculus, reduct seems to denote the result of reducing a redex
00:27:42 <Spark> does it?
00:28:00 <Spark> maybe my mind isn't as miswired as i thought
00:28:13 <Spark> in which case i should feed it more drugs
00:29:06 <Spark> i can't find any use of it online
00:29:10 <Spark> in this context anyway
00:29:15 <Spark> "reduct" that is
00:29:23 <Spark> Jump to: navigation, search
00:29:25 <Spark> In universal algebra and in model theory, a reduct of an algebraic structure is obtained by omitting some of the operations and relations of that structure. The converse of "reduct" is "expansion."
00:29:31 <oerjan> http://www.mscs.dal.ca/~selinger/papers/lambdanotes.pdf
00:29:38 <oerjan> is where i found it
00:30:03 <Spark> ah yes that's pretty clear
00:30:20 <Spark> reduct it shall be
00:31:16 <oerjan> i googled for reduct lambda
00:35:00 <Spark> i'm very crap at googling
00:35:02 <Spark> i always get shit
00:37:17 <hpaste>  arossato pasted "(no title)" at http://hpaste.org/4079
00:44:11 <srid> I am struggling around exercise 4.5 in YAHT.
00:44:25 <srid> data Quadruple a a b b = Quadruple a a b b
00:44:25 <srid> firstTwo (Quadruple p q r s) = [p, q]
00:44:25 <srid> lastTwo (Quadruple p q r s) = [r, s]
00:45:36 <oerjan> srid: hm?
00:45:37 <hpaste>  srid pasted "ex 4.5 in YAHT" at http://hpaste.org/4080
00:45:48 <srid> oerjan: ^^ pasted.
00:46:14 <allbery_b> your data is wrong
00:46:18 <oerjan> srid: you've got an f at the end of data
00:46:20 <Cale> srid: The type constructor should only have two parameters
00:46:29 <srid> oerjan: err.. copy paste error. ignore that
00:46:34 <Cale> srid: That is, at the type level, it should be Quadruple a b
00:46:38 <hpaste>  (anonymous) annotated "ex 4.5 in YAHT" with "(no title)" at http://hpaste.org/4080#a1
00:46:38 <allbery_b> data Typename [typevardecls] = Constructor [typevaruses]
00:47:04 <Cale> srid: at the data level (on the right side of the = sign), is where you have two values of type a and two values of type b
00:47:05 <allbery_b> the type vars before the '=' are declarations, yyou do not repeat them
00:47:19 <srid> ah ok
00:47:36 <srid> just going through the tutorial.. yet to grast most aspects of types in haskell.
00:47:42 <allbery_b> so Quadruple takes two type parameters, each of which are used int he constructor twice
00:48:18 <allbery_b> when referring to the *type* it takes two type arguments; when referring to *data* it takes four
00:48:53 <srid> could you annotate with correct solution?
00:49:07 <Cale> srid: The confusion is most likely from the fact that you're defining two things named Quadruple, in different namespaces.
00:49:19 <Cale> srid: It might help to call the data constructor Q
00:49:24 <srid> would ':r' add to definitions?
00:49:25 <Cale> Then you'd have:
00:49:33 <Cale> data Quadruple a b = Q a a b b
00:49:49 <Cale> So then for example
00:50:04 <Cale> Q 5 6 "Hello" "World" :: Quadruple Integer String
00:50:48 <Cale> You're allowed to name the data constructor the same thing as the type constructor if you want, because they exist in completely separate worlds, on the left and right of the ::
00:52:04 <srid> Cale: No instance for (Show (Quadruple t [Char]))
00:52:24 <Cale> srid: You can add  deriving (Show)  to the end of your data declaration
00:52:46 <Cale> Which will automatically write the code for turning a value of that type into a String.
00:55:16 <hpaste>  (anonymous) annotated "ex 4.5 in YAHT" with "(no title)" at http://hpaste.org/4080#a2
00:56:26 <srid> Cale: why does it work with a different name (Q)?
00:56:46 <srid> .. while ``data Pair a b = Pair a b`` in the tutorial worked.
00:56:49 <Cale> srid: the two instances of the name Quadruple refer to completely different things, in different namespaces
00:57:02 <Cale> The one on the left of the = sign in the data declaration is a type constructor
00:57:09 <Cale> It lives in the world of types
00:57:15 <srid> ok - let me read further.
00:57:20 <Cale> The one on the right of the = sign is a data constructor
00:57:28 <Cale> It lives in the world of values
00:58:27 <Cale> So Quadruple as a type constructor takes two type parameters: the type of the first two parts of the quadruple, and the type of the second two parts.
00:58:52 <Cale> Quadruple as a data constructor takes 4 parameters: the first two being of the first type, and the second two being of that second type.
00:59:23 <srid> ok.
00:59:29 <srid> I guess I need to read more. thanks :)
00:59:39 <srid> YAHT has been pleasing so far.
00:59:52 <Cale> Yeah, this is one place where it kind of falls down.
01:00:11 <Cale> Almost everyone has trouble with this problem.
02:41:22 <firefly> does anybody have an idea on how to feed C-- /into/ ghc?
02:41:52 <firefly> I'd like to to make an experiment with peephole optimization on the C-- code.
02:58:56 <allbery_b> firefly: best to ask in #ghc, I think, but I don't think it's designed to take cmm input
02:59:43 <firefly> I didn't want to bother them with something that wasn't /really/ about ghc development.  If nothing comes out of the experiment then it won't help ghc at all.
02:59:45 <phlpp> hi
02:59:53 <firefly> No, I don't think it can take C-- either :(
03:00:20 <firefly> so no matter what, I'll most likely have to add some code first before I can experiment.
03:02:41 <swiert> hi phlpp
03:03:45 <swiert> phlpp: learning Haskell?
03:11:34 <swiert> waern: Do you know when haddock 2.0 will be out?
03:11:48 <phlpp> swiert: there's nobody who knows all about haskell
03:13:17 <swiert> phlpp: well the basics are pretty well-understood. A lot of the wacky extensions can be a bit puzzling.
03:15:05 <waern> swiert: I hope to get it out after 6.8.2 is out
03:15:20 <swiert> waern: Any idea when that will happen ;) ?
03:15:58 <waern> swiert: in two weeks was the last I heard
03:16:08 <swiert> Ah - great!
03:16:46 <swiert> I can't wait to use haddock 2.0. I'm kind of sitting on some code I'd like to release, but it really needs a few non-Haskell 98 extensions.
03:17:35 <waern> swiert: is the repository publically available? I'm looking for testing material
03:18:04 <swiert> waern: darcs get http://www.cs.nott.ac.uk/~wss/repos/IOSpec
03:18:05 <lambdabot> Title: IOSpec
03:18:15 <waern> swiert: Haddock is buildable with 6.8.1 btw (code.haskell.org/haddock)
03:18:18 <swiert> It really needs infix type constructors.
03:18:26 <swiert> Ok. I'll give it a go.
03:19:08 <waern> ah, infix type constructors should work... conal has already asked me for them :)
03:19:44 <swiert> waern: what about infix class constructors?
03:20:40 <waern> hmm
03:20:47 <waern> good question
03:23:58 <firefly> there seems to be code for reading C-- files :)  http://darcs.haskell.org/ghc/compiler/cmm/CmmParse.y
03:24:08 <firefly> which defines and exports parseCmmFile :)
03:36:26 <firefly> it seems like ghc can read and compile C-- already:   ghc -c xyz.cmm :)
03:36:46 <firefly> now the problem becomes: how do I make ghc output C-- files that it is capable of compiling?
04:01:20 <cinimod> I've upgraded to ghc 6.8.1. In 6.6 if I had an error in ghci then :r reloaded the module with the error but 6.8 wants to reload everything.
04:01:36 <cinimod> Is there any way to get the 6.6 behaviour back?
04:04:31 <Heffalump> someone mentioned that on glasgow-haskell-users
04:04:59 <Heffalump> you could read that to find the conclusion
04:05:07 <geocalc> wait for 6.8.2
04:05:57 <geocalc> :m
04:06:19 <cinimod> I'm hoping geocalc is mistaken - I'll have a look on glasgow-haskell-users - seems a bit of a clanger to me
04:07:57 <Heffalump> I don't think everyone was seeing the same behaviour.
04:08:18 <geocalc> cinimod=<< i was joking, use :m first on part you don't want to reload should work
04:14:56 <cinimod> geocalc: when there's an error you used to end up in the last module that loaded successfully now you end up the prelude so saying m: won't help
04:15:12 <cinimod> Or at least I can't see how it would
04:15:47 <geocalc> mmh
04:16:31 <cinimod> Heffalump: I saw one report like the one I have but Simon Marlow didn't seem to have it. I've posted an email reporting my problem.
04:20:36 <taruti> Why are GADT expression like "data T a = A :: T Int; B :: T Bool; f :: Int -> T any; f 0 = A; f 1 = B" forbidden?
04:20:49 <taruti> Having to wrap it inside an existential type seems stupid.
04:26:01 <Heffalump> taruti: the return type of f is existential
04:26:10 <Heffalump> Int -> T any implicitly means forall any . Int -> T any
04:26:20 <Heffalump> i.e. the caller gets to choose any, not the callee
04:28:05 <taruti> Heffalump: but nothing like (T forall t. t) works either. (then again maybe adding the wrapping is not so bad)
04:28:22 <Heffalump> I don't think there is any syntax for naked existentials.
04:30:05 <desegnis> taruti: This is not really related to GADTs. You have the same problem with Haskell 98 types; the following is illegal: g 0 = 12; g 1 = 'a'. Furthermore, I'm confused by your types, were they typos?
04:30:21 <EvilTerran> i believe the problem is that the type system couldn't cope
04:30:53 <EvilTerran> desegnis, what taruti says makes perfect sense in the context of GADTs
04:31:13 <EvilTerran> s/type system/type inference/
04:32:36 <EvilTerran> desegnis, in that it's perfectly valid to have data Foo a = Bar Int, you should be able to say data Foo :: * -> * where Bar :: Int -> Foo a, i guess
04:33:04 <desegnis> EvilTerran: Oh, my confusion was related to the phantom types
04:33:16 <desegnis> I see now
04:34:43 <desegnis> so, never mind
05:15:57 <olsner> how do I run a main function with arguments (getArgs) from ghci? I want to make sure I'm testing the right thing...
05:16:26 <Beelsebob_> olsner: you need to use System.getArgs
05:16:28 <Beelsebob_> iirc
05:16:46 <olsner> ghci makes my program run with the correct laziness, but when compiled it seems it tries to evaluate the entire infinite list of primes before printing anything
05:17:08 <Beelsebob_> interesting
05:17:10 <olsner> Beelsebob_: that's what I'm using, but is there a putArgs I can use from ghci?
05:17:30 <Beelsebob_> oh, I see... sorry, I fail at reading questions
05:18:15 <firefly> :main takes additional parameters
05:18:16 <Beelsebob_> what I usually do is make main something along the lines of main = do args <- System.getArgs; possibly set up buffering here; realMain args
05:18:21 <Beelsebob_> then you can call realMain in ghci
05:18:50 <olsner> firefly: ah! that's exactly what I was looking for
05:18:59 <firefly> :)
05:20:25 <olsner> now that I've tested it in ghci exactly as I'm testing it when compiled, I guess it's not a problem with my main function doing something weird, but just ghc doing the wrong thing while ghci does the right thing
05:21:04 <desegnis> olsner: Have you tried different -O flags?
05:21:12 <olsner> now I'm off to greet my aunt.. I'll be back with a reduced test case :P
05:21:29 <olsner> desegnis: same thing with -O, -O2 and none
05:21:34 <desegnis> ah
06:21:08 <Baughn> @hoogle openFd
06:21:08 <lambdabot> No matches found
06:21:34 <Japsu> @hoogle openFile
06:21:35 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
06:21:39 <Heffalump> it's been replaced by handleToFd in GHC 6.8.1
06:21:45 <Heffalump> or vice versa, I forget :-)
06:21:52 <Heffalump> and I might mean fdToHandle
06:21:59 <Igloo> fdToHandle'
06:22:10 <Heffalump> I'll get it right eventually..
06:23:13 <Baughn> That'd be why darcs doesn't build. yet another incompatibility.. meh, autoconf fixed it.
06:25:50 <Heffalump> there's a patch in at least some darcs trees for it
06:25:59 <Heffalump> or do you mean you reran configure and it sorted itself out?
06:26:09 <Heffalump> (which would mean that you have the patch)
06:26:30 <Heffalump> that and the package splitting were the only incompatibilities in the darcs code base
06:30:11 * Heffalump grumbles at the people that made Eq a superclass of Num
06:36:59 <Baughn> Peaker_: The laws of physics *can't* be arbitrary. At the very least, occam's razor /working/ proves that they're very simple, but by far most possible laws are very complex indeed
06:37:14 <Baughn> ...eh, mischan
06:38:32 <EvilTerran> anything to do with http://edge.org/3rd_culture/davies07/davies07_index.html ?
06:38:32 <lambdabot> Title: Edge: TAKING SCIENCE ON FAITH BY Pau Davies
06:40:11 <Heffalump> Baughn: huh?
06:40:37 <Baughn> EvilTerran: Not. even. remotely.
06:40:46 <Baughn> Heffalump: As I said, mischan. :/
06:41:20 <Heffalump> oh, I see.
06:41:46 <EvilTerran> huh. okay then. thought it sounded simimar, and as that's a fairly recent article, figured you might've been talking about it. i guess it'd've been too much of a coincidence for us both to have independently read it the same day ;)
06:46:49 * wli is not wild about the empirical sciences for similar reasons.
06:47:52 * wli generally phrases it in a past performance predicting future performance sort of way, often wrt. the sun rising.
06:49:50 * wli also tends to be unhappy with how empiricists often fail to cleanly distinguish between a priori and empirical knowledge.
06:50:30 <vincenz> Baughn: occam's razor is an axiom which can be easily disagreed with
06:50:38 <vincenz> Baughn: for all we know, there must not even be any laws to the universe
06:51:12 <Baughn> vincenz: Experience shows that it works. As such, it makes sense to hypotesize about /why/ this is.
06:51:14 <vincenz> wli: afaik, empiricism is the only way to do science
06:51:24 <vincenz> Baughn: sure, but those are all man-made constructions
06:52:24 <wli> vincenz: I like to stick to the a priori and somehow still managed to stay in the science department.
06:55:26 <vincenz> wli: comp sci != sci
06:56:48 <wli> vincenz: And math?
06:57:35 <vincenz> math isn't science either
06:57:47 <EvilTerran> comp sci is math :)
06:58:09 <EvilTerran> at the level i like it, anyway. and the rest of it's engineering ;)
06:58:15 <wli> vincenz: What are they, and why are they in the science departments so often?
06:59:12 <EvilTerran> maths and CS're both sciences as compared to arts/humanities, but so's engineering
06:59:59 <liyang-bipping> I think of math and science as art. :3
07:00:02 <EvilTerran> they're not natural sciences, tho, which is what people often mean by "the sciences"
07:00:53 <liyang-bipping> s/science/computer &/
07:01:14 <EvilTerran> liyang-bipping, and I think of time as a magazine (;]). it's all semantics in the end.
07:01:50 <EvilTerran> i didn't do anything! <_<  >_>
07:02:54 <liyang> Well, I'm referring to the fact that both mostly involve creative processes, whereas engineering and the physical sciences involve the study of existing phenomena. :3
07:03:40 <vincenz> re
07:04:13 <vincenz> wli: What are they, I don't know what to call them, "logic" based?  As for why are they in the science departement, maybe because most people that do not know about science don't care to amke the distinction?
07:04:40 <liyang> (also I guess because every time I'm in China people think I'm some sort of artist because I have a ponytail. XD)
07:19:48 <Baughn> vincenz: Well, that and the robots
07:20:12 <Baughn> Plus, the cs dept. has lots of computers. The physics dept. /wants/ lots of computers.
07:20:18 <Baughn> It's a marriage made in science.
07:25:48 <earthy> !sigh
07:26:04 <earthy> why the fleep do I bother with comonads...
07:58:39 <ScriptDevil> is there a debian build for yi anywhere?
07:58:45 <ScriptDevil> i cant seem to build mine
08:02:56 <ScriptDevil> !yi
08:03:06 <ScriptDevil> lambdabot, yi
08:03:18 <allbery_b> @where yi
08:03:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
08:03:26 <TomMD> @quote yi
08:03:27 <lambdabot> LoganCapaldo says: I like constructing things with type errors. It lets me read the error and try and figure out what I'm really trying to do
08:03:31 <roconnor> @go 1 CAD in USD
08:03:32 <lambdabot> 1 Canadian dollar = 1.019056 U.S. dollars
08:03:52 <TomMD> @go 1 EURO in USD
08:03:52 <lambdabot> 1 Euro = 1.4745 U.S. dollars
08:03:54 <vincenz> ouch
08:04:08 <TomMD> Seeing as I am paid USD, yes.
08:04:09 <vincenz> cad used to be < usd
08:04:22 <TomMD> By a significant amount.
08:05:25 <Brian`> do you guys do currency trading?
08:05:47 <TomMD> Only when I become a tourist.
08:06:05 <Brian`> lol ok
08:06:30 <Brian`> but that currency data looks different from what i saw on Bloomberg terminal
08:07:13 <TomMD> Thanks for the heads up - I'm not looking at making transactions based on a lambdabot google search, but it is a shocker to see these results.
08:07:25 <Brian`> i c lol
08:07:34 <Brian`> TomMD, you live in Canada?
08:07:41 <TomMD> USA
08:09:23 <EvilTerran> CAD's been >USD for a while now
08:10:27 <Stinger_> having had about zero experience with ML, how similar is it to haskell?
08:10:46 <vincenz> some similarities, soem differences
08:11:09 <vincenz> a) ML allows side-effects, Haskell doesn't only through the use o monads, as such Haskell is referentially transparent
08:11:19 <vincenz> 2) ML uses modules and functors, Haskell uses type classes
08:11:33 <vincenz> 3) ML is eager, Haskell is lazy
08:11:45 <vincenz> those are the main dissimilarities, for the rest they're very close to one another
08:11:53 <Stinger_> hmm ok, thanks
08:11:54 <EvilTerran> 4) ML doesn't use layout
08:12:06 <EvilTerran> instead it uses death-by-parentheses etc
08:12:25 <vincenz> EvilTerran: let's keep it objective :)
08:12:31 <Japsu> iä, parentheses fhtagn
08:13:09 <pitecus> Is there some way to embed source in the executable produced by GHC?
08:13:35 <EvilTerran> okay, okay. "its lack of layout (amoung other design decisions) means more punctuation is needed to write an ML program cf the equivalent haskell"
08:14:02 <sw17ch> @src eval
08:14:02 <lambdabot> Source not found. You speak an infinite deal of nothing
08:14:12 <EvilTerran> @where hsplugins
08:14:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:14:23 <EvilTerran> is the closest we have to an "eval"
08:14:34 <sw17ch> ah, alright. that was my next question
08:15:13 <afabian> I'm having a pretty hard time doing something in Haskell that would be very easy for me if I could lay my hands on some pretty conventional state.  If I boil it down to the basic idea, I have a list of strings (say list 1), and for each of these strings, I get a whole other list of strings ("lists 2").  Then, I want something like a database on list 1, where I transform it into a list of tuples of the form ("string", 0)... a
08:15:13 <afabian> nd then, for each and every item in the 2nd string of lists, I want to increment the number in the tuple if it matches the string in the tuple.  Seems very trivial in a stateful language, but I can't seem to wrap my head around a way to do it.  Maybe it's not a very functional way to attack my problem.
08:15:35 <afabian> Anyone have any basic ideas on how I might want to go about doing such a thing?
08:16:32 <vincenz> "i get a whole other list" ?
08:16:38 <sw17ch> use recursion and pass your altered state on to the next function call?
08:16:38 <quicksilver> afabian: that's a fold over "list 2"
08:16:51 <quicksilver> afabian: you fold over "list 2", with the initial value being all that (x,0) tuples
08:17:07 <quicksilver> afabian: the folding function increases the appropriate tuple if it matches
08:17:32 <quicksilver> where by increases I mean 'returns a new list with that tuple increased'
08:17:39 <afabian> vincenz: Well, for each item in the original list, "list 1", I apply a function and get another list of strings.  So if there are 3 elements in list 1, I get 3 lists of strings.
08:18:50 <afabian> Hmm.  Okay, thanks.  You guys seem pretty helpful.  I'll have to play with it for a while and see what I can do.  I've got this ugly thing where my helper functions are ending up with helper functions.  Well, nevermind that.  I'll go destroy the evidence. ;)
08:19:39 <Vq^> @type unzip
08:19:41 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
08:36:28 <Stinger_> zip l1 $ map sum [map (fromEnum . match x) l2 | (x,l2) <- zip l1 l2]         (where l1 :: [String],  l2 :: [[String]] , match String -> String -> Bool )
08:40:01 <Stinger_> I think that should work :P
08:42:48 <magnus_> Stinger: maybe this is more clear?: [ (x, length . filter (match x) $ l2) | (x,l2) <- zip l1 l2 ]
08:43:24 <Stinger_> probably
08:44:41 <Stinger_> I couldn't remember if haskell had filter, but it was (older) versions of python mixing me up
08:44:46 <Stinger_> its late :P
08:44:56 <magnus_> heh :)
08:45:10 <magnus_> I kinda liked the fromEnum thing though
08:46:40 <magnus_> I guess we have an equivalence: length . filter pred == sum . map (fromEnum . pred)
08:47:16 <Stinger_> formers probably a bit less hackish :P
08:48:33 <quicksilver> yeah, I'm not a big fan of fromEnum on Bool for real work
08:48:38 <quicksilver> neat for obfuscation though :P
08:58:37 <noecksit> hello, how may i recurse through a list, but include the full answer in the recursion
08:59:36 <esap> noecksit: depending on your definition of "including the full answer", foldr might work.
08:59:37 <lambdabot> esap: You have 1 new message. '/msg lambdabot @messages' to read it.
08:59:38 <noecksit> such as, for instance, i have "hello", i want to apply a function to "hello", then "ello", then "llo", then "lo", then "o" finally
09:00:05 <quicksilver> > tails "hello"
09:00:17 <lambdabot>  ["hello","ello","llo","lo","o",""]
09:00:25 <quicksilver> noecksit: mayb that helps :)
09:01:26 <sw17ch> @src tails
09:01:26 <lambdabot> tails []         = [[]]
09:01:26 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:02:05 <sw17ch> > map length (tails "hello")
09:02:05 <lambdabot>  [5,4,3,2,1,0]
09:03:06 <noecksit> yeah, thanx i might work somehow with that
09:03:30 <noecksit> now i can just apply map to the function with the list generated from tails
09:04:26 <sw17ch> map yourFunctionHere (tails yourList)
09:04:50 <Olathe> @messages
09:04:50 <lambdabot> You don't have any new messages.
09:05:06 <mauke> @massage
09:05:06 <lambdabot> You don't have any new messages.
09:05:24 <Olathe> @mousages
09:05:24 <lambdabot> You don't have any new messages.
09:06:51 <noecksit> actually my only problem now is that "yourFunctionHere" takes as arguments two lists rather than one
09:07:08 <mauke> join
09:07:34 <mauke> > map (join zip) (tails "hello")
09:07:35 <lambdabot>  [[('h','h'),('e','e'),('l','l'),('l','l'),('o','o')],[('e','e'),('l','l'),('...
09:08:23 <Olathe> > tails (map (join zip) "hello")
09:08:23 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
09:08:26 <Olathe> :(
09:08:47 <Olathe> @pl \a -> f a a
09:08:47 <lambdabot> join f
09:09:00 <hpaste>  ihope pasted "tail recursion example" at http://hpaste.org/4082
09:09:04 <mauke> > tails (join zip "hello")
09:09:05 <lambdabot>  [[('h','h'),('e','e'),('l','l'),('l','l'),('o','o')],[('e','e'),('l','l'),('...
09:09:10 <Olathe> Ahh.
09:09:52 <mauke> :t \f -> map f . tails
09:09:52 <lambdabot> forall b a. ([a] -> b) -> [a] -> [b]
09:10:08 <mauke> @free mapTails :: ([a] -> b) -> [a] -> [b]
09:10:08 <lambdabot> g . h = k . $map f => $map g . mapTails h = mapTails k . $map f
09:10:27 <noobie> hey guys is there a way to change white spaced characters to a list e.g. 1 2 3 4 to [1,2,3,4]
09:10:37 <ihope_> > words "1 2 3 4 5"
09:10:37 <lambdabot>  ["1","2","3","4","5"]
09:10:38 <mauke> > words "1 2 3 4"
09:10:39 <lambdabot>  ["1","2","3","4"]
09:10:47 <ihope_> > map read (words "1 2 3 4 5") :: [Int]
09:10:48 <lambdabot>  [1,2,3,4,5]
09:11:02 <noobie> nice
09:11:26 <Olathe> > read "1 2 3"
09:11:26 <lambdabot>  Exception: Prelude.read: no parse
09:11:45 <Stinger_> > map read (words "1 2 three 4 5") :: [Maybe Int]
09:11:45 <lambdabot>  Exception: Prelude.read: no parse
09:11:49 <noecksit> whats going on?
09:11:53 <mauke> > read "1.2e3"
09:11:53 <lambdabot>  Exception: Prelude.read: no parse
09:11:59 <mauke> > read "1.2e3" :: Double
09:11:59 <lambdabot>  1200.0
09:12:27 <Olathe> > read a book
09:12:27 <lambdabot>   Not in scope: `book'
09:13:51 <esap> >read "a book"
09:14:00 <esap> > read "a book"
09:14:01 <lambdabot>  Exception: Prelude.read: no parse
09:14:18 <Olathe> > read "test" :: String
09:14:18 <lambdabot>  Exception: Prelude.read: no parse
09:14:21 <Olathe> :(
09:14:26 <Lycurgus> noecksit: my guess is readline integration testing
09:14:29 <Olathe> > read "\"test\"" :: String
09:14:29 <lambdabot>  "test"
09:17:27 <noecksit> so is there any way i could reimplement map so that it takes two lists as arguments instead of one?
09:17:44 <mauke> it's called zipWith
09:19:14 <noobie> i am converting a function to a list, could this work >let result map read (words guess) :: [Colors]
09:19:42 <mauke> missing =
09:19:50 <mauke> otherwise yes
09:19:53 <noobie> ok
09:21:04 <noobie> it works thanks
09:21:09 <noecksit> mauke; thanx, i think that worked
09:30:33 <sizur> where can you get the Memo lib?
09:32:31 <sizur> apparently it was part of ghc 6.4.2, but not anymore?
09:32:40 <sizur> not sure
09:40:19 <sizur> does anybody know where are memorization functions?
09:42:58 <EvilTerran> it's usually pretty trivial to do directly
09:43:07 <EvilTerran> you don't really need a library for it
09:43:29 <sizur> http://www.haskell.org/ghc/docs/6.4.2/html/hslibs/memo-library.html
09:43:31 <lambdabot> Title: 9.2. Memo: Fast memo functions, http://tinyurl.com/22n8gz
09:45:11 <EvilTerran> have you read that page in detail? it says that it was only useful in very specific cases even the
09:45:12 <EvilTerran> n
09:45:28 <EvilTerran> and it'd be wholly implementation-dependent
09:45:49 <EvilTerran> so probably wouldn't work with recent GHC even if it were available
09:47:09 <sizur> ok. then how do i implement it to memorize the last argument? so computation will not repeat incase a function is called again with the same value?
09:48:00 <sizur> that is last arg and the result
09:48:17 <Saizan> > let fibs = 1 : 1 : zipWith (+) fib (tail fib) in fibs !! 10 -- this memoize the last 2 arguments :)
09:48:18 <lambdabot>   Not in scope: `fib'
09:48:18 <EvilTerran> could you maybe paste a non-memoizing version of your function so i have a bit more context?
09:48:25 <EvilTerran> @paste
09:48:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:48:27 <Saizan> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 10 -- this memoize the last 2 arguments :)
09:48:27 <lambdabot>  89
09:48:37 <sizur> it needs to work for any function or one argument
09:48:40 <sizur> of*
09:49:04 <EvilTerran> so you want something of :: (a -> b) -> a -> b?
09:49:07 <sizur> f = (+1)
09:49:09 <sizur> exactly
09:49:25 <EvilTerran> I'm afraid that's not possible
09:49:34 <sizur> why?
09:49:41 <sizur> my book says it is
09:49:43 <Saizan> and not practical, you need to know something about the domain
09:49:51 <EvilTerran> in order to build memoization, you need to be able to compare the parameter type for equality
09:50:08 <EvilTerran> or something to that effect, so you can build a lookup table
09:50:22 <sizur> Eq a => (a->b) ->a->b?
09:50:44 <EvilTerran> even with that caveat, if you just take a function as the parameter, any recursive calls won't be memoized
09:51:07 <mauke> you want at least Ord
09:51:11 <EvilTerran> because the memo-adding function can't "look inside" its parameter and see that it calls itself. functions are abstract.
09:51:16 <sizur> for hash you dont need ord
09:51:25 <mauke> that's why I said "at least"
09:51:35 <mauke> you can also have Hashable or whatever
09:52:16 <EvilTerran> sizur, as a general way of making a memoized function, you have to modify the original definition
09:55:02 <EvilTerran> at its simplest, you could, say, replace "foo :: Int -> <whatever>; foo x = ..." with "foo x = fooMemos!!x; fooMemos = map (...) [0..]"
09:55:18 <EvilTerran> where "..." means the same thing each time
09:55:41 <EvilTerran> although in most cases it'd be more efficient to use a more advanced data structure, like a Map or an Array
09:55:46 <mauke> wasn't tere a memoFix somewhere?
09:57:17 <conal> there's "lazy memoization", which is polymorphic.
09:57:28 <EvilTerran> if you want to explain how to use fixed-point form for memoization, be my guest ;)
09:57:34 <conal> @go lazy memo functions
09:57:35 <lambdabot> http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=5289
09:57:35 <lambdabot> Title: Lazy memo-functions
09:57:37 <sizur> well i need a special case of making sure that computation is not done on the same argument in succession
09:58:09 <sizur> from SOE book
09:58:32 <quicksilver> the SOE book contains an absolutely disgusting hack
09:58:43 <quicksilver> which memoizes using unsafePointerEquality#
09:58:54 <quicksilver> this is broken in general and not recommend :P
09:59:10 <sizur> then it's the same lib that in the link i gave, right?
09:59:17 <sizur> based on pointer equality
09:59:24 <EvilTerran> yes, most likely
09:59:31 <conal> http://haskell.org/haskellwiki/Memoization has some helpful info
09:59:31 <sizur> if nothing else, why not use a hack
09:59:37 <quicksilver> because it's broken!
09:59:46 <EvilTerran> because there's ways that work better and aren't hacks!
09:59:50 <sizur> that's encouraging
09:59:52 <quicksilver> because pointer inequality doesn't guarantee value inequality
10:00:08 <quicksilver> you can (obviously!) have the same value twice at different memory locations
10:00:27 <conal> the ghc version is described in http://citeseer.ist.psu.edu/peytonjones99stretching.html
10:00:27 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
10:00:40 <EvilTerran> because something of type (a -> b) -> (a -> b) that actually modifies its parameter is wholly against the spirit of haskell
10:00:43 <conal> it's polymorphic & lazy
10:00:49 <mrd> just create a data-structure containing all the values you might ever compute
10:01:10 <mrd> lazily...
10:02:13 <conal> sizur: does your memoizer have to be fully polymorphic in the argument type?
10:03:15 <conal> if so, see lazy memo functions.  if not, see maps, tries, etc.
10:03:34 <mauke> is Gradef an acceptable name for a parser library?
10:03:44 <sizur> thanks all
10:03:57 <conal> sizur: good luck
10:04:00 <mrd> mauke: Grade F?
10:04:11 <mauke> well, that's one interpretation
10:04:58 <sizur> in the functional spirit all functions should be memorizable by default! of course then memory needs to be infinite
10:05:17 <mauke> it can also mean Grammar Definition
10:05:20 <sizur> but it would be nice if ghc would support a syntax to state the buckets
10:07:04 <Brian`> @src fromIntegral
10:07:04 <lambdabot> fromIntegral = fromInteger . toInteger
10:07:14 <mrd> sizur: it does. it's called creating a lazy data structure =)
10:08:07 <sizur> mrd: can you pase a simpliest example?
10:08:07 <Brian`> how do i convert from string to int?
10:08:11 <sizur> paste*
10:08:12 <magnus_> @hoogle (a->b->c)->(d->a)->(d->b)->d->c
10:08:13 <lambdabot> No matches, try a more general search
10:08:16 <mrd> > read "1" :: Int
10:08:17 <lambdabot>  1
10:08:27 <Brian`> thanks :)
10:08:46 <mrd> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
10:08:47 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:09:31 <quicksilver> @djinn (a->b->c)->(d->a)->(d->b)->d->c
10:09:32 <lambdabot> f a b c d = a (b d) (c d)
10:09:34 <sizur> what if a fib needs an argument to initialize it's first two values?
10:09:37 <quicksilver> magnus_: ?
10:09:42 <quicksilver> magnus_: as djinn says?
10:09:43 <magnus_> quicksilver: yes, that's what I'm looking for
10:09:45 <mrd> sizur: no big deal
10:09:58 <magnus_> quicksilver: but I'm hoping for a built in function
10:10:06 <magnus_> it is such a common pattern
10:10:15 <vincenz> > fix (1 :) . (1 :) . ap (zipWith (+)) tail
10:10:21 <vincenz> > fix $  (1 :) . (1 :) . ap (zipWith (+)) tail
10:10:22 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[t]'
10:10:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:10:28 <mrd> > let fibs a b = fix (\f -> a:b:zipWith (+) f (tail f)) in fibs 1 1
10:10:28 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:10:47 <mrd> the usage of 'fix' is just a shorthand for a recursive let-definition
10:10:54 <mrd> @src fix
10:10:54 <lambdabot> fix f = let x = f x in x
10:11:01 <sizur> i see
10:11:26 <sizur> mrd: thank you
10:11:50 <mrd> the only problem with the list is that lookup is linear time
10:12:02 <mrd> you can do better with say, Data.Map
10:12:58 <Aviaattori> 3.
10:13:14 <Aviaattori> 33
10:13:52 <Aviaattori> whoopsie...
10:15:32 <sizur> mrd: and that fib function has no space/time leaks?
10:16:15 <shachaf> > fix ((1:) . scanl (+) 1)
10:16:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:16:18 <mrd> well it keeps around all fib numbers up to the highest accessed until you lose track of the list
10:16:30 <Olathe> Where'd I put that list again ?
10:16:31 <mrd> that's memoization after all..
10:16:46 <magnus_> @quickcheck uncurry f . (g &&& h) == (\x -> f (g x) (h x))
10:16:46 <lambdabot> Unknown command, try @list
10:16:49 <magnus_> @list
10:16:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:17:06 <shachaf> magnus_: @check, but it should get arguments.
10:17:07 <mrd> but the general idea is simply a recursively defined lazy data structure
10:17:10 <magnus_> every problem in CS can be solved by another layer of indirection
10:17:13 <sizur> @i fix
10:17:13 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
10:17:21 <mrd> Control.Monad.Fix
10:17:24 <sizur> thx
10:17:26 <magnus_> shachaf: cool
10:17:28 <mrd> but you can use 'let' instead
10:17:43 <shachaf> magnus_: (And probably specify types.)
10:19:10 <mauke> that layer of indirection is lambda.
10:19:27 <conal> magnus_: try liftA2
10:19:30 <magnus_> @check \f g h (x::Int) -> (uncurry f . (g &&& h)) x == f (g x) (h x)
10:19:30 <lambdabot>  Parse error in pattern at "->" (column 17)
10:19:54 <magnus_> conal: checking it out, thanks
10:20:05 <conal> @ty liftA2
10:20:14 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:20:45 <conal> liftM2 would work also, but it's not as hip ;)
10:20:46 <magnus_> @src liftA2
10:20:46 <lambdabot> liftA2 f a b = f <$> a <*> b
10:20:58 <magnus_> looks like what I need
10:21:02 <magnus_> @ty <$>
10:21:04 <lambdabot> parse error on input `<$>'
10:21:11 <conal> @ty (<$>)
10:21:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:21:42 <magnus_> @ty (<*>)
10:21:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:22:11 <noecksit> exanding on before, is there a way to make a modified zipWith function so rather than applying myFunction to two list sequencially, it first takes the first atom of the first list and applies it to to each atom of the second list, and so on
10:22:26 <conal> noecksit: liftA2 again
10:22:27 <noecksit> kind of like (x+y)(x+y)
10:23:11 <clanehin> fmap = <$> just finished several (interrupted) hours of kicking my non-terminating butt
10:23:18 <clanehin> @src (<$>)
10:23:18 <lambdabot> f <$> a = fmap f a
10:23:27 <conal> > liftA2 (+) [1,2,3] [10,20,30]
10:23:29 <lambdabot>  [11,21,31,12,22,32,13,23,33]
10:23:55 <magnus_> > liftM2 (+) [1,2,3] [10,20,30]
10:23:56 <lambdabot>  [11,21,31,12,22,32,13,23,33]
10:24:14 <magnus_> :t liftA2
10:24:14 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:24:16 <magnus_> :t liftM2
10:24:17 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:24:26 <conal> liftA2 generalizes liftM2
10:24:36 <conal> i.e., it more widely applicable.
10:24:40 <conal> (it's)
10:24:55 <magnus_> aha, so Monad f implies Applicative f ?
10:24:57 <xerox> > (+) `fmap` [1,2,3] `ap` [10,20,30]
10:24:57 <lambdabot>  [11,21,31,12,22,32,13,23,33]
10:25:07 <conal> magnus_: yes
10:25:15 <shachaf> magnus_: In theory, yes.
10:25:25 <Heffalump> noecksit: isn't that a cartesian product?
10:25:33 <magnus_> :t ap
10:25:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:25:34 <shachaf> magnus_: pure = return, (<*>) = ap
10:25:42 <noecksit> yeah i think so
10:25:50 <esap> @ty let mapf = flip fmap in \f x y -> x `mapf` \a -> y `mapf` \b -> f a b
10:25:50 <lambdabot> forall (f :: * -> *) a a1 b. (Functor f) => (a -> a1 -> b) -> f a -> f a1 -> f (f b)
10:25:51 <sizur> trying to get my head around fix
10:25:55 <noecksit> thank you, i think thats what i needed
10:26:17 <esap> uh, not general enough :-(
10:26:36 <conal> noecksit: did you mean that the first list contains functions to be applied to members of the second list?  or two lists of arguments to a binary function?
10:27:00 <conal> if the former, use funs <*> args.  if the latter liftA2 f args1 args2
10:27:14 <shachaf> conal: "modified zipWith function" -- I assume the latter.
10:27:15 <noecksit> conal: what i think i meant was two lists of arguments to binary function
10:27:15 <magnus_> > ap (return (\x->2*x)) (return 2)
10:27:17 <lambdabot>   add an instance declaration for (Show (m a))
10:27:27 <magnus_> > ap (return (\x->2*x)) (return [2])
10:27:28 <lambdabot>   add an instance declaration for (Show (m [t]))
10:27:28 <conal> shachaf: i did too until i reread
10:27:36 <magnus_> > ap (return (\x->2*x)) ([2])
10:27:37 <shachaf> Oh, hmm.
10:27:38 <newsham> > liftA2 (+) (zipList [1,2,3]) (zipList [10,20,30])
10:27:43 <lambdabot>   Not in scope: `zipList'
10:27:45 <lambdabot>  [4]
10:27:47 <noecksit> which module is liftA2 in?
10:27:49 <shachaf> Right.
10:27:53 <araujo> hello
10:27:53 <magnus_> > ap [\x->2*x] ([2])
10:27:53 <newsham> > liftA2 (+) (ZipList [1,2,3]) (ZipList [10,20,30])
10:27:53 <shachaf> Control.Applicative.
10:27:54 <lambdabot>  [4]
10:27:54 <lambdabot>   add an instance declaration for (Show (ZipList a))
10:28:06 <newsham> > getZipList $ liftA2 (+) (ZipList [1,2,3]) (ZipList [10,20,30])
10:28:08 <lambdabot>  [11,22,33]
10:28:14 <magnus_> > ap (return [\x->2*x]) (return [2])
10:28:14 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
10:28:48 <noecksit> shachaf: was that for me?
10:28:56 <shachaf> noecksit: Yes.
10:29:02 <magnus_> > ap [\x->2*x] [2]
10:29:03 <lambdabot>  [4]
10:29:17 <magnus_> > ap [\x->2*x,\x->x*x] [2,3,4]
10:29:18 <lambdabot>  [4,6,8,4,9,16]
10:29:34 <noecksit> shachaf: ghci can't find it, is in an external module?
10:29:42 <conal> > [\x->2*x,\x->x*x] <*> [2,3,4]
10:29:43 <lambdabot>  [4,6,8,4,9,16]
10:29:43 <shachaf> noecksit: Which version of GHC?
10:30:10 <noecksit> shachaf: 6.4.1
10:30:13 <shachaf> noecksit: Latest is 6.8.1.
10:30:15 <noecksit> *6.4.2
10:30:20 <shachaf> noecksit: Upgrade! :-)
10:30:32 <shachaf> At least to 6.6.*, probably.
10:32:34 <arossato> there should be a function to create a unique temp filename (similar to mkstemp but returning only a String)...am I wrong? Someone remember where it is located?
10:34:06 <newsham> arossato: that leads to race conditions
10:34:17 <mauke> what's wrong with mkstemp?
10:34:54 <arossato> I need to create a directory
10:35:14 <arossato> something like direname.a2876db
10:35:37 <arossato> (random character after a given name: I remember I saw something like this)
10:36:23 <newsham> FFI to unix's mkdtemp?
10:36:41 <newsham> (not completely standard)
10:36:50 <arossato> newsham: why not...;) thanks
10:37:43 <newsham> which lib is mktemps in?
10:37:58 <arossato> stdlib.h
10:38:15 <newsham> import stdlib.h?
10:38:24 <mauke> System.Posix.Temp
10:38:26 <arossato> newsham: no sorry System.Posix.Temp
10:38:50 <laz0r> hi #haskell, i was wondering if there is something like a 'recommended read' when trying to understand how control.parallel and control.parallel.strategies work?
10:39:08 <laz0r> i tried googling, found quite a few, and didnt really 'get it' so far
10:41:30 <mrd> there's a website with some docs and papers
10:41:42 <mrd> it's linked from the haddock api page
10:41:43 <SamB> huh, the fourth hit for Control/Parallel.hs is a GCC bug report?
10:43:37 <laz0r> http://www.mathematik.uni-marburg.de/~loogen/Lehre/ws02/pfp/strategies.ps
10:43:38 <lambdabot> http://tinyurl.com/3xds9g
10:43:43 <laz0r> that one looks promising
10:44:21 <laz0r> but i was looking for something simpler, i wanted to see how you would make a 'parallel map'
10:45:07 <laz0r> just a very naive attempt at parallelism, take a list, apply funtion to every element in parallel
10:45:33 <mrd> parMap
10:45:48 <mrd> @hoogle parMap
10:45:52 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
10:46:23 <laz0r> mmh, ok, but what would be the 'strategy'?
10:46:28 <mrd> rnf, or rwhnf
10:46:39 <mrd> rnf is a class method which implements "reduce to normal form"
10:46:49 <mrd> rwhnf you can get "for free" but it only reduces to weak-head normal form
10:47:15 <mrd> the point of them being, to force the work to be done in a parallel thread rather than possibly lazily delayed
10:48:17 <laz0r> so rnf and rwhnf are similar to seq?
10:48:43 <mrd> yes, rnf is actually just seq applied to subterms really
10:48:51 <mrd> @src [] rnf
10:48:52 <lambdabot> Source not found.
10:49:02 <laz0r> x `seq` f x, menas evaluate x before evaluating f x if i understood everything correctly
10:49:09 <mrd> rnf (x:xs) = x `seq` rnf xs `seq` ()
10:49:14 <laz0r> that is, makeing the laziness go away?
10:49:25 <mrd> basically
10:50:09 <newsham> Weak Head Consulting would be a nice company name
10:50:10 <mrd> actually that's probably rnf x `seq` rnf xs `seq` () because the instance defn is (NFData a) => NFData [a]
10:51:28 <mrd> some deriving libraries can derive NFData for you.  but there's tons of instances defined for already-existing stuff.
10:51:43 <mrd> so my matrix-multiply of Arrays of Doubles "just worked" with parMap rnf
11:10:34 <laz0r> mmh
11:11:19 <laz0r> it says in the docs that there is a instance (NFData k, NFData a) => NFData (Map k a), but it seems to me there is not
11:11:55 <laz0r> both the key and the values types have instances of NFData as well
12:09:24 <andyjgill> Has anyone used the galois ICFP 2000 raytracer? (There is a copy in the ghc test suite)
12:11:31 <dons> i've used it to benchmark things
12:11:34 <andyjgill> (Or) is there a good way of specifying a small 3d scene? I was going to use GML and the ray tracer.
12:11:59 <andyjgill> Specifically, a picture of a 1/2 solved rubiks cube, actually.
12:12:22 <dons> not sure.
12:12:26 <andyjgill> We could always do a release of the Galois raytracer to hackage.
12:12:36 <andyjgill> Then I could refer to that.
12:13:17 <dons> that's a good idea.
12:13:57 <andyjgill> And I'm sure there are other GML engines out there.
12:14:34 <andyjgill> But perhaps there is a standard specification language for raytracers. Wrong group to ask, I suppose.
12:14:54 <conal> andyjgill: what kind of primitives & operations do you want?
12:15:02 <andyjgill> Hi duncan
12:15:17 <andyjgill> I Conal, perhaps you are the very man I need to talk to!
12:15:22 <andyjgill> I=>Hi
12:15:54 <conal> andyjgill: i have a 3D itch these days, and i'm playing with OpenGL.  so maybe.
12:15:56 <andyjgill> I'm wanting to describe a rubiks cube, as output from a Haskell program
12:16:11 <conal> and i've designed a few functional 3D libs
12:16:12 <andyjgill> Did you ever look at the GML / ICFP2000?
12:16:31 <conal> nope.  ref?
12:16:38 <andyjgill> Its that sort of level I want. (wait a mo)
12:17:03 <andyjgill> http://www.cs.cornell.edu/icfp/
12:17:07 <lambdabot> Title: ICFP Programming Contest Home Page
12:17:12 <andyjgill> http://www.cs.cornell.edu/icfp/task.htm
12:17:12 <lambdabot> Title: The Third Annual ICFP Programming Contest (Version 1.18)
12:17:31 <conal> ... lookin gfor the spec ...
12:17:49 <andyjgill> It was quite a complete language, and the problem was writing an interpreter and raytracer engine for it.
12:18:41 <conal> andyjgill: you want something forth-like??
12:19:11 <conal> not a lovely dsel?
12:19:27 <andyjgill> Whats important is (1) the level of primitives (or higher if possible) (2) ascii.
12:20:05 <conal> andyjgill: haskell-embedding okay?
12:20:41 <andyjgill> Well, its the output from a Haskell program. The good think about ascii is it can be read.
12:21:06 <conal> andyjgill: what program generates the output?
12:21:11 <andyjgill> But I'm exploring possibilities.
12:21:22 <andyjgill> Home brew, for the sake of teaching.
12:21:59 <conal> andyjgill: what's the purpose of the "3D language"?
12:22:30 <conal> andyjgill: i'm wondering if having a "language", in addition to Haskell is an artificial requirement.
12:22:43 <andyjgill> So I want to focus the example in a DSL for exploring solutions to the cube, and having nice pictures of solutions would be nice.
12:22:44 <conal> as opposed to a 3D type.
12:23:11 <conal> so Haskell yes & pictures yes.  but an intermediate language?
12:23:31 <conal> (rather than a type)
12:23:45 <andyjgill> I've got no problem with the 3D type, if its a good one, with a portable library behind it.
12:23:54 <Philippa> I tend to think that the intermediate language is a requirement and the interesting question's how much you can fuse generation and interpretation
12:23:56 <andyjgill> What have you in mind?
12:23:59 <conal> andyjgill: okay. got it.
12:24:14 <conal> Philippa: whose requirement?
12:24:32 <Philippa> intrinsic in getting anything much done
12:24:50 <conal> andyjgill: and what about rendering.  is OpenGL rendering okay?  or do you want raytracing?
12:24:56 <Philippa> if you've got a combinator lib then you've just embedded some flavour of compositional language, for example
12:24:59 <conal> (OpenGL would be interactive speed)
12:25:19 <andyjgill> I just want a nice picture of a cube, perhaps animated turning.
12:25:31 <andyjgill> How complex is OpenGL's API?
12:25:40 <conal> Philippa: sure.  and you probably wouldn't have things like variables, lambda, and types in the "language".
12:26:16 <conal> andyjgill: damn complicated.  that's one reason a nice (functional) 3D type would be useful.
12:26:20 <SamB> andyjgill: hard to say
12:26:22 <goalieca> andyjgill, depends on what you want to do. it is modelled after a state machine though.
12:26:25 <conal> another reason is that it'd be fnl
12:26:33 <conal> functional
12:26:49 <SamB> OpenGL is extensible
12:26:50 <Philippa> conal: which is okay because you're generating the programs in it via what're effectively haskell metaprograms which can include those things
12:27:08 <Philippa> so you don't have to worry about those things at rendertime because they've all been handled already
12:27:14 <conal> the functional 3D type would completely hide OpenGL, which gives simplicity, purity, and performance
12:27:18 <conal> and portability
12:27:19 <SamB> so the API can be as complicated as the people who wrote your implementation felt like, basically...
12:27:31 <andyjgill> Can you give me an example of how you would construct the cube?
12:28:02 <andyjgill> I can imagine in GML having 27 small black cubes, shaping there corners, and then adding colored stickers.
12:28:05 <conal> Philippa: exactly.  GML, on the other hand, has variables, so it's not simply a combinator lib.
12:28:32 <Philippa> no, but then there're plenty of EDSLs that come with their own notion of 'variable' too
12:28:33 <andyjgill> I love the idea of a small 3d type, though.
12:29:41 <conal> andyjgill: imagine starting with GML, removing any language-generic things like variables & definitions, making it statically typed, and packaging as a combinator lib.
12:29:57 <andyjgill> :-) I'd love it.
12:30:08 <conal> whatever you could say in GML, you could say more elegantly in Haskell with the combinator lib.
12:30:10 <vincenz> conal: the GMLMonad :)
12:30:20 <conal> vincenz: no monads!
12:30:24 <vincenz> bah!
12:30:27 <conal> !
12:30:29 <conal> ;)
12:30:34 <vincenz> :)
12:30:51 <conal> there's nothing sequential about graphics.
12:31:00 <conal> just rendering.
12:31:04 <vincenz> True
12:31:14 <glguy> ?seen dons
12:31:14 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 43s ago.
12:31:31 <conal> OpenGL is about rendering, but a functional lib would be about modeling.
12:31:32 <andyjgill> Are you imaging a pure data-structure, or a stronger reactive like structure?
12:31:41 <glguy> dons: I picked up a DirtBag this weekend to bring to work
12:31:48 <vincenz> Though, hmm, making GML a combinator library comes down to saying that you want something that'll take a model and render it (the backend of the GML tool) and then just a data type (or set thereof) that would've been used in the GML tool?
12:31:56 <conal> andyjgill: nothing reactive.  that's an orthogonal issue.
12:32:05 <SamB> this whole sequential rendering thing seems kind of faddish to me anyway
12:32:21 <vincenz> data Object = Square | Rotation Foo Bar Object | Union Object Object
12:32:22 <vincenz> ...
12:32:25 <dons> glguy: awesome!
12:32:27 <andyjgill> Ahh, and then use Haskell to generate a sequence of 3D scenes if needed.
12:32:38 <vincenz> glguy: what is a dirtbag?
12:32:54 <conal> andyjgill: sort of, but a flow, not a sequence.
12:33:01 <conal> (temporally continuous)
12:33:14 <glguy> vincenz: a brand of foot bag
12:33:19 <andyjgill> When/how do we start?
12:33:24 <SamB> conal: but my GPU can't go that fast!
12:33:25 <vincenz> glguy: you mean a hacky sack?
12:33:34 <glguy> vincenz: that's another brand
12:33:36 <conal> SAmB: for animation, temporal discreteness is part of rendering, not modeling
12:33:56 <vincenz> glguy: oh in california that's what they were called
12:34:00 <vincenz> glguy: but that's what you mean, right?
12:34:03 <glguy> yeah
12:34:08 <andyjgill> or course, such a data-structure could also have an ascii rendering.
12:34:08 <dons> http://galois.com/~dons/tmp/dirtbag.jpg
12:34:26 <conal> andyjgill: certainly
12:34:43 <vincenz> right, a hacky sack
12:34:50 <vincenz> dons: didn't know you played or I would've brought mine to HaC
12:35:10 * vincenz prefers the knitted kind
12:35:18 <andyjgill> He moved to the northwest; of course he plays with a hacky sack.
12:35:21 <conal> for me, the heart of functional programming is exactly this separation between model & presentation.  the former is naturally functional & compositional, while the latter is often imperative/sequential and not-so-compositional.  IO belongs with the latter.
12:36:06 <andyjgill> Well said!
12:36:44 <andyjgill> I'm wanting to use such a DSL in the timeframe of about a month; how will we go about this?
12:36:58 <conal> andyjgill: do you have any OpenGL experience?  i'm just starting.
12:37:12 <andyjgill> Nope. Lots of FFI, but no OpenGL.
12:37:49 <vincenz> the question is whether you want opengl or not
12:37:55 <vincenz> this is actually very important if you want GML as source model
12:37:56 <vincenz> -very-
12:38:00 <conal> hm.  there's already a Haskell interface.  the type design will be the easy part for me.  getting someone who's done OpenGL programming in Haskell would make it go much faster.
12:38:14 <vincenz> GML is based on volumetric operations like union/diffrence
12:38:15 <agnokapathetic> does anyone have any advice for a 17 year old applying to computer science programs and intending to do graduate work later on?
12:38:21 <vincenz> The tpyical renderer works by raytracing
12:38:23 * ddarius has never heard of a hacky sack referred to by anything other than "hacky sack".
12:38:29 <vincenz> If you want to go to opengl, you'd have to first move to triangles
12:38:44 <vincenz> Which is less trivial than simply raytracing
12:38:51 <SamB> hacky sack is a brand?
12:38:57 <andyjgill> (looking at the Haskell API for OpenGL)
12:39:23 <ddarius> SamB: Not to my knowledge, but I haven't ever looked deeply into the issue.
12:39:26 <vincenz> andyjgill: The question is, what sort of 3d do you want to do?  In the style of GML, or something else?
12:39:37 <ihope> agnokapathetic: I dunno. Study Haskell?
12:39:51 <conal> vincenz: or pull in some tessellation code.  i think GLU has some.  but yeah, OpenGL is about triangles, with smooth shading to simulate curved surfaces.
12:39:52 <ddarius> SamB: It's possible though.  Band-Aid is a brand, but the word is used generically nowadays.
12:39:55 <andyjgill> Just basic raytracing like pictures. no fancy lighting.
12:40:12 <ddarius> Raycasting
12:40:13 <agnokapathetic> ihope: well, i've been doing that but are there many schools that teach haskell to undergrads?
12:40:15 <andyjgill> Shapes and So. Conal's API would be just great.
12:40:24 <conal> andyjgill: raytracing *is* fancy lighting
12:40:25 <vincenz> conal: Right, if you want to start from GML, I think that segmenting spheres that have been union'ed and then differenced with cones and whatnot into triangles is not trivial
12:40:35 <glguy> "Hacky Sack" is a trademark of Wham-O, Inc.
12:40:39 <conal> (reflections, soft shadows, etc)
12:40:46 <agnokapathetic> ihope: or will it make a difference if the program awards a B.S or a B.A.?
12:40:51 <ihope> agnokapathetic: I don't know.
12:40:53 <SamB> conal: simpler algorithms don't give you properly fancy lighting, usually...
12:41:08 <andyjgill> Being more specific :-)  ... I want to render some 3D objects, and I have a ray tracer lying around.
12:41:18 <vincenz> andyjgill: define 'some 3d' objects
12:41:20 <conal> i agree with vincenz.  CSG (boolean ops on geometry) is not simple.
12:41:23 <vincenz> andyjgill: are you primitives planes or CSG?
12:41:36 <vincenz> raycasting a CSG seems simpler
12:41:41 <vincenz> thanks conal for terminology which escaped me
12:41:54 <andyjgill> CSG, I believe.
12:42:13 <andyjgill> GML used CSG.
12:42:19 <vincenz> Then perhaps raytracing is better than rendering (or whatever you call it what opengl does)
12:42:24 <vincenz> s/better/easier
12:42:29 <SamB> I mean, look at this: http://www.nathan.kopp.com/photons.htm#Examples
12:42:30 <lambdabot> Title: Photons
12:42:34 <ddarius> conal: I imagine you've looked at functional representations?
12:42:46 <conal> ddarius: of what?
12:42:47 <ddarius> @google "functional representations" funreps
12:42:47 <lambdabot> No Result Found.
12:42:49 <SamB> and tell me that you can do that with the basic backwards raytracing algorithm
12:43:55 <ddarius> http://www.hyperfun.org/F-rep.html
12:43:55 <lambdabot> Title: F-rep Home Page. Shape Modeling and Computer Graphics with Real Functions
12:44:02 <SamB> conal: CSG is very simple in the reverse raytracing algorithm...
12:44:06 <vincenz> andyjgill: the main issue with going from CSG to opengl is that you'll need to adaptively segment the resulting surfaces based on how sharp cuts are
12:44:34 <conal> andyjgill: i think what's coming clear here is the basic question of fancy geometry (including CSG) & rendering (reflections, soft shadows) or interactive speed.
12:44:46 <conal> SamB: yep
12:45:13 <vincenz> just compile the haskell code to gpu :)
12:45:18 <SamB> eventually, video games will be raytraced
12:45:21 <andyjgill> I just want a simple way to have a nice picture, for a straightforward shape.
12:45:30 <SamB> or path traced or whatever
12:45:34 <vincenz> andyjgill: straightforward is mostly blocky or mostly spherical?
12:45:39 <conal> ddarius: thanks.  looks like follow-on to John Snyder's PhD thesis.
12:45:43 <andyjgill> Mostly blocky
12:45:44 <glguy> has anyone heard of any progress on getting ghc running on leopard ppc ?
12:46:06 <SamB> either that, or the graphics will stop improving ;-)
12:46:11 <vincenz> if you only have straiht edges, then segmentation should still be doable in CSG
12:46:20 <vincenz> and then you can use opengl
12:47:04 <ddarius> path traced video games would be awesome
12:47:25 <conal> compiling to GPU, esp newer CUDA ones, is a great project.  though perhaps not in andyjgill's time frame.  i'd be interested in updating Vertigo if someone wanted to collaborate.
12:49:33 <ddarius> After that the next step would be to move to "physical optics" and add diffraction
12:49:49 <SamB> anyway, apparantly current GPUs take a heavy hit from conditional branches... so I would not suggest using them to implement raytracing ;-P
12:50:31 <conal> though there's been plenty of related work (raytracing on GPUs)
12:50:33 <ddarius> I'm certain you could use a GPU to significantly speed up raytracing.
12:50:38 <dfranke> ooh.  Apparently lazy IO + concurrency = brokenness.
12:50:46 <vincenz> ddarius: not to mention variable diffraction based on stresses on the soft-bodied physics objects :)
12:51:14 <ddarius> vincenz: Indeed, continuous diffraction from hot air
12:51:22 <ddarius> dfranke: lazy IO + nothing = brokeness
12:51:44 <ddarius> Sorry, continuous refraction
12:52:01 <dfranke> when evaluating a ByteString read using hGetContents requires blocking I/O, it seems to block the entire runtime unless the thread was spawned using forkOS rather than forkIO.
12:52:17 * vincenz was thinking of polarized light and a piece of transparent plastic that is bended
12:52:35 <dons> dfranke: hmm. interesting.
12:52:36 <SamB> yeah, you can use GPUs to at least determine the first hit object...
12:52:40 <vincenz> For instance enemy armor showing those patterns when kicked :)
12:52:40 <dons> dfranke: did you link with -threaded ?
12:52:53 <ddarius> vincenz: Indeed
12:52:54 <dfranke> dons, I'm just running inside ghci
12:53:02 <dons> can you compile a test case?
12:53:51 <ddarius> SamB: It's a huge win to shoot clusters of rays.  Cache coherence is critical for raytracer performance.
12:53:53 <dfranke> It'll take some time to prepare one simple enough to demonstrate, but sure.
12:53:54 <magnus_> why is this a parse error on where? :  (\ x -> y where y = x)
12:54:04 <vincenz> ddarius: sounds like the list monad ::)
12:54:04 <ddarius> where isn't an expression
12:54:26 <magnus_> what is it then?
12:54:28 <SamB> but you really can't run the raytracer on the GPU yet, can you?
12:54:48 <dfranke> dons, anyway, I thought PipeArrow was just about ready, but my tubes are clogging :-(
12:55:01 <ddarius> You probably could, but I was more talking about using it for parts of the raytracing.
12:55:10 <dons> dfranke: check in compiled code. ghci can be weird
12:55:11 <SamB> yeah, you could use it for that...
12:55:40 <vincenz> http://en.wikipedia.org/wiki/Image:Hacky.jpg
12:55:40 <lambdabot> Title: Image:Hacky.jpg - Wikipedia, the free encyclopedia
12:55:48 <SamB> actually now I've got a crazy idea of how you could do it...
12:56:29 <dons> vincenz: so the problem with those ones is that they are hard to 'stall' (i.e. catch on a flat surface of your body), and they tend to bounce unpredicatbly
12:56:54 <vincenz> dons: really? I would think the fuzzy ones are more unpredictable, at least the knitted ones reshape easily
12:57:00 <goalieca> dons i like those ones
12:57:03 <vincenz> the flufy ones tend to be lighter, and hence unshape less
12:57:06 <goalieca> knitted ftw
12:57:15 <vincenz> dons: shoe recommendations?
12:57:33 <dons> there's a huge difference in the kind of results you can get with the softer, sand-filled ones. suddenly a whole set of tricks become feasible
12:57:36 <dons> because there's more control
12:57:39 <SamB> but... how do you avoid testing intersection with all objects?
12:57:39 <vincenz> hmm
12:57:51 <vincenz> SamB: quad-tree
12:58:08 <vincenz> dons: the fluffy ones roll off my shoe more easily cause they're too light
12:58:17 <dons> oh, i use a pair of wide converse shoes. but indoor soccer shoes are good too. the experts recommend 'rod laver' adidas
12:58:34 <dons> oh, these shouldn't be light. the sand filled ones are soft, but heavy
12:58:49 <ddarius> SamB: Or BSP, or bounding volume hierarchies, etc.
12:59:30 <vincenz> dons: are you able to catch on your toe?
13:00:26 <dons> vincenz: yeah, but its hard without the sandfilled ones
13:00:43 <dons> as soon as i got a 'sand bag' i could catch on the toe, toss onto my forehead, catch there. and so on.
13:00:47 <dons> it made a huge difference
13:01:31 <vincenz> monofooted?
13:01:40 * vincenz can't kick with his left foot
13:01:42 <dons> this one, http://www.freedomfootbags.com/shredshop/mrsandbagfootbag-p-28.html
13:01:46 <lambdabot> Title: Mr. Sandbag Footbag | FreedomFootbags.com | Your Footbag (hacky sack &reg;) Shop, http://tinyurl.com/2rn99v
13:01:47 <dons> oh, yeah, you have to train both feet.
13:01:53 <dons> but i'm still not as good on my left.
13:02:56 <dons> takes daily practice
13:03:23 <SamB> ddarius: I'm just trying to see how you'd apply that to a whole cluster of rays
13:03:38 <vincenz> nod
13:03:45 <vincenz> dons: and do you?
13:03:47 * glguy is better with the outside of his foot than the inside
13:04:01 <vincenz> glguy: I can't angle the outside horizontally'nuff
13:04:24 <dons> vincenz: i used to, until i moved here, and my footbags are in transit across the pacific :)
13:04:35 <vincenz> dons: you live in the US, every store sells em!
13:04:35 <dons> oh, they have specialist shoes now, http://www.freedomfootbags.com/shredshop/product_info.php?products_id=86
13:04:36 <lambdabot> Title: Quantum02 Footbag Shoe | FreedomFootbags.com | Your Footbag (hacky sack &reg;) S ..., http://tinyurl.com/2ukfq8
13:04:38 <dons> that's new.
13:04:56 <glguy> dons: at a certain point they will have to call them yoyos :)
13:05:09 <glguy> you can only have so much specialized equipment before you are cheating :)
13:05:13 <dons> heh
13:05:26 <dons> shoes are like raquets for footbags though
13:05:30 <dons> so it makes sense to have ones that work
13:05:35 <glguy> I suppose :)
13:05:40 <glguy> I'll have to bring my yoyo to work sometime
13:05:44 <dons> ?spell raquets
13:05:45 <glguy> I have a cool one
13:05:48 <dons> i think there's a 'c' in there
13:05:50 <vincenz> racket
13:05:52 <vincenz> racquet
13:05:52 <dons> no no.
13:05:56 <dons> yes.
13:06:18 <ddarius> @google "Interactive Rendering with Coherent Raytracing"
13:06:19 <lambdabot> http://citeseer.ist.psu.edu/wald01interactive.html
13:06:19 <lambdabot> Title: Interactive Rendering with Coherent Ray Tracing - WALD, SLUSALLEK, BENTHIN, AND  ...
13:08:18 * vincenz is better at juggling
13:09:06 <ray> did somebody say ray tracing?
13:09:15 <glguy> dons: http://www.tomkuhn.com/images/products/tomcat.jpg
13:09:29 <vincenz> glguy: does it have an engine?
13:09:40 <vincenz> and a little button to say "grip now" ?
13:09:45 <glguy> no
13:09:47 <glguy> :)
13:09:53 <glguy> just a bearing
13:10:03 <vincenz> which direction?
13:10:33 <glguy> ?
13:10:44 <dons> glguy: oh ,nice. so a good clutch yoyo?
13:10:45 <glguy> I mean a ball bearing axle
13:10:50 <vincenz> glguy: it was a poor play on words
13:11:05 <glguy> dons: it isn't one of those that comes back up on its own
13:11:18 <vincenz> glguy: so what if you want to let it keep spinning at the bottom?
13:11:27 <dons> glguy: ah ok.
13:11:27 <glguy> you throw it and it stays down
13:11:32 <SamB> ddarius: ... they don't even do shadow rays???
13:11:33 <glguy> if you want it to come up you have to tug at it
13:11:39 <vincenz> right :)
13:13:17 <fasta> Is there some way to make an application in Haskell in which you have large structures in memory that take too long to be regenerated, but s.t. in the same address space a program can be updated while it's running?
13:13:45 <dons> more info please, fasta
13:13:55 <glguy> he wants to load code at runtime
13:14:03 <SamB> reload, in fact
13:14:03 <glguy> so he doesn't have to regenerate some data in memory
13:14:05 <dons> oh, reloadable static data?
13:14:20 <fasta> dons: no, for example a data base.
13:14:43 <glguy> kaleidoscope data base?
13:15:07 <dons> mm :)
13:15:29 <glguy> then you wouldn't need to worry about memory constraints
13:15:37 <dons> right.
13:16:32 <dons> glguy: see this request for new maintainers for the collections package?
13:16:42 <dons> and that they actually want/have faster versions of much of containers?
13:16:50 <glguy> link?
13:18:11 <dons> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/32248
13:18:12 <lambdabot> Title: Gmane Loom
13:18:28 <dons> there's a huge amount of stuff in there, so its suffering a bit from "missingH syndrome"
13:18:46 <ddarius> SamB: ?  Anyway, that was a long time ago.  Stuff has moved on since then.  This has some interesting slides http://www.cs.utah.edu/~shirley/irt/
13:18:46 <lambdabot> Title: State of the Art in Interactive Ray Tracing
13:18:53 <dons> breaking out individual, or small sets, of structures, so people actually get some experience using them, would be a start
13:19:04 <dons> but seems like their long term goal is replacing stuff in containers.
13:19:07 <hkBst> :t >>=
13:19:08 <lambdabot> parse error on input `>>='
13:19:29 <hkBst> @src >>=
13:19:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:19:35 <mauke> :t (>>=)
13:19:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:20:01 <vincenz> fasta: why not simply dump?
13:20:13 <glguy> dons: who has avoided using missingh for its size?
13:21:10 <dons> its hard to know what's in a huge , unfocused library
13:21:28 <dons> so , for example, no one dependend on missingh till it was broken up
13:21:34 <fasta> Ok, let me put it differently: you are developing an application in which you first need to load 8GB of data from disk before you can run your program, clearly reading this from disk to main memory every time is not going to work. You could make a separate application that holds this data for which you "know" you won't ever change it (not realistic), but it would be better if you could just redefine every function later(like CL allows, IIRC). Is there s
13:21:43 <dons> similarly, here, we should have, say, an AVL package
13:22:07 <oerjan> fasta: i understand that Erlang is quite good at that sort of thing, and i think haskell with threads can do the same things as Erlang processes
13:22:34 <fasta> oerjan: but redefining functions in Haskell is exactly what it doesn't support :)
13:22:52 <oerjan> fasta: erlang doesn't really either, afaik
13:22:56 <dons> there's hot loading for haskell, but perhaps you just want to lift the accessor functions into data, and then reload the data
13:23:05 <fasta> oerjan: unless you use hs-plugins, but I don't know whether that works in general.
13:23:35 <fasta> dons: lift the accessor functions into data?
13:23:59 <fasta> oerjan: I didn't claim Erlang did. :)
13:24:27 <dons> usual trick for this stuff. you lift the api for accessing some resource into a record structure, and then you can replace elements of that structure at will
13:24:34 <dons> first class modules, basically
13:25:00 <dons> now, some pieces might be replaced via code loading, or forking a new binary, or swapping in alternative implementations
13:26:22 <fasta> dons: but this reloading of data (I do understand what you mean) should also happen via some kind of hs-plugins way then.
13:27:17 <dons> ok. another alternative is xmonad-style reloading: make the core app a library, recompile the set of defaults, serialise any state, and fork the updated process
13:27:26 <fasta> Or is there some call on UNIX by which you can replace the current process?
13:27:27 <Lemmih> dons: Changing compiler options could lead to segfaults, no?
13:27:33 <Zao> fasta: exec.
13:27:35 <mauke> fasta: exec?
13:27:39 <dons> Lemmih: right, you have to be careful about interfaces
13:27:55 <dons> fasta: exec. see the forkProcess package in unix
13:28:01 <fasta> So, exec is basically an abortive continuation.
13:28:04 <fasta> How nice.
13:28:09 <dons> fasta: xmonad uses this to reload new configurations
13:28:14 <mauke> exec is a tail call at the process level
13:28:16 <dons> so there's already a lot of code in there for this
13:28:19 <mauke> except not
13:28:25 <Lemmih> I've been thinking about this problem in relation to HAppS. I came to the conclusion that a serialize/deserialize step is necessary.
13:28:41 <glguy> xmonad has to pass the state through as command line arguments
13:28:42 <dons> right, you need to flush state at the very least
13:29:07 <dons> so, compile configuration file, serialise state, fork new binary, pass in state
13:29:09 <dons> and off you go
13:29:15 * dons hits mod-q in xmonad a few times for fun
13:29:45 <fasta> To make the time to do that operation zero, you could have the two processes talk to each other, I guess.
13:30:06 <dons> yeah, you can keep a proxy running
13:30:11 <dons> some kind of buffer process
13:30:32 <dons> glguy: anyway, what do you think about this data structures stuff?
13:30:32 <fasta> Is there a system call to do that?
13:30:41 <dons> seems like a terrible waste to have such good code going unused
13:30:49 <dons> and there's a bunch of data types in there that should be in the containers package
13:30:52 <dons> queues!
13:31:09 <glguy> dons: it works now?
13:31:19 <glguy> dons: and people can depend on this new package directly?
13:31:22 <dons> yeah, just no one uses it, cause its too big
13:31:25 <dons> they can, afaik
13:31:42 <dons> it needs a maintainer, and a plan for mainstreaming the library
13:32:00 <dons> that's a new term i just made up for the process of getting people to use some code
13:32:00 <glguy> I'll have to play with it at work tomorrow
13:32:11 <fasta> dons: what library? missingh?
13:32:13 <dons> i think a couple of us could probably do the maintainership
13:32:18 <dons> fasta: collections
13:32:21 <glguy> I don't have ghc access at home for now :)
13:32:21 <dons> the former edison lib
13:32:49 <fasta> dons: the current maintainer stopped maintaining it?
13:32:57 <glguy> I seem to remember edison needing a bit of a tutorial to get started using it
13:33:04 <dons> right, too big, to clunky.
13:33:10 <dons> individual structures make more sense
13:33:17 <dons> and once we understand the pieces, moving them into base/containers
13:33:27 <dons> since core CS data structures should be easy to find and use
13:33:36 <fasta> I found it quite easy to use, but too limited.
13:34:09 <fasta> I did use the queue implementation, but it was too much effort to recompile it everytime everytime I upgraded GHC.
13:35:04 <dons> ok. that's useful to know
13:35:33 <dons> `too much effort to recompile' == too big?
13:35:47 <fasta> Well, I only needed a small part.
13:35:52 <dons> right.
13:35:54 <dons> glguy: ^^
13:35:58 <dons> missingh syndrome
13:36:18 <fasta> It's more a GHC syndrome.
13:36:32 <dons> if you're a glass-half-empty kind of person
13:36:48 <glguy> more of a packaging issue
13:36:52 <fasta> dons: ?
13:36:58 <fasta> dons: I don't see how that is relevant now.
13:37:06 <vincenz> Anyone have some good basic document on the basics of stock trading?
13:37:14 <dons> btw, who's using cabal-install ?
13:37:28 <fasta> dons: I don't see the technical need to break compatibility everytime I compile GHC from darcs.
13:37:48 <fasta> dons: I used it two times.
13:37:54 <dons> ghc is a whole program compiler
13:38:35 <fasta> dons: it could provide two build targets.
13:38:57 <dons> yes, you could provide a "no inlining in .hi files" abi
13:39:15 <fasta> But maybe that's too much work, I don't know.
13:39:23 <dons> but those tracking darcs are few enough that it isn't worth it
13:39:27 <dons> just get cabal-install working
13:39:30 <dons> makes life a lot easier
13:39:44 <dons> dcoutts__: any thoughts on a cabal install everything target ? :)
13:39:49 <fasta> cabal-install should also use crypto.
13:39:51 <dons> that would install, say, the top 20% more popular haskell libs
13:40:04 <fasta> (and haskell.org should use SSL at the very least)
13:40:15 <dons> what's your concern?
13:40:36 <dons> checking checksums against the source would be good
13:40:43 <fasta> dons: RANDOM ISP playing a man in the middle attack?
13:40:45 <TomMD> fasta: I agree - I wouldn't install something with the end result being completely unverifiable.
13:40:58 <fasta> TomMD: then you currently cannot install anything.
13:41:04 <dons> you do have a type checker. but we could at least do some chksums
13:41:37 <fasta> dons: the problem is that the checksums are distributed by haskell.org too.
13:41:43 <fasta> dons: which is not verifible.
13:41:43 <TomMD> fasta: wrong.  I can verify hashes for some packages.  I can preview source (or at least take confort in knowing I have it and an adversary usually wouldn't want to provide that).
13:41:52 <fasta> verifiable*
13:42:12 <fasta> TomMD: the hashes can be made by the attacker.
13:42:24 <TomMD> fasta: Also, I have a hackage account, so I can ssh in and do all that goodness.
13:42:42 <TomMD> fasta: You miss the point, but I must go - msg me if you want to continue this in about two hours.
13:42:49 <fasta> TomMD: hmm, that would solve it.
13:42:57 <fasta> Just hand everyone a ssh account.
13:43:40 <fasta> TomMD: ok, so it's safe for _you_.
13:44:02 <fasta> s/safe/relatively safe :)
13:44:02 <sjanssen> fasta: SSL + hashes of the tarballs seems sufficient?
13:44:18 <fasta> sjanssen: yes, that seems sufficient.
13:44:43 <fasta> sjanssen: but I don't see https when going to http://haskell.org
13:44:43 <lambdabot> Title: Haskell Community Server
13:44:48 <ddarius> Wouldn't just having a public/private key for haskell.org and a secure hash work?
13:45:02 <sjanssen> (assuming that we can trust Ross Paterson and all people that he trusts :)
13:45:03 <thorkilnaur> glguy, about ghc on ppc leopard: See today's comments on http://hackage.haskell.org/trac/ghc/ticket/1843
13:45:05 <lambdabot> Title: #1843 (ghc 6.8.1 broken on Mac OS X Leopard PPC) - GHC - Trac
13:45:26 <glguy> thorkilnaur: I read your comments earlier, I just didn't notice those were from today :)
13:45:33 <fasta> ddarius: one way or the other you need to tie those crypto stuff to the webpage.
13:45:43 <fasta> that crypto stuff*
13:46:17 <sjanssen> ddarius: SSL seems simpler for the client
13:46:23 <ddarius> sjanssen: Most probably.
13:46:52 <ddarius> fasta: Obviously there will need something certifying the key pair, but otherwise it should be sufficient.
13:47:06 <fasta> ddarius: yes, then we agree.
13:47:34 <fasta> Squeak still has this hugely insecure setup.
13:47:36 <visof> join #physics
13:47:39 <sjanssen> it really shouldn't require much work at all
13:47:57 <fasta> CL has ASDF-INSTALL which already does this.
13:48:42 <mux> if you have a list and know it has precisely two elements (say [x,y]), and you want to write x * y, would you guys write foldl1 (*) or would you pattern match to ensure there are indeed two elements?
13:49:04 <dons> use a tuple?
13:49:12 <dons> and enforce it in the type
13:49:13 <mux> naw, it comes from a matrix multiplication
13:49:25 <mux> I really really want lists
13:49:36 * Heffalump tries to figure out some cunning way to get a fundep accepted
13:49:51 <mux> and this is one single case lost in the maze, it doesn't deserve a type
13:49:53 <Heffalump> I have a class Foo s a sa | s a -> sa, sa -> s a
13:50:05 <oerjan> mux: that would depend on how important it is that there are precisely two elements, wouldn't it?
13:50:11 <mux> I just know at this particular point in my algorithm that I'm going to use a 1x2 matrix
13:50:25 <Heffalump> the idea is that it's rather like an associated type application, but the mapping is one-to-one
13:50:30 <mux> oerjan: I guess so, I'm trying to strike a good balance between conciseness and safeness WRT bugs
13:50:52 <Heffalump> unfortunately, I want to have instance Foo s Int (s Int), and (Foo s a sa, Foo s b sb) => Foo s (a, b) (sa, sb)
13:51:06 <oerjan> mux: well, (\[x,y]->x*y) isn't that long
13:51:10 <Heffalump> and it complains that the two violate the fundep, cos s Int might conceivably be (sa, sb)
13:51:35 <mux> oerjan: I thought (\(x:y:[]) -> x * y) would be the only way to write it?
13:51:39 <Heffalump> at least, I think that's why it's complaining.
13:51:50 <oerjan> mux: no, [x,y] should work fine
13:51:58 <oerjan> they are entirely equivalent afaik
13:51:59 <mux> oh well that changes a heck lot of things ;-)
13:52:22 <ddarius> mux: It would be written with pattern matching.
13:55:24 <mux> cheers
13:55:50 <oerjan> :)
13:59:21 <noobie> is there a way to make  a haskell function automatically load. when it is runned in haskell the program starts with the function name been typed
13:59:39 <mauke> main = somefunction
13:59:55 <dons> noobie: or compile your haskell program
14:00:05 <ddarius> Wald's thesis (whose title I do not know) is 34.5MB!
14:00:38 <kaol> @where Wald's thesis
14:00:38 <lambdabot> I know nothing about wald's.
14:01:13 <noobie> main = myfunction , would make it run automatically without anythin been typed?
14:01:42 <sjanssen> noobie: yes
14:01:50 <noobie> ok
14:01:54 <mrd> when you compile it, or use runhaskell
14:01:55 <oerjan> noobie: depends on exactly how you load the program
14:02:02 <sjanssen> noobie: when run with 'runhaskell' or when compiled
14:02:13 <ddarius> kaol: It's undoubtedly packed full of relatively high-resolution images.
14:02:18 <ddarius> @google Wald thesis
14:02:19 <lambdabot> http://www.mpi-inf.mpg.de/~wald/PhD/
14:02:19 <lambdabot> Title: Ingo Wald: PhD Thesis
14:02:19 <noobie> i am using hugs
14:02:20 <oerjan> if you load it in an interpreter you may still have to write :main or main
14:02:33 <sjanssen> noobie: use runhugs, in that case
14:02:40 <noobie> ok
14:02:41 <mrd> runhugs MyFile.hs
14:03:20 <oerjan> noobie: btw hugs has an option to check if a file has changes
14:03:24 <oerjan> *changed
14:03:30 <noobie> what i want another function to be loaded automatically after the first as been used could i use return (nextfunction)
14:03:50 <oerjan> if you set that, reloading will happen automatically
14:03:52 <mrd> they are all loaded.  are you asking "how do I call a function next?"
14:04:05 <noobie> yes
14:04:12 <mrd> main = do func1; func2
14:04:21 <ddarius> SamB: Does HRDI mean anything to you?
14:04:21 <noobie> ok
14:04:27 <mrd> or newline instead of semicolon, but then indentation must match func1
14:04:41 <njbartlett> Has anybody managed to build nhc98 on Mac OSX?
14:05:20 <dfranke> dons, ok, the threaded runtime seems to make the forkIO problem go away.
14:05:29 <dons> makes sense
14:06:12 <dfranke> now I just need to figure out why mingle isn't working.  I'm guessing that one is an OS-level issue.
14:06:59 <dfranke> (mingle takes two lazy bytestrings and spawns two threads that write them to two pipes with the same endpoint)
14:07:37 <mauke> your task, should you choose to accept it, is to define a class that can have at most one instance
14:07:55 <sjanssen> mauke: easy
14:08:16 <dons> yeah, there was a thread about this a while ago
14:08:19 <dons> closed classes
14:08:29 <mauke> sjanssen: how would you do it?
14:08:40 <sjanssen> module Foo (OneInstance(..)) where class Closed a; class Closed a => OneInstance a; instance OneInstance Int
14:09:02 <sjanssen> oh, and instance Closed Int
14:09:19 <vincenz> nice trick :)
14:09:42 <ddarius> mauuke: class OneInstance a | -> a
14:09:47 <sjanssen> mauke: ie. require a superclass that is not exported
14:09:53 <vincenz> ddarius: is that valid syntax?
14:09:57 <mauke> ddarius: yep, that was my solution
14:09:58 <ddarius> vincenz: Yes, why not.
14:10:03 * vincenz shrugs
14:10:04 <mauke> sjanssen: nice
14:10:57 <dfranke> dons, maybe I'll just get rid of mingle.  I added it because it simulates what happens when two pipes both output to a terminal, but I'm not sure how useful it actually is.
14:11:08 <jsedgwick> could someone explain where and why let clauses are needed?
14:11:15 <ddarius> Would class (Int ~ a) => OneInstance a  work?  I'm not up-to-speed with associated types.
14:11:27 <dons> jsedgwick: they're the primitive lazy binding form
14:11:36 <dons> but sugar for variable binding is built on top of them
14:11:36 <mux> @check \(a,b) -> (a :: Int) `div` (b :: Int) == floor (fromIntegral a / fromIntegral b)
14:11:37 <sjanssen> ddarius: yes, I think so
14:11:38 <lambdabot>  Exception: divide by zero
14:11:41 <dons> so you can get away with never using them
14:11:54 <mux> @check \(a,b) -> b /= 0 ==> (a :: Int) `div` (b :: Int) == floor (fromIntegral a / fromIntegral b)
14:11:55 <lambdabot>  OK, passed 500 tests.
14:12:05 <mux> @check \(a,b) -> b /= 0 ==> (a :: Int) `quot` (b :: Int) == floor (fromIntegral a / fromIntegral b)
14:12:06 <lambdabot>  Falsifiable, after 11 tests: (-2,4)
14:12:16 * mux hearts quickcheck
14:12:26 <jsedgwick> dons how so?
14:12:29 <ddarius> jsedgwick: You -could- get rid of them using fix and lambdas.
14:13:16 <dons> jsedgwick: well, let x = e1 in e2 allocates a suspended computation for e1, and proceeds to evaluate e2
14:13:25 <dons> all other sugar for variable binding is on top of this
14:13:30 <dons> and gets translated down into let
14:13:44 <dons> so its the basic mechanism for user-land laziness
14:14:22 <jsedgwick> you're way beyond me, sorry
14:15:23 <dons> oh, so as a haskell programmer, you need never use 'let'
14:15:26 <mauke> then what does your question mean? :-)
14:16:41 <fasta> jsedgwick: \a b c -> expression_containing a b c) 1 2 3 and let a = 1;b=2;c=3 in expression_containing a b c are the same
14:17:01 <fasta> jsedgwick: that's all dons meant, AFAIK.
14:17:11 <oerjan> > (let x = 3 in x+1, (\x -> x+1) 3, let f = x+1 where x=3 in f)
14:17:12 <lambdabot>  (4,4,4)
14:17:58 <hpaste>  hsuh pasted "xmonad 0.5 testing" at http://hpaste.org/4083
14:18:24 <mauke> no, that workspaces variable won't have any effect
14:18:28 <jsedgwick> i'm getting the feelingYAHT doesn;t actually explain anything like that
14:18:37 <mauke> it needs to be part of the conf thingy
14:18:37 <jsedgwick> just throws the notation out there
14:18:40 <fasta> jsedgwick: and why would it do that?
14:18:46 <mauke> er
14:18:57 <hpaste>  sjanssen annotated "xmonad 0.5 testing" with "fixed" at http://hpaste.org/4083#a1
14:20:22 <fasta> What's the point of not releasing a ghc-6.8.1 package for Debian? Does it have too little users?
14:20:41 <dons> um.
14:20:55 <dons> no one has built one, most likely.
14:21:04 <dons> or ghc-6.8.1 is provided in debian already somewhere
14:21:28 <fasta> Well, Igloo is the package "maintainer".
14:21:34 <sjanssen> fasta: I assume that Igloo has been too busy so far
14:22:06 <fasta> sjanssen: right, so someone should replace him for that task, since the same issue was with 6.6.1, IIRC.
14:22:10 <hpaste>  jsedgwick pasted "let examplen" at http://hpaste.org/4084
14:22:30 <sjanssen> fasta: go for it, Mr. Volunteer ;)
14:22:55 <fasta> sjanssen: Couldn't you say something less predictable?
14:22:59 <fasta> sjanssen: :)
14:23:18 <jsedgwick> why do you need let/in there?
14:23:38 <oerjan> jsedgwick: to avoid writing the expression for det several times?
14:23:46 <Igloo> Has anyone got any suggestions for a good, non-interactive web link checker?
14:24:01 <dons> ?remember Franklin history is made by those who turn up
14:24:01 <lambdabot> Nice!
14:24:16 <dons> Igloo: i use 'linkchecker' or 'urlcheck'
14:24:17 <jsedgwick> i mean, instead of saying det= blah *newline* expression involving det
14:24:19 <sjanssen> fasta: I know that Gentoo has a 6.8.1 package, but many libraries don't build with it, many libraries haven't even been ported for 6.8 upstream
14:24:20 <dons> the latter is a haskell package ;)
14:24:30 <dons> linkchecker is more featureful, but slower and harder to kill
14:24:38 <Igloo> dons: Can you tell linkchecker not to check external links?
14:24:49 <dons> hmm. possibly. it has a lot of options
14:25:56 * Igloo can't see one, although --no-follow-url=^http:// might do it
14:26:42 <TSC> jsedgwick: That form only works for top-level functions (those that aren't inside other functions)
14:27:06 <oerjan> jsedgwick: in haskell syntax, the newline sensitive portions are always started with one of a small number of keywords: let, where, do, of.  Makes it easier to parse I guess.
14:28:18 <jsedgwick> i see. which leads me to my next question [shortbus]what do where clauses do/[/shortbus]
14:28:34 <hpaste>  oerjan annotated "let examplen" with "with where" at http://hpaste.org/4084#a1
14:28:40 <mauke> jsedgwick: backwards let
14:28:41 <sjanssen> jsedgwick: that has actually been proposed before.  I think the main objection is readability
14:29:37 <oerjan> jsedgwick: see my paste, it's equivalent
14:30:07 <jsedgwick> oh, wow. also, perhaps there is a more in-depth tutorial/book about haskell that will be more gentle to those with no FP experience
14:30:22 <jsedgwick> oerjan: thanks for the paste, that explains it perfectly
14:30:49 <fasta> jsedgwick: quicksilver recommends the book by Graham Hutton.
14:31:13 <mauke> emacs'd
14:31:19 <jsedgwick> who is quicksilver?
14:31:33 <fasta> jsedgwick: Jules Bean, a #haskell regular.
14:31:52 <oerjan> @seen quicksilver
14:31:53 <lambdabot> quicksilver is in #haskell and #ghc. I last heard quicksilver speak 4h 22m 10s ago.
14:32:00 <fasta> jsedgwick: The Haskell School of Expression also works.
14:32:12 <sjanssen> jsedgwick: there's even a review of that book in The Monad.Reader, written by dcoutts
14:32:30 <fasta> jsedgwick: I think it's better to just read SICP and then see the obvious mapping to Haskell.
14:33:11 <oerjan> o_O
14:33:17 <fasta> jsedgwick: but it depends a lot on background... I read 3 Haskell books from start to end after I already programmed a lot in Haskell. For me the value of those books were limited.
14:33:43 <fasta> Most of the books only show trivial examples.
14:34:05 <oerjan> @remember fasta [on Haskell tutorials] I think it's better to just read SICP and then see the obvious mapping to Haskell.
14:34:05 <lambdabot> I will remember.
14:34:19 <jsedgwick> ahbackground here = no FP, plenty of c/c++/java/perl
14:34:40 <fasta> jsedgwick: and this is a FAQ.
14:34:50 <fasta> @where books
14:34:50 <lambdabot> I know nothing about books.
14:34:51 <mauke> perl will be the most important language here, I think
14:34:55 <dons> has anyone had a go at porting sicp to haskell?
14:35:06 <mauke> it's closest to haskell in a few ways
14:35:11 <dons> yeah, at least perl as higher order builtins :)
14:35:13 <rue> The "Write Yourself a Scheme in 48 Hours" book is a good follow-up to YAHT or something
14:35:17 <fasta> dons: partially, yes, but not me.
14:35:50 <fasta> dons: there exist these "implement SICP" in every language known to mankind webpages.
14:36:04 <dons> i know.
14:36:17 <dons> it only makes sense in a couple of languages though ;)
14:36:24 <fasta> dons: oh, you meant a complete implementation?
14:36:45 <fasta> dons: or rather: what did you mean?
14:37:11 * oerjan beats his head with a hammer after it suggests he translates SICP to Unlambda
14:37:15 <dons> a good port to haskell of the core material
14:41:28 <hpaste>  luqui pasted "Comonad ArrowApply instance??" at http://hpaste.org/4085
14:45:19 <oerjan> luqui: and that is well-typed?  Presumably then there must be some implied equation for ArrowApply that it violates.
14:45:37 <luqui> it is well types
14:45:40 <luqui> *typed
14:45:46 <luqui> so yes I assume it violates some law
14:46:03 <luqui> just making sure monads were not equivalent to comonads in some obscure way or something...
14:53:23 <jsedgwick> anyone know where i can buy an ebook of sutton's programming in haskell?
15:02:50 <andyjgill> jsedgwick: there is no online copy, I believe,  for Huttons  book.
15:03:46 <Octoploid> jsedgwick: http://www.cambridge.org/catalogue/catalogue.asp?isbn=9780511292187
15:03:47 <lambdabot> Title: Programming in Haskell - Cambridge University Press, http://tinyurl.com/25ls2b
15:20:37 <conal> in case some folks here haven't seen it: http://www.youtube.com/watch?v=JX3VmDgiFnY
15:20:38 <lambdabot> Title: YouTube - Moebius Transformations Revealed
15:24:01 <conal> sigh ... i love that video
15:26:11 <hajamie> Hi, anyone know a tutorial that I can read - I can program in java and PHP, but don't get functional programming at all...  I don't understand the way functions are defined.  Cheers
15:27:42 <hajamie> Also, I'm probably not doing this right because I've never played with IRC before.
15:28:28 <oerjan> @where yaht
15:28:28 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
15:29:21 <oerjan> that's one
15:29:33 <rue> http://haskell.org/haskellwiki/Learning_Haskell for a few variants
15:30:40 <dibblego> ?type (.)
15:30:51 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:31:22 <dibblego> @docs Monoid
15:31:22 <lambdabot> Monoid not available
15:31:28 <dibblego> @docs Data.Monoid
15:31:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
15:31:49 <dibblego> I posted a patch the other day for @docs
15:31:53 <hajamie> Thanks, I'll check them out, I looked at the YAHT one, still confused!
15:32:52 <oerjan> dibblego: so @docs Monoid will work then?
15:33:05 <dibblego> yeah, the base url has changed
15:33:19 <dibblego> I posted the patch on hpaste (is that the usual way of doing it?)
15:33:21 <oerjan> well that too, i mean without the Data :)
15:33:28 <dibblego> oh, not that :)
15:34:11 <oerjan> i somehow doubt hpaste is the official place...
15:34:31 <dibblego> there's probably a darcsy way of doing it
15:34:53 <oerjan> yeah, that's probably what maintainers prefer
15:35:03 <dibblego> I can find lots of documents talking about satisfying the monoid laws, but none that actually specify those laws
15:35:13 <oerjan> oh.
15:35:38 <dcoutts_> @seen dons
15:35:38 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 28m 29s ago.
15:35:53 <dcoutts_> dons: re: cabal install everything...
15:35:56 <oerjan> mempty `mappend` x = x, x `mappend` mempty = x, x `mappend` (y `mappend` z) = (x `mappend` y) `mappend` z
15:36:10 <dibblego> oerjan, that's what I thought, thanks (thought there might be more)
15:36:24 <oerjan> dibblego: that's the usual mathematical definition of a monoid
15:36:32 <dibblego> oerjan, great, cheers
15:36:55 <dcoutts_> dons: I'd like to see cabal-install become capable of being a package testing agent, so eg you could connect it up to the hackage rss feed and build all new stuff and submit results.
15:37:44 <oerjan> dibblego: note that the monad laws are analogues to those (mon comes from monoid, iiuc)
15:37:56 <dibblego> yep
15:38:08 <dcoutts_> dons: as for things like meta-packages, it's probably more useful to define a standard platform like I was suggesting the other day. What would the 20 most popular packages give you if you can install any package at any time?
15:40:27 <luqui> I'm trying to profile a program, but when I compile I just get      Could not find module `Graphics.Rendering.OpenGL':
15:40:27 <luqui>       Perhaps you haven't installed the profiling libraries for package OpenGL-2.2.1.1?
15:40:50 <luqui> how do I say "I don't care about that library"
15:40:53 <luqui> if possible
15:42:41 <dcoutts_> luqui: you can't :-(
15:42:51 <luqui> so I'm just out of luck?
15:43:07 <dcoutts_> no, just install the profiling libs for that package
15:43:13 <dcoutts_> then it'll all work fine
15:43:20 <ddarius> Nice movie conal
15:43:31 <luqui> do you know if there's a clean way to do it on gentoo?
15:43:44 <luqui> or will I have to bring it kicking and screaming as usual :-)
15:44:48 <Saizan> dcoutts_: btw, is there a bug tracker for cabal-install? passing cabal install --global ignores the flag without reporting an error, that's a bit confusing (but cabal --global install works)
15:45:18 <dcoutts_> Saizan: yes, the cabal/hackage bug tracker has a cabal-install component
15:45:37 <dcoutts_> http://hackage.haskell.org/trac/hackage/
15:45:38 <lambdabot> Title: Hackage - Trac
15:46:07 <dcoutts_> Saizan: btw, I'm rewriting the cabal-install command line handling at the moment so we should be able to squash that one
15:46:44 <dcoutts_> The new behaviour will be cabal install --global, not cabal --global install. The latter will give an error message.
15:47:13 <dcoutts_> there will be very few 'global' flags, almost all of them will be sub-command flags
15:47:50 <shu> hello, is there a way to make existent datatypes derive Typeable and Data from Data.Generics without manually writing out the code?
15:48:04 <shu> motivation being i have a record datatype with a CalendarTime in it
15:48:35 <luqui> got it...
15:48:58 <ddarius> @google Data.Derive
15:48:59 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/derive/
15:48:59 <lambdabot> Title: Neil Mitchell - Derive
15:49:01 <Lemmih> shu: deriving instance Typeable CalendarTime.
15:49:05 <Saizan> dcoutts_: yeah, seems better
15:49:25 <shu> Lemmih, ah i see
15:50:34 <shu> looks like a GHC extension, i see
15:50:54 <Lemmih> shu: It's new in ghc-6.8.
15:52:37 <shu> thanks for the info
16:28:16 <ivanm> I'm going to be doing my honours in mathematics next year... does anyone have any suggestions on haskelly projects I could do?
16:29:51 <TomMD> ivanm: A) Make the rolled 'pureMD5' as fast as the unrolled version B) Make the trival fib implementation efficient
16:30:24 <Olathe> Solve the halting problem...in Haskell !
16:30:41 <ddarius> Olathe: We already did that.
16:30:41 <lament> too easy
16:30:44 <Olathe> Oh.
16:31:10 <Olathe> Enumerate the reals !
16:31:35 <Olathe> Wait, [0.0..] should do that.
16:31:50 <Japsu> > [0.0 ..]
16:31:51 <lambdabot>  [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,...
16:31:52 <Olathe> With a nice map, of course.
16:31:59 <Japsu> which is evil
16:32:02 <Olathe> > [0.0, 0.0..]
16:32:03 <lambdabot>  [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0...
16:32:05 <Olathe> There we go.
16:32:24 <Olathe> The .. means it's a bunch of zeroes except for the 1 on the end.
16:33:13 <dons> http://programming.reddit.com/info/61ecu/comments/ :)
16:33:23 <dons> `Haskell: a language for fast, multi-core concurrency (cgi.cse.unsw.edu.au)'
16:33:25 <dons> in response to,
16:33:28 <dons> http://scienceblogs.com/goodmath/2007/11/erlang_a_language_for_function.php
16:33:29 <lambdabot> Title: Good Math, Bad Math : Erlang: a Language for Functional Concurrency, http://tinyurl.com/2pm3wh
16:34:44 <ddarius> "which is one of the most influential languages currently in the programming language research community"
16:34:54 <laz0r> is there a way to do [0,(-1),..]?
16:35:09 <laz0r> oi
16:35:10 <resiak> dons: "To run such a threaded Haskell program across multiple calls" --- should that be "cores"?
16:35:13 <Olathe> > [0,(-1)..]
16:35:14 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
16:35:15 <ddarius> Haskell has well-defined semantics?
16:35:16 <dons> resiak: ah thanks.
16:35:20 <laz0r> it works, just the comma was wrong...
16:35:31 <Olathe> > [0,(-1)..5]
16:35:31 <lambdabot>  []
16:35:32 <resiak> dons: i expected a rebuttal to appear soon, but not this soon!
16:35:45 <Olathe> > [0.0,(-1.0)..5.0]
16:35:46 <lambdabot>  []
16:35:58 <ddarius> The dons PR machine moves quickly.
16:36:06 <dons> resiak: the 'bad at coarse grained concurrency' is just ridiculous though -- that's the *strongest* point
16:36:14 <dons> he should have emphasised distribution more
16:36:32 <dons> resiak: fixed.
16:36:49 <resiak> right; am I right in thinking that Erlang lets you run your threads on different machine with ~zero modifications?
16:37:16 <dons> you need support from the distribution (OTP?) libraries
16:37:21 <dons> so spawn maps to different constructors
16:37:32 <dons> s/constructs/
16:38:15 <Pseudonym> To be fair, Haskell doesn't work quite in the same space where Erlang does.
16:38:20 <dons> right.
16:38:26 <Pseudonym> You can't transparently migrate Haskell threads across a network.
16:38:37 <dons> yes, you have to talk about distribution and migration
16:38:41 <dons> not multicore concurrency
16:38:59 <ivanm> TomMD: I fail to see how either of them would be "mathsy enough"
16:39:09 <dons> i think haskell owns the low end multicore space for now
16:39:23 <ddarius> dons: Isn't Erlang slightly newer than Haskell?
16:39:25 <Korollary> Did anyone at any point assert that Haskell programs could be trivially parallelized?
16:39:28 <ivanm> ddarius: how was the Halting Problem solved?
16:39:28 <dons> its 5 years or more older
16:39:32 <SamB_XP> ddarius: in what way?
16:39:34 <dons> mid 80s
16:39:36 <ddarius> ivanm: halt _ = True
16:39:42 <ddarius> er halts
16:39:49 <ivanm> heh
16:39:57 <ivanm> so everything can now be halted? :o
16:40:06 <SamB_XP> how about...
16:40:14 <dons> Korollary: so goodmath guy asserts it was seriously non-trivial
16:40:20 <SamB_XP> halts x = x `seq` True
16:40:39 <ddarius> Korollary: They can, but that's not what is neccesary.
16:40:53 <SamB_XP> Korollary: everyone has always known that they can be
16:41:15 <Pseudonym> "Many Haskell proponents claim that because Haskell doesn't specify the order in which things are done, and it makes the data dependency relations explicit, and that therefore, it's more amenable to automatic parallelization."
16:41:25 <Pseudonym> No Haskell proponent has seriously claimed that for at least 10 years.
16:41:30 <ddarius> ivanm: All real programs will eventually terminate.  But if you don't believe me, I'd like a demonstration otherwise.
16:41:42 <SamB_XP> Korollary: but almost as long as they have known that it was possible, they've known that the trivial parallelization was not terribly usefull...
16:41:49 <ivanm> SamB_XP: though doesn't that require that x is a test on whether or not something halts?
16:41:58 <ddarius> Purity makes it more amenable to automatic parallelization, but that doesn't mean efficient parallelization.
16:42:02 <ivanm> ddarius: who said anything about real programs?
16:42:03 <Saizan> dons: the erlang echo loop() resends the message to the sender, it doesn't print it on screen
16:42:08 <ivanm> though here's one: find all prime numbers
16:42:09 <mauke> dons: shouldn't run return l?
16:42:34 <SamB_XP> ivanm: that function does not solve the halting problem ;-). it merely returns true for things that halt...
16:42:40 <dons> mauke: oh, that's weird. typo
16:43:06 <ivanm> SamB_XP: ahhh..... since if x returns a value only
16:43:34 <ivanm> *returns, only then will the value True be returned?
16:44:01 <SamB_XP> well, actually, with that semantics missing, it might be hard to say ;-)
16:44:07 <ivanm> heh
16:44:09 <dons> Saizan: oh, good point.
16:45:05 <dons> Saizan: it seems a silly intro example, because the tid is availble from forkIO
16:45:08 <dons> i'll leave it for now
16:45:12 <idnar_> :t seq
16:45:13 <lambdabot> forall a t. a -> t -> t
16:45:17 <idnar_> @djinn a -> t -> t
16:45:17 <lambdabot> f _ a = a
16:45:18 <Pseudonym> And, I might add, nobody has ever claimed that Haskell is "more amenable" to parallelisation than Erlang.
16:45:33 <idnar> hooray side-effects
16:45:40 <ivanm> back to my original question... apart from TomMD's proposals, does anyone have any _serious_ suggestions on what I could do a maths honours thesis on?
16:45:53 * SamB_XP wonders why this haruhi fansub is at 640x480. was it just for the first episode?
16:45:57 <Korollary> ivanm: You could get ideas from sigfpe's blog posts, etc.
16:46:03 <newsham> wouldnt pure functions be a lot easier to optimize (parallelizing being one optimization)?
16:46:15 <newsham> since the analysis for code movement and ordering is a lot simpler?
16:46:27 <dons> Pseudonym: yeah, there's a bit of a fud rumours going about about haskell claiming and failing to be automatically parallelisable, i've seen that twice in the last 2 weeks
16:46:39 <newsham> (ie. compare to analysis to determine if you can move C code outside of a loop)
16:46:40 <SamB_XP> the claims are true
16:46:55 <ddarius> SamB_XP: It is automatically parallelizable.
16:47:03 <ivanm> Korollary: link?
16:47:14 <Pseudonym> http://garden.irmacs.sfu.ca/?q=container/area <- ivanm, pick one.
16:47:17 <lambdabot> Title: Open Problems | Open Problem Garden
16:47:19 <SamB_XP> but the claimed trivial automatic parralization is useless, as we've admitted for some time now
16:47:20 <Korollary> ivanm: http://sigfpe.blogspot.com/
16:47:29 <lambdabot> Title: A Neighborhood of Infinity
16:47:34 <ddarius> SamB_XP: True.
16:47:38 <ivanm> thanks Pseudonym, Korollary
16:47:40 <Pseudonym> Especially any that's marked "recommended for undergraduates".
16:47:41 <sw17ch> SamB_XP: is it? how so?
16:47:46 <SamB_XP> so, I don't see what there problem is
16:47:52 <TomMD> ivanm: OK, so mine were more of CS suggestions.  Perhaps you are into stocastic processes?  I always find those interesting and fun to program up (ex: A petri net library)
16:47:53 <ivanm> Pseudonym: heh
16:47:59 <SamB_XP> sw17ch: too much overhead
16:48:13 <Pseudonym> I'm particularly interested in this one, since I submitted it:
16:48:15 <SamB_XP> sw17ch: a spark for every delayed computation is a bit over-the-top
16:48:15 <Pseudonym> http://garden.irmacs.sfu.ca/?q=op/smallest_universal_supersequence
16:48:18 <sw17ch> ah, that's right, it's hard to group things into threads appropriately, not allocate things to their own thread
16:48:18 <lambdabot> Title: Shortest string containing all permutations | Open Problem Garden, http://tinyurl.com/2p4zos
16:49:04 <SamB_XP> especially if you don't WANT everything to be computed
16:49:10 <ivanm> dons: with the quote "monads are hard to combine"... isn't the fact that monads are easy to combine one of the things SPJ claimed was why STM was so good?
16:49:14 <Saizan> dons: also, in your code, the numbers are really calculated in the main thread since they are not forced before, i'd think
16:49:18 <SamB_XP> since, you know, you have finite RAM
16:49:30 <SamB_XP> ivanm: monads are not easy to compine!
16:49:34 <SamB_XP> er. combine
16:49:34 <RayNbow> SamB_XP, the first ep of Haruhi is widescreen, except for the movie part that the SOS brigade made
16:50:54 <ivanm> SamB_XP: oh...
16:50:56 * SamB_XP wonders how that works if you actually have a wide screen
16:51:00 <dons> Saizan: now that's an interesting thought. the thunk is passed back to the main thread and forced.
16:51:03 <dons> well, easy enough to check
16:54:15 <dons> no change, if i force it before hand, but +RTS -N2 stays faster
16:54:29 * dons ponders some more
16:55:29 <ivanm> Pseudonym: there doesn't seem to be many undergrad level problems there... :s
16:55:30 <Saizan> uhm, the primes are forced by the construction
16:56:02 <dons> ah yeah, that's enough there.
16:56:17 <Pseudonym> ivanm: There are a couple.
16:56:43 <ivanm> yeah... but not even half a page out of the 5 pages :(
16:57:34 <ivanm> ohhh.... unrelated, but this looks interesting: http://www.arsmathematica.net/archives/2007/11/22/tex-finally-made-functional/
16:57:35 <lambdabot> Title: Ars Mathematica  Blog Archive  TeX Finally Made Functional, http://tinyurl.com/yvu8bk
16:58:49 <Pseudonym> "Haskell simply does not operate in the same space as Erlang.  Erlang does real-time, Haskell doesn't.  Erlang does network independence, Haskell doesn't.  And Haskell does elegant multi-core, shared-state concurrency, Erlang doesn't."
16:58:55 <Pseudonym> That's not a lie, is it.
16:59:07 <dons> seems reasonable
16:59:15 <Pseudonym> Cool.
16:59:19 <SamB_XP> indeed
16:59:19 * Pseudonym posts it to GMBM
16:59:29 <SamB_XP> erlang doesn't seem to support shared state
16:59:36 <Pseudonym> No.
16:59:44 <Pseudonym> To share state in Erlang, you wrap a thread around it.
16:59:51 <Pseudonym> Or you pass it explicitly between threads, which means copying it.
17:01:44 <Pseudonym> Oh, dons:
17:02:00 <Pseudonym> You know that lambda has been "commoditised" when it appears on that Che Guevara picture.
17:02:17 <Korollary> I thought Che was commoditized.
17:02:20 <Pseudonym> ANYTHING is officially commoditised once it appears juxtaposed with that.
17:03:18 <ivanm> where's this?
17:03:23 <Korollary> We need a lambda standing tall before a tank at Tiananmen Square.
17:05:52 <hsuh> i suggest a lambda instead of the piramid on the dollar bill
17:06:15 <Korollary> Lambdas are not that cheap
17:06:19 <hsuh> heh
17:06:28 <Korollary> Canadian Dollar maybe
17:06:47 <Olathe> I'm selling lambdas cheap.
17:07:10 <ivanm> how cheap?
17:07:20 <Olathe> 25 cents each.
17:07:24 <Korollary> refurbished lambdas (previously no Church-Rosser, but otherwise in good reducing condition)
17:07:36 <Olathe> They're knockoffs of the originals, but they're functionally identical.
17:07:56 <conal> observably equivalent
17:11:04 <ddarius> That monkeytex link is interesting.
17:11:40 <ivanm> well, I can't seem to find anything that seems interesting to me on the math garden or sigfpe's page
17:13:55 <ddarius> ivanm: What -is- interesting to you?
17:15:58 <firefly> SamB_XP: Erlang has assert/retract for shared "facts".
17:16:39 <ivanm> ddarius: good question :p
17:17:00 <ivanm> probably more the algorithmic side of things: how to write algorithms to solve computations
17:17:09 <ivanm> s/computations/maths problems
17:18:34 <jonathanturner> hi everyone.  I was looking for a good introduction to monads, and I found this: http://channel9.msdn.com/showpost.aspx?postid=358968  -- has anyone watched it?  If you have, is it accurate?
17:18:35 <lambdabot> Title: Brian Beckman: Don't fear the Monads
17:18:48 <Japsu> iä monads fhtagn
17:19:29 <jonathanturner> apparently lambdabot knows what it is, that must be a good sign
17:19:54 <ddarius> jonathanturner: That is not a good introduction to monads.  Check the introductions linked from haskell.org
17:19:59 <Korollary> lambdabot fetches titles for all URLs (and tinyurl's them if necessary)
17:20:01 <SamB_XP> jonathanturner: that just means that lambdabot found the TITLE tag...
17:20:32 <jonathanturner> SamB_XP and Korollary: thanks, that makes sense
17:20:39 <mauke> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
17:20:40 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
17:20:53 <jonathanturner> ddarius: ahh, I was afraid of that
17:21:02 <Japsu> @go all about monads
17:21:03 <lambdabot> http://www.haskell.org/all_about_monads/html/
17:21:03 <lambdabot> Title: All About Monads
17:21:33 <oerjan> @go "monad tutorials considered harmful"
17:21:34 <lambdabot> No Result Found.
17:21:55 <tehgeekmeister> ?src (.)
17:21:55 <lambdabot> (.) f g x = f (g x)
17:21:57 <oerjan> there _should_ have been a hit
17:22:14 <Japsu> @go monad tutorials considered harmful
17:22:15 <lambdabot> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
17:22:15 <lambdabot> Title: Do-notation considered harmful  Data.Syntaxfree
17:22:18 <Japsu> :<
17:24:23 * ivanm goes off to talk to potential supervisor
17:34:51 * glguy implements the Discordian text encryption algorithm: sort
17:35:35 <Pseudonym> glguy: Dude, you're not using the right process.
17:36:01 <glguy> :(
17:36:17 <Korollary> That is very egalitarian, though. The recipient and the eavesdropper finally even.
17:36:37 <Pseudonym> If you don't do the number substitution thing, you're NOT doing Discordian encryption.
17:36:54 <Pseudonym> Or separating vowels.
17:36:58 <glguy> right
17:37:01 <glguy> hmm
17:37:10 <Korollary> Does it even have to be a function of the input?
17:37:37 <ddarius> const is still a function
17:37:49 <oerjan> > let encrypt s = "" in encrypt "Maximal egalitarianism!"
17:37:57 <lambdabot>  ""
17:38:20 <Korollary> ddarius: I meant whether it could be just /dev/random
17:38:50 <conal> Does anyone have an electronic version of the 1993 JFP paper "Improving Intervals" by Jackson & Burton?
17:40:19 <hpaste>  glguy pasted "better ?" at http://hpaste.org/4087
17:40:43 * glguy wonders if he should have tried executing that before submitting
17:41:06 <Korollary> execution is for the weak
17:42:11 <glguy> oh, lookup isn't like Data.Map's lookup
17:45:15 <oerjan> try catMaybes
17:45:22 <glguy> I wanted mapMaybe
17:45:37 <oerjan> :t mapMaybe
17:45:39 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
17:45:47 <oerjan> @index mapMaybe
17:45:47 <lambdabot> Data.Maybe
17:46:22 <oerjan> throw away everything non-alphabetical?
17:48:49 <glguy> seems like that is what is specified
17:50:13 <idnar> :t catMaybes
17:50:16 <lambdabot> forall a. [Maybe a] -> [a]
17:50:31 <idnar> > join [Just 5, Nothing, Just 6]
17:50:32 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
17:51:04 <idnar> :t join [Just 5, Nothing, Just 6]
17:51:04 <lambdabot>     Couldn't match expected type `[]' against inferred type `Maybe'
17:51:04 <lambdabot>       Expected type: [a]
17:51:04 <lambdabot>       Inferred type: Maybe t
17:51:20 <oerjan> :t join
17:51:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:51:36 <glguy> join returns [] if any element is Nothing
17:52:06 <ski> "once,twice,thrice,..." .. what comes before "once" ?
17:52:44 <TSC> never
17:52:46 <glguy> never
17:53:10 <ski> (btw, this is names for church numerals)
17:53:10 <idnar> "never" doesn't really fit, though
17:53:20 <resiak> "none"?
17:53:32 <idnar> you might say "I have done it once" or "I have done it thrice", but "I have done it never" doesn't really work
17:53:38 <ski> "none,one,two,three,..."
17:53:40 <resiak> not quite right, but sounds better…
17:53:50 <TSC> none means "not one", but you really want "not once"
17:53:52 <resiak> well, nonce is right out
17:53:55 <TSC> nonce, obviously
17:53:59 <ski> nonce ?
17:53:59 <idnar> haha
17:54:01 <ski> ah
17:54:04 <idnar> I don't think there is a real word that fits in that position
17:54:12 * ski was considering "zeronce" before
17:54:24 <conal> does anyone have an electronic copy of the JFP 1991 paper "Encapsulating Nondeterminacy in an Abstract Data Type with Deterministic Semantics" by Warren Burton?
17:54:27 <ski> "nonce" doesn't sound ugly, at least
17:54:32 <idnar> "nonce" already means something else ;)
17:54:41 <ski> it does ?
17:54:51 <idnar> nonce n : the present occasion; "for the nonce" [syn: {time being}]
17:55:04 <idnar> it also has a more specific meaning in cryptographic protocols
17:55:08 <idnar> s/meaning/usage/
17:58:13 <conal> btw, i did find the related "Functional Programming Applied to Parallel Combinatorial Search" online.
17:58:49 <augustss> @src foldl
17:58:49 <lambdabot> foldl f z xs = lgo z xs
17:58:49 <lambdabot>     where lgo z []     =  z
17:58:49 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:58:51 <ddarius> @wn nonce
17:58:52 <lambdabot> *** "nonce" wn "WordNet (r) 2.0"
17:58:52 <lambdabot> nonce
17:58:52 <lambdabot>      n : the present occasion; "for the nonce" [syn: {time being}]
18:06:38 <ski> @wn aught
18:06:38 <lambdabot> *** "aught" wn "WordNet (r) 2.0"
18:06:38 <lambdabot> aught
18:06:38 <lambdabot>      n : a quantity of no importance; "it looked like nothing I had
18:06:38 <lambdabot>          ever seen before"; "reduced to nil all the work we had
18:06:38 <lambdabot>          done"; "we racked up a pathetic goose egg"; "it was all
18:06:40 <lambdabot> [3 @more lines]
18:13:32 <Saizan> ?index orElse
18:13:32 <lambdabot> Data.Generics.Aliases, Data.Generics, GHC.Conc, Control.Concurrent.STM
18:29:16 * HeLLoMoTo  TODO GRATIS PARA TU MOVIL http://www.canal-moviles.es
18:38:57 <marl> can I make programs with a few lines of code in haskell (like in common lisp)
18:39:00 <marl> ?
18:39:08 <ddarius> Sure.
18:39:19 <marl> ok
18:39:44 <ddarius> I'd even say that many times Haskell will be somewhat shorter simply because of a more compact syntax.
18:40:08 <marl> serious?
18:40:30 <marl> and... lol, forget what i'd ask
18:40:31 <marl> heheh
18:40:54 <conal> marl: yes.  one example: no #' & funcall.
18:41:19 <marl> what does it do?
18:41:37 <conal> marl: you mean #' & funcall?
18:41:51 <marl> yes
18:41:55 <marl> what does it mean?
18:41:56 <lament> You can make programs with a few lines of code in every language :)
18:42:07 <marl> the only programmina language i know (not very well) are C and ShellSript
18:42:13 <conal> they convert between the function & value namespaces in common lisp.  haskell, like scheme, unifies the namespaces.
18:42:15 <dylan> lament: even cobol?
18:42:40 <conal> more convenient for programming with first class functions, which then leads to shorter & more reusable code.
18:42:43 <lament> the program just won't be able to do very much :)
18:42:52 <shu> what do people use common lisp for these days? (over scheme, i mean)
18:43:20 <lament> libraries, iirc
18:43:21 <marl> hehehehehhe lament
18:43:26 <Korollary> shu: I don't think there's a clear cut answer
18:44:06 <dons> history classes?
18:44:09 <marl> conal: nice, and people work with haskell (obvious), but i mean, in what are it's a lot used (like C is used in embeded sofotware in hardware, it isnt the only language that is able to do it, but it is a lot used in that area)
18:44:21 <lament> dons: i dare you go to #lisp and say that :)
18:44:39 <dons> there's not enough people there to make it fun
18:45:35 <Korollary> dons: But every irc user can be implemented in terms of #lisp users anyway.
18:45:57 <shu> well, CL isn't older than scheme if that's what you were thinking
18:46:01 <dons> Korollary: :)
18:46:07 <SamB_XP> #lisp has the civility for that?
18:46:21 <shu> and i don't know CL at all, really
18:46:32 <shu> but if you need to explicitly tell the language to use tailcalls, that seems like a big pain in the ass
18:46:52 <lament> does tail recursion have disadvantages?
18:46:54 <ddarius> shu: CL just doesn't support tailcalls standardly.
18:47:00 <SamB_XP> the Haskell report doesn't say it explicitly
18:47:16 <shu> ddarius, is it turned on by default in all the implementations then?
18:47:20 <ddarius> SamB_XP: The difference is any sane implementation is forced to support it.
18:47:23 <SamB_XP> because, like, what kind of idiot wouldn't implement tail recursion correctly?
18:47:35 <ddarius> shu: It isn't on by default in many CL implementations.  There isn't even an option in many.
18:47:54 <lament> SamB_XP: a valid question, but you can ask that about pretty much anything and make nearly all language designers look like idiots
18:47:58 <ddarius> lament: The only meaningful one I've heard is the loss of stack frames for stack traces.
18:48:16 <SamB_XP> the report says the same thing about garbage collection
18:48:58 <lament> ddarius: i suppose that's actually a good point. You don't necessarily want tail recursion elision while debugging.
18:49:23 <ddarius> lament: There arguably might be issues for some fairly strong forms of introspection/reflection, but those should deal with the language rather than proscribe the language in my opinion.
18:51:48 <ddarius> lament: The debugging issue can be partially dealt with in some ways.  The simplest and probably most bang for the buck is to keep a finite collection of previous stack frames (except perhaps on self-tail calls).
18:52:20 <lament> it's clearly not a big deal
18:55:24 <ddarius> lament: It allegedly is to some.
19:05:12 <shu> i have a question about generics: using the `extQ` paradigm to add type-specific cases, how do you do it for a list?
19:06:03 <newsham> ok, someone on #haskell is always telling me when using Cont that "control" and some other primitives are superior.
19:06:14 <newsham> is there a link that discusses this (tutorial?)
19:06:37 <newsham> or anyone care to cover this in slow newbie steps?
19:08:17 <ddarius> That would probably be me.
19:08:27 <ddarius> newsham: Do you understand call/cc?
19:08:30 <fbuilesv> The "Real World Haskell" site seems down, anybody knows of progress on the book or an ETA?
19:08:37 <newsham> yes
19:09:06 <ddarius> Then control is just call/cc only it aborts rather than continues when the passed in continuation isn't used.
19:09:37 <dons> fbuilesv: hmm, down?
19:09:42 <ddarius> Unless you were actually asking about shift/reset which is delimited continuations which are interesting and more powerful (but if you don't need that power probably better not to mess with)
19:09:51 <dons> bos: website down
19:10:05 <dons> fbuilesv: very active, eta next year some time
19:10:13 <newsham> control (\k -> do { .... }) k2   so when you dont use k in the do it doesnt call k2?
19:10:27 <fbuilesv> dons: Nice to see you here, thanks for the good news :-)
19:10:57 <dons> no worries.
19:12:19 <ddarius> newsham: more, control f >>= g, if f doesn't use it's argument g is never executed.
19:12:40 <ddarius> abort x = control (\k -> return x)
19:13:03 <newsham> is control defined in any std or semi-std libs?
19:13:38 <newsham> so the last line of a do-block for control will typically invoke k?
19:13:50 <ddarius> newsham: It's probably defined in some of the continuationy packages on hackage.  You can define it yourself readily because the Cont data constructor is exposed.
19:14:13 <ddarius> newsham: It depends, you are presumably calling control for a reason.
19:14:29 <ddarius> @src Cont callCC
19:14:30 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
19:14:39 <ddarius> Just replace that last c with id and you have control.
19:14:58 <ddarius> @src ContT callCC
19:14:58 <lambdabot> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
19:15:09 <ddarius> replace the last c with return in this case
19:16:01 <newsham> now why is it that you prefer control over callCC?
19:16:46 <ddarius> Because to write abort with callCC you'd need to pass around a continuation bound outside of everything, similarly to write control with callCC (or you can use abort).
19:17:11 <ddarius> Whereas, abort x = control (\k -> return x) and callCC f = control (\k -> f k >>= k)
19:18:03 <LoganCapaldo> this control sounds interesting. it's more "primitive" than callCC?
19:18:14 <ddarius> You could if you wanted to define abort directly abort = Cont . const and then control = callCC (\k -> f k >>= abort)
19:18:23 <ddarius> LoganCapaldo: Arguably.
19:18:54 <newsham> ok, seems pretty straightforward now that I get callcc and Cont.
19:19:02 <newsham> how come none of this goodness is on the haskell wiki?
19:19:06 <Saizan> yeah, it puzzled me why you didn't just suggest abort = Cont . const on that cafe thread
19:19:11 <newsham> (also couldnt find info on it using simple google searches)
19:19:25 <ddarius> One strong case in it's favor is that it doesn't duplicate the continuation as callCC does.  I.e. if 'f' uses the continuation linearly then so does control f.
19:20:02 <ddarius> Saizan: I wanted to push control.
19:20:40 <Saizan> fine then :)
19:21:13 <ddarius> newsham: This is usually a good first stop for stuff on continuations: http://library.readscheme.org/page6.html
19:23:28 <newsham> someone who understands this well should write a haskell wiki article on it ;-)
19:23:34 <Saizan> unfortunately there's not a lot about continuations using haskell,
19:23:40 <Saizan> heh
19:23:40 <ddarius> newsham: And put it where?
19:23:52 <newsham> next to the current "Continuations" article?
19:23:55 <ddarius> Saizan: There is quite a bit.
19:24:43 <newsham> http://www.haskell.org/haskellwiki/Category:Haskell ?
19:24:44 <lambdabot> Title: Category:Haskell - HaskellWiki
19:24:57 <ddarius> I should dig up the old HaWiki articles on continuations and CPS and co.
19:24:58 <newsham> http://www.haskell.org/haskellwiki/Category:Tutorials ?
19:24:58 <lambdabot> Title: Category:Tutorials - HaskellWiki
19:24:59 <Saizan> ddarius: not "introductory", e.g. oleg's papers seems to assume familiarity with scheme
19:25:13 <ddarius> Saizan: No, most of it isn't particularly introductory.
19:25:35 <ddarius> Many of the things you'd want to use continuations for in Haskell can be handled by using some other monad.
19:25:46 <ddarius> E.g. exceptions use ErrorT/Either
19:26:11 <ddarius> That said, I believe it is important to have a good grasp on CPS and continuations.
19:26:52 <newsham> here would also be a good place for some cont goodness: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
19:26:53 <lambdabot> Title: Haskell/Continuation passing style - Wikibooks, collection of open-content textb ...
19:27:21 <Saizan> i find them fascinating at least (and the occasional almost free performance gain doesn't hurt)
19:28:07 <matt__r> cabal question: can I tell cabal to build only one of my many defined (in the .cabal file) executables?
19:36:08 <ddarius> Useless archive.org
19:37:59 <davidL> I just installed ghc-6.8.1 but darcs needs ghc-6.6.1 to build, how can I tell darcs (which does not use cabal) to use ghc-6.6.1 to build?
19:38:45 <ddarius> davidL: There's probably an environment variable and/or configuration option you can specify to tell it what GHC to use.
19:41:55 * ddarius is reminded of the time he was looking up stuff to implement first-class delimited continuations in C#.
19:42:17 <dfranke> Is there a way to use preprocessor macros to control what haddock.ghc sees?  The __HADDOCK__ macro mentioned in the docs for regular haddock doesn't seem to work.
19:42:55 <ddarius> There should be.
20:14:49 <shu> ah i see, apparently specializing in SYB-style generics over polymorphic lists is not possible with the current cast operators
20:16:53 <marl> http://www.haskell.org/haskellwiki/Future_of_Haskell here there is '3 variations of haskell' and there are explanations of 6 ones hehe.
20:16:54 <lambdabot> Title: Future of Haskell - HaskellWiki
20:20:19 <oerjan> marl: um, i believe 3 is the section number...
20:20:23 <allbery_b> marl: just missing periods on the sections
20:20:26 <ddarius> "In probability theory there is a very clever trick for handling a problem that becomes too difficult.  We just solve it anyway by: (1) Making it harder still (2) Redefining what we mean by "solving" it, so it becomes something we -can- do; (3) Inventing a dignified, technical-sounding word to describe this procedure, which has the psychological effect of concealing the real nature of what we have done, and making it appear respectable.
20:20:28 <ddarius> "
20:25:00 <glguy> I haven't used hugs since I first started learning Haskell... but where is the Random module?
20:25:22 <oerjan> "where"?
20:25:24 <Saizan> System.Random maybe?
20:25:37 <oerjan> surely both Random and System.Random work
20:25:38 <glguy> Random and System.Random don't seems to work
20:26:03 <oerjan> they work for me
20:26:24 <glguy> :-/ I wonder what the macports portfile installs
20:26:27 <Saizan> after the base split there's a random package
20:26:41 <ddarius> Random is a standard module.
20:26:47 <glguy> Saizan: specifically with though
20:26:53 <glguy> it defaults to 98 mode
20:27:00 <glguy> I'd have assumed to find a Random module
20:27:14 <dons> Hugs.Base> :l System.Random
20:27:14 <dons> System.Random>
20:27:27 <oerjan> without 98 mode it finds both here
20:27:27 <glguy> oh, right
20:27:35 <dons> System.Random> take 10 $ randomRs (0,6) (mkStdGen 42) :: [Int]
20:27:35 <dons> [0,5,0,4,3,3,4,5,2,0]
20:27:37 <glguy> hugs requires you to :l the module
20:27:41 <dons> hugs starts fast!
20:27:44 <oerjan> oh :D
20:30:37 <davidL> > take 10 $ randomRs (0,10) (mkStdGen 42) :: [Int]
20:30:52 <lambdabot>  thread killed
20:31:10 <dons> curious
20:31:16 <dons> > 1+2
20:31:20 <lambdabot>  3
20:31:27 <dons> > take 10 [1..]
20:31:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:31:31 <dons> > take 10 $ randomRs (0,10) (mkStdGen 42) :: [Int]
20:31:32 <lambdabot>  [4,9,3,3,5,8,6,5,4,8]
20:31:33 <TSC> Programs compiled with GHC aren't really supposed to segfault, are they?
20:31:41 <dons> TSC: no.
20:31:46 <Pseudonym> Did you call unsafeSegfault?
20:31:49 <TSC> It only happens with +RTS -hb
20:31:57 <dons> ok. definitely a bug
20:32:00 <dons> what does -hb do?
20:32:07 <TSC> biographical profiling, I hope
20:32:12 <dons> latest ghc?
20:32:19 <dons> ?paste a test program?
20:32:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:32:22 <TSC> I'll check that I'm doing it correctly
20:32:32 <dons> still, shouldn't crash
20:32:50 <ddarius> Isn't nice to blame the language when your programs crash.
20:33:17 <ddarius> (language = language implementation)
20:33:30 <TSC> Indeed
20:33:36 <oerjan> @remember TSC Programs compiled with GHC aren't really supposed to segfault, are they? <Pseudonym> Did you call unsafeSegfault?
20:33:36 <lambdabot> It is forever etched in my memory.
20:34:07 <TSC> Ha, lambdabot's idea of forever is sometimes sketchy (:
20:34:31 <oerjan> someone @flush :)
20:34:42 <oerjan> that helps some, at least
20:34:51 <ddarius> Luckily for her, she doesn't remember when she breaks such promises so as far as she can tell she's faithful.
20:35:09 <TSC> Seems to happen with any program, with -hb
20:35:16 <TSC> So nothing to paste
20:36:01 <TSC> I think I'm misusing -hb
20:36:01 <dons> main = return ()
20:36:02 <dons> ?
20:36:10 <TSC> I tried "main = print 10"
20:36:49 <dons> $ ghc Z.hs -o Z -prof
20:36:53 <dons> $ time ./Z +RTS -hb
20:36:53 <dons> 10
20:36:53 <dons> ./Z +RTS -hb  0.00s user 0.00s system 0% cpu 0.006 tota
20:36:53 <dons> ?
20:36:59 <dons> $ ghc --version
20:36:59 <dons> The Glorious Glasgow Haskell Compilation System, version 6.8.1.20071117
20:37:07 <TSC> I'm using 6.8.1 release
20:37:10 <dons> (stable branch with spec constr)
20:37:12 <TSC> Oh, hang on
20:37:19 <TSC> This may be my fault
20:37:29 <dons> is ./a.out a C program by mistake?
20:37:52 <TSC> I was switching between with 6.6 and 6.8 and may have confused it
20:39:00 <TSC> Ah
20:39:02 <TSC> Hmm
20:39:06 <TSC> What's hpc?
20:39:24 <dfranke> Haskell Program Coverage.
20:39:26 <sclv> grr... #haskell I need your help!
20:39:28 <sclv> https://alioth.debian.org/tracker/index.php?func=detail&aid=307010&group_id=30402&atid=411646
20:39:30 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 307010 Haskell meteor-con ..., http://tinyurl.com/yqvdux
20:39:46 <TSC> That's probably the problem; using GHC 6.6 with the hpc for 6.8, or something like that
20:39:58 <TSC> I think it crashes when making the hp file
20:40:00 <sclv> I can't figure out what the difference is between the output of the program I committed and the target output.
20:40:24 <sclv> Visually they look the same, but when I diff them there's obviously something different between them.
20:40:36 <sclv> If this is a newlines on various systems type issue...
20:40:45 <oerjan> trailing spaces? tabs?
20:41:05 <newsham> try diff with the flag to ignore all whitespace changes?
20:41:22 <TSC> Yeah, some version mismatch; all is well again
20:41:34 <TSC> Sorry if I scared any GHC maintainers
20:41:35 <newsham> (diff -w)
20:42:15 <sclv> yep! that does it. but if they're going to accept the submission, they apparently need it to be exact.
20:42:31 <sclv> what's the emacs command to make whitespace visible?
20:42:33 <newsham> so now figure out what the whitespace delta is
20:42:34 <newsham> and fix it
20:42:41 <newsham> od -c can be helpful
20:44:32 <sclv> oy. i found it.
20:44:52 <luqui> I have an algorithms problem.  I have a data type which is almost like an infinite list: data Stream b a = Stream a (b -> Stream a)
20:45:02 <luqui> but when I implement the analog of, say, scanl
20:45:09 <luqui> it takes quadratic time
20:45:25 <sclv> thanks much
20:45:34 <luqui> How can I get it back to linear like lists have?
20:46:25 <luqui> preparing a nopaste, since I realize that wasn't that clear
20:46:31 <oerjan> hm... note that function results are not cached, that may be a problem?
20:46:55 <luqui> I can't really see why that would affect it in this case.
20:49:59 <oerjan> otherwise, that is sort of a tree with each node a number of children equal to the size of the b type...
20:50:18 <luqui> that may be part of my problem
20:50:33 <luqui> that the data type does not perfectly encode what is going on
20:50:57 <luqui> really, there will only ever be one b which will be applied to the second argument of a given stream
20:51:03 <luqui> but it depends on time
20:51:07 <luqui> and I/O
20:51:10 <luqui> so I coulnd't just use a list...
20:51:25 <luqui> (unsafeInterleaveIO scares me too much)
20:51:48 <oerjan> i see. where is that paste?
20:52:12 <hoelzro> is it possible to use a monadic action inside a pattern guard?
20:52:32 <luqui> the program it's in is huge.  I'm trying to simmer it down into a minimal example
20:52:44 <luqui> (huge for haskell.   circa 300 lines :-)
20:53:07 <luqui> hoelzro, if you mean like IO, no
20:53:21 <luqui> you can use runState etc... but that's probably not what you meant
20:55:16 <hoelzro> yeah, it's a monad encapsulating IO, so I guess not
20:55:21 <hoelzro> thanks for the quick response
21:04:32 <dons> nice, http://programming.reddit.com/info/61esr/comments/
21:04:37 <dons> `Deriving a virtual machine with continuations in Haskell '
21:08:02 * wli is blown away by the blog
21:08:59 <dons>  Shin-Cheng Mu
21:09:02 <dons>  writes amazing stuff
21:11:03 <hpaste>  luqui pasted "Quadratic time listlike thing..." at http://hpaste.org/4089
21:11:31 <ddarius> As mentioned at the beginning of it, this is stuff that goes back to years ago with some work by Ager and Danvy and co. which references work decades ago by, unsurprisingly, John Reynolds.
21:12:27 <luqui> to reiterate re: http://hpaste.org/4089, I'm wondering why it's not linear time
21:14:19 <ddarius> luqui: There was a paper about this recently.
21:14:29 <luqui> cool...
21:15:32 <ddarius> @google "Plugging a space leak with an arrow"
21:15:34 <lambdabot> http://portal.acm.org/citation.cfm?id=1314712.1314919&coll=guide&dl=&CFID=15151515&CFTOKEN=6184618
21:15:34 <lambdabot> Title: Plugging a Space Leak with an Arrow
21:15:57 <ddarius> http://www.cs.yale.edu/~hl293/download/leak.pdf
21:16:23 <luqui> ddarius, thanks
21:16:26 <newsham> what if your leak isnt arrow shaped?
21:16:33 <ddarius> I'm pretty sure that has some relevant aspects.  Maybe not exactly what you want.
21:16:44 <ddarius> newsham: More arrows
21:16:48 <luqui> This one is a comonad actually... and I kinda don't want to generalize it to an arro
21:16:49 <luqui> w
21:16:57 <newsham> i tried to plug a balloon with an arrow once
21:17:03 <newsham> there was hilarity but no leak plugging
21:17:14 <ddarius> Did the balloon have a leak to begin with?
21:17:21 <newsham> ironically, no
21:17:31 <luqui> heh, whaddya know, the paper is about frp
21:17:33 <newsham> but more arrows did not seem to help
21:17:36 <luqui> the precise thing I'm experimenting with :-)
21:17:47 <newsham> i blame the hidden hand of entropy
21:19:38 <newsham> http://video.google.com/videoplay?docid=-4851250372422374791 cool stuff
21:19:38 <lambdabot> Title: Advanced Topics in Programming Languages Series: Parametric Polymorphism
21:20:20 <ddarius> The Wadler talk or that other one?
21:20:36 <newsham> not wadler.  talks about djinn
21:21:03 <ddarius> That other one.
21:21:04 <newsham> gossett
21:34:42 <newsham> ?djinn tonic
21:34:42 <lambdabot> -- f cannot be realized.
21:39:45 <dons> a response to my reponse, re. concurrency, http://www.antipode.ca/2007/games-cores-and-functional-languages/
21:39:46 <lambdabot> Title: Antipode | Archive | Games, cores, and functional languages
21:39:52 <dons> "I realize that a pro-Haskell link would be more compelling if it wasn?t from a .edu domain, but what can you do.
21:39:55 <dons> "
21:39:57 <dons> hah!
21:42:16 <ddarius> You need to move your blog to the galois domain.
21:42:32 <dons> ah yes, a good .com will increase credibility :)
21:49:04 <ddarius> 40-400x not bad
21:49:23 <scook0> well, it makes sense
21:49:32 <scook0> given how crazy some of those architectures are
21:53:09 <k> hi, i've just starting reading yaht, the section that introduces lists says that I cannot have a list that holds both integers and strings, is it possible to create a data type that is either a string or a number?
21:53:26 <oerjan> sure
21:53:33 <k> thereby, allowing a single list to contain both numbers and strings?
21:53:42 <dons> > [Left 1, Right "string", Left 7, Right "is cool"]
21:53:48 <lambdabot>  [Left 1,Right "string",Left 7,Right "is cool"]
21:53:52 <dons> :t [Left 1, Right "string", Left 7, Right "is cool"]
21:53:53 <lambdabot> forall t. (Num t) => [Either t [Char]]
21:54:01 <dons> a list that is Either Int String :)
21:54:15 <scook0> which extension gives you forall?
21:54:17 <phlpp> :D
21:54:22 <k> ah, I see, thanks :)
21:54:27 <dons> scook0: -fglasgow-exts :(
21:56:05 <scook0> looks like I was after ScopedTypeVariables
21:56:06 <shachaf> dons: Not ExistentialQuantification?
21:56:14 <shachaf> Hmm, never mind.
21:56:40 <scook0> forall has a few different uses, I suppose
21:56:42 <oerjan> forall is used for too many different things :)
21:56:46 <oerjan> Rank2Types | RankNTypes | PolymorphicComponents | ExistentialQuantification
21:57:11 <dons> yeah, all sorts could  turn it on.
21:57:15 <dons> i usually use ExistentialQuantification
21:57:39 <ddarius> Doh
21:57:48 <scook0> and the extension system isn't actually as fine-grained as it appears to be, right?
21:57:57 <ddarius> It's not parametric polymorphism's fault that it's useful.
21:58:29 <shachaf> scook0: Better than it was in 6.6. :-)
21:58:33 <scook0> ddarius: it's more that the syntax is being reused to do (related) different things
21:58:34 <dons> there's slowly more and more specific flags (e.g. -XExistentialQuantification
21:58:46 <scook0> shachaf: heh, I'm still on 6.6 for now
21:59:20 <ddarius> scook0: But the syntax isn't being reused.
21:59:33 <ddarius> It's just not artificially being distinguished.
22:00:20 <scook0> I didn't give too much thought to my choice of words :)
22:01:53 <shachaf> scook0: When 6.6 sees LANGUAGE, it just enables -fglasgow-exts.
22:02:01 <shachaf> (I understand.)
22:02:11 <scook0> heh
22:02:13 <scook0> well, not quite
22:02:21 <scook0> since I already had NoMonomorphismRestriction
22:02:30 <scook0> but that's already a separate flag, I believe
22:02:35 <ddarius> It is.
22:02:42 <marl> whois marl
22:04:22 <ddarius> We need someone to write a paper along the lines of Okasaki's "Why would anyone ever want to use a sixth-order function?" only s/sixth-order/rank-6/
22:08:40 <dibblego> has anyone written a geodesic function before?
22:08:51 <dibblego> *geodesic distance function
22:09:07 <ddarius> Probably.
22:09:28 <dibblego> they didn't let google index it then :)
22:09:41 <ddarius> Maybe they called it something else.
22:10:21 <Heffalump> on the earth's surface, or generally?
22:10:33 <dibblego> on the earth's surface
22:11:04 <Heffalump> how accurately do you want the surface modelled?
22:11:41 <dibblego> I'm not too fussed; I wanted to experiment with the different functions
22:11:50 <dibblego> I just find Haskell the easiest to read :)
22:12:31 <Heffalump> I hacked something up based on calculating the 3d difference and then treating that as a chord of a sector to figure out the surface distance
22:12:51 <Heffalump> it's only actually intended for use for short distances so I didn't really care, I was just playing around
22:13:12 <dibblego> is it any one of the functions I can google up, like Haversine?
22:13:22 <Heffalump> I doubt it
22:13:42 <Heffalump> I didn't know that existed :-)
22:13:51 <Heffalump> I was writing this on the train so didn't have the internet as a reference
22:14:43 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:14:44 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:14:51 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:14:54 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:15:18 --- mode: ChanServ set +o dons
22:15:21 --- kick: Morningsickness was kicked by dons (dons)
22:15:22 --- mode: ChanServ set -o dons
22:15:32 <Heffalump> that was exciting
22:15:41 <Pseudonym> As exciting as root canal.
22:15:47 --- mode: ChanServ set +o dons
22:15:49 --- kick: Morningsickness was kicked by dons (dons)
22:15:52 <lucca> please troll using proper utf-8
22:15:54 <dons> grr. need to get the ban list clean
22:16:00 <Pseudonym> I've had root canal, BTW.  I know this.
22:16:04 <Pseudonym> It's bloody tedious.
22:16:09 --- kick: Morningsickness was kicked by dons (dons)
22:16:23 <Morningsickness> The San Diego fires were the work of illegal aliens hellbent on destroying the gay niggger ghetto.  "Pennisbird watched with horror as 6 nigggher faggs burnt to death, leaving their black smooth muscula
22:16:23 <Morningsickness> gay niggger ghetto.  "Pennisbird watched with horror as 6 nigggher faggs burnt to death, leaving their black smooth muscular bodies motionless in a puddle of gay nigggher seemen with their oiled frizzy hair up in smoke. The San Diego fires were the work of illegal aliens hellbent on destroying the gay niggger ghetto.  "Pennisbird watched with horror as 6 nigggher faggs burnt to death, leaving their black smooth m
22:16:24 --- kick: Morningsickness was kicked by dons (dons)
22:16:33 <dons> can someone look up the command to clea rthe ban list?
22:16:38 <Pseudonym> Can you ban 201.160.163.127.cable.dyn.cableonline.com.mx?
22:16:49 <lucca> there's no single irc-proto command to do it...
22:17:00 <lucca> need to set channel mode -b ... for each, I think
22:17:05 --- mode: dons set -b *!*@200.117.254.146
22:17:12 --- mode: dons set -b *!*i=sponsz@*.fbx.proxad.net
22:17:20 --- mode: dons set -b *!*WP-Gast@*
22:17:23 <dibblego> instance Functor -b
22:17:26 --- mode: dons set -b *!*@host-212-149-254-102.kpylaajakaista.net
22:17:33 --- mode: dons set -b *!*n=heloto@*.telia.com
22:17:39 --- mode: dons set -b *!*i=fkoff@*.cpe.net.cable.rogers.com
22:17:45 --- mode: dons set -b *!*@83.243.88.*
22:17:49 <dons> ok, that'll do for now
22:18:00 --- mode: dons set +b *!*=Horehoun@*.160.163.127.cable.dyn.cableonline.com.mx
22:18:02 --- mode: ChanServ set +o Pseudonym
22:18:05 --- mode: ChanServ set -o dons
22:22:02 --- mode: ChanServ set -o Pseudonym
22:38:24 <wolverian> oh, wow. writeList2Chan. thou shalt not name functions like this.
22:39:14 <Pseudonym> There are circumstances where that would be okay.
22:39:30 <Pseudonym> The OpenPGP standard has a concept which is the "String to Key", spelled "S2K".
22:39:43 <Pseudonym> I can imagine that writeString2Key would be perfectly acceptable there.
22:39:47 <wolverian> but surely not in base :/
22:39:53 <Pseudonym> No, not in base.
22:40:14 <wolverian> then.. let's fix it.. (;
22:41:35 <Cale> Hey, at least it's not writeList4Chan ;)
22:44:21 <marl> does anyone here works with haskell?
22:44:57 <Pseudonym> No, nobody.
22:45:06 <Pseudonym> What are we doing here?!
22:46:20 <Lemmih> marl: Yes.
22:46:52 <thoughtpolice> Pseudonym: drinking coffee?
22:47:14 <marl> Pseudonym: i dont work with haskell and i'm here
22:47:16 <wolverian> Cale, hahaha :)
22:47:21 <marl> a lot of people is learning haskell and they are here
22:47:31 <Pseudonym> Yeah, I know.
22:47:33 * Pseudonym is kidding
22:48:45 <marl> Lemmih: what kind of work do you do? what kind of software do you develop.
22:48:50 <marl> ?
22:50:56 <Lemmih> marl: I work on HAppS, a Haskell-based web-framework.
22:51:47 <dons> marl, have a look at some of the companies using haskell, http://haskell.org/haskellwiki/Haskell_in_industry
22:51:59 <dons> web stuff, banks, high assurance systems
22:52:09 <dons> hardware design
22:52:24 <marl> ok
22:52:34 <marl> web stuff = websites?
22:53:02 <dons> web apps (i.e. web sites that do something)
22:53:14 <marl> ahh ok
22:53:16 <ddarius> As opposed to the rest of the web
22:53:31 <marl> ehehehehe
22:54:00 <Lemmih> I only work on backend stuff. Things like scalability and data security.
22:54:55 <dons> i write blogs about haskell for a living
22:55:06 <glguy> while living? or for a living?
22:55:24 <dons> glguy writes xmonad plugins
22:55:50 <glguy> dons plays indoor soccer for a living*
22:55:55 <quicksilver> wolverian: yeah, writeList2Chan has always bugged me
22:56:01 <dons> quicksilver: i agree.
22:56:05 <dons> fromList / toList
22:56:13 * dons drafts a proposal for the libraries
22:56:23 <quicksilver> I kibitz on #haskell for a living
22:56:27 <quicksilver> it doesn't pay well :(
22:56:34 <dons> quicksilver++
22:56:36 <dons> ?karma quicksilver
22:56:37 <lambdabot> quicksilver has a karma of 10
22:57:09 <ddarius> ?karma
22:57:09 <lambdabot> You have a karma of 9
22:57:14 <ddarius> Wow
22:58:40 <thoughtpolice> quicksilver: ann. salary?
22:59:04 <dons> any objections to: writeList2Chan -> fromList; getChanContents -> toList
22:59:51 <Lemmih> Yes. I think they're slightly misleading.
22:59:52 <quicksilver> well I suppose it's a bit different since the other 'fromLists' create a new *blah*
23:00:04 <quicksilver> and this one is using an existing blah
23:00:08 <Lemmih> 'fromList' doesn't create a Chan from a list.
23:00:10 <dons> the alternative is something like listArray / elems
23:00:29 <dons> at least the names should be symmetrical
23:00:34 <Lemmih> I have the same objection with listArray.
23:00:43 <quicksilver> toList seems reasonable; but getChanContents has the secret 'unsafe' vibe
23:01:06 <quicksilver> since we're not allowed to call getContents unsafeGetContents, at least we learn that getContents is a secret word for unsafe :)
23:01:35 <dons> ok, that's too much. i'm exhausted. we can revisit this next time someone writes about writeList2Chan
23:01:58 <dons>   Rename the list/Chan interplay functions to be more obvious.
23:01:58 <dons>   
23:01:59 <dons> Shall I unrecord this patch? (1/19)  [ynWvpxqadjk], or ? for help: y
23:02:02 <dons> :)
23:02:05 * dons `ap` sleep
23:03:27 <andyjgill> >:t ap
23:04:38 <ddarius> :t ap
23:04:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:05:29 <andyjgill> Looks ill typed dons, perhaps you are tired?
23:05:45 <dons> you're not my type
23:12:21 <dufflebunk> In the example for Data.ByteString.Lazy's split it has split '\n' "a\nb\n..." But when I try to use '\n' I get a compile error: Couldn't match expected type `Word8' against inferred type `Char'
23:13:04 <Zao> Aren't Char unicode codepoints?
23:13:44 <scook0> :t '\n' -- ByteString doesn't use Chars
23:13:52 <lambdabot> Char
23:14:20 <scook0> (though I don't know which functions convert for you)
23:14:44 <dufflebunk> The examples in the docs are wrong then
23:14:47 <dufflebunk> http://haskell.org/ghc/docs/latest/html/libraries/bytestring-0.9.0.1/Data-ByteString-Lazy.html#14
23:14:48 <lambdabot> http://tinyurl.com/2kc5r3
23:15:17 <quicksilver> dufflebunk: there is a Char variety of bytestring too
23:15:32 <quicksilver> dufflebunk: maybe that example was intended for that
23:18:17 <chucklarge> Hey,  I am just learning Haskell, and  I am trying to return the element of a list with the maximum number.  At the moment, I can get the number, but I want the entire element.
23:18:18 <chucklarge> for example
23:18:18 <chucklarge> lst :: [(String, String, Integer)]
23:18:18 <chucklarge> lst = [("ads","gh",34), ("gj","dfh",65), ("fjg","ad",485),("s","w",356)]
23:18:19 <chucklarge> getNum :: (String, String, Integer) -> Integer
23:18:19 <chucklarge> getNum (_,_,s) = s
23:18:21 <chucklarge> test :: [(String, String, Integer)] -> Integer
23:18:23 <chucklarge> test [] = 0
23:18:25 <chucklarge> test (x:xs) = max (getNum x) (test xs)
23:18:27 <chucklarge> so if i run
23:18:29 <chucklarge> test lst => 485
23:18:30 <dufflebunk> quicksilver: there's a ByteString.Lazy.Char8, that looks like it'll work much better.
23:18:31 <chucklarge> but I need ("fjg","ad",485)
23:18:33 <chucklarge> any help is appreciated
23:21:57 <scook0> @hoogle maximumBy
23:21:57 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
23:21:57 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
23:22:50 <scook0> maximumBy (comparing getNum) might help
23:22:55 <scook0> @hoogle comparing
23:22:55 <lambdabot> No matches found
23:23:58 <scook0> or maximumBy (compare `on` getNum)
23:28:57 <dfranke> Dang, this is really bad.
23:28:59 <dfranke> http://programming.reddit.com/info/61ecu/comments/c02j6iy
23:29:10 <dfranke> I expected to manage at least 1000.
23:31:47 <glguy> ... and fault tolerance starts at "2"...
23:31:50 <glguy> words of the master
23:49:55 <landjik> does anyone know exactly what lambdabot expects to find under fptoolsPath (as set in the config file)?
23:50:32 <math_lover88> not me
23:51:57 <pejo> landjik, I think lots of stuff was located under fptools/ when ghc used CVS. Nofib, happy, etc.
23:52:11 <landjik> right
23:52:21 <landjik> and I noticed there's an old version of ghc in there
23:53:21 <landjik> in the CVS hierarchy, I mean
23:55:56 <landjik> so if the purpose of fptoolsPath is to point to sources (which seems to be the case from reading the comments in the config file for lambdabot), does that mean I need to replace the version of ghc under fptools with something more current?
