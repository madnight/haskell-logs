00:08:28 <vincenz> Lemmih: it's not
00:20:53 <Taejo> @src (,)
00:20:53 <lambdabot> Source not found. Maybe you made a typo?
00:22:05 <EvilTerran> data (,) a b = (,) a b
00:23:00 <reinierrr> @src ()
00:23:00 <lambdabot> data () = ()
00:28:05 <Taejo> @tell dons Dude, your quad-cores have been smoking way too much Haskell :)
00:28:05 <lambdabot> Consider it noted.
00:28:38 <Taejo> Does lambdabot accept invitations?
00:28:54 <vincenz> No
00:29:03 <vincenz> Taejo: where do you want him to go?
00:29:06 <vincenz> s/him/her
00:29:37 <Taejo> vincenz, I thought it might be nice to have her in #saco if we allow Haskell submissions
00:30:32 * faxathisia wonders what saco is
00:31:05 <Taejo> South African Computer Olympida
00:31:24 <Taejo> s/ida/iad/
00:33:18 <vincenz> @localtime conal
00:33:38 <vincenz> @bot
00:33:38 <lambdabot> :)
00:34:03 <conal> vincenz: i couldn't sleep.
00:34:11 <vincenz> That always sucks
00:34:45 <conal> code calls ...
00:34:54 <vincenz> enjoy!
00:34:57 <conal> @localtime vincenz
00:35:00 <lambdabot> Local time for vincenz is Fri Nov 30 09:34:58 2007
00:35:12 <conal> nine hours diff
00:35:23 <vincenz> Yep, I thought as much but wanted to ascertain
00:42:20 <mgsloan> Haskell should participate in GHOP
00:43:00 <mgsloan> I'd prefer doing haskell tasks rather than mono tasks
00:44:29 <mgsloan> not that it's really possible to just join on spontaneously
00:44:50 <mgsloan> I did hear that they may add projects to it at some point though
00:48:12 <reinierrr> what's GHOP?
00:48:54 <mgsloan> Google Highly Open Participation Contest
00:48:56 <mgsloan> crappy name
00:49:08 <mgsloan> basically, it's a cut down SoC for highschool students
00:49:14 <reinierrr> it's the Klingon word for 'hand', too, according to a quick google search
00:49:18 <mgsloan> lol
00:49:38 <reinierrr> sounds interesting
00:49:50 <reinierrr> but i finished high school 4 years ago :)
00:49:57 <mgsloan> yes, it's pretty good.  $100 for every triple of tasks
00:50:06 <mgsloan> ah, I'll finish high school next year :)
00:52:17 <reinierrr> the GNOME task list has lots of dirty work that the real devs won't ever do themselves...
00:52:33 <mgsloan> indeed
00:52:37 <reinierrr> 'clean up docs', 'increase test coverage', that sort of stuff
00:52:44 <mgsloan> pretty much
00:52:56 <mgsloan> I just did a python task that was pretty nasty
00:53:16 <reinierrr> are you going to get paid now? :)
00:53:27 <mgsloan> basically I documented the core evaluation functions of python, which guido never really bothered doccing
00:53:41 <mgsloan> by core, I mean core.  2000 line beast
00:53:45 <mgsloan> but anyway
00:53:51 <mgsloan> nah, I don't think so
00:54:01 <reinierrr> quite cool though... you should really understand how that interpreter works now
00:54:09 <mgsloan> seems like the "prizes" as they call them (probably due to the legal department) are awarded at the end
00:54:14 <mgsloan> indeed, it was sweet
00:54:19 <mgsloan> that's why I picked it :)
00:55:05 <mgsloan> still, in reality it should be docced by those who wrote it, not by some random high schooler
00:55:31 <reinierrr> nah, open source is all about being helped by random people
00:56:15 <reinierrr> but have you learned Haskell as a high schooler?
00:56:16 <mgsloan> yeah, that part of it's cool.  Still, seems like critical documentation should be written by those who know.  I provided a decent skeleton, though
00:56:24 <reinierrr> i never managed to do that
00:56:29 <mgsloan> yeah, so not exactly random :P
00:56:38 <mgsloan> but that's besides the point
00:56:50 <jeffz> i wish i knew about Haskell in highschool
00:57:08 <mgsloan> yeah, I somewhat lucked out in discovering it
00:57:10 <reinierrr> i knew about it because of the whitespace interpreter source code
00:57:30 <reinierrr> but i couldn't understand why my attempts at "Hello, world" were not well-typed
00:58:05 <mgsloan> ah, heh
00:58:15 <Taejo> I still don't understand how my Haskell programs magically became well-typed as soon as I started university
00:59:00 <reinierrr> anyway, if you want haskell to participate in GHOP  you could try to ask on the mailing list
00:59:08 <mgsloan> hardest bits for me were syntax and monads
00:59:19 <mgsloan> well, probably now's not the time
00:59:22 <mgsloan> GHOP is just starting
00:59:33 <mgsloan> if I seem them add projects though, I'll pursue it
01:00:20 <reinierrr> i believe haskell was already bending the rules a bit in their SoC participation
01:00:32 <reinierrr> because officially they had to be a legal entity, but they weren't
01:01:14 <oerjan> @remember Taejo I still don't understand how my Haskell programs magically became well-typed as soon as I started university
01:01:14 <lambdabot> It is forever etched in my memory.
01:02:27 <reinierrr> i do understand why that happened
01:02:27 <mgsloan> I actually participated in a pseudo-SoC, and that was definitely bending rules
01:02:52 <reinierrr> what's a pseudo-SoC?
01:02:58 <mgsloan> unofficial one
01:03:24 <mgsloan> basically the same deal though (I couldn't do an official one, due to the age limit)
01:03:29 <reinierrr> in which Google still pays you, or...?
01:03:32 <mgsloan> yep
01:03:42 <reinierrr> cool
01:04:08 <mgsloan> had to go through another organization on the way to me (Software freedom conservancy), but it worked out :)
01:05:12 <reinierrr> anyway, i do have to get to work now
01:05:16 <reinierrr> keep up the coding :)
01:05:57 <vincenz> Any STM experts around?
01:05:57 <mgsloan> you too :)
01:06:05 <mgsloan> I have to get to bed, maybe read a bit of TAPL
01:26:26 <firefly> @seen dons
01:26:26 <lambdabot> dons is in #ghc, #xmonad and #haskell. I last heard dons speak 3h 19m 17s ago.
01:27:04 <firefly> @seen ndm
01:27:04 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 21h 51m 10s ago, and .
01:35:10 <dibblego> where is that post about the Haskell ray tracer to debunk the 'laziness hurts performance' meme?
01:35:21 <dibblego> (the Scala mailing list has been infected by you know who)
01:35:58 <Korollary> augustss blog
01:36:26 <dibblego> ta
01:39:47 <Meldon> http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
01:39:48 <Meldon> ?
01:39:48 <lambdabot> Title: Things that amuse me, http://tinyurl.com/25sj6t
01:41:29 <dibblego> that's him
01:55:59 <ttfh> hmm, checking if a Data.Map is empty and comparing it with Data.Map.empty is not the same thing, silly me
01:56:50 <Vq^> ttfh: but it should have the same effect, no?
01:57:10 <ttfh> it has the same effect
01:58:14 <hpaste>  firefly pasted "count spaces in stdin, lazy bytestring" at http://hpaste.org/4160
02:02:30 <hpaste>  firefly pasted "space counting in stdin, strict bytestring" at http://hpaste.org/4161
02:02:54 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4162
02:03:11 <hpaste>  firefly annotated "count spaces in stdin, lazy bytestring" with "annotated with program filename" at http://hpaste.org/4160#a1
02:04:35 <hpaste>  firefly pasted "space counting in C, na√Øve" at http://hpaste.org/4163
02:07:06 <system_e> Could any one look at http://hpaste.org/4162 an tell me if the result of this is realy a String.
02:07:55 <kfish> system_e, heh, what does ghc say?
02:08:03 <system_e> I use hugs
02:08:23 <system_e> And it should be String, as it is there
02:09:14 <system_e> I did (show reult) end i get "\1869639017\138841202\DLE\DC1\1869639017" at console
02:09:24 <hpaste>  firefly pasted "space counting in decent simple C" at http://hpaste.org/4164
02:09:34 <system_e> Are chars realy so big in Hugs?
02:11:02 <quicksilver> system_e: yes, chars are unicode, but I'm still surprised
02:11:36 <hpaste>  firefly pasted "smart space counting using 4K buffer" at http://hpaste.org/4165
02:11:51 <quicksilver> system_e: ah, no I'm not.
02:11:54 <quicksilver> sizeOf char is 4
02:12:01 <quicksilver> the storable instance for char uses unicode points
02:13:28 <wli> isspace(3)?
02:14:13 <hpaste>  firefly pasted "space counting in C so smart as to be dumb (one big buffer)" at http://hpaste.org/4166
02:14:31 <wli> iswspace(3)?
02:15:52 <wli> Also getwchar_unlocked(3)?
02:16:08 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/4162#a1
02:16:14 <hpaste>  firefly pasted "detailed timings of haskell space counting progs" at http://hpaste.org/4167
02:16:44 <hpaste>  firefly pasted "detailed timings of C space counting progs" at http://hpaste.org/4168
02:16:56 <system_e> quicksilver: so http://hpaste.org/4162#a1 should no fail?
02:18:00 <hpaste>  quicksilver annotated "count spaces in stdin, lazy bytestring" with "guards are nicer than if/then" at http://hpaste.org/4160#a2
02:18:12 <quicksilver> firefly: I just made that look prettier, that's all
02:18:35 <quicksilver> system_e: what you're doing is unsaf
02:18:44 <quicksilver> system_e: you're reading 5 bytes from a file into a 5 byte buffer
02:18:46 <firefly> did you retest the speed?
02:18:53 <quicksilver> system_e: and then interpreting that as 5 chars = 40 bytes
02:18:58 <quicksilver> firefly: no. But it shouldn't be different.
02:19:32 <quicksilver> firefly: it should produce the same Core. It just looks nicer.
02:19:44 <firefly> It might be.  I tried many variations and they didn't all reduce to the same machine code.
02:20:37 <firefly> characters in a string are 12 bytes each (the spine for the list takes 8 bytes and the char takes 4).
02:21:03 <firefly> if strings weren't special-cased it would be 20 bytes: 12 for the spine and 8 for each char.
02:21:21 <firefly> (just an aside to system_e)
02:22:35 <firefly> Anyway, the first point of my many space counting programs is that a comparison with textbook C is outdated because gcc insists on being thread-safe by default and therefore does more locking than expected.
02:22:36 <goalieca> wow. that's a lot of wasted space
02:22:54 <firefly> goalieca: probably one of the biggest reasons why bytestrings are faster
02:23:47 <firefly> If one compares with C code that does the same thing, ghc loses, as one expects if one looks at the machine code and sees how it treats the CPU.
02:24:02 <goalieca> well c doens't use a linked list
02:24:27 <firefly> Practically nothing is in registers, everything gets loaded from and stored back to memory all the time, using a stack that is "manually" maintained using the EBP register.
02:24:51 <goalieca> kinda like the old java days
02:24:52 <firefly> The second point is that using enormous read buffers is not such a good idea.  I think this runs counter to most people's expectations.
02:25:00 <goalieca> well java isn't stack .. but anywho..
02:25:01 <system_e>  firefly: So when i read big binary file and then change it to string it will eat a lot of memory?
02:25:20 <firefly> If it needs to keep the whole string alive, yes.
02:25:22 <goalieca> well. is there no such thing as a "rope" in haskell
02:25:26 <firefly> You might be saved by laziness.
02:26:11 <firefly> The third point is that lazy bytestrings are much slower than they should be.  They should actually be faster because they DON'T use enormous I/O buffers.
02:26:20 <firefly> But in fact, they are 4-5x slower.  Why is that?
02:26:44 <sjanssen> firefly: what GHC version are you using?
02:27:01 <firefly> 6.9.20071120 ;)
02:27:20 <sjanssen> okay, so you've got the new lazy ByteString representation
02:27:55 <goalieca> tweaked to win the shootouts sum contest ;)
02:27:58 <firefly> I am not done with my analysis yet -- I'm currently stuck trying to understand what's going on in the core, stg, c--, and assembly for my lazy bytestring tests.
02:28:03 <sjanssen> well, one difference might be that ByteString IO doesn't reuse the buffer, as you're probably doing in C
02:28:19 <firefly> I tend to find the assembly much easier to read than core/stg/c-- ;)
02:28:34 <firefly> Yes, I supposed it didn't.  That shouldn't make it /that/ slow, should it?
02:28:48 <quicksilver> system_e: not necessarily, no
02:28:55 <firefly> Wouldn't it be more comparable to reading the whole thing as one big buffer in terms of cache misses?
02:28:56 <quicksilver> system_e: there is behind the scenes optimisations.
02:29:15 <quicksilver> system_e: but if you are deally regularly with very large strings, you might want to use ByteString.
02:29:17 <sjanssen> firefly: it makes some difference, what numbers are we getting here?
02:29:32 <firefly> it's in one of the pastes.
02:29:47 <firefly> http://hpaste.org/4168
02:30:00 <sjanssen> firefly: yeah, pretty similar locality I'd say.  LBS might do better depending on the GC and cache size
02:30:02 <firefly> http://hpaste.org/4167
02:31:27 <firefly> I've also experimented with hand-optimizing the main loop of the assembly version of cntspaces1.hs, just in order to see what changes would yield how much of a benefit.
02:31:47 <sjanssen> firefly: you're compiling with optimizations, of course?
02:31:59 <firefly> Relatively simple improvements that would keep more things in registers help a lot :)
02:32:03 <firefly> Yes, I use -O2.
02:32:31 <sjanssen> you should use guards like quicksilver suggests
02:32:40 <firefly> I'll post the whole tarball soonish and also post to haskell-cafe.  I think there are some good points in these benchmarks.
02:33:05 <firefly> I'll try the guards-version, too, but I doubt very much it'll magically make things much faster.
02:33:24 <sjanssen> also, a ! on the bs parameter might help
02:33:56 <sjanssen> firefly: it may help GHC realize that cnt is strict in that parameter
02:34:01 <firefly> Yes, it might.  It made no difference (and was determined to be strict) with the strict bytestrings.
02:34:11 <firefly> Better try it with the lazy bytestrings.
02:34:33 <quicksilver> the new register allocator isn't in, is it?
02:34:40 <quicksilver> in "6.9.20071120"
02:34:50 <firefly> The two haskell programs were the fastest versions I've had so far, btw.
02:35:05 <firefly> The register allocator seems to be there but it didn't make much of difference when I tried it.
02:35:27 <firefly> The problem is that the register allocator isn't given enough information.
02:35:49 <firefly> It isn't told that the manual stack stuff can be put in registers instead, for example.
02:35:59 <firefly> It also isn't given that many registers to work with.
02:36:29 <quicksilver> well that's true :)
02:36:40 <firefly> So if it isn't given enough locations ("variables") to allocate registers for and also isn't given enough registers to allocate to those locations then it doesn't really matter much how advanced the register allocator is.
02:36:40 <quicksilver> but ought to be enough registers for this example, I'd have thought
02:36:41 <int-e> firefly, did you try  print $ B.foldl' (\v c -> if c == ' ' then v+1 else v :: Int) 0 s ?
02:37:28 <firefly> Yes.
02:37:45 <sjanssen> results?
02:37:50 <firefly> (and B.foldr' (....) 0 bs)
02:38:01 <sjanssen> foldr' is the wrong thing, don't use that
02:38:18 <firefly> slower.
02:38:20 <quicksilver> firefly: did you try using unsafeHead ?
02:38:29 <firefly> nope!
02:38:49 <firefly> I think foldr' was slightly faster than foldl' or that it was a wash.
02:41:27 <firefly> So I should try making bs strict (for the lazy bytestrings) and I should try unsafeHead.  I'll add those to the set.
02:41:55 <firefly> I'll also permanently add both the foldl' and foldr' versions to the set.
02:42:03 <firefly> Anything else I should try?
02:42:19 <firefly> Probably normal strings, just for laughs ;)
02:42:27 <sjanssen> firefly: don't bother testing foldr' with lazy bytestrings
02:42:41 <sjanssen> firefly: it traverses the string right to left, thus destroying laziness
02:42:44 <firefly> why not?  If foldl' doesn't perform better?
02:43:14 <sjanssen> foldl' should perform much better
02:43:43 <sjanssen> foldr' will use O(n) memory
02:43:58 <firefly> and it hasn't, so far.  Maybe because bs is missing a strictness annotation, I dunno.
02:45:55 <firefly> I've currently got 40 micro benchmarks in the set and a makefile that automatically times them + generates intermediate language files + disassembles the main loop of the end result.
02:46:12 <firefly> Adding another benchmark or ten isn't much trouble.
02:46:36 <firefly> If nothing else, it would be nice to see how better foldl' is with the right annotations :)
02:46:49 <sjanssen> firefly: oh, you should try a versio that doesn't use .Char8 too
02:47:25 <firefly> I still need to compute the variance for each test.  And I would like to test with more than just a 150MB input file.  And I need to plot some graphs.
02:47:28 <quicksilver> sjanssen: would you expect B.foldl' to be different from length . filter ?
02:47:48 <firefly> How should I count spaces without .Char8?
02:47:54 <quicksilver> ==32 ?
02:48:12 <quicksilver> but I'd be surprised if it was different?
02:48:20 <quicksilver> should generate the same code, surely?
02:48:22 <firefly> quicksilver: length + filter perform surprisingly well with strict bytestrings :)
02:48:23 <sjanssen> quicksilver: not in this version of ByteString, I think
02:48:31 <quicksilver> sjanssen: ah?
02:48:37 <sjanssen> quicksilver: the library packaged with GHC doesn't use streams yet
02:48:44 <firefly> It's slightly slower than cntspaces1 but not by much (about 20% afair)
02:48:59 <quicksilver> sjanssen: firefly's using CVS though?
02:49:15 <firefly> Err..  I may have overridden that with cabal.
02:49:35 <firefly> (That's another thing I'd like to nail down before I post the full benchmark set)
02:50:04 * firefly is using DARCS!
02:50:16 <sjanssen> quicksilver: they're still using the old loop fusion code
02:50:30 <sjanssen> though loop fusion might do well enough
02:51:13 <firefly> Any other bytestring stuff you would like me to put into the benchmark set?
02:52:17 <quicksilver> sjanssen: ah.
02:52:25 <quicksilver> firefly: CVS is metasyntactic variable.
02:52:40 <quicksilver> firefly: it means {revision_control_system_in_use} :)
02:53:18 <firefly> CVS is an emetic.
02:53:56 <hpaste>  sjanssen annotated "count spaces in stdin, lazy bytestring" with "count spaces with foldl'" at http://hpaste.org/4160#a3
02:54:05 <sjanssen> firefly: try that one
02:54:25 <firefly> I'll add it to the list :)
02:54:27 <firefly> Any others?
02:54:52 <firefly> Perhaps some that did something a bit more challenging than just counting spaces?
02:56:34 <sjanssen> @seen dcoutts
02:56:34 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 22h 19m 47s ago.
02:56:37 <sjanssen> @seen dcoutts_
02:56:37 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 18h 53m 24s ago.
02:57:22 <sjanssen> firefly: ask dcoutts about this if you see him around
02:57:31 <firefly> will do!
02:58:36 <hpaste>  int-e annotated "count spaces in stdin, lazy bytestring" with "use toChunks for a little extra speed" at http://hpaste.org/4160#a4
02:59:06 <sjanssen> hmm, where did the streams fusion bytestring fork go?
02:59:19 <sjanssen> @where bytestring
02:59:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:00:03 <hpaste>  wli pasted "wchar_t and equivalent work" at http://hpaste.org/4169
03:00:07 <firefly> toChunks.... interesting.
03:01:03 <firefly> wli: I used the name Main_cnt in order to use the same stupid Perl script to cut out the main loop from the disassembly of the binary.
03:02:36 <firefly> wli: why bother with snprintf() and reallocating the output buffer?  why not just use printf?!?!
03:02:37 <wli> duh, typo s/>>=/<<=/g
03:02:44 <firefly> yes ;)
03:03:03 <wli> firefly: No way to detect errors with printf(). You don't know if you got a short write or not.
03:03:18 <firefly> ah.  But does it matter at all in a case like this?
03:03:43 <wli> firefly: Bondage and discipline programming takes its toll.
03:03:54 <firefly> printf() also sets a rather low limit on how much output it is guaranteed to allow.  (504 characters or something like that?)
03:04:52 <firefly> Still, much better in this case to use snprintf() to a fixed size buffer for the number and fputs() for the number buffer and the strings.
03:04:59 <firefly> Much harder to get subtly wrong.
03:05:24 <wli> firefly: To be comparable to Haskell, arbitrary output lengths must be handled, with errors detected and reported.
03:06:06 <firefly> but that is not something that affects the speed?
03:06:21 <wli> firefly: That's not known a priori.
03:06:47 <SamB_XP> prove it!
03:07:22 <firefly> why not?  If the interest is on the main loops one can always make the input big enough to make it not matter, right?  (unless the program(s) try to keep the entire file in memory at once)
03:07:32 <wli> firefly: As you can see from the C code to make it happen, it is a fair amount of code.
03:08:15 <firefly> yes.  And I still contend it would be simpler to get right with a string of fputs() with a single snprintf() to a fixed-size buffer for the number.
03:08:33 <firefly> Also, most CS graduates would then be able to understand it.
03:10:08 <wli> firefly: Well, with the wchar_t's etc. etc. it's more an exercise in making the C ape the functionality in Haskell as opposed to optimal C. The contention I'm making is that there's a lot of hidden correctness functionality in Haskell where C typically cuts corners for "blazing speed at the cost of correctness in corner cases" vs. putting up a benchmark contender.
03:10:51 <SamB_XP> I thought C cut corners for hysterical raisons
03:10:51 <firefly> 1) the bytestring versions I posted are not comparable with your wgetchar() version.  They test a single byte at a time.
03:10:54 <wli> Especially typical handwritten C.
03:11:08 <firefly> 2) wgetchar() means...what?  how big is a wchar_t?
03:11:30 <firefly> 3) ghc/haskell has rather confused and incomplete handling of encodings, anyway.
03:12:14 <wli> firefly: It has things like front ends to decode utf8 which I presume is what Haskell's huge characters are for.
03:12:56 <firefly> (4) btw, the foreign function interface helper functions threaten to use the current locale to autoconvert between encodings some day ... AARGGH!  That's most likely precisely what you don't want.)
03:13:35 <wli> firefly: LANG/LC_CTYPE is required to trigger the utf8 front-end specifically. Otherwise it does no decoding and otherwise it just uses bloated characters like Haskell to stuff ASCII values into.
03:13:35 <SamB_XP> wli: I was under the impression that the unicode support was to take advantage of the huge characters ;-)
03:16:21 <wli> firely: In which case C is put into a situation much like Haskell with respect to handling oversized characters for not much of a reason.
03:17:17 <firefly> wli: look at item 1 again.
03:18:13 <wli> firefly: wchar stuff tests a single byte at a time unless LANG/LC_CTYPE triggers the use of the utf8 codec.
03:18:19 <SamB_XP> what FFI helper routines?
03:18:44 <firefly> SamB_XP: conversion between Haskell strings and C strings.
03:18:50 <SamB_XP> wli: are you implying that utf-8 is the only multibyte encoding in existance?
03:18:51 <wli> firefly: It promotes the single bytes to ints "just in case" in a similar fashion to Haskell.
03:19:29 <SamB_XP> firefly: well, I think they will eventually decide to make new routines that do the locale-based conversion...
03:19:29 <wli> SamB_XP: I didn't mean to. I'm aware of others (EUC-JP, Bigsomething for Chinese, etc.).
03:19:33 <firefly> You do want a way to specify encodings when interfacing with foreign functions but you most likely don't want them to be determined by the current locale.
03:19:55 <SamB_XP> you might!
03:19:58 <firefly> I know that the functions actually don't do this conversion, they are just apparently intended to, "Some Day", according to the comments.
03:20:37 <SamB_XP> well, I suspect that this plan will be revised
03:22:56 <firefly> wli: see my item 1 again.
03:23:40 <wli> I already thought of your item 1 before I even started writing it and it is dealt with as I described. End of story.
03:25:35 <firefly> then I'm afraid one or both of us don't read or write too well.  Hope it's not me.
03:26:30 <wli> wchar_t deals with one byte at a time unless variable-length codecs are invoked.
03:26:56 <firefly> anyway, I'll add it (or something close to it) to the test suite together with a couple of haskell tests that use strings instead of bytestrings.
03:27:10 <wli> They are not invoked unless LANG or LC_CTYPE is involved.
03:27:54 <firefly> wli: 1) that run-time flexibility costs 2) don't pretty much everybody use UTF-8 on Linux these days?
03:28:11 <wli> I mostly see LANG=C
03:28:29 <wli> if LANG is set at all. LC_* never set directly.
03:28:57 <wli> Runtime flexibility makes it an imperfect emulation of unpacked Haskell structures.
03:28:59 <flux-> it may be that everyone who uses ascii subset of utf8 runs utf8?-)
03:29:32 <wli> It's already an imperfect emulation because of lists vs. arrays.
03:29:36 <firefly> LANG=en_DK.UTF-8
03:29:47 * SamB_XP switched to en_US.utf-8 (modulo spelling of utf-8) for the benefit of J
03:29:50 <SamB_XP> JHC
03:29:59 <SamB_XP> hit the wrong key there...
03:30:16 <firefly> What distros don't use UTF-8 by default these days?
03:30:26 <flux-> samb_xp, and how many latin1-systems with high-bit content you need to interface with?
03:30:27 <firefly> Red Hat and Ubuntu switched years ago.
03:30:33 <SamB_XP> dunno, this was installed some time ago
03:31:10 <SamB_XP> well, nowadays whenever I start aptitude over putty I need to tell putty to use utf-8
03:31:34 <wli> There's also more to it than the bloated chars. There's also the intensive error checks.
03:31:41 <SamB_XP> which I discovered you can do just by typing utf-8 in the encoding combo box...
03:32:20 <wli> Similar error checks arise from the Haskell RTS/etc. handling arbitrary-length everything everywhere.
03:32:56 <SamB_XP> didn't handle impossibly-long arrays though ;-P
03:33:36 <wli> It's another imperfection in the emulation, yes.
03:34:01 <wli> However, the basic check that output is actually feasible and coming out correct is there.
03:34:27 <wli> Along with the arbitrary-length output buffering.
03:35:14 * SamB_XP is referring to that bug where GHC allowed (array length * size of pointer) calculations to overflow
03:35:54 <wli> I didn't hear of it.
03:36:01 <SamB_XP> it's been fixed
03:36:01 <firefly> wli, don't you have to use fputs() or write() (or fwrite()) if you really want to make sure that long filenames can be output?
03:36:14 <firefly> isn't snprintf() allowed to have the same output size limitation as printf()?
03:36:32 <SamB_XP> but we could easily make all kinds of scary scary error messages come spewing out of lambdabot just by creating impossibly long arrays ;-)
03:37:09 <wli> firefly: It may loop if that's the case.
03:37:22 <SamB_XP> isn't snprintf required to tell you how many characters it was supposed to output, and isn't it supposed to fill up the provided buffer?
03:37:47 <SamB_XP> rather than using an internal buffer?
03:37:48 <firefly> besides, you don't check for fgetwc_unlocked() read errors and you don't report fclose() errors.
03:38:03 <SamB_XP> fgetwc_unlocked?
03:39:33 <firefly> SamB_XP: implementations are allowed to only handle up to 509 characters per "conversions", that is, a single %s or %d etc.
03:39:45 <firefly> That holds for both printf() and snprintf() as far as I can see.
03:39:53 <SamB_XP> really?
03:39:57 <SamB_XP> why for %s?
03:40:06 <firefly> The rationale is to allow them to use an internal fixed-size buffer.
03:40:18 <SamB_XP> that's not much of a rationale!
03:40:20 <firefly> %s is a conversion.  It can make the implementation simpler.
03:40:43 <firefly> %s also takes field size specifiers + can allow justification to either side.
03:41:04 <firefly> A *decent* implementation doesn't have that limitation, of course.  But the thing is, it's allowed to.
03:41:16 <SamB_XP> well, I admit I'm not sure such limits would not help with the alignment/size stuff
03:41:54 * SamB_XP thinks that restriction should be part of a "lame C" profile
03:42:13 <firefly> xxx_unlocked() because getchar() normally is locked these days, in order to be thread-safe (the buffer + associated ptrs/ctrs in the standard library for stdin/stdout would be accessible to more than one thread at a time which would cause trouble)
03:42:40 <firefly> Here we know there's only one thread doing I/O from stdin (namely the main thread).
03:42:42 <SamB_XP> true, that would cause trouble ;-)
03:42:51 <firefly> Hence the getchar_unlocked() in my code and wgetchar_unlocked in wli's.
03:43:38 <firefly> and the 509 char limit is why wli's much adorned and baroque code really doesn't quite promise as much generality as it seems.
03:44:05 * SamB_XP wonders how hard it would be to optimize the locking so that _unlocked were not much faster than the other way
03:44:07 <firefly> fputs() or write() would work be better in that respect.  The number conversion can be handled just fine with a fixed-size buffer.
03:44:10 <wli> It's not an interesting problem.
03:44:46 <SamB_XP> yeah, I don't think it's interesting either...
03:45:13 <wli> It can be made to set up an output buffer with non-printf subroutines.
03:45:15 <firefly> There's more to it.  The locking versions are function calls and the unlocking versions tend to be macros.  At least getchar_unlocked() is.
03:45:27 * SamB_XP goes to get dressed etc.
03:46:46 <wli> I used fgetwc_unlocked()
03:47:38 <firefly> sorry, typo.
03:50:49 <wli> There are two ways to go about this: (1) copy and handle allocation errors (2) writev() and handle restarting from short writes.
03:52:36 <SamB_XP> so, under what circumstances would a 509 char buffer cause truncation of a %d?
03:52:53 <SamB_XP> only if you specified a field width that wide explicitly?
03:53:30 <wli> I'm not sure what the buffer's supposed to be used for.
03:53:49 <SamB_XP> I certainly can't imagine getting 509 digits!
03:53:56 <SamB_XP> not in C
03:54:05 <firefly> SamB_XP: yes, as far as I can tell.  I am not going to look up the chapter and verse for this, though.
03:54:10 <SamB_XP> > maxBound :: Word128
03:54:13 <lambdabot>  340282366920938463463374607431768211455
03:54:19 <wli> Yeah, but you can fill up more than 509 chars doing multiple conversions.
03:54:32 * SamB_XP didn't even know there was a Word128
03:54:36 <SamB_XP> > maxBound :: Word256
03:54:37 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639935
03:54:42 <SamB_XP> > maxBound :: Word512
03:54:43 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
03:54:48 <SamB_XP> > maxBound :: Word1024
03:54:49 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
03:54:53 <SamB_XP> !!!!!!
03:55:00 <SamB_XP> what is with this
03:55:13 <SamB_XP> @index Word1024
03:55:13 <lambdabot> bzzt
03:55:20 <SamB_XP> @index Word8
03:55:20 <lambdabot> Data.Word, Foreign
03:55:24 <SamB_XP> @index Word256
03:55:24 <lambdabot> bzzt
03:55:28 <SamB_XP> @index Word128
03:55:28 <lambdabot> bzzt
03:55:30 <flux-> it's maaaagic
03:55:32 <SamB_XP> @index Word64
03:55:32 <lambdabot> Data.Word, Foreign
03:55:43 <SamB_XP> okay, so it really doesn't usually go up to 128 ;-)
03:56:06 <SamB_XP> @index Word4096
03:56:06 <lambdabot> bzzt
03:56:14 <SamB_XP> > 1:: Word4096
03:56:15 <lambdabot>  1
03:56:21 <firefly> Okay, time for something else:
03:56:37 <firefly> it seems like ghc hq is brewing a CPS transformation for C-- ?
03:56:45 <doserj> SamB_XP: crypto contains Data.LargeWord
03:57:23 <firefly> (CPS = continuation passing style, where the "rest of the program" is passed as a parameter to every function call (that's the continuation) and functions never return.  They just invoke the continuation.)
03:57:37 <pejo> firefly, speaking of that - is there any mailing list you read with this informatin on?
03:57:42 <SamB_XP> firefly: hmm?
03:58:31 <firefly> It's a bit dim in my memory because I've been reading so much about ghc in so many places -- I think I saw hints to it on some of the ghc development web pages.
03:58:37 <firefly> I hope it's not true.
03:58:52 <wli> Why not?
03:59:03 <firefly> Because I think it's bad idea, of course ;)
03:59:12 <Heffalump> firefly: I believe it is happening, yes. Not sure of the current status, though.
03:59:13 <wli> Why do you think it's a bad idea?
03:59:19 <SamB_XP> firefly: I don't think they plan what you think they plan
03:59:28 <SamB_XP> anyway, I gots to go to school now
03:59:41 <firefly> it's generally a good idea to work with the microarchitecture of the CPUs one intends to use, not against them.
03:59:55 <firefly> call and ret work quite well.
04:00:38 <firefly> indirect jumps are also beginning to be predicted in recent CPUs but do they work as well?  I don't think they do.
04:00:51 <wli> There's only one (micro)architecture anymore anyway. If any are left standing they'll die soon enough.
04:01:21 <firefly> The current code is not that far from using call/ret instead of indirect jumps.  If CPS starts being used it will be much further from using call/ret.
04:01:46 <firefly> They might even start heap allocating activation records, in which case we very likely will get bad cache behaviour.
04:02:10 <Heffalump> I think the idea of using CPS is to make it easier to generate tight loops and the like
04:02:38 <wli> I believe it's being done with a very close eye on performance, and for performance reasons. I know very little of the details.
04:02:46 <Heffalump> <aol>
04:03:25 <firefly> but does it help?  I'm don't think it will.  Just making the current argument passing visible to the current register allocator would definitely help and should be cheaper to implement :)
04:03:45 <firefly> (should read: I don't think it will)
04:04:06 <wli> ISTR hearing of numerous cases where CPS by hand improved things.
04:04:53 <wli> This suggests it's at a higher level than e.g. heap allocating activation records.
04:04:57 <hpaste>  ivant annotated "viet" with "haskellized it" at http://hpaste.org/4170#a1
04:04:59 <dibblego> Dr. Harrop is attacking Haskell with codswallop on the Scala list, yay
04:05:13 <firefly> might that not be because it created bigger functions in C-- so more values were kept in named C-- registers instead of on the explicit stack?
04:05:40 <firefly> If so, then CPS seems to be attacking the wrong problem from the wrong angle.
04:05:53 <wli> I simply have no idea.
04:06:21 <flux-> wli, by one microarchitecture you mean x86 (and x86-64)?
04:06:48 <wli> flux-: Yes.
04:07:18 <flux-> wli, that's a pretty big architecture still (in number of sold units), and if future cpu's want to be compatible, what choice do they have?
04:07:32 <wli> flux-: Not worth getting into.
04:07:37 <flux-> :)
04:07:57 <wli> firefly: If it's just a source-to-source transformation pass, it can just as easily be ripped out later.
04:08:13 <flux-> I suppose an alternative would be doing it in software, like transmeta
04:08:18 <firefly> x86 and x86-64 are definitely more than one microarchitecture, btw :)  (AMD, various from Intel, VIA, ...)
04:09:07 <firefly> wli: I hope so.  I don't think things are being measured enough, though.
04:09:07 <wli> firefly: And I suspect that's exactly what it is because it's usually source programs getting rewritten in CPS by hand that makes the difference.
04:09:19 <firefly> That's actually one of the reasons why I started on this benchmarking binge.
04:10:05 <wli> firefly: i.e. the input to ghc being in CPS vs. not
04:10:08 <firefly> Even a very simple register allocating improvement gives more than the pointer tagging, for example.
04:10:17 <pejo> firefly, the benchmarking binge is a great idea. If you supply it to people they probably will use it if it's simple enough to use.
04:10:37 <pejo> firefly, are you talking about x86_64, or all architectures?
04:11:40 <wli> CPS is very interesting from other POV's
04:12:05 <wli> You can derive the abstract machines by converting single-step tree evaluators to CPS
04:12:25 <firefly> absolutely.  CPS really twisted my brain when I learned about it.
04:12:41 <wli> I mean in practical senses.
04:12:41 <hpaste>  srid pasted "Could someone write a 'concise' version of this program?" at http://hpaste.org/4171
04:12:49 <firefly> And if you look at it the right way, the call/ret instructions in IA32/AMD64 provide explicit support for continuation passing ;)
04:13:01 <wli> Things like the STG machine are derivable.
04:13:04 <srid> I don't think my program is the "right" one though it works.'
04:13:30 <wli> firefly: I'm going to have to ask you to clarify that one. The stack crud is typically an obstacle to CPS.
04:13:59 <firefly> the return address that gets passed on the stack *is* the continuation of the program ;)
04:14:51 <wli> I may need more to go on.
04:16:28 <sjanssen> srid: I think that's the best you can do
04:16:34 <sjanssen> srid: without getting really fancy
04:16:34 <srid> sjanssen: oh.
04:16:41 <srid> sjanssen: anyway - I still learning using YAHT.
04:16:45 <srid> I am*
04:17:05 <firefly> The typed-assembly language guys submitted an assembly language program to one of the early ICFP competitions (derived from cyclone, I think) and used that as a joke.  They weren't half wrong.
04:17:41 <wli> I remember Cyclone.
04:17:59 <hpaste>  ivant annotated "viet" with "moved map out into zipWith HOF" at http://hpaste.org/4170#a2
04:18:07 <wli> I remember TAL, too. Lots of hubbub about that ca. 1997.
04:18:39 <wli> Or at least Palsberg & co. thought it was cool.
04:18:55 <firefly> It is cool :)
04:19:16 <firefly> A quick google didn't find it for me.
04:19:18 <wli> I still don't see how CPS works with a stack discipline.
04:19:58 <firefly> don't look at ret as "return" but as "jump to the continuation we got as a parameter".
04:20:07 <wli> Maybe clobbering the return address on the stack and resetting the stack pointer.
04:20:12 <firefly> The difference is just in allocation and deallocation of memory.
04:20:52 <firefly> anyway, CPS seems most liked by Americans who grew up on Lisp and Scheme and like call/cc.
04:21:20 <firefly> CPS (with heap-allocated activation records) works very nicely with call/cc and thread libraries written in the language itself on top of call/cc.
04:21:35 <firefly> CPS (with heap-allocated activation records) works very nicely with call/cc and thread libraries can be written in the language itself on top of call/cc.
04:21:52 <wli> I mostly ignored Lisp and Scheme and started off on Standard ML (basically I liked the word "standard").
04:22:07 <firefly> It doesn't seem to be as popular this side of the pond where we didn't get call/cc branded into our brains from an early age.
04:23:34 <wli> I thought because of the name that there was more stuff like standards orgs. etc. I found out otherwise later.
04:23:35 <firefly> And performance-wise you do tend to lose out if you don't use a simple stack for your activation records because doing (lots of) heap allocation and relying on the garbage collector to clean it up isn't nice on the cache.  At the very least, you've got strong forces working against you.
04:24:14 <Heffalump> CPS is very much an intermediate representation, not a strategy for structuring the final compiled code, AIUI
04:24:19 <Heffalump> (in the case of GHC, that is)
04:24:36 <firefly> Fritz Henglein did try to get a CPAN-like standardml.org up and running back in early 2000 but he didn't have the manpower.
04:25:29 <pejo> firefly, did you see the paper to ICFP this year by Andrew Kennedy?
04:25:44 <wli> I was expecting standards bodies, IEEE/ACM/etc. involvement, etc., not CPAN.
04:25:46 <firefly> Moscow ML and SML/NJ had/have maintainers who had other things to do as their main job (Peter Sestoft became full professor, for example, plus did a lot of work with C#).
04:25:50 <pejo> (Regarding CPS and americans).
04:26:14 <firefly> no.  better read it then.
04:27:45 <srid> sjanssen: I'm wondering how to do ex 4.7
04:28:06 <sjanssen> srid: what is that?
04:28:48 <Heffalump> how maintained is MLton now? Stephen Weeks is working for Jane St Capital, IIRC.
04:28:51 <srid> sjanssen: Based on our definition of Tuple from the previous exercise, write a function which takes a Tuple and returns either the value (if it√¢s a one-tuple), a Haskell-pair (i.e., (√¢a√¢,5)) if it√¢s a two-tuple, a Haskell-triple if it√¢s a three-tuple or a Haskell-quadruple if it√¢s a four-tuple. You will need to use the Either type to represent this.
04:29:47 <quicksilver> Heffalump: anecdotally it is the case that a manual CPS transform can give substantial performance boost to ghc-compiled code.
04:29:52 <quicksilver> Heffalump: I don't know whyy.
04:29:56 <quicksilver> (I'd like to)
04:30:39 <sjanssen> srid: are you familiar with Either?
04:30:51 <srid> sjanssen: yea, I just read about that in that chapter.
04:31:43 <srid> sjanssen: I was doing this http://hpaste.org/4172
04:32:19 <sjanssen> srid: that isn't a valid data declaration
04:32:32 <srid> oh.
04:32:52 <srid> I think I then need to read a comprehensive writing on haskell 'data declarations' before proceeding in YAHT. no?
04:32:56 <sjanssen> srid: and, instead of declaring a new type, just use nested Eithers
04:34:01 <sjanssen> eg. (Either a (Either (a, b) ...))
04:35:06 <srid> sjanssen: Either is a built-in type, just like Just and Nothing?
04:35:40 <sjanssen> srid: I'd call it pre-defined, not built-in
04:35:49 <sjanssen> srid: because you can define it in normal code:
04:35:53 <sjanssen> @src Either
04:35:53 <lambdabot> Source not found. :(
04:35:58 <sjanssen> bah
04:36:07 <sjanssen> data Either a b = Left a | Right b
04:36:45 <sjanssen> srid: also, Just and Nothing are type constructors, not types.  Maybe is the type that has the constructors Just and Nothing
04:36:45 <srid> yea
04:37:01 <sjanssen> oops, I mean they're data constructors, not type constructors
04:37:41 * srid is looking for sources other than HAYT to read about data/type/misc in haskell.
04:37:47 <srid> YAHT*
04:38:39 <firefly> pejo: that was an interesting article to skim.  They did convert back to something sensible after the CPS phase, though :)
04:38:42 <sjanssen> consider data Bool = False | True
04:38:59 <sjanssen> we're introducing three things in that declaration: a new type called Bool
04:39:23 <sjanssen> and two data constructors called False and True
04:39:31 <pejo> firefly, Danvy had a rebuttal at IFL this year too, it's the last article in the unofficial proceedings.
04:39:33 <srid> `constructors'?
04:39:42 <srid> ok
04:41:38 <srid> Not in scope: data constructor `Either'
04:41:43 <srid> Either is not pre-defined?
04:41:53 <srid> err. it's a type.
04:42:31 <srid> sjanssen: tuple_value (Tuple1 a) = Left a ?
04:42:41 <srid> I'm fsck'ed up.
04:42:44 <sjanssen> srid: ype, that's a start
04:42:47 <sjanssen> yep
04:43:40 <vincenz> @src :+:
04:43:40 <lambdabot> Source not found.
04:43:42 <vincenz> @src :+
04:43:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:43:50 <srid> sjanssen: next: tuple_value (Tuple2 a b) = Right (a, b)
04:43:51 <vincenz> @src (:+)
04:43:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:44:25 <vincenz> srid: no
04:44:32 <vincenz> Right (Left(a,b))
04:44:41 <sjanssen> srid: initially, this seems sensible.  Ask yourself what the case for Tuple3 will be
04:44:44 <srid> ah ok - I'm getting it.
04:45:32 <vincenz> it's like a type level list
04:45:44 <firefly> pejo: do you remember the title?
04:45:44 <vincenz> so to get the proper value, you do the right amount of cdrs (Right) and then a car (Left)
04:47:13 <firefly> Ah, the draft proceedings are here: http://proglang.informatik.uni-freiburg.de/IFL2007/proceedings.shtml
04:47:15 <lambdabot> Title: IFL 2007: Proceedings, http://tinyurl.com/ysd2er
04:47:35 <srid> vincenz: ok, finally up to - tuple_value (Tuple4 a b c d) = Right (Right (Right (Left (a, b, c))))
04:47:49 <vincenz> srid: right, but you're missing the 'd'
04:47:59 <vincenz> but yes, in essence :)
04:48:03 <srid> ah yes. typo
04:48:23 <srid> great! it works. now I can move on to the next section.
04:48:48 <firefly> "Amortizing the Cost of Commuting Conversions when Beta-Reducing Monadic Normal Forms and A-Normal Forms" ?
04:49:50 <pejo> firefly, yeah, probably. It's written in ascii, near the end of the proceedings.
04:50:00 <firefly> yep, that's the one.
04:51:44 <vincenz> Wow
04:51:47 <vincenz> Did anyone read this?
04:51:48 <vincenz> http://www.russellbeattie.com/blog/irseeking-trouble
04:51:49 <lambdabot> Title: RussellBeattie.com - IRSeeking trouble...
04:51:53 <vincenz> Apparently they're doing it in #haskell as well
04:52:19 <firefly> he references "The fog is lifting" ("Taagen letter"), a beautiful piece of music by Carl Nielsen ;)
05:03:12 <vincenz> @join #oasis
05:19:38 <dcoutts_> newsham: ping
05:19:40 <dcoutts_> firefly: ping
05:19:52 <firefly> hi!
05:26:31 <Syzygy-> o.O
05:26:42 <Syzygy-> I have over 500 hits there. Going back to April.
05:27:44 <Syzygy-> Including one really ugly argument over whether discussing rank over the Gaussian algorithm or with more abstract means is the more didactically correct way to talk with a guy who already has a CS degree...
05:30:43 <firefly> dcoutts: I'm currently on a benchmarking binge, primarily to look at ghc's low-level code generation and secondarily, to see how well bytestrings perform.
05:30:55 <dcoutts_> firefly: sounds fun
05:31:24 <firefly> Do you have any interesting code that uses bytestrings that I could use?  It shouldn't be too big but it should be more realistic than just counting spaces, which is my current most advanced task.
05:31:47 <firefly> (which already shows disturbing variations in execution time)
05:33:27 <dcoutts_> firefly: the one we used in our paper was: return ¬∑ foldl' hash 5381 ¬∑ map toLower ¬∑ filter isAlpha =< readFile f
05:33:37 <dcoutts_> where hash h c = h ‚àó 33 + ord c
05:33:43 <firefly> oh yeah.  Gotta add that one (and variations thereof).
05:34:11 <dcoutts_> firefly: it also relies on a fast isAlpha
05:34:21 <dcoutts_> that doesn't do full unicode tests
05:34:34 <firefly> I also wonder why lazy bytestrings are so slow - I might have made a mistake in leaving out a strictness annotation, though.
05:34:46 <firefly> (4-5x slower than strict bytestrings in my space counting example)
05:35:05 <dcoutts_> in theory we should always be able to make lazy bytestrings as fast as strict ones
05:35:16 <dcoutts_> at least for large chunk sizes
05:35:35 <dcoutts_> since a lazy one is just a strict one with a next pointer
05:35:41 <firefly> that a new block of memory is used for each read and that the garbage collector has to clean up should slow it down a bit compared to the theoretical best, but still.
05:36:13 <dcoutts_> firefly: I've measured the cost of that and it's negligible
05:36:14 <firefly> lazy bytestrings should actually be faster than strict ones when all you do is reading linearly through a (cached) file.
05:36:37 <dcoutts_> firefly: the cache effects are much more important than the allocation and GC costs
05:36:56 <firefly> Reading through a file with a smallish buffer size + stepping through the buffer linearly is faster than using a big buffer and doing the same stepping.
05:37:03 <dcoutts_> yes
05:37:05 <firefly> At least all else being equal.
05:37:10 <firefly> (due to cache effects)
05:37:14 <dcoutts_> though re-using the same buffer each time is even faster
05:37:20 <dcoutts_> and we cannot do that
05:37:32 <dcoutts_> we end up cycling through several buffers as they get GC'ed
05:37:41 <firefly> no.  I think Ben Lippmeier is toying with region analysis in haskell?  That might help.
05:38:10 <dcoutts_> well we cannot do it at the moment
05:38:21 <dcoutts_> but anyway, it is not a big cost at all
05:38:40 <firefly> anyway, I was truly surprised about the 4-5x loss of speed.  It was so unexpected that I really should dig closely into it.  Tomorrow, perhaps?
05:38:54 <dcoutts_> once you actually start doing something with the data rather than just copying it then the overhead is unmeasurably small
05:39:23 <dcoutts_> firefly: yes, with the new lazy bytestring representation any slowdown compared to strict bytestring is an area for improvement
05:39:38 <firefly> The buffer size thing made a big difference in a toy XML parser I wrote.
05:39:47 <firefly> mmap() was fastest IFF the file was already cached.
05:40:09 <dcoutts_> firefly: however the lazy bytestring relies on SpecConstr to get the same speed as strict bytestring
05:40:16 <dcoutts_> firefly: and that was broken in 6.8.1
05:40:29 <dcoutts_> so you need 6.8.1.$snapshot or ghc HEAD
05:40:39 <firefly> I use head as of about a week ago.
05:41:14 <firefly> (but I know I should redo my ghc installations just to be completely sure to nail everything down.)
05:41:41 <firefly> I'm probably going to script all the installation stuff so I can be completely sure what is installed and how -- and so others can repeat it.
05:43:43 <firefly> anything else you can think of that I should include in the benchmarking?
05:43:53 <firefly> strace, perhaps, to see what read() calls actually get issued?
05:45:43 <firefly> anything you would like to see run through cachegrind?
05:57:01 <ttfh> hmm, I can't catch IOErrors in my outer monad (StateT) right?
06:05:42 <quicksilver> ttfh: well, that's a good question :)
06:06:04 <quicksilver> ttfh: you can, but you're going to have lost the state up to that point, I think?
06:06:17 <ttfh> yes, I think so
06:06:32 <quicksilver> better to us an ErrorT
06:06:47 <ttfh> yes, and then comes the next question :-)
06:06:48 <quicksilver> and run your internal IO actions so they 'unwrap' into "Left IOError"
06:06:51 <quicksilver> type stuff
06:07:28 <ttfh> StateT inside ErrorT or the other way around?
06:08:03 <quicksilver> if you want to have result state despite the error
06:08:09 <quicksilver> then you want ErrorT StateT
06:08:10 <quicksilver> I think
06:08:26 <quicksilver> @unmtl ErrorT IOError (StateT s IO) a
06:08:26 <lambdabot> s -> IO (Either IOError a, s)
06:08:30 <ttfh> I want to keep the state
06:08:30 <quicksilver> yup
06:08:38 <quicksilver> that's what you want then
06:08:50 <quicksilver> ErrorT IOError (StateT s IO)
06:09:16 <ttfh> hmm, yes
06:09:56 <ttfh> I'm trying to formulate som rule to remember which monad goes inside which
06:10:37 <quicksilver> the outer ones can't stop the side effects of the inner
06:10:42 <quicksilver> that's why IO is always in the middle
06:10:50 <quicksilver> because nothign can rollback IO
06:11:37 <ttfh> So if I wanted a system where I could "undo" state changes...
06:12:59 <sieni> ttfh: what do you mean by that?
06:13:31 <ttfh> sieni: changes i a StateT
06:15:43 <BMeph> s/overdrawn/balance-of-a-million/g ;p
06:17:38 <sieni> ttfh: well, you could have the states you want to undo to in your inner monad or then keep the undo information as a separate part of the state
06:18:14 <EvilTerran> :kind StateT
06:18:34 <roconnor> dons: *sigh* if only the original ruby post had used an exponential problem.
06:18:59 <Beelsebob> @hoogle FilePath -> IO String
06:19:00 <lambdabot> Prelude.readFile :: FilePath -> IO String
06:19:42 <EvilTerran> ?unmtl StateT s [] a
06:19:43 <lambdabot> s -> [(a, s)]
06:20:11 <ttfh> Is it correct to think of it like this: If I had "StateT (ErrorT ...)" I would have to "runStateT" before I could get the Error, so I couldn't recover from errors without throwing away my state?
06:20:41 <EvilTerran> the (StateT s []) monad has a seperate state for each "parallel universe" of the nondeterminism
06:20:55 <Heffalump> you can capture the state and reuse it
06:21:22 <Beelsebob> @hoogle Integral a => a -> b -> [b]
06:21:22 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
06:21:22 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
06:21:24 <EvilTerran> @unmtl ListT (State s) a
06:21:24 <lambdabot> s -> ([a], s)
06:21:43 <EvilTerran> the ListT (State s) monad has one state shared between all parallel universes
06:21:44 <Heffalump> one of the unwrappers (runStateT, execStateT and evalStateT) gives you both the value and the state
06:22:34 <ttfh> I think I will have to experiment with this to understand it
06:23:20 <EvilTerran> s -> [(a, s)]  -- takes a state, returns list of (result,state) pairs; one state for each result
06:24:58 <EvilTerran> s -> ([a], s)  -- takes a state, returns only one state (and the list of results)
06:28:31 <Beelsebob> @index unsafePerformIO
06:28:31 <lambdabot> System.IO.Unsafe, Foreign
06:33:41 <srid> how do I 'add' two lists?
06:33:48 <srid> (not cons)
06:33:56 <allbery_b> zipWith (+) -- ?
06:34:04 <srid> what is zipWith?
06:34:14 <idnar> @src zipWith
06:34:14 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:34:14 <lambdabot> zipWith _ _      _      = []
06:34:19 * allbery_b is not sure what you want
06:34:35 <sieni> > zipWith (+) [1..4] [2..7]
06:34:37 <lambdabot>  [3,5,7,9]
06:34:38 <idnar> srid: what exactly do you mean by 'add'?
06:34:43 <srid> [1,2,3] + [4,5,6] should give [1,2,3,4,5,6]
06:34:52 <idnar> > [1,2,3] ++ [4,5,6]
06:34:58 <sieni> > (++) [1,2,3] [4,5,6]
06:35:02 <lambdabot>  [1,2,3,4,5,6]
06:35:02 <lambdabot>  [1,2,3,4,5,6]
06:35:25 <srid> ok
06:35:26 <sieni> srid: the term is "concatenate"
06:35:34 <srid> yep
06:36:12 <hkBst> augustss: ping
06:44:25 <hpaste>  srid pasted "why doesn't this work?" at http://hpaste.org/4173
06:44:35 <srid> binary tree example
06:45:07 <srid> yea - BinaryTree is a "type" - but I was thinking abstractly when I wrote this.
06:45:33 <oerjan> just replace (BinaryTree a) with a
06:45:34 <srid> since treeFoldl is taking care of the Leaf/Branch cases, why should I 'replicate' the same in treeElements2 instead of abstracting it using BinaryTree itself?
06:45:38 <srid> ah ok
06:47:30 <srid> Occurs check: cannot construct the infinite type: t = [t] -- still debugging.
06:48:05 <oerjan> oh right
06:48:44 <srid> interesting - haskell 'forces' you to write correct programs.
06:49:05 <srid> but I still couldn't find the bug :)
06:49:47 <oerjan> srid: (:) and [] are for a right fold, won't work with a left one
06:50:04 <srid> ok!
06:50:46 * srid is trying to write a foldl for binary_tree that does in-order travesal
06:51:46 <oerjan> treeFoldl looks fine to me, although it'll probably have the usual foldl vs. foldl' strictness problem
06:52:28 <srid> ok, (++) seems to work.
06:53:18 <srid> nope
06:53:33 <oerjan> i think that would force a to be a list
06:53:46 <oerjan> i mean, the elements of the tree
06:54:16 <srid> I'd be nice if there was a function that appends a list and a list OR a list and an element (of type same as the list content)
06:54:26 <srid> s/appends/concatanate/
06:54:33 <oerjan> there cannot be
06:55:03 <srid> anyway - this is all ex 4.10 in YAHT.
06:55:17 <srid> Exercise 4.10 Write a fold function for BinaryTrees and rewrite elements in terms of it (call the new one elements2).
06:55:18 <oerjan> (\l x -> l++[x]) should work
06:55:19 <BMeph> srid: So, how would you tell this function whether you want to append or catenate two lists?
06:55:46 <srid> BMeph: ok - haskell is statically typed. I give up.
06:56:15 <oerjan> srid: try that function instead of (++)
06:56:27 <hkBst> srid: use a Type Class?
06:56:40 <DRMacIver> There can be, sortof, given sufficient type class hackery. But the results wouldn't be very nice.
06:56:41 <srid> oerjan: it worked!
06:56:54 <oerjan> mind you, adding elements to the ends of list is much more expensive than at the beginning
06:57:10 <DRMacIver> If you want to append to both ends, consider a Data.Sequence
06:57:31 <srid> oerjan: how does that work?
06:57:57 <oerjan> srid: the function i gave?  it's a lambda expression
06:58:13 <srid> ok - got it.
06:58:30 <oerjan> it's equivalent to the function f where f l x = l++[x]
06:58:32 <srid> (\arg1 arg2 ...) -> expr
06:58:48 <oerjan> no parentheses
06:59:15 <oerjan> inside i mean
07:00:07 <srid> ok
07:18:59 <srid> oerjan: how would you write `f` for foldr?
07:19:07 <srid> treeFoldr f z (Leaf x) = (f x z)
07:19:07 <srid> treeFoldr f z (Branch left x right) =
07:19:07 <srid>     treeFoldr f (f (treeFoldr f z right) z) left
07:19:11 <srid> treeElements3 a = treeFoldr (\x l -> [x]++l) [] a
07:19:16 <srid> that lambda expression is wrong.
07:20:29 <oerjan> then (:) should be right
07:21:33 <srid> oerjan: that doesn't work - because this time, the left *or* the right argument can be a list.
07:22:13 <oerjan> then it's not the foldr corresponding to your foldl
07:22:25 <srid> 'corresponding'?
07:22:36 <srid> first of all - is my treeFoldr correct?
07:22:59 <oerjan> no
07:23:16 <oerjan> you are not mentioning x on the right side
07:25:21 <oerjan> the last z should be x i think
07:26:20 <srid> treeFoldr f z (Branch left x right) =
07:26:20 <srid>     treeFoldr f (f x (treeFoldr f z right)) left
07:26:23 <srid> that works!
07:27:31 <desp> Hm. Is anyone here aware of IRSeeking?
07:27:33 <srid> oerjan: http://hpaste.org/4174 - I wonder if that is really the definition of 'foldr'
07:27:37 <desp> IRSeek*
07:27:52 <desp> Just found out they do full-scale logging of Freenode.
07:28:04 <desp> http://www.russellbeattie.com/blog/irseeking-trouble
07:28:04 <lambdabot> Title: RussellBeattie.com - IRSeeking trouble...
07:28:10 <quicksilver> desp: yes someone pointed that out earlier
07:28:19 <quicksilver> (as you would have known if you'd checked the IRSeek logs! :)
07:28:29 <srid> oerjan: .. as I do (f x z) instead of (f z x)
07:28:55 <desp> quicksilver: :)
07:29:00 <oerjan> srid: that's right, the initial value should come at the right end
07:29:20 <srid> ah yes.
07:29:56 <oerjan> in fact with trees foldl and foldr should be symmetric, and they are
07:30:19 <araujo> morning
07:30:40 * srid moves on to the next section in YAHT
07:42:20 <ttfh> now I think I understand the order of StateT and ErrorT a little better
07:46:02 <ttfh> It came together when I looked at the type for runStateT, "StateT s m a -> s -> m (a, s)", the state is trapped inside the inner monad, if the inner monad is "ErrorT something", the state is lost in case of an error
07:47:46 <Heffalump> @unmtl (StateT s (ErrorT e) a)
07:47:46 <lambdabot> err: Unknown MTL(1)
07:54:07 <quicksilver> @unmtl StateT s (ErrorT e m) s
07:54:07 <lambdabot> s -> m (Either e (s, s))
07:54:13 <quicksilver> is what Heffalump meant :)
07:54:24 <quicksilver> erm
07:54:27 <quicksilver> @unmtl StateT s (ErrorT e m) a
07:54:27 <lambdabot> s -> m (Either e (a, s))
07:54:31 <quicksilver> would be even better!
07:55:09 <Saizan> someone should fix that parser!
07:55:17 <fourbiss1me> (a few hours later) okay, so Yi does not compile anymore, right ? But is this project still alive ? and worth the look ?
07:58:59 <Heffalump> waern: what's the current status of haddock.ghc?
08:01:32 <waern> Heffalump: will be released after 6.8.2 is out
08:01:44 <waern> Heffalump: darcs repo: code.haskell.org/haddock
08:04:31 <waern> Heffalump: the darcs version works with 6.8.1
08:04:59 <Heffalump> waern: cool, thanks.
08:22:41 <dons> ?userrs
08:22:42 <lambdabot> Maximum users seen in #haskell: 420, currently: 400 (95.2%), active: 9 (2.3%)
08:22:53 <vincenz> dons: #haskell was leached
08:23:15 <dons> hmm?
08:23:15 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
08:23:43 <Heffalump> "leached"?
08:23:45 <vincenz> dons: some website has been logging channels and then placing it online in a search engine
08:23:49 <vincenz> Pisses me off
08:23:58 <vincenz> since we explicitly did not have lambdabot in #oasis to go against logging
08:24:01 <dons> yeah, there's lots of those
08:28:55 <hkBst> > let hellofac 0 = return 1; hellofac n = putStr "hello" >>= (\x -> (liftM (+1) $ hellofac (n - 1)) in hellofac 1 -- why the parse error? It works without the redundant >>= (\x ->
08:28:55 <lambdabot> Unbalanced parentheses
08:29:09 <hkBst> > let hellofac 0 = return 1; hellofac n = putStr "hello" >>= (\x -> (liftM (+1) $ hellofac (n - 1))) in hellofac 1
08:29:15 <lambdabot>  <IO Integer>
08:29:35 <hkBst> hmm, lambdabot has better error messages than GHCi
08:30:41 <hpaste>  redemption pasted "I get an error i don't understand, please explain, so i can learn! tia!" at http://hpaste.org/4175
08:32:26 <dmwit> redemption: What's the error?
08:32:51 <laz0r> i know that i can have IO 'inside' of StateT, like StateT Foo IO Bar, now if i wanted it to be the other way around, would that be possible?
08:33:06 <laz0r> is there some MonadTrans magic that will make it work?
08:33:45 <laz0r> i know there is 'lift' but i don't fully understand when that applies and when not
08:34:27 <desegnis> hkBst: In particular, ghc error messages are often too long.
08:34:38 <Heffalump> 'lo
08:35:45 <desegnis> laz0r: To my knowledge there is no IO monad transformer, and it would not even be possible to define.
08:35:46 <hpaste>  dmwit annotated "I get an error i don't understand, please explain, so i can learn! tia!" with "do less work" at http://hpaste.org/4175#a1
08:35:51 <Saizan> laz0r: that's not possible because building an IO transformer means being able to exit from IO
08:36:23 <dmwit> laz0r: What do you want to do?
08:38:23 <laz0r> dmwit, i have written a program that loads and executes generated haskell code, via has-plugins, now in that plugin i need a state, but would want it to return a IO Something
08:39:20 <dmwit> laz0r: No problem, IO actions are just values.
08:39:24 <dmwit> Go ahead and return them.
08:39:52 <laz0r> mmh, ok
08:40:13 <sieni> what's has-plugins? some lolcode thingie?
08:40:29 <dmwit> heh
08:40:34 <EvilTerran> @where hsplugins
08:40:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:40:39 <laz0r> so i can just do the state thing inside the plugin, and then at the very end write return foo?
08:40:42 <hpaste>  dmwit annotated "I get an error i don't understand, please explain, so i can learn! tia!" with "ooops" at http://hpaste.org/4175#a2
08:40:47 <laz0r> oops, type
08:40:49 <laz0r> typo
08:40:52 <laz0r> hs-plugins
08:41:14 <sieni> can i has plugins, kthxbye?
08:41:46 <vincenz> ok
08:41:57 <vincenz> dmwit: why isn't he using Data.Graph?
08:41:59 <dmwit> redemption: So it looks like probably the error you were getting was because you didn't have the "Eq t =>" restriction in your instance declaration.
08:42:04 <dmwit> vincenz: not sure
08:42:10 <oerjan> laz0r: do you want this state to be preserved across calls?  you might be able to use an IORef
08:42:13 <dmwit> vincenz: I don't even know if he's here on the channel. =)
08:42:18 <vincenz> dmwit: apparently not
08:42:25 <laz0r> oerjan, no, that is not necessary
08:42:57 <oerjan> ok then just returning should work
09:06:36 <Beelsebob> yay :) I'm increasing the average position of Haskell on Project Euler now
09:07:14 <dons> awesome
09:07:27 <BMeph> Haskell: We're upping our average. Up yours. ;)
09:07:34 <Beelsebob> rofl
09:11:12 <Beelsebob> oops
09:11:26 * Beelsebob just write a function to convert numbers to binary
09:11:37 <Beelsebob> on input 99, it returned [1,9,4]
09:11:38 <Beelsebob> :)
09:12:27 <Notrix> you're writing a function to convert numbers to binary ?
09:12:48 <Beelsebob> :P
09:12:58 <vincenz> Beelsebob: not very binary
09:13:15 <ricky_clarkson> @hoogle Integer -> [Char]
09:13:15 <lambdabot> No matches, try a more general search
09:13:20 <vincenz> > map (`mod` 2) . dropWhile (/=0) . iterate (`div` 2) $ 99
09:13:21 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:13:28 <vincenz> > map (`mod` 2) . takeWhile (/=0) . iterate (`div` 2) $ 99
09:13:31 <lambdabot>  [1,1,0,0,0,1,1]
09:13:49 <Beelsebob> essentially what I was doing
09:13:59 <Beelsebob> but managed to get a call to digits mixed into it
09:14:17 <vincenz> > concatMap show . map (`mod` 2) . takeWhile (/=0) . iterate (`div` 2) $ 99
09:14:17 <lambdabot>  "1100011"
09:14:40 <doserj> > showIntAtBase 2 (head.show) 99 ""
09:14:40 <lambdabot>  "1100011"
09:14:55 <ricky_clarkson> > concatMap show . map (`mod` 2) . takeWhile (/=0) . iterate (`div` 2) $ 0
09:14:57 <lambdabot>  ""
09:16:37 <vincenz> > 81-4*95
09:16:38 <lambdabot>  -299
09:16:54 <vincenz> > 81+4*95
09:16:56 <lambdabot>  461
09:17:01 <vincenz> > sqrt 461
09:17:02 <lambdabot>  21.470910553583888
09:17:13 * vincenz wonders how Beelsebob ever got [1,9,4]
09:17:20 <vincenz> there is no base that turns that into 99
09:17:26 <Beelsebob> bits x
09:17:27 <Beelsebob>   | x < 2    = [x]
09:17:27 <Beelsebob>   | otherwise = x `mod` 2 : (digits (x `div` 2))
09:17:36 <Beelsebob> -- zomg that's stupid
09:17:40 <byorgey> vincenz: but there are lots of functions that turn 99 into [1,9,4] =)
09:17:51 <vincenz> byorgey: yes, we call them 'spam'
09:17:54 <vincenz> :)
09:18:10 <Beelsebob> :P
09:18:54 <vincenz> Beelsebob: bits !x
09:19:13 <Beelsebob> why would I want to strictify that?
09:19:55 <vincenz> for obvious reason :)
09:20:00 <vincenz> oh wait, you're comparing
09:20:01 <vincenz> duh me
09:20:07 <allbery_b> er?  the guard makes it effectively strict
09:20:12 <Beelsebob> indeed
09:20:21 <Beelsebob> and anyway... even if it didn't... why would I want to strictify it
09:20:38 <Beelsebob> most of the Haskell I write relies on stuff being really really lazy
09:21:12 <vincenz> allbery_b: right, my point in the 'duh me'
09:21:33 <allbery_b> yeh
09:21:34 <BMeph> @remember BMeph "Lazy expressions are the best at basketball. You can't guard a lazy expression."
09:21:34 <lambdabot> I will remember.
09:22:18 * allbery_b is having dsl pauses, so his remark ended up delayed a bit
09:29:58 <EvilTerran> @hoogle readInt
09:29:59 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
09:29:59 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
09:29:59 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
09:33:24 <Beelsebob> hmm, this one really doesn't pass on the one minute rule... and it also appears to have eaten a gig of ram... probably needs a rewrite
09:34:39 <byorgey> Beelsebob: doh.  Which one are you working on?
09:35:09 <Beelsebob> 27 -- I'd done it *really* na√Øvely... by building all posibilitys, then sorting the result
09:35:36 <Beelsebob> can stop it keeping everything in RAM just by foldling over the list and keeping track of the max
09:39:16 <Cale> Heh, it would be much more interesting without the restriction "starting with n = 0"
09:39:29 <Beelsebob> would indeed
09:41:52 <glguy> @yow
09:41:57 <lambdabot> DIDI ... is that a MARTIAN name, or, are we in ISRAEL?
09:44:41 <juhe> people, what should I use instead of Directory.getDirectoryContents (which was deprecated by ghc 6.8.1) in order to get directory content?
09:45:39 <Cale> System.Directory.getDirectoryContents ?
09:46:01 <juhe> hrm... right
09:46:04 <juhe> :), thanks
09:50:49 <Beelsebob> the primes based ones annoy me
09:50:57 <Beelsebob> there's no real logical approach you can take to them
09:51:03 <Beelsebob> because primes are so unpredictable
09:52:10 <byorgey> Beelsebob: well, there's still lots of mathematical structure you can sometimes exploit.
09:52:34 <Beelsebob> less so than most of the other sequences though
09:53:05 <byorgey> I guess so.
09:53:26 <byorgey> If you're doing them in order, the primes-based ones get much less frequent as you go.
09:53:32 <Beelsebob> indeed
09:53:42 <Beelsebob> I'm not doing them wholy in order
09:53:57 <Beelsebob> I did the first 20 or so, then started hunting out the ones that you can do in Haskell in one line
09:54:03 <Beelsebob> and now am finding ones that interest me
09:54:35 <Beelsebob> some of them are stupidly easy in haskel
09:54:37 <Beelsebob> +l
09:54:40 <Beelsebob> like problem97 = 28433 * 2 ^ 7830457+1
09:58:34 <glguy> 164 and 169 lend themselves to graceful haskell solutions
09:59:00 <ricky_clarkson> @go sieve eratosthenes haskell
09:59:03 <lambdabot> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
09:59:03 <lambdabot> Title: Sieve of Eratosthenes (Haskell) - LiteratePrograms
09:59:27 <Beelsebob> ricky_clarkson: you may want to read the Project Euler thread on haskell-cafe
09:59:38 <Beelsebob> (because the sieve is really really slow)
10:00:06 <ricky_clarkson> Is it O(n^2)?
10:00:14 <Beelsebob> something like that
10:00:50 <hpaste>  beelsebob pasted "Stolen Fast Prime list" at http://hpaste.org/4178
10:00:55 <BMeph> Is there one with Mellissa O'Neill's "original" SoE algorithm?
10:00:55 <ricky_clarkson> I liked it as an explanation of streams in sicp, but it looked slow.
10:01:37 <byorgey> @go o'neill seive
10:01:47 <lambdabot> http://www.che.rochester.edu/~myates/publications/
10:01:47 <lambdabot> Title: Yates Research Group, University of Rochester Chemical Engineering
10:01:51 <byorgey> oops
10:01:59 <ricky_clarkson> Why is it slow, the sieve?
10:02:00 <byorgey> @go o'neill sieve
10:02:00 <lambdabot> http://www.che.rochester.edu/~myates/publications/
10:02:00 <lambdabot> Title: Yates Research Group, University of Rochester Chemical Engineering
10:02:17 <Beelsebob> ricky_clarkson: because as you proceed down the list you carry an ever bigger closure to filter with
10:02:48 <byorgey> ricky_clarkson: the sieve of Eratosthenes itself is not that slow.  but the Haskell code usually passed off as the SoE, isn't.
10:02:58 <byorgey> isn't the SoE, that is.
10:03:07 <Beelsebob> indeed
10:03:13 <ricky_clarkson> I imagine it's tricky to write without side effects.
10:03:18 <byorgey> Beelsebob: that's not really why it's slow, that would just lead to more memory use.
10:03:26 <manu3000> anybody has used HDBC ? I have a very simple request that don't go through.... could it be a case of lazy IO biting me ?
10:04:20 <byorgey> the reason it's slow is that the haskell version actually checks *every* number for divisibility by all the primes, whereas the sieve just crosses off numbers that are multiples of primes
10:09:43 <hkBst> if I define     tuple x = (0, 1, x)      then it will be lazy separately for each member of the tuple?
10:10:05 <dmwit> yes
10:12:19 <Heffalump> though 0 and 1 aren't very lazy
10:12:34 <hkBst> and elements one and two will be available even though they depend on x? Or are they immediately recognized to not depend on x? Not sure it matters.
10:14:28 <manu3000> this is the query "insert into articles (id,title,body,author) values (100,'zop','pyth',15);" in sqlite3, no problem, with Haskell i get a SqlError :
10:14:33 <manu3000> SqlError {seState = "", seNativeError = 1, seErrorMsg = "step: SQL logic error or missing database"}
10:14:40 <manu3000> any idea ?
10:15:06 <byorgey> hkBst: the 0 and 1 don't depend on x at all.
10:15:42 <byorgey> > let tuple x = (0,1,x) in (\(x,y,z) -> x) $ tuple (error "this won't be evaluated.")
10:15:44 <lambdabot>  0
10:33:23 <scodil> is there a way to find out where stack overflows happen?
10:36:04 <ddarius> scodil: Compile with profiling and add the runtime option -xt or use the debugger in GHC 6.8.1
10:37:47 <scodil> ah ok. yeah -xc was giving me no help
10:37:56 <scodil> Main.main. great, thanks.
10:38:19 <byorgey> hehe
10:38:39 <byorgey> scodil: there's some interesting information on the wiki...
10:39:11 <dons> " One more tip: when using `-threaded`, never use the main thread to do the
10:39:11 <dons>  real work.  Communication between the main thread and other `forkIO`'d
10:39:11 <dons>  threads is much much slower than between two `forkIO`'d threads, because
10:39:11 <dons>  the main thread is a "bound thread" (i.e. it has an OS thread to itself).
10:39:11 <dons>  This is perhaps the main reason that turning on `-threaded` will make the
10:39:14 <dons>  version of `threadring` above go much slower.
10:39:16 <dons> "
10:39:21 <dons> that's useful to know
10:39:29 <dons> sjanssen_: ^^
10:39:46 <byorgey> scodil: http://www.haskell.org/haskellwiki/Performance
10:39:48 <lambdabot> Title: Performance - HaskellWiki
10:40:06 <byorgey> might have links to some useful things.
10:40:15 <mrd> hmmm
10:40:49 <Cale> Is there a good reason why the main thread is bound? Is that just for convenience of people using FFI libraries?
10:42:35 <dons> hmm, I guess so.
10:43:35 <mrd> will -ddump-simple-stats show any useful info about NDP rules?
10:43:51 <mrd> er, whatever that flag was
10:44:06 <dons> -ddump-simpl-stats should probably show some fusion (i think..)
10:44:29 <dons> ?users
10:44:29 <lambdabot> Maximum users seen in #haskell: 420, currently: 413 (98.3%), active: 8 (1.9%)
10:47:56 <scodil> is there a strict version of mapAccumL anywhere? or does anyone know how to make one using foldl'?
10:48:12 <scodil> i'm not sure how many $!'s to throw in and where to put them
10:48:51 <byorgey> @src mapAccumL
10:48:51 <lambdabot> mapAccumL _ s []        =  (s, [])
10:48:51 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
10:48:51 <lambdabot>    where (s', y ) = f s x
10:48:51 <lambdabot>          (s'',ys) = mapAccumL f s' xs
10:49:11 <byorgey> scodil: you want it to be strict in the accumulated state?
10:49:30 <byorgey> just put ! in front of the s parameters.
10:49:37 <byorgey> mapAccumL _ !s []  = ...
10:49:37 <scodil> i dunno. do i? I want it not to overflow the stack
10:49:58 <byorgey> I'm pretty sure that's what you'd want.
10:51:36 <scodil> i tried that. maybe its another function..
10:51:49 <scodil> so hard to tell when they all get smooshed together
10:53:02 <byorgey> yeah.  If you paste your code I (and others) could take a look.
10:56:34 <scodil> ok it looks like its not me but drawTree from Data.Tree. So i'll just not do that
11:01:38 <scodil> no i guess it is me that's overflowing it
11:02:23 <jedbrown> dons: Indeed Simon's note about -threaded is really useful.  I'm still confused why 6.6.1 -O is so much faster for me.  Is there a way to determine the build options after the build (My 6.6.1 is a binary package)?
11:02:40 <scodil> does map or concatMap ever overflow?
11:02:44 <scodil> the stack
11:05:15 <ddarius> scodil: No.
11:06:05 <ddarius> (Unless, of course, the stack is already so full that there is not enough for one iteration.)
11:09:13 <scodil> weird. ok i've got a function that transforms a big tree, another that flattens it, and a third that prints it. (show . flatten . transform) overflows but (printTree . transform) doesn't
11:09:31 <scodil> my flatten is just : branches root = root:(concatMap branches (children root))
11:11:27 <ddarius> How deep is your tree?
11:11:34 <scodil> not very
11:11:35 <scodil> its wide
11:11:45 <scodil> so the children lists are probbly doing it
11:11:53 <scodil> that's why I thought maybe it was concatMap
11:13:38 <scodil> weird now it works. I hate transient bugs
11:14:29 <scodil> would compiling with profiling information have an effect on stack overflows?
11:15:17 <SamB_XP> it influences optimization
11:15:25 <SamB_XP> and also means there's more stuff to put on the stack
11:16:03 <scodil> maybe that was it
11:18:48 <SamB_XP> the SCCs can block RULES, etc...
11:19:56 <SamB_XP> well, any cost centers, actually, I guess
11:24:31 <trontonic> The top of this table is just the top of a cylinder. Anyone knows why it results in almost invisible artifacts in yafray and horribly visible artifacts with Luxrender? http://www.3dmodellering.no/images/artifact.png
11:25:01 <bos> wrong channel
11:25:14 <trontonic> bos: oups, sorry :D
11:25:28 <bos> np
11:26:01 <trontonic> So, what's up in the world of Haskell? Is the new GHC any good?
11:26:33 <dmwit> Well, it makes speedier programs.
11:26:36 <dmwit> So that's good.
11:26:48 <SamB_XP> is *it* speedier?
11:27:03 <bos> ys
11:27:07 <bos> er, yes, it is.
11:27:25 <dmwit> Well, it's built with itself, so... =)
11:27:33 <trontonic> that's great
11:28:00 <SamB_XP> yes but sometimes, optimization algorithms take longer to run...
11:29:25 <Cale> trontonic: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/13059 :)
11:29:26 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/yum9yq
11:30:19 <pitecus> Could using lots of short lazy bytestrings use more memory than plain [Char]s?
11:30:33 <bos> pitecus: potentially.
11:30:54 <pitecus> how come?
11:31:14 <bos> lazy bytestrings have some management overhead.
11:31:41 <ddarius> They'd have to be pretty short
11:31:59 <SamB_XP> why short lazy bytestrings?
11:32:07 <shapr> @yow !
11:32:08 <lambdabot> I'm mentally OVERDRAWN!  What's that SIGNPOST up ahead?  Where's ROD
11:32:08 <lambdabot> STERLING when you really need him?
11:33:08 <pitecus> SamB_XP, I just use the lazy ones by default coz they fit better with the language but i guess in this case it was a bad choice
11:33:10 <bos> pitecus: a lazy bytestring contains both a strict bytestring (the head) and a lazy list of chunks. this is necessarily somewhat bigger than a single [Char] element.
11:33:27 <SamB_XP> bos: what if it's empty!
11:33:30 <bos> the crossover point would be small, though.
11:33:49 <bos> SamB_XP: then it's represented as Empty
11:34:10 <SamB_XP> so... a lazy list of chunks, you say?
11:34:12 <bos> but pitecus is asking about small chunks, not empty strings.
11:34:22 <SamB_XP> not another lazy bytestring for a tail?
11:34:39 <|2dman|> hey everyone -- I'm new to the haskell world, and I'm trying to get some cabal packages to work...
11:34:44 <bos> SamB_XP: it's another lazy bytestring, but that's effectively a lazy list of chunks.
11:34:49 <pitecus> what determins the size of the chunks?
11:34:53 <|2dman|> specifically, haxr, for doing XMLRPC
11:35:14 <|2dman|> but whenever I do the runghc Setup.lhs configure, I keep getting hidden package warnings
11:35:17 <bos> pitecus: they max out at 64KB. beyond that, their size depends on how you're manipulating the string.
11:35:59 <pitecus> i unpack and pack a lot since i need to do unicode aware processing
11:36:04 <|2dman|> errors, actually
11:36:11 <bos> if you read in a lazy bytestring from a socket that's sending you 1 byte at a time, you'll get 1-byte chunks.
11:36:11 <pitecus> and utf-8-string doesnt work with bytestrings
11:36:13 <|2dman|> I can't configure it, let alone proceed with the build
11:36:14 <SamB_XP> for instance, they will fragment badly if you use them to represent Fuun DNA
11:36:51 <axm> |2dman|, might be packed for a different ghc version, package names may change
11:36:56 <SamB_XP> pitecus: well, you'll get nice big chunks then...
11:37:02 <bos> pitecus: you could use compactstring, too
11:37:43 <|2dman|> axm, so how do I go about fixing that?
11:37:55 <|2dman|> axm, do I just switch to an older version of GHC?
11:37:57 <pitecus> bos, another dependency on a half finished library
11:38:08 <axm> i am not that firm either, but \msg me the config file  and i will try and help
11:38:15 <axm> no, just adjust the package
11:38:31 <axm> at least that always did it for me
11:38:56 <|2dman|> axm: ok, because the error message does tell me what packages are hidden... do I just add that to the Build-depends line?
11:39:19 <desegnis> axm: The package seems to need an update that is easy to do. Err... yes, you do exactly what you describe.
11:39:23 <axm> no, in cabal everything is hidden by default. you have to add the package in question
11:39:46 <desegnis> s/axm/|2dman|
11:39:58 <axm> err, yes, thats what you do 2d
11:40:06 <|2dman|> axm: ok, I'm trying it
11:40:13 <|2dman|> cool, it configured....
11:40:19 <axm> nice
11:41:14 <|2dman|> oh... now there's an "illegal instance declaration" error in one of the source files
11:41:19 <|2dman|> (I'm in the build stage)
11:43:49 <trontonic> Cale: thanks for the link, lookin good
11:44:36 <SamB_XP> |2dman|: details?
11:44:46 <axm> which haxr? darcs?
11:45:03 <|2dman|> no, haxr the XMLRPC library
11:45:25 <SamB_XP> apparantly haxr changes a lot between versions?
11:45:29 <|2dman|> it's     Illegal instance declaration for `XmlRpcType [(b, a)]'
11:45:40 <axm> so you got it from hackage?
11:45:42 <|2dman|>         (All instance types must be of the form (T a1 ... an)
11:45:42 <|2dman|>          where a1 ... an are distinct type *variables*
11:45:42 <|2dman|>          Use -XFlexibleInstances if you want to disable this.)
11:45:42 <|2dman|>     In the instance declaration for `XmlRpcType [(b, a)]'
11:45:44 <SamB_XP> does it say anything about what makes that illegal
11:45:51 <|2dman|> yeah, it's from hackage... there's only one version there
11:45:59 <|2dman|> (that I can see... not totally familiar with the interface yet)
11:46:18 <axm> there would be a possibly different version per darcs, thats why i asked
11:46:34 <|2dman|> oh, that's what you meant
11:46:56 <|2dman|> I could try the one from darcs...
11:47:02 <SamB_XP> there could even be versions on a website that aren't on hackage!
11:48:14 <|2dman|> no, same error from the darcs version...
11:48:26 <axm> i will need some time to hunt down the dependencies
11:48:27 <|2dman|> that one configured without having to modify the cabal file -- but it has the same "version"
11:49:06 <|2dman|> I appreciate any help you can provide -- I'm kind of at a loss for how to fix this yet
11:54:23 <aboyousif> hello haskellers .. i use ubuntu and i see many options to use haskell (ghc, hugs ...etc ) from where should i start
11:54:32 <mar77a> ghc
11:54:40 <mar77a> which comes with ghci
11:55:28 <axm> |2dman|, compiled here using the darcs haxr, hackage mtl, ubuntu haxml and ghc 6.61
11:55:49 <aboyousif> mar77a: thanks alot ..
11:55:50 <hpaste>  gwern pasted "metaplug problems" at http://hpaste.org/4179
11:55:52 <axm> so my first guess would be a version conflict
11:55:57 <|2dman|> axm: could it be that I'm using 6.8.1?
11:56:27 <jedbrown> |2dman|: did you try putting 'FlexibleInstances' in the 'Extensions:' field?
11:56:40 <gwern> I've been having problems compiling metaplug and hs-plugins with recent ghc and cabal. anyone have any ideas here? I've assembled some of the relevant type sigs but I can't make heads or tails of it
11:56:40 <|2dman|> jedbrown: ah, is *that* where I put it... cool, I'll try that!
11:57:00 <jedbrown> |2dman|: or the '-fglasgow-exts' sledgehammer in 'ghc-options:'
11:58:20 <|2dman|> ok, adding the FlexibleInstances to Extensions: worked for that file, but I hit another error after that...
11:58:27 <|2dman|> so, the glasgow-exts worked for the rest of it
11:58:30 <|2dman|> thanks!
11:58:54 <|2dman|> what do these extensions mean?  Are they places where ghc is not "true" haskell?
11:59:16 <SamB_XP> well, not haskell 98, anyway
11:59:23 <dons> it implements haskell 98, plus newer extensions
11:59:28 <gwern> not haskell '98, yes. alot of them will be in the next haskell standard
11:59:36 <augustss> hi
11:59:41 <|2dman|> oh, okay -- developments *since* the standard
11:59:49 <gwern> dons: is plugins supposed to be broken right now?
12:00:01 <|2dman|> cool, I'll have to note that for the future
12:00:06 <jedbrown> |2dman|: if you are working with the the darcs version, you could send the maintainer your changes: darcs record -m 'Fixed cabal deps.' && darcs send
12:00:22 <|2dman|> jedbrown: cool, thanks
12:00:45 <axm> so it would work with 6.61 in that version but not 6.8.1?
12:00:59 <dons> gwern: it works on 6.6.x only
12:01:12 <SamB_XP> dons: when is this problem going to stop?
12:01:49 <dons> when .hi files and package.confs stop changing, or someone implements hs-plugins api on top of ghc-api
12:01:50 <hpaste>  redemption annotated "I get an error i don't understand, please explain, so i can learn! tia!" with "still an error..." at http://hpaste.org/4175#a3
12:01:55 <|2dman|> axm: well, you tested on 6.61, and I on 6.8.1 -- I assume that you didn't have to make any changes to the cabal file?
12:02:01 <axm> nope
12:02:33 <axm> but it is kinda hard for me to see why there could be a difference with interpreting options to differ from the standard
12:03:03 <axm> it is not that it is a different standard or the options are new in 6.8
12:03:22 <|2dman|> axm: I just compiled 6.8.1 this morning
12:03:31 <|2dman|> axm: hot off the presses, as it were
12:07:19 <jedbrown> dons: This reaction is good, imho: http://cmssphere.blogspot.com/2007/11/parallelizing-haskell.html
12:07:19 <lambdabot> Title: The World of Software Development | Computing, Mischief, and Society: Paralleliz ...
12:07:34 <Cale> |2dman|: generally Haskell standards standardise safe features which have already been implemented, and the real development of the language is always far ahead of that.
12:07:48 <jedbrown> dons: Now to answer "can stackless python..." with a definitive no!
12:10:46 <dropdrive> Is it possible to get ghc to tell me the inferred types of functions in my source code?
12:10:49 <|2dman|> Cale: I'm okay with that -- I'm coming from the Common Lisp and Scheme world, so I don't think it's all that uncommon
12:11:46 <ddarius> |2dman|: There's a lot more consistency between implementations of Haskell than there is in the Scheme/CL world.
12:11:57 <TSC> dropdrive: You can load the source in ghci and ask it
12:12:28 <TSC> With -Wall, ghc will say "no type declaration, but here's what I reckon it is: ..."
12:13:14 <dropdrive> TSC: Thanks.
12:13:43 <TSC> dropdrive: You're welcome.  People have automated it before, so it's possible in one way or another.
12:16:47 <gwern> you know, I think it was my bug which asked for -Wall to report inferred types. it really does make life easier
12:17:56 <TSC> Yes, it was a pleasant surprise to see that
12:23:16 <augustss> Now all we need is the old hbc feature that splices the type signatures back into the source file. :)
12:24:01 <wli> That'd be awesome.
12:24:07 * ddarius would never use it.
12:24:09 * SamB_XP twitches
12:24:29 <wli> I liked defining data structures in the repl, too.
12:24:33 <Heffalump> hbc edited your source for you?
12:24:38 <Heffalump> scary
12:25:01 <SamB_XP> did it have an "undo" feature?
12:26:30 <Cale> A compiler seems more qualified to be editing source code than an IDE, at least to me :)
12:26:44 <SamB_XP> so?
12:27:01 * ddarius doesn't use IDEs.
12:27:06 <SamB_XP> I don't see your point
12:27:26 <Cale> Wrong button :)
12:27:38 <Cale> I suppose my point is that it's not all that scary?
12:27:59 <SamB_XP> why bring up IDEs editing source code?
12:28:39 <Cale> Well, people have IDEs which do that and seem to like them even.
12:29:00 <Cale> (automatic program transformation stuff)
12:29:16 <SamB_XP> do I look like one of those people?
12:29:24 <SamB_XP> also, do the IDEs have "undo"?
12:29:26 <Cale> It wasn't really directed at you.
12:29:42 <SamB_XP> does anyone else here?
12:30:13 <axm> i do, at least for java
12:30:21 <Cale> I don't see what's so wrong with a compiler inserting inferred type signatures automatically on request.
12:30:33 <Cale> I'm pretty sure that it's not so hard to get that right.
12:30:49 <SamB_XP> I still think I'd want an "undo"...
12:31:10 <Cale> You could have it make a backup of course :)
12:34:40 <aboyousif> well i have a question . shall i move to a new editor or vim still suitable me for learning Haskell ?
12:35:21 <jedbrown> aboyousif: Oh no!  You'll have to upgrade to emacs ;-)
12:35:34 <aboyousif> jedbrown:  no way :)
12:36:17 <Cale> aboyousif: Vim is fine, I use it all the time
12:36:39 <Cale> aboyousif: anything with syntax colouring which can expand tabs into spaces should do fine.
12:37:00 <aboyousif> Cale: cool
12:37:36 <dropdrive> Cale: To sort of agree with you, I think it'd be nice to have inferred type signatures placed into a comment right before the function.
12:37:41 <Cale> (It also helps a lot to be able to auto indent to the same number of spaces as the previous line, which is again a really common editor feature)
12:38:15 <SamB_XP> yes, even the editor for visual basic can do THAT
12:38:23 <aboyousif> Cale: is it like in python ?
12:38:49 <SamB_XP> aboyousif: Haskell's indentation is more intricate
12:39:15 <SamB_XP> well, that is, we don't just indent blocks by four spaces each time ;-)
12:39:33 <Cale> aboyousif: It's similar.
12:39:46 <aboyousif> SamB_XP: interesting :) ..
12:39:49 <Cale> One nice thing when you're starting out is that layout is optional.
12:40:08 <Cale> If you include semicolons, and/or braces, layout will be ignored
12:45:13 <dibblego> what is the advice when it comes to Dr. Harrop and his trolling on LanguageX mailing list about Haskell? I've chosen to ignore despite the ever increasing amount of disinformation
12:45:43 <SamB_XP> write it up on uncyclopedia?
12:46:28 <dibblego> well, the Scala list is full of noobs, so it just bothers me that they may have been tainted with bullshit
12:47:10 <dibblego> it's unfair to beginners imo
12:47:19 * SamB_XP reminds everyone that uncyclopedia is one of the largest repositories of disinformation known to man
12:47:34 * dibblego shivers the annoyance off
12:49:06 <ricky_clarkson> I haven't seen Harrop on the Scala list for a while.
12:49:25 <dibblego> he's spouting the usual 'Haskell can't perform because of laziness'
12:49:35 <dibblego> but mixing his logic up
12:49:50 <dibblego> so really it's 'Haskell is impractical' depending on which retort you use
12:50:06 <ricky_clarkson> Hmm, gmail says he hasn't posted this month.
12:50:24 <dibblego> scala-lounge list
12:50:29 <ricky_clarkson> Ah.
12:50:45 <Cale> I think public mockery might work.
12:51:22 <dibblego> a lot of effort just to make an idiot look more like an idiot though
12:52:18 <ricky_clarkson> Don't taint yourself by worrying about it.
12:55:02 <dibblego> you think I should not respond?
12:55:08 <SamB_XP> they could look at his average rating of 1 star...
12:55:28 <dibblego> what rating is that?
12:56:17 <ricky_clarkson> google groups has ratings
12:56:20 <SamB_XP> I assume this is your doctor harrop? http://groups.google.com/groups/profile?hl=en&enc_user=I_YUthUAAACWD_8VFKtRU42NeunWF-drfMq7BcOOnMpM9MYZ86CqoA
12:56:22 <lambdabot> Title: Google Groups, http://tinyurl.com/272wqg
12:56:50 <dibblego> he even cites a blog post that supports my claim, because the author admits to having made a mistake
12:57:01 <dmwit> > (++ "!!") . (>> "AA") $ "Hello world !"
12:57:05 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
12:57:32 <ricky_clarkson> dmwit: Are you looking at the uncyclopedia article?
12:57:45 <dibblego> ah google groups
12:57:54 <dmwit> Yeah, I just wanted to make sure my evaluation matched \bot's. =)
12:58:19 <bos> harrop is just a troll.
12:58:49 <ricky_clarkson> http://esoteric.voxelperfect.net/wiki/AAAAAAAAAAAAAA%21%21%21%21
12:58:51 <lambdabot> Title: AAAAAAAAAAAAAA!!!! - Esolang
12:59:38 <dibblego> bos, he asked me about suffix trees in Haskell and I pointed to your implementation
12:59:57 <SamB_XP> I think harrop may actually make non-trolling posts
13:00:12 <SamB_XP> but he does seem to be an infamous troll
13:01:11 <ricky_clarkson> I think correcting him would be a useless use of time.
13:01:21 <dibblego> I'm going to try one more time
13:01:26 * dibblego cringes
13:02:48 <SamB_XP> what? debian bugs are on google groups?
13:07:11 <ddarius> @let shuffle s t = (head s*head t) : zipWith (+) (shuffle (tail s) t) (shuffle s (tail t))
13:07:24 <lambdabot> Defined.
13:07:53 <ddarius> > shuffle (repeat 1) (1:repeat 0)
13:07:57 <lambdabot> Terminated
13:08:05 <xpika> msg lambdabot > L.shuffle "hello" "world"
13:08:58 <acangiano> dons: http://antoniocangiano.com/2007/11/30/more-on-fibonacci-oops-sorry-lisp-haskell-runs-it-5-times-faster/
13:08:59 <lambdabot> Title: More on Fibonacci. Oops, Sorry Lisp&#8230; Haskell runs it 5 times faster | Zen  ..., http://tinyurl.com/332v86
13:09:15 <ddarius> Oh for the love of Pete.
13:09:24 <acangiano> ddarius: lol
13:12:00 <dons> acangiano: :)
13:12:10 <dons> acangiano: i blame you for all this
13:12:21 <acangiano> dons: eheh
13:12:45 <dons> acangiano: oh, you say "not new", but i think the post about `par` was rather new stuff
13:12:58 <dons> i'm not aware of any other posts about using `par` before
13:12:58 <acangiano> dons: I put some more gasoline on the fire. The more exposure to Haskell, the better. :-P
13:13:05 <dons> i figure so, too.
13:14:08 <acangiano> dons: oh sorry about that, I didn't mean to say that your implementation is not new stuff, but rather that the too messages are not new (1) Haskell fast 2) Haskell is easy to parallelize)
13:14:08 <dons> acangiano: btw, did you try the par version on multiple cores (-threaded) ?
13:14:15 <dibblego> acangiano, cheers, that's going in my "You're Wrong Dr. Harrop" email
13:14:18 <dons> heh
13:14:27 <dons> oh noes, not jon.
13:14:39 <dibblego> he's infected the Scala list
13:15:15 <bos> i wonder why he's got it in for haskell. did the h98 committee sneak into his house and smother a kitten?
13:15:24 <acangiano> dons: the results at the end show the time for the non parallel version and for the mutiple cores one with /threaded
13:15:29 <dibblego> bos, I'll ask him
13:15:30 <acangiano> -threaded
13:15:43 <dons> acangiano: and +RTS -N2 or something like it?
13:15:51 <dons> you did get speedups with -N2 over -N1 ?
13:15:53 <ddarius> bos: Haskell /= F#/O'Caml
13:15:54 <Heffalump> bos: cos he has a O'Caml/F# consultancy?
13:16:09 <dons> ah yes, acangiano
13:16:10 <dons> excellent
13:16:32 <acangiano> dons: yes, it went from 77 to 52 which is excellent
13:16:36 <dons> Heffalump: yeah, if he's selling ocaml support/books, i guess he needs to drive up users for them
13:16:43 <dons> acangiano: yeah, pretty happy with that.
13:16:55 <dons> `par` needs more stress testing , i think
13:17:01 <dons> i bet sparking could be made cheaper
13:17:36 <dons> if all people remember of this thing in a year's time is `par` , i'd be happy with that result
13:17:41 <Heffalump> though perhaps the H98 committee did smother his kitten. That augustss bloke is clearly suspicious.
13:18:03 <dons> acangiano: i'm not convinced the lisp program uses 2 cores
13:18:11 <SamB_XP> augustss: why didn't you tell me you were suspicious
13:18:15 <bos> par's been around for a long, long time.
13:18:18 <acangiano> dons: it really pisses me off how people don't understand that they can't claim that their X language is faster because they are using an algorithmically more efficient snippet. They were comparing our O(phi^n) with their O(n), and say "ahah see Lisp is faster"
13:18:20 <dons> the guy asserted it, but gave no reason for us to think sbcl does magic paralleisation
13:18:26 <acangiano> dons: I actually saw that
13:18:43 <acangiano> dons: I monitored the process for Lisp. It uses both cores in fact.
13:18:47 <dons> how?
13:19:10 <dons> its a linear algorithm, so is the sbcl maybe running the GC in another thread? that's about all i could imagine it doing
13:19:14 <dons> and that seems unlikely.
13:19:19 <ddarius> > take 3 $ shuffle (repeat 1) (1:repeat 0)
13:19:20 <lambdabot>  [1,1,1]
13:19:23 <dons> perhaps the os scheduler's just moving it around
13:19:28 <SamB_XP> would that be beneficial?
13:19:30 <acangiano> dons: could be
13:19:30 <ddarius> > take 10 $ shuffle (repeat 1) (1:repeat 0)
13:19:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
13:19:46 <ddarius> > take 10 $ shuffle (repeat 1) (repeat 1)
13:19:46 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
13:19:50 <dons> and i doubt sbcl has a parallel garbage collector anyway
13:20:02 <Heffalump> perhaps the compiler transforms it to exponentiation (which I'd guess can be parallelised)
13:20:46 <dons> do we have any docs, or other evidence, that the sbcl code magically parallelisaes though? i've never seen this asserted before, so it seems very dubious
13:21:08 <ddarius> > take 10 $ shuffle (repeat 1) (0:1:repeat 0)
13:21:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
13:21:16 <Heffalump> I wasn't serious about it magically transforming it to exponentiation
13:21:20 <dons> :)
13:21:34 <byorgey> ddarius: that's an interesting function there.  what's it for?
13:21:39 <dons> so was this whole par/fibonacci storm useful in the end?
13:21:42 <acangiano> dons: you may be right about sbcl
13:21:45 <SamB_XP> Heffalump: do you have any references re: parallel exponentiation?
13:21:46 <dons> or did it do more harm than good?
13:21:58 <acangiano> dons: it's useful
13:21:59 <dons> bos: what do you think?
13:22:06 <bos> acangiano: i find it unlikely that sbcl parallelised your code.
13:22:15 <Heffalump> SamB_XP: no, I was just guessing.
13:22:16 <SamB_XP> dons: is it faster than doing it sequentially?
13:22:31 <Heffalump> but you could calculate the powers of 2 on one thread, and combine them on another
13:22:37 <dons> SamB_XP: yeah, `par` scaled pretty well.
13:22:55 <acangiano> bos: I start to suspect as much
13:23:16 <ddarius> byorgey: It's the shuffle product of two streams,  (shuffle s t)(n) = Sum_{k=0}^n (n `choose` k) * s!!(n-k) * t!!k
13:24:26 <acangiano> dons, bos: let me change a little the text to include this
13:24:26 <bos> dons: i have no opinion.
13:24:35 <byorgey> ddarius: I see, interesting.
13:24:54 <ddarius> @let shuffleInverse s = let r = recip (head s) : map negate (shuffle (tail s) (shuffle r r)) in r
13:25:07 <lambdabot> Defined.
13:25:48 <dons> ?users
13:25:48 <lambdabot> Maximum users seen in #haskell: 422, currently: 422 (100.0%), active: 12 (2.8%)
13:25:50 <ddarius> > take 10 (shuffle (repeat 1) (shuffleInverse (repeat 1)))
13:25:52 <lambdabot>  [1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
13:26:00 <dons> ah. see, maybe that's the result we can take away.
13:26:06 <ddarius> Excellent
13:26:50 <dons> and people are looking at `par` some more, which will hopefully lead to perf improvements in code using it
13:26:59 <dons> as it gets tested some more
13:27:29 <dibblego> well, we have a Haskell noob as a result of that thread anyway
13:27:52 <ddarius> @let sqrtStream s = let r = sqrt (head s) : map (recip 2) (shuffle (shuffleInverse r) (tail s))
13:27:53 <lambdabot>  Parse error
13:27:57 <ddarius> @let sqrtStream s = let r = sqrt (head s) : map (recip 2) (shuffle (shuffleInverse r) (tail s)) in r
13:27:58 <lambdabot> Defined.
13:28:26 <ddarius> > take 10 $ shuffle (sqrtStream (repeat 1)) (sqrtStream (repeat 1))
13:28:27 <lambdabot>   add an instance declaration for (Fractional (a -> a))
13:28:37 <ddarius> :t sqrtStream
13:28:37 <lambdabot> Not in scope: `sqrtStream'
13:28:45 <dons> dibblego: and several people trying `par`. there's some mindshare we've got now for multicore programming, that's more concrete than previously
13:29:00 <ddarius> > 3
13:29:01 <lambdabot>  3
13:29:07 <dibblego> dons, yeah, I was referring to the Harrop thread that I was whining about earlier
13:29:14 <acangiano> dons, bos: fixed
13:29:36 <conal> @ty map (recip 2)
13:29:37 <lambdabot> forall a b. (Fractional (a -> b)) => [a] -> [b]
13:29:37 <dibblego> dons, someone has been emailing me privately for advice and direction and they are starting off with YAHT
13:29:56 <dons> that's good to know. i've had a few similar emails
13:30:03 <ddarius> Doh.
13:30:14 <ddarius> @let sqrtStream s = let r = sqrt (head s) : map (/ 2) (shuffle (shuffleInverse r) (tail s)) in r
13:30:14 <lambdabot> <local>:4:0:     Warning: Pattern match(es) are overlapped              In th...
13:30:18 <dons> i guess any news is good news, when you're just trying to raise the profile of a technology :)
13:30:20 <ddarius> @undefine
13:30:21 <lambdabot> Undefined.
13:30:30 <ddarius> @let shuffle s t = (head s*head t) : zipWith (+) (shuffle (tail s) t) (shuffle s (tail t))
13:30:30 <lambdabot> Defined.
13:30:36 <ddarius> @let shuffleInverse s = let r = recip (head s) : map negate (shuffle (tail s) (shuffle r r)) in r
13:30:37 <lambdabot> Defined.
13:30:39 * byorgey watches ddarius with curiosity
13:30:42 <ddarius> @let sqrtStream s = let r = sqrt (head s) : map (/ 2) (shuffle (shuffleInverse r) (tail s)) in r
13:30:42 <lambdabot> Defined.
13:30:57 <ddarius> > take 10 $ sqrtStream (1:repeat 0)
13:31:01 <lambdabot>  [1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
13:31:28 <ddarius> > take 10 $ shuffle (sqrtStream (repeat 1)) (sqrtStream (repeat 1))
13:31:29 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
13:31:45 <ddarius> > take 10 $ sqrtStream (1:1:repeat 0)
13:31:45 <lambdabot>  [1.0,0.5,-0.25,0.375,-0.9375,3.28125,-14.765625,81.2109375,-527.87109375,395...
13:32:59 <byorgey> ddarius: where can I read about shuffle product?
13:34:07 <ddarius> byorgey: Any calculus book... the trick is the correspondence between calculus and streams, see http://www.cwi.nl/ftp/CWIreports/SEN/SEN-E0305.pdf
13:34:25 <ddarius> Or for more and links to abstracts: http://homepages.cwi.nl/~janr/papers/\
13:34:29 <ddarius> -\
13:34:36 <byorgey> ddarius: i.e. Taylor series?
13:35:20 <byorgey> ddarius: cool, thanks for the links
13:35:31 <bwx> How do I write a function to remove redundant whitespace from a string? (a sequence of one or more space/newline/tab chars)
13:35:38 <ddarius> byorgey: Yes and the product rule for differentiation.  tail (shuffle s t) = shuffle (tail s) t ^+^ shuffle s (tail t) where (^+^) = zipWith (+)
13:35:51 <dons> > filter (not.isSpace) "foo is bar"
13:35:52 <lambdabot>  "fooisbar"
13:36:25 <byorgey> ddarius: oh, right, now I see.
13:37:24 <ddarius> > take 10 $ zipWith (\(a,n) -> a/(fromIntegral (product n))) (sqrtStream (1:1:repeat 0)) [0..]
13:37:26 <lambdabot>        add an instance declaration for (Floating (b -> c, [a]))
13:37:50 <ddarius> > take 10 $ zipWith (\a n -> a/(fromIntegral (product n))) (sqrtStream (1:1:repeat 0)) [0..]
13:37:51 <lambdabot>   add an instance declaration for (Num [a])
13:37:51 <lambdabot>     In the expression: 0
13:38:02 <bwx> dons, oops sorry i meant compress a sequence of whitespace into only a single space character
13:38:20 <dons> oh filter duplicates? you can roll a loop by hand for that
13:38:24 <dons> dropWhile
13:39:00 <ddarius> > scanl (*) [1..]
13:39:00 <lambdabot>   add an instance declaration for (Num [t])
13:39:11 <ddarius> > scanl (*) 1 [1..]
13:39:11 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
13:39:35 <ddarius> > take 10 $ zipWith (\a fn -> a/fromIntegral fn) (sqrtStream (1:1:repeat 0)) (scanl (*) 1 [1..])
13:39:35 <lambdabot>  [1.0,0.5,-0.125,6.25e-2,-3.90625e-2,2.734375e-2,-2.05078125e-2,1.611328125e-...
13:40:00 <mrd> > unwords $ words "foo    is   bar"
13:40:00 <lambdabot>  "foo is bar"
13:40:50 <bwx> mrd: cool, where can i read the source for the words function?
13:41:02 <dons> ?src words
13:41:02 <lambdabot> words s = case dropWhile isSpace s of
13:41:02 <lambdabot>     "" -> []
13:41:02 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:41:14 <dons> good thinking, mrd
13:42:05 <hpaste>  vvv pasted "2 GHCs => can't resolve Cabal dependencies" at http://hpaste.org/4182
13:42:14 <sethk> dons, I got the regex-base built, but I'm having a problem with regex-posix.  It is looking for Data.ByteString.Base.  bytestring is in the Build-Depends list
13:42:42 <bakert> dons: if you were going to write an irc bot would you use that tutorial you wrote as the basis, or lambdabot, or start again?
13:42:44 <bos> sethk: i think you need to be building from a newer branch, maybe? the regex repositories are a mess
13:42:56 <dons> bakert: i'd start with the irc tut
13:43:02 <dons> lambdabot is too complex.
13:43:03 <Heffalump> vvv: what does which runhaskell report?
13:43:08 <sethk> bos, I'm using 0.92; I've not found a newer set.
13:43:11 <bakert> cool, i will start there.
13:43:16 <bos> the general level of findability of darcs repos on haskell.org is epsilon, unfortunately.
13:43:20 <Heffalump> I suspect it's picking up the system one, since I think ghc doesn't have runhaskell by default.
13:43:21 <bakert> been tweaking it a little already
13:43:42 <sethk> bos, I found the tarballs on hackage.  Do you think that newer code exists somewhere?
13:43:44 <dons> sethk: .Base is from an old bytestring. the one's that work are the regex-base-0.72.0.1, regex-compat-0.71, regex-posix-0.72.0.2
13:43:45 <Heffalump> oh, perhaps it does
13:43:47 <dons> ones
13:44:14 <vvv> vvv@fun:~/src/xmonad$ which runhaskell
13:44:14 <sethk> dons, You want me to use the older ones?
13:44:14 <vvv> /home/vvv/bin/runhaskell
13:44:14 <vvv> vvv@fun:~/src/xmonad$ ls -l `!!`
13:44:14 <vvv> ls -l `which runhaskell `
13:44:17 <vvv> -rwxr-xr-x 1 vvv vvv 1975540 2007-11-30 17:19 /home/vvv/bin/runhaskell
13:44:21 <vvv>  
13:44:47 <bwx> ok, what i really need is to split a string into parts separated by two(or more) newline characters: "hello\n\nworld. foo\nbar\n\n\nbork" -> ["hello", "world. foo\nbar", "bork"]
13:44:50 <dons> sethk: they're the only ones that build with new bytestring and 6.8. i'm not sure i want you to use them though :)
13:45:24 <sethk> dons, I'll try to fix it.  I was able to build regex-base by adding bytestring (and a few other things) to Build-Depends, and removing -Werror
13:45:48 <Heffalump> vvv: hmm, dunno then
13:46:04 <Heffalump> I use two ghcs and haven't had any problems, including with xmonad.
13:46:23 <Heffalump> or rather, I did have problems, but only when using sudo to invoke runhaskell Setup.hs install
13:46:32 <Heffalump> at which point the wrong ghc got picked up and all hell broke loose
13:46:54 <vvv> Heffalump: and how did you configure GHC?
13:47:07 <dikini> dons: thanks for the holyshmoly - I got asked about help with haskell due to that, which is funny, since I'm kinda clueless myself
13:47:13 <Heffalump> I just installed from the binary tarball
13:47:29 <vvv> I did `sh boot; ./configure --prefix=$HOME; ...'
13:47:35 <vvv> Heffalump: I see...
13:48:04 <Heffalump> I had the same configure line, though.
13:48:14 <acangiano> dons: the Lisp guys on Reddit killed it fast: http://programming.reddit.com/info/61uhj/comments
13:48:26 <vvv> hey, are there any Cabal gurus in the house?  http://hpaste.org/4182
13:49:13 <dons> dikini: oh, cool.
13:49:24 <dons> i'm glad it attracted some interest! :)
13:49:28 <dons> ?users
13:49:28 <lambdabot> Maximum users seen in #haskell: 424, currently: 424 (100.0%), active: 20 (4.7%)
13:49:32 <dons> look, new high score :)
13:49:40 <dons> i wonder if that's related :)
13:50:17 <Heffalump> ooh
13:50:26 * Heffalump sends out psychic messages to draw more people in
13:50:29 <dons> :)
13:50:30 <vvv> dons: forget PR, help me repair my xmonad rebuild cycle :)
13:50:36 <acangiano> dons: hopes so
13:50:44 <dons> vvv, ah. its much simpler now, though.
13:51:17 <acangiano> dons: Haskell needs some PR :-P I'm going to link to the channel in my post.
13:51:24 <dons> :)
13:51:28 <dikini> can somebody recommend online texts on categories?
13:51:36 <Mitar> how can i make in haskell an anagram finding program? so that i would give it a list of letters and a list of words and it would find all combinations of all words that are from those letters
13:51:58 <Plareplane> you'd need a dictionary
13:52:18 <Plareplane> oh i can't read, ignore me
13:52:24 <fasta> Mitar: the same as you would do on paper, it would just work faster.
13:52:33 <vvv> dons: this `small_base' flag is needed for the latest GHC, right?
13:52:35 <fasta> ^^
13:53:16 <Mitar> i would like to automatize it ... probably checking all possible combinations of words is not really  a good idea to go for it :-)
13:54:30 <Toxaris> Mitar: why not?
13:54:41 <TSC> Doing it the naive way is probably fast enough
13:54:50 <dons> vvv: nope, it will use that by default, afaik.
13:54:51 <Mitar> because if i use it on a english dictionary ...
13:54:51 <fasta> Mitar: think about the problem more as you don't understand it yet
13:55:02 <ddarius> dikini: What do you know mathematics/computer science-wise?  What do you want to get out of it?
13:55:03 <bwx> sort the letters of each word in the dictionary. then sort these sorted words
13:55:05 <dons> vvv: i'm not sure why base is getting screwed up -- what base version do you havE?
13:55:32 <sethk> dons, I fixed it.  It had a qualified inport of unsafeUseAsCString from base.  I substituted unsafe for base (since that's where I found unsafeUseAsCString) and it builds
13:57:18 <vvv> $ ghc-pkg list base
13:57:18 <vvv> /home/vvv/lib/ghc-6.9.20071130/package.conf:
13:57:18 <vvv>     base-3.0
13:57:18 <vvv>  
13:57:42 <dons> ok, so base >= 3.0
13:58:17 <dikini> ddarius: that is a tough question - I'm ok with discrete maths/set theory and related - my biggest problem with that is language - my studies were not in english so translation of some terms is slow
13:59:03 <vvv> yes (and I've hpasted it)
14:00:25 <ddarius> dikini: Hmm.  Well for a general recommendation, I think http://www.let.uu.nl/esslli/Courses/barr-wells.html is a good intro and an enjoyable read especially for people with a computer science background.
14:00:30 <dikini> ddarius: fairly versed, read played with lambda calculus variants and not afraid to dive (starts sounding like a job interview)
14:00:34 <lambdabot> Title: Courses: Barr / Wells
14:00:49 <dikini> ddarius: cool, thanks
14:02:15 <ddarius> dikini: What are you looking to get out of category theory?  Just generally interested? you want to use it for computer science problems? which? try to apply it to programming? another field altogether (e.g. algebraic topology)?
14:02:27 <grahamhutton> dikini: it's not an online text, but personally I would highly recommend Steve Awodey's recent book on category theory
14:02:28 <dikini> modelling and programming
14:03:31 <grahamhutton> in my experience the online material on categories isn't worth all that much, and often does more to confuse than illuminate
14:03:34 <dikini> I'm trying to prove a bunch of properties of a 'class' of optimisation algorithms, I have an intuition about them, but structure will help
14:03:48 <lQg> how do i do one of those on the fly lambda functions?
14:04:05 <lQg>  /x -> x*2 or some such
14:04:08 <dikini> grahamhutton: thanks, I really like the approach in your book :)
14:04:12 <Heffalump> \x -> x*2
14:04:18 <lQg> cool thanks :)
14:04:42 <ddarius> dikini: http://www.cs.le.ac.uk/people/akurz/books.html has a lot of links.  For language semantics, Categories, Types, and Structures is okay, for turning CT into code there's Computational Category Theory
14:04:42 <lambdabot> Title: Electronically Available Books and Other Sources (mainly Category Theory)
14:05:20 <bwx> is there something like the concat function, that lets me specify an element to be placed between each concatenation?
14:05:39 <ddarius> bwx: concat . intersperse foo
14:05:43 <fasta> What's the expected speedup/slowdown to go from Intel Core2 Duo to PS3 for an Int based code with lots of memory accesses (which might be parallel) using GHC?
14:06:00 <lQg> how do i convert int to string?
14:06:02 <fasta> for Int*
14:06:05 <lQg> show?
14:06:08 <fasta> lQg: yes
14:06:11 <lQg> kk
14:06:17 <ddarius> dikini: http://www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html Ignoring the enrichment aspects, this has tons of good identities and constructs that makes actually "doing" category theory much easier.
14:06:18 <lambdabot> Title: Basic Concepts of Enriched Category Theory
14:06:33 <byorgey> bwx: in the most recent version of the libraries, it's called intercalate
14:06:52 <ddarius> @src intercalate
14:06:52 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:07:10 <byorgey> which (much to my surprise) is a real word.
14:07:13 <ddarius> > concat . intersperse "," $ words "one two three"
14:07:14 <lambdabot>  "one,two,three"
14:07:27 <ddarius> > intercalate "," $ words "one two three"
14:07:27 <lambdabot>   Not in scope: `intercalate'
14:08:18 <dikini> hmm, now I understand the statement - asking a question on #haskell expecting a drop- you get a waterfall
14:08:28 <dikini> thanks :)
14:08:42 <byorgey> lQg: more generally, 'show' can be used to convert anything "showable" (i.e. which is an instance of Show) into a String.  that includes most primitive types.
14:09:18 <fasta> :t show
14:09:19 <lambdabot> forall a. (Show a) => a -> String
14:09:21 <bwx> @src intersperse
14:09:22 <lambdabot> intersperse _   []     = []
14:09:22 <lambdabot> intersperse _   [x]    = [x]
14:09:22 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:10:54 <ddarius> > let notQuiteIntersperse sep = foldr (\x xs -> x:sep:xs) [] in notQuiteIntersperse "," $ words "one two three"
14:10:55 <lambdabot>  ["one",",","two",",","three",","]
14:11:04 <ddarius> > let notQuiteIntersperse sep = foldr (\x xs -> x:sep:xs) [] in concat . notQuiteIntersperse "," $ words "one two three"
14:11:05 <lambdabot>  "one,two,three,"
14:11:52 <sjanssen_> @pl (\x xs -> x:sep:xs)
14:11:52 <lambdabot> (. (sep :)) . (:)
14:12:24 <ddarius> Unfortunately no \x -> (x:sep:))
14:15:49 <byorgey> :t \x -> ((x:sep):)
14:15:50 <lambdabot>     Couldn't match expected type `[a]'
14:15:50 <lambdabot>            against inferred type `[Doc] -> Doc'
14:15:50 <lambdabot>     In the second argument of `(:)', namely `sep'
14:15:52 <shachaf> @ty (\x -> (x:) . (sep:))
14:15:53 <lambdabot> ([Doc] -> Doc) -> [[Doc] -> Doc] -> [[Doc] -> Doc]
14:16:01 <byorgey> oh, right
14:16:05 <byorgey> duh
14:16:20 <shachaf> byorgey: Are you thinking of (++)? :-)
14:16:35 <byorgey> shachaf: apparently I wasn't thinking of anything. =P
14:17:39 <shachaf> @ty \x -> ([x,sep] ++)
14:17:39 <lambdabot> ([Doc] -> Doc) -> [[Doc] -> Doc] -> [[Doc] -> Doc]
14:17:52 <byorgey> @type sep
14:17:52 <lambdabot> [Doc] -> Doc
14:17:56 <byorgey> hehe
14:18:07 <shachaf> @index sep
14:18:09 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
14:18:16 <byorgey> that's what I figured
14:18:26 <byorgey> @type \x -> ([x,?sep] ++)
14:18:27 <lambdabot> forall a. (?sep::a) => a -> [a] -> [a]
14:19:29 <byorgey> implicit parameters are bizarre.
14:20:51 <hpaste>  vvv annotated "2 GHCs => can't resolve Cabal dependencies" with "(no title)" at http://hpaste.org/4182#a1
14:21:50 <fasta> vvv: remove --user and it will work
14:22:02 <fasta> vvv: I had the same issue a few days ago with a different package.
14:22:18 <vvv> fasta: no
14:22:35 <fasta> vvv: more bits please
14:23:32 <fasta> vvv: ...
14:24:23 <dmwit> > logBase 2 1968969056
14:24:24 <lambdabot>  30.8747932922414
14:25:00 <dmwit> It's *like* underflow, but isn't, really.
14:25:02 <dmwit> ?users
14:25:02 <lambdabot> Maximum users seen in #haskell: 424, currently: 413 (97.4%), active: 17 (4.1%)
14:25:33 <hpaste>  vvv annotated "2 GHCs => can't resolve Cabal dependencies" with "(no title)" at http://hpaste.org/4182#a2
14:25:45 <vvv> fasta: http://hpaste.org/4182#a2
14:26:38 <fasta> vvv: what are all the dependencies?
14:26:59 <fasta> vvv: maybe you simply don't have mtl.
14:27:16 <fasta> vvv: never mind
14:27:19 <fasta> vvv: you do have mtl
14:27:30 <vvv> :)
14:28:10 <dmwit> What does "2 GHCs" mean?
14:28:28 <fasta> dmwit: 2 different GHC installations.
14:28:34 <fasta> (probably)
14:28:37 <dmwit> Have you tried specifying the version of GHC to runhaskell?
14:28:48 <fasta> dmwit: the one in $PATH is being used
14:29:12 <dmwit> Is that good or bad? =P
14:29:15 <fasta> vvv: add -v3
14:29:21 <fasta> dmwit: that's good
14:29:34 <ddarius> :t Data.Map.lookup
14:29:35 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
14:30:16 <dmwit> > lookup 0 empty :: [Int]
14:30:17 <lambdabot> Terminated
14:30:18 <EvilTerran> hm... anyone familiar with alex+happy about?
14:30:47 <fasta> vvv: this is 0.4 the release?
14:30:47 <Betovsky> hi ppl
14:31:01 <dmwit> Hiya, Betovsky.
14:31:05 <Betovsky> with ghc 6.8.1 when i try to build a cabal package
14:31:05 <fasta> vvv: I also have a very recent version of GHC installed.
14:31:18 <Betovsky> Setup.lhs: ld is required but it could not be found.
14:31:25 <EvilTerran> I'm trying to think of the way of passing around line+column information (as made by a %wrapper "posn" lexer) so it can be included in the final parse tree
14:31:26 <dmwit> Betovsky: windows?
14:31:27 <Betovsky> do I need to configure something first?
14:31:28 <fasta> Cabal is the new nightmare :)
14:31:31 <EvilTerran> without being horribly verbose
14:31:33 <Betovsky> dmwit yep
14:31:44 <dmwit> Betovsky: You need to put GHC's ld in your path.
14:32:14 <pejo> EvilTerran, isn't there an example for bringing in line numbers in the manual?
14:32:27 <Betovsky> ahh oky
14:32:28 <Betovsky> thx
14:32:48 <sethk> dons, should I send the changes I made to regex-base and regex-posix (so they work with 6.8.1 and bytestring) to someone?
14:33:13 <EvilTerran> yeah, there's one in the happy manual; it seems to require a very specific form of lexer, tho, and i'm not sure if it really meshes with alex
14:33:17 <fasta> sethk: to the maintainer?
14:33:36 <sethk> fasta, yes, I guess.  Does hackage show the maintainer?
14:33:53 <fasta> sethk: I thought so, but the sources do for sure.
14:33:56 <sethk> fasta, yes, it has an email address
14:34:28 <fasta> sethk: it's best if you make sure it also keeps working for previous versions, I guess.
14:34:57 <fasta> sethk: but if you don't feel like doing that, just send it, nobody will blame you.
14:38:21 <fasta> What list of packages does cabal install use?
14:38:41 <fasta> I have a system ghc and a bunch of user ghc's.
14:39:07 <fasta> I get cabal: user error (Unresolved dependencies: base >=2.0) when trying to install xmonad.
14:39:34 <fasta> I have base >=3.0, so I declare this to be a cabal error and not a "user-error".
14:40:04 <sjanssen_> fasta: hmm, interesting
14:40:19 <sjanssen_> fasta: this probably means you're missing one of the other build-depends?
14:40:34 <fasta> sjanssen_: do you really think I miss base-3.0?
14:41:19 <sjanssen> fasta: no, I think Cabal is complaining about the wrong thing
14:41:32 <sjanssen> do you have containers, directory, process?
14:42:07 <fasta> sjanssen: yes, I have all.
14:42:31 <sjanssen> fasta: oh, are you building the released version?
14:42:34 <sjanssen> or darcs?
14:42:38 <fasta> sjanssen: released
14:42:42 <fasta> sjanssen: cabal install xmonad
14:42:48 <vvv> fasta: sorry, I was corking the bottle before sending email to GHC guys :)
14:43:05 <fasta> vvv: GHC is not the one to blame.
14:43:17 <sjanssen> fasta: my comments don't apply then, must be a Cabal bug
14:43:21 <fasta> vvv: Cabal is the problem.
14:43:41 <fasta> searchpath seems like a much easier solution.
14:43:51 <sjanssen> fasta: you'll need to tweak xmonad.cabal to build it with 6.8
14:44:06 <sjanssen> searchpath doesn't come near to solving many of the problems cabal does
14:44:13 <fasta> sjanssen: oh, it hasn't been changed to cope with Cabal configurations?
14:44:23 <sjanssen> fasta: no, that's only in the darcs version
14:44:34 <fasta> sjanssen: of Cabal or xmonad?
14:44:40 <sjanssen> fasta: xmonad
14:45:07 <fasta> sjanssen: do the deps also need to be fetched from darcs repos in that case?
14:45:29 <sjanssen> fasta: nope, they're all on hackage
14:45:59 <fasta> sjanssen: so, in theory cabal install <the darcs xmonad cabal file> should work
14:46:04 <vvv> sjanssen: hi! Have you looked through http://hpaste.org/4182 ?
14:46:29 <fasta> vvv: did you already use -v3?
14:46:41 <sjanssen> fasta: oh, I didn't know that cabal-install can do that
14:46:44 <sjanssen> fasta: but yeah, should work
14:46:46 <vvv> fasta: who to feed with it?
14:46:59 <fasta> vvv: same command as where you stripped --user
14:46:59 <vvv> s/who/whom/
14:47:08 <vvv> let's see..
14:47:46 <fasta> vvv: and the best thing would be to just get cabal-install from hackage and do like me, I guess.
14:48:28 <SamB> too bad you can't cabal-install cabal-install without cabal-install installed
14:48:58 <vvv> runhaskell Setup.lhs configure --prefix=$HOME -v3
14:48:58 <vvv> Configuring xmonad-0.4...
14:48:58 <vvv> [...]
14:48:58 <vvv> Reading installed packages...
14:49:01 <vvv> /home/vvv/bin/ghc-pkg --global list
14:49:04 <vvv> Setup.lhs: At least the following dependencies are missing:
14:49:08 <vvv>     X11 ==1.4.0, mtl -any
14:49:11 <vvv>  
14:49:41 <sjanssen> vvv: X11 and mtl are installed as --user, you must configure xmonad with --user
14:49:41 <vvv> fasta: so, Cabal-1.3, that come with GHC, is not good?
14:49:51 <puusorsa> why can't cabal be more like make??
14:50:05 <puusorsa> as in just one 4 character command to build all etc
14:50:17 <fasta> puusorsa: for a correct package, I only do ih
14:50:29 <fasta> puusorsa: which stands for installhaskell
14:50:37 <vvv> sjanssen: I did that. :) There are not so many combinations really, so I tried them all...
14:50:58 <puusorsa> i use HB
14:51:02 <puusorsa> haskell build
14:51:09 <sjanssen> vvv: otherwise it looks right
14:51:17 <sjanssen> vvv: perhaps try with a released version of Cabal?
14:51:37 <sjanssen> vvv: you can get that from hackage, then ghc-pkg hide the newer version
14:51:45 <fasta> Cool, the darcs I/O bug is fixed.
14:51:51 <puusorsa> or rather H<tab>, only completion. made a short ruby script for that
14:52:03 <vvv> I'll try with darcs version of Cabal! That's what I should do from the very beginning...
14:52:25 * vvv runs for darcs Cabal in hurry ;)
14:52:28 <hpaste>  wellwisher pasted "Problems in main" at http://hpaste.org/4183
14:52:29 <fasta> vvv: I just got the one from Hackage.
14:52:50 <sjanssen> vvv: no, try the released version, darcs is more likely to be broken
14:53:05 <sjanssen> vvv: in fact ghc 6.9.* comes with darcs cabal
14:53:09 <puusorsa> fasta, but having some sensible default would be nice
14:53:20 <fasta> I don't get why people break their repos all the time. My one developer code has never ever been broken.
14:53:32 <fasta> puusorsa: I agree, talk to dcoutts_.
14:53:50 <wellwisher> would some one be able to figure out the compile errors in my program?
14:54:02 <fasta> wellwisher: if it's not undecidable ;)
14:54:11 <sjanssen> wellwisher: please annotate the error messages
14:54:20 <vvv> sjanssen: well. I've got 6.9.*, and Cabal-1.3 from it (see the hpaste), right?
14:54:36 <sjanssen> vvv: yes.  Cabal-1.3 is the darcs version.  Try a released version.
14:54:49 <vvv> sjanssen: okay
14:56:50 <vvv> sjanssen: BTW, why does Cabal-1.2.2.0 complain when I add `--user' to configure?
14:56:54 * EvilTerran discovers bugs in happy
14:56:55 <fasta> cabal install X11
14:56:57 <fasta> cabal: user error (Unresolved dependencies: base -any)
14:57:00 <hpaste>  wellwisher annotated "Problems in main" with "Problems in main" at http://hpaste.org/4183#a1
14:57:03 <EvilTerran> :(
14:57:07 <fasta> sjanssen: I guess thies cabal install program is simply broken.
14:57:15 <vvv> it says
14:57:15 <vvv> Setup.lhs: At least the following dependencies are missing:
14:57:15 <vvv>     base <3, filepath -any
14:57:15 <vvv>  
14:57:16 <sjanssen> fasta: yeah, that must be it
14:57:27 <ikegami--> good evening
14:57:28 <vvv> I just try to grok it. :)
14:57:32 <sjanssen> vvv: and with configure -f small_base?
14:57:45 <wellwisher> error message annotated
14:58:17 <sjanssen> wellwisher: ah, I see
14:58:19 <sjanssen> easy to fix
14:58:37 <wellwisher> there is another ont though :(
14:58:38 <ddarius> EvilTerran: Now you have to see if frown is bug-compatible.
14:58:43 <vvv> sjanssen: I thouth `small_base' relate to xmonad. Anyway, Cabal configures without `--user'
14:59:25 <sjanssen> wellwisher: in line 9, you should use "let rs1 = randList seed 20", because randList isn't an IO action
14:59:43 <Leimy> hello
14:59:55 <SamB> EvilTerran: what manner of bugs?
15:00:08 <Leimy> Anyone know how I can build darcs against GHC 6.8.1 using stable source?
15:00:16 <Leimy> Having issues with the openFd bit
15:00:19 <vvv> sjanssen: oh, I see `small_base' in Cabal.cabal
15:01:05 <EvilTerran> it falls over if you try to use layout in the {...} bit of a rule
15:02:46 <Heffalump> Leimy: there's a patch in the unstable tree you can probably just pull in
15:02:49 <Heffalump> a few patches, in fact
15:02:54 <hpaste>  wellwisher annotated "Problems in main" with "Problems in main" at http://hpaste.org/4183#a2
15:03:04 <Leimy> Heffalump: I'd pull it if I had darcs :-)
15:03:17 <wellwisher> the next error is posted
15:03:38 <hpaste>  EvilTerran pasted "happy bug" at http://hpaste.org/4184
15:04:11 <sjanssen> wellwisher: use show rather than showList
15:04:34 <ddarius> @index listArray
15:04:35 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
15:04:45 <EvilTerran> and, when i work around that, i get "templates/GenericTemplate.hs:75:0: Multiple declarations of `Parser.happyParse'; Declared at: Parser.hs:327:0"
15:05:21 <wellwisher> the same error is still there with show
15:05:58 <sjanssen> wellwisher: did you remove the other occurence of showList?
15:06:41 <wellwisher> nevermind i found the problem
15:06:54 <wellwisher> it didn't like the $
15:07:14 <sjanssen> ah yes
15:07:35 <sjanssen> that will parse as: (xs ++ showList) (average blah)
15:07:54 <sjanssen> clearly you can't ++ functions
15:08:11 <EvilTerran> (++) = mappend ;)
15:08:31 <sjanssen> clearly you can't ++ functions and strings
15:08:37 <sjanssen> there :)
15:08:40 <EvilTerran> okay, you win
15:10:33 <vvv> ?t mappend
15:10:33 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:10:42 <vvv> ?type mappend
15:10:45 <lambdabot> forall a. (Monoid a) => a -> a -> a
15:11:08 * EvilTerran thinks further about that bug in happy
15:11:51 <EvilTerran> i think the only reliable way around it would be to go through the {...} blocks and add explicit {;}s in place of layout before outputting the Parser.hs
15:12:35 <EvilTerran> but that gets kinda tricky, especially as {...} blocks generally don't contain valid haskell, so you can't throw an existing parser at it
15:12:38 <SamB> EvilTerran: oh, istr seeing that...
15:12:50 <EvilTerran> (because of $s)
15:12:55 <Olathe> Why do sites for new programming languages never, ever have snippets of example code that are easy to find from the front page ?
15:13:23 <Olathe> Gee, this looks interesting, I wonder what it looks like.... Umm.... Uhhh....
15:13:34 <SamB> I think haskell.org used to have that "quicksort" example on the frontpage. would you like that better?
15:14:11 <EvilTerran> make the link to "evolution of a haskell programmer" more prominent ;)
15:14:20 <Olathe> Haskell is fine.
15:14:28 <SamB> oh.
15:14:33 <SamB> right. Haskell ain't new.
15:14:38 <SamB> I keep forgetting that :-(
15:14:42 <Olathe> I clicked on the introduction, since that seemed relevant, and it has quicksort pretty early.
15:15:13 * SamB was KIDDING about that
15:15:23 <SamB> you mean you actually like that quicksort example?
15:15:37 <Olathe> No, it just lets me see what code looks like.
15:16:30 <noteventime> Is Data.Tree fast?
15:16:36 <noteventime> In GHC
15:16:43 <dons> should be ok. pretty simple structure.
15:16:50 <fasta> noteventime: you are lucky that monochrom is not here :)
15:16:54 <dons> but you can define your own tree, that is more specialised, noteventime
15:17:07 <noteventime> dons: I know :-)
15:17:09 <SamB> fasta: why is he lucky about that?
15:17:19 <noteventime> Thing is that I'm still new to both Haskell and Functional programming
15:17:23 <EvilTerran> SamB, any thoughts on the other error?
15:17:29 <noteventime> I figured I'd get used to one thing at a time :-)
15:17:31 <EvilTerran> ("templates/GenericTemplate.hs:75:0: Multiple declarations of `Parser.happyParse'; Declared at: Parser.hs:327:0")
15:17:32 <fasta> SamB: he would simply state that the question is meaningless.
15:17:41 <fasta> SamB: and he would be right.
15:17:44 <SamB> no idea about the happyparse thing
15:17:46 <noteventime> fasta: I understand that too
15:17:59 <noteventime> fasta: I still think one can give an intuitive kind of answer to it though
15:18:07 <SamB> noteventime: compared to WHAT?
15:18:20 <Olathe> Compared to saying whether the moon looks fat.
15:18:25 <fasta> I don't think I will ever use Data.Tree, if that answers your question.
15:18:28 <Olathe> That's pretty hard to do.
15:18:30 <noteventime> SamB: Compared to the probably broken thing I'd write myself
15:18:45 <hpaste>  vvv annotated "2 GHCs => can't resolve Cabal dependencies" with "stable Cabal doesn't help" at http://hpaste.org/4182#a3
15:18:47 <byorgey> fasta: that answers noteventime's question even less than saying it's meaningless =)
15:18:50 <SamB> Olathe: what task are you using data.tree for to compare that with?
15:18:51 <ddarius> :t listArray
15:18:52 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:19:14 <byorgey> noteventime: for what purpose are you using Data.Tree?
15:19:29 <fasta> byorgey: nah, I don't think Data.Tree has any applications.
15:19:33 <noteventime> I was thinking I'd try writing a small simple scene graph for representing 3D scenes
15:19:42 <noteventime> To get used to Haskell and OpenGL
15:19:51 <dons> fasta, its useful for its pretty printer
15:19:54 <noteventime> Figured I'd learn the standard library by doing so
15:20:02 <noteventime> while doing so*
15:20:04 <fasta> dons: I don't agree, since I used it and didn't like it.
15:20:18 <dons> I've used it, and liked it.
15:20:37 <dons> but i'm waiting for  your improved graph and tree libraries to appear on hackage :)
15:21:46 * ddarius doesn't really like Data.Tree, though I guess it's fine if you want to do exactly what the functions in it provide.
15:21:51 <scodil> is there a way to convert lazy byte strings into strict ones? or get Data.Binary to make strict byte strings?
15:21:59 <byorgey> noteventime: actually, I think you'd probably want to define your own data type for that purpose.
15:22:05 <SamB> ddarius: of course it is
15:22:08 <noteventime> byorgey: Even as a beginner?
15:22:14 <SamB> but there are so many kinds of trees you might want
15:22:27 <byorgey> noteventime: sure.  defining your own data types is not hard.
15:22:40 <noteventime> byorgey: Defining your own efficient ones might be :-)
15:22:50 <noteventime> If you say so though, I'll give it a try first
15:23:00 <fasta> noteventime: that's why you first think about the problem before you touch a computer.
15:23:00 <ddarius> SamB: There are better versions of a general rose tree.
15:23:16 <byorgey> noteventime: well, what you're talking about sounds simple enough that efficiency won't really be an issue.
15:23:18 <SamB> ddarius: eh?
15:23:24 <ddarius> noteventime: There is nothing efficient/inefficient about Data.Tree.
15:23:36 <noteventime> fasta: The thing is that I still don't have much of an idea what is efficient when doing functional programming :-)
15:23:48 <SamB> noteventime: unless you wanted to use arrays to list the children?
15:23:48 <dons> scodil: concat . toChunks
15:23:56 <fasta> noteventime: the same principles apply as in any other programming language.
15:23:56 <byorgey> noteventime: this is basically some sort of hierarchical structure that breaks up a scene into objects, subobjects, and so on?
15:24:30 <SamB> I usually define my own tree type, I think...
15:24:34 <ddarius> SamB: I'd like one that could be turned into a MonadPlus
15:24:38 <scodil> dons: thanks
15:24:41 <noteventime> byorgey: Well, I was thinking geometry as leaves and transformation matricies and property changes (colour e.t.c.) in the branches
15:24:47 <noteventime> leafs*
15:24:56 <noteventime> But basically, yes
15:24:56 <ddarius> noteventime: Then make a data type that says that.
15:25:33 <noteventime> Haha, I didn't want to start such a controversy. Although I suspected I would >_>
15:25:42 <SamB> and then pull it to pieces when you figure out how to do efficient scene traversal...
15:25:53 <ddarius> noteventime: There isn't a controversy.  Everyone is telling you more or less the same thing.
15:26:07 <byorgey> data Scene = Thing Geometry | Composite Property [Scene]  -- for example
15:26:09 <noteventime> ddarius: Everyone is telling it a lot though :-)
15:26:19 <byorgey> noteventime: welcome to #haskell =)
15:26:25 <noteventime> Well
15:26:28 <SamB> that's called something other than controversy, I think
15:26:32 <noteventime> I have an idea about how to do it
15:26:45 <noteventime> I mainly wanted to know if Data.Tree was considered slow .-)
15:27:09 <EvilTerran> it lacks the kind of semantic information that defining your own data type provides
15:27:11 <ddarius> Data.Tree is probably not what you want, it'd be better in almost every way to define your own data type.
15:27:19 <noteventime> ok
15:27:44 <EvilTerran> it'd be like using nested Eithers and tuples instead of defining your own sum and product types
15:27:45 <noteventime> Thanks for the feedback :-)
15:28:11 <SamB> EvilTerran: worse!
15:28:23 <SamB> it wouldn't even perform the appointed task
15:28:31 <EvilTerran> i dunno, using nested Eithers to represent more than two alternatives would be pretty icky
15:28:43 <SamB> icky, but it would WORK
15:28:47 <EvilTerran> eeh
15:29:20 <SamB> doesn't that squiggol paper do it?
15:31:12 * EvilTerran comes across another (minor, this time) bug in happy, and concludes that it is not yet ready for the prime time
15:31:33 <dons> hmm, really, EvilTerran ?
15:31:40 <dons> its only been in use for the last 15 years
15:31:47 <dons> and ghc uses it.
15:31:49 <EvilTerran> well, i've been using it for a few hours, and already come across numerous bugs
15:31:55 <EvilTerran> that hardly seems good
15:31:59 <dons> that sounds implausible!
15:32:12 <dons> i don't think i've ever run into a bug in happy
15:32:20 <ikegami--> hehe
15:32:23 <EvilTerran> 2305<hpaste>  EvilTerran pasted "happy bug" at http://hpaste.org/4184
15:32:25 <dons> despite using it in maybe a dozen projects
15:32:33 <SamB> perhaps some of them are misfeatures
15:32:46 <SamB> anyway, dons, I know for a fact that happy has bugs sometimes
15:32:51 <EvilTerran> 2306<EvilTerran> and, when i work around that, i get "templates/GenericTemplate.hs:75:0: Multiple declarations of `Parser.happyParse'; Declared at: Parser.hs:327:0"
15:32:57 <dons> huh. is anyone reporting these?
15:33:07 <SamB> I fixed the one I am thinking of
15:33:11 <dons> oh, so mostly just build failures, against whatever base libs you're using?
15:33:16 <EvilTerran> that second one goes away if i introduce a %name thing
15:33:19 <SamB> it only came into play with invalid grammar files
15:33:24 <dons> or are you compiling with -Werror or something?
15:33:32 <EvilTerran> no, neither of those
15:33:33 <SamB> i.e. the error messages weren't working
15:33:55 <EvilTerran> there's too definitions of happyParse in the Parser.hs generated from my Parser.y
15:33:58 <EvilTerran> *two
15:34:00 <dons> EvilTerran: haven't seen any of these build failures -- and it seems surprising. What ghc and happy versions are you using?/
15:34:10 <EvilTerran> but with {-# LINE #-}s between 'em
15:34:16 <SamB> is your happy installed?
15:34:25 <EvilTerran> ghc 6.8.1
15:34:33 <EvilTerran> happy 1.17
15:34:46 <dons> is 1.17 the development version?
15:34:52 <EvilTerran> don't think so...
15:34:59 <dons> ah, its the new release
15:35:05 <dons> 22 Oct.
15:35:14 <EvilTerran> "The current public version of Happy is 1.17, which was released on 22 October 2007."
15:35:24 <dons> i'd double check against 1.16
15:35:30 <SamB> 22 Oct?
15:35:33 <SamB> thats NEW?
15:35:40 <dons> since that's been used pretty well, and i've not seen bug reports
15:35:47 <SamB> oh, right.
15:35:53 <dons> then, *please* report failures to simon marlow
15:35:55 * SamB got his months mixed up
15:36:02 <EvilTerran> I'm working on reporting 'em
15:36:19 <EvilTerran> thought i'd mention them on here to check they weren't deliberate first ;)
15:36:33 <dons> no, i've not seen anyone report this kind of thing.
15:37:00 <EvilTerran> what do you mean by "installed"?
15:37:05 <dons> the fact you're having lots of failures suggests to me something is wrong in the build/library set up happy is expecting
15:37:05 <EvilTerran> (SamB)
15:37:25 * EvilTerran got it from the link described as "Windows: a binary distribution is available, just unzip and go."
15:37:36 <SamB> EvilTerran: where is it?
15:37:40 <SamB> oh.
15:37:41 <EvilTerran> on my path...
15:37:45 <SamB> okay, that's probably installed then
15:38:28 <EvilTerran> dons, it seems to me that the sort of errors i'm getting *couldn't* be problems with the build or libraries
15:38:53 <EvilTerran> the first one being purely a limitation of trying to splice whitespace-dependent code around without parsing it first
15:39:28 <EvilTerran> i don't know what the second's about; that looks like it could be an error that crept in in the last versio
15:39:28 <EvilTerran> n
15:40:03 <dons> sure. you've got restrictions on the indentation. you using tabs, are you?
15:40:08 <EvilTerran> nope
15:40:21 <EvilTerran> or yep. tried both, neither worked.
15:41:38 <fasta> How can I read the contents of memory address 5 in Haskell? Just call peek as root?
15:41:49 <dons> yeah
15:41:59 <dons> well, its your address space
15:42:11 <SamB> wouldn't the easiest way of splicing code around be to insert spaces as needed?
15:42:11 <dons> so the OS will have something to say, I guess
15:42:13 <EvilTerran> and the minor one that pushed me over the edge into this mad rant against an established piece of software was a warning of overlapping patterns caused by my %token directives covering my token type fully, and the _-> error clause in the generated case-of
15:42:35 <dons> yep, that's known though. its not like its a bug
15:42:35 <EvilTerran> which may well be a new thing in ghc 6.8.1
15:42:37 <SamB> EvilTerran: oh, yes, that's really annoying
15:42:44 <SamB> dons: it's ANNOYING
15:43:03 <dons> "numerous bugs" /= bogus warnings :)
15:43:07 <EvilTerran> it's not what people usually want, so it's a bug, i say
15:43:32 <SamB> there could be a directive to avoid it or something
15:44:04 <EvilTerran> indeed
15:44:50 <EvilTerran> that'd probably be the best way of doing it
15:45:26 <SamB> %fulltokencoverage or something
15:45:48 <EvilTerran> set it to "just trust me on this one" mode ;)
15:47:42 <hpaste>  (anonymous) pasted "Peeking as root gives segfault" at http://hpaste.org/4185
15:48:16 * EvilTerran was slightly disappointed to discover that happy uses source concatenation, actually. I'd hoped it'd do something more hygenic
15:48:54 <fasta> dons: any idea why that doesn't just work?
15:49:29 <glguy> Cale, you about?
15:49:56 <EvilTerran> TH-esque splicing of parse trees, say
15:50:01 <dibblego> EvilTerran, are you saying there are no legitimate cases for ++ at all?
15:50:31 <Beelsebob> does seq really do what it's meant to in ghci?
15:51:02 <fasta> Beelsebob: unless you prove that it doesn't, yes.
15:51:28 <Beelsebob> well, I have one instance where seq complexCalculation "done" prints done instantly
15:51:30 <EvilTerran> maybe if speed is a massive priority. but then you've got a fast algorithm that doesn't work in the general case, and (as i am often reminded by my lecturers) fast broken algorithms are trivial to devise ;)
15:51:37 <Beelsebob> but if I immediately follow it with complexCalculation
15:51:44 <Beelsebob> it takes *ages* before it prints anything
15:51:50 <mauke> fasta: er, what did you expect?
15:51:57 <SamB> dibblego: source concatenation, not concatenation
15:51:57 <EvilTerran> Beelsebob, it only reduces to WHNF; can you produce the outermost constructor of your complexCalculation result quickly?
15:52:07 <Beelsebob> ah, yeh, that makes sense
15:52:12 <dibblego> oh, what is source concatenation?
15:52:19 <fasta> mauke: I expected to get back the 4 bytes from memory address 5 interpreted as an Int and printed.
15:52:23 <SamB> dibblego: it's like "paste"
15:52:27 <EvilTerran> "(\x -> " ++ "x + 1)"
15:52:28 <dibblego> ah right
15:52:30 <EvilTerran> ;)
15:52:38 <EvilTerran> it makes baby jesus cry
15:52:38 <SamB> without fixing the indentation or anything
15:52:39 <dibblego> I see, phew :)
15:52:47 <mauke> fasta: first, that address is not aligned for an int, and second, page 0 is probably not mapped
15:53:16 <EvilTerran> it's the sort of preprocessing that's even lower on the pecking order than CPP, as it doesn't even necessarily respect token boundaries
15:53:32 <EvilTerran> let alone AST structure
15:53:43 <dons> iirc, it previously used Language.Haskell  to parse the fragments
15:53:48 <dons>  which restricts you to h98
15:54:08 <dons> hence the change to allow freeform text, to be caught by the compiler in phase 2
15:54:13 <SamB> dons: it should insert an appropriate quantity of spaces in front of each line
15:54:26 <EvilTerran> SamB, i think that's easier said than done
15:54:29 <dons> talk to the authors if you've a bug report
15:55:12 <EvilTerran> i intend to
15:55:27 <fasta> mauke: forgive my ignorance, but what's the problem of it not aligning? Why isn't page 0 mapped? Isn't that a waste of memory?
15:55:46 <Heffalump> Beelsebob: how about seq (show complexCalculation) "done"
15:55:55 <Beelsebob> Heffalump: much longer
15:55:59 <Beelsebob> as expected
15:56:14 <Beelsebob> hmm, does anyone have a good algorithm for producing the factors of an Integer (once and only once each)
15:56:25 <Beelsebob> I'm really struggling to managed to deal with the square case efficiently
15:56:29 <SamB> once and only once each?
15:56:37 <SamB> don't you want to know how many times each appears?
15:56:49 <Heffalump> calculate prime factorisation first
15:56:50 <Beelsebob> not prime factors, just factors
15:56:55 <mauke> fasta: results of unaligned memory access depend on the processor.
15:57:04 <Beelsebob> Heffalump: but then won't the combinations be rather slow?
15:57:10 <SamB> Beelsebob: come up with a bad way good enough to solve that problem on project euler
15:57:14 <Heffalump> Beelsebob: why?
15:57:15 <SamB> then read the thread
15:57:18 <mauke> fasta: some will kill your program (SIGBUS); x86 just get very slow
15:57:36 <Heffalump> Beelsebob: just take the number of times each prime factor occurs, and iterate from 0..that number
15:57:38 <Beelsebob> Heffalump: surely it's at least quadratic time?
15:57:44 <Beelsebob> or am I being a nubin?
15:57:44 <Heffalump> and take the cross-product over all prime factors
15:57:47 <Heffalump> quadratic in what?
15:57:53 <Beelsebob> the number of prime factors
15:57:58 <fasta> mauke: x86 just get very slow?
15:58:01 <mauke> fasta: and the first page isn't mapped to trap null pointer dereferences
15:58:13 <Heffalump> exponential, more like
15:58:22 <Heffalump> but that's cos the number of results is exponential in the number of prime factors
15:58:33 <EvilTerran> > (\n -> filter ((0==).(n`div`)) $ takeWhile ((<n).(^2)) [1..]) 60
15:58:34 <Beelsebob> ah, good point
15:58:34 <fasta> mauke: ok, so that's done of the paging level, I just figured it would compare to 0.
15:58:34 <Heffalump> how would you expect to do any better than linear in the number of results?
15:58:34 <lambdabot>  []
15:58:39 <Beelsebob> so I can't do better than that anyway
15:58:45 <EvilTerran> > (\n -> filter ((0==).(n`mod`)) $ takeWhile ((<n).(^2)) [1..]) 60  -- even
15:58:46 <lambdabot>  [1,2,3,4,5,6]
15:58:51 <Beelsebob> Heffalump: yeh, fair point
15:58:54 <Heffalump> well, you still have to find the prime factors
15:58:59 <Beelsebob> EvilTerran: 10 isn't a factor of 60?
15:59:01 <fasta> mauke: so, the specification of peek states that it is processor dependent?
15:59:02 <Heffalump> but I think that's probably a lot cheaper than then combining them all.
15:59:03 <EvilTerran> er
15:59:03 <mauke> fasta: yes, x86 processors will do what you want by doing multiple reads and assembling the result "manually"
15:59:04 <SamB> anyway, see project euler forums...
15:59:08 <EvilTerran> > (\n -> filter ((0==).(n`mod`)) $ takeWhile (<n) [1..]) 60  -- even
15:59:08 <lambdabot>  [1,2,3,4,5,6,10,12,15,20,30]
15:59:15 * EvilTerran mutters
15:59:16 <mauke> fasta: peek has a spec?
15:59:21 <fasta> mauke: I'd hope so.
15:59:28 <Heffalump> EvilTerran: that doesn't look very efficient
15:59:34 <SamB> mauke: yes. you just read your old BASIC manual
15:59:42 <EvilTerran> O(n), surely?
15:59:49 <Beelsebob> indeed
15:59:52 <Heffalump> yes, but it doesn't need to be O(n)
15:59:56 <fasta> mauke: oh, right, it does mention the alignment issue.
15:59:57 <Beelsebob> but O(n) in the size of the number
15:59:59 <Heffalump> it just needs to be O(number of factors)
16:00:04 <Beelsebob> rather than O(n) in the number of factors
16:00:12 <fasta> mauke: so, it's just my lack of arch specific knowledge.
16:00:16 <Heffalump> + cost of prime factorisation, which I suspect is much less
16:00:30 <mauke> fasta: just think in C!
16:01:00 <SamB> C practice, at that
16:01:02 <fasta> mauke: I can even apply the function alignment to it.
16:01:03 * EvilTerran wanders off muttering
16:01:44 * EvilTerran wonders why people were talking about quadratic and exponential complexities a minute ago
16:01:56 <Heffalump> in the number of prime factors
16:02:18 <Heffalump> which is rather a lot smaller than the number of factors
16:02:20 <fasta> mauke: I don't have years of C experience; I only did some trivial things with it.
16:02:26 <EvilTerran> being a relevant metric ;)
16:02:49 <mauke> fasta: haha, you need to read the comp.lang.c archives (or comp.std.c?)
16:03:31 <fasta> mauke: why? Because it's a valuable resource?
16:04:03 <mauke> for language lawyering
16:04:10 <fasta> mauke: I read K&R2, though.
16:04:26 <dons> dcoutts_: it would be nice if i could say: cabal install ../foo
16:04:33 <dons> to build and install a local repo
16:04:51 <dons> since often we have a mixture of hackage and local dev packages in a project
16:04:53 <fasta> dons: heh, I found out that I wanted that too an hour ago.
16:05:04 <dons> interesting!
16:05:08 <EvilTerran> dons, I hope you'll forgive my "not ready for the prime time" comment. I get fed up with malfunctioning software very quickly... TBH, I sometimes wonder if aiming for a career in CS is a good idea, seeing as all the anger'd no doubt take years off my lifespan ;)
16:05:50 <dons> don't worry, i'm not taking it personally :)
16:06:02 * Heffalump wonders if dons is ready for the prime time
16:06:22 <Heffalump> invoke dcoutts' name and he will arrive!
16:06:27 <EvilTerran> I guess I have this idyllic idea that I can do better, but that doesn't make other people's software malfunctioning any less irritating; if anything, it makes it more so, as I can't fix *everything* around here myself ;)
16:06:41 <noteventime> Hmm, this is probably another stupid question >_>. Any opinions on which editor has the furthest developed Haskell mode? I'm used to both Vim and Emacs. I wouldn't mind learning a new editor if it meant better integration for Haskell.
16:07:07 <sjanssen__> noteventime: emacs has the most extensive Haskell integration
16:07:19 <noteventime> sjanssen: Ok, thanks
16:07:26 <byorgey> noteventime: I think those two are pretty much the best at this point.  which one is better is probably a matter of (violent) opinion.
16:07:29 <olsner> as I understand it, emacs' haskell mode is slightly more advanced... then again, I usually just use normal editors
16:08:18 <noteventime> byorgey: I'm well aware of the Vim vs. Emacs conflict :-)
16:08:19 <fasta> Oh, how I hate the new :r behaviour.
16:08:26 <olsner> the horror of emacs far outweighs most practical advantages, at least the way I view the world
16:08:33 <Heffalump> fasta: at least it's been acknowledged now
16:08:45 <noteventime> olsner: I find emacs pretty neat
16:08:46 <fasta> Heffalump: yes, I read something about it o users
16:08:51 <EvilTerran> @quote EvilTerran technology
16:08:51 <lambdabot> EvilTerran says: Computer Science - because all technology is shit
16:08:51 <fasta> Heffalump: on*
16:09:03 <EvilTerran> (relevant to my earlier rant :D)
16:09:47 <fasta> EvilTerran: Lots of stuff in CS is shit too :)
16:10:10 <fasta> EvilTerran: bugs are everywhere where you see humans.
16:10:34 <olsner> x86
16:11:02 <olsner> 's bogosity baffles even gcc developers... i'm amazed
16:12:18 <fasta> mauke: with address = nullPtr `plusPtr` (alignment(nullPtr `plusPtr` 50000000)), I still get a segfault. Alignment should be ok now, and it's not page 0 anymore.
16:12:25 <Beelsebob> Heffalump: thanks a lot, got a nice fast factorisation now :)
16:12:32 <mauke> fasta: probably another unmapped page
16:12:40 <EvilTerran> fasta, if all goes according to plan, I'll be hiding in academia in a few years, and able to safely avoid computers *and* people
16:13:04 <fasta> EvilTerran: everything interesting is done with computers nowadays, I guess.
16:13:18 <fasta> EvilTerran: and you will get to use the horrors of LaTeX.
16:13:40 <olsner> apparently, the BIOS on current x86 platforms has to work for some time without RAM, so they organize it all to fit into the L1 cache until the RAM controller(s) are initialized
16:13:43 <EvilTerran> <insert quotation about telescopes:astronomy == computers:CS>
16:13:58 <LoganCapaldo> fasta: is that interesting supposed to be qualified with "in academia" or something?
16:13:59 <fasta> mauke: ok, this abstraction of a linear map of memory from 0 to big number has just exploded.
16:14:17 <ddarius> EvilTerran: telescopes:astronomy::computers:CS
16:14:42 <mauke> fasta: why?
16:14:53 <EvilTerran> ah, yes, i've tried to learn (La-)TeX a few times. what fun.
16:15:03 <fasta> LoganCapaldo: I did mean it like that, yes, but I don't think academia is superior in any way to research in industry.
16:15:07 <EvilTerran> ddarius, yeah... that's what i said (isn't it?)
16:15:10 <LoganCapaldo> err
16:15:29 <LoganCapaldo> I just meant there are interesting things that nothing to do with research or academia :)
16:15:31 <ddarius> EvilTerran: The normal form (as far as I can tell) uses ::
16:15:34 <LoganCapaldo> or computers
16:15:48 <fasta> mauke: because I cannot write a program that just reads all the memory locations and print them all.
16:15:56 <EvilTerran> ddarius, ah, okay. i've seen that a couple of times, but i got the impression it was obselete
16:16:08 <LoganCapaldo> just wanted to make sure you didn't mean it as general as it sounded
16:16:24 <EvilTerran> they didn't teach it where i went to school anyway, so it *must* be obselete! :P
16:16:32 <mauke> fasta: you could but I wouldn't do it in haskell
16:16:48 <ddarius> mauke: Haskell isn't the issue here.
16:16:53 <fasta> mauke: doing the same in C would also give a segfault, wouldn't it?
16:17:03 <mauke> fasta: yes, but you can catch SIGSEGV
16:17:19 <ddarius> mauke: Can't you do that in Haskell too?
16:17:20 <mauke> or fork a new process and have it try first
16:17:21 <fasta> mauke: can't I catch that in Haskell too?
16:17:30 <mauke> somehow that sounds very unreliable
16:17:44 <fasta> mauke: but in the case of SIGSEGV it still doesn't return the actual value.
16:17:54 <mauke> in the case of SIGSEGV there is no value
16:18:00 <fasta> mauke: of course there is a value.
16:18:04 <mauke> no
16:18:08 <fasta> mauke: it might be unspecified.
16:18:15 <mauke> uh huh
16:18:22 <fasta> mauke: but the memory of the machine is in some state.
16:18:37 <mauke> that's something completely different
16:19:03 <fasta> I don't see the difference.
16:19:10 <mauke> every process has its own address space, regardless of physical memory
16:19:58 <fasta> Isn't that orthogonal to this issue as root should be able to read from every mapped area?
16:20:04 <SamB_XP> in short: what memory?
16:20:16 <fasta> Oh, I misunderstood.
16:20:36 <dcoutts> Heffalump: hmm?
16:20:49 <mauke> fasta: huh? root is irrelevant
16:20:58 <fasta> mauke: yes, I misunderstood, now I do.
16:20:59 <mauke> if it's a process, it has a private address space
16:21:10 <Heffalump> dcoutts: you appeared just after dons said something to you
16:21:14 <SamB_XP> Double Flatulence Slaughter
16:21:17 <SamB_XP> erg.
16:21:22 <dcoutts> Heffalump: ah
16:21:22 <SamB_XP> ECHAN
16:21:24 <dcoutts> dons: pong
16:21:28 <dons> dcoutts: ping?
16:21:41 <Heffalump> you two have your pings and pongs muddled
16:21:48 <dcoutts> dons: Heffalump thought you were after me I thought
16:21:55 <dcoutts> dons: exciting news though :-)
16:22:00 <dons> very!
16:22:05 <fasta> mauke: but this "private address space" can still be read by root.
16:22:13 <Heffalump> exciting news?
16:22:15 <dcoutts> dons: but I'm feeling a tad exhausted atm, end of term, you know.
16:22:30 <dcoutts> dons: I wish they had said what kind of time frame they were thinking of
16:22:32 <mauke> fasta: no
16:22:35 <dons> mm
16:22:37 <mauke> well, yes, but not directly
16:22:47 <dcoutts> dons: I've no idea if we have enough time to do the extra work
16:22:48 <fasta> mauke: yes, I know there's a base address and all that.
16:22:59 <fasta> mauke: you meant that, right?
16:23:02 <mauke> no
16:23:11 <fasta> mauke: ok, then I have no idea what you are talking about.
16:23:11 <mauke> I meant you don't do it by dereferencing pointers
16:23:15 <mauke> ptrace()
16:23:32 <dcoutts> dons: it could be good and mesh with my writing up my thesis
16:24:27 <dcoutts> dons: anyway, we can talk about it all later, I've got to sleep for 3 days :-)
16:25:34 <ddarius> "Gyroelongated square dipyramid"
16:25:55 <fasta> mauke: how exactly would you read unmapped areas of memory on Linux as root?
16:26:03 <mauke> you don't
16:26:14 <mauke> unmapped areas don't exist; what's there to read?
16:26:53 <fasta> mauke: does this imply that there exist valid memory addresses that are unmapped?
16:26:55 <byorgey> ddarius: ?
16:27:06 <mauke> what do you mean by "valid"?
16:27:45 <fasta> mauke: Suppose you have a memory with only 2 physical bytes with addresses 0 and 1. Both bytes are said to be valid.
16:30:17 <mauke> now what?
16:30:45 <mauke> btw, the "as root" part of your question doesn't make sense
16:31:36 <fasta> mauke: reading an address from a process you don't own is not allowed, AFAIK.
16:31:47 <fasta> mauke: well, you asked what valid meant and either the definition is not clear or you would answer the previous question.
16:32:05 <mauke> you didn't provide a definition
16:32:21 <mauke> you gave a weird special case as an example of validity
16:32:35 <mauke> there is no such thing as an address from another process
16:32:41 <mauke> all addresses are process-local
16:33:00 <mauke> all memory is virtual
16:33:43 <fasta> mauke: but usually the first x bytes of virtual memory is physical memory. '
16:34:01 <mauke> since when?
16:34:18 <SamB_XP> what the heck are you talking about?
16:34:40 <fasta> mauke: ok, well, I assumed that, why would anyone do it differently?
16:35:05 <olsner> some map the end of the address space to physical memory
16:35:21 <mauke> mapping doesn't have to be in order
16:35:41 <mauke> parts of your address space could refer to on-disk files or weirder things
16:37:14 <mauke> and overcommitting means you can have "mapped" memory with no backing
16:38:04 <fasta> What happens when you write to those overcommitted areas?
16:38:21 <olsner> it goes boom ;-)
16:38:27 <mauke> lazy allocation
16:38:36 <mauke> if there is no memory left, someone loses an eye
16:38:48 <olsner> yeah, falling back on the good old OOM killer
16:38:54 <Toxaris> your computer orders more RAM via the internet
16:39:06 <LoganCapaldo> that would be hawt
16:39:13 <Thomas2> there are comps which do that
16:39:28 <LoganCapaldo> see the hourglass until the ram comes in the mail and you installl it
16:39:33 <LoganCapaldo> :p
16:39:36 <Thomas2> bits fail and they order a hardware guy to come in with more all by themselves
16:39:54 <jeffz> Thomas2: only if you pay a hell of a lot of money.
16:40:24 <Beelsebob> damn it I'm a moron
16:40:24 <Thomas2> jeffz: when a friend of mine first told me what they paid for high-reliability comps i was amazed
16:40:31 <olsner> bits ordering hardware? computers sure are getting smarter these days!
16:40:42 <jeffz> Thomas2: in the industry, we refer to them as computers :p
16:40:44 <Beelsebob> problem 27 was both taking ages and being wrong because my prime detection thought all negative numbers were prime
16:41:15 <byorgey> Beelsebob: hah =)
16:41:35 <Thomas2> they were talking hundreds of thousands of dollars for a totally redundant box (swap out CPUs on failure)
16:41:41 <Beelsebob> my prime factors function always returned [n] when n was negative
16:41:46 <Beelsebob> so obviously n must be prime
16:42:21 <idnar> Thomas2: and then an asteroid hits the datacentre, and it's all for nothing ;)
16:42:39 <jeffz> idnar: you can pay extra for a second machine, offsite.
16:49:54 <puusorsa> class Monad m => MonadState s m | m -> s where ... what does the | mean there?
16:50:13 <mauke> "warning, functional dependency coming up"
16:50:26 <Lemmih> puusorsa: It means that 's' is determined by 'm'.
16:51:21 <puusorsa> thanks
16:52:10 <SamB_XP> Beelsebob: what have they been telling you about prime numbers?
16:52:26 <Beelsebob> hmm?
16:56:23 * mrd wonders which numbers are sub-prime
16:56:54 <olsner> "bis" numbers?
16:57:21 <bparkis> is (x v x v x) a legal 3-CNF clause? (ie can you have repeated literals?)
16:57:44 <bparkis> and how about (x v y v z) n (x v y v z) (repeated clauses?)
16:58:00 <mrd> pretty sure its ok
16:58:00 <Beelsebob> you can... but it's pointless
16:58:07 <bparkis> well it's not entirely pointless
16:58:13 <Beelsebob> hmm?
16:58:13 <mrd> well, (x v x v x) is pointful
16:58:15 <bparkis> i have a solution to a problem that depends on using that
16:58:32 * Beelsebob is interested now
16:58:38 <bparkis> on the fact that (x v x v x) n (x v x v x) must either have 2 true clauses or 2 false clauses
16:58:38 <mrd> if you are working in a strictly 3-CNF
16:58:46 <bparkis> and nothing in between
16:58:55 <Beelsebob> true
16:59:00 <Beelsebob> sorry, moronicness
16:59:40 <mrd> proofs are easier if you assume its strictly 3-cnf
16:59:45 <dons> dcoutts: wasn't rl keen on doing this for jfp anyway?
17:00:04 <dcoutts> dons: yes, the main question is how much time we have
17:00:28 <dons> yeah. and what their estimated deadline is.
17:00:36 <dons> i think we should do this though.
17:01:09 <dcoutts> dons: oh definitely, it's a huge honour and opportunity
17:03:03 <geocalc> @version
17:03:03 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
17:03:03 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:18:59 <newsham> ?type \a b -> a (\c _ -> b c) b
17:19:00 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
17:21:01 <newsham> ?djinn ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
17:21:02 <lambdabot> f a b = a (\ c _ -> b c) b
17:21:10 <Olathe> @pl \a b -> a (\c _ -> b c) b
17:21:10 <lambdabot> join . (. (const .))
17:21:38 <ddarius> @src Cont callCC
17:21:38 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
17:25:50 <newsham> ?djinn ((a->(b->r)->r)->(a->r)->r)->(a->r)->r
17:25:51 <lambdabot> f a b = a (\ c _ -> b c) b
17:26:05 <newsham> ?type \a b -> a (\ c _ -> b c) b
17:26:06 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
17:26:51 <newsham> *hmms*
17:27:44 <newsham> ?djinn ((a->b->r)->(a->b)->r)->(a->b)->r
17:27:44 <lambdabot> -- f cannot be realized.
17:28:11 <EvilTerran> ?djinn ((a->b->r)->(a->b)->r)
17:28:11 <lambdabot> -- f cannot be realized.
17:28:31 <Mitar> i am using parsec and i check some things (like identifier uniqueness) while parsing, but when i use "fail" to fail, it prints also some "expected" and "unexpected" error messages which are not correct at that point
17:28:46 <newsham> ?djinn ((a->b->r)->(a->r)->c)->(a->r)->c
17:28:46 <lambdabot> f a b = a (\ c _ -> b c) b
17:28:59 <EvilTerran> Mitar, have a look at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#err
17:29:04 <newsham> ahh,so...  c==r for callcc
17:29:12 <newsham> or rather c::r
17:29:23 <Mitar> i have ...
17:29:49 <EvilTerran> meh
17:29:49 <Mitar> but it does not help ...
17:30:14 <hpaste>  (anonymous) annotated "Stolen Fast Prime list" with "(no title)" at http://hpaste.org/4178#a1
17:30:16 <EvilTerran> @index ErrorT
17:30:16 <lambdabot> Control.Monad.Error, Control.Monad.Error
17:30:21 <EvilTerran> could use that
17:30:47 <Mitar> so for example, i have a do {i <- identifier; if some_check then fail "error" else return i}
17:30:48 <EvilTerran> although you'd want to use Parsely as well, i imagine, to get auto-lifting of the parsec methods
17:31:04 <ddarius> No, c :: a -> (b -> r) -> r
17:31:31 <ddarius> Er sorry, c :: a
17:31:57 <newsham> t::a, t1::b->r, t2::r, t3::r
17:32:02 <Mitar> but that fail does not work as expected - i would like that position of an error is at identifier and not after it
17:32:11 <newsham> ?type \a b -> a (\ c _ -> b c) b
17:32:12 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
17:32:17 <newsham> in that type
17:32:17 <Mitar> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html << why this does not work/
17:32:18 <lambdabot> http://tinyurl.com/sw72f
17:32:52 <newsham> err, wrong notation..  i meant "::" to mean "same type"
17:33:50 <EvilTerran> Mitar, what about get/setPosition?
17:34:12 <ddarius> a :: (t -> t1 -> t2) -> (t -> t2) -> t3, b :: t -> t2, c :: t
17:34:30 <EvilTerran> try (do {i <- identifier; if some_check then fail "error" else return i}) may move the claimed location of the error, too
17:34:36 <newsham> i was trying to figure out how that tyupe lines up with the type for callCC
17:34:47 <EvilTerran> i'm not familiar with the exact details of the quirks of the error reporting
17:35:02 <Mitar> yes, but the question is how does the library itself do it? i am checking the code and i do not see any "strange" ge/setPosition there
17:35:09 <newsham> ie this type ((a->(b->r)->r)->(a->r)->r)->(a->r)->r
17:35:15 <EvilTerran> ... what library?
17:35:36 <EvilTerran> parsec?
17:35:47 <Mitar> yes
17:35:49 <Olathe> Arrrr !
17:36:24 <hpaste>  wli annotated "Stolen Fast Prime list" with "JFP true Eratosthenes" at http://hpaste.org/4178#a2
17:36:45 <EvilTerran> i don't know what you mean by "how does it do it?" -- you shouldn't need to know the (undoubtedly somewhat confusing) internals to use it
17:36:57 <Mitar> ok, try moved it back ... :-)
17:37:54 <Mitar> no, but i am trying to replicate its error reporting techniques also for other uses and not just for parsing errors
17:37:56 <EvilTerran> that's handy to know; it was a bit of a guess
17:39:04 <Mitar> but it still shows the "other" error messages (but not the same anymore, now are the ones one level up)
17:40:52 <Mitar> for example, before i was mathing: identifier ( params )
17:40:53 <newsham> wli: whats (3-1)*(5-1)*(7-1)?  a totient of something?
17:41:06 <Mitar> and was reporting: unexpected "("
17:41:13 <newsham> ah, totient(210)
17:41:32 <Mitar> now it reports the other possibility (after identifier) at that point
17:41:50 <wli> Yeah. It's supposed to be more recognizable than the result itself.
17:45:00 <newsham> i'm not a math person. :(
17:45:28 <newsham> whats the wheel business?
17:46:39 <wli> It's a list of offsets. Basically scanl (+) 2 wheel will give you all the numbers relatively prime to 210
17:47:43 <wli> scanl (+) 11 wheel will give you all the numbers relatively prime to 210
17:48:21 <newsham> thats the spin wheel 11 bit?
17:48:34 <wli> Basically yes.
17:48:34 <newsham> wait, you just offset it all by 11 there
17:48:55 <wli> 11's the first besides 1
17:50:03 <gwern> gott ver dammt. the web form is dead, my emails are being bounced... is there any other way to contact whoever is in charge of community.haskell.org?
17:50:14 <Olathe> What's the fastest Haskell prime list ?
17:50:30 <Olathe> Any ooh-shiny! Atkin sieves ?
17:50:45 <wli> I tried and failed.
17:51:08 <EvilTerran> Olathe, download from http://www.primegrid.com/, then it's O(1) :P
17:51:09 <lambdabot> Title: PrimeGrid
17:51:16 <Olathe> EvilTerran: :)
17:54:14 <davidL> Olathe: O'Neil's sieve is pretty good
17:54:21 <wli> Atkins sieves are difficult to adjust to lazy functional contexts.
17:54:42 <wli> I can't figure out how to rip out the bounded array assumptions.
17:55:06 <wli> davidL: Never heard of it. URL?
17:55:29 <davidL> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/19699/focus=19798
17:55:30 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2ru2z6
17:57:40 <wli> davidL: That's the author whose name I forgot for the Eratosthenes sieve I just hpasted.
17:58:10 <jdrake> I have an IO [FilePath] that I want to map over to return (FilePath, ClockTime), but the monads seem to get in the way. I notice that mapM needs a (a -> m b) function and [a], but my data is an IO [FilePath]. I am unsure how to proceed.
17:58:33 <dibblego> jdrake, maybe you want mapM_ ?
17:58:37 <dibblego> ?type mapM_
17:58:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:58:49 <jdrake> I need the list at the end.
17:59:00 <dibblego> then maPM?
17:59:02 <EvilTerran> jdrake, if you're trying to turn an (IO foo) into a foo, you can't
17:59:03 <davidL> it's what I use to generate primes, but I don't know how it compares to primegen which uses the sieve of atkin
17:59:03 <dibblego> ?type mapM
17:59:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:59:38 <dibblego> ?type liftM
17:59:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:59:59 <EvilTerran> but you can pretend to with monad combinators, or do{} blocks
18:00:04 <dibblego> ?type flip liftM (undefined :: IO [FilePath])
18:00:04 <lambdabot> forall r. ([FilePath] -> r) -> IO r
18:00:09 <wli> davidL: Where's primegen?
18:00:13 <jdrake> I essentially want to perform something like (IO [FilePath] -> [(FilePath, ClockTime)] (note that I do not know where IO would go in the last part.
18:00:24 <dibblego> jdrake, you won't escape the IO-ness
18:00:34 <jdrake> hmm, I would have to look up liftM
18:00:39 <davidL> wli: http://cr.yp.to/primegen.html
18:00:40 <dibblego> jdrake, to go IO [FilePath] -> [(FilePath, ClockTime)], use liftM
18:00:44 <dibblego> er
18:00:48 <dibblego> jdrake, to go IO [FilePath] -> IO [(FilePath, ClockTime)], use liftM
18:00:50 <EvilTerran> you'd probably end up with sth of type [FilePath] -> IO [(FilePath, ClockTime)]
18:00:55 <davidL> wli: it written in C though
18:00:56 <wli> davidL: Atkin sieves don't work the same way. You basically can't get the lazy lists of all primes unless they've worked miracles.
18:01:30 <jdrake> I am not fully able to see what something does by a spec.
18:01:31 <EvilTerran> and then you could have (listOfFilePaths >>= thisNewThing :: IO [(FilePath, ClockTime)])
18:01:45 <dibblego> you probably want to apply liftM to first get IO [FilePath] -> IO [ClockTime], then zip in liftM again
18:01:58 <jdrake> Where can I find liftM in the docs?
18:02:05 <dibblego> Control.Monad I think
18:02:05 <shachaf> Except that you should use fmap or (<$>), not liftM. :-)
18:02:06 <EvilTerran> @index liftM
18:02:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:02:13 <EvilTerran> @docs Control.Monad
18:02:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
18:02:21 <EvilTerran> wait, broken link...
18:02:31 <dibblego> and use fmap instead of liftM if you like (I do ;))
18:02:37 <EvilTerran> @go site:haskell.org control.monad
18:02:38 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Control-Monad.html
18:02:43 <dibblego> ?type flip fmap (undefined :: IO [FilePath])
18:02:43 <EvilTerran> meh
18:02:43 <lambdabot> forall b. ([FilePath] -> b) -> IO b
18:02:52 <shachaf> If you don't like fmap, you can at least use liftA. :-)
18:02:57 <davidL> wli: what do you mean? I was able to write a very unoptimized version of it, I don't see how lazyness matters
18:03:23 <EvilTerran> with the right alternative prelude, you could use (.)...
18:03:30 <wli> davidL: I don't see how you got a lazy list of all primes out of it.
18:03:48 <jdrake> I will look into liftM while I am on the way home. Thank you.
18:04:04 <newsham> ?src liftM --not too much to look into
18:04:04 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:04:12 <dibblego> jdrake, liftM is like map within a monad
18:04:16 <newsham> ?src liftM -- not too much to look into
18:04:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:04:19 <newsham> grr
18:04:22 <dibblego> ?type liftM
18:04:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:04:26 <newsham> ?src liftM
18:04:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:04:27 <dibblego> ?type map
18:04:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:04:36 <jdrake> I read descriptions in the documentation.
18:04:41 <newsham> <- broccoli brains
18:04:42 <dibblego> ew English
18:04:53 <jdrake> I have enough to try it now.
18:04:59 <newsham> > liftM (+3) (Just 8)
18:05:01 <lambdabot>  Just 11
18:05:20 <jdrake> Thank you again. bbl
18:05:24 <newsham> > liftM (++"EOF!") (readFile "/etc/passwd")
18:05:25 <lambdabot>  <IO [Char]>
18:05:25 <ddarius> liftM = fmap
18:05:35 <shachaf> @src liftM
18:05:35 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:05:37 <dibblego> jdrake, this might help http://arcanux.org/lambdacats/io-monad.jpg
18:05:56 <shachaf> jdrake: You can just use (>>=) or do-notation; there's nothing magical about liftM itself.
18:06:18 <dibblego> ?type ap
18:06:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:06:52 <EvilTerran> riddle me this; I presume ghc, say, has some arrangement of types under the hood for representing the AST of any haskell program it can parse, extensions or no
18:07:12 <EvilTerran> ... can we get at this, verbatim? if not, why not?
18:07:25 <sjanssen> EvilTerran: yes, see the GHC API
18:07:41 <SamB_XP> but you need to link GHC into your program, then
18:08:05 <davidL> wli: I can't seem to find what I wrote, but anyway, a lot of optimization needs to be done to the sieve of atkin for it be faster than the sieve of eratosthenes
18:08:20 <EvilTerran> makes sense
18:08:25 <newsham> depending on what you're trying to do, TH might be useful, too
18:09:01 <wli> davidL: But how did you get a lazy list of all primes out of it?
18:09:54 <shachaf> Hmm, linking GHC is bigger than I thought -- 20MB for "main = return ()".
18:10:28 <EvilTerran> newsham, i'm mostly just still sulking about Happy concatenating bits of haskell source together and expecting it to work predictably
18:11:41 <EvilTerran> now you mention it, using TH to put together a haskell EDSL for parsing could potentially work quite well
18:11:48 <EvilTerran> shame TH isn't finished :O(
18:11:50 <EvilTerran> *:(
18:12:42 <davidL> wli: I basically kept track of solutions to 4x^2+y^2, 3x^2+y^2, and 3x^2-y^2
18:13:53 <noobie> is there a way to use ur own error case instead of haskell in built, i am getting  Program error: Prelude.read: no parse nd it terminates my program, i just want it to print incorrect iput then continue
18:14:08 <wli> davidL: How's that help?
18:14:32 <nottha_k> how is the >>= operator different than function composition?
18:14:44 <Olathe> @src (.)
18:14:44 <lambdabot> (.) f g x = f (g x)
18:14:48 <Olathe> @src (>>=)
18:14:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:14:51 <Olathe> Lies.
18:15:12 <Olathe> >>= does whatever the monad wants to in addition to composition.
18:15:49 <ddarius> noobie: Use reads.
18:15:54 <Olathe> m >>= f is like (monad_after . f . monad_before) m
18:16:04 <noobie> how?
18:16:14 <davidL> wli: If the number of solutions to each quadratic is odd then the number is prime
18:16:16 <ddarius> :t reads
18:16:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:16:23 <noobie> i tried, but it doesn't seem to work
18:16:35 <byorgey> noobie: can you paste what you have so far?
18:16:35 <wellwisher> is there a way to map 'add' over 2 lists and returns a list?
18:16:38 <byorgey> @paste
18:16:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:16:39 <ddarius> > reads "3" :: [(Int,String)]
18:16:40 <lambdabot>  [(3,"")]
18:16:42 <ddarius> > reads "aou" :: [(Int,String)]
18:16:42 <lambdabot>  []
18:16:57 <Olathe> > zipWith (+) [1..10] [11..20]
18:16:57 <lambdabot>  [12,14,16,18,20,22,24,26,28,30]
18:17:07 <wellwisher> thanks
18:17:22 <noobie> i didi that
18:17:29 <Olathe> You're welcome.
18:17:41 <nottha_k> Olathe: oh. is that all there is to monads?
18:18:01 <Olathe> nottha_k: You can do weird stuff with them, but that's the basic idea as far as I've seen.
18:18:03 <davidL> wli: by "lazy" do you mean infinite list of primes?
18:18:29 <Olathe> Monads make it really easy to apply functions in weird ways.
18:18:46 <wli> davidL: Yes.
18:19:21 <davidL> wli: oh, my implementation had a limit, I don't see how that algorithm would work without one
18:19:55 <chessguy> @pl \x -> (x, y)
18:19:55 <lambdabot> flip (,) y
18:20:39 <shachaf> nottha_k: (>>=) is probabliy closer to (|>) = flip ($) than to (.)
18:20:45 <shachaf> @ty flip ($)
18:20:45 <lambdabot> forall a b. a -> (a -> b) -> b
18:20:47 <shachaf> @ty (>>=)
18:20:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:21:18 <shachaf> nottha_k: Other than (>>=), a monad needs return :: Monad m => m a -> a, and to satisfy the three monad laws.
18:21:25 <shachaf> @wiki Monads as computation
18:21:25 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
18:21:39 <dibblego> return :: a -> m a I think you mean
18:21:55 <dibblego> m a -> a, unsafePerformIO!
18:22:49 <shachaf> Oops.
18:22:54 <shachaf> @slap shachaf
18:22:54 * lambdabot is overcome by a sudden desire to hurt shachaf
18:26:07 <Olathe> @slap itself
18:26:07 <lambdabot> I don't perform such side effects on command!
18:26:12 <Olathe> O-o
18:26:28 <Olathe> @slap randomthingy
18:26:28 * lambdabot hits randomthingy with a hammer, so he breaks into a thousand pieces
18:26:32 <Olathe> @slap itself
18:26:32 * lambdabot places her fist firmely on itself's jaw
18:26:38 <davidL> @botslap
18:26:39 <lambdabot> Unknown command, try @list
18:26:41 <Olathe> her ?
18:26:46 <Olathe> lambdabot is a her ?
18:26:50 <Olathe> @slap herself
18:26:50 * lambdabot clobbers herself with an untyped language
18:26:51 <davidL> ?vixen What is your name?
18:26:51 <lambdabot> My name is Emily
18:26:59 <davidL> ?vixen asl?
18:26:59 <lambdabot> 19/f/California
18:27:05 <ddarius> Olathe: Yes.
18:27:09 <Olathe> ?vixen ?where ?where
18:27:12 <lambdabot> what?
18:27:17 <Olathe> Heh
18:34:31 <lament> @slap himself
18:34:31 <lambdabot> I don't perform such side effects on command!
18:34:51 <lament> i suppose a sex-change operation would be a pretty big side effect, yeah
18:38:26 <ikegami--> hello
18:39:00 <ikegami--> to emacsen users: here is a demo of dynamic expanding abbrev http://nschum.de/src/emacs/tempo-snippets/screencast/
18:39:18 <ikegami--> and it works on both Emacs21 and Emacs at the HEAD of CVS
18:39:43 <ikegami--> unfortunatelly, the tempo-snippets-mode cannot work Emacs22 because of a bug of Emacs
18:39:51 <ikegami--> anyway, it works with Haskell very well
18:40:14 <davidL> that is cool
18:49:32 <Saizan> ikegami--: what do you use it for with haskell?
18:50:57 <dons> ?users
18:50:57 <lambdabot> Maximum users seen in #haskell: 424, currently: 393 (92.7%), active: 9 (2.3%)
18:57:03 <hpaste>  chessguy pasted "Trying to roll my own zipper for Data.Tree...am i making it too complicated?" at http://hpaste.org/4186
18:57:16 <gwern> if I were writing a shell whose frontend took normal shell-like statements and also normal haskell and then compiled/ran them, how would I architect such a thing? using hs-plugins, the GHC API (whatever that is), or the xmonad model of recompiling and execing?
18:58:39 <wli> I don't read fiction.
18:59:19 <ddarius> chessguy: The transformation is mechanical.
18:59:57 <chessguy> ddarius, well, i'm planning on carrying around some extra state, too
19:00:08 <chessguy> which i'm calling s here
19:00:44 <chessguy> and i need to roll it myself, because i need to understand it
19:01:31 <dfeuer> Roll, roll, roll.
19:02:40 <ddarius> T = AxLT, dT = d(LT) = dLTxdT There you go.
19:02:54 <chessguy> huh?
19:03:07 <oerjan> chessguy: um, what is the unzippered tree this construction corresponds to?
19:03:20 <chessguy> unzipperd?
19:03:41 <oerjan> without zipper
19:03:51 <ddarius> chessguy: d is the derivative, we know what dL is (the zipper for lists) so we get TreeZipper = (ListZipper Tree,TreeZipper)
19:04:43 <chessguy> you're not making any sense, ddarius
19:04:52 <chessguy> oerjan, the zipper is for Data.Tree
19:05:32 <byorgey> chessguy: see the "differentiation of data types" section on http://en.wikibooks.org/wiki/Haskell/Zippers
19:05:32 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
19:05:46 <chessguy> oerjan, the Context has the tree itself, left siblings, right siblings, and the context of the parent
19:05:58 <ddarius> chessguy: http://citeseer.ist.psu.edu/472190.html
19:05:59 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts (Extended Abst ...
19:06:17 <noobie> how do  use reads on a list
19:06:42 <oerjan> oh right i didn't realize Tree /= TTree
19:07:15 <noobie> how do i use reads function to check a list of characters
19:07:41 <oerjan> noobie: check for what?
19:08:15 <Janni> G'evening.
19:09:07 <Janni> I need two replacements for Data.Map with different properties
19:09:11 <monochrom> check for parse errors (because reads has a way to report alternative parses and lack of parses)
19:09:22 <noobie> check for an inccorect iput
19:09:26 <noobie> input
19:09:38 <oerjan> right, an incorrect input gives an empty list back
19:09:45 <chessguy> oerjan, TTree = TraversableTree
19:10:06 <oerjan> > reads "notANumber" :: [(Integer,String)]
19:10:08 <lambdabot>  []
19:10:17 <Janni> One I need, has to be lazy, i.e. (null $ fromList [(x,x) <- [1,2..]]) should evaluate to False.
19:10:23 <oerjan> > reads "34ExtraJunk" :: [(Integer,String)]
19:10:23 <lambdabot>  [(34,"ExtraJunk")]
19:10:24 <noobie> i have created a data type data Col = Cy | By | Rd and so i want to check the users input
19:10:53 <Janni> The other has to do findMin in O(1).
19:11:07 <oerjan> noobie: i recall we helped you write the Read instance before
19:11:11 <Janni> Anybody knows an implementation of such data structures in haskell?
19:11:20 <noobie> it didn't work
19:11:32 <oerjan> huh? what was wrong with it?
19:11:50 <byorgey> noobie: I told you earlier today to paste what you have so far, and you didn't.
19:12:06 <noobie> i wrote it, but it seems haskell detects the internal Read function first, totally ignoring my check
19:12:08 <byorgey> it's kind of hard to help when you only ask vague questions and say things like "it didn't work".
19:12:10 <davidL> Doesn't the data need to be sorted to do findMin in O(1)?
19:12:13 <noobie> ok
19:12:42 <oerjan> noobie: um, if you write an instance yourself you _don't_ want to put deriving Read
19:12:44 <newsham> [16:15] < ddarius> > reads "3" :: [(Int,String)]
19:12:52 <ddarius> Janni: Check out Edison and the collections package, both of which should be available on hackage.
19:13:03 <sjanssen> Janni: isn't that impossible?
19:13:31 <sjanssen> Janni: how can you find the minimum element without consuming the entire input?
19:13:38 <noobie> i didn't
19:13:45 <oerjan> or did you perhaps get the instance syntax wrong?  the definition needs to be inside the where block of the instance declaration
19:13:52 <noobie> i even import Prelude hiding (read)
19:14:02 <oerjan> noobie: you _don't_ want to do that either
19:14:08 <Janni> ddarius: I will, thanks.
19:14:12 <oerjan> in fact that may be your problem
19:14:12 <byorgey> @paste
19:14:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:14:14 <davidL> if you assume it's sorted it's just head, I think
19:14:16 <byorgey> noobie: ^^^
19:14:19 <noobie> why?
19:14:20 <sjanssen> Janni: oh, you want two different data structures, never mind
19:14:25 <noobie> why?
19:14:31 <Janni> sjanssen: Yep, just wanted to tell you that....
19:14:38 <oerjan> because instance does not define a new read function, it overloads the one from the Prelude
19:14:57 <oerjan> oh, and you don't define read, you define readsPrec
19:15:08 <noobie> ???
19:15:15 <noobie> gonna paste what i have
19:15:36 <newsham> noobie needs a whole channel
19:17:39 <hpaste>  noob pasted "(no title)" at http://hpaste.org/4187
19:17:56 <noobie> there
19:18:03 <noobie> all of it cannot hold
19:18:20 <puusorsa> halp!
19:18:22 <puusorsa>      Expected type: StateT st1 (CGIT IO) (WebResult a)
19:18:22 <puusorsa>       Inferred type: StateT st1 (CGIT IO) a1
19:18:35 <oerjan> noobie: remove the Prelude import
19:18:43 <hpaste>  noob annotated "(no title)" with "scd piece" at http://hpaste.org/4187#a1
19:18:44 <puusorsa>     liftIO a = WebPage $ do { a'<-return a; lift.liftIO $ a }
19:19:16 <puusorsa> i have no idea if that makes any sense, been just juggling returns and lifts around and hoping for a miracle
19:19:20 <shachaf> puusorsa: a' <- return a === let a' = a
19:19:27 <oerjan> oh you actually try to write your own _read_?
19:19:47 <puusorsa> shachaf, thought so
19:20:04 <noobie> yes
19:20:09 <oerjan> ic it makes some sense then, except it would be better if you gave it another name
19:20:11 <puusorsa> it might've been other way around at some point
19:20:25 <noobie> ok
19:21:09 <noobie> i don't want to terminate the game when someone enters a wrong input but rather say "Incorrect input", then continue
19:21:34 <puusorsa> hm
19:21:35 <oerjan> oh! you cannot do it that way
19:21:35 <puusorsa> got it working
19:21:38 <puusorsa> weird
19:21:44 <oerjan> error always aborts
19:21:57 <puusorsa> or rather: got it to compile. now let's see ..
19:22:07 <puusorsa>     liftIO a = WebPage $ do { lift.liftIO $ liftM WebResult $ a }
19:23:31 <noobie> why??
19:23:45 <noobie> isn't there a way to change that
19:23:58 <byorgey> noobie: that's just what the error function does.
19:24:01 <oerjan> well you could use catch
19:24:15 <oerjan> but it would be better to use reads directly here
19:24:58 <byorgey> noobie: I think the best way is to incorporate the reading/checking directly into the code where you now compute results = map read (words guess).
19:25:02 <noobie> how does that work
19:25:33 <byorgey> noobie: computing something of type [Colors] cannot possibly involve printing any error messages.
19:26:13 <oerjan> start with using map reads instead
19:26:18 <noobie> can i check before it is read
19:27:07 <byorgey> if (some condition using map reads (words guess)) then ... do normal stuff ... else ... print a nice error message and call mmloop again.
19:27:13 <oerjan> now you want to check if _any_ of the resulting lists are empty.  It turns out the sequence function does what you want
19:27:17 <byorgey> something like that.
19:27:37 <noobie> o
19:27:39 <ddarius> The bot is acting up.
19:27:47 <ddarius> Or is it.
19:27:54 <noobie> o
19:27:55 <oerjan> > map reads (words "1 2 nonumber") :: [[(Integer,String)]]
19:28:00 <lambdabot>  [[(1,"")],[(2,"")],[]]
19:28:06 <ddarius> @google "type erasure"
19:28:07 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
19:28:42 <oerjan> > sequence $ map reads (words "1 2 nonumber") :: [[(Integer,String)]]
19:28:42 <lambdabot>  []
19:28:50 <oerjan> > sequence $ map reads (words "1 2 3") :: [[(Integer,String)]]
19:28:50 <lambdabot>  [[(1,""),(2,""),(3,"")]]
19:29:43 <noobie> well then thanks guys
19:29:48 <dons> ?bot
19:29:48 <lambdabot> :)
19:29:53 <dons> ?go haskell
19:29:54 <lambdabot> http://www.haskell.org/
19:29:54 <lambdabot> Title: Haskell - HaskellWiki
19:30:05 <byorgey> ?go dons
19:30:07 <lambdabot> http://profile.myspace.com/index.cfm?fuseaction=user.viewprofile&friendID=122219015
19:30:07 <lambdabot> Title: MySpace.com - D.O.N.S. - Hamburg, DE - Electro / House / Club - www.myspace.com/ ...
19:30:13 <oerjan> > map (map fst) . sequence $ map reads (words "1 2 3") :: [[(Integer,String)]]
19:30:16 <lambdabot>  []
19:30:31 <oerjan> er
19:30:39 <oerjan> > map (map fst) . sequence $ map reads (words "1 2 3") :: [[Integer]]
19:30:40 <lambdabot>  [[1,2,3]]
19:30:41 <byorgey> dons, bet you didn't know there's an Electro/House/Club group named after you
19:30:52 <dons> didn't know that!
19:31:18 <ddarius> Perhaps lambdabot doesn't like the fact that the first hit is on Java, or maybe it is the quotes.
19:31:25 <dons> you know, i was sitting on the train today coming home, next to elliott, and we had `par` code running in races on each others laptops :)
19:31:29 <ddarius> @google "haskell workshop"
19:31:31 <lambdabot> http://haskell.org/haskell-workshop/2006/
19:31:38 <ddarius> Must be the Java.
19:31:47 <sjanssen> @google java
19:31:47 <lambdabot> http://www.java.com/
19:31:49 <byorgey> dons: nerd! =)
19:31:58 <dons> seeing who could max out their dual core, and which kernel (linux v openbsd) was faster.
19:32:08 <dons> the openbsd laptop was faster on serial code, but failed on +N2
19:32:27 * dons <3 par
19:32:27 <ddarius> dons: Bah.  You need to make it so you can easily distribute all the computation across all your laptops.
19:32:32 <dons> :)
19:32:52 <dons> yeah, distributed haskell. that's probably no more than a couple of days work
19:32:54 <OceanSpray> three months of not touching Haskell has left me without the ability to decipher my own code.
19:33:10 <ddarius> Moral of the story, don't not touch Haskell.
19:33:34 <OceanSpray> Is there some sort of three hour crash course that'll get me refreshed enough to finish a project in 2 days or so?
19:33:39 <sjanssen> dons: you're joking, right?
19:33:45 <byorgey> OceanSpray: sure, it's called #haskell
19:33:52 <dons> sjanssen: oh, distributed haskell?
19:33:52 <gwern> dons: I've been trying to understand something. you said hs-plugins will probably always keep breaking until it's rewritten to use the GHC API - but what is it using if not the GHC api?
19:33:54 <sjanssen> I'm tempted to @remember that quote, hold you to your word :)
19:33:55 <ddarius> OceanSpray: Read the gentle introduction again.  That should take less than three hours.
19:34:03 <dons> sjanssen: please, no!
19:34:04 <OceanSpray> alrighty, gentle it is.
19:34:10 <sjanssen> dons: yeah, I don't think you can do it well in a couple days
19:34:36 <dons> i should have taken a photo of the crowded train with these two guys with dual core laptops number crunching
19:35:00 <gwern> OceanSpray: yeah, I know what you mean. :)  I no longer unstand how I wrote generateCapsQuick in <https://secure.wikimedia.org/wikipedia/en/wiki/User:Gwern/Permutations.hs>
19:35:00 <dons> killing daemons to try to extract more cpu time for the haskell threads
19:35:00 <lambdabot> https://secure.wikimedia.org/wikipedia/en/wiki/User:Gwern/Permutations.hs>
19:35:35 <OceanSpray> gwern, even with all those comments?
19:36:34 <gwern> OceanSpray: even :(
19:36:43 <jdrake> In formatCalendarTime, there is a parameter type TimeLocale, but I don't see anything describing what that is. Any ideas?
19:36:47 <byorgey> OceanSpray: note the comments don't actually talk about the implementation, just how fast it is =)
19:37:04 <OceanSpray> oh lol
19:37:16 <ddarius> gwern: Maybe you should have used names more meaningful than b and c.
19:37:29 <gwern> (it works, and quickly - I just don't understand how the fast version works anymore; it's a variation on a variation on a variation of 3 or 4 functions I wrote and then squashed together)
19:38:06 <ddarius> And wtf?!  You have (\a b -> ...) b c
19:38:07 <byorgey> gwern: and you probably used @pl, eh?
19:38:14 <gwern> ddarius: I don't think that would've helped a lot - I don't understand what b and c are doing, and names wouldn't magically grant me the insight, I don't think
19:38:32 <byorgey> jdrake: which module is this in?
19:38:40 <jdrake> System.Time
19:38:44 <ddarius> gwern: If they were named well (along with a and the -other- b) then that's exactly what they should do.
19:38:48 <gwern> byorgey: yes, actually, I did use @pl at various points
19:38:55 <byorgey> I knew it! =)
19:38:56 <jdrake> At the very end of the ghc page.
19:39:29 <oerjan> @quote @pl
19:39:29 <lambdabot> Tac-Tics says: In fact, @pl is a LB command that turns good Haskell INTO perl
19:39:40 <byorgey> jdrake: hmm... excellent question!
19:39:42 <Fullmoon> Is anyone aware of a guide for functional programming written for OOP guys?
19:39:50 <oerjan> jackpot :)
19:39:59 <jdrake> byorgey: I knew it!
19:40:02 <oerjan> @quote @pl
19:40:02 <lambdabot> Tac-Tics says: In fact, @pl is a LB command that turns good Haskell INTO perl
19:40:07 <dibblego> Fullmoon, How to Forget Everything you Think You Know About OO? :)
19:40:14 <dons> Fullmoon: hmm. that's a good question
19:40:18 <Fullmoon> dibblego: That sounds perfect :)
19:40:24 <dons> an introduction to (pure) fp for OO thinkers?
19:40:27 <dibblego> Fullmoon, alcomohol
19:40:41 <dons> yeah, dibblego's made this transition ok.
19:40:55 <dibblego> I wouldn't say I was an "OO guy" though
19:41:11 <ddarius> There are plenty of people here who were/are.
19:41:17 <byorgey> jdrake: ok, looks like it's from System.Locale
19:41:21 <dibblego> I started writing my own language, then realised I was reinventing some parts of Haskell
19:41:29 <dons> more general purpose trouble maker, eh dibblego ? :)
19:41:36 <dibblego> oh, I'm great at that!
19:41:46 <ddarius> I'm not sure what the qualifications of being an "OO guy" are.  I certainly was rather familiar with OO before learning Haskell.
19:41:57 <byorgey> jdrake: but it's not linked there for some reason.
19:42:03 <Fullmoon> I have a objective c / ruby background
19:42:15 <Fullmoon> For four years now, I think in objects :)
19:42:34 <jdrake> Fullmoon: [ObjectiveC damageBrain];
19:42:42 <byorgey> Fullmoon: I think the transition from OO to FP is pretty easy: just forget everything you know about OO.
19:42:48 <Fullmoon> jdrake: Havent wrote objc it in years
19:43:00 <byorgey> once you learn FP well, you can again start thinking about the way they are related =)
19:43:02 <jdrake> Neither have I :p
19:43:32 <byorgey> that approach served me well, at least.
19:44:21 <mtp> i might just be weird
19:44:42 <OceanSpray> Anybody here from Harvard University?
19:44:43 <mtp> but i can mostly-seamlessly switch between OO, concatentative, and functional
19:45:25 <byorgey> mtp: once you know them, that's not too weird.
19:45:26 <puusorsa> @undo WebPage $ do { lift.liftIO $ liftM WebResult $ a }
19:45:26 <lambdabot> WebPage $ lift . liftIO $ liftM WebResult $ a
19:45:42 <byorgey> the problem is when you try to fit what you're learning about one of them into your existing mental framework for another.
19:45:42 <dons> that's a lot of lifting, puusorsa
19:45:49 <mtp> oh
19:45:51 <mtp> true.
19:46:06 <puusorsa> i'm probably doing something wrong
19:46:17 <puusorsa> and if not, then then i'm doing the wrong thing right
19:46:37 <byorgey> puusorsa: writing some sort of monad transformer?
19:47:12 <puusorsa> instance MonadIO
19:47:12 <sjanssen> puusorsa: that code looks wrong
19:47:17 <oerjan> puusorsa: you shouldn't need lift.liftIO
19:47:47 <sjanssen> oh, writing a MonadIO instance, eh?  lift . liftIO is less questionable then
19:47:48 <oerjan> oh wait
19:47:54 <oerjan> of course :)
19:47:58 <puusorsa> i don't like how it looks either, but it works.
19:48:06 <byorgey> puusorsa: you can't just have ghc derive it for you?
19:48:08 <puusorsa> so can't be all wrong
19:48:12 <sjanssen> puusorsa: what's the defn. of WebPage?
19:48:15 <puusorsa> byorgey, wish i could
19:48:23 <puusorsa> tried and it insulted me
19:48:44 <puusorsa> WebPage :: StateT st (CGIT IO) (WebResult a) -> WebPage st a
19:48:48 <sjanssen> puusorsa: what was the error message?  Have you turned on the necessary extensions?
19:49:01 <puusorsa> just a sec
19:49:17 <sjanssen> yeah, MonadIO deriving won't work there
19:49:25 <sjanssen> is WebResult a Monad?
19:49:39 <puusorsa>     Can't make a derived instance of `MonadIO (WebPage st)'
19:49:39 <puusorsa>       (even with cunning newtype deriving:
19:49:39 <puusorsa>        the eta-reduction property does not hold)
19:49:39 <puusorsa>     When deriving instances for `WebPage'
19:49:43 <puusorsa> sjanssen, no
19:50:07 <oerjan> puusorsa: just change those $'s into .'s and remove the a and you should be point-free i guess
19:50:25 <puusorsa> @pl WebPage $ lift . liftIO $ liftM WebResult $ a
19:50:25 <lambdabot> WebPage (lift (liftIO (fmap WebResult a)))
19:50:33 <sjanssen> WebPage . liftIO . liftM WebResult $ a -- puusorsa, this should work
19:50:47 <byorgey> @type lift
19:50:48 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:50:49 <sjanssen> I'd also use fmap there, but that's just me :)
19:51:38 <dons> hah
19:52:07 <dons> :t <$> forever !
19:52:08 <lambdabot> parse error on input `<$>'
19:52:15 <dons> :t (<$>) forever (!)
19:52:16 <lambdabot> Not in scope: `forever'
19:52:24 <dons> ?let forever a = a >> forever a
19:52:26 <lambdabot> Defined.
19:52:26 <dons> :t (<$>) forever (!)
19:52:26 <lambdabot> Not in scope: `forever'
19:52:30 <dons> ah right
19:52:33 <oerjan> forever has not yet happened
19:53:07 <dons> (<$>) forever (!) :: (Ix i) => Array i e -> i -> ()
19:53:54 <gwern> do .hi files preserve type information?
19:54:02 <sjanssen> yes
19:54:36 <gwern> actually, what's in .hi files? I thought they held Core, but they look like jibberish
19:54:59 <sjanssen> i stands for interface
19:55:09 <sjanssen> it describes the interface for that module
19:55:37 <gwern> I see
19:55:45 <jcreigh> it's like a .h file for C, except GHC makes it for you automatically.
19:57:20 * dons sees if http://darcs.haskell.org/packages/ndp/ builds with 6.8
19:57:20 <lambdabot> Title: Index of /packages/ndp
19:57:36 <dons> "But now I have got a working compiler on FreeBSD-amd64-7.0. If anybody is
19:57:36 <dons> interested, I shall prepare a package of the installed binaries."
19:57:42 <dons> who was looking for that recently?
19:59:02 <puusorsa>     liftIO = WebPage . liftIO . liftM WebResult
19:59:11 <puusorsa> now it looks nicer <3
20:00:42 <dons> mrd: which ghc did you build the ndp package with?
20:00:57 <dons> i guess a head branch?
20:00:58 <dons> "ghc-6.8.1.20071117: panic! (the 'impossible' happened)
20:00:58 <dons>   (GHC version 6.8.1.20071117 for x86_64-unknown-openbsd):
20:00:59 <dons> 	vectorise/Vectorise.hs:(303,0)-(327,78): Non-exhaustive patterns in function vectAlgCase"
20:01:02 <dons> :)
20:01:22 <dons> i just want /tmp/ndp/Data/Array/Parallel/Unlifted/Flat
20:01:31 <chessguy> @type randomR
20:01:32 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:01:45 <mrd> hey
20:01:51 <mrd> whats up
20:01:56 <byorgey> hey mrd
20:02:01 <chessguy> @hoogle arbitrary
20:02:02 <lambdabot> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
20:02:02 <lambdabot> Test.QuickCheck.Arbitrary :: class Arbitrary a
20:02:02 <lambdabot> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
20:02:07 <mrd> i checked out ghc head
20:02:41 <mrd> i haven't seen that error
20:02:56 <oerjan> puusorsa: btw i guess if you define MonadTrans first then i think you just get liftIO = lift . liftIO
20:03:48 <oerjan> usually
20:05:34 <oerjan> which considering this as refactoring, may mean you want lift = WebPage . liftM WebResult
20:08:25 <ddarius> :t callCC
20:08:26 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:09:50 <chessguy> @type randomR
20:09:50 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:10:39 <chessguy> man i hate random numbers in haskell
20:10:52 <dons> whatcha looking for chessguy ?
20:11:21 <dons> > randomRs (1,6) (mkStdGen 42) :: [Int]
20:11:22 <hpaste>  jdrake pasted "Monadic Problem" at http://hpaste.org/4188
20:11:25 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
20:11:38 <jdrake> help help I am being repressed by monads!
20:11:43 <Olathe> :t randomRs (1,6) (mkStdGen 42)
20:11:44 <lambdabot> forall t. (Num t, Random t) => [t]
20:11:45 <chessguy> randomInt :: Int -> Int -> IO Int, that will give me a random number in the closed interval from the first 2 parames
20:11:52 <chessguy> s/mes/ms/
20:12:00 <dons> glguy: did you know about meerten's number?
20:12:04 <jdrake> It is ugly, but I am trying to understand what is happening in my paste.
20:12:07 <glguy> I'd heard of it :)
20:12:11 <glguy> too many
20:12:17 <glguy> "e"s though :)
20:12:21 <chessguy> and i don't want to have to give a seed
20:12:30 <mrd> is Data.Array.Parallel.Unlifted.Flat even unhidden?
20:12:40 <dons> chessguy: ok, so that's easy enough.
20:13:30 <chessguy> so it's just randomRs (1,6) newStdGen?
20:13:36 <chessguy> @type randomRs
20:13:37 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
20:13:51 <chessguy> err
20:14:00 <chessguy> newStdGen >>= randomRs (1,6)
20:14:00 <glguy> newStdGen is in IO though
20:14:10 <glguy> and randomRs isn't
20:14:22 <chessguy> @type newStdGen >>= randomRs (1,6)
20:14:22 <dons> chessguy: randomInt = curry randomRIO
20:14:23 <lambdabot>     Couldn't match expected type `IO' against inferred type `[]'
20:14:23 <lambdabot>       Expected type: StdGen -> IO b
20:14:23 <lambdabot>       Inferred type: StdGen -> [t]
20:14:23 <glguy> randomRs (1,6) `fmap` newStdGen
20:14:28 <glguy> or:
20:14:31 <glguy> randomRIO (1,6)
20:15:14 <chessguy> @hoogle randomRIO
20:15:14 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
20:15:31 <dons> :t curry Random.randomRIO
20:15:32 <lambdabot> forall a. (Random a) => a -> a -> IO a
20:15:56 <mtp> @pl square x = x*x
20:15:56 <lambdabot> square = join (*)
20:16:06 <mtp> Hmm
20:16:13 <mtp> how do i retrieve the definition of join?
20:16:15 <chessguy> is that interval closed?
20:16:31 <glguy> ?src join
20:16:31 <lambdabot> join x =  x >>= id
20:16:44 <dons> *Main> randomInt 1 2
20:16:44 <dons> 1
20:16:44 <dons> *Main> randomInt 1 2
20:16:46 <dons> 2
20:16:54 <chessguy> @pl \x y -> abs (x - y)
20:16:54 <lambdabot> (abs .) . (-)
20:17:17 <davidL> @type randomInt
20:17:18 <lambdabot> Not in scope: `randomInt'
20:17:53 <Olathe> @unpl (abs .)
20:17:53 <lambdabot> (\ a d -> abs (a d))
20:19:10 <Olathe> @unpl (abs .) . (-)
20:19:10 <lambdabot> (\ d g -> abs (d - g))
20:19:26 <Olathe> @unpl (f .) . g
20:19:26 <lambdabot> (\ d i -> f (g d i))
20:19:46 <Olathe> @unpl f . g
20:19:46 <lambdabot> (\ c -> f (g c))
20:19:53 <dons> chessguy: problem sorted?
20:20:01 <chessguy> dons, yes, thanks
20:20:08 <dons> cool cats
20:20:14 <chessguy> as usual, i was making it ridiculously complicated
20:20:26 <Olathe> @pl \a b c -> f (g a b c)
20:20:26 <lambdabot> ((f .) .) . g
20:20:28 <dons> haskell can be a tricky mistress
20:20:32 <glguy> > randomR (1,0) 0
20:20:33 <lambdabot>  Add a type signature
20:20:39 <glguy> > randomR (1,0) 0 :: Int
20:20:39 <lambdabot>  Couldn't match expected type `Int' against inferred type `(t, t1)'
20:20:46 <glguy> > randomR (1,0) 0 :: (Int,Int)
20:20:46 <lambdabot>   add an instance declaration for (RandomGen Int)
20:20:46 <lambdabot>     In the expression: rand...
20:21:00 <glguy> > randomR (1,0) (mkStdGen 0)
20:21:02 <lambdabot>  (1,40014 40692)
20:21:14 <Olathe> @unpl (f .)
20:21:14 <lambdabot> (\ a d -> f (a d))
20:21:26 <glguy> > randomR (3,1) (mkStdGen 0)
20:21:26 <lambdabot>  (3,40014 40692)
20:21:45 <oerjan> :t formatCalendarTime
20:21:45 <lambdabot> Not in scope: `formatCalendarTime'
20:22:14 <oerjan> :t Data.Time.formatCalendarTime
20:22:15 <lambdabot> Couldn't find qualified module.
20:22:28 <oerjan> @hoogle formatCalendarTime
20:22:29 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
20:22:47 <oerjan> @hoogle defaultTimeLocale
20:22:47 <lambdabot> Locale.defaultTimeLocale :: TimeLocale
20:23:23 <Olathe> ((abs .) . (-)) a b -> (abs .) (a -) b -> (abs . (a -)) b
20:23:26 <oerjan> jdrake: seems like your problem with that line is that none of those things actually are monadic.  use let ... = ... and map instead of <- and mapM
20:24:26 <chessguy> @type Int -> a -> [a] -> [a]
20:24:26 <lambdabot> parse error on input `->'
20:24:34 <chessguy> @hoogle Int -> a -> [a] -> [a]
20:24:34 <lambdabot> No matches, try a more general search
20:24:53 <jdrake> oerjan: I am not fully familiar with let
20:25:44 <jdrake> :. I get 100% what you are saying to do.
20:26:16 <oerjan> jdrake: let is pure, <- is monadic
20:26:37 <jdrake> oerjan: But all of the stuff I am doing has IO attached to it
20:26:50 <oerjan> jdrake: except that line
20:27:12 <oerjan> so you use let to insert a pure definition in an otherwise monadic do expression
20:27:37 <hpaste>  oerjan annotated "Monadic Problem" with "try this" at http://hpaste.org/4188#a1
20:28:40 <jdrake> ok, that is what I was just thinking from what you said. I will hope :P
20:29:27 <jdrake> Well, it compiles, it just doesn't seem to 100% work (the time is all printed as F)
20:29:31 <glguy> http://hpaste.org/4188/diff?old=0&new=1
20:29:59 <oerjan> perhaps %F is not supported
20:30:26 <pkrumins> I just found haskell video lectures (http://blip.tv/file/324976), anyone knows more haskell video lectures?
20:30:32 <pkrumins> (those are just two intro lectures!)
20:30:44 <araujo> pkrumins, new to haskell?
20:30:50 <pkrumins> yup
20:30:53 <pkrumins> (but not new to fp)
20:30:56 <SamB_XP> there is a page on the wiki with links to videos...
20:31:01 <ddarius> http://www.haskell.org/haskellwiki/Video_presentations
20:31:01 <lambdabot> Title: Video presentations - HaskellWiki
20:31:08 <pkrumins> great, thank you!
20:31:09 <araujo> pkrumins, good, i recommend you to visit haskell.org
20:31:27 <araujo> that's the main site with the most important links for the community
20:31:43 <pkrumins> thank you araujo, i am already exploring the site!
20:32:14 <araujo> bunch of docs, papers, applications sites, lambdas cookies etc
20:32:18 <araujo> pkrumins, welcome
20:32:25 <jdrake> You are right, %F doesn't work.
20:32:34 <SamB_XP> araujo: where can I order cookies?
20:33:14 <araujo> SamB_XP, you have been around here for a while now ... you should know that
20:33:19 <araujo> :-)
20:33:39 <SamB_XP> I know shapr sometimes tosses me some sugar lambdas
20:33:45 <SamB_XP> but I don't know how to order cookies
20:33:56 * araujo throws some cookies at SamB_XP 
20:34:07 <glguy> ?quote cokkie
20:34:07 <lambdabot> No quotes match.
20:34:10 <glguy> ?quote cookie
20:34:10 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
20:34:58 <dons> ?seen vegai
20:34:58 <lambdabot> I haven't seen vegai.
20:35:53 <oerjan> jdrake: yep, i am looking at the haskell source for formatCalendarTime that comes with hugs, and it does not mention %F
20:36:50 * shapr throws sugar lambdas to SamB_XP
20:37:04 * SamB_XP eats up
20:37:40 <jdrake> Now, I wouldn't mind cleaning this up a little bit. I also would like to get it into a list of tuples like [(FilePath, CalendarTime)]
20:39:02 * glguy wonders:  xs@(_:_) <- foldr (\x xs -> xs `seq` x:xs ) [] `fmap` readFile "whatever"
20:39:41 <jdrake> I noticed a list comprehension syntax, but it doesn't seem support a 1:1, instead it does some kind of product.
20:39:54 <glguy> (I know that doesn't work so well on empty files)
20:40:09 <oerjan> jdrake: you may try zip and zipWith
20:40:22 <jdrake> ok
20:40:49 <jdrake> With those two mapM operations I am doing for times and times2, is it possible to merge those into one?
20:40:51 <oerjan> jdrake: would you like to have the times printed interleave with the file names?
20:40:56 <Plareplane> is there a way to clear individual bindings in ghci instead of :reload to clear all of them?
20:40:58 <oerjan> *interleaved
20:41:08 <jdrake> oerjan: yes, I was planning for that next.
20:41:32 <oerjan> in which case you may want to have just _one_ mapM
20:41:48 <oerjan> and a "pipeline" for each file inside it
20:42:00 <oerjan> which may also give you your tuples easily
20:42:12 <jdrake> hmm, I do not understand
20:42:50 <chessguy> @type ord
20:42:51 <lambdabot> Char -> Int
20:43:23 <chessguy> @pl \x y -> a (o x - o y)
20:43:23 <lambdabot> (a .) . (. o) . (-) . o
20:43:30 <chessguy> sheesh
20:44:44 <hpaste>  oerjan annotated "Monadic Problem" with "combine mapM's" at http://hpaste.org/4188#a2
20:45:02 <oerjan> argh, i annotated the wrong version :)
20:46:37 <hpaste>  oerjan annotated "Monadic Problem" with "correction" at http://hpaste.org/4188#a3
20:52:33 <oerjan> jdrake: it is also possible to use =<< to combine time and time2 even further:
20:52:56 <oerjan> time2 <- toCalendarTime =<< getModificationTime file
20:54:09 <gwern> man, the GHC api has such weird behaivour! suppose you have the totally innocous line 'session <- GHC.newSession (Just path)' to set everything up, and path is something like '/home/gwern/bin/ghc-6.8', GHC API apparently insists on the package.conf being located at /home/gwern/bin/ghc-6.8/driver/package.conf.inplace'!
20:54:27 <oerjan> (btw forM_ is the same as mapM_ just with arguments swapped, it reads better in this case)
20:54:57 <jdrake> ok, I will have a question in a moment :p, I am just going through it now
20:55:58 <shachaf> gwern: I don't think so.
20:56:05 <Lemmih> gwern: Is that a problem? GHC(i) is using the same api so it should just work.
20:56:35 <jdrake> ok, I am unsure how $ works in forM_ files $ \file -> do
20:56:48 <shachaf> gwern: session <- newSession (Just "/usr/local/lib/ghc-6.9.20071128") -- Seems to work, but /usr/local/lib/ghc-6.9.20071128/driver doesn't exist.
20:56:56 <oerjan> @src $
20:56:56 <lambdabot> f $ x = f x
20:57:06 <gwern> Lemmih: I probably should investigate how ghci is avoiding it, yes
20:57:09 <jdrake> Is it a way of avoiding some brackets?
20:57:13 <oerjan> here $ is just a trick to avoid needing parentheses
20:57:17 <gwern> shachaf: how do you mean?
20:57:18 <chessguy> @type replicateM 10 $ randomRIO (1,6)
20:57:19 <lambdabot> forall a. (Num a, Random a) => IO [a]
20:57:26 <gwern> (the first one, not the second)
20:57:41 <jdrake> ok, now \file -> do   is an anonymous function isn't it?
20:57:47 <oerjan> yep
20:58:07 <jdrake> file being a parameter?
20:58:22 <oerjan> right
20:58:33 <jdrake> So essentially for everything in files, do these operations with the current item being file.
20:58:41 <oerjan> exactly
20:58:56 <jdrake> I can be cleaver just before midnight :p
20:59:20 <jdrake> Now to be sure about a few items...   The type of time2 is IO CalendarTime isn't it?
20:59:31 <oerjan> just CalendarTime
20:59:49 <gwern> shachaf: suppose I set path to path = "/usr/bin" (because the system ghc is at /usr/bin/ghc), running session <- GHC.newSession (Just path) yields 'ghc-6.8.1.20071117: Can't find package.conf as /usr/bin/driver/package.conf.inplace'
21:00:41 <jdrake> Now getModificationTime returns IO ClockTime, so how can toCalendarTime discard IO?
21:00:49 <shachaf> gwern: It must look in other place too.
21:00:58 <shachaf> gwern: It doesn't want the path to the GHC binary, though.
21:01:06 <shachaf> gwern: Try "/usr/share/ghc-something", maybe.
21:01:23 <oerjan> jdrake: the IO was stripped off by the <- so to speak
21:02:38 <jdrake> The place where that let is, seems to mess with my sense of style. Is there another way of formatting that?
21:03:23 <oerjan> not by itself
21:03:40 <oerjan> but you _can_ combine it with the others using liftM
21:04:01 <jdrake> hmm, I might give that a shot.
21:04:03 <oerjan> well, depends what style you want i guess
21:04:16 <jdrake> I think I am going to call it a night.
21:04:40 <oerjan> good night :)
21:04:46 <jdrake> Thank you very much sir.
21:05:08 <gwern> shachaf: there's nothing in /usr/share with a driver/ folder containing a package.conf
21:05:30 <shachaf> gwern: There doesn't need to be.
21:05:48 <shachaf> gwern: Of course, I meant lib/. :-)
21:05:51 <shachaf> Sorry.
21:06:24 <gwern> I think something is messed up here; SysTool.lhs says: 'GHC tells which of the two is the case by seeing whether package.conf
21:06:38 <gwern> is in TopDir [installed] or in TopDir/ghc/driver [inplace] (what a hack).'
21:07:38 <jdrake> Q: If a haskell program compiles, does that mean the only errors that can mess things up are logic errors?
21:08:15 <oerjan> no type errors
21:08:44 <oerjan> oh and IO errors are of course possible
21:08:49 <jdrake> yes
21:09:03 <jdrake> Which I shall have to look at tomorrow.
21:09:37 <oerjan> and memory can be awkward - you can certainly run out of it and sometimes haskell makes this worse
21:10:16 <jdrake> yes
21:11:09 <gwern> and there are always cases where the infrastructure has a bug even if your program is perfect
21:12:06 <P_D> I've got a bunch of winapi imports, some of which fall in DLLs GHC/GHCi don't normally load (advapi32.dll).  On linking it does not find the syms, even when I add -ladvapi32.  Any ideas?  Some name mangling option?
21:12:40 <darrint> I have two arbitrary things selected from a list. I want to operate on them, then make a new list with modified versions of those two things. In OO land I'd know the right way to handle this, but how in haskell?
21:13:24 <shachaf> darrint: Selected how?
21:14:31 <darrint> shachaf: Well, that's a good question. For now these will represent players in a card game. For one it's their "turn". For the second, they were picked by the first.
21:15:26 <shachaf> darrint: Maybe you can @paste something?
21:17:03 <hpaste>  darrint pasted "(no title)" at http://hpaste.org/4189
21:18:07 <darrint> shachaf: So in OO land I'd take references to the players and just modify their internal state. But I can't figure out the right idiom for haskell.
21:19:14 <shachaf> darrint: Are you asking how to modify the records?
21:19:21 * shachaf isn't sure what your question is, sorry.
21:20:34 <darrint> shachaf: Simple operations like, given two players, make new player objects with some cards swapped around. Easy enough.
21:20:52 <darrint> shachaf: Now take your new player records and put them back where they go in the game state. That's where I'm stuck.
21:21:50 <shachaf> game { players = newPlayers }?
21:22:48 <gwern> what is a literal Control-d? '\d' doesn't seem to work
21:23:06 <darrint> shachaf: Right, but there's four players. My card handling function only knew about two of them. Now I have to figure out where those two went. Maybe I'm not articulate enough yet.
21:23:06 <shachaf> gwern: ^D usually sends EOF.
21:24:32 <chessguy> > sum $ map (/ 96) [1..96]
21:24:34 <lambdabot>  48.5
21:26:20 <oerjan> darrint: you might want to write a modifyPair generic function
21:27:03 <darrint> oerjan: What would the type look like?
21:27:24 <chessguy> > sum $ map (/ 96) [2,2,3..96]
21:27:25 <lambdabot>  Parse error at "..96]" (column 24)
21:27:29 <chessguy> > sum $ map (/ 96) [2,2..96]
21:27:34 <lambdabot> Terminated
21:27:50 <kaol> > take 10 [2,2..96]
21:27:51 <chessguy> > sum $ map (/ 96) 2:[2..96]
21:27:52 <lambdabot>  [2,2,2,2,2,2,2,2,2,2]
21:27:53 <lambdabot>   add an instance declaration for (Num [a])
21:27:53 <lambdabot>     In the expression: 96
21:27:59 <oerjan> modifyPair :: Int -> Int -> (Player -> Player -> (Player,Player)) -> Game -> Game or something
21:28:10 <chessguy> > sum $ map (/ 96) $ 2:[2..96]
21:28:11 <lambdabot>  48.510416666666664
21:28:47 <oerjan> i guess it depends on what the pair handling function can change
21:29:06 <kaol> > take 10 ([2,1..96]::Int)
21:29:06 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
21:29:12 <kaol> > take 10 ([2,1..96]::[Int])
21:29:12 <lambdabot>  []
21:33:57 <oerjan> afk
21:38:44 <darrint> oerjan: Hmm... looks like I have to thread the indexes of the players, which is what I hoped to avoid. Maybe I should give the players "names" and put them in a smarter container.
21:58:43 <byorgey> @pl \t r -> t + ?x*r
21:58:43 <lambdabot> (line 1, column 13):
21:58:43 <lambdabot> unexpected "?"
21:58:43 <lambdabot> expecting space or simple term
21:58:49 <byorgey> @pl \t r -> t + x*r
21:58:50 <lambdabot> (. (x *)) . (+)
22:13:02 <jdrake> Is there a way to get the size of a file when you have a FilePath?
22:17:10 <P_D> good old fseek END, ftell?
22:18:03 <jdrake> That may not be appropriate as it requires opening the file, which on windows may be denied due to locking
22:18:26 <P_D> you're in luck: import System.Posix.Files as spf ; spf.fileSize $ spf.getFileStatus filepath
22:18:45 <P_D> um.. except IO monad
22:18:53 <P_D> spf.getFileStatus filepath >>= spf.fileSize
22:19:34 <P_D> of course that doesn't work on windows.
22:19:36 <jdrake> I do not have that module :p
22:20:20 <P_D> then you have to open the file and choose your access carefully, I think
22:20:32 <jdrake> Actually, there is a Win32 module.
22:20:37 <jdrake> I might be able to use that.
22:20:58 <jdrake> Is there any way of doing conditional compilation for a specific platform?
22:21:02 <P_D> if this is an operation that winapi really supports, then you can use the FFI
22:21:15 <P_D> cpphs
22:21:41 <rue> Anyone have a link or sufficiently short explanation about what is the idiomatic way to represent mutable data? Say, for example, if I wanted to implement an IRC server and wanted to associate possibly changing data like username etc. with a certain socket?
22:22:28 <jbalint> IORef?
22:22:39 <jdrake> P_D: Where might I find more info on this 'cpphs'?
22:22:43 <P_D> Control.Concurrent.MVar
22:22:45 <P_D> jdrake:  google
22:22:51 <jdrake> ok :p
22:22:53 <jdrake> Merci
22:23:33 <ddarius> rue: Different types of (mutable) information will be stored in different ways.
22:23:52 <rue> So looks like monads are the way to go, broadly, details vary? Anyone know of any functional approaches to the same problem?
22:24:44 <sorear> monads are function, what gave you the idea they weren't?
22:24:50 <sorear> *functional
22:25:38 <rue> Well, I do not mean it that way exactly.. let me rephrase: without monads, are there any approaches other than brute-forcing it?
22:25:44 <ddarius> For something per-socket like a username, I'd fork a thread to handle just that socket with it tail-calling itself and carry things like the username in the arguments.
22:26:09 <ddarius> rue: What is "brute-forcing" it?
22:26:42 <hpaste>  srid pasted "why is this case expression not working?" at http://hpaste.org/4190
22:26:55 <rue> ddarius: Completely recreating the data structure with the new data
22:26:56 <srid> btw - hpaste's "remember me" does't really work
22:28:19 <ddarius> srid: That case expression doesn't work because it's syntactically invalid.  You are making up syntax.
22:28:51 <srid> ddarius: how do I, then, have a single action for multiple matches?
22:29:32 <ddarius> srid: There are ways of doing it, but there is no syntax for it.
22:29:49 <rue> ddarius: Say if I have   make_new sock, name, blah = ..., I can just apply different args to end up with a different data set. That would be brute-force
22:30:13 <ddarius> rue: Okay... what's wrong with that?
22:30:23 <rue> Excuse my invalid syntax, imperative mode has not been disengaged for tonight yet
22:30:49 <srid> ddarius: so what is the way?
22:32:00 <rue> ddarius: Nothing, necessarily! It may get expensive, though.. I was wondering if someone had a nifty trick for that type of approach. Monadic state seems like the more idiomatic approach, though, I suppose
22:33:04 <ddarius> srid: I didn't say there was -a- way, I said there are multiple ways.  The simplest (as in most primitive) is just to "duplicate" the branches (of course you can name the branch to avoid that duplication).  Alternatively, you could use a guard like case () of _ | name `elem` ["Simon","John","Phil"] -> ... and various variations on that.
22:33:21 <wli> It'd be nice if hpaste could search by author.
22:33:42 <srid> I am going with if-then-else.
22:34:41 <ddarius> rue: Why do you think it will get expensive?
22:35:05 <davidL> It'd be more nice if hpaste worked with HAppS 0.9.1. :-]
22:35:47 <srid> the emacs code (haskell-mode in debian) doesn't really indent well. for example, it doesn't indent nested ifs correctly. did anyone notice this?
22:36:39 <davidL> how does it indent them?
22:38:09 <srid> type this:
22:38:10 <srid> doFoo = do
22:38:10 <srid>   putStrLn "What is your name?"
22:38:10 <srid> and then press C-j near the end.
22:38:26 <srid> on next line, it is idented till the "Wh.."
22:38:36 <srid> .. instead of "pu.." as expected.
22:39:21 <ddarius> srid: My understanding is that it offers multiple indentations and you cycle through them.
22:39:32 <srid> I just need the "correct" one.
22:39:40 <ddarius> That indentation isn't incorrect as far as syntax goes.
22:39:57 <rue> ddarius: "Cumbersome" may be a better word and I do not really know, of course. I have not puzzled that approach out fully yet as an alternative
22:40:12 <srid> for eg., I will show you the code that gives syntax error (due to poor indentation)
22:41:03 <sorear> srid: there are multiple correct indentations.  please don't expect emacs to read your mind!
22:41:30 <srid> ddarius: sorear davidL http://hpaste.org/4191
22:41:58 <sorear> srid: that's not an indentation error
22:42:09 <notsmack> srid: you need an else
22:42:23 <ddarius> rue: Most Haskell code is written using little or no ST/IORefs, "recreating" stuff is how most code works.  However, since the language is pure, most can be shared and it just reduces to using a different pointer or, in most cases, recreating the path to the item.
22:43:17 <srid> hmm.. it worked for me without else.
22:43:29 <_|_> Gah! No wonder my parser using Data.Binary wasn't working. The file is all little endian numbers
22:43:30 <sorear> srid: also, why did you paste the URL?
22:43:38 <sorear> srid: just leave announce checked
22:43:42 <srid> ok
22:44:11 <sorear> _|_: that's not Data.Binary's fault, just use getWord32LE and friends
22:44:24 <srid> hpaste bug: 'remember me' is not working (it is unchecked everytime despite my checking it)
22:44:31 <sorear> WE KNOW
22:45:13 <srid> sorear: you do not have to shout.
22:45:33 <sorear> no.
22:46:24 <_|_> sorear: Yeah, I saw. I just wish there was a simple way. No I have to explicity do the get stuff for the tuples.
22:46:34 <sorear> _|_: huh?
22:46:42 <sorear> _|_: how is this more complicated?
22:47:07 <davidL> @src (_|_)
22:47:07 <lambdabot> Source not found.
22:47:09 <ddarius> sorear: He was hoping that the data would already be in Binary's serialization format.
22:47:45 <rue> ddarius: Right, I figure the runtime is fairly smart about that stuff. Alright, sounds good. I just was not able to google up a "this is how you write applications with data" tutorial :)
22:48:04 <_|_> I have things like: type Point = (Int32, Int32). I have to write some code now to explicity use little endian gets.
22:48:22 <_|_> *shrug* No biggie.
22:48:58 <sorear> rue: but I suggest you ditch the map and just fork threads like ddarius suggested
22:49:09 <sorear> rue: it will probably make the system rather simpler
22:50:05 <rue> sorear: Yeap, it seems like a good approach
22:55:22 <oerjan> darrint: (been away) yeah, Data.Map should be easy
22:58:20 <conal> sjanssen: ping
23:03:03 <glguy> when profiling, how might I break out time spent in other modules?
23:03:07 <glguy> data.Set for example
23:04:46 <TSC> You could add cost centre annotations before you call the functions
23:20:13 <sclv> Even if i want to go super low level and unsafe ghc internal, there's no way to mutate data in place without explicitly marshalling it into malloced bytes, right?
23:21:00 <ddarius> sclv: What are you talking about?
23:22:05 <sclv> I wrote a cleaner functional version of nbodies, and then played with the folds and soforth so that if I wanted to introduce mutation it would be restricted to a very tiny portion of the code.
23:22:06 <Nafai> Jon Harrop, is, um interesting: http://www.ffconsultancy.com/languages/ray_tracer/?reddit
23:22:07 <lambdabot> Title: Ray tracer language comparison
23:22:29 <sclv> But I think I'm going to have to implement mutable vectors somewhat like the current entry does anyway.
23:23:11 <ddarius> sclv: There are IOArrays, STArrays, IOUArrays, STUArrays without going to malloced arrays or malloced byte arrays.
23:23:13 <sclv> There's no way to write even a super-unsafe thing that takes, e.g.  something of type Vec !Double !Double !Double (unboxed, of course) and mutates those doubles in place.
23:23:47 <sclv> hmmm... yeah, i guess i could just use indexes into an STArray.
23:24:18 <ddarius> You -could- write such a thing, but it would break stuff almost certainly even if the stars aligned and the data was in the exact format you expected.
23:24:38 <sclv> ddarius: how could I do it?
23:25:20 <sclv> this isn't for sane best practices, but just for trying to squeeze performance for a benchmark, after all.
23:25:42 <ddarius> sclv: You don't want to do it even for that and it should not be necessary.
23:26:12 <sclv> well, sure, but for curiosity's sake...
23:26:44 <sclv> in actual fact i'll probably end up with an STArray.
23:27:36 * glguy wonders what the best way to determine if a "perfect square" (square of an integer)
23:28:04 <sclv> I don't even know of a way to get a reference to the memory address of that vector, so this is why I'm curious how it could be done.
23:28:30 <glguy> right now I'm using a newtonian iteration algorithm I found
23:28:34 <Taejo> glguy, I don't think there is a way to do it without finding the square root
23:28:45 <wli> glguy: I'm not 100% sure. I'd try maybe implementing isqrt.
23:29:02 <ddarius> @google site:hpaste.org isqrt
23:29:03 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
23:29:05 <glguy> (I'm using the "intSqrt" from http://polyomino.f2s.com/david/haskell/hs/NumberTheoryFundamentals.hs.txt)
23:29:06 <lambdabot> http://tinyurl.com/2tkr6y
23:29:08 <wli> Taejo: Prime factorization by non-square-using methods,but it's very slow.
23:29:43 <Taejo> wli, I meant "worth considering"
23:29:45 <wli> glguy: Looking.
23:30:34 <sclv> maybe for large values taking an approximate square root and then testing integral values close to it?
23:30:44 <sclv> using fancy maths to specify how close "close" should be?
23:30:56 <glguy> I'd like to avoid such an approximation..
23:31:09 <Taejo> sclv, well if you find the floor of the sqrt (isqrt) you only need to test that
23:31:15 <wli> glguy: I don't trust Newton iteration without bounds.
23:31:55 <glguy> Taejo: that is the case for small values
23:32:16 <Taejo> what is the case?
23:32:25 <glguy> that you only need to check the floor
23:33:07 <glguy> (assuming you mean on floats since a floor on an integer square root algorithm doesn't make sense)
23:33:44 <Taejo> well isqrt == floor . sqrt on reals
23:33:57 <Taejo> obviously not on floats
23:34:13 <glguy> :t sqrt
23:34:14 <lambdabot> forall a. (Floating a) => a -> a
23:34:18 <wli> Only where precision is sufficient. It's a good starting point.
23:34:54 <Taejo> that's why I said "on reals... not on floats"
23:42:03 <wli> > let isqrt' :: Integer -> Integer -> Integer -> (Integer, Integer) ; isqrt' n a b = let c = (a + b) `div` 2 ; guesses = a : b : c : filter (\x -> a < x && x < b) [(x*x + n) `div` (2 * x) | x <- [a, b, c]] in minimumBy (\(x,y) (x',y') -> (y - x) `compare` (y' - x')) [(x, y) | x <- guesses, y <- guesses, x*x <= n, y*y >= n] in take 10 $ iterate (uncurry $ isqrt' 27) (1,27)
23:42:05 <lambdabot>  [(1,27),(1,7),(5,7),(5,6),(5,6),(5,6),(5,6),(5,6),(5,6),(5,6)]
23:42:50 <sclv> > maxBound::Int
23:42:51 <lambdabot>  2147483647
23:43:22 <davidL> > maxBound::Int * 2
23:43:22 <lambdabot>  Parse error at "*" (column 15)
23:43:31 <davidL> > (maxBound::Int) * 2
23:43:31 <lambdabot>  -2
23:47:17 <oerjan> perhaps (n+k)^2 - n^2 = 2*n*k + k^2 could be used to refine approximations somehow
23:47:57 <wli> Floating point needs some sophistication to help. Someone worked it out for me once.
23:48:29 <oerjan> i would think you only use that for getting an initial guess?
23:48:48 <wli> Yes. You still need some sophistication.
23:49:17 <P_D> floating point sqrt has no business being faster than integer
23:49:45 <ddarius> P_D: 80-bits v. 1024 say
23:50:12 <P_D> sure, if all you have is + and *.  which is an unfortunate limitation.
23:50:34 <ddarius> P_D: What are you talking about?
23:51:05 <wli> approxSqrt :: Integer -> (Integer, Integer) ; approxSqrt n = intervalize $ sqrt $ (fromIntegral n :: Double) where intervalize rt = (floor $ rt - diff, ceiling $ rt + diff) where diff = scaleFloat (1 - floatDigits rt) rt
23:51:11 <davidL> > bitSize (3::Double)
23:51:12 <lambdabot>   add an instance declaration for (Bits Double)
23:51:12 <lambdabot>     In the expression: bitSiz...
23:51:55 <P_D> doing the same algorithm as the floating point, but in fixed point, will be faster.  your fixed point ops don't need to mess with the insignificant bits to start out with, so 1024b is a red herring.  unless all your ops only touch all bits.
23:52:19 <Meldon> red herring
23:52:22 <Meldon> ?
23:52:23 <sclv> davidL: you need a function from Foreign
23:52:28 <P_D> same algorithm used loosely.
23:52:31 <wli> There is no fixed point. It's arbitrary-precision.
23:53:07 <oerjan> > floatDigits (undefined::Double)
23:53:09 <P_D> my argument is a generalization.
23:53:09 <lambdabot>  53
23:53:19 <P_D> fixed point specializes to integers.
23:53:24 <davidL> I see
23:53:30 <Meldon> P_D in this sense?: http://en.wikipedia.org/wiki/Red_herring
23:53:31 <lambdabot> Title: Red herring - Wikipedia, the free encyclopedia
23:53:39 <wli> P_D: To Ints, not Integers.
23:54:03 <P_D> wli:  Ok, well I meant arbitrary precision fixed point then.
23:54:08 <P_D> wli: do you disagree?
23:54:22 <wli> P_D: "Arbitrary-precision fixed point" is an oxymoron.
23:54:41 <P_D> wli: I don't think so, fixed point just means no exponent.
23:54:56 <P_D> wli: the mantissa is unspecified.  at least that's what I meant to say.
23:55:07 <P_D> meldon:  yes
23:55:08 <newsham> arbitrary precision fixed point is just an infinite stream of bytes with a fixed radix point
23:55:20 <wli> P_D: Then I disagree.
23:55:59 <P_D> wli: you think that GMP's integer square root could be faster if it used doubles to start out?
23:56:11 <P_D> (or is because it does)
23:56:43 <wli> P_D: Error estimates are required to produce upper and lower bounds to produce correct results when doing that.
23:57:20 <P_D> what is the relevance of error estimates?
23:58:10 <wli> P_D: floor and ceiling are insufficient to produce usable upper and lower bounds from floating point approximations to integer square roots.
23:58:57 <P_D> wli:  clearly.  it gives you <80b, and that's your starting point.
