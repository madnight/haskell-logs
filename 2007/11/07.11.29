00:00:05 * wli dredges
00:02:44 <olsner> @ty (\f g s x -> (f >>= g s) x)
00:02:59 <lambdabot> thread killed
00:04:05 <wli> It's on hpaste.org but I'm having trouble searching.
00:08:34 <Shimei> dons: Neat article. Upvoted from Canadia. :p
00:09:35 <dons> :)
00:10:06 <dons> now, how can we take advantage of this `par` stuff to get jobs and make money?
00:11:25 <Shimei> Use GHC on the PS3 Cell and do scientific computing. :)
00:11:39 * wli notes there is no way to search for all posts by a particular author on hpaste.
00:11:43 <Shimei> (read an article somewhere about a scientist preferring networked PS3s over his traditional clusters)
00:11:49 <ddarius> wli: Use google
00:12:08 <ddarius> dons: Actually that article is very handy and well timed.  It addresses several misconceptions.
00:12:08 <sjanssen> @google site:hpaste.org wli fibonacci
00:12:10 <lambdabot> No Result Found.
00:12:15 <sjanssen> @google site:hpaste.org wli fib
00:12:16 <lambdabot> No Result Found.
00:13:57 <dons> ddarius: hope so.
00:14:07 <wli> I am using google. It's useless.
00:14:56 <dons> were there  misconcepts other than memoisation, and pseq, ddarius ?
00:15:04 <sjanssen> wli: hpaste has lost its state at least once, your paste may be gone
00:16:00 <ddarius> dons: It presents the "you need the right granularity for threading" issue well.  Something with misconceptions surrounding it.
00:16:09 <Olathe> I hate the right alignment of post titles.
00:16:33 <dons> hmm, and yes, we see again and again "why can't the compiler just figure it out"
00:16:41 <dons> so we need to dip our toes into that a bit more
00:16:57 <dons> having dual core laptops should help the community get some more experience with this, i hope.
00:17:58 <dons> i suspect this divide and conquer, and splitting between straight, and `par` code, as sjanssen did, will be the model for a lot of pure code
00:18:05 <dons> a worker wrapper of sorts
00:18:31 <ddarius> dons: That is actually fairly well known, e.g. parallel skeletons and such.
00:18:37 <glguy> in the fibs case today, none of the Control.Parallel or Control.Parallel.Strategies stuff make the code faster
00:18:42 <glguy> (it did make it slower)
00:18:53 <ddarius> Of course, those routes were explored exactly because it was a model for a lot of code
00:18:54 <dons> ddarius: yeah. we just don't see your average programmer dealing with it
00:19:05 <dons> glguy: see the update
00:19:07 <sjanssen> glguy: it can make it faster, with some work
00:19:10 <glguy> ok
00:19:12 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core
00:19:13 <lambdabot> Title: Haskell hacking
00:19:13 <ddarius> dons: Not yet, and hopefully to a large part not too much later
00:19:21 <Philippa> I guess we can point folks at MapReduce and say "hey, guess what? Swap map for the parallel version and it works"
00:19:24 <Philippa> stuff like that
00:19:26 <sjanssen> the problem is that you need to avoid sparking piddly jobs like 'fib 2'
00:19:42 <dons> sjanssen: so that's just the cost of registering sparks, i think?
00:19:48 <dons> maybe that can be improved a bit.
00:19:51 <sjanssen> dons: yeah
00:20:00 <dons> there's been very very little testing (only satnam's work recently, afaik)
00:20:05 <dons> and he had a custom ghc
00:20:12 <sjanssen> actually, I've always wished for a "synchronous spark"
00:20:13 <dons> i should reread that paper again
00:20:37 <sjanssen> if a CPU is available, run this job immediately, otherwise forget about it
00:20:42 <ddarius> Anyway, I have about four hours until I need to get up and I don't fall asleep immediately.  See you all tomorrow.
00:20:45 <dons> glguy: one problem is that openbsd's scheduler sucks. i want some linuxes
00:20:50 <dons> glguy: do we have debian disks around?
00:20:55 <glguy> ?
00:21:14 <wli> I've manually searched and blown past it somewhere. I know I posted things I've seen before it.
00:21:24 <dons> glguy: it really doesn't like moving jobs around the 2nd core, (and openbsd's had very little smp perf. tuning)
00:21:29 <dons> its showing up in my haskell now
00:21:36 <wli> It should not be lost.
00:21:42 <dons> whereas if i go to a linux box, -N works very nicely indeed
00:21:43 <sjanssen> the latency with GHC's spark queue isn't so nice
00:21:57 <dons> sjanssen: can we get measurements for the cost of a spark?
00:22:06 <sjanssen> hmm
00:22:32 <glguy> no one is using debian in our group
00:22:50 <dons> oh. that was the last linux i used before i wandered off to bsd land
00:23:02 <dons> but now openbsd's smp is no good, and freebsd is ghc broken
00:23:06 <dons> so maybe its time to wander back
00:23:33 <wli> glguy: Do you run hpaste?
00:23:53 <dmwit> dons: Am I reading the blog post incorrectly?
00:24:03 <dmwit> In what way does Haskell outperform gcc?
00:24:06 <wli> I'm hoping whoever does can do grep -nri 'faster fibonacci' or something on things
00:24:07 * glguy is in the middle of a DDR course and has delayed response
00:24:13 <hpaste>  olsner pasted "folded, but not much simpler :(" at http://hpaste.org/4141
00:24:45 <dons> DDR oh my
00:24:48 <wli> DDR?
00:24:51 <dons> he was playing Guitar Hero at lunch
00:24:56 <lament> ddr course?
00:25:02 <olsner> Dance Dance Revolution
00:25:06 <lament> with like a teacher?
00:25:11 <Philippa> wli: you've probably missed the entire genre of games
00:25:16 <dons> we run courses for this at galois, yeah, lament
00:25:29 <Philippa> part of the fitness program? :-)
00:25:41 <dons> ddr is considered good for helping produce type correct programs
00:25:51 <dons> :)
00:25:53 <glguy> no, a series of games
00:25:56 <lament> still makes you look like a retard
00:25:56 <glguy> you play 4 in a row
00:25:59 <dmwit> dons: Oh, never mind me, you were measuring speed by the "total" (wall-clock) time.  got it
00:26:01 <glguy> little break time in between
00:26:07 <glguy> just enough to read and type one line
00:26:17 <glguy> wli, shapr runs the hapste server
00:26:20 <wli> http://www.scannedinavian.com:8000/1945
00:26:35 * olsner runs to work
00:26:35 <glguy> dons, we are using ubuntu, fedora, and arch linux in the group
00:26:39 <glguy> but debian is good too
00:27:17 <wli> I like gentoo's source stuff.
00:27:36 <glguy> I used to use gentoo at work
00:27:51 <glguy> I've also used debian and arch linux at work
00:27:59 <glguy> now I'm on fedora
00:28:15 <glguy> tried ubuntu when I first got my laptop, video support was no good at the time for this card
00:28:21 <dons> i couldn't find any snow, btw, glguy
00:28:30 <dons> :(
00:28:35 <glguy> :(
00:28:37 <glguy> news people lied
00:29:00 <wli> I got sleeted on on the way to electro.
00:29:02 <dons> well, it was kinda sleety,
00:29:08 <dons> yeah, i bet that's what it was
00:29:31 <glguy> maybe portland doesn't know what snow is?
00:29:55 <andyjgill> Back in my day, fib 25 took a long time.
00:30:06 <andyjgill> Not snowing on the east side right now.
00:30:06 <Shimei> Hardly ever snowed in Oregon when I was there.
00:30:20 <Shimei> I was a bit further South in the valley though...
00:30:47 <dons> andyjgill: :)
00:30:53 <dons> andyjgill: i've seen the mailing list from the early days
00:31:01 <dons> when ghc would come with an announcement of how many fibs you could now compute
00:31:05 <dons> per second :)
00:31:06 <andyjgill> Its 40 outside right now.
00:31:34 <dons> ok. bed time. night all
00:31:37 <andyjgill> I remember implementing a JIT for ML, where fib was a larger example.
00:32:02 <andyjgill> night dons
00:33:02 <jsnx> i would like to write to write a script that looks up a string in a web dictionary (using GET). do i need an additional library, or is something in the base libraries for GHC good enough?
00:33:54 <sjanssen> @hackage http
00:33:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/http
00:33:59 <sjanssen> oops
00:34:01 <sjanssen> @hackage HTTP
00:34:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
00:34:07 <sjanssen> jsnx: use that
00:34:28 <wli> > let { fib :: Int -> Integer ; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] ; fib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g } in fib 25
00:34:30 <lambdabot>  75025
00:35:06 <jsnx> does it make any difference that the string is UTF8 encoded Chinese?
00:35:27 <wli> Olathe: There's the "even faster" fib.
00:36:10 <Olathe> Thanks :)
00:36:13 <glguy> jsnx, depends what you intend to do with it
00:36:25 <glguy> if you want to just feed it back to the user as UTF-8, then do nothing
00:36:35 <glguy> if you want to manipulate it, try the utf8-string library
00:36:46 <wli> > let { crushDigits (!n) = let (q, r) = n `divMod` 10 in if q == 0 then r else crushDigits $ r + crushDigits q ; fib :: Int -> Integer ; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] ; fib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g } in crushDigits $ fib 999
00:36:46 <lambdabot>  Parse error in pattern at ";" (column 110)
00:36:55 <jsnx> well, the UTF-8 Chinese characters have to be URL encoded and sent to the dictionary in a GET variable
00:36:59 <int-e> dons: hmm, about measuring sparks. take your fib program. to calculate fib(n) it sparks fib(n+1) threads including the initial thread (this number can be calculated by  threads 0 = 1; threads 1 = 1; threads n = threads (n-1) + threads (n-2)). as a working assumption, almost all of these sparks are wasted - when they get to run they find a fully evaluated thunk. so as a first approximation I'd take the overhead introduced by adding the `par` and 
00:37:00 <dmwit> Surely the fastest fib around uses phi and exponentiation.
00:37:06 <wli> > let { crushDigits n = let (q, r) = n `divMod` 10 in if q == 0 then r else crushDigits $ r + crushDigits q ; fib :: Int -> Integer ; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] ; fib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g } in crushDigits $ fib 999
00:37:11 <lambdabot>  7
00:37:31 <int-e> dons, ... by adding the `par` and `pseq` and divide it by fib 47 (which is the sum of fib 1, ..., fib 46, plus 1)
00:37:53 <dmwit> int-e: There's a bit missing in the middle.
00:38:01 <wli> dmwit: Floating point conversion etc. gets nasty and slows it down. This is logarithmic and pure integer.
00:38:13 <dmwit> I see up to "take the overhead introduced by adding the `par` and"
00:38:50 <int-e> dmwit: yes, the rest is in the second message.
00:39:26 <glguy> jsnx, you don't need to know what the utf-8 means to url encode it
00:39:41 <wli> dmwit: GMP uses a very similar algorithm, based mostly on the same recurrence. There's a (-1)^n affair involved in gmp's.
00:39:47 <int-e> dmwit: (there's some overlap between the two)
00:39:49 <dmwit> int-e: Okay, sorry.  The grammar suggested there was more missing between the two messages.
00:40:09 <dmwit> o
00:40:43 <dmwit> wli: Okay, cool.  In any case, your version is *very* fast according to the hpaste.
00:43:45 <wli> dmwit: Also, you'd have to drag in an arbitrary-precision floating point lib to do it the way you suggest, and also have some way to predict the precision needed.
00:44:14 <dmwit> wli: Uh, no?
00:44:30 <dmwit> Just a symbolic square root.
00:44:53 <Olathe> > ffib 1000000
00:44:56 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
00:44:59 <wli> dmwit: Calculate in Z[5^(1/2)] with Integers? That's another thing entirely.
00:45:08 <dmwit> It wouldn't hurt to have a smart (^), either.  Repeated squaring or something.
00:45:30 <wli> dmwit: Smart (^) is essentially what my "weird recurrence" is.
00:46:05 <dmwit> wli: What? No, you just need something like data NewNum = NewNum Int Int, where Int is the integer part, and Int is the "root 5" part.
00:46:11 <wli> dmwit: Repeated squaring's next refinement is bitreversal. I go one step further and use F_{2*n} and F_{2*n+1} recurrences in tandem with bitreversal.
00:46:13 <dmwit> wli: Ah, cool.
00:47:09 <wli> gmp goes one step further than that and uses a stranger recurrence than I do. I'm not convinced gmp's recurrence is an improvement over the F_{2*n} and F_{2*n+1} I use.
00:48:14 <wli> The thing about gmp's recurrence is that it uses the same expression for even and odd. The (-1)^n is the only difference between the two cases there.
00:48:26 <wli> (IIRC anyway)
00:50:41 <wli> (Here "gmp's recurrence" refers to gmp's builtin Fibonacci implementation. It has Fibonacci in addition to various other special numbers as part of the lib, which aren't directly accessible from Haskell, though FFI's could, in principle, be written.)
00:51:14 <wli> (Odds are it would be faster due to less RTS overhead, and possibly due to being innately faster.)
00:52:05 <int-e> but it would be hard to get working because of the intimate bound between the RTS and gmp with respect to memory management.
00:52:17 <wli> True.
00:52:40 <wli> It's probably also possible to get general second-order linear recurrences working much the same way.
00:54:27 <dmwit> Is there any reason that not all of GMP is available in Haskell?
00:54:29 <dmwit> Developer time?
00:54:36 <dmwit> Or something more fundamental?
00:55:12 <P_D> presumably they just include haskell98, the rest is cruft
00:55:14 <int-e> Nothing fundamental, except that it's hard to do as an extra library.
00:55:35 <wli> It wouldn't fit neatly into a library structure as is now done.
00:55:49 <wli> Maybe Data.GMP? No idea.
00:56:12 <wli> You'd basically just get a dumping ground for whatever's left over.
00:56:49 <dmwit> Yeah, but it would make e.g. primes easier. =P
01:00:04 <wli> dmwit: Primes aren't of as direct importance as number theoretic functions like mu(n), d(n), phi(n), etc.
01:00:31 <P_D> practical application for phi(n)?
01:01:06 <int-e> dmwit: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes has some of the gory details that make implementing such a library hard. the easiest way to bind more functions from gmp would be to add new primops to ghc, but that's rather intrusive.
01:01:12 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac
01:01:49 <wli> P_D: Counting units mod n, nasties whenever you need subdivisions along divisors.
01:01:56 <int-e> P_D: say you want to find a^b (mod n) for coprime a, n and a very large b. then you can reduce b modulo phi(n) before doing the exponentiation.
01:02:26 <P_D> interesting.
01:02:43 <int-e> (using http://en.wikipedia.org/wiki/Euler's_theorem)
01:02:49 <lambdabot> Title: Euler's theorem - Wikipedia, the free encyclopedia
01:03:57 <int-e> actually modular exponentiation and efficient bit tests are the two things that I've missed most so far.
01:05:31 <int-e> (bit tests for Integer use the default implementation, which is  x `testBit` i = (x .&. bit i) /= 0)
01:07:54 <wli> I've missed Standard ML functors more than anything.
01:08:29 <int-e> Uh, I was talking in the context of GMP functions.
01:08:47 <wli> Oh, there is that. ;)
01:10:08 <P_D> prescribed precision floats.  or does GHC import that?
01:10:54 <wli> Nope.
01:11:04 <wli> No arbitrary-precision floats.
01:11:36 <wli> I was working on an arbitrary-precision BCD float module but I'm too lobotomized or something to finish it.
01:11:36 <P_D> it would be nice to have that, and then build a 'compute this to this number of digits' on top of that
01:12:03 <P_D> why BCD?
01:12:27 <wli> P_D: Basically so when you convert bases for printing or parsing it's a nop.
01:12:29 <tessier> 1/3 to a billion digits
01:12:45 <wli> P_D: Or otherwise so it matches human writing.
01:12:58 <wli> P_D: BCD is some sort of real world thing.
01:13:03 <P_D> ... Pffft.
01:13:14 <P_D> Yeah, I've heard something about BCD FPUs.
01:13:15 <tessier> The real world is overrated.
01:13:30 <P_D> Like eniac.
01:13:30 <wli> P_D: Accounting crap wants BCD. (IBM Power has BCD FPU's IIRC.)
01:14:05 <wli> P_D: (It's even a recent addition to the architecture cited as a performance boost for financial applications._
01:14:23 <P_D> fair enough. they invented numbers, we can let them do distasteful things with them =)
01:15:01 <wli> I'm still not sure what the right way to do arbitrary-precision floats is.
01:15:30 <P_D> which choice?
01:15:52 <wli> http://holomorphy.com/~wli/BCD.lhs
01:16:23 <sioraiocht> @src transpose
01:16:23 <lambdabot> transpose []             = []
01:16:23 <lambdabot> transpose ([]   : xss)   = transpose xss
01:16:23 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:16:51 <sioraiocht> @src transpose
01:16:51 <lambdabot> transpose []             = []
01:16:51 <lambdabot> transpose ([]   : xss)   = transpose xss
01:16:51 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:17:12 <P_D> What does NEL abbreviate?
01:17:23 <wli> Non Empty List
01:17:30 * sioraiocht totally thought you wrote "NFL" at first..
01:17:39 <dmwit> Heh, I like this comment:
01:17:46 <P_D> National Football League?
01:17:54 <dmwit>  > The skeleton in the closet for Haskell has always been monads.
01:17:59 <dmwit> s/skeleton/secret weapon/
01:18:10 <sioraiocht> hah, there are WAY those things
01:18:27 <wli> dmwit: Not at all. The scars of H98 are. :(
01:18:28 <sioraiocht> those = worse?
01:18:50 <sioraiocht> man, don't let me type before breakfast
01:18:59 <wli> Any comments/flames/etc. as to what I might be doing wrong with the BCD bits?
01:19:31 <dmwit> waugh
01:19:35 <dmwit> YAHT is 200 pages long??
01:20:02 <P_D> this box needs to get a little hotter before an answer pops out
01:20:07 <sioraiocht> This is totally lambdabot -> http://www.youtube.com/watch?v=dRRi-13KXes
01:20:07 <lambdabot> Title: YouTube - Boten Anna (English)
01:20:15 <dmwit> Heh, yeah.
01:21:10 <dmwit> Also, chapter 10 seems not to exist.
01:21:35 <sioraiocht> is there anything good on GADT's?
01:21:45 <P_D> The {,,} stuff is a named field record syntax?
01:21:52 <dmwit> yeah
01:21:53 <sioraiocht> P_D: yes
01:22:20 <P_D> is scale your exponent?
01:23:30 <wli> P_D: Yeah. Basically it's an ascending series 10^^(scaleBCD x) * sum (zipWith (*) (iterate (*10) 1) (digitsBCD x))
01:24:09 <wli> P_D: Rather (case signBCD x of True -> 1 ; False -> negate 1) * 10^^(scaleBCD x) * sum (zipWith (*) (iterate (*10) 1) (digitsBCD x))
01:25:16 <wli> P_D: One more time.
01:25:21 <wli> P_D: Rather (case signBCD x of True -> 1 ; False -> negate 1) * 10^^(scaleBCD x) * sum (zipWith (*) (iterate (/10) 1) (digitsBCD x))
01:25:45 <P_D> ah
01:26:01 <wli> P_D: Descending series, sorry.
01:26:40 <wli> Do I need to use different data structures? Is something else dumb here?
01:26:55 <P_D> well I've made it through signum, abs, and negate
01:27:15 <Taejo> dons, you're really going for reddit at the moment
01:27:36 <wli> UGH. I screwed up. One more time, even.
01:27:50 <P_D> (iterate (/10) .1) ?
01:27:58 <wli> (case signBCD x of GT -> 1 ; LT -> negate 1; EQ -> 0) * 10^^(scaleBCD x) * sum (zipWith (*) (iterate (/10) 1) (digitsBCD x))
01:28:05 <wli> P_D: SHould be iterate (/10) 1
01:28:29 <P_D> IEEE 754 starts on 1/2, rather than 1.
01:28:29 <wli> P_D: If not I've messed up.
01:28:38 <P_D> but that's taste.
01:29:14 <wli> P_D: It may be better if I start there or otherwise find a BCD standard to conform to.
01:29:56 <P_D> Your structures don't encode a precision
01:30:15 <P_D> are you shooting for infinite precision?
01:30:19 <wli> Yes. I don't know of any meaningful way to do so.
01:30:47 <P_D> is that feasible?  even with laziness
01:30:54 <wli> P_D: The hope is that infinite precision can be carried through and then when someone demands n digits, iterations can be terminated after so many digits.
01:30:59 <wli> I don't know.
01:31:36 <wli> P_D: I'd have to make precision part of the type I think.
01:32:06 <jsnx> okay, so, how do i split a string of chinese characters without breaking up the characters?
01:32:12 <P_D> You must be ok, it's just a power series, and you can do power series lazily
01:32:21 <glguy> jsnx: decode the utf-8
01:32:28 <glguy> and you'll have a string of unicode characters
01:32:34 <glguy> and you can do whatever you want to them
01:32:44 <glguy> instead of a string of utf-8 bytes
01:32:52 <jsnx> glguy: ah, i see
01:34:20 <jsnx> this is going to be interesting...
01:34:44 <P_D> fromInteger doesn't follow your specified format
01:35:16 <wli> P_D: Cancellation can get tricky.
01:35:20 <P_D> (fromInteger 1423 :: BCD) ->  scaleBCD 0, [1,4,2,3]
01:35:39 <wli> P_D: I've screwed up.
01:35:52 <P_D> you are in dire need of quickcheck =)
01:36:11 <wli> I think I'm too dumb to finish it.
01:36:23 <wli> Someone hit me on the head really hard or lobotomized me or something.
01:41:39 <P_D> starting on .1 means that scaleBCD = length digits, which is convenient.
01:42:22 <wli> I guess.
01:42:45 <wli> Changing formats.
01:44:20 <P_D> addition is very tricky.  you have to walk back until you can prove carry can't propagate
01:44:40 <P_D> which means finding an 8, I guess.
01:44:45 <wli> P_D: I do stupidity now and reverse the lists.
01:45:01 <mux> what is that number format?
01:45:10 <wli> mux: BCD floating point.
01:45:20 <mux> wikipedia to the rescue!
01:45:22 <wli> P_D: Addition needs to be completely rewritten so it's properly lazy.
01:45:45 <mux> BCD == binary coded decimal?
01:45:53 <wli> mux: Yes.
01:45:59 <mux> okay
01:46:18 <wli> mux: http://holomorphy.com/~wli/BCD.lhs <-- proof positive I'm no longer capable of coding my way out of a wet paper bag.
01:46:18 <mux> mm, that's space-expensive
01:46:57 <mux> 4 bits to represent only 10 values
01:47:34 <mux> what about BCH? ;-)
01:47:36 <P_D> 10 = 16 up to linearity
01:48:31 <wli> mux: I think I do worse and represent 10 values with 8 bits.
01:49:48 <wli> I should probably do radix 100 in Word8's
01:49:58 <P_D> So, prepend a zero to both lists, and more zeroes on the shorter one to bring it up
01:50:41 <P_D> the first value = carry of result, where carry = 0 if sum of next digits is less than 9, otherwise recurse
01:51:19 <P_D> split the addition work from the carry computations, and duplicate whole heartedly
01:52:25 <wli> Changed to radix 100.
01:53:56 <wli> P_D: I don't understand your carry algorithm.
01:54:19 <P_D> consider adding 0 1 7 3 4 and 0 9 2 8 2 on paper
01:54:56 <wli> P_D: Okay.
01:54:56 <P_D> add 0 and 0:  does 1 and 9 carry?  yes.  first digit: 1
01:55:41 <encryptio> what about 0 0 0 1 and 0 9 9 9?
01:55:42 <P_D> add 1 and 9:  does 7 and 2 carry?  don't know, do 8 and 3 carry? yes.  7 and 2 carries.  1 + 9 +1 divmod 10 = 2
01:55:45 <P_D> next digit 2.
01:56:18 <P_D> add 7 and 2:  does 8 and 3 carry?  yes. 7+2+1 mod 10 = 0.
01:56:27 <wli> P_D: How do you know when to stop propagating carries?
01:57:02 <wli> P_D: They could be very long digit strings (infinite?).
01:57:05 <P_D> 1.  you reach a certain carry.  2.  you reach something that can't carry.  max carry = BASE
01:57:14 <P_D> (i.e. 1)
01:57:37 <P_D> if digit + digit >= BASE, it carries.  if digit + digit < BASE-1, it can't carry.
01:57:54 <P_D> only for digit + digit = BASE -1 do you need to propagate
01:58:28 <P_D> Thinking about it now I seem to recall Feynman talking about a way to parallelize this in some book
01:58:35 <wli> addC x y = let (q, r) = (x + y) `quotRem` 100 in (r, if q == 0 then Nothing else Just q)
01:58:59 <wli> So zipWith addC xDigits yDigits
01:59:18 <P_D> Your adder needs to see the list
01:59:28 <P_D> let me haskellize my thoughts
02:00:12 <wli> I don't know how to let the adder see the list without effectively reversing it.
02:01:24 <wli> Or otherwise iterating something like addC until it comes out all Nothing.
02:02:36 <wli> Basically carries can ripple all the way back.
02:03:50 <P_D> here we go
02:04:26 <hpaste>  P_D pasted "carry propagation" at http://hpaste.org/4142
02:06:41 <P_D> I think the way to parallelize it is to compute the result with either carry result, and compute the carry, then choose the correct answer once you have the carry.
02:07:57 <patperry> is there a reason that there is an "instance IArray Array e" declaration but not an "instance IArray UArray e" ?
02:08:10 <wli> P_D: So basically addDigits :: [t] -> [t] -> ([t], t) where fst (addDigits xs ys) is the digit sum with carries performed and snd (addDigits xs ys) is the carry out?
02:09:17 <P_D> Yes, I guess you can do that.
02:09:20 <Saizan> patperry: yes, because UArray works only for unboxable types which roughly means those which have a fixed length representation
02:10:07 <wli> P_D: IOW think of the list adder as a hardware adder with carry in and carry out, and set up its recurrence by chaining single-digit hardware adder analogues with carry ins and carry outs?
02:10:09 <P_D> Yes, that makes sense.  A full adder is (Z,Z) -> (Z,Z), as it must be.
02:10:26 <wli> P_D: (Z,Z,Z) -> (Z,Z) even?
02:10:31 <P_D> Oh, right. (Z,Z,Z) -> (Z- yes.
02:10:37 <patperry> thanks, wli.  is it possible to use (!), bounds, etc. for a (UArray e)?  how do I do so?
02:10:43 <P_D> well, (Z,Z,B).
02:10:54 <P_D> (Z,Z,B) -> (Z,B)
02:13:41 <Saizan> patperry: no, if you want to specify UArray you can't be polymorphic on the type of the elements
02:13:48 <wli> P_D: But will it be lazy?
02:14:48 <P_D> no, because to compute the sum of a pair of digits you must know the carry of the previous.  that's why I split carry out.
02:15:04 <P_D> because carry alone has termination cases.
02:15:27 <P_D> 1 - 1/inf won't terminate, but that's life.
02:16:30 <dozer> @hoogle stripPrefix
02:16:31 <lambdabot> No matches found
02:16:44 <dozer> @hoogle Data.List.stripPrefix
02:16:44 <lambdabot> No matches, try a more general search
02:16:53 <P_D> Maybe the sum won't get forced though?  and only the tuple?  I don't understand boxing very well.
02:16:58 <dozer> damn - that shows up at http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html#v%3AstripPrefix
02:16:58 <lambdabot> http://tinyurl.com/2lz9qt
02:16:58 <P_D> *the carry tuple
02:17:05 <P_D> * the carry field in the tuple
02:17:41 <patperry> ok, thanks.  so, if I have a type "data Vector e = forall a. IArray e e => Vector { elements :: (a Int e) }".  how would I implement a "zero" function that returns a (Vector a) with an array of some specified length full of zeros?
02:18:05 <P_D> you think this is confusing, wait until you try implementing the number theoretic transform on arbitrary radices for multiplication
02:19:17 <wli> P_D: I used to understand that (I think I may have even written it). I don't believe I have enough of a mind left to understand it at all.
02:20:06 <P_D> I'm being a little dramatic, it's identical to the DFT, with a different root of unity
02:20:13 <P_D> *FFT
02:20:34 <wli> No, I wrote it only for p=257 and radix 256
02:21:26 <dozer> @point \(p) -> (fst p) == (snd p
02:21:26 <lambdabot> Maybe you meant: pointful pointless pointy
02:21:40 <dozer> @pointless \p -> (fst p) == (snd p)
02:21:41 <lambdabot> uncurry (==)
02:22:21 <P_D> good night
02:23:10 <wli> I think this is a mapAccumR
02:28:15 <Saizan> ?type listArray
02:28:17 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
02:29:12 <wli> > mapAccumR (\carry (x, y) -> (carry + x + y) `quotRem` 10) 0 $ zip [1,4,2,3] [0,9,9,9] :: (Int, [Int])
02:29:14 <lambdabot>  (0,[2,4,2,2])
02:30:17 <Saizan> ?type \n -> Data.Array.IArray.listArray (0,n-1) (replicate n 0)
02:30:22 <lambdabot> forall t (a :: * -> * -> *). (Num t, Data.Array.Base.IArray a t) => Int -> a Int t
02:30:36 <Saizan> patperry: ^^^^
02:31:55 <patperry> ok, I got it
02:32:13 <atp> what is meant by "boxed types" anyway
02:32:15 <atp> i've been seeing this lately
02:32:17 <atp> but i don't understand it?
02:32:57 <dozer> atp: it's sort of like an internal Either (func to calculate x) (value of x)
02:33:13 <atp> oh, i see.  to support lazy evaluation.
02:33:18 <dozer> yup
02:33:26 <dozer> at least, I think that's what it is
02:33:29 <atp> so unboxing a type means forcing it to be strictly evaluated?
02:33:37 <Saizan> boxed types are the normal ones, which are lazy and you can find undefined when you inspect a value of such type
02:33:56 <atp> so a boxed type might be _|_
02:34:04 <atp> ?
02:34:08 <Saizan> yes
02:34:37 <dozer> atp: and if you never access it, your program is fine
02:34:41 <atp> right
02:35:05 <atp> but when people are writing code and they talk about unboxing something, they mean forcing it to be strictly evaluated?
02:35:20 <Saizan> yes, and removing indirection
02:35:39 <atp> ah.  so very useful for optimization
02:35:56 <Saizan> it's usually used for numbers since unboxed Ints Floats etc.. are just the machine ones
02:36:12 <patperry> this works:
02:36:12 <patperry> zero :: forall a e. (IArray a e, Num e) => Int -> Vector e
02:36:13 <patperry> zero n = Vector elements where
02:36:17 <patperry>     elements = (listArray (0,n-1) (repeat 0)) :: a Int e
02:37:00 <patperry> but is there a way to say "use UArray for a if you can"?
02:37:48 <atp> ok.  i'm going to bed.  thanks for the help dozer, Saizan.  goodnight
02:37:55 <dozer> patperry: how would you define 'if you can'?
02:38:53 <Saizan> mmh, i wonder which instance will be used here
02:40:36 <wli> @src mapAccumR
02:40:36 <lambdabot> Source not found. My mind is going. I can feel it.
02:40:55 <wli> @src Data.List.mapAccumR
02:40:55 <lambdabot> Source not found. Do you think like you type?
02:44:28 <Saizan> patperry: you've to force a type of IArray before packing it in Vector
02:46:24 <patperry> "if you can" means if "instance UArray a" for that particular a
02:46:41 <patperry> sorry "instance IArray UArray a"
02:50:50 <Saizan> patperry: you need to use another class where the type of the element determine the type of the array, but that'll probably require a lot of instances
02:51:47 <dozer> Saizan: I though those sort of co-classes where comming some time soon?
02:54:07 <Saizan> dozer: class families? i'm not sure they would solve the problem here, where we need something like negation
02:54:20 <dozer> ah, I see what you mean
02:54:49 <dozer> negation would make GADTs much more powerful as well
02:55:05 <dozer> but I guess it would make the type reasoning ugly
02:55:47 <wli> I just don't understand the use cases for GADT's.
02:55:50 <Saizan> well you've to introduce the closed world assumption, and it will be semi-decidable
02:56:19 <wli> The closed world assumption would immediately allow better module systems.
02:57:02 <dozer> open-world with the ability to close it of in the right places is optimal
02:57:33 <wli> I don't see what open world buys in all honesty. You've got to import things anyway.
02:58:21 <dozer> there's a difference between being open-world/closed-world and being extensional
02:58:54 <wli> I don't see where I just tripped over extensionality.
02:59:03 <Saizan> wli: nice use case for gadts http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
02:59:04 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
02:59:23 <dozer> how do you write a module that exposes a class but no instances of that class, and get that module to compile if it is compiled closed world?
02:59:57 <dozer> it would make it impossible for anything importing that module to instantiate that class
03:00:11 <dozer> and anything importing that module and an instantiation to use it
03:00:14 <wli> I don't get it.
03:00:56 <dozer> for instances to bind, everything must be open-world at least untill linking modules together
03:01:18 <wli> What do you mean "for instances to bind?"
03:01:23 <Saizan> dozer: i think a more reasonable choice would be fixing the world only when compiling an executable
03:01:56 <dozer> Saizan: possibly - I'm not sure if this is what happens in reality - can you 'hot load' new instances at run-time?
03:02:37 <wli> I don't see the problem if you expose a class but no instances of it. You've done something useless. Pack up and go home.
03:02:46 <dozer> wli: in a single module
03:03:22 <wli> You mean you define a class and only other modules define instances?
03:03:36 <dozer> yes
03:04:05 <wli> Different story. I don't understand why the closed world assumption does that.
03:04:24 <dozer> ?
03:04:36 <Saizan> dozer: i'm not sure about hot-load, but types are erased at compile-time..
03:05:10 <wli> As far as I understand it, the closed world assumption is just about what instances are there for a given type in a given module.
03:05:44 <wli> So whatever instances are imported and in scope are the ones used for typing.
03:05:52 <dozer> cwa says "there are exactly those instances that I can see" owa says "there are at least those instances I can see"
03:06:10 <dozer> the type-checker barfs if "I can't see an instance that fits"
03:06:21 <wli> dozer: Yes. As far as I can tell this is not a problem.
03:07:00 <dozer> but as soon as you expose a class through a module, it /has/ to be exposed open-world, as you /know/ that you don't see all instances in that module
03:07:26 <wli> dozer: You've thrown me. I don't see why that is.
03:07:59 <wli> dozer: Why would you need to see all instances? Why can't you just work with the instances visible in that module?
03:08:22 <dozer> because it is a library module
03:08:27 <dozer> you have no idea where someone will use it
03:10:35 <Saizan> dozer: i think you're picturing it worse than it is, if you write code using the interface for the class it will work as long as when you check the instances in scope they are not illegal
03:10:45 <wli> I really don't mean to be dense, but I don't see why that hurts closed world or helps open world.
03:11:15 <dozer> but that is not the point - each module needs to be type-checked as you go
03:11:28 <Saizan> it's a matter of what is, and what isn't a member of that class.
03:11:30 <dozer> and each module has an incomplete view of what instances exist for what classes
03:11:54 <Saizan> yeah, the problem is that you need something like whole-program type checking.
03:12:11 <dozer> if you want to be closed-world, yes
03:12:28 <Saizan> or maybe not.
03:12:32 <wli> I'd think closed world would avoid the need for whole-program examination.
03:12:59 <wli> Whatever's in scope is what you get. The rest is ignored.
03:13:58 <dozer> you are confusing the extensional 'what you get' with the intensional 'what is typesafe'
03:14:45 <dozer> there is no instance for X vs there can not be an instance for X
03:15:41 <wli> I don't see why you'd ever care about ruling out the possibility of an instance existing elsewhere in the program.
03:16:03 <dozer> I probably don't but the type-checker shure as hell will
03:16:08 <Saizan> wli: functional dependencies
03:17:17 <wli> dozer: I mean to refer to the typechecker (and basically any/all other internal compiler needs).
03:17:59 <dozer> fundeps are one case, undefined another
03:19:01 <wli> You get multiple conflicting definitions of instance C T never simultaneously in scope. No problem: just pass the dictionary of the instance in scope at the sites where it's in scope.
03:20:01 <wli> Same deal for fundeps: use whatever's in scope to resolve with fundeps.
03:21:28 <wli> Perhaps our notions of "closed world assumption" differ somehow.
03:21:57 <sjanssen> wli: guaranteeing a single instance can be very important
03:22:20 <sjanssen> think Typeable, we need a single instance to be sure that those typecasts are safe
03:22:23 <wli> sjanssen: How? Why? When?
03:22:35 <sjanssen> also, remember associated types
03:22:48 <dozer> or imagine if the same datatype had two instances of Ord, in two different modules
03:22:49 <wli> Remember? I never learned AT's to begin with.
03:22:53 <sjanssen> overlapping associated types can mean a segfault at runtime
03:23:05 <wli> dozer: I just brought up the conflicting instance issue.
03:23:29 <wli> sjanssen: AFAICT you're fine so long as you never allow conflicting definitions to be simultaneously in scope.
03:23:42 <sjanssen> this is what Haskell does
03:24:38 <wli> sjanssen: With the closed world assumption the instance scoping / propagation rules would change so instances would only come into scope when imported and wouldn't get reexported implicitly etc.
03:25:03 <dozer> wli: that will break very badly nearly all of the time
03:25:04 <sjanssen> wli: I don't think this is sufficient in the presenence of ATs
03:25:38 <wli> Okay, "really? why?" goes out to both dozer and sjanssen here.
03:25:52 <sjanssen> wli: do you know what associated types are?
03:25:56 <wli> Bearing in mind I've barely even heard of AT's.
03:26:00 <sjanssen> okay
03:26:09 <wli> sjanssen: Not really. I barely know what fundeps are, never mind AT's.
03:26:11 <sjanssen> in Haskell '98, classes contain functions
03:26:28 <dozer> if one instance of Ord Foo is used to sort a list during one part of the execution of your program, and another instance of Ord Foo is used to sort a list during another part of the exeuction, you will, if you are lucky, get run-time bugs. If you are unlucky, you will get a segfault
03:26:30 <sjanssen> with ATs, classes contain types
03:27:06 <sjanssen> let's stick with dozer's explanation, it is simpler
03:27:08 <wli> dozer: No idea where segfaults come from.
03:27:11 <ricky_clarkson> Would that let you write Maybe with Just as a type?
03:27:22 <sjanssen> wli: are you familiar with the Storable class?
03:27:32 <wli> sjanssen: No. I've never used it.
03:28:05 <sjanssen> wli: it's a class for reading structures from Ptrs, it provides peek, poke and sizeOf
03:28:33 <sjanssen> module A where instance Storable Int where sizeOf x = 8
03:28:46 <sjanssen> module B where instance Storable Int where sizeOf x = 4
03:29:27 <sjanssen> take an array allocated in B's context and try to use it in A's context -- you'll dereference past the end of the array
03:29:30 <sjanssen> segfault
03:30:30 <wli> I'd say that's the programmer's fault.
03:30:42 <sjanssen> there isn't "the" programmer here
03:30:49 <dozer> type-systems are there to prevent programmers from making mistakes
03:30:54 <sjanssen> A and B might be separate third party libraries
03:30:59 <wli> Otherwise you'd want varying Ord instances to be like sortBy
03:31:01 <dozer> and in this case, it's not a mistake made by any one programmer
03:32:25 <sjanssen> now, other conflicts won't be nearly this insidious.  Instead you'll experience mysterious bugs
03:32:37 <sjanssen> any bets on how Data.Map will behave across several Ord instances?
03:34:09 <doserj> sjanssen: the instance in scope would have to be part of the type, and typechecking would fail
03:34:26 <dozer> I had a java bug like that where someone had over-ridden hashCode half-way down a class hierachy and the map was of things typed by somewhere near the top :)
03:34:36 <dozer> was very good at taking out our tomcat
03:34:48 <jewel_> it crashed?
03:34:59 <sjanssen> we do not want that to happen in Haskell
03:35:02 <dozer> triggered a thread-leak
03:35:03 <wli> Not very good.
03:35:32 <sjanssen> doserj: yeah, that might work.  Seems complicated.  How many different instances do you use in a particular function?
03:35:41 <wli> I'm too dumb to devise a system that would make it safe. I can barely follow directions for well-worked-out type systems.
03:36:04 <wli> In fact, most of the time I'm not really even capable of that.
03:36:33 <quicksilver> sjanssen: yes, you'd need Map k a <OrdInstanceForK>
03:36:35 <quicksilver> sjanssen: in a sense
03:36:45 <quicksilver> the map type woudl need to encode which ord instance it's designed for
03:36:51 <quicksilver> similarly with arrays and their storable instances, etc.
03:37:00 <dozer> which would be really nice in some situations
03:37:43 <Saizan> right now you can use a newtype
03:38:05 <dozer> sure, but then you have to bless/unbless things as they go through the collection
03:38:13 <dozer> which is OK but anoying
03:38:34 <sjanssen> we can do quicksilver's suggestion in the type system right now
03:38:52 <wli> sjanssen: How?
03:39:26 <Saizan> using an Ord with a phantom type?
03:40:01 <sjanssen> Saizan: exactly
03:40:22 <sjanssen> there are a couple approaches I can imagine off the top of my head
03:40:39 <Saizan> that's not so nice either, since you've to "pass the type" anyway
03:40:48 <quicksilver> or pass the dictionary explicitly
03:41:04 <quicksilver> passing the dictionary explicitly woudl be nicer anyway because then we could make Map (and Set) a Functor
03:41:26 <quicksilver> you can always have a convenience constructor which passes the Ord dictionary itself
03:41:31 <Saizan> quicksilver: that let's you mix maps with different dictionaries
03:41:48 <quicksilver> yes
03:41:49 <quicksilver> does that matter?
03:41:55 <Saizan> union?
03:42:05 <quicksilver> it makes union less efficient, yes
03:42:09 <quicksilver> you can still do it though :)
03:42:11 <Saizan> well i don't know how they are implemented..
03:42:23 <quicksilver> you just have to turn union into foldl instert
03:42:55 <doserj> so union would not be commutative anymore
03:45:20 <wli> I'm completely lost.
03:49:02 * sjanssen doesn't like passing in the dictionary
03:49:25 <sjanssen> that is clearly more difficult to use
03:49:35 * dozer thinks dictionary passing is exactly what instances of classes are meant to avoid
03:51:46 * doserj agrees. But it also "avoids" the possibility to fine-tune instance selection
03:52:05 * dozer thinks that is why we will be getting class-within-class deffinitions in haskell
03:52:39 <quicksilver> sjanssen: well you only have to pass it in at construction
03:52:50 <quicksilver> since it's opaque
03:52:55 <sjanssen> true
03:52:57 <quicksilver> the dictionary which a Map users doesn't matter, to its users
03:53:01 <quicksilver> it just matters that it works
03:53:08 <sjanssen> that will kill optimization too
03:53:12 <quicksilver> I think it's worth it, just to make Set a Functor
03:53:18 <quicksilver> what kind of optimisaton?
03:53:31 <Saizan> specialization
03:53:43 <sjanssen> yes, specialization
03:53:52 <quicksilver> ah, if you store higher-order functions
03:53:54 <quicksilver> they don't get inlines
03:53:56 <quicksilver> inlined
03:53:59 <sjanssen> plus, this is Haskell!  Do it statically!
03:54:37 <dozer> haskellers do it statically!
03:56:49 <Saizan> unboxing reduces sharing, right?
03:57:22 <dozer> yes
04:00:04 <pejo> Does it neccesarily?
04:00:30 <sjanssen> dozer: "class-within-class"?
04:00:32 <dozer> well, it can never increase sharing
04:01:13 <dozer> sjanssen: class Foo a where class Bar b ...
04:01:29 <dozer> or whatever the syntax is now
04:01:29 <sjanssen> dozer: I can't think of an application
04:01:40 <pejo> A bit unfair to equal "not increasing" and "decreasing" imho.
04:03:18 <wli> I can't figure out what happened or what the conclusion of all this was.
04:03:54 <Saizan> sjanssen: e.g. a GenMap m k v class that you can instance with [(k,v)] or Map k v, you need Eq for the first, and Ord for the second
04:08:26 <Saizan> and.. restricted monads!
04:09:18 <wli> Like Monad instances for Set?
04:09:40 <sjanssen> Saizan: I don't see how this is related to nested classes
04:10:07 <wli> I'm pig ignorant of what's going on with nested classes.
04:10:53 <sjanssen> I've never heard of them before
04:11:35 <Saizan> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions/ClassFamilies
04:11:38 <lambdabot> Title: TypeFunctions/ClassFamilies - GHC - Trac, http://tinyurl.com/27byjk
04:12:06 <Saizan> or i'm misunderstanding "class-within-class"?
04:12:35 <SamB> pejo: well, it does have a tendancy to decrease sharing...
04:13:06 <wli> I suspect I just don't understand much of Haskell beyond monads, monad transformers, a wee bit of typeclass-based overloading, and the ML subset thereof.
04:13:23 <SamB> I've never heard of nested classes before either...
04:14:33 <Taejo> I'm trying to write an xmonad manageHook to automatically float windows that "want" to be small, but I can't figure out how to find the size of a window
04:14:49 <Taejo> any hints?
04:17:31 <SamB> #xmonad might be a better place to ask
04:23:25 * sjanssen is tired of hearing about this stupid blog post http://wagerlabs.com/archives/72.html
04:23:25 <lambdabot> Title: Tenerife Skunkworks
04:28:19 <wli> The open world assumption kind of sucks.
04:28:29 <quicksilver> sjanssen: don't you perpetuate it by posting links about it :)
04:28:43 <sjanssen> mmm
04:28:55 <sjanssen> quicksilver: yeah, I suppose you're right
04:29:04 <sjanssen> I gotta whine somewhere :)
04:29:14 <TSC> What's stupid about it?
04:30:13 <sjanssen> I suppose the article itself isn't so bad
04:30:36 <sjanssen> it's that many seem to take these isolated experiences as the gospel truth
04:31:36 <TSC> You can't help people's lack of critical thinking
04:32:16 <jonathanturner> sjanssen: fwiw, I'm learning haskell now.  I think erlang is probably easier for C++ coders to wrap their head around (if they're like me)
04:32:19 <Saizan> plus it seems to me that joelr doesn't know how to use haskell or the haskell libraries
04:32:34 <sjanssen> ... isolated experiences of someone who seems intent on doing things in the most bizarre way possible
04:32:39 <sjanssen> Saizan: yes!  That too
04:32:49 <TSC> I do wonder a bit when people say dynamic typing is good because it makes code shorter
04:33:18 <TSC> And he says outright that he doesn't really understand monads
04:33:50 <jonathanturner> I think SLPJ is right, they should be called like "warm fuzzy things" so you aren't scared to dig into them
04:34:00 <sjanssen> he tried to use HList records in production code...
04:34:25 <TSC> Wow, that's brave
04:34:29 <int-e> imho, he tried to write an Erlang program in Haskell and failed.
04:34:32 <TSC> I'm scared even to read the paper
04:34:46 <firefly> dons: I remembered the number "39s" -- it seems to be substantially smaller than "71.98s" ;)
04:34:58 <dmwit> I love people who complain about satisfying the type-checker.
04:35:01 <Shimei> I've been writing scheme code lately and most of the bugs could have been caught with some static typing.
04:35:12 <Shimei> Chasing down runtime errors is so painful.
04:35:48 <Boney> lambdabot: quote jonathanturner
04:35:56 <Taejo> firefly, look at the number on the left
04:36:01 <Boney> *shrug* and give up.
04:36:03 <Taejo> *right
04:36:14 <Taejo> @quote jonathanturner
04:36:14 <lambdabot> No quotes match.
04:36:28 <dmwit> firefly: I wondered the same thing.  dons is looking at the wall-time, not the user time.
04:36:28 <firefly> right :)
04:36:30 <Boney> ah, thta's not wnat I wanted.
04:36:38 <Boney> I wanted it to add the most recent thing he said.
04:36:44 <Boney> about "warm fuzzy critters"
04:36:55 <dmwit> ?quote fuzzy
04:36:55 <lambdabot> No quotes match. Wrong!  You cheating scum!
04:36:57 <Taejo> the wall-time is only going to increase as you parallelise
04:37:03 <Taejo> *user-time
04:37:34 <quicksilver> Taejo: it's conceivable you might manage to get a user-time decrease
04:37:35 * Taejo unscrews his head, fiddles about, and screws it back on, hoping it will work better
04:37:43 <dmwit> Boney: "Warm fuzzy things" is a fairly common name for monads here when somebody is complaining. =)
04:37:45 <Boney> it's a good idea.  at work the same conversation keeps re-occuring.
04:37:46 <quicksilver> Taejo: on a parallel system with private caches
04:37:57 <quicksilver> Taejo: if the single-CPU process was memory-bound
04:38:02 <Taejo> ah, yes, true
04:38:02 <quicksilver> Taejo: in general, though, I agree.
04:38:09 <quicksilver> that's quite unlikely to happen
04:38:11 <Boney> somehow Monads come up in conversation, which 2 of us understand.
04:38:23 <Boney> then someone says "Paul will probably try to explain them again"
04:38:26 <Boney> "Oh no"
04:38:31 <Boney> "I don't understand them"
04:38:36 <firefly> Taejo: you've got left and right confused.
04:38:47 <jonathanturner> it's even more confusing if you try to look it up online
04:38:48 <Taejo> hence the unskrewing of my head
04:38:53 <Boney> I've given up trying to understand them because people are resistant to learning about them.
04:39:26 <Boney> "I can program Python without them, why should I need them to program Haskell?"  ergo "That makes Haskell worse"
04:39:41 <jonathanturner> you'll find a lot of people saying what they think, then definitions like "used as a term for God or the first being"
04:39:42 <firefly> The scaling is rather bad, isn't it?
04:40:18 <SamB> these people have Missed the Point&trade;
04:40:35 <wli> Well, just when I learn monads and monad transformers, I can't understand fundeps, AT's, GADT's, Template Haskell, Arrows, Applicatives, or a number of other things.
04:40:45 <ricky_clarkson> Boney: Monads are elephants, warm fuzzy things, boxes and any number of other analogies.
04:40:50 <SamB> or were writing about something entirely different
04:40:53 <SamB> I guess
04:40:59 <Boney> wli: yeah. I'm in that boat too.
04:41:10 <ricky_clarkson> Monads are like.. no they're not, explain them without analogies and I'll listen.
04:41:27 <SamB> ricky_clarkson: they follow these laws, see
04:41:33 <Boney> ricky_clarkson: heh.  I think that requires catagory theory.
04:41:40 <wli> Boney: It took me 10 years to understand monads. I'll die before I figure out much of the rest.
04:41:41 <dobblego> monads are an abstraction that the mainstream programming world is forever reimplementing
04:41:54 <SamB> dobblego: so are a lot of things
04:41:56 <wli> Boney: Not really, but it is down and dirty code.
04:42:01 <dobblego> SamB, indeed
04:42:03 <Boney> wli: oh wow.  I feel special now.  It only took me four weeks.
04:42:05 <ricky_clarkson> Boney: Fine.  Show me where I can read all the category theory I need.
04:42:28 <quicksilver> if you are happy with the notion of side-effects there really isn't much to it
04:42:29 <jonathanturner> okay, I'm reading this guys Haskell vs. Erlang experiment, so he just starts coding in Haskell off the bat without really digging into it?  I think that shows he's a bit reckless even if he's got skills.
04:42:37 <Boney> ricky_clarkson: nfi.
04:42:49 <quicksilver> that is, if you understand the difference between a 'pure' function and one that isn't
04:42:58 <dobblego> there are many good texts on category theory
04:42:58 <firefly> you don't need the category theory unless you REALLY want to know why they got precisely that name.  That's really all you need the category theory for.
04:43:06 <ricky_clarkson> jonathanturner: People used to dynamic typing are quite used to doing stuff and seeing what happens.
04:43:12 <SamB> quicksilver: are you by some chance only explaining IO?]
04:43:13 <ricky_clarkson> dobblego: Any gratis?
04:43:19 <rretzbach1> Hello, I want to install ghc on leopard, I tried a bin dist but make install failed. Is there maybe a haskell installer?
04:43:23 <ricky_clarkson> I've never seen any in a bookshop, and don't like ordering blind.
04:43:27 <dobblego> ricky_clarkson, none that I can recommend
04:43:39 <quicksilver> SamB: a -> m b is different from the 'pure function' a -> b for any non-trivial monad 'm'.
04:43:44 <SamB> firefly: I heard they got that name because category theorists are bad at a naming
04:43:52 <Boney> dobblego: I like that explaination.  that monads are an abstraction.  it's a nice way of saying "your wrong I'm right" :-)
04:44:03 <quicksilver> SamB: it's true that certain monads are themselves pure and therefore a -> m b might be a pure function in a different obvious way
04:44:08 <quicksilver> but that's not the point :)
04:44:09 <dobblego> Boney, I would never say "your wrong" because I don't think you own a wrong
04:44:13 <ricky_clarkson> "Here's a website.  It's really good but it costs $20 to access.  No, I won't let you peek first.  Pay".  That's how I feel about books you order without seeing first.
04:44:27 <wli> First, there are functors.
04:44:36 <Boney> rretzbach1: I'm using 10.4 or 10.3 I can't remember.  macports installed ghc for me.
04:44:38 <dobblego> ricky_clarkson, I would not recommend a book on category theory to "get it" anyway
04:45:00 <dobblego> ricky_clarkson, I would take wli's suggestion and start with Functors
04:45:00 <dmwit> Just use the list monad until you get it.
04:45:04 <rretzbach1> Boney: I fear it will compile ghc...
04:45:08 <dmwit> All the other monads come for free.
04:45:10 <wli> In a non-f***ed-up Prelude the Functor method is called "map," but I'll stick to "fmap" for comprehensibility's sake.
04:45:11 <Boney> dobblego: thanks.
04:45:16 <dmwit> Except, possibly, Cont.
04:45:16 <ricky_clarkson> dobblego: Functors as in "pointers to functions" or something more?
04:45:24 <dobblego> ?type fmap
04:45:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:45:35 <Boney> rretzbach1: Probably.  but it worked for me.
04:45:37 <dobblego> that, and why it is important and why it is an abstraction
04:45:48 <dobblego> you'll note the similarity to:
04:45:55 <dobblego> ?type flip (>>=)
04:45:57 <ricky_clarkson> Why is Functor needed there rather than just a -> b?
04:46:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
04:46:13 <Boney> good night.
04:46:22 <wli> ricky_clarkson: No, they represent type constructors where functions on the argument of the type constructor act on the corresponding elements of the container the constructor constructs.
04:46:23 <rretzbach1> Boney: It surely would, but I don't want to compile two days.
04:46:33 <wli> ricky_clarkson: For instance:
04:46:34 <Saizan> ricky_clarkson: a Functor is none like what is called like that in OO
04:46:36 <ricky_clarkson> Ah, I read the final 'f b' in that sig.
04:46:39 <dobblego> ricky_clarkson, notice how the 'f' there can be replaced with [] and we'd have just a normal list map
04:46:40 <wli> > fmap (+1) [1..5]
04:46:47 <dobblego> [a] is shorthand for [] a
04:46:55 <lambdabot>  thread killed
04:47:02 <wli> > fmap (+1) (Just 3)
04:47:14 <dobblego> we call map the "list Functor"
04:47:18 <lambdabot>  thread killed
04:47:21 <dobblego> but it's not the only Functor (value for f)
04:48:05 <wli> ricky_clarkson: Then there is a monad, which has return and join on it. Ignore bind (a.k.a. (>>=) in extant Preludes).
04:48:53 <ricky_clarkson> :t []
04:48:54 <lambdabot> forall a. [a]
04:49:04 <ricky_clarkson> Is [] a Functor?
04:49:06 <dobblego> ?kind []
04:49:06 <lambdabot> * -> *
04:49:32 <dobblego> yes, there exists: instance Functor [] ...
04:49:44 <doserj> @instances Functor
04:49:44 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:49:45 <ricky_clarkson> Can you see what something is an instance of?
04:49:47 <ricky_clarkson> Ah.
04:50:18 <ricky_clarkson> Well, that's the opposite way to what I asked, but it suffices.
04:50:43 <wli> ricky_clarkson: return (formerly called "unit") is a canonical injection. return :: t -> m t
04:50:45 <SamB_XP_> ricky_clarkson: that's not a bad idea, though
04:50:49 <dobblego> the key point is, I may have some function which one person might write in terms of map; this might mean that a [] argument must be passed; but instead, I write it using fmap, which means "anything that declares itself in the set of Functors" can use this function - I needn't rewrite it
04:51:21 <SamB_XP_> ricky_clarkson: ghci can tell you that, actually
04:51:31 <ricky_clarkson> If you had something that looked for all intents and purposes like a Functor but wasn't an instance of Functor, could you use it with fmap?
04:51:32 <dmwit> ?pl \r -> if r > 0 then show r else ""
04:51:32 <lambdabot> flip (liftM2 if' (> 0) show) []
04:51:35 <SamB_XP_> I think
04:51:46 <SamB_XP_> ricky_clarkson: of course not
04:51:48 <dobblego> ricky_clarkson, no, you'd have to instance Functor it
04:51:49 <wli> ricky_clarkson: join :: m (m t) -> m t
04:51:55 <dmwit> Is a case statement an expression?
04:51:55 <SamB_XP_> ricky_clarkson: you could, however, file a bug report
04:52:12 <SamB_XP_> I did that for TH once ;-)
04:52:13 <wli> ricky_clarkson: This means there's an endomorphism from m (m t) -> m t
04:52:16 <dmwit> (Could I do "initial" ++ case x of ...?)
04:52:19 <dobblego> a Functor is a type "class" or a set of types; you can declare yourself an element of that set
04:52:21 <ricky_clarkson> Is 'instance' scoped, like, say, let is?
04:52:31 <SamB_XP_> no
04:52:33 <wli> ricky_clarkson: For lists, join is concat
04:52:39 <dobblego> ?type join
04:52:41 <dobblego> ?type concat
04:52:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:52:46 <lambdabot> forall a. [[a]] -> [a]
04:53:00 <wli> > join [[1,2],[3,4]]
04:53:01 <lambdabot>  [1,2,3,4]
04:53:02 <dobblego> [] ([] a) -> [] a
04:53:19 <SamB_XP_> I can't see how instance can sensibly be scoped, though existing compilers do a sort of "implicit import" of instances when you import a module
04:53:24 <ricky_clarkson> Ah, that reminds me.  What can I give [1,2,2,3] and it gives me [1,2,3]?
04:53:29 <ricky_clarkson> @hoogle [a] -> [a]
04:53:30 <lambdabot> Prelude.cycle :: [a] -> [a]
04:53:30 <lambdabot> Prelude.init :: [a] -> [a]
04:53:30 <lambdabot> Prelude.reverse :: [a] -> [a]
04:53:34 <dobblego> fmap is to map as concat is to join as >>= is to concatMap
04:53:37 <SamB_XP_> nub
04:53:40 <wli> ricky_clarkson: For functions, join passes the same argument twice.
04:53:40 <dobblego> nub
04:53:43 <dmwit> ricky_clarkson: nub
04:53:49 <SamB_XP_> > nub [1,2,2,3]
04:53:49 <lambdabot>  [1,2,3]
04:53:54 <ricky_clarkson> @src nub
04:53:54 <lambdabot> nub = nubBy (==)
04:53:57 <dmwit> > nub [2,1,2,3]
04:53:58 <lambdabot>  [2,1,3]
04:54:00 <ricky_clarkson> @src nubBy
04:54:00 <lambdabot> nubBy eq []             =  []
04:54:00 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:54:01 * SamB_XP_ notices that underscore
04:54:03 <wli> dobblego: map specialized to lists should not exist. Functor's method should be called map.
04:54:12 <dobblego> wli, I agree
04:54:14 <wli> > join (+) 1
04:54:14 <lambdabot>  2
04:54:17 <ricky_clarkson> Is nub O(n^2)?
04:54:20 <SamB_XP> dobblego: Haskell 98 is stupid :-(
04:54:34 <dmwit> ricky_clarkson: Yes, and you can't do better with just an Eq constraint.
04:54:42 <dobblego> SamB, only in the absolute sense, not relative to its competitors at least :)
04:54:45 <wli> ricky_clarkson: Witness
04:54:49 <dmwit> ricky_clarkson: If you have Ord, you can do a bit better, but it's probably not worth it in a lot of cases.
04:54:58 <SamB_XP> dobblego: well, I meant relative to the previous version
04:55:09 <dobblego> SamB, ah right; I'm not too familiar
04:55:10 <wli> > Data.Set.toList . Data.Set.fromList $ [1,2,2,3]
04:55:11 <lambdabot>  [1,2,3]
04:55:22 <ricky_clarkson> dmwit: So you'd sort then search for duplicates somehow?
04:55:37 <SamB_XP> dobblego: neither am I, but by all reports it lacked much of the idiocy present in Haskell 98
04:55:40 <dmwit> > map head . group . sort $ [1,2,2,3]
04:55:41 <lambdabot>  [1,2,3]
04:55:50 <wli> > Data.IntSet.toList . Data.IntSet.fromList $ [1,2,2,3]
04:55:51 <lambdabot>  [1,2,3]
04:55:54 <SamB_XP> I can't even remember the name of the previous version :-( was it 1.4 or 1.3?
04:55:58 <ricky_clarkson> > group [1,2,2,3]
04:55:58 <lambdabot>  [[1],[2,2],[3]]
04:56:05 <dmwit> wli: Oh, very nice.
04:56:19 <wli> SamB_XP: 1.4 and 1.3 were both better.
04:56:31 <ricky_clarkson> sort, I imagine, is O(n.log(n))?
04:56:34 <dmwit> I like toList . fromList for sets.
04:56:37 <wli> SamB_XP: It wasn't completely linear for 1.4 vs. 1.3
04:56:41 <SamB_XP> wli: well, that might explain why I can't remember the number of the previous version
04:56:44 <dmwit> ricky_clarkson: I'm pretty sure.
04:56:46 <ricky_clarkson> Is this the same order as adding stuff to a hashtable?
04:57:09 <SamB_XP> ricky_clarkson: eh? hashtable?
04:57:19 <ricky_clarkson> In my Java code, I use hashtables sometimes to ensure uniqueness.
04:57:23 <SamB_XP> we don't have any decent hashtable code!
04:57:38 <wli> It'd be nice if you could do local import Data.Set in toList . fromList $ [1,2,2,3]
04:58:02 <SamB_XP> I always just import qualified Data.Set as S
04:58:04 <dmwit> not that nice
04:58:09 <dmwit> yeah, qualified
04:58:32 <SamB_XP> wli: not quite as pretty, I'll admit
04:58:38 <dmwit> ricky_clarkson: If you're really excited about speed, how about implementing a radix-sort? ;-)
04:58:45 <SamB_XP> well, for longer expressions, anyway
04:58:46 <ricky_clarkson> wli: Everything should be scopable, everything should be first class, and erasure should always be preventable. ;)
04:58:46 <wli> I do import qualified Data.Set as Set and import Data.Set hiding (toList, fromList, ...) and a few other things that tend to clash.
04:59:02 <ricky_clarkson> dmwit: I'm more bothered about algorithm order than speed.
04:59:09 <SamB_XP> wli: ah, that works too. but I'm too lazy to do that ;-)
04:59:21 <dmwit> ricky_clarkson: Radix sort is O(n).
04:59:45 <wli> SamB: It doesn't require much effort. I only bother starting to hide things when I get clashes.
05:00:18 <SamB_XP> I guess I just don't like to keep changing the import
05:00:25 <wli> SamB: And I only bother with the qualified import when I get the first clash.
05:01:02 <SamB_XP> sometimes, I might use Data.Map and Data.Set in the same module ;-)
05:01:29 <wli> SamB: The scheme I describe works there.
05:02:43 <wli> SamB: In fact, that's the precise use case I started using it for.
05:03:34 <wli> My BCD module is now broken in different ways.
05:03:45 <SamB_XP> anyway, I guess I just like to be able to stay where I am in the code and not have to go back to the import section ;-)
05:03:47 <wli> I'll bet there are freshmen who could write it in 10 minutes.
05:03:59 <SamB_XP> highschool or college?
05:04:19 <wli> Probably highschool given how addled I am anymore.
05:05:02 <dmwit> So, you being addled means younger people are smarter? =)
05:05:47 <mar77a> what's wrong with the following declaration?
05:05:50 <mar77a> db :: Num => a -> a
05:05:51 <mar77a> db a = a + a
05:06:02 <mar77a> im getting an error when loading the module
05:06:11 <SamB_XP> no, it means he feels pathetic, and the more pathetic he feels, the more likely he thinks it is that a highschool freshman could do what he fails to do
05:06:22 <dmwit> db :: (Num a) => a -> a
05:06:40 <mar77a> ah thanks
05:06:44 * mar77a is a newbie
05:06:56 <dmwit> :t join (+)
05:07:02 <lambdabot> forall a. (Num a) => a -> a
05:07:17 <oerjan> classes like Num are more like predicates on types than like types themselves
05:07:35 <mar77a> i see
05:07:47 <mar77a> dmwit: that gave an error
05:07:56 <oerjan> this tends to confuse OO people, i guess :)
05:08:09 <dmwit> mar77a: Did you put it in a file?  You can't type that at the ghci prompt.
05:08:22 <mar77a> ah, looked like it from the syntax
05:08:45 <oerjan> actually you can if you put a let in front and ; between the parts
05:08:45 <reinierrr> i think of haskell typeclasses more or less the same as i think of java's interfaces
05:08:53 <mar77a> one question, can haskell code be compiled to a binary?
05:09:01 <oerjan> let db :: (Num a) => a -> a; db a = a + a
05:09:01 <dmwit> It almost always is.
05:09:34 <mar77a> the same type of binary cc or g++ would compile?
05:09:44 <quicksilver> yes, very much the same
05:09:51 <oerjan> ghc creates native binaries
05:10:03 <quicksilver> in some cases it uses gcc to make the final binary, in fact
05:10:05 <quicksilver> not always though
05:10:25 <mar77a> does this mean i can compile haskell code and have it run in any machine without extra files?
05:10:47 <dmwit> Any machine with the same architecture and operating system as what you built on, yes.
05:10:48 <SamB_XP> quicksilver: you mean it invokes ld directly sometimes?
05:11:04 <mar77a> well, are there compilers for other operating systems?
05:11:08 <quicksilver> SamB_XP: I suspet it always invokes ld directly.
05:11:08 <SamB_XP> unless your program needs extra files
05:11:16 <oerjan> ghc supports many OSes
05:11:26 <mar77a> great
05:11:28 <quicksilver> SamB_XP: but I mean, sometimes it generates native code directly, and sometimes it uses gcc to generate native code.
05:11:32 <wli> > join (Just (Just ()))
05:11:38 <lambdabot>  Just ()
05:11:40 <SamB_XP> quicksilver: true enough
05:13:06 <oerjan> although i understand ghc is not very good at cross compiling, so you probably need to compile on whatever architecture you want it to run.
05:13:36 <oerjan> some of the other compilers use bytecode which is more portable
05:13:53 <mar77a> i'll just be releasing the sources :D
05:13:56 <oerjan> but not as fast
05:14:11 <reinierrr> oerjan: only portable to platforms on which the interpreter runs
05:14:23 <SamB_XP> yeah, GHC isn't very good at cross compiling at all :-(
05:14:26 <reinierrr> oerjan: but i doubt hugs or nhc run on more platforms than ghc compiles for
05:14:44 <wli> Are there any cross-compilation-capable Haskell compilers?
05:15:23 <oerjan> i thought greater portability was one of the strengths of hugs
05:15:30 <SamB_XP> but in it's defence I think this is in large part because it has to know the storage characteristics of various datatypes...
05:15:33 <oerjan> being nearly portable C
05:15:54 <mar77a> "You can write functions which take functions as parameters. This can be fun, and also very useful."
05:15:58 <SamB_XP> hugs can't compile, much less cross compile ;-)
05:16:06 <mar77a> isn't that possible in every language?
05:16:16 <oerjan> mar77a: not _every_ language
05:16:33 <mar77a> how does it take the function as a parameter? it's result then passes it to the other function right?
05:16:37 <oerjan> but i guess it's pretty common nowadays
05:16:50 <SamB_XP> it is indeed quite common nowadays
05:16:52 <oerjan> > map (+1) [1,2,5]
05:16:55 <lambdabot>  [2,3,6]
05:16:55 <mar77a> something like print(get_value());
05:17:11 <oerjan> here (+1) is a function
05:17:11 <mar77a> or am i missing something?
05:17:28 <oerjan> which is an argument to map
05:17:33 <SamB_XP> yes, you are missing something ;-)
05:17:33 <mar77a> yes
05:17:38 <sclv> ?src map
05:17:38 <lambdabot> map _ []     = []
05:17:38 <lambdabot> map f (x:xs) = f x : map f xs
05:17:45 <quicksilver> mar77a: yes, you don't pass the *result* to the other function
05:17:52 <quicksilver> mar77a: you pass the whole function
05:17:52 <mar77a> what do you pass?
05:17:58 <sclv> map is a function. it takes f which can be a function
05:17:59 <quicksilver> mar77a: it can, rfor example, use it many times
05:18:12 <mar77a> i don't understand HOW you can pass a function
05:18:18 <sclv> (and the xs it takes can be a list of functions too actually!)
05:18:33 <wli> mar77a: You can do it in C.
05:18:33 <mar77a> im looking at map right
05:18:35 <sclv> > let addone x = x + 1 in map addone [1..3]
05:18:38 <lambdabot>  [2,3,4]
05:18:53 <oerjan> C however is more limited in what functions you can create
05:18:54 <mar77a> ohhh i get it
05:18:57 <wli> mar77a: Want me to show you how you do it in C?
05:19:02 <mar77a> sort of like a pointer to a function
05:19:09 <mar77a> no worries, got it wli , thanks
05:19:17 <quicksilver> the implementation will inevitably involve something 'like' a pointer to a function, yes
05:19:19 <wli> oerjan: No, it's not. It's merely vastly less safe.
05:19:22 <mar77a> you get the list and the function and have map apply the function to the list
05:19:32 <oerjan> in haskell it may also include variables used by the function
05:19:33 <mar77a> *plim*
05:19:41 <quicksilver> although in prinviple you might imagine passing the actual code instead
05:19:54 <quicksilver> so you could think of other ways of doing it than pointers
05:19:55 <mar77a> yeah, from my point of view it doesn't change anything
05:19:56 <oerjan> wli: well i mean as just function pointers
05:20:27 <mar77a> oh man, haskell will take ages
05:20:48 <oerjan> @quote curve
05:20:48 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
05:20:50 <mar77a> i started learning 3 or 4 days ago and all i can do is print a list comprehension :p
05:21:10 <Cale> mar77a: It took me at least 2 months before I started to feel comfortable.
05:21:18 <SamB_XP> mar77a: what other languages do you know?
05:21:25 <dmwit> Hey, at least you can print it.  Some people can't do IO even 3 or 4 months in. =)
05:21:27 <mar77a> the usual SamB_XP
05:21:34 <SamB_XP> what is the usual?
05:21:39 <Cale> mar77a: and about a year before I started to feel confident
05:21:40 <mar77a> C/C++, php
05:21:57 <mar77a> well i only started feeling comfortable with c++ after a year or so :*
05:21:58 <SamB_XP> oh, well no wonder you don't get first-class functions
05:22:04 <mar77a> naturally
05:22:08 <wli> mar77a: It took me 10 years to learn monads.
05:22:13 <SamB_XP> no lisp, no python, not even perl!
05:22:19 <mar77a> ruby and python too :p
05:22:22 <Cale> Hehe, it shouldn't take 10 years anymore :)
05:22:24 <SamB_XP> oh
05:22:31 <mar77a> but they're easy
05:22:35 <mar77a> i mean it's just...english
05:22:36 <SamB_XP> didn't you learn about first-class functions in Python?
05:22:47 <mar77a> yes but never used them so
05:22:48 * mar77a shrugs
05:22:59 <SamB_XP> and python is not english ;-)
05:23:17 <wli> Cale: Well, the dirty secret behind them is that I wasn't even trying the vast majority of the time. It only took a couple weeks of trying when I finally did look at it after 10 years.
05:23:25 <oerjan> in haskell list comprehensions are syntactic sugar for first class functions :)
05:23:30 <Cale> wli: :)
05:23:59 <SamB_XP> wli: that doesn't count as taking ten years to understand monads
05:24:02 <wli> In Haskell monads are a crippled degeneration of monad comprehensions, which used to be far better.
05:24:11 <mar77a> i've heard so much about monads
05:24:13 <wli> SamB_XP: It makes the newbies feel better.
05:24:13 <SamB_XP> that counts as taking ten years to get around to bothering
05:24:16 <oerjan> @undo [x+1 | y <- [1..10], x <- [1..y]]
05:24:16 <lambdabot> concatMap (\ y -> concatMap (\ x -> [x + 1]) [1 .. y]) [1 .. 10]
05:24:27 <wli> ARGH
05:24:30 <mar77a> the funny thing is i don't know crap about them so every time someone says the word i imagine some sort of medieval monk
05:24:35 <wli> In Haskell list comprehensions are a crippled degeneration of monad comprehensions, which used to be far better.
05:25:07 <mar77a> im just having a hard time getting used to no commas and brackets in functions
05:25:12 <mar77a> i mean, when using them
05:25:14 <SamB_XP> should we change @undo to produce monadic expressions?
05:25:37 * SamB_XP wonders if that came out in bold for anyone else
05:25:43 <mar77a> neg
05:25:59 <oerjan> mar77a: that reminds me of a book on Forth i read where the compiler was pictured as a medieval monk :)
05:26:14 <SamB_XP> yeah, apparantly this channel has mirc color filtering on ;-)
05:26:42 <mar77a> +c?
05:26:49 * SamB_XP didn't use bold on purpose anyway
05:27:20 <oerjan> no bold here.  although my client shows _underline_ and *bold*
05:27:57 <oerjan> and that works even with +c of course
05:28:03 <SamB_XP> of course
05:28:07 <wli> So, who wants to rip the Prelude and its associated compiler intrinsics to shreds this weekend?
05:28:11 <Saizan> many haskell tutorial fail to mentions the syntax for function application, i didn't get it until i learned lisp first
05:28:35 <SamB_XP> wli: if you were to wait until christmas break I'd be on it
05:29:05 <wli> SamB_XP: You do realize I'm talking about ghc hacking here?
05:29:10 <oerjan> ghc, the contrarevolution
05:29:17 <SamB_XP> Saizan: probably this is because the tutorial writers forgot haskell had syntax for function application
05:29:23 <SamB_XP> wli: quite so
05:29:48 <oerjan> it is easy to forget that space is syntax :)
05:29:57 <mar77a> isn't mapping another way of doing a list comprehension
05:30:21 <Saizan> map f xs = [f x | x <- xs], yes
05:30:28 <oerjan> mar77a: list comprehensions are essentially concatMap
05:30:32 <SamB_XP> @undo [f x | x <- xs]
05:30:33 <lambdabot> concatMap (\ x -> [f x]) xs
05:30:45 <SamB_XP> hmm, that's a funky way to compile that...
05:30:46 <mar77a> er, im still not getting what undo does exactly
05:31:09 <Taejo> I still don't understand why concatMap and not map
05:31:10 <SamB_XP> I hope nobody actually implements the desugaring that way in a compiler!
05:31:20 <oerjan> mar77a: it turns a comprehension or do block into more basic equivalent syntax
05:31:26 <SamB_XP> Taejo: I think the person who added list comprehensions to @undo was being lazy
05:31:38 <mar77a> how's that more basic oerjan
05:31:53 <quicksilver> SamB_XP: that's what I'd expect.
05:31:53 <oerjan> mar77a: it's how the haskell report defines it
05:31:57 <SamB_XP> mar77a: it's closer to haskell "Core"
05:31:58 <Taejo> mar77a, more basic syntax, not more basic to understand
05:32:00 <quicksilver> that's how list comprehension desugars
05:32:06 <mar77a> hehe
05:32:12 <SamB_XP> quicksilver: why would it desugar to be slow?
05:32:14 <mar77a> and what's the diff between concatMap and map
05:32:17 <quicksilver> that won't be slow
05:32:25 <quicksilver> it will fuse
05:32:34 <Taejo> @src concatMap
05:32:34 <lambdabot> concatMap f = foldr ((++) . f) []
05:32:39 <SamB_XP> quicksilver: it will?
05:32:40 <SamB_XP> how?
05:32:43 <oerjan> mar77a: concatMap f l = concat (map f l)
05:32:56 <quicksilver> the whole point of ghc's foldr/build fusion is to make list comprehensions fast
05:33:01 <oerjan> so it concatenates the lists resulting from the map
05:33:13 <quicksilver> well foldr/build + some associated "end-case" rules
05:33:16 <mar77a> ok, what?
05:33:21 <SamB_XP> quicksilver: so how does that fuse [] away?
05:33:30 <SamB_XP> the one around [f x]
05:33:30 <mar77a> lets see what concat does first
05:33:39 <SamB_XP> er. you know what I mean ;-P
05:33:49 <quicksilver> SamB_XP: I imagine there is a rule for it
05:33:50 <Saizan> > concat [[1],[2],[3]]
05:33:53 <lambdabot>  [1,2,3]
05:33:54 <EvilRanter> ?src concat
05:33:54 <lambdabot> concat = foldr (++) []
05:34:04 <quicksilver> foldr ((++) . (\x -> [x]) [] =~~= id
05:34:08 <quicksilver> I should think
05:34:10 <mar77a> those defs aren't helping at all, sorry :)
05:34:17 <oerjan> > map (\x -> [x+1]) [1,2,3]
05:34:18 <lambdabot>  [[2],[3],[4]]
05:34:21 <mar77a> thanks though Saizan , much easier from the examples
05:34:24 <oerjan> > concatMap (\x -> [x+1]) [1,2,3]
05:34:25 <lambdabot>  [2,3,4]
05:34:49 <oerjan> > [x+1 | x <- [1,2,3]] -- desugars to the previous one
05:34:50 <lambdabot>  [2,3,4]
05:35:18 <Saizan> mar77a: concat takes a list of lists and produces a single list concatenating them
05:35:35 <mar77a> but the inner lists can't have more than 1 element apparently
05:35:42 <mar77a> oh nvm, they can
05:35:56 <mar77a> is it recursive or does it work only on the first layer of lists
05:36:01 <quicksilver> just one layer
05:36:04 <mar77a> ow
05:36:05 <oerjan> mar77a: yeah, we just didn't use very good examples for that
05:36:15 <quicksilver> mar77a: the type tells you
05:36:17 <quicksilver> :t concat
05:36:18 <lambdabot> forall a. [[a]] -> [a]
05:36:20 <mar77a> saw
05:36:28 <quicksilver> mar77a: you can see that's only one layer being flattened
05:36:32 <quicksilver> :t concat.concat
05:36:34 <mar77a> hehe not really
05:36:38 <lambdabot> forall a. [[[a]]] -> [a]
05:36:41 <quicksilver> two layers!
05:36:45 <mar77a> right
05:36:52 <quicksilver> :t concat.concat.concat.concat.concat.concat
05:36:53 <lambdabot> forall a. [[[[[[[a]]]]]]] -> [a]
05:36:54 <mar77a> but i've no clue how the dot works there so i'll just pretend nothing happened
05:37:05 <quicksilver> runs one function after another
05:37:06 <oerjan> @src (.)
05:37:06 <lambdabot> (.) f g x = f (g x)
05:37:07 <quicksilver> basically
05:37:07 <mar77a> or maybe i do but it's not the best way to learn it?
05:37:22 <mar77a> hmm
05:37:45 <oerjan> (f . g) x = f (g x) is an equivalent way of writing that
05:37:50 <mar77a> > tail.tail [1,2,3]
05:37:50 <lambdabot>  Couldn't match expected type `a -> [a1]'
05:37:57 <mar77a> deceived
05:37:57 <EvilRanter> parentheses!
05:38:03 <EvilRanter> > (tail.tail) [1,2,3]
05:38:05 <lambdabot>  [3]
05:38:05 <mar77a> where? :o
05:38:08 <mar77a> blargh
05:38:19 <mar77a> why the brackets?
05:38:21 <EvilRanter> . is an operator; function application always binds tighter than operators
05:38:30 <mar77a> ah
05:38:33 <EvilRanter> so foo.bar baz = foo . (bar baz)
05:38:46 <mar77a> metasyntacitc error, unknown variable baz
05:38:51 <Cale> ahaha, all the replies to that blog post criticising Don's benchmark saying that Haskell memoises things automatically have all appeared at the same time, and all basically say the same thing :)
05:39:22 <oerjan> . is a bit evil though, it is used also for module notation so sometimes you need spaces around it as an operator
05:40:07 <EvilRanter> > [False..] -- this is also a problem
05:40:07 <lambdabot>  Parse error at "False..." (column 2)
05:40:10 <EvilRanter> > [False ..] -- this is also a problem
05:40:16 <lambdabot>  [False,True]
05:40:30 <kalven> the benchmark post was silly anyway
05:40:50 <resiak> it was funny
05:40:55 <EvilRanter> it parses Ident.. as the operator (.) in the module Ident
05:41:01 <mar77a> i was wondering if hs had bool vars
05:41:07 <EvilRanter> ?type Prelude..
05:41:08 <lambdabot> parse error on input `Prelude..'
05:41:11 <EvilRanter> ?type (Prelude..)
05:41:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:41:16 <EvilRanter> ?src Bool
05:41:16 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:41:21 <EvilRanter> yes, it has booleans :)
05:41:32 <EvilRanter> ?src (&&)
05:41:32 <lambdabot> True  && x = x
05:41:32 <lambdabot> False && _ = False
05:41:34 <chessguy> 'morning
05:41:38 <EvilRanter> but they're not primatives or anything
05:41:52 <mar77a> ow
05:41:55 <oerjan> well not quite primitives
05:42:29 <oerjan> the if then else expression is primitive and knows about booleans, so that's a bit fishy
05:42:30 <mar77a> ok, according to this tutorial i have to take breaks between sections
05:42:33 <EvilRanter> well, conditionals and list-comprehensions rely on their definitions, but the definition itself is pure haskell...
05:42:48 <EvilRanter> unlike, say,
05:42:49 <EvilRanter> @src ()
05:42:49 <lambdabot> data () = ()
05:43:12 <chessguy> @src []
05:43:12 <lambdabot> data [] a = [] | a : [a]
05:43:22 <chessguy> ha
05:43:24 <oerjan> @src (,)
05:43:24 <lambdabot> Source not found. You type like i drive.
05:43:43 <EvilRanter> data (,) a b = (,) a b --?
05:43:52 <oerjan> indeed
05:44:15 <EvilRanter> data (->) a b = ???
05:44:16 <EvilRanter> :D
05:44:44 <oerjan> you _could_ imagine using S K combinators or something
05:44:53 <int-e> data (->) a b = \a -> b  ;-)
05:45:30 <oerjan> eek
05:46:05 <mux> <<loop>>
05:46:06 <mux> :)
05:46:48 <chessguy> @quote loop
05:46:49 <lambdabot> chessguy says: the loop is only in your brain
05:47:10 <chessguy> hiya int-e, haven't seen you around much lately
05:47:42 <quicksilver> EvilRanter: () is nearly pure haskell. It's only the syntax class at fault :)
05:47:47 <int-e> maybe I haven't been around much. :)
05:47:47 <quicksilver> EvilRanter: [] is much odder.
05:47:57 <EvilRanter> indeed
05:48:33 <chessguy> that would be a logical explanation, but i wouldn't make such an accusation without further evidence :)
05:52:46 <SamB> yeah, at least () behaves the same in both value/pattern and type contexts ;-P
05:56:23 <mar77a> ok what the heck
05:56:32 <mar77a> map takes a function and a list and returns a list
05:56:40 <mar77a> what's map (10 -) supposed to do
05:56:51 <mar77a> where's the list and the function?!
05:56:54 <EvilRanter> > (10 -) 1
05:56:55 <lambdabot>  9
05:57:04 <EvilRanter> > (2^) 3
05:57:05 <lambdabot>  8
05:57:08 <reinierrr> it returns a function that subtracts every member of a list from 10
05:57:08 <SamB> @type (10 -)
05:57:09 <lambdabot> forall t. (Num t) => t -> t
05:57:19 <EvilRanter> ?type map (10-)
05:57:19 <lambdabot> forall t. (Num t) => [t] -> [t]
05:57:24 <reinierrr> > let f = map (10 -) in f [2,3,4]
05:57:25 <lambdabot>  [8,7,6]
05:57:41 <mar77a> hmmm what
05:57:47 <mar77a> > (10 -)
05:57:49 <lambdabot>  <Integer -> Integer>
05:57:51 <SamB> mar77a: the list still needs to be passed
05:57:57 <mar77a> > (10 -) 1
05:57:57 <lambdabot>  9
05:58:00 <SamB> and (10 -) is the function
05:58:03 <mar77a> > 10-1
05:58:04 <lambdabot>  9
05:58:18 <mar77a> what's the C equivalent to (10 -)
05:58:21 <mar77a> 10-- ?
05:58:25 <EvilRanter> no, there isn't one
05:58:28 <SamB> there is none
05:58:33 <mar77a> what is (10 -) then
05:58:33 <resiak> int f(int x) { return 10 - x; }
05:58:34 <EvilRanter> C doesn't have functions as values
05:58:37 <idnar> (10 -) is basically \x -> 10 - x
05:58:40 <oerjan> mar77a: in haskell a function can be partially applied to less than its full number of arguments
05:58:58 <oerjan> the result is a function that takes the remaining arguments
05:59:01 <EvilRanter> mar77a, something doesn't have to exist in C to be real ;)
05:59:20 <mar77a> i didn't say so, i was wondering what was the equivalent syntax
05:59:23 <mar77a> and thanks resiak
06:00:21 <oerjan> for operators there is a special syntax for this, called sections. (10 -) = \x -> 10 - x and er, whoops, - is an exception but (/ 2) = \x -> x / 2 for example
06:00:54 <oerjan> (- 10) happens to be minus ten
06:01:11 <SamB> because some morons thought we had to do it the same way as everyone else
06:01:14 <idnar> hooray ambiguous operators :(
06:01:14 <mar77a> but where's the variable?!
06:01:26 <Cale> I really would be annoyed if (-10) wasn't negative 10.
06:01:48 <Cale> I think the compromise is reasonable.
06:01:54 <SamB> Cale: hmm, well, that could be different from (- 10)
06:02:06 <oerjan> mar77a: which variable?
06:02:12 <scook0> Cale: it just annoys me that (- x) is such a commonly-needed section
06:02:18 <SamB> and it's really annoying when you just wanted a section!
06:02:20 <scook0> compared to, say, (x -)
06:02:23 <Cale> SamB: But then you have things like (-x) meaning negative x and (- x) meaning the operator section?
06:02:23 <idnar> mar77a: in C, you might have a function like int f(int x, int y) { return x + y; }
06:02:41 <Cale> SamB: I suppose it could work.
06:02:46 <idnar> mar77a: you might write another function like int g(int y) { return f(5, y); }
06:03:01 <idnar> mar77a: so calling g is like calling f, with the first paramater always being 5
06:03:12 <SamB> Cale: it would be lexical, rather than grammatical, compromise
06:03:15 <mar77a> ah
06:03:18 <idnar> mar77a: in Haskell, when you say something like: f 5 10
06:03:20 <SamB> insert "a"
06:03:22 <oerjan> > let f x y = x+y; g = f 5 in g 2
06:03:23 <lambdabot>  7
06:03:25 <Cale> There's a function called subtract in the Prelude which was put there as sort of an apology for that special case.
06:03:29 <idnar> mar77a: that's the same as calling f(5, 10) in the C example
06:03:30 <Cale> > subtract 1 5
06:03:30 <lambdabot>  4
06:03:39 <idnar> mar77a: but if you just say: f 5
06:03:47 <idnar> mar77a: you're actually creating a new function like g on the fly
06:04:07 <SamB> too bad we can't do it like calculators because we only have one dash in ASCII
06:04:10 <SamB> :-(
06:04:12 <mar77a> what i don't get is this
06:04:19 <mar77a> subEachFromTen :: [Int] -> [Int]
06:04:19 <mar77a> subEachFromTen = map (10 -)
06:04:32 <dmwit> ?pl \x -> f (g x) x
06:04:32 <lambdabot> f =<< g
06:04:37 <mar77a> where's it passing anything
06:04:47 <mar77a> isn't map supposed to have a list as 2nd arg
06:05:00 <dmwit> map's third argument is a list
06:05:09 <idnar> @type map
06:05:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:05:10 <dcoutts_> @tell dons would you like to integrate mkcabal into cabal-install as a sub-command? (perhaps "cabal init" or something)
06:05:10 <lambdabot> Consider it noted.
06:05:15 <idnar> mar77a: ok, so you normally think of map as a function taking two arguments (a function and a list)
06:05:23 <mar77a> yes
06:05:28 <idnar> mar77a: so if you just pass one argument, the function
06:05:29 <SamB> I thought map only had two arguments
06:05:30 <scook0> dmwit: you mean second argument, I assume?
06:05:34 <idnar> mar77a: the result is a function that just takes a list
06:05:37 * dmwit goes to bed
06:05:40 <dmwit> I need sleep.
06:05:46 <EvilRanter> f x y = (f x) y
06:05:48 <doserj> SamB: map has only one argument (as any function)
06:05:48 <SamB> I need to go to school
06:05:49 <dmwit> Sorry if I confused anybody.
06:05:58 <EvilRanter> > (map (*2)) [1..10]
06:05:58 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
06:06:03 <SamB> doserj: !!! annoying way to talk
06:06:38 <oerjan> > map (map (*2)) [[1..5],[6..10]]
06:06:38 <lambdabot>  [[2,4,6,8,10],[12,14,16,18,20]]
06:07:00 <idnar> @type map
06:07:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:07:04 <idnar> @type map (10 -)
06:07:05 <lambdabot> forall t. (Num t) => [t] -> [t]
06:07:07 <EvilRanter> <SamB> too bad we can't do it like calculators because we only have one dash in ASCII <- could call negate (_); that way it'd be alphanumeric, too ;)
06:07:08 <idnar> @type map (10 -) [1..10]
06:07:09 <lambdabot> forall t. (Num t, Enum t) => [t]
06:07:12 <EvilRanter> anyway. away!
06:07:27 <SamB> _ is taken
06:07:48 <SamB> me also, away!
06:08:01 <resiak> doesn't unicode have distinct negate and subtract symbols?
06:08:31 <scook0> probably -- it has everything else
06:08:33 <sjanssen> yes
06:08:38 <wli> Where's that paper that talked about deriving virtual machines from languages automatically?
06:08:38 <sjanssen> but our keyboards don't
06:08:41 <idnar> I'm not sure about negate and subtract, specifically, but it has like three hundred different "dash" type characters
06:09:05 <resiak> perhaps we could claim the unicode snowman to mean negate
06:09:09 <idnar> mar77a: does that help, or are you still confused? :)
06:09:10 <scook0> 
06:09:33 <oerjan> @quote explode
06:09:33 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
06:09:42 <oerjan> @quote explode
06:09:42 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
06:10:05 <mar77a> well idnar i still don't get how can map take only one argument
06:10:08 <mar77a> when it's supposed to take two
06:10:16 <zipMe> Did fromForeignPtr and toForeignPtr change between the new Bytestring package and an older one ?
06:10:25 <oerjan> mar77a: _every_ haskell function takes their arguments one at a time
06:10:31 <pejo> wli, probably something by Danvy
06:10:34 <mar77a> what
06:10:39 <byorgey> mar77a: that's just it, it doesn't take two.  It is a function which takes one argument, and returns another function.
06:10:41 <dcoutts_> zipMe: mm, could well have done, gaining a parameter I think
06:10:42 <idnar> mar77a: as oerjan says, functions take their arguments "one at a time"
06:10:43 <zipMe> because I cannot compile this : http://www.haskell.org/haskellwiki/?title=Serialisation_and_compression_with_Data_Binary
06:10:43 <wli> pejo: I just need a URL.
06:10:44 <lambdabot> Title: Serialisation and compression with Data Binary - HaskellWiki, http://tinyurl.com/2gu6sj
06:11:06 <scook0> the assumption that map "needs" to take 2 arguments is inaccurate
06:11:08 <mar77a> what does that mean idnar
06:11:19 <zipMe> dcoutts_ : yeah exactly, what is the new int for ?
06:11:23 <scook0> @type map
06:11:25 <idnar> mar77a: when you write "someFunction a b c", that's basically the equivalent of this C code: someFunction(a)(b)(c)
06:11:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:11:37 <dcoutts_> zipMe: internally a ByteString is a pointer and offset and a length
06:11:43 <dcoutts_> zipMe: so 2 ints
06:11:49 <idnar> mar77a: which probably seems quite confusing if you're not used to thinking of functions as values
06:11:59 <mar77a> wth is that C code idnar :p
06:11:59 <zipMe> dcoutts_ : whereas before it was ... ?
06:12:24 <wli> Well, that's not quite true. The C code is a bit hairier than that.
06:12:32 <idnar> mar77a: maybe I should have said this: tempFunc1 = someFunction(a); tempFunc2 = tempFunc1(b); tempFunc3 = tempFunc2(c);
06:12:42 <idnar> mar77a: and that's not real code, because you can't actually do that in C
06:12:54 <idnar> err, that's "result" not "tempFunc3"
06:13:03 <mar77a> you can't?
06:13:20 <oerjan> idnar: i thought C functions could return function pointers just fine
06:13:30 <mar77a> they can
06:13:34 <wli> It can. That's not how currying is done.
06:14:10 <idnar> oerjan: you can't create functions dynamically
06:14:19 <zipMe> dcoutts_ :  in the old version there was no offset, just a pointer and a length ?
06:14:25 <idnar> oerjan: well, without returning pointers into a buffer of dynamically generated code or something insane
06:14:28 <dcoutts_> zipMe: yep
06:14:29 <oerjan> > let f = map (+1) in f [1..10]
06:14:31 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
06:14:41 <wli> Basically you do supercombinators and contexts.
06:14:41 <oerjan> > map (+1) [1..10]
06:14:42 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
06:14:42 <zipMe> dcoutts_ : Ok , thx
06:15:00 <idnar> mar77a: in Haskell, when you declare a function that takes two arguments
06:15:00 <wli> When the supercombinator is saturated you actually do the call.
06:15:04 <dcoutts_> zipMe: internally there was always the offset, it just wasn't exposed by fromForeignPtr and toForeignPtr
06:15:42 <idnar> mar77a: it's actually just a function that takes one argument; when you call that function, it produces another function, that takes the second argument; when you call *that* function with your second argument, you get the actual result
06:15:56 <mar77a> ahhh
06:15:58 <mar77a> currying!
06:16:00 <mar77a> *plim*
06:16:02 <scook0> wli: you *could* do it that way [raw function pointers], if you were willing to do runtime code generation -- not that you'd *want* to
06:16:17 <idnar> mar77a: yes!
06:16:26 <mar77a> how does it fit in the map (10 -) example then
06:16:40 <scook0> wli: e.g. I believe that's how the FFI exports arbitrary Haskell functions to C-land
06:16:41 <reinierrr> you curry twice
06:16:59 <reinierrr> you curry (-) to make the function (10 -) that subtracts a given number from ten
06:17:08 <reinierrr> and then you curry map to map that function on a given list
06:17:17 <mar77a> argh im not 'seeing' it
06:17:21 <mar77a> i'll leave it for later
06:17:49 <zipMe> dcoutts_: I changed fromForeignPtr (castForeignPtr fp) (n * sizeOf (undefined :: a)) to fromForeignPtr (castForeignPtr fp) 0 (n * sizeOf (undefined :: a))
06:17:51 <scook0> remember that "partial application /= currying" :)
06:18:08 <scook0> (i.e. "currying" is often mis-used to mean "partial application")
06:18:13 <zipMe> dcoutts_: do I update the wiki page with the serialization example ?
06:18:57 <reinierrr> scook0: i realize my mistake :)
06:19:34 * scook0 proudly pats his "currying crusader" badge :)
06:19:40 <mar77a> ok i think here's the key
06:19:43 <mar77a> "Again, one step at a time. '(10 -)' is a function. It takes a number and returns ten minus that number."
06:19:48 <mar77a> where's that 'number'?
06:20:15 <reinierrr> it's not written there
06:20:19 <idnar> mar77a: well, it's a function that takes one parameter, and that's the number that is subtracted from 10
06:20:27 <reinierrr> you have to give it a number, and then it subtracts that
06:20:37 <mar77a> what if i don't give it a number
06:20:49 <idnar> > let f = (10 -) in f
06:20:50 <scook0> mar77a: then it won't give you an answer :)
06:20:55 <reinierrr> then you just have a function that's still waiting for a number
06:20:56 <lambdabot>  <Integer -> Integer>
06:20:58 <idnar> > let f = (10 -) in f 5
06:20:59 <lambdabot>  5
06:21:00 <mar77a> so why is it working if i do map (10 -)
06:21:05 <scook0> same as any other function -- if you don't apply it, it won't do anything
06:21:07 <mar77a> where is it getting anything?1
06:21:20 <Stinger_> map applys a function to the elements of a list
06:21:22 <Japsu> but you know what's evil?
06:21:23 <Japsu> this
06:21:26 <idnar> mar77a: when you call subEachFromTen with some list
06:21:26 <mar77a> oh my god
06:21:27 <Japsu> > map (-1) [1,2,3]
06:21:27 <Stinger_> and returns the resulting list
06:21:28 <lambdabot>   add an instance declaration for (Num (a -> b))
06:21:33 <Japsu> > map (+1) [1,2,3]
06:21:34 <mar77a> yes yes yes idnar
06:21:34 <lambdabot>  [2,3,4]
06:21:36 <mar77a> i GOT it
06:21:37 <Japsu> > map (subtract 1) [1,2,3]
06:21:37 <lambdabot>  [0,1,2]
06:21:40 <idnar> mar77a: wooo :)
06:21:46 <mar77a> man i love this
06:21:48 <Japsu> @t (-1)
06:21:48 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:21:54 <Japsu> :t (+1)
06:21:56 <Japsu> :t (-1)
06:21:57 <lambdabot> forall a. (Num a) => a
06:21:57 <lambdabot> forall a. (Num a) => a -> a
06:21:59 <mar77a> it's like the chemistry way
06:22:17 <dcoutts_> zipMe: what example on the wiki?
06:22:20 <Japsu> bah, stupid slow-ass bot
06:22:22 <Japsu> @botslap
06:22:22 <lambdabot> Unknown command, try @list
06:22:47 <oerjan> Japsu: you mean @botsmack
06:22:51 <reinierrr> Japsu: maybe we should rewrite the bot in C to make it faster :)
06:22:54 <Japsu> oerjan: yeah, I mean @botsmack
06:22:57 <Japsu> reinierrr: hahaha
06:23:20 <Japsu> (nah, it was probably my freenode connection that lagged)
06:25:59 <zipMe> dcoutts_: Serialisation and compression with Data Binary
06:26:08 <zipMe> dcoutts_: http://www.haskell.org/haskellwiki/Serialisation_and_compression_with_Data_Binary
06:26:09 <lambdabot> Title: Serialisation and compression with Data Binary - HaskellWiki, http://tinyurl.com/2ca94x
06:28:11 <dcoutts_> zipMe: I see, yes I guess so
06:28:12 <zipMe> dcoutts_: i've changed Data.ByteString.Base Data.ByteString.Internal and added 0 as a new parameter (offset) to fromForeignPtr
06:28:23 <dcoutts_> ok, good
06:28:37 <zipMe> ok
06:28:55 <dcoutts_> zipMe: personally I think all that code is fairly horrible, having to use Data.ByteString.Internal is a good indication of it being horrible
06:29:22 <dcoutts_> I don't see why it can't be just in terms of the public interfaces to Data.Binary and Data.ByteString
06:30:26 <zipMe> dcoutts_ : right, well quite frankly the code goes over my head, I just wanted to try it
06:31:03 <phlpp> @src subtracte
06:31:03 <lambdabot> Source not found. Do you think like you type?
06:31:06 <phlpp> @src subtract
06:31:06 <lambdabot> subtract x y = y - x
06:32:32 <wli> Oh duh.
06:33:00 <Japsu> (-1) is the Num literal minus one
06:33:13 <Japsu> (+1) is a function Num a => a -> a
06:33:43 <jimstutt> zipMe: I've had fps bytestring clash. Now fps/Data/Base.hs wants -fvia-C on foreign import call which doesn't work..
06:33:53 <mar77a> so subEachFromTen = map (10 -) is as simple as
06:33:58 <wli> CPS transform on one-step evaluator gives an obvious abstract machine.
06:34:06 <mar77a> subEachFromTen x === map (10 -) x
06:34:26 <dcoutts_> jimstutt: hmm?
06:34:30 <phlpp> map ((-) 1) [1,2,3]
06:34:31 <byorgey> mar77a: exactly.
06:34:35 <phlpp> > map ((-) 1) [1,2,3]
06:34:37 <lambdabot>  [0,-1,-2]
06:34:37 * wli knows all this stuff.
06:34:42 <mar77a> ok
06:34:46 <phlpp> > map (`(-)`1) [1,2,3]
06:34:46 <lambdabot>  Parse error at "(-)`1..." (column 7)
06:34:55 <phlpp> doh!
06:35:47 <byorgey> > map (subtract 1) [1,2,3]
06:35:48 <lambdabot>  [0,1,2]
06:36:06 <byorgey> phlpp: you can't have arbitrary expressions in between ` `
06:36:11 <doserj> > map (flip (-) 1) [1,2,3]
06:36:11 <lambdabot>  [0,1,2]
06:39:05 <zipMe> jimstutt: i might be wronh but i think fps is the old bytestring before it made it into the standard libs
06:40:24 <mar77a> is there a void equivalent for haskell?
06:41:38 <byorgey> mar77a: well, there's (), the unit type.
06:41:46 <byorgey> mar77a: it only has one value, namely ().
06:41:59 <mar77a> can i define a function like
06:42:03 <mar77a> stuff () 0
06:42:14 <mar77a> er
06:42:31 <mar77a> stuff :: () -> Int
06:42:38 <opqdonut> yeah of course
06:42:40 <byorgey> mar77a: sure
06:42:50 <opqdonut> > let stuff () = 1 in stuff ()
06:42:51 <lambdabot>  1
06:42:57 <byorgey> mar77a: it wouldn't be all that useful though, because all you could do is return the same Int all the time.
06:42:57 <opqdonut> > let stuff = \() -> 2 in stuff ()
06:42:57 <lambdabot>  2
06:42:59 <Stinger_> const 1 ()
06:43:02 <Stinger_> > const 1 ()
06:43:03 <lambdabot>  1
06:43:13 <mar77a> i know byorgey , i was thinking of IO printing functions
06:43:14 <opqdonut> yeah, but you'll have to restrict the type of const
06:43:37 <Stinger_> @t const 1
06:43:37 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:43:42 <Stinger_> @ty const 1
06:43:43 <byorgey> mar77a: well, IO printing functions have to involve IO in the type.
06:43:45 <lambdabot> forall t b. (Num t) => b -> t
06:43:57 <byorgey> mar77a: a function with a type like () -> Int is not allowed to do any IO.
06:44:05 <mar77a> oh, why?
06:44:23 <Stinger_> here comes fun :)
06:44:29 <byorgey> mar77a: because Haskell is a "pure" functional language
06:44:29 <mux> because if it was doing IO, it would have type () -> IO Int
06:45:28 <phlpp> :t ()
06:45:30 <lambdabot> ()
06:45:34 <phlpp> :>
06:46:01 <jimstutt> zipMe: oh luck. plugins-1.0 demanded fps but tomh told me to use hs-plugins. Deprecation carnage in the apps needed?
06:46:12 <byorgey> mar77a: functions in Haskell are what is called "referentially transparent": the same inputs always result in the same output.
06:46:40 <zipMe> jimstuut: there you go, juste use hs-plugins and bytestring
06:46:47 <byorgey> mar77a: in C, if you have a function int foo(int x), and you call foo(6) twice, you *could* get different results, because you don't know what foo is doing behind the scenes
06:46:56 <byorgey> mar77a: it could read from a file or who knows what.
06:47:14 <jimstutt> zipMe: ta again
06:47:41 <byorgey> mar77a: in Haskell, if you have foo :: Int -> Int, foo 6 will always give you the same value, no matter how many times you call it.
06:48:12 <mar77a> byorgey: i don't see how it's related to what i wanted to do and you told me i can't
06:48:22 <mar77a> if i do print_something() it would always print that something
06:48:25 <mar77a> defined in the function
06:49:18 <zipMe> anybody knows when ghc 6.8.2 comes out ?
06:50:00 <byorgey> mar77a: well, perhaps I didn't explain it all that well.  but in any case, your print_something() function in Haskell would have the type print_something :: IO ().
06:50:20 <byorgey> it is an IO computation which doesn't return a value (that's the ()).
06:50:43 <doserj> mar77a: consider "let x = print_something () in x + x". should it print something once, or twice?
06:52:03 <doserj> compare your answer with "print_something () + print_something ()"
06:53:32 <bringert> anybody here with ghc on Cygwin who can check what System.Info.os returns?
06:54:57 <dcoutts_> bringert: it'll be the same as on mingw since ghc was built on mingw, not cygwin
06:55:07 <bringert> hmm, ok
06:55:32 <dcoutts_> bringert: if the cygwin ghc builds ever get resurrected then that could change
06:55:55 <bringert> dcoutts_: I want to use configurations to do add special cc-options when the package is being comiled under cygwin
06:56:08 <bringert> dcoutts_: I just want to give it -mno-cygwin
06:57:10 <bringert> maybe that's not needed anymore, I guess I'll have to test, or rather, force some windows user to do it
06:57:18 <mar77a> byorgey: IO computation?
06:57:26 <dcoutts_> bringert: as far as I know there is no way to detect if it's building under cygwin, since ghc never uses any cygwin programs, it uses it's own gcc etc
06:57:35 <swiert> mar77a: You might want to read: http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
06:57:37 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
06:57:52 <bringert> hmm, then maybe it's not a problem, since ghc wouldn't be using the cygwin gcc anyway
06:57:55 <swiert> It's pretty simple introduction to how Haskell treats I/O.
06:58:18 <Cale> mar77a: We represent I/O effects in Haskell explicitly as values. There are various primitive IO actions, and then functions which let you glue those action-values together into larger actions.
06:58:27 <bringert> dcoutts_: does ghc bundle its own g++ as well?
06:58:52 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- no, read my tutorial here :)
06:58:54 <lambdabot> Title: Introduction to IO - HaskellWiki
06:59:24 <dcoutts_> bringert: not sure, there was some discussion on it, I don't know what the outcome was.
06:59:39 <Cale> Basically, a value of type (IO t) is a data structure which represents an action to be performed. Evaluating that value doesn't cause the action to happen.
07:00:04 <Cale> The only action which really runs in a compiled Haskell program is 'main'.
07:00:17 <Cale> and in turn, it gets built out of smaller actions
07:00:27 <bringert> hmm, is there some way to share some of the build info between multiple executables in the same cabal file?
07:01:45 <Cale> mar77a: You said that your print_something would always print that same thing -- and that's effectively the realisation which allows IO to be treated the way it is in Haskell.
07:01:56 <mar77a> is haskell's indent like python's?
07:02:08 <Cale> mar77a: Quite a lot like it, but a little more flexible.
07:02:22 <Cale> mar77a: You'll want to make sure that your files contain no tab characters.
07:02:34 <mar77a> o_O
07:02:38 <Cale> (Most good editors can ensure that)
07:02:55 <mar77a> my question is if blocks are delimited by tabbing
07:02:58 <Cale> yes
07:03:18 <Cale> You can explicitly insert braces and/or semicolons if you want though
07:03:24 <Cale> in which case the layout will be ignored.
07:03:38 <mar77a> ah good
07:03:59 <Cale> However, people will think you're strange if you do it too much :)
07:04:43 <dcoutts_> bringert: not atm
07:04:48 <dnox> Cale: well that what people think about all haskell programmers so
07:04:54 <Cale> dnox: hehe
07:05:21 <Cale> dnox: Your nick is just similar enough to 'dons' to confuse me for about 1/2 a second :)
07:05:30 <jimstutt> FI: hs-plugins-1.0 : Error can't find AltData.Dynamic with any suffix ["hi"]. Then arrg @README # hi parsing broken.
07:06:38 <Cale> dnox: It must really be saying something then, if Haskell programmers think you're strange :)
07:07:04 <Cale> mar77a: Have you checked out my short tutorial?
07:07:06 <dnox> Cale: nono, i think you haskell programmers are strange ;)
07:07:34 <Cale> dnox: I'm not crazy, it's everyone else in the world who's crazy.
07:07:44 <Cale> ;)
07:07:52 <dnox> mm there is something into that
07:08:16 <mar77a> yes
07:08:21 <mar77a> but im dropping hs for a while
07:10:29 <yaxu> hm, :step is hanging sometimes
07:20:28 <yaxu> yep adding a breakpoint to my program is causing it to hang
07:28:00 <Cale> yaxu: That's interesting :)
07:32:14 <jimstutt> dons?: hs-plugins-1.0 : Error can't find AltData.Dynamic with any suffix ["hi"]. Then arrg @README # hi parsing broken.
07:36:53 <baggles> is this channel newbie friendly?
07:37:07 <allbery_b> we try
07:37:35 <baggles> :)
07:43:42 <fasta> baggles: we usually eat newbies for lunch... after the babies.
07:44:14 <baggles> heh
07:44:30 <Cale> baggles: yeah, it's newbie friendly :)
07:44:40 <Cale> baggles: I recommend asking lots of questions :)
07:45:17 <baggles> the general implementation that Everyone Uses is GHC? is there something better? is there a faq?
07:45:20 <BMeph> fasta: I'd like some Extra Virgin Baby Oil, please... ;)
07:45:22 <davidL> does someone know some clever way to combine two Word8 into one Word16? For example (23::Word8) and (91::Word8) becomes (5979::Word16)
07:45:31 <Cale> baggles: GHC is pretty much the standard.
07:46:06 <baggles> ok. it just took me a while to arrive at SBCL when going over lisp
07:46:26 <fasta> baggles: Hugs is faster for H98 development (not for running the code)
07:46:37 <davidL> > 0x175b -- "17" is 23 in hex and "5b" is 91 in hex
07:46:38 <lambdabot>  5979
07:46:51 <Cale> But Hugs is missing lots of neat things which GHC has
07:47:03 <fasta> Cale: like what?
07:47:24 <Cale> (like a profiler, debugger, etc.)
07:47:37 <fasta> Cale: ok, the profiler.
07:47:48 <fasta> Cale: the debugger doesn't count, since it doesn't work, yet.
07:47:57 <Cale> It sort of works :)
07:48:09 <fasta> Right, sort of, but it hasn't ever helped me in a real world situation.
07:48:16 <Cale> The program coverage stuff is also nice.
07:48:19 <davidL> (I'm sure there's some clever way to do it with bit shifting or something :-\ )
07:48:21 <fasta> (which is my definition of "work")
07:48:28 <mar77a> (comments)
07:48:30 <fasta> Cale: oh, right, that too.
07:48:32 <Cale> Then there's all the type system features and so on (but that's not Haskell 98)
07:49:08 <Cale> mar77a: hm?
07:49:17 <oerjan> > shiftL 8 23 <&&> 91 -- is this it?
07:49:24 <lambdabot>   Not in scope: `<&&>'
07:49:31 <Cale> .&. perhaps
07:49:45 <oerjan> > shiftL 8 23 .&. 91 -- is this it?
07:49:47 <lambdabot>  Add a type signature
07:49:57 <Cale> > shiftL 8 23 .&. 91 :: Integer
07:49:57 <lambdabot>  0
07:50:01 <Cale> > shiftL 8 23 .&. 91 :: Int
07:50:02 <lambdabot>  0
07:50:18 <oerjan> > shiftL 23 8 .&. 91 :: Integer
07:50:20 <lambdabot>  0
07:50:24 <oerjan> oops
07:50:27 <davidL> > 23 .&. 91 :: Int
07:50:28 <lambdabot>  19
07:50:29 <oerjan> > shiftL 23 8 .|. 91 :: Integer
07:50:32 <lambdabot>  5979
07:50:39 <davidL> nice! thank you
07:50:54 <Cale> oh, I see what you were doing :)
07:51:27 <davidL> I should probably learn binary
07:51:31 <Cale> davidL: Of course, you'll need some fromIntegrals to do the conversion as well. Convert to Word16 before the shifting of course :)
07:52:29 <Cale> baggles: There's also yhc which is a bytecode compiler, and jhc which does some interesting whole-program optimisations, but they're less-fully-featured than GHC.
07:53:02 <baggles> interesting
07:53:37 <Cale> Oh, and nhc98, which recently released a new version. It's easier to bootstrap on strange platforms than GHC is. I'm not sure about other advantages it might have.
07:54:01 <baggles> hum. well, my main interest is programming opengl things.
07:54:14 <Cale> Yeah, just get GHC which is what most people use.
07:54:28 <fasta> What's the best way to learn OpenGL, btw?
07:54:31 <baggles> yeah i already have it installed, i might do some experiments later.
07:54:32 <Cale> It should come with an opengl framework (or if it doesn't, it's easy to install one)
07:54:38 <baggles> how easy is it to bind to it?
07:54:40 <conal> baggles: do you have opengl projects in mind?
07:54:55 <conal> i'm also working with opengl in haskell
07:54:58 <baggles> fasta: nehe.gamedev.net has a bunch of tutorials, ask in ##OpenGL anyway :)
07:55:01 <fasta> I have "The Red Book", but it's literally filled with "do this and that for more performance".
07:55:05 <Cale> baggles: There's already a fairly nice (but direct) binding.
07:55:11 <baggles> well, i've been working in common lisp.
07:55:13 <fasta> baggles: I did ask in ##opengl, but nobody said anything.
07:55:16 <baggles> heh
07:55:28 <baggles> the opengl.org FAQ is pretty good
07:55:38 <fasta> baggles: and that url is in the \topic on ##opengl
07:56:07 <baggles> yeah. well, it's probably one of the best sites for breaking it all down. even if it is primarily targetted at win32/c++
07:56:09 <conal> andyjgill & are planning to make a functional wrapper for some opengl functionality.
07:56:12 <fasta> I'd rather just see a list of the primitive things in OpenGL.
07:56:19 <conal> (andyjgill & i)
07:56:25 <fasta> Without all the performance tweaks and multiple versions of functions.
07:56:25 <baggles> cool.
07:56:46 <baggles> i have to say, i'm still fairly swept away with writing it in common lisp still at the moment.
07:57:02 <baggles> but i'd like to at least learn haskell aswell. the functional thing seems very appealing.
07:57:28 <baggles> i should read this guy's thesis too http://www.haskell.org/haskellwiki/Frag#BibTeX_Entry
07:57:29 <lambdabot> Title: Frag - HaskellWiki
07:58:51 <conal> baggles: btw, you can use a very functional style in Common Lisp
07:58:56 <Cale> baggles: Yeah, Frag is a rather exciting proof of concept :)
07:59:12 <Cale> conal: ...if you're willing to fight with the language enough :)
07:59:29 <baggles> yeah, conal, but still, i think if i learnt haskell, it might encourage me to use it more.
07:59:36 <davidL> > let f x y = shiftL (fromIntegral x) 8 .|. (fromIntegral y) :: Word16 in f 8 0 -- thanks again oerjan & Cale
07:59:39 <quicksilver> I like data types.
07:59:43 <lambdabot>  2048
07:59:44 <baggles> but this idea that haskell has of somehow auto-managing the state... seems very appealing.
07:59:46 <quicksilver> that's why I use haskell not common lisp.
07:59:59 <quicksilver> I find that the code I want to write often includes data types :)
08:00:02 <Cale> conal: I mostly found CL to be pretty awkward for proper functional programming (at least as I think of it).
08:00:11 <conal> baggles: it might.  though a lot of people use IO instead of really programming functionally in Haskell.
08:00:24 <baggles> hum.
08:00:27 * wli looks for papers on deriving virtual machines.
08:00:28 <Cale> Scheme is a good deal better in that regard. At least it doesn't give functions a separate namespace.
08:00:29 <fasta> conal: huh?
08:00:33 <conal> Cale: what kind of awkwardness?  from strictness?
08:00:55 <conal> Cale: or the split function/non-function namespace?
08:01:02 <fasta> conal: AFAIK, most people only use IO when actually needed.
08:01:07 <Cale> conal: Well, strictness was an issue too. But mostly things stemming from that namespace issue.
08:01:22 <conal> Cale: yeah.  scheme is nicer in that way.
08:02:20 <Cale> conal: Also it seems that iterative side-effecting constructs are often preferred in CL while basic functional combinators often appeared to be missing.
08:02:21 <fasta> conal: any ETA on that OpenGL thing?
08:02:39 <Cale> (of course you can write them, but it's annoying)
08:03:14 <conal> Cale: yeah.  sigh.  i wrote lots of functional code in CL.  Scheme was nicer.  Haskell *much* nicer.
08:04:23 <conal> fasta: depends in part on whether wxHaskell is friendly to andyjgill's osx machine.  if so, he'd like to have something in a month-ish.  i've done this sort of thing several times, so it won't be hard.
08:04:38 <conal> just the OpenGL specifics are new to me.  and complicated.
08:04:53 <fasta> conal: heh, I was about to ask how you learned OpenGL...
08:04:59 <Cale> Lack of currying and the syntactic heaviness of function composition are another couple small things which contribute to CL and scheme's awkwardness with functional programming relative to Haskell.
08:05:12 <fasta> The specification in The Red Book is also ambiguous in various places.
08:05:30 <conal> fasta: how could anyone know when IO is "actually needed"?  more likely i'd say people use IO when they don't see a functional alternative.
08:06:18 <fasta> conal: well, by definition, you are right.
08:06:27 <fasta> conal: I just happen to know for my programs when to use IO.
08:07:03 <conal> fasta: sure.  and if someone gives you some new nice data types that abstract out your imperative patterns, you might shift to a more functional style.
08:07:38 <scodil> is there a way to have ghc --make put all the .hi and .o files in some other directory, other than where the .hs files are?
08:07:43 <Cale> (Excessive) IO is needed whenever you can't figure out how to clearly separate your model from the user interface of your program.
08:07:48 <fasta> conal: I would be highly surprised if someone would implement my data structures in a pure functional way (not using ST).
08:07:54 <Cale> This should be not-so-often.
08:08:08 <conal> fasta: e.g.,?
08:08:32 <conal> Cale: agreed.  i call that separating "model" from "presentation".
08:08:52 <conal> models are more composable than presentations
08:09:17 <Cale> xmonad is a pretty good example of a program which does this well, from what I understand
08:09:23 <fasta> conal: a structure supporting join, split and an option to refer to locations in the structure in constant time.
08:09:53 <conal> fasta: externally stateful, or internally?
08:10:01 <fasta> conal: ?
08:10:05 <Cale> fasta: Why is logarithmic time unacceptable?
08:10:25 <Cale> fasta: after all, you only have a finite amount of memory.
08:10:29 <fasta> Cale: it's a factor 20
08:10:34 <conal> Cale: yes, fairly nice.  but still has IO wrappers that are not removable, I think.
08:10:44 <fasta> Cale: based on experience.
08:11:00 <Cale> Have you tried Data.Sequence and found that it's too slow?
08:11:15 <fasta> Cale: Data.Sequence cannot do the things I asked.
08:11:30 <conal> fasta: do you have a purely functional interface around an imperative implementation?  or does the mutability show through?
08:11:31 <Cale> Perhaps I don't understand your description then.
08:11:45 <Cale> It does those three things in log time, from what I understand.
08:11:46 <fasta> conal: the function the module exports is purely functional.
08:11:54 <fasta> conal: but it uses ST internally.
08:12:24 <Cale> Well, that's what ST is for :)
08:12:40 <oerjan> scodil: -odir and -hidir iiuc
08:12:40 <conal> fasta: great.  all haskell data types are imperative destructively.
08:12:41 <fasta> Yes, but without references you cannot build such a data structure.
08:12:55 <conal> oops -- i meant implemented destructively (emacs abbrev-o)
08:13:10 <Cale> fasta: How does Data.Sequence not do that?
08:13:37 <fasta> Cale: how can you point to a location in a Data.Sequence?
08:13:41 <fasta> Cale: you cannot
08:13:43 <Cale> With an integer.
08:13:53 <fasta> Cale: and how long does that take to find the element?
08:13:59 <Cale> log time
08:14:04 <ptolomy> hehe. I've been reading the reddit comments to dons most recent blog posts... apparently the iterative fibonacci calculation is more efficient. Mind-blowing.
08:14:12 <Cale> (so effectively constant)
08:14:13 <fasta> Cale: and log time is not equal to the stated constant time.
08:14:25 <fasta> Cale: so, Data.Sequence is not going to work.
08:14:32 <conal> has anyone suggested the constant-time fibonacci algorithm?
08:14:33 <Cale> Yes, I'm saying, you should usually try it and see if it's too slow or not beforehand.
08:14:51 <wli> conal: What's that?
08:14:52 <ptolomy> conal: Yep.
08:14:56 <fasta> Cale: oh, for practical applications that might be true.
08:15:00 <fasta> Cale: this was research.
08:15:05 <Cale> Okay.
08:15:15 <conal> well, whoever suggested the constant-time algorithm, i guess their language is fastest.
08:15:28 <conal> ;)
08:15:30 <fasta> Cale: implement a dynamic tree implementation in Haskell without ST and I will applaud you.
08:15:35 <wli> conal: I suggested http://hpaste.org/1945
08:15:39 <pitecus> Do I need to pass some option to cabal to make a profiling version of a library?
08:16:01 <fasta> Cale: www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdf
08:16:09 <fasta> conal: www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdf
08:16:45 * ptolomy checks macports on a daily basis to see if ghc6.8 is up yet.
08:16:55 <fasta> Implement that in Haskell without ST (and without using unsafePerform* either directly or indirectly) and you did something new.
08:17:26 <Cale> fasta: I'm an advocate of soft-O, that is, of ignoring logarithmic factors as well as constant ones.
08:17:36 <conal> and fasta's example is, i think, not very relevant to the point i was raising about people mixing IO with pure.  if he's implementing a pure interface.  i mean more like Cale said about not knowing how to separate functionality from UI (GUI or otherwise).
08:17:40 <fasta> Cale: yes, we discussed that before.
08:17:54 <fasta> conal: I don't think that's a big issue in Haskell.
08:18:07 <fasta> conal: it's only in Visual Basic by incompetent programmers
08:18:15 <conal> fasta: not big to you, maybe
08:18:22 <fasta> (overly generalizing, of course)
08:18:30 <conal> it is, to me, because it breaks composability.
08:19:21 <fasta> They are mixed in current GUIs, because they are derived from imperative languages.
08:19:34 <Cale> conal: By the way, I saw your presentation with Eros the other day, which was great :)
08:19:42 <conal> Cale: thanks! :)
08:20:17 <conal> fasta: yes, including GUIs written in Haskell :(
08:20:42 <conal> but i think that's just for lack of seeing how to think about them functionally.
08:22:13 <pitecus> Any idea what this means:
08:22:15 <pitecus> src/GramLab/Data/StringLike.hs:10:0:
08:22:15 <pitecus>     Bad interface file: /home/gchrupala/lib/utf8-string-0.2/ghc-6.6.1/Codec/Binary/UTF8/String.hi
08:22:15 <pitecus>         mismatched interface file ways: expected , found p
08:22:15 <Cale> Obviously the answer is some kind of combinator library but hopefully one which is significantly better than the IO library, because there are much better ways to represent visual relations between things than we currently do in IO.
08:23:00 <Cale> pitecus: I don't really know what it means, but I recommend deleting that hi file and trying again.
08:23:38 <allbery_b> interface file was cvompiled for profiling, you're rying to use it in a non-profiled compile
08:23:53 <Cale> That's a crappy error message.
08:24:09 <Cale> It's probably worth submitting a ticket for that :)
08:24:10 <pitecus> ok i was passing --enable-library-profiling to cabal and didnt have -prof in ghc options
08:24:18 <pitecus> thats lame
08:24:37 <pitecus> why do i need to separate places to specify profiling?
08:24:42 <pitecus> to=two
08:27:48 <conal> so i'm imagining a niche for haskell as a language for building composable apps.  but we'll have to program in a more functional/composable style than the IO style.
08:28:26 <conal> i'd like to do it in a linux setting, where lots of little GUI apps that can be composed, Eros-style.
08:28:49 <conal> programmed syntactically as in TV or gesturally as in Eros.
08:30:04 <conal> and the clean separation that enables app composition also enables replacing interfaces with other styles, e.g., 3D.
08:31:00 <conal> i don't think C/Java programmers can do this style.  haskell programmers could but they'd have to think more functionally.
08:32:15 <conal> consider that in haskell an app has type IO ().  from the start we know it's not going to compose.
08:33:06 <fasta> conal: re: lack of... them functionally: I agree.
08:33:32 <wli> What exactly is the Fibonacci benchmark?
08:33:50 <conal> fasta: oh!  i didn't think you ever agreed with me. :)
08:36:35 <conal> anyway, TV is one way to think about and express GUIs functionally and composably.  and it's incredibly simple.
08:36:57 <conal> it's a seed, anyway.
08:37:11 <conal> @wiki TV
08:37:12 <lambdabot> http://www.haskell.org/haskellwiki/TV
08:38:14 <doserj> conal: unfortunately, i find you wiki pages rather confusing. I missing the "big picture" there.
08:39:21 <conal> doserj: oh.  thanks for that feedback.
08:40:18 <MyCatVerbs> conal: of course you can compose apps. Just use >> :)
08:42:07 <doserj> conal: maybe a simple overview page would help, where you explain how TV, GuiTV, DataDriven and what else relate to each other. Currently you have to follow all these links manually...
08:42:19 <conal> John Backus's "Can programming be liberated ..." paper describes why imperative programs don't compose well.  his analysis applies to imperative Haskell programming (IO) as well.
08:42:54 <conal> doserj: i like that idea.  thanks.  they really are pieces of a big picture, and i see i'm not getting that picture across.
08:43:26 <conal> they came from decomposing Eros into several independently usable pieces.
08:44:05 <conal> i'd like people to see how i'm combining them, while at the same time see that they can use them for other things.
08:44:25 <fasta> conal: Beans don't compose? Or what about COM?
08:44:36 <doserj> personally, I would also be interested in more details how this relates to FRP, what are the tradeoffs of the various proposed mechanisms for FRP, etc :)
08:44:39 <vincenz> > let new = 1 in new
08:44:41 <lambdabot>  1
08:45:14 <conal> fasta: have you read the backus paper?  i think he says it pretty clearly.
08:45:40 <conal> doserj: yeah -- that's way overdue.  FRP has so many implementation options with subtle trade-offs.
08:46:00 <conal> doserj: and i have yet another very different FRP implementation architecture i want to try out.
08:46:38 <doserj> conal: :)
08:46:51 <fasta> conal: do you have an url for that article (I only skimmed it once, I guess)?
08:47:02 <conal> fasta: looking ...
08:47:23 <conal> @go "can programming be liberated"
08:47:26 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
08:47:33 <conal> oh -- that's it
08:47:41 <conal> before i could find it in my citeulike
08:49:12 <MyCatVerbs> Hrmn. I think the type checker hates me.
08:49:29 <conal> MyCatVerbs: it's probably personal
08:49:35 <shapr> hah
08:50:24 <MyCatVerbs> I have an Class Foo a b, with member functions source :: b->a, target :: b->a, compose :: b->b->b and identity a->b, and instance Foo [a] (a,a->a,a).
08:50:35 <roconnor> conal: don't higher order IO types give use more composibility than impertive langauges?
08:50:52 <oerjan> MyCatVerbs: compose does not mention a?
08:50:53 <MyCatVerbs> That compiles, fine. Nice enough. When I try to *use* it, the type checker starts repeatedly kicking me in the monads.
08:51:03 <MyCatVerbs> oerjan: indeed, compose does not mention a.
08:51:06 <conal> roconnor: sure.  if what you want to compose is imperative computations.
08:51:23 <MyCatVerbs> oerjan: and when I attempt to *use* compose, the type checker fails to notice the instance. x_x
08:51:23 <oerjan> you have an fd at least?
08:51:46 <MyCatVerbs> oerjan: no, because I don't know how to use them and I'm not very clear on what they are. Are they what I need, please?
08:52:45 <MyCatVerbs> oerjan: e.g. I try compose ([1],id,[1]) ([1],(+1),[2]), and it's unable to find the instance Foo [a] ([a],a->a,[a]).
08:52:49 <oerjan> you could try adding | b -> a
08:53:37 <fasta> MyCatVerbs: it's not because the type checker doesn't "see" it.
08:53:39 <MyCatVerbs> Specifically, it complains that there's no instance of Foo o ([a],a->a,[a]) -- hence my feeling that the type checker hates me, since unifying o to [a] does make that expression work. x_x
08:53:43 <oerjan> if compose is to give a unique instance then a _must_ be derivable from b
08:53:55 <fasta> MyCatVerbs: it's simply because you didn't tell the compiler what instance to use.
08:54:05 <fasta> MyCatVerbs: this instance selection is done as oerjan said.
08:54:20 <dons> ?yow!
08:54:20 <MyCatVerbs> fasta: ah. But a) there's only one instance which maches the type of b, and...
08:54:21 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
08:54:41 <MyCatVerbs> b) how would I go about specifying a particular instance if there are multiple instances which could match, anyway, please?
08:54:50 <fasta> MyCatVerbs: The compiler doesn't care for your reasoning.
08:55:18 <MyCatVerbs> fasta: I could care to have my mental model of the compiler's reasoning updated, then. :)
08:55:18 <oerjan> MyCatVerbs: in haskell the instances the compiler sees are never assumed to be the only ones that can exist, unless you use a fd
08:55:29 <fasta> MyCatVerbs: you can give type annotations or use functional dependencies.
08:55:33 <MyCatVerbs> Dahhhhh.
08:56:02 <fasta> MyCatVerbs: if you want a better answer, show complete code on hpaste.org
08:56:04 <MyCatVerbs> Type annotations? But in an expression involving *only* compose functions, there's nowhere for the '[a]' variable to be indicated.
08:56:45 * MyCatVerbs is currently reading through a book on category theory, and attempting to code up all the constructs therein in a Haskell-idiomatic way.
08:56:55 <conal> roconnor: to be more clear (or try), composability really shines when we talk at the level of what things *are*, rather than performing actions.  semantics get much simpler.  useful properties abound.  programs are obvious in meaning.
08:57:03 <oerjan> MyCatVerbs: add | b -> a before where in the class declaration.
08:57:09 <MyCatVerbs> Don't have the code on hand (home machine with no internet connection, bummer) but I think I can reconstruct it from memory.
08:57:40 <MyCatVerbs> oerjan: ah, ookies. And this tells the compiler that it should use b's type to work out what type a will be?
08:57:52 <oerjan> more or less i think
08:57:57 <fasta> MyCatVerbs: "b determines a"
08:58:13 <fasta> MyCatVerbs: "b unique determines a" to be more precise
08:58:21 <MyCatVerbs> Handy.
08:58:23 <conal> or as backus says in "can programming be liberated ...", "von neumann languages lack useful mathematical properties" (section 9).
08:58:38 <MyCatVerbs> Fundeps seem to have a lot of warnings attached. Are they somehow really dangerous or something?
08:58:47 <fasta> MyCatVerbs: they were, imho.
08:58:54 <fasta> MyCatVerbs: I think they are bug-free now.
08:59:07 <conal> which translates to "haskell IO programming lacks useful mathematical properties"
08:59:13 <conal> (my translation)
08:59:14 <fasta> MyCatVerbs: i.e. my horrenduously complicated fundeps work now.
08:59:52 <bos> @seen  dons
08:59:52 <lambdabot> dons is in #ghc, #xmonad and #haskell. I last heard dons speak 5m 32s ago.
09:00:08 <earthy> um. haskell IO programming provides more useful mathematical properties than e.g. C IO programming does...
09:00:40 <oerjan> let me guess: they wanted associated types to replace fundeps, but as a side effect of making ATs and type families work they ended up fixing the problems with FDs?
09:00:41 <conal> earthy: e.g.,?
09:01:08 <hpaste>  MyCatVerbs pasted "Apparently I need fundeps x_x" at http://hpaste.org/4145
09:01:10 <MyCatVerbs> fasta: oh, awesome.
09:01:35 <MyCatVerbs> fasta: so just bugs, which have been fixed, rather than actual undecidability or anything which could cause my code to never compile? Sweet. ^^
09:01:53 <Cale> conal: I've always wanted to be able to wire gui elements from various programs together. The interface which I'd envisioned quite a long time ago involved something like using wires to demand that the value of two controls be equal, and then allow for abstraction with a tool for dragging and dropping UI elements (which might come from multiple other programs that have been wired together in this way) onto an initiall
09:01:53 <Cale> y blank window, and saving the result. This is somewhat less immediate than it happens in Eros, but it does provide an easy answer to how things should be edited later.
09:02:54 <conal> Cale: yep.  that's the boxes-and-arrows approach.
09:03:30 <conal> Cale: which i think of as syntactic and first-order.
09:04:06 <pitecus> will shadowing a variable cause the gc to collect the object it was bound to?
09:04:11 <conal> Cale: and because it's syntactic, the usual editing solution applies.
09:04:53 <dons> hey bos?
09:04:54 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:04:57 <fasta> MyCatVerbs: well, there's also undecidability, IIRC.
09:05:07 <fasta> MyCatVerbs: but not a problem I ever encountered.
09:05:40 <fasta> MyCatVerbs: well, that's only if you enable undecidable instances...
09:05:46 <MyCatVerbs> fasta: Dankeschon.
09:05:59 <chessguy> @quote ghc
09:05:59 <lambdabot> ghc says: Too many parameters for class
09:06:13 <scodil> is there a generic version of words? something akin to python's split?
09:06:23 <conal> Cale: did you have any thoughts on making that idea higher-order?
09:06:30 <fasta> MyCatVerbs: despite the huge hype surrounding associate type functions, fundeps are the system of choice currently for most things.
09:06:39 <bos> dons: you've stirred up a bit of a frenzy on the reddits
09:06:39 <oerjan> scodil: no
09:06:49 <Cale> I suppose the higher-order generalisation of that would be to have plugs for an output wire and input wire, with which you'd hook up another program.
09:06:56 <oerjan> it's frequently asked for though
09:07:14 <Cale> (connecting those plugs directly would provide the identity function, of course)
09:07:28 <dons> bos, so I think people have `par` in front of mind now. that's probably a good thing
09:07:58 <conal> Cale: doesn't the very style of interface distinguish between functions & values?
09:08:29 <dons> hopefully we get some more hammering on the thread spark code
09:08:36 <dons> squeeze out any perf issues
09:08:43 <nburlett> 'morning!
09:08:50 <conal> nburlett: hey ho!
09:08:53 <Cale> conal: Well, to some extent, yes. You could have a "lambda program" though.
09:09:00 <nburlett> is it possible to tell ghc to use a specific C compiler (instead of gcc)?
09:09:06 <Cale> (along with app)
09:09:13 <fasta> conal: when I read the intro of Backus' article, I read hygienic macros.
09:09:19 <dons> nburlett: -pgmc-gcc-6.0
09:09:32 <nburlett> dons: I don't follow...
09:09:34 <fasta> "algebra of programs whose variables range over programs"
09:09:55 <dons> the -pgmc- flag :)
09:09:58 <fasta> Well, you could argue that a function is a variable too, of course.
09:10:01 <nburlett> dons: ahh, I'll look
09:10:05 <bos> dons :-)
09:10:15 <conal> fasta: yeah, sigh.  he really means functions, not programs.
09:10:16 <fasta> Er a function a program too
09:10:24 <conal> a common semantics/syntax confusion.  :(
09:10:48 <nburlett> dons: so the syntax is -pgmc-command , not -pgmc command ?
09:10:52 <Stinger_> haha dons "Mr obvious"
09:10:56 <conal> like people refering to IO values as "programs" or unevaluated thunks as "expressions" :(
09:11:01 <Cale> You could have a program with 3 places to join things up to it: one for the parameter, one for the result, and one which outputs a function.
09:11:05 <dons> nburlett: right
09:11:23 <nburlett> dons: ok... the manual doesn't quite make that clear ;-<
09:11:27 <nburlett> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-C-compiler
09:11:29 <lambdabot> Title: 5.10. Options related to a particular phase, http://tinyurl.com/smq5n
09:11:31 <nburlett> (but now that I know, I can try it)
09:11:34 <dons> Stinger_: you have to use a combination of humour and violence, to win at internets :)
09:11:55 <Cale> and then either another one for apply, or you could simply use the same interface with directed wires.
09:12:25 <Cale> (so take a function on one wire and parameter on the other, and output a result)
09:12:49 <roconnor> @type par
09:12:50 <lambdabot> forall a b. a -> b -> b
09:13:01 <conal> Cale: and for a three-argument curried function?
09:13:28 <Cale> Well, you'll need to use three applications, which is a little visually awkward perhaps.
09:13:31 <roconnor> @type pseq
09:13:31 <lambdabot> Not in scope: `pseq'
09:14:04 <conal> Cale:; i meant how many "places to join things up"?
09:14:29 <Cale> The same, you'd just have 3 of these boxes each of which has 3 ports.
09:14:34 <oerjan> @index pseq
09:14:34 <lambdabot> GHC.Conc
09:14:39 <Cale> I'll draw it if you'd like.
09:15:42 <conal> Cale: i'd expect something like 7 ports on a three-parameter curried function.
09:16:30 <conal> Cale: one for each parameter, three for the three functions, and one for the final (non-function) result.
09:16:50 <Cale> conal: The function itself is a value which can be carried down wires and doesn't directly have ports. To apply it, you'd have a device which would take the function along one wire, the value to apply it to along another, and send the result along another.
09:17:06 <fasta>              I propose to call this tube the yon Neumann
09:17:06 <fasta> bottleneck.
09:17:21 <fasta> Didn't know it came from there...
09:18:05 <conal> fasta: yeah.  that paper is a real classic!  very influential.  as is Landin's "next 700 programming languages" paper.
09:18:20 <ddvlad> is there any way i can find out system load?
09:18:23 <fasta> conal: yes, I know it's a classic.
09:18:30 <Stinger_> top? ;)
09:18:52 <ddvlad> Stinger_: I meant with Haskell :-)
09:19:57 <ddvlad> hmm... i could parse the output of `uptime'
09:20:24 <conal> Cale: hard to discuss clearly in words.  of course something could be hacked up.  my goal is to match the simplicity of functional programming at the level of a simple & expressive lambda calculus and its type system.  no additional complexity or inconsistency.
09:21:00 <conal> Cale: that's what i think eros does fairly well.
09:21:56 <conal> Cale: and TV, as a programming interface.
09:21:56 <Cale> http://cale.yi.org/autoshare/function-apply.png
09:22:18 <conal> Cale: did you crank that out just now?
09:22:20 <Cale> yep
09:22:26 <conal> with what?
09:22:30 <Cale> Inkscape.
09:22:44 * conal googles
09:23:05 <conal> neat :)
09:23:14 <Cale> It's a nice open-source/free software solution for what Adobe Illustrator does.
09:23:24 <conal> i'll try it out.
09:23:36 <RayNbow> Inkscape takes a bit of time to get used to...
09:23:50 <RayNbow> but it can produce some nice EPS files which I can include in my LaTeX docs :)
09:24:04 <conal> Cale: i'm guessing you'd agree that this is a very syntactic approach.  and far from ideal for either programmers or users.
09:25:03 <fasta> Inkscape crashes after I draw 3 rectangles with some text.
09:25:15 <conal> fasta: then don't do that!
09:25:22 <conal> ;)
09:25:28 <baggles> heh
09:25:34 <Cale> Well, it's a graphical way to represent what Eros is collapsing when functions are applied.
09:25:42 <baggles> sodipodi was quite terribly buggy to begin with
09:25:49 <vincenz> "doctor, doctor, it hurts when I poke myself in the eye!"
09:25:50 <Cale> fasta: really?
09:25:56 <fasta> Cale: yes, no FUD.
09:26:03 <conal> Cale: yes.  eros visualizes semantics, while you're visualizing syntax.
09:26:11 <Cale> fasta: I don't think I've ever had a crash, and I've done some pretty complex things with it.
09:26:17 <fasta> Cale: I honestly tried to make a nice picture to visualise the stacking of my monad transformers.
09:26:34 <baggles> i'm curious as to what are the most famous/notable appllications written in haskell.
09:26:39 <fasta> Cale: then it just crashed, and it was not an installation problem.
09:26:50 <conal> fasta: try it again with Applicative.  (i should be charging you for all this medical advice.)
09:26:52 <fasta> baggles: see wiki
09:26:55 <Japsu> baggles: DARCS, the distributed revision control system
09:26:57 <gwern> famous? probably darcs
09:27:12 <Japsu> hmm, is DARCS an acronym btw
09:27:29 <gwern> Japsu: it apparently used to be
09:27:40 <Japsu> distributed algebraic .. ? :)
09:27:46 <baggles> where on the wiki?
09:27:55 <Cale> http://cale.yi.org/autoshare/Torraent.png -- for example this map of a city on a MUD which I used to play on.
09:28:02 <Japsu> http://en.wikibooks.org/wiki/Haskell/Applications
09:28:03 <lambdabot> Title: Haskell/Applications - Wikibooks, collection of open-content textbooks
09:28:05 <conal> david's advanced (?) revision control system.
09:28:07 <fasta> conal: ?
09:28:10 <conal> i think
09:28:14 <gwern> conal: advanced, yes
09:28:15 <Japsu> hmm
09:28:17 <Japsu> probably not that
09:28:43 <Japsu> (my link, I mean)
09:28:48 <Cale> fasta: Are there steps where I can try to reproduce that bug?
09:28:52 <Japsu> http://haskell.org/haskellwiki/Applications_and_libraries
09:28:55 <Japsu> that's better
09:29:10 <Cale> fasta: (maybe it's been fixed?)
09:29:16 <fasta> Cale: Unless there is a log for operations held by Inkscape, probably not.
09:29:45 <baggles> but still, anyone got anything to say, apart from Darcs, of an application that works well and really benefitted from being written in haskell?
09:30:00 <fasta> I'd rather see Inkscape in Haskell or some other safer language, since clearly people cannot program C, safely.
09:30:02 <gwern> xmonad? ghc?
09:30:03 <lament> parsec :)
09:30:06 <shapr> fasta: truly
09:30:07 <Cale> fasta: hehe :)
09:30:21 <Cale> fasta: Yeah, that would be rather nice to see.
09:30:48 <Cale> I also did the Cabal logo :)
09:31:02 <fasta> Cale: yes, I know. You had more success with Inkscape.
09:31:14 <conal> fasta: ("cannot program program C, safely"). is the topic of another classic i recommend: dijkstra's "the humble programmer".
09:31:22 * shapr boings cheerfully
09:31:28 <baggles> xmonad looks cool
09:31:42 <fasta> conal: dijksta also wrote something about natural languages as programming languages.
09:31:50 * desegnis pushes xmonad in re benefitted from being written in Haskell
09:31:52 <fasta> conal: in short: it's a really, really bad idea.
09:31:53 <Cale> baggles: It is quite cool if you like tiling WMs :)
09:31:59 <baggles> i used ion once.
09:32:21 <conal> fasta: are you suggesting we'd better discount his humble programmer paper?
09:32:33 <conal> fasta: or just adding an aside?
09:33:09 <fasta> conal: adding an aside
09:33:10 <Cale> Also, its support for the protocols that make things like the Gnome panel work correctly is still a bit lacking.
09:33:35 <Cale> (the gnome panel will run and list your windows, but clicking them does nothing)
09:33:44 <hkBst> any help on "ghc-6.6.1: unknown package: posix" ?
09:33:45 <conal> fasta: got it.  do you have a pointer to that paper.  he was awfully smart, so i'd like to know what he thought about natural languages as PLs.
09:33:54 <Cale> (and the pager doesn't really work properly either)
09:34:07 <conal> fasta: maybe it was a good idea ahead of its time
09:34:22 <lament> certainly sounds like a bad idea to me
09:34:28 <Cale> hkBst: oy, the package you're compiling uses the new split packages
09:34:28 <fasta> conal: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html
09:34:29 <lambdabot> Title: E.W.Dijkstra Archive: On the foolishness of "natural language programming". (EWD ..., http://tinyurl.com/2eh4ud
09:34:34 <Cale> (I think)
09:34:37 <conal> lament: how could one know, without learning more??
09:34:42 <conal> fasta: thanks!
09:34:49 <fasta> conal: no, the idea is: algebra good, natural languages don't have algebra => bad
09:34:54 <Cale> err...
09:34:56 <desegnis> Cale: That's an improvement. Once upon a time, xmonad could not even display the gnome panel properly without manual tweaking on every restart. (Once upon a time =~ recently, in xmonad terms)
09:35:33 <desegnis> (But one might add that the display thing is the Gnome developers' fault.)
09:36:03 <Cale> I also found that it discouraged me from having more than one window on each desktop, and my hands started getting tired quickly from hitting Alt+n
09:36:41 <Cale> Programs don't tend to be designed to squish themselves nicely into any rectangle you give them.
09:36:42 <ddvlad> how can I read the output of a command  I run with runCommand?
09:37:10 <Cale> ddvlad: Use a completely different function :)
09:37:25 <Cale> (runInteractiveCommand, iirc)
09:37:53 <psi> Cale: overlapping windows is a good thing, imo
09:37:58 <Cale> Managing the input and output streams can be a little difficult, so there's a nice library for shell-like piping.
09:38:01 <psi> tiling wms are awkward for me
09:38:06 <Cale> psi: I agree.
09:38:23 <Cale> ddvlad: Let me get you a link...
09:38:48 <ddvlad> Cale: I found runInteractiveCommand. I was close though -- the right module :-)
09:39:20 <Cale> yep :)
09:39:34 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH-1.2.4
09:39:35 <conal> hm.  i just read that Dijkstra paper that (fasta's url).  i think it argues *against* the idea programming computers in human language.
09:39:35 <lambdabot> http://tinyurl.com/2vmqhk
09:39:42 <Cale> http://software.complete.org/hsh
09:39:42 <lambdabot> Title: HSH
09:40:08 <Cale> (download link is at the bottom of that page, or if you have cabal-install, you can just use that to install it)
09:40:18 <ddvlad> Cale: thank you :-)
09:40:25 <Cale> The examples on the second link I gave show how to use it.
09:41:12 <fasta> conal: right, I said that.
09:41:43 <Cale> I wish there was a firefox extension which did for every page what the Trac wiki does with anchors. (show a small grey paragraph sign when hovering over a block that contains an anchor)
09:41:46 <conal> fasta: oh!  i misread your remark.
09:43:06 <conal> wow -- i like the two quotes at the top of http://www.cc.gla.ac.uk/courses/science/reason/reas1.htm
09:43:07 <lambdabot> Title: Reasoned Thinking I
09:44:11 <lament> conal: it seems good design to have entities in your system more or less reflect what is actually going on. I think you even say something to that effect (hopefully better expressed) on one of your webpages
09:44:56 <lament> trying to program using a natural language means using a representation very far from what's "actually going on" in any human terms
09:45:57 <conal> lament: further away than in programming languages?
09:46:00 <lament> on any level of abstraction, programs still remain formal systems and human languages still aren't
09:46:18 <ddvlad> Cale: pardon my ignorance, but how is that _that_ useful?
09:46:18 <lament> yes
09:46:31 <conal> lament: how so (further)?
09:46:43 <conal> lament: less precise, i get.
09:46:45 <Cale> ddvlad: For finding links to sections.
09:47:15 <hkBst> Cale: how are those split libs distributed? not all separately, or?
09:47:24 <Cale> ddvlad: Currently if you want to link someone to a particular section of a document, supposing that there's an anchor for it, you still either have to read the HTML or find a link provided by the author.
09:47:51 <ddvlad> Cale: hmm... i misread at first. you're right, it's quite useful to have that
09:47:59 <Cale> hkBst: er, hang on, posix is the package name?
09:48:07 <hkBst> Cale: I guess
09:48:26 <Cale> hkBst: I don't see that on hackage, so maybe I'm wrong about it.
09:48:38 <Cale> There's a 'unix' package.
09:48:49 <Cale> (which provides System.Posix)
09:48:52 <lament> conal: if "what's actually going on" is a formal system of some kind, human languages aren't ideal to represent it.
09:49:12 <conal> lament: so by "actually", you mean "precisely"?
09:49:32 <lament> no
09:49:44 <lament> by "what's actually going on" i mean "what's a good way to think about the problem?"
09:50:04 <conal> oh!  whether or not that's what's actually going on
09:50:12 <lament> if we accept that a good way to think of programming is constructing formal systems, then we need formal languages
09:50:15 <conal> useful for reasoning
09:50:33 <conal> lament: tautologically
09:50:40 <Cale> conal: So perhaps it would be possible to have windows which can be switched between the two styles arbitrarily -- for editing and display/use.
09:50:50 <Cale> (this is back in the previous thread)
09:51:12 <lament> and so far it certainly seems to me that programming is inherently "formal"
09:51:13 <conal> Cale: certainly!  the basic eros mechanisms allow that very elegantly, through DeepArrow.
09:51:30 <Cale> The wiring diagram is sort of what you'd see if you took the "cover" off of an Eros window.
09:51:50 <conal> lament: i agree with your conclusions, but it sounds like circular reasoning to me.
09:52:20 <lament> no
09:52:23 <conal> Cale: sure.  any number of representations can be carried along, as long as their transformers can implement DeepArrow.
09:52:42 <lament> that programming is constructing formal systems is a premise
09:52:50 <conal> Cale: including compilable code, types, pretty-printings
09:52:55 <lament> it might be wrong, it just seems very natural
09:53:12 <ricky_clarkson> I'm converting some code in an imperative language from using mutable lists to using lazy lists.  I find that if I want to keep the same order of elements in my lazy list I end up reversing the list when I've finished constructing it.  Seems bad.
09:53:14 <conal> lament: "natural" in the sense of nature?
09:53:35 <vincenz> I am not fully certain I agree that programming is constructing formal systems.  It's based onan observation someone else once told me.  Namely that all complex problems are defined within a human context
09:54:13 <conal> Gandhi said: neve confuse the what is "natural" with what is "habitual"
09:54:16 <lament> vincenz: that's true
09:54:19 <conal> s/the//
09:54:35 <lament> vincenz: but certain things we want from programming, like proof of correctness, imply a formal system
09:54:55 <Cale> conal: right :)
09:54:58 <vincenz> lament: Right, but if we look at the human context, then much of the interface is not specifieable as a formal system
09:55:21 <conal> vincenz: not specifiable, or we don't know how to specify them?
09:55:32 <vincenz> conal: Undefined
09:55:35 <lament> conal: i don't think i'm confusing natural with habitual.
09:55:41 <vincenz> conal: iow, I do not know
09:55:45 <conal> lament: i think what you're saying is that formal systems have certain benefits, particularly for constructing reliable software.  is that it?
09:56:26 <vincenz> conal: But if I think back on the wish-article I read on that site I gave you the link to, I would have to say unspecifiable
09:56:57 <hkBst> Cale: I think unix is included with ghc-6.6.1
09:56:57 <conal> vincenz: i care about the disctinction of not specifiable vs we don't know, because thinking the former means we don't try, while thinking the latter means we do.
09:57:19 * vincenz nods
09:57:30 <Cale> Well, programming, along with mathematics are both picking things selectively out of a formal system, but both the formal system and the selections made are highly steeped in human context.
09:57:43 <lament> conal: yes, and that these benefits are so crucial that not having them (ie telling some kind of an AI, "AI, do stuff!", and then it infers the details of what you really want, possibly making mistakes) would not constitute programming.
09:57:50 <Cale> hkBst: You can use ghc-pkg list to check that it's installed
09:58:06 <Cale> hkBst: But if it's complaining about posix... Is this a cabal package?
09:58:30 <conal> lament: is that statement your definition of the word "programming" or some claim of fact?
09:58:52 <hkBst> Cale: I have no idea. Hmm, did I mention I was trying to compile cayenne?
09:58:52 <conal> lament: i'm fine with that definition.  i don't know how to understand it as a claim of fact.
09:59:11 <Cale> hkBst: oh, hmm...
09:59:21 <_roconnor> mathematics is programming :)
09:59:29 <conal> roconnor: :) !
09:59:34 <Cale> augustss: are you around? hkBst could use help :)
10:00:10 <Cale> (I'm pretty sure Lennart is the one responsible for Cayenne)
10:00:15 <mux> yeah he is
10:00:22 <Cale> It's pretty old, so I don't know how easy it'll be to compile it.
10:00:47 <conal> speaking of which, here's a project: replace the foundations of the web with math (in what i think is roconnor's sense).  since it's math, it won't bite.  more concretely, Haskell w/o IO.
10:00:52 <hkBst> Cale: we'll see. Hopefully Haskell doesn't break as easily as C does with every compiler upgrade :)
10:00:55 <chessguy> for a second, i read that as "he's pretty old, so..."
10:00:56 <mux> last time I got interested in it, someone from here discouraged me and suggested I try agda instead, or something
10:01:18 <mux> dependent typing is mind twisting anyways =)
10:01:19 <Cale> hkBst: Haskell is *much* faster changing than C
10:01:37 <Cale> hkBst: That is, the language itself is changing fairly quickly.
10:01:45 <chessguy> it sure seems like new releases of GHC tend to break a lot of existing code
10:01:50 <conal> does anyone know the parnas quote defining "low level" programming?
10:02:00 <lament> conal: for most software i can think of, it seems matter of fact that people expect it to work predictably and without errors. Perhaps that's just the kind of software we're used to because we're using formal systems for everything.
10:02:05 <vincenz> Cale: is it, or are we just defining new and new versions and labelling them with the same name?
10:02:08 <chessguy> @go parnas low level
10:02:18 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
10:02:20 <lament> s/expect/want
10:02:24 <chessguy> @go parnas low level
10:02:25 <Cale> vincenz: Basically :)
10:02:25 <mux> chessguy: I think that is at least partially because Haskell98 still lacks many features, and thus many many haskell code relies on unstable extensiosn
10:02:30 <lambdabot> http://catless.ncl.ac.uk/Risks/10.84.html
10:02:30 <lambdabot> Title: The Risks Digest Volume 10: Issue 84
10:02:44 <conal> lament: maybe so.
10:02:45 <mux> unstable as in expected to change
10:03:04 <conal> lament: that one may be habitual rather than natural.
10:03:17 <chessguy> @go parnas "low level"
10:03:18 <lambdabot> http://catless.ncl.ac.uk/Risks/10.84.html
10:03:18 <lambdabot> Title: The Risks Digest Volume 10: Issue 84
10:03:22 <mux> I don't expect 100% haskell98 code to break with a GHC upgrade at least
10:03:29 <Cale> hmm, GHC wont compile this anyway, because there are string literals containing extended UTF-8 characters
10:03:56 <salierix> What does memoise mean?
10:03:57 <lament> conal: there's also a related activity of just telling human subordinates to do stuff
10:04:02 <chessguy> well, just blame the haskell' committee then :)
10:04:08 <lament> conal: we call that management :)
10:04:09 <conal> lament: management.
10:04:11 <conal> :)
10:04:14 <vincenz> salierix: you mean in the sentece "Haskell does not memoise" ?
10:04:23 <mux> heh
10:04:23 <salierix> vincenz, yeah.
10:04:25 <Cale> hkBst: First step: edit the Makefile replacing posix with unix
10:04:27 <nburlett> salierix: it means to remember the result of a function given arguments
10:04:32 <conal> lament: google's "human computation" is another interesting data point.
10:04:44 <vincenz> Cale: is that an offsprung from the CMU work?
10:04:53 <vincenz> s/cale/conal
10:04:59 <Cale> salierix: memoisation is the technique of storing function results so as to not do the work of evaluating the function again when called with the same parameters
10:05:09 <b_jonas> human computation?
10:05:10 <conal> vincenz: Undefined
10:05:17 <njbartlett> nburlett: Whoa your nickname is way too similar to mine :-)
10:05:19 <vincenz> conal: I think the terminology comes from CMU
10:05:20 <salierix> Why doesn't haskell do it?
10:05:31 <b_jonas> is that like pidgeonrank but with humans so the environmentalists don't protest
10:05:32 <hkBst> Cale:  thanks :) getting farther
10:05:37 <vincenz> salierix: memoisation is a technique one may choose to apply to a function
10:05:42 <nburlett> njbartlett: not _that_ similar
10:05:46 <vincenz> salierix: however haskell does not do it for every function, unless you choose so
10:05:55 * conal steps out to gather some firewood and stoke the wood stove ...
10:05:59 <njbartlett> nburlett: Well, i was confused!
10:06:05 <vincenz> salierix: people often think haskell memoises everything, which is a mistaken understanding of some aspects of haskell
10:06:11 <salierix> Oh.
10:06:45 <mux> I've read spj say that excessive memoisation incurs memory leaks
10:06:52 <mux> so haskell only memoize CAFs, IIRC
10:07:07 <nburlett> njbartlett: you thought I was typing for you? ;->
10:07:08 <hkBst> Cale: indeed it now dies on Id.hs:109:5:lexical error in string/character literal (UTF-8 decoding error)
10:07:16 <vincenz> mux: haskell only memoizes zero-argument functions :)
10:07:29 <hkBst> "<B7>"   -> FInfixr 8
10:08:24 <Cale> hmm
10:08:35 <Cale> maybe it's not UTF-8
10:09:03 * mux hopes baggles' quit message wasn't referring to haskell
10:09:04 <salierix> How can haskell have memory leaks?
10:09:18 <Cale> aha
10:09:24 <vincenz> salierix: the same way any language can have memory leaks, by storing references to data that are no longer useful
10:09:31 <Cale> opening the file in gedit and resaving it in UTF-8 worked
10:09:54 <ricky_clarkson> :t join
10:09:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:09:57 <vincenz> s/any language/any garbage collected language
10:10:19 <hkBst> Cale: indeed:   Id.hs: ISO-8859 Java program text      ???
10:10:47 <salierix> vincenz, but haskell has GC. Shouldn't it know what is currently being used?
10:10:48 <hkBst> or maybe file is just dumb :)
10:11:01 <vincenz> salierix: if you keep a reference to some data that is no longer useful, then it can not be gc'd can it?
10:11:24 <vincenz> That being said, memory leaks are a rarity for Haskell
10:11:34 <Cale> hkBst: It's ISO-8859-15
10:11:42 <Cale> hkBst: And it needs to be UTF-8
10:11:50 * conal is back
10:11:53 <njbartlett> It's the same in Java. If you dump a load of objects in a Hashtable, they can't be GCd.
10:11:57 <fasta> salierix: Deciding in general whether some value will ever be used again is....<fill in the answer>
10:12:15 <vincenz> fasta: ooh, ooh, I know "easy"!
10:12:48 <fasta> vincenz: since?
10:12:51 <vincenz> :P
10:13:13 <fasta> vincenz: or do you have one of those shiny Super Turing-Machines?
10:13:22 <vincenz> fasta: yeah, my new STM is great
10:13:38 <fasta> vincenz: what model?
10:13:53 <Cale> hkBst: There are a couple syntax errors in IUtil and CUtil having to do with newlines following the \\ infix operator
10:13:54 * chessguy has the Oracle edition
10:13:55 <vincenz> fasta: quantum-spj
10:13:57 <fasta> vincenz: the purple one that comes with a free pony?
10:14:12 <Cale> (I'm not quite sure what's going on there, but deleting the newline and spaces seems to work)
10:14:12 <vincenz> fasta: no the one with oleg included in the box
10:14:36 <chessguy> i think the pony would be more sociable :)
10:14:43 <Cale> great, I've got it compiled and linked :)
10:14:58 <chessguy> @quote oleg
10:14:58 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
10:15:35 <Cale> heh,  rm -r *~ is not a command that you want to insert additional spaces into. :)
10:16:25 <Cale> (Not that I did, just that I realised what would happen if I had :)
10:16:28 <chessguy> good advice, Cale
10:16:53 <b_jonas> does the quantum one have a cat inside?
10:16:53 <vincenz> Cale: that's what happens with untyped interfaces
10:16:59 <byorgey> Cale: it depends where the spaces go...
10:17:01 * chessguy starts a petition for an "ask Cale" column in HWN
10:17:01 <Cale> If you'd like, I'll tarball this directory
10:17:08 <fasta> vincenz: when do you expect to go Omega?
10:17:12 <vincenz> Cale: "Cale's advice"
10:17:17 * byorgey seconds chessguy's idea
10:17:22 <b_jonas> Cale: yeah, or press enter too early
10:17:36 <vincenz> fasta: Omega?
10:17:50 <b_jonas> that's why I've aliased (a variant of) 'rm *~' to 'rmt' in my shell
10:18:04 <fasta> vincenz: http://plus.maths.org/issue37/features/omega/
10:18:09 <lambdabot> Title: Omega and why maths has no TOEs
10:18:14 <byorgey> "Dear Cale, my GF says she will leave me if I don't stop spending so much time in #haskell.  What should I do?  --Torn in Memphis"
10:18:24 <Cale> http://cale.yi.org/autoshare/Cayenne.tar.gz
10:18:49 <Cale> byorgey: Teach your girlfriend Haskell.
10:19:09 <chessguy> "This week, Cale encourages a reader to apply a forgetful functor to mono-directional relations with overly-strict type restrictions"
10:19:33 <Cale> oy
10:19:43 <dons> ?users
10:19:43 <lambdabot> Maximum users seen in #haskell: 413, currently: 403 (97.6%), active: 17 (4.2%)
10:19:51 <vincenz> fasta: oh, my Omega is 2
10:19:57 <b_jonas> lol
10:20:02 <Cale> hkBst: Get that package and see if it builds for you :)
10:20:08 <byorgey> "This week, Cale shows how to implement Inkscape in 20 lines of Haskell."
10:20:19 <b_jonas> those would be very long lines
10:20:35 <fasta> vincenz: I think you forgot an infinite number of digits on that one.
10:20:36 <b_jonas> (or just a foreign call to the main function in the inkscape shared library?)
10:21:04 <vincenz> fasta: No, infinities are for those stuck to TMs, with STMs you can stick to finite numbers to define infinite processes.  You have the function "toInfinite . fromInteger"
10:21:07 <Cale> otoh, a Bzier spline algorithm would be less than 20 lines.
10:21:19 <byorgey> Cale: =D
10:21:39 <chessguy> man this channel gets wierd sometimes :)
10:21:57 <Cale> Sometimes?
10:22:00 <fasta> vincenz: I was talking about enumerating the digits.
10:22:34 <vincenz> fasta: I compress tthose into '2'
10:23:39 <b_jonas> well, I wrote a vector doodling program once
10:23:46 <Cale> @tell augustss http://cale.yi.org/autoshare/Cayenne.tar.bz2 -- Updated copy of Cayenne which compiles with GHC-6.8.1 (just had to fix a package name and some file format issues)
10:23:47 <lambdabot> Consider it noted.
10:23:53 <vincenz> b_jonas: in haskell?
10:23:57 <b_jonas> vincenz: no
10:23:59 <b_jonas> in ruby
10:24:08 <vincenz> +tk?
10:24:14 <b_jonas> it allows you to draw and edit filled polygons with the mouse
10:24:20 <pitecus> I have a simple question. In this program:
10:24:21 <pitecus> main = do
10:24:21 <pitecus>   fmap (last . lines . reverse) (readFile "f") >>= putStrLn
10:24:21 <pitecus>   putStrLn . show $ (fib (54))
10:24:22 <Cale> It'd be really cool to integrate Nymphaea with an Inkscape-like program.
10:24:32 <b_jonas> and no, colored xterm and xterm mouse support
10:24:36 <Olathe> > ffib 54
10:24:38 <lambdabot>  86267571272
10:24:39 <Cale> (which is an IFS drawing program I wrote with xerox)
10:24:47 <Cale> er, s/IFS/L-system/
10:24:50 <b_jonas> a moment, I have it up somewhere
10:24:53 <pitecus> how can I make sure that the contents of the file "f" are not retained after they arent needed any more
10:24:54 <pitecus> ??
10:25:03 <b_jonas> it's here: http://www.perlmonks.com/?node=ambrus%27s%20scratchpad
10:25:31 <pitecus> Right now this program seems to keep 1G data in memory after printing in the second line of the main
10:25:33 <b_jonas> search for the drawing of the elephant in that page, the code is above it, and the instructions above the code
10:25:44 <Olathe> Cale: Can you update the Fastest Fibonacci thing on the wiki (http://haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West) ?
10:25:45 <pitecus> right until exiting
10:25:45 <Cale> pitecus: that's a terrible way to print the first line of a file.
10:25:57 <pitecus> Cale I know its a test
10:26:04 <roconnor> conal: what are the foundations of the web?
10:26:18 <b_jonas> it's 186 lines total
10:26:20 <Olathe> (02:36.27) (wli) > let { fib :: Int -> Integer ; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] ; fib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g } in fib 25
10:26:24 <Cale> pitecus: you can force a GC, I suppose
10:26:25 <Olathe> (02:37.26) (wli) Olathe: There's the "even faster" fib.
10:26:28 <vincenz> b_jonas: you're the guy at the top?
10:26:41 <Cale> pitecus: there's a function called performGC
10:26:44 <b_jonas> vincenz: no
10:26:44 <pitecus> Cale, any idea why gc doesnt happen?
10:26:51 <Cale> pitecus: It should, really.
10:27:18 <pitecus> not according to what top says
10:27:25 <pitecus> Im really puzzled
10:27:35 <pitecus> And I have a similar proble ina real program
10:27:42 <Cale> Olathe: Anyone can edit.
10:27:48 <Olathe> Ahh.
10:27:52 <Olathe> Alright :)
10:28:04 <Cale> Olathe: you just have to log in.
10:28:12 <roconnor> conal: mathematics is programming because proofs are objects and theorems are dependent types---classical mathematics is restricted to types that have (extensionally) one object.
10:28:52 <b_jonas> vincenz: I'm the guy doing the Odin routine on http://www.perlmonks.com/?node=ambrus
10:28:54 <lambdabot> Title: ambrus
10:29:10 <fasta> pitecus: you use reverse on a rather big input.
10:29:14 <Cale> roconnor: huh?
10:29:18 <fasta> pitecus: I think that's the problem.
10:29:28 <Cale> roconnor: There are different inequivalent proofs of the same result in mathematics.
10:29:54 <pitecus> fasta, what does it have with GC?
10:29:58 <desegnis> fasta: I think pitecus did that by intention.
10:30:02 <roconnor> Cale: not usually.  This of course depends on my definition of equivalent.
10:30:07 <Cale> ah, okay
10:30:17 <pitecus> desegnis, right
10:30:27 <fasta> pitecus: can you paste a complete program (for my convenience)?
10:30:39 <pitecus> paste where?
10:30:46 <Cale> It's just that we're often more interested in whether there is a proof or not. However, it would be a tremendous lie to say that nobody cares about the structure of proofs.
10:30:51 <roconnor> Cale: the extensional equivlance makes all those different proofs the same.
10:31:16 <fasta> pitecus: hpaste.org
10:31:25 <roconnor> Cale: exactly, we are more intrested if there is a proof or not in part because the theorems have at most one proof. :D
10:31:37 <Cale> roconnor: No they don't. :)
10:31:46 <Cale> I don't think mathematicians think of them like that.
10:31:53 <roconnor> at most one proof upto extensionally.
10:31:55 <Cale> For example, many people are quite disturbed by the structure of the classification of finite simple groups.
10:31:58 <hpaste>  pitecus pasted "GC problem" at http://hpaste.org/4146
10:32:01 <allbery_b> wheee, I get to hope I can get my stuff (including dependencies) building under 6.8.1 because I'm triggering a 6.6.1 bug :)
10:32:05 <Cale> Its proof is way too long.
10:32:17 <Cale> (Over 10000 pages)
10:32:30 <pitecus> fasta, im wondering why the huge string is retained even after its not needed any more
10:32:39 <fasta> pitecus: are you sure, it's the string?
10:32:46 <roconnor> Cale: There are certainly multiple proofs upto intensional equivalence.
10:32:51 <pitecus> well its 1G memory
10:32:58 <pitecus> the contents of the file
10:33:03 <Olathe> What's lambdabot's command to see where a function is defined so I can import the thing ?
10:33:07 <fasta> pitecus: it's not the fib?
10:33:14 <byorgey> @index elem
10:33:14 <lambdabot> Data.List, Prelude
10:33:15 <pitecus> fasta its not the fib
10:33:19 <fasta> pitecus: did you profile it?
10:33:19 <Olathe> Ahh, thanks.
10:33:21 <pitecus> try it yourself
10:33:30 <ddvlad> this is going to sound stupid: is there a function :: IO String -> String, that runs the IO and returns the result?
10:33:34 <vincenz> b_jonas: looks painful
10:33:38 <Cale> roconnor: right, which is the equivalence that roughly approximates (I think) what most people use.
10:33:43 <roconnor> Cale: mathematics probably care about proofs upto intensionality to a similar degree that we compare about the intensionality of our haskell functions.
10:33:43 <pitecus> fasta, i just look at what top says
10:34:01 <pitecus> and if you just print the fib the meory usage is under 1M
10:34:04 <mauke> ddvlad: such a function can't exist (but it does :( )
10:34:11 <b_jonas> vincenz: it wasn't
10:34:31 <ddvlad> mauke: if it does, what is it? and how bad is it?
10:34:43 <mauke> unsafePerformIO
10:34:43 <Cale> roconnor: I personally find it disturbing how much intensionality is ignored in the face of length restrictions imposed by journals.
10:34:48 <fasta> pitecus: next time, I ask you to paste a complete program, I expect a complete program.
10:34:49 <roconnor> Cale: this intensional/extensional thing is probably the same as the syntax/semantic discussion you were having before.
10:35:07 <fasta> pitecus: this program is not complete, since it misses imports.
10:35:10 <b_jonas> I cheated: I solved two layers of the Rubik's cube before getting on the toy, and had to do only the bottom layer, so it took less than half minutes
10:35:12 <mauke> ddvlad: unsafePerformIO is unsafe because you can use it to circumvent the type system, segfault your program, etc
10:35:16 <pitecus> oh sorry import System
10:35:22 <roconnor> Cale: I didn't think journals had length restrictions.
10:35:25 <roconnor> (usually)
10:35:25 <b_jonas> (the Rubik's cube isn't really visible on that pic)
10:35:41 <b_jonas> plus, it was on a bicycle journey I quite enjoyed
10:35:51 <Cale> roconnor: Well, it certainly seems as if they do -- or at least apply some pressure in the direction of keeping things short.
10:36:15 <ddvlad> mauke: what i need to do is parse input. is this approach ok? getLine, parse input in non-monadic function, then return whatever results as IO monad?
10:36:16 <roconnor> Cale: but it isn't like the 15 page limit that conference proceedings usually have.
10:36:22 <Cale> Sure.
10:36:23 <roconnor> (in my limited experience).
10:36:46 <mauke> ddvlad: yes, you can do that with >>=
10:37:37 <ddvlad> mauke: i wanted to make sure that it's the right approach. sorry about all the minor questions
10:37:49 <Cale> It seems like in many cases things have eroded to the point where graduate students can spend 3 days and several pages verifying the gap between a couple of lines. It might be that some people are really thinking on that level, but in my experience it's more likely that the work was carried out and then discarded.
10:38:01 <roconnor> Cale: anyhow, I think my original point would be that if you only have one object (extensionally) in your type then what you have isn't very interesting from a programing prespective.
10:38:32 <Cale> (though this is another issue)
10:38:48 <roconnor> Cale: programs become more intresting when you have multiple objects per type, which is constructive mathematics.
10:38:54 <ski_> ddvlad : do {line <- getLine; return (parse line)}
10:39:16 <roconnor> Cale: although now that I write that, I'm not certain I believe it.
10:39:27 <ddvlad> ski_: thank you for the suggestion
10:39:27 <fasta> pitecus: GC does occur, but it's simply that this computation takes a lot of memory.
10:39:39 <mauke> @undo do {line <- getLine; return (parse line)}
10:39:39 <lambdabot> getLine >>= \ line -> return (parse line)
10:39:40 <fasta> pitecus: reverse is O(n)
10:39:52 <gwern> @src const
10:39:52 <lambdabot> const x _ = x
10:39:59 <pitecus> fasta, Im asking why the memory is not freed AFTER the revers and print
10:40:00 <fasta> pitecus: if you state an actual goal the program should achieve, I am sure I can make it run in a lot less space.
10:40:16 <fasta> pitecus: oh, that has an easy answer
10:40:17 <darrint> How do I display the default include path for ghc or ghci?
10:40:28 <pitecus> what is it then, fasta ?
10:40:45 <fasta> pitecus: GC only happens when their isn't a memory available anymore.
10:40:59 <fasta> pitecus: a lot of*
10:41:06 <fasta> there*
10:41:21 <fasta> pitecus: or if you do performGC
10:41:47 <pitecus> I tried inserting performGC and it doesnt change anyhting
10:41:51 <ski_> ddvlad : usually, when beginners want to "remove the `IO' part of a type", what they should be doing is using `<-' in `do'-notation (or `(>>=)')
10:42:16 <fasta> pitecus: did the program run to full completion?
10:42:23 <pitecus> It did
10:42:26 <fasta> pitecus: and did you compile it and not run it in ghci?
10:42:33 <ddvlad> ski_: i think i understand that now. my original approach was faulty
10:42:39 * roconnor thinks monad tutorial need to talk about Kleisli arrows.
10:42:42 <ski_> (ddvlad : `unsafePerformIO' are for very special circumstances, where you really want to trick the compiler .. not usual at all)
10:42:49 * esap is trying to use XShm with Haskell and getting "BadAccess (attempt to access private resource denied)" on X_ShmCreatePixmap :-(
10:42:51 <pitecus> if you have 1G of memory used which is no longer needed then  GC normally will happen
10:43:04 <pitecus> I dont understand why it doesnt in this case thats all
10:43:08 <ddvlad> ski_: just out of curiosity: isn't code operationg with monads a bit slower? (i know i shouldn't worry about this)
10:43:09 <fasta> pitecus: just answer the question
10:43:12 <pitecus> and yeah I ran the program compiled
10:43:22 <ski_> ddvlad : slower why ?
10:43:22 <mauke> pitecus: how did you determine that the memory wasn't freed?
10:43:39 <ski_> ddvlad : better : slower than what ?
10:43:40 <pitecus> by looking at top
10:43:52 <fasta> pitecus: that's a very bad method
10:44:00 <ddvlad> ski_: dunno, just imagined that if they're harder to understand they're also a bit slower. but that was silly
10:44:04 <mauke> does the GC actually return pages to the OS?
10:44:19 <fasta> pitecus: if you profiled it and are completely sure that it doesn't work as it should, you can file a bug report, but I doubt it.
10:44:45 <pitecus> i doubt its a bug too
10:44:56 <pitecus> Im just trying to understand whats going on
10:45:14 <ski> evening, esap
10:45:20 <fasta> pitecus: well, didn't I just explain that?
10:45:22 <pitecus> mauke are you saying that once memory is taken by a haskell program is stays there?
10:45:23 <esap> ski: evening
10:45:33 <pitecus> fasta, no you didnt sorry
10:45:34 <fasta> pitecus: yes, that's true.
10:45:37 <fasta> pitecus: yes, I did.
10:45:53 <pitecus> well you said that GC doesnt happen there
10:45:58 <pitecus> which i doubt
10:46:06 <fasta> pitecus: ...
10:46:08 <pitecus> mauke's explanantion makes some sense though
10:46:19 <mauke> pitecus: http://perldoc.perl.org/perlfaq3.html#How-can-I-free-an-array-or-hash-so-my-program-shrinks%3f
10:46:20 <lambdabot> Title: perlfaq3 - perldoc.perl.org, http://tinyurl.com/c4ey6
10:46:20 <fasta> pitecus: I will say it more formally.
10:47:53 <pitecus> thanks guys I see now
10:48:04 <fasta> pitecus: once a GHC compiled Haskell program has reached a space usage of XGB, it will never return that back to the OS.
10:48:13 <fasta> pitecus: it's a long standing feature request.
10:48:40 <fasta> pitecus: that explains what you see with top
10:48:54 <pitecus> Yeah I understand now. Thanks
10:49:15 <fasta> pitecus: if you profile it, you will see that when performGC is executed it will reduce the internal GHC heap, but still doesn't return memory.
10:49:53 <pitecus> ok
10:50:08 <fasta> If hpaste is after a very big pipe, you could do a ddos attack against it.
10:50:23 <fasta> (as an illustrative example ;))
10:50:48 <fasta> Just let a few hundred thousand machines send a maximum size paste to it.
10:51:08 <fasta> (assuming no special measures are taken by hpaste.org)
10:51:40 <pitecus> scary
10:59:49 <hkBst> Cale: could you give me a patch for IUtil and CUtil ?
11:05:09 <sethk> Hello, everyone.  I'm compiling a program that worked with ghc 6.4, but with ghc-6.8.1 I get "Could not find module Text.Regex".  Has the name of this module changed?
11:05:51 <sethk> 6.8.1  :)
11:05:57 <allbery_b> it isn't bundled in the base libs any more
11:06:00 <sethk> vs 6.6.12
11:06:04 <sethk> 6.6.1
11:06:08 <darrint> What function returns the length of a list?
11:06:10 <hkBst> Cale: never mind. I'm extracting it from your tarball
11:06:23 <allbery_b> get the extralibs package if you installed a binaru distribution, or check whatever repo you got packages from
11:06:25 <sethk> allbery_b, operationally, what does that imply?  That I need to add a package?
11:06:27 <allbery_b> darrInt: length
11:06:27 <daniel_larsson> > length [1..10]
11:06:30 <lambdabot>  10
11:06:33 <allbery_b> sethk: yes
11:06:35 <sethk> allbery_b, no, I work only from source
11:06:38 <darrint> duh. Thanks.
11:06:41 <allbery_b> it should be on hackage as well
11:06:51 <sethk> allbery_b, ok, I couldn't remember the name hackage.  :)
11:06:56 <sethk> thank you
11:06:58 <allbery_b> hackage.haskell.org
11:13:32 <roconnor> @bab nl en verzameling
11:13:33 <lambdabot>   collection
11:13:41 <sethk> this is really weird.  I'm in hackageDB, and I clicked on regex-base.  On the "Other versions" line, the last number is 0.92.  If I click on 0.92, it changes to 0.91 and the version in parantheses in the title becomes 0.92
11:13:48 <sethk> and each time you click it, the two exchange
11:13:56 <sethk> one becomes 0.91, and the other becomes 0.92
11:14:30 <allbery_b> sounds sensible to me
11:14:41 <allbery_b> it shows all available versions; the current one is parenthesized
11:15:01 <roconnor> @bab nl en meetkundig
11:15:07 <lambdabot>   geometrical
11:15:15 <roconnor> oh
11:15:21 <sethk> allbery_b, but it's off by 0.1
11:15:26 <sethk> 0.01, actually
11:15:43 <sethk> oh, I see what you mean
11:15:56 <sethk> there are six versions, five on the line and one above
11:17:08 <EspenG> i'm experiencing the same problem as this blog post describes: http://monad.nfshost.com/wordpress/?cat=8 how can i solve this?
11:17:08 <lambdabot> Title: A kick in the monads  open question
11:18:52 <sethk> allbery_b, I downloaded a tarball.  Now I do runghc Setup configure, etc.?
11:19:23 <allbery_b> yes
11:19:44 <sethk> thanks.  I assume the dependencies are also in hackage.  At least I hope they are.  :)
11:22:02 <Cale> EspenG: The problem is that return is also the name of a prelude function.
11:22:23 <Cale> EspenG: Also, that you have to have an instance of Monad to use the do-notation.
11:22:33 <Cale> EspenG: (which would involve defining return)
11:22:47 <Cale> EspenG: It's best to treat that particular code as pseudocode.
11:22:54 <EspenG> ok
11:23:22 <Cale> EspenG: There should eventually be a proper instance of Monad so that the code on page 77 works.
11:23:37 <EspenG> ok
11:23:55 <hkBst> Cale: did you get cayenne to "make all"?
11:23:56 <Cale> but it'll involve redefining the Parser type because to define an instance you need more than a type synonym.
11:24:22 <Cale> hkBst: I believe so. Let me check again :)
11:24:41 <Cale> (I got it to 'make' at least.)
11:24:49 <hkBst> yeah, I got that too :)
11:24:58 <hkBst> with your help :)
11:25:11 <Cale> yes, "make all" works
11:25:17 <Cale> Did you get the tarball I made for you?
11:25:24 <ricky_clarkson> Isn't there some algorithm for choosing a random element from a list without knowing its size in advance?
11:25:37 <Cale> ricky_clarkson: With uniform probability? No.
11:25:39 <hkBst> Cale: no, but I got the patches
11:25:44 <Cale> hkBst: oh
11:25:49 <Cale> hkBst: There was more than that.
11:25:53 <Cale> (I think?)
11:26:05 <integral> Yes, you keep a regsiter containing "currently chosen value".  Then choose the first element with probablility 1/1, the second 1/2, the third 1/3.
11:26:05 <Cale> cale.yi.org/autoshare/Cayenne.tar.gz
11:26:13 <hkBst> Cale: ah, it's failing to link with some Failed to load interface for `PTS':
11:26:29 <integral> After iterating over the whole array, you have a 1/N chance of the register containing any given element of the array.
11:26:29 <Cale> integral: that means you'll always choose the first element?
11:26:43 <integral> No, it doesn't Cale.  You're iterating over the array *updating* the register
11:26:47 <Cale> oh
11:26:55 <integral> So, yes, the first iteration always chooses the first element :-)
11:27:03 * integral wasn't clear enough
11:29:04 <Cale> ah, but that's just computing the length of the list anyway.
11:29:07 <hkBst> Cale: doesn't seem to be more in your tarball than those patches for {I,C}unit.hs ...
11:29:15 <Cale> hkBst: okay
11:29:23 <Cale> hkBst: Are you having any further problems?
11:29:43 <Cale> hkBst: That code will 'make all' for me.
11:29:51 <Cale> (and the resulting executable appears to work)
11:32:20 <hkBst> Cale: I'm trying to make an ebuild for it. It's doing http://rafb.net/p/RzYf1781.html Not sure if you're interested in that though :)
11:32:21 <lambdabot> Title: Nopaste - No description
11:32:55 <Cale> (so it always traverses the whole list)
11:32:56 <ricky_clarkson> integral: Thanks for that.
11:33:10 <ricky_clarkson> Cale: There's nothing wrong with traversing the whole list, once.
11:33:29 <integral> There's probably a funkier algorithm for haskell :-)
11:34:03 <ricky_clarkson> Also, integral's lets me make a lazy list from an existing list, a lazy list of randoms from the original list thus far.
11:34:12 <hkBst> Cale: anyway, I gotta get some food in me :)
11:34:23 <sethk> allbery_b, I found all the dependencies except for one, fps.  I don't see fps on hackage, is it elsewhere?
11:34:53 <Cale> Well, you're at least going to have to do as much work as computing length would. By computing length first, you do that work up front, and then you can terminate your second pass through the list early. By doing it integral's way, you're essentially combining those two passes into one. I'm not sure if it buys you anything in terms of cost.
11:35:22 <integral> Cale: memory usage if you can discard the elements of the list after computing them, I suppose
11:35:47 <shapr> Kattana: Are you the same Kattana from SST?
11:35:47 <integral> use up a lot of random numbers too.
11:35:59 <shapr> Ah, so you are!
11:36:02 * shapr hugs Kattana 
11:36:12 <Cale> SST?
11:36:14 <sethk> fps is fast packed strings, and if I'm not mistaken, the author is on the premises.
11:36:20 <shapr> Cale: Tremulous server.
11:36:30 <Kattana> yes
11:36:41 <shapr> Kattana: So what brings you to #haskell? Picking up the language?
11:36:53 <Kattana> not really, i lurk
11:37:04 <Kattana> here and #perl6
11:37:23 <shapr> Haskell is great fun :-) have you tried writing anything with it?
11:37:28 <Kattana> nope
11:37:33 <sethk> dons, if fps not in hackage?  I found it on your home page but not in hackage.
11:37:38 <Kattana> i just pretend one day i might
11:37:43 <shapr> Do you want to? I could point you out some helpful urls, and answer any questions.
11:37:50 * shapr ph33rs Kattana's mass driver.
11:38:06 <Kattana> lol, im just feared period
11:38:17 <dons> fps is called bytestring now, sethk.
11:38:17 <Kattana> anyway, nah, dont feel like moving anything im doing to a new language
11:38:46 <sethk> dons, ok.  The dependency checker in the regex package asks for FPS
11:38:52 <shapr> Kattana: I'd say that Haskell is worth learning whether or not you end up using it. It's a great way to stretch your brain, and what you learn applies to all your other programming.
11:38:59 <Kattana> yup
11:39:05 <dons> sethk, i think you must be using and old regex lib then?
11:39:10 <shapr> Anyway, if you have any questions, feel free to ask.
11:39:20 <Kattana> i do
11:39:22 <dons> sethk: with 6.8, i'm using  regex-base-0.72.0.1, regex-compat-0.71, regex-posix-0.72.0.2
11:39:26 <sethk> dons, possibly.  I got to it from hackage, but let me double check
11:39:31 <shapr> Kattana: You have questions? Oh I can answer!
11:39:40 <Kattana> no, i do feel free
11:39:42 <dons> sethk, look for one that depends on bytestring
11:39:43 <shapr> Oh, ok :-)
11:39:50 <Kattana> why so eager to please
11:40:18 <shapr> Because Haskell is the coolest programming language I've found yet, and I try to introduce it to other people so they too can experience the niftiness.
11:40:33 <shapr> I've tried several programming languages...
11:40:50 <Kattana> me too
11:41:01 <shapr> Of course, I also like Joy and PostScript, so I may have unusual tastes in programming languages.
11:41:18 <sethk> dons, you are correct.  I think I'm too dumb to use hackage.  :)
11:41:23 <b_jonas> postscript sucks
11:41:28 <Kattana> i find language to be irrelevant, i program through them, not in or with, so which it is doesnt matter =/
11:41:29 <shapr> b_jonas: I thikn it's fun!
11:41:29 <b_jonas> I tried it once
11:41:43 <b_jonas> here ---> http://www.math.bme.hu/~ambrus/pu/catalan.ps
11:41:44 <shapr> Kattana: I disagree. There's a huge difference between writing assembler and Haskell.
11:41:47 <shapr> Or even C and Haskell.
11:42:00 <b_jonas> after that, I decided I won't write postscript by hand anymore
11:42:06 <shapr> Kattana: I'd bet serious money that Haskell is safer/easier for writing sane code.
11:42:11 <Kattana> but you know how you can program fortran in anything? thats what i do with my own style
11:42:31 <b_jonas> Kattana: you program fortran in everything?
11:42:41 <Kattana> no, i program my way in anything
11:42:43 <shapr> Yeah, but different languages lend themselves to different styles. If you learn that style, you can then use it anywhere else.
11:42:54 <Kattana> but i dont so it doesnt matter
11:43:11 <shapr> b_jonas: That's really cool.
11:43:23 <b_jonas> shapr: have you looked at its source?
11:43:25 <shapr> Kattana: You don't what?
11:43:29 <shapr> b_jonas: yup, very cute.
11:43:33 <b_jonas> because that's what sucks, not the output
11:43:38 <Kattana> learn the style
11:43:54 <shapr> Kattana: What languages have you used the most?
11:44:02 <Kattana> i punch a hole through it and use my own style
11:44:09 <b_jonas> I don't like languages that force a style on me
11:44:27 <b_jonas> but I like ones that allow me to use my style combined with the style of the language
11:44:34 <b_jonas> that is, ones that add style, not take it away
11:44:36 <shapr> Kattana: I'd be interested in seeing any Haskell that you write.
11:45:04 <b_jonas> this means that I like "multi-paradigm" or TIMTOWTDI languages
11:45:20 <shapr> b_jonas: Do you think Haskell fits into multi-paradigm?
11:45:26 <b_jonas> though some languages that claim themselves as multi-paradigm aren't really
11:45:38 <b_jonas> shapr: I don't know yet, I haven't programmed much in haskell yet
11:45:52 <conal> interesting question.  what does "multi-paradigm" mean in a purely functional language?
11:46:03 <conal> are Bool & Int two different paradigms?
11:46:12 <b_jonas> the nice thing in haskell is the same as in perl: it has a large supporting community and lots of users
11:46:25 <Mr_Awesome> whoops
11:46:40 <byorgey> Mr_Awesome: what'd you do!?!
11:46:42 <b_jonas> few languages have so much libraries available as perl do
11:46:47 <Mr_Awesome> im sorry!
11:46:53 * Mr_Awesome hides in the corner
11:47:02 <shapr> Kattana: What languages do you write mostly?
11:47:06 <Kattana> ive used php the most, last job i had was pythong/javascript/custom
11:47:06 <b_jonas> (some others seem to be C, C++, and java)
11:47:14 <shapr> Ah, I see.
11:47:29 <shapr> It would be interesting see how you poke a hole in Haskell and write your own style.
11:47:34 <Kattana> I bet
11:47:34 <Cale> hehe :)
11:47:48 <Mr_Awesome> that just seems a bit counterintuitive
11:47:55 <Cale> All of those languages are kind of the same.
11:47:55 <byorgey> "interesting" isn't the word I would use =)
11:48:07 <Kattana> it seems like a hard language tho to poke holes in
11:48:11 <b_jonas> I think, if I ever had to program larger amount of postscript again, I wrote an interpreter or compiler from a saner language
11:48:14 <Cale> (PHP, Python, Javascript, C, etc.)
11:48:19 <b_jonas> I don't like managing stacks by hand
11:48:19 <vincenz> b_jonas: so you're the opposite form scheme?
11:48:21 <shapr> Kattana: Yeah, it could be.
11:48:37 <shapr> b_jonas: hah, smart.
11:48:38 <sethk> b_jonas, hire a slave
11:48:38 <b_jonas> vincenz: what do you mean?
11:48:45 <shapr> I actually do enjoy managing stacks by hand.
11:48:50 <vincenz> b_jonas: you add styles instead of taking away :)
11:48:55 <ricky_clarkson> Cale: The real reason is that I'm avoiding implementing a get by index on a stream type.
11:48:55 <Cale> Well, programming in an imperative style just involves using the IO (or other) monads.
11:48:57 <b_jonas> vincenz: yep :)
11:48:59 <Mr_Awesome> why would you stubbornly force the language to fit your style? adapt, and let the language influence your style in a symbiotic way
11:49:04 <b_jonas> I wrote a simple compiler once
11:49:09 <b_jonas> so I know I can do it
11:49:13 <shapr> b_jonas: Was it self hosting?
11:49:18 <b_jonas> shapr: no
11:49:20 <vincenz> shapr: like a web server?
11:49:23 <shapr> vincenz: hah
11:49:30 <Kattana> Mr_Awesome, my style is the one true style :P
11:49:32 <shapr> vincenz: By that definition, HAppS is self hosting.
11:49:37 <vincenz> shapr: hoisting :)
11:49:41 * shapr laughs
11:49:43 <Mr_Awesome> Kattana: ah, right ;)
11:49:48 <shapr> GHC is self hoisting!
11:49:55 * shapr does some lambda lifts
11:50:05 <Kattana> I do like the self hosting part
11:50:13 <Cale> Mr_Awesome: Sometimes that's disturbing though. I was disturbed by how poorly Common Lisp supported a functional style of programming.
11:50:13 <b_jonas> I mean, I think stack-based languages can be good as target code for compilers
11:50:21 <shapr> PHP isn't self hosting, and last I heard Python isn't yet self hosting.
11:50:29 <vincenz> hoisting!
11:50:35 <Kattana> yup
11:50:36 <Cale> (Especially as it's the main example most people cite of a functional language)
11:50:37 <b_jonas> (the java vm and lua works like that)
11:50:40 <vincenz> hence my comment about webservers
11:50:41 <Mr_Awesome> Cale: then dont use that language
11:50:44 <Kattana> perl6 will be self hosting
11:50:53 <shapr> Yup, perl6 is nifty stuff.
11:50:54 <b_jonas> (and I think you could compile lisp to a stack-based language too)
11:50:57 <Mr_Awesome> Cale: and i completely agree on that point. thats why i never use cl
11:50:59 <shapr> What's up in the perl6 world anyway?
11:51:08 <shapr> Has audreyt returned from her sabbatical?
11:51:23 <Kattana> dont think so, havnt seen any news
11:51:33 <sethk> what's the command to display what cabal knows about, and/or unhide a package?
11:51:52 <shapr> Where is audreyt these days? I missed a chance to pair program with her in Stockholm, and I want to do that at some point.
11:52:03 <Kattana> heres a question, hows the regex packages in haskell compared to pcre/perl
11:52:13 <Kattana> no idea
11:52:59 <Cale> Kattana: there's a pcre regex library
11:53:07 <b_jonas> shapr: ask on #perl6, they might know more
11:53:09 <shapr> I'd guess that regex support in Haskell has the same functionality as perl, but is possibly a bit slower than perl. Also, regexes aren't embedded directly into Haskell as they are in Perl5.
11:53:27 <Cale> Parsec is better than regular expressions.
11:53:31 * shapr agrees.
11:53:46 <Kattana> yeah dont need to be embedded, @cale does that just give a interface? is it missing some functionality
11:53:54 <shapr> Kattana: I'd suggest you try Parsec if you have the need to do parsing in Haskell. It's way more fun than regexes in my opinion.
11:54:11 <Kattana> meh~
11:54:25 <shapr> In fact, Parsec is often the first that gets people excited about Haskell.
11:54:43 <Kattana> but parsec is new, but im already a regex guru
11:54:59 <Cale> With Parsec, parsers are first class values which can be manipulated at runtime, and run on an input string to produce any kind of value.
11:55:17 <Mr_Awesome> Kattana: something you'll learn in time is that change is often good :)
11:55:20 <shapr> Yeah, regexes have certain limitations...
11:55:34 <Kattana> not if you program through them
11:55:45 <Cale> Regexes just match or don't match, which is sort of boring by comparison.
11:55:47 <shapr> I was frustrated when I discovered that backrefs only point to matches, not to the actual pattern itself.
11:56:19 <shapr> In Parsec you can point to the pattern.
11:56:28 <b_jonas> shapr: pcre and perl5.10re has the feature to point to a pattern
11:56:38 <shapr> Oh cool
11:56:47 <Cale> Oh, and bind things, but that's not as good as producing proper structures.
11:56:52 <shapr> That's a whole parser (and recipe for insanity) right there!
11:57:21 <Kattana> oh well, i will have to look at it, but theres so many things and so little time
11:57:28 * shapr agrees
11:57:32 <Cale> Kattana: A nice example is that a parsec parser can be written which parses the first part of its input as a description of a parser which it then parses the rest of its input with :)
11:57:33 <shapr> So much cool stuff, so little time.
11:57:47 <shapr> Cale: Could that be done with regexes as well?
11:57:49 <shapr> Sounds scary.
11:57:50 <Cale> no
11:58:13 <vincenz> Cale: imagine going one level further
11:58:16 <Cale> Regular expressions can only parse regular languages (well, not in perl, but that's only because they're not regexes)
11:58:30 <Cale> This is a context sensitive language.
11:58:38 <Kattana> cale, ive done that with regexes
11:58:39 <b_jonas> shapr: demerphq added that extension to the perl5 regex engine
11:58:43 <b_jonas> iirc
11:58:44 <Mr_Awesome> vincenz: you can always go one level further
11:58:51 <vincenz> Mr_Awesome: obviously
11:58:51 <_ry> i really need to execute some javascript from with-in haskell. any suggestions on how to achieve that? how hard is it to write a binding to spidermonkey, say?
11:58:54 <shapr> Until your BRAIN EXPLODES!
11:58:58 <vincenz> Mr_Awesome: but the implications are mind boggling
11:59:08 <shapr> _ry: Have you used the FFI in Haskell?
11:59:18 <Mr_Awesome> they usually are
11:59:23 <_ry> shapr: no - how hard is it?
11:59:27 <_ry> :)
11:59:30 <shapr> Very simple
11:59:31 <vincenz> Mr_Awesome: and I was trying to find out what the implications were in this case
11:59:36 <vincenz> so
11:59:39 <shapr> Haskell's FFI is really smooth.
11:59:42 <vincenz> Cale: imagine one level furthr
11:59:49 <Mr_Awesome> but is it really worth it? ;)
11:59:58 <shapr> I should start using words like furthr, since my name is shapr already.
12:00:00 <_ry> shapr: so writing bindings to C libraries is not impossible?
12:00:02 * shapr decides to do so.
12:00:05 <vincenz> Mr_Awesome: cn we know before first checking it?
12:00:08 <shapr> _ry: It's even fun.
12:00:17 <sethk> in ghc-pkg list, do I remember correctly that if the package name is in parentheses the package is hidden?
12:00:18 <shapr> hej bringrt!
12:00:23 <_ry> shapr: any suggestions for learning how to do that?
12:00:29 <Cale> vincenz: hehe
12:00:30 <Mr_Awesome> vincenz: not for sure, but you can guess
12:00:31 <dylan> shapr: you should sell a line of crappy products under the name "the shapr image"
12:00:36 <shapr> dylan: hahaha
12:00:52 <shapr> _ry: There used to be a bunch of simple tutorial on the old hawiki, maybe they were ported to the haskellwiki?
12:01:04 * shapr looks
12:01:16 <Cale> Kattana: also, parsec parsers are actually readable ;)
12:01:27 <Kattana> so are my regexes :P
12:01:36 <shapr> That's true. Have you seen that crazy multipage regex that checks for legal urls?
12:01:40 <Cale> Only if heavily commented.
12:01:46 <Kattana> ive written them :P
12:02:00 <Cale> I've written regexes which I later couldn't figure out.
12:02:02 * desegnis carefully nods in direction to sethk.
12:02:02 <Kattana> Ive written regexs that parse regexes too, now thats scary
12:02:17 <Taejo> shapr, I think it's email addresses... afair URLs are simpler
12:02:20 <b_jonas> shapr: it's started ages ago: http://www.perlmonks.com/?node_id=160771
12:02:25 <shapr> Taejo: oh right!
12:02:26 <lambdabot> Title: Recursive Regex: Update
12:02:29 <shapr> _ry: http://www.haskell.org/haskellwiki/FFI_Introduction
12:02:29 <lambdabot> Title: FFI Introduction - HaskellWiki
12:02:34 <sethk> desegnis, I'm building the regex package, and it complains that containers-0.1.0.0 is hidden, but it is normal in the list
12:02:35 <_ry> thanks!
12:02:41 <shapr> _ry: That should get you started. If you search for FFI on that wiki, you should turn up lots of stuff.
12:02:46 <Mr_Awesome> Kattana: well ive written regexes that parse regex parsing regexes
12:02:46 <shapr> _ry: Or search for 'foreign'
12:02:48 <Cale> Kattana: You can do that, but at least with regular expressions proper you can't then parse the rest of the input with the resulting regular expression.
12:02:53 <desegnis> sethk: Cabal procedure?
12:02:57 <vincenz> Mr_Awesome: I thought that was moot
12:03:00 <shapr> _ry: Or write a javascript interpreter ;-)
12:03:06 <shapr> Actually, didn't someone already write a js interpreter?
12:03:08 <sethk> desegnis, I'm trying ghc-pkg expose.  Is that the right thing to do?
12:03:09 <Cale> (because the language of strings which parse in that way isn't regular, or even context-free)
12:03:11 <Mr_Awesome> vincenz: i knew youd appreciate that comment
12:03:17 <shapr> For some reason I thought Dave Hermann had already done that.
12:03:26 <shapr> Herrman?
12:03:29 <_ry> shapr: i've asked before, but no one knew.
12:03:29 * shapr forgets
12:03:34 <shapr> @quote index
12:03:34 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
12:03:50 <Cale> (of course, you can easily do that with a second line of code, but that's another thing :)
12:04:05 <desegnis> sethk: Try adding containers to the packages list in the cabal file of the package. (This is upgrading stuff, I s'pose)
12:04:13 <shapr> _ry: I'm pretty sure someone has written a javascript interpreter in Haskell, but I don't remember who or where.
12:04:28 <shapr> _ry: But, you could ask the yhc guys, they compile Haskell to javascript, so they might know more.
12:04:29 <sethk> desegnis, I already tried downloading the source and installing it.  No complains, but regex still complains.
12:04:39 <Cale> One thing which I find strange is that regular expressions in Perl aren't really first class values, are they?
12:04:51 <shapr> You might also ask Dave Hermann. I think he's part of the ecmascript standards committee, and has interests in Haskell.
12:04:53 <Mr_Awesome> they are in ruby
12:05:15 <desegnis> sethk: I do not understand under what circumstances there are no vs. still complaints
12:05:26 <Kattana> so, any links to haskell regex and parsec?
12:05:31 <Cale> sure
12:05:35 <shapr> _ry: One nice trick is to ask google for "filetype:hs ecmascript" or "filetype:hs javascript" and try filetype:lhs as well.
12:06:20 <Cale> Well, there's Text.Regex.Base which comes with GHC
12:06:24 <sethk> desegnis, ok.  I'm installing the regex package.  It asked for a few other packages, and I installed them and it's fine.  Now, the runghc Setup.hs configure does not complain, but the runghc Setup.hs build has a compilation error, Data.Sequence not found, and then the following line says containers-0.1.0.0 is hidden
12:06:29 <shapr> Kattana: I learned Parsec from http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
12:06:36 <Cale> and then a bunch of packages which reimplement/extend that
12:06:42 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-pcre-0.93
12:06:43 <lambdabot> http://tinyurl.com/3dzlpl
12:06:45 <ski> @where parsec
12:06:45 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
12:06:45 <Cale> (for example that one)
12:07:11 <sethk> desegnis, specifically,      Could not find module `Data.Sequence':
12:07:11 <sethk>       it is a member of package containers-0.1.0.0, which is hidden
12:07:17 <desegnis> sethk: Did you try editing the .cabal file, and re-running configure/build?
12:07:30 <shapr> Yeah, and hope someone does an NMU
12:07:35 <sethk> desegnis, no, what would I be changing in .cabal?
12:07:47 <Saizan> sethk: that .cabal file is not updated for 6.8.1 it seems, you need to add containers to build-depends
12:07:58 <desegnis> sethk, there is a field called build-depends
12:08:01 <Kattana> k, ill look at those some other time, playing a game on the other screen <_<
12:08:10 <Cale> Kattana: one neat thing is that the regex matching operator =~ is heavily overloaded, so it can produce a large number of different kinds of results depending on what you want the match to do
12:08:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base-0.72.0.1/Text-Regex-Base-Context.html
12:08:14 <lambdabot> http://tinyurl.com/2swohu
12:08:39 <sethk> Saizan, desegnis ah, I see, the runghc Setup.hs configure command needs to identify all libraries used, and at some time in the past this wasn't separated so it didn't have a dependency for it?
12:08:54 <Saizan> exaclty
12:08:55 <Kattana> thats good
12:09:09 <Cale> and it looks like shapr already gav the appropriate link to the parsec docs.
12:09:16 <Saizan> before 6.8 Data.Sequence was in base
12:09:22 <Kattana> yup, got those
12:09:40 <Cale> You'll find parsec at Text.ParserCombinators.Parsec
12:09:47 <Cale> (should come with GHC as well)
12:10:23 <Cale> That's the main difference between the current version and that documentation.
12:10:48 <Kattana> k
12:11:29 <Cale> One really nice thing about Parsec is that you can get really good parsing error messages with little effort.
12:11:36 <phao> using haskell can I do some style of programming like this one: make smaller programs (using haskell) which outputs lines of charactes, then make one program (for user interface) then this interface program calling the other programs, taking their output, formating it, passing to other program as input, etc.
12:11:41 <phao> ?
12:11:50 <Cale> phao: yes
12:12:07 <Cale> phao: we even have an operator symbol which expresses that idea (.)
12:12:27 <sethk> Saizan, desegnis, I get the same problem with Data.ByteString, so I add bytestring to the depends line also?
12:12:59 <Cale> Also, 'interact' will take a String -> String function, and turn it into a complete program which reads from stdin and writes to stdout.
12:13:04 <Cale> :t interact
12:13:06 <lambdabot> (String -> String) -> IO ()
12:13:08 <desegnis> sethk, well see if it does the trick...
12:13:25 <phao> hmm ok
12:13:38 <roconnor> does the adjoint for complex vectors have anything to do with the catagorical notion of adjoint?
12:13:41 <Cale> interact (unlines . map f . lines) will take a function which will be applied to each line of the input and apply it to get the output
12:13:54 <Cale> (that is, you just have to define f
12:13:55 <Cale> )
12:14:00 <phao> works like pipes in shellscript?
12:14:08 <sethk> desegnis, it did.  Now Data.Array, in array-0.1.0.0.  I'll just add each one as it comes up, now that I'm an expert in the procedure  :)
12:14:23 <Cale> Well, if f and g are functions, then (f . g) x = f (g x)
12:14:38 <Japsu> Though (.) operates in the opposite direction as | in shell
12:14:39 <roconnor> @unpl (.)
12:14:39 <lambdabot> (\ a b c -> a (b c))
12:14:43 <Cale> That is, (f . g) is the function which first applies g, then applies f to the result
12:14:56 <phao> ah ok
12:15:09 <Japsu> There's also (>>>) (in Control.Arrow) that's for simple functions the same as (.) but with the arguments reversed
12:15:20 <Japsu> that is, f >>> g = f (g x)
12:15:28 <Japsu> oops,
12:15:28 <Cale> no, the other way
12:15:37 <sethk> desegnis, I get a bunch of "orphan instances" warnings.  Do I ignore them?
12:15:39 <Japsu> that is, (f >>> g) x = g (f x)
12:15:57 <Cale> Curiously enough, the order in which function composition is written is the real evaluation order in Haskell.
12:16:14 <Cale> That is if you have (f . g) applied to something, it's f which is applied first.
12:16:18 <Japsu> The wonders of lazy evaluation. :P
12:16:22 <Cale> right
12:16:30 <Cale> f is applied to (g x)
12:16:39 <desegnis> sethk, you would have to ask the library designer. Those are warnings about the specific code. Ah right, ignore them.
12:17:01 <Cale> which you can think of as simply substituting (g x) for the parameter of f in its body.
12:17:08 <roconnor> ah, the complex matrix adjoin is an adjoint with respect to the inner product.
12:17:12 <Cale> (though it's a little more than that, because of sharing0
12:17:14 <Cale> )
12:18:25 <desegnis> sethk, btw, I've got the faint impression that orphan instances warnings are allowed to appear in quality code sometimes.
12:18:33 <sethk> do I want regex-posix, or one of the others (regex-parsec I'd say no, but I don't know what regex-dfa, regex-pcre, and regex-tre refer to)
12:19:11 <sethk> posix, I guess, is a sensible choice.
12:19:28 <ricky_clarkson> @babel ha en * -> *
12:19:28 <lambdabot> Plugin `babel' failed with: Error: Language ha not supported
12:19:31 <Cale> > let g = (1:) . g in g []
12:19:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:19:49 <Cale> (as that code proves :)
12:21:23 <Cale> (1:) is the function which prepends 1 to any list it's given
12:21:30 <Cale> > (1:) [2,3,4,5]
12:21:36 <lambdabot>  [1,2,3,4,5]
12:22:55 <dnox> > (1:) [0,2,3,4,5]
12:23:00 <lambdabot>  [1,0,2,3,4,5]
12:24:02 <Cale> > let g = g . (1:) in g []
12:24:09 <lambdabot> Terminated
12:24:58 <dnox> > 1: [0,2,3,4,5]
12:24:58 <lambdabot>  [1,0,2,3,4,5]
12:24:58 <Cale> So you can see that it's really the first function in the composition which is evaluated first. In this case, that results in an infinite loop of expanding g
12:25:12 <roconnor> apparently mathematicians like the inner product to be linear in the first argument instead and physicists want linearity in the second argument.
12:25:20 <Cale> roconnor: right
12:25:26 <b_jonas> roconnor: yep
12:25:28 <roconnor> I must admit I like the physicists' notation.
12:25:30 <b_jonas> it's like the i/j thingy
12:25:48 <Cale> Also, most mathematicians I know really hate 'ln'
12:26:11 <Cale> (Except if they're French or something)
12:26:12 <roconnor> if you are going to use column vector notation
12:26:22 <roconnor> it seems to make sense to but the vectors on the right
12:26:25 <dnox> whats wrong with ln?
12:26:42 <Cale> dnox: log is the natural logarithm
12:26:49 <vincenz> Cale: log is base 10
12:26:54 <Cale> No it's not.
12:26:57 <vincenz> and 'n' is not natural :)
12:27:03 <vincenz> it's nepasomething
12:27:04 <dnox> Cale: and ln is=?
12:27:04 <Cale> Nobody cares about the base 10 logarithm.
12:27:12 <vincenz> Cale: all people in signal processing do
12:27:14 <Cale> dnox: A misspelling :)
12:27:32 <vincenz> > log 2 / log 10
12:27:33 <lambdabot>  0.30102999566398114
12:27:36 <_ry> log is definitely base e
12:27:39 <vincenz> very famous number :)
12:27:49 <Cale> vincenz: Only because of anachronistic definitions.
12:27:52 * roconnor tries to use ln.
12:28:09 <sethk> desegnis, now I get an error because there is no Text.Regex.Base.hi.  Looking, that's true, I have Regex/Base/RegexLike.hi, and in the same directory Context.hi.  the whatever.cabal file lists four exposed modules:  Text.Regex.Base, Text.Regex.Base.RegexLike, Text.Regex.Base.Context, and Text.Regex.Base.Impl.  Only two out of four have .hi files
12:28:12 <dnox> Cale: nope, its not like abbreviations for stuff is globably defined for everything in math
12:28:13 * roconnor and lg for logBase 2
12:28:18 <Cale> vincenz: and mathematicians aren't in signal processing either :)
12:28:39 <dnox> Cale: people use different notation for stuff all the time
12:28:39 <vincenz> Cale: remind me what the 'n' stands for?
12:28:46 <Cale> dnox: I know, of course.
12:28:50 <roconnor> Cale: did I ever ask you about arctanh vs artanh?
12:29:11 <vincenz> neparian?
12:29:12 <Cale> vincenz: Naturalis?
12:29:27 <b_jonas> Cale: that depends on the country
12:29:29 <Cale> vincenz: Not Napierian, that's a completely different function.
12:29:33 <b_jonas> here many people like ln
12:29:42 <sethk> desegnis, There is an Impl.hs, but no Impl.hi.  There is nothing like Base.hs, but I don't know whether there should be
12:29:50 <Cale> b_jonas: yeah, in parts of Europe it's popular.
12:29:55 <vincenz> Cale: no, neparian or something like that
12:30:10 <Cale> vincenz: The Napierian log is something else.
12:30:15 <vincenz> oh
12:30:47 <vincenz> Cale: then I was wrongly taught in school
12:31:03 <Cale> NapLog(x) = log(10^7/x) / log(10^7/(10^7 - 1))
12:31:16 <Cale> Where that log is whatever base you'd like.
12:31:24 <desegnis> sethk: Are you installing (or do you have) regex-base? I suppose you need that.
12:31:31 <Cale> (doesn't matter as long as they're both the same)
12:31:53 <sethk> desegnis, I'm trying to install regex-base
12:31:58 <desegnis> oh
12:32:05 <Cale> vincenz: ln stands for Logarithmus Naturalis
12:32:12 <sethk> desegnis, but I was wrong on one thing, there is a file Base.hs
12:32:13 <vincenz> Cale: alright
12:32:27 <vincenz> Cale: in lower school or middle school I was taught it was napierian :|
12:32:33 <vincenz> perhaps my math teacher confounded the two
12:32:40 <Cale> vincenz: That's a common confusion.
12:32:42 <sethk> desegnis, also the other missing one, impl.hs.  I guess I have a build problem
12:33:48 <desegnis> Setup.hs clean; Setup.hs configure; Setup.hs build; ?
12:34:08 <ski> b_jonas : i've been taught `ln'
12:34:22 <ski> (b_jonas : and `log' could mean any one)
12:34:32 <sethk> desegnis, yes, but I repeated it, and I noticed that "module Text.Regex.Base.Context exports nothing", this is during the compile of base.hs
12:35:02 <b_jonas> ski: exactly
12:35:16 <b_jonas> log can mean either log_10 or log_e or log_2 depending on the context
12:35:18 <sethk> desegnis, possibly that is screwing up the build in some one, so it doesn't think it needs base.hs?
12:35:30 <desegnis> sethk, no idea really
12:35:45 <b_jonas> log_10 on calculators, log_e in half on maths, log_2 in the other half
12:35:56 <b_jonas> and sometimes it's irrelevant, either e or 2 works
12:35:57 <sethk> desegnis, this seems to be a specific situation for this package.  I've installed four others today without any issues.
12:36:00 <ddvlad> > toIntegral 2.5
12:36:01 <lambdabot>   Not in scope: `toIntegral'
12:36:20 <ski> (b_jonas : or any other base)
12:36:38 <b_jonas> ski: at least any base greater than 1, yes
12:37:23 <ddvlad> how do I get the integral part of a double?
12:37:24 <sethk> desegnis, I wonder if I need to build Text.Regex.Posix and then come back to base.
12:37:35 <sethk> desegnis, counterintuitive, but looking at the code, not necessarily impossible.
12:38:17 <desegnis> sethk, you write all that as if you were suspecting I knew something :)
12:38:19 <sethk> desegnis, nice thought, but it's not backwards, base is just broken.
12:38:27 <sethk> desegnis, well, you know something about cabal, clearly
12:39:13 <desegnis> But not, I'm afraid, about Text.Regex.
12:39:55 <byorgey> ddvlad: how about floor?
12:40:06 <ddvlad> > floor 3.5
12:40:21 <lambdabot>  thread killed
12:40:32 <byorgey> why does that keep happening to \bot?
12:40:37 <byorgey> > floor 3.5
12:40:37 <lambdabot>  3
12:40:44 <byorgey> > floor (-3.5)
12:40:45 <lambdabot>  -4
12:40:49 <byorgey> > truncate (-3.5)
12:40:49 <lambdabot>  -3
12:40:53 <byorgey> > truncate (3.5)
12:40:54 <lambdabot>  3
12:40:54 <Porges> > properFraction 3.5
12:40:54 <lambdabot>  (3,0.5)
12:41:04 <ddvlad> byorgey: obviously lack of experience... thank you
12:41:18 <byorgey> ddvlad: hehe, no, it happens to me too =)
12:41:26 <Porges> ddvlad: I'd use > fst . properFraction
12:42:05 <b_jonas> isn't truncate the same as that?
12:42:23 <b_jonas> @t properFraction
12:42:24 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:42:27 <ddvlad> Porges: why is that better than floor?
12:42:27 <b_jonas> @type properFraction
12:42:28 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
12:42:44 <Porges> b_jonas: it seems so, now that I look
12:42:54 <Porges> " The default definitions of the ceiling, floor, truncate  and round functions are in terms of properFraction. "
12:43:10 <b_jonas> btw, is there a floor/ceil/round/trunc provided that returns the same kind of float, not an integer?
12:43:35 <b_jonas> that is, in haskell
12:43:49 <mux> I guess realToFrac . floor/round/ceiling
12:44:14 <b_jonas> mux: yes, but I suspect that's inefficent
12:44:14 <ricky_clarkson> @hoogle [a] -> Integer -> Boolean
12:44:15 <lambdabot> No matches, try a more general search
12:44:28 <b_jonas> because floor/... apparently converts to (big) Integer first
12:44:34 <mux> b_jonas: maybe yeah, I don't know of such a function by itself though
12:45:15 <b_jonas> mux: maybe I should read on the foreign interface, because this one is surely very easy to write
12:46:01 <Cale> vincenz: Heh, apparently even Wikipedia was making that mistake by redirecting Napierian logarithm to the page for the natural one. I've fixed that :)
12:46:42 <b_jonas> but that's almost the same, isn't it?
12:46:49 <Cale> No, it's very different.
12:47:01 <Porges> ddvlad: it's equivalent to truncate... use truncate ;p
12:47:06 <b_jonas> hmm
12:47:08 <roconnor> b_jonas: for portability I recommend realToFrac . floor plus a rewrite rule to your FFI code.
12:47:19 <Cale> b_jonas: er, if you were referring to me :)
12:47:20 <ddvlad> Porges: thanks
12:47:35 <b_jonas> Cale: yes, I was
12:47:37 <Cale> http://en.wikipedia.org/wiki/Napierian_logarithm
12:47:45 <Cale> Check out my new stub :)
12:48:13 <vincenz> cale is like the massive wiki-haskell-inkscape-gnome
12:48:21 <vincenz> he just swoops in and adds information
12:48:27 <b_jonas> I see
12:48:34 <Cale> heh
12:48:38 <byorgey> Cale: weird.  so the Napierian log of x *decreases* until x gets to 10^7, then starts increasing again?
12:48:44 <vincenz> He did the same in the LazyBottoms team
12:48:48 <b_jonas> I thought it was just a base 10^(-n) log for some n
12:48:48 <byorgey> that seems... not so useful
12:49:07 <vincenz> byorgey: eh?
12:49:11 <Cale> No, it just decreases.
12:49:12 <vincenz> byorgey: no it just has a negative slope
12:49:39 <desegnis> Cale, out of curiosity: It is not a logarithm to any particular base in the modern sense of the term - why?
12:49:43 <Cale> It's a constant added to the negative of the logarithm to a particular base, as that second formula shows.
12:50:06 <desegnis> oh, right
12:50:22 <desegnis> x in the denominator above, silly me
12:51:38 <Cale> vincenz: You can see an example of all that at once in the Wikipedia article for folds :)
12:51:50 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
12:51:50 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
12:52:09 <Cale> It has Wikipedia, Haskell and Inkscape all at once :)
12:53:37 <desegnis> Btw, speaking of log@Wikipedia, don't we usually restrict the base b of a logarithm to b > 0; b /= 1 (instead of b /= 0, b /= 1)?
12:56:31 <sethk> desegnis, fixed it
12:56:51 <sethk> desegnis, I had to remove -Werror from the GHC options in regex-base.cabal
12:58:12 <desegnis> hm
12:58:15 <Toxaris> > logBase (-3) 42 :: Complex Double
12:58:17 <lambdabot>  0.3707154779528343 :+ 1.0600983023051633
12:58:46 <desegnis> Toxaris, ah, I'm always thinking in real numbers.
12:58:47 <roconnor> > pi/2
12:58:48 <lambdabot>  1.5707963267948966
12:59:51 <hpaste>  Punya pasted "Small HOpenGL program" at http://hpaste.org/4147
13:03:34 <kyevan> Hmm, Java.
13:03:45 <sioraiocht> done anyon ehere have mad regexp skills?
13:04:32 <Olathe> /yes/
13:05:04 <kyevan> Is it odd that I wind up writing most of my Java (Which I need to be using for reasons other than liking it) in such a way that (if you assume the object is being passed to its methods as self, I guess) that it's very nearly purely functional? >_>
13:05:37 <sethk> back later
13:06:19 <Porges> lexical error at character '\65279'
13:06:28 <Porges> my favourite error >:|
13:06:36 <mauke> U+FEFF (0xef 0xbb 0xbf): ZERO WIDTH NO-BREAK SPACE []
13:06:43 <vincenz> @join #oasis
13:07:13 <Toxaris> kyevan: "they" call it the "immutable object pattern" and believe it to be a feature of modern object oriented design
13:08:35 <ricky_clarkson> kyevan: Have you written lazy lists yet?
13:08:50 <vincenz> @remember kittens
13:08:50 <lambdabot> Incorrect arguments to quote
13:08:56 <vincenz> @quote kittens
13:08:56 <lambdabot> rici says: "i.e. if someone offers you kittens for dinner, you can practice not being offended."
13:08:58 <kyevan> No, but I haven't really had reason to.
13:09:53 <ricky_clarkson> Do you find yourself using Iterable a lot/
13:09:54 <ricky_clarkson> ?
13:10:46 <hpaste>  Heffalump pasted "Problem with two-way fundep" at http://hpaste.org/4148
13:11:00 <kyevan> ricky_clarkson: Only when required by some interface I'm implimenting.
13:12:04 <Heffalump> I have a two way fundep between the two parameters a and b of a typeclass Dep a b, and I want to convert b1 to b2 given Dep a b1, Dep a b2  - the fundep implies that b1 = b2, but how do I convince the typechecker of this?
13:12:43 <roconnor> @seen cdsmithus
13:12:43 <lambdabot> cdsmithus is in #haskell. I don't know when cdsmithus last spoke.
13:13:02 <kyevan> Mrrr....
13:13:23 <kyevan> I wish there was a more C-like language with things like Haskell's typing.
13:13:32 <kyevan> But that would be silly, really.
13:13:47 <Taejo> kyevan: Haskell in the IO monad?
13:14:05 <kyevan> Taejo: Well
13:14:05 <Toxaris> is it time for   instance Monad C where ... ?
13:14:33 <kyevan> I need to teach this to people who think Java is too un-C-like for 'real' programmers
13:15:04 <Taejo> lol
13:15:46 <Heffalump> augustss has a blog post or two about embedding C-like syntax in Haskell
13:16:40 <Taejo> ah yes, I was trying to remember who it was
13:17:52 <hpaste>  Punya annotated "Small HOpenGL program" with "(no title)" at http://hpaste.org/4147#a1
13:17:59 <Cale> Java is too un-C-like?
13:18:16 <Toxaris> conv :: (Dep a b1, Dep a b2) => a -> b -> b -- Heffalump
13:18:16 <Toxaris> conv = const id
13:18:43 <Toxaris> Heffalump: give the typechecker a dummy 'a'
13:18:51 <Toxaris> hmm nonsense
13:18:58 <roconnor> I don't understand cdsmith's type system problem :(
13:19:15 * Toxaris decides to double-check for typos from now :(
13:19:36 <Heffalump> I fixed the type sig and it still doesn't work
13:19:53 <Heffalump> oh, I see, your type sig would typecheck but not do what I wanted, right
13:25:52 <kyevan> Cale: It lacks pointers, was one thing they cited.
13:26:01 <Cale> kyevan: It has references.
13:26:10 <Cale> kyevan: Just not pointer arithmetic.
13:26:11 <kyevan> You can't do math with them!
13:26:22 <Cale> Why would you need to?
13:26:27 <mauke> actually, you can
13:26:27 <kyevan> Cale: No idea >_>
13:26:32 <mauke> just not with the same syntax
13:26:46 <mauke> all you need is an array wrapper
13:26:49 <kyevan> mauke: Not without horribly breaking the Java model.
13:27:27 <kyevan> (and possibly the JRE)
13:27:40 <mauke> Ptr p = new Ptr(someArray); p = p.plus(1); // points to someArray[1]
13:28:10 <kyevan> Eh, true.
13:28:13 <kyevan> But anyway :P
13:28:30 <kyevan> I only have to deal with this about once a month. And no more after this year!
13:28:56 <kyevan> Probably, anyway
13:30:43 <cdsmithus> roconner: anything in particular you don't understand, or just the whole thing?
13:39:34 <hpaste>  Saizan annotated "Problem with two-way fundep" with "for Heffalump" at http://hpaste.org/4148#a1
13:39:58 <Heffalump> Saizan: cool, thanks
13:40:35 * Heffalump realises that an instance is necessary to actually prove it works, and goes to try
13:41:21 <Heffalump> it doesn't :-(
13:41:43 <Heffalump> all you've done is move the problem
13:42:49 <roconnor> cdsmithus: I left some comments about my (@@)  I wonder if it would solve your problems.
13:43:06 <roconnor> cdsmithus: because I haven't found a need for your functions in my application.
13:45:00 <cdsmithus> roconnor: Thanks.  I have to admit I'm not particularly looking at any applications here.  Just poking around.  I hadn't seen automatic differentiation until a couple days ago.
13:46:04 <roconnor> cdsmithus: oh.  Why do you think your functions are usefull?
13:46:52 <cdsmithus> roconnor: I don't.  I think they are interesting.  Maybe they are useful.
13:47:49 <roconnor> http://www.haskell.org/haskellwiki/Functional_differentiation#Blog_Posts
13:47:50 <lambdabot> Title: Functional differentiation - HaskellWiki, http://tinyurl.com/36257e
13:48:22 <roconnor> cdsmithus: you should add your post to the list
13:48:31 <cdsmithus> Will do
13:50:20 <cdsmithus> Still trying to read some of the other stuff you linked to.
14:03:43 <BMeph> @remember kittens "If someone offers you a kitten, make kittenade."
14:03:43 <lambdabot> Okay.
14:04:16 <vincenz> @quote kittens
14:04:16 <lambdabot> kittens says: "If someone offers you a kitten, make kittenade."
14:04:18 <vincenz> @quote kittens
14:04:18 <lambdabot> kittens says: "If someone offers you a kitten, make kittenade."
14:04:22 <vincenz> @quote rici
14:04:22 <lambdabot> rici says: "i.e. if someone offers you kittens for dinner, you can practice not being offended."
14:16:34 <davidL> I have a data field that needs to hold two bytes of data which is coming in as [Word8], should I combine the two bytes to create a Word16 or just leave it as [Word8]?
14:18:39 <Olathe> Which will be easier to work with ?
14:18:49 <mwc> davidL, depends what you'd rather work with, two word8s or one word16
14:19:06 <mwc> it'll be a pain to keep masking out half the word16, and then sticking it bac
14:20:13 <davidL> well according to the IEEE people the field should be a number from 0 to 65535
14:20:43 <Olathe> Oh, so you want to work with the field's value ?
14:22:08 <davidL> I'm making a library to deconstruct a network packet, so eventually I'll use the value
14:22:52 <davidL> actually, Word16 would be a lot easier to work with now that I think about it
14:23:17 <Olathe> > let { f::Word8->Word8->Word16; f a b = (fromIntegral a)*256 + fromIntegral b } in f 255 255
14:23:18 <lambdabot>  65535
14:23:41 <davidL> hmm, this is what I had
14:23:59 <davidL> let w8Combine x y = shiftL (fromIntegral x) 8 .|. (fromIntegral y) in w8combine 255 255
14:24:08 <davidL> > let w8Combine x y = shiftL (fromIntegral x) 8 .|. (fromIntegral y) in w8Combine 255 255
14:24:12 <lambdabot>  Add a type signature
14:24:16 <Olathe> Yeah, that's not so bad.
14:24:48 <Olathe> > let { w8Combine :: Word8 -> Word8 -> Word16; w8Combine x y = shiftL (fromIntegral x) 8 .|. (fromIntegral y) } in w8Combine 255 255
14:24:50 <lambdabot>  65535
14:25:03 <Olathe> Probably a bit faster, too.
14:25:40 <davidL> I'll do that, thanks
14:27:10 <Olathe> > let { w16Split :: Word16 -> (Word8, Word8); w16Split x = (fromIntegral $ shiftR x 8, fromIntegral$ x .&. 255) } in w8Split 65535
14:27:12 <lambdabot>   Not in scope: `w8Split'
14:27:23 <Olathe> > let { w16Split :: Word16 -> (Word8, Word8); w16Split x = (fromIntegral $ shiftR x 8, fromIntegral$ x .&. 255) } in w16Split 65535
14:27:24 <lambdabot>  (255,255)
14:27:45 <hpaste>  lienmeister pasted "Guttman-Rosler Transform sort" at http://hpaste.org/4149
14:27:54 <davidL> ah Yes, I also need to create a w8split :)
14:28:38 <Olathe> > let { test :: Word16 -> Word8; test x = fromIntegral x } in test 65535
14:28:38 <lambdabot>  255
14:28:40 <Olathe> Ahh.
14:28:49 <Olathe> > let { w16Split :: Word16 -> (Word8, Word8); w16Split x = (fromIntegral $ shiftR x 8, fromIntegral x) } in w16Split 65535
14:28:50 <lambdabot>  (255,255)
14:29:05 <Olathe> > let { test :: Word16 -> Word8; test x = fromIntegral x } in test 65530
14:29:05 <lambdabot>  250
14:30:07 <davidL> > let { w8split :: Word8 -> (Word8, Word8); w8split x = (fromIntegral & shiftR x 4, fromIntegral $ x .&. 15) } in w8split
14:30:21 <davidL> > let { w8split :: Word8 -> (Word8, Word8); w8split x = (fromIntegral & shiftR x 4, fromIntegral $ x .&. 15) } in w8split 32
14:30:22 <lambdabot>   Not in scope: `&'
14:30:22 <lambdabot>   Not in scope: `&'
14:30:30 <davidL> gah
14:30:48 <Olathe> No fromIntegral needed, since your types are the same.
14:31:03 <davidL> oh
14:31:17 <davidL> > let { w8split :: Word8 -> (Word8, Word8); w8split x = (shiftR x 4, x .&. 15) } in w8split 32
14:31:18 <lambdabot>  (2,0)
14:31:46 <davidL> why isn't there a Word4?
14:32:02 <Olathe> Words haven't been that small since the seventies.
14:32:27 <davidL> > bitSize (42::Word)
14:32:40 <lambdabot>  32
14:32:40 <Olathe> It wouldn't be so hard to implement it, though, I think.
14:33:24 <davidL> is it worth it, to save 8 bits?
14:33:35 <Olathe> Nope.
14:33:37 <ari> :t bitSize
14:33:37 <lambdabot> forall a. (Bits a) => a -> Int
14:33:42 <Olathe> It will almost definitely slow things down.
14:33:51 <davidL> really, why?
14:34:56 <Olathe> Word alignment and so on.
14:35:32 <Olathe> If you tightly pack the data, it has to shift and and it all the time to read it properly.
14:35:40 <Olathe> Reading it is similarly ugly.
14:35:44 <Olathe> Writing, I mean.
14:35:49 <davidL> ah ok
14:36:02 <quicksilver> actually sometimes you can generate rather clever code for that kind of thing
14:36:03 <Olathe> You want the data unpacked, as long as it doesn't exceed the cache or RAM size.
14:36:05 <quicksilver> but ghc can't :)
14:36:35 <Olathe> If you can get it to fit in the cache by packing it, that can actually improve performance.
14:36:53 <Olathe> But if it already fits anyway, it will slow it down.
14:37:46 <davidL> also, is there a way to limit the size of a list in a type synonym? or should I just use a tuple: type MacAddress = (Word8, Word8, Word8, Word8, Word8, Word8)
14:38:59 <Olathe> If it's a MAC address, use a tuple or a word that holds 48 bits.
14:39:45 <davidL> like Word64? (that's the only one I know >=48)
14:40:05 <Olathe> What's the primary use for the MAC address ?
14:40:13 <Olathe> Are you printing it to the screen or a file ?
14:40:36 <davidL> yes
14:40:46 <Olathe> Ahh, I'd go with a tuple then.
14:41:08 <davidL> thanks
14:41:13 <Olathe> No problem.
14:42:32 <quicksilver> davidL: I'd make a new type not a synonym personally
14:42:49 <quicksilver> davidL: data MacAddress = MacAddress Word8 Word8 Word8 Word8 Word8 Word8
14:43:11 <davidL> quicksilver: what is the difference?
14:44:08 <davidL> ah that makes more sense actually
14:44:21 <quicksilver> davidL: not much. But creating a new type can give better error messages in some cases.
14:44:33 <quicksilver> it's not as if there are loads of library functions operating on 6-tuples you want to use.
14:44:55 <quicksilver> also, you can give it strictness annotations should you ever care.
14:45:32 <davidL> I'll keep that in consideration, thank you
14:47:07 <Olathe> quicksilver: That's cool :)
14:47:29 <Olathe> I should learn how to create types one day.
14:47:59 <davidL> yes this is my first time doing this sort of thing
14:50:16 <davidL> I wonder if doing `type W = Word8' and using W instead of Word8 all over the place would be confusing
14:52:15 <ptolomy> Hmm.. I think it'd be awesome if there were a wiki article to help imperative programmers re-calibrate their brains. Sort of a 'where you would've done this... do this!".. then give some nice annotations for why. I think a common stall point is "Wait, how the hell do I create a <object oriented thing>?", and the answer is "You don't. In Haskell, you'd do..".
14:52:20 <ptolomy> Also, I would find such a thing interesting.
14:53:04 * ptolomy should get an account on the wiki.
14:57:16 <ddarius> ptolomy: There are several attempts at just that.  However, often things don't map one-to-one.  The entire approach would be different rather than just a technique.  There may be multiple or no techniques that map to an OO one and there may be no techniques that map to what you "would actually" do in Haskell.
14:57:35 <ptolomy> ddarius: Yeah, I can see how that would be.
14:58:11 <ptolomy> I'd also be interested by a section (if none such exists) that discusses applications in which Haskell may not be currently the best choice.. a "we're working on it". :-P
15:01:08 <ddarius> ptolomy: Other than perhaps library issues, only soft/hard-realtime constraints make Haskell a shaky choice, but that is true for most garbage collected languages.
15:01:08 <gwern> how do you add multiple type-class constraints?  I have 'withOpen :: (HVFSOpenEncap b), (HVIO a) => ( a -> b) -> b' which I thought would work but doesn't seem to
15:01:11 <ptolomy> I suppose such a section would be rather impossible to do practically.
15:01:32 <ddarius> (C1 a, C2 b) =>
15:01:37 <ddarius> :t fromIntegral
15:01:39 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:01:55 <gwern> ah. inside a single parentheses, I see
15:02:27 <conal> i think C1 a => C2 b => ... may work.  saw something in a darcs log.
15:02:42 <conal> curried constraints make so much sense to me
15:03:06 <conal> simpler to include than exclude, i bet
15:03:12 <ddarius> :t let f :: Num a => Show a => a -> a; f x = x+x in f
15:03:12 <lambdabot> parse error on input `=>'
15:03:24 <conal> ddarius: very recent
15:03:27 <ptolomy> ddarius: I'd disagree, but it ends up being a matter of taste. There isn't really anything that haskell _can't_ do, but there is stuff that it isn't the easiest choice if you're equally familiar with another language. For example, if I were writing something that had lots of similar data types that share interfaces and implementations and are clearly heirarchical, haskell would probably...
15:03:28 <ptolomy> ...work, but an object-oriented language with inheritance would be easier for me.
15:04:05 <gwern> conal: no, it doesn't seem to work here: 'src/System/IO/HVFS.hs:103:38: parse error on input `=>'
15:04:16 <ddarius> ptolomy: But that's "for you".  I can't write a list of things where Haskell would be a better language for you.
15:04:33 <conal> gwern: version?
15:04:56 <gwern> conal: 'The Glorious Glasgow Haskell Compilation System, version 6.8.1.20071117
15:05:16 <ddarius> Also, usually the problem doesn't specify "use lots of similar data types that share interfaces and implementation in a heirarchical manner".  As before, perhaps there is a dramatically different approach to the same problem.
15:05:24 <ptolomy> ddarius: Right. It ends up being a matter of taste. But, for the record, I'm still on the lookout for the right way to model implementation inheritance over a large set of data types that vary sightly.
15:05:24 <conal> gwern: perhaps 6.9
15:05:45 <conal> i've been meaning to ask for that grammatical simplification/generalization for a while, and then i saw a darcs log
15:05:51 <ddarius> ptolomy: Model it the same way OO implementations do.
15:05:56 <conal> could be i misunderstood
15:06:26 <ddarius> @version
15:06:26 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
15:06:26 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:06:46 <ptolomy> ddarius: Doing it manually ends up being pretty ugly.. it seems more reasonable to use a language that better maps to the task.
15:06:56 <rumbleca> anybody try using ghci 6.8.1 on freebsd6 amd64(x86_64)?
15:07:04 <rumbleca> getting a core dump
15:07:31 <ddarius> ptolomy: Hopefully an OO language will do OO better than a functional one, but again it's doubtful that the -task- requires it.
15:07:43 <gwern> bleh. is 'withOpen :: forall b. HVFSOpenEncap -> (forall a. HVIO a => a -> b) -> b' translateable to 'withOpen :: (HVIO a) => (a -> b) -> (HVFSOpenEncap b)'?
15:07:53 <ddarius> Also, in my experience, many FP programmers are rather against OO style implementation inheritance.
15:08:28 <davidL> I thought the gcc on freebsd broke ghc 6.8.1 but maybe that's freebsd 7
15:08:29 <ptolomy> ddarius: I think you may be right.. which is why I keep secretly planning to do a server app that I don't usually think haskell maps well to in haskell.
15:08:38 <ddarius> gwern: Yes, they should be equivalent.
15:09:07 <ddarius> Actually, I take that back.
15:09:10 <rumbleca> davidL: sounds like a 7 issue, I'm using gcc 3.4.6 here...
15:09:19 <rumbleca> davidL: but it could be...
15:09:21 <ptolomy> ddarius: (For the record, a simple stock exchange. Lots of similar objects, lots of sharing, threads, a need for global logging, etc)
15:09:35 <olsner> @where lambdacats
15:09:35 <lambdabot> http://arcanux.org/lambdacats.html
15:09:48 <Olathe> @where omg
15:09:48 <lambdabot> I know nothing about omg.
15:10:02 <ddarius> ptolomy: (For the record, I'd probably take an "Erlang-style" approach for that.)
15:10:03 <Olathe> @where ?where
15:10:03 <lambdabot> ?where ?where
15:10:58 <nburlett> join #macports
15:11:00 <ptolomy> ddarius: yeah, I probably will for the main components. An "Actor" for each connection and each major data storage components, each of which will probably have some basic IO task.
15:11:00 <nburlett> grr
15:13:42 <gwern> (dammit missingh)
15:13:59 <Olathe> Dammit, Miss Singh ?
15:14:13 <gwern> all my build problems for libraries seem to boil down to either cabal problems or fancy type problems. it's very frsutrating! the first are easily fixed, but the latter...
15:15:26 <ddarius> gwern: Unless you are making changes you shouldn't have any type problems at all for building a library.
15:15:41 <rumbleca> where are the platform specific constants saved, in the src tree?
15:15:45 <gwern> ddarius: and yet...
15:19:00 <BMeph> Has anyone built Hoogle in 6.8.1?
15:40:23 <ptolomy> ddarius: Delayed-action follow-up: Do you know (or could you point me to an article that explains) why many FP folks oppose implementation inheritance?
15:41:30 <mar77a> @src abs
15:41:31 <lambdabot> Source not found.
15:41:34 <mar77a> rrr
15:42:38 <ddarius> ptolomy: Probably not readily, but let me try.
15:42:59 <ptolomy> ddarius: Thanks. :)
15:44:53 <ddarius> ptolomy: I'd have to read this thread again, but it and the linked one probably have a few points: http://lambda-the-ultimate.org/node/2103
15:44:54 <lambdabot> Title: Implementation Inheritance | Lambda the Ultimate
15:46:32 * ptolomy reads.
15:48:51 <mar77a> what was that function to get a list out of a list of lists
15:48:58 <Saizan> so, CPS tranforming a monad gives you right association of actions, is there a similar technique to make them left associate instead?
15:49:04 <Saizan> mar77a: concat?
15:49:06 <dolio> @type concat
15:49:06 <lambdabot> forall a. [[a]] -> [a]
15:49:13 <mar77a> thanks
15:49:51 <mar77a> and the main thingy
15:50:06 <mar77a> main=do something something
15:50:28 <augustss> mar77a: join works too
15:50:28 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
15:51:13 <LoganCapaldo> Saizan: I dunno if there is but whatever it is it needs to be called co-continuation passing style
15:51:20 <LoganCapaldo> ;)
15:51:25 <mauke> you mean ntinuation passing style
15:51:34 <Saizan> :D
15:51:40 <LoganCapaldo> mauke: blast! I just thought of that joke
15:52:01 <mauke> A COMATHEMATICIAN IS A DEVICE FOR TURNING THEOREMS INTO FFEE
15:52:16 <LoganCapaldo> lol
15:52:19 <ddarius> @quote comathematician
15:52:19 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
15:52:30 <dolio> Cotheorems?
15:52:35 <mar77a> @quote php
15:52:35 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
15:52:45 <mauke> dolio: now that's just silly
15:52:46 <mar77a> @quote c++
15:52:46 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
15:52:56 <mar77a> haha
15:52:59 <Pseudonym> I know the answer to qwe1234's quandry.
15:53:02 <Pseudonym> List is useful.
15:53:05 <Pseudonym> Lisp
15:53:09 <Pseudonym> That matters.
15:53:15 <mauke> @quote c\+\+
15:53:15 <lambdabot> fnord123 says: Haskell mainly helps with my C++ template coding when I'm doing money oriented programming
15:53:30 <LoganCapaldo> mmm money-oriened programming
15:53:37 <dolio> Lots of people seem to thin PHP is useful.
15:53:43 <dolio> Think, even.
15:53:56 <mar77a> i used to :)
15:54:04 <Pseudonym> I did once.
15:54:14 <mar77a> PHP is a good starters language maybe
15:54:19 * ddarius never did.
15:54:19 <Pseudonym> Once upon a time, it was an excellent replacement for SSI.
15:54:24 <mar77a> from the coder's carpe diem point of view
15:54:32 <mar77a> but i think on the long run...not cool
15:54:48 <davidL> I have this datatype: data MacAddress = MacAddress Word8 Word8 Word8 Word8 Word8 Word8, is there an easy way to construct it from a [Word8] (length 6)?
15:54:52 <dolio> It probably is useful, in fact. I just hate it. :)
15:55:19 <ddarius> fromList [a,b,c,d,e,f,g,h] = MacAddress a b c d e f g h
15:55:25 <augustss> Pseudonym: does qwe1234 have a quandry?
15:55:26 <ddarius> Oops.
15:55:32 <ddarius> -g and h
15:55:46 <davidL> @type fromList
15:55:46 <lambdabot> Not in scope: `fromList'
15:55:56 <Saizan> yup, PHP was a nice templating language, now you've template libs for PHP..
15:55:57 <ddarius> davidL: That was a function definition.
15:55:57 <mar77a> @type map
15:55:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:56:02 * LoganCapaldo wants to say foldr1 MacAddress 
15:56:10 <karmazilla> do you guys have any pointers to info/tutorials on how to use parsec for parsing indented languages?
15:56:12 * LoganCapaldo but knows it won't type check
15:56:39 <ddarius> karmazilla: I believe there is a wiki page or something on it, but I'd have to look to findi t.
15:56:42 <augustss> karmazilla: you mean like Haskell?
15:56:48 <davidL> I see, thanks ddarius
15:57:19 <ddarius> davidL: Also you probably want those Word8 fields strict (and unpacked)
15:57:19 <karmazilla> augustss: yes, and python and the sorts
15:57:50 <davidL> ddarius: is there something I can read on how to do that?
15:57:51 <augustss> karmazilla: I'll probably have it in a blog post soonish, but it's easy
15:58:28 <augustss> karmazilla: The basic idea is that you put the column number in each token, and when you know a new indented block begins you transform the token stream
15:58:40 <ddarius> davidL: All you have to do is add ! before each Word8, 'MacAddress !Word8 !Word8 ...' which will make them strict then (with GHC) if you add the flag -funbox-strict-fields they will be unboxed as well.
15:59:31 <augustss> karmazilla: now if you want to parse exactly Haskell it's very, very difficult.
15:59:31 <davidL> ddarius: should I add -funbox-strict-fields as a pragma or deal with that later in cabal?
15:59:32 <karmazilla> augustss: oh? whats the url to your blog so I can snatch your rss feed?
15:59:49 <augustss> karmazilla: augustss.blogspot.com
15:59:54 <ddarius> davidL: Whichever you prefer.
16:00:07 <davidL> thanks ddarius
16:00:57 <karmazilla> augustss: I don't want to parse haskell code... rather I've been toying with the idea of a lispy language that allows you to subtitude parenthises with layout
16:01:35 <augustss> karmazilla: with sensible indentation rules it's easy
16:02:28 <gwern> there are even scheme proposals with working code, iirc. I remember hearing some implementations have that as an option
16:03:18 <karmazilla> augustss: yes, that's what I thougt... and it would probably be dead easy to buld dsl's with such a language
16:03:42 <augustss> could be
16:05:23 <rumbleca> your lispy program could get a lot of verital height without parens
16:06:06 <karmazilla> parens would be optional, rather than prohibited
16:07:09 <ddarius> @users
16:07:09 <lambdabot> Maximum users seen in #haskell: 420, currently: 406 (96.7%), active: 14 (3.4%)
16:09:07 <ricky_clarkson> Bah, clearly we just need to delimit our code with whitespace.
16:09:21 <Heffalump> is there any documentation beyond the GHC user manual about when GHC uses improvement on class contexts?
16:10:07 <ricky_clarkson> Lisp's (+ (* 3 6) (/ 3 2) 4) becomes +  * 3 6  / 3 2  4, where the smaller the number of spaces the tighter the binding.
16:10:38 <ddarius> Heffalump: The source code?
16:10:49 <ddarius> More seriously, maybe the Commentary?
16:11:02 <sorear> I suggest interrogating simon
16:11:06 <karmazilla> ricky_clarkson: that's a thougt but code would easily become hard to read, I think :)
16:11:25 <ricky_clarkson> Sorry, I forgot the smiley. ;)
16:11:46 <karmazilla> smilies implied ;)
16:12:51 <Heffalump> the trouble is that the round-trip time of interrogating Simon means I'll probably have found a different solution to my problem in the meantime.
16:13:13 * Heffalump --> try the commentary
16:14:15 <Heffalump> (no joy)
16:14:55 <ddarius> It was a long shot.
16:15:19 <Heffalump> yeah
16:15:44 <Heffalump> It's really annoying, cos I have a type error "could not deduce foo from bar", when I'm sure that if it applied improvement to bar it would be able to do it.
16:17:19 <hpaste>  (anonymous) annotated "Automata evaluation function" with "(no title)" at http://hpaste.org/4150#a1
16:20:49 <sw17ch> Is it terribly difficult to link C or C++ against haskell?
16:21:01 <mauke> no
16:21:46 <sw17ch> Cool. thanks
16:25:57 <rabbit64> Hi. How do I tell hugs to match this?: data Dat = A | B | C, func :: Dat -> Bool  func (A or? B) = true func C = false . The point is how to tell haskells pattern matcher to determine if matched value is "something" or "something else", reference it @, ? Do you understand me? is it possible? how?
16:26:54 <LoganCapaldo> I seem to have come up a function for which the type can be inferred but I'm not allowed to write the annotation w/o an extension
16:27:31 <LoganCapaldo> Is this a "bug"?
16:27:46 <TSC> rabbit64: I don't think that's possible
16:27:59 <LoganCapaldo> @type let counting f a = tell (Sum 1) >> (return (f a)) in counting
16:28:01 <lambdabot> forall t t1 b (m :: * -> *). (Num t, MonadWriter (Sum t) m) => (t1 -> b) -> t1 -> m b
16:28:03 <ddarius> LoganCapaldo: I don't believe so, but you can ask on the ghc list or haskell-cafe.
16:28:04 <lament> func C = false
16:28:07 <lament> func _ = true
16:28:09 <TSC> You'd normally use separate matching rules
16:28:30 <ddarius> (Of course, in that case you need extensions anyway)
16:28:49 <Heffalump> I've encountered situations like that quite frequently.
16:28:50 <LoganCapaldo> I do?
16:29:02 <ddarius> MonadWriter is a multiparameter type class.
16:29:02 <LoganCapaldo> I'm not using -fglasgow-exts or -XAnything
16:29:11 <rabbit64> TSC, of course, but what if my function is more complex,,, func Dat -> Dat -> Dat -> Bool ; func (A or B) (B or C) = true...how to cope with this?
16:29:20 <Heffalump> LoganCapaldo: but you're using a library that does
16:29:30 <LoganCapaldo> right
16:29:31 <LoganCapaldo> doh
16:29:50 <TSC> rabbit64: You might have to use a case expression or two
16:29:59 <lament> rabbit64: at that point you should probably just switch to if statements / case expressions
16:30:02 <Heffalump> I'm fairly sure I've encountered situations where my code was entirely within some language and a type signature would have required going outside that language.
16:30:18 <Heffalump> (where language = H98 + some stuff)
16:30:47 <LoganCapaldo> I mean I put "bug" in quotes because it just seems "icky" to me
16:31:10 <gwern> lovely. so it was an extension problem.
16:31:13 <LoganCapaldo> I wonder if I turn on warnings it'll warn me
16:31:22 <gwern> is there a list anywhere of just what fglasow-exts is equivalent to?
16:32:30 <rabbit64> I'm doing this, because I want to analyze some arithmetic expressions...data Expr = Primitive1 | Primitive2 | Func Expr Expr....so in func3 I have three parameters and I want to determine If the second and the third parameter is a Primitive [1 or 2], ?if not let the pattern matching continue?
16:33:53 <LoganCapaldo> I guess this is a "problem" inherent w/ being able to flips bits of the language on and off
16:34:02 <rabbit64> or w8 it would be possible to use if, i'm stupid it's midnight..sry
16:34:04 <LoganCapaldo> ah well
16:36:08 <LoganCapaldo> so in H98 tell :: (Monoid w) => w -> Writer w () (or maybe Writer isn't part of H98?)
16:38:54 <Saizan> LoganCapaldo: writer is.
16:40:34 <rabbit64> \o/ it works :D
16:52:00 <mar77a> so...guards are kind of like switch statements, right?
16:52:14 <sorear> yes.
16:52:26 <LoganCapaldo> erm.
16:52:27 <sorear> more like if/elsif/elsif/else chains though.
16:52:37 <LoganCapaldo> cases are ind of like switch statements
16:53:03 <LoganCapaldo> guards are kind of like case foo: if( guard_condition ) break;
16:56:34 <gwern> ok... wtf? if I add -fglasgow-exts to the compile options for missingh, HVFS compiles. if I add in as an extenion *every* extensions listed in http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.2.2.0/Language-Haskell-Extension.html - it doesn't compile! what the heck
16:56:35 <lambdabot> http://tinyurl.com/394gu7
16:57:35 <rabbit64> If my data type is deriving Show, how (where?) to write my own function Show :: Expr -> String (or io or what?),
16:57:44 <conal> gwern: what's the error message?
16:57:46 <sorear> gwern: not all GHC extensions are listed there
16:59:05 <gwern> sorear: doesn't it sort of defeat the point if extensions: can't list all used extensions?
16:59:32 <hpaste>  gwern pasted "missingh" at http://hpaste.org/4152
16:59:36 <sorear> gwern: no.
16:59:44 <gwern> conal: see hpaste
17:00:26 <sorear> gwern: extensions: is for extensions supported by multiple compilers, so as to not require all of ghc-options:, hugs-options:, nhc-options:, etc to be set
17:00:29 <gwern> sorear: I don't see what purpose it serves then if not as a finer0grained replacement to specifying -fglasow-exts as an option
17:00:35 <hpaste>  Porges pasted "LZW compression" at http://hpaste.org/4153
17:01:08 <sorear> gwern: for intrinsically unportable programs, there is no need to use extensions: - and all unsupported extensions are GHC only
17:01:28 <sorear> gwern: note that this is a Bug in cabal.  try upgrading
17:02:00 <gwern> sorear: what is this? the HVFS error or limited extension selection?
17:02:12 <gwern> (and I installed cabal from darcs like two hours ago)
17:03:19 <sorear> gwern: try using Rank2Types
17:03:22 <dons> so anyone played with `par` yet? :)
17:03:44 <chessguy> dons, did you see the blog that was ranting against your 2 parallelism blogs today?
17:03:52 <sorear> the people with multicore systems are still an insignificant minority, I'd say
17:03:52 <dons> yeah :)
17:03:59 <sorear> I for one don't have one
17:04:06 <dons> everyone fixates on the fibonacci.
17:04:07 <sjanssen> sorear: oh, I don't think so
17:04:07 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
17:04:13 * gwern has a new 4-core :)
17:04:18 <sjanssen> sorear: every new system bought in the last year or so is at least dual core
17:04:21 <dons> the lesson next time is to use some obscure algorithm that doesn't have tricky solutions
17:04:25 <dons> so people can concentrate on the detail
17:04:36 <gwern> sorear: removing the -fglasgow-exts and replacing with Rank2Types doesn't work. I already tried that, I said
17:04:41 <sorear> sjanssen: why a) buys new computers regularly b) is smart enough to use haskell?
17:04:52 <gwern> one by one, and in aggregate all of those listed in the doc page...
17:04:54 <sorear> *who
17:04:57 <dons> sorear: yeah, most new laptops have 2 cores, so that's a lot of people.
17:04:58 <chessguy> i have to admit, i didn't understand the numbers either
17:05:04 <dons> chessguy: oh?
17:05:16 <chessguy> as he pointed out
17:05:20 <sorear> gwern: I'd recommend ignoring that doc page.
17:05:25 <dons> chessguy: what do you mean?
17:05:39 <chessguy> ermm, i'd have to look at the post again
17:05:47 <dons> one thing we could do is ask why the `par` sparked version is so much slower -- get SimonM to reduce the cost of registering sparks
17:05:50 <sjanssen> sorear: I think most people buy new computers on a semi-regular basis
17:06:02 <dons> since people likely expect a `par` to be a null op on -N1
17:06:11 <gwern> it isn't?
17:06:21 <sorear> gwern: try http://darcs.haskell.org/ghc/compiler/main/DynFlags.hs
17:06:32 <dons> nope. we saw, 72s, 47s, 28s, 22s for N 1.. 4 , iirc
17:06:32 <Porges> If I define a new operator simply as another operator, does that operator inherit the same precedence?
17:06:39 <dons> while the nonthreaded rts was 39s
17:06:46 <sjanssen> Porges: no
17:07:17 <Porges> Where can I find a list of operator precedence levels - H98 definition?
17:07:19 <chessguy> Unfortunately, the naive attempt to parallelize is actually slower than the original serial version. But if you:
17:07:19 <chessguy>    1. implement the algorithm twice,
17:07:19 <chessguy>    2. add a magic number apparently pulled out of someones nether regions, and
17:07:19 <chessguy>    3. add not just some compile flags, but some runtime flags too,
17:07:19 <chessguy> then you can get a whopping 5% speed improvement with 2 cores, and almost a factor of two speedup with 4 cores, meanwhile burning about twice as many total CPU cycles!
17:07:33 <gwern> UnicodeSyntax sounds interesting
17:07:49 <dons> chessguy: it depends on what you're comparing as the base line
17:08:00 <dons> i guess he's using the unthreaded version, against the parallel one.
17:08:04 <dons> > 37 / 39
17:08:06 <sorear> dons: even if it WAS a null op, it still defeats other optimizations, since in order to effectively parallelize you have to weaken the strictness analyser
17:08:14 <dons> yep. that's a good point, sorear
17:08:14 <lambdabot>  0.9487179487179487
17:08:43 <mar77a> does haskell have any use for a function that returns nothing?
17:08:59 <andyjgill> literally, no.
17:09:04 <mar77a> > foo (Num a) => a -> ()
17:09:04 <lambdabot>  Parse error at "=>" (column 13)
17:09:12 <chessguy> dons, just using the numbers from your post:
17:09:19 <mar77a> er
17:09:21 <andyjgill> Unless, you need to do evaluation.
17:09:22 <chessguy> ./naive  39.03s user 0.00s system 99% cpu 39.108 total
17:09:28 <mar77a> > foo (Num a) a => a -> ()
17:09:28 <lambdabot>  Parse error at "=>" (column 15)
17:09:31 <dons> chessguy: sure, that's right. what's your concern?
17:09:34 <chessguy>  ./np +RTS -N2  138.69s user 1.18s system 190% cpu 72.48 total
17:09:35 <mar77a> oh right
17:09:41 <mar77a> > foo :: (Num a) => a -> ()
17:09:42 <lambdabot>   Not in scope: `foo'
17:09:45 <chessguy> the last number is the amount of time, right?
17:10:01 <sjanssen> chessguy: are you using the cutoff version?
17:10:07 <dons> ./real-par +RTS -N2  71.98s user 0.49s system 191% cpu 37.866 total
17:10:12 <andyjgill>  mar77a: hyperStrict :: a -> ()
17:10:21 <mar77a> what about it andyjgill
17:10:28 <chessguy> sjanssen, i'm pulling the numbers directly off of http://cgi.cse.unsw.edu.au/~dons/blog
17:10:29 <lambdabot> Title: Haskell hacking
17:10:36 <dons> chessguy: you're reading the wrong entry
17:10:42 <dons> that's the 'naive parallel' version
17:10:51 <dons> which is explained, and then improved upon, about 1 paragraph down
17:11:11 <andyjgill> You can cause evaluation, but basically for most programs, you always return a value, not ()
17:11:38 <chessguy> but you say "we're not making much progress" when in fact it looks like it's actually worse than the un-parallelized version
17:12:02 <Porges> gwern: http://hpaste.org/4154
17:12:03 * sorear is going to do the pthreads thing today
17:12:07 <dons> right. we're not making progress.
17:12:16 <dons> though at least it was getting faster as N grew
17:12:16 <Porges> unfortunately, hpaste exploded
17:12:27 <chessguy> > 22.059 / 39.018
17:12:28 <lambdabot>  0.5653544517914809
17:12:44 <sjanssen> sorear: yeah, it would be interesting to see the par combinator implemented in C
17:12:52 <mar77a> where does Char come from
17:12:55 <mar77a> :t Char
17:12:56 <lambdabot> Not in scope: data constructor `Char'
17:13:01 <chessguy> and in the end you improved it by 56% while quadrupling the number of cores? is that expected?
17:13:12 <sorear> mar77a: Char isn't a value, :t won't work on it
17:13:16 <dons> i didn't know what to expect: i've not used `par` before, chessguy :)
17:13:24 <dons> what was unexpected was the slowdown due to `par`
17:13:25 <chessguy> sure
17:13:31 <dons> but at least we were able to recover it
17:13:33 <sorear> the problem is that 35 is too high :)
17:13:33 <chessguy> i'm just saying, it did seem a little od
17:13:34 <chessguy> d
17:13:36 <sorear> *low
17:13:50 <mar77a> in any case i mean, like, Int derives (right term?) from Num...where does Char come from?
17:13:51 <dons> chessguy: but do you understand the result?
17:14:04 <chessguy> somewhat
17:14:05 <andyjgill> dons; http://www.semdesigns.com/Products/Parlanse/examples.html
17:14:05 <lambdabot> Title: Semantic Designs, Inc: Sample PARLANSE Programs
17:14:07 <TSC> mar77a: Int is an instance of Num, you mean
17:14:08 <gwern> Porges: unfortunately my font doesn't seem to show those
17:14:15 <mar77a> ok, an instance
17:14:23 <mar77a> Char is an instance of..?
17:14:25 <hpaste>  Porges annotated "Unicode Fun" with "commenting out everything is ok; hpaste's colourizer needs fixing" at http://hpaste.org/4154#a1
17:14:31 <chessguy> i'm not flaming you like him, but it did strike me as odd too
17:14:32 <andyjgill> These are a couple of programs that we could write in Haskell, and use multicore
17:14:39 <davidL> @docs Char
17:14:39 <lambdabot> Char not available
17:14:41 <dons> oh, nice andyjgill
17:14:46 <Porges> gwern: try now?
17:14:47 <davidL> @docs Data.Char
17:14:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
17:14:54 <jonathanturner> dons: yeah, I think you're right about not using fib next time - my cousin took one look at your blog and wrote the C++ equivalent of memoized version and said "mine doesn't take any time at all"
17:14:56 <dons> chessguy: right. costs and benefits.
17:15:00 <chessguy> while acknowleding that you've got more haskell and programming knowledge in your little toe than i will ever have :)
17:15:01 <sjanssen> sorear: yeah, I had a version that adapts the cutoff according to the number of cores, I should get dons to run that on the 4 core box
17:15:20 <dons> jonathanturner: yeah, everyone knows how to right a fast fibonacci, so they went off and did that instead of thinking about `par`
17:15:35 <dons> so we need something instead where there is no clever solution, and the only way forward is to parallelise
17:15:41 <gwern> Porges: that works. looks quite nice. tough typing though.
17:15:46 <TSC> mar77a: http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Char.html#t%3AChar
17:15:46 <dons> andyjgill: that's a good lib of code to start with
17:15:47 <lambdabot> http://tinyurl.com/37buku
17:15:52 <jonathanturner> dons: no doubt - I think a good look at how to annotate and when to annotate would be very illuminating
17:15:55 <davidL> dons: @docs doesn't return correct URLs
17:15:55 * gwern thinks I'll stick with my emacs pretty lambda formatter
17:16:00 <andyjgill> The pi example is an nice one
17:16:10 <chessguy> anyway, back to my logic textbook
17:16:24 <dons> the problem with any kind of performance thing is that people will try to write in in C++ no matter what :)
17:16:31 <chessguy> or C
17:16:36 <LoganCapaldo> of course no one payed att. to thing. they stll had the ruby smokes python blog for the context of yours dons.
17:16:45 <LoganCapaldo> *to the par thing
17:16:50 <dons> i can only hope that `par` is somehow stuck in the back of their heads though
17:16:51 <chessguy> we should call it C{,++}
17:16:55 <dons> for next time they have 4 cores sitting idle
17:17:52 <dons> and its not bad to position haskell as obviously faster than ruby/python. its a long way from the view of the lang 7 years ago
17:18:11 <dons> and as competitive with C. the `message' that will get remembered is probably fine
17:18:11 <faxathisia> hi
17:18:25 <faxathisia> dons :D
17:18:35 <dons> hey faxathisia
17:18:36 <faxathisia> this made me laugh "I'd had too much coffee"
17:18:45 <faxathisia> in your post
17:19:17 <dons> :)
17:21:38 <faxathisia> > length $ show $ (let fibs = 1:1:(zipWith (+) fibs (tail fibs)) in fibs !! 200)
17:21:40 <lambdabot>  42
17:22:36 <falbani> hi
17:22:39 <dons> so perhaps not as much light was shone on `par` as could have been done. but likely more readers read about haskell and par as a result.
17:22:46 <dons> the internets are funny like that
17:22:54 <falbani> I have a question about how Haskell output strings
17:23:09 <dons> falbani: ask away!
17:23:56 <davidL> does `par` work on amd64?
17:24:05 <dons> sure.
17:24:09 <falbani> I have to output a list of X,Y points for some math app...
17:24:19 * davidL tests
17:24:33 <dons> as long as you've got a new ghc, and the threaded runtime
17:24:41 <dons> the smp stuff is builtin
17:24:55 <dons> your OS scheduler will matter
17:25:00 <mrd> i found the NDP combinator i was looking for :)  updateU
17:25:16 <dons> mrd, so you're using the strict, unboxed ndp arrays?
17:25:19 <dons> from the darcs repo?
17:25:21 <mrd> yep
17:25:24 <mrd> UArrs
17:25:26 <dons> or even the parallel ones?
17:25:29 <falbani> I wrote this function:        t2s    (x, y)  = show x ++ ", " ++ show y
17:25:30 <dons> ok. good.
17:25:38 <mrd> and :*:s
17:25:49 <mrd> i wrote a parallel bellman ford that seems to work
17:25:53 <Informatica> About Holy Gay Nigger Seed (HGNS):
17:25:53 <Informatica> The Holy Gay Nigger Seed (HGNS) is the pure semen collected from a 2 year old gay nigger baby using a special technique called "masturbation". It is a Gay Nigger rituale performed on all Gay Nigger born children by their fathers. The HGNS is then saved for generations to come and is the most valuable commodity in the Federation of Gay Planets.
17:25:56 <dons> mrd, yep. how's it working ?they should be rather good as far as an array lib goes.
17:25:59 --- mode: ChanServ set +o dons
17:26:00 --- mode: dons set +b *!*n=Torres@*.160.163.127.cable.dyn.cableonline.com.mx
17:26:01 --- kick: Informatica was kicked by dons (dons)
17:26:03 <falbani> But the output is "braced" with double quotes
17:26:05 --- mode: ChanServ set -o dons
17:26:16 <mrd> they were quite speedy when i did the matrix multiplication, very nice surprise
17:26:20 <TSC> How are you doing the output?
17:26:22 <mrd> even serially
17:26:31 <sjanssen> falbani: you want to use putStr rather than print
17:26:32 <dons> mrd, they're very similar to bytestrings underneath
17:26:33 <TSC> If you're using "print", use "putStrLn" instead
17:26:40 <mrd> is it using vectorized machine instructions?
17:26:41 <falbani> TSC: with putStrLn
17:26:45 <dons> mrd, but this is great to see. i wonder, should we start recommending UArrs ?
17:26:55 <dons> mrd, and how are you using them in parallel?
17:26:55 <sorear> If I run +RTS -N4 on my one-core system and divide by 4, will I get correct results?  (longshot I know, but it *could* work)
17:27:34 <falbani> sjanssen: I'm using putStrLn... but before I use "show"
17:27:36 <mrd> for the matrix mult i actually just did a list of UArrs for each matrix.  one was in row-major the other in column major order.  then it's just a simple dotP going down the lists
17:27:43 <dons> cool
17:27:46 <sjanssen> falbani: ah, you need to avoid show
17:27:52 <dons> mrd, so is this just an experiment, or for some research ?
17:28:00 <falbani> sjanssen: any idea how?
17:28:07 <gwern> (looks like informatic was going on about GNAA> haven't seen GNAA trolls in a long time)
17:28:07 <sjanssen> falbani: eg. if you've got putStrLn (show line), use putStrLn line
17:28:09 <mrd> for BMF I'm working with an edge-list representation and basically just relaxing edges in paralle, in rounds
17:28:21 <LoganCapaldo> > show "a"
17:28:23 <gwern> w00t! MissingH finally compiled!
17:28:36 <lambdabot>  thread killed
17:28:38 <mrd> both, i guess.  i have a class project which i am writing in haskell
17:28:40 <puusorsa> if i use hdbc and fastcgi with multiple threads, get a db connection in main, and pass that as argument, is that safe?
17:28:50 <LoganCapaldo> > [show "a", "a"]
17:28:50 <lambdabot>  ["\"a\"","a"]
17:29:02 <LoganCapaldo> ^ falboni
17:29:07 <dons> puusorsa: it depends on if the db is thread safe, I think
17:29:11 <dons> i presume it is?
17:29:13 <mrd> they've given us an 8 CPU machine to play with
17:29:17 <gwern> had to totally revamp the .cabal, add -fglasgow-exts, change the Setup.hs, install an old QuickCheck and specify versions... but it finally seems to compile!
17:29:18 <dons> mrd, awesome
17:29:28 <gwern> (yeesh)
17:29:38 <puusorsa> postgres
17:29:44 <davidL> awesome post dons
17:29:55 <puusorsa> but is using the connection from different threads safe?
17:30:00 <sjanssen> gwern: be sure to send patches to CosmicRay
17:30:03 <dons> davidL: yay :)
17:30:04 <mrd> i'll post this bmf code when i clean it up a bit
17:30:09 <dons> mrd, that would be great.
17:30:15 <dons> we need to get more people using the UArr stuff
17:30:38 <puusorsa> didn't get any errors when testing this, but then started thinking maybe it blows up when not expected
17:30:38 <sjanssen> so is ndp actually ready to use with GHC 6.8?
17:30:48 <dons> the flat, strict arrays should be
17:31:08 <gwern> sjanssen: who's that? goerzen?
17:31:13 <sjanssen> gwern: yeah
17:31:31 <dons> davidL: what did you find interesting about it?
17:31:35 <dons> i'm trying to gather some feedback.
17:31:37 <gwern> (now to go wrestle with HSH)
17:31:59 <falbani> sjanssen, dons, LoganCapaldo: Double Quotes are gone! Thanks people!
17:32:17 <chessguy> slightly off topic, but anybody read this? http://homepages.nyu.edu/~ts65/lfp/lfp.pdf
17:32:50 <mrd> i'm not sure i'm getting much parallelism out of it though, they're fast, but the other threads don't seem to be doing much work
17:33:11 <davidL> dons: "./par-c  32.91s user 0.00s system 99% cpu 32.960 total" :)
17:33:31 <mrd> i'm supplying -N 4 and setGang 4
17:33:32 <dons> oh good. i found that quite exciting too :)
17:34:12 <dons> mrd, seems about right
17:34:16 <gwern> now that's strange. why do both base and missingh provide 'Data.String'?
17:34:34 <dons> oh, why are you using MissingH
17:34:44 <dons> its probably out of date now -- after the big missingh break up
17:34:49 <gwern> dons: a dependency for HSH
17:34:57 <dons> hmm
17:35:02 <dons> then it likely requires 6.6.1
17:35:05 <dons> or older
17:35:12 <dons> hence all the build failures you're working through
17:35:28 * gwern doesn't feel like downgrading, and these failures need to be addressed by someone sooner or later
17:36:06 <sjanssen> gwern: missingh shouldn't use the Data.String name, IMO
17:36:41 <mrd> UArrs are strict of course right?
17:36:43 <gwern> yeah, I'm moving it
17:37:13 <mrd> and UArrs of :*: types should still work ok?
17:37:23 <dons> mrd, yeah. i think so
17:37:34 <gwern> are names like 'Data.MissingH-String' allowed?
17:38:31 <sjanssen> gwern: no, alphanumeric and . only
17:39:14 <gwern> (that explains the error)
17:42:45 <hpaste>  Porges pasted "Is there a better way to do this?" at http://hpaste.org/4155
17:45:20 <dmwit> Porges: I don't really know of a better way.
17:45:44 <dmwit> Eventually, you have to tell the compiler what you mean, and this is a pretty minimalistic way to do it.
17:46:37 <Porges> mkay
17:46:49 <Porges> just seemed like something that might have been already invented
17:47:48 <dmwit> Mmmm, a Container class (with instances for [], Map, Set, and so forth) is a pretty nice idea.
17:47:58 <dmwit> If you get something fairly complete, you should consider sharing it. =)
17:48:17 <sjanssen> Porges, dmwit: see Edison and the collections library
17:49:32 <mrd> well i'm going to eat some more while i sort this out.  the code is here http://sequence.complete.org/node/371.  there's a minor bug, but it shouldn't affect parallelism.
17:49:33 <lambdabot> Title: NDP Bellman-Ford | The Haskell Sequence
17:49:54 <dmwit> sjanssen: Oh, that looks nice, thanks for the tip.
17:49:59 <chessguy> @hoogle Int -> Char
17:49:59 <lambdabot> Char.chr :: Int -> Char
17:49:59 <lambdabot> Char.intToDigit :: Int -> Char
17:49:59 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
17:50:03 <Porges> what's the link? :)
17:50:14 <dmwit> ?go haskell edison
17:50:15 <lambdabot> http://www.haskell.org/ghc/docs/edison/
17:50:15 <lambdabot> Title: Edison User's Guide* (Haskell version)
17:50:26 <Porges> thx
17:50:56 <dmwit> Oh, also:
17:50:58 <dmwit> ?where edison
17:50:58 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
17:51:51 <chessguy> @instances-importing Arbitrary
17:51:52 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
17:54:23 <davidL> dons: do you have to be on bsd.mp for `par' to work? :-\
17:54:56 <gwern> any simpler way to get last member of a list than (head . reverse)?
17:55:11 <faxathisia> :t last
17:55:12 <lambdabot> forall a. [a] -> a
17:55:24 <Olathe> > last [1..]
17:55:26 <lambdabot> Terminated
17:55:28 <Olathe> Faster !
17:55:28 <gwern> @src last
17:55:28 <lambdabot> last [x]    = x
17:55:28 <lambdabot> last (_:xs) = last xs
17:55:28 <lambdabot> last []     = undefined
17:55:57 <Olathe> reverse is kind of overdoing it.
17:56:08 <faxathisia> @ src reverse
17:56:10 <faxathisia> @src reverse
17:56:10 <lambdabot> reverse = foldl (flip (:)) []
17:56:24 <faxathisia> @unfold foldl flip in reverse
17:56:24 <lambdabot> Unknown command, try @list
17:56:25 <faxathisia> >:D
17:56:40 <Olathe> > foldl' (flip const) 0 [1..10]
17:56:41 <lambdabot>  10
17:56:59 <faxathisia> very nice :D
17:58:16 <hpaste>  chessguy pasted "how do i get an arbitrary string of a particular length?" at http://hpaste.org/4156
17:58:32 <chessguy> this code gives me a random string with a random length
17:58:43 <Pastorn> @type const
17:58:44 <lambdabot> forall a b. a -> b -> a
17:58:59 <Pastorn> @type (flip const)
17:58:59 <lambdabot> forall a b. b -> a -> a
17:59:04 <dons> davidL: yeah, but on openbsd the scheduler isn't so great anyway :(
17:59:16 <davidL> oh, :-(
17:59:19 <dons> davidL: you should at least see 2 cpus in the output of 'top'
17:59:42 <Pastorn> chessguy: quickcheck
17:59:54 <chessguy> yes...
17:59:56 <gwern> is there any handy function to remove teh last entry in a list? I'm coming up with some terrible concoction of tails and reverses...
18:00:13 <faxathisia> gwern: What's wrong with reverse.tail.reverse
18:00:42 <chessguy> > init "haskell'
18:00:42 <lambdabot>  Improperly terminated string at ""hask..." (column 6)
18:00:47 <chessguy> > init "haskell"
18:00:48 <lambdabot>  "haskel"
18:00:51 <faxathisia> @src init
18:00:52 <lambdabot> init [x]    = []
18:00:52 <lambdabot> init (x:xs) = x : init xs
18:00:52 <lambdabot> init []     = undefined
18:00:54 <gwern> faxathisia: it looks so ugly, and since there was a short for 'last'...
18:01:08 <faxathisia> init = reverse.tail.reverse -- less ugly imo
18:01:30 <gwern> *shortcut
18:01:39 <chessguy> it's even less ugly to use the one that's already defiend
18:01:45 <chessguy> defiend?
18:01:50 <chessguy> defined
18:01:52 <faxathisia> I mean it's a less ugly definition
18:01:56 <Porges> @letallbutlast = head.tail.reverse.inits
18:01:56 <lambdabot> Unknown command, try @list
18:02:00 <faxathisia> Is it worst?
18:02:02 <Porges> @let allbutlast = head.tail.reverse.inits
18:02:06 <faxathisia> I mean is reverse.tail.reverse worse than that definition?
18:02:10 <lambdabot> Defined.
18:02:12 <chessguy> Pastorn, i'm using QC there, but the documentation seems to be gone from http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck-1.1.0.0/Test-QuickCheck.html and i don't know why
18:02:13 <lambdabot> http://tinyurl.com/2ez6o5
18:02:14 <Porges> allbutlast [1..1241241241]
18:02:15 <faxathisia> I wonder if it's less efficient or something
18:02:46 <chessguy> faxathisia, looks like 2n instead of n to me
18:02:54 <gwern> >  allbutlast [1..1241241241]
18:02:57 <lambdabot> Terminated
18:02:59 <gwern> >  init [1..1241241241]
18:02:59 <faxathisia> hmm
18:03:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:03:00 <Porges> lol :D
18:03:10 <gwern> Porges: I think init is faster :)
18:03:12 <faxathisia> chessguy: I think you're right but then it's more efficient in terms of space?
18:03:34 <gwern> reversing a list can't be cheap... destroys laziness, for example, doesn't it?
18:03:38 <chessguy> err, why are you reversing inits?
18:03:48 <Porges> entropy
18:03:53 <Porges> needs mroe
18:04:03 <Porges> ... there it goes
18:04:05 <faxathisia> @src reverse
18:04:05 <lambdabot> reverse = foldl (flip (:)) []
18:04:10 <gwern> random cat needs moar entropy!
18:05:04 <Porges> :| what's the easiest way to install libraries under windows
18:05:09 <Olathe> What we need are some podcats !
18:05:25 <faxathisia> > (reverse [undefined,undefined,"Gold",undefined])!!1
18:05:26 <lambdabot>  "Gold"
18:05:40 <TomMD> Are there plans to allow access to data fields by name in non Haskell 98 data structures?
18:05:41 <faxathisia> seems like it doesn't destroy lazyness
18:05:58 <jcreigh> well, if the list was being generated lazily.
18:06:02 <faxathisia> It just has to calculate the length of the list (which might involve calculating each element, but didn't in this case)
18:07:05 <chessguy> @undo do { g <- n; return gen 320 g a }
18:07:05 <lambdabot> n >>= \ g -> return gen 320 g a
18:07:25 <chessguy> @pl \ g -> return gen 320 g a
18:07:25 <lambdabot> flip 320 a
18:07:31 <chessguy> eh?
18:08:12 <Porges> lol
18:08:12 <monochrom> liftM (\g -> gen 320 g a) n
18:08:17 <darrint> How do I signal -fglasgow-exts from inside a source file?
18:08:33 <TomMD> {-# OPTIONS_GHC -fglasgow-exts #-}
18:08:34 <faxathisia> {-# OPTIONS -fglasgow-exts #-}
18:08:36 <monochrom> liftM (flip (gen 320) a) n
18:08:39 <LoganCapaldo> {-# OPTIONS_GHC -fgkasgow-exts #-}
18:08:39 <darrint> thank you
18:08:43 <Olathe> @do n >>= flip 320 a
18:08:43 <lambdabot> n >>= flip 320 a not available
18:08:47 <Olathe> @redo n >>= flip 320 a
18:08:48 <lambdabot> do { b <- n; flip 320 a b}
18:09:05 * LoganCapaldo is slow and a bad typer
18:09:14 <Olathe> @help do
18:09:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:09:17 <Olathe> @do
18:09:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:09:22 <chessguy> @type \ g -> return ?gen 320 g ?a
18:09:24 <lambdabot> forall t t1 t2. (?gen::t -> t1 -> t2, ?a::t1) => t -> t2
18:09:24 <faxathisia> @quote oleg
18:09:24 <lambdabot> EvilTerran says: i get quite a lot of odd type errors, actually; probably something to do with my fascination with Olegian type hacks...
18:09:28 <Pastorn> chessguy: yeah, it seems that ALL of hoogle i borken
18:09:38 <faxathisia> @keal
18:09:38 <lambdabot> know you know this 24 periods Keal SecretTM
18:09:40 <TomMD> LoganCapaldo: "The miricle is not that you finished, but that you had the courage to start."
18:09:45 <chessguy> @type flip 320 a
18:09:45 <lambdabot> Not in scope: `a'
18:09:52 <faxathisia> @keal
18:09:52 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
18:10:00 <gwern> (the joke is he is parodying my user page: [[User:Gwern]] https://secure.wikimedia.org/wikipedia/en/wiki/User:Gwern )
18:10:04 <faxathisia> lol
18:10:07 <gwern> mischan
18:10:13 <Pastorn> why is hoogle broken? it will make baby lb cry!!
18:10:20 <davidL> hmmm, is the openbsd scheduler so bad that as I increase -N (# cores) the time increases exponentially?
18:11:13 <faxathisia> What's some cool haskell code I should read?
18:11:20 <Zao> faxathisia: Any.
18:11:30 <davidL> 1m50.7s with 2 cores, 2m55.7s with 3 cores :-(
18:11:47 <faxathisia> any outstanding ones to look at?
18:12:15 <Pastorn> faxathisia: there's a GameBoy emulator...
18:12:21 <monochrom> the "functional pearls" column in the Journal of Functional Programming.
18:12:22 <TomMD> faxathisia: Any author named Simon.  Any topic covering STM.  And it isn't very outstanding, but if you want to look at and improve my MD5 that'd be cool too.
18:12:38 <gwern> question,  -XFlexibleInstances -XTypeSynonymInstances is equivalent to adding 'FlexibleInstances, TypeSynonymInstances' to the Extensions: field, I thought, but they don't seem to act the same
18:12:42 <faxathisia> omg
18:12:45 <faxathisia> there really is a Haskell Game Boy Emulator
18:12:49 <TomMD> Oh yes - "Probabilist Functional Programming"
18:12:51 <faxathisia> cool :D
18:12:53 <gwern> (not very fast I heard)
18:13:23 <TomMD> gwern: What isn't very fast?
18:13:25 <faxathisia> :D
18:13:26 <Pastorn> faxathisia: just go to the darcs directory and start browsing
18:13:34 <gwern> TomMD: the gb emu
18:14:06 <Pastorn> faxathisia: i luuuuuuuuuuuv how the instructions are implemented in a case expression with 255 different cases :D
18:14:07 <faxathisia> amazing!
18:14:25 <Olathe> O-o
18:14:26 <Pastorn> have fun
18:14:26 <Pastorn> i
18:14:34 <Pastorn> i'm leaving for bed now
18:14:34 * faxathisia is 
18:14:36 <sorear> faxathisia: the author was here
18:14:40 <faxathisia> today?
18:15:34 <chessguy> @type liftM (\g -> ?generate 320 g (arbitrary :: Gen Char)) n
18:15:39 <lambdabot> Not in scope: `arbitrary'
18:15:39 <lambdabot> Not in scope: type constructor or class `Gen'
18:15:39 <lambdabot> Not in scope: `n'
18:17:32 * faxathisia wonders if you could compile haskell onto a GBA or something and have it emulate a gameboy
18:19:25 <Olathe> Well, you could probably have it cross-compile.
18:19:33 <Olathe> Maybe gcc can do it.
18:21:12 <LoganCapaldo> I'd give my right ARM for a Haskell compiler targeting the gba
18:21:28 <lament> why?
18:21:31 <faxathisia> lol
18:21:41 <faxathisia> :D
18:21:41 <dataangel> If you make a constructor strict with (!), does that mean that just mean that if you give it _|_ you get an error, or does it also mean it forces evaluation of its argument right away? (thus causing the error)
18:21:56 <faxathisia> @quote LoganCapaldo I'd give my right ARM for a Haskell compiler targeting the gba
18:21:56 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:21:59 <faxathisia> >:|
18:22:03 <faxathisia> @remember LoganCapaldo I'd give my right ARM for a Haskell compiler targeting the gba
18:22:03 <lambdabot> Good to know.
18:22:15 <monochrom> My understanding is both.
18:22:17 <lament> gba is just a lame cheap OLPC ripoff
18:22:25 <dons> ?users
18:22:25 <lambdabot> Maximum users seen in #haskell: 420, currently: 393 (93.6%), active: 21 (5.3%)
18:22:29 <dons> oh, up a bit today.
18:22:29 <lament> with emphasis on "cheap", i suppose :)
18:22:31 <Saizan> dataangel: it means that as soon as the constructor is forced, the field is forced too
18:23:28 <dataangel> ah k
18:24:12 <dataangel> Why not have constructors be strict by default?
18:24:34 <LoganCapaldo> why not have everything be strict by default?
18:24:51 <pastorn> .fysik
18:24:54 <LoganCapaldo> cause it would not be coooooooool
18:25:33 * LoganCapaldo would not enjoy sticking laziness annotations all over the place
18:26:48 <dataangel> lol
18:27:45 <monochrom> If strictness is the default, people wouldn't give nonstrictness a fair try. Just look at the habits of programmers of SML.
18:29:37 <dons> and strictness gives you an evaluation order people start to rely on
18:29:51 <dons> so that things like `par` don't work, and side effects start being snuck in
18:29:57 <monochrom> Take lists and "map" for example. We use it at a whim. It is easy to reason about, easy to use, and no performance hit thanks to nonstrictness.
18:30:51 <monochrom> Now look at SML programmers. They avoid map like plague. They take great pains to complicate their code because they have to avoid map, i.e., manually do their fusion or whatever.
18:32:44 <Olathe> Why do they avoid map ?
18:32:58 <Olathe> Ahh.
18:33:36 <Shimei> Laziness annotations is exactly what I'm having to do with some of the scheme exercises in SICP. Not so fun.
18:34:03 <Shimei> The book actually mentions lazy evaluation and polymorphic typing though. Yay for breadth.
18:34:45 <lament> the beauty of scheme is that you can say, "...and now we'll implement lazy evaluation"
18:35:00 <lament> "..and then, as an exercise, polymorphic typing"
18:35:37 <lament> (the resulting language will be extremely verbose and a pain to use, but then, so is Scheme :D)
18:35:49 <faxathisia> lament: I disagree
18:36:25 <lament> with which part? :)
18:36:46 <faxathisia> lament: you aren't using scheme directly are you? implement at least 5 languages on top each other first
18:36:50 <monochrom> The latest SML libraries contain a laziness mechanism. But no one uses it. No one bothers to use it to add lazy lists and lazy map to the same libraries. SML programmers have already trained themselves to use eagerness, there is no interest in exploring laziness even if it is provided later.
18:37:03 <lament> faxathisia: sure (dunno about 5.. probably 1?)
18:37:28 <lament> you can't change scheme so that it has lazy evaluation, but you can quite easily embed a language with lazy evaluation inside scheme
18:37:52 <monochrom> Moral: If a language doesn't stretch people's minds, people won't stretch their minds.
18:38:04 <diltsman> Does anybody use Visual Haskell?  (VS plugin)
18:38:11 <dons> monochrom: i think that's true.
18:38:22 <dons> or, difficult conditions lead to innovation :)
18:39:14 <lament> who was it that applied the same logic to IO
18:39:18 <lament> was it by any chance dons? :)
18:39:50 <diltsman> Anybody know why the VS2005 installer for Visual Haskell says it failed to setup 2 .dlls?
18:39:52 <lament> (ie that haskell programmers got lazy after IO appeared)
18:40:19 <P_D> lazy, or better known as productive.
18:40:31 <__a> is something like lambdabot available over http?
18:42:42 <diltsman> Anybody have experience getting Visual Haskell to install on VS2005?
18:42:57 <P_D> I've done that.  it just worked.  sorry.
18:44:06 <diltsman> It keeps saying "Failed to setup vs_haskell_babel.dll" and "Failed to setup vs_haskell_dlg.dll"
18:56:28 <mcnster> is there a preferred or standard package for haskell with objects?
18:57:14 <chessguy> @hoogle generate
18:57:15 <lambdabot> Test.QuickCheck.generate :: Int -> StdGen -> Gen a -> a
18:57:15 <lambdabot> System.Win32.Mem.hEAP_GENERATE_EXCEPTIONS :: HeapAllocFlags
18:57:23 <chessguy> what does that Int do?
19:00:08 <dons> mcnster: objects?
19:00:55 <dons> as in, mutable, existentially typed data?
19:01:12 <mcnster> dons, yes
19:01:51 <dons> people seem to use record types instead
19:01:58 <dons> and maybe existentials
19:02:16 <mcnster> HList?
19:03:01 <dons> that's one package for tricky type stuff, yep
19:03:07 <dons> what's your use case?
19:03:50 <mcnster> a mutation of Sun's Self into Haskell
19:04:05 <dons> there's been some papers on this stuff
19:04:12 <dons> i think HList came out of one branch
19:05:14 <mcnster> i've got some reading to do then
19:05:41 <mcnster> thanks dons
19:06:09 <dons> if you get stuck, just ask on the -cafe. its come up a few times over the years
19:06:21 <mcnster> will do
19:09:41 <chessguy> @type max
19:09:42 <lambdabot> forall a. (Ord a) => a -> a -> a
19:12:08 <Olathe> ~cafe
19:12:13 <Olathe> Oh.
19:12:17 <dancor> i would like to be able to take a gramamr and a string prefix, and get all strings in the grammar that start with the string prefix
19:12:33 <dancor> should i start from scratch or could an existing parser library help
19:12:52 <monochrom> ~cafe is irrefutable :)
19:13:01 <Olathe> O-o
19:13:33 <Olathe> There are jokes flying above me !
19:13:49 <monochrom> Grammatical Framework may help.
19:14:00 <chessguy> @src Eq
19:14:00 <lambdabot> class  Eq a  where
19:14:00 <lambdabot>     (==), (/=)   :: a -> a -> Bool
19:14:15 <monochrom> Recall that in the pattern matching syntax, irrefutable patterns are marked by ~
19:17:22 <chessguy> @type length . filter id . zipWith (==) target
19:17:23 <lambdabot> Not in scope: `target'
19:17:29 <chessguy> @type length . filter id . zipWith (==) ?target
19:17:30 <lambdabot> forall a. (Eq a, ?target::[a]) => [a] -> Int
19:19:44 <byorgey> dancor: you might want to check out the Functional Pearl by Doug McIlroy
19:19:52 <byorgey> @go enumerating strings regular languages
19:19:53 <lambdabot> http://www.cs.dartmouth.edu/~doug/nfa.ps.gz
19:20:24 <byorgey> that might give you some ideas to start from.
19:20:27 <jonathanturner> I'm pretty new to Haskell, and I'm watching Simon Peyton-Jones's lecture for OSCON.  He mentions that in the type class discussion that if you made a new type and it satisfied the operations of, say, Num, then it would be a Num.  Is that true or did I misunderstand him?
19:20:46 <byorgey> jonathanturner: well, you have to declare it to be so.
19:20:52 <byorgey> using an 'instance' declaration.
19:21:46 <jonathanturner> byorgey: ahh, okay, got it.  So it's not going to try to infer if you just implement something that looks like what the Num operations are
19:22:09 <byorgey> jonathanturner: right.
19:22:33 <jonathanturner> I guess this lets you name your operations differently and map those back on to the expected ones.  Very nifty.
19:23:05 <SamB_XP> hmm?
19:23:52 <byorgey> jonathanturner: sure.
19:31:15 <hpaste>  chessguy pasted "this ruby implementation of a basic GA seems better than my naive haskell implementation. suggestion" at http://hpaste.org/4157
19:34:11 <atp> evening guys
19:34:29 <Spark> GA?
19:34:38 <mgsloan> genetic algorithm
19:35:13 <Spark> ah
19:35:26 <mgsloan> simulated evolution, to find optima in a fitness metric
19:37:37 <byorgey> hi atp
19:46:00 <dons> ?users
19:46:00 <lambdabot> Maximum users seen in #haskell: 420, currently: 393 (93.6%), active: 9 (2.3%)
19:46:25 <P_D> @pl \g (x,y) -> g x y
19:46:25 <lambdabot> (`ap` snd) . (. fst)
19:46:33 <chessguy> hm. apparently my implenetation is actually busted :(
19:46:36 <faxathisia> :t \g (x,y) -> g x y
19:46:38 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
19:46:41 <faxathisia> :t uncurry
19:46:42 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:46:52 <P_D> thanks.
19:46:56 <faxathisia> lambdabot: bad!
19:46:58 <gwern> @pl return $ filter (\x -> head x /= '.') matches
19:46:58 <lambdabot> return (filter (('.' /=) . head) matches)
19:47:14 <gwern> @pl filter (\x -> head x /= '.') matches
19:47:14 <lambdabot> filter (('.' /=) . head) matches
19:47:20 <dons> so, i'm full of soup. what's something exciting ?
19:47:39 <dmwit> A roller coaster!
19:47:41 <chessguy> @let replace spot char string = take spot string ++ [char] ++ drop spot string
19:47:42 <dons> woot!
19:47:44 <lambdabot> Defined.
19:47:50 <dons> that's so true, dmwit
19:47:54 <dmwit> \o/
19:47:56 <dmwit> No hands!
19:47:58 <chessguy> replace 0 'a' "Haskell"
19:48:04 <chessguy> > replace 0 'a' "Haskell"
19:48:04 <lambdabot>  "aHaskell"
19:48:13 <chessguy> > replace 1 'a' "Haskell"
19:48:19 <lambdabot>  "Haaskell"
19:48:25 * chessguy sighs
19:48:37 <davidL> @type insert
19:48:37 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
19:49:07 <dmwit> dons: What do you mean by exciting?
19:49:16 <chessguy> @let replace spot char string = take spot string ++ [char] ++ drop (spot+1) string
19:49:23 <lambdabot> <local>:7:0:     Warning: Pattern match(es) are overlapped              In th...
19:49:30 <chessguy> @undefine
19:49:33 <dons> dmwit: oh, something cool and unusual
19:49:36 <lambdabot> Undefined.
19:49:38 <chessguy> @let replace spot char string = take spot string ++ [char] ++ drop (spot+1) string
19:49:39 <lambdabot> Defined.
19:49:50 <dons> we've not tried to take over the world in at last 4 hours
19:49:54 <chessguy> > replace 0 'a' "Haskell"
19:49:55 <lambdabot>  "aaskell"
19:49:57 <dmwit> dons: Have you seen Chipmunk?
19:50:02 <chessguy> > replace 5 'a' "Haskell"
19:50:03 <lambdabot>  "Haskeal"
19:50:06 <dons> i've seen Alvin and the Chipmunks
19:50:09 <dmwit> Oh, Haskell related, never mind. =P
19:50:13 <faxathisia> Chipmunk physics engine?
19:50:22 <dmwit> yeah
19:50:46 * faxathisia wonders how it's so damn famous
19:50:48 <dmwit> http://files.slembcke.net/chipmunk/movies/sketches.mov
19:50:58 * faxathisia complains about their own failed attempts at writing one
19:50:59 <dmwit> faxathisia: It's got sexy demos.
19:51:34 <chessguy> > replace 3 'a' "foo"
19:51:43 <lambdabot>  "fooa"
19:52:13 <mgsloan> :O that is pretty sweet
19:52:21 <faxathisia> replace is a bad name
19:52:41 <faxathisia> It's actually inserting isn't it?
19:52:42 <chessguy> i'm open for suggestions
19:52:51 <chessguy> faxathisia, it's not supposed to be
19:53:03 <chessguy> > replace 1 'a' "foo"
19:53:08 <lambdabot>  "fao"
19:53:19 <allbery_b> ot'
19:53:20 <Pseudonym> Alvin and the Chipmunks isn't what it was.
19:53:23 <allbery_b> it's a corner case
19:53:31 <mgsloan> we should write a 2d haskell physics engine sometime
19:53:35 <Pseudonym> Anyway.
19:53:36 <kfish> > replace 7 'a' foo
19:53:39 <lambdabot>   Not in scope: `foo'
19:53:46 <kfish> > replace 7 'a' "foo"
19:53:47 <lambdabot>  "fooa"
19:54:01 <allbery_b> with that definition of replace, it takes the entire string, appends the specified character, then the drop returns []
19:56:42 <chessguy> i'm still open to suggestions
19:57:01 <dmwit> It's fine, no suggestions needed.
19:59:56 <allbery_b> > let replace spot char string | spot >= length string = error "replace past end"; | otherwise = take spot string ++ (char:drop (spot+1) string) in replace 7 'a' "foo"
19:59:56 <lambdabot>  Parse error at "|" (column 82)
20:00:06 <allbery_b> > let replace spot char string | spot >= length string = error "replace past end" | otherwise = take spot string ++ (char:drop (spot+1) string) in replace 7 'a' "foo"
20:00:19 <allbery_b> ...
20:00:20 <lambdabot>  Exception: replace past end
20:00:39 <allbery_b> > let replace spot char string | spot >= length string = error "replace past end" | otherwise = take spot string ++ (char:drop (spot+1) string) in replace 3 'a' "foo"
20:00:40 <lambdabot>  Exception: replace past end
20:00:43 <chessguy> partial functions FTL
20:00:44 <allbery_b> oops
20:01:14 * allbery_b thwaps self with an OPTION INDEX 1
20:05:05 <byorgey> heh
20:15:44 <dancor> [Thu Nov 29 20:15:35 2007] [error] PHP Fatal error:  Nesting level too deep - recursive dependency? in /var/users/dcorson/www-git.www/lib/intern/sitevars.php on line 865
20:15:50 <dancor> oops
20:16:13 <dancor> how embarrassing to admit that i use php
20:16:37 <Korollary> We understand
20:17:38 <chessguy> speak for yourself :)
20:18:15 <mgsloan> heh, PHP is practically the antithesis of haskell
20:18:24 <mgsloan> the anti-haskell
20:18:34 <chessguy> PHP -- Pleas Hack me, Please!
20:19:21 <dmwit> Nah, PHP is PHun for all ages! ... P
20:19:50 <ikegami--> PHP -- PHP really needed Haskell Programmers!
20:19:57 <Pseudonym> chessguy: I find it amazing, but I guess I shouldn't by now, just how bad most PHP apps are.
20:20:00 <Pseudonym> As in insecure.
20:20:10 <chessguy> indeed
20:20:18 <chessguy> Bobby Tables will find them
20:20:28 <Pseudonym> Things like someone finds an exploit, it gets patched, and when I come to apply it, I notice five other instances of the exact same bug within 100 lines of the patch.
20:20:29 <jeffz> why does haskell.org use php then?
20:20:42 <joed> http://tnx.nl/php
20:20:43 <lambdabot> Title: PHP in contrast to Perl
20:20:53 <Pseudonym> I don't think it's PHP.
20:20:57 <Pseudonym> I think it's PHP programmers.
20:21:01 <Spark> php is hilarious because systems guys will go to great lengths to make sure the system is tied down, fully upgraded, etc
20:21:13 <Spark> and then someone writes a crappy script that lets the user detonate the moon
20:21:29 <Pseudonym> But you need to allow detonateMoon for this script tor un!
20:21:30 <Pseudonym> run
20:21:39 <Spark> php is also shit though
20:21:43 <Pseudonym> Well, yes.
20:21:49 <Spark> remember the guy who was releasing the "bug a day"
20:21:49 <faxathisia> does PHP have goto?
20:21:53 <dancor> the language is bad and the implementation is worse
20:21:56 <Spark> to piss of the php devs who refused to fix them
20:21:59 <Spark> security bugs :)
20:22:04 <jeffz> faxathisia: the next version will, iirc.
20:22:07 <faxathisia> haha
20:22:10 <Spark> goto is a non-issue
20:22:12 <sclv> all the major php fancy packages everyone uses are still based on 4 and require you to do things like set registerGlobals to on to run them though.
20:22:14 <faxathisia> PHP + goto
20:22:19 <faxathisia> the future :D
20:22:26 <Pseudonym> Exactly.
20:22:35 <Pseudonym> It's the injection bugs that get me.
20:22:45 <dmwit> As long as we're having a pissing match, I've heard its naming scheme is incomprehensible, too.
20:22:46 <Spark> tcl is the classic for that
20:22:48 <Spark> everything is a string
20:22:57 <Spark> so user input is indistinguishable from code
20:23:03 <sclv> php also has a terribly crashy runtime environment -- its real easy to force it to dump core.
20:23:14 <faxathisia> Spark: that doesn't sound like a problem
20:23:19 <faxathisia> is it?
20:23:21 <Shimei> dmwit: Yeah, there's a whole website dedicated to mocking it for that.
20:23:36 <jeffz> so someone should rewrite php in haskell?
20:23:41 <Spark> faxathisia: remember the eggdrop exploits
20:23:49 <Spark> where you could join with {quit} in your nick or whatever it was
20:23:56 <faxathisia> ohhh heh
20:24:00 <faxathisia> never knew about that
20:24:04 <dmwit> jeffz: That wouldn't really be helpful, I think.
20:24:07 <Shimei> dmwit: http://www.tnx.nl/php
20:24:09 <lambdabot> Title: PHP in contrast to Perl
20:24:45 <Pseudonym> While I agree that PHP is crap, I think the real problem is that PHP developers are, on average, much more careless.
20:24:49 <jeffz> dmwit: perhaps, but -- if you can't beat 'em, join em
20:24:54 <Pseudonym> Than pretty much anyone else.
20:25:14 <Pseudonym> Oh, I like that.
20:25:18 <Pseudonym> "Arguments and return values are extremely inconsistent"
20:25:21 <dmwit> jeffz: What makes you think we can't beat them? ;-)
20:25:23 * Pseudonym splutters
20:25:32 <Pseudonym> Has this person never USED Perl?
20:25:43 <Shimei> Oh, someone already posted that link. Whoops.
20:25:48 <faxathisia> Is haskell really good for making websites though?
20:25:53 <faxathisia> I mean of course it's better than PHP
20:26:01 <jeffz> dmwit: I'm guessing the sheer number of php "programmers" who will never use haskell, will be the ones we can't win.
20:26:17 <Shimei> faxathisia: Really just a matter of webserver support isn't it?
20:26:26 <Shimei> PHP is useful because of mod_php and .php files.
20:26:36 <Pseudonym> mod_perl, mod_python...
20:26:39 <dmwit> jeffz: We don't have to convert them, we just have to beat them.
20:27:04 <Shimei> (.php as in PHP being directly integrated into html files, I mean)
20:27:28 <faxathisia> I think lisp is beating PHP in that regard
20:27:36 <faxathisia> since you can write '(html (head ...))
20:27:48 <faxathisia> but I see in haskell like not as easy
20:27:58 <dmwit> nonsense
20:28:11 <dmwit> WASH, despite many drawbacks, has a very nice page construction DSL.
20:28:20 <faxathisia> cool I'll check it out
20:28:31 <Shimei> Pseudonym: Yeah, but not many actual webhosts use those. Some don't even have CGI support for those. My web host supports even Haskell for CGI though. :)
20:28:36 <chessguy> @type average
20:28:37 <lambdabot> Not in scope: `average'
20:28:52 <dmwit> faxathisia: With a very few modifications, you can guarantee statically that it creates valid XHTML strict. =)
20:28:57 <mgsloan> Shimei - nfshost, perhaps?
20:29:02 <Shimei> mgsloan: Yep.
20:29:05 <faxathisia> dmwit: in the type system? :D
20:29:08 <mgsloan> yeah, me too :)
20:29:11 <dmwit> Yup!
20:29:15 <mgsloan> though I haven't messed with haskell cgi on it yet
20:29:17 <faxathisia> haha awesome
20:29:18 <chessguy> @pl \ls -> sum ls / length ls
20:29:18 <lambdabot> liftM2 (/) sum length
20:29:21 <faxathisia> *that* is cool
20:29:52 <chessguy> > liftM2 (/) sum length $ [4678,16828,10113,4866,2994,21704,5733,49676,12669,7424,20998,6846,9664,10975,5503,34424,10868,9755,16282,7045]
20:29:52 <lambdabot>   add an instance declaration for (Fractional Int)
20:30:25 <chessguy> > liftM2 (/) sum (fromIntegral.length) $ [4678,16828,10113,4866,2994,21704,5733,49676,12669,7424,20998,6846,9664,10975,5503,34424,10868,9755,16282,7045]
20:30:25 <lambdabot>  13452.25
20:30:46 <mgsloan> hmm, nice
20:30:58 <allbery_b> > liftM2 (/) sum genericLength [4678,16828,10113,4866,2994,21704,5733,49676,12669,7424,20998,6846,9664,10975,5503,34424,10868,9755,16282,7045]
20:30:59 <lambdabot>  13452.25
20:32:25 <mgsloan> ooh
20:42:58 <shachaf> Why does Hackage have both "text" and "Text" categories?
20:47:39 <dons> shachaf: people can use whatever  text they like for categories, currently
20:48:08 <shachaf> dons: Hmm. Should that be case-sensitive, though?
20:49:32 <dons> its harmless, just annoying for clean freaks
20:49:39 <dons> it annoys me :)
20:51:13 <faxathisia> wait what happens if you add subtyping to haskell?
20:52:09 <dons> the type system gets complex?
20:52:21 <mgsloan> you are smited by the haskell gods?
20:52:58 <faxathisia> actually I have no idea how subtyping might interact with typeclasses
20:53:10 <mgsloan> you'd run into all kinds of variance issues
20:53:18 <faxathisia> what does that mean?
20:53:30 <chessguy> @type let score x y = length $ filter id $ zipWith (==) x y in score
20:53:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
20:53:45 <chessguy> is there a better way to do that?
20:54:55 <mgsloan> Well, I remember scala has variance annotations for generics with subtyping.  I think covariance vs contravariance indicates whether a generic parameter may be a supertype or subtype of the specified type in order to '
20:54:58 <mgsloan> work'
20:55:17 <mgsloan> in general, as dons said, it gets very complex
20:55:34 <davidL> Using a bitmap can an array of positive integers always be sorted in O(n) time?
20:55:40 <mgsloan> and doesn't really serve much of a purpose
20:57:12 <mgsloan> davidL: http://en.wikipedia.org/wiki/Radix_sort
20:57:12 <lambdabot> Title: Radix sort - Wikipedia, the free encyclopedia
20:57:54 <mgsloan> so yes, O(n) is possible for integers
20:58:55 <Pseudonym> You can work out the theoretically optimal complexity for many algorithms using information theory, and this is no different.
21:00:04 <Pseudonym> A k-way case statement is worth log k binary comparisons.
21:01:05 <davidL> I'm thinking more simply than that. For example, for each i in unsorted, bit[i] = 1; for i in [0,n), if bit[i] == 1, print i
21:01:52 <TSC> Then you lose the duplicates
21:02:07 <Pseudonym> There are circumstances where you can assume no duplicates.
21:02:08 <davidL> yes, but you could have a counter to compensate for that
21:02:22 <TSC> Then it's not a bitmap, it's an intmap
21:02:39 <davidL> but it's still O(n)
21:03:02 <TSC> Sure
21:03:19 <TSC> It's bucket sort
21:03:38 <TSC> With very narrow buckets
21:03:58 <faxathisia> why would you sort a bitmap?
21:04:08 <faxathisia> as opposed to store how many are on and off
21:04:24 <Pseudonym> Why would you sort a quick?
21:04:49 <mgsloan> why would you sort a bubble?
21:05:16 <Pseudonym> Hey, I like putting my bubbles in order.
21:05:54 <mgsloan> understandeable
21:05:56 <davidL> is there something I'm missing about that algorithm, it seems like there is
21:05:57 <Pseudonym> But you have a point.  There are exactly no circumstances where bubble sort is the right algorithm to use.
21:06:29 <mgsloan> bogosort is even better
21:07:06 <meester> as an exercise in insanity, i'm trying to make pointfree the following code
21:07:18 <davidL> essentially you have O(2*n) everytime, I don't see how you can do better than that
21:07:20 <meester> let replicate' n = take n . y .(:)
21:07:36 <meester> anyone got any ideas?
21:07:51 <faxathisia> @pointless \n -> take n . y .(:)
21:07:51 <lambdabot> (. (y . (:))) . take
21:08:09 <meester> ouch
21:08:28 <sjanssen> @pl \n x -> iterate (x:) [] !! n
21:08:29 <lambdabot> flip ((!!) . flip iterate [] . (:))
21:09:00 <faxathisia> 1. Permute the array randomly using a quantum process, 2. If the array is not sorted, destroy the universe (checking that the list is sorted requires O(n) time).
21:09:12 <mgsloan> davidL - Big-O doesn't take coefficients
21:09:37 <faxathisia> Isn't O(2n) = O(n)?
21:09:41 <davidL> mgsloan: I know, I didn't know how else to show it
21:09:43 <mgsloan> yep
21:10:03 <faxathisia> so.. O(n) = O(2n)
21:10:08 <Pseudonym> davidL: To sort a list, you need to examine every element.
21:10:13 <faxathisia> or should I really use a different operator than =?
21:10:14 <Pseudonym> So O(n) is a trivial lower bound on sorting.
21:10:42 <davidL> Pseudonym: it's the best case and worst case, I think
21:12:13 <kawfee> faxathisia: for Big Oh, yes
21:12:16 <davidL> you need to keep the entire array in memory, which I guess is a downside
21:12:26 <kawfee> constants in front of the n are not to be bothered with
21:12:56 <Pseudonym> davidL: It depends what kind of decision you can take.
21:13:04 <Pseudonym> As to whether it's the best or worst case.
21:13:32 <Pseudonym> If you have a comparison operation that returns a Bool, then O(n log n) is a lower bound.
21:13:36 <kawfee> keeping an array in memory is more efficent but also memory hog
21:14:07 <kawfee> Pseudonym:  says who?
21:14:20 <kawfee> What data type?
21:14:26 <Pseudonym> kawfee: Any data type.
21:14:29 <kawfee> nah
21:14:37 <kawfee> you can do some special things in special cases
21:14:44 <Pseudonym> If all you can do with it is compare and get a Bool, then your sort must take O(n log n) time.
21:14:48 <Pseudonym> At least.
21:15:00 <Pseudonym> Gregory Chaitin says so.
21:15:02 <kawfee> maybe
21:15:11 <kawfee> that is probably a proven lower bound
21:15:14 <kawfee> iirc
21:15:16 <Pseudonym> Yes.
21:15:29 <faxathisia> Chaitin o_o
21:15:32 <kawfee> but you can do better in special cases
21:15:35 <kawfee> if you know more
21:15:41 <Pseudonym> Ah, that's the key thing.
21:15:44 <P_D> not with modern memory hierarchies.
21:15:46 <kawfee> =]
21:15:50 <TSC> The reasoning of the n log n bound is fairly simple
21:15:56 <srid> Any good Haskell/Erlang book? - http://programming.reddit.com/info/61qxv/comments/
21:15:56 <P_D> n log n is an economically optimal limit
21:15:59 <Pseudonym> See, a comparison that gives you a Bool gives you one bit of information.
21:16:00 <kawfee> memory hierarchy isn't included
21:16:01 <faxathisia> any good books by Chaitin online?
21:16:12 <faxathisia> other than, http://www.umcs.maine.edu/~chaitin/eesti.html www.cs.umaine.edu/~chaitin/unknowable/
21:16:13 <lambdabot> Title: Chaitin, From Philosophy to Program Size
21:16:21 <kawfee> 1 bit or 10 bits is all the same
21:16:24 <P_D> no, but it makes theory fairly useless and non descriptive of reality
21:16:25 <Pseudonym> You need O(n log n) bits of information to do a sort.
21:16:39 <kawfee> what?
21:16:49 <kawfee> haha
21:16:49 <faxathisia> Haskell/Erlang the new C/C++?
21:16:54 <kawfee> are you talking about memory big oh?
21:16:59 <kawfee> or efficiency?
21:17:00 <Pseudonym> A k-way case statement (e.g. extracting a radix) gives you more than one bit of information.
21:17:12 <Pseudonym> I'm talking about time.  Specifically, number of comparisons.
21:17:19 <kawfee> ok
21:17:28 <kawfee> well, the number of bits returned has nothing to do with it then
21:17:52 <faxathisia> kawfee: What?
21:17:55 <kawfee> twat?
21:18:11 <kawfee> if I compare N items the number of bits I return as the result has nothing to do with it
21:18:20 <faxathisia> You're confused
21:18:22 <gwern> @pl showCmd fp args = fp ++ " " ++ show args
21:18:22 <lambdabot> showCmd = (. ((' ' :) . show)) . (++)
21:18:22 <kawfee> Big Oh is a complexity regardless of the language
21:18:27 <kawfee> am not
21:18:43 <kawfee> Big Oh is theoretically based, not based on bits
21:18:52 <faxathisia> kawfee: Yes you are :)
21:18:56 <Pseudonym> Yeah, you are.
21:18:57 <kawfee> what kind of crack pot university did you guys go to?
21:19:00 <Pseudonym> Or I'm not being clear.
21:19:05 <kawfee> no, you aren't
21:19:08 <faxathisia> I understand you Pseudonym..
21:19:10 <kawfee> I think I know what you are talking about.
21:19:19 <kawfee> I have heard this proof before
21:19:22 <kawfee> I think
21:19:23 <gwern> not so sure. there's a reason knuth went to all the trouble of specifying a particular machine for TAOCP
21:19:39 <kawfee> where's the proof?
21:19:43 <kawfee> let me look at it again
21:20:08 <davidL> speaking of TAOCP, /me grabs the 3rd book
21:20:11 <mgsloan> well, quantum computers, yada yada yada
21:20:35 <mgsloan> any recommendations w.r.t TAOCP?  I don't have any of them
21:20:43 <TSC> http://en.wikipedia.org/wiki/Comparison_sort#Number_of_comparisons_required_to_sort_a_list
21:20:43 <lambdabot> http://tinyurl.com/y4ft3x
21:21:59 <sorear> gwern: well... mmix cannot address more than 2^64 bytes of memory, so everything is O(1)
21:21:59 <gwern> mgsloan: wait, I would guess. knuth can't have all *that* many decades left, and when he kicks the bucket, you'll be able to get a definitive edition :)
21:22:06 <kawfee> nah
21:22:08 <mgsloan> haha
21:22:08 <kawfee> I want the proofg
21:22:20 <sorear> need a non"compact" space to get real O()
21:22:23 <TSC> kawfee: The basic argument is there
21:22:23 <mgsloan> yeah, the upcoming TAOCP books sound more exciting than the current ones
21:22:28 <Pseudonym> Yeah.
21:22:31 <Pseudonym> The key statement being:
21:22:40 <Pseudonym> "The sort algorithm must gain enough information from the comparisons to identify the correct permutations."
21:22:46 <Pseudonym> Though I think that last word shouldn't be a plural.
21:22:47 <kawfee> hrm
21:22:48 <faxathisia> yeah it's quite simple
21:22:49 <mgsloan> I mean, to tell you the truth I find sorting to be rather dull
21:22:53 <kawfee> yeah, I want to see the mathematical proog
21:22:54 <kawfee> proof
21:22:56 <faxathisia> Just think about why you don't need O(n^2) bits
21:23:05 <faxathisia> kawfee: Come up with a proof yourself, you'll understand it better
21:23:11 <kawfee> lulz
21:23:16 <kawfee> Why reinvent the wheel?
21:23:25 <TSC> Why learn anything?
21:23:26 <gwern> (I mean, the dude is like 69! he's just about at his average life expectancy point for an old american white male)
21:23:26 <kawfee> I think you guys misunderstand
21:23:33 <Pseudonym> Because inventing algorithmic information theory from scratch is fun!
21:23:43 <kawfee> yeah, I have done it all before
21:24:00 <kawfee> ok whatever
21:24:03 <kawfee> since you can'
21:24:09 <kawfee> since you can't prove it then I don't believe you
21:24:12 <kawfee> QED
21:24:16 <mgsloan> lol
21:24:17 <Pseudonym> OK, don't believe me.
21:24:28 <kawfee> I wont
21:24:28 <Pseudonym> Implement an O(n) sort using only binary comparisons.  See if I care.
21:24:34 <kawfee> I know the proof you are talking about
21:24:37 <kawfee> bits has nothing to do with it
21:24:41 <faxathisia> Pseudonym: I don't believe you ":p
21:24:46 <faxathisia> I can just fill the gaps though
21:24:50 <kawfee> it defies the purpose of Big Oh
21:24:53 <faxathisia> so I agree with what you've said
21:24:54 <TSC> ...
21:24:57 <Pseudonym> :-)
21:25:00 <kawfee> well, you shouldn't believe him
21:25:18 <kawfee> if he is mathematically incompetent then how will you know he is right?
21:25:32 <Pseudonym> It's on Wikipedia!
21:25:41 <Pseudonym> Who cares about me?  IT'S ON WIKIPEDIA!
21:25:44 <SamB_XP> hah!
21:25:45 <Pseudonym> It must be true!
21:25:59 <TSC> It's peer reviewed
21:26:01 <SamB_XP> #zsnes disagrees!
21:26:14 <Pseudonym> See, it says right here.
21:26:19 <kawfee> alright, so let me understand
21:26:29 <kawfee> you say Big Oh is dependant on bits of the return value?
21:26:30 <Pseudonym> The Shannon entropy of a random permutation is log2(n!) bits and *ERIC IS A FAG*.
21:26:38 <kawfee> Yet you use it to determine complexity of haskell?
21:26:43 <kawfee> how odd
21:26:43 <faxathisia> o_o
21:26:48 <TSC> Where to begin with that statement?
21:26:52 <Pseudonym> Yeah.
21:26:55 <SamB_XP> kawfee: what are you trying to say?
21:27:12 <TSC> kawfee: The bits argument is just a way to figure out how many comparisons you need
21:27:18 <Pseudonym> Right.
21:27:28 <Pseudonym> Because each comparison gives one bit of information at the most.
21:27:34 <TSC> I think of it without the bits
21:27:35 <kawfee> ok, , I am down with that
21:27:40 <kawfee> but he specifically said return value
21:27:41 <TSC> There are n! permutations
21:27:45 <kawfee> RETURN value
21:27:48 <TSC> Each comparison rules half of them out
21:27:48 <kawfee> sure
21:27:54 <kawfee> right
21:27:58 <TSC> Therefore, you need log(n!) of them
21:27:59 <kawfee> you split in half everytime
21:28:01 <kawfee> of course
21:28:10 <kawfee> very simple
21:28:11 <TSC> So you n log n, thanks to Stirling
21:28:17 <kawfee> sure
21:28:25 <kawfee> I know all this
21:28:30 <TSC> I'm sure you do
21:28:32 <kawfee> He said return value though
21:28:42 <kawfee> he said the number of bits in the return value mattered
21:29:02 <TSC> All Pseudonym said is that a Bool gives one bit of information
21:29:05 * Pseudonym scrolls up to see what I said
21:29:06 <kawfee> yes
21:29:12 <kawfee> let me get a quote
21:29:51 <kawfee> 23:18 < kawfee> if I compare N items the number of bits I return as the result  has nothing to do with it
21:29:55 <kawfee> 23:18 < faxathisia> You're confused
21:29:59 <kawfee> 23:18 < faxathisia> kawfee: Yes you are :)
21:29:59 <kawfee> 23:18 < Pseudonym> Yeah, you are.
21:30:04 <kawfee> that is what was said
21:30:14 <kawfee> and what you said
21:30:27 <kawfee> and as I said the number of bits RETURNED has nothing to do with it
21:30:28 <Pseudonym> That was in response to something.
21:30:29 <faxathisia> kawfee: You've mixed/cut out events in your paste
21:30:33 <kawfee> hrm
21:30:44 <kawfee> well then, I guess we both are confused, heh
21:30:53 <kawfee> cause I thought you were talking about the number of bits returned
21:30:55 <kawfee> sorry guys
21:30:57 <davidL> probably not as confused as I am
21:31:01 <kawfee> lulz
21:31:02 <faxathisia> kawfee: "we"?
21:31:06 <kawfee> I apologize then
21:31:11 <SamB_XP> yeah, well, sith happens...
21:31:17 <kawfee> faxathisia: yes, we
21:31:26 <faxathisia> kawfee: Which "we"?
21:31:26 <Pseudonym> No apology needed, all friends now.
21:31:28 <Pseudonym> @grouphug
21:31:28 <lambdabot> Unknown command, try @list
21:31:37 <kawfee> I said bits and you said I was confused
21:31:59 <kawfee> You tell me where I was wrong then?
21:32:04 <kawfee> and how I was confused
21:32:08 <kawfee> everything I said was fact
21:32:21 <kawfee> and if it wasn't then I would like to know
21:34:47 * kawfee drops a pin
21:35:51 <dons> ?yow
21:35:51 <lambdabot> Don't SANFORIZE me!!
21:35:59 <dropdrive> Does scanl (+) 0 [1..] !! 1000000 cause a stack overflow because + isn't strict?
21:36:51 <mgsloan> perhaps you mean foldl?
21:36:54 <SamB_XP> dropdrive: I think it's because scanl isn't strict
21:37:32 <mgsloan> ah, nevermind
21:38:32 <dropdrive> SamB_XP: Okay.  Is there a strict version of scanl?
21:38:47 <SamB_XP> if there is, it's called scanl'
21:38:52 <jbalint> hi
21:41:48 <sorear> hello!
21:42:00 <BMeph> Hey there, all. :)
21:42:13 <lambdabot> Hi!
21:42:29 <BMeph> @quote kitten
21:42:29 <lambdabot> rici says: "i.e. if someone offers you kittens for dinner, you can practice not being offended."
21:43:27 <dropdrive> SamB_XP: I don't there is.
21:43:31 <kawfee> hi
21:43:41 <kawfee> Hey there, all. :)
21:43:47 <kawfee> hrm
21:44:08 <BMeph> ...how original. ;p
21:48:19 <dxdt> Is it possible in GHCi to define a function and evaluate something at that function in the same line?  Like let let f a = 4+a; f 4
21:48:47 <mrd> let .. in
21:49:03 <mrd> which is the usual syntax
21:49:53 <dxdt> I see.  I hadn't come across that, yet, in the tutorials.  Thanks!
21:50:43 <dons> > let f a = 4+a in f 2
21:50:48 <andyjgill> dons: I've just emailed you the parallel example for computing pi
21:50:59 <lambdabot>  thread killed
21:51:01 <dons> ah, got it.
21:51:02 <dons> > let f a = 4+a in f 2
21:51:06 <lambdabot>  6
21:51:15 <dons> these virtual hosts can be slow sometimes
21:51:26 <dons> mm, looks like it shouldn't be too hard, andyjgill
21:51:57 <darrint> How do I break apart a tuple in a do block?
21:51:57 <dons> what's this "import Debug.Trace" in there, eh? ;)
21:52:01 <andyjgill> It might be too much of a micro-benchmark, though too many pars
21:52:06 <dons> darrint: do (x,y) <- foo
21:52:10 <BMeph> Just curious - I asked earlier, but heard no reply: has anyone tried building Hoogle since GHC 6.8 came out?
21:52:17 <darrint> thanks.
21:52:20 <andyjgill> err. debugging?
21:52:30 <davidL> dons: how bad really is openbsd's scheduler? the times went up exponentially when I increased the number of cores (maybe I was doing something wrong)
21:52:55 <andyjgill> :-) In turned out that the bug was the interpreter's speed.
21:52:56 <dons> davidL: i couldn't get it to reliably use two cores, it would shuffle jobs onto the second core, then move them straight back to the first.
21:53:04 <dons> so works was pretty much only done on 1
21:53:12 <dons> davidL: keep a window with top open
21:53:17 <dons> and seen if anything gets run on the other cores
21:53:23 <dons> andyjgill: hehe
21:53:23 <davidL> ah yeah
21:53:43 <dons> andyjgill: but it seems like we can use the same trick as the recursive fibonacci
21:53:47 <dons> `par` up to a cutoff
21:54:02 <dons> then use a non-sparking strategy after
21:54:21 <dons> davidL: i couldn't find anything about this either, online.
21:54:34 <dons> is possible people aren't writing smp code for openbsd?
21:58:05 <davidL> CPU1 states: 0.0%, CPU2 states: 0.0%, CPU3 states: 0.0% with -N4 :-(
21:58:48 <davidL> ...CPU0 states: 100%
22:00:02 <newsham> ?seen dcoutts
22:00:02 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 17h 23m 15s ago.
22:07:09 <dons> davidL: yeah :( need a new OS.
22:10:19 <thetallguy> > reverse "reverse"
22:10:23 <lambdabot>  "esrever"
22:10:44 <thetallguy> > reverse "esrever"
22:10:45 <lambdabot>  "reverse"
22:11:02 <davidL> I wonder how freebsd handles smp
22:11:37 <thetallguy> > reverse "persevere"
22:11:38 <lambdabot>  "erevesrep"
22:12:52 <newsham> > reverse "desserts"
22:12:53 <lambdabot>  "stressed"
22:13:07 <davidL> heh
22:13:33 <goalieca> reserve "i'm home early"
22:13:37 <goalieca> > reserve "i'm home early"
22:13:38 <lambdabot>   Not in scope: `reserve'
22:13:43 <goalieca> bah.
22:14:37 <davidL> > reverse "i'm home early"
22:14:38 <lambdabot>  "ylrae emoh m'i"
22:15:12 <goalieca> rever "not laid"
22:15:15 <goalieca> > reverse "not laid"
22:15:18 <lambdabot>  "dial ton"
22:15:24 <goalieca> reverse ":("
22:15:27 <goalieca> > reverse ":("
22:15:28 <lambdabot>  "(:"
22:15:31 <goalieca> :)
22:15:46 <goalieca> dial tone is close enough :P
22:16:01 <davidL> > reverse ":-(((("
22:16:06 <newsham> > let ess = map toLower . filter isAlpha in ess "eva, can I pose as aesop in a cave?"
22:16:08 <Pseudonym> > reverse "a man, a plan, a canal, panama"
22:16:09 <lambdabot>  "((((-:"
22:16:09 <lambdabot>  "amanap ,lanac a ,nalp a ,nam a"
22:16:09 <lambdabot>  "evacaniposeasaesopinacave"
22:16:52 <newsham> > let ess = map toLower . filter isAlpha; palin x = essense x == reverse (essense x) in palindrome "eva, can I pose as aesop in a cave?"
22:17:00 <lambdabot>   Not in scope: `palindrome'
22:17:05 <davidL> > reverse "racecar"
22:17:06 <newsham> > let ess = map toLower . filter isAlpha; palin x = essense x == reverse (essense x) in palin "eva, can I pose as aesop in a cave?"
22:17:09 <lambdabot>   Not in scope: `essense'
22:17:10 <lambdabot>  "racecar"
22:17:22 <newsham> > let ess = map toLower . filter isAlpha; palin x = ess x == reverse (ess x) in palin "eva, can I pose as aesop in a cave?"
22:17:22 <lambdabot>  True
22:17:33 <goalieca> > reverse "astie d'calisse d'crisse d'tabarnac d'astie d'calvaire"
22:17:35 <lambdabot>  "eriavlac'd eitsa'd canrabat'd essirc'd essilac'd eitsa"
22:18:35 <sorear> gwern: you're too late
22:20:15 <oerjan> > join((==).reverse).map toLower.filter isAlpha$"eva, can I pose as aesop in a cave?"
22:20:28 <lambdabot>  True
22:25:49 <Pseudonym> :t join ((==).reverse)
22:25:52 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
22:26:02 <mgsloan> :t join
22:26:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:26:21 <Pseudonym> > join ((==).reverse) "hello"
22:26:36 <lambdabot>  thread killed
22:26:37 <Pseudonym> > join ((==).reverse) "f00f"
22:26:44 <Pseudonym> ...
22:26:48 <lambdabot>  True
22:26:52 <Pseudonym> > join ((==).reverse) "hello"
22:26:54 <lambdabot>  False
22:27:01 <Pseudonym> Cool idiom!
22:27:06 <davidL> nice
22:27:14 <Pseudonym> :t \f -> join ((==).f)
22:27:16 <lambdabot> forall b. (Eq b) => (b -> b) -> b -> Bool
22:28:02 <Pseudonym> ?pl \f -> join ((==).f)
22:28:02 <lambdabot> ((==) =<<)
22:28:07 <Pseudonym> Ooh!
22:28:20 <Pseudonym> > ((==) =<<) reverse "f00f"
22:28:21 <mgsloan> lol
22:28:23 <oerjan> ooh indeed
22:28:25 <lambdabot>  True
22:28:28 <Pseudonym> Damn.
22:29:19 <Pseudonym> > ((==)=<<reverse) "f00f"
22:29:22 <lambdabot>  True
22:29:42 <oerjan> > (=<<)(==)reverse"f00f"
22:29:42 <lambdabot>  True
22:29:51 <mgsloan> > (reverse >>= (==)) "f00f"
22:29:52 <lambdabot>  True
22:30:39 <Pseudonym> ?check \xs -> (reverse >>= (==)) xs == (xs == reverse xs)
22:30:49 <lambdabot>  Add a type signature
22:30:56 <Pseudonym> ?check \xs::String -> (reverse >>= (==)) xs == (xs == reverse xs)
22:30:56 <lambdabot>  Parse error at "::Str..." (column 4)
22:31:08 <Pseudonym> ?check \xs -> (reverse >>= (==)) (xs::String) == (xs == reverse xs)
22:31:10 <lambdabot>  OK, passed 500 tests.
22:31:21 <Pseudonym> :t \xs -> xs == reverse xs
22:31:22 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
22:31:27 <Pseudonym> :pl \xs -> xs == reverse xs
22:31:31 <Pseudonym> ?pl \xs -> xs == reverse xs
22:31:31 <lambdabot> ap (==) reverse
22:31:39 <Pseudonym> ?pl \xs -> reverse xs == xs
22:31:39 <lambdabot> (==) =<< reverse
22:31:53 <Pseudonym> ?pl \xs -> f xs == g xs
22:31:54 <lambdabot> liftM2 (==) f g
22:33:38 <faxathisia> @unpl (reverse >>= (==))
22:33:38 <lambdabot> (reverse >>= (==))
22:37:29 <Shimei> Anyone read http://people.cs.uu.nl/jeroen/article/algebra/index.html? I thought there might be an error on the first page of 3.3 where it says "Zero <*> y = y" which doesn't seem right.
22:37:29 <lambdabot> Title: Explaining algebraic theory with functional programs
22:37:54 <Shimei> Seems like that should be "Zero <*> y = 0" unless Rngs work differently than I'm thinking.
22:38:00 <Shimei> Err. s/0/Zero/
22:39:09 <jdrake> Q: What exactly is the difference between a FilePath and a String, when examples seem to show no distinction between them. For example splitExtension "file.txt"
22:40:14 * Pseudonym is still marvelling at how subtle ((==)=<<) is
22:40:28 <newsham> type FilePath = String
22:40:32 <newsham> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Prelude.html#t%3AFilePath
22:40:33 <lambdabot> http://tinyurl.com/yqz9gj
22:41:49 <jdrake> In here: http://haskell.org/ghc/docs/latest/html/libraries/filepath-1.1.0.0/System-FilePath-Windows.html  Shouldn't links to the type 'FilePath' lead to a type definition?
22:41:49 <lambdabot> http://tinyurl.com/2klksq
22:42:57 <jdrake> Also, with 'type FilePath = String' does that mean I can use it as a String?
22:43:44 <Pseudonym> :t (=<<)(==)
22:43:46 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
22:43:56 <Pseudonym> ?free f :: (a -> a -> Bool) -> (a -> a) -> a -> Bool
22:43:56 <lambdabot> (forall x. h x = k (g x) . g) => g . p = q . g => f h p = f k q . g
22:44:39 <gwern> anyone know how to convert a CChar to a Word8? as far as I can tell, they should be the same thing, but they just aren't gelling for me
22:44:57 <quicksilver> gwern: fromIntegral
22:45:14 <newsham> > map toLower ("/foo/Bar/Blah" :: FilePath)
22:45:15 <goalieca> gwern, convert or cast
22:45:18 <gwern> ... that's unexpected
22:45:19 <sorear> gwern:
22:45:21 <sorear> Mon Oct  8 06:04:04 PDT 2007  Josef Svenningsson <josef.svenningsson@gmail.com> * Update build-depends to work with ghc-6.8
22:45:21 <lambdabot>  "/foo/bar/blah"
22:45:30 <newsham> ?type toLower
22:45:31 <lambdabot> Char -> Char
22:45:39 <quicksilver> gwern: fromIntegral is a generic cast between numeric types
22:45:47 <quicksilver> gwern: erm, integer numeric types :)
22:46:01 <gwern> sorear: hm. just as well. I only got my email and darcs send working again tonight
22:46:08 <quicksilver> gwern: more generally, from an integer type to a not-necessarily-integer one.
22:46:14 <gwern> quicksilver: yes, I'm just surprised that a CChar and a Word8 are both numeric types
22:46:22 <quicksilver> well Word8 definitely is
22:46:26 <quicksilver> I'm not sure about CChar
22:46:28 <quicksilver> but I guess it is
22:46:33 <wli> chr . fromIntegral . ord ?
22:46:48 <quicksilver> wli: CChar not Char
22:47:28 <quicksilver> yeah, CChar is Integral.
22:47:54 <oerjan> n_1*n_2*...*n_k gives (n_1+1)*...*(n_k+1) subcubes
22:48:00 <oerjan> wrong channel
22:52:12 <jdrake> I have a function that recurses through a list, printing its items. At the very end, what is the correct way to tell it to literally do nothing? The type still has to be IO() I believe.
22:52:41 <gwern> return ()?
22:53:11 <gwern> recursing through a list while printing... sounds like a job for mapM_, incidentally
22:53:23 <jdrake> Is do () valid?
22:53:50 <jdrake> Apparently it isn't
22:54:10 <gwern> do return (), I sort of meant
22:54:27 <jdrake> oh ok.
22:54:36 <jdrake> Keep in mind that I am very green.
22:55:08 <faxathisia> :t return () :: IO ()
22:55:19 <lambdabot> IO ()
22:55:23 <faxathisia> :t do return () :: IO ()
22:55:28 <lambdabot> IO ()
22:56:08 <quicksilver> jdrake: this is what mapM_ does, by the way
22:56:19 <quicksilver> jdrake: but, it may be instructive to write the recursion yourself :)
22:56:35 <jdrake> I think for now I will do it recursively for now.
22:56:36 <quicksilver> jdrake: no need for 'do return ()', 'return ()' is the same thing.
22:57:06 <quicksilver> print_all (x:xs) = do {print x; print_all xs} ; print_all [] = return ()
22:57:13 <quicksilver> ^^ someting like that, I imagine
22:57:49 <jdrake> I found that the gentle introduction to haskell is not for me - beyond helping with syntax a little bit. I remember a bit from my last shot, but I did monad stuff right off the bat this time without a real problem.
22:58:19 <quicksilver> one approach to monad stuff is just to follow a few examples and get a feel for it and not worry too much about what it means
22:58:31 <jdrake> yes
22:58:34 <oerjan> @quote gentle
22:58:34 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
22:58:36 <quicksilver> I think that's quite a good approach, but the error messages you get when it goes wrong may be confusing :)
22:59:01 <oerjan> @quote gentle
22:59:01 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
22:59:12 <hpaste>  jdrake pasted "ls" at http://hpaste.org/4159
22:59:28 <jdrake> That is what my thing looks like.
23:00:26 <glguy> printFiles = mapM_ putStrLn
23:00:29 <jdrake> quicksilver: I don't know if you were around a week ago, but I was talking about erlang then. Erlang is just cryptic, these errors were nice.
23:00:43 <quicksilver> jdrake: looks good to me :)
23:01:02 <quicksilver> I've read about erlang and seen code, but I've never written it so I've not experienced erlang errors...
23:01:22 <jdrake> glguy: I will definitely put that as a marker in there, but I want to keep it as it is until I do more.
23:01:30 <jdrake> glguy: I love the hpaste btw!
23:01:30 <quicksilver> that's very sensible
23:01:47 <jdrake> It is so simple in appearance, yet monadically attractive.
23:01:47 <glguy> glad you find it useful :)
23:01:49 <quicksilver> once you've written that pattern by hand a couple of times, you appreciate why is has a name.
23:02:00 <quicksilver> (mapM_, I mean)
23:02:07 <quicksilver> it's also interesting to note that
23:02:22 <quicksilver> printFiles files = sequence (map putStrLn files)
23:02:31 <quicksilver> just to get a feeling for what map and sequence mean
23:03:40 <jdrake> hmm
23:03:53 <jdrake> Let me look over tihs once more thne.
23:04:13 <quicksilver> hmm, I actualy meant sequence_ not sequence.
23:04:20 <quicksilver> although in practice it wouldn't matter much.
23:07:02 <jdrake> Ok, I am not seeing a real difference between your sequence list there and a plain do mapM_ putStrLn xs
23:13:10 <gwern> anyone know whether the support@community.haskell.org email address works? my emails to it seem to be getting bounced
23:28:30 <fourbissime> hi there. i'm trying to compile Yi-0.2 on a gentoo computer, using gentoo-portage tree. unfortunately there is a problem with the Setup.hs file. it doesn't find the function compilerPath within anything imported. I have cabal-1.2.2.0 installed. hoogle tells me it is supposed to be within Distribution.Setup but you know how out of date it can be sometimes ...
23:30:41 <quicksilver> jdrake: there isn't a different at all
23:30:50 <quicksilver> jdrake: mapM_ is defined using sequence_ and map
23:30:55 <quicksilver> too slow.
23:32:28 <fourbissime> any clue on where I should find compilerPath is wellcomed - I'll be away the next few hours but I'll check it back later.
23:43:06 <Lemmih> fourbissime: I'm not sure yi is buildable anymore.
