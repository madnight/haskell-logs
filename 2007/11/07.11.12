00:05:12 <shachaf> Cale: Should (.) be infixr or infixl then?
00:06:15 <quicksilver> left
00:06:34 <quicksilver> althoguh in fact its associative
00:06:41 <quicksilver> even when applied at different types
00:06:46 <quicksilver> which is a neat fact
00:09:06 <scodil> anyone know what the interaction is between inlining and unboxing? If I use INLINE pragmas, it boxes my otherwise unboxed data, which seems counter intuitive.
00:09:54 <quicksilver> functions can't have unboxed return types
00:10:11 <quicksilver> so a transformation which transforms something into areturn type might box it
00:10:12 <quicksilver> AIUI
00:10:26 <quicksilver> I don't understand it in much detail though :)
00:12:36 <shachaf> quicksilver: Really? For different Functors?
00:15:11 <Elifant> Is there reason for catchError from MonadError having type (m a -> (e -> m a) -> m a) and not (MonadError m1 => m a -> (e -> m1 a) -> m1 a). I can't catch exception and convert it to another one because of this.
00:21:38 <quicksilver> shachaf: yes. surprising but true. One of the things which supports Cale's view that it's a asensible thing to do.
00:22:14 <quicksilver> Elifant: I *think* that's because type inference would be hard, and m1 would end up needing an explicit annotation most of the time.
00:23:18 <quicksilver> Elifant: normally the idiom would be to use a suffciently general error type which can encompass all possibilities?
00:24:34 <Elifant> I have separate exception type for each program layer. When lower layer raises error, I wrap it to exception of next layer.
00:25:17 <Elifant> I can do this with every concrete instance of MonadError, e.g. Either, but not with MonadError class generally
00:27:25 <ski> `MonadError m1 => m a -> (e -> m1 a) -> m1 a' wouldn't work, `m' would need to be embedded in `m1' somehow
00:27:47 <ski> (assuming `forall m m1. Monad m => ')
00:28:42 <Elifant> hm... I'll now try to write my own MonadError class with catchError having suggested signature...
00:28:59 <ski> well, i suppose `m' without errors would have to be embedded in `m1', at least
00:29:44 <ski> Elifant : are you saying `m' has some kind of exceptions, and `m1' another kind ?
00:30:09 <Elifant> 'm' and 'm1' are instances of MonadError
00:30:22 <ski> how are they related to each other ?
00:30:34 <ski> (they must be related, for the above to work)
00:30:37 <Elifant> there is no relation
00:31:08 <Elifant> I don't think they need to be related
00:31:43 <ski> you can't run an action of type `m a' in any monad `m' (with some kind of exceptions) and just expect the arbitrary other (non-exception) effects from `m' to just disappear, instead of being embedded into `m1'
00:31:49 <ski> e.g.
00:32:16 <ski> consider `m = ErrorT String IO' and `m1 = Error MyErrorType'
00:32:28 <Elifant> but 'm a' carries value of type 'a', and 'm1 a' do
00:32:46 <ski> what are you going to do about the `IO'-effects of the first argument of type `m a' ?
00:32:58 <Elifant> so if aciton is executed without errors, I just take value and wrap it to 'm1'
00:33:20 <ski> `m a' carries *effectful* computations (of the `m' sort) *returning* values of type `a'
00:34:23 <Elifant> in catchError both 'm' and 'm1' are parametrised with the same type 'a'
00:34:40 <ski> `MonadError e m' isn't just allowed to perform exception effects, it can also perform more or less any other kinf of effects, as well
00:35:05 <ski> the point is not `a' .. `a' is just the type of the return value
00:35:38 <ski> the point is that `m' must not be simply `Error Foo' or something similar, it can contain arbitrary other monadic effects
00:36:02 <ski> s/must not/doesn't have to/
00:36:31 <quicksilver> yes.
00:36:57 <ski> in particular, `m' can contain `IO'-effects (it doen't need to, but it can), and `m1' doesn't need to contain `IO'-effects
00:36:58 <quicksilver> if there were both of the form ErrorT _ m, over the same mnad m
00:37:01 <quicksilver> then it would make sense
00:38:28 <Elifant> Well, I don't understand this... IO effects can be discarded as anything else until they are returned by 'main'. I think I will understand problem when I'll try to implement this myself...
00:38:46 <ski> `IO' effects can't be discarded at all
00:38:55 <ski> `IO' *actions* can be discarded
00:39:05 <ski> if you want
00:39:12 <Elifant> yes, this is what I mean
00:39:34 <ski> foo :: forall m m1 e. (Monad m,MonadError e m1) => m a -> (e -> m1 a) -> m1 a
00:39:56 <ski> then `m a' has to discard its first argument, of type `m a'
00:41:04 <ski> because `m' *can* include (*e.g.*) `IO', then you must in such cases ensure `m1' also will include `IO' (but you don't in the given type signature)
00:41:26 <ski> hence i say you must relate `m' and `m1' in some way
00:41:29 <Elifant> foo :: (MonadError e0 m0, MonadError e1 m1) => m0 a -> (e0 -> m1 a) -> m1 a
00:41:45 <ski> that's not any better
00:42:40 <ski> `MonadError e0 m0' basically is `Monad m0' plus a few operations returning stuff of form `m0 (...)', i,e, in the *`m0'* monad, still
00:43:22 <ski> if you want to replace the error type `e0' by an error type `e1', then you must ensure all the other arbitrary effects are preserved from `m0', to `m1'
00:43:51 <ski> this may well be possible, mind, but not only with the current design of `MonadError'
00:44:57 <ski> btw, in which particular case are you trying to apply this ?
00:45:09 <ski> maybe you don't actually need something as general as this, here ?
00:45:58 <ski> i.e., do you only actually intend to use this with monads of form `Error (...)' or form `ErrorT (...) (...)' ?
00:46:11 <Elifant> well, now I use Either through out program, so I can't convert exception type. I was just interested how to do this more generically
00:46:33 <Elifant> s/can't/can/
00:46:57 <ski> (or even something like `StateT Blah (ErrorT Bleh Bluh)', as long as you don't have to much, and varying, things atop the `Error'/`ErrorT' application)
00:48:15 <ski> hm
00:48:22 <ski> @hoogle mapState
00:48:23 <lambdabot> Control.Monad.State.mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
00:48:23 <lambdabot> Control.Monad.State.mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
00:48:28 <ski> @hoogle mapError
00:48:29 <lambdabot> Control.Monad.Error.mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
00:49:05 <ski> have you tried using `mapErrorT' ?
00:49:23 <Elifant> no. thanks, I'll try
00:50:26 <ski> possibly the simplest, in you case (iiuc), woould be to try something like `mapErrorT (liftM (...))'
00:51:16 <ski> @type \f -> Control.Monad.Error.mapErrorT (liftM (either (Left . f) Right))
00:51:17 <lambdabot> forall b e a (m :: * -> *). (Monad m) => (e -> b) -> ErrorT e m a -> ErrorT b m a
00:51:35 <ski> (s/you case/your case/)
00:51:56 <Elifant> cool
00:52:21 * ski gotta run
01:25:18 <quicksilver> :t mapErrorT
01:25:21 <lambdabot> forall (m :: * -> *) e a (n :: * -> *) e' b. (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
02:06:12 <salierix> How can I pass a new StdGen to a function used by map for each element?
02:07:27 <scook0> hmm
02:08:20 <scook0> if you obtained a list of new StdGens, you could use zipWith instead of map
02:09:00 <scook0> alternatively, you could use mapM, and a variant of your function that generates a new StdGen for itself inside the monad
02:09:07 <scook0> (if that makes any sense)
02:09:24 <salierix> Yeah.
02:11:11 <Bacta> How can I add to a list and have the changes stick?
02:11:29 <scook0> Bacta: uh, what are you trying to do?
02:11:34 <Bacta> myList = ["sword"]
02:11:34 <Bacta> addItem = myList = myList ++ ["key"]
02:11:38 <Bacta> no wait
02:11:45 <salierix> Lists are immutable
02:11:46 <Bacta> myList = ["sword"]
02:11:46 <Bacta> addItem = myList ++ ["key"]
02:11:57 <sjanssen> *everything* is immutable
02:11:58 <Bacta> how can I add to it?
02:12:07 <salierix> Good point.
02:12:07 <Bacta> I know :P but surely there must be a way to do what I want to achieve
02:12:20 <sjanssen> Bacta: you can not change an existing list, you can create a new list with an additional element
02:12:35 <Bacta> and then what can I do to it so it "saves"?
02:12:45 <Bacta> I'm coming from an imperative background here
02:12:53 <quicksilver> Bacta: you pass the new value to the next function.
02:13:14 <Bacta> how can you do ANYTHING in a language like this :P
02:13:17 <quicksilver> salierix: you could use monad Random and use mapM
02:13:47 <salierix> quicksilver, there is a Random monad?
02:14:02 <opqdonut> yes
02:14:08 <quicksilver> salierix: on the wiki there is
02:14:08 <opqdonut> see the wiki
02:14:17 <quicksilver> salierix: its sole purpose is to thread RandomGens
02:14:21 <quicksilver> (Which is what you want here)
02:14:34 <salierix> Cool, I'll check it out.
02:19:15 <Bacta> why does Haskell let me calculate 1024! ?
02:19:32 <sjanssen> Bacta: why wouldn't it?
02:19:40 <sjanssen> > product [1..1024]
02:19:42 <lambdabot>  5418528796058857283076921944683854738001553963538013444482870270683210612073...
02:19:48 <Bacta> wouldn't I get overflow?
02:20:03 <Vq^> Bacta: what would overflow?
02:20:06 <quicksilver> Bacta: your computer probably has quite a few MB of memory
02:20:08 <sjanssen> Bacta: nope, the default number type is arbitrary precision
02:20:09 <Bacta> I couldn't do that in Java
02:20:10 <Vq^> Bacta: what type are you using?
02:20:13 <quicksilver> maybe even a GB or two
02:20:22 <quicksilver> it's unlikely 1024! will overflow that :)
02:20:42 <sjanssen> Bacta: a better question is why Java won't let you calculate 1024! :)
02:20:46 <Vq^> quicksilver: depends on the method of representing numbers :o)
02:20:52 <Bacta> 10000! works
02:20:57 <quicksilver> Java will, in fact
02:21:03 <scook0> > product [1..1024] :: Int
02:21:04 <Bacta> Java will if I use BigInt
02:21:06 <lambdabot>  0
02:21:09 <quicksilver> right
02:21:10 <scook0> \o/
02:21:31 <quicksilver> well haskell uses a BigInt-style type by default
02:21:32 <Vq^> BigInt == Integer ?
02:21:47 <Bacta> yes
02:23:06 <Vq^> Bacta: do you want a failure?
02:23:22 <Bacta> ?
02:23:34 <Vq^> Bacta: do you want the calculation to fail
02:23:54 <Bacta> give me one
02:24:01 <Vq^> Bacta: in that case maybe you should try to force the type to Int
02:24:07 <Bacta> no
02:24:11 <Bacta> I'm going to try 1 000 000
02:24:26 <Bacta> ok that overflows :P
02:24:56 <sjanssen> > product [1 .. 1000000]
02:25:02 <lambdabot> Terminated
02:25:44 <Bacta> ;)
02:25:51 <fasta> Bacta: ?
02:25:57 <Bacta> yes sah
02:26:08 <fasta> What overflows?
02:26:32 <sjanssen> Bacta: the "*** Exception: stack overflow" is different from numeric overflow
02:27:18 <Bacta> well all I wanted to do was push it
02:27:25 <Bacta> I don't care if it overflows numerically or stack
02:27:41 <quicksilver> if you compile it with -O2 that won't stack overflow
02:27:53 <quicksilver> you'll never get a numeric overflow, per se
02:27:53 <Bacta> well I'll give it some more stack space
02:27:59 <quicksilver> you'll just eventually run out of memory
02:28:21 <quicksilver> although things wil porbably get quite slow beofre you run out of memory, I suspect
02:28:58 <Bacta> well I gave it 300 megs
02:29:06 <Bacta> and it still has a stack overflow with 1 000 000
02:30:26 <salierix> What are you trying to do?
02:31:06 <Bacta> break it
02:31:15 <sjanssen> Bacta: compile with ghc -O2
02:31:22 <quicksilver> Bacta: compile with -O2 then it won't be wasting stack space
02:31:53 <fasta> I have a FooMonadT, with an accompanying class MonadFoo. I also have a class CounterStateT, but whenever I run runCounterStateT (someOperationOfMonadFoo>> return 2) it doesn't reduce the context, because runCounterStateT doesn't have a MonadFoo instance. I could add a "deriving MonadFoo" to the definition, but that doesn't look perfect either. Is there a solution to this problem? (Is this the O(n^2) problem?)
02:32:27 <quicksilver> fasta: if I understand you, yes, that's the n^2 problem
02:32:38 <fasta> Bacta: there's one major weakness in GHC and that is that one can run out of stack and heap separately.
02:32:40 <quicksilver> fasta: you need to manually defining the lifting instances through each pair of transformers
02:33:28 <fasta> quicksilver: hmm, that's not what I mean, I think.
02:34:09 <quicksilver> fasta: Well, more rprecisly for each transformer, and each class, you have to defining a lifting instance if that class commutes up through that transformer
02:34:17 <fasta> quicksilver: you mean for each pair of transformer and accompnaying class?
02:34:20 <quicksilver> which, it does, for most sensible classes and transformers
02:34:26 <quicksilver> yes, that is what I should ahve said :)
02:34:41 <fasta> quicksilver: I just like being precise :)
02:34:59 <sjanssen> O(classes * transformers)
02:35:06 <quicksilver> of course, some instances are deliberately omitted
02:35:14 <quicksilver> as someone sensibly pointed out to me last week
02:35:26 <quicksilver> MonadState doesn't lift through StateT
02:35:38 <quicksilver> which means that MonadState always attaches to the 'outermost' state
02:35:41 <sjanssen> it can't due to the functional dependency
02:35:53 <quicksilver> right.
02:36:10 <Bacta> is there a way to get back a true or false if a num is divisible by another?
02:36:14 <fasta> Are you sure it's the outermost?
02:36:26 <sjanssen> yes
02:36:33 <mauke> Bacta: a `mod` b == 0
02:36:33 <quicksilver> fasta: StateT a (StateT b IO) is an instance of MonadState a
02:36:39 <quicksilver> fasta: but not b
02:36:48 <quicksilver> outermost in that sense
02:38:11 <scook0> hmm, I do believe I've created a monstrosity :)
02:38:15 <scook0> it's a python script
02:38:22 <scook0> that generates a .chs file
02:38:34 <scook0> that gets preprocessed by c2hs
02:38:51 <scook0> and all of this is done automagically by cabal
02:39:07 <fasta> quicksilver: but doing get in a ContT block in a StateT(StateT gets the innermost state, though.
02:39:15 <sjanssen> ... until you run it on Windows :)
02:39:34 <sjanssen> fasta: are you sure about that?
02:39:47 <fasta> sjanssen: I have an example that I will paste
02:41:56 <fasta> sjanssen: http://paste.debian.net/42169
02:42:25 <fasta> sjanssen: that returns "1" (the innermost state)
02:42:58 <sjanssen> fasta: no, 1 is the outermost state
02:43:13 <sjanssen> fasta: you apply the runFoo functions in reverse of the order of the type
02:43:16 <quicksilver> innermost evalStateT is outermost StateT
02:43:26 <quicksilver> tis a bit confusing
02:43:27 <fasta> sjanssen: isn't "abc" the outermost state?
02:43:35 <sjanssen> fasta: no
02:43:42 <quicksilver> that's why I gave an example and said 'outermost in that sense'
02:47:49 <Bacta> why won't this work?
02:47:49 <Bacta> divisible a b = if(a `mod` b == 0) then 1 else 0
02:47:49 <Bacta> listD num = [divisible(p, num) | p <- take 20 (iterate(+1)1)]
02:48:21 <mauke> why does your divisible return a number instead of a boolean?
02:48:33 <Bacta> should it be a bool?
02:48:41 <sjanssen> too much C? ;)
02:48:44 <mauke> well, it would make sense, no?
02:48:49 <Bacta> still doesn't fix it
02:48:59 <mauke> you're not giving it enough arguments
02:49:05 <mauke> and the one you're giving it has the wrong type
02:49:39 <Bacta> ?
02:49:40 <mauke> divisible a b = a `mod` b == 0; listD num = [divisible p num | p <- take 20 [1 .. ]]
02:50:05 <mauke> (p, num) is a single value
02:50:11 <Bacta> oh damn :(
02:50:14 <Bacta> my OO days
02:51:09 <RayNbow> just remove the curry, and (p, num) works fine ;)
02:51:33 <mauke> but I like curry!
02:52:00 <Bacta> whats this currying thing?
02:52:25 <mauke> using functions that return other functions to fake multiple arguments
02:52:26 <quicksilver> currying is replacing tupled arguments (a,b,c,d) with multiple arguments
02:52:50 <RayNbow> > (uncurry div) (6,3)
02:52:53 <lambdabot>  2
02:52:55 <fasta> quicksilver: I see what you mean: FooT (BarT (ZorkT ...)) <=> zorkT $ barT $ fooT ...
02:53:05 <quicksilver> fasta: exactly.
02:53:49 <quicksilver> @unmtl StateT a (StateT b IO)
02:53:50 <lambdabot> err: Unknown MTL(1)
02:53:55 <quicksilver> hmph
02:53:58 * quicksilver shrugs
02:54:05 <sjanssen> @unmtl StateT a (StateT b IO) x
02:54:05 <lambdabot> a -> b -> IO (x, a, b)
02:54:23 <sjanssen> ooh, it's cheating
02:58:28 <quicksilver> heh
02:59:04 <fasta> quicksilver: ok, so my example was actually a ContT( StateT (StateT))
02:59:13 <quicksilver> yes
02:59:26 <quicksilver> it's because (if you like) function compostion is 'backwards'
02:59:31 <quicksilver> f . g . h does h "first"
02:59:53 <quicksilver> so if you used >>> to compose your "run" directives, it would line up :)
03:00:55 <fasta> quicksilver: yes, I know, I was just doing a very complex refactoring and it confused me to the point that I didn't know what I was lifting where.
03:02:56 <jedbrown> Playing with the chameneos shootout, I noticed an anomoly.  GHC 6.6.1 code is twice as fast when compiled with `-O' rather than the `-O3 ...' build line.  GHC 6.8.1 code (with either option) is 10% slower than the slow 6.6.1 build.
03:03:34 <mauke> -O3 is wrong
03:03:36 <sjanssen> jedbrown: GHC misparses -O3 as -O0, use -O2 instead
03:04:37 <jedbrown> Same effect.  I was following the directions with the shootout code.
03:04:54 <ari> I'm not sure if that counts as misparsing
03:07:12 <jedbrown> Dropping to -O2 gives 3.8s for 6.6.1 and 4.5s for 6.8.1, but 6.6.1 with -O is just 2.1s.  Why is 6.6.1 so much better?
03:07:28 <fasta> ari: it should tell the user: "not supported" or it should use the highest optimization level.
03:07:45 <sjanssen> jedbrown: try -fvia-c for GHC 6.8
03:07:58 <fasta> It could also be to annoy Gentoo users :)
03:08:14 <jedbrown> I used: ghc -O3 -fglasgow-exts  -optc-O3 -optc-march=pentium4 chameneos.ghc-2.hs -o chameneos.ghc-2.ghc_run
03:08:31 <sjanssen> jedbrown: is chameneos the concurrency one?
03:08:36 <jedbrown> Then dropped the -O3 to -O2 which makes very little difference.
03:08:45 <jedbrown> sjanssen: yes.
03:08:56 <jedbrown> sjanssen: http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=ghc&id=2
03:08:57 <lambdabot> Title: chameneos Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ..., http://tinyurl.com/247ng5
03:08:58 <fasta> jedbrown: are you sure it's being recompiled?
03:09:05 <jedbrown> fasta: yes.
03:09:31 <mauke> <Raag> i have an athlon xp 2.5, any suggestions for cflags? i have this atm: CFLAGS="-O3 -march=athlon-xp -fforce-addr -fmerge-all-constants -ffast-math -fprefetch-loop-arrays -fstrict-aliasing -falign-functions=64 -falign-labels=1 -falign-loops=16 -falign-jumps=16 -mfpmath=sse -mpreferred-stack-bound
03:09:37 <mauke> <rac> here's a hint. if your IRC client lops off part of your CFLAGS, you have a problem
03:09:44 <sjanssen> jedbrown: have you tried -fvia-c?
03:11:35 <jedbrown> sjanssen: I just did.  4.7s for 6.8.1 with -O2 etc.
03:11:51 <fasta> The context of a function shows F a (SomeT m), but I have defined an instance (Monad t, Monad (t m), F m) => F (t m), why is there no context reduction there?
03:12:09 <fasta> Oh, I think I know it already: overlapping instances?
03:12:38 <sjanssen> jedbrown: I've long suspected that the results for chameneos were too good
03:12:56 <sjanssen> jedbrown: the code was just perfect for GHC's scheduler, or something
03:12:59 <mauke> Monad t, Monad (t m)? how does that kind check?
03:13:10 <fasta> Monad m*
03:13:11 <jedbrown> sjanssen: I'm suggesting they can be better by reducing the flags to -O
03:13:30 <jedbrown> sjanssen: but it only works with GHC 6.6.1
03:13:36 <quicksilver> mauke: t :: (* -> *) -> * -> *
03:13:44 <fasta> mauke: MonadTrans t, Monad (t m), Monad m
03:14:35 <quicksilver> fasta: I think you get context reduction on superclasses, not instance schemes?
03:26:36 <ac> if my computer crashes in the middle of a build, would it be safe to just run build again and install?
03:26:48 <taruti> Are there i386 ghc 6.8.1 debian packages somewhere?
03:27:00 <quicksilver> taruti: yes
03:27:20 <taruti> quicksilver: where?
03:27:37 <salierix> So what's so great about lazy evaluation?
03:28:05 <quicksilver> taruti: I can't remember :) Igloo posted some.
03:29:02 <mauke> salierix: decoupling generation and consumption
03:29:11 <quicksilver> taruti: http://www.haskell.org/ghc/distribution_packages.html#debian
03:29:13 <lambdabot> Title: GHC: Distribution packages
03:29:15 <quicksilver> taruti: I believe
03:29:42 <quicksilver> salierix: also more trivial but still useful things like not having to worry too much about hte order of operations
03:29:54 <taruti> sid does not have them and neither does http://haskell-unsafe.alioth.debian.org/archive/i386/unstable/g/ghc6/ (amd64 packages are available from there)
03:29:57 <lambdabot> Title: Index of /archive/i386/unstable/g/ghc6, http://tinyurl.com/2ujfj4
03:29:59 <salierix> What do you mean?
03:30:07 <quicksilver> salierix: let a = some long calc ; b = some other calc in ...
03:30:19 <byorgey> > take 10 $ map (^2) [1..]  -- salierix
03:30:19 <quicksilver> salierix: and rest assured that a and b won't actually be calculated if not needed
03:30:22 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
03:30:57 <byorgey> salierix: to do that in a strict lang, you have to explicitly write some kind of loop that mixes up the fact that you only want 10 results with the squaring and incrementing
03:31:46 <ac> salierix: AFAIU, you don't have to worry about writing tail recursive loops
03:32:00 <byorgey> salierix: you should read the paper "Why functional programming matters", it really has some excellent answers to your question with good examples.
03:32:08 <byorgey> @go "why functional programming matters"
03:32:09 <salierix> I heard that in some cases lazy evaluation can actually be faster than strict. How does that work?
03:32:14 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
03:32:14 <lambdabot> Title: Why Functional Programming Matters
03:32:18 <ac> (am I write saying that?)
03:32:26 <ac> *right (arhg)
03:32:32 <LoganCapaldo> salierix: doing nothing is _always_ faster than doing something :)
03:32:45 <quicksilver> salierix: well on the one hand you may avoid unnecessary calculation
03:32:57 <quicksilver> salierix: more subtly, even if there is nothing unnecessary to avoid
03:32:57 <salierix> LoganCapaldo, sure but you want the right result.
03:33:19 <quicksilver> salierix: doing the calculations on-demand may result in a better memory profile
03:33:41 <quicksilver> e.g. working over a 100M file, "strict" code might allocate very large chunks of memory
03:33:57 <quicksilver> "lazy code" may even, in ideal conditions, stay entirely within cache
03:33:58 <LoganCapaldo> salierix: lazy evaluation does not spontaneously give you incorrect results
03:34:22 <salierix> LoganCapaldo, did I say it did?
03:34:56 <LoganCapaldo> "sure but you want the right result".
03:35:16 <LoganCapaldo> Getting teh right result is orthogonal to whether you do it strictly or lazier
03:35:54 <salierix> LoganCapaldo, I said that in response to "doing nothing is _always_ faster than doing something"
03:35:55 <mux> @check \x -> signum x * x == abs (x :: Int)
03:35:56 <lambdabot>  OK, passed 500 tests.
03:36:28 <LoganCapaldo> salierix: well this is why you let the runtime / compiler decide what things not to do
03:39:27 <salierix> I noticed a new benchmark was just added to the computer language shootout.
03:48:28 <ac> sudo cabal --global install fastcgi
03:48:30 <ac> Data/List.hs:18:1: lexical error at character 'i'
03:48:49 <ac> :-/
03:49:06 <salierix> When did they remove the cheap concurrency benchmark?
03:49:23 <fasta> Horrible hack: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/534160
03:49:29 <lambdabot> Title: ASPN : Python Cookbook : Submit multiple concurrent batch jobs, with flexible th ...
03:50:09 <fasta> (how does this stuff end up at the top of programming.reddit.com?)
03:50:38 <sjanssen> fasta: reddit has sucked lately
03:50:57 <fasta> I think the readers consumed all the content ;)
03:54:47 <dcoutts> ac: http://hackage.haskell.org/trac/hackage/ticket/174
03:54:49 <lambdabot> Title: #174 (cabal-install tries to upgrade the base package) - Hackage - Trac
03:55:00 <dcoutts> ac: I've just reported that error you found
03:55:15 <ac> dcoutts: is there a work around?
03:55:29 <ac> (let me read the ticket actually)
03:56:05 <dcoutts> ac: would you like to comment on that report to give the example that you were trying
03:56:17 <dcoutts> ac: include the output of cabal info  $pkg
03:56:23 <ac> dcoutts: no problem
03:56:39 <dcoutts> the info command lists what packages cabal-install was thinking of installing and in what order
03:57:41 <ac> dcoutts: how do I comment?
03:58:20 <dcoutts> ac: login guest:haskell'  --note the ' prime char
04:02:16 <ac> dcoutts: cabal info produces quite a bit
04:02:42 <dcoutts> yep
04:06:56 <ac> dcoutts: there you go
04:07:00 <dcoutts> ta
04:07:53 <ac> missed a new line
04:08:10 <dcoutts> don't worry
04:09:01 <ac> man I love "It's All Text". I just click the "edit" button on the textarea, and then in vim I say ":r !cabal info fastcgi" ;)
04:09:45 <ac> one of the best firefox extensions
04:09:53 <timbod> I usually build ghc from source... configure --prefix...; make; make install usually works fine for me. But how to build the haddock library docs??
04:10:44 <timbod> according to http://hackage.haskell.org/trac/ghc/wiki/Building/Docs, it looks like I start having to play with the build system (build.mk etc). Is there just a flag to configure?
04:10:46 <lambdabot> Title: Building/Docs - GHC - Trac
04:11:39 <fasta> timbod: it is documented properly, imho. Follow the instructions.
04:12:36 <ac> huh. both the darcs version and the current hackage version seem to do the same thing
04:13:21 <ac> (of cabal-install that is)
04:15:02 <timbod> fasta: so I can just create a mk/build.mk file with nothing in it except "HADDOCK_DOCS = YES"?
04:15:43 <fasta> timbod: I don't think that's true. You should just copy the example file and add that for example
04:16:10 <fasta> timbod: hmm, maybe it would work.
04:17:16 <timbod> It didn't seem to, but perhaps I didn't get it right. otherwise I need to work out how to create a build.mk file that  corresponds to what I get when I don't have one :-(
04:18:15 <fasta> timbod: you do have one.
04:18:23 <fasta> timbod: there's an example file included
04:19:20 <timbod> Right - so the example file is contains the defaults that are used? ie if I copy the example to build.mk, I will get the same results as if there is no build.mk?
04:20:30 <timbod> Actually, reading http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking again, it seems like build.mk just overrides config.mk, so perhaps the single line for haddock lib docs is ok...
04:20:52 <salierix> What's constructor specialization?
04:21:50 <quicksilver> http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
04:22:01 <lambdabot> Title: Com.org - Only the best links ..., http://tinyurl.com/2qf2ur
04:23:03 <quicksilver> !
04:23:05 <quicksilver> com.org ?
04:23:08 <quicksilver> that's odd
04:23:26 <quicksilver> that's not what the tinyru does for me, thankfully
04:29:54 <idnar> research.microsoft.com.org resolves :/
04:33:11 <timbod> in ghc-6.8.1, I see that System.Locale is now in the package old-locale-1.0.0.0, whereas in 6.6.* it was it base. Anyone know if it's deprecated in favour of something else, or just split from base?
04:33:31 <profmakx> timbod, base has been split
04:33:36 <profmakx> into multiple packages
04:33:38 <quicksilver> 'old-' sounds deprecated to me
04:33:44 <profmakx> some have been obsoleted
04:34:19 <profmakx> timbod: http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html
04:34:23 <quicksilver> but, if it is, I have no idea what replaced it
04:34:32 <timbod> I'm updating a cabal library that uses it, and I'm wondering if I should just adjust the dependencies to pickup old-locale, or whether I should be using something newer.
04:35:37 <timbod> release notes don't indicate a replacement... guess I'll just fix the dependencies.
04:36:13 <quicksilver> timbod: ah
04:36:16 <quicksilver> timbod: Data.Time.Format
04:36:18 <quicksilver> timbod: IMO
04:36:39 <quicksilver> timbod: it's not a 5-minute change though; you have to stop using System.Time which is deprecated and move to Data.Time.Clock
04:37:50 <timbod> quicksilver: thanks - that's the pointer I needed. I'll do the change as I didn't like the old time stuff much anyway.
04:41:54 <profmakx> I wonder if these changes are documented somewhere, quicksilver?
04:44:38 <matthew-_> it takes a little while to get your head around data.time - it is much better, but it also, at least superficially, seems to have some functions missing. It doesn't though - internally it's just Data.Fixed and so the Num instance is very useful...
04:45:21 <quicksilver> profmakx: which changes?
04:45:48 <quicksilver> matthew-_: "appears ot have functions missing" is a common haskell problem. Often the answer lies in implemented typeclasses.
04:45:56 <quicksilver> matthew-_: of course, somsetimes they are actually just missing :)
04:46:04 <matthew-_> quicksilver: indeed. :)
04:47:14 <profmakx> quicksilver, i mean such changes as "System.Time has been moved to Data.Time"
04:47:43 <Beelsebob_> eh?
05:12:27 <ikegami--> hello
05:12:57 <ikegami--> does anyone try to use or has an interest to flymake-mode for Haskell?
05:13:49 <ikegami--> (I have a just minitue before sleeping now)
05:14:53 <ikegami--> otherwise, i guess most people use vim instead of emacs...
05:16:54 <Cale> ikegami--: I saw your video :)
05:17:00 <Cale> ikegami--: I might try it sometime soon :)
05:17:38 <ikegami--> Cale: i'm grad to here your comment.
05:17:48 <ikegami--> I'll have a good dream tonight.
05:19:10 <ikegami--> s/grad/glad/;
05:19:19 <pharm> ikegami-- flymake for haskell would be cool.
05:19:27 <ikegami--> some japanese confuse between l and r
05:19:57 <ikegami--> pharm: thanks
05:24:06 <ikegami--> I would thank to people who helps me and also the flymake-mode developer team.
05:24:26 <ikegami--> emacs is lovely
05:25:07 <ikegami--> good friend for Haskell
05:28:14 <jeffz> ikegami--: hi, I had heard of flymake before but never used it... I'm going to use your setup from now on, it looks useful, thank you
05:28:56 <ikegami--> jeffz: your welcome
05:30:14 <ikegami--> jeffz: please don't hesitate to give a message, such as 'Oops, it doesn't work!'
05:32:51 <ikegami--> I needed the on-the-fly type checking for a live-Haskell-programming-demo on a meeting in Japan
05:34:54 <ikegami--> audiences will notice an error before the programmer thinking
05:35:24 <ikegami--> because the error is colorize :)
05:36:05 <pharm> I can see it making for a great demo.
05:36:35 <pharm> Be nice to fix flymake for the multi-line error message issue, but that's just nit-picking.
05:37:55 <ikegami--> I'm an old programmer who uses the /evil/ perl
05:38:16 <osfameron> (evil perl)++
05:38:38 <ikegami--> however, I wish the flymake-mode will be modified as pharm said
05:38:54 <ikegami--> hello, gwern
05:39:08 <ikegami--> I waited you
05:40:12 <pharm> I'll see if I can have a look at some point. It really is very cool.
05:48:32 <n00b> installed the ghc libraries on debian, but they don't seem to be loading
05:48:39 <n00b> what's the problem?
05:50:36 <swiert> n00b: what's the error you're getting?
05:52:57 <n00b> can't find module graphicsuitl
05:53:11 <n00b> and i already installed it
05:54:42 <pejo> n00b, could you paste the exact error message?
05:54:44 <swiert> n00b: what flags are you using?
05:54:51 <n00b> ???
05:54:57 <n00b> what's that?
05:55:21 <swiert> n00b: what are you typing into the commandline? Just ghc Main.hs?
05:55:33 <swiert> You may need to use "ghc --make Main.hs", for example.
05:55:43 <n00b> yep
05:55:52 <n00b> ok
05:56:40 <n00b>   Could not find module `GraphicsUtils':
05:56:45 <n00b> thats the error
05:58:01 <swiert> n00b: could you paste the exact error: http://hpaste.com/new
05:58:27 <swiert> make that hpaste.org
05:58:58 <hpaste>  noob pasted "error" at http://hpaste.org/3819
06:00:00 <swiert> n00b: so what is the code you're trying to compile?
06:00:01 <Taejo> the South African Computer Olympiad is considering opening some of its competitions to the public... how many of you would take 3-5 hours out of a weekend to compete if we allowed haskell submissions?
06:00:34 <swiert> GraphicsUtils is not a 'standard' Haskell library I think.
06:01:14 <osfameron> Taejo: sounds interesting
06:01:23 <hpaste>  noob pasted "code" at http://hpaste.org/3820
06:01:30 <osfameron> Taejo: http://www.olympiad.org.za/ ?
06:01:53 <n00b> i know but i already installed libghc-hgl
06:01:57 <Taejo> http://olympiad.cs.uct.ac.za/
06:02:20 <Taejo> but it only has ghc in the development branch atm
06:02:38 <Taejo> but you can get the problem archive there
06:02:52 <n00b> it should run, right?
06:03:12 <swiert> n00b: you need a file called GraphicsUtils in the same directory as the one you're compiling.
06:03:36 <swiert> n00b: I'm not sure which file that is, because I don't know the context.
06:04:06 <n00b> ok
06:04:27 <n00b> thanks, later guys
06:04:30 <doserj> GraphicsUtils sounds like an ancient version of SOE
06:04:30 <pejo> n00b, if that is the hgl package, it only exposes "Graphics.HGL.Utils"
06:04:39 <doserj> too late :)
06:04:55 <pejo> People are too instant sometimes.
06:05:38 <osfameron> I love it when people come onto irc, ask a question and then disappear in the same minute :-)
06:06:09 <sieni> and also it's nice when people ask questions like:
06:06:18 <sieni> "I can't walk. What's the problem?"
06:06:28 <swiert> I'd be happy to help him, but I can't solve a problem without knowing a bit about the problem he's trying to solve...
06:06:58 <dankna> Taejo, what is the intended audience of the contest?  Students, professionals, ...?  I take it it's not just for those who live in South Africa.
06:07:06 <osfameron> wasn't there a French film that had a scene where 2 philosophers are discussing "How is it possible to walk?"
06:07:15 <osfameron> it's in a time of terrorist troubles, lots of bombings
06:07:32 <osfameron> and at the end, there is a bomb alert, but one of the philosophers has convinced himself that it is indeed *impossible* to walk
06:07:41 <dankna> heh, that's kind of amusing.
06:07:43 <profmakx> can someone help me with a deriving clause for lambdabot? Seems I am too stupid to get this at the moment...
06:08:22 <profmakx> The problem is the MonadError IRCError instance for ModuleT
06:08:26 <Taejo> dankna, the main contest is to prepare the South African team for the IOI (high-school students), but the online contest is open to anyone. You can see the problem archive at olympiad.cs.uct.ac.za
06:08:34 <pejo> swiert, in teaching mode currently? :-)
06:09:07 <Taejo> We added Haskell as a language for the online contest only, since two of the scientific committee are learning it, but it isn't allowed at the IOI
06:09:37 <swiert> pejo: Well - I try to help where I can.
06:10:09 <dankna> Logical.
06:21:19 <ac> what happened to Distribution.Setup?
06:21:29 <dcoutts_> ac: Distribution.Simple.Setup
06:21:50 <ac> hsql-mysql wants it
06:21:54 <dcoutts_> ac: there is still a Distribution.Setup but it's warns you and tells you to use Distribution.Simple.Setup
06:22:04 <ac> on my installation it doesn't exist
06:22:12 <dcoutts_> ac: unless you're using Cabal HEAD
06:22:24 <dcoutts_> if you're using 1.2.x it exists but is deprecated
06:22:32 <dcoutts_> it's removed completely in Cabal HEAD
06:22:55 <ac> I'm using Cabal-1.3 to fix the last problem I had ;)
06:22:56 <dcoutts_> ac: hsql-mysql has more problems than just that anyway
06:23:08 <ac> ah ok. should I try haskelldb-flat instead?
06:23:26 <dcoutts_> ac: or see if the darcs version of hsql-mysql is fixed to work with ghc-6.8
06:23:47 <dcoutts_> ac: or use hdbc, though it doesn't have support for mysql
06:24:06 <ac> I'm not attached to mysql
06:24:15 <ac> I might just use BerkleyDB
06:24:40 <ac> I wanted to try out haskelldb though
06:24:57 <dcoutts_> ac: haskelldb can use hdbc
06:25:29 <ac> than I can use sqlite or postgres. good enough for me
06:27:07 <ski> hello Da_Stoff
06:27:10 <dankna> personally, I am a fan of using it with sqlite
06:27:19 <Da_Stoff> Yo
06:27:24 <dankna> I really like not having to maintain a separate server.  and being able to tell my users they can treat the db as a file.
06:27:47 <dankna> sorry, that's my bit of advocacy for the day :)
06:29:09 <yrlnry> repeatM x = x >> (repeatM x)    does not work well, because of typing problems.  To get it to behave the way I want, I have to do   repeatM x = x >> (repeatM x) >> return ()
06:29:56 <yrlnry> This tricks Haskell into thinking that the type is Monad a => a b -> a ()   instead of Monad a => a b  -> a c.
06:30:06 <sieni> was that a question?
06:30:11 <yrlnry> No.
06:30:26 <ac> dankna: yeah I like that too. Do you have much experience with haskelldb?
06:30:29 <yrlnry> But if someone wanted to comment about it, I'd be delighted to listen to what they said.
06:30:40 <yrlnry> It was intended more as a topic for possible discussion.
06:30:44 <mauke> why is a c a problem?
06:30:49 <mauke> er
06:30:49 <dankna> no, not much experience with haskelldb, I'm afraid
06:30:57 <mauke> why is the type (a c) a problem?
06:31:07 <Toxaris> yrlnry: what about something like repeatM = sequence_ . repeat
06:31:55 <yrlnry> mauke: I'm not completely sure.
06:31:56 <ski> `Monad a => a b -> a ()' is an instance of `Monad a => a b -> a c'
06:32:24 <yrlnry> The prelude has a show function for IO (), but not for IO c, it seems.
06:32:27 <yrlnry> That might be wrong.
06:33:52 <mauke> I don't think any IO has a show
06:34:20 <yrlnry> > print "foo"
06:34:33 <quicksilver> yrlnry: that's not a show instance
06:34:38 <quicksilver> yrlnry: that's ghci feature :)
06:34:43 <quicksilver> it will execute IO actions
06:35:01 <yrlnry> Oh, okay.
06:35:10 <profmakx> note to self: Sometimes try-and-error even helps in haskell
06:35:14 <yrlnry> I thought maybe there was a show that was defined to produce the empty string or something.
06:36:05 <yrlnry> So the failure of repeatM x = x >> repeatM x    may just be a fluske in the implementation of hugs or ghci; , and it might work properly inside a program?
06:36:09 <Toxaris> if (repeatM :: Monad m => m a -> m b), then (repeatM (return 1) :: Monad m => m a. What would that mean and how could it exist?
06:36:40 <yrlnry> Toxaris: it means that the function never returns.  That's just what you would expect.
06:36:56 <quicksilver> well since repeatM (which is normally called forever) never returns
06:37:06 <quicksilver> its return type is not observable
06:37:10 <mauke> yrlnry: how are you using it that you get a type error?
06:37:17 <Toxaris> instance Monad Nonsense where a >> b = a
06:37:38 <quicksilver> Toxaris: that doesn't obey the monad laws, so who cares what that does? :)
06:37:45 <Toxaris> quicksilver: the typechecker
06:37:49 * quicksilver shrugs
06:38:06 <mauke> yrlnry: more information on what ghci does: http://hackage.haskell.org/trac/ghc/ticket/1201
06:38:25 <quicksilver> :t let forever act = act >> forever act in forever
06:38:31 <yrlnry> Main> repeatX (print "foo")
06:38:31 <yrlnry> ERROR - Cannot find "show" function for:
06:38:31 <yrlnry> *** Expression : repeatX (print "foo")
06:38:31 <yrlnry> *** Of type    : IO a
06:38:36 <yrlnry> I'm using hugs here, BTW
06:38:53 <quicksilver> yrlnry: that doesn't mean it's not working.
06:38:55 <mauke> yeah, it doesn't know how to display an arbitrary a
06:38:55 <yrlnry> Whereas the other definition of repeatM, with the extra >> return (), executes the way I expect.
06:38:59 <quicksilver> just that hugs doesn't know what to do with it.
06:39:01 <Toxaris> repeatM (return 1) :: Nonsense a  ==  return 1 >> return 1 ... == return 1 has type Nonsense Int, not forall a . Nonsense a
06:39:04 <yrlnry> It shouldn't have to display an arbitrary a.
06:39:16 <quicksilver> @bot
06:39:24 <yrlnry> Sorry, that's not what I wanted to say.
06:39:35 <yrlnry> Yes, I agree that it is doing the "right" thing.
06:39:41 <yrlnry> I only said that it was not doing what I wanted.
06:39:42 <Botje> yrlnry: istr that hugs can't execute IO actions from the interpreter.
06:39:52 <quicksilver> let forever a = a >> forever a in forever :: (Monad m) => m a -> m b
06:39:53 <yrlnry> It can.
06:40:05 <quicksilver> Toxaris: ^^ output from ghci
06:40:07 <yrlnry> Main> (print "foo")
06:40:07 <yrlnry> "foo"
06:40:20 <Nexus> For someone just getting into Haskell from a C/C++/Python background, which is the best book to teach Haskell and functional concepts in general? Ive been working for a few days off of online tutorials to get started but I'm in want for a physical text.
06:40:20 <quicksilver> Toxaris: so I would say that the type checker is quite happy with this function
06:40:28 <yrlnry> And as I said, the other definition of repeatM works fine in hugs.
06:40:38 <quicksilver> yrlnry: I suspect what hugs does with IO a is execute the action and then show the return value
06:40:39 <mauke> yrlnry: this is indeed weird because hugs doesn't print the result of IO actions
06:40:50 <quicksilver> yrlnry: that's why it wants a to be showable
06:40:59 <yrlnry> quicksilver: Yes, that is what it seems to me too.
06:41:04 <profmakx> hm. Lambdabot now builds with 6.8.1 :)
06:41:10 <quicksilver> yrlnry: anyhow, there is nothing wrong with your definition. There is only somethign wrong with hugs :)
06:41:12 <mauke> Hugs.Base> return undefined :: IO Int
06:41:12 <mauke> Hugs.Base>
06:41:23 <yrlnry> >> So the failure of repeatM x = x >> repeatM x    may just be a fluke in the implementation of hugs or ghci; , and it might work properly inside a program?
06:41:24 <mauke> I'd say that's a bug
06:41:27 <yrlnry> I guess so!
06:41:54 <mauke> your definition should work in ghci, I think
06:41:56 <yrlnry> mauke: Really?  It should execute something that fails to type check,  because it hopes that the execution will fail to terminate?
06:42:10 <Toxaris> quicksilver: hmm ok. why?
06:42:27 <yrlnry> Or is the idea that it should postpone looking up the show function until after the execution completes?
06:42:28 <mauke> yrlnry: it does typecheck
06:42:47 <quicksilver> Toxaris: because it never returns, it never has to construct the function of type 'b'
06:42:50 <sethk> Hello, all.  If you've been following the email thread (now a wiki page) about extensible records, can someone tell me how what's being discussed differs from the currently available syntax like    { x=1 } (forgive my syntax, buit you'll know what I mean.)
06:43:01 <quicksilver> Toxaris: this is implicit in the definition of >>, if you like
06:43:31 <yrlnry> Toxaris: consider     foo n = foo (n-1).  This function has type Num a => a -> b
06:43:42 <mauke> yrlnry: ghci tries to use the expression at various types, and one of them is IO ()
06:43:48 <mauke> I think that's why it succeeds
06:44:25 <quicksilver> ghci will try both IO () and Show a => IO a
06:44:26 <quicksilver> IIRC
06:44:29 <doserj> my ghci complains without -fno-monomorphism-restriction
06:44:37 <yrlnry> Interesting.
06:46:06 <doserj> (for quicksilvers forever definition, that is)
06:46:16 <Toxaris> ok now I see what you mean, and my Monad instance above will not typecheck because (>>) :: m a -> m b -> m b, so it is not possible to define (>>) non-strict in it's second argument, so forever loops for every monad and everything is good?
06:46:48 <quicksilver> Toxaris: I don't really think it's got much to do with strictness
06:47:02 <quicksilver> Toxaris: but yes, your definition of (>>) didn't type check
06:47:02 <mauke> a >> b = b  -- not strict
06:47:05 <quicksilver> I should have noticed that
06:50:19 <mauke> > let forever a = fix (a >>) in forever Nothing
06:50:45 <mauke> @bot
06:51:59 <profmakx> you killed it!
06:52:03 <profmakx> erm her
06:53:21 <sethk> What's the abbreviation SIG mean?  (I know, I'm manifesting increasing senility  :)    )
06:53:28 <yrlnry> Special Interest Group?
06:53:47 <yrlnry> Have you tried http://en.wikipedia.org/wiki/SIG  ?
06:54:16 <sethk> yrlnry, thanks, that's it.
06:54:20 <yrlnry> You are very welcome.
06:54:28 <sethk> yrlnry, I'll have to make myself an acronym cheat sheet.  :)
06:54:30 <Toxaris> quicksilver: sure it has. your argument was about the termination of forever x, and termination in Haskell has to do with strictness.
06:54:31 <yrlnry> Now figure out what the MOD in SIGMOD is.
06:54:33 <mauke> http://www.acronymfinder.com/af-query.asp?String=exact&Acronym=sig&Find=Find
06:54:55 <mauke> Toxaris: try forever Nothing or forever []
06:54:56 <sethk> yrlnry, hey, I graduated from college 25 years ago, I don't do tests.  :)
06:55:13 <sethk> mauke, thanks, I should have realized I'm not the only one with this problem.  :)
06:55:19 <yrlnry> I just thought you'd be amused.
06:55:31 <sethk> yrlnry, I know, I wasn't being serious.  :)
06:57:13 <sethk> yrlnry, by the way, I did search on wiki, but there are many meanings of SIG; it is used in prescriptions, and I got hundreds of hits about that abbreviation.
06:57:34 <sethk> yrlnry, actually, no, I searched on google and got the wikipedia hits for the prescription flavor
06:59:33 <Toxaris> mauke: i tried, have seen the result and see why it is correct. now I wonder: how can it be printed?
06:59:39 <sethk> yrlnry, so, what _is_ SIGMOD?
06:59:58 <yrlnry> Have you tried http://en.wikipedia.org/wiki/SIGMOD ?
07:00:00 <quicksilver> Toxaris: The type checker doesn't know about termination though. The type checker is following a very simple algorithm
07:00:10 <mauke> Toxaris: hax
07:00:44 <sethk> yrlnry, you expect me to realize that just because there is a ...wikipedia.../SIG there may be a ...wikipedia..../SIGMOD?  How undreasonable.  :)  :)
07:00:55 <yrlnry> I expect nothing.
07:00:57 <Toxaris> mauke: hax? I mean, there is not Show instance for  forall x . Maybe x, is there, and yet Nothing :: forall x . Maybe x can be showed.
07:00:58 <yrlnry> I was just asking a question.
07:01:00 <desp> @bot
07:01:03 <mauke> Toxaris: I think ghci's extended defaulting is to blame
07:01:10 <sethk> yrlnry, I meant I should have thought of that.  :)
07:01:53 <sethk> yrlnry, especially since, indeed, it exists.  :)
07:02:49 <Toxaris> *Main> forever Nothing :: Maybe x
07:02:49 <Toxaris> Nothing
07:03:15 <sethk> That acronymfinder page lists 35 meanings for SIG.  That's astounding.  Then again, I'm easily astounded.  :)
07:03:34 <mauke> yep
07:03:49 <sethk> mauke, great site, thanks for pointing me at it.
07:04:54 <sethk> mauke, I have duly bookmarked it, and now I won't have to bother anyone until I forget that I bookmarked it, which will probably take a two weeks.  :)
07:05:47 <mauke> does your browser support search keywords?
07:06:17 <sethk> mauke, I'm not sure, what are they?  I've only been using computers for 40 years, so I don't know all these details.  :)
07:07:39 <mauke> it's for typing things like "g foo" in the address bar to google for foo
07:07:56 <mauke> g is a search keyword and bound do a url like http://google.com/?q=%s
07:08:10 <mauke> s/do/to/
07:08:15 <sethk> mauke, it does completion, yes.  I'm using the latest firefox.
07:08:49 <yrlnry> mauke: where is that documented?
07:08:55 <mauke> I use a for acronymfinder.com, cpan for search.cpan.org, and hoogle for haskell.org/hoogle
07:09:22 <sethk> mauke, great, I didn't know the first part could be a fragment.
07:12:41 <mauke> yrlnry: http://kb.mozillazine.org/Using_keyword_searches
07:13:37 <yrlnry> thanks very much.
07:15:07 <yrlnry> "oh, that's what that box is for."
07:18:07 <shachaf> Is lambdabot dead?
07:18:17 <quicksilver> apparently so
07:18:21 <Zao> shachaf: I'd say he's lazy.
07:18:28 <ski> s/he/she/
07:19:38 <n00b3434> what must i do
07:20:34 <hpaste>  noob pasted "packages " at http://hpaste.org/3821
07:20:48 <n00b3434> there r the packages
07:23:16 <pejo> n00b, regarding your former question - someone suggested that GraphicsUtils was a really old version of SOE. The HGL package exposes "Graphics.HGL.Utils".
07:25:18 <n00b3434> ok
07:41:41 <n00b3434> i solved it using the soe.gtk
07:42:02 <n00b3434> hey guys anyone knows about soe.gtk
07:42:06 <n00b3434> ?
07:43:57 <Olathe> A group is a monoid with inverses, right ?
07:44:19 <quicksilver> yes
07:44:27 <quicksilver> left and right
07:44:45 <Olathe> Alright, thanks.
07:44:46 <quicksilver> (that is, two-sided inverses, not left inverses and right inverses)
07:51:58 <pharm> OK. After some twiddling, I have a Haskell flymake that doesn't need a perl script & copes with the ghc multi-line error messages.
07:52:32 <pharm> It does hack about with the internals of flymake a tad though.
07:58:20 <pharm> But only a very little in the end.
07:59:00 <quicksilver> pharm: nice
08:00:42 <pharm> The key is that flymake splits error lines on a regexp, which can be patched...
08:00:59 <pharm> Plus a little fiddling to make sure that the multiple lines get fed around.
08:01:07 <pharm> I'll see if I can put it up somewhere.
08:04:57 <roconnor> @src ap
08:05:10 <roconnor> @bot
08:12:21 <byorgey> ap m n = m >>= flip liftM n  -- something like that
08:12:50 <mauke> ap mf mx = do { f <- mf; x <- mx; return (f x) }
08:13:59 <mauke> ap = liftM2 id
08:14:38 <shapr> Good morning #haskell!
08:14:44 <shapr> It's a beautiful day for code!
08:19:47 <pharm> about to be nighttime here...
08:20:24 <byorgey> morning, shapr!
08:20:50 <hpaste>  noob pasted "compare function" at http://hpaste.org/3822
08:23:11 <Botje> @djinn Int -> [Int]
08:23:16 <quicksilver> n00b3434: that will still give compare "Hello" "hello" false, surely
08:23:31 <quicksilver> Botje: even if lambda bot was here, which it isn't, it doesn' tknow about lists.
08:23:31 <Botje> @yow
08:23:35 <Botje> ah
08:23:42 <Botje> but I can tab lambdabot :[
08:24:00 <Botje> so she's here, but maybe just sleeping
08:29:06 <byorgey> dons: around?
08:29:19 <byorgey> alas, we are lost without \bot!
08:32:45 <mdmkolbe|work> Quick question, are type functions in HEAD or 6.8?  Where is a good intro to type functions (the wiki isn't helping me much)?
08:33:01 <byorgey> type functions?
08:33:16 <byorgey> you mean type families?
08:33:30 <ToRA> some level of implementation of type families are in 6.8...but they're not supported
08:34:08 <mdmkolbe|work> byorgey: it was a feature an intern was working on this summer.  I've found I *really* need it for the work I'm doing.
08:34:41 <byorgey> mdmkolbe|work: what is the feature?
08:35:35 <shapr> byorgey: What's going on?
08:36:18 <mdmkolbe|work> byorgey: data constructors (e.g. (,))only build data but functions (e.g. fst) can destruct it. in the same way type constructors (e.g. Maybe) only build types, but type functions can destruct.
08:36:31 <byorgey> shapr: you mean, with me in general?
08:37:14 <byorgey> mdmkolbe|work: ah, I see.  interesting.  I'm pretty sure that's not in 6.8, so if it's in GHC must be in HEAD.
08:37:48 <byorgey> shapr: not much, writing on my blog, a little xmonad hacking, grad school essays...
08:38:04 <shapr> Sounds good
08:38:09 <byorgey> shapr: how about you?
08:38:21 <shapr> HAppS work, playing with Second Life on the side some.
08:38:52 <byorgey> nice.
08:39:18 <shapr> I've heard that scriptable objects in SL can have external logic, like a REST api on a webserver, I thought it might be fun to do some Haskell scripting.
08:39:40 <byorgey> awesome =)
08:39:57 <chessguy> good afternoon, #haskell-ites
08:40:04 <shapr> Good morning chessguy!
08:40:11 <byorgey> I tried SL a while ago out of curiosity, it seemed pretty neat.  I stopped though because I could easily get addicted and I don't have time for that =)
08:40:17 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
08:40:22 <byorgey> hey chessguy
08:40:28 <quicksilver> type families are, indeed, a kind of type function
08:40:29 <shapr> byorgey: Yeah, I know that feeling.
08:40:43 <quicksilver> unless I misunderstand they are quite a way short of being general type functions.
08:41:13 <dons> ?yow
08:41:18 <shapr> poor \bot
08:41:32 <byorgey> help us, obi-dons! you're our only hope!
08:41:34 <dons> url module failed in contextual handler: getHostByName: does not exist (no such host entry)
08:41:37 <dons> Main: caught (and ignoring) thread killed
08:41:40 <dons> url module failed in contextual handler: thread killed
08:41:56 <shapr> Obi-don Kenobi.. I like it!
08:42:13 <shapr> @quote dons
08:42:16 <quicksilver> http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
08:42:17 <dons> so the url module has an issue with timing out and blocking everything
08:42:20 <lambdabot> dons says: too many papers, not enough code
08:42:28 <lambdabot> Title: Constructor specialisation for Haskell programs, http://tinyurl.com/2qf2ur
08:42:30 * shapr cheers
08:42:38 <quicksilver> dons: interestingly, last time I pasted that link
08:42:42 <quicksilver> dons: it managed to get the Title wron
08:42:48 <dons> heh
08:42:50 <quicksilver> dons: and then, I think, that's the last we heard from her
08:42:56 <dons> mm
08:43:33 <quicksilver> 12:21 < quicksilver> http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
08:43:34 <lambdabot> Title: Constructor specialisation for Haskell programs, http://tinyurl.com/2qf2ur
08:43:37 <quicksilver> 12:21 < lambdabot> Title: Com.org - Only the best links ...,
08:43:39 <quicksilver>                    http://tinyurl.com/2qf2ur
08:43:39 <dons> mm
08:43:40 <lambdabot> Title: Constructor specialisation for Haskell programs
08:43:45 <quicksilver> as you can see, she said "com.org" last time
08:43:46 <shapr> Too bad lambdabot doesn't have an out of band admin channel, like jabber.
08:43:47 <quicksilver> very odd
08:43:52 <quicksilver> and then, that is the last time she spoke
08:44:30 <dons> shapr: she does :) ssh
08:44:32 <byorgey> maybe microsoft.com got hacked =)
08:44:45 <quicksilver> byorgey: the generated tinyurl was correct, though
08:44:51 <byorgey> weird
08:45:11 <byorgey> maybe... uh... it got unhacked right before you clicked the tinyurl...
08:46:03 <Cale> I just finished reading the SpecConstr paper actually :)
08:46:14 <quicksilver> is it good?
08:46:19 <quicksilver> I think I might have it in my bag
08:46:42 <quicksilver> no, I have the boxy types one
08:46:43 <shapr> dons: Is lambdabot running on community.haskell.org so that any admin there can restart her?
08:46:47 <Cale> Yeah, it's pretty readable, and rather nice to know that GHC does this now :)
08:46:59 <dons> shapr: oh, that's a good idea.
08:47:06 * byorgey prints it out
08:47:08 <dons> she could run under the lambdabot account
08:47:18 <roconnor> @src ap
08:47:18 <lambdabot> ap = liftM2 id
08:48:15 <shapr> dons: Yeah, that would decrease downtime.
08:50:03 <chessguy> @type ap
08:50:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:50:17 <quicksilver> @type (<$>)
08:50:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:50:37 <quicksilver> @type (<*>)
08:50:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:50:39 <shachaf> @ty (<*>)
08:50:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:50:57 <quicksilver> @quote stereo
08:50:58 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:51:03 * quicksilver sighs
08:51:09 <roconnor> @src (<$>)
08:51:09 <lambdabot> f <$> a = fmap f a
08:51:13 <quicksilver> but that's like, part of haskell folklore
08:51:22 <quicksilver> the stereo quote is the lifeblood of this channel!
08:51:29 <quicksilver> @quote cale
08:51:29 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
08:52:38 <byorgey> @quote C-a-l-e
08:52:38 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
08:53:36 <shachaf> @quote stereo!
08:53:36 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
08:54:32 <shachaf> Hmm. I thought @quote used regexps.
08:54:36 <mdmkolbe|work> quicksilver: it looks like type-synonym families might do what I want (data type families did not)
08:54:48 <shachaf> @forget Cale Welcome to #haskell, where your questions are answered in glorious stereo!
08:54:48 <lambdabot> Done.
08:55:14 <Cale> actually, it's all right now, I have my irc client under control :)
08:55:17 <chessguy> @quote stereo
08:55:17 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:55:23 <chessguy> @quote
08:55:23 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
08:55:49 <Cale> (However, isn't that quote kind of getting old by now? :)
08:56:03 <mdmkolbe|work> aww, that was one of my favorite quotes (it's great for telling newbies)
08:57:06 <quicksilver> Cale: some things transcend age
08:57:18 <quicksilver> @quote stereo!
08:57:18 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
08:57:27 <quicksilver> that'll do :)
08:57:32 <quicksilver> I'll reember the !
08:58:55 <mdmkolbe|work> @quote asfdasdfasfd
08:58:55 <lambdabot> No quotes match. Are you on drugs?
08:59:00 <mdmkolbe|work> @quote stereo
08:59:00 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:59:04 <mdmkolbe|work> lambdabot bug?
08:59:09 <byorgey> hm, what's the difference?
08:59:33 <chessguy> @quote
08:59:33 <lambdabot> boegel says: goes to inflate Itkovians balls
09:00:16 <sorear> Cale: ooh, #888 on Trac - the static argument transform might just happen!  (foldr f z [] = z; foldr f z (x:xs) = x `f` foldr f z xs    --->    foldr f z = go where go [] = z ; go (x:xs) = x `f` go xx)
09:00:47 <Cale> nice
09:01:51 <Cale> sorear: Is that the potential extension to SpecConstr I just read about?
09:02:12 <idnar> the point of that being to avoid passing f and z around?
09:02:23 <sorear> Cale: It has nothing to do with SpecConstr, it's an ancient optimization that never made it into GHC for some reason
09:02:34 <sorear> idnar: yes, and it allows partial evaluation
09:02:34 <Cale> Hmm, I wonder why :)
09:02:57 <dons> sorear: its needed for concatMap stream fusion
09:03:15 <dons> (see the alternative ending for the stream fusion paper at icfp)
09:03:16 <Cale> sorear: There was something in the SpecConstr paper about specialising on fixed function arguments.
09:03:39 <Cale> sorear: But perhaps this is actually unrelated to that :)
09:03:39 <dons> dcoutts: * milestone:  6.8 branch => 6.10 branch :)
09:03:47 <dons> dcoutts: #915: Implement list fusion using streams instead of foldr/build
09:03:48 <sorear> Cale: with the SAT, we get that for free!
09:04:12 <Cale> dons: yay!
09:04:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3823
09:08:03 <dons> Cale: do you write on LtU?
09:08:19 <Cale> dons: not really very much.
09:08:43 <dons> oh, ok. i note that they've linked to the old version of my monte carlo haskell paper
09:08:57 <dons> it should probably at least have a link to the revised version .
09:09:46 <Cale> Do you want me to add a comment about it?
09:10:13 <dons> the new version of the paper is here, anyway, http://www.cse.unsw.edu.au/~chak/papers/KCCSB07.html
09:10:14 <lambdabot> Title: Research Papers of Manuel Chakravarty
09:10:52 <shapr> hei Deewiant
09:11:04 <Deewiant> yo
09:11:11 <shapr> opitko Haskellia?
09:11:18 * shapr pretends to know Finnish
09:11:24 <Deewiant> :-)
09:11:38 <Deewiant> opin kyll
09:11:45 <shapr> Ooh, I understood that!
09:12:34 <Deewiant> :-)
09:12:59 <shapr> I read the "speeding up stm imaging" on slashdot and thought they had some sort of concurrency visualization software... but it's just for scanning tunneling microscopes, bah!
09:14:09 <Cale> hehe
09:14:22 <Cale> I haven't visited slashdot in ages
09:14:26 <dons> stupid microscopes
09:15:36 <shapr> So is anyone getting themselves an XO wit the give one get one program? I think we need one for the community.haskell.org buildfarm.
09:15:59 <shachaf> shapr: mgsloan is getting one.
09:16:03 <shapr> Wow, cool!
09:16:15 <chessguy> XO?
09:16:25 <shapr> I'm very tempted, I've wanted a laptop for years, but never found anything really persuasive.
09:16:30 <shachaf> chessguy: OLPC, $100 (now $200) laptop.
09:16:34 <shapr> chessguy: The One Laptop Per Child dealie.
09:16:56 <chessguy> oh
09:17:06 <chessguy> i've heard of OLPC, but not XO
09:17:17 <shapr> XO is the actual laptop name.
09:17:18 <shachaf> chessguy: It's the name of the machine itself.
09:17:24 <shapr> More stereo :-)
09:17:32 <chessguy> gotcha
09:17:42 <dons> yeah, i'm thinking about it too.
09:17:45 * shachaf used one for a bit ~April.
09:17:51 <dons> how easy would it be to get debian on one?
09:17:53 <shapr> shachaf: What did you think?
09:18:12 <byorgey> if I had any kidlets of my own I'd get them one.
09:18:14 <shachaf> shapr: Well, there were a lot of people, I didn't really get a chance to do much.
09:18:23 <shachaf> The screen is impressive.
09:18:33 <shachaf> (In the sun.)
09:18:54 <shapr> That's another thing I'd enjoy about the XO, I can't really use my Nokia 770 in the sunlight.
09:19:34 <shapr> dons: http://wiki.laptop.org/go/Hardware_specification - 433MHz AMD Geode, 256mb DRAM, 1GB NAND flash
09:19:34 <lambdabot> Title: Hardware specification - OLPCWiki
09:19:38 <phlpp> hi!
09:19:42 <shapr> hiya phlpp
09:19:44 <shapr> How's code?
09:20:41 <pharm> Nokia 810 is going to have a transflective screen supposedly. Crap battery life compared with the OLPC XO of course.
09:20:41 <shapr> Good morning Mr Elkins.
09:20:53 <shachaf> dons: Is cjb (that's the one who provided the xmonad picture, right?) a Haskeller?
09:21:00 <dons> shapr: what's your nokia, and do you have hugs on it?
09:21:03 <dons> i need a phone
09:21:08 <ddarius> Morning shapr.  I get to have my teeth cut out of my head this week.
09:21:10 <dons> and may as well get a fun one
09:21:18 <dons> ddarius: wisdom?
09:21:24 <idnar> what is the point of a transflective screen?
09:21:25 <shapr> Nokia 770,800, and 810 aren't phones, they're pocket-sized linux boxes.
09:21:30 <dons> shachaf: don't think he's a long term haskeller
09:21:35 <ddarius> dons: Yeah.  Not necessary, but it's free and "recommended"
09:21:39 <quicksilver> they're quite funky and very cheap
09:21:44 <quicksilver> (the nokia series)
09:22:01 <dons> ddarius: i've had mine out, and its worth it I think.
09:22:02 <shapr> dons: You can get the N800 for ~$250 from buy.com
09:22:06 <shachaf> How does Haskell run on it, does someone know?
09:22:13 <dons> shapr: but can it make phone calls?
09:22:18 <shachaf> I suppose xmonad compiled...
09:22:18 <idnar> oh, I misunderstood this description
09:22:19 <shapr> Only via google talk.
09:22:24 <dons> shachaf: the compiled binary runs on it
09:22:32 <quicksilver> shachaf: my brother's only cost him 70 quid, which was (then) around $120
09:22:35 <pharm> shachaf: can't see why not; it's a Linux ARM box inside IIRC.
09:22:38 <shapr> Though that's often enough, open wifi APs are everywhere.
09:22:52 <dons> shapr: so they're more like zaurus or other tiny unixy pdas?
09:22:57 <shachaf> quicksilver: An XO?
09:22:58 <shapr> dons: Yup
09:23:04 <shachaf> ARM?
09:23:17 <shapr> stepcut had an unregistered build of GHC 6.4 on the Nokia 770.
09:23:26 <quicksilver> shachaf: no, a N770
09:23:48 <shachaf> quicksilver: Oh, I was still talking about the XO.
09:23:57 <shapr> The N800 is about twice as fast and has twice as much storage as the N770, I'm tempted to get that instead of an XO.
09:24:20 <quicksilver> shachaf: yes, that was a mis-tab-complete
09:24:24 <quicksilver> shachaf: it was meant for shapr  :)
09:24:40 <shapr> And supposedly the N800 supports SDHC completely, so you could have 32GB of miniSD storage in your pocket.
09:24:48 <shapr> That's a lot of research papers!
09:25:05 <shapr> I wonder how much space wikipedia requires...
09:25:06 <quicksilver> it's an entire virtual SPJ
09:25:10 <hpaste>  yrlnry pasted "Failed guard clauses" at http://hpaste.org/3824
09:25:13 <osfameron> bug it's horrible to read pdfs on
09:25:22 <shapr> osfameron: I actually like reading PDFs on my Nokia 770.
09:25:25 <osfameron> actually, pdfs are horrible to read in general, but even so...
09:25:28 <yrlnry_> I don't understand why I got a failed pattern match in this simple code.
09:25:30 <osfameron> shapr: 2-column ones?
09:25:35 <shapr> osfameron: no!
09:25:56 <osfameron> shapr: so all you need is to find 32Gb of papers that are actually formatted in a way that you can read them on a computer...
09:26:01 <shapr> I agree with you there, two column PDFs are really painful to read on the Nokia 770, even with fbreader to turn the document sideways.
09:26:02 <osfameron> (which might be a little more difficult)
09:26:14 <osfameron> they're horrible even on a PC monitor
09:26:17 <shapr> osfameron: Or convert them into html with embedded pix?
09:26:38 <osfameron> ah!  can you easily reflow a 2-col pdf into html ?
09:27:04 <shapr> I don't know, but it's possible?
09:27:04 <Jiten> ... for a moment I thought I was looking at #maemo
09:27:08 <quicksilver> shapr: http://download.wikimedia.org/enwiki/latest/
09:27:08 <lambdabot> Title: Index of /enwiki/latest/
09:27:17 <shapr> Jiten: ei ole!
09:27:18 <quicksilver> shapr: apparently, it's on the order of smaller number of gigs
09:27:30 <quicksilver> shapr: should fit on a 32G card
09:28:07 <shapr> Very spiffy.
09:28:29 <shapr> I'm sure someone has two 16gb cards in their N800.
09:28:37 <byorgey> yrlnry_: odd, I get 2 when I run that code
09:28:40 <Jiten> I only have one 2GB card
09:29:24 <byorgey> yrlnry_: are you sure you loaded the right version of the file into ghci, etc.?
09:29:46 <yrlnry_> I was just wondering the same thing.
09:30:20 <yrlnry_> Strange.  It works for me too.
09:30:22 <yrlnry_> Thanks.
09:30:55 <yrlnry_> In ghci, the  ":r" command will reread the file and recompile it, yes?
09:31:28 <yrlnry_> And presumably it won't do anything strange, like making the name 'factfrom' in the definition of the new "factfrom" function refer to the previously compiled version.  Right?
09:31:35 <sorear> right.
09:32:45 <yrlnry_> Okay, thanks.
09:33:02 <yrlnry_> Is there a point-free way to write \x -> (x, foo x)  ?
09:33:15 <dons> sure :)
09:33:17 <ddarius> @pl \x -> (x,foo x)
09:33:17 <lambdabot> ap (,) foo
09:33:18 <dons> there  always is
09:33:18 <yrlnry_> something like id x foo?
09:33:24 <sorear> ap (,) foo
09:33:24 <yrlnry_> Keen, thanks.
09:33:30 <dons> there's an arrow solution too
09:33:31 <sorear> > ap (,) negate 12
09:33:35 <lambdabot>  (12,-12)
09:33:38 <yrlnry_> There's always an arrow solution :)
09:33:39 * ddarius would probably write id *** foo
09:33:41 <ddarius> er id &&& foo
09:33:55 <dons> > id &&& (+1) $ 7
09:33:55 <lambdabot>  (7,8)
09:34:00 <yrlnry_> Ah, && is just what I wanted.
09:34:03 <yrlnry_> &&&.
09:34:11 <yrlnry_> Who wrote @pl?
09:34:13 * sorear likes ap more
09:34:22 <dons> yrlnry_: originally, Thomas Yaeger
09:34:28 <yrlnry_> What's ap?
09:34:33 <ddarius> :t ap
09:34:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:34:35 <ddarius> @src ap
09:34:35 <lambdabot> ap = liftM2 id
09:34:44 <conal> more generally,
09:34:44 <sorear> yrlnry_: S
09:34:45 <yrlnry_> I typed :t ap into ghci and it said it didn't know it.
09:34:49 <conal> :t (<*>)
09:34:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:34:54 <ddarius> @index ap
09:34:54 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
09:34:54 <sorear> yrlnry_: import Control.Monad
09:34:54 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
09:35:04 <yrlnry_> thanks.
09:35:11 <sorear> yrlnry_: you know about S and K, right?
09:35:14 <conal> ap is a specialization of <*>
09:35:18 <conal> to monads
09:35:31 <yrlnry_> @index &&
09:35:31 <lambdabot> Data.Bool, Prelude
09:35:33 <yrlnry_> sorear: yes.
09:35:40 <yrlnry_> @index &&&
09:35:40 <lambdabot> Control.Arrow
09:37:38 <dons> sjanssen: did you see pepe's type families soln, http://hpaste.org/2689
09:38:02 <yrlnry_> But S shouldn't be what I want.  S has (c -> b  -> a) -> (c -> b) -> c -> a, but I want (c -> a) -> (c -> b) -> c -> (a * b)
09:38:19 <byorgey> well, ap is S in the ((->) r) monad, but it's more general than that.
09:38:39 <byorgey> @type (&&&)
09:38:39 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:38:54 <ddarius> :t ap (,)
09:38:55 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
09:39:30 <byorgey> yrlnry_: since there's an instance of (->) for arrow, in that case you could see the type of &&& as (b -> c) -> (b -> c') -> b -> (c, c')
09:39:31 <ddarius> dons: So have we had performance comparisons between the fundep and type family solutions?
09:39:49 <byorgey> yrlnry_: which is exactly what you want.
09:40:24 <ddarius> @pl \x -> (f x, g x)
09:40:24 <lambdabot> liftM2 (,) f g
09:40:55 <yrlnry_> Sure, &&& is just what I want.
09:41:17 <ddarius> uncurry flip
09:41:24 <yrlnry_> ddarius: how did liftM2 get in there?
09:41:27 <ddarius> :t uncurry flip
09:41:27 <lambdabot> forall a b c. (a -> b -> c, b) -> a -> c
09:41:35 <ddarius> yrlnry_: Why shouldn't it?
09:41:49 <yrlnry_> :t liftM2
09:41:50 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:42:19 <yrlnry_> :t  liftM2 (,)
09:42:19 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
09:42:25 <byorgey> liftM2 f x y == return f `ap` x `ap` y == f <$> x <*> y
09:42:55 <yrlnry_> LiftM2 (,) has all the types monad-qualified.  But  \x -> (f x, g x) has no such restriction.
09:43:06 <byorgey> yrlnry_: it's the ((->) r) monad.
09:43:19 <yrlnry_> What's the ((->) r) monad?
09:43:36 <ddarius> yrlnry_: \x -> (f x, g x) is even more restrictive than liftM2 (,)
09:43:57 <byorgey> otherwise known as the 'reader' monad.  i.e. it threads through an extra function parameter to everything.
09:44:08 <yrlnry_> :t  liftM2 (,)
09:44:09 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
09:44:16 <yrlnry_> :t    \x -> (f x, g x)
09:44:17 <lambdabot> Not in scope: `f'
09:44:17 <lambdabot> Not in scope: `g'
09:44:19 <yrlnry_> bah.
09:44:33 <yrlnry_> :t    \f -> \g -> \x -> (f x, g x)
09:44:33 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
09:44:43 <yrlnry_> Okay, I see.
09:45:23 <ddarius> :t \f g x -> (f x, g x)
09:45:24 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
09:45:38 <yrlnry_> I couldn't remember the syntax.  Thanks.
09:45:49 <salierix> How expensive is calling C code from Haskell?
09:46:08 <ddarius> salierix: As expensive as calling a C function is from C.
09:46:12 <shachaf> $0.005 per function call.
09:46:14 <yrlnry_> :t \f g -> LiftM2 (,) f g
09:46:15 <lambdabot> Not in scope: data constructor `LiftM2'
09:46:20 <yrlnry_> :t \f g -> liftM2 (,) f 1g
09:46:21 <lambdabot> forall t a1 a2. (Num (t -> a2), Monad ((->) t)) => (t -> a1) -> t -> (a1, a2)
09:46:28 <yrlnry_> :t \f g -> liftM2 (,) f g
09:46:28 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
09:46:53 <byorgey> yrlnry_: and if you replace each 'm' with (r ->) ...
09:47:02 <ddarius> :t \x f g -> liftM2 (,) f g x
09:47:02 <lambdabot> forall t a1 a2. (Monad ((->) t)) => t -> (t -> a1) -> (t -> a2) -> (a1, a2)
09:47:08 <yrlnry_> Yes, I see.
09:47:13 <byorgey> =
09:47:17 <byorgey> uh, =)
09:48:18 <yrlnry_> Suppose I have a function defined with a series of guard clauses.  I want the last one to be a catchall.  Do I write  | True = ...  ?
09:48:24 <yrlnry_> Or is there some other idiom for that?
09:48:48 <ambiotic> in an if statement, should the "then" and "else" be indented as much as the if, or further? my emacs with haskell mode insists on indenting them the same, but it looks a bit dubious
09:48:50 <gwern> otherwise?
09:48:58 <dons> further, ambiotic
09:49:06 <dons> and 'then' and 'else' are  typically indented the same
09:49:08 <gwern> | otherwise = 42 -- That's always the answer
09:49:21 <yrlnry_> Thanks.
09:49:30 <gwern> ambiotic: you'll learn haskell-mode's indentation is not yet very intelligent
09:49:32 <ambiotic> dons: as I thought. I wonder why it absolutely insists on indenting them all the same. very annoying.
09:49:37 <dons> yes
09:49:41 <ambiotic> gwern: mheh, i suspected as much :)
09:50:12 <ddarius> yrlnry_: Note that otherwise is just another name for True.
09:50:14 <ddarius> @src otherwise
09:50:14 <lambdabot> otherwise = True
09:50:24 <yrlnry_> Yes, of course.
09:50:44 <Toxaris> gwern: but you need instance Num a where ... = undefined to make the answer typecheck
09:50:54 <gwern> but, it's much clearer
09:52:04 <gwern> Toxaris: well, shucks, then you might as well toss an error into the otherwise branch. no worse than undefined...
09:53:01 <yrlnry_> Suppose X is a recursive function.  Is there a jargon term for a lambda term which, if given to the Y combinator, would yield X?
09:53:32 <yrlnry_> For example, if X were the factorial function, the thing I'm talking about is \f x -> if x = 0 then 1 else x * (f (x-1))
09:53:43 <ddarius> Nothing very widely used.
09:53:53 <user317> is there a fast psudorandom generator in haskell?  seems like random is pretty slow on my linux machine
09:53:54 <gwern> a fixpoint?
09:54:01 <faxathisia> hi
09:54:58 <yrlnry_> Anyway, my real question is, I want to write a function countCalls, which, given that thing, say X',  and an argument, say A,  figures out how many times the function X will be called in the computation of (X A).
09:55:15 <yrlnry_> It seems like this ought to be possible, but I can't quite get my head around it yet.
09:55:28 <desegnis> user317: Is System.Random too slow even if you use split appropriately? (Otherwise, I think there is because System.Random is known to be not the fastest, but there's no name in my head right now)
09:55:49 <user317> hmm
09:55:58 <yrlnry_> Oh well, I'll figure it out.
09:56:06 <gwern> could always write a ffi binding to a mersenne twister implementation
09:57:32 <dons> gwern: yeah. i've done it a couple of times, definitely worth while
09:59:37 <gwern> dons: why did you need more than one?
10:00:10 <dons> one was just an Int32 only binding
10:00:24 <dons> the other was to a new version of the twister code, with sse, for doubles
10:00:43 <yrlnry_> @pl filter (\x -> x `mod` n /= 0)
10:00:43 <lambdabot> filter ((0 /=) . (`mod` n))
10:00:54 <yrlnry_> Okay.
10:01:58 <yrlnry_> The pointfree versions are obvious once I see them, but I still don't have the machinery in my head for constructing them myself.
10:02:45 <chessguy> yrlnry_, it takes time
10:03:12 <faxathisia> (`f` x) is a cool trick
10:03:23 <Beelsebob_> yrlnry: any particular reason you want the point free version?
10:03:32 <Beelsebob_> because the version with the lambda is a whole lot more clear there
10:03:35 <jberg> well in the above case the point free is uglier and harder to understand
10:03:50 <chessguy> jberg, i don't know about that
10:03:51 <yrlnry_> Because the only way to get got at doing something is to do it.
10:04:03 <yrlnry_> s/got/good/
10:04:07 <Beelsebob_> yrlnry: oh, okay, fair enough
10:04:14 <jberg> well it's subjective of course
10:04:30 <Beelsebob_> chessguy: I'd really have to agree with jberg there, the lambda is a *lot* clearer
10:04:40 <yrlnry_> Right now I don't have a choice; for me it's lambda expression or nothing.
10:04:47 <faxathisia> I think that filter ((/= 0) . (`mod` n)) reads easier than the version there
10:05:00 <chessguy> ok, good, i'm not totally alone
10:05:19 <Saizan_> it's a simple pipeline
10:05:30 <Beelsebob_> yes... but the lambda is a simple function
10:05:35 <idnar> I'd probably first write something like:  n `divides` x = x `mod` n == 0
10:05:37 <Beelsebob_> I'd rather have a function than a sequencing
10:05:38 <Saizan_> with the lambda you've to see where the x is used
10:05:50 <Beelsebob_> idnar: yeh, that's probably the best
10:05:58 <faxathisia> Can I ask what is a good name for these symbols?
10:06:05 <Beelsebob_> Saizan_: exactly -- it makes it clear where the x is used
10:06:06 <faxathisia> (I want to write haskell code for these functions..)
10:06:35 <faxathisia> it looks a cross between capital T and tau, the other is between P and rho..
10:06:37 <Saizan_> Beelsebob_: for me it's cleared in the pointfree version, it's a matter of geting used to it
10:06:42 <yrlnry_> I just wrote: isPrime n = 1 == numFactors n
10:07:06 <Saizan_> s/cleared/clearer/
10:07:07 <yrlnry_> Normally I would put (numFactors n) == 1 but it occurred to me that if I wrote the 1 on the LHS I could drop the parentheses.
10:07:11 <faxathisia> yrlnry: I prefer 2 == numFactors
10:07:29 <Saizan_> yrlnry_: you can drop them in either form
10:07:30 <yrlnry_> faxathisia: Well, then it would be wrong  :)
10:07:33 <yrlnry_> Oh, I can?
10:07:40 <yrlnry_> It won't numFactors (n == 1)?
10:07:46 <faxathisia> yrlnry_: What are the factors of the number 5?
10:07:55 <faxathisia> yrlnry_: It's 1 and 5...
10:07:56 <Saizan_> no, function application binds tighter than anything else
10:08:10 <faxathisia> yrlnry_: Your definition says the number 1 is prime (which I do not like)
10:08:18 <yrlnry_> faxathisia: No, this function counts the number of factors in the prime factorization.  You are thinking of the number of divisors.
10:08:27 <yrlnry_> No, numFactors 1  ==>  0
10:08:51 <faxathisia> ah I see
10:09:09 <yrlnry_> My Haskell may be a little weak, but there's nothing wrong with my number theory :)
10:09:17 <yrlnry_> Saizan_: thanks.
10:09:35 <faxathisia> I'd call it numPrimeFactors though
10:09:43 <faxathisia> so it doesn't confuse people like me :p
10:09:46 * yrlnry_ shrugs.  
10:10:08 <yrlnry_> I'm doing some exercises I found online.  The exercise said "write a function, numFactors, which..."
10:10:10 <yrlnry_> So I did.
10:10:15 <ambiotic> Hm, I'm reading a tutorial, which says that hugs won't accept Char.toUpper, and to use toUpper, but none of them are working. Where am I noobing out?
10:10:39 <yrlnry_> When you guys want to say that the value of expression foo is bar, what do you write?  I've been using   foo  ==>  bar.
10:10:42 <Saizan_> ambiotic: you've to import Char or Data.Char in your file
10:11:18 <Saizan_> ambiotic: writing "import Data.Char" at the top after "module Foo where"
10:11:28 <ambiotic> aha, I see, thanks :)
10:12:23 <yrlnry_> Is there a standard name for   isin x [] = False; isin x (y:ys) = x == y || isin x ys ?
10:12:35 <faxathisia> I think it's elem
10:12:38 <byorgey> yes, elem
10:12:43 <byorgey> which is in Data.List
10:12:46 <yrlnry_> Bingo.  Thanks.
10:12:58 <yrlnry_> I tried "element" but that wasn't it.
10:13:21 <yrlnry_> I should have looked that up. Sorry.
10:13:52 <byorgey> yrlnry_: but you did look it up, in #haskell =)
10:14:14 <yrlnry_> Thanks.  I don't want to wear out my welcome.
10:14:39 <yrlnry_> Also I don't want you folks to turn into a bunch of bitter, cranky bastards like the ##c people.
10:14:51 <byorgey> yrlnry_: not likely.
10:15:40 <Deewiant> 'filter' and 'nub' are the ones which I never remember, personally.
10:15:46 <yrlnry_> :t nub
10:15:48 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:15:59 <faxathisia> I always remember nub since someone showed me how to list the primes with it :D
10:16:07 <yrlnry_> @index nub
10:16:07 <lambdabot> Data.List
10:16:23 <yrlnry_> @index elem
10:16:23 <lambdabot> Data.List, Prelude
10:16:24 <Deewiant> > nub [1,1,2,3,1,2,3]
10:16:29 <lambdabot>  [1,2,3]
10:16:30 <faxathisia> (well nubBy.. but still rememins me)
10:16:34 <Beelsebob_> http://www.youtube.com/watch?v=lQ-3u6e3UxI <-- for those of you who want to know the true origin of lambdacats
10:16:34 <lambdabot> Title: YouTube - history of LOLCats
10:17:54 <byorgey> > map (head . snd) . group . sort $ [1,1,2,3,1,2,3]   -- faster for Ord things
10:17:55 <lambdabot>  Couldn't match expected type `(a1, [a])'
10:18:01 <byorgey> > map (head . fst) . group . sort $ [1,1,2,3,1,2,3]   -- faster for Ord things
10:18:02 <lambdabot>  Couldn't match expected type `([a], b)'
10:18:43 <byorgey> oh, duh
10:18:49 <Deewiant> > map (head . head . head) . group . sort $ [1,1,2,3,1,2,3]
10:18:49 <lambdabot>   add an instance declaration for (Num [[a]])
10:18:49 <lambdabot>     In the expression: 3
10:18:49 <byorgey> > map head . group . sort $ [1,1,2,3,1,2,3]   -- faster for Ord things
10:18:50 <lambdabot>  [1,2,3]
10:19:03 <Deewiant> > map (head . head) . group . sort $ [1,1,2,3,1,2,3]
10:19:03 <lambdabot>   add an instance declaration for (Num [a])
10:19:03 <lambdabot>     In the expression: 3
10:19:30 <byorgey> just one head
10:19:45 <shachaf> > (Data.Set.toList . Data.Set.fromList) [1,1,2,3,1,2,3]
10:19:46 <lambdabot>  [1,2,3]
10:19:54 <faxathisia> :O
10:20:00 <byorgey> ah yes, that too =D
10:20:24 <yrlnry_> :t \n -> map (- n) [1 .. n]
10:20:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
10:20:25 <lambdabot>     Probable cause: `n' is applied to too few arguments
10:20:25 <lambdabot>     In the expression: n
10:20:29 <Deewiant> byorgey: yeah, just duplicating your fst/snd :-)
10:20:38 <yrlnry_> What's wrong there?
10:20:47 <faxathisia> yrlnry_: (- n) is a function
10:20:53 <yrlnry_> :t \n -> (- n)
10:20:53 <lambdabot> forall a. (Num a) => a -> a
10:20:57 <faxathisia> oops I misread
10:21:00 <yrlnry_> Yes.
10:21:04 <faxathisia> was gona say no need for \n
10:21:14 <yrlnry_> Gotta bind n somewhere :)
10:21:14 <faxathisia> but (- n) is still a function
10:21:16 <Deewiant> :t \n -> map (flip $ n -) [1 .. n]
10:21:22 <lambdabot>     The operator `-' [infixl 6] of a section
10:21:23 <lambdabot>         must have lower precedence than the operand `($)' [infixr 0]
10:21:23 <lambdabot>         in the section: `((flip $ n) -)'
10:21:24 <monadonous> I think you want (subtract n)
10:21:26 <byorgey> it isn't, actually.
10:21:31 <byorgey> > (- 1)
10:21:32 <lambdabot>  -1
10:21:37 <yrlnry_> But why can't I map the (- n) function over the list [1 .. n] ?
10:21:41 <byorgey> ah, the oddities of -.
10:21:43 <Deewiant> d'oh.
10:21:47 <byorgey> (- n) isn't a function, it's negative n.
10:21:47 <monadonous> (-1) means negative one, not \x -> x - 1
10:21:48 <Deewiant> > (+ 1)
10:21:51 <yrlnry_> Oh, it's an unary negation operator?
10:21:55 <lambdabot>  <Integer -> Integer>
10:21:59 <yrlnry_> I thought it might be something like that.
10:22:03 <ukl> Hey...trying to compile Graphics.X11 version 1.3.0, runhaskell Setup.hs configure claims not to find X11 libraries, although /usr/include/X11/Xlib.h exists - what have I done wrong?
10:22:09 <Deewiant> But there's no unary +? Ah, the inconsistency.
10:22:19 <byorgey> yrlnry_: yeah, it's a special case.  it always trips people up.
10:22:28 <monadonous> even worse, - means different things different places
10:22:29 <yrlnry_> Then I :t \n -> (- n)  and saw it had the type I wanted, without considering that I had not falsified the unary negation hypothesis.
10:22:32 <yrlnry_> Whoopss!
10:22:41 <Deewiant> :t \n -> (- n)
10:22:41 <lambdabot> forall a. (Num a) => a -> a
10:22:44 <yrlnry_> THanks.
10:22:46 <byorgey> if you want the equivalent of (+ 1), use (subtract 1)
10:22:50 <Deewiant> :t \n -> subtract n
10:22:51 <lambdabot> forall a. (Num a) => a -> a -> a
10:23:45 <yrlnry_> I wanted (n -) anyway.
10:24:19 <faxathisia> > (\n -> map (-n-) [1..10]) 5
10:24:19 <lambdabot>  [-6,-7,-8,-9,-10,-11,-12,-13,-14,-15]
10:24:35 <Deewiant> :t \n -> (n -)
10:24:35 <lambdabot> forall a. (Num a) => a -> a -> a
10:24:55 <Deewiant> > (\n -> (-n-) 0) 5
10:24:56 <lambdabot>  -5
10:25:04 <Deewiant> > (\n -> (n-) 0) 5
10:25:04 <lambdabot>  5
10:25:17 <Deewiant> > (\n -> ((-) n) 0) 5
10:25:18 <lambdabot>  5
10:26:25 <yrlnry_> @pf \f x -> not(f x)
10:26:25 <lambdabot> Maybe you meant: bf pl
10:26:32 <yrlnry_> @pl \f x -> not(f x)
10:26:33 <lambdabot> (not .)
10:26:38 <yrlnry_> Oh, right.
10:27:31 <faxathisia> @bf +++++++++++[>+++++++++++>+++++++++>+++>++++++<<<<-]>>-.++++.>-.<-.<---.>----.+++++++++++.>+.>---.
10:27:31 <lambdabot>  fd:15: hClose: resource vanished (Broken pipe)
10:27:34 <faxathisia> :[
10:27:36 <phlpp> lol :D
10:27:44 <faxathisia> > bf "+++++++++++[>+++++++++++>+++++++++>+++>++++++<<<<-]>>-.++++.>-.<-.<---.>----.+++++++++++.>+.>---."
10:27:45 <lambdabot>   Not in scope: `bf'
10:27:47 <faxathisia> hmf
10:28:06 <yrlnry_> @pl \primes isPrime n -> filter isPrime (takeWhile (> 1) (map (n -) primes))
10:28:07 <lambdabot> flip ((.) . filter) . (takeWhile (> 1) .) . flip (map . (-))
10:28:12 <yrlnry_> Hee hee.
10:28:24 <faxathisia> > nubBy(((>1).).gcd)[2..]
10:28:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:28:35 <yrlnry_> @pl \n -> filter isPrime (takeWhile (> 1) (map (n -) primes))
10:28:35 <lambdabot> filter isPrime . takeWhile (> 1) . flip map primes . (-)
10:28:37 <faxathisia> this I found here some time ago :p
10:28:42 <phlpp> @src nubBy
10:28:43 <lambdabot> nubBy eq []             =  []
10:28:43 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:29:55 <yrlnry_> maybe filter isPrime . takeWhile (> 1) . (map (n -) primes)  is an acceptable version there.
10:30:03 <yrlnry_> flip map primes . (-) is ridiculous.
10:32:13 <yrlnry_> @pl \n -> filter isPrime (takeWhile (> 1) (map (n -) primes)) /= []
10:32:13 <lambdabot> ([] /=) . filter isPrime . takeWhile (> 1) . flip map primes . (-)
10:32:32 <yrlnry_> Oh, it knows that /= is symmetric.
10:32:37 <yrlnry_> Clever.
10:32:46 <yrlnry_> @pl \n -> n == 1
10:32:46 <lambdabot> (1 ==)
10:32:55 <yrlnry_> @pl \n -> 1 == n
10:32:55 <lambdabot> (1 ==)
10:33:00 <phlpp> hehe
10:33:14 <phlpp> @pl \n -> 5 - n
10:33:14 <lambdabot> (-) 5
10:33:14 <Taejo> @pl for init cond increment body = sequence $ map body $ takeWhile cond $ iterate increment init
10:33:14 <lambdabot> for = ((((sequence .) . flip map) .) .) . flip ((.) . takeWhile) . flip iterate
10:33:18 <phlpp> @pl \n -> n - 5
10:33:18 <lambdabot> subtract 5
10:33:25 <faxathisia> @pl (\x y->(take y x)++[(1+x!!y)]++(drop (y+1) x))
10:33:26 <lambdabot> ap (ap . ((++) .) . flip take) (ap (ap . ((++) .) . flip flip [] . (((:) . (1 +)) .) . (!!)) (flip (drop . (1 +))))
10:33:32 <phlpp> :t subtract
10:33:33 <lambdabot> forall a. (Num a) => a -> a -> a
10:33:39 <phlpp> @src subtract
10:33:39 <lambdabot> subtract x y = y - x
10:33:42 <phlpp> ah
10:33:47 <phlpp> subtract x from y
10:33:48 <phlpp> ok
10:36:34 <Taejo> @src mapM
10:36:34 <lambdabot> mapM f as = sequence (map f as)
10:36:47 <Taejo> as I suspected
10:39:23 <Taejo> @unpl ((((sequence .) . flip map) .) .) . flip ((.) . takeWhile) . flip iterate
10:39:23 <lambdabot> (\ r ad ag aj -> sequence (map aj (takeWhile ad (iterate ag r))))
10:39:42 <faxathisia> @index chr
10:39:42 <lambdabot> Data.Char
10:39:49 <Taejo> hey, unpl DOES magically add readability to code
10:40:05 <bv07> i have a noobie question about implementing an instance of Show for a custom data type - could anybody help me out please?
10:40:24 <faxathisia> bv07: what is your question though?
10:40:31 <shachaf> bv07: Maybe; try asking your question. :-)
10:40:43 <bv07> oops ;| ok, hold on
10:41:48 <yrlnry_> Yaay.  I just wrote my first pointfree definition.
10:42:21 <bv07> i have a data type "Expr" which describes a mathematical equation. I have also written a function "simplify" which will .. well its obvious. I have already written my rules for show. When i want to display an expression (exp1 for example), i want to show (simplify exp1) not show (exp1). How is this possible?
10:43:03 <faxathisia> bv07: I think you can write a show helper function, which can display any given expression
10:43:12 <faxathisia> bv07: Then a particular show instance, which does simplify then calls the show helper
10:43:17 <reqamst> > (take 2 . map (+1)) [1..]
10:43:19 <lambdabot>  [2,3]
10:43:23 <faxathisia> bv07: Do you know how to do a show instance? I know an example
10:43:25 <reqamst> > take 2 $ map (+1) [1..]
10:43:25 <lambdabot>  [2,3]
10:43:31 <bv07> yes, i have written one show instance
10:43:36 <reqamst> so '.' equals '$'?
10:43:42 <shachaf> reqamst: No..
10:43:45 <shachaf> s/.$//
10:43:48 <shachaf> @src (.)
10:43:49 <lambdabot> (.) f g x = f (g x)
10:43:53 <bv07> instance Show Expr where...
10:43:56 <shachaf> (.) is function composition.
10:44:01 <shachaf> ($) is function application.
10:44:04 <shachaf> @src ($)
10:44:04 <lambdabot> f $ x = f x
10:44:08 <desegnis> bv07: Possible... by writing show . simplify instead of just show?
10:45:00 <shachaf> desegnis: Can you tell if an expression is simplified?
10:45:06 <shachaf> s/desegnis/bv07/
10:45:33 <bv07> my simplify function is recursive, so it keeps simplifying until the last simplification is the same as the result
10:45:43 <bv07> so effectively i can tell if it's simplified
10:45:51 <bv07> but unfortunately my code will be tested automatically
10:46:05 <bv07> so i cannot ask them to simply use "simplify x"
10:46:17 <shachaf> bv07: If you have myShow, can you say instance Show Expr where show = myShow . simplify ?
10:46:18 <bv07> i will try using a helper function now, and see if it works
10:46:31 <bv07> ah, that sounds good
10:46:34 <bv07> i will try that
10:46:52 <bv07> although, what would the type of myShow be?
10:46:58 <bv07> the function definition
10:47:02 <faxathisia> same type as show
10:47:09 <bv07> ok
10:47:14 <shachaf> bv07: Expr -> String
10:47:19 <bv07> thanks
10:47:37 <shachaf> bv07: Make sure myShow calls myShow and not show.
10:48:07 <shachaf> instnace Show Expr where show = myShow . simplify where myShow x = ... myShow ...
10:51:43 <bv07> :r
10:51:46 <bv07> oops
10:54:14 <bv07> ok i have a slight problem.. not really sure how to explain this
10:54:33 <bv07> in show, i had plenty of rules
10:55:32 <byorgey> bv07: would it help to paste some code?
10:55:34 <byorgey> @paste
10:55:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:55:57 <bv07> like "show (Id x) = x" and "show (Num y) = show y" where y is a float. It seems that the rule for show Float was inherited from the prelude? (because i didnt define one)
10:56:51 <gkr> http://www.youtube.com/watch?v=91WgM6dNLTE
10:56:52 <lambdabot> Title: YouTube - New Radicals - You Get What You Give
10:56:52 <byorgey> bv07: right.
10:56:57 <gkr> Sorry, wrong window.
10:57:02 <faxathisia> @index fromJust
10:57:02 <lambdabot> Data.Maybe
10:57:13 <byorgey> bv07: there are pre-defined Show instances for most built-in types.
10:57:19 <shachaf> faxathisia: Careful with fromJust. :-)
10:57:24 <shachaf> @instances Show
10:57:26 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
10:58:34 <Olathe> Unfortunately, 5-tuples can't be shown.
10:58:43 <Olathe> It's a sad limitation of Haskell.
10:58:52 * Olathe laments.
10:59:11 <yrlnry_> I have  foo   | g1 = x  | g2 = x  where x = y, but it seems not to work the way I want.  Is the where x=y distributing over the first guard clause?  It seems not.
10:59:13 <shachaf> @seen lament
10:59:13 <lambdabot> lament is in #haskell-blah and #haskell. I don't know when lament last spoke.
10:59:15 <Vq^> Olathe: have you ever used a 5-tuple?
10:59:21 <Olathe> Yes.
10:59:31 <byorgey> yrlnry_: it should.  where scopes over all the guards.
10:59:45 <shachaf> @instances-importing Data.Tuple Show
10:59:46 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
10:59:48 <shachaf> Hmm.
11:00:11 <hpaste>  benvan pasted "ExprTrouble" at http://hpaste.org/3825
11:00:16 * byorgey frowns disapprovingly at Olathe.
11:00:34 <yrlnry_> byorgey: thanks.  I'll investigate further.
11:00:38 <Vq^> Olathe: might i ask what you used it for?
11:00:52 <shachaf> bv07: Make sure to use myShow in there where.
11:01:08 <shachaf> bv07: Since the expression is already simplified (right?).
11:01:59 <bv07> er...
11:02:09 <bv07> except that myshow doesnt have a rule for displaying an integer
11:02:11 <bv07> for example
11:02:16 <bv07> i thought that's what show was for
11:02:40 <byorgey> well, ok, not *all* of them
11:02:48 <hpaste>  yrlnry pasted "Type failure I don't understand" at http://hpaste.org/3826
11:02:49 <shachaf> bv07: Use myShow to display an Expr, specifically.
11:03:38 <bv07> sorry, i dont think i explained properly. The requirement is that "show" will display the simplified expression, not some other function
11:03:44 <bv07> is that still possible?
11:04:44 <byorgey> bv07: yes, that's right.
11:04:52 <shapr> bv07: Will you be bv08 next year?
11:04:53 <bv07> haha
11:04:56 <bv07> no
11:05:03 <bv07> i'm a first-year student
11:05:05 <shachaf> yrlnry_: Monomorphism restriction, maybe?
11:05:16 <byorgey> bv07: in your definition of myShow, you need to use show when applied to built-in types, and myShow when recursively applying it to something of type Expr (such as Num b).
11:05:30 <yrlnry_> shahaf: I don't understand what the problem is.
11:05:44 <shachaf> yrlnry_: (That code seems to work for me, by the way.)
11:05:47 <benvan> ah, thanks byorgey
11:05:52 <byorgey> yrlnry_: try giving numOccurrences an explicit type signature.
11:05:59 <byorgey> yrlnry_: that might get you a better error message.
11:06:20 <byorgey> yrlnry_: and it seems from that message that another function called sameElements is involved
11:06:22 <yrlnry_> I think I found the problem.
11:06:37 <yrlnry_> The previous definition was sameElements = (==)
11:06:43 <yrlnry_> and when I commented it out, the file compiled.
11:06:48 <yrlnry_> So it's some dumb parser error.
11:06:50 <byorgey> yes, that's the MR.
11:06:54 <yrlnry_> MR?
11:06:54 <byorgey> no, not a parser error.
11:06:59 <byorgey> monomorphism restriction.
11:07:32 <shachaf> yrlnry_: Try giving it an explicit type signature.
11:07:35 <byorgey> essentially, any top-level binding with no parameters like that must be monomorphic (i.e. have a specific, non-polymorphic type).
11:07:39 <shachaf> yrlnry_: Or saying sameElements x = (==) x
11:07:46 <byorgey> unless you give it an explicit type.
11:07:48 <shachaf> Or using -fno-monomorphism-restriction.
11:07:50 <sorear> yrlnry_: parser errors don't have words like type in them
11:07:56 <yrlnry_> Ohh.  The complaint was about the == in sameElements, not in numOccurrences.
11:08:00 <shachaf> > let x = type
11:08:01 <lambdabot>  Parse error at "type" (column 9)
11:08:03 <shachaf> :-)
11:08:18 <yrlnry_> I didn't mean a parser *error*; I meant that I thought it had misparsed the code and produced a nonsensical type error as a result.
11:08:37 <byorgey> yrlnry_: right.  the line number in the error is your friend =)
11:08:42 <yrlnry_> Yep.  Thanks.
11:09:08 <benvan> superb, it works, and i understand why. Thank you all for your help :)
11:09:17 <byorgey> benvan: =D
11:10:02 <byorgey> is there any reason -fno-monomorphism-restriction shouldn't be the default, with the ability to specifically turn it on if you want it?
11:10:13 <byorgey> I'm sure this has been discussed before
11:12:01 <shachaf> byorgey: Well, the standard reason.
11:12:17 <yrlnry_> Feh.  numOccurrences x = length . filter (== x)
11:12:29 <yrlnry_> @pl \x -> length . filter (== x)
11:12:29 <lambdabot> (length .) . filter . (==)
11:12:34 <yrlnry_> It was better before.
11:12:54 <byorgey> yrlnry_: yes, points-free-ness can easily be taken too far.
11:12:58 <Deewiant> :t (x .) .
11:12:59 <lambdabot> parse error (possibly incorrect indentation)
11:13:00 <shachaf> > let x :: (Num a,Enum a) => a; x = product [1..100] in (x :: Integer, x :: Int)
11:13:00 <lambdabot>  (933262154439441526816992388562667004907159682643816214685929638952175999932...
11:13:09 <shachaf> Recomputes x for Integer and Int.
11:13:35 <Deewiant> :t \x -> \f -> (x .) . f
11:13:36 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
11:14:19 <Deewiant> :t \x -> \f -> (x .) . f . (==)
11:14:19 <lambdabot> forall b c a a1. (Eq a1) => (b -> c) -> ((a1 -> Bool) -> a -> b) -> a1 -> a -> c
11:14:26 <yrlnry_> but I think length . filter (== x) is probably an improvement on the nonpointfree version.
11:14:56 <byorgey> (f .) . g is a function which passes *two* parameters through g, then passes the result on to f
11:15:05 <byorgey> yrlnry_: agreed.
11:15:25 <shachaf> @ty (.) . (.)
11:15:26 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:15:34 <Phillemann> Does Haskell have a function which sorts a sequence by a comparison function object?
11:15:46 <byorgey> Phillemann: yes, sortBy
11:15:46 <shachaf> sortBy?
11:15:51 <byorgey> @type sortBy
11:15:52 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
11:16:08 <Phillemann> Oh, must have missed that. Thanks. :)
11:16:12 <shachaf> See also on (Data.Function in GHC 6.8).
11:16:20 <shachaf> @let on f g x y = g x `f` g y
11:16:20 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
11:16:33 <shachaf> Amazing, it survived.
11:16:40 <byorgey> > sortBy (compare `on` length) ["foo", "foobar", "x"]
11:16:40 <lambdabot>  ["x","foo","foobar"]
11:16:48 <yrlnry_> @source sortBy
11:16:49 <lambdabot> sortBy not available
11:17:06 <shachaf> @src sortBy
11:17:06 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:17:38 <Phillemann> byorgey: That's pretty much what I wanted...
11:17:50 <Deewiant> byorgey: Yeah, I deciphered as much from the :t. Talk about confusing syntax...
11:18:03 <shachaf> See also Data.Ord.comparing, if you don't have on.
11:18:20 <shachaf> @let dot = (.) . (.)
11:18:21 <lambdabot> Defined.
11:18:31 <shachaf> @ty \f g -> f `dot` g
11:18:31 <lambdabot> Not in scope: `dot'
11:18:35 <byorgey> Deewiant: indeed.
11:18:40 <Phillemann> Which site do you use to look up functions? :)
11:18:41 <shachaf> @ty let dot = (.) . (.) in \f g -> f `dot` g
11:18:42 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:18:47 <shachaf> Phillemann: You can use hoogle.
11:18:49 <shachaf> @where hoogle
11:18:49 <lambdabot> http://haskell.org/hoogle
11:18:55 <shachaf> @hoogle sort
11:18:55 <lambdabot> List.sort :: Ord a => [a] -> [a]
11:18:55 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
11:18:55 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
11:18:58 <Phillemann> Ah, great.
11:19:32 <byorgey> or just go to http://haskell.org/ghc/docs/ and pick your version of ghc.
11:19:47 <byorgey> hoogle is still semi-broken, I think
11:19:55 <byorgey> after the 6.8.1 release
11:21:50 <desegnis> sortBy (compare `on` length) looks cute, but will it not compute the length of the elements multiple times?
11:22:40 <Deewiant> :t on
11:22:40 <lambdabot> Not in scope: `on'
11:23:11 <olsner> map fst . sortBy (compare `on` snd) . map (id &&& length) perhaps?
11:23:13 <Heffalump> desegnis: yes
11:26:03 <reqamst> Which algorithm does List.sort uses? Quick sort?
11:26:36 <ari> reqamst: In ghc, mergesort
11:27:13 <desegnis> (D'oh, I just was writing what olsner just wrote.) I already sometimes wondered why there is no common name for this function. sortByMap, or similar
11:27:37 <olsner> or even sortOn length
11:27:58 <desegnis> sortOn looks right
11:28:42 <faxathisia> :t [(b,a)] -> b -> Maybe a
11:28:42 <lambdabot> parse error on input `->'
11:28:48 <faxathisia> @hoogle [(b,a)] -> b -> Maybe a
11:28:48 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
11:37:32 <stulli> Where can look at the code of built in functions? (I want to know how the delete function in the module List.hs is coded)
11:38:07 <desegnis> Once upon a time, the ghc library docs included a source link on every page
11:38:08 <shachaf> @source Data.List
11:38:08 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:38:09 <Jaak> @src delete
11:38:09 <lambdabot> delete = deleteBy (==)
11:38:18 <Jaak> @src deleteBy
11:38:18 <lambdabot> Source not found. Take a stress pill and think things over.
11:38:35 <shachaf> stulli: In general, darcs.haskell.org/packages/{base,mtl,etc.} is helpful.
11:38:49 <stulli> Ah, thanks
11:39:06 <shachaf> stulli: lambdabot's @src is, too.
11:39:30 <shachaf> stulli: (@src gives the source to a function, @source links to a file; @src's is not always the "real" implementation.)
11:39:53 <dons> sometimes its the h98 impl
11:40:06 <dcoutts_> which is usually more helpful for understanding
11:40:29 <mrd> is there a reason why sliceSU is not exported from Data.Array.Parallel.Unlifted?
11:40:29 <shachaf> @src foldr
11:40:30 <lambdabot> foldr k z xs = go xs
11:40:30 <lambdabot>     where go []     = z
11:40:30 <lambdabot>           go (y:ys) = y `k` go ys
11:40:43 <shachaf> dons: Can someone fix that sometime?
12:09:21 --- topic: '["The Haskell programming language","GHC 6.8.1 is out!! http://tinyurl.com/2nel76","http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","http://arcanux.org/lambdacats.html"]'
12:09:21 --- topic: set by dons on [Sat Nov 03 13:34:54 2007]
12:09:46 <dcoutts_> oh ok
12:10:19 <dcoutts_> SideFFect: perhaps you should be using an array then, that allows you to index from 1 as in the original version
12:10:28 <faxathisia> SideFFect: Did you tell your teacher about the problems before?
12:10:33 <faxathisia> SideFFect: With his code
12:10:45 <SideFFect> yeah...all he said was this (lemme get email)
12:10:56 <faxathisia> hehe
12:11:34 <SideFFect> addp :: (Integer, Integer) -> Integer
12:11:45 <SideFFect> addp (j,k) = j+k
12:11:54 <SideFFect> im like uhh...ok that adds two numbers so what?
12:11:58 <shachaf> addp = uncurry (+)
12:12:01 <faxathisia> O_o
12:12:04 <SideFFect> hes like huh? im not going to tell you how to do ur assign
12:12:10 <SideFFect> then I stopped talking to him lol
12:12:30 <faxathisia> SideFFect: You mention that the code he gave was wrong... and then he told you how to add two numbers?
12:12:42 <mrd> well i'm not getting any parallelism but NDP is damn fast nonetheless
12:13:05 <MisterN> hi. quick question:
12:13:06 <SideFFect> faxathisia: yeah lol
12:13:09 <SideFFect> hes very odd
12:13:17 <faxathisia> hahah
12:13:21 <MisterN> is it hard to embed haskell into c or c++?
12:13:58 <SideFFect> hehe
12:14:00 <MisterN> where can i find information on that? (i couldn't find it on the GHC homepage)
12:14:14 <SideFFect> any ideas of why the code that was given isnt stopping with the if case?
12:14:40 <SideFFect> shouldnt find 1 [1,2] give 0 not 1?
12:14:59 <ukl> Hi - When trying to compile Graphics.X11, configure succeeds but "build" dies with the message, ld could not find -lXinerama. I already checked, libXinerama*.so exists in /usr/lib[64]/ (both) - Where should I look for the error? Is there some "hidden commandline" in Distribution.Simple that should be adjusted concerning ENV vars? Is there something wrong with the present libXinerama?
12:15:04 <Deewiant> > find 1 [1,2]
12:15:05 <lambdabot>   add an instance declaration for (Num (a -> Bool))
12:15:16 <Deewiant> > find (==1) [1,2]
12:15:17 <lambdabot>  Just 1
12:15:20 <Deewiant> > find (==2) [1,2]
12:15:21 <lambdabot>  Just 2
12:15:25 <faxathisia> > fromJust $ find (==1) [1,2]
12:15:25 <lambdabot>  1
12:15:27 <faxathisia> :p
12:15:27 <Deewiant> > find (==1) [2,1]
12:15:28 <lambdabot>  Just 1
12:15:49 <faxathisia> > fromJust Nothing
12:15:50 <lambdabot>  Exception: Maybe.fromJust: Nothing
12:15:59 <Deewiant> SideFFect: it returns the first that matched, evidently; not its index
12:16:11 <ddarius> :t elemIndex
12:16:12 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
12:16:21 <ddarius> :t find
12:16:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:16:25 <dcoutts_> ukl: dons might know about that error
12:16:28 <SideFFect> oh so its just picking 1 because its the first
12:16:32 <Deewiant> :t elem
12:16:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:17:00 <ukl> dcoutts_: I just recognized that the error is thrown by ghc, not gcc (how stupid this assumption), so I haven't got the slightest clue how to fix it.
12:17:05 <Deewiant> is there a wrapper like \n -> find (==n)
12:17:11 <faxathisia> > find (((==) `on` (`mod` 3)) 1) [2,4,6,5,8,10]
12:17:12 <lambdabot>  Just 4
12:17:15 <SideFFect> can I edit that program to output messages instead of integers?
12:17:18 <dcoutts_> ukl: well, ghc is calling gcc to do the linking
12:17:20 <Deewiant> :t (on)
12:17:20 <lambdabot> Not in scope: `on'
12:17:24 <Deewiant> :t `on`
12:17:25 <lambdabot> parse error on input ``'
12:17:25 <SideFFect> and luist the position of the integer?
12:17:27 <Deewiant> :t on
12:17:27 <lambdabot> Not in scope: `on'
12:17:29 <faxathisia> (*) `on` f = \x y -> f x * f y
12:17:35 <MisterN> Deewiant: query lambdabot.
12:17:44 <MisterN> Deewiant: you don't have to spam this channel.
12:17:47 <Deewiant> MisterN: roger that, thanks.
12:17:48 <ukl> dcoutts_: oh, ok.
12:17:48 <faxathisia> MisterN: on is there
12:17:52 <faxathisia> MisterN: I posted it
12:18:11 <ukl> dcoutts_: still I'm completely lost with this issue. hmm.
12:18:13 <MisterN> faxathisia: possibly.
12:18:14 <shachaf> > find ((==1) . (`mod` 3)) [2,4,6,5,8,10]
12:18:15 <lambdabot>  Just 4
12:19:00 <dcoutts_> ukl: try with ghc -v and possibly also -optc-v to pass -v to gcc so it can tell you more about why it cannot find the file
12:20:15 <Raguel> wwjd - what would java do?
12:20:54 <TomMD> Raguel: No, what would 'J' do, as in the 'J' programming language.
12:21:08 <TomMD> @where J
12:21:08 <lambdabot> I know nothing about j.
12:21:10 <TomMD> damn
12:21:29 <Raguel> hmm
12:21:30 <shachaf> jsoftware.com
12:21:34 <Raguel> ah
12:21:47 <Raguel> well it was just one of those phrases that stick in your head for some reason
12:21:54 <shachaf> @where+ j http://jsoftware.com/
12:21:55 <lambdabot> Done.
12:22:20 <Raguel> now i gotta find a way to go from blah to operational again :P
12:22:24 <ukl> I cannot find the right line in here... http://hpaste.org/3828  - If anybody could have a look, it'd be appreciated...
12:23:05 <Raguel> (!) inspiration
12:23:33 <Raguel> Graham Hutton - if you're reading this i don't have access to your past papers cos i'm not in your school - can you email them to me?
12:23:50 <Raguel> well thats one problem solved - now does anyone know anything about scaling factors
12:23:53 <ddarius> Raguel: wtf?
12:24:09 <Raguel> graham reads the logs and answers my questions in class on thursdays
12:24:13 <Raguel> he doesn't answer emails
12:24:20 <Raguel> and i don't have time to go see him
12:24:35 <Raguel> *shrugs* i'll find out if it works later
12:24:59 <alexj> @seen igloo
12:24:59 <lambdabot> igloo is in #haskell, #ghc and #darcs. I don't know when igloo last spoke.
12:25:09 <sjanssen> ukl: does this FAQ help?  http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#X11_fails_to_find_libX11_or_libXinerama
12:25:15 <lambdabot> http://tinyurl.com/3a2duf
12:25:43 <Raguel> spent 10 hours without a break modelling an electric golf caddy and i've lost higher neural functions..
12:25:50 <Raguel> but i want to do some more work tonight
12:26:14 <Raguel> any advice on jumpstarting brains except chemicals?
12:26:26 <MisterN> Raguel: play desktop tower defense.
12:26:28 <ddarius> Read something interesting.
12:26:37 <scodil> does anyone know what the interaction is between unpacked fields and modules? If I define my datatype and associated functions in the same module where they're used, then it upacks fine. If I put the same definitions in another module, it eats up heap like crazy
12:26:44 <MisterN> Raguel: http://www.handdrawngames.com/DesktopTD/game.asp
12:26:44 <lambdabot> Title: Desktop Tower Defense
12:26:56 <MisterN> yeah, lambdabot, you got that right :)
12:27:21 <Raguel> just watched 2 eps of mezzo dsa but still blaaah
12:27:28 <Raguel> lets try this then
12:28:01 <Raguel> and the only reading material i've got to read at hand is journal papers
12:28:08 <alexj> anyone know how to tell ghc 6.8 build system where to find happy?
12:28:47 <hpaste>  jedbrown pasted "shootout thread-ring" at http://hpaste.org/3829
12:29:15 <jedbrown> I'd appreciate suggestions for improvement.
12:30:42 <dons> scodil: sounds like you'll need to use -O2 when compiling the package
12:30:51 <dons> scodil: if it then doesn't inline and unpack, that's a ghc bug
12:30:55 <dons> and very very interesting
12:31:08 <dons> since we had similar issues with the stream fusion across module boundaries
12:31:13 <uk1> hmm I accidentially dropped out, so if anybody has any idea about http://hpaste.org/3828, I'd be glad to listen to you...
12:31:14 <dons> so any test case is useful
12:31:35 <sjanssen> ukl: does this FAQ help?  http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#X11_fails_to_find_libX11_or_libXinerama
12:31:36 <lambdabot> http://tinyurl.com/3a2duf
12:31:53 <uk1> sjanssen: thanks, I'll have a look. haven't seen this page before...
12:31:58 <sjanssen> jedbrown: use _ rather than otherwise
12:32:21 <uk1> sjanssen: that sounds pretty good. I'll have a try (and new hope)
12:33:03 <scodil> dons: the issue happens with multi-level unpacking
12:33:10 <scodil> specifically, recursive multilevel unpacking
12:33:23 <scodil> statically-sized lists, unpacked into arrays
12:34:12 <dons> do you have a small test case that illustrates this?
12:34:19 <scodil> sure... hold on
12:36:22 <uk1> actually, it's this line that fails:  /usr/bin/ghc-6.6.1 -L/usr/lib64 -L/usr/lib -lXinerama -lXext -lX11 Graphics/X11/Types_hsc_make.o -o Graphics/X11/Types_hsc_make   --- What is strange, because libXinerama.1.so is in /usr/lib[64]/...
12:37:17 <hpaste>  scodil pasted "unpacking bug (?)" at http://hpaste.org/3830
12:37:35 <jedbrown> sjanssen: thanks.  This is somewhat faster for me than the Oz/Mozart which is currently winning this new benchmark.
12:38:32 <dons> jedbrown: sweet
12:38:45 <scodil> dons: there. compile with -DPOLYMORPHIC to use the polymorphic, unboxed type. without that flag it uses a monomorphic type. if the polymorphic type is defined in the same file, it runs comparably to the monomorphic type, ie, in constant space. if you move the polymorphic type defs out to another module, it blows up the heap
12:38:46 <dons> jedbrown: feel free to submit it to the shootout then (or is that with ghc 6.8?)
12:39:03 <uk1> ok, giving it up for today. Thanks for your help, might return soon,.... Bye.
12:39:06 <jedbrown> dons: It is almost the same with 6.6 and 6.8.
12:40:10 <hpaste>  sjanssen annotated "shootout thread-ring" with "slightly shorter 'thread'" at http://hpaste.org/3829#a1
12:40:32 <dons> drop the module Main, btw
12:40:35 <dons> its not needed
12:40:49 <jedbrown> dons: As an aside, chameneos is twice as fast for me with 6.6 -O than 6.8 is with any optimization flags.
12:41:04 <dons> interesting. a regression?
12:42:13 <jedbrown> dons: Yes.  Both versions are about the same with full optimization, but 6.6 is twice as fast with just -O than it is with full flags.
12:45:01 <dons> jedbrown: looks like this should be strictier, putMVar r $ max 0 (m - 1)
12:45:13 <dons> make sure it defaults to Int too
12:45:13 <sjanssen> s/jedbrown/sjanssen :)
12:47:55 <mrd> internal error: evacuate: strange closure type 1224263043
12:48:00 <mrd> sounds bad :/
12:48:56 <byorgey> hm, 1224263043 is a strange closure type indeed.
12:49:11 <byorgey> I mean, 1224263042 would make sense, but this...
12:49:49 <Olathe> 1224263043 is totally not in Z_1224263043.
12:50:02 <Olathe> It obviously violates closure.
12:52:44 <mrd> yea well, that's the first time it said that instead of just segving
12:54:11 <dons> mrd, is it a small program?
12:54:14 <dons> is it with ghc 6.8?
12:54:21 <mrd> yea
12:54:31 <dons> please report it then. that's a compiler bug
12:54:32 <dons> ?bug
12:54:32 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
12:54:37 <dons> narrow down what flags are needed
12:54:44 <mrd> yea i'm prepping it.  compiled from ghc head actually, but after release.
12:54:49 <dons> great
12:54:53 <dons> mention that
12:55:04 <dikini> does yield do a context switch in ghc?
12:55:30 <mrd> one problem is that it only occurs on large enough data-sets so i will have to include that
12:56:39 <dons> mrd, ok. or perhaps a little program to generate a data set.
12:56:40 <ski> (Olathe : `Z_1224263043' being a quotient ring ?)
12:56:44 <dons> dikini: it will trigger one, yeah
12:56:58 <dikini> thanks
12:57:08 <TomMD> ?quote pointer
12:57:08 <lambdabot> qwe1234 says: in my very firm opinion, it's never your business to be figuring out pointer type at runtime.
12:57:17 <hpaste>  sjanssen annotated "shootout thread-ring" with "a bit faster" at http://hpaste.org/3829#a2
12:57:23 <sjanssen> jedbrown: ^^^
12:58:02 <mrd> -O1 vs -O2 turns on only two flags?
12:58:22 <TomMD> use -O3 - dons and sorear love to see that.
12:59:09 <TomMD> (note: I am not responsible for any bodily harm that might occur as a result of my advice)
12:59:10 <mrd> whats that turn on? -fhorribly-mangle-my-program?
12:59:39 <sorear> mrd: turns off all optimizations that work, and leaves on the ones that don't
12:59:50 <sorear> mrd: supposedly it's fixed now
12:59:54 <jedbrown> sjanssen: I can't detect a speed difference, but it is certainly cleaner.  I forgot about foldM.
12:59:56 <mrd> -fno-liberate-case seems to stop the crashing
13:00:43 <mrd> but so does -fno-spec-constr weird
13:01:25 <dons> TomMD: :P
13:01:40 <dons> jedbrown: yeah, remember there's points for gzip loc
13:01:59 <dons> jedbrown: and double, triple, quadruple check against the current code, with the same compiler as the shootout
13:02:08 <dons> since there's so many interesting variables that can bias results
13:02:30 <hpaste>  sjanssen annotated "shootout thread-ring" with "a bit cleaner" at http://hpaste.org/3829#a3
13:02:32 <jedbrown> dons: Since this is a new benchmark, there is no existing code.
13:02:45 <dons> oh, its not message-thread ah.
13:02:54 <dons> yes. go for it
13:03:14 <dons> oh, i see, this replaces message-passing/message-thread
13:03:32 <dons> mm, no, that became thread-x
13:03:34 <dons> this is new.
13:03:38 <jedbrown> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
13:03:39 <lambdabot> Title: thread-ring (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2lyngq
13:04:12 <sjanssen> jedbrown: this totally crushes the Java version :)
13:04:34 <dons> i'd hope so. its oz/mozart that we want to beat though
13:04:57 <jedbrown> I know that the strictness $! and Int declarations are good in principle, but can you detect a difference in speed?  They are extra characters...
13:05:10 <dons> make sure you remove the module Main stuff too
13:05:14 <Raguel> damn this tower defense game is addictive :(
13:06:01 <jedbrown> On my machine, it is a hair faster than the oz/mozart.
13:06:18 <ski> (Raguel : Arcomage ?)
13:06:49 <ski> "oz/" ?
13:07:13 <Philippa> Raguel: which one of far too many are you playing?
13:07:13 <hpaste>  sjanssen annotated "shootout thread-ring" with "compress by a single line" at http://hpaste.org/3829#a4
13:07:15 * ski thought Oz was the language, and Mozart the implementation
13:07:27 <dons> i wonder if there's a way to create the ring with cycle
13:08:05 <sjanssen> jedbrown: I think my last annotation is all I can squeeze out of it :P
13:08:40 <jedbrown> sjanssen: Thanks a bunch.  I'll credit you in the comments.
13:08:52 <Raguel> its called desktop tower defense
13:08:56 <Raguel> and i'm losing :(
13:09:02 <dons> better or worse with -threaded ?
13:09:15 <Philippa> ah, that thing. I never did get round to completing it, it's one of the more complicated ones
13:09:20 * sjanssen bets worse
13:09:35 <sjanssen> dons: yep, a little bit worse
13:09:37 <dons> urgh, i note thread-x is compiled with -O3 !
13:10:00 <dons> man i hate -O3
13:10:29 <jedbrown> dons: From what I've noticed, they are all built with -O3.
13:10:31 <dons> its a very linear test, isn't it sjanssen . so as usual -threaded is a pesimissim in this case
13:10:35 <dons> hmm
13:10:35 <dons> that's bad.
13:10:38 <sjanssen> right
13:10:44 <sjanssen> this is a poor test of concurrency
13:10:59 <jedbrown> I get no difference with -threaded.
13:11:48 <dons> 0.9s on my box, btw :)
13:11:55 <jedbrown> Indeed, it is a terrible test.  But really simple for someone new to Haskell concurrency.
13:11:57 <sjanssen> jedbrown: did you force GHC to rebuild it?  ghc --make isn't smart enough to notice the difference between -threaded and otherwise
13:12:29 <dons> have to 10x the N to get reasonable timing
13:13:00 <jedbrown> When I touch the file, it rebuilds it.  And if I don't it says 'compilation IS NOT required'.
13:13:37 <sjanssen> jedbrown: you can use -no-recomp to force GHC to always rebuild it
13:13:42 <dons> i get better code with some bang patterns
13:13:59 <dcoutts_> jedbrown: or rm the .o and/or .hi files
13:15:01 <dons> yes, a few more percents
13:16:12 <sjanssen> dons: are you using the last code I pasted?  Which variables did you add bang patterns to?
13:16:46 <jedbrown> I see absolutely no difference if I
13:17:03 <hpaste>  dons pasted "bang patterns, 0.4s for N=3M" at http://hpaste.org/3831
13:17:11 <dons> ^
13:17:13 <jedbrown> remove the type signature and bang $! from sjanssen's version.
13:17:19 <dons> make sure you use a reasonable value for N
13:17:22 <hpaste>  sjanssen annotated "shootout thread-ring" with "we don't use the "a" variable" at http://hpaste.org/3829#a5
13:18:46 <scodil> so, my issue with unboxing in the same file versus a different file, should I post that to ghc-users, or what?
13:19:55 <sjanssen> dons: the bang patterns don't approve anything for me
13:20:12 <sjanssen> in fact, they seem to be worse across several test runs
13:20:28 <jedbrown> sjanssen: same for me
13:21:18 <sjanssen> s/approve/improve
13:21:52 <dons> ok. i'm using 6.8, so that might be the variable
13:21:54 <sjanssen> jedbrown: the type signature does matter, you need to run with a much larger N to see it
13:22:02 <sjanssen> I'm also on 6.8.1
13:22:04 <dons> it should matter: Integer would be slower
13:22:10 <dons> i wonder if 64 bits matter
13:22:45 <dons> sjanssen: you're probably on a closer arch to the shootout
13:22:51 <dons> anyway, let's just get something in there.
13:22:53 <jedbrown> sjanssen: I'm on 32 bit and compiling this with 6.6.1 since I assume they don't have 6.8 yet.
13:22:59 <dons> jedbrown: do you know how to submit?
13:23:06 <luqui> > fix $ (0:) . map succ
13:23:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:23:13 <jedbrown> I found the directions.
13:23:43 <mrd> oh boy.  subbing rwhnf for rnf makes the crashing go away.  trouble with seq perhaps?
13:24:10 <dons> mm. mrd, that's super interesting
13:25:13 <jedbrown> Do you really get different performance without the type signature?  It is undetectable across many repeated runs for me.  Could it just be insignificant?
13:26:00 <sjanssen> jedbrown: try running with a larger N, say 60000000
13:26:41 <mrd> dons: it's weird because it's just a list of Doubles
13:26:46 <sjanssen> I bet the difference will be visible on the shootout box, it is probably slower than the machines we're testing on
13:26:59 <mrd> shouldn't parFlatMap rnf on a [Double] be the same as parFlatMap rwhnf?
13:28:01 <jedbrown> sjanssen: Okay, but they only use 3 000 000, so does it matter with larger N versus repeated execution?
13:28:38 <jedbrown> sjanssen: I am on a 1.6 GHz Pentium M so it takes ~2 sec.
13:29:29 <jedbrown> For N = 60 000 000, I get 40.833s for Dons version and 40.542s for yours without the type signature or $!.
13:29:30 <sjanssen> jedbrown: N doesn't matter much, it's just necessary to get a stable result on a fast processor
13:30:00 <sjanssen> jedbrown: yeah, your box should be really close to the shootout box
13:30:03 <jedbrown> sjanssen: true
13:30:12 <sjanssen> jedbrown: and my version with the type signature and $!?
13:30:41 <dons> having the same arch is important too, for gcc tweaks
13:30:59 <dons> once you get the haskell good, start looking at -O2/-O -optc-O2 /-optc-O/-optc-O3 etc
13:31:22 <jedbrown> sjanssen: 39.675s
13:32:18 <sjanssen> jedbrown: perhaps we submit the version without the typesig until somebody beats us on speed? ;)
13:32:23 <dons> yeah
13:32:32 <dons> just get something up there today
13:33:39 <SideFFect> how do I output a string that has a well, string, and a value?
13:34:04 <Lemmih> SideFFect: Convert the value to a string?
13:34:20 <SideFFect> like "Found value x in position: x "
13:34:28 <Toxaris> > "like this, SideFFect? " ++ show 42
13:34:32 <lambdabot>  "like this, SideFFect? 42"
13:35:09 <SideFFect> ahh forgot the show command
13:35:11 <SideFFect> lets try
13:36:13 <Phillemann> Can I look for functions by type here?
13:36:15 <SideFFect> its a putstrln tho right?
13:36:26 <Toxaris> > let try = const (error "failed") in try undefined
13:36:27 <lambdabot>  Exception: failed
13:36:29 <shachaf> @hoogle a -> [a]
13:36:29 <lambdabot> Prelude.repeat :: a -> [a]
13:36:29 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:36:31 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
13:36:37 <shachaf> @where hoogle
13:36:37 <lambdabot> http://haskell.org/hoogle
13:36:56 <Toxaris> SideFFect: well, just try it :) yes, putstrln sounds good
13:37:02 <Phillemann> Ah, hoogle can do this, too. Good. :)
13:37:22 <mrd> ah, no. rwhnf does not do it.  it just becomes rarer.
13:37:27 <SideFFect> ah yeah heh
13:37:29 <SideFFect> works
13:37:33 <SideFFect> silly me
13:37:35 <SideFFect> thanks guys
13:37:40 <shachaf> @faq Hoogle
13:37:40 <lambdabot> The answer is: Yes! Haskell can do that.
13:37:41 * mrd will recompile a newer version of ghc and then submit a ticket
13:39:17 * jedbrown goofed with too many versions of the same file.  It is better with the type signature.
13:46:30 <shapr> yargh!
13:46:35 <shapr> @users
13:46:35 <lambdabot> Maximum users seen in #haskell: 412, currently: 405 (98.3%), active: 22 (5.4%)
13:46:39 <mrd> @yow!
13:46:39 <lambdabot> Couldn't find fortune file
13:46:46 <mrd> @arr
13:46:48 <lambdabot> Swab the deck!
13:47:03 <ski> @quote
13:47:03 <lambdabot> sioraiocht says: maybe we should make #haskell a degree granting institution
13:47:08 <shapr> I agree!
13:47:10 <shapr> @quote
13:47:10 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
13:47:27 <Heffalump> Prestigious degrees from non-accredited IRC channels?
13:47:47 <sioraiocht> I need one, as I'm currently convinced I'm going to fail my current degree =p
13:47:54 <Adamant_> #haskell is the offical channel for Haskell discussion
13:48:13 <Adamant_> that's some kind of accreditation
13:49:26 <fasta> When I am in Emacs mode in ghci, run an expression and do C-c C-c, it doesn't respond immediately. Why not?
13:49:59 <sioraiocht> fasta: if it's stuck executing a C function i believe in can't interrupt until after that returns
13:50:18 <sioraiocht> that's how the lua interpreter works, anyway
13:50:21 <fasta> sioraiocht: how about runProcess?
13:50:52 <fasta> sioraiocht: it appears that multiple runProcess calls after eachother still get run.
13:54:21 <SideFFect> im getting parse error on this line
13:54:22 <SideFFect> if (j+1 == k) then putStrLn("oops") else
13:54:25 <SideFFect> else
13:54:29 <SideFFect> is the error it says
13:55:24 <swiert> SideFFect: try "else return ()"
13:55:43 <fasta> sioraiocht: you got cut-off/
13:55:55 <SideFFect> well I have a line after that
13:56:08 <sioraiocht> fasta: nooo
13:56:12 <SideFFect> else newline tab let h = etc etc
13:56:20 <sioraiocht> fasta: I have no idea about runProcess
13:56:24 <fasta> sioraiocht: oops
13:56:31 <dons> when (j+1 == k) $ print "oops"
13:56:38 <dons> ?src when
13:56:39 <lambdabot> when p s = if p then s else return ()
13:56:47 <dons> :t assert
13:56:49 <lambdabot> Not in scope: `assert'
13:56:55 <dons> ?hoogle assert
13:56:56 <lambdabot> Control.Exception.assert :: Bool -> a -> a
13:56:56 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
13:56:56 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
13:57:09 * fasta thinks assert is pretty pointless. GHC agrees.
13:57:18 <SideFFect> im confused?
13:57:22 <dons> it's useful
13:57:24 <fasta> ASSERT, OTOH, is a nice idea.
13:57:25 <sioraiocht> it hurts me deep inside that even library functions use the goddamn if..then..else syntax
13:57:39 <dons> sioraiocht: instead of case?
13:57:48 <astrolabe> What's wrong with if then else?
13:57:57 <sioraiocht> dons: yeah, or guards, or pattern matching, or anything
13:57:59 <dons> SideFFect: 'when' is a suitable conditional, if there's no default else branch
13:58:00 <fasta> sioraiocht: some people are even annoyed with if then else and define cond
13:58:01 <SideFFect> ill paste my code one sec
13:58:09 <dons> what's wrong with if-then-else, sioraiocht ?
13:58:20 <sioraiocht> dons: it's gross, when you can define if as a function in haskell
13:58:28 <Toxaris> SideFFect: you may have not indented the line after your if-then-else line enough for the compiler to figure out where it belongs
13:58:32 <hpaste>  sideffect pasted "else troubles" at http://hpaste.org/3832
13:58:36 <SideFFect> pasted
13:58:37 <Toxaris> SideFFect (just guessing, of course)
13:58:42 <sioraiocht> dons: i feel like if then else is some throwback to ML
13:58:49 <SideFFect> i think its that too, but I hate the indents :P
13:58:55 <dons> if (x) (y) (z) is too lispy for me :)
13:59:06 <sioraiocht> lol
13:59:13 <magnus___> dons: I have sent in my application to Galois (FYI)
13:59:24 <sioraiocht> well
13:59:25 <dons> magnus___: cool
13:59:33 <sioraiocht> it would be (if (x) (y) (z))
13:59:42 <dons> too lispy by far!
13:59:51 <ski> if x y z
14:00:17 <sioraiocht> haha
14:00:22 <SideFFect> anyone know why my else is generating a parse error?
14:00:28 <astrolabe> So... if then else has nicer precidence properties than if were defined as a function?
14:00:53 <Toxaris> SideFFect: just an idea: you normally don't need nested let-blocks because you can just write everything in the same let-block, and due to laziness, it will be computed in some sensible order
14:00:56 <fasta> astrolabe: you lose some parentheses. That's the only reason it exists, I think.
14:01:07 <SideFFect> so how do I fix it?
14:01:35 <sioraiocht> yes
14:01:37 <sioraiocht> you can't skip a line
14:01:47 <sioraiocht> that denotes a new function body in haskell
14:01:50 <SideFFect> wheres the skipped line?
14:01:54 <astrolabe> fasta: I'm all for conserving parenthesis, but it's a losing battle while the lisp people are so profligate.
14:01:56 <sioraiocht> oh sorry
14:01:59 <sioraiocht> i just looks like ther's one
14:02:03 <newsham> extra parens is more of a pain, but it feels like eating your own dogfood.  ie. haskell touts the fact that laziness lets you define your own control flow constructs from primitives.
14:02:04 <SideFFect> heh
14:02:14 <swiert> SideFFect: I'd rewrite that code using guards.
14:02:30 <newsham> and you can, and there are some in the lib, like 'when'.  but "if" just kinda doesnt want to eat your dogfood.
14:02:31 <SideFFect> I will, but how can I fix this?
14:02:37 <TSC> SideFFect: You have three "then"s, but four "else"s
14:02:41 <newsham> what if there was special syntax for "when" and others?
14:02:42 <fasta> astrolabe: then you should get your own implementation of cond.
14:03:11 <SideFFect> hm
14:03:11 <Toxaris> SideFFect: I tried to rewrite your code and realized that you have 3 else's but only 2 if's
14:03:16 <astrolabe> SideFFect: there are two elses for the first if
14:03:16 <newsham> when (already requires) (more parenthesis)
14:03:20 <fasta> Guards don't compose and are a bad idea, imho.
14:03:24 <SideFFect> yeah I see that
14:03:27 <SideFFect> now
14:03:29 <SideFFect> hm
14:04:04 <newsham> (also "if" cant be passed around :( )
14:04:26 <conal> newsham: yeah. that one bites.
14:04:36 <conal> having to write \ a b c -> if a then b else c
14:04:38 <fasta> swiert: what's the advantage of a guard, given the clear disadvantage that you cannot nest them?
14:05:18 <conal> i've also wanted to overload if for a more general notion of boolean, as have others.
14:05:32 <swiert> fasta: if you have a whole sequence of if-then-elses it might be a bit more comprehensible of writing it using guards.
14:05:47 <Toxaris> faste: you don't need to nest them
14:06:09 <fasta> swiert: that would be a case expression then
14:06:46 <fasta> (which can also contain guards and are useful in that case)
14:06:58 <SideFFect> hm having trouble changing the code
14:07:39 <fasta> Toxaris: you can't nest them, but why wouldn't you need to? (unless you name every single piece of logic in your code)
14:08:19 <swiert> fasta: all I'm saying is if-then-elseif-then-elseif-etc can be written quite a bit nicer using guards.
14:09:48 <fasta> swiert: ok, I was more thinking of  if-then-(if then ... else(...))else)
14:11:05 <Toxaris> fasta: we seem to mean different things with "it". I mean the same as swiert, I think, that guards are fine for expressing naturally linear decision trees
14:12:32 <Toxaris> SideFFect: where lies your problem? think about (1) what cases exist in (2) what to do in each case.
14:13:26 <Toxaris> fasta: additionlly, guards are nice for newbies in my opinion, because they allow to seperate cases very strongly, so if you're not really know what you're doing, you can still begin with some of your cases
14:14:43 <Toxaris> fasta: and guards are handy when implementing rules from some paper literally (for playing with some type system or operational semantics), because these rules are normally written with pattern matching and guards too
14:15:01 <Toxaris> this makes Haskell a nice prototyping language for language designers
14:15:31 <shachaf> jjjjjjjjjjjjjjjjjjjjjjjjjjjjj
14:15:38 <shachaf> Oops.
14:15:45 <fasta> | a && b && c && d && e = f  ; | a && not b && c && d && d = g
14:16:18 <fasta> It's not good fot that, though.
14:16:27 <fasta> (assuming all combinations are used)
14:16:58 <geezusfreeek> > take 29 $ repeat 'j'
14:17:00 <lambdabot>  "jjjjjjjjjjjjjjjjjjjjjjjjjjjjj"
14:17:16 <fasta> for*
14:17:31 <Toxaris> foo True True True True = f; foo True False True True True = g -- we have pattern matching, too
14:17:39 <Zao> > replicate 29 'j'
14:17:40 <lambdabot>  "jjjjjjjjjjjjjjjjjjjjjjjjjjjjj"
14:17:48 <geezusfreeek> dang beat
14:19:14 <fasta> Toxaris: that would look like foo semanticName@True ... in a real program.
14:20:41 <RayNbow> @src cycle
14:20:41 <lambdabot> cycle [] = undefined
14:20:42 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:21:55 <Toxaris> fasta: If all combinations are used, one could name the relation, giving the whole truthtable by someName True True ... = True; someName True False ... = False; (formatted as table, with header line in a comment, ...) and using that relation in guards in the real function. most of the time, not all cases are really different. foo x y z | someName x y z = ...
14:25:37 <Toxaris> > let cond otherwise = maybe otherwise snd . find fst in cond "otherwise clause" [(even 3, "nonsense"), (odd 5, "thats true")] -- for lispy people
14:25:38 <lambdabot>  "thats true"
14:27:58 <Raguel> anyone any good with scaling laws (not haskell) - keep drawing a blank :(
14:28:27 <Toxaris> let cond = snd . fromJust . find fst in cond [(even 3, "nonsense"), (odd 5, "thats true"), (True, "otherwise clause")] -- for even lispier people
14:29:31 <ddarius> case () of _ | even 3 -> "nonsense" | odd 5 -> ...
14:54:09 <hpaste>  dikini pasted "Ambiguous type variable" at http://hpaste.org/3833
14:55:23 <dcoutts> shapr: Igloo remember talking about a low risk consultancy company, see this example: http://codethink.co.uk/
14:55:23 <lambdabot> Title: codethink
14:55:33 <dikini> I wonder how do I resolve that, tried various constraints... to no avail :(
14:55:56 <dons> dcoutts: interesting
14:56:09 <dcoutts> that company looks to be a similar model to what we were discussing
14:56:29 <dcoutts> a collection of experts who can be pulled together to take on a contract/project
14:56:31 <dons> yeah
14:56:34 <dikini> I still don't grok the syntax, I suppose
14:56:53 <Igloo> dcoutts: "We maintain a network of expert consutlants" doesn't fill me with confidence  :-)
14:56:58 <dcoutts> dons: the founder has a blog post explaining the system http://blog.floopily.org/2007/07/06/introduction-to-codethink/
14:56:59 <lambdabot> Title: Stories from the land of Rob  Blog Archive  Introduction to Codethink
14:57:25 <dcoutts> Igloo: as a potential customer you mean?
14:57:39 <dcoutts> Igloo: it's pretty much what we were talking about
14:57:52 <Igloo> dcoutts: The spelling error
14:57:58 <dcoutts> ohh :-)
14:57:59 <dcoutts> hah
14:59:15 <shachaf> dikini: Try adding explicit types?
15:00:18 <dikini> shachaf: like AInfo Integer b -> IO () ?
15:00:39 <shachaf> dikini: Yes.
15:00:48 <shachaf> dikini: (Where is EActors?)
15:01:22 <dikini> i didn't paste it since it's a bit larger...
15:01:59 <dikini> ~90lines, don't know the etiquette :)
15:02:37 <chessguy> @paste
15:02:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:03:07 <hpaste>  (anonymous) pasted "EActors" at http://hpaste.org/3834
15:03:19 <dikini> I trimmed the comments, a bit
15:04:37 <dikini> It's my first haskell program, I chose something complex enough to learn, but small enough not to get too lost
15:06:45 <dikini> can I put constraints on a lambda definition?
15:06:58 * Cale looks
15:10:44 <Cale> dikini: ah, you need to restrict the type of m there?
15:10:51 <mrd> @hoogle bracket
15:10:52 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:10:52 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
15:10:52 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
15:11:33 <Cale> dikini: You can probably just add a type signature to m itself, and that will fix the types of a bunch of other things.
15:11:48 <Cale> print (m :: Int)
15:13:02 <Cale> dikini: The trouble is just that print could print all sorts of things, and the rest of the program isn't enough to determine what sort of thing m is, so it doesn't know which stringifying code to use.
15:13:48 <dikini> yeah, I got that, but no luck
15:14:35 <dikini> it is the same error message - ambiguous type variable, in the same place
15:15:03 <astrolabe> \msg dons I notice #haskell is ranked 12th on freenode at the moment, but on the stats page you note it as 13th as of Aug.
15:15:05 <dikini> I think I wrote a nice noodle soup
15:15:07 <astrolabe> oops
15:16:25 <Cale> dikini: hmm
15:16:46 <Cale> dikini: that's interesting. It's exactly the same message?
15:17:09 <Cale> Here, I'll grab the code and try it :)
15:17:27 <dikini> yes
15:17:34 <dikini> thanks
15:20:26 <dons> http://www.intellifactory.com/Home.aspx
15:20:26 <lambdabot> Title: Home
15:20:39 <dons> "Kick-start your development team to exploit the benefits of functional programming"!
15:21:08 <Cale> oh!
15:21:14 <Cale> print Nothing
15:21:31 <Cale> hehe, it doesn't know which show to use there either
15:21:45 <Cale> print (Nothing :: Maybe Integer)
15:21:49 <Cale> will work fine
15:21:57 <Cale> Or just:  putStrLn "Nothing"
15:23:08 <Cale> When I run your program, I get a non-exhaustive patterns in case error, from "forward" in EActors.hs
15:23:21 <Cale> You've only handled the case when g is False there
15:24:12 <dikini> do you need to do full specification? I assumed fallthrough would be fine
15:24:46 <Cale> No, there's nothing to fall through to there -- you read the action which is the result of the case as being spliced in on that line.
15:24:54 <mrd> ooh Brouwer stamps
15:25:39 <Cale> case isn't specialised at all for the case when it's producing an action in a monad -- it will just give an error if the pattern match fails
15:25:47 <Cale> however
15:25:56 <Cale> The solution is fairly easy
15:25:57 <scook0> couldn't you just use unless?
15:26:09 <Cale> yeah, you can :)
15:26:23 <dikini> i could...
15:26:32 <scook0> oh, and return (forward from to) isn't doing what you probably think it does
15:26:33 <Cale> Or else add a true case with that return ()
15:26:58 <dikini> heh, won't be surprised
15:28:32 <ndm> hiya
15:28:36 <waern> hi
15:28:38 <Cale> hello
15:28:44 <hpaste>  scook0 annotated "EActors" with "how about this "forward"?" at http://hpaste.org/3834#a1
15:28:47 <ndm> i'm not allowed to write "argCAF = realWorld#" as a top-level binding
15:28:51 <ndm> because: Top-level bindings for unlifted types aren't allowed
15:28:57 <ndm> the question is why aren't they allowed?
15:29:06 <scook0> (I hope that works)
15:29:19 <ndm> if there is a good reason, then i don't mind, otherwise it seems like yet another ad-hoc hoop to jump through
15:29:21 <Pseudonym> ndm: Implementation issues.
15:29:38 <ndm> Pseudonym: are they actually hard to implement? or is it just that no one has?
15:29:40 <Pseudonym> Essentially, every top-level binding has kind *.
15:29:51 <Pseudonym> Well, what if you exported it?
15:30:02 <ndm> but realWorld# must be a defined top-level binding that is exported
15:30:12 <Pseudonym> Or a built-in.
15:30:21 <dons> its primitive
15:30:22 <Pseudonym> Lots of dumb things are built-ins in GHC.
15:30:24 <Cale> You'll need to add an import of Control.Monad, but other than that it seems to work okay
15:30:40 <ndm> yes, its primitive, but i can't define an alias to it, which is all i want
15:31:00 <dons> extend the type system to allow type aliases for unlifted types, first :)
15:31:00 <ndm> i'm just surprised its so built in that you can't even get as close as defining something remotely similar
15:31:27 <dons> check the unboxed values as first class citizens paper
15:31:34 * ndm does some type hacking ;-)
15:31:56 <ndm> does it say why they are only second class citizens?
15:31:56 <waern> ndm: do you still want the hoogle back-end to work in haddock 2
15:31:58 <Pseudonym> I _suspect_ that if you exported it, you'd fall into problems like having to put the kinds of exported bindings in the .hi files.
15:32:05 <ndm> waern: very much so :)
15:32:07 <dikini> hey! it prints something! now I have to make this actually not waste cpu
15:32:18 <ndm> Pseudonym: i have absolutely no desire to export it :)
15:32:19 <waern> ndm: okay, it's currently the only thing that is not merged over to Haddock 2
15:32:20 <dikini> thanks a lot
15:32:38 <ndm> waern: its ok if it follows later, i.e. in 2.1 or something
15:32:46 <waern> right
15:32:47 <ndm> i.e. don't hold a release over it
15:32:48 <Cale> dikini: You should probably be aware that forward and get can block
15:33:40 <dikini> Cale: why?
15:33:45 <Cale> dikini: If the Chan is initially full when isEmptyChan is applied, but something reads from it before control passes to the readChan below, then it may be empty and the readChan will block.
15:34:22 <dikini> Cale: ok, I haven't thought about such use
15:34:42 <Cale> That is, forward isn't atomic, so you have to assume that anything can happen in between each of the lines.
15:35:01 <dikini> My idea is to keep the knowledge of the channels local
15:35:34 <dikini> although nothing would stop a 'bad' client to read from not it's own channel
15:35:37 <Cale> One idiom which is rather nice is not to pass around channels themselves, but readChan and writeChan applied to them.
15:35:49 <Cale> (like passing around the two ends of the channel separately)
15:36:11 <Cale> Another way to solve this problem is just to use STM and TChans, where it can't arise.
15:36:23 <dikini> yep, I've done this in scheme
15:36:59 <luqui> can you do either of those tricks in scheme?
15:37:00 <dikini> I intentionally don't want to use STM - there shouldn't be any need for failure
15:37:07 <dikini> not STM
15:37:22 <dikini> wrapping a port with a reader - yes
15:38:05 <Cale> Hmm, I'm not sure what you mean by failure...
15:38:07 <Skyp> hm, defining a binary tree datatype with integer elements in haskell was easy... data Tree = Tree Integer Tree | Empty... But I have some problems if I want an arbitrary datatype as elements... I tried: data Tree a = (Tree a) a (Tree a) | Empty , but that didn't work...
15:38:11 <Cale> You mean retry?
15:38:18 <Cale> You can just not call retry :)
15:38:24 <dikini> yes
15:38:43 <Cale> Skyp: Maybe your old definition is still around?
15:38:47 <Skyp> Ok, I actually wrote data Tree = Node ..
15:38:51 <LoganCapaldo>  skyp you need a ctor or that first alternative
15:38:59 <Cale> Oh, heh, right :)
15:39:01 <Skyp> LoganCapaldo: yes, I mistyped that
15:39:14 <Skyp> I used Node as first ctor
15:39:22 <Cale> data Tree a = Node (Tree a) a (Tree a) | Empty
15:39:25 <luqui> Skyp, how did it not work?
15:39:25 <luqui> oh
15:39:29 <dikini> but why use STM and TChan, if not really required?
15:39:31 <Cale> That should be perfectly valid.
15:40:05 <Cale> The only reason I can think it might fail is if your other Tree type still exists -- you can't name them both the same thing
15:40:32 <Cale> dikini: Well, it prevents lots of hard to see bugs.
15:40:33 <Skyp> hm, right... darn, I should read the line numbers of the error messages...
15:41:07 <Skyp> show (Node l e r) = "(" ++ show l ++ ", " ++ show e ++ ", " ++ show r ++ ")" <- here he chokes with "Illegal type in class constraint"
15:41:11 <dikini> Cale: yes, but bugs teach...
15:41:14 <Skyp> but why?
15:41:42 <Cale> Skyp: What's the instance head look like?
15:41:51 <Cale> instance Show a => Show (Tree a) where
15:41:51 <Cale> ?
15:42:37 <Skyp> Cale: that works... thanks ;)
15:42:39 <dikini> Cale: I was considering STM and TChan to implement bounded channels, but I'm afraid it will just add to the complexity
15:42:56 <gabor_> dons: may I plug my blog? ;-)
15:43:16 <Cale> dikini: It's not really so hard. :)
15:43:30 <Skyp> Cale: Is there a short explanation what that means? I admit, I don't fully understand that ;)
15:43:54 <Cale> Skyp: it means, "If there's an instance of Show a, then there's an instance of Show (Tree a)"
15:44:13 <gabor> dons: http://heisenbug.blogspot.com/2007_11_01_archive.html
15:44:14 <lambdabot> Title: don't count on finding me: November 2007
15:44:18 <Cale> Skyp: If you can't show the elements of the tree, then it's hard to show the tree itself.
15:44:24 <Skyp> Cale: ah, ok... so if there is a Show Char, this definition is valid vor Show (Tree Char)
15:44:29 <Cale> yeah
15:44:39 <Skyp> thx ;)
15:44:41 <dikini> Cale: it is not about hard - more about I'm trying to avoid locks and synchronisation,  being content with 'infinte' channels
15:45:40 <dikini> basically, trying to do erlang style processes
15:46:26 <dikini> I'm pleasantly surprised - a total haskell newbie in a couple of days struggling with syntax, doing a half decent job of it
15:46:49 <kfish> gabor, interesting :-)
15:47:21 <gabor> kfish: thx :-)
15:48:22 <dons> nice gabor
15:48:23 <Cale> gabor: where does the name Thrist come from?
15:48:40 <gabor> (type)treaded list
15:48:45 <delaril> hi guys
15:48:49 <gabor> (type)threaded list
15:49:06 <Cale> ah, okay
15:49:11 <Cale> delaril: hello
15:49:21 <dons> gabor: there you go, http://programming.reddit.com/info/60fsx/comments/
15:49:27 <gabor> the name is my invention
15:49:40 <gabor> dons :-)
15:50:16 <gabor> the paper also coins the name "Dominoes of Data"
15:50:33 <delaril> this is probably going to sound a bit silly, but would anyone care to explain why this - http://hpaste.org/3835 - works?
15:50:34 <gabor> but it is still from being done
15:51:05 <gabor> still *far* from
15:51:30 <Cale> delaril: sure
15:51:35 <TomMD> delaril: I don't see any issue with that.  I suggest you read YAHT.
15:51:42 <TomMD> or listen to Cale
15:51:45 <delaril> TomMD: hehe, that's what I'm doing
15:51:51 <delaril> TomMD: it's an example from YAHT
15:52:00 <Cale> delaril: If you have any list, it's either the empty list, or it's a nonempty list, formed by adding an element to the start of another list
15:52:05 <TomMD> ok, thought it looks similar from when I was learning.
15:52:36 <Cale> delaril: So if the list passed to my_length is empty, the first pattern matches, and my_length [] gives 0
15:53:15 <Cale> delaril: If it's nonempty, then the pattern (x:xs) matches the list, binding the head of the list to x, and the tail of the list to xs
15:53:32 <delaril> that's what I don't understand
15:53:37 <Cale> okay
15:53:51 <Cale> > let f (x:xs) = (x,xs) in f [1,2,3]
15:53:52 <delaril> why/how does the tail get bound to xs?
15:53:53 <lambdabot>  (1,[2,3])
15:54:02 <Cale> because that's just how pattern matching works
15:54:06 <Cale> > 1 : [2,3]
15:54:06 <lambdabot>  [1,2,3]
15:54:41 <Cale> The operator (:) is a data constructor, and hence it can be used in expressions to put lists together, and in patterns, to take them apart again.
15:55:15 <Cale> > let f (x:xs) = (x,xs) in f (1 : [2,3])
15:55:16 <lambdabot>  (1,[2,3])
15:55:46 <Cale> Remember that really, the list [1,2,3] is syntax sugar for 1 : 2 : 3 : []
15:55:57 <Cale> that is,
15:56:05 <Cale> 1 : (2 : (3 : []))
15:56:28 <Cale> and so when pattern matched against the pattern (x:xs)
15:56:31 <Cale> x = 1
15:56:37 <Philippa> performance question: how does Data.Map perform for very small maps?
15:56:39 <Cale> xs = 2 : (3 : [])
15:56:42 <Philippa> (1-3 entries, say)
15:56:48 <delaril> Cale: aha
15:57:04 <Cale> bbiab, I have to eat dinner :)
15:57:06 <Philippa> I have a suspicion I've got a case where I'm better off using an association list
15:57:16 <delaril> Cale: thanks, bon appetit
15:57:30 <Cale> Philippa: I think not so bad, but association lists often do a bit better for very small lists like that
15:58:12 <Philippa> *nod* - plus there's the construction overhead, and there aren't going to be too many lookups per construction
15:58:20 <ndm> Philippa: certainly worse than association lists, and they store sizes etc
15:58:28 <Pseudonym> Are you planning to modify the maps a lot?
15:58:31 <Pseudonym> Or just build them once?
15:59:05 <Pseudonym> Like what operations do you plan to use?
15:59:10 <ski> Thrist++
15:59:50 <dons> ?tiny-url http://heisenbug.blogspot.com/2007_11_01_archive.html
15:59:50 <lambdabot> http://tinyurl.com/2f2unh
15:59:52 <dons> stupid reddit
16:00:01 <TomMD> ?
16:00:16 <dons> http://programming.reddit.com/info/60fto/details
16:01:47 <TomMD> So how does that make reddit stupid?
16:03:19 <dons> oh, reddit blocks blogspot links
16:03:39 <Excedrin> why is that?
16:05:20 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lax-0.0.0
16:05:21 <lambdabot> http://tinyurl.com/2overn
16:05:23 <dons> curious
16:06:33 <salierix> dons, do you happen to know when the language shootout people removed the cheap concurrency benchmark?
16:06:43 <Adamant_> a lot of such sites block links from sites they don't particularly like.
16:06:52 <dons> salierix: they renamed it thread-x
16:06:55 <Pseudonym> "I assumed that all the homework you assigned me was Abelian, so I thought that I could pass it in and then do it."
16:07:16 <ricky_clarkson> Has reddit said why they block blogspot?
16:09:24 <salierix> It seems Haskell lost a few spots on the overall list recently.
16:09:42 <Adamant_> digg blocks several political sites they don't like. I don't think they've ever really explained why.
16:10:29 <conal> dons: i'm using your dlist.  list accumulation parameter is a classic, simple technique, and nice to have as a library, to keep the interface simple.  i'd like to see it used for ShowS.
16:10:38 <dons> that's a good idea.
16:10:47 <dons> conal: its also rather excellent inside Writer, i was informed
16:11:09 <dons> its such a classic library, as you say, perhaps we should reuse it from base :)
16:11:42 <conal> dons: exactly
16:12:57 <conal> btw, have you read mitch wand's lovely 1980 paper on the general topic?
16:13:02 <conal> http://www.citeulike.org/user/conal/article/1625484
16:13:03 <lambdabot> Title: CiteULike: Continuation-Based Program Transformation Strategies
16:13:29 <dons> no! I wasn't aware of this. thanks, conal
16:13:41 <conal> super-inspiring for me.
16:14:22 <conal> i'm looking for an online version.
16:18:24 <ddarius> "edited by Peyton S Jones"
16:20:14 <TSC> Doesn't that link to an online version?
16:20:25 <goalieca> probably need to login.
16:20:34 <goalieca> i just picked it up through my schools library proxy
16:20:37 <ddarius> It links to the ACM library
16:20:59 <goalieca>  Volume 27 ,  Issue 1  (January 1980)
16:21:09 <ddarius> I don't remember if I was or wasn't able to get that earlier.
16:21:27 <TSC> Maybe my proxy did magic, but I didn't have to login to ACM
16:22:38 <goalieca> yeh.. i just add .proxy.lib.sfu.ca after the acm.com and bam.
16:23:07 <waern> I found it: http://www.diku.dk/undervisning/2005e/224/papers/Wand80.pdf
16:31:10 <nominolo> TSC many universities give free access to ACM
16:31:36 <TSC> Yeah, but I thought in the past I had to login explicitly to get at it
16:31:53 <TSC> Maybe I'm just thinking of somewhere else, like springer
16:32:21 <nominolo> on citeulike you can add your own copy
16:32:58 <nominolo> but you need to add it via a link to some official site, so that it can extract the meta-information on its own
16:33:49 <conal> found one: http://www.diku.dk/undervisning/2005e/224/papers/Wand80.pdf
16:33:56 <conal> it's a scan.
16:33:58 <ddarius> Little late.
16:33:59 <sprinky> Hey #haskell, I am trying to get the collections package to install from portage, but I get an error saying the package bytestring is hidden. I tried using ghc-pkg expose <packagename>, but it hasn't worked...
16:34:52 <conal> ddarius: oh yeah
16:35:52 <conal> as i remember, there's a general idea of massaging code into a continuation form and finding a data representation of the continuation.
16:36:19 <ddarius> @google Danvy abstract machines
16:36:19 <lambdabot> http://citeseer.ist.psu.edu/733073.html
16:36:20 <lambdabot> Title: A Functional Correspondence between Monadic Evaluators and Abstract Machines . . ...
16:36:46 <ddarius> That set of papers is extremely cool.
16:37:06 <ddarius> Though, that's not exactly the one I was aiming for.
16:37:57 <ddarius> http://www.brics.dk/RS/03/Abs/BRICS-RS-03-Abs/BRICS-RS-03-Abs.html#BRICS-RS-03-13
16:37:59 <lambdabot> Title: BRICS Research Series, Abstracts, 2003, http://tinyurl.com/2bora7
16:38:00 <ddarius> That's the start.
16:39:48 <conal> Does anyone know of a particularly efficient way to map a sequence of Arrays into a single (appended) array?  Really I'll have a sequence of streams of arrays (constant size within a stream), and I want a stream of single (appended) arrays.
16:43:41 <ricky_clarkson> @t Array
16:43:41 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:43:45 <thoughtpolice> @seen ac
16:43:45 <lambdabot> ac is in #haskell-blah and #haskell. I don't know when ac last spoke.
16:43:54 <ricky_clarkson> @type Array
16:43:56 <lambdabot> Not in scope: data constructor `Array'
16:44:20 <LoganCapaldo> @kind Array
16:44:21 <lambdabot> * -> * -> *
16:44:28 <nominolo> sprinky: it's probably a missing "bytestrings" in the .cabal file.  no idea how to fix that on gentoo though
16:45:16 <thoughtpolice> @tell ac btw, my blog is back up in case you're still interested in the ghc api thing: http://austin.youareinferior.net/?q=node/29
16:45:16 <lambdabot> Consider it noted.
16:45:17 <sjanssen> conal: a stream of constant sized arrays, similar to lazy bytestrings?
16:45:18 <sprinky> nominolo: I built bytestring and the missing module (Data.ByteString.Lazy), and it's exposed in package.conf, but oddly enough, collections still can't seem to find the module.
16:45:45 <nominolo> sprinky: yeah. that's because it's not specified in the collections.cabal
16:45:47 <conal> sjanssen: yes, constant sized, i.e., one size per stream.
16:46:45 <nominolo> sprinky: it's because bytestrings has been removed from base in 3.0
16:47:19 <nominolo> sprinky: and the collections package hasn't been updated for ghc 6.8 yet (or at least not the gentoo ebuild)
16:47:24 <conal> thoughtpolice: have you updated your ghc api stuff to 6.8.1 yet?
16:47:40 <sprinky> nominolo: I'm building it from source.
16:47:42 <thoughtpolice> conal: the metaplug lib? yeah, I have a copy that should work on 6.8.1
16:47:46 <thoughtpolice> it needs some tweaks though
16:48:02 <thoughtpolice> conal: i'm still trying to work out the entire 'unload code from memory so you can load new code' deal
16:48:06 <thoughtpolice> but i think i might have found a solution
16:48:09 <thoughtpolice> just needs to be tested
16:48:13 <nominolo> sprinky: ok, then.  just add bytestrings to the build-depends field in the .cabal file
16:48:36 <conal> thoughtpolice: super.  good luck.  i'm interested in playing with it when it's ready.  to help me with a code-generator for Eros.
16:48:48 <thoughtpolice> it's on my windows box though, so I still need to push the patches to linux before I really continue (I find it pretty discomforting to program in windows these days)
16:48:58 <thoughtpolice> conal: if anything i'll ask glasgow-haskell-users :) they might have better ideas
16:49:11 <sprinky> nominolo: In collections.cabal or bytestring.cabal? I have the source for both...
16:49:17 <conal> thoughtpolice: good idea.  also #ghc
16:49:19 <nominolo> sprinky: collections.cabal
16:49:28 <thoughtpolice> conal: i'll keep you posted though. if I get that whole thing worked out, I'll @tell you :)
16:49:58 <conal> thoughtpolice: thanks :)
16:50:15 <nominolo> conal: how do you generate code?
16:50:23 <nominolo> via C + gcc?
16:50:55 <conal> nominolo: i don't, currently.  an earlier version used hs-plugins to compile & load generated haskell code.
16:51:34 <thoughtpolice> conal: but the metaplug lib is currently held back mainly by the monomorphism restriction; I was talking to someone here earlier and I think a better approach would be to start looking around compiler/main, and hacking on the GHC API itself to support better facilities for hot-code loading (basically make it a backend to something like hsplugins)
16:51:48 <nominolo> i might need to write an LLVM parser for my master's thesis.  but that should be a good start to also generate LLVM code
16:51:55 <sprinky> nominolo: I added the module to collections.cabal, but now when I try to build it, it's telling me it can't find the module 'Data.Set', which is in the collections package itself.
16:51:59 <conal> nominolo: Pan generated C code, and Pajama generated java.  i'd rather go through haskell & ghc and see how much perf i can get.
16:52:00 <sprinky> This is getting weird.
16:52:16 <nominolo> conal: ok
16:52:21 <nominolo> sprinky: indeed
16:52:31 <sprinky> nominolo: Any way to fix?
16:52:43 <nominolo> sprinky: isn't collections usually distributed with ghc 6.8.1?
16:52:47 <thoughtpolice> and because of the 12 month release cycle, I think I might have some adaquate time to look into it. if I decide to pursue, i think it'd really help everybody (lets face it: hs-plugins style facilities are pretty cool)
16:52:51 <conal> thoughtpolice: spj said recently that he wants input on the ghc-api.
16:53:02 <conal> thoughtpolice: 12 month?
16:53:08 <sprinky> nominolo: Lemme check
16:53:10 <thoughtpolice> yeah, for major releases anyway
16:53:29 <conal> thoughtpolice: i see.
16:53:29 <nominolo> sprinky: so the workaround would be to compile ghc yourself
16:53:41 <sprinky> nominolo: Are you not thinking of containers? Cause I do have that package.
16:53:41 <thoughtpolice> i don't know if such a change (I don't know much about the internals, supporting that could be a huge overhaul) would be appropriate for 6.8.2
16:53:44 <nominolo> sprinky: took about 30min with make -j2
16:53:51 <nominolo> sprinky: oh, right
16:54:09 <nominolo> sprinky: right, then you also need to add containers to the build-depends
16:54:29 <thoughtpolice> conal: yes I've heard, in particular I heard about moving liskell to be a ghc api user and how it's more "there" rather than "designed."
16:54:43 <thoughtpolice> it's definately, definately worth looking into.
16:55:15 <sprinky> nominolo: It asked for another package, and I added that one too, now it's finally building :D
16:55:41 <nominolo> sprinky: yeah, it's due to the base package being split up
16:55:51 <sprinky> Now install is giving me another message saying it can't find the module Data.Collections with any suffix.
16:56:05 <nominolo> sprinky: and we don't have a nice solution yet to fix all those packages quickly
16:56:22 <chessguy> @type liftM (+ 1) Just 3
16:56:23 <lambdabot> forall a. (Num (Maybe a), Num a) => Maybe a
16:56:28 <conal> thoughtpolice: that's what i hear from spj also: there isn't really a design yet.
16:56:38 <chessguy> @type liftM ((+) 1) Just 3
16:56:38 <lambdabot> forall a. (Num (Maybe a), Num a) => Maybe a
16:56:39 <Taral> @type liftM (+1) (Just 3)
16:56:39 <lambdabot> forall a1. (Num a1) => Maybe a1
16:56:43 <delaril> good night folks
16:56:50 <nominolo> thoughtpolice: it's mainly that the requirements aren't that clear
16:57:11 <nominolo> sprinky: hm, no idea
16:57:13 <chessguy> liftM ((+) 1) $ Just 1
16:57:23 <chessguy> > liftM ((+) 1) $ Just 1
16:57:24 <lambdabot>  Just 2
16:57:25 <sprinky> nominolo: That's a real bummer...
16:57:30 <Taral> > liftM (+1) $ Just 1
16:57:30 <lambdabot>  Just 2
16:57:35 <conal> on ghc-api, for instance, i'd like to compile from abstract syntax rather than concrete syntax.
16:57:50 <sprinky> nominolo: Oh wait, it looked like the module failed to build in the first place.
16:57:55 <goalieca> > liftM (+1) $ Nothing
16:57:55 <lambdabot>  Nothing
16:57:56 <sprinky> Looks like 5 of them failed.
16:58:16 <conal> > (+1) `fmap` Just 1
16:58:17 <lambdabot>  Just 2
16:58:25 <conal> > (+1) <$> Just 1
16:58:25 <lambdabot>  Just 2
16:58:34 <goalieca> > Nothing + 2
16:58:34 <lambdabot>   add an instance declaration for (Num (Maybe a))
16:58:34 <lambdabot>     In the expression: Noth...
16:59:28 <goalieca> @src liftM
16:59:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:59:54 <goalieca> @t liftM
16:59:54 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:00:02 <goalieca> @type liftM
17:00:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:01:05 <chessguy> @pl (\x -> x + 2) `fmap` Just 3
17:01:05 <lambdabot> (2 +) `fmap` Just 3
17:02:12 <IvdSange1> @src liftM2
17:02:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:04:37 <Taral> chessguy: What are you looking for?
17:04:52 <chessguy> just playing around
17:05:21 <nominolo> :t Map.minView
17:05:25 <lambdabot> Couldn't find qualified module.
17:05:30 <nominolo> :t Data.Map.minView
17:05:30 <lambdabot> forall k a (m :: * -> *). (Monad m) => Data.Map.Map k a -> m (Data.Map.Map k a, (k, a))
17:06:11 <dons> nsieve-bits benchmark is 20% faster with ghc 6.8
17:08:05 <dons> binary-trees is 25% faster
17:09:06 <Excedrin> I have a simple mathy program that I'd like to speedup, what's the best way to get some feedback about it?
17:09:17 <Excedrin> mailing list? or just hpaste here?
17:10:00 <chessguy> either one
17:10:03 <chessguy> Excedrin,
17:10:18 <chessguy> probably faster to ask here
17:10:37 <SamB_XP> but might get better answers on the list
17:11:34 <Taral> is ghc 6.8 for debian in the pipeline?
17:13:51 <mrd> Taral: it's in haskell-unsafe
17:14:07 <Taral> is it? http://haskell-unsafe.alioth.debian.org/archive/i386/unstable/g/ghc6/
17:14:08 <lambdabot> Title: Index of /archive/i386/unstable/g/ghc6, http://tinyurl.com/2ujfj4
17:14:39 <mrd> amd64 were uploaded
17:15:06 <Taral> ah, good
17:15:08 <Taral> I use amd64 anyway :D
17:15:43 <dons> fannkcuh 5% faster
17:15:59 <hpaste>  Excedrin pasted "optimization help" at http://hpaste.org/3836
17:16:13 <dons> the threaded stuff seems a bit slower, as sjanssen observed
17:16:21 <dons> but everything else seems 5-25% faster
17:16:57 <sjanssen> 6.8 is great :)
17:16:59 <sjanssen> ghc++
17:17:13 <ddarius> ?karma ghc
17:17:13 <lambdabot> ghc has a karma of 5
17:17:15 <thoughtpolice> seconded. :)
17:17:17 <thoughtpolice> ghc++
17:18:06 <Excedrin> I'm sure there's some things there that are obvious, but I've tried a few different things without big improvements
17:18:58 <Taral> yay 6.8!
17:19:01 <Taral> ghc++
17:19:04 <Taral> ?karma ghc
17:19:04 <lambdabot> ghc has a karma of 7
17:19:14 <Taral> amd64++
17:19:19 <Taral> ?karma amd64
17:19:19 <lambdabot> amd64 has a karma of 1
17:20:22 <sjanssen> Excedrin: the (start, end) tuple may be an issue
17:21:09 <sjanssen> Excedrin: if you want to guarantee that GHC will unbox those Ints, drop the tuple and put bang patterns on them
17:21:15 <Excedrin> ok
17:21:31 <Excedrin> I can't guarantee anything, but that's an easy change to try
17:21:52 <EvilTerran> ?hoogle flop
17:21:52 <lambdabot> No matches found
17:22:36 * EvilTerran wanted something flip-esque
17:33:51 <ddarius> > let flipflop rs ss = (qs,q's) where nand a b = not (a && b); qs = zipWith nand rs (False:q's); q's = zipWith nand ss (False:qs) in flipflop (False:False:False:True:repeat False) (True:False:False:False:False:False:True:repeat False)
17:33:55 <lambdabot>  ([True,True,True,False,True,True,True,True,True,True,True,True,True,True,Tru...
17:34:38 <Brian`> hey guys
17:34:40 <Brian`> I have a question
17:34:50 <scook0> shoot
17:34:53 <Brian`> i was reading about Functional Reference at http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
17:34:55 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
17:35:20 <Brian`> and I was wondering why I couldn't do :t fst (1,2)
17:35:38 <Brian`> the compiler says couldn't match the type
17:35:42 <ddarius> :t fst (1,2)
17:35:43 <lambdabot> forall t. (Num t) => t
17:35:56 <Brian`> no i mean actually that fst is different from the one in prelude
17:36:03 <Brian`> you should see the website
17:36:35 <sjanssen> Brian`: you've got to write "get fst (1, 2)"
17:36:37 <conal> Brian`: that fst isn't a function, so you can't apply it
17:36:42 <conal> yeah, that
17:37:43 <Saizan_> you can use it as a function if you redefine it using ref
17:38:03 <Brian`> type of fst is FRef (x,y) x
17:38:14 <Brian`> but how come we can only apply (1,2) to fst?
17:38:25 <Brian`> man ; I'm kinda confused. I don't even know what question I have lol
17:40:34 <Saizan_> Brian`: a FRef is not a function, so you can't apply it directly to anything, but you can use get (or set) to extract the function stored inside
17:41:21 <ddarius> Brian`: What is the type of fst, what is the type of get fst, what is the type of (1,2)?
17:42:17 <Brian`> ddarius, type of get fst is (x,y) -> x and type of (1,2) is (x,y)
17:42:22 <Brian`> so.. i c what you mean lol
17:42:23 <pjd> Brian`: terminology-wise, you apply fst to (1,2), not the other way around :)
17:42:38 <Brian`> pjd, ah.. i c
17:49:27 <jeevas> hey guys
17:49:44 <TomMD> OT: I have a problem linking apps (Frag) that use GLUT.  Does anyone know what .deb package I need?
17:49:45 <jeevas> I got a *hopefully* quick question
17:50:22 <Saizan_> ask it :)
17:50:32 <jeevas> In logic, what does the '~' symbol mean
17:50:43 <jeevas> as in (t1 ~ t2)
17:51:13 <TomMD> What paper or text are you reading?
17:51:26 <jeevas> Typing Dynamic Typing
17:51:33 <Saizan_> in that context it looks like some kind of equivalence relation
17:51:43 <jeevas> Ahh
17:52:26 <jeevas> Thats what I thought - but wasn't entirely sure
17:52:28 <jeevas> cheers
17:52:42 <TomMD> jeevas: Thanks for the paper ;-)
17:53:10 <jeevas> TomMD: no prob
17:53:28 <Saizan_> whose is it?
17:53:54 <TomMD> Baars, Swierstra
17:54:08 <jeevas> The paper? Its by Arthur 1. Baars and S Doaitse Swierstra
17:57:55 <Excedrin> sjanssen: it seems to be the same with or without the tuple
17:58:17 <sjanssen> Excedrin: not incredibly surprising, GHC is quite clever
18:01:16 <TomMD> We need a new library in base (yes, I know, base is being broken up).  I want to write code like:
18:01:16 <TomMD> import Data.Customer
18:01:16 <TomMD> main = let s = specifications customerBrain ; desiredActions <- s ; let act = sort desiredActions ; sequenceM_ act
18:02:50 <Saizan_> ?index unsafeAt
18:02:51 <lambdabot> bzzt
18:03:07 <Saizan_> ?type Data.Array.unsafeAt
18:03:08 <lambdabot> Not in scope: `Data.Array.unsafeAt'
18:09:21 <Brian`> hi
18:09:26 <Brian`> another question from the same website http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
18:09:27 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
18:09:30 <b4d_ass> how in the hell do i make tokens??? i used all mine
18:09:38 <Brian`> update has type signature update :: FRef s a -> (a -> a) -> (s -> s)
18:09:47 <Brian`> and its definition is update ref f s = set ref (f (get ref s)) s
18:10:02 <Brian`> but doesn't update accepts two arguments and return a function of type (s -> s)?
18:10:12 <Brian`> how come the definition of update involves three arguments?
18:11:52 <TomMD> How come yi built but then fails when it can't load up haskell libraries? (gtk and vty both fail) This seems slightly broken - am I being dense?
18:12:23 <waern> Brian: because it returns a function
18:12:41 <hpaste>  Hyjiasdas pasted "army repair swiss watch" at http://hpaste.org/3838
18:12:51 <shapr> mmm, spam
18:13:24 <Brian`> waern, that's what i thought but the definition involves three arguments..
18:13:32 <TomMD> Hummm... should we have posters write a valid line of haskell code to do something trivial before the post is accepted?
18:13:47 <waern> Brian: the third argument is the argument to the function that is returned when update is only given two arguments
18:13:50 <Brian`> :t (+)
18:13:50 <lambdabot> forall a. (Num a) => a -> a -> a
18:13:56 <TomMD> That would be a mean catch-22 for those just learning :-)
18:13:57 <Excedrin> I guess ufoldl and usum are the number one time consumers in my program, which is surprising, I thought it would be the array copy/update
18:15:36 <waern> Brian: this defines a function: f x = something. "update ref f s = something" defines the function update ref f, i.e the function you get when you apply udate to two arguments
18:16:12 <waern> Brian: so in that example "update ref f" can be seen as f, and s as x
18:16:35 <Brian`> hm..
18:17:19 <Brian`> aha~
18:17:21 <Brian`> i c what you mean now
18:17:28 <Brian`> so since "update ref f" returns a function
18:17:37 <Brian`> the last s is an argument to that function
18:17:38 <Brian`> right?
18:17:48 <waern> yep!
18:17:52 <Philippa> someone remind me how to build a type-level fixpoint?
18:17:54 <waern> so we are defining the returned function
18:17:54 <Brian`> awesome! thanks waern
18:18:04 <waern> Brian: you are welcome :)
18:18:11 <gwern> aw man. dons' new sumfile program really works better. it's now 1.4-2.5 seconds, easily competitive with clean's 2.74 seconds
18:18:17 <LoganCapaldo> newtype Mu t = Mu (t Mu) ?
18:18:26 <gwern> we;re going to totally clean up on the programming language shootout when they get 6.8
18:18:46 <LoganCapaldo> err Mu (t (Mu t))
18:18:51 <LoganCapaldo> no?
18:19:17 <Philippa> ah, dammit, I'll have to do all the boxing by hand, right? Bah
18:19:53 <gwern> is 'print' equivalent to 'putStr . show'?
18:19:58 <Philippa> oh well, this is what I get for trying to be clever
18:20:00 <Philippa> gwern: yep
18:20:09 <Saizan_> putStrLn
18:20:09 <LoganCapaldo> (putStrLn acuttally)
18:21:09 <gwern> print x         =  putStrLn (show x)
18:21:32 <gwern> heh. I'm a little surprised it's not pointless, and defined as 'print = putStrLn . show'
18:23:23 <Philippa> the pointful code is in a sense 'lower level'
18:23:40 <ddarius> Philippa: You could switch to O'Caml.
18:23:49 <gwern> or even defined as 'putStrLn $ show x', even
18:24:39 <Philippa> ddarius: I've concluded I probably didn't want to do it that way after all. I've got two types where one looks so much like it should be an instance of the other via a fixpoint, but really it's probably better for me to keep them separate as there's a corresponding phase distinction in the code
18:24:46 <shachaf> The pointful code doesn't have a problem with the MR. :-)
18:25:05 <shachaf> (This probably has a type signature anyway.)
18:26:43 <gwern> MR?
18:27:05 <shachaf> The monomorphism restriction.
18:27:28 <conal> Backus's famous "Can programming be liberated paper" describes pointful programming as low-level as well, descending to the world of objects.
18:28:02 <conal> ... be liberated" paper ...
18:28:50 <ddarius> You know what we need?  An high yield upper atmospheric nuclear detonation.
18:29:37 <goalieca> terrist!
18:30:12 <ddarius> goalieca: Few if anybody should die directly.
18:30:52 <gwern> ddarius: as if the indirect deaths would be any more pleasant?
18:31:16 <ddarius> gwern: The indirect deaths would mostly be medical equipment failing, failing pacemakers, etc.
18:31:29 <Philippa> conal: I just know how GHC's intermediate languages behave. I don't really buy a lot of Backus' arguments in that paper, at least not regarding pointlessness
18:33:16 <Adamant> that and the sound of our electronic infrastructure flash-freezing.
18:33:52 <LoganCapaldo> we'd have to resort to programming on paper!
18:33:58 <LoganCapaldo> egads
18:34:18 <ddarius> There were far less software bugs when there weren't any programmers.
18:34:36 <Adamant> but there were still algorithm bugs
18:34:38 <gwern> LoganCapaldo: well, Djikstra famously wanted us to program mostly on paper...
18:34:51 <goalieca> Adamant, i built me a faraday cage :-)
18:34:56 <Adamant> sweet!
18:35:05 * chessguy hangs up the phone and wonders what in the world #haskell is discussing
18:35:22 <Adamant> it's the end of our electronic world as we know it, and I feel fine
18:35:24 <LoganCapaldo> I like programming on paper to a certain extent but my programs on paper always end up using libraries that actually exist :)
18:35:26 <goalieca> emp's
18:35:27 <gwern> I have a question. why would adding a meaningless module header like 'module Main () where
18:35:32 <LoganCapaldo> *taht don't actually exist
18:35:38 <gwern> seem to reduce the length of the generated Core?
18:36:05 <scook0> gwern: isn't that an explicit no-export list?
18:36:14 <LoganCapaldo> it is indeed
18:36:14 <ddarius> Less stuff needs to be generated when stuff isn't exported.
18:36:23 <gwern> LoganCapaldo: that's when you then design the non-existent libraries on paper... sooner or later you'll have to depend only on existing libraries, and then your recursion has hit its basecase
18:36:31 <gwern> but, it's just a main definition with a where clause
18:36:40 <scook0> module Main where
18:36:42 <gwern> why would it be exporting it?
18:37:03 <scook0> (would be closer to "meaningless")
18:38:37 <gwern> hm. so, 'module Main () where' != 'module Main where
18:38:50 <scook0> yeah
18:38:55 <gwern>  but module Main where = no module header at all, it seems
18:39:02 <ddarius> Yes.
18:39:14 <scook0> if you omit the list, it exports all top-level declarations
18:39:28 <gwern> I wonder whether explicitly not exporting will buy me anything speed-wise?
18:39:36 <LoganCapaldo> 0and thats equivalent to module main (everything) where
18:39:42 <ddarius> gwern: It can.
18:39:50 <LoganCapaldo> unless i'm wrong
18:40:08 <scook0> ddarius: more aggressive inlining and such?
18:40:43 <ddarius> Yes and specializing potentially.  Certainly, if nothing else, it can reduce the amount of code that needs to be generated.
18:43:11 <scook0> which I suppose is a compile-time (and perhaps even cache) win
18:46:08 <Excedrin> oh wow, I just got almost equivalent performance to C
18:46:10 <gwern> hm. averaging 10 times towards the end, the difference is within the obvious margin of error - 1.64 vs 1.61
18:47:07 <Brian`> hey guys... just a question about studying haskell in general
18:47:15 <Brian`> when a function involves a complex type
18:47:29 <Excedrin> almost a 10x improvement, yay
18:47:50 <Brian`> and if it's hard to understand, how do you understand them ;?
18:47:54 <Brian`> any tips studying haskell?
18:48:28 <Brian`> I really love this language and wanna be good at it... but it's somewhat not as intuitive as other languages so I'm having difficulties here and there...
18:48:44 <gwern> maybe I should look at longest and shortest runtimes, I might see a difference there
18:48:56 <dons> mmm. read everything you can find on the haskell wiki, hang out here a lot, start working on some existing project
18:49:09 <gwern> Brian`: personally, I start with specializations and simplifications and then try to understand the more generalized types
18:49:28 <dons> Excedrin: oh?
18:49:33 <gwern> and I make generous use of the :type command in ghci to see what type the thing I just defined has
18:49:38 <LoganCapaldo> Brian`: forget it's a programming language for a little while
18:49:42 <dons> Excedrin: ghc 6.8?
18:50:05 <Excedrin> dons: ya, my usum was taking most of the time so I bumped it up one level so it's called infrequently
18:50:29 <Brian`> right now, I was having difficulties understanding composability of Functional Reference...
18:50:34 <Brian`> I can understand it conceptually
18:50:50 <Brian`> but I don't think I know it well enough to write it myself without looking at the existing source code...
18:51:05 <Excedrin> (yes 6.8)
18:51:20 <Brian`> in this website http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
18:51:22 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
18:51:29 <Brian`> where it has compose function definition
18:51:32 <scook0> a useful technique is to design your function types first -- often the code "writes itself" after that point
18:51:51 <Brian`> "set = update ab . set bc"
18:51:59 <gwern> dons: you think it's worthwhile to explicitly export nothing for sumfile?
18:52:19 <gwern> doesn't seem to make a measurable difference though it shortens the core
18:52:29 <kalmar> ?users
18:52:29 <lambdabot> Maximum users seen in #haskell: 412, currently: 371 (90.0%), active: 16 (4.3%)
18:52:30 <Brian`> in this case set bc returns "a -> s -> s" type
18:52:49 <Brian`> and be fed into update ab
18:53:03 <Brian`> but I don't understand how it can work...
18:53:28 <kalmar> ?logs
18:53:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:53:43 <Brian`> because "update ab" has type (a->a) -> (s->s)
18:53:55 <Brian`> and set bc has type "a -> s -> s"
18:54:04 <Brian`> how can update ab be composed with set bc?
18:54:49 <Brian`> btw, thanks everyone for sharing your studying tips :)
18:55:34 <scook0> Brian`: set bc has type a -> s -> s
18:55:41 <scook0> which is really a -> (s -> s)
18:56:10 <scook0> so the output of (set bc x) has type (s -> s)
18:56:24 <scook0> which then gets passed in as the argument to (update ab)
18:56:38 <Brian`> ah.. that makes sense
18:56:49 <Brian`> is it always like that? i mean if something has type a -> b -> c -> d -> e
18:57:08 <Brian`> then is it right associative? like a -> (b -> (c -> (d ->e))) ?
18:57:12 <shachaf> Brian`: Yes.
18:57:14 <scook0> Brian`: yeah
18:57:25 <shachaf> Brian`: And application is left associative.
18:57:37 <shachaf> Brian`: f x y z = (((f x) y) z)
18:57:46 <Brian`> oh.. i c
18:57:47 <scook0> I find that composing curried & higher-order functions can get pretty hairy sometimes
18:58:26 <scook0> @hoogle liftIO
18:58:26 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
19:05:48 <sclv> I ran into a stupid bug at work today where proper typing would have been so freaking handy.
19:06:33 <sclv> in java: Math.ceil (count / total) -- stupid java treated count and total as integers and thus the / as `div` and so the ceiling was useless and you got the floor anyway.
19:06:51 <sclv> haskell spoils me
19:07:06 <TSC> C's legacy
19:07:20 <LoganCapaldo> preach it brother sclv
19:07:42 <scook0> I remember doing some stuff with sqlite
19:07:48 <TSC> It could also have pointed out that taking the ceiling of an integer is silly
19:07:55 <scook0> which "helpfully" performs integer division if it thinks both operands are integers
19:08:11 <scook0> so I had to sprinkle (0.0+x) throughout all my queries
19:10:59 <sclv> oh yeah i also love the "genius" php and perl programmers who think that they save space by using the same variable to hold totally different things at different points in their spaghetti code. i'm getting so grumpy about style these days.
19:12:45 <LoganCapaldo> gah
19:12:58 <LoganCapaldo> it's worse when peopel do it in C and offspring
19:13:27 <LoganCapaldo> ok maybe not worse
19:13:31 <LoganCapaldo> but just as bad :)
19:14:37 <chessguy> @quote
19:14:37 <lambdabot> lispy says: the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
19:15:29 <sclv> appropriate too
19:16:51 <Excedrin> oh, well, the change I made to the Haskell code applies to the C code as well, so the C with the change is about 12x faster than the Haskell for the same N
19:19:51 <SamB_XP> is the second biggest reason that they don't know HOW to fix it yet?
19:20:36 <chessguy> @quote bug
19:20:37 <lambdabot> sorear says: The Haskell community has an acute shortage of buggy underdocumented programs.
19:21:19 <Excedrin> perhaps I should contribute some code!
19:21:32 <sclv> yeah but in 60% of programs the "documentation" is a like to citeseer
19:21:46 <sclv> s/like/link/
19:22:04 <SamB_XP> I wrote a buggy... er, incomplete! undocumented z-machine interpreter
19:22:08 <mauke> I want to upload something to hackage. what should I put in Category?
19:22:27 <chessguy> @quote document
19:22:27 <lambdabot> sorear says: [emacs haskell mode] not fucked up, just well documented
19:23:13 <chessguy> @quote emacs
19:23:13 <lambdabot> emu says:  it's translating to chinese? emacs has become sentient?! and it's a grad student?!
19:23:21 <scook0> mauke: that very much depends on what the package is, doesn't it?
19:23:47 <mauke> scook0: it's for interprocess communication channels
19:24:35 <TomMD> mauke: control, it already has STM and the like.
19:24:49 <scook0> I suppose you could run through the existing categories and include all that apply
19:25:26 <scook0> System seems obvious
19:25:27 <sclv> mauke: between haskell processes, or other ones as well?
19:25:57 <mauke> the system itself is language independent
19:26:08 <mauke> I haven't written other bindings, though
19:26:36 <sclv> then control, i guess? if it hooked into existing bindings then system would be the other choice?
19:26:39 <mauke> oh, that's the next problem, which top-level module namespace to use
19:28:25 <TomMD> ?src copyCString
19:28:25 <lambdabot> Source not found. Where did you learn to type?
19:28:33 <TomMD> ?hoogle copyCString
19:28:35 <lambdabot> No matches found
19:30:00 <sclv> Excedrin: do you think it would help if you used mutable arrays in the ST monad?
19:32:31 <dons> are you chasing C, and C is using mutable, unboxed arrays?
19:32:41 <dons> if so, you'll need to use the same structure. ST arrays
19:33:43 <dons> who was working on thread-ring earlier today?
19:33:56 <dons> ah, jedbrown :)
19:34:03 <dons> jedbrown: --> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=ghc&id=0 :)
19:34:05 <lambdabot> Title: thread-ring (new) Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp; ..., http://tinyurl.com/27zzft
19:34:36 <dons> the indenting is a bit odd , but oh well :) its #1
19:35:15 <Excedrin> I think I've tried every kind of array except for stuarrays
19:36:11 <dons> unboxed arrays of any sort?
19:36:41 <Excedrin> IOUArray
19:36:43 <sjanssen> dons: we'll be on top until somebody writes an Erlang version :)
19:37:03 <sjanssen> dons: this problem was going around the blogs a while back
19:37:03 <Excedrin> and UArray
19:37:34 <dons> erlang's not so hot on threads though. those runtime type checks get in the way
19:37:40 <dons> its good, but only haskell good
19:37:57 <dons> its a similar problem to chameneos
19:38:05 <sjanssen> dons: "erlang's not so hot on threads though"?
19:38:15 <sjanssen> isn't that Erlang's main thing?
19:38:29 <dons> i'm not sure erlang can catch ghc, even if its a concurrency problem
19:38:32 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
19:38:33 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
19:38:44 <dons> well, not high performance, more robustness, scaling and lots of parallel processing
19:38:49 <Excedrin> erlang is hot on distribution
19:39:01 <dons> but it has to do runtime type checks, which slow down straight line code
19:39:33 <sjanssen> we'll see
19:40:07 <dons> i wouldn't expect erlang to magically 10x faster. or 2x.
19:40:24 <sjanssen> 99% of the time taken for this problem is inter-thread communication
19:40:35 <sjanssen> yeah, I bet 2x isn't possible
19:40:36 <Brian`> hey, how do I check if something belongs to Monad class?
19:40:55 <dons> ?instances Monad
19:40:57 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:41:03 <dons> Brian`: in the interpreter, :info Type
19:41:05 <dons> for some type
19:41:17 <Brian`> aha~
19:41:20 <Brian`> that's cool
19:41:45 <Brian`> thanks dons
19:41:59 <thetallguy> Brian`: also useful in ghci, :browse module
19:42:23 <thetallguy> quick listing of functions and type sigs.
19:42:46 <Brian`> does that work only for standard module?
19:42:55 * Pseudonym downloads CSLI lecture notes like crazy
19:43:18 <Cale> http://programming.reddit.com/info/60eto/comments/c02galu -- this has got to be the best points/word on a comment that I've ever managed.
19:43:39 <sjanssen> Cale: nice
19:43:51 <dons> heh
19:44:08 <chessguy> heh. people think it's easier to mod up your answer than give the same answer themselves?
19:44:21 <Pseudonym> (-1, Redundant)
19:45:09 <Pseudonym> Seriously, what a dumb question.
19:45:11 <conal> i want to fill up an infinite binary tree (value at each node), breadth-first from a stream.  inverse of breadth-first traversal.  sounds familiar.  anyone know of a reference?
19:45:15 <Pseudonym> D might render C++ irrelevant.
19:45:24 <Pseudonym> Because it's a C++-alike without the C legaciness.
19:45:24 <conal> imagine what E could do!!
19:45:28 <Pseudonym> Exactly!
19:45:30 <Pseudonym> Or E+=2!
19:45:47 * conal chuckles
19:46:12 <Pseudonym> The problem with C++ is that even its _name_ isn't referentially transparent.
19:46:30 <sjanssen> @remember Pseudonym The problem with C++ is that even its _name_ isn't referentially transparent.
19:46:30 <lambdabot> I will remember.
19:46:38 <sjanssen> lambdabot: never forget
19:46:41 <Adamant> E already exists
19:46:41 <sjanssen> @flush
19:46:46 <Pseudonym> And F#
19:46:49 <Pseudonym> So I guess we're up to G.
19:47:05 <Excedrin> skip G go directly to H(askell)
19:47:11 <sclv> conal: conceptually isn't that the same as a breadth-first traversal of a tree, with the caveat that you're constructing it as you visit it?
19:47:20 <Adamant> then there's Io
19:47:34 <Excedrin> Io the scripting language?
19:47:39 <Adamant> yup
19:47:44 <Excedrin> yet another tcl
19:47:45 <sclv> and of course J. this could turn into a dull conversation soon.
19:48:04 <sclv> and j++ and k. all in the apl-likes
19:48:04 <conal> sclv: gee, i don't know.
19:49:06 <thetallguy> conal:  (Tree (s !!0) (Tree (s!!1) ... ...) (Tree (s!!2) .. ...) ?
19:49:22 <Pseudonym> Unfortunately, we already have Z.
19:49:46 <sjanssen> > succ 'Z'
19:49:46 <Pseudonym> (The specification language that's harder to debug than actual code.)
19:49:47 <lambdabot>  '['
19:49:49 <Adamant> there's probably an Omega as well
19:50:01 <conal> thetallguy: yes
19:50:04 * sjanssen writes [
19:50:13 <sjanssen> > maxBound :: Char -- or is this better?
19:50:14 <lambdabot>  '\1114111'
19:50:31 <conal> thetallguy: traversing the (infinite) stream once
19:51:02 <sjanssen> conal: is that possible?
19:51:21 <thetallguy> conal: yes, short hand.
19:51:31 <thetallguy> Woohoo!
19:51:44 <conal> sjanssen: i don't know
19:51:51 <conal> thetallguy: "Woohoo!"?
19:52:02 <thetallguy> oh, sorry, wrong window.
19:52:16 <sjanssen> conal: hmm, you could reduce each !! to O(log n) rather than O(n)
19:52:56 <sjanssen> by segmenting the input into a list of levels
19:52:59 <conal> sjanssen: that's the point of the conversion itself.  i'm really looking for an efficient random-access infinite stream.
19:53:48 <thetallguy> Hmm...
19:53:48 <conal> i figured i'd make an infinite stream and then convert it to an infinite tree for fast element access.
19:54:04 <sjanssen> conal: I'd try the list of levels
19:54:20 <sjanssen> [1 elem, 2 elems, 4 elems, 8 elems, 16 elems ...
19:54:24 <geezusfreeek> an infinite tree......
19:54:57 <conal> sjanssen: that may be simpler.  though less statically typed.
19:55:44 <conal> sjanssen: do you mean instead of the infinite binary tree?
19:55:48 <sjanssen> conal: ooh, what about a lazy trie?
19:55:55 <sjanssen> conal: yeah, instead of the binary tree
19:56:38 <conal> i think what i'm talking about amounts to a lazy trie, indexed by the the binary representation of the numeric index.
19:56:59 <conal> (modulo fussiness around unique binary reps)
19:57:21 <conal> sjanssen: but maybe you mean something else.
19:57:39 <conal> other suggestions welcome for efficiently indexable infinite streams.
19:58:50 <Pseudonym> You specifically want to index by an integer?
19:59:10 <conal> Pseudonym: yeah.
19:59:13 * Pseudonym nods
19:59:17 <LoganCapaldo> well an int would be too small
19:59:19 <Pseudonym> I've used the infinite stream of binary trees before.
19:59:24 <LoganCapaldo> you couldn't get the last element :)
19:59:32 <Pseudonym> The first element has a tree with one level, the second a tree with two levels, etc.
19:59:40 <sw17ch> conal: what do you mean by "efficiently"?
19:59:56 <thetallguy> conal: why not an array?
19:59:58 <Pseudonym> The general case, of a list of perfectly balanced binary trees, is interesting because it has O(1) cons, head and tail.
20:00:09 <thetallguy> conal: I've lost some bit of generality along the way here
20:00:11 <Pseudonym> And O(log n) index.
20:00:26 <Pseudonym> If you're curious, I implemented it in the Mercury standard library.
20:00:30 <Pseudonym> bt_array or something like that.
20:00:37 <conal> thetallguy: because i don't have an a priori bound
20:00:44 <thetallguy> conal: if you just want to do s !!, for any i
20:00:48 <sw17ch> http://en.wikipedia.org/wiki/VList ?
20:00:49 <conal> Pseudonym: oh, as opposed to an int?  it doesn't really matter much.
20:01:01 <Pseudonym> conal: As opposed to a rational tree or something.
20:02:26 <sclv> conal: what about a Tree Branch Tree Tree [a] Integer and where the Integer is the level on the tree. Your function that traverses one level down
20:02:34 <sclv> sorry -- not done typing yet
20:02:53 <sclv> Tree = Empty | Branch Tree Tree [a] Integer
20:03:12 <Pseudonym> Here we go:
20:03:14 <Pseudonym> http://www.google.com/codesearch?hl=en&q=+show:HtIH5IbYziE:P3JYn9okXn0:td4AfRQHQC0&sa=N&cd=2&ct=rc&cs_p=ftp://ftp.fsz.bme.hu/pub/oktatas/prolog/mercury-0.7.3-core.tar.gz&cs_f=mercury-0.7.3/library/bt_array.m#first
20:03:15 <lambdabot> Title: mercury-0.7.3/library/bt_array.m - Google Code Search, http://tinyurl.com/2jatys
20:03:49 <sclv> and the function that traverses a level down constructs a branch if it doesn't yet exist, passing in (drop level) from the list
20:04:08 <Pseudonym> Oh, and it's based on a Chris Okasaki paper.  Why did I forget that.
20:04:11 <sclv> (or drop 2*level or such for the 2nd node)
20:04:21 <conal> Pseudonym: do you know the paper?
20:04:32 <conal> sclv: still in one pass?
20:04:32 <Pseudonym> Go to that link, scroll down to the ra_list submodule.
20:04:37 <sclv> this is probably a dumb idea and continuations would make more sense
20:05:22 <hpaste>  sjanssen pasted "a lazy trie" at http://hpaste.org/3839
20:05:33 <sclv> conal: this wouldn't get you one pass, more like a lazily constructed tree with some amortized costs higher than log n
20:06:32 <sjanssen> conal: that gives you O(n) initial access and O(1) subsequent access to each element
20:06:51 <sjanssen> (we achieve those bounds because Word is constant sized)
20:07:15 <Pseudonym> OK, hang on here.  There used to be an Integer-indexed infinite data structure at MemoisingCafs on the old wiki.
20:07:30 <Pseudonym> But it's not on wikisnapshot.
20:07:47 <sjanssen> this approach extends to [Bool], which is isomorphic to Integer
20:08:26 <sjanssen> in which case the bounds are O(n log n) and O(log n)
20:09:25 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2006-October/018883.html <- Proof that it once existed.
20:09:26 <lambdabot> Title: [Haskell-cafe] Re: function result caching, http://tinyurl.com/33dcm4
20:09:50 <sjanssen> this approach also has the nice feature that a lookup on n will cache [0..n]
20:11:11 <Pseudonym> Aha, here it is:
20:11:13 <Pseudonym> http://osdir.com/ml/lang.haskell.cafe/2003-08/msg00176.html
20:11:14 <lambdabot> Title: Re: Pascal Line in Haskell
20:11:20 * Pseudonym is still proud of that reply
20:12:19 <sjanssen> Pseudonym: isn't a list of arrays better here?
20:12:52 <Pseudonym> No.
20:12:58 <Pseudonym> Why would it be?
20:13:14 <Pseudonym> I'm assuming a list of arrays of increasing size.
20:13:26 <sjanssen> not better asymptotically, but better in practice
20:13:29 <Pseudonym> So if you grab one value from way, way down the list, you make a big array.
20:13:49 <Pseudonym> Using a tree, list of trees or whatever, you only construct the path to the value that you evaluate.
20:14:22 <sjanssen> are the trees increasing size too?
20:14:54 <Pseudonym> Yes.
20:16:53 <sjanssen> then you'll have to strictly create each level, unless you want to break conal's requirement of not traversing the list multiple times
20:16:54 <sjanssen> right?
20:18:52 <Pseudonym> Sorry, you've lost me there.
20:18:59 <Pseudonym> Why do you need to strictly create each level?
20:19:13 <Pseudonym> And not traverse the list multiple times under what circumstances?
20:19:39 <sjanssen> I'm referring to conal's input stream
20:19:46 <sjanssen> not the generated list of trees, sorry
20:19:55 <thetallguy> conal: is your original structure really only semi-infinite?
20:21:26 <sjanssen> Pseudonym: you've got to 'splitAt (2^i)' for each level, right?
20:21:50 <conal> thetallguy: this one is.  most of the others are bi-infinite.
20:21:59 <Pseudonym> Hang on, I'm trying to understand this requirement.
20:22:16 <Pseudonym> Could someone repeat it please?
20:22:47 <sjanssen> Pseudonym: conal wants to create the structure with a single traversal through his input
20:23:10 <Pseudonym> Ah, I see.
20:23:33 <Pseudonym> Well, the list of trees will do it, if you don't mind it being constructed in reverse.
20:23:38 <Pseudonym> It'll still give you O(log n) lookup.
20:23:46 <Pseudonym> But it'll store them in reverse order.
20:23:55 <sjanssen> Pseudonym: the list is infinite :)
20:23:59 <Pseudonym> Ah.
20:24:10 <Pseudonym> So what's up with the stream?
20:34:40 <hpaste>  sclv pasted "a concept sketch of a lazy binary tree" at http://hpaste.org/3840
20:36:15 <sclv> oh dear, i already noticed the base case of getVal is slightly wrong
21:01:29 <kfish> w00t, I just caught up on email, facebook, slashdot, proggit, news.yc, dilbert and phdcomics in 23 minutes flat
21:01:56 * kfish is optimizing the Procrastination monad
21:01:58 <scook0> kfish: now you might have to do some real work! :O
21:02:10 <shachaf> kfish: Not planet.haskell.org?
21:02:20 <Korollary> Everybody needs a secretary
21:02:44 <kfish> :-)
21:03:52 <dons> kfish: woot!
21:04:34 <kfish> yeah, now to find something useful to do for the next 4-5 hrs of lab meeting ...
21:05:09 <shachaf> dons: Just a Zune, not interesting... :-)
21:05:16 <dons> "big_values too large!" mplayer sez
21:06:41 <kfish> dons: have you worked on hmp3 lately?
21:07:02 <dons> i had a poke at it last week to get it to build with 6.8
21:08:03 <kfish> i'm trying to remember what needed to be done for ogg123 support
21:08:40 <dons> need to not filter out /= .mp3 files, and then check the remote control interface works
21:09:51 <kfish> right :-)
21:10:49 <kfish> actually no-one's tested the remote control interface for ogg123 yet, so it's still only available in svn
21:26:21 <chessguy> @quote sleep
21:26:21 <lambdabot> bd_ says: ENOSLEEP_CLOWNSWILLGETME
21:26:36 <chessguy> not helping me fall asleep :)
21:27:04 <ddarius> #haskell is not the place to go for help getting to sleep.
21:27:13 <ddarius> But, for what it's worth: Go to sleep.
21:27:17 <thoughtpolice> the internet in general isn't a good place to look for something like that.
21:27:37 <chessguy> @quote internet
21:27:37 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
21:27:37 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
21:28:28 <thoughtpolice> in any case,
21:28:32 * thoughtpolice --sleep
21:28:45 <shachaf> thoughtpolice --help
21:31:07 <hpaste>  sclv annotated "a concept sketch of a lazy binary tree" with "working, sort of." at http://hpaste.org/3840#a1
21:33:01 <alexyk> hiya -- how do you specify where ghc should find libraries?  I get linkage errors
21:33:10 <alexyk> missing symbols in ghc from darcs
21:33:51 <Cale> alexyk: You're trying to compile GHC itself?
21:34:00 <Cale> Or something else?
21:34:03 <sclv> whee! O(log n) access in the tree constructed so far, but amortized O(n) access for any individual element
21:34:05 <alexyk> nope -- that's done
21:34:20 <alexyk> so I have a program which uses certain libs
21:34:33 <Cale> alexyk: Are you adding --make as a parameter?
21:34:50 <Cale> If not, then try that, it fixes the most common cases of linker errors.
21:34:58 <alexyk> and they're there in /usr/local/lib/ghc-6.9.20071112
21:35:00 <sclv> if we force it so the construction of a left or right node forces the construction of both, we even meet the original single traversal only requirement!
21:35:19 <Cale> Oh, you're running 6.9?
21:35:33 <alexyk> Cale: so I say ghc --make blah.sh -o blah  ?
21:35:38 <Cale> Are you hacking on GHC?
21:35:53 <alexyk> Cale: nope, just love darcs :)
21:35:54 <Cale> Or... I don't understand why else you'd be running 6.9 right now.
21:36:29 <Cale> 6.9 is the unstable development GHC, 6.8.1 is the recently released stable branch
21:36:38 <alexyk> yep
21:36:39 <Korollary> blah.sh sounds like a shell script file
21:36:50 <alexyk> I just wonder how I use 6.9 if I want to...
21:36:59 <alexyk> sorry blah.hs
21:37:04 <ddarius> Korollary: Haskell is the new bash
21:37:16 <Cale> alexyk: yeah, like that
21:37:23 <alexyk> okok
21:37:51 <Cale> alexyk: If that's not compiling with 6.9 and you want it to, then you can just specify the path to ghc-6.9 directly on the commandline.
21:38:25 <Cale> (or ensure that the file that you get when you type `which ghc` is a symlink to it)
21:38:34 <alexyk> I have ghc-6.9 in the path, it compiles but doesn't link
21:38:50 <alexyk> ghc-6.9 went to /usr/local/lib
21:38:59 <alexyk> and /usr/local/bin
21:39:10 <alexyk> but lib is in that 6.9-2007... subdir
21:39:12 <Cale> !paste
21:39:12 <hpaste> Haskell paste bin: http://hpaste.org/
21:39:24 <Cale> could you paste an example of the linker errors that you're getting?
21:42:14 <alexyk> Cale: http://hpaste.org/3842
21:42:43 <alexyk> code compiles with ghc 6.6.1 so it uses standard libs
21:42:46 <Cale> yeah, try just adding --make to the commandline parameters for GHC
21:43:13 <Cale> Many things have moved out of the base package.
21:43:27 <Cale> So --make will track down which packages are needed.
21:43:58 <alexyk> Cale: yep! magic :)
21:44:01 <alexyk> thx
21:44:17 <alexyk> another thing: cabal-install is broken!
21:44:28 <Cale> Otherwise, you can explicitly list packages with -package bytestring -package mtl -package parallel, etc.
21:44:42 <alexyk> ah
21:44:44 <Cale> Or make your program into a cabal package
21:44:58 <alexyk> which is basically make, right?
21:45:07 <Cale> A bit nicer than make, but yeah.
21:45:21 <alexyk> cabal-install is broken for me :(
21:45:26 <Cale> The .cabal file has a field where you list package dependencies.
21:45:38 <Cale> Oh, if you compile it with 1.2.2.0, it'll be broken.
21:46:02 <Cale> If you compile it with Cabal 1.2.1 instead, it should work.
21:46:03 <alexyk> so I got ghc with whatever Cabal is in there
21:46:07 <alexyk> cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
21:46:19 <Cale> Yeah, that's the problem.
21:46:20 <alexyk> -- this is what I get at any run of cabal
21:46:37 <alexyk> so I got my Cabal with ghc -- how do I downgrade to 1.2?
21:46:43 <Cale> GHC 6.8.1 was unfortunately released with a version of Cabal that had this bug.
21:46:43 * ddarius reflects on the days when Cabal and Hackage were just ideas.
21:47:19 <Cale> You can ghc-pkg unregister Cabal-1.2.2.0 and then download and install Cabal-1.2.1 from Hackage
21:47:31 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
21:47:41 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal-1.2.1
21:47:41 <lambdabot> http://tinyurl.com/ywloqh
21:47:46 <faxathisia> hi
21:47:48 <alexyk> ok, should I rebuild cabal-install then?
21:47:51 <Cale> yeah
21:47:55 <alexyk> after I get Cabal 1.2.1?
21:47:59 <Cale> right.
21:48:02 <alexyk> okok
21:48:05 <ddarius> @seen shapr
21:48:05 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 3h 35m 14s ago.
21:48:14 <Cale> After that, if you want to go back to 1.2.2.0, it's probably fine.
21:48:26 <Cale> It just seems to break cabal-install
21:48:50 <alexyk> that's what in unix vs. microsoft is known and anal-cranial inversion
21:48:51 <alexyk> :)
21:49:08 <alexyk> the zigzag process...
21:49:11 <alexyk> \/
21:49:13 <Cale> (I'm running 1.2.2.0 together with a cabal-install that was built with 1.2.1, and everythin seems okay.)
21:49:53 <ddarius> @tell shapr We should put some more life into AmeroHaskell.
21:49:53 <lambdabot> Consider it noted.
21:50:03 <Cale> Yes, it's rather similar to conjugation by an element in a group, which you see a whole lot when solving the Rubik's cube ;)
21:50:51 <ddarius> "Yes!  Installing this software is rather like algebraically extending the Gaussian integers"\
21:52:02 <alexyk> ah, ghc 6.9 reports Cabal 1.3
21:52:12 <alexyk> so I'll unregister *that*
21:52:35 <dons> oh, that's the best cabal of all though!
21:52:55 <alexyk> just for a sec to get my cabal-install goin'
21:53:05 <dons> i think cabal-install darcs depends on cabal darcs / 1.3
21:53:14 <dons> at least it fixes the confTest.c bug some people were having
21:53:25 <dons> i'm using Cabal-1.3 and cabal-install from darcs happily
21:53:33 <alexyk> yayayay!  so I'll get cabal-darcs instead
21:53:40 <alexyk> whats' the repo again?
21:54:02 <dons> darcs.haskell.org/cabal-install
21:54:18 <alexyk> right, and for cabal just /cabal ?
21:54:48 <dons> hmm,  i think its  under the cabal directory somewhere, let me see..
21:55:04 <dons> oh, just http://darcs.haskell.org/cabal
21:55:05 <lambdabot> Title: Index of /cabal
21:55:24 <alexyk> yes, ok
21:56:13 <alexyk> btw: it's safe to just darcs get --partial on all these, right?  Do I ever need complete ones?
21:56:18 <dataangel> Is there like a set of exercises somewhere for developing familiarity with folding/unfolding? I thought I understood folds until I read the wikibook's treeFold example, and my brain exploded
21:56:31 <faxathisia> is it okay to do Data ... = n_stmt_start | n_stmt_end | n_aop_start ... deriving Enum ?
21:56:48 <faxathisia> since they don't fit the naming convention..
21:57:24 <faxathisia> dataangel: This is nice http://www.cs.nott.ac.uk/~gmh/fold.pdf
21:57:49 <ddarius> faxathisia: The case things aren't a convention.  So no, if that's what you are asking.
21:58:00 <faxathisia> they aren't? :o
21:58:18 <faxathisia> wait im confused
21:58:39 <faxathisia> so it's better to do n_stmt_start = 1 ; n_stmt_end = 2 ; .. ?
21:59:16 <ddarius> You can do data Whatever = N_stmt_start | N_stmt_end | ... deriving Enum
21:59:37 <faxathisia> Why capitalize the first letter?
21:59:37 <Apocalisp> Do-notation has me confused. How come let...in works differently in do-land?
22:00:12 <ddarius> faxathisia: Because the standand says so.
22:00:18 <faxathisia> ah ok
22:00:19 <Cale> faxathisia: So that constructors can be syntactically distinguished from variables
22:00:23 <Cale> (in patterns)
22:00:33 <faxathisia> alright thanks
22:01:04 <Cale> Apocalisp: do-notation includes a special case for a statement which is just a let <decls>
22:01:26 <ddarius> @undo do let { x = 3 }; m
22:01:26 <lambdabot> let { x = 3} in m
22:01:31 <Cale> Apocalisp: do { let <decls>; <stmts> } = let <decls> in do { <stmts> }
22:02:10 <ddarius> Apocalisp: Incidentally, it doesn't work "differently", it has a conservative extension of it's abilities.
22:02:22 <Cale> So it just gives a way of making local declarations which scope over the rest of the block
22:02:57 <Cale> Which is especially handy when those declarations involve variables which were bound by <- in previous lines.
22:03:43 * ddarius almost never uses let in do.
22:03:45 <alexyk> dons: after I build/install darcs cabal, how do I rebuild cabal-install with it?  do I need to unregister the previous Cabal-1.3, or this one will overwrite that?
22:04:26 <Cale> alexyk: At present, the Cabal library, and cabal-install are separate.
22:04:29 <wy> Hey, can I ask a question about logic here?
22:04:41 <Cale> wy: yeah, that's not too offtopic, I suppose :)
22:04:44 <dons> only illogical questions will be answered -- be warned!
22:04:50 <ddarius> wy: Are we allowed to ridicule you if you do?
22:05:07 <alexyk> Cale: yep, I've just build Cabal from darcs
22:05:15 <wy> I'm doing some modal logic reasoning.
22:05:22 <alexyk> now want to make sure it supercedes Cabal from ghc -- both are 1.3
22:05:33 <Apocalisp> I see. That's handy. Unexpected, but handy.
22:05:55 <wy> There is a inference rule from a to M a, but now I need an implication a=>M a.
22:06:28 <wy> The only other inference rule is modus ponens. I somehow don't know how to get an implication from this
22:07:05 <alexyk> arrgh I get Conftest again -- I need to remove old Cabal somehow before rebuilding cabal-install...
22:07:08 <faxathisia> :t return
22:07:09 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:07:22 <dons> alexyk: make sure your cabal-install is cleaned
22:07:23 <Cale> Maybe a => M a is not provable, even though a |- M a?
22:07:33 <dons> so it compiles and links against the new cabal you built
22:07:37 <alexyk> dons: Setup.lhs clean?
22:07:51 <wy> Cale: The inference rule says if we have a, then we have M a
22:07:52 <ddarius> Cale: Just throw a lambda there.  Presumably => introduction is there.
22:08:29 <wy> Cale: But that's an inference rule, not an implication. I'm really confused about what's an inference rule and what's an implication
22:09:00 <Cale> wy: Do you have an inference rule which allows you to infer A => B from a proof of B starting from A?
22:09:02 <ddarius> It's "internal" v. "external"
22:09:20 <alexyk> yay!  Conftest is dead.
22:09:42 <alexyk> cabal-1.3 rocks
22:09:59 <dons> alexyk: yep
22:10:02 <wy> Cale: I have from A and A=>B, get B
22:10:16 <Cale> wy: yeah, that's not enough.
22:10:31 <dibblego> modus ponens
22:10:46 <wy> Cale: Strange. If I use a truth table, I can deduce that a=>M a
22:10:46 <Cale> wy: I get the feeling that we don't have enough information about your system to be able to help here.
22:11:32 <wy> Cale: Can you just tell me what's the difference between an inference rule and an implication?
22:11:51 <Cale> wy: Implications are phrased inside the logical system itself.
22:12:08 <Cale> wy: That is, they are strings of symbols, and certain inference rules apply to them.
22:12:16 <ddarius> wy: As I said, a lot of it is a distinction between "internal" and "external".
22:12:33 <wy> ddarius: Thanks. That makes it a little clearer
22:12:38 <Cale> Inference rules are one level higher. They basically tell you how these strings of symbols are allowed to be transformed.
22:12:56 <ddarius> Though a lot of logic just "reflecting" the "meta-logic" into the logic it seems.
22:13:14 <wy> So now I have the inference rule that allows me to have M a once I have a, why can't I get a=>M a from it?
22:13:17 <Thomas2> this all gets important when you want to talk about semantics
22:13:19 <ddarius> Though this -does- have benefit.
22:13:51 <ddarius> wy: You should have a rule called something like => introduction.
22:13:51 <Thomas2> you have to have a logic, and the inference rules give the logic its semantics
22:14:24 <Cale> wy: Can you list all the rules of your system for us?
22:14:31 <Thomas2> you can then have terms in the logic (like implication, which is really just a function bool -> bool -> bool) and give them semantics based on properties of the logic etc
22:14:38 <hpaste>  sclv annotated "a concept sketch of a lazy binary tree" with "Still rough, but knot successfully tied" at http://hpaste.org/3840#a2
22:15:17 <wy> Cale. Yes
22:15:33 <faxathisia> sclv: What is the knot?
22:15:41 <sclv> @quote knot
22:15:41 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
22:15:41 <bos> @hoogle Double -> Int
22:15:42 <lambdabot> No matches, try a more general search
22:15:48 <wy> There are only two others plus all propositional tautologies.
22:16:33 <wy> The first is (M a /\ M (a=>b)) => M b. The second is M a=>a
22:16:37 <bos> > truncate 1.2
22:16:38 <lambdabot>  1
22:16:45 <bos> > round 1.5
22:16:46 <lambdabot>  2
22:17:08 * ddarius curses C#'s Math.round and co. functions being Double -> Double.
22:17:26 <wy> like monads huh?
22:17:35 <ski> wy : do you have the "Deduction Theorem" ?
22:17:36 <Cale> sort of, yeah :)
22:18:06 <QtPlatypus> ddarius: What is wrong with them being Double -> Double?
22:18:07 <Thomas2> doesn't look like he actually has a context
22:18:13 <faxathisia> a -> M a as return
22:18:18 <ski> (wy : more sort of like comonads)
22:18:23 <wy> ski: I have two inference rules. The first is modus ponens. The second is from a to M a
22:18:24 <ddarius> wy: S5 modal logic's proofs are exactly monads.
22:18:32 <ddarius> (or rather monadic terms)
22:18:41 <Cale> Yeah, it's like applicative comonads?
22:19:00 <wy> ddarius: This is really part of S5. Oh, so S5 is so famous?
22:19:19 <ddarius> QtPlatypus: They are the coercions of a floating point number to an integral one so they should do that.  It's annoying to have to follow up with a "cast" to int.
22:19:26 <wy> ddarius: I think this is called K
22:19:38 <wy> ddarius: oh no, KT
22:20:11 <wy> Cale: any ideas?
22:20:23 <Thomas2> wy: what is it you need to do?
22:20:46 <wy> Thomas2: I need to get the implication a=>M a from it
22:21:07 <Thomas2> ummm
22:21:44 * bos has lately become addicted to Control.Applicative
22:21:45 * ski is not sure `a => M a' is provable .. hm
22:21:45 <Cale> wy: Your assignment actually requests that you prove a => M a?
22:21:58 <Cale> I wouldn't expect a => M a to be provable.
22:22:12 <Cale> If it is, it's surprising to me.
22:22:27 <faxathisia> :t return
22:22:28 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:22:34 <wy> Cale: Uhh... I just reverse engineered the goal and get this
22:22:55 <Cale> wy: Maybe a => M a is too strong a result?
22:23:08 <wy> Cale: maybe
22:23:12 <ski> faxathisia : wy had
22:23:15 <ski> |- A
22:23:18 <ski> ------
22:23:18 <ski> |- M A
22:23:24 <Cale> After all, if you can prove both a => M a and M a => a, that means there's no point in having M at all.
22:23:34 <Cale> (Or very little point)
22:23:46 <wy> Cale: That's a good point...
22:24:24 <ski> (`Stream a' has ground element iff `a' has ground element)
22:24:51 <Cale> Yeah, once you start attaching semantics, then it could matter :)
22:25:08 <Cale> However, as a purely logical thing, M is sort of uninteresting then.
22:25:11 <wy> Cale: I guess there is something implied in it...?
22:25:44 <dufflebunk> Does anyone have an example or suggested library for parsing a binary file?
22:26:16 <sjanssen> @hackage binary
22:26:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
22:26:23 <sjanssen> dufflebunk: try that library
22:26:49 <wy> Cale: I don't know if I should tell you my real goal if you are interested.
22:27:00 <dufflebunk> Thanks, sjanssen I'll check it out
22:27:07 <Cale> wy: Well, you can if you like
22:27:38 <ddarius> wy: It's quite easy to ignore people on IRC.
22:27:43 <Cale> KT has exactly the type-level axioms of a comonad.
22:27:56 <alexyk> question about multiple ghc's on the system: how do I do runhaskell Setup.lhs configure <what else> in darcs source repos of packages?  E.g. I assume I need different builds for different ghc's, right?  Should I put them in different prefixes?  Then which ghc-pkg do I use, from which ghc?
22:28:13 <wy> The goal is ~M ( a /\ ~M a)
22:28:19 <ski> Cale : i thought one needed `4 : M a -> M (M a)' for that, as well
22:28:25 <wy> ddarius: Sorry
22:28:46 <Cale> ski: er...
22:28:46 <shachaf> alexyk: I think you use runghc -f.
22:28:54 <ddarius> wy: ?  I'm just saying you can say whatever you want and if people aren't interested they'll just ignore it.
22:28:55 <Cale> ski: hmm, oh
22:29:16 <Cale> ski: K is more like ap, sorry, I was more on track a minute ago :)
22:29:22 <alexyk> shachaf: what's runghc -f?
22:29:23 <shachaf> alexyk: As in "runghc -f ghc-6.8.1"
22:29:31 <Cale> For a moment I thought that was cobind, but it's not.
22:29:36 <shachaf> alexyk: Each ghc has its own ghc-pkg.
22:29:47 <wy> ski: You know a lot about this. How do you know it's called 4?
22:29:57 <ski> i cheated a little
22:30:00 <Cale> So it's like we have ap and extract
22:30:02 <shachaf> alexyk: Are you installing globally?
22:30:18 <ski> <http://en.wikipedia.org/wiki/Modal_logic> , <http://plato.stanford.edu/entries/logic-modal/>
22:30:32 <alexyk> shachaf: ok, so say I got a new repo for package Foo and want to build it for ghc 6.6.1, 6.8.1, and 6.9
22:30:36 <shachaf> Cale: K is like ap?
22:30:41 <alexyk> I'm in darcs repo for foo
22:30:52 <alexyk> how do I do these 3 builds?
22:30:55 <Cale> :t ap
22:30:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:31:07 <Cale> looks like it :)
22:31:13 <alexyk> just specifying runhaskell from different ghc's to Setup.lhs?
22:31:28 <Cale> shachaf: (The modal-logic axiom K, not the combinator)
22:31:48 <shachaf> alexyk: runghc -f ghc-6.6.1 configure; ...-6.6.1 build; ...-6.6.1 install; then clean and repeat.
22:32:05 <alexyk> shachaf: yeah... that's what I thought
22:32:09 <shachaf> Cale: Oh, I missed the rest of the conversation.
22:32:19 <wy> ski: Thanks. I thought this is unique to the logic I'm using. So it's a general thing
22:32:44 <wy> So I have only K+T.
22:33:50 <wy> Cale: cool. I never thought this question is so appropriet for this channel ;-)
22:33:58 <Cale> hehe
22:34:12 <Cale> Functional programming is essentially applied formal logic.
22:34:40 <wy> Cale: So which one is original? modal logic or monads?
22:34:48 <ddarius> And by "essentially" Cale means "".
22:34:53 <Cale> Modal logic is earlier, historically.
22:35:19 <Cale> But I don't think people immediately saw the connection between monads and modal logic.
22:35:20 <wy> It's quite powerful.
22:35:45 <ddarius> Cale: Probably not at least until Lawvere's categorical logic, and even a little bit after that.
22:35:45 <merus> What sort of connection is there?
22:35:47 <ddarius> At least.
22:35:48 <wy> My professor uses it to solve some interesting puzzles
22:36:09 <ddarius> merus: The same old Curry-Howard-Lambek-Lawvere correspondence essentially.
22:36:15 <merus> ddarius: Oh.
22:36:55 <Cale> merus: Monads correspond nicely to a modal logic with an operator M that has a => M a, (a => b) => M a => M b, and M (M a) => a
22:37:15 <wy> any ideas about proving that from K+T?
22:37:17 <merus> Oooh.
22:37:36 <ski> s/=> a/=> M a/
22:37:49 <Cale> oh, duh, yes
22:37:50 <ski> wy : `~M ( a /\ ~M a)' ?
22:37:54 <alexyk> folks: so is it reasonable to use ghc from darcs?  do they run tests before checkin' in?  I mean, development-shmevelopment, it's a checkin, right?
22:37:57 <wy> ski: right
22:38:01 <merus> I never noticed that the monad laws corresponded so closely to the laws of the necessary qualifier. Coolness.
22:38:27 <ddarius> merus: Specifically, S5 modal logic directly corresponds to the monad laws.
22:38:55 <ddarius> merus: Many others are closer to pointed endofunctors or applicative functors or comonads.
22:43:08 <ski> `<> (a -> [] a)' .. hm
22:44:33 <wy> why do you use two modals?
22:44:34 <Cale> wy: I see how you want a => Ma to be true :)
22:44:51 <Cale> (I just went down that path myself, but it seems too strong a condition)
22:45:06 <wy> Cale: You seem to be right
22:45:37 <ski> wy : just trying to make heads or tails out of it ..
22:47:54 <ski> [] a -> [] a
22:47:58 <ski> [] a -> <> [] a
22:48:07 <ski> ~ [] a \/ <> [] a
22:48:16 <ski> <> ~ a \/ <> [] a
22:48:23 <ski> <> (~ a \/ [] a)
22:48:35 <ski> <> (a -> [] a)
22:48:49 <ski> <> ~ (a /\ ~ [] a)
22:48:55 <ski> ~ [] (a /\ ~ [] a)
22:49:10 <wy> Cooool~
22:49:15 <ski> does that seem reasonable ?
22:49:22 <wy> But what's <> ?
22:49:43 <ski> <> a  -||-  ~ [] ~ a
22:49:57 <ski> (i'm assuming you can eliminate double negation)
22:50:52 <ski> also, of course one would need to render the above in your proof system
22:50:53 <wy> So <> [] a is ...
22:51:54 <ski> i'm wondering whether `<> a \/ <> b => <> (a \/ b)' (or some rephrasing of it, not using `\/') holds in `KT' ..
22:51:55 <wy> ~[]~[] ?
22:52:04 <ski> *nod*
22:52:30 <wy> ski: I guess you know a lot about logic already, right?
22:52:42 <ski> anycase, the above seems to suggest (to me) that what you want might be provable in your logic
22:52:58 <ski> wy : a little
22:53:49 <wy> ski: Do you find it very useful?
22:54:07 <ski> i find it fun
22:54:44 <wy> me too :-)
22:54:44 <Cale> It's a lot more fun once you get the picture of attaching semantics to it.
22:55:04 <wy> Cale: I've been doing it ;-)
22:55:16 <wy> It can solve lots of problems
22:56:32 <wy> My professor started from the samantic side gradually into the logics. That's why I didn't get bored ;-)
22:59:08 <wy> ski: what's <> ~ a ?
22:59:36 <wy> ski: Oh, i see.
23:03:15 <wy> ski: You have a better way than what I've learned to this point. I haven't learned how to manipulate <> yet
23:04:05 <wy> ski: How do you get the second line?
23:07:15 <citizenterminal> \uit
23:07:17 <citizenterminal> \quit
23:08:17 <Cale> wy: [] a -> <> [] a ?
23:08:42 <wy> Cale: yes
23:08:55 <Cale> In fact, a -> <> a
23:09:15 <Cale> since [] a -> a, so ~ a -> ~ [] a
23:09:35 <Cale> So a -> ~ [] ~ a
23:09:47 <Cale> and that's a -> <> a
23:10:27 <wy> wait
23:10:42 <wy> How do you have a -> ~ [] ~ a
23:10:55 <Cale> By substitution of ~a for a
23:11:18 <wy> ahhhh
23:11:20 <wy> good
23:14:03 <ski> *nod*
23:20:48 <wy> I have problem connecting <> (~ a \/ [] a) to my form
23:21:17 <wy> Can't see how to go from the transformed last step to this one
23:30:10 <wy> ski: I have another simpler question. Maybe you are still around?
23:32:42 <wy> Does D says something equivalent to ~[](false)
23:43:08 <wy> ski: are you there?
23:49:54 <faxathisia> What do you do if you get stuck trying to program something?
23:53:40 <ray> run a few miles in the park, go out to lunch if it's daytime, that kind of stuff
23:54:58 <KatieHuber> shower
