00:08:31 <xpika> @hoogle IO a -> IO c -> IO d -> IO d
00:08:32 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
00:09:27 <xpika> hoogle++
00:10:57 <xpika> @hoogle IO a -> (a -> IO c) -> (a -> IO d) -> IO d
00:10:57 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
00:38:56 <hpaste>  sjanssen pasted "chameneos-redux. 5x faster than Mozart/Oz" at http://hpaste.org/4108
00:41:09 <sjanssen> @tell dons http://hpaste.org/4108 about 5x faster than any other solution
00:41:09 <lambdabot> Consider it noted.
00:41:11 <sjanssen> @flush
00:45:42 <ddarius> I guess that's good?  How does Oz do typically on that type of benchmark?
00:48:44 <sjanssen> ddarius: from another thread-related test http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
00:48:45 <lambdabot> Title: thread-ring (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2lyngq
00:48:57 <sjanssen> (another Haskell #1, I note)
00:49:58 <sjanssen> ddarius: fairly well, I think.  Oz is supposedly oriented towards concurrent programming
01:00:15 <ddvlad> @users
01:00:15 <lambdabot> Maximum users seen in #haskell: 401, currently: 358 (89.3%), active: 4 (1.1%)
01:00:47 <hpaste>  sjanssen annotated "chameneos-redux. 5x faster than Mozart/Oz" with "slightly faster, somewhat more ugly" at http://hpaste.org/4108#a1
01:01:25 <ddarius> http://www.mozart-oz.org/documentation/apptut/node9.html#chapter.concurrency.cheap This needs a disclaimer on the meaning of "other" in "other languages".
01:01:26 <lambdabot> Title: 7 Concurrency For Free, http://tinyurl.com/2k9qhr
01:02:43 <Philippa> ddarius: our scheduling isn't entirely pre-emptive yet
01:02:55 <Philippa> actually, scratch the yet - it's unlikely to be any time soon
01:03:20 <ddarius> Philippa: It could be made to be without significantly affecting the performance on that problem.
01:04:16 <Philippa> sure. It'd just gut it for an awful lot of others
01:04:40 <ddarius> Agreed and with little benefit which is why it's unlikely to be any time soon.
01:05:04 <ddarius> That said, Haskell and GHC aren't the only languages in town that could keep up with if not beat Oz.
01:05:05 <Philippa> it wouldn't be unreasonable to have a compiler flag. Too bad it can't be an RTS flag really
01:05:10 <jedbrown> sjanssen: What is the third argument of `go' doing?  It seems to be passed around, but not used.
01:07:51 <ddvlad> This is going to sound outrageous. A few friends from college want to write a graphics engine (based on OpenGL) and we have 0 experience in graphics and Haskell. Do I have any chance making a point for Haskell as the programming language?
01:08:56 <quicksilver> ddvlad: I find openGL more pleasant in haskell than other languages, because openGL programming involves a lot of repetition in (e.g.) C or Java and haskell is good at abstracting that stuff
01:09:08 <quicksilver> ddvlad: having said that, if you have 0 haskell experience, it may not be sensible.
01:09:15 <ddarius> ddvlad: How much effort/time are you willing to spend?
01:09:21 <Philippa> ddvlad: what are your aims for the engine?
01:09:59 <ddvlad> ddarius: we already know that _if_ we start this, it will span multiple years, be on and off programming, as schoolwork allows
01:10:22 <quicksilver> over multiple years I'm quite sure haskell will be a net win
01:10:29 <quicksilver> however, your friends may hate you in the short term
01:10:32 <ddvlad> Philippa: they (not me) want to make it usable. Not experimental and proof of concept, but high standard
01:10:51 <Philippa> usable for what?
01:10:54 <ddvlad> quicksilver: they already hate my "I can haz Haskell" shirt :-)
01:11:36 <ddvlad> Philippa: for a game. Basically the leader (of sorts) wants us to be able to make high-end games based on it. 3D and the works
01:11:41 <therp> ddvlad: me wants!
01:11:53 <Philippa> then it's going to need to be more than a graphics engine, too
01:11:58 <ddvlad> therp: it's custom made. Got it for my birthday
01:12:08 <ddvlad> Philippa: what do you mean?
01:12:15 <Philippa> Out of interest, what's happening over OGL and what's commonly known as DX10-class hardware, anyway?
01:12:27 <Philippa> I mean that a game engine is much more than a graphics engine
01:12:35 <Philippa> it was even back on the 386
01:12:49 <ddarius> Philippa: Obviously...
01:12:55 <Philippa> these days, the scaling on that'll kill you
01:14:02 <ddvlad> Hmm... I'll try to make a point for Haskell, especially since other programming languages which have been proposed are thoroughly ugly: C++, Java and C#
01:14:58 <Philippa> yeah, haskell will help a lot. It'll still be extremely hard to keep pace with anything recent technologically, especially if you want to have good enough tools to produce any real amount of content with
01:15:10 <quicksilver> ddvlad: a 'game' engine as opposed to a graphics engine has to deal with things like physics, particles, collision detect, etc.
01:15:12 <Philippa> or rather, with anything recent /and/ high-end
01:15:37 <Philippa> networking. Which affects how you handle the rest of the simulation
01:15:42 <quicksilver> ddvlad: it's surprisingly hard to make a "general purpose" game engine; they inevitably end up encoding certain assumptions about a particular game.
01:15:53 <ddarius> ddvlad: It's near impossible to judge this (partially from lack of information, partially because Haskell throws in another significant unknown), but it seems that you probably don't have enough time/effort budgeted.
01:16:01 <quicksilver> that's why the rather small number of successful general purpose game engines are so valuable.
01:16:11 <ddarius> (Though, with C++, say, it be easier to say that.)
01:16:16 <quicksilver> e.g. why the UT team manage to sell theirs so profitably :)
01:16:36 <Philippa> that, and the Unreal Engine's tooling is pretty awesome from what I've heard
01:16:36 <quicksilver> (and they're not truly general purpose, of course; they just match the kinds of games people want to write)
01:16:49 <quicksilver> one of the UE devs hangs around here sometimes :P)
01:17:05 <ddvlad> quicksilver: we settled for a graphics engine and the first (demonstrational?) game e hoped to be a TBS. So no particle and physics thingies. That at least we have decided
01:17:23 <wli> Aren't there a few different (typically source-licensed but proprietary) components?
01:17:26 <wli> Physics engines and graphics engines are the two components I've heard most about.
01:17:49 <Philippa> wli: depends what you look to buy. Unreal's a complete package.
01:18:32 <quicksilver> ddvlad: TBS = turn based simulation?
01:18:36 <wli> I've heard mostly about physics and graphics as components. What are the others?
01:18:43 <ddvlad> quicksilver: s/simulation/strategy
01:18:51 <Philippa> ddvlad: so actually you're just looking to push a crapload of polygons and probably with no real lighting issues?
01:18:51 <quicksilver> wli: networking, as philippa said
01:18:59 <ddarius> wli: Philippa already listed others.  Input and sound are more.
01:19:09 <wli> Thanks.
01:19:13 <andrewbwm> I am the project managet vlad is talking about, where project manager is an overrated title i just made up
01:19:14 <quicksilver> ddvlad: unless you are totally uninterested in pretty effects, I doubt you'll manage without a particle system.
01:19:18 <Philippa> seconded
01:19:24 <Philippa> on the upside, particle systems are easy
01:19:36 * ddarius hugs particle systems.
01:19:46 <quicksilver> ddvlad: and I'd be surprised if you want *no* physics. Will there not be a notion of 'height'?
01:19:47 <andrewbwm> we want lighting, and a particle system
01:19:55 <Philippa> and doing flashy things with them is much easier in something like Haskell where even if you derive Read and Show you can probably get away with handling it to a tech-smart artist
01:20:07 <quicksilver> will missile weapons not follow natural curves?
01:20:19 <ddvlad> i see. so basically total commitment or agony and being hated by others
01:20:20 <ddarius> quicksilver: Reality is overrated.
01:20:25 <Philippa> quicksilver: that sort of thing's not what gamedev people mean when they say 'no physics'
01:20:43 <quicksilver> Philippa: no, but it's a continuum isn't it?
01:20:51 <Philippa> though missiles may not bother and may nor even be in scale in a TBS
01:21:02 <ddarius> ddvlad: No matter how you cut it, it's likely to be that way (albeit with "total commitment" not being that strong but "commitment" being necessary.)
01:21:19 <andrewbwm> some of this like missiles are details
01:21:21 <Philippa> and make that an inclusive or
01:21:47 <Philippa> andrewbwm: it's called a hypothetical
01:21:52 <sjanssen> jedbrown: the third argument keeps count of the number of times a thread "meets" itself
01:21:54 <Philippa> it's representative of a class of stuff
01:22:02 <sjanssen> jedbrown: this should never happen, but the spec requires it
01:23:01 <ddarius> sjanssen: It probably gets optimized off anyway.
01:23:09 <ddvlad> as a first step towards OpenGL enlightenment, I'm off to properly understand monads.
01:23:18 <ddvlad> Thank you very much for your input, everyone
01:23:21 <sjanssen> ddarius: I highly doubt that
01:23:25 <jedbrown> sjanssen: Yeah, I noticed, but you must `putMVar finish (t,b)'
01:23:31 <ddarius> Raytraced games are the future
01:23:41 <jedbrown> sjanssen: Otherwise it is not being used at all.
01:23:47 <Philippa> ddarius: they aren't and almost certainly never will be. You can always do more with approximate tricks, unfortunately
01:24:02 <sjanssen> ddarius: it requires quite a bit of analysis to prove that the argument is constantly 0
01:24:06 <ddarius> sjanssen: Ah I see it.
01:24:07 <sjanssen> jedbrown: ha, good catch!
01:24:58 <hpaste>  sjanssen annotated "chameneos-redux. 5x faster than Mozart/Oz" with "fixed version, nice catch jedbrown" at http://hpaste.org/4108#a2
01:25:01 <ddarius> Philippa: There are things that may make it better to raytrace (and it's not like you can't do approximation tricks with raytracing).  But seriously, it won't be for a long long time
01:25:57 <Philippa> 30+ years, I reckon. We ought to be kicking a fun number of cores around by then
01:25:59 <ddarius> Philippa: I suspect they'll probably become mixed before then.
01:26:17 <ddarius> Philippa: Probably less than 30 years, probably a lot less.
01:26:42 <ddarius> Philippa: Exponential curves are easy to underestimated.
01:27:27 <Philippa> yeah, but there's a lot more detail to be added yet and probably an entire new task we're not really doing at the moment to be had
01:27:32 <mmaruseacph2> ddarius: not with runge kutta methods and other like those
01:28:03 <mmaruseacph2> ddarius: runge-kutta of higher order and other prediction-corection methods
01:28:20 <wli> mmaruseacph2: What's going on with Runge-Kutta?
01:28:36 <ddarius> Philippa: I'm not sure what exactly you are referring to, but, there is (also) a lot more low-hanging fruit in the raytracing world.
01:28:42 <ddarius> Performance-wise.
01:29:07 <mmaruseacph2> aproximating the exponential curves exactly
01:29:35 <Philippa> ddarius: simulation detail, which needs rendering
01:29:35 <mmaruseacph2> nevermind
01:29:42 <wli> mmaruseacph2: (AIUI there are symplectic Runge-Kutta -like methods going around for various sorts of physical systems that maintain interesting invariants.)
01:31:35 <quicksilver> isn't the thing about raytracing that the clever tricks you can do make it far worse?
01:31:52 <quicksilver> Why would you want raytracing? For stuff like full transparency, internal reflection, refraction...
01:31:59 <quicksilver> but these tricks are absurdly expensive...
01:32:00 <quicksilver> no?
01:32:22 <ddarius> quicksilver: Not really.  Nowadays the big expense is probably global illumination.
01:33:02 <wli> If there's enough hardware to throw at the problem, I don't see why you wouldn't just do it.
01:33:20 <ddarius> wli: Do what?
01:33:26 <wli> Raytrace.
01:34:03 <Philippa> the value of "enough" gets interesting. What kinda geometry are you happy handling?
01:34:04 <ddarius> What hardware there is isn't made for raytracing and you can't require all your users to buy 1024-core machines to play your game.
01:34:37 <ddarius> Philippa: With very high complexity geometry is where raytracing starts beating rasterization.
01:35:00 <Philippa> yet, anyway. Wait 15 years and you can probably start requiring 1024 cores in the high end
01:35:09 <hpaste>  jedbrown annotated "chameneos-redux. 5x faster than Mozart/Oz" with "Fixed leading-space formatting" at http://hpaste.org/4108#a3
01:35:09 <ddarius> Philippa: Probably before then.
01:35:14 <wli> I honestly don't know a whole lot about this.
01:35:41 <wli> The BBC had some AMD guy claiming cinematic quality realtime video "next year" in some video thing.
01:35:57 <Philippa> oh, for some values of 'cinematic quality' it's here now
01:36:08 <ddarius> "cinematic quality" for "CG movies"
01:36:22 <Philippa> there aren't so many games using pre-rendered video these days
01:36:35 <ddarius> I said what I meant in a confusing way.
01:36:46 <wli> I don't know what the guy meant entirely.
01:37:21 <Philippa> that next year you'll be able to buy hardware that could render something along the lines of Toy Story in realtime
01:37:37 <ddarius> Philippa: Exactly what I was trying to say.
01:38:00 <wli> But not a video game rendered in Toy Story quality?
01:38:12 <Philippa> depends on the game
01:38:24 <quicksilver> Some PS3 games are in that league
01:38:28 <ddarius> Unpredictable motion has costs.
01:38:30 <quicksilver> take a look at GT5 on a HDTV
01:38:32 <Philippa> for some values of 'quality', Bioshock on high class hardware does rather better
01:38:35 <jedbrown> sjanssen: With that formatting fix, it ought to be ready to submit.
01:38:56 <wli> quicksilver: GT5?
01:39:01 <quicksilver> gran turismo
01:39:18 <quicksilver> not really my kind of game. But the rendering quality is very impressive.
01:39:42 <quicksilver> it looks much like real film footage of cars racing, except there is no mud and the cars are very shiny :)
01:40:10 <wli> My budget is allocated to purposes not including consumer electronics.
01:41:04 <Philippa> hey, I'm probably not buying a new console for at least a year myself and by most people's standards I'm an avid gamer - there's a difference between that and the lack of cultural connection that comes from not playing or paying attention at all
01:41:39 <quicksilver> right, I'm not buying a PS3 either
01:41:43 <quicksilver> but I saw one in a shop :)
01:41:48 * ddarius (now) lacks that "cultural connection"
01:41:57 <quicksilver> and surely it's relevent to discuss what it looks like, even if I don't want to buy one :)
01:42:04 <quicksilver> since we were discussing graphics quality
01:42:17 <ddarius> Haskell on the PS3 would be... interesting.
01:42:47 <wli> I don't watch TV, listen to the radio, play video games, or read mainstream newspapers or magazines.
01:43:21 <ddarius> wli: Me neither (though that last is because I don't (currently) read any newspapers or magazines.)
01:43:26 <wli> (or mainstream websites)
01:43:27 * ddarius misses his Washington Post.
01:43:36 * osfameron watches TV and reads newspapers occasionally, but I'm utterly out of touch with games (tetris rocked though)
01:43:52 <ddarius> Bubble Bobble all the way!
01:48:36 <wli> So I'm totally out of touch.
01:49:38 <quicksilver> ddarius: there are some people who did some work on getting haskell compiling to the PS3 coprocessors
01:50:28 <sjanssen> y'know, DPH's seems perfect for cell co-processors
01:51:33 <sjanssen> erm, DPH
01:52:13 <sjanssen> it even sets up gangs to work on the data simultaneously
01:52:13 <wli> Translating that to an app making good use of them is another problem entirely. :(
01:52:16 <ddarius> quicksilver: Except that I doubt anyone would do it, I know I'm not, with a good (but not magically so) backend I wouldn't be surprised if Haskell could make a splash on the PS3.
01:53:11 <quicksilver> ddarius: I think the PS3 permits homebrew games? downloading over the net or something?
01:53:18 <quicksilver> if it does, then that would seem to be an interesting angle
01:53:22 <quicksilver> I've not looked into it
01:53:30 <quicksilver> PS2 wouldn't run homebrew games without being hacked.
01:54:36 <Philippa> ddarius: been thinking that for years. Until recently my vote would've gone for a carefully-built ML variant first, admittedly
01:56:02 <ddarius> Philippa: I wouldn't be surprised if that doesn't matter too much.  Anything that makes good use of the hardware will more than make up for other drawbacks (within reason).
01:56:42 <Philippa> predictability's a win
01:57:05 <quicksilver> well my big question with haskell would be "would ordinar games programmers end up finding it hard to get predictable framerates due to sudden forcing of large thunks or GC?"
01:57:17 <quicksilver> if they did, haskell would piss them off
01:57:19 <quicksilver> I guess :)
01:57:31 <ddarius> True, but unpredictably varying between two and one order of magnitude faster is better than predictable being slow.
01:57:51 <quicksilver> if you could build a system which helped the programmer not suffer from that problem, then the other advantages might be compelling.
01:58:38 <ddarius> quicksilver: The GC thing can be done.  Laziness would probably require somewhat knowing what you are doing but probably in a reasonably encapsulable way.
01:59:07 <quicksilver> I certainly don't have any trouble getting good framerates in my openGL messing around
01:59:10 <ddarius> I.e. it is probably doable to make a set of libraries and a Haskell implementation that would not be too "quirky"
01:59:11 <quicksilver> but, then, I'm doing very simple stuff
01:59:26 <quicksilver> whereas professional games programmers generally run at 99% of what the hardware is capable of.
01:59:50 <wli> I'm too clueless for an OpenGL "Hello World" but graphics is a bit far afield for me.
02:01:12 <Philippa> the easiest way to deal with GC in the circumstances where you actually want to use it on the SPUs is to just not bother, anyway
02:01:37 <Philippa> perhaps, if you're feeling generous, do an inference pass for linearly-used stuff
02:02:13 <Philippa> and then invoke it manually between each pass of whatever you're doing
02:02:44 <ddarius> Indeed, something that gives some more control over allocation probably captures most of it.
02:05:18 <wli> Though to be honest, visualization would help me a bit.
02:08:44 <waern> swiert: Test.IOSpec.Ref is missing from the IOSpec repository
02:12:43 <goalieca> @src foldl'
02:12:43 <lambdabot> foldl' f a []     = a
02:12:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:13:32 <goalieca> so seq makes it strict. damn im' tired
02:13:43 <goalieca> couldn't remember on my own
02:14:38 * ddarius prefers foldl' f a (x:xs) = (foldl' f $! f a xs) xs
02:15:49 <wli> Me too.
02:21:43 <swiert> waern: That should probably be Test.IOSpec.IORef...
02:22:30 <swiert> waern: Where is it referenced from?
02:25:35 <FireShaft> can someone please give me some tutorials on haskell? Please?
02:26:33 <dmwit> Sure!
02:26:53 <dmwit> Do you want the mind-numbingly fast one or the nice, easy slow one?
02:29:29 <hpaste>  dmwit pasted "'compact' makes me uneasy" at http://hpaste.org/4109
02:30:16 <dmwit> ?where YAHT
02:30:16 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
02:30:20 <dmwit> ?where gentle
02:30:20 <lambdabot> http://www.haskell.org/tutorial/
02:30:42 <dmwit> FireShaft: The first is the easier tutorial, and the second is the more difficult one.
02:30:50 <FireShaft> thank you
02:30:53 <FireShaft> thanks a lot :)
02:32:01 <MyCatVerbs> However, both start out easy-ish and get harder as they go along. One really funny strategy is to read YAHT first, then switch to the Gentle Tutorial when you get stuck, then switch to YAHT when you get stuck with that, then... ad infinitum, or until you finish both. ;)
02:32:28 <FireShaft> hehe sorta Recursive parsing
02:32:53 <MyCatVerbs> Coroutines, perhaps. :)
02:52:05 <swiert> @djinn ((b->a)->a) -> ((c->b)->b) -> ((c->a)->a)
02:52:08 <lambdabot> -- f cannot be realized.
03:04:56 <wli> When building agda, I get:
03:05:06 <wli> dist/build/Syntax/Parser/Parser.hs:29:0:
03:05:06 <wli>      error: ../../undefined.h: No such file or directory
03:05:14 <wli> What just hit me?
03:06:59 <dmwit> That's kind of a funny error.
03:07:29 <chessguy> @undo t gs s = do { c <- pL s; c gs }
03:07:29 <lambdabot> t gs s = pL s >>= \ c -> c gs
03:07:36 <wli> How so?
03:08:07 <chessguy> @pl \gs s -> pL s >>= \ c -> c gs
03:08:07 <lambdabot> flip ((>>=) . pL) . flip id
03:08:17 <dmwit> I mean, undefined.h is clearly undefined.
03:08:49 <dmwit> ?pl \c -> c gs
03:08:49 <lambdabot> ($ gs)
03:09:11 <dmwit> t gs s = pL s >>= ($ gs) -- not a bad definition
03:09:41 <dmwit> ?pl s gs -> pLs >>= ($ gs)
03:09:41 <lambdabot> (line 1, column 6):
03:09:41 <lambdabot> unexpected ">" or "-"
03:09:41 <lambdabot> expecting variable, "(", operator or end of input
03:09:48 <dmwit> ?pl \s gs -> pLs >>= ($ gs)
03:09:48 <lambdabot> const ((pLs >>=) . flip id)
03:09:55 <dmwit> ?pl \s gs -> pL s >>= ($ gs)
03:09:55 <lambdabot> (. flip id) . (>>=) . pL
03:10:13 <dmwit> whoa
03:11:23 <dmwit> Bah, monomorphism restriction.
03:48:52 <dmwit> ?src Monad
03:48:52 <lambdabot> class  Monad m  where
03:48:52 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:48:52 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
03:48:52 <lambdabot>     return      :: a -> m a
03:48:52 <lambdabot>     fail        :: String -> m a
03:54:56 <osfameron> it has to be said that's fairly compact for a powerful abstraction
03:56:07 <osfameron> on #moose, people were saying they'd spoke to spj at Oscon, and that the Monad might not end up being the ultimate abstraction
03:56:27 <integral> What's that meant to mean?
03:56:27 <wli> What would be, if not monads?
03:56:27 <osfameron> if I understood correctly, because people still find it inconvenient, and work around it with unsafeFoo calls
03:56:48 <dmwit> Do they propose an alternate solution?
03:56:50 <osfameron> oh, I have no idea - I'm just interested :-)
03:57:18 <osfameron> bear in mind this is a short exchange on irc with someone who had once spoken to spj...
03:57:53 <pejo> Calling something 'the ultimate abstraction' is a quite strong statement.
03:58:17 <osfameron> oh, well "ultimate abstraction" were my words, and very probably badly chosn
03:59:50 <quicksilver> osfameron: when I've previously heard SPJ talk about the problems of 'using monads too much'
03:59:57 <quicksilver> he's normally talking about over-linearisig
04:00:07 <quicksilver> (not the unsafeFoo stuff at all; that stuff is rather the point)
04:00:26 <osfameron> as in monads break parallelism?
04:00:38 <quicksilver> not quite what I meant, but you could say that yes
04:00:57 <quicksilver> it's more about programmer convenience though
04:01:08 <quicksilver> having to give names to intermediate values when you don't want to is clumsy
04:01:15 <quicksilver> makes you look like  a first-grade programm
04:01:20 <quicksilver> a <- b+1
04:01:24 <quicksilver> c <- a*2
04:01:29 <quicksilver> d <- c-1
04:01:31 <quicksilver> return d
04:01:32 <osfameron> heh
04:01:56 <quicksilver> there is a natural yo-yo when you discover a cool new concept
04:02:06 <quicksilver> the first wave is to discover the amazing generality of the concept
04:02:15 <quicksilver> "Ohh, look, *all* these different things are monads!"
04:02:21 <quicksilver> the swingback is
04:02:31 <osfameron> quicksilver: am I misrepresnting the brief comments by mst on #moose yesterday?  I'm almost certainly not *understanding* them
04:02:32 <quicksilver> "Hmm.. I wish they weren't monads, monads are so restrictive"
04:02:46 * quicksilver checks how far back his scrollback in #moose goes
04:04:46 <quicksilver> osfameron: no, I think you're representing mst correctly and mst is mis-representing spj
04:04:49 <quicksilver> but heck, I wasn't there :P
04:04:55 <osfameron> heh :-)
04:04:56 <quicksilver> so I'm ill-qualified to make such guesses
04:05:14 <quicksilver> I don't think unsafePerformIO is a symptom of anythign wrong with monads
04:05:15 <quicksilver> not remotely
04:05:23 <osfameron> I think I'll now shut up and come back to the topic when I understand monads better/at all
04:05:25 <quicksilver> it's just a symptom of haskell not having the IO abstractions people want to use
04:05:55 <osfameron> (I got a kickstart from the recent playing with it and comments though.  The Maybe stuff (and Not Just Maybe stuff) is really cool)
04:06:00 <quicksilver> there ought to be a set of primitives which give eople the ability to do the tricks they want to do
04:06:09 <quicksilver> without breaking ref transparency
04:06:15 <quicksilver> it's just we don't know what those primitives are
04:06:17 <quicksilver> well, I don't.
04:06:20 <osfameron> ah
04:08:50 <Saizan> we need a substitute for ReaderT..
04:21:32 <mass0ud> Hello
04:42:51 <hpaste>  jedbrown pasted "Building ndp with ghc-6.8.1" at http://hpaste.org/4110
04:43:10 <jedbrown> I think this is fixed in HEAD, but should I still report it?
04:46:08 <matthew-_> can't hurt. Would be even better if you checked out HEAD and saw whether you could reproduce the bug there
04:47:40 <jedbrown> I looked at the code for that function and lots has changed in HEAD.
04:48:15 <jedbrown> I'll build HEAD before I report anything.
04:48:21 <dmwit> Is there a reason to export a type without its constructors?
04:48:33 <TSC> Sure, an abstract data type
04:48:42 <dmwit> I mean, if it's an abstract type, do you even need to export the type at all?
04:48:50 <dmwit> Or can you just export the functions that work on the type?
04:48:55 <TSC> Yeah, so other modules can use the type name
04:48:57 <matthew-_> depends if you need the type
04:49:18 <dmwit> ...oh right
04:49:20 <TSC> Otherwise they'll get unknown identifier errors
04:49:24 <dmwit> ?slap dmwit
04:49:24 * lambdabot pokes dmwit in the eye
04:50:31 <TSC> Haskell has the wonderful property of making people feel very smart and very dumb at the same time (:
04:51:04 <TSC> For me, usually the latter
04:52:04 <vincenz> @remember TSC Haskell has the wonderful property of making people feel very smart and very dumb at the same time (:
04:52:04 <lambdabot> It is stored.
04:55:24 <earthy> :)
04:59:44 <yaxu> TSC: it's more of an oscillation between the two for me
05:05:11 <yaxu> ha
05:07:00 <yaxu> as an experiment i tried manipulating a haskell readline prompt from a forked thread
05:07:19 <yaxu> it worked, but when i quit my program to the ghci prompt it carried on working
05:07:58 <yaxu> every 10th of a second 'ho' got added to the ghci prompt, makes it difficult to quit :)
05:09:38 <yaxu> every 100th of a second in fact
05:10:37 <TSC> ho ho ho, merry christmas
05:11:14 <yaxu> :)
05:11:30 <osfameron> yoyohonads?
05:12:56 <yaxu> it seems though that forked thread can't edit a readline prompt at the same time as me
05:13:03 <yaxu> a shame
05:23:13 <gbacon> given ArrowXml a => a (String,[String]) XmlTree, how do I pluck out the components of the input pair?
05:25:36 <gbacon> mmm444: can you help with an arrow question?
05:26:15 <Botje> :t first
05:26:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
05:26:31 <Botje> argh. that's not it
05:26:41 <gbacon> right, I tried first >>> mkText, but it doesn't typecheck
05:27:10 <oerjan> :t arr fst
05:27:10 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) a
05:27:20 <vincenz> :t pure fst
05:27:20 <lambdabot>     Ambiguous occurrence `pure'
05:27:20 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
05:27:20 <lambdabot>                           or `pure', imported from Control.Arrow
05:27:26 <gbacon> ahh
05:27:29 <vincenz> :t Control.Arrow.pure fst
05:27:29 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) a
05:27:59 <oerjan> pure = arr
05:28:05 <vincenz> @src pure
05:28:05 <lambdabot> Source not found. My mind is going. I can feel it.
05:28:11 <vincenz> @src Control.Arrow.pure
05:28:11 <lambdabot> Source not found. I feel much better now.
05:28:14 <vincenz> @src arr
05:28:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:28:24 <oerjan> they're defaults are pure = arr, arr = pure
05:28:28 <oerjan> *their
05:28:33 * vincenz thinks pure should be used
05:28:36 <gbacon> thanks!
05:28:45 * gbacon used pure
05:28:46 <oerjan> vincenz: except that's ambiguous
05:28:52 <vincenz> oerjan: for now
05:29:07 <vincenz> :t Control.Applicative.pure
05:29:07 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
05:29:13 <vincenz> :t Control.Arrow.pure
05:29:13 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
05:29:22 <oerjan> :t liftA0
05:29:22 <lambdabot> Not in scope: `liftA0'
05:29:30 <oerjan> er...
05:29:47 <oerjan> there was some synonym for Applicatives too i think
05:30:48 <oerjan> nah, maybe i'm confusing with liftA = fmap = (<$>)
05:30:57 <gbacon> at the toplevel, I have doc :: ArrowXml a => [Foo] -> a XmlTree XmlTree.. would it be better to incorporate [Foo] into the arrow?
05:31:34 <vincenz> oerjan: is there some relation between applicatives and arrows?
05:31:35 <oerjan> so since pure is the _only_ name for the Applicative it would sort of make sense to import Control.Arrow hiding (pure)
05:31:35 <gbacon> the intent is to scatter bits from the list into the document
05:31:53 <oerjan> vincenz: they are both generalizations of Monads
05:31:59 <vincenz> oerjan: but not on the same axis?
05:32:23 <oerjan> no.  if the ArrowApply class is any guide, Monad is the smallest common extension
05:32:30 * vincenz nods
05:32:39 <vincenz> I was hoping one would be parent of the other
05:32:49 <vincenz> hence why 'pure' should be used, but if that is not the case..
05:32:55 <vincenz> then pure is best left for Applicative
05:33:11 <oerjan> Arrow generalizes kleisli arrows (a -> m b) , while Applicative generalizes actions themselves (m a)
05:33:30 <vincenz> Thanks for clarifying that :)
05:35:49 <faxathisia> actually
05:36:01 <oerjan> Arrow.pure f ~= return . f, while Applicative.pure x ~= return x
05:36:27 <vincenz> so if we generalized some way
05:36:30 <vincenz> to have (.) == ($)
05:36:35 <vincenz> then they'd be the same :)
05:36:57 <oerjan> well (.) is fmap
05:37:01 <faxathisia> to define a matrix type in haskell, I should use a typeclass.. then I could define instances for Num a => [[a]], an instance for an array
05:37:05 <faxathisia> would that be the best?
05:37:06 <oerjan> (for ->)
05:37:29 <oerjan> and $ is fmap for the Indentity monad i guess
05:37:30 <vincenz> faxathisia: use Array
05:37:36 <vincenz> faxathisia: Array allows higher-dimensional indices
05:37:40 <oerjan> *Identity
05:37:50 <vincenz> so pure a = fmap return a
05:38:01 <vincenz> @type fmap return a
05:38:03 <faxathisia> What is the use of a matrix that has more than 2D?
05:38:06 <lambdabot> Not in scope: `a'
05:38:09 <vincenz> @type fmap return
05:38:10 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
05:38:22 <vincenz> faxathisia: higher dimensiona data?
05:38:32 <oerjan> faxathisia: tensors
05:38:46 <vincenz> voxels
05:40:48 <faxathisia> if I used a typeclass could I make an instance for array which is purely function and also an instance for STArray which is mutable?
05:40:57 <faxathisia> (maybe... mutable is the wrong word?)
05:41:31 <oerjan> faxathisia: if you look at the Array modules there are two different type classes for immutable and mutable arrays
05:42:42 <oerjan> since just about everything you do with mutable ones has to be in a monad
05:43:25 <Saizan> mmh, maybe with associated types? or you could always use the identity monad
05:58:24 <quicksilver> vincenz: no; higher dimensional data is still 2D
05:58:37 <quicksilver> vincenz: a 3x3 matrix is still a 2D matrix :)
05:58:45 <quicksilver> as oerjan said, tensors
05:58:46 <mauke> @pl \k -> m (\r -> f r k)
05:58:46 <lambdabot> m . flip f
05:59:47 <vincenz> quicksilver: that's bigger dimension, not higher dimension :)
05:59:51 * vincenz meant more dimensions
06:00:20 <quicksilver> well, it was in the context of 'Array allows higher dimensional indices'
06:00:31 <quicksilver> in which context, 2D arrays clearl model matrices (of all sizes)
06:00:32 <vincenz> quicksilver: right
06:00:37 <quicksilver> while 3D arrays model tensors
06:00:37 <vincenz> 2D = (i,j)
06:00:40 <vincenz> 3D = (i,j,k)
06:03:24 <mauke> @pl \k -> f (\r _ -> k r) k
06:03:24 <lambdabot> f =<< (const .)
06:03:38 <faxathisia> Since, readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
06:04:01 <faxathisia> x <- readArray arr 0 ... should x be of type e.g. Int, if I had an array of Ints?
06:04:12 <mauke> yes
06:05:08 <mauke> :t (liftM return >>=)
06:05:12 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *) b. (Monad m, Monad m1) => (m1 (m a1) -> m1 a1 -> b) -> m1 a1 -> b
06:08:02 <jedbrown> Also, fields f(t,x,y,z) projected into a finite dimensional space are uses of higher-dimensional arrays.
06:11:09 <Saizan> jedbrown: have you been successful at building ghc HEAD?
06:11:33 <jedbrown> Saizan: It's running, but not done yet.
06:12:26 <Saizan> heh, i've broken associated type synonim right now :(
06:13:02 <yaxu> i told a lie earlier, readline *does* work with concurrency :)
06:13:20 <Saizan> i.e. ghc panic on 6.8.1
06:16:22 <faxathisia> @undo do return $ f x
06:16:22 <lambdabot> return $ f x
06:16:37 <shapr> I wonder when the shootout will have ghc 6.8
06:18:03 <shapr> @users
06:18:03 <lambdabot> Maximum users seen in #haskell: 401, currently: 358 (89.3%), active: 14 (3.9%)
06:18:20 * shapr boings cheerfully
06:19:03 <faxathisia> @hoogle (Monad m) => m a -> m
06:19:06 <lambdabot> Prelude.id :: a -> a
06:19:06 <lambdabot> Prelude.return :: Monad m => a -> m a
06:19:06 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:20:24 <mauke> faxathisia: kind error
06:20:26 <byorgey> faxathisia: what are you looking for?  m a -> m doesn't make sense.
06:23:04 <faxathisia> @hoogle (Monad m) => m a -> a
06:23:05 <lambdabot> Prelude.id :: a -> a
06:23:05 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:23:05 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
06:23:11 <faxathisia> thhat sort of thing
06:23:17 <faxathisia> but I think it defeats the purpose
06:23:44 <mauke> yeah, what if m a doesn't contain an a?
06:23:54 <mauke> should it just invent something?
06:24:07 <Saizan> undefined!
06:24:37 <Saizan> faxathisia: maybe you want a comonad, extract :: w a -> a
06:25:39 <faxathisia> what would be the type of something which takes 3 ints and produces a ST s (STArray s Int Int) ?
06:25:56 <faxathisia> Int -> Int -> Int -> ST s (STArray s Int Int) seems useless
06:25:57 <mauke> Int -> Int -> Int -> ST s (STArray s Int Int)
06:26:02 <mauke> what
06:26:09 <Saizan> why useless?
06:26:53 <faxathisia> ok then I think it is the correct type
06:27:04 <faxathisia> in that case
06:29:14 <ogex> how can I output to standard output using ANSI colors? I want to mimic echo -e "\e[1;32mfoo" to get a green text
06:30:11 <mauke> > "\e"
06:30:12 <lambdabot>  Illegal escape sequence at ""\e"" (column 1)
06:30:21 <integral> > "\esc"
06:30:21 <lambdabot>  Illegal escape sequence at ""\esc..." (column 1)
06:30:32 <int-e> > "\ESC"
06:30:32 <mauke> putStrLn "\27[1;32mfoo"
06:30:32 <lambdabot>  "\ESC"
06:30:38 <mauke> > "\27"
06:30:39 <lambdabot>  "\ESC"
06:31:33 <ogex> thanx mauke, it works.
06:32:11 <ogex> (even in emacs!)
06:36:10 <faxathisia> @undo do y <- (f x) ; g y
06:36:10 <lambdabot> (f x) >>= \ y -> g y
06:36:33 <mauke> @. pl undo do y <- (f x) ; g y
06:36:33 <lambdabot> g =<< f x
06:39:19 * osfameron wants the Maybe monad in Perl :-(
06:39:32 <faxathisia> so write it? :p
06:40:26 <dmead> > "I HAVE" ++ "THE POWER"
06:40:29 <lambdabot>  "I HAVETHE POWER"
06:40:49 <Jaak> s/HAVE/HAS/
06:41:31 <exDM69> Jaak: :)
06:41:41 <osfameron> faxathisia: yeah.  I believe yrlnry has written a monad framework for Perl.  And I read a post on a decent syntax for it (but using source filters... yuck)
06:41:43 <dcoutts_> I've been trying to persuade kolmodin to write the operational semantics of LOLCODE
06:42:09 <mauke> haha
06:43:57 <dcoutts_> t1, store -> t1', store'
06:43:57 <dcoutts_> ------------
06:43:57 <dcoutts_> HAI t1 KTHXBYE, store -> HAI t1' KTHXBYE, store'
06:44:50 * oerjan 's mind explodes
06:45:53 <dcoutts_> it's just a simple small step operational semantics
06:46:05 <mux> we are left to wonder what t1 and store are
06:46:10 <mux> I guess tore is heap, and t1 a term?
06:46:15 <dcoutts_> right
06:46:21 <mux> fairly usual
06:46:25 <dcoutts_> yep
06:46:25 <dcoutts_> modelling the IO behaviour is quite a lot more interesting
06:46:38 <swiert> that'd make a great TMR article (wink, wink)
06:46:50 <dcoutts_> hah hah, yeah
06:47:07 <oerjan> i assume HAI ... KTHXBYE is sort of { ... } or begin ... end?
06:47:15 <dcoutts_> oerjan: yep, blocks
06:47:46 <dcoutts_> currently LOLCODE is restricted to stdin/stdout IO, so the semantics could model it as String -> String
06:47:59 <dcoutts_> or as continuations
06:48:08 <dcoutts_> there are several possibilities
06:48:08 <faxathisia> well I can't figure out how to write addition
06:48:12 <faxathisia> but here's my idea
06:48:25 <hpaste>  faxathisia pasted "vec3" at http://hpaste.org/4111
06:48:58 <faxathisia> I guess if I changed the vec3' functions to use the identity monad, it would work in the same way as the vec3 ones
06:49:09 <faxathisia> so then I could use a typeclass and have either mutable or immutable vectors
06:49:10 <dcoutts_> kolmodin: want to co-author a TMR article on the operational semantics of LOLCODE?
06:49:31 <faxathisia> but I was wondering how sort of ridiculous it would be to do
06:50:21 <faxathisia> any thoughts?
06:50:40 <faxathisia> (because I want to write some matrix code which is optionally mutable)
06:52:30 <pejo> dcoutts, using LOLCODE as test for Ott?
06:54:06 <jedbrown> faxathisia: why not vec3'Double = amap (*2)
06:54:34 <dcoutts_> pejo: Ott?
06:54:40 <faxathisia> @index amap
06:54:40 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
06:55:03 <pejo> dcoutts, that tool by Sewell et al for the working semanticist. Hm, maybe I misremember the name?
06:55:33 <faxathisia> jedbrown: seems like It's not applicable
06:55:53 <dcoutts_> pejo: ah found it: http://www.cl.cam.ac.uk/~pes20/ott/
06:55:53 <lambdabot> Title: Ott
06:55:54 <Saizan> ?type amap
06:55:57 <lambdabot> Not in scope: `amap'
06:56:12 <pejo> dcoutts, well, if you weren't I guess they picked a nice syntax for it. :-)
06:56:15 <jedbrown> faxathisia: The big trouble with immutable arrays is sequential updates using neighbors.  Gauss-Seidel doesn't work, for instance.
06:56:25 <oerjan> :type Data.Array.IArray.amap
06:56:32 * osfameron reads through http://sleepingsquirrel.org/monads/monads.html , wonders if it's better to let Perl be Perl..
06:56:33 <lambdabot> Title: Monads in Perl
06:56:41 <oerjan> ?type Data.Array.IArray.amap
06:56:41 <jedbrown> faxathisia: How does it not work?
06:56:46 <lambdabot> forall e' e (a :: * -> * -> *) i. (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.IArray a e') => (e' -> e) -> a i e' -> a i e
06:57:32 <faxathisia> ah it does infact
06:57:34 <faxathisia> I made a mistake
06:57:41 <faxathisia> thanks, that's better
06:58:03 <quicksilver> your add should be a zipWith
06:58:09 <quicksilver> but arrays don't seem to have zipWith
06:58:16 <quicksilver> really arrays should be foldable and traversable
06:58:21 <quicksilver> then zipWith comes for free
06:58:40 <faxathisia> I could define foldable and traversable instances mysefl?
06:58:53 <oerjan> quicksilver: the problem is arrays are dynamically sized
06:59:05 <oerjan> otoh so are lists
06:59:27 <oerjan> but for arrays the start index is not fixed either
07:00:06 <jedbrown> It would seem natural to operate on the intersection of the index sets.
07:00:59 <faxathisia> well then I am stuck :|
07:01:10 <oerjan> right, although i think you need to assume things about the Ix instances for that to make sense
07:01:41 <oerjan> (i guess all current instances are nice enough?)
07:02:12 <b_jonas> how do I find out what module I have to import to get instance Monad ((->) t) ?
07:02:37 <oerjan> i.e. i think there is no builtin method for finding the bounds for the intersection
07:02:43 <b_jonas> because it's apparently not in the Prelude or Control.Monad
07:02:59 <oerjan> b_jonas: Control.Monad.Instances
07:03:01 <mauke> Control.Monad.Reader
07:03:08 <oerjan> or that
07:03:20 <faxathisia> how would you define a matrix type in haskell?
07:03:39 <b_jonas> yep, Control.Monad.Instances worked
07:03:42 <quicksilver> oerjan: eh? what does dynamically sized have to do with zipWith :P
07:03:44 <b_jonas> thanks
07:03:50 <b_jonas> how do I find this out from the docs?
07:03:56 <oerjan> Control.Monad.Instances is the default place for those Monad and Functor instances for builtin H98 types that don't already have them
07:04:13 <mauke> osmosis
07:04:22 <mux> Forcing to search mode for keyword Mickey 3d (pub: 129376, URL: http://soundscool.cluscrive.com/songs/musique?search=Mickey 3d)
07:04:22 <lambdabot> Title: SoundsCool
07:04:25 <mux> oops, sorry
07:04:31 <oerjan> b_jonas: the special thing about those is that both the class and the type are defined in H98 but not the combined instance
07:04:34 <quicksilver> oerjan: zipWith would be used for arrays of the same sice as each other
07:04:53 <oerjan> which means the usual rule of define the instance in the same module as one of those doesn't work
07:05:38 <oerjan> quicksilver: well then you probably would want a check that they have the same bounds
07:06:03 <oerjan> which would be more limited than the list case
07:07:01 <jedbrown> The semantics for higher dimensional Ix when the sizes don't match is a problem.
07:07:22 <quicksilver> oerjan: *shrug* the list case doesn't bother
07:07:24 <jedbrown> I'd like a good way of extracting submatrices, but this requires more than Ix.
07:07:29 <quicksilver> oerjan: I don't really see a difference
07:07:50 <quicksilver> oerjan: you can perfectly sensibly define zipwith for any traversable on the left and any foldable on the right...
07:08:03 <b_jonas> oerjan: I see
07:08:09 <quicksilver> but if the foldable is "shorter" than the traversable, it doesn't make sense
07:08:10 <oerjan> quicksilver: what jedbrown is saying, you might want to use the intersection of the index sets, which is essentially what lists to
07:08:26 <quicksilver> ah well yes, that would be slightly clever
07:09:12 <oerjan> but Ix does not support this, at least not easily
07:09:46 <wli> The practical needs of matrix manipulation tend to warrant data structures specifically for resembling matrices which are rather far from simple arrays, though built atop arrays in various fashions.
07:09:49 <oerjan> jedbrown: i guess you _could_ assume that the range orders are consistent for submatrices
07:10:01 <yaxu> anyone have luck getting the ghc-6.8.1 binaries working under ubuntu?  i need libreadline4
07:10:16 <yaxu> sorry if this is a FAQ
07:10:18 <wli> The practical needs of matrix manipulation tend to warrant data structures specifically for REPRESENTING matrices which are rather far from simple arrays, though built atop arrays in various fashions.
07:11:23 <wli> block, band, bordered band, upper/lower triangular, Toeplitz, etc.
07:11:55 <Saizan> yaxu: http://article.gmane.org/gmane.comp.lang.haskell.cafe/31193/match=alien
07:11:56 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/ysho8n
07:13:44 <jedbrown> wli: That is just compressed storage.  Plenty of interesting matrices are either sparse or dense (and pretty small) so flat arrays are fine.  Those compressed representations are convenient for matrix decomposition.
07:14:05 <yaxu> thanks Saizan
07:14:15 <quicksilver> wli: absolutely but it depends quite a lot what you intend to do with them
07:14:20 <wli> Not just decomposition, but also composition.
07:14:30 <quicksilver> wli: it may well be that faxathisia's intended uses don't require that at all
07:14:48 <wli> Building the things can get rather irritating when such primitives are lacking.
07:14:51 <jedbrown> wli: But for most big problems, matrix decomposition is just too expensive.  Hence we use sparse storage and iterative methods in which we only need to compute matrix-vector products.
07:14:59 <faxathisia> you know I think I should really solve my problem not using matrices
07:15:43 <jedbrown> Composition tends to break the nice structure, so it is not generally done explicitly.
07:16:11 <wli> Not that kind of composition.
07:16:28 <wli> Rather, building them up from smaller pieces.
07:16:45 <jedbrown> (This really isn't something to do in Haskell though.  There are good libraries we can interface with.)
07:16:55 <jedbrown> Oh, indeed.
07:17:57 <jedbrown> Where the action of the whole matrix is computed in terms of actions of those pieces.
07:19:41 <faxathisia> @index guard
07:19:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:26:13 <jedbrown> Is it possible in c2hs #fun to get the out-marshaler to run even when the result is not used (to check an errorcode and possible return error in the IO monad)?
07:30:55 <dcoutts_> jedbrown: I think so
07:31:14 <dcoutts_> jedbrown: have you tried it? does it not work?
07:31:57 <jedbrown> dcoutts_: If I specify an out-marshaller with `Type' outMarsh-
07:32:14 <jedbrown> dcoutts_: Then the generated .hs has no reference to it.
07:32:55 <dcoutts_> jedbrown: can you @hpaste the example
07:32:58 <dcoutts_> @hpaste
07:32:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:35:05 <hpaste>  jedbrown pasted "c2hs out-marshalling" at http://hpaste.org/4112
07:35:26 <Eelis> any idea when the shootout.alioth.debian.org people will use 6.8.1 ?
07:39:10 <faxathisia> @pl (\(_ := o) -> o)
07:39:10 <lambdabot> (line 1, column 7):
07:39:10 <lambdabot> unexpected "="
07:39:10 <lambdabot> expecting natural, identifier, "_" or "("
07:43:37 <Jaak> Is it possible to defunctionalize code that uses GADTs? (Reynolds's defunctionalization.)
07:44:37 <Jaak> the algorithm doesn't directly work but I was wondering if there is known modification that does work with GADTs...
07:46:29 <mnislaih> funny! The guy who started the "St. Petersburg Game" thread in the ML is the singer from Astrud, a famous band in Spain
07:47:10 <faxathisia> @hoogle (a -> Bool) -> [a] -> Int
07:47:10 <lambdabot> No matches, try a more general search
07:47:26 <oerjan> :t findIndex
07:47:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
07:48:17 <dcoutts_> jedbrown: why do you use hE- as the out marshaler rather than hE* ?
07:48:46 <byorgey> @babel es en Puedo preguntarme qué hace este hombre aprendiendo Haskell? Viva!
07:48:46 <lambdabot>   I can ask qué does east man learning Haskell? Live!
07:48:52 <dcoutts_> jedbrown: the c2hs manual says: "Alternatively, the identifier may be followed by a minux sign -, in which case the Haskell type does not appear as an argument (in marshaller) or result (out marshaller) of the generated Haskell function."
07:49:30 <byorgey> uh, right, thanks babelfish
07:49:31 <jedbrown> dcoutts_: That was a hack so that the result tuple didn't include the result, as in IO ((), Rank))
07:50:05 <jedbrown> dcoutts_: Right, it would be nice if I could do: hE*-
07:50:10 <dcoutts_> jedbrown: ok, would you like to file a bug report: http://hackage.haskell.org/trac/c2hs/
07:50:11 <lambdabot> Title: c2hs - Trac
07:50:25 <jedbrown> dcoutts_: But that isn't valid syntax.
07:50:42 <dcoutts_> jedbrown: honestly I'm a bit unsure of what the '-' marshaler modifier actually means or what it's for.
07:51:19 <dcoutts_> jedbrown: in the bug report give your example and why you're using - and what you'd expect
07:51:35 <jedbrown> dcoutts_: Am I going about this entirely the wrong way?
07:51:58 <dcoutts_> jedbrown: I'm not sure what you're doing
07:52:22 <dcoutts_> jedbrown: your point seems quite reasonable, that we should still use the marshaler even if the result is IO ()
07:52:50 <jedbrown> dcoutts_: I just want to check the error code and throw it away as long as it is okay.
07:53:09 <ricky_clarkson> @babel es en puedo preguntar que este hombre aprende Haskell?
07:53:10 <lambdabot>   I can ask that this man learns Haskell?
07:53:20 <dcoutts_> jedbrown: sounds pretty reasonable. That'll work if you use hE* too though I think, no?
07:53:23 <ricky_clarkson> byorgey: Where did you get that?
07:53:52 <dcoutts_> jedbrown: ah yes, but there's that other out parameter.
07:54:09 <jedbrown> dcoutts_: If I use hE* then the return value from the whole function is IO ((), Interesting, Types)
07:54:15 <byorgey> ricky_clarkson: from the PS at the end of a message in the cafe thread that mnislaih referenced
07:54:26 <dcoutts_> jedbrown: yes ok, include all that info in the bug report
07:54:36 <OctopSnook> yaxu: ubuntu binaries worked first time for me. What  was the msg. PS I don't know if this is the right place for these sort of Qs being a complete newb.
07:54:41 <dcoutts_> jedbrown: I help maintain c2hs, that doesn't mean I understand it :-)
07:55:19 <dcoutts_> jedbrown: but if you provide enough info then the main author might be able to fix it.
07:55:39 <mnislaih> byorgey: Can I wonder why this man is learning Haskell ?
07:55:41 <dcoutts_> jedbrown: in the mean time use the workaround IO ((), Blah)
07:56:16 <byorgey> mnislaih: ok, I see.
07:56:26 * byorgey needs to learn spanish
07:56:32 <jedbrown> dcoutts_: Thanks.  Otherwise, it is really nice.
07:58:27 <mnislaih> byorgey: you can start with his songs: http://www.youtube.com/watch?v=BtlpzoSRJCg
07:58:28 <lambdabot> Title: YouTube - Astrud - Paliza
07:58:49 <byorgey> mnislaih: heh =)
07:59:03 <faxathisia> mf
07:59:13 <faxathisia> it takes 22.13 for my code to solve a simple puzzle
08:00:49 <faxathisia> The list monad is a lot slower then prolog..
08:02:45 <Saizan> faxathisia: compiling with -O2?
08:02:55 <faxathisia> oh just running in ghci
08:03:06 <oerjan> there was some page about how many monads could be implemented faster with continuation passing instead of data types
08:03:31 <oerjan> although i guess lists are getting pretty optimized
08:04:34 <Saizan> well, Cale's sudoku solver is 4x faster with ConT (StateT .. []) rather than the normal version
08:04:56 <faxathisia> I can't use ghc
08:05:04 <faxathisia> seems like there's some problem with my installation
08:05:27 <Saizan> you get an error?
08:05:48 <faxathisia> maybe it's my fault, main = putStrLn "Hello" -- compiles fine
08:06:13 <faxathisia> doing ghc Sweeper.hs -I. gives some Undefined symbols
08:06:28 <oerjan> faxathisia: add --make ?
08:09:46 <faxathisia> cool that works great
08:09:58 <faxathisia> so I go from 22 seconds to 6.33
08:09:58 <dcoutts_> jedbrown: if you don't file the bug we'll forget and it'll never get fixed :-)
08:10:23 <dcoutts_> jedbrown: http://hackage.haskell.org/trac/c2hs
08:10:24 <lambdabot> Title: c2hs - Trac
08:11:20 <jedbrown> dcoutts_: I'm working on it.  The guest account seems unable to create a ticket.
08:11:40 <dcoutts_> jedbrown: really? oh, hmm, lemme fix that..
08:11:52 <hpaste>  faxathisia pasted "Equations" at http://hpaste.org/4113
08:12:17 <faxathisia> so this is pretty slow.. I could convert it to CPS I guess does that sound like a good idea?
08:12:32 <dcoutts_> jedbrown: oh yes, silly me. Should be fixed now.
08:12:43 <jedbrown> dcoutts_: Works.  Thanks.
08:12:54 <dcoutts_> jedbrown: thanks for recording that for us.
08:13:57 <fasta> faxathisia: are you talking about compiled code?
08:14:11 <faxathisia> hm I would rather not
08:14:23 <faxathisia> I mean it's easier to deal with in ghci
08:14:37 <fasta> faxathisia: then you are comparing different things => pointless
08:15:15 <faxathisia> comparing the same thing is even more pointless :p
08:16:09 <quicksilver> faxathisia: before you call it slow, try it compiled
08:16:12 <faxathisia> I did..
08:16:18 <faxathisia> It's 6 seconds compiled 22 seconds in ghci
08:16:25 <quicksilver> did you use -O2?
08:16:38 <doserj> faxathisia: sort . nub seems like an obvious place for optimization
08:17:33 <oerjan> sort . nub = map head . group . sort
08:17:39 <faxathisia> cool 2.26s with -O2
08:17:49 <doserj> (if that list is long)
08:17:59 <fasta> Saizan: What was the difference between the ContT code and the other code? Algorithm was the same?
08:18:12 <faxathisia> oerjan: That made it a bit faster too :d
08:18:20 <fasta> next at 11, faster algorithms are faster.
08:18:23 <faxathisia> Is my approach basically stupid though?
08:18:39 <faxathisia> Well I know it is actually
08:18:40 <quicksilver> faxathisia: did you use -O2 yet?
08:18:47 <faxathisia> quicksilver: Yes 2.26 seconds
08:18:50 <quicksilver> ah
08:18:54 <quicksilver> that's better :)
08:18:58 <quicksilver> sorry, didn't see that
08:19:10 <Saizan> fasta: yes, i just changed the type, plus a lifter from lists to the new monad for some list literals
08:19:37 <fasta> Saizan: do you have an explanation for why it runs faster?
08:19:49 <byorgey> faxathisia: looks like you're basically solving the 0-1 knapsack problem.
08:20:02 <faxathisia> yeah I think so
08:20:05 <faxathisia> if it's NP complete
08:20:19 <faxathisia> since this is solving minesweeper
08:20:21 <fasta> General sudoku is NP-Complete, right?
08:20:36 <fasta> Ok, I basically assumed sudoku.
08:20:42 <doserj> solution !! (fromJust $ elemIndex variable cells) -- this cannot be fast using lists
08:20:46 <fasta> Nice to see a different problem :)
08:20:46 <oerjan> fasta: yep
08:20:50 <byorgey> faxathisia: your current solution is essentially O(2^n) where n is the number of variables.
08:21:14 <faxathisia> I'll replace the cells list with a Map
08:21:23 <byorgey> faxathisia: there is a well-known dynamic programming solution which is O(kn) where k is the maximum possible sum.
08:21:29 <fasta> faxathisia: does this have any application?
08:21:38 <Saizan> fasta: essentially it bypasses the use of lists when >>= is not really using non-determinism
08:21:41 <faxathisia> oh ok cool
08:21:47 <faxathisia> I'll try dynamic programming :D
08:22:07 <byorgey> faxathisia: look at the Wikipedia page for the knapsack problem for a start
08:22:16 <faxathisia> fasta: not really.. I just want to solve minesweeper quickly so I can run game of life backwards
08:22:35 <fasta> faxathisia: and what is the relation between those two?
08:22:47 <mux> didn't people prove that minesweeper is an NP-complex problem?
08:22:51 <fasta> mux: yes
08:22:56 <mux> that makes it fun :)
08:23:38 <faxathisia> fasta: I can convert a single game of life into a set of minesweeper problems, solving them and checking consistency would give me predecessors for the initial config
08:23:54 <faxathisia> (Maybe there is a faster way but I don't know it)
08:24:29 <fasta> faxathisia: minesweeper problems? That seems very contrived and I doubt your claim.
08:24:47 <fasta> Since AFAIK, the Game of Life can be used for arbitrary computations.
08:25:00 <faxathisia> I'll make an example
08:25:13 <faxathisia> so can infinite minesweeper
08:25:22 <faxathisia> (apparently.. I don't understand any proof)
08:25:46 <oerjan> very esoteric method :)
08:26:45 <fasta> Actually, I don't understand what your input and output is.
08:27:30 <fasta> A single game of life configuration has only one predecessor.
08:27:45 <faxathisia> there could be zero or more predecessors
08:28:20 <fasta> I implicitly assumed that the configuration was generated by the machine.
08:29:48 <oerjan> there are going to be a lot of predecessors in general - there are many things that disappear, for example
08:30:08 <oerjan> exponentially many
08:30:08 <Saizan> i.e. the transition function is not injective?
08:30:23 <oerjan> neither injective nor surjective
08:31:15 <hpaste>  faxathisia annotated "Equations" with "minesweeper" at http://hpaste.org/4113#a1
08:31:16 <oerjan> (those having no predecessor are called garden of eden patterns)
08:31:20 <faxathisia> that's the plan :p
08:31:58 <fasta> Hmm, maybe I should implement a game of life first, before I start theorizing about one :)
08:34:18 <Saizan> oerjan: do they look nice?:)
08:34:33 <oerjan> i don't remember
08:34:58 <faxathisia> mostly look like random noise
08:35:06 <faxathisia> the minimal ones anyway
08:35:38 <scodil> is there a version of Data.Binary that compiles with 6.8.1? Or is there some newer library that does that kind of thing?
08:36:03 <oerjan> found one in MCell, it looks fairly nice
08:36:15 <Saizan> scodil: the latest on hackage compiles fine
08:37:05 <scodil> Saizan: what version is that? 0.2? Because I get "Data.Sequence is a member of containers-0.1.0.0 which is hidden" as an error
08:37:23 <Saizan> 0.4 iirc
08:37:28 <Saizan> ?hackage binary
08:37:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
08:37:29 <scodil> oh
08:37:47 <scodil> the version linkedto from dons page is not the latest.
08:37:55 <vincenz> @type min
08:37:56 <lambdabot> forall a. (Ord a) => a -> a -> a
08:41:03 <byteshack> I'm triying to get my feet wet with fp, and with Haskell in particular. While telling someone about it, I was asked if fp and REST were at odds with each other. Thoughts?
08:41:21 <oerjan> faxathisia: i have a sort of Rube-Goldberg feeling about your minesweeper route :)
08:41:28 <faxathisia> hehe
08:42:12 <pejo> byteshack, 'REST'?
08:42:25 <byteshack> as in RESTful web services
08:42:30 <yaxu> byteshack: i don't see why they would be
08:42:44 <byorgey> byteshack: they are pretty much completely orthogonal.
08:42:57 <Syzygy-> Yo yaxu
08:42:59 <byteshack> Seemed that REST is very, ah, noun oriented, and that's what is confusing me a bit
08:43:19 <byorgey> you can write a RESTful web service in any language, including a functional one.
08:43:24 <exDM69> byteshack: they are different. although fp and other languages can do pretty much anything, there are fields where the other is "easier" than the other
08:43:29 <yaxu> hey Syzygy-
08:44:00 <byteshack> and you can write OO in anything... but, does fp lend itself "nicely" to something like REST? I guess that is a better question
08:44:11 <yaxu> i'd have thought ideas like idempotence would sit with fp more easily
08:44:17 <byteshack> some fuzzy def of nicely
08:44:19 <Syzygy-> yaxu: Wanna see something scary?
08:44:26 <quicksilver> byteshack: I'd think fits very well indeed
08:44:27 <yaxu> Syzygy-: yes, very much
08:44:34 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/thesis.pdf
08:44:37 <Syzygy-> My current thesis draft
08:44:42 <quicksilver> byteshack: a GET action would have type State -> String
08:44:49 <quicksilver> byteshack: indicating that it can't change the state only query it
08:44:53 <yaxu> Syzygy-: aha, congrats
08:44:58 <conal> maybe the question is more about REST fits with functional *programming* rather than with, e.g., imperative programming in a functional language.
08:45:00 <quicksilver> byteshack: so you could actually have your types *enforce* the RESTful ness
08:45:13 <Syzygy-> Still working like hell on it - I hope to have it in a non-embarrassing form by ... say ... February or so.
08:45:25 <Syzygy-> But it's homing in on the point where several chapters only have editing left to do.
08:45:28 <quicksilver> (also indicating that a GET request can't do any IO: GET must not have side-effects)
08:45:33 <conal> concretely, can IO be almost entirely invisible?
08:45:40 <Syzygy-> ObHaskell - appendix A is almost exclusively haskell code. :)
08:45:48 <byteshack> interesting
08:45:55 <yaxu> it looks over my head
08:46:00 <Syzygy-> yaxu: It is.
08:46:09 <Syzygy-> But it has pretty pictures! And lots of formulas!
08:46:33 <Syzygy-> yaxu: Parts of it are over the head of my advisor... ;)
08:46:35 <yaxu> that's what i was about to say :)
08:46:50 <byteshack> conal: yes, your point about REST and fp programming is probably what I'm trying to ask
08:47:12 <byteshack> GET would be nice and easy
08:47:55 <conal> i would think that noun-oriented would naturally fit with functional programming and verb-oriented with imperative programming.
08:48:11 <conal> unless noun-oriented and verb-oriented don't mean what i assume
08:48:42 <shapr> I dunno, arrows look like verbs to me.
08:48:45 * osfameron read that as "fictional programming".  Pesky lens fell out of glasses :-(
08:49:00 <conal> shapr: which arrows?
08:49:08 <conal> the interface itself, or some arrows in particular
08:49:09 <conal> ?
08:49:19 <shapr> On the other hand, functions as first class values could seem like both nouns and verbs.
08:49:36 <conal> i don't think functions are verbs.  maybe actions.
08:49:45 <conal> the sin function doesn't do anything.  it just is.
08:49:49 <shapr> conal: Arrows being first transformations, I think of a representation of an action, sort of like 'going for a run' versus 'running'
08:49:56 <oerjan> the original sin
08:49:57 <Saizan> well in REST you've names that refer to different values over time
08:50:19 <conal> oerjan: okay, maybe sin is a verb.  how about cos?  :)
08:50:40 <conal> i guess tan is a verb also.  but cot is definitely a noun!
08:50:41 <oerjan> cos that's a different story
08:50:51 <shapr> hah
08:51:14 <shapr> I thought of arrows like directobject <- verb -< subject
08:51:35 <oerjan> never had much of a tan myself
08:51:38 <byorgey> just a sec, what about csc?
08:51:50 <Saizan> conal: what do you use for IO?
08:51:52 <conal> shapr: sure some arrows & monads represent actions/verbs.  but i'd say that's not functional programming.  it's imperative programming in a functional language.
08:51:57 <Syzygy-> byorgey: Pah!
08:52:08 <chessguy> heya osfameron
08:52:14 <osfameron> hi chessguy
08:52:14 <conal> Saizan: how specifically do you mean "IO
08:52:16 <conal> "?
08:52:17 <byorgey> Syzygy-: sorry. ;-)
08:52:42 <byorgey> Syzygy-: changing the subject, you have nifty diagrams in your thesis =)
08:52:47 <chessguy> osfameron, i'm enjoying your "Monad Wars" series. any chance you can put the current codebase somewhere?
08:52:51 <byorgey> too bad I don't know what any of it means (...yet)
08:53:03 <conal> roconnor: howdy
08:53:08 <osfameron> chessguy: yeah, that's a good idea...
08:53:11 <Saizan> conal: fetching a fixed number of bytes from an Handle for example
08:53:28 <chessguy> i suspect there's a much cleaner way to do your parsing, but it's hard to play with it when there's bits of code all over
08:53:59 <Syzygy-> byorgey: One thing I'd like to play with in the future is to fuse operad theory with functional programming...
08:54:27 <osfameron> chessguy: indeed.  I'll clean up the code and post it my svn server soon
08:54:35 <chessguy> cool beans. thanks!
08:54:41 <roconnor> conal: hey
08:54:46 <roconnor> conal: I watched your google talk
08:54:47 <osfameron> (that said, I promised myself an evening away from the computer tonight... let's see if I manage...)
08:55:01 <byorgey> Syzygy-: that sounds neat.  what's operad theory?  (can you explain it in a couple sentences, given that I have a solid undergrad math background?)
08:55:06 <Syzygy-> byorgey: Operads, the way they were introduced to me, codify operation composition - which should make them good tools for this corner of theoretical CS. However, I'm a bit at a loss for what Koszularity or free resolutions of haskell prorgams should mean.
08:55:20 <conal> Saizan: I use imperative programming in Haskell.  My goal, however, is to figure out how to get this kind of thing out of the programming model into the underlying machinery.  Just like the very stateful implementation of pure lazy evaluation is hidden.
08:55:30 <byorgey> Syzygy-: ok, interesting.
08:55:37 <shapr> conal: Maybe fp is about being able to treat verbs as nouns?
08:55:59 <byorgey> Syzygy-: where would I go if I wanted to learn about operad theory?
08:55:59 <conal> shapr: i'd say fp is about being able to treat everying (including verbs) as nouns.
08:56:04 <Syzygy-> byorgey: An operad is a collection {O_i} of "thingies" - sets with structure - such that you can "compose" two thingies. An object in O_i should be thought of as a thingie with i inputs and 1 output, and the composition operations defined need to be associative wrt composition.
08:56:08 <shapr> I like that.
08:56:19 <oerjan> well with all the data types going around, maybe fp is about being grammar oriented? :)
08:56:54 <Syzygy-> byorgey: Depends a bit on what side taste you want to it. There's a book by Markl, Shnider and Stasheff that does a reasonable job discussing them, and a bunch of papers by Markl and a few others that do decent stuff too.
08:57:03 <conal> shapr: if your favorite domain is imperative computation, then sure you'd like the IO type.  but if it's something else, then the IO type is a distraction.
08:57:17 <Syzygy-> Or you could go read the (e-)book by Tom Leinster http://www.maths.gla.ac.uk/~tl/book.html
08:57:19 <conal> and IO hurts composability where used.
08:57:20 <lambdabot> Title: Higher Operads, Higher Categories
08:57:27 <byorgey> Syzygy-: ok, thanks.  so how is an operad different than a monoid?  it has more structure?
08:57:52 <Syzygy-> An operad is a monoid in a particular category. Or a monad in a particular setting. And a monad is a kind of operad. And ... well ...
08:57:56 <Syzygy-> Things get tangled just about there.
08:58:23 <Syzygy-> A monoid only lets you compose in straight lines, as it were.
08:58:25 <shapr> But you can read the thesis and find out exactly how tangled they get!
08:58:31 <Syzygy-> An operad lets you compose in all sorts of way.
08:58:39 <byorgey> Syzygy-: ok.
08:58:41 <Syzygy-> shapr: Nope. I only deal in one operad ... or maybe three.
08:58:53 <shapr> Ok, maybe some other papers too...
08:59:05 <Syzygy-> byorgey: "concatenate lists" <<- monoid. "insert this subtree at the 4th leaf" <<- operad
08:59:20 <byorgey> Syzygy-: ok, that makes sense.
08:59:47 <byorgey> Syzygy-: so it looks like I should have a grounding in basic category theory before trying to read those books?
09:00:01 <Syzygy-> byorgey: Probably, yeah...
09:00:20 <Syzygy-> byorgey: On the other hand, you should have a grounding in basic category theory.
09:00:24 <conal> shapr: another angle: imperative programming is about doing, while functional programming is about being.
09:00:37 <Syzygy-> conal: Isn't that rather the prolog way?
09:00:51 <Syzygy-> declarative programming is about being.
09:01:00 <conal> Syzygy-: yes.  including functional programming.
09:01:12 <EvilTerran> i'd say prolog's more about having (properties, relationships, etc)
09:01:20 <shapr> conal: I like that!
09:01:21 <ricky_clarkson> being is doing
09:01:27 <Syzygy-> do-be-do-be-do
09:01:30 <conal> shapr: :)
09:01:33 <byorgey> Syzygy-: hehe, yes, I know. =)  I've picked up some here and there, but haven't yet sat down to learn it systematically.
09:01:55 <byorgey> Syzygy-: it's high on my list of Things To Do Right After I Finish Grad School Applications. =)
09:01:58 <Syzygy-> byorgey: Neither have I, but I chose a branch of mathematics that uses it VERY extensively, so I pick up quite a bit anyway.
09:02:06 <conal> that's why i cringe at the thought of fp newbies learning the IO monad.
09:02:27 <byorgey> Syzygy-: fair enough.
09:02:34 <Syzygy-> But I -really- need to get going now. *poof*
09:02:41 <conal> Syzygy-: later
09:02:45 <EvilTerran> conal, i'd say it's an improvement over learning one of those wishy-washy not-really-pure "functional" languages
09:02:49 <EvilTerran> ;P
09:04:01 <conal> EvilTerran: IO is like a warm bath.  it's so comfortable, why bother getting out.  it lulls us away from really creative thinking.
09:04:35 <conal> "i don't know how to thinking about X functionally.  oh well, toss it into IO."
09:04:53 <vincenz> conal: I presume 'IO' is ac ollection name for stateful stuff?
09:04:59 <vincenz> even if not IO based?
09:05:04 <conal> "oh well -- i'll write that part in IO"
09:05:14 <vincenz> 'oh well -- i'll use a state monad'
09:05:17 <ricky_clarkson> Monads are not like elephants, warm baths, warm fuzzy things.
09:05:18 <conal> vincenz: yes.  it doesn't really mean input/output.
09:05:30 <vincenz> conal: I think the meta-pattern is
09:05:37 <vincenz> 'oh well -- i'll sequentialize it into a monad'
09:05:43 <conal> vincenz: state monad i don't mind so much, as long as there's no underlying IO.
09:06:00 <conal> the problem is that IO has no tractable semantics.  and the beauty of FP is tractable semantics.
09:06:08 <EvilTerran> "monads as bathroom furniture"
09:06:21 <conal> vincenz: that also.  unnecessary sequentiality.
09:06:50 * EvilTerran read that as "squishiality" the first time
09:06:53 <vincenz> conal: the man problem with that is
09:07:14 <conal> (or woman problems -- no sexism here)
09:07:14 <vincenz> conal: we don't have althernate structuring methods, not to mention, even if we did, we don't have the libraries to map them to something that isn't sequential
09:07:17 <EvilTerran> it makes your algorithms mushy ;)
09:07:19 <vincenz> s/man/main
09:07:23 <conal> oh1
09:07:42 <vincenz> take concatMap
09:07:47 <vincenz> concatMap is parallelizable
09:08:17 <vincenz> but it's written linearly, for lack of other posssibilities
09:08:37 <conal> vincenz: i agree that we don't have alternative methods as broadly successful as IO.  i think that's because IO is so comfortable, there's not much incentive to try.
09:08:53 <osfameron> could write a Map/Reduce monad à la google?
09:09:02 <osfameron> * "could one write"
09:09:18 <osfameron> or I suppose "has someone written"...
09:09:18 <vincenz> most likely
09:09:22 <vincenz> but it'd be yuckier than lists
09:09:28 <vincenz> because we don't have access to the pointers under the hood
09:09:35 <conal> vincenz: what do you mean that concatMap is written linearly?  is it the recursion or fold in the definition?
09:09:42 * chessguy comes back to the screen and sees "monads as bathroom furniture"
09:09:50 <chessguy> i think i'd better scroll up
09:09:53 <conal> vincenz: that sequentiality is probably mainly due to the list (stack) type.
09:10:08 <vincenz> conal: but a list needn't be
09:10:17 <chessguy> osfameron, there is a relatively current thread on -cafe about that
09:10:18 <conal> vincenz: agreed
09:10:20 <vincenz> nothing stops the runtim from segmenting portions on it and having futures instead of thunks
09:10:31 <vincenz> but sadly, that's not possible from user-space
09:10:44 <vincenz> basically, we should replace thunks by futures :)
09:11:27 <osfameron> chessguy: ah, thanks I'll have a look
09:12:03 <conal> with lists, at least we have simple semantics.  not the case with IO.  and so, while IO is convenient, we lose reasoning & most composition.
09:12:59 <vincenz> true
09:13:01 <conal> anyway, i guess i'm fishing to see who's interested in helping explore alternatives to IO that are both convenient and semantically simple (and thus composable).
09:13:03 <vincenz> aliasing-hell
09:15:32 <CosmicRay> also what is the current best source for gpe on os2008?  the downloads section on maemo.org has it for os2007, but some of the repos mentioned do support os2008
09:18:21 <chessguy> @undo do { n' <- parseInt n; m' <- parseMerchandise m; Just $ f n' m'}
09:18:21 <lambdabot> parseInt n >>= \ n' -> parseMerchandise m >>= \ m' -> Just $ f n' m'
09:19:00 <chessguy> \n m -> parseInt n >>= \ n' -> parseMerchandise m >>= \ m' -> Just $ f n' m'
09:19:03 <chessguy> @pl \n m -> parseInt n >>= \ n' -> parseMerchandise m >>= \ m' -> Just $ f n' m'
09:19:04 <lambdabot> (. ((. ((Just .) . f)) . (>>=) . parseMerchandise)) . (>>=) . parseInt
09:20:28 <phlpp> hi
09:20:41 <byorgey> hi phlpp
09:20:57 <EvilTerran> ?type (. ((. ((Just .) . f)) . (>>=) . ?parseMerchandise)) . (>>=) . parseInt
09:21:08 <lambdabot> Not in scope: `f'
09:21:08 <lambdabot> Not in scope: `parseInt'
09:21:12 <EvilTerran> ?type (. ((. ((Just .) . ?f)) . (>>=) . ?parseMerchandise)) . (>>=) . ?parseInt
09:21:13 <lambdabot> forall a a1 a2 b a3. (?f::a2 -> a -> b, ?parseMerchandise::a1 -> Maybe a, ?parseInt::a3 -> Maybe a2) => a3 -> a1 -> Maybe b
09:22:11 <chessguy> @type liftM2
09:22:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:23:16 <EvilTerran> ?type (liftM2.liftM2) ((Just .) . ?f) (?parseInt) (?parseMerchandise)
09:23:17 <lambdabot> forall (m :: * -> *) a1 (m1 :: * -> *) b a. (Monad m, Monad m1, ?f::a1 -> a -> b, ?parseInt::m (m1 a1), ?parseMerchandise::m (m1 a)) => m (m1 (Maybe b))
09:23:43 <EvilTerran> eeh
09:23:57 <EvilTerran> one of those monads is reader ;)
09:24:26 * EvilTerran has used (liftM2.liftM2) somewhere before
09:25:03 <EvilTerran> ... that's not even right, anyway. never mind.
09:26:57 <chessguy> cmdMearchandise f (n:m:_) = liftM2 f (parseInt n) (parseMerchandise m)
09:27:00 <chessguy> i think
09:27:24 <chessguy> @pl \n m ->  liftM2 f (parseInt n) (parseMerchandise m)
09:27:24 <lambdabot> (. parseMerchandise) . liftM2 f . parseInt
09:28:09 <chessguy> @type liftM2 ?f (?parseInt ?n) (?parseMerchandise ?m)
09:28:10 <lambdabot> forall a1 a2 r t (m :: * -> *) t1. (?f::a1 -> a2 -> r, ?parseInt::t -> m a1, ?n::t, ?parseMerchandise::t1 -> m a2, ?m::t1, Monad m) => m r
09:28:22 <ddarius> chessguy: cmdMerchandise f xs = do (n:m:_) <- xs; liftM2 f (parseInt n) (parseMerchandise m)
09:28:43 <quicksilver> :t liftM2.liftM2
09:28:43 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
09:28:49 <mauke> bah, who came up with the namespace Text.ParserCombinators
09:28:50 <ddarius> @quote liftM
09:28:50 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
09:28:54 <ddarius> @quote liftM
09:28:54 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
09:28:57 <ddarius> @quote liftM
09:28:57 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
09:29:00 <ddarius> There we go.
09:29:36 <chessguy> ddarius, does that handle the case where xs is < 3 elements?
09:29:45 <ddarius> chessguy: Yes.
09:30:36 <chessguy> osfameron, ^^ this discussion is for you :)
09:30:48 <EvilTerran> mauke, what's the matter with it, too long?
09:31:15 <mauke> yeah
09:31:36 <osfameron> chessguy: ooo!  shiny, thanks.  I'll copy the backlog now, read later ;-)
09:31:38 <mauke> what's wrong with Parsing or Parser?
09:31:44 <chessguy> ddarius, hmm, so how does it know that the monad liftM2 is lifting to is different than the monad being drawn from in the <- xs
09:31:56 * EvilTerran goes hunting for his vicious abuse of fmap
09:31:57 <chessguy> or am i totally confused
09:32:02 <EvilTerran> @quote fmap
09:32:02 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life; is much happier now
09:32:12 <EvilTerran> @quote fmap
09:32:12 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life; is much happier now
09:32:17 <EvilTerran> bah
09:32:22 <EvilTerran> mauke, I agree
09:32:50 * EvilTerran doesn't find what he was looking for, but does find main = putStr s >> print s where s = "main = putStr s >> print s where s = "
09:33:07 <byorgey> chessguy: it would have to be the same monad.
09:33:15 <ricky_clarkson> EvilTerran: A quine?
09:33:17 <ddarius> chessguy: Oh sorry, I had a thinko.  Add a return.
09:33:17 <osfameron> chessguy: I'm heading off - if there's anything you think will be useful, I'll grep backlogs tomorrow if I see a nick highlight :-)
09:33:21 <EvilTerran> ricky_clarkson, indeed
09:33:57 <chessguy> ddarius, err..
09:33:59 <ddarius> chessguy: I'm not sure if I'd consider it nicer than handling the two cases.
09:34:16 <chessguy> yeah, purely for instructional purposes now
09:34:39 <ddarius> cmdMerchandise f xs = do (n:m:_) <- return xs; liftM2 f (parseInt n) (parseMerchandise m)
09:34:58 <chessguy> what the...
09:35:48 <chessguy> @type let cmdMerchandise f xs = do (n:m:_) <- return xs; liftM2 f (parseInt n) (parseMerchandise m) in cmdMerchandise
09:35:48 <lambdabot> Not in scope: `parseInt'
09:35:48 <lambdabot> Not in scope: `parseMerchandise'
09:36:00 <chessguy> @type let cmdMerchandise f xs = do (n:m:_) <- return xs; liftM2 f (?parseInt n) (?parseMerchandise m) in cmdMerchandise
09:36:01 <lambdabot> forall a1 a2 t t1 (t2 :: * -> *). (?parseInt::t1 -> t2 a1, ?parseMerchandise::t1 -> t2 a2, Monad t2) => (a1 -> a2 -> t) -> [t1] -> t2 t
09:36:51 <chessguy> hm, it typechecks
09:37:30 <chessguy> so the return is for the t2 monad?
09:37:35 <byorgey> ddarius, chessguy: why (n:m:_) <- return xs instead of let (n:m:_) = xs?
09:38:00 <ddarius> byorgey: Consider the behavior when xs == [foo]
09:38:05 <chessguy> byorgey, that's what i'm trying to figure out
09:38:12 <byorgey> ddarius: ah
09:38:30 <ddarius> > do (x:_) <- return []; return 3
09:38:35 <ddarius> > do (x:_) <- return []; return 3 :: Maybe Int
09:38:41 <lambdabot>   add an instance declaration for (Show (t t1))
09:38:45 <lambdabot>  Nothing
09:39:07 <byorgey> > do let (x:_) = []; return 3 :: Maybe Int
09:39:07 <lambdabot>  Parse error at "::" (column 29)
09:39:20 <byorgey> > do {let (x:_) = []; return 3} :: Maybe Int
09:39:20 <lambdabot>  Parse error at "}" (column 29)
09:39:29 <ddarius> You need brackets around the binding.
09:39:46 <byorgey> > do {let { (x:_) = [] }; return 3} :: Maybe Int
09:39:47 <lambdabot>  Just 3
09:39:49 <phlpp> :t True
09:39:49 <lambdabot> Bool
09:39:53 <phlpp> buhu!
09:39:58 <phlpp> lambdabot is alive \o/
09:40:20 <byorgey> hmm, not what I was expecting
09:40:23 <chessguy> > do {let { (x:_) = [] }; return x} :: Maybe Int
09:40:23 <lambdabot>   Irrefutable pattern failed for pattern (x : _)
09:40:37 <chessguy> > do {let { (x:_) = [3] }; return x} :: Maybe Int
09:40:38 <lambdabot>  Just 3
09:40:39 <byorgey> hm, why did it use an irrefutable pattern?
09:40:47 <ddarius> let bindings are always lazy (except now with bang patterns)
09:40:53 <faxathisia> @index catMaybes
09:40:53 <lambdabot> Data.Maybe
09:41:00 <byorgey> huh, I didn't realize that
09:41:11 <byorgey> ok, makes sense now.
09:41:41 <quicksilver> one reason why I'm not entirely sure I like bang patterns
09:41:46 <quicksilver> feels like a big change to "let"
09:41:50 <quicksilver> but there you go...
09:41:50 <ddarius> If you want a strict let in Haskell 98 you can use a case.
09:41:54 <quicksilver> langauges need change
09:41:59 <byorgey> on pattern-match failure, foo <- return bar will induce a failure in the monad, whereas let foo = bar will just throw a pattern match exception.
09:42:22 <quicksilver> additionally, let foo = bar won't through that exception until you inspect foo
09:42:27 <quicksilver> if you never do, it won't
09:42:28 <ddarius> @undo do (x:_) <- return []; return 3
09:42:28 <lambdabot> return [] >>= \ a -> case a of { (x : _) -> return 3; _ -> fail ""}
09:42:54 <quicksilver> whereas foo <- *probably* forces immediately
09:43:07 <quicksilver> (technically it depends on the definition of 'fail' and >>= in that monad)
09:43:11 <ddarius> @undo do let { (x:_) = [] }; return 3
09:43:11 <lambdabot> let { (x : _) = []} in return 3
09:43:14 <byorgey> quicksilver: right.
09:43:14 <quicksilver> but, e.g. in Maybe it forces immediately
09:43:42 <chessguy> ok, so...how does this code work? it seems like conflicting monads to me. cmdMerchandise f xs = do (n:m:_) <- return xs; liftM2 f (?parseInt n) (?parseMerchandise m) in cmdMerchandise
09:43:58 <ddarius> chessguy: There is only one monad being used.
09:44:15 <chessguy> ddarius, which monad?
09:44:26 <ddarius> chessguy: Maybe in osfameron's case.
09:44:38 <byorgey> but that code could use any monad.
09:44:56 <ddarius> Depending on the types of parseInt and parseMerchandise, yes.
09:45:16 <chessguy> ddarius, right, they are   String -> Maybe String, or something
09:45:17 <byorgey> ddarius: oh, right.
09:45:47 <chessguy> but shouldn't the (n:m:_) force the list monad to be used?
09:45:59 <ddarius> (The types of parseInt and parseMerchandise could be generalized too)
09:46:13 <ddarius> chessguy: No.  (n:m:_) <- getLine is fine.
09:46:13 <byorgey> chessguy: no.  it just forces xs to be a list.
09:46:34 <chessguy> hrm
09:46:42 <ddarius> chessguy: Without the return it would be using the list monad, with the return it becomes (n:m:_) <- Just xs
09:46:58 <chessguy> right...
09:46:59 <chessguy> hm
09:47:44 <byorgey> ...which has the effect of binding n and m to the first two elements of xs, OR resulting in Nothing if xs doesn't have two elements.
09:47:54 <chessguy> so how does it know that  xs is Nothing if   there are less than 3 element
09:47:55 <chessguy> s
09:48:12 <ddarius> chessguy: Look at the expansion of the syntax
09:48:23 <ddarius> @undo do (n:m:_) <- return xs; return 3
09:48:23 <lambdabot> return xs >>= \ a -> case a of { (n : m : _) -> return 3; _ -> fail ""}
09:48:41 <chessguy> ohh, and fail is Nothing
09:48:41 <byorgey> @src Maybe fail
09:48:41 <lambdabot> fail _      = Nothing
09:48:45 <byorgey> =D
09:48:58 <chessguy> nice
09:49:03 * ddarius must return to work.
09:49:05 <chessguy> good stuff
09:49:33 <chessguy> ddarius, make sure your work monad has a run function so you can leave :)
09:50:57 <chessguy> @tell osfameron long story short, here's an alternative for cmdMerchandise. probably not any better, but it is interesting: cmdMerchandise f xs = do (n:m:_) <- return xs; liftM2 f (parseInt n) (parseMerchandise m
09:50:57 <lambdabot> Consider it noted.
09:51:15 <faxathisia> :D
09:54:06 <mcp_> Hello
09:54:47 <faxathisia> hi
09:55:13 <mcp_> I want to make a function with type:   solveq :: p -> s
09:55:28 <mcp_> and implementation:   solveq _ = []
09:55:29 <faxathisia> I don't think you can  :|
09:55:41 <mauke> [] has the type [s], not s
09:55:45 <faxathisia> p and s are variables.. don't they have to be types?
09:55:51 <mcp_> thats what i dont understand
09:56:00 <glguy> :t const []
09:56:08 <glguy> @bot
09:56:09 <mcp_> i think of type "s" beeing more general than [s].
09:56:11 <lambdabot> :)
09:56:15 <lambdabot> thread killed
09:56:19 <mauke> mcp_: it is
09:56:20 <glguy> @type const []
09:56:21 <lambdabot> forall a b. b -> [a]
09:56:26 <mcp_> so [s] should be valid there
09:56:40 <mauke> mcp_: it is
09:56:55 <mcp_> Inferred type : a -> [b]
09:57:00 <mcp_> is what the compiler tells me
09:57:06 <glguy> that would be correct :)
09:57:25 <twanvl> "solveq :: p -> s" means that the CALLER can choose what s is, so he could choose for instance Int
09:58:03 <mcp_> So, the yielded type must be some internal type, or derived from ones further left?
09:58:10 <mauke> huh?
09:58:13 <mauke> no
09:58:28 <mauke> [] is always a list
09:59:14 <mcp_> i want change the implementation later. So i want the function to return "anything of anytype"
09:59:40 <chessguy> mcp_, but you're returning a list, which you said yourself is  more specific
09:59:42 <mauke> then you can't use []
09:59:56 <mauke> also, a function of type a -> b is useless
10:00:08 <chessguy> @djinn a -> b
10:00:09 <mauke> there are only two values of that type anyway
10:00:10 <lambdabot> -- f cannot be realized.
10:00:36 <chessguy> two values?
10:00:46 <chessguy> presumable one is bottom
10:00:58 <mauke> :t [undefined, const undefined]
10:01:00 <lambdabot> forall a b. [b -> a]
10:01:20 <chessguy> cute
10:08:13 <harryv> hey. i installed a package from hackage (runhaskell Setup.* install etc) but now i see that it was an old package - theres a never version. should i just install onp of that, or remove the old one first? and - how DO i remove the old one?
10:08:23 <hpaste>  Jaak pasted "GADTs + defunctionalization" at http://hpaste.org/4114
10:11:30 <harryv> ?
10:11:52 <dons> yeah, just install over
10:11:55 <dons> ghc can ahndle it
10:14:45 <fxr> harryv: you can unregister the package if you like, there's no remove
10:21:31 <phlpp> :t (<<=)
10:21:33 <lambdabot> Not in scope: `<<='
10:21:37 <phlpp> :t (=<<)
10:21:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:26:07 <OctopSnook> harryv: ghc-pkg unregister <pkg>
10:28:24 <dfranke> sigh.
10:28:27 <dfranke> http://hackage.haskell.org/trac/ghc/ticket/1936
10:28:28 <lambdabot> Title: #1936 (When lazy IO blocks, it blocks the whole runtime) - GHC - Trac
10:28:34 <dfranke> kernel diving time!
10:29:21 <dons> an os bug??
10:29:33 <dons> wow
10:29:39 <dfranke> dons: got some other explanation for that strace?
10:29:59 <dons> it looks a bit weird.
10:30:33 * dons tries on bsdf
10:30:58 <dons> oh btw, your +RTS flag to ghc won't do anything, will it?
10:31:03 <dons> they need to be runtime flags
10:31:36 <dons> $ sleep 5 | ./A
10:31:36 <dons> A: <stdin>: hGetBufNonBlocking: interrupted (Interrupted system call)
10:31:36 <dons> $
10:31:40 <dons> is what i get.
10:32:34 <dfranke> that when you hit ^C, or immediately?
10:32:40 <dons> immediately
10:32:46 <dons> no heartbeat messages
10:32:51 <mauke> I get a heartbeat
10:32:54 <mauke> -threaded or no
10:33:11 <dfranke> wow.  This is crazy.
10:33:13 <mauke> oh, but I'm on 6.6.1
10:33:36 <faxathisia> turns out you can run game of life backwards by solving minesweeper :D
10:34:28 <dons> on 6.6.1 it works
10:34:35 <dons> not in 6.8
10:34:41 <dons> so looks like scheduler issue?
10:34:48 * dfranke boggles
10:34:51 <b_jonas> dfranke: couldn't the problem be that putStrLn is to a block-bufferred file?
10:34:57 <dons> i.e. cat | ./test
10:35:03 <dons> produces a heartbeat
10:35:22 <dfranke> b_jonas: putStrLn is to stdout.
10:35:27 <dfranke> b_jonas: which is line-buffered.
10:35:37 <dons> we can show that the behaviour changed bewtween 6.6 and 6.8
10:35:39 <dons> shoudl be enough
10:35:48 <b_jonas> dfranke: just checking
10:36:26 <b_jonas> (just because it's stdout, it can be block-buffered, it depends on the stat type, not whether it's a standard handle)
10:36:30 <byorgey> faxathisia: that's neat =)
10:37:04 <dfranke> b_jonas: yeah, it should have just been going to the tty when I tested it before.
10:37:10 <dfranke> b_jonas: so line.
10:37:19 <acangiano> dons: real world haskell seems to be down (for a couple of days at least)
10:37:26 <b_jonas> dfranke: yep, it doesn't explain everything
10:37:33 <dons> acangiano: hmm.
10:37:39 <faxathisia> there's predecessors of the glider http://rafb.net/p/n7NVdc43.txt
10:38:02 <faxathisia> as an example
10:39:16 <dons> dfranke: can you update the patch with details about 6.6 v 6.8
10:40:08 <newsham> ?yarr
10:40:08 <lambdabot> Arr! Me ship be the biggest brig in the port!
10:40:13 <dons> nice, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-0.1.0.0
10:40:14 <lambdabot> http://tinyurl.com/2t78tq
10:40:20 <dons> A purely functional interface to basic linear algebra computations and other numerical
10:40:23 <dons> routines, internally implemented using GSL, BLAS and LAPACK
10:40:33 <b_jonas> can you show me the strace output with timestamps (strace -r I think)?
10:40:57 <b_jonas> that is, of the buggy one
10:41:01 <dfranke> dons: If I update it, it'll just say "dons told me he gets proper behavior with 6.6 but not 6.8".  I don't have a 6.6 install handy.
10:41:25 <b_jonas> because this way the strace doesn't seem completely impossible to me
10:41:25 <bos> acangiano: i don't see a problem
10:41:39 <b_jonas> what if those signals were generated while the previous signals were handled
10:41:42 <dons> yes, loads for me now
10:41:49 <dons> was down two days ago.
10:41:53 <b_jonas> (supposeing the handles were running too slow)
10:42:06 <dons> acangiano: you using the right url?
10:43:50 <b_jonas> dons: ah, an interface to lapack?
10:43:53 <b_jonas> that sounds interesting
10:44:04 <b_jonas> gotta bookmark it
10:45:06 <b_jonas> thanks for the link
10:45:46 <acangiano> dons: did it change? :-P http://www.realworldhaskell.org/
10:45:47 <lambdabot> Title: Real World Haskell
10:46:00 <dons> lambdabot things its up ^^
10:46:18 <bos> acangiano: i upgraded my server, so it would have been down for a few hours at the weekend
10:47:23 <acangiano> bos: hmmm, I still can't reach it from my computer
10:47:26 <dfranke> dons: so are you going to post the 6.6 bit, or shall I?
10:47:46 <bos> acangiano: can you traceroute to it?
10:49:10 <pitecus> I have a GHC-compiled program which uses 1.2G on a 32 bit machine and 2.6G on a 64 bit one. Is that normal??
10:49:19 <bos> pitecus: yes
10:49:30 <mrd> total, or at once?
10:49:48 <bos> pitecus: unfortunately, the STG machine is very pointer-heavy, so it gets penalised on 64-bit machines
10:50:10 <bos> this makes x86_64 GHC code often run considerably more slowly than i386 GHC code
10:50:22 <acangiano> bos: I can't. I get unknown host.
10:50:27 <Vulpyne> Are there any openssl bindings for Haskell that deal with actual SSL connections? Haven't turned up anything useful with my searches.
10:50:42 <pitecus> bos, ok i guess this means the program needs a rewrite. Unfortunately i can't afford using more than about 1.5G...
10:51:03 <bos> pitecus: what kind of program? 1.5G is pretty huge.
10:51:09 <pitecus> or is there some way of compiling th program in 32 bit mode?
10:51:13 <bos> acangiano: that's very weird
10:51:39 <acangiano> bos: it is. Every other site is fine.
10:51:47 <mrd> pitecus: a haskell program will allocate and release lots of memory very quickly -- that is very different from acquiring a huge amount of space at once
10:51:56 <pitecus> bos one problem is I use Strings coz ByteStrings don't do Unicode properly
10:52:06 <bos> pitecus: use the utf8-string package for that
10:52:08 <acangiano> bos: I wonder if it's just me or if it affects other people too.
10:52:15 <pitecus> mrd its some global table i need to keep around
10:52:33 <pitecus> utf8-string works with strings AFAIR
10:52:44 <pitecus> thats what Im using for UTF-8
10:52:53 <pitecus> does it support bytestrings now?
10:53:04 <bos> acangiano: can you traceroute to 64.81.58.173 ?
10:53:09 <mrd> hmm. chars are word-sized, right?
10:53:15 <bos> pitecus: oh, iswim.
10:53:33 <bos> pitecus: yes, there's no packed unicode string library available.
10:53:54 <acangiano> bos: I can.
10:54:04 <bos> pitecus: people prefer to argue what the representation should be instead of writing the code :-(
10:54:05 <pitecus> bos, thats the problem, i always end up having to use Strings
10:54:25 <sieni> mrd: bos: what about accents and such?
10:54:40 <bos> acangiano: that's extra-weird
10:54:42 <bos> sieni: what?
10:54:43 <mrd> well Chars being UTF-32 would take care of that
10:55:13 <glguy> mrd, as opposed to what Chars are now?
10:55:14 <hpaste>  acangiano pasted "Traceroute" at http://hpaste.org/4115
10:55:26 <mrd> isn't that what Chars are?
10:55:26 <bos> sieni: there are only two sensible representations for packed unicode strings, UTF-16 and UTF-32
10:55:47 <bos> acangiano: can you look up www.serpentine.com? (same machine, different name)
10:55:59 <bos> acangiano: ah, apparently you can
10:56:20 <acangiano> bos: I can, yes
10:56:32 <pitecus> I seem to have seen some partial implementation of proper Unicode aware bytestrings somewhere but that was experimental code I think
10:56:56 <bos> pitecus: i wrote such a library, but haven't had time to finish it up
10:57:01 <Saizan> ?google Data.CompactString
10:57:02 <lambdabot> http://twan.home.fmf.nl/compact-string/
10:57:02 <lambdabot> Title: Data.CompactString
10:57:04 <pitecus> http://twan.home.fmf.nl/compact-string/
10:57:05 <lambdabot> Title: Data.CompactString
10:57:09 <pitecus> exactly
10:57:16 <faxathisia> @brain
10:57:16 <lambdabot> Pinky, I am in considerable pain.
10:57:17 <pitecus> anyone try it?
10:57:21 <faxathisia> @brain
10:57:21 <lambdabot> But where are we going to find a duck and a hose at this hour?
10:57:26 <pitecus> is it  useable??
10:57:32 <pitecus> Saizan?
10:57:37 <Saizan> however converting from Char to utf8 Word8 is simple
10:57:49 <Saizan> pitecus: not tried
10:58:59 <pitecus> Unicode support always sucks in experimental languages ;-)
10:59:35 <dons> hey, Char is unicode, and utf8string supports it fine.
10:59:38 <glguy> So people are using the utf8-string package for things?
10:59:41 <dons> unicode sucks in all languages
10:59:51 <glguy> dons, not ObjC on Mac :)
10:59:55 <dons> so i hear.
11:00:06 <dons> let's steal that api
11:00:30 <sieni> bos: mrd: part of the code points are combining characters which modify other characters, so you can represent stuff like  with either one or two code points
11:00:39 <bos> sieni: yes, i know
11:00:54 <pitecus> dons, you the problem was memory useage with [Char]
11:01:05 <pitecus> plus GHC on 64 bits
11:01:10 <pitecus> its not doable
11:01:20 <glguy> "GHC on 64 bits"?
11:01:23 <bos> acangiano: afaict, the problem with looking that host up seems to be on your end
11:01:30 <bos> glguy: the STG pointer tax
11:01:31 <acangiano> bos: weird. Now it's working.
11:01:44 <pitecus> glguy, it uses 2x as much memory as in 32 bits
11:01:58 <pitecus> or rather the programs compiled with it
11:16:11 <faxathisia> I guess I could have, data Variable = A | B | C | ...
11:16:22 <faxathisia> but it would make more sense to use newdata Variable = Int ?
11:17:28 <desegnis> faxathisia, how many constructors do you need? More around five, or ten, or better a million?
11:17:47 <faxathisia> Unbounded would be best
11:18:16 <faxathisia> I mean I probably only use 20 or something but I don't have an upper bound
11:18:17 <dons> the good thing about A|B|C is that the constructer will get stored in the low end bit of the pointer to it
11:18:23 <dons> but for Int, it won't
11:18:32 <faxathisia> oh .. what does that mean?
11:18:37 <dons> as long as you're under 4 or8 constructors, that is
11:19:08 <faxathisia> I mean what is good about the lower bits?
11:19:13 <dons> faxathisia: pointer tagging in ghc 6.8
11:19:27 <faxathisia> oh ok I think I see
11:19:31 <dons> means you can inspect which constructor you're looking at simply by masking the pointer to the value
11:19:36 <dons> not actually  jumping into the closure
11:19:42 <desegnis> If you have only around 20 constructors, then a data declaration can make for descriptive names, and strong typing.
11:19:52 <gbacon> I've formed a mental model of >>> as a fancy map.. do I need to disabuse myself of this?
11:20:33 <gbacon> e.g., runX (constL ["a","b"] >>> selem "p" [ mkText ]) produces two p elements
11:22:02 <dolio> >>> is more like a fancy compose (.). But composition is itself a special case of functor mapping...
11:22:25 <dolio> Function composition, that is.
11:22:28 <gbacon> gotcha
11:23:05 <gbacon> but I've run into a case where the typechecker is pushing me to use a list as the RHS's input
11:24:39 <gbacon> even though everywhere else, it looks like >>>'s second argument gets called for each element in the input
11:24:52 <gbacon> as with the runX example above
11:24:58 * gbacon scratches head
11:25:03 <andyjgill> @seen augustss
11:25:03 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
11:25:30 <Cale> gbacon: That's because all the >>>'s which are used in HXT are for list arrows which do that.
11:26:16 <gbacon> so have I made the typechecker think I'm after a different arrow?
11:26:21 <Cale> Err...
11:26:27 <Cale> What's the error message?
11:27:06 <augustss> andyjgill: yes?
11:27:14 <gbacon> when the program typechecks, I have to use ArrowXml a => a [TrDataSet] XmlTree
11:27:30 <gbacon> but I expect the type to be s/
11:27:31 <gbacon> [
11:27:42 <gbacon> but I expect the type to be s/\[\]//g
11:27:57 <goalieca> sometimes my head turns off and my brain farts
11:27:58 <gbacon> i.e., TrDataSet, not [TrDataSet]
11:28:51 <Cale> gbacon: there are combinators for switching between those, iirc...
11:29:34 <Cale> hmm...
11:30:28 <Cale> ah, you can turn an a b c into an a b [c] using listA... there ought to be some kind of dual to that.
11:31:09 <gbacon> cale: but why am I running into this in the first place? everywhere else, the types are what I expect
11:31:43 <Cale> I'd need to see your program to be able to tell.
11:32:14 <Saizan> am i wrong or someone translated the type-level instant insanity solver to indexed types?
11:32:16 <gbacon> cale: the call is pure transSets >>> eachDataStructure, and transSets returns [TrDataSet]
11:32:32 <Cale> okay
11:32:51 <Cale> that is, transSets :: (ArrowXML a) => a b [TrDataSet] ?
11:32:59 <gbacon> no, it's pure
11:33:05 <Cale> oh
11:33:24 <Cale> then you can't use >>> unless eachDataStructure is also a pure function.
11:33:37 <esap> Is there some theory on how to compute fixpoints of functions represented as parse trees?
11:33:47 <Cale> (in which case >>> is just function composition)
11:34:03 <gbacon> it typechecks as ArrowXml a => a [TrDataSet] XmlTree
11:34:15 <Cale> okay
11:34:31 <gbacon> but the list input surprises me
11:36:45 <Cale> Well, you can use constL to turn that list input into an arrow which gives each result in turn.
11:38:17 <gbacon> yeah, I've tried that, but it doesn't typecheck: Couldn't match expected type `[]'
11:39:52 <gbacon> oh, you're saying in eachDataStructure?
11:40:34 <gbacon> I meant I've tried constL (pure transSets) >>> eachDataStructure
11:40:51 <gbacon> my arrow-intuition stinks :-(
11:46:09 <gbacon> I see that I can unwrap the list inside eachDataStructure, but it really surprised me that doing so was necessary when it looks more-or-less like mapM everywhere else
11:47:39 <Cale> Well, the most intuition is probably gained by looking at the plain list arrow directly
11:48:04 <faxathisia> is there a more specific name for the sort of set of equations,
11:48:12 <Cale> Internally, LA b c is just b -> [c]
11:48:35 <Cale> When you compose: (>>>) :: LA b c -> LA c d -> LA b d
11:48:58 <Cale> That's really (b -> [c]) -> (c -> [d]) -> (b -> [d])
11:49:06 * gbacon nods
11:49:13 <faxathisia> just like Ax = b linear equations except, there are no constants (so everything in A is 1 or 0), e.g. 3 = a + b + c, 2 = a + c and also a, b, c are all in [0..n] for some integer n
11:50:18 <Cale> faxathisia: Some kind of linear diophantine equations?
11:50:29 <faxathisia> yea
11:51:14 <faxathisia> hmm
11:52:05 <faxathisia> What would you call a solver for them?
11:52:33 <faxathisia> solve [Int := [Variable]]
11:53:43 <Cale> gbacon: applyA (pure constL)  -- this is what you're looking for, I think
11:54:00 <Cale> gbacon: Its type is (ArrowList a) => a [c] c
11:55:59 <Cale> oh, you could also use  (>>. concat)
11:56:41 <Cale> Which has the type: (ArrowList a) => a b [c] -> a b c
11:57:06 <Cale> Should be the same thing as composing on the right with  applyA (pure constL
11:57:10 <Cale> )
11:57:23 <gbacon> inside eachDataStructure?
11:57:54 <Cale> gbacon: between transSets and eachDataStructure, or in the second case, applied to transSets
11:58:29 <gbacon> as in transSets >>. eachDataStructure?
11:58:35 <Cale> (pure transSets >>. concat) >>> eachDataStructure
11:58:50 <Cale> actually, duh
11:58:58 <Cale> arrL transSets >>> eachDataStructure
11:59:31 <gbacon> typechecks!
12:00:00 <Cale> I'd somehow ignored the fact that transSets is just a pure function
12:00:16 <Cale> arrL :: (b -> [c]) -> a b c
12:00:22 <gbacon> but what's different about this case that I have to use arrL?
12:00:29 <Cale> Well,
12:00:34 <gbacon> or.. what sorts of differences will force that route?
12:00:36 <Cale> pure :: (b -> c) -> a b c
12:00:39 <Cale> right?
12:00:55 <gbacon> assuming arrow a, yes
12:00:57 <Cale> So if your function is something like (Foo -> [Bar])
12:00:58 <Cale> then
12:01:11 <Cale> pure f :: a Foo [Bar]
12:01:36 <Cale> pure f :: (Arrow a) => a Foo [Bar]
12:01:46 * gbacon nods
12:01:51 <Cale> (Haven't even made use of the fact that it's a list arrow)
12:02:31 <Cale> arrL takes the list returned by the function and fuses it into the arrow structure, creating an arrow which nondeterministically returns each of the elements of the list.
12:02:52 <Cale> So
12:03:02 <Cale> arrL f :: (ArrowList a) => a Foo Bar
12:03:47 <Cale> You can treat it as just giving you a value of type Bar then, and the arrow machinery handles the different cases automatically.
12:03:59 <gbacon> is that the issue then, that the pure function is a -> [b] rather than simple [b]?
12:04:13 <Cale> rather than a -> b ?
12:04:46 <Cale> It's all about whether you want the arrow machinery to take over the processing of those lists, or if you want the next arrow in the chain to get a list.
12:05:13 <gbacon> for example, I'm feeding another arrow with sensors >>= dataUnits >>> eachEncoding
12:05:20 <Cale> To go the other way, you can use listA
12:05:31 <Cale> listA :: (ArrowList a) => a b c -> a b [c]
12:06:02 <gbacon> sensors >>= dataUnits :: [(String, String)] but eachEncoding :: a (String, String) XmlTree
12:06:32 <Cale> yeah, so that's not well-typed, since [(String, String)] isn't an arrow type
12:06:52 <gbacon> oh, sorry, dropped constL!
12:07:03 <gbacon> constL (sensors >>= dataUnits)
12:07:03 <Cale> ah, okay
12:07:32 <faxathisia> Has anyone written a solver for Systems of Linear Diophantine Equations?
12:07:40 <faxathisia> (which is more efficient than mine)
12:07:50 <Cale> faxathisia: I don't know, would be interesting to find out.
12:08:05 <faxathisia> I wrote a basic one but I am right now going to find a better algorithm
12:08:08 <faxathisia> (Hopefully..)
12:08:20 <gbacon> that's my confusion: I don't see why the arrow machinery takes over in the latter example but that I had to use arrL in the former
12:14:15 * faxathisia *grr*
12:14:32 <faxathisia> there is the exactly algorithm I want in some pdf but it's for registered users only :p
12:14:39 <goalieca> @iterate
12:14:39 <lambdabot> Unknown command, try @list
12:14:43 <goalieca> @src iterate
12:14:43 <lambdabot> iterate f x =  x : iterate f (f x)
12:15:02 <dons> sjanssen: how far did you get with chameneos-redux?
12:15:04 <gbacon> cale: thank you very much for your help.. the code is producing the desired output, but I'm after deeper understanding
12:15:12 <sjanssen> dons: done, I think
12:15:20 <dons> want to toss the code up somewhere?
12:15:25 <Cale> gbacon: in which example?
12:15:53 <gbacon> why I have to use arrL in one case but not another where the computations appear to have the same structure
12:16:14 <Cale> gbacon: Are you talking about the one where you had to use constL instead?
12:16:21 <gbacon> yes
12:16:28 <vincenz> @hoogle [a] -> Bool
12:16:28 <Cale> constL is similar to arrL
12:16:29 <lambdabot> Prelude.null :: [a] -> Bool
12:16:29 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
12:16:29 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:16:35 <roconnor> @type parititon
12:16:36 <lambdabot> Not in scope: `parititon'
12:16:40 <roconnor> @type partiton
12:16:41 <lambdabot> Not in scope: `partiton'
12:16:44 <roconnor> @type partition
12:16:44 <Cale> It's the same as arrL . const
12:16:44 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:17:22 <Cale> arrL . const :: (ArrowList a) => [c] -> a b c
12:17:35 <Cale> constL :: (ArrowList a) => [c] -> a b c
12:17:54 <Cale> The similarity of the types is not a coincidence, they really do the same thing :)
12:18:06 <gbacon> ding!
12:18:35 <Saizan> (one odd thing is that all those combinators are class methods, when most can be easily defined in terms of others, actually the whole ArrowXml class has default implementations)
12:18:47 <gbacon> well.. then why weren't the interchangeable?
12:18:53 <gbacon> s/the/they/
12:18:54 <hpaste>  sjanssen annotated "chameneos-redux. 5x faster than Mozart/Oz" with "final revision" at http://hpaste.org/4108#a4
12:19:13 <dons> oh awesome, you've got mozart installed?
12:19:16 <Cale> gbacon: arrL and constL aren't the same, but arrL . const and constL are...
12:19:27 <dons> the shootout has been great for improving my other language reading ability
12:19:35 * gbacon nods
12:19:56 <sjanssen> dons: yeah, I grabbed it since it was in Gentoo
12:20:20 <gbacon> so in what sorts of cases do I need arrL and when constL?
12:20:28 <Cale> arrL is more general
12:20:45 <Cale> you use it when you have a function b -> [c], and you want to turn that into an arrow.
12:20:53 <dons> sjanssen: cute, very similar to mine, actually.
12:21:02 <gbacon> but when I have a list, I can get away with constL?
12:21:09 <Cale> constL is where you just want an arrow which ignores its input and produces the same options every time
12:21:14 <Cale> right
12:21:19 * gbacon nods nods nods
12:21:28 <dons> sjanssen: might be able to tweak some of the data structures for small constant improvements to allocation or time
12:22:06 <vincenz> foo x y | x == y = ...
12:22:10 <vincenz>       | otherwise = ...
12:22:12 <olsner> @src readIO
12:22:12 <lambdabot> Source not found. I am sorry.
12:22:13 <vincenz> if I want a where on the first clause
12:22:17 <olsner> @ty readIO
12:22:18 <lambdabot> forall a. (Read a) => String -> IO a
12:22:20 <vincenz> do I put it prior to the otherwise lline?
12:22:37 <gbacon> cale: great; thanks much for your help.. I've really enjoyed reading your contributions to reddit
12:22:45 <gbacon> dons: you too!
12:22:58 <olsner> vincenz: you can put it at the end and have it shared between clauses
12:23:08 <vincenz> olsner: thanks
12:23:15 <olsner> (dunno if where clauses are acceptible between clauses)
12:23:36 <dons> gbacon: sure!
12:23:36 <gbacon> cale: I guess I was trying to throw away the thunk too quickly in my mental model
12:23:48 <gbacon> dons: I can't wait to buy your book
12:23:57 <sjanssen> dons: http://hpaste.org/4108#a1 picked up only tiny improvements
12:23:58 <dons> me neither!
12:24:28 <kaol> don't they even send copies to the authors?
12:24:48 <dons> i'm sure i'll get a copy or two :)
12:29:55 <Syzygy->   Book or paper?
12:29:57 <Syzygy-> Ah. Book.
12:30:51 <gbacon> thanks all
12:34:27 <vincenz> @type foldr
12:34:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:34:44 <BMeph> Is there an efficient rotate on lists, or do you have to roll your own structure?
12:35:09 <dmwit> rotate :: [[a]] -> [[a]] or rotate :: [a] -> [a]?
12:35:20 <dmwit> And no, it's not really efficient. =)
12:35:23 <BMeph> The second.
12:35:27 <dmwit> O(n) or so.
12:35:49 <dmwit> Maybe use a DList if you're really excited about rotation?
12:35:51 <BMeph> As in rotate (x:xs) == xs++[x].
12:36:42 <olsner> > liftM2 (zip (++)) inits tails [1,2,3]
12:36:43 <lambdabot>  Couldn't match expected type `[a]'
12:36:59 <olsner> > liftM2 (zipWith (++)) inits tails [1,2,3]
12:37:05 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
12:37:14 <dolio> Heh.
12:37:15 <olsner> > liftM2 (zipWith (++)) tails inits [1,2,3]
12:37:15 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3]]
12:38:01 <olsner> there! although it duplicates one rotation ;-)
12:39:08 <xerox> tail it
12:39:56 <olsner> well, I guess that's left as an exercise to the reader
12:40:55 <dmwit> I don't think you would call that efficient, though.  That's, what, O(n^2)?
12:41:10 <dolio> Yeah. inits is n^2.
12:41:17 <faxathisia> > map (take 3) $ iterate (drop 1) $ cycle [1,2,3]
12:41:17 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,...
12:41:21 <faxathisia> > take 3 $ map (take 3) $ iterate (drop 1) $ cycle [1,2,3]
12:41:22 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
12:42:51 <dolio> Producing them all is going to be O(n^2) anyhow.
12:42:58 <faxathisia> exactly
12:43:30 <dolio> > let rotate n l = t ++ h where (h,t) = splitAt n l in rotate 0 [1,2,3]
12:43:31 <dmwit> Right, but with the right structure, rotating once can be O(1).
12:43:31 <lambdabot>  [1,2,3]
12:43:37 <dolio> > let rotate n l = t ++ h where (h,t) = splitAt n l in rotate 1 [1,2,3]
12:43:37 <lambdabot>  [2,3,1]
12:43:42 <dolio> > let rotate n l = t ++ h where (h,t) = splitAt n l in rotate 2 [1,2,3]
12:43:42 <lambdabot>  [3,1,2]
12:43:45 <dolio> > let rotate n l = t ++ h where (h,t) = splitAt n l in rotate 3 [1,2,3]
12:43:45 <lambdabot>  [1,2,3]
12:43:49 <dmwit> Or... maybe not in Haskell?
12:45:53 <BMeph> Blasphemer! ;p
12:46:46 <jfoutz> would it be a bad idea to have a function with thousands of pattern matches?
12:46:49 <dolio> You could store an index for the new head and rebuild on reading.
12:46:58 <shapr> @quote mzero
12:46:58 <lambdabot> No quotes match. The more you drive -- the dumber you get.
12:46:59 <shapr> aww
12:47:02 <Saizan> dmwit: Data.Sequence should almost be it
12:47:10 <dmwit> I'm pretty sure DList has O(1) (amortized) head and snoc, though, so that would do it.
12:47:10 <dolio> So you could rotate by just incrementing modulo the size.
12:48:00 <shapr> @quote mplus
12:48:00 <lambdabot> No quotes match. stty: unknown mode: doofus
12:48:02 <shapr> foo
12:48:08 <dmwit> jfoutz: Err... well, it's a bad idea from the point of view of having to write thousands of pattern matches...
12:48:48 <BMeph> So, easy answer: use a deque, and it's all good? ;)
12:49:59 <jfoutz> heh, ok. so... i have some code that scores poker hands. it runs in about 3 sec or so. i was thinking i could write a script to enumerate the cases i care about, and just make something like (score (1,2,3,4,5) = 10 )
12:50:26 <shapr> Is there something like PreludeExts in hackage?
12:50:29 <jfoutz> i was sorta hoping ghc's pattern match would be more clever than my list manipulations.
12:50:38 <shapr> Someplace where people can throw in useful code and have it generally available?
12:50:39 <mrd> if you bucket sort the poker hands it actually becomes pretty easy to test the hands
12:50:50 <dmwit> jfoutz: Use pattern guards.
12:51:23 <mrd> which can bed done using groupBy
12:51:27 <mrd> be done*
12:51:35 <dmwit> score hand | isAStraight hand = 10 | isAnotherThing = 20 | ...
12:53:05 <mrd> i actually wrote some haskell to do it
12:53:11 <jfoutz> mrd, yeah.. right now i'm doing sort then groupby. 3 seconds for 2.6 million hands
12:53:46 <jfoutz> which is great
12:54:13 <jfoutz> the only obvious speed improvement i could think of was breaking out explicit cases.
12:54:32 <Heffalump> is there a standard location for the chasing bottoms code?
12:54:49 <hpaste>  shapr pasted "old PreludeExts" at http://hpaste.org/4116
12:54:59 <shapr> Aw, it got cut off.
12:55:51 <dmwit> 5K limit
12:57:20 <Saizan> Heffalump: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ChasingBottoms-1.2.2 does this counts?
12:57:21 <lambdabot> http://tinyurl.com/3dwaqh
13:01:20 <Heffalump> oh, I thought I searched that for it. Ta.
13:01:50 <Heffalump> Ah yes, I made the mistake of trying to search hackage by google. Rash assumption, I guess :-)
13:03:09 <hpaste>  camden pasted "(no title)" at http://hpaste.org/4117
13:06:56 <shapr> swiert: Hey, are you done with the tmrwiki data?
13:07:22 <swiert> shapr: no - can you keep it up?
13:07:35 <swiert> I'm in two minds what to do with the content.
13:07:58 <shapr> I could send you a tarball of the pages.
13:08:13 <swiert> I'd like to maybe move it to the new wiki, but I'm not sure how to automate this.
13:08:22 <swiert> shapr: That'd be great!
13:09:11 <shapr> As soon as I finish cleaning off the spam...
13:12:32 <swiert> shapr: Could you leave the tmrwiki online for the moment. I'm not sure when I'll get around to moving the content over.
13:12:37 <shapr> yup
13:13:15 <swiert> thanks. how's code, btw?
13:13:36 <shapr> Slow but steady.
13:13:44 <swiert> still hacking on HApps?
13:13:47 <shapr> All tmrwiki pages are now immutable.
13:14:15 <shapr> Yup, HAppS is really nifty, and has lots of buzzwords. It's a distributed, transaction-based failsafe web application server!
13:14:25 <shapr> And the magic under the hood is amazing.
13:14:31 <swiert> "Fully buzz-word compliant"
13:16:32 <shapr> swiert: Once the upload is finished it'll be at http://www.scannedinavian.com/~shae/tmrwikisource.tar.gz
13:16:51 <swiert> shapr: Thanks again for your help.
13:16:54 <newsham> ?keal
13:16:54 <lambdabot> can GMP support KealDigit? I invent KealDigit
13:17:03 <shapr> sure
13:17:10 <shapr> @protontorpedo
13:17:10 <lambdabot> what makes haskell more fun than say clisp?
13:17:37 <ehird`> wow
13:17:41 <ehird`> has lambdabot gon crazy?
13:17:50 <newsham> ?b52s
13:17:50 <lambdabot> Girl from Ipanema, she goes to Greenland
13:17:51 <ehird`> *gone
13:18:10 <dmwit> ?vixen . b52s
13:18:14 <lambdabot> Guys who can speak latin really turn me on.
13:18:39 <dmwit> ehird`: I think the obvious answer here is "yes."
13:19:35 <dolio> @girl19
13:19:35 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
13:19:37 <dmwit> ?yhjulwwiefzojcbxybbruweejw
13:19:37 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
13:19:50 <mrd> ?palomer
13:19:50 <lambdabot> Pfft
13:19:51 <dmwit> ?brain
13:19:51 <lambdabot> I think so, Commander Brain from Outer Space! But do we have time to grease the rockets?
13:20:02 <mrd> ?palomer
13:20:03 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
13:20:10 <dmwit> ?yow!
13:20:10 <lambdabot> Let's send the Russians defective lifestyle accessories!
13:20:40 <byorgey> @arr !
13:20:40 <lambdabot> Aye Aye Cap'n
13:20:59 <faxathisia> @src nub
13:20:59 <lambdabot> nub = nubBy (==)
13:21:00 <dmwit> ?yarr!
13:21:00 <lambdabot> Arrr!
13:21:03 <faxathisia> @src nubBy
13:21:03 <lambdabot> nubBy eq []             =  []
13:21:03 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:21:13 <ehird`> dmwit: I am confused!
13:21:13 <dmwit> faxathisia: c-c-c-COMBO BREAKER
13:21:31 <faxathisia> oops sorry
13:21:50 <dmwit> heh
13:22:32 <olsner> ?help palomer
13:22:32 <lambdabot> palomer. Sound a bit like palomer on a good day.
13:22:40 <dmwit> I think we're pretty much out of (unique) combos anyway.
13:22:58 <olsner> so lambdabot's got a few new dramatis personae nowadays, eh?
13:23:03 <dmwit> ?freshname
13:23:03 <lambdabot> Haa
13:23:11 <dmead> ?losers
13:23:11 <lambdabot> Maximum users seen in #haskell: 408, currently: 400 (98.0%), active: 18 (4.5%)
13:23:28 <dmwit> Whoa...
13:23:32 <dmwit> ?figlet hey!
13:23:32 <lambdabot> Couldn't run the figlet command.
13:23:38 <dmwit> shucks
13:23:43 <dolio> Probably for the best.
13:23:49 <mrd> spamalicious
13:23:56 <mrd> ?quote
13:23:56 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
13:25:42 <dolio> @quote JonHarrop
13:25:42 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
13:27:04 <goalieca> how fast are tuples to throw around. i think i might be abusing them and that is causing performance problems
13:27:20 <dmwit> ?. pretty undo do { x <- jobs; y <- people; return (x+1, y) }
13:27:20 <lambdabot>  jobs >>= \ x -> people >>= \ y -> return (x + 1, y)
13:28:32 <hpaste>  faxathisia pasted "Solve linear diophantine equations" at http://hpaste.org/4118
13:28:49 <Lycurgus> "throwing around" anything in an environment like Haskell is unwise
13:28:57 <faxathisia> there is a simple solver then
13:29:05 <faxathisia> e.g. solve [[(2,0), (3,1), (1,2)] := 43] (0,9), produces [[4,9,8],[5,8,9],[5,9,6],[6,8,7],...
13:29:18 <mrd> people who live in garbage collected houses can throw around tuples
13:29:31 <mrd> faxathisia: how many variables?
13:29:37 <faxathisia> as many as you like
13:29:43 <mrd> undecidable
13:29:46 <Lycurgus> yeah, if gc was all there was to it
13:30:37 <faxathisia> mrd: The variables are bounded
13:31:07 <faxathisia> better example: solve [[(2,0), (3,1), (1,2)] := 43, [(1,0), (1,1)] := 15] (0,9) --> [[6,9,4],[7,8,5],[8,7,6],[9,6,7]]
13:31:37 <faxathisia> that's solving all integer x,y,z in the range [0..9] such that 2x + 3y + z=43, x+y=15
13:32:19 <mrd> ok
13:34:18 <faxathisia> but is there a better algorithm to use than generate & test?
13:38:25 <Cale> faxathisia: Well, you could first solve the linear system of equations over the rationals, and then search for integer solutions to it.
13:39:13 <olsner> isn't that some kind of diophantine equation? I think there are clever ways to solve those
13:39:42 <faxathisia> to solve over the rationals, Just use e.g. Gaussian elimination?
13:39:47 <Cale> faxathisia: yeah
13:39:51 <faxathisia> cool ok I can do that
13:40:15 <faxathisia> olsner: Seems like it but I can't find any decent descriptions
13:40:20 <Cale> at least, it will reduce the number of parameters you have to look through
13:40:27 <faxathisia> yeah that would be great
13:40:36 <faxathisia> at this point I have the most naive solution
13:41:10 <faxathisia> (one more question should I use STArray for Gaussian elimination, as opposed to immutable arrays?)
13:41:16 <faxathisia> or something like that
13:41:26 <olsner> otoh, the only problem with generate-and-test is performance, so if your problems turn out to be small, why bother with a complicated solution :P
13:41:42 <Cale> faxathisia: Lists of lists work well.
13:41:54 <Cale> faxathisia: since Gaussian elimination is essentially recursive.
13:41:54 <faxathisia> really? :|
13:42:28 <Cale> You operate mostly on the heads of the lists, and on the first list (after rearranging)
13:43:05 <paczesiowa> do any of you know how to match eof in alex's rules?
13:43:55 <Lycurgus> who is alex?
13:44:33 <paczesiowa> A lexical analyser generator for Haskell
13:44:34 <Zao> Lycurgus: Haskell counterpart of lex.
13:44:37 <Zao> *lexx
13:45:07 <Lycurgus> Acknowledged/Thanks.
13:46:20 <olsner> *lex
13:46:31 <olsner> lexx is scifi :P
13:47:24 <paczesiowa> so, no alex users?
13:49:17 <Zao> olsner: Ah, I'm thinking of flex. I knew I missed a letter, but not which :)
13:49:31 <olsner> :)
13:57:30 <Vulpyne> Anyone around that's familiar with hsgnutls?
14:01:21 <dylan> gesundheit.
14:02:53 <allbery_b> <Zao> Lycurgus: Haskell counterpart of lex.
14:03:12 <allbery_b> this is actually correct as stands; flex is the free software version of the original unix lex :)
14:04:43 <hpaste>  faxathisia annotated "Solve linear diophantine equations" with "Gaussian elimination" at http://hpaste.org/4118#a1
14:05:00 <faxathisia> to implement it I would actually eliminate in the top right? to avoid much consing
14:05:20 <Cale> faxathisia: right. You should partition the rows by whether their first element is 0 or not.
14:05:23 <faxathisia> and should I also sort the columns then rows so that I've got as many zeros there to start with?
14:05:40 <Cale> Not sort, but just use partition
14:06:10 <Cale> If you want, I have some code for this which I could find. It's a good exercise though :)
14:06:26 <faxathisia> I would really appreciate it
14:06:40 <faxathisia> I've actually written Gaussian elimination 3 times in the last week :p
14:06:48 <faxathisia> (using different datatypes)
14:11:57 <faxathisia> I don't know what you mean by partition though
14:12:03 <faxathisia> like actually split the matrix in two?
14:17:10 <hpaste>  Cale annotated "Solve linear diophantine equations" with "Gaussian elimination" at http://hpaste.org/4118#a2
14:17:56 <faxathisia> wow, thank you very much :D
14:18:06 <Beelsebob> bloody hell
14:18:14 <Beelsebob> someone actually writing real functional programs
14:18:28 <Cale> Beelsebob: hm?
14:18:37 <Beelsebob> it's not a massive file of arrays and monads to make it into imperative code
14:19:01 <Beelsebob> not even any strictness anotations
14:19:03 <Cale> heh
14:19:04 <Beelsebob> I congratulate you :)
14:22:29 <mrd> any NDP hackers around? is there a cool way to update a UArr with new values in parallel?
14:22:41 <mrd> like // for immutable arrays
14:24:14 <Cale> mrd: Doesn't ndp use an immutable interface?
14:24:22 <Cale> er, oh
14:24:28 <Cale> I see what you mean :)
14:25:02 <dmwit> :t (<$)
14:25:04 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:26:36 <ihope> @free a -> f b -> f a
14:26:36 <lambdabot> Extra stuff at end of line
14:26:42 <ihope> @free f :: a -> f b -> f a
14:26:42 <lambdabot> Extra stuff at end of line
14:26:50 <mrd> @djinn a -> b -> b
14:26:50 <lambdabot> f _ a = a
14:26:55 <mrd> @free a -> b -> b
14:26:55 <lambdabot> Extra stuff at end of line
14:26:59 <ihope> @free f :: a -> F b -> F a
14:26:59 <lambdabot> $map_F g . f x = f (g x) . $map_F h
14:27:40 <Cale> mrd: at the very least you should be able to accomplish it with a comprehension
14:27:43 <Cale> (or map)
14:28:06 <mrd> i suppose
14:28:26 <Cale> mrd: Just doing a lookup, with the fallthrough case being equal to the current value.
14:28:42 <ihope> @free putStr
14:28:43 <lambdabot> $map_IO $id . putStr = putStr
14:28:57 <ihope> What an entirely non-obvious theorem.
14:29:17 <ihope> @free error
14:29:18 <lambdabot> f . error = error . $map $id
14:29:31 <ihope> Much more interesting.
14:29:55 <ihope> Not sure why it felt the need to $map $id before doing so, though :-P
14:31:11 <faxathisia> @instances Fractional
14:31:12 <lambdabot> Double, Float
14:31:29 <Cale> faxathisia: Also, Rational, if you import Data.Ratio of course :)
14:31:38 <faxathisia> aha that's what I wanted, thank you
14:32:06 <ihope> @free (+)
14:32:06 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:33:34 <dmwit> "Is dmwit stupid or just asking too many questions? 21.6% lines contained a question!"
14:33:39 <dmwit> =/
14:33:47 <dmwit> I guess that's what I get for googling myself.
14:34:05 <Cale> heh, that's kind of a silly log analyser
14:34:11 <mrd> is dimwit stupid?
14:34:16 <mrd> sorry =)
14:34:22 <ihope> mrd: stop making puns while I'm typing them!
14:34:23 <dmwit> Well... I guess he is at that. =)
14:34:37 <dmwit> oh, I get it
14:34:39 <dmwit> heh
14:37:14 <olsner> that's dmwit proving his wit dm for you :P
14:38:23 <sizur> in OpenGL, renderString :: (Font a) => a -> String -> IO (). How do i state the coordinates where to begin to render the text?
14:38:27 <dobblego> it's not just me that reads dmwit as "dim wit"?
14:38:35 <allbery_b> newp :)
14:38:36 <dmwit> No, it's on purpose.
14:38:42 <sizur> that function is in GLUT not OpenGL, sorry
14:38:53 <dmwit> I thought it was clever back in 5th grade.
14:39:03 <dmwit> Incidentally, I still think it's pretty clever. =)
14:39:15 <mrd> witty
14:39:40 <mrd> there is a glRenderString?
14:39:48 <mrd> oh
14:39:57 <mrd> there's probably a glutMoveTo or something
14:40:21 <sizur> mrd: where
14:40:45 <mrd> in your computer
14:41:12 <sizur> witty. i dont see a function like that in the module docs
14:41:37 <dmwit> It's part of Data.Language.Natural.
14:41:54 <dons> F# and SPJ and multicores: leading new people to haskell :)  http://nxtgenug.spaces.live.com/Blog/cns!59F714755D6E2A69!221.entry
14:41:54 <lambdabot> http://tinyurl.com/2hbzto
14:41:57 <dmwit> In the new GHC 6.10.1 "ai" library.
14:42:23 <sizur> and hoogle does not cover any GLs
14:44:10 <mrd> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL-2.2.1.1/Graphics-Rendering-OpenGL-GL-RasterPos.html
14:44:10 <lambdabot> http://tinyurl.com/2cakh8
14:44:35 <mrd> my guess: currentRasterPosition $= Vertex4 ...
14:44:41 <dons> sjanssen: so your chameneos code is right, wrt. ndiff?
14:44:57 <sizur> declarative nature of haskell led me to pick it up. and so much more declarative nature of reactive animation. but for some strange reason not many ppl find FRP that interesting
14:44:59 <dons> i get quite varying numbers
14:45:17 <mrd> or maybe rasterPos
14:45:18 <allbery_b> actually I think people find it interesting but not quite there yet
14:45:20 <sjanssen> dons: yeah, the numbers aren't deterministic
14:45:29 <allbery_b> there was a -cafe thread recntly on that
14:45:48 <mrd> rasterPos (Vertex2 ...)
14:46:00 <dons> sjanssen: is it enough for ndiff to give the ok?
14:46:10 <mrd> 'later
14:46:11 <sjanssen> I think so
14:46:15 <sjanssen> I haven't installed it
14:46:58 <sizur> mrd: thanks :) testing
14:48:02 <dons> ah yes, the oz one varies a lot too
14:48:13 <dons> well, not much, actually
14:50:45 <sjanssen> dons: AIUI, they won't compare the numerals at all, only the spelled out versions
14:53:56 <sizur> mrd: thanks :) it works. i need to get more familiar with the docs
14:57:32 <dons> sjanssen: ah ok
14:59:24 <faxathisia> @pl (\y -> case y of Just x -> x ; Nothing -> 0)
14:59:24 <lambdabot> (line 1, column 25):
14:59:24 <lambdabot> unexpected ">"
14:59:24 <lambdabot> expecting variable, "(", operator or ")"
15:00:04 <allbery_b> case can't be made pointless
15:00:20 <faxathisia> oh because it forced evaluation ?
15:00:41 <allbery_b> because of the syntax.  case <point> of ...
15:00:43 <Saizan> ?type fromMaybe 0
15:00:45 <lambdabot> forall t. (Num t) => Maybe t -> t
15:00:50 <allbery_b> there is no lambdacase
15:00:58 <faxathisia> ooh
15:01:03 <faxathisia> cool :D
15:01:09 <SamB_XP> also, lambda doesn't count as pointless
15:02:15 <SamB_XP> you'd need an operator that performed a single level of church-encoding...
15:02:21 <allbery_b> no, but lambdacase would also be pointfree case (at least in the case expression)
15:02:31 <allbery_b> case of
15:02:44 <allbery_b> patterns would still be pointful I guess
15:02:57 <dobblego> scala> (y: Option[Int]) => y match { case Some(x) => x; case None => 0 }
15:04:31 <dobblego> (_: Option[Int]) match { case Some(x) => x; case None => 0 }
15:04:39 <atp> hey, does anyone know how to make firefox display text/x-haskell (ie, haskell source code) as text/plain (in pane) rather than forcing me to download it?
15:04:43 <faxathisia> @hoogle b -> [(a, b)] -> Maybe a
15:04:43 <ddarius> maybe n j m = case m of Nothing -> n; Just x -> j x
15:04:43 <lambdabot> No matches, try a more general search
15:04:50 <ddarius> maybe 0 id
15:05:13 <ddarius> Luckily maybe is already defined.
15:05:22 <faxathisia> @src lookup
15:05:22 <lambdabot> lookup _key []          =  Nothing
15:05:22 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:05:22 <lambdabot>                         | otherwise = lookup key xys
15:05:49 <atp> is lookup not defined for a general monad?
15:05:57 <atp> or is that just Data.Map.lookup
15:06:18 <ddarius> atp: Many do, but not the standard list lookup.
15:06:36 <mrd> @src lookup
15:06:36 <lambdabot> lookup _key []          =  Nothing
15:06:36 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:06:36 <lambdabot>                         | otherwise = lookup key xys
15:06:40 <mrd> @hoogle lookup
15:06:41 <atp> hm, that's too bad.  it's nice to use the list monad sometimes :)
15:06:41 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:06:41 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
15:06:41 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
15:06:49 <ddarius> atp: However, you can write a maybeToMonadZero
15:06:49 <faxathisia> I just wrote flippedLookup
15:06:52 <mrd> @hoogle maybeToList
15:06:56 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
15:07:46 <ddarius> It would incidentally be, maybe mzero return or maybe (fail "fraggle") return
15:08:54 <atp> yeah, i mean, it just seems like lookup is almost the canonical example of why general monads are a good thing... of course i can tranlate it after the fact, but it's not as elegant ;)
15:09:02 <atp> translate it rather
15:09:06 <perspectivet> what's the idiom  way to determine endianess of the machine currently running a chunk of haskell code
15:09:13 <perspectivet> *idiomatic
15:09:20 <ddarius> atp: Much of the standard library is not as general as it could be for a variety of reasons.
15:09:44 <atp> efficiency?  ease of implementation?
15:09:52 <ddarius> atp: Neither of those.
15:09:55 <atp> hm
15:09:57 <atp> then?
15:10:09 <dobblego> to keep people employed!
15:10:13 <atp> hehe
15:10:29 <dons> sjanssen: looks good. go ahead an submit it. be sure to let isaac know what flags to use (e.g -fbang-patterns -O )
15:10:41 <ddarius> atp: Beginner friendliness, such idioms weren't as common when the standard library was made, potentially a bit of backwards compatibility
15:10:57 <mrd> length :: (Num a, StringLike b) => b -> a
15:11:00 * mrd chuckles
15:11:16 <atp> hm, yeah, i suppose that's true, although really the truth is that you can't put off learning monads for long if you want to write haskell
15:11:28 <atp> they're just too pervasive and convenient
15:11:32 <mrd> er ListLike
15:11:41 <ddarius> atp: The issue was more getting simpler types/type errors.
15:12:03 <atp> ddarius: yeah, i mean, don't get me wrong, i'm not arguing with you or disagreeing with the design decision, i understand it completely. i'm just musing.
15:12:03 <ddarius> atp: But yeah, most people don't like that trend in Haskell 98.
15:12:14 <ddarius> atp: Many people disagree with it.
15:12:25 <atp> oh good :)
15:12:58 <atp> it's sort of a trade-off, i guess. i've been teaching my cousin how to program recently and because he has a relatively strong math background i chose haskell as the language to teach him
15:13:11 <atp> you really run up against monads pretty fast
15:13:32 <atp> comonads and arrows a little bit less quickly but even there their use becomes pretty evident after a while
15:13:54 <ddarius> atp: Well one beginner issue however, is that it can be hard to tell when the function you're looking for is an instance of a general one.
15:13:54 <ddarius> atp: All kinds of monad operators do useful things for specific types.
15:13:56 <sizur> i'm only beginning to get monads
15:14:04 <sizur> monoids, that was easy
15:14:19 <atp> sizur: you know, sigfpe wrote a very nice little blog thing called "you could have invented monads" which i recommend
15:14:20 <ddarius> E.g. sequence for the list monad is the cartesian product of a list of lists.
15:14:58 <atp> yeah.  it takes a bit of messing with before it becomes intuitive
15:16:07 <sizur> atp: thanks, found it. i read already about 10 tutorials on monads. time to read one more :P
15:16:41 <atp> sizur: sigfpe is a smart guy.  he also wrote a blog post which explores the trivial monad as a way of expressing taint, which i found very interesting
15:17:28 <sjanssen> dons: https://alioth.debian.org/tracker/index.php?func=detail&aid=307906&group_id=30402&atid=411646 what's the turnaround, usually?
15:17:29 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 307906 Haskell chameneos- ..., http://tinyurl.com/2exfhl
15:17:45 <geocalc> taint ?
15:18:09 <atp> geocalc: yeah.  because a monad is like a box that contains a value, and you can manipulate the value all you want (by applying function to it) but you can't take it out of the box
15:18:14 <ddarius> atp: My point is that there are functions in the standard library that people don't realize are there because they are special cases of a (ridiculously) general function.
15:18:16 <ddarius> sizur: Stop reading tutorials and read some of Wadler's papers.  They are more comprehensive, more authoritative, more entertaining, and likely easier to read/understand.
15:19:02 <atp> ddarius: sure, i understand.
15:19:48 <sizur> this? http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
15:19:48 <lambdabot> Title: Wadler: Monads
15:20:06 <ddarius> sizur: Yes.  I recommend "The essence of functional programming" for a start.
15:20:19 <geocalc> that don't explain whjat mean the word "taint" is it colors ?
15:20:31 <atp> geocalc: oh, no, hehe, taint as it spoiled
15:20:53 <sizur> thanks for pointers. i was beginning to feel stupid already (who knows about the truth value of that feeling)
15:20:54 <atp> geocalc: for example, labelling data as unsafe for security reasons (like perl does with the -T switch)
15:21:24 <atp> sizur: feeling stupid is a good sign.  the more you learn about anything, the more you realize how much you don't know.  so don't let it bug you.
15:21:36 <geocalc> mmh ok thanks atp
15:26:35 <ddarius_> @wn taint
15:26:35 <lambdabot> *** "taint" wn "WordNet (r) 2.0"
15:26:35 <lambdabot> taint
15:26:35 <lambdabot>      n : the state of being contaminated [syn: {contamination}]
15:26:35 <lambdabot>      v 1: place under suspicion or cast doubt upon; "sully someone's
15:26:35 <lambdabot>           reputation" [syn: {defile}, {sully}, {corrupt}, {cloud}]
15:26:37 <lambdabot>      2: contaminate with a disease or microorganism [syn: {infect}]
15:26:39 <lambdabot>         [ant: {disinfect}]
15:27:45 <hpaste>  faxathisia annotated "Solve linear diophantine equations" with "solve'" at http://hpaste.org/4118#a3
15:28:25 <faxathisia> Cale: It's working now with Gauss-Jordan Elimination, again thanks :D
15:28:35 <Cale> faxathisia: cool :)
15:30:23 <dobblego> what's the Lisp equivalent of folds?
15:30:32 <faxathisia> dobblego: CL has reduce
15:30:46 <dobblego> thought so, cheers
15:31:05 <faxathisia> iirc scheme does not have an equivalent but it is in a SRFI
15:33:46 <ddarius> sizur: The paper "Monads for Functional Programming" is similar to "The essence of functional programming" but a bit longer and covering more/different stuff.
15:35:43 <ddarius> Of course you can easily define foldl.  foldr isn't so useful.
15:36:51 <sizur> ddarius: thx
15:37:25 <scook0> ddarius: in a strict language, you mean?
15:40:14 <ddarius> scook0: Yes, i.e. CL/Scheme.
15:57:21 <chessguy> 'evening haskellers
15:57:33 <TSC> Hi cheese guy
15:57:45 <Excedrin> mmm cheese
15:57:46 <dikini> evening
15:58:32 <tennin> in Haskell I still have to re-explain to myself why foldr is more basic everytime I use it.
15:59:18 <faxathisia> how do you define read for a custom datatype?
15:59:23 <dikini> i'm trying to cook a channel monad, or monad like structure, but return eludes me slightly :)
15:59:24 <faxathisia> It's not like show
15:59:30 <tennin> I think that'll go away... eventually
15:59:51 <faxathisia> It says, `read' is not a (visible) method of class `Read'
16:00:24 <chessguy> dikini, @paste your code?
16:00:29 <dikini> the only meaning I can come up with is a new channel, but that doesn't feel right
16:01:01 <sjanssen> tennin: yes, you just have to remember that foldr simply replaces the :'s and [] in a list
16:01:05 <TSC> faxathisia: It's not a method; you should define readsPrec (or for GHC, readPrec)
16:01:11 <sjanssen> faxathisia: can't you use deriving Read?
16:01:22 <dikini> chessguy: I'm working the basics atm, the code is just an outline... not code
16:01:23 <faxathisia> I couldn't get what I want from deriving
16:01:35 <sjanssen> faxathisia: generally it is not recommended to write custom Read/Show instances
16:01:58 <SamB_XP> sjanssen: how about specifically?
16:02:24 <faxathisia> readsPrec        :: Int -> ReadS a
16:02:27 <faxathisia> this is odd
16:02:39 <SamB_XP> faxathisia: read the report
16:02:54 <SamB_XP> it won't seem odd after you do that
16:03:03 <tennin> sjanssen: Yeah, that's my handle on it, but sometimes I have to think it through a bit more before I'm convinced
16:03:06 <faxathisia> @report
16:03:06 <lambdabot> ()
16:03:13 <SamB_XP> @google Haskell report
16:03:15 <lambdabot> http://www.haskell.org/onlinereport/
16:03:15 <lambdabot> Title: The Haskell 98 Language Report
16:03:21 <faxathisia> thank you
16:03:40 <hpaste>  (anonymous) pasted "channel monad???" at http://hpaste.org/4120
16:03:45 * SamB_XP goes up to his bed to read, having nothing else to do...
16:04:13 <dikini> i feel guilty of some sin or another with that
16:04:29 <ddarius> tennin: If Tree is data Tree a = Empty | Leaf a | Branch (Tree a) (Tree a), define foldrTree.
16:04:38 <vincenz> > let necklace l = fix (l++) in necklace [1,2,3]
16:04:40 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
16:04:45 <vincenz> @hoogle [a] -> [a]
16:04:45 <lambdabot> Prelude.cycle :: [a] -> [a]
16:04:45 <lambdabot> Prelude.init :: [a] -> [a]
16:04:45 <lambdabot> Prelude.reverse :: [a] -> [a]
16:04:50 <vincenz> @src cycle
16:04:50 <lambdabot> cycle [] = undefined
16:04:50 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:05:47 <tennin> ddarius: would it take a binary operation::a->a->b, a unary function::a->b, and a value::b?
16:05:57 <ddarius> tennin: Yes.
16:06:09 <ddarius> Well, not quite those tyes.
16:06:14 <tennin> er, right
16:06:53 <tennin> um, a->b->b
16:07:11 <dikini> problem with a new channel return is that it breaks it won't be a right identity
16:07:27 <tennin> er no that's not... aagh i've been up too long can't think
16:07:46 <ddarius> @where report
16:07:46 <lambdabot> http://www.haskell.org/onlinereport/
16:07:52 * dikini looks at his keyboard - it has it's own mind
16:08:18 <sjanssen> tennin: do you know about the other catamorhpisms in the standard library?
16:08:25 <sjanssen> tennin: eg. maybe, eiter
16:08:27 <tennin> no actually
16:08:28 <sjanssen> either
16:08:32 <tennin> wait, yes
16:08:50 <tennin> I've had to think this through a bunch of times.  I have a eureka moment everytime but somehow it doesn't keep.
16:08:56 <tennin> (this = catamorphisms)
16:09:44 <resiak> does anyone have any recommendations for categories textbooks?
16:10:00 <ddarius> resiak: Introductory or what?  What background do you have?
16:10:20 <sizur> trees and bushes and wind and
16:10:27 <sizur> wallpaper
16:11:02 <slava> if you want all the details but little philosophy, get 'categories for the working mathematician'
16:11:04 <tennin> I guess in pure untyped lambda calculus data types are defined as folds?  like Church numerals
16:11:10 <slava> it covers all the basics but it's pretty dense
16:11:30 <sizur> thanks all for the pointers :) hitting the sack now
16:11:33 * ddarius agrees with slava.
16:11:46 <ddarius> (Though, I actually found it lighter than I expected it to be.)
16:11:46 <ddarius> tennin: That's one possibility.
16:12:07 <dobblego> category theory for computer scientists (I think is the title) is a short and pretty good explanation
16:12:13 <slava> ddarius: i haven't read the whole thing yet
16:12:18 <slava> just bits and pieces as i've needed them
16:12:24 <resiak> ddarius: i've taken a course this term.  i've skimmed Ben Pierce's “Basic Category Theory for Computer Scientists”, but some more detail would be useful
16:12:25 <slava> its more of a reference than something you'd read cover to cover
16:12:36 <ddarius> slava: It's a reasonably good reference.
16:12:40 <slava> to me category theory is really just a bunch of useful definitions
16:12:50 <slava> and not something to study in itstelf
16:12:51 <ddarius> slava: E.g.?
16:13:09 <hpaste>  dikini annotated "channel monad???" with "(no title)" at http://hpaste.org/4120#a1
16:13:19 <ddarius> slava: There is some really nice "pure" category theory.  Though category theory itself is mostly nice/useful when applied.
16:13:59 <ddarius> E.g. the properties of adjoints is pure category theory, but extremely useful in applications.
16:14:24 <slava> well to me at least, concepts such as adjoint functors didn't make sense until i saw good examples from algebraic topology
16:15:02 <ddarius> slava: Personally, I find representability to be the most useful perspective on the core idea of category theory.
16:15:22 <resiak> slava, ddarius: thanks! :)
16:15:39 <ddarius> slava: I really like how adjoint functors come up in logic.
16:19:18 <dikini> category theory eludes me, but not too much time to study that better :(
16:21:53 <tennin> ok, so foldrTree :: Tree a -> b -> (a -> b) -> (b -> b -> b) -> b; foldrTree t e fl fb = case t of Empty -> e; Leaf x -> fl x; Tree l r -> fb (foldrTree l e fl fb) (foldrTree r e fl fb) ?
16:22:58 <dikini> has anyone dealt with monads and ephemeral structures?
16:23:16 <ddarius> tennin: Yes.
16:23:27 <dikini> i'm kind of lost there
16:23:37 <ddarius> I'd probably use pattern matching rather than case for that, but that doesn't change anything.
16:24:23 <ddarius> tennin: At any rate, the code and (obviously) the type readily and mechanically follow from the data type declaration (assuming it's positive/inductive)
16:24:45 <Milt> so who loves ruby? :)
16:26:23 <davidL> Milt: http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=threadring&lang=all  :D
16:26:25 <lambdabot> Title: thread-ring (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Extra!, http://tinyurl.com/2afspl
16:26:49 <Milt> heh nice link david
16:27:30 <tennin> and foldlTree... wouldn't exist at all since only leaf nodes carry values of the type parameter
16:27:35 <sjanssen> Haskell ftw
16:27:48 <Milt> weird that Mono was tested but not the real implementation of .net
16:28:04 <dikini> on gentoo?
16:28:08 <sjanssen> tennin: personally, I'd call that foldTree instead
16:28:17 <Milt> ah I see
16:28:18 <atp> aren't some crazy people writing H# or something
16:28:31 <tennin> I love MS'
16:28:33 <Milt> im sure there's some haskell for .net
16:28:43 <Milt> people love trying to implement languages for the CLR
16:28:44 <tennin> MS's benchmarking clause in their .net EULA
16:29:00 <atp> my brother's company is a C# shop, so we've joked about clandestinely replacing large swaths of C# with haskell...
16:29:23 <faxathisia> since there is (!) :: (Ix i) => Array i e -> i -> e.. What operator would you use for Array i e -> i -> Maybe e ?
16:29:23 <atp> "hey! we had 40 thousand lines of C# here yesterday, but now there are 40 lines of... dear god, what is a catamorphism?"
16:29:30 <Milt> the real questino is who is writing Haskell.NET on rails?
16:29:36 <dobblego> @remember atp> "hey! we had 40 thousand lines of C# here yesterday, but now there are 40 lines of... dear god, what is a catamorphism?"
16:29:36 <lambdabot> I will never forget.
16:29:39 <sjanssen> faxathisia: !?
16:29:45 <faxathisia> sjanssen: thanks :D
16:30:39 <Milt> I'm new to Haskell.  I found a tutorial called "Write a scheme in 48 hours" and I'm intrigued.
16:30:52 <tennin> "Notwithstanding any other agreement you may have with Microsoft, if you disclose such benchmark test results, Microsoft shall have the right to disclose the results of benchmark tests it conducts of your products that compete with the .NET Component, provided it complies with the same conditions above."
16:30:59 <atp> that's a nice tut, but i think it's best if you know some haskell before you attempt it
16:31:13 <dikini> Milt: I find that tutorial slightly misleading
16:31:19 <Milt> oh realy?
16:31:31 <Milt> it claims that it's for total beginners who don't even know a porgramming language ;0
16:31:37 <atp> Milt: it's lying :)
16:31:38 <davidL> haha tennin
16:31:57 <atp> i learned from the gentle intro, which was pretty good
16:32:04 <atp> yet another haskell tutorial isn't bad either...
16:32:05 <Milt> yeah, I went thorugh a litle of it and I was wondering what kind of person who has never programmed would understand it... maybe someone with a phd in UML
16:32:09 <dikini> yep, implementing scheme is easy, problem is that it doesn't tackle the really interesting part of scheme
16:32:56 <dikini> i don't have the brains for uml too many different diagrammes there
16:33:28 <atp> i think haskell is sort of a gateway drug really
16:33:33 <Milt> gateway to what?
16:33:40 <ddarius> The gateway drug to PLT
16:33:45 <atp> exactly
16:33:54 <dikini> :)
16:33:57 <atp> at first you're saying, wow, that's a cute way to write a factorial function
16:34:13 <atp> and then two weeks later you find yourself saying "why, that's just a hylomorphism!  how stupid of me!"
16:34:18 <mrd> the gateway drug to PCP -- Post Correspondence Problems
16:34:19 <Philippa_> next thing you know you're writing a typechecker for a homebrew type system
16:34:19 <atp> and other things of that nature
16:34:53 <Excedrin> that's some hard stuff
16:35:01 <Milt> I jsut got a new job working at a Windows Forms shop.  They don't seem to expect me to write code though, just to draw diagrams and control flows ;0
16:35:06 * mrd pats his System F typechecker and small step evaluator
16:35:31 <atp> see the funny thing is, when you start out, it *seems* like hard stuff
16:35:39 <atp> and then before you know it...
16:35:42 <Milt> are you talking about PLT scheme?
16:36:09 <davidL> Programming language theory
16:36:19 <Milt> ah
16:36:40 <Philippa_> mrd: I'm trying something that AFAIK is minorly novel. The problem with which is that you spend ages trying to get all the design decisions straight and documented so you don't have to remember how they all interact all at once
16:37:38 <mrd> yea I spent a bunch of time abstracting everything so that I could use either string variables or DeBruijn notation interchangeably.  for no particular reason.
16:38:20 <Philippa_> I didn't mean code design decisions :-)
16:38:30 <dikini> what would you call a monad without the second law? a broken monad?
16:38:40 <mrd> ah. well, considered writing your system on paper first?
16:39:05 <Philippa_> if it's a full spec I may as well be coding it
16:39:16 <ddarius> dikini: I wouldn't call it a monad at all.
16:39:26 <mrd> in Twelf? =)
16:39:29 <Philippa_> at least that way I've got GHC's typechecker helping keep me consistent
16:39:38 <glguy> anyone know who elrodeo is?
16:39:43 <dikini> yeah, I thought so
16:39:56 <Philippa_> I should learn one of the proof assistants sometime - I'll probably buy Coq'Art in the next few months
16:40:04 <atp> perhaps a monad without the associative law could be called a quasimonad *yuck yuck*
16:40:19 <mrd> Twelf is excellent for PLT
16:40:44 <mrd> Coq will drive you nuts because you have to deal with binding still.  Or somehow find a way to encode HOAS.
16:41:27 <faxathisia> Can you nest where's?
16:41:33 <mrd> I guess that's good for extraction though, to have a verified debruijn or somesuch.
16:41:38 <mrd> faxathisia: sure
16:41:52 <ddarius> I thought they did find a way to encode HOAS
16:41:59 <faxathisia> ahh ok thanks
16:42:03 <faxathisia> I had wrong indentation
16:42:09 <Philippa_> tbh, handling binding isn't exactly killing me at the moment
16:42:17 <Saizan> AS?
16:42:24 <mrd> there's some paper with something like it, but I don't think they go the twelf way with negative appearences of recursive types
16:42:48 <mrd> you could probably crib something off the PoPLmark challenge
16:43:30 <hpaste>  dikini annotated "channel monad???" with "the meaning I managed to get to, but seems fishy" at http://hpaste.org/4120#a2
16:43:32 <ddarius> Saizan: Higher Order Abstract Syntax
16:43:58 <ddarius> Saizan: E.g. data Exp = Lam (Exp -> Exp) | App Exp Exp
16:44:26 <mrd> in Twelf that's, lam : (exp -> exp) -> exp.
16:47:40 <ddarius> data Exp where Lam :: (Exp -> Exp) -> Exp | App :: Exp -> Exp -> Exp Happy?
16:47:45 <davidL> is there a short/idiomatic way to set many fields of a datatype equal to elements in a list ([[Word8]])?
16:48:11 <mrd> ddarius: haha, now encode a subject reduction proof in Haskell
16:48:57 <conal> davidL: i don't think so, but if the question arises, perhaps a different datatype def would work better.
16:49:48 <conal> davidL: or maybe the Binary encoding lib would work for you
16:50:04 <mrd> i think i tried to encode the typing relation and had to give up on the Lambda rule
16:50:10 <Leimy> I'm looking through http://legacy.cs.uu.nl/daan/download/parsec/parsec.html to figure out some stuff with Parsec... but it's not behaving the way the document describes with the latest GHC for Mac OS X.
16:50:43 <davidL> conal: thanks, I will look into it
16:50:49 <mrd> "OfLam   :: (forall x. Of x t1 -> Of (e x) t) -> Of (Lam t1 e) (Arrow t1 t)" aborted attempt hah
16:51:52 <ddarius> Leimy: That particular documentation is really really old.
16:52:28 <mrd> of-lam : ({x:tm} of x T' -> of (E x) T) -> of (lam T' E) (arrow T' T)
16:52:47 <Cale> Leimy: The main difference is that the module locations have changed. Are you seeing anything else?
16:53:44 <Leimy> Cale: it's not behaving the way the document claims
16:53:56 <Cale> How in particular?
16:54:21 <Leimy> Cale: for example the "sentence" Parser doesn't allow for ','
16:55:00 <Leimy> oh yes it does... Ugh
16:55:14 <Leimy> anyway the error message doesn't include all the options available
16:55:15 <Leimy> only the last
16:55:21 <Leimy> I think it's the way <|> is working
16:55:32 <Cale> As given in the documentation, sentence is not supposed to parse ','
16:55:44 <Cale> er, oh
16:55:49 <Cale> separator handles that
16:55:53 <Leimy> right :-)
16:55:54 <Cale> so yeah
16:55:56 <Leimy> I was wrong
16:56:00 <Leimy> I forgot a !.?
16:56:02 <Leimy> anyway
16:56:16 <Leimy> the error messages as reflected in this document only show the last choice tried with <|>
16:56:20 <Leimy> not the other option.
16:56:32 <Leimy> so if I do ``run sentence "hi,123"``
16:56:47 <Leimy> I don't get ``expecting "," space or letter"
16:57:45 <Leimy> oh weird!
16:57:47 <Cale> *Main> parseTest sentence "hi,123"
16:57:47 <Cale> Loading package parsec-2.1.0.0 ... linking ... done.
16:57:47 <Cale> parse error at (line 1, column 4):
16:57:47 <Cale> unexpected "1"
16:57:47 <Cale> expecting space, "," or letter
16:57:51 <Leimy> I must have broke something....
16:57:56 <Leimy> cuz now it's working again
16:58:01 <Leimy> I wonder what the heck I typed
16:59:02 <Leimy> oh well... operator error
16:59:03 <Leimy> :-(
16:59:17 <Leimy> totally PEBCAK
16:59:59 <Cale> No worries.
17:00:56 <Leimy> hmmm
17:01:32 <Leimy> yet the tutorial says that I should get "expecting letter or end of sentence" for ``run sentence "hi,di"``
17:01:42 <Leimy> and I only get expecting end of sentence
17:02:01 <Leimy> so something still seems off
17:02:07 <Leimy> it's probably me again though... I'll double check.
17:09:41 <Leimy> yeah it's definitely different from that document's error messages
17:10:29 <Leimy> doesn't say ",", space or letter either
17:10:34 <Leimy> it says space, "," or letter
17:10:46 <Leimy> it's as if the <|> evaluates differently.
17:13:37 <Leimy> and as a result I'm not getting the described error message behavior of <?> either.
17:15:54 <dmwit> Leimy: hpaste?
17:16:05 * ddarius sets off on a crazy exercise.
17:16:06 <Leimy> how to access hpaste?
17:16:10 <ddarius> !paste
17:16:10 <hpaste> Haskell paste bin: http://hpaste.org/
17:16:15 <Leimy> oh sweet
17:18:05 <hpaste>  Leimy pasted "Parsec trouble?" at http://hpaste.org/4121
17:19:00 <dmwit> Leimy: Oh, <|> only goes to its second option if no tokens match the first guy.
17:19:08 <Leimy> right
17:19:24 <dmwit> You need to either left-factor your language, or use <?> for backtracking (which can be very slow!).
17:19:28 <Leimy> but the error in the document says that it should show  "expecting 'a' "
17:19:36 <Leimy> not "expecting "(a)""
17:19:42 <Leimy> that's a pretty big difference isn't it? :-)
17:19:50 <Leimy> I didn't use try
17:19:53 <Leimy> so it should have consumed the (
17:19:53 <dmwit> mmm
17:20:04 <Leimy> which I think is the root of my confusion.
17:20:06 <dmwit> Where's the document?
17:20:15 <Leimy> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html  <-- I was told this is old
17:20:20 <Leimy> but it's th only one I found :-)
17:21:13 <Philippa_> Leimy: your problem appears to be that the error messages for the string parser were improved?
17:21:14 <dmwit> I wouldn't worry about it too much if I were you.
17:21:28 <dmwit> It's entirely possible that Dan just wrote what he figured the error would be without even trying it.
17:22:15 <ddarius> dmwit: More likely, the library has changed in the past 6 years.
17:22:18 <conal> anyone here familiar with Foreigh.Marshall.Alloc ?  I want to know whether memory gets freed automatically, or if I have to set up a finalizer manually.
17:22:26 <dmwit> Yes, I agree that that is more likely.
17:22:26 <conal> i'm referring to malloc
17:22:29 <Leimy> Philippa_: that's an improvement?
17:22:32 <conal> ditto for mallocArray
17:22:50 <Leimy> Philippa_: seems like a bit of a change :-)
17:23:06 <ddarius> conal: You have to free it.
17:23:18 <Philippa_> Leimy: More or less, yes. A <?> got added to the end of string - it'd be nice if it told you it's got the ( already, but note the different quotes?
17:23:23 <conal> ddarius: thanks.
17:23:28 <scook0> conal: given that they produce Ptrs and not ForeignPtrs, and that that module has a free function, I'm guessing manual management
17:23:33 <conal> anyone have examples of automatically freeing via finalizers?
17:23:42 <conal> scook0: makes sense.
17:23:55 <faxathisia> @pointless (\(x,_) -> x /= 0)
17:23:55 <lambdabot> (0 /=) . fst
17:23:59 <Leimy> Philippa_: sure...  It's as if someone snuck a <?> in there, but I wasn't expecting it.  I guess I'll just plod onward.  I'm sure it's fine.  I just thought maybe something was going on.
17:23:59 <sjanssen> conal: it's quite straightforward with ForeignPtr
17:24:08 <sjanssen> conal: or use the alloca functions where you can
17:24:43 <conal> sjanssen: do you use newForeignPtr? and withForeignPtr ?
17:24:45 <Philippa_> Leimy: I say "a bit" because really it ought to tell you it's expecting the rest of the string, or how far through it got
17:25:05 <sjanssen> conal: mallocForeignPtr* functions are easier
17:25:13 <Leimy> Philippa_: and in some cases the errors don't enumerate all the valid things that could successfully complete the parse
17:25:16 <Philippa_> ddarius: once we've got the rest release-worthy, might you be interested in working on Parsec's error handling? It could use both a generalisation and a going-over to produce neater messages
17:25:17 <Leimy> it's enumerating less
17:25:20 <sjanssen> conal: and yes, use withForeignPtr to use the Ptr
17:25:30 <conal> sjanssen: oh.  i hadn't found those ones.  thanks.
17:25:57 <Philippa_> Leimy: yeah, I'm aware of a few like that. It can't keep a perfect "expected" set without some help, and there's no way to help it at the moment
17:25:58 <conal> looks great.
17:26:09 <Leimy> Philippa_: Ok that's fine! :-)
17:26:54 <Leimy> Philippa_: I'm glad I'm not losing my mind.  I can accept that.  Parsec definitely seems pretty great.  My last experience with something like this was boost::spirit, which was ok, but I hate how C++ overloads everything and the template error messages are for the birds.
17:28:00 <dmwit> I <3 GHC's error messages.
17:28:29 <Leimy> yeah GHC is pretty amazing... heard it was ported to the JVM. :-)
17:28:56 <Philippa_> there's still info I'd like to be able to get out of GHC sometimes, but usually it's when I'm doing something fairly weird
17:29:26 <Philippa_> if you're not doing any typeclass hackery there's a couple of basic techniques that'll narrow down the source of an erroneous type pretty fast
17:29:35 <Igloo> Philippa_: What sort of info?
17:29:57 <Philippa_> Igloo: usually some subset of the typing
17:30:14 <Philippa_> I want to know "where the hell did you get that expected type from?", essentially
17:30:27 <Igloo> Ah, right
17:30:32 <Philippa_> it's not something that necessarily wants to be on by default because of the sheer amount of info involved
17:30:59 <Igloo> Yeah, it's hard to present that in a readable format
17:31:04 <Philippa_> it's not too often, but just occasionally a WTFy type gets a bit further than expected and you lose the context for it
17:31:57 <Philippa_> mmm, arguably what you really want there's a type-level debugger
17:32:07 <dmwit> I often comment out a few things and see if the inferred type changes.
17:32:23 <dmwit> So, yeah, you have to learn a few tricks.
17:32:35 <Philippa_> dmwit: doing that systematically's one of the two I had in mind
17:32:38 <dmwit> But for the most common errors, it's very very nice.
17:32:47 <Philippa_> the other's cutting recursive knots with a well-placed type annotation when you've got mutual recursion
17:33:02 <dmwit> Right, I also find myself doing that from time to time.
17:33:38 <dmwit> It's especially helpful to provide an explicit annotation to a function it's flagged as an error, because then it pushes the error farther into the function.
17:33:48 <dmwit> A few iterations of that, and you've narrowed it down to a very small expression. =)
17:35:57 <Brian`> hey, is there a way to make my program listen to RSS feeds so that as soon as RSS feeds get updated, my program fetches those new feeds?
17:36:08 <ddarius> Philippa_: Once we get something out the door, I have no problem fiddling with it.
17:37:59 <dmwit> Brian`: Can it be done in any other language?
17:38:14 <dmwit> (I honestly don't know whether RSS feeds are pull or push, so this is an honest question.)
17:38:27 <Philippa_> they're pull, IIRC
17:38:53 <Brian`> dmwit : I'm not sure if I can do it in any other languages either..
17:38:58 <dmwit> Okay, then the closest he'll get to what he wants is by polling the feed, which isn't all that nice.
17:44:48 <faxathisia> What would you name the process of taking a set of equations and doing something so they become easier to solve?
17:48:11 <dobblego> faxathisia, simplification?
17:48:23 <Brian`> @hoogle [a]->[a]
17:48:31 <lambdabot> Prelude.cycle :: [a] -> [a]
17:48:31 <lambdabot> Prelude.init :: [a] -> [a]
17:48:31 <lambdabot> Prelude.reverse :: [a] -> [a]
17:48:33 <faxathisia> dobblego: ack, of course!
17:48:42 <faxathisia> thanks
17:56:46 <Brian`> how do I change one element from a list in an effective way? like [1,2,3,4,5,6,7] -> [1,2,3,0,5,6,7]
17:57:24 <Leimy> you mean efficient?
17:57:31 <dons> Brian`: splitAt and ++
17:57:31 <Brian`> yeah ; efficient lol
17:57:37 <conal> can anyone explain when cabal writes .setup-config and when dist/setup-config?
17:57:39 <Brian`> :t splitAt
17:57:40 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:57:48 <dmwit> Brian`: Use arrays.
17:58:11 <dons> sjanssen: did you submit your chameneos?
17:58:24 <ddarius> > map toEnum [True,False]
17:58:24 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
17:58:35 <ddarius> > map fromEnum [True,False]
17:58:36 <lambdabot>  [1,0]
17:58:40 <Brian`> thanks dons and dmwit for answering
17:59:29 <faxathisia> haskell is really fun :p
18:00:32 <notsmack> the Fuse link at http://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system#Filesystems_2 is broken; anybody know where it is?
18:00:34 <lambdabot> Title: Applications and libraries/Operating system - HaskellWiki, http://tinyurl.com/29tf4n
18:02:59 <dons> sjanssen: http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneosredux&lang=all
18:03:00 <lambdabot> Title: chameneos-redux (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/36jgbe
18:03:02 <dons> haskell ftw!
18:06:16 <sjanssen> even a little better than I thought
18:08:16 <hpaste>  goalieca pasted "nbody -- pure functional" at http://hpaste.org/4122
18:08:20 <goalieca> hmm. i wrote an nbody here but it is dead slow. Really ultra dead slow. Can't figure out why
18:08:35 <goalieca> there's a space leak too
18:09:23 <ddarius> goalieca: You probably want the tuple components to be strict.
18:09:35 <dons> for Double math you need strict, unboxed Doubles
18:09:42 <dons> and a bunch of C compiler flags
18:10:04 <dmwit> ?index arctan
18:10:04 <lambdabot> bzzt
18:10:08 <dmwit> ?index atan
18:10:08 <lambdabot> Prelude
18:11:39 <ddarius> goalieca: Also why don't you use pattern matching to extract tuples in the adv* functions?
18:12:52 <dons> to compete seriously in the benchmark, you usually have to implement exactly the same algorithm and data structure as the current best entry
18:12:57 <dons> unless you have some natural advantage
18:14:05 <goalieca> well ya. i'm doing this for learning
18:14:07 <goalieca> i'm not that naive :P
18:14:36 <dons> :)
18:15:10 <goalieca> lets say i did it all in floats instead of double
18:15:19 <goalieca> is that faster off the bat.. without dealing with unboxing
18:15:33 <ddarius> Floats are often slower (generally)
18:17:05 <dons> hmm, really?
18:17:22 <atp> why would that be i wonder
18:17:33 <atp> both are word aligned, aren't they?  that can't be why
18:17:38 <dons> i've found the opposite, but rarely can we use Floats for shootout code
18:17:48 <dons> because of precisoin
18:17:52 <Brian`> @hoogle ([a]->[a]) -> [a] ->[a]
18:17:53 <lambdabot> No matches, try a more general search
18:18:20 <atp> dons: yeah, figures.
18:18:49 <atp> i wonder if compilers will ever get good enough that we don't need to code so imperatively for the benchmark
18:19:20 <dons> the concurrency benchmarks give me hope
18:19:35 <dons> but this is really about low level control of the machine, so the benchmarks will probably always be low level
18:19:48 <atp> yeah, well, state-based coding techniques are borked for concurrent algorithms unless you're really really careful
18:19:52 <dons> since its unlikely the compiler can magically optimise any garbage down to domain-optimal code
18:20:35 <faxathisia> : id :: ([a]->[a]) -> [a] ->[a]
18:20:38 <faxathisia> :t id :: ([a]->[a]) -> [a] ->[a]
18:20:39 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a]
18:20:55 <faxathisia> I wonder why hoogle didn't notice that
18:20:57 <atp> yeah... on the other hand, fp (being more mathematical in nature) should lend itself better to all sorts of optimizations not possible with non functional models
18:21:11 <dolio> :t id
18:21:12 <lambdabot> forall a. a -> a
18:21:15 <dolio> That's why.
18:21:22 * faxathisia doesn't understand
18:21:43 <goalieca> hmm.. adding strictness anotations has sped things up quite a bit so far
18:21:48 <faxathisia> a -> a unifies with ([a] -> [a]) -> [a] -> [a]
18:21:49 <goalieca> but not nearly the order of magnitude needed
18:21:52 <dolio> The search algorithm isn't sophisticated enough to transform a -> a into the one your version.
18:21:57 <Philippa_> atp: that tends to work better in large-scale systems than in microbenchmarks
18:22:08 <faxathisia> how does hoogle actually work
18:22:09 <faxathisia> ?
18:22:20 <atp> true
18:23:04 <dolio> ndm is allegedly working on something that would find that for the next version of hoogle, though, whenever that's due.
18:23:22 <faxathisia> will that work by unification or checking  subtyping or what?
18:23:36 <Philippa_> atp: largely because the amount of info needed to teach the compiler enough to optimise something is often too much to be worth a one-off use
18:23:44 <dolio> Well, he has a bunch of rewrite rules.
18:23:58 <faxathisia> oh I suppose flip is one of the rules
18:23:58 <dolio> And depending on which rewrite rules you use depends on what order they'll be ranked.
18:24:07 <faxathisia> (currently)
18:24:14 <faxathisia> oh that's clever
18:24:38 <goalieca> hmm. code certainly loses readability when adding all these bloody annotations
18:24:50 <ddarius> goalieca: Use bang patterns.
18:25:09 <ddarius> Or better, you should be able to use unboxed tuples for the tuples of Doubles.
18:25:34 <Saizan> are type synonims in an usable status? i find they don't simplify consistently
18:25:46 <ddarius> Saizan: ?
18:26:12 <Saizan> sorry, associated type synonims/type families
18:26:26 <faxathisia> @hoogle [Either a b] -> ([a],[b])
18:26:26 <lambdabot> No matches, try a more general search
18:26:55 <faxathisia> ?djinn [Either a b] -> ([a],[b])
18:26:56 <lambdabot> -- f cannot be realized.
18:27:07 <ddarius> Djinn doesn't do recursive types (like lists)
18:27:38 <dobblego> ?type es -> (lefts es, rights es)
18:27:39 <lambdabot> Parse error in pattern
18:27:45 <faxathisia> For what reason?
18:27:52 <faxathisia> well I mean
18:27:58 <faxathisia> is it "impossible", or just hard?
18:28:10 <atp> hey, there's no way to make a purely functional FIFO that has actual O(1) update and retrieval, is there?  ie, not amortized O(1)
18:28:30 <sorear> faxathisia: impossible
18:28:46 <ddarius> I don't think it would be that much harder for most types.
18:28:52 <dolio> You can prove too many theorems with recursive types.
18:28:53 <sorear> @go finger trees
18:28:54 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
18:28:54 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
18:29:06 <sorear> constant O(1) access to both ends
18:29:35 <atp> sorear: ah, cool, let me check that out
18:29:46 <shapr> mmm, finger trees!
18:30:02 <atp> purely functional data structures are the win
18:30:08 <shapr> yay fp!
18:30:47 <shapr> atp: Is your nickname adenosine triphosphate?
18:30:56 <atp> no, my initials
18:31:16 <dmwit> You have very energetic initials.
18:31:16 <atp> although i often get asked that, which is one reason i love freenode
18:31:41 <atp> :)
18:32:07 <ddarius> atp: Look at "Purely Functional Data Structures" by Chris Okasaki.  There is a paper and a book.
18:33:01 <atp> yeah, i've looked at that... i don't know ml too well, though, so it didn't sink in immediately.
18:33:14 <dolio> There's haskell in the back.
18:33:20 <dolio> Although flipping all the time is a pain.
18:33:24 <atp> of the book or the paper
18:33:28 <atp> i only looked at the paper
18:33:29 <dolio> The book.
18:33:41 <atp> hm
18:33:56 <atp> i'll keep an eye open for it.
18:34:20 <dolio> I can't say I've seen it anywhere. You might have to buy it online.
18:34:25 <Saizan> mmh when you've bugs in type-level programs the kind system doesn't help much
18:34:44 <dolio> Maybe I just don't visit the right bookstores, though.
18:35:10 <dobblego> I bought it online, it was cheap
18:35:31 <atp> dolio: no, you're probably right.  unfortunately.  but okasaki's paper on red black trees in haskell was pretty awesome, so it's not like i'm worried it'll suck
18:36:43 <atp> these days, even relatively mainstream literature is getting hard to find in meatspace bookstores... amazon is killing them all, which i suppose can't be helped, but i miss the way i used to be able to browse
18:37:15 <thoughtpolice> i have a copy of okasaki's book sitting here. should probably read through it sometime
18:37:21 <atp> now the computer science section of bookstores is some variation of xml for dummies
18:37:29 <dobblego> is there a way of making an expression monomorphic in a where clause?
18:37:47 <dolio> Yeah. It's hard to find stores with a good math/comp sci section.
18:37:49 <thoughtpolice> atp: i know how you feel. no bookstore here carries anything more competant than something like 'java for dummies'
18:38:05 <thoughtpolice> although I did see some nice andre lamothe book sitting around. didn't have the money though. :(
18:38:18 <thoughtpolice> anything I want that's serious I'd have to go to barnes&nobles, which is like an hour away.
18:38:27 <dolio> One of the stores in my area eliminated the math section entirely when they moved, as far as I can tell.
18:38:59 <atp> yeah.  i'm lucky because i live next to stanford, so i just pop into the bookstore there... they have a slightly better than average selection
18:39:08 <ddarius> dobblego: Give it a type annotation
18:39:36 <dobblego> ddarius, sure, but how?
18:39:38 <atp> but even thurston's great 3d geometry & topology i ended up having to order on-line
18:39:47 <atp> after my copy's spine broke :(
18:40:02 <ddarius> f x = g x where g :: Int -> Int; g x = x
18:40:22 <dobblego> ?check \x -> x % 2 == 0 || x % 2 == 1 || x % 2 == -1 where x :: Int
18:40:22 <lambdabot>  Parse error at "where" (column 47)
18:40:42 <Saizan> you can't have where in a lambda
18:41:00 <dobblego> right, so can I restrict it easily somehow?
18:41:11 <ddarius> :t \(x::Int) -> x
18:41:19 <lambdabot> Int -> Int
18:41:28 <dobblego> ok, I thought there might be a nicer way
18:41:31 <dobblego> cheers
18:41:33 <sjanssen> dobblego: \x -> (x :: Int) % 2 == 0 || x % 2 == 1 || x % 2 == -1
18:41:42 <dobblego> sjanssen, yep thanks
18:41:47 <sjanssen> \(x::Int) requires GHC extensions
18:41:59 <atp> also, (%) constructs ratios...
18:42:14 <ddarius> :t (%)
18:42:15 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:42:22 <sjanssen> atp: interestingly, it's still valid code
18:42:31 <dobblego> I know, I wanted to prove it false for someone
18:42:37 <ddarius> Go overloaded literals
18:42:38 <atp> sure, because fromInteger -1 == -1 to haskell
18:42:42 <Saizan> ?check \x -> let test = x % 2 == 0 || x % 2 == 1 || x % 2 == -1 where x :: Int in test
18:42:43 <lambdabot>   Misplaced type signature: x :: Int
18:43:43 <ddarius> You can give types to locally declared values in a where (or a let), not "retroactively" give a type to some variable in an outer scope.
18:44:51 <dolio> @check \x -> let test = y % 2 == 0 || y % 2 == 1 || y % 2 == -1 ; y :: Int ; y = x in test
18:44:52 <atp> you could use asTypeOf maybe
18:44:53 <lambdabot>  Falsifiable, after 0 tests: -1
18:46:16 <atp> hey, just to be confusing, you could encase it all in a let x % y = x `mod` y in ...
18:46:19 <atp> hehe
18:46:45 <atp> or maybe just let (%) = mod in ?
18:46:49 <atp> does that even work?
18:46:52 <dobblego> atp, yes
18:47:14 <atp> and the locally overridden operator has the same fixity as its overloaded parent unless otherwise specified?
18:47:21 <atp> or what?
18:47:24 <sjanssen> ?check \x -> let _ = x :: Int in x % 2 == 0 || x % 2 == 1 || x % 2 == -1
18:47:25 <lambdabot>  Falsifiable, after 1 tests: -1
18:47:26 <ddarius> > let f (%) = 6 % 3 in f mod
18:47:27 <lambdabot>  0
18:47:44 <ddarius> atp: It should have the default fixity I believe.
18:47:46 <goalieca> hmm. i'm having trouble unboxing all the tuples. tons of illegal binding errors
18:47:53 <ddarius> atp: You can locally specify a fixity if you want.
18:47:59 <atp> ddarius: how would you do that?
18:48:12 <ddarius> goalieca: You can't unbox the tuples of tuples (I'm pretty sure)
18:48:16 <sjanssen> goalieca: there are major restrictions in how you can use unboxed tuples
18:48:37 <goalieca> so i'll just unbox all the doubles anyways. mostly though i figure the lack of "in-place" updating is killing me
18:48:43 <ddarius> > let (%) = mod; infixl 5 % in 3 % 5
18:48:46 <lambdabot>  3
18:48:54 <atp> ah, it goes in the let... interesting
18:48:59 <goalieca> so far i've sped up way more than 10x
18:50:48 <goalieca> this reminds me of those days when i had to explicitly add "Register" keyword in c
18:51:01 <atp> sometimes you still have to :)
18:51:26 <atp> after all, if you're coding C, why not manipulate every little thing
18:51:42 <ddarius> Because then you might as well code ASM
18:51:49 <atp> yes, that's sort of what i meant :)
18:52:05 <atp> it's a haha only serious kind of joke though, because i actually quite like C
18:52:42 <atp> it's close enough to ASM that it's pretty uncommon that you ever need to write asm anymore
18:52:45 <atp> which is good
18:53:31 <goalieca> i do like c as well. it's haskell i have a hard time figuring out what it is gonna produce
18:53:45 <atp> goalieca: that comes with practice
18:53:52 <atp> you just have more experience with C is all
18:54:33 <goalieca> all it took was learning assembly
18:54:39 <goalieca> unfortunately that doesn't transfer to haskell
18:54:40 <ddarius> goalieca: What does your code look like now?
18:55:01 <ddarius> goalieca: Sure it does, you just have more layers to go before it becomes significant.
18:55:15 <atp> learning assembly is good for any programmer
18:55:25 <ddarius> goalieca: Ironically, learning CPS transfers back to assembly.
18:55:28 <atp> as is learning haskell :)
18:56:30 <hpaste>  goalieca annotated "nbody -- pure functional" with "updated" at http://hpaste.org/4122#a1
18:56:33 <faxathisia> how can you learn assembly:
18:56:34 <faxathisia> ?
18:56:46 <atp> pick an architecture, read the manual
18:56:49 <goalieca> faxathisia, i also know vhdl/verilog
18:57:03 <ddarius> The Art of Assembly is decent for the x86 architecture.
18:57:27 <goalieca> ddarius, basically all i've done is strictified things. i can't figure out how to unbox the double tuples
18:57:37 <goalieca> getting too many illegal errors..
19:01:17 <dons> goalieca: use a custom type
19:01:32 <dons> data T = T {-# UNPACK #-} !Double {-# UNPACK #-} !Double
19:01:34 <dons> :)
19:01:41 <dons> and repalce (x,y) with (T x y)
19:01:54 <dons> data T = {-# UNPACK #-} !Double :*: {-# UNPACK #-} !Double
19:01:59 <dons> i wonder if that works ^
19:02:07 <dons> then (x :*: y)
19:02:07 <sjanssen> yes, data types that have been UNPACKed are better than unboxed tuples anyway
19:02:32 <dons> yeah, don't use (# x , y #) -- they're really tricky, due to the restrictions on the value semantics
19:02:39 <dons> [  ;)  ]
19:03:08 <dolio> @quote value semantics
19:03:08 <lambdabot> No quotes for this person.
19:03:22 <goalieca> unpack?
19:04:14 <shapr> @bot
19:04:14 <lambdabot> :)
19:04:39 <Nafai> Hey shapr!
19:06:15 <sjanssen> goalieca: yes, it means that the double itself is stored in the structure, rather than a pointer to a double
19:08:45 * Nafai tries to figure out how to compile yi
19:10:26 <dons> import GHC.Exts
19:10:26 <dons> main = print $
19:10:26 <dons>     case (# 1.0##, 2.0## #) of
19:10:27 <dons>          (# x,y #) -> D# (x +## y)
19:10:40 <dons> if you want to invite criticism :)
19:10:47 <faxathisia> You don't mind using fromJust when it's trivial to observe it can never fail?
19:11:06 <Nafai> When I try to configure Yi, I get this:     "Could not find module `Distribution.Simple.Setup':"
19:11:16 <dons> compiles to,
19:11:17 <dons> Main.main =
19:11:17 <dons>   GHC.Base.$
19:11:17 <dons>     @ GHC.Float.Double
19:11:17 <dons>     @ (GHC.IOBase.IO ())
19:11:20 <dons>     print_rox
19:11:22 <dons>     (GHC.Float.D# (GHC.Prim.+## 1.0 2.0))
19:11:25 <dons> good ghc.
19:11:37 <monochrom> print rox. indeed. :)
19:11:41 <davidL> Nafai: you probably need to upgrade cabal
19:12:26 <dons> and we get : Main.lvl = GHC.Float.D# 3.0
19:12:29 <dons> with ghc -O
19:12:31 <dons> :)
19:12:38 <dons> probably a good thing
19:12:57 <Nafai> davidL: Okay, let me figure out how to do that
19:13:12 <davidL> @where cabal
19:13:12 <lambdabot> http://www.haskell.org/cabal
19:14:31 <hpaste>  ddarius annotated "nbody -- pure functional" with "unboxed tuples, pattern matching, no superfluous parens" at http://hpaste.org/4122#a2
19:15:42 <ddarius> You also don't need the $! in runIt
19:18:22 <dons> that's a lot of bangs
19:20:18 <ddarius> Several can be removed.
19:20:42 <Nafai> If I build a new version of cabal and install it in my $HOME, will it override the version that is installed system-wide?
19:20:53 <ddarius> Most actually.
19:24:14 <sjanssen> Nafai: yes
19:25:16 <hpaste>  ddarius annotated "nbody -- pure functional" with "quieter code" at http://hpaste.org/4122#a3
19:25:57 <Nafai> sjanssen: Thanks
19:26:06 <dons> did you check the core code, ddarius , or just infer it from the use?
19:26:29 <goalieca> lol. i !'d a lot
19:26:30 <ddarius> dons: Simple human strictness analysis.
19:26:56 <ddarius> If GHC can't do what I did for most of those, it's broken.
19:27:27 <ddarius> I'm fairly certain there is still some room for improvement.
19:27:30 <ddarius> Strictness wise.
19:28:44 <scook0> is there any particular reason Data.Unique doesn't support Show?
19:29:04 <Nafai> Bleh
19:29:21 <Nafai> This is sure taking a bit
19:29:26 <scook0> (at the moment I'm just unsafeCoerce#-ing to Integer, which makes me queasy)
19:31:26 <dons> scook0: hashUnique :: Unique -> Int
19:31:49 <sjanssen> hmm, this is interesting
19:32:07 <scook0> dons: not *quite* the same thing, but I guess I won't be creating 2^32 unique objects anyway
19:32:14 <sjanssen> goalieca: I added some strict data types to your code and it overflowed the stack.  Do you use laziness in this program?
19:33:33 <goalieca> nope..
19:33:45 <ddarius> My first version has a typo where there is a loop in adv1.
19:33:47 <sjanssen> hmm
19:33:50 <goalieca> probably runIt being recursively called
19:34:18 <Nafai> What does this mean?
19:34:21 <Nafai>     Could not find module `Data.ByteString.Internal':
19:34:21 <Nafai>       it is a member of package bytestring-0.9, which is hidden
19:35:24 <sorear> Nafai: it means you didn't remember to declare a dependancy on bytestring
19:35:48 <Nafai> Hrm
19:36:13 <Nafai> I'm trying to use the latest zlib library
19:42:21 <Nafai> Oh, d'oh.
19:42:38 <Nafai> I see that the latest yi depends on GHC 6.8 :(
19:46:57 <ivanm> On the mailing list recently, there were comments about how wordpress didn't like Haskell code...
19:47:11 <ivanm> so what would be the best/most popular blogging site for Haskell then?
19:48:00 <dons> roll your own is pretty popular
19:48:12 <davidL> HAppS-Begin :)
19:49:53 <hpaste>  sjanssen annotated "nbody -- pure functional" with "15x faster than the original.  Any good?" at http://hpaste.org/4122#a4
19:51:14 <Brian`> how come "map (\x -> read x::Int) . words . unlines" doesn't work?
19:51:25 <Brian`> since (words . unlines) :: [String] -> [String]
19:51:41 <Brian`> and map f takes any list, shouldn't this work..?
19:52:12 <ddarius> :t map (\x -> read x :: Int) . words . unlines
19:52:14 <lambdabot> [String] -> [Int]
19:52:16 <ivanm> dons: presume for the sake of argument that I don't have a server or 24-hour uptime computer handy (seeing as how I don't) :p
19:52:20 <ddarius> Brian`: What's the problem?
19:52:40 <ivanm> (though I might down the track)
19:53:32 <Brian`> ddarius, ohhh i c... that's because I was using it in do block
19:53:36 <monochrom> I believe sigfpe uses blogspot just fine.
19:53:59 * Nafai compiles ghc 6.8.1
19:54:06 <Nafai> I wonder how long that will take :)
19:54:48 <dons> you could even serve up content on community.haskell.org
19:55:26 <ivanm> heh
19:55:33 <hpaste>  goalieca annotated "nbody -- pure functional" with "louder but much faster (8x)" at http://hpaste.org/4122#a5
19:55:39 <ivanm> I was originally leaning towards wordpress, but after those comments... :s
19:55:51 <goalieca> i magically picked the right thing to "strict" and nailed another massive performance.
19:56:04 <dons> well, you can do it less magically by reading the core :)
19:56:22 <dons> its not really hit-and-miss, you're tuning the generated code
19:56:39 <dons> -ddump-simpl !
19:57:07 <goalieca> well.. i'm actually within a factor of 2x of the actual debian one
19:57:38 <chessguy> @pl f B x y = x
19:57:38 <lambdabot> f = const const
19:58:34 <goalieca> hmm. core looks like it takes a bit to learn how to read
19:58:48 <sjanssen> goalieca: how does your code compare to the code I've posted?
19:59:45 <goalieca> i didn't check that one yet. i'm checking it now
20:03:11 <Korollary> goalieca: Montreal beat Toronto in shootout
20:03:22 <goalieca> Korollary, i saw. and they had to zamboni it a few times
20:03:27 <Korollary> and Sadine just scored
20:03:28 <goalieca> cannucks just score 2 secs ago
20:03:33 * goalieca enjoys his tv tuner
20:03:50 * Korollary enjoys Center Ice
20:11:30 <goalieca> Korollary, fight
20:12:30 <Korollary> goalieca: The Ducks fight a lot. I am waiting for the guy with the mustache (Garros?)
20:15:22 <hpaste>  chessguy pasted "is this CPS?" at http://hpaste.org/4123
20:16:29 <ddarius> chessguy: Not in an interesting way.
20:16:50 <chessguy> hm. i'm trying to figure out what "cont" is
20:19:02 <ddarius> chessguy: It is a continuation, you just aren't using it in any interesting way in that particular code.  Also, that function is not in CPS itself (kind of)
20:19:24 <chessguy> it's not my code
20:19:34 <chessguy> so it's a continuation, but not CPS
20:19:49 <chessguy> (i didn't realize there was a distinction)
20:20:08 <ddarius> chessguy: Continuations are things, CPS is a style.
20:20:24 <ddarius> cont is a continuation.  The function isn't (fully) in CPS.
20:20:28 <chessguy> yeah, i thought the style was just using the things :)
20:20:37 <chessguy> ok
20:21:22 <Korollary> goalieca: pp goal
20:21:31 <goalieca> Korollary, kessler.. pssh
20:21:43 <Korollary> goalieca: Kessler got whacked
20:22:20 <Korollary> Pronger is such a nice guy
20:22:28 <goalieca> i hate kessler
20:23:22 <dobblego> is there a type-class that generalises Data.Map?
20:23:28 <dons> does anyone know of a console tool for playing audio streams off the net?
20:23:37 <Korollary> dons: mplayer should do
20:23:39 <dons> we have mplayer, but i'd like something like snownews or mutt
20:23:56 <dons> where i can list all the common srcs i listen to, and choose between them
20:24:10 <dons> maybe some podcast stuff will work
20:24:23 <Korollary> dons: if you head over to freshmeat or sf.net, I bet you'd find console based players that play streams
20:24:27 <dons> i'm listening to a lot of internet radio atm
20:24:31 <dons> ok.
20:24:52 <hpaste>  dibblego pasted "something like this?" at http://hpaste.org/4124
20:25:00 <gwern> anyone know of any Haskell shells? I know of hashell, but that seems to require hs-plugins
20:25:02 <Korollary> dons: does it have to be a console app?
20:25:14 <dons> not really, though that's preferred
20:25:19 <goalieca> ddarius, hmm. do the constructors actually slow things down
20:25:24 <dons> gwern: there's no serious contenders
20:25:38 <gwern> my rule of thumb is that whenever I want to listen to something, either Amarok or MPlayer can do it
20:25:49 <gwern> I suspect amarok can handle all your radio needs, imo
20:25:50 <ddarius> goalieca: They shouldn't.
20:25:51 <dons> i use mplayer currently, and shell aliases
20:26:16 <dons> amarok eh?
20:26:23 <gwern> dons: oh. that's a pity. is there any research even on shells for strongly & staticly typed  languages?
20:26:35 <dons> yeah, there's been some
20:26:45 <dons> since most errors in shell code are type errors :)
20:26:55 <dobblego> have you tried VLC player? it's much nicer than Amarok and MPlayer (more compatible and less buggy)
20:27:24 <gwern> dons: yeah. for a KDE based sort of app, amarok doesn't have too ridiculously many dependencies
20:28:08 <gwern> dons: well, I personally find most of my shell errors are things like 'sort tmp | uniq > tmp', which would take a bit of type hackery to fix, I suspect
20:28:36 <goalieca> Korollary, :-)
20:29:07 <Korollary> goalieca: subtle redirect
20:31:40 <sclv> dibblego: have you looked at collections and edison on hackage?
20:31:59 <dobblego> sclv, nope
20:32:30 <davidL> dons: you should add support for streams to hmp3, maybe add flac support while your at it :-)
20:32:37 <sclv> they're replacement collections libraries that both define, as i recall, classes via which one can access the various collections they provide.
20:33:09 <dobblego> ah thanks
20:33:55 <dons> davidL: yeah, we need abstract backend support
20:34:07 <dons> its a great little mp3 player, but too monomorphic :)
20:34:50 <dobblego> "too monomorphic" - I think I will use that one in the future :)
20:37:32 <dons> forall . Audio a => Hmp a  -- should hold
20:37:42 <dons> currently though, we only have instance Audio MP3
20:37:53 <dobblego> Hmp?
20:37:54 <dons> and even then, only locally,
20:37:57 <dons> ?where hmp3
20:37:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
20:38:12 <dobblego> ah
20:39:28 <dons> to think that there was a time we didn't write window managers and mp3 players and revision control systems
20:40:51 <dons> so who's going to write what next?
20:40:56 <dons> where's the next big thing?
20:41:06 <dons> ddarius: 'bout time you released some code!
20:42:12 <dons> so is there a way to do deepSeq in the parallel strategies strategies?
20:43:39 <dons> rnf
20:43:49 <ddarius> dons: I actually, in conjuction with Philippa, might be releasing someone else's code.
20:44:02 <ivanm> dons: so what do you use for your blogging engine?
20:44:08 <ddarius> dons: I have a very small binding I can finish packaging.
20:44:19 <dons> great, ddarius
20:44:35 <dons> is it smaller than http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nano-md5-0.1
20:44:36 <lambdabot> http://tinyurl.com/24u69z
20:44:38 <goalieca> hmm. constructors are slower than tuple.
20:44:46 * dons hopes to claim title for smallest hackage package
20:44:48 <goalieca> so Planet x y z is slower than (x,y,z)
20:45:07 <ddarius> dons: No.
20:45:13 <goalieca> literally 2x as slow from what i'm finding
20:45:14 <dons> Planet !x !y !z  -funbox-strict-fields, goalieca ?
20:45:18 <hpaste>  cbrad pasted "(no title)" at http://hpaste.org/4125
20:45:28 <dons> goalieca: they should be identical, assuming you need strictness
20:45:36 <ddarius> The thing that kept me from releasing it a while ago is figuring out the correct way to package the C with it.
20:45:47 <oerjan> um tuples are not strict
20:45:49 <ddarius> Or rather not feeling like doing said figuring out.
20:46:14 <cbrad> I would like to add two arrays of Ints efficiently, but struggling
20:46:33 <ddarius> There's some other code I can write that also would be pretty small but useful.
20:46:38 <ddarius> I should do it before I get scooped.
20:46:45 <oerjan> oh, wait
20:46:53 <cbrad> I am using an STUArray as in http://hpaste.org/4125
20:47:14 <cbrad> As soon as I try and access another array, ghc complains
20:47:17 <oerjan> er, yes.  so tuples and non-strict data should _really_ already be identical.
20:47:48 <goalieca> well strict data is running slower by 2x
20:48:09 <goalieca> but only for Planets, and not Bodies
20:48:28 <davidL> is this for a benchmark?
20:49:16 <cbrad> davidL: who?
20:49:18 <ddarius> cbrad: Depending on what you mean, that sounds like what it is supposed to do.
20:49:19 <Nafai> Man, compiling ghc takes a while :)
20:49:22 <oerjan> goalieca: are there other constructors than Planet in the data type?  that might explain it since tuples don't need to check which one you use
20:49:43 <goalieca> Planet contains vector..
20:49:48 <cbrad> ddarius: so I don't understand how to do it properly :-)
20:49:57 <davidL> for goalieca, but nevermind, it's the n-body benchmark on that gentoo site
20:50:08 <ddarius> cbrad: Maybe.  What do you mean by "GHC complains"?
20:50:28 <cbrad> ddarius: Could not deduce (MArray a t (ST s)) from the context ()
20:50:31 <goalieca> davidL, actually it is debian.. and i'm doing this to learn. i plan on writting scientific code in haskell next semester
20:50:33 <oerjan> goalieca: i mean, is it data Planet = Planet x y z, with nothing else?
20:50:40 <cbrad> ddarius: arising from a use of `readArray'
20:50:42 <goalieca> but my best effort is within 2x of the ghc one on the site
20:50:51 <oerjan> er not quite that
20:50:55 <goalieca> oerjan, data Planet = P {pPos, pVel:: !V, pMass :: !Double}
20:51:02 <goalieca> V is a vector type
20:51:39 <oerjan> goalieca: so was it already strict or did you add strictness _after_ you found out it was slower than tuples
20:51:52 <goalieca> it was already strict
20:51:52 <ddarius> :t runSTUArray
20:51:53 <lambdabot> Not in scope: `runSTUArray'
20:51:59 <ddarius> @index runSTUArray
20:52:00 <lambdabot> Data.Array.ST
20:52:00 <oerjan> ok then it makes more sense
20:52:04 <goalieca> this entire program doesn't need lazyness
20:52:07 <ddarius> :t Data.Array.ST.runSTUArray
20:52:08 <lambdabot> forall i e. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
20:52:24 <ddarius> @index readArray
20:52:24 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
20:52:31 <ddarius> :t Data.Array.MArray.readArray
20:52:32 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Ix i, Data.Array.Base.MArray a e m) => a i e -> i -> m e
20:52:46 <ddarius> Oh, duh.
20:54:22 <Nafai> Yay, it's done!
20:55:46 <dons> there's usually a path between full strictness, and full laziness, that gives  an optimal reduction order
20:56:39 <notsmack> dons: any good rules of thumb for that?
20:57:07 <skew> produce small values strictly, large ones lazily
20:57:35 <dons> yeah
20:57:37 <notsmack> skew: makes sense
20:57:44 <dons> things you don't necessarily use, lazy
20:57:57 <goalieca> well i'll play around with that. right now my code is 2x slow as the ghc one in the benchmark. And i'm quite happy with it.
20:57:58 <notsmack> small in size or effort?
20:58:12 <skew> small as in size in memory
20:58:13 <skew> like integers
20:58:23 <dons> well done, goalieca
20:58:57 <ddarius> cbrad: I'd have to play with it to figure it out.  I remember having a the damndest time making the compiler happy in one of these cases.  Namely processArray in http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
20:58:58 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
20:59:17 <cbrad> ddarius: thanks for taking a look
21:00:06 <skew> "pasted into ghci"?
21:00:17 <goalieca> well.. it is still about 4x slower than the cpp version.
21:00:31 <skew> Woo preprocessor abuse!
21:00:36 <ddarius> cbrad: Just play around with it and try to give types to things.
21:00:43 <skew> or was that a C++ version?
21:00:55 <goltrpoat> can someone point me towards a survey on compilation via CPS?  (got appel's book on order)
21:01:05 <thetallguy> How bizarre.  Futurama turns out to be an anagram of Futamura.
21:01:40 <skew> goltrpoat: I'm also looking for something on compilation by CPS, but a bit more specific
21:01:50 <scook0> thetallguy: quite easy to confuse the two when skimming :)
21:01:54 <goltrpoat> thetallguy:  futurama projection? :)
21:02:01 <ddarius> thedward: Yeah, I read that as futumura at first.
21:02:22 <ddarius> goltrpoat: There was a good recent paper about that (not a survey though)
21:02:23 <thetallguy> Apparently, sigfpe did just that.  He read my blog all excited about the Futamura projection.
21:02:34 <skew> I remember seeing a paper where they passed around contiuations mostly as jump targets in code generation, to make tigheter code, avoid jumping straight to other jumps, etc
21:03:09 <thetallguy> I'd forgotten all about the Futamura projection.
21:03:38 <ddarius> thetallguy: How do you forget about the Futamura projection?!
21:03:58 <dons> heh, poor sigfpe
21:04:21 * oerjan wants someone to tell him in one line what the Futamura projection is.
21:04:33 <dons> there was a blog recently about it
21:04:35 <dons> hmm.
21:04:37 <ddarius> oerjan: There are actually three of them.
21:04:44 <dons> in some pseudo-haskell
21:04:58 <dons> http://www.cubiclemuses.com/cm/blog/archives/000419.html
21:05:10 <lambdabot> Title: The Secret Art of Futamura Projection :: Cubicle Muses
21:07:11 <thetallguy> ddarius:  No excuse for it, I know.
21:09:00 <ddarius> oerjan: Let P be a partial evaluator, I an interpreter, and C a compiler. P(I) = C
21:09:11 <ddarius> That's the first Futamura projection.
21:12:59 <ddarius> Actually I jacked that some.
21:13:11 <Pseudonym> I read that as "Futurama" for some reason.
21:13:30 <thetallguy> Pseudonym: see above
21:13:39 <thetallguy> that's how all this got started.
21:13:40 * Pseudonym sees above
21:13:42 <Pseudonym> Aha.
21:14:10 * ddarius needs to focus on some one thing.
21:15:01 <goltrpoat> ddarius:  the only recent one i've seen was "compiling with continuations, continued"
21:15:20 <ddarius> Oh yeah, I was supposed to look that up.  Yeah, I think that's it.
21:15:39 <goltrpoat> which was a good paper, but somewhat tangential to what i was looking for
21:19:53 <hpaste>  skew pasted "inlining problem" at http://hpaste.org/4126
21:20:24 <skew> I've got this code that inlines nicely in one module, but not if it's split
21:20:35 <skew> even with pragmas, even though everything is included in the headers
21:21:01 <dons> skew, that could be a bug report.
21:21:13 <dons> there's real problems with inlining across modules/packages, that we need to nail down
21:21:18 <ddarius> goltrpoat: Many papers on SML implementation are useful.  readscheme's page should have some useful stuff.  Heck, Steele's thesis is a great read.
21:21:29 <dons> skew, so even with {-# INLINE #-} and -O2 ?
21:21:32 <skew> I should try it on 6.8 then
21:21:39 <dons> recursive things won't inline, of course
21:21:41 <skew> yeah
21:21:59 <dons> yes, oh, definitely try on 6.8
21:22:02 <dons> since the inliner is fixed a lot
21:22:07 <dons> or are  you on the  head branch
21:22:15 <goltrpoat> ddarius:  the RABBIT one?  yeah, ive been reading that
21:22:32 <skew> I checked it a lot with 6.6.1
21:22:41 <skew> That
21:23:12 <skew> That's where I actually read core and so on
21:24:05 <dons> yeah, 6.6 has problems in this area.
21:24:14 <dons> you need to try 6.8, hopefully it works. if it doesn't, bug report
21:25:21 <skew> just as soon as I put in my XO order, and see if Linux likes my new monitor as well as Windows...
21:25:51 <ddarius> goltrpoat: This http://library.readscheme.org/page6.html and http://library.readscheme.org/page8.html this should have some stuff.  As well as a bunch of other interesting stuff.
21:26:23 <goltrpoat> ddarius:  i was bored over the weekend, so i wrote a toy scheme interpreter in c++ (yes, REALLY bored).  with a native garbage collector.  i ended up with this template-based pattern matcher that made writing small-step semantics really simple.  added define-syntax on sunday and realized it was actually running fairly big programs
21:26:32 <goltrpoat> so i figured i should make it compile to something or other.
21:27:34 <goltrpoat> trouble is, the only things ive compiled to, are g-machine, and x86 assembly from imperative code.  i understand how compilation via CPS works, but all i know about optimization from that point on are SSA-like tricks and inlining via beta reduction
21:27:41 <ddarius> goltrpoat: Interested at all in register allocation?
21:27:59 <ddarius> goltrpoat: Check out Shiver's work.
21:28:05 <goltrpoat> olin shiver?
21:28:14 <skew> shivers, I think
21:28:20 <ddarius> Yeah, misplaced '
21:28:24 <skew> and his student matt might
21:28:42 <skew> I was finally coding up Gamma CFA, before I got a copy of Coq
21:28:48 <skew> Coq'Art
21:28:49 <goltrpoat> i actually have a paper of might's open right now :)
21:29:03 <ddarius> goltrpoat: Read Olin Shivers' thesis.
21:29:14 <skew> but basic compilation is a bit prior to the fancy control flow analysis
21:29:19 <goltrpoat> readscheme is great btw.
21:29:26 <ddarius> goltrpoat: Indeed it is.
21:30:52 <goltrpoat> "Control-Flow Analysis of Higher-Order Languages" ?
21:31:09 <ddarius> That should be it.
21:31:16 <goltrpoat> cool, thanks a lot.
21:31:23 <dons> http://www.brics.dk/~barnie/RealLib/
21:31:24 <lambdabot> Title:
21:31:29 <dons> someone picked the wrong language :(
21:32:46 <hypomnema> does anyone have sample code of binary I/O?  I've got a variable-length [CUChar] that i want to output to h <- openBinaryFile "/tmp/foo" WriteMode
21:33:13 <hypomnema> the whole getting-to-Ptr thing confounds me (excellent reference documentation, total lack of usable examples as far as i can tell)
21:34:36 <ddarius> goltrpoat: "Optimizing Nested Loops using Local CPS Conversion" might be interesting.
21:35:02 <dons> oh, just use Data.Binary, hypomnema
21:35:38 <dons> maybe just pack it into a bytestring, since you're writing a list
21:35:41 <dons> then write that
21:36:00 <ddarius> "A Continuation Passing Style for Prolog" This should be interesting.
21:36:01 <hypomnema> i honestly cannot figure out how to pack a char list into a bytestring
21:36:09 <ddarius> pack
21:36:19 <dons> these are bytes, are they? CUChars?
21:36:33 <dons> :t Data.ByteString.Char8.pack
21:36:34 <lambdabot> String -> Data.ByteString.Base.ByteString
21:36:40 <zanedo> I'm newbie so trying study with tutorial, but GHC return "Parser error on input '='". Is there anyone know what is wrong?
21:36:51 <dons> :t Data.ByteString.pack
21:36:52 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
21:36:53 <hypomnema> yeah, it's actually binary data
21:37:19 <hypomnema> err, i misspoke, not a char list, a CUChar/Word8/etc list
21:37:19 <oerjan> zanedo: need to see the surrounding parts
21:37:23 <dons> ok, usually i use Data.Binary for binary data, or bytestrings (not lists!). but anyway, you can pack those bytes into bytestrings as above.
21:37:24 <oerjan> !paste
21:37:24 <hpaste> Haskell paste bin: http://hpaste.org/
21:37:31 <dons> perhaps just use Word8, and then Data.ByteString.pack
21:37:41 <dons> then Data.ByteString.writeFile foo str
21:38:04 <oerjan> zanedo: actually one possibility, are you trying to paste tutorial code into the interpreter?  often you need to put it in a file and load it
21:38:12 <dons> how's that, hypomnema. do you have a path to proceed on?
21:38:25 <hypomnema> dons: it looks like Data.ByteString.pack works on null-terminated data, though
21:38:31 <zanedo> oerjan: wait a minutes, thx
21:38:32 <oerjan> because the ghci syntax is not the same as module top level syntax
21:38:36 <dons> staying in Bytestrings and Data.Binary (which i guess you've not seen yet), is probably best for performance.
21:39:13 <hypomnema> dons: yeah, i think i have to rework my code a little here.  i'm trying to turn a list of bits (toy huffman implementation) into a file
21:39:26 <glguy> ?seen dons
21:39:26 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 50s ago.
21:39:33 <dons> ?saw glguy
21:39:33 <lambdabot> Maybe you meant: faq map show slap src yow
21:39:48 <dons> hypomnema: convert the bits to a list of Word8, pack them
21:39:58 <dons> 0 bytes shouldn't matter, should they?
21:40:05 <glguy> heh
21:40:06 <zanedo> oerjan: It's just simple. "a = 3" and "f x = x + 1"
21:40:24 <hpaste>  goalieca annotated "nbody -- pure functional" with "my best version. I learned a lot. thanks!" at http://hpaste.org/4122#a6
21:40:27 <oerjan> zanedo: yep that sounds like the difference between ghci and module syntax.
21:40:29 <hypomnema> dons: that answer makes me very happy, since it's the least rework.  hopefully NUL doesn't break =)
21:40:39 <dons> Data.ByteString doesn't care about null
21:41:01 <oerjan> in that case you can just prepend "let" and still use ghci, but that won't work for all declarations
21:41:16 * dmwit makes a note in his stalker file: goalieca=Ryan Dickie
21:41:25 <oerjan> put it in a File.hs or something, and load with :l File
21:41:45 <zanedo> bobwhoops: I need to RTFM more. oerjan, thanks.
21:43:00 <goalieca> dmwit, google found my home phone number.. and that isn't posted anywhere. that scares me
21:43:23 <dmwit> yikes!
21:43:56 <goalieca> dmwit, and there are a lot of Ryan Dickies, who also live in canada, who also played goalie, and are also my same age
21:43:58 <monochrom> Google is googling you!
21:44:05 <davidL> what placeholder goes in printf for [Int]?
21:44:10 <goalieca> google is creepy sometimes. i wonder what kind of skynet they got going on
21:44:20 <goalieca> davidL, a list of Ints?
21:44:22 <monochrom> I don't think there is one for [Int]
21:44:24 <goalieca> none
21:44:28 <ddarius> goalieca: It's called myspace (and co.)
21:44:42 <goalieca> davidL, usually you build a string yourself
21:44:49 <goalieca> with a whole lot of %d
21:44:59 <dmwit> unwords . map show
21:45:06 <davidL> ohhh, nice
21:45:11 <dmwit> Or just "show" is good.
21:45:14 <davidL> thanks
21:45:15 <dmwit> > show [3,4,5,6]
21:45:24 <lambdabot>  "[3,4,5,6]"
21:45:25 <skew> why doesn't show trim infinite values?
21:45:35 <ddarius> skew: Why should it?
21:45:36 <dmwit> eh?
21:45:42 <goalieca> ddarius, i have never purchased online
21:45:48 <goalieca> or post it anywhere. i don't use myspace
21:45:54 <ddarius> goalieca: -You- don't.
21:45:57 <skew> well, we ought to have some pretty printing system that does
21:46:01 <skew> for ghci, if nothing else
21:46:08 <dmwit> skew: What are you on about?
21:46:09 <ddarius> skew: Perhaps, but Show isn't it.
21:46:13 <TSC> take 100 . show
21:46:17 <TSC> There you go
21:46:24 <oerjan> skew: take will usually work
21:46:28 <dmwit> skew: How do you detect infinite values to trim, anyway?
21:46:47 <skew> crude heuristics like "only go 100 constructors deep"
21:47:06 <skew> I'm sure you've seen repls with nice pretty printers
21:47:16 <oerjan> skew: lambdabot just cuts off the resulting string if it's too long
21:47:24 <monochrom> I will hate such a "feature" which is really a bug.
21:47:37 <oerjan> > 11^200
21:47:39 <lambdabot>  1899052764604618242121820463954116340585832240009877848127251456103762646167...
21:47:55 <davidL> @more
21:48:10 <monochrom> If ghci implements that suggestion, I'll file a bug report.
21:48:28 <oerjan> monochrom: i recall reading that Vital/Pivotal cleverly just calculated the part that fit in the window
21:49:11 <ddarius> oerjan: That could come as just a side effect of normal lazy evaluation if done properly.
21:49:11 <dmwit> oerjan: Yes, but it also gives a scroll bar.
21:49:14 <oerjan> if ghci had a gui it could use scrollbars and something similar
21:49:16 <monochrom> That's laziness, which is good, and compliant with infinite data.
21:49:21 <skew> simply trimming the string doesn't work so well on things like trees
21:49:35 <skew> e.g, if the left branch is infinite
21:49:59 <dmwit> skew: class ShortShow where ... ;-)
21:50:06 <skew> and you'd rather see structure near the top than Node (Node (Node (Node (Node ... (type "@more to see more")
21:50:33 <skew> heck, even lambdabot's behaviour would be an improvement when you've done something like t <- readFile "gigabytes_of_logs"
21:51:08 <TSC> I think there's an option not to show the value of monadic binds like that
21:51:13 <monochrom> I don't want ghci to be a smartass making those decisions for me. If I want deep subtrees elided, I want to write my own pretty printer to do exactly that. I don't want ghci to do that.
21:51:17 <ddarius> TSC: There is.
21:51:26 <monochrom> I want ghci to do what I write, not what I mean.
21:51:28 <skew> yeah, -fno-print-bind-results
21:51:44 <skew> monochrom: so you'd be violently opposed to adding a standard pretty-printing class?
21:51:49 <monochrom> That's what programming is about. Do what I write, not what I mean.
21:52:02 <skew> and having ghci use that with sensible defaults rather than plain Show?
21:52:06 <dmwit> skew: I don't think he'd be against that.
21:52:08 <hypomnema> dons: sigh.  Couldn't match expected type `Char' against inferred type `Word8'
21:52:20 <dmwit> I think he'd be against making ghci use the pretty printer by default, rather than Show.
21:52:34 <monochrom> What is sensible defaults? I think this proposal is insensible already.
21:52:39 <hypomnema> dons: however, i think i can retrofit this code to use Char without too much hassle (Char doesn't implement Bits ?!  silly unicode...)
21:52:41 <dons> hypomnema: import Data.ByteString.pack or Data.ByteString.Char8.pack
21:52:44 <dons> depending on what you want
21:52:56 <dons> use Data.ByteString.pack if you're in Word8 form
21:53:04 <hypomnema> dons: ah, okay.  huzzah!
21:53:10 <dons> use Data.ByteString.Char8.pack if you're in Char form, and happy to be truncated to Word8
21:53:52 <hypomnema> side note: is there a better way to test this stuff than editing a file in one window and :reload in ghci in another?
21:54:08 <mwc_> what's a good way to keep up to date on the latest updates to hackage?
21:54:53 <davidL> > show ([1,2,3] :: [Word8])
21:54:54 <lambdabot>  "[1,2,3]"
21:54:58 <skew> monochrom: you seem to formatting values for one infinitely long line. I think Text.PrettyPrint.HughesPJ.style is pretty decent
21:56:50 <skew> and printing an infinite value out as "here's the result of your operation" rather than when you specifically use print or putStr(Ln) is not a reasonable default - especially when bindings are canceled when you interrupt the printing
22:00:20 <ozone> was someone looking for me?
22:00:29 <ozone> oh, nevermind
22:03:37 <monochrom> OK, just don't touch "deriving Show".
22:04:47 <goltrpoat> :t readFile
22:04:48 <lambdabot> FilePath -> IO String
22:04:53 <goltrpoat> sort of obvious what you're getting there, isn't it
22:05:28 <davidL> what's the easiest way to go from Word8 to Char?
22:06:30 <Olathe> > chr $ fromIntegral (5::Word8)
22:06:31 <lambdabot>  '\ENQ'
22:06:38 <goltrpoat> chr . fromEnum?
22:06:48 <goltrpoat> or that
22:06:53 <davidL> ah thanks
22:21:00 <dobblego> when write quickcheck, do you write conjunctive expressions or use a new property each time or a combination of both?
22:21:22 <dobblego> check p && q or check p; check q
22:23:46 <Heffalump> a combination of both, but erring on the side of the latter
22:24:11 <dobblego> yeah, that's exactly what I do
22:24:13 <dobblego> cheers
22:28:51 <dfranke> gah! I can't use forkProcess with +RTS -N >1?
22:28:54 <dfranke> That sucks :-(
22:30:11 <dons> dfranke: really?
22:30:16 <monochrom> This is why it is futile to count axioms or properties or theorems.
22:30:18 <dons> that's just unix execve
22:30:37 <skew> ok, it at least looks like 6.8.1 produces the same results with everything in one module
22:30:39 <monochrom> In practice, organize as you see fit.
22:30:54 <dobblego> monochrom, referring to me?
22:31:02 <hypomnema> dons: while looking at the ByteString doco, i glanced up at the url and a light went on.  Thanks for the library, and help using it =)
22:31:06 <dfranke> dons: try it.
22:31:22 <dfranke> dons: it dies with an error saying it's unsupported.
22:32:51 <sjanssen> dfranke: threads+fork == death
22:33:49 <dons> ah yes, it does sound pretty scary
22:34:00 <dons> forkOS perhaps, and run something over there
22:34:08 <dons> there's probably someway to do it
22:34:18 <dons> runProcess
22:34:30 <sjanssen> IIRC, the System.Process stuff still works
22:35:24 <sjanssen> dfranke: what did you plan to do after forkProcess?
22:35:27 <hypomnema> half-ignorant comment: forking within a pthread creates a copy of only the running thread, which might conflict with the GC stuff?
22:35:45 <dfranke> sjanssen: connect a bunch of pipes and then execFile
22:35:59 <sjanssen> note that the docs say that exec immediately after forkProcess is the only thing guaranteed to work
22:36:31 <dfranke> sjanssen: not necessarily limited to [ std ++ x | x <- [in,out,err] ]
22:37:51 <dfranke> I can hack around this with a helper binary and FIFOs in /tmp, but... yuck.
22:38:49 <skew> dons: still not inlining
22:39:07 <skew> and all the definitions are small and non-recursive, and exported in the .hi even without the pragmas
22:40:27 <skew> whoa, show-iface no longer gives implementations, after adding INLINE pragmas!
22:40:38 <skew> with 6.6.1 it just wrapped __inline_me or something around the code
22:42:48 <dfranke> is there a quick way for a program to check whether it's using the threaded runtime?
22:42:57 <skew> seems like building with --make may confuse things
22:43:09 <skew> dfranke: yes, some "constant"
22:44:06 <skew> nm, I was thinking of rtsSupportsBoundThreads
22:44:27 <goalieca> is there a reason why we need -threaded off by default
22:44:41 <dons> skew, hmm. this sounds very wrong
22:44:48 <dons> skew, is it a small test case?
22:44:55 <dons> and you've got -O cranked up?
22:44:59 <skew> yeah, did you see the paste?
22:45:00 <skew> -O2
22:45:04 <dons> nope?
22:45:10 <dfranke> anyway, I guess the plan is to have three versions of this procedure:
22:45:21 <skew> hmm, that was in my computer's previous life.
22:45:31 <dfranke> 1. One that uses runProcess, used if the only Fds in the pipe are 0,1,2.
22:45:51 <skew> http://hpaste.org/4126
22:45:53 <dfranke> 2. One that uses forkProcess, used only if it won't fail.
22:46:01 <skew> nef logs to the rescue
22:46:04 <dfranke> 3. One that uses FIFOs in /tmp, as a last resort.
22:46:11 <jsnx> > let op_0 = (+)
22:46:11 <lambdabot>  Parse error at end of input
22:46:20 <skew> dfranke: how about a little bit of C?
22:46:25 <jsnx> it works in ghci...
22:46:36 <dfranke> but I need to be able to detect if forkProcess is going to fail.
22:46:44 <skew> jsnx: ghci syntax is like the inside of a do block
22:46:52 <jsnx> > op_0 = (+)
22:46:53 <lambdabot>  Parse error at "=" (column 6)
22:46:57 <skew> just op_0 = (+) at top level
22:47:06 <jsnx> okay, i give up
22:47:21 <skew> it's kinda weird
22:47:28 <skew> main problem is no declaration order in files
22:47:33 <dfranke> I'm not sure op_0 is a valid identifier.
22:47:43 <jsnx> dfranke: really?
22:47:54 <dfranke> try:
22:47:54 <jsnx> > op0 = (+)
22:47:54 <lambdabot>  Parse error at "=" (column 5)
22:48:04 <skew> sure it is, "let op_0 = (+)" works fine in ghci
22:48:09 <jsnx> well, it works in ghci
22:48:25 <jsnx> > pr0n = (+)
22:48:25 <lambdabot>  Parse error at "=" (column 6)
22:48:31 <skew> I think lambdabot only takes complete expressions
22:48:35 <jsnx> foo = (+)
22:48:41 <jsnx> hmm
22:48:43 <jsnx> okay
22:48:47 <dfranke> @let op_0 = (+)
22:48:50 <lambdabot> Defined.
22:48:55 <dfranke> there you go
22:49:03 <jsnx> > help
22:49:07 <dons> ?help
22:49:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:49:13 <lambdabot>   Not in scope: `help'
22:49:29 <jsnx> so, how do we get the type of the above binding?
22:50:15 <dfranke> I guess the good news about all these headaches is that if I can abstract them away, I've built something really useful.
22:50:38 <quicksilver> jsnx: you can do this
22:50:47 <quicksilver> :t let op_0 = (+) in op_0
22:50:48 <lambdabot> forall a. (Num a) => a -> a -> a
22:51:11 <jsnx> okay, that's weird
22:51:25 <jsnx> because in ghci, it's Integer -> Integer -> Integer
22:51:30 <jsnx> which is why I am here
22:51:57 <jsnx> as i would like it be (Num a) => a -> a -> a
22:52:00 <quicksilver> jsnx: let bindings in a do block are subject to defaulting
22:52:12 <jsnx> oh
22:52:14 <quicksilver> and ghci is like a do block
22:52:19 <jsnx> right
22:52:59 <quicksilver> you should be able to do
22:53:12 <jsnx> figured it out
22:53:14 <quicksilver> let op_0 :: Num a => a -> a -> a ; op_0 = (+)
22:53:16 <quicksilver> I thinkg
22:53:35 <jsnx> let op_0::(Num a) => a -> a -> a = (+)
22:53:38 <skew> dons: I think this is it 8.13.5 "INLINE prevents any inlining happening in the RHS of the INLINE thing"
22:53:39 <jsnx> works
22:53:42 <skew> perhaps
22:54:30 <skew> now that I individually invoked ghc -O2 -c on each file I see some inlining, and I'm still untangling the Core
22:55:40 <glguy> Is there a command like "time" that tells you how much memory an application used at peak?
22:56:12 <skew> GHC profiling
22:56:16 <xpika> hello, I'm trying to program a vector graphics editor in haskell, but there are so many IORefs being passed it seem as if they are coming out of my ears.
22:56:20 <xpika> @paste
22:56:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:56:31 <ddarius> xpika: Then don't use IORefs.
22:56:54 <skew> glguy: I think valgrind has a mode where it spits out a GHC-format heap profile
22:57:00 <dons> skew hmm :(
22:57:18 <dons> skew, i'm pretty sure we rely on this in the stream-fusion lib too
22:57:29 <dons> maybe not
22:57:40 <dons> does that help you though?
22:57:47 <skew> well, it looks like the main loop came out ok this time around
22:57:59 <hpaste>  (anonymous) pasted "IORefs too many :(" at http://hpaste.org/4127
22:58:00 <skew> although the stuff around the edges and the final printing is definitely not the same
22:58:13 <skew> in one module f1 and f2 compile to alpha-equivalent core
22:58:25 <skew> I wonder if I just need to run the simplifier for more iterations
22:58:54 <slava> http://www.flickr.com/photo_zoom.gne?id=383068155&size=o
22:58:55 <lambdabot> Title: Flickr Photo Download: He's as country as cornflakes.
22:59:28 * glguy wonders why Apple picked the crappiest version of top(1) to include
22:59:40 <dons> skew, that could be
22:59:49 <dons> skew, there's a flag in 6.8 for this, to keep the simplifier iteratoins running
23:00:24 <skew> I think it's been around longer - or I've just had the beta 6.8 docs installed locally for a long time
23:00:33 <glguy> slava: huzzah!
23:02:25 <sclv> Man walks into a doctor's office and says "doc -- every time I poke my right index finger into my left elbow like so it hurts like crazy." doc says: "well, don't do that then."
23:02:26 <dfranke> well, crud.  Here's the RTS code that throws the error:
23:02:30 <dfranke> #if defined(THREADED_RTS)
23:02:30 <dfranke>     if (RtsFlags.ParFlags.nNodes > 1) {
23:02:30 <dfranke>         errorBelch("forking not supported with +RTS -N<n> greater than 1");
23:02:30 <dfranke>         stg_exit(EXIT_FAILURE);
23:02:30 <dfranke>     }
23:02:33 <dfranke> #endif
23:02:35 <skew> -fmax-simplifier-iterations=100 changed nothing
23:02:57 <skew> I guess there's no convenient way to make it hash-cons Core?
23:02:58 <dfranke> how the heck am I supposed to interface to that when it might not even be defined?
23:04:04 <xpika> I don't see how stateT will get me out of the mess in  http://hpaste.org/4127
23:05:47 <shapr> @yow !
23:05:48 <lambdabot> Is a tattoo real, like a curb or a battleship?  Or are we suffering in Safeway?
23:06:07 <glguy> dons: what value was that problem I showed you giving?
23:07:04 <sclv> xpika: seriously. create a data structure containing your state and either run in the state monad or pass it around explicitly.
23:08:43 <quicksilver> xpika: the general rule I use is "Never pass an IORef"
23:08:57 <dons> that's a good rule.
23:09:03 <dons> closely followed by never use an IORef
23:09:08 <dons> 52852124
23:09:11 <quicksilver> xpika: passing an IORef is a really weak kind of type guarantee, and it leads to imperative-style programs.
23:09:12 <dons> glguy:
23:09:27 <glguy> dons: I think that it overflows in the 32-bit version :)
23:09:28 <quicksilver> dons: you have to for IO () callbacks, unfortunately.
23:09:37 <dons> glguy: ah
23:09:38 <quicksilver> dons: but you try to minimise the scope
23:09:41 <glguy> dons: in fact, switching to Integer on ppc-32bit
23:09:42 <dons> quicksilver: yeah, that's true
23:09:44 <jsnx> lolz
23:09:46 <glguy> fixed my glitch
23:10:03 <dons> Word64?
23:10:15 <glguy> need to handle negative values
23:10:54 <sjanssen> Int64?
23:11:08 <glguy> on 32-bit, would Integer be faster or slower whne most of the values fit in an Int32?
23:11:18 <sjanssen> glguy: Integer would probably be faster
23:11:37 <glguy> ?index Int64
23:11:37 <lambdabot> Data.Int, Foreign
23:11:38 <jsnx> sjanssen: why is that?
23:11:41 <sjanssen> GHC does 64 bit operations very poorly on 32 bit platforms
23:11:43 <quicksilver> xpika: it would be easier to follow your code with type annotations, but :) i would make types like MouseStte -> IO DragState
23:12:00 <quicksilver> xpika: which makes it explicit that that action reads the mousestate and writes the drag state
23:12:23 <waern> xpika: maybe you can use this: http://www-users.cs.york.ac.uk/~ndm/proplang/
23:12:24 <lambdabot> Title: Neil Mitchell - PropLang
23:12:30 <glguy> sjanssen: in my case, Int64 was > 2x faster
23:12:38 <glguy> (os x , ppc , 32 bit)
23:12:47 <sjanssen> oh, interesting
23:13:03 <sjanssen> Int64 will unbox, which can make a difference
23:13:11 <glguy> 20sec vs 17 sec with Ine32
23:13:17 <glguy> (which provide the wrong answer, however)
23:13:26 <enderbean> Hello, I am just starting out with Haskell and don't understand how to address a type error (I think its caused by trying to divide an integral). Do I need to declare an explicit type that is an instance of both classes or something else?
23:13:32 <glguy> damn, my fingers are slipping up all over
23:13:36 <quicksilver> enderbean: use div for integers
23:13:41 <quicksilver> enderbean: / is for fractionals
23:13:50 <jsnx> glguy: what was that supposed to be?
23:13:50 <glguy> > 3 `div` 2
23:13:53 <lambdabot>  1
23:14:04 <glguy> Int32
23:14:12 <glguy> and provided
23:14:15 <jsnx> enderbean: uhm, well, not necessarily
23:14:21 <enderbean> Thanks..
23:14:31 <quicksilver> xpika: as a minor point, toggleRef is just \r -> modifyIORef r not
23:14:35 <jsnx> what is the error, exactly?
23:15:03 <quicksilver> xpika: a.k.a. flip modifyIORef not, but I'm not a fan of flip
23:15:16 <jsnx> you should check to see that everything in between your start and end has the type that you want
23:15:26 <jsnx> in some cases, the default is surprising
23:15:27 <dobblego> xpika, what would you suggest instead?
23:15:36 <dobblego> er , quicksilver
23:16:13 <enderbean> Ambiguous type variable a in the constraints: Integral a arising from use of divisibleBy(based on mod) at ... Fractional a arising from use of / ...
23:16:27 <waern> dobblego: judging from his example, lambda abstraction
23:16:29 <jsnx> enderbean: aha
23:17:03 <jsnx> did you assign an explicit type signature to divisibleBy?
23:17:09 <jsnx> that might help
23:17:26 <enderbean> jsnx: I haven't written any explicit type signatures
23:17:35 <jsnx> enderbean: than you should try it
23:17:48 <quicksilver> jsnx: no, that wont' help him
23:17:49 <mauke> what
23:17:54 <mauke> just use div instead of /
23:17:58 <quicksilver> jsnx: there is no tpe signature which wil unify Integral and Fractional
23:18:06 <quicksilver> jsnx: there is no tpe which is an instance of both
23:18:11 <quicksilver> hence my initial advice to him
23:18:20 <jsnx> quicksilver: oh, i did not see that advice...
23:18:31 <jsnx> i defer to quicksilver
23:18:53 <jsnx> i guess (/) always spits out a double, so there's no helping it
23:19:01 <mauke> it doesn't
23:19:15 <jsnx> or rather, a Fractional...
23:19:39 <mauke> > 1.2 / 3.4 :: Rational
23:19:40 <lambdabot>  6%17
23:20:29 <jsnx> :type 1.2 / 3.4
23:20:46 <sclv> ?ty 1.2/3.4
23:20:47 <lambdabot> forall t. (Fractional t) => t
23:20:52 <jsnx> oh, right
23:20:53 <enderbean> Why are there two different division operators?
23:21:05 <jsnx> div and (/)?
23:21:17 <jsnx> someone else should answer this one...
23:21:20 <mauke> one for integers, one for fractionals
23:21:36 <sclv> div throws away the remainder, / gives the full result.
23:21:51 <jsnx> "integer division" is different from "division"
23:21:53 <sclv> thus both are of type a->a->a
23:22:07 <sclv> > 12 `divMod` 5
23:22:09 <lambdabot>  (2,2)
23:22:21 <quicksilver> enderbean: in principle, (/) could be overridden to have both behaviours
23:22:26 <quicksilver> enderbean: so, it was a design decisio
23:22:38 <quicksilver> enderbean: that since they are different operations, give them different names
23:22:58 <enderbean> I assume it was because secretly throwing away the fraction on integers could cause logic errors to sneak in
23:23:02 <quicksilver> exactly
23:25:42 <dmwit> > ord '\n'
23:25:45 <lambdabot>  10
23:27:00 <dmwit> > ord '\r'
23:27:03 <lambdabot>  13
23:32:41 <jsnx> does anybody use 'unfold' much?
23:32:43 <jsnx> i am reading a paper about it
23:32:52 <dobblego> yes!
23:33:08 <jsnx> dobblego: is there a standard implementation?
23:33:12 <sjanssen> probably not as often as I could
23:33:13 <dobblego> ?type unfoldr
23:33:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:33:15 <sjanssen> @src unfoldr
23:33:15 <lambdabot> unfoldr f b  = case f b of
23:33:15 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
23:33:15 <lambdabot>    Nothing        -> []
23:33:23 <dobblego> http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/unfold.ps.gz are you reading that?
23:33:28 <Olathe> Eww.
23:33:28 <jsnx> oh, i see -- it has a left and right variant
23:33:35 <jsnx> dobblego: yes
23:35:43 <quicksilver> I don't often use unfold explicitly, I must admit
23:35:52 <quicksilver> I'm more likely to use one of the build-in sequence generators
23:35:55 <quicksilver> like iterate
23:35:58 <quicksilver> or scanl
23:39:09 <sclv> :t scanl
23:39:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:39:28 <Olathe> @t lambdabot
23:39:29 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:39:46 <Olathe> :botsnack
23:40:03 <sclv> :t iterate
23:40:09 <lambdabot> forall a. (a -> a) -> a -> [a]
23:40:36 <sclv> What would be handy is a default unfoldr without the Maybe -- i.e. unfoldforever
23:42:10 <quicksilver> yes, if I do use unfold it quite often always returns Just
23:44:43 <jsnx> :t 1.2/3.4
23:44:46 <lambdabot> forall t. (Fractional t) => t
23:44:55 <jsnx> :type 1.2/3.4
23:45:11 <jsnx> interesting
23:45:18 <Cale> I find that a lot of the applications of unfoldr fit quite nicely into the function: unfoldrAlt g p f = map g . takeWhile p . iterate f
23:46:03 <Cale> jsnx: It treats literals 1.2, etc as Rationals first, and applies fromRational to them.
23:49:35 <jsnx> actually what i thought was interesting was the :t
23:51:22 <Cale> By the way, this is what explains the odd behaviour of constants like 1e10000000000000000 -- since it is so costly to represent that number directly as a Rational, it can take a while to compile a Haskell file containing such a constant.
23:52:20 <Cale> Of course, if it ends up being a Double, a much smaller constant would do ;)
23:53:06 <dmwit> > let e x y = x * (10 ^ y) in 1 `e` 10000000000000000
23:53:11 <lambdabot> Terminated
23:53:36 <dmwit> > let e x y = x * (10 ^ y) in 1`e`1000000
23:53:43 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
23:54:04 <dmwit> > let e x y = x * (10 ^ y) in fromRational $ 1`e`1000000
23:54:07 <lambdabot> Terminated
23:54:11 <xpika> guess ill try the tactic of doing what Xmonad did, having one big datastructure to hold the whole program
23:54:15 <int-e> > let e x y = x * (10 ^ y) in 1 `e` 10000000000000000 :: Double
23:54:15 <lambdabot>  Infinity
23:54:25 <dmwit> Forget compilation, it takes too long at runtime. =P
23:54:56 <dons> xpika: it works well, i find. don't distribute your state around, keep it in one place
23:55:30 <olsner> actually, for a Double, you could just store Inf (or generate an error) since the exponent is larger than what a Double can hold
23:56:42 <skew> dons: actually, it looks like the things not being inlined are just applications of printf to constant strings
23:57:11 <dons> ah ok.
23:57:25 <skew> which makes sense because they were not being simplified
23:58:33 <skew> things not being inlined under 6.8.1, that is. 6.6.1 was still pretty broken, I think
