00:00:05 <markb> i realise this
00:00:08 <faxathisia> (and you don't need ghc either)
00:08:43 <markb> faxathisia: but when configuring ghc to build...and dont have one of its deps, its much easier to get it from darwin ports, than finding it and building it yourself
00:09:11 <faxathisia> I'm not sure about that.. I just downloaded the binary it worked fine
00:10:37 <markb> yes but you aren't editing and compiling ghc itself
00:11:32 * faxathisia gives up trying to help
00:11:39 <markb> i dont mean any disrespect
00:11:58 <faxathisia> ghc 6.something compiled fine for me.. 6.8.1 didn't due to a known bug
00:12:16 <faxathisia> I didn't have to install any dependancies
00:12:27 <faxathisia> (unless I already had for something else..)
00:14:24 <markb> he configure for 6.8.1 looks for happy, alex...i was just trying to find an easy way to grab them, but then darwin ports didnt compile ghc properly for some reason so i had to get them from source
00:14:43 <sieni> 4/win 22
00:14:45 <sieni> eiku
00:15:42 <sjanssen> markb: the happy/alex thing is a bug with the extralibs tarball
00:16:15 <sjanssen> try installing GHC without them
00:17:12 <markb> sjanssen: im building ghc now, hopefully everything goes smoothly since i have them now
00:27:35 <hpaste>  markb pasted "HpcDraft failed compile" at http://hpaste.org/3911
00:37:04 <SnailRacer> markb: you need to test for the string with Left Right somewhere
00:39:11 <markb> SnailRacer: this happened with the code in ghc
00:39:29 <SnailRacer> yeah, odd
00:41:00 <markb> i grabbed it from the darcs repos...the STABLE version...perhaps i should grab the head
00:41:09 <araujo> :-)
00:50:15 <faxathisia> I can't find a haskell minesweeper solver anywhere
00:51:31 <wli> I think everyone's tied up solving sudoku.
00:51:52 <faxathisia> ack
00:52:06 <goalieca> can minesweeper even be solved.
00:52:11 <goalieca> there are places you have to "guess"
00:52:16 <OceanSpray> The seas have boiled away,
00:52:20 <faxathisia> guessing is ok by me
00:52:21 <OceanSpray> the mountains crumbled.
00:52:36 <faxathisia> I would like to see every possible solution for a configuration
00:52:36 <OceanSpray> What's ghc's main purpose?
00:52:58 <faxathisia> (of course in a real game only one of them is correct)
00:53:36 <faxathisia> (or none if it's an inconsistent configuration?)
00:53:41 <SnailRacer> What can a paperclip be used for?
00:55:59 <davidL> I need to make this one character shorter, how?: main=putStr"Hello, world!"
00:56:48 <wli> "Solving" minesweeper has an obvious meaning: determining the optimal strategy.
00:57:10 <markb> davidL: main=print"hello, world!" ?
00:57:28 <davidL> but that prints with quotes
00:57:38 <SnailRacer> Given a certain state of a game of minesweeper you could figure the probabilities for covered tiles, but I don't think there's always a tile with 100% probability of not having a mine.
00:58:13 <faxathisia> SnailRacer: if you have a 8
00:58:59 <davidL> is there some other, shorter keyword for main?
01:00:04 <wli> No. You need a shorter putStr.
01:00:26 <sjanssen> davidL: you know that it's possible?
01:00:27 <davidL> how?
01:00:52 <Cale> http://sed.free.fr/complex/mines.html
01:01:08 <davidL> yeah the shortest solution is supposedly 26 characters, to print Hello, world!
01:01:09 <sjanssen> davidL: no, I'm asking whether you're sure that it's possible
01:01:17 <davidL> http://golf.shinh.org/p.rb?hello+world
01:02:10 <Cale> It's NP-complete, in a rather fun way. :)
01:03:41 <sjanssen> davidL: your solution is 26 characters
01:03:50 <davidL> it is?
01:03:55 <sjanssen> yes
01:04:09 <davidL> wc -c told me 27 :-(
01:04:10 <sjanssen> tell your editor not to write a newline at the end of the file
01:04:39 <davidL> gah, thank you
01:07:55 <kfish> minesweeper solved in 26 characters? crikey!
01:12:43 <Pastorn> @src iterate
01:14:07 <Pastorn> @src iterate
01:14:14 <Pastorn> is she dead?
01:14:29 <sjanssen> @botsnack
01:19:12 <faxathisia> > let iterate f x = x : (map f (iterate f x)) in map fst $ iterate (\(x,y) -> (y,x+y)) (0,1)
01:20:26 <wli> iterate f x = let xs = x : map f xs in xs would be better.
01:21:24 <wli> If you insist on no let, then iterate f x = x : iterate f (f x)
01:22:13 <faxathisia> I don't think iterate f x = let xs = x : map f xs it iterate
01:22:21 <faxathisia> oh I see
01:24:49 <faxathisia> why is it better though?
01:25:08 <wli> More explicit sharing.
01:25:16 <faxathisia> ah right
01:58:51 <ico> Hello all. I'm trying to build xmonad, but cabal barfs to me saying "Setup.lhs: xmonad.cabal:24: 'Executable' stanza starting with field 'flag small_base". Any tips what my problem could be ?
01:59:21 <kfish> ico, possibly your cabal is too old?
01:59:44 <ico> ah, let me see. I'm using the default cabal debian etch provides...
02:01:25 <MyCatVerbs> Whoa, 200(7-n,where n is a member of the natural numbers and is strictly greater than zero) called, they want their -stable branch back! ;)
02:02:21 <sjanssen> ico: you need Cabal 1.2 or greater
02:02:41 <ico> ok, this changed recently it seems
02:02:46 <ico> pity that my distro does not provide that
02:03:59 <MyCatVerbs> ico: what version of ghc do you have installed? It wouldn't be particularly difficult for you to compile and install 6.8.1 like, right now, provided it's anything in the 6.x series (and I think some of the 5.x series, but I'm not completely sure about that).
02:04:13 <ico> 6.6.1-2
02:04:22 <sjanssen> note there is no need to upgrade GHC to build xmonad
02:04:36 <MyCatVerbs> sjanssen: yeah, but it'll get him new Cabal for free, more or less.
02:04:37 <sjanssen> you can even install Cabal as a user if you don't want to clutter up system files
02:04:44 <MyCatVerbs> sjanssen: plus it'll be faster. >>
02:04:46 <sjanssen> @hackage Cabal
02:05:03 <sjanssen> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal-1.2.2.0
02:05:11 <ico> hmm that would be an option
02:05:30 <ico> although things will probably clutter when combining manual stuff with distro stuff
02:05:34 <sjanssen> ico: you can build and install from that link in just a few minutes
02:13:05 <coderdave> hi, im working through a tutorial 'Yet another haskell tutorial' and im trying to do an excersise where i input a bunch of numbers and it returns a list, then i take the list and perform a sum. I've been able to do both function seperately but i dont know how to combine them so i input a bunch of numbers and then perform a sum on the list
02:13:22 <coderdave> here is my output
02:13:22 <coderdave> foldl (+) 0 (askForNumbers)
02:13:22 <coderdave> ERROR - Type error in application
02:13:22 <coderdave> *** Expression     : foldl (+) 0 askForNumbers
02:13:22 <coderdave> *** Term           : askForNumbers
02:13:23 <coderdave> *** Type           : IO [Integer]
02:13:25 <coderdave> *** Does not match : [a]
02:13:32 <coderdave> oops, didn't mean for it to spam multiple lines, sorry :(
02:13:45 <quicksil1er> that's OK, but there is a paste at http://hpaste.org/
02:13:52 <quicksil1er> the problem is that 'askForNumbers' isn't a list of numbers
02:13:54 <coderdave> ok, thanks quicksilver
02:13:59 <quicksil1er> it's actually a command which does something
02:14:01 <quicksil1er> (gets input)
02:14:06 <quicksil1er> and then returns a list of numbers
02:14:10 <coderdave> right
02:14:12 <quicksil1er> you need to use a "do" block
02:14:21 <quicksil1er> do nums <- askForNumbers
02:14:34 <quicksil1er>    print (foldl (+) 0 nums)
02:14:38 <quicksil1er> something like that
02:14:58 <quicksil1er> you don't have to print the answer, you can do whatever you like with the answer :)
02:15:06 <coderdave> it says Last generator in do {...} must be an expression
02:15:14 <coderdave> need () maybe?
02:15:32 <coderdave> oh wait
02:15:32 <coderdave> nvm
02:16:46 <coderdave> ok, that snipet of code you gave me is not a function, correct?
02:17:07 <coderdave> just two imperitive statements?
02:18:22 <ADEpt> @type do {n <- read; print (sum n :: Int)}
02:18:46 <kfish> coderdave, it's the body of a function ;-)
02:18:59 <coderdave> right
02:19:04 <coderdave> gotcha
02:19:14 <quicksil1er> coderdave: that error suggests you got the indentation wrong
02:19:21 <quicksil1er> you need the 'print' to line up with the 'nums'
02:21:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3912
02:21:18 <coderdave> here is my error
02:21:26 <coderdave> http://hpaste.org/3912
02:22:20 <quicksilver> coderdave: yes. my guess was correct
02:22:27 <quicksilver> coderdave: 'print' must line up with 'num'
02:22:44 <quicksilver> coderdave: but also, 'myfunc' needs to start on the left margin
02:23:07 <coderdave> hmm, i guess i should read up on white spaces and tabs
02:23:10 <RayNbow> the layout rules are pretty unforgiving for people new to it
02:23:16 <coderdave> seems like i am missing something fundamental
02:23:27 <jeffz> the emacs haskell-mode makes it a great deal easier i think
02:23:31 <quicksilver> coderdave: I would advise against using tabs in haskell
02:23:34 <quicksilver> just use spaces
02:24:00 <faxathisia> I like it when you press tab it inserts several spaces
02:24:12 <wli> I don't get the pro-space deal.
02:24:13 <faxathisia> seems ideal
02:24:20 <coderdave> ok, i fixed the layout issue and i get undefined variable "nums"
02:24:39 <coderdave> wli: working in a team environment, having tabs convert to spaces makes sharing code easier
02:25:51 <RayNbow> btw coderdave, did you write that factorial function yourself?
02:26:00 <wli> I'd expect the existence of a standard to be the first-order effect, and spaces to be suboptimal due to allowing greater variation in style and also being harder to count.
02:26:30 <JoshGraham> wli +1
02:26:43 <ico> sjanssen: maybe you can give me a bit of help here: I built and installed a local version of cabal, using a different --prefix. Now how can I make the xmonad build use that version ?
02:26:53 <coderdave> raynbow, yah that was easy it was in the text but i got it right
02:27:15 <sjanssen> wli: spaces are necessary for the sort of indentation used in Haskell, IMO
02:27:16 <quicksilver> coderdave: that's just a typo
02:27:24 <quicksilver> coderdave: you used 'num' in the line before and the 'nums' in the next line
02:27:34 <RayNbow> coderdave, do you know the product function that's in the Prelude?
02:27:35 <quicksilver> wli: you can't line up with the three spaces in "do " using a tab :P
02:27:46 <coderdave> quicksilver: thanks!
02:28:06 <coderdave> raynbow: no, i dont know of it
02:28:16 <sjanssen> ico: ghc should automatically pick the largest version number
02:28:24 <wli> quicksilver: do^Inums <- askForNumbers etc.
02:28:28 <sjanssen> ico: what does "ghc-pkg list Cabal" give?
02:28:47 <wli> sjanssen: I've never run across such a situation.
02:28:52 <RayNbow> coderdave: product [2,3,6] ~~> 36
02:29:07 <sjanssen> wli: it is trivial to generate code that is ambiguous based on the tab width
02:29:08 <coderdave> the prelude is the standard library for haskell, correct?
02:29:17 <sjanssen> wli: are your tabs set to 8 spaces?
02:29:22 <RayNbow> and something like... product [1..5] ~~> 120
02:29:30 <wli> sjanssen: Standardize tab widths at 8 spaces, as is standard anyway.
02:29:43 <quicksilver> coderdave: the prelude is the smallest, most standard part
02:30:05 <quicksilver> coderdave: however, the much larger library is also considered to be fairly standard
02:30:24 <RayNbow> coderdave, using the product function, you can rewrite factorial: fac n = product [1..n]
02:30:24 <coderdave> ok, gotcha - when i learn a little more of the basics ill be able to reference it :)
02:30:29 <quicksilver> coderdave: the entire tree shown at http://haskell.org/ghc/docs/latest/html/libraries/ is considered fairly 'standard' by most people.
02:30:32 <coderdave> raynbow, what is the benefit?
02:30:41 <quicksilver> wli: except, that's just not standard at all
02:30:44 <RayNbow> no explicit recursion :p
02:30:49 <geocalc> my tab is 2 space and i saw no problems
02:30:59 <quicksilver> wli: of the coders I know, less than 1% use 8-space indentation
02:31:02 <quicksilver> and I know a lot of coders
02:31:13 <Syzygy-> Yikes. 8-space? That gives me vertigo.
02:31:20 <Syzygy-> Even 4-space feels big.
02:31:46 <quicksilver> geocalc: I doubt you're using tabs, though?
02:31:51 <wli> sjanssen: It's the standard tabstop from time immemorial.
02:31:53 <quicksilver> geocalc: you're probably just using two spaces?
02:32:09 <sjanssen> wli: quicksilver is the person disagreeing with you
02:32:17 <quicksilver> wli: it was never standard for coding. it was once standard for displaying tabular data, sure.
02:32:18 <geocalc> 2-spaces tab
02:32:28 <wli> quicksilver: 8 spaces is the standard tabstop from time immemorial.
02:32:39 <quicksilver> but, it's not used in code.
02:32:41 * RayNbow prefers 4 spaces :p
02:32:43 <quicksilver> or, by very few people indeed.
02:32:58 <wli> quicksilver: I've never seen a single coder who doesn't use 8-space tabs.
02:33:08 <quicksilver> And I've only ever seen a couple who do.
02:33:14 <ico> sjanssen: ghc-pkg list Cabal: Cabal-1.1.6.2
02:33:17 <quicksilver> Out of a survey including severl hundred :)
02:33:23 <quicksilver> so clearly we hvae a very different corpus.
02:33:29 <sjanssen> ico: ah, so GHC doesn't know about it somehow
02:33:44 <ico> I did the configure, build and istall as a normal user, eg non-root
02:33:48 <wli> quicksilver: I have no idea where you're getting your "coders" from. Every Linux kernel hacker uses 8-space tabs.
02:34:00 <sjanssen> ico: oh, did you give the --user flag when configuring?
02:34:06 <ico> nope :)
02:34:06 <ico> retry
02:34:21 <Syzygy-> *emerging 6.8.1*
02:34:38 <ico> sweet
02:34:46 <ico> thank you!
02:35:06 <wli> quicksilver: And 8-space tabstops with tabs as '\t' is written into kernel coding standards. akpm even runs a patch checking script that warns when spaces are used for indentation.
02:35:42 <quicksilver> wli: I'm familiar with the linux kernel but in my experience it is very aberational in that respect.
02:35:51 <faxathisia> Linux kernel is just one program though ?
02:35:59 <quicksilver> wli: although I understand why there needs to be a standard in a project like that, of course.
02:36:03 <quicksilver> and it's linus's call.
02:36:41 <wli> Userspace can't be much different.
02:36:42 <quicksilver> I don't know Linus personally, and anyone I know who contributes to the kernel only obeys the kernel coding standards when writing for the kernel :)
02:37:16 <quicksilver> of course, since akpm insists on hard tabs, you can view the kernel with any tab-width.
02:37:25 <faxathisia> formatting C code is different to haskell though
02:37:25 <quicksilver> which gives the user some flexibility.
02:37:44 <quicksilver> (as long as you don't use intra-line tabs, but that's pretty unusual in C)
02:38:34 <wli> Hard tabs are the way to go. Spaces are just a waste of space and also typing if you ever have to manually indent.
02:39:54 <wli> Space -based indenting wastes multiple megabytes in the kernel's disk footprint.
02:40:14 <faxathisia> megabytes is nothing :p
02:40:37 <quicksilver> wli: hard tabs don't let you do alignment, though
02:40:42 <quicksilver> as in
02:40:53 <quicksilver> if (a == FOO ||
02:40:55 <wli> quicksilver: alignment of what?
02:41:00 <quicksilver>     b == FOO)
02:41:03 <quicksilver> that sort of thing
02:41:11 <quicksilver> which I think makes code much more readable
02:41:24 <faxathisia> <tab><space><space><space><space>b == FOO)
02:41:31 <faxathisia> what about that
02:41:34 <quicksilver> faxathisia: yes, that workd.
02:41:42 <quicksilver> faxathisia: but that's not using hard tabs exlusively :)
02:41:46 <horchata_> i wonder if someone could critique this code:
02:41:47 <horchata_> http://paste.lisp.org/display/50943
02:42:00 <quicksilver> faxathisia: that's the best style of all, but alas editor modes don't support it and I'm too lazy to do it by hand.
02:42:25 <wli> If you're playing that sort of indentation game you should probably break it out into variables anyway.
02:42:31 <faxathisia> horchata_: what bout takeWhile instead of filter?
02:42:34 <faxathisia> since it's an infinite list
02:42:50 * EvilTerran is occasionally tempted to make a preprocessed-out indentation syntax that does all sorts of magic to line things up nicely
02:42:50 <doserj> horchata_: print . show is typically unnecessary. Just use print
02:42:57 <quicksilver> wli: I don't agree. breaking out into variables inserts un-necessary names.
02:43:14 <faxathisia> horchata_: like sum $ filter even $ takeWhile (< something) $ fibs
02:43:21 <horchata_> faxathisia, doserj: thanks much
02:43:39 <horchata_> ah so takeWhile doesn't require i know the upper bound
02:43:42 <horchata_> excellent
02:43:47 <EvilTerran> as in, have the IDE insert markup to align things vertically while you're working, and then it could produce a file with the markup flattened down to spaces (and the semantic meaning of the indentation lost) on request
02:44:01 <faxathisia> Why does a lot of people make a function 'main' ?
02:44:11 <horchata_> tutorials?
02:44:23 <EvilTerran> so you could have a load of line-end comments aligned vertically, and if you made one of the lines longer, it'd move all the comments over
02:44:42 <quicksilver> faxathisia: because ghc makes 'main' the main entry point to your program.
02:44:52 <wli> quicksilver: Huge expessions are bad ideas.
02:44:54 <EvilTerran> faxathisia, horchata_; if it's of type IO (), it's because that's the "entry point" of a compiled haskell program
02:44:58 <wli> -main-is is handy
02:45:02 <quicksilver> wli: my haskell programs are generally huge expressions
02:45:05 <faxathisia> quicksilver: is there any advantage? I just go :load file and then use the functions I wrote
02:45:11 <quicksilver> faxathisia: no
02:45:19 <quicksilver> faxathisia: but some people like to write compiled programs which can be run :)
02:45:28 <EvilTerran> faxathisia, there is if you're compiling it. otherwise, there's no real difference
02:45:40 <faxathisia> what's the point in compiling?
02:45:43 <EvilTerran> well, or using it with runhaskell/runghc
02:45:51 <quicksilver> faxathisia: it would be annoying if you had to :load firefox.hs, startFirefox at the ghci prompt each time they wanted to run firefox, would they?
02:45:56 <faxathisia> haha
02:45:57 <EvilTerran> performance, obfuscation of your horrible coding practices...
02:46:00 <faxathisia> I didn't write firefox though :p
02:46:03 <EvilTerran> ;)
02:46:05 <quicksilver> no, but someone did.
02:46:24 <faxathisia> there is really a performance difference?
02:46:29 <EvilTerran> oh, very much so
02:46:42 <quicksilver> there is a massive performance difference between compiled and interpreted code, yes
02:46:45 <EvilTerran> ghci does very little optimisation compared to what ghc can do
02:46:48 <quicksilver> of course, you can run compiled code in ghci
02:47:06 <faxathisia> and the compiled code doesn't have to have a main?
02:47:15 <quicksilver> faxathisia: indeed not
02:47:20 <faxathisia> cool
02:47:24 <wli> faxathisia: -main-is
02:47:28 <faxathisia> what?
02:47:28 <quicksilver> when you use the standard libraries
02:47:32 <quicksilver> you are using compiled code
02:47:34 <EvilTerran> it could be like a C library, that just exports a load of functions
02:47:41 <EvilTerran> rather than a fully-functional standalone application
02:47:47 <quicksilver> wli: "Huge expessions are bad ideas."
02:47:52 <quicksilver> wli: I actually couldn't agree more strongly
02:48:01 <quicksilver> wli: my opinion is precisely the opposite
02:48:06 <quicksilver> statements are bad ideas
02:48:10 <quicksilver> huge expressions are the ideal state
02:48:18 <quicksilver> s/agree/disagree/ :)
02:48:32 <wli> quicksilver: No. Huge expressions without names anywhere are bad ideas.
02:48:40 <EvilTerran> but, in a stand-alone haskell application, you need an "entry point" where execution starts
02:49:07 <EvilTerran> this is called "main" by default, but you can change the name of it with the -main-is flag passed to ghc
02:49:09 <quicksilver> wli: names are useful when names are useful. I don't think there is a simple mapping from expression size to need for names.
02:49:23 <EvilTerran> me, I program in De Brujin terms!
02:49:25 <faxathisia> wli: What is "-main-is"?
02:49:29 <quicksilver> wli: I certainly don't advocate nameless code :)
02:49:34 <quicksilver> but I disagree with the connection
02:49:44 <geocalc> huge tabs VS huge expressions
02:49:47 <wli> quicksilver: Digestibility.
02:49:55 <EvilTerran> faxathisia, see my last-but-one line; it lets you rename the "entry point" of your code
02:50:11 <faxathisia> oh ok
02:50:37 <wli> -main-is is actually incredibly useful.
02:50:57 <wli> Test drivers can be left sitting around and so on.
02:52:40 <hpaste>  quicksilver pasted "example of multi-line expression" at http://hpaste.org/3913
02:53:01 <quicksilver> wli: there is a kind of example. Not that I'm claiming this code is perfect in any way.
02:53:11 <quicksilver> but that has a largish expression which I should have aligned with spaces, although I haven't :)
02:56:38 <doserj> I would give names to the two anonymous function. otherwise, it's fine.
02:57:21 <quicksilver> I don't see any value in naming those functions
02:57:23 <quicksilver> they're not interesting
02:57:39 <quicksilver> 'updatePSToHaveGameBoardFocus' ?
02:57:47 <quicksilver> the lambda is clear. it says what it says.
02:57:56 <quicksilver> A name could , at best, say the same thing :)
02:58:03 <doserj> it's not for reuse, or something. but it makes the table nicer to read
02:58:21 <quicksilver> I wouldn't mind nicer record update syntax for this kind of thing :)
02:58:26 <quicksilver> but that's slightly orthogonal
02:59:01 <quicksilver> If it made it small enough to get it all onto one line, so all the help texts lined up, that would look nicer, though
03:00:25 <quicksilver> if I gave up my slavish addiction to 80-col width that would enable me to do that
03:00:29 <quicksilver> but the time is not yet ready.
03:00:33 <quicksilver> I shall be 80 col for a while yet.
03:04:29 <Spark> i like the idea of "slightly orthogonal"
03:04:33 <hpaste>  sjanssen annotated "example of multi-line expression" with "is this better?" at http://hpaste.org/3913#a1
03:04:36 <Spark> what's that... 20 degrees off? :)
03:06:36 <quicksilver> Spark: actualy what I meant was 'almost orthogonal' :)
03:07:03 <quicksilver> sjanssen: well I like the alignment, certainly.
03:07:14 <quicksilver> sjanssen: I'm happy with my let and don't feel the need to switch to a where :)
03:08:14 <wli> I'd probably give a name to each triple in the list.
03:08:50 <sjanssen> wli: you'd really prefer to write twice as much code?
03:09:42 <wli> It's not twice as much code.
03:09:44 <sjanssen> I don't see how any clarity would be gained
03:09:46 <quicksilver> sjanssen: the other thing I might do is factor out all the "justs" into a map (\(a,b,c) -> (a,b,Just c)) at the top.
03:09:57 <quicksilver> sjanssen: mainly because that might save a little horizontal space + noise
03:10:00 <sjanssen> wli: fine, about 1.5x as much
03:10:00 <wli> Maybe twice as many lines.
03:10:16 <quicksilver> I can't possibly see why you'd want to name each triple
03:10:20 <quicksilver> as it stands, I reads really nicely
03:10:38 <quicksilver> it's obvious a map of keypresses, to effects, with help text
03:10:49 <quicksilver> (is my opinion)
03:11:01 <sjanssen> I agree
03:11:08 <doserj> I wouldn't factor out the Just
03:11:18 <quicksilver> doserj: why not?
03:11:44 <doserj> you might want to add a keyboard shortcut without helptext later :)
03:12:06 <quicksilver> doserj: I could always ++ that without the map :)
03:12:12 <quicksilver> after the map, that is
03:12:35 <doserj> but that wouldn't look quite as nice. It obscures things
03:12:35 <quicksilver> I have done such tricks in the past.
03:12:41 <quicksilver> yeah, you might be right
03:13:04 <doserj> and you may have other tables like this in your program, which should look similar
03:13:22 <quicksilver> indeed I do
03:13:29 <quicksilver> although they have slightly different types
03:13:41 <sjanssen> it does look really nice without Just
03:14:08 <quicksilver> Personally I find this to be a great (if minor) advantage of haskell
03:14:17 <quicksilver> using lists of tuples as a kind of 'structuring tool'
03:14:33 <quicksilver> the java code to set up key associations like that would be a great deal longer
03:14:41 <quicksilver> and the help text would end up in a different function, most likely
03:17:20 <doserj> I always get a slight uneasy feeling when using a Maybe String.
03:18:06 <doserj> do you distinguish between Nothing and Just ""?
03:19:28 <pitecus> Is is possible to write a method toEither that will construct (Left x) or (Right x) depending in the type of x?
03:19:59 <doserj> pitecus: try to write a type signature for it
03:20:02 <SamB_XP> pitecus: what do you think?
03:20:08 <pitecus> I think not
03:20:14 <pitecus> but Im ignorant
03:21:09 <SamB_XP> well, what type should it return?
03:21:32 <pitecus> SamB_XP, Either a b
03:21:49 <SamB_XP> what is b in the case of a type that returns Left x
03:22:36 <pitecus> SamB_XP, OK let's say it always returns Either Foo Bar
03:22:40 <pitecus> Thats fine
03:22:44 <quicksilver> doserj: Yes. Nothing means no help text. Just "" draws the place where help text would go, but puts nothing into it :)
03:22:55 <quicksilver> doserj: I agree Just "" isn't very useful...
03:22:57 <SamB_XP> pitecus: well there's nothing hard about writing a method like that
03:23:08 <quicksilver> pitecus: the problem might be with the input
03:23:13 <quicksilver> pitecus: "depending on the type of x"
03:23:20 <quicksilver> pitecus: so what is the input type of this function?
03:23:42 <SamB_XP> class ToEither a where toEither :: a -> Either Foo Bar
03:24:00 <quicksilver> that would then be a method not a function :)
03:24:03 <quicksilver> but you could indeed do it.
03:24:14 <SamB_XP> he said method to start with ;-)
03:24:16 <pitecus> Ya i was thinking of a method
03:24:22 <quicksilver> oh yes
03:24:25 <quicksilver> my bad ;(
03:25:41 <pitecus> SamB_XP, in "toEither :: a -> Either Foo Bar" a should be either Foo or Bar, and I don't know how to specify that
03:25:56 <quicksilver> pitecus: instance ToEither Foo where toEither = Left
03:26:06 <quicksilver> instance ToEither Bar where toEither = Right
03:26:11 <SamB_XP> pitecus: you can't say that in a "once and for all" way
03:26:17 <quicksilver> and then simply don't declare any more instances
03:26:27 <quicksilver> it's true that you can't promise no more instances will be written
03:26:34 <quicksilver> but I'm not sure that matters much in normal use
03:26:41 <quicksilver> you're the programmer, you know which instances you wrote :P
03:26:50 <pitecus> OK let me play with it
03:27:02 <sjanssen> there's actually a trick to close class instances
03:27:25 <sjanssen> class Secret a; class Secret a => ToEither a ...
03:27:32 <SamB_XP> sjanssen: true, but does it buy you anything except preventing morons from instancing your class?
03:27:36 <sjanssen> export ToEither, but don't export Secret
03:27:47 <sjanssen> SamB_XP: nope, only moron protection :)
03:28:19 <quicksilver> sjanssen: what message do they get if they try to make another instance?
03:28:27 <SamB_XP> somehow, in this case that doesn't seem worth the bother?
03:28:32 <SamB_XP> quicksilver: instance of what?
03:28:40 <quicksilver> ToEither
03:28:48 <sjanssen> quicksilver: no instance for SomeModule.Secret, I imagine
03:28:48 <SamB_XP> I assume the method is on Secret
03:29:00 <SamB_XP> oh, no?
03:29:00 <SamB_XP> er.
03:29:01 <quicksilver> ah, the method is on Secret?
03:29:06 <SamB_XP> I guess it doesn't matter actualy
03:29:14 <sjanssen> no, the method must be on toEither
03:29:16 <quicksilver> sjanssen: but they can turn on overlapping instances, cna't htey?
03:29:30 <quicksilver> sjanssen: and then their instance overlaps with the Secret instance scheme
03:29:32 <SamB_XP> quicksilver: it's a superclass...
03:29:36 <quicksilver> oh
03:29:39 <sjanssen> otherwise the user can't write the type of toEither
03:29:46 <sjanssen> quicksilver: yes, that is possible
03:29:46 <SamB_XP> not a constraint on the instance
03:29:47 <quicksilver> superclass not instance scehme
03:29:54 <quicksilver> clever
03:30:13 <sjanssen> I think Text.Printf does this
03:30:26 <SamB_XP> I wish it WOULDN'T
03:30:26 <quicksilver> instances schemes being somewhat-like but actually totally different from superclasses is really confusing :)
03:30:46 <SamB_XP> Text.Printf is something that it would be nice to be able to implement for your own types
03:31:11 <SamB_XP> ... of course, I'd also like it better if it worked properly for the types it already supports
03:31:33 <SamB_XP> (I'm thinking of types like those in Data.Int and Data.Word)
03:31:49 <SamB_XP> (or Foreign.C.Type[s)
03:33:13 <quicksilver> do you actually using printf, then?
03:33:29 <quicksilver> I thought it was an interesting experiment in typeclasses, not for actual use :)
03:33:35 <SamB> I might use it more if it was more usable
03:37:19 <quicksilver> I would have thought a nice combinator library for text formatting would be more haskelly
03:37:24 <quicksilver> than printf with its funny format strings
03:37:35 <quicksilver> although format strings do have a virtue of conciseness
03:38:24 <chris2> which techniques are used to implement complex tree transformations in ghc? do they use attribute grammars or something like that?
03:40:12 <SamB> quicksilver: perhaps so
03:40:22 <SamB> but something at least as powerful as printf would be nice
03:40:44 <SamB> and a heck of a lot prettier than C++'s iostreams
03:40:49 <quicksilver> ;)
03:41:01 <SamB> chr1s: ... they use algebraic datatypes
03:41:04 <SamB> er.
03:41:06 <SamB> chris2:
03:41:15 <chris2> okay
03:41:30 <chris2> doesnt that make some kinds of stuff pretty complicated?
03:41:35 <SamB> yes
03:41:40 <chris2> :)
03:41:41 <Sizur> i'm trying to compile with -prof and i get "/usr/bin/ld: cannot find -lHSarray-0.1.0.0_p". what's that?
03:41:55 <SamB> they have some utility functions on those types, of course
03:42:09 <chris2> i hope so
03:42:34 <quicksilver> Sizur: means you don't have the profiling version of one of the libraries you're using
03:42:36 <chris2> are there maybe any combinator libraries for defining tree walkers?
03:42:39 <quicksilver> (or, that ghc can't find it, at least)
03:42:40 <SamB> Sizur: ... I've never heard of HSarray
03:42:45 <SamB> what is it?
03:43:13 <Sizur> i thought ghc comes with profiler
03:43:40 <SamB> Sizur: it does
03:43:53 <Sizur> SamB: so what lib am i missing then?
03:44:06 <SamB> but like many profilers you need to build the code with profiling support
03:44:32 <SamB> unlike, say, gcc's profiling instrumentation, this is an "all or nothing" deal with GHC
03:45:04 <SamB> so all libraries you use also need to have been compiled for profiling
03:45:18 <SamB> (presumably in addition to the normal way)
03:45:41 <Sizur> SamB: so in plain langauge i have to recompile ghc with other libs?
03:46:00 <SamB> not quite
03:46:49 <Sizur> i'm tying to profile a simple script, i dont explicitly use any libs aside from haskell standard
03:47:54 <SamB> could you run "ghc-pkg describe HSarray"
03:48:04 <nominolo> I think I've been programming too much in Haskell -- tonight I had a recursive dream ...
03:48:14 <Sizur> ghc-pkg: cannot find package HSarray
03:48:24 <doserj> you mean "ghc-pkg desscribe array"
03:48:32 <SamB> oh
03:48:37 <SamB> that might work better
03:48:39 <SamB> heh
03:49:34 <hpaste>  sizur pasted "profiling issue" at http://hpaste.org/3914
03:50:17 <quicksilver> I thought all the libraries which shipped were supposed to ship with profiling versions (also)
03:50:20 <SamB> Sizur: okay, so it looks like they've moved array stuff into it's own package
03:50:31 <SamB> Sizur: how did you install GHC?
03:50:43 <quicksilver> Sizur: were you using ghc --make to compile?
03:50:48 <Sizur> bootstrapped using 6.6.something
03:50:56 <Sizur> quicksilver: yeah --make
03:51:00 <quicksilver> hmm
03:51:25 <quicksilver> do you in fact have a file called libHSarray-0.1.0.0_p ?
03:51:37 <Sizur> quicksilver: where do i check?
03:51:47 <quicksilver> with 'locate' ? :)
03:52:11 <quicksilver> probably /usr/local/lib/ghc-6.8.1/ somewhere
03:52:46 <Syzygy-> They did move arrays into its own package. Says so right in the release notes. :)
03:52:46 <hpaste>  sizur annotated "profiling issue" with "locate" at http://hpaste.org/3914#a1
03:53:29 <doserj> so it is built, but not installed?
03:53:36 <doserj> ah, it is installed
03:56:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3915
03:57:13 <Sizur> any idea what could be wrong?
03:57:41 <reqamst> What's happening with Haskell Algorithm Challenge?
03:58:46 <quicksilver> Sizur: no. the right library is there but for some reason it's not finding it.
03:58:52 <quicksilver> Sizur: maybe try over on #ghc?
04:04:33 <byorgey> reqamst: what's that?
04:05:02 <visof> what are the advantages of "type" in haskell?
04:05:14 <quicksilver> visof: really it's a kind of documentation
04:05:27 <quicksilver> giving specific names even when you're re-using generic types
04:05:45 <reqamst> byorgey: http://www.haskell.org/haskellwiki/HAC
04:06:01 <sjanssen> reqamst: I don't think it every happened
04:06:50 <visof> quicksilver please can you explain further simply?
04:07:04 <byorgey> reqamst: looks like that page was last edited in January.
04:07:54 <quicksilver> visof: I don't think it's very useful, myself :)
04:07:58 <reqamst> Yeah, long time ago.
04:08:03 <quicksilver> visof: but, for example, type String = [Char]
04:08:12 <quicksilver> visof: a String is just a list of Chars
04:08:22 <quicksilver> but it's convenient sometimes to think of it as a specific type.
04:08:38 <byorgey> visof: type IdCode = String ; type WombatCount = Int ; data Foo = Foo IdCode WombatCount is more descriptive than just data Foo = Foo String Int.
04:09:31 <byorgey> visof: hm, just to be clear, you are asking about the "type" keyword?  (as opposed to the advantage of types in general?)
04:09:53 <visof> ya
04:10:10 <visof> advantages of types in haskell
04:10:32 <geocalc> -s*
04:10:46 <visof> is this like c types or c++?
04:11:01 <visof> int x , y;
04:11:06 <visof> int result;
04:11:15 <visof> result= x+y?
04:11:23 <visof> is this like it?
04:12:54 <byorgey> oh, you're asking about the advantages of types in general!  quicksilver and I thought you were asking something more specific =)
04:13:35 <byorgey> visof: types let you express properties of your code which can be checked by the compiler.
04:13:54 <byorgey> visof: yes, C and C++ have types too.
04:14:05 <byorgey> but the Haskell type system is much more powerful.
04:14:06 <visof> like Haskell?
04:14:14 <visof> how?
04:14:42 <byorgey> well, for one thing, Haskell allows you to define your own types.
04:15:14 <quicksilver> visof: the advantages of types is that the compiler can tell you if your code is rubbish
04:15:15 <byorgey> for example:  data Tree a = Empty | Branch a (Tree a) (Tree a)
04:15:21 <visof> structures in c/c++ ca do this
04:15:34 <quicksilver> visof: if you use an untyped language like lisp or perl, then you don't know if the code is rubbish until you run it and try sometimg
04:15:37 <quicksilver> right
04:15:43 <quicksilver> structures in C/C++ are a good example of types
04:15:51 <quicksilver> (some of the other bits of C/C++ are not)
04:15:56 <doserj> http://en.wikibooks.org/wiki/Haskell/Type_basics
04:15:57 <wolverian> quicksilver, types don't guarantee non-rubbishness
04:16:03 <quicksilver> wolverian: indeed not :)
04:16:28 <wolverian> so the correct phrase would be that type checking gives more compile-time guarantees
04:16:34 <wolverian> s/more/additional/
04:17:05 <idnar> although the type checking in C/C++/etc. doesn't do a very good job of catching bugs; it's mainly just good for making you type out a lot more code
04:17:20 <quicksilver> wolverian: I was using some gentle hyperbole :) I think it was clear enough what I meant.
04:17:58 <idnar> I'd just about completely given up on statically typed languages, before I discovered Haskell (and other statically typed languages not in the C family, I guess)
04:18:07 <wolverian> quicksilver, sure. :)
04:18:54 <quicksilver> idnar: C++/Java style class-based systems give a good degree of type safety.
04:19:03 <quicksilver> idnar: C++ still allows you to shoot yourself in the foot with pointers, though
04:19:11 <quicksilver> and they both give you horrible verbosity :)
04:19:20 <quicksilver> the type system part works fine, as far as it goes, though.
04:19:26 <quicksilver> (lack of polymorphism is annoying)
04:20:09 <idnar> the problem is that you end up using dynamic dispatch to work around deficiencies in the static type system, so you still end up with run-time type-related errors / bugs instead of them being caught at compile time
04:20:25 <quicksilver> yes
04:20:31 <quicksilver> there are a bunch of problems with it, in fact :)
04:20:39 <idnar> and of course, in the case of Java, you have the awesome "null" value
04:23:30 <quicksilver> idnar: however I would claim not that the systems fail in type safety, precisely
04:23:41 <quicksilver> idnar: i would claim that the type-safe constructs they provide are incomplete
04:23:50 <quicksilver> idnar: forcing you to use unsafe constructs quite often
04:23:57 <quicksilver> ...which is where it all goes wrong
04:24:08 <quicksilver> the "safe fragment" is safe enough. It just isn't expressive enough.
04:24:42 <idnar> sure; I think that's basically what I meant
04:24:47 * quicksilver nods
04:28:48 * byorgey hates 'null' in Java with the fire of a thousand suns
04:30:24 <ricky_clarkson> byorgey: I use it happily as a replacement for Maybe, with IDEA's @NotNull and @Nullable to help.
04:32:19 <byorgey> ricky_clarkson: hm, interesting, I'd never heard of that
04:32:37 <byorgey> does this only work in IntelliJ IDEA?
04:32:48 <ricky_clarkson> I think findbugs has its own implementation too.
04:32:54 <byorgey> unfortunately, I can't use that at work.
04:32:59 <ricky_clarkson> Which?
04:33:03 <byorgey> IDEA
04:33:11 <byorgey> we use Eclipse
04:33:12 <ricky_clarkson> Then your work is doubly retarded.
04:33:27 <byorgey> tell me about it.
04:33:50 <ricky_clarkson> Optional static typing within a statically typed language. ;)
04:35:59 <wolverian> the annotations are apache-licensed
04:42:30 <Sizur> if i have a list of Maybe's what standard function do i use to extract Just's?
04:43:12 <dblhelix> @hoogle catMaybes
04:43:54 <matthew_-> foldr msum Nothing
04:44:17 <matthew_-> err, no
04:44:28 <matthew_-> catMaybes it is
04:44:59 <dblhelix> what's wrong with lambdabot?
04:45:00 * locomalo is back (gone 07:08:14)
04:45:37 <jeffz> lb seems to have gone on strike
04:46:01 <dblhelix> well, I can't really blame her
04:46:05 <Sizur> dblhelix: thanks
04:46:12 <dblhelix> Sizur: yw
04:46:21 <jeffz> dblhelix: or she's just, really... really... lazy.
04:46:26 <Sizur> i know it's easy to write, but we want to reuse stuff ;)
04:46:37 <dblhelix> Sizur: rightly so
04:47:36 <kfish> did the module "FilePath" change capitalization to "filepath" sometime during the last year or so?
04:48:15 <matthew_-> kfish: if you mean the package name, yes, I believe so
04:49:06 <Sizur> we don't have any accumulative filer, right?
04:49:17 <kfish> matthew-_, that would explain why cabal-1.3's Cabal.cabal doesn't find it :-)
04:49:21 <Sizur> filter*
04:49:33 <matthew_-> kfish: indeed.
04:49:53 <kfish> does cabal support alternative dependencies? :-)
04:55:18 <visof> what this mean  (p:xs)?
04:55:19 <hpaste>  mmorrow annotated "(no title)" with "(no title)" at http://hpaste.org/3912#a1
04:55:34 <visof> is this tuple?
04:55:59 <visof>  sieve (p:xs) = p : sieve [x|x <- xs, x `mod` p > 0]
04:56:03 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/3912#a2
04:56:58 <hpaste>  mmorrow annotated "(no title)" with "(no title)" at http://hpaste.org/3912#a3
04:57:16 <dmwit> visof: No, (p:xs) is the notation for a list.
04:57:36 <dmwit> (:) is cons, it puts an element onto the front of a list.
04:57:50 <dmwit> > 1 : [2,3,57]
04:58:17 <visof> so p and xs are lists?
04:58:50 <dmwit> p is an element, xs is a list.
04:59:13 <visof> i understood
04:59:16 <visof> thanks
04:59:21 <dmwit> Sure, good luck!
04:59:24 <dmwit> =)
05:00:55 <ricky_clarkson> I have a friend who struggles to understand arithmetic with negative numbers, and I thought about using Zero, Succ and Pred to explain it, but I couldn't work out how.
05:01:50 <dmwit> That seems like it would be a bit of a convoluted way to explain integers to a friend who is already having trouble.
05:01:54 <hpaste>  mmorrow annotated "is there a way to make this a one-liner?" with "(no title)" at http://hpaste.org/3906#a1
05:02:08 <Beelsebob> church numerals are not a good way of dealing with negative numbers
05:02:16 <Beelsebob> they only barely do it with a cludge
05:03:38 <hpaste>  dmwit annotated "is there a way to make this a one-liner?" with "correction" at http://hpaste.org/3906#a2
05:04:48 <yaxu> is it bad form for two modules to import each other?
05:05:17 <visof> can i find the online free "programming in Haskell by Graham Hutton" Ebook?
05:05:36 <dmwit> yaxu: It's a bit hard to do, have a look at hs-boot files.
05:05:47 <yaxu> dmwit: ah, i'll work around it then
05:05:54 <yaxu> visof: it's not free afaik
05:05:57 <jeffz> visof: no - you should pay for a copy like every other hard working person did -- perhaps you can ask your library to stock it.
05:06:07 <ricky_clarkson> dmwit: Sure.  I didn't actually try, just realised that I couldn't.
05:06:10 <yaxu> visof: there used to be a free to download pdf with the first few chapters in
05:06:24 <ricky_clarkson> dmwit: One needs to keep one's brain active while sat on a slow-moving bus..
05:06:38 <yaxu> visof: that got pulled when the book was published though
05:06:41 <dmwit> heh
05:06:46 <visof> yaxu i downloaded 5 chapters
05:07:03 <jeffz> I recall that copy wasn't for distribution
05:07:16 <yaxu> visof: that's the one
05:07:26 <yaxu> visof: you can browse it here too: http://books.google.co.uk/books?id=olp7lAtpRX0C&printsec=frontcover&dq=hutton+haskell&ei=55U9R7ayNIuEpgLYmNC8Ag&sig=-1q3-wva8qc01CqqvVLmNVT5Xwk
05:08:26 <yaxu> some pages anyway
05:08:32 <yaxu> it's a very good book
05:08:36 <hpaste>  dmwit annotated "(no title)" with "Just for fun, using some built-in functions" at http://hpaste.org/3912#a4
05:09:10 <visof> can any one who have the book put it for free?
05:09:32 <jeffz> visof: no - this is against the law, have you no conscience?
05:09:56 <jeffz> visof: you could probably work 1 shift in a bar and then have enough money to purchase the book
05:10:24 <visof> ok i 'll try
05:11:12 <Beelsebob> visof: note that the author (although I can't claim to know his motives), probably wrote said book in order to suplement his not so wonderful Lecturer's salary
05:11:31 <jeffz> visof: in life, people are expected to work for money to purchase things they want - stealing undermines is wrong and undermines the efforts of others
05:11:56 <Beelsebob> jeffz: although in this case what he is proposing isn't of course stealing
05:12:02 <Beelsebob> it's merely copyright infringement
05:12:09 <Beelsebob> which is a fine distinction, but a relevant one
05:12:16 <vincenz> hpc comes with 6.8?
05:12:28 <dmwit> es
05:12:30 <dmwit> yes
05:13:54 <jeffz> Beelsebob: interesting you say 'merely' - I guess you don't think of it in terms of right and wrong then.
05:14:08 <geocalc> lol pay for knowledge
05:14:33 <Beelsebob> jeffz: merely as in "copyright" is a lesser crime than "theft" -- copyright only involves taking a copy for yourself, not removing one from the other person
05:14:50 <Beelsebob> and I didn't say anything about whether it's right or wrong
05:15:08 <Beelsebob> mostly because I'm yet to be convinced by either side about whether copyright is a good or a bad thing
05:15:33 <geocalc> pay for knowledge is a crime
05:15:35 <Beelsebob> all I said was that the crime he was proposing was not theft... which it isn't
05:15:51 <jeffz> Beelsebob: well, I'm no expert on law, but if permissive licenses can protect free content, then all licenses should be respected equally.
05:16:26 <Beelsebob> jeffz: plausable, but as I said, I make no judgement on whether it's "right" or "wrong" at the moment, because neither side has convinced me
05:16:32 <reqamst> Huh... In my country "Programming Haskell" by Hutton costs about $130.
05:16:56 <jeffz> reqamst: look at a second hand copy on amazon... could be considerably cheaper
05:16:58 <Beelsebob> partly I agree with geocalc that one should never ask for money for knowledge, and partly I agree that people with big brains should get some money for using them
05:17:32 <dmwit> Most licenses have no problem with charging money for their product.
05:17:40 <dmwit> Just thought I'd throw that in there.
05:17:52 <wolverian> Beelsebob, but does the latter necessitate a right to it?
05:18:46 <wolverian> that is, a right to impose restrictions on the knowledge. I can imagine other methods of payment.
05:18:56 <Beelsebob> wolverian: perhaps sociatally -- in that our society is run on having money, we *need* people with big brains to use them, if we don't reward them then they'll start producing physical things instead to make some money (after all, society revolves around it)
05:19:34 <wolverian> Beelsebob, yeah. what I mean is that the means of rewarding can - and I argue should - be different from what they are now.
05:19:39 <geocalc> visof lopok at ghc sources you should have a good knowledge of haskell after (and it's free)
05:19:50 <geocalc> look*
05:20:03 <Beelsebob> wolverian: that's interesting... what methods of rewarding them would you propose?
05:20:14 <visof> geocalc ok
05:20:23 <Beelsebob> geocalc: that's cruel
05:20:33 <Beelsebob> visof: there are plenty of free learning resources on Haskell.org
05:20:37 <Beelsebob> just go look at the tutorials there
05:20:45 <visof> ok
05:20:58 <geocalc> that too
05:21:02 <Beelsebob> if you don't get enough from that, I'd recommend either Graham Hutton's book, or Simon Thompsons (which may be cheeper)
05:21:47 <Beelsebob> or Tony Davie's... but only because then it's my mum you're paying royalties to :P
05:22:07 <geocalc> lol
05:22:24 <sjanssen> cabal++ configurations are easy and useful!
05:23:07 <sjanssen> therp++ Xft in xmonad!
05:24:20 <geocalc> c2hs-- uninstallable on ghc 6.8.1
05:24:52 <dcoutts> geocalc: oh yes, I need to do a new release
05:25:08 <dcoutts> thanks for reminding me
05:25:13 <geocalc> ;)
05:25:36 <Botje> ghc-- # not superior over every other language yet.
05:25:47 * Botje sits and waits for SPJ to answer "oh, thanks for reminding me"
05:26:13 <dcoutts> hah hah
05:26:40 <dcoutts> Botje: but that one isn't true! ghc is superior over every other language already :-)
05:26:42 <dcoutts> ghc++
05:26:46 <dcoutts> @karma ghc
05:26:54 <dcoutts> lambdabot?
05:26:57 <dcoutts> @botsnack
05:27:22 <Botje> \bot is sluggish from eating too many botsnacks
05:29:04 <fasta> If I let multiple threads write to the same file with appendFile, and suppose thread 1 writes 11111, thread 2 writes 22222 etc. Is it possible that the file contains 12345 afterwards as substring?
05:29:19 <fasta> Or in other words: is appendFile atomic?
05:29:43 <wolverian> Beelsebob, sorry, I was on the phone. I think reading Cory Doctorow's essays (or, indeed, books) might give a better picture of the whole thing. for an example, see http://craphound.com/someone/Cory_Doctorow_-_Someone_Comes_to_Town_Someone_Leaves_Town.htm, namely, the introduction.
05:29:52 <mornfall> fasta: I wouldn't assume anything at all, but that's me.
05:29:55 <Botje> fasta: that depends on your Os, i think.
05:30:11 <fasta> mornfall: I am not assuming anything.
05:30:16 <mornfall> fasta: Like not even that it will contain an interleaving of the stuff you wrote there in different threads.
05:30:28 <mornfall> Could be complete trash as far as I can guess.
05:30:30 <Botje> fasta: it would certainly help if you flushed directly after writing
05:30:32 <mornfall> But you can always try in C.
05:30:40 <fasta> mornfall: ?
05:30:44 <Botje> but that's likely to fail too.
05:30:45 <fasta> mornfall: why would I need C for that?
05:30:46 <mornfall> And see what the platform can get you.
05:30:59 <Botje> I think you'd best use some kind of writer lock
05:31:13 <fasta> These things should be specified.
05:31:17 <mornfall> Why?
05:31:23 <mornfall> It's most of the time a nonsense to do that.
05:31:24 <Beelsebob> wolverian: In reading his "short term" passage, it's very tempting to believe him -- but he has no scientific evidence, that he didn't in fact lose half a million sales, and grossly underestimate demand
05:31:27 <mornfall> Why not write to different files?
05:31:30 <fasta> Either appendFile does it or it doesn't.
05:31:41 <geocalc> a nmultibuffer is missing
05:31:51 <geocalc> -n*
05:31:58 <mornfall> fasta: Why do you think that's the case?
05:32:28 <mornfall> Such universal rules don't work even with specified behaviour (say POSIX-required), much less with something unspecified.
05:33:00 <quicksilver> fasta: I know for sure that hPutStr is not atomic
05:33:03 <mornfall> And haskell implementations already need to work with both POSIX and some non-POSIX systems...
05:33:06 <quicksilver> fasta: because I have witnessed it
05:33:12 <wolverian> Beelsebob, yeah. sorry, couldn't think of a better source right now. I'll try to dig up some (his site will probably have them). my position is that it is just not tenable to keep the current copyright regime, so whether you lose money or not is irrelevant. (it is a bit extreme, perhaps.)
05:33:16 <quicksilver> fasta: my suspicion would be that appendFile might not be.
05:33:53 <quicksilver> fasta: I would always use a Chan for such. (Indeed, that's what I changed my code to do).
05:34:10 <Beelsebob> wolverian: I'm yet to be convinced that it's untennable too -- we've been running on honesty to buy the bloody thing for years, I don't see why that should change simply because we've got a digital thing, instead of a photocopier and a piece of paper
05:34:20 <mornfall> Well, I still don't get what is the use-case.
05:34:20 <fasta> mornfall: actually, I don't give anything about POSIX or non-POSIX systems, per se. I am programming Haskell and the documentation for Haskell should state the behaviour since Haskell is supposed to be a higher-level language.
05:34:32 <geocalc> Beelsebob=<< patents kill progress
05:34:35 <mornfall> fasta: ... well, your call.
05:34:43 <Beelsebob> geocalc: hmm?
05:34:52 <quicksilver> fasta: I agree. The documentation for appendFile misses out a lot.
05:35:13 <fasta> I hate this "guessing what a function does".
05:35:24 <waern> geocalc: you can just change one line in c2hs' cabal file to make it work with ghc 6.8
05:35:40 <geocalc> ? 1
05:36:04 <mornfall> fasta: You are surely welcome to write more and better documentation.
05:36:20 <geocalc> where ? waern
05:36:32 <wolverian> Beelsebob, oh, I guess I buy the whole information wants to be free morality.
05:36:46 <fasta> mornfall: I am sorry, but I haven't seen you here, like ever, so why would I care about your opinion?
05:37:10 <mornfall> In that case, you certainly shouldn't.
05:37:17 <Beelsebob> wolverian: so do I, but that doesn't mean that I agree that the people who are very tallented at spending a lot of time producing said information should not be rewarded for their time and effort
05:37:21 <fasta> mornfall: unless you have written more bug reports than me, I suggest you don't say those kinds of things.
05:37:36 <Beelsebob> after all, those who produce ideas, still need physical things to stay living
05:37:54 <Beelsebob> I do like the description of DRM
05:37:57 <wolverian> Beelsebob, sure. the rewards just should be based on something less restrictive to the spread of knowledge. I agree that I'm not making a very good case.
05:38:08 <Beelsebob> "The worst technology idea since the electrified nipple-clamp"
05:38:39 <Beelsebob> wolverian: nah, you're making a fairly good case -- just I'm deliberately playing devils advocate
05:38:42 <geocalc> the solution is matter-generators Beelsebob
05:38:46 <dmwit> Information wants to have liberty, but that doesn't need to mean it has no cost.
05:38:51 <Beelsebob> geocalc: I've often thought that
05:38:58 <wolverian> dmwit, sure. I'm not arguing about money.
05:39:02 <Beelsebob> as soon as matter can be produced freely as well as information, we're sorted
05:39:03 <fasta> I wouldn't be surprised when DRM would work in 20 years.
05:39:20 <Beelsebob> fasta: oh? but DRM is a fundamentally flawed idea
05:39:26 <fasta> Beelsebob: no, it isn't.
05:39:43 <Beelsebob> person a encrypts an item, and attempts to send it to person b, without person b being able to decrypt it
05:39:47 <fasta> Beelsebob: ...
05:39:56 <fasta> Beelsebob: do you really think that I don't know that?
05:39:59 <Beelsebob> any cryptographer is gonna tell you that that's fundamentally flawed
05:40:10 <Beelsebob> fasta: no, I'm interested in what your counter argument is
05:40:32 <fasta> Beelsebob: the point of DRM is to make it so difficult for people to copy it that they won't.
05:40:49 <geocalc> lol
05:40:51 <fasta> Beelsebob: yes, you can build expensive machines to still read the output.
05:40:52 <therp> fasta: then mallory comes along and strips of DRM
05:41:17 <fasta> I am not saying I think DRM is a good idea, but that's irrelevant.
05:41:17 <wolverian> fasta, it's hard to do that in a way that wouldn't be made null when one party cracks the DRM.
05:41:26 <Beelsebob> fasta: yes, but I don't think it'll ever be possible to produce said sufficiently difficult to break DRM
05:41:45 <fasta> Beelsebob: it's just how you define "break".
05:41:46 <Beelsebob> after all, look at things like Blue Ray disks, where the encryption was expected to take more than a couple of years to break
05:41:54 <Beelsebob> in fact it was broken in under a month
05:42:05 <dmwit> "It is sometimes in the central authority?s best interest not to blacklist a compromised device key even when they have the ability to do so."
05:42:10 <wolverian> fasta, of course, I think both BluRay and HD-DVD are trying to do exactly that, with the player keys on the discs.
05:42:13 <dmwit> www.freedom-to-tinker.com/?p=1108
05:42:29 <Beelsebob> remember, safe builders don't ever sell "unbreakable safes" they sell safes with a "mean time to breaking" on them
05:42:29 <fasta> dmwit: right
05:43:34 <Beelsebob> dmwit: unfortunately for said central authority's interests, *all* keys need to be revoked
05:43:40 <Beelsebob> because there's an algorithm for producing them now
05:43:57 <waern> geocalc: move build-tools field to the library stanza, and add  process, directory, array, containers, pretty to the deps
05:43:58 <waern> s
05:44:00 <fasta> Oh, and this "unbreakable", only works when P/=NP and you assume people don't download broken movies of the net(but you can make that work with extreme laws).
05:44:01 <dmwit> Beelsebob: I wasn't actually trying to make a point in the ensuing argument.
05:44:07 <dmwit> I was rather trying to derail the argument. =P
05:44:11 <flux> beelsebob, I actully don't see why it would be impossible to create a system that's considerable more difficult to break than the systems have been..
05:44:14 <wolverian> hah, haskell school of expression is 133 euros here
05:44:19 <hpaste>  mmorrow annotated "is there a way to make this a one-liner?" with "(no title)" at http://hpaste.org/3906#a3
05:44:20 <wolverian> that is insane.
05:44:24 <fasta> wolverian: it is.
05:44:24 <Beelsebob> dmwit: ah, okay
05:44:47 <geocalc> ok waern thanks
05:45:03 <flux> just a simple version: encrypt everything with a secret key, embed said secret key to a secure display device, after a stage where it takes much effort to get the signal back
05:45:09 <Beelsebob> fasta: flux: I agree that it's probably possible to do... but my suspicion is that creating such a scheme that goes into silly time to crack, requires silly time in its self
05:45:32 <fasta> Beelsebob: that's just what you want to believe.
05:45:34 <wolverian> flux, that's what HDCP tries to do.
05:45:40 <flux> wolverian, exactly :)
05:45:43 <Beelsebob> flux: okay then, I'll take appart said display device, grab the keys, and publish them on the intermawebs
05:45:57 <Beelsebob> admitedly the take appart stage is hard
05:46:02 <fasta> Beelsebob: you assume you can take apart all devices.
05:46:08 <flux> beelsebob, you actually won't do that, because the keys may recide on a ibm cryptochip, which you will most likely fail to retrieve the keys from
05:46:14 <Beelsebob> fasta: I do indeed, there's nothing a sledgehammer can't break :P
05:46:21 <Beelsebob> remember -- safes are rated in time to crack them
05:46:21 <flux> hm, reside
05:46:24 <wolverian> cryptochips are not uncrackable, or even meant to be
05:46:25 <Beelsebob> not as uncrackable
05:46:28 <wolverian> (with physical access)
05:46:50 <fasta> Beelsebob: what if your sledge-hammers will start a chemical reaction melting everything of interest?
05:47:11 <Beelsebob> fasta: there are many safes that do exactly that -- but still people manage to get into them
05:47:20 <flux> hmm
05:47:23 <Beelsebob> all it means is that I require a professional safe cracker
05:47:30 <Beelsebob> or to become one
05:47:41 <flux> how about a safe that listens to sounds (ultrasound) and after sufficient levels self-destructs?-)
05:47:51 <Beelsebob> ... same thing
05:47:53 <fasta> Beelsebob: well, I highly doubt anyone get into some safes I have heard of.
05:47:57 <Beelsebob> there's always a clever safe cracker
05:48:00 <wolverian> fasta, they don't need to crack _all_ the devices, only one.
05:48:25 <dmwit> fasta: I dare you to make a foolproof system.  I've got some very talented fools...
05:48:35 <wolverian> fasta, if there's a device blacklist in the content (like in AACS), they need to crack one device per month, or release, or whatever. which isn't hard.
05:48:38 <therp> talented fools lol :)
05:48:41 <flux> beelsebob, I think another thing to balance extreme measures out is that one doesn't really like the documents inside the safe being destroyed unless they really need to be
05:48:43 <Beelsebob> anyway, is anyone genuinely going to buy this mystical monitor that destroys itself if you bump into it, or make a sound over 1dB above ambient
05:48:54 <wolverian> fasta, you can make it _hard_, but you can't win with technology. only law can give an edge to the content distributors.
05:49:08 * Beelsebob has to side with wolverian on that one
05:49:17 <flux> beelsebob, maybe it can just disable itself so that a technician needs to service it ;)
05:49:23 <Beelsebob> not only that, but there is no *need* to make it hard with technology
05:49:37 <Beelsebob> we have after all not been putting complex locking mechanisms on VHS tapes and books
05:49:45 <Beelsebob> and yet people still bought them
05:50:08 <Beelsebob> flux: but the whole point was to destroy the chip so I couldn't grab keys off it
05:50:47 <flux> beelsebob, service = replace the chip..
05:51:01 <Beelsebob> flux: and you expect people to do this every time they laugh loudly at the TV?
05:51:30 <dmwit> Yes!
05:51:32 <flux> beelsebob, well, obviously the measures were a bit extreme and nonsuitable for this case
05:51:35 <dmwit> Humour is not allowed here.
05:51:37 <fasta> Beelsebob: that would be quite funny to see, but no.
05:51:43 <Beelsebob> fasta: :
05:51:44 <Beelsebob> :D
05:51:47 <Beelsebob> a really good example is chip and pin bank cards, and the banks even have the advantage there, person b and c aren't the same person.
05:51:49 <fasta> HAHAHA!, Oh, damn!
05:51:56 <Beelsebob> they were meant to be "uncrackable"
05:52:13 <Beelsebob> and yet, 2 years later, processing power is high enough that they can be broken in a matter of hours
05:52:42 <fasta> Beelsebob: no, they were not meant to be "uncrackable".
05:52:48 <fasta> Beelsebob: they only advertised that.
05:52:51 <Beelsebob> haha
05:52:52 <Beelsebob> :D
05:52:53 <fasta> Beelsebob: completely different things
05:53:00 <Beelsebob> fair point
05:53:22 <fasta> If you want something "uncrackable" I suggest you try to tap into feeds of the US army.
05:53:40 <fasta> I doubt they will find it cool that you do that, though.
05:53:51 <Beelsebob> hmm, I thought they used RSA
05:53:56 <Beelsebob> and AES
05:54:14 <Beelsebob> both of which have known flaws... just they can have the key length turned up high enough to mask them
05:54:38 <fasta> Beelsebob: What flaws does RSA have?
05:54:46 <Beelsebob> anyway, if I want something fun to crack, I only need look at the signals they're transmitting from germany right now
05:54:51 <quicksilver> surely there is a huge difference between trying to intercept a message
05:54:56 <quicksilver> which is from a to b, and you're c
05:54:58 <Beelsebob> fasta: I was under the impression that RSA with <=64bit keys could be cracked in hours
05:54:58 <quicksilver> which is very hard
05:55:09 <quicksilver> and trying to crack a message which is *for you*
05:55:17 <Beelsebob> quicksilver: indeed -- the point I was trying to make
05:55:18 <fasta> Beelsebob: and it was never meant to be used with <=64 bits
05:55:28 <quicksilver> the point about the DRM is that the decryption key lives inside your PC/DVD player or whatever
05:55:36 <quicksilver> all you need to do is poke about till you find it
05:55:40 <Beelsebob> fasta: true, but it is flawed, and as CPU power increases the key length will have to too
05:55:41 <therp> beelsebob: the whole encryption business is about the length of keys and the number of rounds, both turn weak ciphers into strong ones.. so every cipher has flaws, but they are masked sufficiently by those two parameters
05:55:50 <fasta> Beelsebob: 700-800 bits is 3 months CPU time of a super computer now.
05:56:19 <fasta> Well, that was a few years ago. Probably a month now.
05:56:25 <Beelsebob> quicksilver: indeed -- or if it turns out you can't do that, you could always just attach a large, high res digital camera to the front of your monitor, and record the data straight back in
05:56:25 <fasta> Beelsebob: ???
05:56:36 <Beelsebob> admitedly that takes time
05:56:40 <therp> beelsebob: CPU power does not increase fast in comparison to key length. I once calculated to number of bits of entropy that are required even under very unrealistic technology growth models
05:56:44 <Beelsebob> but it'll always beet DRM
05:57:15 <Beelsebob> fasta: anyway, if I want a challenge, I'll merely listen to the enigma code they're transmitting from germany atm
05:57:33 <fasta> Beelsebob: what's a challenge about that? The answer has been documented already, AFAIK.
05:57:50 <Beelsebob> fasta: indeed -- the challenge is to make a bog standard PC do it faster than 1940s hardware
05:58:15 <therp> that shouldn't be hard..
05:58:20 <Beelsebob> (collosus has been rebuilt, and they're challenging people to try to crack enigma faster than collosus can)
05:58:26 <Beelsebob> which apparently really is very hard to do
05:58:46 <fasta> On what technology was colossus based?
05:58:48 * therp wants known plaintext attacks just like in WWII
05:58:57 <Beelsebob> fasta: ask alan turing :P
05:59:05 <fasta> I will ask Wikipedia
05:59:19 <Beelsebob> therp: sure, but said known plaintext attacks got fed into collosus
05:59:30 <hpaste>  mmorrow annotated "is there a way to make this a one-liner?" with "(no title)" at http://hpaste.org/3906#a5
05:59:31 <Beelsebob> your challange is to do the processing to figure out the key, faster than collosus can
05:59:38 <fasta> Oh, it was electronic.
05:59:49 <fasta> Not surprising that it's hard to beat then.
05:59:53 <Beelsebob> fasta: yes, although I believe large chunks were still mechanical
06:00:10 <Beelsebob> for example the bit that produced keys, was still sets of mechanical rotors churning through posibilities
06:01:14 <therp> beelsebob: interesting. my bet is against collosus though. I simply can't imagine 1940 technology to be superior to anything similar constructed in the 21th century, but we'll see
06:02:07 <Beelsebob> therp: remember (a) that collosus was designed by a computing god (b) it's a special purpose machine -- it's programable only in the sense that it can be given different "menus" with which to try to crack enigma
06:02:16 <Beelsebob> so it's probably still a pretty nasty challenge
06:02:44 <Beelsebob> on the other hand -- I wouldn't be surprised if someone clever writing something massiely parallel in occam or erlang, managed to do it
06:02:49 <EvilTerran> collosus didn't have to run an OS alongside its cracking attempt
06:03:03 <Beelsebob> EvilTerran: I don't *think* you have to run Fista on the PCs :P
06:03:20 <Beelsebob> ohhh
06:03:23 <Beelsebob> and just now on the BBC
06:03:24 <EvilTerran> heh, indeed
06:03:49 <Beelsebob> "An amateur cryptographer has beaten colossus in a code-cracking challenge set up to mark the end of a project to rebuild the pioneering computer."
06:04:27 <EvilTerran> just a few days ago I was discussing with someone how having a standard stripped-down OS that could be bundled onto computer game discs would be at least interesting
06:04:49 <hpaste>  (anonymous) annotated "is there a way to make this a one-liner?" with "(no title)" at http://hpaste.org/3906#a6
06:05:12 <Beelsebob> EvilTerran: indeed -- unfortunately, it would probably require crazy things like drivers for every single graphics card under the sun, etc
06:05:22 <Beelsebob> and thus, your game would stop working the second a new graphics card came out
06:05:29 <EvilTerran> mmm
06:06:05 <EvilTerran> something with a non-ROM component'd be good, so it could download drivers as it needed them
06:06:15 <EvilTerran> and then cache them for later use
06:06:56 <Beelsebob> interesting
06:07:11 <EvilTerran> maybe put it on a USB stick?
06:07:17 <Beelsebob> but you're then opening it up for people to be given whatever the graphics card maker wants them to have
06:07:37 <EvilTerran> hm?
06:07:54 <Beelsebob> I don't like the idea of saying "yes you can put anything you like on my computer" to big companies
06:08:07 <Beelsebob> especially when evidence says big companies (like Sony) will put malicious things there
06:08:09 <nominolo> @seen bringert
06:08:13 <rabbit64> EvilTerran, you can put in on the hard disk for example, and then you can put there your os as well :P
06:08:13 <integral> virtual machines.  "You can put anything you like inside a virtual machine on my computer"
06:08:54 <nominolo> is it just me or is lambdabot sleeping?
06:09:02 <Beelsebob> rabbit64: the point though is that there's problems with incompatabilities in games -- even within windows
06:09:28 <Beelsebob> but I don't see quite how this solves them
06:09:36 <Beelsebob> because incompatablitity with drivers can always be introduced
06:10:12 <EvilTerran> my primary thought was performance
06:10:23 <rabbit64> me neither, would you be able to run another (web) applications parallelly with the game?
06:10:32 <Beelsebob> except that windows is actually fairly well built for game performance (if nothing else)
06:10:44 <Beelsebob> remember, it's so well built for game performance, that the XBox runs it
06:11:15 <rabbit64> Beelsebob, the OS would support all hardware?
06:11:21 <rabbit64> or EvilTerran ...
06:11:22 <Beelsebob> rabbit64: exactly
06:11:27 <Beelsebob> it would have to download components
06:11:35 <Beelsebob> and then you get the incompatibility issues straight back
06:11:43 <EvilTerran> hey, it was just an idle thought i came up with in the pub
06:11:44 <rabbit64> exactly
06:12:00 <Beelsebob> yeh, I think I've had a discussion about this one in the pub too
06:12:12 <rabbit64> Isn't xbox so fast because it is built to use one hardware configuration as well (or i'm mistaken)?
06:12:18 <Beelsebob> sorry, didn't mean to rip it to shreds, melery to have a fun argument
06:12:33 <Beelsebob> rabbit64: plausable -- it does also have a damn nice hardware config
06:12:41 <Beelsebob> (3 3Ghz G5s IIRC)
06:12:52 <rabbit64> hmm not bad ;)
06:13:10 <Beelsebob> not quite as shiny as the PS3s hardware
06:13:26 <Beelsebob> and yet... the Wii is still the best console out there, with it's little 700Mhz PIII
06:13:33 <Beelsebob> and 8MB of graphics memory
06:13:41 <rabbit64> I still think you would not get very big performance improvement
06:14:53 <Beelsebob> tbh, If I want to play games, I'll sit and play peggle on my mac
06:15:05 <Beelsebob> can't be arsed with silly shooting games
06:16:23 <rabbit64> I like them...for example when I want to kill people, so I don't have to kill the real ones ;)
06:16:57 <rabbit64> i mean to abreact
06:17:26 <Beelsebob> hehe
06:18:59 <pejo> Beelsebob, you seriuosly saying that the Wii is a PIII?
06:19:29 <visof> how can i write >_/ in haskell?
06:19:43 <Beelsebob> sorry, it isn't a PIII, it's a PPC
06:19:47 <Beelsebob> 729Mhz PPC chip
06:19:57 <Beelsebob> with a 243 Mhz ATI graphics card
06:20:12 <Beelsebob> 88MB of system RAM, and 3MB of embeded GPU RAM
06:20:39 <Beelsebob> that's it
06:20:48 <Beelsebob> it's pretty crappy hardware, but awesome fun
06:20:51 <integral> wow.
06:21:24 <rabbit64> visof, with keyboard o_O ?
06:21:39 <visof> isDigit   ::
06:21:40 <visof>              c ’0’ ∧ c ’9’
06:21:40 <visof> isDigit c =
06:22:05 <visof> greater than and equal?
06:22:14 <visof> > and equal?
06:22:33 <rabbit64> >=
06:22:41 <integral> ≱ == <
06:22:48 <integral> ≥ == >=
06:23:42 <visof>  ≥ how can i do this?
06:23:49 <rabbit64> ">="
06:23:50 <integral> ≥ is >=
06:23:57 <visof> ok
06:25:03 <bringert> hi nominolo
06:25:21 <rabbit64> btw, this haskell is a genious language, i'm getting in love with it, even though I hated it 2 days ago
06:25:31 <osfameron> > groupBy (\a b->isLetter a == isLetter b) "take1thing"
06:25:37 <nominolo> bringert: hi there.  i have a location idea for Hac 08
06:25:43 <flux> rabbit64, what made you venture further - or is it mandatory?-)
06:25:49 <bringert> nominolo: yes?
06:25:56 <flux> or plain persistence..
06:25:58 <osfameron> is there a function like groupBy that does the above?  e.g. alternates the predicate?
06:26:51 <rabbit64> flux, you can write really serious things on a few lines, and you can prove your algorithm relatively easily
06:27:18 <osfameron> I mean something like >  let groupBy2 f = groupBy (\a b-> f a == f b)
06:27:28 <osfameron> I was sure I'd seen something like it but now can't find it
06:27:44 <rabbit64> I think I'm going to haskell the whole weekend!
06:27:51 <rabbit64> ;)
06:28:50 <kfish> rabbit64, but if you haskell 4 days in a row, your brain will go tripsy and it will never work the same way again! be careful!
06:29:31 <rabbit64> well, I'm not really sure If my brain works well now ;), i think I have nothing to loose :D
06:32:03 <kfish> rabbit64, then have fun with it :-)
06:32:21 <kfish> btw. what is the first thing you would want to build with haskell?
06:32:26 <rabbit64> kfish, you bet i will!
06:33:08 <visof> > [ x*y | x <-[1..3], y <- [4..6],even x*y]
06:34:08 <rabbit64> I don't know...i think some kind of module for maxima program, that draws and shows graphs interactivelly...provided it doesn't exist, but i doubt i will succeed
06:34:22 <visof> is filter here for the result or for the Input?
06:35:33 <rabbit64> kfish, and I have no experience with modules, IO's...or I just write some stupid program that calculates something
06:36:18 <kfish> rabbit64, what tutorials/books are you using?
06:36:45 <rabbit64> just online book from my school, but i have downloaded some from google
06:37:14 <EvilTerran> ?src on
06:37:21 * yaxu comes back from lunch, finds he missed an interesting copyright discussion
06:37:36 <kfish> yaxu, it's still raging on #haskell-blah ;-)
06:37:44 <yaxu> ah good
06:37:51 <rabbit64> kfish, btw how it is to make programs that utilize mouse, graphics and this stuff? (can haskell do it well?)
06:37:51 <EvilTerran> osfameron, I think groupBy ((==) `on` f) would do what you want
06:38:37 <rabbit64> I mean if there are some modules for that...I want to do it relatively quickly
06:38:50 <kfish> rabbit64, yes, eg. gtk2hs is pretty nice to use
06:39:08 <osfameron> EvilTerran: ah, yes 'on' sounds like what I vaguely remembered, ta
06:39:19 <osfameron> EvilTerran: where does it live?
06:39:30 <EvilTerran> er... the 6.8 prelude?
06:39:41 <osfameron> dammit, I have 6.6.1
06:39:59 <Saizan_> Data.Function
06:40:08 <kfish> rabbit64, YAHT is a pretty nice tutorial to work through for a weekend :-) seeing as you need to learn about modules and IO quickly
06:40:38 <osfameron> ah, I don't have Data.Function.  I think I'll install 6.8
06:40:39 <fasta> quicksilver: the point of the Chan was to have all your threads write to it, but I don't see how that would speed up the appendFile? It seems you are just delaying it then. As input I have a list of strings I want to append to a file foo.
06:40:43 <rabbit64> thx kfish i will check it out right now
06:41:53 <shachaf> EvilTerran: No, Data.Function.
06:41:59 <shachaf> Oh, never mind.
06:42:10 <shachaf> on f g x y = g x `f` g y
06:43:24 <rabbit64> lol there is even an opengl module
06:44:45 <hpaste>  pierre pasted "framework for computer physics lessons" at http://hpaste.org/3916
06:47:26 * osfameron checks out the packages in http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
06:52:30 <quicksilver> fasta: I wasn't trying to speed it up?
06:52:39 <quicksilver> fasta: I was trying to promise you didn't get data interleaved?
06:52:43 <quicksilver> fasta: wasn't that your question?
06:52:46 <fasta> quicksilver: oh, then I wasn't clear enough.
06:53:02 <fasta> quicksilver: Yes, I understood that you were making sure of that.
06:53:05 <quicksilver> I thought you were concerned about multiple appendFiles interleaving with each other
06:53:33 <fasta> quicksilver: the data is already available in one thread. There was no problem with interleaving.
06:53:47 <fasta> quicksilver: I wanted to make it more I/O bound.
06:54:32 <osfameron> can I compile ghc 6.8.1 in less than 3 hours?
06:55:47 <quicksilver> osfameron: what CPU?
06:56:16 <osfameron> quicksilver: er dunno...
06:56:35 <fasta> osfameron: what OS?
06:57:32 <osfameron> fasta: linux (ubuntu 6.10)
06:57:42 <fasta> osfameron: cat /proc/cpuinfo
06:58:13 <osfameron> fasta: ta, Intel(R) Pentium(R) M processor 1.40GHz
06:58:51 <quicksilver> osfameron: probably take you an hour or two on that, I expect
06:58:52 <quicksilver> 13:28 < fasta> If I let multiple threads write to the same file with
06:58:52 <quicksilver>                appendFile, and suppose thread 1 writes 11111, thread 2 writes
06:58:52 <quicksilver>                22222 etc. Is it possible that the file contains 12345
06:58:52 <quicksilver>                afterwards as substring?
06:59:05 <quicksilver> ^^ I can see why I thought what I thought :)
06:59:17 <fasta> quicksilver: yes, I wasn't clear.
06:59:22 <osfameron> quicksilver: cool.  (If it doesn't overheat and shut down, as my laptop likes doing when it gets stressed)
06:59:41 <fasta> osfameron: you should return your laptop :)
06:59:42 <quicksilver> fasta: I imagine it's faster (more IO-bound) to leave the file open than append each time
06:59:48 <quicksilver> if that's suitable for your needs
07:00:16 <fasta> quicksilver: well, it's not that important, I just wondered how a proper solution could look like.
07:00:21 <quicksilver> and depending where the data is coming from, the bytestring versions of the handle writing functions are more likely to have high IO throughputs
07:00:39 <salierix> Is it possible to embed a haskell interpreter inside a haskell application?
07:00:48 <quicksilver> salierix: yes; see hs-plugins
07:01:04 <quicksilver> it's not 100% straightforward, hs-plugins is a bit fiddly to get to compile
07:01:42 <bringert> salierix: you can also use the GHC API
07:01:54 <salierix> Oh?
07:03:19 <dikini> how portable are implicit parameters?
07:04:27 <EvilTerran> with -C0, is ghc's context switching guaranteed to be fair?
07:08:23 <matveev> where binary
07:08:46 <matveev> @where bnary
07:08:56 <matveev> @where binary
07:09:13 <matveev> @src fst
07:10:31 <quicksilver> the bot's dead
07:10:37 <quicksilver> (long live the bot!)
07:10:49 <EvilTerran> @bot?
07:10:54 <EvilTerran> :(
07:11:46 <reqamst> lambdabot: wake up!
07:17:57 <wli> I still can't afford ATTaPL. :(
07:18:08 <visof> http://www.msxnet.org/humour/girls-are-evil.jpg
07:21:30 <kfish> http://www.cse.unsw.edu.au/~dons/binary.html
07:21:40 <kfish> fst            :: (a,b) -> a
07:21:46 <kfish> fst (x,_)       = x
07:22:18 <fasta> visof: there's #haskell-blah for that
07:23:09 <idnar> besides, the algebra there is all wrong
07:23:11 <visof> define blah?
07:23:38 <idnar> you get |evil| not evil
07:24:51 <visof> i didn 't do this
07:24:57 <visof> i found it
07:24:59 <rabbit64> absolute evil?
07:25:43 <visof> it 's a joke
07:26:10 <EvilTerran> @quote joke
07:26:24 <EvilTerran> bah... "never let the facts get in the way of the joke", etc
07:26:31 <rabbit64> what does the joke function?
07:28:27 <visof> sorry for all girls here and don t sorry for guys
07:31:16 <fxr> girls?
07:31:32 <fxr> is this a joke?
07:36:28 <rabbit64> joke x y = 2^z
07:37:54 <fxr> anybody seen uwe schimdt? I cannot communicate with him via e-mail around 2 weeks
07:45:59 <phlpp> hi
07:46:20 <jedbrown> Does anyone know of any effort on hMPI since 2001?  I want to bring it up to date, but I don't want to duplicate work.
07:46:39 <byorgey> hi phlpp.
07:47:17 <geocalc> hmpi ?
07:47:47 <jedbrown> geocalc: Haskell bindings for MPI.  It is on the wiki, but pretty dated.
07:48:01 <geocalc> ok
07:48:46 <idnar> I thought MPI was dead or something
07:49:16 <jedbrown> idnar: What made you think that?
07:49:16 <dmead> openmosix is dead
07:49:19 <dmead> not mpi
07:49:20 <dmead> i think
07:49:42 <dmead> the maintainer quit cause it would be too much effort to port to 2.6
07:49:45 <dmead> or something
07:49:50 <dmead> or it was impossible, etc
07:50:40 <idnar> oh, that might be what I was thinking of
07:51:50 <dmead> mosha bar
07:51:52 <dmead> is his name
07:52:13 <dmead> yea
07:52:14 <dmead> http://en.wikipedia.org/wiki/Moshe_Bar
08:00:44 <matveev> jedbrown: hMPI does not even compile with 6.6, refers to something missing named as strangly as "Addr"
08:04:06 <jedbrown> matveev: Yeah, I'm aware of that.  Not too much of a surprise considering how old it is.  I'm trying to decide whether to start over or work on the old code.
08:06:02 <matveev> It seems that ForeignPTr was not avalable at that time. ANd now Addr is not avaialble anymore. I am not good enough in Hskell to be able to port it.
08:07:41 <quicksilver> addr is stll there in GHC.Base, I think
08:07:49 <quicksilver> GHC.Base.Addr# perhaps?
08:07:57 <quicksilver> but, I don't think that's the encouraged way to work :)
08:10:02 <jedbrown> I'm new to FFI, but its something I've been meaning to learn and this seems like a good time.
08:19:40 <matveev> autoconf was also broken, uses obscolete ghc flags and m4 macros. But I reached my limit at details of the interface *between* Haskell and FFI.
08:24:00 <jedbrown> In principle, the bindings should be pretty simple.  There are no data structures.
08:24:51 <jedbrown> I want bindings to at least a subset of MPI-2, so there is a lot of new stuff anyway.
08:29:00 <matveev> I understood that there are both "bindings" and (much fewer) haskellish abstractions for convenience.
08:29:04 <jedbrown> Eventually, I want to be able to manage distributed processes analogously to the Control.Concurrent.
08:30:39 <wli> What does Control.Concurrent do if thread creation fails?
08:31:50 <matveev> Right, the case with hMPI was a surprise to me. Everybody talks about multi-core and parallelizm but the interface to the "industry standard" rots.
08:31:53 <mrd> exception presumably
08:32:22 <quicksilver> wli: forkIO has no realistic chance of failing
08:32:22 <mrd> I haven't seen an "industry standard" worth interfacing to
08:32:23 <wli> As in the programdies.
08:32:29 <quicksilver> wli: only heap exhaustion
08:32:39 <defcons> @hoogle [a] -> Int
08:32:41 <quicksilver> it doesn't consume any OS-level resource
08:32:44 <quicksilver> (Except a bit of memory)
08:32:55 <defcons> lambdabot, hurry up, damn you
08:33:01 <mrd> length :: [a] -> Int
08:33:16 * mrd beats the bot
08:33:17 <jedbrown> Well, everyone has multi-core on their desk these days.  But for large-scale parallel, MPI is the only practical thing.
08:33:18 <defcons> aah, wrong thing anyway
08:33:20 <wli> quicksilver: forkOS for a blocking call, etc.
08:33:29 <defcons> @hoogle [a] -> a -> Int
08:33:30 <quicksilver> wli: even forkOS doesn't spawn a new OS thread
08:33:40 <defcons> thanks mrd. I meant what I just wrote
08:33:42 <quicksilver> wli: forkOS just marks the haskell thread it spawns as being 'bound'
08:33:42 <mrd> defcons: flip index or something
08:33:48 <quicksilver> wli: unless I am wrong :)
08:33:54 <allbery_b> @bot
08:33:56 <mrd> findIndex?
08:34:10 <wli> jedbrown: I thought 4096 CPU SGI Altix machines with 16TB RAM were used for that.
08:34:36 <jedbrown> wli: not many shared memory machines on the tops500...
08:35:24 <jedbrown> wli: besides, even big shared memory machines frequently use MPI since it provides a much more flexible interface to parallelism.
08:35:32 <defcons> mrd, is there no way to count the amount say, number 1s in a list?
08:35:37 <wli> It varies with the type of problem.
08:35:39 <mrd> length with filter
08:35:41 <defcons> I mean, is there already a function for this
08:35:47 <defcons> right
08:36:10 <jedbrown> wli: The only competition is OpenMP which is not nearly as flexible.
08:36:13 <wli> There are problems that don't fit the distributed memory paradigm.
08:36:37 <mrd> OpenMP is a giant load of crap
08:36:43 <wli> And generally you don't get to pick your problem; you're just limited by your budget in what you can do about it.
08:36:52 <mrd> at least GOMP is
08:38:59 <jedbrown> wli: With shared memory, you can still use MPI and the implementation will not use the network.
08:39:26 <wli> I'm sure there are people who don't get it floating around who say "Just throw a cluster of cheap PC's at it" and will never understand (perhaps deliberately refusing to do so) that it's a doorstop for the problem at hand.
08:39:52 <wli> Like ones in management, who sink the whole project with such mandates.
08:40:35 <jedbrown> Lots of people don't understand that latency is frequently a much bigger problem than bandwidth for HPC.
08:40:45 <vincenz> yep
08:40:52 <vincenz> bandwidth is esy
08:40:57 <vincenz> just put 1000 harddrives in a truck :)
08:44:03 <matveev> that is why "sparking" evaluation of each and every symbol will never work
08:44:48 <byorgey> heh, my networks text in college actually had a quote, "never underestimate the bandwidth of a station wagon filled with tapes" or something like that =)
08:45:57 <vincenz> byorgey: obviously that varies with time
08:46:24 <byorgey> vincenz: right, I think your version is more modern =)
08:46:36 <vincenz> or a container-ship filled with hard-drives :)
08:46:49 <byorgey> sweet!
08:47:32 <vincenz> woo, 1ziga-bit of bandwidth
08:47:37 <vincenz> latency....2 months
08:49:11 <dons> ?yow
08:49:33 * byorgey googles shipping container dimensions
08:49:38 <dons> url module failed in contextual handler: thread killed
08:49:55 <quicksilver> dons: always seems to be the url module?
08:50:07 <dons> yep. locks up when a website times out
08:50:08 <quicksilver> dons: can't you sandbox it a bit more so failures there don't bring down the whole bot?
08:50:16 <quicksilver> (says I, who have never looked at the code once)
08:50:17 <dons> i expect so
08:52:17 <byorgey> hm, about 40 PB per shipping container
08:57:00 <osfameron> meh, make[1]: *** [stage1/ghc-6.8.1] Error 1
08:57:02 <byorgey> @go 40 feet * 8 feet * 8.5 feet * ((200 GB) / (23 (in^3))) * 4000 / (2 months)
08:57:03 <lambdabot> ((40 feet) * (8 feet) * (8.5 feet) * ((200 GB) / (23 * (in^3))) * 4,000) / (2 months) = 30.355081 TBps
08:57:06 <osfameron> nothing better than a helpful error message
08:57:12 <byorgey> 30 terabytes per second, not bad! =D
08:58:31 <vincenz> byorgey: well I don't know how long a boat takes from e.g. US to japan
08:58:46 <vincenz> and it's 500GB :)
08:58:48 <byorgey> vincenz: actually, I bet it's faster than 2 months
08:58:54 <vincenz> so 75 TBs
08:58:54 <byorgey> yeah, I was being conservative =)
08:58:56 <vincenz> +
08:58:56 <vincenz> p
08:59:18 <vincenz> byorgey: right, still need time to fill the HDs :)
08:59:23 <vincenz> but we can assume they're all done in parallel
08:59:26 <vincenz> (given enough manforce :D)
08:59:34 <byorgey> vincenz: of course. =)
09:00:28 <vincenz> it's the same discussion in embeded systems as power vs energy
09:00:33 <vincenz> power is meaningless for embedded systems
09:00:50 <vincenz> power is only meaningful for : cooling at high end, and scavenging at serious low end
09:01:09 <vincenz> in the middle you're battery limiited, so energy-limited :)
09:01:31 <dons> so what's new in haskell land this week?
09:01:36 <dons> anyone doing something exciting?
09:02:30 <vincenz> dons: one sentence response to "why do you like FP?"
09:02:48 <dons> more productive, more fun
09:02:57 <geocalc> 2*
09:03:03 <vincenz> *1.5
09:05:32 <conal> dons: i'm working on a data-based representation for functions over infinite continuous domains.  for imagery etc.
09:05:57 <conal> using infinite binary trees, zippers, and infinite approximation streamas.
09:06:00 <dons> ah, now that sounds interesting :)
09:06:39 <RayNbow> @src replicate
09:06:39 <lambdabot> replicate n x = take n (repeat x)
09:06:43 <conal> it pokes at a discomfort i have with functional programming.  it encourages functions as first class values but gives a preference penalty for doing so.
09:06:58 <conal> since data reps cache but functions don't.
09:07:12 <byorgey> conal: neat!
09:08:11 <integral> @pl \ f k q -> f . k $ (q . f)
09:08:11 <lambdabot> ap (flip . ((.) .) . (.)) (flip (.))
09:08:20 <conal> in pan & pajama, when one zooms or pans, everything gets recomputed.  ditto for anti-aliasing passes.  my new rep has a huge amount of sharing.
09:08:29 <conal> anyway, i'm pretty excited about it.
09:08:31 <RayNbow> <dons> anyone doing something exciting? <-- not really, I made a simple backtracking algorithm for a puzzle in some students associate journal :p
09:09:29 <lament> is the puzzle sudoku? :)
09:09:34 <RayNbow> nope :p
09:09:39 <geocalc> @version
09:09:39 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
09:09:39 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:10:22 <RayNbow> "given a shape made out of equilateral triangles... in how many ways can you construct that shape using isosceles trapezoids with sides 1,1,1,2" <-- the description of the puzzle
09:10:33 <tuomov> I'm thinking of doing something exciting but dunno when I'll really have the time to finish the designs, let alone code..
09:10:44 <tuomov> (bah, grunt work, coding)
09:11:13 <geocalc> 6.6 dons excite yourself to 6.8.1
09:11:13 <conal> i'm wondering about possibilities for controlling data type layout in ghc
09:11:31 <dons> tuomov: oh, like what?
09:12:39 <tuomov> well, this started out as an FS project, but has evolved into something more interesting..
09:13:47 <conal> given http://hpaste.org/3910, if I add "!"s to the Pair fields, could i get Pair (Pair Float) to lay out as four sequential unboxed floats?
09:14:00 <tuomov> dunno what it will eventually evolve into
09:15:41 <dons> conal: check the core, with -ddump-simpl
09:15:54 <dons> i think so
09:16:33 <osfameron>  <dons> anyone doing something exciting? --> I'm attempting to write a 5 min lightning talk on Dope Wars in Haskell for the London Perl Workshop
09:16:48 <dons> oh,  cool.
09:16:58 <dons> behind enemy lines eh?
09:17:12 <osfameron> kinda (I'm one of the enemy :-)
09:17:53 <osfameron> they welcomed talks on other languages, and I thought it might be fun
09:18:17 <conal> dons: thanks.  i'd like your opinion on whether the thing i'm really going after is feasible.  i want an infinite stream of arrays of doubling size 1, 2, 4, ....  I want the stream to be lazy but the arrays strict.  And the sizes statically enforced.  A bottom-up binary tree (nested data type) looks just the thing.
09:19:05 <conal> the types are in that hpaste
09:19:54 <conal> i don't know if it's at all feasible to get the nested Pair values (successive tree rows) to be unboxed
09:20:03 <vincenz> I sincerely doubt it
09:20:15 <vincenz> the compiler would have to know how many there are
09:20:22 <vincenz> since you could have any nesting of Pair's
09:20:38 <vincenz> so you need some overhead, and since this is not a typical usecase, I think the compiler will stick to the default, which is boxes
09:21:18 <bsdemon-rus> hello all, can anyone help me with my program?
09:21:18 <bsdemon-rus> I have following definition of tree data structure: "Tree a = Node a [Tree a]"
09:21:18 <bsdemon-rus> Then simple function:
09:21:18 <bsdemon-rus> "deepElements' :: [Tree a] -> Int -> [a]"
09:21:18 <bsdemon-rus> "deepElements' [] _ = []"
09:21:30 <vincenz> bsdemon-rus: @paste
09:21:34 <bsdemon-rus> So hugs says: Cannot justify constraints in explicitly typed binding
09:22:17 <byorgey> bsdemon-rus: is that all of deepElements', or are there more lines?
09:22:49 <bsdemon-rus> yes little more
09:23:09 <byorgey> bsdemon-rus: why don't you paste it on hpaste
09:23:10 <byorgey> @paste
09:23:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:23:18 <hpaste>  bsdemon pasted "deepElements" at http://hpaste.org/3917
09:23:38 <conal> vincenz: makes sense.  i guess there'd have to be some kind of dictionary to carry the dynamic element size.
09:24:01 <bsdemon-rus> sorry
09:24:05 <andyjgill> Does anyone know is there is an RSS feed of all call for papers for Haskell/FP related conferences?
09:24:44 <dons> andyjgill: hmm
09:24:59 <dons> andyjgill: there's the types@ list and the haskell@ list, but i know of no central archive
09:25:32 <andyjgill> I just deleted yet another call for papers, and perhaps there is a central place for one? or should be.
09:25:54 <dons> well, all the mailing lists have online archives
09:26:22 <hpaste>  byorgey annotated "deepElements" with "need parens around (n-1)" at http://hpaste.org/3917#a1
09:26:33 <byorgey> bsdemon-rus: function application has highest precedence
09:26:55 <byorgey> so deepElements' tr n-1 parses as (deepElements' tr n) - 1
09:26:56 <dons> andyjgill: at one time i was collecting conferences here http://haskell.org/haskellwiki/Conferences
09:27:15 <byorgey> so you just need parens around the (n-1).
09:27:43 <andyjgill> Thanks dons, thats useful
09:28:13 <dons> andyjgill: the other thing is to go through the haskell@ archvies and pull out cfps
09:28:38 <bsdemon-rus> byorgey: ok, but I have "ERROR "task_2.hs":10 - Cannot justify constraints in explicitly typed binding"
09:28:39 <andyjgill> Yes. good idea
09:28:42 <dons> here, http://news.gmane.org/gmane.comp.lang.haskell.general
09:28:44 <lambdabot> Title: Gmane Loom
09:28:56 <byorgey> bsdemon-rus: which lines is #10?
09:28:59 <byorgey> *line
09:29:20 <bsdemon-rus> byorgey: deepElements' [] _ = []
09:29:48 <byorgey> hm, that's odd
09:30:09 <byorgey> seems like a Hugs thing, it works fine for me
09:30:14 <byorgey> any Hugs experts here?  ndm?
09:30:25 <doserj> it works in hugs for me
09:30:50 <byorgey> bsdemon-rus: what version of Hugs is this?
09:31:02 <bsdemon-rus> byorgey: sorry! it's okey now, thank you very much, i'm new to Hasskel programming
09:31:18 <byorgey> bsdemon-rus: ok, no problem, glad it works now =)
09:31:36 <byorgey> and welcome to Haskel! =)
09:31:52 <byorgey> except... with two l's. =P
09:32:23 * byorgey seems unable to spel this wekk
09:32:49 <reqamst> dons: maybe you know what's happening with Haskell Algorithm Challenge?
10:09:53 <paczesiowa> have anyone succeded compiling encoding with new ghc?
10:10:42 <desegnis> Can anyone reproduce the ghc-6.8.1/ByteString issue that I already used to pester dons, and which I described in http://hpaste.org/3626 ?
10:13:06 <doserj> desegnis: confirmed
10:13:34 <desegnis> doserj, thanks
10:23:08 <faxathisia> hello
10:23:32 <faxathisia> mm I wanna display some grids..
10:23:42 <faxathisia> So I thought I could use a haskell webserver.. does that sound good idea?
10:25:07 <Lemmih> faxathisia: Why not use CGI?
10:25:10 <fasta> faxathisia: probably not :)
10:27:30 <hpaste>  mmorrow annotated "ghc-6.9 link issue" with "(no title)" at http://hpaste.org/3842#a1
10:27:48 <faxathisia> Lemmih: this http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/HaskellCgi/show-haskell.cgi?file=../HaskellCgi/show-haskell.cgi&title=Show+Haskell ?
10:27:51 <lambdabot> http://tinyurl.com/39dk48
10:29:25 <Lemmih> faxathisia: The code is dated but, yeah, something like that.
10:31:49 <faxathisia> fasta: do you know any easier method?
10:32:16 <fasta> faxathisia: I would use Apache + CGI.
10:34:40 <ptolomy> Hm.. ByteString gives deprecation warning when I use findSubstring and says I should not use it.. what should I use instead?
10:34:58 <mrd> isInfixOf ?
10:35:07 <mrd> hm that doesn't return an int though
10:35:16 <davidL> is there a function in the prelude or in Data.List that removes the n'th element from the list, I thought there was but I can't find it?
10:35:18 <hpaste>  aaim pasted "sum & sum" at http://hpaste.org/3918
10:37:48 <faxathisia> you couldn't recommend any small webservers  which let you write pages in haskell?
10:37:56 <faxathisia> I can't face setting up apache
10:38:21 <Lemmih> lighttpd is my server of choice.
10:40:46 <kscaldef> ghc docs moved?
10:40:57 <kscaldef> I get 404 on http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:40:58 <lambdabot> http://tinyurl.com/ovjef
10:43:28 <reqamst> Through that on haskell wiki almost everyone link to libraries doesn't work
10:44:13 <byorgey> kscaldef: yes, the organization changed. the new URL for that is http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Prelude.html
10:44:13 <lambdabot> http://tinyurl.com/yqz9gj
10:46:11 <shapr> mmm, code
10:46:54 <faxathisia> hm ok
10:47:06 <faxathisia> Is there a way to make a program [not written in haskell] talk to ghci ?
10:47:11 <dons> sure
10:47:17 <dons> over a pipe
10:47:34 <faxathisia> ok I'll try that, thanks dons
10:47:41 <davidL_> @where logs
10:47:41 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
10:47:59 <kscaldef> davidL: ugly, but this does it:
10:48:01 <kscaldef> > let n = 4 in (\(a,b) -> a ++ b) $ (take (n-1) &&& drop n) [0,1,2,3,4,5,6]
10:48:01 <lambdabot>  [0,1,2,4,5,6]
10:48:38 <faxathisia> (\(a,b) -> a ++ b) == uncurry (++) I think ?
10:48:42 <davidL_> yeah that's what I have now, I'm playing code golf so I'm trying to make it as short as possible
10:48:51 <faxathisia> > uncurry (++) ("foo","bar")
10:48:52 <lambdabot>  "foobar"
10:48:55 <faxathisia> :D
10:49:04 <kscaldef> byorgey: that's uncool (http://www.w3.org/Provider/Style/URI.html)... is there any possibility of redirects?
10:49:21 <byorgey> kscaldef: don't ask me! =)
10:49:58 <kscaldef> > let n = 4 in uncurry (++) $ (take (n-1) &&& drop n) [0,1,2,3,4,5,6]
10:49:59 <lambdabot>  [0,1,2,4,5,6]
10:50:23 <paczesiowa> > let f n list = let (begin, end) = splitAt (n-1) list in begin ++ tail end in f 3 [1..10]
10:50:23 <lambdabot>  [1,2,4,5,6,7,8,9,10]
10:50:46 <faxathisia> @src break
10:50:46 <lambdabot> break p =  span (not . p)
10:51:38 <kscaldef> > let n = 4 in uncurry (++) $ (split (n-1) >>> second tail) [0..10]
10:51:38 <lambdabot>  Couldn't match expected type `(,)' against inferred type `(->)'
10:51:54 <paczesiowa> what does this mean "rarr13 = unsafePackAddress 0 ""#" ? it fails to compile because of incorrect indentation, but if I remove # types dont match
10:51:58 <kscaldef> hmm...
10:52:22 <reqamst> @src curry
10:52:23 <lambdabot> curry f x y = f (x, y)
10:52:29 <reqamst> @src uncurry
10:52:29 <lambdabot> uncurry f p = f (fst p) (snd p)
10:52:35 <byorgey> > let f n lst = splitAt n >>> first init >>> uncurry (++) in f 4 [0..6]
10:52:36 <lambdabot>  Add a type signature
10:53:27 <integral> @djinn ((Int -> Bool) -> Bool) -> Bool
10:53:27 <lambdabot> f _ = False
10:53:31 <faxathisia> @pl (\(a,b) -> a /= 3)
10:53:31 <lambdabot> (3 /=) . fst
10:53:34 <davidL_> @src first
10:53:34 <lambdabot> Source not found. Just try something else.
10:53:50 <integral> @djinn ((a -> b) -> b) -> b
10:53:50 <lambdabot> -- f cannot be realized.
10:53:54 <faxathisia> > map snd$filter((3/=).fst)$zip[1..]"hello"
10:53:56 <lambdabot>  "helo"
10:53:58 <faxathisia> :D
10:54:02 <faxathisia> this is shorter
10:54:53 <byorgey> > let f n = splitAt n >>> first init >>> uncurry (++) in f 4 [0..6]
10:54:54 <lambdabot>  [0,1,2,4,5,6]
10:55:38 <kscaldef> yeah, I like that version
10:56:15 <paczesiowa> anybody? what is this # character?
10:56:15 <davidL_> > let s = "hello" in take 2 s++take 3 s
10:56:17 <lambdabot>  "hehel"
10:56:24 <davidL_> err
10:56:32 <davidL_> > let s = "hello" in take 2 s++drop 3 s
10:56:33 <lambdabot>  "helo"
10:56:40 <faxathisia> paczesiowa: I don't undersand
10:56:50 <paczesiowa> > unsafePackAddress 0 ""#
10:56:50 <lambdabot>   parse error on input `}'
10:57:35 <roconnor> @go 1 CAD in USD
10:57:35 <lambdabot> 1 Canadian dollar = 1.029336 U.S. dollars
10:57:42 <allbery_b> at a guess you need -fglasgow-exts to enable the # suffix, which denotes an internal type
10:58:03 <byorgey> > ((uncurry(++).first init).).splitAt$3 "hello"
10:58:03 <lambdabot>   add an instance declaration for (Num ([Char] -> Int))
10:58:24 <byorgey> > ((uncurry(++).first init).).splitAt 3$"hello"
10:58:24 <lambdabot>  Couldn't match expected type `a1 -> ([a], [a])'
10:58:34 <allbery_b> (usually an unlifted type)
10:58:39 <megna> GHC.Prim.Addr#
10:58:48 <byorgey> > (((uncurry(++).first init).).splitAt)3 "hello"
10:58:49 <lambdabot>  "helo"
10:59:50 <paczesiowa> allbery_b: thx
11:01:25 <xerox> > (\n -> (!! n) . tail . ap (zipWith (++) . ([]:) . inits) tails) 3 "abcde"
11:01:25 <lambdabot>  "abce"
11:05:28 <shapr> hiya xerox! How's code?
11:06:25 <xerox> No code. Lots of algebra lately :)
11:06:32 <xerox> It's quite fun.
11:07:31 <xerox> How aboout you?
11:11:44 <shapr> Hacking on HAppS, reading about arrows for fun.
11:13:22 <shapr> y0 Arnia, how's code?
11:13:30 <shapr> mmmdonuts: donuts!
11:13:39 <mmmdonuts> shapr:mmm!
11:13:48 <Arnia> shapr: code is categorical
11:13:52 <Arnia> shapr: how are you?
11:15:53 <shapr> Flowing
11:16:43 * byorgey gives shapr a frosted lambdonut
11:17:00 <mmmdonuts> I'm having a problem defining a monad of mine as an instance of Num.  I googled and found the same problem in the Gentle Intro at http://www.haskell.org/tutorial/monads.html .
11:17:00 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
11:17:41 <mmmdonuts> That page defines a Num instance but when I try to run that, I get : Could not deduce (Eq (R a), Show (R a)) from the context (Num a)
11:17:48 <shapr> What's the minimum OPTIONS pragma I can use to make 'forall a' work? Is there something less than -fglasgow-exts ?
11:17:52 <mmmdonuts> I'm getting the same error with my own monad.
11:18:15 <mmmdonuts> halp!
11:18:36 <davidL_> @index (&&&)
11:18:36 <lambdabot> Control.Arrow
11:18:43 <byorgey> mmmdonuts: Num instances require an Eq instance and a Show instance.
11:19:01 <byorgey> so you'll have to make instances of those for your monad first, or you could just derive them.
11:19:02 <mrd> shapr: ExistentialTypes should do it for sure
11:19:25 <shapr> thanks
11:19:30 <mrd> er that's {-# LANGUAGE ... #-}
11:19:43 <byorgey> mmmdonuts: it's possible that the situation was different when that tutorial was written...
11:20:00 <mrd> also lexically scoped type vars
11:20:05 <shapr> Is LANGUAGE generally a better choice than OPTIONS ?
11:20:16 <mrd> it allows more specific enabling
11:20:21 <shapr> I'd assume yes for stuff like TemplateHaskell ExistentialTypes, etc
11:21:07 <byorgey> shapr: it's supposedly preferred.  since it should supposedly work for compilers other than ghc.
11:21:11 <mmmdonuts> byorgey, thanks.  It seems like you can't derive an Eq instance for a monad like the one on that page, afaict.  And to defining Eq yourself involves lifting it into the monad, so its type no longer satisfies Eq.  Hence my stuckness.
11:21:51 <mmmdonuts> Notice the definition of ==* on that page, as opposed to defining an Eq instance.
11:21:51 <byorgey> hm, yes, I see.
11:21:56 <Cale> mmmdonuts: A monad like what?
11:22:26 <mmmdonuts> Cale, I have a state-like monad pretty much identical to the one on the page at http://www.haskell.org/tutorial/monads.html
11:22:26 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
11:22:31 <shapr> byorgey: Yeah, good point.
11:22:54 <mmmdonuts> And I can't define Num for it, because I don't know how to define Eq for it (explanation just a few entries up in the log)
11:22:57 <Cale> Oh, yes, you can't define an Eq instance for State-like monads because they're functions, and there's no way to compare functions for equality.
11:23:03 <mmmdonuts> Right
11:23:10 <glguy> quickcheck!
11:23:13 <glguy> ;)
11:23:14 <mmmdonuts> Does that mean I can't define Num either?
11:23:15 <Cale> You can define a stub Eq instance.
11:23:15 <byorgey> blame Num =(
11:23:17 <shapr> mrd: Should {-# LANGUAGE ExistentialTypes #-} work with 6.6.1?
11:23:32 <mmmdonuts> Damn you Num!
11:23:35 <Cale> Num is just a bit poorly designed.
11:23:59 <byorgey> instance Eq (R a) where (==) = undefined
11:24:21 <newsham> you want to define something as Num that you dont know how to compare?
11:24:34 <byorgey> newsham: why not?
11:24:42 <Cale> Or just write
11:24:49 <Cale> instance Eq (R a)
11:24:58 <newsham> byorgey: sounds weird to me
11:25:13 <Cale> I think just leaving the instance blank should work.
11:25:18 <mmmdonuts> byorgey, Cale, thanks - I'll give it a try.
11:25:31 <byorgey> Cale: true, but then you get lots of warnings =P
11:25:36 <Cale> newsham: It's not strange at all.
11:25:55 <mmmdonuts> newsham, adding and multiplying etc. don't require comparison.
11:26:11 <mmmdonuts> (not externally anyway...)
11:26:19 <Cale> newsham: I can think of literally dozens of instances of Num which there's no useful definition of equality for.
11:26:35 <newsham> my imagination is much more limited than yours
11:26:47 <newsham> i'm intrigued..  got some interesting examples?
11:26:50 <Cale> The real numbers, for instance
11:27:06 <byorgey> heh
11:27:17 <mmmdonuts> newsham, see the Gentle Intro page I've mentioned : http://www.haskell.org/tutorial/monads.html
11:27:17 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
11:27:49 <shapr> mrd: Oh, it's ExistentialQuantification
11:28:01 <mmmdonuts> newsham, that tries to define Num for a monad.  Doesn't work under GHC 6.6+ though.
11:28:09 <Cale> (as represented by, say, an integer part, and an infinite binary expansion.)
11:29:15 <Cale> Another example would be functions with a fixed domain and numeric codomain.
11:29:30 <Cale> (fixed infinite domain)
11:29:45 <Cale> Say, like functions from the natural numbers to the natural numbers
11:29:56 <Cale> You can add or multiply those pointwise.
11:30:25 * vincenz multiplies Cale
11:30:29 <Cale> I suppose it had better be from the Natural numbers to the Integers, just so we can negate :)
11:30:51 * vincenz negates Cale 
11:31:15 <faxathisia> :(
11:31:32 * Cale rotates 4 dimensionally and flips himself back around.
11:32:02 * vincenz uses a 5-dimensional hyperplane to constrain cale
11:32:04 <byorgey> faxathisia: ?
11:32:08 <newsham> why cant you define Eq on reals?
11:32:19 <vincenz> newsham: real reals?
11:32:25 <vincenz> newsham: or computer ones?
11:32:28 <Cale> newsham: Well, you can't define it in any way which is guaranteed to terminate.
11:32:41 <faxathisia> byorgey: I can't get ghci to run inside lisp
11:32:49 <vincenz> Cale: how would you even define reals?
11:32:55 <faxathisia> somehow -v0 stops me getting any output....
11:33:03 <newsham> cale: haskell has bottoms. :)
11:33:27 <Cale> Well, you could define the real reals as proofs of existence of certain numbers. It would be a pain. Probably easier to use the computable reals :)
11:33:41 <vincenz> Cale: computable reals like flot?
11:33:41 <Cale> Existence and uniqueness rather.
11:33:41 <mmmdonuts> byorgey, thanks, that worked.  I actually like including the "undefined" because it makes it clear what's going on.
11:33:48 <Cale> No, not like float.
11:33:51 <vincenz> ok
11:34:03 <vincenz> Cale: see if you have real reals, why couldn't yo have real equality on those?
11:34:13 <Cale> Because it's not decidable.
11:34:15 <vincenz> I mean reals have identity
11:35:06 <byorgey> mmmdonuts: =)
11:35:08 <faxathisia> CL-USER> (funcall (ghci) (format nil "[1..10]~%"))
11:35:08 <faxathisia> "[1,2,3,4,5,6,7,8,9,10]"
11:35:09 <faxathisia> :D
11:35:11 <desegnis> You could always do data Real = Real Exponent [Digit] deriving (Eq); type Exponent = Integer; type Digit = Int. But the list of digits may be infinite
11:35:15 <Cale> It's possible that two real numbers are equal, but you can't prove it.
11:35:21 <vincenz> o
11:36:16 <newsham> I may be being dense, but.. that doesnt stop you from writing an Eq instance, does it?
11:36:29 <Cale> Like, if you had the real reals, you could define something like the real number in the interval [0,1] whose nth binary digit is a 1 if the nth Turing machine halts, and stuff like that.
11:36:54 <Cale> newsham: You can write a bad Eq instance.
11:37:01 <ADEpt> Q: with ghc 6.6.1 i can write my code in utf8 and use, for example, russian function names. But there is no way to invoke them in ghci. Is this a bug in ghci, or undocumented feature (non-latin1 names) which is likely to go away?
11:37:23 <Cale> But not a really meaningful one where you can guarantee termination.
11:37:56 <newsham> cale:  instance Eq [a] doesnt necessarily terminate either.
11:38:06 <vincenz> Cale: sure you can describe that, but that's not constructively generateable
11:38:16 <vincenz> Cale: and for reals, you only need Eq for numbers that can be constructively generated
11:38:21 <vincenz> Cale: since you're using Eq on a computer :)
11:38:30 <geocalc> ADEpt=<< how you import utf8 ?
11:38:52 <newsham> vincenz: you can write a program to generate all the bits in PI
11:39:00 <newsham> and try to compare PI against itself
11:39:16 <vincenz> good point :)
11:39:35 <geocalc> hoho pi is finite !
11:39:55 <ADEpt> geocalc: hm. since ghc insists on utf8 string literals, you kind of have to have sources in utf8. the rest comes naturally - you just write non-latin1 names and that's it
11:40:02 <newsham> geo: the digits in pi in any Natural base are infinite
11:40:53 <geocalc> newsham=<< it wwas humour
11:41:19 <byorgey> PI = 10 in base PI =)
11:41:35 * wli is, of course, suspicious.
11:41:44 <geocalc> ADEpt=<< i was talking of utf8.string
11:41:48 <newsham> PI is not a Natural.
11:41:52 * shapr is suspicious of suspicious people, especially himself!
11:41:56 <newsham> geo: lucky me, I get to play your straigh tman
11:42:07 <ADEpt> geocalc: i use System.IO.UTF8 from package "utf8"
11:42:18 <geocalc> mmh
11:42:32 <byorgey> newsham: mine too! =)
11:42:36 <faxathisia> hmm
11:42:55 <faxathisia> Is there any way for ghci to signal this the end of the output for the command run?
11:42:59 <geocalc> byorgey=<< pi = 1 pn base pi
11:43:09 <geocalc> in*
11:43:14 <faxathisia> like it's just one line in general, but if there's an error it's multiple lines
11:43:34 <byorgey> geocalc: ?  no, 1 = 1 in base anything.
11:44:49 <geocalc> i disagree
11:45:32 <opqdonut> [a,b,c] in base p is a*p^2+b*p^1+a*p^0 by convention
11:45:42 <opqdonut> so [1] = 1*p^0 = 1*1 = 1
11:45:51 <Cale> vincenz: You could actually have the non-constructable, but definable reals on a computer.
11:46:18 <Cale> There are still only countably many of those, but they're much harder to compare.
11:46:40 <Cale> I suppose you could try to define Eq for them in some way which would search for a proof of equality.
11:47:25 <Cale> But it would be pretty hopeless.
11:48:14 <geocalc> the logic is 1 is the base so in base n 1 = n this is logic only not convention
11:48:33 <faxathisia> geocalc: You are talking about something else, not base
11:48:37 <opqdonut> yeah
11:48:46 <opqdonut> 1 in base-10 is 1 :)
11:48:47 <Saizan_> geocalc: in base 2, 2=1?
11:49:09 <quicksilver> geocalc: observe: 1 in base 10 is 1. 1 in base 16 is 1. 1 in base 2 is 1.
11:49:09 <hpaste>  faxathisia pasted "example of ghci interaction" at http://hpaste.org/3919
11:50:00 <faxathisia> Is there any way to make ghci print out how many lines each thing is going to take.. or some ending delimiter so that I know how much to read in each case?
11:50:18 <faxathisia> I could just read 1 line at a time, if there's no errors
11:50:18 <geocalc> this way yes but this is not very logic
11:50:44 <quicksilver> geocalc: it is perfectly logical. It is because x^0 = 1, ifor any x except 0.
11:51:36 <quicksilver> faxathisia: why are you trying to read ghci's output? this sounds weird
11:51:53 <quicksilver> faxathisia: why not write a proper program and read the programs output?
11:51:56 <faxathisia> quicksilver: I want to use a lisp webserver so I can make a GUI for some haskell program
11:52:02 <Saizan_> faxathisia: you could manipulate your expression, i.e. instead of x use print x >> putStr "delimiter"
11:52:26 <faxathisia> hm yeah
11:52:30 <faxathisia> I guess that works better
11:52:31 <quicksilver> faxathisia: OK. So use a haskell program. Not ghci.
11:52:53 <faxathisia> I'm so used to using ghci for haskell..
11:52:56 <faxathisia> I'll try that though, thanks
11:53:44 <faxathisia> mumble
11:53:59 <quicksilver> faxathisia: why would you use ghci? sounds like you are createing problems which need not exist.
11:54:04 <quicksilver> just run your haskell program directly
11:54:09 <quicksilver> rather than trying to parse ghci's output.
11:54:16 <faxathisia> quicksilver: Yeah, I got that
11:54:18 <faxathisia> gonna try it
11:54:20 <faxathisia> thanks for the idea
11:54:27 <quicksilver> any time :)
11:54:28 <newsham> Microsoft Office 2007 which, when deployed on Windows Vista, consumes over 12x as much memory and nearly 3x as much processing power as the version that graced PCs just 7 short years ago (Office 2000).
11:55:09 <quicksilver> newsham: I'm quite surprised it's only 12x and 3x :)
11:55:34 <geocalc> why using fista at all ?
11:55:34 <quicksilver> I wouldn't have been surprised to hear 50x and 10x.
11:55:41 <newsham> i'm not.
11:57:51 <newsham> http://exo-blog.blogspot.com/2007/09/what-intel-giveth-microsoft-taketh-away.html
11:57:51 <lambdabot> Title: exo.blog: What Intel Giveth, Microsoft Taketh Away, http://tinyurl.com/27zbjw
11:58:09 <quicksilver> certainly MS Word today feels to me slower than MS Word 4.0 on a 1994(?) macintosh did.
11:58:20 <quicksilver> of course, it does do more.
11:58:26 <quicksilver> mostly, not things I want it to do.
11:58:38 <newsham> als you're probably playing mp3s and watchign a movie and have 4 browsers open in the background
11:58:46 <quicksilver> certainly not.
11:59:03 <newsham> you need to work smartly, not hardly
11:59:14 * EvilTerran hardly works ;)
11:59:14 <quicksilver> I do. I work smartly and dn't use MS Word :)
11:59:38 <quicksilver> I was just sharing an anecdote about it since you brought the subjec tup :)
12:00:12 <newsham> MSWord is a standard for docs at my company, although there's some internal debate and trials to do work with LaTeX
12:00:56 <newsham> we prob write on average 1-2 docs per week per employee.
12:00:57 <quicksilver> It's true that MSWord format documents are used a lot where I work, but I try quite hard to avoid them, and when I can't, I use openoffice.org.
12:01:02 <pejo> newsham, oh, just look at how many phd students that never finish their dissertation - clearly you can't work in latex!
12:01:22 <newsham> err.. wait.. about 0.5/week-person
12:02:16 <geocalc> use gedit
12:02:29 <newsham> pejo: what you dont see is what you never get?
12:02:38 <newsham> geo: is that google's?
12:02:54 <geocalc> no gnome
12:03:07 <newsham> heh.. gnome.  pass.
12:04:42 <faxathisia> is HAppS also a webserver?
12:05:09 <quicksilver> faxathisia: I believe it has an optional built-in webserver, yes
12:05:49 <faxathisia> I hope this works better
12:06:30 <newsham> if you just want a plain web server, there's HWS
12:06:49 <faxathisia> ok I'll try that first
12:06:53 <newsham> I use it as my web server
12:07:33 <newsham> http://darcs.haskell.org/hws
12:07:34 <lambdabot> Title: Index of /hws
12:07:58 <newsham> one warning: the darcs version lets you fetch "../../../../any/file/on/your/box"
12:08:05 <newsham> so you should probably patch that
12:08:08 <faxathisia> ah that's fine
12:08:22 <faxathisia> it will execute haskell as webpages though?
12:08:38 <newsham> its just a web server.. no dynamic content.
12:09:12 <newsham> this version has CGI support.  I havent used it: http://code.haskell.org/mohws/
12:09:13 <lambdabot> Title: Index of /mohws
12:09:26 <faxathisia> ok I'll try HAppS :)
12:09:41 <newsham> thats prob more like what you want
12:09:43 <EvilTerran> surely it's fairly straightforward to get, say, apache running haskell as CGI?
12:09:59 <faxathisia> EvilTerran: I hope not :|
12:10:00 <quicksilver> if you're used to adminning apache, I'd think so, yes
12:10:22 <gwern> oh. so that's why no one replied to my email: http://www.haskell.org/pipermail/haskell-cafe/2007-November/034717.html <-- the heck?
12:10:23 <lambdabot> Title: [Haskell-cafe] Performance problems with parallelizing QuickCheck using channels ..., http://tinyurl.com/35k5db
12:10:46 <EvilTerran> i don't recall; can runghc (or whatever) deal with #! lines?
12:11:04 <pejo> EvilTerran, it's not a problem to get stuff to execute as CGI under apache, if that is what you're asking.
12:11:42 <EvilTerran> i'm wandering in here mid-conversation, so i may be covering old ground
12:12:11 <byorgey> gwern: odd indeed...
12:12:34 <wli> Just compile the thing and put it in cgi-bin
12:12:45 <gwern> looks like the PGP sig was the problem. I think I'll remove it and try sending again
12:12:52 <newsham> "#!/usr/bin/runhaskell" works fine
12:12:59 <geocalc> EvilTerran=<< #!/blah/blah/runhaskell
12:13:30 <newsham> at last with .lhs files.  I think also with .hs
12:13:47 <geocalc> hs yes
12:13:49 <EvilTerran> newsham, geocalc: okay. i figured that'd be the thing to do, but i wasn't sure if it'd try to parse the #! as haskell and die horribly
12:13:58 <faxathisia> urk all these dependancies
12:14:01 <EvilTerran> > #!/usr/bin/runhaskell
12:14:02 <lambdabot>   parse error on input `}'
12:15:32 <paczesiowa> > foreign import ccall "system_encoding.h get_system_encoding" get_system_encoding :: IO CString
12:15:32 <lambdabot>  Parse error at "forei..." (column 1)
12:16:05 <augustss_> yo!
12:16:13 <dmwit> EvilTerran: Special case for the first line.
12:16:24 <paczesiowa> what's wrong with that code?
12:16:26 <EvilTerran> that makes sense
12:16:47 <EvilTerran> paczesiowa, well, you can't do declerations in lambdabot, only expressions...
12:16:48 <gwern> oh great. now my email is being held for moderation. How often do the Haskell-Cafe mods check in?
12:17:09 <paczesiowa> EvilTerran: I have this in normal file nad it fails to parse too
12:17:15 <cedricshock> Hi. I got curious and have a question. How does laziness affect the space usage of something like Data.Map? If (say via some console using the IO monad) repeatedly insert the same key into the map without ever accessing the map in any other way would I build a huge que of inserts into the map, running the space needed for my program through the roof?
12:17:40 <Saizan_> are you using -ffi?
12:17:52 <EvilTerran> paczesiowa, oh, i don't know then... ask Saizan_, he seems to know what's going on ;)
12:18:36 <Saizan_> paczesiowa: you need to enable the Foreign Function Interface, -ffi flag to ghc
12:19:07 <paczesiowa> was that needed in ghc-6.6.1?
12:19:33 <Saizan_> yes
12:20:04 <paczesiowa> I'm trying to compile encoding-0.2 with new ghc
12:20:33 <paczesiowa> Saizan_: thanks! now i compiled
12:20:43 <faxathisia> ohh geez
12:20:43 <paczesiowa> *it
12:21:00 <faxathisia>  Not in scope: type constructor or class `Private'
12:21:17 <faxathisia> I guess I'll try to set up apache then
12:22:52 <geocalc> do you have a fixed ip faxathisia ?
12:23:10 <paczesiowa> btw, new ghc has been out for a while and still lots of packages don't compile, and fixing is as easy as adding deps to cabal file, what gives?
12:23:14 <faxathisia> geocalc: I only care about running this locally
12:23:35 <geocalc> mmh
12:24:42 <mmmdonuts> faxathisia, the HAppS repos were broken as of Tuesday: see http://groups.google.com/group/HAppS/browse_thread/thread/2309c0e2eada9736
12:24:43 <lambdabot> Title: repos currently broken - HAppS | Google Groups, http://tinyurl.com/3yy8gs
12:24:47 <mmmdonuts> Dunno if they're fixed yet.
12:24:50 <mmmdonuts> Check out #happs
12:24:56 <faxathisia> mmmdonuts: ahh, it's possible they are broke still then
12:24:57 <shapr> I think they work.
12:25:04 <faxathisia> or I'm just unlucky
12:25:32 <shapr> Have you tried them today?
12:25:48 <faxathisia> yes I just checked everything out and I got some error
12:26:00 <faxathisia> I'm trying CGI now
12:26:08 <byorgey> cedricshock: it's possible, yes.
12:28:09 <shapr> faxathisia: What error?
12:28:20 <faxathisia> em I don't have it anymore..
12:28:38 <faxathisia> I could download HAppS and try again
12:28:46 <faxathisia> The last line was Not in scope: type constructor or class `Private'
12:28:58 <shapr> I've never seen that one.
12:31:06 <geocalc> btw Saizan_ -ffi is now deprecated
12:31:11 <faxathisia> Is there maybe an easier way to display grids of images than using HTML?
12:31:27 <geocalc> opengl
12:31:44 <shapr> faxathisia: If you have trouble building happs again, tell me!
12:32:01 <faxathisia> shapr: I'll try for more than 2 mins to get it to work then
12:32:09 <byorgey> faxathisia: one of those walls full of TVs like they have at electronic appliance stores?
12:32:17 <faxathisia> byorgey: I wish :p
12:33:29 <shapr> faxathisia: Ok
12:34:22 <mmmdonuts> shapr, I have a working older version of HAppS 0.9.1 on my own box, but I just tried to build it on another machine (using searchpath) and got the same error:
12:34:35 <mmmdonuts> haskell/State.hs:23:37: Not in scope: type constructor or class `Private'
12:34:55 <faxathisia> oo
12:35:03 <faxathisia> if you get the same error that's potentially good news :)
12:35:16 <grahamhutton> hi folks - first time on IRC1
12:35:40 <faxathisia> hi grahamhutton
12:35:40 <dmwit> Hi grahamhutton!
12:35:46 <therp> grahamhutton: welcome
12:35:55 <grahamhutton> thanks!
12:36:01 <dmwit> Somebody was just asking about your book here last night.
12:36:10 <grahamhutton> yes, i saw this.
12:36:38 <grahamhutton> (i look at the logs to see what is hapenning, but never used IRC myself before)
12:36:53 <paczesiowa> @src stdout
12:36:53 <lambdabot> Source not found. That's something I cannot allow to happen.
12:37:07 <wli> Book signing in PDX?
12:37:17 <dmwit> ?src IO.stdout
12:37:17 <lambdabot> Source not found. My pet ferret can type better than you!
12:37:33 <grahamhutton> good idea, but that's 6000 miles away for me :-)
12:37:48 <geocalc> put your book free online i say grahamhutton
12:38:00 <faxathisia> geocalc: Try a library
12:38:08 <geocalc> no
12:38:19 <geocalc> too far
12:38:39 <pejo> geocalc, bleh. Don't scare people away from here.
12:38:41 <dmwit> Oops, I hope I didn't touch of this silly debate again.
12:39:36 <geocalc> i just had to say this once to grahamhutton
12:40:10 <faxathisia> shapr: yeah It's the same as mmmdonuts said
12:40:15 <faxathisia> Just, haskell/State.hs:23:37:  Not in scope: type constructor or class `Private'
12:40:27 <newsham> hi graham.  I enjoyed your Haskell book.
12:40:51 <faxathisia> seems to be this myEntries::Private MyEntries
12:41:32 <grahamhutton> newsham: many thanks - it's was a lot of fun to write (but took a long time)
12:41:54 <faxathisia> Doesn't look like Private is defined anywhere from grepping
12:42:10 <faxathisia> I'm not sure what todo
12:42:43 <grahamhutton> anyone here going to "fun in the afternoon" in York (UK) next week?
12:43:37 <geocalc> and you ?
12:43:57 <grahamhutton> yes, of course!  (http://sneezy.cs.nott.ac.uk/fun/)
12:43:58 <lambdabot> Title: Fun in the Afternoon
12:44:31 <dikini> would love to but its 500 miles away :(
12:44:34 <pejo> grahamhutton, did it take longer to write than expected?
12:44:40 <vincenz> grahamhutton: que es?
12:44:56 <grahamhutton> yes, i was expecting about 3 years, but it took nearly 6.
12:45:09 <faxathisia> woah
12:45:14 <wli> grahamhutton: Did you use lhs2TeX or something fancier?
12:45:47 <vincenz> wli: a set of parallel ms's
12:45:51 <vincenz> :D
12:45:55 <grahamhutton> yes, lhs2TeX (which I would highly recommend)
12:45:55 <Octoploid> grahamhutton: any plans for an advanced followup book?
12:46:03 <vincenz> they're like google pigeons but cheaper
12:46:05 <vincenz> master students
12:46:21 <integral> heh
12:46:30 <grahamhutton> there are already a number of advanced Haskell books in the pipeline by others.
12:47:05 <wli> grahamhutton: How'd you deal with the boilerplate generated from each file being a problem when you use more than one literate Haskell source file?
12:47:47 <grahamhutton> not sure what you mean --- my book was one giant lhs file.
12:48:33 <wli> grahamhutton: Terrifying. I was sort of afraid you'd say that. :(
12:48:42 <vincenz> grahamhutton: a compileable one?
12:48:45 <faxathisia> wow
12:48:48 <grahamhutton> i'm a low tech kind of author
12:49:07 <gwern> grahamhutton: I've always wondered something. on a project like a book, is Latex really worth all the effort in learning and writing?
12:49:16 <byorgey> gwern: yes!!
12:49:26 <vincenz> gwern: even for papers it is
12:49:31 <vincenz> gwern: besides they give you templates
12:49:33 <vincenz> not much to learn really
12:49:36 <vincenz> unless you want fgures
12:49:38 <vincenz> then you google
12:49:39 <vincenz> copy paste code
12:49:42 <grahamhutton> yes, definetely.  otherwise the publishers would have typeset everything incorrectly.
12:49:43 <vincenz> change parameters
12:49:44 <vincenz> and voila :)
12:50:25 <dmwit> Heh, "That block would look much better if it were lined up with the previous one.  That guy probably didn't know much about indentation anyway."
12:50:33 <grahamhutton> if you are interested in how things look, then you don't want publishers doing the final typesetting.
12:50:34 <faxathisia> lol
12:51:07 <grahamhutton> dmwit: precisely!
12:51:14 <vincenz> dmwit: "This code takes too much whitespace, let me just reset it a bit" :)
12:51:21 <quicksilver> grahamhutton: welcome to #haskell :)
12:51:29 <vincenz> quicksilver--
12:51:36 <quicksilver> ?
12:51:40 <vincenz> quicksilver++
12:51:47 <pejo> grahamhutton, the publishers do more harm than good?
12:51:48 <gwern> grahamhutton: ok. so that brings me to another question, is it better to write the entire thing as a lhs from thebeginning or do you do the formatting and typesetting after it's mostly done?
12:51:49 * quicksilver shrugs amiably
12:51:57 * vincenz is feeling silly
12:52:02 <vincenz> friday-evening, tired
12:52:15 <vincenz> my sillyness is related to my tiredness
12:53:35 <grahamhutton> i write all my stuff in plain ascii first, rewrite it lots of times, and then when i'm finally happy with everything, translate it into latex.   I picked up this technique from Phil Wadler, and can recommend it --- it avoids wasting lots of time of formatting early on in the writing process, and keeps the focus on the actual writing.
12:54:13 <paczesiowa> :t swap
12:54:15 * gwern nods. that makes a lot of sense
12:54:22 <vincenz> grahamhutton: good point
12:54:25 <lambdabot> Not in scope: `swap'
12:54:35 <vincenz> except when doing formulas :/
12:54:35 <paczesiowa> > swap (1,2)
12:54:36 <lambdabot>   Not in scope: `swap'
12:54:44 <faxathisia> @pl (\(x,y)->(y,x))
12:54:44 <lambdabot> uncurry (flip (,))
12:54:49 <faxathisia> :D
12:54:51 <faxathisia> that's cool
12:55:06 <faxathisia> swap = uncurry (flip (,))
12:55:24 <dmwit> swap :: (a, b) -> (b, a) -- the type signature says it all
12:55:39 <paczesiowa> where did swap go?
12:55:55 <faxathisia> ?djinn (a, b) -> (b, a)
12:55:55 <lambdabot> f (a, b) = (b, a)
12:56:02 <newsham> dmwit: what is the type signature for \a b -> (2*b,3*a) ?
12:56:19 <dmwit> newsham: You get a Num constraint there, eh?
12:56:20 <paczesiowa> :t \a b -> (2*b,3*a)
12:56:21 <lambdabot> forall t t1. (Num t, Num t1) => t1 -> t -> (t, t1)
12:56:23 <olsner> smart thinking there! I think the first instinct of many would be to think "Oh, so I'm writing a book in latex - better get going on learning latex and writing all the templates i'll need for my book before I write too much text that i'll need to reformat later on"
12:56:24 <byorgey> paczesiowa: there is no swap.
12:56:33 <byorgey> not in the standard libraries I mean.
12:56:37 <newsham> dmwit: doh.
12:56:56 <olsner> @djinn (a, b) -> (b, a)
12:56:57 <lambdabot> f (a, b) = (b, a)
12:57:16 <paczesiowa> byorgey: so how did I come up with this name:/
12:57:25 <dmwit> It's in tutorials.
12:57:43 <dmwit> And the "How to confuse C programmers" thing. =)
12:57:45 <byorgey> paczesiowa: well, it's a good name for that function =)
12:58:19 <vincenz> @djinn a -> b -> c -> d -> e -> (b,c,d,e)
12:58:20 <lambdabot> f _ a b c d = (a, b, c, d)
12:58:31 <faxathisia> :t (,,,,)
12:58:32 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
12:58:35 <vincenz> @djinn m a -> m b -> m (a,b)
12:58:35 <lambdabot> -- f cannot be realized.
12:58:39 <faxathisia> grr
12:58:44 <olsner> @t const (,,,)
12:58:44 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:58:47 <olsner> @type const (,,,)
12:58:48 <lambdabot> forall a b c d b1. b1 -> a -> b -> c -> d -> (a, b, c, d)
12:59:09 <byorgey> @type liftM2 (,)
12:59:10 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
12:59:17 * wli LaTeX monkeyed in college but it mostly had to do with fiddling with spaces and operator sizes in equations until they looked good.
13:00:10 <newsham> i would like to use lh2tex a lot more as soon as I can get it to build on my two platforms :)
13:00:28 <mrd> do you write your math in ascii?
13:00:36 <grahamhutton> yes!
13:00:37 <newsham> I would really like cleaner notation for lifting and I think I can hack it together with lhs2tex
13:01:04 <grahamhutton> doing math (and haskell) in plain ascii first is a great incentive to keeping it simple :-)
13:01:13 <shapr> hiya gmh!
13:01:20 <grahamhutton> hi shapr
13:01:23 <dmwit> newsham: Wow, you're using a platform that doesn't have a binary distribution of one of the TeXs?
13:01:32 <shapr> I'm Shae Erisson, we met at HW2007
13:01:37 <newsham> dmwit: i have latex on all my platforms.  I dont have lhs2tex on them.
13:01:42 <dmwit> oh
13:01:46 <dmwit> Sorry, I misread.
13:02:04 <shapr> So what sort of nifty code is flowing past today?
13:02:33 <olsner> what does lhs2tex do? just insert \begin/end{code} and remove >'s?
13:02:39 <grahamhutton> yes, i remember.  (and I've been lurking here for ages.)
13:02:57 <shapr> Ah, I see.
13:02:57 <wli> shapr: I'm going to take a stab at a CPO-STV CGI script after I reinstall my laptop.
13:03:06 <shapr> CPO-STV?
13:03:24 <wli> shapr: http://en.wikipedia.org/wiki/CPO-STV
13:03:24 <lambdabot> Title: CPO-STV - Wikipedia, the free encyclopedia
13:03:47 <wli> shapr: Comparison of Pairs of Outcomes by the Single Transferable Vote
13:03:53 <grahamhutton> shae: it was HW 2006 in porland :-)
13:04:04 <byorgey> olsner: it can also do things like format Haskell code nicely: use special characters for various operators (user-configurable), line up things that should be lined up, etc...
13:04:13 <shapr> grahamhutton: Oh, that long ago? Wow.
13:04:17 <shapr> Time flies...
13:04:18 <grahamhutton> indeeed
13:04:42 <grahamhutton> it was a pity you weren't at HW 2007 -- more than 150 people attended!
13:04:44 <byorgey> olsner: and also it can insert the output of dynamically evaluated Haskell expressions into the document.
13:04:49 <byorgey> olsner: it's really rather nice =)
13:04:59 <olsner> byorgey: ooh, sounds nice... will come in handy when I finally get to work on writing that haskell paper :P
13:05:09 <augustss_> Hi Graham!
13:05:14 <grahamhutton> i lennart!
13:05:14 <shapr> grahamhutton: Yeah, I wish I could have been there. Especially for CUFP, since I was on the committee and several people that I invited showed up.
13:05:15 <dons> grahamhutton: !
13:05:19 <dons> welcome :)
13:05:22 <byorgey> olsner: yes, definitely!  I used it to write my article in the Monad.Reader
13:05:30 <dons> andyjgill: around?
13:05:32 <thetallguy> Yes, we need a bigger forum for HW and CUFP 2008, ithink
13:05:50 <shapr> wli: Oh, sounds interesting.
13:05:55 <wli> shapr: It's basically CSSD on the potential outcomes of a multi-winner election.
13:05:57 <grahamhutton> hi don (my first time on irc - i finally managed to install an irc client --- ask Andy G, and he will explain why this is a milestone :-)
13:06:20 <dons> grahamhutton: well, good to see you here :)
13:06:20 <shapr> grahamhutton: Be warned, #haskell can suck all of your productive time away by being too entertaining.
13:06:29 <byorgey> olsner: what haskell paper are you going to write?
13:06:38 <olsner> byorgey: no idea yet :P
13:06:42 <mae> how do i do nth-root formulas in haskell?
13:06:47 <mae> sqrt i know about
13:06:49 <byorgey> olsner: ah, I see. =)
13:06:50 <shapr> grahamhutton: Are you familiar with lambdabot?
13:06:52 <thetallguy> shapr: that's easy to fix, you just ask for help on what you're supposed to be working on.
13:06:53 <sebell> grahamhutton: Client? You mean you're not using telnet? :)
13:07:00 <byorgey> mae: nth root is the same as **(1/n)
13:07:06 <grahamhutton> yes!  i've been checking out the haskell logs for years.
13:07:06 <shapr> thetallguy: I should practice that sort of focus :-)
13:07:08 <byorgey> > 64**(1/6)
13:07:10 <lambdabot>  2.0
13:07:16 <mae> what is the diff between using ^ and **
13:07:22 <augustss_> types
13:07:26 <dons> :t (^)
13:07:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:07:28 <byorgey> mae: ^ is only for integral powers.
13:07:29 <dons> :t (**)
13:07:29 <lambdabot> forall a. (Floating a) => a -> a -> a
13:07:32 <mae> got it
13:07:36 <augustss_> > (-2)^2
13:07:36 <lambdabot>  4
13:07:38 <thetallguy> conal asked for an algorithm the other day and we all dropped what we were doing...
13:07:43 <grahamhutton> lennart -- i guess you and ganesh will be in york this coming week?
13:07:45 <augustss_> > (-2)**2
13:07:46 <lambdabot>  4.0
13:08:16 <desegnis> mae: Put another way, (^) is only for natural exponents.
13:08:23 <shapr> Speaking of physical #haskell meetings, who's interesting in showing up at AmeroHaskell in Portland? Does January seem like a good month?
13:08:34 <byorgey> olsner: let's have a great idea and write a paper together!
13:08:39 <augustss_> grahamhutton: yes, we will.  we'll be heading home in the evening, though
13:08:58 <augustss_> but we'll make it to the curry!
13:08:59 <thetallguy> January's always a good month.  Not sure if I can get to Portland, then, but Jan is a good month.
13:09:14 <grahamhutton> yes, me too:  i've had too many bad experiences with late night "fun in the afternoon" antics.
13:09:25 <shapr> Alcohol and lambdas don't mix?
13:09:36 <dmwit> ?users
13:09:36 <lambdabot> Maximum users seen in #haskell: 413, currently: 412 (99.8%), active: 25 (6.1%)
13:09:40 <grahamhutton> they mix too well, that's the problem.
13:10:11 <geocalc> lamdalcool
13:10:18 <augustss_> Hmm, why does (-2)**2 work?
13:10:29 <dons> what's it defaulting to?
13:10:41 <dons> :t (-2)**2
13:10:41 <lambdabot> forall a. (Floating a) => a
13:10:53 <dmwit> :t (**)
13:10:53 <lambdabot> forall a. (Floating a) => a -> a -> a
13:10:54 <dons> and lambdabot uses -fextended-defaulting too, btw.
13:11:07 <dons> > (-2)**2 :: Double
13:11:08 <lambdabot>  4.0
13:11:16 <faxathisia> grahamhutton: sounds like fun! wish I could go :p
13:11:18 <shapr> grahamhutton: Can you still write code when less than sober?
13:11:46 <augustss_> log (-2) should be NaN
13:11:51 <vincenz> shapr: type-inference keeps you level-headed
13:11:55 <augustss_> > (-2)**1.5
13:11:56 <lambdabot>  NaN
13:12:07 <shapr> vincenz: Your type inference must be better than mine!
13:12:19 <vincenz> shapr: well you might end up repeating yourself to it
13:12:23 <faxathisia> if you look at djinn upside down.....
13:12:27 <grahamhutton> who writes code anymore -- that's so last century...
13:12:43 <vincenz> "It types!"  "GHC: Does not type" "But it should type!" "GHC: Does not type" "But comeone, cut me some slack!"  "GHC: slack out of bounds"
13:12:56 <faxathisia> haha
13:12:59 <shapr> grahamhutton: You just write types, and that proves your program correct, thus not requiring any code?
13:13:02 <sebell> shapr: You haven't heard of the `Ballmer Peak'?
13:13:13 <olsner> I'm thinking of writing a linker (already started on that, but progress is kind of slow, and I'll still have to write/integrate (an) object file parser/writer(s)) or a network protocol testing framework - with the proper abstractions I imagine it could be quite beautiful
13:13:15 <shapr> Is that the place where Steve Ballmer is losing his hair?
13:13:22 <faxathisia> vincenz: reminds me of Prolog "Work dammit" "no" "Argh!!" "no" "You suck!" "no"
13:13:33 <augustss_> Hmmm, I think ghc calls the C power function which is too clever.  (-2)**2 should be NaN
13:13:37 <sebell> shapr: http://xkcd.com/323/
13:13:38 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
13:13:44 <shapr> I shouldn't make fun of people who are losing their hair, I'm sure it'll happen to me sometime soon.
13:13:47 <vincenz> faxathisia: :D
13:13:57 <vincenz> > log (-2) :: Complex Double
13:13:58 <olsner> augustss_: why is (-2)**2 not 4?
13:13:58 <lambdabot>  0.6931471805599453 :+ (-3.141592653589793)
13:14:15 <thetallguy> shapr: it's really not a problem
13:14:17 <vincenz> olsner: ** is floating, you want ^
13:14:27 <augustss_> olsner: because the Prelude saus ut should be computed via exo and log
13:14:27 <thetallguy> shapr: you just need to keep a few hats around.
13:14:29 <augustss_> exp
13:14:32 <shapr> thetallguy: Heh, I'll try that.
13:14:48 <shapr> sebell: Ah, that's the ballmer peak!
13:14:59 * shapr laughs
13:15:08 <augustss_> > (-2:+0)**2
13:15:08 <lambdabot>      precedence parsing error
13:15:08 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
13:15:11 <vincenz> > log (-1) :: Complex Double
13:15:12 <lambdabot>  0.0 :+ (-3.141592653589793)
13:15:25 <augustss_> > ((-2):+0)**2
13:15:25 <lambdabot>  4.0 :+ (-9.796850830579018e-16)
13:15:30 <olsner> shapr: then better make the most of the joke until the joke's on you!
13:15:36 <augustss_> Now that I'm happy with
13:15:38 <shapr> I guess so.
13:16:12 <faxathisia> > iterate (**2) 1
13:16:13 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
13:16:15 <vincenz> > log (-1) * (-0:+1)
13:16:16 <lambdabot>      precedence parsing error
13:16:16 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
13:16:20 <faxathisia> -_-
13:16:29 <vincenz> > log (-1) * (0:+(-1))
13:16:29 <lambdabot>  (-3.141592653589793) :+ -0.0
13:16:30 <faxathisia> > 1 : iterate (**2) 2
13:16:31 <lambdabot>  [1.0,2.0,4.0,16.0,256.0,65536.0,4.294967296e9,1.8446744073709552e19,3.402823...
13:16:38 <vincenz> > log (-1) * (0:+1)
13:16:38 <lambdabot>  3.141592653589793 :+ 0.0
13:16:43 <EvilTerran> > iterate (*(0:+1)) 1
13:16:44 <lambdabot>  [1.0 :+ 0.0,0.0 :+ 1.0,(-1.0) :+ 0.0,0.0 :+ (-1.0),1.0 :+ 0.0,0.0 :+ 1.0,(-1...
13:18:07 <olsner> heh, "Type-Level Instant Insanity"
13:18:15 <EvilTerran> just add Oleg!
13:18:27 <faxathisia> that really great
13:18:33 <faxathisia> the Type-Level Instant Insanity stuff
13:19:41 <thetallguy> what is (:+)?
13:20:10 <Saizan_> the infix constructor of Complex
13:20:17 <sebell> :t (:+)
13:20:17 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
13:20:18 <thetallguy> thanks
13:20:29 <faxathisia> thetallguy: (a :+ b) makes the complex with real a and imaginary b
13:20:44 <faxathisia> a+ib
13:21:23 <shapr> @quote oleg
13:21:24 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
13:21:48 <faxathisia> > let (a :+ b) = a+b in sqrt (-1) :: Complex Double
13:21:49 <lambdabot>      Occurs check: cannot construct the infinite type: t = Complex t
13:21:49 <lambdabot>       Ex...
13:21:55 <Saizan_> are typelevel decimal numbers on hackage yet?
13:21:55 <faxathisia> hm :/
13:22:31 <thetallguy> I asked Hoogle what (:+) was and it said: Did you mean: (:+)
13:22:38 <thetallguy> Still a few bugs in the system.
13:23:28 <andyjgill> Hi Graham!
13:23:29 <geocalc> lol
13:23:30 <Saizan_> yes, known bug
13:23:40 <grahamhutton>   hi andy!
13:23:54 <thetallguy> Amusing, though.
13:24:01 <grahamhutton> (andy: i finally managed to install an IRC client!!!)
13:24:03 <andyjgill> you made it to the party, then!
13:24:11 <grahamhutton> finally
13:24:12 <dons> oh, no. now we're in for trouble :)
13:24:13 <shapr> Igloo: When do you expect 6.8.1 debs for debian/unstable? Should I go ahead and build my own binary?
13:24:24 <dons> is Igloo still awake?
13:24:34 <grahamhutton> andy: the paper is progressing well, first 2 pages already rewritten; just 30 to go :-)
13:24:45 <andyjgill> :-)
13:24:49 <shapr> @seen Igloo
13:24:49 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I don't know when Igloo last spoke.
13:24:51 <thetallguy> shapr: they aren't quite ready yet.
13:24:53 <shapr> Guess not.
13:24:54 <faxathisia> what paper?
13:25:03 <shapr> grahamhutton: Ooh, which paper?
13:25:05 <thetallguy> shapr: David built them but found them unstable.
13:25:07 <grahamhutton> the worker/wraper transformation
13:25:16 <shapr> David Roundy?
13:25:21 <thetallguy> Fox
13:25:41 <grahamhutton> just google for the title and you'll get the abstract
13:25:47 <thetallguy> partner in crime, formerly at Linspire with me and stepcut
13:25:52 <shapr> Ah, I see.
13:25:57 <shapr> Does he hang out here on #haskell?
13:26:08 <quicksilver> Igloo himself posted some 6.8.1 debs if I'm not mistaken
13:26:22 <vincenz> oooo
13:26:22 <shapr> Ya know, irc could really benefit from user tags.
13:26:30 <quicksilver> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
13:26:31 <lambdabot> Title: Haskell Unsafe
13:26:36 <quicksilver> ^^ there, I think?
13:26:40 <thetallguy> not often, but he is dsfox and I'll ping him
13:26:51 <shapr> spiffy
13:26:59 <mae> how can I round a fractional to 2 decimal places
13:27:13 <quicksilver> mae: (*100).fromIntegral.round.(/100)
13:27:15 <shapr> quicksilver: Do you know if those haskell-unsafe has x86_64 ?
13:27:21 <quicksilver> mae: hmm, try again
13:27:27 <quicksilver> mae: (/100).fromIntegral.round.(*100)
13:27:29 <quicksilver> looks better :)
13:27:31 * shapr just looks in the dir...
13:27:44 <quicksilver> shapr: I would guess not, but I've been wrong before :)
13:27:44 <mae> heh
13:27:47 <mae> thanks :)
13:27:57 <shapr> Ah, so it does! spiffy!
13:28:04 <quicksilver> > (/100).fromIntegral.round.(*100) $ 3.151419
13:28:05 <lambdabot>  3.15
13:28:24 <andyjgill> Hey graham, if you setup you account with a password, you can also have private side chats. Its good for 1-on-1 discussions about projects in the works.
13:28:25 <quicksilver> mae: there is also showEFloat
13:28:32 <andyjgill> Perhaps someone else will know more about this
13:28:36 <quicksilver> mae: but that turns it into a string
13:28:40 <quicksilver> andyjgill: you missed him :)
13:28:52 <andyjgill> Ahh. I see he has just gone.
13:28:53 <quicksilver> andyjgill: grahamhutton [n=grahamhu@cpc2-basf3-0-0-cust716.nott.cable.ntl.com]  has quit []
13:29:02 <andyjgill> Talking to a wall again ...
13:29:03 <mae> thank you :)
13:29:12 <vincenz> unsafeHaskell :: Haskell -> C
13:29:57 <geocalc> cpp too ?
13:30:16 <shapr> safeC :: (WellPaidDeveloper a) => a -> C -> Haskell
13:30:25 <vincenz> unsafeHaskell:: (CLike c) => Haskell -> c
13:31:50 <cedricshock> byorgey: Thanks. After thinking about it some more (on a walk to the post office) any time you apply some state transformation function in the IO monad and don't have an IO side-effect that depends on the complete result it's possible (and likely) to build a huge queue of state transformations in memory rather than processing all the transformation and having only one state in memory.
13:32:23 <visof> > foo x = if x > 0 then 1 else if x < -1  else  0 in foo 3
13:32:24 <lambdabot>  Parse error at "=" (column 7)
13:32:49 <visof> help
13:32:55 <quicksilver> cedricshock: yes. there is no direct relationship between monads and strictness
13:32:58 <quicksilver> visof: missing 'let'
13:32:58 <byorgey> cedricshock: yes, it's possible.  although it's also possible that an optimizing compiler will help.
13:33:23 <quicksilver> cedricshock: although IO (and some other monads) effectively enforce strictness on values they actualy 'use'.
13:33:26 <visof> > let  foo x = if x > 0 then 1 else if x < -1  else  0 in foo 3
13:33:26 <lambdabot>  Parse error at "else" (column 46)
13:33:39 <byorgey> visof: if x < -1 else ... doesn't make sense
13:33:48 <quicksilver> visof: your second if doesn't have a then
13:33:49 <byorgey> if x < -1 then what?
13:34:16 <shapr> On the other hand, if your code is sufficiently lazy, it won't build up a queue for stuff that's never used.
13:34:43 <vincenz> shapr: I dunno, I'm reasonably lazy, and stuff builds up all the time
13:34:59 <visof> byorgey 0?
13:34:59 <byorgey> cedricshock: if it's a problem, you can always use explicit strictness annotations to force evaluation, either with seq or with "bang patterns"
13:35:03 <shapr> Yeah, but you haven't wasted a lot of effort on your US taxes, have you?
13:35:23 <byorgey> visof: each 'if' must have a matching 'then'.  your second 'if' doesn't.
13:35:23 <vincenz> point
13:35:28 <cedricshock> byorgey: Yeah. It'd be a bit tricky for an optimizing compiler for a lazy language to run a piece of code eagerly when it can't prove that the code will be run unconditionally.
13:35:40 <visof> ok
13:36:01 <byorgey> cedricshock: yes, but Haskell isn't lazy, it's non-strict =)
13:36:06 <visof> > let  foo x = if x > 0 then 1 else if x < -1 then 1  else  0 in foo 3
13:36:07 <cedricshock> vincenz: thanks for the chuckles
13:36:08 <lambdabot>  1
13:36:46 <quicksilver> byorgey: ghc is almost fully lazy, though.
13:36:54 <shapr> cedricshock: Oh yeah? http://citeseer.ist.psu.edu/636576.html
13:36:55 <lambdabot> Title: Optimistic Evaluation: An Adaptive Evaluation Strategy for Non-Strict Programs - ...
13:37:06 <vincenz> cedricshock: I try my best :)
13:37:13 <quicksilver> shapr: the fact someone's written a paper about it doesn't mean it isn't tricky :)
13:37:16 <shapr> hah
13:37:26 <quicksilver> shapr: indeed, they may have written a paper precisely cos it was tricky!
13:37:33 <vincenz> papers have the luxuries of making a lot of assumptions :)
13:37:34 <shapr> Ooh, good point!
13:37:56 <cedricshock> shapr: I said tricky, not impossible. I can run a piece of non-terminating code and give up on it when it turns out I don't need it.
13:38:33 <vincenz> You could have a strictness-jit :)
13:38:43 <shapr> How would that work?
13:38:55 <vincenz> Run it a few times, if it's seen that you always need the data strictly..
13:38:58 <vincenz> strictify it
13:39:11 <vincenz> s/awlays/ > x %
13:39:17 <shapr> I think you'd have to strictify it in chunks.
13:39:25 <vincenz> where x is inversionally proportional to the cost of laziness
13:39:27 <shapr> Like lazy bytetrings.
13:39:41 <cedricshock> vincenz: What happens when it turns out that the nth case needs to be non-strict to achieve termination?
13:39:50 <shapr> I wonder if the ghc-api is powerful enough to build a prototype for this sort of thing?
13:39:51 <vincenz> cedricshock: I'd be surprised
13:40:06 <vincenz> and you can strictify chunks of it
13:40:09 <vincenz> like loop unrolling :)
13:40:22 <shapr> yeah
13:41:23 <pjd> cedricshock: re. your previous comment, that's what Eager Haskell does
13:41:53 <pjd> (as far as i understand (which is not very))
13:42:05 <vincenz> > 26^3
13:42:06 <lambdabot>  17576
13:42:17 <vincenz> > 26^2 + 26 + 1
13:42:18 <lambdabot>  703
13:42:18 <grahamhutton> andyg: did you see Ohori's POPL 2007 paper on "lightweight fusion"?
13:42:23 <shapr> I thought Eager Haskell and pH were purely strict languages?
13:42:36 <augustss_> nono
13:42:50 <faxathisia> pH is still lazy I think
13:43:00 <shapr> Oh, I should read up on those then.
13:43:02 <faxathisia> I really should have read the whole book :/
13:43:06 <augustss_> with an ideal scheduler
13:43:17 <delYsid> Does anyone know of a usage example for OpenAL in Haskell?
13:43:18 <cedricshock> vincenz: yeah, that works when you can prove interesting things. I actually have a really simple execution model I frequently use. Everything is lazy. I don't do anything until I need it. Then everything is eager. If I'm not doing something I find something, anything, to do on the off chance I need it. You can get a bit more sophisticated and do the things you think will benefit you the most (most likely to be used / compresses memory
13:43:18 <cedricshock> the most, etc.)
13:43:31 <pjd> shapr: Eager Haskell is still non-strict
13:43:34 <shapr> Ideal scheduler? Sounds like I need to spend some time with scholar.google.com
13:44:00 <vincenz> cedricshock: how do you travel through your graph of things to do?
13:44:10 <vincenz> cedricshock: and how do you store values? thunks?
13:44:15 <pjd> "The Eager Haskell compiler executes Haskell programs eagerly by default [...] When resource bounds are exceeded, computation falls back and is restarted lazily. By using a hybrid of eager and lazy evaluation, we preserve the semantics of Haskell and yet permit efficient iteration."
13:45:15 <shapr> delYsid: Maybe stuff in the ALUT examples dir? http://cvs.haskell.org/darcs/packages/ALUT/examples/
13:45:16 <lambdabot> Title: Index of /darcs/packages/ALUT/examples
13:46:42 <dikini> how safe are implicit parameters? that is can a value of an implicit parameter be leaked outside its scope?
13:46:50 <grahamhutton> dons: is andyg around?
13:47:04 <dons> i can't see him. i think he's working at home today
13:47:09 <cedricshock> vincenz: I usually travel through the graph of things to do by parallelizing the code, and I end up storing values using something like STM. It's not as horribly ugly as it sounds. There's no reason a compiler couldn't do these things itself, but there might be some reasons not ot.
13:47:23 <grahamhutton> andyg --- you there?
13:47:32 <dons> andyjgill: ping ^^
13:47:34 <shapr> dikini: Thomas Jaeger wrote something about that once, and there was a mailing list thread about that. I think that some specific implicit parameters can leak, but I don't remember the details.
13:47:39 <dons> will trigger his irc client, grahamhutton
13:47:44 <dons> by using his irc nick
13:47:50 <dons> some clients ring bells and so forth
13:47:52 <grahamhutton> thanks!
13:47:59 * dikini googles
13:48:27 <quicksilver> grahamhutton: we met once, when you hosted a spatial logic workshop prior to an APPSEM conference. I was in the QMUL crowd.
13:48:47 <grahamhutton> quicksilver: what's your real name?
13:48:54 <quicksilver> grahamhutton: Jules Bean
13:49:03 <grahamhutton> of course - i remeber you well!
13:49:05 <andyjgill> Yes, I am now
13:49:12 <grahamhutton> hi andy
13:49:18 <augustss_> Mr Gill!
13:49:21 <quicksilver> I'm a boring City programmer now, but #haskell keeps me sane :)
13:49:41 <grahamhutton> andyg: did you see the POPL 2007 paper by Ohori on "lightweight fusion"?
13:49:44 <andyjgill> Hi augustss
13:50:08 <andyjgill> Was that the one you sent a pointer to a couple of weeks ago?
13:50:23 <delYsid> shapr: thanks
13:50:29 <grahamhutton> maybe - it's got w/w all over it, but doesn't make any mention of this.
13:50:47 <dons> i've seen the paper (and the talk)
13:51:02 <dons> base on hylo fusion, iirc?
13:51:21 <vincenz> cedricshock: what langauge was ths for?
13:51:28 <grahamhutton> i thought it was based on fixed-point fusion.
13:51:35 <andyjgill> Well, its based on Fix promote, which is basically the same as w/w.
13:51:51 <dons> ah yes, that's right. it was all fix point promotion stuff
13:52:25 <grahamhutton> indeed - the number of missing references is quite surprising (particularly for a POPL paper)
13:53:40 <grahamhutton> particulary the omitted references to more than a decade of work on fixed-point promotion by certain dutch folks.
13:54:22 <andyjgill> The recipe is the key contribution of our paper; in a digestible format, if you excuse the pun
13:54:33 <grahamhutton> nice line!
13:54:41 <grahamhutton> maybe we should use this.
13:54:59 <cedricshock> vincenz: python, and I've done similar (but not the same) things in haskell, including racing lazy programs against each other and using partial results from programs in the other programs (such as finding bounds for search algorithms).
13:55:46 <andyjgill> I was trying to get a reference to donuts, but got hung up on the surface tension of the torus.
13:56:57 <grahamhutton> andyg: don't talk to me about torus'ssss
13:57:49 <grahamhutton> (maybe you remember they guy who complained about me describing the surgace of the donus as a torus, when he claimed was a 2D thing...)
13:58:04 <andyjgill> So the POPL paper says "Although it is preliminary, it demonstrates practical feasibility of this method. "
13:58:16 <andyjgill> (yes, that was the donut joke)
13:58:21 <grahamhutton> bugger
13:58:41 <olsner> well, obviously, the *surface* of the donut is 2D
13:58:51 <faxathisia> I think the surface is 3D
13:59:00 <andyjgill> It seems to work on small examples, but the problem is always interesting to scale up, and hits issues.
13:59:03 <grahamhutton> here we go again :-)
13:59:13 <andyjgill> tell the story.
13:59:13 <faxathisia> i'm quite often wrong :p
13:59:41 <olsner> it's a rectangle glued together in both ends, as I see it
13:59:42 <faxathisia> you can describe any point of it using a 2D coordinate, but it is 3D in nature..
13:59:46 <grahamhutton> andy: i would, but it's quite late here already (10pm)
14:00:02 <andyjgill> Sure. Glad to hear your making progress, though.
14:00:07 <faxathisia> I'm not sure if my point of view is actually mathematically sound or nonsense
14:00:53 <sphynx> hi! I have a question: does Data.Binary supports data sharing during serialization?
14:01:23 <sphynx> I mean that kind osupport as described in 'Pickler combinators' paper, for example
14:03:35 <sphynx> any answer? :)
14:03:50 <sethk> sphynx, I don't believe so
14:04:30 <EvilTerran> if you mean "can it serialize (repeat 1) in finite time", i think the answer's no
14:04:44 <sphynx> sethk: ok. I just want to compare pickler combinators way and Data.Binary
14:05:26 <sethk> sphynx, I haven't read the paper, so I can't say anything terribly intelligent
14:05:33 <sethk> what's the URL?
14:05:54 <sphynx> sethk: 1 sec please
14:06:01 <dsfox> shapr: I built the debs of ghc-6.8.1 that appeared in http://haskell-unsafe.alioth.debian.org/archive/amd64/unstable/g/ghc6/
14:06:02 <lambdabot> Title: Index of /archive/amd64/unstable/g/ghc6, http://tinyurl.com/3xt48d
14:06:15 <sphynx> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
14:06:58 <dsfox> I ran into some trouble because hscolour version 1.9 put its executable in hscolour instead of HsColour, which is where ghc6 expects it.  Once that was fixed it built fine for i386
14:06:59 <sphynx> it seems that advantage of Data.Binary is its efficiency due to using lazy bytestrings
14:07:01 <sethk> sphynx, ok, thanks.  Of course there is no guarantee that I'll say anything intelligent after I read it either  :)  ...
14:07:19 <grahamhutton> andyg: i got a message from you, but can't reply
14:07:32 <dsfox> now waiting for the debianization of extralibs
14:07:50 <hpaste>  omg pasted "return tree node" at http://hpaste.org/3920
14:07:53 <sethk> sphynx, it seems that lazy turns out to be less efficient, almost always, but let me read ...
14:08:01 <sphynx> sethk: and advantage of pickler combinators way is its default synchronization of serialization/deserialization functions in one data type
14:08:09 <dons> sphynx: the picklers will be slower :)
14:08:16 <dons> yeah, two methods in the type class, v. one.
14:08:22 <omg-9238423> could someone help me figure out what's wrong with my treeNode function
14:08:27 <quicksilver> faxathisia: the way of making precise your intuition is to say "the (surface of the) torus cannot be embedded in the plane"
14:08:38 <sphynx> dons: so we can't err in synchronization of these two functions - it's good :)
14:08:40 <omg-9238423> i probably should be using some kinda monad but i haven't gotten that far yet
14:08:47 <quicksilver> faxathisia: in that sense, the surface of the torus has something more than two dimensions to it
14:08:54 <dons> sphynx: right, but you pay in terms of efficiency
14:08:56 <quicksilver> faxathisia: but, of course, its dimension is still 2 :)
14:09:01 <dons> building an AST, vs fast code
14:09:08 <faxathisia> quicksilver: What is "it's dimension"?
14:09:19 <dons> (with the invariant checked with QC)
14:09:21 <sphynx> dons: also I wonder - if I would implement pickler combinators using ByteStrings somehow
14:09:25 <sethk> dons, there's some similarities here to the client/server stuff we did a while back
14:09:27 <cedricshock> faxathisia: It's mathematically sound, you just don't have the right jargon. The surface is a two dimensional manifold. It can only be a "real thing" when it's embedded in a vector space of a t least 3 dimensions. (you can't put the torus in a two dimensional vector space (like a plane)).
14:09:35 <quicksilver> faxathisia: there is a number of ways of formulating that
14:09:40 <dons> sethk: yeah
14:09:43 <sphynx> dons: then it will be fast and correct both :)
14:09:51 <faxathisia> cedricshock: ahh
14:09:54 <quicksilver> faxathisia: one way is to say that its dimension is 2 precisely because you can paramterise it with 2 coordinates
14:10:05 <quicksilver> faxathisia: another way is to say it is "locallly like" a plane
14:10:08 <wli> insert homeomorphism/diffeomorphism where appropriate
14:10:11 <faxathisia> quicksilver: ok cool
14:10:23 <olsner> quicksilver: are all these other formulations equivalent?
14:10:26 <faxathisia> locally like -- seems odd
14:10:42 <sphynx> dons: also it seems support of sharing is useful thing (but default implementations of pickler combinators does not provide good one either)
14:11:32 <sphynx> cause it can't serialize cyclic values (we need to implement pointer-based equality test somehow
14:11:50 <cedricshock> faxathisia: It' just means that if you look at a small enough piece of a torus it looks as much like as big a piece of a plane as you'd like it too. Or if you put it under a really powerful microscope you can't see the difference, you can only see it if you back off a ways.
14:12:11 <vincenz> cedricshock: and when it's not rotting
14:12:15 <vincenz> otherwise you can't look at it
14:12:23 <faxathisia> cedricshock: I suppose you can show that by doing implicit differentiation?
14:12:27 <olsner> but pointer-based equality isn't even enough... things like (repeat 1) could be implemented as allocating more and more elements through lazy evaluation, rather than as a cyclic list
14:12:28 * vincenz shudders at the thought of a rotting donut
14:12:53 <quicksilver> olsner: no, they're not.
14:13:08 <vincenz> quicksilver: was going to say the same but he said 'could'
14:13:29 <quicksilver> vincenz: I was talking to his earlier question, address to me :)
14:13:38 <vincenz> oh :)
14:13:48 <quicksilver> (repeat 1) is an infinite list
14:13:49 <vincenz> quicksilver: sadly I only have highlighting on my nick :)
14:13:49 <EvilTerran> sphynx, i think you'd want serialization of unevaluated thunks
14:13:55 <cedricshock> faxathisia: I'm not sure what you mean by implicit differentiation, but that's the right idea. It's called differential geometry and about a billion other names.
14:14:05 <EvilTerran> rather than handling cycles in the structure
14:14:09 <quicksilver> the fact that haskell implements it as a circle is an implementation detail
14:14:12 <quicksilver> it need not be
14:14:12 <EvilTerran> but that would be Really Quite Hard, i think
14:14:37 <vincenz> not really
14:14:45 <vincenz> a = cons
14:14:47 <vincenz> a.value = x
14:14:48 <vincenz> a.next = a
14:14:53 <vincenz> that's a textual representation :)
14:15:00 <EvilTerran> i mean in the general case
14:15:04 <sphynx> EvilTerran: yeah, it seems so. I said 'cyclic' just because of terminology from paper
14:15:05 <vincenz> just as easy
14:15:12 <EvilTerran> > [1,2..] ?
14:15:13 <vincenz> EvilTerran: I've written a lua serializer that does fine with serial structures
14:15:13 <lambdabot>   parse error on input `}'
14:15:13 <vincenz> erm
14:15:15 <vincenz> cyclical
14:15:23 <vincenz> just need a hashmap of pointers written -> names
14:15:30 <EvilTerran> what about trying to serialize an infinite list of the primes?
14:15:38 <EvilTerran> or the odd perfect numbers?
14:15:42 <vincenz> EvilTerran: you acn only serialize what is in memory
14:16:03 <vincenz> but ok, you make a good point
14:16:06 <EvilTerran> "what's in memory" is an implementation detail ;)
14:16:18 <EvilTerran> i want to be able to serialize anything i like
14:16:19 <SamB> it would be nice, sometimes, if you could rewind and serialize what used to be in memory ;-)
14:17:13 <cedricshock> vincenz: Can haskell serialize a result of a computation without actually performing it? I can't see any reason why it shouldn't be able to, but I haven't done a lot of serialization.
14:17:31 <SamB> cedricshock: how the heck could it?
14:17:34 <vincenz> cedricshock: hmm well if you used bytecode maybe
14:17:34 <ddarius> Simply serialize the thunk.
14:17:41 <vincenz> the issue is that haskell compiles and sometimes inlines
14:17:48 <SamB> well, you'd need an extension, clearly
14:17:57 <vincenz> how would this serialized data structure survive if you moved to a new program with diferent code?
14:18:01 <vincenz> I mean
14:18:05 <vincenz> how would even a datatype survive?
14:18:08 <vincenz> data Foo = Bar | Bir
14:18:13 <vincenz> a = [Bar, Bir]
14:18:13 <SamB> vincenz: good question
14:18:13 <Toxaris> does (save whole state of the machine the haskell program is running on) count as serialization?
14:18:14 <vincenz> serialie
14:18:15 <vincenz> a
14:18:20 <vincenz> data Foo = Bir | Bar
14:18:23 <vincenz> unserialize a
14:18:28 <sethk> you can't encode data that doesn't exist
14:18:38 <vincenz> sethk: eh
14:18:39 <vincenz> ?
14:18:43 <SamB> and then what happens if someone changed the datatype?
14:18:48 <vincenz> serialization is a communication mechanisim between two pieces of code
14:18:54 <vincenz> that are not linked together
14:18:58 <sethk> vincenz, no, that's not the sense here
14:19:08 <vincenz> sethk: since when?
14:19:08 <sethk> vincenz, this is serialization as in marshalling
14:19:11 <vincenz> yes
14:19:13 <vincenz> my point
14:19:18 <ddarius> Toxaris: Why not?
14:19:26 <vincenz> program 1: data Foo = Bir | Bar; serialize [Bir, Bar]
14:19:36 <vincenz> program 2: data Foo = Bar | Bir; unserialize
14:19:54 <SamB> sethk: what is the difference between marshalling and communication between two pieces of code?
14:20:03 <cedricshock> vincenz: That doesn't stop anything. Just serialize the needed code right along with it...
14:20:04 <EvilTerran> vincenz, everything explodes ;)
14:20:20 <sethk> SamB, in general, marshalling refers to a system of translation that is independent of the internal data representations
14:20:35 <vincenz> sethk: haha :)
14:20:48 <EvilTerran> cedricshock, it's not meaningful to speak of serializing compile-time declerations (eg data declerations)
14:20:49 <vincenz> "independent of internal data represntations"
14:20:51 <geocalc> foo | bar | bir | bur ....
14:20:57 <sethk> SamB, so I can marshall among heterogeneous machines, as in CORBA and other such abominations
14:20:57 <SamB> sethk: such a system can work how?
14:21:11 <sethk> SamB, there are two ways it has been done in the commercial world
14:21:13 <SamB> sethk: DCOM
14:21:19 <sethk> SamB, ok, three
14:21:20 <sethk> :)
14:21:26 <cedricshock> vincenz: Your serialization just needs to have the same functional semantics as the language. Porgram 1's data Foo and program 2's data Foo have nothing to do with each other, unless they're the same.
14:21:37 <vincenz> cedricshock: right, how do you prove that?
14:21:38 <SamB> sethk: but how is that independant of the data representations?
14:21:41 <vincenz> cedricshock: attach a full type?
14:21:43 <SamB> it is at least ad-hoc dependant
14:21:46 <sethk> SamB, things like corba, and the java support for the same type of thing, change everything to a string representation
14:21:56 * olsner screams XML! and flees
14:22:07 <vincenz> olsner: that's not a serialization
14:22:09 <vincenz> olsner: that's just a file format
14:22:11 <geocalc> =<<*
14:22:13 <sethk> SamB, IBM's system has all processes identify each other, and each process is capable of translating any supported data representation
14:22:16 <vincenz> xml vs binary is completely under the hood in this discussion
14:23:22 <EvilTerran> i imagine Data.Typeable could be invoked to provide run-time type safety
14:23:32 <sethk> vincenz, you can't meaningfully discuss marshalling without taking account of the way data iss transfered
14:23:35 <vincenz> EvilTerran: I disagree
14:23:41 <cedricshock> vincenz: How do you prove anything about serialized data? You don't know that it's going to match your type unless you check that it matches your type. If you want to serialize data so that some arbitrary program can read it, good luck.
14:23:43 <grahamhutton> any notts folks here?
14:23:47 <vincenz> EvilTerran: typeable is within one instance of program, you can have a unique set of types to refer to
14:23:47 <olsner> (yes, that was kind of the point - xml isn't a solution to any problem, just a file format)
14:23:50 <EvilTerran> i only said "I imagine"... didn't say it was possible
14:24:04 <EvilTerran> *didn't say it was necessarily true
14:24:19 <Toxaris> ddarius: I don't know, since I'm not sure what serialization exactly means
14:24:21 <vincenz> cedricshock: right, but as long as that's data, that's not too bad
14:24:27 <vincenz> cedricshock: but if you're now encoding thunks with code..
14:24:32 <vincenz> cedricshock: it could be a lot riskier
14:24:32 <SamB> olsner: it is one possible solution to the "how do I parse this SGML without being told it's doctype up front" problem
14:24:38 <vincenz> and that was our original premise
14:24:38 <SamB> by changing the problem
14:24:49 <sethk> now, if you are talking about haskell programs, you can already marshall and unmarshall independent of internal representation
14:25:00 <vincenz> sethk: oh?
14:25:11 <EvilTerran> i haven't used Typeable much; I was thinking it might be possible to encode any type declerations in the serialization
14:25:20 <vincenz> sethk: and in response to your prior point, yes you can
14:25:21 <Toxaris> ddarius: e.g., if it extends to non-data parts of the runtime state
14:25:22 <vincenz> you can do a mapping from
14:25:27 <vincenz> internal types -> external types
14:25:28 <sethk> vincenz, no, not really.
14:25:32 <vincenz> and then external -> types -> bit layout
14:25:32 <cedricshock> vincenz: Why does it need to be riskier? You need to check the type of the code, just like the type of the data. Not only do you need to check it you need to prove it.
14:25:38 <EvilTerran> and then check against them when thawing
14:25:41 <sethk> vincenz, what you are saying is just a tautology, there is no information in it.
14:25:46 <vincenz> the second is where you mak a choice to use xml, or binary, or fingerprint drwaings
14:25:51 <SamB> vincenz: but that's not independant of internal types
14:26:01 <vincenz> SamB: never said it was
14:26:08 <SamB> someone did ;-P
14:26:12 <vincenz> sethk did
14:26:31 <sethk> SamB, I said something is independent of internal types, I didn't say _that_ particular thing is
14:26:33 <vincenz> I see, all wrongful points are now used against me :)
14:26:48 <vincenz> sethk: your external represntation must have some morphism with respect to internal types
14:26:50 <SamB> vincenz: sorries
14:26:58 <vincenz> sethk: otherwise you're not encoding data from your program in it
14:27:09 <vincenz> e.g.
14:27:15 <vincenz> yu number your data constructors from left to right
14:27:22 <vincenz> now the number is dependent on the position in the data -def
14:27:31 <sethk> vincenz, indeed, it does, I was just pointing out that the language contains the capability to marshall and demarshall, without writing any code
14:27:51 <vincenz> sethk: no, you keep switching your points and I have no idea anymore what you're saying, I fear.
14:28:07 <sethk> vincenz, do I have a quota on the number of points?  :)
14:28:15 <SamB> sethk: don't you know that pointing is rude?
14:28:30 <vincenz> sethk: no, but if you say "I was just pointing blabla" that means that you're refining a previous point, not making a new one
14:28:31 <sethk> SamB, No, I'm antisocial, never learned that stuff
14:28:42 <vincenz> making a new one while insinutating you're refining only confuses matter
14:28:43 <sethk> vincenz, indeed, and that's precisely what I was doing
14:28:52 <vincenz> heh
14:28:54 <vincenz> fence hopper
14:28:55 <sethk> vincenz, just because you can't remember it long enough to follow ... :)
14:28:57 <SamB> confusing matters?
14:29:10 * Toxaris wonders about pointfree discussion style
14:29:12 <SamB> that's precisely what you were doing?
14:29:16 <sethk> I'm extracting my code from a tarball so I can make some sense here
14:29:23 <sethk> because I've forgotten the syntax
14:29:30 <sethk> but I do have a point, that I'll get to presently
14:29:37 <vincenz> sethk: right, well it was fun discussing :)
14:29:47 <vincenz> sethk: next time if you want to have a constructive argument with someone, try not to offend them
14:30:10 <SamB> or deductive or whatever
14:30:24 <EvilTerran> so...
14:30:25 <SamB> any kind of argument besides a flamefest, basically ;-P
14:30:32 <EvilTerran> about them record systems
14:30:48 <EvilTerran> ;)
14:30:54 <SamB> EvilTerran: ooh, are you going to do something about that>
14:31:09 <sethk> SamB, actually, rarely on this channel
14:31:19 <cedricshock> Ahh, look what I started! Everybody gets cookies. Vincenz for pointing out that communication relies on some shared understanding of what the other parties understand, sethk for pointing out that the marshalling in haskell just works (we could find the entire answer by just trying to marshall repeat 1)..., and SamB for pointing out xml's almost sole beauty, that it isn't SGML. Oops. I flamed again...
14:31:51 <SamB> no, the beauty isn't that it isn't SGML
14:31:59 <EvilTerran> SamB, I would, but I'm only a lowly undergrad...
14:32:07 <SamB> the beauty as that you can parse it without a DOCTYPE
14:32:38 * EvilTerran struggles to find beauty in XML
14:32:40 <SamB> SGML with a doctype is cute
14:32:51 <SamB> especially if you don't even need any tags ;-)
14:33:37 <SamB> yes, I have encountered a doctype where you probably won't want any tags!
14:33:47 <sethk> SamB, an ML without M?
14:33:56 <EvilTerran> is it the bottom doctype?
14:33:57 * liyang waves at grahamhutton :)
14:34:11 <Boney> > marshall repeat 1
14:34:12 <lambdabot>   Not in scope: `marshall'
14:34:12 <grahamhutton> hi liyang!!!!
14:34:16 <cedricshock> EvilTerran: I suggest you stop looking. If they cut out about the entire language and just left the tags attributes, character data and some of the namespace stuff (i.e. the tiny bit of XML we all use) then it might be pretty...
14:34:26 <SamB> it's for DSSSL stylesheets appropriate for use with jade
14:34:57 <liyang> grahamhutton: Wouter is sometimes on as swiert; I can't think of any other Notts people off-hand. :3
14:35:00 <EvilTerran> i stopped looking somewhere around "--" being forbidden in comments
14:35:11 <grahamhutton> (liyang: my first time on IRC -- finally managed to install a client)
14:35:18 <SamB> if you don't use any tags, it will implicitly start all the elements you need to write a DSSSL stylesheet
14:35:47 <vincenz> tags could be encoded as natural numbers
14:35:56 <vincenz> and those could be encoded by extra <>'s around your stuff
14:35:57 <grahamhutton> liyang: yes, i know about swiert -- been lurking (checking logs) for ages, but never "logged on"
14:35:59 <vincenz> so no more tags :)
14:36:16 <davidL> grahamhutton: are you the one who wrote Programming in Haskell?
14:36:27 <grahamhutton> davdL: yes, that's right.
14:36:28 <geocalc> grahamhutton=<< you often quit or your client is buggy
14:36:33 <liyang> grahamhutton: be careful. It's a great place for wasting hours of time. :(
14:36:49 <dons> oh, alex has builtin lazy bytestring wrappers now.
14:36:49 <SamB> but not quite as good as webcomics
14:36:50 <dons> very nice
14:36:53 <grahamhutton> liyang: yes, i'm aware of this!
14:37:17 <quicksilver> I for some reason associate edwinb with notts?
14:37:24 * liyang heads back to the kitchen. brb.
14:37:28 <quicksilver> but maybe that's a chain of association notts -> conor -> edwinb
14:37:33 <quicksilver> rather than anything direct
14:37:39 <liyang> quicksilver: yes. :)
14:37:39 <grahamhutton> edwinb is an honoroary notts person -- doesn't work here (yet), but should.
14:37:54 <quicksilver> grahamhutton: in any case, he's here, although he doesn't talk much :)
14:37:58 * quicksilver pokes edwinb 
14:39:01 <grahamhutton> quicksilver: yes, there's many associations like this.
14:40:12 <faxathisia> hmm
14:40:20 <faxathisia> What is that really neat way to get a powerset of a list
14:40:32 <Cale> filterM (const [True, False])
14:40:37 <faxathisia> ah :D
14:40:40 <faxathisia> thanks
14:40:46 <ddarius> > filterM (const [True,False]) "abc"
14:40:48 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
14:40:50 <quicksilver> power [] = [[]]; power (x:xs) = power xs ++ map (x:) (power xs)
14:40:51 <dobblego> ?type filterM
14:40:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:40:55 <olsner> what's "notts"?
14:41:02 <vincenz> olsner: university in the uk
14:41:06 <quicksilver> cale's is neater, mine is maybe slightly more pedagogical :)
14:41:16 <grahamhutton> notts = university of nottingham, uk
14:41:32 <ddarius> quicksilver: Yours is the archetypical case of why CSE can be bad
14:41:40 <Cale> I like how closely the monadic one reflects the actual definition of the powerset
14:41:42 <olsner> aha! nottingham
14:41:59 <Cale> Or a definition, anyway
14:42:07 <quicksilver> Cale: well the monadic one takes an 'indicator function' approach
14:42:18 <Cale> You're basically saying "keep or don't keep each element"
14:42:19 * EvilTerran would be tempted to make it filterM (return [False ..]), just for the hell of it
14:42:43 <ddarius> Obfuscation is important to EvilTerran.
14:42:49 <quicksilver> of course
14:42:51 <quicksilver> he's evil!
14:42:55 <vincenz> EvilTerran: you mean const :)
14:42:59 <EvilTerran> >:]
14:43:01 <ddarius> return == const
14:43:06 <vincenz> ddarius: eh?
14:43:08 <EvilTerran> >  filterM (return [False ..]) [1,2,3]
14:43:09 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:43:10 <faxathisia> > [False ..]
14:43:11 <lambdabot>  [False,True]
14:43:12 <Cale> > return 5 6
14:43:12 <lambdabot>  5
14:43:12 <ddarius> > return 3 5
14:43:13 <vincenz> oh yeah, reader monad
14:43:13 <lambdabot>  3
14:43:20 <EvilTerran> @src (->) return
14:43:20 <lambdabot> return = const
14:43:31 <vincenz> :)
14:43:31 <ddarius> Cale: You confused me for a second.
14:43:47 <Cale> where?
14:43:55 <Cale> oh, heh
14:44:00 <EvilTerran> i quite like the evil involved in deliberately mixing two monads right next to each other
14:44:06 <faxathisia> also what is a good way to represent a grid of bits or small numbers?
14:44:13 <EvilTerran> when it's wholly unnecessary
14:44:15 <faxathisia> I mean a rectangle grid
14:44:21 <Cale> faxathisia: an array of Bool?
14:44:24 <olsner> EvilTerran: nice monad trick there
14:44:37 <vincenz> in the end
14:44:37 <Cale> UArrays of Bool are particularly cool, since they're bitpacked.
14:44:40 <vincenz> given enough monads
14:44:44 <vincenz> you can encode everything as monads
14:44:54 <Cale> and you can still index them with anything in the class Ix :)
14:44:58 <EvilTerran> olsner, well, most of the trick's Cale's. i just obfuscated.
14:45:06 <faxathisia> ok thanks a lot Cale I'll try it
14:45:42 <ddarius> @src Ix
14:45:42 <lambdabot> class (Ord a) => Ix a where
14:45:42 <lambdabot>     range           :: (a,a) -> [a]
14:45:42 <lambdabot>     index           :: (a,a) -> a -> Int
14:45:42 <lambdabot>     inRange         :: (a,a) -> a -> Bool
14:45:42 <lambdabot>     rangeSize       :: (a,a) -> Int
14:46:25 <ddarius> @src (Int,Int) index
14:46:25 <lambdabot> Source not found. That's something I cannot allow to happen.
14:46:41 <EvilTerran> @src Int index
14:46:41 <lambdabot> Source not found. Maybe you made a typo?
14:47:06 <geocalc> is missing atindex
14:47:09 <ddarius> I don't think there's a way to specify the proper thing to @src
14:47:28 <EvilTerran> @src index
14:47:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:47:45 <EvilTerran> i'm thinking it's probably not in @src's database
14:48:10 <gwern> what does @src work off of anyway? is it grepping a bunch of files?
14:48:47 <ddarius> My understanding is that it is a semi-mechanically predefined database.
14:48:58 <ddarius> Though I guess I could just look at the source and find out.
14:49:01 <ddarius> @src src
14:49:01 <lambdabot> Source not found. My mind is going. I can feel it.
14:49:12 <faxathisia> ddarius: I couldn't find it in lambdabot code
14:49:37 <ddarius> faxathisia: Find what?  Clearly @src is there.
14:49:48 <faxathisia> @src but not the code
14:49:48 <lambdabot> Source not found. Wrong!  You cheating scum!
14:49:56 <geocalc> is it not with haddock ?
14:50:09 * EvilTerran couldn't find the @src database in the lambdabot repo
14:51:21 <olsner> I was thinking about a cool concept the other day: encoding the complexity of operations in the type system, and then by inspecting the type of functions being able to extract something similar to O(n^2) or O(nlogn)
14:52:01 <quicksilver> olsner: you are not the first :)
14:52:17 <quicksilver> olsner: there was a thread about this on -cafe recently, for example
14:52:31 <grahamhutton> olsner: there is a paper about this by Nils Anders Danielsson at POPL 2008
14:52:52 <gwern> olsner: so you'd get types like (!!) :: (N a) => Int -> [a] -> a, or something?
14:53:03 <geocalc> link ?
14:53:05 <olsner> don't know how possible it is though... and laziness makes the idea of the complexity of an algorithm somewhat different and somewhat less useful, if you assume that most of all calculated (described?) data is never actually used
14:53:44 <grahamhutton> geocalc: http://www.cs.chalmers.se/~nad/publications/danielsson-popl2008.pdf
14:53:45 <lambdabot> http://tinyurl.com/yrvjlu
14:53:57 <geocalc> thanks
14:57:07 <geocalc> btw is there a pdftohtml in haskell ?
15:01:23 <quicksilver> geocalc: I shouldn't think so. PDF -> HTML is hard.
15:02:50 <vincenz> quicksilver: there's a poor solution, but yeah
15:03:01 <geocalc> hmm
15:03:07 <vincenz> quicksilver: PDF -> (HTML, [PNG])
15:04:05 <geocalc> png -> imagemagick
15:04:56 <geocalc> nothing white :: i can read
15:06:01 <geocalc> ?go pdf2html
15:06:03 <lambdabot> http://pdftohtml.sourceforge.net/
15:06:03 <lambdabot> Title: PDFTOHTML conversion program
15:15:17 <ddarius> geocalc: View this as an opportunity.
15:30:59 <grahamhutton> @seen swiert
15:30:59 <lambdabot> Last time I saw swiert was when I left #darcs, #ghc, #haskell and #scala 5d 2h 13m 27s ago, and .
15:33:36 <omg_911> i need help on a tree operation in haskell
15:34:16 <faxathisia> omg_911: What operation?
15:34:31 <vincenz> blink
15:34:39 <omg_911> i want to return the nth node, using depth first ordering
15:34:45 <omg_911> let me use paste
15:35:10 <vincenz> omg_911: so something like
15:35:16 <vincenz> generate_list_of_depth_first !! n
15:35:19 <faxathisia> I am really unsure if it's a good idea or not.. but maybe you could use the state monad?
15:35:23 <vincenz> nah
15:35:24 <vincenz> use a list
15:35:27 <faxathisia> oh.. vincenzs method is much better
15:35:36 <faxathisia> I keep forgetting the implications of lazyness
15:35:36 <grahamhutton> sounds like composition: compute depth first ordering, then select nth element
15:35:38 <vincenz> you can do a lot more stuff with it then :)
15:35:55 <hpaste>  omg_911 pasted "tree operation" at http://hpaste.org/3921
15:36:18 <vincenz> depth_first_tree Node v cs= v:concatMap depth_first_tree cs
15:36:26 <vincenz> doh
15:36:31 <vincenz> no that's correct
15:36:35 <omg_911> huh?
15:36:37 <vincenz> oh wow
15:36:41 <vincenz> ewy
15:36:59 <vincenz> you're doing two things at once
15:37:03 <vincenz> listing and then a loop
15:37:05 <vulpyne> How might I specify the type of an argument to a lambda function? Something like \x :: SomeTime -> blah blah doesn't seem to work.
15:37:06 <vincenz> you want to split the two
15:37:15 <vulpyne> Er, :: SomeType is  what I meant.
15:37:57 <vincenz> omg_911: what's with that Try stuff
15:38:03 <vincenz> omg_911: and why the conditionals on branches?
15:38:14 <Saizan_> vulpyne: use parens
15:38:19 <omg_911> i want to return the node if i find it
15:38:25 <Saizan_> \(x :: SomeType) ->
15:38:25 <omg_911> or return an index and keep looking
15:38:28 <vincenz> omg_911: easy nuff
15:38:34 <vulpyne> \(x :: SomeType) -> ... ?
15:38:57 <vulpyne> Yep, that works. Thanks!
15:39:17 <visof> can "tuples" do all the "data" do?
15:39:27 <omg_911> vincenz: i'm not sure
15:39:31 <visof> tuples can define different types
15:39:35 <LoganCapaldo> visof: tuples + either
15:39:45 <hpaste>  vincenz annotated "tree operation" with "woo" at http://hpaste.org/3921#a1
15:39:48 <vincenz> omg_911: check that
15:39:53 <LoganCapaldo> (and newtype depending on what you want to acheive)
15:40:18 <LoganCapaldo> functions can do all that "data" does too
15:40:32 <vincenz> omg_911: your original code doesn't make much sense
15:40:51 <visof> LoganCapaldo  explain further and give me simple example please?
15:41:05 <vincenz> omg_911: what is Try for?
15:42:06 <omg_911> vencenz: thanks, yours works great
15:42:33 <omg_911> vencenz: well i was having trouble figuring out how to continue the search if a sub branch has failed
15:42:35 <LoganCapaldo> data Tree a = Leaf a | Branch a (Tree a) (Tree a) --> newtype Tree a = Tree (Either a (Tree a, Tree a))
15:42:50 <LoganCapaldo> you need Either for the | secnarios
15:42:59 <LoganCapaldo> and you need newtype for the recursion
15:43:20 <vincenz> omg_911: remember
15:43:23 <vincenz> omg_911: every loop is a list
15:43:25 <vincenz> omg_911: so code it like a list
15:43:30 <vincenz> and then later you can do all sorts of fancy things
15:43:39 <vincenz> (it's like combining for loops of different kernels :)
15:44:09 <LoganCapaldo> visof: am I making sense?
15:44:16 <visof> ya
15:44:29 <visof> thanks
15:46:30 <visof> is a here "type" or value?
15:46:35 <visof> "a"?
15:47:12 <LoganCapaldo> it's a type parameter
15:47:28 <LoganCapaldo> you can have a Tree of Ints or a Tree of Strings or a Tree ...
15:47:37 <LoganCapaldo> Sorry
15:47:53 <LoganCapaldo> Maybe I shoudn't have thrown that in with the other stuff <g>
15:48:21 <vincenz> Tree of Trees of Ints
15:48:32 <visof> ya
15:48:34 <LoganCapaldo> them too
15:48:41 <visof> i understood
15:50:08 <visof> another question
15:50:19 <visof> what this "|" mean?
15:50:45 <visof> i learn in list comprehension something like that
15:50:56 <Saizan_> it's different
15:51:03 <dmwit> It is a guard, and it has a different meaning in function definitions.
15:51:06 <visof> [x^2| x <- [2..4]]
15:51:21 <Saizan_> dmwit: we're talking about data definition
15:51:42 <dmwit> Oh, geez, | is used everywhere.
15:51:45 <dmwit> =P
15:51:49 <visof> what is the difference between them?
15:51:55 <LoganCapaldo> if you have data Data = A | B | C that means A is a value of type Data and B is a value of type Data and C is a value of type Data
15:52:07 <ddarius> visof: They are all just syntax.  They don't have inherent meaning.
15:52:11 <dmwit> visof: In a data definition, separating things by | means "choose one of".
15:53:51 <visof> i couldn't understand
15:55:23 <dmwit> ok
15:55:38 <dmwit> A data type can have many different constructors.
15:55:46 <dmwit> Each constructor makes a distinct instance of that type.
15:56:03 <dmwit> So, you can have a type Animal with constructors Cat and Dog, for example.
15:56:32 <dmwit> Cat and Dog may store different information.
15:56:51 <dmwit> For example, you might have Cat :: Hunger -> TailSize -> Animal
15:57:02 <dmwit> and Dog :: Happiness -> Animal.
15:57:10 <dmwit> The way you express this in Haskell is
15:57:20 <dmwit> data Animal = Cat Hunger Tailsize | Dog Happiness
15:57:48 * SamB_XP likes
15:57:52 <dmwit> This says, "I am creating a new type called Animal, which has two possible inhabitants."
15:57:55 <visof> we have here two constructors cat and dog?
15:58:00 <dmwit> right
15:58:27 <dmwit> Note that here Hunger, Tailsize, and Happiness are themselves types.
15:58:38 <visof> so we separate between two constructors with "|"?
15:58:45 <dmwit> yes
15:59:21 <visof> bom bom bom don
15:59:27 <visof> i understood
15:59:31 <dmwit> heh
15:59:42 <visof> thanks dmwit
16:01:27 <visof> if we say   data pair a b = pair a b
16:01:46 <gabor> possible
16:01:46 <visof> we have here one constructor "pair" with two types
16:01:53 <dmwit> Err, not quite.
16:01:54 <faxathisia> you must use Pair
16:01:58 <visof> types parameters*
16:02:01 <dmwit> yes
16:02:02 <dmwit> !
16:02:16 <faxathisia> The language uses capitol letters to know that it's a pattern matching type constructor
16:02:25 <dmwit> But yes, as other people have said, in Haskell type names and constructors must begin with an upper-case letter.
16:02:42 <visof> ok
16:02:46 <gabor> and only those...
16:02:57 <Saizan_> gabor: and classes and modules
16:02:59 <dmwit> Type variables are lower case, as are function/variable names.
16:03:32 <gabor> and there can be a value and a type of the same name
16:03:41 <gabor> 2 namespaces
16:03:50 <grahamhutton> Haskell has a multitude of name spaces!
16:04:07 <gabor> the hierarchical ones?
16:04:48 <mmmdonuts> gabor, one example: data Foo = Foo | Bar
16:05:19 <gabor> yep, Foo as type and Foo as value (data constructor)
16:05:56 <grahamhutton> When teaching Haskell, things such as data Pair a b = Pair a b are totally confusing (and should be avoided)
16:06:06 <LoganCapaldo> data Bar = Foo Foo ; data Foo = Bar Bar
16:06:21 <vincenz> LoganCapaldo: only valid value of that is _|_
16:06:36 <vincenz> or some set of things on top of _|_
16:06:40 <gabor> in haskell there are no entities in the type plane with non-capital letters, right?
16:06:40 <LoganCapaldo> I don't see how that's a problem :)
16:06:46 <Saizan_> grahamhutton: yes, together with the syntactic sugar for lists
16:06:55 <dmwit> Foo (Bar (Foo _|_)) also seems to be of that type.
16:06:57 <vincenz> LoganCapaldo: might be interesting for error catching
16:07:04 <mmmdonuts> grahamhutton, if you want to get any more books written, get out of here while you still can! ;)
16:07:05 <vincenz> dmwit: read my second statement
16:07:08 <vincenz> ;)
16:07:13 <dmwit> Ah yes. =)
16:07:53 <grahamhutton> saizan: i don't agree about the list syntax --- [1.2.3] is easy to understand for beginners, 1:(2:(3:[]))) isn't.
16:08:56 <Saizan_> grahamhutton: many fall in the "type looks like contructors" trap and write functions like func [(a,b)] when they mean func ((a,b):xs)
16:10:17 <grahamhutton> I don't think this is a problem if types are introduced correctly.
16:10:43 <dmwit> I don't think it is a problem, period.
16:10:49 <dmwit> People make that mistake a maximum of two times.
16:11:10 <Saizan_> well, it just happen quite often to see mistakes like that on this channel
16:11:29 <mmmdonuts> hence my comment
16:13:44 <Saizan_> i mean, novices asking why their func doesn't work
16:24:44 <SamB_XP> Saizan_: as long as people include instructions to get on #haskell in their books ...
16:24:59 <shapr> dsfox: Thanks!
16:25:23 <shapr> dsfox: thetallguy said that you had some problems, are those cleared up?
16:26:37 <thetallguy> dsfox: I remember you got the packages built, but that you stopped using them.  Was it because things weren't complete yet?
16:39:00 <dufflebunk> Looks like the tmrwiki is having pretty bad spam problems:
16:39:02 <dufflebunk> http://www.haskell.org/tmrwiki/IssueFive_2fFeedBack_2fHRay
16:39:03 <lambdabot> Title: IssueFive/FeedBack/HRay - TmrWiki
16:42:13 <faxathisia> @src mapM
16:42:13 <lambdabot> mapM f as = sequence (map f as)
16:50:55 <faxathisia> arrayMapM f arr = map (listArray (bounds arr)) $ mapM f (elems arr)
16:51:52 <wli> How long before array comprehensions hit mainline?
17:05:21 * edwinb feels his ears burning
17:08:12 <edwinb> quicksilver: yowch ;)
17:09:28 <Philippa_> edwinb: yeah, the person responsible quit though. I'd say something about lightweights going to bed early except I was going to bed at 8pm the other week
17:09:39 <edwinb> heh
17:09:51 * edwinb makes a note to pay attention to this channel more often
17:10:24 <Philippa_> yeah, it's a bit like that. I probably don't pay enough attention these days
17:10:48 <edwinb> I just pretend that I've been doing work or something...
17:11:01 <Philippa_> My Summer of Code t-shirt showed up today - finally I got "paid" for something! :-)
17:11:14 <edwinb> oooh!
17:12:25 <ddarius> Where is xerox's Parsec stuff?
17:12:33 <faxathisia> changes to parsec?
17:12:34 <Syzygy-> Ysy!
17:13:00 <Philippa_> ddarius: Google Code. I could use a tarball of the stuff he did after the deadline sometime and someone willing to give me a hand bashing it into prerelease-ready state, it didn't quite get enough coding time in the end
17:13:59 <ddarius> Philippa_: How much effort do you think remains?
17:15:05 <Philippa_> it's largely neatening work. I think there were a couple of bug fixes needed doing too, I definitely need to pin xerox down and extract info sometime - but the big features are in and essentially work
17:16:12 <Philippa_> the really big bit there is that it means all the mind-bending stuff's been done already
17:16:29 <thoughtpolice> speaking of the soc stuff, what about the XCB bindings?
17:16:34 <ddarius> Yeah, that's the important part.
17:17:35 <ddarius> Philippa_: What's the size of the codebase roughly?
17:17:46 <Philippa_> it's not actually all that mind-bending if you're used to thinking about compiler work - turning a monad into a monad transformer is just a matter of translating the implementation to monadic form
17:18:02 <Philippa_> ~1KLoC IIRC
17:18:37 <Philippa_> there's not an awful lot of boilerplate in it. Parsing really is one of the things functional languages are good at
17:19:35 <ddarius> Philippa_: If you promise to harass me constantly enough, I have no problem giving you a hand.
17:20:14 <Philippa_> cool. What kind of frequency am I looking at? (I figure it's not actually measured in Hz, which saves an inappropriate @quoting)
17:21:50 <ddarius> A couple hours most weekday afternoons.  Probably some weekends.
17:22:32 <Philippa_> okay. Can talk timezone shifting in a bit once I've got a more recent tarball and a bug list from xerox
17:22:56 <Philippa_> I figure you're at least the right side of the greenwich meridian from the POV of my dodgy sleep patterns
17:23:15 <Philippa_> edwinb: how're you doing?
17:23:43 <edwinb> Philippa_: good question ;)
17:24:02 <edwinb> need to secure more employment, but we've just finished what I think is a fun paper for PLDI
17:24:18 <ddarius> link?
17:24:32 * edwinb looks around for potention reviewers before revealing what it is ;)
17:24:34 <ddarius> Philippa_: Well, due to my occupation, my sleep patterns are mostly normal.
17:24:36 <edwinb> er, potential
17:24:59 <Philippa_> I inferred "normal enough" from "weekday afternoons" :-)
17:31:31 <Heffalump> is PLDI doing double-blind reviewing, then?
17:31:57 <edwinb> yes
17:32:16 <edwinb> I'm not a big fan of that myself...
17:32:24 <edwinb> but you have to play by the rules ;)
17:40:11 <goalieca> time to pull huet
18:03:04 * shapr tries the dsfox packages
18:28:08 <Nafai> shapr: What's dsfox?
18:28:53 <thetallguy> Nafai: Who is dsfox.
18:29:25 <thetallguy> Nafai: Friend of mine who is building Debian packages
18:31:50 <Nafai> Ah, cool
18:32:34 <faxathisia> @pl putStrLn ""
18:32:35 <lambdabot> putStrLn []
18:34:04 <EvilTerran> putChar '\n', if you prefer?
18:34:56 <EvilTerran> although there'd be some merit, imo, in having a putLn function
18:41:43 <Nafai> So, if do notation is merely "syntactic sugar", is there something (in lamdbabot maybe) that will convert code written in do notation to the form that uses bind?  Just curious so I can learn better about the other style
18:41:54 <faxathisia> @undo
18:41:55 <lambdabot> ()
18:42:49 <allbery_b> @undo do { x <- y; return (foo x) }
18:42:50 <lambdabot> y >>= \ x -> return (foo x)
18:44:34 <Nafai> Cool, thanks
18:44:50 <ddarius> The syntactic sugar is very light, i.e. the transformation is
18:44:52 <ddarius> -very- simple.
18:44:55 <Nafai> True
18:45:10 <ddarius> You've seen all the crux of it there in allbery_b's example.
18:46:41 <sorear> > do 1 `asTypeOf` ()
18:46:42 <lambdabot>  Couldn't match expected type `t t1' against inferred type `()'
18:49:41 <faxathisia> @pl if x then "#" else " "
18:49:42 <lambdabot> if' x "#" " "
18:49:57 <faxathisia> @src if'
18:49:57 <lambdabot> Source not found. :(
18:50:13 <ddarius> if' is the obvious definition, but it's just something @pl uses.
18:50:20 <sorear> faxathisia: yup, can't be @pl'd in any remotely pretty way
18:50:31 <kkk> #EMAC
18:53:15 <ddarius> @pl if True then 1 else 2
18:53:15 <lambdabot> if' True 1 2
18:53:18 <ddarius> Darn.
18:53:21 <SamB_XP> hah
18:53:26 <SamB_XP> pathetic effort!
18:53:26 <faxathisia> ohh
18:53:32 <SamB_XP> lambdabot: try harder
18:53:34 <faxathisia> Now I realize why :: is two chars
18:53:38 <faxathisia> So you can line up with -> :p
18:53:56 <SamB_XP> faxathisia: no, because ML got it the wrong way round and it was ugly
18:54:11 <faxathisia> I don't think it's ugly..
18:54:22 <SamB_XP> with their f (x1::x2::xs) = ...
18:54:23 * ddarius much prefers a single colon for "types" when such things come up in math.
18:54:33 * ddarius does prefer Haskell's way for Haskell though.
18:54:33 * mkehrt_office agrees ML got it right
18:54:40 <mkehrt_office> oh
18:54:41 <mkehrt_office> heh
18:54:44 <mkehrt_office> oh well
18:54:52 <faxathisia> :(
18:54:57 <mauke> ML got it obviously wrong
18:55:04 <SamB_XP> mkehrt_office: see, you can use views in math
18:55:10 <faxathisia> I keep seeing data .. = !Foo
18:55:14 <SamB_XP> creatively
18:55:16 <sorear> ML is a much more elegant language
18:55:20 <sorear> it's just ugly
18:55:27 <SamB_XP> sorear: how does that WORK
18:55:41 <mkehrt_office> I think sorear means syntactically
18:55:43 <SamB_XP> more elegant it's just ugly?
18:55:46 <ddarius> ML isn't a bad language, it's just syntactiaclly ugly.
18:55:49 <SamB_XP> oh
18:55:55 <SamB_XP> you mean it has a nicer AST?
18:56:22 <ddarius> That said, I consider ML to be about comparable with Haskell in elegance (modulo syntax), but then I haven't looked at any of the MLs all that much.
18:56:32 * mkehrt_office goes back to writing ML and not arguing language aesthetics
18:59:54 <faxathisia> mm
19:00:03 <faxathisia> I really wonder if there is a better way to print a 2D array as a grid
19:00:14 <faxathisia> I wrote this horrible thing with nested mapM
19:00:19 <brad__> is there anyway to determine what the path is for Setup in the ghc build process - ghc 6.8.1 claims it cannot find "happy" even though it is in /usr/local/bin and i symlinked it to /usr/bin...
19:02:18 <SamB_XP> brad__: does it run?
19:02:24 <brad__> yes
19:02:33 <brad__> and the configure step for ghc actually detects it too
19:02:43 <brad__> which makes the failure to find it later more strange
19:03:35 <brad__> is there some local dir in the build path that i should copy it to?
19:04:46 <SamB_XP> that whole deal sounds pretty funky
19:04:54 <SamB_XP> I don't think copying it will help
19:05:13 <brad__> yes, seems strange, i am starting to wonder how well the ghc build process is tested
19:05:22 <sorear> I don't think I'm going to bother with 6.8.1, too many horror stories.
19:05:42 <brad__> if you can get it to build, you're a guru!
19:05:51 <sorear> brad__: go whine on #ghc, more likely to be noticed by the People In Power
19:05:58 <SamB_XP> it didn't used to be hard to build
19:06:04 <brad__> oh okay sorear!
19:06:07 <brad__> thats a better idea
19:06:27 <brad__> you folks are always so sympathetic though! its soothing to vent here
19:07:01 <brad__> anyway thanks and i will go check out #ghc
19:09:24 <ddarius> sorear: Aren't you using 6.9 anyways?
19:09:32 <sorear> ddarius: 6.7
19:09:41 * ddarius was mostly joking.
19:09:50 <hpaste>  faxathisia pasted "unsightly showGrid?" at http://hpaste.org/3922
19:10:13 <faxathisia> is there any other thing I should use than mapM to try and write htis better?
19:10:28 <faxathisia> It's just printing an array as a 2D grid
19:11:03 <ddarius> mapM_ would be better, and forM_ likely more so
19:11:32 <faxathisia> thanks :D
19:11:41 <sorear> faxathisia: Do you have a good reason to be using arrays?
19:11:48 <faxathisia> I don't know..
19:12:04 <mae> how do I define a class as one of the fields in a data type?
19:12:16 <mae> are you only allowed to use static types?
19:12:28 <faxathisia> what is the reason for using an array
19:12:31 <sorear> mae: What would using a class mean?
19:12:33 <ddarius> mae: That doesn't make sense anyway
19:13:29 <mae> ok here is what i have, a data class 'Rate' of which there are instances AnnualRate MonthlyRate and DailyRate .. the class definition defines three functions toAnnual  toMonthly toDaily
19:13:32 <mae> all this works fine and dandy
19:13:50 <mae> so i want to create a data type 'Balance' that has two fields, Amount, and Rate
19:14:00 <mae> Rate being a class
19:14:28 <ddarius> mae: Haskell type classes aren't OO classes.
19:14:46 <mae> yeah i know all that, i guess i was hoping someone could explain how to make this concept more "haskelly"
19:14:59 <mae> still weaning myself off of ruby
19:15:12 <sorear> mae: Define a single type Rate which represents a rate.
19:15:15 <faxathisia> why s it called forM_ and not forM?
19:15:28 <ddarius> faxathisia: Because there is a forM and it does something different from forM_
19:15:29 <sorear> mae: Whether it is expressed annually or daily is irrelevant
19:15:36 <sorear> mae: it's still a % per year
19:15:44 <sorear> mae: perhaps fractional
19:15:48 <mae> sorear: the reason i want a data class Rate is because I want the rate to be stored in whatever format is the "original" format, hence i don't make any lossy calculations with doubles until the very last moment
19:15:56 <sorear> mae: don't draw false distinctions
19:16:08 <sorear> mae: why do lossy calculations with doubles?
19:16:19 <sorear> mae: haskell has exact rational arithmetic
19:16:31 <sorear> > 1 / (1 % 293943203490945954093480)
19:16:32 <SamB_XP> sorear: because that's the only kind of calculations you can do with doubles, duh ;-P
19:16:33 <lambdabot>  293943203490945954093480%1
19:16:36 <mae> well for instance, suppose one creditor provides me only with an annual rate, but it is in actuality calculated daily, etc etc
19:16:47 <ddarius> SamB_XP: False.
19:16:51 <SamB_XP> except under certain constraints
19:16:57 <ddarius> Better.
19:17:07 <mae> sorear: i've been trying to exactly duplicate the financial calculations for my AMEX card :)
19:17:09 <mae> but the funny thing is
19:17:23 <mae> i think the calculations that it makes actually depends on the lossiness of floats
19:17:32 <SamB_XP> !
19:17:36 <mae> because the "exact" numerical calculation is one penny off of what is on my statement :)
19:18:09 <mae> it is like 131.07 on the statement and calculates out to 131.08 exactly... but when i do floats it comes out to 131.079999999998 or something
19:18:18 <mae> so i think it does a floor on the cents
19:18:24 <mae> after making a lossy calculation
19:18:33 <SamB_XP> what is this "exact" calculation?
19:18:43 <allbery_b> more commonly it uses ints with the decimal place moved
19:18:56 <ddarius> "fixed precision"
19:19:00 <mae> to predict credit card financial charges, so as to automatically calculate the best distribution to get the best rate..
19:19:02 <allbery_b> which would have a similar effect to doing a floor on every calculation
19:19:09 <ddarius> (Well, decimal fixed precision)
19:19:32 <SamB_XP> if it's exact, why is it giving you 131.08, and not some much longer irrational number?
19:19:44 <mae> allbery_b: i tried that but that comes out wrong, the only calc that comes out correct is when i floor the cents after i do double division, when i do any exact financial calculations they are off :)
19:20:47 <mae> SamB: basically what i'm trying to say is, after fidgeting with it for awhile, it seems their calculation is that it is all done with floating point calculations with the fractional cents truncated rather than rounded
19:21:06 <mae> if i break it into daily exact cents the calculation is off
19:21:09 <mae> its weird
19:21:12 <wli> mae: Try arbitrary-precision BCD.
19:21:22 <mae> is that the %?
19:21:25 <faxathisia> sorear: you got me worried should I an array? :p
19:21:38 <SamB_XP> try using 100-place numbers in maple or mathematica or maxima or something
19:21:58 <SamB_XP> with continuously compounded interest
19:21:59 <sorear> faxathisia: Maybe, it depends, what are you doing with these arays?
19:22:07 <ddarius> wli: If the arbitrary precision BCD is exact then the result will be the same as an exact calculation otherwise.
19:22:12 <SamB_XP> you do know what continuously-compounded means?
19:22:14 <faxathisia> sorear: solving minesweeper [hopefully]
19:22:33 <faxathisia> so I wanna be able to make copies and changes quickly
19:22:47 <mae> yeah i do
19:22:55 <SamB_XP> faxathisia: how big are your playing fields?
19:23:10 <mae> but it is calculated at a daily rate
19:23:14 <sorear> faxathisia: You won't get that from an Array, you need a Map or an IO(U)Array
19:23:15 <faxathisia> I don't know really.. I have a 4x4 test but I would like to do a lot bigger
19:23:23 <mae> i mean i know it is all relative if you calculate it
19:23:30 <mae> but i am just trying to emulate their exact calculations
19:23:33 <mae> first and foremost
19:23:35 <SamB_XP> daily?
19:23:35 <faxathisia> What is the point in array then?
19:23:53 <SamB_XP> sorear: arrays are plenty fast if small enough
19:24:14 <ddarius> Anything is plenty fast if small enough.
19:24:34 <sorear> faxathisia: Constant time lookups
19:24:35 <SamB_XP> I think small enough may be larger than sorear thinks ;-)
19:24:42 <faxathisia> alright
19:25:07 <mae> sorear: i get "not in scope" when i try that "exact" arithmetic in ghci
19:25:27 <ddarius> @index (%)
19:25:27 <lambdabot> Data.Ratio
19:26:10 <mae> how do i load that into prelude ? :)
19:26:15 <shapr> @users
19:26:15 <lambdabot> Maximum users seen in #haskell: 413, currently: 368 (89.1%), active: 13 (3.5%)
19:26:25 <SamB_XP> mae: eh, that's not how we call it
19:26:36 <mae> ??
19:26:39 <ddarius> mae: You don't.  You can load that module in GHCi with :m Data.Ration or import it when in a file.
19:26:50 <ddarius> mae: The Prelude is a specific module.
19:27:00 <ddarius> s/Data.Ration/Data.Ratio
19:27:13 <sorear> mae: You modify the Prelude by joining the Haskell-prime committee.
19:27:16 <ddarius> Also, you can import the more "standard" Ratio module instead of Data.Ratio
19:27:22 <SamB_XP> oooh. I want Data.Ration
19:27:24 <SamB_XP> it sounds yummy
19:27:30 <mae> lol
19:27:35 <ddarius> SamB_XP: Ever have an MRE?
19:27:37 * faxathisia bags Data.InstantNoodles
19:27:46 <SamB_XP> ddarius: a what?
19:27:53 <shachaf> SamB_XP: It's actually Data.TripeRation -- not what you want at all.
19:28:03 <SamB_XP> shachaf: eh?
19:28:05 <allbery_b> US army field rations.  "meals ready to eat"
19:28:09 <ddarius> SamB_XP: Meals-Ready-to-Eat, what is typically used as "rations" nowadays.
19:28:16 <allbery_b> (for dubious values of "meals" and "eat")
19:28:17 <SamB_XP> shachaf: haskell doesn't allow different modules to have the same appearence
19:28:25 <ddarius> allbery_b: And "ready"
19:28:39 <SamB_XP> ddarius: this is Haskell we are talking about
19:28:44 <SamB_XP> not US ARMY fare
19:28:45 <shachaf> SamB_XP: Sure, but all it does is import it.
19:28:53 * ddarius isn't in the US Army.
19:28:55 <SamB_XP> I was thinking gummy lambdas
19:29:00 <SamB_XP> or something
19:29:01 <shachaf> SamB_XP: They haven't implemented .FoodRation yet, so that's the default.
19:29:04 <SamB_XP> I dunno
19:32:53 <mae> ok and how to turn a rational back into a float? :)
19:33:01 <mae> or to round to 2 decimal places?
19:33:11 <ddarius> @src RealFrac
19:33:12 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
19:33:12 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
19:33:12 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
19:33:19 <ddarius> @src Real
19:33:19 <lambdabot> class  (Num a, Ord a) => Real a  where
19:33:19 <lambdabot>     toRational      ::  a -> Rational
19:33:24 <ddarius> @src Fractional
19:33:24 <lambdabot> class  (Num a) => Fractional a  where
19:33:24 <lambdabot>     (/)             :: a -> a -> a
19:33:24 <lambdabot>     recip           :: a -> a
19:33:24 <lambdabot>     fromRational    :: Rational -> a
19:33:49 <ddarius> @hoogle round
19:33:50 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
19:33:50 <lambdabot> Text.Html.background :: String -> HtmlAttr
19:33:50 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
19:37:04 * wli doesn't like how his attempt at an arbitrary-precision BCD floating point module looks.
19:37:24 <andyjgill> Is is possible to have a function that takes no arguments?
19:37:36 <Olathe> > let f = 5 in f
19:37:37 <lambdabot>  5
19:37:52 <andyjgill> Yes, but is f a function?
19:37:56 <ddarius> wli: If you didn't care about efficiency, then you should be able to knock something out fairly quickly.
19:38:04 <ddarius> andyjgill: Define "function".
19:38:18 <andyjgill> :-) thats what I'm trying to do.
19:38:36 <ddarius> andyjgill: Some people consider variables to be nullary functions some people don't.
19:38:42 * wli managed to get something knocked out a bit ago (NFI how quickly) but I made a mess of it somehow.
19:38:53 <andyjgill> I'm describing value bindings in Haskell, and compare them with C functions, but that take no arguments (vs take void).
19:39:12 <andyjgill> Is a nullary function a correct description?
19:39:37 <ddarius> A correct description of what?  The C functions?  Sure.
19:39:53 <andyjgill> I can understand how functions actually ever take 1 argument, and currying is the hack that lets you apply with n arguments
19:40:07 <ddarius> In strict languages there is a distinction between values and "nullary functions".
19:40:24 <andyjgill> f () =   ... vs f = ...
19:40:26 <sorear> wait, is this the same andyjgill who wrote hpc? :P
19:40:33 <andyjgill> yes.
19:40:39 <ddarius> andy, run while you can!
19:40:56 <sorear> andyjgill: There are two fully equivalent ways to think of functions in Haskell.
19:41:07 <andyjgill> I'm just checking my terminology, with functions that take no arguments
19:41:25 <sorear> andyjgill: Option 1: Functions take one argument, and are a type of value.  () is NOT a function; (+) takes a value and returns a function.
19:41:49 <sorear> andyjgill: Option 2: All values are functions taking N arguments.  () takes 0 arguments, (+) takes (at least) 2.
19:42:28 <andyjgill> And by construction, you can get 2 from option 1, for n arguments, n >= 1
19:42:57 <ddarius> You can easily get n+1 from n for all non-negative n.
19:43:25 <andyjgill> Its the base case, of course, it always is :-)
19:43:37 <Cale> I usually only consider to be something a function if its top level type constructor is (->)
19:43:49 <Cale> whoops, editing mistake there :)
19:43:59 <Cale> I usually only consider something to be a function if its top level type constructor is (->)
19:44:20 <andyjgill> Okay, so is saying function with no argument as an informal description of CAFs makes sense to others, I use that
19:45:47 <sorear> andyjgill: yes it does
19:46:01 <andyjgill> Thanks
19:46:17 <Cale> Making the words "function" and "value" synonymous is a little funny though.
20:05:38 <faxathisia> @undo do return 1
20:05:38 <lambdabot> return 1
20:05:52 <ddarius> do m ~> m
20:07:13 <sorear> Quiet day.
20:11:44 * wli hammers out BCD code since he's not able to do anything more intelligent like CPO-STV.
20:13:33 <faxathisia> I wanna ask about this list comprehension if it's ok..
20:13:59 <hpaste>  faxathisia annotated "unsightly showGrid?" with "enableCells" at http://hpaste.org/3922#a1
20:14:36 <faxathisia> I just wonder if this is a good way (or if there is a better way) to map one array into a new one
20:15:03 <dons> mm
20:15:05 <dons> let's see  :)
20:15:14 <dons> looks a bit side effecty
20:15:36 <faxathisia> I am struggling with this array type :S
20:15:50 <faxathisia> I don't know what the natural ways to operate on it are
20:16:06 <dons> there's not many natural ways on haskell arrays, as they are.
20:16:38 <dons> forM helps here
20:17:29 <faxathisia> To use forM, since it's a 2D array.. should I define an instance for Enum (a, b) ?
20:17:54 <faxathisia> (so I could do [(x,y)..(w,h)])
20:18:35 <dons> no no.
20:19:04 <hpaste>  dons annotated "unsightly showGrid?" with "mapM -> forM" at http://hpaste.org/3922#a2
20:19:39 <faxathisia> ahh
20:20:20 <hpaste>  dons annotated "unsightly showGrid?" with "another attempt" at http://hpaste.org/3922#a3
20:21:17 <faxathisia> yeah It's a lot more clear
20:23:23 <dons> hmm, so the lesson here is: when you can use whitespace freely, use it :)
20:24:47 <hpaste>  faxathisia annotated "unsightly showGrid?" with "as a map" at http://hpaste.org/3922#a4
20:24:51 <faxathisia> so now I can reuse it :D
20:24:54 <faxathisia> thanks a lot dons
20:24:57 <sclv> faxathisia: this might be a terrible idea, but if you get the elems of the array, it will be essentially "flattened" right? so you get the elems and then map show over them and map over that a function that intersperses a newline at every yth element, where y is the width of the array, and then you can just mapM a print over  the whole thing?
20:25:53 <faxathisia> how do you intersperse ever yth?
20:25:57 <faxathisia> I mean does this already exist?
20:26:38 <sclv> nah, but shouldn't be too hard to write... concat . intersperse . chunk (where chunk doesn't exist but has been defined plenty of times)
20:27:41 <faxathisia> > let f x = (take 3 x) : f (drop 3 x) in f [1..20]
20:27:42 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20],[],[],[],[...
20:28:17 <sclv> ty Data.Array.IArray.amap
20:28:23 <sclv> @ty ty Data.Array.IArray.amap
20:28:24 <lambdabot> Not in scope: `ty'
20:28:28 <sclv> @ty Data.Array.IArray.amap
20:28:29 <lambdabot> forall e' e (a :: * -> * -> *) i. (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.IArray a e') => (e' -> e) -> a i e' -> a i e
20:29:15 <sclv> for chunk, use an unfold or throw a takeWhile (not . nil) in
20:31:30 <faxathisia> > let chunk n xs = takeWhile (/= []) $ chunked xs ; chunked xs = take n xs : chunked (drop n xs) in chunk 3 [1..13]
20:31:30 <lambdabot>   Not in scope: `n'
20:31:37 <faxathisia> ach
20:31:48 <faxathisia> chunk n xs = takeWhile (/= []) $ chunked xs where chunked xs = take n xs : chunked (drop n xs)
20:31:51 <faxathisia> Well I think that is ok /
20:31:53 <faxathisia> Is it?
20:32:07 <faxathisia> (it does work)
20:34:11 <sclv> > let chunk n = takeWhile (/= []) . chunked where chunked xs = take n xs : chunked (drop n xs) in chunk 3 [1..20]
20:34:12 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
20:34:48 <kfish>     Warning: Module `Data.IORef' is imported, but nothing from it is used,
20:34:50 <kfish> w00t :-)
20:34:56 <faxathisia> *glerk*
20:34:56 <dons> sweet :)
20:35:06 <dons> that's such a satisfying warning
20:35:11 * kfish is doing some happy refunctoring
20:35:20 <sclv> > let chunk n = takeWhile (/= []) . chunked where chunked xs = take n xs : chunked (drop n xs) in intersperse 0 $ chunk 3 [1..20]
20:35:20 <lambdabot>   add an instance declaration for (Num [t])
20:35:44 <sclv> > let chunk n = takeWhile (/= []) . chunked where chunked xs = take n xs : chunked (drop n xs) in intersperse [0] $ chunk 3 [1..20]
20:35:45 <lambdabot>  [[1,2,3],[0],[4,5,6],[0],[7,8,9],[0],[10,11,12],[0],[13,14,15],[0],[16,17,18...
20:36:31 * shapr installs all the libs one by one
20:37:41 <shapr> Bah, I wish autoreconf could be called by cabal.
20:38:38 <Nafai> I used Haskell at work the other day :)
20:38:47 <hpaste>  faxathisia annotated "unsightly showGrid?" with "alternative showGrid" at http://hpaste.org/3922#a5
20:38:51 <faxathisia> very unixy :p
20:45:42 <hpaste>  sclv annotated "unsightly showGrid?" with "yay @pl! (oh, and the `dot` operator could help, right?)" at http://hpaste.org/3922#a6
20:46:00 <shapr> Nafai: What did you do?
20:46:36 <Nafai> shapr: I needed a large CSV file to test a procedure and generating a million line file with Python was too slow
20:46:48 <Nafai> So I did my first real file i/o in Haskell :)
20:46:48 <shapr> cool!
20:48:05 <shapr> Nafai: How did you like it?
20:49:19 <sclv> we need a pl that we can teach `dot` and `in` to
20:50:37 <Nafai> shapr: It was cool, and I actually suprised myself when I used mapM instead of map first
20:50:49 <dons> Cale: this reminded me of one of yours :)  http://science.slashdot.org/comments.pl?sid=362251&cid=21373093
20:50:51 <lambdabot> Title: A New Theory of Everything?
20:50:56 <dons> the comment, that is.
20:51:32 <ddarius> Stop with the mapM of putStr
20:52:06 <hpaste>  tehgeekmeister pasted "typing woes in parseRadix" at http://hpaste.org/3923
20:52:10 <faxathisia> ddarius: is mapM_ ok?
20:52:22 <Nafai> ddarius: Even if you have a list of strings?
20:52:29 <dons> faxathisia: yeah, since you're discarding the result
20:52:43 <dons> you rarely want the list of () you get back from print statements
20:52:51 <Cale> dons: :)
20:52:54 <faxathisia> this is so cool :D
20:53:02 <faxathisia> I convert game of life into a set of minesweeper problems
20:53:07 <faxathisia> now I have to write a solver for that :p
20:53:20 <Nafai> Ah
20:53:29 <Nafai> That might explain the memory usage
20:53:32 <dmwit> So you turned a P problem into an NP problem? =P
20:53:43 <faxathisia> hehe
20:54:29 <tehgeekmeister> re the code i just hpasted, it's for exercise 1.3.4 in write yourself a scheme in 48 hours
20:55:13 <Cale> > 24*7
20:55:14 <lambdabot>  168
20:55:27 <Nafai> Oh well
20:55:34 <wli> "Write Yourself a Haskell in 168 Hours?"
20:55:38 <Cale> hehe :)
20:55:40 <faxathisia> lol
20:55:43 <Nafai> I still wrote Haskell, albeit bad Haskell, for work :)
20:56:25 <tehgeekmeister> that'd be a fun tutorial.
20:56:27 <wli> Why not? Enough people are fascinated by its inner workings.
20:57:02 <Cale> It would be really nice to have a Haskell which uses a rewriting semantics that keeps everything in terms of Haskell expressions all the way through.
20:58:26 <Cale> So you could watch all the lazy evaluation take place step by step.
20:58:58 <Cale> (If anyone's thinking of doing a Haskell in 168 hours tutorial :)
20:58:58 <wli> I did something disturbingly like that.
20:59:51 <wli> A long time ago and very incomplete, though.
21:01:25 <wli> http://holomorphy.com/~wli/grid/
21:01:26 <lambdabot> Title: Index of /~wli/grid
21:01:30 <hpaste>  dmwit annotated "unsightly showGrid?" with "separate array->list conversion and IO bits" at http://hpaste.org/3922#a7
21:01:36 <wli> I don't think I could write even that much anymore.
21:02:45 <wli> Basically it was some intermediate phase of the pj-lester book with a step-by-step debugger.
21:02:51 <faxathisia> interesting
21:03:08 <wli> So you could examine the heap and other abstract virtual machine state.
21:07:31 <dons> nice haskell benchmark of the day (new shootout puzzle), http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
21:07:32 <lambdabot> Title: thread-ring (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2lyngq
21:09:41 <mmmdonuts> I love the Ruby result in that benchmark
21:09:43 <dmwit> Whoa, Java 6 -server #2 is beating everybody by a lot.
21:10:53 <bos> tiny green threads will crush opposition there. erlang would probably do nicely.
21:11:30 <dons> dmwit: just functions flipping back and forward
21:11:43 <allbery_b> hm, that reminds me.  bytestring was integrated into base to make it available by shootout rules.  what happens with the mega-split?
21:11:53 <dons> scary times, possible, allbery_b
21:12:03 <dons> i'll talk to isaac about it, and ensure we get some packages on there
21:12:15 <dons> as long as they're easily installable from gentoo, shouldn't be too much of a problem
21:12:43 <Cale> Also, the bytestring package is included with 6.8.1, isn't it?
21:12:50 <Cale> (at least, in the big version?)
21:13:18 <dons> in the big versoin, yeah
21:13:27 <dons> but for  the shootout it depends on what is in gentoo's package system
21:15:06 <sclv> i look forward to a php implementation that will make ruby look good in comparison.
21:15:24 <dons> php and ruby do battle it out for the wooden spoon
21:15:27 <kfish> i look forward to a shootout where we control the rules :-)
21:15:29 <dons> with javascript
21:15:49 <dons> kfish: well, we do ok on this one. we've had a long relationship with the present maintainers
21:15:58 <dons> its also, happily, the most widely read
21:16:29 <kfish> whatabout the banned implementations and forced rewrites of code?
21:16:40 <kfish> is that less of a problem now?
21:16:58 <dons> well, that's still the case, but the rules have tightened for everyone
21:17:18 <dons> so its a bit fairere
21:17:25 <allbery_b> note that java 6 server #2 fell to that rule
21:17:31 <dons> right
21:17:50 <dons> and we lose out on sum-file
21:18:02 <dons> and binary-trees is a strict benchmark, unnec.
21:18:06 <dons> but oh well, its ok.
21:18:57 <wli> What did Java 6 server #2 do?
21:20:01 <wli> Or otherwise, why was it disqualified?
21:20:10 <sclv> cooperative threads with a scheduler
21:20:11 <allbery_b> looks like it wrote its own custom threading mechamisn
21:21:33 <sclv> why did the nice fasta ghc implementation get disqualified by the way?
21:22:52 <sorear> sclv: because fasta is a walking personality conflict
21:23:50 <dons> oh, we did have fasta removed. hmm. didn't notice that
21:24:07 <dons> ah, uses Int math
21:24:16 <dons> its not that nice, just faster
21:24:34 <dons> completely different data structures used though
21:24:54 <dons> i'm sure we can improve fasta
21:25:04 <dons> that's a relatively naive bytestring entry
21:25:15 <hpaste>  tehgeekmeister annotated "typing woes in parseRadix" with "working version." at http://hpaste.org/3923#a1
21:25:41 <tehgeekmeister> anyone want to explain to me why the second version worked and the first didn't?  or rather, i know why the second worked, but i'm not sure why the first didn't.  could someone explain?
21:26:00 <dons> sorear: you should submit fast haskell programs :)
21:26:06 <dons> what do you do with your spare time now?
21:29:16 <dons> first (or second) 2008 hackathon planning underway, http://haskell.org/haskellwiki/Hac_2008
21:29:34 <allbery_b> prefix >> liftM (\x ->  case x of
21:29:42 <allbery_b> shouldn't that be >>= ?
21:29:48 <tehgeekmeister> yes, it should
21:29:50 <kfish> dons: is that hackathon co-located with a conference?
21:29:58 <allbery_b> (your first try)
21:29:59 <tehgeekmeister> i noticed that as i wrote the second version
21:30:15 <ddarius> dons: We're more than a factor of 2 behind C++, obviously there is room for improvement.
21:30:59 <Cale> More than a factor of 2 where?
21:31:02 <Cale> In general?
21:32:46 <sclv> the regex-dna one also looks pretty bad in terms of performance. is that because it relies on slow built in regex bindings?
21:33:25 * sclv would like to contribute to the shootout but still doesn't really know anough
21:33:32 <sclv> s/anough/enough
21:35:00 <sclv> group
21:35:20 <sclv> er groupBy notHeader also looks like maybe not the most efficient way to do things.
21:35:27 <bos> sclv: yes, t.r.posix is slow. t.r.pcre is also slow, but much faster.
21:37:01 <dons> kfish: don't think so this time.
21:37:12 <dons> so it'll be a .eu thing
21:38:26 <dons> ddarius: yes, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gpp
21:38:27 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/yptp36
21:38:34 <dons> meteor could be improved with little effort
21:38:37 <dons> its just a bit large
21:39:46 <dons> the current meteor entry is the only haskell one anyone's tried to do, afaik
21:39:52 <dons> so there's free points there
21:39:59 <dons> translate  the clean program
21:40:50 <dons> clean really diverged from haskell over time, didn't it:
21:40:50 <dons>   :: MaskData :== {!{!{![#Int!]}}}
21:41:32 <tehgeekmeister> allbery_b: even with >>= instead of >> it doesn't work.  there's something subtle i'm missing about nesting a case expression in a lambda in a monad, i'm sure.
21:41:46 <dons> ddarius: would you like to have a go at a non-naive meteor entry?
21:41:57 <dons> earn your #haskell keep :)
21:42:13 <ddarius> Oh noes!  dons has actually pressed the issue.
21:42:30 <dons> its a free hit, basically
21:42:44 <dons> the benchmark most obviously to be improved
21:42:51 <ddarius> dons: I haven't looked at it, but I'm pretty confident that I could get significant improvements.
21:42:57 <dons> i think a relatively naive translation of the clean entry would be rather good
21:43:03 <dons> and go from 22x slower to maybe 2x
21:43:04 <ddarius> 22x suggests something is being done rather wrongly
21:43:07 <dons> right
21:43:39 <allbery_b> hm.  actually, what I don't see is why you need liftM
21:43:48 <dons> it was one of the first meteor solutions, the haskell one, before people worked out how to do it well
21:44:28 <Dunearhp> Can someone tell me if ghc 6.8 is available in ubuntu gutsy gibbon?
21:44:29 <allbery_b> case doesn't need to be lifted, and the alternatives are already in the right monad
21:45:01 <dons> Dunearhp: hmm. i can never keep up with these linux distro version names :)
21:45:04 <ddarius> Dunearhp: Just download the binary.
21:45:42 <ddarius> Dunearhp: Cale, I think it is, constantly speaks of Ubuntu's and GHC's release cycles being almost perfectly out of sync with each other.
21:45:42 <tehgeekmeister> allbery_b: still gets a type error without the liftM, but i just can't make any sense of it.
21:46:00 <tehgeekmeister> i don't know enough about parsec to grok it's types.
21:46:32 <Cale_> heh
21:47:08 <Cale> I don't know about "constantly", but yeah, I've been annoyed by that more than once.
21:47:48 <Dunearhp> Thanks, I was just considering whether it would be easier to install the binary or do a distro upgrade
21:48:29 <jeffz> Dunearhp: I don't think 6.8 is in gutsy.
21:49:26 <Dunearhp> Thanks, I'll get the binary
21:52:12 <hpaste>  tehgeekmeister annotated "typing woes in parseRadix" with "working version of the first approach, if anyone cares to see it." at http://hpaste.org/3923#a2
21:52:39 <allbery_b> you got it too, huh?
21:52:48 <allbery_b> problem was trying to pass x on into parsers that didn't expect it
21:53:04 <tehgeekmeister> yeh, i just had two small bugs
21:53:10 <tehgeekmeister> and i'd corrected each individually
21:53:13 <tehgeekmeister> but not at the same time
21:53:19 <tehgeekmeister> so i never got that version to work before
21:53:37 * wli can't be arsed to finish http://holomorphy.com/~wli/BCD.lhs
21:53:42 <Cale> Dunearhp: You'll also have to install libgmp (if you don't already have it) and libreadline 4. If there's no package for it, then you can use alien to convert the rpm that's at the same place where you get the binary.
21:54:44 <tehgeekmeister> is it bad style to have so many declarations in a where, including nested where clauses?
21:55:25 <dons> Igloo: did the specconstr fix get pushed into the stable branch yet?
21:56:28 <Dunearhp> Cale:  thanks
21:56:55 <ddarius> tehgeekmeister: Glancing, it looks like many of those could be usefully lifted up or abstracted.
21:58:09 <tehgeekmeister> ddarius: i had an idea for a more elegant approach for a base n parser, but it involves more work with enum types than i'm really prepared to do.
21:59:43 <ddarius> Anyway, I need to sleep.
22:05:01 <sclv> ok so if i have an Int and want to get an Int#, what do I do?
22:05:38 <int-e> @src Int
22:05:39 <lambdabot> data Int = I# Int#
22:05:45 <allbery_b> pattern match on (I# x)
22:05:47 <allbery_b> yeh, that
22:08:34 <sclv> thanks
22:08:53 * sclv is playing with seeing if hand-unboxing speeds up the recursive benchmark
22:09:39 <dons> heh, i was doing that. its very carefully tuned though already
22:09:47 <dons> look at the -ddump-simpl output from the current program
22:09:52 <dons> it's already perfect core.
22:09:55 <dons> the problem's the code generator
22:10:05 <dons> -fasm might well help in 6.8
22:10:09 * dons tries this
22:10:28 <daugustine> hey, anyone know where I can find some information on how memory is allocated and deallocated in haskell, ie. what goes to the stack/heap etc.?
22:10:42 <dons> yeah, -fasm seems to help here
22:10:45 <dons> 3.7 v 3.4s
22:11:04 <dons> daugustine: the STG paper, google for "the spineless, tagless G machine"
22:12:06 <dons> maybe we should submit a bug report about recursive being too slow wrt. clean
22:12:20 <sclv> dons: yeah, I see now right in those core rules at the end how everything's already neatly specialized
22:13:57 <dons> yeah, its a good result. the problem is the generated assembly
22:14:25 <dons> i really the the best bang for our buck is improving 'meteor'
22:15:01 <dons> another good trick is to checkout the entire repo, then check the fastest programs against the current haskell versions, for changes to what is acceptable, and new tricks
22:15:09 <dons> there's a little arms race going on in each benchmark
22:15:15 <dons> as people think up new-yet-legal idea
22:15:42 <dons> here's the haskell meteor entry, http://shootout.alioth.debian.org/gp4/benchmark.php?test=meteor&lang=all
22:15:43 <lambdabot> Title: meteor-contest benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer La ..., http://tinyurl.com/38xbh9
22:15:45 <dons> super naive.
22:15:56 <dons> someone can surely translate the C++ or Clean, for big points
22:16:08 <dons> 2 or 3 people in here over a weekend could come up with some good code, surely !
22:17:09 <dons> wow, the C++ entry is huge
22:19:21 <wli> Red Scorpion! ;)
22:29:03 <goalieca> haskell is doing really well in the concurrency domain though
22:29:09 <goalieca> damned fast lightweight threading model
22:29:56 <wli> M:N threads
22:31:20 <dons> yeah, very strong there.
22:36:16 <cognominal_> @src (++)
22:36:16 <lambdabot> (++) []     ys = ys
22:36:16 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
22:40:04 <dons> make sense, cognominal_ ?
22:47:05 <sjanssen> @yow
22:47:05 <lambdabot> If I felt any more SOPHISTICATED I would DIE of EMBARRASSMENT!
22:47:17 <dmwit> ?yarr!
22:47:17 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
22:48:51 <cognominal_> dons yea I am making slides for a haskell presentation
22:49:03 <dons> cool :)
22:49:11 <dons> video taping?
22:49:31 <cognominal_> nope, but I will eventuall post the slides in French
22:49:42 <sjanssen> cognominal_: if you want the really nice definition of (++), xs ++ ys = foldr (:) ys xs
22:50:01 <cognominal_> but in 40 mins I will touch not much
22:51:58 <cognominal_> http://conferences.mongueurs.net/fpw2007/talk/846
22:51:59 <lambdabot> Title: Comprendre haskell pour mieux programmer en d'autres langages
22:52:34 <cognominal_> That's a Perl conference but I am preparing for perl6
22:53:13 <cognominal_> @src foldr
22:53:14 <lambdabot> foldr k z xs = go xs
22:53:14 <lambdabot>     where go []     = z
22:53:14 <lambdabot>           go (y:ys) = y `k` go ys
22:53:32 <salierix> Any word on when ghc 6.8.1 will be added to gentoo?
22:53:33 <Cale> That's the ugly definition of foldr
22:53:39 <Cale> foldr f z [] = z
22:53:55 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
22:54:46 <salierix> Hmm, nice job on the thread-ring benchmark...
22:54:56 <Cale> It's only because GHC doesn't perform a particular optimisation that the one with 'go' exists.
22:55:30 <sjanssen> salierix: yes, great results.  GHC: 679 times faster than Ruby :)
22:55:30 <Cale> I should patch the @src database now that I have access to the darcs repo :)
22:56:05 <Cale> :)
22:59:27 <dons> salierix: yes, its only shorter, uses less memory, and faster, than all competing programs :)
22:59:39 <dons> oh, i take my words back. pascal pips us on heap
22:59:52 <salierix> But only just.
23:00:31 <salierix> I'm still having trouble with how monad transformers work.
23:00:31 <cognominal_> @pf foldr
23:00:32 <lambdabot> Maybe you meant: bf pl
23:00:41 <faxathisia> me too :S
23:01:14 <faxathisia> I never figured out why IOT can't exist
23:01:34 <sjanssen> dons: hmm, I wonder if we can shave off a couple allocations somewhere
23:01:45 <goalieca> does haskell have parallel gc?
23:01:51 <sjanssen> no
23:01:53 <dons> sjanssen: yes, wondering.
23:02:04 <sjanssen> goalieca: GHC HQ is working on it
23:02:19 <Cale> faxathisia: Theoretically, it could, but it would be rather difficult to implement.
23:02:38 <goalieca> sjanssen, ty
23:02:39 <salierix> faxathisia, a lot of monads implement liftIO though so what's the point?
23:03:29 <sjanssen> dons: though it may be silly to fight for 200kb :)
23:04:00 <dons> this was a little too easy. i wonder if there's some better impl. we've not thought about
23:04:18 <dons> "explicity or implicitly linked in a ring"
23:04:24 <dons> do we really need 503 MVars?
23:04:43 <salierix> What's an MVar?
23:04:52 <sjanssen> theoretically, this could be done with a single mvar
23:04:57 <dons> a synchronised mutable variable
23:04:58 <dons> sjanssen: right.
23:04:59 <sjanssen> erm, maybe two
23:05:11 <dons> how to wake them up in turn though
23:05:15 <sjanssen> if you can guarantee the correct sequence of takes
23:05:37 <sjanssen> MVar will wake them up in turn, we have to make them 'take' in the right order
23:05:40 <dons> maybe a bunch of MVars with () in them
23:05:45 <dons> for sequencing
23:05:49 <dons> with a central counter
23:07:23 <sjanssen> remember that we need to avoid anything resembling "cooperative threads… and other programs with custom schedulers"
23:07:37 <dons> mm
23:07:50 <dons> yes, so this is nicer, they all just wait to be woken up
23:07:55 <dons> threads don't signal each other
23:08:21 <sjanssen> but how do you guarantee the order?
23:08:44 <dons> i mean, the current impl is nicer :)
23:09:01 <sjanssen> it is certainly more obvious
23:09:03 <dons> the token being passed is the MVar lock, currently
23:09:28 <sjanssen> this is exactly the code you'd write on the first pass
23:09:33 <dons> yes
23:09:37 <sjanssen> which is nice, because it performs very well :)
23:09:40 <sorear> goalieca: yes, GHC has a parallel GC
23:09:45 <dons> that's so disconcerting
23:09:58 <dons> sorear: hmm?
23:10:08 <sjanssen> sorear: I thought it wasn't finished?
23:10:11 <dons> sorear is ambiguous with language sometimes
23:10:20 <sorear> sjanssen, dons: It's finished and it works.
23:10:28 <dons> there's no parallel GC in any installed branch other than on simonmar's laptop
23:10:33 <sorear> I can cite threads if you don't beleive me.
23:10:47 <sjanssen> sorear: I actually would be interested in reading
23:10:50 <dons> right, so sure, there's dead ghc branches
23:10:55 <dons> with lots of papers about them
23:11:06 <dons> but ghc head and stable don't have parallel GC
23:11:15 <dons> which is surely what goalieca is asking
23:11:36 <goalieca> well.. it is nice to know that it is on the way
23:11:48 <dons> see simonM's mail this week about how the perf wasn't good enough yet. wrt. memory bandwidth being the bottleneck
23:12:00 <goalieca> because non-parallel gc makes a huge hit
23:12:32 <dons> sjanssen: the logic in the thread here is a bit more complex than in Mozart
23:12:37 <dons> maybe that could be simplfied
23:12:42 <dons> i don't like testing the 'm' value twice
23:13:06 <sorear> goalieca: why do you want parallel GC?  surely what you actually want is faster GC... the current parallel GC is slower than the sequential one, even on a multiprocessor
23:13:06 <salierix> Does anyone use Yi?
23:13:14 <sorear> (which is why it hasn't been released)
23:13:21 <sorear> salierix: I don't think so.
23:13:38 <sjanssen> dons: the original code had a single case, but that leads to duplicated code in the alternatives
23:14:05 <goalieca> sorear: well i expect some overhead for sync but doesn't the gc block all other threads while it collects
23:14:19 <salierix> What does $! mean in the code?
23:14:29 <goalieca> @src $!
23:14:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:14:33 <dons> strict apply
23:14:34 <sorear> goalieca: Even the parallel GC blocks all other threads.  It's a parallel GC, not a concurrent GC
23:14:36 <goalieca> well.. strict apply
23:15:09 <sjanssen> dons: actually, it seems we're doing extra work
23:15:59 <sjanssen> dons: we have to pass the value along even when it's less than 0 because the program will only quit when the main thread quits
23:16:33 <sorear> goalieca, sjanssen: http://haskell.org/pipermail/glasgow-haskell-users/2007-November/013482.html & http://haskell.org/pipermail/glasgow-haskell-users/2007-November/013500.html
23:16:33 <lambdabot> http://tinyurl.com/27pq8l
23:18:37 <sjanssen> dons: so we should exit straight away when m == 1, using either an async exception or that exit function in System.Posix
23:19:44 <Taejo> @pl \n -> let (front, back) = splitAt n xs in front ++ (tail back)
23:19:44 <lambdabot> (line 1, column 11):
23:19:44 <lambdabot> unexpected "("
23:19:44 <lambdabot> expecting natural, identifier or "in"
23:19:51 <dons> ah
23:19:55 <Taejo> @pl \n -> let (front, back) = (splitAt n xs) in front ++ (tail back)
23:19:55 <lambdabot> (line 1, column 11):
23:19:55 <lambdabot> unexpected "("
23:19:55 <lambdabot> expecting natural, identifier or "in"
23:20:09 <dons> yes, i tried the async exceptoin
23:20:13 <dons> but then the main thread complains
23:20:42 <goalieca> sorear, hmm.. i wonder what fraction of that is overhead
23:21:15 <sjanssen> even: throwTo (ExitException exitSuccess) fails?
23:21:15 <dons> exitImmediately
23:21:37 <sjanssen> exitImmediately should be in base
23:21:48 <sjanssen> this is the second time in as many weeks that I've needed it
23:22:57 <dons> i'm not seeing noticeable differences  with exitImmediately
23:23:11 <sjanssen> the speed difference will be tiny
23:23:23 <dons> right
23:23:27 <sjanssen> we're saving at most 503 MVar puts
23:23:30 <dons> not many threads to wake up
23:25:36 <dons> i'm not sure there's much we can do here
23:25:49 * dons reads the core for  the thread body a little
23:26:21 <sjanssen> bah, this indentation is annoying
23:28:31 <dons> oh, the 'go' loop?
23:28:43 <sjanssen> and the 2 space indentation in the other functions
23:28:48 <dons> yes.
23:28:56 <sjanssen> I can only handle 4 space intervals
23:29:03 <dons> gzip it to see if it matters :)
23:29:20 <dons> parens zip better than space and $ i noticed
23:30:10 <sjanssen> too bad we can't use Control.Monad.forever yet
23:31:30 <dons> yeah
23:34:59 <dobblego> why not?
23:35:52 <sjanssen> dobblego: the shootout box doesn't have GHC 6.8 yet
23:36:12 <salierix> Control,Monad.forever? Sound interesting, what is it?
23:36:24 <dobblego> ah right
23:36:41 <sjanssen> salierix: forever m = do m; forever m
23:36:46 <sjanssen> basically, repeat the action forever
23:36:55 <sjanssen> like while(true)
23:36:58 <dobblego> is it optimised or something?
23:37:05 <dobblego> ah nice
23:37:15 <salierix> Ah, dons has that in the "roll your own irc bot" code.
23:38:04 <dmwit> It's pretty useful. =)
23:42:24 <dons> sjanssen: yeah, so even with exiting early, and a single test in the loop body, there's hardly a difference. its all in the cost of the MVar
23:43:14 <sjanssen> we might be able to notice on the shootout box
23:43:24 <dons> maybe there's a little difference. i get consistently a little faster
23:43:26 <dons> on big N
23:43:57 <sjanssen> the difference is bounded anyway
23:44:06 <hpaste>  dons pasted "refactor" at http://hpaste.org/3924
23:44:10 <sjanssen> it's N `mod` 503 extra mvar writes
23:44:43 <dons> and however many cycles we remove from the thread body
23:44:44 <sjanssen> I'm surprised that works
23:44:52 <dons> hmm?
23:44:53 <goalieca> stupid question but why 2 mvars in there at all?
23:45:07 <dons> there's 503 , goalieca :)(
23:45:09 <goalieca> err ya
23:45:13 <goalieca> i meant that
23:45:13 <sjanssen> doesn't exitImmediately ExitSuccess have to run in the main thread?
23:45:26 <dons> sjanssen: it calls unix' exit(); so i guess that works anywhere
23:45:39 <sjanssen> oh, exitImmediately, nevermind
23:46:09 <dons> strangely i don't need to link the unix package
23:46:10 <hpaste>  sjanssen annotated "refactor" with "or write to an MVar when we're all done" at http://hpaste.org/3924#a1
23:46:15 <dons> since exit is in the rts, i think
23:46:16 <dons> so ld is ok
23:47:20 <dons> yes, there's nothing wrong with having the main thread just wait and print
23:49:23 <sjanssen> do they strip comments before gzipping?
23:50:18 <dons> not sure.
23:52:01 <dons> we should fix meteor instead :)
23:52:58 <dons> now the current code seems faster. strange
23:53:20 <dons> ah, 6.6.1 v 6.8.1
23:54:47 <sjanssen> losing to Lua?
23:54:57 <sjanssen> proof that we're using the wrong algorithm
23:56:39 <goalieca> hmm. i get ring now
23:57:43 <Korollary> goalieca: 6-2
23:58:00 <goalieca> Korollary, ya. but mtl lost 4-1
23:58:15 <goalieca> and ohlund... what a dumbass
23:58:50 <Korollary> I missed the 1st period. Did he do something?
