00:00:08 <b_jonas> depends on the context
00:00:15 <b_jonas> sometimes do is better, sometimes >>= is
00:00:20 <dmwit> dibblego: I often use >>= over do.
00:00:44 <dmwit> For long pipelines that only use the previous action's result, >>= is ideal.
00:01:05 <oerjan> it parallels the difference between filter/concat/map and using list comprehensions
00:01:28 <dibblego> yeah I guess it does
00:01:28 <dmwit> When I have a result that needs to be used in several later parts of the pipeline, I usually use do.
00:01:33 <b_jonas> yeah, '>>= \' isn't really good
00:01:52 <b_jonas> but if the rhs is in pointfree style, then >>= might be easy
00:02:38 <dmwit> (I also usually use do when I'm only using (>>).  It somehow seems cleaner.)
00:02:49 <oerjan> and if there are lots of .'s =<< may fit better with that
00:04:29 <oerjan> i noted 6.8.1 advertised >=> and <=< operators
00:04:43 <b_jonas> wtf are those?
00:04:52 <dibblego> I once used sequence instead of lots of >>
00:04:53 <dmwit> oerjan: :t ((>=>), (<=<))
00:04:54 <dmwit> ?
00:04:57 <b_jonas> I know =<<
00:05:06 <omnId> dmwit: Kleisli composition
00:05:07 <oerjan> in Control.Monad i think
00:05:21 <omnId> (a -> m b) -> (b -> m c) -> a -> m c
00:05:24 <oerjan> they would also be useful in monadic pipelines
00:05:29 <omnId> (>=>) :: ...
00:05:35 <dmwit> omnId: Hmm, neat.
00:05:50 <omnId> @src Kleisli (>>>)
00:05:50 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:06:04 <omnId> (f >=> g) x = f x >>= g
00:06:42 <oerjan> (x >>= f) >>= g = x >>= (f >=> g)
00:07:42 <oerjan> so >=> allows you to leave out the initial action in a >>= pipeline
00:08:17 <nornagon> :t \x -> f x >>= g
00:08:19 <lambdabot> Not in scope: `f'
00:08:19 <lambdabot> Not in scope: `g'
00:08:26 <nornagon> oher
00:08:52 <oerjan> :t \x -> ?f x >>= ?g
00:08:53 <lambdabot> forall t (m :: * -> *) a b. (?f::t -> m a, ?g::a -> m b, Monad m) => t -> m b
00:09:08 <b_jonas> (liftM Right $ b xr) is the same as (do { t <- b xr; return Right t; }), is it?
00:09:15 <omnId> Kleisli f >>> Kleisli g = Kleisli (\x -> f x >>= g) -- Control.Arrow has a Kleisli newtype.
00:09:57 <oerjan> b_jonas: missing parentheses
00:10:05 <omnId> @type Kleisli putStrLn >>> Kleisli readIO
00:10:06 <oerjan> return (Right t)
00:10:06 <lambdabot>     Couldn't match expected type `()' against inferred type `String'
00:10:06 <lambdabot>       Expected type: Kleisli IO () d
00:10:06 <lambdabot>       Inferred type: Kleisli IO String a
00:10:17 <b_jonas> (do { t <- b xr; return (Right t); }) then
00:10:24 <omnId> @type Kleisli readIO >>> Kleisli putStrLn
00:10:25 <lambdabot> Kleisli IO String ()
00:10:40 <omnId> = String -> IO ()
00:11:26 <levi13> Hi, Can someone help with a Haskell/OpenGL problem?
00:11:36 <levi13> I get an assertion error when running
00:12:27 <omnId> > runKleisli (Kleisli (readIO::String->IO(Maybe Int)) >>> Kleisli print) "Just 1"
00:12:28 <lambdabot>  <IO ()>
00:14:37 <omnId> (readIO >=> print) "Just 1" -- with the new (>=>) that doesn't need the newtypes.
00:15:02 <nornagon> :t ()
00:15:04 <lambdabot> ()
00:15:15 <nornagon> what actually is ()?
00:15:17 <omnId> :k ()
00:15:18 <lambdabot> *
00:15:21 <omnId> data () = ()
00:15:28 <omnId> a datatype with one value
00:15:52 <omnId> usually called "unit" or the empty tuple
00:16:01 <nornagon> i've always thought of it as a 'coin'
00:16:16 <nornagon> from when some monad tutorial i was reading called IO () an 'IO coin'
00:16:26 <omnId> I think that was YAHT :)
00:16:36 <mlh> the closest thing to null / void type that haskell has  - as I understand it
00:17:10 <oerjan> :t readIO
00:17:11 <lambdabot> forall a. (Read a) => String -> IO a
00:17:35 <omnId> it was a simple Kleisli that I could think of off the top of my head :)
00:17:48 <omnId> return is another one.
00:19:05 <omnId> > runKleisli (Kleisli return >>> Kleisli (replicate 5)) 3
00:19:06 <lambdabot>  [3,3,3,3,3]
00:20:24 <omnId> > runKleisli (Kleisli (\x -> [x, x+1]) >>> Kleisli (replicate 5)) 3
00:20:25 <lambdabot>  [3,3,3,3,3,4,4,4,4,4]
00:23:06 <b_jonas> I'm getting a type error
00:23:15 <b_jonas> argh
00:23:26 <Zao> In Haskell, that's unheard of!
00:23:29 <b_jonas> ah, I know why
00:26:39 <b_jonas> ok, corrected it
00:48:42 <ketil> Good morning!
00:49:18 <b_jonas> I like type errors because they find lots of errors in compile time
00:49:25 <ketil> I'm extracting some stuff from a file using lazy bytestrings.  Memory consumption is too high, and I suspect my program is retaining too much of the file.
00:49:57 <ketil> Will pack . unpack work as a way to "break"  the chunks, retaining only the substrings I need?
00:50:12 <sjanssen> ketil: yes
00:50:16 <ketil> (I could just test it, but a test run takes ~3 hours :-)
00:50:17 <dancor> i want to have a large lexicon of words stored in a trie structure, and i want that structure to 'load' as quickly as possible when my program starts up.  thoughts?  is there anything like python pickling in haskell
00:50:25 <ketil> sjanssen, OK, thanks, will try it then.
00:50:41 <ketil> sjanssen, do you by chance remember the default chunk size?
00:50:47 <sjanssen> 256KB
00:50:59 <ketil> OK.
00:51:02 <b_jonas> It's a nice change to me because when I write ruby programs, the interpreter doesn't detect even obvious syntax errors (mistyped variable names) till compile time.
00:51:24 <b_jonas> Thus, rarer branches often have errors like that for months.
00:51:25 <sjanssen> dancor: Read/Show is easy but slow
00:51:45 <sjanssen> dancor: Data.Binary is less automatic but outrageously fast
00:53:44 <sjanssen> ketil: are you only holding on to small strings from your input?
00:55:25 <ketil> sjanssen, that remains to be seen :-)
00:55:30 <ketil> but yes, I suspect I am.
00:55:31 <Cale> b_jonas: Yeah, I find it really annoying when writing a program in a dynamically typed language, and having something which is an obvious type error end up crashing my program in a non-obvious way. Especially for instance the case where something which should be a type error ends up getting stuck into a long-lived data structure, and only causes problems when it's extracted much later, and I have to go searching for t
00:55:31 <Cale> he thing which built that part of the structure.
00:56:00 <b_jonas> ruby is worse than that
00:56:16 <b_jonas> it doesn't even do that with type errors
00:56:31 <sjanssen> ketil: [Char] actually has less memory overhead than lazy ByteStrings for strings in the 0-20 character range
00:56:33 <b_jonas> but syntax errors like 'els' instead of 'else' and things like that
00:56:48 <ketil> One thing that made an impression from a python project was the need to write tons of unit tests that checked for correctly typed arguments.
00:56:49 <Cale> heh, that's crazy :)
00:57:09 <b_jonas> perl is better in that kind of thing, luckily
00:57:11 <sjanssen> ketil: so it may be to your advantage to skip the second 'pack'
00:57:16 <ketil> sjanssen, hmm...so perhaps I should just use 'unpack'?
00:57:19 <ketil> right.
00:57:29 <ketil> didn't think of that.
00:57:51 <sjanssen> or even use Strict.pack . Lazy.unpack
00:57:57 <ketil> I need to check it, but I think I only keep fixed length words, so I could also use UArray Int Word8.
00:58:16 <ketil> Or (# Word8, Word8,...Word8 #) :-)
00:58:34 <ketil> I guess the UArray is equiv to Strict.pack...
00:58:38 <sjanssen> UArray Int Word8 has about the same size overhead as ByteString (maybe more)
00:59:29 <ketil> Shouldn't we have a bytestring-like library replacing the UArrays, really?
00:59:30 <sjanssen> a single chunk lazy ByteString has something like 6 words more than a strict ByteString
01:03:52 <sjanssen> actually, only 1 word more in the new version packaged with GHC 6.8.1
01:07:42 <paczesiowa> I want to write a parser, my basic parsers are var, struct, term etc, but they need to depend on parser expr (which can vary) so I was thinking of keeping this expr parser inside state of other parsers, getting it out and applying, but it results in infinite type, what should I do with this infinite type?
01:10:49 <oerjan> paczesiowa: an infinite type usually means you need to declare a newtype or data to "break the loop"
01:11:33 <oerjan> since those can be recursive
01:15:06 <paczesiowa> now I wonder if it is even possible:/ if factor depends on a expression (factor can be expression in parens) and expression is build from factors then there is a loop:/
01:15:35 <quicksilver> that's no problem at all
01:15:48 <quicksilver> recursive data structures are the basis of most interesting haskell programms
01:15:55 <quicksilver> list is recursive after all :)
01:17:26 <oerjan> say, newtype ParserState = PS { exprParser :: CharParser ParserState Expr, {- other state -} }
01:17:57 <paczesiowa> so what's the difference between, "static" factors and expressions (defined at source code) and "dynamic" where factor must take expression parser as an argument and pass that expr parser to expr itself (<- this sounds to hard for me)
01:18:23 <b_jonas> can you help me in syntax
01:18:23 <quicksilver> it's quite unusual to need such complex state tricks in a parser
01:18:35 <b_jonas> I'd like to declare the type of 'loop'
01:18:38 <quicksilver> I've always made my parsers stateless
01:18:41 <b_jonas> loop :: (a -> m (LoopCtl a b)) -> a -> m b;
01:18:45 <b_jonas> except that m has to be a Monad
01:18:57 <quicksilver> Monad m => (a -> m (LoopCtl a b)) -> a -> m b
01:19:52 <paczesiowa> quicksilver: I'm writing prolog parser, I don't know expression parser because I don't know the operators, (they can change after parsing and executing some source code, then parser has to adapt to new operators)
01:20:38 * quicksilver nods
01:20:39 <quicksilver> hmm
01:20:46 <oerjan> paczesiowa: probably better to keep an operator table than a function
01:20:47 <quicksilver> then, yes, I see your point
01:20:47 <b_jonas> prolog parser, wow
01:21:04 <quicksilver> unless operators fall into some simple syntactic class
01:21:16 <b_jonas> I once wrote a program that output prolog code
01:21:29 <b_jonas> but then I didn't even try to mess with operator precedences
01:21:40 <b_jonas> just parenthisized excessively
01:22:10 <paczesiowa> oerjan: I tried keeping operator table inside state, pulling it out and constructing parser but the error was the same
01:22:32 <oerjan> that's strange
01:22:47 <paczesiowa> operators aren't problem, problem is op/3 which alters operator attributes
01:22:51 * wli thinks compilers and interpreters should be written in the precise opposite order from how they typically are.
01:24:28 <exDM69> I am writing a card game. I have data Card and a function fromIndex :: Integer -> Card. I get the whole deck by doing map fromIndex [0..51]
01:24:37 <therp> wli: in what "order" are they written now?
01:24:50 <wli> therp: Front end to back end.
01:24:53 <b_jonas> wli: same question as therp
01:25:01 <exDM69> how can I make a constructor Deck = map fromIndex [0..51]
01:25:34 <therp> wli: you'd rather prefer back end to front end?
01:25:36 <oerjan> paczesiowa: if your table just contained symbols and precedences/associativity, then i don't see how there could be a recursive type in that...
01:25:39 <wli> therp: yes
01:26:24 <b_jonas> the problem with prolog operators is that the compiler gives statements back to the compiler
01:26:41 <b_jonas> (like in TeX or perl etc)
01:26:53 <b_jonas> the compiler gives directions to the parser I mean
01:27:01 <oerjan> exDM69: what would such a constructor do?
01:28:00 <exDM69> oerjan: it would be a list of all cards in a deck
01:28:08 <paczesiowa> oerjan: newtype ParserState = PS (GenParser Char ParserState Expr), still an infinite type
01:28:23 <oerjan> exDM69: you don't want a constructor then, but a function.
01:28:44 <paczesiowa> > let deck = map fromIndex [0..51] in deck
01:28:45 <lambdabot>   Not in scope: `fromIndex'
01:28:52 <bvdijk> exDM69: You can also represent cards as follows: type Card = (Rank, Suit); data Suit = S | H | D | C; data Rank = R2 | R3 | ... | R10 | RJ | RQ | RK | RA;
01:29:07 <bvdijk> exDM69: And then deck = [(r, s) | s <- suits, r <- ranks]
01:29:11 <exDM69> bvdijk: yes, that's what I did
01:29:12 <oerjan> paczesiowa: impossible, that should be legal
01:29:24 <bvdijk> suits = [S .. ]; ranks = [R2 .. ]
01:29:32 <exDM69> oerjan: the function has no parameters
01:29:53 <bvdijk> (make sure to add deriving Enum to Rank and Suit)
01:29:56 <exDM69> so it's not really a function (is it)?
01:30:04 <oerjan> exDM69: in haskell we sometimes call them functions anyhow
01:30:09 <paczesiowa> it's a function of 0 arguments
01:30:14 <exDM69> so how would I write it?
01:30:34 <paczesiowa> the same as every other function, but without arguments
01:30:48 <paczesiowa> deck = map fromIndex [..
01:31:54 <paczesiowa> oerjan: apparently it's not legal
01:32:06 <oerjan> paczesiowa: could you paste?
01:32:13 <paczesiowa> ok, wait
01:33:09 <wli> deriving (Eq, Ord, Read, Show, Bounded, Enum)
01:33:14 <balodja> sum n m s = if n == m then s else sum (n+1) m (s+n) -- is that tail recursive?
01:33:48 <quicksilver> balodja: yes
01:34:15 <oerjan> balodja: you build a thunk in the third parameter, so not quite as much as you want perhaps
01:35:07 <oerjan> you may wish to make it strict in s
01:35:10 <balodja> I'm interested in how if/then/else influence on tail recursion
01:35:23 <oerjan> if then else is fine
01:35:25 <pierre-> balodja: no influence
01:35:55 <b_jonas> I'll have to ask the admin in the university to install ghc
01:36:00 <oerjan> but because of thunk building, tail recursion is not the whole story in haskell
01:36:20 <quicksilver> or even the right story to think about :)
01:37:07 <quicksilver> non-trivial 'do' expressions can't be tail recursive, by definition
01:37:13 <quicksilver> but it doesn't matter, they work fine anyway :P
01:37:44 <hpaste>  Paczesiowa pasted "Parser with another parser inside it's state" at http://hpaste.org/3666
01:38:38 <quicksilver> paczesiowa: paste the exact error message?
01:38:55 <dikini> in http://hpaste.org/3665 I have a subtle problem - how do I avoid the total order of Ord, while reusing most of its operations
01:39:08 <dikini> do I need to dfine my own class?
01:39:48 <dikini> best would be to avoid Eq as well, since in maths it is not required for the method
01:40:21 <oerjan> dikini: you could just decide on some arbitrary order between BeeVals and BeeRanks?
01:40:38 <dikini> yes
01:40:46 <dikini> it is problem dependent
01:40:57 <quicksilver> the best model of the situation you really have is to make beeval and beerank seperate types
01:41:08 <paczesiowa> hmm, cleaning up code to paste it, fixed my error, looks like I need some sleep
01:41:12 <quicksilver> and define Ord on beeval and beerank but not on beet itself
01:41:28 <oerjan> paczesiowa: heh :)
01:42:33 <dikini> hmm, makes sense, then pull them into beet,
01:43:05 <dikini> thanks
01:43:30 <quicksilver> I would argue, by the way, than in maths Eq *is* required by Ord
01:43:36 <quicksilver> or, at least, it's implied by ord
01:43:46 <dikini> well it is not
01:44:05 <dikini> but in haskell, as far as I understand it is
01:44:05 <paczesiowa> but still, if I try to assign expr inside term parser to state value, there is infinite type, and I have no idea how to make term look like smth that ParserState
01:44:11 <Korollary> < doesn't require Eq
01:44:23 <quicksilver> dikini: don't contradict me without giving your reasons
01:44:36 <quicksilver> total orders are normally defined in the language of set theory with equality
01:44:39 <quicksilver> so Eq is a given
01:44:39 <dikini> partially ordered sets?
01:45:38 <dikini> where <= & => don't imply equality
01:45:46 <Korollary> right
01:45:48 <dcoutts> sjanssen: actually a single chunk lazy ByteString has 1 word more than a strict ByteString
01:45:54 <quicksilver> we're not talking about partially ordered sets
01:45:59 <quicksilver> we're toalking about Ord
01:46:02 <quicksilver> which is total ordering...
01:46:08 <dikini> quicksilver: ok
01:46:28 <quicksilver> you can define equality in total orderings as not (a < b) && not (b > a), for example.
01:46:37 <dikini> yes
01:46:45 <quicksilver> although it's more normal in my experience to take = as given
01:46:47 <quicksilver> and work up
01:46:48 <dcoutts> sjanssen: data ByteString = Empty | Chunk !Strict.ByteString ByteString
01:47:20 <dikini> how do I express partial order using the prelude defined classes?
01:47:48 <quicksilver> you can't
01:47:50 <quicksilver> :)
01:47:52 <quicksilver> define your own
01:47:54 <dikini> :)
01:48:15 <dikini> yeah, I though you would say that
01:48:16 <b_jonas> I like the idea of  Write Yourself a Scheme in 48 Hours ("http://halogen.note.amherst.edu/%7Ejdtang/scheme_in_48/tutorial/overview.html")
01:48:16 <lambdabot> http://halogen.note.amherst.edu/%7Ejdtang/scheme_in_48/tutorial/overview.html"
01:48:24 <roconnor> @type comapre
01:48:26 <lambdabot> Not in scope: `comapre'
01:48:28 <b_jonas> because I like writing interpreters and I already wrote a scheme interpreter once
01:48:28 <roconnor> @type compare
01:48:29 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
01:48:39 <roconnor> @info Ordering
01:48:40 <lambdabot> Ordering
01:48:47 <roconnor> what does info do?
01:48:47 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
01:48:52 <roconnor> @help info
01:48:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:48:56 <yitz> dikini: I usually find partial orderings expressed in structure of data, rather than a relation between constructors
01:49:01 <oerjan> roconnor: it spell corrects to undo
01:49:08 <Korollary> lol
01:49:11 <roconnor> :/
01:49:42 <dikini> yitz: have any examples I can look at?
01:50:49 <yitz> mmm, not sure what you're trying to do.
01:51:09 <b_jonas> I guess I should try to write an interpreter in scheme as well
01:51:14 <b_jonas> in haskell I mean
01:51:19 <dikini> xpress a set with partial order
01:51:33 * dikini should start spelling right
01:52:03 * yitz gaev upp a longg tiem ego
01:52:15 <dikini> ok
01:52:36 <Kolji[Z]> IRC chan dedicated to Haskell :) - that's what saves me :)(
01:52:38 <Kolji[Z]> :D
01:53:42 <Kolji[Z]> I need help. How would you define a function which swaps two elements of a list on a position M and N ? :)
01:53:56 <yitz> well, a partial ordering is often really just a tree. so you build the tree lazily, and traverse to find what you need. That sort of thing.
01:54:17 <sjanssen> dcoutts: only in the new representation, yeah?
01:54:20 <smtms> Kolji[Z], are you a student?
01:54:26 <Kolji[Z]> smtms: yes :)
01:54:30 <roconnor> Kolji[Z]: that is an unusual thing to do with lists, but it can be done.
01:54:48 <oerjan> Kolji[Z]: the splitAt function is nice for such things
01:54:57 <Kolji[Z]> functional programming is a subject I only have in my first semester and would like to leave it behind :)
01:55:03 <Kolji[Z]> splitAt? Will try :)
01:55:05 <oerjan> > splitAt 3 "acbdefgh"
01:55:07 <lambdabot>  ("acb","defgh")
01:55:08 <MarcWeber> dcoutts: Which is the status of the haskell package build environment? I'd like continuing the work and packaging all the hackage package for nix. So we'll get buildfarms for windows/unix for free (including dependencies such as X11 or gtk/wx etc). Thanks for the nice summary on the cabal list.
01:55:12 <dcoutts> sjanssen: yes, otherwise yes, it's the overhead of the list node
01:55:17 <Zao> Kolji[Z]: Too bad. Functional programming is great.
01:55:46 <Kolji[Z]> Zao: yes
01:56:08 * roconnor has to give a lecture on the awesomeness of Haskell in Amsterdam in December.
01:56:12 <dikini> yitz: the problem is that I don't know the structures involved, at least before hand, I do know that they have partial order defined
01:56:34 <dcoutts> MarcWeber: I'm not sure what you mean exactly about the build environment
01:56:47 <dikini> must have, otherwise no way to work with them
01:56:51 <dikini> never mind
01:56:57 <dcoutts> MarcWeber: I'd like you to continue the work on Cabal -> nix packaging too :-)
01:57:04 <b_jonas> Can you explain me how loop functions like map or foldl' can be brought up to monads?
01:57:13 <dcoutts> MarcWeber: I've pointed you at hackport before haven't I ?
01:57:31 <dikini> I'll go with rolling my own , i suppose
01:57:51 <quicksilver> @src map
01:57:51 <lambdabot> map _ []     = []
01:57:51 <lambdabot> map f (x:xs) = f x : map f xs
01:57:55 <b_jonas> Like, how can I have a variant of map that traverses a list strictly from left to right, is in a monad, and the transformer function you pass to it is a monad function
01:57:55 <dcoutts> MarcWeber: hackport the gentoo tool for generating packages from hackage, there's a lot of code there you could steal.
01:58:14 <oerjan> :t mapM
01:58:15 <dcoutts> b_jonas: mapM ?
01:58:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:58:37 <quicksilver> b_jonas: to make that monadic, you change (f x : map f xs) into do { ff <- f x ; fs <- map f x; return (ff : fs) }
01:58:51 <quicksilver> b_jonas: (w.r.t the source of map wich I just asked lambdabot for)
01:59:04 <quicksilver> b_jonas: and yes, that is mapM. But I was explaining how it works :)
01:59:16 <b_jonas> I see
02:00:13 <b_jonas> so Control.Monad has things like this
02:00:37 <yitz> dikini: sure, if you don't know anything more than that, then go with it.
02:00:42 <Kolji[Z]> what's a function of connecting index's? Concat?
02:00:43 <oerjan> yep
02:00:52 <Kolji[Z]> nice :)
02:01:05 <oerjan> Kolji[Z]: er, i wasn't answering you but that's one
02:01:07 <b_jonas> does it have some more conventional loops like monadic while loops as well?
02:01:14 <Kolji[Z]> :D
02:01:21 <b_jonas> I think I'll need both while loops and map/fold loops
02:01:24 <oerjan> if you mean adding together lists
02:01:30 <oerjan> also the ++ operator
02:01:39 <b_jonas> and I might have to write my own as well
02:01:47 <therp> kolji: you might want to look at Hoogle (just google that)
02:01:54 <b_jonas> (even in haskell, there's no library function for everything)
02:02:09 <oerjan> :t foldM
02:02:10 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
02:02:33 <oerjan> the while loop you might have to do yourself though
02:02:47 <b_jonas> I guess I'll need an array loop
02:02:52 <b_jonas> because I want to work with arrays
02:02:59 <b_jonas> IArrays or UArrays that is
02:03:10 <b_jonas> but I can write those the same way
02:03:14 <MarcWeber> dcoutts: I'll have a look at hackport right now
02:03:22 <oerjan> @docs Data.Foldable
02:03:23 <lambdabot> Data.Foldable not available
02:03:23 <b_jonas> or combine mapM/foldM with indices
02:03:24 <dcoutts> @where hackport
02:03:24 <lambdabot> http://haskell.org/~gentoo/hackport/
02:03:33 <oerjan> argh
02:03:41 <b_jonas> ah, foldable and functor
02:03:45 <b_jonas> good ideas
02:04:03 <b_jonas> the haskell class system rocks
02:04:04 <oerjan> and Data.Traversable
02:04:23 * SimeonK slaps pesatan around a bit with a large trout
02:04:48 <b_jonas> Functor is what can be map-ped, and Foldable is what can be folded, right?
02:05:35 <oerjan> yes, and Traversable can be mapped with something monadic
02:05:52 <oerjan> or even applicative iirc
02:07:10 <b_jonas> 'Traversable' doesn't seem to have enough instances according to the docs
02:07:17 <oerjan> oh, sequenceA is in Traversable
02:07:20 <wli> Zippable might be nice.
02:07:30 <SimeonK> what's the difference between splitAt and swap ?
02:07:33 <SimeonK> it does the same
02:07:39 <oerjan> i was missing it from Control.Applicative (for lists)
02:07:41 <wli> swap (x, y) = (y, x) IIRC
02:07:51 <wli> splitAt is another beast entirely.
02:08:05 <SimeonK> swap 4 [1,5,4,7,8,9,94]
02:08:05 <SimeonK> ([1,5,4,7],[8,9,94])
02:08:16 <SimeonK> ^ that's what swap did
02:08:23 <SimeonK> exactly the same as splitAt
02:08:25 <SimeonK> weird
02:08:26 <oerjan> SimeonK: must be a different name for it
02:08:37 <wli> Not a definition of swap with which I'm familiar.
02:08:40 <b_jonas> or some generalization
02:08:41 <oerjan> in the library, it's called splitAt
02:08:49 <b_jonas> @t (swap, splitAt)
02:08:49 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:08:57 <quicksilver> Foldable can be folded, and hence mapM_'ed
02:08:57 <b_jonas> :t (swap, splitAt)
02:08:59 <lambdabot> Not in scope: `swap'
02:09:01 <quicksilver> Functor can only be mapped
02:09:09 <quicksilver> Traversable can be mapM'ed and sequence'ed
02:09:26 <b_jonas> um
02:09:40 <quicksilver> funnily enough I'm writing up a wiki article on these at the moment
02:09:42 <b_jonas> why does can be folded imply mapping?
02:09:49 <quicksilver> not mapping
02:09:52 <quicksilver> mapM_'ing
02:09:54 <quicksilver> different :)
02:10:05 <quicksilver> mapM_ doesn't collect results, so it is essentially a fold
02:10:09 <b_jonas> oh
02:10:41 <ivanm> roconnor: ping!
02:10:58 <quicksilver> mapM_ is like folding with (>>)
02:11:06 <pjd> @type let mapA _ [] = Control.Applicative.pure []; mapA f (x:xs) = (:) <$> f x <*> mapA f xs in mapA
02:11:07 <lambdabot> forall t (f :: * -> *) a. (Applicative f) => (t -> f a) -> [t] -> f [a]
02:11:20 <pjd> who needs monads :)
02:11:35 <b_jonas> I'm not sure I understand Foldable exactly
02:11:36 <quicksilver> pjd: that's "traverse"
02:11:40 <b_jonas> it seems to have lots of methods
02:11:44 <quicksilver> pjd: specialised to list
02:11:59 <b_jonas> and too few instances
02:12:03 <pjd> quicksilver: oh, ok
02:12:10 <b_jonas> the doc says only [] and Maybe are foldable
02:12:22 <quicksilver> b_jonas: the other instances are defined with the types
02:12:33 <quicksilver> b_jonas: the types that actually define them
02:12:34 <yitz> quicksilver: mapM_ isn't like folding with >>. It _is_ folding with >>.
02:12:44 <b_jonas> but the docs usually contain all instances, even if defined elsewhere
02:12:46 <oerjan> quicksilver: suddenly the functions i was missing from Control.Applicative turn up elsewhere... :)
02:12:49 <quicksilver> yitz: well, it's "fmapping" followed by folding with >>
02:12:55 <quicksilver> oerjan: :)
02:12:58 <b_jonas> the docs meaning http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Foldable.html
02:13:00 <lambdabot> http://tinyurl.com/2onctf
02:13:02 <quicksilver> oerjan: Traversable and Applicative are dual
02:13:11 <mux> I need to build GHC 6.8.1
02:13:15 <quicksilver> oerjan: Applicative is "the most general thing which can be sequenced"
02:13:24 <quicksilver> oerjan: while Traversable is "the most general thing you can sequence over"
02:13:55 <b_jonas> sometimes I feel that haskell operates with too general properties
02:14:04 <yitz> quicksilver: ok, right. sequence_ then.
02:14:12 <ivanm> is Data.Foldable new in 6.8.1 ?
02:14:13 <b_jonas> but then I can ignore anything that's too general of course
02:14:45 <oerjan> ivanm: no
02:14:50 <yitz> b_jonas: that is the classic problem with category theory :)
02:15:01 <ivanm> OK, just don't recall seeing it before
02:15:45 <b_jonas> the docs are wierd
02:15:51 <b_jonas> so which module defines Array ?
02:15:51 <oerjan> quicksilver: what is the dual of Foldable then?
02:16:05 <b_jonas> is it Data.Array or Data.Array.IArray ?
02:16:05 <quicksilver> oerjan: Monoid, I suppose. It's not quite the same sense of dual though.
02:16:43 <quicksilver> oerjan: yeah. Monoid is to Applicative as Foldable is to Traversable
02:16:53 <quicksilver> oerjan: you fold monoids, you traverse applicatives
02:17:11 <oerjan> right.  anything for Monads?
02:17:13 <ivanm> b_jonas: Array, but IArray has extra functions for immutable arrays IIRC
02:17:35 <b_jonas> yitz: when I was a first or second year, it was very strange to me why older maths students talked about even the most obvious and simple things with algebric terminology
02:17:37 <quicksilver> oerjan: well Monads are all Applicative, so you can traverse them
02:17:52 <b_jonas> they talked about permutation groups when they just swapped a few objects around
02:17:54 <b_jonas> and the like
02:18:03 <quicksilver> oerjan: I'm not aware of anything which represents the stuff you can do with Monads but not Applicatives
02:18:12 <b_jonas> nowdays I find that less strange, but of course there are still things that I find too abstract
02:18:14 <quicksilver> oerjan: it would, essentially, be a kind of traverse + a DAG
02:18:23 <quicksilver> oerjan: where the DAG indicates how you route results
02:18:25 <taruti> Does GHC 6.8.1 support creating shared libraries on x86-linux?
02:18:34 <oerjan> perhaps "comprehending"?
02:18:36 <yitz> b_jonas: until you realized that algebraic terminology is universal in some category
02:18:52 <quicksilver> oerjan: (the difference between an Applicative and a general Monad is that with a general Monad you can wire the results around to other actions)
02:18:58 <b_jonas> it would also help if we had some classes about abstract thingies like abstract algebra or topology
02:19:02 <quicksilver> oerjan: of course, thats what do notation is
02:19:08 <quicksilver> oerjan: do notation is wiring diargams
02:19:33 <wli> b_jonas: The numeric hierarchy is in dire need.
02:19:45 <yitz> b_jonas: yes. I actually started from there, and move to computer stuff later.
02:19:47 <b_jonas> wli: huh?
02:20:10 <wli> b_jonas: Of abstract algebra.
02:20:24 <b_jonas> well
02:20:40 <b_jonas> the problem with abstract algebra and topology is that we use it in classes, but never actually learn it
02:20:52 <yitz> wli: you mean to make it more granular?
02:20:59 <b_jonas> we prove some theorems over and over but no-one thinks he should teach the general ones I mean
02:21:12 <wli> yitz: Yes but also less screwed up.
02:21:49 <b_jonas> Of course that's because I'm in BUTE, not the other university ELTE.
02:22:09 <yitz> BUTE? ELTE?
02:22:22 <b_jonas> BUTE is www.bme.hu, the technical university
02:22:59 <b_jonas> they're running a faculty that's variably called mathematician and applied maths
02:23:04 <b_jonas> it's a new one
02:23:18 <b_jonas> (I call it experimental mathematician)
02:23:40 <b_jonas> it's more practice oriented and less abstract than the real mathematician education
02:23:47 <b_jonas> which is in ELTE (www.elte.hu)
02:24:02 <quicksilver> oerjan: A nice think about Traversable + Foldable is it gives the most general type for zipWith
02:24:11 <b_jonas> the Eötvös univeristy, which has been teaching maths for ages (that's where all the famous mathematicians come from)
02:24:15 <SimeonK> brb
02:24:26 <quicksilver> oerjan: zipWith (Traversable t,Foldable f) => (a -> b -> c) -> t a -> f b -> t c
02:24:52 <yitz> Budapesti vs. Eotvos Lorand?
02:25:01 <b_jonas> no
02:25:13 <SimeonK> yitz: Hungarian?
02:25:14 <b_jonas> BUTE = Budapest Univ of Technology and Economics
02:25:34 <oerjan> oh
02:25:36 <b_jonas> while ELTE = Eötvös Lóránd Tudományegyetem = Eötvös Lóránd Univ of Sciences
02:25:45 <yitz> got it.
02:25:46 <b_jonas> of which I don't know the english abbrev (it might not even have one)
02:25:59 <b_jonas> BUTE is called BME in hungarian, of which M means technical
02:26:08 <yitz> SimeonK: no, unfortunately.
02:26:16 <SimeonK> why unfortunately? :)
02:26:25 <SimeonK> I guess b_jonas is Hungarian
02:26:29 <yitz> unfortunately that I don't speak it.
02:26:38 <b_jonas> So where's Array documented apart from that it's a member of IArray
02:26:42 <b_jonas> s/member/instance/
02:26:49 <SimeonK> nemtudom hungarian
02:26:57 <b_jonas> I'd like to know which other classes Array and UArray are instances of
02:27:16 <b_jonas> to find which *able I need exactly
02:27:30 <yitz> My grandfather went to college in Hungary (not sure where though). My sister-in-law's first language is Hungarian, because her parents are from Hungary.
02:29:07 <b_jonas> or are there classes of whch all IArray are instance of?
02:29:31 <oerjan> b_jonas: it may not be obvious which _order_ to traverse an array in, for a general Ix instance
02:29:57 <b_jonas> oerjan: hmm
02:30:11 <b_jonas> that's why I'd like to know the exact isntances
02:30:18 <b_jonas> should I perhaps get the sources and read them?
02:30:27 <b_jonas> the library sources that is
02:31:07 * wli wonders if he should write things up for the Monad Reader sometime.
02:31:21 <quicksilver> oerjan: Ix instances do dictate an order
02:31:27 <quicksilver> oerjan: and indeed, arrays are instances of traversable
02:32:25 <oerjan> aha
02:33:13 <oerjan> yeah you could use the range function
02:33:56 <swiert> wli: Yes! Please do.
02:34:21 <swiert> I'm putting together the next issue at the moment - the next deadline will probably be in January.
02:34:32 <david_> Hi all! do you know if (and how) I can export a haskell function (foreign export ccall) that return a list of tuple?
02:34:53 <wli> swiert: That sounds about right for me.
02:35:12 <oerjan> although there is no efficient way to go backwards, from index in the order to array index
02:36:02 <quicksilver> oerjan: yes there is, range and index between let you go both ways
02:36:29 <swiert> wli: I hope to release the next issue fairly soon. Expect a call for papers in a few weeks.
02:36:45 <b_jonas> oh, so Array is defined in prelude?
02:36:57 <wli> swiert: Sounds good.
02:37:09 <ivanm> @hoogle Array
02:37:10 <lambdabot> Array :: module
02:37:10 <lambdabot> Data.Array :: module
02:37:10 <lambdabot> Foreign.Marshal.Array :: module
02:37:13 <oerjan> quicksilver: i mean, without traversing the whole range list :)
02:37:20 <b_jonas> on it isn't
02:37:46 <b_jonas> but the docs don't link to its definition anywhere
02:37:53 <b_jonas> I hate this
02:38:27 <Cale> david_: How do you expect to be able to manipulate that list of tuples on the C side?
02:38:32 <roconnor> ivanm: pong
02:38:39 <oerjan> @index Array
02:38:39 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
02:38:43 <sjanssen> david_: I think you need to export a StablePtr of lists of tuples
02:39:12 <Cale> david_: You can marshal things to C datatypes, but it's a bit more involved.
02:39:21 <sjanssen> eg. foreign export ccall "foo" foo :: Int -> StablePtr [(Int, Int)]
02:39:32 <Cale> Oh, yes, you can do that.
02:39:32 <ivanm> roconnor: OK, that makes sense for the naming of CReal
02:39:57 <david_> some where in the doc they said that with c99 ghc are able to manage in some way tuple
02:39:59 <roconnor> :)
02:40:11 <ivanm> btw, my the topic of my project (which is due in a week, btw) is now finalised to be providing a common "interface" to exact real arithmetic implementations using only functions and folds, etc.
02:40:11 <david_> this is my function: calculateAPDF :: Float -> [(Float, Float)]
02:40:19 <ivanm> because the prof I'm doing it with likes folds
02:40:31 <david_> I try with StablePtr
02:40:38 <roconnor> ivanm: interface?
02:40:54 <sjanssen> david_: [(Float, Float)] is basically opaque to a C program?
02:41:05 <sjanssen> s/?/.
02:41:55 <sjanssen> david_: perhaps you want to marshal the list into a (Ptr Float) and pass that to C?
02:42:00 <david_> sjanssen: but if I write: foreign export ccall "calculate_apdf" calculateAPDF :: Float -> [(Float, Float)]
02:42:05 <david_> I have: "Unacceptable result type in foreign declaration: [(Float, Float)]"
02:42:34 <sjanssen> david_: right, because [(Float, Float)] doesn't make any sense in a C program
02:42:54 <ivanm> roconnor: can't think of a decent name... but I'm trying to distill the common elements of various implementations into one meta-implementation kind of thing, basing it on boehm's papers
02:43:10 <ivanm> which, as it happens, my prof had only ever read one of until today but referenced all of them :s
02:43:12 <david_> I don't need a particular data structure in C. so... the best way could be marshal it in an array of struct
02:43:27 <david_> but I think it' very difficult
02:43:36 <ivanm> since he could never find the other one
02:43:39 <sjanssen> david_: okay, you've got to do that on the Haskell side.  It's pretty easy
02:43:45 <david_> so... what do you think is the best way?
02:45:12 <david_> sjanssem: tnx! :). what's your way? How should I modify my haskell function?
02:45:19 <roconnor> ivanm: interesting
02:45:37 <fasta> Suppose I have the types FooState and BarState that both need a counter, how can I implement the counter once with as little boilerplate as possible? One could make a type class Countable, but that still requires one to explicitly state that for every type (that's about as much work as defining data FooState = FooState {counter::Int};inc = modify(\s-> s{counter = counter s + 1})).
02:46:11 <roconnor> CounterStateT?
02:46:15 <sjanssen> david_: you can leave the Haskell function alone, just write a wrapper function that dumps the data into a Ptr
02:46:31 <sjanssen> david_: check out the functions in Foreign.Marshal.Array
02:46:46 <fasta> roconnor: is that compiled away completely?
02:47:04 <david_> sjanssem: Ok. I just check! tnx!
02:47:06 <b_jonas> I wondering how I could write a J interpreter in haskell
02:47:26 <ivanm> roconnor: well, the prof has been using exact real arithmetic as a "proof" for his version of fp all this time, so he figured he'd get me to back him up by proving it :p
02:47:28 <b_jonas> apart from what I mentioned above and the parser, the most difficult part of that is how to represend J values
02:47:30 <therp> J? Java?
02:47:40 <b_jonas> no, J = www.jsoftware.com
02:48:01 <b_jonas> it's an apl-like thingy but with more higher order functions
02:48:24 <b_jonas> but the question of how to represent the J values well is not haskell-specific
02:48:38 <b_jonas> because I've no idea how to do it efficently in _any_ language
02:48:50 <b_jonas> I also can't imagine how their interpreter can work
02:49:11 <therp> the scheme cross-compiler was rather easy for me.
02:49:34 <b_jonas> scheme cross-compiler means scheme to haskell compiler?
02:49:41 <sjanssen> fasta: class Count a where inc :: a -> a; instance Count FooState where inc (FooS x) = FooS $ x + 1; instance Count BarState where inc (BarS x) = BarS $ x + 1; increment = modify inc
02:49:58 <sjanssen> fasta: doesn't seem like much boilerplate at all
02:50:04 <therp> usually you create a data type representing values of that language. data JValue = JInt Integer | JOtherPrimitive <object to represent that primitive in haskell> | ..
02:50:08 <therp> bjonas: yes
02:50:24 <fasta> sjanssen: I think roconnor's solution is better.
02:50:43 <therp> bjonas: although it was cross-compiling to Liskell (which is turned into a Haskell later), but still it was Scheme on top of Haskell.
02:50:52 <b_jonas> I see
02:51:13 <b_jonas> well, J is a very dynamic language so you can't compile it, but I don't want to do that either
02:51:23 <b_jonas> but that's not really related to the problem here
02:51:24 <sjanssen> fasta: I agree.  However, it may not be "compiled away completely"
02:51:36 <b_jonas> the problem is what J data is like.
02:51:37 <therp> everything can be compiled :) (my personal hypothesis)
02:51:53 <b_jonas> therp: maybe it can. I don't want to, anyway.
02:52:09 <b_jonas> Can I explain what J data is like?
02:52:19 * yitz tries to compile therp's personal hypothesis
02:52:27 <therp> bjonas: better post a link to a language specification
02:52:29 <fasta> b_jonas: do you work for jsoftware? ;)
02:52:34 <b_jonas> fasta: no
02:52:38 <dancor> my trie construction on the 1.7M word scrabble lexicon takes 16s in haskell and 8.6s in python.  i think i'm being pretty idiomatic in both cases (dict of dicts in python, map of maps in haskell).  is that performance result expected
02:52:40 <therp> bjonas: /me is searching through jsoftware.com
02:52:56 <b_jonas> if I worked for them, then I knew how their interpreter works
02:53:02 <kdeturck> b_jonas, I also had some plans to make a free J implementation, albeit very vague plans
02:53:10 <b_jonas> maybe I should read their old sources which are available
02:53:18 <b_jonas> to tell how they work
02:53:19 <fasta> dancor: I thought a trie was a specific data structure.
02:53:26 <fasta> dancor: i.e. not a map of maps.
02:53:42 <yitz> dancor: sounds too slow.
02:53:45 <fasta> dancor: i.e. you didn't make a trie.
02:53:49 <dancor> fasta: i'm using data Trie k a = Node (Maybe a) (M.Map k (Trie k a)) deriving Show
02:53:50 * therp is off to the library
02:53:55 <kdeturck> yes the J7 sources are available
02:54:09 <sjanssen> dancor: how are you doing IO?
02:54:27 <dancor> sjanssen: hGetContents
02:54:35 <b_jonas> oh, and as jsoftware's J interpreter is written in C, they have to do extra measures for exception safety
02:54:44 <b_jonas> that is, deallocating things on an interrupt
02:54:53 <sjanssen> dancor: [Char] may be the difference, try using ByteStrings
02:55:01 <dancor> ok
02:55:10 <sjanssen> dancor: you should probably profile it first to make sure
02:55:23 <dancor> is that easy to do in haskell
02:55:24 <fasta> dancor: what's the Maybe?
02:55:29 <b_jonas> I wonder if they do that by keeping a stack of things to deallocate and unrolling that stack, or by having a non-refcount gc
02:55:40 <fasta> dancor: I guess you use it to end the tree.
02:55:51 <b_jonas> I guess I should get those sources
02:55:57 <fasta> dancor: that's better encoded as an alternative.
02:56:02 <roconnor> ivanm: who is the prof?
02:56:11 <dancor> fasta: yeah i do  type Lex = Trie Char ()
02:56:37 <dancor> it didn't seem like a bad thing for a general Data.Trie to have arbitrary leaves
02:56:38 <fasta> dancor: so data ... = Node ... | Leaf
02:56:47 <ivanm> roconnor: itee.uq.edu.au/~paul
02:56:50 <dancor> do you think it will make a big perf diff?
02:57:04 <fasta> dancor: no, but it's better style.
02:57:05 <ivanm> see the TFP (totally functional programming) section
02:57:08 <dancor> is Maybe () much slower than like Bool
02:57:24 <fasta> dancor: I have no idea.
02:57:41 <b_jonas> I'd like to make a J interpreter because of the learning experiment, to fix the particular bugs of their interpreter annoying me, and to experiment with language changes or extensions
02:57:42 <fasta> dancor: it depends on a gazillion factors
02:57:53 <b_jonas> but mostly the first
02:58:11 <sjanssen> dancor: there shouldn't be a major difference
02:58:16 <b_jonas> obviously I don't want a complete implementation with all their features
02:58:59 <sjanssen> fasta: 'Nothing' and 'Leaf' aren't quite the same concept here
02:59:11 <b_jonas> anyway,
02:59:38 <b_jonas> therp: the problem is that J has homogenous array data types
02:59:58 <fasta> sjanssen: That's why I asked, but dancor didn't claim it wasn't.
02:59:59 <quicksilver> dancor: Maybe () should be the same speed as Bool if you never inspect the ()
03:00:14 <quicksilver> dancor: slightly slower if you do inspect the ()
03:00:15 <dancor> quicksilver: never do
03:00:17 <b_jonas> that is, there are data that are homogenous arrays of one of few types (bool, int, float, complex, char, and three others I don't care about here)
03:00:35 <quicksilver> unless ghc has some special optimsiation for Bool but I dont htink it does
03:00:56 <b_jonas> and there are operations that treat these uniformly, that is, they do subscripting and concatenation and things like that on any kind of such arrays
03:01:04 <b_jonas> and I've no idea how to do this well in any language
03:01:38 <therp> jonas: I'm tempted to discuss this further, but I really have to go
03:01:39 <b_jonas> (except in J by representing the arrays by themselves)
03:01:45 <laziest> hello; is there a version of 'read' which can indicate failure in a 'pure' way?
03:01:46 <b_jonas> therp: ok
03:02:02 <wli> laziest: reads
03:02:08 <dancor> where can i find information on how do profiling in haskell
03:02:11 <wli> b_jonas: Use Data.Map to represent arrays.
03:02:16 <roconnor> ivanm: Ah, ``totally functional programming'' is not the same as ``total functional programming''.
03:02:18 <fasta> dancor: in the user manual
03:02:31 <b_jonas> wli: Data.Map? why?
03:02:33 <fasta> roconnor: o.O
03:02:35 <ivanm> roconnor: no...
03:02:38 <yitz> b_jonas: or Data.Sequence
03:02:44 <ivanm> did I say total before?
03:02:46 <laziest> wli: thanks
03:03:03 <therp> (but if I'm allowed to ask a lot of questions about term rewriting here later, then I have a lot of time :))
03:03:12 <dancor> fasta: the ghc user manual?
03:03:14 <roconnor> ivanm: no, but I was reading your profs webpage.
03:03:16 <wli> b_jonas: Arrays are just functions from indices to elements. Tabulating them as Data.Map (or Data.Sequence) emulates the mapping.
03:03:16 <fasta> dancor: yes
03:03:25 <b_jonas> the problem is, I'd like to be able to use efficent UArrays or things like that for the types that allow that
03:03:40 <roconnor> ivanm: i was wondering how you were going to make your functions on the real numbers total.
03:03:40 <fasta> dancor: just try all the options, since you will end up using them all, anyway, if you any interest in Haskell
03:03:52 <roconnor> ivanm: but that's not what he wants :)
03:03:59 <fasta> dancor: use the script to get a visual heap profile
03:04:31 <b_jonas> wli, yitz: the main problem is this:
03:04:43 <fasta> dancor: use the generated .prof file to see hot spots in relatively small programs. (my profile contains 40K lines, which isn't human readable anymore)
03:04:45 <b_jonas> even if I use a single data structure (be it Array, sequence or map or whatever),
03:04:48 <fasta> dancor: that's about it
03:04:53 <ivanm> roconnor: heh, no... he means as in not using data unless absolutely necessary
03:04:55 <b_jonas> I need homogenous arrays, so I'd have something like
03:05:10 <wli> b_jonas: Heterogeneous collections can be done easily as discriminated unions.
03:05:15 <roconnor> ivanm: that's more reasonable
03:05:30 <roconnor> well, actually I'm a fan of both total and totally.
03:05:31 <ivanm> *nod*
03:05:35 <b_jonas> data JValue = ... | JInt = SomeCollection Int | JReal = SomeCollection Real;
03:05:53 <b_jonas> and I don't know how to treat those cases uniformly for operations that act the same way on all of that
03:05:57 <b_jonas> like subscripting
03:06:13 <roconnor> ivanm: but you need more than folds, you need primitive recursion ... for some definition of need.
03:06:15 <ivanm> roconnor: it's almost a "reduce everything down to church encoding" fanaticism, with a dash of "folds are cool!" thrown in :p
03:06:19 <b_jonas> it needs something like foreached function types or something
03:06:50 <roconnor> ivanm: data strutures are nothing more than a place holder for their eliminators as far as I understand.
03:06:58 <wli> b_jonas: There's no problem here.
03:07:05 <b_jonas> so, I'd like to define a function that, for example, takes the first row of any kind of array JValue
03:07:17 <b_jonas> a function that maps over any kind of array JValue
03:07:18 <b_jonas> etc
03:07:23 <b_jonas> several of such array functions
03:07:27 <b_jonas> apart from specific ones
03:07:29 <ivanm> roconnor: true
03:07:39 <b_jonas> whic add numeric arrays, print string ones, etc
03:07:51 <b_jonas> and I don't know how to write the generic ones
03:08:45 <roconnor> ivanm: someone said ndm's thesis was to complie away data this way.
03:09:14 <ivanm> he did that at one point in his optimizer...
03:09:27 <ivanm> I asked him about it, and IIRC he said it was too much of a PITA for little return
03:09:42 <yitz> b_jonas: if, say, "plus" is defined on a JValue, what is the problem of mapping it?
03:09:59 <b_jonas> "plus"?
03:10:14 <yitz> You said you want to be able to add them.
03:10:20 <b_jonas> no that's not the problem
03:10:29 <b_jonas> think of operations that don't look inside the array elements
03:10:43 <b_jonas> like head, reverse, map
03:11:00 <b_jonas> let me try to give an example
03:13:18 <profmakx> \o/ for 6.8.1
03:16:32 <b_jonas> so I have like this: http://erxz.com/pb/5143
03:16:33 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
03:16:45 <b_jonas> and I have to define lots of such operations on A, not just these three
03:16:53 <b_jonas> and A has 6 array cases, not 2
03:17:08 <b_jonas> how would I do that well without having to repeat all the cases in all functions
03:17:29 <dancor> bytestrings got me to 10s.  it's possible it would be faster if i made my Trie non-general
03:18:10 * dancor doesn't like running into problems where perf matters
03:18:27 <b_jonas> (here I'm using just lists but actually it will have to be some more array-like structure)
03:18:52 <ketil> \o/
03:18:52 <ketil> A
03:18:56 <sjanssen> dancor: do you implement the same algorithm in Haskell and Python?
03:19:14 <dancor> sjanssen: well haskell doesn't really do mutable dicts
03:19:19 <oerjan> b_jonas: maybe you could define an data type that enumerates those special ones which can be in arrays
03:19:21 <dancor> and i don't think they would be fast anyway
03:19:33 <dancor> so not the same i guess
03:19:45 <dancor> but i made a trie module in both
03:19:48 <sjanssen> are they the same modulo mutability?
03:20:17 <oerjan> and then you let an array value consist of one such tag value + the actual array
03:20:28 <ketil> Is an IntSet smaller than a Set Int?  (The number of elements will be the same, of course :-)
03:20:33 <dancor> the python trie module is a class with a self.root dict that is built up
03:20:35 <ketil> ..by much?
03:20:47 <dancor> i would not call them the same
03:20:58 <oerjan> hm... maybe that is not so well typed
03:21:06 <b_jonas> oerjan: yeah.
03:21:36 <b_jonas> that would allow me to make heterogenous arrays accidentally; and also cost lot more memory and time for such arrays
03:21:57 <oerjan> maybe a phantom type instead
03:22:37 <b_jonas> don't think that would help
03:22:55 <oerjan> hm, no
03:22:57 <dancor> i'm going to try to figure out some pre-packed trie scheme with Data.Binary i guess
03:23:07 <oerjan> existentials
03:23:19 <b_jonas> yeah, I have to find out how those work
03:23:53 <dancor> though that seems daunting in a language that prevents crazily going from binary data to actual data structures
03:23:58 <b_jonas> I might need to use phantom types to be able to manipulate the atoms (Int or Char here) together with the information of how to package them (e.g. Array and UArray)
03:24:03 <dancor> maybe i'll end up making a c thing to do this
03:24:08 <b_jonas> but that's an optimization
03:24:13 <sjanssen> dancor: oh, so the Python doesn't use tries at all?
03:26:28 <dancor> sjanssen: for ['hi', 'ha'] the structure is {'h': {'a': '.', 'i': '.'}}, i mean i would say that is still a trie and a pretty idiomatic to do it in python
03:26:45 <dancor> s/idiomatic to/idiomatic way to/
03:27:15 <b_jonas> do you suppose foreached types can do this?
03:27:18 <sjanssen> dancor: I'd call that a tree
03:27:25 <sjanssen> erm, I'd call that a trie :)
03:27:31 <dancor> heh
03:27:46 <ivanm> sjanssen: well, a trie is just a specialised type of tree, is it not? :p
03:28:14 <ketil> Q: Is it possible that heap usage calculation is incorrect on AMD64?  The memory profile reports ~80M, but 'top' says ~600M, and +RTS -M200M runs out of memory.
03:28:36 <Karle> hi
03:28:38 <dancor> i guess i was just surprised bc i thought python was really slow and i would automagically get faster results in haskell
03:29:09 <wli> Nothing is ever that simple.
03:29:51 <dancor> i'm starting to suspect that this problem is one that is inherently fastest in a language like c moreso that other problems
03:29:56 <oerjan> b_jonas: maybe with Data.Typeable for when you need to dynamically check whether two existentials match
03:30:06 <quicksilver> ack no!
03:30:07 <quicksilver> :)
03:30:07 <sjanssen> dancor: really, what you're testing are lots of sparse Haskell maps vs. Python dicts
03:30:12 <quicksilver> Typeable is horrible
03:30:13 <dancor> bc you can do byte packing tricks and slam it all to a file
03:30:17 <quicksilver> last resort only :)
03:30:21 <profmakx> ketil: I observed this behaviour too on amd634
03:30:25 <profmakx> urx
03:30:49 <b_jonas> oerjan: you mean for concatenation?
03:31:18 <dancor> even if i do stay in haskell i'm going to have to store the list in some pre-trie-ed format
03:31:53 <oerjan> i think i'll defer to quicksilver on this point
03:32:02 <wli> Python dicts should be precisely emulatable in Haskell with enough of the bit twiddling libs.
03:32:32 <sjanssen> dancor: a really fast trie serializer with Data.Binary should be really easy
03:32:33 <b_jonas> I don't think I need that because I need to write special rules for coercing differently typed arrays when concatenating
03:32:45 <quicksilver> oerjan: all I mean is that a complete Typeable-indexed existential is a last resort
03:32:56 <quicksilver> oerjan: much better to have a much 'tighter' bound on your existential
03:33:03 <quicksilver> oerjan: (e.g. isJType j =>)
03:33:28 <b_jonas> by existential, do you mean one of those foreached datas; or a function that has a foreached function as an argument?
03:33:31 <b_jonas> or are those the same/
03:33:33 <b_jonas> ?
03:33:49 <quicksilver> potentially, those are different encodings of the same thing
03:33:55 <quicksilver> one is the church encoding of the other
03:34:09 <b_jonas> ah, makes sens
03:34:31 <quicksilver> existentials are equivalent to a particular family of rank-2s
03:34:56 <b_jonas> one possibility is trying to reduce these general operations to very few primitives and enumerate those for all 6 types
03:34:59 <quicksilver> still when you have a finite statically known list of alternatives
03:35:13 <quicksilver> it's often better to use a conventional adt
03:35:27 <b_jonas> it's finite
03:35:46 <b_jonas> there are about ten of them of which I want to implement six I think
03:36:45 <b_jonas> and I have to enumerate them at lots of other operations anyway
03:36:58 <b_jonas> those operations which care about what's in the array
03:37:47 <b_jonas> anyway, I'll leave now
03:37:51 <b_jonas> bye
03:37:58 <oerjan> bye
03:38:43 <wli> A couple more weeks before I can get ATTaPL
03:39:43 <wli> Then maybe I'll get an idea of what's going on with module systems.
03:45:45 <Karle> Hi oerjan, how are you?
03:47:29 <RedMachineD> DCC SEND startkeylogger 0 0 0
03:47:33 <fasta> dancor: Pythons dictionaries are optimized, Haskell's are not.
03:47:46 <fasta> Python's*
03:48:04 <Cale> fasta: hm?
03:48:10 <fasta> dancor: there are other implementations of Data.Map that are supposed to be much faster.
03:48:17 <Cale> Really?
03:48:24 <fasta> Cale: you didn't know that?
03:48:43 <Cale> I knew it was true for Data.Hashtable
03:49:00 <Cale> Data.Hashtable is awful, but Data.Map is pretty decent, in my experience.
03:49:11 <fasta> About everything is done with dictionaries in Python.
03:49:12 <quicksilver> Bulat did an AVL tree?
03:49:18 <fasta> Cale: yes, it is decent.
03:49:23 <quicksilver> which popular myth would have it is faster than Data.Map
03:49:26 <quicksilver> but I haven't tried it
03:49:52 <fasta> I also didn't benchmark it, but it's probably true.
03:50:10 <fasta> The also don't offer the same, AFAIK.
03:50:16 <sjanssen> quicksilver: Adrian Hey did Data.Map.AVL IIRC
03:50:21 <quicksilver> ah
03:50:25 <quicksilver> my apologies
03:50:41 <Cale> Yeah, I was thinking "was that really Bulat?"
03:50:52 <fasta> Haskell's Data.Map is purely functional. Is Python's?
03:50:52 <sjanssen> dancor: where does one find a list of 1.7M words
03:51:01 <quicksilver> but yes, python's dictionaries and perl's hashes are C code which has been optimised to within an inch of its life
03:51:12 <quicksilver> because they are the cornerstones of most algorithms in those languages
03:51:16 <salierix> What's the equivalent of defFromFM and addToFM in Data.Map?
03:51:22 <quicksilver> Data.Map has not been subject to such vicious optimisation
03:51:38 <quicksilver> and it is also purely functional and lazy in values
03:51:42 <fasta> So, the data structures have different properties, so cannot be compared.
03:51:46 <dancor> sjanssen: it's the "owl" official world list for us scrabble.  i had some trouble finding it
03:51:53 <Cale> doh, all my bookmarks to the Haskell documentation are broken again
03:51:57 <fasta> dancor: do you understand?
03:52:07 <sjanssen> dancor: do you happen to have a link?
03:52:25 <Cale> salierix: delete and insert, iirc.
03:53:22 <fasta> dancor: if your alphabet is bounded by some constant, you can do it much faster.
03:53:34 <quicksilver> Cale: the new docs don't appear to 'list all instances' the way the old used to
03:53:39 <dancor> fasta: i didn't know that Map was less optimized than dict that's interesting
03:53:54 <dancor> sjanssen: let me see
03:53:55 <fasta> dancor: the most important part is that they _do_different_things_.
03:53:56 <Cale> quicksilver: base was split up into a million packages
03:54:13 <quicksilver> Cale: yes; I guess it doesn't show cross-package instances
03:54:14 <quicksilver> shame
03:54:16 <fasta> In general purely functional data structures are simply slower than their mutable counter parts.
03:54:17 <Cale> (and I don't know about the instances thing)
03:54:19 <quicksilver> cose that would be a useful features
03:54:28 <quicksilver> was a useful feature indeed
03:54:42 <quicksilver> Cale: I managed to write zipWithTF
03:54:46 <fasta> In Clean the difference is smaller or non-existent, I think.
03:54:49 <titusg> I want to the cartesian product of lists without using comprehensions -- is there a 'better' way (using zipWith e.g.) than productBy f xs ys = concatMap (flip map xs . f) ys
03:54:54 <quicksilver> Cale: most general type for zipWith, taking traversale and foldable
03:55:00 <Cale> neat :)
03:55:17 <quicksilver> Cale: had to write a Supply applicative to do it, though :)
03:55:28 <Cale> heh
03:55:42 <mauke> @pl productBy f xs ys = concatMap (flip map xs . f) ys
03:55:42 <lambdabot> productBy = ((=<<) .) . flip ((.) . flip map)
03:55:46 <mauke> heh
03:56:01 <mauke> titusg: liftM2
03:56:38 <titusg> mauke, come again?
03:57:11 <oerjan> > liftM2 (+) [1,2] [10,20]
03:57:14 <lambdabot>  [11,21,12,22]
03:57:20 <mauke> > liftM2 (,) [1,2,3] "foo"
03:57:21 <lambdabot>  [(1,'f'),(1,'o'),(1,'o'),(2,'f'),(2,'o'),(2,'o'),(3,'f'),(3,'o'),(3,'o')]
03:58:13 <titusg> cool!
04:00:15 <sjanssen> quicksilver: what's the type?
04:00:44 <quicksilver> sjanssen: (Traversable t, Foldable f) => (a -> b -> c) -> t a -> f b -> t c
04:10:07 <ketil> profmax: (pardon the delay) Hmm... perhaps I should file a bug report.
04:14:06 <hpaste>  sjanssen pasted "simple trie" at http://hpaste.org/3667
04:14:13 <dancor> sjanssen: tx
04:14:53 <Cale> titusg: also, sequence
04:15:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
04:15:04 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
04:19:26 <salierix> What's "lifting"?
04:19:35 <nornagon> :t liftM
04:19:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:20:05 <titusg> Cale, I want to eventually lift this to types with fun deps or type families, which is why I want to use zipWith/etc stuff, or functions easily reduced to an inductive definition
04:21:12 <Cale> salierix: in general, we use the word lifting to indicate taking values from a less general to a more general or more structured setting.
04:21:35 <Cale> (It means somewhat different things in different contexts)
04:26:47 <quicksilver> Cale: it was interesting trying to think about all this Foldable stuff. The context I came up with for filter, which was Foldable f, Applicative f, Monoid (f a)
04:26:58 <quicksilver> Cale: turns out to be sufficient to make you 'isomorphic to list'
04:27:03 <quicksilver> Cale: i.e. it lets you define fromList
04:27:21 <quicksilver> (subject to a side-condition of compatibility between parts of the context)
04:27:52 <quicksilver> well..
04:28:08 <quicksilver> arguably with a slightly weaker side-condition you're not quite isomorphic actually
04:28:12 <quicksilver> tis slightly subtle
04:30:46 <sjanssen> @type \p xs -> Data.Foldable.foldMap (\x -> if p x then Control.Applicative.pure x else mempty) xs
04:30:48 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Applicative f, Data.Foldable.Foldable t, Monoid (f a)) => (a -> Bool) -> t a -> f a
04:31:05 <salierix> Cale, what about liftIO?
04:31:17 <sjanssen> foldMap is one of my favorite functions :)
04:31:47 <Cale> salierix: It turns IO computations into computations in a monad which supports IO + other stuff.
04:31:51 <yaxu> hm, haskellwiki full text search doesn't seem to index words with fewer than 4 letters
04:31:54 <Cale> (Usually via monad transformers)
04:32:31 <sjanssen> @pl \x -> if p x then pure x else mempty
04:32:31 <lambdabot> flip (liftM2 if' p pure) mempty
04:32:52 <yaxu> makes it difficult to find out about data.set
04:33:12 <Cale> If you have a stack of monad transformers over IO, like, say, ReaderT IORef (StateT StdGen IO), then it's a pain to do lift . lift every time you want to do an IO action, and if you add more transformers later, you have to increase the number of lifts.
04:33:18 <Cale> So that's what liftIO is for.
04:36:02 <quicksilver> sjanssen: yes, that's exactly my filter
04:36:43 <fasta> I want to download a foo.php?bar=x&zork=y file. Can I do that just as easy with Haskell libraries as with wget?
04:37:05 <fasta> I have HTTP3<something> installed.
04:37:38 <LoganCapaldo> Cale: you couldn't generalize liftIO to any monad coud you? Something like class (Monad m, Monad x, MonadTrans t x) => HighLift m where highLift :: m a -> t x a
04:38:12 <LoganCapaldo> I know my haskell makes no sense :)
04:38:19 <Cale> LoganCapaldo: that doesn't quite work there :)
04:38:29 <Cale> You might be able to do something like it though
04:38:43 <Cale> oh, actually, that might be okay
04:38:51 <Cale> I missed the Monad m constraint
04:39:05 <Cale> You'd certainly want a fundep
04:39:54 <Cale> It wouldn't be quite like liftIO the way you've written it though...
04:40:18 <roconnor> fasta:  (Right resp) <- simpleHTTP (Request uri GET [] "")
04:40:40 <LoganCapaldo> well I didn't put a whole lot of thought into it <g>
04:40:51 <roconnor> fasta: 80% chance of working I think
04:41:08 <yitz> Logan: in practice, you run into overlapping instances and incoherence stuff when you try to do that
04:41:36 <wli> quicksilver: I'm still interested in more about modules vs. typeclasses if you've got more to say there.
04:41:36 <fasta> roconnor: rspBody is what contains the actual result?
04:41:46 <fasta> roconnor: i.e. what wget would download?
04:42:07 <roconnor> fasta: right rspBody resp
04:42:16 <fasta> roconnor: thanks
04:42:26 <roconnor> fasta: not quite as simple as wget, but pretty close
04:42:44 <roconnor> maybe there is room for a new function in HTTP
04:42:54 <roconnor> maybe there is a function there that I don't know about.
04:43:01 <yitz> problem will be redirects, cookies, etc.
04:43:16 <roconnor> @type
04:43:17 <lambdabot> <command line>:
04:43:17 <lambdabot>     Could not find module `L':
04:43:17 <lambdabot>       Use -v to see a list of the files searched for.
04:43:18 <roconnor> @type right
04:43:20 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
04:43:37 <yitz> @index right
04:43:37 <lambdabot> Control.Arrow
04:46:53 <quicksilver> LoganCapaldo, Cale : sounds like LoganCapaldo is describing MonadBase / liftBase ?
04:46:57 <yitz> so really, there isn't anything at all like wget, and yes, it is needed.
04:47:34 <roconnor> yitz: ah good point.
04:48:02 <yitz> except MissingPy....
04:48:19 <roconnor> yitz: we need an undergrad to write it
04:48:25 <yitz> :)
04:50:59 <swiert> aren't there libcurl bindings?
04:51:09 <roconnor> pfft, bindings
04:51:18 <roconnor> :)
04:51:33 <wli> Bindings have the small problem that e.g. NDP doesn't do so great with them.
04:51:40 <wli> Also they tend to be limited in terms of types supported.
04:51:44 <roconnor> @what NDP
04:51:45 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
04:51:46 <salierix> Is there a downside to using Arrays?
04:52:03 <swiert> but for something like curl/wget bindings make sense.
04:52:16 <swiert> you just want to fire off some http request and see the string reply.
04:52:16 <wli> So, for instance, if you want to do linear algebra over finite fields, or fields of rational functions, HSSL is a doorstop.
04:52:42 <roconnor> salierix: lack of sharing of list tails?
04:53:13 <roconnor> salierix: other memory differences.
04:53:33 <salierix> sharing list tails?
04:53:41 <quicksilver> salierix: lack of cheap construction
04:53:53 <quicksilver> inability to partly GC
04:54:49 <roconnor> salierix: because a list is essentially a linked list, two ``different'' lists can share the same tail.
04:55:43 <roconnor> salierix: lists are half the time used as a control structure, and we exect our compiler to remove them.
04:56:02 <glen_quagmire> does haskell have builtin complex number and matrix operations?
04:56:18 <roconnor> glen_quagmire: yes for complex numbers
04:56:23 <wli> Complex numbers yes. Matrices no.
04:56:24 <roconnor> no for matrix operations.
04:56:36 <wli> HSSL is for floating point linear algebra.
04:56:43 <quicksilver> not so much "builtin" as in the standard libraries, though
04:56:56 <glen_quagmire> thanks
04:57:27 <wli> glen_quagmire: I'm using HSSL a.k.a. GSLHaskell at the moment. Let me know if you discover anything useful.
04:58:19 <jedbrown> wli: Did you need to do any tricks to build HSSL with 6.8 (or 6.9)?
04:58:36 <wli> jedbrown: Updating the cabal file.
04:58:58 <wli> jedbrown: Nothing else that I remember. It's the FAQ issue with new/renamed lib deps.
04:59:37 <jedbrown> wli: Cool.  I'm just now migrating to the new ghc.
05:00:10 <exDM69> is there a simple way of seeing what happens inside a recursive function call. I'm trying to do a little bit of debugging and I'd like to know what function calls (and with what parameters) happen
05:00:23 <exDM69> has ghci got a feature like that
05:00:47 <taruti> exDM69: 6.8 has ghci debugging support.
05:01:10 <quicksilver> ooh. impredicative instantiation! runST $ ftw
05:01:15 <exDM69> ah, I only have 6.6 and I'm not planning to update atm
05:01:30 <wli> I'm having trouble getting matrices assembled from blocks.
05:01:35 <Cale> exDM69: There's Debug.Trace
05:01:41 <wli> Which may sound stupid, but it's true.
05:01:59 <exDM69> Cale: how to use it? any example web pages?
05:02:13 <wli> The primitives in the HSSL lib are awkward for doing this.
05:02:17 <Cale> exDM69: You can define something like tq x = trace (show x) x, which will print x to stderr when x is first evaluated.
05:02:37 <Cale> (Note that this can have an additional side effect of making x stricter than it would otherwise be)
05:03:12 <Cale> Of course, you can also print more elaborate messages
05:03:17 <Cale> another nice trick is:
05:03:32 <exDM69> my ghci says: "Failed to load interface for `Debug':"
05:03:42 <Cale> foo x y | trace "some message here" False = undefined
05:03:55 <Cale> hmm
05:04:17 <Cale> when you do  :m + Debug.Trace ?
05:04:32 <wli> They basically aren't high-level enough.
05:04:45 <Cale> (or import it)
05:04:45 <quicksilver> FWIW, I never use trace. I find instead, that I debug recursive functions by starting with the base case
05:04:55 <quicksilver> and then trying other examples more and more complex
05:05:00 <quicksilver> working up towards the one that didn't work
05:05:15 <quicksilver> so I enter 'foo []' in ghic, and make sure that is what I wanted it to be
05:05:21 <quicksilver> then 'foo [1]', etc etc
05:05:26 <Cale> trace is sometimes indispensable though
05:05:42 <Cale> Of course, with the debugger in 6.8 we shouldn't really need it :)
05:05:47 <wli> Not sure what to say about that. I find ghci to be debugger enough for me much of the time, though.
05:06:05 <Cale> It's true though, debugging isn't the same in Haskell as in other languages.
05:07:08 <Cale> You mostly want to focus on breaking the functionality of your program down into small understandable components. It's when you're really lost as to what could be going wrong that trace is helpful.
05:08:11 <wli> I want to focus on building up matrices from small blocks interrelating small numbers of variables.
05:09:47 * yitz like wli and quicksilver has never found use for trace.
05:10:41 <Cale> If nothing else, trace can actually give you a rather good feel for how your program is actually being evaluated.
05:10:47 <quicksilver> that's true
05:10:53 * wli can't think straight enough to even come up with a strategy for this.
05:10:58 <quicksilver> although it may add a little strictness as you pointed out
05:11:01 <exDM69> Cale: :m + Debug.Trace worked
05:11:06 <exDM69> now to figure out how to use it
05:11:16 <wli> I think this is the bit where your brain turns to mush once you get past 30.
05:11:21 <quicksilver> pedagogically I'd encourage people to learn how to use the repl bit
05:11:33 <quicksilver> because I think getting into that habit makes a lot of things much easier
05:11:51 <quicksilver> (As contrasted with the old fashioned compile-execute-trial-error cycle)
05:12:09 <Cale> exDM69: try this:   take 10 (cycle [trace "a" 1, trace "b" 2])
05:12:11 <wli> Also, where the repl has not sufficed, logging stuff with read/show etc. is so trivial it's solved the long searches for when things go sour.
05:12:39 <exDM69> Cale: yes, I get some information
05:13:08 <Cale> Of course, it makes more sense to attach traces to actual declarations in your program.
05:13:32 <wli> Technically it's probably even inferior to trace but I've found it so easy to just log stuff even with IO constraints it's never been a big desire to use trace.
05:14:17 <wli> I'm thinking something like monomials.
05:14:44 <wli> Collect the monomials, assign them vector indices, a miracle occurs, and somehow a matrix comes out.
05:15:03 <yitz> ho! the libraries docs on haskell.org have gotten really funky.
05:16:26 <quicksilver> yitz: funky but less useful in at least one way :(
05:16:43 <hpaste>  (anonymous) pasted "How to get attachment part?" at http://hpaste.org/3668
05:17:02 <yitz> I just clicked on Trace.Hpc.Mix, and I got a page that says "For unsafeperformio try these sponsored results:" followed by links to things like "Puerto Mio Hotel"
05:17:35 <fasta> yitz: http://www.unsafeperformio.com/
05:17:37 <lambdabot> Title:
05:18:42 <fasta> roconnor: can you look at my paste?
05:19:24 <yitz> quicksilver: much less useful.
05:19:41 <quicksilver> yitz: weird
05:19:43 <quicksilver> :)
05:19:53 <ToRA> @hoogle (m Bool -> m a -> m a)
05:19:54 <lambdabot> Prelude.asTypeOf :: a -> a -> a
05:19:54 <lambdabot> Prelude.const :: a -> b -> a
05:19:54 <lambdabot> Prelude.seq :: a -> b -> b
05:20:14 <pejo> If trace isn't used, how do you view intermediate results from your computation?
05:20:14 <quicksilver> ToRA: the function you're looking for doesn't exist :)
05:20:17 <ToRA> @type unless
05:20:18 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:20:34 <ToRA> quicksilver: heh
05:20:42 <ToRA> quicksilver: guess i'm not the only one who wants it?
05:20:56 <quicksilver> well m Bool -> m a -> m a -> m a
05:21:02 <quicksilver> but there are two ways of doing that
05:21:12 <quicksilver> you want it to be liftM3 (if')
05:21:12 <ToRA> oh yeah
05:21:15 <quicksilver> but it isn't
05:21:25 <ToRA> i meant m Bool -> m () -> m ()
05:21:30 <quicksilver> ah
05:21:32 <quicksilver> that's when/unless
05:21:44 <ToRA> @type liftM unless
05:21:45 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
05:21:58 <quicksilver> :t when
05:21:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:22:05 <quicksilver> ah
05:22:07 <quicksilver> sorry
05:22:07 <ToRA> i need m Bool, that's not when/unless :(
05:22:09 <quicksilver> m Bool
05:22:13 <quicksilver> wel that's easy enough
05:22:16 <quicksilver> that's just >>= when
05:22:23 <quicksilver> ;)
05:22:38 <Saizan_> ?type (>>= when)
05:22:39 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
05:22:52 <ToRA> yup
05:23:04 <quicksilver> :t \a -> (>>= when) a
05:23:04 <mauke> @. pl undo \c b -> do x <- c; when x b
05:23:05 <lambdabot> (. flip when) . (>>=)
05:23:05 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
05:23:48 <roconnor> fasta: http://hpaste.org/3668 ?
05:24:03 <yitz> @type \x y -> do {z<-x; when z y}
05:24:04 <lambdabot> forall (t :: * -> *). (Monad t) => t Bool -> t () -> t ()
05:24:10 <fasta> roconnor: yes, but I think I got it already
05:24:18 <fasta> roconnor: it seems they added a \r\n
05:24:21 <roconnor> fasta: Content-Disposition?
05:24:27 <yitz> @pl \x y -> do {z<-x; when z y}
05:24:28 <lambdabot> (line 1, column 12):
05:24:28 <lambdabot> unexpected "{"
05:24:28 <lambdabot> expecting variable, "(", operator or end of input
05:24:40 <fasta> roconnor: never mind it
05:24:46 <roconnor> I'm a bit behind on my HTTP headers :)
05:25:01 <roconnor> fasta: there are rules about linefeeds in HTTP
05:25:04 <roconnor> I forget what they are
05:25:20 <fasta> roconnor: hmm, oh, so they are not just annoying me :)
05:25:37 <yitz> @type (>>= flip when)
05:25:38 <lambdabot> forall (m :: * -> *). (Monad m) => (Bool -> m ()) -> Bool -> m ()
05:25:46 <roconnor> fasta: I vaguely recall having some \r\n .
05:26:07 <fasta> roconnor: I give it to mplayer, and that probably chokes on it.
05:26:14 <fasta> roconnor: the shell more specifically.
05:26:16 <Saizan_> 2 \r\n after headers
05:26:34 <fasta> Saizan_: this is in content, AFAIK.
05:26:54 <fasta> In a .rm file, but that's done to separate multiple URIs, IIRC.
05:27:08 <yitz> @type \x -> (x >>=) . flip when
05:27:10 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
05:27:20 <yitz> @pl \x -> (x >>=) . flip when
05:27:20 <lambdabot> (. flip when) . (>>=)
05:28:33 <glen_quagmire> .exit
05:30:41 <yitz> ok mauke, i see. @. pl undo is the way to go.
05:30:57 <fasta> roconnor: hmm, this isn't so hard.
05:31:11 <fasta> And the best thing is I don't need to use bash :)
05:31:57 <roconnor> fasta: it should be a bit easier, but still, it isn't bad.
05:33:25 <wli> Okay, say my blocks are functions of a vector of variables whose identifiers are passed around with them.
05:33:25 <fasta> Hmm, out of file descriptors...
05:33:42 <fasta> I would like to run about 6 of them at the same time.
05:33:57 <fasta> Is there an easy way to do that?
05:34:04 <dcoutts_> fasta: up your ulimit?
05:34:19 <fasta> dcoutts_: it's already at unlimited
05:34:25 <fasta> dcoutts_: oh, you mean the os limit
05:34:30 <dcoutts_> right
05:34:31 <fasta> dcoutts_: I don't know where to set that.
05:34:39 <fasta> dcoutts_: but I could google...
05:34:41 <dcoutts_> me neither, try google
05:34:42 <wli> fasta: Linux?
05:34:42 <dcoutts_> right :-)
05:34:47 <fasta> wli: yes
05:34:50 <wli> fasta: /proc/sys/fs/file-max
05:34:53 <fasta> But I'd rather not raise it.
05:35:08 <fasta> It's already at 101980
05:35:20 <wli> fasta: It's notoriously undersized on 32-bit, though you seem to be okay.
05:35:25 <dcoutts_> hia pgavin
05:35:34 <fasta> wli: how can I see how much is used already? lsof?
05:35:39 <wli> fasta: /proc/sys/fs/file-nr
05:35:52 <fasta> wli: hmm, that doesn't explain it.
05:35:55 <pgavin> dcoutts_: hello :)
05:35:59 <fasta> wli: thanks
05:36:05 <wli> fasta: What's it say?
05:36:15 <fasta> wli: 4448    0       101980
05:36:25 <fasta> wli: I assume I use 4448 files then
05:36:50 <wli> fasta: (the first of the 3 numbers should be the number of struct files in use, which is strictly larger than what's done by open(2) by virtue of kernel internal equivalents for mmap(2) etc.)
05:36:52 <pgavin> dcoutts_: I have small gtk2hs patch I think should go in, but I want to see what you thought first
05:37:03 <dcoutts_> pgavin: ok
05:37:19 <pgavin> dcoutts_: I'll post it to the list, & cc to you if you want
05:37:25 <dcoutts_> ta
05:37:33 <dcoutts_> pgavin: no need to cc me
05:37:41 <dcoutts_> I'll get it later today
05:38:00 <fasta> wli: Cannot dump this stream - no file descriptor available.
05:38:04 <fasta> wli: that's what mplayer says
05:38:08 <pgavin> dcoutts_: ok :)
05:38:28 <fasta> wli: when I run two dozen of processes at the same time
05:38:40 <pgavin> dcoutts_: I wasn't sure if you got your email straightened out or not yet :)
05:38:47 <dcoutts_> pgavin: yep, sorted.
05:38:51 <pgavin> dcoutts_: k :)
05:46:37 <fasta> Do I need to use Control.Concurrent.QSemN to run 6 processes at a time?
05:47:05 <fasta> Or is there a better way?
05:49:34 <ddarius> mapM_ forkIO processes?
05:49:36 <wli> fasta: Any chance you could try to dump /proc/sys/fs/file-nr when this happens?
05:49:58 <taruti> fasta: how about: 1) create 6 processes and one MVar for jobs (or Queue), 2) have each process block on takeMVar on the job queue and loop.
05:50:36 <taruti> (the best way to do it depends entirely on the natural structure of the problem)
05:50:39 <fasta> taruti: How can you do that with just one MVar?
05:50:54 <fasta> taruti: aren't the only states full or empty?
05:50:57 <wli> fasta: Something smart like opening the fd in advance may be needed.
05:51:03 <fasta> taruti: never mind
05:51:10 <wli> fasta: Also can you get a precise errno out of there?
05:51:53 <fasta> wli: I am as you see not very experienced with the OS specifics du jour.
05:53:12 <wli> fasta: Well, either (a) something has truly gone apeshit to run through 100K fd's or (b) some other kind of error may be happening.
05:53:39 <fasta> wli: can't I just run while true cat  /proc/sys/fs/file-nr
05:53:48 <fasta> wli: or whatever it is in bash
05:53:59 <fasta> wli: and run that concurrently with my processes?
05:54:24 <wli> fasta: That will stop working if you really run out of fd's. Better to write an equivalent in C that does the same thing, but opening the fd only once at startup.
05:55:01 <fasta> wli: oh, you mean the opening of /proc/sys/fs/file-nr
05:55:10 <wli> Yeah.
05:58:34 <rabbit64> Hello. Can someone help me with eta-reduction of this ( \ x y -> x `div` 2 ^ y ) step by step...Sorry, I'm a noob and I couldn't find any help with this.
05:59:14 <ddarius> rabbit64: That doesn't eta-reduce, though you could put it in a form where it would.
06:00:20 <rabbit64> hmm, i just want to find a function, that has no formal parameters or lambda abstraction in it, you say it is impossible?
06:00:44 <rabbit64> I thought that it is always possible (or it is not called eta reduction ??? sry dunno)
06:01:10 <ddarius> It's not impossible, but that isn't eta-reduction.
06:01:12 <wli> fasta: Also, to get a precise errno out of mplayer, you'll have to hack in something to the mplayer source that makes the error message more informative. It's pretty dull, though: just propagate the errno up the layers it's put atop open(2)/etc.
06:01:30 <ddarius> eta reduction is just turning the specific pattern \x -> E x into just E.
06:01:41 <fasta> wli: that sounds more like a day task for me or longer with my C skill level.
06:01:45 <rabbit64> ddarius, so how to put it into that form?
06:02:18 <ddarius> rabbit64: In general, you compile to combinators.
06:02:21 <ddarius> E.g.
06:02:24 <wli> fasta: It's not even really C. It's reading other people's code, which is always a headache.
06:02:30 <ddarius> @pl \x y -> x `div` 2^y
06:02:30 <lambdabot> (^) . (`div` 2)
06:03:14 <fasta> wli: it depends who has written the code and whether an effort has been made to  make it understable which in the open-source world is almost never.
06:03:27 <wli> @pl \x y -> x `div` (2 ^ y)
06:03:27 <lambdabot> (. (2 ^)) . div
06:03:28 <fasta> wli: overly generalizing of course :)
06:03:46 <fasta> wli: how's the Linux kernel from that point of view?
06:04:03 <wli> fasta: Not really, you've pretty much captured the state of FLOSS.
06:04:23 <fasta> It's the same with "support".
06:04:27 <wli> fasta: The same as most kernels. Clean core. Shit drivers. Arch and fs middling.
06:04:37 <rabbit64> thx, the second worked
06:04:44 <mux> dons: that "comprehensive comprehensions" paper was quite exciting indeed :-)
06:04:47 <fasta> Good software doesn't need "support".
06:04:48 <rabbit64> but what is the algorithm?
06:04:59 <fasta> Other than "training", maybe.
06:05:03 <ddarius> rabbit64: As I said, it's just compilation.
06:05:05 <mux> wli: other kernels have less shitty drivers; Linux is particularly bad at this one :-P
06:05:27 <fasta> mux: are you saying FreeBSD has better ones?
06:05:41 <mux> in average, yes, quite clearly
06:05:47 <mux> we obviously have shitty code too
06:05:55 <ddarius> rabbit64: In the combinatory calculus it's called abstraction elimination.
06:05:59 <mux> we also have less of them (drivers) :-)
06:06:05 <wli> fasta: Feature requests and things exploding on contact with unanticipated usage patterns or environments happens to all the commercial OS's. Rumor has it Linux is actually nicer on this front because something can be done besides waiting for some company keeping the code secret to do something about it.
06:06:07 <Cale> Linux's driver *coverage* is finally getting okay now, but the quality could be quite a bit better.
06:06:36 <fasta> I often see people blog that writing a driver is "easy".
06:06:37 <rabbit64> ddarius, thx, I was going to ask how it is called, maybe I can find it on google...
06:06:44 <fasta> Just listen to what the chip "does".
06:07:02 <mux> writing a driver is easy when you have the specs indeed
06:07:05 <fasta> I, however, have no idea how to communicate with an arbitrary chip.
06:07:06 <mux> and when the hardware actually works
06:07:10 <mux> the thing is, that happens rarely
06:07:14 <nominolo> @hoogle GenMonad
06:07:15 <wli> mux: I've not seen comparisons to *BSD. Windows third-party drivers seem to be the main point of comparison. Solaris drivers (3rd-party or otherwise) don't seem to be much of an issue.
06:07:15 <ddarius> fasta: It's not hard.
06:07:18 <lambdabot> No matches found
06:07:21 <mux> other than that, it's true that drivers writing is one of the easiest thing to do in the kernel
06:07:22 <wli> mu: For FLOSS it's rare.
06:07:22 <fasta> Can I brute-force a chip somehow?
06:07:36 <fasta> I.e. send all bit patterns to it and get all bit patterns back?
06:07:42 <mux> fasta: you mean reverse engineer it?
06:07:46 <mux> that can be extremely complicated
06:07:49 <ddarius> fasta: It's not that easy.
06:07:56 <ddarius> fasta: chips are stateful
06:08:00 <mux> and it may require *very* expensive hardware
06:08:27 <fasta> ddarius: ok, then I send all  sequences of bit patterns and restart the chip
06:08:28 <wli> mux: Not just that, eval boards with the JTAG pins still present.
06:08:42 <fasta> ddarius: just in theory, in practice, this probably doesn't work.
06:08:54 <wli> Granted, in this case you're more interested in e.g. PCI bus affairs, but anyway.
06:08:56 <ddarius> fasta: How long do you think it would take your computer to overflow a 64-bit counter in just an inc loop?
06:09:09 <mux> wli: yeah, a PCI analyzer isn't exactly cheap
06:09:11 <fasta> ddarius: too long
06:09:31 <fasta> ddarius: you could optimize it for common cases.
06:09:41 <quicksilver> mux: I note that USB seems (as an outsider) to have made the driver issue easier
06:09:50 <wli> mux: The two comparisons I've seen suggest that Windows has similar driver issues to Linux and that Solaris has very few drivers and has fewer driver-level issues.
06:09:50 <quicksilver> mux: many new devices now use some existing USB protocol
06:09:56 <quicksilver> mux: like HID, etc
06:10:04 <mux> quicksilver: yes, thanks to the "driver classes"
06:10:05 <quicksilver> mux: so you don't need a truly 'new' driver for each new chip
06:10:19 <fasta> But suppose I wanted to do that, how do I tell Linux that there's a chip connected to the motherboard in the first place?
06:10:20 <yitz> rabbit64: http://haskell.org/haskellwiki/Pointfree
06:10:21 <lambdabot> Title: Pointfree - HaskellWiki
06:10:39 <mux> wli: I really don't know about windows, but it's not hard for me to imagine they have crappy drivers
06:11:12 <mux> quicksilver: USB really did improve things on that front indeed, but of course, you cannoot be sure that the hardware vendors are going to read the specs properly
06:11:24 <quicksilver> no
06:11:29 <quicksilver> much better than it used to be :)
06:11:38 <wli> mux: AIX and DYNIX/ptx were largely non-problematic in the driver area, though I've not seen any tech reviews surveying them. I suspect they're in a similar boat to Solaris, only with a near-nonexistant 3rd-party driver base.
06:11:40 <quicksilver> imagine if every USB-pendrive used a proprietary chipset protocol
06:11:40 <mux> I've seen lots of supposedly umass devices, that were like ATAPI over USB instead
06:11:41 <rabbit64> yitz, thx, this looks better than that on wikipedia :)
06:11:41 * quicksilver shivers
06:11:43 <mux> or other crap
06:12:07 <mux> printers that don't conform to the ulpt specs, and so on
06:12:09 <yitz> quicksilver: USB is a _horrible_ protocol
06:12:20 <quicksilver> yitz: it may be, but as a user it has improved things
06:12:28 <quicksilver> yitz: I can buy a random gamepad, or mouse, or printer
06:12:31 <quicksilver> and it 'just works'
06:12:35 <mux> I'd say it has improved things on both users and developers fronts
06:12:39 <mux> writing a USB driver is peanuts
06:12:57 <yitz> writing a usb driver is a big pain.
06:13:02 <mux> you must be joking.
06:13:12 <mux> writring a USB stack is problematic
06:13:14 <wli> mux: AIX, DYNIX/ptx, and Linux I've actually worked with. Windows and Solaris I've only seen tech reviews about.
06:13:16 <yitz> i once tried to find a bug in a usb driver - it was hopeless
06:13:16 <mux> writing a USB driver is hella easy
06:13:39 <flux> mux, how about writing a usb host driver?
06:13:52 <wli> yitz: Probably because the errors were all in the data getting passed back and forth vs. the C code shoveling the data.
06:14:38 <mux> flux: I never looked at the uhci/ohci/ehci drivers code, so can't tell for that one
06:15:10 <wli> Anyway, drivers are the latrine of every kernel. Some kernels merely have better janitorial staff or fewer mess-makers than others.
06:15:12 <mux> as always there are quirks to deal with, for sure
06:15:37 <quicksilver> I only ever did one brief piece of driver hacking
06:15:37 <yitz> mux: maybe there is boilerplate so that if you need a driver for an existing kind of device it is easy.
06:15:47 <quicksilver> I hacked the ethernet driver for the LCIII
06:15:53 <quicksilver> by single-stepping the mac ROM in macsbug
06:16:06 <quicksilver> to find out the missing command from the *BSD driver
06:16:10 <quicksilver> was the blind leading the blind, but it worked
06:16:34 <wli> There is a lot of boilerplate out there. A lot of the problems are trying to minimize the code duplication while still handling the special cases.
06:17:08 <mauke> wli: why are you +o?
06:17:15 <wli> Erroneously unduplicating subtly different code leads to bugs.
06:17:18 <wli> mauke: No idea.
06:17:19 <fasta> He hacked the channel ;)
06:17:21 <mux> if you want y our drivers not to be a mess, there is a huge need on frameworks
06:17:24 --- mode: wli set -o wli
06:17:38 <mux> Linux guys tend to recode the whole 802.11* spec with every driver for instance
06:17:53 <allbery_b> leftover from the op hunt over the weekend
06:17:56 <wli> mux: A lot of that comes from third parties.
06:17:58 <mux> you cannot have clean, small and portable drivers without many, many abstraction frameworks
06:18:04 <allbery_b> when somebotty thingum invaded the channel
06:18:33 <mux> resources (PIO, MEMIO) abstraction, IRQ handling abstraction, DMA abstraction, etc
06:18:54 <mux> oh, attachment abstraction too
06:18:59 <rabbit64> ahh, what the hell is T transformation?
06:19:20 <mux> you want to reuse the driver for when it's over PCI and when it's over, SBUS - who knows
06:19:29 <fasta> rabbit64: transformer
06:20:07 <rabbit64> it's a function?
06:20:24 <fasta> rabbit64: more context
06:20:44 <fasta> rabbit64: The T in StateT, WriterT means transformer etc
06:21:15 <rabbit64> I want to eliminate abstraction, so I can use identity and constant (i don't know what it is called), and there was also mentioned that t-thing
06:21:30 <fasta> rabbit64: const
06:21:37 <mauke> I K
06:21:42 <Saizan_> S?
06:21:59 <rabbit64> T= I K o_O
06:22:08 <mauke> what?
06:22:13 <Saizan_> ?type id const
06:22:15 <lambdabot> forall a b. a -> b -> a
06:22:16 <mauke> I K is K
06:22:29 <mauke> ?type const id ap ap
06:22:30 <lambdabot>     Ambiguous type variable `m' in the constraint:
06:22:30 <lambdabot>       `Monad m' arising from use of `ap' at <interactive>:1:9-10
06:22:30 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:22:33 <rabbit64> and what is T?
06:22:57 <fasta> Uhm, how can you with just one MVar run 6 processes concurrently? It seems an mvar has only two states: full or empty.
06:23:05 <rabbit64> in wikipedia: T[ ] transformation
06:23:10 <fasta> I would think that you need a list of them (i.e. 6)
06:23:23 <quicksilver> depends what kind of coordination you want
06:23:23 <fasta> Or you need a QSemN
06:23:26 <quicksilver> if you just have jobs
06:23:30 <quicksilver> and you don't care who does which one
06:23:32 <mauke> http://en.wikipedia.org/wiki/Combinatory_logic#Explanation_of_the_T.5B.C2.A0.5D_transformation
06:23:34 <lambdabot> http://tinyurl.com/y47ol7
06:23:36 <quicksilver> then you can just have an MVar Job
06:23:42 <quicksilver> and whoever takes it first, gets it
06:23:52 <quicksilver> the other processes block for the next job
06:23:58 <fasta> quicksilver: yes, but I want them to run at the same time.
06:24:02 <quicksilver> they will
06:24:05 <quicksilver> have one MVar Job
06:24:08 <quicksilver> stick 6 jobs into it
06:24:17 <quicksilver> and have the 6 processes taking jobs out of it
06:24:23 <mauke>  a transformation, T[ ], which converts an arbitrary lambda term into an equivalent combinator.
06:24:36 <quicksilver> each process will take whatever job is waiting when it wants one
06:25:22 <fasta> quicksilver: I suppose you don't mean newMVar 6, right?
06:25:37 <quicksilver> fasta: no
06:25:44 <quicksilver> fasta: I mean, you have 1 MVar
06:25:54 <fasta> quicksilver: the jobs are just IO actions, I really don't see what you mean.
06:25:55 <quicksilver> you call some number of times (more than 6, I guess) putMVar
06:26:03 <quicksilver> which puts 'job descriptors' into it
06:26:14 <quicksilver> each client thread tries to 'takeMVar' from this MVar
06:26:18 <quicksilver> when it gets a job
06:26:22 <quicksilver> it goes away and does it
06:26:48 <rabbit64> I think will commit suicide on that haskell exam :/
06:27:01 <fasta> quicksilver: so, putMVar 1 >> putMVar 2 is different from putMVar 2?
06:27:07 <quicksilver> oh yes
06:27:09 <quicksilver> very very different
06:27:14 <quicksilver> the second put blocks
06:27:18 <quicksilver> until the MVar is empty again
06:27:32 <quicksilver> (which hopefully is almost instant, since hopefully a client thread is currently blocked on take)
06:27:59 <fasta> quicksilver: no, that was a wrong example.
06:28:14 <quicksilver> ok, what is a right example?
06:31:26 <wli> fasta: What are you trying to do?
06:31:43 <fasta> wli: I just want to run only 6 mplayer processes at the same time.
06:31:56 <fasta> wli: and when one is done the next one should take over
06:32:04 <mauke> does it have to be in haskell?
06:32:34 <fasta> mauke: yes, because I want to learn something from it
06:33:17 <mauke> you'll probably learn that haskell's support for unix is very bad
06:33:26 <nominolo> @unmtl StateT
06:33:27 <lambdabot> err: No applications
06:33:32 <nominolo> @unmtl StateT s m
06:33:32 <lambdabot> err: Unknown MTL(1)
06:33:37 <nominolo> @unmtl StateT s m a
06:33:37 <lambdabot> s -> m (a, s)
06:34:06 <fasta> mauke: I use runCommand which seems to work acceptable.
06:34:19 <fasta> mauke: but Perl is probably much better
06:34:26 <mauke> http://search.cpan.org/~dlux/Parallel-ForkManager-0.7.5/ForkManager.pm
06:34:30 <lambdabot> Title: Parallel::ForkManager - A simple parallel processing fork manager - search.cpan. ..., http://tinyurl.com/y9nosr
06:34:48 <quicksilver> fasta: you want to run these processes with different parameters, I gues?
06:34:56 <wli> fasta: QSemN seems about right.
06:35:05 <mauke> @index runCommand
06:35:06 <lambdabot> System.Process
06:35:09 <quicksilver> fasta: I would have an MVar [String]
06:35:16 <quicksilver> which contains the parameters
06:35:16 <fasta> quicksilver: it's just a list of IO actions.
06:35:33 <quicksilver> you can have an MVar [IO ()] if you prefer
06:35:39 <quicksilver> and then fork 6 proceess
06:35:53 <quicksilver> each process does: (x:xs) <- takeMVar mv
06:35:54 <fasta> quicksilver: and then wait for them all to complete and fork 6 new processes?
06:36:00 <quicksilver> no
06:36:04 <quicksilver> putMvar xs
06:36:05 <quicksilver> run x
06:36:13 <quicksilver> (and then loop)
06:36:23 <quicksilver> so each one pulls the next action off the top of the list
06:36:28 <quicksilver> and removes it from the list
06:36:41 <quicksilver> then you just prepopulate than MVar with the correct list of actions
06:36:44 <quicksilver> simple enough
06:36:48 <mauke> heh. one thread per child
06:37:17 <quicksilver> I don't believe you need QSemN
06:37:22 <fasta> quicksilver: I am sorry, I don't see how you maintain the 6.
06:37:30 <quicksilver> fasta: you fork 6. They stay running forever
06:37:38 <quicksilver> (well I suppose they stop if the list is empty, perhaps)
06:37:59 <quicksilver> each of the six is in a private runloop: "take job; run joop; repeat;"
06:38:15 <arossato> is there a way to build ghc-extralibs automatically or do I have to build each of them manually?
06:38:21 <wli> fasta: 6 workers. One shared mutable/locked worklist of actions to execute.
06:38:22 <fasta> quicksilver: ok, _now_ I see what you mean
06:38:37 <quicksilver> runLoop mv = do { (x:xs) <- takeMVar mv; putMVar mv xs; x; runLoop mv}
06:38:38 <fasta> My idea would be to have N workers
06:38:49 <quicksilver> this assumes that the mvar is MVar [IO ()]
06:38:57 <fasta> Which is a less optimal idea, I guess.
06:39:00 <quicksilver> yes, that's right. N workers.
06:39:03 <quicksilver> N runLoops
06:39:14 <quicksilver> forM_ [1..6] (forkIO $ runLoop mv)
06:39:45 <mauke> ooh, autodeath on empty list
06:40:58 <quicksilver> yup
06:41:01 <quicksilver> maybe it's an empty list
06:41:06 <quicksilver> erm
06:41:08 <quicksilver> maybe it's infiinte
06:41:15 <quicksilver> I'm not 100% sure what fasta means it to be :)
06:41:17 <wli> let mv = MVar ... in do { n <- read <$> getArgs ; forM_ [1..n] (forkIO $ runLoop mv) }
06:41:35 <mauke> if you want a dynamic work list, a Chan would be better, right?
06:41:50 <wli> I'd expect so.
06:42:57 <fasta> quicksilver: it's a finite list
06:43:10 <quicksilver> fasta: well my version just throws an exception in the subthreads when the list emptys
06:43:13 <quicksilver> fasta: which is kind-of OK
06:43:16 <quicksilver> if a bit clumsy
06:43:22 <quicksilver> it kills the subthreads at least :)
06:43:23 <fasta> quicksilver: I adapted it to do nothing
06:43:33 <fasta> quicksilver: in that case
06:43:47 <mauke> I don't think it's clumsy
06:43:49 <fasta> What do you mean by dynamic work list? One, where the threads themselves can add too?
06:43:51 <exDM69> @pl \x -> (/=) x . f x
06:43:51 <lambdabot> liftM2 (.) (/=) f
06:43:54 <quicksilver> mauke: Chan's not great for communicating between multiple subprocesses
06:43:59 <mauke> fasta: yes
06:44:03 <mauke> quicksilver: why?
06:44:04 <quicksilver> mauke: at least, I've never used it that way
06:44:30 <mauke> what else is it good for?
06:44:43 <fasta> And add what? Workers or tasks?
06:44:46 <fasta> I assume tasks
06:44:59 * wli is clueless as to what a TVar is.
06:45:21 <mauke> wli: an IORef in STM
06:45:29 <fasta> wli: AFAIK, it's an STRef, but faster on concurrent hardware.
06:46:09 <mauke> wtf
06:46:13 <wli> So basically an STRef with some sort of semantics wrt. concurrency?
06:46:14 <mauke> what happened to the STM docs?
06:46:25 <fasta> mauke: were they every documented?
06:46:31 <fasta> wli: yes
06:46:41 <mauke> fasta: yes
06:46:47 <fasta> mauke: ever*
06:47:02 <wli> fasta: Is the atomicity any coarser-grained than readTVar/writeTVar being atomic?
06:47:16 <fasta> wli: I don't know.
06:47:25 <fasta> I still live in a single-threaded world.
06:47:46 <exDM69> is there a not operator in haskell? as in C's !x
06:47:58 <mauke> http://haskell.org/ghc/docs/6.6.1/html/libraries/base/GHC-Conc.html#t%3ASTM
06:48:00 <lambdabot> http://tinyurl.com/2xe3ca
06:48:01 <fasta> exDM69: no, operator, but we have not
06:48:02 <mauke> exDM69: yes
06:48:23 <mauke> wli: yes
06:48:32 <mauke> wli: STM means you can have arbitrary atomicity
06:48:42 <quicksilver> mauke: I've only ever used a Chan for the case where each thread wnats every message
06:48:52 <wli> mauke: atomically?
06:48:53 <quicksilver> mauke: not where each message is to go to (at most) one thread
06:48:58 <quicksilver> mauke: but yes, I think it will work
06:49:05 <quicksilver> mauke: Chan is not very well documented :)
06:49:09 <mauke> quicksilver: wouldn't you have to duplicate the Chan in each thread for that?
06:49:11 <mux> Chan's are needed when you want queueing
06:49:12 <quicksilver> mauke: yes
06:49:19 <mux> aren't they?
06:49:28 <mauke> wli: hmm?
06:49:30 <quicksilver> mux: when you need more sophisticated queueing than simply blocking on put, yes
06:49:34 * mux nods
06:49:39 <quicksilver> mux: blocking on put it s a nice simple queueing appraoch :)
06:49:44 <mux> indeed :-)
06:50:26 <quicksilver> ooh, the new docs don't have source links either :(
06:50:30 <quicksilver> sadness
06:50:36 <quicksilver> @docs Control.Concurrent.Chan
06:50:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
06:50:45 <quicksilver> @source Control.Concurrent.Chan
06:50:45 <lambdabot> http://darcs.haskell.org/packages/base/Control/Concurrent/Chan.hs
06:50:53 <wli> mauke: Looks like I can deal with it.
06:52:07 <mauke> a recent insight of mine: you don't need "atomically" to get atomicity. every STM action is atomic.
06:52:23 <mauke> ooh, I can catch exceptions in STM!
06:52:39 <wli> mauke: Is there a primitive for taking a sequence of STM monadic values to a new STM monadic value that is itself atomic?
06:53:04 <mauke> wli: yes, "sequence"
06:53:13 <mauke> or what do you mean?
06:53:37 <wli> mauke: Like sequence, but guaranteeing they're all done as a single unit.
06:53:51 <wli> mauke: If sequence makes that guarantee, then I'm done.
06:54:14 <mauke> STM makes that guarantee
06:54:27 <mauke> implicitly
06:54:42 <mauke> the only way to actually execute STM is to convert it to IO, which is done by "atomically"
06:55:12 <raxas> forkIO plays nicely with multicores, right?
06:55:14 <mauke> which guarantees that the resulting IO action is done atomically WRT other STM threads/actions
06:55:40 <wli> mauke: So to "break up" into regions where atomicity is needed, one uses atomically to extract from the STM monad?
06:56:54 <mauke> yes
06:57:03 <wli> Okay, that's all pretty obvious, then.
06:57:04 <quicksilver> raxas: yes
06:57:26 <quicksilver> raxas: forkIO is lightweight threading, but if your RTS is threaded, it will schedule threads on as many cores as you ask it to.
06:58:03 <wli> Compile with -threaded, then use +RTS -N 16 if you've got 16 cores.
06:58:58 <wli> The ghc RTS does M:N threading, forkIO is a user thread, the RTS cmdline options control the number of kernel threads.
06:59:16 <xsakalik> Hi. Why this is wrong?: (2+) . 3
06:59:28 <mauke> xsakalik: because 3 is not a function
06:59:55 <xsakalik> Isn't it null function? It takes nothing and returns 3
07:00:04 <sioraiocht> has anyone gotten ghci 6.8 working on leopard yet?
07:00:11 <mauke> only if you define an appropriate Num instance
07:00:24 <mauke> which is kind of sucky because Num requires Show and Eq
07:00:51 <wli> ... which is yet another lame thing about the numeric hierarchy.
07:01:04 <SimeonK> are you guys mostly students?
07:01:07 <xsakalik> I thought that everything is function in haskell
07:01:27 <wli> SimeonK: No. I'm a Linux kernel programmer.
07:02:24 <SimeonK> nice
07:03:01 <rabbit64> and what about this: let f = 3 in (2+) . f ?
07:03:11 <mauke> rabbit64: same problem
07:03:21 <wli> let f _ = 3 in (2+) . f
07:03:23 <mauke> unless you make a -> b an instance of Num, that won't work
07:03:43 <rabbit64> that is totally retarded
07:03:53 <rabbit64> i don't understand... f is not a function?
07:04:01 <wli> instance Num t => instance Num (s -> t) where { fromInteger n = const n ; ... }
07:04:49 <mauke> rabbit64: 3 is not a function (by default)
07:05:01 <mauke> wli: generalize it to Applicative :-)
07:05:22 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
07:05:26 <Philippa_> rabbit64: let just defines values
07:05:28 <rabbit64> mauke, but if i define, f to return 3 f = 3 (btw f _ =  3 won't work either)...that is a gunction
07:05:43 <Philippa_> if you write f _ = ..., then f's a function because it takes a parameter (the _ pattern)
07:05:49 <mauke> rabbit64: f = 3 is not a function
07:05:55 <mauke> you're just setting f to 3
07:06:12 <Philippa_> yeah. For that matter, let f _ = 3 is sugar for let f = \_ -> 3
07:06:34 <Cale> rabbit64: You can think of non-function values as nullary functions if you want, but usually we only call things functions when their top-level type constructor is (->)
07:06:36 <Philippa_> let doesn't care whether a value's a function or not, it just binds stuff
07:07:06 <Philippa_> in fact, formally it's only a function when the top-level type constructor's -> - any other notion of function isn't haskell's
07:08:03 <rabbit64> hmm, i think i understand, but it's weird, because i thought that point of haskell was to transform everything to function, even a simple value...whatever
07:08:45 <Philippa_> no, it's not. The point is that functions are the only way to "do things"
07:09:30 <Philippa_> you can have a functional language where all values are described by functions if you want, but it doesn't gain you anything - in fact it loses you things, because it's harder to tell what's "just a value"
07:10:25 <Philippa_> when we say haskell's "purely functional" we don't mean it in the same sense as "purely OO", but that all the functions are "purely functions" - just maps from input to output with no side-effects
07:10:25 <rabbit64> Interesting
07:12:07 <fasta> It is rather odd that runhaskell and ghci don't do the same things.
07:12:27 <fasta> runhaskell File.hs just returns without any output while ghci gives tons of output.
07:12:31 <Philippa_> not really. runhaskell isn't supposed to be an 'interactive environment', it's just supposed to run the damn file
07:12:48 <fasta> If I do putStrLn, it should putStrLn
07:12:51 <fasta> It doesn't.
07:13:18 <Philippa_> funny, it did just now when I tried it
07:16:00 * wli has a tough enough time building matrices from a bunch of equations. I'll punt on all this.
07:17:33 <rabbit64> btw...I've got a little problem. I dont want to be annoying...but I will be, I have asked it some time ago: How to eliminate this lambda abstraction: \ x y -> (div) x (2^y) this *manually*...step-by-step, I have read that stupid wikipedia article (or too wise ;) ), but i couldn't find any damned example of the elimination technique
07:18:23 <mauke> T[ \x -> \y -> div x ((^) 2 y) ]
07:18:37 <SimeonK> functional programming ftw
07:18:40 <wli> Start with the variable in the inner lambda.
07:18:49 <SimeonK> I am learning for thrusday's test and I am beginning to like it
07:19:04 <wli> Try to move the variable to the right.
07:19:09 <rabbit64> I am learning for the friday's test and I am beginning to hate it :P
07:19:13 <mauke> T[ \x -> T[\y -> div x ((^) 2 y)] ]
07:19:33 <rabbit64> which variable y?
07:19:46 <wli> x `div` (2^y) = div x (2^y) = (div x . (2^))
07:19:56 <wli> = (div x . (2^)) y rather
07:19:56 <quicksilver> rabbit64: first step is to understand that "div x (2^y)" is the same as "(div x . (2^)) y"
07:20:04 <SimeonK> rabbit64, what school do you attend? :)
07:20:08 <rabbit64> (div x) is function
07:20:15 <quicksilver> rabbit64: once you understand that translation, you can strip of the y
07:20:16 <rabbit64> SimeonK: masaryk university in brno
07:20:19 <SimeonK> :)
07:20:22 <mauke> T[ \x -> S T[\y -> div x] T[\y -> (^) 2 y] ]  (rule 6)
07:20:32 <wli> eta reduce to \x -> div x . (2^)
07:20:36 <SimeonK> rabbit64...so we have something in common :D
07:20:40 <rabbit64> lol
07:20:46 <SimeonK> what's your UCO?
07:20:52 <rabbit64> 256725, you?
07:20:56 <SimeonK> 256394
07:21:12 <Philippa_> rabbit64: yep, (div x) is equivalent to \y -> (div x y)
07:21:17 <SimeonK> hey, I know you :D
07:21:22 <wli> div x . (2^) = (.) (div x) (2^) = (flip (.)) (2^) (div x) = ((flip (.)) (2^) . div) x
07:21:25 <mauke> T[ \x -> S (K T[div x]) S T[\y -> (^) 2] T[\y -> y] ]  (rule 3, rule 6)
07:21:30 <SimeonK> you had the first english seminary with me
07:21:43 <rabbit64> lol i too
07:21:51 <rabbit64> i saw you couple of times
07:22:11 <SimeonK> yeah...I often roam the chambers of FI
07:22:28 <rabbit64> as for everyone helping me with the elimination...i think i'm starting to understand it thaaanks! \o/
07:22:47 <mauke> T[ \x -> S (K (div x)) S (K ((^) 2) I ] (rule 2, 1, 3, 4)
07:22:53 <quicksilver> when you're doing it by hand, the mistake I make most often its stripping the wrong variable
07:23:21 <quicksilver> mauke: what's "flip" in SKI?
07:23:24 <rabbit64> I am starting to roam the library
07:23:31 <mauke> er, wait
07:23:59 <mauke> flip = T[\f x y -> f y x] = T[\f -> \x -> \y -> (f y) x]
07:24:18 <rabbit64> SimeonK: you are in muni pc room?
07:24:34 <SimeonK> nope
07:24:36 <SimeonK> my dorm
07:25:17 <mauke> = T[\f -> T[\x -> T[\y -> (f y) x]]] = T[\f -> T[\x -> S T[\y -> f y] T[x]]]
07:26:19 <mauke> = T[\f -> T[\x -> S (S T[\y -> f] T[\y -> y]) x]]
07:27:19 <mauke> = T[\f -> T[\x -> S (S (K f) I) x]] = T[\f -> S T[\x -> S (S (K f) I)] T[\x -> x]]
07:29:01 <mauke> = T[\f -> S (K (S (S (K f) I))) I] = S T[\f -> S (K (S (S (K f) I)))] T[\f -> I]
07:31:12 <mauke> = S (S T[\f -> S] T[\f -> K (S (S (K f) I))]) (K I) = S (S (K S) (S (K K) T[\f -> S (S (K f) I)])) (K I)
07:32:13 <mauke> = S (S (K S) (S (K K) (S (K S) T[\f -> S (K f) I]))) (K I)
07:32:50 <rabbit64> If I eliminate abstraction, I try to move the variables to the right side of the definition. But when it's on the right side, for example: fn ..(^) ... y))), I can't just put it out, can I?
07:32:57 <mauke> = S (S (K S) (S (K K) (S (K S) (S T[\f -> S (K f)] (K I))))) (K I)
07:33:27 <mux> aieee
07:33:29 * mux covers eyes
07:33:35 <quicksilver> mauke: blah. Nasteier than I expected
07:34:05 <mauke> = S (S (K S) (S (K K) (S (K S) (S (S (K S) T[\f -> K f]) (K I))))) (K I)
07:34:55 <mauke> = S (S (K S) (S (K K) (S (K S) (S (S (K S) (S (K K) I)) (K I))))) (K I)
07:35:45 <fasta> Philippa_: more complicated program, of course.
07:35:50 <mauke> :t ap (ap (const ap) (ap (const const) (ap (const ap) (ap (ap (const ap) (ap (const const) id)) (const id))))) (const id)
07:35:52 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
07:35:58 <rabbit64> that thing is supposed to be flip O_O?
07:36:05 <mauke> hmm. that's not right
07:36:24 <mauke> needs more pen&paper
07:37:21 <mauke> rabbit64: anyway, can you see how I tried to apply the rules from wikipedia? :-)
07:37:21 <Saizan_> rabbit64: you can remove it from the inner lambda
07:39:31 <twb> Is Graphics.Vty the popular way to implement a TUI?
07:39:42 <twb> If so, is there a tutorial using it?
07:40:50 <hpaste>  fasta pasted "Self-contained program to dowload webcasts" at http://hpaste.org/3669
07:41:10 <fasta> Philippa_: try and see whether that does the same.
07:42:06 <fasta> When I run that in ghci, mplayer seems to be getting executed, when I do ghc --make <foo.hs> or do runhaskell <foo.hs> nothing happens.
07:44:27 <quicksilver> fasta: probably you need to compile with -threaded
07:44:34 <quicksilver> fasta: ghci uses the threaded RTS by default
07:45:13 <fasta> quicksilver: can I use fail btw in the IO monad just like in runMaybeT?
07:45:29 <quicksilver> if you use fail in the IO monad you get an exception
07:45:30 <fasta> quicksilver: (without getting an exception)
07:46:19 <fasta> quicksilver: well, in that case I don't think the code can be much better than it is, other than generalizing it in the way to get the URIs.
07:46:21 <quicksilver> no, an exception is the sematnics of fail in IO
07:46:34 <quicksilver> the code loks fine to me
07:47:02 <quicksilver> except, as I say, I think you need to compile with -threaded
07:47:17 <quicksilver> I often defined 'whenJust' for the case foo of Just bar -> ideiom
07:47:18 <fasta> quicksilver: ghc --make -threaded DownloadWebcasts.hs
07:47:33 <fasta> quicksilver: that doesn't work
07:47:41 <quicksilver> "doesn't work?"
07:47:48 <quicksilver> gives and eorr? compiles but doesn't work?
07:47:55 <fasta> quicksilver: it compiles, but when I run I get zero results
07:48:22 <fasta> quicksilver: by zero results, I mean that it returns the empty string
07:48:29 <quicksilver> ghc -threaded --make
07:48:30 <quicksilver> ?
07:48:34 <quicksilver> not sure if order matters
07:48:50 <fasta> quicksilver: that's the same
07:50:09 <mux> ah yeah, whenJust is highly needed
07:50:24 <mux> haskell standard libraries could do with a few more functions here and there
07:51:13 <fasta> The same for Either, I guess.
07:51:51 <fasta> quicksilver: do you have another suggestion?
07:52:09 <fasta> quicksilver: you can run it on your own system if you make that directory.
07:55:11 <mauke> :t ap (ap (const ap) (ap (const const) (ap (const ap) (ap (ap (const ap) (ap (const const) id)) (const id))))) (const (ap (const const) id))
07:55:13 <lambdabot> forall b b1 b2. (b1 -> b2 -> b) -> b2 -> b1 -> b
07:55:18 <mauke> I'm doing it right!
07:55:37 <mauke> quicksilver: flip = S (S (K S) (S (K K) (S (K S) (S (S (K S) (S (K K) I)) (K I))))) (K (S (K K) I))
07:55:50 <Taejo> @pl \x -> p1 x || p2 x
07:55:50 <lambdabot> liftM2 (||) p1 p2
07:56:02 <rabbit64> btw this: (flip (.) (2^) . div), how to simplify it?
07:56:04 <Taejo> what instance of monad is that using?
07:56:20 <mauke> Taejo: (->) e
07:56:40 <Taejo> mauke, where is that instance defined?
07:56:58 <mauke> in Control.Monad.Instances and (for older ghcs) Control.Monad.Reader
07:57:22 <fasta> mauke: do you have an idea of why GHC doesn't run the code?
07:57:32 <byorgey> rabbit64: how about \x y -> 2^(x `div` y) ?
07:57:34 <Taejo> thanks
07:57:53 <rabbit64> byorgey, the problem is that i dont want lambda abstraction there
07:57:53 <quicksilver> :t let {S=ap;K=const;I=id} in S (S (K S) (S (K K) (S (K S) (S (S (K S) (S (K K) I)) (K I))))) (K (S (K K) I))
07:57:54 <lambdabot> Not in scope: data constructor `S'
07:57:54 <lambdabot> Not in scope: data constructor `K'
07:57:54 <lambdabot> Not in scope: data constructor `I'
07:57:57 <byorgey> rabbit64: points-free doesn't necessarily mean 'simpler'
07:57:58 <quicksilver> doh
07:58:00 <byorgey> rabbit64: why not?
07:58:31 <rabbit64> byorgey: i just eliminated abstractions...so i don't want them back :)
07:58:54 <mauke> fasta: no
07:58:56 <byorgey> rabbit64: but why? lambda abstractions won't give you leprosy or anything.
07:58:59 <quicksilver>  :t let {s=ap;k=const;i=id} in s (s (k s) (s (k k) (s (k s) (s (s (k s) (s (k k) i)) (k i))))) (k (s (k k) i))
07:59:03 <quicksilver> :t let {s=ap;k=const;i=id} in s (s (k s) (s (k k) (s (k s) (s (s (k s) (s (k k) i)) (k i))))) (k (s (k k) i))
07:59:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1 -> b
07:59:05 <lambdabot>     Probable cause: `k' is applied to too few arguments
07:59:05 <lambdabot>     In the second argument of `s', namely `(k i)'
07:59:12 <rabbit64> byorgey, i have an exam, so i need to know it
07:59:21 <rabbit64> (i will have)
07:59:49 <byorgey> rabbit64: ok, well, flip (.) (^2) is the same as (. (^2))
08:00:04 <byorgey> so, (. (^2)) . div
08:00:18 <mauke> byorgey: that makes it more complicated, not simpler
08:00:24 <rabbit64> this: flip (.) (2^) . div is not flip (.) (.) (2^) (div) ?
08:00:31 <byorgey> mauke: that's what I said, but rabbit64 insisted =)
08:00:47 <rabbit64> it's all my fault ;)
08:00:52 <mauke> rabbit64: it's (.) (flip (.) (2^)) div
08:01:08 <mauke> byorgey: no, you wanted to add lambdas, which makes it even more complicated
08:01:31 <rabbit64> moment, . has bigger priority than function application?
08:01:36 <matthew-_> @where yaht
08:01:36 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
08:01:56 <byorgey> mauke: huh?  I guess it depends what your definition of 'simple' is.
08:01:56 <mauke> rabbit64: no, function application binds tighter than any operator
08:01:59 <fasta> rabbit64: . is a function
08:02:04 <mauke> byorgey: closer to SKI
08:02:46 <byorgey> mauke: fair enough, you mean 'theoretically simple' while I meant 'simpler to understand'.
08:02:47 <exDM69> @pl (\x y -> x + f y)
08:02:47 <lambdabot> (. f) . (+)
08:03:23 <fasta> Well, I guess I just have to run it in ghci, then.
08:03:51 <fasta> So much more "fantastic concurrency".
08:03:57 <fasta> er for
08:06:19 <rabbit64> soo flip (.) (2^) . div is (flip (.) (2^)) . div! uff
08:08:05 <mauke> :t ap (ap (const ap) (ap (const const) (ap (const div) id))) (const (ap (const ((^) 2)) id))
08:08:13 <lambdabot> forall b b1. (Integral b1, Integral b) => b -> b1 -> b
08:08:56 <mauke> @unpl ap (ap (const ap) (ap (const const) (ap (const div) id))) (const (ap (const ((^) 2)) id))
08:08:56 <lambdabot> (((\ _ x y -> x >>= \ v -> y >>= \ u -> return (v u)) >>= \ p -> ((\ _ c _ -> c) >>= \ ab -> ((\ _ -> div) >>= \ ah -> (\ e -> e) >>= \ ag -> return (ah ag)) >>= \ aa -> return (ab aa)) >>= \ o ->
08:08:57 <lambdabot> return (p o)) >>= \ j -> (\ _ -> (\ _ -> (^) 2) >>= \ an -> (\ h -> h) >>= \ am -> return (an am)) >>= \ i -> return (j i))
08:10:08 <idnar> ouch
08:10:23 <mauke> this is not enough broccolis
08:11:37 <wli> Variable nomenclature kind of blows.
08:12:05 <sethk> 'morning, all.  I'm building 6.8.1, and it wants happy, so I downloaded happy.  Can someone either give me the three line install procedure (I've forgotten how one uses Setup.lhs) or point me at a URL on how to do it?
08:12:21 <dikini> where can I see the rationale behind Maybe deriving from Eq and Ord?
08:13:23 <Saizan_> sethk: runghc Setup configure, runghc Setup build, runghc Setup install
08:13:36 <mauke> dikini: it makes sense?
08:13:40 <sethk> Saizan_, thanks.  I'll write it down this time.  :)
08:13:46 <dikini> :)
08:13:57 <Philippa_> dikini: it doesn't constrain uses of Maybe, but an Eq instance is trivial and there's an obvious ordering on Maybe
08:14:07 <Philippa_> namely the "information content" ordering
08:14:30 <dikini> Nothing < Just ?
08:14:33 <SimeonK> this world is a vector space of basis = {(1,0,0),(0,1,0),(0,0,1)}
08:14:33 <Philippa_> right
08:14:48 <Philippa_> and then to compare Justs, punt to the Eq instance for the parameter
08:15:06 <dikini> ok, I grok that, I think
08:16:58 <rabbit64> why is ((^3) . (^2)) 5 not equal to (^3) . (^2) 5, and how works priority in infix ... i thought that (^3) . (^2) 5 is (.) (^3) (^2) 5
08:17:34 <mauke> it isn't
08:17:43 <mauke> <mauke> function application binds tighter than any operator
08:17:59 <mauke> x . y z is (x . (y z))
08:18:17 <SimeonK> (^3) . (^2) 5 doesn't even work
08:18:19 <sethk> Saizan_, I'm getting "Could not find module `Distribution.Simple.Program'.  Does that mean cabal is not installed?
08:18:49 <rabbit64> i see
08:18:50 <fasta> sethk: it's easiest to first install the cabal-install package.
08:19:16 <sethk> fasta, OK, I'll look for it (on the ghc web page, I presume)
08:19:28 <fasta> sethk: no
08:19:31 <fasta> sethk: hackage
08:19:38 <sethk> fasta, ah, ok, thanks.
08:19:43 <fasta> sethk: in the same package list
08:19:52 <fasta> sethk: it's not perfect yet, but it's somewhat easier
08:20:06 <doserj> however, cabal-install requires to install HTTP, and zlib... and zlib requires a new Cabal...
08:20:38 <ndm> doserj, but does cabal-install work?
08:20:53 <doserj> i'm still building it :)
08:21:08 <ndm> i think the traditional answer is "no, want to volunteer?"
08:21:23 <fasta> ndm: it does now
08:21:33 <raxas> > ((^3) . (^2)) 5
08:21:38 <lambdabot>  15625
08:21:41 <sethk> doserj, At the moment I'm building ghc 6.8.1; does it (or not) make more sense to try cabal-install after I get the newest compiler installed?
08:21:49 <b_jonas> hi
08:21:56 <Igloo> I wasn't paying much attention, but weren't people saying cabal-install doesn't work with GHC 6.8.1?
08:22:12 <fasta> Igloo: I tested it with 6.9
08:22:28 <sethk> hmm., sounds like perhaps not the way to go to install 6.8.1.  :)
08:23:42 <sethk> oklopol, now I'm even further confused (if that's possible).  the cabal site says ghc 65.6.1 includes cabal 1.1.6.2, and I have ghc 6.6.1 installed
08:23:54 <sethk> so perhaps the error didn't mean what I thought it meant.
08:24:00 <doserj> ndm: I run into the "dist/Conftest.c: openFile: does not exist" problem :)
08:24:45 <rabbit64> what does this mean? (+) (+3)
08:25:02 <mauke> it means (+) applied to (+3)
08:25:11 <wli> Throwing exceptions for file open failures is nasty.
08:25:28 <sethk> the error is (running "runghc Setup configure" for happy 1.17)  Setup.lhs:9:7:
08:25:28 <sethk>     Could not find module `Distribution.Simple.Program':
08:25:34 <mauke> and it requires (+3) to be a number
08:25:49 <rabbit64> so why it doesn't throw error
08:25:58 <rabbit64> +3 is function
08:26:09 <mauke> > (+) (+3)
08:26:10 <lambdabot>   add an instance declaration for (Num (a -> a))
08:26:10 <lambdabot>     In the expression: (+) (...
08:26:17 <mauke> looks like an error to me
08:26:51 <rabbit64> ah yes, i'm stupid
08:27:12 <b_jonas> is there a library for multi-dimensional immutable arrays that can be partially subscripted fast?
08:27:29 <wli> Multidimensional arrays are handled by arrays on tuples.
08:27:36 <fasta> b_jonas: Use (1,1,1,1) as indices.
08:27:45 <doserj> "cabal update" gives a segmentation fault after downloading the package list from hackage...
08:27:47 <b_jonas> wli: I'd like arrays of arbitarily many dimensions
08:27:52 <wli> Array (Int, Int) Double -- 2D array
08:27:59 <wli> Array (Int, Int, Int) Double -- 3D array
08:28:03 <b_jonas> I could use just flattened arrays with * indexing
08:28:04 <chessguy> > ((+) (+3))
08:28:05 <lambdabot>   add an instance declaration for (Num (a -> a))
08:28:05 <lambdabot>     In the expression: ((+) ...
08:28:08 <wli> Array (Int, Int, Int, Int) Double -- 4D array
08:28:13 <b_jonas> wli: no, it's still about the interpreter
08:28:16 <wli> b_jonas: etc.
08:28:19 <doserj> "cabal list" gives an "
08:28:20 <doserj> cabal: Data.ByteString.Lazy.index: index too large: 0"
08:28:28 <fasta> doserj: report a bug if you care enough.
08:28:29 <chessguy> > ((+). (+3))
08:28:30 <lambdabot>  <Integer -> Integer -> Integer>
08:28:39 <b_jonas> which has to interpret arbitary dimension arrays
08:28:42 <fasta> doserj: that's what I did for my annoyance.
08:28:51 <rabbit64> I was wondering why is this valid: (. (^2)) and why it is flip (.) (^2), why is the dot not in prefix; braces
08:28:58 <b_jonas> that is, the dimension is computed in runtime
08:29:16 <sethk> looks like the binary 6.6.1 didn't include cabal, or perhaps required it to be explicitly enabled.
08:29:17 <wli> b_jonas: Then Array [Int] JValue I guess.
08:29:36 <mauke> rabbit64: (? x) is flip (?) x for any operator (?)
08:29:36 <b_jonas> is [] an Ix?
08:29:37 <dons> > ((+). (+3)) -- interesting defaulting there
08:29:39 <lambdabot>  <Integer -> Integer -> Integer>
08:29:46 <b_jonas> [Int] that is
08:30:11 <roconnor> b_jonas: I don't think so.
08:30:12 <chessguy> dons, i thought ghc always defaulted to Integer, when possible
08:30:17 <wli> b_jonas: You'll need to define an instance.
08:30:25 <dons> :t 1
08:30:26 <lambdabot> forall t. (Num t) => t
08:30:34 <b_jonas> you can define an Ix instance/
08:30:35 <chessguy> oh, right
08:30:38 <b_jonas> ?
08:30:40 <chessguy> hmm
08:30:41 <dons> :t ((+). (+3))
08:30:42 <lambdabot> forall a. (Num a) => a -> a -> a
08:30:54 <b_jonas> let's see
08:31:17 <ndm> Igloo: i have no objection to closing 1592
08:31:17 <b_jonas> still, will that allow me to extract a row of a matrix fast
08:31:29 <b_jonas> ?
08:31:46 <b_jonas> because that's what I mean by partial subscripting
08:31:49 <wli> b_jonas: You'll have to write an operator to do it.
08:32:15 <chessguy> dons, something in LB's rendering of a function?
08:32:19 <Igloo> ndm: thanks
08:32:32 <b_jonas> wli: but if I use a simple Array, wouldn't that mean lots of copying the rows?
08:32:38 <quicksilver> dons: something to do with typeable, I believe
08:32:39 <rabbit64> How is it called when it's written in this way: (+3) 4 prefix or infix?
08:32:59 <wli> b_jonas: Could be. There may be better representations.
08:33:13 <quicksilver> dons: when you 'typeable' something it loses its polymorphism if you're not careful.
08:33:40 <b_jonas> wli: it would be easy to have an immutable array of which you can refer to slices
08:33:40 <quicksilver> rabbit64: well the fact that (+3) comes before 4 is prefix
08:33:54 <b_jonas> but I wonder if I have to write that myself
08:33:56 <quicksilver> rabbit64: but the notation '(+3)' itself is an infix section, which is specific to haskell
08:34:09 <quicksilver> rabbit64: and not used widely outside the haskell community
08:35:04 <rabbit64> I didn't noticed what it does (3+) was equal to (+3) to me, (because + is commutative), but good to know
08:35:07 <dons> quicksilver: well, the Show instance is going to trigger defaulting now, with -fextended-defaulting
08:35:22 <dons> which apparently extends to functions -- previously that wouldn't have found a Typeable instance either
08:35:31 <rabbit64> but (+3) is shortcut of flip (+
08:35:34 <rabbit64> ) 3
08:36:41 <b_jonas> oh noes
08:36:59 <b_jonas> what others did you mention, Sequence, and what was the other/
08:37:01 <b_jonas> ?
08:37:08 <b_jonas> why can't I type "?"
08:37:22 <chessguy> apparently you can, since you just did
08:37:24 <chessguy> twice
08:38:22 <quicksilver> rabbit64: right
08:38:35 <quicksilver> rabbit64: and flip (+) 3 is conventional prefix notation
08:38:48 <quicksilver> rabbit64: (+3) 4 is at best a hybrid notation
08:39:00 <quicksilver> you won't find anything like it in most literature
08:39:11 <rabbit64> god thanks
08:39:16 <quicksilver> you might alternatively view it as a shortcut for (\x -> x+3) 4
08:39:22 <quicksilver> which uses infix :)
08:39:35 <quicksilver> or you might view it as a shortcut for (\x -> (+) x 3) 4
08:39:38 <quicksilver> which uses prefix!
08:39:44 <rabbit64> lol thx
08:40:37 <b_jonas> ah, so a Seq (in Data.Sequence) is one of these tree-based sequences with fast insertion
08:40:50 <b_jonas> I'll have to think about that one...
08:41:00 <fasta> b_jonas: "fast"
08:41:06 <quicksilver> Seq is a pretty good alternative to List
08:41:20 <jedbrown> b_jonas: I would find bindings to blitz++ or boost::multi_array very handy.
08:41:21 <quicksilver> in many cases wher eyou want something 'as convenient' as List but with better speed
08:41:28 <fasta> It's about an order of magnitude slower for a million length list.
08:41:32 <jedbrown> b_jonas: That provides the speed and sections.
08:41:33 <SimeonK> rabbit64
08:41:41 <SimeonK> what are you still doing here? >:O
08:41:51 <rabbit64> I'm waiting for lecture
08:41:51 <SimeonK> you should have already been running to the lecture
08:41:52 <exDM69> http://haskell.org/haskellwiki/Random_shuffle  <<-- the first two algorithms don't work (ghc 6.6)
08:41:53 <lambdabot> Title: Random shuffle - HaskellWiki
08:41:54 <SimeonK> ah
08:41:57 <SimeonK> you're at school
08:41:59 <quicksilver> Seq has excellent sharing properies
08:41:59 <rabbit64> i've got 15 minutes
08:42:00 <SimeonK> I forgot :O
08:42:06 <b_jonas> jedbrown: sure it does, but that's not neccessary for just sections
08:42:21 <rabbit64> It's unfortunate to live in komarov
08:42:35 <rabbit64> >=/
08:42:47 <b_jonas> it's needed if I also want fast amending (//) or fast insertion or deletion to the middle
08:42:56 <SimeonK> oh
08:43:03 <quicksilver> right
08:43:10 <fasta> How can runCommand take arguments?
08:43:16 <SimeonK> Komarov, I heard it's dangerous out there at night
08:43:17 <quicksilver> whereas arrays have pretty terrible insertion properties
08:43:19 <quicksilver> I would think
08:43:21 <jedbrown> b_jonas: Depends what you need to do.  I'm pretty new to the FFI, but considering writing the interface.
08:43:25 <b_jonas> while for just sections, I can use a proxy class which refers to a part of the array
08:43:38 <fasta> quicksilver: elaborate
08:43:47 <fasta> quicksilver: you mean the resizing?
08:43:48 <quicksilver> fasta: inserting into the middle of a long array is a copy
08:43:49 <quicksilver> yes
08:43:56 <quicksilver> inserting into the middle of a large Seq is zero-copy
08:44:00 <rabbit64> simeonk, I'm considering to stop visiting lectures at all...especially wednesday: 8:00 math, 12:00 sites, 18:00 informatics -> whole day in school
08:44:15 <b_jonas> depends on what I awnt to do, exactly.
08:44:30 <SimeonK> what's that at 12:00 ?
08:44:34 <quicksilver> fasta: runCommand uses the shell
08:44:41 <b_jonas> I definitely don't want fast insertion or deletion in the middle, and I also think I don't want fast amending
08:44:51 <quicksilver> fasta: so the shell parses arguments in the standard way; typically by the shell
08:44:53 <rabbit64> SimeonK: pc sites services, credit for free :)
08:44:58 <quicksilver> tpically by space characters
08:45:01 <SimeonK> oh
08:45:02 <rabbit64> but it's interresting
08:45:04 <SimeonK> try Online_A :)
08:45:05 <b_jonas> at least not for this, it's still good to know about it
08:45:13 <SimeonK> 2 credits for free
08:45:30 <SimeonK> ok, I'm rushing to the lecture
08:45:39 <SimeonK> Okey, D3, here I come!
08:45:39 <rabbit64> rush!
08:45:44 <rabbit64> kk
08:45:47 <rabbit64> cya
08:47:51 <b_jonas> but really, what was the other data structure you mentioned?
08:47:59 <b_jonas> oh, it was map
08:48:58 <b_jonas> that allows fast amending, but doesn't have much advantages over an array apart from that
08:49:27 <rabbit64> bye, thx for help
08:49:32 <b_jonas> there's also IntMap
08:49:39 <quicksilver> well the big difference is between functional-style structures which have sharing
08:49:48 <quicksilver> and array structures which need to copy everything
08:50:13 <quicksilver> and array structures which modify-in-place
08:50:37 <b_jonas> yep
08:50:48 <jedbrown> b_jonas: IntMap won't do multi-dimensions, whereas (Map [Int] Value) works fine.
08:51:11 <b_jonas> jedbrown: a flat Array Int also works
08:51:37 <b_jonas> you just have to map the indices to flat indices with arithmetic
08:52:13 <quicksilver> flat Array Int is pointless
08:52:22 <quicksilver> you might as well use Array (Int,Int,Int)
08:52:29 <jedbrown> b_jonas: Ah, because since your arrays are dense, you won't run out of address space.
08:52:33 <quicksilver> because then that arithmetic happens behind the scenes :)
08:52:44 <wli> b_jonas: What you probably want/need is a multidimensional tree structure like a BKD tree or an R^+ tree.
08:52:51 <quicksilver> you could use the same kind of by-hand encoding to use IntMap though
08:53:00 <quicksilver> I'd start with something simple, though
08:53:04 <quicksilver> and see how it goes
08:53:11 <quicksilver> and decided what your hard performance requirements are
08:53:24 <quicksilver> certain structures will be better for some algorithms than others
08:53:24 <b_jonas> jedbrown: exactly
08:53:29 <wli> b_jonas: They're complicated, though.
08:54:11 <Taejo> is there a way to include a module on the ghc command line?
08:54:12 <b_jonas> BKD tree or R^+ tree -- I haven't ever heared about that
08:54:19 <Taejo> like -M in perl
08:54:36 <b_jonas> I might try writing an Ix instance for [Int] though
08:54:44 <b_jonas> because that sounds nice
08:54:48 <jedbrown> Taejo: how about :m
08:55:05 <wli> b_jonas: They support n-dimensional data. Search for slices or ranges in any one of the dimensions or any combination of them is O(lg(N)) where there are N elements in the tree.
08:55:30 <b_jonas> wli: hmm
08:55:35 <b_jonas> but I don't need that
08:55:36 <Taejo> jedbrown,  on the command line? I didn't know you could do that. It isn't in the man page
08:55:37 <quicksilver> wli: A crude haskell encoding would give lousy data locality of course
08:55:41 <b_jonas> I'm still thinking of writing a J interpreter
08:55:41 <wli> b_jonas: With a bit more involved of estimates if you want all results.
08:55:54 <b_jonas> and J doesn't do such complicated operations fast
08:55:55 <quicksilver> wli: btu maybe that doesn't matter, depending how big his arrays are in practice
08:56:50 <wli> quicksilver: These things are so hard they're basically unheard of outside of projects/organizations with small armies of people to park on getting the things hammered out. They're hard to implement.
08:57:15 <jedbrown> Taejo: No, that's for ghci.  I don't know about on the command line.  If you are doing `ghc -e something' then you can just use the full name.
08:57:30 <wli> quicksilver: Kind of like integrated register allocation and instruction scheduling in compilers.
08:57:36 <Taejo> yeah, I'm doing ghc -e; I'll use the full name
08:58:45 <b_jonas> so is there a library type representing slices of Arrays?
08:58:51 <b_jonas> or slices of IArrays, rather
08:59:31 <quicksilver> wli: Yeah. If ghc gets even a *half* decent register allocation scheme it could start to perform very interestingly well on certain special case problems
08:59:42 <quicksilver> b_jonas: you could represent them as IArrays!
08:59:51 <quicksilver> b_jonas: I'm not sure if the slicing interface is built in though
09:00:06 <b_jonas> yeah, representing as IArrays would make sense
09:00:24 <b_jonas> provided IArrays can be instanced
09:00:48 <quicksilver> sure
09:00:52 <quicksilver> no law against instancing IArry
09:00:53 <b_jonas> but somehow the methods of IArray isn't documented
09:00:55 <quicksilver> just go ahead and do it :)
09:01:08 <quicksilver> b_jonas: not documented?
09:01:16 <b_jonas> look at this http://haskell.org/ghc/docs/latest/html/libraries/array-0.1.0.0/Data-Array-IArray.html
09:01:18 <lambdabot> http://tinyurl.com/yusu79
09:01:18 <quicksilver> b_jonas: what about http://haskell.org/ghc/docs/latest/html/libraries/array-0.1.0.0/Data-Array-IArray.html
09:01:19 <lambdabot> http://tinyurl.com/yusu79
09:01:22 <quicksilver> yes
09:01:27 <b_jonas> it tells about only a single method
09:01:29 <quicksilver> why do you say the methods arne't docmented?
09:01:34 <b_jonas> bounds
09:01:55 <b_jonas> is that really the only method?
09:02:08 <quicksilver> hrm
09:02:16 <b_jonas> @src IArray
09:02:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:02:19 <quicksilver> @source Data.Array.IArray
09:02:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/IArray.hs
09:02:30 <quicksilver> grrr!
09:03:30 <quicksilver> http://darcs.haskell.org/packages/array/Data/Array/IArray.hs
09:03:55 <wli> quicksilver: Are you speaking of ia32 codegen? That in particular is obscenely hard.
09:04:22 <quicksilver> hmm
09:04:41 <quicksilver> b_jonas: maybe IArry isn't designed to be instanced, yuck.
09:04:51 <wli> quicksilver: x86-64 codegen is not anywhere near as bad; the 8 additional registers help a lot.
09:05:22 <quicksilver> wli: can you use those registers even when running in "ia32 userland" ?
09:05:28 <b_jonas> quicksilver: well, I could use a different interface than
09:05:30 <quicksilver> wli: or are they locked out from you then?
09:05:39 <quicksilver> b_jonas: seems stupid to me :)
09:05:43 <wli> quicksilver: It's still really bad because nothing is remotely normal, though. No, you can't use them in ia32 userland. ia32 locks them out from you.
09:05:56 <quicksilver> b_jonas: the idea of IArry interface for strides seems so natural!
09:06:04 <quicksilver> b_jonas: not sure why they don't do it
09:06:20 <b_jonas> quicksilver: IArray is not in prelude, while Array is, which is I think why the functions like (!) and array aren't methods
09:06:34 <pejo> wli, you can't do much about the lack of registers on ia32 though, so nto really up to the compiler writer.
09:06:50 <b_jonas> it may have to do with performance reasons as well though
09:06:56 <quicksilver> b_jonas: the methods are called unsafeArray and unsafeIndex
09:07:01 <quicksilver> b_jonas: and they're hidden
09:07:03 <wli> pejo: You have to try harder, using more advanced algorithms, and so on.
09:07:06 <quicksilver> (by default, at least)
09:07:19 <pejo> wli, that would benefit a less register starved architecture too though
09:07:38 <b_jonas> um, think of how DiffArray has to be implemented, it has to know when there's no need to copy an array because there's only one reference to it
09:07:40 <mcp_> hoogle [[]]->[]
09:07:46 <b_jonas> I guess that might need some help from the compiler
09:07:46 <wli> pejo: The gains would be more marginal on less register-starved architectures.
09:07:52 <pejo> mcp, concat
09:07:57 <b_jonas> which can be a reason why (//) is not a method
09:08:02 <wli> pejo: They're vast on ia32, though.
09:08:08 <mcp_> pejo, thx
09:08:26 <Beelsebob> mcp_: also, you wanted "@hoogle [[a]] -> [a]"
09:08:32 <Beelsebob> @hoogle [[a]] -> [a]
09:08:32 <lambdabot> Prelude.concat :: [[a]] -> [a]
09:08:34 <Beelsebob> :)
09:10:52 <mcp_> is it possible to use hoogle, but not filling the channel with hoogle-spam?
09:11:01 <chessguy> @djinn [[a]] -> [a]
09:11:01 <lambdabot> -- f cannot be realized.
09:11:06 <Beelsebob>  /msg lambdabot @hoogle [[a]] -> [a]
09:11:13 <allbery_b> or haskell.org/hoogle
09:11:13 <hpaste>  exDM69 pasted "Shuffling problem" at http://hpaste.org/3670
09:11:18 <Beelsebob> or... download and install lambdabot on your own machine
09:11:32 <quicksilver> mcp_: hoogle was a web service first :)
09:11:35 <mcp_> allbery_b, great link
09:11:42 <quicksilver> mcp_: the lambdabot interface is just for convenience
09:12:29 <b_jonas> convenience... and the crazyness of irc bot lovers like me
09:12:32 <exDM69> http://hpaste.org/3670?lines=true  <<--- what's the problem here?
09:13:15 <ToRA> change to shuffle :: forall a . [a] -> IO [a]
09:13:20 <ToRA> and turn on some flag
09:13:28 <ToRA> erm
09:13:42 <ToRA> {-# LANGUAGE ScopedTypeVariables #-}
09:14:04 <ToRA> otherwise ghc doesn't realise / know that the a at the top is the same as the a in the enclosed type sig
09:14:21 <geocalc> on ghc 6.8.1 lambdabot can't compil
09:14:23 <exDM69> why is forall a needed
09:14:36 <quicksilver> to indicate that the three 'a's are all the same
09:14:49 <mauke> can't you just remove the inner type signature?
09:15:12 <quicksilver> ToRA: I thought scopedtypevars was implicitly on if you put an explicit forall?
09:15:18 <quicksilver> ToRA: is this no longer tha case?
09:15:51 <ToRA> quicksilver: it may well be
09:16:28 <mrd> you still need the language feature
09:16:52 <doserj> it doesn't parse the "forall" correctly without extenstions..
09:17:01 <ToRA> yeah, you need the flag
09:17:26 <quicksilver> ah, you're right
09:17:27 <doserj> (on my ghc, newer versions may differ...)
09:17:32 <quicksilver> you used to need glasgow-exts
09:17:42 <quicksilver> now there is a specific flag instead
09:18:11 <ToRA> exDM69: i have a version of shuffle kicking around that's not in IO if you're interested?
09:18:22 <exDM69> ToRA: I'd like to see it
09:18:55 <exDM69> I don't understand any of the shuffle algorithms in the wiki
09:18:56 <hpaste>  ToRA annotated "Shuffling problem" with "non IO shuffle" at http://hpaste.org/3670#a1
09:19:07 <ToRA> basically the same as your approach
09:19:10 <ToRA> but using ST
09:19:14 <exDM69> so I just copypasted that part and consentrate on other stuff
09:29:33 <mcp_> last time i've been here, someone mentioned i should compare to null instead of    "mylist == []". How would that actually look like?
09:29:53 <ToRA> > let mylist = [1,2,3] in null mylist
09:29:55 <lambdabot>  False
09:30:01 <mrd> @type null
09:30:02 <lambdabot> forall a. [a] -> Bool
09:30:52 <mcp_> That means:   null mylist
09:31:09 <mcp_> And it will be true, if mylist is empty, false otherwise. correct?
09:31:13 <byorgey> mcp_: right.
09:31:22 <ToRA> > null []
09:31:23 <lambdabot>  True
09:32:16 <integral> @src null
09:32:16 <lambdabot> null []     = True
09:32:17 <lambdabot> null (_:_)  = False
09:32:19 <fberthold> Hi folks, has anyone managed to build missingh with 6.8.1?
09:35:43 <mrd> mcp_: the reason btw, is that "mylist == []" introduces an unnecessary Eq constraint on the type of mylist
09:39:21 <Cale> ddarius/other people who were talking about guitar earlier, here's some more Wayne Krantz: http://uk.youtube.com/watch?v=WE4TCD4MFF4
09:39:22 <lambdabot> Title: YouTube - Wayne Krantz, Keith Carlock,Tim Lefebvre - Marciac 1999 pt 1
09:41:47 <adamjones> I have a monadic cat ... he has a toy he'll only play with inside a box.
09:43:34 <pgavin> @src enumFromTo
09:43:34 <lambdabot> Source not found. Maybe you made a typo?
09:43:51 <pgavin> @src Enum
09:43:51 <lambdabot> class  Enum a   where
09:43:51 <lambdabot>     succ                     :: a -> a
09:43:51 <lambdabot>     pred                     :: a -> a
09:43:51 <lambdabot>     toEnum                   :: Int -> a
09:43:51 <lambdabot>     fromEnum                 :: a -> Int
09:43:53 <lambdabot> [3 @more lines]
09:43:57 <pgavin> @more
09:43:58 <lambdabot>     enumFrom                 :: a -> [a]
09:43:58 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
09:43:59 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
09:44:13 <ddarius> Subtle piece of UI
09:44:14 <pgavin> @src Enum.enumFromTo
09:44:14 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:44:15 <byorgey> adamjones: maybe try an unsafeRunCat?
09:44:47 <fasta> Be sure to include a sliceCat ;)
09:46:50 <fberthold> It looks like missingh will build if you change the main function from "defaultMainWithHooks" to "defaultMain" admittedly I don't know what negative reprucussions this could have.
09:48:50 * ddarius hears a crack form in the fabric of space-time.
09:49:21 <daniel_larsson> fberthold: That sounds like a cabal issue, not missingh itself. I'm not sure what changed in cabal 1.2 so can't help much :/
09:51:27 <fberthold> daniel_larsson: I tend to agree, the group of libs surrounding missingh have the same issue.
10:05:43 <fasta> Cale: Did you take a look at the problem we discussed?
10:06:01 <Cale> The ST thing?
10:06:10 <fasta> Yes
10:07:52 <Cale> Not yet, I was out later than I expected and ended up sleeping as soon as I got back. I might have a look soon.
10:11:25 <dcoutts_> @tell doserj we'd appreciate if you could report that cabal bug you had and the circumstances to reproduce it http://hackage.haskell.org/trac/hackage/
10:11:25 <lambdabot> Consider it noted.
10:12:44 <dcoutts_> @tell doserj I expect it's a symptom of the index file not getting downloaded, check if your $HOME/.cabal/packages/hackage.haskell.org/00-index.tar.gz is empty or a valid archive
10:12:44 <lambdabot> Consider it noted.
10:17:26 <thetallguy> ?seen igloo
10:17:26 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 47m 15s ago.
10:18:36 <thetallguy> igloo: what's the state of Debian packaging for 6.8.1?  If there's stuff to do, can we help in a coordinated way?
10:20:32 <thetallguy> @tell igloo what's the state of Debian packaging for 6.8.1?  If there's stuff to do, can we help in a coordinated way?
10:20:32 <lambdabot> Consider it noted.
10:26:57 <phlpp> @babel en de continue
10:26:58 <lambdabot>   fahren Sie fort
10:27:01 <phlpp> :D
10:27:11 <phlpp> lambdabot, good to see you back at work!
10:27:43 <phlpp> @babel de en ago hat einen dick schnullerich
10:27:44 <lambdabot>   ago has one thickly schnullerich
10:27:47 <phlpp> hehe :>
10:28:38 <phlpp> interesting that he transformed dick, german adjective, into a adverb
10:30:02 <salierix> How does printf work? I wasn't aware that Haskell supported variable arity functions...
10:30:35 <Saizan_> using typeclasses
10:31:36 <byorgey> salierix: deep magic. =)
10:31:53 <salierix> evil magic?
10:32:01 <Saizan_> until you look at the source :)
10:32:13 <byorgey> no, not evil. =)
10:32:19 <puusorsa> @src printf
10:32:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:32:29 <Saizan_> @source Text.Printf
10:32:30 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
10:32:31 <byorgey> @type printf
10:32:33 <lambdabot> forall r. (PrintfType r) => String -> r
10:33:10 <byorgey> salierix: essentially, printf returns a "PrintfType", which can be a function OR just a String
10:33:16 <salierix> Anyone know how I can get firefox to treat .hs files as plain text?
10:34:14 <byorgey> @go firefox extension "open in browser"
10:34:16 <lambdabot> http://www.spasche.net/mozilla/
10:34:17 <lambdabot> Title: Mozilla stuff
10:34:30 <byorgey> salierix: ^^ that works for me.
10:36:02 <phlpp> hey byorgey
10:36:03 <phlpp> :>
10:36:16 <byorgey> hey phlpp!
10:36:20 <phlpp> sup?
10:36:20 <byorgey> how goes it?
10:36:27 <phlpp> well, well! :D
10:36:41 <byorgey> finally got my NSF grad fellowship application done =P
10:37:06 <phlpp> grats!
10:37:26 <phlpp> although i don't know about this abbreviation
10:37:31 <phlpp> ;)
10:37:43 <phlpp> sounds cool at least
10:38:15 <byorgey> National Science Foundation, it's a US gov't organization that provides lots of funding for science research
10:38:31 <byorgey> and they have a fellowship to support graduate students.
10:38:47 <phlpp> oh, that's cool
10:39:14 <sioraiocht> byorgey: my undergrad uni had a huge set of grants from the NSF for studentsin System assurance
10:39:17 <sioraiocht> if you're interested ;)
10:39:27 <salierix> byorgey, thanks for the link.
10:39:34 <byorgey> salierix: you're welcome.
10:39:39 <byorgey> sioraiocht: which one was that?
10:39:44 <sioraiocht> syracuse university
10:40:06 <glen_quagmire> i go to syracuse
10:40:15 <byorgey> sioraiocht: and what's system assurance?  I mean, I think I get the general idea from the name, but...?
10:40:28 <sioraiocht> umm, computer and network security
10:40:33 <sioraiocht> glen_quagmire: really?
10:40:36 <glen_quagmire> it means system is assurared
10:40:37 <sioraiocht> glen_quagmire: what program?
10:40:42 <glen_quagmire> sioraiocht: no i lie
10:40:54 <byorgey> ah.  well, thanks, but security isn't really my cup of tea =)
10:41:01 <glen_quagmire> i don't go to syracuse because it's not a girl only school
10:45:54 <araujo> hello
10:45:58 <phlpp> hi
10:46:07 <glen_quagmire> hai
10:50:13 <faxathisia> hiya
10:51:30 <faxathisia> how do you usually approach, reading through to understand someone elses code
10:51:51 <dcoutts_> look at the types
10:51:52 <faxathisia> I mean if it's kind of big, bigger than 3 or 4 files
10:52:13 <dcoutts_> you can use ctags
10:52:17 <dcoutts_> or just grep
10:52:24 <dcoutts_> to link uses to definitions
10:52:57 <geocalc> mmh
10:52:58 <glen_quagmire> open all 3-4 files
10:53:06 <glen_quagmire> and Alt+Tab like a mad person
10:57:38 <geocalc> what do you read faxathisia ?
10:58:31 <faxathisia> LogicT and in general just wondering
10:58:43 <geocalc> ok
10:58:54 <SimeonK> mooh
10:58:55 <faxathisia> have you seen it?
10:59:26 <geocalc> not yet
10:59:57 <faxathisia> geocalc: http://okmij.org/ftp/Computation/monads.html#LogicT
10:59:58 <lambdabot> Title: Monads
11:05:16 <geocalc> pdf berk
11:05:29 <faxathisia> lol
11:05:38 <faxathisia> get a program to read pdf files?
11:06:27 <geocalc> no too white background
11:15:42 <sethk> I'm still having a problem installing happy.  I've installed the latest darcs, cabal, and haddock but the problem has not gone away.
11:15:54 <sethk> the errror is:  Setup.lhs:9:7:
11:15:54 <sethk>     Could not find module `Distribution.Simple.Program':
11:16:22 <sethk> I see that file in an old ghc (6.4, I think), but I'm not sure why it isn't in my 6.6.1 tree.
11:16:29 <sethk> Does anyone know what I need to install?
11:17:58 <mrd> which cabal?
11:18:03 <aleator> sethk: I had similar lately. I don't know if this works, but try using ghc-pkg to hide the old cabal.
11:18:13 <mrd> you're gonna need 1.2 or later for that to work
11:18:25 <sethk> mrd, 1.2 of which?  cabal?
11:19:23 <mrd> yea
11:19:31 <mrd> or you can back up to 1.16 Happy which is what I did =)
11:19:36 <sethk> mrd, ok, I'll give that a try.
11:19:49 <sethk> aleator, I'm not sure I know exactly how to do that.
11:20:00 <sethk> aleator, if installing 1.2 doesn't work, I'll have to figure it out I guess.  :)
11:21:11 <aleator> sethk: "ghc-pkg list" what does it say about cabal?
11:21:42 <sethk> aleator, Cabal-1.1.6.2, ...
11:22:00 <aleator> Ah ok. So forget what I said and get the 1.2
11:22:25 <sethk> aleator, ok.  :)
11:22:30 <sethk> I'm looking for it.
11:22:36 <mrd> @where cabal
11:22:36 <lambdabot> http://www.haskell.org/cabal
11:23:00 <sethk> yes, I found the 1.1.6.2 right away.  I think I have to pull 1.2 from darcs
11:23:08 <mrd> its 1.3 now i think
11:23:25 <sethk> mrd, ok, so get the latest?
11:23:34 <mrd> sure
11:23:50 <mrd> or if you're just going to compile ghc 6.8.1 then you can drop back to 1.16 happy
11:24:25 <sethk> mrd, yes, if I don't get anywhere with it fairly quickly I'll downgrade happy.
11:24:46 <sethk> why does the darcs get command use --partial?
11:24:54 <mrd> save you some downloading
11:25:13 <sethk> ok
11:25:20 <mrd> use --partial unless you're going to do development on it
11:25:37 <sethk> oklopol, thanks, I was curious
11:25:43 <sethk> I'm extracting now.
11:30:19 <sethk> what's the extra step, before runghc Setup configure, that's needed when you pull a package from darcs?
11:31:20 <aleator> Hey. I'm probably stupid, but I'm if I do "readFile "foo"" do I need to close the file somehow?
11:31:28 <mrd> no
11:31:41 <mrd> sethk: nothing?
11:32:09 <aleator> Then why do I get errors for too many open files when doing that sequentially?
11:32:18 <mrd> they get read lazily
11:32:21 <sethk> mrd, ok, I can handle nothing.  :)
11:32:44 <mrd> aleator: so it may not be closed until an indeterminate time has passed
11:33:32 <mrd> i think the easiest thing to do is import qualified Data.ByteString.Char8 as SS; and use SS.readFile instead.  strict semantics for IO.
11:33:46 <mrd> SS.unpack `fmap` SS.readFile if you want a String
11:42:01 <sethk> mrd, happy 1.17 seems to be happy (  :)   ) after installing cabal 1.3, thanks.
11:49:23 <sethk> oklopol, now Alex is unhappy because it can't find Distribution.Setup.  Maybe here is where ghc-pkg can hide the newer cabal and expose the older one?
11:49:45 <Saizan_> yes
11:50:18 <Saizan_> or you can compile the Setup with ghc -package Cabal-1.1.6.2 and then use the binary
11:50:21 <sethk> Saizan_, I hide 1.3, and the older one is then exposed?
11:50:42 <sethk> Saizan_, I'll try the second option, it seems cleaner.
11:54:15 <sethk> Saizan_, thanks, using -package worked nicely.
11:56:10 <sethk> I built ghc 6.8.1 until I received an error about happy being unavailable (well, ok, I didn't read the README).  Should I just continue after installing happy and Alex and Haddock, or do I need to start again?
12:04:21 <rabbit64> Hi. What's the name of this function: f g h x = (g x) (h x)...from ski calculus?
12:04:40 <dmwit> You mean (f (g x) (h x))?
12:04:43 <dmwit> I think that's S.
12:04:54 <xerox> S f g x = f x (g x)
12:05:03 <b_jonas> @pl f g h x = (g x) (h x)
12:05:03 <lambdabot> f = ap
12:05:06 <rabbit64> yes thays it
12:05:51 <Liskni_si> @unpl join
12:05:52 <lambdabot> (\ b -> b >>= \ a -> a)
12:05:59 <paczesiowa> how can I use tuple of 1200 elements?
12:06:21 <paczesiowa> besides writing it?
12:06:29 <b_jonas> paczesiowa: what do you need such a large tuple for?
12:06:33 <dmwit> paczesiowa: Maybe hlist?
12:06:46 <faxathisia> > "(0" ++ (take (1200-1) $ repeat ",0") ++ ")"
12:06:47 <hpaste>  dcoutts pasted "Cabal JobPool (for sjanssen)" at http://hpaste.org/3671
12:06:48 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
12:06:53 <faxathisia> aww
12:07:10 <faxathisia> cycle repeat :S
12:07:26 <Jaak> > "(0" ++ (take (1200-1) $ cycle ",0") ++ ")"
12:07:28 <lambdabot>  "(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:07:39 <faxathisia> @@ @run "(0" ++ (take (1200-1) $ cycle ",0") ++ ")"
12:07:39 <paczesiowa> parsec's OperatorTable is a list of operators, and I need that list to have exactly 1200 elements
12:07:40 <lambdabot>  "(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:08:03 <paczesiowa> faxathisia: what about funtion to extract n-tk element?
12:08:07 <faxathisia> paczesiowa: a list is not a tuple
12:08:08 <paczesiowa> *n-th
12:08:24 <faxathisia> paczesiowa: (\(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,x_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)->x)
12:08:38 <dmwit> paczesiowa: Is there are really good reason not to use a list?  (i.e. are they different types?)
12:09:33 <paczesiowa> faxathisia: I know that, but then I can write some functions to operate on a tuples (safe) and at the end make it a list and give it to parsec.
12:09:51 <faxathisia> I don't think a tuple is safer than a list..
12:09:58 <paczesiowa> dmwit: they are the same type, but there must be exactly 1200, would be nice if type system could check that for me
12:09:59 <faxathisia> Just use a list the whole time
12:10:06 <dmwit> paczesiowa: Aha.
12:11:07 <paczesiowa> faxathisia: about that funtcion to extract n-th elem, writing that 1200 times is hmm...
12:11:29 <paczesiowa> actually, writing that even once is weird
12:11:55 <b_jonas> you could use an Array, or write a wrapper over it to only allow exactly 1200 element arrays
12:12:01 <int-e> paczesiowa: well, you could build a tree with fixed shape then, say  type X6 a = (a,a,a,a,a,a); type X5 a = (a,a,a,a,a); type X8 a = (a,a,a,a,a,a,a,a); type X1200 a = X5 (X5 (X6 (X8 a)))
12:12:20 <dmwit> I like b_jonas' idea best.
12:12:42 <int-e> yes, using arrays is sane.
12:13:20 <paczesiowa> hmm, I'd never think of such evil, imperative structure:P
12:14:01 <faxathisia> why not just use a list?
12:14:23 <paczesiowa> wait a minute...using array would result in error at the runtime, not at the compile time
12:14:24 <dmwit> Yeah, list + quickcheck or so also seems sane.
12:15:17 <paczesiowa> is template haskell good for these kind of things (just asking, not gonna use it with my level of haskellism)
12:15:31 <dmwit> paczesiowa: I think if you want purely compile-time checking, you're going to have to deal with a certain amount of pain.
12:15:51 <dmwit> But let me just suggest hlist again, in case you didn't notice it. ;-)
12:15:53 <dmwit> ?where hlist
12:15:54 <lambdabot> http://homepages.cwi.nl/~ralf/HList
12:16:02 <faxathisia> paczesiowa: I really wanna know why you don't just use a list :S
12:16:10 <Saizan_> hlist doesn't solve the 1200 issue
12:16:37 <dmwit> Saizan_: Sure it does, you just need to write down the entire type (once, as a named type), and then assert that in your type signatures.
12:16:40 <paczesiowa> I tried to read about that hlist once, it's too complicated for me
12:16:43 <Saizan_> but you can easily construct a Vec which have the lenght in the type
12:16:46 <dmwit> Or maybe I'm misunderstanding hlist's.
12:18:19 <dons>  you can just derive Num for your 1200 element enumeration
12:18:55 <faxathisia> I feel like I am missing something here :S
12:18:59 <paczesiowa> faxathisia: I'll probably end up using a list, I was just curious if it can be done better (isn't that what haskell is all about?)
12:19:08 <int-e> Did Language.C ever get finished?
12:19:29 <faxathisia> paczesiowa: I don't understand why checking a lists length at compile time is better
12:19:48 <dmwit> faxathisia: The question is, can we get the type-checker to confirm that there are exactly 1200 elements?  Lists don't provide a mechanism for that.
12:20:20 <dmwit> faxathisia: Compile-time checking (could) prevent a bunch of errors by acting as a regression test of sorts.
12:20:31 <paczesiowa> faxathisia: if it would be 2 elements, would you use lists for that?
12:20:47 <Rened> Didn't you say that this was for a parser interface? You will need run time errors anyway.
12:21:09 <paczesiowa> dons: I don't understand that, I don' want to add these "tuples" I just want to take one tuple, extract smth and return new tuple with one element updated
12:21:13 <faxathisia> dmwit: What I don't get why one would rather check this at compile time than runtime
12:21:23 <dmwit> Fail early.
12:23:05 <int-e> faxathisia: compile time checks constitute proofs. they can't go wrong at run time, by definition. a run time check might trigger once every few weeks. It's less predictable.
12:23:26 <faxathisia> int-e: I was just talking about this specific case
12:23:44 <dmwit> faxathisia: So was int-e.
12:23:56 <faxathisia> I don't see how that applies
12:24:06 <dmwit> We know there are 1200 operators now, but what if some idiot tries to change Parsec and accidentally deletes one during the refactoring?
12:24:07 <faxathisia> you have to construct some data and check it's length before passing it to the parser
12:24:15 <dmwit> Let's find out right away, not when somebody tries to use that deleted operator!
12:24:49 <int-e> hmm? no, I was talking about a more general case really, although that includes this particular one.
12:25:04 <paczesiowa> actually there are 1200 lists of operators (every lists contains operators of the same precedence)
12:25:16 <int-e> of course it's a trade off. you're probably going to spend (waste?) a lot of time pacifying the type system if you implement this as a compile time check.
12:25:59 <Saizan_> we need typelevel arithmetic on hackage!
12:26:21 <dmwit> paczesiowa: Okay.  The point stands; it is *sometimes* worthwhile to check these things at compile time.  (I'm not sure this is one of them, though.)
12:26:35 <b_jonas> btw, if you don't want to type \(_,_,_,_,_,x,_,_,_)->x 1200 times, you can use named tuples
12:26:45 <monochrom> hee hee
12:27:11 <b_jonas> then you only need O(1200) code, not O(1200^2)
12:27:59 <b_jonas> an alternative is to use the derived Show and reading the values from the shown tuple
12:28:23 <dmwit> b_jonas: You mean this? data List1200 a = Tuple1200 { n1 :: a, n2 :: a, ... }
12:28:43 <b_jonas> dmwit: yes, but I'm not sure of the syntax
12:28:48 <dmwit> ok
12:29:13 <Rened> In my opinion tuples should only be used when temporarily marshalling data between functions
12:29:41 <Rened> For something more integral to the structure of the program I would use a user defined type
12:30:19 <b_jonas> (in sml, normal tuples can be used as named as well, with accessor functions named iirc #1, #2, #3, ...)
12:34:28 <SimeonK> I'm calucalting an eternal index
12:35:43 <SimeonK> how long do you think will I enjoy it?
12:36:21 <rabbit64> SimeonK, 5 seconds
12:36:43 <SimeonK> >:O
12:36:48 <SimeonK> ok
12:36:52 <SimeonK> I'm stopping it :D
12:37:33 <rabbit64> lol, it was just prediction, the longer you enjoy it, better for you (or your score in test :P )
12:38:36 <SimeonK> yes
12:38:51 <SimeonK> calculating infinite index will save me at the test :D
12:38:53 <paczesiowa> hmm those tuples would cause hard to read errors, if I would return 1199tuple isntead of 1200, I'd have to write some utility to parse ghc errors:)
12:39:38 <rabbit64> ah eternal, i thought it is external (so i thought it is something not pointless)
12:40:07 <rabbit64> :?
12:40:26 <SimeonK> eternal as neverending o_O
12:40:54 <rabbit64> I know what is eternal, i misread it as external
12:41:29 <SimeonK> get glasses :P
12:42:26 <rabbit64> very funny...
12:42:30 <dons> ?users
12:42:31 <lambdabot> Maximum users seen in #haskell: 424, currently: 403 (95.0%), active: 15 (3.7%)
12:42:53 <SimeonK> ?users
12:42:54 <lambdabot> Maximum users seen in #haskell: 424, currently: 401 (94.6%), active: 15 (3.7%)
12:43:07 <SimeonK> ?commands
12:43:07 <lambdabot> Unknown command, try @list
12:43:12 <SimeonK> @list
12:43:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:43:23 <SimeonK> :/
12:43:49 <SimeonK> rabbit64
12:43:56 <rabbit64> yes?
12:44:08 <SimeonK> have you read all the slides?
12:44:18 <SimeonK> I mean until 107 (the last one today)
12:44:18 <rabbit64> not yet...
12:44:33 <monochrom> Am I in the right channel? eternal index, enjoy, test score... Where is #haskell?
12:44:35 <rabbit64> i've got time till friday
12:44:58 <SimeonK> monochrom, try "/s log"
12:45:53 <SimeonK> eternal index, that's an alfa and omega of haskell
12:45:56 <monochrom> Well, if you do /s log on your part, you will find that I came in very recently, and therefore my /s log would contain nothing useful.
12:46:10 <SimeonK> well, try it :)
12:46:29 <b_jonas> wtf is "/s log"?
12:46:41 <SimeonK> that's the mystery :D
12:46:46 <monochrom> The server says "s: Unknown command"
12:47:01 <SimeonK> what client do you use?
12:47:17 <monochrom> xchat
12:47:26 <SimeonK> ah
12:47:34 <SimeonK> then try "/server log" :D
12:47:42 <SimeonK> no!
12:47:51 <SimeonK> :(
12:47:59 <SimeonK> I thought they are joking
12:48:02 <SimeonK> omg
12:48:04 * SimeonK blushes
12:48:11 <rabbit64> or noto
12:48:17 <Saizan_> ..
12:48:22 * SimeonK runs and hides
12:48:32 * rabbit64 will find SimeonK 
12:48:33 <SimeonK> ok, back to fp
12:48:39 <SimeonK> :O
12:48:44 <rabbit64> muhahaha >=D
12:49:04 * SimeonK waves a flag with great writing "back to haskell"
12:49:09 <monochrom> /server log disconnects and tries to connect to a server called "log". You are just talking out of your ass. From now on I'll doubt everything you say.
12:50:05 * rabbit64 steal a SimeonK's flag and kills a fly with it
12:50:31 <SimeonK> :/
12:50:55 * rabbit64 returns flag to SimeonK 
12:52:31 * SimeonK pokes rabbit64
12:52:51 <SimeonK> try doing infinite index
12:53:12 <rabbit64> ok i'll try...w8
12:54:36 * rabbit64 has experienced a head explosion and is now dead 
12:55:12 <SimeonK> rabbit64: "Kick of one student is a tragedy. Kick of hundred is a statistic."
12:55:27 * omnId throws both rabbit64 and SimeonK into GHC's evaluator
12:55:30 <rabbit64> SimeonK, words of a dictator *scared*
12:56:07 <rabbit64> so now you have to blow up the whole university to "undo" this tragedy
12:56:26 <dmwit> ?remember YHC There is currently no debugging system available. Please write correct programs.
12:56:26 <lambdabot> It is forever etched in my memory.
12:56:34 <rabbit64> btw, how can I type and be dead at the same time?
12:56:40 <SimeonK> impossible, Brandej's got it secured
12:56:41 <omnId> dmwit: haha
12:56:43 <SimeonK> Brandejs
12:57:07 <rabbit64> We just have to steal his eye...that's all
12:57:30 <rabbit64> (wednesday 12:00, pc sites)
12:57:39 <SimeonK> that's when my english begins
12:58:02 <rabbit64> that's online english, that doesn't count
12:59:09 <SimeonK> that's not online
12:59:13 <SimeonK> that's normal one
12:59:30 <faxathisia> > cycle "O_o_"
12:59:39 <lambdabot>  "O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o_O_o...
12:59:42 <rabbit64> SimeonK, what's your ttl score?
13:00:07 <faxathisia> SimeonK rabbit64 try /msg :p
13:00:31 <dmwit> Or at least continue in -blah.
13:00:48 <rabbit64> okok...we're quiet
13:00:55 <SimeonK> bah is moderated
13:01:38 <mwc> bah humbug!
13:02:32 * omnId tests if @@ is wrapped in @more to prevent flooding
13:02:38 <omnId> @@ @@ @read @run concat $ replicate 20 "(@brain)"
13:02:40 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
13:02:53 <omnId> weird, works in /msg
13:16:33 <phlpp> > 8 ++ take 10 $ cycle "=" ++ D
13:16:34 <lambdabot>   Not in scope: data constructor `D'
13:16:41 <phlpp> > "8" ++ take 10 $ cycle "=" ++ "D"
13:16:42 <lambdabot>  Couldn't match expected type `[Char]'
13:16:53 <faxathisia> > "8" ++ (take 10 $ cycle "=") ++ "D"
13:16:54 <lambdabot>  "8==========D"
13:16:57 <phlpp> ah ok
13:17:26 <dmwit> > replicate 10 '='
13:17:27 <lambdabot>  "=========="
13:17:34 <dmwit> Not that I endorse the end product.
13:18:02 <faxathisia> > ("8"++).(++"D").(replicate 10) '='
13:18:03 <lambdabot>  Couldn't match expected type `a -> [Char]'
13:18:17 <dmwit> > ("8"++).(++"D").(replicate 10)$'='
13:18:18 <lambdabot>  "8==========D"
13:18:21 <b_jonas> > concat $ replicate 6 "\o/ "
13:18:21 <lambdabot>  Illegal escape sequence at ""\o/" (column 22)
13:18:24 <faxathisia> mf!
13:18:25 <b_jonas> > concat $ replicate 6 "\\o/ "
13:18:27 <lambdabot>  "\\o/ \\o/ \\o/ \\o/ \\o/ \\o/ "
13:18:58 <b_jonas> buubot used to have a bug once that you could produce very long output with one of its plugins
13:19:14 <faxathisia> > map (!!"zwyzslw") $ map (mod 5) $ [1..]
13:19:14 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
13:19:24 <faxathisia> grr
13:19:31 <b_jonas> (I also make an infinite loop of replies between buubot and buubot2 once.)
13:19:42 <dmwit> > map ("zwyzslw"!!) $ map (mod 5) $ [1..]
13:19:43 <lambdabot>  "zwywzllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll...
13:20:10 <dmwit> > map ("zwyzslw"!!) $ map (`mod` 5) $ [1..]
13:20:12 <lambdabot>  "wyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzszwyzsz...
13:20:35 <dmwit> b_jonas: Yeah, that's really hard to prevent when there are two bots.
13:20:44 <b_jonas> dmwit: yes, I know
13:20:46 <phlpp> > replicate 6 "\\o/ "
13:20:47 <b_jonas> because of quines
13:20:48 <lambdabot>  ["\\o/ ","\\o/ ","\\o/ ","\\o/ ","\\o/ ","\\o/ "]
13:20:50 <phlpp> ah
13:20:57 <faxathisia> > map ("zwyzslw"!!) $ map (flip mod 7) $ (zipWith (*) (map (flip mod 5) $ [1..]) [1..])
13:20:58 <lambdabot>  "wsyyzwzzwzszszzywlwzzywlzllzszzwwzzwsyyzwzzwzszszzywlwzzywlzllzszzwwzzwsyyz...
13:21:00 <b_jonas> IRC has a builtin mechanism agains it: notices
13:21:17 <b_jonas> but somehow people didn't like when I made my bot answer with notices instead of privmsgs
13:21:44 <b_jonas> even though that's exactly the purpose of notices: clients are expected not to reply to notices
13:22:46 <dmwit> One thing you could do is always start your reply with the nick of the person you're replying to.
13:22:49 <kpreid> b_jonas: such people should be ignored!
13:22:51 <b_jonas> (also, my bot replies to some messages memoserv send to read memoserv messages)
13:22:54 <dmwit> Then make the bot not reply to anything that starts with its nick.
13:23:08 <b_jonas> dwmit: that's sort of what I'm doing with my bot
13:23:14 <b_jonas> but I don't control other's bots
13:23:23 <b_jonas> so there can still be a loop including them
13:23:27 <dmwit> right
13:23:35 <b_jonas> the bot also has a list of bots which it almost ignores
13:24:02 <b_jonas> (and a way for bots to register themselves to that list, but no-one uses that)
13:24:49 <b_jonas> buubot and buubot2 also had ignore list and buu has made them ignore each other after this attack
13:25:27 <b_jonas> though the one answering memoserv messages is not my evalbot
13:26:58 <dmwit> > map ("abcdefg"!!) $ map (flip mod 7) $ (zipWith (*) (map (flip mod 5) $ [1..]) [1..])
13:27:00 <lambdabot>  "beccagadbaedeaacgfgaacgfaffaeadbbdabeccagadbaedeaacgfgaacgfaffaeadbbdabecca...
13:27:34 <dmwit> > cycle "beccagadbaedeaacgfgaacgfaffaeadbbda"
13:27:36 <lambdabot>  "beccagadbaedeaacgfgaacgfaffaeadbbdabeccagadbaedeaacgfgaacgfaffaeadbbdabecca...
13:27:51 <dmwit> > length "beccagadbaedeaacgfgaacgfaffaeadbbda" == 35
13:27:52 <lambdabot>  True
13:27:59 <faxathisia> :O
13:28:03 <faxathisia> > (*) 7 5
13:28:04 <lambdabot>  35
13:28:42 <faxathisia> > map ("%£$@*&"!!) $ map (flip mod 13) $ (zipWith (*) (map (flip mod 11) $ [1..]) [1..])
13:28:43 <lambdabot>  Exception: Prelude.(!!): index too large
13:28:56 <faxathisia> impossible
13:29:21 <ricky_clarkson> Are you making lambdabot generate chord sequences?
13:29:27 <dmwit> > map ("abcdefg"!!) $ map (`mod` 7) $ map (`mod` 35) $ map (^2) [1..]
13:29:29 <lambdabot>  "beccebabeccebabeccebabeccebabeccebabeccebabeccebabeccebabeccebabeccebabecce...
13:29:53 <dmwit> derr, (`mod` 7) . (`mod` 35) == (`mod` 7)
13:30:09 <Thas> Data.Map.deleteAt isn't doing what I'm expecting.. where is my expectation going wrong?  deleteAt 0 (fromList [("hello","world"),("smiling","gnus"),("are","happy")]) is returning "fromList []", I'm expecting what I gave it, minus ("are","happy").
13:30:19 <omnId> map f . map g . map h = map (f . g . h), btw
13:30:31 <dmwit> :t deleteAt
13:30:33 <lambdabot> Not in scope: `deleteAt'
13:30:38 <dmwit> :t Data.Map.deleteAt
13:30:39 <lambdabot> forall k a. Int -> Data.Map.Map k a -> Data.Map.Map k a
13:31:01 <omnId> @docs Data.Map
13:31:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
13:31:14 <omnId> s/latest/6.6.1/
13:31:43 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/containers-0.1.0.0/Data-Map.html
13:31:45 <lambdabot> http://tinyurl.com/29uckw
13:31:56 <int-e> Thas: that got fixed
13:32:06 <Thas> int-e: Oh, bug in 6.6.1?
13:32:20 <int-e> Thas: in the base library that comes with it, yes.
13:32:25 <Thas> Ok, thanks.
13:32:35 <Thas> I was afraid I was missing something obvious!
13:34:48 <faxathisia> Can you think of any medium-sized-ish haskell programs which create some instances and classes I should look at?
13:39:45 <astrolabe> faxathisia: I guess you've looked at the ones in the prelude?
13:39:56 <faxathisia> I don't think so
13:40:12 <faxathisia> well I've seen them probably all in tutorials I guess
13:40:35 <astrolabe> faxathisia: here http://www.haskell.org/onlinereport/basic.html
13:40:36 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
13:40:45 <TSC> faxathisia: gtk2hs (library, not program) has classes and instances all over the place
13:53:57 <dmwit> I just had a stroke of genius.
13:54:03 <dmwit> Well, maybe not genius.
13:54:10 <dmwit> But I had a thought, which is unusual for me.
13:54:20 <dmwit> Record syntax should desugar to a class and an instance.
13:54:43 <dmwit> data Foo a = Constructor { x :: a, xs :: [a] } would become
13:55:07 <dmwit> data Foo a = Constructor (a, [a])
13:55:30 <dmwit> class HasX a b where x :: a -> b
13:55:48 <dmwit> instance HasX (Foo a) a where x = fst
13:56:15 <dmwit> s/where.*/where x (Constructor (a, _)) = a/
13:56:20 <twanvl> that is a good idea, except for the tuples
13:56:44 <dmwit> The advantage is that x is now a first-class function, just like you want it to be.
13:56:49 <omnId> seems very extensible-recordsy
13:56:50 <dmwit> Moreover, punning comes for free!
13:57:14 <dmwit> Function definition has a natural de-sugar, too:
13:57:28 <dmwit> f (Constructor {x = binding}) becomes
13:57:40 <dmwit> f (Constructor (binding, _))
13:58:06 <omnId> well, that particular bit's no different from existing records
13:58:15 <twanvl> I would suggest  x:: FRef a b
13:58:17 <dmwit> Great, less work for me!
13:58:19 <omnId> (besides the extra tuple)
13:58:42 <omnId> dmwit: have you looked at twanvl's functional references thingy?
13:58:51 <dmwit> Yep, and I use them now.
14:00:16 <omnId> I don't understand "The advantage is that x is now a first-class function".  Current selectors are ordinary functions, too.
14:01:06 <omnId> should maybe be a '| a -> b' fundep on HasX
14:01:14 <dmwit> omnId: Ah, you're right, the problem is with the setters.
14:01:22 <dmwit> Let's see, how would setters desugar in this case.
14:01:58 <omnId> rec {x = val} --> let Con _ xs = rec in Con x xs
14:02:08 <dmwit> value { x = newX } becomes (\Constructor (_, y) -> Constructor (newX, y)) val
14:02:11 <omnId> s/x/val/
14:02:18 <twanvl> rec { x = y }  -->  set x y rec
14:02:31 <dmwit> Yeah, functional references win on this one.
14:02:41 <dmwit> The setter still isn't first-class in my proposal.
14:02:48 <dmwit> Which is why I was excited about it in the first place.
14:02:54 <twanvl> a setX function would work as well
14:02:58 <dmwit> nm
14:03:01 <omnId> dmwit: is there a reason for your the tuple?
14:03:07 <omnId> s/your//
14:03:26 <dmwit> omnId: No, I just didn't think far enough ahead.
14:03:53 <omnId> if it's data anyway, it had might as well use multiple fields, like current records.
14:04:02 <dmwit> yeah
14:04:22 <dmwit> I blame my memory.
14:04:40 <omnId> unless you're newtyping tuples, but that's representationally no different from new multiple-field data constructors
14:05:51 <dmwit> This is a bit of a side-track, but don't newtypes deal with _|_ differently than data does?
14:06:28 <bos> yeah.
14:08:04 <omnId> newtype constructors don't actually exist at runtime, so matching against just them doesn't actually force any evaluation.
14:11:09 <dataangel> I'm trying to grok monads at the moment, reading http://haskell.org/haskellwiki/IO_inside which is making a lot of sense, but I noticed that rather than having functions take the_world as an argument and returning a new the_world, they actually return IO a's, which are themselves functions that take worlds and give back a value and a new world. Why the extra layer?
14:11:11 <lambdabot> Title: IO inside - HaskellWiki
14:11:46 <Gwern-away> hey, does anyone know why the sum-file benchmark on the great programming language shootout is so very slow?
14:12:04 <Gwern-away> the example input file runs lickety-split on my system...
14:12:24 <omnId> dataangel: the IO datatype (as defined there) encapsulates the world-passing bit in its monad instance (>>=) and return, so you don't have to deal with those niggly bits.
14:12:25 <mauke> IO is a bad example of a monad
14:13:20 <omnId> it's pretty much exactly State RealWorld monad.
14:13:45 <astrolabe> @type print
14:13:46 <lambdabot> forall a. (Show a) => a -> IO ()
14:13:55 <astrolabe> @type print "hello"
14:13:56 <lambdabot> IO ()
14:14:15 <omnId> dataangel: IO actions are themselves functions wrapped inside the data constructor.  Binding is essentially fancy function composition that passes the updated worlds around in the correct way.
14:14:25 <astrolabe> So, you get extra arguments when they''re useful, but they aren't always used.
14:14:49 <dataangel> Well, so main returns an IO (), which should be typed as RealWorld -> ((), RealWorld). So if main returns an IO (), main actually returns a function that if given a world gives a new world, rather than being that function itself. And so GHC "feeds" the world into that returned function at runtime.. or something?
14:15:18 <omnId> pretty much
14:15:24 <mauke> dataangel: that's like saying "x = 2" makes x return 2 instead of being 2 itself
14:15:25 <dataangel> craziness :D
14:15:32 <astrolabe> main doesn't 'return' an IO (), it IS an IO ().
14:15:52 <omnId> zero-argument functions are indistinguishable from constants in Haskell.
14:16:07 <mauke> there are no zero-argument functions
14:16:25 <dataangel> mauke: Err, but say in C. Main doesn't return a function. It's something that is itself executed, and that execution is running the program. But it seems that in Haskell, main returns a function, and the evaluation of _that_ function is actually runninng the app
14:16:33 <Saizan_> there are no functions!
14:16:41 <mauke> main doesn't return a function, it is a function
14:16:48 <mauke> (in that model of IO)
14:17:01 <dataangel> oh right
14:17:13 <omnId> dataangel: that's a fair understanding.  main is an IO action, GHC passes the first RealWorld into that action.
14:17:28 <mauke> but I don't think of IO x as functions
14:18:18 <omnId> mauke: maybe not, but that's the way IO inside describes them, and it's not an *incorrect* way to define them.
14:18:27 <mauke> I still don't like it
14:18:32 <omnId> fine, fine :)
14:18:46 <mauke> you can't pass the real world around in the real world
14:19:05 <omnId> that's an implementation detail :)
14:19:13 <mauke> yes, exactly
14:19:15 <omnId> though defining IO as such is also one.
14:19:37 <mauke> IO as a tree type makes much more sense
14:19:42 <omnId> but understanding a formulation of IO as this implementation can be helpful when coming to grips with it.
14:19:49 <mauke> well, until you start thinking about what >>= has to do
14:21:14 <Saizan_> CPS!
14:21:20 <omnId> dataangel: any other fuzzy bits?
14:21:24 <psnively> Hi guys. Anyone know why I get "Could not find module `Distribution.Simple.Program'" from trying to "runhaskell Setup configure --ghc" in Happy 1.17?
14:21:50 <Saizan_> i'm starting to think that the concept of monad is based on CPS, and the others are just fancy "effects"
14:22:04 <dmwit> mauke: IO as a tree type?  Explain?
14:22:04 <psnively> This is with GHC 6.6.1 on Mac OS X 10.5 on a MacBook Pro.
14:22:17 <Saizan_> psnively: you probably need to upgrade cabal to 1.2
14:22:27 <psnively> How do I do that? :-)
14:23:02 <mauke> dmwit: think of it as the AST for an imperative language
14:23:15 <astrolabe> psnively: get it from here http://www.haskell.org/cabal/download.html
14:23:16 <lambdabot> Title: The Haskell Cabal
14:23:51 <mauke> dmwit: given an AST (bound to main), the haskell runtime then walks and executes it
14:23:51 <psnively> Gotcha, thanks. :-)
14:24:05 <dmwit> mauke: Interesting.  So (>>=) adds another branch to the tree?
14:24:09 <mauke> dmwit: thinks like getChar, putChar and (>>) are just helpers for constructing such a tree
14:24:30 <mauke> (>>=) doesn't really fit because it bakes a callback into the tree instead of a real branch
14:24:50 <mauke> but that's no problem; since Haskell is pure, the runtime can call back into Haskell code
14:25:39 <psnively> Heh. Virtualization for free!
14:25:58 <dataangel> omnId: explaining it to someone else and seeing if I trip up ;p
14:30:18 <dataangel> omnId: Fuzzy bit: So each function that gives back an IO something is giving back a function that takes the world, and gives back the value from the function and the new world. Now, when bind occurs, are we chaining things together to make this one final big RealWorld -> ((), RealWorld) main function, does bind cause the evaluation to happen somehow? ... I might be confused :P
14:30:34 <dataangel> *or does bind cause
14:31:00 <dataangel> actually, thinking about the return type of main, I'm going to guess it must be composing them together
14:31:02 <pgavin> dataangel: setting an IO action to main causes it to execute
14:31:05 <dataangel> which actually I think you said above
14:31:19 <omnId0> dataangel: oh sorry, I was afk and got disconnected
14:31:32 <pgavin> dataangel: the run time system actually just reads your main action and treats it as a plan of execution
14:34:10 <dataangel> omnId: Fuzzy bit: So each function that gives back an IO something is giving back a function that takes the world, and gives back the value from the function and the new world. Now, when bind occurs, are we chaining things together to make this one final big RealWorld -> ((), RealWorld) main function, does bind cause the evaluation to happen somehow? ... I might be confused :P
14:34:18 <dataangel> repeated since you wre afk
14:34:25 <dataangel> *or does bind cause
14:35:26 <gwern> what's the ghc option that causes it to dump Core?
14:35:41 <omnId> dataangel: binding composes them together, the compiler still sets things off by passing in the first RealWorld
14:36:34 <dpiponi> What's the recommended Haskell way to access the representation of a Float as an Int. Ie. what's written in C as *(int *)&f, where f is a float?
14:37:17 <Botje> okay. I have just ascended nethack. now somebody give me a hard paper to read
14:37:43 <faxathisia> Botje: http://okmij.org/ftp/papers/LogicT.pdf
14:38:01 <Heffalump> dpiponi: unsafeCoerce#
14:38:03 <mauke> dpiponi: I'd use Foreign.* and castPtr
14:38:16 <Heffalump> dpiponi: or, you can do it portably and inefficiently using decodeFloat
14:38:51 <Botje> faxathisia: heh, lessee :)
14:39:21 <omnId> dataangel: binding the first action to a second makes a composed function that, when given the first RealWorld, sends it through the first action which "makes" an updated RealWorld, which is then passed into the second
14:39:32 <dataangel> omnId: Is "IO a" a constructor?
14:39:55 <mauke> dataangel: no
14:40:01 <mauke> IO is a type constructor, though
14:40:23 <dataangel> So from a C++ coders point of view, it's a templated typedef
14:40:27 <dataangel> ?
14:40:35 <omnId> similar, yes
14:40:40 <dataangel> ah k that helps
14:40:42 <omnId> but I don't know enough C
14:40:44 <omnId> :)
14:40:55 <dpiponi> Heffalump: thanks
14:41:10 <Heffalump> dpiponi: I have code kicking around if you want it
14:41:19 <dpiponi> Yes please!
14:41:21 <Heffalump> well, for Double <-> Int64
14:41:26 <Heffalump> I imagine you can figure out the details :-)
14:42:07 <mauke> dataangel: more like a struct template, I'd say
14:42:41 <Heffalump> ah, I only seem to have the Int64 -> Double case written out portably. The other way I just went straight to the coerce.
14:43:03 <dpiponi> Heffalump: it should be almost the same, right?
14:43:15 <Heffalump> well, kind of inverted, but yeah
14:43:17 * omnId looks at the IO inside page, and that defines IO as a type alias.  I think typedef would be more similar than struct.
14:43:35 <hpaste>  Heffalump pasted "Int64 <-> Double" at http://hpaste.org/3672
14:44:57 <dpiponi> Heffalump: Thanks. Time to start learning all those functions whose names end in #
14:46:29 <sethk> compiling 6.8.1 I'm getting a link error, undefined reference to __DISKARD__.  Ring any bells with anyone?
14:46:59 <sethk> it's on the link of stage1/ghc-6.8.1
14:48:37 <sethk> the symbol appears in nativeGen/RegLiveness.o
14:49:02 <malsyned> Why does List.find return a Maybe while Prelude.head throws an exception?
14:50:31 <ddarius> malsyned: Why not?
14:51:27 <malsyned> Well, I mean, by what objective criteria should one decide whether to return a Maybe or whether to call error?
14:51:42 <ddarius> malsyned: There isn't one.
14:52:15 <ddarius> There are some considerations but no hard and set rules.
14:52:38 <Botje> malsyned: do you want your program to continue or not? :)
14:52:40 <kscaldef_> malsyned: subjectively, head will "usually" succeed, while "find" is more uncertain
14:53:37 <malsyned> The difference reminds me, sortof, of the distinction between runtime exceptions and static exceptions in Java.  Except that Haskell places stricter restrictions on what kind of code can catch "runtime" exceptions (calls to error).
14:53:40 <sethk> symbol __DISKARD__, anyone?  It doesn't appear in any of the ghc source files, but is undefined in RegLiveness.o and causes stage1/ghc-6.8.1 link to fail.
14:54:36 <dibblego> malsyned, it is correct that you make this logical association
14:54:45 <bos> @seen dons
14:54:46 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 1h 56m 52s ago.
14:55:34 <sethk> I guess I'll upgrade gcc to the latest version and try the build again ...
14:56:21 <bos> @seen andyjgill_
14:56:21 <lambdabot> andyjgill_ is in #darcs, #xmonad, #ghc and #haskell. I don't know when andyjgill_ last spoke.
14:56:35 <malsyned> It's not possible to "catch" an error outside of the IO monad, right?
14:56:39 <andyjgill_> Hi bos
14:57:09 <sethk> boy, lambdabot is not too bright.  _I_ know when andijgill last spoke, at 22:43   :)
14:57:22 <idnar> heh
14:58:19 <bos> andyjgill_: are you getting my privmsgs?
14:59:30 <dataangel> mauke: Why a struct template?
15:00:57 <andyjgill_> bos: yes, but there might be a delay here?
15:01:15 <bos> andyjgill_: if you haven't registered with nickserv, i won't be able to see your responses
15:01:16 <mauke> dataangel: because IO isn't just an alias for another type
15:01:58 <dibblego> what's the function for doing this? (Monad m) => (a -> m b) -> m a -> m b
15:02:12 <idnar> @hoogle (a -> m b) -> m a -> m b
15:02:13 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
15:02:13 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
15:02:13 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
15:02:13 <Cale> :t (=<<)
15:02:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:02:39 <dibblego> gah, Monday morning
15:02:40 <dataangel> mauke: A templated typedef wouldn't be either. It maybe confusing to think about because C++ doesn't actually support templated typedefs, but you can get the same effect by defining a typedef inside a templated struct -- you now have a typedef with a definition dependent on a parameterized type
15:02:40 <dibblego> thanks
15:02:45 * idnar fails spectacularly
15:03:09 <mauke> dataangel: typedefs are always aliases for existing types
15:03:12 <dataangel> mauke: I'm imagining something like: template<class T> typedef LinkedList<T> LL;
15:03:43 <dataangel> mauke: But in real C++ you would have to do: template<class T> struct dummy { typedef LinkedList<T> LL; };
15:03:47 <mauke> yeah, now LL<T> is LinkedList<T>
15:03:51 <mauke> just an alias
15:04:49 <mrd> C++ makes baby lambda cry
15:05:43 <dataangel> mauke: Hrm, how is IO different? template<class T> struct IO { typedef function<(T, RealWorld)(RealWorld)> type; }
15:05:47 <Sgeo> Bye all
15:06:11 <dataangel> mauke: Pretend that (T, RealWorld)(RealWorld) is syntactic sugar for a function that takes a RealWorld and returns a tuple with value of type T and a new RealWorld
15:06:37 <raxas> since the coming of templates, c++ makes cry even old gray hair men, not just lambda babies
15:07:14 <dataangel> In C++ speak, LL<T> is only a template of a type. It's not a concrete type until T is known. I'm not sure how haskellers view that :)
15:07:48 <dibblego> ?hoogle (Monad m) => m [a] -> (a -> m b) -> m [b]
15:07:49 <lambdabot> No matches, try a more general search
15:08:11 <mauke> dataangel: oh, you still think of IO as functions
15:08:18 <dibblego> ?type mapM
15:08:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:08:47 <mrd> dataangel: as a desperate plea for parametric polymorphism
15:08:58 <dataangel> mauke: Aren't they? type IO a  =  RealWorld -> (a, RealWorld)
15:09:00 <mauke> dataangel: what's IO::type for? IO<T> is already a type
15:09:06 <mauke> dataangel: not necessarily
15:09:16 <mauke> and IO is definitely not a 'type'
15:09:16 <dataangel> mrd: How are templates not parametric polymorphism?
15:09:29 <mauke> it's either 'newtype' or 'data'
15:09:46 <dataangel> mauke: I'm trying to transcribe that type signature
15:09:48 <mrd> it's not a type
15:10:48 <dataangel> mrd: what isn't a type?
15:10:58 <mauke> template<typename a> struct IO { ::std::pair<a, RealWorld> contents(RealWorld); };
15:10:59 <mrd> templates
15:11:11 <faxathisia> hey you know LogicT is a monad transformer
15:11:18 <faxathisia> What do you think happens if you lift Parsec through it?
15:11:28 <dataangel> mrd: true technically but is there any consequence?
15:12:24 <dataangel> mrd: You can still pass them around can't you? Actually now that I think about it I'm not sure whether or not you can pass around templates themselves...
15:12:54 <mrd> if templates are instantiated with types, but templates are not types, then you can't instantiate a template with a template
15:13:07 <mauke> also, typename X<T>::template Foo<U>::t x(42);
15:13:18 <mrd> like as with impredicate polymorphism
15:13:21 <dataangel> mauke: That works too. I was thinking IO::type in my version was real type. Instead you've given a class function with that type.
15:13:23 <mrd> impredicative!
15:13:44 <mauke> dataangel: ah, right. make that a function pointer or something
15:13:52 <mrd> also, i have no idea how C++ is formalized, but I'm sure type safety doesn't hold
15:13:52 <mauke> it's not supposed to be a method
15:14:13 <malsyned> Is there a good explanation for why the type of "catch" is "IO a -> (IOError -> IO a) -> IO a", rather than something more general like "a -> (AnExceptionType -> a) -> a" ?
15:14:14 <raxas> dataangel: in hardcore c++ community, templates are percieved as functional metaprograms, not types
15:14:22 <dataangel> mrd: C++ has an undecidable grammar. I seriously doubt it is formalized ;p
15:14:32 <mrd> types can be programs
15:14:32 <mauke> malsyned: how is that more general?
15:14:38 <mrd> that is called dependent types
15:14:47 <malsyned> mauke: because you can use it in pure code.
15:14:49 <dolio> @type catchError
15:14:51 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
15:14:59 <mauke> malsyned: oops, didn't see the non-IO's :-)
15:15:16 <dataangel> raxas: I think that's just a name difference, if your type system is turing complete it's still a type system but also allows for metaprograms, like C++
15:15:28 <mauke> malsyned: pure code can't throw IO exceptions
15:15:36 <mrd> dataangel: do parametricity results hold for C++ templates?
15:15:51 <malsyned> mauke: but it can return "bottom" by calling "error".  is there a way to catch that in the caller?
15:15:55 <dataangel> mrd: I'm not sure what you mean, example?
15:15:56 <dolio> Throwing and catching exceptions would be impure, I suspect.
15:16:02 <mauke> malsyned: not in H98
15:16:07 <mrd> dataangel: the fact that id is the only inhabitant of forall a. a -> a
15:16:07 <malsyned> mauke: what about in ghc?
15:16:07 <raxas> dataangel: that's what they discovered long after templates were invented
15:16:12 <mrd> ?djinn a -> a
15:16:13 <lambdabot> f a = a
15:16:16 <mauke> malsyned: Control.Exception.catch
15:16:40 <malsyned> mauke: ghci claims that it's type is "IO a -> (GHC.IOBase.Exception -> IO a) -> IO a"
15:17:07 <mauke> it is
15:17:08 <mrd> dataangel: parametricity is a formalization of the intuition that parameterized types are abstract and can sharply limit the space of possible well-typed programs
15:17:09 <dataangel> mrd: You mean that the only function on types that takes type A and gives back type A is the type identity function?
15:17:27 <malsyned> mauke: so how is that any better than the prelude's catch for use in pure code?
15:17:31 <mrd> and thanks to Curry-Howard, the space of possible proofs of the proposition the type represents
15:17:58 <dataangel> raxas: how long after? I recall reading someone discovering they could code a lisp in it fairly early on, but I'm not sure what timescale you're thinking
15:18:09 <mauke> malsyned: it isn't. you can't reliably catch exceptions in pure code
15:18:33 <malsyned> mauke: yeah.  a shame.  Is there a good theoretical basis for why not, do you know?
15:18:36 <mauke> I'm pretty sure it messes with your evaluation order
15:18:46 <dataangel> mrd: Your summary is good but just from it I don't know enough to know if it holds or not
15:19:14 <raxas> dataangel: it took several years until some good quality libraries with metaprograms were designed, like boost
15:19:35 <mrd> don't stress it too much, the result isn't easy especially when the language is a mess
15:19:41 <dataangel> raxas: To be fair, it took several years before there were any compilers that supported the standard
15:21:09 <raxas> dataangel: and at the beginning, many lay coders (not a c++ hardcore/standard team) percieved templates just as fancy macros
15:21:50 <raxas> and often rejected them for the reason of incompatibility
15:22:40 <raxas> whole Qt library was such an example, it took years for trolltech to accept templates at some primitive level
15:25:31 <raxas> actually, it was a FC++ library, said modelled after haskell prelude which made me interested in haskell at all
15:26:15 <raxas> http://www.cc.gatech.edu/~yannis/fc++/
15:26:16 <lambdabot> Title: FC++: The Functional C++ Library
15:27:06 <dpiponi> raxas: Same here. Seeing that monad implementation was one of the things that pushed me to try to understand monads.
15:27:56 <RayNbow> dataangel, can you elaborate on C++'s undecidable grammar?
15:28:48 <faxathisia> you can write a template which causes an infinite number of errors
15:28:52 <faxathisia> Isn't that it?
15:29:00 <faxathisia> recursive failure
15:29:52 * RayNbow has very limited experience with C++'s features
15:30:08 <RayNbow> but I can produce some C-style programs in C++ :p
15:30:14 <dataangel> RayNbow: http://yosefk.com/c++fqa/web-vs-c++.html#misfeature-2
15:30:15 <sioraiocht> RayNbow: consider yourself lucky =p
15:30:21 <lambdabot> Title: C++ FQA Lite: ﻿C++ criticism by other people
15:30:27 <dataangel> blessed even ;p
15:30:40 <dataangel> I wouldn't mind C++ so much if I didn't have to deal with my boss's code
15:31:01 <ari> Hm
15:31:09 <dataangel> which is a single letter variable name global variable switch on type variable rats nest
15:31:11 * RayNbow prefers Java and Haskell as a programming language...
15:31:16 <ari> I thight I'd /set hide_colors on, how did that red bit get in there
15:31:36 <RayNbow> although I'm still trying to get an understanding of those damn Monads :p
15:31:43 <dataangel> I might consider Java if it had MI
15:31:52 <faxathisia> dataangel: What's MI?
15:31:55 <ari> *thought
15:31:56 <dataangel> multiple inheritance
15:31:56 <RayNbow> multi inheritance
15:32:12 <sioraiocht> dataangel: that's what interfaces are for
15:32:13 <Excedrin> @quote oop
15:32:14 <lambdabot> Spark says: "oops, we proved the wrong property"
15:32:17 <LoganCapaldo> it's like multple personalities but with inheritance
15:32:39 <dataangel> sioraiocht: I like the policy C++ stuff, which sort of necessitates implementation MI
15:32:52 <LoganCapaldo> Interfaces do not give you everything MI does. This is arguable a good thing.
15:32:57 <LoganCapaldo> *arguably
15:33:00 <Karle> hi all
15:33:02 <dataangel> true
15:34:16 <sioraiocht> LoganCapaldo: you can't have diamond inheritance in interfaces, can you?
15:35:08 <faxathisia> It'd be hilarious if they add lambda and a metaobject protocol to java
15:35:19 <sioraiocht> faxathisia: ?
15:35:27 <faxathisia> sioraiocht: ?
15:35:28 <LoganCapaldo> You could, but you don't run into the same number or severity of problems. I am not an uber-OO expert though :)
15:36:56 <dataangel> wait a second
15:37:55 <dataangel> why does the prelude say: "data IO a = .... -- abstract" instead of "type IO a = ... -- abstract" Presumably they're imagining some sort of ... constructors?
15:37:56 * dataangel isn't sure
15:38:12 <monochrom> Yes, some sort of constructor.
15:38:58 <dolio> It can't be 'type' because you can't partially apply type synonyms in Haskell.
15:39:25 <mauke> 'type' is never abstract
15:40:21 <monochrom> "type IO a = " does not allow "instance Monad IO"
15:40:34 <elliottt> does anyone know if it's possible to pass arguments to hsc2hs from the cabal file?
15:42:10 <Cale> I usually imagine IO as some GADT which has constructors for primitive IO actions along with return and bind.
15:43:17 <dolio> That's a good reason present it as 'data ...' instead of 'newtype ...'.
15:43:26 <dolio> The latter being an implementation detail. :)
15:43:31 <dataangel> dolio: What does "partially apply" mean? Curry?
15:43:52 <dolio> 'IO a' is fully applied. 'IO' is partially applied.
15:44:04 <Cale> It means to take a function of multiple parameters, and produce a function of fewer parameters by applying the function to some, but not all of its arguments.
15:44:22 <dataangel> dolio: Hrm. why is it problematic that you can't do that with 'type'?
15:44:39 <Cale> Currying is the process of taking a function of multiple parameters and turning it into a function of one parameter which returns a function of the rest of the parameters.
15:44:46 <dolio> dataangel: Because you need to partially apply instances of, say, Monad and Functor.
15:45:00 <Cale> Well, you need to not apply the constructor at all.
15:45:16 <dolio> 'instance Monad IO' and so on. Not 'instance Monad (IO a)'.
15:45:26 <dataangel> Cale: that's what I thought. Since IO only has one parameter and I haven't seen it yet except as IO a, IO (), IO Char, etc. I'm not sure I understand though
15:45:35 <dolio> Well, depends on the monad 'instance Monad (State s)'.
15:45:50 <dataangel> ah, I haven't learned instances yet
15:45:58 <dataangel> will think about it again then :)
15:46:06 <newsham> ?type readFile "/etc/passwd"
15:46:08 <lambdabot> IO String
15:46:29 <newsham> when you execute 'readFile "/etc/passwd"' you get a string as a result
15:46:33 <dolio> You'd also have trouble using it in monad transformers. 'StateT s IO a' has IO partially applied.
15:50:16 <hpaste>  Cale pasted "IO" at http://hpaste.org/3673
15:50:30 <dataangel> I understand why Java has garbage collection -- there's no manual freeing mechanism and it's totally undecidable when something is no longer used. But why does Haskell need it? I don't know enough about compiler implementation but it seems like statically knowing when you can delete things could be possible.
15:51:04 <Cale> dataangel: It almost sort of is, and there's work in that direction on region inference.
15:51:16 <gwern> dons: I've spent the last hour or two playing around with the sum-files benchmark on the programming language shootout. How the deuce is the Clean entry so damn fast?
15:51:28 <dons> bytestring io
15:51:33 <dons> gwern: see the super-fast
15:51:40 <Karle> hi again
15:51:43 <dons> bytestring one -- clean is doing that in a library call
15:51:55 <dons> though i note my bytestring version is twice as fast again
15:52:03 <gwern> dons: is that what the 'sumcol
15:52:08 <gwern> is all about?
15:52:21 <dons> well, there's  a disqualified bytestring version
15:52:40 <Cale> I think it's kind of dumb that your bytestring version is disqualified.
15:52:42 <oerjan> disqualified?
15:53:07 <dolio> He didn't use the built-in 'getLine'.
15:53:20 <dataangel> Cale: Any recommended reading? :D
15:53:25 <joelr1> good evening
15:53:29 <dcoutts> Cale: actually I think it's a reasonable restriction
15:53:32 <gwern> dons: on another note, on my computer the haskell versions generally run around 4-6 seconds for the faster ones, while the benchmarks says ~16 seconds. is my computer just faster or did ghc improve that much?
15:53:49 <Karle> good evening joelr1
15:53:51 <joelr1> i built 6.8.1 on leopard but cannot run ghci since it complains about missing _environ in HsBase
15:53:54 <dcoutts> Cale: we should be using IO that does not require reading the whole file in one, go, we should do it in constant memory
15:54:00 <dcoutts> Cale: ie we should use lazy bytestrings
15:54:04 <joelr1> has anyone encountered this issue?
15:54:19 <Cale> er, yeah, why isn't the lazy bytestring library being used then?
15:54:49 <sethk> joelr1, I'm still trying to get it built, haven't gotten that far yet.
15:54:57 <gwern> Cale: it is http://haskell.org/haskellwiki/Shootout/SumFile#Current
15:54:57 <Cale> gwern: Maybe a combination of the two, especially if you're running 6.8.1 since its code generation is quite a bit better than previous versions.
15:54:58 <lambdabot> Title: Shootout/SumFile - HaskellWiki
15:55:01 <dcoutts> Cale: in this example it's 10x slower because the strict one could be unboxed more
15:55:29 <gwern> Cale: is ghc 4x better?
15:55:39 <dcoutts> Cale: this is one reason we switched the lazy bytestring representation in bytestring-0.9, to allow for such specialisation and unpacking
15:55:43 <gwern> (and yes, I'm using 6.8.1)
15:55:53 <Cale> gwern: I'd be surprised by that factor.
15:56:07 <Cale> gwern: But I think at least 15% faster on average.
15:56:23 <gwern> the pointer tagging thing, I'd guess
15:56:27 <Cale> yeah
15:56:35 <joelr1> scsibug: ping
15:56:37 <gwern> didn't a bunch of bytestring improvements make it into 6.8.1 too?
15:56:40 <Cale> But there are other improvements as well, yes
15:57:07 <dcoutts> gwern: yep, into bytestring-0.9 which is bundled with ghc-6.8.1
15:57:41 <gwern> strangely, -O2 seems to make a little difference for the current sum-file; as compared with -O it shaved about .2 seconds off the 4.7 second runtime
15:58:37 <wli> Just make bytestrings the new standard IO interface so as to be able to win the shootout.
15:59:47 <joelr1> anyone else with 6.8.1 on leopard?
15:59:58 <LoganCapaldo> getLine :: (IsString s) => IO s ?
16:00:58 <Cale> joelr1: I'd heard of one other user, but I'm not sure if they had any problems or not.
16:01:02 <dcoutts> anyone want to translate a short C function into a Haskell one? :-)
16:01:17 <dcoutts>  /* Stolen verbatim from rpm/lib/misc.c
16:01:22 <joelr1> Cale: i think that was scsibug
16:01:23 <dcoutts>  int rpmvercmp(const char * a, const char * b)
16:01:42 <dcoutts> rpm's version comparison code, which would be handy to replicate in Cabal
16:01:45 <Cale> joelr1: Oh, and ChilliX has a 10.5 build which he's currently testing(?)
16:01:53 <joelr1> ChilliX: ping
16:02:05 <LoganCapaldo> what i'ts not just < ?
16:02:18 <LoganCapaldo> I mean strcmp
16:02:40 <Igloo> dcoutts: Why?
16:02:59 <dcoutts> Igloo: pkg-config uses it for it's version strings
16:03:25 <Igloo> Ah, OK
16:03:27 <joelr1> Cale: it's a silly issue but i can't figure it out. _environ is defined in /usr/lib/crt1.o gcrt1.o and crt1.10.5.o. apparently that doesn't get linked into ghc on leopard
16:03:28 <dcoutts> $ pkg-config --modversion openssl
16:03:29 <dcoutts> 0.9.8f
16:03:39 <Cale> dataangel: Oh, sorry, reading for what topic?
16:03:40 <dcoutts> Igloo: currently we try to parse that as a Version
16:06:44 <joelr1> @tell scsibug where's _environ in leopard? ghci doesn't run without it! /usr/local/lib/ghc-6.8.1/lib/base-3.0.0.0/HSbase-3.0.0.0.o: unknown symbol `_environ'
16:06:44 <lambdabot> Consider it noted.
16:07:03 <joelr1> @tell ChilliX where's _environ in leopard? ghci doesn't run without it! /usr/local/lib/ghc-6.8.1/lib/base-3.0.0.0/HSbase-3.0.0.0.o: unknown symbol `_environ'
16:07:04 <lambdabot> Consider it noted.
16:07:12 <Cale> joelr1: I only used 10.3 (and betas of 10.4), and only for a few months, so I don't really know much about it.
16:07:23 <joelr1> Cale: no problem
16:07:29 <jatqceer> where is GHC.Handle.openFd in ghc-6.8.1?  darcs configure errors because it couldn't find openFd
16:09:38 <dcoutts> jatqceer: fdToHandle'
16:09:58 <ChilliX> joelr1: hmm
16:09:58 <lambdabot> ChilliX: You have 1 new message. '/msg lambdabot @messages' to read it.
16:10:18 <joelr1> ChilliX: hi manuel
16:10:37 <joelr1> ChilliX: did you bump against this issue?
16:10:42 <jatqceer> dcoutts: which module is it in?
16:10:57 <ChilliX> joelr1: What build is that?
16:11:05 <joelr1> ChilliX: 6.8.1
16:11:37 <ChilliX> Did you build from source?
16:12:26 <joelr1> ChilliX: yes, but not from darcs
16:12:34 <joelr1> ChilliX: i got the source from haskell.org and built that
16:12:58 <joelr1> ChilliX: i also just built a simple test program and _environ is there.
16:12:59 <ChilliX> Can you do me a favour?  Try www.cse.unsw.edu.au/~chak/haskell/ghc-6.8.1-i386-apple-darwin.tar.bz2
16:13:14 <ChilliX> This is a full bindist build I did yesterday
16:13:24 <dcoutts> jatqceer: GHC.Handle
16:13:26 <ChilliX> but it needs readline from macports in /opt/local
16:13:38 <joelr1> ChilliX: don't know if it matters but i built 6.8.1 using the old 6.6.1, one i had built on tiger before upgrading
16:13:48 <joelr1> ChilliX: i have readline from macports
16:14:01 <dibblego> bos, you around? does this property hold? \p -> find always always p >>= return . not . null
16:14:03 <ChilliX> We couldn't test it, because the guy who wanted to test it has a too slow and flaky internet connection
16:14:24 <ChilliX> joelr1: that's what I did, too
16:14:33 <jatqceer> dcoutts: thanks
16:14:54 * glguy is building ghc 6.8.1 on leopard/ppc now with a readline and gmp manually built and installed to /usr/local
16:14:58 <joelr1> ChilliX: i'm downloading at about 70kbps
16:15:08 * glguy is holding fingers crossed :)
16:15:15 <bos> dibblego: not if you run on an empty directory
16:15:19 <joelr1> oops... speed dropping :)
16:15:30 <LoganCapaldo> I'm so behind with me ghc 6.8.1 on tiger :)
16:15:53 <joelr1> anyway, about 10 minutes remaining
16:16:16 <joelr1> ChilliX: you forgot to answer my question, though... did you bump against this issue?
16:16:58 <ChilliX> no, but that may be because I didn't test that 6.8.1 build yet
16:17:17 <joelr1> ChilliX: ugh... you built ghc but never ran ghci?
16:17:35 <ChilliX> joelr1: well, I ambuilding the head all the time and that works fine
16:17:46 <ChilliX> but someone else had problems
16:17:54 <ChilliX> so I did that 6.8.1 build for him
16:17:55 <joelr1> ChilliX: do you build the head with 6.8.1 or 6.6.1?
16:18:01 <ChilliX> but then he couldn't test it
16:18:19 <ChilliX> and I wasn't too keen on the nth+1 version of ghc on my machine...well, long story
16:18:31 <ChilliX> and the bindist doesn't seem to have the inplace script...
16:18:45 <ChilliX> otherwise I'll just rebuild that one and test it myself
16:18:53 <dons> anyone know why #rubyonrails has crashed in population size? mac 1475, cur: 262...
16:19:03 <dons> with #haskell also larger than #ruby-lang permanently now.
16:19:10 <dons> both channels have really dropped in size.
16:19:20 <araujo> Haskell is taking over the world
16:19:25 <bos> dons: where are you looking?
16:19:31 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
16:19:32 <ChilliX> dons: Because people figured ruby is out?!?
16:19:32 <lambdabot> Title: Search IRC, displaying all channels on freenode
16:19:38 <faxathisia> maybe someone invented haskell on hydrolics
16:19:43 <dons> the big change is #rubyonrails crashing
16:19:43 <glguy> dons: oh, I know why, because it was a fad
16:19:46 <LoganCapaldo> #rubyonrails has started requiring your being identified to nickserv before you can enter
16:20:11 <dons> LoganCapaldo: that might be it. #ruby-lang has also shrunk down too
16:20:25 <thetallguy> igloo: di dyou get my message about Debian packaging?
16:20:34 <joelr1> ChilliX: what version do you build head with?
16:20:34 <ChilliX> joelr1: forget what I said...
16:20:54 <ChilliX> joelr1: just tried the ghci of the version in the tar file I posted the link off, works fine
16:21:11 * ChilliX got too many copies of ghc build lying around and gets confused.
16:21:19 <ChilliX> now testing a compile
16:21:20 <LoganCapaldo> How do you count? According to my irc client #ruby-lang has 390 and #haskell has 374.
16:21:22 <Igloo> thetallguy: Hi, yes. Thanks for the offer, but it's not really something that can be split up easily. I hope to get to it in the next day or two
16:21:29 <Karle> I would like to get help, if anyone is free
16:21:36 <joelr1> ChilliX: so what version do you build head with?
16:21:58 <thetallguy> igloo: okay, let us know if we can help.
16:22:21 <Igloo> OK, will do, thanks!
16:22:41 <ChilliX> joelr1: ok, compiling and running hello world is fine too, no _environ problem
16:22:59 <joelr1> ChilliX: knock-knock
16:23:08 <ChilliX> joelr1: re build compiler, same deal as you, 6.6.1 build on tiger
16:23:08 <dcoutts> @seen ndm
16:23:08 <lambdabot> I saw ndm leaving #haskell 7h 48m 7s ago, and .
16:23:13 <ChilliX> (from macports)
16:23:37 <dcoutts> @tell ndm I've got a new hoogle.txt db for gtk2hs, do I give it to you or what?
16:23:37 <lambdabot> Consider it noted.
16:23:46 <joelr1> ChilliX: right
16:23:59 <ChilliX> joelr1: so, please really try that bindist of mine.  It all seems to work on my box.
16:24:15 <paczesiowa> is it possible to write parser with parsec so that ghci segfaults when parsing? or safe code (without unsafePerform*) will never segfault
16:24:16 <ChilliX> HEAD also runs the validate testsuite fine on Leopard
16:24:42 <joelr1> ChilliX: it's easy to tell if it will or will not work. nm ghc-6.8.1 | grep environ
16:24:49 <ChilliX> joelr1: I take it that you got Xcode 3.0.
16:24:49 <dons> paczesiowa: safe code will  never segfault.
16:24:49 <joelr1> ChilliX: D = will, nothing = won't
16:25:06 <joelr1> ChilliX: i'm about to find out
16:25:08 <dons> paczesiowa: it is always a bug in the compiler or runtime if that happens, sometimes the libraries
16:25:35 <LoganCapaldo> unsafeCoerce# can take you to segfault town right?
16:25:42 <dons> yep.
16:25:52 <dons> it is the C programming combinator
16:25:57 <joelr1> ChilliX: 100% and you?
16:25:58 <ChilliX> EthicsGradient-wl chak 13 (.../Code/haskell): nm ~/Sandbox/src/ghc-6.8.1/compiler/stage2/ghc-6.8.1 |grep environ
16:25:58 <ChilliX> 00a53660 T ___hscore_environ
16:25:58 <ChilliX> 00ba8004 D _environ
16:26:28 <joelr1> ChilliX: how did you tell i got 3.0?
16:26:28 <ChilliX> but works just fine
16:26:40 <paczesiowa> I had ghc-6.8.1 compiled with 6.6.1 and it was ok (at least since yesterday), now I recompiled ghc 6.8.1 with 6.8.1 and ghci segfaults
16:26:56 <ChilliX> joelr1: If you haven't got 3.0, nothing would work, even gcc fell over on my box with missing link symbols
16:26:58 <sethk> ChilliX, I got a link error when I was compiling stage1/gcc-6.8.1, __DISKARD__.  Ring any bells?
16:27:02 <hpaste>  Karle pasted "please help a newbie" at http://hpaste.org/3674
16:27:11 <sethk> ChilliX, that is, __DISKARD__ undefined.
16:27:45 <joelr1> ChilliX: is it sanctioned to build head with 6.8.1 now?
16:27:58 <ChilliX> sethk: that sounds line oen of these mangler marks wasn't discarded
16:28:23 <joelr1> ChilliX: your version works perfectly fine. wth?
16:28:29 <sethk> ChilliX, indeed, but then why am I seeing it and others not?
16:28:34 <faxathisia> Karle: What are all the type definition?
16:28:44 <sethk> ChilliX, I'm upgrading my gcc to the most recent version, and trying again.
16:28:56 <ChilliX> joelr1: works? great! Then, I'll aks Igloo to put it up on the ghc download page
16:29:12 <joelr1> ChilliX: is it kosher to build head with 6.8.1 now?
16:29:14 <ChilliX> sethk: you got leopard?  what arch?
16:29:14 <hpaste>  Karle annotated "please help a newbie" with "please help a newbie" at http://hpaste.org/3674#a1
16:29:21 <ChilliX> joelr1: that I didn't try yet
16:29:31 <joelr1> allright
16:29:41 <sethk> ChilliX, Initially I'm just building on a Linux box, which is why it's strange that I see something like this.
16:29:52 <faxathisia> Karle: look pkg is (Pkgtype,Address,Payload), which doesn't match with [a]
16:30:03 <ChilliX> sethk: very strange, any fancy build options?
16:30:19 <gwern> bleh. man, I give up. I can't get the sume-file benchmark any faster. damn clean program, mocking my efforts to translate into haskell...
16:30:38 <sethk> ChilliX, no, none at all.  I have 6.6.1 installed and I simply did ./configure.  That's why I thought maybe my gcc installation was borked.
16:30:54 <ChilliX> what does gcc --version say?
16:31:06 <ChilliX> If it is gcc 4.2, there were some issues with that IIRC
16:31:10 <sethk> ChilliX, 4.1.1.  I'm installing 4.2.1.
16:31:26 <sethk> ChilliX, there are issues with almost all the gcc releases.  :)
16:31:46 <Karle> faxathisia, more details please
16:31:49 <ChilliX> sethk: Can you try the following?
16:32:04 <sethk> ChilliX, only if you tell me what the following is   :)
16:32:14 <faxathisia> Karle: I don't know any more
16:32:16 <ChilliX> seth: create a file mk/build.mk and add just one line saying: SplitObjs       = NO
16:32:20 <faxathisia> Karle: probably scanU
16:32:32 <bos> dcoutts: ping
16:32:36 <bos> @seen dcoutts
16:32:36 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 6s ago.
16:32:37 <ChilliX> then build from scratch (ie, make distclean beforehand)
16:32:39 <dcoutts> bos: pong
16:32:46 <bos> dcoutts: any plans for a gtk2hs release soon?
16:32:53 <joelr1> ChilliX: what's your gcc version? mine is 4.0.1 for some reason
16:32:56 <sethk> ChilliX, ok, then what?  Repeat configure?  Do make?  Do make clean and then make?
16:33:01 <dcoutts> bos: testing it as we speak
16:33:10 <bos> i'd like there to be a zero-day build of ghc 6.8.1 when fedora 8 comes out in 3 days
16:33:17 <ChilliX> joelr1: i686-apple-darwin9-gcc-4.0.1 (GCC) 4.0.1 (Apple Inc. build 5465)
16:33:23 <dcoutts> bos: hmm?
16:33:30 <joelr1> ChilliX: identical
16:33:31 <bos> but i need a buildable gtk2hs or i can't upgrade ghc
16:33:34 <joelr1> @localtime ChilliX
16:33:35 <lambdabot> Local time for ChilliX is 2007-11-06 11:33:35 +1100
16:33:40 <ChilliX> This is the one which is on the Leopard upgrade dvd and in the Xcode bundle that you get from ADC
16:34:21 <dcoutts> bos: ok, can I send you a gtk2hs tarball for you to test? It's marked 0.9.12.1 but is not the official final tarball yet.
16:34:23 <joelr1> ChilliX: exactly what i have. makes me wonder why my results were different and _environ was undefined
16:34:34 <bos> dcoutts: yes, sure
16:34:38 <Karle> faxathisia, scanU :: (a -> Int) -> (a -> [b] -> a) -> a -> Signal b -> Signal a
16:35:02 <faxathisia> Karle: what is  Signal ?
16:35:12 <sethk> ChilliX, I'll extract into a clean directory; I'm never 100% sure about any distclean.  :)
16:35:42 <faxathisia> Karle: oh well doesn't matter
16:35:50 <Karle> faxathisia, NullS :: Signal a
16:35:51 <Karle> (:-) :: a -> Signal a -> Signal a
16:35:57 <faxathisia> Karle: I think the problem is you pass update as the parameter (a -> [b] -> a)
16:36:03 <dcoutts> bos: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.tar.gz
16:36:05 <faxathisia> Karle: but update has type Table-> Pkg-> Table
16:36:08 <oerjan> Karle: i _already_ told you that update_pr needs to use an updateLL2 :: Table -> [[(Pkg,Pkg)]] -> Table, and told you partly how to write it.
16:36:13 <faxathisia> Karle: and Pkg is not the same as [b]
16:36:56 <Karle> oerjan, yes
16:37:24 <bos> dcoutts: grabbing it now
16:38:39 <Karle> oerjan, so I have no other way? :(
16:39:06 <bos> dcoutts: what will the final version number be?
16:39:07 <joelr1> how do i tell ghc that gcc needs -framework GMP ?
16:39:24 <dcoutts> bos: same
16:39:25 <oerjan> i doubt it.
16:39:50 <joelr1> never mind
16:39:51 <hpaste>  Paczesiowa pasted "ghci segfaults" at http://hpaste.org/3675
16:40:08 <Karle> oerjan, alright!
16:40:14 <ChilliX> joelr1: quick look at google reveals that lots of people have problems with _environ with all kinds of builds, seems to be a BSD thing
16:40:28 <joelr1> right
16:40:40 * joelr1 is building HOC with ghc 6.8.1
16:40:51 <joelr1> i want to write mactrades, dammit!
16:41:56 <ChilliX> joelr1: Do you have a GMP framework lying around?
16:42:04 <joelr1> ChilliX: 100%
16:42:09 <ChilliX> That's it I guess.
16:42:20 <ChilliX> It's linked against the old clib
16:42:24 <ChilliX> libc that is
16:42:41 <ChilliX> the ghc build checks for the GMP framework and uses that instead of the inplace gmp if it is avail
16:42:47 <ChilliX> I don't have a GMP framework
16:42:50 <ChilliX> just ditch it
16:42:52 <joelr1> ChilliX: aha
16:43:21 <joelr1> ChilliX: i can always get it back with time machine ;-)
16:43:25 <Karle> Is there any similar functions to foldl'?
16:43:41 <oerjan> :t foldr
16:43:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:43:54 <joelr1> ugh oh, gotta rebuild darcs now
16:43:54 <ChilliX> joelr1: It's not very useful on 10.5 anymore.  (That version, I mean.)
16:44:00 <oerjan> also foldl but you usually don't want it, foldl' was an improvement to it
16:44:11 <joelr1> ChilliX: i just screwed up my darcs
16:44:19 <ChilliX> oh
16:44:20 <Karle> thanks
16:44:29 <oerjan> and lots of stranger functions in Data.List
16:44:33 <oerjan> @docs Data.List
16:44:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
16:44:43 <joelr1> hehe
16:45:06 <sethk> ChilliX, OK, I did a fresh extraction, and created mk/build.mk and copied the SplitObjs = NO line from build.mk.sample (to eliminate the possibility of my fat fingering it).
16:45:22 <sethk> ChilliX, Now you want me to do the usual, i.e., ./configure, make?
16:45:37 <Karle> cannot open the page ... page not found
16:46:12 <ChilliX> sethk: yes
16:46:31 <sethk> ChilliX, ok, configuring.  I'll capture the output in case it is of interest.
16:46:41 <ChilliX> ok
16:46:52 <oerjan> Karle: oops. must have been moved in the ghc 6.8.1 release.
16:47:29 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
16:47:31 <lambdabot> http://tinyurl.com/22sg7z
16:47:38 <paczesiowa> should I report this bug http://hpaste.org/3675 ?
16:48:01 <oerjan> and the large list of modules is where it always was
16:48:03 <oerjan> @docs
16:48:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:48:22 <joelr1> has anyone tried to build darcs with 6.8.1 on leopard?
16:49:07 <oerjan> (an even larger list of packages that don't necessarily come with ghc is at hackage)
16:49:11 <oerjan> @hackage
16:49:11 <lambdabot> http://hackage.haskell.org
16:49:22 <joelr1> ChilliX: when i try to build HOC it's looking for gmp.h. where do i get it from now that i blew away the GMP framework?
16:50:08 <Karle> thanks oerjan
16:50:22 <ChilliX> Hmm, why would it look for gmp.h?
16:50:55 <ChilliX> If you really need it, you'll need a 10.5 version of it in any case.
16:51:27 <joelr1> ChilliX: beats me. actually, this is what it says: /usr/local/lib/ghc-6.8.1/include/Regs.h:30:45:
16:51:27 <joelr1>      error: gmp.h: No such file or directory
16:51:35 <joelr1> ChilliX: rings a bell?
16:53:51 <joelr1> andyjgill: hi
16:54:11 <andyjgill> hi joelr1
16:56:07 <joelr1> andyjgill: how is haskell on the bare metal?
16:57:26 <monochrom> There is really no metal in bare metal, is there?
16:57:50 <ChilliX> joelr1: no, maybe a case of ghc not installing all its headers... *sigh*
16:59:04 <joelr1> ChilliX: well, i have gmp from macports. will try that.
16:59:55 <ChilliX> joelr1: hmm, maybe not ghc's fault, I just compiled and ran a program using Integer with the 6.8.1 I gave you and it works fine...hmm, but I used the inplace compiler
17:00:45 <hpaste>  ChilliX pasted "test use of Integer" at http://hpaste.org/3676
17:00:57 <joelr1> ChilliX: it definitely did _not_ install gmp.h whereas 6.6.1 has it
17:01:21 <ChilliX> joelr1: Can you just compile and run the program I just hpasted with your 6.8.1 install?
17:02:07 <joelr1> ChilliX: ld: library not found for -lgmp
17:02:23 * ChilliX sighs
17:02:28 <joelr1> ChilliX: do i need to rebuild from scratch as opposed to using your binary version?
17:02:41 <joelr1> ChilliX: rebuild now that i don't have the gmp framework that is
17:02:42 <ChilliX> No, you shouldn't
17:03:12 <ChilliX> Is there something like linux ldd on macos?
17:03:48 <ChilliX> I guess, it is a matter of a botched install script...
17:03:51 <joelr1> ChilliX: sure. otool -L
17:03:55 <scsibug> joelr1 and ChilliX:  I was able to run that program, and I note that 6.8.1 did not install any gmp headers (where 6.4 and 6.6 did)
17:03:55 <lambdabot> scsibug: You have 1 new message. '/msg lambdabot @messages' to read it.
17:04:20 <joelr1> scsibug: do you have the gmp framework installed?
17:04:37 <scsibug> I have GMP.framework installed
17:04:50 <joelr1> scsibug: where did you get the leopard version?
17:04:57 <ChilliX> scsibug: GMP.framework on leopard?
17:05:09 <scsibug> errr, i'm on my 10.4 box, let me check on leopard
17:05:18 <joelr1> hehe
17:05:33 <ChilliX> 10.4 is sooo boring ;)
17:05:50 <joelr1> now everything is complaining about -lgmp
17:06:04 <scsibug> yep, same on both, GMP.framework
17:06:18 <ChilliX> joelr1: What you can do, I guess, is build 6.8.1 from source now that GMP.framework is goneadn use the *inplace* version of that
17:06:29 <scsibug> where did I get it?  I had the same version on 10.4
17:07:03 <joelr1> scsibug: yep, what i had before i blew it away. strange you didn't get the _environ issue
17:07:46 <scsibug> nope, and i've compiled several major packages and done some work, no problems
17:08:04 <joelr1> ChilliX: do i need to make distclean?
17:08:21 <joelr1> ChilliX: or will a simple ./configure && make do it?
17:08:39 <scsibug> joelr1: you might want to look into changing build.mk to speed up compilation
17:08:51 <joelr1> scsibug: how
17:08:53 <scsibug> (instructions in mk/build.mk.sample)
17:09:29 <joelr1> scsibug: what exactly did _you_ change, though?
17:09:43 <scsibug> what did I change where? in build.mk?
17:09:49 <ChilliX> joelr1: I'd try just configure and make
17:09:50 <joelr1> scsibug: yes
17:10:21 <joelr1> ChilliX: the first thing it did, it looks like, is untar gmp
17:10:31 <scsibug> copy mk/build.mk.sample to mk/build.mk, and uncomment the line "BuildFlavour = quickest"
17:10:54 <ChilliX> joelr1: re unpacking gmp, that's good
17:11:01 <joelr1> ChilliX: and then Linking ghc-pkg-inplace ...ld: library not found for -lgmp
17:11:13 <joelr1> scsibug: thanks
17:11:32 <ChilliX> joelr1: that's less good
17:11:52 <joelr1> ChilliX: distclean?
17:12:34 <joelr1> ChilliX: actually, i'm building 6.8.1 with same. could be the problem.
17:14:17 <joelr1> ChilliX: rebuilding with 6.6.1 now
17:14:40 <ChilliX> ok
17:16:19 <ChilliX> joelr1: I may have a solution for you
17:16:35 <ChilliX> the .tar.bz2 contains the right gmp, it's just not installed
17:16:41 <ChilliX> but you can copy it manually
17:16:55 <ChilliX> cp gmp/libgmp.a $prefix/lib/ghc-6.8.1
17:17:11 <ChilliX> and probably need the header, too
17:17:24 <joelr1> ChilliX: i'll try that if this build fails
17:17:42 <glguy> Has anyone else seen the "unknown scattered relocation" message when building ghc 6.8.1?
17:18:08 <glguy> as generated by ghc-inplace
17:18:20 <tunnuz> hi all
17:18:30 <tunnuz> can I make a question? I'm pretty new to Haskell
17:18:45 <glguy> go for it
17:18:50 <tunnuz> thanks
17:18:56 <tunnuz> i have three lines of code to paste
17:19:04 <tunnuz> my GHC is giving me an error
17:19:05 <tunnuz> on this
17:19:13 <tunnuz> es6c []     = []
17:19:13 <tunnuz> es6c (x:xs) =   foldl f [(x,0)] xs
17:19:13 <tunnuz>                 where f z [] = z
17:19:13 <tunnuz>                       f [(p,s)] y = (p,s):[(y,s+p)]
17:19:29 <tunnuz> it says
17:19:36 <tunnuz> <tunnuz> es6c []     = []
17:19:36 <tunnuz> <tunnuz> es6c (x:xs) =   foldl f [(x,0)] xs
17:19:36 <tunnuz> <tunnuz>                 where f z [] = z
17:19:36 <tunnuz> <tunnuz>                       f [(p,s)] y = (p,s):[(y,s+p)]
17:19:39 <tunnuz> no wait
17:19:40 <tunnuz> sorry
17:19:43 <tunnuz> it says
17:19:45 <dmwit> ?hpaste
17:19:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:19:54 <dmwit> Use that, please?
17:19:56 <tunnuz> thanks
17:20:19 <hpaste>  tunnuz pasted "(no title)" at http://hpaste.org/3677
17:20:29 <tunnuz> ok that's it
17:20:40 <tunnuz> it's an university exercise, i think it should run
17:20:52 <tunnuz> it compiles but when i try to run it on a list of numbers
17:20:55 <tunnuz> it gives me the error
17:21:07 <dmwit> :t foldl
17:21:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:21:54 <monochrom> I wonder why not f [] z = z
17:22:33 <dmwit> tunnuz: This has a very strange type, what is it supposed to do?
17:22:51 <tunnuz> it is supposed to take a list of numbers
17:23:06 <tunnuz> and return a list of couples
17:23:07 <newsham> tunnuz: do you want f [(p,s)] y = (p,s):[(y,s+p)] ?
17:23:18 <newsham> thats a single item list with (p,s) in it
17:23:25 <newsham> or do you want a list with (p,s) as the head and a possible tail?
17:23:37 <dmwit> Yeah, I think you have lists in several places that aren't appropriate.
17:23:37 <tunnuz> the second
17:23:51 <tunnuz> ah ok
17:23:55 <newsham> that's written:  ((p,s):rest)
17:24:21 <dmwit> What is a couple?
17:24:33 <dancor> @code sum
17:24:34 <lambdabot> Maybe you meant: more todo vote
17:24:35 <newsham> > let ((p,s):rest) = [(1,2), (3,4), (5,6)] in p
17:24:38 <lambdabot>  1
17:24:39 <newsham> > let ((p,s):rest) = [(1,2), (3,4), (5,6)] in rest
17:24:41 <lambdabot>  [(3,4),(5,6)]
17:24:42 <dmwit> ?src sum
17:24:42 <lambdabot> sum = foldl (+) 0
17:25:02 <joelr1> ChilliX: is the [: .. :] array syntax in 6.8.1 ?
17:25:06 * dmwit gasps
17:25:07 <monochrom> probably couple = 2-tuple
17:25:10 <dmwit> Not foldl'?
17:25:24 <dmwit> monochrom: Yes, but of what? element and current sum, maybe?  Or adjacent elements?
17:25:34 <tunnuz> element
17:25:40 <tunnuz> and previous elements' sum
17:25:49 <dmwit> tunnuz: Okay.
17:25:54 <tunnuz> wait
17:25:56 <tunnuz> i don't want the solution
17:26:02 <dmwit> How much of the Prelude are you allowed to use?
17:26:03 <tunnuz> because it's an university exercise
17:26:06 * monochrom resists to state a true but socially-considered-rude statement.
17:26:13 <dmwit> Yes, I won't give away solutions.
17:26:17 <tunnuz> i want to understand
17:26:22 <tunnuz> i can use
17:26:24 <ddarius> monochrom: Go for it
17:26:25 <tunnuz> foldl
17:26:27 <dmwit> (Nobody here will.)
17:26:30 <tunnuz> (.)
17:26:44 <tunnuz> the basic operators
17:26:46 <ddarius> The solution is 42!
17:26:52 <dmwit> tunnuz: zip?
17:27:00 <monochrom> > product [1..42]
17:27:02 <lambdabot>  1405006117752879898543142606244511569936384000000000
17:27:15 <tunnuz> dmwit, better if i don't use zip
17:27:21 <dmwit> > let (*) = (const (const 42)) in 6 * 9
17:27:21 <tunnuz> because it's another exercise
17:27:22 <ChilliX> joelr1: yes, but vectorisation is not fully implemented yet; ie, you can use the syntax to play around with it, but it won't parallelise or be very fast
17:27:22 <lambdabot>  42
17:28:09 <dmwit> tunnuz: Okay.  So tell me in English what you were shooting for with the "f" helper function?
17:28:17 <joelr1> ChilliX: ok, still rebuilding ghc
17:28:20 <glguy> are we intentionally avoiding the library function that does exactly this traversal?
17:28:45 <dmwit> oh!
17:28:49 <dmwit> heh
17:28:56 <dmwit> tunnuz: Are you allowed the scan functions?
17:28:57 <joelr1> ChilliX: i want to use the haskell cocoa bindings and roll out a trading app. that's mostly array processing, though (time series)
17:29:00 <tunnuz> dmwit: no
17:29:05 <dmwit> glguy: yep
17:29:19 <newsham> btw, defining "f" as a helper function is nicer from a data hiding point of view, but for exploration its easier if you define it as a separate function
17:29:30 <newsham> so you can play with it and test it interactively on its own
17:29:32 <glguy> cool, then this doesn't give anythign away !
17:29:38 <tunnuz> ok
17:29:49 <joelr1> ChilliX: i'm hoping i'll get decent results from 6.8.1, although  i'm already tearing my hair out just by thinking about gc pressure
17:29:58 <dmwit> Yes, you should test that "f" really does what you think it does. =)
17:30:38 <ChilliX> joelr1: wow sounds cool
17:30:50 <joelr1> ChilliX: and that's not even in 64-bit mode
17:31:10 <glguy> > let f xs = zip xs $ scanl1 (+) xs in f [1,2,3,4,5]
17:31:11 <ChilliX> gc pressure?  You think you'll have too much gc overhead?
17:31:11 <lambdabot>  [(1,1),(2,3),(3,6),(4,10),(5,15)]
17:31:45 <joelr1> ChilliX: always happens to me for some reason. it's also x2 with 64 bits
17:31:52 <dmwit> > let f xs = zip xs $ scanl (+) 0 xs in f [1, 2, 3, 4, 5]
17:31:54 <lambdabot>  [(1,0),(2,1),(3,3),(4,6),(5,10)]
17:32:07 <glguy> > let f = zip `ap` scanl1 (+) in f [1,2,3,4,5]
17:32:08 <lambdabot>  [(1,1),(2,3),(3,6),(4,10),(5,15)]
17:32:39 <joelr1> ChilliX: btw, had to distclean and configure and rebuild again since something complained about missing the gmp framework
17:33:10 <dataangel> I understand what it means for a function to be strict, but what does it mean for a type to be strict?
17:33:21 <ChilliX> joelr1: ok
17:33:51 <ChilliX> btw, it seems that the bindist makefile just misses an invocation of the Makefile in the gmp/ subdir...
17:34:00 <LoganCapaldo> dataangel: if it helps, constructors are just functions
17:34:09 <LoganCapaldo> @type Just
17:34:10 <lambdabot> forall a. a -> Maybe a
17:34:30 <ChilliX> I'll try whether that fixes the issue.
17:34:40 <dmwit> > let f = scanl (\(_, sum) x -> (x, sum+x)) in f [1..5]
17:34:41 <lambdabot>  Couldn't match expected type `(b, b)' against inferred type `[a]'
17:34:52 <dmwit> > let f = scanl (\(_, sum) x -> (x, sum+x)) (0, 0) in f [1..5]
17:34:53 <lambdabot>  [(0,0),(1,1),(2,3),(3,6),(4,10),(5,15)]
17:35:08 <joelr1> ChilliX: great. i'll hold out for another 30 minutes, hopefully the quickest build will finish by then
17:35:13 <faxathisia> Does anyone know a bit about Monad transformers I have a question
17:35:15 <joelr1> @localtime joelr1
17:35:17 <lambdabot> Local time for joelr1 is 2007-11-06 01:35:16 +0000
17:35:20 <dataangel> LoganCapaldo: I get that, but types themselves aren't functions. From the IO inside wiki article, "The RealWorld type is an abstract datatype, so pure functions also can't construct RealWorld values by themselves, and it's a strict type, so 'undefined' also can't be used." Having trouble imagining a non-strict type :P
17:35:37 <dmwit> tunnuz: How you doing?  Getting closer?
17:36:01 <tunnuz> something like that
17:36:12 <tunnuz> i'm editing the second branch of the f function
17:36:26 <tunnuz> because when I tried to use it out of its context
17:36:26 <dmwit> ok
17:36:30 <tunnuz> it returned an error
17:36:33 <dmwit> heh
17:36:46 <dmwit> What should f accomplish, if you write it correctly?
17:37:44 <tunnuz> take a list with a 2-tuple insiede
17:37:50 <tunnuz> s/insiede/inside
17:37:57 <tunnuz> and an integer
17:38:05 <tunnuz> and create the list
17:38:31 <tunnuz> [(p,s),(y,s+p)]
17:38:52 <dmwit> 1. Why should the input be in a list?
17:39:12 <tunnuz> because the other branch of the function produces a list
17:39:13 <Saizan_> dataangel: undefined inhabits all types, but there are some special types often called unboxed for which this is not true, it's an implementation issue/ghc internal
17:39:16 <dmwit> 2. Why is the output like that?  How will this function be used?
17:39:31 <dmwit> tunnuz: Okay, but *should* the other branch produce a list?
17:39:36 <dmwit> What is the goal of this function?
17:39:44 <sethk> ChilliX, the build with split NO is continuing.  I'm not sure whether I've reached the point where the error originally occurred, but so far so good.
17:39:48 <tunnuz> yes, because i have to concatenate it to create a longer list
17:39:53 <tunnuz> dmwit, the f function?
17:39:55 <dmwit> yeah
17:40:26 <tunnuz> well
17:40:35 <tunnuz> because it's evaluated inside a foldl
17:41:00 <tunnuz> at the end
17:41:07 <ChilliX> sethk: that's at least encouriging :)
17:41:12 <tunnuz> it should make
17:41:37 <tunnuz> from [1,2,3,4] ==> (1,0) (2,1) (3,3) (4,6)
17:41:45 <tunnuz> (element, sum of the previous)
17:41:57 <dmwit> tunnuz: I think you may misunderstand the fold function.
17:42:10 <tunnuz> mmm
17:42:15 <dmwit> Let's talk about it.
17:42:17 <tunnuz> it is possible
17:42:35 <dmwit> The fold function, at heart, transforms an input list to an output list; I'll call these in and out respectively.
17:42:42 <dmwit> sorry
17:42:43 <dmwit> that's wrong
17:42:46 <tunnuz> yes
17:42:50 <chessguy> very wrong :)
17:42:52 <tunnuz> list --> single value
17:42:55 <dmwit> yes
17:43:00 <dmwit> that's right
17:43:02 <dmwit> =)
17:43:04 <newsham> where single value could be a list :)
17:43:09 <LoganCapaldo> > isJust (Just (error "non-strict"))
17:43:17 <lambdabot>  True
17:43:24 <tunnuz> calling recursively a function f on a "zero" value z and on an element of the input list
17:43:37 <dmwit> The fold function, at heart, "accumulates" a value by looking at each element in a list.
17:43:43 <tunnuz> yes!
17:43:54 <dmwit> Okay, so let's say our accumulator is a list.
17:43:58 <dmwit> (as in your case)
17:44:00 <tunnuz> yes
17:44:13 <tunnuz> (a list of 2-tuples, in my case)
17:44:27 <dmwit> Now, the helper function "f" should take the current value of the accumulator, and *one* element of the list, and produce a new value for the accumulator.
17:44:44 <tunnuz> yes
17:44:44 <dmwit> Good so far?
17:44:47 <dmwit> Cool.
17:44:49 <tunnuz> good
17:44:49 <tunnuz> :P
17:45:09 <tunnuz> that's the reason because the output of my f function is always a list
17:45:25 <dmwit> So, the inputs to f are a list like ((a, b):moreTuples) and an element.
17:45:29 <dmwit> tunnuz: right
17:45:43 <dmwit> I'm slowly catching up to your implementation idea. =)
17:45:51 <Cale> http://cale.yi.org/autoshare/canhaspoly.jpeg
17:45:55 <tunnuz> :) thank you
17:46:13 <faxathisia> tunnuz: how did you generate it
17:46:15 <faxathisia> > zip [1..4] (let x = (1:2:(zipWith (+) x (tail x))) in take 4 x)
17:46:16 <lambdabot>  [(1,1),(2,2),(3,3),(4,5)]
17:46:17 <faxathisia> not like this
17:46:21 <glguy> Cale: that looks like a staged photo!
17:46:29 <dmwit> faxathisia: Apparently, no zips or scans.
17:46:32 <glguy> I bet your cat wasn't interested in reading chapter 30
17:46:49 <tunnuz> faxathisia, not like this
17:46:51 <dmwit> tunnuz: Okay, let's look at your base case.
17:46:57 <dmwit> f z [] = z
17:46:58 <faxathisia> tunnuz: your list was
17:46:59 <chessguy> glguy, i could see Cale owning a cat that reads out of TAPL
17:46:59 <newsham> the cat doesnt know that "30" is not ω over 0
17:46:59 <tunnuz> dmwit, that's ok
17:47:04 <faxathisia> [(1,1),(2,2),(3,3),(4,6)]
17:47:06 <faxathisia> what's that 6?
17:47:29 <tunnuz> should be [(1,0),(2,1),(3,3),(4,6)]
17:47:30 <faxathisia> ach nothing
17:47:32 <faxathisia> ok
17:47:34 <dmwit> tunnuz: No, you have it backwards.
17:47:40 <dmwit> Look at the type of foldl:
17:47:41 <dmwit> :t foldl
17:47:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:47:49 <tunnuz> yes
17:47:54 <tunnuz> ah ok
17:47:57 <dmwit> Here, b = Int (say), and a = (Int, Int).
17:47:58 <newsham> you're taking   (3,3) and generating   (3+1, 3+3) ?
17:48:11 <dmwit> err
17:48:16 <dmwit> a = [(Int, Int)]
17:48:25 <tunnuz> yes
17:48:33 <tunnuz> no wait
17:48:39 <dmwit> So, the *first* argument to f should be a list, and the second argument should be an int.
17:48:42 <newsham> you take  (a,b) and c  and generate ... ?
17:48:51 <tunnuz> dmwit, yes
17:49:16 <dmwit> That's part one of why the type for f looks so screwy. =P
17:49:31 <dmwit> Now let's have a look at the inductive case for f.
17:49:45 <dmwit> Just for simplicity, I think we should generate the list you want in reverse, okay?
17:49:45 <tunnuz> dmwit, so my base case it's ok, right?
17:50:04 <dmwit> (This puts the most recently calculated value at the front, which is easier to pick off than the back.)
17:50:12 <dmwit> tunnuz: No, I think your base case has got its arguments in reverse.
17:50:12 <tunnuz> dmwit, that's ok
17:50:21 <dmwit> You want f [] z = z, not f z [] = z.
17:50:28 <tunnuz> no wait
17:50:36 <tunnuz> in my first branch
17:50:40 <tunnuz> (base case)
17:50:48 <tunnuz> z is a list
17:50:54 <newsham> the input is what?  [1,2,3,4,5] ?
17:51:01 <dmwit> newsham: yeah
17:51:03 <tunnuz> and [] it's the empty element after the (xs) list has been processed
17:51:18 <newsham> and the initial value is going to be a list with one tuple in it?
17:51:41 <newsham> an empty list?
17:51:41 <dmwit> yeah
17:51:54 <tunnuz> the base case will be run as: f [(x,0)] [] => [(x,0)]
17:52:08 <newsham> so f z [] = z
17:52:10 <dmwit> tunnuz: No it won't.
17:52:11 <newsham> as he said :)
17:52:12 <dmwit> It will be run as
17:52:19 <dmwit> f [(x, 0)] (x, y)
17:52:36 <newsham> dmwit: his input list doesnt have tuples
17:52:37 <dmwit> Gah, I'm getting so confused and wrong.
17:52:49 <newsham> one of his parameters will be a naked integer, yes?
17:52:51 <dmwit> f [(x, 0)] someValueFromTheInputList
17:53:01 <newsham> you're accumulating a list of integers
17:53:04 <dmwit> yes
17:53:05 <tunnuz> exactly
17:53:06 <newsham> so one of your parameters will be an integer
17:53:10 <dmwit> yes
17:53:16 <dmwit> Thank you, newsham.
17:53:27 <tunnuz> dmwit, you're right, but the last element of the input list is [], that's what the base case is written for
17:53:34 <dmwit> Aha!
17:53:39 <dmwit> I see where you're getting confused.
17:53:58 <dmwit> tunnuz: foldl handles the [] base case all by itself; it *only* passes elements to the helper function.
17:54:08 <newsham> ?type foldl
17:54:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:54:18 <newsham> the naked "a" is the base case.
17:54:41 <faxathisia> [(1,0),(2,1),(3,3),(4,6)]  so each (x,y) turns into (x+1, x+y)
17:54:43 <faxathisia> > take 4 $ iterate (\(x,y) -> (x+1, x+y)) (1,0)
17:54:45 <lambdabot>  [(1,0),(2,1),(3,3),(4,6)]
17:54:45 <tunnuz> yes, but [] is, AH OK
17:55:14 <dmwit> f isn't getting lists... it's getting elements!
17:55:16 <newsham> > foldl (\x y -> undefined) "base case" []
17:55:16 <tunnuz> dmwit, i'm puzzled ...
17:55:20 <lambdabot>  "base case"
17:55:32 <dmwit> tunnuz: Go ahead.
17:55:44 <tunnuz> in my opinion
17:56:09 <tunnuz> f is taking a list and then an element (that could be a [])
17:56:13 <newsham> whatever the 2nd arg to foldl is will be what foldl returns when given the empty list
17:56:20 <tunnuz> because, that's right, foldl handles the []
17:56:23 <dmwit> tunnuz: Your elements are not lists, so they cannot have the value [].
17:56:32 <tunnuz> but
17:56:32 <dmwit> tunnuz: Your elements are Ints, so they can only take on Int values.
17:56:33 <newsham> here's where I think you're getting confused.
17:56:40 <tunnuz> > tail [1]
17:56:42 <lambdabot>  []
17:56:42 <newsham> I think you want foldl to return [] as its base case.
17:56:44 <joelr1> ChilliX: i'm unhappy to report that rebuilding from scratch without the gmp framework does not solve the _environ issue. i'll have to follow your bindist recipe. gmp.h did get installed, though.
17:56:54 <dmwit> tunnuz: But, see this:
17:56:56 <dmwit> > head [1]
17:56:57 <newsham> ie the answer to your problem, when given the empty list, is [] ?
17:56:58 <lambdabot>  1
17:57:02 <dmwit> That is a value, and it can never be [].
17:57:08 <dmwit> > head [] -- is an error!
17:57:10 <lambdabot>  Exception: Prelude.head: empty list
17:57:13 <tunnuz> ah ok
17:57:21 <tunnuz> so the first branch of my f it's wrong ...
17:58:01 <oerjan> tunnuz: i think part of your problem is that foldl is not suited to it at all
17:58:08 <dmwit> agreed
17:58:37 <faxathisia> why not use
17:58:37 <faxathisia> iterate (\(x,y) -> (x+1, x+y)) (1,0)
17:59:00 <oerjan> although you probably can manage
17:59:05 <dmwit> faxathisia: It only works for lists like [1..], we want more general lists to work too.
17:59:06 <newsham> what is the original problem description?
17:59:35 <newsham> http://arcanux.org/lambdacats.html
17:59:36 <lambdabot> Title: Lambdacats
17:59:42 <newsham> oops, wrong channel
17:59:58 <dmwit> There is no wrong channel for \cats!
18:00:09 <newsham> no point preaching to the choir
18:01:10 <oerjan> the reason being that passing from es6c [1,2,3] to es6c [1,2,3,4], say, is _not_ a simple operation
18:01:35 <oerjan> it modifies the list at the wrong end
18:02:05 <dmwit> :t scanl -- probably closer to what you want
18:02:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:02:19 <faxathisia> > foldl (\x y -> x ++ [(y,(snd (last x))+(fst (last x)))]) [(1,0)] [2,3,4]
18:02:19 <tunnuz> YAHOOOOOOO
18:02:20 <lambdabot>  [(1,0),(2,1),(3,3),(4,6)]
18:02:22 <tunnuz> I DID IT!!!
18:02:26 <dmwit> tunnuz: Great!
18:02:40 <tunnuz> no wait
18:02:49 <tunnuz> executed the wrong function lol
18:02:54 <tunnuz> es6 instead of es6b
18:02:58 <tunnuz> ^^
18:02:59 <faxathisia> tunnuz: is that what you watned to do?
18:03:11 <dmwit> scanl :: ((Int, Int) -> Int -> (Int, Int)) -> (Int, Int) -> [Int] -> [(Int, Int)]
18:03:11 <tunnuz> es6 it's done with tail recursion and accumulator
18:03:19 <tunnuz> but i have to do it with foldl
18:03:23 <faxathisia> tunnuz: hello?
18:03:24 <dmwit> Aha.
18:03:25 <oerjan> i see
18:03:43 <tunnuz> faxathisia, yes, that's it, but more flexible
18:03:44 <Cale> tunnuz: what's es6?
18:03:51 <faxathisia> tunnuz: "more flexible"?
18:04:05 <faxathisia> What exactly is it you want to do?
18:04:07 <tunnuz> i have to write a function
18:04:19 <faxathisia> can you hpaste a complete description of the problem please
18:04:28 <tunnuz> that works on ALL lists
18:04:41 <tunnuz> ah ok
18:04:44 <tunnuz> no your solution it's ok
18:04:46 <tunnuz> sorry
18:04:46 <oerjan> infinite ones too? then foldl _cannot_ do it
18:05:05 <tunnuz> oerjan :P
18:05:37 <tunnuz> faxathisia, the problem is that i have already solved it as you did, but the description said: 1 foldl, no ++
18:05:38 <faxathisia> tunnuz: How are you getting on?
18:05:40 <newsham> you might think oerjan is joking... but he's not :)
18:05:47 <dmwit> If I make a module Rabbit.Vector, should it be in Rabbit/Vector.hs or Rabbit/Vector/Vector.hs?
18:05:55 <newsham> > map (*3) [1..]
18:05:57 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
18:06:05 <newsham> there are functions that work well on infinite lists
18:06:30 <faxathisia> tunnuz: It's trivial to remov the ++
18:06:32 <faxathisia> > reverse $ foldl (\x y -> (y,(snd (x!!0))+(fst (x!!0))):x) [(1,0)] [2,3,4]
18:06:33 <lambdabot>  [(1,0),(2,1),(3,3),(4,6)]
18:06:33 <oerjan> and indeed the scanl version of your function does so
18:06:46 <Cale> > foldr (\x xs -> x : map (+x) xs) [] [1..]
18:06:47 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
18:06:58 <newsham> fax: are you doing his homework?
18:07:18 <faxathisia> tunnuz: and you can use pattern matching to imrpvoe it reverse $ foldl (\ x@((a,b):xs) y -> (y,a+b):x) [(1,0)] [2,3,4]
18:08:13 <oerjan> i would say unless the teacher has a perverse mind, reverse wouldn't be allowed if ++ isn't
18:08:26 <tunnuz> oerjan, true
18:08:26 <faxathisia> afaict the teacher is setting bad tasks
18:09:33 <oerjan> as far as i can see, writing your f itself will require a recursion
18:09:36 <ac> is there a mod_haskell like project for GHC?
18:09:36 <faxathisia> newsham: was trying to help (show the problem is stupid), Is that a problem?
18:09:38 <newsham> did the teacher say to use foldl?
18:09:46 <chessguy> dmwit, i think the latter
18:09:57 <newsham> fax: I think you gave him the answer instead of helped him find the answer.
18:09:59 <chessguy> dmwit, err, the former, i mean
18:10:15 <dmwit> chessguy: Thanks.  That was my guess, too, and it seems to work, so... =)
18:10:37 <chessguy> dmwit, because if you were just making a module called Vector, you would name it Vector.hs
18:10:48 <chessguy> not Vector/Vector.hs
18:10:51 <oerjan> or, wait
18:10:58 <oerjan> f requires a foldr
18:11:29 <oerjan> hm, no
18:11:44 <Cale> I can has problem specification?
18:13:03 <newsham> cale: srsly
18:13:05 <oerjan> ok writing f with any folding stuff other than an explicit recursion will be awkward
18:13:30 <Cale> Is the goal writing a function equivalent to reverse $ foldl (\ x@((a,b):xs) y -> (y,a+b):x) [(1,0)] ?
18:13:40 <Cale> er,
18:13:43 <Cale> reverse . foldl (\ x@((a,b):xs) y -> (y,a+b):x) [(1,0)] [2,3,4]
18:13:50 <Cale> grr
18:13:53 <Cale> reverse . foldl (\ x@((a,b):xs) y -> (y,a+b):x) [(1,0)]
18:13:56 <Cale> there we go :)
18:14:02 <oerjan> Cale: there was a zip/scanl version mentioned earlier
18:14:13 <newsham> he hasn't given a proper problem description yet
18:14:19 <faxathisia> I asked him for one :|
18:14:22 <newsham> he has just shown examples of inputs and outputs
18:14:30 <oerjan> the problem is not so much in what function to write as in the stupid restrictions on how to write it
18:14:38 <newsham> and his attempted solution
18:14:47 <oerjan> newsham: well those were clear enough
18:14:50 <faxathisia> If I was in this situation, I would just hand in iterate (\(x,y) -> (x+1, x+y)) (1,0)
18:14:56 <newsham> oerjan: I disagree
18:14:59 <oerjan> faxathisia: that _won't_ work
18:15:13 <oerjan> newsham: they're clear on what the function should _do_
18:15:17 <Cale> If a function has an infinite domain, then it can't be determined by finitely many points. ;)
18:15:28 <newsham> oerjan: still unconvinced.
18:16:09 <newsham> i suspect there may be something lost in translation
18:16:15 <newsham> causing these strange solutions
18:16:41 <newsham> homework tip #1: solve the right problem.
18:16:53 <faxathisia> does anyone have time to try and explain some monad transforming :|?
18:17:13 <newsham> fax: they're like legos that plug together ;-)
18:17:18 <oerjan> newsham: [1,2,3,4] -> [(1,0),(2,1),(3,3),(4,6)]. perfectly clear unless you're being silly.
18:17:44 <faxathisia> oerjan: It's trivial to write, but everytime you -do- write it this guy tunnuz rejects it
18:17:45 <oerjan> newsham: now, afaiu tunnuz has been asked to solve this problem in several different ways
18:18:08 <Cale> is it just   \xs -> zip xs (scanl (+) 0 xs)
18:18:25 <newsham> oerjan: i bet you $1CAD that's not the solution the professor asked to be solved
18:18:41 <oerjan> newsham: ok that is possible
18:18:48 <oerjan> not betting against
18:18:50 <faxathisia> :(
18:19:13 <chessguy> @go 1 canadian dollar in US dollars
18:19:14 <lambdabot> 1 Canadian dollar = 1.058985 U.S. dollars
18:19:23 <newsham> chess: hedging against late payment ;-)
18:20:00 <chessguy> @quote
18:20:00 <lambdabot> heatsink says: @pl (\y -> you y off)
18:20:14 <Cale> @pl (\y -> you y off)
18:20:14 <lambdabot> flip you off
18:20:17 <Cale> heh
18:20:19 <ivanm> heh
18:20:31 <chessguy> @quote flip
18:20:31 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
18:20:34 <faxathisia> or is there any recommended texts?
18:20:39 <oerjan> tunnuz: are you sure you have read the problem correctly? we all think using foldl for this is terribly silly
18:20:40 <faxathisia> because I read various stuff which makes very little sense
18:21:02 <newsham> ?pl (\a -> this a house)
18:21:02 <lambdabot> flip this house
18:21:09 <chessguy> faxathisia, your best bet is to just ask
18:21:20 <chessguy> faxathisia, or google. there are some tutorials out there
18:21:22 <oerjan> because the function you need as a helper is almost as complicated as the real one
18:21:40 <faxathisia> I read tonnes of tutorials though
18:21:48 <Cale> Is tunnuz still here?
18:21:50 <chessguy> faxathisia, so ask your question(s)
18:21:56 <chessguy> @seen tunnuz
18:21:56 <lambdabot> tunnuz is in #haskell. I last heard tunnuz speak 13m 30s ago.
18:22:08 <tunnuz> yep
18:22:10 <tunnuz> i'm here
18:22:24 <Cale> tunnuz: Can we have the actual problem statement?
18:22:24 <tunnuz> oerjan, i'm sure :/
18:22:34 <tunnuz> Cale, it's in Italian
18:22:42 <Cale> I suppose that would be okay
18:23:03 <tunnuz> and the description does not include the various restriction on the commands we should use
18:23:04 <chessguy> i might be able to translate some of it
18:23:07 <oerjan> tunnuz: well then if you are to avoid using ++, reverse, last and anything complicated in f, then you must write it using recursion
18:23:22 <oerjan> i see
18:24:13 <tunnuz> well
18:24:21 <tunnuz> i have two versions
18:24:32 <tunnuz> of the working function
18:24:46 <tunnuz> but they both write the output list in reverse
18:24:59 <newsham> chess: cad is actually $1.0723 today (google's out of date)
18:25:00 <hpaste>  Karle pasted "help again please" at http://hpaste.org/3678
18:25:20 * Cale hopes the Canadian dollar gets to $2.0 USD :)
18:25:36 <faxathisia> Karle: what bout mergE = ++ ?
18:25:45 <newsham> cale: where are you?
18:25:53 <Cale> Canada, of course :)
18:26:01 <newsham> seems people in eur arent too happy about the strength of the EUR
18:26:10 <Cale> (Specifically Brantford, Ontario)
18:26:19 <Cale> I think that's silly.
18:26:20 <oerjan> Karle: i think the second argument to mergeE needs to be of type (Pkgtype,Int,Payload)
18:26:36 <Cale> Having one's currency be worth more can only be a good thing.
18:26:46 <Karle> mergE :: [Pkg] -> [Pkg] -> [Pkg]
18:26:47 <Karle> mergE [pkg1] [pkg2] = [pkg1,pkg2]
18:26:49 <tunnuz> oerjan, do you think that fold(r) would fit?
18:26:58 <oerjan> oh wait
18:27:00 <newsham> depends.  not so good for a healthy manufacturing sector
18:27:08 <Cale> tunnuz: foldr fits *much* better
18:27:19 <newsham> US coulddefinitely use a cheapter currency.  just hope I can get a raise ;-)
18:27:22 <oerjan> tunnuz: i don't think foldr would be better, really
18:27:25 <infrared> hi, i have a program that uses Text.Regexp and i can't compile it. ghc throws errors like: "(.text+0x62): undefined reference to `regexzmbasezm0zi71_TextziRegexziBaseziContext_zdf4_closure'" should i add some flag to ghc to include regexp library?
18:27:38 <tunnuz> lol
18:27:38 <Cale> really? hmm
18:27:42 <kilimanjaro> Cale, except the downside is the price you pay for canadian textbooks fixed at the 1.3 canada / us rate
18:27:49 <tunnuz> ok, now I go to bed, it's 3:30 here
18:27:52 <tunnuz> (AM)
18:27:59 <oerjan> tunnuz: unless you could use map in addition, perhaps
18:28:02 <tunnuz> I let you know if I can solve it!
18:28:18 <oerjan> Karle: misread. what is the type of zipWithU?
18:28:21 <Cale> > foldr (\x xs -> (x,0) : map (second (+x)) xs) [] [1,2,3,4]
18:28:23 <lambdabot>  [(1,0),(2,1),(3,3),(4,6)]
18:28:31 <Cale> looks like a foldr to me
18:28:39 <tunnuz> ^^
18:28:51 <tunnuz> I let you know if I can too.
18:28:56 <tunnuz> bye and thanks
18:29:16 <Cale> Or you could of course nest the foldrs
18:29:39 <newsham> kili: he can get books from amazon.com in US$'s
18:29:49 <tunnuz> bye
18:29:53 <faxathisia> the first thing I don't know is in Parsec, GenParser is an instance of Monad and Parser = GenParser Char () a so is Parser a Monad?
18:29:55 <Cale> > foldr (\x xs -> (x,0) : foldr (\(a,b) ys -> (a,b+x):ys) [] xs) [] [1,2,3,4]
18:29:56 <lambdabot>  [(1,0),(2,1),(3,3),(4,6)]
18:30:05 <newsham> sounds like arbitrage opportunity..
18:30:11 <oerjan> Cale: not at all.  the norwegian central bank is very afraid of NKR getting too strong.  last time it happened a great deal of our industry collapsed because they couldn't export.
18:30:42 <Karle> zipWithU :: Int -> Int -> ([a] -> [b] -> [c]) -> Signal a -> Signal b -> Signal c
18:31:00 <Cale> You could of course export at lower prices.
18:31:18 <Cale> Which would be the same as having your money fall in value, wouldn't it?
18:31:22 <newsham> s'what happened to US manufacturing..
18:31:32 <faxathisia> chessguy: It didn't work
18:31:35 <SamB_XP> yay falling dollar
18:32:10 * SamB_XP goes and repeatedly drops a dollar down the stairs
18:32:20 <oerjan> faxathisia: sure Parser is a monad
18:32:35 * Cale continues working on the Imlib binding
18:32:53 <faxathisia> oerjan: ok thanks
18:32:57 <faxathisia> so now I'm wondering
18:33:15 <monochrom> More precisely, "GenParser t s" is a monad, therefore the special case "Parser" which is "GenParser t s" with t=Char, s=() is a monad.
18:33:34 <faxathisia> monochrom: ok that makes more sense than what it said in the docs
18:33:38 <oerjan> Karle: zipWithU needs two ints as first argument, for some reason
18:33:42 <faxathisia> It's kind of what I imagined
18:33:50 <oerjan> those are missing
18:33:55 <faxathisia> so a Monad transformer can turn any Monad into a new one, right?
18:33:58 <oerjan> *arguments
18:34:02 <dmwit> :t liftM2
18:34:03 <oerjan> faxathisia: right
18:34:04 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:34:07 <monochrom> We have been very sloppy in saying "Either is a monad" when it should be "Either x is a monad", for example.
18:34:18 <faxathisia> What can I do with lifting Parser through LogicT?
18:34:23 <dmwit> :t join
18:34:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:34:28 <faxathisia> like what is the monad I get and how does it work
18:34:36 <faxathisia> (how do I check these things basically)
18:34:44 <dmwit> ?pl f c n -> c (f n) (f n)
18:34:44 <lambdabot> (line 1, column 7):
18:34:44 <lambdabot> unexpected ">" or "-"
18:34:44 <lambdabot> expecting variable, "(", operator or end of input
18:34:46 <faxathisia> That's what I can't figure out
18:34:49 <dmwit> ?pl \f c n -> c (f n) (f n)
18:34:50 <lambdabot> flip =<< (ap .) . flip (.)
18:35:21 <newsham> ?hoogle LogicT
18:35:21 <lambdabot> No matches found
18:36:35 <faxathisia> It's here http://okmij.org/ftp/Computation/monads.html#LogicT
18:36:35 <lambdabot> Title: Monads
18:36:37 <faxathisia> newsham
18:37:51 <Karle> oerjan, merge_pR = zipWithU 1 1 merge  .........looks good?
18:38:09 <newsham> how about something less exotic, like StateT with Parser?
18:38:29 <faxathisia> newsham: I don't know about that either :|
18:38:36 <newsham> do you know State?
18:39:01 <faxathisia> Well I used either State and ErrorT or StateT and Error before
18:39:08 <faxathisia> but like I don't really know why it worked
18:39:47 <newsham> > runState (do x <- get; put x+2; return (3*x)) 5
18:39:48 <lambdabot>   add an instance declaration for (Num (State s ()))
18:39:48 <lambdabot>     In the expression: (...
18:39:57 <newsham> > runState (do x <- get; put (x+2); return (3*x)) 5
18:39:59 <lambdabot>  (15,7)
18:40:20 <newsham> State monad is for gluing together small stateful functions
18:40:30 <newsham> that can "get" the current state, or "put" the current state
18:40:39 <SamB_XP> I used one of those as a fake parser monad
18:40:53 <SamB_XP> it was a dirty hack, though
18:41:16 <newsham> so in that example, we started with a state of 5 (passed into runState).  we fetched it into x, stored x+2 (7), and set the result to 3*x (15).
18:41:33 <newsham> result of runState was the final state (7) and the result value (15)
18:41:37 <newsham> wrapped in a tuple.
18:42:30 <faxathisia> yeah
18:42:56 <newsham> get :: State Int Int;   put :: Int -> State Int ();  return :: Int -> State Int Int
18:42:59 <newsham> in that example
18:43:08 <oerjan> Karle: might be right...  also, mergE needs to be a slightly different type, mergE :: [Pkg] -> [Pkg] -> [[(Pkg,Pkg)]] i think
18:43:26 <newsham> so "StateT" lets you turn some other monad into a monad that also has these same "get" and "put" functions on the embedded state
18:44:15 <newsham> ie:  State Char Int  <- has implicit state Char and result type Int
18:44:21 <faxathisia> do you think like
18:44:28 <faxathisia> State is wrapped around the other monad
18:44:34 <faxathisia> or State is inside the other monad?
18:44:37 <faxathisia> or something like
18:44:41 <newsham> StateT Char Parser Int  <- has implicit state Char, and extends Parser Int
18:45:14 <newsham> I dont know how to answer that question in a non-confusing way :)
18:45:49 <newsham> whereas the type for State was    s -> (a,s)  (for state s and result type a)
18:45:53 <oerjan> faxathisia: i think perhaps inside is the best intuition, since the combined monad is implemented with the initial monad
18:46:17 <newsham> the type for StateT s Parser a will be   s -> Parser (a,s)
18:46:25 <oerjan> also, you cannot escape the initial monad
18:46:37 <newsham> so it will have access to the state, and will return an updated state as part of the Parser result
18:47:05 <monochrom> @unmtl StateT s Maybe
18:47:05 <lambdabot> err: Unknown MTL(1)
18:47:07 <Karle> when I fix one problem it leads to another ... fix the other leads back to the first problem
18:47:39 <faxathisia> newsham: ok I think I follow
18:48:29 <newsham> in this example, you could use such a thing (I believe) to accumulate a symbol table in the state while you parsed
18:49:56 <infrared> damn, i can't even compile that thing..
18:50:48 <newsham> the idea I think is fairly simple.  there are some minor details you have to keep track of like in order to run your StateT thing you need to combine the function for running the Parser with the run function for running the StateT
18:51:00 <newsham> and to access the Parser you have to use lift operations (I think?)
18:51:17 <newsham> and I'm not in enough practice to give good comments/examples :(
18:51:29 <faxathisia> ok thanks I think I see
18:51:36 <faxathisia> It's a bit odd though
18:51:49 <faxathisia> Like if the state is just something contained in the parser monad
18:51:59 <oerjan> Karle: do you have a grip on what each piece of the program is supposed to do?  it is hard to fix something if you don't know how it _should_ work.  i suppose an abstract framework like this Signal stuff doesn't make it easier.
18:52:03 <faxathisia> What use is a LogicT ?
18:52:22 <faxathisia> Since you would want the logical operations to backtrack like through the parser?
18:52:26 <newsham> i'm not familiar with LogicT.. I did see url but didnt read yet
18:52:44 <newsham> i'm sure there are combinations of monad T's that dont make sense
18:52:49 <faxathisia> ok im gonna try and do some basic stuff with parser with StateT
18:52:54 <faxathisia> based on what you said
18:52:54 <newsham> just like you can put together lego blocks that shouldnt be placed together :)
18:53:00 <faxathisia> and then try logicT
18:53:06 <faxathisia> so thanks a lot :D I'll see what happens
18:54:04 <newsham> did you read any of the existing tutorials that covers T's?
18:54:17 <SamB_XP> is it T time?
18:54:19 <faxathisia> about 5 and none made sense lol
18:54:33 <faxathisia> this was a couple weeks ago though
18:54:56 <SamB_XP> hmm, I think I ran into Ts in lambdabot
18:55:34 <newsham> here's an even simpler one:  StateT with []: http://www.haskell.org/all_about_monads/html/xformerexamples.html
18:55:35 <lambdabot> Title: More examples with monad transformers
18:56:11 <Karle> oerjan ... more or less...
18:56:35 <hpaste>  infrared pasted "Can't compile an app that uses regexes" at http://hpaste.org/3679
18:57:38 <infrared> i have this mundane problem, not about monads and such, but maybe someone can help?
18:57:57 <SamB_XP> infrared: oh, no, not sexy enough!
18:58:04 <SamB_XP> have to add monads or we won't help
18:58:23 <newsham> how are you invoking ghc?
18:58:31 <infrared> hm, wait a sec
18:58:45 <newsham> ghc --make myprog.hs ?
18:58:49 <sjanssen> infrared: use ghc --make
18:59:51 <infrared> --make works! :)
19:00:01 <newsham> nonsexy problem solved!
19:00:25 <infrared> now it's time to make it more sexy :)
19:00:33 <oerjan> SamB_XP: don't be so negative, of course we'll help but we'll add enough monads he won't understand it
19:00:38 <ac> what exactly does --make do, and why is the option even there (as opposed to the functionality working by default)?
19:01:36 <SamB_XP> ac: we'd have to deprecate not passing --make...
19:02:25 <sjanssen> ac: --make automatically chases dependencies, it also adds -package flags for all the packages you've used
19:03:01 <sjanssen> ac: some build systems need more control
19:03:12 <SamB_XP> Cabal uses another flag that tells it to just not let you use packages you didn't pass -package flags for
19:03:30 <ac> that's what I figured: there are build systems that need to override that stuff
19:03:52 <SamB_XP> I think cabal uses --make too though
19:03:58 <SamB_XP> right now
19:04:05 <SamB_XP> since it's too lame to chase dependencies
19:04:52 <Saizan_> i don't think so, since you've to explicitly list exposed and internal modules
19:05:00 <SamB_XP> GHC itself is one example of something that isn't built with --make, I Think...
19:05:12 <SamB_XP> Saizan_: yeah, that's what the other flag is for ;-)
19:05:32 <SamB_XP> oh, wait,
19:05:34 <SamB_XP> I got confuse
19:05:35 <SamB_XP> d
19:05:36 <sjanssen> Saizan_: it does use --make
19:05:48 <SamB_XP> yeah, it does use --make
19:05:57 <SamB_XP> you don't HAVE to list internal modules
19:06:17 <SamB_XP> it just gives you better error messages, I think?
19:06:26 <Saizan_> uhm, true, not for executables at least
19:09:06 <infrared> hoogle doesn't work, all links are broken
19:09:25 <SamB_XP> @seen ndm
19:09:25 <lambdabot> I saw ndm leaving #haskell 10h 34m 24s ago, and .
19:09:51 <SamB_XP> @tell ndm hoogle's links are b0rk
19:09:51 <lambdabot> Consider it noted.
19:10:08 <SamB_XP> @tell ndm so saith infrared
19:10:09 <lambdabot> Consider it noted.
19:13:40 <oerjan> @tell dons @docs links are broken after base split (e.g. @docs Data.List)
19:13:41 <lambdabot> Consider it noted.
19:13:59 <nburlett> dons: does the binary package build on 6.8.1?
19:14:26 <oerjan> @seen dons
19:14:27 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 2h 22m 33s ago.
19:14:50 <nburlett> hm... does 6.8.1 have the binary library included with it?
19:15:15 <oerjan> @source Data.List
19:15:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
19:15:45 <LoganCapaldo> ghci says nay.
19:15:48 <dons> nburlett: should build
19:15:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:16:04 <nburlett> dons: Setup.lhs: binary.cabal:22: Invalid syntax (no colon after field name)
19:16:30 <oerjan> @source Data.ByteString
19:16:30 <lambdabot> Data.ByteString not available
19:16:32 <dons> with 6.8.1?
19:16:39 <nburlett> uh, I think
19:16:42 <sethk> ChilliX, my build is still going, which as you said is a good sign.  What does that configuration change, namely SplitObjs=NO, actually do?
19:16:44 <nburlett> how do I get the version?
19:16:56 <dons> $ ghc-pkg list Cabal
19:16:57 <dons> /home/dons/lib/ghc-6.8.1/package.conf: Cabal-1.2.2.0
19:17:13 <nburlett> oh, crud, it's using 6.6.1
19:17:16 <dons> ah
19:17:23 <dons> then updated your cabal version for 6.6.1
19:17:26 * nburlett smacks self in head
19:19:04 <nburlett> wtf.. my mac is messed up
19:20:20 <LoganCapaldo> @where lambdabot
19:20:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:20:30 <LoganCapaldo> @version
19:20:30 <lambdabot> lambdabot 4p575, GHC 6.6 (Linux i686 2.66GHz)
19:20:30 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:22:01 <sorear> sethk: normally GHC generates one .o per library, with split-objs it's one per symbol
19:22:26 <LoganCapaldo> that' a lotta os
19:22:27 <sorear> sethk: split-objs crashes low quality linkers, no split-objs makes 20+ MB executables
19:22:54 <sethk> sorear, what is the point?  better granularity of symbol resolution?
19:23:11 <SamB_XP> is GCC a low-quality linker
19:23:15 <SamB_XP> sorear: one per MODULE
19:23:23 <sorear> SamB_XP: GCC isn't a linker, period
19:23:30 <SamB_XP> er, GNU ld
19:23:39 <sorear> sethk: not having your disk fill with copies of the standard library
19:23:41 <SamB_XP> and... er...
19:23:53 <SamB_XP> doesn't it split into one .o per SCC?
19:24:29 <sethk> one file per symbol would be completely unmanageable
19:25:15 <newsham> linking granularity is obj file, no?
19:30:20 <LoganCapaldo> gah
19:30:33 <LoganCapaldo> I wanted to install cabal install so I wouldn't have to play hunt the dependency
19:30:42 <LoganCapaldo> but cabal isntall has depedencies
19:30:50 <LoganCapaldo> it's a vicious cycle
19:31:35 <Cale> You only have to do cabal-install's dependency chain once though
19:32:13 <sethk> I was able to install cabal 1.3 over my binary install of ghc6.6.1 (which has the earlier cabal) with no problems at all.
19:32:35 <sethk> Since ghc6.6.1 was available as a binary for my system, everything essentially chased itself.
19:34:56 <Cale> Installing 6.8.1 also appears to give you cabal-install.
19:35:37 <LoganCapaldo> it didn't give it to me, unless I'm spelling the command wrong?
19:36:30 <calvins> what are the conditions under which it's safe to use unsafePerformIO? I'm tempted to use it for a library I'm working on in order to hide the fact that IO is happening with a hashtable, in order to prevent users from having to be in the IO monad when they call the lookup?
19:36:51 <LoganCapaldo> Dont use a hashtable?
19:36:58 <calvins> The hashtable is read only, and is populated only once at startup.
19:37:08 <calvins> Data.Map and friends are not fast enough
19:37:15 <Cale> Which hashtable implementation are you using?
19:37:20 <calvins> Data.HashTable
19:37:31 <Cale> Oh, it's consistently slower than Data.Map
19:37:38 <calvins> really?
19:37:38 <Cale> So don't bother with that.
19:37:42 <Cale> yeah
19:37:49 <LoganCapaldo> Data.map and friends are too fast! :)
19:37:49 <Cale> Also, it doesn't scale as well.
19:37:55 <ddarius> It is, apparently, an impressively bad implementation
19:38:36 <Cale> It's a naive implementation. It's much harder to get hashtables right than it is to get binary balanced trees right.
19:38:49 <ddarius> Nevertheless, there are fast hash tables.
19:39:22 <calvins> i was not using the hashString function that they use, but was instead using the dbj2 hash algorithm (h = h*33 + ord c).
19:39:43 <calvins> and it seemed very fast from my brief experimenting
19:39:59 <calvins> djb2 was much faster than their hashString function
19:41:56 <calvins> so just for informational purposes, how often, if ever, do y'all use unsafePerformIO? Looking around inside libraries I see it used all over the place (in GHC internally, in ByteString), etc.? But people say it's evil and shouldn't be used..
19:42:09 <Karle> hi cale
19:42:24 <Cale> hello
19:42:40 <Karle> I am struggling with data type matching
19:42:44 <Cale> calvins: It's probably best to avoid it unless you actually understand how GHC is going to compile stuff
19:42:56 <Cale> calvins: That is, treat it as you would a compiler hook.
19:42:58 <Karle> Can you take a look at my code a bit?
19:43:04 <LoganCapaldo> @index unsafePerformIO
19:43:04 <lambdabot> System.IO.Unsafe, Foreign
19:43:16 <LoganCapaldo> hmm
19:43:16 <Cale> However, you can usually safely use it if the IO action you apply it to will always give the same result.
19:43:26 <LoganCapaldo> I really expected it to be in a GHC><Something>
19:43:27 <Cale> Karle: okay
19:43:33 <sorear> It also has to have no effects.
19:43:36 <calvins> yeah, that is what I was trying to get at with my question. I understand what the docs say about not inlining and ensuring that let floating doesn't occur
19:43:48 <LoganCapaldo> s/>/./
19:44:08 <Karle> Cale , I will post it now
19:44:51 <Cale> It's a convenient way to effectively add new language primitives.
19:45:34 <hpaste>  Karle pasted "help" at http://hpaste.org/3680
19:45:59 <Cale> For instance, ByteStrings aren't a built-in datatype, so unsafePerformIO is used to carefully allocate and manipulate chunks of memory for them.
19:46:27 <hpaste>  Karle annotated "help" with "(no title)" at http://hpaste.org/3680#a1
19:46:38 <Cale> Karle: your type signature claims that findporT returns a list
19:46:43 <LoganCapaldo> How do I feed cabal-install a .cabal file?
19:46:50 <Cale> Karle: but in all cases, it doesn't do so
19:46:57 <Cale> (it gives a pair)
19:47:09 <Karle> yes
19:47:15 <dons> yes, we curiously do our own low level memory management
19:47:25 <dons> not many libraries do that. hmm
19:47:28 <Cale> Karle: try deleting/commenting out the type signature for findporT, and seeing what hugs infers for it
19:48:21 <Cale> (you can use  :t findporT  on the hugs commandline to get the inferred type signature)
19:48:27 <infrared> just defined a slice function: slice start end seq = take (end - start) (drop start seq) . maybe there is sth like that in the prelude/stdlib?
19:48:41 <Cale> infrared: nope
19:48:41 <ddarius> LoganCapaldo: unsafePerformIO is part of the FFI addendum
19:48:54 <infrared> Cale: ok, thanks
19:49:36 <LoganCapaldo> % cabal install arrows
19:49:36 <LoganCapaldo> cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
19:49:42 <LoganCapaldo> Huh?
19:49:52 <LoganCapaldo> I think cabal hates me
19:49:55 <Cale> infrared: It seems to come up often enough that maybe something like it should be in the libraries.
19:50:12 <LoganCapaldo> it's like some kind of conspiracy...a cabal of people who don't want me to install..
19:50:54 <Cale> huh
19:51:15 <Cale> cabal --global install arrows  worked for me on 6.8.1
19:51:41 <LoganCapaldo> I think I'm missing a step
19:51:51 <hpaste>  Karle annotated "help" with "(no title)" at http://hpaste.org/3680#a2
19:52:45 <Cale> Karle: look at the types of the things you're matching against in the first parameter of findporT
19:53:18 <Cale> Karle: There's Abst, and a triple (_,250,_), and then a list of one element
19:53:19 <LoganCapaldo> How about this one? cabal: user error (Unresolved dependencies: fps >=0.7)
19:53:27 <Cale> Those can't possibly all have the same type.
19:53:43 <Karle> i see
19:54:02 * LoganCapaldo gives up and chases
19:54:09 <calvins> there is one place I've been using unsafePerformIO that I believe is safe, but I'm not sure. I have a FastString type that consists of an Int (for fast equality testing) and a ByteString. The next int to use for the ids is maintained in an IORef Int is created using unsafePerformIO....
19:54:22 <nburlett> scsibug: when you installed readline, did it break python?
19:54:29 <nburlett> @seen scsibug
19:54:29 <lambdabot> scsibug is in #haskell. I last heard scsibug speak 2h 43m 58s ago.
19:54:41 <Cale> LoganCapaldo: that sounds like a possibly broken/old package
19:54:49 <calvins> at the moment, the function to create a new FastString does not use unsafePerformIO, so the signature is ByteString -> IO FastString.
19:55:07 <LoganCapaldo> well that one is darcs lambdabot
19:55:08 <calvins> I'd really, really like to be able to have it be ByteString -> FastString
19:55:09 <Cale> LoganCapaldo: fps is now called bytestring
19:55:16 <Cale> hmm
19:55:25 <LoganCapaldo> which was the instigator for this whole mess
19:56:06 <Cale> Lambdabot must be the trickiest possible Haskell program to compile, due to it requiring almost everything.
19:56:38 <SideFFect> hello all :D
19:56:41 <sorear> It's also got one of the most painful build systems in existance.
19:56:59 <LoganCapaldo> I built lambdabot once before
19:57:02 <ari> @quote unsoundPerformIO
19:57:02 <lambdabot> No quotes match.
19:57:03 <Cale> calvins: Are you just using it for weak equality testing?
19:57:07 <sorear> calvins: I beleive that's a good use of it
19:57:10 <LoganCapaldo> but eval was broken due to that regexp bug
19:57:10 <vagif> Hello. Anyone can advise minimalistic web framework ?
19:57:11 <calvins> does this sound like a reasonable use case for unsafePerformIO? Multiple calls to mkFastString with the same argument always return the same result, and the only side effect is updating the global IORef counter (which only happens when a new FastString is created, not when one is reused).
19:57:19 <Cale> There's already something for that built into GHC isn't there?
19:57:26 <hpaste>  sideffect pasted "hmm_find" at http://hpaste.org/3681
19:57:33 <sorear> calvins: yes, it's a very good use.  GHC does it!
19:57:44 <SideFFect> can anyone tell me how to act an extra guard in the code I pasted?
19:57:50 <calvins> Cale: for fast equality testing. Each time I see a URI for the first time, I create a FastString for it so that I can have constant-time equality testing.
19:57:58 <sorear> LoganCapaldo: really I don't recommend it
19:58:04 <SideFFect> I need to check that the head of the second list doesnt equal the head of the first list + 1
19:58:18 <SideFFect> I tried putting it in the where, doesnt work
19:58:24 <LoganCapaldo> sorear: building lambdabot?
19:58:42 <Karle> Cale , I dont know how to solve this problem actually
19:59:27 <sorear> ues
19:59:40 <Cale> SideFFect: what's wrong with the code you pasted?
19:59:52 <LoganCapaldo> I need to get some cooler irc bots for work though
19:59:54 <Cale> (other than the tab characters)
19:59:59 <LoganCapaldo> the ones we have are really lame
20:00:00 <SideFFect> I need to add a check to it that the teacher wants
20:00:07 <calvins> sorear: thanks for the confirmation, i did see that in GHC. I wished I could reuse their FastString, but it is not exposed and it is very well-integrated to other internal stuff...
20:00:24 <SideFFect> that head of the second list doesnt equal to head of first list plus 1
20:00:45 <SideFFect> meaning he wants the program to terminate if [1,2] is given as first list for example
20:01:08 <Cale> terminate how?
20:01:11 <Cale> With an error?
20:01:28 <SideFFect> one sec, ill check what he wants exactly
20:02:23 <SideFFect> hm, well he doesnt say exactly, but I think he wants it as the first check and then the rest of the program can go on
20:02:32 <SideFFect> like if thats not satisfied, then dont do anything
20:02:48 <SideFFect> I tried && it to the where...didnt like it
20:03:02 <SideFFect> because it doesnt know bs until after splitIn2 is computed
20:03:25 <Cale> You can't just "not do anything". You can crash, if you want.
20:03:51 <Cale> That's the closest approximation to not doing anything I can think of.
20:04:00 <SideFFect> so lets crash :P
20:04:03 <Cale> all right
20:04:14 <Cale> Could you explain this condition a little more?
20:04:50 <SideFFect> sure, he wanted us to translate an imperitive, iteritive program of binary search into haskell, functional
20:04:55 <SideFFect> which we (I) did
20:05:19 <SideFFect> but I didnt add the if (K != J+1) for the program
20:05:32 <SideFFect> j is a[j] k is a[k] of the list
20:05:37 <Cale> can you paste the imperative code?
20:05:40 <SideFFect> where j is 1 k is n
20:05:41 <SideFFect> sure
20:06:21 <Cale> By the way, I think someone already told you this, but lists don't make a very good approximation to arrays.
20:06:41 <hpaste>  sideffect pasted "imper_teach" at http://hpaste.org/3682
20:06:51 <SideFFect> yeah I know, we didnt learn arrays tho, so lists are ok
20:07:29 <Cale> okay, and with the additional test?
20:07:35 <SideFFect> sorry?
20:07:46 <Cale> I mean the imperative program
20:07:48 <Cale> oh
20:07:50 <Cale> I see
20:07:58 <nburlett> @msg scsibug readline borked my computer
20:07:58 <lambdabot> Not enough privileges
20:08:13 <nburlett> @tell scsibug readline borked my computer
20:08:13 <lambdabot> Consider it noted.
20:08:33 <Cale> Er, did your prof explicitly tell you that the test for j+1 <> k should be implemented directly?
20:08:40 <sorear> @msg nburlett this is what @msg does
20:08:49 <Cale> Your program already contains a test which performs the same function as that.
20:09:24 <SideFFect> really? where? the otherwise false?
20:09:27 <oerjan> SideFFect: i think the haskell equivalent of K != J+1 might be to add a find x [y] = ... case
20:09:41 <Cale> Hmm, I suppose.
20:09:41 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:09:59 <nburlett> Cale: oops.. that message wasn't for you
20:10:01 <nburlett> sorear: thanks
20:10:08 <SideFFect> add a new case? but arent they all covered?
20:10:19 <oerjan> SideFFect: yeah, it's unnecessary
20:10:21 <Cale> they are all covered
20:10:34 <Cale> You could add a case that was something like:
20:10:52 <Cale> sigh.
20:10:57 <SideFFect> whoa heh
20:10:57 <ac> uhg, I hate these flash players that make you redownload an entire movie when you change to fullscreen, or do something simple like that
20:11:21 * ddarius just hates Flash movie players.
20:11:24 <Cale> I just know that as soon as I start writing code, that netsplit will reconnect
20:11:31 * sorear just hates Flash
20:11:31 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
20:11:33 <Cale> find x [b] | (b == x) = True
20:11:36 <sorear> @messages
20:11:37 <lambdabot> nburlett said 1m 47s ago: thanks
20:11:42 <Cale>            | otherwise = False
20:11:47 <Cale> You could do that
20:12:11 <Cale> But it's kind of silly, given that it will already do the equivalent of that as soon as it recurses one more step.
20:12:14 * ac just hates the web
20:12:19 <SideFFect> yeah exactly... hm
20:12:41 <SideFFect> he wants us to have that code I said in the program because he wants to test it with a bad example
20:12:45 <SideFFect> hes odd
20:12:56 <Cale> j+1 = k means that the part of the array being examined is of length 1
20:13:07 <SideFFect> yeah exactly
20:13:22 <SideFFect> he doesnt want to search if the array/list is of length 2
20:13:27 <calvins> does anybody know pros or cons regarding Data.Map vs Data.Map.AVL (from the collections library of Adrian Hey), apart from that Data.Map is in the standard libraries? Does Data.Map.AVL have any compelling benefits? Ditto for Data.Set vs. Data.Set.AVL..
20:13:32 <Cale> length 2?
20:13:42 <SideFFect> oh...can I just add...if length bs = 2 then exit?
20:13:50 <calvins> is the collections library generally faster than equivalent standard data structures?
20:13:57 <Cale> That's not what the imperative program does, is it?
20:14:31 <SideFFect> I think it does? k != j+1 just checks to make sure umm
20:14:32 <Cale> calvins: the collections library is I think the name for the stuff which was in base, but they've just split it off.
20:14:46 <SideFFect> wait...does it check if the values are 1 apart, or the length is 1 apart?
20:14:56 <Cale> SideFFect: yeah, I'd call that length 1 :)
20:15:12 <Cale> hmm
20:15:23 <Cale> oh, I see
20:15:45 <SideFFect> wow lots of blue and green :P
20:15:49 <calvins> oh, i didn't realize it was in base. I thought it was a standalone library that wasn't part of any of the pre-installed and available libraries.
20:16:07 <agnokapathetic> I know maps are applying a function to a list and generating new list, but is there a way to apply a function to a list and get IO?
20:16:13 <agnokapathetic> like in: printEach list = map (\x -> putStrLn ((show (fst x)) ++ (show (snd x))) ) [(x,y) | x <- [0.. length list], y <- (list !! x)]
20:16:17 <oerjan> argh! and this client is _supposed_ to hide netsplit rejoins :(
20:16:17 <Cale> calvins: I think it's included in GHC 6.8.1
20:16:27 <Cale> yes, containers-0.1.0.0
20:16:32 <LoganCapaldo> @type mapM
20:16:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:16:41 <agnokapathetic> thank you :-)
20:16:43 <calvins> okay, i'm on ghc6.6 until it shows up in gentoo, but will upgrade soon.
20:16:44 <Cale> agnokapathetic: mapM
20:16:46 <oerjan> but fails when it happens in several stages
20:16:50 <Cale> agnokapathetic: Or mapM_
20:16:58 <Cale> (See Control.Monad)
20:17:33 <Cale> calvins: In 6.6, the modules in containers are in base.
20:18:14 <Cale> calvins: It's part of a project to shrink the base library as much as possible, so that upgrades to the other modules are easier to install between GHC versions.
20:18:31 <calvins> hmmm, the Data.Map.AVL that I mentioned definitely isn't in base under ghc 6.6, because I have to add 'collections' as a 'Build-Depends' in the cabal configuration to get it to build
20:18:42 <SideFFect> an email he just sent about how to handle the error problem
20:18:44 <Cale> oh, is that in collections now?
20:18:51 <SideFFect> http://hpaste.org/3683
20:19:00 <calvins> it is in collections under 6.6, yeah
20:20:09 <Cale> oh, sorry, my mistake
20:20:21 <Cale> That's containers I'm talking about, not collections
20:20:38 <calvins> ah, i see
20:20:43 <LoganCapaldo> @type let f = return ; xs = [] in (mapM f xs, f xs) -- hmm
20:20:44 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (m [a], m [a1])
20:20:55 <oerjan> those are somewhat competing libraries, aren't they
20:21:19 <calvins> i'm just wondering about how the collections things, like Data.Map.AVL, compare to things like Data.Map, where they're very similar data structures. If there are no known problems with Data.Map and Data.Set, then I'd go with what's in base, but i remember some kind of an email a month or two ago where droundy was having some kind of problem with Data.Map, and somebody suggested the collections Data.Map.AVL instead..
20:21:47 <Cale> collections from hackage doesn't build yet for me on 6.8.1 (the usual base split problem)
20:22:01 <Cale> hmm
20:22:04 <Cale> I'd try Data.Map
20:22:11 <LoganCapaldo> @type let f = return ; xs = [()] in (mapM f xs, f xs)
20:22:13 <lambdabot> forall (m :: * -> *). (Monad m) => (m [()], m [()])
20:22:30 <calvins> yeah, i'd prefer to stick to base as much as possible, all other things being equal...
20:22:41 <Cale> I've had very decent performance from Data.Map, and until you actually see that it's the bottleneck, I wouldn't worry about looking for another finite map implementation.
20:23:16 <Cale> In fact, you probably should just program everything with the easiest possible data structures you can manage, and then profile and see where your program is actually slow.
20:23:18 <oerjan> LoganCapaldo: that's weird, shouldn't f be monomorphic?
20:23:42 <LoganCapaldo> oerjan: isn't it?
20:23:48 <Cale> (If it's too slow at all)
20:23:58 <oerjan> you apply it both to a list and to each element
20:23:58 <calvins> yeah, i did a bit of premature optimization by using a hashtable
20:24:10 <LoganCapaldo> oh yeah
20:24:13 <calvins> i'll try Data.Map and see how that compares...
20:24:35 <LoganCapaldo> I was just going for mapM return == return for lists
20:24:41 <LoganCapaldo> but your point is more interesting
20:25:08 <oerjan> LoganCapaldo: oh wait, it's monomorphic in the monad, not the argument
20:25:28 <oerjan> because the argument itself has no typeclass restriction
20:25:30 <LoganCapaldo> oh duh
20:25:46 <oerjan> subtle stuff :)
20:26:13 <faxathisia> What is a higher-ranked?
20:26:14 <faxathisia> type
20:26:22 <ac> anybody used HAppS?
20:27:10 <Cale> SideFFect: oh, so he wants you to add the same bug to the Haskell code?
20:27:10 <faxathisia> oh like printf
20:27:15 <Cale> SideFFect: I'm not sure I understand
20:27:37 <SideFFect> yeah he does
20:27:45 <SideFFect> you're not the only one lol
20:27:59 <oerjan> @type let xs = [()] in (mapM return xs, return xs)
20:28:01 <SideFFect> we need to start off by adding that case...where k <> j +1
20:28:01 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => (m [()], m1 [()])
20:28:30 <Cale> SideFFect: um, he's saying to change it to k <> j + 2, I think.
20:28:45 <LoganCapaldo> oerjan: yeah I went out of my way to do let f = return before, it was on purpose :)
20:28:47 <Cale> But I don't get the impression that this has much to do with the Haskell code.
20:29:00 <oerjan> ah
20:29:22 <SideFFect> well, first we need to have the check to change it to J+2 no?
20:29:30 <SideFFect> hes very odd, when he asks things
20:29:36 <SideFFect> all his assigns are like this
20:29:57 <oerjan> @check \xs -> mapM return (xs :: [Bool]) == return xs
20:29:58 <lambdabot>   add an instance declaration for (Eq (m [Bool]))     In the expression: (map...
20:30:09 <Cale> SideFFect: You implemented an invariant checker?
20:30:16 <nburlett> anyone here using Mac OS X 10.5 with GHC 6.8.1?
20:30:23 <SideFFect> I dont think so? lol
20:30:30 <oerjan> @check \xs -> mapM return (xs :: [Bool]) == (return xs :: Maybe [Bool])
20:30:31 <lambdabot>  OK, passed 500 tests.
20:30:39 <oerjan> @check \xs -> mapM return (xs :: [Bool]) == (return xs :: [[Bool]])
20:30:41 <lambdabot>  OK, passed 500 tests.
20:31:15 <newsham> sideff: did you get your bsearch working well?
20:31:29 <SideFFect> yep, works perfectly, finds what it needs to
20:31:37 <SideFFect> find 4 [1,2,3,5] = false
20:31:46 <SideFFect> find 3 [1,2,3] = true
20:32:15 <oerjan> @src mapM
20:32:16 <lambdabot> mapM f as = sequence (map f as)
20:32:49 <Cale> SideFFect: For this imperative language?
20:32:58 <oerjan> maybe it even works for Applicatives
20:33:09 <oerjan> :t traverse
20:33:10 <lambdabot> Not in scope: `traverse'
20:33:18 <oerjan> :t Data.Traversable.traverse
20:33:20 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:33:30 <SideFFect> cale: hmm?
20:33:49 <ramza3> hmm, the pugs source has poetry in it ...that is interesting
20:34:45 <goalieca> fucking netsplits
20:34:56 <Cale_> sorry, I think my IRC server went down
20:35:04 <Cale_> SideFFect: You implemented an invariant checker?
20:35:10 <Cale_> SideFFect: For this imperative language?
20:35:22 <SideFFect> I dont know what an invariant checker is?
20:36:06 <Cale_> I suppose it would be a program which executes the imperative code and tests invariants used in the proof of its correctness?
20:36:15 <Cale_> I'm not sure.
20:36:20 <SideFFect> heh
20:36:25 <SideFFect> then im even more not sure
20:36:43 <nburlett> gah... WTF happened to my computer?!?!
20:36:48 <SideFFect> all I need to do is get that code in my code somehow...oh, and also have output as Found 4 in position 3 or etc
20:38:01 <agnokapathetic> any way to take only alpha numerics from a string?
20:38:18 <agnokapathetic> i was thinking of a difference of two lists
20:38:18 <nburlett> agnokapathetic: filter ?
20:38:23 <agnokapathetic> thanks
20:38:29 <mrd> > filter isAlphaNum "abc---"
20:38:31 <lambdabot>  "abc"
20:38:53 <nburlett> > filter isAlphaNum "abc123*(*$@"
20:38:55 <lambdabot>  "abc123"
20:38:58 <nburlett> > filter isAlphaNum "abc123*(*$hello@"
20:38:59 <lambdabot>  "abc123hello"
20:39:04 <nburlett> tada!
20:39:09 <agnokapathetic> Thank you! :-)
20:40:16 <nburlett> > filter isAlphaNum "w%^^@h#%^@%$y#$W$#o%%%n%%t#M#$y$R@e@#a@d@l$i$n$e$W#$o$r#$k!C!o!r!r!e@#c@#tl#$#%y"
20:40:18 <lambdabot>  "whyWontMyReadlineWorkCorrectly"
20:43:37 <goalieca> whoah.. encore
20:44:33 <sethk> ChilliX, still here?
20:44:44 <sethk> orbitz, anyone, continuing my saga of building ghc 6.8.1 ...
20:44:54 <ChilliX> sethk: yep
20:44:58 <joed> ChilliX: I think it builds fine from source, I had 6.6.1, updated Cabal, tweaked a native readline for osx, added Happy and all extra libs. Just got done building.
20:45:01 <sethk> sorry orbitz, I meant or and must have hit tab by mistake
20:45:11 <sethk> ChilliX, different error now:
20:45:29 <sethk> ChilliX, building GLUT
20:45:43 <sethk> Graphics/UI/GLUT/QueryUtils.hs:41:15:
20:45:43 <sethk>     parse error on input `CALLCONV'
20:45:57 <SideFFect> cant I check for the j and k in my splitIn2 function?
20:46:10 <ChilliX> hmm, that looks like a CPP macro that wasn't resolved
20:46:14 <sethk> ChilliX, do you want the compile line?
20:46:49 <sethk> ChilliX, perhaps an anomoly associated with the compiler version?
20:47:05 <sethk> ChilliX, I've built gcc 4.2.1, I can install it and try the ghc build again.
20:47:58 <Korollary> sethk: wassup
20:48:20 <ChilliX> I am not sure about the GLUT build system, it may be that this macro was left over in a pre-processing step
20:48:26 <sethk> Korollary, not much, just trying to see how many ways it is possible to screw up on building 6.8.1   :)
20:48:40 <ChilliX> I doubt that it is gcc-specific (but it's not impossible)
20:48:51 <sethk> ChilliX, ok, but wouldn't everybody else building on linux see it also?
20:49:11 <sethk> ChilliX, it must be something about my environment, unless other people are disabling GLUT explicitly.
20:49:13 <tehgeekmeister> how do i use round on a double?
20:49:26 <ChilliX> joed: Great!
20:49:45 <ChilliX> joed: I also did a new bindist that handles gmp right (I think)
20:49:52 <ChilliX> at least it works on my machine now
20:49:57 <ChilliX> without the -lgmp error
20:50:15 <joed> ChilliX: Indeed. ./configure ; make ; sudo make install - the previous bindist I never got working.
20:50:23 <sethk> ChilliX, do you think it's worth retrying with the newer gcc, or is that only going to waste several more hours to end up in the same place?
20:50:27 <ChilliX> The problem is an omission in the bindist root Makefile
20:50:41 <omnId> tehgeekmeister: it gives you an Integral, so you fromIntegral if you want the result to be a Double
20:50:43 <sethk> ChilliX, obviously nobody is sure, but what's the better approach?
20:51:06 <tehgeekmeister> omnId: i'm trying to pass it a double, how is that done?
20:51:16 <ChilliX> sethk: I think its better to first have a closer look at what is goi8ng wrong
20:51:21 <sethk> ChilliX, it's possible that everyone else using linux is installing a package or binary tarball.
20:51:23 <omnId> > round (2.4 :: Double)
20:51:27 <sethk> ChilliX, ok.
20:51:31 <lambdabot>  2
20:51:57 <tehgeekmeister> omnId: nevermind, i made a really stupid mistake on my end.
20:51:57 <ChilliX> sethk: look at the source where it fails, does it have more of these CALLCONVs in there
20:52:05 <omnId> splitty tonight.
20:52:06 <sethk> ChilliX, ok, looking ...
20:53:30 <sethk> ChilliX, there are three of them.  The error occurs on the first.  I would bet that if we comment out that line, we'll just get an error on the line which follows.
20:54:27 <ChilliX> it's probably in a foreign import isn't it?
20:54:36 <sethk> ChilliX, yes
20:54:48 <ChilliX> What was the name of the file again?
20:55:12 <sethk> libraries/GLUT/Graphics/UI/GLUT/QueryUtils.hs
20:55:21 <sethk> line 41
20:55:26 <ChilliX> ok, let me a have a look at the source
20:57:46 <omnId> @slap the freenode servers
20:57:47 * lambdabot smashes a lamp on the freenode servers' head
20:58:17 <goalieca> @slap itarweb
20:58:17 * lambdabot throws some pointy lambdas at itarweb
20:58:43 <ChilliX> sethk: Can you paste the compiler command in hpaste after all?
20:59:28 <sethk> ChilliX,   certainly.  I noticed that CALLCONV appears in libraries/GLUT/configure and has cases.  possibly a missing case?  Pasting now...
21:02:19 <ChilliX> re missing case, there are only two: its either windows or something else, so that should be ok
21:03:20 <SideFFect> how would I output the position of a found item from a list?
21:03:43 <hpaste>  sethk pasted "6.8.1 compile error" at http://hpaste.org/3684
21:03:50 <ivanm> @doc Prelude
21:03:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:03:57 <sethk> ChilliX, let me know if you need any earlier lines
21:04:04 <ivanm> ^^ that link doesn't work... where are the docs located now?
21:04:35 <sethk> ChilliX, config.log has this:   CALLCONV=''
21:05:20 <sethk> ChilliX, but clearly that's not arriving in the compile of QueryUtils.hs, as it should be defined to be nothing, space, however you want to phrase it.
21:06:01 <Korollary> ivanm: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Prelude.html
21:06:03 <lambdabot> http://tinyurl.com/yorrvr
21:07:44 <ChilliX> sethk: strange, have a look at configure.ac, near the end of the file doesn't it set CALLCONNV to ccall for everyhting but mingw32?
21:08:11 <omg911> is there a way to use pattern mattching in a function definition to match a type?
21:08:27 <sethk> ChilliX, looking.  I think I already noted that config.log has it defined as ''.  (Sometimes I'm not sure whether I thought or actually typed.  :)  )
21:08:32 <omg911> ie. f x = x*x where x is a  double
21:08:54 <omnId> omg911: you could add a type annotation for f
21:08:58 <omnId> f :: Double -> Double
21:09:04 <SideFFect> ill be back after :D
21:09:13 <Korollary> omg911: is x always a double?
21:09:15 <faxathisia> Isn't a typeclass which is needed
21:09:23 <omg911> yeah but would that work if x has more than one type
21:09:23 <faxathisia> and you define it for Double -> Double as well as other types?
21:09:32 <sethk> ChilliX, it certainly does.  And configure has the same case
21:09:38 <omg911> yeahfor my custom types
21:09:47 <dmwit> I just worked through the FFI addendum, but didn't see anything about marshalling/unmarshalling C structs.  Anybody have any pointers?
21:09:47 <omnId> omg911: oh, you want a different defintion for doubles than other types?
21:09:49 <omg911> x can be a terminal or function
21:09:53 <hpaste>  tehgeekmeister pasted "typing woes." at http://hpaste.org/3685
21:09:54 <omg911> yes
21:10:09 <omnId> omg911: you can use Data.Typeable.cast, but that's somewhat evil.
21:10:35 * tehgeekmeister needs to learn more about the haskell numeric types
21:10:40 <omnId> showOrNot x = fromMaybe (show x) (cast x)
21:11:09 <omnId> > (\x -> fromMaybe (show x) (cast x)) "strings aren't shown"
21:11:11 <lambdabot>  "strings aren't shown"
21:11:17 <faxathisia> o-o
21:11:18 <omnId> > (\x -> fromMaybe (show x) (cast x)) (Just "other things are")
21:11:19 <lambdabot>  "Just \"other things are\""
21:11:26 <faxathisia> :t (\x -> fromMaybe (show x) (cast x))
21:11:27 <lambdabot> forall a. (Show a, Typeable a) => a -> String
21:11:36 <faxathisia> o_O
21:11:38 <omnId> @type cast
21:11:40 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
21:12:41 <omnId> maybe (..general version for any type x..) (\x -> ..specific version for one type..) (cast x)
21:12:46 <sethk> ChilliX, I can add some echo statements and see what $host is, and whether it gets assigned at that point.
21:13:05 <omg911> i don't understand your code tehgeekmeister
21:13:18 <omnId> > cast "typesafe casts OMG!!" :: Maybe String
21:13:19 <ChilliX> yes, bu really, either way, CALLCONV should be set to something
21:13:20 <lambdabot>  Just "typesafe casts OMG!!"
21:13:29 <omnId> > cast "typesafe casts OMG!!" :: Maybe Int
21:13:30 <lambdabot>  Nothing
21:13:52 <omg911> ah
21:13:55 <dmwit> :t cast
21:13:57 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
21:14:07 <dmwit> Aha, I was wondering how that was possible.
21:14:15 <dmwit> The Typeable constraint makes that much clearer. =)
21:14:40 <omnId> class Typeable a where typeOf :: a -> TypeRep
21:14:56 <ChilliX> setk: do you have a file GNUmakefile in there?
21:14:59 <dmwit> instance Eq TypeRep, too, I assume.
21:15:05 * dmwit tries asking again, just in case
21:15:05 <omnId> most likely
21:15:12 <sethk> ChilliX, looking ...
21:15:17 <ChilliX> If so, have a look at it, it shouyld define GHC_OPTS
21:15:17 <dmwit> I'd like to call a C function that takes a struct.  How can I do that?
21:15:22 <hpaste>  tehgeekmeister annotated "typing woes." with "typing woes, with comments." at http://hpaste.org/3685#a1
21:15:29 <faxathisia> dmwit: impossible
21:15:29 <tehgeekmeister> omg911: that should make it a lot easier.
21:15:30 <sethk> ChilliX, yes, I have the file.  Looking ...
21:15:35 <ChilliX> and that's where it has on my machine -optc-DCALLCONV=ccall
21:15:40 <faxathisia> dmwit: You must actually write ABI specific code I think
21:15:56 <ChilliX> That's what tells GHC, to tell gcc to replace CALLCONV by ccall
21:16:12 <ChilliX> This file is generated by cabasl
21:16:29 <faxathisia> dmwit: since no FFI in haskell can do this
21:16:36 <faxathisia> (at least that I am aware of)
21:16:37 <ChilliX> So, I ams tarting to suspect Cabal is messing tis up
21:16:41 <sethk> ChilliX, there are a bunch of places where GHC_OPTS is appended
21:16:51 <sethk> ChilliX, I did install cabal 1.3, to get happy to be happy.
21:16:53 <dmwit> faxathisia: Ugh, rats.  I have no idea what that means, and I doubt I want to.
21:17:00 <ChilliX> Line 10
21:17:04 <dmwit> Wrapper C-function time.
21:17:05 <faxathisia> dmwit: Well is it a struct or a pointer to a struct?
21:17:09 <dmwit> struct
21:17:12 <sethk> ChilliX, should I hide 1.3 and let it use the cabal for ghc 6.6.1?
21:17:13 <dmwit> Pointers are easy (I think).
21:17:14 <faxathisia> oh right heh, wrappers might be the way
21:17:25 <faxathisia> I really hate to write them though :|
21:17:51 <sethk> ChilliX, I'm on the line, but I'm not sure what I'm looking for.
21:18:00 * dmwit considers rewriting those functions in Haskell, and only importing the ones that take pointers
21:18:16 <faxathisia> dmwit: What I did in the past was the equivalent of memcpy my struct into a series of ints and pass those according to what the C calling conventions were on my platform
21:18:21 <ChilliX> sethk: Here is what I have:
21:18:22 <ChilliX> GHC_OPTS = -package-name GLUT-2.1.1.1 -hide-all-packages -split-objs -i -idist/build/autogen -idist/build -i. -Idist/build -Iinclude -optc-DCALLCONV=ccall -\#include "HsGLUT.h" -odir dist/build -hidir dist/build -stubdir dist/build -package base-3.0.0.0 -package array-0.1.0.0 -package containers-0.1.0.0 -package OpenGL-2.2.1.1 -O -DCALLCONV=ccall -XCPP -XForeignFunctionInterface
21:18:38 <dmwit> faxathisia: eww
21:18:50 <faxathisia> dmwit: hey, it was inside the compiler.. no one knew! >:D
21:19:13 <ChilliX> dmwit: tools like c2hs can help you with structs
21:19:20 <sethk> ChilliX, I'm missing the -optc-DCALLCONV=ccall
21:19:30 <ChilliX> That's the probelm, then
21:19:35 <sethk> ChilliX, I'm also missing the -split-objs, but that's intentional.
21:19:40 <ChilliX> yep
21:19:44 <dmwit> ChilliX: Thanks, I'll have a look.
21:19:53 <sethk> ChilliX, ok, should I hack GNUmakefile and continue the build?
21:20:11 <ChilliX> sethk: worth a try
21:21:02 <dmwit> ChilliX: ...are you the author of c2hs?
21:21:20 <sethk> ChilliX, k, I'll try it.  add both -optc-CALLCONV and -DCALLCONV=ccall ?
21:21:25 <ChilliX> dmwit: yes...hence, I know it helps ;)
21:21:30 <dmwit> O_o
21:21:39 <ChilliX> sethk: yep
21:21:47 <sethk> ChilliX, ok, doing it now ...
21:23:12 <ac> how do SYB and template haskell relate to each other?
21:26:32 <ac> are they completely different?
21:26:52 <sethk> ChilliX, ok, I restarted the build at the top level.  It will take a couple of minutes to say "up to date" in 1000 places first.  :)
21:27:09 <sethk> ChilliX, ok, different errors   :0
21:27:29 <sethk> ChilliX, a bunch of undefined font identifiers.  I'll paste a couple:
21:27:40 <sethk> cbits/HsGLUT.c:27:0:
21:27:40 <sethk>      error: ‘GLUT_BITMAP_9_BY_15’ undeclared (first use in this function)
21:27:40 <sethk> cbits/HsGLUT.c:28:0:
21:27:40 <sethk>      error: ‘GLUT_BITMAP_TIMES_ROMAN_10’ undeclared (first use in this function)
21:29:34 <ChilliX> hmm
21:29:51 * dmwit starts travelling the dependency graph
21:29:53 <sethk> in GLUT part of tree the string appears only in HsGLUT.c
21:32:14 <ChilliX> I wonder whether that is defined in the GLUT itself
21:32:36 <sethk> ChilliX, could be.  I'm not sure where GLUT headers live
21:33:11 <goalieca> @slap irc
21:33:11 * lambdabot hits irc with an assortment of kitchen utensils
21:33:12 <ChilliX> They are from the actual GLUT headets, see http://openglut.sourceforge.net/group__bitmapfont.html
21:33:13 <lambdabot> Title: OpenGLUT 0.6.3 development - OpenGLUT: Text Rendering - Bitmapped Fonts
21:33:40 <sethk> ChilliX, ok, do you think I need to upgrade GLUT?
21:34:38 <ChilliX> sethk: It's in the GLUT.framework
21:35:03 <ChilliX> Well, maybe it is just that the C compiler wasn't given the right options to find the stuff
21:35:21 <sethk> ChilliX, maybe it isn't there, and configure didn't detect that it isn't there.
21:36:00 <sethk> ChilliX, it's in the 6.6.1 tree, so that's not it
21:36:34 <sethk> ChilliX, well, maybe not, I installed 6.6.1 from a binary tarball, so that proves nothing.
21:37:01 <ChilliX> sethk: I don't follow.  This header file is part of the code you get from Apple
21:37:27 <sethk> ChilliX, I installed 6.6.1 from the binary tarball, which means GLUT was already built
21:37:41 <sethk> ChilliX, so I may not have GLUT installed on my box.
21:37:44 <oerjan> ivanm: the main documentation page is still in the same place, with updated links to the rest
21:37:48 <oerjan> @docs
21:37:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
21:38:01 <ChilliX> sethk: or was this the linux box?
21:38:14 <sethk> ChilliX, right, I'm on my linux box.
21:38:20 * ChilliX starts to get confused with the various builds today...
21:38:28 <ChilliX> Ah, just type "locate glut.h"
21:38:52 <sethk> ChilliX, doesn't exist.
21:39:00 <ChilliX> Well, that settles it :)
21:39:02 <ChilliX> What distro?
21:39:08 <sethk> ChilliX, so I guess I should install it.  :)
21:39:19 <sethk> ChilliX, it's a ubuntu install, but a couple of revs back.
21:39:39 <ChilliX> There is a probably a mesa package or so
21:39:54 <sethk> ChilliX, yes, good point, I'll look.
21:41:48 <sethk> ChilliX, I've got freeglut3, glutg3, libglut3, libglut3-dev, .....
21:42:18 <omnId> ac: AFAIU, TH allows you to generate syntax at compile time.  Data.Generics allows you to apply polymorphic functions over the structure of datatypes.
21:42:33 <sethk> ChilliX, freeglut3 (but not dev) is installed, so I'll try freeglut3-dev
21:44:09 <ac> omnId: could Data.Generics be accomplished with template haskell? I understand the idea of template haskell because I'm familiar with the idea of C++ templates and macros, but I don't have anything to relate generic programming to
21:46:13 <ac> what does "type-indexed function" mean? Or "kind-indexed kinds"?
21:47:03 <omnId> ac: I don't know, I've only done one small thing with Generics, and I'm still hazy.  I actually used both, using Generics to recurse over the structure of arbitrary data and produce compile-time syntax in TH.
21:47:22 <SideFFect> back again :D
21:47:43 <goalieca> ac: umm.. how would a template be different from a "class" in haskell
21:47:48 <goalieca> as far as generic is concerned
21:47:55 <SideFFect> can anyone help me with displaying where I found the position of a digit?
21:48:13 <dmwit> ChilliX: I'm getting an error when building c2hs.
21:48:16 <sorear> ac: no you don't.  template haskell has nothing to do with C++ templates
21:48:27 <dmwit> I've just built alex, happy, and cabal succesfully, so those dependencies are satisfied.
21:48:50 <ac> sorear: it certainly sounds a lot like lisp macros though
21:49:02 <sorear> ac: that's what it is
21:49:19 <hpaste>  dmwit pasted "c2hs build error" at http://hpaste.org/3686
21:49:23 <allbery_b> yeh, except that the intermediate format doesn't look like haskell source
21:49:34 <geocalc> dmwit=<< ghc version ?
21:49:40 <allbery_b> (that is IMO both an advantage and a disadvantage in lisp)
21:49:51 <dmwit> geocalc: 6.6.1
21:49:55 <omnId> allbery_b: you use Haskell code to generate it, though
21:50:04 <geocalc> ok
21:50:05 <allbery_b> true
21:50:28 <ac> allbery_b: so you're saying template Haskell processes an intermmediate representation of your program?
21:50:45 <sorear> @seen beschmi
21:50:45 <lambdabot> I saw beschmi leaving #xmonad, #haskell and #darcs 9d 12h 37m 47s ago, and .
21:50:59 <faxathisia> geocalc <- lol ;
21:51:10 <allbery_b> yes.  you feed it a chunk of haskell code, it generates a bunch of Var and Lam etc. which you can manipulate at cmpile time
21:52:07 <allbery_b> or going the other way you can feed it the Var, Lam, etc. generated at compile time on the fly and have TH compile it into the program
21:52:12 <ac> It seems like generic programming could be implemented using template haskell
21:52:39 <ac> er, I guess any feature could be, but it seems it would be natural to
21:53:43 <faxathisia> hey is there some desirable attribute of non-recursive types over recursive types
21:53:44 <faxathisia> ?
21:53:48 <dmwit> Actually, I don't see the word "library" anywhere in the cabal file for c2hs.
21:54:14 <oerjan> ac: i think template haskell is far less portable than generics
21:56:18 <ac> so perhaps its better to use generics over templates if you can?
21:56:34 <ac> *it's
21:57:46 <SideFFect> why is this wrong
21:57:46 <SideFFect> | (head ls /= (head rs) + 1) = False
21:58:28 <oerjan> someone the other day cringed at the idea of template haskell getting into haskell-prime, saying something like it would force every compiler to be like ghc
21:58:54 <sorear> that would be me
21:59:19 <sorear> mr. deep misgivings about most extensions, but TH quite a bit more than most
21:59:20 <dmwit> SideFFect: Syntactically wrong?  It seems fine syntactically.
21:59:33 <dmwit> SideFFect: Although that function can probably be written more simply.
21:59:43 <scook0> perhaps the problem is in the line(s) above?
21:59:49 <dmwit> SideFFect: We'll probably need more context to give you a real answer.
22:00:01 <oerjan> SideFFect: i thought the j = k+1 thing was supposed to be comparing array indices, not contents?
22:00:10 <newsham> does seem like a fairly heavy-weight thing to require in the standard.
22:00:15 <newsham> given that most programs dont use TH
22:00:17 <newsham> or need it
22:00:36 <oerjan> but i didn't look that hard at it
22:00:37 <allbery_b> does h' have anything like optional annexes?
22:01:00 <faxathisia> guys what is your favorite haskell code?
22:01:04 <allbery_b> (i.e. if a compiler chooses to implement it, here is the standard for template haskell)
22:01:16 <newsham> fax: "3"
22:01:26 <faxathisia> what
22:01:31 <sorear> > nubBy(((>1).).gcd)[2..]
22:01:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:01:33 <newsham> > 3
22:01:34 <lambdabot>  3
22:01:36 <SideFFect> well, im trying things out cause syntax for haskell bugs me :(
22:01:39 <faxathisia> sorear: nice :
22:01:39 <faxathisia> :D
22:02:03 <faxathisia> any like longer ones?
22:02:07 <faxathisia> I mean a few pages or more
22:02:10 <SideFFect> how would I compare the two items of a list and see if they are 1 digit apart?
22:02:19 <SideFFect> two separate lists that is
22:03:12 <newsham> assuming x was the head of one list and y was the head of the other, and they were both integers:    x == y+1 (or x+1 == y ?)
22:03:26 <SideFFect> ah
22:03:27 <ac> SideFFect: list2 == (map (+(-1) list1) -- ?
22:03:33 <SideFFect> that might work :P
22:03:36 <SideFFect> lets see
22:03:48 <newsham> ac: nice
22:04:04 <ac> newsham: uhm, it has at least one syntactical error
22:04:10 <SideFFect> does not equals is /= right?
22:04:16 <newsham> yah but i like the idea
22:04:17 <ac> newsham: and there's no reason not to swap list1 and list2 and use (+1)
22:04:18 <faxathisia> @src (/=)
22:04:18 <lambdabot> x /= y = not (x == y)
22:04:20 <omnId> yes
22:04:31 <SideFFect> alrighty
22:04:54 <SideFFect> still a stupid error
22:05:03 <SideFFect> cant match expected type against inferred type
22:05:05 <SideFFect> bool
22:05:08 <SideFFect> but im giving it False
22:05:09 <SideFFect> so wth
22:05:17 <newsham> > (\xs ys -> map (+1) xs == ys || xs == map (+1) ys) [1,2,3] [2,3,4]
22:05:18 <lambdabot>  True
22:05:29 <newsham> > (\xs ys -> map (+1) xs == ys || xs == map (+1) ys) [2,3,8] [1,2,7]
22:05:31 <lambdabot>  True
22:05:53 <SideFFect> find a place to put that in this code?
22:05:54 <SideFFect> http://hpaste.org/3681
22:07:00 <omnId> @type find
22:07:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
22:07:05 <omnId> SideFFect: find doesn't give a Bool
22:07:17 <SideFFect> but I defined it that way
22:07:20 <omnId> SideFFect: on the rhs of two cases.
22:07:22 <SideFFect> works without my extra line
22:07:28 <omnId> oh, your find, nvm >_>
22:07:36 <newsham> > splitAt 0 [] -- sideffect, you dont need a base case for splitIn2
22:07:36 <SideFFect> I add this, doesnt work
22:07:36 <SideFFect> | r + 1 /= ls = False
22:07:37 <lambdabot>  ([],[])
22:08:23 <omnId> SideFFect: I copy/pasted that code and it compiled.
22:08:34 <SideFFect> which code?
22:08:48 <omnId> http://hpaste.org/3681
22:09:08 <newsham> > splitAt (1 `div` 2) [1]
22:09:09 <lambdabot>  ([],[1])
22:09:12 <SideFFect> yeah I know it works
22:09:24 <SideFFect> I need to add my j and k as I said
22:09:31 <SideFFect> the comparison we've been doing
22:09:40 <newsham> why do you need j and k?
22:09:56 <omnId> newsham: problem statement by the prof.
22:10:08 * dmwit discovers hsc2hs and jumps
22:10:12 <dmwit> boing!
22:10:12 <SideFFect> I need to compare a[k] with a [j] + 1 and if the same then end program
22:10:23 <newsham> omnId: the example was in an imperative language that used j and k, I dont see why j and k are needed in the haskell code
22:10:25 <SideFFect> but not sure where to put it
22:10:44 <SideFFect> I dont either, but he said he wants it so he can test for the case of [1,2]
22:10:50 <SideFFect> (he wants the program to end if so)
22:10:56 <newsham> what is the case [1,2] ?
22:10:59 <tehgeekmeister> how to coerce an Int to Integer?
22:11:07 <SideFFect> lets say find 3 [1,2]
22:11:13 <SideFFect> he wants it to give error
22:11:14 <faxathisia> > (fromIntegral (3 :: Int)) :: Integer
22:11:16 <lambdabot>  3
22:11:18 <omnId> find _ [1,2] = error "this is unusual."
22:11:19 <SideFFect> like not run anything
22:11:29 <SideFFect> hes a very weird professor
22:11:38 * dmwit deflates
22:11:44 <dmwit> It only appears to deal with pointers.
22:11:52 <newsham> find n xs | n >= length xs = error "bad bad bad"
22:11:58 <SideFFect> he wanted this in haskell, which is almost written
22:11:59 <SideFFect> http://hpaste.org/3682
22:12:06 <faxathisia> man
22:12:12 <SideFFect> newsham whats that?
22:12:27 <faxathisia> SideFFect: Just tell the dude, port your stuff to haskell yourself!
22:12:31 <newsham> wait..   find 3 [1,2] gives an error?
22:12:33 <newsham> that doesnt make sense.
22:12:41 <newsham> find 3 [1,2] should return whatever means "not found"
22:12:47 <ac> Isn't cabal supposed to download libraries and install them?
22:12:52 <sjanssen> ac: no
22:12:58 <sjanssen> that's cabal-install
22:13:00 <ac> That would be a layer on top of cabal?
22:13:05 <SideFFect> yeah for me it returns false
22:13:12 <ac> sjanssen: how do I get cabal-install?
22:13:20 <SideFFect> but he wants it to stop completely
22:13:25 <newsham> it does stop
22:13:25 <SideFFect> its weird
22:13:28 <newsham> it stops and returns False
22:13:38 <sjanssen> ac: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0
22:13:39 <newsham> how do you mean "immediately?
22:13:40 <lambdabot> http://tinyurl.com/yss6oz
22:13:47 <SideFFect> but it only stops because its not there
22:13:54 <SideFFect> he even wants find 2 [1,2] to stop
22:14:04 <newsham> why would "find 2 [1,2]" stop?
22:14:20 <newsham> it sounds like your description is confusing elements with indices
22:14:33 <newsham> "find x xs" means "find x as an element in xs"
22:14:49 <newsham> not "find x as an element of xs starting with the xth element in the list"
22:15:01 <SideFFect> he wanted this
22:15:01 <SideFFect> http://hpaste.org/3683
22:15:17 <SideFFect> yeah my find works as I want it...I just need to implement that bs case
22:15:41 <newsham> side: your code doesnt have a j or k and can never have the situation where j+1 <> k.
22:16:00 <SideFFect> but isnt that a good thing?
22:16:15 <SideFFect> but now I have to re-write it to test for that case first? argh
22:16:17 <newsham> its a great thing.. your code doesnt have silly requirements that can go wrong.
22:16:25 <ChilliX> sethk: yes, you need -dev packages for headers
22:16:26 <newsham> your code has no way to represent a list of negative length
22:16:36 <newsham> in his code, the length is negative when j and k cross
22:17:10 <SideFFect> I thought his code tests for one list being one bigger then the other?
22:17:15 <newsham> it sounds like what he wanted you to do is write a function "find x in xs between indices j and k"
22:17:23 <newsham> and each time you recurse you update j and k.
22:17:30 <SideFFect> yeah, binary search
22:17:35 <SideFFect> I thought thats what I had?
22:17:36 <newsham> and if j and k ever cross, then the invariant has been violated and you want to abort
22:17:53 <newsham> but you dont do that.. what you implemented is "find x in xs" and at each point you chop the list in half and recurse
22:17:57 <newsham> there is no j or k to keep track of
22:18:01 <ChilliX> dmwit: what version of c2hs and ghc?
22:18:12 <dmwit> c2hs 0.15.0, ghc 6.6.1
22:18:28 <SideFFect> well, he said to reqrite it and TRY to be as close to the original imperitive language as possible
22:18:28 <newsham> your j is always implicitely zero and your k is always implicitely the length of the current list
22:18:34 <newsham> and therefore k can never be less than j
22:18:48 <SideFFect> hm... so is there someway to rescue myself? :P
22:18:51 <dmwit> ChilliX: Also, cabal 1.3
22:18:52 <newsham> well you could do that if you want.. but your current code isnt "as close to the original imperative language as possible"
22:19:13 <newsham> here's a hint: in your code each time you try again your list is shorter.
22:19:14 <dmwit> ChilliX: Though I have cabal 1.1.6.2 installed, too, if that's a problem.
22:19:24 <newsham> in his code each time he tries again,his list is the same list, but his indices changed.
22:19:34 <newsham> you could write your code to operate that way if you wanted to
22:19:45 <newsham> (it would be kind of silly, but it sounds like thats what you think he wants)
22:20:05 <SideFFect> well he did an example on the board and he shrank the list each time
22:20:09 <SideFFect> so I think I was ok?
22:20:29 <newsham> so if he was shirnking the list, then why does he need pointers into the list to keep track of it?
22:21:06 <SideFFect> I have no idea...he just writes these things in his sleep
22:21:10 <SideFFect> and hopes it makes sense
22:21:18 <ChilliX> dmwit: What OS and what error?
22:21:34 <newsham> side: well, try to rewrite it again using indices into the list as he does
22:21:39 <ChilliX> Not sure about cabal dependencies, dcoutts did the cabal code.
22:21:59 <dmwit> ChilliX: Linux 2.6.21.1 on i686; error is http://hpaste.org/3686
22:22:05 <newsham> as a hint: each time you "loop around" you will keep the same list but update the indices
22:22:37 <SideFFect> rewrite? this took me 6hrs to write...
22:22:42 <newsham> it sounds like your professor doesnt like haskell that much and prefers imperative languages :)
22:22:55 <SideFFect> actually he loves functional programming heh
22:22:56 <newsham> side: *shrug* you asked me, thats the answer.
22:23:08 <SideFFect> I know...I guess I have no choice
22:23:14 <faxathisia> Is it just me who hands in ridiculous homework answers to make fun of teachers silly assignments?
22:23:16 <SideFFect> anyway I could keep any of the existing code?
22:23:18 <newsham> i like your current implementation, btw.
22:23:25 <SideFFect> thanks
22:23:43 <SideFFect> I might just get fed up and hand that in saying this is the RIGHT way to implement it and ur way was silly
22:23:47 <newsham> side: you dont need your existing code.  the new code might be similar, but still different
22:23:58 <SideFFect> wow a start from scratch thing :P
22:24:00 <faxathisia> SideFFect: That's quite acceptable imo
22:24:04 <dmwit> ChilliX: Hiding Cabal-1.3 seems to fix this.
22:24:15 <ChilliX> ok
22:24:17 <faxathisia> SideFFect: You can title the work "Wake up!"
22:24:17 <SideFFect> hm...I wonder what he'll say :P
22:24:19 <newsham> side: its only a dozen lines of ocde
22:24:20 <SideFFect> lol
22:24:26 <newsham> "from scratch" shouldnt be so bad :)
22:24:34 <SideFFect> yeah but my haskell isnt great at all :9
22:24:37 <SideFFect> :(*
22:24:59 <newsham> i wouldnt be so brash about it
22:25:07 <hpaste>  agnokapathetic pasted "trouble thinking non-imperatively" at http://hpaste.org/3687
22:25:22 <newsham> but saying "this code does not have any invariants that can be violated" would get the point across politely
22:25:25 <SideFFect> how do I keep track of indices tho?
22:25:31 <faxathisia> > unwords "foo bar baz"
22:25:32 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
22:25:34 <faxathisia> :O
22:25:35 <agnokapathetic> i seem to be having trouble understanding how to do a somewhat simple task
22:25:37 <SideFFect> heh I wouldnt mind writing that :P
22:25:39 <faxathisia> :t unwords
22:25:39 <newsham> side: pass em in as arguments to the function
22:25:40 <lambdabot> [String] -> String
22:25:47 <faxathisia> > words "foo bar baz"
22:25:49 <lambdabot>  ["foo","bar","baz"]
22:26:06 <sethk> ChilliX, I can't really install glut, except from source, without upgrading my entire ubuntu system.  How do I tell ghc-6.8.1 to skip glut?
22:26:24 <agnokapathetic> how do i assign a variable conditionally
22:26:34 <agnokapathetic> like depending on another variables value?
22:26:38 <SideFFect> hmm
22:26:43 <glguy> x = if b then y else z
22:26:50 <glguy> x | b = y | otherwise = z
22:26:52 <agnokapathetic> in the case of http://hpaste.org/3687
22:27:21 <glguy> agnokapathetic: for the second use of "args" consider: args'
22:27:25 <faxathisia> agnokapathetic: instead of args:10000 did you maybe want args ++ [10000] ?
22:27:31 <newsham> agnok: [fn, a, b] = if (length args) == ....
22:27:45 <newsham> instead of using args !! 0,  args !! 1, ...
22:27:53 <newsham> you can use "readFile fn"
22:27:57 <omnId> agnokapathetic: you also need a 'let' for the args binding in your do block.
22:28:11 <agnokapathetic> faxathisia: yeah, i do mean that, i was just trying to sketch it out :-)
22:28:31 <SideFFect> btw- can I change my code to output Found item 4 in position x easily?
22:28:33 <agnokapathetic> omnId: would that prepend the do statement?
22:28:50 <omnId> hm?
22:28:58 <newsham> side: nope.  your current code doesnt keep track of what position it is found at
22:29:04 <newsham> it just keeps track of "found" or "not found"
22:29:07 <dmwit> SideFFect: Yes, just keep track of position information by passing two more parameters.
22:29:10 <omnId> for your second binding, let args' = if ...
22:29:18 <agnokapathetic> ah okay
22:29:42 <SideFFect> dmwit: how?
22:29:56 <omnId> agnokapathetic: if you don't give it a different name it'll be defined in terms of itself recursively (!)
22:30:00 <ChilliX> sethk: Try removing the whole GLUT tree from libraries/
22:30:07 <newsham> agnok: not sure whats wrong with your paste..
22:30:14 <newsham> looks like a reasonable approach
22:30:46 <agnokapathetic> newsham: aside from the fact it won't compile?
22:30:58 <hpaste>  (anonymous) annotated "trouble thinking non-imperatively" with "(no title)" at http://hpaste.org/3687#a1
22:31:08 <newsham> "trouble thinking non-imperatively"  I assumed you wanted hints on going more functional
22:31:17 <sethk> ChilliX, that should work.  :)   I'm downloading the most recent ubuntu install.  I suspect that there will be multiple problems on this comparatively ancient installation.
22:31:35 <newsham> I think your code would look nicer with a "printOne (a, b) = ..."
22:31:35 <omnId> (anonymous), it needs indented more
22:31:41 <newsham> and mapM_ printOne $ ...
22:31:50 <newsham> you like to use !!1 and fst
22:31:52 <dmwit> SideFFect: You can modify "find" to be of type Pos -> Pos -> Integer -> [Integer] -> Pos, where type Pos = Integer tells the beginning and end indices of the current list.
22:32:01 <omnId> the 'then' to the left of the args' will break args's definition
22:32:18 <SideFFect> hm I could true
22:32:20 <dmwit> SideFFect: Then you write a wrapper function findForReal x bs = find 0 (length bs) x bs -- or so
22:32:31 <agnokapathetic> newsham: ill always take tips on functional style :-)
22:32:49 <SideFFect> but in my code, where (ls, r:rs) = splitIn2 bs cant I just use l and r to test the heads of the lists respectively?
22:33:04 <agnokapathetic> newsham: but, im just trying to figure out how to do default values
22:33:04 <hpaste>  omnId annotated "trouble thinking non-imperatively" with "mind your layout.  let introduces a declaration block that may have several bindings." at http://hpaste.org/3687#a2
22:33:13 <dmwit> SideFFect: I'm not proposing a change to your algorithm.
22:33:20 <SideFFect> I know
22:34:20 <agnokapathetic> thank you :-)
22:34:35 <dmwit> SideFFect: So... what's the confusion, then?
22:34:43 <hpaste>  newsham annotated "trouble thinking non-imperatively" with "small cleanup" at http://hpaste.org/3687#a3
22:35:01 <SideFFect> I tried writing it and it didnt work :P
22:35:24 <SideFFect> I tried | r +1 /= l = False and gave error
22:35:35 <omnId> newsham: layout!
22:36:05 <omnId> newsham: the 'then' and 'else' need indented past the [ in the binding.
22:36:07 <newsham> err should be mapM_ printOne
22:36:40 <dmwit> SideFFect: ...why would you write that?
22:37:00 <dmwit> First of all, you have no binding for "l".
22:37:10 <dmwit> Second of all, the proposed change has a return value of Integer... not Bool.
22:37:13 <newsham> side: you want to return the index that the item was found at, not False
22:37:34 <newsham> your professor used "j" and "k", perhaps you should use the same names
22:38:05 <SideFFect> how do I output an indice?
22:38:19 <SideFFect> like...
22:38:19 <newsham> same way you outputted False
22:38:28 <SideFFect> I tried, I put -> String
22:38:32 <SideFFect> so I can write a line
22:38:34 <SideFFect> gave an error
22:38:48 <newsham> focus on writing a function that tells you what the index is first
22:38:52 <newsham> then worry about printing it out later
22:38:55 <SideFFect> i used putStrLn("Item" x "found")
22:38:59 <SideFFect> just to test
22:39:15 <newsham> ?type putStrLn
22:39:15 <dmwit> Heh, I bet the type-checker *loved* that.
22:39:17 <lambdabot> String -> IO ()
22:39:25 <newsham> putStrLn takes a single string
22:39:39 <newsham> ?type "Item" ?x "found"
22:39:41 <lambdabot>     Couldn't match expected type `t1 -> t2 -> t'
22:39:41 <lambdabot>            against inferred type `[Char]'
22:39:54 <newsham> thats not a valid expression
22:40:29 <SideFFect> so how would I print a line w/ text and the x value that was given?
22:40:34 <dmwit> SideFFect: You'll need to keep track during your recursion of the current position in the list.
22:40:47 <dmwit> SideFFect: Leave output for later, after you have a correct function. ;-)
22:40:52 <SideFFect> heh yeah
22:42:35 <newsham> x = 0; y = 10; while(y > 0) { x += y; } return x;
22:42:50 <newsham> in that imperative code Ihave two variables and a loop.
22:43:02 <omnId> here's a start, SideFFect:
22:43:03 <SideFFect> ahh imperative...how I miss thee
22:43:06 <newsham> i can turn that into functional code by using recursion
22:43:06 <omnId> find x j k xs | k < j = -1 -- if the lower index passes the upper, it's not in the list, so return some "not in list" dummy index.
22:43:16 <newsham> the function would look like this:
22:43:47 <newsham> f x 0 = x;  f x y = f (x+y) (y-1)
22:43:54 <newsham> (oops, I forgot to decrement my y).
22:44:12 <newsham> and the answer is:    f 0 10
22:44:28 <newsham> see how I turned the loop into recursion?  each time I wanted to loop I passed in the new versions of "x" and "y"
22:44:34 <newsham> and I made "x" and "y" arguments
22:44:57 <newsham> > let f x 0 = x; f x y = f (x+y) (y-1) in f 0 10
22:44:58 <SideFFect> yeah it takes in x+y and y-- in place of x an y
22:44:59 <lambdabot>  55
22:45:10 <dmwit> ?karma y
22:45:10 <lambdabot> y has a karma of -1
22:45:20 <goalieca> lol
22:45:23 <newsham> so I just turned an imperative loop into a recursive function
22:45:23 <omnId> y++
22:45:35 <newsham> your job is to do the same with your profs loop
22:45:49 <SideFFect> or I could tell him to go screw himself :P
22:45:55 <newsham> either way
22:45:59 <SideFFect> lol
22:46:11 <SideFFect> ill try it... ill be here all day tomor for help for sure heh
22:46:27 <omnId> SideFFect: did you see the first case I gave above?
22:46:30 <newsham> maybe you'll figure it out before then.. good luck
22:46:40 <SideFFect> thanks newsham
22:46:49 <SideFFect> and what case omnID?
22:47:13 <omnId> find x j k xs | k < j = -1 -- if the lower index passes the upper, it's not in the list, so return some "not in list" dummy index.
22:47:40 <SideFFect> ahh
22:47:47 <omnId> then write more cases for more values of x, j, k, xs, and tests on them, recurse on find with new values.
22:47:51 <SideFFect> I see how its done, but still thinking how to apply it to mine
22:48:14 <omnId> Start the whole thing off with 'otherFind x xs = find x 0 (length xs) xs'
22:48:20 <omnId> length xs - 1, maybe
22:48:53 <dmwit> In this regard, our thoughts are one.
22:48:58 <SideFFect> heh
22:49:12 <SideFFect> you guys really know your algorithms eh?
22:49:21 <omnId> @slap SideFFect's prof
22:49:21 * lambdabot places her fist firmely on SideFFect's prof's jaw
22:49:22 <newsham> eh, this is kid glove stuff
22:49:37 <SideFFect> yeah true...too bad wenever learned it the right way
22:49:42 * dmwit suspects that an Array would be better suited to this algorithm.
22:49:55 <SideFFect> lol at omnID...id like to do that
22:49:57 <omnId> dmwit: as does everyone else.
22:50:10 <newsham> dmwit: yah, i commented on the irony of his prof asking them to implement bin search on lists the other day
22:50:15 <dmwit> right
22:50:17 <newsham> and yes, ew've been talking about this for 2 days now
22:50:22 <ac> what do I do with a .cabal file? Can I use cabal-install to install a package I've downloaded that's not in the hackage database, but seems to have cabal stuff?
22:50:30 <SideFFect> yeah...fun with lists
22:50:39 <ac> nevermind, it is in hackage
22:50:46 <SideFFect> 1sec
22:50:57 <newsham> at least if its written witn indices, going from list to array is a trivial edit
22:53:04 <newsham> coqIde is kinda ugly
22:53:16 <SideFFect> need to reboot...
22:53:49 <omnId> wonder why one would "need" to reboot?
22:53:54 <newsham> windows
22:54:24 * omnId uses windows, you stuffy-nosed elitist pig.
22:55:29 <ac> cabal install says: "cabal: dist/Conftest.c: openFile: does not exist"
22:55:39 <omnId> @quote windows
22:55:39 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
22:56:05 * allbery_b always loves it when an ATM is showing a bluescreen
22:56:12 <dmwit> ?go evan_tech windows
22:56:16 <lambdabot> http://www.livejournal.com/~evan_tech
22:56:16 <lambdabot> Title: evan_tech -- Recent Entries
22:56:18 <omnId> A TV station bsod'ed, wow.
22:56:47 <ac> any ideas on how to slap cabal in to submission?
22:57:04 <omnId> ac: get a quality whip?
22:58:56 <Korollary> ac: I'd try the cabal mailing list.
22:59:05 <faxathisia> re why do you need to reboot: computer scientist, mechanic and physicist are in a broken down car, the mechanic says lets see if anything in engine has come out of place, physicist says lets check it the horsepower is enough to counter the slope of the road, computer scientist says,  Why don't we all just get out the car and back in again?
22:59:39 <omnId> heh
23:00:43 <sjanssen> ac: I heard something about cabal-install being broken with GHC 6.8.1.  I don't remember the details
23:03:30 <bauchus> hi. is it possible to define a new type at a ghci prompt?
23:03:54 <dmwit> bauchus: I think you need to put it in a file, then load that file.
23:04:06 <omnId> bauchus: nope
23:04:11 <ac> sjanssen: I just installed 6.8.1 :-P
23:05:58 <bauchus> that's a pity
23:07:09 <ac> hum. building HaXml dies with " Could not find module `Text.PrettyPrint.HughesPJ'"
23:07:53 <ac> but it claims to "expose" that
23:08:05 <ac> I mean the pretty library I have installed
23:09:46 <sjanssen> ac: you have to add it to the build-depends field of HaXml.cabal
23:10:00 <ac> sjanssen: I'm not using cabal, because it seems to be broken
23:10:13 <ac> sjanssen: or does Setup.hs use cabal?
23:10:40 <sjanssen> ac: GHC 6.8.1 has a massive reorganization of the core libraries, and most third parties haven't caught up yet
23:10:49 <sjanssen> ac: yes, Setup.hs uses Cabal
23:11:21 <ac> I wonder if 6.8.1 solved the problem I mainly installed it for :P
23:13:37 <sjanssen> ac: what was the problem?
23:13:48 <ac> the build-depends contains a list of libraries. How do I get the library name from a module path, like "Data.Map"?
23:14:23 <sjanssen> GHC will tell you when it fails
23:14:26 <ac> sjanssen: it was either a mistake in grapefruit, or a bug in ghc's type families
23:14:57 <sjanssen> ac: oh, remember that type families are not an officially supported feature in the 6.8.x series
23:15:12 <sjanssen> ac: grapefruit probably shouldn't be using them yet
23:15:19 <ac> that's what I think :P
23:16:55 <ac> ah I see, it says it right on the next line, "containers"
23:21:45 <ac> not having cabal is very not cool. I should probably either fix cabal or go back to 6.8.0
23:21:58 <ac> cabal-install that is
23:26:28 <omnId> @@ @read @run wordsWise sortNoCase' @show @yow
23:26:29 <lambdabot>  am ENGLISH? I me, PARDON speaking
23:27:34 <dmwit> PARDON me, am I speaking ENGLISH?
23:27:39 <dmwit> But what does sortNoCase' do?
23:27:45 <dmwit> ...
23:27:49 * dmwit bangs head
23:27:54 <omnId> sortBy (compare `on` toLower)
23:28:07 <omnId> map toLower rather
23:28:29 <omnId> @type sortBy (compare `on` toLower)
23:28:31 <lambdabot> Not in scope: `on'
23:28:56 <omnId> @let on f g x y = g x `f` g y
23:28:56 <lambdabot> <local>:45:0:     Multiple declarations of `L.on'     Declared at: <local>:9:...
23:29:08 <omnId> :(  @type doesn't see L.
23:36:17 <quicksilver> @type L.on
23:36:19 <lambdabot>     Interface file inconsistency:
23:36:19 <lambdabot>       home-package module `L' is mentioned,
23:36:19 <lambdabot>       but does not appear in the dependencies of the interface
23:56:54 <ac> blarg, I can't get cabal-install installed
23:59:31 <ac> I guess it's already installed, but it seems to be broken
