00:04:52 <int-e> ddarius: http://www.haskell.org/pipermail/libraries/2007-November/008593.html
00:04:53 <lambdabot> Title: Control.Category in base, http://tinyurl.com/22jtop
00:07:22 <repnop> wli: thanks for info on that pdf, looks very useful :)
00:26:04 <ddarius> Oh Jesus God.
00:27:10 <repnop> whats up ddarius?
00:33:57 <ddarius> The Control.Category proposal.
00:34:06 <ddarius> But anyway, I need to sleep.
00:34:11 <repnop> take it easy man
00:55:15 <dons> int-e, ddarius: i don't like it either. anything without a paper makes me feel weird
00:55:27 <dons> and it sure got comitted rather quickly. hmm
00:56:14 <vincenz> @type ap
00:56:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:59:44 <int-e> dons: and it was in the middle of the ghc 6.8.1 release preparations. oh well we'll see how this discussion goes.
01:00:08 <repnop> vincenz: thanks :)
01:05:19 <dons> int-e: you might be able to make a case that non of the usual suspects contributed
01:06:07 <dons> and the src is full of tabs
01:09:42 <arcatan> aargh, did haskell.org just break down
01:12:12 <dons> is it sunday?
01:12:46 <dons> then yes, it is down. (whenever it goes down, its a sunday, for some   reason)
01:12:53 <sjanssen> weird
01:21:52 <arcatan> that's a bit like those webshops which are closed nighttime
01:29:30 <mgsloan> haskell.org takes a break on the sabbath, I suppose
01:29:50 <mgsloan> goes to church, confesses its sins, that sort of thing
01:38:06 <Cale> It's up for me
01:38:34 <arcatan> yeah, now it works
02:03:01 <Mitar> i cannot remember, but i think there was a standard function, which returns newline, is this true? what is its name?
02:05:35 <matthew-_> Mitar: I'm not sure there is. But so long as the output handle isn't in binary mode, newlines should be converted appropriately to the platform correct form
02:05:48 <Mitar> ok ...
02:28:50 <Mitar> does there exist a map over tuples?
02:29:24 <ivanm> fmap maybe?
02:29:30 <int-e> no. it can't work in general because tuple elements can have distinct types.
02:29:58 <ivanm> you could do something like (first *** second) (f,g) , IIRC
02:30:05 <ivanm> @type (first *** second)
02:30:16 <lambdabot> forall (a :: * -> * -> *) b c d (a1 :: * -> * -> *) b1 c1 d1. (Arrow a, Arrow a1) => (a b c, a1 b1 c1) -> (a (b, d) (c, d), a1 (d1, b1) (d1, c1))
02:31:50 <int-e> Mitar: of course you can easily define your own map-like function for tuples if you need it.
02:32:03 <Mitar> i am making my own version of a show class (ShowXML)
02:32:24 <Mitar> and I would like to call like showXML function of every element of a tuple
02:32:45 <Mitar> (they all have defined this function as they are instances of the ShowXML)
02:33:33 <mgsloan> you'll have to make an instance of the class for every tuple length supported
02:33:36 <integral> :t gmap
02:33:36 <lambdabot> Not in scope: `gmap'
02:33:55 <mgsloan> just like how Show is implemented for tuples
02:34:19 <Mitar> this is ... ugly?
02:34:39 <int-e> tuples aren't the prettiest part of Haskell.
02:34:40 <Mitar> so is show defined for a 123 long tuple? :-)
02:34:54 <int-e> Mitar: probably not
02:35:09 <phlpp> hi guys
02:35:59 <int-e> the haskell 98 report doesn't even require 123-tuples to work.
02:36:03 <int-e> "There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7."
02:36:05 <ivanm> Mitar: I doubt there is even such a thing as a 123 element long tuple
02:36:28 <Mitar> :-)
02:36:31 <mgsloan> > show (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28)
02:36:31 <lambdabot>        add an instance declaration for
02:36:31 <lambdabot>       (Show (t,
02:36:32 <lambdabot>              t1,
02:36:34 <lambdabot>      ...
02:37:15 <int-e> ghc provides Show instances for up to 15 elements, it seems.
02:37:21 <int-e> @instances Show
02:37:21 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
02:37:29 <mgsloan> actually,
02:37:30 <mgsloan> > show (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
02:37:30 <lambdabot>        add an instance declaration for
02:37:30 <lambdabot>       (Show (t,
02:37:31 <mgsloan> yeah
02:37:31 <lambdabot>              t1,
02:37:33 <lambdabot>      ...
02:37:35 <Heffalump> we've used 41-element tuples
02:37:38 <atom> @src Num
02:37:38 <lambdabot> class  (Eq a, Show a) => Num a  where
02:37:38 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:37:39 <lambdabot>     negate, abs, signum     :: a -> a
02:37:40 <phlpp> > (1, 2, 3, 4, 5, 6)
02:37:41 <lambdabot>     fromInteger             :: Integer -> a
02:37:43 <lambdabot>  (1,2,3,4,5,6)
02:37:46 <int-e> > show (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
02:37:46 <lambdabot>  "(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)"
02:38:20 <mgsloan> and yeah, I agree, it's ugly
02:38:26 <mgsloan> there should be provisions for it
02:38:27 <int-e> Heffalump: Hmm, I really hope that this was in generated code :)
02:40:05 <mgsloan> something like the way C++ templates work could do it - generate instances on demand
02:49:32 <sjanssen> the problem is that we don't have a uniform interface to tuples
02:50:43 <njd> hi - just getting myself a ghc 6.8.1 environment - installed cabal_install but now it says: 'cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)' - any hints?
02:50:44 <phlpp> @type randomRIO
02:50:48 <lambdabot> forall a. (Random a) => (a, a) -> IO a
02:51:12 <phlpp> > randomRIO (1, 6)
02:51:14 <lambdabot>  <IO Integer>
02:54:07 <phlpp> ok, what was this random stuff about? i want something like srand() for C, so that i can set the seed e.g. to some unique-like value, like most guys do in C with TIME. i just want to produce some random values in a certain range, not only 1 time but around 1000 times, and i don't want to get the same values, at least the same cycles, again
02:54:12 <Cale> njd: Cabal 1.2.2.0 is broken with respect to cabal-install, compile cabal-install with 1.2.1 or HEAD and it'll work.
02:54:25 <phlpp> random values are just integers in the range [a,b]
02:54:57 <Cale> Um, didn't you just find that?
02:55:03 <Cale> randomRIO will do that.
02:55:22 <Cale> oh, you want to set the seed
02:55:29 <Cale> :t mkStdGen
02:55:31 <lambdabot> Int -> StdGen
02:55:37 <Cale> :t randomR
02:55:37 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
02:55:45 <Cale> :t randomRs
02:55:46 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
02:56:04 <Cale> randomR will give you a value, and another random generator to be used next time. You
02:56:12 <repnop> cale: you know a way to construct an inf data struct that is random +- 0.0001 each entry?
02:56:16 <Cale> You're expected not to use the same random gen twice.
02:56:35 <Cale> randomRs will produce an infinite list of pseudorandom values
02:56:39 <repnop> i suck at haskell still but i like to learn
02:57:41 <Cale> > [(if b then negate else id) 0.0001 | b <- randoms (mkStdGen 42)]
02:57:43 <lambdabot>  [-1.0e-4,-1.0e-4,-1.0e-4,1.0e-4,1.0e-4,-1.0e-4,1.0e-4,-1.0e-4,1.0e-4,-1.0e-4...
02:58:09 <phlpp> Cale: ok, but at least i got one problem. how to set the INITIAL random generator/seed?
02:58:24 <Cale> See that mkStdGen?
02:58:29 <phlpp> jep
02:58:32 <Cale> I'm passing it the seed that I want.
02:58:37 <Cale> In this case, it's 42
02:58:42 <phlpp> jup
02:58:56 <phlpp> that's like srand(42)
02:59:33 <phlpp> but this 42 is constant, it should be unique-like, like this srand(TIME_FOOBAR) call. so i'm asking if there's some other function which returns me such a unique-like value
02:59:44 <phlpp> just don't to have a seed twice
02:59:45 <atom> Got this error: Couldn't match expected type `Int' against inferred type `Integer'. I'm trying to define the fromInteger function for one of my datatypes, and the field in the type is defined as an Int. How do I solve this besides redefining the type to use an Integer?
02:59:52 <Cale> fromIntegral
03:00:10 <atom> @src fromIntegral
03:00:11 <lambdabot> fromIntegral = fromInteger . toInteger
03:00:16 <Cale> Most numeric conversions are solved by either fromIntegral or realToFrac
03:00:32 <Cale> :t fromIntegral
03:00:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
03:00:39 <Cale> :t realToFrac
03:00:40 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
03:00:52 <TSC> phlpp: You can get the time, using something in System.Time, and then pass that to mkStdGen
03:00:54 <puusorsa> phlpp, getStdGen
03:00:57 <atom> Cale: thanks, works
03:01:12 <puusorsa> "There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad. It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator. To get deterministic behaviour, use setStdGen."
03:01:14 <phlpp> :t getSTdGen
03:01:15 <lambdabot> Not in scope: `getSTdGen'
03:01:21 <Cale> If you're in IO, then you should usually prefer newStdGen to getStdGen.
03:01:38 <Cale> getStdGen is kind of silly, even.
03:01:40 <atom> :t signum
03:01:41 <lambdabot> forall a. (Num a) => a -> a
03:01:53 <repnop> nice to know mkStdGen
03:01:53 <phlpp> puusorsa: so u mean i don't have to set the seed?
03:02:04 <repnop> seeds are important for me hehe
03:02:10 <puusorsa> it's seeded at program startup
03:03:35 <Cale> It's really a shame that it uses the time rather than /dev/random to get a seed.
03:03:54 <repnop> well /dev/random depends on the os
03:04:10 <atom> repnop: so does gettimeofday()
03:04:16 <sjanssen> System.Random isn't really intended for serious use anyway
03:04:29 <atom> unless it uses the unix time, which is just gross
03:04:29 <repnop> atom: getimeofday() should return the same result if both oses are synced to UTC :)
03:04:42 <atom> repnop: it returns time in nanoseconds right?
03:04:53 <atom> repnop: dunno, it's been a while, I might be wrong
03:05:08 <repnop> but the way linux and fbsd collect their entropy and give it in /dev/random are different afaik
03:05:23 <atom> repnop: /dev/random is stil the best, yeah.
03:05:24 <repnop> i know linux blocks if there isn't enough entropy
03:05:32 <sjanssen> and we must remember Windows too
03:05:35 <atom> repnop: yeah, that's why linux has the /dev/urandom device
03:05:36 <repnop> dunno about fbsd
03:05:40 <repnop> yep
03:05:47 <repnop> urandom is seeded via random
03:05:56 <atom> repnop: but does not block
03:06:07 <repnop> the device blocks unless youset to non-blocking
03:06:17 <repnop> on /dev/random
03:06:29 <atom> repnop: I meant for /dev/urandom
03:06:31 <repnop> when you issue a read() to it
03:06:39 <repnop> yeah urandom doesn't block
03:07:13 <atom> sjanssen: ah, screw windows :)
03:07:15 <atom> ;)
03:07:35 <repnop> windows is the black sheep :p
03:07:50 <repnop> it has its own functions for the equiv
03:08:26 <atom> repnop: I never figure out why windows doesn't support POSIX, other than the "we want to have the monopoly" thing
03:08:36 <repnop> it has its own posix subsystem
03:08:39 <repnop> but no one uses it
03:08:42 <atom> repnop: which half-works
03:08:43 <repnop> better off using cygwin
03:08:43 <phlpp> puusorsa: but which random function do i have to use? i just thought ove using randomRs and making a random generator by using mkStdGen,  because i thought, the value of mkStdGen will be modified by this "seed from start up"
03:09:11 <phlpp> sorry for my poor understanding/flat learning curve.
03:10:02 <repnop> but win32 api has nothing to do with haskell :)
03:10:30 <repnop> i'm finally free of using windows as a desktop so i can forget such things haha
03:13:26 <repnop> though many things i love about windows, easy to inject your code in any running process :)
03:13:34 <repnop> CreateRemoteThread etc
03:13:38 <hpaste>  sjanssen pasted "besides, seeding a new generator with /dev/random is trivial" at http://hpaste.org/3954
03:15:17 <repnop> hehe
03:15:44 <repnop> sjanssen = phlpp?
03:15:48 <phlpp> ??
03:15:49 <phlpp> no
03:15:52 <repnop> oh
03:16:02 <repnop> well someone lurking contributed to the conversation
03:16:07 <phlpp> i think sjanssen has a  thousand times better haskell skill ;)
03:16:11 <repnop> ah :)
03:16:16 * repnop has no clue
03:16:47 <repnop> is there a verison of haskell besides haskell 98?
03:16:56 <atom> if I have a type T of class Num and fromInteger is defined on it, how does haskell know to run fromInteger on the "5" I pass as a parameter of type T?
03:17:13 <phlpp> @index withBinaryFile
03:17:14 <lambdabot> bzzt
03:17:20 <phlpp> @hoogle withBinaryFile
03:17:20 <lambdabot> No matches found
03:17:31 <Cale> atom: integer literals are automatically wrapped in calls to fromInteger by the compiler, if that's what you mean
03:17:56 <Heffalump> repnop: there are earlier versions, but no later versions yet
03:18:02 <repnop> Heffalump: thank you
03:18:30 <atom> Cale: yeah, that's what I mean. However, my motives for asking are such: I have a type that I want "promoted" automatically in the same way integers are
03:18:34 <phlpp> is withBinaryFile some unstable bleeding edge function?
03:18:37 <atom> is that possible?
03:18:47 <phlpp> i can't find it
03:18:51 <Cale> atom: If you make it an instance of Num, then that will apply to them.
03:19:14 <Cale> That is, you'll be able to treat 5 as a value of your type.
03:20:02 <atom> Cale: that I'm already doing, and it's great. However, is it possible to replace the "5" with another custom type and have it promoted to the required type automatically?
03:20:03 <Heffalump> atom: when you write Haskell source, literals like 5 have type Num a => a
03:20:13 <sjanssen> phlpp: it might be new in GHC 6.8
03:20:21 <phlpp> sjanssen: oh
03:20:23 <atom> Heffalump: ah
03:20:26 <Heffalump> internally, the compiler translates them to fromInteger 5, and then treats the 5 as having type Integer.
03:20:29 <atom> Heffalump: ok, I gets it now :)
03:20:33 <Heffalump> thus achieving this effect
03:21:12 <hpaste>  sjanssen annotated "besides, seeding a new generator with /dev/random is trivial" with "with openBinaryFile instead" at http://hpaste.org/3954#a1
03:22:05 <atom> @src -
03:22:05 <lambdabot> x - y = x + negate y
03:23:13 <phlpp> sjanssen: thanks!
03:23:38 <atom> Heffalump: so there isn't a way to get this kind of syntax sugar for other types, it's hardcoded into the compiler?
03:25:01 <EvilTerran> @src negate
03:25:01 <lambdabot> negate x = 0 - x
03:25:36 <atom> EvilTerran: yeah, if you forget to define one of these, you get a stack overfow :)
03:25:46 <EvilTerran> :D
03:27:05 <atom> @forall
03:27:05 <lambdabot> Unknown command, try @list
03:27:10 <atom> @src forall
03:27:10 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:27:35 <atom> @src foreach
03:27:35 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:27:38 <atom> damn :)
03:28:02 <atom> what's a rutabaga???
03:28:23 <ivanm> a vegetable, I belive
03:28:27 <ivanm> @go rutabaga
03:28:32 <lambdabot> http://www.rutabaga.com/
03:28:32 <lambdabot> Title: Kayaks, Canoes and Paddling Accessories
03:28:38 <ivanm> heh, that's not it
03:28:39 <integral> swede / turnip
03:28:54 <atom> heh
03:29:17 <atom> @src map
03:29:18 <lambdabot> map _ []     = []
03:29:18 <lambdabot> map f (x:xs) = f x : map f xs
03:29:32 <atom> found you :)
03:29:57 <phlpp> sjanssen: do i have to convert the value of betterStdGen to use it with e.g. randomRs?
03:32:04 <sjanssen> phlpp: no
03:32:43 <phlpp> :t mkStdGen
03:32:45 <lambdabot> Int -> StdGen
03:33:02 <phlpp> ah!
03:33:16 <ac> Does anybody think the following sounds appealing?
03:33:16 <lambdabot> ac: You have 1 new message. '/msg lambdabot @messages' to read it.
03:33:19 <phlpp> seems like i have to "unlift" or at least lift IO StdGen to StdGen i think
03:33:40 <ac> A simple template language that gets compiled to a haskell function or module
03:33:41 <phlpp> because sth. like randomRs (a, b) betterStdGen doesn't work because of some missing instance declaration
03:34:07 <ac> That can handle any substitution being an "IO String"
03:34:37 <sjanssen> phlpp: yes, the usual IO stuff applies
03:34:54 <atom> 26   negate (Roll dies mod) =
03:34:54 <atom>  27     (Roll (map (\(Die cnt die) = (Die (-cnt) die)) dies) (-mod))
03:35:06 <atom> compiler is reporting error on the = in the 2nd row. what's wrong?
03:35:24 <sjanssen> the = should be ->
03:35:38 <atom> sjanssen: oh. ok  :)
03:35:51 <atom> k, loads. thanks
03:36:33 <EvilTerran> ac, sounds like it wouldn't be very hygenic
03:36:50 <EvilTerran> we've got Template Haskell...
03:36:57 <ac> so each template variable would get "++" to the adjacent ones, and if one template variable was an "IO String" all the strings would get lifted/returned (whatever the term is) to IO Strings
03:37:29 <ac> EvilTerran: would Template Haskell really be useful for that?
03:37:42 <atom> ac: I thought haskell already has some notion of the c preprocessor... or have I remebered wrong?
03:37:46 <EvilTerran> it works at the level of the already-parsed syntax tree
03:37:47 <ac> I thought it might be...
03:37:59 <EvilTerran> which is much safer
03:38:22 <ac> basically I want a simple templating system for web programming and other stuff that isn't tied to XML
03:38:24 <EvilTerran> while what you're proposing works either at the token level or even below that
03:38:39 <EvilTerran> ah, i see.
03:39:03 <EvilTerran> by "language that gets compiled to [haskell]" i thought you meant "a haskell preprocessor"
03:39:51 <ac> no, just something with "<% foo %>" thingies, or maybe "{{foo}}"
03:39:59 <EvilTerran> i said i see
03:40:30 <ac> somebody wrote a really simple system, but AFAIU, it only supports simple substitution, and no function calls
03:40:42 <EvilTerran> and %>foo<% would become "++(foo)++", or equivalent with IO lifting
03:41:01 <ac> EvilTerran: something like that, but after a little thinking about it, I don't think that exact solution would really work
03:41:16 <ac> EvilTerran: but that's exactly along the lines I've been thinking
03:42:07 <ac> I don't have any details worked out, and I don't think I'm experienced enough to work them out easily :-|
03:43:50 <repnop> hey Cale you still here?
03:43:54 <Cale> yep
03:44:07 <repnop> there a way to use those random functions in ghci or you stuck importing?
03:44:51 <repnop> feel silly asking such a trivial question :/
03:45:16 <Cale> :m + System.Random
03:45:46 <repnop> ah thanks
03:45:46 <Cale> Adds System.Random to the current list of modules available in GHCi.
03:45:52 <repnop> yeah figured such
03:52:18 <igel> anyone familiar with 'Data parallel Haskell'?
03:54:45 <ac> Does anybody else want such a thing? I suppose not, or it would already be on hackage
03:57:02 <ac> actually, it would probably be just as useful without any IO lifting
03:58:28 <ac> I think it would be cool to say something like "import Page1; .... putStrLn $ page1 arg1 arg2 arg3 ... "
03:59:18 <ac> and "Page1" would be defined in a file that was mostly plain text
04:00:26 <mux> @let farey n let farey' n a b c d = if c >= n then [] else let k = (n + b) `div` d; e = k * c - a; f = k * d - b in c%d : farey' n c d e f in 0: farey' n 0 1 1 n
04:00:27 <lambdabot>  Parse error
04:00:39 <mux> @let farey n = let farey' n a b c d = if c >= n then [] else let k = (n + b) `div` d; e = k * c - a; f = k * d - b in c%d : farey' n c d e f in 0: farey' n 0 1 1 n
04:00:42 <lambdabot> Defined.
04:00:52 <mux> > farey 8
04:00:52 <lambdabot>  [0%1,1%8,1%7,1%6,1%5,1%4,2%7,1%3,3%8,2%5,3%7,1%2,4%7,3%5,5%8,2%3,5%7,3%4,4%5...
04:09:01 <TSC> > (sort $ nub [ x%y | y <- [1 .. 8], x <- [0 .. y] ]) == farey 8
04:09:01 <lambdabot>  True
04:09:45 <delYsid> whats the new darcs url for yi?
04:09:51 <delYsid> lambdabot: yi?
04:09:51 <phlpp> :t nub
04:09:52 <lambdabot> forall a. (Eq a) => [a] -> [a]
04:09:57 <phlpp> @src nub
04:09:57 <lambdabot> nub = nubBy (==)
04:10:25 <TSC> nub removes duplicate items from a list
04:20:24 <DRMacIver> Is there a good overview of Data.Binary somewhere? I can't even find any docs for it.
04:20:40 <DRMacIver> Oh, found the docs. Never mind
04:26:55 <mux> TSC: yes but that version would be *much* slower
04:27:22 <mux> especially for large orders
04:30:14 <EvilTerran> (map head . group . sort) is O(n.log n), rather than (sort.nub)'s O(n^2)
04:31:24 <EvilTerran> @check liftM2 (==) (map head.group.sort) (sort.nub) :: [Int] -> Bool
04:31:25 <lambdabot>  OK, passed 500 tests.
04:33:16 <hpaste>  Heziva pasted "How can I create a class, and say that all instance of Num are instance of it?" at http://hpaste.org/3955
04:34:42 <EvilTerran> instance Num a => Foo a where ...
04:38:44 <Heffalump> EvilTerran: no, that just says that any Foo is a Num
04:39:56 <EvilTerran> no, that'd be class Num a => Foo a
04:40:05 <Heffalump> oh, sorry, yes
04:40:17 <EvilTerran> instance Num a => Foo a actually makes the instance. the class => points the wrong way. :)
04:41:38 * EvilTerran thinks... i *think* it'd be possible to make a O(n.log n) implementation of nub, by accumulating seen elements in a set...
04:41:49 <EvilTerran> oh, wait, that'd put an Ord constraint on the elements. never mind.
04:43:51 <DRMacIver> <multiple dispatch fanboy>It would be nice to be able to specify overrides for particular type classes</mdf>
04:44:22 <vwx> @seen dcoutts_
04:44:22 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
04:44:27 <EvilTerran> there's an extension for that, isn't there?
04:45:03 <LoganCapaldo> you can do that in C++ ...
04:45:08 * LoganCapaldo ducks
04:45:14 <EvilTerran> well, there's the SPECIALISE pragma
04:45:22 <DRMacIver> Ah, that's true
04:45:25 <hpaste>  Heziva annotated "How can I create a class, and say that all instance of Num are instance of it?" with "How can I create a class, and say that all instance of Num are instance of it? (v2)" at http://hpaste.org/3955#a1
04:46:08 <EvilTerran> but that doesn't let you define the new code, only makes a non-polymorphic version of the compiled code for performance, afaict
04:46:22 <Heziva> hello :)
04:46:58 <Heziva> I'm new to Haskell, and I got some troubles with type classes...
04:47:11 <DRMacIver> That seems to be a common refrain. :)
04:47:20 <Heziva> sry :D
04:47:27 <nominolo> @users
04:47:27 <lambdabot> Maximum users seen in #haskell: 413, currently: 383 (92.7%), active: 9 (2.3%)
04:47:32 <dikini> Heziva: welcome to the club :)
04:47:37 <DRMacIver> Heziva: No, I'm not objecting. :) Just pointing out that you're not alone.
04:47:38 <Heziva> Can someone explain me why this (http://hpaste.org/3955) is wrong?
04:47:40 * EvilTerran can't remember... do you need an extension to have an "instance ... => Foo <just a type variable>"?
04:47:54 <EvilTerran> "The instance type must be of form (T a b c)"
04:48:18 <nominolo> EvilTerran: -XFlexibleInstances
04:48:40 <EvilTerran> Heziva, try adding {-# LANGAUGE FlexibleInstances #-} to the top of the file
04:48:56 <EvilTerran> *LANGUAGE, rather
04:49:05 <nominolo> or just -fglasgow-exts
04:49:27 <EvilTerran> well, yes, but then it gets quite easy to accidentally use an extension without realising that you are
04:49:32 <nominolo> {-# OPTIONS_GHC -fglasgow-exts #-}
04:49:35 <Heziva> EvilTerran> OK i'm trying ...
04:49:43 <nominolo> yeah
04:50:06 <EvilTerran> -fglasgow-exts is a bit of a sledgehammer
04:50:22 <nominolo> EvilTerran: unfortunately, not all extensions are covered by some LANGUAGE feature.
04:50:37 <integral> it would be nice to have a -fglasgow-exts -ftell-me-which-features-i-am-using
04:50:37 <EvilTerran> "i'm doing something interesting... better enable glasgow-exts"
04:50:51 <Igloo> nominolo: They should be in 6.8
04:50:52 <LoganCapaldo> Heziva: your instance for lists doesn't actually use the fact that the elements are instances of HasF ...
04:50:55 <EvilTerran> yeah, it's annoying that they don't all have a -X in 6.6
04:51:11 <nominolo> Igloo: it was some special syntax i think.  let me check ..
04:53:35 <Heziva> well.... It doesn't solve it, it just made compilator complaining for another thing :D (i'll copy it to hpast in a second)
04:54:43 <nominolo> Igloo: "Can't make a derived instance of `Data Expr'
04:54:43 <nominolo>       (You need -fglasgow-exts to derive an instance for this class)
04:54:43 <nominolo>     In the data type declaration for `Expr'"
04:55:12 <nominolo> Igloo: at least the error message should be fixed to suggest the right -X option
04:55:30 <Igloo> nominolo: -XDeriveDataTypeable
04:56:13 <Heziva> no i't OK :D I had to add {-# OPTIONS_GHC -fallow-undecidable-instances -fglasgow-exts #-} in the top of my file :)
04:56:34 <nominolo> Igloo: hm now it fails to compile
04:57:04 <Heziva> thx :)
04:57:18 <nominolo> Igloo: ok, rank2types was missing
04:57:52 <vwx> how can i have darcs whatsnew show the diff of a file in vimdiff?
04:59:22 <nominolo> heh: "{-# LANGUAGE TypeOperators, GADTs, FlexibleInstances, DeriveDataTypeable, Rank2Types, PatternGuards #-}"
04:59:47 <LoganCapaldo> nominolo: sheesh. Are you even using Haskell anymore? :)
05:00:03 <nominolo> LoganCapaldo: it's been written by jyp ;)
05:00:24 * LoganCapaldo doesn't know who jyp is
05:00:26 <nominolo> but it's probably Haskell'
05:00:37 <nominolo> LoganCapaldo: Jean-Phillippe Bernady
05:00:44 <nominolo> *Bernardy
05:00:45 <DRMacIver> Did I hear mention of someone having implemented a binary parsec recently?
05:00:48 <LoganCapaldo> I remain ignorant :)
05:00:58 <nominolo> LoganCapaldo: yi maintainer
05:01:01 <LoganCapaldo> ah
05:01:18 <DRMacIver> I'm trying to parse a binary file format and wondering what the best way of doing so is.
05:01:21 <nominolo> DRMacIver: it was a SoC project
05:03:23 <DRMacIver> Yes, but the summer of code project has approximately zero visible lines of code that I can find, and someone mentioned one in here recently.
05:03:46 <hpaste>  (anonymous) annotated "How can I create a class, and say that all instance of Num are instance of it?" with "(no title)" at http://hpaste.org/3955#a2
05:04:06 <Heziva> well... that's not better :(
05:04:08 <nominolo> DRMacIver: Philippa could know the current status
05:05:10 <DRMacIver> nominolo: Ok. Thanks. I'll ask her if I can't find anything.
05:06:01 <Heziva> does anyone knows why Haskell think that "ab" could be matched by (Num a) => Foo a ?!
05:06:28 <LoganCapaldo> this also confuses me. I hink it's that it matches a, and then applies the num constraint afterwards...
05:06:55 <Heziva> if I dont use -fallow-undecidable-instances I got this message....
05:07:22 <Heziva>  Constraint is no smaller than the instance head
05:07:23 <Heziva>       in the constraint: Num a
05:07:31 <EvilTerran> ah, yes, when deciding if instances overlap, it doesn't look at the => context, only the instance head itself
05:07:34 <LoganCapaldo> I think you have to throw in  a -fallow-overlapping-instances too
05:07:41 <EvilTerran> (not the stuff to the left of the =>, only the stuff to the right)
05:08:39 <EvilTerran> so, yes, -fallow-overlapping-instances should fix that
05:08:51 <Heziva> OK it seems to work with all those options :)
05:09:00 <EvilTerran> alternatively, you might want to rethink your approach, seeing as you're needing all these extensions
05:09:04 <EvilTerran> (just a thought)
05:09:24 <DRMacIver> It looks like what was mentioned recently whas tibbe had done some work on making a parsec-like work with bytestrings.
05:09:32 <DRMacIver> Which appears to be totally distinct from the SoC project
05:09:57 <Heziva> OK thank u very much :)
05:10:48 <LoganCapaldo> {-# LANGAUGE NoFootKevlar #-}
05:13:05 <nominolo> meh. the glorious ":back" doesn't work :/
05:13:10 <EvilTerran> ?
05:13:54 <nominolo> i did what dons described in his recent blog post, but it doesn't work
05:14:39 <nominolo> hm, i guess i should run more code in interpreted mode
05:28:30 <DRMacIver> Hm. If I have, say, two Word8s and want to read them into (say) a Word16 in big endian order, where in the libraries should I be looking?
05:29:04 <EvilTerran> Data.Bits?
05:30:24 <DRMacIver> It's not at all obvious to me how to do it with Data.Bits (short of the obvious "implement it myself" solutions, which I'd like to avoid if possible)
05:30:34 <vwx> (\(hi, lo) -> fromIntegral hi * 256 + fromIntegral lo) :: ((Word8, Word8) -> Word16) (1, 2)
05:30:47 <vwx> >  (\(hi, lo) -> fromIntegral hi * 256 + fromIntegral lo) :: ((Word8, Word -> Word16) (1, 2)
05:30:47 <lambdabot> Unbalanced parentheses
05:31:10 <vwx> >  (\(hi, lo) -> fromIntegral hi * 256 + fromIntegral lo) :: ((Word8, Word) -> Word16) (1, 2)
05:31:10 <lambdabot>  Parse error at "1," (column 86)
05:31:19 <DRMacIver> Yes, I know how to implement it. :)
05:31:38 <EvilTerran> we don't seem to have a nice way of shuffling bytes rather than bits
05:32:07 <vwx> how to convert Float to Double and Double to Float?
05:32:07 <DRMacIver> But I need to do a bunch of different byte manipulations, not just this one, so I was hoping there would be a nice pre-existing module
05:32:26 <EvilTerran> write one and stick it on hackage? ;)
05:32:31 <LoganCapaldo> > (\(hi :: Word8, lo :: Word8) -> (fromIntegral hi *  256 + fromIntegral lo) :: Word16) (1,2)
05:32:32 <lambdabot>  Parse error in pattern at "->" (column 30)
05:32:52 <DRMacIver> EvilTerran: Could do. I'm more likely to write them on need and see if I have enough at the end of it to separate out.
05:32:57 <scook0> didn't somebody recently complain (on cafe) about being unable to find pre-existing word-manipulation functions?
05:33:01 * EvilTerran would quite like some haskell equivalent to perl's pack/unpack; http://perldoc.perl.org/functions/pack.html
05:33:01 <lambdabot> Title: pack - perldoc.perl.org
05:33:56 <LoganCapaldo> EvilTerran: that strikes me as a pain in the neck as far as the types go
05:34:25 <EvilTerran> actually, a pack/unpack thing in haskell would probably be best represented as something built on top of bytestring parser-combinators
05:34:45 <LoganCapaldo> yeah
05:34:59 <LoganCapaldo> that would be less insane :)
05:35:30 <scook0> Data.Binary?
05:35:57 * SamB wonders why duff had been waiting for so long for someone to create a blobby compiler...
05:36:10 * SamB wonders why he didn't write his own
05:36:13 <DRMacIver> Oh, hm. Data.Binary is already big endian, isn't it?
05:36:26 <DRMacIver> I wonder if I can abuse that to do binary parsing.
05:36:48 <scook0> I think it has specified-endian stuff as well, somewhere
05:37:11 <DRMacIver> scook0: The docs suggest it's always in big endian order.
05:37:18 <scook0> "getWord32be" "getWord32le"
05:37:26 <DRMacIver> Hm. Ok.
05:37:46 <scook0> (in Data.Binary.Get)
05:38:17 <DRMacIver> I think I'll try using Data.Binary. I have a worrying feeling I'll get halfway through and discover it's impossible to make it do what I want though. :)
05:39:36 <scook0> from a cafe post: "Data.Binary is two different things. This is not as well explained as it could be."
05:40:52 <Heffalump> why do you need to abuse Binary to do the parsing?
05:40:57 <Heffalump> Get and Put are designed specifically for that
05:41:16 <Heffalump> the type class Binary is intended for serialisation and deserialisation where you get no control over the format
05:41:22 <_ry> how are people doing unit tests in haskell?
05:42:09 <DRMacIver> Heffalump: It just doesn't seem designed for parsing existing file formats as opposed to serialising and deserialising existing haskell types
05:42:45 * Heffalump has used Get and Put to do it
05:42:57 <EvilTerran> _ry, we get it to typecheck and forget about it ;)
05:42:59 <Heffalump> they're not very good with things like backpatching though
05:43:05 <DRMacIver> backpatching?
05:43:20 <EvilTerran> _ry, but seriously, have a look at QuickCheck, say
05:43:23 <EvilTerran> @where quickcheck
05:43:23 <Heffalump> when putting data, inserting a count of bytes before the data itself
05:43:23 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
05:43:33 <DRMacIver> Ah
05:43:40 * DRMacIver might just hand write this parser.
05:43:47 <vincenz> re
05:43:51 <Igloo> I believe there are 2 halves to the library, one that is for serialising, and another where you can tell it what endianness to expect etc for standard data formats
05:43:51 <DRMacIver> At least as a first attempt
05:43:52 <Heffalump> do you want to see some sample code that uses Get and Put?
05:44:01 <DRMacIver> That would be good if you don't mind
05:44:27 <Heffalump> it's a bit abstracted
05:44:36 <DRMacIver> In what sense?
05:45:40 <Heffalump> it doesn't just use Get/Put as the backend, it can also use strings
05:46:10 <DRMacIver> ok
05:46:20 <DRMacIver> I'd like to take a look anyway, but I probably won't understand it. :)
05:46:26 <Heffalump> just trying to sort out some conflicts, one sec
05:47:57 <Heffalump> darcs get http://urchin.earth.li/darcs/ganesh/gps
05:47:58 <lambdabot> Title: Index of /darcs/ganesh/gps
05:48:09 <DRMacIver> Thanks
05:48:26 <Heffalump> it's a generic reader for PalmDB files, instantiated for reading GPS logs
05:49:49 <DRMacIver> Thanks
05:51:01 <DRMacIver> Any particular bits I should look at?
05:51:37 <_ry> can i use guards for variables defined in after "where" ?
05:51:44 <Heffalump> _ry: yes
05:51:59 <Heffalump> DRMacIver: PalmDB/Translator.hs, I guess
05:52:17 <Heffalump> it's a bit hard to see the underlying operations because of all the type classes
05:52:21 <DRMacIver> ok. Thanks.
05:52:54 <DRMacIver> Err. Yeah. I see what you mean...
05:52:55 <Heffalump> but really, all you have to do to use Data.Binary.Get is to call things like readWord8, readWord16 etc.
05:53:45 <DRMacIver> ok. I'll give it a go. :)
05:55:25 <_ry> is there a flatten command? which takes nested lists and smashes them into one?
05:55:30 <Heffalump> concat
05:57:18 <DRMacIver> Do the binary instances for tuples do the obvious thing? i.e. read in order with no tagging?
05:57:32 <Heffalump> no clue, sorry
05:57:46 <DRMacIver> I suppose I should just check the source, sorry...
05:58:24 <DRMacIver> Yes, looks like
06:01:14 <_ry> do if statements act like typical functions? i.e. do they return a value? can i do 1 + (if x > 0 then x else y)
06:01:28 <EvilTerran> that's the *only* thing you can do with them
06:01:53 <EvilTerran> everything's a value, even control structures :)
06:02:18 <EvilTerran> > if 1 == 2 then "true!!!" else "false :("
06:02:24 <lambdabot>  "false :("
06:02:49 <EvilTerran> > (if True then (+1) else (*2)) 3
06:02:50 <lambdabot>  4
06:03:13 <balodja> > let 1 = 1 in if 1 == 2 then "true" else "false"
06:03:14 <lambdabot>  "false"
06:03:29 <balodja> > let 1 = 2 in if 1 == 2 then "true" else "false"
06:03:30 <lambdabot>  "false"
06:04:22 <EvilTerran> let 1=1 in... is a pattern match
06:04:37 <EvilTerran> or let 1=2 in...; it's never evaluated, either way, as you don't bind any values
06:04:40 <EvilTerran> *variables
06:05:03 <Baughn> balodja: I've seen that work on /some/ implementations. Not this one, though.
06:05:09 <b_jonas> that's because let implicitly does a ~ match, right?
06:05:11 <EvilTerran> > let (==)=(/=) in if 1 == 2 then "true!!!" else "false :("
06:05:12 <lambdabot>  "true!!!"
06:05:28 <b_jonas> that's different
06:05:48 <EvilTerran> yeah. (let PAT = EXP in EXP') == (case EXP of ~PAT -> EXP')
06:05:51 <b_jonas> the haskell report defines how patterns treat numbers:
06:06:02 <b_jonas> they're sort of like data constructors, but not exactly
06:06:08 <EvilTerran> numbers are pretty much constructors, are the- i thought so :)
06:06:50 <EvilTerran> so you can't re-assign them; let 1=2 in... is like let True=False in..., or let Maybe x = Nothing in...
06:06:53 <EvilTerran> *Just x
06:07:14 <EvilTerran> except, unlike that last one, you have no way of telling that it failed, as there's no variables bound
06:07:34 <b_jonas> EvilTerran: because numeric literals are overloaded
06:07:45 <vincenz> EvilTerran: not to mention that
06:07:46 <b_jonas> they're converted to a number with fromInteger or fromRational etc,
06:07:47 <vincenz> 1 is actually
06:07:49 <Baughn> EvilTerran: I would hope it's staggeringly obvious, though
06:07:50 <vincenz> (fromInteger 1)
06:07:51 <b_jonas> and then are compared with ==
06:08:02 <b_jonas> which can do something unexpected for some types
06:08:40 <EvilTerran> Baughn, i mean it doesn't affect the semantics of the program whether a pattern in a let matches or not, if it's got no variables bound in it
06:08:40 <b_jonas> but for plain Integers, they're pretty much like ordinary data constructors
06:09:08 <EvilTerran> b_jonas, ahh... that makes sense
06:09:09 <Baughn> EvilTerran: Makes sense
06:09:22 <b_jonas> EvilTerran: isn't that only with lazy matches?
06:09:24 <b_jonas> I mean,
06:09:27 <Baughn> EvilTerran: I /have/ seen 'let 1 = 2 in 1' return 2, though. Is that a bug?
06:09:32 <EvilTerran> let bindings _are_ lazy
06:09:39 <b_jonas> EvilTerran: yep
06:09:53 <b_jonas> > case 2 of { 1 -> 1 + 8 }
06:09:54 <lambdabot>   Non-exhaustive patterns in case
06:10:01 <EvilTerran> you'd do the strict equivalent with (case EXP of PAT -> EXP'), yes
06:10:39 <b_jonas> > let (1, a) = (2, 10) in a + 1
06:10:39 <lambdabot>   Irrefutable pattern failed for pattern (1, a)
06:10:49 <b_jonas> > let ((~1), a) = (2, 10) in a + 1
06:10:50 <lambdabot>  11
06:10:58 <vincenz> evil
06:11:02 <b_jonas> so they're only lazy on top level
06:11:03 <EvilTerran> yes? :)
06:11:27 <b_jonas> > case 2 of { ~1 -> 1 + 8 }
06:11:27 <lambdabot>  9
06:11:41 <b_jonas> > case 2 of { 1 -> 1 + 8; _ -> -1 }
06:11:46 <lambdabot>  -1
06:12:06 <b_jonas> which shows that they're compared for equalty when matched non-lazily
06:22:44 <MyCatVerbs> :t all
06:22:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:23:06 <LoganCapaldo> > typeOf all == typeOf any
06:23:13 <lambdabot>  Add a type signature
06:23:34 <mauke_> > all `asTypeOf` any
06:23:34 <lambdabot>  Add a type signature
06:23:45 <LoganCapaldo> @type let a = any `asTypeOf` all in a
06:23:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:24:45 <Elifant> @hoogle (MonadTrans t, Monad m) => (m a1 -> m a2 -> m r) -> t m a1 -> t m a2 -> t m r
06:24:46 <lambdabot> Did you mean: (MonadTrans t, Monad m) => (m A1 -> m A2 -> m r) -> t m A1 -> t m A2 -> t m r
06:25:00 <LoganCapaldo> waaaaa?
06:26:04 <LoganCapaldo> @type (lift .) . f
06:26:07 <lambdabot> Not in scope: `f'
06:26:15 <LoganCapaldo> @type \f -> (lift .) . f
06:26:15 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) a1 a2. (MonadTrans t, Monad m) => (a2 -> a1 -> m a) -> a2 -> a1 -> t m a
06:26:44 <TSC> It seems that typeOf doesn't go well with polymorphism
06:26:44 <Elifant> @hoogle (MonadTrans t, Monad m) => (m A1 -> m A2 -> m r) -> t m A1 -> t m A2 -> t m r
06:26:45 <lambdabot> No matches, try a more general search
06:27:08 <Mauke> hoogle doesn't do classes
06:27:10 <TSC> At least with lambdabot
06:27:24 <Elifant> so how to find function I need?
06:27:28 <EvilTerran> TSC, Data.Typeable can't represent polymorphism
06:27:43 <TSC> Ah
06:27:50 <LoganCapaldo> @type (\f -> (lift .) . f) :: (MonadTrans t, Monad m) => (m a -> m b -> m c) -> (t m a -> t m b -> t m c)
06:27:51 <lambdabot>     Couldn't match expected type `t m'
06:27:51 <lambdabot>            against inferred type `m' (a rigid variable)
06:27:51 <lambdabot>       `m' is bound by the polymorphic type
06:28:36 <Mauke> @src MonadTrans
06:28:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:28:43 <LoganCapaldo> @type \f a b -> do { a' <- lift a ; b' <- lift b ; lift (f a'  b') }
06:28:44 <lambdabot> forall a (t :: (* -> *) -> * -> *) a1 (m :: * -> *) a2. (MonadTrans t, Monad m, Monad (t m)) => (a -> a1 -> m a2) -> m a -> m a1 -> t m a2
06:29:10 * LoganCapaldo can't seem to come up with a way to write it to have the exact type he wants
06:30:00 <Mauke> yeah, you'd need a way to untrans a value
06:30:12 <vincenz> you need gravity :)
06:30:17 <vincenz> to do the reverse of a lift/elevator
06:30:37 <Mauke> drop should be the opposite of lift
06:30:40 <vincenz> Sadly, not all monad transformers have gravity
06:31:42 <Elifant> ok, then more concrete question: I've wrapped GenParser with StateT and need to apply usual parser operations like 'many', 'sepBy' and so on
06:31:43 <LoganCapaldo> vincenz: which ones?
06:31:57 <LoganCapaldo> Elifant: lift
06:32:06 <LoganCapaldo> @type lift
06:32:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:32:32 <Mauke> LoganCapaldo: how does that help?
06:32:49 <Elifant> LoganCapaldo: can you give me an example? 'lift' wraps monad with trans, but how to call function on unwrapped monad?
06:33:02 <LoganCapaldo> well he jsut wants to use many sepBy etc. in his StatT parser right?
06:33:11 <Mauke> yes
06:33:31 <vincenz> problem with gravitiy is that it'd be the same, in a sense as (m a) -> a
06:33:36 <LoganCapaldo> so instead of foo <- many bar you have foo <- lift (many bar)
06:33:45 <Mauke> LoganCapaldo: no
06:33:51 <Mauke> many bar doesn't typecheck
06:34:13 <LoganCapaldo> Oh I see
06:34:15 <vincenz> LoganCapaldo: or elevator, if you're in the US
06:35:00 <LoganCapaldo> x <- lift bar ; foo <- lift (many (return x)) ?
06:35:11 <LoganCapaldo> gah i got nothing
06:35:40 <LoganCapaldo> Elifant: can't you just use GenParser's st parameter instead of StateT?
06:35:57 <Elifant> I know about state parameter of GenParser, but I don't want to use it, because only small part of my parser needs state.
06:36:27 <Mauke> you'll have to write your own parser combinators with manual state plumbing
06:36:28 <vincenz> LoganCapaldo: they should do something like
06:36:37 <LoganCapaldo> explicitly pass the state around to that bit?
06:36:38 <vincenz> floor2 = lift . lift
06:36:45 <vincenz> floor3 = lift . lift . lift
06:37:11 <Elifant> LoganCapaldo: well, I can ever write parser without parsec, but is it the preffered way? :)
06:37:21 <LoganCapaldo> I dunno
06:37:38 <vincenz> Elifant: I like parsec for some things, alex/happy for others
06:38:04 <Mauke> is parsec still maintained?
06:38:24 <Elifant> parsec is perfect for this concrete task, because language is highly dynamic
06:38:39 <LoganCapaldo> You could be a real evil sob and use IORefs and unsafePerformIO :)
06:39:05 <Elifant> yeah, or C language :)
06:39:20 <mauke> regexes
06:40:09 <DRMacIver> Hmm. Can I read and write bytestrings as utf8?
06:40:14 <Elifant> so, there is no way to use StateT GenParser?
06:40:37 <mauke> no sane way, unless you reimplement all combinators first
06:40:49 <LoganCapaldo> Seems like GenParserT State would've worked
06:40:55 <Philippa> Mauke: Parsec itself hasn't seen much maintenance in a while, but it's fair to call it stable. There's been the recent SoC work generalising it, which isn't release-ready yet though ddarius offered to lend a hand with it
06:40:57 <LoganCapaldo> but I've been wrong before
06:41:08 <mauke> Philippa: s/stable/broken/
06:41:11 <LoganCapaldo> notably within the last 10 minutes
06:41:40 <mauke> by which I mean notFollowedBy is broken
06:41:48 <Philippa> how so?
06:42:02 <mauke> just look at the type
06:42:14 <Elifant> and option should return Maybe...
06:43:04 <mauke> notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
06:43:17 <Philippa> yes, it's a "guard"
06:43:23 <mauke> which is notFollowedBy :: Parser Char -> Parser ()
06:43:28 <Philippa> that's not broken, it's just not what you're expecting
06:43:35 <Philippa> and yes, I know how to read Parsec types off
06:43:41 <mauke> why is the argument restricted to tok/Char?
06:43:53 <DRMacIver> (Oh. What I have isn't standard UTF8 anyway. Hurrah. :( )
06:44:46 <Elifant> mauke: because parsec is not backtracking?
06:44:52 <Philippa> mauke: it generates "unexpected" errors
06:44:55 <mauke> Elifant: huh?
06:44:56 <Philippa> Elifant: wrong
06:45:03 <Elifant> mauke: if you want to look for several tokens, use try
06:45:14 <mauke> Elifant: what does that have to do with my question?
06:45:37 <Philippa> a notFollowedBy' with the more general type might be a reasonable addition
06:45:39 <Elifant> say you want to use 'notFollowedBy (string "ab")'
06:45:47 <Philippa> Elifant: that doesn't fix it
06:45:50 <Elifant> what if avaible input is 'a'
06:45:51 <mauke> Philippa: if it's just for error messages, it could use Show a => a
06:45:52 <Elifant> ?
06:46:09 <mauke> Elifant: notFollowedBy (string "ab" >> return 'x')
06:46:11 <Philippa> mauke: not for the "unexpected" error as things stand
06:46:16 <Philippa> unexpected is always a token
06:46:33 <mauke> Elifant: that doesn't work either
06:46:40 <mauke> what notFollowedBy wants is a parser that accepts a single token
06:46:56 <mauke> but the return type has nothing to do with the "side effects" of a parser
06:46:57 <Philippa> Elifant: RTFType
06:48:49 <mauke> that's like assuming IO Char will always read a single character from stdin
06:49:16 <Philippa> it's the closest guarantee the type system can manage
06:49:39 <Philippa> remember, most of Parsec's Haskell 98
06:49:43 <mauke> it's completely unrelated! how can you call it a "closest guarantee"?
06:50:23 <mauke> I can make char parsers that return anything and arbitrary parsers that always return a char
06:50:24 <Philippa> it at least accepts the right thing and catches 'obvious' wrong things
06:50:34 <mauke> it doesn't accept the right thing
06:50:48 <Philippa> the right thing includes knowing /which/ token was accepted and shouldn't have been
06:51:03 <mauke> notFollowedBy (char ';' >> return SemiColon) doesn't work, for example
06:51:27 <Philippa> no, and it's not the right thing either
06:51:54 <mauke> why not?
06:52:22 <Philippa> because ';' is the 'token', SemiColon's just a non-terminal
06:52:37 <mauke> parsec knows which tokens were consumed
06:52:53 <mauke> it doesn't have to look at a parser's return value for that
06:53:08 <Philippa> yeah, there's an alternative implementation that involves comparing two lists. Presently, Parsec doesn't count
06:53:59 <Philippa> and really, if you're that bugged? Write it yourself, submit a patch
06:54:17 <Philippa> the existing function isn't /broken/, it's just not the one you were expecting
06:54:52 <mauke> how is notFollowedBy (string "ab" >> return 'x') not broken?
06:55:25 <Philippa> again, best guarantee the language in question was actually able to offer
06:55:27 <Philippa> get over it
06:55:52 <Philippa> in the time you've spent here arguing you could've written a suitable replacement, no?
06:56:00 <mauke> not quite
06:56:19 <mauke> getting error messages right is nontrivial, especially in the presence of notFollowedBy
06:56:57 <Philippa> the majority of the work's done by the primitives
06:57:11 <mauke> that's why I turned to Parsec to see how it does it
06:57:32 <mauke> and then I noticed that the type of notFollowedBy doesn't make sense
06:57:36 <Philippa> mmm. Now that's something that's a lot easier to believe has an actual bug in it
06:58:29 <delYsid> Does anyone know the current darcs URL for yi?
06:58:36 <LoganCapaldo> @where yi
06:58:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
06:58:45 <LoganCapaldo> I'm guessing, not there :)
06:59:03 <Philippa> you're sitting there saying that in 2007 about a library last released in 2001 for a language standardised in 1998. You're using the wrong value of "make sense" because you're used to getting fuller type safety everywhere
06:59:27 <LoganCapaldo> darcs get --partial http://code.haskell.org/yi/
06:59:28 <lambdabot> Title: Index of /yi
06:59:29 <mauke> I don't need it to be type safe. I'd be happy with a runtime error
06:59:39 <Philippa> might as well complain about head being unsafe
06:59:54 <mauke> head is documented as being unsafe
07:01:03 <Philippa> and the documentation for notFollowedBy includes a definition of it
07:01:14 <Philippa> if you're only using Haddock that's your problem
07:03:37 <Philippa> now, would you like to talk about error handling? That's actually productive
07:03:57 <Philippa> the existing notFollowedBy more or less has to be left as-is for compatability reasons, unfortunately
07:06:08 <LoganCapaldo> hmm
07:19:42 <cyberix> Does standard libraries include a function to check, if a given value is numerical?
07:20:22 <cyberix> Or do I have to check separately for int, float, ...
07:20:35 <allbery_b> > reads "123foo" :: [(Int,String)]
07:20:38 <lambdabot>  [(123,"foo")]
07:20:54 <allbery_b> > reads "foo123" :: [(Int,String)]
07:21:05 <lambdabot>  []
07:22:21 <LoganCapaldo> @type lex
07:22:22 <lambdabot> String -> [(String, String)]
07:22:34 <EvilTerran> > lex "12.34"
07:22:35 <lambdabot>  [("12.34","")]
07:22:43 <EvilTerran> > lex "12qq34"
07:22:43 <lambdabot>  [("12","qq34")]
07:23:06 <LoganCapaldo> I couldn't remembe rif lex gave you a hint as to the token or not
07:23:14 <Philippa> cyberix: it should be known statically what type a given value is. Do you mean something else, like whether a string is a representation of a numeric type?
07:23:19 <LoganCapaldo> > lex "0x23"
07:23:20 <lambdabot>  [("0x23","")]
07:24:01 <cyberix> Philippa: Yes
07:24:03 <LoganCapaldo> > all isNumeric "124"
07:24:04 <lambdabot>   Not in scope: `isNumeric'
07:24:15 <LoganCapaldo> > all Data.Char.isNumeric "124"
07:24:15 <lambdabot>   Not in scope: `Data.Char.isNumeric'
07:24:20 <LoganCapaldo> > all Data.Char.isNume "124"
07:24:23 <LoganCapaldo> > all Data.Char.isNum "124"
07:24:28 <lambdabot>   Not in scope: `Data.Char.isNum'
07:24:28 <lambdabot>   Not in scope: `Data.Char.isNume'
07:24:51 <Saizan_> ?hoogle isNumeric
07:24:51 <lambdabot> No matches found
07:24:56 <Saizan_> ?hoogle isDigit
07:24:56 <lambdabot> Char.isDigit :: Char -> Bool
07:25:03 <LoganCapaldo> Doh!
07:25:12 <LoganCapaldo> > all isDigit "123"
07:25:13 <lambdabot>  True
07:25:15 <Saizan_> which doesn't quite work for floats
07:25:19 <LoganCapaldo> right
07:25:24 <LoganCapaldo> I was getting to that :)
07:25:28 <cyberix> :-)
07:25:47 <EvilTerran> you could use the functions provided by parsec for parsing various types of haskell token
07:26:45 <LoganCapaldo> > let cor = \f g x -> f x || g x in all (isDigit `cor` (== '.')) "123"
07:26:46 <lambdabot>  True
07:26:49 <LoganCapaldo> > let cor = \f g x -> f x || g x in all (isDigit `cor` (== '.')) "123.76"
07:26:50 <lambdabot>  True
07:26:53 <LoganCapaldo> > let cor = \f g x -> f x || g x in all (isDigit `cor` (== '.')) "q"
07:26:54 <lambdabot>  False
07:27:02 <LoganCapaldo> still not perfect
07:27:14 <LoganCapaldo> but maybe good enough for what you are doing
07:27:16 <cyberix> I store various inputs from getLine into a list.
07:27:26 <cyberix> It seems that they can be of different type
07:27:34 <cyberix> It should not be possible, right?
07:27:35 <Elifant> It seems I have found a way to apply 'many' to 'StateT GenParser': pmany = mapStateT (\p -> do {r <- many p; return (map fst r, snd (last r))})
07:27:52 <Elifant> is it right? can it be written shorter or simplier?
07:28:07 <LoganCapaldo> cyberix: getLine returns a string
07:28:12 <LoganCapaldo> @type getLine
07:28:13 <lambdabot> IO String
07:28:21 <LoganCapaldo> (err an IO String)
07:28:32 <Saizan_> ?type mapStateT
07:28:32 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
07:28:51 <cyberix> ok
07:29:10 <LoganCapaldo> Also is there a version of  my "cor" in the libs somewhere? I keep finding myself wanting it
07:29:37 <Saizan_> ?type \many -> mapStateT (\p -> do {r <- many p; return (map fst r, snd (last  r))})
07:29:38 <lambdabot> forall (m :: * -> *) a (n :: * -> *) a1 b. (Monad n) => (m (a, b) -> n [(a1, b)]) -> StateT b m a -> StateT b n [a1]
07:29:44 <EvilTerran> liftM2 (||)?
07:29:45 <LoganCapaldo> @hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
07:29:45 <lambdabot> No matches, try a more general search
07:29:53 <LoganCapaldo> EvilTerran: that sounds right
07:30:19 <LoganCapaldo> @type liftM2 (||) (== '.') isDigit
07:30:23 <lambdabot> Char -> Bool
07:30:27 <Saizan_> Elifant: pmany = lift (many p) ?
07:30:44 <LoganCapaldo> Saizan_: you just made the same mistake I did
07:30:57 <Elifant> Saizan_: p is 'StateT GenParser', so I can't apply 'many' to it
07:31:04 <LoganCapaldo> many takes a GenParser, p is a StateT GenParser
07:31:11 <Saizan_> ah, right
07:32:38 <EvilTerran> ?type lift
07:32:39 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:32:41 <LoganCapaldo> another way might be do { x <- get ; lift (many (runStateT p x)) }
07:33:10 <LoganCapaldo> err
07:33:24 <LoganCapaldo> well you'd have to pull out the right stuff from runStateT
07:33:31 <LoganCapaldo> and put the new state back
07:33:40 <LoganCapaldo> which I think is jsut what MapStateT does
07:34:53 <Elifant> it does. the question is whether my argument to mapStateT right?
07:34:53 <Saizan_> well it works, but i'm not sure it has the right semantic
07:35:20 <Saizan_> every time p is used by many it sees the same state
07:35:32 <Saizan_> not the one produced by the previous p
07:35:41 <Saizan_> fsvo previous
07:36:25 <Elifant> So I have to write my own version of many...
07:36:53 <Elifant> It seems it is time to integrate parsec with monad transformers...
07:37:13 <Saizan_> doesn't parsec give you the possibility to insert your state in its monad?
07:37:17 <LoganCapaldo> Elifant: remind me again why you just aren't using GenParser's state param? <g>
07:38:01 <Elifant> because only small part of my parser uses state
07:38:31 <LoganCapaldo> this seems like an awful lot of work for only a small part of your parser
07:38:32 <fasta> Wasn't ParsecT another SoC project?
07:38:49 <fasta> Did any SoC project succeed?
07:38:49 <Elifant> and, additionally, I want this part to be separate library, so it must be compatible with user parsers
07:38:59 <Saizan_> fasta: yes, even if we're talking more about MonadParsec
07:39:02 <LoganCapaldo> aha
07:39:18 <LoganCapaldo> that ameks more sense
07:39:37 <LoganCapaldo> hmm
07:39:55 <fasta> This MonadFoo design seems a really bad idea, because of the complexity issues.
07:40:23 <LoganCapaldo> Elifant: so when you are done you'll have a new parser combinator that internally uses some state but doesn't expose it to the outside world?
07:40:27 <fasta> It works upto some pretty large size of programs, but beyond that...
07:40:58 <Elifant> LoganCapaldo: yes
07:41:59 <Elifant> LoganCapaldo: to be concrete, it is expressions parser, it receives user parsers for arguments and operations and internally uses stack of operators and arguments
07:42:14 <Elifant> I know about ParsecCombinators.Expr, but I use another algorithm...
07:42:15 <Philippa_> Elifant: you're best off using the state in your parser, really
07:42:23 <Philippa_> don't fork Parsec over it
07:42:36 <LoganCapaldo> Do you need the state at "run the parser time" or "buidl the parser time"?
07:43:04 <Philippa_> and frankly, the best solution's probably just to do some manual accumulator passing and put up with it for now
07:43:36 <Philippa_> ddarius volunteered to help get the SoC Parsec code releaseworthy, so hopefully we'll have something for you at some point - unfortunately xerox didn't manage as much coding time as we'd both hoped
07:43:54 <Elifant> I don't like hacks... I isn't my job (to do quick), but my hobby (to do clean and cool).
07:44:22 <Philippa_> accumulator passing isn't a hack
07:44:38 <Philippa_> StateT does it under the hood
07:44:42 <Elifant> I have found Text.ParserCombinators.Parsely.Class, seems interesting...
07:45:11 <Elifant> Philippa_: yes, but StateT is created for not passing state manually
07:45:24 <LoganCapaldo> building an elaborate tower of monad transformers around Parsec for one small btit of your parser doesn't strike me as particular clean or cool either...
07:45:44 <Philippa_> LoganCapaldo: if we had the appropriate typeclass for Parsec parsers it'd be the right thing to do
07:45:58 <Philippa_> as it is, we don't and that's why it's not
07:46:05 <LoganCapaldo> yes
07:46:27 <Philippa_> Elifant: as a rule, writing 3x as much code to 'do it right' is a loss unless you're really going to use the generalisation later
07:47:15 <Philippa_> you could, of course, always do something shocking like call lift manually too
07:47:23 <EvilTerran> is there a function to hide the state in a state-using parsec parser?
07:47:38 <LoganCapaldo> put in under your bed?
07:47:43 <Elifant> :)
07:48:14 <Philippa_> EvilTerran: not as such, but IIRC the primitives're there to write a combinator that'll run something with state () and return
07:48:19 <Elifant> when I found that HughesPJ is only usable for strings, I generalized it to make MY code clean
07:48:37 <Philippa_> ...wait, of course they're not, sorry 'bout that
07:48:54 <Philippa_> what you /can/ do is runParser from within your parser, having got the input stream and returning it and resetting it appropriately at the end
07:48:56 <EvilTerran> embedNewState :: st0 -> st -> GenParser tok st a -> GenParser tok st0 a
07:48:58 <EvilTerran> or something
07:49:15 <Philippa_> so yeah, you can build it but not without another runParser call
07:49:37 <EvilTerran> meh. that'll cause rather gruesome error messages, won't it?
07:50:26 <Saizan_> is there a benchmark for parsec?
07:50:39 <Philippa_> EvilTerran: yeah :-(
07:50:52 <LoganCapaldo> :-( == slow?
07:51:04 <Philippa_> :-( = gruesome error messages
07:51:04 <EvilTerran> seems to me that it'd be worth making a builtin for that
07:51:05 <LoganCapaldo> oh wait
07:51:15 <LoganCapaldo> i got my wires crossed
07:51:22 <Philippa_> and yeah, it'd be worth a built-in
07:51:41 <EvilTerran> so you can keep the state of a bit of parser internal
07:52:02 <Philippa_> *nod* - it wasn't really intended for that
07:52:03 <Heziva> hello! I'm reading a paper on Haskell polymorphism, but my english is not good enougth... can anyone explain me in a few words what "polyvariant" means?
07:52:21 * EvilTerran doesn't even know what polyvariant means
07:52:25 <Philippa_> Heziva: it would help if you included some context
07:52:33 <LoganCapaldo> My english is pretty good but I have no idea what polyvariant means :)
07:52:33 <Philippa_> beyond "a paper on Haskell polymorphism"
07:53:28 <Heziva> OK ^ ^ it's for my studies.... Implementing Haskell Overloading (here: http://citeseer.ist.psu.edu/augustsson93implementing.html)
07:53:35 <lambdabot> Title: Implementing Haskell overloading - Augustsson (ResearchIndex)
07:53:48 <Heziva> i'm getting the exact sentence...
07:53:53 <EvilTerran> @seen augustss
07:53:54 <lambdabot> I saw augustss leaving #haskell 6h 38m 3s ago, and .
07:54:04 <Heziva> pitty :D
07:54:16 <EvilTerran> you could @ask him
07:54:19 <EvilTerran> @help ask
07:54:19 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
07:54:45 <syntaxfree> hey everyone.
07:54:48 <LoganCapaldo> @wn polyvariant
07:54:48 <syntaxfree> @seen sigfpe
07:54:49 <lambdabot> No match for "polyvariant".
07:54:49 <lambdabot> I haven't seen sigfpe.
07:54:59 <syntaxfree> what's sigfpe nickname here?
07:55:02 <Heziva> yep i'll ask him :)
07:55:05 <syntaxfree> s/sigfpe/sigfpe's/
07:55:40 <allbery_b> dpip[oni
07:55:50 <allbery_b> minus the errant bracket
07:56:14 <Heziva> ask heziva test
07:56:21 <Heziva> @ask heziva test
07:56:22 <lambdabot> You can tell yourself!
07:56:23 <syntaxfree> I think I'll leave him feedback on his blog.
07:56:43 <Heziva> well.... sry i'm a noob on IRC :D Could you tell me how to use this?
07:56:50 <syntaxfree> anyway, have you seen sigfpe's tutorial on E8?
07:57:01 <LoganCapaldo> Heziva: that was the right way to do it
07:57:07 <fasta> @help
07:57:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:57:13 <syntaxfree> @seen dpiponi
07:57:13 <lambdabot> I haven't seen dpiponi.
07:57:15 <LoganCapaldo> lambdabot just disapproves of people sending messages to themselves
07:57:23 <Heziva> OK :) thx
07:57:27 <syntaxfree> @seen dpipponi
07:57:27 <lambdabot> I haven't seen dpipponi.
07:57:30 <fasta> @help @seen
07:57:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:57:31 <syntaxfree> @seen dp*
07:57:31 <lambdabot> I haven't seen dp*.
07:57:33 <fasta> @help seen
07:57:33 <lambdabot> seen <user>. Report if a user has been seen by the bot
07:57:45 <fasta> @help ask
07:57:46 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
07:57:50 <syntaxfree> I didn't want to pollute his blog with "didactic" feedback.
07:58:15 <syntaxfree> has anyone seen that E8 tutorial?  I think it has far too much calculus and far too little algebra.
07:58:36 <Saizan_> which one?
07:58:45 <syntaxfree> Saizan_: on sigfpe's blog.
07:59:03 <syntaxfree> Pretty much anyone who's gonna even look into this E8 biz knows his multivariate calculus. OTOH, most people have little more than a conceptual grasp of groups, let alone Lie algebras.
07:59:32 <syntaxfree> He kinda spends a lot of time explaining what a directional derivative is, then plunges into Lie groups and Lie algebras in a single paragraph.
07:59:59 <syntaxfree> He was specifically asking for feedback, since he's gonna write part 2. Then again, I might just be full of shit.
08:00:30 <_ry> okay- i'm embarrassed because i haven't been able to solve this problem for a whole day now. I have a list of filenames, i want to open the files, read in their lines, and put all of their lines into a single list. Can anyone offer a suggestion on how to do this?
08:02:01 <fasta> _ry:     putStrLn =<< liftM concat $ mapM readFile list_of_files
08:02:03 <syntaxfree> _ry: "cat *"
08:02:14 <fasta> _ry: untested
08:02:14 <Elifant> where should I post ghc stdlib patches and suggestions to?
08:02:15 <EvilTerran> > liftM concat . mapM (liftM lines . readFile)
08:02:16 <lambdabot>  <[[Char]] -> IO [[Char]]>
08:02:57 <fasta> Oh, if you want the lines in that way, use EvilTerran's.
08:03:00 <Inspico> hi :]
08:03:26 <fasta> EvilTerran: libraries@haskell.org, IIRC, but that might have changed.
08:03:39 <EvilTerran> not I!
08:04:11 <Igloo> Elifant: See http://www.haskell.org/haskellwiki/Library_submissions
08:04:12 <lambdabot> Title: Library submissions - HaskellWiki
08:04:19 <Elifant> tnx
08:04:23 <_ry> Sigh. liftM takes a normal function and lifts it into the monad space?
08:04:34 * _ry doesn't get monads. i guess that's my problem.
08:04:37 <fasta> @src liftM
08:04:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:04:38 <syntaxfree> fasta: Haskell(putStrLn =<< liftM concat $ mapM readFile) == sh(cat *)
08:05:01 <fasta> syntaxfree: are you sure about that?
08:05:34 <syntaxfree> fasta: are you sure it isn't?
08:05:34 <fasta> syntaxfree: for i in *.foo =/ mapM_ (all files ending in .foo)
08:05:45 <fasta> syntaxfree: (in bash)
08:06:08 <fasta> syntaxfree: I don't know all the differences between the various shells, because the semantics are way too messy to comprehend.
08:07:11 <syntaxfree> well, bash(cat *) == bash (for i in * do cat $i >> temp; done; cat temp; rm temp)
08:08:01 <_ry> @index liftM
08:08:01 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:08:09 <fasta> syntaxfree: no, that's no true
08:08:23 <fasta> syntaxfree: mkdir zork; cd zork;cat *
08:08:43 <fasta> syntaxfree: mkdir zork; cd zork; touch foobar; cat *
08:08:47 <fasta> syntaxfree: compare and learn
08:09:13 <fasta> not*
08:09:19 * EvilTerran doesn't see a difference
08:09:28 <balodja> temp is not needed :)
08:09:29 <fasta> EvilTerran: what do you mean?
08:09:36 <fasta> EvilTerran: did you execute it?
08:09:46 <syntaxfree> ouch!
08:09:54 <syntaxfree> ugly corner case.
08:10:02 <syntaxfree> I hate corner cases.
08:10:03 <EvilTerran> currently on windows, i'm afraid. what's the corner case i'm clearly not aware of?
08:10:10 <fasta> As I said: shells are WAY too complicated.
08:10:19 <doserj> '*': file not found...
08:10:21 <syntaxfree> EvilTerran: it's evident from the example. empty directories return an error.
08:10:38 <EvilTerran> ah, aren't wildcards lovely
08:10:49 <LoganCapaldo> lol
08:10:52 <syntaxfree> actually bash needs a Maybe type.
08:10:53 <fasta> EvilTerran: an evil feature called nullglobbing.
08:11:08 <EvilTerran> "feature"
08:11:11 <LoganCapaldo> I woulda thunk it woulda been expanded to cat
08:11:28 * EvilTerran goes back to fighting with geometry
08:11:38 <_ry> EvilTerran: so now I have IO [String].. how can I print that?
08:11:42 <fasta> I encountered this yesterday and decided to write the simple script in Haskell.
08:11:55 <EvilTerran> _ry: (putStr =<< ...)
08:12:07 <fasta> The only inconvenient thing is that one has to import System.Directory and some regex lib.
08:12:10 <LoganCapaldo> btw
08:12:13 <LoganCapaldo> % cat *
08:12:13 <LoganCapaldo> zsh: no matches found: *
08:12:17 <fasta> Otherwise, it's much easier to understand.
08:12:33 * LoganCapaldo hugs zsh
08:12:34 <fasta> Scsh is also nice.
08:14:09 <LoganCapaldo> * in an empty directory expanding to * seems like a really dumb thing to do
08:14:31 <EvilTerran> expanding to nothing wouldn't work in this case either, though
08:14:43 <LoganCapaldo> define "work"
08:14:50 <doserj> it can get really confusing when using 'find'
08:14:53 <EvilTerran> cat; expects input on stdin
08:14:59 <LoganCapaldo> yeah
08:15:10 <LoganCapaldo> so?
08:15:19 <LoganCapaldo> you' be confused for a bit :)
08:15:20 <EvilTerran> bash(cat *) == bash (for i in * do cat $i >> temp; done; cat temp; rm temp) still doesn't hold
08:15:30 <LoganCapaldo> oh
08:15:33 <LoganCapaldo> yes
08:16:07 <EvilTerran> actually, surely that * in the second one also expands to * under the current semantics, so the second command *will* actually do the same thing?
08:16:29 <allbery_b> yes
08:16:36 <EvilTerran> (for i in * do cat $i >> temp; done; cat temp; rm temp) == (cat * >> temp; cat temp; rm temp)
08:16:53 <mauke> no, it isn't
08:17:26 <EvilTerran> or is there magic syntax around 'for' that stops that happening
08:17:27 <EvilTerran> ?
08:17:43 <LoganCapaldo> I don't understand the introduction of temp. I was under the impression that cat * --> cat file1 file2 .. filen
08:18:10 <EvilTerran> we were trying to apply equational reasoning to shell scripts
08:18:33 <b_jonas> sure, cat * >> temp will try to cat temp to itself
08:18:47 <LoganCapaldo> well but cat is part of the FFI <g>
08:18:55 <mauke> b_jonas: since when?
08:19:09 <b_jonas> mauke: at least if temp is in the current dir
08:19:17 <b_jonas> hmm wait
08:19:19 <EvilTerran> temp is a fresh variable ;)
08:19:22 <b_jonas> maybe it doesn't
08:19:25 <dmwit> This is a pretty silly argument.
08:19:26 <mauke> yeah, if it already exists
08:19:37 <b_jonas> let me try
08:19:38 <dmwit> "What is the right way for 'cat *' to behave?" -- a fine question
08:19:51 <mauke> the problem is that cat * is inherently broken and should be cat ./*
08:19:55 <dmwit> "How can I specify cat's behavior by writing more shell scripts?" -- silly question
08:20:05 <b_jonas> sorry, you're right
08:20:16 <b_jonas> it doesn not cat temp to itself
08:20:44 <b_jonas> mauke: or cat -- *
08:21:01 <allbery_b> dmwit: no, it's not.  see definitions of shcat() on solaris and freebsd (both for use before /usr is mounted, assuming an ancient but still used filesystem layout)
08:21:14 <LoganCapaldo> I think cat is a poor example, it being not a shell primitive and it being perfectly possible for me to replace /bin/cat with runhaskell or something
08:21:18 <mauke> b_jonas: touch ./-  # fail
08:21:33 <LoganCapaldo> dammit
08:21:42 <LoganCapaldo> I shoulda typed that before allbery_b spoke :)
08:22:25 <b_jonas> mauke: wow indeed
08:22:29 <b_jonas> that's wierd
08:22:49 <b_jonas> I have to take care of that when I write shell scripts
08:22:52 * LoganCapaldo notes that touch ./- works on zsh
08:23:06 <LoganCapaldo> wait
08:23:13 <LoganCapaldo> maybe i didn't understand what # fail meant
08:23:42 <b_jonas> oh, and if there are no files in the current dir, then you'll have a problem as well
08:25:02 <LoganCapaldo> Man are we offtopic or what? :)
08:25:38 <LoganCapaldo> aha
08:25:44 <LoganCapaldo> - == stdin
08:25:46 <allbery_b> consider it a continuation of the haskell-shell discussion from last night?
08:25:46 <LoganCapaldo> I see
08:26:18 <fasta> Is this a re-invokable continuation?
08:27:34 <LoganCapaldo> maybe instead of * expanding to file1 file2 .. filen it should expand to ./file1 ./file2 .. ./filen or even /absolute/path/file1 /absolute/path/file2 .. /absolute/path/filen
08:28:30 <b_jonas> it shouldn't I think
08:29:12 <LoganCapaldo> You want to be able to create a directly full of command line options and run your command with foo * ? :)
08:29:57 <b_jonas> no, that's what -- is for
08:30:11 <b_jonas> note that the getopt in the c library handles --
08:30:17 <b_jonas> so most programs should understand it
08:30:25 <allbery_b> but that doesn't help with - == stdin
08:30:39 <b_jonas> yes, that's a stupid thing
08:31:08 <LoganCapaldo> Can anyone see a downside to having * expand to absolute paths?
08:31:50 <allbery_b> in theory it could push you over argument length limits
08:32:24 <_ry> seems like a rare situation
08:32:37 <b_jonas> LoganCapaldo: yes
08:32:44 <b_jonas> firsty, I have things like
08:33:22 <allbery_b> one could also argue that it assumes that all filesystems are sufficiently unixlike to have ".", but I think that one would bite you in far more obvious ways if violated
08:33:29 <b_jonas> for f in foo*; do mv "$f" bar"${f#foo}"; end
08:34:16 <b_jonas> secondly, I might want to do, like, for f in foo*; do ln -s "../$f" "foo/$f"; end
08:34:30 <b_jonas> both of these would be broken by absolute paths
08:34:54 <b_jonas> also, there are some rare cases when you can't generate an absolute pathname for a relative pathname
08:35:09 <LoganCapaldo> ok, but what if only "naked" * expanded to absolute paths?
08:35:11 <b_jonas> also, try ls *.ps
08:35:21 <b_jonas> and ls $PAD/*.ps
08:35:26 <b_jonas> especially with ls -l
08:35:29 <b_jonas> I mean
08:35:33 <b_jonas> ls -l *.ps
08:35:37 <b_jonas> ls -l $PWD/*.ps
08:35:43 <b_jonas> the second one is ugly
08:35:58 <b_jonas> LoganCapaldo: hm,
08:36:19 <b_jonas> the symlink example was supposed to be for f in *; do ln -s "../$f" "foo/$f"; end
08:36:21 <b_jonas> that's bare *
08:36:23 <_ry> i'm looking at an expression "y >>= (mapM putStrLn)" and I want to know the actual types being used in "mapM" . how do i do that?
08:36:32 <b_jonas> if you want absolute paths you can always do ~+/* or "$PWD"/*
08:36:46 <b_jonas> while it would be difficult to get relative paths if * expanded to absolute paths
08:36:51 <b_jonas> so this way is more versatile
08:37:01 <_ry> oh and y :: IO [String]
08:37:42 <Saizan_> ?type mapM
08:37:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:37:54 <Saizan_> ?type putStrLn
08:37:55 <lambdabot> String -> IO ()
08:38:08 <Saizan_> ok, so a = String, m = IO, b = ()
08:38:32 <Saizan_> because (String -> IO ()) must be equal to (a -> m b)
08:38:40 <LoganCapaldo> b_jonas: you use things like "$PWD"/* when you expect to have these problems though. It's when you don't expect it and just use * that it bites you :)
08:39:03 <b_jonas> LoganCapaldo: no
08:39:13 <b_jonas> I think I'm not that bad at shell programming
08:39:27 <allbery_b> :t ?y >>= mapM putStrLn
08:39:27 <lambdabot> (?y::IO [String]) => IO [()]
08:39:35 <b_jonas> and when would absolute paths better than relative ones?
08:39:41 <b_jonas> it's not that common
08:40:30 <_ry> Prelude IO System Control.Monad> :t ?y >>= (mapM putStrLn)
08:40:30 <_ry> <interactive>:1:0: parse error on input `?'
08:40:49 <olsner> lambdabot > ghci
08:41:14 <Saizan_> _ry: it's an extension, :set -fglasgow-exts to enable it
08:41:22 <Olathe> > ghci
08:41:23 <lambdabot>  True
08:41:33 <resiak> > lambdabot
08:41:33 <lambdabot>   Not in scope: `lambdabot'
08:41:36 <resiak> :(
08:41:56 <olsner> oh, I guess it's not a lambdabot-ism then
08:43:09 <grahamhutton> hi wouter!
08:44:27 <njbartlett> Hi... I'm looking for some help picking an appropriate data structure and algorithm for a particular task...
08:45:30 <njbartlett> Given a set of time periods, defined as a start time and a duration, which may overlap, I want to search for all periods that contain a particular instant. The set of period to search may be large
08:47:24 <b_jonas> njbartlett: are the periods given in advance, or can they change later?
08:48:02 <b_jonas> that is, do you want to mix adding/deleting periods with searching?
08:48:06 <njbartlett> b_jonas: They are built up incrementally. I was thinking some kind of tree which is kept sorted according to start time...
08:48:25 <b_jonas> if it's incremental, then you need the data structure from Cormen
08:48:27 <njbartlett> Yeah, it's all mixed up. It's basically a group calendar kind of application
08:48:29 <b_jonas> a moment
08:48:56 <b_jonas> here it is
08:49:11 <b_jonas> interval trees, chapter 14.3 of the new edition of Cormen
08:49:36 <njbartlett> Sorry, I'm not sure what Cormen is...?
08:49:47 <b_jonas> Cormen-Leiserson-Rivest-Stein: Intr. to algorithms
08:49:56 <njbartlett> Aha. Excellent, thank you
08:50:00 <b_jonas> I don't completely understand how that tree thingy works though
08:50:31 <b_jonas> especially how it manages to find _all_ such intervals, not just one
08:50:44 <b_jonas> because that's only given as an exercise to the reader
08:50:49 <swiert> njbartlett: sounds like you may want to look at "RangedSets"
08:50:50 <swiert> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Ranged-sets-0.1.1
08:50:51 <lambdabot> http://tinyurl.com/399ko4
08:50:55 <Heffalump> you can preprocess the intervals into a list of overlapped intervals
08:51:07 <Heffalump> then keep it in a standard tree sorted by start time
08:51:43 <Heffalump> unless you change one interval that overlaps a very large number of other intervals, it should be fairly cheap to update incrementally
08:52:19 <b_jonas> yep, if you could preprocess it, it would be easy to do everything in linear time in the number of intervals
08:52:39 <Heffalump> swiert: those don't look like they identify *which* range
08:52:57 <phlpp> :t oneOf
08:52:58 <lambdabot> Not in scope: `oneOf'
08:53:08 <njbartlett> Well, I would want to incrementally add intervals to the tree... I'm assuming I can get insertion down to O(log N) though
08:53:24 <phlpp> :t Text.ParserCombinators.Parsec.oneOf
08:53:24 <lambdabot> forall st. [Char] -> Text.ParserCombinators.Parsec.Char.CharParser st Char
08:55:37 <njbartlett> Heffalump: Yeah that sounds like it would work... thanks!
08:55:51 <swiert> Heffalump: you're right. I suppose you could keep track of a list of Ranges and check that yourself...
08:57:43 <cyberix> How do I explicitly do nothing?
08:57:52 <EvilTerran> where?
08:58:01 <cyberix> function [] = nothingrelevant
08:58:09 <Deewiant> id
08:58:14 <njbartlett> cyberix: Vote for LibDems? ;-)
08:58:39 <b_jonas> njbartlett: lol
08:58:39 <EvilTerran> cyberix, ah... functions in haskell don't "do" things, though, in that sense
08:58:50 <EvilTerran> they evaluate to values
08:58:53 <cyberix> Well I have a "do" function.
08:58:55 <b_jonas> that does't always work though,
08:58:58 <Heffalump> in a do block, return ()
08:59:15 <Olathe> > return () :: IO ()
08:59:16 <lambdabot>  <IO ()>
08:59:17 <EvilTerran> what type's your function?
08:59:24 <b_jonas> how do you do that on a local election?
09:02:47 <phlpp> @src id
09:02:47 <lambdabot> id x = x
09:02:53 <phlpp> obvious!
09:03:02 <EvilTerran> or, with eta-reduction,
09:03:03 <EvilTerran> id =
09:03:06 <EvilTerran> :P
09:03:08 <phlpp> :D
09:03:09 <MyCatVerbs> EvilTerran: hahahah.
09:03:11 <MyCatVerbs> @pl id
09:03:12 <lambdabot> id
09:03:15 <MyCatVerbs> Awwww.
09:03:18 <MyCatVerbs> @pl \x -> x
09:03:18 <lambdabot> id
09:03:21 <MyCatVerbs> Damn.
09:03:21 <phlpp> @pl \x = x
09:03:21 <lambdabot> (line 1, column 4):
09:03:21 <lambdabot> unexpected "="
09:03:21 <lambdabot> expecting operator, pattern or "->"
09:03:28 <phlpp> @pl \x -> x
09:03:28 <lambdabot> id
09:03:28 <EvilTerran> @pl id id
09:03:29 <lambdabot> id
09:03:31 <phlpp> ok
09:03:32 <EvilTerran> @pl id id id id id id id id
09:03:33 <lambdabot> id
09:03:43 <MyCatVerbs> @pl \a b c = a c b
09:03:43 <lambdabot> (line 1, column 8):
09:03:43 <lambdabot> unexpected "="
09:03:43 <lambdabot> expecting pattern or "->"
09:03:49 <MyCatVerbs> @pl \a b c -> a c b
09:03:49 <lambdabot> flip
09:03:53 <MyCatVerbs> Hee.
09:04:10 <EvilTerran> @. pl djinn a b c -> a c b
09:04:10 <lambdabot> (line 1, column 1):
09:04:10 <lambdabot> unexpected "-"
09:04:10 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
09:04:31 <boyscared> @type (>>)
09:04:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:05:09 <EvilTerran> @. pl djinn (a -> b -> c) -> (b -> a -> c)
09:05:09 <lambdabot> f = flip
09:05:34 <MyCatVerbs> @djinn (a->b->c) -> (c->a->b)
09:05:34 <lambdabot> -- f cannot be realized.
09:05:46 <MyCatVerbs> @djinn (a->b->c) -> (a->c->b)
09:05:46 <lambdabot> -- f cannot be realized.
09:05:54 <MyCatVerbs> ...huh?
09:05:58 <MyCatVerbs> :t flip
09:05:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:06:04 <MyCatVerbs> Ohreit.
09:06:16 <MyCatVerbs> @djinn (a->b->c) -> (b->c->a)
09:06:16 <lambdabot> -- f cannot be realized.
09:06:19 <MyCatVerbs> @djinn (a->b->c) -> (b->a->c)
09:06:19 <lambdabot> f a b c = a c b
09:06:41 <MyCatVerbs> :t flip flip
09:06:42 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
09:07:42 <geocalc> :t flop
09:07:43 <lambdabot> Not in scope: `flop'
09:08:31 * EvilTerran quite likes flop = uncurry.flip.curry
09:08:52 <Heffalump> that's cute
09:08:57 <Saizan_> ?type  uncurry.flip.curry
09:08:57 <lambdabot> forall a b c. ((a, b) -> c) -> (b, a) -> c
09:09:15 <Saizan_> ?type  uncurry.flip.curry $ id
09:09:16 <lambdabot> forall a b. (b, a) -> (a, b)
09:09:16 <Heffalump> ?type (uncurry.flip.curry) id
09:09:17 <lambdabot> forall a b. (b, a) -> (a, b)
09:09:18 <Heffalump> bah!
09:09:26 <b_jonas> take care with names like "flop"
09:09:40 <geocalc> mmh
09:09:56 <EvilTerran> 't's not entirely a serious suggestion for the name
09:10:04 <b_jonas> because some people have recommended names "chip" and "chimp" for functions like the perl builtins "chop" and "chomp" working in the other direction
09:10:20 <shachaf> b_jonas: How would chip work?
09:10:35 <resiak> @pl \fs x -> sequence (map ($ x) fs)
09:10:35 <lambdabot> (sequence .) . flip (map . flip id)
09:10:41 <mauke> append a random character
09:10:55 <shachaf> mauke: Oh, handy! :-)
09:11:04 <Heffalump> I think b_jonas means from the front
09:11:13 * resiak growls at lambdabot 
09:11:17 <resiak> @pl \fs x -> map ($ x) fs
09:11:17 <lambdabot> flip (map . flip id)
09:11:25 <shachaf> Oh... I guess that makes more sense.
09:11:30 <Saizan_> ?type \fs x -> sequence (map ($ x) fs)
09:11:31 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => [a -> m a1] -> a -> m [a1]
09:11:34 <Heffalump> @pl \(a,b) -> (b,a)
09:11:35 <lambdabot> uncurry (flip (,))
09:11:43 <shachaf> How often do you have a newline in the front?
09:11:47 <Heffalump> @pl curry id
09:11:47 <lambdabot> curry id
09:11:54 <Saizan_> ?type \fs x -> sequence (sequence fs x)
09:11:54 <lambdabot> forall t (m :: * -> *) a. (Monad ((->) t), Monad m) => [t -> m a] -> t -> m [a]
09:11:56 <Heffalump> odd, why doesn't it turn that into (,) ?
09:12:03 <Saizan_> ?pl \fs x -> sequence (sequence fs x)
09:12:04 <lambdabot> (sequence .) . sequence
09:12:05 <EvilTerran> @pl uncurry id
09:12:06 <lambdabot> uncurry id
09:12:15 <Heffalump> @pl (,)
09:12:16 <lambdabot> (,)
09:12:17 <EvilTerran> ?type curry id
09:12:18 <lambdabot> forall a b. a -> b -> (a, b)
09:12:34 * EvilTerran blinks
09:12:35 <Saizan_> resiak: if i'm not wrong, (sequence .) . sequence should work
09:13:19 <EvilTerran> @@ @pl @djinn @type curry id
09:13:19 <lambdabot>  f = (,)
09:14:17 <EvilTerran> Heffalump, @pl doesn't seem to be able to eliminate curry
09:14:21 <resiak> Saizan_: yeah, spot on.  that instance of Monad terrifies me slightly :):
09:14:42 <EvilTerran> @pl curry.uncurry
09:14:42 <Saizan_> resiak: it's just the naked reader monad :)
09:14:42 <b_jonas> shachaf, Heffalump: yes, from the front of the string
09:14:42 <lambdabot> id
09:14:52 <EvilTerran> er, or something...
09:15:06 <Saizan_> resiak: confusing at first but very nice :)
09:16:13 <shachaf> It helps, with (r ->), to think of the types instead of the implementations.
09:16:29 <resiak> Saizan_: humm, so an expression f in the Reader monad which doesn't use ask is equivalentish to const f
09:16:44 <Saizan_> ?src Reader
09:16:44 <lambdabot> Source not found. It can only be attributed to human error.
09:16:55 <cyberix> How do I combine "read foo::Int" with map?
09:16:56 <EvilTerran> return = const, if that's what you mean
09:17:03 <Saizan_> resiak: newtype Reader r a = Reader (r -> a)
09:17:42 <resiak> EvilTerran: oh, right
09:18:11 <EvilTerran> a monadic "action" in the (r->) monad is a function expecting an r
09:18:20 <Saizan_> resiak: if you remove the newtype, m a = r -> a, so it's the monad of functions from a fixed type r
09:18:47 <EvilTerran> thus, the obvious way of "embedding" a value in the monad, ie return, is const
09:19:22 <Saizan_> ?type sequence
09:19:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:19:42 <b_jonas> Heffalump: this is the thread where the name is recommended: http://www.perlmonks.com/?node_id=437447
09:19:44 <EvilTerran> and (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b
09:19:50 <lambdabot> Title: cut of first char of a string
09:19:50 <b_jonas> see also http://www.perlmonks.com/?node_id=542549
09:19:53 <lambdabot> Title: Re: Chopping the beginning of a string?
09:19:56 <EvilTerran> @djinn  (r -> a) -> (a -> r -> b) -> r -> b
09:19:57 <lambdabot> f a b c = b (a c) c
09:20:04 <EvilTerran> @src (->) (>>=)
09:20:04 <lambdabot> f >>= k = \ r -> k (f r) r
09:20:21 <EvilTerran> (>>=) f k r = k (f r) r
09:20:29 <EvilTerran> ta-dah!
09:21:14 <Deewiant> @pl g f k r = k (f r) r
09:21:14 <lambdabot> g = flip flip id . (ap .) . flip (.)
09:21:17 <resiak> nice
09:22:13 <geocalc> @src (>=>) (=<<)
09:22:13 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:22:57 <Saizan_> ?type flip (ap . flip)
09:22:58 <lambdabot> forall a b c. (b -> a) -> (a -> b -> c) -> b -> c
09:23:14 <allbery_b> @src Reader return
09:23:14 <lambdabot> Source not found. You speak an infinite deal of nothing
09:23:32 <allbery_b> @src (->) return
09:23:33 <lambdabot> return = const
09:31:55 <ihope_> 6.8.1 is out, eh? When did that happen?
09:32:20 <defcons> reverse' [] = []
09:32:20 <defcons> reverse' (x:xs) = reverse' xs : [x]
09:32:24 <defcons> what's wrong with that?
09:32:26 <sorear> I believe the tinyurl says
09:32:36 <shachaf> defcons: You can't cons onto the end of a list.
09:32:39 <ihope_> defcons: reverse' xs is a list, not a single element.
09:32:44 <sorear> defcons: (:) is cons, not append
09:32:49 <defcons> of course
09:33:06 <defcons> ++ instead of :
09:33:24 <sorear> right.
09:34:35 <ihope_> Of course, it would work just fine (kind of) in a language where : is allowed to take non-matching arguments!
09:35:10 <sorear> ihope_: does [] : []   return [[]] or []?
09:35:19 <ihope_> sorear: [[]]?
09:35:45 <ihope_> And [1,2,3] : [4,5,6] would be [[1,2,3],4,5,6].
09:35:49 <sorear> ihope_: if : is allowed to behave as ++, you can't tell which behavior to use in that case!
09:36:05 <ihope_> Same semantics except allowing mixed lists.
09:36:20 <EvilTerran> instance Num a => Num [a]!
09:36:23 <ihope_> Typechecking is left as an exercise for the reader.
09:36:32 <LoganCapaldo> I hate exercise
09:39:05 <Saizan_> i hate reader
09:39:22 <ihope_> Caveat lector?
09:39:49 <LoganCapaldo> Caviar lecturn
09:40:06 <ihope_> Sounds delicious.
09:41:14 <defcons> is there a single-functional primitively recursive unzip function?
09:41:27 <sorear> @src unzip
09:41:28 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
09:41:49 <sorear> defcons: that's primitive recursive - what does single-functional mean?
09:42:12 <defcons> actually, that's a point. I always forget about two arguments
09:42:16 <defcons> never mind, thanks
09:42:44 <sorear> "about two arguments" ?
09:42:58 <LoganCapaldo> @hoogle [(a,b)] -> ((a, b) -> (c,d)) -> ([c],[d])
09:42:59 <lambdabot> No matches, try a more general search
09:43:02 <defcons> I don't actually want an iterative version
09:43:27 <defcons> but I'm guess that iterative is the only way
09:44:13 * LoganCapaldo wonders if unzipWith would actually get used
09:45:05 <defcons> sorear, is that really primitively recursive?
09:45:14 <sorear> defcons: Yes.
09:45:26 <defcons> okay
09:45:30 <defcons> how do you do it without fold?
09:45:32 <LoganCapaldo> acttually
09:45:38 <EvilTerran> what exactly does "primatively recursive" mean?
09:46:00 <defcons> I'm guessing what the author means is that you should not store state in the arguments
09:46:02 <sorear> @go primitive recursion
09:46:03 <lambdabot> http://en.wikipedia.org/wiki/Primitive_recursive_function
09:46:03 <lambdabot> Title: Primitive recursive function - Wikipedia, the free encyclopedia
09:46:06 <LoganCapaldo> @hoogle [a] -> (a -> (b,c)) -> ([b],[c]) would be better as unzipWith
09:46:07 <lambdabot> Did you mean: [a] -> (a -> (b, c)) -> ([b], [c]) Would Be Better As UnzipWith
09:46:22 <LoganCapaldo> @hoogle [a] -> (a -> (b,c)) -> ([b],[c])
09:46:23 <lambdabot> No matches, try a more general search
09:46:34 <sorear> LoganCapaldo: (unzip .) . map
09:46:43 <LoganCapaldo> yeah I know
09:48:31 <defcons> so is there a primitive recursive solution to unzip?
09:48:55 <Saizan_> ?src unzip
09:48:56 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
09:50:18 <wli> Why would the ~ make a difference there?
09:50:39 <defcons> anyone?
09:50:53 <Saizan_> unzip ((a,b):xs) = let (as,bs) = unzip xs in (a:as,b:bs); unzip [] = ([],[])  ?
09:50:55 <ihope_> defcons: is that unzip there not primitive recursive?
09:51:27 <defcons> it is not of the form: sum (x:xs) = x + sum xs
09:51:36 <defcons> where sum [] = 0
09:52:23 <ihope_> That's a form?
09:52:29 <Saizan_> wli: because if not the foldr would recurse deeply because each tuple constructor depends on inspecting the one of the recursive call
09:52:30 <defcons> I think you know what I mean
09:53:02 <EvilTerran> defcons, well, i for one don't
09:53:17 <wli> That could be irritating.
09:53:52 <EvilTerran> is there any reason why \ parameters aren't irrefutable by default?
09:54:04 <Saizan_> defcons: f (a,b) (as,bs) = (a:as,b:bs); unzip (x:xs) = x `f` unzip xs; unzip [] = ([],[]), does this count?
09:54:08 <defcons> sum (x:xs) = x + sum (xs) rather than sum x (a:as) = sum (x+a) as
09:54:17 <EvilTerran> it's not like there'll ever be another case to fall through to
09:54:30 <ihope_> They aren't irrefutable? Do you mean not lazy?
09:54:47 <EvilTerran> ~PAT is an irrefutable version of PAT; it never fails to match
09:55:01 <EvilTerran> although an error can occur later if PAT wouldn't've matched
09:56:04 <defcons> Saizan_, but do you see what I mean?
09:56:45 <defcons> oh, I think I get that noiw
09:57:02 <EvilTerran> unzip [] = ([],[]); unzip ((x,y):xys) = (x:xs,y:ys) where (xs,ys) = unzip xys?
09:58:08 <defcons> EvilTerran, okay thanks a lot
09:58:28 <EvilTerran> i think we'd normally call that "explicitly recursive" or what-have-you
09:58:40 <EvilTerran> "primative recursive" has a specific (albeit arcane) specific meaning
09:59:03 <EvilTerran> s/specific/technical/2
09:59:09 <defcons> okay
09:59:19 <Philippa_> I don't think it's all that arcane. It basically means "fold-like"
09:59:21 <EvilTerran> "directly recursive", maybe
09:59:43 <Philippa_> I'm not sure I see where the directness is
09:59:53 <EvilTerran> Philippa_, oh, okay. that wasn't the impression i got from trying to understand that wikipedia article, but i didn't spend long on it...
10:00:26 <EvilTerran> i imagine the point of the original question was to provide an implementation that didn't use any existing recursive functions
10:00:45 <EvilTerran> instead, opting to recurse directly
10:01:58 <Saizan_> " sum (x:xs) = x + sum (xs) rather than sum x (a:as) = sum (x+a) as" this looks more like "avoid accumulators/tail recursion"
10:03:13 <Philippa_> EvilTerran: Primitive recursion means something specific, just doing it without using existing recursive functions is nowhere near good enough
10:03:22 <Saizan_> btw, why haskell has strict rather than lazy product type matching? (like in miranda)
10:03:25 <Philippa_> for example, so long as the input's finite all primitive recursive functions terminate
10:03:35 <Philippa_> Saizan_: consistency
10:03:50 <EvilTerran> i know! but i don't think the original question meant primitive recursion in the techical sense
10:04:05 <EvilTerran> seeing as defcons didn't seem to know that technical meaning
10:05:02 <Philippa_> I wouldn't assume that, it could easily be a homework question or a theoretical one that's not been fully understood
10:05:56 <defcons> Philippa_, It's from Haskell, the Craft of Functional Programming
10:06:08 <Philippa_> FWIW, the wikipedia definition is more or less what you get if you allow primitive recursion over naturals and tuples
10:06:45 <Philippa_> it's frequently understood to generalise to algebraic datatypes, which is where "fold-like" comes in more obviously
10:07:01 <Philippa_> defcons: I'd expect that to mean primitive recursion, then
10:07:06 <Philippa_> if it's asking you whether one exists
10:07:26 <defcons> no, it said give primitive recursive definitions of reverse and unzip
10:08:30 <Philippa_> unzip is [(a,b)]->([a],[b]), right? Should be doable
10:08:57 <Deewiant> @ty unzip
10:08:58 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
10:09:04 * hgolden is back
10:09:05 <Philippa_> don't expect the primitive recursion to feel 'efficient'. You'll find map is primitive recursive
10:09:23 <Philippa_> reverse is more fun, there's a cute one using foldl
10:09:47 <Philippa_> do you understand the interpretation of folds as "replacing the constructors with functions"?
10:10:24 <wli> I've never heard of it.
10:11:29 <Saizan_> wli: foldr f z xs == replacing (:) with f and [] with z in xs
10:11:51 <Philippa_> wli: you might find l ++ r = foldr (:) r l cute
10:12:17 <Philippa_> it looks prettier if you define the flipped version 'cos you can leave the second parm pointless that way
10:12:20 <DRMacIver> Hm. I wish I could do "deriving Binary"
10:12:42 <Saizan_> DRMacIver: use derive from hackage
10:12:45 <Philippa_> "swap the [] with the tail list" :-)
10:12:58 <Saizan_> and you can do $(derive makeBinary 'Foo)
10:13:45 <DRMacIver> Saizan_: Thanks. I'll take a look.
10:14:46 <Phillemann> Is there a function to convert a tuple (a,b) to a list [a,b]? :)
10:14:54 <Phillemann> Thus, (a,a) -> [a]
10:15:25 <phlpp> ?
10:15:33 <mauke> @pl \(a,b) -> [a,b]
10:15:33 <lambdabot> uncurry ((. return) . (:))
10:15:38 <phlpp> a list can only have vars from one type?
10:15:43 <phlpp> i thought
10:15:58 <phlpp> ah (a,a) -> [a], ok
10:16:09 <Philippa_> Phillemann: no, but it's easy enough to write - \(a,b)->[a,b]
10:16:31 <Phillemann> Philippa_: Hehe, yep, just wanted to see if it's available in the prelude :)
10:16:34 <Philippa_> which is going to be more readable than the pointless version
10:16:46 <phlpp> Philippa_: use hoogle for this :>
10:17:10 <Phillemann> phlpp: Did so, it found nothing...
10:17:14 <phlpp> you can e.g. hoogle for a type signature
10:17:30 <phlpp> Phillemann: ok, then afaik you can be sure that there's no such function
10:17:37 <phlpp> s/afaik/i think
10:23:50 <defcons> reading the lambdacats makes me actually want a curry tonight
10:24:11 <phlpp> @index StdGen
10:24:11 <lambdabot> System.Random
10:24:21 <phlpp> @source System.Random
10:24:21 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
10:24:51 <phlpp> oh
10:24:57 <phlpp> actually there is no Random.hs
10:26:46 <Deewiant> what's if'
10:27:14 <Saizan_> Control.Concurrent doc says that only one thread can hold the lock on an Handle, so if a thread is blocked reading one that wants to write will block too?
10:28:23 <phlpp> :t if'
10:28:24 <lambdabot> Not in scope: `if''
10:28:48 <shachaf> @ty let if' b t f = if b then t else f in if'
10:28:48 <lambdabot> forall t. Bool -> t -> t -> t
10:29:14 <shachaf> Is there a nicer way to say (maybe (return Nothing))?
10:29:32 <augustss> Data.Bool should have that function.  Perhaps with a different name.  It's a shame it doesn't
10:29:37 <dmwit> Deewiant: if' p x y = if p then x else y
10:29:46 <Deewiant> cheers
10:30:00 <dmwit> :t fromMaybe
10:30:00 <lambdabot> forall a. a -> Maybe a -> a
10:30:01 <shachaf> Perhaps it should be called "if". :-)
10:30:05 <Deewiant> lambdabot gave it to me in @pl but doesn't find it in @ty or @src
10:30:11 * Philippa_ suggests Data.Bool.fold
10:30:16 <shachaf> @ty maybe (return Nothing)
10:30:16 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
10:30:18 <dmwit> :t maybe (return Nothing)
10:30:19 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
10:30:38 <dmwit> :t maybe
10:30:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:30:40 <Philippa_> shachaf: IIRC if's a reserved word
10:30:48 <shachaf> Philippa_: Yes.
10:30:51 <shachaf> Is there a reason, though?
10:30:55 <shachaf> Other than parentheses?
10:31:17 <phlpp> :t (>>=)
10:31:19 <Philippa_> and then and else?
10:31:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:31:32 <Philippa_> it's just syntax, sure
10:31:33 <shachaf> Philippa_: Yes, that's what replaces the parentheses.
10:32:02 <dmwit> shachaf: It looks a lot like liftM (>>)
10:32:13 <dmwit> But not quite.
10:32:16 <shachaf> @ty fmap (*>)
10:32:16 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f1 (f a) -> f1 (f b -> f b)
10:33:05 <phlpp> sorry for annoying you, but i don't get how to convert/lift sth. of type IO StdGen to StdGen
10:33:15 <mauke> you don't
10:34:38 <shachaf> phlpp: Well, with (>>=), like you said. But you have to put your result back in IO when you're done.
10:34:56 <ihope_> You don't turn IO a into a; you turn a -> IO b into IO a -> IO b.
10:36:47 <phlpp> hmm
10:47:45 <defcons> @source drop
10:47:45 <lambdabot> drop not available
10:47:56 <defcons> @source GHC.List.drop
10:47:56 <lambdabot> GHC.List.drop not available
10:48:02 <mauke> @src drop
10:48:02 <lambdabot> drop n xs     | n <= 0 =  xs
10:48:02 <lambdabot> drop _ []              =  []
10:48:02 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
10:54:45 <defcons> thank you mauke
11:00:09 <dmwit> Okay, so I'm reading the Arrow paper by Hughes.
11:00:24 <dmwit> I haven't even gotten to the good stuff, and I've already learned something:
11:00:40 <chessguy> dmwit, do tell
11:01:01 <dmwit> "The Haskell newtype declaration introduces a new type isomorphic to an existing one, where the constructor names the isomorphism."
11:01:10 <dmwit> That's such a cool way to think of newtype!
11:01:27 <Botje> it's a nice way to say "defines a type synonym" :)
11:01:52 <dmwit> Yeah, because it conveys the idea that we are talking about two different sets of values.
11:03:51 <dfranke> whaaa.  I want dependent types, dangit.
11:05:26 <dfranke> (I'm using newtype here, but I don't *want* an isomorphism.  I want an endomorphism.)
11:05:48 <chessguy> dfranke, what's that mean?
11:06:00 <dfranke> chessguy: endomorphism?
11:06:04 <chessguy> yes
11:06:14 <chessguy> as compared to isomorphism
11:06:19 <wli> dfranke: Smells like GADT's.
11:06:39 <dfranke> chessguy: a property-preserving function that maps a set onto a subset of itself.
11:07:16 <dfranke> wli: among other things.
11:07:51 <dmwit> Do you need to specify the property along with each endomorphism, I guess?
11:08:16 <wli> dfranke: I wonder if it can be done with some of those super-fancy non-H98 constructs.
11:08:42 <chessguy> dfranke, would you mind giving an example?
11:09:01 <dfranke> I have a GADT representing an arrow, and then I have a couple functions that only makes sense on certain constructors.
11:09:32 <chessguy> i can see that something like data List a = Null | Cons a (List a) -- is isomorphic to lists
11:11:15 <dmwit> f (Point x y) = Scalar x; f (Scalar x) = Scalar x -- an endomorphism that preserves... something
11:11:18 <dmwit> ?
11:12:44 <dfranke> I suppose what I could do is add a third type parameter to my GADT, which can take on one of two monomorphic types, one of which indicates that my extra functions make sense.
11:12:53 <dfranke> but that seems uglier than using newtype.
11:13:12 <dmwit> Phantom types, eh?
11:14:26 <opqdonut> dfranke: can't you just say "= undefined" for the values it doesn't work on?
11:14:37 <opqdonut> of course you lose type safeness that way
11:14:43 <dfranke> opqdonut: right
11:14:48 <dfranke> so it defeats the purpose.
11:15:02 <opqdonut> i'd say phantom types is the way to go
11:15:19 <dfranke> seriously?  That feels so dirty.
11:15:50 <wli> Is there any situation where newtypes are anything but a performance hack vs. data?
11:16:15 <dfranke> not in h98.
11:16:25 <dfranke> in ghc, newtypes allow clever deriving and data don't.
11:17:11 <wli> Sounds like ignoring newtype most of the time is fine, then.
11:18:02 <dmwit> I think you can use newtypes to shuffle type-parameter order so that you can write instances.
11:18:55 <wli> data is just as good for that, modulo the efficiency concern.
11:19:09 <dmwit> Oh, right.
11:19:15 <dmwit> Oh, no, I remember the difference.
11:19:26 <wli> The deriving affair I forgot about, and seems to be the sole distinction.
11:19:30 <dmwit> data is always tagged with a constructor, so _|_ is treated differently.
11:20:12 <dmwit> If we compare data Foo a = Foo a with newtype Foo a = Foo a, then
11:20:39 <dmwit> Foo _|_ is not the same as _|_ for the data declaration, but is the same for the newtype declaration.
11:21:17 <wli> Now I'm trying to remember why that ever matters.
11:22:23 <dmwit> heh
11:27:45 <DRMacIver> Saizan_: Thanks for the link. The Data.Derive stuff is helping a lot.
11:44:18 <Saizan_> DRMacIver: np
11:47:14 <dmwit> Aha, so it is not accurate to say, "Every monad is an arrow."  More like, "You can create an arrow from any monad."
11:47:42 <Philippa_> and a monad from any ArrowApply, IIRC. Isomorphism rather than equality, no biggie
11:48:13 <dmwit> Well, it's even more different than that, right?
11:48:14 <DRMacIver> I was under the impression that there were two arrows for every monad? Or am I confusing arrows and adjunctions?
11:48:23 <DRMacIver> Hm.
11:48:28 <DRMacIver> No, I'm just completely confused
11:48:30 <DRMacIver> Ignore me
11:49:10 <SamB> DRMacIver: I suspect you can make infinitely many arrows from a single monad...
11:49:14 <dmwit> I guess the simplest way to say what I'm thinking is to look at the kinds of monads and arrows.
11:50:02 <dmwit> i.e. in some sense monads store a value, and arrows store a transformation. (?)
11:50:53 <Saizan_> well you usually get the "reader arrow" out of a monad, no?
11:52:26 <ddarius> The (a?) natural arrow to get from a monad is the Kleisli arrow of that monad.
11:53:33 <ddarius> In DRMacIver's favor, this is (related to) one of the two canonical ways of factoring a monad back into an adjunction.
11:53:33 <DRMacIver> Hmm.
11:54:04 <DRMacIver> ddarius: Yes, that is what I was thinking of. But then I realised I'd got the directions and analogies totally confused which is why I shut up. :)
11:56:02 <DRMacIver> On a more practical note, I have a bunch of symbols and an associatiation with Word8s. e.g. FOO=1, BAR=2, BAZ=3..., etc. I want to create the object datat declaration and binary instance for this but despearately don't want to write it out in full manually. Is TH likely to be the right tool for this or should I be using something built on top of it? (Or just write a script to generate it?)
11:56:13 <DRMacIver> Well, immediately practical.
11:56:23 <DRMacIver> Arrows/monads/etc. are pretty practical once you're actually used to them. :)
11:56:37 <ddarius> TH is one way of doing it.
11:57:31 <geocalc> DRMacIver=<< it's like everything
11:58:06 <dons> DRMacIver: use the deriving tool in the binary utils directory
11:58:14 <DRMacIver> geocalc: Everything >>= DRMacIver == fail "Head exploded"
11:58:17 <SamB> DRMacIver: couldn't you just do something with "deriving Enum"
11:58:17 <dons> just temporarily deriving Data for your type
11:58:18 <SamB> ?
11:58:31 <DRMacIver> Sorry, my explanation was bad.
11:58:32 <dons> and then the script will print the Binary instance for you
11:58:43 <DRMacIver> I have a specific association of tags to numbers.
11:58:50 <DRMacIver> They're not actually in sequence like that.
11:58:59 <SamB> DRMacIver: why the heck aren't they?
11:59:07 <dons> is the association derivable?
11:59:08 <DRMacIver> SamB: Because they're the opcodes for the Java VM.
11:59:11 <dons> i.e. in constructor order?
11:59:13 <SamB> ... oh
11:59:26 <dons> if not, you'll need to write a script to do it (possibly hacking the deriving script provided with binary)
11:59:59 <DRMacIver> dons: ok. Looks like a script it is. Thanks.
12:00:07 <SamB> why does this VM spec define "must"
12:00:17 <dmwit> DRMacIver: sed 's/\(.*\)=\(.*\)/fromEnum \1 = \2\ntoEnum \2 = \1' # ;-)
12:00:20 <SamB> why don't they import the Internet Standard that does that?
12:00:21 <chucklarge> Hi, just learning Haskell... how can I iterate through tuples bigger than 2 to retrieve individual items?  ex I want "Texas" out of  ("Jones",True, "Texas", False ,39)
12:00:35 <mauke> you don't iterate.
12:00:50 <mauke> the answer is pattern matching
12:00:54 <dmwit> stateName (_,_,s,_,_) = s
12:00:56 <dons> chucklarge: use a list?
12:01:07 <mauke> dons: s/list/record type/?
12:01:08 <dons> or use pattern matching, yes.
12:01:12 <dmwit> chucklarge: Have you seen data record types?
12:01:13 <opqdonut> or accessors
12:01:32 <dons> data MyT = MyT { name :: String , ... age :: Int }
12:01:44 <dons> then use 'name' and 'age' to extract fields, i.e.   stateName s = name s
12:02:08 <dons> chucklarge: so yeah, as mauke says, looks like you want a labelled record type
12:02:12 <chucklarge> I actually have a list of records,  [ ("","",""), ("","",""), ("","","")] for example
12:02:30 <SamB> DRMacIver: explain again why you didn't arange the opcodes in order in your datatype?
12:02:53 <SamB> DRMacIver: besides, I suppose, impdep1 and impdep2
12:03:10 <DRMacIver> SamB: I could do. But then I'd have to figure out what the right order was, hope there weren't any gaps, etc.
12:03:19 <SamB> http://java.sun.com/docs/books/jvms/second_edition/html/Mnemonics.doc.html
12:03:20 <DRMacIver> I haven't actually written the datatype yet.
12:03:45 <DRMacIver> SamB: Ah ha. Thanks. :)
12:03:49 <opqdonut> i think using Enum is the neatest way
12:04:04 <DRMacIver> SamB: But there's still the issue with the high end ones.
12:04:28 <SamB> well, you can use Enum for the rest and special case those two
12:04:48 <DRMacIver> I guess.
12:05:21 <DRMacIver> I'm inclined to think that writing a script which parses that list is likely to be more robust and will give me better control over other things.
12:05:27 <SamB> hmm.
12:05:32 <SamB> possibly ;-)
12:05:43 <SamB> hadn't thought of that
12:05:57 <SamB> you'd just have to get rid of that footnote mark
12:06:01 <DRMacIver> Yeah
12:06:23 <DRMacIver> It will need a little sanitizing
12:06:35 <SamB> a tiny bit
12:07:31 <SamB> possibly that list is a bit old....
12:08:10 <SamB> hmm, well, probably not
12:08:29 <DRMacIver> Can't be.
12:08:36 <DRMacIver> This is the specification after all.
12:08:46 <DRMacIver> It is by definition up to date. :)
12:09:09 <tutbot> hi have a question about building cabal in windows (ghc 6.8.1, but not using MSYS or CYGWIN). "runhaskell Setup.hs configure" gives error message "Setup.hs: ld is required but it could not be found".
12:09:13 <TomMD> @let x = ['z', 2]
12:09:14 <lambdabot> <local>:6:10:     No instance for (Num Char)       arising from the literal `...
12:09:29 <TomMD> @let x = ['z', 2] :: forall a. [a]
12:09:29 <lambdabot>  Parse error
12:09:49 <TomMD> how do you get lambdabot to allow heterogenious lists?
12:09:58 <opqdonut> TomMD: the type you want is [forall a. a]
12:10:03 <TomMD> Ah, thanks
12:10:16 <TomMD> @let x = ['z', 2] :: [forall a. a]
12:10:17 <lambdabot>  Parse error
12:10:21 <dons> lambdabot is h98 only
12:10:24 <TomMD> ok
12:10:28 <dfranke> Ok, I tihnk I've just painted myself into a corner.
12:10:32 <hpaste>  (anonymous) pasted "Propblem making PipeArrow an instance of Arrow" at http://hpaste.org/3958
12:11:03 <dfranke> How do I tell Haskell that an expression like (pure id) >>> (exec "foo") should be well-typed?
12:11:25 <dfranke> i.e., that arrow methods shouldn't care about the first type parameter?
12:14:30 <hpaste>  tutbot pasted "cabal help" at http://hpaste.org/3959
12:15:11 <SamB> DRMacIver: see http://java.sun.com/docs/books/jvms/second_edition/jvms-clarify.html
12:15:26 <dfranke> did that question make sense?
12:16:32 <DRMacIver> SamB: Ah. Thanks.
12:17:30 <dmwit> dfranke: no
12:18:15 <dmwit> tutbot: Well, do you have a linker?
12:18:30 <DRMacIver> SamB: I don't *think* they added any new instruction codes though
12:18:42 <tutbot> dmwit: it should because "ghc --make" works fine.
12:19:22 <tutbot> all standard ghc-6.8.1 installation.
12:20:14 <dmwit> huh
12:20:34 <dmwit> I wonder if cabal is depending on something it shouldn't.
12:20:49 <dmwit> Wait, why are you trying to build cabal?
12:20:56 <Lemmih> tutbot: Try compiling Setup.hs instead of interpreting it.
12:20:57 <dmwit> Doesn't it come with GHC?
12:21:39 <tutbot> sorry. not to build cabal, but to create a projection following Don's article: http://en.wikibooks.org/wiki/Haskell/Packaging
12:21:59 <dfranke> Ok, I have a data type with kind (* -> * -> * -> *).
12:22:15 <dfranke> I want to make an instance of a class which expects kind (* -> * -> *).
12:22:36 <dfranke> ?t (>>>)
12:22:36 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:22:37 <dmwit> Ah, -fglasgow as usual. =)
12:22:41 <dfranke> :t (>>>)
12:22:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
12:23:17 <dmwit> Wait, I may be thinking of something else.
12:23:29 <SamB> man, this JVM spec doesn't have a very good typesystem
12:23:47 <dmwit> dfranke: Can you do "instance Arrow (PipeArrow p) where"?
12:23:53 <opqdonut> yeah
12:23:55 <dfranke> What I want is for (foo ::: PipeArrow p b c) >>> (bar ::: PipeArrow q c d) to be well-typed even if p != q.
12:24:03 <DRMacIver> SamB: Indeed. I'm having great fun with it. :-/
12:24:08 <dmwit> dfranke: ...oh
12:24:10 <opqdonut> or instance Arrow (forall p. PipeArrow p)
12:24:12 <DRMacIver> SamB: Which particular aspect did you have in mind? :)
12:24:12 <tutbot> Lemmih/dmwit: I can make exe using "ghc --make Setup.hs -o Setup.exe". what to do next?
12:24:24 <SamB> DRMacIver: "reference" seems kind of lame
12:24:33 <Lemmih> tutbot: ./Setup.exe configure
12:24:41 <SamB> it's... like... dynamically typed
12:24:47 <twanvl> dfranke: what should the type of the result be? PipeArrow p b d or PipeArrow q b d?
12:25:02 <opqdonut> dfranke: how about "instance Arrow (forall p. PipeArrow p)"
12:25:03 <dfranke> twanvl: PipeArrow (forall r. r) b d
12:25:07 <DRMacIver> SamB: Well it's the byte code. In theory it's safe to have it be type erased...
12:25:17 <opqdonut> dfranke: ok, then you want what i suggested
12:25:21 <DRMacIver> SamB: Their excuse is that this way they can fit all their opcodes into a single byte
12:25:24 <twanvl> Then why do you need the parameter at all?
12:25:29 <dfranke> opqdonut: except that it doesn't seem to work.
12:25:35 <opqdonut> twanvl: good question
12:25:38 <tutbot> Lemmih: Running "Setup.exe configure" gives the same error message.
12:25:48 <opqdonut> dfranke: how does it not work?
12:26:03 <SamB> I just read aaload and it is referring to something as having type "reference" and referring to an array with items of type "reference"
12:26:24 <Lemmih> tutbot: You probably have to specify the path to 'ld' yourself.
12:26:51 <DRMacIver> But yes, the JVM bytecode is pretty grim. Which is why I'm hoping to layer a nice higher level API on top of this once I've got the low level parsing and generating all shiny.
12:27:28 <DRMacIver> (Why am I doing this? Because I want to target a compiler at the JVM and tool Java in Haskell, and hsjava made me sad)
12:27:33 <hpaste>  dfranke pasted "It breaks like this" at http://hpaste.org/3960
12:28:01 <tutbot> Lemmih: thanks. how? to set "ld-options"?
12:28:26 <dons> this is a good one, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=wmii%2Cion3&show_installed=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
12:28:27 <lambdabot> Title: popcon graph, http://tinyurl.com/257zfm
12:28:40 <dons> wrong chan
12:28:59 <dfranke> opqdonut: PipeArrow OSPipes doesn't unify against (PipeArrow (forall p. p))
12:29:16 <opqdonut> dfranke: hrmm, existential types are not my forte, you might want to try "instance Arrow (PipeArrow a)" and "instance Arrow (Pipearrow (exists p. p))"
12:29:32 <twanvl> newtype GeneralPipeArrow a b = forall p. GPA (PipeArrow p a b)
12:29:55 <opqdonut> that might work also
12:30:20 <twanvl> that is an existential type, which may not do what you want either
12:32:11 <dfranke> meh, I'm going back to what I was doing earlier, and damnit I want my dependent types.
12:34:09 <tutbot> Lemmih/dmwit: got it fixed. just as simple as adding it to 'PAHT'. Took some long hours to figure this out.
12:34:15 <tutbot> thanks a lot!
12:34:19 <dmwit> Great, good luck!
12:36:00 <ddarius> dfranke: You could make a different Arrow class, but yeah, you're most screwed.
12:36:05 <tutbot> thanks. I went through cabal document, looking for ld-options, etc. Just a wrong direction... I am glad it works now.
12:39:28 * SamB wonders when he came to have only one browser plugin installed
12:40:38 <dfranke> ddarius: yeah, I suppose I could do that and take advantage of rebindable syntax, but that would be a tad anti-social if the programmer wanted to use other arrows at the same time.
12:41:18 <ddarius> dfranke: Don't worry, I was leaning more toward the "you're screwed" side.
12:49:07 <RemiTurk> good evening everybody
12:49:33 <bakert> ?src liftM2
12:49:34 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:51:00 <dons> hey RemiTurk
12:55:45 <Apocalisp> How would you go about implementing client and server applications while making the calls from client to server type-safe?
12:57:16 <dons> Apocalisp: serisalise data with their types, and type check on reading?
12:57:29 <kosmikus> hi RemiTurk
12:57:29 <dons> i think typed channels are a fairly well understood problem
12:57:44 <dons> RemiTurk: hey, so is your windowm manager going to get uploaded to hackage?
12:57:46 <dons> if not, why not? :)
12:57:48 <Apocalisp> Not by me!
12:57:50 <Apocalisp> :-)
12:57:57 <dmwit> heh
12:58:12 <chessguy> @type liftM2
12:58:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:59:43 <Apocalisp> Do you know of a good reference to get me started with typed channels?
13:04:32 <RemiTurk> I found a difference in defaulting between 6.6.1 and 6.8.1. hugs agrees with 6.8.1, so I expect it was a bug in 6.6.1. Anyone familiar here with the fine details of defaulting?
13:06:23 <byorgey> RemiTurk: defaulting did change between 6.6.1 and 6.8.1.
13:06:41 <byorgey> RemiTurk: what's the particular difference that you found?
13:17:22 <hpaste>  (anonymous) annotated "niceness" with "(no title)" at http://hpaste.org/3961#a1
13:27:24 <RemiTurkII> hello again
13:27:41 <RemiTurkII> so much for good internet connections :(
13:28:20 <shachaf> RemiTurkII: Why II?
13:29:00 <RemiTurkII> because my connection died, but RemiTurk himself (myself? whatever ;)) is still connected according to #haskell
13:29:10 <RemiTurkII> I'm figuring out how to replace myself now ; )
13:29:18 <wli> Use a ghost command with nickserv.
13:29:19 <shachaf> RemiTurkII: /msg nickserv ghost.
13:33:28 <dmwit> You can also change nicknames with /nick RemiTurk or so. ;-)
13:33:48 <RemiTurk> thanks, I think I'm me again :)
13:34:06 <RemiTurk> I keep not using IRC enough to get familiar with it
13:34:14 <byorgey> RemiTurk: did you get my messages before your connection died?
13:35:04 <hpaste>  RemiTurk pasted "ghc 6.6.1/6.8.1 defaulting diff" at http://hpaste.org/3962
13:35:24 <RemiTurk> byorgey: I'm reading the http log now
13:38:11 <dmwit> That's odd.
13:40:33 <RemiTurk> dons: (sorry, my inet died and this got lost) I haven't really done anything with it the last (almost) year, except, well, used it, until recently. I may cabalize & hackagize it and release version ().() when I have some time to spill, but other than that, I guess helping with xmonad is going to be more useful
13:40:54 <dmwit> (This may be a simplification of a more interesting program, but just in case: I'd use Bool instead of Maybe ().)
13:40:55 <shachaf> RemiTurk: ().()? Why not just ()?
13:41:02 <shachaf> Counting in base 1? :-)
13:41:22 <Tomh-> hey, anyone know why calculating stuff on the triangle of pascall is much faster in haskell than in java for example?
13:41:29 <dons> RemiTurk: sure, dive in :)
13:41:41 <dons> Tomh-: haskell is more fun? :)
13:41:51 <Tomh-> i mean executing time :)
13:41:52 <dons> Tomh-: it really depends on the algorithm, and the compiler
13:42:00 <RemiTurk> shachaf: I already released The First And Only version (). If there ever is going to be more ().() seems like the logical successor..
13:42:13 <dons> ghc has a good optimiser, and compiles to native code, so given the identical algorithm, it is usually faster than java
13:42:16 <Tomh-> what stuff can a haskell compiler do that a java compiler cant
13:42:24 <dons> which is punished by the jitting/bytecode. poor java
13:42:43 <dons> Tomh-: there are also a whole set of optimisations not possible on java, that are on haskell, due to type informatoin, and purity
13:42:45 <dmwit> Tomh-: GHC compiles to native code, Java compiles to bytecode.
13:42:59 <dons> but that's probably not the issue. it would be bytecode v. native code, most likely
13:43:03 <MarcWeber> Tomh-: haskell doesn't have to do that much type checks ( a instance of ClassX ) .. And ghc doesn't have JIT
13:43:09 <Tomh-> i see
13:43:20 <Tomh-> but how can the haskell compiler improve algorithms
13:43:22 <dons> similar issues with C#
13:43:32 <dons> Tomh-: it can optimise pure code better than pure code in java
13:43:51 <Tomh-> i see
13:44:05 <dons> since purity is explicit in haskell, but would need to be discovered in the java compiler
13:44:08 <EvilTerran> because java doesn't *know* it's pure
13:44:09 <Tomh-> what about lazy evaluation and memorisation stuff
13:44:10 <dons> which they probably don't do
13:44:12 <Tomh-> will that help?
13:44:28 <dmwit> In this particular case... probably not much.
13:44:28 <dons> well, if its the same algorithm, presumably the java one is lazy and memoising too
13:44:32 <EvilTerran> it's worth noting that, for compiling C, gcc lets you mark some functions as pure
13:44:36 <dons> laziness is a win for some problems
13:44:43 <dmwit> EvilTerran: Oh, really, how?
13:44:50 <EvilTerran> __attribute__ ((pure)), iirc
13:44:52 <mauke> __attribute__((__const__))
13:44:53 <dons> Tomh-: java can be faster, but haskell tends to use less memory, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=java
13:44:54 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2hozbt
13:45:02 <RemiTurk> byorgey: any idea whether that (http://hpaste.org/3962) is part of the changes in defaulting?
13:45:03 <Tomh-> ok
13:45:05 <EvilTerran> see http://www.ohse.de/uwe/articles/gcc-attributes.html
13:45:06 <lambdabot> Title: gcc attribute overview
13:45:20 <byorgey> RemiTurk: no, I don't know
13:45:56 <dons> one simon peyton jones /= all of the java commercial backers, but its a close call
13:46:06 <mauke> "const" functions are truly pure; "pure" functions can read through pointers
13:46:11 <jonathanturner> someone needs to do another k-nucleotide so that it beats java in every category
13:46:22 <EvilTerran> yeah, __attribute__ ((pure))
13:46:32 <jonathanturner> (sizewise at least)
13:46:34 <dons> jonathanturner: we're waiting on ghc 6.8 to be uploaded, before attempting another assault
13:46:46 <jonathanturner> dons: hehe, sweet
13:46:53 <dons> though we did upload a new thread-ring impl the other day,
13:46:54 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
13:46:54 <Heffalump> should wait for 6.8.2 :-)
13:46:55 <lambdabot> Title: thread-ring (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2lyngq
13:47:05 <dons> and as Heffalump says, it'll really be 6.8.2 that we care about
13:47:10 <dmwit> fasta seems to be the one we're really losing on (compared to Java).
13:47:25 <dons> yeah, its a moderately naive impl.
13:47:30 <dons> its using different algos, for one.
13:47:49 <dons> there's a lot of free points in a new meteor-contest implementation, btw
13:47:55 <dons> since that's entirely naive currently
13:47:59 <dons> its using the wrong algorithm
13:48:08 <EvilTerran> __attribute__ ((const)) is a stricter garuntee than ((pure))
13:48:48 <davidL> ?seen thoughtpolice
13:48:48 <lambdabot> thoughtpolice is in #xmonad, #perl6 and #haskell. I don't know when thoughtpolice last spoke.
13:48:51 <dons> `This is a contest - different algorithms may be used' -- meteor-contest (unusual benchmark)
13:53:39 <davidL> @where hsns
13:53:39 <lambdabot> I know nothing about hsns.
13:53:52 <davidL> does someone know where the darcs repo of hsns is?
13:54:47 <davidL> nevermind
13:55:15 <phlpp> @index calendar
13:55:16 <lambdabot> bzzt
13:55:19 <davidL> @where+ hsns darcs get http://code.haskell.org/hsns/src/
13:55:19 <lambdabot> It is forever etched in my memory.
13:55:20 <phlpp> @cal
13:55:20 <lambdabot> Maybe you meant: eval faq keal map pl url
13:55:31 <_ry> okay. I have IO [String] and putStrLn :: String -> IO (). I want to apply it to each element of my IO [String]
13:55:33 <dmwit> phlpp: Whatcha lookin' for?
13:55:44 <phlpp> i just thought lambdabot has something like a calendar :D
13:55:44 <dmwit> :t mapM_
13:55:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:55:46 <phlpp> nevermind ;)
13:55:51 <_ry> (i feel like i've been asking this same question about 100 times here)
13:56:02 <_ry> dmwit: mapM_ isn't seeming to work
13:56:04 <mauke> _ry: x >>= mapM_ putStrLn
13:56:27 <_ry> mauke: so that takes the [String] out of the IO?
13:56:32 <mauke> >>= does
13:56:38 <_ry> puts it into the second arg of mapM_
13:57:11 <dmwit> Rather than thinking of that as taking the [String] out of IO, you should think of it as putting the first argument of mapM_ *into* IO.
13:57:26 <dmwit> Well, the second argument of mapM_, anyway.
13:57:34 <mauke> dmwit: too complicated :(
13:57:47 <dmwit> ok, hmm...
13:58:14 <shachaf> _ry: That's the same as do { x <- m; mapM_ putStrLn x }.
13:58:24 <shachaf> _ry: (It's what the do-notation translates into.)
13:58:58 <_ry> hmm. okay.
13:59:02 * dmwit tries to remember the salient points from when he "got it"
13:59:34 <dmwit> Actually, I think I figured out the list monad first, and then IO quite a while later.
13:59:53 <EvilTerran> ?type (>>=)
13:59:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:59:56 <chessguy> shachaf, as you wrote it, it's do { m <- x; mapM_ putStrLn m }
13:59:57 <dfranke> I think the Maybe monad is easiest to learn.
14:00:22 <phlpp> oh hm
14:00:25 <dons> shapr, little motivating phrase for the day, "history is made by those who bother to turn up"
14:00:26 <shachaf> chessguy: mauke was the one who came up with the name x. :-)
14:00:33 <mauke> learning IO first makes sense because you can use it to write Hello, World
14:00:36 <shachaf> dfranke: Easier than Identity? :-)
14:00:40 <mauke> and interactive programs
14:00:52 <EvilTerran> something of type (IO a) is in the IO "box"; >>= puts the input end of its second parameter into the same box so it can get at >>=s first parameter, on condition that its output end is already in the box
14:00:53 <chessguy> ok, well, as mauke wrote it then
14:00:53 <EvilTerran> ;)
14:01:05 <shachaf> main = putStrLn "Hello, world!" -- No need for a monad instance here. :-)
14:01:06 <dmwit> You can use "interact" until you understand IO, that's what I did.
14:01:07 <dfranke> shachaf: yes, because when you're trying to learn something, it helps to see that there's a point to it :-)
14:01:24 <phlpp> should this work, when i want to use sth. of type IO StdGen produced by some function f to put in a function that wants to havea StdGen: do { x <- f; p f }, so p takes a Stdgen and f returns an IO StdGeN?
14:01:28 <mauke> shachaf: ok. now write your own version of putStrLn
14:01:41 <EvilTerran> putStr.(++"\n")
14:01:54 <mauke> EvilTerran: very good. now putStr
14:02:13 <shachaf> mauke: There's a primitive eventually, other than (>>=)/return.
14:02:16 <LoganCapaldo> Identity has a point! it's so you can write all your code monadically, even the pur code so that when yu switch to some unhold StateT ReaderT ListT IO stack you don't have to change any of your code. it just works! ;)
14:02:17 <mauke> phlpp: no, you need p x
14:02:23 <shachaf> mauke: Write your own putChar. :-)
14:02:25 <EvilTerran> i get your point. i'm being facetious. ;)
14:02:35 <phlpp> mauke: jup
14:02:41 <phlpp> but that doesn;t work, too
14:02:49 <mauke> what's the type of p?
14:03:17 <phlpp> :t randomRs
14:03:18 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
14:03:18 <dfranke> LoganCapaldo: I didn't say it didn't have one.  I said that someone trying to understand monads isn't going to see it.
14:03:19 <phlpp> ;)
14:03:22 <phlpp> that's the type
14:03:29 <dmwit> phlpp: p needs to return an IO (something).
14:03:36 <mauke> phlpp: return (p x) then
14:03:37 <dmwit> So, (return . p) f would be okay.
14:03:40 <dmwit> sorry
14:03:47 <dmwit> (return . p) x, as mauke says
14:03:48 <LoganCapaldo> dfranke: I find it impressive you actually deigned to respond to that nonsense :)
14:04:27 <dfranke> LoganCapaldo: oh, I've written worse.
14:04:56 <phlpp> dwmit, thanks
14:05:01 <phlpp> dmwit i mean :>
14:05:34 <phlpp> it's like studying haskell mostly at the weekend for now, don't know, 2 months, and still such simple problems occur
14:05:48 <dfranke> LoganCapaldo: now, IdentityT, on the other hand...
14:06:05 <dfranke> LoganCapaldo: now THAT is pointless, and I'm not talking about @pl.
14:06:13 <LoganCapaldo> ah yes, the greatest and most powerful monadtransformer in all the land
14:06:26 <RemiTurk> dfranke: I once really really really wanted to have an IdentityT
14:06:39 <RemiTurk> actually, I think I defined it
14:07:00 <LoganCapaldo> It aint exactly the hardest monad transformer to write
14:07:08 <RemiTurk> lol :)
14:07:18 <hpaste>  _ry pasted "is it perfectly clear I don't know what I'm doing. (Trying to copy the unix sort command) Any sugges" at http://hpaste.org/3963
14:08:20 <dfranke> if I had my drothers, I'd just do away with the non-transformer versions of State, Reader, etc. and just define them like, e.g., type State a = StateT (->) a
14:08:25 <cale> You don't have to duplicate the mapM_ putStrLn (quicksort l)
14:09:02 <LoganCapaldo> isn't that how they are defined? type State = StateT Identity?
14:09:08 <phlpp> @pl betterStdGen >>= \s -> return $ randomRs (1,6) s
14:09:08 <lambdabot> randomRs (1, 6) `fmap` betterStdGen
14:09:13 <phlpp> hehehe
14:09:20 <dfranke> LoganCapaldo: not IIRC
14:09:23 <_ry> cale: i hope so. but i don't know how to take it out of the do statement
14:09:28 <dfranke> LoganCapaldo: I think they're implemented seperately.
14:09:52 <cale> _ry: just outdent it a bit to line it up with the if
14:10:17 <LoganCapaldo> dfranke: agrees
14:10:21 <LoganCapaldo> I am sad
14:10:28 <LoganCapaldo> err
14:10:30 <monochrom> > (\x -> ("hello", not x)) :: State Bool String
14:10:32 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
14:10:32 <lambdabot>     but its type `S...
14:10:34 <phlpp> betterStdGen >>= \s -> return $ randomRs (1,6) s <- could someone again explain this by words? does this mean, that the value of randomRs is lifted into the IO Monad, so that i can use betterStdGen, which returns a IO StdGen while randomRs is awaiting an StdGen?
14:10:35 <LoganCapaldo> that was ssuposed to be ghci agrees
14:10:43 <monochrom> > State (\x -> ("hello", not x)) :: State Bool String
14:10:43 <lambdabot>        add an instance declaration for (Show (State Bool String))
14:11:04 <monochrom> That shows that State is not StateT Identity.
14:11:17 <LoganCapaldo> e> :i State
14:11:17 <LoganCapaldo> newtype State s a = State {runState :: s -> (a, s)}
14:11:25 <LoganCapaldo> so does that!
14:11:32 <monochrom> If State were StateT Identity, my code would receive a different type error.
14:11:56 <thoughtpolice> davidL: ping?
14:12:01 <cale> _ry: oh, I see :)
14:12:18 <phlpp> can anyone verify/falsify my explination?
14:12:23 <cale> _ry: you'll have to pull the "l <-" out of the if as well
14:12:30 <chessguy> cale, you look like you're losing weight :)
14:12:47 <dons> heh
14:13:02 <byorgey> chessguy, you beat me to it =)
14:13:14 <monochrom> I think phlpp's explanation is ok.
14:13:32 <thoughtpolice> davidL: ah see you found what you were looking for. :)
14:13:35 <hpaste>  Cale annotated "is it perfectly clear I don't know what I'm doing. (Trying to copy the unix sort command) Any sugges" with "like this." at http://hpaste.org/3963#a1
14:13:45 <cale> chessguy: oh?
14:13:55 <chessguy> cale, small 'c' :)
14:13:59 <cale> ah
14:14:05 <byorgey> well, except that the value of randomRs is not lifted into the IO monad *so that* you can use betterStdGen.
14:14:22 <cale> Just reinstalled my OS, along with my IRC client.
14:14:23 <phlpp> yeah, that make's no sense
14:14:25 <phlpp> i see..
14:14:37 <dons> cale returns for the first time since 03.07.16
14:14:48 <EvilTerran> and the second time!
14:14:53 <phlpp> byorgey: do you have a better explination to me?
14:14:56 <phlpp> newbie-safe? :>
14:14:59 <byorgey> phlpp: it's just because of the type of >>= requires a function which produces a monad on the RHS.
14:15:10 <byorgey> er, I should say, a monadic value.
14:15:13 <EvilTerran> ?type (>>=)
14:15:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:15:21 <Cale> _ry: see my paste there?
14:15:25 <monochrom> That's just semantics.  <duck> :)
14:16:03 <_ry> Cale: oh thank you
14:16:44 <dmwit> _ry: Skip monads, go straight to arrows. ;-)
14:18:02 <dfranke> nah, skip arrows, go straight to cannonballs.
14:18:17 <monochrom> Skip wars. Go straight to tree hugging.
14:18:49 <goalieca> screw tree hugging go straight to tree humping
14:19:02 <monochrom> go straight to haskell
14:19:08 <EvilTerran> so. about those type systems.
14:19:40 <monochrom> skip go. go straight to jail. do not pass go. do not collect $200.
14:20:56 <vincenz> monochrom: lazily?
14:22:30 <bakert> stupid question - is "do" for all monads, or for IO specifically?
14:22:35 <Philippa_> all monads
14:22:39 <vincenz> it's syntax for all monads
14:22:45 <bakert> good :)
14:22:50 <bakert> tks
14:25:35 <dons> ?users #darcs
14:25:36 <lambdabot> Maximum users seen in #darcs: 41, currently: 38 (92.7%), active: 0 (0.0%)
14:25:39 <dons> ?users #xmonad
14:25:39 <lambdabot> Maximum users seen in #xmonad: 87, currently: 85 (97.7%), active: 8 (9.4%)
14:25:42 <dons> woot
14:26:44 <dons> #ocaml, Current: 62, Avg: 59
14:26:44 <dons> mwhaha
14:27:26 <dfranke> dons: being more popular than OCaml isn't that much to write home about...
14:27:44 <dons> poor ocaml
14:27:55 <EvilTerran> analogies could be drawn to being more popular than stabbing yourself in the eye with a fork
14:27:58 <sethk> dfranke, well, you know, the hump is always greener ...
14:28:15 <EvilTerran> ... when your camel has mildew?
14:28:26 <dons> more in #xmonad than #mutt
14:28:45 <sethk> EvilTerran, who knows?  It sort of looked like it made sense ... :)
14:28:47 <cedricshock> Haskell and XML: Is there any library for XML Haskell abstract syntax trees? Any starts on an XPath, XSL library?
14:28:59 <dons> if we extrapolate from irc users to total users ...
14:29:10 <dons> cedricshock: haxml and hxt
14:29:32 <dfranke> dons: I don't think that was what he was asking about...
14:29:45 <dfranke> dons: I think he means he wants to represent Haskell ASTs using XML.
14:29:48 <dons> oh, haskell ast in xml
14:29:48 <thoughtpolice> i'm thinking of ditching mutt. i might try that new sup client...
14:29:51 <dons> not xml ast in haskell
14:30:16 <cedricshock> dons: Yep. I'm thinking of writing an xslt to haskell compiler in xslt.
14:30:21 <ihope_> I imagine GHC has some nice function sleep :: Double -> IO () or such.
14:30:32 <mauke> threadDelay
14:30:41 <dfranke> cedricshock: you could probably do it in not much code using Language.Haskell.* plus Data.Generics
14:31:06 <ihope_> Aha.
14:32:31 <dfranke> cedricshock: doing the reverse transformation with equal simplicity would be left as an exercise to the reader.
14:33:20 <cedricshock> dfranke: Yeah. It should probably be simple enough that someone else has already done it...
14:35:28 <monochrom> Apparently no one has needed and AST in XML yet.
14:36:42 <xpika> hello does anyone know what the equivalent of /usr/local/lib/ghc-6.6.1 would be for windows
14:36:43 <xpika> ?
14:36:46 <dfranke> Yeah, Haskell has much nicer replacements for XML, so when you need to speak XML you're probably speaking to something that doesn't speak Haskell.
14:37:07 <dfranke> hence, no Haskell ASTs in XML.
14:39:36 <EvilTerran> xpika, C:\Program Files\ghc-6.6.1\gcc-lib , i think
14:39:48 <EvilTerran> (or whatever folder you installed ghc into\gcc-lib)
14:40:23 <dfranke> hmm, what the... has the unix package been removed from ghc-6.9?
14:41:14 <dfranke> or did they just build the snapshot documentation on a 'doze box?
14:43:16 <xpika> "C:\\ghc\\ghc-6.6"
14:44:29 <bakert> QuickCheck's oneof has a type of [Gen a] -> Gen a
14:44:34 <bakert> does that mean I can't say
14:44:40 <bakert> oneof [1, 2, 3]
14:44:41 <bakert> ?
14:44:57 <bakert> what would i say instead to get a random value from that list?
14:44:57 <ddarius> @index Gen
14:44:57 <lambdabot> Test.QuickCheck, Debug.QuickCheck
14:45:07 <ddarius> @instances-importing Test.QuickCheck Num
14:45:09 <lambdabot> Double, Float, Int, Integer
14:45:14 <byorgey> bakert: I think there's another function that does what you're looking for.
14:45:15 <ddarius> @src Gen
14:45:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:45:40 <bakert> oneof chooses a random item from a list.  i think.
14:45:52 <bakert> but perhaps in a different way from what i expect
14:45:57 <bakert> @doc QuickCheck
14:45:57 <lambdabot> QuickCheck not available
14:46:05 <bakert> ?where QuickCheck
14:46:05 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
14:46:08 <byorgey> bakert: well, it chooses a random generator from a list.
14:46:15 <bakert> oh
14:46:16 <bakert> i see
14:46:19 <byorgey> bakert: there's 'choose'
14:46:23 <bakert> hence the Gens in the list
14:46:24 <byorgey> @type Test.QuickCheck.choose
14:46:25 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
14:46:32 <dfranke> how do Haskell's standard IO functions interpret non-7-bit characters?
14:46:39 <byorgey> i.e. choose (1,3) chooses a random value from the range 1..3
14:46:51 <bakert> byorgey: that sounds like what i want :)
14:46:54 <bakert> thanks
14:46:58 <byorgey> bakert: sure =)
14:47:10 <mauke> dfranke: input or output?
14:47:17 <dfranke> mauke: input
14:47:25 <mauke> plain
14:47:27 <dfranke> If I read a 0xFF, what character do I get?
14:47:32 <mauke> '\255'
14:47:48 <dfranke> which corresponds to what?  Latin1?
14:48:01 <LoganCapaldo> dfranke: that would depend would it not?
14:48:01 <mauke> unicode
14:48:08 <mauke> 
14:48:21 <LoganCapaldo> oh nvm
14:48:55 <dfranke> ok, well the first 256 unicode codepoints correspond to Latin1, correct?
14:49:00 <mauke> yeah
14:49:08 <dfranke> alright.
14:49:26 <mauke> > isLower '\255'
14:49:26 <dfranke> It was just troubling me a bit that fdRead and fdWrite use String and not ByteString.
14:49:26 <lambdabot>  True
14:49:43 <mauke> yeah, the current IO system is more or less broken
14:50:16 <chessguy> > chr '\255'
14:50:17 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
14:50:23 <dfranke> ord '\255'
14:50:27 <dfranke> > ord '\255'
14:50:28 <lambdabot>  255
14:50:34 <chessguy> > (chr.ord) '\255'
14:50:34 <lambdabot>  '\255'
14:50:37 <EvilTerran> thrilling
14:50:48 <EvilTerran> > show '\255'
14:50:48 <lambdabot>  "'\\255'"
14:51:02 <dfranke> > show "\255"
14:51:03 <lambdabot>  "\"\\255\""
14:51:07 <EvilTerran> > fix show
14:51:08 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:51:14 <chessguy> @v
14:51:14 <lambdabot> "\""
14:51:15 <dfranke> hah
14:51:38 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
14:51:39 <lambdabot> "\"#$%&'()*+,\""
14:51:50 <ddarius> The current standard IO functions do little to no interpretation or encoding/decoding.
14:51:57 <chessguy> @help yhjulwwiefzojcbxybbruweejw
14:51:58 <lambdabot> V RETURNS!
14:52:18 <chessguy> @help v
14:52:19 <lambdabot> let v = show v in v
14:52:37 <EvilTerran> v for vendeyhjulwwiefzojcbxybbruweejw?
14:53:15 <chessguy> @v
14:53:15 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
14:53:34 <chessguy> i don't get it
14:54:08 <LoganCapaldo> in the distant past v was used internally
14:54:11 <Japsu> can lambdabot show us the source of show :: String -> String?
14:54:19 <LoganCapaldo> something like it in ghci
14:54:19 <chessguy> LoganCapaldo, for what?
14:54:26 <chessguy> @src show
14:54:26 <lambdabot> show x = shows x ""
14:54:36 <chessguy> @src shows
14:54:37 <lambdabot> Source not found. You speak an infinite deal of nothing
14:54:40 <Japsu> I mean the specific instance
14:54:41 <chessguy> i lose
14:54:41 <LoganCapaldo> people discovered this and "abused" it
14:54:58 <LoganCapaldo> so the name was change dto the long vedeyajsas... thingy
14:55:04 <LoganCapaldo> people discovered this
14:55:09 <resiak> @src String shows
14:55:09 <lambdabot> Source not found. Are you on drugs?
14:55:14 <EvilTerran> and abused that as well
14:55:29 <LoganCapaldo> so now there's no "v equivalent" and the commands are sort of articfacts of an earlier time
14:55:34 <chessguy> @quote
14:55:34 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
14:55:43 <LoganCapaldo> this is all hearsay on my part
14:55:46 <resiak> @src Char showList
14:55:47 <lambdabot> Source not found. It can only be attributed to human error.
14:55:47 <LoganCapaldo> I was not there
14:55:51 <chessguy> @quote souwh
14:55:51 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
14:56:01 <chessguy> LoganCapaldo, yeah, i remember when you were a n00b :)
14:56:07 <LoganCapaldo> any inaccuracies are mine and not those of those who told me :)
14:56:19 <chessguy> and now you know way more than me
14:57:28 <chessguy> (not that that's saying much)
15:01:08 <_ry> @src liftM
15:01:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:01:59 <LoganCapaldo> more trivia anyway :)
15:02:04 <_ry> monads never define a function ma -> a
15:02:06 <_ry> ?
15:02:12 <LoganCapaldo> some do
15:02:18 <LoganCapaldo> @type fromJust
15:02:19 <_ry> return goes the other way
15:02:20 <lambdabot> forall a. Maybe a -> a
15:02:25 <LoganCapaldo> @type head
15:02:26 <lambdabot> forall a. [a] -> a
15:02:55 <shachaf> @ty runIdentity -- This one's actually safe. :-)
15:02:56 <lambdabot> forall a. Identity a -> a
15:03:16 <shachaf> @ty unsafePerformIO
15:03:17 <lambdabot> forall a. IO a -> a
15:03:19 * shachaf hides.
15:04:10 <LoganCapaldo> @type runST
15:04:10 <lambdabot> Not in scope: `runST'
15:04:35 <_ry> <math> when i think of a monad as a functor (say the list monad) it's domain is the category of all types and it's codomain is lists of all types? </math
15:05:37 <_ry> or should you define the domain types to make it a concrete functor?
15:06:05 <ddarius> _ry: It's domain and codomain is the category of Haskell types and functions.
15:06:07 <_ry> category of strings -monad--> category of [String] ?
15:10:37 <chessguy> anybody know where i can grep #haskell logs?
15:10:56 <dmwit> nef.org/~tunes
15:11:08 <dmwit> whoops
15:11:18 <dmwit> tunes.org/~nef
15:11:35 <chessguy> mm, that doesn't have grep functionality
15:11:48 <chessguy> and i don't see a way of getting a zip
15:11:50 <jeffz> maybe google.com/search?q=site:tunes.org+inurl:logs+inurl:haskell+keyword
15:13:22 <atom> @src :+
15:13:22 <lambdabot> Source not found. My brain just exploded
15:13:38 <atom> @src Complex
15:13:38 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
15:13:57 <xpika> I can't remember what's the haskell way for perls chop. ie  "something\n"  -> "something"
15:14:05 <EvilTerran> init?
15:14:08 <EvilTerran> @src init
15:14:09 <lambdabot> init [x]    = []
15:14:09 <lambdabot> init (x:xs) = x : init xs
15:14:09 <lambdabot> init []     = undefined
15:14:10 <LoganCapaldo> init?
15:14:14 <ptibor> hello
15:14:28 <xpika> EvilTerran: thanks
15:15:26 <chessguy> xpika, that always gets rid of the last char though
15:15:30 <chessguy> whether it's \n or not
15:15:45 <mauke> so does perl's chop :-)
15:16:11 <chessguy> ok, i can never remember which is chop and which is chomp
15:16:20 <ptibor> i have defined a new class, where the instances should have a specific, default value:
15:16:23 <ptibor> class (Show a, Eq a) => TapeValue a where def :: a
15:16:55 <ptibor> but I cannot make instance the whole Num class, why?
15:16:56 <ptibor> instance TapeValue (Num a) where def = 0
15:17:08 <ptibor> sorry, not this was a bad try
15:17:23 <ptibor> I am trying with this code:
15:17:24 <ptibor> instance Num a => TapeValue a where def = 0
15:17:29 <dmwit> instance (Num a) => TapeValue a where def = 0
15:17:33 <mauke> that needs ghc extensions
15:17:34 <Cale> -fglasgow-exts ?
15:17:47 <LoganCapaldo> FlexibleInstances IIRC from earlier today :)
15:18:11 <Saizan_> and undecidable i think
15:18:32 <Cale> Yeah, that'll probably need undecidable instances too.
15:18:35 <EvilTerran> undecidable only if you have any other instance of TapeValue, iirc
15:18:52 <mauke> I'm pretty sure that instance by itself is undecidable
15:19:05 <EvilTerran> oh, wait, undecidable, not overlapping. yeah.
15:19:23 <ptibor> yes, its need undecidable and glasgow-ext also
15:19:39 <EvilTerran> with such a general instance head, though, overlapping's likely to come up fairly soon
15:19:39 <ptibor> I cannot do that without these extensions?
15:19:50 <mauke> no, it's not standard H98
15:19:54 * ddarius never uses overlapping instances.
15:20:38 * EvilTerran does, but only when faffing about in the type system
15:20:46 <EvilTerran> i've not used it for anything "serious", iirc
15:20:49 <ptibor> am I doing workaround? how can I do that nicely?
15:20:51 <RemiTurk> night everyone
15:21:00 * ddarius does crazy things in the type system but refuses to use overlapping instances.
15:30:07 <dfranke> standard library ought to have a Group class.
15:30:20 <dfranke> (Monoid a) => (Group a) where minv ::: a -> a
15:30:37 <LoganCapaldo> what's minv do?
15:30:50 <dfranke> gives the inverse of a group element.
15:31:00 <mauke> there are too many groups
15:31:04 <EvilTerran> x `mconcat` minv x = mzero?
15:31:22 <EvilTerran> mempty, rathe
15:31:24 <EvilTerran> r
15:31:26 <monochrom> Every group is a monoid. If there are too many group, there are too many monoids.
15:31:33 <mauke> right
15:32:25 <dfranke> (in related news, this shell library is getting really baroque)
15:32:49 <EvilTerran> i can't actually think of any haskell monoids off-hand (other than the numeric ones) that that makes sense for; can you give an example?
15:33:07 <shachaf> @instances Monoid
15:33:08 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
15:33:38 <LoganCapaldo> well minv (Sum a) = Sum (negate a) right?
15:33:44 <LoganCapaldo> and recip for Product?
15:33:50 <EvilTerran> i mentioned the numeric ones
15:34:06 <EvilTerran> they're not limited to haskell, so i deemed them Not Interesting ;)
15:34:17 <EvilTerran> (don't pick up on the obvious fallacy there, i can see it)
15:34:31 <LoganCapaldo> @src mappend Ordering
15:34:31 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:34:45 <EvilTerran> @src Ordering mappend
15:34:45 <lambdabot> Source not found.
15:34:47 <LoganCapaldo> minv GT = LT, minv EQ = EQ ?
15:35:15 <EvilTerran> > liftM2 mappend `join` [LT,EQ,GT]
15:35:18 <lambdabot>  [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
15:35:19 <dfranke> (If you're wondering why I want a Group class for a shell library, it's for group actions on environment variables)
15:35:25 <monochrom> I like baroque. It is clean and structured.
15:36:11 <ddarius> dfranke: So you want G-Sets
15:36:27 <EvilTerran> > mempty :: Ordering
15:36:27 <lambdabot>  EQ
15:36:41 <EvilTerran> so that one's not a group
15:37:00 <dfranke> ddarius: I don't know what that means
15:37:13 <ddarius> dfranke: A group acting on a set.
15:37:19 <dfranke> ddarius: yes.
15:39:07 <dfranke> ddarius: so I get to compose verbs rather than nouns, which is nice because it doesn't require knowledge of the starting environment, which means it can be purely functional.
15:40:07 <ddarius> Anyway, what is wrong with just using a record?
15:40:29 <dfranke> where my generating set is { define a new environment variable, unset an environment variable, clear the starting environment, restore the starting environment }
15:41:44 <ddarius> data Group g = Group { identity :: g, inv :: g -> g, mult :: g -> g -> g }
15:42:46 <dfranke> why would I want that?  This approach works fine, it's just annoying that the standard library doesn't already contain a class definition for Group.
15:42:59 <twanvl> why not just use function composition or perhaps Kleisli composition?
15:44:17 <ddarius> As others have said, in general, there can be more than one group structure on a type.
15:44:24 <dfranke> Kleisli?  This is not a monad.
15:44:36 <twanvl> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:45:41 <ramza3> any one pretty familiar with parsec, I am not, hope my question makes sense
15:45:55 <_ry> ddarius: how would you, say, define the permutation group with that?
15:46:07 <_ry> the 5th one, say
15:46:15 <chessguy> ramza3, i don't see your question
15:46:46 <_ry> it seems Group should be a class...
15:46:54 <ddarius> _ry: Declare a type to represent it and define identity, inv, and mult appropriately.
15:47:00 <ddarius> _ry: No it shouldn't.
15:47:22 <ddarius> But by the same token, neither should Monodi.
15:47:27 <twanvl> Group could be a replacement for part of Num, but not based on Monoid
15:47:40 <hpaste>  ramza3 pasted "Parse and one line comments" at http://hpaste.org/3965
15:48:02 <LoganCapaldo> Let's ask the oposit equestion, why do we have class Monoid instead of data Monoid m = { mempty :: m , mappend :: m -> m -> m } ?
15:48:04 <ramza3> chessguy: trying to add one line comments, but dont really know what I am doing; http://hpaste.org/3965
15:48:05 <dfranke> ddarius: I don't see anything in your reasoning that doesn't lead to the conclusion that typeclasses should be abolished entirely.  Which has been suggested.
15:48:40 <ddarius> dfranke: There are plenty of types that have a single natural instance of type classes.  Monoid and Group aren't one of them.
15:49:10 <chessguy> ramza3, add ; to your symbol list
15:49:12 <dfranke> ddarius: not many.
15:49:13 <twanvl> ramza3: that should be a parse error, because there is no expression
15:49:22 <ddarius> dfranke: Most of them, what are you talking about?
15:49:43 <dfranke> ddarius: I've often wanted to redefine instances Eq, Ord, Show, etcetera.
15:49:56 <dfranke> especially Ord.
15:49:58 <ddarius> dfranke: Hence my phrase "natural"
15:50:09 <ddarius> And I didn't say all of them.
15:50:31 <twanvl> when would you need a different Ord?
15:50:36 <_ry> ddarius: what is the different between using a data for group and class for group? i don't quite get it.
15:50:53 <ddarius> _ry: Because I can have two values of type Group Int, I can't have two instances.
15:51:20 <_ry> ah
15:51:30 <dfranke> twanvl: most recently, to order strings using UCA rather than UCS_BASIC.
15:51:31 <LoganCapaldo> ddarius: i tak you're not a fan of newtype Sum ... Product, etc.?
15:51:48 <ramza3> chessguy, twanvl: you guys are good
15:51:53 <ddarius> LoganCapaldo: I was upset when they changed the a -> a instance and introduced Endo.
15:52:12 <LoganCapaldo> wait there wasn't an Endo before?
15:52:16 <LoganCapaldo> boo
15:52:23 <LoganCapaldo> they shulda kept it a -> a
15:52:34 <ddarius> But wrapper types and/or phantom types are two ways of dealing with this.
15:53:01 <Raguel> if c# incorporates lambda calculus does that make it superior to c and c++?
15:53:05 <twanvl> There are two reasonably natural instances for (->)
15:53:27 <ddarius> A phantom type example, data CaseSensitive; data CaseInsensitive; newtype PString a = PString String; instance Ord (PString CaseSensitive) where ... ; instance Ord (PString CaseInsensitive) where ...
15:53:40 <ramza3> Raquel: anything is superior to C++
15:53:46 <ddarius> Raguel: In most ways, C# is already superior to C and C++.
15:53:54 <dfranke> ramza3: oh, I wouldn't say *anything*...
15:53:55 <Raguel> is it worth using then?
15:54:13 <Raguel> ramza3: would you say java was? ;)
15:54:14 <ramza3> dfranke: fortran, basic, cobol, vb; except those
15:54:18 <ddarius> twanvl: I agree that the one they changed it to is also reasonable.  I just used the other one more often and having to inject Endo defeats those cases.
15:54:26 <ramza3> Raquel: to C++, yes
15:54:32 <Raguel> oh gods i have to learn fortran from scratch
15:55:29 <Raguel> so is c# worth learning/using then?
15:56:00 <Raguel> and is fortran difficult to use?
15:56:02 <dfranke> only if you have a need for using the CLR.
15:56:15 <Raguel> wossa clr?
15:56:18 <ddarius> Raguel: C# is a relatively decent mainstream "industry" language, but if you don't have any particular reason to learn it there are better languages to learn.
15:56:23 <Raguel> other than clear
15:56:24 <dfranke> the .NET runtime environment.
15:56:52 <dfranke> and of course, soon F# will be out of beta and you can use that.
15:57:20 <Raguel> well i need to learn fortran for my project
15:57:25 <Raguel> but i'm taking up haskell in my spare time
15:57:55 <Raguel> starting to poke around lambda the ultimate when i'm not designing a crappy golf trolly
15:58:12 <dfranke> oif.  Freshman CS?
16:00:39 <dfranke> One of those "design an OO system that models X" questions/projects?
16:02:03 <dfranke> (On my final exam in such a course, my grade was so high that it didn't matter how I did on the exam.  So I got to give a snarky answer on the "design an OO system that models the University of Florida" question.)
16:02:23 <dfranke> The Student class had only one field, GPA, and only one method, drink(), which lowered it.
16:03:18 <Raguel> freshman cs? i wish
16:03:23 <Raguel> 3rd year mech eng
16:03:30 <Raguel> taking cs with free credits
16:03:36 <Raguel> cos its a barrel of laughs
16:03:42 <newsham> why does drink mutate the gpa field?
16:03:44 <monochrom> hahahaha
16:03:55 <monochrom> because it's an OO class.
16:04:23 <Raguel> and i have NO idea what you just said :)
16:04:33 <Raguel> but singular value decomposition calls me
16:04:41 <newsham> matrices ftw
16:04:51 <Raguel> so unless anyone here is a closet pro on matrix decomposition
16:04:58 * Raguel peers at newsham
16:05:19 <Raguel> meh
16:05:38 <Raguel> i'll go back to reading papers and being my gf's hot water bottle
16:06:16 <monochrom> Cling-on's :)
16:06:20 <dmwit> ...kinky
16:19:27 <dibblego> there was a recent article (on reddit?) that discussed why a function like words (but not '\n') could not be generally written because of all the corner cases; anyone remember it?
16:20:57 <newsham> what sort of corner cases?
16:24:02 <dmwit> :t (<*>)
16:24:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:24:11 <dmwit> ?src Applicative
16:24:11 <lambdabot> class Functor f => Applicative f where
16:24:11 <lambdabot>     pure  :: a -> f a
16:24:11 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:24:17 <dmwit> ?src <$>
16:24:17 <lambdabot> f <$> a = fmap f a
16:25:20 <dmwit> Any infix operators that don't use < or >? (So that I know it won't get eaten by blogging software?)
16:25:38 <shachaf> > You're asking about infix operators?
16:25:39 <lambdabot>  Parse error at "infix" (column 21)
16:25:40 <dmwit> Specifically, any that are not used in the Prelude.
16:25:47 <monochrom> .
16:25:53 <monochrom> err nevermind
16:26:07 <dmwit> Actually, (.) is okay, because it's easy to define.
16:26:09 <dmwit> Thanks!
16:26:20 <shachaf> OK, and ($), then.
16:26:31 <twanvl> dibblego: http://osfameron.vox.com/library/post/haskell-words-and-perl-split.html?
16:26:33 <lambdabot> http://tinyurl.com/2zb4bn
16:26:43 <shachaf> Besides... (.) is from Control.Category, not the Prelude. :-)
16:26:49 <EvilTerran> there's +++ in ReadP
16:26:58 <mauke> %
16:27:27 <shachaf> `on`. :-)
16:27:51 <EvilTerran> (?)
16:28:38 <dmwit> :t let f . g x = f (g x) in (.)
16:28:39 <lambdabot> Parse error in pattern
16:28:50 <dmwit> uh-oh
16:28:55 <EvilTerran> :t let (f . g) x = f (g x) in (.)
16:28:56 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
16:29:14 <EvilTerran> precedence still applies in patterns :)
16:29:21 <shachaf> > let True ? x = const x; False ? _ = id in (True ? 1 $ 2, False ? 1 $ 2)
16:29:24 <lambdabot>  (1,2)
16:29:34 <dmwit> Well, the example I gave on the blog may be a bit less than clear, then, since it doesn't compile. =P
16:29:53 <EvilTerran> (.) f g x = ... is another way of putting it
16:30:03 <EvilTerran> @src (->) (>>=)
16:30:04 <lambdabot> f >>= k = \ r -> k (f r) r
16:30:09 <shachaf> Or (.) f g = \x -> ...
16:30:13 <EvilTerran> there's another way, although i don't really like it
16:30:36 <EvilTerran> the trouble with (f . g) x = ... is, iirc, one of the obscure haskell compilers doesn't like it
16:30:43 <dmwit> let (.) = fmap -- ;-)
16:31:10 <dibblego> twanvl, excellent thanks! that's it
16:34:38 <dmwit> dons++ for main = print "You're my type!"
16:35:50 <shachaf> dmwit: ?
16:36:04 <goalieca> shachaf reddit post IIRC
16:36:13 <dmwit> http://programming.reddit.com/info/60ty3/comments/
16:36:35 <dmwit> More specifically,
16:36:36 <dmwit> http://programming.reddit.com/info/60ty3/comments/c02higk
16:36:48 <shachaf> Not putStrLn?
16:37:01 <dmwit> print is easier for the non-believers
16:37:06 <dons> charm offensive
16:38:55 <newsham> Doing everything in Haskell is like writing all the documentation in Latin.
16:38:56 <newsham> heh
16:39:07 <Brian`> what happens if a monadic type that a programmer creates does not meet the three basic monads axioms?
16:39:28 <dmwit> Nothing.
16:39:32 <shachaf> @quote laws
16:39:32 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
16:39:34 <LoganCapaldo> cats sleeping with dogs
16:39:35 <shachaf> @quote laws
16:39:35 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
16:39:39 <LoganCapaldo> mass hysteria
16:39:40 <dmwit> The notation just doesn't mean the same thing.
16:40:10 <shachaf> @quote the.laws
16:40:10 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
16:40:15 <newsham> paul graham says less is more. news on reddit.
16:40:41 <dmwit> Brian`: You really want them to obey the laws, though, because then you get to do nice reasoning about the meaning of do constructs and sequencing.
16:40:57 <mauke> $ diff /usr/bin/less /bin/more
16:40:57 <mauke> Files /usr/bin/less and /bin/more differ
16:41:10 <Brian`> dmwit: yeah I guess. I was just wondering what would've happened it I don't obey the laws... does the program crash or something?
16:41:17 <LoganCapaldo> hehe
16:41:19 <LoganCapaldo> no
16:41:28 <dmwit> No, the result is just different than a cursory inspection would suggest it ought to be.
16:41:29 <LoganCapaldo> that would be _awesome_ though
16:41:45 <dmwit> I thought I saw an example showing what happens if each law fails...
16:41:53 <dmwit> But I can't remember where. =/
16:41:54 <shachaf> Can we have an automatic monad-law checker? :-)
16:41:58 <LoganCapaldo> Exception: *** Bad programmer! Obey the laws!
16:42:08 <Brian`> lol
16:42:15 <dmwit> shachaf: Halting problem? =P
16:42:40 <dibblego> is there a function like break but :: (a -> Bool) -> [a] -> [[a]] that recursively applies break?
16:42:43 <shachaf> dmwit: "...checker? :-)"
16:42:50 <dmwit> *nods*
16:43:00 <dons> fix break ? :)
16:43:03 <shachaf> dmwit: (I know.)
16:43:12 <dmwit> dibblego: No, people usually write that themselves.
16:43:31 <dibblego> surely it can be written without using fix
16:43:36 <dmwit> :t break
16:43:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:43:58 <dibblego> keep putting snd of the return value in until []
16:44:03 <EvilTerran> > map (takeWhile f) . takeWhile (not.null) . iterate (dropWhile f) ?
16:44:03 <lambdabot>   parse error on input `}'
16:44:03 <dmwit> right
16:44:15 <newsham> prop_MonadLaw1 = ...
16:44:24 <EvilTerran> > let f = (/=' ') in map (takeWhile f) . takeWhile (not.null) . iterate (dropWhile f) $ "foo bar baz eek"
16:44:30 <lambdabot>  ["foo","","","","","","","","","","","","","","","","","","","","","","","",...
16:44:42 <EvilTerran> erm.
16:45:00 <EvilTerran> ah, yes, i see.
16:45:00 <dmwit> :t iterate
16:45:01 <lambdabot> forall a. (a -> a) -> a -> [a]
16:45:11 <EvilTerran> > let f = (/=' ') in map (takeWhile f) . takeWhile (not.null) . iterate (drop 1 . dropWhile f) $ "foo bar baz eek"
16:45:11 <dmwit> :t unfoldr
16:45:12 <lambdabot>  ["foo","bar","baz","eek"]
16:45:12 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:45:28 <dibblego> yeah unfoldr crossed my mind
16:45:34 <dibblego> which is a bit hazy today :)
16:47:01 <dmwit> > let f = (/=' ') in map head . group . map (takeWhile f) . inits $ "foo bar baz eek"
16:47:02 <lambdabot>  ["","f","fo","foo"]
16:47:34 <dmwit> ?hoogle prefix
16:47:35 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
16:47:35 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
16:47:35 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
16:47:56 <davidL> why does lambdabot depend on oeis now? was a new plugin added?
16:48:00 <EvilTerran> > unfoldr (\xs -> if null xs then Nothing else Just . second (drop 1) . break (==' ') $ xs) "foo bar baz eek"
16:48:00 <lambdabot>  ["foo","bar","baz","eek"]
16:48:49 <dibblego> ?type second
16:48:50 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:49:15 <dmwit> > let f = (/= ' ') in map head . groupBy (\x y -> f (head y)) . takeWhile (not null) . inits $ "foo bar"
16:49:18 <lambdabot>  Couldn't match expected type `Bool'
16:49:21 <dmwit> bah
16:50:19 <scook0> @oeis 1, 1, 2, 3
16:50:20 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
16:50:20 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:50:29 <davidL> ah cool ;)
16:51:07 <sorear> ooh, @oeis?  cool!!
16:51:07 <shachaf> @oeis 1,2,2,1,1,2,1
16:51:08 <lambdabot> Number of distinct primes dividing n (also called omega(n)).
16:51:08 <lambdabot> [0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2,...
16:51:22 <dmwit> map head . groupBy (\x y -> f (head y)) . takeWhile (not . null) . tails $ "foo bar baz eek"
16:51:24 <dibblego> wtf is oeis?
16:51:27 <shachaf> @oeis 1,2,2,1,1,2,1,2,2,1
16:51:27 <lambdabot> Kolakoski sequence: a(n) is length of n-th run; a(1) = 1; sequence consists j...
16:51:27 <lambdabot> [1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2,...
16:51:28 <dmwit> > map head . groupBy (\x y -> f (head y)) . takeWhile (not . null) . tails $ "foo bar baz eek"
16:51:28 <lambdabot>   Not in scope: `f'
16:51:36 <sorear> @go OEIS
16:51:39 <ddarius> @help oeis
16:51:42 <lambdabot> http://www.research.att.com/~njas/sequences/
16:51:42 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
16:51:42 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
16:51:47 <dibblego> ah yes, cool!
16:54:38 <mrd> > last . takeWhile (not . any null) . map fst $ iterate (\ (a, b) -> ((a++) . return *** snd . span isSpace) (break isSpace b)) ([],"the quick brown fox jumps over the lazy dog")
16:54:39 <lambdabot>  ["the","quick","brown","fox","jumps","over","the","lazy","dog"]
16:55:28 <goalieca> > words "the quick brown fox jumps over the lazy dog"
16:55:29 <lambdabot>  ["the","quick","brown","fox","jumps","over","the","lazy","dog"]
16:55:36 <dmwit> ?hoogle wordsBy
16:55:36 <lambdabot> No matches found
16:55:38 <dmwit> bummer
16:55:45 <dmwit> That would have definitely been the trump card. =P
16:55:48 <davidL> > sort "the quick brown fox jumps over the lazy dog"
16:55:49 <lambdabot>  "        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
16:55:59 <davidL> > nub $ sort "the quick brown fox jumps over the lazy dog"
16:56:00 <lambdabot>  " abcdefghijklmnopqrstuvwxyz"
16:56:21 <dmwit> > all ['a'..'z'] (elem "the quick brown fox jumps over the lazy dog")
16:56:21 <lambdabot>  Couldn't match expected type `a -> Bool'
16:56:26 <dmwit> :t all
16:56:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:56:40 <dmwit> > all (elem "the quick brown fox jumps over the lazy dog") ['a'..'z']
16:56:40 <lambdabot>  Couldn't match expected type `[[Char]]'
16:56:53 <jleedev> :t elem
16:56:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:57:01 <goalieca> @src words
16:57:01 <lambdabot> words s = case dropWhile isSpace s of
16:57:01 <lambdabot>     "" -> []
16:57:01 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:57:01 <twanvl> > all (`elem` "the quick brown fox jumps over the lazy dog") ['a'..'z']
16:57:02 <lambdabot>  True
16:57:03 <dmwit> heh, got 'em both flipped
16:57:20 * dmwit is 0 for 4 today
16:57:33 * goalieca is FTW
16:57:53 <shachaf> dmwit: Go play some more Nethack. :-)
16:58:03 <dmwit> shachaf: 0 for 4 there, too ;-)
16:58:16 <goalieca> hm.. how hard would it be to translate nethack into haskell
16:58:45 <dmwit> NetHack is not a complicated game, it just has a bazillion special cases.
16:58:55 <dmwit> That means it is easy, but boring, to port into another language, I think.
16:59:13 <gwern> goalieca: probably not terribly. I mean, the dev team takes forever, soyou might even be able to beat the next release (which has been in the makigns for like 4 years now)
16:59:35 <gwern> and rogue-likes are well understood - isn't there a 'rouge in 1 week' programming contest?
16:59:43 * goalieca has never played nethack for more than 5 minutes
16:59:46 <goalieca> :(
17:00:09 <SamB> goalieca: well... you can start now
17:00:18 <SamB> or you could try porting a game that you actually play
17:00:29 <goalieca> or i can start by finishing the two papers i have to write
17:00:31 <goalieca> :(
17:00:40 <SamB> yes, I should also do that
17:00:59 <gwern> it would be interesting if someone were to try to 'xmonad' nethack
17:01:11 <gwern> (where 'xmonad' is a verb I just made up right now)
17:01:21 <SamB> I *know* that
17:02:01 <SamB> but I assume you mean "make it a lot shorter by coming up with an elegant mathematical formulation of it's essential function"
17:02:32 * goalieca is a neutral human valkyrie
17:02:44 <gwern> SamB: right, but I also include the tertiary meanings of 'shorter, more reliable, with proofs and QC tests, and lots of extensions'
17:03:08 <SamB> well, yes, those things are also rather expected
17:03:19 <sorear> NetHack is a lot bigger than it needs to be because it has a LOT of code duplicated for different combinations of targets.  False dichotomies introduce bloat.
17:03:39 <sorear> For instance, there are three versions of the attack code, in uhitm.c, mhitm.c, and mhitu.c.
17:03:40 <gwern> sorear: so... it's easy prey? :)
17:03:51 <SamB> gwern: probably not as easy as you'd like
17:04:04 <shachaf> sorear: No uhitu.c? :-)
17:04:09 <SamB> there are probably some rather tricky complications
17:04:12 <sorear> One handles you hitting monsters, one for monsters hitting monsters, another for monsters hitting you.
17:04:21 * shachaf guesses that goes under uhitm.c.
17:04:23 <SamB> u hit u?
17:04:29 <dmwit> shachaf: Multiplayer NetHack?
17:04:31 <dmwit> =)
17:04:33 <SamB> that sounds unlikely
17:04:39 <SamB> how can you hit yourself?
17:04:45 <EvilTerran> if you're hallucinating?
17:04:48 <mauke> ever seen fight club?
17:04:48 <sorear> This might have been forgivable back in the days of Rogue, but there is no significant difference now, because of self-polymorph
17:04:51 <gwern> SamB: well, I suspect the input and output could be nasty - I've had glimpses of the dark underbellies of shells and terminals, and there be monsters...
17:05:03 <Brian`> hey what does type IO () mean?
17:05:06 <Brian`> what does () mean?
17:05:10 <EvilTerran> @src ()
17:05:10 <SamB> gwern: oh, that would be the least of your worries
17:05:10 <lambdabot> data () = ()
17:05:11 <dmwit> data () = ()
17:05:15 <sorear> so uhitm has to handle fancy stuff like polymorphing into a purple worm
17:05:23 <dmwit> Brian`: It's just a place-holder when we have nothing interesting to return.
17:05:23 <SamB> the I/O could be totally abstracted
17:05:31 <KatieHuber> it's a 0-tuple, "void" if you're coming from C/Java
17:05:39 * EvilTerran wonders if dmwit would say ":)" if he said "@bot"
17:05:46 <Brian`> is that why we cannot extract value from IO () type?
17:05:48 <SamB> dmead: @bot
17:05:51 <SamB> er.
17:05:54 <SamB> dmwit: @bot
17:05:58 <dmwit> :o
17:06:01 <Brian`> for Maybe a, we can extract the type a by using pattern matching, right?
17:06:01 <EvilTerran> haha
17:06:03 <LoganCapaldo>  or unit if you are coming from ML
17:06:05 * SamB tries to remember to use THREE letters before tab
17:06:07 <Brian`> but can't we do that in IO?
17:06:20 <EvilTerran> IO () is rather like Maybe ()
17:06:24 <dmwit> Brian`: Right, IO is an abstract data type, so we don't know the constructors.
17:06:29 <SamB> Brian`: IO has no Just
17:06:37 <goalieca> damn. nethack is confusing
17:06:38 <Brian`> ah.. i c
17:06:52 <EvilTerran> in that we *can* get at the value (only not with pattern-matching), but it doesn't mean anything interesting
17:06:59 <gwern> SamB: what d'you think the real worries would be?
17:07:20 <Cale> Also, however it's represented, it will usually take more work than simple pattern matching to get a value of type a from an IO a, you have to actually carry out the instructions that the (IO a) represents.
17:07:20 <dmwit> gwern: Ever gone spelunking through nethack.wikia.com?
17:07:32 <gwern> dmwit: only on rare occasions
17:07:40 <Cale> For example:
17:07:43 <sorear> More examples.
17:07:44 <Cale> :t getLine
17:07:45 <lambdabot> IO String
17:07:54 <SamB> gwern: hairy ad-hoc polymorphic-ish things?
17:08:08 <Cale> getLine will ask the user for a string
17:08:17 <SamB> nethack.wikia?
17:08:36 <monochrom> False dichotomy is a plague among beginner programmers. For example you ask them to sum up a list or an array. They make three cases or more: zero items, one items, the rest. It would be ok if not combined with this human nature: you write more lines, you make more mistakes.
17:09:02 <gwern> SamB: oh, you think it'd be hard to find a good way of avoiding all the adhocery, I see
17:09:09 <gwern> monochrom: 0, 1, or infinity?
17:09:18 <Botje> zero, one, many.
17:09:26 <Botje> sounds about right
17:09:36 <SamB> gwern: I suppose the fact that it sounds like nethack errs on the side of non-polymorphism MIGHT be comforting...
17:09:37 <EvilTerran> zero would be not defining sum at all
17:09:45 <EvilTerran> one would be just the sum [] case
17:10:50 <EvilTerran> i think a lot of the eventual code in a haskell version of nethack would turn out to be definitions of various Data.Map (Thing,OtherThing) (IO())
17:11:26 <LoganCapaldo> mm
17:11:41 <LoganCapaldo> the enxt killer haskell app, a rogue like in Haskell> :)
17:11:48 <dmwit> EvilTerran: Surely it would be s/IO/StateT NethackState IO/
17:11:52 <dmwit> or some suc
17:12:38 <EvilTerran> isn't there already a MonadState instance for IO that uses IORefs?
17:13:01 <dmwit> Yeah, but how do you QuickCheck *that*??
17:13:06 <EvilTerran> er. point.
17:13:10 <LoganCapaldo> where would you keep the "global" IORef?
17:13:22 <EvilTerran> LoganCapaldo, and a different one for every type! :D
17:13:35 <EvilTerran> never mind, my brain's gone to bed for the evening
17:13:44 <gwern> @src mapM_
17:13:45 <lambdabot> mapM_ f as = sequence_ (map f as)
17:13:55 <gwern> @src sequence_
17:13:55 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:14:55 <shachaf> @ty foldr (*>) (Control.Applicative.pure ())
17:14:56 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f ()
17:15:16 <gwern> wait. is mapM_ parallel or sequential?
17:15:29 <mauke> sequential
17:15:38 <EvilTerran> does it mention parallelism in its definition?
17:16:02 <gwern> guess not. hm.
17:16:28 <shachaf> The pure part COULD be parallel. :-)
17:16:52 <shachaf> But "sequence" does suggest that things are done in sequence.
17:17:06 <EvilTerran> unfortunately, "enforced purity means things can run in parallel implicitly!" is a big fat lie at the moment ;)
17:17:31 <gwern> but on the other hand, if I threw a forkIO in there as part of the function being mapped, presumably it'd then effectively be parallel///
17:17:56 <gwern> @src forkIO
17:17:57 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
17:17:57 <lambdabot>     where action_plus = catchException action childHandler
17:18:03 <EvilTerran> it's possible to write a parallel version, yes, and i imagine forkIO would do the job
17:18:04 <shachaf> EvilTerran: Sure, but I said it could :: Maybe RunInParallelImplicitly.
17:18:20 <EvilTerran> what?
17:19:02 <shachaf> EvilTerran: I said the pure part could run in parallel, not that it does. :-)
17:19:13 <EvilTerran> ah, yes. *could*.
17:19:35 <nominolo> > isLetter ''
17:19:35 <lambdabot>  Improperly terminated character constant at "''" (column 10)
17:20:02 <LoganCapaldo> why do you torture us lambda?
17:20:02 <nominolo> > map isLetter ""
17:20:14 <lambdabot>  [True]
17:20:23 <Botje> > map isLetter ""
17:20:23 <nominolo> weird
17:20:24 <lambdabot>  [False]
17:20:27 <EvilTerran> > ""
17:20:28 <lambdabot>  "\955"
17:20:35 <Botje> aww. snowmen don't count as letters?
17:20:40 <LoganCapaldo> > head ""
17:20:40 <lambdabot>  '\955'
17:20:47 <shachaf> > map toUpper ""
17:20:48 <lambdabot>  "\923"
17:21:09 <EvilTerran> nominolo, the stage in the parser that rejects character constants that aren't one character works in bytes instead of characters
17:21:39 <EvilTerran> so, if you set your codepage to some obselete 8-bit greek encoding...
17:22:02 <EvilTerran> ... it'd still reject it, 'cos it'd think it was a  or something =/
17:22:09 <nominolo> nah, i just wanted to check if i could use haskell's Prelude functions to write a haskell parser
17:22:28 <EvilTerran> well, you *could*...
17:23:18 <nominolo> i will
17:24:30 <LoganCapaldo> import Language.Haskell?
17:24:42 <nominolo> LoganCapaldo: it's an incremental parser
17:25:07 <LoganCapaldo> which?
17:25:15 <LoganCapaldo> I know nothing
17:25:21 <LoganCapaldo> I'm just spouting nonsense
17:25:41 <nominolo> written by jyp, based on Swierstra/Hughes's paper on online-parsers
17:25:59 <nominolo> "Polish Parsers, Step by Step"
17:26:21 <ddarius> parMapM_ = mapM_ (forkIO .)
17:26:33 <ddarius> parMapM_ = mapM_ . forkIO
17:27:25 <nominolo> > map isLower ""
17:27:28 <lambdabot>  [True]
17:27:40 <nominolo> crap, why doesn't that work in my ghci ...
17:31:48 <LoganCapaldo> work how?
17:32:00 <LoganCapaldo> could be your terminal
17:34:26 <LoganCapaldo> x -> State Int x heheh
17:34:32 <LoganCapaldo> type lambda!
17:34:58 <shachaf> LoganCapaldo: But what will you do for kind lambdas?
17:35:04 <shachaf> I suppose all lambdas are kind.
17:36:14 <ddarius> > isLower ''
17:36:14 <lambdabot>  Improperly terminated character constant at "''" (column 9)
17:36:25 <ddarius> > all isLower ""
17:36:27 <lambdabot>  False
17:37:20 <shachaf> > isUpper '\923'
17:37:21 <lambdabot>  True
17:43:13 <sorear> ddarius:
17:43:25 <sorear> > length "
17:43:25 <lambdabot>  Improperly terminated string at """ (column 8)
17:43:26 <sorear> > length ""
17:43:28 <lambdabot>  1
17:43:31 <sorear> oh.
17:43:33 <sorear> nm
17:49:25 <sjanssen> lambdabot does UTF-8 now?
17:49:47 <sjanssen> > fromEnum ''
17:49:47 <lambdabot>  Improperly terminated character constant at "''" (column 10)
17:50:10 <sjanssen> > ""
17:50:12 <lambdabot>  "\923"
17:50:32 <sjanssen> > fromEnum . head $ ""
17:50:34 <lambdabot>  923
17:50:38 <sjanssen> only in String, apparently
17:50:56 <mauke> > 
17:50:56 <lambdabot>  Illegal character ''\155''
17:50:56 <lambdabot>  at "" (column 2)
17:52:47 <monochrom> Strange.
17:54:55 <sjanssen> oh, I get it
17:55:14 <sjanssen> lambdabot parses the input with Language.Haskell before sending it to GHC
17:56:43 <Brian``> hey, in Monad binding, if the value of monad is a list would the function apply to each element of the list?
17:56:51 <sjanssen> "" passes because the UTF-8 encoding translates into several bytes that also happen to be valid characters
17:57:26 <Brian``> in http://www.haskell.org/all_about_monads/html/solution3.html
17:57:27 <lambdabot> Title: Solution to exercise 3
17:57:37 <Brian``> i was having trouble understanding grandparent function
17:57:38 <sjanssen> Brian``: yeah, in x <- [1, 2, 3], x takes the value 1, 2, 3 in turn
17:57:54 <Brian``> i c.. that's why...
17:58:00 <Brian``> so if we do
17:59:09 <idnar> sneaky
17:59:13 <idnar> (re: UTF-8)
17:59:27 <EvilTerran> > length ""
17:59:29 <lambdabot>  1
17:59:37 <Brian``> nvm ; lol couldn't come up with an example hehe
18:00:05 <monochrom> Oh! RIght, "" happy with multiple bytes, '' unhappy.
18:00:06 <mauke> > do { x <- [1, 2, 3]; y <- [x + 1, x * 2]; return y }
18:00:21 <lambdabot>  thread killed
18:00:27 <mauke> what
18:00:44 <sjanssen> and GHC finally gets the UTF-8 encoded input, which it interprets correctly
18:00:49 <mauke> > do { x <- [1, 2, 3]; y <- [x + 1, x * 2]; return y }
18:00:52 <lambdabot>  [2,2,3,4,4,6]
18:00:58 <Brian``> cool that's a good example :)
18:01:15 <monochrom> Just blame it on a power glitch. :)
18:01:24 <ddarius> Cosmic rays
18:01:32 <Brian``> so if I translate to bind notation, it would be -- [1,2,3] >>= (\x -> [x+1, x*2]) ?
18:01:41 <mauke> @undo do { x <- [1, 2, 3]; y <- [x + 1, x * 2]; return y }
18:01:41 <lambdabot> [1, 2, 3] >>= \ x -> [x + 1, x * 2] >>= \ y -> return y
18:01:51 * monochrom should compile "Top Ten Blames for Irreproducible Problems" :)
18:02:08 <monochrom> CosmicRay is one of them, yes. :)
18:02:09 <ddarius> 1) Users
18:02:26 <EvilTerran> http://pages.cs.wisc.edu/~ballard/bofh/excuses ?
18:03:08 <EvilTerran> ddarius, you mean (l)users? :P
18:04:50 <monochrom> GLI = graphical luser interface?
18:05:26 <EvilTerran> graphical line interface; edge-drawn on an oscilloscope :)
18:06:34 <monochrom> vector graphics was hot once. :)
18:06:43 <mtp> hmm
18:06:50 <monochrom> raster graphics is a rather recent movement.
18:06:51 <mtp> i'm having trouble using listArray
18:07:47 <monochrom> Thankfully, vector graphics is reincarnated as vector fonts in raster systems.
18:08:02 <EvilTerran> thank fortune for antialiasing :)
18:08:10 <EvilTerran> ?type listArray
18:08:12 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
18:08:17 <davidL> ?elements boron
18:08:17 <lambdabot> *** "boron" elements "Elements database 20001107"
18:08:17 <lambdabot> boron
18:08:17 <lambdabot> Symbol: B
18:08:17 <lambdabot> Atomic number: 5
18:08:17 <lambdabot> Atomic weight: 10.811
18:08:19 <lambdabot> [7 @more lines]
18:08:25 <davidL> wow
18:08:33 <EvilTerran> wow?
18:08:47 <davidL> it doesn't work on my lambdabot
18:09:00 <EvilTerran> might need a database from somewhere
18:09:05 <monochrom> You probably need extra plugins.
18:09:20 <davidL> ah
18:15:09 <hpaste>  mtp pasted "(no title)" at http://hpaste.org/3968
18:17:13 <monochrom> listArray (0,max_fp_regs) (take max_fp_regs $ repeat Nothing)
18:17:53 <monochrom> Actually it is off by one. listArray (0,max_fp_regs) (take (max_fp_regs + 1) $ repeat Nothing)
18:18:16 <monochrom> And actually you don't have to care. listArray (0,max_fp_regs) (repeat Nothing)
18:18:32 <monochrom> > listArray (0,1) (repeat Nothing)
18:18:34 <lambdabot>  array (0,1) [(0,Nothing),(1,Nothing)]
18:18:38 <monochrom> works :)
18:19:01 <mtp> ah
18:19:46 <mtp> can I not use a function in the tuple, though?
18:20:08 <monochrom> How do you mean?
18:20:23 <mauke> mtp: missing ( )
18:20:46 <mtp> hmm, no, trying to change it from listArray (0,max_fp_regs) etc, to listArray (0,30) etc still failed
18:20:50 <mtp> mauke: where
18:21:11 <mauke> mtp: look at monochrom's code
18:21:35 <mtp> > newFPRegFile = listArray (0,max_fp_regs) (repeat Nothing)
18:21:35 <lambdabot>  Parse error at "=" (column 14)
18:21:50 <mtp> > listArray (0, 30) (repeat Nothing)
18:21:51 <lambdabot>  array (0,30) [(0,Nothing),(1,Nothing),(2,Nothing),(3,Nothing),(4,Nothing),(5...
18:21:55 <mauke> wait, what?
18:22:06 <mtp> first one was a mistake
18:22:09 <mauke> the error message doesn't match the code
18:22:26 <mtp> mauke: I just changed it to the first one
18:22:35 <mtp> with the code I pasted, that's the error i'm getting
18:23:57 <monochrom> I think you should paste updated code and new error message.
18:24:04 <mtp> yeah
18:25:55 <hpaste>  mtp annotated "(no title)" with "(no title)" at http://hpaste.org/3968#a1
18:26:36 <monochrom> Monomorphism restriction?!
18:26:58 <mtp> i .. dunno.
18:27:22 <LoganCapaldo> this is madness! No, this is the monomorphism restriction!
18:28:17 <monochrom> Solution: Give a type signature to newFPRegFile.
18:28:21 <mtp> > listArray (0,30) (repeat 0) -- also doesn't work on my ghci
18:28:23 <TomMD> @quote perl
18:28:23 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
18:28:23 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
18:28:23 <lambdabot> he was one of the pugs de
18:28:29 <lambdabot>  array (0,30) [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(1...
18:28:52 <monochrom> lambdabot behaves slightly differently.
18:29:08 <mauke> yeah, extended defaulting
18:29:27 <mauke> > listArray `asTypeOf` id
18:29:34 <lambdabot>  Couldn't match expected type `[e] -> Array i e'
18:29:43 <mauke> or a different listArray
18:29:50 <monochrom> Technical details of the monomorphism restriction is at http://haskell.org/onlinereport/decls.html#sect4.5.5
18:29:53 <mtp> oh, yeah, huh.
18:31:32 <monochrom> Generally definitions like x = read "0" falls under the spell. Function definitions like f y = read "0" are unaffected. Definitions with user type signatures are unaffected.
18:31:46 <mtp> > Data.Array.Diff.listArray
18:31:49 <lambdabot>   Not in scope: `Data.Array.Diff.listArray'
18:31:52 <mtp> Bah
18:32:00 <mauke> @index listArray
18:32:00 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
18:32:19 <mauke> :t Data.Array.listArray
18:32:26 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
18:32:28 <mauke> that's what lambdabot uses
18:33:40 <LoganCapaldo> > listArray (-3, -1) [0,1,2] ! -2
18:33:41 <lambdabot>      precedence parsing error
18:33:41 <lambdabot>         cannot mix `(!)' [infixl 9] and prefix ...
18:33:54 <LoganCapaldo> > listArray (-3, -1) [0,1,2] ! negate 2
18:33:55 <lambdabot>  1
18:34:17 <LoganCapaldo> Haskell's index versatility is versatile
18:34:35 <monochrom> There is no Data.Array.Diff.listArray. There is only Data.Array.IArray.listArray :: blahblah -> Data.Array.Diff.DiffArray blahblah
18:35:06 <mtp> Ahh
18:35:08 <LoganCapaldo> > listArray (-3, -1) [0,1,2] == listArray (-2, 0) [0,1,2]
18:35:12 <monochrom> This is the same phenomenon as: there is no Complex.read, there is only Prelude.read :: String -> Complex blah
18:35:14 <mtp> adding a type annotation fixed it
18:35:16 <lambdabot>  False
18:35:20 <LoganCapaldo> oh good
18:35:26 <LoganCapaldo> I got scared there
18:35:45 <mtp> Array.Diff is a bit more stringent, it seems
18:35:55 <LoganCapaldo> @hoogle (Ix i) => Array i e -> i
18:35:56 <lambdabot> No matches, try a more general search
18:36:02 <hpaste>  mtp annotated "(no title)" with "fixed" at http://hpaste.org/3968#a2
18:36:20 <Olathe> > false
18:36:20 <lambdabot>  True
18:37:05 <LoganCapaldo> @hoogle Array i e -> i
18:37:06 <lambdabot> No matches, try a more general search
18:37:11 <LoganCapaldo> bah
18:37:22 <LoganCapaldo> @hoogle minIndex
18:37:22 <lambdabot> No matches found
18:37:34 <LoganCapaldo> @docs Data.Array
18:37:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
18:38:07 <LoganCapaldo> aha
18:38:10 <LoganCapaldo> bounds
18:38:32 <mauke> BOUNCE
18:38:51 <dmwit> boing!
18:58:32 <dmwit> Nobody programs on Sunday night. =/
18:59:01 <dons> xmonad is getting programmed right now
18:59:16 <monochrom> I'm programming on Sunday night.
18:59:33 <dmwit> You guys know enough that you don't have to ask questions, though. =)
19:00:01 <monochrom> Oh you mean that! Actually a couple of type error questions a while ago.
19:00:15 <monochrom> (It turned out to be MR again!)
19:00:22 <dmwit> hehe
19:00:30 <dmwit> What a beautiful feature.
19:03:59 * SamB wonders why debian has a package of rpm
19:04:12 * SamB wonders even more why he installed it
19:04:26 <LoganCapaldo> rpm is the LSB packaging system is it not?
19:04:39 <SamB> the what now?
19:04:46 <Nafai> Plus if you want to use alien, you need rpm
19:05:05 <SamB> oh, that would explain how it got installed then
19:05:08 <LoganCapaldo> that was gonna be the next thing I said :)
19:05:20 <allbery_b> plus if you want touse most commercial software you need either rpm or alien (which uses rpm)
19:05:24 <LoganCapaldo> LSB = linux standard base
19:05:45 <SamB> I thought most commercial software came in tarballs or .isos
19:06:11 <allbery_b> an awful lot of commercial s/w is packaged in rpms for red hat
19:06:20 <LoganCapaldo> I've seen lots commercial stuff in rpms
19:07:28 <SamB> granted, I've only really looked at games and their demos...
19:07:42 <dfranke> If I lazily read a string from a file handle, possibly with blocking IO, and then spawn a thread that writes that string to another handle, do I need to do any sort of locking?  Or is it taken care of by the IO manager already?
19:08:29 <dons> should be fine.
19:08:37 <dons> the spawned thread will demand the input
19:09:42 <SamB> I assume that that string is the only thing in the file?
19:10:02 <dfranke> yes.  It's really a pipe.
19:12:02 <SamB> hmm, SUS should adopt the subtitle "many names"
19:15:22 <sclv> ok so I had an interesting stupid idea. we have polymorphism on strings with isString, right?
19:15:44 <sclv> could we do the same with all things that can be "list like"?
19:15:55 <sclv> i.e., implementing fromList and toList?
19:16:57 <sclv> polymorphism on list/sequencelike things seems a bit harder than necessary in haskell at the moment, or am I missing something?
19:18:35 <sclv> e.g., it would be nice to be able to drop in a sequence, a dlist, a skiplist etc with essentially no rewriting and furthermore in such a way that it didn't require hiding the prelude & such to make it "transparent" so that the instances could be used across the same file easily.
19:19:05 <LoganCapaldo> I find your ideas intriguing and wish to subscribe to your newsletter
19:20:07 <sclv> I suspect you'd probably need some magic for the (:) constructor if you *really* wanted this to work, such that it instead became a polymorphic function for construction, which is easy, but compiler voodoo for pattern matching.
19:21:17 <sclv> I mean its sort of on that level of it would be nice to write all yr. code using lists and maps and then decide on nice implementations later, sort of how you can swap iarrays without too much difficulty.
19:22:15 <Saizan_> well arrays have a much more consistent structure than what you're talking about
19:23:21 <sclv> conceptually anything that can be viewed as a list has a car and cdr, which is all that list functions are built on, though, right?
19:23:48 <sclv> you could specialize better ones for your instance though, would be the point.
19:24:47 <sclv> the only real obstacle would be the pattern matching and properly "desugaring" list notation in type declarations.
19:25:25 <Saizan_> yes, but if you build everything with car and cdr you don't gain anything for more complex structures
19:25:33 <Saizan_> *from
19:27:01 <sclv> right: so you have a class isList with all yr. list functions (which are built from car and cdr) and a default list implementation and then you have Data.Sequence which implements the defaults and also a whole bunch of others more efficiently, and Data.DList which overrides the default ++ and etc.
19:28:01 <Saizan_> yeah, the problem lies in writing that class
19:29:22 <sclv> nah -- that class is essentially yr. basic list functions -- the problem is in you need compiler support if you want to keep pattern matching reasonable, or at least views.
19:29:24 <ddarius> This idea has come up before.
19:30:09 <Saizan_> sclv: so all of Data.List?
19:31:00 <SamB> many times
19:31:02 <SamB> in many forms
19:31:51 <Saizan_> the one i've seen was a StringLike to unify String and ByteString
19:31:59 <sclv> Saizan_: well, I mean, it's already been written, so...
19:37:56 <sfultong> what is recommended for windowing libraries?  gtk2hs? ghc native x11 or glut?  something else?
19:38:15 <sfultong> ideally I'd like png support, and it's just a 2d app
19:40:23 <dmwit> Gtk2Hs is pretty nice.
19:40:38 <dmwit> It's not really a windowing library, though.
19:40:51 <dmwit> X11 is counter-indicated. =)
19:41:00 <dmwit> What are you trying to do?
19:42:06 <dons> x11 is indeed counter-indicated.
19:42:12 <dons> unless writing a window manager
19:42:34 <sfultong> hehe, ok
19:42:36 <Cale> Or a Haskell-native widget library :)
19:42:43 <Lewisham> does GTK2Hs look like ass on Mac OS X?
19:43:11 <araujo> sfultong, gtk2hs is definitely the way to go for GUI apps.
19:43:17 <sfultong> ah, thanks
19:43:34 <Cale> Lewisham: no, but I'm a Linux user.
19:44:00 <shachaf> Is gtk2hs recommended over wxhaskell?
19:44:03 <sfultong> why isn't gtk2hs in the ghc standard libraries?  Is it too new?
19:44:27 <Cale> It's maybe too big.
19:44:29 <dmwit> Maybe they don't want a dependency on Gtk, for Windows people.
19:44:39 <araujo> sfultong, Because they are bindings for gtk+
19:44:39 <sfultong> there's gtk for windows...
19:44:39 <Saizan_> so, which idiom would you use to communicate listening threads that a Chan will be written no more?
19:44:43 <Lewisham> Cale: I'll take you word for it :) Maybe I'll have a crack at it later this evening, to see what it looks like
19:44:55 <dmwit> sfultong: Right, but what Windows person has it installed?
19:45:00 <sfultong> heh, true
19:45:06 <araujo> sfultong, programming languages don't usually ship with such a bindings
19:45:32 <araujo> implementations*
19:45:34 <dmwit> (Well, I guess I did, because I used Gimp as a refusal to pirate Photoshop, but... =)
19:45:44 <sfultong> well, the ghc standard library has gotten quite large, it seems
19:46:00 <sfultong> and a glut binding is provided, and that's probably non-trivial
19:46:54 <araujo> It's better to have modularized packages though
19:47:07 <sfultong> I'd trot out the idea that MS is behind the exclusion, but I'm afraid I'd be taken seriously
19:47:34 <araujo> There is no point for that
19:47:59 <araujo> gtk2hs is just a project containing bindings for gtk+
19:48:27 <araujo> As i said; most of the programming languages implementations work like that too.
19:48:56 <araujo> They have different projects for each bindings and such.
19:49:17 <sfultong> but it'd be more fun if all bindings were done in a purely functional way...
19:49:41 <sfultong> they should be chock full of state monads
19:49:45 <araujo> gtk2hs is purely functional.
19:50:40 <ddarius> Saizan_: Have an "end of content" message?
19:50:59 <ddarius> Saizan_: You could also do much more interesting things like passing the continuation over the channel.
19:54:27 <sfultong> araujo: it doesn't have crazy stuff like the $= operator in ghc's glut libraries?
19:55:33 <dmwit> What does $= do? IORef?
19:55:55 <sfultong> yeah
19:56:03 <Saizan_> ddarius: which continuation are you referring to?
19:56:06 <araujo> sfultong, no way
19:56:09 <dmwit> Nope, none of that.
19:56:11 <sfultong> that's good
19:56:44 <araujo> sfultong, you can easily code using gtk2hs without using State
19:57:41 <Saizan_> isn't it in IO anyway?
19:57:59 <ddarius> Saizan_: In some contexts you can pass on what the listener should continue to do.
20:00:45 <Saizan_> ddarius: here i'm essentially "broadcasting" messages fetched form a socket, so it doesn't apply well
20:01:25 <Saizan_> i'm wondering about writing my own version of Chan
20:01:28 <sfultong> araujo: but perhaps there would be some advantages to forcing people to use it that way?  I dunno, I'm just wondering
20:04:46 <ddarius> You could make a one-shot Chan using MVars and have it pass a next one-shot Chan until it's finished.
20:06:04 <araujo> Saizan_, yeah, probably to be more explicit the mutable State monads
20:06:16 <araujo> sfultong, to use it in what way?
20:08:21 <Saizan_> ddarius: that seems just the current implementation of Chan
20:10:44 <dmwit> What is the meaning of this law?
20:10:52 <dmwit> arr (f >>> g) = arr f >>> arr g
20:11:00 <dmwit> It doesn't seem well-typed to me.
20:11:11 <Brian``> @src sequence
20:11:11 <lambdabot> sequence ms = foldr k (return []) ms
20:11:11 <lambdabot>     where
20:11:11 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
20:11:46 <dmwit> Or, actually, what I mean is, the type seems too restrictive for that to be a general arrow law.
20:12:00 <ddarius> Saizan_: Yes, the main difference would be the difference between data Stream a = Stream a (Stream a) and data List a = Cons a (List a) | Nil
20:12:53 <shachaf> dmwit: The second (>>>) is function composition, right?
20:13:00 <Saizan_> the first is
20:13:05 <dmwit> Oh, never mind, that law is only supposed to apply to the function arrow anyway.
20:13:20 <shachaf> (I meant the first, sorry.)
20:14:37 <Saizan_> ddarius: yes, i wonder if that'll noticeably impact performance
20:14:51 <ddarius> I don't see why it would.
20:25:56 <bilboquet> Newbie question: I can't get array-0.1.0.0 to build with GHC 6.6.1. Is it supposed to build?
20:26:21 <dfranke> Is there a preprocessor available that provides codo sugar for comonads?
20:26:45 <ddarius> No
20:27:15 <dfranke> was that to me or to bilboquet?
20:27:29 <ddarius> You
20:28:20 <shachaf> bilboquet: I don't think so.
20:28:30 <bilboquet> What version should I use?
20:28:42 <TomMD> 6.9
20:28:43 <shachaf> bilboquet: No version -- 6.6.1 is before the split.
20:28:43 <dmwit> Data.Array is in base
20:29:00 <dmwit> (i.e. you should already have it)
20:29:32 <shachaf> bilboquet: Or use GHC 6.8.1, which may be nicer.
20:29:36 <bilboquet> dmwit: Well I got this error trying to build hosc: Setup.lhs: cannot satisfy dependency array-any
20:30:43 <dmwit> Try removing that dependency from the .cabal file?
20:31:07 <dfranke> bilboquet: that probably means the package is intended for 6.8.1, but try dmwit's suggestion.
20:32:32 <dfranke> well, foo.  I've finally realized that comonads are the appropriate abstraction of this pattern I keep running into, but they're ugly without codo.
20:33:14 <shachaf> dfranke: What would codo be like, by the way?
20:33:21 <shachaf> dfranke: (What would it translate into?)
20:33:40 <bilboquet> dfranke: I'll try with 6.8.1..
20:33:59 <dfranke> shachaf: http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
20:34:00 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
20:37:00 <shachaf> dfranke: "I've been trying to figure out what similar sugar might look like for comonads. But I can't quite figure it out. I can see roughly what it'd look like."
20:37:13 <dmwit> "We end up with something twice as fancy... but twice as fancy is still just fancy."
20:37:30 <luqui> Is there a way to see how ghc desugars arrow syntax?
20:37:53 <dmwit> GHC doesn't desugar arrow syntax, does it?
20:38:02 <dmwit> You have to use a separate preprocessor for that.
20:38:06 <dfranke> yes, it does.
20:38:09 <dfranke> -farrows to enable it.
20:38:13 <dmwit> Oh, wow!
20:38:22 <ddarius> dmwit: GHC has been doing that for a long while now.
20:38:32 <dmwit> Well, great.
20:39:36 <shachaf> luqui: Does http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html help?
20:39:37 <lambdabot> Title: 8.9. Arrow notation, http://tinyurl.com/tts6c
20:40:46 <luqui> shachaf, no not really.  I want to see specifically what it's doing because I have two things which I think are equivalent but they're behaving differently...
20:41:42 <hpaste>  luqui pasted "Aren't these arrows equivalent?" at http://hpaste.org/3969
20:42:08 <hpaste>  luqui annotated "Aren't these arrows equivalent?" with "I mean..." at http://hpaste.org/3969#a1
20:45:01 <ddarius> I believe they should be.
20:45:38 <luqui> probably means I implemented my arrow wrong then...
20:50:42 <dmwit> "the actual translation produces Core"
20:51:07 <dmwit> luqui: So, you'd have to use the flag that dumps the Core language and go vgrepping through it to find out how it desugars.
20:51:30 <dons> thorkilnaur: re dataum, remember even data Singular = Singular has two inhabitants in the type :)
20:51:33 <luqui> ok, what's the flag?
20:51:35 <dons> thetallguy: ^^
20:51:54 <dmwit> luqui: I don't know... -ddump-simpl?
20:54:44 <luqui> dmwit, that seems to do it
20:56:31 <Brian``> hey, on All About Monads tutorial, it says "Right-to-left binding (of foldM) is achieved by reversing the input list before calling foldM." Does this hold for foldl and foldr, too?
20:56:48 <dmwit> no
20:57:09 <dmwit> Wait, what?
20:57:32 <dons> ?src foldM
20:57:32 <lambdabot> foldM _ a []     = return a
20:57:32 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
20:57:39 <dons> ?src foldl
20:57:40 <lambdabot> foldl f z xs = lgo z xs
20:57:40 <lambdabot>     where lgo z []     =  z
20:57:40 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
20:57:44 <dons> ?src foldr
20:57:44 <lambdabot> foldr k z xs = go xs
20:57:44 <lambdabot>     where go []     = z
20:57:44 <lambdabot>           go (y:ys) = y `k` go ys
20:57:56 <dons> there's only one direction with foldM
20:58:02 <dmwit> Brian``: No, rather than composing foldl and reverse, you'd just use foldr; similarly you wouldn't use foldr and reverse, you'd use foldl.
20:58:22 <shachaf> But still, it would work.
20:58:33 <shachaf> (Right?)
20:58:41 <ddarius> foldr c n /= foldl (flip c) n . reverse
20:58:56 <Brian``> but for foldM, we have to provide reversed list in order to use right-to-left binding?
20:59:16 <dmwit> ddarius: Is that only false for infinite lists?
21:00:01 <dons> ?check \c n xs -> (foldr c (n::Int) (xs::[Int])) == (foldl (flip c) n . reverse $ xs)
21:00:17 <lambdabot>  thread killed
21:00:25 <shachaf> How about (foldl c n) and (foldr (flip c) n . reverse), in the other direction?
21:00:35 <dons> ?check \c n xs -> length xs < 5 => (foldr c (n::Int) (xs::[Int])) == (foldl (flip c) n . reverse $ xs)
21:00:35 <lambdabot>  Parse error at "=>" (column 26)
21:00:39 <dons> ?check \c n xs -> length xs < 5 ==> (foldr c (n::Int) (xs::[Int])) == (foldl (flip c) n . reverse $ xs)
21:00:49 <dons> :)
21:00:50 <lambdabot>  Arguments exhausted after 301 tests.
21:01:03 <Brian``> lol
21:01:10 <Brian``> is that quick check?
21:01:15 <dons> yeah.
21:01:17 <dmwit> I'd be exhausted, too, I guess.
21:01:18 <ddarius> > let c x xs = "(c "++show x++" "++xs++")"; n = "n" in foldr c n [1,2,3]
21:01:19 <lambdabot>  "(c 1 (c 2 (c 3 n)))"
21:01:24 <dons> ?scheck \c n xs -> length xs < 5 ==> (foldr c (n::Int) (xs::[Int])) == (foldl (flip c) n . reverse $ xs)
21:01:30 <lambdabot> Done.
21:01:39 <dons> ?check \x -> x || not x
21:01:40 <lambdabot>  OK, passed 500 tests.
21:01:42 <ddarius> > let c x xs = "(c "++show x++" "++xs++")"; n = "n" in foldl (flip c) n $ reverse [1,2,3]
21:01:43 <lambdabot>  "(c 1 (c 2 (c 3 n)))"
21:01:43 <dons> ?scheck \x -> x || not x
21:01:43 <lambdabot>   Completed 2 test(s) without failure.
21:02:03 <shachaf> > foldr (:) [] [1..]
21:02:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:02:19 <shachaf> > foldl (flip (:)) [] (reverse [1..]) -- :-)
21:02:21 <lambdabot> Terminated
21:02:39 <dmwit> Right.
21:02:56 <dmwit> So, for finite lists they compute the same value.
21:03:10 <Brian``> interesting...
21:03:12 <dmwit> For infinite lists, foldr may terminate when foldl does not.
21:03:18 <shachaf> But in the other direction they're equivalent, right?
21:03:21 <dmwit> (and reverse certainly won't terminate)
21:03:29 <ddarius> > foldr const undefined [1,2,3]
21:03:30 <Brian``> yeah
21:03:31 <lambdabot>  1
21:03:37 <ddarius> > foldl (flip const) undefined $ reverse [1,2,3]
21:03:38 <lambdabot>  1
21:03:54 <Brian``> :t const
21:03:55 <lambdabot> forall a b. a -> b -> a
21:04:05 <dmwit> shachaf: No, for the same reason: on infinite lists, reverse does not terminate.
21:04:15 <shachaf> dmwit: Exactly, and neither does foldl.
21:04:18 <ddarius> Even if reverse did terminate, foldl doesn.
21:04:25 <dmwit> oh ho!
21:04:36 <shachaf> I'm talking about (foldl c n) and (foldr (flip c) n . reverse).
21:04:41 <dmwit> ok
21:04:43 <ddarius> Of course, reverse = foldl (flip (:)) []
21:11:42 <goalieca> @src reverse
21:11:42 <lambdabot> reverse = foldl (flip (:)) []
21:11:58 <ddarius> goalieca doesn't trust me
21:12:13 <dmwit> I don't trust you either.
21:12:19 <ddarius> Me neither.
21:12:57 <dmwit> Oh!
21:13:02 <dmwit> Are there monad transformer laws?
21:13:08 <ddarius> Sure.
21:14:19 * dmwit adds to his queue
21:15:36 <shachaf> Is there a reason reverse isn't foldl'?
21:16:03 <dmwit> ?source reverse
21:16:04 <lambdabot> reverse not available
21:16:11 <ddarius> shachaf: There's no reason it should be.
21:16:15 <monochrom> @type ap
21:16:16 <ddarius> And foldl' isn't H98
21:16:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:16:27 <shachaf> ddarius: Oh, right.
21:16:31 <shachaf> It's optimized, right?
21:16:42 <ddarius> ?
21:16:45 <goalieca> >take 5 $ reverse [1..2^31]
21:16:47 <shachaf> With just foldl.
21:16:56 <goalieca> > take 5 $ reverse [1..2^31]
21:17:02 <dmwit> Probably, but ?source failed me.
21:17:03 <lambdabot> Terminated
21:17:12 <goalieca> it seems strict anyways
21:17:20 <shachaf> dmwit: ?source is for modules.
21:17:22 <ddarius> shachaf: I don't think so, no more than foldl'.  The issue is there is no semantic difference between foldl and foldl' in reverse's case.
21:17:23 <shachaf> @source Data.List
21:17:24 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:18:17 <dmwit> ddarius: Space usage?
21:18:29 <ddarius> let y = x:xs in y `seq` f y  === f (x:xs)
21:18:34 <ddarius> dmead: ?
21:18:37 <ddarius> er dmwit
21:19:36 <shachaf> Hmm, right.
21:19:51 <dmwit> yeah
21:19:51 <dmwit> ok
21:20:57 <dmwit> ?hoogle Bool -> a -> Maybe a
21:20:57 <lambdabot> No matches, try a more general search
21:21:34 <bilboquet> dfranke: I managed to get almost everything running with 6.8.1. I installed binary-0.4.1 and when I link my program it says "unknown package: binary-0.4". What does that mean?
21:21:43 <ddarius> :t guard
21:21:44 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:22:10 <ddarius> :t fmap (const ?a) . guard
21:22:11 <lambdabot> forall a (f :: * -> *). (?a::a, Functor f, MonadPlus f) => Bool -> f a
21:22:54 <dmwit> :t \p x -> guard (p x) >> return x
21:22:54 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
21:23:22 <dfranke> bilboquet: is the program specifying that it needs an exact version of binary?
21:23:29 <dmwit> That's nice.
21:23:41 <dmwit> > guard False >> return 3 :: Maybe Int
21:23:43 <lambdabot>  Nothing
21:24:33 <bilboquet> dfranke: It's not depending on binary directly, so no
21:25:37 <dfranke> bilboquet: don't think I can help you then without poking around.
21:26:36 <newsham> guard (p x) >> f x
21:26:48 <newsham> guard (p x) >> return (f x)
21:26:59 <dmwit> Very useful for unfoldr.
21:29:19 <dmwit> :t \p f x -> unfoldr (\i -> guard (p i) >> return (f i)) x
21:29:20 <lambdabot> forall b a. (b -> Bool) -> (b -> (a, b)) -> b -> [a]
21:30:21 <dmwit> ?pl \x -> (>> return (f x))
21:30:21 <lambdabot> flip (>>) . return . f
21:30:37 <newsham> ?pl \(a,b) -> (b,a)
21:30:37 <lambdabot> uncurry (flip (,))
21:31:34 <shachaf> > (uncurry . flip . curry) id (1,2)
21:31:35 <lambdabot>  (2,1)
21:33:07 <dmwit> > let while p f x = unfoldr (\i -> guard (p i) >> return (f i)) x in while (<10) (join (***) (+1)) 0
21:33:08 <lambdabot>      Occurs check: cannot construct the infinite type: b = (b, b)
21:33:08 <lambdabot>       Expec...
21:33:15 <dmwit> :t join (***)
21:33:16 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
21:33:54 <dmwit> > let while p f x = unfoldr (\i -> guard (p i) >> return (f i)) x in while (<10) (join (,) . (+1)) 0
21:33:55 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:34:31 <newsham> > unfoldr (\n -> guard (n /= 0) >> (uncurry.flip.curry.(`divMod` 10)) n) 4231
21:34:32 <lambdabot>  Couldn't match expected type `(a, b) -> c'
21:36:43 <dmwit> > let while p f x = unfoldr (\i -> guard (p i) >> return (f i)) x in while (/=0) (\x -> (x `mod` 10, x `div` 10)) 4231
21:36:44 <lambdabot>  [1,3,2,4]
21:36:45 <newsham> > unfoldr (\n -> guard (n /= 0) >> (uncurry (flip (,)).(`divMod` 10)) n) 4231
21:36:45 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
21:37:09 <dmwit> ?pl \x -> (x `mod` 10, x `div` 10)
21:37:10 <lambdabot> liftM2 (,) (`mod` 10) (`div` 10)
21:40:57 <shachaf> > (\x -> x `mod` 10, x `div` 10) 5
21:40:58 <lambdabot>   Not in scope: `x'
21:41:20 <shachaf> What's that supposed to mean?
21:41:24 <dmwit> > (\x -> (x `mod` 10, x `div` 10)) 5
21:41:39 <lambdabot>  thread killed
21:41:46 <dmwit> mrnt?
21:42:06 <dmwit> shachaf: It means that in the second argument of your tuple, x doesn't exist (because it isn't inside the lambda).
21:42:16 <shachaf> > (\x -> (x `mod` 10, x `div` 10)) 5 -- I forgot the parentheses, indeed, but that should work now.
21:42:28 <lambdabot>  (5,0)
21:42:39 <shachaf> Oh.
21:43:03 <xpika> is there a good technique for keeping using multiple ghc versions?
21:43:18 <ddarius> Just do so.
21:43:33 <allbery_b> ghc installs as ghc-$version with the latest install symlinked to ghc
21:43:39 <allbery_b> and the libdirs are versioned
21:43:57 <xpika> so when you want to compile with ghc 6.6?
21:44:03 <shachaf> xpika: Use ghc-6.6.
21:44:04 <ddarius> ghc-6.6
21:44:05 <dmwit> ghc-6.6.1 --make
21:44:06 <allbery_b> just make it use ghc-6.6 instead of ghc
21:44:16 <shachaf> (And use runghc -f ghc-6.6)
21:45:52 <xpika> ok, im using the windows build
21:46:30 <ddarius> The story should pretty much be the same.
21:46:38 <Lemmih> No more stereo. Hello surround sound.
21:47:07 <xpika> windows build doesn't come with symliks
21:47:23 <dmwit> That's okay, ghc-6.6.1 and ghc-6.8.1 will still work.
21:48:16 <xpika> all I have is a ghc.exe
21:48:28 <xpika> two ghc.exe's
21:53:45 <newsham> ?pl \n -> guard (n/=0) >> return (n+1)
21:53:46 <lambdabot> ap ((>>) . guard . (0 /=)) (return . (1 +))
21:56:34 <phlpp> hi
21:56:58 <TSC> Hi, phlpp
22:08:19 <dfranke> Alright, this is getting frustrating....
22:08:26 <dfranke> Is there a category theorist in the house?
22:08:38 <ddarius> Just ask your question.
22:09:09 <dfranke> okay, so I have `data ExecBuilder b c' whose internal structure is hidden.
22:10:24 <dfranke> I have a function which constructs an ExecBuilder, and some functions which map ExecBuilders to ExecBuilders with possibly-different type parameters.
22:10:57 <dfranke> and finally, I have a function buildExec :: ExecBuilder b c -> PipeArrow b c, and PipeArrow is an arrow.
22:11:15 <dfranke> so, everything works fine...
22:11:40 <dfranke> but there has got to be a category theoretic description of what an ExecBuilder is.
22:11:56 <dfranke> and I can't figure out what the hell that description is.
22:12:03 <dfranke> I thought it was a comonad, but it turns out not quite.
22:13:47 <dfranke> or rather, it wasn't quite a comonad when I had (ExecBuilder (PipeArrow b c)) rather than ExecBuilder b c
22:13:55 <dfranke> obviously this way it's the wrong kind.
22:14:28 <ddarius> buildExec might be the action of a functor on some kind of arrow types if ExecBuilder can be viewed as a Hom-"set" of some type.
22:14:47 <ddarius> I don't know why you think there has to be some (nice) categorical thing here.
22:14:53 <marceau> so you're looking for something more than a bifunctor with a couple of natural transformations?
22:15:53 <dfranke> marceau: I might be looking for precisely that.
22:17:01 <ddarius> dfranke: Since "natural transformation" just translates to "polymorphic function", it being a bifunctor with some natural transformation would be saying something almost vacuous.
22:17:09 <ddarius> "bifunctor" would be saying a bit
22:19:08 <marceau> unless you've got some mappings that suggest structure, such as a 'multiplication' or 'comultiplication' in this case of monads or comonads, it is hard to say if there is a special categorical label for your situation
22:20:15 <dfranke> is there anything interesting that comes from having a monomorphism from ExecBuilders to PipeArrows?
22:20:35 <marceau> well that it might be an action of some kind has been suggested
22:22:18 <marceau> if it is a monomorphism/epimorphism on functions as a functor then it could be called faithfull/full
22:22:33 <marceau> but you haven't said what it does to functions, only to types
22:22:45 <dfranke> the trouble is that it's not an isomorphism -- not every PipeArrow has a corresponding ExecBuilder.  Otherwise I could at least define an instance of Functor.
22:23:08 <ddarius> dfranke: What are you talking about?
22:23:12 <dfranke> (if I wrote the type as ExecBuilder (PipeArrow b c))
22:23:28 <marceau> that's not an issue categorically as a functor does not have to be surjective on objects
22:25:06 <dfranke> the problem isn't that it isn't surjective.  It's that some PipeArrows wouldn't be in the domain.
22:26:12 <marceau> wait, so you have a function that takes an ExecBuilder and gives a PipeArrow?
22:26:23 <dfranke> right.
22:26:26 <marceau> for any ExecBuilder?
22:26:31 <dfranke> correct.
22:26:39 <dfranke> but that function is not invertible.
22:26:52 <dfranke> it's injective but not surjective.
22:26:55 <marceau> that's ok.
22:27:01 <marceau> because they are both functors
22:27:13 <marceau> so that function is a natural transformation between the functors
22:27:29 <marceau> strictly speacking, that collection of functions
22:28:15 <dfranke> what are the both in "they are both functors"?
22:28:55 <marceau> ExecBuilder takes two types, so it is a functor from Types x Types to Types
22:29:04 <marceau> so is PipeArrow
22:29:48 <ddarius> Presumably PipeArrow is more like Type^op x Type -> Type
22:30:03 <marceau> sure
22:30:36 <luqui> hmm... why isn't there an instance Arrow a => Functor (a b) where fmap = (^<<)
22:31:02 <dfranke> I think that would be an undecidable instance.
22:31:26 <marceau> (but arrows are functors, just as monads are functors)
22:33:45 <luqui> dfranke, ghc ain't complainin...
22:34:08 <luqui> (it needs -XFlexibleInstances, but not undecidable)
22:35:57 <marceau> arrows probably are not required to be functors by haskell by default, just like monads, so that you don't have to define fmap if you don't want to
22:36:48 <marceau> *are
22:37:19 <marceau> in the case of monads, a category theorist would define join and fmap
22:37:26 <marceau> and then define bind in terms of those
22:37:34 <marceau> but if all you care about is bind...
22:37:49 <ddarius> Categorist don't usually define bind at all.
22:38:42 <luqui> but can't you define fmap f x = x >>= (return . f)
22:38:47 <marceau> that's definitely true
22:38:58 <luqui> so why not Monad m => Functor m
22:39:03 <marceau> also true
22:39:34 <sjanssen> luqui: because that instance is potentially both overlapping and undecidable
22:40:09 <marceau> it is sometimes done nevertheless
22:40:09 <luqui> fair enough.  I don't really grok the instance criteria yet..
22:41:10 <sjanssen> well, it's obviously overlapping:
22:41:24 <sjanssen> data Foo a; instance Functor Foo; instance Monad Foo
22:48:13 <chadz> anyone know if hs-plugins will work with 6.8.1?
22:48:33 <chadz> all my attempts building it lead to a bizzare error akin to "Data.Array.Base is hidden"
22:49:06 <hircus> chadz: modify the cabal build file to include those
22:49:06 <Lemmih> It won't.
22:49:44 <hircus> 6.8.1 remove a lot of things from the default namespace .. forgive any terminology abuse
22:52:01 <chadz> hircus: alright.
22:52:03 <chadz> thanks
22:52:15 <chadz> now, to figure out why my robocode bot won't load :(
22:52:22 <hircus> no prob
22:52:39 <Lemmih> chadz: hs-plugins has to be updated for each new release of ghc.
22:53:35 <ac_> why does ghc make such monstrous binaries?
22:54:31 <monochrom> @src Control.Applicative.some
22:54:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:54:46 <chadz> @src some
22:54:46 <lambdabot> some v = some_v
22:54:46 <lambdabot>   where many_v = some_v <|> pure []
22:54:46 <lambdabot>         some_v = (:) <$> v <*> many_v
22:55:00 <monochrom> @src optional
22:55:01 <lambdabot> optional v = Just <$> v <|> pure Nothing
22:55:04 <ac_> my hello world program is 2.8M
22:55:05 <dfranke> ac_: because it statically links it runtime.
22:55:14 <dfranke> its*
22:55:24 <chadz> i gotta read into the applicative stuff. i've been meaning to forever, until I forgot what it was called.
22:55:37 <chadz> :t <|>
22:55:39 <lambdabot> parse error on input `<|>'
22:55:42 <monochrom> Haha. OK I see. Thanks.
22:55:46 <chadz> :t (<|>)
22:55:47 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
22:56:18 <sjanssen> ac_: the binary would be much smaller with split-objs on
22:56:22 <chadz> :t (<$>)
22:56:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:56:43 <chadz> that's bizzare
23:00:00 <ac> sjanssen: how do I do that?
23:00:24 <dfranke> anyhow, thanks marceau, ddarius.  I've defined class Bifunctor f where bimap :: (a -> c) -> (b -> d) -> (f a b) -> (f c d), and I'm able to write a reasonable instance for that.
23:00:54 <dfranke> one which I probably won't bother to include, but that sates my curiosity.
23:01:25 <sjanssen> ac: it's a setting you can turn on when building GHC's libraries.  I don't recall exactly how to do it
23:14:54 <xpika> does anyone know how to fix the windows hs plugins problem "c:/ghc/ghc-6.6/HSbase.o: unknown symbol `_free'"
