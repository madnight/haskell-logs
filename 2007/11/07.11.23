00:06:54 <wli> mu = join, which are fmap and return?
00:08:03 <ddarius> eta = return and fmap is the action of the functor itself the name of which is usually used for it.
00:08:13 <Syzygy-> return == eta and fmap is the functor .... what ddarius said
00:08:16 <wli> Okay.
00:08:26 * Syzygy- is a big fan of "functor with natural transformations"
00:08:39 <wli> What's a good way to check for won games in Connect 4?
00:08:57 <ddarius> I.e. bind in category theory looks like Tf;Âµ
00:09:18 <Syzygy-> ddarius: ; = eta ?
00:09:30 <Syzygy-> :t bind
00:09:32 <lambdabot> Not in scope: `bind'
00:09:38 <Syzygy-> :t (>>=)
00:09:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:11:21 <ddarius> ; is diagrammatic orderg composition, i.e. >>> or flip (.)
00:38:33 <osfameron> morning
00:47:14 <spitters> pl \x f x -> f x x
00:47:36 <spitters> :pl \x f x -> f x x
00:48:47 <wli> @pl \x f -> f x x
00:48:47 <lambdabot> flip =<< flip id
00:48:57 <wli> @pl \f x -> f x x
00:48:57 <lambdabot> join
00:49:10 <wli> @type flip join
00:49:11 <lambdabot> forall a b. b -> (b -> b -> a) -> a
00:49:17 <wli> @type flip =<< flip id
00:49:18 <lambdabot> forall c b. b -> (b -> b -> c) -> c
00:50:06 <wli> spitters: Your \x f x -> f x x is illegal because of the repeated x in the argument list of the lambda.
00:50:31 <wli> spitters: Not sure if one of the x's is spurious or if you wanted a y in one of those positions.
01:00:40 <spitters> Thanks
01:01:26 <Pastorn> i have this: ordered (x:y:ys) = x <= y && ordered (y:ys)
01:01:29 * wli tries to think of how to group Ints into lists of consecutive members.
01:01:36 <Pastorn> can i make that with fold somehow?
01:02:14 <quicksilver> Pastorn: no, you can make it into a zip
01:02:48 <quicksilver> :t \l -> all (zipWith (<=) l (tail l))
01:02:50 <lambdabot>     Couldn't match expected type `a -> Bool'
01:02:50 <lambdabot>            against inferred type `[Bool]'
01:02:50 <lambdabot>     In the first argument of `all', namely `(zipWith (<=) l (tail l))'
01:02:52 <Pastorn> ah, and . zipWith (<) x (tail x), right?
01:03:00 <quicksilver> yes :)
01:03:15 <quicksilver> :t all
01:03:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:03:17 <quicksilver> :t and
01:03:17 <lambdabot> [Bool] -> Bool
01:03:23 <quicksilver> always get those confused :)
01:03:30 <quicksilver> :t \l -> and (zipWith (<=) l (tail l))
01:03:30 <lambdabot> forall a. (Ord a) => [a] -> Bool
01:03:37 <Pastorn> quicksilver: all = and . mayp
01:03:44 <Pastorn> *and . map*
01:03:53 <quicksilver> Pastorn: yes, I see that now :) I just get them mixed up sometimes
01:05:28 <Pastorn> @pl (\xs -> zipWith (<=) xs (tail xs))
01:05:28 <lambdabot> ap (zipWith (<=)) tail
01:05:35 <Pastorn> fuckin
01:05:36 <Pastorn> ap
01:21:16 <quicksilver> Pastorn: yes, it's a close cousing of the wellknown aztec god
01:21:21 <quicksilver> Pastorn: zip`ap`tail
01:28:43 * wli comes up with a vaguely adequate position evaluator.
01:35:04 * quicksilver evaluates wli's position. Vaguely adequate.
01:41:16 <ikegami--> hello
01:41:49 <ikegami--> here is a recent setting for programming Haskell on Emacs
01:41:52 <ikegami--> http://hpaste.org/4057
01:42:23 <ikegami--> after reading the current discussion about Emacs on the Haskell-cafe
01:43:45 <ikegami--> The above setting enables to delete all trailing white-spaces automatically
01:43:55 <ikegami--> ;-)
01:50:56 <davidL> is withBinaryFile not in ghc-6.6.1?
01:51:14 <Big_Ham> can someone help me with some work please??
01:51:45 <Big_Ham> it's easy for you people, I promise.
01:51:49 <quicksilver> Big_Ham: never ask to ask.
01:51:51 <quicksilver> Big_Ham: just ask.
01:51:57 <Big_Ham> yeah, but I feel bad
01:51:58 <Big_Ham> lol
01:52:03 <hpaste>  Big_Ham pasted "work" at http://hpaste.org/4058
01:52:20 <quicksilver> well, what's wrong with it?
01:52:28 <Big_Ham> it keeps asking for definitions of fraction int and integral int to define value
01:52:41 <quicksilver> that's because you're using /
01:52:43 <quicksilver> isn't for ints
01:52:49 <quicksilver> :t (/)
01:52:52 <Big_Ham> how can I divide then?
01:52:55 <lambdabot> forall a. (Fractional a) => a -> a -> a
01:53:00 <quicksilver> use div
01:53:07 <quicksilver> (value e1) `div` (value e2)
01:53:08 <Big_Ham> aaaa, ok
01:53:17 <quicksilver> div is for integral types
01:53:17 <Big_Ham> told ya it would be a simple one :D
01:53:23 <quicksilver> is for fractional types
01:53:27 <quicksilver> > 8/3
01:53:28 <Big_Ham> so div won't work unless it produces a whole number?
01:53:28 <lambdabot>  2.6666666666666665
01:53:31 <quicksilver> > 8 `div` 3
01:53:32 <lambdabot>  2
01:53:37 <quicksilver> div just rounds down
01:53:50 <Big_Ham> aaa, excellent, thank you Quicksilver, you're a hero
01:54:04 <quicksilver> Big_Ham: by the way (n `mod` 1 /= 0) is superfluous
01:54:21 <quicksilver> Big_Ham: you have defined the type with "Lit Int", so you *know* n is an integer.
01:54:26 <quicksilver> Big_Ham: it can't possibly not be.
01:54:33 <Big_Ham> yeah well I wanted to make sure it was a whole number, but as you say now it's useless
01:54:43 <quicksilver> Big_Ham: the <0 part is needed though
01:54:48 <quicksilver> (assuming you want positive only)
01:54:48 <Big_Ham> that was part of me trying to get round the fractional integral error thing
01:54:52 <quicksilver> ;)
01:55:34 <Big_Ham> now it just wants a definition of Integral....
01:56:17 <Big_Ham> "Instance of integral required for definition of value"
01:56:34 <araujo> morning
01:56:58 <quicksilver> Big_Ham: you aren't reporting the whole error message :)
01:57:11 <quicksilver> Big_Ham: it actually says something like instance of Integral (Maybe Int) required....
01:57:20 <quicksilver> I would imagine
01:57:24 <Big_Ham> yeah, that is exatly what it says
01:57:34 <quicksilver> well your value function doesn't return Ints
01:57:38 <quicksilver> it returns Maybe Ints
01:57:49 <quicksilver> so how can you use (value e1) + (value e2) ?
01:57:55 <quicksilver> + works on numbers, not Maybe numbers
01:58:10 <Big_Ham> so I need to put maybe causes into each one of those?
01:58:29 <Big_Ham> so a maybe into add and a maybe into times?
01:59:41 <doserj> and into Sub, and into Divide ...
01:59:55 <doserj> liftM2 ftw :)
02:00:07 <Big_Ham> I already have them in sub and divide
02:00:31 <wli> divide :: IntVal -> IntVal -> Maybe (IntVal, IntVal)
02:00:51 <quicksilver> Big_Ham: it's not that
02:01:01 <quicksilver> Big_Ham: youre maybe cases in divide are for returning Nothing
02:01:05 <quicksilver> Big_Ham: which is fine...
02:01:18 <quicksilver> Big_Ham: but your problem is with the recursive calls to value
02:01:52 <Big_Ham> why would that be scrweing it up?
02:02:10 <quicksilver> Big_Ham: what should it do with (value e1) + (value e2)
02:02:17 <Big_Ham> add them together
02:02:19 <quicksilver> Big_Ham: if value e1 returns Nothing?
02:02:20 <Big_Ham> that's it
02:02:22 <quicksilver> Nothing isn't a number!
02:02:33 <quicksilver> in fact, (Just 4) isn't a number either
02:02:34 <Big_Ham> then it couldn't add them together
02:02:34 <Big_Ham> hmm
02:02:39 <quicksilver> > (Just 4) + Nothing
02:02:41 <lambdabot>   add an instance declaration for (Num (Maybe t))
02:02:41 <lambdabot>     In the expression: (Jus...
02:02:47 <quicksilver> > (Just 4) + (Just 5)
02:02:47 <lambdabot>   add an instance declaration for (Num (Maybe t))
02:02:47 <lambdabot>     In the expression: (Jus...
02:02:51 <quicksilver> see the problem?
02:03:00 <Big_Ham> yeah I do see what you mean
02:03:15 <quicksilver> fortunately, there is a solution to this, although it might blow your mind slightly
02:03:19 <quicksilver> it's called liftM2
02:03:28 <quicksilver> turns out that 'Maybe' is a Monad
02:03:33 <Big_Ham> lift M2?
02:03:36 <quicksilver> and we can 'lift' arithmetic into the monad
02:03:45 <quicksilver> > liftM2 (+) (Just 4) (Just 5)
02:03:46 <lambdabot>  Just 9
02:03:52 <quicksilver> > liftM2 (+) (Just 4) (Nothing)
02:03:53 <lambdabot>  Nothing
02:04:01 <quicksilver> it will return Nothing if either of the parameters was Nothing
02:04:09 <quicksilver> and it will return Just (a+b) if they were, in fact, both numbers.
02:04:49 <quicksilver> Big_Ham: however, I daresay this is something well beyond what you've been taught yet...
02:04:57 <quicksilver> so it might not be the solution  you'd choose to take
02:05:00 <Big_Ham> yeah it is, and thus we can't use it
02:05:10 <Big_Ham> well I could, but I wouldn't get the marks for it
02:05:20 <quicksilver> failing that you have to use 'case' on (value e1) and (value e2)
02:05:25 <quicksilver> to see if eitehr is Nothing
02:05:35 <quicksilver> it helps that you can case two things at once, actually:
02:05:38 <ttfh> Wheee, I just got a smal program using the Cont monad working :-)
02:05:52 <doserj> case (value e1, value e2) of (Just x, Just y) -> ...
02:05:53 <quicksilver> case (value e1,value e2) of (Nothing,Nothing) -> Nothing
02:06:04 <quicksilver> (Just x,Just y) -> Just (x+y)
02:06:09 <quicksilver> I'll let you think about the other cases yoruself
02:06:13 <quicksilver> (there are two more)
02:06:35 <Big_Ham> and that would go where??
02:06:47 <Big_Ham> a whole new function or into the existing one?
02:07:47 <Big_Ham> and shouldn't the arrow be  an = ?
02:09:00 <quicksilver> Big_Ham: I was just looking at the 'add' case for you, as an example
02:09:11 <Big_Ham> so that would replace the add code then?
02:09:16 <quicksilver> Big_Ham: yeah, the -> in case is a bit like the '=' in a function definition
02:09:23 <Big_Ham> aaa
02:09:24 <quicksilver> some people think it's odd they ar different symbols
02:10:13 <masak> does it ever seem inelegant that liftM, liftM2, liftM3, liftM4 and liftM5 all have to be defined separately?
02:10:19 <masak> even though they are so alike
02:10:39 <masak> same with functions for differently-sized tuples
02:11:48 <Big_Ham> could I just not get away with writing the top definition then put the rest into the Otherwise Nothing area
02:11:49 <Big_Ham> ?
02:11:56 <EvilTerran> masak, they don't necessarily have to be defined seperately
02:12:07 <EvilTerran> likewise for zipWithN
02:12:11 <masak> EvilTerran: oh? that's good news
02:12:17 <EvilTerran> > liftM2 (,) [1..3] [1..3]
02:12:18 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
02:12:26 <EvilTerran> > (,) <$> [1..3] <*> [1..3]
02:12:26 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
02:12:40 <EvilTerran> > zip3 [1,2,3] "abc" [LT ..]
02:12:41 <lambdabot>  [(1,'a',LT),(2,'b',EQ),(3,'c',GT)]
02:13:04 <masak> :t <$>
02:13:05 <lambdabot> parse error on input `<$>'
02:13:13 <masak> :t (<$>)
02:13:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:13:15 <quicksilver> masak: no, I dont' think it's inelegant, because they have different types.
02:13:31 <quicksilver> masak: I wouldn't want things with different types (in particular) number of arguments to look the same
02:13:39 <EvilTerran> > zipList (,,) <$> ZipList [1,2,3] <*> ZipList "abc" <*> ZipList [LT ..]
02:13:39 <lambdabot>   Not in scope: `zipList'
02:13:40 <quicksilver> however, the applicative notation certainly looks nicer
02:14:15 <masak> I think I just understood functors a little bit better
02:14:19 <masak> EvilTerran: thx
02:14:24 <EvilTerran> > getZipList (,,) <$> ZipList [1,2,3] <*> ZipList "abc" <*> ZipList [LT ..]
02:14:24 <lambdabot>  Couldn't match expected type `ZipList a'
02:14:29 <EvilTerran> > getZipList $ (,,) <$> ZipList [1,2,3] <*> ZipList "abc" <*> ZipList [LT ..]
02:14:29 <lambdabot>  [(1,'a',LT),(2,'b',EQ),(3,'c',GT)]
02:14:32 <EvilTerran> tadah!
02:14:39 <EvilTerran> np
02:14:48 <EvilTerran> @src <$>
02:14:48 <lambdabot> f <$> a = fmap f a
02:15:19 <masak> @src <*>
02:15:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:15:33 <EvilTerran> @src Applicative
02:15:33 <lambdabot> class Functor f => Applicative f where
02:15:33 <lambdabot>     pure  :: a -> f a
02:15:33 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
02:15:39 <EvilTerran> gotta define that one yourself ;)
02:15:42 <masak> :)
02:16:25 <EvilTerran> > (,) `liftM` [1..3] `ap` "abc" -- make of this what you will
02:16:25 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:17:09 <davidL> @type hGetBuf -- how can I create a temporary Ptr buf?
02:17:09 <lambdabot> Not in scope: `hGetBuf'
02:17:17 <EvilTerran> "monads" is a subset of "applicative( functor)s" is a subset of functors
02:17:26 <davidL> hGetBuf :: Handle -> Ptr a -> Int -> IO Int
02:17:30 <Big_Ham> is there a way I can stop that stream executing once the condition has failed? So as soon as it falls into minus number it stops evaluating that expression and moves onto the next one??
02:17:59 <wli> I don't understand (<*>)
02:18:02 <quicksilver> Big_Ham: probably, but I'm not really sure what you mean
02:18:08 <quicksilver> Big_Ham: returning nothing should do.
02:18:16 <wli> What's it do?
02:18:31 <EvilTerran> given a monad, you can make it a functor with fmap=liftM, and an applicative with pure=return and <*> = ap
02:18:39 <quicksilver> wli: applies a function (buried in a monad) to a value (buried in a monad)
02:18:42 <EvilTerran> @type (<*>)
02:18:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:18:45 <quicksilver> wli: returning a value (still buried in a monad)
02:18:49 <Big_Ham> it's meant to take a list of ints and a single int and return an expression using the list of ints that make the int if one exists
02:18:53 <quicksilver> wli: except, s/monad/applicative/
02:19:03 <EvilTerran> quicksilver, s/mon- damn.
02:19:07 <quicksilver> wli: but it works for monads too :)
02:19:15 <quicksilver> EvilTerran: I felt it was easier to explain that way for some reason :)
02:19:16 <wli> I don't get ap, so describing (<*>) in terms of ap doesn't help.
02:19:50 <EvilTerran> @src ap
02:19:50 <lambdabot> ap = liftM2 id
02:19:52 <quicksilver> wli: do you get do { av <- a; bv <- c; cv <- c; return (f av bv cv) }
02:20:04 <roconnor> what's that command to get a xwindow that will show all your xevents?
02:20:08 <EvilTerran> ap mf mx = do f <- mf; x <- mx; f x
02:20:17 <wli> quicksilver: liftM3?
02:20:22 <doserj> roconnor: xev?
02:20:37 <roconnor> doserj++
02:22:23 <quicksilver> wli: yes
02:22:28 <quicksilver> wli: you can write that as
02:22:56 <wli> EvilTerran: That doesn't tell me when to use it or provide other useful intuition.
02:23:11 <quicksilver> wli: f <$> av <*> bv <*> cv
02:23:18 <EvilTerran> it takes a lifted function and a lifted value, and gives back a lifted result
02:23:32 <quicksilver> wli: it's just "another way to write" lift M3
02:23:39 <quicksilver> wli: but it's more applicative in style
02:24:00 <EvilTerran> {- lifted function -} [(+1),(*2)] `ap` {- lifted value -} [2,3]
02:24:02 <EvilTerran> > {- lifted function -} [(+1),(*2)] `ap` {- lifted value -} [2,3]
02:24:09 <lambdabot>  [3,4,4,6]
02:25:18 <wli> quicksilver: f <$> a <*> b <*> c?
02:25:35 <wli> quicksilver: How does that associate?
02:25:42 <EvilTerran> left
02:26:04 <EvilTerran> ?type (\f a b c -> f <$> a <*> b <*> c)
02:26:05 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
02:26:12 <wli> f <$> (a <*> (b <*> c)) ?
02:26:20 <doserj> the other left :)
02:26:35 <EvilTerran> ?type (\f a b c -> f <$> (a <*> (b <*> c)))
02:26:36 <lambdabot> forall a b (f :: * -> *) a1 a2. (Applicative f) => (a -> b) -> f (a1 -> a) -> f (a2 -> a1) -> f a2 -> f b
02:26:51 <EvilTerran> ?type (\f a b c -> ((f <$> a) <*> b) <*> c)
02:26:51 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
02:26:52 <wli> ((f <$> a) <*> b) <*> c?
02:26:54 <quicksilver> yes
02:27:24 <quicksilver> it becomes clear if you work through the types
02:27:30 <quicksilver> and I'm going to pretend it's a monad
02:27:37 <quicksilver> f :: a -> b -> c -> m d
02:27:45 <quicksilver> hmm
02:27:48 <quicksilver> poor choice of names :)
02:27:56 <quicksilver> f :: s -> t -> r -> m u
02:28:20 <quicksilver> argh
02:28:25 <quicksilver> and now I'm just talking rubbish
02:28:30 <quicksilver> 3rd time lucky?
02:28:34 <quicksilver> f :: s -> t -> r ->  u
02:28:43 <wli> f <$> a when a is m s then gives t -> r -> m u?
02:28:48 <quicksilver> f <$> a :: m (t -> r -> u)
02:28:53 <quicksilver> no
02:28:58 <quicksilver> m ( t -> r -> u )
02:29:03 <quicksilver> then <*> is application 'under the m'
02:29:05 <quicksilver> so
02:29:17 <quicksilver> f <$> a <*> b :: m ( r -> u )
02:29:30 <quicksilver> f <$> a <*> b <*> c :: m u
02:31:58 <quicksilver> wli: any clearer now?
02:32:06 <wli> quicksilver: yeah, thanks
02:33:43 <quicksilver> wli: it's actually less pleasant when you start with a 'Kleisli' f instead of a pure one
02:33:51 <quicksilver> wli: then you end up in m (m u)
02:33:55 <quicksilver> wli: and you need a 'join'
02:34:57 <wli> quicksilver: Yeah, that could get clumsy.
02:39:43 <hpaste>  thomas pasted "Is there any function that makes the following?.." at http://hpaste.org/4059
02:41:19 <EvilTerran> thomas: not in the standard libraries, no
02:41:24 <quicksilver> who is thomas?
02:41:33 <quicksilver> hullo thomas?
02:41:38 <EvilTerran> thomas: you might be able to use hsPlugins to get the effect you want
02:41:40 <quicksilver> you are looking for an interpreter
02:41:48 <quicksilver> haskell doesn't have built in interpretation.
02:41:57 * quicksilver wonders if thomas is in Big_Ham's class at UU :)
02:42:11 <quicksilver> looks like an attempt at a similar exercise
02:42:24 <EvilTerran> hm?
02:42:30 * EvilTerran scrolls up
02:42:38 <quicksilver> EvilTerran: well Big_Ham is writing a parser/interpreter for numeric expressions
02:42:50 <quicksilver> EvilTerran: actually, not parser. Evaluator and pretty-printer.
02:43:00 <quicksilver> I daresay they'll get onto parsing in a week or two :)
02:52:31 <davidL> how do I pass the -lpng flag to the linker from hsc2hs?
02:55:30 <davidL> /usr/bin/ld: cannot find -lpng :-(
02:56:28 <dcoutts> davidL: --cflag=  or use Cabal
02:56:47 <dcoutts> Cabal knows how to tell hsc2hs about c libs and c/cpp flags
02:59:23 <davidL> well I tried: $ hsc2hs -I/usr/local/include/libpng -L -lpng hpng.hs
02:59:32 <davidL> /usr/bin/ld: cannot find -lpng
03:04:20 <davidL> I guess I'll use cabal :-\
03:06:09 <quicksilver> davidL: that's not a failure to pass -lpng
03:06:16 <quicksilver> davidL: clearly, -lpng is being passed
03:06:19 <quicksilver> hence the error
03:06:34 <quicksilver> davidL: that means it can't find libpng.so (or whatever) in the directories it's been configured to look in
03:06:59 <davidL> does ld check /usr/local/lib by default?
03:08:25 <pejo> davidL, not usually.
03:09:29 <dcoutts> davidL: you didn't read what I said :-)
03:09:35 <dcoutts> davidL: --cflag=
03:09:56 <dcoutts> as in,  hsc2hs -I/usr/local/include/libpng --cflag=-lpng hpng.hs
03:10:24 <davidL> yeah that part worked ;)
03:10:51 <dcoutts> ok good good :-)
03:10:53 <davidL> then I had to do: ghc -L/usr/local/lib -lpng hpng_out.hs
03:11:44 <dcoutts> if you do this a lot, just get /usr/local/lib and /usr/local/include on the appropriate global paths
03:13:12 <davidL> I'll use cabal
03:17:04 <davidL> thanks by the way
03:25:50 <quicksilver> most people consider it appropriate for /usr/local/lib to be in the default link path
03:26:03 <quicksilver> certainly it is on the unix systems which I admin
03:28:52 <davidL> how do you list the link paths?
03:29:58 <yaxu> my code has a lot of "maybe Nothing f x" in it, I get the feeling that this means I am not using monads properly
03:30:33 <yaxu> davidL: cat /etc/ld.so.conf
03:30:58 <davidL> cat: /etc/ld.so.conf: No such file or directory
03:31:18 <yaxu> is there an /etc/ld.so.conf.d ?
03:31:24 <davidL> nope
03:31:33 <quicksilver> :t \f x -> maybe Nothing f x
03:31:34 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
03:31:40 <davidL> I am on openbsd
03:32:19 <quicksilver> :t \f x -> x >>= f
03:32:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
03:32:33 <quicksilver> yaxu: "maybe Nothing f x" is "x >>= f"
03:33:41 <yaxu> interesting
03:33:52 <yaxu> and that works within the IO monad?
03:34:01 <quicksilver> yaxu: no, that works within the Maybe monad
03:34:08 <yaxu> gotcha
03:34:22 <quicksilver> well, of course "x >>= f" works in any monad :)
03:34:31 <quicksilver> but, assuming you have the same types of x and f that you had before
03:34:36 <quicksilver> then it's forced to be the maybe monad
03:34:45 <quicksilver> (because your "x" was "x :: Maybe a")
03:36:55 <pejo> davidL, /etc/ld.so.conf isn't used on all systems. Seems likely that openbsd doesn't use it.
03:37:08 <yaxu> thanks quicksilver, i'll experiment
03:37:37 <roconnor> @pl \x f x -> f x x
03:37:37 <lambdabot> const join
03:37:55 <roconnor> @pl \x y z -> f z x y
03:37:55 <lambdabot> flip . flip f
03:38:10 <roconnor> spitters: compose flip (flip f)
03:38:27 <yaxu> davidL: look for shlib_dirs in /etc/rc.conf
03:39:10 <davidL> shlib_dirs=       # extra directories for ldconfig, separated
03:39:19 <davidL> neat
03:40:13 <davidL> oh I can do ldconfig -r to see the search directories
03:40:50 <yaxu> davidL: not in the gnu version it seems
03:41:45 <davidL> thanks yaxu
03:58:54 <hpaste>  jedbrown pasted "Alternatives and FFI" at http://hpaste.org/4060
04:06:39 <yaxu> :t comparing
04:06:41 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:07:10 <_ry> when i do "a <- [1,2,3,4]" what type does a have?
04:07:24 <int-e> Num a => a
04:07:38 <int-e> @type 1
04:07:38 <lambdabot> forall t. (Num t) => t
04:08:09 <yaxu> @hoogle comparing
04:08:09 <lambdabot> No matches found
04:08:43 <jedbrown> yaxu: http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Ord.html
04:09:06 <yaxu> jedbrown: aha, thanks!
04:15:31 <jedbrown> Anyone have suggestions regarding best practices for alternatives and FFI? (see paste)
04:27:58 <Saizan> jedbrown: {#fun printRank  as ^{rankToCInt `Rank'}->`IO ()'#} <-- with c2hs
04:31:41 <jedbrown> Saizan: Cool, thanks.  I've just been using hsc2hs which doesn't provide that, but it is a compelling feature.
04:33:48 <hpaste>  Big_Ham pasted "(no title)" at http://hpaste.org/4061
04:34:06 <Big_Ham> Can anyone tell me where my case syntax is wrong please?
04:34:21 <Big_Ham> keeps the error:
04:34:30 <resiak> you need to indent the cases past "case"
04:35:40 <Big_Ham> that hasn't made a difference
04:35:52 <mauke> resiak: I don't think so
04:35:55 <Big_Ham> still get: Type error in case pattern
04:36:01 <resiak> hrm
04:36:08 <mauke> what's the exact error message?
04:36:15 <doserj> you want "case (value e1, value e2) of ...
04:36:40 <Big_Ham> Term: (just x, just y) Type: (Maybe a, Maybe b) Does Not Match: Maybe Int
04:36:45 <mauke> yeah, unless you have a weird Num instances
04:37:08 <mauke> Big_Ham: that's caused by the +
04:37:14 <Big_Ham> but if they are both ints then they need to be added....
04:37:19 <mauke> the other +
04:37:58 <Big_Ham> which one?
04:38:06 <Big_Ham> the case((value e1) + .... one?
04:38:09 <mauke> yes
04:38:13 <Big_Ham> yeah I have
04:38:15 <Big_Ham> now it's
04:38:22 <Big_Ham> ((value e1), (value e2))
04:38:32 <Big_Ham> I get a different type error now
04:38:40 <mauke> for x + y?
04:39:01 <Big_Ham> Term : Nothing Type Maybe a DOes not match Int
04:39:05 <doserj> (Just x , Just y) -> Just (x + y)
04:39:10 <mauke> right
04:39:37 <Big_Ham> aaaa
04:39:43 <mauke> x + y has type Int but Nothing has type Maybe Int. you need to turn x + y into a Maybe Int
04:40:01 <Big_Ham> now I get the error I was using the case syntax to get around in the first place
04:40:13 <mauke> heh
04:40:22 <Big_Ham> lol let me try and sort this out, grr :@
04:40:25 <mauke> what is it?
04:40:40 <Big_Ham> well I haven't changed the rest of the function to the case syntax, so it could be that
04:40:47 <Big_Ham> as you can see in the paste
04:41:03 <Big_Ham> so I'm going to change the lot and then see hat happens
04:41:18 <mauke> (value e1) - (value e2) is a problem
04:41:24 <Big_Ham> I'm getting Instance of Integral (maybe Int) required for definition of value
04:41:26 <mauke> value returns a Maybe Int, not an Int
04:41:30 <mauke> yes
04:41:47 <doserj> that is in the Divide case
04:42:02 <mauke> you need to handle the case where value returns Nothing
04:42:17 <Big_Ham> precisely, that's what I'm going to do now
04:43:54 <_ry> how can i prepend "a" to each string in a list of strings?
04:44:03 <Big_Ham> map
04:44:05 <Big_Ham> ?
04:44:42 <_ry> > map ("a" ++ ) ["hello", "world"
04:44:42 <lambdabot>  Parse error at end of input
04:44:47 <_ry> > map ("a" ++ ) ["hello", "world"]
04:44:48 <opqdonut> > map (a:) ["lol","bur"]
04:44:49 <lambdabot>   Not in scope: `a'
04:44:49 <lambdabot>  ["ahello","aworld"]
04:44:57 <opqdonut> > map ('a':) ["lol","bur"] --woops
04:44:57 <lambdabot>  ["alol","abur"]
04:46:43 <_ry> single quotes and double quotes are different? (is it like in C?)
04:47:10 <opqdonut> yeah, like c
04:47:18 <Big_Ham> how can I keep the error checking in the value function whilst using the case syntax?
04:47:24 <Big_Ham> is there a way to include if's in it?
04:47:29 <opqdonut> > ['a','b','c'] == "abc"
04:47:31 <lambdabot>  True
04:48:06 <Big_Ham> so (Just x, Just y) -> Just(x-y) if x-y > 0?
04:48:28 <mauke> Big_Ham: (Just x, Just y) | x - y > 0 -> Just (x - y)
04:48:34 <quicksilver> Big_Ham: you can put ifs anywhere
04:48:37 <resiak> and presumably | otherwise -> Nothing
04:48:37 <mauke> you use "| condition -> ..."
04:48:47 <Big_Ham> aaa, excellent, thank you
04:48:50 <quicksilver> (Just x,Just y) -> if x-y >0 then Just (x-y) else Nothing
04:49:01 <mauke> or that
04:49:03 <quicksilver> Big_Ham: I actually think the "guard" (|) looks neater
04:49:12 <quicksilver> Big_Ham: but wanted you to see the 'if' way as well
04:49:27 <Big_Ham> thanks quicksilver
04:59:11 <hpaste>  Big_Ham pasted "(no title)" at http://hpaste.org/4062
04:59:45 <Big_Ham> I'm getting a type error in case expression Term: Nothing Type: maybe A , Does Not Match : Int
04:59:53 <Big_Ham> it's only doing it in the last clause though :S
05:00:08 <Big_Ham> in the divide clause
05:00:16 <quicksilver> you're missing  Just
05:00:22 <Big_Ham> o cock
05:00:24 <Big_Ham> :D
05:00:41 <Big_Ham> yay
05:00:44 <Big_Ham> compiled
05:00:58 <Big_Ham> quicksilver > The One
05:02:02 <Big_Ham> thanks a lot though fella
05:03:05 <doserj> Big_Ham: you could also use "_ -> Nothing" to shorten the function a bit :)
05:03:28 <Big_Ham> that would mean another other case right?
05:03:43 <doserj> no. in your existing cases.
05:03:59 <Big_Ham> *any other
05:04:23 <Big_Ham> so if it was anything except (just x, Just y) it would = Nothing
05:04:43 <doserj> yes
05:05:44 <Big_Ham> aaaa, ok, thanks a million doser
05:06:03 <Big_Ham> I''m off anyway, so hungry, see you guys later
05:06:25 <faxathisia> hello
05:08:24 <quicksilver> doserj: I did also show him that liftM2 did exactly what he wanted
05:08:32 <quicksilver> doserj: but he thought his professor probably wouldn't let him use that :)
05:08:46 <doserj> I could understand that :)
05:15:50 <geocalc> @where base
05:15:50 <lambdabot> http://darcs.haskell.org/packages/base/
05:19:43 <faxathisia> @keal
05:19:43 <lambdabot> the [nsa] even make light green both ways once
05:22:01 <_ry> I have a list of type [(A,B)] and I want to use map and apply each tuple in the list to two function printA and printB
05:22:09 <_ry> how can i do that?
05:22:09 <geocalc> @let psum x = (x * (x+1)) `div` 2
05:22:12 <lambdabot> Defined.
05:22:26 <mauke> _ry: then do what with the results?
05:22:39 <_ry> mauke: return IO ()
05:23:08 <_ry> printA :: A -> IO () ,  printB :: B -> IO ()
05:23:20 <mauke> mapM_ (\(x, y) -> do printA x; printB y) list
05:23:23 <roconnor> @pl \x y z -> f z x y
05:23:23 <lambdabot> flip . flip f
05:23:36 <_ry> ah, okay.. duh
05:24:35 <idnar> @undo do printA x; printB y
05:24:35 <lambdabot> printA x >> printB y
05:24:42 <idnar> @pl \(x, y) -> printA x >> printB y
05:24:42 <lambdabot> uncurry ((. printB) . (>>) . printA)
05:25:07 <roconnor> @pl \x y z -> f y z x
05:25:07 <lambdabot> flip (flip . f)
05:25:32 <Saizan> ?type uncurry (>>) . (printA *** printB)
05:25:34 <lambdabot> Not in scope: `printA'
05:25:34 <lambdabot> Not in scope: `printB'
05:25:41 <Tobsan> @scr unsafePerformIO
05:25:41 <lambdabot> Maybe you meant: arr rc src
05:25:43 <Saizan> ?type uncurry (>>) . (?printA *** ?printB)
05:25:43 <lambdabot> forall (m :: * -> *) a b b1 b'. (Monad m, ?printA::b1 -> m a, ?printB::b' -> m b) => (b1, b') -> m b
05:25:51 <Tobsan> @src unsafePerformIO
05:25:51 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
05:25:55 <Tobsan> oh snap
05:26:11 <quicksilver> Saizan: Yeah, I was thinking of something like that
05:26:19 <quicksilver> Saizan: but it's certainly going to look longer :)
05:28:24 <Saizan> quicksilver: sometimes i wish we had a naked Kliesli IO
05:28:58 <quicksilver> Saizan: you could always special-case the combinators
05:29:04 <quicksilver> Saizan: to avoid the boring wrap/unwrap
05:29:28 <quicksilver> like >=> is, in fact
05:29:51 <Saizan> well, not that much :)
05:30:14 <geocalc> @let lpsum x 0 = 0 ; lpsum x 1 = psum x ; lpsum x _ = lpsum (psum x) (y-1)
05:30:17 <faxathisia> Where is >=> documented?
05:30:21 <lambdabot> <local>:6:65: Not in scope: `y'
05:30:24 <quicksilver> Control.Monad, I think
05:30:36 <faxathisia> @docs Control.Monad
05:30:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
05:30:42 <faxathisia> damn
05:31:09 <EvilRanter> http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Monad.html#v%3A%3E%3D%3E
05:31:10 <lambdabot> http://tinyurl.com/34ev5c
05:31:35 <faxathisia> ohh
05:31:42 <faxathisia> so why is /base/ removed?
05:31:59 <EvilRanter> meh. 'cos they wanted to add a version number?
05:32:01 <faxathisia> @src
05:32:01 <lambdabot> src <id>. Display the implementation of a standard function
05:32:07 <faxathisia> lambdabot: where is your code
05:32:14 <EvilRanter> @where lambdabot
05:32:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:32:20 <faxathisia> thanks agian
05:32:32 <geocalc> false
05:32:59 <quicksilver> faxathisia: I think there is a plan to put symlinks in for 'latest'
05:33:10 <quicksilver> faxathisia: but they wanted to be able to have docs of different versions installed at once
05:33:13 <quicksilver> which makes good sense...
05:33:24 <geocalc> it is at code.haskell.org
05:34:44 <faxathisia> http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Dummy/DocAssocs.hs
05:34:46 <lambdabot> http://tinyurl.com/2nly5h
05:34:47 <faxathisia> base = P.unsafePackAddress 4 "base"#
05:34:49 <faxathisia> change to
05:34:53 <faxathisia> base = P.unsafePackAddress 4 "base-3.0.0.0"#
05:35:02 <faxathisia> maybe?
05:35:20 <faxathisia> and revert when the symlinks are around
05:39:06 <faxathisia> is it a bad idea
05:39:51 <quicksilver> they're not all in base, though
05:39:56 <quicksilver> @docs Control.Arrow
05:39:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
05:40:03 <quicksilver> ^^ this is now in arrows-1.0.0.0
05:40:04 <quicksilver> or something
05:40:08 <faxathisia> oh my god
05:40:24 <quicksilver> so really, @docs needs to be fixed to understand the package system :)
05:41:39 <faxathisia> @docs undefined
05:41:39 <lambdabot> undefined not available
05:41:55 <faxathisia> @docs reverse
05:41:55 <lambdabot> reverse not available
05:42:12 <faxathisia> ok it seems that @docs should  just click on one of these http://www.haskell.org/ghc/docs/latest/html/libraries/
05:42:15 <faxathisia> is that right?
05:42:16 <quicksilver> @docs is for modules
05:42:16 <lambdabot> is for modules not available
05:42:22 <quicksilver> ;)
05:42:24 <MyCatVerbs> @docs System.Random
05:42:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
05:42:25 <quicksilver> not for functions
05:42:51 <quicksilver> but yes, one thing would be that @docs could read the haddock output
05:43:04 <MyCatVerbs> That's probably not the best place to link to. The -latest library docs are often partially broken due to work-in-progress status.
05:43:31 <quicksilver> even if not broken, they might contain new functions which don't exist yet on the user's installation
05:44:01 <MyCatVerbs> http://www.haskell.org/ghc/docs/6.6/html/libraries/ or http://www.haskell.org/ghc/docs/6.8.1/html/libraries/ are much better options, usually.
05:44:14 <quicksilver> in fact, @docs could have options for both
05:44:17 <faxathisia> ok
05:44:21 <quicksilver> it could default to 6.8.1
05:44:25 <quicksilver> but have a -version option
05:44:27 <quicksilver> or something
05:45:22 <MyCatVerbs> Better yet, we should make Firefox report the output of ghc-pkg somewhere in the HTTP headers. ;)
05:45:53 * MyCatVerbs wonders what it'll take to get his university to upgrade to 6.8.1. >_>
05:52:06 <osfameron> mauke: that perl sub avg should work - I'm sure I tried it
05:52:26 <osfameron> mauke: I probably didn't specify:   use List::Util qw(sum);  ?
05:52:55 <mauke> $ perl -MList::Util=sum -wle 'sub avg { sum @_ / @_ } print avg 1, 2, 3'
05:52:56 <mauke> 1
05:52:59 <faxathisia> Here are the URLs
05:53:05 <faxathisia> http://rafb.net/p/quTlFx85.txt
05:53:10 <faxathisia> based on package
05:54:11 <osfameron> mauke: ooo!
05:54:19 <mauke> osfameron: in short, precedence
05:54:21 <faxathisia> extracted from http://www.haskell.org/ghc/docs/6.8.1/html/libraries/ with http://rafb.net/p/YOwanv10.txt
05:54:35 <faxathisia> maybe that helps ? :|
05:54:47 <osfameron> mauke: yeah (sum @_) / @_
05:54:59 <osfameron> mauke: either I just didn't test it, or copied it badly :-(
05:55:13 * osfameron checks his rough notes
05:55:21 <osfameron> thanks for the catch
05:55:58 <EvilRanter> hm... trying to build hat here
05:56:26 <EvilRanter> "Failed to load interface for `Prelude': Perhaps you haven't installed the profiling libraries for package base?"
05:57:01 <osfameron> pity sum doesn't work implicitly on @_ or I could do { (sum) / @_ } -- almost looks like haskell currying... though it isn't
05:57:50 <mauke> btw, sum is semi-broken
05:57:55 <EvilRanter> where would I get these profiling libraries from? google is not being forthcoming.
05:57:57 <mauke> it doesn't return 0 for empty lists
05:58:44 <Saizan> EvilRanter: did you compile ghc yourself?
05:58:51 <EvilRanter> no
05:58:57 <malcolmw> EvilRanter: the error sounds strange for an attempt to install hat - not what I would expect at all
05:59:14 <faxathisia> > sum []
05:59:20 <lambdabot>  0
05:59:26 <EvilRanter> malcolmw, yeah, i thought it was a bit weird
05:59:32 <faxathisia> no I think sum [] = 0 is confusing
05:59:32 <mauke> sum as in &List::Util::sum
05:59:40 <faxathisia> mauke: perl errors?
05:59:42 <faxathisia> or what
05:59:43 <EvilRanter> I figured it needed profiling hooks to do some of its magic
05:59:53 <EvilRanter> faxathisia: sum [] = 0 makes perfect sense!
06:00:00 <osfameron> mauke: oh?  Well I know L::U's reduce isn't quite a proper fold as it uses the first element as the init
06:00:10 <mauke> osfameron: that's ok, actually
06:00:13 <faxathisia> > product []
06:00:13 <lambdabot>  1
06:00:13 <integral> fold1
06:00:17 <mauke> reduce is a perfectly fine foldl
06:00:48 <mauke> it's just that sum xs is implemented as foldl (+) (head xs) (tail xs), more or less
06:00:56 <mauke> so it returns undef for no arguments
06:00:59 <EvilRanter> sum (x:xs) = x + sum xs, so sum [x] = x + sum [], and obviously sum [x] = x, so sum [] = 0
06:01:06 <faxathisia> I think undef is fine
06:01:12 <faxathisia> seems quite reasonable
06:01:12 <mauke> faxathisia: it isn't
06:01:17 <quicksilver> faxathisia: then you're wrong :)
06:01:27 <quicksilver> faxathisia: sum :: [Int] -> Int is a total function
06:01:28 <EvilRanter> it's not undefined, though. it has one mathematically defined value
06:01:32 <malcolmw> EvilRanter: no, there is no profiling magic in Hat that I can remember (as one of the authors!)
06:01:37 <quicksilver> faxathisia: no way it should return undefined :)
06:01:39 <faxathisia> perl isn't a total functional language
06:01:58 <quicksilver> that doesn't give it license to deviate un-necessarily
06:02:06 <quicksilver> the sum of an empty set is well understood
06:02:17 <EvilRanter> malcolmw: huh, weird. I'm pretty sure i didn't try to make a profiling build of hat, say...
06:02:54 <faxathisia> it says on wikipedia "the sum of the elements of the empty set is zero, but the product of the elements of the empty set is one"
06:03:00 <mauke> yes
06:03:10 <EvilRanter> but, for some reason, the offending invocation of ghc has the -prof flag
06:03:15 <mauke> similarly, and [] is True while or [] is False
06:04:04 * osfameron used to wonder why you couldn't just map each op to its default init argument somewhere
06:04:19 <osfameron> (+)=>0, (*)=>1, and=>True  etc.
06:04:20 <faxathisia> there is no reason perl should follow this convention though
06:04:29 <faxathisia> It's not mathematics ..
06:04:33 <osfameron> and then just leave out the init to fold
06:04:43 <EvilRanter> faxathisia: similar reasoning as above: product [x] = x, product (x:[]) = x * product [], and x = x * product [] => product [] = 1
06:04:55 <EvilRanter> faxathisia: there's even less reason for it not to, though
06:05:00 <faxathisia> It's a monoid right
06:05:10 <faxathisia> (+, 0) (*, 1) (and, True) (or, False)
06:05:12 <EvilRanter> @instances Monoid
06:05:13 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
06:05:16 <EvilRanter> yes
06:06:04 <EvilRanter> it's introducing an unnecessary special case, if you break the monoid-ness.
06:06:44 <faxathisia> in any case it's not a mathematically rigerously defined language, it's built from another point of view
06:06:48 <_ry> suppose i have a large list of numbers. i want to create a histogram list of these where i would have (number, count) pairs. any idea how to do this?
06:07:13 <EvilRanter> still an unnecessary special case
06:07:29 <mauke> _ry: you could fold it down to a Map
06:07:47 <faxathisia> _ry: probably sort them group them and map across making a tuple of the first element and the length
06:07:51 <EvilRanter> > group $ sort "abracadabra"
06:07:54 <lambdabot>  ["aaaaa","bb","c","d","rr"]
06:08:14 <mauke> > map (ap (,) length) . group . sort $ "abracadabra"
06:08:14 <lambdabot>  [("aaaaa",5),("bb",2),("c",1),("d",1),("rr",2)]
06:08:27 <EvilRanter> > map (length &&& head) . group . sort $ "abracadabra"
06:08:27 <lambdabot>  [(5,'a'),(2,'b'),(1,'c'),(1,'d'),(2,'r')]
06:08:28 <matthew-_> add in first head ?
06:08:37 <matthew-_> yeah, that's the one :)
06:09:05 <EvilRanter> that's a relatively common snippet on here, iirc
06:09:47 <doserj> yes, both with and without the sort :)
06:10:53 <_ry> @type (&&&)
06:10:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:11:08 <mauke> it makes more sense if you substitute (->) for a
06:11:20 <faxathisia> @pl (\x -> (length x, head x))
06:11:20 <lambdabot> liftM2 (,) length head
06:11:41 <faxathisia> :t (liftM2 (,))
06:11:42 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
06:11:44 <EvilRanter> Arrow (~>) => (b ~> c) -> (b ~> d) -> (b ~> (c,d))
06:12:04 <_ry> (,) .. holy crap
06:12:14 <faxathisia> :t (,,,,,,,,,,,,)
06:12:15 <lambdabot> forall a b c d e f g h i j k l m. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
06:12:29 <_ry> that's insane!
06:12:33 <faxathisia> O_o
06:12:36 <faxathisia> :t (,,)
06:12:36 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
06:12:42 <EvilRanter> :t flip flip flip flip flip
06:12:42 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
06:12:43 <faxathisia> lambdabot: You forget a
06:12:45 <_ry> :t [,,]
06:12:45 <lambdabot> parse error on input `,'
06:13:01 <faxathisia> @pl (\x,y,z->[x,y,z])
06:13:01 <lambdabot> (line 1, column 6):
06:13:01 <lambdabot> unexpected ","
06:13:01 <lambdabot> expecting letter or digit, operator, pattern or "->"
06:13:01 <lambdabot> ambiguous use of a non associative operator
06:13:05 <EvilRanter> _ry, sadly not, although it would be quite handy on occasion
06:13:08 <faxathisia> @pl (\x y z->[x,y,z])
06:13:08 <lambdabot> (. ((. return) . (:))) . (.) . (:)
06:13:48 <EvilRanter> you could do something dodgey with a typeclass
06:13:50 <faxathisia> @pl (\(x,y,z)->[x,y,z])
06:13:50 <lambdabot> (line 1, column 7):
06:13:50 <lambdabot> unexpected ","
06:13:50 <lambdabot> expecting letter or digit, operator or ")"
06:13:50 <lambdabot> ambiguous use of a non associative operator
06:14:00 <faxathisia> what
06:14:00 <EvilRanter> MPTCs, probably fundeps, too
06:14:07 <mauke> faxathisia: no tuples
06:14:19 <mauke> fox only ... final destination
06:22:25 <_ry> in that histogram example, is it easier somehow if i use an array?
06:22:31 <_ry> (i need to for my assignment, not sure why)
06:22:47 <EvilRanter> harder, i'd say
06:22:58 <faxathisia> turn the array into a list using elems
06:23:33 <Saizan> mutable or pure? for mutable you might want to sort in place
06:23:58 <_ry> other way around, i should output an array where the indicies are the objects i'm counting and the values are the counts.
06:24:24 <matthew-_> so 'a' is an index to an array?
06:24:40 <_ry> matthew-_: actually i'm counting integers
06:24:47 <_ry> (between 0 and 14)
06:25:05 <matthew-_> right! that might be doable then!
06:25:09 <faxathisia> :t for
06:25:11 <lambdabot> Not in scope: `for'
06:25:35 <faxathisia> well you could just map (\x -> count how many times x is in the array) [0..14]
06:26:12 <matthew-_> yeah, it'd be a mapM_ wouldn't it?
06:26:16 <Saizan> oh, then you've just to increment the field everytime you encounter the corresponding value in the list
06:26:43 <doserj> http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.1.0.0/Data-Array-IArray.html#v%3AaccumArray
06:26:45 <lambdabot> http://tinyurl.com/2mgdvh
06:33:11 <faxathisia> I like this __ = __
06:35:24 <EvilRanter> @paste
06:35:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:36:28 <hpaste>  EvilRanter pasted "from hat-2.05/src/hattools/Makefile" at http://hpaste.org/4063
06:37:13 <EvilRanter> malcolmw: that's the only mention of '-prof' i've found in the build files. any thoughts?
06:37:25 <malcolmw> EvilRanter: oops, looks like that got committed accidentally
06:37:45 <EvilRanter> oh :S
06:37:48 <malcolmw> I think it should be safe to remove -prof -auto-all and continue
06:38:01 <quicksilver> faxathisia: if perl isn't a "mathematically rigorous language" then I wonder why 2 + 2 = 4
06:38:09 <quicksilver> faxathisia: we might as well give that up too :P
06:38:34 <quicksilver> faxathisia: I think when there is an obvious mathematical interpretation of somethign which fits well into a language there is no reason to avoid it.
06:38:35 <malcolmw> EvilRanter: are you building with ghc 6.6.x?  If using ghc-6.8.1 then you should also change the comparison with 606 to 608
06:38:42 <EvilRanter> 6.6.1
06:38:47 <EvilRanter> seems to be working
06:38:57 <EvilRanter> although there's a terrifying array of warnings whizzing by
06:39:19 <malcolmw> oh, there are indeed a few of those, yes
06:39:28 <EvilRanter> an awful lot of "warning: cast to pointer from integer of different size"
06:39:55 <malcolmw> EvilRanter: hmm, do you have a 64-bit machine by any chance?
06:40:33 <EvilRanter> I think so. well, the comlab do, anyway; it's their computer
06:40:35 <faxathisia> quicksilver: perl -e 'print 99**99**99' -> inf
06:40:56 <malcolmw> EvilRanter: Hat may not be 64-bit clean.  Adding a -m32 to the C compiler options might turn out to be needed, if you get crashes at runtime in the end
06:41:07 <EvilRanter> okay, thanks. i'll try that.
06:41:08 <quicksilver> faxathisia: "which fits well into the language"
06:41:14 <quicksilver> faxathisia: that was *exactly* my point
06:41:24 <quicksilver> faxathisia: perl is built around fixed-length integers, so you expect overflows
06:41:28 <EvilRanter> faxathisia: the point still stands that adding unnecessary inconsistencies is still a bad tactic
06:41:34 <quicksilver> faxathisia: so it's understandable that 99**99**99 doesn't work.
06:41:36 <faxathisia> there is no inconsistencies
06:41:43 <EvilRanter> quicksilver: well, i thought it used doubles everywhere
06:41:44 <quicksilver> faxathisia: however there is NO REASON for sum [] to be undef
06:41:49 <faxathisia> the empty list doesn't have a sum, product..
06:41:53 <quicksilver> faxathisia: but it does
06:41:54 <EvilRanter> faxathisia: YES THEY DO
06:41:57 <quicksilver> the empty list has a sum of 0
06:42:01 <faxathisia> in haskel they do
06:42:04 <quicksilver> no, they do
06:42:04 <faxathisia> sets in mathematics do
06:42:04 <quicksilver> in life
06:42:05 <EvilRanter> in MATHS they do
06:42:06 <quicksilver> in maths
06:42:10 <quicksilver> in the real world
06:42:11 <faxathisia> perl is not haskell or mathematics
06:42:15 <quicksilver> there is no room for ambiguity or doubt.
06:42:23 <EvilRanter> *everything* is mathematics
06:42:25 <quicksilver> you might as well argue that empty lists don't have a length.
06:42:44 <doserj> faxathisia: if you have no notes and no coins in you wallet, how much money do you have?
06:43:25 <faxathisia> doserj: I've got 0 money
06:43:29 <EvilRanter> the sum of nothing is, under all circumstances, zero. that's as much of a fundamental rule of maths as 1+1=2
06:43:39 <quicksilver> faxathisia: exactly. And that is the sum of an empty list.
06:43:46 <faxathisia> not necessarily
06:43:51 <quicksilver> faxathisia: because your wallet contained an empty list of coins and notes.
06:43:58 <Cale> Sets and lists don't exist outside our mathematical formalisms, so it's not an empirical question what the sum or product of the empty list is. However, there's still typically only one really sensible way to define it.
06:44:00 <EvilRanter> indeed, sum [] = 0 follows directly from 0 being the identity of (+)
06:44:11 <faxathisia> I got Nothing -> 0, or Just (5 pound note) -> 5
06:44:19 <faxathisia> There are many ways to consider it..
06:44:29 <quicksilver> faxathisia: there is only one sensible answer for "sum []"
06:44:34 <faxathisia> EvilRanter: That's very clear
06:44:34 <quicksilver> and there is no reason to dislike this answer
06:44:45 <quicksilver> there are two reasons to go for undef:
06:44:51 <quicksilver> (1) multiple possible answers don't know which to choose
06:44:55 <quicksilver> (2) no sensible answer
06:45:00 <quicksilver> neither of these apply here
06:45:10 <quicksilver> there is one, and only one, sensible answer for sum []
06:45:18 <osfameron> any aggregate operation f on an empty list produces the fixed point of f ?
06:45:18 <Cale> Well, you might want sum [] to be 57.
06:45:22 <faxathisia> if you define sum as the sum of the elements of a list, when a list has no elements there is no defined sum
06:45:33 <EvilRanter> no.
06:45:38 <quicksilver> Cale: but that's not sensible :) for some obvious sense of the word 'sensible'
06:45:39 <Cale> But then it's just not the usual notion of summation.
06:45:43 <faxathisia> if you define sum as reducing the (+, 0) moniod
06:45:57 <Cale> Normally the sum of an empty set is 0, by definition.
06:46:01 <EvilRanter> which is how it's defined, faxathisia
06:46:07 <EvilRanter> whether in those terms or otherwise
06:46:12 <faxathisia> EvilRanter: yes in haskell and mathematics
06:46:28 <mauke> faxathisia: and in the real world
06:46:43 <mauke> I don't care what you think; sum() returning 0 is useful in practical programs
06:46:44 <Cale> mauke: How exactly do numbers and sets exist in the "real world"?
06:46:54 <EvilRanter> "if you define sum as the sum of the elements of a list" you blow the stack or get a <<loop>>, depending on how smart your theorem prover is
06:47:03 <mauke> Cale: they don't
06:47:06 <quicksilver> mathematics models the real world
06:47:14 <Cale> mauke: So what do you mean by that?
06:47:14 <quicksilver> and in all the obvious ways that sets and lists model real world things
06:47:14 <EvilRanter> ;)
06:47:26 <quicksilver> we find that the sum of the whatever an empty list models
06:47:28 <quicksilver> should be zero
06:47:29 <Cale> quicksilver: No it doesn't, that's the job of science.
06:47:39 <quicksilver> Cale: ok, I'm taking shortcuts.
06:47:42 <faxathisia> well
06:47:42 <Cale> :)
06:47:44 <faxathisia> [+] ()  =>  0
06:47:47 <faxathisia> so perl 6 is progress
06:47:55 <quicksilver> Cale: science shows us ways to use mathematics to model the real world
06:47:59 <quicksilver> and when we use those ways
06:48:03 <Cale> Yeah, I'd agree with that :)
06:48:09 <quicksilver> we model certain real-world entities as sets or lists
06:48:15 <quicksilver> when we check what 'sum' means in those contexts
06:48:16 <mauke> Cale: I had the problem of sum(@foo) returning undef for empty arrays in a "real" program
06:48:28 <Cale> mauke: ah, in that sense :)
06:48:35 <_ry> is last a linear time operation?
06:48:40 <Cale> _ry: yes
06:48:43 <_ry> :(
06:48:43 <mauke> Cale: so regardless of mathematical elegance, returning 0 would have been the right answer in practice
06:48:46 <mauke> in that case anyway
06:49:00 <Cale> _ry: there's no way to follow all those pointers in constant time.
06:49:12 <_ry> if it wrapped around?:
06:49:25 <quicksilver> we find that we would like the sums of the real world thing which corrspond to empty lists
06:49:28 <quicksilver> to be zero
06:49:29 <mauke> you could make a doubly linked list but it would be mostly useless in practice
06:49:30 <quicksilver> in every case
06:49:41 <quicksilver> because of that, we have lots of confidence that zero is the right definition
06:49:45 <quicksilver> doserj gave one example
06:49:47 <EvilRanter> you could make a circular doubly-linked-list, but you'd need to copy every cell to change *anything*
06:49:48 <quicksilver> there are many, many more.
06:49:50 <Cale> _ry: consider the case of an infinite list :)
06:50:05 <_ry> Cale: oh yeah!
06:50:12 <quicksilver> that's what I mean when I say "in the real world, the sum of an empty list is zero"
06:50:17 <EvilRanter> _ry: if you only need to work with one end of a list, it's best to work with the front
06:50:27 <quicksilver> and I wouldn't normally expet to need a 15 line explanation to justify that to smart people like you lot :P
06:50:49 <Cale> Well, 0 is the right definition for sum [], because we want the property to hold that sum (xs ++ ys) = sum xs + sum ys
06:51:02 <Cale> and no other value for sum [] will make that true.
06:51:04 <matthew-_> right, this might be slightly late...
06:51:06 <quicksilver> that's one of many ways of saying it, yes
06:51:14 <EvilRanter> _ry: otherwise, you may want to have a look at different data structures; Data.Sequence is another linear homogeneous collection, but with good complexities for working with either end
06:51:28 <matthew-_> > assocs $ runSTUArray ((newArray (0, 14) 0 :: ST s (STUArray s Int Int)) >>= \a -> let f v = readArray a v >>= writeArray a v . succ in mapM_ f [7,5,4,8,7,6,6,6,4,3,3,3,2,9] >> return a)
06:51:29 <lambdabot>   Not in scope: `writeArray'
06:51:40 <mauke> quicksilver: http://sc.tri-bit.com/Obviously_Something_Stupid :-)
06:51:41 <lambdabot> Title: Obviously Something Stupid - StoneHome
06:51:41 <matthew-_> AGH! That took me half an hour to do! It works damnit
06:52:17 <matthew-_> :m + Data.Array.MArry
06:52:32 <mauke> MArry Me
06:52:37 <Cale> hahaha, arguing about the colour of yellow is awesome
06:52:45 <matthew-_> why does Î»b not know writeArray?
06:52:54 <EvilRanter> are we allowed ST?
06:53:05 <EvilRanter> > runST
06:53:05 <lambdabot>   Not in scope: `runST'
06:53:09 <matthew-_> ugh!
06:53:13 <quicksilver> > Control.Monad.ST.runST
06:53:14 <lambdabot>   Not in scope: `Control.Monad.ST.runST'
06:53:18 <quicksilver> no, I dn't think so
06:53:18 <matthew-_> why not? It's safe isn't it?
06:53:28 <quicksilver> ask dons :)
06:54:04 <EvilRanter> maybe 'cos you can cause a big stinky error with a polymorphic STRef (or whatever the details are)?
06:54:10 <matthew-_> are there papers on ST ? I don't really get this forall s . stuff ? Why is it there?
06:54:36 <quicksilver> matthew-_: to stop you getting access to the underlying mutable stuff which you've changed
06:55:18 <mauke> hmm, couldn't you escape the rank-2 continuation by using existentials?
06:55:29 <mauke> (I like buzzwords)
06:55:49 <quicksilver> no. existentials themselves can't escape :)
06:56:01 <quicksilver> this kind of rank-2 is just another way of writing an existential, really.
06:56:03 <matthew-_> lol, I love the show instance: "<<ST action>>"
06:56:48 <ertai> It seems that http://code.haskell.org is down, can someone confirm it?
06:56:53 <matthew-_> quicksilver: ahh, I getcha. That makes sense.
06:57:05 <quicksilver> matthew-_: otherwise it wouldn't be safe
06:57:08 <matthew-_> indeed
06:57:17 <matthew-_> why isn't it just hidden then like in IO ?
06:57:20 <quicksilver> matthew-_: it uses mutation behind the scenes, but on the condition that you can't access the 'old' stuff
06:57:35 <quicksilver> because it needs to stop you join different ST actions
06:57:47 <matthew-_> ahh, yes, that too makes sense
06:57:47 <quicksilver> which have different private bundles of mutable state
06:59:11 <matthew-_> so, you're suggesting it would very bad to add an instance MonadState s ST ? ;)
07:00:29 <EvilRanter> ertai: same here
07:00:30 <quicksilver> well that wouldn't be the same s :)
07:00:45 <quicksilver> hmm
07:00:47 <quicksilver> no that's OK
07:00:49 <quicksilver> you can do that
07:00:52 <quicksilver> it's just not very useful :)
07:01:31 <_ry> how can i iterate through an array :/
07:01:51 <EvilRanter> malcolmw: well, it built, but the hat package seems to not be registered with ghc
07:01:59 <EvilRanter> so i can't build a test program
07:02:00 <matthew-_> _ry: depends what type of array it is
07:02:20 <EvilRanter> _ry: the normal thing would be to convert it into a list and map over that
07:02:40 <_ry> okay...
07:02:42 <EvilRanter> in haskell, as lisp, we use lists instead of loops ;)
07:03:00 <_ry> is there no map function for arrays?:
07:03:07 <matthew-_> _ry: no.
07:03:16 <quicksilver> yes, there is
07:03:35 <matthew-_> mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
07:03:45 * matthew-_ munches some pie :: Humble
07:04:02 <quicksilver> mapArray for MArrays, and amap for IArrays
07:04:47 <_ry> @index amay
07:04:47 <lambdabot> bzzt
07:04:52 <_ry> @index amap
07:04:52 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
07:05:50 <faxathisia> > sum ([] :: [()])
07:05:51 <lambdabot>   add an instance declaration for (Num ())
07:05:51 <lambdabot>     In the expression: sum ([] :: ...
07:06:02 <quicksilver> what there doesn't appear to be is traversable and foldable instances.
07:06:06 <quicksilver> which is a shame
07:06:14 <quicksilver> as that would give you mapM_ and mapM
07:09:34 <dons> woot, nhc98!
07:09:42 <dons> malcolmw++
07:09:46 <matthew-_> ahh, dons is awake.
07:09:48 <dons> http://article.gmane.org/gmane.comp.lang.haskell.general/15770
07:09:49 <lambdabot> Title: Gmane -- Mail To News And Back Again
07:09:56 <matthew-_> dons: why does Î»b not allow ST ?
07:10:29 <malcolmw> dons: my guinea pig is still trying to nhc98 to compile successfully on a machine that doesn't already have nhc98 installed
07:10:46 <malcolmw> minor updates to the tarball may still be forthcoming
07:10:53 <dons> matthew-_: unsafeIOToST
07:10:57 <faxathisia> @src Monoid
07:10:57 <lambdabot> class Monoid a where
07:10:57 <lambdabot>     mempty  :: a
07:10:57 <lambdabot>     mappend :: a -> a -> a
07:10:57 <lambdabot>     mconcat :: [a] -> a
07:11:14 <faxathisia> oh ok
07:11:16 <faxathisia> @src mconcat
07:11:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:11:24 <dons> malcolmw: not 64 bit clean though, still, right?
07:11:30 <faxathisia> I'm guessing mconcat is = fold mempty mappend
07:11:32 <faxathisia> is that rtue?
07:11:38 <resiak> dons: could you not just import hiding unsafeIOToST?
07:11:47 <faxathisia> oops
07:11:53 <malcolmw> dons: yep, but -m32 compatibility on 64-bit machines
07:11:55 <faxathisia> fold mappend mempty
07:12:12 <quicksilver> dons: couldn't you just ban that particular function though?
07:13:00 <dons> quicksilver: sure. i think there's some other issue. check the logs (?)
07:13:15 <dons> maybe i was just being over cautious
07:13:30 <faxathisia> dons: Hi
07:13:34 <dons> http://programming.reddit.com/info/619er/comments/ (nhc98 released! A Haskell compiler for small systems )
07:13:36 <dcoutts> dons: just built nhc98-1.20 here with a little assistance from malcolmw
07:13:37 <dons> hey faxathisia
07:13:58 <dons> oh good, dcoutts
07:14:07 <dcoutts> dons: it needs a couple minor patches to build on machines that are not malcolmw's ;-)
07:14:16 <ricky_clarkson> Is that to get Haskell onto the OLPC? ;)
07:14:30 <dons> malcolmw: is nhc now on hackage?
07:14:37 <dons> it would be cool to get the compilers onto hackage :)
07:14:43 <EvilRanter> malcolmw: sorry to keep harassing you, but I've run into the problem described at http://www.nabble.com/Hat-hasn't-installed-properly-t2568765.html, and the final solution ("sh start") doesn't seem to make sense here...
07:14:43 <lambdabot> Title: Nabble - Haskell - Hat - Hat hasn't installed properly
07:14:47 <dons> ricky_clarkson: i imagine that would work
07:14:58 <faxathisia> dons: I don't know if it helps but since lambdabot has not worked out where the docs are there is a list of urls based on package here http://rafb.net/p/quTlFx85.txt
07:15:15 <dons> faxathisia: ah ok.
07:15:30 <faxathisia> which is extracted from http://www.haskell.org/ghc/docs/6.8.1/html/libraries/ with http://rafb.net/p/YOwanv10.txt
07:15:42 <sethk> Hello, all.  I've been doing some job hunting lately, and a friend tells me that there is a Haskell project at one of the big Wall Street brokerage companies.  Has anyone heard anything about this?
07:15:56 <dons> sethk: yep.
07:16:08 <sethk> dons, any details?
07:16:18 <sethk> dons, I'm living in Manhattan, and they may be hiring.
07:16:30 <dons> http://haskell.org/haskellwiki/Jobs
07:16:45 <sethk> dons, maybe I should have thought about looking there?  :)
07:16:46 <phlpp> hi
07:16:46 <EvilRanter> (there's no file called start anywhere)
07:16:48 <dons> also , check the haskell@ and haskell-cafe@ archvies, there's been others
07:17:01 <dons> yeah, i'm trying to keep that page up to date
07:17:05 <dons> as jobs get announced on the lists
07:17:33 <dons> so that looks like deutsche bank. there may well be a job still at credit suisse nyhc too
07:17:38 <dons> nyhc??
07:17:42 * dons needs coffee
07:18:05 <sethk> dons, thass't ok, I don't alhways type good either
07:18:58 <sethk> dons, I find Credit Suisse, but not Deutsche bank, on that page.  I'm probably just blind, or maybe it's listed by a subsidiary name.  I'll look at all of them.
07:19:33 <dons> sethk: see the 'Finance Job' link
07:19:42 <sethk> dons, thanks
07:20:01 * wli looks for other examples.
07:20:02 <dons> there was also a job advertised from Barclay's a few months ago
07:20:18 <dons> so not everything mentioned on the list is on that page
07:20:33 <sethk> dons, k.  This one looks very interesting (the finance link)
07:21:11 <dons> yeah, looks advanced.
07:21:38 <sethk> dons, I'd have to finally figure out what a monad transformer actually _is_. :)
07:21:41 <dons> heh
07:21:41 <faxathisia> given a monoid M with identity I and operator *, is there a name for folding (*) with I on a list of [M]?
07:22:03 <Cale> multiplication?
07:22:12 <EvilRanter> monoidal sum/product?
07:22:17 <Cale> I don't think that's given a special name :)
07:22:24 <faxathisia> is it the same mconcat?
07:22:31 <EvilRanter> that's mconcat, yes
07:22:32 <Cale> Oh, in Haskell, yes.
07:22:54 <faxathisia> I think it makes sense now to define sum as mconcat with the monoid 0, +.. product with 1, * etc
07:23:06 <faxathisia> and just make the claim that perls sum is not actually a sum but something close :p
07:23:35 <faxathisia> (btw is it mconcat or mConcat?)
07:23:38 <EvilRanter> mconcat
07:23:42 <faxathisia> why?
07:25:17 <Zao> To disambiguate from mc-on-cat? :)
07:25:46 <Zao> Erm. Don't IRC without coffee.
07:30:58 <EvilRanter> gaaah
07:31:31 <EvilRanter> this's created a load of folders with {-# in their names
07:34:48 <EvilRanter> oh dear lord, there's one called #-} and one called LINE, too
07:34:53 <EvilRanter> something's gone horribly wrong
07:38:35 <EvilRanter> and these folders are all over the place in my prefix directory i put all my cabal stuff into... i don't know what's meant to be there any more, so i might have to rip it all out and start again :(
07:39:18 <Saizan> dons: ever thought about adding a get/putStorable to binary?
07:39:36 <dons> mm
07:39:50 <dons> now that's interesting. we don't have instances for C types
07:40:48 <faxathisia> Where is there haskell versions of All, Any, Dual a, Endo a, Ordering etc?
07:41:51 <Saizan> yes, and for example when parsing binary fixed-length packets it is sometimes easier to flush the stream in a struct like you might do in C
07:42:43 <osfameron> is there an extension to haskell that lets us match its datastructures with Xpath (or similar query language) ?
07:42:52 <faxathisia> @src Foldable
07:42:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:42:53 <Saizan> faxathisia: Data.Monoid and Data.Ordering ?
07:43:05 <faxathisia> http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Monoid.html
07:43:06 <lambdabot> http://tinyurl.com/2ac86v
07:43:11 <faxathisia> Saizan: There's some description there
07:43:20 <faxathisia> but are there good haskell implementations somewhere?
07:43:25 <Saizan> ?src Endo
07:43:25 <lambdabot> Source not found. :(
07:43:32 <quicksilver> faxathisia: implementations?
07:43:38 <quicksilver> faxathisia: what's to implement?
07:43:47 <faxathisia> mempty and mappend
07:43:51 <quicksilver> (Endo f) `mappend` (Endo g) = Endo (f . g)
07:43:54 <faxathisia> for each instance
07:43:57 <quicksilver> faxathisia: sure, look in the source
07:44:04 <Saizan> http://darcs.haskell.org/libraries/base/Data/Monoid.hs
07:44:04 <faxathisia> yeah which source?
07:44:08 <faxathisia> aah ok thanks
07:54:17 <EvilRanter> i give up. folders named after bits of haskell pragmas is just, frankly, too absurd to comprehend.
07:55:09 * EvilRanter notes down what cabal bundles he has installed, and nukes the folder he installs them into
07:55:12 <EvilRanter> *sigh*
07:57:29 <Cale> What happened?
07:57:55 <EvilRanter> Somehow, the hat install process made directories called '{-#', 'LINE', '1', '"somethingOrOther.hs"', and '#-}' in said folder
07:57:58 <EvilRanter> in various places
07:58:10 <Cale> awesome
07:58:12 <EvilRanter> and the install process otherwise failed half-way through
07:58:23 <EvilRanter> so i don't know what's meant to be there and what isn't
07:58:30 <EvilRanter> and indeed what's meant to be *where*
07:58:38 <malcolmw> EvilRanter: eek, sounds nasty
07:59:18 <EvilRanter> and I think it'd be quicker to gut it and start again than try to work out exactly what to delete
07:59:27 <EvilRanter> i only had a couple of things installed anyway
08:00:04 <EvilRanter> i'll sort it out some other time, i'm off
08:03:02 <jedbrown> Is it possible to serialize an arbitrary value (so that Haskell can evaluate it in a different context)?
08:07:43 <kpreid> Arbitrary? No.
08:09:46 <jedbrown> kpreid: The runtime must have some representation of it.  Why is there no way to get a hold of that?
08:10:38 <kpreid> Generally: because that representation may be interrelated with other parts of the runtime state.
08:11:18 <jedbrown> kpreid: Okay.  How about a thread?  Is it possible to suspend a running thread and put its state into a buffer?
08:11:50 <kpreid> Hm.
08:12:09 <kpreid> Actually, I think there might be a Haskell implementation that does that sort of thing, for distribution purposes.
08:13:11 <jedbrown> I want to build some distributed functionality on MPI and I'm trying to figure out how much I can abstract it.
08:13:58 <jedbrown> For the particular problem I'm working on, I can get away with just moving data around, but it would be more powerful if I could move more general objects.
08:14:40 <jedbrown> In particular, the code that moves the objects around would not need to know specifics about my particular problem.
08:15:01 <ricky_clarkson> Does Haskell have some tuple destructuring, like: let x y z=some3ple?
08:15:42 <kpreid> > let (x,y,z) = (1,2,3) in x
08:15:43 <jedbrown> ricky_clarkson: let (x,y,z) = some3ple  ??
08:15:45 <lambdabot>  1
08:16:28 <ricky_clarkson> Nice.
08:16:44 <kpreid> pattern matching is very regular in haskell
08:17:49 <Cale> Yeah, there's destructuring for most types really.
08:18:49 <dcoutts> dons: are you root on darcs.h.o ? I need some perms fixing in /srv/trac/c2hs
08:19:27 <dons> i have root, yep
08:20:09 <dcoutts> dons: I own all the files in /srv/trac/gtk2hs, but in c2hs they all belong to root, so I can't add a guest user or delete the spam from the db.
08:20:59 <dcoutts> dons: the group ownership and perms are fine
08:22:13 <dons> oh, i'm not root on darcs.h.o actually
08:22:15 <dons> only code
08:23:12 <dcoutts> dons: ah ok. Same here.
08:23:26 <dcoutts> dons: perhaps you could ask someone who is root on that box.
08:24:01 * dcoutts is doing a c2hs release and would like to be able to point to the c2hs trac as the right place to report bugs
08:24:12 <Igloo> dcoutts: Done
08:24:29 <dcoutts> Igloo: oh, thanks! :-)
08:30:59 <pitecus> Are there no links from library doc to source files or am I blind?
08:31:24 <oerjan> pitecus: upper right corner of page
08:31:38 <oerjan> (for each module)
08:31:51 <pitecus> oerjan, it says contents and index
08:31:54 <pitecus> no source
08:31:58 <pitecus> http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck-1.1.0.0/Test-QuickCheck.html
08:31:59 <lambdabot> http://tinyurl.com/2ez6o5
08:32:00 <oerjan> oh?
08:32:17 * EvilTerran returneth
08:32:53 <oerjan> that's annoying, it used to be there
08:33:27 <shapr> @yow !
08:33:27 <lambdabot> I have a very good DENTAL PLAN.  Thank you.
08:34:22 <pitecus> quite annoying
08:34:37 <oerjan> otoh it only gave you the public module itself, so if that imported private modules those still weren't so easy to find
08:36:27 <oerjan> @source Test.QuickCheck
08:36:28 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
08:37:25 <oerjan> lambdabot to the rescue, although @source may not have been updated in a while either
08:37:50 <pitecus> Could someone explain what sized does in Quickcheck?
08:39:27 <shapr> It changes the size of the produced value.
08:39:54 <faxathisia> How can you tell if evaluation of a language is deterministic from looking at operational semantics?
08:40:40 <pitecus> shapr, Im looking at the Arbitrary instance for Maybe and can't figure out what's it supposed to be doing...
08:40:43 <oerjan> from its use in the source it seems to me like it's more a way of finding out what size the surroundings want
08:41:08 <Cale> faxathisia: Very carefully? :)
08:41:14 <faxathisia> haha
08:41:17 <oerjan> instance Arbitrary Int where arbitrary     = sized $ \n -> choose (-n,n)
08:41:20 <EvilTerran> faxathisia, induction on the inference rules; show that (all subexpressions are deterministic) => (this expression is deterministic) for each rule in turn
08:42:58 <jedbrown> I could serialize arbitrary values to a limited extent by having a map from keys to values defined at compile time.
08:42:58 <jedbrown> With some parsing, it could even do composition, but this seems rather backwards.  Is there a better way?
08:43:20 <oerjan> pitecus: so the function passed to sized itself gets passed the current wanted size, so it can use it
08:44:18 <pitecus> oerjan, OK
08:45:45 <faxathisia> this is really baffling
08:48:20 <byorgey> faxathisia: what is?
08:48:31 <Saizan> for numeric constants, is it better to use some toplevel CAFs or CPP #define ?
08:49:22 <faxathisia> byorgey: this language semantics definition
08:49:22 <faxathisia> I'm starting to think this entire thing is a hoax :P
08:49:30 <byorgey> oh, hehe =)
08:49:35 <ndm> @seen malcolmw
08:49:35 <lambdabot> malcolmw is in #darcs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 2m 15s ago.
08:49:44 <byorgey> Saizan: "better" in what sense?
08:49:52 <ndm> malcolmw: ghc no longer works on venice - did you change the haskell paths script?
08:50:13 <faxathisia> can I just ask something about these semantic charts..
08:50:18 <malcolmw> ndm: nope, haven't touched anything
08:50:38 <ndm> malcolmw: did you add nhc to the base path script? if it wasn't you, it might have been matt
08:51:00 <malcolmw> ndm: no, I didn't
08:51:08 <malcolmw> what is the "base path script" anyway?
08:51:30 <Beelsebob> malcolmw: did you get the email I sent you about hmake and ghc-6.8?
08:51:49 <ndm> malcolmw: we have /grp/haskell/base-paths which sets up all the Yhc/GHC stuff onto the path
08:52:03 <malcolmw> Beelsebob: yes.  I committed a fix, but I'm waiting for darcs to push it (and have been for a couple of hours now)
08:52:17 <Beelsebob> okies, cool, thanks :)
08:52:18 <ndm> it seems someone crapped on it, as i can no longer use emacs to edit the damn thing!
08:53:55 <ndm> malcolmw: if you log into venice, can you do anything?
08:54:25 <malcolmw> ndm: yes, I can do stuff
08:55:18 <malcolmw> ndm: is it called 'bash-paths' perhaps?
08:55:25 <ndm> it is
08:55:42 <ndm> malcolmw: and matt hosed it, by forgetting PATH=PATH++..., and just overwrote the path
08:56:19 <malcolmw> matt has a lock on the file right now
08:56:36 <Saizan> byorgey:  style, maintainability, etc..
08:56:45 <ndm> malcolmw: matt has now fixed it :)
08:56:58 <ndm> i just saw nhc was now available, so knew it was one of you two!
08:57:11 <ndm> now we have cat, emacs, less and ghc back :)
08:57:34 <byorgey> Saizan: well, personally, I can't think of any ways in which using CPP #defines is better than toplevel CAFs.
08:57:46 <byorgey> Saizan: although there may be some reasons I don't know about.
08:58:44 <byorgey> Saizan: in terms of style & maintainability, however, using CPP is unambiguously ugly.  and slightly less portable/more fragile since it depends on more tools to be able to build.
08:58:44 <Saizan> byorgey: i'm just being infected by the C code i'm porting probably :)
08:58:57 <sorear> malcolmw++
08:59:10 <byorgey> Saizan: don't be tempted by the dark side!!
09:00:10 <ndm> byorgey: try out: foo = realWorld#
09:00:33 <ndm> (now for bonus marks try doing it with -cpp and figure out why that ALSO doesn't work)
09:00:35 <ricky_clarkson> Yeah, unless your build includes cpp rewritten in Haskell, don't do it! ;)
09:01:04 <Saizan> ?where hscpp
09:01:04 <lambdabot> I know nothing about hscpp.
09:01:09 <Saizan> ?where cpphs
09:01:09 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
09:01:42 <byorgey> ndm: heh, no thanks =)
09:04:17 <desegnis> So... code.haskell.org is down?
09:05:07 <RubberHound> How would you find the sum of a digits in an integer?
09:05:18 <RubberHound> *sum of digits
09:05:22 <quicksilver> I'd add them all up in my had!
09:05:24 <quicksilver> head!
09:05:34 <davidL> @type digitToInt
09:05:36 <lambdabot> Char -> Int
09:05:42 <integral> sum $ [ read [x] | x <- show theInteger ]
09:05:49 <faxathisia> RubberHound: convert it to a string (using show), and then map across turning them into integers before using sum
09:05:58 <RubberHound> oh
09:06:01 <RubberHound> ok, thanks
09:06:11 <integral> sum . (map digitToInt) . show
09:06:17 <davidL> > sum $ map digitToInt (show 12345)
09:06:18 <lambdabot>  15
09:06:25 <faxathisia> > sum $ map digitToInt $ show 234
09:06:25 <lambdabot>  9
09:07:20 <RubberHound> i don't seem to have that function in my namespace
09:07:33 <oerjan> @index digitToInt
09:07:33 <lambdabot> Data.Char
09:07:40 <bsdemon-rus> Can anyone tell me why:
09:07:40 <bsdemon-rus> "someFunc :: [[Integer] -> Bool] [Integer] -> [Bool]"
09:07:40 <bsdemon-rus> yelds
09:07:40 <bsdemon-rus> "Illegal type "[] ([Integer] -> Bool) [Integer]" in constructor application" ?
09:08:00 <integral> bsdemon-rus: you''re missing something between [Integer] -> Bool] [Integer]
09:08:16 <wli> let digitalSum n | n < 10 = n | otherwise = let (q, r) = n `quotRem` 10 in r + digitalSum q
09:08:16 <bsdemon-rus> oh yes, i'm stupid
09:10:02 <dons> ?pl k f g = \a -> f >> g a
09:10:02 <lambdabot> k = (.) . (>>)
09:13:07 <faxathisia> so frustrating
09:13:36 <RubberHound> is there digitToInetger?
09:13:45 <RubberHound> because i need that, not ToInt
09:13:49 <faxathisia> :t fromEnum
09:13:50 <lambdabot> forall a. (Enum a) => a -> Int
09:13:58 <faxathisia> RubberHound: I guess you can use fromIntegral
09:14:34 <faxathisia> > (fromIntegral $ digitToInt '6') :: Integer
09:14:35 <lambdabot>  6
09:14:45 <faxathisia> for example
09:14:50 <faxathisia> though integrals method solves that doesn't it?
09:14:58 <hpaste>  firefly pasted "cnt/bytestring example w/core+C--+asm" at http://hpaste.org/4064
09:15:02 <faxathisia> (removes need for fromIntegral)
09:15:25 <faxathisia> > (sum $ [ read [x] | x <- show 466654 ]) :: Integer
09:15:26 <lambdabot>  31
09:15:30 <firefly> dons, can I ask you a couple of questions about the C-- code from the simple byte-counting ByteString example?
09:15:37 <dons> sure
09:15:49 <dons> though JaffaCake is the main guy :)
09:15:54 <dons> he actually dreams in Cmm
09:16:01 <firefly> I was wondering where names like "sY9_ret" come from.
09:16:18 <dons> internal symbol + '_ret'
09:16:34 <dons> produced by the codeGen translation from functional to imperative code
09:16:57 <firefly> (there are also sYI_ret, sYb_entry, sYJ_ret, sYH_ret, Main_a_entry, Main_a1_entry, ZCMain_main_entry)
09:17:07 <dcoutts> firefly: compilers often need to generate fresh names, sometimes they can be derived from existing names to show where they come from, sometimes they cannot.
09:17:26 <firefly> __stginit_Main_, __stginit_Main, __stginit_ZXMain seem understandable, except, why so many?
09:17:47 <dons> different entry points, fast / slow
09:18:06 <firefly> sure I understand why extra names sometimes are needed and that they get weird names -- but there are so many extra names that seem completely mysterious to me.
09:18:15 <bakert> If I have "data Foo = Foo { x :: Int, y :: Int, z :: Int }" and "a = [1, 2, 3]" how can I make a Foo out of a?
09:18:21 <hpaste>  Agromov pasted "4eza..." at http://hpaste.org/4065
09:18:43 <bakert> (the real example has 13 fields)
09:19:05 <firefly> What's ZC mean?  I think I saw it on one of the commentary web pages but I forget.
09:19:13 <oerjan> bakert: i don't think you get away from pattern matching
09:19:51 <bakert> oerjan: oh :(  perhaps i should start earlier in the chain.  the Ints come from calls to abitrary (from QuickCheck) so perhaps I can do something there?
09:20:06 <firefly> will Foo {a !! 1, a!! 2, a!!3} or something like that work?
09:20:30 <oerjan> bakert: you should be able to do Foo `ap` arbitrary `ap` ... then
09:20:43 <bakert> firefly: yes probably but i was hoping for something more like Foo (magicFunc a)
09:20:44 <bakert> :)
09:21:00 * firefly doesn't like magic
09:21:15 <bakert> something along the lines of replicate and replicateM
09:21:18 <oerjan> er, make that first ap a liftM
09:21:29 <bakert> oerjan: so 13 times ap?
09:21:34 <oerjan> yeah
09:22:03 <bakert> maybe i should change my data structure.  i am growing to hate functional references with record anyway
09:22:13 <bakert> because it makes the types complicated
09:22:15 <hpaste>  faxathisia annotated "semantics" with "it's not clear if this is right or wrong" at http://hpaste.org/4052#a5
09:22:23 <byorgey> the problem with doing some kind of fold of ap over (replicate 13 arbitrary) is that all the arbitrary's have to be the same type.  which they aren't.
09:22:27 <firefly> The many versions of Main arise already in the core code but I'm completely baffled as to why.
09:22:33 <bakert> byorgey: they are all Ints so that's cool
09:22:43 <byorgey> bakert: oh, well in that case...!
09:23:04 <oerjan> byorgey: it's each point in the application which needs to be the same type
09:23:21 <bakert> ?src ap
09:23:21 <lambdabot> ap = liftM2 id
09:23:31 <oerjan> Foo, Foo x, Foo x y need to have the same type to fold over a list
09:23:54 <byorgey> oh, right.
09:23:54 <firefly> Another question: what are the fast and slow entry points used for?  What forces the ghc runtime to use the slow entry point?
09:24:17 <alexj> @seen igloo
09:24:17 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 47m 7s ago.
09:26:03 <bakert> ?hoogle ap
09:26:04 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
09:26:04 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
09:26:04 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
09:28:02 <oerjan> it _would_ be possible to make a list of generic functions for it, but if you only have one use case...
09:28:25 <hpaste>  bsdemon annotated "4eza..." with "(no title)" at http://hpaste.org/4065#a1
09:28:38 <oerjan> i.e. ap13 f (x:r) = ap12 (f x) r etc.
09:28:39 <bakert> just one.  arbitrary = do { return $ Foo $ liftM arbitrary `ap` arbitrary `ap` arbitrary `ap` arbitrary `ap` ... } ???
09:29:20 <oerjan> but because of typing, there need to be one for each possible number of arguments
09:29:40 <faxathisia> :t iterate ap
09:29:41 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
09:29:41 <lambdabot>     Probable cause: `ap' is applied to too few arguments
09:29:41 <lambdabot>     In the first argument of `iterate', namely `ap'
09:29:43 <bakert> hmm that's unpleasant!  it makes me think my whole approach is wrong
09:30:08 <bakert> i just want to define arbitrary (from quickcheck) for a record containing 13 Ints and nothing else.
09:30:26 <bakert> i feel like that should not be hard.  but perhaps it just needs to be explicitly written out
09:30:38 <quicksilver> in haskell terms, that's metaprogramming
09:30:45 <oerjan> bakert: well records with 13 fields are probably awkward no matter how you look at it
09:30:50 <quicksilver> because a record with 13 ints isn't a "uniform thing"
09:30:59 <quicksilver> so you need a metaprogramming solution
09:31:00 <bakert> yes.  i could make it a list or a map.
09:31:21 <bakert> the only good thing about it being a record is that i am using functional references to refer to both the fields
09:31:21 <quicksilver> it's not too painful to get Data.Derive or something, I think
09:31:23 <quicksilver> to do this
09:31:25 <bakert> and the inverse of the field
09:31:33 <bakert> hot record = 11
09:31:34 <quicksilver> but I haven't actually done it myself
09:31:36 <bakert> cold record = 9
09:31:53 <bakert> which is cool and all but perhaps not worth the attendant pain.  i could just define my 13 inverses
09:32:02 <bakert> which i am actually doing anyway
09:32:11 <hpaste>  bsdemon annotated "4eza..." with "End!" at http://hpaste.org/4065#a2
09:32:21 <bakert> this is my recurring problem with my lack of haskell knowledge ... no idea how to structure data
09:32:47 <oerjan> bakert: um, if you used a list you probably could make a functional reference kind of thing that took a position parameter?
09:33:37 <faxathisia> bakert: me too
09:33:37 <faxathisia> :(
09:33:43 <fasta> We are pleased to announce that, contrary to popular belief, there is
09:33:44 <fasta> indeed more than one Haskell compiler in the world.
09:33:49 <fasta> Golden!
09:33:52 <bakert> :)
09:34:03 <bakert> they probably just need a hug
09:34:26 * shapr hugs mwc
09:35:35 * Nafai eyes nhc98
09:37:04 <hpaste>  faxathisia annotated "semantics" with "is there any reason to not use something simpler like this?" at http://hpaste.org/4052#a6
09:37:32 <quicksilver> bakert: you certainly can use functional references into lists
09:37:36 <quicksilver> that's no problem
09:37:49 <bakert> i have almost forgotten now why i have functional references.
09:37:57 <bakert> it all stems from wanting to be able to say:
09:38:00 <bakert> hot data
09:38:04 <bakert> and
09:38:05 <bakert> cold data
09:38:14 <quicksilver> if you define data FPRef a s = FPRef { set :: s -> a -> s, get :: s -> a}
09:38:15 <bakert> and get a result for either from the one number stored in the structure
09:38:27 <quicksilver> then you can certainly have
09:38:34 <quicksilver> erm
09:38:38 <quicksilver> get = (!!n)
09:39:15 <quicksilver> set l v = take (n-1) l ++ [v] ++ drop n l
09:39:16 <quicksilver> I think
09:39:31 <bakert> my FRef is:
09:39:37 <bakert> ata FRef s a = FRef    { get :: s -> a
09:39:37 <bakert>     , set :: a -> s -> s
09:39:37 <bakert>     }
09:39:41 <bakert> which looks very similar
09:39:47 <quicksilver> in fact, the cool thing about functional references is they can work into arbitrarily detailed structures
09:39:54 <quicksilver> yes, just your parms for set were reversed
09:40:20 <bakert> i may just try your list idea.
09:40:22 <bakert> thanks
09:40:47 <faxathisia> @pl (\x y -> f x y)
09:40:47 <lambdabot> f
09:42:37 <faxathisia> @pl (\x -> I need a break x)
09:42:37 <lambdabot> I need a break
09:44:49 <quicksilver> Baughn: o
09:44:51 <quicksilver> oops
09:51:10 <Cale> @pl (\x -> There is no space before this x)
09:51:10 <lambdabot> There is no space before this
09:52:34 <fasta> I don't hope the name functional references will stick around forever...
09:53:24 <oerjan> just lobby to call mutable variables "dysfunctional references"
09:55:32 <fasta> Functional references and mutable references cannot be used for the same purpose.
09:56:01 <fasta> So, I don't see the reason to redefine the concept of a reference.
09:58:04 <dons> Igloo: code.haskell.org's web server is down
09:58:06 <dons> any ideas?
09:58:58 <Cale> fasta: huh? It's not redefining the concept of a reference
09:59:32 <dons> Igloo: so all projects on code.haskell.org have no web access.
10:00:11 <Cale> fasta: A functional reference gives you a way to refer to a part of a data structure.
10:01:02 <Igloo> dons: I can't see anything in logs. Have you tried just restarting it?
10:01:15 <Igloo> apache, I mean
10:02:28 <dcoutts> Igloo: are you going to restart it or am I?
10:02:29 <fasta> Cale: ok, so you claim that when I have a tree and split it up in two pieces that any functional reference will still point to the right node?
10:02:53 <Igloo> dcoutts: I'm not. You and dons can fight it out  :-)
10:02:58 * dcoutts does it
10:03:28 <Cale> fasta: an immutable tree?
10:03:59 <dons> back up. good work dcoutts :)
10:04:06 <dcoutts> @arr!
10:04:06 <lambdabot> Swab the deck!
10:04:08 <fasta> Cale: it's about the things you can do with it. But if it's immutable, sure.
10:04:09 <Cale> fasta: A functional reference to tree structures will point to a given point in any tree.
10:04:26 <Cale> That is, a specific node, irrelevant of which tree you're talking about.
10:04:56 <Cale> s/irrelevant/irrespective/
10:06:03 <dons> i think this is awesome. some french guy wrote a blog article about glguy's xmonad screenshot, http://jehan.zemarmot.net/blog/2007/11/23/les-manchots-ne-sont-pas-manchots/
10:06:04 <lambdabot> Title: Mon Havre de LibertÃ© » Blog Archive » Les manchots ne sont pas manchots&#8230;, http://tinyurl.com/2obzdy
10:06:19 <quicksilver> @babel fr en manchots
10:06:20 <lambdabot>   penguins
10:06:22 <quicksilver> ah
10:06:43 <fasta> Cale: ok, the thing I am interested in is that when one has a handle/reference/pointer/thingie to a tree node storted in a data structure and that one does operations to the tree that update certain things, that they references/thingies still point to the right nodes.
10:06:44 <resiak> ooh, mad keyboard!
10:07:00 <dons> ?babel fr en Les manchots ne sont pas manchots
10:07:01 <lambdabot>   The penguins are not penguins
10:07:05 <fasta> Cale: that's what you can do when the tree structure is mutable
10:07:23 <fasta> Cale: (and thus have mutable references)
10:07:26 <Cale> fasta: well, that's just not what functional references are about. They're more like paths which would work in any tree.
10:07:26 <quicksilver> fasta: well that's true of functional references too
10:07:36 <quicksilver> in some sense
10:07:41 <quicksilver> depending what you mean by 'right nodes'
10:07:48 <quicksilver> as cale says, it's more like a path
10:08:04 <quicksilver> so after you mutate the tree, your reference still points to the 3rd leaf of the second branch..
10:09:56 <firefly> I have on the desk before me the "Architecture of the Haskell Execution Platform (HEP) version 6", a description of how ghc and hugs could share code.
10:10:05 <firefly> It dates from July 1999.
10:10:13 <firefly> Does anybody know if anything ever came out of that?
10:10:17 <dons> ghci
10:10:17 <dcoutts> firefly: ghci
10:10:41 <fasta> quicksilver: by right node, I mean that when one has a reference to a node containing the label "FOO", and one completely reorders the tree, that afterwards the reference still points to a node containing "FOO", but it could be that the parents/children of the node containing "FOO" have changed.
10:10:45 <dons> ghc gained a mixed interpreter/comiler frontend
10:11:04 <quicksilver> fasta: I understand, in fact, what you mean. However I was just pointing out that there is another interpretation of 'right nodes'
10:11:09 <dcoutts> firefly: which also led to Template Haskell
10:11:13 <quicksilver> so, functional references are useful, but different.
10:11:18 <quicksilver> and they are also a kind of 'reference'
10:11:28 <quicksilver> they refer to things deep in complex data structures.
10:13:12 <SamB_XP> this reminds me of the issues involved with implementing Data for Data.Map...
10:13:35 <firefly> thanks.  That it begat template haskell is surprising!
10:15:03 <shachaf> dons: "nhc98 released! A Haskell compiler for small systems" -- you didn't include a version number; it was a bit confusing.
10:15:32 <SamB_XP> wasn't nhc98 released eons ago?
10:15:59 <shachaf> SamB_XP: Yes, this was specifically about 1.20.
10:16:30 <SamB_XP> shachaf: uh huh
10:17:01 <dons> shachaf: its the first release since web 2.0
10:17:13 <dons> so i figure lots of readers wouldn't know about it   :)
10:18:18 <quicksilver> talking of web 2, does nhc have yhc's javascript backend?
10:18:57 <SamB_XP> quicksilver: I was under the impression that the difference between nhc and yhc WAS the backend portions?
10:19:24 <dons> nhc produces faster code, as a result
10:19:37 <dons> yhc is a fork of nhc, yep
10:19:56 <SamB_XP> they've remerged the frontends, though, haven't they?
10:21:37 <dcoutts> SamB_XP: as I understand it yes, mostly. However they have completely different build infrastructures and nhc supports more libs.
10:22:06 <SamB_XP> sounds reasonable
10:22:43 <noobie> why is it that no one in here have any knowledge of HGL
10:22:57 <bos> is nhc 32-bit only?
10:23:07 <bos> malcolm made an insinuation in that direction.
10:23:19 <SamB_XP> what? no 18-bit support?
10:23:27 <dcoutts> bos: yes
10:23:47 <dcoutts> bos: so works on amd64 if you've got gcc -m32 working and 32bit support libs
10:24:20 <dcoutts> noobie: because nobody uses it anymore since it doesn't work very well and there are several better alternatives.
10:24:31 <dcoutts> HGL is dead
10:24:36 <dcoutts> has been for ages
10:24:59 <bos> dcoutts: fair enough
10:25:05 <noobie> well i have to learn it for a project
10:25:29 <dcoutts> noobie: best of luck
10:25:49 <SamB_XP> HGL is NOT OpenGL bindings
10:25:57 <SamB_XP> that's most of what I can say
10:34:47 <bos> what happens with ghc if i try importing a module that was built with some language extension? does ghc enable the right extension based on a field in the .hi file, or do i have to enable the flag on the command line?
10:36:13 <SyntaxNinja> Igloo: you around?
10:36:16 <SyntaxNinja> hi dons
10:36:41 <sorear> bos: language extensions are not used when loading modules, only when compiling them
10:36:46 <sorear> bos: so it just works
10:37:20 <bos> sorear: fair enough
10:39:55 <SamB_XP> assuming you don't also need the feature to USE the module, of course
10:44:18 <newsham> are there any functional programming holidays?  like Alonzo Church day or Lambda day?
10:45:13 <faxathisia> *lol*
10:45:46 <newsham> happy eta-reduction!
10:45:55 <byorgey> newsham: there should be!
10:46:07 <byorgey> we could celebrate Haskell Curry's birthday...
10:46:27 <ricky_clarkson> With a curry.  Without side-effects.
10:46:30 <byorgey> 12 September, says Wikipedia.
10:46:45 <trez> any excuse for drinking beer is okay for me
10:46:49 <newsham> hmm.. thats too 9/11
10:46:59 <newsham> (my birthday is 9/10)
10:47:06 <byorgey> ok, how about Alonzo Church's birthday? 14 June.
10:47:53 <astrolabe> I disagree that it's too 9/11.  We (the world) have had much larger disasters than 9/11.
10:48:00 <newsham> 9 nov, national curry day.  http://www.prnewswire.co.uk/cgi/news/release?id=14785
10:48:01 <lambdabot> Title: NATIONAL CURRY DAY
10:48:24 <newsham> astrolabe: like the reichstag fire?
10:48:28 <ricky_clarkson> I used to live in Rusholme.  I think I can still smell curry.
10:48:33 <ricky_clarkson> @go rusholme
10:48:34 <lambdabot> http://en.wikipedia.org/wiki/Rusholme
10:48:34 <lambdabot> Title: Rusholme - Wikipedia, the free encyclopedia
10:49:24 <astrolabe> newsham: not exactly what I had in mind.
10:49:57 <wli> newsham: Very similar events indeed.
10:53:04 <newsham> astrolabe: 3000 dead bankers is a pretty serious event!
10:56:07 <SamB_XP> newsham: what? they were all bankers?
10:58:31 <srid> Hello. I just read "Haskell in 10 minutes." What do you suggest as learning material for a Python programmer who has also done a bit of Scheme?
10:58:41 <newsham> samb: I dont know.  I dont obsess about 9/11 and dont really know the statistics.
10:59:09 <newsham> some bad guys did some bad stuff, bad things happened, and then all of the people who run my country decided to kill all the things that my country stood for
10:59:21 <newsham> thats the relevant part of the story
11:00:01 <newsham> srid: I'd suggest "two dozen short lessons" but they took it offline :(
11:00:08 <newsham> graham hutton's book is a good starting point.
11:00:20 <newsham> there's also some python programming docs that are relevant..
11:01:15 <newsham> lemme see if I can dig up python doc
11:01:51 <newsham> http://www.amk.ca/python/writing/functional <- will give you some familiarity with the concepts in a language you're already familiar with
11:01:52 <lambdabot> Title: Functional Programming HOWTO
11:02:17 <srid> newsham: http://www.cs.lth.se/EDA120/TwoDozenLessons/twoDznQ.pdf ?
11:02:42 <newsham> prob thats the one
11:02:43 <tp76> srid: YAHT (Yet Another Haskell Tutorial).
11:03:10 <newsham> yup, thats it.  is the answer sheet online too?
11:03:27 <newsham> the author took it off of his page..  i guess he's going commercial with it?
11:03:42 <srid> tp76: I saw both YAHT and AGITH linked in the wiki.
11:04:24 <srid> newsham: yep - he is going to publish in Pragmatic Programmers - http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
11:04:25 <lambdabot> Title: Two Dozen Short Lessons in Haskell, http://tinyurl.com/hl9mm
11:05:03 <srid> that's where I got the keywords (twoDznQ.pdf) to search in google for. :)
11:05:29 <newsham> good for him, its an excellent tutorial.  bad for us who used to get it free :)
11:11:13 <cedricshock> This works: "instance (Traceable a) => Traceable [a] where ..." but this doesn't: "instance (Traceable a) => Traceable (Either a) where ...". Why?
11:12:31 <resiak> @kind Either a
11:12:34 <lambdabot> Not in scope: type variable `a'
11:12:41 <resiak> doh.
11:12:50 <cedricshock> @kind [Int]
11:12:50 <lambdabot> *
11:13:03 <cedricshock> @kind (Either Int)
11:13:03 <lambdabot> * -> *
11:14:24 <cedricshock> resiak: Thanks. I really want "instance (Traceable a, Traceable b) => Traceable (Either a b) where ...", since ht point is combining two different traceable things into one independent one.
11:15:01 <alexj> @seen igloo
11:15:01 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 1h 12m 8s ago.
11:15:22 <srid> http://www.lisperati.com/haskell/
11:15:55 <dons> jobs jobs jobs, http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/24#sign-o-the-times
11:15:56 <lambdabot> Title: Haskell hacking
11:20:47 <cedricshock> @type or
11:20:47 <notsmack> osfameron: "foldr1 commonPrefix"?
11:20:49 <lambdabot> [Bool] -> Bool
11:22:49 <Cheery> !help
11:22:58 <Cheery> @type (.)
11:23:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:25:18 <Cheery> does haskell have rank 2 polymorphism?
11:25:33 <dons> it has rank n
11:25:38 <dons> rank 2 is boring :)
11:26:44 <oerjan> @type runST
11:26:55 <lambdabot> Not in scope: `runST'
11:27:03 <oerjan> @type Control.Monad.ST.runST
11:27:04 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
11:28:41 <ddarius> Haskell 98 doesn't though (though in the semantics of constructor classes it uses them)
11:31:50 <cedricshock> What's the name for the function a -> Maybe a -> a  that's \x -> (\m -> case m of Maybe y -> y Nothing -> x) ?
11:32:03 <xerox> :t maybe
11:32:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:32:09 <dcoutts> @type fromMaybe
11:32:09 <lambdabot> forall a. a -> Maybe a -> a
11:32:21 <dmwit> ?hoogle a -> Maybe a -> a
11:32:21 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
11:32:21 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:32:30 <dcoutts> @type \x -> (\m -> case m of Maybe y -> y Nothing -> x)
11:32:31 <lambdabot> parse error on input `->'
11:32:32 <dmwit> That's how you answer that question for yourself in the future. =)
11:33:21 <cedricshock> dmwit: Thanks.
11:33:34 <dmwit> ?type \x m -> case m of { Just y -> y; Nothing -> x }
11:33:47 <lambdabot> forall t. t -> Maybe t -> t
11:34:54 <ddarius> @. hoogle type \x m -> case m of Just y -> y; Nothing -> x
11:34:55 <resiak> > Nothing `mplus` Just 3
11:34:55 <lambdabot> Did you mean: Forall T. t -> Maybe t -> t
11:34:55 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
11:34:55 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:34:58 <cedricshock> ?hoogle a -> (a -> a -> a) -> [a] -> a
11:34:58 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
11:34:58 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
11:34:58 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
11:34:59 <lambdabot>  Just 3
11:35:30 <cedricshock> Neat
11:35:34 <resiak> @pl \x y -> x `mplus` Just y
11:35:34 <lambdabot> (. Just) . mplus
11:36:42 <firefly> what are sparks and spark pools?  (within the context of ghc)
11:36:53 <dmwit> ?pl \x y -> fromJust (x `mplus` Just y)
11:36:53 <lambdabot> (fromJust .) . (. Just) . mplus
11:37:10 <ari> That's beautifully semisymmetric
11:37:17 <dmwit> agreed
11:37:32 <ari> :t (fromJust .) . (. Just)
11:37:39 <lambdabot> forall a a1. (Maybe a1 -> Maybe a) -> a1 -> a
11:37:54 <resiak> slick.
11:38:32 <cedricshock> >compare [1, 2] [2, 1]
11:38:41 <dmwit> > compare [1, 2] [2, 1]
11:38:42 <lambdabot>  LT
11:38:52 <dons> shapr: sometimes being a haskell programmer feels like this, http://www.galois.com/~dons/images/che-lambda.png
11:40:18 <dcoutts> hah
11:40:42 <dons> dcoutts: could be related to you!
11:41:08 <dcoutts> he's got cooler hair
11:41:22 <dons> i must admit, this really is more a likeness, http://web.balliol.ox.ac.uk/history/portraits/images/034%20King%20Charles%20I.jpg
11:41:22 <lambdabot> http://tinyurl.com/366g42
11:42:15 <dcoutts> mm, very regal
11:42:40 <resiak> someone should put the face of che on a unicyclist.
11:42:48 <dcoutts> dons: that's what thorkilnaur said :-)
11:42:55 <dons> :)
11:43:07 <dcoutts> I've got the postcard with Charles I
11:46:56 * Baughn is annoyed to discover that Leopard's tar binary breaks the GHC install process
11:57:12 <sclv> firefly: see the documentation on `par` I think?
11:57:55 <faxathisia> hmf
11:58:11 * faxathisia is still upset about pH not existing
11:59:01 <firefly> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html#id3198759  ?
11:59:01 <lambdabot> Title: 8.17. Concurrent and Parallel Haskell, http://tinyurl.com/25eyfl
11:59:07 <esap> Someone should implement a good type system for concurrency.
11:59:30 <faxathisia> concurrent programming should just work without anything extra
11:59:47 <ricky_clarkson> esap: I don't know what I'm talking about, but isn't that what Actors is for?
12:00:40 <esap> ricky: Actors is a model, IIRC, not a type system. Or at least I haven't seen a type system for Actors.
12:01:30 <sclv> esap: what would such a type system do?
12:01:52 <esap> sclv: Ensure that deadlocks, livelocks, etc cannot happen.
12:02:10 <mux> STM goes a long way on that road
12:02:16 <esap> ricky: I mean http://en.wikipedia.org/wiki/Actor_model
12:02:17 <lambdabot> Title: Actor model - Wikipedia, the free encyclopedia
12:02:20 <mux> without any special feature from the type system
12:02:25 <firefly> okay, now I've read 8.17.4, about seq and par.  So sparks are computations that get queued (as a "spark") and then maybe executed on another cpu when you actually end up needing it.  Otherwise your own thread picks it up and evaluates it.
12:03:25 <esap> mux: Agreed, but it also has pretty strong assumptions on what you can do.
12:03:39 <Saizan> well, i think type system for concurrency are based on what are known as "session types", but i just know the name..
12:03:42 <mux> right, it clearly doesn't fit any scenario
12:04:01 <mux> the lack of progress guarantees can be a showstopper
12:04:07 <sclv> right so you can have let x = 12 + 27 in x `par` foo x where foo would normally take a while to get around to evaluating x
12:04:44 <sclv> i think of it like the opposite of `seq`
12:11:03 <ddarius> esap: Allegdely Acute http://www.cl.cam.ac.uk/~pes20/acute/ is something you may want to look at.  At any rate, there have definitely been static analyses for preventing deadlock
12:11:03 <lambdabot> Title: Acute
12:11:44 <faxathisia> hi ddarius
12:11:49 * dcoutts builds Cabal using Cabal and nhc98-1.20
12:11:53 * SamB_XP wonders why the GHC haddocks are missing their source links...
12:12:04 <dcoutts> woo finally works!
12:12:20 <mux> SamB_XP: known bug, should be fixed in 6.8.2
12:12:31 <faxathisia> ddarius: I actually managed to code that thing today, thanks so much for you help
12:12:50 * SamB_XP doesn't see why they can't backport the fix and update the online docs now
12:13:10 <faxathisia> (I think that there is something wrong with the actual language definition though..)
12:13:31 <esap> woo is impossible to search with google :-)
12:14:22 <esap> ddarius: I do know some attempts, e.g. CFFD equivalence stuff
12:15:37 <kaol> ?users
12:15:37 <lambdabot> Maximum users seen in #haskell: 401, currently: 394 (98.3%), active: 16 (4.1%)
12:15:56 <davidL> how do I use FFI to import a constant? foreign import "FOO_CONST" foo :: Int ?
12:16:18 <mux> davidL: you mean a #define ?
12:16:25 <davidL> mux: yeah
12:16:37 <esap> ddarius: this Acute looks like interesting, have to look at it.
12:16:37 <ddarius> davidL: Just run CPP over your Haskell file.
12:16:44 <mux> davidL: no help from the FFI for that
12:16:51 <dons> any slides from Fun in the Afternoon up ?
12:17:40 <davidL> you mean just including the header file and using hsc2hs is all I have to do?
12:18:01 <swiert> dons: I haven't seen anything yet.
12:18:23 <dons> ok.
12:18:31 <mux> one of the *c2hs tool has #{const_str}
12:18:41 <ddarius> davidL: There's a flag for GHC that will run CPP over your file before compiling it.
12:18:46 <dons> why is it that every post about F# mentions Haskell? :)
12:18:54 <dons> http://jyliao.blogspot.com/2007/11/learning-wpf-with-f-dock-and-grid.html
12:18:55 <lambdabot> Title: John Liao's Blog: Learning WPF with F# - The Dock and the Grid, http://tinyurl.com/2wmhdf
12:19:05 <dons> (F# user complains: I'm struggling with and trying to work through is how to write expressively
12:19:06 <ddarius> Because Microsoft has been subverted to a Haskell propaganda machine.
12:19:09 <dons> elegant code that I see in Haskell's Prelude code"
12:19:18 <dons> ddarius: looks like it
12:19:47 <davidL> ddarius: are you saying I don't even need to use hsc2hs if I use the GHC flag?
12:20:24 <ddarius> davidL: Unless you have some other reason to, you shouldn't.
12:20:47 <dons> ddarius: is F# the ghc windows port ? :)
12:21:00 <dons> maybe ghc should just generate F# on windows..
12:21:01 <ddarius> dons: Not yet.
12:21:26 <sw17ch> dons: was it you, or some one else who was on the F# team?
12:21:33 <dons> sounds like a really cheap way to get .NET support going - core2F#
12:21:40 <dons> sw17ch: that's don syme
12:21:44 <dons> the `other' dons
12:22:04 <dons> he's an aussie too, doing fp, which is confusing, since he also uses 'dons'
12:22:33 <sw17ch> dons: yeah, that messed me up. I'm potentially comparing Haskell and F# for a class... and haven't decided yet
12:22:36 <Heffalump> dons: have you used associated type synonyms at all?
12:22:39 <ddarius> dons: I like how even a year ago (even now) people were saying that monads were academic frivolity and now there are talking heads saying that they are "the future"
12:23:22 <dons> Heffalump: only lightly. rl is the big assoc. type hacker
12:23:28 <dons> ddarius: :)
12:23:43 <davidL> ddarius: do I even need to use foreign imports if I use GHC's CPP flag?
12:23:51 <dons> sw17ch: are you on windows?
12:23:53 <Heffalump> I'm trying to work out how badly broken they are in ghc 6.8.1
12:23:56 <dons> if not, then F# isn't an option
12:24:08 <dons> Heffalump: check with ChilliX or on the list
12:24:21 <Heffalump> ok
12:24:30 <ddarius> davidL: No, not for CPP #defined constants.
12:24:35 <sw17ch> dons: dual boot Vista Business and Gentoo... usually i'm only in windows to play with visual studio and Team Fortress 2
12:25:05 <thoughtpolice> dons: i think syme said that the current f# distro works with mono; he provided a zip for it as well as an msi
12:25:19 <davidL> thanks ddarius
12:25:26 <dons> sw17ch: well, ghc works on windows quite fine, so unless you needed .net libs or something, i'd see no issue with using ghc.
12:25:36 <dons> its just choosing between ocaml and haskell
12:25:54 <dons> do you care about learning purity, monads and concurrency? or hmm, side effectful fp
12:26:02 <ddarius> F# is missing some of significant things from O'Caml
12:26:09 <dons> yeah, no functors!
12:26:19 <dons> its like CAL, but for ocaml, and more successful :)
12:26:36 <sw17ch> dons: to be honest, it was to compare the parallel nature of the two. It's a high performance computing class. Lots of OpenMPI and OpenMP... etc...
12:26:55 <dons> cool. you can use the hmpi binding for haskell
12:27:07 <sw17ch> Then the prof mentioned he was curious what the deal with Transactional Memory deal was.
12:27:17 <dons> yeah, what's the deal with that?
12:27:24 <dons> :)
12:27:26 <sw17ch> dons: there's hmpi? I think you have just amde my day. How does it differ from distributed haskell?
12:27:42 <dons> haskell binding to mpi, versus runtime support for distribution
12:28:04 <sw17ch> dons: i have no idea what the deal with it is... which is why i'll probably look into that as opposed to comparing F# and Haskell... but i'm still curious about the whole situation
12:28:18 <thoughtpolice> speaking of high performance, anybody investigated the use of -fvectorise yet?
12:28:39 <dons> i'd wait for an ndp announcement on that, thoughtpolice
12:28:43 <dons> there's the 'status report' paper though
12:28:45 <thoughtpolice> that's what i was figuring
12:28:53 <thoughtpolice> yeah, the partial vectorisation paper
12:28:55 <dons> showing some good speedups on the 40 cpu sun boxes, versus C
12:29:33 <sw17ch> thoughtpolice: can you describe what it does in 10 words or less?
12:29:39 <conal> does -fvectorise tie the array comprehension syntax to the parallel array combinators?
12:29:51 <thoughtpolice> when ndp is ann for 6.8, i assume -fvectorise will (at least somewhat) be able to desure the parallel array comprehensions syntax to ndp's high performance stuff
12:30:09 <conal> that's what i'm hoping
12:30:40 <thoughtpolice> sw17ch: it will basically allow expressions like this: dotp xs ys = sumP [: x * y | x <- xs, y <- ys :] to map across multiple cores
12:30:46 <thoughtpolice> that's not 10 words though, but i think sufficient
12:30:54 <dons> you can at least program in the list api for parallel arrays
12:31:02 <thoughtpolice> yeah, GHC.PArr
12:31:03 <dons> even if the comprehension syntax isn't on
12:31:05 <thoughtpolice> i was messing with it yesterday
12:31:12 <sw17ch> '10' is more of a guideline to prevent you from reproducing the paper on the subject =)
12:31:43 <conal> are the arrays strict & unboxed?
12:31:45 <sw17ch> not that i think you yourself are prone to do tyat, it's more that i feel i end up asking enough questions to have that effect.... dons, was nice enough to walk me through monads a few weeks back and i feel i stole 2 hours of his night
12:31:56 <conal> i.e., are the elements unboxed?
12:32:00 <thoughtpolice> -fvectorise will (i think) simply allow that nice syntax to be properly desugared to package ndp's high performance combinators, which do the actual grunt work
12:32:45 <thoughtpolice> because without that you have to deal with the manual syntax yourself
12:32:58 <thoughtpolice> see http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
12:33:44 <conal> i wonder if there's an elegant & efficient way to fill up C-style arrays to pass to OpenGL etc.  and in particular, via parallel arrays.
12:34:07 <sw17ch> thoughtpolice: on a related subject, am I wrong in thinking that it's "possible" to run every function call in a haskell program in it's own thread without having race conditions?
12:34:18 <conal> my image stuff is tremendously parallelizable.
12:34:45 <firefly> is there a "cmmcolour" just like there is an hscolour?
12:34:58 <ddarius> sw17ch: No, you are not (roughly)
12:35:33 <sw17ch> Cool... so, in the age of deca-cores we're headed for... haskell wins out?
12:35:39 <ddarius> sw17ch: Every application f m n, f, m, and n and can sparked in it's own "thread" and executed.
12:35:43 <thoughtpolice> i don't know exactly how to answer, but if you're dealing with pure functions, scalable parallelization works a lot easier
12:35:55 <dons> sw17ch: purity, native code, light threads, is what you need
12:36:02 <dons> so that's not a very large set of languages
12:36:02 <thoughtpolice> the vectorisation stuff depends largely on purity
12:36:03 <ddarius> sw17ch: Yes and no.  Parallelizing -everything- is not usually a win.
12:36:20 <ddarius> sw17ch: The important thing is having the right granularity.
12:36:26 <sw17ch> ddarius: of course not... the trick is determining how much to parallelize
12:36:33 <sw17ch> er... that's better than what i said
12:36:34 <sw17ch> :0
12:37:08 <thoughtpolice> in any case once once ndp is more readily available for ghc 6.8 i will have some fun with it if possible. especially if the desugaring all works properly in a way where -fvectorise can show some nice performance increases
12:37:11 <sw17ch> but haskell fits the "pipe lining" thread model quite well. f is in thread 1, g is in thread 2... etc
12:37:17 <ddarius> sw17ch: In slogan form, for Haskell "Automatic parallelization is easy, efficient parallelization is (still) hard."
12:38:04 * ddarius suspects that much of the parallel thread array stuff will be useful even for sequential programs simply as a better way to fill arrays.
12:38:14 <ddarius> s/thread//
12:38:15 <esap> Maybe something that would group functions based on size and choose large enough pieces for threads.
12:38:24 <thoughtpolice> the slogan definately says something nice, at least. :)
12:38:30 <ddarius> esap: That "something" is called the programmer.
12:38:57 <sw17ch> ddarius (or any one else): dealing with the hard part there... what if compilers were allowed to optimize parallel programs "on the fly". initially make everything a thread, then start grouping the shortest sequential threads together until some optimum is reached?
12:39:07 <Shurique> is there an action that returns the width of the user's terminal?
12:39:12 <sw17ch> esap: bingo
12:39:42 <sw17ch> esap: my thought is to "cook" the program for a while. allow it's use to define how it's optimized
12:39:43 <esap> ddarius: usually yes. I suppose automatically finding cohesive pieces of code is hard.
12:39:45 <ddarius> sw17ch: There is research in that line.  And I'm sure there has been research in that direction decades before as well.
12:40:29 <thoughtpolice> Shurique: you can use the hscurses.
12:40:58 <thoughtpolice> Shurique: vty might have support for it too but I wouldn't know. you can also pull a 'tiny' ncurses binding from hmp3 that offers that too
12:41:17 <sorear> vty *does* have support for it
12:41:29 <sorear> or you could just pull the gwinsz.c file from vty
12:41:34 <thoughtpolice> well there you go :)
12:41:57 <sorear> note that there is no portable way to do this, I had to use an (ancient BSD, so widely supported) ioctl
12:42:35 <Shurique> that's fine
12:42:44 <Shurique> I'll explore these options, thanks!
12:45:21 * ddarius remembers when this paper was new: http://www.cse.unsw.edu.au/~chak/papers/CK03.html
12:45:22 <lambdabot> Title: Research Papers of Manuel Chakravarty
12:45:39 <dons> mm
12:45:41 <esap> Btw, does GHC have support for XShm extension?
12:45:47 <dons> a lot has happened since then, ddarius , eh?
12:45:53 <dons> we got some fusion going on
12:46:35 <ddarius> It was an exciting paper.
12:48:33 * esap couldn't find any reference to XShm from Graphics.X11.
12:49:46 <dons> i don't know of a binding
12:49:52 <dons> but would be happy to accept working patches to the X11 li
12:49:53 <dons> v
12:49:54 <dons> b
12:51:59 <esap> maybe I'll write something. I already have something that worked on earlier version of the lib, but was broken by latest stable version
12:52:23 <esap> some very bad hack though :-(
12:55:33 <sw17ch> i've got a feeling most sweet technology started as a bad hack
12:56:29 <puusorsa> surprise :)
12:56:31 <cedricshock> ?hoogle liftM
12:56:32 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
12:56:32 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:56:32 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
12:58:05 * dcoutts pushes initial nhc98 support to Cabal HEAD
13:00:51 <dons> sweet
13:02:52 <davidL> will ghc -cpp take care of #include statements?
13:06:50 <Saizan> is there an easy way to know if you are on a little or big endian machine at compile time?
13:07:21 <Saizan> s/on/compiling for/
13:07:26 <dons> write a word in host order, read it back
13:08:12 <ddarius> davidL: It should although you may want to stick an #include in a comment if there is C code contained in it.  It's probably better to add the include via a flag.
13:08:19 <Saizan> mmh, that requires TH, i wished for something like a CPP constant
13:08:30 <ddarius> Saizan: Just use a CPP constant.
13:09:11 <Saizan> ddarius: and write a configure script to set it?
13:10:51 <hpaste>  davidL pasted "something wrong with ghc's c pre-processor?" at http://hpaste.org/4066
13:12:43 <ddarius> Saizan: I would just use a GCC header fiel.
13:15:15 <Saizan> ddarius: ah, ok, i'm just almost clueless on C build systems and similar :)
13:16:16 <opqdonut> make is underappreciated
13:16:50 <ddarius> davidL: CPP should be including the content of the file verbatim, so anything that isn't interpreted by it will remain.
13:18:01 <davidL> ddarius: what's that have to do with "/usr/include/zconf.h:261:27: parse error on input `;'"
13:19:03 <davidL> libpng depends on zlib but that doesn't really explain the error
13:20:22 <davidL> by the way that code works fine when I used hsc2hs
13:20:25 <gwern> so, I'm trying to sign up on community.haskell.org, and the web form seems to be broken. anyone know whether there's someone I can jsut email instead?
13:21:19 <ddarius> hsc2hs presumably handles #includes in a more sophisticated manner
13:21:54 <davidL> would using cabal simplify all of this?
13:22:12 <byorgey> gwern: hm, maybe Igloo?
13:22:26 <gwern> byorgey: oh, btw. the site seems to be back up
13:22:37 <byorgey> gwern: yup.
13:23:10 <gwern> @seen Igloo
13:23:10 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 3h 20m 17s ago.
13:23:27 <vali> when will "the great language shootout" run the tests with ghc 6.8.1?
13:25:45 <dons> once its in gentoo
13:26:00 <vali> aah
13:26:08 <gwern> dons: do they follow ~ or stable?
13:35:45 <grahamhutton> hi andy!
13:39:01 <thoughtpolice> anybody got a link for the haskell workshop 07 papers/videos? i was looking at the 'lightweight concurrency primitives for ghc' vid but i'd like to go along with slides
13:40:01 <grahamhutton> http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
13:40:03 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
13:41:54 <Betovsky> hi
13:42:06 <dons> hey Betovsky. welcome
13:42:10 <Betovsky> is there a way to see if given 2 functions they are the same?
13:42:21 <dons> compare them for all input values?
13:42:22 <Betovsky> for exemplo
13:42:44 <liyang> grahamhutton: evening. What IRC client are you using? Could you see if there's another window that's popped up? (It'll say `liyang' on it or something. :)
13:43:04 <Betovsky> do { f1 <- [(+), (*)] ; f2 <- [(+), (*)]; guard (f1 == f2); ...
13:43:08 <grahamhutton> i'm using colloquy
13:43:18 <harlekin> dons: Good to see you. I am trying to compile haskell-plugins from hackage. But it won't compile, though I think I fulfill the dependencies. Got some time for that?
13:43:23 <shachaf> It doesn't look like grahamhutton is identified.
13:43:25 <dons> harlekin: grab the darcs repo
13:43:30 <ddarius> Betovsky: No, it is not possible.
13:43:31 <byorgey> Betovsky: in general, that is not possible.
13:43:35 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/hs-plugins
13:43:37 <lambdabot> Title: Index of /~dons/code/hs-plugins
13:43:39 <Betovsky> oky
13:43:45 <liyang> shachaf: which means I can't send /msgs? :3
13:43:49 <harlekin> dons: Thanks. Will try that.
13:43:58 <faxathisia> liyang: you can' he should get it, but not able to reply
13:44:05 <grahamhutton> liyang: i never managed to get private messages to work so far.
13:44:12 <byorgey> Betovsky: and it's not a limitation of Haskell, it's just the logic of it: the only way to compare two functions for equality is, as dons said, to compare their outputs for all possible input values.
13:44:12 <shachaf> liyang: It possibly means you can't receive them.
13:44:12 <liyang> ah. I. See.
13:44:16 <faxathisia> grahamhutton: /msg nickserv help
13:44:22 <faxathisia> grahamhutton: and you can help register as well
13:44:28 <Betovsky> yes i thought so
13:44:35 <Betovsky> but sometimes im amazed with haskell can do
13:44:47 <byorgey> Betovsky: heh, fair enough =)
13:44:53 <faxathisia> (nickserv will get messages even though normal users wont)
13:45:06 * liyang is needed downstairs. brb...
13:45:13 <Betovsky> is there a good way for the example above
13:45:27 <Betovsky> to f2 get a member of the list except the one that is f1 ?
13:45:32 <dons> ?check \x -> (join (*)) x == (^2) (x :: Int)
13:45:37 <lambdabot>  OK, passed 500 tests.
13:45:46 <dons> ?check \x -> (join (+)) x == (^2) (x :: Int)
13:45:46 <lambdabot>  Falsifiable, after 0 tests: 1
13:45:48 <shachaf> liyang: You can /msg nickserv set unfiltered on, if you prefer.
13:45:56 <dons> ?scheck \x -> (join (*)) x == (^2) (x :: Int)
13:45:56 <lambdabot>   Completed 13 test(s) without failure.
13:46:04 <pejo> grahamhutton, you need to register your nick to get the messages through normally. In some status window you probably have some nasty stuff saying you're not allowed to message people.
13:46:49 <byorgey> Betovsky: one way that comes to mind is that you could choose f1 and f2 from a list of integers, have a check for equality, and then use them to index into a list of functions.
13:47:03 <Jedai> ?scheck \x -> (join (+)) x == (*2) (x :: Int)
13:47:04 <lambdabot>   Completed 13 test(s) without failure.
13:47:25 <Betovsky> byorgey ...
13:47:35 <Betovsky> i feel so dumb now..
13:47:56 <byorgey> Betovsky: don't bother =)
13:47:58 <Beelsebob> :t join
13:47:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:48:08 <pejo> Doh, faxathisia answered that just a few lines below.
13:48:10 <ddarius> @index reallyUnsafePtrEq
13:48:10 <lambdabot> bzzt
13:48:33 <thoughtpolice> grahamhutton: thanks. :) aside from vids, you wouldn't happen to know where slides could be found, do you?
13:49:20 <thoughtpolice> ah nevermind
13:49:23 <opqdonut> is there a standard reference on the denotional semantics of haskell?
13:49:55 <grahamhutton> thoughtpolice: sorry, i only know where the vids are
13:50:23 <grahamhutton> pejo: many thanks - i'm now registered!
13:50:28 <ddarius> opqdonut: Haskell doesn't have a formal semantics.
13:50:33 <thoughtpolice> it's cool. i didn't find the slides, but found the paper for it
13:50:50 <ddarius> thoughtpolice: You could email the author.
13:51:17 <opqdonut> ddarius: oh ok
13:51:42 <opqdonut> i'm watching thru this german lecture series that seems to be heading towards them
14:00:11 <harlekin> dons: I keep getting the same error: http://pastebin.archlinux.org/19946
14:00:28 <dons> oh, you're using 6.8?
14:00:33 <dons> plugins haven't yet been ported to 6.8
14:01:20 <harlekin> dons: Okay. Correct, I am using 6.8.1. Do you suggest using an older version or will it be ported soon?
14:01:55 <dons> it won't be ported terribly soon, 6.6.1 is a good choice till then, if you need plugin support
14:02:30 <harlekin> Okay. Thank you. (:
14:02:34 <geocalc> dons failure
14:03:19 <ddarius> @donsnack
14:03:19 <lambdabot> :)
14:04:39 <ski> @botsmack
14:04:39 <lambdabot> :)
14:04:39 <geocalc> dons=<< i suggest you to make effort for 6.8.2 anyway
14:04:49 <dons> thanks for the suggestion :)
14:14:45 <noobie> in haskell SOEGraphics when a windows is closed e.g. closeWindow w | how do u make a program automatically load after completion
14:14:54 <noobie> in haskell SOEGraphics when a windows is closed e.g. closeWindow w | how do u make a program automatically load after completion
14:15:40 <jdrake> Has anyone ever heard of raytracing, but for 2d images objects? (would this be compositing?)
14:15:51 <noobie> in haskell SOEGraphics when a windows is closed e.g. closeWindow w | how do u make a program automatically load like my function  [main] after completion, tried return main, but it doesn't seem to workk
14:15:57 <faxathisia> jdrake: raycasting?
14:16:03 <faxathisia> jdrake: like Wolfenstein 3D
14:16:06 <harlekin> dons: Do I have to compiled all packages I've compiled with 6.8.1 in order to get lambdabot to compile again against 6.6.1?
14:16:16 <dons> yep
14:16:23 <dons> i recommend cabal-install
14:16:30 <dons> for pulling all the deps and building them
14:16:48 <jdrake> faxathisia: hmm, not quite. Think the parts of a chart layered upon each other with zorders. The point of view is directly on, no wierd angles.
14:16:51 <harlekin> Thanks. I'll check out cabal.
14:16:55 <noobie> any help??
14:17:09 <faxathisia> jdrake: I think you should look at conals work actually
14:17:18 <faxathisia> there is some really nice stuff which I think is relevant
14:17:28 <jdrake> faxathisia: Where might this be found?
14:17:50 <faxathisia> http://conal.net/Pan/
14:17:50 <lambdabot> Title: The Pan Home Page
14:18:05 <noobie> closeWindow w return (other func) doesn't seem to work
14:18:06 <faxathisia> there is also a video talk about it
14:18:26 <jdrake> THIs looks interesting
14:18:49 <noobie> everyone's busy, bye then
14:18:54 <jdrake> I am not specifically using haskell for this, so I am looking for general theory as it relates to functional languages.
14:19:10 <oerjan> noobie: i'm not busy i just don't know anything about SOEGraphics
14:19:17 <faxathisia> jdrake: yeah I think you will be like this video then :p
14:19:24 <faxathisia> hm lets see
14:19:29 <noobie> ok
14:19:53 <gwern> noo... community.haskell.org is still teh broke: 'Unexpected stderr: "rt: Server error: Internal Server Error (500)\n"'
14:19:55 <jdrake> One of the problems I have is thinking how to do things in a functional style with immutable data.
14:20:19 <conal> jdrake: i hadn't thought of Pan as 2D raycasting, but i guess it fits.
14:20:37 <faxathisia> conal: hello
14:20:41 <faxathisia> :)
14:20:43 <conal> faxathisia: hi
14:20:56 <jdrake> I am actually using erlang, so some sequential stuff can be done.
14:21:01 <conal> faxathisia: thanks for the advertisement :)
14:21:19 <faxathisia> conal: well I thought it's a great example of functional programming
14:21:30 <faxathisia> at least I think I picked up a lot from it
14:21:40 <faxathisia> I can't find this video ..
14:21:57 <faxathisia> oh
14:22:01 <jdrake> I might not be able to be online for much longer :p
14:22:04 <faxathisia> jdrake: http://www.uwtv.org/programs/displayevent.aspx?rID=2124&fID=368
14:22:04 <lambdabot> Title: UWTV Program: Functional Image Synthesis
14:22:32 <ddarius> I finally got around to looking at TyPiCal.  These (old) slides are cool especially pg. 36
14:22:38 <ddarius> http://www.kb.ecei.tohoku.ac.jp/~koba/slides/UNU-IIST.pdf.gz
14:23:34 <jdrake> I was thinking of an 'Algebra of Images', wondering if that would make any sense.
14:24:02 <faxathisia> jdrake: yes that's what the video is about basically
14:24:11 <jdrake> Cool stuff
14:24:27 <conal> jdrake: totally.  see the Pan papers & talk.  i'd be happy to discuss it with you.  i'm often on IRC.
14:24:46 <dobblego> ?hoogle (Monad m) => m a -> Int -> a
14:24:46 <lambdabot> Data.Graph.Inductive.Monad.newNodesM :: GraphM m gr => Int -> m (gr a b) -> m [Node]
14:24:52 <jdrake> conal, I am most interested as long as things don't go too far beyond me :p
14:25:10 <dobblego> is there a (!!) function somewhere, but where [] is a type argument?
14:25:12 <conal> Start with the Bridges 2001 paper at http://conal.net/Pan/papers.htm .
14:25:12 <lambdabot> Title: Papers
14:25:29 <conal> jdrake: that "Start with ..." was for you
14:25:34 <oerjan> dobblego: huh?
14:25:47 <byorgey> dobblego: some sort of "Indexable" type class?  nothing like that exists AFAIK
14:25:48 <dobblego> oerjan, m a -> Int -> a
14:26:09 * ddarius had exactly the same response as oerjan 
14:26:10 <byorgey> dobblego: that type doesn't make sense.  not all monads are 'indexable'
14:26:12 <dobblego> byorgey, something like that, but I'm hoping it can be constructed from an existing type-class(es)
14:26:12 <oerjan> dobblego: i guess you can do it with foldable somehow
14:26:29 <conal> ?ty sequenceM
14:26:31 <lambdabot> Not in scope: `sequenceM'
14:26:38 <dobblego> yeah, Foldable crossed my mind, but I can't think of the solution, since foldl is tail recursive
14:27:17 <conal> ?ty sequenceA
14:27:17 <lambdabot> Not in scope: `sequenceA'
14:27:19 <dobblego> byorgey, I just defaulted to Monad to make my point clear :)
14:27:25 <conal> ?ty Data.Traversable.sequenceA
14:27:25 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
14:27:37 <oerjan> dobblego: Foldable already has toList
14:29:01 <jdrake> One problem that I have thought of, with regards to images, is how to store them. With a language like erlang, I am not seeing any data type that would offer efficient storage.
14:29:48 <ddarius> Doesn't Erlang have a type of just amorphous blobs of data.
14:30:28 <oerjan> dobblego: and both foldl and foldr
14:31:06 <jdrake> ddarius: I haven't seen any reference to a datatype like that.
14:31:22 <dobblego> oerjan, I'm still not clear on how (Foldable f) => f a -> Int -> a could be written given this
14:32:02 <ddarius> http://www.erlang.org/doc/reference_manual/data_types.html#2.4
14:32:03 <lambdabot> Title: Data Types
14:32:17 <oerjan> dobblego: use !! with the result of toList
14:33:16 <jdrake> ddarius: I have seen that type, I am not sure of its efficiency, but it is a possibility.
14:34:22 <jdrake> I am not entirely sure if erlang is appropriate for this mind you.
14:34:43 <ddarius> jdrake: It depends on what you're going for.
14:35:29 <jdrake> ddarius: A certain level of efficiency is required.
14:36:15 <jdrake> But in most cases it won't matter because these things are only generated once.
14:39:00 <jdrake> Q: Can a haskell program have modules that work in a similar way to DLL based plugins?
14:39:56 <Lemmih> jdrake: And how's that?
14:40:00 <allbery_b> @where hs-plugins
14:40:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:40:13 <allbery_b> doesn't wiork with 6.8.1 yet
14:41:07 <jdrake> Lemmih: To which question is your reply?
14:41:45 <Lemmih> jdrake: I was wondering how DLL plugins works.
14:42:13 <geocalc> wat is it ?
14:42:26 <geocalc> what*
14:42:41 <SamB_XP> Lemmih: rather like .so plugins
14:43:15 <jdrake> Lemmih: Imagine a wiki that has different processing modes that are provided at run time, not necessarily known at compile time. Only their structure needs to be known.
14:43:31 <cinema> JohnMeacham_: ping
14:43:55 <geocalc> do you mean shared ?
14:44:25 <jdrake> What my ultimate target that I am looking to do is a wiki of sorts, erlang can surely do most of what is required. But there are other components as well.
14:44:37 <jdrake> geocalc: shared in one sense I suppose
14:44:54 <geocalc> hehe
14:45:26 <SamB_XP> jdrake: what particular attributes of DLL plugins are you wondering about?
14:46:54 <jdrake> SamB_XP: All that is necessary is to be able to load them up to know what they provide and then use the appropriate one. So for example, an image input plugin might support png input and another tiff. You load both up and see what they provide and then use whichever one, and then preferablly be able to unload them, but this might not be required.
14:47:21 <conal> jdrake: btw, i just fixed the broken links at the end of http://conal.net/Pan/papers.htm
14:47:21 <lambdabot> Title: Papers
14:47:25 <SamB_XP> why wouldn't you be able to do that?
14:48:01 <jdrake> conal: ok
14:48:28 <jdrake> SamB_XP: The only real experience I have had with functional programming was with Ocaml a while back, which didn't support it.
14:49:21 <jdrake> conal: On the functional images paper, I am quite impressed so far. Not entirely sure how useful it ultimately is, but it is looking good.
14:49:29 <SamB_XP> jdrake: well, er, actually you DO need hs-plugins...
14:49:50 <Lemmih> Or the ghc api.
14:50:09 <SamB_XP> Lemmih: yeah, if you are crazy
14:50:23 <jdrake> BTW, does hs-plugins work on windows at all?
14:50:32 <SamB_XP> not a clue
14:50:42 <jdrake> For practical reasons I develop on windows, but anything that is deployed is on linux.
14:50:43 <conal> jdrake: i'm updating that work to play with "tangible functional programming", which you may like also.  see the google techtalk link at the top of my home page.
14:50:50 <Lemmih> SamB_XP: hs-plugins is a pain to build. The ghc api is a pain to use. Pick your torture. (:
14:51:15 <jdrake> conal: Have you ever heard of 'domtool'?
14:51:29 <conal> jdrake: nop
14:51:31 <Lemmih> (building == updating the interface parser by hand)
14:51:33 <SamB_XP> I heard something about hs-plugins using GHC-provided APIs in the future, instead of hacked loaders?
14:51:59 <jdrake> Its a purely functional language that the hosting cooperative uses (hcoop.net) to configure domains and webserver configs. It is done in MLton, and it is quite sweet.
14:52:10 <thoughtpolice> the thought of it becoming a client of the ghc api has been addressed.
14:52:28 <conal> jdrake: thanks.  i'll check it out.
14:52:54 <SamB_XP> that seems like the ideal way to let someone else take the torture for you
14:53:03 <jdrake> There is a guy named smerdyakov (#hcoop) that developed it. I am not sure if anyone else actually understands it though :p
14:53:04 <thoughtpolice> but right now i think the api might lack some things that might be needed to bring it to that state. something to look at for 6.10?
14:53:47 <SamB_XP> thoughtpolice: I heard something to the effect that this deficiency in the GHC API was in the process of being corrected?
14:54:28 <thoughtpolice> SamB_XP: i'm not sure, it's more 'there' than 'designed,' so i'm sure any work in that area would be very much appreciated.
14:54:49 <thoughtpolice> right now my library can achieve some similar functionality to hsplugins, sans module unloading. which is what you want for hot-code swapping
14:55:11 <thoughtpolice> and from the looks of it there's no basic primitive in the api to provide that, although perhaps nulling out a session and then reloading it might work
14:55:35 <jdrake> conal: I am not sure hat lerpC does exactly by looking at the function.
14:56:01 <conal> jdrake: where are you reading?
14:56:29 <jdrake> Page 13 of http://conal.net/papers/functional-images/fop-conal.pdf
14:56:45 <jdrake> It looks like 4 corners.
14:57:26 <thoughtpolice> but i haven't investigated it. making it a client of the API would be a big benefit to hsplugins though, and getting it to such a state would probably make other life easier on other projects too (i think spj recommended liskell become a client of the api too, for example)
14:58:33 <conal> jdrake: lerpC linearly interpolates between two colors
14:58:55 <jdrake> I got that,but I fail to see how the function definition meets it.
14:58:58 <conal> jdrake: and bilerpC bilinearly interpolates between four colors
15:00:05 <conal> jdrake: it interpolates each of the four components of a color: blue, green, red, and alpha
15:00:24 <conal> jdrake: "h" does the numeric interpolation.
15:00:40 <jdrake> conal: Is this sort of thing easy to downoad and test out?
15:02:17 <conal> jdrake: sadly, no.  Pan bitrotted.  And I haven't released Pajama, a newer version that compiles into Java.  There are a few non-compiler spin-offs.  I don't know what status.
15:02:44 <jdrake> heh, that kind of sucks
15:03:06 <conal> jdrake: yeah.  it was a fun toy.
15:03:16 <faxathisia> well the concepts remain valid
15:03:56 <jdrake> conal: Could you imagine a language that is as safe as haskell or SML that can be used to composite images (in the fashion of say excel's charts)?
15:04:06 <conal> and it motivated my Eros work (tangible functional programming), which will include Pan in a way that non-programmers can author.
15:04:54 <jdrake> conal: You mgith like this: http://wiki2.hcoop.net/DomTool/Examples
15:04:54 <lambdabot> Title: DomTool/Examples - HCoop Wiki
15:05:25 <conal> jdrake: ("Could you imagine ..").  Certainly!
15:05:40 <jdrake> conal: In a practical way :p
15:05:58 <conal> jdrake: speed?
15:06:13 <jdrake> The theory being that you could define a function in said language that could take data and render a chart.
15:06:46 <jdrake> conal: Speed that does not require real time, but preferably fast enough for web rendering (cached?)
15:07:25 <conal> jdrake: oh, gotcha.  data rendering.  sure, and plenty fast enough.
15:07:33 <davidL> is there a way to simulate #include "foo.h" for a module with cabal?
15:08:20 <SamB_XP> conal: Java?
15:09:00 <conal> SamB_XP: about Pajama?
15:09:25 <SamB_XP> yeah
15:09:33 <SamB_XP> like, what does that give you?
15:09:50 <jdrake> I should ask Smerdyakov how he made his language. I have no idea how something like that would be done :p
15:10:14 <SamB_XP> jdrake: ... ?
15:10:18 <conal> SamB_XP: yeah.  by compiling into java and then to JVM, i get pretty good performance of interactive imagery that runs widely in browsers.
15:10:35 <SamB_XP> it does?
15:10:44 <conal> SamB_XP: which part?
15:10:53 <SamB_XP> "runs widely in browsers"
15:11:03 <jdrake> SamB_XP: Smerdyakov made a language for managing webserver configurations, purely functional.
15:11:34 <SamB_XP> jdrake: the hard part about making a language is figuring out what it should be, isn't it?
15:11:39 <conal> SamB_XP: as widely as anything i know of for the performance ballpark.
15:12:00 <SamB_XP> conal: fair enough
15:12:17 <SamB_XP> I certainly have not got silverlight installed on anything...
15:12:43 <jdrake> SamB_XP: Only partially. The language is pretty similar to existing functional languages.
15:13:51 <jdrake> I wonder how you could implement a language in haskell or sml (et al.) that is not a horrifying amount of work.
15:15:05 <ddarius> jdrake: ?
15:15:11 <SamB_XP> well, the first step is to beg, borrow, steal, or even write a parser for it
15:15:22 <faxathisia> jdrake: Smerdyakov will write ten million lines of code in a second though won't he? :p
15:15:24 <mikael> provided the language isn't horrifyingly complex and has nonhorrifying evaluation semantics it'd probably be pretty breezy with parsec and a good old recursive evaluate function
15:15:47 <jdrake> faxathisia: He does seem superhuman sometimes.
15:16:04 <SamB_XP> you could use either Parsec or Alex/Happy (or Happy and a self-made lexer)
15:16:15 <SamB_XP> depending on how horrifying the lexical syntax of the language is
15:16:31 <faxathisia> yeah just making a decent AST and writing evaluation rules is quite simple
15:16:42 <faxathisia> (unless like mikael said)
15:16:43 <jdrake> Is there such a thing as a 'functional scripting language'? Something like a haskellscript sort of thing?
15:16:52 <conal> jdrake: you could also skip the syntax altogether and do an "embedded language"
15:17:00 <faxathisia> writing a parser for a language with Parsec is fun but it's still much more code than the other parts :/
15:17:14 <jdrake> I might look into it somewhat.
15:17:24 <jdrake> But I think I must run for about half an hour or s.
15:17:28 <jdrake> I will be back though.
15:18:04 <conal> jdrake: later
15:18:09 <jdrake> Thank you all very much for your assistanc.
15:18:27 <faxathisia> hnf
15:20:00 <gwern> @src fromIntegral
15:20:00 <lambdabot> fromIntegral = fromInteger . toInteger
15:40:37 <alexj> anyone know how to do standalone deriving with template haskell?
15:42:15 <ddarius> @google DeriveTH
15:42:17 <lambdabot> http://swik.net/deriveth
15:42:17 <lambdabot> Title: deriveth - SWiK
15:42:59 <Lemmih> alexj: I don't think it's possible yet.
15:43:53 * jdrake est ici, maintenant!
15:44:03 <faxathisia> hi :)
15:45:06 <newsham> bonjour
15:46:15 <jdrake> Les yeux de moi regard les persons de interesante.
15:46:28 <jdrake> That is my last attempt at botched french for the night.
15:46:41 <faxathisia> @babel fr en yeux
15:46:42 <lambdabot>   eyes
15:47:27 <jdrake> It should be 'The eyes of me watch the people of interest.'
15:48:46 <faxathisia> I find it strange and kind of annoying how hard it is to learn and easy to forget foreign language compared to programming languages (for me)
15:49:11 <faxathisia> (I know I knew what 'yeux' meant in the past..)
15:49:11 <ddarius> foreign languages are far, far more complicated than any artificial language.
15:50:04 <dons> anyone have suggestions for this questoin: "I also had to build the transitive closure of a binary relation, and I was surprised I couldn't find any library functions to do that" ?
15:50:38 <ddarius> I thought someone did make such a library.
15:50:41 <faxathisia> which language does have library for that I would be interested to know
15:50:41 <vincenz> dons: fixM
15:51:08 <ddarius> @google site:haskell.org inurl:pipermail relations "transitive closure"
15:51:09 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2003-November/005433.html
15:51:09 <lambdabot> Title: Type tree traversals [Re: Modeling multiple inheritance]
15:51:18 <ddarius> That's too old.
15:51:38 <vincenz> dons: reminds me of that code based on fixM written by dpiponi
15:51:49 <vincenz> dons: that generated a transitive closure in a sense
15:51:52 <dons> yeah, i'm sure i've seen a thread on this at some piont this year
15:51:55 <dons> vincenz: yeah.
15:52:34 <Toxaris> faxathisia: I find it not harder to remember the meaning of words in some foreign language then to remember the exact meaning of library functions
15:52:59 <oerjan> > take 4 ([1,2,3] `union` [4,undefined])
15:53:01 <lambdabot>  [1,2,3,4]
15:53:27 <Toxaris> faxathisia: but fortunately there are dictionaries resp. api descriptions for both natural and artifical languages
15:53:37 <ddarius> > [1,2,3,3] `union` [2,4,4]
15:53:38 <lambdabot>  [1,2,3,3,4]
15:54:29 <faxathisia> Toxaris: true, I suppose it could be lack of immersion/continued use
15:55:12 <lament> ddarius: "human languages", not "foreign languages" :)
15:55:42 * ddarius finds English even simpler than programming languages.
15:56:25 <dons> so what's the recommendation for binary relations libs?
15:56:32 <dons> roll your own from some monadic tricks?
15:57:03 <ddarius> Find the one that was made.
15:57:10 * ddarius tries something else.
15:57:20 <wli> Symmetric?
15:57:22 <ddarius> @google site:haskell.org inurl:pipermail "Data.Binary"
15:57:22 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2007-September/031659.html
15:57:22 <lambdabot> Title: [Haskell-cafe] Data.Binary Endianness
15:57:28 <ddarius> @google site:haskell.org inurl:pipermail "Data.Relation"
15:57:28 <lambdabot> No Result Found.
16:00:38 <dons> ddarius: any other keywords i can try?
16:01:53 <ddarius> http://www.haskell.org/haskellwiki/Applications_and_libraries/Data_structures  There's a Data.Relation on this.  I'm not sure what all it does.
16:01:54 <lambdabot> Title: Applications and libraries/Data structures - HaskellWiki, http://tinyurl.com/247ycb
16:03:16 <ddarius> http://wiki.di.uminho.pt/twiki/bin/view/Personal/Joost/RelationsInHaskell
16:03:18 <lambdabot> http://tinyurl.com/2h6jm3
16:03:44 <jdrake> Would you guys understand a 'Typing' definition for an integer constant that is like this:  G |- Int : int
16:03:55 <jdrake> It is part of domtool's language reference, but I understand it not.
16:04:40 <ddarius> It seems to say Int has type int in context G
16:04:56 <ddarius> But it should tell you what the judgement stands for somewhere.
16:05:39 <jdrake> I have never seen |- before.
16:06:20 <faxathisia> jdrake: http://mumble.net/~campbell/images/HM-t-shirt.png
16:06:36 <conal> faxathisia: lol
16:07:03 <jdrake> faxathisia: Might be useful as a shirt :p
16:07:16 <faxathisia> jdrake: anyway I would say read TAPL is really nice
16:07:20 <faxathisia> em
16:07:33 <darinm> there is a shirt with that
16:07:36 <faxathisia> Types and Programming Languages  http://www.cis.upenn.edu/~bcpierce/tapl/
16:07:36 <lambdabot> Title: Types and Programming Languages
16:07:41 <jdrake> What is TAPL?
16:07:47 <faxathisia> if you're library has it or anything
16:07:48 <darinm> Types and Programming Languages
16:08:56 <darinm> or if you want something free, you can check Harper's book (draft)
16:08:58 <darinm> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
16:09:19 <jdrake> I like free :p
16:09:26 <jdrake> Although $46.16 isn't bad for it either
16:10:13 <darinm> it's worth the money if you're into that stuff
16:10:16 <conal> jdrake: or take a simple explanation: G is a collection of name/type pairs, and G |- e : t says that given the typings in G, e can be determined to have type t.
16:11:09 <adrian> Does anyone have experience with passing a raw struct (not a pointer to a struct) to a C function via the FFI?
16:11:18 <jdrake> oh yes, Int is an integer constant and I guess 'int' is the type.
16:11:21 <ddarius> jdrake: Know any logic programming?
16:11:35 <jdrake> ddarius: Not particularily
16:11:43 <conal> jdrake: yes, and with no restrictions on G
16:12:03 <faxathisia> adrian: It's not possible with haskells FFI
16:12:17 <jdrake> I would love to be able to program a fully typesafe microcontroller language :p
16:12:21 <ddarius> jdrake: By 'not particularly' do you mean 'no'?
16:12:23 <conal> jdrake: if you look at the lambda case, you can see how typings get added to G.
16:12:27 <faxathisia> adrian: You may learn about the ABI for your system and write appropriate code if it's possible .. or write a glue code wrapping the C function
16:12:30 <jdrake> ddarius: yes :p
16:13:05 <oerjan> faxathisia: i vaguely recall someone implying that one of the c2hs things handles such matters?
16:13:11 <adrian> faxathisia: thanks. that's sort of what I expected but I wanted to confirm
16:13:22 <goalieca> @src product
16:13:22 <lambdabot> product = foldl (*) 1
16:13:39 <conal> jdrake: you can think of those typing rules as a program either to verify that an expression has a type in some context (G) or to compute the type from the context and expression.
16:13:59 <conal> jdrake: (a functional program)
16:14:17 <davidL> hmm, I am doing a foreign import ccall on this C function: png_read_png(png_ptr, info_ptr, png_transforms, NULL) ... that one of the  c2hs things handles such matters?
16:14:28 <davidL> err
16:14:42 <ddarius> typecheck :: Map Variable Type -> Expression -> Type -> Bool; typecheck G e t = ...
16:14:51 <jdrake> I wonder if this core domtool language is capable of being used for generic purposes :p
16:15:18 <conal> jdrake: perhaps, but i bet haskell would be more fun. :)
16:15:36 <davidL> hmm, I am doing a foreign import ccall on this C function: png_read_png(png_ptr, info_ptr, png_transforms, NULL) ... what should be in place of XXX? f_png_read_png :: Ptr a -> Ptr b -> Int -> XXX
16:16:05 <jdrake> conal: Even better- port it to haskell :p
16:16:21 <faxathisia> even better write a haskell SML ffi ?? :P
16:16:23 <conal> jdrake: as an embedded language.
16:16:40 <ddarius> faxathisia: Haskell can talk to SML.
16:16:49 <faxathisia> oh how?
16:17:00 <ddarius> The FFI
16:17:23 <jdrake> conal: If you can imagine a wiki page that has an embedded script to generate a particular graphic, say a vector graphically demonstrating 3+4i, and it generates the image when the wiki page is generated (and caches).
16:17:31 <jdrake> That is the sort of thing I would love to have.
16:17:52 <faxathisia> the C FFI or is there a SML one?
16:18:03 <ddarius> @google Haskell Server Pages
16:18:05 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp/
16:18:05 <lambdabot> Title: HSP - Haskell Server Pages
16:18:57 <ddarius> faxathisia: The FFI is not required to be just C, but yes, worst-case scenario I'm sure SML can expose it's functions via a C interface and Haskell can definitely use them.
16:19:00 <jdrake> smlweb :p
16:19:03 <conal> jdrake: sounds nifty.  and yeah, see HSP.  also, client-side execution could be cool.  then you could do interactive graphics.
16:19:21 <faxathisia> I see
16:19:54 <jdrake> conal: Not too interested in client side, more interested in backend generating user viewable pages that are not modifiable by the user.
16:21:05 <jdrake> Is a 'functor' the same thing as a first class function?
16:21:13 <Cale> jdrake: nope
16:21:33 <Cale> jdrake: A functor is a type constructor which supports an operation like 'map'
16:21:38 <Cale> @src Functor
16:21:38 <lambdabot> class  Functor f  where
16:21:38 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:22:14 <Cale> So more or less, it's a data structure with homogeneously typed contents which has a way to apply a function to all the elements held inside it.
16:22:17 <kpreid> Is there a type which is a container of no values of a particular type, and thus implements Functor as fmap _ = id?
16:22:30 <Cale> Well, not id
16:22:32 <ddarius> In C++ the term 'functor' -is- used for 'function object' which is a poor man's way of simulating higher order functions.
16:22:43 <Cale> because id would never unify in the right way
16:22:46 <kpreid> Cale: whoops, right
16:22:55 <ddarius> kpreid: newtype Const a = Const
16:22:59 <ddarius> er data
16:23:04 <kpreid> ddarius: I'm asking if it exists already
16:23:16 <ddarius> kpreid: No it doesn't.
16:23:21 <kpreid> \x -> x => id is only universally valid in untyped lambda calculus...
16:23:30 <kpreid> er, untyped whatever
16:24:21 <jdrake> Just to be sure, would it be something like  map `+` [1 2 3 4 5] [1 2 3 4 5]  (not specifically haskel syntax)
16:24:26 <oerjan> newtype Const a b = Const a, surely?
16:24:56 <Cale> jdrake: err, what would you expect that to do?
16:24:58 <oerjan> and instance Functor (Const a) where fmap = id
16:25:14 <oerjan> er no
16:25:16 <Toxaris> instance Functor () where fmap = const id
16:25:24 <oerjan> fmap (Const x) = Const x
16:25:41 <Toxaris> hmm no, you need an * -> * of course :(
16:25:54 <faxathisia> jdrake: in haskell it'd be like map (uncurry (+)) $ zip [1..5] [1..5]
16:25:57 <Toxaris> so data Const a = Const; instance Functor Const where fmap = const id
16:26:19 <ddarius> map (uncurry (+) $ zip .. .. = zipWith (+) .. ..
16:26:21 <jdrake> Cale: [1+1 2+2 ...]
16:26:30 <jdrake> $ does ?
16:26:44 <oerjan> Toxaris: not that either
16:26:55 <ddarius> ($) = id
16:27:00 <ddarius> @src ($)
16:27:00 <lambdabot> f $ x = f x
16:27:03 <oerjan> the phantom type a prevents it from typechecking
16:27:23 <jdrake> ok
16:27:30 <ddarius> oerjan: Indeed.  That is one of the few cases when an unsafeCoerce might not be unreasonable.
16:28:07 <ski> m@(Left _) >>= _ = m  -- is a similar case
16:29:04 <jdrake> There is a thing I want to implement - a versioning file system - on top of the wiki I envision. Is this sort of thing a reasonable thing to make, maybe using some of darcs?
16:29:13 <ski> (s/Left _/Nothing/ is the same)
16:30:43 <resiak> jdrake: have you seen ikiwiki?
16:30:57 <jdrake> resiak: I have heard of it.
16:31:00 <Toxaris> oerjan: hmm yes, after all, it's *not* the same type
16:32:06 <oerjan> Toxaris: easy to wrap and unwrap the constructor though
16:32:23 <resiak> jdrake: okay, just thought i'd mention it since you're talking about a vcs-wiki synergy
16:32:34 <jdrake> resiak: Something like that
16:33:00 <jdrake> A friend of mine once asked, why doesn't any modern unix have a versioning file system?
16:33:11 <oerjan> Toxaris: actually the newtype Const a b = Const a should work even better, since newtype constructors are eliminated on implementation
16:37:26 <newsham> jdrake: darcs, cvs, svn, hg, etc.
16:37:30 <newsham> who needs to complicate the fs?
16:37:56 <Vq^> isn't there some FUSE driver for svn?
16:39:04 <jdrake> newsham: You don't always have everything conveniently saved in a history :p
16:39:45 <thoughtpolice> jdrake: dragonflybsd is planning to implement a filesystem with 'versioning' capabilities. i'm running dfly 1.10 but the fs is scheduled for beta at the 2.0 release
16:40:10 <newsham> fossil/venti?
16:40:36 <thoughtpolice> i believe dillon named it HAMMER or somesuch
16:40:43 <thoughtpolice> there was a link to the spec on reddit a while ago
16:40:50 <newsham> ZFS supports snapshots
16:41:03 <idnar_> snapshots aren't automatic
16:41:09 <Cale> jdrake: that would be zipWith
16:41:14 <idnar_> of course, filesystems don't really have transactional semantics, so there's already a problem
16:41:17 <Cale> > zipWith (+) [1..5] [1..5]
16:41:18 <lambdabot>  [2,4,6,8,10]
16:41:24 <thoughtpolice> yeah. zfs snapshots are pretty nice (ran solaris 10 before i installed fbsd,) but i believe hammer is designed to do this automatically
16:41:28 <jdrake> idnar_: ITS had it apparently
16:41:35 <mikael> OS X Leopard has like a time machine that lets you fly in time and/or space with real-time 3D effects
16:41:38 <P_D> I've got a lot of C structs in memory which I ned to poke and prod at.  At the moment I'm using hsc2hs, but I've got a lot of structs with definitions shifting about.  I'd like to have just one representation for them in the C header.  Is there a way to automatically derive Storable instances or something equivalent?
16:41:51 <Cale> The map function just takes a function and applies it to the elements of a single list.
16:42:00 <Cale> > map (+1) [1..5]
16:42:00 <lambdabot>  [2,3,4,5,6]
16:42:02 <newsham> if you use a write-only filesystem you have all versions of every file at your disposable
16:42:03 <thoughtpolice> newsham: i believe the idea is you just mount a filesystem with an 'at date' and it'll map the drive as it was on that date.
16:42:10 <Cale> > map (+) [1..5]
16:42:11 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
16:42:11 <idnar_> jdrake: eh, well, you know what I mean
16:42:18 <thoughtpolice> but I'm not sure exactly how that works
16:42:26 <Cale> > zipWith ($) (map (+) [1..5]) [1..5]
16:42:27 <lambdabot>  [2,4,6,8,10]
16:42:29 <thoughtpolice> because the paper made my head spin after like the first paragraph or so
16:42:32 <newsham> err.. append-only
16:43:38 <P_D> I understand Data.Binary is the modern way to do marshalling, but that seems to be built on bytestrings.  I've just got Ptr Structs coming in.
16:43:40 <thoughtpolice> newsham: it looks very interesting though. i like dragonfly, so i'll be sure to give it a spin when 2.0 comes out
16:43:42 <Toxaris> thinking about functors wich aren't containers, would it make sense to have instance Functor ((->) a) where fmap = (.)?
16:43:44 <Vq^> http://wayback.sourceforge.net/ <- FUSE based versioning filesystem
16:43:44 <lambdabot> Title: Wayback: User-level Versioning File System for Linux
16:44:22 <thoughtpolice> i'm actually compiling nhc on it right now because I want a haskell compiler, but my port of ghc 6.6 didn't go so well a while back. might try 6.8.1 soon
16:44:27 <oerjan> > (+) `fmap` 1 `fmap` 1 -- yes
16:44:27 <lambdabot>   add an instance declaration for (Show (f (a -> a)))
16:44:40 <oerjan> um...
16:44:50 <oerjan> > ((+) `fmap` 1) `fmap` 1 -- yes
16:44:51 <lambdabot>   add an instance declaration for (Show (f (a -> a)))
16:44:51 <P_D> > (+) 1 `fmap` 1 `fmap` 1
16:44:52 <lambdabot>   add an instance declaration for (Show (f t))
16:45:02 <sizur> how to coerce from Float to Double?
16:45:11 <newsham> http://en.wikipedia.org/wiki/Fossil_(file_system)
16:45:12 <oerjan> er... messing up
16:45:14 <resiak> @hoogle Float -> Double
16:45:15 <lambdabot> No matches, try a more general search
16:45:21 <P_D> sizur: realToFrac
16:45:26 <sizur> thanks
16:45:27 <oerjan> > (+1) `fmap` (+1) $ 1
16:45:28 <lambdabot>  3
16:45:38 <oerjan> Toxaris: ^^
16:45:43 <thoughtpolice> newsham: oh, and there's also ext3cow which does something similar for linux: http://www.ext3cow.com
16:45:43 <lambdabot> Title: Welcome
16:45:45 <P_D> > (realToFrac (1.0 ::Float)) :: Double
16:45:45 <lambdabot>  1.0
16:45:53 <sizur> yeah it works
16:46:03 <thoughtpolice> i've never used it though (I came across it when it was beta,) but it looks neat.
16:46:34 <jdrake> Cool wayback :p
16:46:36 <thoughtpolice> and i'm pretty sure it's most likely a hell of a lot more efficient than a system built on fuse
16:47:08 <thoughtpolice> although zfs-on-fuse apparently gets some pretty decent performance.
16:47:22 <Toxaris> oerjan: thanks :) once again, i found what was already there. "you could have invented the Functor instance for (a ->)"
16:48:30 <oerjan> Toxaris: remember that every monad is morally an applicative and a functor, although someone could forget to write the instances
16:48:34 <jdrake> What is a non-basic haskell tutorial for someone who has looked into haskell before but didn't remember everything?
16:48:47 <resiak> isn't there a Monad a => Functor a instance?
16:48:59 <oerjan> resiak: no
16:49:05 <newsham> jdrake: gentle introduction?
16:49:06 <P_D> jdrake: gentle introduction is aimed at people with some experience in FP
16:49:10 <resiak> oerjan: hrm, why not?
16:49:12 <Toxaris> oerjan: I'm aware of that
16:49:21 <oerjan> it would have overlapping problems
16:49:40 <P_D> @src seq
16:49:41 <lambdabot> Source not found. You type like i drive.
16:49:56 <jdrake> perfect
16:49:58 <resiak> oerjan: because there are separate Functor instances for Maybe and friends?
16:51:21 <oerjan> resiak: as well as things that are Functors but not Monads.  for technical reasons if you have instance Monad a => Functor a then only the Functor a part is considered on lookup, so _everything_ would overlap
16:52:38 <conal> because instance selection just uses the head, not the context.  it doesn't search.
16:52:41 <oerjan> the "right" thing would be to make Monad a subclass of Functor
16:53:10 <Toxaris> > getConst $ fmap undefined $ Const "just found 'Const' in Control.Applicative"
16:53:12 <lambdabot>  "just found 'Const' in Control.Applicative"
16:53:23 <conal> oerjan: and allow subclasses to provide definitions or defaults for superclass methods.
16:54:05 <oerjan> grumble grumble class alias proposal grumble grumble
16:54:09 <newsham> class monoidalcategory
16:54:11 <resiak> oerjan: ah, i see
16:55:03 <jdrake> Has anyone ever explained the value of functional programming to the conservative system administration type that is unconvinced it would survive in a high use environment? I have a friend like this, and his opinion of functional languages is not high due to that background.
16:55:28 <jeffz> jdrake: there was a mention of a system administrator programming in Haskell, on programming.reddit.com not long ago
16:55:50 <conal> and the Linspire story
16:56:23 <newsham> jdrake: my web server is written in haskell.
16:56:43 <newsham> i wouldnt say its "high use" but its got lots of uptime and doesnt fall over
16:56:58 <jdrake> OMG, there is a lot of useful stuff on there today
16:57:56 <mikael> there's this haskell mail server that's really flexible and configurable and whatnot and which looks like a conservative sysadmin type would find cool
16:58:11 <jdrake> I can't find the sysadmin link though
16:58:33 <SamB_XP> functional programming is not quite orthogonal to whether or not your web server falls over...
16:58:45 <SamB_XP> but I don't see how it would make your webserver fall over
16:58:57 <mikael> here it is: http://postmaster.cryp.to/
16:58:58 <lambdabot> Title: Postmaster ESMTP Server
16:59:11 <newsham> sam: if your a sysadmin that thinks that functional programming is not ready for high use
16:59:15 <newsham> its a datapoint against that opinion
17:00:17 <SamB_XP> wasn't that what you had said was not useful
17:00:41 <newsham> hm?  what did I say?
17:01:09 <JohnMeacham> cinema: pong.
17:01:11 <SamB_XP> in any case, a sysadmin should be concerned with particular programs
17:01:17 <conal> mikael: neat!  configuring a mailserver in haskell.  opens up possibilities for elegant mail combinators.
17:01:17 <SamB_XP> should he not?
17:01:22 <newsham> definitely.
17:01:54 <oerjan> instance Monad Postal
17:02:19 <conal> monad - urg.
17:02:26 <oerjan> instance Arrow then
17:02:59 <conal> or Applicative
17:03:16 <conal> but preferably with a simple, IO-free semantics.
17:12:16 <jdrake> Windows seriously needs a ps decoder
17:12:46 <jeffz> jdrake: ps decoder?
17:13:10 <jdrake> Something like postscript to pdf
17:13:15 <SamB_XP> I have often wondered why Adobe Reader does not perform this function
17:13:17 <jeffz> yeah... ghostscript.
17:13:40 <jeffz> jdrake: ghostscript has been around for yonks.
17:13:59 <mikael> mac's preview converts ps to pdf but usually it makes these huge bitmap pdfs or something that are super slow to scroll through
17:14:21 <thoughtpolice> jdrake: i tried using gs's provided ps2pdf.bat file and it broke because of some stupid reason
17:14:31 * jeffz never has any problem with it.
17:14:36 <thoughtpolice> i go the poor man's way: download the ps on linux, use ps2pdf there, and then send the file over using netcat
17:15:48 <conal> i use ps2pdf on my windows machine
17:16:07 <thoughtpolice> mine normally gives some weird error of "could not open temp file: ''" or somesuch.
17:16:20 <thoughtpolice> it's not that big of an inconvenience though, honestly.
17:16:28 <jeffz> SamB_XP: Adobe Reader not reading PostScript files is most likely a ploy by Adobe to make sure people don't increase their use of PostScript.
17:16:58 <SamB_XP> jeffz: why would Adobe mind this?
17:17:03 <jdrake> Well, I have ghostscript, but no ps2pdf.
17:17:12 <SamB_XP> Adobe is responsible for BOTH technologies...
17:17:13 <jdrake> Ghostscript can show the ps file, but it looks unreadable
17:17:15 <conal> i got my ps2pdf with MiKTeX
17:17:16 <jeffz> SamB_XP: the way I see it, PDF is more profitable to them
17:17:53 <jdrake> I am definitely not downloading miktex
17:19:42 <jdrake> of course ps2pdf.com is nice too :p
17:21:41 <davidL> > (3 :: CInt) + 2
17:21:43 <lambdabot>   Not in scope: type constructor or class `CInt'
17:22:43 <ddarius> @index CInt
17:22:43 <lambdabot> Foreign.C.Types, Foreign.C
17:22:56 <ddarius> > 3 :: Foreign.C.CInt
17:22:57 <lambdabot>   Not in scope: type constructor or class `Foreign.C.CInt'
17:23:11 <ddarius> :t 3 :: Foreign.C.CInt
17:23:13 <lambdabot> Foreign.C.Types.CInt
17:24:30 <oerjan> :t Foreign.C.unsafePerformIO
17:24:30 <lambdabot> Not in scope: `Foreign.C.unsafePerformIO'
17:24:47 <oerjan> :t Foreign.unsafePerformIO
17:24:47 <lambdabot> forall a. IO a -> a
18:07:24 <vincenz> @lang es en cotillo
18:07:33 <vincenz> @bot
18:07:33 <lambdabot> :)
18:08:06 <vincenz> @dict es en cotillo
18:08:06 <lambdabot> Supported dictionary-lookup commands:
18:08:06 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
18:08:06 <lambdabot> Use "dict-help [cmd...]" for more.
18:08:22 <faxathisia> @babel es en cotillo
18:08:23 <lambdabot>   cotillo
18:08:29 <vincenz> thanks
18:08:34 <vincenz> that didn't help much
18:12:21 <byorgey> vincenz: what, you don't know what a cotillo is?
18:12:27 <vincenz> o.O
18:12:29 <vincenz> nope
18:12:43 <oerjan> @babel es en Parte del martillo u otra herramienta con la que se golpea
18:12:43 <lambdabot>   Part of the hammer or another tool with which it is struck
18:13:02 <vincenz> I've been told it means gossip
18:13:10 <byorgey> vincenz: just kidding, me neither =)
18:13:15 <oerjan> @babel es en Parte opuesta al filo en algunos instrumentos cortantes:
18:13:15 <lambdabot>   Part opposed to the edge in some sharp instruments:
18:13:25 <vincenz> no
18:13:27 <vincenz> este es cocillo
18:13:42 <oerjan> (http://www.wordreference.com/definicion/cotillo)
18:13:43 <lambdabot> Title: Yahoo!
18:13:56 <vincenz> ah, tu utilizas babel en este modo
18:14:02 <vincenz> oerjan: I thought you were writing spanish yourself :)
18:14:08 <oerjan> nope
18:14:37 <byorgey> http://www.spanishdict.com/1AS.cfm?e=cotilleo
18:14:37 <lambdabot> Title: SpanishDICT.com - Dictionary of Spanish and English
18:14:45 <byorgey> that says 'cotilleo' means gossip
18:14:45 <oerjan> i just found a spanish definition of cotillo so i needed to translate it
18:15:10 <oerjan> @babel en es gossip
18:15:10 <lambdabot>   chisme
18:15:23 <oerjan> @babel es en cotilleo
18:15:23 <lambdabot>   cotilleo
18:15:45 <byorgey> your @babel proves nothing.  nothing!
18:17:09 * vincenz moves his lips unsynched with his mouth "your @babel is strong, I will beat you, fight!"
18:17:14 <oerjan> @babel es en cotillear
18:17:14 <lambdabot>   to cotillear
18:17:27 <oerjan> >_<
18:18:18 <oerjan> lips unsynched with mouth?  that takes some skill
18:18:26 <vincenz> never seen those japanese movies
18:18:33 <vincenz> where they put some really heavy american voice
18:18:50 <oerjan> now, lips unsynched with _voice_, on the other hand
18:18:53 * faxathisia got it :p
18:18:58 <vincenz> oh llol
18:19:01 <vincenz> bleh, late, tired
18:19:04 <vincenz> @localtime oerjan
18:19:05 <lambdabot> Local time for oerjan is Sat Nov 24 03:19:05 2007
18:51:59 <newsham> ?check id === id
18:52:00 <lambdabot>   Not in scope: `==='
20:53:27 <elliottt> ?bot
20:53:27 <lambdabot> :)
20:53:34 <elliottt> @source satisfy
20:53:34 <lambdabot> satisfy not available
20:53:45 <elliottt> @source Text.ParserCombinators.Parsec.Satisfy
20:53:45 <lambdabot> Text.ParserCombinators.Parsec.Satisfy not available
20:53:53 <elliottt> @source Text.ParserCombinators.Parsec.Char.Satisfy
20:53:53 <lambdabot> Text.ParserCombinators.Parsec.Char.Satisfy not available
20:53:56 <elliottt> -_-
20:54:02 <hpaste>  dufflebunk pasted "How to find number of bytes read" at http://hpaste.org/4067
20:54:46 <oerjan> satisfy f           = tokenPrim (\c -> show [c])  (\pos c cs -> updatePosChar pos c)  (\c -> if f c then Just c else Nothing)
20:55:20 <dufflebunk> If anyone has used ByteStrings and Binary and knows how to find out how many bytes Binary used up, I'd appreciate it if you could let me in on the secret
20:55:53 <oerjan> elliottt: btw @src is the command for single functions but i doubt it has Parsec
20:57:20 <dufflebunk> I pasted a small sample program in the link above. I know, it's probably ugly and awkward... but this is new to me.
21:02:58 <oerjan> there ought to be a variant of decode that returns the remaining substring, like with ReadS
21:03:53 <Cale> dufflebunk: There's a Data.ByteString.length, I'm fairly sure.
21:04:36 <Cale> mm, oh, I see what you mean
21:05:48 <Cale> runGetState :: Get a -> ByteString -> Int64 -> (a, ByteString, Int64)
21:07:19 <Cale> You can apply that to the 'get' for the appropriate type, along with a ByteString and an initial count, and it'll return the parsed stuff, along with the remainder of the ByteString and the updated count
21:07:35 <Cale> (which if you started with 0 should be the number of characters read)
21:08:22 <Cale> dufflebunk: does that help?
21:13:19 <elliottt> oerjan: thanks :)
21:31:03 <chessguy> @seen osfameron
21:31:03 <lambdabot> osfameron is in #haskell. I last heard osfameron speak 13h 48m 20s ago.
21:31:47 <chessguy> 'evening haskellers
21:32:10 <dobblego> does anyone have a vmware image (linux) with a lambdabot that compiles and runs properly; and you can just change that configuration and recompile without farting about (lambdabot has wasted so much of my time previously)
21:37:41 <chessguy> osfameron++ for some interesting blogs lately
21:37:54 <chessguy> @tell osfameron
21:37:54 <lambdabot> Consider it noted.
21:37:54 <chessguy> <chessguy> osfameron++ for some interesting blogs lately
21:38:21 <ddarius> Slick.
21:42:21 <dufflebunk> Cale: I'm not sure... I seek to a point in a file and then create a lazy byte string, so finding out the remainer might not be very efficient
21:42:59 <dufflebunk> Ah, the Int64 is the number used, not number left
21:43:06 <Cale> dufflebunk: right.
21:44:42 <dufflebunk> That might work. Not as handy as decode, but I'll give it a try
21:44:49 <conal> i'm looking for the wiki page about type familes that mentions generalized tries.  not sure whether it's on the haskell wiki or the ghc wiki.  anyknow know?
21:45:40 <allbery_b> @go haskell type families generalized tries
21:45:41 <lambdabot> http://haskell.org/haskellwiki/GHC/Indexed_types
21:46:34 <conal> allbery_b: thanks.  don't know why my googling didn't get it.
21:49:27 <dufflebunk> Cale: See, this is where I get confused, in order to run that function I need something of type (Get a), but I have no way of making it...
21:49:34 <Cale> get
21:49:48 <Cale> You just use get. Let type inference handle the rest.
21:50:53 <Cale> You could put some other computation in the Get monad there, but get is what decode would have used.
21:51:42 <ddarius> @tell osfameron You most likely want the fields of your game state record to be strict.
21:51:42 <lambdabot> Consider it noted.
21:55:02 <dufflebunk> Cale: Ok, I sort of get it. I'm having trouble though because the get function doesn't seem to take any input... but I guess that's ok if it simply returns a function that does the work.
21:55:15 <Cale> dufflebunk: It's polymorphic
21:55:17 <ddarius> :t Data.Binary.get
21:55:19 <lambdabot> forall t. (Data.Binary.Binary t) => Data.Binary.Get.Get t
21:55:43 <Cale> dufflebunk: Its value depends on which instance of Binary is present.
21:56:09 <Cale> dufflebunk: See, you defined it for TwoChars just above there.
21:56:21 <dufflebunk> Right, but get returns the same thing each time it's called for TwoChars
21:56:34 <Cale> right
21:56:44 <Cale> It's always the same computation
21:56:50 <Cale> (the one which reads two chars)
21:57:20 <sclv> ?ty plusPtr
21:57:21 <lambdabot> Not in scope: `plusPtr'
21:57:37 <sclv> ?hoogle plusPtr
21:57:37 <lambdabot> Foreign.Ptr.plusPtr :: Ptr a -> Int -> Ptr b
21:57:44 <Cale> Just like getLine is always the computation which gets a line of text from the user.
21:57:58 <Cale> Even though the user might enter different text each time.
21:58:21 <dufflebunk> Yeah, it bugs me. I'll get used to it though.
21:58:26 <ddarius> :t getLine
21:58:27 <lambdabot> IO String
21:58:49 <dufflebunk> Cale: Any idea what the third argument is in runGetState ?
21:59:33 <oerjan> :t Data.Binary.Get.runGetState
21:59:34 <lambdabot> forall a. Data.Binary.Get.Get a -> Data.ByteString.Lazy.ByteString -> Int64 -> (a, Data.ByteString.Lazy.ByteString, Int64)
21:59:36 <Cale> dufflebunk: The initial Int64 that it starts counting from
21:59:43 <Cale> So in your case, I think you want 0
21:59:46 <ddarius> State passing
22:00:22 <oerjan> ah right, runGetState is the run for the Get monad
22:00:46 <ass_lover> any news of a haskell operating system?
22:01:11 <Cale> There is one or two. I'd advise you to change your nick.
22:01:12 <dobblego> @where house
22:01:12 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
22:03:36 <ass_lover> any professional programmers here?
22:03:49 <math_lover> :)
22:08:20 <hpaste>  dufflebunk annotated "How to find number of bytes read" with "Working" at http://hpaste.org/4067#a1
22:08:59 <dufflebunk> Cale: Thanks, that seems to work
22:09:11 <Cale> great :)
22:09:39 <Cale> s/subtype/instance/
22:09:47 <Cale> (Binary isn't a type)
22:11:02 <math_lover> typage
22:11:15 <dufflebunk> What is it if it's not a type?
22:11:26 <ddarius> A new thesis to read (if I haven't already... which is likely [that I have])
22:11:44 <ddarius> dufflebunk: An instance
22:11:45 <oerjan> a type class
22:12:00 <ddarius> Er Binary is a type class and TwoChars is an instance of it.
22:12:01 <Cale> dufflebunk: A typeclass, yes
22:12:14 <ddarius> type class /= OO class
22:12:37 <ddarius> It means something closer to it's usage in set theory.  I.e. a collection of things.
22:12:41 <dufflebunk> Ah, right. I keep forgetting there's a whole new level
22:13:03 <Cale> I tend to think of typeclasses as relations on types.
22:13:13 <math_lover> what a large haskell powered website?
22:13:17 <Cale> Many of which are just unary relations, so either true or false.
22:13:32 <Cale> math_lover: how large?
22:14:27 <math_lover> couple 1000 users
22:14:32 <math_lover> stuff liek that
22:14:46 * ddarius wonders if "third generation wavelets" would return hits'
22:15:01 <Cale> http://hackage.haskell.org/packages/hackage.html -- I'm pretty sure this is written in Haskell.
22:15:04 <lambdabot> Title: HackageDB: introduction
22:15:07 <math_lover> the generation term is so overused in computng lingo
22:15:43 <oerjan> generation X-ray?
22:15:46 * dufflebunk believes that lingo is second generation terminology
22:16:42 <ddarius> oerjan: A movie starring Jamie Foxx?
22:17:22 <Cale> There was also an online clothing store which was written in Haskell, iirc.
22:17:27 <math_lover> hacakge
22:17:29 <math_lover> cabal
22:17:30 <Cale> I can't recall the url.
22:17:34 <math_lover> woa cult liek names
22:17:55 <math_lover> "oh our software is 5 generations ahead"
22:18:02 <math_lover> ----from a bad interview
22:18:20 <math_lover> a rabin python fan I might add
22:18:54 <agnokapathetic> > let isTriNum n = n == i*(i+1)/ 2 where i = truncate (sqrt (2*n))
22:18:54 <lambdabot>  Parse error at end of input
22:19:19 <agnokapathetic> >let isTriNum n = n == i*(i+1)/ 2 where i = truncate (sqrt (2*n))
22:19:36 <agnokapathetic> > let isTriNum n = n == i*(i+1)/ 2 where i = truncate (sqrt (2*n))
22:19:36 <lambdabot>  Parse error at end of input
22:19:50 <dobblego> > let isTriNum n = n == i*(i+1)/ 2 where i = truncate (sqrt (2*n)) in isTriNum 7
22:19:52 <lambdabot>  Add a type signature
22:20:01 <agnokapathetic> oh there we go :-)
22:20:17 <Cale> math_lover: You might be interested in http://happs.org/ -- I'm not sure who the users of it are.
22:20:18 <lambdabot> Title: HAppS - The Haskell Application Server
22:20:19 <agnokapathetic> theres my problem, i keep getting "No instance for (RealFrac Int)"
22:20:34 <mlh> http://braintreehemp.com.au/
22:20:43 <math_lover> so what is a nice way to learn haskell, and what are the best reasons to learn it when compares to say perl?
22:20:52 <dobblego> ?type \n -> n == i*(i+1)/ 2 where i = truncate (sqrt (2*n))
22:20:53 <lambdabot> parse error on input `where'
22:21:16 <ddarius> math_lover: If you are happy with the languages you are currently using, why bother with Haskell?
22:21:17 <dobblego> ?type \n -> let i = truncate (sqrt (2*n)) in n == i*(i+1)/ 2
22:21:18 <lambdabot> forall b. (Floating b, RealFrac b, Integral b) => b -> Bool
22:21:20 <agnokapathetic> math_lover: it makes you learn to think in a new way about programming
22:21:28 <math_lover> Im not happy only knowing bash
22:21:37 <math_lover> http://www.youtube.com/watch?v=zEzh10_xoqw&feature=related
22:21:38 <lambdabot> Title: YouTube - barbie girl - aqua
22:21:39 <ddarius> math_lover: Why not?
22:22:23 <Cale> math_lover: If you're a math person, chances are you'll like Haskell.
22:22:40 <oerjan> > let isTriNum n = n == i*(i+1)`div` 2 where i = truncate (sqrt (2*fromIntegral n)) in isTriNum 7
22:22:41 <lambdabot>  False
22:22:56 <agnokapathetic> thank you oerjan :-)
22:23:01 <dufflebunk> math_lover: bash is fun
22:23:24 <Cale> I wrote an entire IRC bot as essentially a single bash pipeline.
22:23:25 <agnokapathetic> bourne shell (similar to bash) server pages: http://hyperrealm.com/wtfd00d/shsp/
22:23:26 <lambdabot> Title: Bourne Shell Server Pages
22:23:46 <Cale> (with a fifo tying the ends together)
22:23:58 <math_lover> pipe is a nice thingy
22:24:05 <math_lover> I  love cut cron pipe and find
22:24:21 <math_lover> alogn with tokenizing greps it makes me feel godlink
22:24:25 <math_lover> god-like
22:26:18 <oerjan> > filter ("ha" `isInfixOf`) . sort . words $ "haskell has pipes too, sort of"
22:26:18 <lambdabot>  ["has","haskell"]
22:28:10 <math_lover> I wish my sorcery to become stronger
22:28:40 <Cale> Haskell is a pretty fun language.
22:29:13 <Cale> It's by far my favourite of the 15 or 20 programming languages I know reasonably well.
22:30:53 <ddarius> Cale: You ever read the papers on TyPiCal?
22:31:50 <Cale> Hmm, the name rings a bell, but I don't think I have.
22:32:11 <tits_loover> k
22:32:20 <tits_loover> hello?
22:32:22 <ddarius> Paul Snively often mentioned it on LtU.  I just recently decided to actually look at it.
22:32:26 <Cale> ...yeah, that's not an appropriate nick here.
22:32:38 <tits_loover> Im trying to change
22:32:46 <tits_loover> mirc not doing what I want
22:32:56 <Cale> I recommend X-Chat.
22:33:06 <math_guy88> crap
22:33:07 <math_guy88> ok
22:33:18 <math_guy88> so wait
22:33:20 <math_guy88> cale
22:33:25 <Cale> ddarius: Is there a more googleable phrase?
22:33:26 <math_guy88> why haskell your favorite?
22:34:32 <Cale> math_guy88: Because it makes it much easier to write programs that actually work the first time. Code is easier to think about than in most languages since it tends to satisfy lots of nice properties and guarantees.
22:34:46 <math_guy88> ah
22:34:47 <ddarius> Cale: The key is to add "pi calculus".  But anyway, here is the page: http://www.kb.ecei.tohoku.ac.jp/~koba/typical/
22:34:48 <lambdabot> Title: TyPiCal
22:34:52 <Cale> It's also rather compact. 3 lines of Haskell code can do quite a lot.
22:34:56 <math_guy88> what haskell programs have you made lately?
22:35:29 <ddarius> "A New Type System for Deadlock-Free Processes" This paper is the one I'm looking at now. http://www.kb.ecei.tohoku.ac.jp/~koba/papers/concur2006-full.pdf\
22:35:36 <Cale> I've been working on a binding to Imlib 2, but mostly small things lately.
22:36:21 <Cale> The largest Haskell program I've written was a pipeline scheduler for PPC+Altivec assembly code.
22:36:38 <math_guy88> oow what does it do?
22:36:50 <Cale> It was about 1200 lines of code, about half of which was documentation, and it would have been something like 15000 lines of C code.
22:37:00 <math_guy88> I am messing with forth common lisp perl tcl and haskell
22:37:25 <math_guy88> 1200
22:37:30 <Cale> It reordered the instructions in programs so that different parts of the processor could work at the same time more effectively.
22:37:33 <math_guy88> vs 15000 is huge reducation
22:37:45 <math_guy88> is that GOOD c code like reusing subroutines etc.?
22:37:58 <Cale> yes
22:38:06 <math_guy88> wow
22:38:08 <Cale> That's an estimate by an expert C programmer.
22:38:20 <math_guy88> thats a lot less 1 to 4th vs 1 to 3rd
22:38:31 <math_guy88> wow
22:38:50 <math_guy88> ddi you make sue of haskell libs?
22:38:58 <math_guy88> to cheat ro is it head to head comparison/
22:39:34 <Cale> I didn't really use that much in the way of libraries.
22:39:42 <dobblego> Haskell libraries are pure, which makes them easy to compose
22:39:45 <Cale> I just made really good use of lazy evaluation.
22:40:03 <Cale> and monads
22:40:18 <Cale> (particularly there was quite a lot of the list monad)
22:40:31 * ddarius wonders if a constraint logic language wouldn't have been better still.
22:40:37 <Cale> Well, possibly, yes.
22:40:53 <Cale> That's essentially what the problem was.
22:41:12 <wli> Constraint logic languages are something I'd like to know more about.
22:42:11 <Olathe> calvins: Is the code for that scheduler available ?
22:42:15 <Olathe> Cale
22:43:08 <dfranke> is there a way to get deriving to work on GADTs?
22:43:16 <ddarius> Hack GHC?
22:43:21 <Cale> Olathe: No, unfortunately. When I left, it stayed with my supervisor at McMaster. I don't know if that code is going to end up in anything released or not.
22:43:43 <Olathe> Ahh, OK.
22:43:57 <dufflebunk> My brother went to McMaster
22:43:58 <Cale> Olathe: I won't be too surprised if they find a better algorithm than I came up with for doing that.
22:44:18 <Cale> I'm actually a Waterloo person, I just worked at McMaster for a Summer.
22:47:05 <atp> hey guys.  if i have a type which depends on some parameter, in the way Maybe a depends on a (i'm not sure what the proper term for that is called), is it possible to make that type forall a an instance of some class?
22:47:29 <oerjan> atp: sure
22:47:32 <atp> how?
22:47:35 <Cale> math_guy88: I mostly use Haskell for small mathematical experiments. These days I think way more about the structure of programs than actually writing code.
22:47:39 <dobblego> ?kind Maybe
22:47:41 <lambdabot> * -> *
22:47:46 <dobblego> ?kind Maybe Int
22:47:46 <lambdabot> *
22:47:51 <Olathe> @help kind
22:47:51 <lambdabot> kind <type>. Return the kind of a type
22:48:10 <Cale> atp: instance Foo (T a) where ...
22:48:10 <Olathe> Returns the car of an automobile.
22:48:42 <atp> see, i tried that, and it complains about a kind mismatch.  could it be that my definition of the class is wrong?
22:48:55 <Cale> atp: Oh, perhaps you want
22:48:59 <Cale> instance Foo T where
22:49:09 <Cale> It depends on which class it is.
22:49:29 <atp> well, it's a class i defined myself, and at the moment it looks like this: class Container a where ...
22:49:32 <Cale> Classes are allowed to have type constructors for parameters.
22:49:38 <Cale> okay
22:49:50 <atp> basically the deal is this, a is most likely a type that looks like say, Object a
22:49:57 <Cale> and so 'a' there is a variable representing a type constructor?
22:50:00 <atp> or lets call it something other than a
22:50:02 <atp> Object o
22:50:17 <atp> and the functions in the Container a class don't really care what o is specifically
22:50:28 <oerjan> data Object o = ... ?
22:50:30 <Cale> all right
22:50:36 <dfranke> well, so much for SYB making things easier if I'm going to have to manually derive Data.
22:50:45 <Cale> Let me see a type signature for one of the functions in that class Container
22:50:56 <atp> oerjan: it's a big datastructure... the o is mainly there because that allows it to be a recursive datatype in some instances where that's convenient...
22:51:04 <Cale> (specifically, one which uses the type variable a)
22:51:35 <atp> ok, i have one that looks like addContained :: a -> o -> Maybe a
22:51:45 <Cale> for any a?
22:52:03 <oerjan> is this a multiparameter type class?
22:52:04 <Cale> There's basically only two things such a function could be doing
22:52:10 <oerjan> Container o a ?
22:52:10 <atp> oh i see wait wait
22:52:12 <atp> right
22:52:15 <Cale> addContained x y = Just x
22:52:16 <Cale> or
22:52:19 <Cale> addContained x y = Nothing
22:52:27 <atp> I should be saying a o -> o -> Maybe (a o) huh
22:52:35 <Cale> yeah
22:52:38 <atp> duh
22:52:41 <Cale> that's more likely :)
22:52:43 <atp> sorry, that was a major brain fart
22:52:51 <atp> thanks for helping me think straight
22:52:56 <Cale> no problem
22:52:56 <atp> you too oerjan
22:53:24 <oerjan> ok, then it ought to be instance Container Foo where
22:54:08 <oerjan> since a gets kind * -> *
22:55:05 <atp> yeah
23:01:01 <atp> ok, another type question
23:01:42 <atp> suppose i have a class that looks like this: class Foo a where getString :: a -> String
23:01:56 <atp> now, I have my earlier data structure, Object o
23:02:05 <atp> now regardless of what the o in Object o is,
23:02:16 <atp> i want to define getString on it
23:02:24 <atp> and make it an instance of my Foo class
23:02:25 <atp> forall o
23:02:42 <atp> can i do something like instance Foo (Object o) where ... ?
23:02:59 <oerjan> sure
23:04:09 <atp> hm...
23:04:21 <oerjan> although with no restriction on o you won't be able to make the string depend on it
23:04:31 <atp> the string doesn't depend on it
23:04:35 <atp> that's why i'm asking
23:04:48 <oerjan> (btw the class Show is similar to Foo)
23:04:59 <atp> that's a good point
23:05:09 <Brian```> @src Reader
23:05:09 <lambdabot> Source not found.
23:05:21 <atp> but doesn't show require that the a also be an instance of Show?
23:05:54 <oerjan> not if you write the instance yourself
23:05:58 <Cale> atp: usually, since you usually want to show the elements too
23:06:03 <oerjan> only for deriving
23:06:06 <atp> ah, i see
23:06:37 <oerjan> newtype Reader r a = Reader { runReader :: r -> a }
23:06:46 <oerjan> Brian```: ^^
23:08:22 <oerjan> incidentally, lambdabot has just such Show instances for some of the types it won't "run":
23:08:37 <oerjan> > print "test"
23:08:39 <lambdabot>  <IO ()>
23:08:42 <Cale> > getLine
23:08:42 <lambdabot>  <IO [Char]>
23:09:00 <Cale> > reverse
23:09:00 <lambdabot>  Add a type signature
23:09:10 <Cale> > [reverse]
23:09:11 <lambdabot>  Add a type signature
23:09:14 <Cale> hmm :)
23:09:16 <Olathe> > reverse::[[]]
23:09:17 <lambdabot>      `[]' is not applied to enough type arguments
23:09:17 <lambdabot>     Expected kind `*', but ...
23:09:24 <Cale> oh, it's polymorphic, right
23:09:27 <Olathe> > reverse [[], []]
23:09:28 <lambdabot>  [[],[]]
23:09:38 <Olathe> > reverse::[[a]]
23:09:38 <oerjan> > chr
23:09:38 <lambdabot>  Couldn't match expected type `[[a]]'
23:09:39 <lambdabot>  <Int -> Char>
23:09:40 <Cale> > [reverse :: String -> String]
23:09:41 <lambdabot>  [<[Char] -> [Char]>]
23:09:51 <Cale> :)
23:09:54 <Olathe> > reverse::[[reverse]]
23:09:54 <lambdabot>  Couldn't match expected type `[[reverse]]'
23:10:01 <Olathe> > reverse::[[reverse::[Int]]]
23:10:01 <lambdabot>  Parse error at "::[In..." (column 19)
23:10:21 <brad_> anyone have a decent summary of what i can and can't do with nhc98 vs ghc?
23:10:22 <Olathe> > reverse::[[<[Int]->[Int]>]]
23:10:23 <lambdabot>  Parse error at "<[Int..." (column 12)
23:10:25 <oerjan> although actually those instances require a Typeable instance to give the type, i guess
23:11:08 <Olathe> > reverse [reverse, tail]
23:11:09 <lambdabot>  Add a type signature
23:11:09 <oerjan> but they don't use the actual value, only the type
23:11:29 <Olathe> > [reverse, tail]
23:11:37 <Olathe> :(
23:11:37 <lambdabot>  Add a type signature
23:11:55 <oerjan> Olathe: i think only some specific types have such instances (IO, ->)
23:12:19 <oerjan> because otherwise you would get overlapping with the ordinary ones
23:13:00 <oerjan> and [] already has a Prelude Show instance
23:13:25 <ddarius> oerjan: What's your point?
23:13:28 <oerjan> hm, wait...
23:13:37 <oerjan> that _should_ use the one for the functions
23:13:59 <oerjan> > [map chr, map chr . reverse]
23:14:01 <lambdabot>  [<[Int] -> [Char]>,<[Int] -> [Char]>]
23:14:20 <atp> thanks for the help guys, i'm out
23:15:17 <oerjan> ddarius: i was thinking if lambdabot used a generic overlapping Show based on Typeable, then you could imagine it printing <[[Int] -> [Char]]> there
23:16:14 <ddarius> oerjan: Ah.
23:16:35 <oerjan> > print "a" >> return [map chr, map chr . reverse] -- adding an IO should work
23:16:36 <lambdabot>  <IO [[Int] -> [Char]]>
23:22:21 <luqui> is there a way to specify constraints on an associated type
23:23:01 <luqui> say, class VectorSpace v where type Field v :: *,  I want to make sure Field v is an instance of Num
23:26:39 <luqui> where by "type" I mean "data"
23:26:56 <luqui> oh wait
23:27:02 <luqui> can associated types even do that?
23:28:08 <luqui> ah, got it, class (Num (Field v)) => VectorSpace v where ...
