00:03:13 <pejo> landjik, if you don't get an answer right now .. dons is usually around on this channel during daytime in the US. And probably plenty of others who know lambdabot as well.
00:03:49 <landjik> OK, thanks
00:17:24 <marl> can I i access firebird and postgresql databases using haskell?
00:19:56 <quicksilver> postgresql certainly
00:20:26 <quicksilver> I don't recall hearing about firebird bindings but it's not unlikely
00:21:03 <marl> ok.
00:22:34 <dfranke> does Firebird speak ODBC?
00:23:13 <marl> i dont know.. :(
00:23:29 <marl> i've only used firebird in a sad time (heheh) when i spent 2 weeks with delphi
00:23:53 <marl> but there you dont need to know those things to do simple task (what i was doing)
00:35:10 <dmwit> So I'm reading "Tackling the Awkward Squad" again.
00:35:29 <dmwit> Is the difference between MVar and Channel mainly that writing to a Channel never blocks?
00:39:09 <dmwit> Or maybe "blocks for a shorter time" would be more accurate.
00:39:17 <osfameron> morning
00:39:18 <lambdabot> osfameron: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:39:20 <osfameron> ooo!
00:40:03 <osfameron> hmmm, one of those messages is rather minimalist
00:40:10 * osfameron checks his irclogs
00:47:37 <hpaste>  ScriptDevil pasted "Stack Overflow on myZero == myInf" at http://hpaste.org/4090
00:48:13 <ScriptDevil> well.. where did i go wrong, i thought i was taking advantage of lazy evaluation
00:50:24 <sclv> what are you trying to do?
00:50:41 <scook0> sclv: looks like lazy naturals
00:50:44 <ScriptDevil> well.. i am trying to check if zero == inf. i must get false
00:50:57 <ScriptDevil> scook0, yeah.. thats what i tried :)
00:51:05 <ScriptDevil> i am a newbie /..
00:51:20 <sclv> when you use == it needs to reduce arguments to weak head normal form, right? so it forces the evaluation of myInf, which gives a loop
00:51:23 <scook0> MySucc(MySucc a) == MySucc(MySucc b) =  (MySucc a) == (MySucc b)
00:51:27 <scook0> looks suspicious
00:51:46 <ScriptDevil> scook0, it must evaluvate top down
00:52:01 <scook0> shouldn't it be:
00:52:05 <ScriptDevil> so when i give myZero == myInf, it must check only the first condition
00:52:19 <scook0> (MySucc a) == (MySucc b) = (a == b)
00:53:14 <scook0> though I don't know if that's related to your actual problem
00:53:14 <ScriptDevil> scook0, i am not sure... this method works with finite stuff
00:54:04 <ScriptDevil> scook0, i doubt if what you said will work. because only MySucc and MyZero are ctors of  MyNat
00:55:58 <sclv> couldn't you just make inf another constructor of MyNats?
00:56:48 <scook0> ScriptDevil: I can't reproduce a stack overflow
00:56:57 <ScriptDevil> scook0, what do you get?
00:56:59 <ScriptDevil> False?
00:57:18 <scook0> yep
00:57:20 <ScriptDevil> Main> MyZero == myInfERROR - Control stack overflow
00:57:35 <ScriptDevil> hmm.. wait.. will try running it outside emacs
00:57:45 <scook0> thought with your definition, I also got "non-exhaustive patterns" comparing one and two
00:58:34 <scook0> *Main> Zero == inf
00:58:34 <scook0> False
00:58:57 <scook0> (I'm running GHCi 6.6)
00:58:58 <ScriptDevil> thanls
00:59:00 <ScriptDevil> *thanks
00:59:11 <ScriptDevil> me too. but i ran the repl within emca
00:59:14 <ScriptDevil> emacs
00:59:41 <sclv> if it's a problem still you could also make MyInf more explicitly lazily recursive with something like myInf = let x = mySucc x = in x, no?
01:00:11 <sclv> s /= in/in/
01:00:37 <scook0> inf = fix Succ :)
01:01:12 <ScriptDevil> err... scook0 did you run the same code?
01:02:40 <scook0> MySucc myInf = myInf
01:02:44 <scook0> looks like your problem
01:02:53 <scook0> (since I changed that line when I was typing mine)
01:03:05 <scook0> and if I change it back, (==) diverges
01:03:16 <ScriptDevil> what did you use instead?
01:03:24 <ScriptDevil> sclv, thanks. will tru that
01:03:26 <scook0> myInf = MySucc myInf
01:03:47 <ScriptDevil> :) well.. will do that change
01:04:12 <scook0> I'm struggling to figure out what the original version even means...
01:04:17 <ScriptDevil> of course.. that was the problem
01:04:51 <ScriptDevil> well.. it was an idiotic typo on my part. i meant to type myInf = MySucc myInf
01:05:51 <scook0> I was surprised that it's valid syntax
01:06:06 <scook0> @where report
01:06:06 <lambdabot> http://www.haskell.org/onlinereport/
01:06:14 <ScriptDevil> thanks scook0 ... yeah.. an error would have helped
01:07:05 <TSC> Is there any user documentation for cabal-install?
01:07:42 <scook0> oh, I see what that syntax is doing now
01:08:06 <ScriptDevil> what?
01:08:28 <scook0> it's like (a, b) = (x, y)
01:09:06 <scook0> it defines myInf as "take myInf, and remove a MySucc from it"
01:09:23 <scook0> which is going to give you _|_
01:09:34 <ScriptDevil> :o :(
01:09:56 <ScriptDevil> err... i must learn to think functionally!!!
01:09:57 <scook0> well, at least I learned something
01:10:15 <scook0> it's not something you often see in a top-level binding
01:11:05 <ScriptDevil> i guess i am just good at screwing things in a tough way ;)
01:11:50 <sclv> ?ty let Just foo = foo in foo
01:11:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = Maybe t
01:11:50 <lambdabot>       Expected type: Maybe t
01:11:50 <lambdabot>       Inferred type: t
01:12:01 <sclv> ?ty let Just foo = foo in 12
01:12:01 <lambdabot>     Occurs check: cannot construct the infinite type: t = Maybe t
01:12:01 <lambdabot>       Expected type: Maybe t
01:12:01 <lambdabot>       Inferred type: t
01:12:31 <sclv> I wonder why it gives an error there then.
01:12:49 <scook0> sclv: Maybe is not recursive
01:12:55 <scook0> whereas MyNat is
01:13:17 <sclv> ?ty Just (Just 12)
01:13:18 <lambdabot> forall t. (Num t) => Maybe (Maybe t)
01:13:40 <scook0> > fix Just
01:13:41 <lambdabot>      Occurs check: cannot construct the infinite type: a = Maybe a
01:13:41 <lambdabot>       Expe...
01:13:59 <scook0> > fix (():)
01:14:00 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
01:22:58 <math_guy88> how does haskell replace macros?
01:23:24 <sciolizer> @google template haskell
01:23:25 <lambdabot> http://www.haskell.org/th/
01:23:25 <lambdabot> Title: Template Haskell
01:23:38 <dmwit> math_guy88: What macros are you thinking of?
01:23:57 <Cale> math_guy88: Lazy evaluation takes care of many of the uses of macros.
01:24:19 <Cale> ... okay.
01:24:32 <Vq^> :/
01:24:34 <rue> My lazy C curmudgeon brain likes to think of function application as macro expansion :)
01:24:36 <dmwit> Good thing he stuck around for the full answer.
01:26:01 <scook0> other features that make macros less crucial are concise lambda notation, the ($) operator, and IO actions as first-class values
01:26:11 <scook0> (for anyone else listening)
02:02:35 <fasta> Setup.hs: At least the following dependencies are missing: base -any
02:03:53 <fasta> What should I add to the cabal file exactly for 6.9?
02:05:03 <fasta> Hmm, I think I got it already.
02:11:41 <fasta> Why is documentation installed in /usr even with  --user --prefix=$HOME?
02:19:39 <RayNbow> dons, that sieve function you defined @ http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/26#no-headaches
02:19:40 <lambdabot> Title: Haskell hacking
02:20:21 <RayNbow> ...isn't it a bit lacking in performance?
02:20:25 <fasta> Why can array.cabal in the array library contain base as dependency while I cannot do that for my packages?
02:22:00 <RayNbow> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf <-- a better sieve function
02:24:03 <fasta> I have base-3.0 and containers-0.1, Build-Depends:      base >= 3, containers, what can possibly be wrong?
02:26:12 <EvilTerran> harumph.
02:28:31 <fasta> Setup.hs: At least the following dependencies are missing: base >=3, containers -any
02:30:50 <Lemmih> fasta: Do you have multiple versions of GHC installed?
02:41:38 <fasta> Lemmih: yes
02:41:44 <fasta> Lemmih: about 8
02:42:09 <fasta> I meant about 38 ;)
02:42:25 * fasta should delete some of those...
02:42:48 <Lemmih> Perhaps Setup.hs is using the wrong ghc-pkg.
02:42:50 <fasta> Oh, no, that included ghci and ghc-pkg, so about 8.
02:43:04 <fasta> Lemmih: no, I give the correct one as an argument.
02:43:58 <Lemmih> It disagrees.
02:46:38 <fasta> Lemmih: so, how can I verify that I use the right one? I _know_ I give the right one on the command-line. It might be that it gets ignored, but that's not my fault.
02:48:52 <Lemmih> fasta: Are you using --with-compiler and --with-hc-pkg?
02:48:57 <fasta> Lemmih: yes
02:49:38 <fasta> runhaskell Setup.*s configure --enable-library-profiling --with-compiler=$HOME/bin/ghc --with-hc-pkg=$HOME/bin/ghc-pkg --user --prefix=$HOME
02:49:44 <fasta> Lemmih: ^^ is what I use
02:50:18 <Lemmih> And '$HOME/bin/ghc-pkg list base'?
02:51:36 <fasta> base-3.0 with a dir above it
02:52:11 <Lemmih> Weird.
02:53:40 <Lemmih> Perhaps Setup.hs needs the cabal library from $HOME/bin/ghc.
02:55:02 <doserj> does "-v3" give some information?
02:56:16 <fasta> Loading package Cabal-1.3 ... linking ... done.
02:56:28 <fasta> I think Cabal-1.3 has to do with it.
02:56:48 <fasta> Loading package containers-0.1 ... linking ... done.
02:57:00 <fasta> It does load containers (the other dependency correctly)
02:57:44 <fasta> But it does say however at the end that containers-any is missing.
02:57:56 <fasta> I.e. it even reports inconsistent things.
02:58:09 <quicksilver> I have some vague memory that versions under 1.0 don't satisfy any?
02:58:15 <quicksilver> but it's possible that I made that up entirely
02:59:30 <fasta> base -any, containers >=0.1
02:59:43 <fasta> with containers >= 0.1 specified in build depends
02:59:50 <fasta> So, that's not true either.
03:00:29 <xpik2> does anyone here think llvm has a lot of potential?
03:00:57 <fasta> xpik2: that's not a question.
03:01:08 <fasta> xpik2: potential for what?
03:02:12 <Lemmih> fasta: You may have a messed up installation. For some reason, Cabal can't see or parse the package file.
03:02:50 <fasta> Lemmih: could be, but that would mean the GHC build is broken again.
03:03:13 <fasta> I will install the test suite.
03:03:49 <Lemmih> Does the testsuite test cabal?
03:04:05 <fasta> Lemmih: I would hope so.
03:04:20 <pejo> xpik, the "main author" has mailed atleast C---list suggesting that people switch to llvm. And the slashdot comments when pcc was imported in OpenBSD. And so on.
03:07:01 <huamn> is there a way to make some kind of an internal buffer to the appliation which could be then handled in both ends with System.IO functions like hPutStrLn etc?
03:07:20 <huamn> Control.Concurrent.Chan is something like that but it does not provide possibility to use System.IO functions
03:08:11 <xpik2> well, if manufacturers write drivers in llvm it could be good for users wanting to use an alternative hardware or OS?
03:25:28 <fasta> Lemmih: when I do ./Setup.hs configure, it does work.
03:28:00 <fasta> Lemmih: ok, I understand it completely now.
03:28:28 <fasta> Lemmih: I passed --user and the semantics of that apparently changed in this cabal version.
03:55:06 <dmwit> huamn: Like, make a pipe?
03:57:38 <dmwit> huamn: See System.Posix.IO, especially createPipe.
03:59:50 * SamB_XP wonders what language rašė is in
04:01:16 <quicksilver> huamn: yes, createPipe, although I think Concurrent.Chan is a better solution in most cases.
04:02:48 <SamB_XP> if all that is wanted is a way to exchange values in-process, yeah, Chan is probably better
04:39:37 --- mode: irc.freenode.net set +o ChanServ
04:59:01 <vincenz> osfameron: ping
05:01:32 <osfameron> vincenz: pong
05:01:45 <vincenz> osfameron: I don't feel like signing up for vox
05:01:45 <vincenz> so
05:02:14 <vincenz> Your parseMap is completely redundant.   Maybe is a monad, so you don't need to check member
05:02:17 <vincenz> parseMap = flip M.lookup
05:02:22 <vincenz> and if you want to constrain it to Maybe's only
05:02:23 <vincenz> add
05:02:36 <vincenz> parseMap :: (Ord k) => M.Map k a -> k -> Maybe a
05:02:42 <Beelsebob> anyone come across this error before? http://hpaste.org/4091
05:02:47 <Beelsebob> (attempting to build darcs)
05:02:49 <vincenz> though that's not really required
05:03:02 <quicksilver> Beelsebob: yes, they broke it
05:03:02 <vincenz> (since parseMechandise already constricts)
05:03:06 <Beelsebob> fail
05:03:13 <Beelsebob> any way to fix it?
05:03:16 <quicksilver> Beelsebob: darcs depends on an internal function they stopped exporting
05:03:23 <Beelsebob> ah, bugger
05:03:30 <quicksilver> Beelsebob: they propose to re-export the internal function for 6.8.2 last I heard
05:03:30 <Beelsebob> so it won't build against 6.8.1 at all?
05:03:39 <quicksilver> if there is a workaround, I don't know what it is
05:03:52 <Beelsebob> buggery
05:03:57 <vincenz> osfameron: Was gonna leave that in a comment, but I don't feel like signing up to vox :|
05:04:00 * Beelsebob really shouldn't have jumped on 6.8.1 yet
05:04:14 <vincenz> does hpc ship with 6.8?
05:06:22 <Saizan> vincenz: yes, there's a flag for it, iirc
05:06:30 <vincenz> spiffy
05:07:19 <osfameron> vincenz: heh, yeah, people have a lot of trouble with that :-(
05:07:33 <osfameron> vincenz: I don't understand how you avoid M.lookup throwing an error though
05:07:42 <vincenz> osfameron: 'fail' for Maybe is Nothing
05:07:49 <vincenz> @src fail Nothing
05:07:49 <lambdabot> Source not found. My pet ferret can type better than you!
05:07:52 <vincenz> @src Maybe fail
05:07:52 <lambdabot> fail _      = Nothing
05:08:27 <vincenz> > M.lookup 1 (fromList [(2,2)]) :: Maybe Int
05:08:28 <lambdabot>   Not in scope: `fromList'
05:08:29 <osfameron> vincenz: ok.  I guess that explains my question about why Lookup was monadic, and which monad it's in
05:08:34 <vincenz> > M.lookup 1 (M.fromList [(2,2)]) :: Maybe Int
05:08:35 <lambdabot>  Nothing
05:10:05 <vincenz> osfameron: :)
05:10:49 <osfameron> vincenz: dammit, now I have to refactor my blog post as well as the code...
05:11:04 <vincenz> Sorry :|
05:11:39 <osfameron> ;-)
05:14:38 <osfameron> vincenz:  I won't get chance to update before tomorrow - I'll have a play with it tonight though, thanks!
05:14:47 <vincenz> Welcome(:
05:14:58 * Beelsebob ponders where hmake's darcs repo is hiding
05:15:01 <Beelsebob> @where hmake
05:15:01 <lambdabot> http://haskell.org/hmake
05:15:05 <Beelsebob> :/
05:16:33 <roconnor> @type partition
05:16:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:16:35 <malcolmw> Beelsebob: it is part of nhc98's repo
05:16:47 <roconnor> > partition odd [1..]
05:16:48 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
05:17:00 <roconnor> > partition odd [1..5]
05:17:00 <Beelsebob> malcolmw: cheers, I had guessed as much, I'm halfway through grabbing it's patches
05:17:01 <lambdabot>  ([1,3,5],[2,4])
05:18:01 * Beelsebob ponders if it would be interesting to have a lambdabot that demands things in a different order
05:18:41 <Beelsebob> i.e. so that that first example would have resulted in something like ([1,3,5,7,9,11,13,15... ], [2,4,6,8,10,12,14,16... ])
05:18:52 <Beelsebob> to show that you can get snd without fully evaluating fst
05:19:23 <Beelsebob> would be somewhat more complex to implement than it is just now though
05:19:33 <quicksilver> Beelsebob: you'd have to reimplement show, woudln't you?
05:19:47 <Beelsebob> quicksilver: no, show is fine
05:19:49 <quicksilver> (that is, implement something like show, but with the ability to cascade maximum lengths)
05:19:56 <quicksilver> Beelsebob: ?
05:20:03 <Beelsebob> you'd hae to reimplement the inards of the evaluator to not use Lazy evaluation order
05:20:07 <int-e> yes you'd have to reimplement show for lambdabot
05:20:09 <quicksilver> ack!
05:20:12 <Beelsebob> something non-strict, but not lazy
05:20:15 <quicksilver> that sounds like a terrible way to do in, Beelsebob
05:20:21 <int-e> > show ([1..],[1..])
05:20:26 <quicksilver> much better just to implement an alternative show strategy
05:20:27 <quicksilver> IMO
05:20:34 <Cale> > uncurry zip . partition odd $ [1..]
05:20:36 <lambdabot>  thread killed
05:20:39 <int-e> what lambdabot does is essntially that.
05:20:43 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
05:20:44 <Beelsebob> quicksilver: except that show is limited by the order of evaluation in the compiler
05:20:54 <quicksilver> yes, so you implement a different show
05:20:59 <quicksilver> which takes a 'max length' down to sub-terms
05:21:06 <quicksilver> and reduces that as you descend the tree
05:21:14 <Beelsebob> hmm, true
05:21:17 <doserj> Beelsebob: show *defines* the order of evaluation
05:21:18 <Beelsebob> that would work nicely
05:21:22 <Beelsebob> it just wouldn't truely by correct
05:21:28 <quicksilver> why wouldn't it be correct?
05:21:35 <Beelsebob> sorry, correct wasn't the right word
05:21:42 <Beelsebob> it wouldn't be the "right" way to do it
05:21:51 <Beelsebob> in that it's simulating a different evaluation order within lazy evaluation
05:21:52 <quicksilver> btw, I don't htink "lazy evaluation order" is a very useful description
05:21:57 <quicksilver> the evaluation is demand-driven
05:22:01 <Beelsebob> indeed
05:22:02 <quicksilver> so the order depends on demand
05:22:07 <quicksilver> it's not inherent in the shape of the expression
05:22:21 <Beelsebob> indeed
05:22:58 <Beelsebob> IMHO the "correct" way to do this is to write an evaluator that evenly splits evaluation between the parts of the expression
05:23:05 <Beelsebob> rather than left-most outer-most first
05:23:10 <int-e> Beelsebob: whatever that means
05:23:44 <int-e> Beelsebob: really you can try to implement this. you'll end up with a show-like function that implements your evaluation policy.
05:23:52 <Beelsebob> int-e: so that the evluator rather than always demanding the next bit of the first list, first demands the head of the first list, then the head of the second, then the head of the tail of the first, then the head of the tail of the second etc
05:23:56 <ricky_clarkson> If you had an unsigned bounded type, say, UByte or something, could you get an a+b expression where a was evaluated and b not?
05:24:31 <ricky_clarkson> E.g., a=255, so a+b would always give 255, so b would not be evaluated.
05:24:32 <Beelsebob> int-e: I'm saying that the "correct" way to do it is to reimplement a section of ghc, not to reimplement a section of lambdabot
05:24:46 <quicksilver> Beelsebob: I think you misunderstand left-most outermost-first
05:24:58 <quicksilver> that is just talking about how you evaluate complex applications
05:25:07 <quicksilver> it doesn't explain how you evaluate general expressions
05:25:11 <Beelsebob> sorry, yes, it is
05:25:14 <int-e> Beelsebob: the leftmost outermost semantics stem from the implementation of  show.  lambdabot uses show to generate its output string.
05:25:21 <quicksilver> as I said early, the order of evaluation of general expressions is demnad driven
05:25:24 <quicksilver> so this is all driven by show
05:25:29 <quicksilver> and nothing to do with ghc internals
05:25:37 <quicksilver> any other non-strict compiler would do the same
05:25:51 <int-e> there is no magic "give me a representation of this value" function, it's all Haskell.
05:26:04 <Beelsebob> true that
05:26:11 <Beelsebob> yeh, I'm being a moron
05:26:25 <quicksilver> having said that
05:26:29 <quicksilver> I do think it would be a nice thing to have
05:26:36 <quicksilver> (the alternate show instance)
05:26:45 <quicksilver> fun for lambdabot, handy for some other things too
05:26:47 <idnar> ricky_clarkson: I don't see why not
05:26:47 <Beelsebob> well, it's more of a pretty
05:26:51 <idnar> ricky_clarkson: (+) 255 _ = 255
05:26:55 <quicksilver> yeah, more of a pretty, I agree
05:27:19 <Beelsebob> my appologies for so vehemently being a moron
05:27:28 <Beelsebob> more listening required there
05:30:32 <ricky_clarkson> How do multi-threaded Haskell programs such as GUIs work?  I'm trying to work out how I can do it better in $IMPERATIVE_LANG.
05:30:39 <ricky_clarkson> ..is there a specific doc to read?
05:31:22 <int-e> @docs Control.Concurrent
05:31:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
05:31:37 <ricky_clarkson> 404
05:31:53 <int-e> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Concurrent.html
05:31:54 <lambdabot> http://tinyurl.com/38fp5d
05:31:55 <ricky_clarkson> (lambdabot should check her own URLs too ;) )
05:33:04 <int-e> some missing symlinks on the server. (at least I think they should be symlinks.)
05:34:08 <EvilTerran> yeah, it'd make sense if .../FOO/... symlinked to .../FOO-LATEST/...
05:35:01 <int-e> @index par
05:35:02 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
05:35:43 <int-e> There's also STM (http://haskell.org/ghc/docs/latest/html/libraries/stm-2.1.1.0/Control-Concurrent-STM.html) And there is Control.Parallel (http://haskell.org/ghc/docs/latest/html/libraries/parallel-1.0.0.0/Control-Parallel.html) for parallel evaluation in pure code.
05:35:49 <lambdabot> http://tinyurl.com/2oo6kp
05:35:51 <int-e> Did I miss anything?
05:36:07 * osfameron kicks technorati
05:37:10 <quicksilver> ricky_clarkson: you spawn little worker threads to do the work
05:37:20 <quicksilver> ricky_clarkson: and you let the GUI library main loop hold the main thread
05:37:30 <quicksilver> normally you're not allowed to do drawing direct from the worker threads
05:37:37 <quicksilver> (and that's normally a bad idea even if it was allowed)
05:37:48 <quicksilver> so you communicate with Mvars or Chans when work is done
05:37:48 <ricky_clarkson> How do you tell whatever does the drawing what to redraw?
05:37:57 <quicksilver> with an mvar or a chan
05:38:07 <quicksilver> simplest case, just an MVar ()
05:38:09 <ricky_clarkson> A Chan is like a [Event] or something?
05:38:19 <quicksilver> redrawflag :: MVar ()
05:38:26 <quicksilver> -- in worker thread
05:38:35 <quicksilver> tryPutMVar redrawflag ()
05:38:50 <quicksilver> -- in grpahics thread
05:39:08 <quicksilver> case tryTakeMVar redrawflag of Nothiing -> return () ; Just () -> redraw
05:41:22 <ddarius> @google A Concurrent Windowing System
05:41:23 <lambdabot> http://citeseer.ist.psu.edu/pike89concurrent.html
05:41:23 <lambdabot> Title: A Concurrent Window System - Pike (ResearchIndex)
05:42:24 <quicksilver> ricky_clarkson: and yes, a Chan Event is a bit like [Event]
05:42:34 <quicksilver> ricky_clarkson: but with multiple writers and readers, safely
05:42:47 <quicksilver> ricky_clarkson: although in this case you'd have multipler writers but one reader, more likely
05:42:58 <ricky_clarkson> Makes sense.
05:43:08 <ddarius> There's no such thing as multiple writers of a [Event]
05:43:24 <nominolo> so, did dons' publicity piece attract some people, yet?
05:43:32 <ddarius> Which?
05:43:59 <nominolo> programming.reddit.  top story
05:44:11 <nominolo> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/26#no-headaches
05:44:12 <lambdabot> Title: Haskell hacking
05:44:29 <nominolo> that title is rather wrong
05:44:30 <ddarius> You mean people to this channel?
05:44:43 <nominolo> yes
05:45:30 <osfameron> ddarius: hi
05:45:53 <ddarius> hey
05:46:11 <osfameron> ddarius: ta for the comment - I don't understand what it means for the fields of a record to be strict
05:46:39 <osfameron> or what problems it is causing/will cause for them not to be :-)
05:46:54 <ddarius> Well to specify it you just add a !, i.e. data GameState = GS { turn :: !Integer, ... etc. }
05:47:24 <nominolo> and use -funbox-strict-fields orwhatsitcalled
05:47:27 <osfameron> ah, I've seen that syntax quoted.  I believe it's a langauge extension?
05:47:28 <osfameron> ah, ok
05:47:30 <ddarius> What can happen is if you aren't looking at a field too often, but are modifying it you can build up thunks
05:47:35 <ddarius> osfameron: That particular use isn't.
05:47:55 <ddarius> When it is used on arguments of a function it is, e.g. f !x = x:xs
05:48:34 <osfameron> what do you mean by "build up thunks" ?
05:48:35 <ddarius> So you may increment turn each "turn" of the game, but not often have reason to look at it so it builds up as 0+1+1+1+1+1
05:48:46 <osfameron> ah, ok
05:48:58 <osfameron> so that the whole thing gets evaluated in one fell swoop later
05:49:30 <ddarius> In some cases this can lead to stack overflow though I doubt that would actually occur in your case, but usually you have no reason for such fields to be lazy and as nominolo mentions having them be strict opens some optimizations.
05:49:34 <nominolo> you'll need {-# LANGUAGE BangPatterns #-}
05:49:43 <ddarius> nominolo: Not for what I suggested.
05:49:51 <nominolo> ok
05:50:34 <wolverian> does any ghc release yet have data parallelism builtin?
05:51:18 <ddarius> The current ones have the syntax and the libraries but they aren't connected (except maybe in 6.8.1?), I think GHC HEAD has them connected.
05:51:23 <opqdonut> is 6.6 binary-compatible with 6.6.1?
05:51:25 <nominolo> should be in 6.8.1.  but it's still experimental iirc
05:51:34 <nominolo> opqdonut: no
05:51:38 <opqdonut> ah, okay
05:51:47 <ddarius> opqdonut: There is a version field in the libraries so no version is binary compatible with another.
05:51:57 <wolverian> ddarius, thanks!
05:51:58 <opqdonut> ah okay
05:52:10 <ddarius> That said, hacking that field with a hex editor would probably work more often than not.
05:52:19 <opqdonut> so i need to have 6.6 runtime libs to run stuff compiled with it?
05:52:36 <ddarius> opqdonut: ? No.
05:52:55 <nominolo> opqdonut: yes, libraries have to be compiled with the same ghc as your program
05:52:57 <ddarius> Each program should be standalone except for maybe on OSX.
05:53:11 <opqdonut> yeah okay
05:53:22 <nominolo> opqdonut: but ghc links statically by default
05:57:26 <chessguy> 'morning
06:04:25 <osfameron> ddarius: thanks for the suggestions, I'll have a look at that in more detail tonight and update tomorrow
06:07:32 <osfameron> chessguy: thanks :-)
06:07:48 <chessguy> osfameron, thank you!
06:09:13 <chessguy> your blog is quickly rising to the top of my list of interesting blogs to watch
06:11:09 <Ingon> Hi, I'm trying to have something like reverted Maybe, and promote it to monad... here it is:
06:11:12 <hpaste>  Ingon pasted "Monads" at http://hpaste.org/4092
06:11:33 <Ingon> but it seems like i miss something...
06:11:50 <quicksilver> I doubt that's a monad
06:12:10 <quicksilver> hmm
06:12:11 <hpaste>  Ingon annotated "Monads" with "(no title)" at http://hpaste.org/4092#a1
06:12:11 <quicksilver> maybe it is
06:12:34 <quicksilver> that can't be right :)
06:12:45 <Ingon> it is not
06:12:46 <quicksilver> you can't have a useful monad which ignores the value in return
06:12:49 <chessguy> isn't that just pretty much the same asmaybe?
06:13:04 <Ingon> yes in the other way
06:13:06 <chessguy> i think he means return = Commit
06:13:11 <Saizan> no, that doesn't compile
06:13:14 <Ingon> return _ = Commit
06:13:47 <quicksilver> Ingon: don't forget (return x) >>= f should be f x
06:14:01 <quicksilver> Igloo: try 'return 1 >>= Rollback'
06:14:07 <quicksilver> Igloo: oops, sorry!
06:14:11 <vincenz> that's illtyped
06:14:13 <quicksilver> Ingon: that was for you :)
06:14:37 <Ingon> but it holds that
06:14:53 <Ingon> I mean (return x) >>= f should be f x
06:15:05 <Ingon> return x is Commit
06:15:22 <quicksilver> return x >>= Rollback
06:15:22 <hpaste>  vincenz annotated "Monads" with "fix?" at http://hpaste.org/4092#a2
06:15:27 <Ingon> ooo, but f does not really needs this
06:15:28 <quicksilver> should be Rollback x
06:15:32 <quicksilver> and it isn't
06:15:43 <hpaste>  vincenz annotated "Monads" with "whoops - this should do it" at http://hpaste.org/4092#a3
06:16:01 <Ingon> that is Either
06:16:03 <Ingon> actually
06:16:11 <vincenz> nearly
06:16:11 <quicksilver> yes, it is :)
06:16:16 <vincenz> Either has some more constraints
06:16:22 <Ingon> :)
06:16:24 <quicksilver> does it?
06:16:27 <vincenz> yeah
06:16:29 <vincenz> it's
06:16:34 <vincenz> instance Monad (Either ErrMsg)
06:16:42 <quicksilver> ah, that's not what I meant
06:16:46 <quicksilver> that type is either
06:16:49 <quicksilver> fail is broken anyway
06:16:52 <vincenz> yah
06:16:52 <quicksilver> I ignore fail :P
06:17:43 <Ingon> so I can collect all the eventual changes... but that is not what I mean :)
06:18:15 <quicksilver> Ingon: what do you mean, in fact?
06:18:17 <vincenz> Ingon: oh!
06:18:22 <vincenz> sec
06:18:23 <quicksilver> I strongly suspect you have a monoid but not a monad
06:18:27 <quicksilver> or, what you want isn't >>=
06:18:31 <vincenz> quicksilver: monoids give rise to monads :)
06:18:31 <Ingon> it could be
06:18:31 <quicksilver> you want `mplus`
06:18:42 <quicksilver> vincenz: not invariably
06:18:50 <quicksilver> monads have some way of threading return values
06:18:50 <vincenz> s/invariably/??
06:19:03 <Ingon> I whant to compose actions -> if action Commits, than next action is called
06:19:10 <quicksilver> I'm not sure Ingon even wants to thread return values
06:19:12 <Ingon> if not - an error is promoted to the runner
06:19:19 <quicksilver> Ingon: yes, what you want is sensible, but it's not >>=
06:19:24 <quicksilver> >>= is about threading return values
06:19:31 <quicksilver> and you're not trying to that, as far as I can see
06:19:40 <Ingon> >> is what I need more :)
06:19:48 <quicksilver> what you're doing is actually modelled by `mplus` in Either
06:19:57 <quicksilver> but I would just use a custom combinator for now
06:20:09 <quicksilver> no value in instantiating monad if you're not doing anything monadic
06:20:22 <Ingon> mhm
06:20:35 <vincenz> Ingon: why do you 'need' >>= ?
06:21:23 <vincenz> quicksilver: there is a way to do it
06:21:36 <Ingon> to use the pretty do notation ;) I was just picturing a sequence of things, do this do this...
06:22:18 <vincenz> let me roll it up )
06:22:44 <vincenz> two questions
06:22:47 <vincenz> Igloo: what is the 'a' in Rollback
06:22:53 <vincenz> erm ignon
06:22:56 <vincenz> and secondly
06:22:58 <Ingon> fail reason
06:23:05 <vincenz> how do reasons combine?
06:23:11 <vincenz> jsut atke the first?
06:23:15 <Ingon> yes
06:23:28 <Ingon> actually, after a fail no more actions are performed
06:24:01 <doserj> Ingon: you can also use do-notation, when you only define (>>)
06:25:57 <vincenz> hmm
06:26:00 <vincenz> really sounds like either :|
06:27:21 <quicksilver> it sonds like mplus for either to me
06:27:30 <quicksilver> then if you have a lot in a row, you use mconcat
06:27:40 <quicksilver> mconcat [action1,action2,action3,action4]
06:27:51 <quicksilver> (but you can write them on separate lines if you want!)
06:28:00 <vincenz> quicksilver: it sounds like Either monad "if fail then stop with reason"
06:30:18 <Saizan> i wonder what's the use for a transaction that you only knows it commits
06:33:55 <Saizan> also usually if you have a list of transactions if the nth rollbacks you're back to what you had after the (n-1)th, not at the start
06:34:06 <Saizan> but this is just semantic :)
06:34:30 <Ingon> Actually it sould be called TransactionStatus maybe
06:35:06 <Ingon> but the idea is that I have something linke - runInTransactions with these sequenced
06:35:24 <Ingon> which performrs actual commit or rollback based on the result
06:35:43 <Ingon> but no need of performing actions after one has failed
06:38:43 <Saizan> so you're pairing it with a description of what your transaction actually does?
06:39:30 <Ingon> I'm not really sure what you ask
06:40:41 <Saizan> well, i'm not sure what you're modelling, but a transaction usually has some effect on some kind of state
06:41:30 <Ingon> oh sure
06:41:51 <Ingon> the initial idea was to have type of actions -> DB -> (DB, Status)
06:43:29 <darrint> Is there some example code online which shows a simple use of all the Writer monad's convenience functions? tell, pass, censor?
06:43:30 <Saizan> i'd use DB -> Either Reason DB, which is roughly ErrorT Reason (StateT DB) ()
06:44:11 <shapr> Good morning #haskell!
06:44:28 <Ingon> hmm..
06:44:46 <Saizan> s/StateT/State/
06:44:48 <Ingon> monad transformers
06:45:26 <Saizan> well you can unroll them making your own monad
06:45:41 <Saizan> ?untml ErrorT Reason (StateT DB) ()
06:45:41 <lambdabot> Maybe you meant: unmtl unpl
06:45:49 <Saizan> ?unmtl ErrorT Reason (StateT DB) ()
06:45:49 <lambdabot> err: Unknown MTL(1)
06:45:53 <Saizan> ?unmtl ErrorT Reason (State DB) ()
06:45:53 <lambdabot> DB -> (Either Reason (), DB)
06:46:05 <Saizan> ah
06:46:08 <Saizan> i had it wrong
06:46:25 <Saizan> ?unmtl StateT DB (Either Reason) ()
06:46:26 <lambdabot> err: Unknown MTL(1)
06:47:53 <Saizan> ah well, newtype TransactionM a = T (DB -> Either Reason (a,DB))
06:53:11 <Ingon> hm...
06:53:22 <Ingon> will have to understand this one
06:54:04 <Saizan> well it will be the monad of actions that may transform a DB or fail with a Reason
06:55:13 <Saizan> but the trasformation is opaque, everything happens inside the function
06:58:22 <Ingon> ok, but then what will be the type of the functions ? stop :: DB -> Either Reason (a,DB) ?
07:00:12 <Saizan> if you use the newtype and declare it a monad, possibily also a MonadState and MonadError, you'd get stop :: TransactionM a
07:01:06 <Saizan> stop = T (\_ -> Left thereason)
07:03:33 <Saizan> or stop = throwError thereason, once you've instanced MonadError
07:04:25 <Ingon> actually stop is not a function... or its a function with no arguments returning "instance" which have a function in it?
07:04:26 <fasta> I asked this question before, but is there any way to do a list of actions and stop whenever the result of one of them is True, but by using combinators, not just one function that does that? In spirit it should be equal to liftM any $ mapM returningBool list, but it should only execute the actions until one returns True.
07:05:08 <fasta> Is there some unsafe operation that can provide these semantics?
07:05:11 <yrlnry> @pl \f -> let x = f x in x
07:05:11 <lambdabot> fix
07:05:15 <yrlnry> heh.
07:05:34 <osfameron> takeWhile False ?
07:06:08 <fasta> osfameron: the problem is that the number of side effects performed should depend on lazyness.
07:06:26 <fasta> osfameron: mapM normally just executes them all.
07:06:29 <Saizan> Ingon: stop is a function wrapped in the constructor T of your monad, this function (\_ -> Left reason) ignores its argument (the DB) and returns Left reason
07:07:16 <Ingon> aha
07:07:18 <Ingon> insert :: TransactionM Stringinsert = T (\db -> Right $ ("Do something...", db))
07:07:20 <Saizan> Ingon: i assumed that in the definition of >>= for this monad Left indicates failure/rollback and so aborts the successive actions
07:07:23 <yrlnry> @pl \Y f-> f (Y f)
07:07:23 <lambdabot> ap id
07:07:36 <yrlnry> @src ap
07:07:36 <lambdabot> ap = liftM2 id
07:07:46 <Ingon> mhm
07:08:00 <Saizan> well insert needs to return a modified db
07:08:09 <yrlnry> @pl \Y f x-> f (Y f) x
07:08:09 <lambdabot> ap id
07:09:03 <yrlnry> @pl \r a b c d e f g h i j k l m n o p q s t u v w x y z -> (r (t h i s i s a f i x e d  p o i n t c o m b i n a t o r))
07:09:05 <Saizan> insert v = T (\db -> Right ((),insertDB v db)), or just insert v = modify (insertDB v), once you've MonadState
07:09:06 <lambdabot> ((((((const .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .) .)
07:09:06 <lambdabot>  .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .)
07:09:06 <lambdabot> . (((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
07:09:06 <lambdabot>  . (.) . (.) . (.) . (.) . (.)) (flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .)
07:09:09 <lambdabot> .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
07:09:12 <lambdabot> [27 @more lines]
07:09:14 <lambdabot> optimization suspended, use @pl-resume to continue.
07:09:16 <yrlnry> Oops.  Sorry.
07:09:34 <fasta> yrlnry: how about you don't spam the channel?
07:09:50 <Saizan> modify f = T (\db -> ((), f db))
07:10:37 <Saizan> yrlnry: err
07:10:44 <Saizan> modify f = T (\db -> Right ((), f db))
07:11:45 <yrlnry> I didn't know that the result would be so big.  Sorry again.
07:11:50 <shapr> hiya jewel, how's code?
07:11:57 <hpaste>  Ingon pasted "Monad?" at http://hpaste.org/4094
07:12:03 <shapr> Yay monads!
07:12:06 * shapr boings
07:12:23 <Ingon> if i understand correctly def should be something like this?
07:12:29 <Saizan> yrlnry: k, btw fixed point combinators can't be expressed as lambda abstractions in haskell
07:13:08 <Saizan> Ingon: almost
07:13:29 <osfameron> fasta: oh :-(  didn't know that, was hoping it would just magically work lazily (I'm still at the superstitious stage of haskell development :-)
07:13:45 <Saizan> first, instance Monad TransactionM where .. since the monad is the type constructor
07:13:45 <Ingon> yes, gives me an error
07:14:19 <Ingon> ha
07:14:21 <vincenz> Ingon: that won't work for two reasons
07:14:29 <vincenz> Ingon: first, return doesn't return a valid monadic entity
07:14:34 <vincenz> it's supposed to return a wrapped function
07:14:40 <vincenz> secondly you're forcing a == DB
07:14:53 <Saizan> Ingon: secondly, there f :: DB -> Either Reason (a,DB), not already Either Reason (a,DB)
07:15:45 <vincenz> Ingon: that's my first point
07:15:47 <vincenz> erm
07:15:52 <vincenz> s/ Ingon / Saizan
07:16:03 <vincenz> oh waith ,the f too?
07:16:06 * vincenz checks again
07:16:08 <Saizan> yeah
07:16:38 <Saizan> and g wants x as argument not db, you've to feed db after unwrapping the monad
07:17:12 <yrlnry> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
07:17:12 <lambdabot> ap (. join id) (. join id)
07:17:19 <vincenz> yeah
07:17:27 <alexj> @seen igloo
07:17:27 <lambdabot> igloo is in #ghc, #darcs and #haskell. I last heard igloo speak 1h 28m 17s ago.
07:18:09 <vincenz> seems like a combinatio nof a failure and a state monad
07:18:40 <Saizan> well yes, it's just an unrolled StateT DB (Either Reason)
07:19:24 <hpaste>  vincenz annotated "Monad?" with "foo" at http://hpaste.org/4094#a1
07:19:34 <vincenz> Saizan: but the other way makes more sense
07:19:44 <vincenz> EitherT (StateT s m) a
07:19:52 <vincenz> or not?
07:20:05 <Saizan> no
07:20:23 <Saizan> ?unmtl ErrorT Reason (State DB)
07:20:23 <lambdabot> err: Unknown MTL(1)
07:20:28 <Saizan> ?unmtl ErrorT Reason (State DB) a
07:20:28 <lambdabot> DB -> (Either Reason a, DB)
07:20:43 <Saizan> this way you always get a DB back
07:20:54 <vincenz> Oh right
07:20:54 <Saizan> possibly transformed
07:21:04 <vincenz> bleh, transofformers always stack counter-intuitively
07:21:26 <Saizan> yeah, becose the outermost transformer ends up being the inner monad :)
07:21:54 <ramza3> http://darcs.haskell.org/hxt-typesafe/doc/  I was thinking of using hxt for an html parser, is this a good library to use for such a task. Basically, I need to parse a html document and find all of the links on a page
07:21:55 <lambdabot> Title: Haskell XML Toolbox 4.02
07:22:06 <vincenz> Saizan: right and you also call the run's in the opposite direction if you newtype your transformer stack and make your custom run :)
07:22:21 <ramza3> with ghc, just asking in the event it isn't maintained
07:22:59 <quicksilver> ramza3: it's maintained but I'm not sure how well it performs on invalid XML
07:23:11 <quicksilver> maybe someone else knows better
07:23:43 <ramza3> quicksilver: it says it  supports liberal html
07:24:56 <quicksilver> ramza3: ah, then I think youre' OK
07:24:57 <Saizan> this reminds me that i was looking for a way to compose CPS transformed monads without nesting continuations
07:25:06 <Ingon> but it again does not compiles :(
07:25:07 <vincenz> LOL: http://worsethanfailure.com/Articles/Overruled-by-RemoveSpecialCharsExceptQuoteAmpersand.aspx
07:25:08 <lambdabot> Title: Overruled by RemoveSpecialCharsExceptQuoteAmpersand... - Worse Than Failure, http://tinyurl.com/yrblmj
07:27:06 <hpaste>  Saizan annotated "Monad?" with "unwrapping the newtype" at http://hpaste.org/4094#a2
07:27:25 <Saizan> err, it's not = but -> there
07:27:41 <ToRA> fasta: foldr1 (\l r -> l >>= \n -> if n then return True else r) ?
07:27:44 <ramza3> vincenz: I just read that on reddit, that guy should never work as a developer again.  Unless it is a cruel joke to make a point, then it is ok
07:28:09 <fasta> ToRA: that's not the same idea, just an obvious implementation.
07:28:10 <vincenz> Saizan: missing a '
07:28:16 <ToRA> fasta: tho i don't know of any way to make it neater
07:28:20 <vincenz> ramza3: not to mention, who the hell uses charcodes?!?
07:28:41 <fasta> ToRA: oh, you get quite a lot of neat points.
07:28:47 <fasta> ToRA: it's just not what I asked for.
07:29:08 <ToRA> fasta: it does what you ask for..i.e. it is lazy
07:29:16 <ToRA> fasta: it's just not neat in terms of combinators
07:29:34 <Saizan> vincenz: heh, i'm still thinking of adding a type checker to firefox/hpaste :)
07:29:34 <fasta> ToRA: The question specifically referred to _how_.
07:29:36 <ramza3> vincenz: are you gnuvince on reddit
07:30:10 <vincenz> ramza3: no
07:30:11 <vincenz> ramza3: I am vincenz
07:30:27 <vincenz> Saizan: that'd be neat
07:30:56 <Saizan> fasta: so you want an unsafeInterleaveM ?
07:31:45 <fasta> Saizan: yep
07:34:50 <vincenz> fasta: easy :)
07:35:47 <fasta> vincenz: unsafeInterleaveIO + unsafePerformIO? + return?
07:35:57 <vincenz> sequence_ $ interleaveWith (\b -> if b then fail undefined else return ()) $ map const actions
07:36:04 <vincenz> sequence_ $ interleaveWith (\b -> if b then fail undefined else return False) $ map const actions
07:36:14 <ToRA> @type  foldM (flip if' (return True)) False
07:36:18 <lambdabot> Not in scope: `if''
07:36:25 <fasta> vincenz: interleaveWith?
07:36:28 <fasta> vincenz: is that new?
07:36:41 <vincenz> fold (>>=) $ intercalate (\b -> if b then fail undefined else return False) $ map const actions
07:36:44 <vincenz> there you go
07:36:50 <vincenz> make that a foldl1
07:37:11 <fasta> vincenz: and where can I find this intercalate?
07:37:16 <vincenz> @hoogle intercalate
07:37:16 <lambdabot> No matches found
07:37:22 <fasta> vincenz: it doesn't appear to be in 6.9
07:37:24 <vincenz> hmm
07:37:27 <Saizan> for a general monad the problem is not lazyness, but threading of effects, you've to incapsulate shortcircuting in your monad or write a different mapM
07:37:27 <vincenz> well it's just interleaving
07:37:34 <vincenz> you could always define it, it's pretty generic
07:38:16 <vincenz> intercalate _ [] = []; intercalate _ [x] = [x]; intercalate e (x:y:xs) = x:e:intercalate e (y:xs)
07:38:28 <Saizan> intercalate x = concat . interleave x
07:38:39 <vincenz> @hoogle interleave
07:38:39 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
07:38:39 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
07:38:44 <Saizan> err
07:38:47 <Saizan> intersperse
07:38:52 <vincenz> @hoogle intersperse
07:38:52 <lambdabot> List.intersperse :: a -> [a] -> [a]
07:38:54 <vincenz> oh
07:38:56 <vincenz> I meant intersperse
07:39:15 <vincenz> foldl (>>=) (return True) $ intersperse (\b -> if b then fail undefined else return False) $ map const actions
07:39:23 <vincenz> erm, make that return False )
07:39:29 <vincenz> although it matters not as the first is a const action
07:39:43 <ToRA> what's wrong with (assuming if')
07:39:45 <ToRA> foldM (flip if' (return True)) False
07:39:46 <ToRA> ?
07:39:47 <vincenz> @type foldl (>>=) (return True) $ intersperse (\b -> if b then fail undefined else return False) $ map const
07:39:49 <lambdabot>     Couldn't match expected type `[Bool -> m Bool]'
07:39:49 <lambdabot>            against inferred type `[a] -> [b -> a]'
07:39:49 <lambdabot>     In the second argument of `($)', namely `map const'
07:39:52 <vincenz> @type foldl (>>=) (return True) $ intersperse (\b -> if b then fail undefined else return False) . map const
07:39:53 <lambdabot>     Couldn't match expected type `[Bool -> m Bool]'
07:39:53 <lambdabot>            against inferred type `[m1 Bool] -> [Bool -> m1 Bool]'
07:39:53 <lambdabot>     In the second argument of `($)', namely
07:39:55 <vincenz> grr
07:40:03 <vincenz> @type foldl (>>=) (return True) . intersperse (\b -> if b then fail undefined else return False) . map const
07:40:04 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
07:40:07 <vincenz> :)
07:40:25 <Ingon> Saizan: that is not it (http://hpaste.org/4094) because returned type is b...
07:40:34 <vincenz> ToRA: if' doesn't exist :)
07:40:54 <ToRA> vincenz: :p
07:41:03 <Saizan> Ingon: uh?
07:41:17 <ToRA> vincenz: /other/ than that?
07:41:18 <Saizan> ?type (>>=)
07:41:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:41:21 <Ingon> you are actually performing the second action?
07:41:50 <Saizan> Ingon: yes, >>= is supposed to give you the result of the second action in the end
07:42:23 <Saizan> Ingon: which can still rollback by itself
07:43:16 <Saizan> > foldl (>>=) (return True) . intersperse (\b -> if b then fail undefined else return False) . map const $ map (==5) [1..]
07:43:17 <lambdabot>  Couldn't match expected type `m Bool' against inferred type `Bool'
07:43:29 <fasta> vincenz: I don't see why fail would give the same semantics as ToRA's code.
07:43:35 <Saizan> > foldl (>>=) (return True) . intersperse (\b -> if b then fail undefined else return False) . map const $ map (Just . (==5)) [1..]
07:43:44 <lambdabot> Terminated
07:44:01 <vincenz> fasta: what are you asking then?
07:44:14 <vincenz> fasta: I thought your only dissatisfaction was that it was not combinatorized
07:44:15 <Saizan> yeah, fail there is assuming that your monad can recover from it
07:44:54 <Saizan> > foldl (>>=) (return True) . intersperse (\b -> if b then fail undefined else return False) . map const $ map (Just . (==5)) [1,5,undefined]
07:44:54 <lambdabot>  Nothing
07:44:57 <vincenz> and the reason is
07:45:03 <vincenz> ToRA's will execut all actions afaict
07:45:05 <vincenz> returns aren't global
07:45:15 <vincenz> or did I misread his code
07:45:34 <ToRA> vincenz
07:45:37 <ToRA> vincenz: ah, yeah
07:45:54 <Saizan> ?type foldM (flip if' (return True)) False
07:45:55 <lambdabot> Not in scope: `if''
07:46:08 <ToRA> vincenz: it doesn't evaluate all actions, but i think it does force the spine of the list
07:46:12 <Saizan> ?type foldM (flip (\b a c -> if b then a else c) (return True)) False
07:46:13 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
07:46:24 <vincenz> ToRA: right, I think mine is lazy?
07:46:35 <vincenz> if the moand is sufficiently lazy when failed
07:46:50 <Saizan> vincenz: yes, but fasta didn't want to fail
07:47:18 <vincenz> oh
07:47:31 * vincenz stops giving answers to queestions he half read and tuns
07:47:57 <Saizan> > foldM (flip (\b a c -> if b then a else c) (return True)) False $ map (Just . (==5)) [1..]
07:48:00 <lambdabot> Terminated
07:48:09 <Saizan> > foldM (flip (\b a c -> if b then a else c) (return True)) False $ map (Just . (==5)) [1,5,6,undefined]
07:48:10 <lambdabot>  Just True
07:49:15 <ToRA> yeah, the foldM forces the spine, not the values
07:49:21 <vincenz> what of mine?
07:49:27 <ToRA> Saizan / mine
07:49:37 <Saizan> yours force the spine too
07:49:39 <vincenz> ah
07:49:47 <Saizan> > foldl (>>=) (return True) . intersperse (\b -> if b then fail undefined else return False) . map const $ map (Just . (==5)) [1..]
07:49:51 <lambdabot> Terminated
07:49:53 <ToRA> Saizan: yes, that's what i just said...
07:49:54 <vincenz> :|
07:50:14 <Saizan> ToRA: i meant vincenz's one
07:50:30 <vincenz> shame
07:50:46 <Saizan> we need something like takeWhileM or takeUntilM to write this with a combinator
07:50:46 <vincenz> @src Maybe (>>=)
07:50:46 <lambdabot> (Just x) >>= k      = k x
07:50:46 <lambdabot> Nothing  >>= _      = Nothing
07:51:31 <vincenz> > foldr (>>=) (return True ) . intersperse (\b -> if b then fail undefined else return False) . map const $ map (Just . (==5)) [1..]
07:51:34 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
07:51:34 <lambdabot>     Probabl...
07:51:37 <pitecus> What would one do to write a function which works on both lists and ByteStrings?
07:51:47 <vincenz> > foldr (=<<) (return True ) . intersperse (\b -> if b then fail undefined else return False) . map const $ map (Just . (==5)) [1..]
07:51:50 <lambdabot>  Exception: stack overflow
07:52:01 <vincenz> it could be worse :)
07:52:45 <Saizan> pitecus: write a String typeclass first, but sometimes you can just change imports
07:53:22 <Saizan> mmh
07:53:35 <pitecus> Saizan, what methods would the typeclass have?
07:53:49 <vincenz> Saizan: why string and not 'list'?
07:53:57 <vincenz> instance List [] ...
07:54:03 <vincenz> oh, bs's only do chars?
07:54:09 <Saizan> exactly
07:54:11 <vincenz> shame
07:54:32 <Saizan> and internally they are just Word8
07:54:53 <byorgey> vincenz: how would BS's do anything other than chars?
07:55:25 <Saizan> pitecus: that's a good question, and i think it depends how you want to use it
07:55:44 <fasta> Maybe I should start asking easier questions :)
07:55:57 <Saizan> byorgey: well they could do Storable a => a quite easily i think
07:56:33 <byorgey> Saizan: oh, I see, store elements in a serialized format?
07:56:57 <pitecus> hm
07:57:07 <Saizan> fasta: well, propose some additions to Control.Monad :)
07:57:34 <fasta> Saizan: you mean an extra method?
07:57:54 <Saizan> fasta: no, just something like takeWhileM
07:58:12 <fasta> Saizan: oh, I already have that in my own lib and the politics take too long.
08:00:08 <Saizan> byorgey: yes, ByteStrings are roughly a Ptr Word8 + size
08:00:54 <BMeph> Hello, all.
08:01:11 <byorgey> Saizan: right, that makes sense.
08:01:21 <byorgey> hello BMeph.
08:01:48 <BMeph> Could I get a refresher on GHC? It's flipping out about not understanding functions as monads.
08:02:04 <byorgey> BMeph: perhaps you need to import Control.Monad.Instances?
08:02:40 <byorgey> I assume you are referring to the ((->) r) monad instance.
08:03:35 <BMeph> Okay. Is there some way to do that in the .ghci file? My copy of GHCi compiles my function fine, but the one at work is complaining.
08:04:01 <BMeph> byorgey: You assume correctly.
08:04:39 <byorgey> BMeph: sure, just add the line ':m +Control.Monad.Instances' to your .ghci file.
08:04:52 <Saizan> or import the module in your source
08:04:54 <byorgey> you can also just type that at the GHCi prompt before entering your function.
08:05:17 <byorgey> Saizan's suggestion is probably the best course of action.
08:06:14 <hpaste>  BMeph pasted "Works at home, not at work." at http://hpaste.org/4095
08:08:08 <Beelsebob> wow, that's a really nice example of how not to write Haskell
08:08:14 <BMeph> I'm mostly interested in figuring out why my home setup has no problem with it, but the one at work does. The machines are different, but the GHC (6..8.1) is fresh out of the "box" in both cases.
08:08:38 <BMeph> Beelsebob: Flatterer. ;p
08:08:39 <Beelsebob> :t (uncurry (flip (++)).).((splitAt 1).).liftM2 (.) intersperse (:)
08:08:44 <lambdabot> forall a. a -> [a] -> [a]
08:09:05 <Beelsebob> > ((uncurry (flip (++)).).((splitAt 1).).liftM2 (.) intersperse (:))  5 [1,2,3]
08:09:07 <fasta> BMeph: error messages?
08:09:10 <lambdabot>  [5,1,5,2,5,3,5]
08:09:15 <BMeph> Imagine if intersperse put the item at the front and back of the list. That's what this does.
08:09:22 <Beelsebob> > ((uncurry (flip (++)).).((splitAt 1).).liftM2 (.) intersperse (:))  5 [1,1,1,2,3]
08:09:23 <lambdabot>  [5,1,5,1,5,1,5,2,5,3,5]
08:09:30 <Beelsebob> isn't that just intersperse?
08:09:48 <Beelsebob> or am I missing something?
08:09:52 <quicksilver> it's intersperse pluse end-bracketing
08:09:58 <quicksilver> as BMeph just said :)
08:10:04 <Beelsebob> oh, missed that
08:10:04 <BMeph> Beelsebob: Intersperse doesn't put the items at the ends.
08:10:16 <osfameron> so it's extrasperse ?
08:10:24 <quicksilver> extraandintersperse
08:10:31 <byorgey> disperse?
08:10:36 <roconnor> @type (join .) . (.)
08:10:46 <lambdabot> forall a b a1. (b -> a1 -> a) -> (a1 -> b) -> a1 -> a
08:10:48 <Beelsebob> > let spread x [] = [x]; spread x (y:ys) = x:y:spread x ys in spread 5 [1,1,1,2,3]
08:10:55 <lambdabot>  [5,1,5,1,5,1,5,2,5,3,5]
08:11:02 <Beelsebob> more consise, and easier to understand
08:11:26 <hpaste>  BMeph annotated "Works at home, not at work." with "Added error msg" at http://hpaste.org/4095#a1
08:12:02 <byorgey> BMeph: yes, that's the error I'd expect to see if an import of Control.Monad.Instances was needed
08:12:08 <quicksilver> BMeph: reader monad not in scope
08:12:11 <byorgey> not sure why it would work one place and not the other, though.
08:12:17 <quicksilver> BMeph: import Control.Monad.Reader or Control.Monad.Instances
08:12:29 <quicksilver> in some versions of ghc, Control.Monad exports this. In others it doesn't. I think.
08:12:39 <Beelsebob> note that my implementation doesn't need anything to do with Monads
08:13:29 <BMeph> Beelsebob: If I wanted to be quicjk and pretty, I'd just use intersperse with the points. I'm trying to make it a utility function.
08:13:37 <byorgey> quicksilver: but BMeph said both machines have ghc 6.8.1 installed.
08:13:54 <Beelsebob> BMeph: but... mine was quicker and prettier and had fewer dependancies
08:14:05 <BMeph> let outersperse x list = x:list:[x] in 5 [0..3]
08:14:35 <idnar> > let outersperse x list = x:list:[x] in outersperse 5 [0..3]
08:14:36 <lambdabot>   add an instance declaration for (Num [t])
08:14:48 <osfameron> @type on
08:14:49 <lambdabot> Not in scope: `on'
08:14:53 <Beelsebob> you meant ++ instead of the second :
08:15:07 <idnar> > let outersperse x list = x:list ++ [x] in outersperse 5 [0..3]
08:15:08 <lambdabot>  [5,0,1,2,3,5]
08:15:10 <BMeph> Beelsebob: err, right, thanks. ;)
08:15:19 * vincenz would call that 'bracket'
08:15:31 * Beelsebob thinks he would agree with vincenz there
08:15:40 <vincenz> there's no spersing going on
08:15:56 <conal> [x]++list++[x] looks prettier and would probably be optimized to the same code.
08:16:11 <BMeph> Anyway, that's what I'm doing, I'm just trying to do it w/o specifying the item and the list in the definition.
08:16:11 <Stinger_> let spread x y = [x] ++ (intersperse x y) ++ [x]
08:16:13 <fasta> I would use bracketWith
08:16:15 <Beelsebob> > let bracket x list = x:list ++ [x]; spread x = bracket x . intersperce x in spread 5 [1,2,3]
08:16:15 <lambdabot>   Not in scope: `intersperce'
08:16:25 <Beelsebob> helps if I can spell
08:16:32 <fasta> Or bracket_with ;)
08:16:38 <Beelsebob> indeed
08:16:43 <conal> @ty \ x -> ([x]++).(++[x])
08:16:44 <lambdabot> forall a. a -> [a] -> [a]
08:16:48 <idnar> @pl outersperse x list = x:list ++ [x]
08:16:49 <lambdabot> outersperse = liftM2 (.) (:) (flip (++) . return)
08:16:55 <idnar> BMeph: you mean like that?
08:16:57 <vincenz> > let bracket a comb b = a `comb` b `comb` a in let surround x l = bracket [x] (++) l in surround 5 [1..3]
08:16:58 <lambdabot>  [5,1,2,3,5]
08:17:04 <Beelsebob> why do people think that point free style is nice?
08:17:05 <BMeph> idnar: exactly
08:17:07 <idnar> @pl outersperse x list = [x] ++ list ++ [x]
08:17:07 <lambdabot> outersperse = liftM2 (.) (:) (flip (++) . return)
08:17:12 <Beelsebob> that's horrific
08:17:14 <idnar> heh
08:17:19 <idnar> Beelsebob: well, it's sometimes nicer
08:17:19 <Beelsebob> it was much nicer as the original version
08:17:24 <Beelsebob> idnar: sometimes
08:17:27 <Beelsebob> deff not in this case though
08:17:37 <idnar> in this case, I'd say that @pl's version is definitely awful :P
08:17:47 <conal> or outersperse x = ([x]++) . (++[x])
08:17:52 <osfameron> Beelsebob: I'm with you there.  But the mental exercise of making something points free is quite useful
08:17:57 <vincenz> conal: no!
08:18:08 <conal> vincenz: no?
08:18:11 <Beelsebob> osfameron: true, that's why I tend to do it manually myself if I do it at all
08:18:15 <vincenz> bracket comb a = (a `comb`) . (`comb` a)
08:18:24 <Beelsebob> rather than relying on @pl to magically produce something nice
08:18:27 <conal> vincenz: yes!
08:18:34 <byorgey> vincenz: nice =)
08:18:43 <conal> nice one, vincenz
08:18:45 <byorgey> then outersperse = bracket (++)
08:18:48 <vincenz> yah
08:18:49 <vincenz> well
08:18:57 <vincenz> bracket (++) . return
08:18:57 <vincenz> :)
08:19:03 <byorgey> uh, right =)
08:19:06 <vincenz> where return == (:[])
08:19:09 <Beelsebob> why return?
08:19:15 <Beelsebob> why do we need to do everything in monads
08:19:17 <vincenz> Beelsebob: injection into listmonad
08:19:21 <Beelsebob> can't we have a few pure functions?
08:19:23 <conal> s/return/pure
08:19:25 <vincenz> Beelsebob: cause it's cleaner than the cookiemonster
08:19:27 <Beelsebob> I can inject it myself if I want
08:19:32 * byorgey likes the monkey operator.
08:19:43 <vincenz> outersperse = bracket (++) . (:[])
08:19:53 <Beelsebob> outersperse = bracket (++)
08:20:01 <vincenz> bracket expects a list
08:20:06 <vincenz> intersperse takes a -> [a]
08:20:12 <vincenz> so it'd be nice to have similar for outersperse
08:20:17 <vincenz> you could do
08:20:17 <Beelsebob> ah, okay
08:20:18 <byorgey> really, Data.List out to export a 'singleton' function
08:20:20 <Beelsebob> fair enough
08:20:25 <vincenz> surround = bracket (++)
08:20:32 <vincenz> outersperse = surround . ([])
08:20:37 <vincenz> s/[]/:[]
08:20:42 <fasta> byorgey: singleton = return
08:20:53 <fasta> byorgey: but I agree, though.
08:20:57 <byorgey> fasta: I know that.  read the scrollback. =)
08:21:03 <conal> i'd rather use pure than return here.  monads keep people thinking sequentially.
08:21:11 <Beelsebob> conal: agreed
08:21:20 <Beelsebob> vincenz: my main problem with that is merely that "return" makes you think "this is a monad"
08:21:27 <conal> down with unnecessary monad use!
08:21:28 <Beelsebob> when the concept of this function has nothing at all to do with monads
08:21:39 * Beelsebob agrees *very* strongly with conal 
08:21:41 <vincenz> Beelsebob: well look at 2.0
08:21:45 <conal> :)
08:21:54 <Beelsebob> vincenz: yeh, that's better :)
08:22:23 <vincenz> @pl \a comb -> (a `comb`) . (`comb` a)
08:22:23 <lambdabot> ap (ap . ((.) .) . flip id) (flip flip)
08:22:33 * byorgey is going to start a new user group, Haskell Types Ranting Against Unnecessary Monad Use (HTRAUMA)
08:22:35 * vincenz chuckles
08:22:55 <vincenz> byorgey: and lovingly call it head trauma?
08:23:05 <Beelsebob> byorgey: you'll want my monad tutorial then
08:23:14 <byorgey> vincenz: sure, why not =)
08:23:36 <Beelsebob> it describes monads as "nuclear turds" -- incredably powerful, but boy do they smell bad
08:23:46 <conal> sometimes i think much of what people call "functional programming" is really imperative programming in a functional language.
08:23:53 <Beelsebob> conal: indeed
08:24:18 * byorgey just realized that 'Use' starts with the letter 'U' =P
08:24:35 <idnar> hahahaha
08:24:40 <ToRA> byorgey: Abuse?
08:24:43 <idnar> it took me a little while to figure that one out
08:24:45 <ehird`> it's reccomended to indent haskell code with all spaces, right?
08:24:50 <byorgey> ToRA: excellent!  even better =)
08:24:51 <ehird`> (Instead of emacs-style spaces+tabs)
08:24:55 <vincenz> ehird`: tabs are evil
08:25:05 <vincenz> I think they should uninvent the tab key on keyboards
08:25:10 <Beelsebob> ehird`: all spaces, yes
08:25:16 <Phillemann> Beelsebob: Is this a tutorial for monad beginners? :)
08:25:19 <ehird`> vincenz: i'm not interested in this discussion, i'm interested in what everybody actually uses for haskell projects
08:25:21 <vincenz> or the tab-ascii character
08:25:25 <vincenz> ehird`: yes, spaces
08:25:33 <Beelsebob> Phillemann: it's a tutorial on when you shouldn't use monads even though everyone does
08:25:36 <vincenz> ehird`: the second part was not to you, notice the lack of nick
08:25:47 <ehird`> [16:24:55] <vincenz> ehird`: tabs are evil
08:25:48 <byorgey> Beelsebob: link?
08:25:50 <ehird`> that was to me
08:25:57 <Beelsebob> byorgey: not written yet, I'm working on it
08:26:01 <vincenz> ehird`: oh well, that was to say "tabs in haskell are evil, everyone uses spaces"
08:26:08 <Phillemann> Beelsebob: Ok, could be better to first learn _how_ to use monads and then when not to do it at all.
08:26:09 <Stinger_> hah vinc
08:26:10 <byorgey> Beelsebob: oh, I see. =)
08:26:23 <Beelsebob> Phillemann: that's *exactly* what I'm preaching
08:26:33 <Saizan> Beelsebob: any examples?
08:26:36 <ehird`> vincenz: okay. i'm a tab fan but can 100% understand using spaces in haskell code -- since it relies heavily on 'where are we, cursor-wise'
08:26:36 <Beelsebob> learn what they are, learn what they're good at, then don't use them ever again
08:26:43 <Beelsebob> Saizan: my favourite is parser combinators
08:26:46 <byorgey> Phillemann: well, there are already plenty of tutorials to teach you _how_ to use monads.
08:26:50 <Beelsebob> which have no need at all to be described in monads
08:27:06 <Beelsebob> they're a very pure idea
08:27:06 <Phillemann> byorgey: Yes, I'm currently reading "All about monads" (literally :>).
08:27:13 <Saizan> Beelsebob: just applicative functor?
08:27:15 <conal> i've been working on a style of keeping "interface" (I&O) cleanly separated from pure functionality.  then composing each part separately.  That's what TV is about.
08:27:24 <Beelsebob> Saizan: ?
08:27:45 <Saizan> Beelsebob: how would you structure a parser combinator library?
08:27:49 <ehird`> anyone edit haskell with vim? if so, does anyone know how i can get it to autoindent properly?
08:27:56 <vincenz> ehird`: I do
08:28:01 <Beelsebob> Saizan: well, I quite like CPS for doing them
08:28:07 <vincenz> ehird`: truth be told, I prefer doing it manually
08:28:16 <vincenz> ehird`: block insert et al are easy :)
08:28:23 <Beelsebob> but the point I'm making is that the exposed interface should not tell you that I use CPS at all
08:28:25 <ehird`> vincenz: well, i have better things to do with my time than tap out to align code :-)
08:28:26 <conal> Beelsebob: me too about parser combinators (PCs).  i haven't seen a monadic PC program that would be more elegantly expressed via Applicative.
08:28:38 <klugez> ehird`: http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
08:28:39 <vincenz> ehird`: well I have my tab key auto-align to two spaces
08:28:45 <Saizan> Beelsebob: i'm specifically talking about the interface
08:28:47 <vincenz> without actual tabs
08:28:48 <conal> urg.  i meant "wouldn't"!
08:29:04 <conal> "i haven't seen a monadic PC program that *wouldn't* be more elegantly expressed via Applicative."
08:29:08 <Beelsebob> Saizan: the interface should be merely "pure" functions where pure means non-monadic
08:29:16 <vincenz> ehird`: set the following in your .vimrc : tabstop=2, softtabstop=2,shiftwidth=2,expandtab
08:29:25 <vincenz> or if you want, only in the case of .hs files
08:29:32 <ehird`> vincenz: I know how to set that :P
08:29:39 <vincenz> ok
08:29:42 <vincenz> well those are what I use for haskell
08:29:45 <ehird`> but i dislike indenting anything manually, even if i have a magic button to insert 2 spaces
08:29:45 <Saizan> Beelsebob: ok, so each one accepts the stream of token and returns the rest?
08:30:02 <Beelsebob> Saizan: no, each accepts a stream of tokens and a continuation
08:30:10 <vincenz> ehird`: I admit it's become second nature for me
08:30:35 <dmead> ?src foldr
08:30:36 <lambdabot> foldr k z xs = go xs
08:30:36 <lambdabot>     where go []     = z
08:30:36 <lambdabot>           go (y:ys) = y `k` go ys
08:30:50 <Saizan> Beelsebob: so a type Parser a = [Token] -> (a -> r) -> r ?
08:31:04 <Beelsebob> something like that, yes
08:31:19 * Beelsebob is just trying to dredge up the ones he really liked
08:31:25 <Beelsebob> chris okasaki made some nice ones
08:31:41 <Beelsebob> they had an "interesting" implementation
08:31:50 <Beelsebob> mostly interesting because he found a use for 6th order functions
08:31:52 <Beelsebob> :D
08:32:17 <Beelsebob> vincenz: either that or
08:32:19 <Beelsebob> fail
08:32:24 <Beelsebob> http://www.eecs.usma.edu/webs/people/okasaki/jfp98.ps
08:32:29 <vincenz> Beelsebob: misperson?
08:32:44 <Beelsebob> vincenz: I fail at pressing cmnd-c, but succed at pressing cmnd-v
08:32:45 <Beelsebob> sorry
08:32:50 <vincenz> np :)
08:33:01 <Saizan> Beelsebob: and how do you compose two parsers then?
08:33:38 <geocalc> yes how
08:33:39 <Beelsebob> Saizan: fail, I didn't read your type sig right
08:34:09 <Beelsebob> the continuation should be another parser
08:34:13 <Beelsebob> with which it is composed
08:34:23 <Beelsebob> or whatever the combinator feels like
08:36:01 <Saizan> ok, just to vague to continue this discussion :)
08:36:14 <Beelsebob> indeed
08:36:15 <Beelsebob> sorry
08:36:24 <Beelsebob> take a look at the chris okasaki ones
08:36:34 <Beelsebob> also, I'm trying to dredge up code I had for a really simple library
08:36:40 <Beelsebob> but I'm struggling to find them
08:36:43 <Saizan> however i think that some common pattern will arise, and then you'd end up reiventing a monad or some other similar thing
08:37:21 <geocalc> it seems
08:37:56 <Beelsebob> Saizan: it's plausable that I will reinvent a monad -- but that doesn't mean that it should be called a monad and pointed out
08:38:10 <Beelsebob> because it being a monad adds nothing to the understanding of the parser combinators
08:38:21 <Saizan> Beelsebob: if you call it a monad you can reuse general combinators
08:38:47 <Beelsebob> I could -- but I'd add a layer of generality that meant that my code became completely non-understandable
08:38:49 <fasta> They could have named it ThingieSatisfyingThingieRules
08:39:00 <fasta> That would probably be less clear.
08:39:06 <Beelsebob> my argument against monads is often that they are *too* general
08:39:09 <fasta> Since there are other Thingies :)
08:39:09 <Beelsebob> and make code less clear
08:39:17 <Saizan> ThingieForAbstractingRepetitivePatterns seems the best descriptive name :)
08:39:42 <conal> Beelsebob: i think we have different reasons for objecting to monads.  For instance I often want Applicative, because it is *more* general.
08:39:58 <Beelsebob> Saizan: except that they abstract *all* repetative patterns into the same box, and remove all insight into what the repetitive pattern is
08:40:04 <Beelsebob> conal: agreed
08:40:05 <fasta> Arrows could be named AnotherLessUsedThingie
08:40:14 <Saizan> Beelsebob: just look at the type and you know
08:40:39 <mux> WarmFuzzieThingie
08:40:39 <Beelsebob> Saizan: If I say I've invented a data type called "Jam", it's a monad
08:40:43 <Beelsebob> what can you tell me about it?
08:40:57 <Beelsebob> other than it conforms to some arbitrary (although mathamatically nice) rules
08:41:14 <conal> I'd still go with (:[]) over return or pure in the bracket example above, however.  Because return/pure does not make bracket more general.
08:41:24 <conal> So it's not a useful generalization.
08:41:25 <Saizan> that you can compose Jams in some meaningful way
08:42:01 <conal> Sometimes using the more general forms in a def results in a more general def.  Big win!
08:42:02 <Beelsebob> Saizan: and you would have no clue about how Jams might be put together
08:42:21 <Beelsebob> on the other hand I could ignore the fact that they're monads and say "I have Jams, they can be put together with toasts like this"
08:42:26 <conal> Then I'd say that the details of parser combinators (or whatever) are the distraction.
08:42:53 <quicksilver> conal: I also dislike using return when you definitely mean list
08:43:01 <quicksilver> I prefer (:[]) or even (\x->[x])
08:43:13 <Saizan> Beelsebob: ok, but i can come and say, they are also monads, so i have this prepackaged machines that does some useful things with them
08:43:41 <conal> quicksilver: it's tricky though.  if i apply that choice too early, then sometimes i won't notice that my function is way more general than lists.
08:43:43 <Beelsebob> Saizan: and I say "why use those machines, when you could use these more descriptive machines with bigger signs on them saying what they do"
08:44:00 <Saizan> Beelsebob: because i don't want to rewrite them :)
08:44:16 <Beelsebob> Saizan: but you don't have to -- I do
08:44:26 <Beelsebob> I just provide the machinery
08:44:30 <Saizan> Beelsebob: and also, i can stack a StateT on jour Jam and have a stateful Jam
08:44:47 <Beelsebob> hehe, I might have intentionally disabled the ability to do that
08:44:49 <Beelsebob> :P
08:44:55 * Beelsebob runs with that bombshell
08:45:02 <Saizan> i'm the user, not you :)
08:46:12 <dons> ?users
08:46:12 <lambdabot> Maximum users seen in #haskell: 415, currently: 386 (93.0%), active: 18 (4.7%)
08:46:14 <Saizan> the point is better composability, as always
08:46:27 <byorgey> someone should start a Haskell-themed rock group named "StateT Jam"
08:47:06 <conal> Haskell == State    :(
08:47:17 <Beelsebob> hehe
08:47:26 <Beelsebob> conal: that was the bombshell I was trying to run away with
08:48:50 <Saizan> well, StateT is just a common example, oyu can't always write everything as a stream processor :)
08:49:08 <Beelsebob> I can and I will... *stomps foot* and really leaves
08:50:08 <Saizan> well then i'd be very interested to read your code
08:50:33 <osfameron> ooo, call for copy for Monad Reader...
08:52:15 <Beelsebob> Saizan: of note, all the debugging views I've written for Hat are entirely stream processers
08:52:26 <vincenz> conal: you mean outersperse
08:52:29 <byorgey> osfameron: you should write something!
08:52:31 <vincenz> bracket is -very- general
08:52:31 <Saizan> btw, i think continuations are more imperative than monads
08:52:38 <vincenz> bracket :: (a -> a -> a) -> a -> a -> a
08:53:01 <conal> vincenz: yes.  i meant the list-specific one.
08:53:04 <vincenz> ah :)
08:53:15 <vincenz> You know, if we keep generalizing like this
08:53:21 <osfameron> byorgey: yeah - I think I might work towards that soon...
08:53:34 <vincenz> I bet we'll find the one -true- typeclass with -one- method that covers ALL of haskell, just need the proper types :)
08:54:11 <byorgey> class Stuff where doStuff: ((a -> (b -> c)) -> d) -> (e -> e) -> ((((f -> [h] -> i) ...
08:54:16 <vincenz> e.g.
08:54:19 <Beelsebob> isn't that what S K and I are for?
08:54:23 <vincenz> a `op` b :: Sum Int = a + b
08:54:34 <fasta> vincenz: there exist some machine with only one instruction, so that should work.
08:54:35 <vincenz> a `op` b :: Mul Int = a * b
08:54:39 <fasta> exists*
08:54:42 <ehird`> fasta: OISCs are fun
08:54:54 <fasta> ehird`: ?
08:55:03 <ehird`> fasta: one instruction set computer
08:55:10 <fasta> ehird`: ok
08:55:14 <vincenz> all computers are OISC :)
08:55:21 <vincenz> I doubt they have multiple instruction sets :)
08:55:21 <fasta> Heh
08:55:49 <fasta> They do call it like that.
08:55:52 <fasta> What a stupid name.
08:55:58 <fasta> http://en.wikipedia.org/wiki/OISC
08:55:59 <lambdabot> Title: One instruction set computer - Wikipedia, the free encyclopedia
08:56:00 <vincenz> o.O
08:56:05 <Saizan> ((one instruction) set) computer
08:56:05 <vincenz> thtey should call it singleton-set computer
08:56:23 <ehird`> shush you, it's an esoteric idea for fun
08:56:24 <ehird`> :P
08:56:25 <vincenz> Saizan: just call it 'single instruction computer'
08:56:28 <vincenz> SIC
08:57:58 <fasta> At least the design isn't bloated ;)
08:58:15 <fasta> They should implement Scheme in it :)
08:58:36 <ehird`> you aim low
08:58:38 <ehird`> Port ghc!!!
08:58:47 <ehird`> well, just write a C-- backend for it
08:58:50 <ehird`> which is equivilent
08:59:01 <vincenz> nah, brainfuck
08:59:14 <ehird`> brainfuck gets far too much attention as far as esolangs go
08:59:24 <puusorsa> lolcode <3
08:59:51 <vincenz> ehird`: whitespace then
09:00:26 <Saizan> well, write a C-- -> lolcode -> brainfuck -> whitespace -> OISC pipeline
09:00:37 <ehird`> puusorsa: you are everything wrong with the esolang community, just fyi
09:00:41 <vincenz> brainfuck -> whitespace is too easy
09:00:54 <ehird`> now, Underload or Glass? Yes.
09:01:25 <Saizan> C-- -> whitespace -> lolcode -> brainfuck -> lisp -> OISC ?
09:02:45 <ehird`> C-- -> Scheme -> Glass -> Underload -> OISC
09:02:51 <ehird`> C-- -> Scheme is ofc a  huge shift
09:02:56 <ehird`> and Glass -> Underload too
09:02:59 <ehird`> they might both be stack based
09:03:05 <puusorsa> ehird`, im not part of that community
09:03:09 <ehird`> but that won't help, because glass is OO and Underload has no facility for that
09:03:11 <ehird`> puusorsa: exactly!
09:03:20 <puusorsa> and if a i was my favorite is threaded intercal :)
09:03:26 <puusorsa> please ... come from
09:03:28 <puusorsa> <3
09:03:47 <vincenz> ant assembler :)
09:10:57 <dons> so how are we going to take over the world today, guys?
09:11:06 <Zao> Lazily.
09:11:22 <dons> we can do it eagerly too, though!
09:11:31 <dons> take !world
09:11:32 <jedbrown> Nice article dons.
09:11:45 <dons> cheers jedbrown. its fun to muscle-up sometimes
09:12:23 <dons> i think in fairness, markcc didn't mean to conflate distribution and multicore concurrency, but there were still other problems that needed addressing in his article
09:13:14 <jedbrown> Actually, the distributed part is pretty important to me, not in terms of reliability, but in terms of scalability.
09:13:36 <pitecus> Is there some way to specify in .cabal that header files should be looked for in $HOME/include?
09:13:59 <dons> right, the way to do that in haskell is to run a bunch of identical nodes, communicating via Data.Binary +tcp, but you're basically reimplementing erlang's lib support for the very same
09:14:08 <jedbrown> But erlang is so ugly...
09:14:22 <jedbrown> I'm working on MPI-based distribution.
09:15:34 <RayNbow> dons, did you read my comment on IRC about sieve?
09:15:35 <dons> looks like there's some potential for more concurrency and parallel articles
09:15:39 <dons> RayNbow: sure. :)
09:15:48 <dons> i took that sieve from the sieve suite
09:16:03 <dons> so feel free to use a better sieve if you like (not the goal of the article)
09:16:56 <RayNbow> I had to use a better sieve for a Project Euler problem :p
09:17:41 <dons> i took it from here http://www.cse.unsw.edu.au/~dons/code/nobench/spectral/primes/
09:17:42 <lambdabot> Title: Index of /~dons/code/nobench/spectral/primes
09:17:45 <dons> there's a set of them
09:18:05 <ddarius> @seen osfameron
09:18:05 <lambdabot> osfameron is in #haskell. I last heard osfameron speak 24m 44s ago.
09:18:19 <pitecus> There is something called include-dirs but I assume it wont understand the $HOME/include stuff
09:19:08 <yrlnry> I wish that the result of [1..] had a more general type than [Integer].  I can  let s = 0 : zipWith (+) (cycle [1]) s in s    and get what I want; it has type (Num a) => [a].  Why doesn't [0..]  do this automatically?
09:19:23 <sjanssen> pitecus: IIRC, that should be handled with a buildinfo file
09:19:57 <sjanssen> yrlnry: [1..] :: (Num a, Enum a) => [a]
09:20:03 <pitecus> sjanssen, buildinfo file? never heard of that? Is it something you create manually?
09:20:17 <yrlnry> I guess my problem was somewhere else.  Thanks.
09:20:18 <sjanssen> yrlnry: which defaults to Integer
09:21:24 <yrlnry> Okay, .I have a file that defines iota = [1..]  and then uses iota in a number of different contexts.  When I :t iota, it says iota :: [Double].  why doesn't it report the most general possible type?
09:21:31 <integral> monomorphism restriction
09:21:38 <yrlnry> Oh, right.
09:21:41 <yrlnry> Grr.
09:21:58 <integral> that's a CAF, and it'll just bloat up terribly anyway
09:22:00 <sjanssen> pitecus: http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#system-dependent
09:22:07 <yrlnry> CAF?
09:22:09 <lambdabot> Title: 2. Creating a package, http://tinyurl.com/yv8xjt
09:22:13 <integral> constant-applicative form
09:22:25 <integral> lose the misplaced hyphen
09:22:47 <pitecus> thanks
09:24:39 <yrlnry> Thanks.
09:28:11 <phlpp> :t (<<=)
09:28:15 <lambdabot> Not in scope: `<<='
09:28:23 <phlpp> :t (=<<)
09:28:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:28:26 <phlpp> :>
09:28:28 <ddarius> @tell osfameron For your parseInt function you say you are using the Maybe monad, well if you take this stance further you would rewrite parseInt into parseInt s | all isDigit s = return (read s) | otherwise = mzero, but then it's type becomes parseInt :: MonadPlus m => String -> m Int.  This technique is called NotJustMaybe and is exactly what Map.lookup is doing.  The monad that lookup will use is whatever the surrounding context requires (i.e. whicheve
09:28:28 <lambdabot> Consider it noted.
09:28:28 <ddarius> r the user wants).  This means it will return Nothing on failure when used with Maybe, throw an error if used with IO, return the empty list for [], etc.
09:28:31 <ddarius> Shite.
09:28:53 <ddarius> @tell osfameron (i.e. whichever the user wants).  This means it will return Nothing on failure when used with Maybe, throw an error if used with IO, return the empty list for [], etc.
09:28:54 <lambdabot> Consider it noted.
09:29:13 <pitecus> OK it worked with .buildinfo file. What do people normally do to create that file on without relying on the OS being Unix?
09:30:05 <MyCatVerbs> pitecus: making the OS pretend it's Unix, often with Cygwin or MinGW/MSYS or Interix or some other POSIX compatibility layer. ;)
09:30:12 * MyCatVerbs hides in the corner again.
09:31:09 <osfameron> ddarius: ta
09:31:09 <lambdabot> osfameron: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:31:25 <sjanssen> pitecus: I've only seen autoconf scripts used for this purpose (which sucks for portability, as you note)
09:31:49 <pitecus> so there is no good solution :-(
09:32:17 <sjanssen> how do you determine the location of these header files?
09:33:40 <pitecus> sjanssen, I just want the compiler to look in the user's account in addition to whatever the standard location is on each OS
09:33:51 <pitecus> so on Unix in $HOME/include
09:34:13 <sjanssen> hmm
09:34:25 <sjanssen> aren't there environment variables that govern the include path?
09:35:31 <pitecus> sjanssen, could be
09:36:15 <sjanssen> it doesn't seem right to include the $HOME/include hack in the build system at all
09:36:58 <pitecus> sjanssen, you re probably right
09:37:06 <pitecus> so what would be the right thing
09:37:11 <fasta> Is there some list like type implementation that is not lazy, but an order of magnitude faster that can store Ints?
09:37:29 <vincenz> fasta: sounds like you want something like bytestring for Ints
09:37:43 <vincenz> chunked lists
09:37:45 <int-e> or UArrays
09:37:53 <pitecus> I mean now the compiler only seems to look in /usr/include or smth
09:37:56 <int-e> hmm. wait. 'not lazy'
09:38:08 <sjanssen> fasta: maybe StorableVector?
09:38:08 <int-e> fasta: which part do you want to be strict?
09:38:19 <fasta> int-e: the not lazy part is only because I expect that to be faster.
09:38:33 <fasta> sjanssen: does that also work outside IO?
09:38:33 <vincenz> fasta: cached-sized chunks ala bytestring would be great :)
09:38:37 <sjanssen> fasta: yes
09:38:43 <vincenz> fasta: prolly really easy to do
09:38:54 <vincenz> just rip bytestring and replace char by Int :)
09:40:09 <fasta> sjanssen: have you tested it against [] to see that it is faster for the application I describe?
09:40:26 <sjanssen> fasta: no, it hasn't been tested for performance at all
09:40:35 <dottedmag> Are there Debian packages for ghc 6.8.1? haskell-unsafe.alioth.d.o still has 6.6, and just recompiling 6.8 with 6.6 diff.gz fails.
09:40:47 <Saizan> ?index StorableVector
09:40:48 <lambdabot> bzzt
09:41:02 <fasta> @go StorableVector
09:41:04 <lambdabot> http://code.haskell.org/~sjanssen/storablevector/
09:41:04 <lambdabot> Title: Index of /~sjanssen/storablevector
09:41:11 * int-e is missing something, what *is* the application?
09:42:02 <sjanssen> fasta: it should have performance similar to ByteString, it is based on a version of that library from about 1.5 years ago
09:43:29 <Saizan> funny, we mentioned generalizing ByteString to Storable a => a just some hours ago
09:44:09 <sclv> what would you use it for?
09:44:17 <shapr> Everything!
09:44:34 <thetallguy> osfameron raises a goo point in his blog.
09:44:41 <sclv> Ok, yeah, I mean what occasions why fasta is looking for it in particular?
09:44:48 <ddarius> shapr would write an Io interpreter with it (not that Io the other one)
09:44:57 <shapr> Right, the scary Io.
09:45:10 <thetallguy> aboout Map.lookup and "but which monad is it in, and more to the point, why?"
09:45:10 <ddarius> @google Jot and Io
09:45:12 <lambdabot> http://www.esolangs.org/wiki/Jot
09:45:12 <lambdabot> Title: Jot - Esolang
09:45:13 <Saizan> thetallguy: which?
09:45:22 <shapr> In that case, performIo would always be unsafe
09:45:26 <thetallguy> That's pretty confusing first time you run into it.
09:45:35 <ddarius> thetallguy: Look at what I told him a few pages up in this channel.
09:45:46 * shapr throws a bookmark at ddarius
09:45:56 <shapr> Man, I want AmeroHaskell.
09:45:59 <thetallguy> If you run lookup in ghci, it will invoke the IO monad fail
09:46:08 <osfameron> thetallguy: yeah, I've had clarification from a few places (inc ddarius just now)
09:46:18 <ddarius> shapr: Go rabblerouse on haskell-cafe or something.
09:46:22 <thetallguy> ddarius: I ran into this a while back and sorted it out as well.
09:46:27 <shapr> Good idea
09:46:27 <osfameron> but I really didn't get it while looking at it on my own (I suppose I should have read the documentation or something...)
09:46:28 <fasta> sjanssen: it doesn't seem to have O(1) cons.
09:46:32 <vincenz> sjanssen: neat lib :)
09:46:44 <sjanssen> fasta: you didn't ask for that
09:46:49 <thetallguy> osfameron: I think the next thing to do is get that explanation into the Data.Map docs
09:46:55 <fasta> sjanssen: "list-like"
09:47:00 <thetallguy> a little example would save people a lot of time.
09:47:06 <ddarius> thetallguy: It's a Haskell idiom, it should not be in the Data.Map docs.
09:47:16 <sjanssen> fasta: that is very general
09:47:24 <fasta> sjanssen: It can be amortised O(1).
09:47:29 <thetallguy> ddarius: I disagree.  Examles are good
09:47:35 <osfameron> ddarius: where should-it-be/is-it described ?
09:47:44 <ddarius> On the old wiki (in the golden days), there was a page titled "Common Haskell Idioms" that had all sorts of this stuff but it was never migrated.
09:47:48 <thetallguy> ddarius: a simple example usage and a link would be very useful.
09:48:00 <ddarius> thetallguy: Examples are fine, but explaining the NotJustMaybe idiom there is inappropriate.
09:48:33 <thetallguy> ddarius:  That's an oxymoron.  The example would explain... ;-)
09:48:37 <fasta> Examples are a bad excuse for properly defined semantics.
09:48:45 <resiak> ah, so is using return and fail now considered harmful in favour of return and mzero?
09:48:47 <thetallguy> ;alskdjf;alsidfj;aslfdkj
09:48:47 <fasta> for not having*
09:48:56 <faxathisia> :t fail
09:48:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:49:01 <faxathisia> :t mzero
09:49:01 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
09:49:05 <fasta> resiak: some do, I don't.
09:49:08 <thetallguy> fasta:  giving only examples is bad.
09:49:08 <resiak> :t Map.lookup
09:49:10 <lambdabot> Couldn't find qualified module.
09:49:15 <resiak> :t Data.Map.lookup
09:49:16 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
09:49:18 <thetallguy> fasta: giving no examples is also bad.
09:49:22 <Saizan> the doc do tells that it will call fail when the object is not found, no?
09:49:22 <ddarius> fail was always considered harmful
09:49:26 <resiak> yeah
09:49:26 <fasta> thetallguy: what library could use examples?
09:49:33 <faxathisia> http://haskell.org/wikisnapshot/NotJustMaybe.html
09:49:34 <thetallguy> fasta: all of them.
09:49:35 <faxathisia> it uses fail there :/
09:49:41 <resiak> so all the standard examples of the NotJustMaybe idiom are actually broken :D
09:49:43 <fasta> thetallguy: I disagree.
09:49:46 <thetallguy> fasta: first rule of technical writing.
09:50:06 <ddarius> A wonderful treasure lost: http://web.archive.org/web/20061011032657/http://www.haskell.org/hawiki/CommonHaskellIdioms
09:50:07 <fasta> thetallguy: first rule of Haskell docs: not being chatty.
09:50:07 <lambdabot> http://tinyurl.com/3e4c8s
09:50:39 <thetallguy> fasta: I strongly disagree.  Chatty is different from clarity.
09:50:44 <ddarius> resiak: I'd prefer that they used mzero rather than fail so that the type would explicitly make it clear that failure was an option.
09:50:53 <resiak> ddarius: sure
09:51:16 <ddarius> resiak: It'd also be nice to split MonadPlus into MonadZero/MonadPlus to more finely specify what is possible (and not)
09:51:39 <fasta> ddarius: did you already movehttp://web.archive.org/web/20061011013338/www.haskell.org/hawiki/SimulatingDependentTypes?
09:51:45 <resiak> it'd be nice if there were some function f :: String -> m b for which f == const mzero in MonadPlus and f == fail in other Monads
09:52:11 <resiak> ddarius: does anyone not think that removing fail from Monad is a good idea?
09:52:22 <ddarius> fasta: I don't think I really moved much of anything.  I didn't have Internet access during most of the transition.
09:52:40 <fasta> ddarius: since I guess it's your article, you could still move it.
09:52:44 <ddarius> resiak: Well it was put there for a reason...
09:52:54 <ddarius> fasta: Sure, but I'm not sure where to put it.
09:52:56 <resiak> ddarius: pattern match failure, right?
09:53:02 <ddarius> resiak: Yes.
09:53:13 <sjanssen> resiak: well, there are some weird cases with that
09:53:16 <ddarius> fasta: A new "Common Idioms" like thing needs to be made.
09:53:46 <resiak> i can't helping that there must be some solution allowing pattern matching in do notation which doesn't involve randomly adding failure to everything
09:53:48 <Saizan> The function will return the result in the monad or fail in it the key isn't in the map. Often, the monad to use is Maybe, so you get either (Just result) or Nothing. <-- i don't think there's any ambiguity here..
09:54:11 <sjanssen> for example, these would have different types: do x <- m; return (fst x) and do (x, _) <- m; return x
09:54:12 <Saizan> besides a missing "if"
09:54:49 <resiak> sjanssen: is that so bad?
09:55:14 <sjanssen> resiak: yes and no.  I bet it will be quite surprising the first time you encounter it
09:55:20 <faxathisia> @src uncurry
09:55:22 <ddarius> sjanssen: In the general case, it seems appropriate.
09:55:32 <vincenz> sjanssen: what is the difference?
09:55:40 <ddarius> In that particular case, it would be annoying.
09:55:46 <vincenz> oh in caase you go for explicit failure monads?
09:55:54 <sjanssen> vincenz: pattern matching in in the LHS of monadic <-
09:55:58 <int-e> resiak: you couldn't write  [a] <- getArgs  anymore.
09:55:59 * vincenz nods
09:56:01 <resiak> sjanssen: there are lots of things in Haskell that surprise me the first time I see them :-)
09:56:02 <sjanssen> ddarius: yes, it was a bad example
09:56:06 <vincenz> sjanssen: you mean if fail was moved out?
09:56:13 <vincenz> ..of monad
09:56:13 <sjanssen> vincenz: yes
09:56:18 <resiak> int-e: sure you could, because IO has fail
09:56:34 <ddarius> int-e: Sure you could.  IO can still be MonadPlus/MonadZero.
09:56:34 <vincenz> which is actually rather silly as tuples have only one data-constructor
09:56:36 <resiak> s/fail/a sensible-ish meaning for fail/
09:56:39 <vincenz> It should be able to infer it can't go wrong there
09:56:39 <int-e> resiak: well if you got rid of fail.
09:56:57 <resiak> int-e: IO could be .. what ddarius said.
09:57:52 <sjanssen> vincenz: yeah, we might consider defining non-failing pattern matches, including ~ patterns, newtypes, single constructor data, etc.
09:58:01 <int-e> ddarius: hmm. yuck? IO will never satisfy  foo >> mzero == mzero
09:58:22 <int-e> mm. ok, that's not really a requirement.
09:58:22 <ddarius> int-e: Not in general, no.
09:58:45 <vincenz> sjanssen: of course I made a slight assumption, namely that tuples are strict.  Otherwise there's still a slight difference in the case of undefined
09:58:47 <crazy_coder> j #c++
09:59:20 <ddarius> I agree with Cale that ther should be MonadPlus and MonadOrElse classes for the two different types of things mplus is used for.
09:59:20 <sjanssen> int-e: eh, that law is at least halfway true.  Any exceptional IO action is mzero-ish
09:59:23 <Saizan> vincenz: uh? which difference?
09:59:29 <fasta> Uh, ok, I now understand why people hate wikis.
09:59:34 <vincenz> do (x, _) <-m; don't use x
09:59:42 <vincenz> do x <- m; don't use (fst x)
09:59:51 <vincenz> for _|_ those are different
09:59:57 <fasta> I wrote something about using Data.Sequence vs lists for the same purpose, with the same algorithmic complexitiy.
10:00:03 <int-e> oh well. there's only one place where I'm really unhappy about fail, and that is the MonadError class which spoils the monad instance for Either.
10:00:23 <vincenz> unless you assume all binds are lazy paterns
10:00:23 <doserj> vincenz: that is not really surprising, is it?
10:00:28 <vincenz> doserj: no it is not
10:00:28 <ddarius> int-e: That's arguably MonadErrors fault.
10:00:29 <fasta> But then someone just deleted that, because he misinterpreted it.
10:00:31 <pheaver> lois
10:00:37 <vincenz> doserj: but you should read the previous context :)
10:00:38 <pheaver> oops, sorry
10:00:47 <Saizan> vincenz: right
10:00:47 <fasta> I wish I could mark people that are free to modify my stuff.
10:00:59 <fasta> I.e. people of which I think they have a clue.
10:01:08 <vincenz> sjanssen: is there anything that would work against for instance having all binds be implicitly lazy patterns?
10:01:43 <sjanssen> vincenz: that could work, but we'd lose the useful pattern match failure behavior
10:02:01 <vincenz> good point
10:02:05 <vincenz> failure would only happen at use time
10:02:09 <fasta> Wow, the UI for reverting changes could not possibly have been made worse.
10:02:24 <fasta> I cannot select a column...
10:02:26 <sjanssen> vincenz: actually, I don't think this has any issue with lazy bind
10:02:40 <doserj> sjanssen: it is not always clear, it seems, whether the "useful" pattern match failure behavior should be fail, or mzero
10:02:45 <fasta> Do they expect everyone runs Emacs in the browser?
10:02:46 <vincenz> sjanssen: the problem is that otherwise tuples would still have to be in the FailureMonad
10:03:10 <vincenz> sjanssen: do (x, _) <- m; don't use x  .. vs .. do x <- m; don't use (fst x)
10:03:36 <ddarius> doserj: This is why fail is still there.
10:03:53 <doserj> I like fail
10:04:01 <doserj> it is only in the wrong class :)
10:04:04 <sjanssen> vincenz: the current desugaring for (x, _) <- m is m >>= \m' -> case m' of (x, _) -> ...; _ -> fail "blah"
10:04:18 <sjanssen> vincenz: I propose m >>= \m' -> case m' of (x, _) -> ...
10:04:29 <ddarius> doserj: Moving it to a different class (while it would be nicer) wouldn't really resolve the issues discussed here.
10:04:56 <sjanssen> doserj: I think it is clear that fail is more useful for many Monads, like IO
10:05:14 <sjanssen> doserj: IO can give you the source file and line number for a pattern match failure
10:05:31 <sjanssen> doserj: mzero can't
10:05:44 <vincenz> sjanssen: ah right :)
10:06:36 <doserj> fail can produce runtime errors, mzero can't :)
10:06:59 <sclv> @bot
10:07:11 <sjanssen> doserj: instance MonadZero State where mzero = error "really?"
10:07:44 <sjanssen> doserj: btw, I'm considering this in the context of moving fail out of Monad
10:07:49 <doserj> that doesn't fullfill the monadplus laws
10:08:04 <doserj> (but maybe the monadzero laws, whatever they are)
10:09:12 <sjanssen> personally, I'd split MonadPlus into MonadZero and MonadPlus, move fail to MonadZero, and slightly relax the laws for MonadZero
10:11:11 <doserj> sjanssen: that would definitely be nicer than the current situation, from my POV
10:11:32 <doserj> (also, move (>>) to Applicative :)
10:11:48 <sjanssen> meh
10:12:11 <sjanssen> that's orthogonal
10:12:15 <doserj> yep
10:12:49 <sjanssen> though if Haskell' were to consider this fail change, it would be the right time to consider other backwards-incompatible changes like that
10:13:22 <doserj> yes. If do-blocks can have different types, then why not Applicative
10:14:05 <doserj> (and move return to MonadIO :)
10:14:14 <Saizan> heh?
10:14:15 <fasta> In what ways can functional code using lists be optimized without making it mutable if the right algorithm already is being used?
10:14:19 <Saizan> return to MonadIO?
10:14:51 <doserj> pure is a much better name for what return in a general monad does.
10:16:18 <conal> doserj: rather than (>>), i like liftA2 mappend
10:17:04 <conal> i almost never use (>>).  too often my bug turned out to be that i've neglected to use the value from the LHS of the >>
10:17:41 <pitecus> I was trying to run that code from http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/26#no-headaches and it's weird, it runs in 9 sec with -N1 and in 0.06 sec with -N2
10:17:51 <pitecus> Shouldn't it be at most twice as fast???
10:18:00 <conal> the neat thing about liftA2 mappend is that it's the same as (>>) when both args are unit-valued, and otherwise it combines monoidally, which has been really useful for me.
10:18:45 <Saizan> conal: they must have the same type though
10:18:54 <conal> Saizan: yep
10:18:56 <fasta> pitecus: some cache effect.
10:18:58 <EvilTerran> @instances Monoid
10:19:13 <fasta> pitecus: or not -threaded or whatever
10:19:14 <EvilTerran> @bot ?
10:19:18 <doserj> Saizan: I think conal sees that as an advantage
10:19:20 <pitecus> quite some effect
10:19:28 * EvilTerran was thinking () could be a Monoid instance
10:19:31 <conal> doserj: zakly
10:19:40 <conal> EvilTerran: it is!
10:19:54 <EvilTerran> i tried to check...
10:20:09 <conal> another nifty one is a->b for monoid b
10:20:49 <conal> another nice monoid: Event a
10:21:17 * pitecus is tempted to convert some real code to concurrent
10:22:05 <conal> these monoids make the DataDriven lib super simple and general.
10:22:09 <conal> @wiki DataDriven
10:22:29 <fasta> lambdabot is dead.
10:22:38 <conal> http://haskell.org/haskellwiki/DataDriven
10:22:41 <conal> fasta: thanks
10:23:18 <fasta> conal: did you, like, make anything with it?
10:23:43 <conal> fasta: Phooey, TV, and Eros.
10:24:11 <conal> The heart is this def: type SourceG change m = ((,) change) `O` m
10:24:29 <conal> for arbitrary Monoid change and Applicative m
10:24:44 <fasta> conal: where's the source for Eros?
10:24:50 <fasta> conal: it's not on the wiki.
10:25:02 <conal> @wiki Eros
10:25:07 <conal> oh yeah.
10:25:27 <sciolizer> http://www.haskell.org/haskellwiki/Eros
10:25:55 <fasta> conal: ?
10:26:03 <conal> fasta: see the Eros distribution link on that page, and go up.
10:26:30 <conal> i haven't announced & officially released.  i've been waiting for some haddock.ghc & ghc-6.8 issues to get ironed out.
10:26:32 <fasta> conal: and how should someone know that?
10:26:36 <dmead> > ping
10:26:37 <fasta> conal: ok
10:26:44 <dmead> ?src
10:26:54 <dmead> ?src nub
10:26:56 <dmead> sigh
10:26:57 <doserj> fasta: the URL somehow gives it away :)
10:27:34 <fasta> doserj: If I go to microsoft.com to some distr page and go up one level, I don't get the source code.
10:27:38 <conal> does anyone know whether hackage is yet using haddock.get
10:27:52 <conal> ... using haddock.ghc yet?
10:28:57 <ehird`> where's the vim haskell indentation again?
10:28:58 <doserj> fasta: http://*darcs*.haskell.org/..../*dist*/ matches some pattern for me
10:29:34 <faxathisia> leaves (Tree left right) = leaves left ++ leaves right  vs  leaves' (Tree left right) = leaves' left . leaves' right
10:29:44 <sciolizer> Not sure if this is taboo or not, but that lambdabot_ is my local build.
10:29:52 <faxathisia> It says that using leaves' is more efficient
10:30:35 <faxathisia> why is that? I expect the answer is ++ must copy the entire left leaves.. but must it?
10:31:45 <vincenz> in general using differential lists is somewhat more efficient
10:31:51 <Saizan> faxathisia: it's because in the first case you get deeply nested (++)s and so the complexity becomes quadractic
10:32:08 <conal> except that dlist loses sharing
10:32:27 <faxathisia> @src (++)
10:32:27 <lambdabot_> (++) []     ys = ys
10:32:27 <lambdabot_> (++) (x:xs) ys = x : xs ++ ys
10:32:53 <conal> the usual penalty for using functions in functional programming ;)
10:32:56 <ehird`> :|
10:33:01 <faxathisia> ok yeah, I guess there are more conses no matter what
10:33:08 <vincenz> conal: so does the ++ solution?
10:33:15 <vincenz> conal: and what sharing in this case?
10:33:39 <Saizan> faxathisia: in a simpler context, a ++ (b ++ c) is more efficient than (a ++ b) ++ c
10:34:20 <faxathisia> Can't there be some way to make them both just as efficient..
10:34:31 <conal> vincenz: let zs = list_of_expensive_elements in zs ++ zs
10:35:03 <ehird`> anyone?
10:35:05 <Saizan> faxathisia: no because you've to traverse the first list to append the second to it
10:35:06 <conal> vincenz: let zs = nPrimes 100  in zs ++ zs
10:35:22 <vincenz> conal: oh right, I was referring to this case :)
10:35:31 <vincenz> conal: when generating a full list from the single element up
10:35:33 <resiak> Saizan: couldn't the compiler transform the latter into the former if it knows that ++ is associative and strict in its left argument?
10:36:01 <sclv> @bot
10:36:01 <lambdabot_> :)
10:36:16 * vincenz should've been more specific
10:36:24 <conal> with that caveat, dlists are awesome.
10:38:22 <Saizan> resiak: well i think it could sometimes, but i suppose it's not always so obvious, for example in the writer monad with monoid [a], the (++)s are not used next to each other
10:38:23 <conal> i'm with resiak.  write elegantly and ask the compiler to do the small, simple tweaks
10:38:41 <resiak> Saizan: that's a good point
10:40:12 * vincenz should've been more specific
10:40:20 <conal> just to plug Applicative again, ((,) o) is the Applicative Writer for monoids o.  And one doesn't need a transformer version.  Just use composition (O).
10:40:46 <conal> That's half of what's going on in DataDriven.
10:42:23 <conal> 2/3
10:42:50 <conal> 1/1
10:43:00 <doserj> I find (change, m a) much easier to read than ((,) change) `O` m :)
10:43:54 <conal> doserj: me too.  the other way automatically provides the Applicative instance.
10:44:31 <conal> If Haskell instance selection used higher-order matching, then `O` version could be inferred automatically.
10:44:39 <Saizan> Applicative a,Applicative b => Applicative (O a b)?
10:44:54 <conal> Saizan: yes!
10:45:12 <conal> that's why all of the monad transformer stuff can be discarded for Applicative.
10:45:14 <doserj> conal: We probably have to wait for Haskell''' for that, though...
10:45:16 <Saizan> nice property
10:45:23 <conal> doserj: prby
10:45:31 <conal> probably.  (emacs abbrev)
10:45:53 <conal> and for full higher-order logic programming in the type system.  we're so close.
10:46:21 <conal> universals, implication, backtracking into context constraints
10:46:45 <conal> then we could handle a lot of nice instances that now are flagged as overlapping.
10:47:13 <Saizan> but it becomes undecidable, right?
10:47:26 * esap would like to have types without 'undefined' values.
10:47:33 <conal> Saizan: semi-decidable and practical.
10:47:52 <conal> which is already true of Haskell typing
10:48:36 <doserj> esap: http://pll.cpsc.ucalgary.ca/charity1/www/home.html
10:48:36 <conal> for instance, composing contravariant functors gives a functor.  but so does composing two functors.  ghc will allow either instance but not both.
10:48:36 <lambdabot_> Title: CHARITY - Home Page
10:49:00 <esap> doserj: I've seen charity.
10:49:05 <conal> similarly, composing a cofunctor & a functor vs a functor & a cofunctor.  both give cofunctors, but only one may be declared.
10:49:46 <doserj> esap: then find a way to embed it into the haskell type system :)
10:50:07 <esap> doserj: Actually GHC has something quite similar, the values with # kind.
10:51:06 <esap> doserj: But what's missing is Cantor's diagonalization on those values.
10:51:42 <doserj> values of a # kind may still diverge
10:52:08 <esap> doserj: Example?
10:52:58 <esap> doserj: At least 'fix' is not supported.
10:55:44 <conal> i don't understand the # kind.  are there any functions polymorphic over # ?
10:56:08 * ehird` is reading scheme in 48 hours
10:56:10 <ehird`> it's great!
10:56:18 <sjanssen> conal: unsafeCoerce# :)
10:56:22 <conal> a kind #n for representation size n makes sense to me.
10:56:31 <conal> sjanssen: type?
10:56:44 <sjanssen> a -> b
10:56:58 <conal> sjanssen: and the kinds of a & b?
10:57:08 <sjanssen> @kind GHC.Exts.unsafeCoerce#
10:57:11 <lambdabot_> parse error on input `GHC.Exts.unsafeCoerce#'
10:57:34 <conal> @type GHC.Exts.unsafeCoerce#
10:57:37 <lambdabot_> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
10:57:37 <lambdabot_> [2 of 2] Compiling L                ( L.hs, interpreted )
10:57:50 <conal> ??
10:57:55 <Saizan> @kind (#,#)
10:57:58 <lambdabot_> parse error on input `,'
10:58:39 <conal> GHC.Prim.unsafeCoerce# :: forall (a :: ?) (b :: ?). a -> b
10:58:44 <conal> what's "?"?
10:58:56 <conal> i hope no one quotes that question.
10:59:09 <sjanssen> conal: a and b can be any type
10:59:09 <kosmikus> it's a kind that can be both * and #
10:59:11 <doserj> the least upper bound of * and #
10:59:15 <Saizan> # and * are subtypes of ?
10:59:24 <kosmikus> subkinds
10:59:34 <conal> oh -- so really polymorphic even over #.  that's what i'd asked.
10:59:43 <sjanssen> conal: of course unsafeCoerce# is not your typical function
11:01:05 <conal> are there other functions polymorphic over unboxed types?
11:01:16 <fasta> Why do tutorials promise more than they deliver? Scheme in 48 hours, doesn't implement full Scheme, so it should be called something like "Some half-baked Scheme implementation in 48 hours".
11:01:29 <doserj> conal: error
11:01:31 <faxathisia> lol
11:01:49 <faxathisia> hows it not a scheme?
11:01:51 <conal> doserj: sure enough.
11:01:53 <faxathisia> I mean it doesn't claim R5RS
11:02:04 <Toxaris> fasta: isn't that the tutorial wich asks stuff like "implement the full numeric tower in 2:30 min" as exercises?
11:02:30 <kosmikus> conal: seq in the second arg
11:02:40 <fasta> faxathisia: Scheme was R5RS at the time that was released.
11:03:00 <fasta> And otherwise it's R4RS.
11:03:03 <conal> kosmikus: oho.  all pretty fringe functions.
11:03:11 <fasta> Since Scheme is an IEEE standard.
11:03:23 <faxathisia> ok I see your point
11:03:25 <kosmikus> conal: and mkWeak# seems to be, but I don't know exactly what that does
11:03:53 <conal> kosmikus: how are you coming up with these examples?
11:04:06 <kosmikus> conal: browsing the GHC.Exts module ;)
11:04:15 <conal> btw, i use mkWeak in DataDriven
11:04:24 <conal> kosmikus: oh!
11:04:44 <kosmikus> oh, I've used mkWeak once, too, I think. but I certainly don't know exactly what it does at the moment ;)
11:05:20 <kosmikus> touch# is another one
11:05:42 <conal> kosmikus: see http://haskell.org/haskellwiki/DataDriven#Ephemeral_values
11:05:42 <lambdabot_> Title: DataDriven - HaskellWiki
11:06:58 <kosmikus> conal: yeah, I start to remember. btw, the link to the System.Mem.Weak documentation is dead
11:07:10 <esap> What I would like with unboxed types is a function similar to not_fix :: ((a -> a) -> a) -> b, which would according to Curry-Howard correspondence prove that fixed points do not exist (using Cantor's diagonalization proof).
11:07:23 <conal> kosmikus: oops!  thanks
11:09:25 <conal> kosmikus: link fixed now
11:09:30 <kosmikus> great
11:09:37 <conal> renamed for base-3.0
11:10:27 <Ingon> ?src GenParser
11:10:27 <lambdabot_> Source not found. The more you drive -- the dumber you get.
11:10:28 <pitecus> whats the difference between weak head normal form and normal form?
11:10:33 <kosmikus> conal: looks fragile having both "latest" and "base-3.0.0.0" in the URL ;)
11:10:44 <kosmikus> esap: what would you do with such a proof?
11:11:05 <conal> kosmikus: sure does!  i wonder if there's an alternative.
11:11:07 <Ingon> ?src Text.ParserCombinators.Parsec.Prim.GenParser
11:11:07 <lambdabot_> Source not found. It can only be attributed to human error.
11:11:35 <kosmikus> conal: I don't know. fix the ghc version too, I guess.
11:11:54 <faxathisia> omg
11:11:58 <faxathisia> http://web.archive.org/web/20061011013338/www.haskell.org/hawiki/SimulatingDependentTypes
11:12:06 <faxathisia> that is some sly spam
11:12:09 <lambdabot_> http://tinyurl.com/yv3kwe
11:12:11 <faxathisia> instance Height (Leaf k [http://hcnvfi.d5x5.net/vvbmhqx.htm v]) Zero
11:12:12 <lambdabot_> Title: Untitled Document
11:12:15 <conal> kosmikus: yep.  done.  thanks again.
11:12:16 <esap> kosmikus: Generate an infinite tower of new types.
11:12:41 <esap> kosmikus: Cantor's diagonalization can prove that some elements are not part of some type.
11:13:07 <esap> kosmikus: So what I would like to do is to distinguish the different levels of that hierarchy
11:14:00 <Ingon> ?src Parser
11:14:00 <lambdabot_> Source not found. My pet ferret can type better than you!
11:14:22 <esap> kosmikus: basically, Cantor's diagonalization proves that there is no surjective map x -> (x -> Bool). Just some way of taking advantage of that.
11:14:59 <esap> kosmikus: But having 'undefined' as part of 'Bool' breaks that property.
11:15:00 <Ingon> ?src token
11:15:00 <lambdabot_> Source not found. It can only be attributed to human error.
11:15:06 <kosmikus> I more or less know how the technique works. I was more interested about what you're going to do with it.
11:15:33 <kosmikus> well, having undefined makes Haskell inconsistent anyway. Nevertheless, it's still a nice programming language.
11:16:10 <esap> well you wouldn't want to get rid of 'undefined' on all types. It would be way too hard to use.
11:17:42 <esap> But it's useful to have a sublanguage that cannot support 'fix', but which could use cantor's diagonalization.
11:17:45 <MyCatVerbs> It's just an explicit replacement for _|_.
11:17:50 <kosmikus> esap: why not? I know it's easy to say that "undefined" is just so convenient, but I find languages without general recursion interesting.
11:18:11 * bos pushes ghc 6.8.1 and gtk2hs 0.9.12.1 to the fedora 8 stable repository
11:18:24 <MyCatVerbs> kosmikus: aieeee! Some aren't even bloody well Turing complete!
11:18:40 <mrd> exactly
11:18:49 <faxathisia> kosmikus: Like which?
11:18:53 <kosmikus> MyCatVerbs: so what? ;)
11:18:55 <mrd> and you mean without partial recursion
11:19:08 <kosmikus> faxathisia: like Epigram or Coq.
11:19:12 <esap> kosmikus: It's actually hard to program with a language that must prove all programs as terminating.
11:19:23 <faxathisia> kosmikus: Can you tell me a little bit about Epigram? :)
11:19:45 <esap> kosmikus: because the type system must then disallow anything that it cannot prove as terminating.
11:19:54 <kosmikus> esap: probably as hard as programming Haskell for the first time is for a C programmer ;)
11:20:06 <faxathisia> esap: Or you yourself could prove to the type system?
11:20:20 <kosmikus> faxathisia: what do you want to know.
11:20:24 <mrd> write programs in the polymorphic lambda calculus
11:20:25 <esap> kosmikus: well yes, often the programmer would have to provide the proof.
11:20:38 <faxathisia> kosmikus: Well I looked at Epigram before but I couldn't understand what it's about
11:21:30 <kosmikus> it's a prototype for a programming language with dependent types. it allows you to develop your programs interactively.
11:21:46 <esap> kosmikus: But I would prefer a language that was divided into two, where one half would allow undefined and another wouldn't.
11:21:50 <kosmikus> it's a bit difficult to use in its current form.
11:22:17 <mrd> Agda is another language of interest
11:22:19 <esap> kosmikus: The thing is, I think those two halves both have things you cannot do in the other half.
11:22:21 <kosmikus> esap: yes, it sounds reasonable to tag nonterminating programs as evil.
11:22:27 <kosmikus> esap: much like IO.
11:22:34 <esap> kosmikus: yes.
11:22:47 * faxathisia (Reads about dependent types)
11:23:16 <kosmikus> esap: but you can already get quite far by adding codata.
11:23:17 <mrd> coinduction aka evil?
11:23:25 <esap> kosmikus: fix is interesting in such language. It would have to "choose sides" as to whether you can prove the fixed point as terminating or not.
11:23:54 <kosmikus> mrd: not all coinduction is evil.
11:24:10 <kosmikus> general recursion is evil.
11:24:21 <mrd> you mean partial recursion
11:24:27 <kosmikus> ?
11:24:44 <mrd> general recursion means totality
11:25:09 <faxathisia> kosmikus: What's the advantage..? provably correct programs or really expressive type system?
11:25:42 <kosmikus> mrd: no, it doesn't. where do you get that from?
11:27:13 <faxathisia> apparenly general recursion means two things
11:27:15 <kosmikus> mrd: oh, I just see that http://mathworld.wolfram.com/GeneralRecursiveFunction.html talks about two different camps. apparently you're the first person I meet that belongs to the "other" (relatively spoken).
11:27:16 <lambdabot_> Title: General Recursive Function -- from Wolfram MathWorld
11:27:51 <wolverian> http://haskell.org/ghc/docs/latest/html/libraries/stm-2.1.1.0/Control-Concurrent-STM-TVar.html -- is this supposed to be empty?
11:27:51 <lambdabot_> http://tinyurl.com/27vn24
11:27:55 <esap> kosmikus: One way to prove that things terminate is to prove that your types have a fixed-point free self-map (like logical negation in case of Bool). I would expect a subset of types with this property. Then have the result kind of 'fix' be based on whether a type has fixed-point free self-map or not.
11:29:34 <conal> hi grahamhutton
11:29:58 <grahamhutton> hi conal!
11:30:07 <mrd> kosmikus: yes, it's wonderfully confusing
11:30:08 <kosmikus> hey grahamhutton. I don't think I've ever seen you here.
11:30:23 <grahamhutton> hi andres -- i've only started on IRC recently :-)
11:30:28 <kosmikus> mrd: indeed.
11:30:35 <kosmikus> grahamhutton: nice :)
11:30:56 <faxathisia> kosmikus: is there no advantage? :|
11:31:09 <kosmikus> faxathisia: advantage of what?
11:31:22 <exDM69> grahamhutton: kiss life goodbye
11:31:28 <faxathisia> kosmikus: What is the idea for Epigram
11:31:56 <grahamhutton> edDM69 --- i only use IRC at home in the evening, so there's no danger of distraction during the day :-)
11:31:59 <kosmikus> oh, advantage of Epigram: you can write programs, properties, and proofs within a single language.
11:32:17 <kosmikus> the types can be extremely expressive and the interactivity helps you to structure your programs.
11:32:25 <SamB_XP> also, it isn't turing complete
11:32:28 <faxathisia> I like the sound of it
11:32:30 <esap> oh maybe the result kind of 'fix' should actually be based on whether the *function* given as argument is fixed-point free or not.
11:32:56 <esap> that's not as simple I suppose :-)
11:34:18 <grahamhutton> esap: every function of type a -> a in Haskell has a fixed point
11:34:44 <esap> grahamhutton: I know. GHC has unboxed types which I don't think have fixed points.
11:35:02 <esap> or do they?
11:35:20 <kosmikus> what do you mean by a type having a fixpoint?
11:36:02 <SamB_XP> @type +#
11:36:04 <lambdabot_> parse error on input `+#'
11:36:04 <faxathisia> kosmikus: 1 more question :)  did you start Epigram after haskell or something else?
11:36:12 <SamB_XP> @type (+#)
11:36:13 <lambdabot_> Not in scope: `+#'
11:36:21 <SamB_XP> @type (GHC.Prim.+#)
11:36:23 <lambdabot_> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
11:36:23 <lambdabot_> [2 of 2] Compiling L                ( L.hs, interpreted )
11:36:26 <faxathisia> kosmikus: (wondering what sorts of prerequisites there are)
11:36:32 <doserj> (+#) :: Int# -> Int# -> Int#
11:36:43 <SamB_XP> thank you ;-)
11:36:52 <kosmikus> faxathisia: oh, Haskell should be sufficient knowledge to start with Epigram.
11:36:56 <idnar> that... was an interesting response from lambdabot_
11:37:18 <SamB_XP> now... find me a fixpoint for (1# +#)
11:37:33 <kosmikus> faxathisia: but as mrd suggested, Agda(2) is also an interesting language to look at. it has a more Haskell-like syntax, and the current implementation is a bit more usable than that of Epigram.
11:37:36 <grahamhutton> SamB: just the example I was going to suggest!
11:37:50 <mrd> epigram isn't very usable atm
11:37:50 <faxathisia> kosmikus: ok thanks a lot, stuff to check out now :D
11:37:57 <esap> kosmikus: I mean that there is a fixed-point free function a -> a for the type a.
11:38:10 <mrd> i couldn't figure out how to delete code after loading it , even
11:38:17 <SamB_XP> esap: what the heck?
11:38:52 <SamB_XP> esap: the only functions of that type are id and const _|_
11:38:55 <grahamhutton> In GHC, functions with unboxed return types are implicitly lifted so that the return type includes bottom, but this doesn't seem to be enough to ensure that every function has a fixed point, as shown by the (1+) example above.
11:40:09 <esap> SamB: for concrete a of course, choose any type *without* undefined element.
11:40:47 <resiak> I have  data Query a = Leaf a | And [Query a] | Or [Query a]  .  Is there a way to get f :: Query (IO a) -> IO (Query a) for free, or do I have to write out the (admittedly trivial) five lines?
11:40:58 <kosmikus> mrd: I've only used Epigram to get a feeling for what might be possible in the future.
11:41:10 <kosmikus> mrd: I'm impatiently waiting for Epigram2 ;)
11:41:36 <sjanssen> resiak: hmm, sounds like you want a Traversable instance
11:42:37 <byorgey> resiak: you won't be able to get it *completely* for free, since there are multiple possible implementations of f.
11:42:49 <byorgey> at the very least you'd have to choose one.
11:42:49 <resiak> I don't see how to write a sane Foldable instance
11:43:06 <sjanssen> resiak: don't use Foldable, use Traversable
11:43:13 <esap> grahamhutton: What I'm advocating is to have two kinds in the language (dividing the language into two so that there would be types without _|_ and types with _|_) and have a fixed point function that magically find which side the argument function is. So "fix (not :: BoolWithoutUndefined -> BoolWithoutUndefined)" would be a type error, but "fix not :: forall a.a"
11:43:17 <resiak> class (Functor t, Foldable t) => Traversable t where
11:43:21 <sjanssen> oh
11:43:37 <sjanssen> well, Foldable is easy too
11:43:51 <resiak> sjanssen: how?  And and Or need different combining functions
11:44:15 <grahamhutton> esap: http://www.soi.city.ac.uk/~ross/papers/pointed.html
11:44:16 <lambdabot_> Title: Parametricity and Unboxing with Unpointed Types
11:44:27 <sjanssen> resiak: Foldable only provides a simple sequence-like view on the type
11:44:51 <esap> grahamhutton: cool somebody's already done it :-)
11:45:07 <resiak> sjanssen: sure… hrm. so i should give the obvious implementation of Foldable, regardless of how useless it basically is? :)
11:46:06 <byorgey> resiak: yup =)
11:46:34 <sjanssen> resiak: hmm.  Or you can just write 'sequence' for Query, it depends on whether you'll want other functionality based on Traversable
11:47:14 <resiak> sjanssen: yeah, i think just writing sequence is the path of least resistance for now.  thanks for your help!
11:48:18 <sjanssen> resiak: actually, you can get Foldable for free with a definition of sequence!
11:48:29 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Traversable.html#v%3AfoldMapDefault
11:48:30 <lambdabot_> http://tinyurl.com/35mwrw
11:49:33 <resiak> aha
11:49:43 <resiak> (for free modulo the Foldable instance :))
11:50:23 <sjanssen> modulo 'instance Foldable Query where foldMap = foldMapDefault', to be exact
11:52:14 <Saizan> uhm, half of Control.Monad could be defined for Applicative, instead
11:54:02 <SamB_XP> so, does this applicative stuff get us "monad comprehensions" or equivalent?
11:55:10 <sjanssen> SamB_XP: no, Monad is strictly more expressive than Applicative
11:55:41 <ptolomy> how does the GHC runtime deal with multithreaded access to thunks? Do all (potentially) unevaluated thunks have an associated mutex?
11:56:11 <sjanssen> ptolomy: short answer: no.  long answer: read the SMP Haskell paper :)
11:56:26 <ptolomy> sjanssen: Thanks.  :)
11:56:31 <Saizan> medium answer?
11:56:33 * ptolomy goes to find the paper.
11:56:47 <SamB_XP> are you folks making Applicative a superclass of Monad? if so, please also fix Monad so that monad comprehensions can reasonably be added
11:56:54 <sjanssen> medium answer: locking is not needed because computations are pure
11:57:05 <SamB_XP> (Make MonadZero class, move fail there...)
11:57:19 <Laney> aha, my intuition was right for once ;)
11:57:29 <sjanssen> SamB_XP: MonadZero and Monad comprehensions are othogonal AFAICT
11:58:20 <SamB_XP> well, all of this stuff needs to get done...
11:58:31 <resiak> sjanssen: hah!  that seems circular (requiring Traversable to implement Foldable so that I can implement Traversable)
11:59:49 <byorgey> resiak: that's because it is circular.  but mutual recursion is no problem for Haskell. =)
12:00:12 <SamB_XP> I have too much of a headache to argue about the theoretical orthogonality of MonadZero and monad comprehensions, but in practice they would not be orthogonal...
12:00:45 <SamB_XP> I'm pretty sure...
12:01:57 <sjanssen> SamB_XP: why can't MonadZero use the same desugaring as 'do' syntax?
12:02:46 <resiak> byorgey: sure, i just didn't think of it
12:03:04 <SamB_XP> hmm, actually, moving fail to MonadZero would require GHC changes, wouldn't it :-(
12:03:12 <SamB_XP> all this wired in stuff is a pain
12:04:14 <sjanssen> SamB_XP: it'd also break tons of code
12:04:37 <ptolomy> Hmm.. I wonder if will be faster for me to have an array of 256 'Maybe a's instead of having a map of (Map Char a).. I'm only doing lookups, really, but it is typically has less than10 actual members..
12:04:41 <SamB_XP> yeah.
12:05:03 <SamB_XP> I really wish GHC wouldn't wire things in so tightly...
12:06:33 <sjanssen> SamB_XP: it can be done with -fno-implicit-prelude
12:06:41 <SamB_XP> sjanssen: that doesn't count
12:06:58 <SamB_XP> that doesn't rewire stuff, that just uses whatever is in scope
12:07:04 <sjanssen> SamB_XP: that makes me believe that it isn't wired in
12:07:13 <sjanssen> at least not more wired in than Prelude typically is
12:07:24 <SamB_XP> yes, but that is bad enough
12:08:11 <sjanssen> you want to change something in the Prelude, so you have to change the Prelude
12:08:15 <sjanssen> why is this bad?
12:08:16 <SamB_XP> hmm.
12:08:19 <SamB_XP> I have an idea
12:08:36 <SamB_XP> an extra-special package called sugar
12:09:10 <SamB_XP> or something like that...
12:09:14 <sjanssen> and?
12:09:33 <SamB_XP> which exports the things that the desugarer needs
12:10:17 <phlpp> :t true
12:10:19 <lambdabot_> Not in scope: `true'
12:10:21 <SamB_XP> it's not a very well thought out idea, clearly ;-)
12:10:24 <phlpp> :t True
12:10:25 <lambdabot_> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
12:10:26 <lambdabot_> [2 of 2] Compiling L                ( L.hs, interpreted )
12:10:32 <phlpp> ._.
12:10:33 <vincenz> wtf
12:10:37 <vincenz> > 1
12:10:38 <lambdabot_>      Bad interface file: ShowQ.hi
12:10:38 <lambdabot_>         mismatched interface file versions:...
12:10:41 <sjanssen> phlpp: lambdabot_ is broken
12:10:42 <vincenz> o.O
12:10:47 <phlpp> oh
12:10:58 <phlpp> did i broke lambdabot down?
12:10:59 <sciolizer> =/ sorry. I just upgraded to 6.8.1, and it broke everything.
12:11:00 <SamB_XP> mbot was showing similar messages not long ago...
12:11:02 <SamB_XP> phlpp: no
12:11:40 <sjanssen> lambdabot: what is your problem?
12:11:41 <vincenz> sjanssen: you know what would be nice?
12:11:47 <sjanssen> vincenz: what?
12:11:58 <vincenz> class (Storable a) => FixedWidth a where ...
12:12:06 <vincenz> and then use that with your Storable Vector for an optimized !
12:12:12 <vincenz> you could then use this for matrices
12:12:32 <sjanssen> vincenz: all Storables should be fixed width
12:13:08 <vincenz> sjanssen: how do you deal with poly-constructor datatypes?
12:13:21 <vincenz> for instance Maybe
12:13:24 <sjanssen> vincenz: they're padded
12:13:31 <vincenz> ah
12:13:33 <sjanssen> Maybe doesn't have a Storable instance, of course
12:13:34 * vincenz wrinkles his nose
12:13:37 <vincenz> well
12:13:42 <vincenz> instance (Storable a) => Storable (Maybe a)
12:13:59 <SamB_XP> that sounds like it would waste a LOT of space
12:14:02 <sjanssen> vincenz: basically, Storable is supposed to be used for things like C structs
12:14:07 <vincenz> oh
12:14:10 <vincenz> not for serialization
12:14:27 <sjanssen> definitely not for serialization
12:14:41 <sjanssen> exact representation is very machine dependent
12:15:52 <vincenz> hmm
12:15:55 <vincenz> not if you go down to bytes
12:16:23 <SamB_XP> you MIGHT be able to use it with Data.Word/Data.Int for dealing with large mmapped datafiles in the fast case ("the files are from a machine with the same endianness as us")
12:16:55 <vincenz> enddianness is trivially bypassable
12:16:56 <sjanssen> SamB_XP: yeah, that would be okay
12:17:40 <vincenz> But that would be if the main purpose was serialization, not struct reading |
12:17:49 * vincenz thinks the name Storable is off then
12:17:50 <sjanssen> vincenz: that doesn't fix the problem.  Storable instances are for FFI, not serialization
12:17:56 <vincenz> Right
12:17:59 <vincenz> so call it FFIAble
12:18:12 <SamB_XP> it's in the Foreign tree...
12:18:12 <sjanssen> vincenz: see Data.Binary
12:18:13 <vincenz> storable to me in the first place talks about serialization
12:18:17 <SamB_XP> isn't that good enough for you?
12:18:35 <vincenz> SamB_XP: apparently not, as I assumed it was for serialization
12:20:01 <vincenz> sjanssen: ok,  will do
12:20:21 <BMeph> vincenz: Maybe you want the... Serializable class? ;p
12:20:36 <vincenz> @hoogle Serializable
12:20:37 <lambdabot_> No matches found
12:21:01 <SamB_XP> vincenz: think store as in STA
12:21:41 <BMeph> @hoogle ShowQ
12:21:42 <lambdabot_> No matches found
12:21:53 <vincenz> SamB_XP: I'm afraid I'm not familiar with sTA
12:22:35 <BMeph> > let s = ">_^"; (/>/^/) ('>':xs) _ = '^':xs; g = g in s/>/^/g
12:22:36 <lambdabot_>      Bad interface file: ShowQ.hi
12:22:36 <lambdabot_>         mismatched interface file versions:...
12:22:55 <BMeph> ACTION weeps for the broken lambdabot_
12:23:06 <BMeph> <Sighs>
12:25:48 <landij1> lambdabot should have said "^_^"?
12:25:57 <EvilTerran> er, what?... "Setup.lhs: HTTP.cabal:19: 'Executable' stanza starting with field 'flag old-base description'"
12:26:13 <nominolo> has anyone here successfully set up a darcs posthook on code.haskell.org to send commit messages to a mailing list?
12:26:35 <Heffalump> old version of cabal?
12:27:12 <EvilTerran> 1.1.6.2?
12:27:22 <byorgey> EvilTerran: yup, that's old.
12:27:28 <hajamie> Hi, I'm probably being a muppet, but why do I get the following in winhugs?
12:27:29 <hajamie> Hugs> map Char.isLower "aaAAaaA"
12:27:29 <hajamie> ERROR - Undefined qualified variable "Char.isLower"
12:27:46 <nominolo> Data.Char.isLower
12:27:51 <Heffalump> I'm not sure if hugs allows you to just import symbols like that
12:27:55 <Saizan> you need to :l Data.Char
12:27:57 <Heffalump> try loading Char or Data.Char
12:28:00 <hajamie> ok
12:28:10 <EvilTerran> i could've sworn I updated it just a couple of months ago 'cos something else was broken...
12:28:20 * byorgey wonders what a muppet is
12:28:29 <hajamie> Data.Char> Hugs> map Char.isLower "aaAAaaA"
12:28:29 <hajamie> ERROR - Undefined qualified variable "Char.isLower"
12:28:39 <EvilTerran> @go muppet
12:28:40 <lambdabot_> http://muppets.go.com/
12:28:40 <lambdabot_> Title: Muppets.com -- The New Official Home of the Muppets!
12:28:48 <hajamie> oops, typo
12:28:51 <byorgey> hajamie: now that you have imported Data.Char, you can just write 'isLower', without the 'Char.'
12:28:53 <Toxaris> hajamie: use isLower without Char
12:28:59 <allbery_b> EvilTerran: 6.8.1 required extensions to try to work around all the breakage the library split caused
12:29:22 <allbery_b> so there's a whole new Cabal needed for anything that knows about the lib split
12:29:35 <EvilTerran> hm? I'm still on GHC 6.6.1, will the new cabal work with that?
12:29:36 <hajamie> Woot!  Thanks!
12:29:38 <allbery_b> yes
12:29:53 <sciolizer> @type True
12:29:55 <Heffalump> EvilTerran: yes
12:29:58 <allbery_b> but if you're installing something that has been ported to 6.8.1 then it needs the new cabal, so you need the new Cabal
12:30:05 <lambdabot_> Bool
12:30:10 <EvilTerran> right -.-
12:30:13 <allbery_b> which thankfully is backward compatible
12:30:28 * EvilTerran sighs, expands his taskbar to two lines
12:30:33 <EvilTerran> I have too many windows open >.<
12:30:55 <Saizan> use xmonad!
12:31:11 <EvilTerran> and you can't put the quicklaunch and start button one-above-t'other on a horizontal two-line task bar, which is just stupid >>.<<
12:31:24 * byorgey writes a quick virus in Haskell that closes random windows and sends it to EvilTerran
12:31:47 * EvilTerran doesn't open any executable attachments
12:32:17 <ehird`> EvilTerran: using windows must suck.
12:32:32 <EvilTerran> if it did, i wouldn't use it
12:32:47 <ehird`> you poor person
12:32:48 <EvilTerran> it has its annoyances, but I prefer it to, say, linux for most purposes
12:32:56 * ehird` uses os x
12:33:57 <EvilTerran> I could've guessed by all the smugness.
12:34:02 <ehird`> :-)
12:34:11 <ehird`> actually i'm like that anyway
12:34:42 * SamB_XP always uses a two-line taskbar...
12:35:14 <dmwit> Only problem with a two-line taskbar is that then the Start menu isn't in the bottom left corner.
12:35:16 <sjanssen> taskbars are for the weak
12:35:48 <EvilTerran> dmwit, indeed; that ties in with what i was saying about not being able to stack it with the quicklaunch
12:36:25 <EvilTerran> er... okay, so i've built the new cabal thing... what am I supposed to do with it?
12:36:53 <byorgey> EvilTerran: uh... nothing =)
12:37:03 <byorgey> EvilTerran: just install whatever you were trying to install before
12:37:10 <EvilTerran> oh, has it copied itself in automagically? that's helpful
12:37:43 <byorgey> no, the installation process dynamically uses the functionality provided by the installed Cabal library.
12:37:50 <TSC> Hmm, MissingH is a bit broken under 6.8.1; it conflicts with the new base library (both have Data.String)
12:38:21 <EvilTerran> "ghc --make Setup.lhs -o setup" installs the cabal library?
12:38:33 <EvilTerran> (in the dir i extracted the cabal tarball to)
12:38:52 <EvilTerran> i'm thoroughly confused
12:39:41 <allbery_b> Setup.lhs should load the installed current Cabal
12:39:48 <Heffalump> have you installed the new cabal?
12:39:53 <Heffalump> if not, you'll want to do that first :-)
12:39:53 <allbery_b> you shouldn't need to ghc --make it, just runhaskell
12:39:55 <EvilTerran> i'm trying!
12:39:56 <allbery_b> or runghc
12:40:03 <EvilTerran> http://haskell.org/cabal/download.html
12:40:04 <lambdabot_> Title: The Haskell Cabal
12:40:07 <Heffalump> ok. So how did you build it? With the old cabal?
12:40:12 <allbery_b> yes
12:40:14 <EvilTerran> is teh confusing me
12:40:16 <allbery_b> oops
12:40:38 <Heffalump> Download old cabal. Build with old cabal. Install with old cabal.
12:40:51 <EvilTerran> i have an old cabal...
12:40:51 <Heffalump> Then restart build process of thing you were working with originally, perhaps after cleaning.
12:40:57 <Heffalump> sorry, Download new cabal.
12:41:09 <Heffalump> I got a bit carried away with my "old cabal"s there.
12:41:24 <Igloo> You can build new Cabal with itself
12:41:25 <allbery_b> download *new* cabal, build and instal with old...
12:41:36 <Igloo> Just ghc --make Setup in its tree
12:41:48 <sjanssen> actually, Cabal's build procedure uses the new Cabal automatically
12:41:54 <Heffalump> oh, ok. Well, that then.
12:41:58 * Heffalump gives up
12:42:06 <Igloo> :-)
12:42:07 * EvilTerran gives up too
12:42:18 <EvilTerran> I'll just get a more recent GHC binary. easier.
12:48:29 <landij1> I just built the most recent Cabal from darcs yesterday (on Linux).  It uses a Makefile to bootstrap.  You could try using the version of make that comes with MinGW if you're on Windows.
12:49:51 <EvilTerran> or, i could just download 6.8.1. that'd be quicker *and* more likely to work than installing MinGW
12:52:09 <hpaste>  ptolomy pasted "Word completion data structure" at http://hpaste.org/4097
12:53:19 <ptolomy> It is a bit messy, but it was surprised how simply I could get an efficient and correct system.. the server is pretty darn fast as in, and it took me a total of maybe 20 minutes.. once I compiled, it pretty much worked.
12:53:55 <olsner> @faq
12:53:55 <lambdabot_> The answer is: Yes! Haskell can do that.
12:55:26 <resiak> sjanssen: thanks for your help earlier; once i got the types right and my head around applicative, I reduced one enormous confusing function to two simple ones (plus obviously-correct instances of things). :)
12:58:05 <vincenz> > 1
12:58:25 <sciolizer> eval module failed in contextual handler: IRCRaised Data.ByteString.last: empty ByteString
12:59:29 <sciolizer> If somebody else has a working copy of lambdabot that they want to put up, I'll gladly terminate mine. :)
12:59:52 <dmwit> ?quote haskell.form
12:59:52 <lambdabot_> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
13:00:03 <dmwit> resiak: ^^ ;-)
13:00:17 <resiak> dmwit: :)
13:03:01 <nominolo> k
13:03:16 <nominolo> heh, oops
13:05:00 <nominolo> why does a word completer need bytestrings? doesn't a trie with multiple entry points suffice?
13:06:22 <ptolomy> nominolo: Well, since I'm returning the entire words that it completes to, I chose to keep all of the words in memory as bytestrings (since they are much smaller), then have each node point to the list of strings it completes to.
13:06:36 <vincenz> ptolomy: why not generate?
13:06:40 <vincenz> based on a trie
13:07:02 <vincenz> cause you'll have a big list of pointers ini your roots
13:07:28 <nominolo> bytestrings don't work too well for small strings, since you trash the C-allocator
13:07:41 <dmwit> Right, a tree walk seems perfect for this application.
13:08:17 <nominolo> well, at least i'm not sure it's actually cheaper since bytestrings still have some overhead (pointers + region offsets)
13:08:31 <vincenz> using a list zipper it's easy to generate prefix
13:08:54 <vincenz> getWords rev_pre [] tree = rev_append rev_pre onto everything in tree
13:09:16 <vincenz> getWords ys (x:xs) tree = t <- lookup tree x in getWords (x:ys) xs t
13:09:42 <ptolomy> My thinking was mostly that I wanted the cost to be up front so that I wouldn't have to be allocating whenever it is queried.
13:10:16 <vincenz> ptolomy: yes but your consumption is way up, unless you plan to generate a lot of words based on short prefixes anyways, but even then your memory consumption is down to more or les s1/26th
13:11:01 <ptolomy> http://definr.com/ <-- I was amusing myself by trying to create a viable haskell replacement for the backend used by this site.
13:11:01 <lambdabot_> Title: definr - incredibly fast dictionary
13:11:09 <ptolomy> Lots of completions for short words..
13:11:17 <nominolo> the network will be the bottleneck in either case, i think
13:11:19 <vincenz> when I say short I mean 2 letters or less
13:11:59 <vincenz> not to mention that since you're sending these
13:12:04 <vincenz> you can probably lazily generate the list of words
13:12:08 <vincenz> and send em over network
13:12:14 <vincenz> thereby not requiring storage of all words
13:12:56 <sjanssen> ptolomy: a binary search over an array of ByteStrings would probably be faster, but significantly less elegant
13:13:25 <nominolo> faster than a trie?
13:13:42 <olsner> aren't they both logn?
13:13:51 <vincenz> olsner: for what operation?
13:14:05 <sjanssen> nominolo: faster in practice, I think
13:14:06 <ptolomy> My current techinque requires one map lookup for every query character.
13:14:10 <vincenz> I think for word generation from prefix, trie is bette
13:14:12 <olsner> vincenz: lookup
13:14:13 <nominolo> trie is O(length of word)
13:14:17 <vincenz> olsner: this isn't lookup
13:14:23 <sjanssen> I might be stupid
13:14:50 <ptolomy> .. which is why I was considering replacing the Map with an array so I can have constant-time lookup, but it seems so wasteful.
13:14:51 <vincenz> for lookup, a hash map is the fastest
13:14:57 <vincenz> but not for this
13:15:08 <vincenz> cause you have Word -> [Word]
13:15:09 <sjanssen> I think this solution will use lots of memory
13:15:25 <vincenz> sjanssen: you can use an array for each level
13:15:44 <sjanssen> vincenz: my concern is the cached [BS] at each level
13:15:44 <olsner> vincenz: I thought we were interested in finding a list of words matching a prefix - at least it's *some* kind of lookup
13:15:52 <vincenz> sjanssen: oh right, I agree completely
13:16:20 <ptolomy> the [BS] at each level has a maximum length, and the members should be shared, I'd think.
13:16:24 <vincenz> olsner: yes we are, and afaict, only tries support such
13:16:37 <sjanssen> ptolomy: the members are shared, but the spines of the lists aren't
13:16:50 <vincenz> right :)
13:16:57 <vincenz> 22:07 < vincenz> cause you'll have a big list of pointers ini your roots
13:17:00 * ptolomy should do a count just to see how many nodes his current version running iwht dict.words has.
13:17:17 <vincenz> ptolomy: I can give you a back of the envelope
13:17:23 <vincenz> given 50k words at an average length of 6 letters
13:17:28 <vincenz> you're gonna have 300 pointers to BS's
13:17:32 <vincenz> 300k even
13:17:39 <vincenz> and 50k BSs
13:17:44 <vincenz> (obviously)
13:18:57 <vincenz> so your pointer list overshadows your BS in consumption
13:18:59 <vincenz> that's even easily provable
13:19:08 <vincenz> for each letter in your word, you have 1 byte in the BS, and 1 pointer to it
13:19:16 <vincenz> (plus a cons cell)
13:19:29 <sjanssen> ptolomy: it's O(n) extra memory, where n is the sum of the length of all words
13:19:31 <ptolomy> If I get time, I'll do an alternate implementation that does a binary search on an array of ByteStrings.. it'll probably be faster and smaller, although less fun.
13:19:52 <vincenz> how do you binary search based on prefix?
13:19:57 <vincenz> I thought binary search required total ordering
13:20:27 <olsner> vincenz: you can binary search for a range too
13:20:28 <ptolomy> I assume you'd search once for each prefix character.
13:20:44 <vincenz> olsner: interesting
13:20:58 * ptolomy thinks he means something different than what he said.
13:21:10 <vincenz> data Trie a = Emp | Trie (Array (Bool, Trie a))
13:21:15 <sjanssen> vincenz: use binary search to determine the range that starts with c0, then binary search on that range to determine the range that has the second letter c1, etc.
13:21:30 * vincenz nods at sjanssen 
13:21:46 <swiert> sjanssen: Any chance of an XMonad submission for the next Monad.Reader?
13:22:21 <vincenz> data Trie a = Emp | Trie (IOArray (Bool, Trie a))
13:22:25 <vincenz> and then use unsafeIO
13:22:27 <sjanssen> actually, I'd do something like: data Trie = Trie (Int, Int) (Map Char Trie)
13:22:42 <vincenz> sjanssen: I used to have that in an implementation
13:22:42 <vincenz> in fact
13:22:48 <vincenz> I have a Trie implementation that mirrors Map
13:22:53 <sjanssen> where the (Int, Int) is a range onto a sorted array of ByteStrings
13:22:57 <vincenz> but I fear that all those Maps might be expensive memorywise
13:23:09 <sjanssen> swiert: perhaps, let me see if dons is interested
13:23:13 <sjanssen> dons: interested?
13:23:13 <nominolo> Better Trie !Int !Int !(Map Char Trie)
13:23:26 <nominolo> @seen dons
13:23:26 <lambdabot_> dons is in #xmonad, #haskell and #ghc. I don't know when dons last spoke.
13:23:36 * vincenz still wonders why you want the BS instead of generating live
13:23:58 <swiert> sjanssen: cool. I'd imagine he's pretty swamped with finishing a PhD, starting a new job, etc...
13:31:15 <ptolomy> If the suffixes were generated live, wouldn't it mean more runtime allocations to construct all the possible strings (along with the cost of walking subtrees to get completions), whereas maintaining a list of BS completions seems like it'd be costly but one-time.
13:31:20 * vincenz isn't sure a BS would be ideal, eventuall you'll have to rewrite em anyways to the output, so might as well generate live and depend on proper fusion
13:31:27 <vincenz> ptolomy: not with proper fusion
13:31:32 <ptolomy> I always forget about that...
13:31:34 <vincenz> ptolomy: eventuall you're gonna be using these strings once
13:32:05 <vincenz> of coures
13:32:06 <ptolomy> ByteString.hPuts converts to String?
13:32:11 <vincenz> the only thing that talks is a benchmark
13:32:16 <ptolomy> Right.
13:32:18 <vincenz> comparing a prefix lookup and dump to IO
13:32:19 <sjanssen> ptolomy: no, it writes the bytes directly
13:32:30 <vincenz> ptolomy: how are you sending your output?
13:32:35 <vincenz> ptolomy: aren't you generating HTML?
13:32:53 <ptolomy> No, plaintext with BS.unlines
13:33:00 <ptolomy> Content-Type: text/plain
13:33:04 <vincenz> ah
13:33:52 <sjanssen> ptolomy: if you want *maximum* speed, keep the words as a single \n separated ByteString
13:34:04 <ptolomy> offsets..
13:34:38 <sjanssen> ptolomy: yeah, then store (Int, Int) pairs in the internal nodes of your trie
13:34:56 <ptolomy> Now I just need a good multicore machine and a benchmarking client to run tests with..
13:35:03 <dcoutts_> bos: woo! (re: pushing ghc 6.8.1 and gtk2hs 0.9.12.1 to the fedora 8 stable repo)
13:35:04 <vincenz> why multicore?
13:35:30 <sjanssen> then you can simply hPut (take x . drop y) for the fastest possible IO
13:35:57 <sjanssen> hPut (take x . drop y $ bs)
13:36:22 <vincenz> @pl \x y -> hPut . take x . drop y
13:36:22 <lambdabot_> ((hPut .) .) . (. drop) . (.) . take
13:36:26 <conal> hPut . take x . drop y
13:36:30 <ptolomy> vincenz: Part of my arbitrary specification. I was aiming for "fast production server with 2k+ responses per second".. and each connection is its own thread, so a multicore machine would be best.
13:36:43 <vincenz> oh right
13:36:49 <vincenz> ptolomy: well start with this
13:36:56 <vincenz> :)
13:37:05 <vincenz> this seems singlecore, this kernel at least
13:37:17 * ptolomy needs to start writing code for practical ends so he is forced to make clearer specifications and more reasonable goals.
13:37:26 <sjanssen> ptolomy: all words are latin1, right?
13:37:36 <ptolomy> Assumed ASCII words.
13:37:51 <ptolomy> english dictionary entries.
13:37:59 <Mr_Awesome> ptolomy: quit valuing clarity and reason :P
13:38:01 <vincenz> ok, slurp the file into a BS
13:38:05 <vincenz> then build your trie :)
13:38:58 * byorgey thinks hGetContents should be renamed to hSlurp
13:39:16 <vincenz> data Trie = Trie !Int !Int !(Map Char Trie)   as proposed by nominolo
13:39:35 <sjanssen> use IntMap instead
13:39:47 <vincenz> I would even go for an array
13:39:54 <vincenz> and use an | Emp
13:39:58 <vincenz> IOArray
13:40:01 <vincenz> and use unsafeIO
13:40:05 <vincenz> for lookup
13:40:21 <vincenz> if you know your letters are a-z
13:40:23 <sjanssen> vincenz: no!
13:40:29 <sjanssen> vincenz: use Array
13:41:02 <sjanssen> there is no good reason to use IOArray+unsafePerformIO over Array here
13:41:11 <vincenz> hmm
13:41:15 <vincenz> I always thought they took more memory overhead
13:41:18 <vincenz> due to their laziness
13:41:18 <sjanssen> no
13:41:24 <vincenz> good to know then :)
13:41:26 <sjanssen> IOArrays are lazy
13:41:59 <vincenz> so tere yo go
13:42:33 <vincenz> data Trie = Emp | Trie !Int !Int (Array Word8 Trie)
13:42:37 <ptolomy> hmmm.. now I have 3 implementations to attempt.
13:43:25 <ptolomy> Good thing my boss doesn't know what I do all day.
13:43:31 <byorgey> hehe
13:44:54 <sjanssen> if you want, data Trie = Empty | Trie !ByteString !(Array Word8 Trie)
13:45:09 <vincenz> sjanssen: you wouldn't know the length?
13:45:26 <vincenz> oh wait, lengths are on top of BS, aren't they
13:45:40 <vincenz> sjanssen: there's a difference,
13:45:53 <vincenz> never mind there isn't, but still the question remains
13:46:04 <vincenz> the second !ByteString represents the whole segment or just the prefix?
13:46:10 <sjanssen> that uses 2 (IIRC) more words, but it's a little bit nicer IMO
13:46:18 <sjanssen> vincenz: the whole segment
13:46:26 <sjanssen> the segment from the dictionary
13:46:28 <vincenz> ooh
13:50:47 <ptolomy> man, generating the Trie that references locations in the one bytestring is going to be a lot less pretty than the other way.
13:51:35 <dcoutts_> why reference locations in a bytestring, why not just take the appropriate segments of the bytestring. It's cheap to do that and pretty space efficient.
13:51:36 <vincenz> sjanssen: dropping and taking for BS reuse the same data, right?
13:51:43 <dcoutts_> yes
13:51:58 <dcoutts_> it allocates only 5 words
13:52:11 * vincenz counts
13:52:36 <Saizan> ahah! so it's 3 more words that way!
13:52:43 <dcoutts_> 1 header word, 2 for a ForeignPtr (with shared ForeignPtrContents) and 2 for the 2 ints, offset and length
13:53:27 * ptolomy blasphemes and tries out a vector-of-strings based C++ version first.
13:53:33 <dcoutts_> Saizan: no, only 2 if you're using {-# UNPACK #-} !Int
13:53:36 <vincenz> that's 5 words extra for each internal node..
13:53:56 <vincenz> > 26^5 * 5
13:53:58 <vincenz> > 26^6 * 5
13:54:11 <faxathisia> 1544578880
13:54:16 * vincenz wrinkles
13:54:24 <dcoutts_> why do you think it's 5 ?
13:54:30 <dcoutts_> what are we comparing exactly?
13:54:42 <vincenz> nm
13:54:43 <sjanssen> vincenz: those allocations don't really matter, I bet they won't even happen because hPut will unbox its arguments
13:54:48 <vincenz> the dictionary is sparse
13:54:51 <vincenz> it's hard to calculate this
13:54:57 <Saizan> data Trie = Emp | Trie !Int !Int (Array Word8 Trie) vs data Trie = Empty | Trie !ByteString !(Array Word8 Trie)
13:55:31 <dcoutts_> Saizan: ok, so if you use UNPACK pragmas on those strict fields (which you should) then it's 2 words difference
13:55:36 <vincenz> ptolomy: btw, since you're using an array, make very sure to check that your input is [a-z]
13:56:10 <vincenz> (lowercase then filter :)
13:56:32 <Saizan> dcoutts_: does the strict field on Array matter?
13:56:35 <sjanssen> vincenz: a-z isn't right, definr.com preserves case and supports non-alphabetic words
13:56:41 <vincenz> oy
13:56:45 <ptolomy> well, I arbitrarily decided that case and spaces should be preserved.
13:56:52 <vincenz> then I'm not certain my suggestion of using an array is good
13:57:02 * vincenz assumed a reasonably small keyspace per character
13:57:32 <sjanssen> we're looking at about 1KB overhead for each array
13:57:48 <vincenz> then perhaps a map might be better
13:57:53 * vincenz isn't too familiar with overhead of maps
13:57:55 <sjanssen> I'm curious how many internal nodes there are in the dictionary
13:58:04 <vincenz> but they're better for sparse structures one would think
13:58:10 <vincenz> and dictionaries are rather spare
13:58:11 <vincenz> +s
13:58:12 <sjanssen> vincenz: O(n)
13:58:14 <SideFFect> Hey guys!
13:58:31 <SideFFect> get this...my teacher is working on making a "better" haskell compiler
13:58:38 <SideFFect> hes calling it Haskell++
13:58:39 <SideFFect> lol
13:58:47 <conal> SideFFect: who's your teacher?
13:59:03 <SideFFect> dr. d.probst
13:59:23 <dcoutts_> Saizan: yes, using ! and {-# UNPACK #-} n the Array field will also save 1 header word and 1 indirection
13:59:36 <vincenz> sjanssen: arrays cost 1K?
13:59:39 * vincenz whistles
13:59:39 <SideFFect> hes allowing mutable trees, and easier keywords and a whole bunch of stuff I dont get heh
13:59:39 <dcoutts_> Saizan: oops, stray 'n'
14:00:00 <sjanssen> vincenz: an array that covers the entire character range
14:00:02 <byorgey> mutable trees!?
14:00:12 <vincenz> sjanssen: oh right
14:00:28 <sjanssen> SideFFect: mutability?  Sounds like he doesn't understand Haskell
14:00:56 <glguy> sjanssen: didn't you hear? *dr.* d.probst
14:01:06 * vincenz chuckles
14:01:07 <gbacon> what's the best way to lift a list into an arrow?
14:01:07 <SideFFect> yeah like instead of having to re-create a whole new tree if you change something at the last child node, he wants to be able to change a tree directly
14:01:20 <sjanssen> philosophically, I mean
14:01:22 <gbacon> I have a document shell going with HXT
14:01:27 <mrd> gbacon: listA
14:01:30 <sjanssen> SideFFect: oh, with an immutable interface?
14:01:48 <Cale> SideFFect: Presumably that would mean that you would need to throw away the reference to the previous tree?
14:02:01 <glguy> maybe he's implementing uniqueness types?
14:02:09 <vincenz> glguy: clean
14:02:17 <glguy> vincenz: exactly like clean
14:02:20 <mrd> what's wrong with Zippers
14:02:25 <SideFFect> I have no idea how hes doing it, but hes doing it... he gave us an assignment with his "syntactic sugar" as he calls it
14:02:32 <SideFFect> I'll paste it on hpaste, one sec
14:02:35 <vincenz> mrd: nothing, they're great
14:02:59 <SamB_XP> what sort of PhD does he have?
14:03:21 <mrd> piled higher
14:03:24 <hpaste>  SideFFect pasted "Trees_Mutable?" at http://hpaste.org/4098
14:03:31 <gbacon> mrd: what's wrong with my thinking in expecting listA [1,2,3] >>> (+1) to produce [2,3,4]?
14:03:33 <SideFFect> long read, but thats the assign
14:03:45 <SideFFect> I think he graduated comp sci
14:03:47 <SideFFect> or eng
14:03:49 <SideFFect> not sure
14:03:50 <gbacon> sorry, dropped a pure
14:04:14 <Saizan> ah! that's a really mutable tree, in a monad.
14:04:35 <SideFFect> the assign you mean?
14:04:57 <Saizan> mmh, no, wait, i'm going to read it better first :)
14:05:20 <SideFFect> heh ok :P
14:05:37 <SamB_XP> what is all this STM bussiness
14:05:59 <SamB_XP> "data STM Tree a" is not Haskell syntax
14:06:07 <SideFFect> standard transactional memory I think
14:06:10 <Zao> SamB_XP: STM is a monad.
14:06:16 <SideFFect> it has to do with transactions and atomic
14:06:22 <vincenz> Zao: that doesn't diminish SamB_XP's claim
14:06:24 <SamB_XP> Zao: in the usual language, yes
14:06:28 <vincenz> data STM Tree a means nothing
14:06:30 <mrd> gbacon: listA expects an arrow argumen
14:06:31 <vincenz> you want
14:06:33 <faxathisia> SamB: How is that not haskell ?
14:06:33 <SamB_XP> Zao: clearly this is different, however
14:06:35 <vincenz> STRef (Tree a)
14:06:41 <Zao> Oh. Misread.
14:06:41 <faxathisia> oh you can't have a space in the name
14:06:43 <idnar> @info STM
14:06:43 <lambdabot_> (STM)
14:06:52 <SamB_XP> vincenz: this is an ASSIGNMENT
14:06:56 <idnar> @info STM Tree
14:06:56 <lambdabot_> (STM Tree)
14:07:03 <vincenz> SamB_XP: hmm?
14:07:10 <Heffalump> sideffect: this guy? http://encs.concordia.ca/Faculty/directory/CSE/DProbst.html
14:07:10 <lambdabot_> Title: Faculty of Engineering and Computer Science Directory
14:07:20 <SideFFect> thats him
14:07:32 <mrd> gbacon: well you can lift anything into an arrow using constA
14:07:35 <SideFFect> :D
14:07:37 <Heffalump> never heard of him :-)
14:07:44 <SideFFect> you went to concordia?
14:07:46 <vincenz> SamB_XP: telling him which API might be useful isn't going to solve the problem much
14:07:47 <mrd> gbacon: listA is for obtaining multiple results from an arrow
14:08:01 <SamB_XP> vincenz: I never mentioned an API!
14:08:08 <vincenz> SamB_XP: no, I did
14:08:13 <vincenz> SamB_XP: or why did you say "this is an ASSIGNMENT" ?
14:08:31 <mrd> gbacon: listA (atTag "p" >>> multi getText) to get all paragraphs, for example
14:08:41 <Heffalump> no, just did some googling. I meant I never heard of him in a Haskell context.
14:08:58 <SideFFect> oh yeah...he only learned this like last yr or yr and a half ago
14:09:00 <SamB_XP> vincenz: are you looking at http://hpaste.org/4098 ?
14:09:03 <SideFFect> and he wants to change it already
14:09:04 <SideFFect> sigh...
14:09:05 <Saizan> well this Haskell++ seems syntactic sugar for TMVar essentially
14:09:21 <Heffalump> what research has he done before?
14:09:24 <vincenz> SamB_XP: yes, still wonder why you stated that in all caps to me?
14:09:31 <SideFFect> yeah thats what we're doing TVar read/write stuff
14:09:39 <SideFFect> he hates the TVar he said
14:09:39 <gbacon> mrd: I'm trying to go the other direction: I'd like to take data from a list and sprinkle it into an XML tree generated by HXT
14:09:49 <SideFFect> his research? no idea
14:09:51 <sjanssen> SideFFect: you ought to tell him that this is possible in standard GHC already
14:09:58 <gbacon> mrd: a la the collectImages >>> genTableRows example in the HXT tutorial
14:10:13 <SideFFect> he said he doesnt use GHC and so has no idea if simon berch (?) if thats his name, created it already
14:10:41 <glguy> that's a pretty good reason to drag your students into something then
14:10:47 <SideFFect> hehe
14:10:49 <Saizan> gbacon: constL
14:10:55 * SamB_XP forgets about trying to talk with vincenz, he (SamB) is too confused :-(
14:11:08 <mrd> constL :: (ArrowList a) => [c] -> a b c
14:11:19 <vincenz> SamB_XP: 23:08 < vincenz> SamB_XP: or why did you say "this is an ASSIGNMENT" ?
14:11:23 <vincenz> erm
14:11:23 <Saizan> gbacon: most utility functions are given by this class http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ArrowList.html or the other Arrow*
14:11:24 <lambdabot_> http://tinyurl.com/upyok
14:11:29 <vincenz> 23:06 < SamB_XP> vincenz: this is an ASSIGNMENT
14:11:36 <vincenz> SamB_XP: I wondered why you said that to me, that's all
14:11:43 <SamB_XP> I'm not sure
14:12:03 <SamB_XP> it sounded like you were trying to correct the assignment or something, I guess
14:12:15 <vincenz> oh
14:12:29 <vincenz> yes, but I figured the assignment would at least be input correct, given how it most likely came from his prof
14:12:51 <vincenz> SamB_XP: and you said it's not valid syntax, then Zao said STM existed, and I pointed out to Zao what you were claiming
14:12:55 * vincenz stops the metatalk
14:13:10 <SideFFect> does anyone have an idea of what he wants?
14:13:28 <SideFFect> we can already finish this using normal haskell, but his syntactic sugar thing is weird
14:13:30 <vincenz> SideFFect: seems pretty straightforward, he wants a mutable data-structure
14:13:38 <SamB_XP> SideFFect: you want to ask him for the Haskell++ documentation, is what you want
14:13:39 <sjanssen> SideFFect: the text doesn't make very much sense
14:13:49 <SamB_XP> also a compiler would be nice
14:13:54 <SideFFect> isnt the point of haskell to do away with mutable variables?
14:14:07 <SideFFect> well, you can update things, just doesnt change the first memory place
14:14:13 * sjanssen agrees with SamB_XP, you need to know the semantics of this stuff if you're expected to use it
14:14:17 <SideFFect> he's working on the compiler
14:14:21 <SideFFect> w/ 3 grad students
14:14:28 <SideFFect> lol...the fun of working for a teacher
14:14:29 <faxathisia> which compiler?
14:14:31 <SamB_XP> does he have the documentation done yet?
14:14:41 <vincenz> faxathisia: Haskell++
14:14:44 <SideFFect> he didnt tell us anything of what he has dont yet
14:14:46 <SideFFect> done*
14:14:58 <SideFFect> just he's working on making haskell "better"
14:15:02 <faxathisia> haha
14:15:12 <glguy> can you take the class from a different prof?
14:15:17 * vincenz thinks the naming is poor, and if it's just syntactic sugar, why is he calling it a new language instead of simply using macros ala liskell or TH, or some prepropcessor?
14:15:32 <SideFFect> too late now :P 1 week left in term
14:15:52 <Heffalump> I think we're wasting way too much time discussing vapourware advertised by someone who isn't even here and didn't even mean to advertise it here :-)
14:16:09 <gbacon> Saizan: I'm stuck trying to figure out how to supply a list as input to ArrowXml
14:16:14 <vincenz> Heffalump + 1
14:16:19 <SideFFect> two choices for this class: this teacher, haskell crazy, or another teacher who teaches eiffel and ruby and etc
14:16:35 <mrd> gbacon: runX (constL ["a","b"] >>> selem "p" [ mkText ])
14:16:37 <SamB_XP> I think you should tell your prof that the official Haskell time-wasting club said that he shouldn't give you assignments based on vapourware...
14:16:42 * sjanssen notes that Haskell is picking up lots of karma from this conversation
14:16:54 <SideFFect> we all sighed when he gave us this assignment, dont worry
14:17:02 <vincenz> sjanssen I thought that was only if there's nothing before it
14:17:06 <gbacon> mrd: thanks!
14:17:09 <vincenz> @karma sjanssen
14:17:10 <lambdabot_> sjanssen has a karma of 38
14:17:12 <sjanssen> SamB_XP: vapourware without semantics!
14:17:15 <vincenz> Why do you think sjanssen++
14:17:16 <vincenz> @karma sjanssen
14:17:16 <lambdabot_> sjanssen has a karma of 39
14:17:18 <vincenz> oh
14:17:18 <mrd> @wiki HXT/Practical
14:17:19 <lambdabot_> http://www.haskell.org/haskellwiki/HXT/Practical
14:17:26 <SamB_XP> yeah, undocumented vapourware at that
14:17:26 <sjanssen> vincenz: I know because I wrote the code to do it :)
14:17:29 <faxathisia> SamB_XP: hahaha
14:17:51 <vincenz> sjanssen: Then you rightfully deserve that ++ :)
14:17:55 <SamB_XP> if it came with semantics, that wouldn't quite be vapourware, would it?
14:18:04 <SideFFect> ok time to eat...have fun discussing the assign :P
14:18:19 <vincenz> </Haskell++>
14:18:20 <sjanssen> SamB_XP: well the -ware suffix means software, I suppose
14:18:28 <sjanssen> SamB_XP: you can have a spec without an implementation
14:18:33 <vincenz> sjanssen: hardware
14:18:39 <faxathisia> @remember SamB I think you should tell your prof that the official Haskell time-wasting club said that he shouldn't give you assignments based on vapourware...
14:18:39 <lambdabot_> Done.
14:18:40 <SamB_XP> well, the semantics would almost be software
14:19:34 <dibblego> ?hoogle (Eq a) => a -> [a] -> Bool
14:19:35 <lambdabot_> Prelude.elem :: Eq a => a -> [a] -> Bool
14:19:35 <lambdabot_> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:19:51 * vincenz groans at the presence of notElem
14:20:01 <faxathisia> @src notElem
14:20:01 <lambdabot_> notElem x =  all (/= x)
14:20:10 <vincenz> @src elem
14:20:10 <lambdabot_> elem x    =  any (== x)
14:20:19 <vincenz> maybe for early abort?
14:20:21 <faxathisia> weird..
14:20:21 <idnar> vincenz: not . elem isn't exactly the same thing
14:20:24 <vincenz> wait, that wouldn't work
14:20:26 <vincenz> idnar: exactly
14:20:29 <idnar> > elem 5 [1..]
14:20:33 <vincenz> (not .) . elem
14:20:54 <idnar> eek, what happened to the bot?
14:21:11 <sciolizer> idnareval module failed in contextual handler: IRCRaised Data.ByteString.last: empty ByteString:
14:21:41 <Heffalump> idnar: really?
14:21:52 <Heffalump> oh, if == and /= aren't opposites?
14:22:02 <idnar> Heffalump: I was thinking more in terms of early-out
14:22:06 <vincenz> idnar: that's the problem
14:22:15 <vincenz> oh right, it does work, early abort on fail
14:22:15 <faxathisia> == and /= have to be opposites don't they?
14:22:18 <Heffalump> they should have precisely the same early-out, shouldn't they?
14:22:24 <vincenz> Heffalump: no, opposites
14:22:26 <Heffalump> faxathisia: "have to be", yes
14:22:26 <idnar> all (/= x) can early out if you find x == a
14:22:28 * vincenz ponders
14:22:35 <Heffalump> so can any (== x)
14:22:35 <idnar> any (== x) can early out if you find x /= a
14:22:38 * vincenz is too tired to keep context-switching form what he's working on
14:22:47 <idnar> not (all (/= x)) can't early out if you find x /= a
14:22:49 <Heffalump> no, they both early-out in the same case, namely x == a
14:22:52 <vincenz> idnar: no
14:22:56 <vincenz> idnar: any (==x) can early out when == x
14:23:00 <idnar> err.
14:23:02 <vincenz> all (/=x) same
14:23:05 <idnar> yeah
14:23:07 <idnar> ugh
14:23:11 * vincenz was equally confused :)
14:23:13 <idnar> I'm not thinking clearly
14:23:26 <conal> muddle happens
14:23:46 <vincenz> irc tends to reacting too quickly out of fear of losing context
14:23:47 <idnar> in both cases, you terminate once you either find a, or the end of the list
14:23:49 <Heffalump> is everyone convinced that notElem is not . elem assuming sensible == and /= ?
14:23:57 <vincenz> IRC is a poor medium for meaningful conversation.
14:24:07 <vincenz> Heffalump: yes, hence my first ugh
14:24:08 <idnar> and the return values are just swapped
14:24:10 <shapr> vincenz: What's better?
14:24:20 <vincenz> shapr: conversations?
14:24:35 <shapr> Hard to do with this many geographically distributed people.
14:24:41 <Heffalump> I like IRC for shallow to medium depth technical conversations.
14:24:46 <Heffalump> It's hard for really deep stuff.
14:24:51 <SamB_XP> in conversations, though, you have this thing where you can only have one person talk at a time...
14:24:58 <byorgey> Heffalump: no, notElem is (not .) . elem
14:25:28 <vincenz> byorgey: he probably meant that, but shortcutted ;)
14:25:34 <Heffalump> err yes, that
14:26:26 <idnar> vincenz: actually, I'd say IRC decreases that problem
14:26:28 <byorgey> my point is, perhaps that's why notElem is given in the Prelude... so the poor n00bies won't be confused when they try defining it themselves as not . elem =)
14:26:36 <Heffalump> heh
14:26:38 <idnar> vincenz: in real life, I don't want to pause in silence for 15 seconds, because it's awkward
14:27:01 <glguy> notElem is good and allows for clean: (x `notElem`)
14:27:01 <idnar> vincenz: on IRC, I don't have a problem doing that when I want to (I just sometimes start typing before my brain has finished thinking :P)
14:27:06 <monochrom> Natural languages are also poor media.
14:27:10 <vincenz> idnar: exactly, so you concentrate your talks to well-defined time intervals and talk about meaningful things, insteado f lurking for ages and ages, and then randomly reacting to something that catches your intrest
14:27:14 <conal> i've been pondering an IRC extension.  let people anonymously annotate their reactions to parts of statements.  like annoyed, confused, amused, ....  have the annotations immediately visible to all.  i bet we'd all learn something about effective communication.
14:27:25 <SamB_XP> monochrom: artificial languages aren't much better when you are confused
14:27:29 <Tene> Interesting.
14:27:35 <glguy> rather than: (not . (x `elem`)) -- which is uglier
14:27:45 <glguy> and notElem is common enough to justify not being ugly
14:27:52 <idnar> vincenz: well, I find I have more meaningful conversation on IRC, because I have more time to frame good responses and so on
14:27:56 <vincenz> glguy: (not . elem x)
14:28:38 <vincenz> heh
14:28:40 <vincenz> perfect point in case
14:28:50 <conal> i'm guessing that vincenz's groan is about name-space noise, giving names to things that are easily & transparently expressed.
14:28:54 <vincenz> I make an offhand remark about the usefulness about IRC, seeing how I'm tired and feeling silly, and we get a whole debate ;)
14:28:56 <conal> that's my reaction to such things.
14:29:11 <vincenz> conal: indeed
14:29:14 <conal> vincenz: i liked your remark.
14:29:26 <idnar> vincenz: heh
14:29:27 <vincenz> the drive in the prelude has always been to clean pure combinators
14:29:29 * Tene mentions lojban, just to observe the reactions.
14:29:33 <conal> (about irc, i mean.  but also about notElem)
14:29:38 <vincenz> notElem is a glaring exceptin
14:29:45 <vincenz> conal: thanks :)
14:29:46 <idnar> Tene: la la la can't hear you
14:29:54 <conal> there's concatMap
14:30:06 <vincenz> conal: touche
14:30:22 <glguy> looks like its time to get rid of /=
14:30:24 <glguy> we already have == and not
14:30:38 <Tene> idnar: should I type louder? ;)
14:30:39 <glguy> infact, Factor only has = and not
14:31:02 <monochrom> How to express /= using == and not?
14:31:03 <faxathisia> define not in terms of == and /=
14:31:06 <vincenz> glguy: well besides just redundancy '_not_Elem' and _not_ . elem
14:31:10 <Pseudonym> @src Eq
14:31:10 <lambdabot_> class  Eq a  where
14:31:10 <lambdabot_>     (==), (/=)   :: a -> a -> Bool
14:31:14 <conal> glguy: there's mental pollution.  we already have /= in our heads.  by why add new things like notElem
14:31:17 <Pseudonym> Hmm, the default instance isn't shown.
14:31:25 <Pseudonym> @src (/=)
14:31:25 <lambdabot_> x /= y = not (x == y)
14:31:28 <Pseudonym> That's it.
14:31:40 <glguy> any and all?
14:31:44 <glguy> lets get rid of one
14:31:51 <vincenz> glguy: notElem is far less used, than those others
14:31:56 <glguy> vincenz: by you
14:32:00 <conal> :)
14:32:23 <Pseudonym> ?pl \x xs -> not (elem x xs)
14:32:23 <lambdabot_> (not .) . elem
14:32:29 <vincenz> ok ok, this is far more subjective than one would've imagined :)
14:32:41 * vincenz keeps it to groaning
14:33:09 <idnar> @type any
14:33:10 <lambdabot_> forall a. (a -> Bool) -> [a] -> Bool
14:33:31 * vincenz wonders if you can express bracket as swing
14:33:34 <Pseudonym> not `o` elem
14:34:01 <idnar> @pl \f xs -> not (any (\x -> not (f x)) xs)
14:34:02 <lambdabot_> (not .) . any . (not .)
14:34:27 <conal> is there a notNull?
14:34:51 <Botje> notNull = not . null
14:35:11 <conal> i mean in the standard lib?
14:35:28 <vincenz> @src notNull
14:35:29 <lambdabot_> Source not found. And you call yourself a Rocket Scientist!
14:35:29 <conal> or notIsDigit, etc.
14:35:42 <vincenz> notNothing :)
14:35:46 <conal> notElem is such a strange exception
14:35:58 <vincenz> conal: yeah, but I can't quantify why, it just feels odd
14:36:40 <conal> vincenz: i think there's a clue in the name "notElem".  it's shorthand for the definition
14:36:42 <Pseudonym> notElem is, though, a standard mathematical operator.
14:36:55 <vincenz> conal: good point
14:36:56 <glguy> are there valid cases where: (/=) is different from \ x y -> not (x == y)
14:36:56 <glguy> ?
14:37:03 <conal> Pseudonym: good point
14:37:04 <dibblego> geez, sorry for hoogling!
14:37:07 <Pseudonym> glguy: That came up on haskell-cafe recently.
14:37:19 <TSC> glguy: With floats and NaN, maybe?
14:37:21 <vincenz> @type 1
14:37:21 <Pseudonym> The only thing I can think of is that (/=) might be more efficient or more lazy.
14:37:23 <lambdabot_> forall t. (Num t) => t
14:37:42 <conal> i think Pseudonym's point is that we mathy folks already have notElem in our heads.
14:37:45 <vincenz> @type \g f a -> (f a) g (flip f a)
14:37:45 <Pseudonym> TSC: Nope.  Nan /= Nan is True.
14:37:46 <lambdabot_>     Occurs check: cannot construct the infinite type: t = a -> t -> t1
14:37:46 <lambdabot_>     Probable cause: `flip' is applied to too few arguments
14:37:50 <vincenz> @type \g f a -> (f a) `g` (flip f a)
14:37:50 <Pseudonym> Yes.
14:37:51 <lambdabot_> forall a c t. ((a -> c) -> (a -> c) -> t) -> (a -> a -> c) -> a -> t
14:37:55 <faxathisia> notElem in maths?
14:38:03 <Pseudonym> Some algorithms are already specified in terms of notElem.
14:38:16 <vincenz> @type \h g f a -> (f a) g (h f a)
14:38:18 <lambdabot_> forall t t1 t2 t3. ((t -> t1 -> t2 -> t3) -> t -> t2) -> t1 -> (t -> t1 -> t2 -> t3) -> t -> t3
14:38:20 <TSC> faxathisia: Yeah, ∉
14:38:21 <vincenz> @type \h g f a -> (f a) `g` (h f a)
14:38:23 <lambdabot_> forall t t1 t2 t3. ((t -> t1) -> t -> t2) -> (t1 -> t2 -> t3) -> (t -> t1) -> t -> t3
14:38:30 <faxathisia> I find that really strange
14:38:34 <vincenz> hmm
14:38:37 <faxathisia> []'s are not the same as sets
14:38:38 <Pseudonym> Or, ratehr, \not\in
14:38:43 <vincenz> > 1
14:38:57 <Pseudonym> faxathisia: No, but they're often used as lightweight sets.
14:39:01 <Pseudonym> For when sets are small.
14:39:14 <Pseudonym> :t union
14:39:15 <conal> and there's list comprehension syntax.
14:39:15 <lambdabot_> forall a. (Eq a) => [a] -> [a] -> [a]
14:39:17 <vincenz> > (\h g f a -> (f a) `g` (h f a)) flip (.) (++) [0] [1..5]
14:39:21 <Pseudonym> :t intersection
14:39:22 <lambdabot_> Not in scope: `intersection'
14:39:26 <Pseudonym> Hmm.
14:39:29 <TSC> :t intersect
14:39:30 <lambdabot_> forall a. (Eq a) => [a] -> [a] -> [a]
14:39:32 <Pseudonym> Right.
14:39:33 <Pseudonym> etc
14:39:34 <conal> :t intersect
14:39:36 <lambdabot_> forall a. (Eq a) => [a] -> [a] -> [a]
14:39:39 <conal> oh
14:39:48 <vincenz> conal: trying to see if bracket generalizes but apparently not
14:40:19 <Pseudonym> And, of course:
14:40:21 <Pseudonym> :t nub
14:40:22 <lambdabot_> forall a. (Eq a) => [a] -> [a]
14:40:23 <conal> vincenz: from lists?
14:40:30 <vincenz> conal: yes
14:40:34 <vincenz> well from lists it already does
14:40:45 <vincenz> bracket f a = (a `f`) . (`f` a)
14:40:51 <vincenz> but by removing the (.) and the flip
14:40:54 <vincenz> and generalizing those
14:40:54 <huamn> is there some standard unique function for lists?
14:41:12 <vincenz> bracket f a = (.) (f a) (flip f a)
14:41:12 <vincenz> bracket' g f a = (.) (f a) (g f a)
14:41:12 <vincenz> bracket'' h g f a = h (f a) (g f a)
14:41:22 <Pseudonym> :T BRACKET
14:41:22 <faxathisia> huamn: What do you mean?
14:41:24 <Pseudonym> :t bracket
14:41:24 <TSC> huamn: Do you mean nub?
14:41:25 <lambdabot_> Not in scope: `bracket'
14:41:27 <vincenz> maybe I oughta just make it (g a)
14:41:31 <conal> vincenz: you can get (.) from Arrow.  and flip from DeepArrow.
14:41:35 <Japsu> @index bracket
14:41:35 <lambdabot_> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
14:41:38 <huamn> I want only elemts that are not equal to any other element
14:41:42 <faxathisia> huamn: nub
14:41:43 <vincenz> bracket is a new combinator
14:41:46 <Pseudonym> :t Control.Exception.bracket
14:41:48 <lambdabot_> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:41:48 <huamn> ok, thanks
14:41:51 <Pseudonym> I already use that.
14:41:51 <vincenz> Pseudonym: not that one
14:42:05 <andyjgill> @seen grahamhutton
14:42:06 <lambdabot_> I saw grahamhutton leaving #haskell 54m 1s ago, and .
14:42:07 <vincenz> bracket f a = (a `f`) . (`f` a)
14:42:09 <TSC> huamn: And nubBy, if you want to redefine equality
14:42:10 <vincenz> e.g
14:42:16 <vincenz> braceket (++) [x]
14:42:27 <vincenz> conal: I wonder if the order matters
14:42:36 <Pseudonym> @let brackt f a = (a `f`) . (`f` a)
14:42:37 <lambdabot_> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:42:39 <faxathisia> > let bracket f a = (a `f`) . (`f` a) in bracket (++) ["||"] "testing"
14:42:39 <lambdabot_>  Couldn't match expected type `[Char]' against inferred type `Char'
14:42:46 <conal> vincenz: do you mean generalize beyond functions?
14:42:48 <vincenz> (a `f`) . (`f` a) vs (`f` a) . (a `f`)
14:42:57 <vincenz> conal: no generalize away from the use of flip and .
14:42:58 <Pseudonym> @let bra f a = (a `f`)
14:42:59 <lambdabot_> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:43:05 <Pseudonym> @let ket f a = (`f` a)
14:43:06 <lambdabot_> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:43:06 <shapr> @quote
14:43:07 <lambdabot_> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
14:43:10 <shapr> hah
14:43:13 <vincenz> conal: see if it becomes something like swing or on
14:43:17 <conal> vincenz: oh -- but not to generalizes *of* flip & . ?
14:43:26 <conal> vincenz: swing?
14:43:27 <hpaste>  glguy pasted "type synonyms?" at http://hpaste.org/4099
14:43:37 <vincenz> conal: a combinator Cale came up a while ago, but I forgot it's exact definition
14:43:37 <glguy> am I doing something wrong here in my MonadState class?
14:44:02 <vincenz> conal: basically see if I can define bracket in terms of swing and on
14:44:11 <vincenz> conal: so my first step was taking out the flip and the . and passing them in
14:44:16 <conal> (retry): vincenz: oh -- but not to generalizations *of* flip & . ?
14:44:27 <vincenz> bracket flip f a = (f a) . (flip f a)
14:44:35 <vincenz> bracket dot flip f a = dot (f a) (flip f a)
14:45:00 <conal> vincenz: i get it now
14:45:06 <vincenz> it's almost like an on, except that you're flipping your second g
14:45:28 <conal> i see
14:45:38 <Japsu> http://en.wikipedia.org/wiki/Bra-ket_notation
14:45:38 <lambdabot_> Title: Bra-ket notation - Wikipedia, the free encyclopedia
14:45:40 <Japsu> ;)
14:45:42 <conal> of course one could generalize on a bit
14:45:42 <vincenz> and using the same x, instead of x and y
14:45:49 <conal> to take g & g'
14:45:55 <conal> then specialize to on and to bracket
14:45:57 <vincenz> ooh
14:46:10 <faxathisia> > let bracket f a = (a `f`) . (`f` a) in bracket (++) "||" "bah"
14:46:14 <vincenz> on f g g' x y = (g x y) `f` (g' x y)
14:46:26 <faxathisia> (*) `on` f = \x y -> f x * f y
14:46:27 <vincenz> that will unify with the bracket!
14:46:29 <faxathisia> I like this style
14:46:33 * vincenz cods
14:46:42 <Saizan> glguy: what's the error?
14:46:53 * conal wonders if vincenz is a codfish
14:47:00 <Japsu> where's lambdabot's response to  00:46   faxathisia : > let bracket f a = (a `f`) . (`f` a) in bracket (++) "||" "bah"
14:47:01 <hpaste>  (anonymous) annotated "type synonyms?" with "error" at http://hpaste.org/4099#a1
14:47:15 <conal> like jas hook
14:47:32 * shapr hugs ddarius 
14:47:34 <glguy> Saizan: State (StateT Int Id) isn't simplifying
14:47:38 <shapr> jas love!
14:47:56 <conal> shapr: ??
14:48:16 <Pseudonym> glguy: Why should it simplify?
14:48:17 <shapr> That was a rastafarian joke :-)
14:48:26 <conal> oh
14:48:36 <glguy> Pseudonym: it should know that that is an Int and how to show them?
14:48:40 <shapr> "Jah love" is commonly said in reggae songs.
14:48:53 <Pseudonym> How can you show a StateT?
14:48:57 <vincenz> @type \f a -> (f a) . (flip f a)
14:48:58 <lambdabot_> forall c. (c -> c -> c) -> c -> c -> c
14:49:00 <glguy> I'm not trying to
14:49:41 <vincenz> @type \f a -> let on' f g g' x y = f (g x y) (g x y) in on' ($) f (flip f) a
14:49:43 <lambdabot_>     Occurs check: cannot construct the infinite type: a = a -> b
14:49:43 <lambdabot_>       Expected type: (a -> b) -> (a -> b) -> t
14:49:57 <vincenz> @type \f a -> let on' f g g' x y = f (g x y) (g' x y) in on' ($) f (flip f) a
14:49:59 <lambdabot_>     Occurs check: cannot construct the infinite type: a = a -> b
14:49:59 <lambdabot_>     Probable cause: `flip' is applied to too few arguments
14:50:03 * vincenz goes to pm
14:50:17 <Cale> swing f = flip (f . flip ($))
14:50:28 <Pseudonym> :t \f -> flip (f . flip ($))
14:50:29 <lambdabot_> forall a b b1 c. (((a -> b) -> b) -> b1 -> c) -> b1 -> a -> c
14:50:31 <Cale> @unpl swing f = flip (f . flip ($))
14:50:31 <lambdabot_> swing f b c = f (\ g -> g c) b
14:51:00 <Cale> @let swing f b c = f (\ g -> g c) b
14:51:01 <lambdabot_> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:51:09 <Cale> hmm
14:51:29 <Saizan> glguy: are you testing from ghci? compiling it seems to work
14:51:56 <vincenz> @type \f a -> let on' f g g' x y = f (g x y) (g' x y) in on' (.) (const f) (const . flip $ f) () a
14:51:58 <lambdabot_> forall c. (c -> c -> c) -> c -> c -> c
14:52:00 <vincenz> \o/
14:52:05 <vincenz> nasty tho :(
14:52:10 <glguy> Saizan: it requires additional type declarations
14:52:18 <glguy> Saizan: once I added them it figure dit out
14:52:27 <ddarius> lambdabot_ ?
14:52:51 <faxathisia> :t \f a -> (const f) (const . flip $ f) () a
14:52:53 <lambdabot_> forall b c. (() -> b -> c) -> b -> c
14:52:59 <Pseudonym> So how is swing used?
14:53:04 <hpaste>  vincenz pasted "combinators :(" at http://hpaste.org/4100
14:53:13 <vincenz> whoops, that should be (.) not ($)
14:53:20 <sciolizer> ddarius: regular lambdabot ceased functioning, so I popped mine up, but it seems to be breaking as well. Do you have a copy?
14:53:27 <hpaste>  (anonymous) annotated "combinators :(" with "(no title)" at http://hpaste.org/4100#a1
14:54:06 <SamB_XP> sciolizer: can you salvage the quotes that got added, btw?
14:54:09 <Pseudonym> And I'm still not convinced of the usefulness of "bracket".
14:54:43 <ddarius> sciolizer: I haven't built (or tried to build) a fully functional lambdabot in say four years.
14:54:50 <hpaste>  vincenz annotated "combinators :(" with "fixes" at http://hpaste.org/4100#a2
14:54:55 <vincenz> Pseudonym:
14:55:00 <vincenz> bracket (++) [1]
14:55:06 <Pseudonym> Yes...
14:55:16 <sciolizer> SamB_XP: no idea. Is there an easy way to do that? I suppose the IRC logs could just be scanned when dons gets his back up.
14:55:18 <vincenz> it was originally called outersperse
14:55:23 <pitecus> Im getting this error whe compiling with ghc: ld: cannot find -lmaxent. How do I specify where to look for libraries?
14:55:35 <Pseudonym> I see that bracket (++) might be handy sometimes.
14:55:39 <Pseudonym> But in general?
14:55:53 <ddarius> :t bracket
14:55:54 <lambdabot_> Not in scope: `bracket'
14:56:10 <SamB_XP> sciolizer: -blah isn't logged, though...
14:56:12 <Pseudonym> And I maintain that clashing with Control.Exception.bracket is bad.
14:56:17 <vincenz> Pseudonym: valid points
14:56:43 <sciolizer> SamB_XP: blah?
14:56:46 <Pseudonym> Perhaps a "bracket"-alike should actually be associated with Monoid?
14:57:10 <Pseudonym> Is it useful outside of Monoid?
14:58:12 * mux wonders how he managed to get gosper's algorithm for arithmetic on continued fractions wrong so that addition seems to work just fine, but multiplication gives different results for x * y and y * x, both false
14:58:55 <faxathisia> mux: What are you doing with gosper's algorithm?
14:58:59 <vincenz> Pseudonym: it seems rather monoidal from the typesig, given the (c->c->c) bit
14:59:13 <ddarius> sciolizer: Better not to ask.
14:59:30 <mux> faxathisia: implement a Num instance for continued fractions (and Floating)
14:59:37 <faxathisia> mux: cool :D
14:59:49 <mux> I think this lends itself to haskell very well
14:59:54 <mux> lazy infinite lists etc
15:00:05 <faxathisia> mux: do you know any way to produce an infinite list of digits from a continued fraction?
15:00:37 <mux> faxathisia: yes, gosper gives specific coefficients to achieve that, but I didn't try it yet
15:01:23 <vincenz> a bit OT: anyone know a good standalone runtime for JS?
15:01:33 <mux> z can produce its value as decimal digits by multiplying by 10 instead of reciprocating, after outputting t = [z]:
15:01:36 <mux> z'(x,y) = (10(a-te) 10(b-tf) 10(c-tg) 10(d-th)) / (e  f  g  h).
15:02:30 <Pseudonym> mux: http://ofb.net/~wnoise/haskell/math/
15:02:31 <lambdabot_> Title: Index of /~wnoise/haskell/math
15:02:31 <Pseudonym> FWIW
15:02:40 <Pseudonym> Some kind person preserved my code.
15:02:58 <sciolizer> SamB_XP: there's a State/Log folder in lambdabot which keeps logs of all of the channels, including #Haskell-blah (if that's what you meant).
15:03:24 <SamB_XP> sciolizer: true
15:03:35 <SamB_XP> sciolizer: I meant, there are no public logs of -blah
15:03:54 <SamB_XP> which considering some of the stuff people talk about there is a VERY GOOD THING
15:04:05 <mux> Pseudonym: heh nice
15:04:20 <mux> Pseudonym: I did it the matrix way to shorten the algorithm
15:04:24 <mux> only it doesn't work :D
15:04:25 * Pseudonym nods
15:04:38 <mux> Pseudonym: what do you get for [0,2] * [0,3], out of curiosity?
15:04:59 <mux> [0,6] right?
15:05:09 <Pseudonym> Dunno, I haven't run it in ages.
15:05:11 <Pseudonym> Let me check.
15:05:15 <mux> thank you
15:05:42 <Pseudonym> *ContFrac> ContFrac [0,2] * ContFrac [0,3]
15:05:42 <Pseudonym> ContFrac [0,6]
15:05:50 <mux> heh, as expected
15:06:02 <mux> well you gave me a solid ground for comparing & testing
15:06:20 <mux> it would be nice to cabalize that thing, because there are very nice things to do with it
15:06:50 <mux> gosper suggests composing forms to reduce the number of operations needed for computation
15:06:56 <mux> I think we can do this with GHC RULES
15:07:11 <conal> GHC rules, indeed!
15:07:23 <mux> oh yeah
15:08:57 * mux bbl &
15:12:03 <vincenz> Haha, reading a presentation on JS a
15:12:12 <vincenz> "The High-Performance JS Mantra"
15:12:14 <vincenz>  - Be Lazy
15:12:55 <monochrom> If they add "- Be Immutable" I'll be more thrilled.
15:12:55 <dibblego> is there a function like approximatelyEqualto :: Double -> Double -> Bool ?
15:13:01 <ddarius> vincenz: link?
15:13:13 <vincenz> http://www.slideshare.net/pureclone/highperformance-javascript
15:13:13 <lambdabot_> Title: High-Performance JavaScript  SlideShare
15:13:25 <vincenz> slide 11/48
15:14:46 <vincenz> "Use closures to chain state together with periodic pauses"
15:16:17 <hpaste>  conal pasted "approxEq" at http://hpaste.org/4101
15:16:41 <Pseudonym> @let approxEq a b = False  -- Conservative approximation
15:16:42 <vincenz> conal: I disagree
15:16:42 <lambdabot_> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
15:16:48 <faxathisia> lol
15:17:01 <vincenz> conal: if you want to use a distance, be equally distant wherever
15:17:14 <dibblego> conal, thanks
15:17:33 <dibblego> vincenz, you disagree with conal's code?
15:17:40 <vincenz> I disagree with the different signs case
15:17:45 <Pseudonym> Yeah, me too.
15:17:52 <vincenz> suddenly your eps becomes much smaller
15:17:57 <Pseudonym> 1e-200 `approxEq` -1e-200
15:18:29 <conal> i don't think min diff is workable for large numbers.
15:18:31 <Pseudonym> The epsilon should be based on the machine epsilon for that type, and denormalised numbers should be handled correctly.
15:18:53 <monochrom> You see, there is no one single "approximately equal" fitting all applications.
15:19:06 <Pseudonym> Or all floating-point types.
15:19:19 <monochrom> <horror>You should therefore make it a type class method instead! </horror>
15:20:05 <monochrom> Everyone should newtype his/her Double and write his/her application specific method.
15:20:12 <conal> mine was a q&d for some QC testing.  i offer it as a starting point.  please improve!
15:20:26 <dibblego> conal, I need it for QC testing too :)
15:20:35 <monochrom> Then everyone's code will look the same except with slightly different semantics hidden behind the method.
15:20:44 <conal> dibblego: oh!  give it a try :)
15:21:11 <dibblego> ScalaCheck testing actually (let's be honest) :)
15:21:42 <monochrom> Everyone's "approximately equal" is approximately equal. Some are more approximately equal than others.
15:21:56 <dibblego> @remember <monochrom> Everyone's "approximately equal" is approximately equal. Some are more approximately equal than others.
15:21:56 <lambdabot_> Done.
15:22:05 <conal> dibblego: are you using Scala so your programs can run in web browsers?
15:22:29 <dibblego> conal, no, because Haskell is "too hard"; making progress though
15:22:39 <conal> lol
15:22:49 <dibblego> conal, i.e. "better than Java" is my success story :)
15:23:10 <conal> dibblego: not much of a goal.  work up from there, okay?   ;)
15:23:21 <faxathisia> approximatelyEqual x y = abs (x - y)
15:23:29 <vincenz> faxathisia: hah
15:23:31 <vincenz> you mean
15:23:39 <vincenz> hmm
15:23:40 <vincenz> nm
15:23:42 * vincenz hides
15:23:44 <liyang> monochrom: John Major had something along those lines.
15:23:45 <dibblego> conal, I ran a Scala course a few weeks ago and I stressed the importance of learning Haskell - for one person it has succeeded
15:23:51 <Pseudonym> faxthisia: Doesn't work either.
15:24:08 <vincenz> abs (x - y) / max(abs x, abs y) < eps
15:24:12 <monochrom> John Major, the previous PM? He was interested in approximations too?
15:24:13 <dibblego> conal, in fact, I used Haskell notation in my slides, so it would fit :)
15:25:01 <conal> vincenz: oh -- i like the look of that one.
15:25:45 <vincenz> conal: it's not numerically stable for large x's and y's close together
15:25:55 <vincenz> or is it
15:26:16 <conal> way outside my expertise
15:26:19 * vincenz tries to remember
15:26:29 <vincenz> I think it's only an issue when you divide by (x -y ) when they're big and close
15:28:38 <dmwit> It should be.
15:28:55 <dmwit> s/./ fine./
15:29:55 <KSSKSIK> Hi!  What can be used instead of read to String -> Int or String -> Integer?
15:30:13 <KSSKSIK> read is somewhat slow
15:30:44 <EvilTerran> ?hoogle readInt
15:30:45 <lambdabot_> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:30:45 <lambdabot_> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:30:45 <lambdabot_> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
15:31:55 <dmwit> I wonder if these ?remembers will stay across the \bot_ -> \bot transition.
15:32:27 <LoganCapaldo> readInt 0 isDigit (\x -> ord x - ord '0') ????
15:33:04 <hpaste>  Toxaris pasted "notElem == not . elem" at http://hpaste.org/4102
15:33:06 <dmwit> let ???? = "" in ...
15:33:14 <LoganCapaldo> lol
15:33:15 <LoganCapaldo> no
15:33:21 <LoganCapaldo> I know what ReadS is
15:33:25 <dmwit> ok
15:33:35 <LoganCapaldo> I was asking if that was a typically invocation of that function
15:33:42 <LoganCapaldo> *typical
15:34:33 <dmwit> ?hoogle readDec
15:34:33 <lambdabot_> Numeric.readDec :: Integral a => ReadS a
15:34:33 <lambdabot_> Numeric.readDec :: Num a => ReadS a
15:34:33 <lambdabot_> Text.Read.Lex.readDecP :: Num a => ReadP a
15:34:45 <dmwit> I think readOct/Dec/Hex are the usual invocations.
15:35:52 <LoganCapaldo> Hmm I bet it should proabbly be readInt <base> not readInt 0 now that I've thought about it
15:35:58 <LoganCapaldo> @src readInt
15:35:58 <lambdabot_> Source not found. stty: unknown mode: doofus
15:36:10 <LoganCapaldo> lambdabot_: meanie
15:36:23 <LoganCapaldo> @src readDec
15:36:23 <lambdabot_> Source not found. This mission is too important for me to allow you to jeopardize it.
15:36:28 <dmwit> ?index readInt
15:36:28 <lambdabot_> Numeric
15:36:32 <dmwit> ?source Numeric
15:36:32 <lambdabot_> http://darcs.haskell.org/packages/base/Numeric.hs
15:37:10 <dmwit> Yeah, the base.
15:37:48 <dmwit> ?source Text.ParserCombinators.ReadP
15:37:48 <lambdabot_> http://darcs.haskell.org/packages/base/Text/ParserCombinators/ReadP.hs
15:47:07 <vincenz> augustss: ping
15:53:54 <sciolizer> @when dons
15:53:54 <lambdabot_> Maybe you meant: seen what where wn
15:54:00 <sciolizer> @where dons
15:54:00 <lambdabot_> http://www.cse.unsw.edu.au/~dons
15:54:06 <sciolizer> @seen dons
15:54:06 <lambdabot_> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 49m 39s ago.
15:54:06 <gwern> phooey. shellac is teh broken :(
15:57:26 <sciolizer> @tell dons lambdabot seems to be broken. I put up lambdabot_ in the mean time. See http://sciolizer.com:8083/State/ for karma, quotes, logs, etc. E-mail me if port 8083 is down and you still want it. I assume you can shutdown lambdabot_ since you're an admin.
15:57:26 <lambdabot_> Consider it noted.
15:57:49 <sciolizer> @tell dons sciolizer@gmail.com
15:57:49 <lambdabot_> Consider it noted.
15:58:37 <dons> sciolizer: ?
15:58:37 <lambdabot_> dons: You have 2 new messages. '/msg lambdabot_ @messages' to read them.
15:58:43 <monochrom> hehe
15:58:46 <sciolizer> oh good :)
15:59:04 <monochrom> dons brings us dawns :)
15:59:19 <dons> how is the bot broken?
15:59:21 <dons> ?bot
15:59:21 <lambdabot_> :)
15:59:27 <dons> ?quote haskell
15:59:28 <lambdabot_> HavocPennington says: Haskell is the least-broken programming language available today.
15:59:33 <monochrom> (trivia: every word in that sentence ends with s :) )
16:00:22 <sciolizer> @bot
16:00:51 <sciolizer> dons: lambdabot is online but appears to be unresponsive
16:01:47 <exDM69> maybe he's sleeping?
16:01:52 <sciolizer> @wake
16:02:42 <Lemmih> Perhaps we should rewrite lambdabot in some high level language so it doesn't crash this often.
16:02:49 <monochrom> haha
16:02:56 <conal> good one
16:03:28 <conal> @remember <Lemmih> Perhaps we should rewrite lambdabot in some high level language so it doesn't crash this often.
16:03:43 <conal> doh!
16:03:58 * Lemmih grins.
16:04:04 <Pseudonym> Lambdabot doesn't crash, though.
16:04:06 <Pseudonym> She hangs.
16:04:11 <Pseudonym> Totally not the same thing.
16:04:15 <LoganCapaldo> indeed
16:04:19 <mux> LB just doesn't reconnect
16:04:39 <LoganCapaldo> we just need to rewrite lambdabot in a language in which programs are guaranteed to terminate
16:05:14 <Pseudonym> ESFP
16:05:16 <Pseudonym> Clearly.
16:05:36 <cjay> well.. just patch ghc to kill every program after 20 years runtime
16:06:08 <gwern> wouldn't only using total functions and avoiding primitive recursion guarantee termination or something?
16:06:17 <Pseudonym> http://www.cs.kent.ac.uk/pubs/1999/990/index.html
16:06:30 <Pseudonym> Except that's not a link.
16:06:35 <Pseudonym> http://www.jucs.org/jucs_6_4/ensuring_termination_in_esfp
16:06:36 <Pseudonym> That's it.
16:07:30 <sciolizer> must be hard to write an interpreter
16:07:56 <SamB_XP> eh?
16:07:59 <SamB_XP> hard, you say?
16:08:26 <Pseudonym> "Hard" sounds like a job for Haskell!
16:08:26 <faxathisia> sciolizer: For what?
16:08:31 <Pseudonym> At least until it's bootstrapped.
16:08:50 <sciolizer> faxathisia: well, Turing complete languages, for one. :)
16:08:58 <SamB_XP> sciolizer: eh?
16:09:02 <SamB_XP> I don't see your point
16:09:13 <faxathisia> sciolizer: various turing complete languages are easy to write interpreters for
16:09:21 <gwern> sciolizer: I've heard comonads have something to do with interpreters
16:09:37 <ski> @quote comonad
16:09:37 <lambdabot_> adept says: Tried to co-read and co-understand comonads, but got co-re dump
16:09:48 <sciolizer> I mean it must be hard to write a Turing complete language interpreter in a total language like ESFP.
16:09:57 <SamB_XP> OH
16:10:05 <SamB_XP> yes ;-)
16:10:08 <Pseudonym> Yeah.
16:10:11 <SamB_XP> I guess it must
16:10:17 <faxathisia> well you could write a procedure that does 1 iteration of a game of life for example
16:10:19 <faxathisia> quite easily
16:10:34 <sciolizer> true
16:10:55 <Pseudonym> Or, for that matter, one lambda calculus reduction step.
16:11:11 <Philippa> gwern: primitive recursion is safe, it's general recursion that's the worry
16:11:25 <faxathisia> Where does 'bootstrapped' come from?
16:11:42 <sciolizer> Looking at the ESFP abstract though, it looks like you CAN have infinite data structures / computations, just so long as you have guaranteed production.
16:11:47 <ski> faxathisia : http://en.wikipedia.org/wiki/Bootstrap
16:11:48 <lambdabot_> Title: Bootstrapping - Wikipedia, the free encyclopedia
16:12:12 <gwern> nooo <http://community.haskell.org/admin/account_request.html> failed on me again. who do I talk to about this?
16:12:21 <Pseudonym> I wonder if you could write an ESFP interpreter in ESFP.
16:12:31 <faxathisia> ski: ahh thanks :D
16:14:38 <faxathisia> That's impressive
16:14:47 <faxathisia> The analysis of the gcd code (termination proof) is done automatically isnt' it
16:15:54 <monochrom> The computer knows too much.
16:16:18 <Philippa> The computer is perfect, citizen
16:21:43 <dibblego> ?src logBase
16:21:43 <lambdabot_> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:21:46 <dibblego> ?src log
16:21:46 <lambdabot_> Source not found. Wrong!  You cheating scum!
16:22:48 <EvilTerran> is this really bad practice? everyMatch parser text = [match | Right match <- map (parse parser "") (tails text)]
16:24:34 <dons> ?bot
16:24:34 <lambdabot_> :)
16:24:38 <dons> ah
16:29:50 <sjanssen> @botsnack
16:29:50 <lambdabot> :)
16:29:50 <lambdabot_> :)
16:29:58 <sjanssen> lambdabot_: @part #haskell
16:31:00 <sjanssen> dons can decide whether lambdabot_ should @quit
16:31:34 <dmwit> ?users
16:31:34 <lambdabot> Maximum users seen in #haskell: 401, currently: 384 (95.8%), active: 7 (1.8%)
16:39:37 <dmwit> > unlines . lines $ "ab\n\ncd"
16:39:45 <lambdabot>  "ab\n\ncd\n"
16:41:40 <idnar> > lines "ab\rcd"
16:41:54 <lambdabot>  ["ab\rcd"]
16:41:59 <idnar> > lines "ab\r\ncd"
16:42:01 <lambdabot>  ["ab\r","cd"]
16:43:10 <mrd> ?check (\ s -> unlines (lines s) == s)
16:43:12 <lambdabot>  Falsifiable, after 1 tests: "\1001464"
16:43:19 * mrd cackles
16:43:21 <dons> hmm, should we get strict Chans added to base?
16:43:27 <dons> anyone have thoughts on this?
16:43:32 <mrd> strict Chans?
16:43:56 <mrd> isn't the point of Chans to act like a stream?
16:43:57 <dons> i suspect, as a parallel structuring mechanism, lazy Chans are quite dangerous -- its hard to ensure work is done on the right side of the Chan
16:44:03 <dons> mrd: element-strict
16:44:08 <mrd> hmm
16:44:08 <dmwit> ?check (\s -> last s /= '\n' || unlines (lines s) == s)
16:44:09 <lambdabot>  Exception: Prelude.last: empty list
16:44:21 <mrd> that could explain some mysteries.  thinking of that mailing list msg recently?
16:44:29 <dons> i've a nice example of naive Chan use that only works with element-strict Chans
16:44:34 <dcoutts> dons: I expect those Control.Concurrent modules will get pulled out into a separate package in ghc 6.10
16:44:36 <dons> without which only 1 core is used: for the main thread
16:44:38 <dmwit> ?check (\s -> take 1 (reverse s) /= "\n" || unlines (lines s) == s)
16:44:50 <ddarius> dons: I don't think Chans were intended to be a parallel structuring mechanism.
16:44:53 <lambdabot>  thread killed
16:44:59 <dons> for strict chans, work is done properly in the 2 worker threads
16:45:02 <dons> and the result is twice as fast
16:45:11 <mrd> why not just tell people to use 'rnf'?
16:45:20 <dons> ddarius: well, they're widely used (by me) for gluing threads together with streams
16:45:40 <dons> mrd, maybe data structures should just work properly out of the box?
16:45:48 <mrd> they do work
16:46:03 <dcoutts> dons: similarly, eg see this job pool, without that evaluate it doesn't do much parallel evaluation
16:46:03 <dcoutts> http://haskell.org/~duncan/cabal/dep-experiment/JobPool.hs
16:46:03 <mrd> just not the side effects you wanted ;P
16:46:32 <dons> dcoutts: yep
16:46:49 <dons> and almost all uses of MVar should havre a $!
16:46:55 <dcoutts> dons: btw, this is quite a nice concurrency abstraction for the cases where it's enough
16:47:14 <dons> package it up :)
16:47:14 <dcoutts> dons: just launch :: m a -> m ()
16:47:21 <dcoutts> and collect :: m a
16:48:01 <dcoutts> dons: I'll see about extracting it from Cabal if we end up using it
16:48:26 <dcoutts> dons: it's nice because it allows serial implementations as well as parallel
16:48:38 <dcoutts> so good for cabal where we have to support hugs and nhc etc
16:48:46 <dons> yes, i think the concurrency package should move out.
16:48:52 <dcoutts> but want to be able to use implementations on forkIO for ghc
16:48:54 <dons> then it would be easier to work on
16:48:58 <dcoutts> yes
16:50:36 <dcoutts> dons: nice concurrency post btw
16:50:50 <dons> well,it can be improved with strict Chans
16:50:52 <dons> :)
16:50:58 <dcoutts> dons: I'm not sure we have enough intros to the concurrency libs
16:51:02 <dons> it got some attention at least
16:51:05 <dons> yeah
16:51:15 <glguy> unsafeDoggeh#
16:51:23 <dcoutts> dons: eg I only just figured out the other day how to use semaphores Sem and SemQ
16:51:57 <dons> heh. i haven't used them in years.
16:51:58 <dons> hmm
16:52:07 <dcoutts> I use one in that JobPool example to limit the number of concurrent jobs
16:52:23 <dcoutts> which is important for Cabal since most jobs will be running expensive external processes
16:52:33 <dons> yep
16:52:46 <dcoutts> like make -j3
16:53:04 <glguy> I think that SampleVar is one that gets the least exposure
16:53:19 <dcoutts> aye, it's also the one most recently added
16:53:59 <dcoutts> dons: but for those cases where you're trying to do parallel evaluation, shouldn't it be possible to use those Strategies things to get a nicer result?
16:54:07 <dcoutts> rather than using low level things like chans ?
16:54:17 <mrd> @hoogle rnf
16:54:17 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
16:54:18 <dons> yes, perhaps.
16:54:38 <dons> i've not looked at them much. maybe we can fix things module by module :)
16:54:39 <dcoutts> build a big lazy structure and apply a coarse parallel evaluation strategy
16:55:07 <LoganCapaldo> NFData a => Strategy a ?
16:55:09 <dcoutts> dons: it might be interesting to see if you can recast your example in that blog post in a pure way using Strategies
16:55:16 <LoganCapaldo> oh der
16:55:20 <LoganCapaldo> Strategy = tycon?
16:55:21 <dcoutts> dons: and if not, perhaps there's something wrong with the Strategy lib
16:55:41 <mrd> type Strategy a = a -> ()
16:56:08 <dcoutts> dons: there's too much to get wrong with stuff like MVar/Chans, though obviously they're the underlying mechanism
16:56:45 <dons> yes, that's a good idea.
16:56:59 <dons> we need a nice program, fairly short, interesting, and then rewrite it a few different ways
16:57:03 <dons> as a tut
16:57:06 <dcoutts> yes
16:57:09 <dons> someone should write a book chapter about this
16:57:12 <dcoutts> heh
16:57:14 <luqui> anyone with experience with the opengl bindings?  I can't find the analog of glColor3f anywhere!
16:57:43 <dcoutts> dons: as you've probably gathered, I'm a concurrency noob
16:57:55 <glguy> how does NFData relate to DeepSeq?
16:58:35 <dcoutts> glguy: deepSeq is one particular parallel evaluation strategy (which actually happens to be a serial evaluation strategy)
16:58:56 <dcoutts> so NFData is a more general system aimed at parallel evaluation
16:59:28 <dcoutts> DeepSeq is mainly aimed at being a hack to fix space leaks by strictifying structures
17:02:10 <EvilTerran> @src writeFile
17:02:10 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
17:02:13 <LoganCapaldo> @type uncurry $ flip (,)
17:02:15 <lambdabot> forall a b. (b, a) -> (a, b)
17:03:27 <glguy> so... parList rnf list_of_thunks   is similar to: rnf list_of_thunks?
17:06:15 <Cale> glguy: Except that it evaluates the elements in parallel rather than sequentially.
17:06:15 <mrd> luqui: er?
17:06:38 <LoganCapaldo> @type fst .uncurry . flip (,)
17:06:39 <lambdabot>     Couldn't match expected type `b -> c'
17:06:39 <lambdabot>            against inferred type `(a, a1)'
17:06:39 <lambdabot>     In the second argument of `(.)', namely `flip (,)'
17:06:49 <luqui> mrd, nevermind.  found it.   in the, uh, VertexSpec module...
17:06:56 <LoganCapaldo> @type fst . uncurry $ flip (,)
17:06:57 <lambdabot>     Couldn't match expected type `(a, b)'
17:06:57 <lambdabot>            against inferred type `(a1, b1) -> c'
17:06:57 <lambdabot>     In the second argument of `(.)', namely `uncurry'
17:06:59 <mrd> color i think
17:07:08 <LoganCapaldo> wait
17:07:17 <mrd> use the Color3 constructor
17:07:18 <LoganCapaldo> where her type error messages always so verbose?
17:07:22 <glguy> For the Strategies to have much effect, do you need to run multiple processes on multiple cores?
17:07:38 <LoganCapaldo> s/where/were/
17:08:08 <mrd> color (Color3 0 0 0 :: Color3 GLfloat)
17:09:19 <luqui> mrd, thanks, got it.  I was just confused since it wasn't in the Color module...
17:09:30 <luqui> I think I grok the module structure a bit more now too
17:09:41 <mrd> yea it's a little wacky
17:10:11 <mrd> type ambiguity might bite you, if it can't figure out what the type param should be from context.
17:11:44 <TomMD> @where osker
17:11:44 <lambdabot> I know nothing about osker.
17:13:50 <luqui> is there a quick conversion from double to float?
17:14:00 <luqui> fromRational . toRational seems like overkill
17:14:20 <faxathisia> :t fromRational . toRational
17:14:21 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
17:14:26 <faxathisia> @hoogle forall a a1. (Fractional a, Real a1) => a1 -> a
17:14:26 <lambdabot> Did you mean: forall a a1. (Fractional a, Real a1) => A1 -> a
17:14:26 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:14:26 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
17:14:34 <LoganCapaldo> read . show ?
17:14:34 <faxathisia> :|
17:14:49 * vincenz smacks LoganCapaldo 
17:14:57 <LoganCapaldo> ow!
17:14:58 <mauke> fromEnum . toEnum
17:15:10 * luqui smacks mauke!   :-)
17:15:12 <vincenz> @hoogle forall a a1. (Real a, Real a1) => a1 -> a
17:15:13 <lambdabot> Did you mean: forall a a1. (Real a, Real a1) => A1 -> a
17:15:13 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:15:13 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
17:15:18 <faxathisia> :t fromEnum . toEnum
17:15:19 <lambdabot>     Ambiguous type variable `b' in the constraint:
17:15:19 <lambdabot>       `Enum b' arising from use of `fromEnum' at <interactive>:1:0-7
17:15:19 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
17:15:34 <luqui> > fromEnum (toEnum pi)
17:15:34 <lambdabot>   add an instance declaration for (Floating Int)
17:15:45 <luqui> > fromEnum (toEnum 3.1415)
17:15:48 <lambdabot>   add an instance declaration for (Fractional Int)
17:15:53 <mauke> haha
17:16:06 <luqui> hmm... I could have sworn Float was an Enum.  I remember wondering why.
17:16:19 <mauke> > toEnum (fromEnum pi)
17:16:20 <lambdabot>  3
17:16:26 <luqui> oh right
17:16:29 <luqui> it is an enum..
17:16:33 <luqui> and my brain is backwards
17:16:47 <luqui> > toEnum (fromEnum pi) :: Float
17:16:47 <lambdabot>  3.0
17:16:50 <vincenz> o.O
17:16:55 <faxathisia> o_o
17:16:56 <vincenz> how can it be an enum
17:17:08 <EvilTerran> @src Float fromEnum
17:17:09 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:17:13 <luqui> it's just equivalent to Int, not all values are enumerated
17:17:19 <faxathisia> @instanced Enum
17:17:19 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
17:17:23 <wli> > [1.1, 1.2 .. 1.5]
17:17:24 <lambdabot>  [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996]
17:17:36 <EvilTerran> @check liftM2 (==) fromEnum floor
17:17:37 <lambdabot>  Add a type signature
17:17:42 <EvilTerran> @check liftM2 (==) fromEnum floor :: Float -> Bool
17:17:43 <lambdabot>  Falsifiable, after 2 tests: -2.3333333
17:17:48 <EvilTerran> @check liftM2 (==) fromEnum trunc :: Float -> Bool
17:17:48 <lambdabot>   Not in scope: `trunc'
17:18:00 <EvilTerran> @check liftM2 (==) fromEnum truncate :: Float -> Bool
17:18:00 <lambdabot>  OK, passed 500 tests.
17:18:08 <luqui> > enumFromThenTo 3.0 3.1 4.0
17:18:09 <lambdabot>  [3.0,3.1,3.2,3.3000000000000003,3.4000000000000004,3.5000000000000004,3.6000...
17:18:10 <wli> [1.1, 1.2 .. 1.5] is why it's an Enum.
17:18:34 <resiak> step four: find some non-terminating enumFromThenTo due to rounding errors!
17:18:52 <luqui> > enumFromThenTo 3.0 3.00000000000000001 4.0
17:18:52 <lambdabot>  [3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0...
17:19:21 <luqui> probably want one less trivial than that though
17:19:35 <EvilTerran> good thing haskell doesn't mind infinite structures, eh ;)
17:19:40 <resiak> eh, i doubt it'd be more more exciting :)
17:20:12 <EvilTerran> @go catch
17:20:13 <lambdabot> http://www.catchinfo.org/
17:20:13 <lambdabot> Title: CATCH
17:20:17 <EvilTerran> er
17:20:19 <EvilTerran> @where catch
17:20:19 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
17:23:54 * EvilTerran has just written a quick-and-dirty implementation of a problem involving lots of fromJusts, incomplete pattern matches, etc... now to tighten it up ;)
17:25:15 <luqui> > let snipe n [] = []; snipe n (x:xs) = x:snipe n (drop n xs) in snipe 1000000 [3.0001,10000.0::Float]
17:25:17 <lambdabot>  [3.0001]
17:26:04 <luqui> > let snipe n [] = []; snipe n (x:xs) = x:snipe n (drop n xs) in snipe 1000000 [3.0,3.0001,10000.0::Float]
17:26:10 <lambdabot>  [3.0]
17:26:16 <luqui> > let snipe n [] = []; snipe n (x:xs) = x:snipe n (drop n xs) in snipe 1000000 [3.0,3.0001..10000.0::Float]
17:26:19 <lambdabot> Terminated
17:26:20 <luqui> god I'm dumb
17:26:49 <luqui> well, lambdabot doesn't have enough cpu to show you my nonterminating example
17:27:17 <gwern> luqui: at times like that, I like to look at the lambdacats. 'i kant haskell today. i has the dumbs.' etc.
17:27:24 <hpaste>  dfranke pasted "When lazy IO blocks, it blocks the whole runtime" at http://hpaste.org/4103
17:27:31 <luqui> lazy bitestring!
17:28:11 <dfranke> ^^^ this is badly broken
17:35:41 <hpaste>  Pseudonym pasted "near" at http://hpaste.org/4104
17:36:02 <Pseudonym> Just found some old code of mine.
17:36:18 <Pseudonym> Ah, bug there.
17:36:43 <hpaste>  Pseudonym annotated "near" with "correction" at http://hpaste.org/4104#a1
17:36:50 <noobie> i created a data type to store some colors data Col = Bk | Yw.. etc when a user types a value thats not in the type it terminates, i want it to just say putStrln "error there" and then continue
17:37:13 <Pseudonym> How are you converting what the user types to a Col?
17:37:28 <noobie> read
17:37:31 <Pseudonym> :t reads
17:37:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:37:36 <Pseudonym> Try that.
17:37:49 <Pseudonym> > reads "True" :: [(Bool,String)]
17:37:53 <lambdabot>  [(True,"")]
17:37:56 <Pseudonym> > reads "foo" :: [(Bool,String)]
17:37:56 <lambdabot>  []
17:38:01 <noobie> ???
17:38:21 <noobie> use it in a better example
17:38:53 <glguy> ask a specific question?
17:39:04 <noobie> how to use reads
17:39:08 <resiak> you can't define data types in lambdabot, can you?
17:39:19 <glguy> resiak: you can't
17:39:22 <resiak> that's a shame
17:39:23 <wli> :t let readM s = case reads s of [(x, _)] -> return x ; [] -> throwError "readM: no parse" ; _:_:_ -> throwError "readM: ambiguous parse" in readM
17:39:24 <lambdabot> forall (m :: * -> *) a. (Read a, MonadError [Char] m) => String -> m a
17:39:29 <resiak> it would be nice if this worked:
17:39:32 <Pseudonym> > case reads "True" of { [(b::Bool,_)] -> "kthx"; _ -> "o noes" }
17:39:32 <lambdabot>  Parse error in pattern at "->" (column 38)
17:39:34 <resiak> > data Col = Bk | Yw deriving Read; [reads "Bk", reads "blah"] :: [[(Bool,String)]]
17:39:34 <lambdabot>  Parse error at "data" (column 1)
17:39:52 <Pseudonym> Erm,.
17:39:58 <noobie> i am a noob
17:40:07 <noobie> tht's too complicated
17:40:24 <glguy> readMaybe s = case reads of [(x,rest)] | all isSpace rest -> Just x ; _ -> Nothing
17:40:28 <Pseudonym> Right.
17:40:34 <Pseudonym> That works.
17:40:36 <dfranke> noobie: 'reads' returns a list of possible parses.
17:40:47 <noobie> ok
17:40:48 <dfranke> noobie: if there are no possible parses, it returns an empty list.
17:40:49 <resiak> noobie: reads str returns a list whose first element is (the value read, leftover string) if the string is valid input, and [] otherwise
17:41:56 <wli> readM is nice in other ways.
17:42:12 <noobie> the thing is i want to write a error case so that when a user enters like fg which is not a valid type i don't get a error
17:42:23 <noobie> and the program terminiate
17:42:41 <noobie> i was getting some PRelude.read parse error
17:42:57 <monochrom> Error detection and handling is too complicated.
17:43:39 <mauke> noobie: hint: stop calling yourself a noob, and don't repeat your question if you don't understand the answer
17:44:27 <TomMD> Has anyone produced a 'diff' utility for the -ddump-simpl output? (I.e. eliminating the noise from altered variable and function names)
17:46:22 <cytzol> would it be wrong of me to use an array as a stack and hope no-one's looking
17:46:39 <noobie> basically i want a function that checks the users input with the valid inputs [data Col =bk|cy|yw] if it is not valid it prints error and ask the user to enter a valid input
17:46:41 <scook0> cytzol: why not just use a list?
17:46:49 <byorgey> cytzol: too late, we're all looking now =)
17:46:53 <Lemmih> TomMD: I've written a pretty printer for -ddump-simpl.
17:47:01 <glguy> cytzol: a standard array would make a slow stack
17:47:21 <scook0> cons-lists make great stacks
17:47:51 <cytzol> surely that would mean going all the way to the end of the list to pop something off of it
17:48:01 <scook0> cytzol: uh, no, you pop stuff off the front
17:48:08 <scook0> which is the same end you push stuff on
17:48:17 <cytzol> yeah, that works too
17:48:22 <mauke> heh
17:48:25 <mauke> lists _are_ stacks
17:48:26 <cytzol> okay.
17:48:27 <scook0> push = (:), pop = tail, peek = head
17:48:27 <pjd> cytzol: lists are really stacks
17:48:34 <pjd> that happen to be usable as lists
17:48:43 <resiak> noobie: do you have ghci handy?  Try running    reads "foo" :: [(Col,String)]   for different strings and see what comes out
17:49:01 <monochrom> Good advice.
17:49:31 <resiak> noobie: compare its results to read "foo" :: Col
17:55:44 <conal> pjd: well put
17:56:30 <noobie> ERROR file:.\newr.hs:155 - Type error in type annotation
17:56:30 <noobie> *** Term           : map reads (words guess)
17:56:30 <noobie> *** Type           : [[(a,[Char])]]
17:56:30 <noobie> *** Does not match : [([Colors],String)]
17:56:30 <noobie> Random>
17:59:29 <noobie> getting that error
17:59:29 <resiak> did you do what i suggested?
17:59:36 <noobie> yep
17:59:44 <resiak> what did you discover?
17:59:54 <noobie> i got an err
18:00:35 <resiak> what error did you get when you tried to evaluate    reads "foo" :: [(Col,String)]
18:01:46 <noobie> *** Type           : [[(a,[Char])]] Does not match : [([Colors],String)]
18:01:47 <Nafai> I have a string and I want to divide it up into two character strings, "ABCDEF" --> ["AB", "CD", "EF"]
18:01:56 <Nafai> Is there a straightforward way to do that?
18:02:24 <monochrom> One way is to write a loop that calls splitAt many times.
18:02:28 <EvilTerran> > iterate (drop 2) ['A'..'F']
18:02:30 <lambdabot>  ["ABCDEF","CDEF","EF","","","","","","","","","","","","","","","","","","",...
18:02:46 <EvilTerran> > takeWhile (not.null) . iterate (drop 2) $ ['A'..'F']
18:02:47 <lambdabot>  ["ABCDEF","CDEF","EF"]
18:03:03 <Olathe> > iterate head "hello"
18:03:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:03:03 <lambdabot>       Expected...
18:03:05 <EvilTerran> etcetc; it's fairly easy from there :)
18:03:11 <faxathisia> @src chunk
18:03:11 <lambdabot> Source not found. stty: unknown mode: doofus
18:03:12 * resiak gives up
18:03:13 <faxathisia> @src chunks
18:03:14 <lambdabot> Source not found. I feel much better now.
18:03:25 <faxathisia> needs added
18:03:38 <monochrom> Your "etcetc" is making it sound harder than my "write a loop" :)
18:04:11 <vincenz> monochrom: just add (map (take 2))
18:04:16 <Lemmih> noobie: Only 'reads "foo" :: [(Col,String)]'. Don't use 'map'.
18:04:18 <EvilTerran> > unfoldr ((>>) <$> guard.not.null <*> return.splitAt 2) ['A'..'F']
18:04:19 <lambdabot>  ["AB","CD","EF"]
18:04:22 <EvilTerran> >:]
18:04:33 <faxathisia> > let chunk n = takeWhile (not . null) . unfoldr (Just . splitAt n)  in chunk 3 "arghasdf"
18:04:33 <lambdabot>  ["arg","has","df"]
18:04:34 <vincenz> EvilTerran: evil
18:04:39 <EvilTerran> that's me :D
18:04:59 <monochrom> You're the best!
18:05:18 <Saizan> EvilTerran: next time with spears!
18:05:30 <vincenz> Saizan: the singer?
18:05:34 <EvilTerran> > map (take 2) . takeWhile (not.null) . iterate (drop 2) $ ['A'..'F']  --seriously, though, this is my preferred form for that one. clearer, and generalises better
18:05:35 <lambdabot>  ["AB","CD","EF"]
18:05:42 <Olathe> > let f (a:b:c:ds) = [a, b]:f (c:ds); f xs = [xs] in f "ABCDEF"
18:05:43 <lambdabot>  ["AB","CD","EF"]
18:05:54 <vincenz> Olathe: not parametrizeble for n
18:05:58 <Saizan> vincenz: if you can put it on irc..
18:06:00 <Olathe> Of course it is.
18:06:07 <Olathe> You just need to make a code generator ;)
18:06:07 <Saizan> "she"
18:06:22 <EvilTerran> > let f (a:b:etc) = [a, b] : f etc; f xs = [xs] in f "ABCDEF" -- why break pattern-match beyond the first two?
18:06:23 <lambdabot>  ["AB","CD","EF",""]
18:06:23 <vincenz> Olathe: ok, not runtime parametrizeable for n
18:06:26 <Olathe> Heheh
18:06:33 <EvilTerran> ah, to escape the empty-list case. clever.
18:06:41 <EvilTerran> s/break//
18:06:58 <Nafai> EvilTerran: I like your "preferred form"
18:07:03 <EvilTerran> ty :)
18:08:09 <Olathe> @src take
18:08:09 <lambdabot> take n _      | n <= 0 =  []
18:08:09 <lambdabot> take _ []              =  []
18:08:09 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
18:08:41 <noobie> Lemmih: it worked, but how do i put it in the code?
18:09:04 <__snake> re
18:09:30 <__snake> does anybody have experience with building GHC for ia64?
18:10:16 <__snake> I'm trying to follow the "Porting GHC" instructions
18:10:20 <__snake> with no success
18:16:42 <Lemmih> noobie: Understand the types.
18:16:55 <luqui> can I export a qualified name from a module?
18:17:09 <mauke> yes
18:17:12 <luqui> i.e. export the entire Data.Map module under the name Map
18:17:32 <vincenz> Lemmih: Thank you Master Mona
18:17:43 <vincenz> erm, Yoda, or was it Monad..
18:18:15 <byorgey> use the types, Luke!
18:18:27 <Olathe> > let section _ [] = []; section size xs = let (inits, tails) = splitAt size xs in inits:(section size tails) in section 2 "hello"
18:18:27 <lambdabot>  ["he","ll","o"]
18:19:06 <noobie> how would i make that in a error message, would i say like if soandso == [] then putStrLn "some error message"
18:19:58 <byorgey> noobie: sure.  note you can also test for the empty list with the 'null' function
18:20:01 <vincenz> if ... then ... else ...
18:20:06 <byorgey> > null [1,2,3]
18:20:06 <lambdabot>  False
18:20:10 <byorgey> > null []
18:20:10 <lambdabot>  True
18:20:14 <noobie> ok
18:20:18 <noobie> thanks
18:20:54 <Olathe> @src null
18:20:54 <lambdabot> null []     = True
18:20:54 <lambdabot> null (_:_)  = False
18:21:33 <Olathe> > let null' [] = True; null' _ = False in null' [1..]
18:21:33 <lambdabot>  False
18:21:37 <Olathe> > let null' [] = True; null' _ = False in null' []
18:21:38 <lambdabot>  True
18:22:13 <LoganCapaldo> > let null' = foldr (const False) True in (null' [], null' [1,2,3])
18:22:13 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `Bool'
18:22:41 <mauke> needs more const
18:22:47 <resiak> > let result = reads "badgers" :: [(Int, String)] in (result, null result)
18:22:48 <lambdabot>  ([],True)
18:22:49 <LoganCapaldo> > let null' = foldr (const (const False)) True in (null' [], null' [1,2,3])
18:22:49 <lambdabot>  (True,False)
18:22:56 <resiak> > let result = reads "13" :: [(Int, String)] in (result, null result)
18:22:56 <lambdabot>  ([(13,"")],False)
18:23:09 <hpaste>  luqui pasted "export a qualified module?" at http://hpaste.org/4105
18:24:07 <Olathe> > let cowbell = (>> "Ding! ") in cowbell [1..]
18:24:07 <lambdabot>  "Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Din...
18:24:56 <faxathisia> > let cowbell = (>> "Ding! ") in cowbell [Just 1, Just 2, Nothing, Just 3, Nothing]
18:24:57 <lambdabot>  "Ding! Ding! Ding! Ding! Ding! "
18:25:07 <faxathisia> :t (>>)
18:25:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:25:20 <luqui> he's abusing the list monad...
18:25:27 <Olathe> Abuse ?!
18:25:36 <Olathe> We need more cowbell !
18:26:12 <Olathe> @src (>>)
18:26:12 <lambdabot> m >> k      = m >>= \_ -> k
18:26:32 <Olathe> > let cowbell = (>> "Ding! ") in Nothing
18:26:32 <lambdabot>  Nothing
18:26:39 <Olathe> > let cowbell = (>> "Ding! ") in Just 5
18:26:39 <lambdabot>  Just 5
18:27:01 <Olathe> > let cowbell = (>> "Ding! ") in map cowbell [Just 5, Nothing]
18:27:01 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe t'
18:27:13 <Olathe> Ahh.
18:27:26 <byorgey> uh... you do realize you didn't actually *use* cowbell back there? =)
18:27:36 <Olathe> Yes :)
18:30:31 <monochrom> @quote flies
18:30:31 <lambdabot> monochrom says:  Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
18:31:08 <sjanssen> > let morecowbell = ("Ding! "++) in iterate morecowbell ""
18:31:09 <lambdabot>  ["","Ding! ","Ding! Ding! ","Ding! Ding! Ding! ","Ding! Ding! Ding! Ding! ",...
18:34:30 <Olathe> > let morecowbell = ("Ding! "++) in (iterate morecowbell "") >>= id
18:34:41 <Olathe> Faster !
18:34:45 <lambdabot>  "Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Ding! Din...
18:34:51 <EvilTerran> > fix $ map ("Ding! "++) . ([]:)
18:34:55 <lambdabot>  ["Ding! ","Ding! Ding! ","Ding! Ding! Ding! ","Ding! Ding! Ding! Ding! ","Di...
18:36:57 <Pseudonym> Oh, the upside-down robot ninja monkey oeprator.
18:36:59 <Pseudonym> Good use of it.
18:37:19 <Olathe> Heheh
18:38:05 <EvilTerran> > fix (("Ding! ":).join(++)) -- faster?
18:38:06 <lambdabot>  ["Ding! ","Ding! ","Ding! ","Ding! ","Ding! ","Ding! ","Ding! ","Ding! ","Di...
18:38:10 <EvilTerran> er, wait
18:38:20 <EvilTerran> > fix (("Ding! ":).map(join(++))) -- faster?
18:38:21 <lambdabot>  ["Ding! ","Ding! Ding! ","Ding! Ding! Ding! Ding! ","Ding! Ding! Ding! Ding!...
18:40:14 <Olathe> > iterate (\xs -> 'D':'i':'n':'g':'!':' ':xs) ""
18:40:14 <lambdabot>  ["","Ding! ","Ding! Ding! ","Ding! Ding! Ding! ","Ding! Ding! Ding! Ding! ",...
18:41:22 <faxathisia> > ["","Ding! ","Ding! Ding! ","Ding! Ding! Ding! ","Ding! Ding! Ding! Ding! ","Ding! Ding! Ding! Ding! Ding! "]
18:41:22 <lambdabot>  ["","Ding! ","Ding! Ding! ","Ding! Ding! Ding! ","Ding! Ding! Ding! Ding! ",...
18:42:04 <Olathe> > ["", "Ding! "..]
18:42:04 <lambdabot>   add an instance declaration for (Enum [Char])
18:42:04 <lambdabot>     In the expression: ["", "...
18:42:06 <Olathe> :(
18:43:24 <Japsu> speaking of bells
18:43:38 <Japsu> someone mentioned elsewhere that using unsafePerformIO should "ring a bell"
18:43:42 <Japsu> well
18:44:05 * vincenz rings a bell around Olathe's head until his ears don't stop chiming
18:44:15 <Japsu> unsafePerformIO' act = unsafePerformIO (putStr "\07" >> act)
18:44:16 <Japsu> there
18:44:28 <Japsu> an unsafePerformIO that literally "rings a BEL"
18:44:40 <Olathe> Yay ! Free cowbell that never stops !
18:45:01 <vincenz> Japsu: ooh, then you can hear random beeps as haskell runs down your lazy data structure
18:45:10 <Japsu> vincenz: yeah!
18:45:31 <mauke> writeFile "/dev/tty" "\a" plz
18:45:37 <Japsu> :D
18:45:49 <Japsu> mauke: mine's faster
18:45:59 <Japsu> @src writeFile
18:45:59 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
18:46:00 <mauke> and suffering from buffering
18:46:07 <Japsu> true
18:46:09 <scook0> vincenz: wow, that actually strikes me as being a good idea! :)
18:46:25 <Japsu> but at least it does't fopen, fputs and fclose every time
18:46:29 <scook0> (oh, no pun intended)
18:46:49 <mauke> but what if stdout is not a terminal?
18:47:02 <vincenz> mauke: BOOM!
18:47:09 <vincenz> unsafeLaunchNuke
18:47:09 <Japsu> well then all hell breaks loose
18:47:09 <Olathe> Heheh
18:47:13 <Japsu> and we hear no beeps
18:47:24 <Japsu> launchMissiles :: STM () -- serious international side-effects
18:47:41 <vincenz> Japsu: the nice thing tho
18:47:43 <scook0> Japsu: atomically launchMissiles
18:47:44 <vincenz> it's non sequential
18:47:56 <vincenz> whether you launch first or the others do, the result is the same :)
18:48:06 <Japsu> scook0: retry
18:48:15 <Japsu> vincenz: hahaha
18:48:16 <scook0> oh, nuclear winter is confluent!
18:48:32 <vincenz> very parallelizeable
18:49:22 <Japsu> "do nuclear launches commute"
18:49:48 <luqui> the word orer for atomically launchMissles is a little off...
18:50:21 <Japsu> lol
18:50:42 <vincenz> the problem is
18:50:47 <vincenz> they only commute to a certain degree
18:50:53 <vincenz> hmm, this is actually interesting
18:51:00 <vincenz> it's parallel only within certain time-bounds
18:51:08 <vincenz> if you launch one way earlier than the other..
18:51:37 * vincenz wonders if there's a mathematical structure that shares that propert
18:51:38 <vincenz> y
19:37:00 <TSC> Given a cabal package with a few executables, can I tell it to build only one of them?
19:38:14 <dons> not that I know of
19:38:35 <TSC> Oh well
19:38:54 <dons> comment out the ones you don't want to build
19:39:45 <TSC> Yeah, there are a few possible work-arounds
19:39:54 <vincenz> @dict es en querido
19:39:54 <lambdabot> Supported dictionary-lookup commands:
19:39:54 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
19:39:54 <lambdabot> Use "dict-help [cmd...]" for more.
19:40:24 <oerjan> @babel es en querido
19:40:25 <lambdabot>   wanted
19:40:44 <vincenz> @babel es en quien
19:40:44 <lambdabot>   who
19:40:53 <vincenz> @babel es en huviera
19:40:53 <lambdabot>   huviera
19:48:01 <vincenz> @babel es en hubiera
19:48:02 <lambdabot>   it had
19:55:42 <vincenz> @babel es en pensabas
19:55:42 <lambdabot>   you thought
19:56:48 * oerjan points out that you can use the babelfish website
19:56:55 <vincenz> oerjan: thanks
20:02:47 <Brian`> hi guys
20:02:58 <shapr> hiya brian
20:03:31 <Brian`> hey, what function creates a list of n elements?
20:03:52 <xpika> how do you check if an IORef is undefined or not?
20:03:53 <EvilTerran> @hoogle Int -> [a]
20:03:56 <monochrom> replicate n 'a'
20:03:58 <lambdabot> Prelude.replicate :: Int -> a -> [a]
20:03:58 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
20:03:58 <lambdabot> Prelude.take :: Int -> [a] -> [a]
20:04:08 <xpika> > replicate 5 'a'
20:04:12 <lambdabot>  "aaaaa"
20:04:12 <Brian`> > replicate 5 [3]
20:04:14 <lambdabot>  [[3],[3],[3],[3],[3]]
20:04:19 <Brian`> that's what i've been looking for!
20:04:35 <Brian`> thanks EvilTerran, monochrom :)
20:05:10 <Brian`> I'm trying to write sudoku :) the first program I'm writing myself with haskell :) not like tutorial follow-up wish me some luck hehe
20:05:57 <xpika> > undefined == undefined
20:05:58 <lambdabot>  Undefined
20:05:59 <shapr> That's a good idea.
20:06:11 <dons> xpika: there's no undefined iorefs, are there?
20:06:45 <monochrom> with much caveat, you may deref the IORef, then try { force evaluation } catch { the exception corresponding to error }
20:06:48 <dons> the only way to introduce an IORef is with a -> IO (IORef a)
20:06:49 <xpika> > a <- newIORef undefined
20:06:49 <lambdabot>  Parse error at "<-" (column 3)
20:07:03 <dons> oh, you want to know if it is bottom? you'll have to force it, in IO.
20:07:05 <dons> as monochrom says.
20:07:29 <dons> it could contain a non-terminating computation too, of course
20:07:57 <monochrom> yes, that's the caveat. there is no always-correct test.
20:08:09 <Korollary> Brian`: once you're done, you can also check the huge sudoku page on the Haskell wiki: http://www.haskell.org/haskellwiki/Sudoku
20:08:10 <lambdabot> Title: Sudoku - HaskellWiki
20:08:22 <dons> i had lots of fun at work watching little graphs of programs utilising 98% and 197% cpu, with +RTS -N1, and then +RTS -N2
20:08:25 <dons> very cute
20:08:35 <Brian`> Korollary, sure I'll keep that in mind
20:09:00 <Brian`> dons, do you use haskell at work?
20:09:30 <oerjan> 197% is some good parallelization :)
20:10:16 <dons> Brian`: yeah.
20:10:39 <dons> oerjan: to be fair, it was a test of some concurrency abstractions
20:10:42 <dons> :)
20:23:41 <Brian`> @hoogle a -> String
20:23:41 <lambdabot> Prelude.show :: Show a => a -> String
20:23:41 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
20:23:41 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
20:25:31 <hpaste>  dons pasted "chameneos-old" at http://hpaste.org/4106
20:25:53 <dons> oh, did we have that conversation in the wrong channel
20:25:54 <dons> silly me
20:26:19 <dons> sjanssen: yeah, there's the old one ^^
20:26:29 <dons> looks like now we have to print out some 'n's on meeting
20:26:49 <sjanssen> dons: it is probably OT in #xmonad, anyway
20:26:57 <dons> right.
20:27:01 <dons> i thought i was in #haskell :}
20:27:23 * allbery_b was wondering why that discussion was in #xmonad...
20:27:38 <dons> i've had a long day :)
20:27:51 <dons> and sjanssen is in both chans, and we have evil schemes in both chans, so its easy to get confused
20:28:02 <dibblego> > cos 0
20:28:10 <lambdabot>  1.0
20:28:32 <dons> yo dibblego. how's .au under the glorious new leadership? any different? beer still cold? blowies still annoying?
20:28:51 <dibblego> dons, too much news about it actually :)
20:29:01 <dons> yeah, i noticed
20:29:09 <dibblego> I don't vote
20:29:17 <dons> wow
20:29:29 <dons> did you just incriminate yourself? :)
20:29:33 * sjanssen wants to know what a blowie is
20:29:38 <dibblego> I have already announced it on my blog
20:29:47 <TSC> sjanssen: We'll tell you when you're older
20:29:52 <dibblego> I'll happily pay the price :)
20:30:18 <dons> yeah, probably not a good idea to google for blowies
20:30:26 <dons> http://www.glaucus.org.uk/BlowFly053.jpg
20:31:02 <sjanssen> TSC: hmm, the sort of blow-something I know about isn't generally called "annoying" ;)
20:33:04 <monochrom> Hopefully Chinese will become the second official language under the new leadership. :)
20:33:13 <dons> heh
20:33:27 <TSC> The great leader Rudd commands it!
20:33:29 <dons> i should have persisted with my mandarin at uni
20:33:56 <dons> haskell's a lot easier
20:34:25 <monochrom> In an interview with a Chinese TV channel, he spoke Mandarin throughout!
20:34:37 <dons> yeah, the great ruddbot has modules for that
20:34:43 <monochrom> haha
20:35:44 <TSC> "I know kung-fu", said the Ruddbot
20:38:31 <Brian`> @hoogle String
20:38:33 <lambdabot> Foreign.C.String :: module
20:38:33 <lambdabot> Prelude.String :: type String
20:38:33 <lambdabot> Text.Read.String :: String -> Lexeme
20:42:51 <dons>   * write all the colour changes for blue red and yellow creatures, using the colour complement
20:42:54 <dons>     function"
20:42:56 <dons> damn their impurity!
20:43:07 <dons> tracing grr
20:43:15 <sjanssen> dons: yeah, that's dumb
20:43:33 <sjanssen> shouldn't be outrageously expensive, I hope
20:44:13 <hpaste>  luqui pasted "make append-using function more efficient?" at http://hpaste.org/4107
20:44:16 * kfish started learning japanese and haskell at about the same time
20:44:23 <luqui> is there a more efficient way to write that?
20:44:45 <luqui> I've heard that japanese and ruby go well together
20:44:56 <bparkis> hey i was thinking--sometimes you want to copy someone else's code and modify it, rather than use their function as a black box or roll your own.  so how about a programming environment with support for inline expansion of functions, _in the editor_, so you can then modify the source yourself to get it to do something else
20:45:28 <bparkis> conveniently--like you'd just type foo(a, b, c) and then use some hotkey to inline it, and the source for foo would expand out
20:46:30 <bparkis> exists already?
20:46:47 <chessguy> @hoogle (a -> Bool) -> m a -> m [a]
20:46:47 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
20:47:00 <sjanssen> dons: the old implementation is a bit questionable: replicateM_ 3 yield
20:47:13 <chessguy> @hoogle m [a]
20:47:13 <lambdabot> Control.Monad.List.runListT :: ListT m a -> m [a]
20:47:13 <lambdabot> Prelude.undefined :: a
20:47:13 <lambdabot> Test.QuickCheck.Batch.bottom :: a
20:47:37 <chessguy> luqui, does the order of the resulting list matter?
20:47:39 <mauke> luqui: why does your whileM return the results in reverse order?
20:47:45 <luqui> can't do that
20:47:48 <luqui> well
20:47:53 <luqui> I suppose I could then reverse at the end
20:47:55 <luqui> then it's O(n)...
20:47:58 <luqui> okay sounds good
20:48:00 <luqui> :-)
20:48:11 <mauke> why reverse?
20:48:18 <luqui> because I need the list to be in forward order
20:48:20 <chessguy> then reverse $ val : whileM p m
20:48:27 <hpaste>  monochrom annotated "make append-using function more efficient?" with "(no title)" at http://hpaste.org/4107#a1
20:48:30 <mauke> what?
20:48:37 <mrd> bparkis: find-definition and cut/paste?
20:48:51 <dmwit> mauke: He wants the last results to be at the end of the list.
20:48:58 <mrd> bparkis: what you are describing sounds like the normal mode of Java programmers
20:49:03 <mauke> dmwit: then why ++ [val]?
20:49:09 <mauke> that puts the last result first
20:49:23 <luqui> mauke, am I just being silly?
20:49:23 <chessguy> dmwit, other way round, he wants the first result at the end
20:49:24 <bparkis> yes i agree it does tend to ignore the value of abstraction
20:49:27 <mauke> luqui: yes
20:49:29 <dmwit> ...oh
20:49:36 <monochrom> Oh ha, I was not looking at the order.
20:49:36 <conal> monochrom: how about building the list backward and then reversing.
20:49:45 <conal> monochrom: or use dlist
20:49:47 <luqui> riiight... okay thanks :-)
20:49:52 <mauke> he's already building it backwards, that's the problem
20:49:52 <mrd> bparkis: likely some retarded IDE like Eclipse has special support for that kind of idiocy
20:50:34 <chessguy> mrd, don't be so shy, tell us what you really think :)
20:50:38 <bparkis> well, i wouldn't go that far, i mean being able to modify the source to make something slightly different is the reason for open source in the first place
20:50:52 <dmwit> luqui: There's also this trick for one-element if lists:
20:50:56 <bparkis> not idiocy, just easily misused
20:51:05 <dmwit> [x | p x]
20:51:16 <dmwit> Let me annotate.
20:52:15 <dmwit> Oh, wait, it doesn't work here.  Never mind. =P
20:53:31 <thetallguy> http://wiki.secondlife.com/wiki/Eventlet
20:53:35 <lambdabot> Title: Eventlet - Second Life Wiki
20:53:58 <hpaste>  monochrom annotated "make append-using function more efficient?" with "this one has the original order" at http://hpaste.org/4107#a2
20:54:06 <thetallguy> This link showed up on reddit. non-blocking network IO with co routines in python
20:54:17 <thetallguy> Anyone know anything about it?
20:54:28 <monochrom> luqui: the most recent one is in the original order you coded.
20:54:42 <luqui> monochrom, that's the trick I was looking for, even though I didn't need it
20:54:42 <sorear> thetallguy: yes, I've done it in C
20:54:50 <chessguy> osfameron, ping?
20:55:41 <thetallguy> sorear: Can you tell what it is?  The page is so full of jargon it's hard to get a handle on what they are doing.
20:55:49 <thetallguy>  s/tell/tell me
20:56:26 <sorear> thetallguy: I'm not even reading the page, it's obvious from the title which ancient trick they are pulling
20:57:00 <thetallguy> sorear: it sounds like the thesis of that guy from NYU.
20:57:14 <sorear> thetallguy: they have created a cooperative scheduler based on context-switching primitives, and rather than just using system threads, rewrote the core of the OS in python
20:58:18 <thetallguy> http://citeseer.ist.psu.edu/fuchs95escaping.html
20:58:19 <lambdabot> Title: Escaping the event loop: an alternative control structure for multi-threaded GUI ...
20:58:26 <chessguy> @pl \i -> (toLowerS $ name i, i)
20:58:26 <lambdabot> (,) =<< toLowerS . name
20:59:07 <conal> thetallguy: looks like something i'd be interested in.  thanks.
20:59:28 <thetallguy> sorear: presumably because they hope to gain code clarity?  They seem to imply speed improvements
20:59:50 <thetallguy> sorear: thanks, I think I will let it go by.
20:59:54 <dmwit> (toLower . name) &&& id
20:59:58 <thetallguy> conal: Yes, it's an interesting read.
20:59:58 <dmwit> :t (&&&)
21:00:12 <sorear> people don't read the literature, they like to take credit for reinventions
21:00:13 <lambdabot> thread killed
21:00:24 <monochrom> Sounds like a precursor to delimited continuations or continuations or yield-generators.
21:00:26 <thetallguy> conal: the eventlet stuff reminded me of it and that I owed you the link.
21:00:43 <sorear> if I had a penny for every foundational result I've reinvented... well okay I'd only by around $5 richer
21:00:43 <thetallguy> sorear: yes.  Done it myself once or twice.
21:00:52 <thetallguy> lol
21:01:01 <conal> thetallguy: glad to have it.
21:01:13 <chessguy> hm, is there a better way to do this? f x | p x = Just $ g x; f x | otherwise = Nothing
21:01:24 <dmwit> Yes!
21:01:40 <dmwit> But I can't remember it.  It was really fancy, used guard and stuff.
21:01:43 <chessguy> haha
21:01:47 <dmwit> Let's see...
21:01:47 <chessguy> @type guard
21:01:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:01:53 <thetallguy> conal: David knew him at NYU.  Thought well of him.
21:01:57 <EvilTerran> f x = guard (p x) >> g x
21:01:58 <mauke> chessguy: s/; f x//
21:02:02 <sjanssen> dons: most of this extra output is stupid
21:02:08 <thetallguy> conal: I think he sold Yahoo a calendar app for a lot of money and retired.
21:02:14 <sjanssen> dons: eg. printing the color complement table
21:02:21 <EvilTerran> f x = liftM2 (>>) guard g
21:02:21 <sorear> chessguy: f x = [ x | p x ] with monad comprehensions
21:02:43 <EvilTerran> s/g/return.g/, even
21:03:03 <dmwit> f = liftM g . guard . p -- this?
21:03:19 <dmwit> ?type \g p -> liftM g . guard . p
21:03:20 <lambdabot> forall r (m :: * -> *) a. (MonadPlus m) => (() -> r) -> (a -> Bool) -> a -> m r
21:03:31 <dmwit> nope =)
21:03:50 <chessguy> @type liftM2 (>>) guard (return.g)
21:03:50 <lambdabot> Not in scope: `g'
21:03:58 <chessguy> @type liftM2 (>>) guard (return.?g)
21:03:58 <lambdabot> Not in scope: `.?'
21:03:58 <lambdabot> Not in scope: `g'
21:04:03 <dmwit> ?type liftM_
21:04:04 <lambdabot> Not in scope: `liftM_'
21:04:05 <chessguy> @type liftM2 (>>) guard (return . ?g)
21:04:06 <lambdabot> forall b (m :: * -> *). (MonadPlus m, ?g::Bool -> b) => Bool -> m b
21:04:51 <mauke> haha
21:04:54 <sjanssen> @type (>>) (guard . ?p) (return . ?g)
21:04:57 <lambdabot>     Ambiguous type variable `m' in the constraint:
21:04:57 <lambdabot>       `MonadPlus m' arising from use of `guard' at <interactive>:1:6-10
21:04:57 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
21:05:12 <mauke> liftM_ :: (Monad m) => (a -> b) -> m a -> m ()
21:05:30 <sjanssen> @type liftM2 (>>) (guard . ?p) (return . ?g)
21:05:31 <lambdabot> forall b (m :: * -> *) a. (?p::a -> Bool, MonadPlus m, ?g::a -> b) => a -> m b
21:05:40 <dmwit> mauke: Yeah, not exactly what anybody wanted. =P
21:07:27 <EvilTerran> @type \p g -> liftM2 (>>) (guard.p) (return.g)
21:07:28 <lambdabot> forall b (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> (a -> b) -> a -> m b
21:07:42 * xpika me
21:07:53 <chessguy> @type liftM2 (>>) (guard.(all isDigit)) (return . read)
21:07:54 <lambdabot> forall b (m :: * -> *). (MonadPlus m, Read b) => [Char] -> m b
21:09:56 <ramza3> http://www.haskell.org/http/  the http library seems to be lacking
21:09:57 <lambdabot> Title: Haskell HTTP package
21:11:42 <bparkis> adding a new abstraction bears a slight resemblance to adding a new covariate to a statistical model--when you add an abstraction you are adding another concept to describe the program you are making, and there is a question of how many and which concepts are necessary to make that program
21:12:14 <bparkis> similar to finding a statistical model where you add new covariates to describe the underlying distribution, and there is a question of how many and which covariates are necessary to describe that distribution
21:13:51 <thetallguy> ramza3: what in particular are you looking for?
21:14:24 <ramza3> thetallguy: ssl would be nice
21:14:34 <bparkis> just as in statistics there is a question of whether the new covariate is "significant," there may be a question in programming of whether a particular abstraction is significant
21:14:55 <thetallguy> ramza3: I think you have to talk to the HAppS guys for that.
21:15:06 <dmwit> ramza3: Maybe use the curl bindings?
21:15:14 <bparkis> having to do with how well it fits your program compared to the complexity it adds
21:15:25 <bparkis> all in vague metaphorical terms, though
21:16:11 <chessguy> > inits "string"
21:16:14 <lambdabot>  ["","s","st","str","stri","strin","string"]
21:16:16 <hypomnema> i'm just learning haskell, and the borked doco links at haskell.org are driving me insane.  i have to ask: does anyone know why they haven't put 403 or mod_rewrites on them?
21:16:34 <mrd> doco?
21:16:36 <ramza3> thetallguy: does happs have its own independent set of http client libraries or is it a dependency
21:16:39 <hypomnema> mrd: documentation
21:16:45 <mrd> where what
21:16:54 <mrd> 'cause of the haddock upgrade?
21:17:29 <sclv> http://haskell.org/ghc/docs/latest/html/libraries/
21:17:39 <sclv> This should get you good working links for everything.
21:17:53 <sclv> The lack of source is still a pain though.
21:17:55 <hypomnema> sclv: thanks!  it doesn't fix all the broken links in the google index, though
21:18:30 <dmwit> hypomnema: You should use hoogle for this stuff anyway.
21:18:46 <hypomnema> most of hoogle's got broken links too, unless they've been fixed today
21:18:55 <dmwit> haskell.org/hoogle
21:19:24 <dmwit> Oh, really?
21:19:37 <dmwit> I just checked its Data.Map link, which was right, and figured they were all good. =P
21:19:47 <hypomnema> dmwit: yeah, let me look at my history to find a specific example
21:19:47 <scook0> some is fixed; some is still broken
21:20:11 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Text-Html.html#v%3AconcatHtml  (broken)
21:20:12 <lambdabot> http://tinyurl.com/2y9hgo
21:20:30 <scook0> (as a workaround, I just s/latest/6.6/ in the URL, since I haven't upgraded yet)
21:20:35 <hypomnema> my original question remains though: HTTP has redirects for this exact reason  =)
21:20:44 <chucklarge> is there a good way to remove duplicate pairs from a list,  order of the pairs does not matter,  [(1,2),(3,5),(2,1),(5,3)]  => [(1,2),(3,5)]
21:21:07 <mauke> order all pairs first
21:21:28 <chessguy> > nub [(1,2),(3,5),(2,1),(5,3)]
21:21:30 <lambdabot>  [(1,2),(3,5),(2,1),(5,3)]
21:21:40 <chessguy> oh
21:21:47 <mrd> > map (min *** max) [(1,2),(3,5),(2,1),(5,3)]
21:21:48 <lambdabot>  [(<Integer -> Integer>,<Integer -> Integer>),(<Integer -> Integer>,<Integer ...
21:22:09 <mrd> > map (uncurry min &&& uncurry max) [(1,2),(3,5),(2,1),(5,3)]
21:22:09 <dmwit> ?type (***)
21:22:09 <lambdabot>  [(1,2),(3,5),(1,2),(3,5)]
21:22:10 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:22:18 <mrd> > nub $ map (uncurry min &&& uncurry max) [(1,2),(3,5),(2,1),(5,3)]
21:22:18 <lambdabot>  [(1,2),(3,5)]
21:22:47 <chessguy> @type nub . map (uncurry min &&& uncurry max)
21:22:47 <oerjan> > nubBy (comparing (uncurry min &&& uncurry max)) [(1,2),(3,5),(2,1),(5,3)]
21:22:47 <lambdabot> forall a. (Eq (a, a), Ord a) => [(a, a)] -> [(a, a)]
21:22:47 <lambdabot>  Couldn't match expected type `Bool'
21:22:54 <dmwit> ?type uncurry (min &&& max)
21:22:54 <lambdabot>     Couldn't match expected type `b -> c'
21:22:54 <lambdabot>            against inferred type `(a -> a, a -> a)'
21:22:54 <lambdabot>     In the first argument of `uncurry', namely `(min &&& max)'
21:23:00 <dmwit> Oh, right.
21:23:43 <oerjan> huh?
21:23:52 <luqui> :t comparing
21:23:52 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
21:23:53 <oerjan> :t comparing (uncurry min &&& uncurry max)
21:23:53 <lambdabot> forall a. (Ord a, Ord (a, a)) => (a, a) -> (a, a) -> Ordering
21:24:17 <oerjan> oh wait
21:24:23 <luqui> I had no idea that function existed.  I've wanted it a few times though :-)
21:24:25 <dmwit> Ordering /= Eq
21:24:35 <oerjan> > nubBy ((==) `on` (uncurry min &&& uncurry max)) [(1,2),(3,5),(2,1),(5,3)]
21:24:36 <lambdabot>   Not in scope: `on'
21:24:41 <dmwit> err... Ordering /= Bool, really
21:24:47 <oerjan> @let on (==) f x y = f x == f y
21:24:50 <lambdabot> Defined.
21:24:54 <oerjan> > nubBy ((==) `on` (uncurry min &&& uncurry max)) [(1,2),(3,5),(2,1),(5,3)]
21:24:55 <lambdabot>  [(1,2),(3,5)]
21:25:30 <dmwit> ?pl \f -> f min &&& f max
21:25:30 <lambdabot> liftM2 (&&&) ($ min) ($ max)
21:25:37 <oerjan> luqui: comparing = (compare `on`) anyway
21:25:49 <hypomnema> on using hoogle vs google: http://www.haskell.org/hoogle/?q=nub versus http://www.google.com/search?q=haskell+nub
21:25:50 <lambdabot> Title: nub - Hoogle
21:25:50 <oerjan> except it's a bit older so lambdabot has it by default
21:25:52 <luqui> except on doesn't exist...
21:26:03 <oerjan> @hoogle on
21:26:04 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
21:26:04 <lambdabot> System.Console.Readline.onNewLine :: IO ()
21:26:04 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
21:26:24 <oerjan> luqui: it's recently added, Data.Function i believe
21:26:46 <Korollary> Data.Function is the coolest module name evah
21:26:55 <Korollary> Sorta like Turing.Machine
21:27:18 <luqui> hey, there's fix!  Good, I always felt awkward importing Control.Monad.Fix when I just wanted fix :-)
21:27:24 <dmwit> ?pl (\x y -> tmin x == tmin y && tmax x == tmax y)
21:27:24 <lambdabot> ap (ap . ((&&) .) . (. tmin) . (==) . tmin) ((. tmax) . (==) . tmax)
21:28:29 <oerjan> dmwit: that's, hm, (==) `on` (tmin &&& tmax)
21:28:33 <oerjan> i think
21:28:48 <dmg_> Hi all, Dimitry is here
21:29:13 <oerjan> hello dimitry
21:29:17 <dmwit> oerjan: Okay, I'm just playing around, anyway.
21:29:44 <chessguy> @seen Dimitry
21:29:44 <lambdabot> I haven't seen Dimitry.
21:30:02 <dmg_> I have a question, not directly Haskell-related, but just in case anybody knows. Is there a tool that could help detect memory leaks in MSIE?
21:30:27 <dmwit> I can detect leaks.
21:30:35 <dmwit> "There are leaks."
21:30:42 <dmwit> done
21:30:44 <dmg_> I am trying to implement monadic style in my Javascript-related stuff, but I faced memory leaks again. Never had that with plain CPS.
21:31:36 <luqui> dmg_, that stuff doesn't work with the naive implementation of pads that eg. python (and probably JS) uses
21:31:49 <oerjan> dmwit: hm i'm wrong there needs to be some (un)currying there
21:32:02 <luqui> dmg_, variables are alive until the end of their scope, not just until their last usage
21:32:12 <chessguy> dmg_, you have an implementation of monads in JS?
21:32:13 <dmwit> oerjan: let tmin = uncurry min; tmax = uncurry max in ... ;-)
21:32:20 <sorear> chessguy: no
21:32:24 <sorear> chessguy: he has two things
21:32:29 <Heffalump> dmg_: without symbol information leak tools won't be much use
21:32:35 <sorear> chessguy: an implementation of the G-machine in JS
21:32:35 <dmg_> OK, here is a page in question: http://www.golubovsky.org/repos/wsptest/EchoM.html
21:32:36 <lambdabot> Title: EchoM
21:32:45 <sorear> chessguy: and an implementation of monads in Haskell
21:32:48 <dmg_> It's source is http://www.golubovsky.org/repos/wsptest/EchoM.hs
21:33:00 <dmwit> sorear: heh
21:33:09 <chessguy> G-machine?
21:33:16 <dmg_> This is my old test program that times conversion from Roman to Decimal and vv.
21:33:18 <dmwit> I think he means STG-machine.
21:33:22 <oerjan> dmwit: oh wait i was confused by the name, it was right the first time or
21:33:26 <sorear> dmg_: I think one or the other is the problem - either your backend is broken, or your monad is broken.  I seriously doubt there is something specific to the combination (MSIE, monads)
21:33:32 <sorear> dmg_: no, I mean G-machine
21:33:41 <sorear> dmwit: no, I mean G-machine
21:34:05 <dmwit> Hmm, really?  What compiler takes Haskell -> G-machine?
21:34:06 <luqui> dmg_, have you tried it on spidermonkey?
21:34:10 <dmg_> Works perfectly in firefox, but when you load it into MSIE, every input causes leak of 1M. When unloaded, MSIE returns memory back though.
21:34:21 <luqui> okay
21:34:25 <sorear> dmwit: any old haskell compiler
21:34:30 <sorear> dmwit: emphasis on old
21:34:34 <dmg_> Can I run spidermonkey on MSIE?
21:34:48 <luqui> no don't think so
21:34:58 <sorear> dmwit: notably hbc and nhc, and descendants thereof (think yhc)
21:35:01 <luqui> so it is IE, just making that clear
21:35:12 <dmwit> ok
21:35:19 <sorear> dmwit: you're talking to Dimitry Golubovsky, the guy who wrote ycr2js
21:35:31 <monochrom> I think the question is: how to rewrite the program to keep broken IE happy.
21:35:37 <dmg_> Now, another, much more contrived example: http://darcs.haskell.org/yhc/web/jsdemos/HsWTKDemo.html
21:35:38 <lambdabot> Title: HsWTKDemo
21:35:46 <sorear> (and since it doesn't acually use latin letters I feel license to misspell)
21:36:16 <dmg_> Written in plain CPS, but does generally the same: reads from input field, outputs somewhere. Press it hard, many times, no leaks in MSIE.
21:36:26 <dmwit> sorear: Actually, I was talking to you and chessguy.  I already knew dmg_'s question was out of my league. =P
21:36:33 <sorear> dmg_: I'm initially inclined to suspect luqui is on the write track.  Do you implement pointer zapping?
21:36:43 <dmg_> So I need something to check where those leaks come from - there must be circular refs unbroken.
21:37:56 <dmg_> Yes, I wrote ycr2js. I am trying to finalize the main stuff, and the cnoice between plain CPS and monadic, if possible, is important.
21:38:09 <sclv> this is pretty slick.
21:38:22 <dmg_> Just more people would like monadic. To me, no much difference though. But thinking of possible users...
21:39:22 <dmg_> sorear: I tried where I could. Basically the only pointer I could zap is the pointer to the event just received after it was used.
21:40:05 <dmg_> The whole thing is based on the delimiter for the Cont monad I wrote - there was a discussion on Cafe.
21:40:20 <sorear> dmg_: you have two components, if I'm not mistaken
21:40:37 <sorear> dmg_: a large chunk of Haskell which implements funky monads and mangles the DOM
21:40:50 <sorear> dmg_: and a compiler which produces Javascript from YHC CORE
21:40:51 <dmg_> I save the remainder of computation basically as event handler and exit When an event arrives, it continues where stopped.
21:41:20 <dmg_> sorear: yes there are two things, but closely related.
21:42:12 <sorear> dmg_: my intuition is that ycr2js mangles the code sufficiently that monadic and CPS Haskell tickle the same patterns at a lower level
21:42:26 <hajamie> Hullo, I'm a little confused.  Could anyone explain the following line of code to me? : map (:x) [(head x)..n-1])
21:42:48 <sorear> dmg_: going from this, we see that the correct behaviour of FF strongly suggests that non-leaky Haskell exists
21:42:50 <dmg_> I'm afraid, this does not have to do with DOM; this is the executed part of the computation that does not purge.
21:43:06 <sorear> dmg_: since if the Haskell was leaky, FF would not be able to reliably purge
21:43:07 <dmg_> sorear: yes
21:43:22 <oerjan> > let x = [1,2,3] in map (:x) [(head x)..n-1])
21:43:22 <lambdabot> Unbalanced parentheses
21:43:33 <oerjan> > let x = [1,2,3] in map (:x) [(head x)..n-1]
21:43:34 <lambdabot>   Not in scope: `n'
21:43:45 <oerjan> > let x = [1,2,3]; n=4 in map (:x) [(head x)..n-1]
21:43:46 <lambdabot>  [[1,1,2,3],[2,1,2,3],[3,1,2,3]]
21:43:53 <sorear> dmg_: so we see that the problem must be in either ycr2js proper or MSIE.
21:43:56 <hajamie> heh cool!
21:44:05 <sorear> dmg_: you talk about zonking events
21:44:06 <dmg_> OK, does anybody know of a tool I asked, to detect memory leaks in MSIE?
21:44:17 <sorear> dmg_: why does ycr2js proper *know* about events?
21:44:25 <sclv> > let x = [2,3,4]; n=4 in map (:x) [(head x)..n-1]
21:44:26 <lambdabot>  [[2,2,3,4],[3,2,3,4]]
21:44:34 <sclv> > let x = [3,4,5]; n=4 in map (:x) [(head x)..n-1]
21:44:35 <lambdabot>  [[3,3,4,5]]
21:45:15 <dmg_> ycr2js does not know about events. It is garbage collector in FF that works more correctly than MSIE, this is a known fact.
21:45:36 <hajamie> Thanks!  I guess I should have tried that...
21:45:47 <sclv> dmg_: MSIE has a frikin awful developer toolkit -- there's some way to set it so that it can drop you into the visualbasic framework but i've never gotten it to work.
21:45:53 <oerjan> hajamie: (:x) is a function that prepends its argument to the list x
21:46:24 <dmg_> Well, right, no quick answer...
21:46:48 <oerjan> and map (:x) l prepends _every_ element of l to x in turn, collecting the resulting list
21:47:52 <dmg_> I'm just wondering how much would plain CPS be uncomfortable to code in, comparing to monadic? Not for me, but does anybody here have general objections to plain CPS?
21:47:59 <sclv> http://www.jonathanboutelle.com/mt/archives/2006/01/howto_debug_jav.html
21:48:00 <lambdabot> Title: HOW-TO: Debug JavaScript in Internet Explorer, http://tinyurl.com/py2zz
21:48:43 <dmg_> Hmm, would that run in Wine?
21:49:06 <dmg_> But thanks sclv, I'll definitley look into this.
21:49:28 <sclv> beats me -- whenever I tried to even get it to run on NT it just froze my computer.
21:49:36 <xpika> @pl (\[x,y,z]-> f) [0,1,0]
21:49:36 <lambdabot> (line 1, column 3):
21:49:36 <lambdabot> unexpected "["
21:49:36 <lambdabot> expecting pattern
21:50:06 <sclv> pl only pattern matches on tuples.
21:50:11 <mauke> xpika: f
21:50:22 <oerjan> and only two-tuples at that
21:50:24 <dmg_> OK thanks for the discussion, hopefully we continue it some time later, I've got to be going. But if anybody has thoughts on CPS vs monadic, please just post them here, I'll read the log.
21:50:26 <dmg_> Bye all.
21:51:09 <sclv> @pl \(a,(b,c)) -> a:b:c
21:51:09 <lambdabot> uncurry ((`ap` snd) . (. fst) . (. (:)) . (.) . (:))
21:51:17 <sclv> but on nested two tuples!
21:52:08 <sclv> @unpl uncurry ((`ap` snd) . (. fst) . (. (:)) . (.) . (:))
21:52:08 <lambdabot> uncurry (\ i -> (\ u f -> ((:)) i (((:)) (fst u) f)) >>= \ z -> snd >>= \ y -> return (z y))
21:52:39 <oerjan> shockingly, @. @unpl @pl is not the identity.
21:52:40 <dmwit> ?pl \(a,(b,c)) -> [a,b,c]
21:52:41 <lambdabot> uncurry ((`ap` snd) . (. fst) . (. ((. return) . (:))) . (.) . (:))
21:53:03 <xpika>  @pl (\[x,y,z] -> f x y z) [0,1,0]
21:53:07 <mauke> @. djinn type \(a,(b,c)) -> [a,b,c]
21:53:13 <lambdabot> -- f cannot be realized.
21:53:23 <dmwit> xpika: f 0 1 0 -- ;-)
21:53:43 <dmwit> xpika: What are you really looking for?
21:54:12 <hajamie> oerjan++
21:54:13 <xpika> @pl (\[x,y,z] -> f x y z)
21:54:13 <lambdabot> (line 1, column 3):
21:54:13 <lambdabot> unexpected "["
21:54:13 <lambdabot> expecting pattern
21:54:20 <xpika> that
21:54:40 <mauke> @pl (\xs -> f (head xs) (head (tail xs)) (head (tail (tail xs))))
21:54:40 <lambdabot> ap (liftM2 f head (head . tail)) (head . tail . tail)
21:54:59 <dmwit> ?pl \xs -> f (xs !! 0) (xs !! 1) (xs !! 2)
21:54:59 <lambdabot> ap (liftM2 f (!! 0) (!! 1)) (!! 2)
21:55:36 <dmwit> :t liftM3 f (!!0) (!!1) (!!2)
21:55:37 <lambdabot> Not in scope: `f'
21:55:44 <mauke> (funcall f (car xs) (cadr xs) (caddr xs))
21:55:56 <dmwit> :t \f -> liftM3 f (!!0) (!!1) (!!2)
21:55:56 <lambdabot> forall r a. (a -> a -> a -> r) -> [a] -> r
21:56:30 <conal> :t \f -> liftA3 f (!!0) (!!1) (!!2)
21:56:31 <dmwit> I guess ?pl doesn't know about liftM3, eh?
21:56:31 <lambdabot> forall d a. (a -> a -> a -> d) -> [a] -> d
21:57:00 <oerjan> @pl \x -> f (g x) (h x) (i x)
21:57:00 <lambdabot> ap (liftM2 f g h) i
21:57:09 <oerjan> hm, apparently not
21:57:12 <mauke> who needs liftM9000 when you have ap
21:57:18 <dmwit> :t \f -> return f `ap` (!!0) `ap` (!!1) `ap` (!!2)
21:57:26 <lambdabot> forall b a. (a -> a -> a -> b) -> [a] -> b
21:57:32 <conal> :t \f -> f <$> (!!0) <*> (!!1) <*> (!!2)
21:57:33 <lambdabot> forall b a. (a -> a -> a -> b) -> [a] -> b
21:57:41 <dmwit> Now, how can we make this work.
21:58:18 <mauke> S (S (S (K f) (!!0)) (!!1)) (!!2)
21:59:06 <sclv> the !! queries are awful. so much duplicated work.
21:59:07 <dmwit> :t iterate
21:59:10 <lambdabot> forall a. (a -> a) -> a -> [a]
21:59:33 <dmwit> I think we need type-level lists to make this any nicer. =/
22:00:02 <dmwit> But \[x, y, z] -> f x y z is already pretty nice, so why bother? =)
22:00:15 <sclv> the pattern matching solution, though pointy, is actually nice and efficient though, yeah.
22:00:29 <dmwit> Or, you could define f [x, y, z] and just use that version of f instead.
22:00:50 <mauke> @pl \xs -> let x = head xs; xs' = tail xs; y = head xs'; xs'' = tail xs'; z = head xs'' in f x y z
22:00:52 <lambdabot> ap ((`ap` head) . (. tail) . flip . flip flip head . ((.) .) . f . fix . const . head) tail
22:01:00 <sclv> maybe it could be better as \x:y:z:xs so that you can use it on an arbitrary length list.
22:01:17 <dmwit> What do you do for short lists?
22:01:28 <sclv> pattern match failure.
22:01:33 * oerjan considers something with uncurry and splitAt 1 ...
22:01:51 <dmwit> :t \f (x:xs) -> (f x, xs)
22:01:57 <oerjan> oh wait, the first pair is a list too
22:01:57 <lambdabot> forall t t1. (t -> t1) -> [t] -> (t1, [t])
22:02:02 <oerjan> *of the pair
22:02:30 <sclv> @unpl p ((`ap` head) . (. tail) . flip . flip flip head . ((.) .) . f . fix . const . head) tail
22:02:30 <lambdabot> p (\ u -> (\ at e -> f (fix (\ _ -> head u)) e (head (tail at))) >>= \ ay -> head >>= \ ax -> return (ay ax)) tail
22:03:10 <sclv> @do p (\ u -> (\ at e -> f (fix (\ _ -> head u)) e (head (tail at))) >>= \ ay -> head >>= \ ax -> return (ay ax)) tail
22:03:10 <lambdabot> p (\ u -> (\ at e -> f (fix (\ _ -> head u)) e (head (tail at))) >>= \ ay -> head >>= \ ax -> return (ay ax)) tail not available
22:03:21 <sclv> @redo p (\ u -> (\ at e -> f (fix (\ _ -> head u)) e (head (tail at))) >>= \ ay -> head >>= \ ax -> return (ay ax)) tail
22:03:21 <lambdabot> p (\ u -> do { ay <- (\ at e -> f (fix (\ _ -> head u)) e (head (tail at))); ax <- head; return (ay ax)}) tail
22:03:28 <dmwit> :t let apply1 (f, x:xs) = (f x, xs) in \f xs -> apply1 (apply1 (apply1 (f, xs)))
22:03:29 <lambdabot> forall t t1. (t -> t -> t -> t1) -> [t] -> (t1, [t])
22:03:35 <conal> what does it take to get ghc to pull computations out of lambda?
22:03:46 <mauke> fix (\_ -> ...)? genius!
22:04:34 <dmwit> :t let apply1 (f, x:xs) = (f x, xs) in head . apply1 . apply1 . apply1 . uncurry
22:04:34 <lambdabot>     Couldn't match expected type `(t -> t1, [t])'
22:04:34 <lambdabot>            against inferred type `(a, b) -> c'
22:04:34 <lambdabot>     In the second argument of `(.)', namely `uncurry'
22:04:37 <sclv> wtf would that even do?
22:04:46 * sclv still gets easily befuddled by fix
22:05:04 <mauke> sclv: \_ -> ... is const
22:05:09 <mauke> fix . const == id
22:05:22 <dmwit> :t let apply1 (f, x:xs) = (f x, xs) in uncurry $ head . apply1 . apply1 . apply1
22:05:23 <lambdabot>     Couldn't match expected type `[a]'
22:05:23 <lambdabot>            against inferred type `(t1, [t])'
22:05:23 <lambdabot>     In the second argument of `(.)', namely
22:05:26 <sclv> > fix (\_ -> 12) 5
22:05:27 <lambdabot>   add an instance declaration for (Num (t -> a))
22:05:27 <lambdabot>     In the expression: 12
22:05:27 <lambdabot>   ...
22:05:29 <mauke> > fix (\ _ -> 42)
22:05:30 <lambdabot>  42
22:05:33 <sclv> > fix (\_ -> 12)
22:05:33 <dmwit> Oh, right.
22:05:34 <lambdabot>  12
22:05:57 <mauke> > fmap fix return "zomg"
22:05:58 <lambdabot>  "zomg"
22:06:15 <sclv> oh right, i remember this conversation
22:06:38 <sclv> @quote fmap.fix
22:06:38 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
22:06:47 <mauke> return == const
22:06:48 <dmwit> ?pl \f xs -> head (apply1 (apply1 (apply1 (f, xs))))
22:06:48 <lambdabot> ((head . apply1 . apply1 . apply1) .) . (,)
22:08:01 * dmwit wants something like (iterate apply1 (f [x,y,z]) !! 3), but it doesn't really typecheck
22:08:15 <dmwit> It would require heterogeneous lists, I think.
22:10:05 <luqui> Can I import hiding a constructor but not the type it constructs?
22:10:14 <sclv> would arrows help?
22:10:49 <mauke> luqui: sure, why not?
22:10:54 <dmwit> luqui: Yes, I think so.
22:11:01 <luqui> I'm not sure what the syntax would be
22:11:05 <mauke> happens all the time if you import e.g. Data.Map
22:11:28 <dmwit> import Data.Maybe hiding Just
22:11:32 <dmwit> import Data.Maybe hiding (Just)
22:11:38 <luqui> oh, I mean if they are named the same
22:12:07 <dmwit> import Data.Maybe hiding (Maybe(Maybe)) -- I think
22:12:20 <luqui> Maybe(Just) of course you mean
22:12:26 <luqui> hmm, I'll try that
22:12:32 <dmwit> Sure, but then they're not named the same. =)
22:12:39 <luqui> heh :-)
23:07:53 <sjanssen> dons: this chameneos entry may be cheating
23:12:52 <sjanssen> dons: nevermind
23:13:12 <dons> sjanssen: meet, count, yield, print results?
23:13:23 <sjanssen> dons: the original
23:13:28 <dons> the new spec just seems more annoying than anythign.
23:13:33 <sjanssen> but I was just confused by waker
23:13:35 <dons> oh, why? too cooperatiive?
23:13:36 <sjanssen> dons: are you working on it?
23:13:44 <sjanssen> dons: I thought so, but it's fine
23:14:07 <dons> i did most of it, but got stopped on the complement/next arrive part
23:14:15 <dons> since now we don't just have colours, but ids too
23:14:28 <dons> so how do you set which thread to arrive
23:14:53 <dons> i might have misunderstood it though
23:15:46 <sjanssen> this "spelling out" stuff is stupid
23:16:35 <dons> yeah, i have no idea what they're thinking
23:16:46 <dons> same with printing the complement table, and printing the colours that start
23:17:02 <sjanssen> all that to avoid writing a (trivial) parser for the input
23:17:28 <sjanssen> though, to be honest, the Haskell code for those parts will be quite elegant :)
23:17:54 <sjanssen> countOut = map (!! ["zero", "one", etc.]) . show
23:18:51 <dons> mm
23:37:26 <osfameron> morning
23:42:16 <xpika> [ print x | x <-  [1,2,3]]
23:49:48 <xpika> I once saw someone use IO in a list comprehenion. does anyone know how to do that?
23:50:00 <TSC> Just like that
23:50:13 <TSC> That gives you a list of IO actions, [IO ()]
23:50:27 <TSC> You can convert that into a single action with sequence
23:50:29 <TSC> @type sequence
23:50:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:50:44 <TSC> Then you've got a single action that will print 1, then 2, then 3
23:50:58 <TSC> Of course, you can do other things with the list before sequencing it
23:51:07 <TSC> (say, reverse it, so you get 3 2 1 instead)
23:51:37 <TSC> sequence just says "put these monadic values together, in order"
23:51:48 <TSC> In the case of the IO monad, that means "execute these one after another"
23:51:52 <TSC> And that's that
23:57:41 <sjanssen> @pl \b x -> if b then x else x+1
23:57:42 <lambdabot> (`ap` (1 +)) . if'
