00:40:58 <RogerTaylor> Hello
00:41:24 <RogerTaylor> If one were to write a new program using regexps in Haskell, what is the appropriate package to use?
00:41:53 <RogerTaylor> For GHC 6.6.1, we have: regex-base-0.72, regex-compat-0.71, regex-posix-0.71
00:42:16 <RogerTaylor> and I'd like to use the one that's likely to be in the forthcoming GHC's, if possible
00:47:33 --- mode: ChanServ set +o sjanssen
00:49:25 --- mode: sjanssen set -o sjanssen
01:03:58 * osfameron reads the haskell-cafe post on the Prompt monad
01:04:41 <kowey> for fellow bikeshed painters out there: http://jottit.com/mzqbp/
01:04:42 <lambdabot> Title: Home
01:06:08 <osfameron> the second version
01:07:30 <vincenz> osfameron: link?
01:08:52 <osfameron> vincenz: the Prompt post?  <quick search on ml...> here you go, http://www.haskell.org/pipermail/haskell-cafe/2007-November/034830.html
01:08:53 <lambdabot> Title: [Haskell-cafe] An interesting monad: "Prompt", http://tinyurl.com/3y2b8c
01:09:05 <vincenz> gracias
01:26:54 <dmwit> kowey: fmap firstNotBlank $ get_preflist "author" -- my preferred way
01:27:10 <dmwit> Well, I prefer liftM over fmap, but just because I learned it first. =)
01:27:39 <bakert> is there a better way of saying second-element-in-list than (head . drop 1) ?
01:27:46 <dmwit> (!!1)
01:28:08 <bakert> merci
01:30:13 <osfameron> cadr? ;-)
01:30:18 <bakert> :)
01:33:32 <bakert> data Foo = Bar | Baz | Quuz String; isQuux (Quux _) = True; isQuuz _ = False
01:33:39 <bakert> is there a better way of doing isQuux?
01:34:21 <bakert> oh, ignore the fact that i randomly changed the x for a z there :)
01:34:34 <bakert> tice
01:34:37 <bakert> *twcie
01:34:41 <bakert> gah!
01:34:43 <bakert> *twice
01:34:50 <bakert> oh dear.  back to keyboard school for me.
01:35:20 <bakert> still, question remains ... is there a one-liner version of isQuux?
01:35:49 <bakert>     data Foo = Bar | Baz | Quux String; isQuux (Quux _) = True; isQuux _ = False
01:35:54 <bakert> is the correct version :)
01:38:41 <bakert> ?src liftM2
01:38:41 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:38:55 <masak> ?src liftM
01:38:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:39:19 <bakert> i'm messing about with ?pl and it has offered me liftM2 ... which i don't totally get.
01:39:39 <bakert> (\x -> pred x && not (elem x ls))
01:39:41 <bakert> =>
01:39:42 <gvdm> two arguments, not one
01:39:47 <gvdm> same idea
01:39:54 <bakert> ?pl (\x -> pred x && not (elem x ls))
01:39:54 <lambdabot> liftM2 (&&) pred (not . flip elem ls)
01:40:11 <bakert> crazee
01:40:14 <mauke> bakert: do you know Reader?
01:40:19 <bakert> no
01:40:23 <bakert> but i have been asked taht before
01:40:26 <bakert> so maybe i should :)
01:40:43 <mauke> the Reader monad passes a value to all subcomputations
01:40:50 <mauke> it can be accessed with x <- ask
01:41:02 <bakert> cool.  so you don't have to pass state around all the time?
01:41:15 <mauke> yeah
01:41:26 <mauke> (though unlike State, you can't change it)
01:41:37 <bakert> oh ok
01:41:57 <mauke> > runReader (do { x <- ask; y <- ask; return [x, y]}) 42
01:41:59 <lambdabot>  [42,42]
01:42:21 <mauke> ok, that's not a very good example
01:42:34 <bakert> i get it though.
01:42:58 <mauke> well, function arguments are also a kind of state
01:43:30 <bakert> err ... ok
01:43:43 <mauke> you write \x -> ... and anywhere in the body you can say x to get the state
01:43:50 <bakert> right
01:43:54 <bakert> makes sense
01:44:14 <mauke> if you look at the implementation of Reader, you can see that it works exactly the same way
01:44:30 <mauke> newtype Reader e a = Reader (e -> a)
01:44:43 <mauke> i.e. it turns the hidden state into function arguments
01:44:53 <mauke> or rather, a function argument
01:45:06 <hpaste>  ddvlad pasted "State monad headaches" at http://hpaste.org/3970
01:45:20 <mauke> ok?
01:45:27 <bakert> yep
01:45:29 <bakert> i follow
01:45:32 <bakert> i think :)
01:45:43 <bakert> so liftM2
01:45:46 <mauke> well, it turns out you don't need the Reader wrapper
01:45:53 <mauke> type Reader' e a = e -> a
01:46:09 <mauke> you can just make (e ->) an instance of Monad
01:47:05 <mauke> instance Monad ((->) e) where return x = \e -> x; m >>= f = \e -> f (m e) e
01:47:33 <bakert> golly
01:48:00 <bakert> not familiar with using -> like a function like that
01:48:09 <bakert> but sort of half makes sense :)
01:48:17 <bakert> :t (->)
01:48:19 <lambdabot> parse error on input `->'
01:48:22 <bakert> hmm
01:48:23 <bakert> :(
01:48:24 <mauke> you mean the partial application? ((->) e) a == (e -> a)
01:48:43 <bakert> i was looking at "Monad ((->) e)"
01:48:49 <mauke> yeah
01:48:56 <mauke> (->) is just another type constructor
01:49:05 <bakert> oh really
01:49:09 <bakert> interesting
01:49:14 <mauke> it takes two arguments
01:49:34 <bakert> i see
01:50:04 <mauke> > (do { x <- ask; y <- ask; return [x, y]}) 42
01:50:09 <lambdabot>  [42,42]
01:50:15 <mauke> see? no runReader
01:50:34 <bakert> i see
01:50:57 <bakert> but liftM2 doesn't use ask, it uses something else?
01:51:06 <mauke> it uses >>=
01:51:27 <mauke> it comes down to return = const, ask = id, liftM2 c f g x = f x `c` g x
01:51:33 <bakert> so where the above code calls ask it does the binding thing to get the values to use in the function
01:53:56 <bakert> ok i get it.  at least for my limited example i can see what it is doing, anyway.  thanks mauke!
01:54:04 <mauke> ddvlad: change :: Int -> State [Bool] ()
01:54:26 <mauke> change n = do { v <- get; put (transform n v) }
01:54:40 <ddvlad> mauke: hmm... that would mean that the computation yields no result, right?
01:54:50 <mauke> right
01:57:07 <ddvlad> mauke: now I get some error at execState. my guess is that here lies the terribly wrong and clumsy part
01:58:08 <mauke> oh yeah, execState (change 2)
01:59:44 <mauke> vec = replicate 3 False
02:00:34 <ddvlad> wow. it worked :-o
02:00:52 <ddvlad> thank you very much. i'm off to understand all of this :-)
02:01:36 <Morningsickness> Depakote (GNAP) - Chicago, Illinois, USA - A group of GNAA members were shocked to find that Church of Scientology founder L. Ron Hubbard was once indeed a bona fide gay nigggger. "I am confident that Hubbard's theory of Dianetics leans more to the fag side", said GNAA Spokesperson Jmax. "After a long and arduous journey through the galaxy I am proud to finally see the Church of Scientology and Gay Niggggger Associa
02:01:37 <Morningsickness> The Church of Scientology first took it's interest in the GNAA after a surprise shift of disgruntled members after the decomposition of Terri Schaivo, many including GNAA leader timecop, now OT 13, has converted to Scientology. "I began scientology as a fat, gay, gook, and a coke addict; now thanks to purification run-down, my body is clear of thetans and impurity, allowing my seed to descend into a new generation o
02:01:38 <Morningsickness> About Church of Scientology:
02:01:40 <Morningsickness> The Church of Scientology was founded by known Science Fiction Writer L. Ron Hubbard and his theory of Dianetics. Dianetics is Modern Science of Mental Health, a patented method proving that psychiatry is indeed a plot by jews to control of the minds of all human beings. As of 2006 Scientology is now raking in over 3 Trillion dollars (.USD) a quarter, with over 15 million active followers world-wide, including GNAA 
02:01:44 <mauke> wb
02:01:55 <Morningsickness> good shit
02:01:58 <Morningsickness> lol
02:02:37 <osfameron> huh?
02:02:54 <mauke> he just got kb'd from #perl
02:03:01 <jeffz> ... and ##c
02:03:23 <ddvlad> that was... enlightening
02:04:15 <matthew-_> presumeably it's also wrong. I know no details about scientology but anti-semitism seems unlikely no?
02:04:33 <osfameron> they are certainly anti-psychiatry
02:04:40 <jeffz> undoubtedly, GNAA are a trolling group.
02:04:44 <ddvlad> matthew-_: did you actually read all that? :o)
02:04:52 <vincenz> pricks
02:05:03 <vincenz> who kbd
02:06:58 <matthew-_> jeffz: gnaa.us seems to suggest so
02:08:25 <gvdm> gah! matthew-_ never give out links to trolls, somebody, at the end of some IRC connection, will follow it
02:08:43 <mauke> that's not a link
02:09:10 <osfameron> some user agents will format it as a link
02:09:12 <gvdm> yeah it is, just chuck gnaa.org in your web browser
02:09:20 <gvdm> :P
02:09:42 <matthew-_> ok, the first time I saw that website, I assumed it was a piss-take. Now I'm not so sure!
02:10:12 <EvilTerran> iirc, they're a splinter group from SomethingAwful
02:10:17 <osfameron> people believe crazy things, sometimes it's difficult to pretend to be crazier for the purpose of satire
02:10:36 <matthew-_> plus, it's raining here
02:10:57 <EvilTerran> who didn't think SA had enough stupid drivel, apparently
02:11:29 <ibid> GNAA is a known troll group
02:11:43 <ibid> it's been known to cause disruption in freenode channels before
02:11:55 <ibid> (though this was the first time i've actually witnessed it)
02:12:15 <ddvlad> and slashdot... they reguarly appear on slashdot
02:12:45 <matthew-_> gosh. are there no depths to which they won't sink?
02:13:11 <ddvlad> matthew-_: don't you like slashdot?
02:13:19 <gvdm> #gentoo is taking a savaging
02:13:58 <gvdm> ddvlad: slashdot died a long time ago, now its just the masses
02:14:40 <ddvlad> hmm... i suppose i have no means of comparing, i only got there a couple of years ago
02:14:57 <ibid> they do have archives, i think
02:15:01 <matthew-_> though tbh, I don't take part in any online forum type stuff. Emails are good.
02:16:30 <ddvlad> slashdot is fun with all the memes and groupthink, but its programing reddit where i first heard of haskell. i remain forever in debt
02:19:01 <matthew-_> I really have better things to do with my time than have arguments about monads or functional programming or message passing ... that's why I like #haskell. There are never arguments (well, very few). There are many interesting discussions though
02:35:17 * sjanssen starts an argument about message passing monads in functional programming
02:40:37 <ricky_clarkson> I hope it terminates.
02:41:04 <matthew-_> seems it hit the base case immediately
02:41:41 <EvilTerran> i was thinking it got killed by lambdabot after running for more than three seconds
02:50:49 <Taejo> @pl apply f x = f x
02:50:50 <lambdabot> apply = id
02:51:03 <Taejo> @type \ f x -> f x
02:51:05 <lambdabot> forall t t1. (t -> t1) -> t -> t1
02:51:10 <Taejo> @type apply
02:51:11 <lambdabot> Not in scope: `apply'
02:51:17 <Taejo> @type id
02:51:18 <lambdabot> forall a. a -> a
02:51:18 <scook0> @type ($)
02:51:19 <lambdabot> forall a b. (a -> b) -> a -> b
02:51:55 <Taejo> scook0, so ($) and id are equal, but they have different types?
02:52:02 <resiak> @type \x -> (`id` x)
02:52:05 <lambdabot> forall t t1. t -> (t -> t1) -> t1
02:52:34 <Taejo> @pl \x -> (`id` x)
02:52:35 <lambdabot> flip id
02:53:09 <matthew-_> I really like zipWith id or zipWith ($)
02:53:18 <EvilTerran> @src ($)
02:53:19 <lambdabot> f $ x = f x
02:53:23 <scook0> Taejo: ($)'s type is more restricted
02:53:26 <EvilTerran> @pl ($)
02:53:26 <lambdabot> id
02:54:08 <Taejo> > map ($) [1..10]
02:54:16 <lambdabot>   add an instance declaration for (Num (a -> b))
02:54:16 <lambdabot>     In the expression: 10
02:54:42 <EvilTerran> > map ($2) [(+1), (^2), (*3), negate]
02:54:43 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
02:54:47 <scook0> > map ($ 1) [(+1), (+2)]
02:54:52 <lambdabot>  [2,3]
02:54:54 <EvilTerran> > map ($ 2) [(+1), (^2), (*3), negate] --?
02:54:55 <lambdabot>   parse error on input `}'
02:55:20 <EvilTerran> > map ($ 2) [(+ 1), (^ 2), (* 3), negate] -- wtf?
02:55:27 <lambdabot>  [3,4,6,-2]
02:55:40 <EvilTerran> weird
02:55:52 <ToRA> sequence  [(+1), (^2), (*3), negate] 2
02:56:00 <ToRA> > sequence  [(+1), (^2), (*3), negate] 2
02:56:14 <lambdabot>  [3,4,6,-2]
02:56:23 <scook0> curious
02:56:35 <ddvlad> funcs = map (\ k b -> execState (change k) b) [5..1] -- shouldn't this give me a list of functions? b is bool, so I should get [Bool]->[Bool], right?
02:56:43 <Taejo> @src sequence
02:56:43 <lambdabot> sequence ms = foldr k (return []) ms
02:56:43 <lambdabot>     where
02:56:43 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
02:57:11 <ddvlad> i get an empty list (of type [Bool]->[Bool] though)
02:57:26 <ToRA> >[5..1]
02:57:28 <ToRA> > [5..1]
02:57:31 <ToRA> > [5,4..1]
02:57:34 <ricky_clarkson> The map and sequence above seem to make sense, why are they curious?
02:57:43 <lambdabot>  thread killed
02:57:43 <lambdabot>  [5,4,3,2,1]
02:58:07 <ddvlad> i get an empty list -- shouldn't there be 5 functions in the list/
02:58:12 <ToRA> ddvlad:
02:58:13 <ToRA> Prelude> [5..1]
02:58:13 <ToRA> []
02:58:23 <ToRA> that is why you get an empty list ;)
02:58:27 <ddvlad> > [5,4..1]
02:58:29 <lambdabot>  [5,4,3,2,1]
02:58:33 <matthew-_> it'll try and go up the enum, rather than down, unless you tell it explicitly
02:58:55 <ricky_clarkson> > [1,2,4..]
02:58:56 <lambdabot>  Parse error at "..]" (column 7)
02:58:56 <ddvlad> d'oh, there i was worrying my whole perception of map and currying was wrong
02:59:38 <ricky_clarkson> > let a=5 in [a..]
02:59:40 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
02:59:55 <ricky_clarkson> > let a=5 in let b=11 in [a,b..]
02:59:59 <lambdabot>  [5,11,17,23,29,35,41,47,53,59,65,71,77,83,89,95,101,107,113,119,125,131,137,...
03:00:11 <ricky_clarkson> I like that it's not restricted to constant expressions.
03:00:35 <ddvlad> > let a=5 in [a,(a-1),..1]
03:00:36 <lambdabot>  Parse error at "..1]" (column 21)
03:00:40 <ddvlad> > let a=5 in [a,(a-1)..1]
03:00:41 <lambdabot>  [5,4,3,2,1]
03:01:29 <ToRA> > let a = 5 in enumFromThenTo a (pred a) 1
03:01:30 <lambdabot>  [5,4,3,2,1]
03:02:20 <ddvlad> ToRA: isn't that a bit too verbose?
03:02:43 <ToRA> ddvlad: yeah course, just showing that it's all just sugar
03:02:53 <ddvlad> oh. i see
03:03:09 <ToRA> and you can change the meaning of it if you ever wanted, since enumFromThenTo is in the Enum class
03:04:10 <matthew-_> > do { a <- [1..]; b <- [1..]; take 10 [a,b..] }
03:04:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,1,3,5,7,9,11,13,15,17,19,1,4,7,10,...
03:04:19 <matthew-_> > do { a <- [1..]; b <- [1..]; take 5 [a,b..] }
03:04:20 <lambdabot>  [1,1,1,1,1,1,2,3,4,5,1,3,5,7,9,1,4,7,10,13,1,5,9,13,17,1,6,11,16,21,1,7,13,1...
03:04:56 <Tobsan> @src takeWhile
03:04:56 <lambdabot> takeWhile _ []                 =  []
03:04:56 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:04:56 <lambdabot>                    | otherwise =  []
03:05:06 <Tobsan> ty
03:07:47 <ToRA> > [1..] >>= take 5 . enumFromThen 1
03:07:48 <lambdabot>  [1,1,1,1,1,1,2,3,4,5,1,3,5,7,9,1,4,7,10,13,1,5,9,13,17,1,6,11,16,21,1,7,13,1...
03:08:00 <ddvlad> wow... i finally made it. is it ok if i paste a few lines? there is certainly a better way to do it
03:08:58 <matthew-_> if it's more than two lines, it might be better to use hpaste.org/new
03:09:18 <ddvlad> matthew-_: that's what i meant, sorry
03:09:27 <matthew-_> :)
03:10:01 <hpaste>  ddvlad annotated "State monad headaches" with "Working now, though I've probably slaughtered some of the beauty of Haskell." at http://hpaste.org/3970#a1
03:10:38 <ToRA> ddvlad: change n = modify (transform n) ?
03:11:12 <ddvlad> ToRA: hmm... must look up modify
03:11:22 <mauke> @src modify
03:11:22 <lambdabot> Source not found. My mind is going. I can feel it.
03:11:37 <ToRA> :t modify
03:11:38 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:11:55 <mauke> modify f = do { x <- get; put (f x) }
03:12:11 <matthew-_> hmm. modify is really the dual of liftM except on the state param rather than the monad param
03:13:33 <ddvlad> i'm really proud of that foldr in the last line. my first idea was just to apply all functions in a recursion
03:13:49 <ToRA> doesn't foldr (.) id = sequence in  this case?
03:13:54 <ToRA> oh no
03:13:55 <ToRA> ignore me
03:15:11 * osfameron peeks at the "ABC of Category Theory" and is lost by the first example "Everyone knows that the ‘canonical’ way to turn an integral
03:15:15 <osfameron> domain into a field is to take its field of fractions."
03:15:54 <integral> osfameron: that is, looking at things like a/b where a and b are picked from some integral domain
03:16:51 <doserj> that's just a generalization of "rational numbers are fractions of integer numbers"
03:17:27 <ddvlad> why does the "n = read line" fail with "Not in scope: line" ?
03:17:47 <ddvlad> (the commented text in my paste)
03:19:53 <ToRA> ddvlad: variables declared in a do block arn't in scope inside an attached where clause
03:20:04 <doserj> see http://www.haskell.org/haskellwiki/Let_vs._Where
03:20:07 <lambdabot> Title: Let vs. Where - HaskellWiki
03:20:19 <ddvlad> so, let would work?
03:20:28 <osfameron> integral, doserj: I guess that "ABC" is still "As long as you have some recent maths study."  I'm sure it's perfectly clear, it's just in a language I don't speak...
03:20:46 <doserj> the language is called maths :)
03:20:55 * integral thinks that was 2nd year vocabulary for himself
03:21:29 <osfameron> yeah, that language :-)
03:24:00 <yaxu> > map (\x -> (head x, length x)) $ List.group . List.sort $ "jackdaws love my big sphynx of quartz"
03:24:02 <lambdabot>  [(' ',6),('a',3),('b',1),('c',1),('d',1),('e',1),('f',1),('g',1),('h',1),('i...
03:24:45 <vincenz> ABC = activity-based ... something
03:24:59 <vincenz> yaxu:
03:25:16 <vincenz> > (head &&& length) . group . sort $  "jackdaws love my big sphynx of quartz"
03:25:18 <lambdabot>  ("      ",27)
03:25:29 <vincenz> > map (head &&& length) . group . sort $  "jackdaws love my big sphynx of quartz"
03:25:29 <lambdabot>  [(' ',6),('a',3),('b',1),('c',1),('d',1),('e',1),('f',1),('g',1),('h',1),('i...
03:26:32 <kfish> nice frequency table!
03:31:36 <ddvlad> i'm off to school. thanks for the help everyone, it's real fun knowing there's an expert to turn to
03:33:37 <yaxu> @src &&&
03:33:37 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
03:34:20 <yaxu> vincenz: hm, thanks :)
03:34:28 <vincenz>  > [1..] >>= scanl (+) 0 . take 5 . enumFromThen 1
03:34:35 <vincenz> > [1..] >>= scanl (+) 0 . take 5 . enumFromThen 1
03:34:37 <lambdabot>  [0,1,2,3,4,5,0,1,3,6,10,15,0,1,4,9,16,25,0,1,5,12,22,35,0,1,6,15,28,45,0,1,7...
03:39:48 <fxr> any hxt developers here?
03:47:17 <hpaste>  Sewardsas pasted "louis purse used vuitton" at http://hpaste.org/3971
03:48:19 <yaxu> what's the practical difference between '$' and '.' ?
03:48:45 <ToRA> precedence
03:49:02 <Syzygy-> Also you can do function $ value, but not function . value
03:49:16 <Syzygy-> Or ... couldn't.
03:49:28 <Syzygy-> > (+1) $ 2
03:49:30 <lambdabot>  3
03:49:33 <Syzygy-> > (+1) . 2
03:49:34 <lambdabot>   add an instance declaration for (Num (a -> b))
03:50:43 <yaxu> thanks
03:52:01 <yaxu> and by precedence you mean that you can't do this
03:52:07 <yaxu> > (+1) . (*2) 1
03:52:07 <lambdabot>   add an instance declaration for (Num (a -> b))
03:52:11 <yaxu> but can do this
03:52:16 <yaxu> > (+1) $ (*2) 1
03:52:17 <lambdabot>  3
03:52:30 <yaxu> ?
03:52:31 <scook0> > (+1) . (*2) $ 1
03:52:32 <lambdabot>  3
03:52:34 <scook0> :)
03:52:39 <resiak> why doesn't . bind more tightly than application?
03:52:48 <resiak> oh, that's a stupid question
03:52:49 <resiak> ignore me.
03:52:51 <yaxu> scook0: that's what i mean
03:52:53 <scook0> resiak: because application binds more tightly than everything
03:52:59 <SamB_XP> yeah, duh
03:53:16 <scook0> heck, even unary minus binds less than application
03:53:19 <resiak> yeah, i know that it _does_, but was wondering why.  then i considered foo x . g
03:53:25 <scook0> (which causes fun bugs)
03:53:41 <SamB_XP> scook0: "fun" is not the word
03:53:44 <byorgey> yaxu: beware though, ($) and (.) are not at all the same function.
03:53:49 <SamB_XP> we should go the smalltalk route or something
03:53:52 <scook0> resiak: there are advantages in having a uniform rule, even if it's stupid in some particular cases
03:54:03 <byorgey> yaxu: it's just that in situations like f $ g $ h x  and f . g . h $ x they happen to give the same results.
03:54:04 <SamB_XP> can you say -1 in smalltalk?
03:54:28 <byorgey> yaxu: ($) is just function application:  f $ x = f x.
03:54:30 <SamB_XP> byorgey: um, you missed a $
03:54:44 <SamB_XP> in the first of those
03:54:46 <SamB_XP> IMO
03:54:50 <scook0> ($) = (id :: (a -> b) -> a -> b)
03:55:05 <byorgey> SamB_XP: no I didn't.
03:55:13 <byorgey> SamB_XP: h $ x === h x.
03:55:21 <yaxu> @src .
03:55:22 <lambdabot> (.) f g x = f (g x)
03:55:40 <SamB_XP> byorgey: well. it better illustrates the confusingness if you have either a $ or a . in each position...
03:55:47 <byorgey> SamB_XP: well, that's true.
03:55:59 <byorgey> yaxu: (.) is function composition.
03:56:36 <yaxu> right, so you end up with a new function with .
03:56:38 <SamB_XP> hmm, I am so going to be late for class...
03:56:52 <byorgey> yaxu: right.
03:56:57 <SamB_XP> well, better today than wednesday...
03:57:35 <yaxu> hm, so why does that matter?
03:58:05 <yaxu> this has been troubling me for a while
03:58:20 <SamB_XP> in Haskell, you can get a new function just by looking at something oddly...
03:58:32 <yaxu> :)
03:58:42 <scook0> (:[])
03:59:03 <SamB_XP> @quote {-
03:59:04 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
03:59:16 <SamB_XP> @quote \{-
03:59:16 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
03:59:33 <ari> @quote monster
03:59:34 <lambdabot> dcoutts says: (:[]) looks like a monster
03:59:40 <scook0> nom nom nom
04:00:01 <yaxu> i guess it matters because i can't do foo = sort $ group , but can do foo = sort . group
04:00:12 * SamB_XP wonders which quote happened first
04:00:49 <scook0> I'm a big fan of (.).(.) as well
04:00:55 <scook0> though it's not quite as useful
04:01:22 <scook0> and I've yet to see a realistic use for (.)(.)
04:01:51 <SamB_XP> I think I only said that because I'd recently learned that [] and () were multi-token names ;-)
04:02:16 <SamB_XP> or recently noticed it, anyway
04:04:01 <SamB_XP> and don't try to convince me that [] is not a name, because if it isn't a name then how does "data [a] = [] | a : [a]" work?
04:04:31 <EvilTerran> it doesn't :)
04:04:50 <idnar> SamB_XP: that's not valid Haskell code, as far as I know :P
04:05:41 <EvilTerran> anyway, it should be "data [] a = [] | a : [] a", if you're going to insist [] is a name
04:11:37 <byorgey> yaxu: that's right.
04:12:49 <SamB_XP> idnar: ... your point being?
04:15:33 <SamB_XP> @instances Monad
04:15:34 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:19:08 <Taejo> @src concatMap
04:19:08 <lambdabot> concatMap f = foldr ((++) . f) []
04:19:35 <vincenz> @src foldr
04:19:35 <lambdabot> foldr k z xs = go xs
04:19:35 <lambdabot>     where go []     = z
04:19:35 <lambdabot>           go (y:ys) = y `k` go ys
04:19:37 <vincenz> @src foldl
04:19:38 <lambdabot> foldl f z xs = lgo z xs
04:19:38 <lambdabot>     where lgo z []     =  z
04:19:38 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
04:33:57 <MyCatVerbs> Holy netsplit, networkman!
04:39:00 <byorgey> BIFF! POW!
04:41:49 --- mode: irc.freenode.net set +o ChanServ
04:46:47 <faxathisia> http://web.archive.org/web/20010628005806/www.numeric-quest.com/haskell/Orthogonals.html
04:46:47 <lambdabot> http://tinyurl.com/2tedjo
04:47:20 <faxathisia> mf :(
04:47:37 <faxathisia> Does anyone know what's happened to this maths stuff?
04:47:57 <faxathisia> all this stuff is on web archive, http://web.archive.org/web/20010605003250/http://www.numeric-quest.com/haskell/
04:47:58 <lambdabot> http://tinyurl.com/2kwd2x
04:53:25 <faxathisia> :t __ = __
04:53:26 <lambdabot> parse error on input `='
04:53:31 <faxathisia> :t let __ = __ in __
04:53:32 <lambdabot> forall t. t
04:56:23 <faxathisia> Isn't there any solver for x in Ax = b, matrix A and vectors x, b?
04:56:34 <faxathisia> I'm gonna have to write it .. just to replace it later
04:57:46 <integral> @djinn [[Double]] -> [Double] -> [Double]
04:57:46 <lambdabot> f _ a = a
05:06:26 <mauke> @index Endo
05:06:26 <lambdabot> bzzt
05:07:09 <vincenz> integral: lol
05:10:40 <faxathisia> for Gaussian elimination, do you think I should use an array or something else, to represent the matrix?
05:11:01 <faxathisia> I would just like to choose something sensible but I only know about lists..
05:11:12 <vincenz> use array
05:11:18 <faxathisia> ok thanks
05:16:29 <ToRA> @hoogle [Either a b] -> ([a],[b])
05:16:30 <lambdabot> No matches, try a more general search
05:21:24 <swiert> TMR Issue 9 is out:
05:21:25 <swiert> http://www.haskell.org/haskellwiki/The_Monad.Reader
05:21:26 <lambdabot> Title: The Monad.Reader - HaskellWiki
05:21:32 <swiert> Hot off the press.
05:33:19 <faxathisia> Is there some way to check operator precedence?
05:33:35 <faxathisia> like enter 3*4+2*3 and have it output (3*4)+(2*3)
05:34:01 <scook0> well, if you don't mind a sledgehammer, you could use TH
05:34:09 <vincenz> faxathisia: for personal info?
05:34:15 <vincenz> faxathisia: ghci :i operator
05:34:19 <vincenz> it gives you precedence level
05:34:34 <faxathisia> ah nice
05:34:35 <vincenz> Prelude> :i (+)
05:34:36 <vincenz> ...
05:34:42 <vincenz> infixl 6 +
05:34:45 <matthew-_> faxathisia: you really want something like the sql EXPLAIN statement
05:34:49 <Saizan_> there's also a flag like -ddump-parsed or similar
05:35:03 <faxathisia> :|
05:35:04 <faxathisia> *Main> :i !!
05:35:04 <faxathisia> (!!) :: [a] -> Int -> a 	-- Defined in GHC.List
05:35:12 <faxathisia> there is no mention of precidence
05:35:43 <matthew-_> functions like that always have highest precedence
05:35:52 <scook0> weird ... maybe no explicit precedence is specified
05:36:10 <matthew-_> yeah, actually I'm totally wrong about that aren't I?
05:36:46 <faxathisia> ok great :D
05:37:13 <dozer> can I declare something in record syntax within a function signature, or must I declare it at the top level?
05:37:37 <scook0> dozer: top level, if I understand what you're asking
05:37:57 <scook0> (i.e. you can't specify "ad-hoc" record types)
05:38:05 <scook0> you have to define them explicitly
05:38:06 <dozer> so something like f :: { a :: x, b :: y } -> z is right out?
05:38:10 <scook0> yeah
05:38:15 <dozer> pants
05:38:21 <scook0> under the current record system anyway :)
05:38:28 <dozer> I have a load of state to thread
05:38:40 <dozer> different functions thread or forget different parts of a record
05:39:05 <scook0> you might be able to do some HList magic
05:39:09 <scook0> but I have no experience with that
05:39:58 <dozer> thx
05:46:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3973
05:48:34 <dozer> I'm working with things with lots of parametric type variables
05:48:47 <dozer> often I only care about 2 or 3 of the 8-15 of the things
05:48:59 <dozer> pitty I can't replace the 'booring' ones with _ in the signature
05:49:17 <dozer> and have the comiler fill it in with _a1 _a2 ...
05:54:28 <dozer> so: Data.Set.member :: (Ord k) => k -> Map k a -> Bool
05:54:29 <dozer> as: Data.Set.member :: (Ord k) => k -> Map k _ -> Bool
05:56:12 <Saizan_> well, you don't need to write type signatures
05:56:23 <vincenz> and with emacs
05:56:25 <vincenz> and haskell-mode
05:56:28 <vincenz> yo can make it generate it for you :)
05:56:52 <amaron> vincenz: is it supported for vim too?
05:57:29 <dozer> well yeah, but it's nice to document in the signature that the external behavior of the member method is neutral to the 'a' parameter but cares about the 'k' parameter
05:58:46 <Saizan_> dozer: it's yet documented as it is, since it works forall a. a
06:01:17 <dozer> :t map Data.Set.member
06:01:19 <lambdabot> forall a. (Ord a) => [a] -> [Data.Set.Set a -> Bool]
06:01:30 <dozer> :t map Data.Map.member
06:01:31 <lambdabot> forall a a1. (Ord a) => [a] -> [Data.Map.Map a a1 -> Bool]
06:01:34 <faxathisia> :t (let __ = __ in __ :: forall ___. ___)
06:01:34 <lambdabot> forall ___. ___
06:02:06 <faxathisia> :t (let __ = __ in __ :: forall _1. _1)
06:02:07 <EvilTerran> :t (let __ = __ in __ :: forall __. __)
06:02:08 <lambdabot> forall _1. _1
06:02:08 <lambdabot> forall __. __
06:02:27 <dozer> the a1 in that signature is of no earthly use to anyone - it's just there because we /have/ to give it a name
06:08:32 <sethk> dozer, well, that and we need a way of saying "dummy variable different from previous dummy variables"
06:09:24 <dozer> sethk: yeah - I was kind of assuming that if _ appeared 5 times in a sig, it was 5 independent type variables, just like in pattern matches it would be 5 independent patterns
06:09:39 <dozer> sethk: and that if you want to tie type variables together, you name them
06:10:48 <sethk> dozer, yes, I know what you meant and I don't disagree
06:11:02 <sethk> dozer, it's an artifact of type inference, obviously.
06:11:51 <dozer> I have signatures like this:
06:12:00 <dozer> apply :: ( QueryBuilder dataSelection datatypeVariableID dataPropertyExpression dataRange         , Reasoner reasoner                    description                    dataPropertyExpression                    dataRange                    individual                    constant         , IndividualRewriter description                              individualVariableID                              individual                              datatypeVar
06:12:00 <dozer> nt                              individualSelection         , IndividualScoper description                            individualVariableID                            individual                            datatypeVariableID                            constant         , TargetVariableExpander description                                  individualVariableID                                  individual                                  datatypeVariab
06:12:02 <dozer> ant                                  srcFact                                  fact         , AsPrefix individualVariableID         , AsPrefix individual         , Ord individualVariableID         , Ord datatypeVariableID         , Show individual         , Show constant         , Show dataPropertyExpression         , Show dataRange         , Show description         , Show individualVariableID         , Show datatypeVariableID         , Show src
06:12:08 <dozer> ner            -> Rule individualVariableID                   individualSelection                   datatypeVariableID                   dataSelection                   srcFact           -> State (Context description                             individualVariableID                             individual                             datatypeVariableID                             constant)                    [fact]
06:12:10 <dcoutts_> too much!
06:12:13 <masak> ouch
06:12:21 <dozer> ouch - oops
06:12:34 <dcoutts_> yes, it would be quite possible to give partial type signatures with _'s in them
06:12:36 <dozer> my bad - but you get the point - most of that could be replaced by underscores
06:12:39 <EvilTerran> gaaaaaaak
06:12:51 <dcoutts_> they would just translate into smaller sets of type constraints
06:15:13 <dozer> hehe, my signatures are getting to be up to 2x as large as my functions
06:16:26 <opqdonut> i'd say you need type aliases or something
06:16:30 <sjanssen> dozer: consider using shorter type variable names
06:16:57 <sjanssen> multiple word type variables are really not typical Haskell
06:17:26 <dozer> sjanssen: hehe :) that just reduces the number of chars typed - that's what autocomplete is for - anyway, the names here come from specs that I'm implementing - they aren't my words
06:18:09 <EvilTerran> surely that would be assembled out of several type aliases?
06:18:21 <dozer> since there's no way to name type parameters seperate from the types...
06:18:26 <EvilTerran> are we going to need type-level where{}? :P
06:19:58 <Philippa> dozer: it can make it easier to read as well as to write
06:21:21 <dozer> Philippa: I know, but all the types need to be named after things in some UML and XML specs
06:22:16 <dozer> and almost none of the names have unique first-letter abreviations
06:22:50 <Philippa> how about first-syllable?
06:23:05 <Philippa> indVarId, say?
06:23:30 <Philippa> possibly make datatype dt instead
06:24:46 <dozer> yeah, that works for some of them, but the real issue is that typically any given function that's parameterised of a bunch of these is contracted to only use 2-3 of them, and the rest end up being visual clutter regardless of how fully they are written out
06:28:06 <dozer> unfortunately, using inconsistent abreviations introduces as many type-level bugs as the increased readability fixes :/
06:28:18 <dozer> that's what you get for being a dyslexic programmer
06:30:24 <sjanssen> you can't invent a consistent variable scheme?
06:30:26 <sethk> who's dexlystic?
06:31:26 <dozer> sjanssen: the simplest consistent variable scheme is to use the full names
06:33:57 * dozer will be quiet now
06:35:09 <therp> I just solved my homework in term rewriting quickly mostly because I stripped all unneeded syntax and made the terms short and easy to work with. I think same applied for naming in programming.
06:40:35 <Philippa> dozer: so use dat for datatype, stick to 'first syllable'?
06:47:40 <dozer> Philippa: datatype vs dataValue vs dataVariable - quickly becomes easy to get the wrong short version
06:47:57 <dozer> it's not about if there are short ways to type this, but if I can consistently get them right
06:48:23 <dozer> the past 3 months has convinced me I can only be trusted to type out the full names without constantly getting it wrong :)
06:52:40 <Saizan_> can't you simply use meaningless one letter names for types you don't care about?
06:54:09 <dozer> Saizan_ yeah, I could, although it would be a pita if later I started caring about one of them again and had to re-name all the rest :)
06:54:24 <dozer> anywah, this is idle chatter
06:54:41 <Saizan_> i don't see the difference with using underscores here
06:56:37 <hpaste>  pierre pasted "computer physics N2" at http://hpaste.org/3974
06:57:32 <titusg> how do I make a non-capturing group with Text.Regex? (?:re) doesn't work...
07:21:47 <huamn> what's the best way to split a string at dots, so "a, b, c" would become ["a", "b", "c"] or so...?
07:22:07 <swiert> huamn: splitAt in Data.List.
07:22:27 <huamn> thanks
07:22:37 <swiert> hang on. That's not it.
07:24:54 <MyCatVerbs> :t splitAt
07:24:56 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:25:03 <cba-daugustine> I've asked this before, but don't remember, where can i find how haskell manages memory, like what is placed on the stack, heap, etc.
07:25:41 <MyCatVerbs> cba-daugustine: best bet is to ask on the haskell-cafe@ mailing list. You'll get much better responses there than anyone'll be able to give you here. >>
07:25:41 <Japsu> @where split
07:25:41 <lambdabot> I know nothing about split.
07:25:41 <opqdonut> looked in the ghc manual?
07:25:43 <Japsu> lambdabot: stupid bot
07:26:00 <Japsu> http://osfameron.vox.com/library/post/haskell-words-and-perl-split.html
07:26:02 <lambdabot> http://tinyurl.com/2bz6am
07:26:10 <Japsu> http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html
07:26:10 <lambdabot> Title: The Julipedia: A split function in Haskell, http://tinyurl.com/fhss7
07:26:29 <dcoutts_> cba-daugustine: to a first approximation: all data constructors go on the heap, function arguments go on the stack
07:26:53 <dcoutts_> cba-daugustine: let and where allocate heap objects too
07:27:12 <opqdonut> and as the stack unwinds args might be moved to the heap b/c closures
07:27:17 <swiert> huamn: I don't think it's in Data.List. It's pretty easy to write yourself though.
07:27:25 <dcoutts_> cba-daugustine: though all these things can be changed somewhat by transformations during optimisation
07:27:56 <cba-daugustine> okay... thanks
07:28:07 <huamn> hm yes splitAt seems to take only integer arguments...
07:28:20 <ddarius> cba-daugustine: Haskell doesn't specify.  Specific implementations obviously do something, but those are implementation details.  If you are interested read the literature and commentary surrounding the implementation you are interested in.
07:28:23 <huamn> I guess I need to write it myself then.
07:28:54 <dcoutts_> huamn: see span and unfoldr
07:28:54 <mcp_> What does  =>  do?
07:29:07 <faxathisia> > break (==',') "a, b, c"
07:29:11 <lambdabot>  ("a",", b, c")
07:29:13 <dcoutts_> mcp_: it's part of a type signature
07:29:14 <ddarius> mcp_: Nothing.  It is syntax.
07:29:21 <dcoutts_> @type elem
07:29:22 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:30:03 <dcoutts_> mcp_: in type signatures it separates the type expression from constraints on the type variables
07:30:45 <mcp_> where would i find docs for => ?
07:30:47 <dcoutts_> mcp_: eg elem says it takes something of type 'a', a list of them and gives a result. Then you can pick any type 'a' so long as that type is in the type class Eq.
07:31:10 <dcoutts_> mcp_: you want to look up polymorphism and type classes
07:31:16 <ddarius> mcp_: Again.  It is syntax, it doesn't have meaning on it's own.  It is used in three different ways in Haskell.
07:31:26 <dcoutts_> mcp_: which you will find in any tutorial on Haskell
07:31:28 <mcp_> dcoutts, ok, so its realted to the type class thing
07:31:42 <dcoutts_> mcp_: yes, as in that example with elem
07:31:57 <ToRA> huamn: splitRegex
07:32:04 <ToRA> @type splitRegex
07:32:13 <lambdabot> Not in scope: `splitRegex'
07:32:26 <dcoutts_> mcp_: you know you can have types like:  a -> a  right ?  That works for any type 'a' you choose.
07:32:37 <dcoutts_> mcp_: eg the type of reverse
07:32:37 <osfameron> splitRegex didn't seem to do capturing of the delimiter
07:32:40 <dcoutts_> @type reverse
07:32:43 <lambdabot> forall a. [a] -> [a]
07:32:47 <mcp_> dcoutts, ive just studied what you wrote, and i think ive got it
07:32:53 <dcoutts_> mcp_: see, reverse works for lists of any type at all
07:33:01 <ToRA> Prelude Text.Regex> splitRegex (mkRegex ", ") "a, b, c, d"
07:33:01 <ToRA> ["a","b","c","d"]
07:33:29 <dcoutts_> mcp_: but sometimes that's not enough, sometimes you want to say a function works with any type that has certain properties, like support for equality or ordering
07:34:09 <dcoutts_> mcp_: for example sort, sort can't work with lists of any element type like reverse can, it can only work with lists of things that can be ordered
07:34:22 <dcoutts_> mcp_: so it restricts the types to those in the Ord type class
07:34:25 <dcoutts_> @type sort
07:34:26 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:34:34 <dcoutts_> @type reverse
07:34:34 <lambdabot> forall a. [a] -> [a]
07:34:40 <dcoutts_> see the difference?
07:36:18 <mcp_> so    class  (Eq a) => Ord a  where    means, to be of class Ord, i must also be in Eq, right?
07:36:28 <dcoutts_> mcp_: yes
07:36:30 * dcoutts_ disappears to go teach Haskell elsewhere
07:44:41 <vincenz> Why does Ord require Eq?
07:45:21 <mauke> because it's a subclass
07:45:24 <Olathe> Because equal elements aren't greater than each other.
07:45:53 <faxathisia> @src compare
07:45:53 <lambdabot> compare x y | x == y    = EQ
07:45:53 <lambdabot>             | x <= y    = LT
07:45:53 <lambdabot>             | otherwise = GT
07:45:56 <vincenz> mauke: Obviously, I was questioning the deeper reason :)
07:46:16 <faxathisia> so is it x == y and x <= y must be implemented for the minimal Ord instance?
07:46:17 <vincenz> compare x y | x < y = LT
07:46:22 <vincenz>               | y < x = GT
07:46:26 <vincenz>               | otherwise = EQ
07:46:35 <faxathisia> Ord has <= and >= though
07:46:42 <mauke> so Ord lets you compare stuff for equality
07:46:57 <ddarius> It's a perfectly reasonable thing to do as all Ord instances imply that an equality is defined.
07:47:46 <ddarius> Now asking why Num requires Show is something else (and well hashed over ground)
07:47:54 <faxathisia> you cannot define > in terms of <, you need < and ==
07:48:16 <Captain_Thunder> If I have a list comprehension like [f x y | x <- xs, y <- ys] do x and y ultimately need to be the same length?
07:48:22 <ddarius> faxathisia: You can define > directly.
07:48:25 <byorgey> Captain_Thunder: no.
07:48:36 <byorgey> Captain_Thunder: in that case, you would get all possible pairings of elements from xs and ys.
07:48:39 <faxathisia> x and y do not have length
07:48:46 <ddarius> Captain_Thunder: x and y aren't necessarily lists
07:48:46 <Captain_Thunder> Ah, OK.
07:48:48 <faxathisia> xs and ys will have to be lists though
07:48:54 <faxathisia> wont they?
07:48:54 <ddarius> And xs and ys don't have to be the same length
07:49:09 <byorgey> > [x + y | x <- [1,2,3], y <- [6,8,9]]
07:49:11 <lambdabot>  [7,9,10,8,10,11,9,11,12]
07:49:12 <byorgey> faxathisia: yes.
07:49:30 <byorgey> unless someone brings back monad comprehensions. =)
07:49:43 <ddarius> > [x+y | x <- [1,2], y <
07:49:43 <lambdabot>  Parse error at end of input
07:49:47 <ddarius> > [x+y | x <- [1,2], y <- []]
07:49:47 <lambdabot>  []
07:49:51 <vincenz> monad comprehensions ftw
07:49:56 <faxathisia> what about monad comprehensions?
07:50:01 <byorgey> Captain_Thunder: does that make sense?
07:50:10 <vincenz> faxathisia:
07:50:16 <vincenz> [foo | bar] :: [a]
07:50:22 <vincenz> with monad comprehensions it'd be :: m a
07:50:32 <Captain_Thunder> byorgey, yes, thanks.
07:51:36 <byorgey> faxathisia: [ foo | x <- m ] would mean m >>= \x -> foo.
07:52:08 <byorgey> faxathisia: which is already true for lists.
07:52:26 <byorgey> > [ x+3 | x <- [1..4] ]
07:52:26 <lambdabot>  [4,5,6,7]
07:52:36 <osfameron> it's just a slightly more compact way of doing do-notation isn't it?
07:52:37 <byorgey> > [1..4] >>= \x -> x + 3
07:52:37 <lambdabot>   add an instance declaration for (Num [b])
07:52:37 <lambdabot>     In the expression: x + 3
07:52:37 <lambdabot>     ...
07:52:37 <faxathisia> It's not really a good thing though is it?
07:52:49 <faxathisia> doesn't make sense more than using do notation
07:52:51 <byorgey> > [1..4] >>= \x -> [x + 3]
07:52:51 <lambdabot>  [4,5,6,7]
07:52:54 <ddarius> You missed a return
07:52:59 <byorgey> yeah, I just realized that.
07:53:16 <byorgey> [ foo | x <- m ] is m >>= \x -> return $ foo
07:53:31 <byorgey> faxathisia: depends who you ask. =)  they used to be in Haskell, but got taken out.
07:53:38 * ddarius rarely uses list comprehensions and would monad comprehensions even less.
07:53:58 <byorgey> faxathisia: mostly because (AIUI) the error messages confused newbies.
07:54:27 <byorgey> imagine if you did something wrong with a list and got some crazy error message talking about "no instance for Monad somethingorother..." =)
07:54:38 <faxathisia> I know how it feels :p
07:54:40 <vincenz> add a -no-newbie switch
07:54:53 <ddarius> byorgey: And that -never- happens nowadays...
07:55:02 <byorgey> ddarius: right, of course not. =)
07:55:42 <vincenz> --i-eat-transformers-for-breakfast
07:55:56 <byorgey> faxathisia: yes, IMO do-notation fills the same niche that monad comprehensions would.
07:56:13 <byorgey> -fno-condescension
07:56:28 <MyCatVerbs> vincenz: --smug-haskelly-bastard
07:56:37 <vincenz> --oleg
07:56:41 <MyCatVerbs> Hahahaha.
07:56:44 <byorgey> hehe
07:56:46 <mauke> -fignore-errors
07:56:58 <byorgey> clearly these should all be in ghc 6.8.2 =)
07:57:01 <MyCatVerbs> --dons, makes the compiler turn all error messages off.
07:57:05 <byorgey> who wants to log a ticket?
07:57:15 <titusg> if I'm hacking someone's cabal package, how do I let cabal know about a new dependency? so I don't get "x is part of y, which is hidden ." when I build with cabal?
07:57:16 <MyCatVerbs> Instead you have to calculate by hand exactly where the type unifier failed. =D
07:57:45 <MyCatVerbs> Or, better yet, it just outputs a '?' on a line by itself.
07:57:58 <MyCatVerbs> The experienced haskeller, you see, will usually already know what is wrong. :)
07:58:06 <byorgey> titusg: add it to the build-depends field?
07:58:12 <ski> monad comprehensions would read (a little bit) nicer with "collectionny" monads
07:58:21 <Syzygy-> MyCatVerbs: With --hand-holding-please turning verbose error messages back on?
07:58:31 <vincenz> --im-a-pythonista
07:58:45 <osfameron> I'm not sure the verbose error messages are always much good at handholding...
07:58:52 <vincenz> what about
07:58:53 <vincenz> --gavino
07:59:15 <vincenz> That would give  error messages as generated by
07:59:16 <vincenz> @keal
07:59:16 <lambdabot> i have basically written a proof that shows an assumption is wrong
07:59:22 <faxathisia> lol
07:59:25 <faxathisia> @keal
07:59:25 <lambdabot> i prove infinity never ends in both directions
07:59:32 <faxathisia> :D
07:59:34 <MyCatVerbs> Syzygy-: --hand-holding-please should turn on an expensive analyser to attempt the NP-hard-and-then-some job of working out exactly *why* the user made that error in the first place, as opposed to just where the error is. :)
07:59:35 <osfameron> I like the one where you copy a declaration like "let a=1" from ghci to a .hs file, and it complains about your indentation
07:59:39 <ski> @. elite keal
07:59:39 <lambdabot> I TRy maK3 PRoGRam (a|lEd GLYf 7O do i+ Bu+ my 5(ripT LANG (AlLED T To0 5|O\/\/. I iN\/3n7 T
07:59:39 <byorgey> Syzygy-: no, --hand-holding-please would produce error messages like "oh no, something went wrong!  It's ok, don't feel bad, Haskell is really really hard.  Just go paste your code on hpaste and ask #haskell for help."
07:59:55 <vincenz> @proton
07:59:55 <lambdabot> can haskell outdo java and jboss n stuff?
08:00:07 <faxathisia> @. elite keal
08:00:07 <titusg> byorgey, where will I find that? Doesn't seem to be anything in Setup...
08:00:07 <lambdabot> |4madABOt 7o0k 5 70 8 WhOLe secOnDS +o Re+Urn []
08:00:08 <MyCatVerbs> Who the Hell are keal and proton?
08:00:09 <vincenz> @proton
08:00:09 <lambdabot> is functional progrmaming the same as object oriented?
08:00:25 <faxathisia> @keal
08:00:25 <lambdabot> today's 24hour project was supposed to be logical overloading using plegm method
08:00:26 <byorgey> titusg: there should be a file ending with a .cabal extension.
08:00:34 <Olathe> @proton
08:00:34 <lambdabot> or does it become a mishmash of code?
08:00:41 <MyCatVerbs> Gah, stop that.
08:00:44 <MyCatVerbs> Less bogosity, already!
08:00:55 * MyCatVerbs starts firing anti-bogons into the room.
08:00:57 <MyCatVerbs> @dons
08:00:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:01:01 <MyCatVerbs> Dammit.
08:01:04 <MyCatVerbs> @oleg
08:01:07 <lambdabot> Defined.
08:01:11 <faxathisia> o_O
08:01:12 <MyCatVerbs> Huh?
08:01:12 <vincenz> lol
08:01:14 <ski> MyCatVerbs : see e.g. <http://tunes.org/~nef/logs/haskell/06.01.13>
08:01:15 <MyCatVerbs> @lemmih
08:01:15 <lambdabot> Unknown command, try @list
08:01:16 <faxathisia> @quote oleg
08:01:16 <lambdabot> vincenz says: we need a flag like "ghc --I-am-oleg"
08:01:28 <MyCatVerbs> @quote lemmih
08:01:28 <lambdabot> Lemmih says: <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
08:01:31 <titusg> byorgey, got it, thanks.
08:01:37 <ski> @quote
08:01:37 <lambdabot> Beelsebob says: how do you add a quote
08:01:41 <MyCatVerbs> ski: thanks.
08:01:43 <ski> @ghc
08:01:43 <lambdabot> ghc says: Functional dependencies conflict between instance declarations
08:01:47 <faxathisia> @quote oleg
08:01:47 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
08:01:58 <Beelsebob> I do?
08:01:59 <Beelsebob> o.O
08:02:05 <MyCatVerbs> How the Hell come keal and proton have their own quote commands, but oleg, dons and lemmih don't? oO
08:02:16 <faxathisia> @keal
08:02:16 <lambdabot> antiparsimony were 100% correct...
08:02:21 <vincenz> MyCatVerbs: keal kept on coming here saying bullshit
08:02:30 <vincenz> MyCatVerbs: proton came in here for like a year, asking the same stupid questions
08:02:33 <vincenz> @proton
08:02:33 <lambdabot> I got some info b 4 about how lazy eval makes macros not needed please expand...
08:02:45 <faxathisia> @quote oleg
08:02:45 <lambdabot> vincenz says: we need a flag like "ghc --I-am-oleg"
08:02:47 <faxathisia> @quote oleg
08:02:47 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
08:02:48 <ski> MyCatVerbs : keal was schizophrenic, iirc
08:02:50 <faxathisia> grr
08:02:50 <vincenz> Only negative people get @'s
08:03:02 <Olathe> Everyone knows that protons are positive.
08:03:09 <vincenz> it was 'protontorpedo'
08:03:17 <vincenz> And his last name was something sexual
08:03:24 <vincenz> And rather disturbing
08:03:30 <MyCatVerbs> vincenz: ah, danke.
08:03:34 <MyCatVerbs> ski: oh, wow.
08:03:36 <masak> @proton
08:03:36 <lambdabot> why haskell over say clsip or smalltalk?
08:03:42 <masak> :)
08:04:05 <MyCatVerbs> ski: see, I always thought people acted like that because they were dumb enough to believe online IQ tests' results, rather than because of actual clinical illness.
08:04:10 <ski> (MyCatVerbs : i.e. istr he said so himself)
08:04:21 <MyCatVerbs> ski: fair 'nuff.
08:06:08 <vincenz> online IQ tests are fictive?
08:06:20 <faxathisia> vincenz: about as good as real IQ tests I thin
08:06:36 <vincenz> faxathisia: and how are they?
08:06:48 <hpaste>  ramza3 pasted "Issue with recent and current factor" at http://hpaste.org/3975
08:06:55 <faxathisia> 100% useless? :p
08:06:57 <osfameron> vincenz: flawed
08:07:05 <osfameron> I think they measure *something* don't they?
08:07:21 <osfameron> and the something is correlated with intelligence in some cases
08:08:02 <ddarius> A correlation is not a case-by-case thing
08:08:23 <osfameron> good catch
08:08:34 <vincenz> it might be a partial correlation :)
08:08:35 <osfameron> for some sets?
08:08:39 <vincenz> for some subsets
08:09:04 <osfameron> there's a large cultural bias
08:09:18 <osfameron> and it's only testing certain types of intelligence
08:09:20 <dons> http://programming.reddit.com/info/60xyl/comments/
08:09:42 <dons> `The Monad.Reader 9: Cabal, Darcs Patch Theory, Roll Your Own Typechecker :: PDF '
08:10:07 <ddarius> Thanks lambdabot
08:10:51 <Japsu> yay!!
08:11:08 <dons> ?bot
08:11:08 <lambdabot> :)
08:11:10 <dons> ?uptime
08:11:10 <lambdabot> uptime: 2d 23h 21m 27s, longest uptime: 1m 10d 23h 44m 29s
08:13:05 <psykon> f a a = ....
08:13:17 <psykon> can't i do something like this that only matches if the arguments are the same?
08:13:21 <mauke> no
08:13:31 <psykon> :|
08:13:32 <oerjan> f a b | a == b = ....
08:13:40 <psykon> i wonder why
08:13:43 <ddarius> Miranda could but they didn't add that to Haskell
08:13:57 <psykon> any special reason?
08:14:09 <vincenz> not that useful
08:14:10 <hpaste>  faxathisia pasted "GaussianElimination" at http://hpaste.org/3976
08:14:22 <mauke> psykon: well, you could desugar it to f a b | a == b, but which variable would your a then refer to?
08:14:25 <mauke> a or b?
08:14:28 <oerjan> it would be another complication for the definition of pattern matching
08:14:40 <faxathisia> mauke: (a+b)/2
08:14:40 <vincenz> besides
08:14:42 <psykon> mauke, there would only be one variable
08:14:43 <vincenz> guards make it clearer :)
08:14:55 <ddarius> faxathisia: LU decomposition and then back substitution
08:15:02 <faxathisia> ddarius: is it faster?
08:15:03 <mauke> psykon: no
08:15:11 <oerjan> psykon: haskell values cannot be compared for complete equality
08:15:16 <faxathisia> than gaussian elimination?
08:15:20 <oerjan> only for equality in the Eq class
08:15:39 <oerjan> and that is not necessarily defined to mean "identical"
08:15:48 <psykon> i see
08:15:48 <vincenz> nor equal :)
08:15:50 <psykon> that's a good point
08:15:56 <oerjan> (although normally it would be)
08:16:03 <vincenz> oerjan: and should :)
08:16:21 <psykon> now i can live in peace with this feature not being there
08:16:23 <psykon> :)
08:16:30 <faxathisia> ohh
08:16:31 <faxathisia> I see
08:16:50 <ddarius> faxathisia: Yes, and the LU decomposition is useful on its own
08:17:06 <faxathisia> in Ax = b, LU decomposition is computationally efficient when you want to solve x for multiple b
08:17:15 <ddarius> (At least faster for solving)
08:17:16 <faxathisia> ddarius: alright I will try to code it :)
08:17:25 <faxathisia> but I wanted to ask first is my code ok ?
08:17:30 <faxathisia> In particular the right datastructure
08:17:32 <oerjan> psykon: although it would not be _that_ much of a stretch... pattern matching on numeric literals already uses the Eq class
08:18:08 <ddarius> faxathisia: Depends on what you are gonig for
08:18:15 <faxathisia> hm
08:18:18 <oerjan> but in that case there is no variable to fill in
08:18:41 <faxathisia> I really want to solve a different problem but I thought I should write this first..
08:21:16 <cedricshock> What does this error mean:     cannot parse LANGUAGE pragma?
08:21:49 <mauke> it means ghc can't parse a LANGUAGE pragma
08:22:20 <oerjan> cedricshock: what does you LANGUAGE pragma look like?
08:22:51 <cedricshock> {-# LANGUAGE TemplateHaskell, FlexibleInstances,
08:22:51 <cedricshock>              OverlappingInstances, UndecidableInstances, CPP,
08:22:51 <cedricshock>              ScopedTypeVariables, PatternSignatures, GADTs,
08:22:51 <cedricshock>              PolymorphicComponents, FlexibleContexts,
08:22:51 <cedricshock>              MultiParamTypeClasses, DeriveDataTypeable,
08:22:52 <cedricshock>              PatternGuards #-}
08:23:02 <faxathisia> woah..
08:23:08 <faxathisia> cedricshock: What code is this?
08:23:17 <cedricshock> The error is line 3, column 34, just after "ScopedTypeVariables". It's from HAppS.
08:23:46 <faxathisia> I had a different error with HAppS the other day
08:24:59 <Igloo> cedricshock: If you're trying to use the latest darcs happs you'll need GHC 6.8.1
08:25:51 <cedricshock> Igloo: Thanks. That'd make this error make sense.
08:25:57 <oerjan> cedricshock: does it complain about not knowing about ScopedTypeVariables or PatternSignatures?  otherwise i would think the error message is rather unhelpful
08:26:22 <cedricshock> oerjan: Nope. The message is rather unhelpful.
08:26:58 <oerjan> maybe worth a bug report then
08:27:12 <oerjan> well, provided 6.8.1 does the same
08:27:26 <oerjan> (for values it doesn't know)
08:35:00 <cedricshock> oerjan: It looks like 6.8.1 got a complete LANGUAGE pragma overhaul.
08:35:15 <oerjan> good :)
08:35:53 <doserj> ghc-6.8.1 gives: unsupported extension: Blah
08:37:40 <cedricshock> Does anyone know the easiest way to get ghc 6.8.1 for Ubuntu. Compile it from source?
08:38:05 <doserj> install the binary?
08:38:47 <cedricshock> Ubuntu 7.10 doesn't have readline4.
08:39:11 <geocalc> bubutu
08:40:27 <geocalc> install readline cedricshock
08:41:52 <hpaste>  matveev pasted "Stack overflow: prime numbers (what else)" at http://hpaste.org/3977
08:44:17 <cedricshock> else p : factors' d prims
08:44:21 <cedricshock> sould probably be
08:44:29 <matveev> hi, i've heard that tail recursion is a cure for all stack overflows. Followed that (as much as I can). Get Stack overflow anyway. Any comments on http://hpaste.org/3977 ? I'm new to Haskell.
08:44:31 <cedricshock> else p : factors' d ps
08:45:06 <ddarius> cedricshock: tail recursion isn't all there is to stack overflows in lazy languages
08:45:11 <ddarius> er matveev
08:45:19 <ddarius> @wiki Stack overflow
08:45:19 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
08:45:50 <doserj> p: factors' d prims is ok, to return multiple prime factors. the problem is that you have an infinite loop
08:46:13 <cedricshock> Sorry, I thought yo were eliminating the prime, you're not, you divided the number (which is better).
08:46:17 <ddarius> That said, factors' isn't tail recursive (though that's actually better in this case)
08:46:20 <doserj> (testing against all prime numbers)
08:47:00 <oerjan> doserj: huh? there is a 1 _ case
08:47:18 <doserj> oh, true.
08:47:20 <cedricshock> You are ending at infinity, not at 1.
08:48:18 <cedricshock> Sorry, confused again. This piece of code is written totally backwards from how I usually write.
08:48:23 <matveev> ddarius: is didnt get it: "tail recursion isn't all there is to stack overflows in lazy languages"
08:49:41 <faxathisia> Is there a data type to pair two values together not (,)?
08:50:32 <ddarius> I'm not sure what either of you said.
08:50:36 <opqdonut> faxathisia: well you can define one your self
08:52:50 <cedricshock> matveev: I bet factors 4 will stack overflow.
08:53:08 <matveev> ddarius: in short: factors' n primes = p : factors' (n/p) primes or factors' n primes =  factors' n (tail primes). You say the *first* is NOT tail recursive?
08:53:09 <cedricshock> If so I bet you can figure out what's going on.
08:53:54 <cedricshock> Crud. I misunderstood it again. I have got to stop looking at this piece of code.
08:54:05 <oerjan> cedricshock: missed the 2 : ? :)
08:54:18 <sclv> p : factors' d prims is not tail recursive
08:54:36 <oerjan> i actually do _not_ understand why there would be a stack overflow.
08:54:38 <sclv> a tail recursive call can *only* return the results of the cal.
08:54:51 <cedricshock> sclv got it. Spot on.
08:55:18 <sclv> i don't know if this is the stack overflow problem or not, but you get p : (a thunk which evals to p: a thunk which evals to p : ...
08:55:19 <cedricshock> oerjan: Missed the difference between ps and prims again.
08:55:35 <hpaste>  mcp_ pasted "ERROR "Aufgabe6.lhs":10 - Undefined data constructor "Tree". Can someone tell me why?" at http://hpaste.org/3979
08:55:51 <oerjan> cedricshock: i know factors' is not tail recursive but i don't see how that is a problem
08:57:08 <ddarius> sclv: That is fine.  As I said, it is actually better that that line is not "tail recursive"
08:57:23 <mauke> mcp_: those Trees should be Nodes
08:57:25 <hpaste>  (anonymous) annotated "Stack overflow: prime numbers (what else)" with "Tail recursive version." at http://hpaste.org/3977#a1
08:57:27 <sclv> yeah -- looking at the code i agree
08:58:17 <sclv> ... maybe
08:58:36 <jedbrown> Which Haskell type will hold CInt and (Ptr ForeignStruct) in a portable manner?
08:58:46 <sclv> say you're factoring a 500 digit prime with that code.
08:59:11 <Philippa_> jedbrown: depends. I'm guessing you want it to act as if it's a C union of the two?
08:59:41 <Philippa_> IIRC the two types aren't actually guaranteed to be the same size
08:59:54 <mcp_> mauke, are you sure on that? When i would put Nodes there, it would not match the tree-type declaration
09:00:25 <sclv> hmmm.. wait.
09:00:28 <sclv> not sure.
09:00:35 <jedbrown> Philippa_: I am trying to interface to a library where one implementation represents its constants as (int) while the other has type (struct foo_t *)
09:00:36 <mauke> mcp_: it doesn't match types, it matches values
09:00:41 <mauke> mcp_: Tree is not a value
09:00:55 <cedricshock> sclv: Not tail recursive should be better here, it yields results before the computation is complete.
09:01:07 <EvilTerran> data Foo ... = Bar Baz Eek -- Foo, Baz, and Eek are types; Bar is a constructotr
09:01:08 <matveev> oops, I cannot reproduce it *today* it was "factors 150124789". But today I already have a longer "primes" array in ghci memory. Will restart.
09:01:27 <sclv> yep -- just trying to figure out where the memory leak could be.
09:02:42 <vincenz> EvilTerran: not quite
09:02:44 <cba-daugustine> man... i've searched all morning for memory stuff in haskell... and haven't found anything besides what was said in here... and I'm not sure I understand it completely
09:02:46 <vincenz> EvilTerran: Foo is a type constructor
09:02:53 <EvilTerran> well, yes
09:02:54 <vincenz> EvilTerran: Bar is a -data- construtor
09:03:02 <sclv> granted primes will give you a big memoized caf which may be one issue -- the other being that the lack of tail recursion might hurt if you're factoring, say, 2^500
09:03:09 <EvilTerran> phlphlplplplffffhhhhhhlt.
09:03:29 <cedricshock> cba-daugustine: What do you mean?
09:03:31 <vincenz> EvilTerran: and that was a -de- constructor
09:03:53 <cba-daugustine> like, what gets allocated to the heap and stack
09:03:53 <chessguy> @remember EvilTerran phlphlplplplffffhhhhhhlt
09:03:53 <lambdabot> Done.
09:04:25 <EvilTerran> er... didn't think it was that memorable, but okay then :)
09:04:36 <cedricshock> sclv: factoring 2^500 should be much better lazy...
09:04:40 <faxathisia> haha
09:04:48 * EvilTerran is just tired, groggy, and playing fast and free with terminology
09:04:51 <faxathisia> @quote EvilTerran
09:04:51 <lambdabot> EvilTerran says: look for GNU HaltingProblem; it's still in beta, but it might do what you want
09:04:57 <faxathisia> lol
09:05:24 <chessguy> @go gnu halting problem
09:05:25 <lambdabot> http://en.wikipedia.org/wiki/Halting_problem
09:05:25 <lambdabot> Title: Halting problem - Wikipedia, the free encyclopedia
09:06:09 <ricky_clarkson> @quote newsham
09:06:09 <lambdabot> newsham says: dont confuse larry wall's drug induced vision of computing with the state of reality
09:06:32 <matveev> sclv: thanks for the code
09:06:51 <cedricshock> cba-daugustine: Whatever the compiler wants to. In general function calls are added to the stack. Data structures usually sit in the heap (I think).
09:07:16 <sclv> matveev: that wasn't me on hpaste. good luck though.
09:07:19 <mcp_> mauke, what i really missed, what specifieng that my tree nodes must be in Eq.
09:08:08 <cba-daugustine> cedricshock: thanks
09:09:08 <chessguy> @quote wall
09:09:08 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
09:09:34 <chessguy> @quote smile
09:09:34 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
09:10:36 <vincenz> @quote operational
09:10:37 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
09:11:01 <chessguy> @quote love
09:11:01 <lambdabot> twb says: But, I love my job. It's like being in a rock band. i.e. no pay, but fun.
09:11:22 * vincenz calls those hobbies
09:12:36 <chessguy> @quote job
09:12:36 <lambdabot> twb says: But, I love my job. It's like being in a rock band. i.e. no pay, but fun.
09:13:04 <oerjan> chessguy: playing an association game with @quote ?
09:13:17 <chessguy> yes, it's quite fun
09:13:25 <cedricshock> @quote fun
09:13:25 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
09:13:31 <chessguy> i'm not very good at it today
09:13:56 <oerjan> @quote argument
09:13:56 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
09:14:09 <cedricshock> @quote coerce
09:14:09 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
09:14:16 <chessguy> @quote dangerous
09:14:16 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
09:14:29 <cedricshock> lol
09:14:35 <oerjan> @quote mind
09:14:36 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
09:14:43 <vincenz> @quote breaking
09:14:43 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
09:14:51 <chessguy> @quote hurt
09:14:51 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
09:14:53 <vincenz> and we're back to 'love'
09:15:07 <cedricshock> @quote emacs
09:15:07 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
09:15:15 <chessguy> @quote emacs
09:15:15 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
09:15:25 <cedricshock> @quote os
09:15:26 <lambdabot> ghc says: parse error (possibly incorrect indentation)
09:15:31 <chessguy> lol
09:15:41 <oerjan> @quote indentation
09:15:41 <lambdabot> ghc says: parse error (possibly incorrect indentation)
09:15:53 <cedricshock> @quote error
09:15:53 <lambdabot> ghc says: internal error: Invalid object in processHeapClosureForDead
09:16:01 <cedricshock> @quote dead
09:16:01 <lambdabot> Pseudonym says: The Scheme programming language is optimised for writing small brain-dead tutorial compilers for.
09:16:19 <oerjan> @quote brain
09:16:19 <lambdabot> chessguy says: the loop is only in your brain
09:16:35 <oerjan> @quote loop
09:16:35 <lambdabot> chessguy says: the loop is only in your brain
09:16:42 <oerjan> @quote loop
09:16:42 <lambdabot> chessguy says: the loop is only in your brain
09:16:47 <cedricshock> Now just keep doing !quote loop forever...
09:16:59 <chessguy> @fix quote 'loop
09:16:59 <lambdabot> Maybe you meant: faq ft id thx
09:17:18 <oerjan> @quote only
09:17:18 <lambdabot> knuth says: Beware of bugs in the above code; I have only proved it correct, not tried it.
09:17:42 <cedricshock> @quote proved
09:17:42 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
09:17:48 <vincenz> @quote stupidty
09:17:48 <lambdabot> No quotes match. You type like i drive.
09:17:51 <vincenz> @quote stupidity
09:17:51 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
09:18:01 <vincenz> like this case
09:18:14 <hpaste>  (anonymous) annotated "Stack overflow: prime numbers (what else)" with "simple optimization" at http://hpaste.org/3977#a2
09:18:16 <chessguy> @quote terminate
09:18:16 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
09:18:16 <lambdabot> science problem. ;-)
09:18:25 <cedricshock> Ok. Maybe we should let other people use the channel now...
09:18:42 <chessguy> how boring :)
09:18:48 <Syzygy-> I kinda miss the 'majestic stereo' quote.
09:19:01 <oerjan> @quote stereo
09:19:01 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:19:07 <oerjan> eep
09:19:08 <Syzygy-> o.O
09:19:12 <vincenz> @remember Syzygy- I kinda miss the 'majestic stereo' quote
09:19:12 <lambdabot> It is stored.
09:19:15 <oerjan> @quote broken
09:19:15 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
09:19:16 <vincenz> @quote stereo
09:19:17 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:19:21 <vincenz> wtf
09:19:26 <vincenz> @quote Syzygy-
09:19:26 <lambdabot> Syzygy- says: I kinda miss the 'majestic stereo' quote
09:19:26 <oerjan> heh :D
09:19:36 <oerjan> @quote stereo
09:19:36 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:19:39 <Syzygy-> @quote Syzygy-
09:19:40 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
09:19:43 <faxathisia> I mss that quote
09:19:45 <oerjan> @quote knuth
09:19:45 <lambdabot> knuth says: Beware of bugs in the above code; I have only proved it correct, not tried it.
09:19:46 <vincenz> @quote 'majestic stereo'
09:19:46 <lambdabot> No quotes for this person. My brain just exploded
09:19:48 <Syzygy-> Thought so. I -do- have more than one quote in there.
09:19:52 <vincenz> quote is buggy
09:19:56 <faxathisia> #haskell where your questions get answered in stereo
09:19:59 <Syzygy-> @quote stereo
09:19:59 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:20:02 <faxathisia> or something similar
09:20:03 <oerjan> vincenz: i am not sure that's the bug
09:20:09 <oerjan> or?
09:20:18 <oerjan> weird that it _only_ fails on that one
09:20:19 <vincenz> oerjan: what of the response I got?
09:20:25 <Syzygy-> @quote blahonga
09:20:26 <lambdabot> No quotes match. stty: unknown mode: doofus
09:21:08 <oerjan> @quote
09:21:08 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
09:21:24 <Syzygy-> @quote
09:21:24 <oerjan> vincenz: i thought @quote usually gave up entirely when it did
09:21:24 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
09:21:44 <Syzygy-> o.O
09:21:52 <oerjan> @quote meta.stereo
09:21:52 <lambdabot> No quotes match. Sorry.
09:21:57 <vincenz> @. ++ . read . show . state @. ++ . read . show . state
09:21:57 <lambdabot> Plugin `compose' failed with: Unknown command: "++"
09:22:01 <vincenz> :|
09:22:02 <Olathe> Someone deleted that :(
09:22:08 <Olathe> @quote stereo
09:22:08 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:22:36 <oerjan> @quote c.a.l.e
09:22:36 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
09:22:46 <vincenz> @quoate elac
09:22:47 <lambdabot> No quotes match.
09:22:57 <Olathe> @quotecale cale
09:22:58 <lambdabot> Unknown command, try @list
09:23:13 <oerjan> @quote stereo.
09:23:13 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
09:23:25 * oerjan does a little dance
09:23:32 <vincenz> wtf
09:23:39 <vincenz> @quote stereo.
09:23:39 <lambdabot> z0d says: What was the stereo quote?
09:23:43 <vincenz> @quote stereo
09:23:43 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:23:44 <Olathe> :(
09:23:46 <vincenz> o.O
09:23:52 <vincenz> ok, that's buggy
09:23:52 <Olathe> @quote at
09:23:52 <lambdabot> dons says: who was it who said (shapr?) that they welcome their competitors using languages other than haskell? it's a bad sign if your enemies start coding in haskell!
09:24:21 <mcp_> Im going to implement Ord. Zvon says  (<=) or compare is enough for a minimal definition. Will < and == also be sufficient? Is there a way to find out without implementing?
09:24:37 <oerjan> @quote metastereo
09:24:37 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
09:24:45 <vincenz> mcp_: just do 'compare'
09:24:59 <oerjan> the rest are not gone after all
09:25:00 <earthy> mcp_: == is not in Ord, nor does Ord rely on it existing, IIRC
09:25:25 <oerjan> earthy: Ord presupposes Eq, but doesn't use it
09:25:37 <oerjan> or?
09:25:57 <cedricshock> mcp_: To find out before implementing look op the definition of Ord in the Prelude. It's usually easier to just try it and find out...
09:26:07 <oerjan> actually the default for compare uses ==
09:26:22 <MyCatVerbs> Keal actually sounds like a pretty cool guy, for certain values of "cool".
09:26:37 <vincenz> MyCatVerbs: you mean those overlapping with 'insane' ?
09:26:40 <hpaste>  faxathisia annotated "GaussianElimination" with "lu decompose" at http://hpaste.org/3976#a1
09:27:04 <MyCatVerbs> vincenz: yes, but insane in a way that includes explaining to the public at large how to make an IRC bot that simulates himself, and pretty effectively, too. =)
09:27:10 <earthy> the report states: "The default declarations allow a user to create an Ord instance either with a atype specific compare function or with type-specific == and <= functions'
09:27:16 <osfameron> that "competitors using haskell" quote is a reference to Paul Graham on Lisp etc.?
09:27:27 <earthy> so, < and == does not cut it in '98
09:27:35 * vincenz puts MyCatVerbs in a straight jacket
09:27:56 <MyCatVerbs> vincenz: also, the intersection of the set of cool people with the set of insane people is not neccessarily the null set. So there. :P
09:28:10 <oerjan> @quote welcome.to
09:28:10 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
09:28:28 * oerjan breathes relieved
09:29:43 <faxathisia> any comments regarding my paste?
09:29:55 <faxathisia> I mean the annotation
09:29:57 <Olathe> Yay !
09:30:09 <Olathe> @quote stereo
09:30:09 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:30:11 <Olathe> @quote stereo!
09:30:11 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
09:30:26 <Olathe> I found the sekrit password.
09:30:34 <oerjan> no i did!
09:30:43 <Japsu> yay!
09:31:06 <Olathe> I found a second sekrit password !
09:31:16 <faxathisia> oops I lied in my comments
09:31:33 <vincenz> faxathisia: heh
09:31:37 <vincenz> faxathisia: "test 1" iso "test1"
09:31:38 <cedricshock> faxathasia: What do you want commented on?
09:32:09 <vincenz> faxathisia: small suggestion
09:32:14 <vincenz> faxathisia: newCell don't make it take a tuple
09:32:21 <vincenz> faxathisia: you're creating and destroying tuples for no reason
09:32:31 <faxathisia> oh really is that more expensive?
09:32:38 <vincenz> yah
09:32:46 <faxathisia> I had it just because I i
09:32:49 <faxathisia> it's a coordiante
09:32:58 <vincenz> never make tuplpes unless required
09:33:07 <vincenz> especially if you plan to destroy them right away
09:33:10 <faxathisia> ok that is fixed now
09:33:14 <nominolo> @src many
09:33:14 <lambdabot> Source not found. Do you think like you type?
09:35:30 <vincenz> faxathisia: looks nasty
09:35:37 <vincenz> faxathisia: you're constantly going to and from arrays
09:35:41 <vincenz> and lsits
09:35:57 <cedricshock> faxathisia: What does it do wrong?
09:36:16 <faxathisia> cedricshock: It seems to work when it's supposed to
09:36:32 <vincenz> faxathisia: so how does it fail?
09:36:37 <vincenz> it fails in not failing?
09:36:59 <faxathisia> no I just wonder if I did stupid things
09:37:03 <faxathisia> which seems like I did :p
09:37:14 <faxathisia> I don't know how to fix going back and forth from lists and arrays though
09:37:28 <vincenz> use mutable arrays
09:37:29 <vincenz> is one option
09:37:38 <cedricshock> faxathisia: Then I won't hold back and will openly say: Your folds scare me.
09:37:50 <vincenz> cedricshock: in luDecompose?
09:37:57 <faxathisia> cedricshock: :p
09:38:10 <vincenz> faxathisia: runColumn is hard to grok
09:38:13 <faxathisia> How do you think it should be written?
09:38:31 <vincenz> use more where's and some naming  in that:)
09:39:17 <cedricshock> faxathisia: I would name more of the things in that huge fold.
09:39:59 <vincenz> yeah
09:40:04 <vincenz> cedricshock: what I just said :)
09:40:10 <faxathisia> well I turn the top of the column into a 1, then fold down it zeroing each cell below
09:40:19 <faxathisia> It's hard to name these..
09:40:54 <cedricshock> faxathisia: I would also (down the road) consider what primitive operations on vectors and matrices this can be written in terms of.
09:41:27 <faxathisia> ah yeah
09:41:38 <faxathisia> ok a better way to write all this code is,
09:41:55 <faxathisia> Write elementary row operations and other types ops on matrices
09:42:12 <faxathisia> then more complex things like echelonForm and luDecompose in terms of it?
09:42:38 <vincenz> yes
09:43:05 <vincenz> and I wouldn't use a fold
09:43:08 <vincenz> I'd use a recursive function
09:43:11 <vincenz> and pass the state
09:43:17 <vincenz> since one is clearly state (the matrix)
09:43:21 <vincenz> while the other is the thing you're 'folding' over
09:43:24 <vincenz> namely the column
09:43:43 <vincenz> erm, that made no sense
09:43:47 <faxathisia> no I understood
09:43:51 <vincenz> but you basically pass around two things in your fold and tuple/detuple them
09:45:14 <faxathisia> I think I should use ST arrays and not IO arrays?
09:45:16 <faxathisia> is that sensible
09:46:20 <faxathisia> hm
09:46:28 <faxathisia> What array type do you think is a good idea to use
09:47:28 <hpaste>  vincenz annotated "GaussianElimination" with "cleaned a bit" at http://hpaste.org/3976#a2
09:48:30 <cedricshock> faxathisia: Wikipedia has a nice little algorithm for generalized LUP factorization which you might find useful. It's described recursively and in terms of extracting parts of a matrix, very similar to how one would compute a determinant. (under the heading "LUP algorithm")
09:48:59 <faxathisia> vincenz: cool
09:51:17 <vincenz> faxathisia: that should clarify the code somewhat
09:51:24 <vincenz> faxathisia: easier to visualize the change in l and u
09:51:31 <vincenz> faxathisia: though you have to fill it in :)
09:53:31 <faxathisia> cedricshock: Since you delete rows and columns on this matrix and work recursively.. Will it mean a lot of copying and be slower?
09:55:35 <mcp_> Now that i defined my own <= haskell does no longer know which one to use. (Could refer to: Main.<= Hugs.Prelude.<= ) Can I specify, use Prelude if applicable mine otherwise. Or is this error-message an indication that my definition of <= is completely wrong?
09:56:07 <Saizan_> mcp_: you've to define it as part of an instance declaration
09:56:11 <mauke> why are you redefining <=?
09:56:27 <Saizan_> like: instance Ord MyType where (<=) = ...
10:00:16 <b_jonas> @hoogle Int -> [a] -> [[a]]
10:00:17 <lambdabot> No matches, try a more general search
10:00:24 <b_jonas> @hoogle [a] -> Int -> [[a]]
10:00:24 <lambdabot> No matches, try a more general search
10:00:43 <oerjan> b_jonas: what do you want?
10:00:57 <Saizan_> another quest for chunks?
10:00:58 <b_jonas> splitting lists to even-sized lists
10:01:20 <b_jonas> there are two or three variants of that
10:01:32 <doserj> @type unfoldr
10:01:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:02:03 <oerjan> > let chunks n = takeWhile (not . null) . unfoldr (Just . splitAt n) in chunks 2 [1..9]
10:02:04 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9]]
10:02:24 <faxathisia> data (Fractional a) => Matrix a = STArray (Int, Int) a
10:02:29 <faxathisia> Is that a good Matrix?
10:02:47 <b_jonas> etf
10:02:52 <b_jonas> is that even in haskell?
10:03:10 <b_jonas> oh, I see, it's recursive
10:03:11 <oerjan> b_jonas: you mean my chunks definition?
10:03:15 <b_jonas> yes
10:03:28 <faxathisia> chunk n xs = takeWhile (/= []) $ chunked xs where chunked xs = take n xs : chunked (drop n xs)
10:03:33 <faxathisia> this is more chunks
10:03:42 <oerjan> takeWhile and unfoldr are in Data.List
10:03:58 <oerjan> faxathisia: don't use /= [], it requires Eq
10:04:10 <faxathisia> ah :D
10:04:18 <cedricshock> faxathisia: That's a fine matrix, if you don;t care about being purely functional.
10:04:20 <faxathisia> I'm stealing yours
10:05:03 <MyCatVerbs> chunk n xs = takeWhile (not . null) $ chunked xs where chunked xs = take n xs : chunke (drop n xs)
10:05:07 <MyCatVerbs> ?
10:05:07 <Saizan_> faxathisia: you lack a constructor, and you might want to use newtype
10:05:35 <MyCatVerbs> :t let { chunk n xs = takeWhile (not . null) $ chunked xs where chunked xs = take n xs : chunked (drop n xs) } in chunk
10:05:36 <lambdabot> forall a. Int -> [a] -> [[a]]
10:05:57 <MyCatVerbs> let { chunk n xs = takeWhile (not . null) $ chunked xs where chunked xs = take n xs : chunked (drop n xs) } in chunk 5 [1..]
10:06:00 <Saizan_> MyCatVerbs: splitAt > take, drop
10:06:08 <MyCatVerbs> > let { chunk n xs = takeWhile (not . null) $ chunked xs where chunked xs = take n xs : chunked (drop n xs) } in chunk 5 [1..]
10:06:09 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
10:06:13 <MyCatVerbs> Oops, heh. Ahhh, I see.
10:06:15 <oerjan> b_jonas: er, my chunks it not recursive, but let ... in ... can use what is defined in the first part in the second
10:06:28 <MyCatVerbs> Saizan_: I was just running faxathisia's code to see what it did, is all. =)
10:06:40 <abell> Is there a way to express in an instance definition that if m is a Monad and m a is of class C1 then   StateT s m a   is of class C2?
10:06:50 <b_jonas> it's just wierd
10:07:02 <b_jonas> I don't see why you use takeWhile in it
10:07:15 <b_jonas> I'd write it as
10:07:15 <mcp_> mauke, i dont try to redefine <=. I try to define it for my type. Does the error indicate i redefined it for other (default) types?
10:07:21 <b_jonas> @let chunk n [] = []; chunk n s = let (p, q) = splitAt n s in (p : chunk n q);
10:07:23 <lambdabot> Defined.
10:07:27 <b_jonas> > chunk 3 "hello, world"
10:07:28 <lambdabot>  ["hel","lo,"," wo","rld"]
10:07:36 <faxathisia> > chunk 3 "hello, world!"
10:07:36 <Saizan_> instance Monad m, C1 (m a) => C2 (StateT s m a) where
10:07:36 <lambdabot>  ["hel","lo,"," wo","rld","!"]
10:08:11 <b_jonas> so takeWhile is because you generate an infinite list?
10:08:23 <Saizan_> b_jonas: yes
10:08:30 <EvilTerran> there's a rather nice unfoldr for that, iirc
10:08:32 <b_jonas> tricky
10:09:07 <b_jonas> I've got to get used to these infinite constructs
10:09:37 <faxathisia> :t fix
10:09:37 <lambdabot> forall a. (a -> a) -> a
10:10:39 <oerjan> EvilTerran: that was what i did first, but apparently that was too advanced :/
10:10:41 <EvilTerran> > unfoldr (liftM2 (>>) (guard.not.null) (return.splitAt 5)) [1..]
10:10:43 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
10:10:56 <EvilTerran> oh, too advanced? sorry =/
10:11:07 <abell> Saizan_, if I try for example     instance ( Monad m, Num ( m a ) ) => Num ( StateT s m a )       I get "Non type-variable argument in the constraint: Num (m a)"
10:11:08 <oerjan> er, not as advanced as yours...
10:11:17 <EvilTerran> :P
10:11:47 <oerjan> for once i didn't use the -> monad :D
10:12:06 <faxathisia> I can't use forall ia data definition, can I?
10:12:22 <oerjan> faxathisia: with extensions, surely
10:12:25 <EvilTerran> faxathisia, you can with extensions; it is rather arcane, though
10:12:36 <Saizan_> abell: you need to enable an extension, try with -fglasgow-exxts
10:12:43 <Saizan_> err -fglasgow-exts
10:13:18 <faxathisia> Alright then instead how about, data (Fractional a) => Matrix s a = Matrix' (STArray s (Int, Int) a)
10:13:29 <EvilTerran> > map (take 5) . takeWhile (not.null) . iterate (drop 5) $ [0..] -- is how i prefer to phrase that, for clarity reasons
10:13:30 <lambdabot>  [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],...
10:14:17 <b_jonas> EvilTerran: tricky
10:14:35 <abell> Saizan_, thanks. That seems to solve the problem :-)
10:14:53 <b_jonas> > map (take 5) . takeWhile (not.null) . iterate (drop 5) $ [0..17]
10:14:53 <lambdabot>  [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17]]
10:15:09 <EvilTerran> > take 5 [1,2,3]
10:15:09 <lambdabot>  [1,2,3]
10:15:31 <b_jonas> that also gives a way to write the overlapping variant
10:15:42 <EvilTerran> indeed =]
10:16:16 <b_jonas> > map (take 5) . takeWhile ((5 <) . length) . tails $ [0..17]
10:16:17 <lambdabot>  [[0,1,2,3,4],[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,...
10:16:31 <b_jonas> > map (take 3) . takeWhile ((3 <=) . length) . tails $ [0..8]
10:16:32 <lambdabot>  [[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8]]
10:16:45 <b_jonas> > map (take 3) . takeWhile ((3 <=) . length) . iterate tail $ [0..8]
10:16:45 <lambdabot>  [[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8]]
10:16:56 <EvilTerran> @src tails
10:16:56 <lambdabot> tails []         = [[]]
10:16:56 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
10:17:16 <EvilTerran> @check liftM2 (==) tails (iterate tail) :: [Int] -> Bool
10:17:17 <lambdabot>  Falsifiable, after 0 tests: []
10:17:24 <b_jonas> now I have to read all the definition variants above
10:17:25 <EvilTerran> ah.
10:18:02 <EvilTerran> tail [] = _|_, so iterate tail (finite list) will always finish with an infinitude of _|_ elements
10:18:23 <EvilTerran> @check liftM2 (==) tails (iterate (drop 1)) :: [Int] -> Bool
10:18:23 <lambdabot>  Falsifiable, after 0 tests: [2,-1]
10:18:52 <ikegami--> hello
10:18:59 <EvilTerran> oh, never mind. i see the problem, but i won't clog the channel any more trying to fix it ;)
10:21:10 <byorgey> hi ikegami--
10:21:18 <mrd> @karma ikegami
10:21:19 <lambdabot> ikegami has a karma of -2
10:21:27 <byorgey> @seen ikegami
10:21:27 <lambdabot> I haven't seen ikegami.
10:21:40 <byorgey> no harm done =)
10:21:59 <ikegami--> I wonder how great if the TempoSnippets mode for Emacs will work for Haskell: http://emacswiki.org/cgi-bin/emacs/TempoSnippets
10:22:00 <lambdabot> Title: EmacsWiki: TempoSnippets
10:22:54 <b_jonas> EvilTerran
10:22:55 <b_jonas> :
10:23:05 <b_jonas> that means interate tail is probably better here
10:23:08 <faxathisia> There's no way to get purely function & mutable? :p
10:23:24 <ikegami--> There is a demo for C++ that Emacs expands several phrase dynamically
10:23:24 <EvilTerran> oh?
10:23:25 <b_jonas> because it doesn't test for an empty list completely unneccessarily
10:23:38 <EvilTerran> either way, it does a pattern match
10:23:46 <EvilTerran> there's really nothing in it, performance-wise
10:23:57 <EvilTerran> and "tails" is easier to type ;)
10:24:10 <b_jonas> yeah
10:24:22 <b_jonas> makes sense
10:24:46 <b_jonas> tails is easier to type, but I had to search for its name in the docs
10:24:54 <b_jonas> while I remembered iterate and tail already
10:25:00 <EvilTerran> @hoogle [a] -> [[a]]
10:25:01 <lambdabot> List.inits :: [a] -> [[a]]
10:25:01 <lambdabot> List.tails :: [a] -> [[a]]
10:25:01 <lambdabot> List.group :: Eq a => [a] -> [[a]]
10:25:13 <EvilTerran> @hoogle+
10:25:14 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
10:25:17 <EvilTerran> eh
10:25:41 <mcp_> I still dont understand why <= is ambigious. Here is my code:  instance (Ord a) => Ord (Tree a) where s@(Leaf a1) <= t@(Leaf a2) = (a1 <= a2)
10:26:54 <EvilTerran> do you have a definition of <= _anywhere_ in your file other than in an instance Ord definition?
10:26:57 <mcp_> I think what confuses haskell is the (a1<=a2) part.  Actually i dont care which type of <= is used for (a1<=a2).
10:27:04 <faxathisia> @hoogle
10:27:04 <lambdabot> HOOGLE - Haskell API Search
10:27:04 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
10:27:04 <lambdabot>  
10:27:28 <BMeph> mcp_: did you mean "==" vice "="? :)
10:27:29 <EvilTerran> i assure you, it's very unlikely that *haskell* is the one confused ;)
10:27:30 <mcp_> EvilTerran, i dont think so. I have ==
10:27:57 <EvilTerran> @paste maybe, so we can have a look?
10:27:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:28:37 <hpaste>  mcp_ pasted "(no title)" at http://hpaste.org/3980
10:28:45 <mcp_> problem is in last line
10:29:17 <mauke> mcp_: misindentation
10:29:55 <EvilTerran> mcp_, the body of a where{} has to be indented further than the line with the "where" itself on it
10:29:58 <mcp_> mauke, you are right. Thanks
10:30:51 <BMeph> mauke: /clap
10:46:31 <mcp_> i want to pass a comparison operator to my function. func:: op -> a -> b  gets me a Inferred type is not general enough. Is it possible to use something like op@(a->a->Bool) in the type specification?
10:47:00 <oerjan> drop the op@
10:47:02 <EvilTerran> func :: (a -> a -> Bool) -> ...
10:47:33 <oerjan> :t sortBy --example
10:47:34 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:47:44 <EvilTerran> mcp_, in general, you don't need foo@(...) in patterns, either. it's only useful if you want to give a name to the overall value *and* pull out individual bits of it
10:48:10 <mcp_> works without the op@ part
10:50:37 <oerjan> hm, with scoped type variables @ patterns in types might actually have some use.
10:52:36 <hpaste>  jedbrown pasted "Simple FFI troubles.  Why?" at http://hpaste.org/3981
10:55:49 <mcp_> Program error: pattern match failure: istLTE v466 ...   isLTE is a functio i wrote, but what does that v466 mean???
10:56:49 <oerjan> probably some variable name invented by ghc
10:57:26 <oerjan> anyway, pattern match failure probably means you forgot to define your function for all argument possibilities
10:58:28 <jedbrown> Could someone please explain why my program gives different values for what is supposed to be a global constant?
10:58:29 <mcp_> oerjan, ok, thx. I see why there is the pattern match failure. Just been confused by the v466 part.
10:58:40 <oerjan> iiuc in its internal core language, functions with type class contexts get extra arguments for the class dictionaries
10:58:46 <oerjan> *ghc's
10:59:27 <alexj__> @seen igloo
10:59:27 <lambdabot> igloo is in #haskell, #darcs and #ghc. I last heard igloo speak 2h 34m 28s ago.
10:59:59 <oerjan> jedbrown: hpaste?
11:00:31 <jedbrown> yeah, http://hpaste.org/3981
11:00:32 <glguy> jedbrown: because you shadowed the constant?
11:00:35 <oerjan> jedbrown: off the top of my head you might be evaluating it for different types, say Int vs. Integer
11:01:07 <oerjan> oh, FFI
11:01:17 <jedbrown> Aren't the type declarations explicit enough.
11:02:20 <dons> Igloo: how often do the popcorn stats run? once weekly?
11:02:59 <jedbrown> glguy: I need a copy of the constant because it is an argument for foreign functions.  I don't need to change its value, but I need to be able to send it back to C.
11:05:27 <oerjan> jedbrown: what happens with two uses of MPI_COMM_WORLD in a purely C program?
11:05:41 <earthy> hmmm delimited continuations as zippers
11:05:47 <Igloo> dons: Daily
11:05:59 <dons> Igloo: and the tick points?
11:06:05 <dons> are they just weekly ticks?
11:06:24 <dons> i note its continued to go up, and was wondering how often the stats are gathered, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=xmonad&show_installed=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
11:06:25 <lambdabot> Title: popcon graph
11:06:54 <jedbrown> oerjan: it gives: 134518912  134518912
11:07:11 <jedbrown> oerjan: i.e. different than above, but both the same values which is the critical part.
11:07:20 <Igloo> dons: There are something like 25 crosses (or whatever) across the width of the graph
11:07:44 <Igloo> dons: None makes it hard to see which line is which with lots of lines, and all points is just a mess
11:08:08 <oerjan> jedbrown: could it be that one case is evaluated at a different compile time?
11:08:29 <oerjan> or, one at compile time, one at runtime
11:08:46 <faxathisia> #haskell -- where your questions are answered STEREOENCEPHALOSCOPICALLY
11:09:09 <jedbrown> oerjan: Oh! Yes since cabal runs hsc2hs separately.
11:09:27 <dons> Igloo: right, so the ticks aren't significant (not check points or anything)
11:11:49 <Igloo> dons: Right
11:11:50 <Eelis> if i want to read from an fd and handle a possible EWOULDBLOCK result, is there a better way to do that than using fdRead and catching and reading the stringized exception it throws?
11:13:41 <geocalc> is it for geordi ?
11:13:50 <Eelis> yes.
11:13:57 <geocalc> ;)
11:14:07 <Eelis> i currently re-wrap c_read, but it's a kludge
11:20:44 <vincenz> @join #oasis
11:21:10 <Eelis> my experience has been that C function wrappers that abstract just a little too much is the main source of inconvenience when trying to do some *nix systems programming in Haskell
11:33:57 <Captain_Thunder> Is it valid to say something like
11:34:03 <Captain_Thunder> l :: [Int]
11:34:06 <Captain_Thunder> l = []
11:34:13 <Olathe> Yes.
11:34:14 <sjanssen> Captain_Thunder: yep
11:34:20 <Captain_Thunder> Thanks.
11:49:04 <mcp_> how do i split a list in half (one half may be longer (by one element) than the other in case of an odd number of elements)?
11:49:14 <Orphi> Greetings assorted Haskell people. Can anybody here help me with a Cabal problem?
11:50:19 <oerjan> mcp_: splitAt + length, probably
11:50:28 <dons> Orphi: ask away
11:50:38 <oerjan> + div
11:50:48 <Orphi> dons: ah, I'm glad it's you :-)
11:51:10 <Orphi> "Setup: ld is required but it could not be found."
11:51:15 <oerjan> > let halves l = splitAt (length l `div` 2) l in halves [1..11]
11:51:21 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10,11])
11:51:31 <mcp_> oerjan, will genericSplitAt do that also? has no docs in zvon :(
11:52:11 <oerjan> mcp_: they do the same, just splitAt is restricted to Int lengths
11:52:20 <oerjan> as is length, so you can just as well use it
11:52:29 <mcp_> oerjan, thx
11:53:29 <Orphi> dons: I'm trying to install the stream fusion thing.
11:53:42 <Orphi> dons: I managed to find a way to extract a tar.gz file
11:53:50 <Orphi> dons: but Cabal configure isn't happy.
11:54:10 <dons> which ghc and cabal version do you have?
11:54:20 <Orphi> dons: let me check...
11:54:25 <dons> it will need Cabal 1.2.x
11:54:34 <dons> and ghc 6.8 anyway, for reasonable performance
11:54:34 <Orphi> dons: GHC 6.8.1
11:54:47 <dons> ok.that should work
11:54:48 <Orphi> uh... how do I check the Cabal version?
11:54:56 <dons> ghc-pkg list
11:55:19 <Orphi> Cabal 1.2.2.0
11:55:25 <dons> ok. that's fine.
11:55:28 <dons> what error do you get?
11:55:40 <dons> ?paste
11:55:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:55:41 <Orphi> like I said, "ld is required but it could not be found"
11:55:45 <dons> oh. weird.
11:55:51 <dons> do you have ld?
11:55:55 <Orphi> no. this is Windoze. it doesn't have ld.
11:55:57 <dons> in your path?
11:55:59 <dons> oh hmm.
11:56:03 <dons> so a cabal issue
11:56:18 <dons> so i guess you can't build any hackage packages
11:56:21 <Orphi> well, it's *true* that ld isn't there... ;-)
11:56:28 <dmwit> Somebody last night solved that error by putting ld in their path.
11:56:30 <Saizan_> do you have the bin directory of ghc in your path?
11:56:34 <dons> i'm not sure what you're supposed to do -- this is a general windows issue
11:56:36 <Orphi> nope. I've never managed to install anything with Cabal. ever. heh.
11:56:42 <dmwit> ...are you sure there's no chance of having ld? =)
11:56:48 <dons> so you'll need ghc, ld and a proper haskell dev environment
11:56:52 <earthy> !sigh
11:57:03 <Orphi> hold on a sec...
11:57:44 <Orphi> ...just checked. there *is* an LD.EXE hidden away in one of the GHC folders.
11:57:50 <Orphi> I thought GHC was using it...
11:58:05 <earthy> no conversion from EpochTime to either LocalTime or ClockTime
11:58:20 <Orphi> it's not in PATH though; presumably that's why Cabal isn't finding it?
11:58:33 <Orphi> (and presumably GHC finds it because it knows where it is.)
11:58:38 <dmwit> right
11:58:46 <earthy> windows without MSYS, obviously
11:58:56 <Orphi> Windows without *anything*...
11:59:19 <earthy> dons: windows *is* a proper haskell dev env
11:59:34 <Saizan_> Orphi: how did you install ghc?
11:59:35 <earthy> especially if you use Visual Haskell
11:59:42 <dmwit> Orphi: Do you know how to put it in your path?
11:59:47 <dons> earthy: yes, sure. i was just suggesting he ensure his env was set up.
11:59:54 <earthy> ah. right. ;)
11:59:56 <dons> i.e. ghc, ld, et al
11:59:57 <Orphi> Saizan_: just from the Windows installer package.
11:59:59 <earthy> yeah, that takes some doing
12:00:08 <shapr> dons: I like that motivating phrase.
12:00:20 <dons> shapr: :)
12:00:21 <Orphi> so is there some way I can tell Cabal where LD.EXE is?
12:00:32 <Orphi> without fiddling with my PATH anyway...
12:00:33 <dons> hmm. it would be best if it is in your path
12:00:38 <earthy> not directly IIRC
12:00:55 <dons> so does anyone else have suggestions about how to resolve the Data.Stream name clash?
12:01:17 <shapr> What's the clash?
12:01:20 <Orphi> right. so you're telling me if you take a Windows box, and install GHC from the download on the GHC home page, Cabal doesn't work right?
12:01:21 <earthy> what name clash? :)
12:01:28 <sjanssen> dons: I like Fusion.Stream
12:01:34 <dons> stream-fusion Data.Stream clashes with Ross and Wouter's Stream type
12:01:40 <sjanssen> IMO, the Data hierarchy is overloaded
12:01:43 <dons> mm
12:01:45 <Saizan_> Orphi: you can pass --with-ld= to configure
12:01:47 <dons> its a data type though
12:01:55 <dons> Data.Stream.Fusion ?
12:01:58 <Orphi> Saizan_: OK, let me try...
12:01:58 <sjanssen> or Data.Fusion.Stream
12:02:46 <Saizan_> Orphi: i thought the installer would update %Path% for you..
12:02:47 <earthy> hm. interesting.
12:03:00 <earthy> yet another instance of the Main Problem with Haskell
12:03:19 <earthy> no good library namespace policy
12:03:26 <Orphi> Saizan_: The GHC installer puts GHC.EXE into PATH, but not all the GCC stuff (LD, CC1, etc.)
12:03:30 <earthy> nor a good library interface standardization system
12:03:43 <earthy> leading to multiple ways of dealing with errors/exceptions
12:03:56 <earthy> multiple representations for strings, time, etc
12:04:02 <earthy> and no good 'baseline'
12:04:06 <dons> ell, we have a name policy: grab a name, then fight on libraries@ to keep it
12:04:18 <earthy> that sucks though.
12:04:33 <Orphi> hmm, --with-ld doesn't seem to work.
12:05:42 <earthy> plus, I tend to run into oddnesses in the libs
12:05:44 <sjanssen> dons: I think Data.Fusion.Stream fits the taxonomy better
12:06:06 <sjanssen> earthy: IME, module names are rarely a problem in practice
12:06:06 <dons> i quite like that
12:06:14 <dons> yeah, its hardly ever an issue
12:06:19 <sjanssen> certainly not often enough to be called the Main Problem
12:06:26 <dons> i think only once have i had to --hide-package arrows
12:06:29 <dons> to work around the issue
12:06:34 <dons> there are bigger issues
12:06:58 <earthy> sjanssen: module names aren't
12:07:22 <earthy> (yet, haskell is small enough as of now)
12:07:36 <earthy> however, 3 different representations of time
12:07:48 <earthy> multiple ways of dealing with errors/exceptional situations
12:07:52 <earthy> etc. are
12:08:39 <earthy> and this is all to do with policy in the libraries
12:08:59 <earthy> methinks on Don's problem however that Data.List.Fusable is a nice name. ;)
12:09:24 <sjanssen> it's a very bad name for this purpose, in my opinion
12:09:26 <dons> but its not for lists
12:09:36 <dons> its for sequence types. in particular, ByteStrings and ndp arraays
12:09:40 <sjanssen> stream fusion is only somewhat related to lists
12:09:43 <dons> lists as well, but that's a less important case
12:09:43 <MyCatVerbs> Data.Fucking.Ridiculous.Optimization.Fodder
12:09:44 <earthy> Data.Fusion.Stream would be a good second
12:09:50 <dons> yeah
12:09:58 <MyCatVerbs> Data.C.Envy
12:10:03 <sjanssen> earthy: what happens when I invent river fusion?
12:10:09 <MyCatVerbs> Data.Fuck.C.We.Can.Do.Better
12:10:12 <dons> Data.Fusion.Supero
12:10:21 <MyCatVerbs> Data.Fusion.Superhero?
12:10:23 <Olathe> Data.Superhero
12:10:34 <sjanssen> earthy: streams shouldn't steal the generic Data.List.Fusible name
12:10:41 <Olathe> Superheros are strong enough to not need fusion !
12:10:50 <earthy> sjanssen: Data.Fusion.River ? :)
12:11:02 <earthy> sjanssen: true enough
12:11:03 <MyCatVerbs> Olathe: what about those superheros who're powered by fusion?
12:11:10 <sjanssen> earthy: yes, and they should all be under Data.Fusion
12:11:20 <Olathe> Sun = Data.Nuclear.Fusion.init
12:11:31 <earthy> Data.Fusion.Nuclear  :)
12:11:35 <Saizan_> Orphi: i meanth --with-ld=/path/to/ld
12:11:36 <Olathe> MyCatVerbs: That's a vicious myth !
12:11:41 <geocalc> poor dons
12:12:08 <Orphi> Saizan_: I tried --with-ld=C:\ghc\ghc-6.8.1\gcclib\ld.exe
12:12:11 <Orphi> it no likie
12:12:32 <Orphi> maybe if I temporarily add it to PATH just for this session... hmm...
12:12:42 <sjanssen> dons: will bytestring depend on the fusion library, or will it have a local copy of the fusion module?
12:12:56 <dons> i think we'll do a local copy
12:13:02 <MyCatVerbs> Olathe: oh yeah? Captain James T. Kirk.
12:13:03 <dcoutts_> sjanssen: yep, for now.
12:13:10 <dons> and we can stricitfy the states up
12:13:11 <MyCatVerbs> Or was it Jim Kirk? Anywa.
12:13:15 <Orphi> ...woah, that worked! o_O
12:13:20 <dons> Data.Fusion.Stream.Strict
12:13:24 <MyCatVerbs> Olathe: ask any Star Trek freak: totally a superhero.
12:13:27 <BMeph> Orphi: Did you quote it? The ld path, that is?
12:13:42 <Olathe> MyCatVerbs: Yes, but a fictional one.
12:13:45 <Orphi> BMeph: tried with and without quotes.
12:13:50 <olsner> MyCatVerbs: kirk? mere human!
12:13:55 <Olathe> True superheroes are never powerd by fusion.
12:13:59 <Orphi> also with and without ".exe", and indeed just with the path (with and without trailing slash)
12:14:10 <olsner> but he does get all the hot alien chicks, though
12:14:12 <monochrom> Data is not powered by fusion.
12:14:19 <geocalc> why not fusion first dons ?
12:14:22 <Olathe> Fission, maybe, if they've just been frozen solid by their arch-nemesis and need to reheat.
12:14:25 <Olathe> Fusion, never.
12:14:30 <dcoutts_> dons: it's not clear that that is necessary. It'd be worth investigating. I might do that while writing up my thesis.
12:14:36 <Cale> Data.Alt.Adjective.Noun.Verb.Verb.Verb
12:14:49 <MyCatVerbs> olsner: it's impossible to get that much otherwordly nookie without being at least demimetahuman.
12:14:56 <Orphi> !! GUYS...
12:14:58 <dmwit> Iz dat sum Swedish Chef?
12:15:06 <Orphi> !! stream fusion is installed.
12:15:17 <Olathe> Data.Alt.Swedish.Chef.Bork.Bork.Bork
12:15:20 <opqdonut> alt.french.captains.borg.borg.borg
12:15:28 <hpaste>  mcp_ pasted "why doesnt the last rule build a valid tree. (last question for today, i promise)" at http://hpaste.org/3982
12:15:38 <Cale> http://www.aanvvv.com/ :)
12:15:39 <lambdabot> Title: alt.this.site.introduce.explain.describe | alt.adjective.noun.verb.verb.verb
12:15:40 <dcoutts_> dons: ie it might not be necessary to specialise Stream a to Word8 for use in ByteString, we might be able to get the same performance from just Stream Word8 if the simplifier and strictness analysis are good enough.
12:15:52 <dmwit> Orphi: Great!
12:15:57 <oerjan> Data.Alt.Swedish.TennisPlayers.Borg.Borg.Borg
12:16:08 <Orphi> guys, I'm going to post this to haskell-cafe, in case anybody else tries to do this...
12:16:37 <dmwit> alt.this.link.click.press.go heh
12:16:50 <Olathe> Data.Alt.Stereo.Comment.Delete.Delete.Delete
12:17:15 <dcoutts_> dons: I'm writing the intro and related work atm. Been re-reading the 1977 Burstall and Darlington paper, and Wadler's deforestation paper.
12:18:03 <dons> oh, yes, i was thinking Stream Word8 might be ok.
12:18:08 <dons> though we might want unlifted states
12:18:11 <dons> external states
12:19:33 <oerjan> mcp_: you need parentheses around tail too
12:19:41 <oerjan> and head
12:20:03 <dcoutts_> dons: possibly, yes.
12:20:09 <geocalc> @version -- still not current
12:20:10 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
12:20:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:20:25 <mcp_> oerjan, thx
12:20:34 <oerjan> and you forgot the l argument to halves
12:21:15 <faxathisia> eek
12:21:23 <oerjan> also, you can use something like (bef,x:aft) = halves l
12:21:33 <geocalc> eke
12:22:17 <earthy> that's odd...
12:22:23 <earthy> *TreeZipper System.Posix.Time Data.Time> show . (flip addUTCTime (UTCTime (fromGregorian 1970 1 1) 0)) $ 1195503460
12:22:27 <earthy> "2007-11-19 20:17:40 UTC"
12:22:28 <earthy> *TreeZipper System.Posix.Time Data.Time> show . (flip addUTCTime (UTCTime (fromGregorian 1970 1 1) 0)) . toEnum . fromEnum $ 1195503460
12:22:31 <earthy> "1970-01-01 00:00:00.00119550346 UTC"
12:24:43 <sjanssen> > logBase 2 1195503460
12:24:44 <lambdabot>  30.154971159458317
12:25:06 <dmwit> earthy: switch to/from
12:25:07 <earthy> it's a time_t :)
12:25:23 <dmwit> toEnum . fromEnum /= id
12:25:33 <dmwit> :t toEnum . fromEnum
12:25:34 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
12:26:15 <oerjan> dmwit: in this case /= fromInteger would seem to be the problem
12:26:27 * earthy nods
12:26:29 <dmwit> :t fromEnum . toEnum
12:26:29 <lambdabot>     Ambiguous type variable `b' in the constraint:
12:26:29 <lambdabot>       `Enum b' arising from use of `fromEnum' at <interactive>:1:0-7
12:26:29 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
12:26:52 <dmwit> oerjan: Oh, well, yeah.  Sure.
12:26:53 <earthy> actually, I'm trying to convert from System.Posix.Types.EpochTime to Data.Time.LocalTime.NominalTimeDiff
12:27:09 <earthy> they're both seconds...
12:27:23 <earthy> just different opaque types
12:27:52 <earthy> but it's weird that toEnum /= fromIntegral
12:28:00 <earthy> s/fromIntegral/fromInteger
12:28:43 <earthy> err. Data.Time.Clock.NomailDiffTime
12:28:47 <earthy> Nomina
12:28:54 <dmwit> You're 0 for 3. =P
12:28:58 * earthy stops trying to type correctly. :)
12:29:09 <ddarius> That's the trick to speed.
12:29:45 <earthy> but the docs state: data NominalDiffTime
12:29:45 <oerjan> earthy: it seems the Enum and Num may have different purposes
12:29:46 <earthy> This is a length of time, as measured by UTC. Conversion functions will treat it as seconds.
12:30:02 <dmwit> earthy: I don't think difftime is what you want.
12:30:19 <earthy> dmwit: okay, then explain how to get from an EpochTime to a UTCTime. :)
12:30:24 <dmwit> I'm working on it. =)
12:30:36 <dmwit> Can you point me at the Data.Time docs?  Google is failing me.
12:30:52 <Orphi> alright people, I just posted tonights learnings to Haskell-cafe, where others will hopefully be able to find it... heh.
12:31:03 <ddarius> Orphi: We have a wiki
12:31:13 <Orphi> true, that too..
12:31:27 <earthy> http://www.haskell.org/ghc/docs/latest/html/libraries/time-1.1.2.0/Data-Time.html
12:31:47 <Orphi> who's actually responsible for Cabal anyway?
12:31:53 <Orphi> is it the GHC guys, or a seperate team?
12:32:37 <dmwit> earthy: parseTime
12:33:03 <dmwit> parseTime "%s" -- %s is for seconds from the Unix epoch
12:33:28 <earthy> that... kinda *SUCKS*BIGTIME*
12:33:47 <earthy> I shouldn't need to convert the EpochTime to a string!
12:33:52 <dmwit> Yeah, there's probably another way.
12:33:55 <dmwit> I'm still looking. =)
12:34:07 <faxathisia> what about this code http://ofb.net/~frederik/stla/ ?
12:34:09 <earthy> plus, parseTime isn't in Data.Time in 6.6.1
12:34:15 <dmwit> false
12:34:56 <faxathisia> It's a bit hairy ? :S
12:36:44 <dmwit> earthy: There's a secondsToDiffTime, do you have a constant epochTime?
12:37:28 <earthy> dmwit: I have a System.Posix.Files.FileStatus
12:37:49 <earthy> from which I can get e.g. an accessTime which is an EpochTime
12:37:59 <earthy> (plus, secondsToDiffTime == fromInteger)
12:38:52 <dmwit> I'm just saying, to use a DiffTime you need a starting date.
12:39:13 <earthy> yeah, that's (UTCTime (fromGregorian 1970 1 1) 0)
12:39:37 <dmwit> Okay, so you have that constant, and you have fromInteger, what's missing?
12:39:59 <earthy> the problem being that fromInteger :: Integer -> DiffTime
12:40:10 <faxathisia> Isn't there any decent matrix library in haskell?
12:40:16 <earthy> but me having an EpochTime
12:40:20 <faxathisia> I really can't find one
12:40:22 <ddarius> faxathisia: There are bindings.
12:40:27 <faxathisia> hmm :(
12:41:03 <earthy> *TreeZipper System.Posix.Time Data.Time> do t<-epochTime; putStrLn . show . (flip addUTCTime (UTCTime (fromGregorian 1970 1 1) 0)) . fromInteger $ t
12:41:13 <earthy> Couldn't match expected type `Integer' against inferred type `System.Posix.Types.EpochTime'
12:41:30 <faxathisia> nothing written in haskell itself?
12:41:36 <dmwit> oh
12:41:44 <earthy> where System.Posix.Time.epochTime is just a simple way of getting at an EpochTime
12:41:49 <earthy> for testing purposes
12:41:56 <ddarius> fromIntegral
12:42:13 <earthy> ddarius: which is in Integral, which EpochTime does not have an Instance for
12:42:48 <ddarius> faxathisia: Nothing serious I don't think.
12:43:12 * dmwit suggests parseTime . show =/
12:43:22 <earthy> dmwit: yeah, but that sucks gigantically
12:43:28 <faxathisia> ok I'm going to write some basics
12:43:55 <dmwit> earthy: Well... it's not *that* bad.  It isn't really what I would call "best practice", but there's not that much wrong about it.
12:44:07 <ddarius> Attempting to write correct, numerically stable, and efficient linear algebra routines is a big wheel to reinvent.
12:44:16 <earthy> dmwit: plus, my installation doesn't have parseTime. :)
12:44:20 <faxathisia> I think the best way to represent a matrix is STArray
12:44:22 <dmwit> Seriously?
12:44:27 <faxathisia> so then I can mutate it, does that sounds reasonable?
12:44:28 <earthy> seriously. it wasn't in 6.6
12:44:37 <dmwit> I'm running 6.6 right now and I can see it.
12:44:40 <earthy> (it is in 6.8.1)
12:44:42 <dmwit> Are you sure you didn't just mistype? =P
12:44:45 <ddarius> faxathisia: Depends on what you're going for.
12:44:47 <faxathisia> { e.g. data (Fractional a) => Matrix s a = Matrix' (STArray s (Int, Int) a) }
12:45:16 <earthy> *TreeZipper System.Posix.Time Data.Time> :module  + Data.Time.Format
12:45:16 <earthy> Could not find module `Data.Time.Format':
12:45:19 <ddarius> Don't put class constraints on data types.
12:45:32 <earthy> time-1.0
12:46:12 <dmwit> Hm, I have time-1.1.1 for some reason.  Okay, that's probably why.
12:46:43 <faxathisia> ddarius: I want to avoid what I did in my previous code which is a lot of copying to and from lists
12:47:07 <earthy> @hoogle unsafeCoerce
12:47:08 <lambdabot> No matches found
12:48:17 <faxathisia> oh wait should I use IOArray instead of STArray?]
12:48:31 <ddarius> faxathisia: Depends on what you're going for.
12:48:54 <faxathisia> ddarius: What can I say?
12:49:08 <ddarius> What do you want to do with this?
12:50:26 <earthy> do t<-epochTime; putStrLn . show . (flip addUTCTime (UTCTime (fromGregorian 1970 1 1) 0)) . fromInteger . (read :: String -> Integer) . show $ t
12:50:29 <earthy> 2007-11-19 20:50:19 UTC
12:50:54 <earthy> that's a reasonably safe version
12:50:57 <dmwit> heh
12:51:02 <earthy> !sigh
12:51:07 <ddarius> You shouldn't need ' :: String -> Integer'
12:51:14 * dmwit sees a read . show in there... =P
12:51:31 <earthy> yea
12:51:46 <earthy> it's better than going unsafeCoerce#
12:51:58 <dmwit> read . show is a sign that the library isn't doing what you want, I think.
12:52:01 <int-e> @index epochTime
12:52:01 <lambdabot> System.Posix.Time, System.Posix
12:52:14 * earthy nods
12:52:26 <faxathisia> ddarius: write some matrix operations and then more based on those
12:52:46 <ddarius> faxathisia: To do what?
12:52:57 <faxathisia> That was all really
12:53:12 <faxathisia> later I want to write something to solve sparse matrices but I don't know which type of ones they are yet
12:53:41 <ddarius> faxathisia: Do you want this stuff to be fast or general or easy to use or easy to write or what?
12:54:07 <faxathisia> sort of fast and general yeah
12:55:30 <faxathisia> I don't know how anyone decides which datatypes to use
12:56:22 <ddarius> They decide based off the intended problem domains the library is supposed to handle well.
12:57:35 <ddarius> @users
12:57:35 <lambdabot> Maximum users seen in #haskell: 418, currently: 407 (97.4%), active: 12 (2.9%)
12:58:25 <oerjan> it got reset again? :/
13:15:21 <jedbrown> Why does this cause a link error?
13:15:21 <jedbrown>      foreign import ccall foo :: CInt; #{def inline int foo () { return 5; }}
13:15:52 <dmwit> Guess what inline means?
13:15:54 <integral> "inline"?
13:16:47 <jedbrown> My reading of the hsc2hs docs says that inline functions can be handled this way.
13:17:06 <cinimod> does anyone know if catch works with gadts?
13:18:30 <cinimod> Aah I see I've already asked Neil this question and apparently it didn't
13:30:00 <bakert> why is "ap" called "ap"?
13:30:46 <cinimod> :t ap
13:30:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:30:49 <oerjan> APply, presumably
13:31:00 <ddarius> Indeed
13:31:12 <bakert> ah
13:31:40 <bakert> cinimod: ap is "liftM2 id"
13:31:44 <bakert> :src ap
13:31:48 <bakert> ?src ap
13:31:48 <lambdabot> ap = liftM2 id
13:31:50 <bakert> evn
13:31:52 <bakert> *even
13:32:04 <ddarius> And ($) = id
13:32:10 <oerjan> @src even
13:32:10 <lambdabot> even n = n `rem` 2 == 0
13:32:14 <bakert> :)
13:32:48 <bakert> i am cogitating on liftM2 today
13:32:54 <bakert> i am mostly getting it
13:32:56 <bakert> thanks to mauke
13:33:09 <ddarius> It's obvious if you understand monads
13:33:13 <ddarius> @src liftM2
13:33:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:33:20 <bakert> i do and i don't
13:33:39 <astrolabe> :t liftM2
13:33:39 <bakert> the trouble is the monad i am dealing with is (i think) list
13:33:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:33:48 <bakert> which i don't think of as a monad
13:33:56 <bakert> what is bind for the list monad?
13:34:07 <faxathisia> :t >>=
13:34:08 <lambdabot> parse error on input `>>='
13:34:08 <ddarius> @src [] (>>=)
13:34:08 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:34:11 <faxathisia> hm
13:34:12 <byorgey> bakert: it's flip concatMap.
13:34:16 <ddarius> Which is to say flip concatMap
13:34:31 <bakert> so when i do my liftM2
13:34:35 <byorgey> bakert: you can think of the list monad as the nondeterministic choice monad.
13:34:43 <bakert> i can?
13:34:44 <bakert> :)
13:34:53 <ddarius> Alternatively, do a <- as; b <- bs; return $ a + b  <=> [a+b | a <- as, b <- bs]
13:35:03 <faxathisia> bakert: yeah look at the pythagorean triples code
13:35:10 <ddarius> bakert: THat is the way you should be thinking about it (and similarly for other monads)
13:35:15 <byorgey> so liftM2 f l1 l2 means 'apply f to each possible combination of values from l1 and l2'
13:35:19 <faxathisia> i think that demonstrates what byorgey said quite well
13:35:36 <bakert> ?where pythagorean
13:35:36 <lambdabot> I know nothing about pythagorean.
13:36:01 <faxathisia> pythags = [ (x, y, z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2 ]
13:36:02 <byorgey> > liftM2 (+) [1,2,3] [4,9]
13:36:04 <lambdabot>  [5,10,6,11,7,12]
13:36:33 <bakert> egad
13:36:41 <bakert> i'll write that down to think about later
13:37:18 <bakert> the reason all this arises is because i am messing with ?pl and lambdabot
13:38:00 <oerjan> @vixen do you think bakert should mess with you?
13:38:00 <faxathisia> > [1..] >>= (\z-> [1..z] >>= (\y-> [1..y] >>= (\x-> if x^2 + y^2 == z^2 then [] else [(x,y,z)])))
13:38:06 <lambdabot> me?
13:38:06 <lambdabot>  [(1,1,1),(1,1,2),(1,2,2),(2,2,2),(1,1,3),(1,2,3),(2,2,3),(1,3,3),(2,3,3),(3,...
13:38:21 <ddarius> faxathisia: guard
13:38:25 <faxathisia> oops.. that's everything that isn't a pythagorean triple
13:38:25 <faxathisia> :p
13:38:39 <bakert> ?pl (\x -> (pred x) && (f z x))
13:38:39 <lambdabot> liftM2 (&&) pred (f z)
13:39:14 <byorgey> bakert: that's the ((->) r) monad.
13:39:19 <bakert> ah
13:39:20 <bakert> yes
13:39:27 <bakert> i'd forgotten that
13:39:49 <bakert> which is why the list stuff makes no sense in connection with my example :p
13:39:53 <bakert> sorry
13:40:21 <bakert> i don't think i understand (->)
13:40:39 <bakert> ((->) r) is a partial application of function definition itself in some way?
13:40:50 <bakert> hmm
13:41:00 <bakert> that makes no sense thomas
13:41:01 <bakert> :(
13:41:16 <bakert> mauke very kindly took me through the reader monad
13:41:18 <bakert> which made sense
13:41:30 <bakert> then he sort of waved his hands and said "but you don't need reader"
13:41:35 <bakert> and i think that's where my brain gave up
13:41:49 <bakert> when i do my
13:42:01 <bakert> liftM2 (&&) p (f y)
13:42:07 <bakert> what is happening?
13:42:11 <TSC> @src liftM2
13:42:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:42:19 <bakert> the bind of the ((->) r) monad is invoked
13:42:23 <bakert> to get two values
13:42:28 <ddarius> @src (->) (>>=)
13:42:29 <lambdabot> f >>= k = \ r -> k (f r) r
13:42:30 <bakert> and then a && b is done
13:42:56 <ddarius> Take the definition of >>= and the definition of liftM2 and calculate
13:45:29 <bakert> ok simple things first.  the ((->) r) monad has a bind operation.  this if an infix operator.  the result is a function.
13:45:37 <bakert> s/result/value/
13:45:51 <bakert> a funciton of one argument.
13:46:33 <bakert> (f r) r
13:46:57 <Saizan_> (f r) and r are passed as arguments to k
13:47:11 <bakert> yep
13:47:13 <bakert> right
13:47:20 <bakert> so the function that is the result of the bind operation
13:47:28 <bakert> takes an argument
13:47:40 <bakert> that is passed to a function made by applying f to the argument
13:47:51 <bakert> and then k is applied to the value of all of that
13:48:16 <bakert> i think i am going to have to sleep on this one
13:48:36 <bakert> thanks folks
13:48:37 <dmwit> bakert: Conceptually:
13:48:48 <dmwit> f reads from an environment to give a value.
13:48:50 <nominolo> @seen mboes
13:48:50 <lambdabot> I haven't seen mboes.
13:48:59 <ddarius> In this particular case, and in many others, it's often best to just follow the types and assume the "obvious" implementation.
13:49:08 <dmwit> k needs that value to construct itself.
13:49:33 <dmwit> So, to construct the "k" bit of the monad, let f read from the environment (that's (f r)), then give that value to k.
13:49:52 <dmwit> Now, since "k" is a reader monad, it also reads from the environment.
13:49:57 <dmwit> So send it the "r", also.
13:50:05 <ddarius> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
13:50:05 <lambdabot> f a b c = b (a c) c
13:50:07 <dmwit> And that gives k (f r) r -- just like above.
13:50:22 <bakert> oh i see
13:50:32 <bakert> (f r) and r are arguments to k
13:50:36 <dmwit> right!
13:50:40 <bakert> i'm not sure why i wasn't reading it like that!
13:51:00 <bakert> so i do this bind (twice for liftM2)
13:51:06 <bakert> and i have these functions
13:51:09 <dons> @tell int-e -O3 is suboptimal
13:51:09 <lambdabot> Consider it noted.
13:51:12 <bakert> that are made by doing hte bind
13:51:27 <bakert> f1 && f2
13:51:32 <bakert> what does that do?
13:51:43 <dmwit> Well, f1 and f2 would have to be Bool for that to type-check.
13:51:52 <bakert> i see right
13:52:02 <bakert> so the result of the bind operations (because of what i pass in) are -> Bool
13:52:07 <dmwit> But since you're inside the monad, they are "Bool" types.
13:52:09 <bakert> so when I && them together
13:52:14 <bakert> i get -> Bool out
13:52:17 <dmwit> right
13:52:18 <bakert> hence it works
13:52:20 <bakert> cool
13:52:36 <bakert> i think i understand that.  but i am going to read it again tomorrow morning to be sure.
13:53:05 <bakert> thanks folks and good night your patience once more appreciated!!!
13:57:02 <BMeph> @seen Lindsay Lohen act
13:57:02 <lambdabot> I haven't seen Lindsay.
13:57:16 <dmwit> Heh, nice try.
13:57:35 <ddarius> Not really
13:57:48 <dibblego> ?type msum
13:57:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:58:11 <dibblego> ?type mplus
13:58:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:01:11 <olsner> is msum == join for [a]?
14:01:40 <dmwit> ?src mplus []
14:01:40 <lambdabot> Source not found. Are you on drugs?
14:01:44 <dmwit> ?src [] mplus
14:01:44 <lambdabot> mplus = (++)
14:01:46 <dmwit> yes
14:01:51 <ddarius> @src msum
14:01:51 <lambdabot> msum =  foldr mplus mzero
14:01:56 <ddarius> @src concat
14:01:56 <lambdabot> concat = foldr (++) []
14:02:06 <faxathisia> how do you find mzero for a given monad?
14:02:13 <olsner> ?src [] mzero
14:02:14 <lambdabot> mzero = []
14:02:18 <olsner> ?src
14:02:18 <lambdabot> src <id>. Display the implementation of a standard function
14:02:26 <olsner> bah, undocumented!
14:02:30 <faxathisia> ?src ((->) e) mzero
14:02:30 <lambdabot> Source not found. stty: unknown mode: doofus
14:02:33 <faxathisia> hmf
14:02:46 <faxathisia> @instances Monad
14:02:47 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:02:51 <byorgey> ?src (->) mzero
14:02:51 <lambdabot> Source not found. You speak an infinite deal of nothing
14:02:56 <olsner> not sure -> has mzero
14:02:58 <ddarius> There isn't an mzero instance for (r ->0
14:03:04 <faxathisia> no mzero O_o
14:03:06 <BMeph> ?src ((->) r) mzero
14:03:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:03:15 <faxathisia> what the hell
14:03:20 <byorgey> it's not an instance of MonadPlus.
14:03:26 <faxathisia> @instances MonadPlus
14:03:26 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:03:27 <dibblego> msum' :: (MonadPlus m, Foldable f) => f m a -> m a
14:03:37 <faxathisia> ?src Maybe mzero
14:03:37 <lambdabot> mzero = Nothing
14:03:49 <olsner> > concat . repeat $ []
14:03:50 <lambdabot>  Exception: <<loop>>
14:04:15 <olsner> I spoke an infinite deal of nothing, but no witty response from lambdabot.
14:04:48 <ddarius> > msum (repeat mzero)
14:04:48 <lambdabot>   add an instance declaration for (Show (m a))
14:05:19 <faxathisia> > msum (repeat mzero) :: []
14:05:19 <lambdabot>      `[]' is not applied to enough type arguments
14:05:19 <lambdabot>     Expected kind `?', but ...
14:05:21 <faxathisia> hmf
14:05:26 <faxathisia> > msum (repeat mzero) :: [Int]
14:05:26 <lambdabot>  Exception: <<loop>>
14:05:32 <faxathisia> > msum (repeat mzero) :: Maybe Int
14:05:32 <lambdabot>  Exception: <<loop>>
14:05:35 <faxathisia> cool :D
14:05:52 <faxathisia> What's a MonadPLus?
14:06:05 <olsner> a monad that has mplus and mzero
14:06:21 <dibblego> ?type mplus
14:06:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:06:23 <dibblego> ?type mzero
14:06:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:06:35 <dibblego> ?src [] mplus
14:06:35 <lambdabot> mplus = (++)
14:06:48 <dibblego> [1,2,3] `mplus` [4,5,6]
14:06:49 <dibblego> > [1,2,3] `mplus` [4,5,6]
14:06:50 <lambdabot>  [1,2,3,4,5,6]
14:06:56 <olsner> ?src Maybe mplus
14:06:56 <lambdabot> Nothing `mplus` ys  = ys
14:06:56 <lambdabot> xs      `mplus` _ys = xs
14:07:17 <olsner> does haskell have _-prefixed names, or is that just a fluke?
14:07:32 <ddarius> olsner: _ can be used anywhere in a name
14:07:50 <olsner> but _ is special, right?
14:07:59 <olsner> > (\_ -> _) 7
14:07:59 <lambdabot>  Parse error in expression at end of input
14:08:03 <ddarius> By itself, yes.
14:08:16 <ddarius> But then so is '
14:08:33 <BMeph> It's used in pattern matching for a pattern that always matches.
14:08:36 <faxathisia> > (\__ -> __) 7
14:08:37 <lambdabot>  7
14:09:34 <faxathisia> @src msum
14:09:35 <lambdabot> msum =  foldr mplus mzero
14:09:45 <faxathisia> > msum [Nothing, Nothing, Just 3, Nothing, Just 4]
14:09:45 <lambdabot>  Just 3
14:09:48 <olsner> ah, that's what I thought I knew, but now I know I know it
14:10:04 <faxathisia> > msplit [Nothing, Nothing, Just 3, Nothing, Just 4]
14:10:04 <lambdabot>   Not in scope: `msplit'
14:10:11 <ddarius> > (\_' -> _') 3
14:10:11 <lambdabot>  3
14:10:29 <olsner> ah, cute ;-)
14:16:19 <dmwit> > let O_o = const 0-0 in O_o O_o
14:16:20 <lambdabot>   Not in scope: data constructor `O_o'
14:16:27 <dmwit> doh
14:16:32 <faxathisia> haha
14:16:40 <faxathisia> > _ <
14:16:40 <lambdabot>  Parse error in expression at end of input
14:22:12 <dmwit> > let o_O = const d_b q_p; d_b = 0-0; q_p = (^^) in o_O
14:22:13 <lambdabot>  0
14:23:30 <BMeph> let o_O = const d_b q_p; d_b = 0-0; q_p = (^_^) in o_O
14:23:45 <Laney> Is there any way to `darcs changes' on a remote (http) repo?
14:23:52 <Laney> besides getting it
14:23:54 <dmwit> No good, _ isn't considered an infix character.
14:24:48 <BMeph> dmwit: Right - it seems to be my day for "nice tries". ;p
14:26:46 <dmwit> > let s = ">_^"; (/>/^/) ('>':xs) _ = '^':xs; g = g in s/>/^/g
14:26:47 <lambdabot>  "^_^"
14:28:20 * dmwit lies in wait to trap Perl programmers
14:29:03 <faxathisia> heh
14:29:09 <olsner> ... someone must like mopping up 'sploding perl coder brains
14:33:08 <davidL> is anyone aware of a haskell program that implements some sort of "tagging" interface?
14:34:28 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ChasingBottoms-1.2.2 (lazy properties for QuickCheck)
14:34:29 <lambdabot> http://tinyurl.com/3dwaqh
14:39:36 <matthew-_> my word. A blog article I wrote ended up on prog . reddit and there were actually some sane and sensible comments on it. People didn't randomly decide to flame me to a crisp. I'm impressed.
14:45:23 <ddarius> matthew-_: Your article sucks!
14:45:28 <matthew-_> thank you
14:45:35 <matthew-_> I feel much better now.
14:45:48 <dons> oh the one that mentions haskell only in passing?
14:46:00 * ddarius has no idea
14:46:08 <matthew-_> My default opinion of the population of the internet is safe once more
14:46:13 <matthew-_> dons: err, possibly
14:46:31 <matthew-_> the current front page of wellquite.org
14:47:11 <dons> that's the one
14:47:36 <dons> got a  lot of comments
14:47:39 <matthew-_> and I'm actually comming to the opinion that Haskell's Chan is message passing, and an MVar is just a one-place channel.
14:47:50 <matthew-_> dons: yeah, and many of them are perfectly sane.
14:48:26 <matthew-_> dons: you're at galois aren't you?
14:49:08 <dons> i am. yep
14:49:45 <matthew-_> I'm interested in how galois manages to convince its clients that writing software in a "weird" and "unheard-of" language is a good idea.
14:50:02 <dons> our clients request proofs
14:50:07 <matthew-_> that'd do it.
14:50:23 <faxathisia> dons:  cool, what kinds of proof?
14:50:32 <dons> but even the ones that don't care about security more than other things
14:50:38 <dons> so php doesn't cut it
14:50:40 <faxathisia> in some specification languages or something like that?
14:50:53 <dons> faxathisia: in theorem provers, typically
14:50:58 <matthew-_> ok so it really is a highly specialised field then, where competition is going to be slim?
14:51:18 <matthew-_> (or at least, competant competition?)
14:51:18 <dons> there's competition, but its at the high end of the reliability spectrum
14:51:20 <faxathisia> which ones do you think are good to look at ?
14:51:29 <matthew-_> interesting
14:51:35 <dons> so there's some pretty big hurdles to get over to be competitive in the first place
14:51:52 <dons> the users don't care as long as the binary runs on their system, too
14:51:59 <dons> so it doesn't matter what it was compiled from
14:52:23 <dons> we make the technical decisions :)
14:52:28 <matthew-_> oh right, so the client doesn't want access to the code at all?
14:52:44 <dibblego> is there a words function that inserts [] where there are consecutive words matching the argument?
14:52:45 <dons> i think it depends on the client. some want the code, and proofs for the code
14:52:50 <dibblego> such that there is an inverse
14:53:56 <faxathisia> there is so much theorem proving software
14:54:01 <matthew-_> dons: and do you do agile development? Are the projects you do projects that are going to alter the way your clients use computers? Or are they lower-level embedded projects that plugin (sorta) to existing systems and thus have little impact on HCI?
14:54:55 <ddarius> matthew-_: Chans should immediately suggest message passing.
14:55:04 <dons> both. there are low level embedded things, all the way up to web apps
14:55:48 <matthew-_> oh right. But presumeably the proofs are on aspects like correct implementation of Bell LaPadula and such like?
14:56:06 <dons> for the low level stuff
14:56:12 <dons> X does not access Y
14:56:14 <dons> and so forth
14:56:15 <matthew-_> yep
14:56:20 <matthew-_> you do proofs on web apps?
14:56:33 <dons> not that i'm aware of.
14:56:42 <faxathisia> hehe
14:56:43 * dons sits here writing QuickCheck properties for some JSON code
14:56:43 <faxathisia> http://www.cs.chalmers.se/~koen/folkung/
14:56:44 <lambdabot> Title: Paradox and Equinox
14:56:54 <dons> so semi-formal methods for web apps, anyway
14:57:09 <matthew-_> very interesting. well I must go to bed. night.
14:57:17 <faxathisia> dons: Which theorem proving software[s] do you typically use?
14:57:21 <faxathisia> or are typically used
14:57:27 <dons> Isabelle seems most common
14:57:39 <dmwit> dibblego: Shouldn't be hard to write; toggle between takeWhile/dropWhile.
14:57:44 <dons> galois recently released a web app testing framework, btw
14:57:51 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/selenium-0.2.2
14:57:53 <lambdabot> http://tinyurl.com/3de8la
14:57:58 <dibblego> dmwit, yeah I'm about to write it
14:57:58 <dons> we like testing
14:58:22 <matthew-_> dons: meh, just write proof carrying code and sod the testing :)
14:58:46 <dons> its all about correctness and assurance
14:58:46 <faxathisia> proof carrying code?
14:58:49 <faxathisia> How do you do that
14:58:56 <cbrad> dons: is that a haskell wrapper around thoughtworks selenium?
14:59:02 <dons> cbrad: yep
14:59:16 <matthew-_> faxathisia: the type of a value indicates various properties about the value
14:59:22 <dons> so you can hook it into quickcheck
14:59:24 <ddarius> faxathisia: You write code and and proof of correctness of that code and put them together.
14:59:36 <cbrad> we have done webapp testing here at that level - it is very time-consuming and brittle
14:59:49 <matthew-_> faxathisia: err, what ddarius said. I'm wrong. I'm describing something else
14:59:54 <dons> yes, ours is a bit more automated.
14:59:58 * matthew-_ heads to bed
15:00:09 <dons> we combine it with code coverage analysis
15:00:13 <dons> as well.
15:00:17 <dons> which is super useful
15:00:24 <faxathisia> ddarius: What's an example of that?
15:00:29 <dmwit> > let spaces [] ss = ss; spaces s ss = notSpaces (dropWhile isSpace s) : takeWhile isSpace s : ss; notSpaces [] ss = ss; notSpaces s ss = spaces (dropWhile (not . isSpace) s) : takeWhile (not . isSpace) s : ss; newWords s = notSpaces s [] in newWords "foo   bar baz eek   "
15:00:34 <lambdabot>      The equation(s) for `notSpaces' have two arguments,
15:00:34 <lambdabot>     but its type `[C...
15:00:36 <ddarius> (Actually, it's usually a proof that the code satisfies certain properties, e.g. memory safety)
15:01:58 <dibblego> ?djinn a -> [a]
15:01:58 <lambdabot> -- f cannot be realized.
15:02:11 <dibblego> ?djinn [a] -> [[a]]
15:02:11 <lambdabot> -- f cannot be realized.
15:02:20 <ddarius> djinn doesn't do recursive types
15:03:08 <faxathisia> Is an IP checksum an example of proof carrying code?
15:03:44 <ddarius> faxathisia: Not really.
15:06:22 <dmwit> ?hoogle (a -> Bool) -> [a] -> ([a], [a])
15:06:22 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:06:22 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:06:22 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:09:30 <faxathisia> "Proof-Carrying Code (PCC) is a technique by which a code consumer (e.g., host) can verify that code provided by an untrusted code producer adheres to a predefined set of safety rules."
15:09:41 <dmwit> > let spaces ss [] = ss; spaces ss s = let (y, n) = span isSpace s in notSpaces (y:ss) n; notSpaces ss [] = ss; notSpaces ss s = let (y, n) = break isSpace s in spaces (y:ss) n; newWords = reverse . notSpaces [] in newWords "foo bar   baz eek  "
15:09:42 <lambdabot>  ["foo"," ","bar","   ","baz"," ","eek","  "]
15:09:44 <faxathisia> It sounds like type checking but with more expressive type system
15:10:41 <dibblego> dmwit, nice one
15:10:55 <dmwit> Wait, it gets better. =)
15:11:21 <Laney> I understand PCC as: consumer writes code + properties that it must satisfy; consumer can verify that properties do indeed hold. Is this accurate?
15:11:35 <dmwit> > let spaces p ss [] = ss; spaces p ss s = let (y, n) = break p s in spaces (not . p) (y:ss) n; newWords = reverse . spaces isSpace [] in newWords "foo bar   baz eek   "
15:11:35 <lambdabot>  ["foo"," ","bar","   ","baz"," ","eek","   "]
15:11:42 <dons> Laney: yeah
15:11:42 <dmwit> Much shorter. =)
15:11:45 <dons> e.g.
15:11:50 <dons> provide source code, and types
15:12:01 <Laney> s/consumer/producer
15:12:02 <dons> the user can do type checking themselves to confirm the types are true
15:12:09 <dons> generalise that to proofs and proof checking
15:12:33 <Igloo> Is there a cunning way for a script to get the latest tarball for a package?
15:12:37 <dons> users don't need to trust the provider, they can do the proof checking themselves, however they want
15:12:38 <faxathisia> that's what I meant
15:12:47 <Igloo> (from hackage)
15:12:48 <dons> Igloo: cabal install seems to know how to do it?
15:12:54 <dons> cabal update
15:12:57 <dons> cabal install foo
15:13:05 <dmwit> Actually, that could be worse, if the run-time isn't smart enough to know that not . not === id.
15:13:11 <Igloo> That's doing more than I'd like a script to have to do, though
15:13:18 <faxathisia> I can't find any example of proof carrying code though
15:13:22 <faxathisia> what does it look like?
15:13:27 <dons> oh, the default package name has the .tar.gz link on it for the latest src
15:14:04 <ddarius> Laney: consumer writes properties and model producer writes code and proofs
15:14:57 <ddarius> faxathisia: Type checking can and is used to generate proofs of certain properties easily, but type systems don't need to be involved at all.
15:15:12 <faxathisia> ok that's confusing :p
15:15:18 <faxathisia> I thought everything was expressed as type
15:15:19 <ddarius> faxathisia: Usually PCC is viewed as working at the level of machine code as far as verification is concerned.
15:15:25 <dons> w3m -dump_source http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary/ | grep tar.gz | sed 's/.*ref=//;1q'
15:15:26 <lambdabot> http://tinyurl.com/ys3zg3
15:15:26 <faxathisia> but a more complex type system than e.g. haskells
15:15:31 <dons> "/packages/archive/binary/0.4.1/binary-0.4.1.tar.gz"
15:15:34 <dons> Igloo: ^^
15:15:47 <dons> prepend "http://hackage.haskell.org/cgi-bin/hackage-scripts/package/" to the package name
15:15:47 <ddarius> faxathisia: If you want to you can view things that way.
15:15:55 <dons> extract the first tar.gz from that page
15:16:03 <dons> download it with the same prepended url
15:16:05 <faxathisia> ddarius: That's just what I imagined from skimming some notes
15:16:26 <ddarius> faxathisia: The Curry-Howard correspondence relates type systems and logics.
15:17:17 <Igloo> dons: Hmm, thanks
15:17:37 <dons> Igloo: there's probably a filesystem way too, using ssh to the archive
16:33:07 <chessguy> @seen jgraves
16:33:07 <lambdabot> I haven't seen jgraves.
16:33:23 <chessguy> anybody remember the nick of the person doing the haskell spider solitaire?
16:33:34 <chessguy> his name is james graves
16:36:48 <chessguy> bah
16:52:07 <newsham> Hi
16:59:42 <paczesiowa> do I need cygwin to install network package on windows? (cabal needed ld which I found in ghc dir, but now it wants sh which isn't there)
17:04:02 <paczesiowa> that's kinda funny:P if I had question about some ultra higher order abstract generalized kind, there would 10 people willing to help. I have question about windows and you all go quiet:P
17:04:25 <dmwit> heh
17:04:33 <newsham> pacz: the Network package in extralibs?
17:05:12 <newsham> when I install ghc it came with Network
17:05:16 <newsham> on windows
17:05:27 <newsham> Fun with lhs2tex: http://www.thenewsh.com/%7Enewsham/Hats.pdf
17:07:36 <dmwit> newsham: cute
17:08:07 <paczesiowa> newsham: you're right. I needed http so I decided to install network first, but it's already there.
17:08:22 <newsham> ghc-pkg list is your friend
17:09:09 <paczesiowa> it's not natural to run cmd apps on windows for me, so I forgot about that:P
17:09:21 <paczesiowa> *app
17:10:45 <Botje> newsham: it looks like apl!
17:10:47 <newsham> a fork's no good for soup
17:11:05 <newsham> I dont know APL
17:11:09 <dmwit> ...unless it's ramen noodle soup.
17:11:38 <dmwit> APL has glyphs instead of named functions.  It's like reading Chinese.
17:11:43 <Botje> dmwit: you made me hungry
17:12:06 <sjanssen> newsham: this is an interesting idea
17:12:41 <newsham> I dont get full credit.  funmath notation uses hat and left/right arrow for lifting binops over functions
17:14:19 <newsham> binary operator modifiers
17:14:39 <newsham> I would like to use tihs trick, but it doesnt seem to be compatible with lhs2tex: http://www.haskell.org/pipermail/haskell-cafe/2007-October/033869.html
17:14:40 <lambdabot> Title: [Haskell-cafe] binary operator modifiers, http://tinyurl.com/2suvuc
17:14:41 <Botje> reminds me of perl 6 hyperoperators
17:14:55 <newsham> maybe I should switch to perl!  ;-)
17:15:13 <Botje> <+> = foldr1 (+)
17:15:18 <Botje> >+< was something else but I forgot
17:15:26 <paczesiowa> newsham: thanks for (obvious but still) help
17:15:44 <newsham> if I could define   -:liftM2 (op):-   as \widehat{op}   that would be happy
17:16:13 <newsham> botje: so lifting over lists?
17:16:22 <newsham> oh wait, no, its a reducer
17:16:22 <sjanssen> newsham: maybe you can use some clever CPP hackery?
17:16:45 <sjanssen> <+> doesn't seem very useful
17:17:04 <sjanssen> nearly all folds need a zero element
17:17:10 <newsham> I would think   <+> = zipWith (+)    would be a more interesting def
17:17:25 <newsham> sjanssen:  foldr1 has an implicit zero element no?
17:17:34 <dmwit> > foldr1 [] -- no
17:17:34 <newsham> (or more correctly avoids needing one)
17:17:35 <Botje> sjanssen: that's why it's foldr1
17:17:35 <lambdabot>  Couldn't match expected type `a -> a -> a'
17:17:40 <sjanssen> newsham: basically liftA2 in the zip Applicative, right?
17:17:49 <dmwit> > foldr1 (+) []
17:17:50 <lambdabot>  Exception: Prelude.foldr1: empty list
17:18:13 <newsham> hmm.. there's a zip applicative?
17:18:35 <dmwit> It may not be defined, but it appears in one of the Applicative papers.
17:18:35 <sjanssen> newsham: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Applicative.html#t%3AZipList
17:18:36 <lambdabot> http://tinyurl.com/2qd5f8
17:18:45 <newsham> danke
17:18:57 <Botje> I AM GOING TO EAT NOODLES.
17:19:03 <Botje> and then read a J tutorial
17:19:07 <Botje> and possibly sleep, too.
17:19:21 <sjanssen> it isn't the default instance for [], because that would conflict with the existing Monad instance for []
17:19:21 <dmwit> *poke*
17:20:16 <byorgey> Botje: have fun =)
17:21:24 <dons> cabal install rocks
17:21:35 <dons> it makes life so much easier for the working haskell programmer
17:21:49 <dons> setup: At least the following dependencies are missing: fastcgi >=3001
17:21:54 <dons> $ cabal install fastcgi
17:21:54 <dons> Downloading 'parsec-2.1.0.0'...
17:22:01 <dons> Downloading 'network-2.1.0.0'...
17:22:12 <dons> Downloading 'xhtml-3000.0.2.1'...
17:22:18 <dons> Downloading 'cgi-3001.1.5.1'...
17:22:29 <dons> Downloading 'fastcgi-3001.0.1'...
17:22:29 <dgriffi3> do all FFI calls happen in thread?
17:22:38 <dmwit> Urgh, that's a nasty dependency chain.
17:22:39 <vininim> please post also compiling outupt
17:22:41 <sjanssen> dgriffi3: not all of them
17:22:42 <newsham> sj: *nod*
17:23:13 <sjanssen> dgriffi3: in GHC, without the threaded runtime, FFI calls never use an extra thread
17:23:42 <dgriffi3> what if I am using the threaded runtime?
17:23:45 <dons> dmwit: not with cabal install :)
17:23:51 <sjanssen> dgriffi3: with the threaded runtime, FFI calls marked as "safe" get a thread, calls marked as "unsafe" don't
17:24:04 <dmwit> dons: Yep, looks like that's a Win. =)
17:24:20 <dons> cabal-installl FTW!
17:24:50 * dons goes back to work on secret proprietary codez
17:25:23 <dgriffi3> sjanssen: so if I wanted to use FFI calls in parallel everything needs to be marked unsafe?
17:25:34 <byorgey> dons: what, you do actual work? =)
17:25:38 <sjanssen> dgriffi3: no, they need to be marked as "safe"
17:25:51 <dgriffi3> sjanssen: ok, thanks
17:26:28 <dons> byorgey: its all i do, my gf says
17:26:37 <sjanssen> dgriffi3: use safe when you expect the function to block (like IO, etc.), use unsafe for quick non-blocking stuff
17:26:45 <byorgey> dons: hehe
17:28:32 <newsham> *uploads questionable code to cabal so he can peek at dons' propertary codez*
17:28:52 <newsham> (hows the security on the hackage site, btw?)
17:29:06 <dons> hackage is hosted at galois
17:29:16 * dons peeks at newsham's codes
17:29:18 <dons> inserts explotis
17:30:07 <dons> $ sed 's/id/unsafePerformIO (print "mwhahah") `seq` id' < newsham.tar.gz
17:30:31 <dons> we should put checksums on hackage
17:30:33 <byorgey> heh =)
17:30:42 <newsham> dons: touche
17:30:53 <jcreigh> dons: that won't work, it's gzipped. :)
17:30:56 <dmwit> I doubt that does what you want to a .gz ;-)
17:31:01 <newsham> yah, signatures or md5s would be useful.
17:31:04 <dons> jcreigh: proprietary sed codez :)
17:31:09 * vincenz was already thinking "sed does gz"?
17:31:15 <newsham> PGP signatures over all packages?
17:31:37 <vincenz> no
17:31:50 <SamB> or to a .tar!
17:31:54 <sorear> dons: don't you know about -i :)
17:31:58 <vincenz> 2^32 quantum bits
17:32:03 <dons> sorear: gnu sed extn.
17:32:16 <newsham> instance Functor gz
17:32:19 <shapr> dons: Where's that cabal?
17:32:20 <newsham> fmap it
17:32:36 <newsham> instance Functor tar
17:32:37 <dons> shapr: cabal-install? that's darcs cabal install, and darcs cabal 1.3.x
17:32:37 <vincenz> fmap f = gzip . f. gunzip
17:32:46 <vincenz> easynuff
17:32:49 <shapr> Ah, I'll install that.
17:35:41 <Captain_Thunder> Is there a function to tell me how many characters in a string are different?
17:35:48 <dmwit> length . nub
17:35:50 <newsham> different than what?
17:35:55 <Captain_Thunder> ie, diff "ab" "ac" => 1
17:36:01 <dmwit> oh
17:36:06 <newsham> do you want minimum edit distance?
17:36:22 <newsham> or just position-by-position compare?
17:36:38 <Captain_Thunder> Either, I guess.
17:37:04 <sjanssen> > length . filter id $ zipWith (/=) "ab" "ac"
17:37:06 <lambdabot>  1
17:37:08 <newsham> filter id (zipWith (/=) "this is a test" "thos ir a tust")
17:37:14 <newsham> > filter id (zipWith (/=) "this is a test" "thos ir a tust")
17:37:15 <lambdabot>  [True,True,True]
17:37:25 <vincenz> > length . filter not . zipWith (==) $ "abc "adc"
17:37:25 <lambdabot>  Improperly terminated string at """ (column 47)
17:37:35 <vincenz> > length . filter not $ zipWith (==)  "abc" "adc"
17:37:35 <lambdabot>  1
17:37:48 <shapr> Hm, Crypto doesn't build...
17:37:49 <newsham> min-edit-distance is more involved
17:37:58 <vincenz> newsham: how's that work?
17:38:03 <dmwit> \s t -> system $ "diff -i " ++ s ++ t
17:38:14 <vincenz> dmwit: unsafePerformIO :)
17:38:20 <vincenz> make it functional!
17:38:23 <Captain_Thunder> @type zipWith
17:38:24 <newsham> dynamic programming.  you calculate all possible edit distances, and return the minimum
17:38:24 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:38:25 <dmwit> heh
17:38:29 <newsham> http://en.wikipedia.org/wiki/Levenshtein_distance
17:38:29 <lambdabot> Title: Levenshtein distance - Wikipedia, the free encyclopedia
17:38:59 <newsham> the algorithm is really simple, and you can implement it with simple recursion if you have caching
17:39:15 * shapr fixes crypto
17:39:21 <vincenz> newsham: thx
17:39:47 <newsham> i have some examle code but not in haskell
17:40:00 <newsham> oh also I think there's an implementation in hpaste
17:40:01 <vincenz> which lang?
17:40:04 <newsham> python
17:40:07 <shapr> @where hunit
17:40:09 <lambdabot> http://hunit.sourceforge.net/
17:40:16 <shapr> I want to know where the darcs repo is :-/
17:40:22 <vincenz> newsham: long?
17:40:24 <shapr> I want a @hackage command!
17:40:27 <vincenz> newsham: can I see?
17:40:44 <shapr> Crypto on hackage is missing deps.
17:40:46 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/diff2.py  (and diff.py)
17:41:04 <newsham> one's memoized, the other's table driven
17:41:25 <newsham> also one demonstrates how to recover the min-edit sequence, and the other just returns the min edit distance
17:42:45 <Saizan_> there's mine somewhere on hpaste, 2 nested foldr
17:43:04 <newsham> google is a great hpaste search (should be integrated into hpaste)
17:43:57 <newsham> oh, I did have a haskell one.  http://www.thenewsh.com/%7Enewsham/x/machine/diff4.hs
17:44:12 <newsham> thats the table driven version
17:45:27 <newsham> http://hpaste.org/100
17:45:35 <newsham> thats saizan's on hpaste
17:47:08 <Saizan_> brr, quite unreadable
17:48:34 <newsham> you mispelled levenshtein
17:48:54 <dmwit> You should see my sh implentation, it's very readable. =)
17:49:02 <cbrad> I am getting different output from my program depending on whether I compile with -O2 or not
17:49:09 <cbrad> I am using GHC 6.8.1
17:49:14 <vincenz> cbrad: @hpaste
17:49:20 <dmwit> cbrad: That sounds bad.  Care
17:49:25 <dmwit> ...to share?
17:49:26 <cbrad> Is there any known problems?
17:49:36 <cbrad> There is a fair amount of code
17:49:46 <dmwit> (My backspace key is too close to my enter key.)
17:49:53 <cbrad> I would need to distill it down to try and isolate it
17:50:08 <cbrad> Just thought someone might know something about it
17:50:16 <cbrad> I saw some GHC 6.8.1 issues on the caffe
17:52:02 <Saizan_> cbrad: can you summarize the differencies?
17:52:30 <cbrad> I am doing a lot of fairly simple numerical calculations
17:52:53 <cbrad> The numbers output are different depending on whether I compile with -O2 or not
17:53:07 <cbrad> I haven't been able to identify a pattern yet
17:53:17 <Saizan_> ah, with Doubles?
17:53:20 <dmwit> Are you using floats/doubles?
17:53:45 <cbrad> Mainly with Int, I think
17:54:01 <dibblego> vincenz, I have an implementation in Scala if you like (for levenshtein distance)
17:54:37 <cbrad> No there might be some floats in there to
17:55:20 <kjnfkjnkjfgkjfgk> DCC SEND "startkeylogger" 0 0 0
17:55:30 <dmwit> Whoa, kjnfkjnkjfgkjfgk must be hard to type for those of you without tab-completion.  I hope he asks a million questions.
17:55:46 <vincenz> dibblego: nah, that's fine :)
17:55:51 <dmwit> Errr... that looks ominous.
17:56:09 <vincenz> he left?
17:56:18 <dibblego> vincenz, it uses a global memo table (akin to unsafePerformIO)
17:56:24 <dmwit> I'd say that about half a dozen people here have a Trojan. =P
17:56:30 <vincenz> dibblego: like the python version?
17:56:37 <dibblego> vincenz, where is the python version?
17:56:40 <vincenz> dmwit: Why only that brand?
17:56:51 <vincenz> dibblego: newsham's: http://www.thenewsh.com/%7Enewsham/x/machine/diff2.py
17:57:00 <dibblego> ?check \xs -> xs ++ [] == (xs :: [Int])
17:57:12 <newsham> and also diff.py at the same dir
17:57:15 <lambdabot>  thread killed
17:57:16 <dibblego> vincenz, yep, pretty similar
17:57:53 <Saizan_> well, you don't need a memo table.. you can just build it incrementally by columns keeping only the last
17:58:03 <dibblego> vincenz, http://tinyurl.com/2nzkga
17:58:06 <newsham> yah, my diff.py doesnt use memoization
17:58:11 <Saizan_> (that's the spirit of my poorly written implementation)
17:58:38 <vincenz> dibblego: thx
17:58:40 <vincenz> dibblego: verbose :)
17:58:50 <sjanssen> dmwit: IIRC, it's a bug in some router's firmware
17:58:57 <dibblego> vincenz, it's not really; it's the same 4 or 5 lines of code
17:59:05 <dmwit> sjanssen: Ah, okay, I won't bother ?telling them, then.
18:00:08 <Saizan_> sjanssen: that you can trigger with that line?
18:00:09 <newsham> my diff.py keeps the full table (not just the last column)
18:01:32 <dmwit> newsham: Did you know that thenewsh.com behaves badly if it doesn't get a www. in the address?
18:01:47 <newsham> *nod*
18:01:51 <dmwit> ok
18:02:04 <newsham> thanks
18:02:32 <vincenz> dibblego: haha, like lisp :)
18:02:42 <vincenz> m(f)(i - 1)(get(i - 1))(j - 1) + (if(e) 0 else 1)
18:02:46 <vincenz> any more () and it'd be lisp
18:03:16 <dibblego> vincenz, yeah Scala is a bit parenthesesy :) it panders to Java-ness
18:03:42 <dibblego> but those parentheses are actually to aid partial application
18:03:46 <vincenz> I don't get all the parameters
18:03:52 <vincenz> m seemed to be 2 didmensional
18:03:55 <vincenz> or potentially 3
18:04:02 <dibblego> m :: (A => B) => A => B
18:04:10 <newsham> here's another impl: http://www.scannedinavian.com/~eric/hpaste/DiffHtml.hs
18:04:27 <dibblego> but then B is a function type (thus, taking more arguments)
18:04:33 <vincenz> dibblego: you mean im
18:04:49 <dibblego> no, m
18:04:52 <vincenz> oh
18:05:10 <dibblego> im is the 'memo strategy'
18:05:12 <vincenz> what does val m = im[Memo[Int, Int]](x.length + 1) mean
18:05:43 <vincenz> and how does that translate to java? Since the stuff seems to be imported from java
18:05:57 <newsham> scala emits JVM bytecode
18:06:02 <dibblego> no, it's definitely not imported from Java
18:06:04 <newsham> and lets you call into Java
18:06:15 <vincenz> ah
18:06:17 <dibblego> it is actually a bit more general than a typical implementation
18:06:21 <dibblego> you pass in 'how to memo'
18:06:42 <dibblego> it is part of a memoisation library that I wrote
18:06:54 <vincenz> what do [] brackets do?
18:07:01 <vincenz> cause m is
18:07:03 <dibblego> passing type arguments
18:07:13 <vincenz> SizedMemo[Int][Memo[Int, Int]]
18:07:13 <dibblego> since Scala's type inferencer is not as clever as Haskell's
18:07:13 <vincenz> ?
18:07:35 <dibblego> that doesn't look legit to me
18:07:38 <vincenz> and what of the (x.length + 1) at the end?
18:07:44 <vincenz> maybe this is a bit too OT
18:07:46 <dibblego> the size of the memo table
18:07:48 <vincenz> and I should just RTFM
18:08:07 <dibblego> since ED can pass a memo table size (not all algorithms can for example)
18:09:01 <vincenz> I'll look at it again tomorrow
18:09:05 <vincenz> Thx
18:09:09 <dibblego> one might consider using a Map for the memo table for example
18:09:15 <vincenz> yep
18:09:31 <dibblego> and the library abstracts all that away (so long as (A => B) => A => B guarantees no side-effects)
18:09:44 <dibblego> it is a library that Haskell needs :)
18:09:52 <vincenz> sounds like tc's to me
18:10:05 <dibblego> tc's? I know there was talk about such a library
18:10:05 <vincenz> tlc tc
18:10:10 <vincenz> type classes
18:10:18 <dibblego> ah yes, it would be done with a type class
18:10:22 <nornagon> @djinn [a -> a -> a] -> [a] -> [a]
18:10:23 <lambdabot> f _ a = a
18:10:26 <dibblego> @where weak
18:10:26 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
18:10:33 <dibblego> that paper explains all the options
18:10:35 <vincenz> night
18:10:37 * vincenz nods
18:10:38 <nornagon> @hoogle [a -> a -> a] -> [a] -> [a]
18:10:38 <lambdabot> No matches, try a more general search
18:10:40 <vincenz> Thanks, I'll take a look at it
18:10:41 <dibblego> seeya
18:10:45 <nornagon> hm
18:10:52 <vincenz> nornagon: o.O?
18:11:12 <dibblego> ?type insertWith
18:11:13 <lambdabot> Not in scope: `insertWith'
18:11:18 <dibblego> ?type Data.Map.insertWith
18:11:18 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
18:11:18 <vincenz> @pl \f x -> zipWith ap (map join f) x
18:11:18 <lambdabot> zipWith ap . map join
18:11:22 <vincenz> you need that?
18:11:27 <vincenz> @pl \f x -> zipWith ($) (map join f) x
18:11:27 <lambdabot> zipWith id . map join
18:11:35 <nornagon> I want to take a list of operators like [(+), (-), (*)] and a list of numbers like [1,2,3,4] and 'insert' the operators between the numbers
18:11:38 <vincenz> @type zipWith id . map join
18:11:38 <lambdabot> forall b a. [b -> b -> a] -> [b] -> [a]
18:11:47 <vincenz> oh
18:11:54 <nornagon> disregarding precedence
18:12:26 <vincenz> doubt there's such a thing
18:12:30 <vincenz> cause it's such a one-off kinda thing
18:12:37 <vincenz> I mean the operators must be exactly one shorter than the numbers
18:12:38 <nornagon> yeah, guess so
18:12:42 <nornagon> i'll roll my own then
18:12:56 <vincenz> nornagon: think of the cases where lenght of operators is bigger, and where lenght of operators is msaller
18:13:02 <vincenz> the first is relatively easy, just ignore
18:13:04 <vincenz> the last is less clear
18:13:10 <nornagon> yep
18:13:18 <nornagon> it's just a solution to a silly problem :)
18:13:21 <vincenz> ignore extra numbers?
18:13:34 <scook0> well, if you start with zipWith ($), you get [(1+),(2-),(3*)]
18:13:47 <vincenz> scook0: nope
18:13:57 <vincenz> won't work for last one
18:14:01 <vincenz> told you, one off
18:14:13 <scook0> it's only a start :)
18:14:15 <Raguel> can i check if anyone can read this?
18:14:21 <vincenz> app f [] = ???
18:14:27 <byorgey> Raguel: sure, go ahead =)
18:14:28 <vincenz> app f [x] = x
18:14:47 <vincenz> app f (x:xs) = app' f x xs
18:14:56 <Raguel> hmmm - either everyone on #math has me /ignored or they're not answering then...
18:15:10 <vincenz> app' f x [] = x; app' f x (y:ys) = app' f (x`f`y) ys
18:15:15 <byorgey> Raguel: what sort of math?
18:15:19 <scook0> then you can apply mconcat to those sections
18:15:32 <scook0> and finally apply the resulting function to the remaining element
18:15:35 <vincenz> app f [] = undefined; app f (x:xs) = app' f x xs; app' f x [] = x; app' f x (y:ys) = app' f (x`f`y) ys
18:15:52 <byorgey> scook0: you have to be careful, of course, about which way you want to parenthesize
18:15:54 <Raguel> matrix decomposition mainly - but i was helping one person out who doesn't seem to hear me
18:15:58 <scook0> byorgey: true
18:15:59 <vincenz> scook0: like that?
18:16:13 <byorgey> do you want (1 + (2 - (3 * 4)))? or (((1 + 2) - 3) * 4)?
18:16:19 <scook0> and if you're slightly trickier with your application
18:16:25 <nornagon> the latter
18:16:26 <scook0> you can isolate the first number instead of the last one
18:16:27 <byorgey> Raguel: hm, odd
18:16:29 <nornagon> but it's not that important
18:16:32 <vincenz> nornagon: my code does the latter
18:16:34 <vincenz> ooh
18:16:35 <vincenz> another option
18:17:11 <vincenz> foldX (\(f,x) y -> x `f` y) YOURCONSTANT $ zip fs xs
18:17:22 <Raguel> byorgey: go onto #math and see if you can hear me
18:17:35 <vincenz> > foldl (\(f,x) y -> x `f` y) 0 $ zip [(+), (*)] [1,2]
18:17:36 <lambdabot>      Occurs check: cannot construct the infinite type:
18:17:36 <lambdabot>       t = t1 -> b -> (...
18:17:42 <vincenz> > foldl (\y (f,x) -> x `f` y) 0 $ zip [(+), (*)] [1,2]
18:17:43 <lambdabot>  2
18:17:50 <scook0> > (flip id) 1 $ (+2) >>> (-3) >>> (*4)
18:17:50 <lambdabot>   add an instance declaration for (Num (b -> c))
18:17:54 <byorgey> Raguel: I can hear you fine
18:17:57 <vincenz> > foldr (\(f,x) y -> x `f` y) 0 $ zip [(+), (*)] [1,2]
18:17:57 <lambdabot>  1
18:18:03 <vincenz> 1+2**0
18:18:04 <scook0> > ($ 1) $ (+2) >>> (-3) >>> (*4)
18:18:05 <vincenz> 1+2*0
18:18:05 <lambdabot>   add an instance declaration for (Num (b -> c))
18:18:10 <Nafai> No fun programming lately :(
18:18:12 <vincenz> nornagon: the foldr works if you have the last value
18:18:20 <vincenz> > foldr (\(f,x) y -> x `f` y) 0 $ zip [(+), (*),(-)] [1,2,3]
18:18:20 <lambdabot>  7
18:18:27 <vincenz> 1+2*(3-0)
18:18:40 <scook0> > ($ 1) $ (+2) >>> (subtract 3) >>> (*4)
18:18:40 <lambdabot>  0
18:18:42 <byorgey> Nafai: =(
18:18:43 <vincenz> @pl (\(f,x) y -> x `f` y)
18:18:43 <lambdabot> ap fst snd
18:18:52 <vincenz> > foldr (ap fst snd) 0 $ zip [(+), (*),(-)] [1,2,3]
18:18:52 <lambdabot>  7
18:19:31 <Nafai> byorgey: How about yourself?
18:19:42 <vincenz> nornagon: do you know that you'll have exactly one more number?
18:19:45 <vincenz> nornagon: if so then
18:19:57 <byorgey> Nafai: actually, today I've been having fun writing an extension module for xmonad
18:19:58 <nornagon> vincenz: yes
18:20:00 <vincenz> > let foo fs xs = foldr (ap fst snd) (last xs) $ fs xs in foo
18:20:03 <lambdabot>  Add a type signature
18:20:07 <vincenz> nornagon: use that :)
18:20:09 <Nafai> byorgey: Cool, what does it do?
18:20:16 <vincenz> > let foo fs xs = foldr (ap fst snd) (last xs) $ zip fs xs in foo
18:20:19 <lambdabot>  Add a type signature
18:20:24 <vincenz> that one I mean, you need the zip
18:20:44 <byorgey> Nafai: it allows you to specify layout configurations on a per-workspace basis, as opposed to specifying the same layout configuration for all workspaces (the default)
18:21:00 <vincenz> > let foo fs xs = foldr (ap fst snd) (last xs) $ zip fs xs in foo [(+), (+), (+)] [1,2,3,4]
18:21:01 <lambdabot>  10
18:21:06 <vincenz> > let foo fs xs = foldr (ap fst snd) (last xs) $ zip fs xs in foo [(+), (+), (-)] [1,2,3,4]
18:21:07 <lambdabot>  2
18:21:08 <Nafai> byorgey: Nice
18:22:07 <byorgey> Nafai: I've done lots of fiddling with xmonad, fixing/contributing documentation, etc., but this is my first shot at a real extension module, so it's been fun figuring it out =)
18:23:31 <kfish> w00t, proggit has all the goods on "category theoray"
18:23:34 <Nafai> Cool, I've been meaning to try to get xmonad working for me; xmonad + gnome + gnome panels seems like it could be a sweet spot for me
18:25:06 <Saizan_> btw how can you switch to a workspace names e.g. 1f?
18:25:23 <Saizan_> *named
18:26:33 <Raguel> omg reading why functional programming matters for the first time is a head trip :|
18:26:53 <dons> heh
18:26:55 <Raguel> its like - you can have an entire program represented by a single line
18:27:13 <newsham> or a single function
18:27:21 <Raguel> thats what i meant
18:27:29 <Raguel> and it calls a handful of functions
18:27:36 <Raguel> which call a handful of functions
18:27:51 <Raguel> and in the end you get an incredibly complex tree of functions
18:27:53 <newsham> I see... functions within functions...
18:28:04 <Raguel> and not only do you NEVER have to work out how the tree works
18:28:17 <Raguel> (ie you don't need to know how many things call the add function)
18:28:39 <newsham> now imagine that you have an equation for every imperative piece of your old imperative program.
18:28:42 <Raguel> just that if you work from the bottom up and define each function correctly then you can't go wrong
18:28:49 <newsham> and changing one line somewhere changes the meaning of the whole thing
18:28:54 <scook0> > let interop ops (n:ns) = ($ n) $ foldl1' (>>>) $  zipWith flip ops ns in interop [(+),(-),(*)] [1..4]
18:28:55 <lambdabot>  0
18:29:22 <Raguel> tempted to say thats why you do it right first time
18:29:37 <Raguel> but if you name a function correctly and have it do what its name is
18:29:42 <newsham> dont worry, there's still room for error :)
18:29:50 <newsham> > head []
18:29:50 <lambdabot>  Exception: Prelude.head: empty list
18:30:00 <xpika> @where dons
18:30:00 <lambdabot> http://www.cse.unsw.edu.au/~dons
18:30:03 <scook0> > take 1 []
18:30:04 <lambdabot>  []
18:30:05 <dons> ?seen dons
18:30:05 <lambdabot> You are in #haskell, #ghc and #xmonad. I last heard you speak just now.
18:30:28 <xpika> dons: hello, do you have any plans for hs-plugins?
18:30:39 <Raguel> just kinda :| cos instead of writing a huge program you just define a LOT of tools
18:30:44 <dons> well, not really. i'll eventually port it to ghc 6.8
18:30:49 <dons> unless someone else does it first
18:31:11 <Raguel> were's cse.unsw?
18:31:21 <Raguel> australia?
18:31:32 <newsham> south wales?
18:31:33 <Raguel> goldland?
18:31:37 <dons> it is, yes. though i don't live there any more.
18:31:49 <dons> http://unsw.edu.au
18:31:58 <lambdabot> Title: UNSW: The University of New South Wales - Sydney Australia - Home page
18:32:03 <newsham> another grad student out standing in his (galois) field
18:32:15 <Raguel> i think gold land fits better with edu.au
18:32:24 <dons> something like that, newsham :)
18:32:33 <dons> just doing my bit for the brain drain
18:32:40 <kfish> onya dons
18:32:46 <Raguel> whereas i appear to be learning haskell for fun :S
18:33:00 <dons> kfish: yeah, go team!
18:33:02 <Raguel> since technically i SHOULD be learning fortran right now
18:33:25 <newsham> one of the profs at my grad school had a comic clip on his door that showed a scarecrow, captioned "another grad student out standing in his field"
18:33:30 <newsham> wish I had a copy of that
18:33:33 <shapr> hah
18:33:36 <shapr> email him!
18:33:48 <Raguel> my professor reads this channel _
18:33:54 <shapr> I don't have a professor!
18:34:01 <shapr> My boss reads this channel though :-)
18:34:03 <byorgey> shapr: you should get one!
18:34:04 <Raguel> nothing like a healthy does of paranoi at 2:30 am
18:34:04 * shapr waves at alexj
18:34:09 <newsham> I dont remmeber which prof it was, it wasnt one of mine.
18:34:43 <newsham> sapr: how're things at happs?
18:35:52 <shapr> Moving along steadily
18:35:57 <sfultong> now that I've tried RoR, I wanna try happs
18:36:05 <shapr> We've switched to 6.8.1, yay!
18:36:15 <shapr> The repos are currently broken though.
18:38:08 <sfultong> my ScrolledWindow in gtk2hs isn't showing up... anyone know why?
18:38:24 <sfultong> I was hoping that scrolledwindow would be a drop-in replacement for Window, but apparently not...
18:41:47 <Raguel> ok if i have a function: blah a x (b z) = stuf
18:41:52 <Raguel> whats the b z bit?
18:41:56 <Raguel> where does it come from
18:41:58 <Raguel> where does it go
18:42:08 <Raguel> and when the function is passed 2 arguments what happens?
18:43:02 <byorgey> Raguel: as you've written it, that's not valid Haskell.
18:43:13 <byorgey> Raguel: however, the (b z) part could be a pattern match?
18:43:15 <Raguel> redtree f g a (node label subtrees) =
18:43:15 <Raguel> f label (redtree' f g a subtrees)
18:43:21 <Raguel> is what i'm looking at
18:43:53 <byorgey> that's... hmm.
18:44:09 <byorgey> Raguel: this is the definition of the redtree function?
18:44:17 <Raguel> part of it
18:44:25 <Raguel> its to reduce a tree...
18:44:36 <Raguel> or create a red coloured tree..
18:44:39 <sfultong> Raguel: it's Node, not node ;-)
18:44:51 <byorgey> ok, that makes more sense =)
18:44:55 <Raguel> copy&paste
18:45:00 <Raguel> soe node
18:45:11 <sfultong> really? well, I'd assume it to be Node...
18:45:25 <byorgey> if it's Node, then it would be a pattern match on the Node constructor.
18:45:30 <Raguel> redtree f g a (node label subtrees) =
18:45:30 <Raguel> f label (redtree' f g a subtrees)
18:45:30 <Raguel> redtree' f g a (cons subtree rest) =
18:45:30 <Raguel> g (redtree f g a subtree) (redtree' f g a rest)
18:45:30 <Raguel> redtree' f g a nil = a
18:45:39 <Raguel> thats the full definition
18:45:45 <byorgey> if it's lowercase... I'm not sure what it is.
18:45:50 <mauke> source?
18:46:18 <Raguel> why functional programming by john hughes
18:46:42 <Raguel> which is sort of "start here to learn about haskell" paper
18:47:25 <mauke> that's not haskell
18:47:29 <Raguel> no
18:47:33 <Raguel> it functional programming...
18:47:43 <Raguel> sorry - slipped my mind to mention it :(
18:47:55 <Raguel> *thwap*
18:48:16 <byorgey> ohhh. heh. =)
18:48:23 <mauke> and yeah, it's a pattern match
18:49:04 * sfultong wishes people never thought up pseudo-code
18:50:04 <Raguel> hmmm now i need to decide: its 3 am, do i take caffine to keep my brain alive enough to read more of this bearing in mind i've been on the go since 10am with only 2hours off total, do i fall asleep or do i run on low brain power and watch anime till 5am
18:51:40 <Korollary> sleep
18:51:42 <jeffz> Raguel: mind your health.
18:52:21 <Raguel> my health is suprisingly good actually :)
18:53:07 <TomMD> > "Stay online you POS connection."
18:53:08 <lambdabot>  "Stay online you POS connection."
18:53:11 <TomMD> Good
18:53:25 <Raguel> ?
18:53:31 <Korollary> echo test
18:53:40 <Raguel> hrm
18:53:59 <Raguel> so when its pattern matching it'll only accept arguments of those 3 types?
18:54:07 <Raguel> (in the pseudocode)
18:54:53 <mauke> three types?
18:55:32 <Raguel> node label and subtrees in the first one
18:56:43 <Raguel> ok this is getting nowhere - i feel like i should just start reading this paper from the top (not a silly idea) and do it later... like tomorrow
18:56:59 <Raguel> and since i've got to be up and in computer labs for 9am... i'm probably gonna read a book
18:57:02 <Raguel> night all
18:57:58 <mauke> redtree :: (X -> Y -> Z) -> (Z -> Y -> Y) -> Y -> treeof X
18:58:01 <mauke> or something like that
18:58:20 <mauke> the node label and subtrees are two values, not three types
18:58:43 <mauke> er, redtree :: (X -> Y -> Z) -> (Z -> Y -> Y) -> Y -> treeof X -> Z
19:03:24 <vininim> >integrate((x**2)*(exp(-4e40*(x**2))),x,0,1)
19:04:15 <shachaf> vininim: Which channel was that meant for?
19:05:18 <vininim> well maybe lambdabot had an numericla integrator, you never know ;)
19:05:46 <shachaf> vininim: That's not Haskell syntax anyway, that's why I was wondering.
19:05:52 <faxathisia> it's not haskell?
19:05:52 <shachaf> vininim: Try mbot with Mathematica syntax.
19:05:56 <faxathisia> > -4e40
19:05:58 <lambdabot>  -4.0e40
19:06:02 <faxathisia> looks like haskell :/
19:06:12 <dfranke> faxathisia: the x isn't haskell.
19:06:13 <shachaf> Well, it's valid Haskell, I guess.
19:06:18 <mauke> > integrate((x**2)*(exp(-4e40*(x**2))),x,0,1)
19:06:19 <lambdabot>   Not in scope: `x'
19:06:19 <shachaf> Except for the x, yes.
19:06:21 <faxathisia> You just have to make some kind of variable type which makes an AST when you apply operators to it
19:06:32 <faxathisia> like x + y = Add x y
19:06:37 <dfranke> you need TH for that.
19:06:40 <mauke> custom Num instance
19:06:44 <faxathisia> mauke: Exactly
19:06:47 <faxathisia> no need for TH?
19:07:03 <dfranke> how does it know to take the x as a symbol rather than evaluating it?
19:07:04 <mauke> the problem is that x is not in scope here
19:07:07 <shachaf> faxathisia: Sure, but x is still not bound.
19:07:21 <faxathisia> @let x = variable
19:07:22 <lambdabot> <local>:10:4: Not in scope: `variable'
19:07:24 <sjanssen> let x = Var "x"
19:07:35 <faxathisia> er.. sjanssen that's a better idea than mine :)
19:23:41 <dufflebunk> I get the feeling I'm doing something wrong if I write a liftM14 function so I can use Data.Binary and read in a structure with 14 parts.
19:24:45 <chessguy> IIRC, liftn can be simulated with ap
19:24:56 <sjanssen> dufflebunk: yes, you are doing something wrong :)
19:24:57 <chessguy> @type ap
19:24:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:25:21 <sjanssen> chessguy is spot on, liftM3 f x y z = return f `ap` x `ap` y `ap` z
19:27:48 <dufflebunk> Ok, thanks.
19:27:48 <shachaf> Or: f <$> x <*> y <*> z
19:28:11 <shachaf> (Or idiom brackets, if GHC had them.)
19:29:19 <dons> dufflebunk: hmm that sounds like your type is too big :)
19:30:31 <newsham> 14-part counterpoint sounds hard
19:30:56 <dufflebunk> dons: Possibly, but if I break it up I have you write multiple Binary instances isntead of just one
19:31:06 <dufflebunk> to, not you
19:31:20 <noecksit> hello, i am very new to haskell
19:31:26 <dufflebunk> Hello noecksit
19:31:34 <dons> dufflebunk: yep, that's true
19:31:36 <noecksit> for my first program, i would like to make a merge function
19:31:40 <dons> hi noecksit . welcome
19:32:03 <dons> well, its more traditional to write the fibonacci sequence for a first program, but oh well :)
19:32:03 <noecksit> which merges two files based on their difference
19:32:21 <dons> ok, sure. so what algorithm do you want to use?
19:32:25 <mauke> whoa. files?
19:32:48 <dons> how about you write 'cat' first, then cat on 2 files, then cat with merged output?
19:32:51 <dons> that would be a good progression
19:32:51 <ddarius> I think my first actual Haskell program was a converter from a simple Haskelly language to C++ templates.
19:32:59 <dons> ddarius: you're a bad person
19:33:00 <noecksit> dons: i played around with some introductory programs, i mean this is the first program that i would have use for
19:33:07 <mauke> my first haskell program was hello world
19:33:17 <ddarius> (The first program -that- program tested, though, was factorial.)
19:33:19 <dons> ah ok. sweet. how's it going, noecksit ? are you stuck somewhere, or proceeding along ok?
19:33:27 <dfranke> mine was towers of hanoi.  That's the first program I write in every new language I learn.
19:33:45 <newsham> dfranke: got a CPP implementation?
19:33:54 <monochrom> My first Haskell program was whatever the Gentle Introduction made me write.
19:34:06 <noecksit> dons: no, im just not sure how to start, writing a cat program sounds like a goal
19:34:15 <dfranke> newsham: heh, I could give it a shot :-).  I hear that CPP is indeed Turing-complete.
19:34:16 <dons> ok. so have a look at System.IO
19:34:18 <dons> ?docs System.IO
19:34:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
19:34:24 <newsham> http://www.ioccc.org/1995/vanschnitz.c
19:34:25 <dons> and familiarise yourself with the io functions
19:34:37 <dons> a very cute cat program is:   main = interact id
19:34:42 <dons> ?src interact
19:34:42 <lambdabot> interact f = do s <- getContents; putStr (f s)
19:34:50 <dons> so you'll likely want to use getContents and putStr
19:34:55 <noecksit> ok thanx
19:35:19 <dons> let us know if you get stuck
19:35:21 <jeffz> 404 on that System.IO url
19:35:27 <dons> oh.
19:35:33 <dons> oh, package numbers
19:35:41 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/System-IO.html
19:35:42 <lambdabot> http://tinyurl.com/2uqgyq
19:35:45 * jeffz noticed earlier today when looking at google search result that 404'd nearby.
19:35:50 <sfultong> latest isn't linked up?
19:35:54 <newsham> putStr (diff' (readFile f1) (readFile f2)) where diff' = liftM2 diff
19:35:54 <dons> someone want to patch the @docs command please?
19:35:58 <dons> ?version
19:35:59 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
19:35:59 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:36:04 <newsham> err..  >>= putStr
19:36:12 <dons> ^^ darcs get, edit Plugin/Dummy.hs
19:38:07 <dibblego> ?type isPrefixOf
19:38:08 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
19:38:14 * SamB wishes xpdf would print alpha-blended images correctly...
19:38:43 <dibblego> ?hoogle (a -> Bool) -> a -> [a] -> Bool
19:38:43 <lambdabot> No matches, try a more general search
19:42:27 <byorgey> dons: I'll do it tomorrow if no one else gets around to it.
19:46:39 <kscaldef_> it would be really nice if someone put in some redirects from the old docs URLs to the new ones
19:47:17 <kscaldef_> it's very frustrating to have all your bookmarks break all the sudden
19:49:30 <dibblego> ?hoogle Int -> [a] -> [[a]]
19:49:30 <lambdabot> No matches, try a more general search
19:49:36 <dons> we should try to get a haskell program to win an open source award
19:49:42 <dons> how about nominating ghc? :)
19:49:54 <dons> most innovating dev tool
19:50:06 <jeffz> dons, who gives these awards?
19:50:07 <dibblego> is there a function f such that f 3 "abcdefg" -> ["abc", "def", "g"] ?
19:50:08 <lament> most innovative Haskell compiler
19:50:23 <shachaf> Most practical haskell compiler.
19:50:24 <dons> jeffz: oh, there's all sorts. o'reilly/google does one, sourceforge another
19:50:31 <shachaf> (Do they accept oxymorons? :-) )
19:50:31 <Cale> dibblego: There is, but you have to write it ;)
19:50:39 <dibblego> Cale, ok :)
19:50:46 <dons> there's the australian open source awards
19:50:50 <Cale> I recommend using iterate
19:50:52 <lament> let f _ _ = ["abc", "def", "g"] in f 3 "abcedfg"
19:51:01 <dons> matt chapman won that for rdesktop a while a go, and tridge for samba, iirc
19:51:04 <saturday> how do I convert a Int to a double/float?
19:51:11 <dibblego> lament, ah thanks, you're a great help
19:51:30 <Cale> > let f n = map (take n) . takeWhile (not . null) . iterate (drop n) in f 3 "abcdefg"
19:51:30 <jeffz> dons, ah ok,  when can we preorder real world haskell?
19:51:31 <lambdabot>  ["abc","def","g"]
19:51:38 <dons> oh, our very own kfish got nominated for something in '04
19:51:43 <shachaf> lament: Not good -- your uses "abcedfg".
19:51:54 * ddarius uses Google to organize his "bookmarks"
19:51:55 <mauke> saturday: fromIntegral
19:51:57 <dons> jeffz: not yet, afaik. getting there though
19:52:05 <kscaldef_> shachaf: I assume that was a joke
19:52:06 <saturday> mauke: aah
19:52:10 <kfish> eh?
19:52:11 <kfish> oh
19:52:13 <kfish> :-)
19:52:23 <saturday> been trying fromInt
19:52:28 <shachaf> kscaldef_: Yes. :-)
19:52:39 <dons> gee, the AUUG awards are really dominated by unsw hackers
19:52:39 <shachaf> kscaldef_: (Not the "your" part -- that was a mistake.)
19:52:54 <brian`> is Data.FiniteMap not part of standard libary??
19:53:04 <shachaf> brian`: It's just Data.Map now.
19:53:13 <ddarius> Data.FiniteMap has been obsolete for a long time now
19:53:16 <dons> faster, cleaner, more friendly
19:53:27 <brian`> ok :)
19:53:43 * ddarius sees a little yellow FiniteMap sitting in a grayscale palm.
19:54:47 <brian`> :t trim
19:54:50 <lambdabot> Not in scope: `trim'
19:55:10 * kfish nominates GHC for "most likely to produce working code"
19:56:03 <dons> yeah, ghc should really get an open source award. its been open for the last 18 years, and still going strong
19:56:40 <brian`> what's AUUG award?
19:56:43 <dons> nuturing many an ioccc winner and bzip2 author
19:56:58 <shachaf> ghc++ -- mini-award. :-)
19:57:12 <lament> not _very_ many, i would imagine :)
19:57:42 <dons> well, 1 of each :)
19:59:31 <sorear> don't forget valgrind
20:01:28 <dons> well, 1 valgrind / bzip author
20:14:51 <xpika> what keystroke takes you to the corresponding ) in Vim
20:14:52 <xpika> ?
20:14:57 <jcreigh> %
20:15:15 <xpika> jcreigh: yep
20:15:41 <jcreigh> "yep"? What, was that just a pop quiz to see if we were paying attention? :)
20:15:53 <ddarius> Congratulations, you passed.
20:16:06 <jcreigh> cool. so I'm not a replicant?
20:16:10 <xpika> jcreigh: sorry, I couldn't remember it.
20:16:15 <noecksit> hello, would you concatenate a string with another one using ++, as in the case of 'putStr "Word " ++ s'
20:16:23 <jcreigh> xpika: heh, no worries, I was just joking.
20:16:30 <xpika> yep
20:16:44 <jcreigh> noecksit: yeah, ++ appends lists and strings are lists of characters.
20:16:46 <dons> putStr ("Word " ++ s)
20:17:03 <dons> ?let s = "cool"
20:17:07 <lambdabot> Defined.
20:17:10 <dons> > "stuff is " ++ s
20:17:11 <lambdabot>  "stuff is cool"
20:17:52 <noecksit> thats what i had wrong, i didnt have parenthesis around
20:18:19 <ddarius> Unsurprisingly, function application binds tighter than anything.
20:18:21 <jcreigh> noecksit: yeah, remember that function application binds tighter than anything else.
20:18:41 <noecksit> dons: what does parenthesis do, does that specify order of evaluation?
20:18:52 <brian`> :t return
20:18:53 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:18:59 <mauke> no, only associativity
20:19:08 <brian`> how does it know 'return' know which monad container to use?
20:19:14 <kscaldef_> magic
20:19:19 <brian`> how does 'return' know*
20:19:19 <ddarius> noecksit: It does the same thing it does in arithmetic or most other languages, it just specifies how to parse the expression
20:19:24 <dons> brian`: usually it is specified by the surounding context
20:19:25 <ddarius> bran_: type inference
20:19:26 <chessguy> @quote magic
20:19:26 <jcreigh> brian`: type inference
20:19:26 <lambdabot> dons says: yes, i have magic powers.
20:19:29 <dons> ( 1 + 2) * 3
20:19:40 <dons> reverse ("foo" ++ "bar")
20:19:41 <brian`> wow ; so it figures out itself huh? that's crazy
20:19:47 <dons> type inference :)
20:20:04 <brian`> man, haskell's so lovely lol
20:20:09 <mauke> brian`: think of it as a virtual function
20:20:09 * ddarius liked it better when he didn't use tab-completion.
20:20:12 <kscaldef_> type inference is pretty much magic in the Arthur C. Clarke sense
20:20:17 <chessguy> brian`, not so crazy, when you think about it. usually there's some surrounding context that gives it away
20:20:22 <dons> ddarius: heh, i keep getting caught out too
20:20:29 <dons> esp. now there's so many non-unique prefixes
20:20:45 <brian`> chessguy, gotcha :)
20:21:00 <chessguy> it is pretty cool though :)
20:21:16 <brian`> yeah it is
20:21:26 <brian`> hey btw how did ddarius do "* ddarius liked it better when he didn't use tab-completion."?
20:21:32 <ddarius>  /me
20:21:33 <brian`> how do I set it? i'm new to IRC ..
20:22:15 <chessguy> he just typed '\me liked it better...'
20:22:18 <monochrom> /me loves haskell
20:22:23 <monochrom> Not \me
20:22:26 * mauke types "/me types "/me types "/me types "/me types "/me types CORE DUMPED
20:22:33 <chessguy> err, yeah
20:22:57 <ddarius> Robots are going to make the most horrid puns.
20:23:06 <jcreigh> mauke: IRC doesn't have good support for quining
20:23:24 <lambdabot> So I told him: "You are such an EBCDIC!"
20:23:30 <monochrom> > fix (\s ->"/me types " ++ show s)
20:23:33 <lambdabot>  "/me types \"/me types \\\"/me types \\\\\\\"/me types \\\\\\\\\\\\\\\"/me t...
20:24:00 * brian` waiting for the day where Haskell becomes faster than C
20:24:01 <ddarius> > fix $ ("/me types "++) . show
20:24:01 <lambdabot>  "/me types \"/me types \\\"/me types \\\\\\\"/me types \\\\\\\\\\\\\\\"/me t...
20:24:17 <mauke> brian`: that was several months ago
20:24:31 <brian`> lol
20:24:38 <kscaldef_> although, wasn't it still slower than C++ on that benchmark?
20:24:57 <brian`> what ;? faster than c but slower than c++??
20:25:05 * kscaldef_ shrugs
20:25:15 <chessguy> there will always be _some_ benchmark in which you can prove that any programming language is faster than any other
20:25:18 <jcreigh> there are lies, damned lies, benchmarks, statistics and delivery dates.
20:25:26 <kscaldef_> c++ can do calculations at compile time that C can't
20:25:41 <mauke> just use boost.preprocessor
20:25:44 <monochrom> @remember jcreigh there are lies, damned lies, benchmarks, statistics and delivery dates.
20:25:44 <lambdabot> I will never forget.
20:25:54 <lekro> is it reasonable to believe that Haskell could profit more from parallel architectures than C or C++?
20:26:02 <jcreigh> that's not actually original with me. :)
20:26:11 <ddarius> lekro: It would be unreasonable not to believe that.
20:26:38 <ddarius> The Haskell community looks to the coming multicore future with anticipation.
20:26:52 <monochrom> who originated it?
20:26:55 <jcreigh> I for one welcome our multicore overlords.
20:27:03 <lekro> ddarius: well, C and C++ is not too bad, either. But I believe Haskell has potential to win against C or C++ in this direction
20:27:23 <brian`> what about erlang?
20:27:34 <brian`> for concurrency, isn't erlang better than haskell?
20:27:42 <ddarius> lekro: I don't know what this "potential" thing you're talking about is.  Haskell does win againts C/C++ in that area.
20:28:01 <lekro> brian`: look like it for me
20:28:32 <ddarius> Haskell supports more forms of concurrency than Erlang and has a better compiler.
20:29:03 <brian`> that's cool
20:29:15 <ddarius> That said, Erlang's support for message-passing concurrency makes it very convenient and, much more importantly, it has the libraries and community to really turn that into something powerful.
20:29:24 <kscaldef_> brian`: both erlang and haskell are pure functional languages, which is a big win for concurrency.  Erlang has better support for concurrency built in
20:29:41 <dons> chessguy: i'm pretty sure there's no benchmark which shows ruby as faster
20:30:19 <chessguy> dons, ...than BF?
20:30:21 <chessguy> :)
20:30:29 <chessguy> obviously i was exaggerating to make a point
20:30:50 <lekro> ddarius: it already wins against C/C++ in that area? then I definitely missed a lot of news :/
20:31:24 <dons> erlang supports distribution and failure better, haskell is faster
20:31:47 <chessguy> lekro, there are benchmarks in which haskell performs much better than C{,++}. there are also benchmarks which show just the opposit
20:31:48 <chessguy> e
20:31:54 <lekro> ddarius: I know that Haskell has more modern notions like STM, but I wasn't aware that it already payed off so much to win against languages that are a lot closer to the hardware
20:31:55 <ddarius> Haskell pretty much doesn't support distribution at all.  What support was researched has drifted into the shadows.
20:31:58 <jcreigh> of course, in discussions of the speed of Haskell, we almost always mean s/Haskell/GHC/
20:32:14 <dons> why haskell rocks, why erlang is slow: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=hipe
20:32:20 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/28d6h2
20:32:25 <dons> on no benchmark is erlang faster
20:32:26 <ddarius> lekro: Haskell's threads are far, far lighter than most of the threads you'd use in C/C++.
20:32:30 <dons> including all the concurrency benchmarks
20:32:53 <kscaldef_> how does LOC / speed of development compare, though?
20:33:16 * ddarius imagines Haskell is shorter than Erlang, if nothing else because the syntax is more compact.
20:33:22 <dons> erlang v haskell? bout the same. erlang's a bit more old fashioned, less abstractions
20:33:33 <dons> yeah. erlang's a bit 1980s-ish
20:33:43 <dons> you can see loc in that benchmark
20:33:45 <ddarius> They should have never used that Prologish syntax.
20:34:04 <dons> half the time erlang is shorter, half the time haskell is.
20:34:11 <dons> but never is erlang faster
20:34:18 <jcreigh> I just had this crazy vision of the future 20 years from now where people are saying "Well, we'd like to use language X, but we're going to use Haskell for speed..."
20:34:25 <dons> erlang has better marketing
20:34:26 <chessguy> lol
20:34:58 <kscaldef_> yeah, although with this Wide Finder business, it seems like Erlang is going to have to make some improvements fast or have their marketing backfire
20:34:59 <ddarius> Haskell doesn't seem to be doing too bad itself in that regard either.
20:35:02 * ddarius eyes dons.
20:35:04 <dons> "patch applied (ghc): New vectorisation built-ins"
20:35:31 <dons> kscaldef_: oh, erlang losing out to the typed fp languages, last i saw?
20:35:38 <dons> or it was having issues with strings?
20:35:48 <kscaldef_> strings / file IO
20:35:54 * dons watches yet another parallelism construct land in ghc's src tree
20:36:03 <dons> yeah, someone should port bytestring over ;)
20:36:04 <kscaldef_> although, currently JoCaml is kicking everyone else's ass
20:36:16 <dons> yeah, pity they won't compile ghc for that.
20:36:23 <dons> brian wrote a great parallel haskell one, for smp
20:36:43 <dons> bytestrings + smp == lots of fun
20:36:54 <jeffz> is it forseeable for a haskell runtime to do hot code swapping like erlang can?
20:36:59 <brian`> do you think F# will kick fp in the future?
20:36:59 <dons> the kind of problem you just beg to throw haskell at
20:37:03 <dons> jeffz: i don't think so.
20:37:09 <brian`> i mean kick other fp's ass *
20:37:10 <dons> brian`: its just another ocaml
20:37:10 <kscaldef_> the intriguing thing at the moment is that the JoCaml solution seems to be faster than disk I/O
20:37:17 <dons> and its tied to windows
20:37:21 <brian`> yeah
20:37:28 <dons> so no more than C#
20:37:36 <dons> windows people will love it, no one else will be able to use it
20:37:41 * ddarius is liking C#
20:37:46 <dons> the ocaml guys will cry a little bit
20:38:01 <ddarius> C# is not pissing me off (in the directions it goes) like Java did.
20:39:07 <monochrom> I think F# will promote FP. Then all the other FPL communities benefit from it.
20:39:15 <dons> yes
20:39:16 <dons> i agree.
20:39:24 <dons> it will be a shorter barrier to entry into haskell, for one
20:39:28 <dons> and there'll be more jobs
20:39:46 <monochrom> For example it is very hard to get a C++ lover interested in Haskell. He keeps asking "what about performance?"
20:39:50 <dons> it'll be easier to see haskell, i suspect
20:39:59 <dons> s/sell/
20:40:08 <dons> monochrom: yeah, you have to go on the safety aspect?
20:40:18 <monochrom> But it's much easier to get an F# lover interested in Haskell. He only asks "what about eagerness?" :)
20:40:20 <dons> or concurrency
20:40:29 <ddarius> Indeed.  F# just brings people over without actually stepping on Haskell's userbase.
20:40:44 <dons> well, on the .NET bytecode, it probably won't be blindingly fast either
20:40:48 <hpaste>  dibblego pasted "lambdabot @docs patch" at http://hpaste.org/3986
20:40:54 <dons> ddarius: right.
20:40:56 <ddarius> As you said earlier, the picture isn't as rosy for the O'Caml people, but probably still a net win.
20:41:06 <newsham> i imagine by the time f# becomes "popular", c# programmers will be asking themselves "what about performance?"
20:41:09 <dons> right, it kills ocaml on windows
20:41:12 <Pseudonym> monochrom: I think that true C++ devotees are easier to win over than you think.
20:41:25 <Pseudonym> As opposed to know-nothing C++ fanboys.
20:41:31 <dons> the ones that know the failures
20:41:32 <ddarius> Both Pseudonym and I are fans of C++ and we're here.
20:41:33 <dfranke> I can't imagine how anyone could be a C++ devotee.
20:41:34 <Pseudonym> True C++ devotees care about abstraction.
20:41:41 <Pseudonym> Exactly.
20:41:54 <ddarius> True C++ devotees hate C with a passion.
20:41:58 * Pseudonym nods
20:42:06 <Stinger_> true c++ devotees are doing stupid lambda tricks with templates :)
20:42:09 <dibblego> True Scotsman... :)
20:42:12 <Philippa_> dfranke: needing - or having felt a need - to work at the kind of level that C offers while wanting abstraction and not having had the time to explore alternatives
20:42:28 <Pseudonym> Stinger_: As opposed to stupid type-level tricks with typeclasses.
20:42:41 <dfranke> Philippa_: I don't find C++'s abstractions clean enough to be useful.  I'd rather just use C.
20:42:49 <Stinger_> I'm not that advanced yet so I'm still good :)
20:42:54 <brian`> I looked at the functional programming package in Boost and it looked ugly as hell -_-;
20:42:56 <Pseudonym> :-)
20:43:09 <Philippa_> dfranke: sure. But you can see that not everyone would find that to be the case?
20:43:11 * ddarius writes a C++ compiler in C++'s type system.  It'll be a meta-circular compiler!
20:43:21 <Pseudonym> brian: I know, but then, I've also seen the Haskell code submitted to the shootout.
20:43:25 <Philippa_> ddarius: you'll have trouble, you can't represent strings
20:43:26 <monochrom> You meta-bootstrap!
20:43:28 <Pseudonym> "Ugly as hell" springs to mind there, too.
20:43:33 <ddarius> Philippa_: Says you.
20:43:50 <brian`> Pseudonym, yeah probably..
20:43:51 <mauke> Philippa_: lists of ints
20:43:55 <Pseudonym> struct Nil {};
20:44:06 <Pseudonym> template <typename X, typename Xs> Cons { ... };
20:44:06 <Philippa_> sorry, yeah, over-strong statement. You can't do it without a stupidly heavyweight encoding
20:44:08 <dfranke> Philippa_: but it's just so damned ugly.  I can understand people saying "it's the best tool I know for the job", but I just can't understand *liking* it.
20:44:12 <ozone> mauke: then you get unicode support for free!
20:44:24 <Pseudonym> Philippa: Like, oh, STRINGS AS LISTS OF CHARS?
20:44:27 <ddarius> Philippa_: You mean like [Char]...
20:44:36 * Pseudonym high-fives ddarius
20:44:50 * dons kicks Pseudonym. the shootout code is beautiful now :)
20:45:00 <dons> really, there's some nice code appearing
20:45:05 <dons> thanks to new libs and 6.x
20:45:10 <ozone> dons: btw, i didn't ask conrad to forward that unicode email to you :}
20:45:10 * Pseudonym takes a look
20:45:19 <Philippa_> now write out a bunch of encoded template-level strings by hand :-)
20:45:21 <dons> to wit, http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=ghc&id=2
20:45:23 <lambdabot> Title: thread-ring (new) Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nb ..., http://tinyurl.com/34vjft
20:45:23 <ddarius> Indeed.  We just keep making "low-level" code non-performant and everything gets better.
20:45:23 <ozone> dons: (but if you do ever feel like hacking on proper unicode support for haskell, gee, that'd be rather nice...)
20:45:40 <dons> ozone: we're going to need it soon or later on the project i'm working on
20:45:43 <ozone> Philippa_: it's not that hard with some macros :}
20:45:51 <ozone> dons: woo!
20:45:51 <dons> so we've some unicode strings stuff, but bytestrings will be needed eventually
20:45:55 <Philippa_> ozone: even with them it's going to be more painful than in Haskell
20:46:01 <dons> so we actually were talking about this cocoa api today
20:46:03 <dons> we'll see how it goes
20:46:13 <ddarius> Philippa_: I can have my cake and eat it too
20:46:16 <ozone> dons: uhh, cocoa api?
20:46:19 <newsham> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=4 beautiful?
20:46:20 <lambdabot> Title: mandelbrot Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Co ..., http://tinyurl.com/3aqtzf
20:46:26 <dons> ozone: sorry, obj C unicode.
20:46:30 <newsham> thats like 3x longer than what I'd write in C.
20:46:32 <Philippa_> ddarius: I don't want to know what you do with your cake!
20:46:39 <dons> newsham: mandelbort, and other double math is still not nice
20:46:57 <dons> i didn't claim all fast haskell programs are beautiful haskell programs
20:46:59 <dons> some are.
20:47:01 <newsham> C also doesnt have complex math
20:47:02 <dons> more than there used to be
20:47:03 <ozone> dons: well, in my copious spare time i'd love to write a CFString bridge for Haskell (which is the exactly same data structure as cocoa's NSString)
20:47:08 <ddarius> newsham: It does now.
20:47:13 <Pseudonym> http://shootout.alioth.debian.org/gp4/benchmark.php?test=fannkuch&lang=ghc&id=2 <- Pretty code, eh?
20:47:14 <newsham> [18:43] * dons kicks Pseudonym. the shootout code is beautiful now :)
20:47:14 <ozone> dons: i'll need it for HOC at some point anyway
20:47:14 <lambdabot> Title: fannkuch Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2oqzla
20:47:19 <newsham> I thought you just did :)
20:47:22 <dons> the new sum-file is ok, and fast, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
20:47:23 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/ys3ony
20:47:24 <Philippa_> dfranke: yeah, it's ugly - unfortunately an awful lot of it just about makes sense in an "I only really knew C-like languages before" kind of way, so some people follow a similar evolution in their understanding and like it that way
20:47:51 <dons> so, the ugly programs are slowly disappearing, being replaced by libraries and better compiler optimisations
20:47:55 <sclv> that mandelbrot code doesn't look that bad except for the strictness bangs everywhere
20:48:00 <dons> things like bits not being inlined
20:48:16 <dons> mandelbort's hard. you have to compete against the best C or C++ can do
20:48:23 <dons> which means trying to produce identical code from the ghc backend
20:48:29 <dons> so its a careful massaging
20:48:41 <dons> there's only a few instructions you need to get wrong to blow it
20:48:50 <Pseudonym> I understand this shootout thing, however.
20:49:02 <Pseudonym> In one sense, it's a stacked deck.
20:49:05 <noecksit> how can i compare whether two elements of a list are the same, or two strings?
20:49:07 <dons> oh, fannkuch needs a rewrite too though
20:49:14 <dons> i've been too scared to go back to it
20:49:16 <Pseudonym> Fact is, C can't even begin to compete with Haskell for equivalent programs.
20:49:17 <noecksit> would it be "equal? s1 s2"
20:49:27 <dfranke> noecksit: s1 == s2
20:49:31 <Pseudonym> And by "equivalent", I mean "does the same thing".
20:49:35 <ddarius> noecksit: This isn't Scheme.
20:49:36 <newsham> I always wondered why people wrote completely unrealistic programs for benchmark suites and then optimized for them.
20:49:40 <Pseudonym> Equally robust, for example.
20:49:41 <dons> fannkuch is the epitome of the ugly haskell brute force solution
20:49:44 <newsham> instead of writing normal code and optimizing for that
20:50:13 <dons> there's a number of shootout programs that need to be revisited
20:50:20 <ddarius> newsham: You write a several 100 KLOC codebase just to see if it's faster or not.
20:50:22 <dons> meteor-contest is begging for a good rewrite
20:50:29 <noecksit> so that wouldn't just compare whether the strings point to the same variable, as in Java?
20:50:33 <dons> fannkuch probably could be done differently now
20:50:38 <ozone> newsham: i got into a rather heated debate with the Great Language Shootout guy after i claimed that his benchmarks were too easily misinterpretable to be useful
20:50:42 <ddarius> noecksit: No.  It's structural equality.
20:50:42 <dmwit> noecksit: no
20:50:51 <dfranke> I often suspect that Haskell's performance in the shootout is generaly better than it should be, just because Haskell has smarter hackers writing the submissions.
20:51:05 <ddarius> noecksit: There is no pointer/reference equality in Haskell.  There are no pointers/references (well, there are, but...)
20:51:10 <sclv> haha on the file test, clean and java are wiping the floor with C. how is that possible?
20:51:24 <Pseudonym> C's I/O library is woeful.
20:51:25 <dons> until we beat Clean everyday, I don't think we're performing properly
20:51:36 <Pseudonym> I don't know if that's the reason, I just wanted to mention it.
20:51:38 <ddarius> dons: Mostly agreed.
20:51:59 <Pseudonym> dons: Yeah, I agree with you there.
20:52:11 <ddarius> Hopefully, the improvements to GHC's backend will bring in another breath of fresh air.
20:52:12 <Pseudonym> Clean has one minor advantage.
20:52:19 <Pseudonym> And that's compile-time GC/structure reuse.
20:52:21 <dons> yeah, its all in backend optimisations now
20:52:21 <sfultong> will 6.8 do noticeably better in the shootout?
20:52:35 <ddarius> I think that is the biggest thing that makes people say O'Caml/Clean is faster.
20:52:37 <dons> sfultong: yes, my initial benchmarks show 20-30% across 2/3 of shootout programs
20:52:48 <sfultong> wow, that's very impressive
20:53:17 <dons> well, everything else has been optimised out of the programs. so small changes to the runtime have big effects at this point
20:53:23 <dons> probably more so than typical programs
20:53:48 <dons> its not new optimisations though, its the pointer tagging
20:53:49 <ddarius> 6.8.1 has made some impressive gains across the range of codebases.
20:53:56 <dons> since the code was already hand crafted to get the right core
20:54:10 <dfranke> hah, nice results on thread-ring
20:54:30 <dfranke> not really fair until somebody writes an Erlang submission though.
20:54:47 <dons> e.g. binary-trees, already rather good,
20:54:49 <dons> 6.6: 4.263
20:54:53 <dons> 6.8:
20:54:55 <dons> 3.178
20:54:59 <newsham> ozone: yah but thats pretty true of all benchmarks.
20:55:11 <Philippa_> yeah, though 6.8.1 accidentally turns off some optimisations too
20:55:11 <dons> so 25% right there, meaning hmm, 1st place on that benchmark?
20:55:22 <newsham> i just dont like it (but I understand it will happen) when people write a bunch of non-idiomatic code taylored just for the benchmark.
20:55:39 <ddarius> dfranke: Erlang isn't going to come close to GHC there.
20:55:41 <sfultong> it'd be fun to write a haskell compiler to unlambda, and then write a really good unlambda compiler to C :-P
20:55:42 <dons> yep, looks like we'll take #1 for binary-trees, http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
20:55:43 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
20:55:47 <newsham> it reduces the usefulness of the benchmark to people like me who want to look at the impls and figure out what languages we like and why
20:55:49 <Philippa_> newsham: the real question is what the idioms for speed become
20:56:11 <dmwit> newsham: It's OK, because the other languages are doing the same thing.
20:56:15 <Philippa_> in that regard I think it's been really useful for us, because it's made us think enough about what they should be and how to make it happen automatically
20:56:18 <dons> newsham: its good for knowing the maximum level of tweaking possible
20:56:24 <dons> given arbitrary skill levels
20:56:29 <Philippa_> dmwit: it's not, because that's not what newsham wants to know
20:56:31 <dmwit> As long as the speed difference between idiomatic and optimized code is roughly the same in every language (a strong assumption), everything evens out.
20:56:37 <newsham> phila: i know that I dont write haskell code constantly looking at the disassembled results to try to fit a desired outcome.
20:56:44 <newsham> if I want a desired asm outcome, I'll write the asm code
20:56:47 <dmwit> Oh, I see.
20:56:57 <newsham> dons: true, thats one value of it I guess.
20:56:59 <Philippa_> then you clearly don't care about speed /that/ much
20:57:03 <newsham> but not too valuable to me I guess
20:57:16 <dons> newsham: and that means you get a sense of what library code, for example, is capable of
20:57:27 <mauke> withCString "..." (mkFun . castPtrToFunPtr)!
20:57:29 <newsham> dmwit: yah, so I read all this non-idiomatic code and dont get a good feel for any of the languages (or what their realistic perf will be for code I write)
20:57:38 * ddarius thinks the biggest benefits by far of the shootout has been to prompt fixing of some exceptionally bad code.
20:57:48 <ddarius> *cough* String IO *cough*
20:58:21 <newsham> some of the C code is very straightforward :)
20:58:38 <newsham> (but i already know about C programming and expected perf)
20:58:55 <ozone> ddarius: funny how it bit erlang in the ass for tim bray's stupid benchmark.  i really don't know many (any?) languages that have actually got strings right
20:59:09 <dons> hmm, i think binary-trees is a perfect benchmark for pointer tagging
20:59:16 <dons> it just allocates a gazillion tree nodes, strictly
20:59:27 <dons> so it will really benefit from a) knowing which constructor it is
20:59:31 <dons> and b) if its been evaluated yet
20:59:43 <dons> so we see a humongous speedup from the pointer tagging runtime
20:59:45 <ddarius> ozone: Define "right" in regards to strings
20:59:55 <ozone> ddarius: i was waiting for that :)
20:59:56 <kscaldef_>  ozone: most languages that are used a lot use buffered IO
21:00:36 <kscaldef_> that was the obvious thing killing Erlang in that example
21:01:24 <ozone> ddarius: i think you know what i mean -- good performance, proper handling of lots of character sets, good level of abstraction, good interoperability with other types of strings, good unicode support, etc
21:01:29 <dons> they should get some bytestrings ;)
21:01:41 <dons> but they can't take our fusion!
21:01:42 <ozone> but of course, depends on your needs and wants and goals, blah blah blah
21:02:15 <ddarius> ozone: Perhaps the problem is "strings" themselves.
21:02:20 <kscaldef_> indeed
21:02:33 <kscaldef_> doing strings "right" is going to be expensive
21:02:34 <ddarius> dons: Almost no language can take our fusion.
21:02:46 <sfultong> wasn't someone working on ropes for haskell a while back?
21:02:57 <ddarius> sfultong: About three to five people, including me.
21:03:01 <dons> Data.Sequence is close enough, sfultong
21:03:03 <ozone> kscaldef_: i don't think that's a suitable answer, considering that one well-done implementation is going to save a lot of headache for a lot of people
21:03:13 <ddarius> dons, sfultong: Apparently.
21:03:26 <kscaldef_> ozone: different people have different priorities, though
21:03:28 <ddarius> Heck, lazy bytestrings do rather well by themselves too.
21:03:50 <sfultong> oh... I was going to figure out what exactly ropes were/were capable of when a full haskell implementation was made :(
21:03:56 <ozone> kscaldef_: yes, but one very good string class goes a very long way to solving a lot of people's problems
21:04:06 <dons> yeah, side effecing languages -- even if you can rediscover purity -- are going to break up pipelines with intermediate effects too often for fusion to be a big win, i suspect
21:04:25 <dons> let alone the problem of discovering pure expressions in the first place
21:04:27 <ddarius> sfultong: Write an editor that stores the entire file -and all changes to it- in one "string"
21:04:48 <ddarius> sfultong: Free unlimited undo.
21:05:33 <sfultong> ah... sounds more like knots than ropes
21:05:58 <ddarius> Or rather just a stack of strings that each are "the entire file" at each change
21:06:53 <sfultong> I think learning how to effectively utilize function purity is a bigger challenge in haskell than learning monads
21:07:13 <Nafai> sfultong: What do you mean exactly?
21:07:18 <ddarius> sfultong: Everything is pure.  You don't usually directly "utilize" that.
21:07:59 <sfultong> well... like realizing you can save up large lists of arbitrary computations, and not have to worry about it
21:08:21 <dfranke> that's not purity, that's laziness.
21:08:22 <dons> oh, laziness really, then.
21:08:56 <dons> and then data becomes control, and the haskell programmer's eyes glaze over like a lisp programmer eating a macro
21:09:09 <ddarius> Usually purity is used in (in)formally (perhaps subconciously) reasoning about your code.
21:09:15 <dons> as they stare off into the distance, thinking about infinite streams of actions
21:09:45 <ddarius> Haskell programmers are very happy and friendly with data being control.
21:09:51 <sfultong> err.. yeah, laziness
21:10:01 <sfultong> :-P
21:10:24 <dons> > take 4 (replicate getChar)
21:10:26 <lambdabot>  Couldn't match expected type `Int' against inferred type `IO Char'
21:10:39 <dons> > take 4 (repeat getChar)
21:10:40 <lambdabot>  [<IO Char>,<IO Char>,<IO Char>,<IO Char>]
21:10:50 <dons> that's your first class imperative language right there!
21:11:20 <ddarius> sfultong: What happens particularly is that you just learn how to appropriately write code in a lazy language and the benefits of laziness come naturally.  Sometimes you have to actually think about it though.
21:11:50 <dibblego> some people get stuck in strict, imperative land indefinitely
21:12:28 <ddarius> It takes care to write good strict, imperative land code in Haskell.
21:12:30 <goalieca> yeh.. that happens
21:12:47 <dibblego> some people get stuck in strict, imperative land indefinitely and never write good Haskell code :)
21:13:12 <dfranke> I think lazy semantics would probably be more intuitive than eager if you were learning Haskell as a first language.
21:13:27 <dibblego> they are in my anecdotal experiments
21:13:31 <dfranke> because you don't have to distinguish between x and (lambda () x)
21:13:44 <sfultong> dfranke: yeah, imperative programming is ruining our children!
21:14:05 <dibblego> sfultong, despite your sarcasm, I firmly believe that statement
21:14:05 <dfranke> sfultong: meh.  I learned QBASIC at the age of 5, and I turned out alright :-)
21:14:08 <dons> that was the plan with haskell as a teaching language
21:14:22 <sfultong> sapr/whorf hypothesis applied to programming
21:14:42 <ddarius> dibblego: Those are the people that write page long functions using STUArrays and then wonder one a one-liner using list-processing functions tromps them.
21:14:47 <sfultong> yeah, QBASIC was my first... scratch that, apple basic was my first language
21:14:49 <dons> the first programming language i learned properly was pure and lazy, i wonder if it warped me
21:15:00 <dibblego> ddarius, yep, you've met them too :)
21:15:08 <dfranke> dons: was that Haskell, or something else?
21:15:13 <newsham> dons: how boring.
21:15:25 <dons> heh
21:15:25 <sfultong> dibblego: actually I wasn't being sarcastic... I just like to make fun of my own sentiments :)
21:15:37 <dons> consider it an experiment
21:15:38 <ddarius> dons: I don't know about purity, but you don't seem too lazy so I guess you're good.
21:15:50 <newsham> no single stepping through 6502 using a cartridge monitor?
21:15:52 <noecksit> hello, i have a question about passing parameters in functions
21:15:58 <dons> noecksit: please ask!
21:16:09 <noecksit> i have a function "equal a b = a == b"
21:16:13 <dons> newsham: oh, by session 2, sure.
21:16:33 * ddarius wrote a 6502 emulator once, he thinks...
21:16:35 <noecksit> and then "print (map equal (lines s lines d))"
21:16:40 <dons> i want to see the kids that start with epigram, and work backwards
21:16:43 <ddarius> I'm pretty sure it was a 6502
21:16:51 <newsham> wrote a few emulators, but never for 6502
21:16:52 <dons> lines s lines d looks wrong
21:16:59 <dons> do you mean, lines s ++ lines d
21:17:08 <noecksit> with s and d being a string of multiple length
21:17:10 <dons> ah, no zip :)
21:17:16 <dons> > zip "haskell" "pascal"
21:17:18 <lambdabot>  [('h','p'),('a','a'),('s','s'),('k','c'),('e','a'),('l','l')]
21:17:21 <ddarius> zipWith equal (lines s) (lines d)
21:17:21 <dfranke> I think he means print (map $ equal (lines s) (lines d))
21:17:37 <dfranke> err, scratch the $
21:17:44 <dons> > [ x == y | (x,y) <- zip "haskell" "pascal" ]
21:17:45 <lambdabot>  [False,True,True,False,False,True]
21:17:47 <ddarius> "a string of multiple length" ?
21:17:49 <dfranke> actually scratch that whole thing
21:17:53 <dfranke> I have no idea what he means.
21:17:55 <dons> good dfranke :)
21:18:03 <noecksit> i want to check if the the first element in lines s is equal to the first element is lines d and so on for every element in the two lists
21:18:08 <dons> yep
21:18:13 <dons> i'd use a list comprehension for that
21:18:14 <dmwit> > zipWith (==) "haskell" "pascal"
21:18:14 <lambdabot>  [False,True,True,False,False,True]
21:18:20 <dons> and 'zip' to pair up the elements
21:18:26 <dmwit> noecksit: ^^
21:18:31 <dons> > zip [1..10] "haskell pascal"
21:18:32 <lambdabot>  [(1,'h'),(2,'a'),(3,'s'),(4,'k'),(5,'e'),(6,'l'),(7,'l'),(8,' '),(9,'p'),(10...
21:18:40 <dons> then you compare the pairs
21:18:51 <dons> or do it in one pass as dmwit says, with zipWith
21:19:13 <dons> > zipWith (*) [1..10] [10,9..1]
21:19:13 <lambdabot>  [10,18,24,28,30,30,28,24,18,10]
21:19:37 <dons> n.b reverse enumFromTo, rarely seen ;)
21:19:37 <ddarius> Incidentally, equal a b = a == b is the same as equal = (==) which suggests there is no reason to name it.
21:20:15 <dons> noecksit: ok, so got some ideas to ponder now?
21:20:43 <noecksit> dons: yeah, ill def check out zipWith and zip more
21:21:39 <sfultong> in my recent, brief foray into ruby, I was missing zipWith... I was tempted to reimplement prelude in ruby
21:22:00 <ddarius> sfultong: The Haskell Prelude is less fun in most other languages.
21:22:11 <sfultong> or... maybe it wasn't zipWith...
21:22:14 <newsham> doesnt sound like zipwith would be terribly hard to reproduce
21:22:24 <dons> hmm, i think there was even a ruby prelude project
21:22:47 <dons> i saw the ruby guys going nuts over unfolr the other day
21:22:51 <dons> maybe they'd like zipWith too
21:22:51 <ddarius> newsham: Writing the code is easy enough, but oftentimes it's nowhere near as useful.
21:23:13 <dfranke> In my brief, less recent foray into Ruby, I was missing the ability to have my programs terminate before grandchildren arrived.
21:23:27 <dons> http://rubyforge.org/projects/prelude
21:23:28 <sfultong> heh, what was really confusing to go to ruby, is that everything in ruby is an object.... so I was concatenating functions with '.' in a sense...
21:23:28 <thetallguy> I don't see any library functions that deal with logins, uids, gids, passwords, etc., the whole /etc/passwd /etc/group stuff.  Am I overlooking them anywhere?
21:23:29 <lambdabot> Title: RubyForge: Prelude Library: Project Info
21:23:35 <newsham> ddar: I dont think I buy that, wrt ruby and zipwith
21:23:37 <ddarius> dfranke: Your code took two generations to run?  Impressive.
21:23:39 <dons> thetallguy: in the unix package
21:24:05 <dons> thetallguy: c.f. System.Posix.User
21:24:51 <dons> should be pretty complete, and mostly portable
21:25:21 <thetallguy> dons:  sweet, got it, thanks.
21:25:58 <dfranke> ddarius: the final straw that made me give up on Ruby was when I was writing a program to generate frequency tables of n-grams from a long corpus.  The damned thing was taking so long that I just rewrote it in C, with glib and only about 50% more code, and got a 25x speeedup.
21:27:07 <ddarius> I've never really had the desire to learn ruby or python.
21:27:25 <ddarius> I've written some python though.  Maybe someday I'll learn it too.
21:27:43 <Nafai> Basic Python took me an afternoon to learn
21:27:52 <Nafai> Wish I could say the same about Haskell :)
21:27:58 <Nafai> Though I have come a long ways recently
21:28:29 <sfultong> yeah.  I'll never be done learning haskell
21:28:38 <dfranke> I've been Haskelling for a year now, and when I hang around here I don't dare consider myself proficient.
21:29:08 <newsham> python's such a great beginners language
21:29:13 * ddarius has only been Haskelling for five and three quarter years.
21:29:18 <hircus> dfranke: wasn't there this article somewhere that said it takes 10 years to learn programming
21:29:29 <dfranke> hircus: by Norvig, yeah.
21:29:36 <ddarius> Peter Norvig, learn programming in 21 years or some such
21:29:43 <sfultong> heh, nice
21:29:44 <dons> hmm. how can we make this easier
21:29:46 <ddarius> It's linked on my programmersheaven bio.
21:30:03 <dons> it doesn't feel like a hard language. maybe we can sell brain implants
21:30:07 <ddarius> (The one I haven't touched for about five and three quarter years...)
21:30:16 <dons> delivering spj goodness directly into the cortex
21:30:16 <dfranke> hircus: But I don't recall whether that assertion was regarding specific languages or programming in general.
21:30:21 <newsham> write yourself ghc in 70080hrs
21:30:23 <dfranke> hircus: I've been coding for 15 years.
21:30:24 <ddarius> dons: The core of Haskell is extremely simple.
21:30:54 <thetallguy> dons: It's on my list to blog about starting with core and no prelude
21:30:55 * ddarius has been coding for 11.
21:31:31 <dfranke> actually, I suppose I consider myself proficient at the H98 level.  But all the most beautiful and magical stuff is in extensions.
21:31:37 <dons> thetallguy: yeah, that would be very useful
21:31:51 <dfranke> at least, the beautiful and magical stuff that isn't also in Scheme.
21:31:54 <thetallguy> dons: but I think the fundamental thing is, it takes a while to understand what the run time is doing for you
21:32:02 <Philippa_> 18 here
21:32:03 * sfultong wonders what it's like for children of programmer parents who grow up learning programming soon after English
21:32:16 <Philippa_> odd
21:32:17 <thetallguy> and I've been wondering if expression reduction needs to be moved up sooner.
21:32:18 <newsham> thetall: sounds like an interesting blog article.  where's your blog?
21:32:29 <thetallguy> It's on planet haskell
21:32:39 <thetallguy> cliffordbeshers.blogspot.com
21:32:46 <newsham> the jansen/koopman/plasmeijer SAPL paper ruled
21:32:49 <dfranke> sfultong: the funny thing is, I'm in that category, but my parents weren't programmers :-)
21:32:53 <thetallguy> It's mostly recipes, so far.
21:33:01 <thetallguy> They are easier than code.
21:33:08 <dfranke> sfultong: my dad was CE major but by the time I was born he had moved into sales.
21:33:23 <dmwit> My brother tried to teach me how to do some C programming when I was a kid.
21:33:32 <sfultong> ewww.... sales :-P
21:33:34 <dmwit> I was hopelessly bad.
21:33:42 <dmwit> (I guess I still am. =)
21:33:43 <newsham> C was around when you were a kid? ;-)
21:33:45 <Philippa_> most of us are when we're really young
21:33:48 <thetallguy> I think it just really takes time to relearn.
21:33:58 <sfultong> I can't wait to have kids to program
21:34:09 <dmwit> That'll be the day.
21:34:14 <thetallguy> sfultong: hah!
21:34:20 <thetallguy> other way around.
21:34:28 <dmwit> "Johnny, put that down!  I'm going to rip out your frog-playing subroutines if you keep that up."
21:34:28 <dfranke> Literally the second book I ever read, the first being Dick & Jane or some such, was a QBASIC book :-)
21:34:29 <newsham> hope you're good at exception handling
21:34:34 <Philippa_> sfultong: you teach them, it's not quite the same thing :-)
21:35:01 <Philippa_> heh, I was a more enthusiastic reader than that
21:35:42 <sfultong> Philippa_ : teach, program... it's all the same thing when they're 2 years old
21:35:58 <goalieca> i learned from the qbasic help-file examples
21:36:02 <ddarius> My QBASIC code was ridiculously bad.
21:36:29 <newsham> didnt have an ibmpc, no qbasic for me.
21:36:37 <sfultong> I learned QBASIC by randomly changing numbers in the nibbles and gorillas source...
21:36:46 <sfultong> it took a while to figure things out
21:36:49 * RayNbow remembers his first piece of VB code... it looked like a DOS batch file with all those gotos :p
21:37:36 <sfultong> heh, goto was the first instance of program flow control I came across, and it seemed magical
21:37:45 <sfultong> when I was ~9
21:37:48 <newsham> you could get a compuer with a multitasking operating system and a windowing system for the same cost as an IBMPC running dos, back then
21:39:11 <kscaldef> sfultong: I guess I qualify.  My mom was CS and my dad EE and I started programming at 7
21:39:26 <dfranke> and the first words I ever learned how to spell were dir, cp, copy, move, abort, retry, and fail.
21:39:35 <dfranke> erp, s/cp//
21:39:40 <newsham> dfranke: i'm sorry :(
21:41:53 <Philippa_> you didn't learn you could use a, r and f?
21:42:17 <sfultong> kscaldef: nice, now regale me with your tales of superhuman programming feats
21:42:18 <dfranke> yeah, I did.  But I got used to seeing those words, so I could spell them :-)
21:42:21 <Philippa_> I was playing hangman on an Amstrad PCW before I got to play with a PC, so I was spelling rather more
21:44:46 <kscaldef> sfultong: I think the most obvious result is that I learn languages very easily.  Like natural languages, I think that if you can use multiple computer languages before puberty, you can just pick up new languages without much work.
21:45:00 * ddarius really should write an assembler/forth or something with a hexeditor sometime.
21:45:29 <kscaldef> I'd probably have more programming feats to brag about if I hadn't spent 15 years convinced I was going to be a physicist
21:45:45 <ddarius> kscaldef: I hate to burst your bubble, but I think everyone who has learned more than a two different languages can pick up new ones very easily.
21:46:14 <kscaldef> ddarius: maybe 2 languages of different paradigms
21:46:15 <sfultong> everyone who has learned a paradigm can pick up others in the same paradigm easily...
21:46:34 <ddarius> sfultong: Agreed.
21:46:45 <kscaldef> but, many "programmers" seem to never be able to move beyond the paradigm they first used
21:46:59 <ddarius> Many programmers don't ever try.
21:47:17 <sfultong> kscaldef: sorry to hear about the physics.  I thought I was going to make electronic music for 2-3 years...
21:47:42 <dfranke> I didn't have much trouble moving from imperative to OO or from there to functional.  I've never grokked Prolog, though.
21:47:54 <kscaldef> sfultong: physics was fun until I discovered that academia wasn't all it's cracked up to be
21:47:56 <dons> Ulisses Costa's blogging in english :) nice foldr overview  http://programming.reddit.com/info/60zsk/comments/
21:48:05 <kscaldef> being a professor is a lot like being a manager
21:48:14 <dons> the uminho guys need to get more visibility. they do some amazing haskell stuff
21:48:34 <kscaldef> lots of paperwork and politics and telling other people want to do, and not a lot of doing stuff yourself
21:48:35 <dons> `The magic foldr: simpler, cleaner code by abstracting out recursion '
21:49:23 <ddarius> dfranke: Go learn Prolog.
21:49:33 <shachaf> dons: "lenght"?
21:49:58 <shachaf> Someone (else) should post a comment.
21:50:05 <dons> heh, his english is better than my portuguese
21:50:12 <sfultong> kscaldef: so what's your take on this Lisi guy that everyone's talking about?
21:50:33 <sfultong> ddarius: is learning Prolog worth it?
21:50:37 <newsham> kscaldef: I dont think computer languages are nearly as hard to learn as natural language.  and they're much closer to each other semantically.
21:50:42 <dons> sfultong: E8 would make a great Control.* extension for haskell :)
21:50:44 <kscaldef> sfultong: I should really go read his paper, but I've been too busy the last week
21:50:52 <shachaf> Yes, I'm not talking about the parts that aren't code.
21:51:00 <newsham> learning multiple computer languages is not really that much of a challenge, even if you learned programming late in life.
21:51:00 <kscaldef> newsham: agreed
21:51:04 <ddarius> sfultong: Yes.  Using it is foolish, but learning it is good.
21:51:08 <shachaf> Misspellings in PDFs/images/code really bug me.
21:51:14 <ddarius> (There are better logic languages.)
21:51:39 * Pseudonym ahems
21:51:54 <Pseudonym> This is true, but Prolog is a great toy, if all you want to do is play.
21:52:18 <shachaf> dons: How do you get to all these links, by the way?
21:52:19 <ddarius> If you go for toys, there are still funner logic programming toys than prolog.
21:52:30 <Pseudonym> True enough.
21:52:33 <dons> shachaf: the magic of rss aggregation.
21:52:34 <Pseudonym> But Prolog is ubiquitous.
21:52:42 <ddarius> Which is exactly why I suggest it.
21:52:45 <Pseudonym> And to be fair, most logic languages begin with Prolog.
21:52:53 <ddarius> Which is exactly why I suggest it.
21:52:56 <Pseudonym> Whether it's the semantics or just the syntax.
21:52:57 <Pseudonym> Yeah.
21:53:05 <Pseudonym> Learning Prolog is worth it.
21:53:10 <Pseudonym> Learning it well is... uh...
21:53:16 <Pseudonym> Up to you.
21:53:44 <Pseudonym> If you feel like you need a failure-driven loop, you really need to think about getting a better language.
21:53:45 <sfultong> well... that's 2 recommendations.  I suppose I should file away that advice for whenever I have no other things to learn
21:54:12 <sfultong> in other words... within a couple lifetimes
21:54:45 <sfultong> maybe if I get more recommendations, I'll bump it up in the queue a few notches ;-)
21:55:33 <ddarius> sfultong: Writing a type checker is easy as pie in a logic language.
21:55:52 <Pseudonym> Or, rather, as easy as sigma.
21:56:47 <bos> @seen dons
21:56:47 <lambdabot> dons is in #haskell, #ghc and #xmonad. I last heard dons speak 4m 14s ago.
21:57:20 <sfultong> @seen sfultong
21:57:21 <lambdabot> You are in #haskell. I last heard you speak just now.
21:58:15 <shachaf> @seen myself
21:58:15 <lambdabot> I haven't seen myself.
21:59:05 <sfultong> @seen the world
21:59:05 <lambdabot> I haven't seen the.
21:59:24 <sfultong> oh, I forgot about that silly truncation
21:59:47 <monochrom> @seen Haskell
21:59:47 <lambdabot> I haven't seen Haskell.
22:00:08 <monochrom> @seen lambdabot
22:00:08 <lambdabot> Yes, I'm here. I'm in #oasis, #huskerlug, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell,
22:00:08 <lambdabot> #ghc and #darcs
22:00:17 <shachaf> haskell goes by the name glguy now. :-)
22:00:20 <ddarius> @seen lambdabot2
22:00:20 <lambdabot> I haven't seen lambdabot2.
22:00:52 <sclv> wtf at clean! MaskData :== {!{!{![#Int!]}}}
22:01:16 <sclv> does anyone know what that means?
22:01:30 <kscaldef> sfultong: I just skimmed Lisi's paper.  It seems interesting, but I'm skeptical of the significance.  The fact that you can embed the standard model and gravity in E8 is not really surprising, given the size of E8.  I'd like to see some expansion on his claims of experimental testability, though.
22:01:36 <ddarius> I'm pretty sure the [#Int] is a head strict list of Int, otherwise, no.
22:02:16 * sclv is trying to take dons advice and port the clean meteor-contest to haskell (knowing virtually no clean, and also not having bothered, by that token, to really understand what the clean code does)
22:02:34 <sfultong> kscaldef: well, I don't know much about theoretical physics, but I imagine that the domain of E8 is smaller than the domain of string theory... so maybe progress is being made :-P
22:02:56 <ddarius> sclv: Indeed.  After looking at that I decided I either needed to learn Clean or say screw it and write it from scratch.
22:03:11 <sclv> I've gotten pretty far actually
22:03:44 <newsham> http://motls.blogspot.com/2007/11/exceptionally-simple-theory-of.html
22:03:44 <sclv> I think this is a strict array of strict arrays of strict arrays of lists of unboxed ints
22:03:44 <lambdabot> http://tinyurl.com/2y64by
22:05:31 <phlpp> hi
22:06:51 <kscaldef> sfultong: in some sense yes, but there are string theories based on E8xE8 with our universe living on one E8, so I'm not sure how different this is.  I guess a question you might ask is why this particular representation of E8, rather than one of the N others?  (Where N is quite large)
22:06:56 <sclv> that function uses parallel array comprehensions it seems, so i'm going to leave it be and finish translating the rest, which is relatively easy
22:07:42 <Pseudonym> It does concern me that a paper which attempts to solve a major problem in physics doesn't mention words like "Hamiltonian" once.
22:07:44 <sclv> that nested letrec that clean is so fond of with rebinding every line is awful and ugly -- so imperative.
22:08:29 <goalieca> Pseudonym, or jacobian :P
22:09:07 <kscaldef> Pseudonym: he talks about actions, with are basically equivalent
22:09:36 <kscaldef> particle physics is couched in the language of Lagrangians / actions generally
22:09:58 <kscaldef> although, there's a straightforward translation to the Hamiltonian formulation
22:10:07 <newsham> did you read lubos motl's reaction to Lisi's paper?
22:10:15 <kscaldef> no
22:10:25 <newsham> http://motls.blogspot.com/2007/11/exceptionally-simple-theory-of.html
22:10:25 <lambdabot> http://tinyurl.com/2y64by
22:10:38 <kscaldef> wow, this is like flashbacks... I remember all these guys from usenet back in the day
22:11:13 <kscaldef> before I will go read that, I will just say that Motl is a really ...opinionated... guy
22:11:28 <newsham> thats what makes it all the more fun
22:11:38 * sfultong reminds himself to visit #haskell whenever a popular science article intrigues him
22:11:58 <kscaldef> I actually used to be a moderator of sci.physics.research and dealing with Motl was an ongoing problem
22:12:31 <newsham> yah but thats serious, blogs are entertainment :)
22:13:04 <goalieca> kscaldef, the good 'ol days when trolls were smarter
22:15:06 <Korollary> Lubos is a fun guy
22:15:23 <Korollary> Does anyone know exactly why he moved back home?
22:19:20 <kscaldef> well, while Lubos is typically abrasive in that post, I would say that he's probably right.  Lisi's paper looks more like numerology to me than physics
22:21:25 <sfultong> well, nevertheless, I'm intrigued about E8 now
22:21:29 <kscaldef> wow.. the comments on that post are really something... "You come off sounding like a pissed off jew, what with your name calling and frivolous arguments."
22:21:43 <sfultong> classy
22:22:32 <newsham> if you're going to be an asshole, you could do worse than becoming a scientist
22:22:50 <sfultong> yeah, you could become a politician
22:24:08 <shapr> hiya skew, long time no see. How's code?
22:25:29 <skew> not too much code.
22:25:35 <skew> Applying to grad school, finally.
22:25:39 <shapr> Cool, whereat?
22:25:39 <skew> Also bought the Coq book
22:26:19 <skew> UIUC, though I might want to go somewhere else later
22:27:09 <skew> How are you?
22:27:24 <shapr> Life is good, learning new stuff and getting paid to hack Haskell.
22:27:30 <skew> yay
22:27:35 <shapr> Have you read any interesting papers lately?
22:27:37 <skew> Oh, I was playing with some scala.
22:28:16 <skew> Actually, playing with straight Java in Eclipse and watching the IDE go was interesting too
22:28:18 <shapr> Do you like it?
22:28:29 <shapr> I've been playing with Eclipse some myself.
22:28:43 <skew> The stuff with traits seems nice
22:29:16 <glguy> @yow
22:29:16 <lambdabot> I want a WESSON OIL lease!!
22:29:20 <shapr> @yow !!
22:29:20 <lambdabot> Did an Italian CRANE OPERATOR just experience uninhibited sensations in
22:29:20 <lambdabot> a MALIBU HOT TUB?
22:29:23 <shapr> @quote glguy
22:29:24 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
22:29:29 <shapr> @quote skew
22:29:30 <lambdabot> skew says: [on the subject of strictness] there is a sequet incatation.
22:29:54 <skew> I got into that trying to find some nice way of making an editor with syntax highlighting
22:30:00 <shapr> Did you find something?
22:30:02 <skew> the Java styled text thing is way compilcated
22:31:08 <skew> Then Coq'Art got here and I've been looking through that
22:31:58 <shapr> I've been rereading Hamming's Art of Science and Engineering, it's really great.
22:32:52 <skew> hmm, papers. I read a bit about the synthesis OS.
22:33:04 <skew> fancy runtime code generation to make things go fast
22:33:41 <skew> all had coded, but I think you might think of it as compiling closures by partially evaluating the code generator with respect to the closure body, then making closures by baking in arguments with the specialized code generator
22:33:47 <skew> hand coded, that is
22:34:21 <ddarius> The Self papers are more interesting, but the Synthesis OS paper was also cool.
22:34:30 <shapr> poly-inline caching! w00!
22:35:11 <skew> I thought the stuff about making specialized efficient code generators for each bit of code to be generated seemed quite nice
22:36:33 <shapr> Is the synthesisOS stuff better/different from Self's PIC?
22:36:54 <ddarius> Synthesis OS was very old.
22:37:05 <skew> I don't know about Self, but I think it just has a single JIT.
22:37:26 <skew> on the other hand, Synthesis doesn't do any sort of polymorphism at all
22:38:31 <skew> it's like when you connect some objects callbacks/dependencies together it generates code for that specific combination
22:39:01 <skew> Mostly by pasting pre-existing bits of code together, then stuffing in a few constants
22:39:11 <shapr> partial evaluation?
22:39:33 <skew> but the part I thought was really interesting was that a lot of the work was done ahead of time, making the templates and figuring out what runtime optimizations would pay off, so the runtime part is very fast
22:39:50 <skew> It was all written by hand, but it sounded like partial evaluation
22:40:16 <ddarius> shapr: Just read the paper.  It isn't too long and has quite a few other ideas.
22:40:19 <ddarius> It's hacky though.
22:40:22 <skew> like I said, partially evaluating the code generator with respect to each bit of code that might need to be specialized, at compile time, then using the appropriate specialized generator at runtime
22:40:54 <skew> ddarius: yeah, what I'm saying is a somewhat less hacky reinterpretation of what the paper describes
22:41:27 <shachaf> "For example, we must be able to invert each patch, or undo it's change." -- from TMR. Is it too late to fix it?
22:43:11 <skew> oh, and this software renderer michael abrash worked on apparently puts together pixel pipelines also with some very cheap sort of instruction assembly: [#haskell] orked on apparently puts together pixel pipelines also with some very cheap sort of instruction assembly: V
22:43:35 <skew> i)] [2:#haskell(+cnt)] [Act: 1]
22:43:38 <skew> [#haskell]
22:43:45 * ddarius hasn't heard Abrash's name in a long long time.
22:43:49 <skew> just a minute, need to figure out how to paste...
22:44:36 <skew> http://programming.reddit.com/info/60zbp/comments/
22:44:48 <skew> (ddj in 2004, but that gathers the parts together)
22:46:26 <shachaf> If it isn't -- "There seems to be two main ways of solving the problem.".
22:49:25 <skew> Ah, and of course various things on gradual typing - "Space Efficient Gradual Typing", and "Well-Typed Programs Can't Be Blamed"
23:25:48 <goalieca> hmm. why do people try to cheat off me. they know i hate cheaters.
23:26:41 <ddarius> goalieca: I suggest punching everybody who tries to cheat off you in the face from now on.  I guarantee that that will quickly resolve the issue.
23:26:55 <Korollary> goalieca: you're the one who's cheating off your line. Fear my backhander.
23:27:19 <goalieca> Korollary, i only cheat when I know my d-man can't stop the pass
23:27:31 <goalieca> your backhander? pssh
23:27:40 <goalieca> and i wish i could punch people over msn
23:27:46 <Korollary> Your d-men can't stop a beach ball rolling thru the crease
23:28:02 <ddarius> goalieca: One day my service will be in place and you will be able to for a reasonable fee.
23:31:28 * goalieca drops gloves
23:31:40 <Korollary> drop the helmet too?
23:52:35 <hpaste>  sclv pasted "Clean Meteors Translation" at http://hpaste.org/3987
23:54:14 <sclv> Ok that's about as far as I can take it.
23:54:22 <goalieca> Korollary, of course.
23:54:38 * goalieca slugs Korollary in the ear
23:54:49 <dons> how's the speed, sclv ?
23:54:50 <sclv> It typechecks and compiles but my brain is in no shape to translate the masksAtCell function at the moment
23:55:02 <dons> looks like it could do with some type annotations :)
23:55:16 <sclv> dons: it's not finished -- there's a dummy function for one of the pieces, and I haven't even tried to optimize it
23:55:35 <dons> ok, but its implementing the clean algo?
23:55:38 <sclv> This was just a dumb translation -- haven't even fully figured out how the clean is supposed to work.
23:55:50 <sclv> dons: yeah -- everything should be a direct translation of the clean functions
23:56:02 <sclv> I figured it would be a good start for someone else to finish off.
23:56:04 <dons> its a weird benchmark, isn't it :)
23:56:30 <dons> i think you'll have to finish it
23:56:58 <sclv> gah -- that means I'll have to understand it. :-)
23:57:02 <sclv> maybe tomorrow.
23:57:28 <osfameron> can you section on (,) ?
23:57:40 <sclv> the dummy function I haven't implemented yet seems to be a lot of heavy lifting and it involves nested array comprehensions
23:57:48 <osfameron> > let c = (,3) in c 1
23:57:48 <lambdabot>  Parse error at "3)" (column 11)
23:57:51 <osfameron> meh
23:59:13 <osfameron> > let { c = (,); d = (`c` 3) } in d 1
23:59:22 <lambdabot>  (1,3)
23:59:35 <osfameron> so how come that works but I can't section (,3) ?
