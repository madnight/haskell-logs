00:00:01 <Cale> actually, the function arrow can be quite helpful in understanding these things
00:00:12 <Cale> > (length &&& head) "Hello"
00:00:13 <lambdabot>  (5,'H')
00:00:46 <Cale> > (length *** reverse) ("Hello", "world")
00:00:47 <lambdabot>  (5,"dlrow")
00:01:13 <falconair> ah, i see, i think that's what i should do, sit down with ghci and start typing these expressions out
00:01:55 <Cale> There's really not a whole lot to the arrow abstraction, but there are some really crazy examples of arrows.
00:04:20 <Cale> I think the right thing to do is just decide on how you're going to represent computations, and what kinds of ways to combine them you're going to want to support, and then see if that matches up with one of the existing types of libraries.
00:05:09 <Cale> Monads, Comonads, Arrows, Applicative functors, and other abstractions like them, as far as functional programming is concerned, are really just different kinds of combinator library.
00:06:20 <falconair> i'm still not very comfortable with the haskell language itself, i end up jumping around trying to find an easier way to do what i want (for my stock market experiment, i have been moving between arrows, comonads and app. functors)
00:10:49 <Cale> These abstractions are nice, and good sources of ideas, but recognising that something is a monad or comonad, etc. only goes so far. It'll give you (hopefully) a reasonably good library of functions for manipulating your computations, but there's still the underlying design of the library, and the supported operations to think about.
00:21:24 <goalieca> @src MVar
00:21:24 <lambdabot> Source not found. I feel much better now.
00:21:29 <goalieca> @src newMVar
00:21:29 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:24:07 <NuBeowulf> @src
00:24:08 <lambdabot> src <id>. Display the implementation of a standard function
00:24:19 <NuBeowulf> @help
00:24:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:27:22 <Cale> Heh, I just noticed that the first thing Graham Hutton does in his Programming in Haskell book (or at least, a prerelease copy from 2005) is the exactly the same double double thing which I do on this channel with beginners all the time :)
00:27:28 <goalieca> concurrent haskell needs better documentation. All i can find are papers by one of the simons
00:28:00 <user317> how do you install cabal on windows?
00:28:35 <goalieca> hmm.. i still haven't got what an MVar is yet. to me it seems like an atomic version of Maybe
00:31:12 <sjanssen> goalieca: MVars are mutexes with a value attached
00:31:59 <goalieca> sjanssen, yes.. but they can also appear to be "empty" now.
00:31:59 <sjanssen> goalieca: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Concurrent-MVar.html while dry, is quite informative
00:32:01 <lambdabot> http://tinyurl.com/25qzy5
00:32:08 <narain> is this a good place to ask about gtk2hs?
00:32:22 <sjanssen> goalieca: yes, empty corresponds to a "taken" or "blocked" mutex
00:32:31 <goalieca> i was reading that: "It can be thought of as a a box, which may be empty or full."
00:32:33 <goalieca> but that didn't really help
00:32:37 <sjanssen> goalieca: you are familiar with mutexes from some other language, right?
00:32:45 <goalieca> i deal with posix all the time
00:32:49 <sjanssen> okay
00:33:35 <narain> can i send an event to a widget in gtk2hs?
00:33:36 <goalieca> hmm.. i'll try to make my own semaphore using Mvar.. maybe then it'll make more sense.
00:33:37 <sjanssen> so, it's a mutex, except the usual "take" operation also returns a value
00:33:51 <goalieca> okay
00:34:13 <sjanssen> and the "return" operation requires an extra argument, the new value to store in the MVar
00:34:32 <sjanssen> the next "take" will receive this value
00:48:10 <narain> are there any gtk2hs users here?
00:54:14 <goalieca> bloody haskell knows when a deadlock.. a.out: thread blocked indefinitely
00:54:23 <goalieca> that still entertains me.
00:54:49 <sjanssen> > let x = x in x :: ()
00:54:50 <lambdabot>  Exception: <<loop>>
00:55:29 <sjanssen> I like that one even better :)
00:56:04 <goalieca> ghc is pretty damn smart for a compiler
00:56:10 <user317> what happens if i get an exception on a handle, do i still need to close it?
00:57:48 <sjanssen> goalieca: the best part is that these features are natural with the implementation GHC has chosen
00:58:49 <sjanssen> "thread blocked indefinitely" is just an exception that is thrown when a thread will be garbage collected
00:59:08 <goalieca> heh
01:01:00 <sjanssen> "Exception: <<loop>>" is a natural side effect of GHC's treatment of thunks
01:06:09 <sjanssen> goalieca: you can even catch both of those exceptions
01:07:03 <sjanssen> eg. foo `catch` \e -> case e of NonTermination -> ...; BlockedIndefinitely -> ...; etc.
01:15:09 <goalieca> sjanssen, so in case of a deadlock i can catch it!?
01:15:16 <sjanssen> yep
01:15:35 <goalieca> that has to be just about the coolest thing ever. well i suppose it all boils down to the gc.
01:15:48 <goalieca> and what generation
01:16:01 <goalieca> well i did managed to get a semaphore built using just mvar's
01:16:12 <goalieca> i tested it on my dining philosopher where they all share 2 forks
01:16:24 <sjanssen> deadlock detection is not guaranteed, however
01:16:46 <sjanssen> it only happens in the case where a thread is blocked on an MVar and no more references to it exist
01:17:05 <quicksilver> or all threads which hold references are themselves blocked
01:17:07 <quicksilver> I believe
01:17:22 <sjanssen> yeah, that should work too
01:18:14 <goalieca> well.. sure. some sort of halting problem must exist
01:18:55 <quicksilver> this is much simpler than ahalting problem
01:19:09 <quicksilver> it's not evaluating the algorithm and tring to look ahead to the future
01:19:12 <quicksilver> it's just reachability
01:19:18 <quicksilver> (which is what GC does anyway)
01:19:32 <goalieca> ya. which is why i qualified it with "some sort"
01:19:39 * quicksilver nods
01:19:58 <goalieca> lol. its late at night.
01:54:19 <RayNbow> @src foldl'
01:54:19 <lambdabot> foldl' f a []     = a
01:54:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:07:17 <salierix> What does forall mean in a type signature?
02:08:37 <sjanssen> salierix: usually they're redundant
02:08:53 <sjanssen> eg. id :: forall a. a is the same as id :: a
02:09:17 <sjanssen> salierix: forall establishes a "scope" for that type variable
02:11:01 * quicksilver thinks id :: forall a . a -> a is more usual
02:11:24 <sjanssen> erm, right :)
02:12:09 <quicksilver> salierix: or to answer it another way: forall means it works "for all types a".  But conventionally forall is omitted and it's just assumed that if you have a variable like "a" it means "all possible a"
02:12:15 <quicksilver> :t length
02:12:16 <Heffalump> it establishes a scope for the type variable in the signature; there's also a GHC extension scoped type variables where a top-level forall in a type signature extends into the entire body of the declaration.
02:12:17 <lambdabot> forall a. [a] -> Int
02:12:37 <quicksilver> salierix: for example, length works for lists of type a, for all different possible as
02:12:42 <quicksilver> salierix: I.e. lists of any type
02:13:17 <gour> heh, ex-haskell hacker writes erlang book - http://wagerlabs.com/archives/128.html
02:13:19 <lambdabot> Title: Tenerife Skunkworks
02:14:45 <salierix> So why does forall exist at all?
02:15:19 <sjanssen> salierix: it becomes interesting when foralls are nested in function types
02:15:26 <sjanssen> @type Control.Monad.ST.runST
02:15:27 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
02:16:20 <salierix> ?
02:16:23 <sjanssen> salierix: the 'a' scopes over the whole thing, but 's' only scopes over the left of the function arrow
02:16:49 <sjanssen> that type signature essentially says that the s variable can't "leak out"
02:17:43 <salierix> Do you know of any good examples using the ST monad?
02:17:56 <sjanssen> hmm
02:18:30 <sjanssen> gour: $10 says he decides to write an OCaml book instead in the next week
02:18:42 <sjanssen> then Haskell the week after that
02:18:49 <Heffalump> salierix: read Launchbury and King: Structuring Depth-First Search in Haskell
02:19:08 <Heffalump> that has a good example of using it to achieve a complexity improvement
02:19:28 <sjanssen> finally he'll go back to Erlang, and write a blog post about how Haskell has all sorts of imagined problems
02:20:21 <quicksilver> isn't joelr currently working on haskell/cocoa stuff?
02:20:26 <quicksilver> or are there two joelrs?
02:20:40 <sjanssen> quicksilver: asking about it on the mailing list, at least
02:21:07 <quicksilver> well, asking wolgang for admin rights to set it up on google code
02:21:17 <sjanssen> yeah
02:21:21 <salierix> Heffalump, where is that?
02:21:28 <Heffalump> dunno, google for it :-)
02:21:34 <Heffalump> It was published in the mid-90s.
02:21:51 <gour> sjanssen: heh, in the comment section he said he wrote his blog posts about haskell
02:22:04 <quicksilver> @go structuring depth first search in haskell
02:22:06 <lambdabot> http://www.cse.ogi.edu/~jl/Papers/dfs.ps
02:22:09 <quicksilver> presumably that's it
02:27:39 <salierix> Why does Random have no documentation?
02:28:19 <sjanssen> salierix: hmm, some funky haddock bug
02:28:28 <sjanssen> salierix: look at System.Random instead
02:28:47 <sjanssen> has haddock's behavior wrt. re-exported functions changed?
02:28:53 <quicksilver> salierix: mostly the "single world" modules are haskell98
02:28:55 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.0/Random.html
02:28:57 <lambdabot> http://tinyurl.com/3ap7wc
02:28:58 <quicksilver> sjanssen: if they are cross-package, yes
02:29:11 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/stm-2.1.1.0/Control-Monad-STM.html
02:29:12 <lambdabot> http://tinyurl.com/2dn62b
02:29:22 <quicksilver> sjanssen: and since System.Random is in base, but Random is in haskell98
02:29:28 <quicksilver> sjanssen: you don't see nothing :(
02:29:35 <sjanssen> according to my recollection, this is a regression
02:29:39 <quicksilver> sjanssen: cross-package haddock is bassically broken
02:29:40 <sjanssen> I may be mis-remembering
02:29:40 <quicksilver> yes, it is
02:29:52 <quicksilver> there are a number of related regressions
02:30:00 <quicksilver> no cross-package instances ar documented also
02:30:16 <quicksilver> you will not traversable thinks it only has two instances, for example
02:32:06 <sjanssen> http://www.haskell.org/ghc/docs/6.6-latest/html/libraries/stm/Control-Monad-STM.html
02:32:08 <lambdabot> http://tinyurl.com/2hf6a7
02:32:12 <sjanssen> is at least slightly better
02:33:33 <quicksilver> sjanssen: Yes. I believe they are aware of the problems.
02:41:14 <phlpp> good morning!
02:45:32 <NuBeowulf> morning
03:22:27 <astrolabe> It would be nice to use symmetric operator symbols ('+', '*.*' etc.) for symmetric operators, and vice versa.  The problem is '-' already spoils that.
03:23:20 <wli> Parsing unary operators is a solved problem.
03:23:50 <wli> No reason to complain. It's solved. It works. It's over.
03:24:08 <astrolabe> I think we might be talking at cross-purposes.
03:24:24 <astrolabe> I talking about binary operators.
03:24:59 <wli> I think I see. Never mind.
03:26:17 <b_jonas> hi,
03:27:05 <vincenz> astrolabe: 'symmetric' => 'commutative'
03:27:11 <vincenz> astrolabe: or 'symmetric' => 'a -> a -> c'
03:27:12 <vincenz> ?
03:27:33 <astrolabe> vincenz: commutative
03:27:50 <b_jonas> this might be a stupid question, but could a compiler in theory compile all algebraic data types to functions and case matches  to function calls (with lazy semantics) after it's done type inference and dealt with classes?
03:27:59 <phlpp> a-b = -b+a :P
03:28:03 <b_jonas> in standard haskell I mean
03:28:07 <visof> >sum[1..5]
03:28:18 <quicksilver> b_jonas: that sounds like 'church encoding'
03:28:25 <vincenz> 'xactly
03:28:41 <astrolabe> > sum[1..5]
03:28:48 <lambdabot>  15
03:28:51 <quicksilver> b_jonas: the answer is "yes", but ghc doesn't work this way, as it happens.
03:29:01 <wli> b_jonas: It might help you to read SPJ's book(s) on implementing lazy FP languages.
03:29:05 <astrolabe> visof: you need a space after the '>'
03:29:15 <visof> > sum[1..5]
03:29:17 <lambdabot>  15
03:29:23 <quicksilver> b_jonas: ndm's whole program-optimizer "supero" church encodes everything, I believe
03:29:24 <phlpp> > (\x -> (x*(x+1))/2) 5
03:29:25 <lambdabot>  15.0
03:29:28 <quicksilver> it's a work in progress though
03:29:41 <phlpp> > (\x -> (x*(x+1))`div`2) 5
03:29:42 <lambdabot>  15
03:29:45 <visof> > qsort[1,4,3,5,2]
03:29:46 <lambdabot>   Not in scope: `qsort'
03:30:17 <vincenz> > sort[1,4,3,5,2]
03:30:19 <lambdabot>  [1,2,3,4,5]
03:31:19 <visof> > 7 'div' 2
03:31:19 <lambdabot>  Improperly terminated character constant at "'div'" (column 3)
03:31:46 <b_jonas> I know ghc doesn't work like that, because it's often faster to do otherwise
03:32:08 <visof> > 2^3
03:32:09 <lambdabot>  8
03:32:12 <vincenz> > 7 `div` 2
03:32:14 <lambdabot>  3
03:33:03 <phlpp> > 3*2 + 7`mod`2
03:33:04 <lambdabot>  7
03:34:09 <phlpp> :t (<>)
03:34:11 <lambdabot> Doc -> Doc -> Doc
03:34:15 <b_jonas> wli: is SPJ equal to "Simon Peyton Jones"
03:34:19 <phlpp> what the heck
03:34:22 <quicksilver> b_jonas: yes
03:34:29 <quicksilver> phlpp: pretty printing library
03:34:31 <phlpp> @src (<>)
03:34:31 <lambdabot> Source not found. That's something I cannot allow to happen.
03:34:38 <quicksilver> @index (<>)
03:34:39 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
03:34:49 <phlpp> quicksilver: ok, i just thought this one is equal to the pascal <> :D
03:34:59 <quicksilver> no, that's /=
03:35:07 <phlpp> jep, i know
03:35:34 <phlpp> pascal has indeed some strange operators/loop constructs
03:35:54 <b_jonas> phlpp: pascal?
03:36:09 <b_jonas> you mean the "with" construct?
03:36:17 <b_jonas> or the set operations?
03:36:25 <phlpp> :D
03:36:30 <b_jonas> or range types?
03:36:51 <b_jonas> I mean, those aren't so strange, just not general enough.
03:37:01 <phlpp> hehe
03:37:23 <b_jonas> They didn't yet know the general constructs to use, like classes and whatever, so they just added a few things they thought you'd often need to the code
03:37:27 <b_jonas> s/code/core/
03:37:43 <quicksilver> bah
03:37:48 <b_jonas> oh, and pascal also has a few builtin functions that have special call syntax
03:37:53 <quicksilver> I'd rather have pascal than classes every day
03:37:55 <b_jonas> (like basic)
03:38:10 <phlpp> i mean its not the begin and end; stuff
03:38:13 <quicksilver> at least pascal had local procedures
03:38:14 <b_jonas> quicksilver: depends on what "classes"
03:38:28 <b_jonas> quicksilver: yeah, that's a good thing
03:38:55 <phlpp> hehe
03:39:34 <phlpp> i mean i laugh at some of my german friends who always tell me, why pascal is crap (begin and end, you know..)
03:40:02 <phlpp> but the point is, that i type 'begin' FASTER than this german guys type { with german kbd layout
03:40:58 <quicksilver> ;)
03:41:03 <trontonic> free pascal compiler is really good
03:41:05 <b_jonas> phlpp: that's why I use a custom keyboard layout based on us-qwertyt
03:41:06 <quicksilver> you can always DEFINE { BEGIN
03:41:09 <quicksilver> if you really care
03:41:11 <phlpp> it's not a disadvantage do have begin and end instead of { and }. there are some other points that are irritating for c/php programmers, like for only counts up to a certain point, not checking an abort condition
03:41:13 <trontonic> it's quick to compile and was the first (?) to support 64-bit executables
03:41:21 <quicksilver> but obsessing over keywords is daft
03:42:18 <phlpp> quicksilver: i think { is ok, but i don't think that "begin" instead of { is the main problem of pascal
03:42:40 <quicksilver> agreed
03:42:44 <quicksilver> that's what I'm saying
03:42:52 <quicksilver> keywords really aren't that important :)
03:42:55 <phlpp> ok :)
03:44:03 <wli> They are, but it's all-too-often BS flamewar material vs. the artistry it should be.
03:44:47 <nominolo> it's the lack of an inline-let :)
03:45:41 <nominolo> though haskells if-then-else construct doesn't play too well with the rest of the syntax :/
03:50:05 <wli> There are a lot of languages that could use inline lets.
03:50:17 <b_jonas> no, the main problem with C is the lack of a standard way to tell the compiler that your code changes the floating-point rounding mode so the optimizer doesn't treat floating-point arithmetic as pure ops. :)
03:51:26 <wli> No, the main problem with C is the lack of a module system.
03:52:46 <b_jonas> wli: you mean, functions and vars local to the compilation unit, and headers with macros to import functions with shorter names doesn't count as a module system to you?
03:54:23 <wli> No. Macro preprocessing is not a module system no matter how you spin it.
03:54:31 <quicksilver> I would say, the main problem with C is unrestricted memory access and non-bounds-checked arrays.
03:54:41 <quicksilver> That's the reason I tend to avoid C for real work.
03:54:45 <vincenz> quicksilver: not to mention unsafe casts
03:55:03 <wli> None of those things can be lived without in the kernel world.
03:55:10 <vincenz> that's a strong claim
03:55:28 <quicksilver> vincenz: unsafe casts at least you can avoid using. It's very hard to avoid using the unrestricted memory access since most C libraries have that paradigm firmly entrenched.
03:55:44 <ricky_clarkson> Lack of restrictions isn't so much a problem, as lack of a mechanism for adding those restrictions yourself.
03:55:48 <wli> vincenz: Yet easily defensible.
03:56:02 <vincenz> quicksilver: the main problem is that arrays are too lowlevel, namely the specification that array elements are contiguous in memory
03:56:05 <vincenz> wli: how
03:56:14 <quicksilver> I think 99.99% of a kernel can be written without unrestritcted memory access.
03:56:23 <quicksilver> It should be easy to isolate those bits that actualy need it.
03:56:29 <vincenz> quicksilver: into a clean dsl :)
03:56:58 <wli> vincenz: Raw memory manipulation is required.
03:57:34 <vincenz> wli: again, a claim without any backup
03:59:36 <b_jonas> unsafe casts you can almost always avoid in c++ (they have to be used in system libraries and malloc)
03:59:46 <b_jonas> that's what I like in c++
04:00:00 <wli> vincenz: Um, wget -c -t 0 ftp://ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.22.tar.bz2
04:00:12 <quicksilver> wli: that just shows what linus did.
04:00:13 <vincenz> wli: an implementation is not a proof of the fact that it is -required- by -any- os
04:00:14 <b_jonas> non-bounds-checked array is an advantage I think. you can always bounds-check arrays when you want to do, but usually that's not needed.
04:00:16 <vincenz> quicksilver: thank you
04:00:17 <quicksilver> wli: it doesn't show what is possible
04:00:44 <quicksilver> in fact, kernels have been written in languages with memory restrictions
04:01:25 <vincenz> imo, it'd b better to use a language that has memory restrictions and to use specific native dsl-constructs for where it -might- be required, thereby ensuring more saftey
04:02:42 <Jiten> the correct operation versus performance tradeoff :)
04:02:54 <vincenz> Jiten: it needn't be a performance issue
04:02:59 <vincenz> all depends on the complexity of your compiler
04:03:13 <vincenz> or the restrictions of the language
04:03:25 <wli> Every piece of runtime system is a relatively nasty burden for the kernel to take on.
04:03:34 <vincenz> a language without arrays, e.g., would have no added complexity since you can't do out-of-bound if you don't have arrays
04:03:35 <b_jonas> really, bounds checking usually isn't such a big deal.
04:03:50 <vincenz> s/e.g./i.e.
04:03:58 <quicksilver> b_jonas: you speak like someone who hasn't had a C program crash due to an off-by-1 array access
04:04:08 <quicksilver> b_jonas: or at least, hasn't had that happen often enough
04:04:12 <vincenz> quicksilver: I think he means re performance cost
04:04:12 <b_jonas> quicksilver: sure I've had that
04:04:33 <b_jonas> but most often it's easy to avoid that, even if by adding bounds checking
04:04:37 <wli> It's not a performance cost.
04:05:02 <b_jonas> and I'm rather a c++ programmer than a c programmer these days
04:06:20 <roconnor> :/ Why do people thing programming should be easy?
04:06:26 <wli> In kernels you have to write allocators yourself, and esp. with memory-mapped crap in drivers use the types as nothing more than indexing and decoding aids.
04:06:40 <roconnor> sorry, I'm reading reddit comments.
04:06:50 <wli> The idea of a bounds-checked array is patently preposterous.
04:06:52 <vincenz> roconnor: link?
04:07:06 <roconnor> vincenz: http://programming.reddit.com/info/609ja/comments/
04:07:08 <lambdabot> Title: programming: Admitting that Functional Programming Can Be Awkward
04:07:09 <vincenz> wli: keep on making unfounded claims, it's amusing
04:08:05 <vincenz> roconnor: heh, lots of FP vs OOP, which imo is a wrong take on things. FP and OOP both have their areas of applicability
04:08:07 <roconnor>  vincenz: perhaps this thread specifically http://programming.reddit.com/info/609ja/comments/c02fv86
04:08:08 <lambdabot> Title: programming: Admitting that Functional Programming Can Be Awkward
04:08:12 <wli> vincenz: kmalloc(), __get_free_pages(), bootmem_alloc(), pardon me while I fish for drivers.
04:08:21 <vincenz> wli: again, you'er talking about -one- implementation
04:08:29 <vincenz> wli: an implementation is not a proof that it holds for all possible implementaitons
04:09:20 <wli> AIX and DYNIX/ptx were not significantly different. I worked with them for less time over 5 years ago and no longer have source access, so they're not as easy to cite.
04:09:50 <wli> So that's 3 implementations, not one.
04:09:59 <vincenz> wli: if I look at three different people, and I see they're all female, does this mean that all humans are female?
04:10:14 <vincenz> ni fact
04:10:17 <vincenz> if I look at a 1000 people
04:10:20 <vincenz> and I use a porn site
04:10:24 <vincenz> then most likely I'm seeing 1000 females
04:10:28 <vincenz> are all humans female then?
04:10:31 <b_jonas> wli: a kernel has to know about memory mapped to the kernel address space, versus memory allocated just physically; also about swappable and non-swappable; whole-page and partial; and lots of other stuff
04:11:11 * wli groans
04:11:24 <b_jonas> it's not just like malloc/new/mmap/madvise/mprotect/mlock as in processes
04:11:39 * Zao hands wli a cookie for working on sane kernels.
04:12:19 <vincenz> wli: I do not know a lot about OS design, but I'm agains 'forall x, property x' especially if based on empirical evidence based on old coding techniques.  It's close-minded and if anything it hampers research to find cases where such property may not hold, (and this case that'd be agood thing, since unbounded access is not particularly clean)
04:12:22 <wli> vincenz: I daresay the counterexamples (and I'm aware of a number of them) are vastly more exotic, rare, and far less broadly used than what I'm citing.
04:12:29 <vincenz> wli: And?
04:12:59 <wli> vincenz: If this is not enough to go on, there never will be. Ciao.
04:13:07 <vincenz> wli: so we should just stop research outright
04:13:11 <vincenz> wli: that's very close-minded
04:13:39 <wli> Kernels need help in vastly different areas.
04:13:49 <vincenz> wli: that does not preclude work in this area as well
04:13:59 <b_jonas> wli: like hardware interface stuff?
04:14:25 <b_jonas> or kernel-specific algorithms like networking, swapping, whatever?
04:15:02 <wli> Closing up typical userspace holes in a naive fashion in kernelspace creates a huge headache of how to work around the "safety measure," which is universally required. Cyclone is probably the furthest along in that direction (and has a kernel going to demonstrate it).
04:16:17 <wli> b_jonas: The runtime constraints on kernels create huge constraints on the language. Programmer-assisting techniques that work under such restrictions would help greatly.
04:17:03 <wli> Module systems, for example, have no impact on runtime ...
04:17:11 <b_jonas> wli: like the step from assembly to statically typed C (however many casts you use) was?
04:17:17 * Philippa had a use case for an isomorphic-but-not-equal identity monad transformer last night
04:17:27 <b_jonas> oh yeah, module systems. that would be nice.
04:17:40 <Philippa> as in, it would've saved me a couple of hours of debugging time and probably will save me more when I've got round to putting it in place
04:17:55 <wli> nice
04:18:06 <hkBst> how is the Peter Landin J operator related to continuations?
04:20:34 <Philippa> vincenz: raw memory manipulation is required for any language you can write a from-the-metal RTS in. Unless you want your OS to have an RTS as the kernel - which is passing the buck - a kernel needs raw memory access
04:21:00 <quicksilver> Philippa: but, I claim, only in a minute portion of its code
04:21:10 <vincenz> which could be encapsulated in a small dsl
04:21:13 <quicksilver> Philippa: my estimate was 0.01%, which may be a bit tight
04:21:41 <wli> The estimate is wrong.
04:21:43 <quicksilver> but I suggest that vast majority of a kernel is "normal" code doing "normal" stuff and would benefit from elegant, guaranteed safe, memory controlled.
04:22:39 <Jiten> so, you're just shrinking the actual kernel.
04:22:45 <wli> Your suggestion's been made before and not found to be compelling or useful.
04:22:46 <Philippa> wli: the estimate can probably be right if you can push all the safety burdens to the type system
04:23:07 <Philippa> ...well, right to within two orders of magnitude
04:23:31 <quicksilver> Jiten: if you define "kernel" as "that bit which does direct memory access", then yes
04:23:43 <quicksilver> Jiten: conventional a kernel does quite a bit more than that.
04:23:55 <quicksilver> Jiten: process scheduling, IO marshalling, message passing.
04:24:11 * Philippa points out that IO marshalling is inherently at least somewhat unsafe
04:24:14 <wli> You blow the array safety bounds bits every time you call a handwritten allocator.
04:24:24 <vincenz> roconnor: I was surprised by http://programming.reddit.com/info/609ja/comments/c02fw7b
04:24:26 <lambdabot> Title: programming: Admitting that Functional Programming Can Be Awkward
04:24:44 <wli> IO marshalling will crucify you with filesystem metadata.
04:25:04 <Philippa> wli: that rather depends on the language in question. I'm pretty sure you could build something that should behave safely in Coq, for example
04:25:06 <Jiten> quicksilver: I was just thinking that in order to have elegant, guaranteed safe and memory managed, you have to provide a kernel that does that for the rest of the code.
04:25:10 <roconnor> vincenz: I was a bit confused by that too.
04:25:50 <quicksilver> Jiten: yes. you do.
04:25:59 <quicksilver> Jiten: I'm talking about compartmentalising that problem.
04:26:07 <quicksilver> Jiten: solving it carefully, but solving it only once.
04:26:21 <wli> Memory-mapped IO will get interesting, too.
04:26:31 <Jiten> yes, that's a good idea.
04:26:43 <wli> It's a pointer to something that isn't even within the bounds of physical memory.
04:27:30 <wli> Random raw memory, casted to a struct pointer type to snatch things at various offsets for convenience's sake.
04:28:26 <Jiten> a whole operating system with a small kernel at the core providing elegant, safe and memory managed functionality to the other layers.
04:28:44 <wli> The bounds of virtual memory are also dynamic. Kernels dynamically map stuff in and out all the time. Pray tell how your array bounds checking will ever deal with that?
04:28:45 <vincenz> roconnor: usually he makes smart comments so why I was surprised
04:28:58 <vincenz> roconnor: I hope I didn't make mistakes in my reply
04:29:07 <Philippa> wli: pray tell how you know it's actually safe?
04:29:35 <Philippa> (note that what I'm advocating isn't really array bounds checking, it's using dependant typing to prove it's safe)
04:30:17 <Jiten> and no direct memory access allowed for anything but the kernel ... I wonder if that's feasible.
04:30:26 <wli> Philippa: I'm going for saying array bounds checking is irrelevant not just because it gets in the way but also because it's just not applicable to the actual sorts of bounds checks needed.
04:30:44 <Philippa> fair enough
04:31:08 <wli> Dependent types might be able to do it.
04:31:10 <Philippa> Jiten: depends on your notion of 'direct', you'll need something tolerable for drivers
04:31:23 <Philippa> if dependent types can't do it, then kernels can't be proven safe at all
04:32:11 <wli> Philippa: I'd not be surprised if kernels couldn't be proven safe at all. I'd say it's a coin flip.
04:32:37 <Philippa> I reckon that depends a lot on the value of 'safe' involved
04:32:42 <quicksilver> if that is true (and I would be extremely surprised if it was) we could still hope to push down the unprovable bits into a corner.
04:32:54 <vincenz> a dsl :)
04:32:58 <quicksilver> And say "the rest of the system is safe, based on the following lemma about this bit in the corner"
04:33:05 <vincenz> anywho
04:33:07 <vincenz> >>= shower
04:33:08 <quicksilver> "but curiously, we don't seem to be able to prove that lemma"
04:33:23 <vincenz> quicksilver: so it's an axiom :)
05:14:53 <vincenz> roconnor: is it me or is reddit decreasing in value
05:18:08 <fasta> Can I refer to the name of the current function in TH?
05:19:01 <trontonic> vincenz: the problem with reddit is that it's boring :)
05:19:50 <kalven> not enough haskell focus?
05:20:54 <Saizan> fasta: define refer
05:22:20 <fasta> Saizan: some compile time available variable of type String that holds the name of the closest enclosing named function which is currently being defined.
05:24:45 <Saizan> mmh, i'm not aware of such a thing
05:24:58 <vincenz> trontonic: agreed
05:28:29 <b_jonas> in '(f, g) = h j k' at module level, if k was that compile-time variable, what would it return?
05:30:01 <Saizan> _|_
05:30:46 <fasta> b_jonas: I could have been more explicit by saying the unique closest...
05:31:19 <Saizan> fasta: but in that case there's no unique closest
05:31:29 <fasta> Saizan: which would make it undefined
05:31:44 <fasta> Saizan: which is already what you said
05:35:42 <b_jonas> I can't see though why such a variable woule be useful.
05:36:00 <b_jonas> oh, you said "in TH"
05:36:05 <b_jonas> that's different sorry
06:03:42 <CosmicRay> does anyone know who currently hands out accounts on hackage?
06:04:29 <quicksilver> No. Guessing: Igloo ?
06:05:04 <vincenz> nod
06:05:06 <vincenz> igloo
06:07:07 <CosmicRay> hrm.
06:07:18 <CosmicRay> I just found http://hackage.haskell.org/packages/accounts.html which suggests ross
06:07:21 <lambdabot> Title: HackageDB: User accounts
06:07:46 <CosmicRay> I'll tell the person that's asking to try both
06:18:14 <dcoutts> CosmicRay: I think it's only Ross
06:18:26 <CosmicRay> ok
06:24:05 <Altair^> what is usually wrong when the compiler says parse error on input where
06:24:29 <pejo> Altair, indentation, or missing things on the line before?
06:24:36 <Altair^> ok
06:25:23 <Altair^> but it seems to be ok
06:26:53 <Altair^> ah, I found it, ty
06:28:48 <Saizan> does Data.ByteString.Lazy.hGet read lazily or not?
06:28:53 <dcoutts> no
06:29:08 <dcoutts> hGetContents is the only lazy read
06:29:09 <Saizan> perfect
06:30:01 <ivanm> so its name is a lie?
06:30:27 <Saizan> it still gives you a .Lazy.ByteString :)
06:31:34 <ivanm> heh
06:34:07 <fasta> Does ghci have an option to do -xc like ghc?
06:34:37 <ivanm> can't you pass parameters to ghci? isn't ghci just "ghc -i" or something?
06:34:44 <dcoutts> ghci == ghc --interactive
06:39:18 <fasta> dcoutts: -xc only works when a program is compiled with ghc
06:39:37 <fasta> dcoutts: it's an option to the RTS, I am not sure how I would communicate that to ghci.
06:40:37 <LoganCapaldo> compile ghci with -xc of course :)
06:41:01 * LoganCapaldo isn't making any sense
06:43:48 <fasta> LoganCapaldo: that probably only works when an exception in ghci is thrown, not in a user program.
06:44:15 <quicksilver> since ghci is, itself, a haskell program compiled with ghc
06:44:20 <quicksilver> you can give it RTS options
06:44:40 <quicksilver> and I think ghci runs its client (user) programs in the same RTS as itself.
06:45:41 <fasta> quicksilver: ok, in that case compiling ghci differently would help.
07:02:26 <astrolabe> Am I allowed to do 'type B = A' and 'type C = B'?
07:02:35 <matthew-_> I think so.
07:03:00 <astrolabe> Must be something else wrong then.
07:04:28 <astrolabe> matthew-_: you're right.  Thanks.
07:04:41 <matthew-_> np
07:05:41 <astrolabe> I've started putting all my   'data...' 'newtype...' and 'type...' at the top of my files.  Does that seem sensible to people?  Anyone else do it?
07:06:12 <byorgey> seems sensible to me, unless there's a ton of them.
07:06:26 <astrolabe> merci
07:07:39 <matthew-_> It depends. I often do that. But I also often have several separate "Types.hs" modules for defining types. depends on the size of the project
07:22:25 <salierix> How do I enable multi-parameter type classes?
07:22:36 <quicksilver> -fglasgow-exts? :)
07:23:28 <quicksilver> {-# LANGUAGE MultiParamTypeClasses -} apparently
07:23:32 <quicksilver> oops, missing #
07:23:37 <quicksilver> {-# LANGUAGE MultiParamTypeClasses #-} apparently
07:23:51 <quicksilver> astrolabe: I would put "private" data decls at the top of the file, yes
07:24:06 <quicksilver> and decls shared between modules in a separate file like matthew-_ says
07:24:19 <quicksilver> together with the functions that operate on them, though
07:35:53 <matthew-_> ok. I think some sort of leadership of hackage would be a good idea. There are multiple libraries that provide the same feature now. Eg utf8 input and output are provided by "encoding", "iconv" and "utf8-string"
07:36:13 <matthew-_> it would be a shame for hackage to become a mess...
07:36:54 <quicksilver> I dunno. Parallel development and competition can produce more interesting results
07:37:05 <matthew-_> "confused users"
07:37:06 <quicksilver> it's not always obvious what the best solution to a problem is.
07:37:13 <matthew-_> that's true.
07:37:44 <doser> There should be stats like number of downloads, or number of packages depending on it
07:37:57 <matthew-_> but I think pointing such things out to the authors of such packages would be a good idea if it means they come together and unify ideas. I don't think Haskeller's are likely to retort with "Mine's better than yours so delete yours"
07:38:15 <matthew-_> s/Haskeller's/Haskellers'/
07:38:16 <Saizan> a list of raccomended packages might be a good idea, as it has been proposed
07:38:20 <quicksilver> oh, yes, communication is good.
07:38:34 <quicksilver> encoding and iconv are different things, AIUI
07:38:43 <quicksilver> utf8-string might be a competitor for encoding
07:38:50 <quicksilver> but you didn't even mention compactstring ;P
07:38:54 <shachaf> matthew-_: s s/'// , as long as you're at it. :-)
07:39:15 <matthew-_> shachaf: oh bother, yes indeed!
07:39:52 <matthew-_> quicksilver: well, iconv uses the iconv C library, encoding does it all in Haskell, and has many encodings, and utf8-string just does for utf8 what encoding does for about 30 encodings
07:40:41 <matthew-_> Saizan: adding a recommended list has dangers - it could create some sort of heirarchy of people who's opinion is more important than others...
07:41:23 <Saizan> well that depends on how you form such a list
07:41:26 <quicksilver> I note that CPAN is a total mess and anarchy
07:41:30 <quicksilver> yet, it still works
07:41:53 <quicksilver> (some people's opinions are more important than others. For example mine is more important than yours!)
07:43:12 <Saizan> we might just have reviews or links to wikipages/blog posts even if it's not so elegant
07:43:41 <quicksilver> building up wisdom on the wiki is good
07:43:50 <quicksilver> reviews/testimonials/examples
07:43:55 <matthew-_> it could be argued that some metrics would be useful - code coverage by test suite, for example
07:45:05 <Philippa> matthew-_: sometimes unification's a bad idea
07:45:12 <Philippa> I don't /want/ the different parsing libs unified, they do different things
07:45:34 <monadonous> I'm trying to install cabal-install, and it says "cabal-install.cabal:24: Invalid syntax (no colon after field name)". That isn't my fault, is it?
07:45:37 <pejo> Philippa, how about one library that does it all instead?
07:45:52 <nominolo> monadonous: probably not
07:45:56 <doser> monadonous: get a new Cabal
07:46:20 <doser> Cabal 1.2.1 to be precise
07:46:20 <nominolo> monadonous: right, cabal-install needs a newer Cabal
07:46:39 <Philippa> pejo: can't be done
07:46:40 <matthew-_> yeah. It's just that last weekend I desperately wanted a utf8 encoding library, so I went to hackage and just did a firefox quicksearch for utf8 so up comes utf8-string. But now, being some calmer, I realise I probably should have used encoding.
07:46:51 <nominolo> monadonous: if you want you can install it separately, you don't need the newest ghc
07:46:53 <monadonous> ah thanks
07:46:57 <Philippa> not in any useful sense
07:47:21 <Philippa> do you want really strong static analysis, or do you want maximum parsing power? They're mutually exclusive
07:47:30 <pejo> Philippa, well. This kind of reminds of the discussion with dons the other day where he wished that all the effort that has gone into different compilers would have gone into a single one instead.
07:47:36 <matthew-_> Philippa: so in that case then it should be clear why they should be separate. But when you're implementing the same thing twice...
07:48:04 <Philippa> sometimes it's not clear libs're going to naturally evolve to the same point as each other
07:48:19 <Philippa> and then you're left arguing about what "the same thing" means
07:48:54 <Philippa> see the multitude of approaches to handling XML, XHTML and HTML for example
07:48:54 <matthew-_> sure sure. I'm not saying that it's terrible and all that, I'm just saying it would be useful if hackage gets checked from time to time for such things.
07:49:13 <opqdonut> easiest way to get ghc 6.8 on debian?
07:49:40 <Heffalump> Igloo posted packages to haskell-unsafe
07:49:47 <Heffalump> @where haskell-unsafe
07:49:47 <lambdabot> I know nothing about haskell-unsafe.
07:50:06 <Heffalump> http://urchin.earth.li/pipermail/debian-haskell/2007-November/000339.html
07:50:08 <lambdabot> Title: [Debian-haskell] GHC 6.8.1 debs, http://tinyurl.com/2gmjux
07:51:34 <opqdonut> thanks!
07:53:52 <quicksilver> furthermore a lot of haskell programming is experimental in some sense
07:54:06 <quicksilver> so someone will put together a library because it's interesting
07:54:13 <quicksilver> arrow-based invertible parsing, say
07:54:39 <LoganCapaldo> @index MonadTrans
07:54:39 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:56:01 <LoganCapaldo> Hey if you define lift do you get liftIO for free?
07:56:21 <idnar> :t liftIO
07:56:23 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:57:46 <LoganCapaldo> in case anyone else was interested, the answer is nope
07:59:55 <Saizan> instance MonadTrans t, MonadIO m => MonadIO (t m) where liftIO = lift . liftIO ? Overlapping at least
08:01:12 <LoganCapaldo> I was thinking less general, like instance (MonadTrans t) => MonadIO (t IO) where liftIO = lift
08:02:02 <LoganCapaldo> but in retrospect you proably wouldn't want that
08:03:24 <quicksilver> well, it overlaps
08:03:32 <quicksilver> that's the problem with schemes like that
08:03:58 <LoganCapaldo> {-# LaunguageDWIM #-} :)
08:03:58 <quicksilver> that instance "applie for all t"
08:04:06 <quicksilver> and then adds a MonadTrans context
08:05:04 <quicksilver> there are ways in which ghc decides between overlapping instances, with appropriate flags, but I've never felt all that happy with them myself
08:06:03 <matthew-_> oh they're fine! It's only incoherent-instances that are really worrying
08:06:06 <matthew-_> :)
08:06:22 <quicksilver> I think overlapping instances go against the spirit of parametricity, myself
08:07:06 <matthew-_> I changing "not type checked code" to "type checked code" is a good thing. ;)
08:08:34 <matthew-_> +think
08:08:34 <LoganCapaldo> matthew-_: I think we all agree about that, it just depends on how you get from A to B right?
08:08:45 <matthew-_> LoganCapaldo: oh sure. I was being "funny"
08:09:03 <quicksilver>  
08:09:22 <quicksilver> matthew-_: you'd love ocamls' -rectypes, then :)
08:09:33 <quicksilver> with rectypes, everything typechecks
08:10:12 <opqdonut> i'm getting a stack overflow with large inputs. -xt -hb shows the stack (TSO) using huge amounts of memory. what would be the best way to track this down?
08:10:23 <opqdonut> i guess unevaluated chunks are accumulating somewhere
08:12:12 <quicksilver> I think a stack overflow is most common when you force a huge thunk
08:12:26 <quicksilver> typical causes are folds building up huge thunks
08:12:36 <quicksilver> and typical solution is strictifying the fold
08:12:47 <opqdonut> yeah i know
08:12:55 <opqdonut> but i've no idea where this could be happening
08:13:17 <opqdonut> can i somehow trace what closures these are or something?
08:13:34 <opqdonut> -hc shows the memory as SYSTEM
08:14:08 <opqdonut> i already strictified some of my data structures with no help
08:14:17 <opqdonut> *and it didn't help
08:14:38 <opqdonut> could this be record updates?
08:14:46 <Saizan> an huge stack means that you're recursing too deep, not that you're allocating too much data, afaiu
08:14:50 <quicksilver> I'm afraid I know nothing about haskell profiling options
08:14:57 <opqdonut> hrmmm
08:15:26 <quicksilver> did you look at http://haskell.org/haskellwiki/Stack_overflow ?
08:15:27 <lambdabot> Title: Stack overflow - HaskellWiki
08:23:42 <opqdonut> wow, i fixed it!
08:23:51 <opqdonut> needed a $! in the correct spot
08:25:10 <opqdonut> seems i had hanging references while recursing thru the input string
08:25:32 <opqdonut> changed the function to force evaluation of the previous step
08:26:24 <Saizan> ehe, a foldl :)
08:26:42 <opqdonut> yes, but an implicit one, that's why i didn't notice it
08:27:04 <opqdonut> the structure of the program was "foldl over input, check final value for condition"
08:27:10 <opqdonut> which of course makes a leak
08:27:36 <opqdonut> guess i should write that as an explicit fold....
08:28:27 <Saizan> it should be quite mechanic
08:28:35 <opqdonut> yep
08:28:40 <LoganCapaldo> @type \f a -> return $ \b -> return (f a b) -- does this function already exist?
08:28:42 <lambdabot> forall t (m :: * -> *) t1 a (m1 :: * -> *). (Monad m, Monad m1) => (t -> t1 -> a) -> t -> m (t1 -> m1 a)
08:28:59 <LoganCapaldo> hmm
08:29:09 <LoganCapaldo> that type is more generally than I expected
08:29:13 <LoganCapaldo> *general
08:29:54 <byorgey> LoganCapaldo: what did you expect?
08:30:16 <LoganCapaldo> @type let g = return in \f a -> g $ \b -> g (f a b) -- more like this
08:30:17 <lambdabot> forall (m :: * -> *) t t1 a. (Monad m) => (t -> t1 -> a) -> t -> m (t1 -> m a)
08:30:38 <byorgey> opqdonut: this is one reason it helps to use recursive combinators in favor of explicit recursion... it helps in identifying such things.
08:31:10 <byorgey> LoganCapaldo: ...isn't that the same?
08:31:20 <opqdonut> byorgey: exactly.
08:31:36 <LoganCapaldo> byorgey: not exactly the same
08:31:46 <byorgey> ah, yes, I see
08:31:54 <byorgey> the same monad as opposed to different monads
08:32:16 <byorgey> @pl let g = return in \f a -> g $ \b -> g (f a b)
08:32:16 <lambdabot> ((return . (return .)) .)
08:32:25 <byorgey> oh, of course! =P
08:32:58 <Saizan> LoganCapaldo: where do you need such a combinator?
08:33:14 <byorgey> I was wondering the same thing.
08:33:44 <LoganCapaldo> well i had this idea
08:34:07 <LoganCapaldo> to "count" the number of operations by counting the number of binds
08:34:27 <LoganCapaldo> So I'd basically want to use >>= as .
08:34:32 <LoganCapaldo> for pure code
08:34:59 <LoganCapaldo> witha  variant of writer that incremented the count everytime  (>>=)
08:35:10 <byorgey> hm, interesting
08:35:11 <LoganCapaldo> but liftM would let you cheat too much
08:35:44 <LoganCapaldo> it's nto going to be a very accurate number of course, but I thought it might be interesting to compare the results of something like bubble sort vs. mergesort, etc.
08:36:01 <sorear> you're breaking the monad laws!
08:36:26 <LoganCapaldo> oops :)
08:37:25 <quicksilver> LoganCapaldo: it's a mistake to think >>= has anything much to do with number of operations, I think
08:37:37 <quicksilver> the internals of actions is private
08:37:45 <LoganCapaldo> yeah i know
08:37:49 <quicksilver> putStr "ab" === putStr "a" >> putStr "b"
08:37:50 <Saizan> i'd use an explicit primitive to increment the counter
08:39:00 <LoganCapaldo> I was just thinking about (dons's?) "overloadable semicolons" expression
08:43:49 <dblhelix> what happened to the ascii art in ghci's sign-on banner?---hi all :)
08:46:46 <kaol> search for "startup banner" on http://haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html
08:46:48 <lambdabot> Title: 1.4. Release notes for version 6.8.1, http://tinyurl.com/3yjyhg
08:47:29 <dblhelix> kaol: that doesn't answer it ;-)
08:48:43 <noteventime> Has anyone read "The Haskell road to Logic, Math and Programming"?
08:49:06 <dblhelix> noteventime: I haven't
08:49:29 <dblhelix> noteventime: but what I've heard from it, it makes for a good read
08:49:37 <noteventime> Thanks :-)
08:50:05 <noteventime> Just making sure that I won't read something despised by the Haskell community :-P
08:51:07 <_cheerios> noteventime, still in ze mail
08:52:09 <noteventime> _cheerios: I beg your pardon? :-)
08:52:34 <_cheerios> (amazon order, should be here by x-mas)
08:53:07 <ZsoL> dblhelix, yes it does
08:53:55 <dblhelix> ZsoL: how does it do?
08:55:11 <dblhelix> ZsoL: ah, sorry, I thought I asked why it did disappear... my bad
08:55:58 <ZsoL> dblhelix, do a search for '.ghci' :-)
08:56:44 <dblhelix> ZsoL: I did find the passage
08:57:04 <ZsoL> okay
09:15:07 <hpaste>  LoganCapaldo pasted "well counting operations mighta been a wash, but I did come up with a bizzare spelling of liftM2" at http://hpaste.org/3788
09:35:36 <nominolo> wow.. a null-pointer reference caused core dump in haskell ...
09:36:31 <Botje> instead of returning Nothing and pinpointing the source location
09:36:49 <Botje> ?
09:36:51 <Botje> shame!
09:37:36 <LoganCapaldo> Nothing + pinpointing source location? Don't you mean Left sourceLocation ?
09:37:38 <SamB_XP> Botje: since when does nothing carry source locations?
09:38:00 <Botje> blah
09:38:08 <Botje> should've said Left :)
09:39:07 <nominolo> gdb gives me a two-entry backtrace
09:39:24 <enzo> I've been scratching my head over this question for a while now, maybe one of you out there can help me. I'm just working on a basic program that takes two lists, who's values are a combination integers and doubles, and returns one list.  My problem is that I can't get the values in the resultant list to come out in any nice format; that is for the list to display the values that are integers as integers and the values that are d
09:39:24 <enzo> oubles as doubles. I've tried [Double] -> [Double] -> [Double], [Integer] -> [Integer] -> [Integer] and [Float] -> [Float] -> [Float]; none of which come out in the format I'm looking for.
09:39:52 <Botje> enzo: you'll have to use your own version of show ..
09:40:45 <pjd> enzo: the list can only really contain one type
09:40:59 <Botje> something like map (\x -> if abs(x - (floor x)) < 0.0001 then show $ floor x else show x)
09:41:17 <Botje> .. over your list of [Double] or [Float]
09:41:52 <enzo> Botje: Gotcha
09:42:27 <Botje> > map (\x -> if abs(x - (floor x)) < 0.0001 then show $ floor x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99 ]
09:42:28 <lambdabot>  Add a type signature
09:43:09 <Botje> mrr? well, you get the point.
09:43:13 <Botje> > map (\x -> if abs(x - (floor x)) < 0.0001 then show $ floor x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99 ] :: [String]
09:43:14 <lambdabot>  Add a type signature
09:43:17 <pjd> enzo: alternatively, you could have a list of Either
09:43:25 <LoganCapaldo> @type floor
09:43:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:43:42 <LoganCapaldo> a != b :)
09:43:45 <LoganCapaldo> x - floor x
09:43:48 <LoganCapaldo> it's confused
09:45:00 <LoganCapaldo> x - fromIntegral (floor x) should do it I think
09:45:28 <int-e> @type round
09:45:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:45:48 <int-e> floor will fail on the 99.99
09:45:54 <pjd> > map (either show show) [Left 5, Right 2.3, Left 42]
09:45:55 <lambdabot>  ["5","2.3","42"]
09:46:01 <LoganCapaldo> > map (\x -> if abs(x - fromIntegral (floor x)) < 0.0001 then show $ floor x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99 ]
09:46:03 <lambdabot>  ["1","1.0e-2","3.14","5","42","99.99"]
09:46:49 <pjd> enzo: like that?
09:47:12 <int-e> > map (\x -> if abs(x - fromIntegral (floor x)) < 0.0001 then show $ floor x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99, 3.99999, 40.00001 ]
09:47:14 <lambdabot>  ["1","1.0e-2","3.14","5","42","99.99","3.99999","40"]
09:47:55 <int-e> > map (\x -> if abs(x - fromIntegral (round x)) < 0.0001 then show $ round x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99, 3.99999, 40.00001 ]
09:47:56 <lambdabot>  ["1","1.0e-2","3.14","5","42","99.99","4","40"]
09:48:08 <enzo> pjd: yes it works!
09:49:13 <pjd> enzo: you could tweak that some more, but the basic idea is there
09:50:14 <pjd> the list is polymorphic: (Num n, Fractional f) => [Either n f]
09:50:32 <pjd> so you can specialize it to any Num and Fractional instance
09:50:35 <enzo> yeah Ideally I'd like to get rid of the quotations but that shouldn't bee too difficult
09:51:36 <LoganCapaldo> > map read $ map (\x -> if abs(x - fromIntegral (round x)) < 0.0001 then show $ round x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99, 3.99999, 40.00001 ]
09:51:38 <lambdabot>  Exception: Prelude.read: no parse
09:51:43 <byorgey> enzo: yes, you can make a newtype for your special Integer/Double list, and make your own show instance that doesn't have the quotes.
09:51:45 <enzo> pjd: I tried that one too but I got a type error
09:52:08 <LoganCapaldo> > map read $ map (\x -> if abs(x - fromIntegral (round x)) < 0.0001 then show $ round x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99, 3.99999, 40.00001 ] :: [Double]
09:52:09 <lambdabot>  [1.0,1.0e-2,3.14,5.0,42.0,99.99,4.0,40.0]
09:52:24 <byorgey> LoganCapaldo: my eyes!
09:52:49 <LoganCapaldo> I'm sure I don't know what you are talking about?
09:52:52 <LoganCapaldo>  :)
09:53:10 <pjd> enzo: well, the quotes are just because it's a list of strings
09:53:41 <Nafai> Man I love how concise and expressive Haskell code is!
09:54:13 <LoganCapaldo> > concat $ intersperse ", " $ map (\x -> if abs(x - fromIntegral (round x)) < 0.0001 then show $ round x else show x) [ 1, 0.01, 3.14, 5, 42, 99.99, 3.99999, 40.00001 ]
09:54:15 <lambdabot>  "1, 1.0e-2, 3.14, 5, 42, 99.99, 4, 40"
09:54:27 <pjd> enzo: for example,
09:54:28 <pjd> > mapM_ (either print print) [Left 5, Right 2.3, Left 42]
09:54:29 <lambdabot>  <IO ()>
09:54:34 <pjd> err
09:54:39 <ZsoL> almost
09:54:39 <ZsoL> ;-)
09:54:44 * LoganCapaldo knew that would happen
09:54:55 <pjd> how do you get lambdabot to IO again
09:55:03 <LoganCapaldo> I think you don't
09:55:03 <byorgey> pjd: you don't.
09:55:09 <pjd> :(
09:55:18 <Botje> try show, instead.
09:55:20 <Botje> no?
09:55:24 <pjd> enzo: well, do that in ghci
09:55:26 <byorgey> pjd: because then you could HACK DONS' SERVER!
09:55:32 <pjd> Botje: yeah, that's what i had before
09:56:12 <LoganCapaldo> > mapM_ (join either print) [Left 5, Right 2.3, Left 42] -- not really shorter
09:56:14 <lambdabot>  <IO ()>
09:56:29 <vincenz> lambdabot: one character
09:57:10 <vincenz> @djinn (a->b) -> (Either a a) -> b
09:57:10 <lambdabot> f a b =
09:57:10 <lambdabot>     case b of
09:57:10 <lambdabot>     Left c -> a c
09:57:10 <lambdabot>     Right d -> a d
09:57:52 <pjd> vincenz: those are different instances of show, though
09:58:13 <pjd> would it work like that?
09:58:35 <LoganCapaldo> > let intercalate s ss = concat $ instersperse s ss in intercalate ", " $ map (join either show) [Left 5, Right 2.3, Left 42]
09:58:36 <lambdabot>   Not in scope: `instersperse'
09:58:48 <LoganCapaldo> > let intercalate s ss = concat $ intersperse s ss in intercalate ", " $ map (join either show) [Left 5, Right 2.3, Left 42]
09:58:50 <lambdabot>  "5.0, 2.3, 42.0"
09:59:02 <LoganCapaldo> guess not
09:59:28 <LoganCapaldo> > let intercalate s ss = concat $ intersperse s ss in intercalate ", " $ map (either show show) [Left 5, Right 2.3, Left 42]
09:59:29 <lambdabot>  "5, 2.3, 42"
09:59:46 <LoganCapaldo> I demand more polymorphism! :)
10:00:06 <byorgey> yeah, using join like that is in the ((->) r) monad, so r always has to be the same type
10:00:37 <LoganCapaldo> or maybe I demand less polymorphism
10:00:43 <LoganCapaldo> not sure anymore
10:00:54 <byorgey> I think you just demand more DWIM-ism.
10:01:08 <idnar_> > mapM_ (either show show) [Left 5, Right 2.3, Left 42]
10:01:09 <lambdabot>  [(),(),(),(),(),()]
10:01:33 <LoganCapaldo> interesting choice
10:01:51 <idnar_> > mapM_ (either show show) [Left 5, Right 2.3, Left 42] :: [String]
10:01:52 <lambdabot>  Couldn't match expected type `String' against inferred type `()'
10:02:00 <byorgey> but... why are there six!?
10:02:03 <idnar_> I guess I'm missing something
10:02:15 <LoganCapaldo> idnar: why are you using mapM-?
10:02:19 <LoganCapaldo> @type mapM_
10:02:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:02:47 <idnar> yeah, I guess that doesn't make much sense
10:02:58 <salierix> Hmm, the State monad is actually pretty clever...
10:02:59 <byorgey> oh, it's using the list monad!  "52.342" is six characters =)
10:03:09 <idnar> where do the () come from?
10:03:16 <byorgey> the _ in mapM_
10:03:22 <idnar> oh yes, obviously
10:03:22 <LoganCapaldo> well mapM_ does a return () basically
10:03:28 <LoganCapaldo> and in the list monad...
10:03:31 <idnar> I think I need some coffee
10:03:36 <idnar> > mapM (either show show) [Left 5, Right 2.3, Left 42] :: [String]
10:03:38 <lambdabot>  ["524","522","5.4","5.2","534","532"]
10:03:43 <idnar> heehee
10:03:48 <opqdonut> :D
10:03:54 <opqdonut> excellent
10:04:04 <byorgey> ohhhhh now I get it... haha!
10:04:05 <idnar> that's some crazy code
10:04:15 <salierix> I've found that all written descriptions of the State monad are piss poor though.
10:04:49 <opqdonut> when i finally used it, i didn't need an explanation
10:05:03 <Lemmih> @seen Igloo
10:05:03 <lambdabot> Igloo is in #ghc, #darcs and #haskell. I last heard Igloo speak 16h 50m 30s ago.
10:05:20 <vincenz> pjd: uh?
10:05:48 <LoganCapaldo> vincenz: misdirected message
10:05:55 <LoganCapaldo> he was talking to me I think
10:05:55 <vincenz> LoganCapaldo: yeah, me to you too
10:06:01 <vincenz> I tabcompleted lambdabot
10:06:34 <idnar> > map (join either show) [Left 5, Right 2.3, Left 42]
10:06:36 <lambdabot>  ["5.0","2.3","42.0"]
10:08:09 <pjd> LoganCapaldo: i was talking to vincenz too, re. the djinn output
10:08:16 <vincenz> pjd: that has nothing to do with 'show'
10:08:38 <vincenz> I was just checking if lambdabot was smart enough to turn that into some short code without a case
10:09:14 <idnar> @. @pl @djinn (a->b) -> (Either a a) -> b
10:09:14 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
10:09:18 <pjd> vincenz: well, it's basically join either
10:09:35 <vincenz> nod
10:09:37 <idnar> @. pl djinn (a->b) -> (Either a a) -> b
10:09:37 <lambdabot> (line 3, column 12):
10:09:37 <lambdabot> unexpected ">" or "-"
10:09:37 <lambdabot> expecting variable, "(", operator or end of input
10:09:54 <vincenz> I doubt pl does case
10:10:00 <idnar> yeah, I guess not
10:10:10 <vincenz> @pl case True of True -> 1 | False -> 2
10:10:10 <lambdabot> (line 1, column 19):
10:10:10 <lambdabot> unexpected ">" or "-"
10:10:10 <lambdabot> expecting variable, "(", operator or end of input
10:10:20 <vincenz> @pl \x -> {case x of True -> 1 | False -> 2}
10:10:20 <lambdabot> (line 1, column 7):
10:10:20 <lambdabot> unexpected "{"
10:10:20 <lambdabot> expecting lambda abstraction or expression
10:10:31 <vincenz> @pl \x -> case x of True -> 1 | False -> 2
10:10:31 <lambdabot> (line 1, column 22):
10:10:31 <lambdabot> unexpected ">" or "-"
10:10:31 <lambdabot> expecting variable, "(", operator or end of input
10:10:37 <vincenz> oh well
10:10:42 <byorgey> shouldn't that be ; instead of | ?
10:10:44 <LoganCapaldo> s/|/;/
10:10:49 <vincenz> point
10:10:55 <vincenz> @pl \x -> case x of True -> 1 ; False -> 2
10:10:55 <lambdabot> (line 1, column 22):
10:10:55 <lambdabot> unexpected ">" or "-"
10:10:55 <lambdabot> expecting variable, "(", operator or end of input
10:11:01 <vincenz> but it doesn't like the ->
10:11:23 <byorgey> @pl \x -> case x of { True -> 1 ; False -> 2 }
10:11:23 <lambdabot> (line 1, column 17):
10:11:24 <lambdabot> unexpected "{"
10:11:24 <lambdabot> expecting variable, "(", operator or end of input
10:11:25 <LoganCapaldo> @pl \x -> case x of { True -> 1 ; False -> 2 }
10:11:25 <lambdabot> (line 1, column 17):
10:11:25 <lambdabot> unexpected "{"
10:11:25 <lambdabot> expecting variable, "(", operator or end of input
10:11:33 <byorgey> doh =)
10:13:55 <LoganCapaldo> I want a magical type class ChurchEncodable or some such that when you deriving-ed it it would define a function churchenc such that for Either it would be either, for Maybe it would be maybe, etc., etc.
10:14:26 <LoganCapaldo> I think that would need depedendant types or other such nonsense though, but that's why it would be magical! :)
10:15:33 <allbery_m> doesn't it just need @djinn built into ghc?
10:15:47 <LoganCapaldo> yeah I guess
10:15:56 <idnar> heh
10:15:59 <Saizan_> class ChurchEncodable t enc | t -> enc where churchenc :: t -> end
10:16:02 <LoganCapaldo> But I mean what would the type of churchenc be without magic?
10:16:21 <Saizan_> s/end/enc/
10:17:11 <LoganCapaldo> Saizan_: that'll work? All you need is MPTCs?
10:17:18 <LoganCapaldo> and fundeps?
10:17:33 <vincenz> LoganCapaldo: not the auto-deriving bit
10:17:37 <vincenz> you'll have to roll em yourself
10:17:44 <LoganCapaldo> yeah i know
10:18:04 <Saizan_> yes, but it wouldn't be so nice to use, because you can't do anything with enc until you know t
10:18:14 <LoganCapaldo> mmm
10:19:09 <Saizan_> but as a replace for either, maybe, etc.. it will work
10:19:19 <Saizan_> modulo order of arguments
10:20:04 <LoganCapaldo> hmm
10:20:10 <LoganCapaldo> @type maybe
10:20:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:20:27 <sven_> hi
10:21:05 <sven_> is there a way to only let positiv numbers be the parameters of a function?
10:21:42 <Heffalump> you could use some unsigned type like Word32
10:22:15 <LoganCapaldo> @instance Num Word32
10:22:16 <lambdabot> Maybe you meant: instances instances-importing
10:22:22 <LoganCapaldo> @instances Num Word32
10:22:23 <lambdabot> Couldn't find class `Num Word32'. Try @instances-importing
10:22:35 <LoganCapaldo> nvm
10:22:41 <byorgey> sven_: what exactly do you want to do?
10:22:51 <sven_> hm thanks, but isn't it posible to just say "this function takes an int, which must be larger than 0" ?
10:22:57 <allbery_m> @instances-importing Data.Word Num Word32
10:22:58 <lambdabot> Couldn't find class `Word32'. Try @instances-importing
10:23:03 <allbery_m> durr
10:23:05 <LoganCapaldo> f (n+0) = ... :)
10:23:07 <sven_> byorgey: I want to write a function with 2 parameters which must be larger than 0
10:23:07 <allbery_m> @instances-importing Data.Word Num
10:23:08 <lambdabot> Double, Float, Int, Integer, Word, Word16, Word32, Word64, Word8
10:23:27 <LoganCapaldo> or f x y | x > 0 && y > 0 = ...
10:23:28 <allbery_m> haskell doesn't have dependent types, so you can't describe that constraint in the type system
10:23:43 <vincenz> you can error
10:23:45 <allbery_m> you can use guards to throw exceptions on negative arguments tough
10:23:50 <vincenz> f x y | x > 0 && y > 0 = ...
10:23:56 <vincenz>       | otherwise = error "..."
10:23:56 <sven_> ok, guards sounds good, thank you :)
10:24:22 <LoganCapaldo> vincenz: you don't need the otherwise right? It'll just fial with an non-ehaustive blah blah error
10:24:32 <vincenz> LoganCapaldo: true but you can give it a more meaningful error
10:24:36 <dcoutts> @Yarr!
10:24:36 <lambdabot> Maybe you meant: arr yarr
10:24:37 <dcoutts> cabal-install rocks.
10:24:43 <dcoutts> @yarr!
10:24:44 <lambdabot> I'll keel haul ya fer that!
10:24:48 <dcoutts> lambdabot: happy now?
10:25:12 * lambdabot licks dcoutts
10:25:19 <byorgey> @aft!
10:25:19 <dcoutts> hah hah hah
10:25:20 <lambdabot>  There was an error in the type: (line 1, column 1):
10:25:21 <lambdabot>  unexpected "<"
10:25:21 <lambdabot>  expecting "forall" or a simple type term
10:26:25 <LoganCapaldo> Or you coud define the function like f x = g (sqrt x ** 2) where g = ... actual function ... :p
10:26:56 <Saizan_> sqrt (x**2)?
10:27:23 <LoganCapaldo> what sqrt doesn't do complex?
10:27:42 <Saizan_> mmh
10:27:42 <byorgey> > (sqrt (-3) ** 2)
10:27:44 <lambdabot>  NaN
10:27:45 <allbery_m> only if you import Data.Compelx
10:28:00 <Saizan_> > sqrt (-1) :: Complex Double
10:28:01 <lambdabot>  -0.0 :+ 1.0
10:28:05 <LoganCapaldo> well it;s a good thing that wasn't a serious suggestion :)
10:28:27 <vincenz> LoganCapaldo: why not (max x (-x))
10:28:41 <LoganCapaldo> why not abs?
10:28:44 <vincenz> hah
10:28:48 <vincenz> abs is for the weak
10:28:56 <vincenz> @type abs
10:28:57 <lambdabot> forall a. (Num a) => a -> a
10:29:00 <vincenz> @type max
10:29:01 <lambdabot> forall a. (Ord a) => a -> a -> a
10:29:13 <LoganCapaldo> vincenz: actually I might do max 0 x
10:29:21 <vincenz> either way, it forces it to num :|
10:29:58 <LoganCapaldo> well there's no concept of negative outside of Num right?
10:30:03 <LoganCapaldo> @type negate
10:30:03 <vincenz> nope
10:30:04 <lambdabot> forall a. (Num a) => a -> a
10:30:07 <vincenz> nor of 0
10:30:23 <LoganCapaldo> well mzero, mempty...
10:30:27 <LoganCapaldo> maybe
10:30:38 <vincenz> LoganCapaldo: that's not 0
10:30:48 <vincenz> and I doubt mzero == 0 for Num
10:30:52 <vincenz> > mzero :: Int
10:30:52 <lambdabot>  Couldn't match expected type `Int' against inferred type `m a'
10:31:00 <vincenz> > mempty :: Int
10:31:01 <lambdabot>   add an instance declaration for (Monoid Int)
10:31:01 <lambdabot>     In the expression: mempty
10:31:01 <lambdabot> ...
10:31:08 <LoganCapaldo> > memty :: Sum Int
10:31:08 <lambdabot>   Not in scope: `memty'
10:31:14 <LoganCapaldo> > mempty :: Sum Int
10:31:15 <lambdabot>  Sum {getSum = 0}
10:31:41 <LoganCapaldo> you're definitely right about mzero though
10:32:00 <Saizan_> ?where hsc2hs
10:32:01 <lambdabot> I know nothing about hsc2hs.
10:32:15 <Saizan_> shouldn't it come with ghc?
10:33:11 <LoganCapaldo> > mempty :: Product Int -- not zero
10:33:13 <lambdabot>  Product {getProduct = 1}
10:37:56 <Nucleo_> is Manuel Chakravarty's  6.8.1 distribution package the latest & greatest for OS X?
10:38:13 <Nucleo_> I don't see any mentions of binary packages on the official pages yet...
10:42:24 <newsham> where are the notes on updating packages for ghc-6.8.1 in backwards compatible way?
10:43:26 <dons> on the wiki. and in the ghc release notes
10:43:26 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:45:14 <dons> ?ow
10:45:14 <lambdabot> Barbie says, Take quaaludes in gin and go to a disco right away!
10:45:14 <lambdabot> But Ken says, WOO-WOO!!  No credit at "Mr. Liquor"!!
10:45:24 <dons> lovely
10:45:51 <enzo> >(head(tail [1,2,3]))*(head(tail(tail [1,2,3])))-(head(tail(tail [1,2,3])))*(head(tail [1,2,3]))
10:46:09 <idnar> ow, my eyes
10:46:26 <dons> ?pl (head(tail [1,2,3]))*(head(tail(tail [1,2,3])))-(head(tail(tail [1,2,3])))*(head(tail[1,2,3]))
10:46:26 <lambdabot> 0
10:46:35 <pjd> haha
10:46:37 <dons>  @pl is smart
10:47:01 <ddarius> @pl head [1,2]
10:47:01 <lambdabot> 1
10:47:05 <enzo> How can I get Lambabot to simplify
10:47:09 <ddarius> @pl tail [1,2]
10:47:10 <lambdabot> [2]
10:47:15 <dons> use ?pl and lift out variables
10:47:30 <hpaste>  gwern pasted "What's a better way to handle the emty list?" at http://hpaste.org/3789
10:47:36 <ddarius> @pl head []
10:47:37 <lambdabot> head []
10:47:39 <dons> ?pl \s -> (head(tail s))*(head(tail(tail s)))-(head(tail(tail s)))*(head(tail s))
10:47:40 <lambdabot> ap ((-) . ap ((*) . head . tail) (head . tail . tail)) (ap ((*) . head . tail . tail) (head . tail))
10:47:50 <idnar> dons: he said "simplify"
10:47:53 <idnar> *duck*
10:48:09 <enzo> =]
10:48:20 <gwern> so, my question is pretty straight forward. any better way to handle an empty list argument other than calling error?
10:48:22 <dons> ?pl \s -> let f = head . tail in (f s))*( f (tail s)))-(f (tail s)))*(f s))
10:48:22 <lambdabot> (line 1, column 35):
10:48:22 <lambdabot> unexpected ")"
10:48:22 <lambdabot> expecting variable, "(", operator or end of input
10:48:56 <dons> gwern: its hard, isn't it, when constructing a pair
10:49:04 <gwern> yeah.
10:49:07 <dons> gwern: I suggest lifting into Maybe
10:49:19 <dons> to signal error. since error itself is pretty bad for your code quality
10:49:23 <gwern> you can't return (0, []). because then it's not you know a [a]
10:49:41 <gwern> but you can't return (0, [a]) because that requires more information than was passed in...
10:49:45 <dons> so its lengthHead ?
10:50:11 <dons> > length *** head $ "haskell"
10:50:12 <lambdabot>  Couldn't match expected type `([a], [a1])'
10:50:15 <gwern> pretty much, but it's being mapped
10:50:25 <ddarius> &&&
10:50:33 <dons> > length &&& head $ "haskell"
10:50:35 <lambdabot>  (7,'h')
10:50:36 <dons> quite so
10:50:42 <gwern> filter for not null, sort, group and than map pairLength
10:50:46 <idnar> > length &&& head $ []
10:50:48 <lambdabot>  Exception: Prelude.head: empty list
10:50:53 <dons> map (length &&& head) :)
10:51:01 <dons> gwern: sounds like rle ?
10:51:13 <gwern> dons: rle? what is that?
10:51:15 <ddarius> dons: sort
10:51:24 <dons> ah
10:51:25 <pjd> > (,) <$> length <*> head $ "haskell"
10:51:26 <lambdabot>  (7,'h')
10:51:35 <dons> gwern: http://cgi.cse.unsw.edu.au/~dons/blog/2007/07
10:51:36 <lambdabot> Title: Haskell hacking
10:51:43 <idnar> :t group
10:51:44 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
10:51:54 <dons> > map (length &&& head) . group $ "haskell"
10:51:56 <lambdabot>  [(1,'h'),(1,'a'),(1,'s'),(1,'k'),(1,'e'),(2,'l')]
10:51:59 <gwern> dons: oh, no. it's actually your parallel quickcheck library
10:52:21 * gwern is doing the -Wall thing. I find it educational and kind of constructive
10:52:45 <idnar> what does the latter look like in applicative syntax?
10:53:17 <gwern> my hope is to understand how pqc works and then find a simple way to make quickcheck parallel by default, since that'd be nice
10:53:30 <dons> right. that's a medium term goal for QC2
10:53:34 <dons> is fine grained task parallelism
10:53:41 <dons> bringert's written some notes on it
10:53:50 <gwern> link?
10:53:55 <dons> oh, you'll have to ask him
10:54:15 <gwern> as I said yesterday, I didn't see what was so hard about making it more parallel. money, meet mouth...
10:54:58 <dons> well, there's lots of potential parallelism
10:55:18 <dons> pqc does a pretty good job, imo
10:55:26 <dons> assuming jobs cost about the same
10:55:50 <hpaste>  newsham pasted "cabal error help" at http://hpaste.org/3790
10:56:11 <pejo> dons, speaking of QC - did you write that blog post about it yet? :-)
10:56:25 <hpaste>  LoganCapaldo annotated "What's a better way to handle the emty list?" with "if fst is 0 just don't peek at snd" at http://hpaste.org/3789#a1
10:56:27 <newsham> also why does Cabal.cabal use "small_base" but dcoutts email uses splitBase?
10:56:46 <dcoutts> newsham: it makes no difference whatsoever
10:56:53 <dcoutts> the flag names are not significant
10:57:00 <newsham> dcoutts: "cabal error help" at http://hpaste.org/3790
10:57:03 <gwern> dons: yes, but it's not by default. one could do quickcheck parallel *now*, with your pqc, sure, but who's really going to download it, install, figure out how to use it etc.? getting qc parallel by default is the only realistic way people will make use of it
10:57:16 <newsham> probably super obvious error
10:57:36 <dcoutts> newsham: the if needs to be inside a library/executable section
10:57:49 <b_jonas> does 'if a then b else c $ d' parse as 'if a then b else (c $ d)' or as '(if a then b else c) $ d'?
10:58:10 <dons> gwern: oh, i do. we plan to add it to QC2 in short time
10:58:28 <gwern> so, xss@(xs:_) translates to a list [xss,xs,....]?
10:58:42 <LoganCapaldo> > if True then id else id $ 7
10:58:43 <lambdabot>   add an instance declaration for (Num (a -> a))
10:58:43 <dons> no?
10:58:56 <allbery_m> no, xss is the whole list, xs is its head
10:59:00 <dcoutts> gwern: no xss=[xs, ...]
10:59:02 <LoganCapaldo> b_jonas: the second apparently
10:59:08 <dons> > let a@(h:_) = a ++ [h] in "haskell"
10:59:09 <lambdabot>  "haskell"
10:59:13 <LoganCapaldo> err first I mean
10:59:18 <LoganCapaldo> not second :)
10:59:20 <dons> > let f a@(h:_) = a ++ [h] in f "haskell"
10:59:21 <lambdabot>  "haskellh"
10:59:40 <dons> :t let f a@(h:_) = a ++ [h] in a
10:59:41 <lambdabot> Not in scope: `a'
10:59:43 <dons> :t let a@(h:_) = a ++ [h] in a
10:59:45 <lambdabot> forall t. [t]
10:59:57 <newsham> danke dcoutts
11:00:14 <gwern> ok, so 'xss' is the entire list; 'xss = [xs,...]' then, if I understand y'all?
11:00:19 <idnar> gwern: right
11:00:20 <gwern> (what a confusing notation)
11:00:20 <dons> :t fix (\xs -> xs ++ head xs)
11:00:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:00:22 <lambdabot>       Expected type: [a]
11:00:22 <lambdabot>       Inferred type: a
11:00:58 <monochrom> Would you like xs ++ [head xs] ?
11:01:10 <dons> :)
11:01:15 <dons> i've not had my coffee yet.
11:01:17 <b_jonas> LoganCapaldo: that error would actually show that it parses the first way
11:01:28 <LoganCapaldo> WHich is why I corrected myself
11:01:35 <b_jonas> oh ok
11:01:45 <b_jonas> ok, thanks
11:01:58 <gwern> > pairLength xs = (length xs, head xs)
11:01:58 <lambdabot>  Parse error at "=" (column 15)
11:02:04 <gwern> > let pairLength xs = (length xs, head xs)
11:02:04 <lambdabot>  Parse error at end of input
11:02:23 <gwern> bleh. I'll just use ghci then
11:02:27 <monochrom> (length xs, head (xs ++ [undefined]))
11:03:38 <LoganCapaldo> > let pairLength xs = (length xs, head xs) in case pairLength [] of (0, _) -> "Would've been an error ; (n,xs) -> "Fine"
11:03:38 <lambdabot>  Improperly terminated string at """ (column 118)
11:03:44 <LoganCapaldo> > let pairLength xs = (length xs, head xs) in case pairLength [] of (0, _) -> "Would've been an error" ; (n,xs) -> "Fine"
11:03:45 <lambdabot>  "Would've been an error"
11:03:58 <salierix> Dealing with random numbers sure is a pain.
11:04:03 <LoganCapaldo> > let pairLength xs = (length xs, head xs) in case pairLength [1,2,3] of (0, _) -> "Would've been an error" ; (n,xs) -> "Fine"
11:04:04 <lambdabot>  "Fine"
11:04:13 <monochrom> There is no pain.
11:04:27 <LoganCapaldo> gwern: it won't actually exploded until you "look" at the value
11:04:44 <gwern> hm. that's unfortunate. using the &&& definition or LoganCapaldo's definition stop ghc from complaining about unmatched patterns, but they both still error on empty lists. so it trades one error for another
11:04:45 <monochrom> Alternatively, C. S. Lewis's The Problem of Pain is a good read on pain.
11:05:06 <gwern> monochrom: really? I read some of that and threw it away in digust
11:05:08 <LoganCapaldo> > let pairLength xs = (length xs, head xs) in case pairLength [1,2,3] of (0, _) -> [] ; (n,xs) -> [xs]
11:05:10 <lambdabot>  [1]
11:05:17 <LoganCapaldo> > let pairLength xs = (length xs, head xs) in case pairLength [] of (0, _) -> [] ; (n,xs) -> [xs]
11:05:18 <lambdabot>  []
11:05:49 <monochrom> Then you will also have to throw me away in disgust. :)
11:06:22 <gwern> lewis was terrible as a philosopher. I do hope you're better
11:06:25 <enzo> OMG This is driving me up the wall. Can someone explain to me why there is no type signature call "Real" that simply includes all real numbers!?!? All this differentiating between Integers double, it drives me insane !!
11:06:48 <enzo> *integers & Doubles
11:07:01 <LoganCapaldo> @quote fromIntegral
11:07:02 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:07:32 <gwern> enzo: anything wrong with Floats for your purposes?
11:07:32 <monochrom> Scheme has an elaborate hierarchy of number types.
11:08:22 <newsham> I have decided (hear ye!) that part of the perf problem is that people run out and grab C bindings for lots of low layer libraries.  If someone wrote some of the hard stuff like crypto in Haskell, and it turned out to be embarrasingly slow that would get people motivated to make it go faster.
11:08:39 <newsham> thats my overstepping my pay scale comment for Nov.
11:08:48 <gwern> newsham: so, is haskell prime removing the ffi facilities? :)
11:08:53 <enzo> gwern: Well for what I'm doing they act in the same way doubles do so yes
11:08:58 <dons> newsham: data structures usually push the compiler authors though. things like ndp and bytestring led to big improvements.
11:09:08 <dons> newsham: its probably worse in the ruby/python world though.
11:09:15 <dons> at least we talk about beating C
11:09:23 <newsham> I dont think performance is on the radar for python.
11:09:26 <newsham> nor should it be
11:09:30 <byorgey> enzo: but what drives one even more insane is having titchy very-hard-to-track-down numeric errors in languages that try to shield you from the difference, and end up doing weird things behind your back.
11:10:01 <dons> people use python for high perf numerics though, which is the scary thing.
11:10:05 <newsham> dons: *nod* if someone saw a real world implementation of something like crypto they might get interesting data structure ideas on how to make it go fast
11:10:19 <newsham> ie. implementations that need speed == playground for the phd students
11:10:24 <byorgey> enzo: what exactly are you doing for which you need Integers and Doubles intermixed so much?
11:10:29 <dons> yep
11:10:34 <gwern> :t ""
11:10:35 <lambdabot> [Char]
11:10:52 <gwern> if "" is a list of one Char, then what is that Char?
11:10:54 <LoganCapaldo> :t "" :: (IsString s) => s
11:10:55 <lambdabot>     Not in scope: type constructor or class `IsString'
11:11:02 <shachaf> gwern: It's not.
11:11:04 <monochrom> In Scheme, (/ 1 2) is a rational, (/ 2 2) is an intger. To further my horror, (* 2 (/ 1 2)) is an integer, and it is even smart enough to give (sqrt 4) an integer. I'm astonished.
11:11:06 <LoganCapaldo> "" is not a list of one char
11:11:12 <LoganCapaldo> its a list of no chars
11:11:18 <dons> newsham: it is also your duty to report as a bug any not-C performance from C-like code
11:11:18 <shachaf> gwern: It's a list of 0 chars.
11:11:21 <shachaf> > "" == []
11:11:23 <lambdabot>  True
11:11:25 <byorgey> gwern: no, [Char] doesn't mean "a list of one char", it means "a list which can hold (any number of) things of type Char".
11:11:28 <enzo> byorgey: yes this is true. .... I can't get my program to return a list of intermixed Integers and Doubles
11:11:33 <shachaf> @ty ([] `asTypeOf` "")
11:11:34 <lambdabot> [Char]
11:11:34 <salierix> I don't think I'm using the State monad correctly ;)
11:11:40 <newsham> dons:  I will have to write some first.  but good point.
11:11:52 <byorgey> enzo: my question is, why do you *want* a list of intermixed Integers and Doubles?
11:11:52 <ddarius> byorgey: Why not just use Doubles?
11:11:53 <gwern> :t []
11:11:54 <lambdabot> forall a. [a]
11:12:15 <gwern> :t "" == []
11:12:16 <lambdabot> Bool
11:12:41 <gwern> (I guess I don't understand this polymorphic stuff too well then)
11:12:54 <enzo> byorgey: so when I look at the list it's more aesthetically pleasing.
11:12:56 <salierix> I'm thinking the best way to deal with random number is to just use randomRIO instead of randomR
11:12:57 <byorgey> ddarius: because I hate floating-point, so I never use Doubles at all. =)
11:13:01 <shachaf> gwern: [] is a list of values of any type.
11:13:03 <LoganCapaldo> "" is jsut a fancy, char specific way of writing []
11:13:07 <shachaf> gwern: (The same type.)
11:13:19 <shachaf> gwern: "" is a list of Chars.
11:13:25 <LoganCapaldo> "abc" is jsut a fancy char specific way of writing ['a','b','c']
11:13:30 <shachaf> gwern: Which happens to be empty.
11:13:42 <newsham> salierix: you could also use randomRs
11:13:48 <allbery_m> @wiki New_monads/MonadRandom
11:13:49 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
11:13:51 <LoganCapaldo> :t "abc"
11:13:52 <lambdabot> [Char]
11:13:53 <shachaf> LoganCapaldo: Is there a non-Char-specific-way of writing ['a','b','c']? :-)
11:14:03 <byorgey> enzo: ok.  and where are the numbers in the list coming from -- do you know which ones are Integers and which ones are not?  or is it just that you want to show whichever numbers happen to come out close to an integer without a decimal point?
11:14:06 <LoganCapaldo> shachaf: I'm trying to help! shush you! :)
11:14:24 <monochrom> I use randomRs. I can do stream programming.
11:14:26 <allbery_m> shachaf: 'a':'b':'c':[] ?
11:14:26 <salierix> newsham, then I have to pass around the returned generator.
11:14:31 <newsham> Random.split is also useful for recursion
11:14:37 <byorgey> enzo: you might also consider using the Rational type, with a specialized Show instance.
11:14:43 * allbery_m short on sleep and smartalecky today
11:14:57 <newsham> whats wrong with passing things around?
11:15:02 <shachaf> allbery_m: That's still Char-specific.
11:15:05 <olsner> > map toEnum [97,98,99] `asTypeOf` ""
11:15:06 <lambdabot>  "abc"
11:15:41 <allbery_m> only insofar as I used Chars
11:15:46 <shachaf> olsner: Still Char-specific, because of the asTypeOf.
11:15:58 <shachaf> allbery_m: But you did use Chars. :-)
11:16:07 <allbery_m> hard to substitute non-Chars into "xxx" (ignore the IsString silliness for ByteStrings for a moment...)
11:16:08 <salierix> I'm trying to use the State monad but that is turning out to be pretty useless.
11:16:15 <LoganCapaldo> :t map toEnum [97..99]
11:16:17 <lambdabot> forall a. (Enum a) => [a]
11:16:42 <shachaf> allbery_m: Any reasons you're _m, by the way?
11:17:01 <monochrom> IIRC, beginning with 6.8.1 there is a "stream like" type class and associated library functions. It takes "s -> (a,s)" functions and turns them into lists/streams. There are other conveniences. Random fits this framework very well.
11:17:07 <shachaf> LoganCapaldo: That's not writing ['a','b','c'].
11:17:16 <allbery_m> my desktop on campus with the vnc session I normally use has decided to be broke, so I'm using my mac desktop at home
11:17:23 <allbery_m> *broken
11:17:31 <shachaf> allbery_m: You can still /nick allbery_b, no?
11:17:36 <LoganCapaldo> It's a way of writing something that includes ['a', 'b', 'c'] :)
11:18:01 <enzo> byorgey: I have no idea which ones are integers and which ones are not, just that they are all real numbers. I want my list to show whichever values happen to be integers and whichever values happen to be doubles.
11:18:28 <allbery_m> I could but I'll be leaving this session up[ when I next reboot and restart the vnc session (oon the pessimistic assumtpion it'll fall over within hours again...)
11:18:37 <Porges> :t isIntegral = (==0) . snd . properFraction
11:18:39 <lambdabot> parse error on input `='
11:18:44 <shachaf> enzo: So your only problem is the display?
11:18:45 <newsham> dons: what about the MD5 function http://sequence.complete.org/node/367?  6x slower than C
11:18:47 <lambdabot> Title: md5 :: LazyByteString -> MD5Ctx | The Haskell Sequence
11:18:48 <Porges> @let isIntegral = (==0) . snd . properFraction
11:18:55 <lambdabot> Defined.
11:18:55 <byorgey> enzo: ok, so using [Either Integer Double] is out.  the Rational idea might still work.  Where exactly are these numbers coming from?  Are you calculating them, or getting them from some source of input?
11:19:08 <LoganCapaldo> :t properFraction
11:19:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
11:19:22 <LoganCapaldo> ah
11:19:45 <newsham> oh you already saw it nevermind
11:20:00 <dons> newsham: see his mail, he improved it to 2x with a couple of small changes
11:20:03 <olsner> > properFraction pi
11:20:04 <lambdabot>  (3,0.14159265358979312)
11:20:05 <newsham> awesome
11:20:12 <dons> it will hit code generation issues eventually, but that's pretty good
11:20:14 <newsham> i'm a little backlogged on cafe
11:20:26 <newsham> i dont know how people keep up with this thing
11:20:30 <olsner> > (properFraction . snd . properFraction) pi
11:20:32 <lambdabot>  (0,0.14159265358979312)
11:20:47 <enzo> byorgey: I'm doing some web programming so it really depends on what the user enters in
11:21:37 <LoganCapaldo> eh just use strings :)
11:21:43 <enzo> Shachaf: thats right my problem is in the display
11:21:54 <dcoutts> newsham: we only look at the interesting threads, that's how
11:22:14 <monochrom> Hrm! I can't find what I said.
11:22:28 <LoganCapaldo> > printf "%f" 3.2
11:22:28 <lambdabot>  Add a type signature
11:22:32 <LoganCapaldo> > printf "%f" 3.2 :: String
11:22:33 <enzo> byorgey: Since a list can only be in one type, I can't find a solution to my problem..
11:22:33 <lambdabot>  "3.2"
11:22:38 <LoganCapaldo> > printf "%f" 3.0 :: String
11:22:39 <lambdabot>  "3.0"
11:22:45 <LoganCapaldo> > printf "%.0f" 3.0 :: String
11:22:47 <lambdabot>  "3"
11:22:51 <LoganCapaldo> > printf "%.0f" 3.2 :: String
11:22:52 <lambdabot>  "3"
11:22:55 <LoganCapaldo> eh
11:23:06 <newsham> dcoutts: i try that too and usually only get about the first 3 msgs of an interesting thread before i get time pressure
11:23:07 <shachaf> enzo: Why not just keep this to the display?
11:23:20 <byorgey> enzo: oh, I see.  well, perhaps what you want to do is create your own new type which can hold either an Integer or a Double.  When the user enters some input, first check whether it contains a period -- if so, parse it as a Double, otherwise as an Integer.
11:23:20 * ddarius has 227 unread messages from Haskell-Cafe
11:23:32 <shachaf> enzo: The list is a list of Doubles, right?
11:23:48 <LoganCapaldo> > printf "%f" 3.2 :: String
11:23:49 <lambdabot>  "3.2"
11:23:53 <LoganCapaldo> > printf "%f" 3.0 :: String
11:23:55 <lambdabot>  "3.0"
11:24:02 <LoganCapaldo> I think I tried that already
11:24:02 <byorgey> enzo: then you can define arithmetic on your new type such that arithmetic between two Integers is still an Integer, otherwise it becomes a Double.
11:24:21 <monochrom> It can be said that only 3 messages (or some O(1) messages, same constant for all threads) per thread are worth reading.
11:24:35 <user317> anyone know how to forget current changes in git?
11:24:42 <enzo> byorgey: Excellent idea!
11:24:47 <Botje> git reset --hard
11:25:04 <byorgey> enzo: then you can create a Show instance for your data type that does the right thing.
11:25:25 <user317> thanks
11:25:26 <newsham> mono: I think that is aprox correct, but its undecidable which three ;-)
11:26:13 <olsner> possibly AI-complete rather than undecidable
11:26:32 <monochrom> If a thread has more than 15 messages or thereabouts, I skip the whole thread. Reason: it is very likely to be a controversial, fluffy stuff, everyone-has-an-opinion-but-few-have-answers thread.
11:26:44 <monochrom> (E.g. "FP Design")
11:27:19 <allbery_m> > printf "%g" 3.0 :: String
11:27:22 <lambdabot>  "3.0"
11:27:28 <allbery_m> hrm, that seems wrong
11:27:29 <monochrom> Again, that one is also just a heuristic. There are exceptions.
11:27:48 <hpaste>  gwern annotated "What's a better way to handle the emty list?" with "specialize to avoid pattern match crash or empty list crash" at http://hpaste.org/3789#a2
11:28:13 <newsham> olsner: i dunno, i picked the best 3 once and ended up with a paradox
11:28:36 <LoganCapaldo> > (\n -> printf (head $ [ s |  s <- [ "%.0f" ], isIntergral n ] ++ [ "%f" ]) n :: String) 3.2
11:28:37 <lambdabot>   Not in scope: `isIntergral'
11:28:47 <LoganCapaldo> I thought that was @let'ed
11:29:04 <Cale> isIntegral?
11:29:05 <shachaf> isIntergal wasn't. :-)
11:29:13 <idnar> heh
11:29:13 <olsner> > isIntergal 7
11:29:14 <lambdabot>   Not in scope: `isIntergal'
11:29:19 <olsner> > isIntregal 7
11:29:19 <lambdabot>   Not in scope: `isIntregal'
11:29:31 <olsner> > isIntegral 7
11:29:32 <lambdabot>  True
11:29:35 <olsner> lol
11:29:39 <LoganCapaldo> > (\n -> printf (head $ [ s |  s <- [ "%.0f" ], isIntegral n ] ++ [ "%f" ]) n :: String) 3.2
11:29:42 <Porges> @let display x = case (isIntegral x) of { True -> (show.fst.properFraction) x; otherwise -> show x }
11:29:43 <lambdabot>  "3.2"
11:29:46 <lambdabot> Plugin `eval' failed with: L.hs: renameFile: does not exist (No such file or directory)
11:29:49 <LoganCapaldo> > (\n -> printf (head $ [ s |  s <- [ "%.0f" ], isIntegral n ] ++ [ "%f" ]) n :: String) 3.0
11:29:50 <lambdabot>  "3"
11:30:03 <LoganCapaldo> I fail at spelling
11:30:04 <Porges> display 3.2
11:30:14 <Porges> > display 3.2
11:30:16 <lambdabot>  "3.2"
11:30:21 <Porges> > display 3.0
11:30:22 <lambdabot>  "3"
11:30:26 <shachaf> > isIntergal "LoganCapaldo"
11:30:27 <lambdabot>  True
11:31:24 <allbery_m> ha!  Text.Printf.printf does %g wrong, as I thought
11:31:36 <olsner> hmm.. the facebook likeness application gave me a 104% similarity with one of my friends
11:31:51 <LoganCapaldo> > (\n -> printf (head $ [ "%f" | isIntegral n ] ++ [ "%f" ]) n :: String) 3.0
11:31:52 <lambdabot>  "3.0"
11:32:49 <LoganCapaldo> > (\n -> printf (head $ guard (isIntegral n) >> return "%.0f" ++ [ "%f" ]) n :: String) 3.0
11:32:49 <gwern> olsner: so you are more like them than they are
11:32:50 <lambdabot>  "3"
11:33:05 <LoganCapaldo> > (\n -> printf (head $ guard (isIntegral n) >> return "%.0f" ++ [ "%f" ]) n :: String) 3.2
11:33:07 <lambdabot>  Exception: Prelude.head: empty list
11:33:11 <LoganCapaldo> doh
11:33:24 <LoganCapaldo> > (\n -> printf (head $ (guard (isIntegral n) >> return "%.0f") ++ [ "%f" ]) n :: String) 3.2
11:33:25 <lambdabot>  "3.2"
11:33:30 <dons> hehe http://www.criticsrant.com/bb/reading_level.aspx
11:33:32 <lambdabot> Title: The Blog Readability Test. What level of education is required to understand you ...
11:33:42 <LoganCapaldo> wait
11:33:44 <dons> apparently sigfpe's blog requires junior high school level education
11:34:09 <LoganCapaldo> > (\n -> printf (head $ (guard (isIntegral n) >> return "%.0f" ++ [ "%f" ])) n :: String) 3.2
11:34:10 <lambdabot>  Exception: Prelude.head: empty list
11:34:18 <LoganCapaldo> eh
11:35:01 <shachaf> dons: And yours is Elementary School? :-)
11:35:05 <olsner> apparently augustss's blog is slightly simpler though, only elementary school level
11:35:31 <LoganCapaldo> > (\n -> printf (if isIntegral n then "%.0f" else "%f") n :: String) 3
11:35:33 <lambdabot>  "3"
11:35:36 <LoganCapaldo> > (\n -> printf (if isIntegral n then "%.0f" else "%f") n :: String) 3 .2
11:35:37 <lambdabot>  Couldn't match expected type `b -> c'
11:35:41 <LoganCapaldo> > (\n -> printf (if isIntegral n then "%.0f" else "%f") n :: String) 3.2
11:35:42 <lambdabot>  "3.2"
11:35:51 * LoganCapaldo stops spamming the channel
11:36:16 <monochrom> salierix: you may find http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom-0.1.0 useful. It does what you're trying, and it's correct code.
11:36:19 <lambdabot> http://tinyurl.com/28wzxt
11:37:08 <shachaf> haskell.org is College (Undergrad).
11:37:23 <dons> shachaf: heh :)
11:37:36 <andyjgill> Hey Dons, my blog is elementary school, but my research statement is genius.
11:38:14 <newsham> sigfpe's blobbies are weird
11:38:37 <LoganCapaldo> hpaste.org is Genius!
11:39:00 <dons> andyjgill: heh
11:39:39 <dons> galois.com is genius level too, it seems
11:42:24 <Cale> I hope that's not starting again.
11:42:59 <shachaf> Challenge: Make the shortest page ranked "Genius".
11:43:23 --- mode: irc.freenode.net set +o ChanServ
11:44:41 <fox86> hmm
11:44:58 <allbery_m> what's more painful than netsplits?  xchat aqua with growl during netsplits
11:45:22 <lament> that can be shortened to
11:45:41 <lament> what's painful? xcht aqua
11:45:45 <lament> *xchat
11:45:53 <allbery_m> neh
11:46:01 <newsham> ?seen sigfpe
11:46:02 <lambdabot> I haven't seen sigfpe.
11:46:08 <allbery_m> it's finen ormally, but the growl interface is less than configurable
11:46:18 <allbery_m> newsham: he's been going as dpiponi of late
11:46:24 <allbery_m> @seen dpiponi
11:46:24 <lambdabot> I saw dpiponi leaving #haskell 4d 20h 59s ago, and .
11:46:26 <Cale> Heh, I have a reddit post which apparently requires a postgrad reading level.
11:46:37 <andyjgill> slashdot is high school, so perhaps this blog readability thing is onto something
11:47:03 <Cale> programming.reddit.com/info/2wjai/comments/c2womz
11:47:23 <shachaf> reddit.com is Junior High School, programming.reddit.com is High School.
11:47:26 <Brian`> if you have "type Parser a = String -> [(a, String)], is Parser type or type constructor?
11:47:37 <shachaf> Brian`: Type.
11:47:43 <shachaf> Brian`: There is no type constructor.
11:47:50 <shachaf> Brian`: "type" just makes aliases.
11:47:51 <Cale> huh?
11:47:56 <Brian`> yeah that's what I thought too
11:48:00 <Philippa> it's a type synonym that you use as if it were a type constructor
11:48:12 <Cale> Parser's a type constructor of sorts there, yeah.
11:48:13 <Philippa> Parser is a synonym for a constructor, Parser a is a type
11:48:15 <Brian`> but I'm reading Graham Hutton's paper, "Monadic Parser Combinator"
11:48:29 <shachaf> programming.reddit.com/search?q=haskell is Elementary School, though...
11:48:55 <shachaf> Wait.
11:48:57 <shachaf> Never mind.
11:49:00 <Brian`> oh.. ok. Parser is a synonym for a constructor i c
11:49:01 * shachaf misread.
11:49:03 <Brian`> that makes sense
11:49:06 <shachaf> It behaves like a type constructor.
11:49:12 <shachaf> Sorry, never mind.
11:49:28 <Brian`> shachaf, it's ok :) thanks for helping me
11:49:53 <Cale> Parser is (sort of) a type constructor, Parser Integer is a type
11:49:59 <scodil> any gtk2hs uses awake?
11:49:59 <lambdabot> scodil: You have 1 new message. '/msg lambdabot @messages' to read it.
11:50:04 <scodil> users, even
11:50:44 <Cale> It's not a real type constructor in that it basically must be fully applied at all times. You can't use it to define instances.
11:50:47 <newsham> huh?   "Parser a" if  "type Parser a = ..."  is just a type name and not a constructor, no?
11:50:47 <scodil> how do you send messages with lambdabot?
11:51:01 <Cale> newsham: yes, but what is "Parser"
11:51:18 <dcoutts> scodil: @tell who what
11:51:30 <newsham> I dont understand the quesiton.
11:51:41 <Cale> "Parser a" is a type
11:51:53 <Cale> But "Parser" itself acts like a type constructor
11:51:54 <scodil> oh there you are
11:51:55 <monochrom> :k Parser
11:51:56 <Brian`> newsham, the question was "if you have "type Parser a = String -> [(a, String)], is Parser type or type constructor?"
11:51:56 <lambdabot> Not in scope: type constructor or class `Parser'
11:52:03 <gwern> Cale: you know, most people get a blog for that sort of thing :)
11:52:11 <Cale> gwern: heh
11:52:16 <gwern> *sort of really lengthy 'comment'
11:52:18 <scodil> i was going to do @tell dcoutts what build problems? :)
11:52:23 <scodil> but now i guess i wont
11:52:24 <newsham> ok i misunderstood the question.
11:52:26 <monochrom> :k Text.ParserCombinators.Parsec.Parser
11:52:28 <lambdabot> * -> *
11:52:37 <Philippa> oh, of course. Type synonyms have to be fully applied
11:52:38 <shachaf> scodil: @ask for questions.
11:52:38 <newsham> mono: he's not talking about that Parser
11:52:52 <newsham> that Parser is not "type Parser a"
11:53:00 <Cale> gwern: I have a blog: http://cgibbard.livejournal.com/
11:53:06 <shachaf> (I thought there was a difference, but I'm not sure anymore.)
11:53:33 <monochrom> @let type PMono a = String -> [(a, String)]
11:53:33 <lambdabot> Invalid declaration
11:53:37 <newsham> when you say 'constructor' I'm thinking abot something you call from code.
11:53:53 <newsham> like   data Foo a = Bar a;   "Bar" constructor.
11:54:01 <scodil> dcoutts: is there any access to the GtkTreeSortable interface? How do you sort trees/lists by various columns?
11:54:04 <nominolo> @seen jyp
11:54:04 <lambdabot> I saw jyp leaving #xmonad and #haskell 24d 23h 28m 34s ago, and .
11:55:09 <Cale> I don't really get the whole idea of blogs. Why is that really any different from having a web site? I run a webserver on my machine already. It runs MediaWiki.
11:55:09 <monochrom> http://www.haskell.org/onlinereport/lexemes.html#sect2.4 look for "type constructor"
11:55:10 <lambdabot> Title: Haskell 98 Lexical Structure
11:55:26 <nominolo> gwern: do you get yi to work?
11:55:26 <newsham> cale: the main difference is feedback mechanism on page?
11:55:37 <Cale> Yeah, MediaWiki will do that.
11:55:42 <newsham> i recently started a faux blog (its a log but no feedback)
11:55:57 <newsham> http://www.thenewsh.com/%7Enewsham/blog/
11:55:59 <lambdabot> Title: bLogos
11:55:59 <LoganCapaldo> Does mappend have to be commutative?
11:56:01 <Cale> You can edit the pages if you want.
11:56:15 <newsham> mine is a webserver on my machine already.
11:56:19 <Cale> (Just log in first)
11:56:38 <newsham> cale: you let people edit your web page?
11:56:42 <Cale> yes
11:56:56 <newsham> so that seems like a superset of a blog already
11:57:12 <newsham> if you use it in an append-only fashion
11:57:14 <newsham> (prepend?)
11:57:17 <monochrom> The whole idea of blogs is you don't run your own webserver. You don't even write your own html. Log on to a third-party website, type stuff into a text box. No programming. No computer literacy.
11:57:24 <Cale> Yeah, which is why I don't get the point.
11:57:45 <newsham> whats not to get.  you have a wiki-slash-blog.
11:57:54 <monochrom> The whole idea of blogs is computer illiteracy.
11:58:02 <Brian`> is Haskell derived from Gofer?
11:58:07 <newsham> nah, you can be literate and use a blog
11:58:11 <Cale> monochrom: Now that sounds kind of likely.
11:58:20 <newsham> "apathy" might be a better word ;-)
11:58:37 <monochrom> Like Bill Gates's vision. "Everyone has a computer. Everyone can use a computer. Everyone can use without education."
11:59:01 <Cale> Brian`: Gofer was what turned into Hugs
11:59:07 <shachaf> Brian`: Isn't Gofer an implementation of Haskell?
11:59:13 <Cale> Yeah.
11:59:25 <Cale> Haskell is derived from Miranda, mostly.
12:00:14 <lament> computer illiteracy is a good thing
12:00:20 <LoganCapaldo> @instance Monoid
12:00:21 <lambdabot> Maybe you meant: instances instances-importing
12:00:24 <lament> and blogs are a good thing
12:00:26 <LoganCapaldo> @instances Monoid
12:00:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
12:01:01 <LoganCapaldo> > mempty :: a -> b
12:01:02 <lambdabot>   add (Monoid b) to the expected type of an expression
12:01:02 <lambdabot>     In the expression:...
12:01:18 <LoganCapaldo> > mempty :: (Monoid b) => a -> b
12:01:19 <lambdabot>  Add a type signature
12:01:28 <LoganCapaldo> right
12:01:29 <monochrom> newsham: Maybe I'm anal. I was discussing "what is the point". So I think the original intention is as what I said. Of course, computer gurus find it convenient and enjoy it too, but it is not the original intention, it is a side-effect.
12:01:49 <Cale> I don't really like the purely linear organisation of blogs.
12:02:07 <newsham> cale: and I dont writing my software in map-reduce fashion
12:02:13 <newsham> sometimes a restrictive medium is called for
12:02:37 <Cale> I don't see why it's called for in this case.
12:02:48 <lament> Cale: because you have to balance functionality with ease of use
12:02:56 <lament> Cale: ease of use for both the blogger and the audience
12:03:06 <LoganCapaldo> Ah
12:03:10 <monochrom> newsham: And of course, as time goes by and things evolve, the original intention becomes moot, how people actually use it is much more relevant, I admit.
12:03:11 <LoganCapaldo> I've just invented End
12:03:14 <LoganCapaldo> *Endo
12:03:27 <lament> Cale: have you read that article about hierarchical vs. tags?
12:03:33 <Cale> Most of the time, if I'm going to write something, I'm not going to write it for November 10th 2007, I'm going to hope that it remains valid for at least a few years.
12:03:36 <Nafai> Say I have a function that returns Maybe a, and a list that contains that types that function needs...is there a map-like function that will iterate over all of those and just return the Just instances (preferrebly without the Just?)
12:03:46 <lament> Cale: right, so you tag it with relevant stuff
12:03:56 <LoganCapaldo> @type catMaybes
12:03:57 <Korollary> Cale: That's just you. Most people do write it for the day/moment.
12:03:57 <lament> Cale: which blogs let you do just fine
12:03:58 <lambdabot> forall a. [Maybe a] -> [a]
12:04:00 <newsham> would you like haiku / if it was less restrictive / and allowed you to cheat?
12:04:11 <Nafai> @index catMaybes
12:04:11 <lambdabot> Data.Maybe
12:04:21 <LoganCapaldo> > catMaybes [Just 1, Nothing, Just 2]
12:04:22 <lambdabot>  [1,2]
12:04:26 <Nafai> LoganCapaldo: Thanks!
12:04:31 <Nafai> Haskell rocks! :)
12:04:33 <monochrom> Is that a Haiku? I am not sure about the rules. :)
12:04:43 <newsham> haiku is 5,7,5 syllables
12:04:44 <lament> no, that's not a haiku, it's a senryu
12:04:56 <allbery_m> technically not because haikus have to have nature motifs
12:05:04 <LoganCapaldo> @hoogle Endo a -> a -> a
12:05:05 <lambdabot> No matches, try a more general search
12:05:15 <lament> newsham: no, haiku isn't necessarily 5,7,5, but it can't have that kind of polemics and remain a haiku
12:05:44 <newsham> i wanted the last line to be "and less about nature"
12:05:49 <newsham> but alas
12:05:50 <Cale> lament: What do tags do that a full-text search can't?
12:06:03 <lament> Cale: nothing! which is why you don't even need tags!
12:06:12 <lament> Cale: so why do you need anything other than a linear structure?
12:06:18 <conal> LoganCapaldo: hoogle probably interprets your Endo as a type constructor rather than a class
12:06:28 <Saizan_> Cale: you can say that writing a blog is like writing an article in a magazine, people talk about it because it has been written now, a wiki is instead an inpersonal source of knowledge
12:06:35 <lament> Cale: there're very good arguments against any other kind of structure
12:06:36 <LoganCapaldo> Endo is a type constructor isn't it?
12:06:36 <Cale> Because the linear organisation of the things I write is irrelevant.
12:06:42 <LoganCapaldo> (a newtype msot likel)
12:06:45 <LoganCapaldo> :t Endo
12:06:47 <lambdabot> forall a. (a -> a) -> Endo a
12:06:52 <conal> LoganCapaldo: oh, yeah it is.
12:07:20 <conal> :t appEndo
12:07:21 <lambdabot> forall a. Endo a -> a -> a
12:07:40 <lament> Cale: well, the things have to be ordered somehow. Ordering them by date is kinda natural - as if you were writing stuff on paper.
12:07:51 <LoganCapaldo> thanks conal
12:07:59 <conal> sure
12:08:09 <Cale> Why not organise them into a tree structure?
12:08:25 <lament> Cale: now i really want to find that article on trees vs tags :)
12:08:27 <monochrom> Cale arranges his articles into a sphere. :)
12:08:33 <lament> Cale: tree structures are bad
12:08:59 <TomMD> What?  No messages?  Its a Saturday night and i don't have any invitations to hackathons!  Whats a programmer to do...
12:09:01 <monochrom> tree is less flexible and realistic than dag.
12:09:16 <lament> Cale: in that 1) they're too complicated and 2) they don't work very well
12:09:41 <newsham> trees are easier to serialize
12:09:58 <LoganCapaldo> meh
12:10:02 <Cale> Yeah, we should totally go for flat directoryless filesystems.
12:10:12 <Cale> Directories are a failure.
12:10:14 <LoganCapaldo> mappend = (.) for Endo, not flip (.) like I expected
12:10:17 <lament> Cale: yes, i believe so
12:10:22 <Cale> Hehe.
12:10:25 <newsham> cale: dos had a flat directoryless filesystem
12:10:26 <lament> Cale: no, really
12:10:26 <newsham> and cp/m
12:10:42 <Cale> newsham: I know :)
12:10:52 <newsham> i bet you can find a copy to run somewhere
12:10:58 <lament> Cale: organizing stuff in one tree means you have some sort of "primary key" you're arranging things according to
12:11:03 <nominolo> anyone got the ghc 6.8.1 binary to install on ubuntu?
12:11:07 <lament> Cale: music goes into this directory, photos go into this directory
12:11:13 <olsner> newsham: must've been a really old dos version... all versions I've seen have had directories
12:11:16 <lament> Cale: once you want things arranged differently, you're screwed
12:11:18 <newsham> http://simh.trailing-edge.com/software.html
12:11:20 <lambdabot> Title: Software Kits
12:12:11 <Cale> lament: My music directory has genre directories in it, then the genre directories have artist subdirectories (with appropriate symlinks), and then inside each artist directory I have albums, and then sometimes inside an album, I have things broken down by disc.
12:12:30 <Cale> I have ~12000 items :)
12:12:38 <LoganCapaldo> >  let f = appEndo . snd . runWriter $ do { tell (subtract 1) ; tell (* 2) ; tell (/ 0.5) } in f 7
12:12:39 <lambdabot>  Couldn't match expected type `t -> t'
12:12:51 <LoganCapaldo> :t runWrite
12:12:52 <lambdabot> Not in scope: `runWrite'
12:12:54 <LoganCapaldo> :t runWriter
12:12:55 <lambdabot> forall w a. Writer w a -> (a, w)
12:12:56 <Cale> If I was to flatten that out, it would be completely unmanageable.
12:12:57 <newsham> item == track?
12:13:04 <ulfdoz> Cale: Wouldn't it be more nature to have artist/album/disc/title?
12:13:17 <newsham> it would be manageable if you had another mechanism (other than directory heirarchy) for managing metadata
12:13:17 <olsner> or, rather, dos has a set of 1 to 8 keys of 8+3 characters for each file, but that's just a technical limitation in a simple implementation of a real tree
12:13:22 <ulfdoz> That's at least the scheme I use.
12:13:24 <lament> Cale: right, so at some point you made a decision that knowing the genre is more important than knowing the artist, and knowing the artist is more important than knowing the album, and that stuff is organized into albums
12:13:25 <newsham> (not that dir heirarchy is a bad way)
12:13:28 <lament> Cale: none of that is universal
12:13:30 <Cale> ulfdoz: that's essentially how it is, except there's also genre at the top
12:13:41 <monochrom> I recommend a consideration of http://www.google.com/search?q=nelson+zigzag+structure if you are interested in organizing things and their relations.
12:13:41 <lambdabot> Title: nelson zigzag structure - Google Search
12:13:42 <Cale> lament: It's reasonably so.
12:13:53 <newsham> lament: also bands may span genres over the course of their career, from album to album or even song to song
12:13:54 <lament> Cale: it never worked for my music collections
12:14:02 <LoganCapaldo> >  let f = appEndo $ snd $ runWriter $ do { tell (subtract 1) ; tell (* 2) ; tell (/ 0.5) } in f 7
12:14:03 <lambdabot>  Couldn't match expected type `t -> t'
12:14:08 <ulfdoz> Cale: I omitted that, because there are some experimental artists switch genres like underwear.
12:14:08 <olsner> http://c2.com/cgi/wiki?LimitsOfHierarchies
12:14:10 <lambdabot> Title: Limits Of Hierarchies
12:14:11 <lament> Cale: first of all, some stuff is impossible to place into a specific genre. Then you're already screwed
12:14:14 <Cale> Don't forget you can symlink.
12:14:14 <LoganCapaldo> doh
12:14:33 <monochrom> I guess I can give you a brief summary. It is structured but not hierarchical. My understanding is it is a general graph.
12:14:34 <LoganCapaldo> >  let f = appEndo $ snd $ runWriter $ do { tell $ Endo (subtract 1) ; tell $ Endo (* 2) ; tell $ Endo (/ 0.5) } in f 7
12:14:34 <Cale> lament: So define a new genre for them.
12:14:35 <lambdabot>  27.0
12:14:52 <Cale> Besides, I have an Avant Garde directory which eats up most of that sort of thing. :)
12:14:53 <lament> Cale: that's nonsense
12:15:08 <ulfdoz> Cale: But maintaining symlinks can get a nightmare. However, amarok does a great job when it comes to indexing metadata.
12:15:19 <lament> Cale: right, so you have to remember which genre you placed an artist into
12:15:24 <Cale> Sure.
12:15:33 <LoganCapaldo> Hmmm
12:15:33 <newsham> lament: there are tools for locating items in large directory trees
12:15:40 <Cale> But how hard is it to remember that John Scofield is in Jazz?
12:15:44 <monochrom> MozartGenre. BrahmsGenre. ...
12:15:47 <Korollary> why are you managing them yourself anyway? use winamp or itunes or something.
12:15:49 <newsham> one of hte benefits of reusing existing structures is you get tools for free
12:16:15 <yitz> monochrom: classical. romantic.
12:16:16 <newsham> itunes pretty much sucks for management
12:16:27 <Cale> I use audacious to play music. I generally do so by dropping an album directory onto it.
12:16:29 <lament> yitz: Beethoven?
12:16:31 <monochrom> LangLangGenre.
12:16:40 <yitz> lament: romantic.
12:16:40 <newsham> i have a large collection and it is maintained by directory heirarchies (no symlinks) in a similar manner
12:16:44 <lament> yitz: ...
12:16:52 <yitz> :)
12:17:01 <ulfdoz> Cale: I really recommend amarok, if you're using linux.
12:17:04 <yitz> Avant Garde.
12:17:13 <Cale> I don't even have that many symlinks. Most of my music fits clearly into one or another genre.
12:17:18 <monochrom> BrahmsBeethovenTenthGenre
12:17:19 <lament> Cale: you're lucky :)
12:17:38 <newsham> usually in the process of building a large collection of music you like, you get to know where it all is really well
12:17:43 <newsham> finding music is rarely a problem
12:17:52 <Cale> ulfdoz: That uses KDE though, which means it takes ages to load.
12:18:01 <lament> newsham: sure, but it isn't a problem with tags either
12:18:02 <Cale> (most likely)
12:18:07 <lament> i just wish i could find that article
12:18:17 <newsham> lament: who says you cant have both?  I have scripts which auto-tag all my data
12:18:17 <Cale> I *really* couldn't stand iTunes when I used it on OSX.
12:18:38 <ulfdoz> Cale: Yes, the dependencies are quite voluminous. I personally, are completely on KDE:
12:18:39 <lament> newsham: of course you can have both
12:18:47 <newsham> when I rip a cd, I collect cddb info and create a metadata file for the album and tag all the files using the metadata file
12:18:53 <Cale> It only allowed for essentially one level of categorisation, which for me was "Album".
12:19:02 <lament> itunes is a piece of crap
12:19:10 <newsham> the album exists as a directory under subdirectories for artists
12:19:19 <ulfdoz> lament: Full Ack.
12:19:54 <ulfdoz> Cale: And to make the "bloat" even larger, amarok uses SQL-Backends like mysql, postgres, sqlite and so on.
12:20:02 <ulfdoz> But it is fucking fast.
12:20:03 <newsham> small composable tools >> large do-everything app
12:20:11 <newsham> also no lock-in
12:20:39 <Korollary> there's no lock-in if you have only mp3s or un-drm'd aac
12:20:40 <newsham> locate,find,grep,mp3info,play,...
12:20:47 <olsner> hmm... I hope amarok didn't actually need all those dependencies I answered 'No' to
12:20:56 <newsham> kor: what I mean by lockin is large amount of metadata built up in a proprietary format (itunes)
12:21:22 <Cale> Heh, I strip ID3 tags from everything I get.
12:21:28 <Korollary> I don't know if it's all proprietary. Winamp can surely handle my ipod's database.
12:21:37 <newsham> i add ID3 tags to everything I get ;-)
12:21:47 <Korollary> I correct id3 tags if necessary
12:21:49 <ulfdoz> Cale: Ok, so amarok can't be a win for you. It relies on them.
12:21:50 <newsham> my music comes from CDs
12:21:51 <Cale> If you're adding them yourself, then it'd be okay.
12:22:14 <Cale> I just can't be bothered, and my filesystem is already maintaining that data.
12:22:15 <lament> Cale: anyway i'm too lazy to build up the entire argument right now, but i can probably do it in the future :)
12:22:29 <newsham> but I dont manually add it.. I just put in cd and say "rip the_cure/newest_crappy_stuff_i_shouldnt_have_bought"
12:22:32 <newsham> and let it do its thing
12:22:36 <olsner> as far as I can see, iTunes stores most of its information in ID3 tags... at least if you check the box that says it should store the modified tags
12:22:48 <newsham> it does the cddb lookup, ripping, encoding etc
12:22:53 <lament> Cale: but it's a pretty good argument :)
12:22:59 <Cale> lament: hehe
12:23:10 <lament> Cale: hierarchical structures are similar to OO - everything works really really well in theory
12:23:32 <Cale> It's working out really well in practice for me. :)
12:23:44 <newsham> lament: so throw all the metadata into a file.  we have the technology.
12:23:51 <lament> Cale: well, in your case it's simply because you're not listening to diverse enough music
12:23:56 <LoganCapaldo> @type let mconcatMap = (mconcat .) . map in mconcatMap
12:24:04 <lambdabot> forall b a. (Monoid b) => (a -> b) -> [a] -> b
12:24:10 <newsham> ad hominem
12:24:10 <Cale> I have ~12000 songs and I can find any one of them in a few seconds.
12:24:11 <lament> newsham: my point is that tags rule and directories suck. Being able to use both doesn't change that.
12:24:20 <lament> Cale: that doesn't change my point :)
12:24:30 <LoganCapaldo> > let mconcatMap = (mconcat .) . map in mconcatMap mconcatMap Sum [1,2,3]
12:24:31 <lambdabot>      Occurs check: cannot construct the infinite type: b = [a] -> b
12:24:31 <lambdabot>     Proba...
12:24:32 <olsner> I'd rather say the opposite - both hierarchies and OO have theoretical shortcomings that may or may not have an impact in practice
12:24:39 <newsham> cale: i like your layout, but you could still find any one of 12k in seconds without it.
12:24:40 <lament> Cale: The very fact that you're able to sort stuff by "genre" means you don't listen to diverse enough music :)
12:24:42 <newsham> poor argument.
12:24:42 <Korollary> anybody can find anything. Use google desktop for instance.
12:24:45 <LoganCapaldo> > let mconcatMap = (mconcat .) . map in mconcatMap Sum [1,2,3]
12:24:47 <lambdabot>  Sum {getSum = 6}
12:24:51 <Cale> lament: Oh?
12:24:55 <LoganCapaldo> > let mconcatMap = (mconcat .) . map in mconcatMap Product [1,2,3]
12:24:56 <lambdabot>  Product {getProduct = 6}
12:25:09 <Korollary> lambdabot: Cale also listens to the whole album in order
12:25:15 <Korollary> no shuffle
12:25:24 <Cale> right.
12:25:26 <lament> Cale: i'm a musicias with pretty good training, classical and otherwise, and i would have huge troubles classifying stuff into genres in a useful way.
12:25:30 <lament> *musician
12:25:33 <newsham> just because you store an album in order doesnt mean you have to listen to it as such
12:26:09 <Cale> I listen to albums in the order in which the artist designed the album to be listened to.
12:26:34 <lament> also not all music is in "albums"
12:26:49 <Cale> It's okay to move files up the tree.
12:26:50 <lament> albums are just what, past 60-70 years?
12:27:00 <yitz> Cale: that depends on the genre. For some, the order is not specified by the artist and not significant.
12:27:01 <newsham> lament: surely you can think of a solution to that problem.
12:27:04 <Cale> Or change the tree structure locally.
12:27:13 <newsham> this isnt rocket science
12:27:37 <lament> Cale: also, suppose you have different pianists performing different Bach pieces
12:27:47 <lament> Cale: since you order by Artist, you'll have them in different places?
12:28:01 <newsham> lament: whats wrong with that?
12:28:04 <Cale> Maybe, depends on who the artist is considered to be there.
12:28:05 <olsner> argh, arts seems to be a real Enterprise Sound System... why couldn't everything just use alsa directly?
12:28:14 <lament> Cale: ah... so who is it considered to be?
12:28:20 <newsham> find . -name info |xargs grep Bach
12:28:24 <lament> Cale: i do believe this is a good example ;)
12:28:26 <yitz> newsham: large amounts of content with varying metadata is rocket science
12:28:27 <Cale> Well, you could do it both ways.
12:28:34 <lament> Cale: exactly, but you can build your hierarchy only one way
12:28:35 <newsham> oh come on..
12:28:39 <Oejet> Hi.
12:28:43 <Cale> No you don't have to at all.
12:28:47 <newsham> yitz: these problems you can solve in your sleep!
12:28:55 <newsham> how about "locate Bach"?
12:29:05 <newsham> all the files with "Bach" in its name on your whole system
12:29:07 <Cale> lament: I could create artist directories for each of the pianists, as well as for Bach
12:29:08 <newsham> how hard is that?!
12:29:11 <lament> newsham: i keep telling you the same thing and you keep ignoring it
12:29:12 <yitz> newsham: ever hear of owl/rdf? topic maps?
12:29:12 <Cale> and symlink the files into each
12:29:21 <newsham> you guys are talking like you've never used a computer to solve a problem before
12:29:41 <lament> newsham: again... my point is that tags are better than hierarchies, not that you can't do both.
12:29:54 <newsham> how is that any easier or harder with tags?
12:29:55 <Cale> But in practical terms, I'm more likely to have a directory for Bach, then directories for each person who is playing Bach.
12:30:08 <Cale> (inside it)
12:30:09 <lament> Cale: right, so you have to remember that there's an exception to your Artist rule
12:30:18 <Korollary> you're almost talking about hierarchical databases versus relational
12:30:21 <lament> Cale: it starts getting more complicated already
12:30:27 <Cale> lament: Not really. The computer will remind me of that.
12:30:43 <Cale> When I click on the Bach directory, I will see the others inside of it.
12:31:01 <Oejet> Hm, what is the topic of the current discussion?
12:31:06 <Cale> (duh)
12:31:17 <lament> Cale: it's perfectly plausible that one day, you want to listen to stuff by Bach, and another day, you want to listen to stuff (by any composer) performed by Glenn Gould.
12:31:22 <monochrom> Korollary: Yeah, I do wonder if it's year 1907 or 2007.
12:31:28 <lament> Cale: on the first day, you'll be able to just use your tree hierarchy.
12:31:29 <allbery_m> heh
12:31:36 <newsham> lament:  play `locate Gould`
12:31:43 <lament> Cale: on the second day, you're screwed unless you put extensive work into managing your hierarchy
12:31:50 <Cale> So, create a directory called Gould with symlinks to all of the stuff by Gould.
12:32:10 <lament> Cale: right, "unless you put extensive work into managing your hierarchy"
12:32:18 <Korollary> monochrom: is there a directory that contains all directories that don't contain themselves?
12:32:18 <Cale> You only have to do it once.
12:32:29 <Oejet> How about extensive work into managing tags?
12:32:53 <monochrom> Are directories well-founded or not?
12:33:00 <newsham> http://www.sooloos.com/www/index.html
12:33:01 <lambdabot> Title: sooloos
12:33:05 <byorgey> error: No instance for (Ord (ClassificationSystem t))
12:33:34 <newsham> korollary: directories cannot contain cycles
12:33:46 <newsham> you can create meta-cycles with symlinks
12:34:57 <newsham> lament: I can write a shell script to make a symlink to all songs for composer "Gould" in 5 minutes.  I can run that shell script in 5sec
12:35:06 <newsham> hardly the definition of "screwed"
12:35:07 <Oejet> Btw. I am trying to set up a GHC+HOpenGL environment on win32, and I think, that HOpenGL is contained in GHC 6.8.1, but when I try to compile it says, that is cannot find the GLUT package. I have not found any (working) intructions on how to set this up. Where can I look?
12:35:22 <lament> Cale: note that creating a directory Gould with symlinks to all of the stuff by Gould is effectively the same as adding a "Gould" tag, but the latter is natural (you tag stuff with relevant info), while the former is really strange (because instead of one tree, you now have two trees)
12:35:46 <Cale> lament: How is that unnatural?
12:35:54 <newsham> my yard has 3 trees
12:36:01 <newsham> they all seem natural
12:36:09 <Cale> hehe
12:36:22 <lament> man, i should know better than to argue with programmers
12:36:29 <monochrom> In a non-empty directory, there is a subdirectory such that if it contains cycles, then every sibling contains cycles.
12:36:47 <monochrom> Every directory loves me, but I love my subdirectory only.
12:37:18 <monochrom> Don't throw out the subdirectory with the file system!
12:37:36 * Korollary is now geeked out
12:38:14 <yitz> monochrom: a symlink in time saves nine
12:38:21 <Japsu> Elsewhere it was requested that lambdabot would be changed not to react (get title, make shorturl etc.) more than once to the same link being pasted multiple times on a single channel
12:38:39 <monochrom> An Apple a day, keeps the directories away.
12:39:07 <Japsu> mmh one-to-many relationships
12:39:11 <yitz> Japsu: within a time limit, I suppose
12:39:16 <Japsu> yitz: yeah ofc
12:39:25 <Cale> Japsu: I have a solution: don't paste the same link multiple times :)
12:39:37 <Japsu> Cale: haha, I'll tell them ;)
12:39:43 <Skyp> hm, what is an elegant way to join a list of strings with a separator? At the moment I use: foldr (\x y -> x ++ '~':y) [] ["foo","bar","baz","qux","quux"]
12:39:56 <Japsu> Skyp: intersperse
12:40:01 <Cale> Skyp: concat . intersperse '~'
12:40:09 <Cale> er, "~" rather
12:40:13 <Skyp> ok, one more function I didn't know ;) thx ;)
12:40:20 <Japsu> > concat . intersperse ", " $ ["foo", "bar", "baz"]
12:40:22 <lambdabot>  "foo, bar, baz"
12:40:34 <olsner> @index intersperse
12:40:34 <lambdabot> Data.List
12:40:48 <Japsu> hmm,
12:40:50 <Japsu> @src intersperse
12:40:50 <lambdabot> intersperse _   []     = []
12:40:51 <lambdabot> intersperse _   [x]    = [x]
12:40:51 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
12:40:57 <Japsu> okay, no fold there
12:41:31 <Japsu> lol, I got the feature request wrong
12:41:34 <allbery_m> @src intercalate
12:41:34 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
12:41:40 <olsner> > ["foo","bar","baz"] >>= (:",")
12:41:41 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:41:45 <Cale> Is intercalate in the libraries yet?
12:41:51 <byorgey> Cale: yup!
12:41:55 <olsner> > ["foo","bar","baz"] >>= (:[","])
12:41:56 <Japsu> what he had in mind wast to make lambdabot insult the subsequent pasters of a link ;)
12:41:56 <lambdabot>  ["foo",",","bar",",","baz",","]
12:41:57 <allbery_m> 6.8.1 yes, 6.6.x no
12:42:00 <byorgey> comes with 6.8
12:42:17 <Japsu> in Finnish we have this word "WANHA!!!" that's often used that way ;
12:42:29 <Japsu> bah,
12:42:29 <olsner> Japsu: what's that mean exactly?
12:42:34 <Japsu> olsner: "old" ;)
12:42:52 <olsner> oh, in sweden we just say "OLD!!!"
12:43:05 <Japsu> in fact "old" is "vanha" but the v is changed to w for added emphasis ;)
12:43:27 <EvilTerran> i'm from a group who would say "ringing!"
12:44:17 <p431i7o> some live here?
12:44:48 <Cale> p431i7o: Well, it might seem that way, but this channel has quite consumed my entire life yet.
12:44:56 <Cale> hasn't*
12:45:04 <p431i7o> lol
12:45:07 <dons> hah
12:45:14 * dons looks at Cale 
12:45:22 <monochrom> Yeah, your music organization consumes the rest of the life. XD
12:45:57 <hpaste>  LoganCapaldo pasted "Endo + class == no dice?" at http://hpaste.org/3791
12:46:01 <p431i7o> i'm a newbie in haskell, i'm using it because i have to do some of home work
12:46:04 <Cale> Heh, it really doesn't take that much time anymore.
12:46:22 <monochrom> Good. 'Cause we need you to live 24/7 here.
12:46:29 <LoganCapaldo> I do not understand why that type is infinite
12:46:43 <LoganCapaldo> could someone please school me?
12:47:04 <chessguy> @dice 6
12:47:04 <lambdabot> 6 => 6
12:47:11 <Cale> p431i7o: feel free to ask lots of questions about Haskell, but try not to directly ask your homework problems (besides, your prof is probably already here ;)
12:47:48 <mwc> Cale: hahah, that would be funny
12:48:22 <sorear> p431i7o_espanish: Please ask lots of questions.  Answering them is fun!
12:48:58 <p431i7o_espanish> no dont see in that form, i have trouble to read on file because i have to read line by line to manage it, and only i have readFile in standar Prelude
12:49:28 <dons> how about getLine ?
12:49:34 <allbery_m> you're thinking too strictly; readFile is lazy
12:49:36 <dons> or 'lines =<< readFile'
12:49:45 <desegnis> LoganCapaldo: If Endo f :: Endo a, then f :: a -> a
12:50:11 <monochrom> LoganCapaldo: class Wrapper applied to Endo should give: unwrap :: Endo a -> a.  But the implementation gives Endo a -> a -> a.
12:50:22 <LoganCapaldo> oh der
12:50:45 <Cale> p431i7o_espanish: lines will break a string up by newlines
12:50:48 <LoganCapaldo> but that's not waht I want :)
12:50:50 <desegnis> LoganCapaldo: Thus your code would need a to be equal to a -> a. That's where it's infite
12:50:58 <Cale> > lines "abc\ndef\nghi"
12:51:01 <desegnis> *infinite
12:51:06 <lambdabot>  ["abc","def","ghi"]
12:52:11 <p431i7o_espanish> ok, i gonna try again, and, how can i write separate modules with the main module in the same file?
12:52:18 <sorear> You don't.
12:52:34 <LoganCapaldo> desegnis, monochrom anyway I can define Wrapper such that it works for all three cases?
12:53:12 <Cale> It would be nice if we could nest modules.
12:53:34 <lament> p431i7o_espanish: speakas espanish?
12:53:52 <monochrom> I don't see how to do it or what it is supposed to mean for Endo.
12:53:53 <p431i7o_espanish> si
12:54:01 <p431i7o_espanish> es mi lengua.. pero no todos entienden
12:54:11 <allbery_m> @users #haskell-es
12:54:11 <lambdabot> Maximum users seen in #haskell-es: 1, currently: 0 (0.0%), active: 0 (NaN%)
12:54:17 <allbery_m> heh
12:54:20 <sorear> @join #haskell-es
12:54:25 <sorear> @join #haskell.es
12:54:28 <monochrom> "I have a function Int->Int. Can I get an Int from it? What Int should I get?"
12:54:29 <sorear> @part #haskell-es
12:54:37 <LoganCapaldo> monochrom: I most jsut wanted to  chop off the constructor
12:54:40 <allbery_m> @users #haskell-es
12:54:40 <lambdabot> Maximum users seen in #haskell-es: 2, currently: 0 (0.0%), active: 0 (NaN%)
12:54:43 <LoganCapaldo> de-newtypeify it
12:55:08 <desegnis> LoganCapaldo, maybe: class Wrap w t where unwrap :: w -> t. If that's what you want
12:55:14 <p431i7o_espanish> join #haskell.es
12:56:10 <Saizan_> LoganCapaldo: it's the same as churchenc 
12:56:14 <LoganCapaldo> lol
12:56:25 <LoganCapaldo> I need to stop trying to use type classes
12:56:48 <LoganCapaldo> I clearly did not have the brain power to determine which ones make sense and which ones don't
12:57:00 <LoganCapaldo> s/use/create/
12:57:36 <lament> Cale: http://www.shirky.com/writings/ontology_overrated.html
12:57:37 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags
12:57:40 <desegnis> LoganCapaldo, as long as the compiler determines it for you...
12:58:00 <lament> Cale: that article seems fairly persuasive
12:58:35 <p431i7o_espanish> i will back with the correct questions, but is good to know about this chanel, thankyou people!
13:00:14 <Korollary> I wonder if any python projects have .py domains...
13:00:20 <LoganCapaldo> I want to say unwrap :: w a -> ( a | f a | f a a | f a a a ...)
13:00:25 <LoganCapaldo> perhaps
13:00:30 <monochrom> haha
13:00:38 <LoganCapaldo> ah well
13:01:34 <chessguy> Categories, Links, and Tags, oh my!
13:01:35 <monochrom> Seems like ( a | f a | f a a | f a a a ...) is to be determinized by another parameter of the type class, as desegnis says.
13:01:54 <ricky_clarkson> Hmm, I've discovered that I want flatten, map, filter, etc., on files.  Could be an interesting little project.
13:02:29 <ricky_clarkson> Are Haskell compiled programs typically fast to start, say, in comparison to C, or at the worst, Perl?
13:02:29 <Korollary> like HASH?
13:02:33 <monochrom> Either unwrap :: w -> t or unwrap w a -> t a. I don't know which works.
13:02:46 <conal> ricky_clarkson: do you mean read file, process, and write another file?
13:02:56 <ricky_clarkson> conal: Yes.
13:03:06 <monochrom> Maybe neither works.
13:03:06 <Korollary> ricky_clarkson: http://shootout.alioth.debian.org/gp4/benchmark.php?test=hello&lang=all
13:03:08 <lambdabot> Title: startup benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language  ..., http://tinyurl.com/qy4dn
13:03:09 <conal> ricky_clarkson: then you'll probably find TV helpful
13:03:13 <conal> @wiki TV
13:03:14 <lambdabot> http://www.haskell.org/haskellwiki/TV
13:03:16 <Korollary> err
13:03:46 <Korollary> perl doesn't seem to be that bad
13:03:50 <monochrom> Dependent type may work.
13:04:09 <ricky_clarkson> Thanks.  I'm going to work now, so I'll keep irssi at this point and look later.
13:04:11 <hpaste>  (anonymous) pasted "pyths" at http://hpaste.org/3792
13:04:25 <conal> ricky_clarkson: TV generalizes "interact", which is similar to what you're thinking of.
13:05:37 <SimonRC> conal: that looks totally ridiculous out-of-context
13:05:39 * SimonRC goes
13:09:32 <lament> Cale: i guess the main point there is that there're many ways to classify stuff, and by organizing stuff into a hierarchy, you set one of those ways as being the priviliged "real" way (the rest, as you say, can be added with symlinks), and that's really _conceptually_ wrong
13:09:55 <Cale> What's wrong with choosing a system?
13:10:16 <lament> there isn't a "real" way to organize stuff
13:10:18 <desegnis> LoganCapaldo, monochrom: I now realize that FlexibleInstances are needed for this, too.
13:10:24 <Cale> You could use hard links too, I suppose.
13:10:48 <Cale> Then the different ways would be indistinguishable ;)
13:10:50 <yitz> lament: ontology is a powerful and useful technique. But you have to know when and how to use it. It doesn't magically solve every classification problem with no work - far, far from it.
13:11:39 <waern> it would be cool to apply ontology to module systems :)
13:11:43 <yitz> After all - it worked well for physical books in libraries.
13:12:02 <lament> yitz: the article talks about that in detail
13:12:12 <Cale> The filesystem is a graph.
13:12:14 <yitz> right, i'm familiar with it
13:12:20 <lament> yitz: physical books in libraries _do_ have a privileged "true" classification
13:12:40 <lament> so a hierarchical system is not fundamentally wrong
13:12:42 <Cale> You can use a graph to implement an arbitrary relation.
13:12:48 <yitz> ontologies also work when there is not a privileged "true" classification.
13:13:28 <yitz> Cale: but in general searching it is NP-complete.
13:13:36 <lament> the problems start when you're using several classifications
13:14:24 <lament> sure you could keep all your music in two separate places, organized by performer and by composer.
13:14:27 <lament> But that's madness :)
13:15:55 <Cale> lament: Why is it madness? You only put the work in to make those classifications if you care about them.
13:16:04 <Cale> In which case it's not crazy to do it.
13:16:57 <lament> Cale: in this case, because both classifications are not really trees, they're one-level deep
13:17:05 <lament> Cale: which means that they're really tags :)
13:17:27 <Cale> "really"?
13:18:05 <lament> unless you do have sub
13:18:10 <lament> unless you do have sub-classification
13:18:49 <wli> What sort of searching is this?
13:23:21 <hpaste>  LoganCapaldo annotated "Endo + class == no dice?" with "monochron, desegnis FlexibleInstances pretty much does it." at http://hpaste.org/3791#a1
13:27:05 <LoganCapaldo> course this doesn't let me use the built in Endo
13:27:05 <LoganCapaldo> but as far as Haskell abuse goes seems pretty low key
13:28:50 <LoganCapaldo> hmm hpaste doesn't have nick completion. I typoed monochrom
13:29:39 --- mode: irc.freenode.net set +o ChanServ
13:33:23 <monochrom> orly? :)
13:34:03 <dons> i hope kfish knows what pain he inflicted on the world, http://www.rubinsteyn.com/template_insanity.html
13:40:57 --- mode: irc.freenode.net set +o ChanServ
13:48:01 --- mode: irc.freenode.net set +o ChanServ
13:55:10 <dons> Igloo: around?
13:55:40 <yitz> Welcome back, everyone. Thanks for clobbering my scrollback buffer. How often does this craziness happen?
13:56:23 <dons> its rare
13:56:27 <idnar> approximately every time some script kiddie attacks freenode with a nasty DDoS
13:56:32 <wli> It's from DDoS attacks.
13:56:46 <idnar> (or, of course, you have the accidental kind of network failure)
13:56:54 <wli> Which CGI frameworks are oriented toward standalone CGI apps?
13:56:55 <idnar> irssi handles netsplits quite gracefully, which is nice
13:57:26 <Cale> Are you sure? Christel just sent a global notice that they're going to do some rerouting?
13:57:57 <Cale> Is that rerouting due to DDoS attacks?
13:58:11 <wli> My basic thought for the moment is a survey, stuffing the responses in a database, then displaying summary stats.
13:58:36 <wli> (without rotorooting my current webserver configs)
13:58:49 <int-e> Cale: "[...] we're experiencing some routing problems between our US hub and the machine services reside on [...]" was the given reason.
13:59:10 <Cale> yeah
13:59:28 <LoganCapaldo> @type let d = (>> return ()) in d
13:59:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:59:37 <Cale> That's why I found the comment that it's a DDoS attack sort of strange :)
13:59:54 <LoganCapaldo> @let d = (>> return ())
13:59:55 <lambdabot> <local>:6:4:     Ambiguous type variable `m' in the constraint:       `Monad ...
13:59:57 <Cale> Usually when it's a DDoS attack, they don't make announcements :)
14:00:14 <LoganCapaldo> @let d x = (x >> return ())
14:00:18 <lambdabot> Defined.
14:00:25 <LoganCapaldo> whyfor is this so?
14:00:28 <LoganCapaldo> MR?
14:01:05 <yitz> LoganCapaldo: yes/
14:01:26 <yitz> can we request that lambdabot run without MR?
14:01:50 <glguy> Cale: they announced the ddos attack a few days ago at least
14:02:01 <glguy> said they were "working with sponsors to block it"
14:02:04 <Cale> glguy: yeah there was one going on back then
14:02:18 <wli> <Cale:#haskell> lament: Why is it madness? You only put the work in to make
14:02:19 <wli> +those classifications if you care about them.
14:02:35 <wli> Sorry.
14:02:38 <Cale> But the netsplits stopped, so I figured that problem was over :)
14:03:08 --- mode: irc.freenode.net set +o ChanServ
14:03:24 <yitz> dons: how about no MR for lambdabot?
14:03:29 <dons> mmm
14:05:49 <yitz> Those who like MR say it helps avoid certain subtle bugs when writing a module. Could be. But in an interactive environment, it is a major annoyance. I shut it off in y dot-ghci.
14:06:01 <yitz> s/y/my/
14:10:46 <idnar> MR?
14:10:50 <sorear> yitz: you could go like ML and use uninstantiated type variables
14:11:06 <sorear> idnar: monomorphism restriction
14:11:14 <idnar> ah
14:11:18 <yitz> idnar: the nefarious "monomorphism restriction"
14:11:55 <Cale> The MR has caused more subtle bugs for me than it's fixed.
14:12:22 <Cale> For example, back before forM was a library function, I'd written:
14:12:27 <Cale> forM = flip mapM
14:12:36 <Cale> and then used forM in an ST computation
14:12:53 <yitz> What happened?
14:13:05 <Cale> Which changed that ST computation's type to ST () (something)
14:13:20 <yitz> ugh
14:13:24 <chessguy> Cale, you didn't type-annotate forM?
14:13:28 <Cale> nope
14:13:38 <Cale> If I had, it wouldn't have been a problem.
14:13:47 * chessguy makes a mental note to type-annotate *everything*
14:14:03 <Cale> Or just turn the MR off :)
14:14:15 * yitz imagines what chessguy's where clauses are going to look like from now on
14:14:40 <LoganCapaldo> @type on
14:14:41 <lambdabot> Not in scope: `on'
14:15:09 <yitz> Cale: but doesn't MR just cause certain things to be rejected? How did it _cause_your ST problem?
14:15:45 <LoganCapaldo> > let ing f g x y = g x `f` g y in (compare`ing` length) [(), (), ()] []
14:15:46 <lambdabot>  GT
14:16:07 <yitz> GT?
14:16:12 <LoganCapaldo> Greater than
14:16:16 <yitz> ah
14:16:55 <allbery_m> yitz: the MR can cause a particular concrete type to be selected automatically, instead of just causing a type error
14:17:00 <LoganCapaldo> > compare 2 2
14:17:01 <lambdabot>  EQ
14:17:32 <yitz> allbery_m: I just love automation. It saves so much time.
14:17:38 <sorear> @seen cdsmith
14:17:39 <lambdabot> I saw cdsmith leaving #haskell 2m 12d 19h 55m 26s ago, and .
14:17:46 <byorgey> LoganCapaldo: hehe, clever
14:18:11 <sorear> @seen cdsmithus
14:18:11 <lambdabot> I haven't seen cdsmithus.
14:18:20 <allbery_m> basically it only caises an error if it spots you using it with multiple types or in a polymorphic situation.  otherwise it forces a concrete type, which works until you try to use it with another type later on
14:18:31 <allbery_m> (notably in ghci...)
14:18:58 <allbery_m> hnence th suggestion that interactive stuff like ghci or LB's @run should not have the MR
14:19:28 <wli> Or if you wanted a different concrete type.
14:20:17 <allbery_m> another place where it bites is that it interacts with defaulting.  so if you define something that looks like it ought to be polymorphic over Num, it's liable to end up defaulted to Int or Integere
14:20:26 <sorear> allbery_m: it only forces a concrete type at module boundaries, or if you are using GHCi.  This is definitely GHCi's fault; SML toplevels have done the right thing for decades.
14:21:20 <LoganCapaldo> > let ing f g x y = f (g x) (g y) ; add = (+) in (add`ing` length) "byorgey" "LoganCapaldo"
14:21:22 <lambdabot>  19
14:21:51 <idnar> cute
14:21:56 <byorgey> =D
14:22:06 <quicksilver> Cale: ping?
14:22:23 <Nafai> byorgey: So I'm up to problem #10!
14:22:26 <idnar> although I get the feeling it would drive me insane if I looked at enough code that used that "trick"
14:22:32 * byorgey high-fives Nafai!
14:22:41 <idnar> Nafai: of what?
14:22:47 <LoganCapaldo> I'm trying to think of a way to tack an "s" onto length without resorting to let length = lengths
14:22:49 <LoganCapaldo> err
14:22:52 <LoganCapaldo> flip that last
14:22:54 <Nafai> idnar: Project Euler
14:23:02 <Nafai> I'm using it as an excuse to learn Haskell
14:23:05 <idnar> Nafai: oh right, cool
14:23:06 <chessguy> @type flip length
14:23:07 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Int'
14:23:07 <lambdabot>     In the first argument of `flip', namely `length'
14:23:14 <idnar> Nafai: I started doing that as well in Haskell
14:23:17 <Nafai> A lot more manageable than trying to jump into a big application
14:23:28 <idnar> I think I've done the first 20 problems
14:23:40 <Nafai> Yeah, I just started a couple days ago
14:23:41 <idnar> somebody I knew was doing them in Java, and I couldn't resist ;)
14:23:56 <Nafai> I couldn't imagine doing these problems in Java
14:24:09 <Nafai> Haskell is so much more expressive
14:24:20 * byorgey cringes at the thought of doing P.E. in Java
14:24:23 <idnar> I've implemented the solution, and he's still messing around with reading the data from a file or something
14:24:25 <yitz> @type let s = ($) in (length `s`)
14:24:26 <lambdabot> forall a. [a] -> Int
14:24:42 <sorear> that's a gratuitous GHC extension
14:24:44 <idnar> although the only reason he was doing it in Java is to learn Java (he has to do it for one of his courses)
14:24:55 * Nafai nods
14:25:15 <Nafai> We should compare solutions sometime
14:25:29 <Nafai> byorgey has been helping me a bit so I can learn more idiomatic Haskell
14:25:29 <LoganCapaldo> sorear: `` sections?
14:25:41 <idnar> Nafai: mine are in a public darcs repo at http://slipgate.za.net/~mithrandi/darcs/projecteuler/
14:25:43 <lambdabot> Title: Index of /~mithrandi/darcs/projecteuler
14:25:57 <Nafai> Cool, I should do that for mine as well
14:26:00 <sorear> LoganCapaldo: braino
14:26:03 <idnar> Nafai: in most cases, I was just trying to solve the problem with the least amount of effort on my part
14:26:07 * Nafai nods
14:26:18 * LoganCapaldo is truly confused now
14:26:20 <allbery_m> sorear: yeh, actually that's kinda what I said (admittedly incoherently) if you take it with the prior statement about use with multiple types
14:26:28 <allbery_m> cross-module is the only way you could trigger it
14:26:29 <Nafai> I think I'm going to start putting some of my functions into modules
14:26:40 <idnar> so I haven't exactly been trying to write gratuitously un-idiomatic code, but in a lot of cases, the solution could probably be more efficient, or more elegant
14:26:44 <idnar> (or both)
14:26:48 <Nafai> Right now I've just been copying and pasting common functions, like those for finding primes, etc
14:26:49 * wli is taking a stab at #160 now that he's had enough time to forget int-e's solution.
14:26:59 <yitz> idnar, Nafai, if you have anything interesting to add to http://haskell.org/haskellwiki/Euler_problems, please do.
14:27:00 <lambdabot> Title: Euler problems - HaskellWiki
14:27:02 <idnar> yeah, I think I copied my primes implementation half a dozen times
14:27:06 <Nafai> yitz: Thanks
14:27:15 <idnar> although later on, I had to find a more efficient implementation
14:27:35 <Nafai> I'll look as soon as I have #10 done :)
14:27:44 <opqdonut> i have a monad StateT Int Error, how do i do an mplus on the Error part?
14:27:45 <byorgey> wli: heh, that one has given me so much grief... =P
14:27:55 <idnar> generally I was too impatient to wait for longer than 30 seconds to get an answer; in some cases, compiling with optimizations vs. running in ghci was good enough to make it fast enough
14:28:05 <quicksilver> opqdonut: liftM mplus?
14:28:19 <yitz> just mplus
14:28:24 <opqdonut> hmm
14:28:24 <yitz> no lift needed
14:28:35 <yitz> (you mean ErrorT ?)
14:28:38 <quicksilver> yitz: ? mplus alone can't touch the inside of the monad
14:28:45 <quicksilver> ah
14:28:48 <yitz> try it :)
14:28:50 <quicksilver> I misread him :)
14:28:51 <opqdonut> i mean Error = Either String
14:28:52 <LoganCapaldo> opqdonut: yu have a StateT Int Error and you want to mplus the iner Error?
14:28:57 <opqdonut> yes
14:29:06 <quicksilver> I thought he had State Int Error :)
14:29:19 <LoganCapaldo> would you not need to runStateT it
14:29:20 <LoganCapaldo> ?
14:29:21 <yitz> Control.Monad.State provides a built-in lift for that.
14:29:29 <wli> byorgey: I particularly liked my solution for PE#152 but there's not really much Haskell to it.
14:30:01 <byorgey> wli: cool.  well, don't tell me since I haven't solved that one yet =)
14:30:20 <yitz> (i.e., instance MonadPlus m => MonadPlus (StateT s m)
14:30:29 <opqdonut> yitz: oh, that's defined?
14:30:33 <yitz> yep
14:30:39 <opqdonut> ?instances MonadPlus
14:30:40 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:30:41 <byorgey> wli: there's something obvious I'm not getting with that one, because I can't seem to pare down the search space to a manageable enough size
14:30:49 <opqdonut> yitz: thanks a ton :)
14:30:50 <wli> byorgey: The code is not very enlightening as to what went on with the solution.
14:31:04 <byorgey> wli: fair enough, that's often the case =)
14:31:56 <wli> byorgey: It's like Fortran etc.; all the work went on with the math to get the formulas written down. The code itself doesn't say anything.
14:32:11 <wli> (Well, except for the final formula.)
14:33:07 <byorgey> right.  perhaps my problem is that I sometimes jump into coding too soon and then get stuck in an unproductive rut.
14:33:35 <wli> byorgey: If you can massage the problem into the right form there's math stuff that just spits out all the solutions for you.
14:34:11 <byorgey> wli: awesome.  well, I'll have to play around with it more at some point... right after I finish grad school applications =)
14:38:37 <wli> byorgey: Anyway, if you do it the way I did, there is no search. The n-th element has a formula for it, there's a recurrence to get the n+1-st from the n-th, etc.
14:39:11 <hpaste>  jaj pasted ".xmobarc" at http://hpaste.org/3793
14:41:49 <byorgey> wli: ok, good to know. =)
14:41:49 <wli> byorgey: This is the "nugget" problem, right?
14:42:12 <byorgey> wli: I thought you were talking about #152?
14:42:34 <wli> byorgey: I'm trying to make sure I'm talking about the right one.
14:42:46 <visof> i was using ghc-6.6.1 then i try to install ghc-6.8.1 and when i try to run it i had
14:42:48 <visof> /usr/local/lib/ghc-6.8.1/ghc-6.8.1: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory
14:43:02 <visof> what should i do?
14:43:08 <byorgey> wli: #152 is about expressing 1/2 as a sum of reciprocals of squares
14:43:22 <wli> byorgey: Oh, sorry, I was on about #137
14:43:43 <wli> byorgey: #152 has me stumped as well, sorry.
14:43:56 <byorgey> wli: oh, that one!  yes, I've solved that one =)
14:44:00 <byorgey> hehe
14:44:25 <byorgey> wli: and I know what you're talking about with the recurrence
14:44:36 <wli> byorgey: Pell equation blah blah blah, okay.
14:44:41 <byorgey> yeah =)
14:44:59 <shapr> @yow !
14:45:00 <lambdabot> I think my career is ruined!
14:45:04 <shapr> I believe it!
14:45:47 <byorgey> lambdabot's career, ruined?  I doubt it.
14:46:02 <byorgey> @botsnack
14:46:02 <lambdabot> :)
14:46:05 <Nafai> Hey shapr1
14:46:08 <Nafai> er, shapr!
14:46:14 <shapr> hiya Nafai!
14:46:45 <Nafai> How's it going?
14:47:02 <wli> byorgey I've not gotten anywhere on #153 either though I probably should've.
14:48:16 <byorgey> wli: I've not solved #153 yet either.  I think I solved it in the shower once but didn't code it up or write it down, and now I forget =P
14:50:47 <wli> There was some twist that made it more difficult than dealing with the ordinary divisor functions.
14:53:07 <gwern> is -fasm the default if you use -02?
14:58:27 <n00b> can SOE library mix colors
14:58:28 <n00b> ?
14:59:34 <n00b> does it have a color palette ? in stead of the standard colors ?
14:59:49 <sjanssen> gwern: -fvia-c is the default for 6.6, -fasm is the default for 6.8
15:00:55 <gwern> sjanssen: ok. but if you specify -O2 will it change to fvia-c for the small boost I've heard it adds?
15:01:05 <sjanssen> no
15:01:11 <magnus> dons: I am looking for jobs now and I'm wondering what the situation is at galois right now. Could you enlighten me? Also, how strict is the preference for candidates that can obtain security clearance (i.e. US citizens)?
15:01:58 <sjanssen> does anyone know how long the type level instant insanity program should take to execute?
15:02:02 <dons> we're hiring, and US citizens are possibly the minority at galois. european citizens are ok
15:02:18 <magnus> dons: thanks
15:03:26 <n00b> can SOE library mix colors ?
15:04:11 <wli> byorgey: I'm stymied by the summation. Otherwise it'd just be factoring Z over Z[i].
15:04:35 <dons> n00b: we saw your earlier questoin. i'm not sure anyone uses SOE enough to know.
15:05:40 <byorgey> wli: right, the summation is what makes it interesting.
15:09:00 <sjanssen_> instant insanity made my box thrash so hard I had to restart :(
15:09:01 <gwern> ...oops.
15:09:24 <n00b> ok
15:09:30 <sjanssen_> I wonder if it works correctly with ghc 6.8.1
15:10:10 <gwern> so, uh, I have two local repositories of something, a and b. I record a patch in a, but a is messed up so I pulled a's new patch from b, and I deleted a because I no longer needed it. then I build everything and test inside b, and I go to darcs send - but now that new patch is not a local patch >.<
15:17:25 <wli> byorgey: One evil thing is that the prime factorization isn't really the key. For instance, the divisors of 5 being 1, 1 + 2*i, 1 - 2*i, 2 + i, 2 - i, and 5 gets divisors differing only by sign, which is horrible.
15:17:32 <sjanssen_> @seen kfish
15:17:32 <lambdabot> I saw kfish leaving #haskell 1d 13h 17m 20s ago, and .
15:22:00 <Cale> dcoutts: I just noticed that it would be really convenient if there were a package which contained cabal-install and all its dependencies with a script that built and installed them all.
15:22:24 <chessguy> @quote
15:22:24 <lambdabot> metaperl says: I never thought anyone could be on IRC as much as you and look that good
15:22:38 * chessguy preens
15:23:21 <wli> byorgey: It's more like enumerating a^2+b^2=n s.t. a > 0
15:23:57 <byorgey> wli: right, for all divisors n of the integer in question... or something like that
15:24:10 <Nafai> Man, looking at the solutions on that wiki page makes my solutions seem very verbose
15:24:11 <wli> byorgey: Or perhaps a^2+b^2 <= n
15:24:30 <chessguy> @quote verbose
15:24:30 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
15:25:11 <dcoutts> Cale: mm
15:25:56 <byorgey> Nafai: well, they probably are, but that's OK.  It takes a while to develop a sense for doing things idiomatically/concisely.
15:26:03 * Nafai nods
15:26:37 <byorgey> someone should write a book called "How to learn Haskell in 24 hours"
15:26:38 <thoughtpolice> @pl \ s -> f (s*16)
15:26:38 <lambdabot> f . (16 *)
15:26:57 <byorgey> and then when you open it up, it just laughs at the reader for even thinking such a book could exist
15:27:06 <puusorsa> Teach yourself Haskell in 24 hours
15:29:24 <Cale> dcoutts: Currently "bootstrapping" is a little annoying, since you have to get HTTP, zlib, and Cabal at least before you can get to cabal-install
15:29:40 <dcoutts> Cale: yes
15:29:57 <dcoutts> Cale: and it might get worse in future if we add more stuff into cabal-install
15:30:14 <thoughtpolice> @index liftIO
15:30:14 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:30:32 <dcoutts> Cale: but what would that package be? would it just be another cabal package that bundles all it's deps internally?
15:30:43 <Cale> I suppose it could be
15:30:59 <Cale> Eventually, I hope cabal-install will come packaged with ghc :)
15:31:38 <dcoutts> Cale: well it'd come with the 'jumbo' installer, but not the minimal ghc tarball which has only the packages needed to bootstrap
15:31:47 <Cale> yeah
15:32:17 <sjanssen> dcoutts: it could simply be a bundle of several packages with a packaged shell script "for i in x y z; do cd $i; Setup configure ..."
15:32:19 <dcoutts> and imho we need to make a platform distribution that is not synchronised with the ghc release schedule
15:32:37 <dcoutts> sjanssen: except for windows
15:32:52 <LoganCapaldo> course now that import works at the ghci toplevel, I've starting doing :import
15:32:53 <sjanssen> dcoutts: yeah, you'd need a .bat too
15:32:56 * LoganCapaldo sighs
15:33:06 <sjanssen> alternatively, just make some generic Linux and Windows binaries
15:33:13 <dcoutts> sjanssen: there's no reason one cannot make a package that bundles the other dependent packages
15:34:05 <sjanssen> dcoutts: except it's not so nice to dump everything into one tree, IMO
15:34:35 <dcoutts> sjanssen: it ought to be straightforward to make a program that generates a package that bundles certain of it's deps
15:34:38 <rabbit64> @pl \y -> [x | x <- y]
15:34:39 <lambdabot> return . ((x | x) <-)
15:34:40 <rabbit64> doesn't work?
15:34:57 <dcoutts> sjanssen: so it does not need to be kept that way in the darcs tree, just generated for distribution
15:35:00 <allbery_m>  @pl dioesn't undertand list comprehensions
15:35:29 <rabbit64> how to reduce it then?
15:35:36 <dcoutts> sjanssen: if the dependent package does not have clashing hidden modules then it should be easy to build it as one lib/exe
15:35:41 <Cale> rabbit64: that looks like id
15:35:46 <allbery_m> (or monadic "do" syntax, which is solveable by composing with undo)
15:36:08 <rabbit64> yes, I meant that type of expression [x | ...something very complicated...]
15:36:18 <allbery_m> @. pl undo \y -> do {x <- y; return x }
15:36:18 <lambdabot> id
15:36:45 <allbery_m> I don't think there's a list comprehension desugarer but it's easy to convert to monadic then use @undo
15:36:51 <sjanssen> dcoutts: yes, that's true
15:36:58 <sjanssen> dcoutts: it's an interesting idea
15:37:38 <sjanssen> dcoutts: it should probably only be done for executables
15:37:43 <dcoutts> sjanssen: yes it might be interesting to make a cabal-bundle tool
15:37:55 <rabbit64> okey, thanks
15:37:56 <dcoutts> sjanssen: yes, I guess so
15:38:24 <dcoutts> sjanssen: it'd be ok for privately used libs, but not if it exposes types via the public lib api
15:39:09 <dcoutts> sjanssen: and in fact configurations should make it possible to use either the installed or bundled version
15:39:20 <dcoutts> with preference for the installed
15:39:35 <sjanssen> dcoutts: exactly (re: exposed types)
15:41:13 <Cale> Do we have a workaround for the conftest.c thing yet?
15:41:38 <dcoutts> Cale: yes, it's fixed in Cabal HEAD, or in the older Cabal-1.2.1 or mkdir dist
15:41:48 <Cale> ah
15:42:08 <dcoutts> Cale: the fix will be included in the next Cabal-1.2.x release which will be in ghc-6.8.2
15:42:37 <dons> ?undo [ x | x <- [1..] ]
15:42:38 <lambdabot> concatMap (\ x -> [x]) [1 ..]
15:42:43 <dons> ?unpl [ x | x <- [1..] ]
15:42:43 <lambdabot> [x | x <- [1 ..]]
15:42:48 <dons> ?. pl undo [ x | x <- [1..] ]
15:42:48 <lambdabot> [1..]
15:42:51 <dons> nice
15:42:57 <dons> ?. pl undo [ x | x <- [1..], odd x ]
15:42:57 <lambdabot> flip (liftM2 if' odd return) [] =<< [1..]
15:43:00 <dons> mm
15:43:15 <Bacta> what does the ^ operator mean in Haskell?
15:43:42 <dons> > 2 ^ 4
15:43:42 <Heffalump> @type (^)
15:43:44 <lambdabot>  16
15:43:44 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:43:52 <Heffalump> integer exponentiation
15:43:54 <Bacta> ah, power
15:44:13 <rabbit64> @type (liftM2)
15:44:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:44:23 <allbery_m> ah, @undo does handle comprehensions
15:44:29 <Bacta> so no wonder when I did (^3) 1 I was getting 1 not 2 :P
15:44:47 <allbery_m> well, sort of.  why if' when filter?
15:45:03 <dons> there's no rhyme nor reason to @pl :)
15:45:22 <Altair^> why does my call "let a = array (0,3) [1,2,3,4]" fail in ghci?
15:45:29 <Heffalump> @type if'
15:45:30 <lambdabot> Not in scope: `if''
15:45:38 <rabbit64> @type (monad)
15:45:40 <lambdabot> Not in scope: `monad'
15:45:46 <allbery_m> "if'" is @pl's way of saying it can't do if x then y else z
15:45:52 <byorgey> Altair^: what error do you get?
15:46:00 <Cale> dcoutts: ah, great :)
15:46:02 <Heffalump> more importantly, it can't curry it
15:46:15 <Altair^>  No instance for (Num (t, e))
15:46:15 <Altair^>       arising from the literal `1' at <interactive>:1:21
15:46:15 <Altair^>     Possible fix: add an instance declaration for (Num (t, e))
15:46:17 <byorgey> Altair^: oh, wait, look at the type of array
15:46:21 <byorgey> @type array
15:46:22 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
15:46:33 <rabbit64> @type (=<<)
15:46:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:46:38 <dcoutts> Cale: want to help hack on cabal-install? :-) we need more helpers
15:46:39 <byorgey> Altair^: the second argument to array needs to be a list of (index, element) pairs
15:47:14 <Altair^> ah ok
15:47:15 <LoganCapaldo> array (0, 3) (zip [0..] [1,2,3])
15:47:27 <rabbit64> ehm...that monad is module or what?
15:47:52 <LoganCapaldo> > let indexed = zip [0..] in array (0,3) (indexed [1,2,3,4])
15:47:53 <shachaf> LoganCapaldo: [1..4], no?
15:47:54 <lambdabot>  array (0,3) [(0,1),(1,2),(2,3),(3,4)]
15:47:59 <shachaf> rabbit64: It's a type class.
15:48:15 <LoganCapaldo> shachaf: what I'm not allowed to make mistakes? <g>
15:48:45 <Cale> dcoutts: what needs doing?
15:48:52 <rabbit64> I guess I should read some manual :)
15:49:22 <pjd> rabbit64: Monad is closely related to Functor
15:49:28 <dcoutts> Cale: lots of stuff, we have a list of things in the track. but the most important imho is unifying the command line UI of cabal-setup and cabal-install.
15:49:48 <dcoutts> Cale: there's some easy ones listed in the trac too.
15:49:48 <rabbit64> still nothing... :D
15:49:56 <shachaf> rabbit64: That (Monad m) => is like (Num a) => in (+).
15:49:59 <shachaf> @ty (+)
15:50:00 <lambdabot> forall a. (Num a) => a -> a -> a
15:50:23 <dcoutts> Cale: and design work, like deciding how global installs should work
15:50:31 <pjd> rabbit64: an example of Functor would be the map function for lists
15:50:39 <shachaf> This means "for any Num a, a function :: a -> a -> a" (where Integer, Double, etc. are Nums).
15:50:51 <rabbit64> so Monad type is like a binary function?
15:50:57 <shachaf> rabbit64: Monad isn't a type.
15:50:59 <pjd> Functor is the generalized version of that
15:51:04 <shachaf> @src Monad
15:51:05 <lambdabot> class  Monad m  where
15:51:05 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:51:05 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:51:05 <lambdabot>     return      :: a -> m a
15:51:05 <lambdabot>     fail        :: String -> m a
15:51:23 <dcoutts> Cale: so as you know, cabal-setup has the same command line UI as runghc Setup.hs. Then cabal-install has a separate one for no good reason.
15:51:25 <Cale> rabbit64: Monad is a typeclass for types which support those operations there
15:51:30 <shachaf> rabbit64: It's a type class -- a collection of types.
15:51:33 <shachaf> @instances Monad
15:51:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:51:48 <shachaf> All of those are Monads.
15:52:00 <dcoutts> Cale: we should have a single UI with commands for both devs and more end-user-like actions.
15:52:31 <rabbit64> lol, thanks for trying to help me...but I will rather read a manual...
15:52:39 <rabbit64> I'm really a beginner
15:52:59 <shachaf> rabbit64: Do you understand the (Num a) => in (+)?
15:53:05 <dcoutts> Cale: we really want cabal-install to just 'extend' the command line UI defined in the Cabal lib. We'd like to do that in a nice way rather than a hacky way.
15:53:16 <rabbit64> shachaf, i think yes
15:53:39 <shachaf> rabbit64: As pjd suggested, you should probably look at Functor first.
15:53:43 <shachaf> @ty map
15:53:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:53:57 <pjd> :t fmap
15:53:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:54:03 <shachaf> map gets a function :: a -> b and a list of as, and returns a list of bs.
15:54:10 <rabbit64> and fmap?
15:54:13 <shachaf> fmap works for any Functor.
15:54:18 <shachaf> Lists are Functors.
15:54:23 <shachaf> > fmap (+1) [1,2,3]
15:54:23 <pjd> the list map is fmap for lists
15:54:24 <lambdabot>  [2,3,4]
15:54:28 <shachaf> Maybes are also Functors:
15:54:35 <shachaf> > fmap (+1) (Just 5)
15:54:36 <lambdabot>  Just 6
15:54:40 <shachaf> > fmap (+1) Nothing
15:54:41 <lambdabot>  Nothing
15:54:53 <shachaf> @instances Functor
15:54:54 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:54:55 <rabbit64> moment how can you add 1 to "just 5", is it not a type?
15:55:02 <shachaf> rabbit64: It's a value.
15:55:09 <pjd> @src Maybe
15:55:10 <lambdabot> data Maybe a = Nothing | Just a
15:55:25 <shachaf> rabbit64: In Maybe, fmap's type is :: (a -> b) -> Maybe a -> Maybe b
15:55:36 <shachaf> rabbit64: Oh, I forgot; have you seen Maybe yet?
15:55:48 <rabbit64> maybe :)
15:55:52 <rabbit64> yes
15:55:53 <LoganCapaldo> groan
15:56:05 <rabbit64> i will try to put it in hugs
15:56:08 <pjd> rabbit64: Maybe is basically an optional value
15:56:41 <shachaf> rabbit64: Another way to think of it is as a one-element list.
15:56:46 <pjd> something returning Maybe foo returns either Just foo, or Nothing
15:56:55 <LoganCapaldo> zero or one element list
15:57:15 <rabbit64> yes I know that
15:57:19 <shachaf> > find even [1,2,3,4]
15:57:20 <lambdabot>  Just 2
15:57:25 <shachaf> > find even [1,3]
15:57:26 <lambdabot>  Nothing
15:57:31 <pjd> fmap lets you apply a function to a Maybe value, without the function having to know about Maybe
15:57:47 <shachaf> rabbit64: Now, if you want to work on the inside of the Maybe, you have to extract it, deal with it, and rewrap it.
15:57:49 <allbery_m> or you can use pattern matching to extract it
15:58:04 <shachaf> rabbit64: Or just leave it undealt with if it's Nothing.
15:58:11 <allbery_m> case x of Just y -> y; Nothing -> (provide a default)
15:58:11 <pjd> allbery_m: which is what fmap does :)
15:58:12 <rabbit64> how is fmap defined, please?
15:58:24 <shachaf> rabbit64: It's different for every Functor.
15:58:26 <LoganCapaldo> @src Maube fmap
15:58:26 <lambdabot> Source not found. Wrong!  You cheating scum!
15:58:31 <LoganCapaldo> @src Maybe fmap
15:58:31 <shachaf> @src Maybe fmap
15:58:32 <lambdabot> fmap _ Nothing       = Nothing
15:58:32 <lambdabot> fmap f (Just a)      = Just (f a)
15:58:32 <lambdabot> fmap _ Nothing       = Nothing
15:58:32 <lambdabot> fmap f (Just a)      = Just (f a)
15:59:26 <Cale> dcoutts: hmm :) Currently I'm pretty clueless about how Cabal actually works internally, so I'll probably have to look at that a bit :)
15:59:29 <pjd> for comparison,
15:59:29 <pjd> @src [] fmap
15:59:30 <lambdabot> fmap = map
15:59:39 <pjd> well
15:59:41 <pjd> @src map
15:59:42 <lambdabot> map _ []     = []
15:59:42 <lambdabot> map f (x:xs) = f x : map f xs
15:59:52 <rabbit64> btw if i type maybe Int, it is Nothing | Just int?
16:00:08 <pjd> rabbit64: more or less
16:00:13 <LoganCapaldo> yeah effectively
16:00:16 <shachaf> rabbit64: A value of type Maybe Int is either Nothing or Just a value of type Int.
16:00:22 <rabbit64> what is the difference between Just int and int?
16:00:34 <shachaf> rabbit64: One is wrapped in a Just constructor.
16:00:36 <LoganCapaldo> About four letters :)
16:00:38 <pjd> Just Int is an Int wrapped in a Maybe
16:01:04 <shachaf> rabbit64: You have to deal with the Maybe-ness explicitly -- you can't say:
16:01:08 <shachaf> > (Just 1) + 2
16:01:08 <lambdabot>   add an instance declaration for (Num (Maybe t))
16:01:09 <lambdabot>     In the expression: (Jus...
16:01:09 <puusorsa> Maybe Just Nothing
16:01:28 <LoganCapaldo> @type Just
16:01:29 <lambdabot> forall a. a -> Maybe a
16:01:47 <LoganCapaldo> Just is a function taking as and turning them into Maybe as
16:02:07 <pjd> rabbit64: it's like an Int versus a list of one Int
16:02:09 <rabbit64> uff, so Maybe x = Nothing | Just x, and Just x is Maybe x (from forall a. a -> Maybe a)?? o_O
16:02:28 <LoganCapaldo> fmap is a function that takes a function operating on as and turns them into functions operating on Maybe as
16:02:33 <shachaf> rabbit64: The first thing you said is the data declaration.
16:02:36 <shachaf> @src Maybe
16:02:36 <lambdabot> data Maybe a = Nothing | Just a
16:02:43 <rabbit64> @src Just
16:02:43 <lambdabot> Source not found. Where did you learn to type?
16:03:05 <pjd> Just and Nothing are Maybe's constructors
16:03:07 <shachaf> rabbit64: Just is really two things -- a function that wraps a value in a Just, and a mechanism to pattern-match in a function that accepts a Maybe.
16:03:31 <Cale> :t Just 5
16:03:33 <lambdabot> forall t. (Num t) => Maybe t
16:03:37 <Cale> :t Just "Hello"
16:03:38 <lambdabot> Maybe [Char]
16:03:43 <Cale> :t Nothing
16:03:44 <lambdabot> forall a. Maybe a
16:03:47 <rabbit64> this is quite weird
16:04:08 <mrd> :t Just undefined
16:04:09 <lambdabot> forall a. Maybe a
16:04:15 <Cale> > let f Nothing = 0; f (Just x) = x^2 in [f Nothing, f 5, f 7]
16:04:16 <lambdabot>   add an instance declaration for (Num (Maybe t))
16:04:19 <rabbit64> So...if something is Nothing | Int, is it equal to Nothing | Just int ?
16:04:29 <Cale> > let f Nothing = 0; f (Just x) = x^2 in [f Nothing, f (Just 5), f (Just 7)]
16:04:31 <lambdabot>  [0,25,49]
16:04:32 <shachaf> rabbit64: There isn't a Nothing | Int.
16:04:45 <shachaf> rabbit64: If it's a Maybe, it has to be a Just something or a Nothing.
16:05:11 <mrd> Just 1 :: Maybe Int
16:05:21 <mrd> left side is value, right side is type
16:05:32 <dcoutts> Cale: cabal-install is a good bit smaller than the Cabal lib.
16:05:45 <rabbit64> So there is no String | Int ?
16:05:50 <Cale> dcoutts: cool
16:06:00 <Cale> rabbit64: Haskell doesn't have untagged union types
16:06:00 <shachaf> rabbit64: String | Int?
16:06:09 <dmwit> rabbit64: Either String Int ?
16:06:13 <rabbit64> yes?
16:06:22 <rabbit64> or no? (???)
16:06:24 <dmwit> Then you can have Left "blah" and Right 42.
16:06:26 <Cale> rabbit64: When we define a new type, the values have to be tagged with constructors
16:07:14 <Cale> So in a data declaration, you have a bunch of things in the format:  <data constructor> <type> <type> <type> ...
16:07:24 <Cale> and each of those is separated by the | symbol
16:07:31 <pjd> rabbit64: maybe it will help to take a quick detour to http://en.wikibooks.org/wiki/Haskell;  check the "Type basics" and "Type declarations" chapters
16:07:32 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
16:07:42 <Cale> The types listed after each data constructor are the parameters to that constructor
16:07:51 <Cale> the types of the parameters, rather
16:07:57 <Cale> For example:
16:08:05 <Cale> data Person = P String Integer
16:08:14 <Bacta> Hey I have this function : firstSquare n = take 1 ([p | p <- n, p > 100000]) , how could I get it so it automatically feeds in a list of the first 20 powers of 2
16:08:16 <Bacta> ?
16:08:22 <Cale> Then (P "Cale" 24) has type Person
16:09:00 <rabbit64> hmm,...thx 4 help, i'll check that book, sorry for bothering with floaters
16:09:02 <shachaf> Bacta: Call the function with an argument? :-)
16:09:06 <Cale> firstSquare [2^n | n <- [0..20]] ?
16:09:26 <Bacta> ah :)
16:09:27 <Bacta> thanks
16:09:55 <Cale> firstSquare seems deceptively named though :)
16:10:31 <gwern> has anyone written a shell in haskell yet? It seems like the next logical step - there are editors, window managers, media players and games in haskell, so...
16:10:35 <Bacta> I was doing (iterate (*2)1)
16:10:45 <Japsu> hshell hmm
16:11:02 <shachaf> Bacta: You can use take to take a certain number of elements from a list.
16:11:06 <LoganCapaldo>  > iterate (*2) 1
16:11:24 <shachaf> > iterate (*2) 1 -- Without the space
16:11:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:11:55 <LoganCapaldo>  > take 20 $ iterate (*2) 1
16:12:07 <Bacta> so how can I do this: firstSquare n = take 1 ([p | p <- squares, p > 100000]) without having to pass it a list?
16:12:13 <LoganCapaldo> dude
16:12:15 <rabbit64> > let x = f f f f (+1) 0 where f g = g . g in x
16:12:17 <lambdabot>  65536
16:12:18 <shachaf> Bacta: Do what?
16:12:18 <LoganCapaldo> lambdabot so hates me
16:12:32 <Bacta> firstSquare n = take 1 ([p | p <- squares, p > 100000]) and not have to pass in a list of squares
16:12:48 <shachaf> LoganCapaldo: She hates your spaces.
16:12:49 <LoganCapaldo> > 1
16:12:50 <lambdabot>  1
16:12:54 <Nafai> gwern: It does seem natural, especially since I'm finding (I'm just new to Haskell) that a lot of my code feels like I'm piping data from one thing to another, just like you would in a shell
16:12:56 <LoganCapaldo> what spaces?
16:13:02 <Bacta> oh wait :)
16:13:04 <Bacta> I've got an idea
16:13:06 <shachaf> Bacta: What do you want to do with it?
16:13:17 <shachaf> < LoganCapaldo>  > take 20 $ iterate (*2) 1
16:13:29 <shachaf> Notice the double space.
16:13:30 <Nafai> gwern: If I squint hard enough, my $ and . look like | :)
16:13:33 <Cale> gwern: a few people have written some things, but there hasn't been anything which has really taken off
16:13:38 <rabbit64> > let x = f f f f f (+1) 0 where f g = g . g in x
16:13:39 <lambdabot>  Exception: stack overflow
16:13:42 <rabbit64> haha
16:13:48 <LoganCapaldo> I did not see any leading space on my screen. Also bizzare that it happened multiple times thugh
16:13:55 <LoganCapaldo> *though
16:14:10 <Bacta> firstSquare = take 1 ([p | p <- (take 20 ( iterate (*2) 1)), p > 100000])
16:14:10 <Cale> Nafai: yeah, bash really prepared me quite well for lazy functional programming. I once wrote an entire IRC bot as a single shell pipeline :)
16:14:11 <Bacta> :D
16:14:17 <LoganCapaldo> > 1
16:14:18 <lambdabot>  1
16:14:21 <LoganCapaldo>        > 1
16:14:21 <Bacta> i love this take and iterate thing
16:14:31 <rabbit64> lol
16:15:09 <Bacta> but the idea of "take" is kind of ambiguous because it keeps making me think there is still something in the background generating powers of 2 for ever and ever :P
16:15:22 <Cale> there is
16:15:27 <pjd> non-strict evaluation!
16:15:36 <Cale> It just stops running when you stop taking things from it
16:15:52 <shachaf> It probably isn't there anymore. :-)
16:16:04 <LoganCapaldo> and it's not "in the background"
16:16:06 <Bacta> so how many lines of Java or C would it take me to write the same thing?
16:16:10 <Bacta> I imagine a lot
16:16:30 <Cale> Not too many in this particular case really.
16:16:41 <Cale> Make it slightly more complicated, and it'll start getting hairy :)
16:16:44 <LoganCapaldo> unless ghc secretly got parallelism and turned it on automatically while I wasn't looking.
16:16:49 <Nafai> Cale: :)
16:16:58 <pjd> > take 1 . filter (100000<) $ iterate (*2) 1
16:17:00 <lambdabot>  [131072]
16:17:08 * thoughtpolice is having fun trying to get an arithmetic compiler with harpy working :)
16:17:25 <pjd> s/take 1/head/, for that matter
16:17:38 <thoughtpolice> i'm thinking i'll replace my alex/happy stuff with a shunting yard implementation though. since the asm operations are largely stack based anyway
16:17:43 <Bacta> so that question was worth 3 marks in the 2006 exam
16:17:48 <Bacta> I'm gonna kick ass :)
16:18:58 <LoganCapaldo> man I wish I had exams on haskell
16:19:04 <Bacta> oh? :P
16:19:05 <rabbit64> ahhh, stupid exam...who would say that const id is curry snd and not \x -> x
16:19:07 <Bacta> what do you have em on
16:20:32 <byorgey> rabbit64: const id is not \x -> x.
16:20:42 <byorgey> \x -> x is id.
16:20:55 <rabbit64> i know, stupid mistake
16:21:32 <rabbit64> Btw I had a dream about that const function chasing me a month before the exam
16:21:35 <rabbit64> really
16:21:39 <byorgey> haha!
16:27:06 <Cale> const isn't so scary if it hasn't already eaten something else
16:27:19 <Cale> But once it has, you'd better watch out.
16:28:25 <byorgey> > const "aiee!" $ "Cale"
16:28:26 <lambdabot>  "aiee!"
16:28:34 <rabbit64> I think I couldn't find out if const had eaten something else before ;)
16:28:35 <rabbit64> aww
16:28:41 <davidL> Cale: I'm curious how you created the mathematica plugin for lambdabot, did you use MathLink?
16:29:12 <Cale> davidL: no
16:29:37 <Cale> davidL: It's really an ugly hack. I just wrote a shellscript wrapper around the mathematica kernel
16:30:02 <Cale> MathLink would be the "right way" to do it though
16:30:09 <davidL> oh
16:31:26 <Cale> This way though, it looks exactly like the Eval plugin, but with runplugs replaced with my shell script.
16:31:35 <conal> there's a mathematica plugin?
16:31:41 <shachaf> conal: For mbot.
16:31:52 <shachaf> conal: (In #math.)
16:32:01 <Cale> % Integrate[Sqrt[Cos[x]],x]
16:32:01 <conal> shachaf: oh!
16:32:03 <mbot> Cale: 2*EllipticE[x/2, 2]
16:32:15 <Cale> mbot: @part #haskell
16:32:33 <conal> cool
16:33:15 <shachaf> Can I ?where zap now? :-)
16:33:24 <shachaf> (Actually, mbot doesn't know that one.)
16:34:31 <Olathe> @where botlife
16:34:31 * lambdabot lives.
16:34:32 <Bacta> why can't I do something like: grade (>85 <100) = "A+" ?
16:35:15 <Cale> grade x | x > 85 && x < 100 = "A+"
16:35:26 <Bacta> ah thanks :)
16:35:33 <rabbit64> >"asd"
16:35:39 <Cale> > "asd"
16:35:48 <lambdabot>  "asd"
16:35:57 <Olathe> > ['a', 's', 'd']
16:35:58 <lambdabot>  "asd"
16:36:17 <rabbit64> > putStr "asd"
16:36:19 <lambdabot>  <IO ()>
16:38:16 <scook0> > liftM2 (&&) (>85) (<100) 93
16:38:18 <lambdabot>  True
16:38:47 <rabbit64> @pf x -> a /close x
16:38:47 <lambdabot> Maybe you meant: bf pl
16:38:49 <conal> > liftA2 (&&) (>85) (<100) 93
16:38:50 <lambdabot>  True
16:39:05 <conal> (no need to get monadic)
16:40:02 <shachaf> > (&&) <$> (>85) <*> (<100) $ 93 -- Hmm, the liftA2 version looks better.
16:40:03 <lambdabot>  True
16:40:27 <Japsu> hmm
16:40:31 <shachaf> sjanssen: Did you ever end up implementing the nice idiom brackets for GHC?
16:40:33 <Japsu> which monad and which arrow is that?
16:40:42 <sjanssen> shachaf: nope
16:40:43 <shachaf> Japsu: (r ->)
16:40:46 <conal> Japsu: ((->) a)
16:40:50 <shachaf> Japsu: A is Applicative, not Arrow.
16:40:53 <Japsu> oh
16:41:03 <Japsu> hmmm
16:41:06 <byorgey> and it's ((->) r) for both.
16:41:12 <Bacta> whats something good to write to practice my Haskell?
16:41:14 * Japsu needs to read the monad guide
16:41:17 <Bacta> something largish but not too complicated
16:41:28 <Japsu> (All About Monads, that is)
16:41:33 <rabbit64>  
16:41:39 <Japsu> rabbit64:
16:42:01 <byorgey> Bacta: an interpreter for a simple programming language, perhaps?
16:42:02 <rabbit64> just testing the lambdabot
16:42:11 <shachaf> rabbit64: You can /msg her.
16:42:13 <Bacta> byorgey: Wayyy too hard :P
16:42:32 <byorgey> Bacta: well, I think it would be less hard than you think, but ok =)
16:42:35 <shachaf> Bacta: Why?
16:42:41 <Bacta> need to practice for my exam
16:43:25 <byorgey> Bacta: try some Project Euler problems?
16:43:35 <shachaf> Bacta: I mean, why is it too hard?
16:43:40 <Bacta> oh Project Euler
16:43:42 <Bacta> good idea
16:47:09 <Brian`> anyone knows any haskell group in new york?
16:48:11 <rabbit64> Some kind of extremist group, that is trying to take over the government?
16:48:29 <Brian`> lol just user group
16:48:36 <shachaf> Brian`: See http://www.haskell.org/haskellwiki/User_groups
16:48:36 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
16:48:37 <lambdabot> Title: User groups - HaskellWiki
16:48:59 <rabbit64> :]
16:49:21 <Brian`> does "New York Functional Programmers Network Inaugural Meeting" still have regular meeting?
16:49:24 <Brian`> does anyone know?
16:49:28 <rabbit64> Sorry it's too late, I'm getting mad
16:50:08 <Brian`> mad at what?
16:50:15 <Brian`> mad at the fact that there is no more meetings!?
16:50:30 <rabbit64> yes exactly! :)
16:50:36 <byorgey> Brian`: well, they probably don't have regular Inaugural meetings =)
16:51:17 <goalieca> how can i build an "extra library", in this case STM, without rebuilding all of ghc
16:52:40 <Lemmih> goalieca: Install it like any other library.
16:53:52 <thoughtpolice> hm, if I wanted to get started using data.generics, what'd be a good read? there're some papers on the wiki but I'm not totally sure where to start
16:56:35 <shachaf> @where syb
16:56:36 <lambdabot> http://www.cs.vu.nl/boilerplate
16:56:40 <goalieca> Lemmih, i see no makefile or anything.
16:56:47 <shachaf> thoughtpolice: There are papers and slides there.
16:56:57 <Lemmih> goalieca: Use cabal.
16:58:45 <thoughtpolice> shachaf: appreciated :)
17:02:48 <chessguy> @bot
17:02:48 <lambdabot> :)
17:02:58 <sjanssen> @seen ChilliX
17:02:58 <lambdabot> I saw ChilliX leaving #ghc and #haskell 1d 18h 36m 21s ago, and .
17:05:27 <dons> early sunday in .au, probably not online today
17:13:33 <Bacta> how can I get getFibonacciNumbers = [fibonacci(p) | p <- take 10 (iterate (+1) 1)] to only give me numbers < 1 000 000 ?
17:13:42 <ikegami--> hello
17:14:04 <dons> ?google fibonacci site:haskell.org
17:14:05 <Olathe> Bacta: takeWhile (< 1000000) that
17:14:06 <lambdabot> http://www.haskell.org/~pairwise/intro/section1.html
17:14:06 <lambdabot> Title: Haskell for C Programmers
17:14:12 <dons> hmm
17:14:26 <ikegami--> I revised the instruction of Flymake Haskell on Emacs at http://www.emacswiki.org/cgi-bin/emacs/FlymakeHaskell
17:14:28 <lambdabot> Title: EmacsWiki: FlymakeHaskell
17:14:34 <ikegami--> I wish it helps you
17:14:37 <Olathe> > let getFibonacciNumbers = [fibonacci(p) | p <- take 10 (iterate (+1) 1)] in takeWhile (< 1000000) getFibonacciNumbers
17:14:38 <lambdabot>   Not in scope: `fibonacci'
17:14:41 <dons> Bacta: http://haskell.org/haskellwiki/The_Fibonacci_sequence
17:14:43 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
17:14:50 <Olathe> Bah.
17:14:57 <dons> but yes, use takeWhile
17:15:55 <Bacta> my Fibonacci sequence works fine :)
17:17:21 <ikegami--> I thank dons that he encourgas me to write the document at Wiki.
17:18:17 <byorgey> Bacta: instead of take 10 (iterate (+1) 1), you can just say [1..10] =)
17:18:24 <dons> ikegami--: :)
17:18:28 <dons> i'm glad its going well
17:19:21 <byorgey> Bacta: and [fibonacci p | p <- [1..10]] is just (map fibonacci [1..10])
17:20:53 <Bacta> well I've just stuck to the iterate method because I need to keep going until I get a number > 1 000 000
17:21:23 <byorgey> Bacta: well, then you can just use [1..]
17:21:26 <Bacta> man it gets slow when I get to larger numbers :(
17:21:30 <dobblego> iterate (+1) 1 === [1..]
17:21:35 * sjanssen loves 5850 line ghc error messages!
17:21:48 <byorgey> Bacta: how did you implement the fibonacci function?
17:21:55 <Bacta> badly :P just a sec
17:22:01 <Bacta> fibonacci 1 = 1
17:22:01 <Bacta> fibonacci 2 = 2
17:22:01 <Bacta> fibonacci n = fibonacci(n-1) + fibonacci(n-2)
17:22:03 * byorgey 's jaw drops
17:22:11 <byorgey> ah. that's what I suspected =)
17:22:17 <dobblego> heh, id!
17:22:19 <Bacta> yes theres a heap of recursion going on here :P
17:22:26 <byorgey> Bacta: writing fibonacci in that way is rather ineffient =)
17:22:30 <Bacta> it is :P
17:22:37 <Bacta> I was thinking if I made previous values into a list
17:22:43 <Cale> > fix ((0:) . scanl (+) 1)
17:22:44 <Bacta> then it wouldn't have to go through so much computation
17:22:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:22:56 <dobblego> fibonacci n = memo fibonacci (n-1) + memo fibonacci (n-2)
17:22:57 <byorgey> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:22:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:23:27 <byorgey> Bacta: there you have the two favorite ways to generate fibonacci numbers in Haskell
17:23:39 <Cale> fib and fac are getting tired though. Let's work on the derangements sequence :)
17:23:53 <Cale> let derangements 0 = 1; derangements 1 = 0; derangements n = (n-1) * (derangements (n-1) + derangements (n-2)) in map derangements [0..]
17:23:58 <Cale> > let derangements 0 = 1; derangements 1 = 0; derangements n = (n-1) * (derangements (n-1) + derangements (n-2)) in map derangements [0..]
17:24:02 <lambdabot> Terminated
17:24:03 <goalieca> is there any special linking flag i need to use when using STM
17:24:06 <Cale> hmm :)
17:24:09 <goalieca> i keep getting undefined references for STM
17:24:10 <Cale> > let derangements 0 = 1; derangements 1 = 0; derangements n = (n-1) * (derangements (n-1) + derangements (n-2)) in map derangements [0..20]
17:24:12 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32...
17:24:27 <Cale> goalieca: --make
17:24:43 <Cale> Or -package stm, I think
17:24:47 <Bacta> "Find the sum of all the even-valued terms in the sequence which do not exceed one million.
17:24:48 <Bacta> "
17:24:58 <Bacta> so the problem is not completely finished yet, just need to put the `mod` bit in
17:24:59 <Cale> (or add stm to the build dependencies in your cabal file)
17:25:50 <byorgey> > let derangements = 1 : 0 : zipWith (*) [1..] (zipWith (+) derangements (tail derangements))
17:25:51 <lambdabot>  Parse error at end of input
17:25:55 <goalieca> Cale. thanks that worked
17:26:00 <byorgey> > let derangements = 1 : 0 : zipWith (*) [1..] (zipWith (+) derangements (tail derangements)) in derangements
17:26:02 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32...
17:26:05 <byorgey> =D
17:26:34 <Cale> :)
17:27:08 <Cale> > let derangements = 1 : 0 : zipWith (*) [1..] . ap (zipWith (+)) tail $ derangements in derangements
17:27:09 <lambdabot>  Couldn't match expected type `[t]'
17:27:29 <Cale> > let derangements = (1 :) . (0 :) . zipWith (*) [1..] . ap (zipWith (+)) tail $ derangements in derangements
17:27:30 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32...
17:27:42 <Cale> > fix ((1 :) . (0 :) . zipWith (*) [1..] . ap (zipWith (+)) tail)
17:27:44 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32...
17:27:59 <byorgey> hurrah!
17:29:16 <byorgey> hm, how about Catalan numbers?
17:29:25 <Cale> > Math.OEIS.describeSequence [1,0,1,2,9,44,265,1854,14833]
17:29:26 <lambdabot>   Not in scope: `Math.OEIS.describeSequence'
17:29:33 <Cale> hmm, I should commit that patch :)
17:29:46 <olsner> :T memo
17:29:57 <byorgey> Cale: you integrated Math.OEIS into \bot??
17:29:58 <olsner> :t memo
17:30:00 <lambdabot> Not in scope: `memo'
17:30:00 * Cale finally can haz darcs password
17:30:20 <Cale> byorgey: Well, it's a trivial thing, just need to add an import.
17:30:30 <byorgey> Cale: right.  awesome =)
17:31:22 <dons> Cale: :) go for it.
17:31:30 <olsner> :t  ap (zipWith (+)) tail
17:31:32 <lambdabot> forall a. (Num a) => [a] -> [a]
17:31:51 <olsner> > ap (zipWith (+)) tail [1..7]
17:31:52 <lambdabot>  [3,5,7,9,11,13]
17:32:00 * Cale does a darcs pull first and notices that twanvl beat him to it :)
17:32:07 <Cale> hehe
17:32:24 * Cale shakes his fist sarcastically at twanvl 
17:32:29 <twanvl> :)
17:33:09 <Cale> what modifications did you make to it?
17:33:43 <dons> is Math.OEIS now built in?
17:33:43 <twanvl> It uses lambdabot's Lib.Url instead of the HTTP library
17:34:29 <twanvl> and I added a search function that takes an arbitrary query, instead of only a sequence or an id, so you can search for "prime numbers"
17:35:22 <byorgey> twanvl: nice =)
17:35:37 <byorgey> hm, I should set up a darcs repo for it somewhere
17:37:32 <byorgey> would community.haskell.org be the place to put such a thing?
17:39:20 <dons> twanvl: do i need to install anything to start using Math.OEIS with lambdabot?
17:39:30 <twanvl> dons: no
17:39:49 <dons> is it available via the eval plugin?
17:40:04 <dons> or only via @oeis ?
17:40:14 <twanvl> only @oeis
17:40:40 <dons> ?quit try this then
17:40:56 <Cale> oh, we should add an import for it to L.hs
17:41:18 <dons> @oeis 1,2,3
17:41:25 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
17:41:31 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:41:35 <Cale> @oeis [1,2,3]
17:41:41 <lambdabot> Sequence not found. Where did you learn to type?
17:41:46 <Cale> heh :)
17:41:53 <byorgey> haha, awesome =)
17:42:07 <Cale> @oeis 1,2,3,4,5
17:42:09 <lambdabot> The natural numbers. Also called the whole numbers, the counting numbers or t...
17:42:11 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:42:13 <Olathe> @where botdeath
17:42:13 * lambdabot dies.
17:42:20 <byorgey> @oeis 1,0,1,2,9,44
17:42:21 <lambdabot> Subfactorial or rencontres numbers, or derangements: number of permutations o...
17:42:21 <lambdabot> [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,320...
17:42:21 <Olathe> Muahahaha.
17:42:24 <Cale> @oeis 0,1,2,3,4,5
17:42:25 <lambdabot> Digital sum (i.e. sum of digits) of n.
17:42:25 <lambdabot> [0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9...
17:42:31 <Olathe> @oeis 4,9,16,25
17:42:32 <shachaf> @list oeis
17:42:32 <lambdabot> The squares: a(n) = n^2.
17:42:32 <lambdabot> [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
17:42:32 <lambdabot> oeis provides: oeis
17:42:36 <olsner> @oeis 1,4,1,5
17:42:37 <lambdabot> Decimal expansion of Pi.
17:42:37 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,...
17:42:38 <shachaf> Hmm, can it give links too?
17:42:51 <shachaf> @oeis 84,92
17:42:51 <Cale> I like how it's surprisingly good at not finding the sequence you're thinking of :)
17:42:52 <lambdabot> Expansion of x/((1 - x)^2*(1 - x^3)).
17:42:52 <lambdabot> [0,1,2,3,5,7,9,12,15,18,22,26,30,35,40,45,51,57,63,70,77,84,92,100,108,117,12...
17:42:53 <Olathe> @oeis 9,25,49,81
17:42:54 <lambdabot> Odd squares: (2n+1)^2. Also centered octagonal numbers.
17:42:54 <lambdabot> [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,1521...
17:43:11 <Cale> @oeis 2,4,167
17:43:11 <lambdabot> Divisors of 668.
17:43:12 <lambdabot> [1,2,4,167,334,668]
17:43:17 <byorgey> shachaf: apparently not the @oeis version.  if we imported it into L.hs it could.
17:43:23 <shachaf> It would be nice if it at least gave the sequence number.
17:43:27 <Olathe> @. oeis run map (^2) [7,10..20]
17:43:29 <lambdabot> Sequence not found. My brain just exploded
17:43:35 <Olathe> Bah.
17:43:37 * shachaf doesn't like the unsafePerformIO in it.
17:43:40 <dons> needs some parens
17:43:46 <Olathe> @map (^2) [7,10..20]
17:43:46 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:43:49 <Olathe> > map (^2) [7,10..20]
17:43:50 <lambdabot>  [49,100,169,256,361]
17:43:59 <Olathe> @oeis 49,100,169,256,361
17:44:00 <lambdabot> (3n+1)^2.
17:44:00 <lambdabot> [1,16,49,100,169,256,361,484,625,784,961,1156,1369,1600,1849,2116,2401,2704,3...
17:44:08 <twanvl> It should strip the '[' and ']'
17:44:09 <Olathe> Damn you, OEIS !
17:44:09 <Cale> If it was imported, we could just use describeSequence directly.
17:44:29 <Olathe> @map (^2) [100,141..500]
17:44:30 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:44:32 <Olathe> > map (^2) [100,141..500]
17:44:34 <lambdabot>  [10000,19881,33124,49729,69696,93025,119716,149769,183184,219961]
17:44:40 <Olathe> @oeis 10000,19881,33124,49729,69696,93025,119716,149769,183184,219961
17:44:41 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:44:45 <Olathe> Heh
17:45:00 <Olathe> @oeis 10000 19881 33124 49729 69696 93025 119716 149769 183184 219961
17:45:00 <nornagon> @oeis 37
17:45:01 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:45:02 <lambdabot> The prime numbers.
17:45:02 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
17:45:22 <Olathe> @oeis 2 3 7 11 13
17:45:23 <lambdabot> Binary irreducible polynomials (primes in ring GF(2)[ X ]), evaluated at X=2.
17:45:23 <lambdabot> [2,3,7,11,13,19,25,31,37,41,47,55,59,61,67,73,87,91,97,103,109,115,117,131,13...
17:45:31 <Olathe> @oeis 2 3 7 11 13 17 19
17:45:32 <Cale> @oeis 4,8,15,16,23,42
17:45:32 <lambdabot> Primes which do not appear in A071196.
17:45:32 <lambdabot> [2,3,7,11,13,17,19,29,37,43,47,53,61,67,73,79,89,103,107,113,137,139,149,151,...
17:45:33 <lambdabot> The Lost Numbers.
17:45:33 <lambdabot> [4,8,15,16,23,42,108]
17:45:41 <Olathe> @oeis 2 3 7 11 13 17 19 23
17:45:42 <lambdabot> Smallest nonempty set S containing prime divisors of 10k+4 for each k in S.
17:45:42 <lambdabot> [2,3,7,11,13,17,19,23,29,31,37,47,67,71,73,79,97,127,157,167,197,241,337,367,...
17:45:45 <nornagon> ... lost numbers?
17:45:50 <Olathe> @oeis 2 3 7 11 13 17 19 23 31
17:45:50 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:46:00 <Olathe> Ahh, it can't do the search with gaps.
17:46:00 <Cale> nornagon: Have you watched the TV series "Lost"?
17:46:08 <Japsu> @oeis 0,75,74,75
17:46:09 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:46:14 <Olathe> @oeis 2 3 5 7 11 13 17 19 23 29 31
17:46:14 <lambdabot> The prime numbers.
17:46:14 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
17:46:20 <Japsu> @oeis 0,76,75,76
17:46:20 <nornagon> Cale: only a couple of episodes. i was hoping it wasn't that ;(
17:46:21 <lambdabot> Ludwig van Beethoven, Bagatelle No. 25, "Fuer Elise".
17:46:21 <lambdabot> [0,76,75,76,75,76,71,74,72,69,52,57,60,64,69,71,52,56,64,68,71,72,52,57,64,76...
17:46:26 <nornagon> heh
17:46:27 * Japsu claims victory
17:46:35 <Olathe> If you search on OEIS using spaces instead of commas, it will treat them as arbitrary gaps.
17:46:42 <Olathe> But @oeis fails !
17:46:45 <Olathe> Fails !!!
17:47:09 <byorgey> Olathe: hm, I didn't know that
17:47:26 <Olathe> I thought it was kind of annoying that it doesn't do that by default.
17:47:53 <Olathe> You might have a sequence that's the even elements of a sequence they have, but searching with commas would never find it.
17:49:06 <idnar> what do the numbers for Fr Elise represent?
17:49:22 <shapr> Has anyone tried to talk to Google APIs from Haskell?
17:49:32 <Olathe> Can you have it give the sequence ID ?
17:50:27 <Cale> Olathe: we should just import Math.OEIS
17:50:32 <byorgey> Olathe: Math.OEIS can give the sequence ID, but apparently the way twanvl wired up the @oeis command, it only gives the description and sequence.
17:50:49 <Cale> That way we can get all the extra information about the sequences that we want :)
17:50:58 <Olathe> idnar: It says "From the source file for a Midi player. This is intended to demonstrate the "Listen to a sequence" page." (http://www.research.att.com/~njas/sequences/?q=0%2C76%2C75%2C76&language=english&go=Search)
17:50:59 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences, http://tinyurl.com/29uwvh
17:51:22 <byorgey> Cale, are you volunteering? =)
17:51:38 <Cale> all right, I'll try out my account :)
17:51:54 <Nafai> shapr: Hey1
17:52:03 * Nafai mutters about his stupid keyboard
17:52:06 <Nafai> Hey!
17:53:42 <idnar> hmm, ok
17:55:46 <shapr> hiya Nafai
17:56:05 <Cale> hmm, where are the repositories kept on code.haskell.org?
17:56:38 <dons> /srv/*
17:56:57 <Cale> ah, okay
17:58:42 <Cale> darcs: takeLock /srv/code/lambdabot/_darcs/lock in /srv/code/lambdabot: atomic_create /srv/code/lambdabot/_darcs/lock in /srv/code/lambdabot: permission denied (Permission denied)
18:03:21 <dons> Cale: are you in the lambdabot group? :)
18:03:29 * dons checks
18:03:30 <Cale> I don't know
18:03:45 <dons> then the answer is "no". i will add you
18:03:54 <Cale> yeah, I'm only in cgibbard
18:04:07 <dons> done.
18:06:31 <Cale> I'm just getting a fresh copy of the repo from there to make sure there are no problems, and it seems rather slow, so I'll be able to try it once that's done. :)
18:06:41 <dons> it'll take a while. 2k patches
18:06:54 <Cale> It's funny that it gets them one at a time.
18:07:01 <dons> funny is one word
18:08:44 <Cale> It's also kind of stupid that the web works entirely in that way too. They didn't think to design the protocol such that things linked directly from a document on the same server would use the same HTTP connection.
18:09:01 <Cale> But with the web, you usually don't have pages with 2000 images on them.
18:09:04 <idnar> Cale: well, actually, there is support for that
18:09:54 <Cale> oh, there is?
18:10:01 <idnar> although I guess it wasn't there originally
18:10:36 <sorear> Cale: new in http/1.1, which came out in 1999
18:10:41 <Cale> heh
18:10:50 <sorear> so darcs is 8 years out of date.  unsuprising
18:10:51 <stepcut> @google http pipelining
18:10:51 <idnar> in HTTP/1.1 you have support for multiple requests on a connection (not sure if you can do that with 1.0), and also request pipelining (can send multiple requests without waiting for a response)
18:10:53 <lambdabot> http://www.mozilla.org/projects/netlib/http/pipelining-faq.html
18:10:53 <lambdabot> Title: HTTP/1.1 Pipelining FAQ
18:11:04 <idnar> darcs just uses curl for HTTP, doesn't it?
18:11:07 <Cale> Do most webservers actually make use of that?
18:11:15 <sorear> as soon as kowey's thesis (Conflicts for the layman) comes out, I'm rewriting darcs
18:11:19 <sorear> Cale: yes.
18:11:38 <idnar> most browsers don't do HTTP/1.1 by default if you have a proxy configured
18:11:51 <idnar> more of them do it if you don't have a proxy configured
18:12:10 <byorgey> sorear: I thought kowey's thesis was on natural language generation?
18:12:13 <Cale> Ah, that might explain some things :)
18:12:32 <sorear> byorgey: uh... lispy's thesis then
18:12:32 <idnar> there are a bunch of issues with various implementations, but I think it mostly works
18:12:40 <sorear> @seen lispy
18:12:40 <lambdabot> I saw lispy leaving ##logic, #ghc, #darcs, #xmonad, #haskell-blah, #haskell and #haskell-soc 2d 21h 1m 4s ago, and .
18:12:48 <Olathe> @seen O1athe
18:12:48 <lambdabot> O1athe has changed nick to olathe.
18:12:48 <lambdabot> You are in #haskell-blah and #haskell. I last heard you speak just now.
18:12:53 <idnar> heh
18:13:05 <Olathe> Hmm...
18:13:27 <Olathe> I wonder if I could switch to everyone else's nicks and have lambdabot think we're all one person.
18:13:48 <sorear> it would take ten minutes
18:13:53 <olsner> I think that idea's already been had
18:14:00 <Olathe> Did it work ?
18:14:02 <sorear> you can't issue IRC commands faster than once every two seconds
18:14:09 <dons> sorear: you could do the darcs api on top of git right now, cheaply
18:14:45 <Cale> okay, pushed successfully :)
18:14:57 <sorear> does git support darcs merges?
18:14:58 <dons> sweet
18:15:16 <Cale> I added oeis to the build-depends as well
18:15:19 <dons> sorear: it seems to provide all the darcs functionality we use typically. glguy's the expert though
18:15:28 <Cale> Hopefully that shouldn't be too much of a problem :)
18:15:44 <Cale> Is hs-plugins working with 6.8.1 yet?
18:15:46 <olsner> sorear: what's that thesis about? must be interesting if it merits writing a new VCS...
18:15:53 <Cale> I can't actually build lambdabot myself right now.
18:16:27 <thoughtpolice> Cale: don't think so. i was going to give a go at writing a plugin for lb for lazy smallcheck, but I can't build it yet
18:16:33 <sorear> Cale: expect to get hate mail from dons then, he gets pretty annoyed when people don't test :P
18:16:55 <twanvl> you don't need hs-plugins to build the bot
18:18:09 <thoughtpolice> no, but you need it for example, if you want to use the quickcheck plugin iirc (it invokes the ./quickcheck binary which depends on plugins)
18:19:00 <Cale> sorear: I'll test it as soon as he fixes plugins ;)
18:19:00 <thoughtpolice> and to do something in that vein for say, a lazysmallcheck plugin, yeah, I'd need it. but you are right that you don't need it to build.
18:19:18 <hpaste>  davidL pasted "lambdabot + runplugs problems" at http://hpaste.org/3795
18:19:47 <Cale> dons!!!
18:19:49 <Cale> ^^
18:19:59 <stepcut> Is there any documentation on -fvectorize  ?
18:20:44 <thoughtpolice> stepcut: doesn't look like it. I was wondering on how to utilize it the other day, but I've no idea where to start
18:21:21 <stepcut> I don't even have the foggiest clue what it does -- I just wonder if it will make floating point math go faster
18:21:54 <thoughtpolice> stepcut: it's for the new nested data parallelism stuff.
18:22:21 <stepcut> thoughtpolice: but, what does it do ?
18:22:55 <thoughtpolice> stepcut: see http://www.cse.unsw.edu.au/~chak/papers/CLPK07.html
18:22:56 <lambdabot> Title: Research Papers of Manuel Chakravarty
18:23:26 * stepcut reads
18:23:36 <davidL> Cale: is plugins broken?
18:24:00 <Cale> davidL: On 6.8.1 it is. I don't know what your issue is on 6.6.1, since I had it working there.
18:24:34 * stepcut notes that vectorise with an s would probbaly have yielded him better search results
18:24:44 <thoughtpolice> davidL: i'm having the same issue with plugins on my openbsd box (4.1)
18:24:56 <thoughtpolice> except I believe in my case it's a missing _environ or somesuch
18:25:02 <davidL> thoughtpolice: are you on amd64?
18:25:16 <thoughtpolice> davidL: no, pentium 4
18:25:51 <thoughtpolice> the error didn't occur with lambdabot though; it occured when I tried to build my own bot which uses hs-plugins
18:44:40 * Cale wonders what happened to dons :)
18:44:55 <Cale> @get-dons
18:44:56 <lambdabot> Unknown command, try @list
18:47:05 <dons> what happened to me?
18:47:21 <Cale> dons: hehe
18:47:31 <Cale> dons: People are talking about problems with hs-plugins
18:48:00 <Cale> (also, any idea when it will be ready for 6.8.1? ;)
18:48:25 <Cale> (I can't actually build lambdabot myself right now)
18:48:31 <Cale> Oh, I have to run.
18:48:51 <dons> you'll have to build with 6.6.x for now
18:49:33 <davidL> dons: did you see my paste?
19:10:54 <Nafai> Say I wanted to split up a = [[1,2,3],[2,3,4],[4,5,6]] how would I do that?  I tried putting \ after the commas for each row, but that didn't work
19:11:41 <dons> split up ?
19:11:44 <allbery_m> you mean onto separate lines?  just use indentation
19:11:57 <Nafai> Yeah
19:12:42 <hpaste>  dons pasted "indent" at http://hpaste.org/3796
19:12:59 <Nafai> Thanks
19:13:05 <Nafai> I was missing the indents
19:14:08 <hpaste>  allbery_b pasted "another indentation example" at http://hpaste.org/3797
19:15:11 <allbery_m> the advantage of the first style is that it's easier to insert new rows without editing other lines, especially if you move the outer brackets to their own lines
19:18:02 <brian`> can anyone help me with this simple tutorial stuff?
19:18:09 <brian`> I was following http://haskell.org/haskellwiki/HXT/Practical/Simple1
19:18:10 <lambdabot> Title: HXT/Practical/Simple1 - HaskellWiki
19:19:18 <brian`> but when I tried to compile, it says there is a parse error on input '->'
19:21:00 <sorear> Did you include the LANGUAGE line?
19:21:34 <brian`> yeah i did
19:22:03 <brian`> module HXT_Simple1
19:22:03 <brian`>     where
19:22:03 <brian`>  
19:22:03 <brian`> {-# LANGUAGE Arrows, NoMonomorphismRestriction #-}
19:22:06 <brian`> import Text.XML.HXT.Arrow
19:22:10 <brian`>  
19:22:13 <brian`> data Guest = Guest { firstName, lastName :: String }
19:22:16 <brian`>              deriving (Show, Eq)
19:22:19 <brian`>  
19:22:24 <brian`> getGuest = deep (isElem >>> hasName "guest") >>>
19:22:27 <brian`>            proc x -> do
19:22:27 <brian`>              fname <- getText <<< getChildren <<< deep (hasName "fname") -< x
19:22:30 <brian`>              lname <- getText <<< getChildren <<< deep (hasName "lname") -< x
19:22:33 <brian`>              returnA -< Guest { firstname = fname, lastname = lname }
19:22:39 <brian`> that's basically my source code so far..
19:22:42 <brian`> it gives me the parse error message at proc x -> do part
19:23:09 <allbery_m> the LANGUAGE Lines has to come at the top of the file
19:23:26 <brian`> oh.. really? ok
19:23:36 <allbery_m> otherwise it doesn't do anything and the proc x -> is illegal
19:24:03 <brian`> aha ..
19:24:07 <brian`> that resolved the problem
19:24:12 <brian`> sweet~
19:24:15 <brian`> thanks allbery_m
19:25:16 <allbery_m> btw, it's preferable to paste large things like that in channel.  use hpaste instead:
19:25:18 <allbery_m> @paste
19:25:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:26:00 <ddarius> And by "to paste" allbery_m means "not to paste"
19:26:21 <allbery_m> whoops, sorry
19:26:23 <allbery_m> yes
19:26:40 <allbery_m> not only is it annoying, but if there are other discussions taking place it ends up intermixed and unreadable
19:27:18 <brian`> okay thanks for the tip
19:27:33 <brian`> I'm new to haskell world so didn't know about hpaste..
19:27:55 <allbery_m> it's a general IRC thing.  lots of pastebins around
19:28:30 <allbery_m> IRC isn't good at threading so it helps to avoid confusion when everything gets mixed together
19:28:44 <brian`> i c..
19:37:05 <goalieca> @src rety
19:37:06 <lambdabot> Source not found. I am sorry.
19:37:07 <goalieca> @src retry
19:37:07 <lambdabot> Source not found. Sorry.
19:38:47 <goalieca> hmm. i notice that IO with concurrency is funny. It never mixes up the strings "aa" "bb" --> "abab" but it always does with the newlines
19:38:58 <goalieca> @src putStrLn
19:38:58 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
19:39:22 <goalieca> well it always seems to change threads right at the ';'
19:41:03 <dons> goalieca: flushing
19:41:20 <dons> locks an MVar, and that is enough to give the scheduler a chance to flip
19:41:32 <dons> if you change the buffering, i'll bet you see more interleaving
19:41:59 <goalieca> @src putStr
19:41:59 <lambdabot> putStr s  = hPutStr stdout s
19:42:11 <goalieca> so it makes a c-call ?
19:42:21 <goalieca> i guess it would depend on using OS threads or not
19:42:32 <allbery_m> no, it's native
19:42:41 <allbery_m> in ghc at least
19:44:17 <goalieca> another question, how come there is no "join" thread function. the example on the wiki is to use a spinlock and an MVAR list (of tid's)
19:44:53 <allbery_m> at the very lowest level are OS calls but that's below the buffering layer and invokes the system call (or OS equivalent) directly
19:45:17 <allbery_m> thread model is different in Haskell.  threads are created as needed and go away at their will
19:45:35 <goalieca> yeh.. but what if i wanted to wait on all threads to finish computing
19:45:37 <allbery_m> and are much lighter weight than e.g. java threads
19:46:00 <allbery_m> force their results
19:46:10 <allbery_m> no different from any other haskell expression
19:47:30 <allbery_m> instead of layering in a thread API, haskell threads are just expressions and behave like any other expressions.  (technically this is not so much a threads model as it is co-expressions.)
19:48:13 <thoughtpolice> goalieca: you can have a response channel shared among all threads, and when a thread quits, have it send a message over the channel. your main thread can keep count of how many threads are active, and when it gets a n amount of those messages, it knows to continue
19:49:17 <goalieca> well.. i tried "forcing a response".. but forkIO always returns immediately (just like any other fork).
19:49:23 <goalieca> so i don't know what you mean
19:49:28 <thoughtpolice> for example, you spawn five threads and they all have access to a response channel over which you can send Maybe values. the main thread just reads stuff coming in from the channel, and when it has gotten for example, five counts of Nothing sent over the wire, to go do whatever
19:49:46 <thoughtpolice> goalieca: hold on, I might be able to whip something up right fast if you'd like
19:49:53 <goalieca> ty
19:51:32 <allbery_m> goalieca: you need a communication channel between the main thread and the forked one (typically an MVar), which you then wait on to get the result.  not sure if you need to actually force that, since it's in IO it may be strict already... (I don't actually do much with interthread communication in my stuff)
19:51:34 <Saizan_> basically each thread put in a MVar and you take from it to join with that thread
19:52:13 <hpaste>  (anonymous) pasted "the example from the docs.. " at http://hpaste.org/3798
19:52:37 <goalieca> Saizan_, that is the example from the docs ^^
19:52:50 <goalieca> kind of an ugly solution
19:53:36 <ricky_clarkson> Korollary: Thanks for the link to the hello world part of the language shootout.
19:53:51 <ricky_clarkson> Korollary: It puts Haskell between C and Perl, which is fine.
19:54:17 <Korollary> se nada
19:55:05 <ricky_clarkson> "de nada", no?
19:57:17 <ricky_clarkson> I also asked about Haskelly file manipulation.
19:57:20 <Korollary> Indeed
19:57:52 <ricky_clarkson> ..someone pointed me at hash, which seems to a) not exist, and b) not theoretically do what I want.
19:58:12 <ricky_clarkson> E.g., flatten directory would create a new directory with all the same files in, but without any subdirectories.
20:12:39 <hpaste>  thoughtpolice pasted "for goalieca" at http://hpaste.org/3799
20:12:44 <thoughtpolice> goalieca: there ya go :)
20:14:17 <thoughtpolice> it's the same sort of wait mechanism I use in my bot; I got it from one of dons blog posts... it works nicely, though. :)
20:17:16 <goalieca> thoughtpolice, that's pretty nice actually.
20:18:01 <thoughtpolice> yes for what I used it for in my bot it worked nicely; I needed assurance all threads closed before i unloaded a bunch of modules from memory and reloaded them
20:18:23 <thoughtpolice> first import of the synchronisation method I used had some problems because modules got unloaded weird, that method was a nice fix though
20:19:05 <goalieca> hmm.. still though.. it would be really nice to have a "blocking" wait. i'm sure a little "rest" call in the wait function would slow the load.
20:20:52 <thoughtpolice> most likely.
20:59:51 <Casey-^> hello, just looking around for someone to chat with... I have a few pictures up at www.myspace.com/caseytinsley if you wanted to see. feel free to message me :)
21:11:37 <ddarius> ?
21:13:30 <dons> hello. just looking for some lambdas to hack with ... I have a few list comprehensions up at hpaste.org if you wanted to see. feel free to correct type errors.
21:17:48 <goalieca> that was weird.
21:18:16 <newsham> does myspace support list comprehensions?
21:19:34 <goalieca> nope. myspace is a completely mutated
21:19:36 <dons> i think it uses a peek and poke interface
21:20:39 <goalieca> facebook is easy to bypass privacy.. they use some sort of hash for images but there is a pattern to it. all images are served up publicly if you can guess the URL
21:21:04 <goalieca> eg: change the s in a thumbnail to n
21:21:32 <newsham> you can get in trouble for peeking and poking at the jailbait on myspace
21:28:09 <chenjian> Hello, everyone.
21:29:08 <Cale> Hello
21:30:06 <sorear> Hello
21:30:48 <ikegami--> Hi, there
21:31:11 <goalieca> hi
21:31:14 <ikegami--> I upload a demo movie for flymake-mode for Haskell on Carbon Emacs
21:31:15 <ikegami--> http://www.youtube.com/watch?v=oYdkrOMhFWU
21:31:17 <lambdabot> Title: YouTube - demo : flymake-mode for Haskell on Carbon Emacs
21:32:01 <ikegami--> Because of the bug(?) of YouTube, the first section does not played correctly, however,
21:32:13 <dons> oh, nice. ikegami-- can you add it to the videos page on the wiki, http://haskell.org/haskellwiki/Video_presentations
21:32:15 <lambdabot> Title: Video presentations - HaskellWiki
21:32:26 <ikegami--> editing Haskell program file can be seen clearly
21:33:14 <ikegami--> dons: thanks for your advice
21:35:26 <ikegami--> I wonder which section is best, for a while at Video_presentations
21:36:58 <dons> applications, maybe?
21:37:04 <dons> or a new category of 'development' ?
21:41:26 <ikegami--> development seems an abstract title, i think (but i'm not native English speaker),
21:41:43 <ikegami--> then, i'll add my video at the applications section
21:42:26 <ikegami--> The reason: everyone develop something!
21:45:00 <srihari> would anyone know if there's a problem with cabal in ghc 6.8.1 on windows?
21:46:54 <Cale> srihari: I haven't heard of anything that general. There are some bugs in cabal, what are you seeing?
21:47:34 <Cale> srihari: You may want to try Cabal-1.2.1 or HEAD if 1.2.2.0 isn't working out for you.
21:48:04 <Cale> In particular, cabal-install seems to be broken under 1.2.2.0
21:48:53 <srihari> 'runhaskell Setup.hs configure' gives me: "Setup.hs: ld is required but it could not be found.",
21:49:47 <srihari> (sorry, my ISP seems to block freenode, and ircatwork is rather slower than it should be)
21:50:09 <srihari> thanks, will try that
21:50:23 <Cale> http://pages.cs.wisc.edu/~kovar/hall.html -- ahahaha
21:50:24 <lambdabot> Title: Kovar/Hall
21:52:08 <Manyfold> as a physicist i must protest against this kind of humor
21:53:36 <narain> how do i turn  Maybe (IO a)  into  IO (Maybe a) ?
21:54:34 <Manyfold> srihari : what is your ISP?
21:54:42 <Cale> case x of Nothing -> return Nothing; Just y -> fmap Just y
21:55:04 <Cale> or if you'd like
21:55:25 <Cale> maybe (return Nothing) (fmap Just)
21:55:43 <Cale> hmm, Data.Traversable.sequence would also work
21:55:57 <narain> Cale: hmm, i like the second one
21:56:53 <narain> but i did feel that it would be nice for sequence to work on more general types :)
21:56:54 <ddarius> Or with pointless obfuscation, maybe (return mzero) (fmap return)
21:57:14 <narain> :t mzero
21:57:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
21:57:36 <ddarius> Actually, that's not completely pointless as it generalizes the function.
21:58:45 <narain> :t maybe
21:58:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:59:40 <ddarius> :t maybe (return mzero) (fmap return)
21:59:41 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad f, MonadPlus m, Functor f) => Maybe (f a) -> f (m a)
21:59:52 <srihari> ah, much better
22:00:19 <srihari> Manyfold: it's Airtel
22:02:37 <ikegami--> aha, some kind people have already edited for Flymake http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
22:02:38 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
22:02:50 <ikegami--> thanks very much
22:04:06 <Cale> srihari: Oh, you're missing ld?
22:04:12 <srihari> yes, I am
22:04:34 <srihari> or not, actually, since it's in the gcc-lib directory
22:04:43 <Cale> hmm...
22:05:16 <Cale> So perhaps it just comes down to figuring out where cabal is looking for it.
22:05:29 <dfranke> ...the heck?
22:05:31 <srihari> guess so
22:05:41 <dfranke> I could have sworn that (Either String) was a monad, but ghc is telling me otherwise.
22:06:11 <srihari> of course, it is a minor puzzle on how I build cabal HEAD, since setup.lhs requires ld there, too :)
22:07:28 <sorear> dfranke: types aren't monads
22:07:35 <sorear> dfranke: you need instances too
22:07:54 <Cale> Uh, Either String is a monad
22:08:11 <Cale> But stupidly, you have to import Control.Monad.Error to get the instance
22:08:17 <sorear> there exists a monad-structure on Either String, yes.
22:08:18 <dfranke> ah, ok.
22:08:23 <sorear> but there are many of them
22:08:30 <sorear> you need to import the one you want
22:08:31 <Cale> sorear: not that many of them
22:08:48 <sorear> Cale: an uncountable infinity are possible...
22:08:53 <Cale> hmm...
22:09:11 <dfranke> sorear: Captain Obvious, we salute you.  However, the one I had in mind is the one defined in Control.Monad.Error :-)
22:09:22 <Cale> Can you describe them?
22:10:08 <sorear> dfranke: yes.  GHC isn't smart enough to know that if exactly one instance is in the standard libraries somewhere it should be used.  for all GHC knows there might be an instance in ANOTHER module
22:10:15 <Cale> Oh, I suppose there may be, once you fix the String type there.
22:10:25 <Cale> But only one is actually natural, as far as I can tell.
22:10:32 <dfranke> sorear: yeah, I just thought it was defined in the Prelude.
22:10:36 <sorear> Cale: no, adding describability restricts the model to something countable
22:10:52 <sorear> dfranke: instance Monad (Either String) isn't even legal H98
22:11:00 <Cale> That is, (Either e) is only a monad in one way.
22:11:20 <Cale> (which is natural in e)
22:11:28 <sorear> see: GHC is not a thoerum prover
22:12:01 <Cale> Heh, I'd forgotten about that silly restriction in H98
22:12:20 <dfranke> Also, shouldn't the instance definition be moved to Data.Either?  I thought orphan instances were now considered a Bad Thing.
22:12:22 <Cale> They were being really conservative about the description of typeclasses.
22:12:41 <Cale> dfranke: There really should be an instance in Prelude.
22:13:03 <Cale> But barring that, I suppose Data.Either is okay.
22:13:21 <Cale> Also, the current instance, requiring an instance of Error e, is silly.
22:13:36 <Cale> instance Monad (Either e) where
22:13:41 <Cale>    return x = Right x
22:13:42 <sorear> dfranke: orphan instances aren't bad at all
22:13:50 <Cale>    Left e >>= f = Left e
22:13:56 <Cale>    Right x >>= f = f x
22:13:57 <sorear> dfranke: GHC implements them poorly, but that's their fault
22:14:12 <Cale> That's the one true instance of Monad for Either e
22:14:15 <sorear> meh, just kill fail
22:14:19 <Cale> right.
22:14:21 <dfranke> Cale: I think you need to make it (Either String) so that you can define fail.
22:14:24 <Cale> yeah
22:14:31 <Cale> Well, not Either String
22:14:41 <Cale> But Either e where e is in the Error class.
22:14:48 <Cale> fail is stupid though
22:14:59 <sorear> very.
22:15:27 <Cale> It's not part of the definition of a monad, and it usually ends up being implemented by something which just crashes your program.
22:15:53 <Cale> It's far more sensible to have a separate class for monads where failure is possible.
22:16:17 <shachaf> Cale: MonadZero?
22:16:24 <Cale> yes
22:16:27 <shachaf> Cale: Or something else, for fail?
22:16:38 <dfranke> I'd rather just use ErrorT
22:16:47 <shachaf> MonadZero++
22:17:02 <Cale> MonadZero would be okay, or maybe MonadFail, for those which can reliably hand back a string message.
22:17:22 <Cale> But I like MonadZero more.
22:17:32 <dfranke> no, MonadZero would be bad.
22:17:42 <Cale> Why?
22:17:44 <shachaf> Cale: Where fail would just be const mzero, if it doesn't make sense?
22:17:54 <Cale> shachaf: I suppose so, yeah.
22:18:02 <dfranke> because sometimes you want (fail x >> return y) to be (return y), and sometimes you want it be failure.
22:18:27 <Cale> In which monads is it not failure?
22:18:27 <dfranke> wait, nevermind.
22:18:36 <dfranke> I was conflating >> with mplus.
22:18:39 <Cale> ah
22:18:53 <dfranke> so yeah, MonadZero would be good.
22:18:57 <Cale> Yeah, we also need to split MonadPlus into MonadPlus and MonadOrElse
22:19:49 <Cale> Interestingly, MonadOrElse would still have useful implementations even on things which were still MonadPlus instances.
22:20:13 <Cale> For example, [] `orElse` ys = ys; xs `orElse` ys = xs
22:21:30 <ddarius> :t flip $ either Left
22:21:32 <lambdabot> forall a b b1. Either a b1 -> (b1 -> Either a b) -> Either a b
22:54:58 * Cale compiles instant insanity :)
22:55:12 <dons> yay!
22:55:29 <Cale> time ghc -fglasgow-exts -fallow-undecidable-instances -fcontext-stack=100000 instant-insanity.lhs
22:56:27 <Cale> I added some stuff to the code to reify the results into values, and a main to print it out.
22:56:48 <thoughtpolice> hm, does -fglasgow-exts no longer imply things like template haskell with 6.8.1? I'm using a couple of extensions (generating stuff with harpy) and -XTemplateHaskell works, but passing -fglasgow-exts doesn't imply it I guess.
22:57:12 <ddarius> -fglasgow-exts did?
22:57:27 * ddarius thought you needed -fth ...
22:57:33 <shachaf> ddarius: In 6.4 it did.
22:57:42 <dons> yeah, i don't think -fglasgow-exts ever enabled TH did it?
22:57:44 <shachaf> But not since 6.6, I think.
22:58:41 <Cale> heh, GHC is using 327MB of memory
22:59:06 <ddarius> So are we now going to start benchmarking C++ and Haskell typechecking performance?
22:59:14 <dons> better than the C++ by all accounts
22:59:34 <dons> the type checker should be reasonably performant... fingers crossed
22:59:35 <Cale> The C++ typechecker doesn't even solve the complete problem
22:59:54 <thoughtpolice> dons: i was under the assumption it did... oh well. not a real biggie since I have cabal anyway, but I was looking at some core output and stuff.
23:00:24 <Cale> (at least in that guy's C++ compiler)
23:00:30 <adamjones> Can anyone help me troubleshoot some issues compiling under ghc 6.8.1?
23:00:55 <Cale> GHC just did another allocation, it's up to 434 MB, I hope it doesn't need much more
23:01:02 <thoughtpolice> on another note, apparently passing -ddump-simpl to ghc when compiling a alex-generated lexer blows up compile times. then again, the alex-generated stuff is probably fairly 'mechanical' in terms of its structure
23:01:23 <dons> Cale: going to make a bug report about type inference performance?
23:01:37 <dons> thoughtpolice: -ddump-simpl will force a lot of pretty printing
23:01:44 <Cale> heh
23:03:00 <Cale> I have another 280MB or so free, but if it needs any more than that, I don't think I'll be able to do it, at least without killing X.
23:03:35 <thoughtpolice> dons: i'll keep that in mind. :)
23:05:29 <dons> Cale, would be interesting to compare 6.6 and the new 6.8 typesystem (or is it "runtime" ;)
23:09:51 <thoughtpolice> hm, to use the new -fvectorise stuff, do you need the ndp package installed with 6.8 or can you use GHC.Parr? i was thinking of looking at it but (understandably as its pretty beta) there's not much in terms of using it in ghc
23:09:54 <Cale> It's up to 606 MB
23:10:08 <Cale> 146 MB free
23:10:16 <Cale> (including buffers/cache)
23:11:37 <Cale> 809MB, I'm swapping.
23:12:52 <Cale> Oh, I suppose I have 2GB of swap.
23:14:03 <Cale> 1237 MB VIRT.
23:14:44 <Cale> This is kinda insane ;)
23:15:59 <Cale> I'm being slaughtered by iowait.
23:21:37 <Cale> 23758 cale      18   0 1593m 744m 1988 D  2.3 73.6  18:51.49 ghc-6.8.1
23:21:53 <Cale> Cpu(s):  4.0%us,  2.7%sy,  0.0%ni,  0.0%id, 93.0%wa,  0.0%hi,  0.3%si,  0.0%st
23:22:31 <dons> go Cale!
23:23:07 <Cale> Don't you have a nice 16 core machine with lots of memory in it? :)
23:24:13 <dons> oh, yes. that's true.
23:24:19 <dons> for our smp type system?
23:24:26 <Cale> heh :)
23:24:56 <Cale> Well, at the very least you could devote one of the cores to it ;)
23:25:38 <dons> http://www.comp.nus.edu.sg/~sulzmann/manuscript/concurrent-chr-stm.ps (concurrent STM type checker)
23:25:42 <lambdabot> http://tinyurl.com/28qv2k
23:25:58 <dons> since our type programs are so computationally intensive now
23:26:14 <dons> we need a native code backend for our type programs
23:26:28 <dons> compiled type inference!
23:26:45 <dons> sorear:  ^^ something to work on :)
23:26:56 <dons> hey andyjgill
23:27:09 <andyjgill> Hi Don
23:30:07 <Cale> It's just passed the 2GB mark.
23:30:09 <sjanssen> does anybody have GHC 6.8.1 on a box with a ridiculous amount of memory?
23:30:33 <dons> i can get it on a 16G box with a day or two's notice
23:30:37 <adamjones> define ridiculous
23:30:38 <sjanssen> I've got a solution to Instant Insanity using type families, and my 2GB RAM + 1.5 GB swap was not enough :(
23:30:40 <Cale> :)
23:30:50 <sjanssen> Cale: is that what you're running now?
23:30:58 <adamjones> ah, ridiculous large, can't help there.
23:31:00 <Cale> sjanssen: yeah
23:31:10 <dons> sjanssen: oh, awesome. that does sound like a job for the ChilliX's type families big box
23:31:29 <sjanssen> Cale: ah, good that you're experiencing the same difficulties
23:31:31 <dons> well, its the ndp big box, but type families would be welcome, i suspect
23:31:31 <Cale> sjanssen: Er, I'm running a slightly modified version of what was in the Monad.Reader article.
23:31:45 <sjanssen> Cale: I was worried that I made a mistake transcoding it
23:31:53 <Cale> I added some stuff to reify the types to values at the end so that the main could print it out.
23:32:04 <dons> sjanssen: you should blog the result, btw. once it terminates
23:32:23 <sjanssen> Cale: yes, you have to use Typeable or Show hacks to convince GHC to reduce the type families
23:32:29 <Cale> I'm down to 1.1GB of swap free.
23:33:02 <dons> sjanssen: wow.
23:33:21 <Cale> My load average is 4.15
23:33:23 <dons> we need to start the Type system/Performance wiki page
23:34:55 <Cale> I have no idea how they got the result for the paper.
23:35:03 <Cale> Well, I have some idea ;)
23:35:28 <sorear> duh, functional dependancies are faster
23:35:56 <Cale> Well, this is the code from the paper.
23:36:29 <sjanssen> Cale: oh, the fundep version is taking that much memory?
23:36:39 <sjanssen> it was quite reasonable on my box
23:37:22 <sjanssen> sorear: "duh, functional dependancies are faster", because fundeps are more mature, or because of some technical reason?
23:37:51 <sorear> sjanssen: I was joking, but I would check - it's quite possible the fundep version terminates
23:37:59 <Cale> sjanssen: really? How long/how much memory did it take? And which GHC did you use?
23:38:17 <sjanssen> Cale: I don't remember, and 6.8.1
23:38:24 <sjanssen> I'll run it again, one moment
23:38:41 <mae> whats the easiest way in haskell to find out if an element e is in a list l
23:38:46 <sjanssen> Cale: "quite reasonable" may include as much as 1.5 GB RAM
23:38:51 <sjanssen> mae: elem
23:38:53 <mae> like 5 in [1,2,3,4,5] true
23:38:56 <mae> ah
23:39:04 <Cale> It's been running for 19 minutes, and is up to 2300 MB, so perhaps I did something horribly wrong with my Reify typeclass.
23:39:09 <dons> :t elem
23:39:10 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:39:26 <dons> > elem 5 [1..] -- ;)
23:39:28 <lambdabot>  True
23:39:30 <dfranke> Gah, darcs almost just gave me a heart attack.
23:39:37 <dfranke> I added a bunch of new files and a directory.
23:40:05 <dfranke> Then realized I meant to add the directory recursively, so I ran darcs revert.
23:40:17 <dfranke> which proceeded to delete the files that I had added.
23:40:35 <dfranke> yay for unrevert.
23:40:52 <sjanssen> darcs get http://code.haskell.org/~sjanssen/instantinsanity
23:40:54 <lambdabot> Title: Index of /~sjanssen/instantinsanity
23:41:00 <dfranke> (and they're all open in my emacs buffer anyway)
23:41:07 <Cale> I think I'm going to kill this off.
23:41:40 <Cale> Well, I'll wait for it to reach 2.5 GB :)
23:43:26 <Cale> It's only 14MB short of that, but it hasn't done any extra allocation in a bit.
23:44:53 <mae> what is the opposite of Char.ord
23:45:10 <Cale> Char.chr
23:45:18 <mae> cool :)"
23:45:28 <adamjones> Can anyone explain why I'm getting this error trying to compile xmonad on ghc 6.8.1?
23:45:30 <hpaste>  adamjones pasted "(no title)" at http://hpaste.org/3804
23:45:38 <Cale> You can also use fromEnum and toEnum which are in the Prelude
23:46:23 <sjanssen> adamjones: you have to add containers to the build-depends field in xmonad.cabal
23:46:47 <dobblego> ?hoogle [a] -> Maybe a
23:46:51 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
23:46:51 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
23:46:52 <sjanssen>  echo ':t solutions (u::Cubes)' | ghci instantinsanity.lhs -fglasgow-exts  )  386.65s user 1.52s system 99% cpu 6:28.82 total
23:47:00 <dobblego> > listToMaybe [1,2,3]
23:47:03 <sjanssen> Cale: ^^^, with about 1GB of RAM used
23:47:05 <lambdabot>  Just 1
23:47:09 <dobblego> > listToMaybe []
23:47:10 <lambdabot>  Nothing
23:47:57 <adamjones> sjanssen: looks like that did it, thanks.
23:47:59 <Cale> sjanssen: interesting
23:50:50 <dons> adamjones: http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Building_xmonad_with_GHC_6.8 also, so the solution is documented
23:50:52 <lambdabot> Title: Xmonad/Frequently asked questions - HaskellWiki, http://tinyurl.com/3a2duf
23:52:59 <sjanssen> would anyone like to look at http://code.haskell.org/~sjanssen/instantinsanity/instantinsanitytf.hs, and see if I've made any obvious mistakes?
23:53:00 <lambdabot> http://tinyurl.com/2pjl7f
23:54:03 * Cale tries again using Show rather than a needless MPTC :)
23:55:12 <Cale> This is already looking much much better.
23:59:46 <takamura> hi
