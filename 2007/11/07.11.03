00:00:09 <sjanssen> right
00:00:22 <Cale> and clicking on the workspaces/dragging around windows in the pager would do the right thing
00:02:51 <Cale> Tiling window managers seem to work a whole lot better if you mostly stick to terminal windows.
00:03:33 <Cale> As soon as there's a graphical window around, usually it's unreasonable to resize it to many of the shapes which would be perfectly okay for a terminal window.
00:04:12 <mae> anyone know about how fubar'd wxhaskell is with ghc 6.6.1?
00:08:45 <Cale> Is it fubared at all?
00:09:02 <Cale> I think it's fine if you use the darcs version
00:28:21 <mae> there is a darcs version?!
00:44:37 <Cale> yeah, darcs get http://darcs.haskell.org/wxhaskell
00:44:39 <lambdabot> Title: Index of /wxhaskell
00:44:57 <Cale> mae: ^^
00:48:21 <mae> they still using eiffel to generate bindings?
00:48:33 <mae> i was considering taking a whack at using c->haskell
01:04:29 <dmwit> I'm writing an email to a friend about Haskell, would anybody be interested in looking through it for any major blunders?
01:04:36 <dmwit> http://buckwheat.stanford.edu/amino.lhs
01:07:08 <dmwit> I'm also accepting big-picture comments, like, "Sending that mail isn't worth it." =)
01:07:24 <KatieHuber> might want to give an instruction on how to run it with GHC
01:07:43 <dmwit> Yes, that's a good point.
01:08:44 <wli> Eiffel? Interesting.
01:10:07 <KatieHuber> I found the paragraph before "offsets" tricky to understand on first reading
01:10:17 <KatieHuber> (on second reading it and the code were fine)
01:11:20 <dmwit> Maybe continuing the example would help.
01:11:39 <dmwit> i.e. showing what (offsets [5,6,7,30,29,28]) would look like for three-element sums.
01:11:59 <KatieHuber> oh, you've got a "runhaskell amino.lhs" at the end which kinda answers the first question
01:12:02 <araujo> wli, yeah, that's an interesting OO language
01:12:16 <dmwit> KatieHuber: Yeah.  I think putting something earlier in the mail would be good, though.
01:12:33 <araujo> wli, i was playing with it for a while in the past ... it is like a "declarative static typing object system"
01:18:02 <wli> I came up with a function that should present grave difficulties for approximation methods even though it's completely nonsingular on the real line.
01:19:00 <wli> Essentially what goes on is that there are problems that arise when there are nearby poles in the complex plane.
01:20:11 <wli> The solution sometimes is to try to capture a few poles by having an approximation method allowing some finite number of poles.
01:21:42 <wli> I can thwart that by having a countable number of poles dense on the horizontal lines +/- r*i, essentially a pole at each rational multiple of i.
01:24:42 <wli> Each nonzero rational multiple of i, that is.
01:28:49 <wli> Enumerate the nonnegative nonzero rationals as r_n; let f x = recip . sqrt $ (sinh pi)^(2::Int) + (cos x)^(2::Int) ; g x = sum [f (x / fromRational (positiveRationals `genericIndex` n)) / 2^n | n <- [0..]] (using a numerical summation process in reality of course.
01:29:56 <wli> The sqrt may or may not be a good idea. Not sure yet. (It's actually an algebraic singularity with that).
01:31:11 <wli> Polynomial approximants will explode on contact with radii of convergence. Rational approximants can only take on a finite number of poles/singularities at a time, so they can't deal with the density.
01:32:06 <wli> No idea what trigonometric approximants do.
01:34:41 <ZsoL> Fourier-series?
01:35:02 <wli> Well, they would be a finite Fourier series, or a "trigonometric polynomial."
01:35:38 <wli> You'd get the coefficients from linear algebra on irregular meshes or FFT's on regular ones.
01:36:04 <ZsoL> ah, i c
01:38:04 <wli> > let f x = let t = sinh pi ; t2 = t * t ; c = cos x ; hi = recip t2 ; lo = recip $ t2 + 1 in (2 * (recip $ t2 + c * c) - (lo + hi))/ (hi - lo) ; g x = let gs = scanl1 (+) $ zipWith (*) (iterate (/2) (1/2)) [f (x / fromRational r) | r <- tail rationals] in snd . head . dropWhile (\(nxt, prv) -> abs ((nxt - prv)/(nxt + prv)) > 1e-12) $ zip (tail gs) gs in map g [0, 0.5 .. 3.0] :: [Double]
01:38:05 <lambdabot>   Not in scope: `rationals'
01:38:22 <wli> Ugh. Well the definition of rationals used is wrong anyway...
01:53:38 <roconnor> \join #tutbot-testing
01:53:43 <roconnor> oops
02:05:53 <ac> does anybody know what a CCG grammar is?
02:06:09 <wli> You mean DCG?
02:06:22 <ac> no, Combinatory Categorial Grammar
02:06:37 <ac> I was hoping I could get a comprehensible explenation without diving in to some super dense paper
02:10:24 <kowey> ac: have you seen http://groups.inf.ed.ac.uk/ccg/publications.html ? I'm sure there's something friendly in there
02:10:28 <lambdabot> Title: The CCG site
02:11:08 <ac> kowey: reading something from there now.
02:11:43 <kowey> a thesis might be a good way to go about it... since they have room, they can afford to go slower on the state of the art
02:12:37 <ac> wli: what's DCG?
02:12:50 <wli> Definite Clause Grammar
02:13:16 <ac> wli: what makes it interesting?
02:14:27 <wli> They're sort of nice ways to do recursive descent -like parsers.
02:14:36 <wli> They come from logic languages.
02:15:09 <ac> does lambdabot have pounce capabilities?
02:19:00 <kowey> ac: ftp://ftp.cogsci.ed.ac.uk/pub/steedman/ccg/trandd.pdf <-- might be a good one for Haskellers
02:25:45 <ac> the categories they keep mentioning: are those category theory categories?
02:27:51 * kowey doesn't know any category theory
02:28:04 <kowey> but I think they use category the way all other grammar formalisms do
02:28:17 <kowey> like, 'the category of this phrase is VP'
02:30:45 <kowey> 'syntactic category', says wikipedia
02:48:13 <wli> I guess I need 2 ^^ (negate n) / (fromRational $ positiveRationals `genericIndex` n) to be arbitrarily large for the derivatives to blow up.
02:52:15 <wli> Basically, for any enumeration of the rationals r_n, one has for any real constant K > 0 that there is an n such that 1/r_n > K * 2^n. At which point the whole affair becomes nowhere differentiable.
02:54:15 <wli> Or, at least, the series representation becomes useless for differentiation.
02:56:44 <hpaste>  Vq^ pasted "comparing TVar a against TVar b" at http://hpaste.org/3622
02:57:07 <Vq^> can it be done at all?
02:57:35 <wli> Not sure where you're getting TVar from.
02:58:01 <Vq^> from the standard library :P
02:58:05 <wli> Never mind. I know neither Typeable/Generics nor STM.
02:58:06 <taruti> STM
02:58:29 <Vq^> i'm trying to compare two TVars without knowing their exact type
02:58:44 <scook0> if you had a Typeable constraint, it might be possible
02:58:59 <scook0> depending on the semantics of your equality
02:59:35 <taruti> Vq^: are you trying to compare againsts variable identity?
02:59:43 <Vq^> taruti: yes
02:59:51 <Vq^> im not interested in values there
03:00:10 <Vq^> and i think thats how Eq TVar works
03:01:05 <scook0> does your code compile?
03:01:12 <Vq^> no
03:01:37 <Vq^> i'm not even sure Typeable is the way to go, i have never used it before
03:01:39 <taruti> Vq^: that uses internally just sameTVar# which is probably type insensitive.
03:02:28 <Vq^> sameTVar# ?
03:02:44 <Vq^> is there some way to extract it?
03:04:23 <scook0> Vq^: with Typeable it compiles
03:05:14 <taruti> Vq^: well that is iirc compiled to mo_wordEq
03:05:47 <Vq^> scook0: it does? what did you alter?
03:05:57 <taruti> Vq^: thus unsafeCoerce is probably safe in that instance. But going via Typeable is cleaner.
03:06:17 <hpaste>  scook0 annotated "comparing TVar a against TVar b" with "Typeable constraint" at http://hpaste.org/3622#a1
03:07:15 <scook0> not sure if it *works*...
03:08:21 <Beelsebob> OMG
03:08:34 <Beelsebob> \cats has completely summed up how I feel 90% of the time
03:08:48 <Vq^> scook0: im testing it now :)
03:08:57 <scook0> my tests say no :(
03:11:50 <scook0> Vq^: the cast seems to fail even when comparing something to itself
03:12:24 <scook0> Vq^: is it important that the TVars themselves be strongly typed?
03:12:52 <scook0> (i.e. you could have TVars containing existentials, instead of the other way around)
03:13:33 <Vq^> yeah, i got the same result here
03:14:22 <scook0> I'm actually a little alarmed that that definition of equality can fail (join (==))
03:14:27 <Vq^> my idea is that a thread in my program could have a reference to a more specific type than another
03:14:33 <scook0> ah
03:14:34 <Vq^> (it's not really about Num)
03:15:35 <Vq^> maybe i should go for the lowlevel datacomparison
03:18:51 <scook0> Vq^: oh duh
03:20:36 <hpaste>  scook0 annotated "comparing TVar a against TVar b" with "*there*'s your problem" at http://hpaste.org/3622#a2
03:20:48 <scook0> Vq^: works fine!
03:21:07 <scook0> (you were casting (v1,v2) instead of just v1)
03:21:26 <Vq^> oh
03:21:49 <mauke> geq :: (Typeable a, Typeable b, Eq b) => a -> b -> Bool
03:22:02 <mauke> geq x y = cast x == Just y
03:22:11 <hx2k> hello!
03:22:21 <Vq^> hello mr hx2k!
03:22:22 <scook0> howdy
03:22:41 <Vq^> scook0, mauke: thanks a bunch
03:22:51 <Vq^> scook0++
03:29:55 * wli gets a look at plots of his counterexample function.
03:45:33 <phlpp> hi
03:46:51 <scook0> hey
04:07:13 <arcatan> hmmpph. parsec's stringLiteral doesn't like multiline string literals...
04:10:52 <Vq^> it's supposed to work like Haskell string-literals if im not mistaken
04:11:43 <wli> The \ ... \ gaps, yes?
04:13:01 * Heffalump wonders if anyone ever uses those
04:13:32 <wli> I'll bet when generating code or program-interpreted output those are where comments go.
04:14:19 <arcatan> oh, that works?
04:14:43 <mauke> > "foo \ {- hi -} \ bar"
04:14:43 <lambdabot>  Illegal character in string gap at ""foo" (column 1)
04:14:56 <wli> Not that kind of comment.
04:16:22 <wli> I guess it's whitespace-only.
04:22:22 <_ry> what does "polymorphic type" mean
04:22:59 <geocalc> ie Num
04:23:16 <_ry> ah, like an abstract type?
04:23:27 <opqdonut> :t id
04:23:29 <mauke> Num is not a type
04:23:31 <_ry> geocalc: (eg not ie)
04:23:31 <opqdonut> :t (+)
04:23:32 <lambdabot> forall a. a -> a
04:23:33 <lambdabot> forall a. (Num a) => a -> a -> a
04:23:39 <mauke> _ry: I'd say it's a type with variables in it
04:23:42 <opqdonut> those are polymorphic
04:23:55 <opqdonut> :t mapM
04:23:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:24:51 <geocalc> mmh ok
04:25:12 <Beelsebob> _ry: a polymorphic type is one that can be a number of different concrete types
04:25:27 <Beelsebob> e.g. 'a' can be anything
04:25:35 <Beelsebob> and Num a => a can be any numeric type
04:43:47 <roconnor> @type 7
04:43:49 <lambdabot> forall t. (Num t) => t
04:48:33 <wli> woops ... need to subtract not divide
04:57:22 <roconnor> @bab nl en technik
04:57:23 <lambdabot>   technik
04:58:14 <mauke> @bab de en technik
04:58:15 <lambdabot>   technology
04:58:24 <roconnor> @bab nl en techniek
04:58:24 <lambdabot>   technique
04:58:48 <roconnor> ... I think technology is the translation I'm looking fr
04:59:05 <roconnor> @bab nl en de techniek
04:59:06 <lambdabot>   technique
05:03:27 <CodeFaction> hi
05:06:34 <CodeFaction> i want to buy a haskell book but i only have the money to buy one
05:06:38 <CodeFaction> since im a student
05:06:42 <CodeFaction> which one is best?
05:07:11 <jeffz> CodeFaction: you can read the review of 'Programming in Haskell' by Graham Hutton in the Monad Reader edition 7
05:07:21 <jeffz> CodeFaction: http://www.haskell.org/haskellwiki/The_Monad.Reader
05:07:23 <lambdabot> Title: The Monad.Reader - HaskellWiki
05:07:52 <CodeFaction> cool ty
05:09:33 <salierix> Do the cabal pacakages on hackagedb require the latest version of cabal?
05:09:50 <roconnor> ``In just a decade‚Äôs time, we‚Äôll have gone from half the world never having made a telephone call to half the world owning a phone.
05:10:07 <Zao> salierix: Possibly.
05:10:41 <salierix> I guess that's why a few packages are failing to install...
05:13:14 <geocalc> salierix=<< ghc version ?
05:13:22 <wli> I'm thrilled about this more interesting function whose dense set of singularities is along the two parallel lines |Im z| = 1
05:14:58 <roconnor> a dense set of singularities?
05:15:05 <roconnor> is that even possible?
05:15:12 <wli> Of course.
05:15:31 <roconnor> what is a simple example?
05:15:39 <wli> Just enumerate the rationals and drop singularities there.
05:15:53 <wli> http://holomorphy.com/~wli/NastyFunction.pdf
05:16:28 <roconnor> wli:  but we want continuity elsewhere right?
05:17:30 <wli> roconnor: Perfectly continuous along the real line. Absolutely continuous, bounded, etc.
05:17:46 <wli> roconnor: The second one is, rather.
05:17:59 <salierix> geocalc, 6,6,1
05:18:06 <roconnor> ah
05:18:09 <wli> I think even uniformly continuous.
05:18:10 <roconnor> crazy!
05:18:25 <roconnor> what a sucky function
05:19:57 <wli> roconnor: What's sucky about it?
05:20:19 <roconnor> it has a dense set of singularities
05:20:37 <wli> It's absolutely fabulous, dahling.
05:20:54 <roconnor> wli:  you are summing nastySeries?
05:20:58 <wli> It completely confounds all extant methods of attempting to deal with singularities nearby in the complex plane.
05:21:13 <wli> Yeah. It was done stupidly.
05:21:34 <roconnor> is the series convergent (on the irrationals?)
05:22:07 <wli> I think so. I'm not really sure.
05:22:36 <wli> The second function's series is very much convergent.
05:23:03 <roconnor> each irrational is close to a lot of rationals
05:23:21 <roconnor> so you have the powers of (1/2) vs the poles near by
05:23:26 <wli> The second function is more interesting. The first has poles on the real line.
05:23:52 <roconnor> iota is the second one?
05:23:56 <wli> Yeah.
05:24:26 <wli> Depending on when you last refreshed the series in math notation may be on a page by itself after the code.
05:25:59 <roconnor> yeah, but I don't have much of an intuition for hyperbolic trig functions on the i axis.
05:26:17 * mux notes there is a new project euler problem accessible in 50 minutes
05:26:53 <wli> roconnor: Hm? cosh(i*x) = cos(x), sinh(i*x) = i * sin(x)
05:27:36 <wli> roconnor: The function for each term was originally conceived as sec(x+i)*sec(x-i).
05:28:42 <roconnor> wli: by why not rotate it to place it on the real line?
05:29:31 <roconnor> oh wait
05:29:56 <roconnor> the variable doesn't occur in the coefficents
05:31:03 <roconnor> and I totally misunderstood where the poles where
05:31:39 <wli> roconnor: The idea is to have a simple pole some fixed distance away (in the limit) from every point no matter how many are removed by e.g. using rational functions to take out a finite number of them.
05:32:55 <wli> I guess they end up being pi from everything, so it'd be |Im z| = pi
05:33:31 <salierix> Anyone know if the HOPL presentations were recorded?
05:35:14 <wli> roconnor: So basically anything power series -based can have a radius of convergence no greater than pi.
05:37:37 <wli> roconnor: However, it is periodic with period 2*pi so Fourier cosine series should work, though methods for computing the coefficients may not.
05:37:59 <roconnor> wli:  I don't see how you can have a dense set of singularity and be continuous elsewhere
05:38:34 <roconnor> if you could you could find limits to a point outside the dense set for any valueb
05:38:40 <roconnor> and hence it wouldn't be continuous
05:38:45 <wli> roconnor: It happens all the time, though most of the time it's the boundary of the disk of convergence for a series doing it. They're called natural boundaries.
05:40:02 <wli> roconnor: Like sum [x^(n^2) | n <- [0..]] (a Jacobi theta function IIRC).
05:40:53 <roconnor> what are you claiming about the above function?
05:41:08 <roconnor> it has a dense set of singularities on the unit circle?
05:41:13 <wli> roconnor: Yes.
05:41:34 <roconnor> but it well defined on the unit circle outside that dense set?
05:41:50 <roconnor> and it is continuous on the unit circle outside that dense set?
05:42:27 <wli> roconnor: It's defined nowhere on the unit circle that I'm aware of, though I think there are analytic continuations not based on it that do something else.
05:42:55 <roconnor> wli: what does it mean to be a singularity?
05:43:31 <wli> roconnor: Well, there are simple poles and essential singularities and a few other things.
05:44:28 <roconnor> I just don't see how the function's behavour is different on this dense set vs off this dense set.
05:45:04 <wli> roconnor: Well, it's a dense set of simple poles for my nasty function.
05:45:21 <wli> roconnor: They're probably essential singularities for the theta function.
05:45:50 <roconnor> so how is the pole different from the surrounding undefinedness?
05:46:07 <roconnor> both are undefined
05:46:43 <wli> roconnor: The undefinedness is only on the unit circle and outside it for the theta function and along the lines |Im z| = pi*i for the iota function.
05:47:06 <wli> roconnor: iota is defined everywhere but those two lines.
05:47:30 <roconnor> yeah, but you said you have a dense set of singularities
05:47:53 <roconnor> yeah, but you said you have a countable dense set of singularities
05:48:04 <roconnor> in what way do you not have an uncountable dense set of singularities?
05:48:30 <wli> roconnor: It's unresolved whether it converges at all at irrational real offsets from pi*i.
05:48:53 <wli> roconnor: I suspect it actually might.
05:49:45 <roconnor> but you said it was undefined on the unit circle.
05:50:10 <roconnor> for the theta function
05:50:12 <wli> I was talking about iota. The theta function is a different case.
05:50:23 <roconnor> oh
05:51:18 <roconnor> and if iota doesn't converge anywhere on |Im z| = pi*i, then you don't have anything special?
05:52:14 <ivanm> roconnor: is it OK if I bug you for a bit? :p
05:53:33 <roconnor> ivanm: sure
05:53:50 <ivanm> OK, I'm looking over david lesters CReal code again...
05:54:29 <ivanm> and I'm confused, because his code for defining creal to be an instance of floating seems to be recursive...
05:54:38 <ivanm> pi depends on atan, which depends on pi, etc.
05:54:57 <roconnor> yes
05:55:03 <roconnor> but there is a base case in atan
05:55:10 <roconnor> that doesn't use pi
05:55:13 <roconnor> er
05:55:16 <wli> roconnor: Not sure. I think it's still interesting from the POV of confounding things that try to remove poles.
05:55:17 <roconnor> I think
05:55:22 <ivanm> hhe
05:55:53 <ivanm> you're right... -4 < t < 4 doesn't depend on pi
05:56:09 <ivanm> and the definition of pi uses that range...
05:56:30 <wli> One can always try pi + pi*i
05:56:44 <ivanm> for what?
05:56:50 <mauke> > pi + pi :+ 1
05:56:52 <lambdabot>      precedence parsing error
05:56:53 <lambdabot>         cannot mix `(+)' [infixl 6] and `(:+)' ...
05:56:54 <mauke> er
05:57:01 <ivanm> heh
05:57:04 <roconnor> wli: but if you don't really have poles anymore, you are hardly confounding them :)
05:57:10 <mauke> > pi :+ pi
05:57:11 <lambdabot>  3.141592653589793 :+ 3.141592653589793
05:58:10 <wli> roconnor: sec(pi+pi*i)*sec(pi-pi*i) = sech(pi)^2
06:01:19 <wli> roconnor: sorry, sec(x+pi*i)*sec(x-pi*i) at x=pi+pi*i = sech(2*pi)
06:01:54 <roconnor> wli: oh, are you saying that itoa is defeined at pi + pi*i
06:01:56 <wli> roconnor: Now for whether the series converges...
06:02:27 <wli> roconnor: Well, I have a closed form for a sub-term that may be useful for proving that.
06:04:01 <wli> roconnor: I get a big hairy expression that is definitely nonsingular.
06:04:44 <wli> roconnor: It's a function of circular functions of r so it's bounded, too.
06:05:02 <wli> roconnor: (here r is the rational offset from pi + pi*i)
06:05:31 <wli> roconnor: So I have a dense set of points where it converges.
06:06:23 <roconnor> but it isn't continuous at those points.
06:06:56 <wli> Necessarily not, since any approach along the line Im z = pi*i will encounter singularities.
06:07:03 <roconnor> yep
06:07:12 <roconnor> so it isn't really a function ;)
06:08:10 <wli> It's discontinuous along the lines |Im z| = pi; it's perfectly well-defined and even continuous for |Im z| < pi.
06:08:42 <roconnor> yep
06:20:54 <wli> woops... I've only got the convergence result for the real part.
06:21:38 <wli> The imaginary part is basically O(tan(r)) where r is the rational offset.
06:22:42 <roconnor> oh
06:22:54 <roconnor> ... to be honest, that makes me feel better.
06:22:57 <roconnor> :)
06:23:20 <wli> (sinh(2*pi)/((cos r)^2 + (sinh (2 * pi))^2)) * tan r
06:24:23 <wli> So I'm stuck with sum $ zipWith (*) (iterate (/2) (1/2)) [(sinh(2*pi)/((cos r)^2 + (sinh (2 * pi))^2)) * tan r | r <- rationals] converges.
06:27:02 <wli> roconnor: It's possible to use other constructions, for instance, instead of 2 ^^ (negate n) to weight things down, some vastly more rapidly decreasing sequence of weights designed to beat down any issue with the rationals approximating pi/2 too closely.
06:27:53 <wli> roconnor: 2 ^^ (negate $ product [1..n]) is plausible, for instance. ;)
06:29:45 <wli> roconnor: All it needs to do is outrun any approach to half-integral multiples of pi/2 the sequence of rationals might make.
06:30:38 <roconnor> I'm still skeptical
06:31:03 <roconnor> but perhaps
06:31:03 <wli> This requires an estimate of the rate of convergence of the convergents of the continued fractions of half-integral multiples of pi.
06:31:53 <wli> Or maybe not. We don't have to deal with the worst-case enumeration of rationals, just the one being used for the series.
06:33:47 <wli> And could, in principle, choose other enumerations so things converge better or estimates are easier to obtain.
06:41:59 <wli> One dumb trick would be c n = case [abs (cot r) | r <- filter (/= 0) take n rationals] of { [] -> 1 ; xs@(_:_) -> minimum xs } (the dumb trick to exclude 0 is needed, of course).
06:48:24 <wli> What's the convenient one-liner for the rationals again?
06:49:03 <wli> roconnor: I'm doing take 10 $ map (head &&& length) $ group $ scanl1 min $ map (abs . recip . tan) $ (map fromRational $ tail rationals :: [Double])
06:50:11 <wli> roconnor: This seems to suggest that the weights need not converge to 0 very quickly at all.
06:53:16 <wli> roconnor: To be extra sure, 2 ^^ (negate n) * funnyCotangent n should do the trick. No reason coefficients can't depend on rationals !! n, now that I think of it.
07:05:26 <wli> roconnor: Convinced?
07:14:14 <chessguy> @type bracket
07:14:15 <lambdabot> Not in scope: `bracket'
07:14:28 <chessguy> @hoogle bracket
07:14:28 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:14:28 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
07:14:28 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
07:15:09 <chessguy> :i bracket
07:18:17 <chessguy> @pl loop = \i -> prompt >> input >>= process >> loop i
07:18:17 <lambdabot> loop = fix (((prompt >> input >>= process) >>) .)
07:20:59 <wli> roconnor: Never mind; that could be foiled by the rational offset within x itself.
07:22:30 <roconnor> wli: :)
07:25:37 <olsner> @src IO.bracket
07:25:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:34:11 <shachaf> @src bracket
07:34:11 <lambdabot> bracket before after thing = block $ do
07:34:12 <lambdabot>     a <- before
07:34:12 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
07:34:12 <lambdabot>     after a
07:34:14 <lambdabot>     return r
07:47:12 <EvilTerran> heh, "thing". i like that.
07:55:19 <sorear> Igloo++ simonpj++ JaffaCake++
07:55:54 <wli> sorear: Did they do anything in particular for that?
07:56:04 <sorear> GHC 6.8.1
07:57:38 <shachaf> Add it to the /topic, maybe?
08:01:29 <DRMacIver> Hm.
08:02:13 <DRMacIver> I'm trying to compile some old code I wrote with  "ghc --make RenderPoints.hs -o RenderPoints" and am getting an error while linking: ld: cannot find -lXmu
08:02:24 <DRMacIver> I have *no* idea what this is supposed to mean. :)
08:02:25 <DRMacIver> oops
08:03:09 <DRMacIver> I'm assuming it's a problem linking in the OpenGL libraries, but that also happens when trying to use -package GLUT
08:03:13 <roconnor> DRMacIver: sudo aptitude install libxmu-dev
08:03:45 <DRMacIver> Ah, right.
08:05:11 <DRMacIver> Hurray. Works now.
08:05:12 <DRMacIver> Thanks.
08:06:52 <DRMacIver> Hm. Sorry, that was a bit of a dim moment on my part.
08:11:01 <desegnis> What does the -f in the numerous ghc options mean? ‚ÄúFlag‚Äù?
08:11:30 <sorear> probably
08:15:28 <araujo> morning
08:16:13 <desegnis> If it really means ‚Äúflag‚Äù, that's similar to starting every word in a text with w, wTo wShow wIt's wA wWord.
08:16:41 <shachaf> "For now, think of monads as bathroom fixtures and monad combinators as plumbing." -- I haven't seen that one before. :-)
08:16:49 <LoganCapaldo> f = feature?
08:17:10 <LoganCapaldo> I like my explanation better
08:17:25 <arcatan> f is fo feature
08:17:40 <desegnis> LoganCapaldo: It sounds better, still... What distinguishes a feature flag from non-feature flag?
08:17:40 <dbueno> 404'd? http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html
08:17:41 <lambdabot> http://tinyurl.com/37zra8
08:17:50 <LoganCapaldo> ghc -O2 -fundecidable-instance
08:18:07 <LoganCapaldo> (compile @ 02, and use the undecidable-instances feature)
08:18:10 <DRMacIver> dbueno: The docs all seem to be 404ed at the moment.
08:18:11 <shachaf> From the GCC man page: Many options have long names starting with -f or with -W---for example, -fstrength-reduce, -Wformat and so on.  Most of these have both positive and negative forms; the negative form of -ffoo would be -fno-foo.
08:18:28 <dbueno> DRMacIver: Oh -- my browser must have been pulling the others from my cache. =]  Thanks.
08:18:34 <Vq^> @seen psi
08:18:35 <lambdabot> I saw psi leaving #haskell 1d 19h 24m 30s ago, and .
08:18:35 <LoganCapaldo> gah my mini explanation came out all wrong
08:18:38 <wli> roconnor: The best I can come up with is to go fishing for a bound like |pi - p/q| < eps ==> q > f(eps) for some f.
08:18:40 <DRMacIver> dbueno: Or maybe only some of them are broke. Not sure.
08:18:48 <DRMacIver> dbueno: But the last couple I've looked at were all 404s.
08:19:27 <desegnis> dbueno: The docs are reachable from <http://haskell.org/ghc/docs/latest/html/libraries/>
08:19:52 <desegnis> dbueno: It seems they dropped a version number into the URIs
08:20:11 <DRMacIver> Ah, thanks desegnis
08:20:39 <dbueno> desegnis: I navigated from that page, but it seems I had a cached copy.
08:20:49 <dbueno> desegnis: I just Shift-refreshed, and it looks all different.
08:20:55 <desegnis> Ah.
08:21:05 <dbueno> desegnis: Thanks.
08:22:10 <desegnis> LoganCapaldo: You could argue that ‚Äúcompiling O2‚Äù is a feature, too. I suppose they use -f only for long option names. (But then they could use --undecidable-instances, just as we have --make)
08:22:29 <LoganCapaldo> I'm reading the manual
08:22:57 <LoganCapaldo> and the implication I'm getting is that the -f* ones are all the ones that can be dynamically turned on and off
08:23:18 <LoganCapaldo> eg with ;set in ghci or in {-# OPTIONs... types directives in source files
08:23:32 <desegnis> So it's -f as in dynamic. :)
08:23:42 <LoganCapaldo> apprently :)
08:24:21 <desegnis> According to the lastest release notes, btw, it's -XUndecidableInstances no. Probably -X for extension
08:24:26 <desegnis> s/no/now
08:26:37 <mux> @check \(b,e) (b',e') -> (b :: Int) > (b' :: Int) && (e :: Int) > (e' :: Int) ==> (b^e) > (b'^e')
08:26:39 <lambdabot>  Exception: Prelude.^: negative exponent
08:26:44 <LoganCapaldo> on the other hand as i continue to read there seem to be a few -f* type options that don't look liek they follow that pattern
08:27:00 <desegnis> And according to section 5.9.2 in the current manual it's -f as in optimisation.
08:27:04 <mux> @check \(b,e) (b',e') -> (b :: Int) > (b' :: Int) && (e :: Int) > (e' :: Int) && e > 0 && e' > 0 ==> (b^e) > (b'^e')
08:27:05 <lambdabot>  Falsifiable, after 11 tests: (1,3), (-3,2)
08:27:24 <mux> @check \(b,e) (b',e') -> (b :: Int) > (b' :: Int) && (e :: Int) > (e' :: Int) && b > 0 && b' > 0 && e > 0 && e' > 0 ==> (b^e) > (b'^e')
08:27:25 <lambdabot>  Arguments exhausted after 3 tests.
08:27:35 <LoganCapaldo> I read that
08:28:05 <LoganCapaldo> I think the wording was meant to convery "optimizations that can be done regardles sof platform will be in the -f flag family"
08:28:25 <desegnis> I suppose so
08:29:13 <LoganCapaldo> I don't think there's really a a consistent meaning for f, it's probably just convient to add options there due to the way the code is structered, is my guess :)
08:30:05 <roconnor> wli: I think you should try to prove it doesn't coverge on |Im z|=+/-pi*i
08:30:40 <desegnis> LoganCapaldo: Eh, that's what I only feared might eventually be the reason.
08:30:44 <roconnor> DRMacIver: http://arcanux.org/lambdacats/dumb.jpg
08:31:03 <LoganCapaldo> don't get me wrong I haven't read the code, so I definitely don't know
08:32:49 <desegnis> right
08:32:54 <DRMacIver> roconnor: Heh
08:33:29 <DRMacIver> roconnor: Did you just make that? :)
08:33:59 <roconnor> DRMacIver: nope, I saw it today on lambda cats
08:34:04 <roconnor> but what you said reminded me of it.
08:34:13 <DRMacIver> Ah
08:35:21 <roconnor> @bab nl en haaskarbonade
08:35:22 <lambdabot>   hare chop
08:35:34 <roconnor> ... let's call it pork chop
08:36:40 <Axioplase> hare ? looks like rabbit.
08:37:17 <roconnor> Axioplase: true, but I think the dutch like using rabbit names to name cuts of meat.
08:40:29 <roconnor> @wn mirin
08:40:31 <lambdabot> No match for "mirin".
08:41:43 <roconnor> Mirin (kanji: Âë≥ÈÜÇ; hiragana: „Åø„Çä„Çì) is an essential condiment used in Japanese cuisine, with 40%‚Äì50% sugar.
08:42:04 <wli> roconnor: If there were a delta > 0 so that |f(x + pi*i) - L| < 0 for all x with |x - pi/2| < delta then you get a contradiction wrt. density of poles.
08:42:28 <wli> roconnor: |f(x + pi*i) - L| < epsilon
08:44:52 <wli> roconnor: So it can converge nowhere where |Im z| = pi.
08:47:06 <wli> roconnor: no that's just discontinuity
08:48:54 <conal> ghc-pkg check
08:49:01 <conal> oops - wrong window
08:49:25 <conal> (reading through 6.8.1 release notes)
08:49:50 <EvilTerran> Using username "root".
08:49:54 <EvilTerran> root's password: _
08:51:01 <roconnor> EvilTerran: try asking for the Administrator login instead for conal
08:51:12 <EvilTerran> harumph.
08:51:27 <olsner> @pl \x -> (or (x == True) (x == False))
08:51:27 <lambdabot> liftM2 or (True ==) (False ==)
08:51:47 <roconnor> const True
08:51:59 <EvilTerran> @scheck \x -> (or (x == True) (x == False))
08:52:00 <lambdabot> Couldn't match expected type `[Bool]' against inferred type `Bool'
08:52:12 <EvilTerran> @scheck \x -> (x == True || x == False)
08:52:13 <lambdabot>   Completed 2 test(s) without failure.
08:52:20 <olsner> @pl \x -> (x == True) || (x == False)
08:52:20 <lambdabot> liftM2 (||) (True ==) (False ==)
08:52:32 <roconnor> const True
08:52:49 <roconnor> ... even though it doesn't preserve stupid bottoms
08:53:15 <wli> roconnor: Non-convergence can't be proven without the same sort of analytic estimates required for convergence, or so it seems.
08:53:18 <EvilTerran>  @pl only treats a few higher-order functions as combinators, it won't manipulate anything else except as an abstract thing
08:53:46 <EvilTerran> @pl itDoesn'tEvenCareIfThingsExist
08:53:46 <lambdabot> itDoesn'tEvenCareIfThingsExist
08:53:51 <olsner> roconnor: Bool can be FileNotFound also
08:54:04 <wli> EvilTerran: Its transformations aren't type-preserving, either, for that matter.
08:54:31 <conal> ?liftA2 (||) id not
08:54:31 <lambdabot> Unknown command, try @list
08:54:32 <EvilTerran> er?
08:54:38 <conal> ?type liftA2 (||) id not
08:54:40 <lambdabot> Bool -> Bool
08:55:41 <EvilTerran> wli, surely they would be, if you start in a well-typed expression at least?
08:56:10 <wli> EvilTerran: Sometimes they're more general; I've hit a few cases where they were less general.
08:56:19 <EvilTerran> weird
08:56:37 <wli> EvilTerran: The types are always comparable that I've seen.
08:57:38 <roconnor> @go 4*5 oz in g
08:57:39 <lambdabot> 4 * 5 ounces = 566.990463 grams
09:03:02 <allbery_b> fwiw the only times I've had it end up less general I used ($) --- which @pl is not smart enough to eliminate, apparently --- or I've dropped into a context which triggered the MMR (being pointfree...)
09:04:15 <wli> I don't remember the cases well enough to say.
09:24:20 <geocalc> someone listen here ?
09:24:30 <ZsoL> sure
09:24:30 <ari> I prefer reading
09:24:45 * Oejet is all ears.
09:26:55 * EvilTerran is not all 'ere
09:29:23 <allbery_b> @hoogle listen
09:29:24 <lambdabot> Network.Socket.listen :: Socket -> Int -> IO ()
09:29:24 <lambdabot> Control.Monad.Writer.listen :: MonadWriter w m => m a -> m (a, w)
09:29:24 <lambdabot> Network.listenOn :: PortID -> IO Socket
09:29:30 <wli> @hoogle gc
09:29:30 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
09:29:31 <lambdabot> Data.Typeable.gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
09:29:31 <lambdabot> Data.Typeable.gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
09:29:50 <integral> @hoogle cast
09:29:50 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
09:29:51 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
09:29:51 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
09:30:22 <LoganCapaldo> @type \f -> find f . return
09:30:23 <lambdabot> forall a. (a -> Bool) -> a -> Maybe a
09:31:09 <LoganCapaldo> @pl \f -> find f . return
09:31:09 <lambdabot> (. return) . find
09:31:20 <LoganCapaldo> (.) sections. doh
09:31:44 <LoganCapaldo> I knew there had to be a way
09:33:44 <LoganCapaldo> @type (. return) . (find . not)
09:33:46 <lambdabot>     Couldn't match expected type `a -> Bool'
09:33:46 <lambdabot>            against inferred type `Bool'
09:33:46 <lambdabot>     In the second argument of `(.)', namely `not'
09:34:24 <LoganCapaldo> @type (. return) . (find . (not .))
09:34:25 <lambdabot> forall a. (a -> Bool) -> a -> Maybe a
09:38:10 <LoganCapaldo> @type let { justWhen = (. return) . find ; justUnless = justWhen . (not .) } in (justWhen, justUnless)
09:38:11 <lambdabot> forall a a1. ((a -> Bool) -> a -> Maybe a, (a1 -> Bool) -> a1 -> Maybe a1)
09:39:48 <LoganCapaldo> @pl justUnless f x = if f x then Nothing else Just x
09:39:49 <lambdabot> justUnless = (`ap` Just) . flip flip Nothing . (if' .)
09:42:13 <LoganCapaldo> > let a = 7 in do { x <- Just a ; guard x > 10 ; return x }
09:42:14 <lambdabot>  Couldn't match expected type `Maybe t' against inferred type `Bool'
09:42:34 <LoganCapaldo> > let a = 7 in do { x <- Just a ; guard $ x > 10 ; return x }
09:42:35 <lambdabot>  Nothing
09:42:41 <LoganCapaldo> > let a = 7 in do { x <- Just a ; guard $ x > 1 ; return x }
09:42:42 <lambdabot>  Just 7
09:44:58 <LoganCapaldo> @type let retunWhen p x = guard (p x) >> return x in returnWhen
09:44:59 <lambdabot> Not in scope: `returnWhen'
09:45:11 <LoganCapaldo> @type let returnWhen p x = guard (p x) >> return x in returnWhen
09:45:12 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
09:46:11 <LoganCapaldo> @hoogle (b -> Bool) -> b -> m b
09:46:12 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
09:47:32 <LoganCapaldo> @type \p x -> guard (p x) >> Just x
09:47:33 <lambdabot> forall a. (a -> Bool) -> a -> Maybe a
09:47:48 <desegnis> m
09:48:07 <desegnis> sry... hardware failure
09:53:14 * hgolden is back
09:53:19 <LoganCapaldo> @type \p x -> guard $ liftM not p x >> return x
09:53:20 <lambdabot>     Couldn't match expected type `m a' against inferred type `Bool'
09:53:21 <lambdabot>     In the first argument of `liftM', namely `not'
09:53:21 <lambdabot>     In the first argument of `(>>)', namely `liftM not p x'
09:55:49 <LoganCapaldo> @type \p x -> guard (liftM not p x) >> return x
09:55:51 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
09:56:39 <geocalc> > 1 + 1
09:56:40 <lambdabot>  2
09:57:17 <LoganCapaldo> @type (not <$>)
09:57:18 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f Bool
09:57:23 <hpaste>  sphynx pasted "TemplateHaskell pattern matching on types" at http://hpaste.org/3623
09:57:38 <sphynx> hi!
09:57:52 <geocalc> hi
09:57:58 <sphynx> I have a question related to TemplateHaskell, could you please take a look on my hpaste?
09:58:13 <LoganCapaldo> > not <$> (> 3) 2
09:58:14 <lambdabot>  Couldn't match expected type `f Bool' against inferred type `Bool'
09:58:24 <geocalc> me no
09:58:25 <sphynx> It's about pattern matching on types using ''Type syntax
09:58:25 <LoganCapaldo> > not <$> (> 3) $ 2
09:58:26 <lambdabot>  True
09:58:34 <LoganCapaldo> precedence is ruining my day
09:58:46 <LoganCapaldo> well not really
09:58:54 <LoganCapaldo> I wouldn't have it any other way
10:00:07 <Saizan_> sphynx: tried with guards?: pickleSimpleType (ConT t) | t == ''Int   = .. | t == ''Double = ..
10:00:25 <sphynx> Saizan_: willy try now )
10:00:30 <sphynx> will *
10:00:49 <LoganCapaldo> you can't try willy, no willy wont try
10:00:55 <LoganCapaldo> sorry
10:01:02 <LoganCapaldo> it's saturday
10:01:06 <sphynx> :)
10:01:31 <sphynx> well it works with guards, thanks! Stupid question...
10:03:07 <sphynx> BTW, is there some way of quick testing of ClauseQ? If I try to run "runQ someExprWithReify >>= putStrLn.pprint", it says that can't do reify in IO monad..
10:03:39 <sphynx> so I test it only in code - create [Dec] from Clause and compile it in another module
10:04:51 <Saizan_> i sue something like this: $(runQ someExprWithReify >>= stringL.pprint)
10:04:54 <Saizan_> *use
10:05:26 <Saizan_> ?hoogle stringL
10:05:29 <lambdabot> Language.Haskell.TH.stringL :: String -> Lit
10:05:30 <lambdabot> Language.Haskell.TH.StringL :: String -> Lit
10:05:30 <lambdabot> Text.ParserCombinators.Parsec.Token.stringLiteral :: TokenParser st -> CharParser st String
10:05:52 <Saizan_> ah, so return . LitE . stringL . pprint
10:09:46 <sphynx> Saizan_: hm, so IO monad is not involved in StringL.pprint (but invlved in putStrLn.pprint), so reifying works well, right?
10:10:07 <Saizan_> yes
10:10:44 <Saizan_> and $(..) converts ExpQ in String
10:13:32 <Mourad> me I seek enter free Shell and psybnc /msg Mourad
10:14:13 <ari> If on the other hand all you need is wisdom, speak with Yoda
10:14:36 <salierix> All the documentation links in Hoogle seem to be broken.
10:14:54 <LoganCapaldo> who needs documentation when you have type signatures? :)
10:17:45 <sphynx> is there some handy way to show Q Info got from reify?
10:21:16 <EvilTerran> i think you have to make it into a straing constant Exp and splice it in
10:21:21 <EvilTerran> *string
10:21:23 <EvilTerran> (with show)
10:22:48 <sphynx> EvilTerran: hm... could you please give an example?
10:24:06 <Saizan_> sphynx: replace pprint with show in my previous suggestion
10:25:50 <Saizan_> Prelude Language.Haskell.TH> $(runQ (reify ''Maybe) >>= return . LitE . StringL . show)
10:25:54 <Saizan_> "TyConI (DataD [] Data.Maybe.Maybe [a_1627395804] [NormalC Data.Maybe.Nothing [],NormalC Data.Maybe.Just [(NotStrict,VarT a_1627395804)]] [])"
10:26:52 <keseldude> Hi. So... I'm trying to use GLUT, and I'm on windows at the moment... it says it "can't find the .so/.dll file for: glut32 (addDLL:  unknown error)" Where do I get the dll and where do I put it?
10:27:28 <EvilTerran> ghci> $(liftM (LitE . StringL . show) [| 1 + 2 |])
10:27:28 <EvilTerran> "InfixE (Just (LitE (IntegerL 1))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2)))"
10:27:44 <Zao> keseldude: The GLUT website, unsurprisingly :)
10:27:48 <Zao> http://www.opengl.org/resources/libraries/glut/
10:27:49 <lambdabot> Title: GLUT - The OpenGL Utility Toolkit
10:28:27 <Zao> As for where to put it, either the program directory (preferred) or in the system search path like %WINDIR%\system32
10:28:29 <EvilTerran> ghci> let foo = 23 in $(liftM (LitE . StringL . show) (reify 'foo))
10:28:29 <EvilTerran> "VarI foo_1627397960 (VarT t_1627398176) Nothing (Fixity 9 InfixL)"
10:28:33 <sphynx> Saizan_, EvilTerran: got it, thanks!
10:28:55 <keseldude> hey I think I got it to work
10:28:57 <keseldude> thanks
10:29:15 <EvilTerran> Saizan_, that runQ you had there is embedding Q inside Q, i think
10:29:32 <Saizan_> EvilTerran: it's useless anyway :)
10:29:54 <EvilTerran> trying to runQ to embed Q inside IO would fail if you try to reify, anyway
10:32:26 <sphynx> yeah, it works without runQ too
10:32:47 <sphynx> $(reify ''Int >>= return . LitE . StringL . show)
10:34:57 <wli> I'm still trying to put the matrices together after all this time.
10:35:13 <EvilTerran> well, that's equivalent to the liftM version
10:36:02 <wli> My current futzing around looks like:
10:36:05 <wli> let derivs :: [Double] ; derivs = iterate (*2) 1 ; pascal :: [[Integer]] ; pascal = [1] : zipWith (zipWith (+)) (map (0 :) pascal) (map (++ [0]) pascal) in ((4 >< 4) $ concat $ take 4 $ map (take 4 . (++ repeat 0) . reverse . zipWith (*) derivs . map fromIntegral) pascal) <|> diag (fromList $ replicate 4 $ negate 1)
10:36:05 <phlpp> @src any
10:36:06 <lambdabot> any p =  or . map p
10:36:19 <hpaste>  Karle pasted "Haskell" at http://hpaste.org/3624
10:36:49 <phlpp> @src all
10:36:49 <lambdabot> all p =  and . map p
10:39:52 <salierix> @src State
10:39:52 <lambdabot> Source not found. I feel much better now.
10:41:06 <arcatan> hah
10:41:20 <hpaste>  Karle pasted "Haskell" at http://hpaste.org/3625
10:41:37 <salierix> Looks like ghc 6.8.1 is out.
10:44:43 <luqui> Karle ask a question about 3625?
10:44:57 <dmwit> luqui: Looks like a demonstration, not a question.
10:46:47 <luqui> er, 3624...
10:49:12 <Mourad> me I seek enter free Shell and psybnc plsssss /msg Mourad speak FranÁais
10:49:41 <salierix> The darpa urban challenge is going surprisingly well...
10:50:09 <wli> Urban challenge?
10:50:34 <salierix> You haven't heard about it?
10:50:40 <wli> Not a peep.
10:51:00 <EvilTerran> could someone ban that guy? i don't understand what he's saying, but he's repeating himself, and it sounds a bit dubious
10:51:03 <salierix> http://www.darpa.mil/grandchallenge/
10:51:04 <lambdabot> Title: Welcome
10:51:31 <salierix> http://www.darpa.mil/grandchallenge/overview.asp
10:51:32 <lambdabot> Title: Overview
10:54:14 <allbery_b> sorry, no access here :/
10:56:28 <Karle> hi
10:58:23 <sorear> Hello.
10:58:50 <Trinithis> hi
10:58:50 <sorear> @seen glguy
10:58:50 <lambdabot> I saw glguy leaving #haskell 16h 59m 28s ago, and .
10:58:54 <sorear> @seen Cale
10:58:55 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
10:59:18 <Trinithis> @seen sorear
10:59:18 <lambdabot> sorear is in ##logic, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 24s ago.
11:00:01 <Trinithis> @seen pjd
11:00:01 <lambdabot> pjd is in #haskell. I last heard pjd speak 12h 16m 30s ago.
11:00:07 <sorear> wli: EvilTerran requests an op-judgement
11:00:31 <wli> sorear: What?
11:00:39 <sorear> 10:49 < Mourad> me I seek enter free Shell and psybnc plsssss /msg Mourad speak Fran√ßais
11:00:43 <sorear> 10:50 < EvilTerran> could someone ban that guy? i don't understand what he's saying, but he's repeating himself, and it sounds a bit dubious
11:01:01 <EvilTerran> and before that 1715<Mourad> me I seek enter free Shell and psybnc /msg Mourad
11:01:43 <wli> sorear: Not sure what to say here. Either (a) I'm not an op or (b) I think he's on about Mourad, not me.
11:02:35 <sorear> wli: ChanServ begs to differ
11:02:45 <tehgeekmeister> random curiosity: what os do people in #haskell tend to use?
11:03:10 <mrd> debian
11:03:12 <pejo> tehgeekmeister, all of them.
11:03:20 <salierix> Some form of linux I would think.
11:03:44 <allbery_b> tehgeekmeister: no real preferences here.  windows, osx, linux, openbsd, freebsd, ...
11:03:47 --- mode: ChanServ set +o wli
11:04:02 <sorear> I can handle most of them but prefer unixoids (run Debian at home, as much due to historical reasons as anything else)
11:04:03 <tehgeekmeister> hmm.  okay.
11:04:05 <wli> I didn't realize it had stuck around.
11:04:13 * allbery_b did doublecheck that he hadn't been granted ops here...
11:04:18 <wli> Okay, well, there's clearly botstuff going on.
11:05:18 <allbery_b> (no, I'm not asking or offering... have occasionally been unexpectedly granted ops in various freenode channels.  weird)
11:05:31 <wli> I think he (or it, in the event the client was an inanimate bit such as a bot) is gone.
11:06:10 * wli has just been around for a while.
11:06:35 <sorear> I have that 'problem' too (and did check)
11:07:02 <wli> Like I said, there are people who have started college, learned Haskell, graduated, and gone on to become far, far better Haskell programmers than I since I originally learned it.
11:07:39 <wli> That said, I have been otherwise occupied.
11:08:03 * EvilTerran mostly runs window XP, but can dual-boot to fedora 7, and is quite happy using F7 exclusively on the uni computers
11:08:20 <raxas> unfortunately, there was an ircop hack on Thu, 01 Nov 2007, beware of random ops
11:08:32 <mrd> EvilTerran: have you managed to compile the X11 haskell pkg?
11:08:44 <EvilTerran> I'll probably be switching to fedora exclusively when MS kill support for XP
11:08:48 <EvilTerran> mrd, er, i think so
11:09:15 <EvilTerran> do you need it to build xmonad?
11:09:26 <mrd> I was trying to do that a while back on a fedora machine, and it kept giving me strange errors like "libX11 not found" (but it was there)
11:09:30 <mrd> yea
11:09:44 <allbery_b> hm, that was a faq for x11-extras, probably similar fix needed for X11
11:12:35 <Heffalump> anyone used NixOS?
11:12:39 * Heffalump is quite tempted to try it
11:15:22 <salierix> Never heard of it.
11:15:50 <tehgeekmeister> Heffalump: sounds cool.  if only i still used linux.
11:17:12 <tehgeekmeister> i wonder if it actually has enough apps/hardware support that it's usable?
11:17:43 <dmwit> It's a Linux.
11:17:50 <dmwit> It has all the apps/hardware support that any Linux has.
11:18:14 <Heffalump> well, depends how easy you want things to be
11:18:27 <tehgeekmeister> exactly.  i want the distro to take care of most of that for me.
11:18:35 <tehgeekmeister> or at least make it easy to take care of.
11:18:57 <sphynx> ?hoogle Data.Binary.Get
11:18:58 <lambdabot> No matches, try a more general search
11:19:03 <sphynx> ?hoogle Data.Binary
11:19:04 <lambdabot> No matches, try a more general search
11:20:11 <Heffalump> I'd just run it under VMWare
11:20:42 <tehgeekmeister> yeh, that's what i'd do too.  i need more free space to try something like that, tho.
11:20:54 <tehgeekmeister> i only have 10gb free right now.
11:21:12 <Heffalump> having bought a new computer last year, I still have more space than I know what to do with
11:21:38 <tehgeekmeister> i did the same, but i have lots of music and such.
11:21:39 <pejo> Heffalump, oh, let us take care of your "problem".
11:22:05 <Heffalump> my wife, having got a new computer just a few weeks ago, has *huge* amounts of spare space :-)
11:22:23 <Heffalump> pejo: what with? You won't be able to get it off again very easily, it being the wrong end of an ADSL line :-)
11:23:17 <Heffalump> IDE space in a home is amazingly cheap. SCSI space in a data center is still quite expensive.
11:23:28 <idnar> the new 500GB drive I bought two weeks ago is already more than half full
11:24:31 <pejo> Heffalump, oh, bummer. We need a more symmetric ADSL. :-)
11:24:42 <pejo> Heffalump, I would guess that a data center makes you pay for backup?
11:24:46 <arcatan> symmetric assymetric DSL
11:25:01 <idnar> my hard drives basically just act as a cache for data located elsewhere
11:25:04 <dmwit> assymetric DSL: there's an idiot on both ends
11:25:07 <arcatan> -s
11:31:44 <sphynx> I'm trying to write automatical derivation of pickler functions from 'Pickler combinators' functional pearl
11:32:26 <sphynx> pickling function is of type PU a, so I want to create such function automatically for given type a
11:33:17 <sphynx> at the moment I'm starting to use TemplateHaskell for this. But after some googling and reading haskell wiki I've figured out that there are another approaches to generic programming (e.g. Data.Generics)
11:34:03 <sphynx> I just want to know what approach would be more suitable for my task
11:34:25 <lekro> I'm looking for the documentation of System.Random. anyone know why the site disappeared? http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
11:34:27 <lambdabot> http://tinyurl.com/hch36
11:34:54 <Saizan_> ?docs System.Random
11:34:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
11:35:12 <lekro> 404
11:35:25 <lekro> I don't think it's supposed to be 404
11:36:04 <sorear> the link is correct!
11:36:12 <lekro> yes
11:36:19 * sorear wonders if he should add "YES THE DOCS ARE DOWN" to the topic
11:36:29 <Saizan_> http://www.haskell.org/ghc/docs/latest/html/libraries/random-1.0.0.0/System-Random.html
11:36:31 <lambdabot> http://tinyurl.com/2nlxrw
11:36:45 <lekro> Saizan_: thanks
11:39:28 <LoganCapaldo> Are the docs down?
11:39:33 <salierix> Is there an online source browser for the ghc source code?
11:40:34 <allbery_b> darcs is browseable
11:44:39 <sphynx> ?docs Data.Generics
11:44:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
11:45:08 <mwc> hmmm, how is is that the topic hasn't been updated to reflect the release of 6.8.1?
11:45:17 <Heffalump> pejo: yes, data centers charge to run backups themselves, though we've found we can just backup our server to home computers without trouble. A full restore would require a visit, though.
11:45:22 <Heffalump> mwc: it's been released?
11:45:50 <mwc> http://www.haskell.org/pipermail/glasgow-haskell-users/2007-November/013327.html
11:45:55 <mwc> according to that it has
11:46:05 <mwc> could all be Igloo's evil joke
11:46:22 <dmwit> Is this correct?
11:46:25 <dmwit> http://www.rosettacode.org/rosettacode/w/index.php?title=String_Byte_Length#Haskell
11:46:27 <lambdabot> Title: String Byte Length - Rosetta Code, http://tinyurl.com/2d933b
11:46:38 <dmwit> It doesn't look like it handles Unicode correctly...
11:47:25 <Heffalump> I agree
11:47:39 <dmwit> Is there actually a way to get the byte length of a string in Haskell?
11:48:01 <Heffalump> www.haskell.org seems not to be responding, though
11:48:02 <allbery_b> "byte length" is a slippery concept.  see the Encoding module on hackage
11:48:12 <mwc> dmwit: ByteString perhaps?
11:48:49 <Heffalump> doesn't pack just truncate Chars into Word8?
11:48:53 <mwc> to know the byte length of a unicode string, you need the encoding. So if you assume UTF-32 ;D
11:49:05 <dmwit> allbery_b: Right, which is why I was interested that the page claimed to have a solution. =)
11:49:09 <Rebooted> what would you recommend as a database interface? HDBC? HaskellDB?
11:49:23 <mwc> Rebooted: one is lowerlevel than the other, but I can't recall which
11:49:24 <allbery_b> dmwit: I'd call the entire page iffy, to be hones
11:49:26 <allbery_b> t
11:49:34 <dmwit> yeah
11:49:46 <dmwit> Lots of length("Hello world")-type solutions.
11:49:47 <Heffalump> HDBC is lower-level than HaskellDB
11:49:57 <mwc> thanks Heffalump
11:50:05 <Heffalump> HaskellDB is neat, but it's quite verbose to actually use
11:50:25 <Rebooted> thanks both of you
11:51:22 <Igloo> Anyone got any theories on why haskell.org has gone sluggish?
11:51:40 <mwc> THousands of redditors checking out the link to the 6.8.1 release?
11:51:52 <Igloo> I don't /think/ it should be the release, because that doesn't directly involve any wikimedia pages
11:51:55 <araujo> Igloo, it is getting lazy?
11:52:01 <allbery_b> actually by saying "byte length" I suspect they're trying to avoid such issues, and really mean "the reported length of the default implementation ignoring encoding issues"
11:52:08 <mwc> http://programming.reddit.com/info/5zrcs/comments/
11:52:09 <lambdabot> Title: programming: ANNOUNCE: GHC version 6.8.1
11:52:14 <mwc> Igloo: see what you've wrought?
11:53:04 <sw17ch> What's new with 6.8.1
11:53:19 <sw17ch> * goes to find a changelog
11:53:25 <mwc> sw17ch: pointer tagging, gcc 4.2 support
11:53:30 <mwc> those are my two favourites
11:53:33 <dmwit> allbery_b: There's also a "character length" page.
11:53:38 <mwc> I assume there's been some NCG work too
11:53:41 <sw17ch> mwc: they put pointer tagging in eh???
11:53:43 <mwc> that's always nice
11:53:48 <sw17ch> i read that a while ago
11:53:58 <mwc> sw17ch: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-November/013327.html
11:54:00 <sw17ch> does the performance really work out to be as good as the original paper said it did?
11:54:02 <mwc> partial changelog
11:54:12 <mwc> sw17ch: they're still claiming it is
11:54:27 <sw17ch> mwc: do you believe it?
11:54:41 <mwc> it's hard to argue with the results in GHC itself
11:54:51 <allbery_b> I can't speak to specific changes' effects, but darcs ghc has in my experience been noticeably faster
11:54:55 <mwc> it's either believe it or call the GHC team liars
11:55:08 <mwc> oh, the debugger is present too
11:55:11 <sw17ch> well, i'm happy to hear that =)
11:58:10 <mwc> So Igloo, when I can I expect this in deb/unstable?
11:59:11 <mwc> hmmm, this is strange. haskell.org is still slow
12:01:23 <dons> ?users
12:01:23 <lambdabot> Maximum users seen in #haskell: 424, currently: 379 (89.4%), active: 15 (4.0%)
12:02:16 <Heffalump> wow, where'd they all go?
12:03:27 <wli> NFI
12:05:42 <dons> hmm looks like haskell.org is having a hard time...
12:05:42 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
12:06:04 <mwc> dons: I'm blaming the ocaml guys
12:06:09 <mwc> dos'ing the new ghc release
12:06:21 <dons> yep
12:06:31 <dylan> all three of them?
12:06:43 <LoganCapaldo> ocamlers are downloading the new relase of ghc?
12:06:54 <dons> dylan: :)
12:07:19 <dons> i've mailed the haskell.org maintainer
12:08:49 <dons> i don't think i've seen this happen for a ghc release before
12:09:19 <salierix> I just installed 6.6.1 too...
12:09:49 <dmwit> Me too. =P
12:10:12 <dmwit> But I want the debugger, if only just to try it, so I'll be upgrading.
12:10:58 <LoganCapaldo> I don't want the debugger
12:11:04 <LoganCapaldo> it will make me weak
12:11:07 <LoganCapaldo> ;)
12:11:12 <dmwit> =)
12:11:19 <dmwit> Weak is a good thing, I think.
12:14:05 <adamjones> So, anyone have a guess as to wether building this from source on top of ubuntu's copy of 6.6.1 then removing the ubuntu package will leave me with anything usable?
12:14:28 <adamjones> I'm in the process of finding out now, but any pointers would be nice.
12:14:55 <mwc> adamjones: I presume there'd be some lib breakage as well
12:15:42 <adamjones> fun.
12:15:43 <salierix> I install ghc in my home directory.
12:15:58 <adamjones> salierix: that's probably a better idea.
12:16:14 <dmwit> "It now has its own flag -fwarn-dodgy-imports."
12:16:23 <dmwit> I love that GHC still allows flags with such informal names. =)
12:16:42 <Saizan_> dodgy?
12:16:59 <salierix> It's a british thing.
12:17:01 <arcatan> well.. they're, you know, dodgy
12:17:21 <LoganCapaldo> What sort of imports are considered dodgy?
12:17:38 <LoganCapaldo> import A; import B where both A and B expose a function f ?
12:17:39 <dmwit> LoganCapaldo: importing T(..) when T is an abstract type
12:17:48 <dons> haskell.org seems back in business
12:18:01 <LoganCapaldo> abstract type?
12:18:39 <dmwit> no constructors exported
12:18:56 <LoganCapaldo> ahhm
12:19:36 <dmwit> Oh, no more GHCi ASCII art!
12:19:45 <oerjan> (LITHT (PLUTH 2 2) (TIMETH 3 3))
12:20:01 <oerjan> bah wrong channel
12:20:01 <dmwit> haha
12:20:08 <dmwit> Lisp with a lisp.
12:20:16 <adamjones> yep, quite original.
12:20:17 <LoganCapaldo> Lipth with a lipth
12:20:40 <omnId> LoganCapaldo: who's talking about lips?
12:20:41 <tehgeekmeister> Heffalump: it appears nix is written in c++
12:20:50 <omnId> LoganCapaldo: :P
12:20:52 <adamjones> One of my complaints about english: palindrome doesn't follow lisp's concept of self-reference.
12:20:59 <oerjan> someone in #esoteric made a lithpbot
12:22:43 <dmwit> Also, "ticky-ticky profiling" is an amazing name.
12:23:24 <dmwit> Wait, parsec, regex, and stm are gone?
12:23:24 <adamjones> anyone want to explain what "ticky-ticky" means?
12:23:31 <dmwit> I must be misunderstanding something.
12:24:10 <dmwit> adamjones: It apparently refers to the noise made by a particular computer as it does this kind of profiling. =D
12:24:19 <adamjones> awesome.
12:24:32 <omnId> @go ticky-ticky profiling
12:24:33 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ticky-ticky.html
12:24:33 <lambdabot> Title: 6.7. Using &#8220;ticky-ticky&#8221; profiling (for implementors)
12:24:47 <LoganCapaldo> did they run it on a metronome?
12:24:51 <omnId> "(ToDo: document properly.)"  :D
12:25:11 <desegnis> dmwit: Parsec etc. are considered extralibs now.
12:25:32 <dmwit> desegnis: Oh, this just means they're not installed *by default* any more?
12:25:48 <Heffalump> tehgeekmeister: and?
12:26:03 <Heffalump> I use lots of stuff written in C++ :-)
12:26:08 <tehgeekmeister> oh, i do too
12:26:22 <tehgeekmeister> but i get paranoid when they claim it's entirely deterministic and purely functional
12:26:25 <tehgeekmeister> and it's written in c++
12:26:32 <desegnis> dmwit, this just means you have to unpack the *-extralibs.tar.bz2 file onto your source tree, and they will be installed
12:26:41 <dmwit> ok
12:26:44 <tehgeekmeister> i have no problem with c++ itself.
12:28:28 <dmwit> tehgeekmeister: I guess the first Haskell compilers were written in C[++].
12:28:50 <tehgeekmeister> necessarily, too.
12:29:01 <tehgeekmeister> it's entirely sensible before the language can bootstrap.
12:29:42 <mwc> you could have written it in SML or something as well
12:29:52 <dfranke> is haskell.org getting thwapped because of the ghc release, or is this unrelated?
12:29:55 <mwc> there were better languages than C for writing compilers before Haskell
12:30:16 <dmwit> Yay, forever is defined in 6.8!
12:30:23 <tehgeekmeister> forever?
12:30:30 <dmwit> forever a = a >> forever a
12:30:31 <tehgeekmeister> mwc: yes, that's true.
12:30:39 <mwc> dfranke: I suspect the Ocaml crowd is DOS'ing haskell.org to keep us from being that much further ahead of them
12:30:55 <LoganCapaldo> forever a =loop where loop = a >> loop
12:31:00 <LoganCapaldo> I slow
12:31:09 <dmwit> It's not hard to write for yourself, but it is mildly annoying to do it on every program. =)
12:31:40 <dfranke> mwc: I'm just trying to reach the release notes so I can find out how much further ahead we are.  I know about ATs and the debugger.  What else is new?
12:32:01 <Heffalump> tehgeekmeister: would you have the same paranoia if it was written in Haskell but used the IO monad?
12:32:39 <tehgeekmeister> Heffalump: not at all.  people much smarter than me claim that monads are safe, and i believe them.
12:32:45 <mwc> dfranke: pointer tagging and gcc 4.2 support jumped out at me
12:33:02 <Heffalump> I think you may be a little confused, then :-)
12:33:09 <tehgeekmeister> Heffalump: oh, wait, no, i see the problem.  still, a purely functional language would prevent some problems.
12:33:11 <dfranke> mwc: what is pointer tagging?
12:33:16 <tehgeekmeister> yes, i just didn't notice it right away.
12:33:26 <tehgeekmeister> i'm still getting used to all this.
12:34:06 <Heffalump> if most of the logic was written in a purely functional way, then yes, you could conclude that
12:34:10 <omnId> tehgeekmeister: monads are gravy.  IO is the imperative world.
12:35:32 <tehgeekmeister> nonetheless, a pure language would prevent unintentional statefulness in the package manager -- even if it didn't prevent the problems inherent when you bring in io, which are issues they have to manage explicitly now anyway.
12:35:33 <LoganCapaldo> so once I've built this, should I go back and build it again with itself? :)
12:35:39 <dmwit> :t unsafePerformIO -- no problem, I know how to get rid of the IO monad!
12:35:41 <lambdabot> Not in scope: `unsafePerformIO'
12:36:36 <dmwit> tehgeekmeister: I doubt it.  Usually, statefulness in package managers requires file access... not really something you can do unintentionally.
12:37:00 <dmwit> Still, I like Haskell, they should do a rewrite. ;-)
12:37:02 <mwc> dfranke: pointer tagging is a way of keeping track of the data referenced by pointers in the lower bits of the pointer itself
12:37:29 <mwc> with 4-byte alignment, the lower two bits are always zero
12:37:30 <tehgeekmeister> dmwit: no, i meant in other parts of the logic.  c++ gives plenty of opportunity for accidental state unrelated to any io.
12:37:49 <mwc> dfranke: it sped up GHC itself by 15%
12:37:52 <LoganCapaldo> So like you could encode whether an Either was Left or RIght in the pointer?
12:38:08 <mwc> precisely
12:38:10 <LoganCapaldo> (and then the pointer would jus tpoint directly to the value?)
12:38:21 <mwc> don't know if it goes that far
12:38:58 <sorear> it doesn't
12:39:15 <sorear> but it allows GHC to skip two unpredictable indirect jumps
12:39:32 <sorear> which costs a LOT more than the simple pointer indirection of a known Left
12:39:42 <lekro> is there an easy way to safely drop the last element of a list? it should be like init but it should ignore empty lists (just return those)
12:39:43 <omnId> cool, OverloadedStrings!
12:40:15 <dfranke> cool.  So is this strictly an implementation detail, or does it need hints from the programmer?
12:40:21 <dmwit> no hints
12:40:45 <Heffalump> omnId: very handy, those
12:40:49 <allbery_b> the former
12:40:57 <dmwit> lekro: Maybe, you could do (reverse . drop 1 . reverse) or so?
12:41:14 <dmwit> Or (\xs -> take (length xs - 1) xs).
12:41:29 <omnId> init' [] = []; init' xs = init xs
12:41:49 <dmwit> Wow.
12:41:54 <dmwit> That's so much better.
12:41:56 <lekro> it should also be non-strict i guess
12:42:34 <lekro> your init' looks good, but actually I hoped there'd be some predefined function for this
12:43:08 <dmwit> lekro: Most list functions are for dealing with the beginning of lists.
12:43:18 <dmwit> lekro: If you're dealing with the end a lot, may I suggest you reverse the list?
12:43:32 <lekro> what I'm actually trying to do is getting rid of the last \n in the list unlines gives me
12:43:33 <dmwit> lekro: Or, if you're dealing with both ends, use a different data structure. ;-)
12:44:06 <dmwit> > unlines "hmmm\ndoes it give\nthe newlines?"
12:44:07 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
12:44:17 <dmwit> erp
12:44:24 <dmwit> I get it.
12:44:27 <LoganCapaldo> > unlines ["a", "b"]
12:44:27 <lekro> > unlines ["a", "b"]
12:44:28 <lambdabot>  "a\nb\n"
12:44:29 <lambdabot>  "a\nb\n"
12:44:34 <lekro> > unlines []
12:44:35 <lambdabot>  ""
12:44:49 <LoganCapaldo> > concat $ intersperse "\n" ["a", "b"]
12:44:51 <lambdabot>  "a\nb"
12:44:53 <dmwit> > concat . intersperse "\n" $ ["a", "b"]
12:44:54 <lambdabot>  "a\nb"
12:44:58 <dmwit> Rats, too slow.
12:45:29 <LoganCapaldo> > intercalate "\n" ["a", "b"] -- is this in 6.8.1 ?
12:45:30 <lambdabot>   Not in scope: `intercalate'
12:45:48 <roconnor> ugh, stupid linux audio system
12:45:59 * dmwit consoles roconnor
12:46:02 <pierre-> what are overloaded strings?
12:46:27 <roconnor> okay closing xpdf fixed it.
12:46:30 <lekro> > take 10 $ concat $ intersperse "\n" (cycle "x")
12:46:31 * roconnor sighs
12:46:31 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:46:34 <omnId> pierre-: "blah" :: IsString a => a
12:46:36 <pierre-> this mean i can supply for example bytestring instead of [Char] for String?
12:46:45 <roconnor> I wish I had an operating system that managed audio between applications
12:46:47 <omnId> pierre-: class IsString a where fromString :: String -> a
12:47:07 <dmwit> lekro: s/cycle/repeat/
12:47:19 <pierre-> omnId: thanks, i see now
12:47:25 <lekro> dmwit: ah :)
12:47:26 <LoganCapaldo> > take 10 $ concat $ intersperse "\n" (cycle ["x"])
12:47:27 <lambdabot>  "x\nx\nx\nx\nx\n"
12:47:30 <omnId> pierre-: so given instance IsString ByteString where fromString = pack, yes, you could.
12:49:24 <dmwit> roconnor: Me, too.
12:49:38 <omnId> release notes in case anyone else is interested: http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html
12:49:40 <lambdabot> Title: 1.4. Release notes for version 6.8.1, http://tinyurl.com/3yrwse
12:50:11 <dmwit> Lot's of cool stuff there.
12:50:16 <dmwit> -'
12:50:51 <omnId> disambiguated record fields!   Different record types can now share field names!
12:51:30 <roconnor> dmwit: let's write one in haskell
12:51:49 <wli> One what?
12:52:06 <dmwit> roconnor: Have you *seen* the Linux audio hierarchy?
12:52:11 <dmwit> No way do I want to get into that.
12:52:36 <wli> That area of drivers/ is best described as "unclean."
12:53:02 <adamjones> dmwit: it's a hierarchy? Always more resembled a bog or tar pit to me.
12:53:03 <dfranke> it's not so much the driver level that's bad as all the daemons lumped on top of them.
12:53:34 <dmwit> http://blogs.adobe.com/penguin.swf/linuxaudio.png
12:54:19 * allbery_b thinks you meant "sewer"
12:54:59 * dmwit wants people to agree on one, then make it work.
12:55:06 * dmwit wants impossible things
12:55:53 <dfranke> I would vote for aRts.
12:56:01 <dfranke> (no, it doesn't require KDE)
12:56:15 <dmwit> Unfortunately, people's solution to agreeing on one is to make a new one.
12:56:37 <LoganCapaldo> hehe
12:56:42 <LoganCapaldo> -fwarn-tabs
12:57:19 <dmwit> This is nice for usability:
12:57:22 <dmwit> The ?missing type-signature? warning now tells you what type GHC inferred for the function.
13:00:07 <hpaste>  desegnis pasted "ByteString bug in ghc 6.8.1" at http://hpaste.org/3626
13:00:36 <desegnis> dons: I think I hit a bug in Data.ByteString after compiling the new ghc release. See my paste.
13:01:36 <LoganCapaldo> hooot: GHCi now treats import M at its prompt the same as :module +M.
13:01:40 <desegnis> (Argh. I realise there are no line breaks in my description.)
13:02:57 <desegnis> @seen dons
13:02:57 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 40m 40s ago.
13:03:29 <dons> desegnis: ?
13:04:12 <dons> desegnis: the code hasn't changed. so i wonder what's the issue.
13:04:15 <dons> which version of bytestring?
13:04:34 <desegnis> dons: The one from the extralibs tarball.
13:04:43 <dons> oh the representation of lazy bytestrings changed a bit, so its possible something changed there.
13:05:15 <omnId> LoganCapaldo: awesome!
13:05:15 <dons> what happens when you pipe input from a file?
13:05:27 <pierre-> can i now build all the base libraries as shared?
13:05:52 <desegnis> dons: That works just fine.
13:06:30 <desegnis> dons: As for hypotheses on what could be the issue, don't count on me.
13:08:01 <dons> hmm. i'll look into it
13:08:09 <desegnis> thanks
13:08:20 <dons> compiled, or in ghci, btw?
13:08:56 <desegnis> Compiled, but wait, I'll check ghci
13:09:26 <mauke> that means the program calls read(2) again after having gotten all the input
13:10:04 <kscaldef> is anyone working on a Mac binary for 6.8.1?
13:11:03 <LoganCapaldo> I'm building it on my mac. So yes I am working on a mac binary :)
13:11:09 <LoganCapaldo> or rather ghc is
13:11:27 <desegnis> dons: getContents or BS.getContents and C-d does not work for me in ghci at all, be it 6.8 or 6.6. It just prints ^D
13:11:54 <mauke> probably because ghci changed the terminal settings for interactive use
13:12:06 <dons> yeah
13:12:36 <kscaldef> LoganCapaldo: that you intend to package for others?
13:13:05 <LoganCapaldo> kscaldef: I wasn't really palnning on it.
13:13:10 <desegnis> Ah. readline stuff and such. Well, I wouldn't type stdin by hand from ghci anyway
13:13:11 <LoganCapaldo> *planning
13:13:31 <chessguy> \o/ !!
13:13:41 * chessguy finally solves his new rubik's cube
13:15:02 <omnId> congrats, chessguy!
13:15:10 <omnId> now do it again.
13:15:18 * chessguy is already working on it
13:15:26 <kilimanjaro> I can solve a rubik's cube blindfolded, hanging upside down in briney saltwater without the Coast Guard to protect me from pirates
13:15:28 <lekro> sorry to bother again but where can I find the documentation of Data.List?
13:15:41 <omnId> @docs Data.List
13:15:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:15:42 <dmwit> chessguy: Nice!
13:15:48 <lekro> omnId: that's down
13:15:51 <omnId> oh
13:15:56 <kscaldef> hmm... well, there's not too much point in me working on compiling it myself when my copy of Leopard is due to arrive early next week... I guess I'll just wait until I upgrade the OS, then see if there's a binary build yet or not
13:15:58 <allbery_b> is it?  Data.List shgould still be in base
13:16:09 <allbery_b> it's stuff that got split out that is mislinked, I think
13:16:35 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
13:16:36 <lekro> ah, http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
13:16:37 <lambdabot> http://tinyurl.com/2lz9qt
13:16:37 <lambdabot> http://tinyurl.com/2lz9qt
13:16:40 <allbery_b> oh
13:16:46 <allbery_b> new versioning stuf.  gotcha
13:17:25 <omnId> weird that the new version haddock includes the haskell98 compat modules.
13:17:33 * allbery_b still thinks all those extra version components look way too much like SCCS *shudder*
13:17:50 <omnId> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
13:17:51 <lambdabot> http://tinyurl.com/2lz9qt
13:18:47 * omnId failed to see that posted *twice*, he was busy looking for it.
13:22:00 <omnId> glad to see, though, that the module tree is now first, without the long package list in the way.
13:25:18 <omnId> aww, no source code link in the 6.8.1 haddocks?  :(
13:26:24 <desegnis> Hey, I was sure something was missing there in the upper right corner.
13:26:47 * omnId *uses* that link a lot!
13:28:37 <sphynx> Hm, while playing with TH I've figured out that ConT Data.Tuple.(,,,) and TupleT 4   are the same
13:29:19 <sphynx> former appears from reification of type, but latter from [t| (Int,Int,Int,Int)]
13:30:17 <dons> i love ghc release days
13:30:48 <dons> they come around once a year, like santa claus, with lots of new toys for good children, and new type system extensions for the bad children
13:31:09 <sphynx> And this name Data.Tuple.(,,,...) seems to be the reason why tuple length is limited to 62, right?
13:31:46 <LoganCapaldo> hmm
13:31:57 <sphynx> and I wonder if there are some way to convert TupleT n to ConT Data.Tuple.(,,,) and backwards?
13:31:58 <LoganCapaldo> 62 is suspiciously close to 64 ...
13:32:09 <sphynx> but 2 chars is used for ()
13:32:17 <mauke> wait, 6.8.1 is released?
13:32:29 <omnId> mauke: yep!
13:32:36 <mauke> why didn't anyone tell me? why isn't it in the topic? and what happened to 6.8.0?
13:32:47 <mauke> oh, released today :-)
13:32:49 <omnId> dons: topic!
13:33:20 <dons> topci!
13:33:38 --- mode: ChanServ set +o dons
13:34:17 <dons> ?tiny-url http://www.haskell.org/pipermail/glasgow-haskell-users/2007-November/013327.html
13:34:18 <lambdabot> http://tinyurl.com/2nel76
13:34:24 <lament> a debugger? whee (?)
13:34:51 <omnId> dons: maybe also include release notes
13:34:55 --- topic: set to '["The Haskell programming language","GHC 6.8.1 is out!! http://tinyurl.com/2nel76","http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","http://arcanux.org/lambdacats.html"]' by dons
13:34:56 <omnId> ?tiny-url http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html
13:34:57 <lambdabot> http://tinyurl.com/3yrwse
13:35:13 <dons> well, they're linked from the announce
13:35:21 <dons> see also http://programming.reddit.com/info/5zrcs/comments/
13:35:23 <lambdabot> Title: programming: ANNOUNCE: GHC version 6.8.1
13:35:25 <dons> for strange comments
13:36:13 <lament> the startup banner is gone!! oh no!!
13:36:22 <stepcut> heh
13:36:32 <Korollary> were you an avid fan?
13:36:49 <lament> it's the main reason I use Haskell.
13:36:56 <allbery_b> *snrk*
13:37:15 <omnId> which reminds me, I still don't know where .ghci lives on Windows.
13:37:36 <Korollary> Documents And Users/YourUser perhaps on XP?
13:37:44 <sorear> lament: it's not THAT good
13:38:02 <omnId> Korollary: tried that and a few others with no luck in 6.6.1
13:38:34 <omnId> tried ghc\bin
13:38:34 <Korollary> omnId: I guess you have to look in the source code to see which folder it checks
13:38:45 <lament> sorear: you're right. I guess I'll switch to CLISP.
13:38:50 <omnId> I'll poke around, then.
13:39:06 * allbery_b gives lament a logo interpreter
13:39:59 --- mode: ChanServ set -o dons
13:40:16 <mauke> heh, bundling ghc into gcc
13:40:31 <dons> i bet the gcc guys would love that
13:40:34 <stepcut> :p
13:40:46 <sjanssen> ooh, 6.8.1 is out
13:41:11 <dons> sjanssen: time to think about xmonad support :)
13:41:24 <dons> hey nostrademons
13:41:28 <dons> got the new ghc release yet?
13:41:36 <dons> we got some pointer tagging action going on...
13:41:38 <idnar> GNU Haskell Compiler
13:41:48 <nostrademons> hey dons
13:42:01 <omnId> if anyone knows offhand where I would find that kind of thing in the ghc source tree, tell me, otherwise I'll look myself.
13:42:25 <nostrademons> you see the thread on programming paradigms on Proggit?
13:42:46 <nostrademons> I was kinda curious about you opinion on the Haskell-optimization subthread
13:43:09 <nostrademons> since you did many of the shootout entries and actually have some real world experience with it
13:43:55 <nostrademons> http://programming.reddit.com/info/5zpub/comments/c02dbjn
13:43:57 <lambdabot> Title: programming: Ask Reddit: Are there any programming paradigms besides functional  ...
13:44:17 <allbery_b> omnId: at a first guess, drivers/ghci/
13:44:22 <jr_> Newbie question: do I have to compile packages (e.g. HSQL) again for ghc6.8.1?
13:44:28 <allbery_b> which, oddly enough, contains a rather suggestive ghci.rc
13:44:30 <Heffalump> jr_: yes
13:44:34 <ddarius> Impredicative instantiantiation is back?
13:44:43 <lament> http://programming.reddit.com/info/5zpub/comments/c02dbjn
13:44:44 <lambdabot> Title: programming: Ask Reddit: Are there any programming paradigms besides functional  ...
13:44:44 <omnId> allbery_b: looking at compiler/ghci/InteractiveUI.hs
13:44:47 <lament> whoops
13:45:07 <allbery_b> hm, right
13:45:22 <jr_> Heffalump: ok thanks
13:45:25 <dons> nostrademons: what was your concern?
13:45:27 * allbery_b just discovered how off his first guess was, by being reminded that windows needs "help" with some things
13:45:33 <omnId> ghci.rc contains one line: 0 ICON "ghci.ico"
13:45:47 <allbery_b> yeh, hadn't realized that was windows specific
13:45:52 <nostrademons> I was just kinda curious about whether Haskell's normally optimized by making it lazier & more functional or stricter & more imperative
13:45:56 <allbery_b> that's a windows resource compiler source file
13:46:38 <dons> nostrademons: hmm, both come into play. for microbenchmarks precise evaluation order is usually used, since there's some optimal reduction based on the cpu that we want, which means strictness to specify that order
13:46:50 <dons> nostrademons: for big programs, often you'll want more laziness
13:46:56 <dons> to glue components together
13:47:07 <dons> e.g. xmonad is lazy all over
13:47:13 <dons> workspaces you never use are never created
13:47:45 <nostrademons> interesting.  basically what I suspected
13:47:49 <dons> the shootout is cpu/cache benchmarks though, which means using strictness to pick an optimal reduction order, usually. not really a surprise
13:47:55 <dons> and similar for other low level code
13:47:57 <nostrademons> yeah
13:48:14 <dons> so the language has to support laziness by default, and strictness when its worth your while choosing some particular order of eval
13:48:52 <dfranke> is parallel make (-j) safe for building ghc?
13:49:05 <omnId> allbery_b: first "./.ghci", then System.Posix.getEnv "HOME" -- :(
13:49:10 <monochrom> I believe so. dons did that.
13:49:16 <dons> dfranke: yes, definitely
13:49:29 <omnId> looks like I have no global option on windows.
13:49:34 <dons> i typically use -j3 for 2 cores, and up to -j20 on 16 cores
13:49:47 <salierix> Geez, the MIT darpa challenge bot has 40 CPU cores...
13:49:48 <dfranke> this is an 8-core box, so -j10
13:49:55 <dons> yeah
13:50:02 <dons> should be nice and zippy to compile then
13:50:17 <idnar> omnId: why not set HOME?
13:50:29 <allbery_b> er?
13:50:52 <allbery_b> can't you set envars somewhere under the System control panel?
13:50:59 <monochrom> ghc 6.8.1 is out?!!!
13:51:04 * monochrom goes download
13:51:07 <allbery_b> (modulo how XP rearranged the control panels)
13:51:47 <adamjones> Has anyone else run into issues with the configure for 6.8.1 failing to detect that happy wasn't installed when the make process depends on it?
13:52:18 * ddarius thinks Visual Studio should be added to the GCC.
13:52:23 <adamjones> this could entirely be due to my rather poor understanding of unix compilation tools in general.
13:52:23 <gcc> good idea
13:53:07 <omnId> idnar: I saw '#ifndef mingw32_HOST_OS /
13:53:07 <omnId> import System.Posix hiding (getEnv)' and assumed, lemme try.
13:53:09 <monochrom> hahaha
13:53:32 <gcc> can someone link me to a simple hello world haskell program?
13:53:44 <monochrom> main = putStrLn "hello world"
13:54:14 <LoganCapaldo> actual program shorter than link to program :)
13:54:30 <gcc> lol
13:54:35 <gcc> i can compile that rigt now?
13:54:46 <adamjones> No. You have to put it in a file first.
13:54:50 <LoganCapaldo> if you have a haskell compiler installed
13:54:51 <gcc> yeah im doin it
13:54:56 <idnar> omnId: ah, well, I haven't looked at the code or used ghci under win32, was just suggesting it off the cuff
13:54:59 <gcc> whats a typical haskell compiler
13:55:02 <LoganCapaldo> ghc
13:55:12 <chessguy> and you'll need "module Main/nwhere"
13:55:14 <gcc> ok i dont have it. im on Mac OS X 10.5 Leopard
13:55:16 <monochrom> Put it into say Whee.hs.  ghc --make Whee.hs.  Look for the executable and run it.
13:55:16 <omnId> idnar: works, awesome!
13:55:22 <ddarius> chessguy: You shoudn't.
13:55:24 <sjanssen> chessguy: no, that's implicit
13:55:28 <chessguy> oh really?
13:55:30 <sjanssen> yes
13:55:33 * chessguy shuts up
13:55:36 <ddarius> And blech "module Main where\n"
13:55:44 <monochrom> It's optional.
13:56:08 * chessguy really needs to learn to not open his mouth
13:56:18 * monochrom ties up chessguy's hands
13:59:02 <Karle> hi
13:59:03 <monochrom> www.haskell.org seems slow to my place today
13:59:30 <omnId> hello, Karle.
13:59:36 <ddarius> monochrom: The paperboy is spiting you.
13:59:38 <Karle> hi omnId
13:59:56 <monochrom> Is everyone flocking to download ghc 6.8.1 causing congestion? :)
14:00:08 <allbery_b> it is, we figure the ghc releae has slashdotted it
14:00:26 <monochrom> That is an indicator of success. :)
14:01:11 <monochrom> I will download later.
14:01:18 <allbery_b> hm, where's Cale to grouse about success?
14:01:35 <allbery_b> :)
14:02:01 <monochrom> "Avoid success at all cost - our web server would die otherwise!" :)
14:02:16 <Trinithis> @seen pjd
14:02:16 <lambdabot> pjd is in #haskell. I last heard pjd speak 15h 18m 45s ago.
14:02:21 <Trinithis> @seen Cale
14:02:21 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
14:02:47 <LoganCapaldo> > [-2,-1,0,1,2,3..]
14:02:48 <lambdabot>  Parse error at "..]" (column 15)
14:02:58 <LoganCapaldo> >[1,2,3..]
14:03:02 <LoganCapaldo> > [1,2,3..]
14:03:03 <lambdabot>  Parse error at "..]" (column 7)
14:03:09 <LoganCapaldo> > [1..]
14:03:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:03:22 <LoganCapaldo> > [1,2..]
14:03:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:03:26 <LoganCapaldo> I see
14:03:28 <Trinithis> > [-1..]
14:03:30 <lambdabot>  [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
14:03:37 <LoganCapaldo> that works
14:03:59 <raxas> any tips for good examples how to use stuff from Control.Applicative?
14:04:17 <jr_> how long does ghc usually take to compile (I'm on a 1.6Ghz Macbook (Yonah) with 1Gig of RAM, ghc6.6)
14:04:23 <Trinithis> @seen thetallguy
14:04:23 <lambdabot> thetallguy is in #haskell. I last heard thetallguy speak 15h 3m 17s ago.
14:05:15 <jr_> that is, using ghc6.6 to compile 6.8.1 right now
14:05:53 <monochrom> jr_: I have a P4 2GHz with 1GB RAM. It takes hours to build both the compiler and the extralibs.
14:06:28 <sjanssen> jr_: less than an hour (assuming you've passed -j2)
14:07:08 <monochrom> If I just build, it's easily 8 hours. In practice I change some config file to say "I don't want -fvia-C, I want -fasm", and that brings it down to 4 hours.
14:08:17 <monochrom> Perhaps the extralibs part is the bulk of it. But I like extralibs. Too lazy to hunt down individual libraries later.
14:08:53 <gcc> ok can someone tell me a simple hello world program in haskell so i can compile it?
14:09:04 <monochrom> main = putStrLn "hello world"
14:09:10 <monochrom> Put it into say Whee.hs.  ghc --make Whee.hs.  Look for the executable and run it.
14:09:13 <gcc> i have this
14:09:14 <gcc> main = putStrLn "hello world"
14:09:15 <allbery_b> @go 99 bottles haskell
14:09:18 <lambdabot> http://99-bottles-of-beer.net/language-haskell-1070.html
14:09:19 <lambdabot> Title: 99 Bottles of Beer | Language Haskell
14:09:27 <monochrom> (P.S. Are you a finite state automaton?)
14:09:30 <gcc> i did this
14:09:32 <gcc> ghc --make test.hs
14:09:40 <monochrom> "test" is a poor name.
14:09:41 <gcc> it shoots me with errors
14:09:52 <monochrom> Oh, but errors, how could it be?
14:09:56 <salierix> Looks like xmonad still has a few bugs.
14:09:57 <gcc> oh your right. that explains why i get errors.
14:10:01 <gcc> thanks for pointing it out! =D
14:10:22 <zeloran> hey
14:10:23 <monochrom> ./test instead of just test
14:11:02 <monochrom> Whee is a superior name, and I love it. :)
14:11:20 <gcc> http://rafb.net/p/Rqe0zu95.html
14:11:21 <lambdabot> Title: Nopaste - No description
14:11:58 <sjanssen> gcc: your ghc is badly broken
14:12:21 <allbery_b> that looks like you have a ppc backend on intel
14:12:33 <monochrom> yeah!
14:12:45 <gcc> oh whoops
14:12:52 <gcc> well im on an intel imac
14:12:58 <gcc> know a better compiler?
14:13:17 <monochrom> http://www.haskell.org/ghc/download_ghc_661.html#macosxintel
14:13:19 <allbery_b> go back and find the intel version?
14:13:21 <lambdabot> Title: GHC: Download version 6.6.1
14:13:29 <zeloran> how to solve this in haskell:
14:13:30 <zeloran> data Expr = Con Int | Var String | Sum [Expr] | Prod [Expr] deriving Show
14:13:42 <zeloran> i want to write a function simplify
14:13:42 <sorear> gcc: btw, we have a channel pastebin - hpaste.org
14:13:43 <monochrom> Look for "MacOS X 10.4 (Tiger) Intel"
14:13:51 <zeloran> that takes an Expr
14:13:58 <gcc> but im not in tiger
14:14:02 <gcc> im in cheetah
14:14:26 <zeloran> and simplifies it in this way that for example Prod[Con 1,Con 0,Con 3] = Con 0
14:14:27 <allbery_b> "leopard" --- but tiger bins will work for now
14:14:35 <zeloran> because 1*0*3=0
14:14:40 <omnId> zeloran: write the cases one by one.
14:14:45 <allbery_b> it may be a while before all the various binary versions are updated
14:15:06 <zeloran> at the moment i only have: simplify (Prod (Con 0:_)) = (Con 0)
14:15:17 <monochrom> I admit I have never used MacOS and certain details I would never know.
14:15:22 <omnId> zeloran: you have variables, so it look's like you'll need a variable mapping passed into simplify, too.
14:15:23 <zeloran> which only work of course if the first element ist Con 0
14:15:37 <allbery_b> (I think audreyt was doing the intel OSX binaries for a while but she's kinda gone missing)
14:15:50 <omnId> simplify :: Expr -> Map String Exp -> Exp
14:16:14 <zeloran> no i have simplify :: Expr -> Expr
14:16:25 <allbery_b> <omnId> zeloran: you have variables, so it look's like you'll need a variable mapping passed into simplify, too.
14:16:27 <zeloran> what would your definition mean
14:16:31 <omnId> zeloran: then what would simplify (Var x) equal?
14:16:39 <monochrom> Var x
14:16:41 <zeloran> yes
14:16:50 <zeloran> simpl(Var x) Var x
14:16:53 <zeloran> =
14:17:07 <monochrom> It's "simplify". It is not "evaluate".
14:17:09 <omnId> so any sums or products with Vars will also be unsimplifyable.
14:17:12 <omnId> oh
14:17:20 <zeloran> i think monochrom got it
14:18:09 <zeloran> i want just to simplify expressions in the way that for Products that have an zero in it the hole expressions simplifies to zero
14:18:12 <monochrom> Hopefully, simplify (Sum [Var "x", Con 0] ) = Var "x"
14:18:43 <omnId> zeloran: your example should be fine, then.
14:18:51 <zeloran> o really
14:18:53 <zeloran> not
14:18:58 <zeloran> because
14:19:01 <Saizan_> simplify (Prod xs) | any (== Con 0) xs = Con 0
14:19:08 <Saizan_> ?type any
14:19:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:19:31 <zeloran> thats sound like a solution Saizan
14:19:36 <zeloran> i will give it a try
14:20:11 <omnId> you'll need deriving Eq on Exprs.
14:20:38 <zeloran> how to do?
14:20:48 <omnId> data Expr = ... deriving (Eq, Show)
14:20:52 <zeloran> ok thx :)
14:21:05 <omnId> I might map simplify accross the xs first, too.
14:21:19 <omnId> simplify (Prod xs) | any (== Con 0) (map simplify xs) = Con 0
14:21:55 <zeloran> o amaizing it works xD
14:22:18 <zeloran> nice (short) way to solve such problems
14:22:56 <omnId> ... | all isCon (map simplify xs) = product (map unCon xs)
14:23:27 <omnId> unCon (Con x) = x; isCon (Con x) = True; isCon _ = False
14:23:48 <Saizan_> omnId: forgot a simplify
14:23:53 <omnId> forgot the Con in the rhs above.
14:24:08 <zeloran> a bit to hard for a newbie like me :/
14:24:34 <omnId> Saizan_: hm?  I map simplified xs.  Where did I miss?
14:24:43 <zeloran> why shall i use the map?
14:24:56 <zeloran> instead of only "any (== Con 0) xs
14:24:57 <omnId> zeloran: to simplify each factor in the Prod
14:25:19 <zeloran> so that Prod[ Prod[ ... works?
14:25:20 <roconnor> aaaaaaaaaaaaaahhh ``An Ceiling Cat sayed, Beholdt, the Urfs, I has it, An I has not eated it.
14:25:23 <omnId> unless you only want to simplify the top level.
14:25:27 <roconnor> http://www.lolcatbible.com/index.php?title=Genesis_1
14:25:28 <lambdabot> Title: Genesis 1 - LOLCat Bible Translation Project
14:25:33 <roconnor> the wrongness
14:25:49 * omnId shoots the interent
14:25:58 <omnId> -net*, even
14:26:24 <omnId> she needed to be put down, she was too full of stupid.
14:26:43 <roconnor> ``An Ceiling Cat sayz, i can haz lite? An lite wuz.
14:27:11 <allbery_b> erm, -blah is over there
14:27:26 <omnId> oh god, this doesn't have *every* book and chapter, does it?
14:27:39 <zeloran> the | means a "case-operator" ?
14:27:51 <omnId> zeloran: a guard
14:27:57 <zeloran> is there a default case ?
14:28:04 <omnId> otherwise
14:28:11 <roconnor> omnId: ``oh Ceiling Cat, this doesn't have *every* book and chapter, does it?
14:28:37 <omnId> zeloran: it adds a boolean check before moving into the rhs.  So if the last check is True, it'll always pass.
14:28:40 <omnId> @src otherwise
14:28:40 <lambdabot> otherwise = True
14:29:02 <allbery_b> (sorrym but when #haskell is busy like now it's best to move that stuff elsewhere, hard enough to keep up)
14:29:05 <Saizan_> omnId: you need to pass a simplified xs to map unCon
14:29:31 <omnId> Saizan_: oh, right
14:29:58 <omnId> Saizan_: it'd probably be easier to have a where simple = map simplify xs
14:31:10 <omnId> | all isCon simple = Con (product (map unCon simple))
14:32:17 <zeloran> at the moment i have
14:32:18 <zeloran> simplify (Prod xs) | any (== Con 0) (map simplify xs) = Con 0
14:32:18 <zeloran>                    | otherwise = Prod xs
14:32:18 <zeloran> 									
14:32:18 <zeloran> 									
14:32:18 <zeloran> simplify (Con xs) = (Con xs)
14:32:25 <zeloran> and it works :)
14:33:23 <zeloran> seems to work
14:33:31 <hpaste>  Paczesiowa pasted "Parse this!" at http://hpaste.org/3628
14:33:33 <paczesiowa> could anyone look at that?
14:35:09 <twanvl> have you used parsec before?
14:35:10 <omnId> paczesiowa: is that Prolog?  I suppose you'd need a Prolog grammar.
14:36:48 <paczesiowa> yes, i've used parsec. it's not about prolog grammar, the problem is prolog can alter operators associativity in the middle of parsing, which results in different parsetrees for 1-1-1, is it possible to parse this using parsec?
14:37:16 <hpaste>  omnId pasted "for zeloran" at http://hpaste.org/3629
14:38:14 <twanvl> you should fix up the associativity after parsing
14:38:36 <ddarius> Yes it is possible to parse that with Parsec.
14:40:38 <paczesiowa> twanvl: I don't understand how do I do that after parsing, and to what intermediate representation should I parse in the first place
14:41:00 <twanvl> You could parse it as if all operators are left associative
14:41:15 <twanvl> most haskell parsers do this as well
14:41:31 <omnId> maybe: Infix [Op] [Expr], with length ops == length exprs - 1
14:42:02 <zeloran> i try :) @ omn
14:43:49 <paczesiowa> omnId: that could work, but then how do I know whuch operators should change assoc. ? besides it's ugly I think, 2-pass parsing? there are single-pass compilers out there
14:44:15 <twanvl> paczesiowa: look at http://code.haskell.org/lambdabot/Lib/FixPrecedence.hs for a well commented example
14:44:39 <wli> Doesn't laziness make it singlepass anyway?
14:44:41 <sw17ch> Does some one have time to explain the difference between "data" and "class" to me?
14:45:30 <paczesiowa> twanvl: thx
14:45:52 <omnId> sw17ch: data defines new datatypes, class introduces new typeclasses, which specify interfaces that many types could implement.
14:46:25 <sw17ch> omnId: thanks. so the datatype could be thought of as similar to a "struct" then.
14:46:32 <sw17ch> i guess i don't really understand the concept of a typeclass
14:46:46 <twanvl> what language do you know? C?
14:46:47 <sjanssen> sw17ch: Haskell "class" has nothing to do with OO "class"
14:46:48 <omnId> class Eq a where equal :: a -> a -> Bool;  instance Eq Int where equal 0 0 = True; equal 1 1 = True; ...; equal _ _ = False
14:47:39 <sw17ch> omnId: so you create a class, and then can create types that implement the interface to the class
14:47:57 <KatieHuber> Haskell "class" is a *bit* like a Java interface
14:48:08 <KatieHuber> if you really have to relate to some OO concept
14:48:21 <TomMD> sorear: is there a hidden dependency for the pcap bindings?  I seem to recall it needs a certain libpcap-dev, and I obviously don't have the right one.
14:48:35 <sw17ch> twanvl: I know a lot of C... don't know much java... Perl, Ruby, JavaScript, C++, PHP, ... etc..
14:48:43 <sw17ch> wait... i only don't know java very well
14:48:54 <sw17ch> the rest of those i can work with just fine
14:49:01 <omnId> a Java or C++ or whatever "class" is three things simultaneously:  a concrete datatype with data members (Haskell data); an set of types that satisfy an interface, usually using subtypes (Haskell class); and an assertion that the concrete type implements that interface (Haskell instance)
14:49:50 <sw17ch> omnId: Enum is a class, right?
14:49:54 <omnId> yes
14:49:57 <omnId> @src Enum
14:49:57 <lambdabot> class  Enum a   where
14:49:57 <lambdabot>     succ                     :: a -> a
14:49:57 <lambdabot>     pred                     :: a -> a
14:49:57 <lambdabot>     toEnum                   :: Int -> a
14:49:57 <lambdabot>     fromEnum                 :: a -> Int
14:49:59 <lambdabot> [3 @more lines]
14:50:04 <omnId> > succ 1
14:50:05 <lambdabot>  2
14:50:06 * Cale notices the new version of GHC :)
14:50:08 <omnId> > succ False
14:50:09 <lambdabot>  True
14:50:20 <omnId> @instances Enum
14:50:21 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:50:27 <omnId> > succ 'a'
14:50:28 <lambdabot>  'b'
14:50:29 <sw17ch> so if i make a datatype and want it to implement the Enum class... (is that the right terminology?)... i need to implement succ, pred, toEnum, fromEnum... for the datatype
14:50:33 <KatieHuber> ooh, 6.8.1
14:50:52 <omnId> sw17ch: yes, and other methods that LB omitted (3 @more lines)
14:51:02 <paczesiowa> is there a online changelog for ghc?
14:51:23 <omnId> paczesiowa: the topic links to an announcement, the announcement to the changelog
14:51:27 <sw17ch> omnId: ah, so there's a strict separation between what things are and how you work with them... (data/methods)
14:52:08 <paczesiowa> omnId: can't connect to haskll.org/* :-(
14:52:27 <omnId> paczesiowa: check the ghc trac
14:52:32 <omnId> @go ghc trac
14:52:35 <lambdabot> http://hackage.haskell.org/trac/ghc
14:52:35 <lambdabot> Title: GHC - Trac
14:52:49 <ddarius> paczesiowa: If you want to change the associativity of operators as you parse you can carry around a table of parsers and update it as you parse a fixity declaration.
14:53:18 <paczesiowa> ddarius: carry that table inside parsec's state?
14:53:36 <paczesiowa> ddarius: that looks neat
14:53:49 <omnId> sw17ch: yep, and it makes for some interesting kinds of overloading, like on the return type.
14:53:59 <omnId> > fromInteger 1 :: Int
14:54:00 <lambdabot>  1
14:54:01 <omnId> > fromInteger 1 :: Float
14:54:03 <lambdabot>  1.0
14:54:09 <omnId> @instances Num
14:54:10 <lambdabot> Double, Float, Int, Integer
14:54:21 <omnId> > fromInteger 1 :: Data.Ratio.Ratio Integer
14:54:22 <lambdabot>  1%1
14:54:49 <sw17ch> wow
14:54:50 <omnId> fromInteger is a Num method
14:55:09 <kpreid> maxBound is my favorite example, since it's "not a function"
14:55:16 <kpreid> > maxBound :: Int
14:55:17 <lambdabot>  2147483647
14:55:17 <omnId> > maxBound :: Char
14:55:19 <lambdabot>  '\1114111'
14:55:29 <omnId> @src Bounded
14:55:29 <lambdabot> class  Bounded a  where
14:55:29 <lambdabot>     minBound, maxBound :: a
14:55:45 <sw17ch> nice =)
14:55:53 <sw17ch> > maxBound :: Num
14:55:54 <lambdabot>      Class `Num' used as a type
14:55:54 <lambdabot>     In the type `Num'
14:55:54 <lambdabot>     In an expression ty...
14:55:59 <sw17ch> oh shoot
14:56:01 <sw17ch> that's right
14:56:07 <omnId> yeah, Num is a class, not a type.
14:56:12 <sw17ch> @src Num
14:56:12 <lambdabot> class  (Eq a, Show a) => Num a  where
14:56:12 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:56:12 <lambdabot>     negate, abs, signum     :: a -> a
14:56:12 <lambdabot>     fromInteger             :: Integer -> a
14:56:12 <zeloran> thx again omnId, i did not really understand your hole paste yet - but i learned from it :)
14:56:33 <zeloran> whole
14:56:48 <sw17ch> > maxBound Integer
14:56:49 <lambdabot>   Not in scope: data constructor `Integer'
14:56:54 * kpreid wonders why types and classes are even in the same namespace
14:57:03 <kpreid> oh, right, export/import
14:57:04 <sw17ch> > maxBound :: Integer
14:57:05 <lambdabot>   add an instance declaration for (Bounded Integer)
14:57:05 <lambdabot>     In the expression: ma...
14:57:14 <omnId> Integers are unbounded :)
14:57:18 <sw17ch> @instances Bounded
14:57:19 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
14:57:30 <zeloran> i'm now trying to do some simililiar for Sums like simplify (0+3+2) = 3+2
14:57:31 <sw17ch> :t 10^20
14:57:32 <lambdabot> forall t. (Num t) => t
14:57:49 <omnId> > [minBound..maxBound] :: [Ordering] -- quick way to enumerate a type
14:57:50 <lambdabot>  [LT,EQ,GT]
14:57:51 <paczesiowa> :t 10^20 :: Integer
14:57:52 <lambdabot> Integer
14:57:56 <paczesiowa> :t 10^20 :: Double
14:57:57 <lambdabot> Double
14:58:08 <sw17ch> >[minBound..maxBound] :: Char
14:58:11 <sw17ch> > [minBound..maxBound] :: Char
14:58:12 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
14:58:13 <paczesiowa> it is what you want it to be:>
14:58:17 <sw17ch> > [minBound..maxBound] :: Chr
14:58:18 <lambdabot>   Not in scope: type constructor or class `Chr'
14:58:21 <omnId> list of Chars
14:58:31 <sw17ch> > [minBound..maxBound] :: [Char]
14:58:33 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
14:58:35 <sw17ch> oic
14:58:46 <sw17ch> ah, cool
14:59:01 <omnId> > [minBound..maxBound :: Char] -- you could also specify the type of just a bound
14:59:03 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
14:59:18 <sw17ch> omnId: so this brings me to my next question (if you're interested in answering more ;) )
14:59:30 <omnId> :)
15:00:07 <sw17ch> data MyData1 = MyData1 MyData2 MyData3
15:00:15 <omnId> +|
15:00:26 <omnId> unless MyData2 and MyData3 are themselves types.
15:00:34 <sw17ch> well, I was more thinking something like this
15:00:39 <sw17ch> data LispValue = Representation Value
15:01:03 <omnId> if Representation is a type, you'll need a constructor for LispValues
15:01:06 <sw17ch> working on a lisp parser, and I want each Atom/String/Boolean/List/Number... etc
15:01:17 <omnId> data LispValue = Val Representation Value
15:01:41 <sw17ch> omnId: i see people use the data type name for the ... is the first one the constructor name?
15:01:48 <omnId> yes
15:01:55 <paczesiowa> sw17ch: there is easy googlable simple lisp interpreter with great comments for newbies
15:02:10 <sw17ch> the scheme in 48 hours one?
15:02:12 <omnId> data <Name> <params> = <Con> <params> | <Con> <params> | ...
15:03:05 <paczesiowa> sw17ch: no
15:03:28 <paczesiowa> sw17ch: http://www.defmacro.org/ramblings/lisp-in-haskell.html
15:03:29 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
15:03:52 <sw17ch> ah, when i started ... i wasn't quite able to keep up with that, but perhaps i can now
15:04:02 <omnId> sw17ch: types and values are in different namespaces, so you can, and people often do, use the same name for the type and its constructor.
15:04:23 <sw17ch> omnId: is there a reason not to?
15:05:02 <omnId> *shrug*, if you have several, it'd sort of give preference to the one.
15:05:24 <omnId> the tuple types use the same name
15:05:29 <sw17ch> does Blaise hang out in here at all?
15:05:33 <omnId> @src (,)
15:05:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:05:43 <omnId> data (a,b) = (a,b)
15:05:55 <omnId> where (,) is the type name and constructor name.
15:06:16 <sw17ch> ohhhh...
15:06:27 <sw17ch> alright, i'm starting to see this ... thanks
15:06:28 <sw17ch> =)
15:06:38 <omnId> it's a special case, though, since you can't normally put commas in an identifier.
15:06:53 <omnId> otherwise the type and representation itself is plain-jane haskell.
15:07:02 <sw17ch> quite cool
15:07:06 <omnId> data Pair a b = Pair a b -- same thing with different names.
15:07:20 <allbery_b> if you're not familiar with haskell it can be a little confusing; if you are, it helps you associate types and values
15:07:47 <allbery_b> and since it's usually fairly clear when you're in a type context vs. a value context...
15:08:06 <sw17ch> allbery_b: i'm not quite to that point yet, but I'm getting close
15:08:28 <sw17ch> i haven't had to do much with data/class/instance yet
15:08:29 <omnId> yeah, newbies usually aren't quite clear on that point, though, but it comes, and it's very black-and-white.
15:08:50 <omnId> which things are terms and which things are types.
15:08:51 <paczesiowa> why are tuples built inside haskell?
15:09:01 <omnId> just the sugary names.
15:09:35 <allbery_b> same reason lists are.  (a,b) is easier for humans that (,) a b
15:09:44 <omnId> @src []
15:09:45 <allbery_b> *than
15:09:45 <lambdabot> data [] a = [] | a : [a]
15:09:54 <sw17ch> omnId: how does deriving work? (is this a bad thing to ask here?)
15:09:58 <allbery_b> like [a,b] is easier than a:b:[]
15:10:07 <paczesiowa> :t 1,2
15:10:15 <lambdabot> parse error on input `,'
15:10:16 <paczesiowa> :t (1,2)
15:10:18 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
15:10:27 <paczesiowa> that doesn't make sense?
15:10:36 <allbery_b> hm?
15:10:42 <omnId> sw17ch: ask away :).  deriving writes instances based on how your datatype is put together.  The report has more details.
15:11:06 <omnId> http://www.haskell.org/onlinereport/decls.html#sect4.3.3
15:11:07 <lambdabot> Title: The Haskell 98 Report: Declarations
15:11:22 * sw17ch needs two monitors...
15:11:24 <Cale> sw17ch: It only works for a fixed set of classes.
15:11:25 <allbery_b> numeric constants are somewhar magical, per the report a numeric constant like 1 is internallyt (fronIntegral 1)
15:11:29 <omnId> rather http://www.haskell.org/onlinereport/derived.html#derived-appendix
15:11:30 <lambdabot> Title: The Haskell 98 Report: Derived Instances
15:11:41 <paczesiowa> Pair a b = a ::: b, then we can write 1:::2, 1:::2:::3
15:11:50 <allbery_b> so you don't have to explicitly type them as Int vs. Double etc.,
15:11:59 <paczesiowa> it's the same, but parens aren't needed
15:12:08 <Cale> sw17ch: Except in GHC, there's an extension which lets you derive any class through a newtype that the original data type supported.
15:12:14 <omnId> sw17ch: for example, deriving Eq defines (==) so that only things with the same constructor, which have equal arguments, and equal.
15:12:25 <omnId> are* equal
15:12:27 <mrd> > let a ::: b = (a,b) in 1:::2
15:12:28 <lambdabot>   Not in scope: data constructor `:::'
15:12:43 <mrd> > let a $:: b = (a,b) in 1$::2
15:12:45 <lambdabot>  (1,2)
15:12:53 <mrd> (forgot : must begin type constructors)
15:13:14 <paczesiowa> > let a ::: b = (a,b) in 1:::2:::3
15:13:15 <lambdabot>   Not in scope: data constructor `:::'
15:13:23 <paczesiowa> > let a $:: b = (a,b) in 1$::2$::3
15:13:24 <lambdabot>  ((1,2),3)
15:13:44 <sw17ch> omnId: thanks for bringing up Eq, i forgot that one... and it will come in handy, along with show
15:13:51 <sphynx> Is it possible to generate patterns of lambdas in TemplateHaskell brackets expressions? I'd like to have something like [| \ $(genPattern) -> $genBody |]
15:13:54 <omnId> paczesiowa: operators that start with a colon are reserved for constructors, similar to with uppercase letters.
15:13:54 <paczesiowa> so if (,) wasn't built in, we could use tuples without parens
15:14:11 <sphynx> but it gives an "error in pattern parsing" now...
15:14:16 <paczesiowa> omnId: but I wanted that ::: to be constructor
15:14:23 <sphynx> could you please help?
15:14:24 <paczesiowa> infix constructor of a tuple
15:14:37 <omnId> paczesiowa: you can only make new constructors when defining a new datatype.
15:14:46 <omnId> data Pair a b = a :+ b
15:15:01 <paczesiowa> omnId: I know, but I don't know how to tell that to lambdabot
15:15:12 <omnId> you can't.
15:15:41 <omnId> > let data Pair a b = a :+ b in 1 :+ 2 -- omnId tests his assertion
15:15:42 <lambdabot>  Parse error at "data" (column 5)
15:15:57 <paczesiowa> anyway, is there a reason for that builtin tuples?
15:16:17 <omnId> 18:14 <!allbery_b> same reason lists are.  (a,b) is easier for humans that (,) a b
15:16:34 <sphynx> so, any ideas on my question about TemplateHaskell? :)
15:16:42 <paczesiowa> I'm not telling you to use > (:::) a b
15:16:51 <paczesiowa> I'm talking about a ::: b
15:17:04 <omnId> sphynx: you could put together the LamE's and Pats yourself :(
15:17:34 <omnId> paczesiowa: nobody's defined one.  You could.
15:17:35 <paczesiowa> what's wrong with (a:::b) opposed to (a,b) ?
15:17:40 <sphynx> omnId: Yeah, but it is not handy.. It's difficult to construct big expressions in that way..
15:17:51 <omnId> paczesiowa: put 'data Pair a b = a ::: b' in a file, load into ghci, test
15:18:04 <paczesiowa> omnId: I did that long time ago:>
15:18:18 <sw17ch> omnId: what good is a data without a constructor?
15:18:31 <sw17ch> omnId: stop being so helpful, i see everyone is bugging you =)
15:18:33 <sphynx> I wonder why pattern macro expansion does not work.. Is it just not implemented yet?
15:18:34 <sw17ch> omnId++
15:18:35 <paczesiowa> sw17ch: ::: is constructor (written infix)
15:18:46 <omnId> sw17ch: I enjoy it :D
15:19:04 <omnId> sphynx: is there a [p| ... |] form?
15:19:22 <sw17ch> i'm thinking something like: data DataType = OtherType SomeOtherType
15:19:24 <sphynx> omnId: yeah, but it tells me 'not supported yet'
15:20:00 <sw17ch> @paste
15:20:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:20:09 <paczesiowa> I just don't understand, why they did put tuples inside haskell (which is special case for syntax, and it makes definition more ugly) when it's so easy to do it in standard library
15:20:23 <omnId> sw17ch: if you had 'data A = A; data B = B; data C = A B', what type would 'A' have?
15:20:30 <monochrom> Why does Haskell use (a,b) for tuple and [a,b] for list, not [a,b] for tuple and (a,b) for list?
15:20:46 <monochrom> (I'm trolling.)
15:21:06 <hpaste>  sw17ch pasted "Figuring out `data' with an AST" at http://hpaste.org/3630
15:21:06 <omnId> paczesiowa: the haskell committee decided it was pleasant enough to wire in.
15:21:08 <Heffalump> sphynx: correct, it's not yet implemented
15:21:35 <raxas> monochrom: (a.b) were tuples and [a,b] lists in prolog many decades ago
15:21:44 <monochrom> I am not sure that (a,b,c) is easy to do in library.
15:21:50 <sphynx> So the only way to work with patterns is to construct all Pats by hand for now?
15:21:57 <Heffalump> sphynx: I believe so
15:22:04 <paczesiowa> omnId: we should question the authorities, not trust them blindly
15:22:15 <sphynx> Heffalump: bad..
15:22:38 <omnId> paczesiowa: who's trusting anything?  It's just the way it is.  Not much point in trying to change it.  Besides, I like it.
15:22:44 <paczesiowa> omnId: especially if it's so easy to understand subject, not some uber-mega type system problem
15:22:45 <KatieHuber> anyone know how easy it is to build GHC as a cross-compiler?
15:22:56 <allbery_b> painful
15:22:59 <KatieHuber> (for an already-supported platform, on an already-supported platform)
15:23:26 <allbery_b> I don't think the internal plumbing is there for that
15:23:48 <KatieHuber> I thought that's how the port to a new platform was done, come to think of it
15:24:08 <allbery_b> no, port to a new platform is telling it to generate plain-jane ANSI C
15:24:08 <paczesiowa> omnId: what is there to like? the thing that you must write parens around tuple expression? or unnecessary "pollution" of haskell syntax?
15:24:20 <omnId> sw17ch: I guess that works, but there's an awful lot of invalid values in that type like: 'LispValue (AtomRepresentation "") (StringValue "blah")
15:24:32 <KatieHuber> allbery_b: ah, of course
15:24:36 <allbery_b> which has no platform dependencies at all (and performs like molasses in January)
15:24:48 <monochrom> Gosh, why question the Haskell language when European languages are more full of holes? For example what is that singular/plural and countable/uncountable business? What's with given genders to desks? As a Chinese I actually question that, "don't trust the authority" and all...
15:25:02 <omnId> paczesiowa: I think you're getting riled up over a pointless change to uninteresting syntax.
15:25:23 <sw17ch> omnId: oh... good point
15:25:36 <paczesiowa> omnId: getting rid of tuples, and allowing infix constructors to start with a comma, and all haskell 98 code would still work
15:25:55 <allbery_b> some things are worth questioning, others just aren't.  tuples are an example; there are multiple ways to do it, all of them have warts somewhere
15:25:56 <omnId> paczesiowa: Now that's a decent idea.
15:26:04 <allbery_b> h98's are at least well defined
15:26:54 <paczesiowa> omnId: I know what it is! it's that some stupid guy found a hole in your conspiracy and you can't explain yourself:P
15:26:57 <allbery_b> people tend to worry more abotu the *real* warts, like record syntax
15:27:20 <omnId> except given: data a , b = a , b, the value (1,"blah",'x') would have type: ((Integer,String),Char), not (Integer,String,Char), which would break things.
15:27:38 <omnId> (though I think large tuples should be nested pairs anyway...)
15:27:55 <paczesiowa> omnId: I agree
15:28:03 <sw17ch> is it possible to have a new data "inherit" the fields of some other data type? similar to other OO languages?
15:28:10 <omnId> That's a huge breaking change, though.
15:28:20 <omnId> sw17ch: no subtyping
15:28:26 <sw17ch> omnId: cool, thanks =)
15:28:29 * chessguy wonders what he just tune in to
15:28:42 <chessguy> s/ne/ned/
15:28:44 <omnId> chessguy: newbies asking questions :)
15:28:59 <omnId> sw17ch: it makes type inference harder, I think
15:29:00 <sw17ch> chessguy: warning, i'm full of them tonight
15:29:10 <monochrom> I think you're looking at a discussion equivalent to "why not optimize the spelling of Haskell to Haskel"
15:29:11 <sw17ch> omnId: i don't like it any way =)
15:29:19 <allbery_b> heh
15:29:36 <paczesiowa> omnId: the only problem would be with type signatures
15:30:07 <chessguy> newbie haskell questions and conspiracy theories, interesting stuff.
15:30:13 <paczesiowa> :P
15:30:38 <chessguy> @users
15:30:39 <lambdabot> Maximum users seen in #haskell: 424, currently: 380 (89.6%), active: 14 (3.7%)
15:30:40 <allbery_b> just go back to the source ◊î◊©◊õ◊ô◊ú and be done with it :)
15:31:03 * chessguy offers allbery_b a tissue
15:31:06 <monochrom> By the time it got to "the designers chose to spell Haskell, but you should always question the authority" it become incredulous.
15:31:22 <sw17ch> omnId: data LispExpr = AtomExpr | StringExpr | BooleanExpr | ... -- is this valid if i define AtomExpr and friends as datatypes?
15:31:49 <omnId> LispExpr still needs constructos
15:31:52 <omnId> rs*
15:32:01 <monochrom> Hrm, Pythagoras and Akhilleus...
15:32:05 <chessguy> sw17ch, that's pretty much how the "Write yourself a scheme interpreter in 48 hours" tutorial does it
15:32:21 <idnar> Pythalleus
15:32:22 <scook0> data LispExpr = LAtom AtomExpr | LString StringExpr | LBool BooleanExpr
15:32:38 <chessguy> that would work too
15:32:39 <omnId> that'd do fine.
15:32:44 <monochrom> Why do you need BooleanExpr?
15:33:06 <scook0> monochrom: for #t and #f perhaps?
15:33:29 <paczesiowa> so use | LBool Bool
15:33:30 <monochrom> Be warned that #f is more than boolean.
15:33:39 <omnId> you*could* encode those as atoms...
15:33:39 <sw17ch> monochrom: hmm... because True (as a value) and "#t" (as a string) are both important to my project
15:34:31 <sw17ch> I'm hoping to have an expression have both a "representation" (the string value of the source code) and a "value" (what it evaluates too)
15:34:53 <omnId> paczesiowa: another syntax interaction is that the commas in list comprehensions would also be ambiguous.
15:35:04 <scook0> but yeah, to be honest you probably only need data LispExpr = LAtom String | LString String | LBool Bool
15:35:09 <monochrom> OK, I don't understand, out of narrow-mindedness. Please don't mind me.
15:35:11 <scook0> unless you're doing extra fancy stuff
15:35:38 <omnId> | LList [ListExpr]
15:36:01 <scook0> indeed
15:36:02 <sw17ch> scook0: does atom cover numbers?
15:36:10 <sw17ch> i guess i've been fuzzy on the definition of "atom"
15:36:18 <paczesiowa> omnId: I think that could be fixed somehow
15:36:23 <scook0> I guess it depends if you want it to or not :)
15:36:40 <sw17ch> monochrom: to be honest, i can't explain what I'm trying to do very well yet
15:36:40 <paczesiowa> omnId: and you don't use list comprehensions that often
15:36:41 <scook0> you could have separate constructors for atoms and for numbers
15:37:02 <desegnis> Nice: With recent versions of ghc and gtk2hs, a small Gtk demo compiles faster (1.3 s instead of 1.6 s), and the generated executable is smaller by a factor of 4.
15:37:02 <scook0> or you could wrap them up in a new AtomExpr or Maybe String Integer type
15:37:13 <scook0> (ugh, Either String Integer)
15:37:23 <sw17ch> scook0: I'd like to think that my atoms and my numbers are different. helloWorld vs. #36rSW17CH
15:37:31 <omnId> If , were an identifier character, I wonder what other parts of the syntax would be affected.
15:37:51 <scook0> sw17ch: are you trying to maintain the actual typed-in syntax of your numbers?
15:38:08 <sw17ch> yes... i need to be able to reproduce the exact syntax of the source file :)
15:38:31 <sw17ch> scook0: this is a bit convoluted :\
15:38:34 <scook0> ah, then Integer won't be a suitable representation
15:39:05 <sw17ch> scook0: yeah... which is why i'm trying to have the Representation and Value fields for each expression
15:39:20 <Cale> desegnis: recent as in 6.8.1?
15:39:35 <scook0> I guess the next question is, do your internals actually need to be able to distinguish between the different kinds of atom?
15:39:57 <sw17ch> scook0: not until much later... and it could probably work with a string comparison
15:39:59 <paczesiowa> is there support for shared libraries in new ghc?
15:40:09 <sw17ch> scook0: much much MUCH later, yes, i'll need to distinquish
15:40:18 <scook0> i.e. if they didn't, you could just represent atoms with a string
15:40:42 <scook0> like "symbol", "#36rSW17CH", "\"string\""
15:40:43 <omnId> paczesiowa: quickly searching the release notes for '.so' didn't turn up anything
15:41:03 <paczesiowa> :-(
15:41:17 <Heffalump> oh, I thought someone had written that
15:41:52 <sw17ch> scook0: yeah, i am representing atoms as strings, but i do want to differentiate between constant/numeric values
15:42:05 <sw17ch> scook0++
15:42:11 <sw17ch> thanks guys, gotta run for a while
15:42:16 <sw17ch> omnId++
15:43:38 <trippo_> uhm, problems with haskell.org?
15:43:44 <paczesiowa> yeah
15:44:04 <Cale> It's slow, probably due to all the load from people finding out about the new GHC
15:44:08 <paczesiowa> too many ghc lovers
15:45:39 <scook0> so is 6.8.1 the first blessed 6.8 release?
15:45:51 <olsner> where's 6.8 or 6.8.0?
15:45:54 <allbery_b> isn't the problem with non-specialcasing commas that it also breaks list syntactical sugfar, which is impossible to fix in a library?
15:45:54 <allbery_b> (yes I'm a bit slow)
15:46:01 <Heffalump> they don't exist
15:46:12 <Heffalump> 6.8.0.<date> was used for the release-candidates
15:46:35 <olsner> oic
15:47:07 <allbery_b> too many vendor package systems break weirdly otherwise
15:47:16 <allbery_b> they end up using epochjs to compensate
15:47:41 <Trinithis> @seen pjd
15:47:41 <lambdabot> pjd is in #haskell. I last heard pjd speak 1m 59s ago.
15:47:55 <Trinithis> @seen Cale
15:47:56 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3m 52s ago.
15:47:58 <Cale> hello
15:48:00 <Trinithis> hi
15:48:07 * pjd waves
15:48:11 <Trinithis> Okay, I think I understand it
15:48:12 <Trinithis> sec
15:48:23 <Trinithis> A Functor is a class of types that all implement the polymorphic function
15:48:23 <Trinithis> fmap :: (Functor ftor) =>  (a -> b) ftor a -> ftor b
15:48:23 <Trinithis> Such that "fmap fun ftor" applies fun to all of ftor's (relevant) value(s), which results in a new ftor' such that ftor' contains all those new value(s).
15:48:23 <Trinithis> A Monad is a Functor that also has definitions for the operator (>>=) and the polymorphic function return:
15:48:23 <Trinithis> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
15:48:25 <Trinithis> return :: (Monad m) => a -> m a
15:48:27 <Trinithis> And the reason why monads are used over some other data type is that they provide a clean abstraction for the interfacial use of an entity (ignoring application)?
15:48:59 <Heffalump> "interfacial"?
15:49:09 <Trinithis> interface adj
15:49:11 <monochrom> I won't argue.
15:49:27 <pjd> @dict intefacial
15:49:27 <lambdabot> Supported dictionary-lookup commands:
15:49:28 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
15:49:28 <lambdabot> Use "dict-help [cmd...]" for more.
15:49:32 <lament> "interfacial" sounds like something every spam filter ought to block
15:49:33 <pjd> @dict wn intefacial
15:49:33 <lambdabot> Supported dictionary-lookup commands:
15:49:33 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
15:49:33 <lambdabot> Use "dict-help [cmd...]" for more.
15:49:36 <pjd> @wn intefacial
15:49:38 <lambdabot> No match for "intefacial".
15:49:45 <allbery_b> monads let you express a great many constructs as HOF libraries that would otherwise need macros or special cases
15:49:47 <pjd> @wn interfacial
15:49:48 <lambdabot> *** "interfacial" wn "WordNet (r) 2.0"
15:49:48 <lambdabot> interfacial
15:49:48 <lambdabot>      adj : relating to or situated at an interface; "an interfacial
15:49:48 <lambdabot>            layer"; "interfacial tension is the surface tension at
15:49:48 <lambdabot>            the interface between two liquids"
15:49:56 <Trinithis> of, pertaining to, or of the nature of an interface.
15:50:12 <Trinithis> dictionary.com
15:50:13 <monochrom> Please, not another essay-writing exercise for monads. :)
15:50:19 <Cale> Trinithis: Monads occur naturally all over the place, we just recognise them as such so that we get a library of code which operates across all of them
15:50:48 <Trinithis> Is my understanding correct?
15:50:49 <pjd> Trinithis: and right, it's the same reason for most type classes
15:50:53 <lament> monads are like cockroaches
15:51:27 <Cale> Trinithis: mostly, I think :)
15:51:40 <monochrom> I believe it is easier to describe Zen Buddhism in words than to describe monads in words.
15:51:42 <ddarius> There are monads under your refridgerator right now.
15:51:46 <pjd> by separating the monad type class, you gain the ability to write tons of useful functions that work with any monad
15:51:56 <Cale> Trinithis: there were some bits in there which seemed worded a *little* strangely, but I think you have the right idea :)
15:52:14 <Trinithis> The thing I dont understand is the mathematical definition of Functors. In math they seem like transforms... aka like the derivative
15:52:24 <|Jedai|> The fmap from Functor must have some properties to be a real Functorial fmap : fmap id == id && fmap (f . g) == fmap f . fmap g
15:52:39 <pjd> e.g. all the stuff in Control.Monad: sequence, mapM, filterM...
15:52:57 <pgavin> hmm... is haskell.org down?
15:53:10 <monochrom> Functors are some kind of transforms. Not the only kind, of course.
15:53:12 <allbery_b> someone should put thta in /topic
15:53:21 <allbery_b> it's slashdotted by the ghc6.8.1 release
15:53:23 <pjd> Trinithis: in Haskell they are too
15:53:28 <monochrom> Yes haskell.org is very slow to me too.
15:53:32 <Trinithis> But in Haskell, they seem like a data structure
15:53:37 <ddarius> monochrom: A monad is an endofunctor T with two natural transformations, Œ∑ and ¬µ, that satisfie, Œ∑;¬µ = id = TŒ∑;¬µ and T¬µ;¬µ = ¬µ;¬µ
15:54:00 <pjd> Trinithis: the actual "functor" is a combination of the data structure and its fmap
15:54:05 <pgavin> allbery_b: not literally slashdotted though
15:54:09 <monochrom> Thank you ddarius. Please relay it to someone who needs it most.
15:54:10 <Trinithis> ahh
15:54:23 <omnId> Trinithis: well, they are transformers, in a way.  The list functor transforms the Int type into the list of Ints type.
15:54:32 <ddarius> monochrom: Now describe Zen Buddhism in words.
15:54:35 <allbery_b> no, but de facto that's the standard term for a web flash crowd
15:54:42 <monochrom> Oh, haha.
15:55:44 <lament> zen is a school of buddhism that emphasizes meditation over other practices?
15:55:51 <pjd> omnId: and also the Int -> Foo function to the [Int] -> [Foo] function
15:56:14 <omnId> pjd: oh right, Functor of course includes fmap.
15:56:25 <Cale> Trinithis: well, there is a sense in which you can turn the derivative into a functor. If M is a differentiable manifold, we can form the tangent bundle on M, called TM, consisting essentially of the disjoint union of the tangent spaces at each point of M. We can lift maps f: M -> N between differentiable manifolds, to maps between their tangent bundles Tf: TM -> TN such that the Tf encodes the information about the d
15:56:25 <Cale> erivative of f on the tangent spaces.
15:56:47 <monochrom> Zen Buddhism is stop questioning and start accepting the status quo.
15:57:04 <omnId> monochrom: Mu.
15:57:13 <Trinithis> The way I sorta view functors was as:A function that takes as its domain another function f, resulting in a new function, g, where g's domain is related to f's domain and g's range is related to f's range
15:57:33 <Trinithis> in the math sense
15:57:34 <omnId> "completely reject any status quo" is my understanding.
15:57:40 <Cale> s/range/codomain/ but yeah
15:57:49 <Cale> I suppose the range is also related
15:58:01 <Trinithis> range is a subset of the codomain
15:58:05 <Cale> right
15:58:39 <Trinithis> Cale: is my understanding of the math functor ...ok?
15:58:50 <Cale> It's all right...
15:59:15 <Cale> Categories don't always consist of sets and functions, but it's a good intuition in most cases.
15:59:22 <Trinithis> mmm
15:59:35 <desegnis> Cale: Sorry for the delay. Yes, 6.8.1. The comparison might be flawed though; I'm comparing to ghc 6.6 and some no-name darcs version of gtk2hs flowing around on my box.
15:59:38 <pjd> Trinithis: regarding monads, a more straightforward way to understand them might be via join instead of >>=
15:59:48 <Cale> Basically, functors are structure-preserving maps between categories.
16:00:19 <Trinithis> pjd: Haven't come across join yet. But if anything, I should understand how to use >>= over do notation?
16:00:25 <Cale> In the way that linear maps are structure-preserving maps between vector spaces, and group homomorphisms are structure preserving maps between groups.
16:00:31 <omnId> m >>= k = join (fmap k m)
16:00:39 <scook0> because the core properties of categories--composition and identity--are preserved by functors
16:00:49 <omnId> join :: Monad m => m (m a) -> m a
16:00:52 <Cale> Trinithis: I would recommend understanding >>= and then connecting it up with do-notation afterward.
16:01:19 <Cale> Trinithis: do-notation is a very handy shorthand, but it can be misleading if you're not comfortable with the underlying stuff
16:01:31 <ddarius> Actually, (>>=) implies more structure than join and return.
16:01:47 <pjd> Trinithis: yeah, don't worry too much about do notation
16:01:50 <Cale> Well, you need fmap as well. :)
16:01:58 <omnId> join is the category-theoretical mu (or eta? I sometimes confuse them.)
16:02:00 <lament> >>= makes a lot more sense than join in terms of "what the hell it's for"
16:02:05 <Cale> omnId: mu
16:02:06 <Trinithis> Cale: I figured. But once I feel rather comfortable with them, is it typical to use do notation.
16:02:11 <pjd> you'll know you understand monads when do notation suddenly becomes very obvious and simple :)
16:02:11 <Trinithis> lol
16:02:11 <scook0> ddarius: (>>=) =~= (join, fmap), right?
16:02:15 <Cale> Trinithis: yes
16:02:27 <pjd> Trinithis: it's a matter of style, actually
16:02:31 <monochrom> Second attempt. Zen Buddhism is the about fixed point equation world = world_state_transformer world.
16:02:36 <pjd> you can often write much more succinct functions without do notation
16:02:39 <Cale> Trinithis: in fact, we often mix the two. The flipped over version of >>=, which is =<< is convenient for that
16:02:46 <omnId> scook0: =~= is "equivalent up to isomorphism", correct? :)
16:02:53 <ddarius> scook0: Yes, though there also the issue that all Haskell monads are strong.
16:02:59 <pjd> but occasionally, it can't be beat
16:03:02 <Cale> do x <- foo =<< bar; ...
16:03:07 <scook0> omnId: I was just going for "hand-wavey equivalent"
16:03:07 <Trinithis> What is =<< called? rev-bind?
16:03:24 <omnId> flip bind would be a good name
16:03:30 <omnId> (=<<) = flip (>>=)
16:03:31 <allbery_b> dnib? :)
16:03:31 <pjd> Trinithis: i mentally pronounce both as "into"
16:03:33 <scook0> omnId: I'm not enough of a hardened categorist to make firm statements :)
16:03:45 <omnId> scook0: me neither :)
16:03:59 <idnar> x <- foo -< bar
16:04:06 <Cale> I don't know how much category theorists really use bind.
16:04:11 <scook0> omnId: actually, my intent was more "interdefinable"
16:04:31 <Cale> They tend to use the equivalents of our fmap, return, and join
16:04:52 <Cale> x >>= f = join (fmap f x)
16:05:35 <pjd> join `dot` fmap
16:05:35 <Heffalump> who introduced bind, Wadler?
16:05:36 <ddarius> Cale: They don't really at all.  They use Kleisli compositions sometimes, which is close.  Some computer scientists that use category theory use f^* for (>>= f).  Maybe some algebraic topologists do something similar too.
16:06:02 <Trinithis> `dot` == (.) ?
16:06:04 <Cale> Yeah, actually it might have been Wadler.
16:06:17 <omnId> (f `dot` g) x y = f (g x y)
16:06:28 <scook0> :t (.).(.)
16:06:29 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:06:31 <omnId> dot = (.).(.)
16:06:33 <Cale> Is dot in the libraries, or just in lambdabot?
16:06:37 <ddarius> Cale: Moggi's monadic meta language using let would be exactly the same as using bind/do-notation.
16:07:00 <scook0> I tend to call it `o2`
16:07:13 <scook0> as in unaryFunc `o2` binaryFunc
16:07:19 <omnId> (.:) is another common name
16:07:34 <monochrom> Unfortunately .. is already take.
16:07:55 <ddarius> @check \x y -> x..y == take x y
16:07:55 <lambdabot>  Parse error at "..y" (column 10)
16:08:06 <omnId> @slap ddarius
16:08:07 * lambdabot slaps ddarius
16:08:07 <scook0> though the "three nipples" definition makes me giggle :)
16:09:04 <scook0> and it's extensible to extra parameters on the rhs, by adding more .(.)
16:09:11 <Trinithis> well gtg. thanks again
16:09:19 <Cale> Trinithis: no problem :)
16:09:23 * ddarius says it's extensible by adding more (.).
16:09:41 * scook0 agrees with ddarius up to isomorphism
16:10:22 <ddarius> :t let triple f = f . f . f in triple (.)
16:10:24 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
16:10:24 <lambdabot>     Probable cause: `.' is applied to too few arguments
16:10:24 <lambdabot>     In the first argument of `triple', namely `(.)'
16:10:37 <ddarius> Stupid type system.
16:10:46 <battlestar_57203> lol
16:11:23 <omnId> @type let triple f = f . f . f in triple
16:11:24 <lambdabot> forall c. (c -> c) -> c -> c
16:11:28 <omg911> :t 4
16:11:29 <lambdabot> forall t. (Num t) => t
16:11:30 <pjd> Cale: dot is a #haskell invention, i think
16:11:41 <omg911> cool
16:11:52 * pjd wishes (..) was syntactical
16:11:56 <ddarius> omnId: All the fs have to have the same type which all the (.)s in (.) . (.) . (.) don't.
16:12:15 <pjd> then you'd have (.), (..) = (.).(.), (...) = (.).(.).(.), and on
16:12:20 <omnId> so you want rank-2 polymorphism?
16:13:21 <ddarius> omnId: No.
16:13:53 <trippo_> how do I define >>= in terms of join and return?
16:14:02 <ddarius> trippo_: You don't.
16:14:16 <trippo_> uhm, what am I missing?
16:14:19 <monochrom> fmap
16:14:21 <ddarius> fmap
16:14:27 <pjd> trippo_: s/return/fmap/
16:14:34 <trippo_> oh yes, I meant fmap, not return :-)
16:14:34 <ddarius> (i.e. the fact that all (categorical) monads are functors)
16:14:43 <scook0> or liftM, depending on what you want to call it
16:14:46 <pjd> >>= is fmap, followed by a join
16:14:46 <mauke> (join .) . fmap
16:14:47 <ddarius> trippo_: Then that definition has been given several times.
16:14:52 <monochrom> <Cale> x >>= f = join (fmap f x)
16:14:58 <ddarius> trippo_: Or just follow the types.
16:15:05 <scook0> trippo_: you should be able to figure it out from the types
16:15:14 <trippo_> thanks
16:16:05 <omnId> fmap (f :: a -> m b) (x :: m a) :: m (m b), where m is scopes over all and is in Monad, so then you just join the result.
16:16:46 <pjd> @remember foonly [Re. GHC 6.8.1 announcement] They actually had the source a year ago, but it finally finished compiling! ;-)
16:16:46 <lambdabot> I will remember.
16:17:46 <idnar> hahaha
16:18:41 <kolmodin> about time.. http://picasaweb.google.com/kolmodin/Freiburg2007 :)
16:18:42 <lambdabot> Title: Picasa Web Albums - Lennart Kolmodin - Freiburg 2007
16:21:04 <omnId> @. read @ @run unwords . sort . words $ @show @yow
16:21:06 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
16:21:27 <omnId> @. id @ @run unwords . sort . words $ @show @yow
16:21:28 <lambdabot>   "Awright, ENVY? PENIS hid my of one which you"
16:24:14 <trippo_> can I make a functor from a Tree, where Tree is a binary search Tree (i.e. (Tree t) with t is ordered)?
16:24:34 <trippo_> I meant, where t is ordered?
16:25:24 <trippo_> I guess not, given the signature of fmap
16:26:12 <pjd> you probably can
16:26:26 <Heffalump> no
16:26:37 <Heffalump> it's the same as the restricted monad problem
16:26:51 <scook0> if you have a class constraint on your datatype, that causes problems
16:26:52 <Heffalump> but, do you really need the Ord condition for the fmap implementation?
16:27:06 <Heffalump> class constraints on datatypes are pretty much useless anyway
16:27:18 <trippo_> well, what I was trying to do
16:27:19 <omnId> Heffalump: to make a new sorted Tree, I believe so.
16:27:29 <Heffalump> oh, right, yeah
16:27:30 <trippo_> is making a monad of binary trees
16:27:45 <Cale> Hey, GHC 6.8 is out now, so class constraints on datatypes work properly when you use the GADT syntax.
16:28:01 <Heffalump> that's not enough for restricted monads, though
16:28:06 <Cale> right
16:28:14 <trippo_> I don't need them ordered, but merging unordered trees produces totally unbalanced trees
16:28:26 <trippo_> so I put an ordering on the elements, that's all
16:28:30 <Heffalump> a proper fmap implementation is data agnostic
16:29:02 <trippo_> ok, but the problem is join
16:29:16 <trippo_> i tried to make it a bit efficient
16:29:31 <kolmodin> anyone else have trouble reaching haskell.org?
16:29:42 <Heffalump> kolmodin: yes, lots of people have reported it
16:30:26 <allbery_b> futz
16:30:33 * allbery_b just tried adding that to the topic
16:30:34 <kolmodin> Heffalump: ok, thanks
16:30:49 <kolmodin> Heffalump: btw, I just uploaded my pics from Freiburg :)
16:31:00 <Heffalump> yeah, I saw :-)
16:31:28 <kolmodin> neither you or me are on them though..
16:31:42 <Heffalump> heh
16:31:47 <Cale> wli: Your +o is showing
16:33:20 * omnId is still going through the release notes
16:33:26 <omnId> Yay!  Kleisli composition!
16:34:17 <mdmkolbe> Is haskell.org down?
16:34:31 <omnId> slow, yes
16:34:37 <allbery_b> overloaded due to ghc release
16:34:42 <allbery_b> (we think)
16:34:49 <mdmkolbe> ah
16:34:57 <allbery_b> someone put that in the topic, please
16:35:01 <TSC> Is there a Debian package in unstable yet?
16:35:09 <pejo> Does haskell.org need mirrors?
16:35:10 <allbery_b> (wli, I think you nominatred yourself since you're the one with ops)
16:35:47 <mdmkolbe> Ok, since I can't pull my documention from haskell.org does anyone remember what function grabs the equivalent of argv[0] and what package it is in?
16:36:04 <mrd> @hoogle getProgName
16:36:05 <lambdabot> System.getProgName :: IO String
16:36:07 <mauke> getArgs
16:36:08 <trippo_> System.getArgs !! 0
16:36:10 <mauke> er, that
16:36:13 <trippo_> ops, sorry
16:36:22 <mrd> System.Environment actually
16:36:39 <Heffalump> since when were we +t?
16:37:04 <mdmkolbe> ... and the gold star goes to mrd, thx
16:37:14 <roconnor> where is the 6.8.1 torrent?
16:37:15 <mdmkolbe> mrd++
16:37:17 <rawicki> TSC: no, not yet
16:37:22 <allbery_b> no idea, but we are
16:37:26 <mrd> is it a main sequence star
16:37:50 <omnId> Heffalump: is that an IRC channel mode?  What does it mean?
16:38:34 <mauke> +t means only ops can change the topic
16:45:11 <dmwit> Awesome:
16:45:13 <dmwit> * tessier_ (n=treed@kernel-panic/sex-machines) has joined #haskell
16:45:38 <dmwit> It could only get geekier if it was s/treed/threed/.
16:48:46 <sorear> dmwit: She's had the same hostmask for a loong time.
16:49:41 <darinm> anyone else having problems accessing haskell.org?
16:49:49 <dmwit> darinm: Yes.
16:49:56 <dmwit> It's been slow today.
16:50:02 <darinm> ah, ok
16:50:32 <lucca> is the origin of the problem known?
16:50:56 <darinm> is there a mirror of the 6.8.1 sources anywhere?
16:51:08 <dmwit> lucca: The best guess is that it's the result of 6.8's release.
16:51:31 <lucca> urk, that could do it
16:52:10 <omnId> @where+ slow? Yes, haskell.org seems slow.  We think it's because of the new release.
16:52:10 <lambdabot> It is stored.
16:52:31 <dmwit> Surely you'd want ?fact+ instead.
16:53:02 <omnId> oh?  They use different dbs?
16:53:15 <dmwit> Well... I don't actually know.
16:53:17 <dmwit> ?fact wolf
16:53:17 <lambdabot> I know nothing about wolf
16:53:22 <dmwit> Yep, different.
16:53:37 <omnId> @where+ slow?
16:53:37 <lambdabot> Done.
16:53:41 <omnId> @fact+ slow? Yes, haskell.org seems slow.  We think it's because of the new release.
16:53:41 <lambdabot> I know nothing about slow?
16:53:48 <dmwit> ?list
16:53:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:54:09 <dmwit> ?fact-set slow? Yes, haskell.org seems slow.  We think it's because of the new release.
16:54:09 <lambdabot> Fact recorded.
16:54:38 <omnId> cool.
16:54:39 <twanvl> We need a @why command
16:55:05 <allbery_b> or an @alias so we can make @why on the fly
16:56:41 <tessier__> dmwit: Yeah, I dig my hostmask. :)
16:58:48 <sorear> `It would be be better just to put it in the topic.
16:59:05 <keseldude> Is there an easy way to play mp3 (or any music) files with haskell on windows? hmp3 is only for *nix
16:59:29 <sorear> keseldude: Why do you want to do it with Haskell?
17:01:10 <keseldude> well... the only other languages I know/am learning are Java and C
17:01:46 <keseldude> having a music player in java doesn't seem like such a good idea because of speed
17:01:57 <mauke> why can't you use an existing player?
17:02:00 <dmwit> I guess the question is, "Why are you writing a music player?"
17:02:31 <keseldude> for fun and to make it exactly how I want it to be
17:02:43 <mauke> writing an mp3 player doesn't sound like fun
17:02:59 <keseldude> it could play flac too
17:03:16 <dmwit> keseldude: Dunno, maybe use OpenAL?
17:05:42 <keseldude> that's for positioning audio sources in a 3d
17:05:49 <keseldude> not really an mp3 decoder
17:06:28 <darinm> you're trying to write an mp3 player with haskell?
17:06:29 <dmwit> Okay, so liblame or libffmpeg or so + FFI?
17:06:38 * dmwit wonders how hmp3 did it.
17:06:45 <stepcut> hmp3 just calls mpg123
17:06:50 <dmwit> heh
17:07:13 <keseldude> that's not exactly cross platform
17:07:15 <stepcut> In windows, there is a whole framework for chaining together decodes/encoders/filters/etc
17:07:33 <stepcut> keseldude: is cross-platform a goal for your project ?
17:07:38 <darinm> keseldude: it's cross platform if the underlying libs are cross platform
17:09:09 <keseldude> cross-platform is a goal
17:09:43 <raxas> mpd, a music player daemon is a way to go. just write another client in haskell for it
17:10:11 <stepcut> keseldude: you could probably use ffmpeg for the audio decoding (mp3, flac, etc), and sdl+opengl or gtk for the platform independent GUI and sound card access
17:10:13 <dmwit> raxas: He's on Windows, apparently.
17:10:40 <jcreigh> on windows you should just use foobar2000 and be done with it. :)
17:10:44 <stepcut> though, I am not sure if gtk provides an cross-platform sound APIs
17:11:09 <stepcut> and windows, you should just run linux in a virtual machine, and use mpd ;)
17:11:41 <keseldude> I guess I'll have to my write my own if I want to do it =\
17:11:44 <keseldude> heh
17:12:00 <stepcut> perhaps you could revive a port of Haskell to .NET and use the .NET libraries ?
17:13:36 <keseldude> yeah... now would be a good time to mention that I started haskell 2 days ago and I don't know very much about it yet. I was just wondering whether it was not extremely difficult for when I learn haskell better.
17:13:49 <keseldude> and it sounds like it is
17:14:08 <dmwit> Equally difficult to any language I guess.
17:14:22 <dmwit> They'd all interface to libffmpeg or liblame or some other decoder lib.
17:14:38 <keseldude> I could probably make one in Java
17:15:23 <keseldude> and then compile it with gcj....
17:15:48 <LoganCapaldo> I'm trying to build 6.8.1 and it's having issues with building the readline stuff. Specifically it complains about a bunch of (what I think are constants) not being defined, UNDO_DELETE, UNDO_INSERT, etc, all around line 723 or so in Readline.hsc
17:16:17 <trippo_> keseldude: gcj can be much slower than Sun's javac
17:16:34 <trippo_> I mean, the compiled code
17:16:48 <dmwit> LoganCapaldo: Have you got the -dev files for the right version of readline?
17:17:00 <stepcut> keseldude: most of the difficulty is getting a working set of cross-platform APIs for sound, decoding, and GUI stuff. If there was a usuable port of Haskell to .NET or JVM, then that would be one solution -- but I don't think there is anything production worthy in that direction yet
17:17:37 <stepcut> (or AVM, the flash virtual machine)
17:17:51 <scook0> I think part of that problem is the fact that Haskell is a poor fit for most existing VMs
17:18:06 <LoganCapaldo> dmwit: maybe. I wouldn't mind just skipping the readlne stuff for now if possible
17:26:33 <dmwit> Slow stuff.
17:26:41 <dmwit> Everybody should look at
17:26:42 <dmwit> http://wiki.slembcke.net/main/published/Chipmunk
17:26:43 <lambdabot> Title: Chipmunk in Main
17:28:32 <LoganCapaldo> said constants all appear to be in my readline header
17:32:23 <allbery_b> platform?
17:32:33 <LoganCapaldo> ppc os x
17:32:46 <LoganCapaldo> unless that wasn't directed at me
17:32:59 <allbery_b> others have hit that, it's finding the system readline before the third party (real) one
17:33:09 <LoganCapaldo> yeah
17:33:15 <LoganCapaldo> I assumed as much
17:33:17 <allbery_b> not sure about fixes though
17:33:26 <LoganCapaldo> I'm trying to figure out how to munge the include path
17:33:32 <allbery_b> I don't see it with my darcs builds on ppc tiger
17:34:42 <shapr> It's a beautiful day out there.
17:34:46 <shapr> salut anna30
17:34:50 <idnar> so what sort of data type should I use to represent a tic-tac-toe game board?
17:35:13 <dmwit> data Entry = X | O | Empty
17:35:14 <daniel_larsson> If you can call snow and slush a beautiful day
17:35:25 <shapr> idnar: You could start out with a list of Entry
17:35:36 <conal> dmwit: chipmunk looks nifty!
17:35:56 <idnar> shapr: well, that was what initially came to mind, but modifying the list seems inconvenient
17:36:27 <conal> i wonder what a genuinely functional (not IO) interface to chipmunk might look like
17:36:27 <shapr> You could make a statically sized ADT.
17:36:31 <idnar> have to split the list at the entry I want to modify, then put it back together
17:36:40 <dmwit> conal: I was wondering the same thing... =)
17:36:47 <shapr> dmwit: What's cool about Chipmunk?
17:36:49 <dmwit> I put it on my list of projects to do SomeDay.
17:37:01 <dmwit> shapr: It's really, really fast 2D physics.
17:37:01 <idnar> ADT?
17:37:15 <shapr> idnar: Algebraic DataType
17:37:23 <dmwit> shapr: Which could save me some trouble if I ever get around to trying to make an actual platformer game.
17:37:25 <sjanssen> idnar: I'd probably use Map (Int, Int) Entry
17:37:37 <sjanssen> Map is overkill, but it has more useful operations than []
17:38:13 <allbery_b> ahm they're spreading
17:38:24 <shapr> Whoa, 6.8 is OUT!
17:38:26 <allbery_b> ("anna30")
17:38:37 <omnId> idnar: if you just want to use lists: onElt i f xs = take i xs ++ [f (xs!!i)] ++ drop (i+1) xs
17:38:43 <idnar> shapr: would that be something like data Board = mkBoard Entry Entry Entry Entry Entry Entry Entry Entry Entry ?
17:38:45 <allbery_b> been bouncing around on cognet for a couple weeks
17:38:45 <chessguy_> they really ought to send out an email
17:38:47 <shapr> Is there a debian package of 6.8?
17:39:09 <sjanssen> chessguy_: they have
17:39:11 <omnId> onElt 2 (onElt 0 (const X)) puts an X at element 0 of row 2
17:39:31 <idnar> omnId: yeah, it's not that hard, just seems icky
17:39:33 <chessguy_> sjanssen, i mean to haskell@ and/or haskell-cafe@
17:39:55 <idnar> I was thinking about some kind of data structure that would reflect the victory condition in some way
17:39:56 <sjanssen> chessguy_: "[Haskell] ANNOUNCE: GHC version 6.8.1" is in my inbox :)
17:40:04 <chessguy_> hmm
17:40:07 <idnar> but I'm not sure if that makes any sense, and I couldn't come up with anything sensible either
17:40:20 <omnId> idnar: I agree, but it doesn't really matter much for such a small case.
17:40:38 <chessguy_> it slipped by me
17:40:43 <sjanssen> omnId: I think [[Entry]] is less clean than Map (Int, Int) Entry
17:40:49 <omnId> yeah
17:41:01 <conal> omnId: hurray for composable editors
17:41:13 <sjanssen> and you can even remove the 'Empty' case from Entry, and treat absence from the map as an unmarked box
17:41:35 <KatieHuber> is haskell.org down for other people?
17:41:37 <scook0> an array would be another choice
17:41:44 <ddarius> @fact slow?
17:41:44 <lambdabot> slow?: Yes, haskell.org seems slow. We think it's because of the new release.
17:42:29 <idnar> anyhow, once I've done that, then I guess I'd want to use the List monad to do a look-ahead search to determine the best move
17:42:31 <KatieHuber> well, since I can't get to the documentation, and the GHC folks seem to think a man page is beneath them, anyone know how I get GHC to stop after producing a .hc file?
17:42:47 <idnar> except that doesn't quite seem right
17:43:38 <KatieHuber> ooh, the page loaded :|
17:43:55 <KatieHuber> at this rate, it'll be night time before I get to the right page in the docs :p
17:44:02 <TSC> KatieHuber: -C ?
17:44:29 <stepcut> KatieHuber: GHC often ships with the same documentation that is on the site
17:44:52 <KatieHuber> -C works, thanks
17:45:02 <TSC> The Debian package has a man page (:
17:46:23 * ddarius has too many hefty and dense papers to read.
17:47:44 <LoganCapaldo> mmm
17:48:08 <LoganCapaldo> I have learned the secret ways of configure the ghc build system to obey my commands with regards to the location of readline :)
17:48:25 <Saizan_> are libraries in the binary snapshot of 6.8.1 builded with O2?
17:53:15 <dpiponi> Looks like haskell.org has been "reddited"
17:54:01 <Saizan_> yeah
17:54:06 <chessguy_> wow, haskell.org is ridiculously slow
17:54:21 <chessguy_> "ghc is out...if you can get it" :)
17:54:33 <Korollary> bittorrent
17:54:45 <Saizan_> is there a torrent?
17:54:50 <ac> Are there any changes from 6.8.0 to 6.8.1?
17:55:01 <ac> Well, clearly there are, but are they significant?
17:55:27 <dpiponi> dons lists these: http://programming.reddit.com/info/5zrcs/comments/
17:55:29 <lambdabot> Title: programming: ANNOUNCE: GHC version 6.8.1
17:55:55 <ac> what IS program coverage?
17:56:13 <dmwit> It tells what parts of the code get executed.
17:56:14 <mauke> tells you which parts of your program were executed
17:56:15 <dpiponi> I've never used it myself, but it's a way to find out what parts of your code have been run
17:56:22 <mauke> haha
17:56:30 <chessguy> "They actually had the source a year ago, but it finally finished compiling!" lol
17:56:41 <dmwit> chessguy: Yeah, that was my favorite comment, too. =)
17:56:43 <ac> and does "gcc" stand for Glaskow Core Compiler, or GNU C Compiler?
17:56:51 <Korollary> gnu GCC
17:57:26 <dpiponi> I guess with pointer tagging the next release will take one year/1.15 time to compile.
17:57:40 <omnId> @quote finished.compiling
17:57:41 <lambdabot> foonly says: [Re. GHC 6.8.1 announcement] They actually had the source a year ago, but it finally finished compiling! ;-)
17:58:21 <omnId> > recip 1.15
17:58:22 <lambdabot>  0.8695652173913044
17:58:32 <omnId> @go 0.869 years in days
17:58:33 <lambdabot> 0.869 years = 317.395471 days
17:58:37 <Korollary> is there a torrent tracker for open source stuff?
17:58:39 <mauke> > 365 / 1.15
17:58:41 <lambdabot>  317.3913043478261
17:59:54 <dmwit> > 365 * 0.85 -- don't you mean this?
17:59:56 <lambdabot>  310.25
18:00:03 <Saizan_> i've just compiled a program with 6.8.1 and it's 33% slower then with 6.6.1.. the problem is probably with the libs not built with optimizations
18:00:07 <dmwit> oh
18:00:09 <dmwit> nm
18:00:33 <Saizan_> *than
18:01:29 <sjanssen> it might also be the difference between -fvia-c and -fasm
18:01:46 <sjanssen> though 30% is a bit large for that
18:02:21 <ddarius> ac: There's a video on it.
18:03:53 <ac> ddarius: video on what?
18:04:43 <ddarius> HPC
18:04:58 <ddarius> Haskell Program Coverage
18:05:23 <chessguy> ddarius, that sounds interesting. got a link?
18:05:29 <ddarius> http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
18:05:31 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
18:06:00 <chessguy> gracias
18:06:23 <ac> conal: did you get OpenGL working?
18:13:16 <conal> ac: yes.  in C with GLUT and in Haskell without.  i'll probably use wxHaskell anyway, so GLUT is no biggie.
18:14:04 <ac> conal: cool. so wxHaskell has OpenGL support?
18:14:10 <dons> Saizan_: make sure you compile the libs and everything with -O2 :)
18:14:22 <conal> ac: yep. it comes with two simple OpenGL demos
18:16:08 <Saizan_> dons: yup, when haskell.org works again :)
18:16:20 <ac> conal: I ran in to two problems writing that 2D code. First, you can only make textures whose dimensions are powers of two (but you probably already knew that). And secondly you have to be careful what state OpenGL is in, for example if you forget to "matrixMode $= Modelview 0", your coordinate system will be screwed
18:17:00 <conal> ac: thanks for the warnings.  OpenGL seems to be a minefield
18:17:06 <ac> heh :)
18:17:14 <ac> it's really fast though, and looks nice
18:17:22 <ac> I want to play with the convolution filters
18:17:26 <conal> yep
18:17:32 <conal> what convolution filters?
18:17:56 <ac> conal: it's in the OpenGL spec now. You can create convolution filters either on the entire buffer, or pieces of it too, I think
18:18:14 <ac> so you can do realtime embossintg, and stuff like that
18:18:15 <conal> ac: nifty.
18:18:25 <ac> or depth of field blurs
18:18:38 <conal> nice
18:18:57 <conal> ac: are textures stored in video memory?
18:19:04 <ac> conal: as long as they'll fit
18:19:10 <conal> and if not?
18:19:20 <ac> conal: I'm not sure if you'll get an error, or it if it will just be slow
18:19:36 <ac> conal: typically video cards have at least 256mb of ram these days. That's quite a bit
18:19:51 <conal> ac: btw, i saw somewhere that non-power-of-two textures are available via extension.
18:20:10 <ac> conal: yeah. I have not experimented with extensions yet
18:20:24 <conal> ac: i'm playing with a representation of infinite, continuous images (and other functions), so 256mb might not be enough.  :)
18:20:48 <ac> conal: but you're only looking at a finite area over any given time span
18:20:53 <ddarius> Convolve with an Airy filter the luminous surfaces.
18:21:05 <conal> and finite resolution
18:21:27 <oerjan> ac: 256 millibytes is not _that_ much (ducks)
18:21:30 <conal> ac: i'd like to avoid repeated copying to video memory
18:21:31 <ac> conal: you're dealing with 2D, so you want infinite pannability and zooming?
18:21:41 <conal> ac: exactly.  as in Pan
18:22:02 <conal> but in pan i represented images simply as functions.
18:22:17 <conal> so very low memory use, but lots of recomputation
18:22:39 <ac> conal: hmm. I wonder if you could use the video card to calculate your functions
18:22:40 <conal> ac: also progressive anti-aliasing
18:22:52 <conal> and also arbitrary (non-linear) transformations.
18:22:55 <ac> conal: that would only work on newer video cards that support programmable pixel shaders
18:23:11 <conal> ac: exactly.  i'll do that as well.  do you know about vertigo?
18:23:15 <ac> nope
18:23:18 <conal> @where vertigo
18:23:18 <lambdabot> I know nothing about vertigo.
18:23:25 <conal> @where+ vertigo http://conal.net/Vertigo
18:23:26 <lambdabot> Good to know.
18:23:31 <conal> :)
18:24:24 <ac> neat, I was just asking about something like that here earlier
18:24:43 <conal> vertigo compiled into vertex shader assembly code.  i'd like to dust it off for OpenGL.
18:24:59 <ac> conal: that would be very cool
18:25:01 <conal> i don't know whether OpenGL still supports assembly-style shaders
18:25:32 <conal> if so, it could be reasonably easy.  i'd do the UI in Haskell rather than generating C# code this time.
18:25:38 <conal> probably on top of TV
18:25:40 <ac> You mean OpenGL may only take programmable shader language as strings?
18:25:42 <conal> @wiki TV
18:25:42 <lambdabot> http://www.haskell.org/haskellwiki/TV
18:25:51 <sorear> it supports shaders in a portable language designed to pander to C++/Java programmers
18:26:01 <conal> ac: i mean the old assembly style vs the newer C style
18:26:06 <sorear> so retargeting your assembler shouldn't be hard
18:26:20 <conal> if the old assembly style is still available
18:26:27 <sorear> even if not.
18:26:33 <conal> btw, are you interested in helping resurrect vertigo
18:26:49 <ac> me?
18:26:53 <conal> sorear: yeah -- it may be easy enough to just start over and target the newer shading language.
18:26:57 <sorear> very little (and I don't have a working 3d accelerator)
18:27:24 <conal> ac: yes, you.
18:27:47 <ac> conal: sure, but I have very little experience in anything like that.
18:28:15 <conal> ac: oh, okay.  i don't quite know how to find interested, able, and available collaborators
18:28:28 <sorear> I have a GL fractal flame renderer that I'd like to finish, but it reliably crashes my X server
18:28:40 <ac> conal: I'd be interesting in learning, though it might take me a while to get up to speed
18:28:42 <conal> sorear: at least it's reliable!
18:28:43 <sorear> and that's most of my 3dfoo interest
18:29:20 <conal> ac: okay.  let's keep it in mind as we both get up to speed.
18:29:36 <conal> vertigo-generated code ran insanely fast
18:30:09 <conal> the images on the web page are all interactive, with automatically-generated GUIs.  very smooth.
18:30:21 <ac> conal: remember when I said I was interested in an interactive declarative graphics system? I'm not sure I was clear that I meant that both the final program would be interactive and the process of building the program would be interactive, meaning quick compilation
18:31:04 <conal> ac: i wasn't sure, before.  but that's exactly what i'm going after with eros.
18:31:43 <ac> conal: cool. How could I not want to work on such a system? Because it would be so much fun to play with the end result
18:32:02 <conal> ac: theoretically, eros runs cross-platform, being built on wxHaskell.  but probably not in practice, since i only have a windows machine right now.  soon to change!
18:32:11 <conal> ac: totally!
18:32:22 <ac> Especially if you could leverage a fast video card too
18:32:47 <ac> conal: is/was Vertigo suited for non-graphics computation?
18:32:48 <conal> yep.  functional sure helps there: no sequentiality to get in the way.
18:32:59 <conal> of course i mean *genuinely* functional, not IO
18:33:18 <conal> ac: yes. the compiler knows nothing at all about graphics.  all of my compilers work that way.
18:34:03 * ac considers buying a modern video card
18:34:30 <conal> one angle for eros is as a competitor to photoshop/gimp.  it allows filters to remain dynamic/parameterized even after applying them.  and the result is not limited merely to an image, but may be another filter.
18:34:45 <ac> that would be a requirement for this porject. Specifically an NVIDIA card, because I don't think the ATI ones play nice with linux
18:34:55 <conal> and the same environment can do 3d, sound, whatever.
18:35:12 <conal> oh -- i'm glad to know to stick with NVIDIA.
18:35:13 <allbery_b> not yet at least.  ati's making noises about that but it hasn't eventuated yet
18:35:57 <conal> i choose my current windows laptop carefully to have NVIDIA, because i have a stereo head-tracking head-mount display, and the stereo part only works with NVIDIA.
18:36:14 * sorear wants a documented video card
18:36:35 <conal> but then the display (dual svga) went way up in price, from $550 to $1500, which makes it much less interesting to develop for.
18:37:13 <dons> haskell.org's getting its butt kicked. i'm not sure we've ever had such an effect before, triggered by a ghc release
18:37:24 <dons> we'll have to think seriously about mirrors...
18:37:27 <ac> dons: it's a good sign I think
18:37:42 <conal> dons: that's awesome.  people care.
18:37:43 <dons> oh, certainly. better than languishing in obscurity :)
18:37:46 <allbery_b> unles syou're cale :>
18:37:48 <conal> a pretty recent phenomenon.
18:37:51 <dons> yep.
18:37:58 <Cale> hm?
18:38:06 <allbery_b> "beware of success"?
18:38:18 <allbery_b> or something like that
18:38:18 <Cale> ah
18:38:25 <dons> we're coping so far
18:38:30 <Cale> yeah, that's a common view actually, not just mine :)
18:38:36 <allbery_b> welcome to success, here's your free flash crowd
18:38:51 <dons> the academics are safely isolated from the crowd, so they can keep innovating
18:38:53 <conal> "free flash crowd"?
18:38:59 <dons> flash mob
18:39:08 <allbery_b> aka slashdotting
18:39:18 <conal> oh
18:39:25 <Korollary> dons: insert ghc into an open source torrent tracker?
18:39:26 <allbery_b> (and "free" as in we didn't do anything other than announce a release)
18:39:28 <ac> conal: considering that I've done basically nothing with compilers, what would you recommend reading for working on a project like this?
18:39:42 <allbery_b> fsvo "we"
18:39:55 <dons> Korollary: i think we'll have to talk to Igloo about this now, yes.
18:40:06 <dons> haskell.org's up, but just super super slow
18:40:13 <allbery_b> dcoutts is
18:40:16 <dons> will be interesting to get some statistics about it
18:40:19 <allbery_b> (in #ghc)
18:40:22 <conal> ac: hm.  i don't know.  i don't know much about compilers either.
18:40:41 <ac> conal: didn't you work on/create Vertigo?
18:40:43 <conal> ac: i'd say keep exploring haskell in general.
18:41:03 <stepcut> If distros already had 6.8.1 available, that would also likely reduce demand on haskell.org
18:41:13 <conal> ac: yes.  i've written a few compilers, but i think of myself as an amateur
18:41:49 <omnId> stepcut: considering it's only been released today, I'd say that's somewhat unreasonable :)
18:41:49 <conal> pan, pajama & vertigo are based on partial evaluation, rather than more traditional compiler technology.
18:41:53 <darinm> dons: it seems to be ok speed wise once it connects, or at least it has been when I've actually been able to download binaries
18:42:03 <darinm> just takes forever to connect
18:42:12 <dons> darinm: cool
18:42:19 <conal> i'm glad i grabbed 6.8.1 yesterday.  pure luck
18:42:19 <dons> yes, it just takes a long time to connect
18:42:33 <conal> even the win32 binary snapshot works!
18:43:58 <ac> conal: sounds like you're beeing a little bit modest. Surely you have one suggestion
18:44:12 <stepcut> omnId: well, KDE usually gives the packagers a few days between the final release, and the actual announcement
18:44:20 <monochrom> A torrent tracker for the haskell community would be good for distribution both ghc and lecture videos :)
18:44:53 <omnId> stepcut: I see.
18:45:05 <conal> ac: here's an immodest suggestion: read "compiling embedded languages".  See http://conal.net/papers for a link.
18:45:07 <lambdabot> Title: Conal Elliott&#146;s Publications
18:45:31 <ac> conal: heh. I'll check it out
18:46:08 <stepcut> It would be interesting to know how much traffic haskell.org gets in the next day or two, and see what the cost would be if the files were hosted on S3. (which also provides bittorrent downloads)
18:46:37 <dons> mm
18:46:38 <conal> hey all, i'm going to start using a linux soon and probably shift over to it as my main environment.  what are your favorite haskell-hacking-friendly linux choices?
18:47:06 <dons> mm. debian or gentoo i think are common. arch linux is also making some inroads
18:47:13 <monochrom> I use Ubuntu.
18:47:15 <dons> i think gentoo has the most haskell packages out of the box
18:47:21 <dons> and debian has the most ghc archs
18:47:21 <ac> conal: vim
18:47:44 <ac> conal: sawfish window manager
18:47:58 <ac> (nothing to do with Haskell though)
18:47:59 <monochrom> I use Ubuntu, but I don't use Ubuntu's haskell stuff. I download and sometimes build my own.
18:48:02 <dons> ac, come on.
18:48:04 <stepcut> what happened to the GSoC project to autobuild hackage packages for debian ?
18:48:13 <dons> this is haskell. we use xmonad for window management :P
18:48:16 <KatieHuber> I've used ubuntu's GHC a little, without issues
18:48:20 <conal> ac: lispy goodness.
18:48:27 <ac> dons: what?
18:48:36 <dons> xmonad. http://xmonad.org/ :)
18:48:37 <lambdabot> Title: xmonad : a tiling window manager
18:48:45 <ac> ;)
18:48:58 <idnar> I don't actually want a tiling window manager, all of my windows occupy the full screen
18:49:09 <dons> so you need a fullscreen tiling window manager
18:49:15 <sjanssen> idnar: xmonad has 'Full' mode too :)
18:49:16 <conal> ac: i'm an emacs fiend.  surprisingly, my fingers remember some vi, but i'd flounder without emacs.
18:49:19 <idnar> but I guess ion3 qualifies as one
18:49:20 <daniel_larsson> <- loves xmonad
18:49:34 <idnar> I was going to try xmonad out, but the "recompile it to change your bindings" thing put me off
18:49:38 * stepcut uses xmonad + full-mode most of the time
18:49:47 <mauke> idnar: why? how often do you change your bindings?
18:50:01 <conal> same (linux) question, but with "pretty" as another criterion.
18:50:11 <monochrom> DOS is a full-screen window manager. :)
18:50:13 <dons> idnar: oh, its not really like that. think of it as registering your bindings :)
18:50:16 <KatieHuber> I thought "let" bindings were supposed to be polymorphic?
18:50:21 <idnar> mauke: in general, not very often, but it means I can't use a packaged version, and it makes fiddling around with things while setting it up rather frustrating
18:50:23 <KatieHuber> why doesn't
18:50:23 <dons> idnar: since you don't actually have to quit to restart or anything like that
18:50:23 <KatieHuber> let { x = 3; y = 2 } in (fromIntegral (x `mod` y)) / x
18:50:25 <KatieHuber>  work?
18:50:35 <monochrom> Ubuntu is very pretty.
18:50:37 <LoganCapaldo> a lot in the begining not so much when oyou find some that suit you
18:50:43 <scook0> KatieHuber: monomorphism restriction, perhaps?
18:50:49 <idnar> anyhow, maybe I'll try again sometime
18:51:10 <mauke> idnar: the only frustrating thing is build time
18:51:14 <KatieHuber> scook0: yeah, if I introduce z it's ok
18:51:16 <dons> there was a new release yesterday for xmonad, btw.
18:51:20 <idnar> mauke: right
18:51:22 <mauke> install + restart is extremely smooth
18:51:24 <conal> so the main Ubuntu drawback is having to build ghc oneself to stay up to date?
18:51:34 <monochrom> "let f = \x -> x" is monomorphic, "let f x = x" is not.
18:51:39 <KatieHuber> but if I do it with z = x it's not, so I have to type the RHS of x twice?
18:52:03 <thetallguy> conal:we can do that
18:52:16 <conal> thetallguy: do what?
18:52:30 <dino-> conal: Do you mean to use GHC later than what's in apt?
18:52:31 <thetallguy> build ghc for ubuntu
18:52:41 <LoganCapaldo> > let { x :: (Num a) => a; x = 3 ; y = 2 } in (fromIntegral  (x `mod` y)) / x
18:52:44 <lambdabot>  0.3333333333333333
18:52:47 <conal> dino-: yeah.
18:52:47 <monochrom> Yes, only problem with Ubuntu is not-so-update haskell stuff.
18:52:52 <dino-> If you don't need things later than what's in packaging system, it's very easy to install.
18:52:56 <dino-> ok
18:53:04 <LoganCapaldo> > let { x = 3 ; y = 2 } in (fromIntegral  (x `mod` y)) / x
18:53:05 <lambdabot>  Add a type signature
18:53:24 <bos31337> @seen dons
18:53:24 <conal> and i assume building from source is a lot more fun than on windows.
18:53:24 <lambdabot> dons is in #ghc, #xmonad and #haskell. I last heard dons speak 1m 8s ago.
18:53:27 <LoganCapaldo> Seems to be MR or something similar to me
18:53:39 <ac> conal: Why would you have to build from source?
18:53:39 <dino-> There is sometimes the ability to use alien on things to convert them from rpm to deb. But for something complicated like ghc.. I may be very afraid of it.
18:53:41 <dons> yo bos31337
18:53:46 <ac> conal: I just installed the binary package
18:54:15 <omnId> dons: lacking an X server, I cannot use Xmonad.
18:54:15 <conal> ac: i tend to use & push bleeding edge language features
18:54:30 <dons> omnId: i can sell you one if you'd like?
18:54:31 <thetallguy> conal: the debian packaging is not always up to date
18:54:32 <ac> conal: are you dithering between Gentoo and Ubuntu?
18:54:38 <omnId> dons: hehe.
18:54:41 * LoganCapaldo votes they implement text mode xmonad
18:54:52 <dino-> Sounds like you're going to be often compiling GHC on whatever distro you're using then.
18:54:53 <idnar> LoganCapaldo: isn't that called screen?
18:55:02 <thetallguy> conal, so sometimes you would have to build the latest from source
18:55:08 <conal> ac: yes, given comments.
18:55:11 <bos> dons, i've been thinking about how to couple Data.Binary with a source of discontinuous data such as a bunch of UDP packets, and i haven't got a very good idea of what to do.
18:55:25 <bos> as in, i can think of a few things, but none of them is very clean.
18:55:42 <conal> thetallguy: yeah.  and i'm looking forward to doing so successfully on linux.  one of my motivations for leaving windows behind.
18:55:44 <dons> hmm.
18:55:53 <dfranke> WTF?  I just did an 'aptitude remove ghc6', and now *everything* in /usr/lib/ghc-6.6 is gone, including libraries that I compiled myself rather than installed from a .deb.
18:56:08 <bos> dons: for example, let's say you're trying to read 2000 bytes, but you get it in 1200-byte chunks.
18:56:12 <dons> yep
18:56:33 <thetallguy> dfranke: ain't Debian grand?
18:56:40 <Igloo> dfranke: Are you sure they aren't in /usr/local/lib?
18:57:01 <bos> i think the ideal interface for something like this would be a way to run the Get monad and have it indicate either partial consumption, failure, or a complete result with residual data.
18:57:20 <LoganCapaldo> dfranke: I think the lesson learned here is not to install home made libs into directories that the package manager believes it owns
18:57:25 <hpaste>  Jeff pasted "Rose Tree" at http://hpaste.org/3631
18:57:27 <bos> we already have the last of the three, but not either of the first two.
18:57:36 <dino-> dfranke: Sometimes I do "apt-get -s remove ..." to simulate and see what's about to happen without doing it.
18:57:36 <dfranke> Igloo: oh, so they are.  In one directory per package so I didn't see them when I looked for /usr/local/lib/ghc-6.6
18:58:00 <bos> in fact, trying to run the Get monad with an incomplete result gives an error, which is indistinguishable from a "real" failure.
18:58:08 <dfranke> ok, not-a-bug.
18:58:17 <dino-> Also, I don't use aptitude, only apt-get and dpkg, but apt-get seems to like to make double-sure you mean it when it's removing or installing lots of stuff.
18:58:18 <allbery_b> actually, does that matter?  you need tro reinstll them all anyway
18:58:45 <allbery_b> should have done a ghc-pkg list beforehand to see what needed to be rebuilt
18:58:55 <dfranke> LoganCapaldo: well, actually I *wanted* that behavior; I just wasn't expecting to get it.
18:59:09 <bos> unfortunately, making Get capable of partial results looks like it would require a lot of reworking.
18:59:26 <LoganCapaldo> well its kind of moot as it didn't actually happen anyway :)
19:00:04 <bos> you'd possibly have to recast it to use a CPS monad, so you could restart in the middle of a partial parse when you get more data.
19:00:43 <LoganCapaldo> Seeing warnings during this compile makes me feel dirty
19:02:17 <bos> uh oh, i've killed dons.
19:02:40 <stepcut> haha
19:02:46 <monochrom> Who will complete his part in Real World Haskell then?!
19:02:52 <dfranke> bos: what signal did you use?  I hope you ensured graceful termination.
19:03:11 <bos> if he dumped core, maybe we can recover the data.
19:03:16 <dons> bos, sorry, yes :)
19:03:35 <daniel_larsson> SIGCONT worked apparently
19:03:54 <thetallguy> Woud we then have a bot called 'donscore'?
19:04:01 <dons> bos, right, there's definitely some open issues in the various ways people want to use Get and Put. i don't have a firm idea yet of what the next step is, but i need to use binary at work for various things, so hopefully that will force some thinking on it :)
19:04:14 <monochrom> Another solution is to rewind and retry the transaction. Say, let's wind him back to his PhD in Australia...
19:04:18 <dfranke> daniel_larsson: nah, I restarted him.  He's still recovering his journal, though, so he might be slow for a while.
19:04:18 <dons> oh man
19:04:21 * dons kicks monochrom 
19:04:24 <bos> dons: yeah, i need to use Binary too.
19:04:26 <monochrom> hahahaha
19:04:49 <chessguy> hmm. i don't get this debugger
19:05:02 <dons> the debugger gets you?
19:05:04 <bos> but you probably get more cycles for it than i do.
19:05:05 <LoganCapaldo> chessguy: you have to download 6.8.1
19:05:15 <chessguy> LoganCapaldo, i have it
19:05:19 <conal> back to unfinished-phd days.  that's a scary thought
19:05:23 <LoganCapaldo> I forgot the smiley :)
19:05:27 <dons> bos, yeah, so maybe we should have a wiki page for future directions for the binary stuff?
19:06:05 <bos> dons: +1
19:06:28 <dons> i need to move a bunch of these projects onto code.haskell.org, and add wiki pages in the process
19:06:35 <dons> binary, bytestring, lambdabot et al
19:06:49 <dons> ssh'ing to sydney is getting tedious :)
19:08:12 <hpaste>  chessguy pasted "debugger" at http://hpaste.org/3632
19:08:15 <bos> heh, latency to galois's colo is undoubtedly better
19:08:24 <chessguy> i'm stepping through the evaluation of this line
19:08:32 <chessguy> and it's showing me what it evaluates
19:08:33 <dons> right.
19:08:50 <chessguy> but the next time i do step, it runs through to the end of the program
19:08:51 <bos> i looked at writing a deflate decompressor for the chapter on parsing binary files, but it would take too much space.
19:09:02 <dons> mmm
19:09:20 <dons> yeah, needs  to be kept concise
19:09:21 <sorear> chessguy: of course.  0 argument functions are memoized by GHC.
19:09:29 <sorear> that's why it's called a lazy language
19:09:41 <chessguy> sorear, but it's never evaluated this before
19:09:51 <bos> the problem with writing a haskell book is that you can't write complicated examples, or you suffer from combinatorial explosion in trying to describe wtf is going on.
19:10:07 <sorear> chessguy: oh, I misunderstood.
19:10:17 <chessguy> and that's not the only reason (or probably even the main reason) it's lazy
19:10:19 <dons> bos, too many new concepts per line of code?
19:10:29 <dons> or does that apply to any language?
19:10:41 <bos> i think haskell is much denser.
19:10:46 <sorear> chessguy: note that the debugger only works on bytecode.  (.), unlines, lines, interact, map, and ($) are compiled
19:11:23 <dons> bos, yeah, most languages are fairly monomorphic in the core concepts compared to haskell :) keeps things simple, and repetitive
19:11:37 <chessguy> oh, you mean because they're in libraries?
19:12:23 <sorear> chessguy: the standard library is compiled to native code.  Iborra didn't add the necessary hooks to the NCG, only to the bytecode generator.
19:12:44 <chessguy> 'yes' would have sufficed :)
19:14:25 <ac> dfranke: everything that's not installed using dpkg should generally be in /usr/local
19:17:16 <chessguy> can i tell the debugger to descend into non-compiled function calls?
19:18:38 <hpaste>  scook0 pasted "controlled conversion from (a -> IO b) to (a -> b)" at http://hpaste.org/3633
19:19:08 <scook0> any thoughts?
19:19:16 <monochrom> What I see from other real-world programming books (e.g., how to write eclipse plugins): they present significant examples, they don't explain everything used in the code, they only explain the focus of the chapter.
19:19:20 <idnar> mmm, pointer tagging
19:20:48 <Cale> scook0: since you're in IO anyway, can't you use unsafeInterleaveIO for that?
19:21:03 <Cale> er, hmm
19:21:20 <scook0> Cale: I want to ensure that all the unsafe I/O happens before a certain point, or not at all
19:21:29 <Cale> ah, okay
19:21:40 <scook0> (the sentinel stuff is theoretically unnecessary, but is an extra level of safety)
19:21:58 <Karle> hi I wonder if anyone has time to help a newbie like me?
19:22:19 <Cale> Karle: sure
19:22:42 <Cale> Karle: In fact, we encourage you to ask lots of questions :)
19:23:15 <Karle> I have some compiling problem with  scanl2SY
19:23:33 <Karle> I can show you more detail on Hpaste.org
19:23:38 <Cale> sure
19:25:35 <dfranke> whenever I try to install a package I'm getting:
19:25:36 <dfranke> cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
19:25:50 <hpaste>  Karle pasted "scanl2SY" at http://hpaste.org/3634
19:25:55 <dfranke> is this a ghc-6.8 issue or am I doing something wrong?
19:26:57 <Karle> Thanks Cale!
19:26:58 <Cale> Karle: perhaps you meant (fromSignal (Prst a :- NullS)) ?
19:27:19 <Cale> It's complaining that too many parameters were passed to scanl2SY
19:27:26 <Cale> I don't actually recognise that function
19:27:43 <Karle> fromSignal is actually unsignal
19:28:25 <Cale> (I think you're using a custom signal processing library or something?)
19:28:37 <Karle> yes SynchronousLib
19:28:59 <Cale> However, since you passed fromSignal as two of the parameters to scanl2SY, I kinda think you might have meant to apply it to the following things instead
19:29:07 <Karle> do you want to see the library
19:29:10 <omnId> function call syntax is a little different in Haskell.  f g(x) parses as: f (g) (x), with two arguments passed to f.
19:29:18 <ac> haskell.org servers need a shot of adrenalin
19:29:19 <Cale> That's all right
19:29:27 <oerjan> could also write (fromSignal $ Prst a :- NullS)
19:29:46 <Cale> Yeah, try that and see if it helps
19:29:54 <ShockSMX> is haskell.org slashdotted or something
19:30:00 <Karle> I will try now
19:30:01 <Cale> ShockSMX: yes
19:30:02 <omnId> @fact slow?
19:30:03 <ShockSMX> ok
19:30:03 <lambdabot> slow?: Yes, haskell.org seems slow. We think it's because of the new release.
19:30:52 <shapr> @yow !
19:30:52 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
19:31:00 * Cale wonders why Xorg has grown to 500MB
19:31:01 <shapr> Mmm, I want my spaceship!
19:31:21 * shapr dynamicizes StaticVector!
19:31:23 <Karle> Cale : what should I try to be more precise?
19:31:38 <Cale> Karle: Your parens are in the wrong place, I think
19:31:49 <shapr> Always listen to your parens!
19:31:55 <Cale> f g(x) h(y) doesn't mean f (g x) (h y)
19:32:00 <Karle> thanks , shapr
19:32:04 <Cale> It means f g x h y
19:32:15 <mauke> (x) always means x
19:32:31 <Karle> alright
19:32:35 <monochrom> (((f g) x) h) y
19:32:35 <Karle> thanks
19:32:50 <shapr> Karle: I was just punning on "Always listen to your parents" :-)
19:32:54 <oerjan> @. id @ @run replicate 3 =<< @show @fact slow?
19:32:56 <lambdabot>   "ssslllooowww???:::   YYYeeesss,,,   hhhaaassskkkeeellllll...ooorrrggg   sss...
19:33:03 <Olathe> What's the new version ?
19:33:07 <omnId> hah hah
19:33:11 <monochrom> hahahahah
19:33:13 <monochrom> 6.8.1
19:33:20 <shapr> Karle: Det √§r inte s√• roligt p√• engelska.
19:33:24 <shapr> er, p√• svenska
19:33:41 <Olathe> Is it the stable version ?
19:33:46 <monochrom> Yes.
19:33:49 <Olathe> Ahh :)
19:33:50 <shapr> I speak Scandinavian.
19:33:54 <dfranke> where did the .1 come from?  Isn't the custom just to start with 6.8?
19:34:04 <monochrom> The custom changed.
19:34:04 <Cale> Not with GHC, apparently
19:34:33 <Karle> thanks you guys
19:34:35 <Olathe> dfranke: Haskell is so advanced, its new versions are from the future.
19:34:40 <shapr> Karle: Do you have more questions?
19:34:43 <chessguy> i'm clearly going to have to bind M-p RET to something to use this debugger :)
19:34:58 <scook0> dfranke: there's a comment about the new numbering in the 6.8.1 docs
19:35:22 <Karle> be right back for more questions
19:35:39 <dons> dfranke: 6.8 was a dev-only release
19:36:29 <dfranke> also, what's on tap for 6.10/7.0?  I noticed that there have already been 6.9 snapshots being made for a few months.
19:36:36 <Olathe> @speedup-site
19:36:36 <lambdabot> Unknown command, try @list
19:36:43 <sorear> dfranke: 6.8.0.$date is pre-release snapshorts
19:36:58 <chessguy> @version
19:36:59 <lambdabot> lambdabot 4p571, GHC 6.6 (Linux i686 2.66GHz)
19:36:59 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:37:03 <chessguy> LB is so outdated
19:37:07 <sorear> dfranke: 6.9 is the devbranch, it might become anything
19:37:20 <sorear> chessguy: 'twas 6.4.2 until a few months ago
19:37:21 <dfranke> sorear: yeah, I know that.  But what's planned?
19:37:24 <Olathe> lambdabot is sooo five days ago.
19:37:30 <sorear> dfranke: type families
19:38:00 <chessguy> Olathe, at least someone appreciated my joke :)
19:38:08 <sorear> also major backend rewrite (have you seen the ASM for memcpy?  9 memory references per loop with the current backend)
19:38:24 <ac> conal: how would your project of reviving Vertigo and supporting OpenGL fit in with your other projects such as Phooey, TV, DeepArrow, and Pajama?
19:39:51 <darinm> has anyone given any more thought to targeting LLVM at the backend?
19:40:16 <hpaste>  Karle pasted "help" at http://hpaste.org/3635
19:40:36 <Karle> Hi again .... my next question is posted
19:40:43 <Karle> please help
19:41:28 <chessguy> Karle, you never defined Prst, for one thing
19:41:55 <chessguy> Karle, nor AbstExt
19:42:31 <Karle> I should have more variables?
19:42:53 <Karle> according to the type
19:43:18 <omnId> I don't see the syntax error in that pasted code.  Maybe it's from elsewhere?
19:43:20 <chessguy> Karle, you can't use an expression like AbstExt without defining it somewhere
19:44:00 <Cale> chessguy: I figure they're in the library
19:44:01 <oerjan> Karle: check the line number for the error
19:44:02 <omnId> you could do with some spaces for clarity, though :)
19:44:15 <monochrom> I gave stub declarations for AbstExt and Prst. I get no error.
19:44:40 <Cale> ...yeah, there's no obvious error in that snippet of code
19:44:52 <mauke> there is, actually :-)
19:44:55 <oerjan> Karle: are you perhaps trying to paste that into your interpreter?
19:45:00 <chessguy> except he's not importing any library
19:45:02 <mauke> use of foo [(x,y)] = ... is a typical newbie error
19:45:31 <Cale> mauke: hm?
19:45:41 <omnId> mauke: semantically, maybe, but not syntactically :)
19:45:43 <oerjan> because data declarations must be in a file
19:45:49 <scook0> Cale: assuming that will map over the list, rather than match a single-element list
19:46:19 <LoganCapaldo> scook0: really?
19:46:42 <scook0> LoganCapaldo: i.e. the mistake is assuming that it will do that (because in fact it won't)
19:46:51 * LoganCapaldo has difficulty imagining it would do that
19:47:08 <LoganCapaldo> rather I have dificulty imagining imagining it would do that
19:47:10 <Karle> Table = [(Address,Port)] so I use [()]
19:47:16 <idnar> hmm, that wouldn't have occurred to me if you hadn't suggested it
19:47:17 <scook0> that's probably because you know Haskell too well
19:47:32 <scook0> I can see it being reasonable from a newbie's perspective
19:47:35 <monochrom> I have never been a newbie.
19:47:39 <idnar> but if someone told me that's what it did, I wouldn't find it completely crazy
19:47:51 <allbery_b> haskell does, to a first approximation, look like programming by example, so I can see that
19:47:53 <scook0> let monochrom = fix addExperience
19:48:01 <oerjan> Karle: anyway there are errors in what you pasted but none of it explains the error message.  Please paste whole error message and the whole file which it refers to.
19:48:55 <oerjan> if it isn't in a file but something you typed at the interpreter prompt, then that _might_ explain your error.  put it in a file instead.
19:49:23 <Karle> That was the whole error message
19:50:06 <mauke> Karle: what, no line number?
19:50:19 <SamB_XP> okay, why the heck is james clark on twitter... he hasn't done anything yet
19:50:25 <monochrom> Most of newbie errors are creativity errors and guess errors. I am not creative, and I don't guess (ok, I guess and check, and when it fails I stop guessing), so I tend not to make those errors. (What do I do instead? I read the rules again and again...)
19:50:38 <oerjan> it looks like a Hugs error message
19:50:40 <scsibug`> Well, this is no good.  ":print (+)" in GHCi 6.8.1 gives me a panic.
19:51:24 <oerjan> Karle: and was that your whole file you pasted?
19:51:37 <LoganCapaldo> I think I have a similar attitude to monochrom
19:51:51 <oerjan> and for the third time, have you put it in a _file_ at all?
19:52:01 <SamB_XP> ... and ... jwz has way more followers and posted 3 times ... and what does jwz do anymore anyway?
19:52:07 <LoganCapaldo> Anything I come up with creatively I assume to be incorrect so i don't try it
19:52:22 <LoganCapaldo> heh
19:52:24 * chessguy prepares to hold oerjan in his chair
19:52:37 <omnId> 21:57 <!LoganCapaldo> > let { x :: (Num a) => a; x = 3 ; y = 2 } in (fromIntegral  (x `mod` y)) / x
19:52:50 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3635#a1
19:53:07 <omnId> LoganCapaldo: you try some things :)
19:53:15 <monochrom> If I guess or "create" something, I first verify that the written rules justify it. Minimal presumption.
19:53:31 <Karle> oerjan... no it is just a part of it
19:53:32 <LoganCapaldo> my next statement was going to be I do guess a lot however :)
19:53:35 <omnId> Karle: that probably means the defintion before that line ended prematurely
19:53:48 <Karle> oerjan ... do you want me to post the whole file?
19:54:13 <omnId> Karle: post the definition right before line 1010
19:54:16 <omnId> 101*
19:54:24 <oerjan> chessguy: darn right! :)
19:54:44 <LoganCapaldo> (plus I don't think that as particular creative)
19:56:04 <oerjan> what omnId said
19:56:06 <dfranke> where is the current repository for haddock.ghc?
19:56:15 <dfranke> the /SoC/ version seems to be a year old.
19:56:36 <Karle> it turned out to be the last line I had problem with
19:56:43 <dfranke> wait, nm.
19:56:47 <omnId> @slap Karle
19:56:47 * lambdabot clobbers Karle with an untyped language
19:56:57 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3635#a2
19:57:09 <allbery_b> perlwhacked?
19:57:15 <monochrom> hehe
19:57:24 <dfranke> I was looking at ghc.haddock
19:57:25 <nburlett> hey all, GHC 6.8.1 doesn't seem to compile on Mac OS X Leopard
19:57:33 <oerjan> any way, that "unexpected `;', possibly ..." often means something wrong just before it
19:57:49 <nburlett> Readline.hsc doesn't work
19:57:51 <scsibug`> nburlett: are you getting readline errors?
19:57:56 <oerjan> and it can be anything, because that ; is "virtual", a result of layout processing
19:57:57 <chessguy> Karle, yeah, you're missing a ) on that line
19:57:59 <nburlett> scsibug`: indeed
19:57:59 <Karle> oerjan ... i see
19:58:01 <scsibug`> yep, I ran into that too
19:58:04 <allbery_b> or squeezed to death by a Python, or Tcled to death
19:58:13 <nburlett> scsibug: what's the fix?
19:58:27 <Karle> that's right
19:58:58 <scsibug> nburlett: building readline from source will probably work... I did a PPC build instead, haven't gotten around to trying to fix intel.
19:59:06 <omnId> Karle: and, like Cale said, change the fromSingal calls to: (fromSignal (Prst a :- NullS))
19:59:08 <nburlett> scsibug: I'm on PPC
19:59:15 <omnId> with the outer parens
19:59:36 <Karle> yes.. now I am runing into another problem ..... thanks.... brb
19:59:37 <scsibug> nburlett: I just posted a binary build of 6.8.1 for PPC... scsibug.com
19:59:41 <chessguy> @seen Cale
19:59:41 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 14m 10s ago.
19:59:46 <Cale> hi
20:00:06 * chessguy introduces himself to omnId
20:00:27 <omnId> hello chessguy
20:00:39 <omnId> I've been previously known as omniscientIdiot
20:00:50 <chessguy> i don't think you got the joke
20:00:51 <chessguy> lol
20:00:54 <chessguy> never mind
20:00:54 <nburlett> scsibug: I'd prefer to just build it myself... what readline package did you use?
20:00:57 <scsibug> nburlett: It was built on 10.4, and assumes you have gmp and readline.  I'd be really curious to find out if it worked on 10.5/PPC.
20:01:13 <monochrom> Now you're omni-identitical
20:01:27 <LoganCapaldo> omnId :: a -> a ?
20:01:31 <nburlett> scsibug: ok
20:01:36 <monochrom> hehe, yeah, like that :)
20:01:46 * nburlett downloads from scsibug.com
20:02:01 <omnId> oh god, I just saw my typo, was it re: that, chessguy?
20:02:04 <scsibug> nburlett: GNU readline 5.2 ... which I haven't gotten to build on intel yet (it failed when i just ran configure and make).  The OS X GNUReadline framework worked for 6.6, but doesn't for 6.8.
20:02:13 <chessguy> omnId, bingo :)
20:02:19 <nburlett> scsibug: figgures
20:02:26 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3635#a3
20:02:37 <brad__> dons announced 6.8.1 with this note (among others): "overload string literals (!)"...can someone tell me the significance of this?
20:02:53 <omnId> "blah" :: IsString a => a
20:03:01 <Karle> hi again... it seems that I still have the same problem but with different complains
20:03:03 <omnId> class IsString where fromString :: String -> a
20:03:04 <LoganCapaldo> "hello world" :: ByteString
20:03:21 <omnId> Karle: change the fromSignal calls!  You've been told twice!
20:03:41 <brad__> ah, so this will make it easier to use ByteStrings?
20:03:53 <Karle> omnId ... please tell me again ... I might have missed the message
20:04:03 <LoganCapaldo> "Select * from users" :: IO SqlQuery
20:04:25 <brad__> what about "associated types" ?
20:04:27 <omnId> fromSignal(Prst(a)):-NullS   --->   (fromSignal (Prst a :- NullS))
20:04:29 <LoganCapaldo> I look forward with great anticipation to all the abuses people come up with for this
20:05:09 <sjanssen> LoganCapaldo: instance IsString (IO ()) where fromString = putStrLn
20:05:35 <Saizan_> is fromString applied at compile or runtime?
20:05:37 <Karle> thanks omnId
20:05:37 <LoganCapaldo> sjanssen: yeah wasn't that the first abuse thought up for this? :)
20:05:59 <sjanssen> LoganCapaldo: I think the original use-case was ByteString
20:06:14 <LoganCapaldo> empahsis on the _ab_ :)
20:06:26 <Flynsarmy> putStrLn (length lst). How do i change the Int to a String so putStrLn will work?
20:06:35 <monochrom> "1+1" :: Dynamic  {- the semantics is: parse, interpret, evaluate as Haskell -} :)
20:06:39 <Flynsarmy> I would have used hoogle but it's timing out :(
20:06:42 <oerjan> @remember LoganCapaldo [on overloaded string literals] I look forward with great anticipation to all the abuses people come up with for this
20:06:43 <lambdabot> It is stored.
20:06:43 <sjanssen> instance IsString (CharParser ()) where toString = string
20:06:56 <Saizan_> Flynsarmy: show
20:07:04 <allbery_b> :t show
20:07:12 <lambdabot> forall a. (Show a) => a -> String
20:07:26 <allbery_b> @instances Show
20:07:27 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
20:07:46 <Olathe> > (1, 2, 3, 4, 5)
20:07:47 <lambdabot>  (1,2,3,4,5)
20:07:59 <Olathe> Unpossible !
20:08:01 <hpaste>  omnId annotated "help" with "function application" at http://hpaste.org/3635#a4
20:08:13 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3635#a5
20:08:19 <Karle> omnId ... it complains something else
20:08:59 <omnId> yes?
20:09:01 <oerjan> Flynsarmy: note that putStrLn . show = print
20:09:12 <chessguy> omnId++  for pasting the answer to a question half a second before it was asked :)
20:09:12 <Flynsarmy> oerjan: Thanks
20:10:27 <omnId> Karle: if the scanl2SY function takes a Signal, maybe you should omit the fromSignal function?
20:10:47 <omnId> that's what the error is telling you.
20:10:59 <omnId> fromSignal gives a type that scanl2SY doesn't like.
20:11:02 <Karle> omnId, thanks for clarification
20:11:41 <oerjan> omnId: unless :- doesn't return a Signal either?
20:11:47 <oerjan> (hypothetically)
20:12:02 <omnId> oerjan: presumably fromSignal takes a Signal :)
20:12:15 <oerjan> yes, but the type error could be the :-
20:12:35 <omnId> Karle: could you say: ':t (:-)' at the prompt for me?
20:12:40 <Karle> I get rid of the fromsignal....still some complains
20:13:00 <Karle> ok...omnId
20:13:11 <oerjan> omnId: might be hard in hugs if it doesn't compile
20:13:19 <omnId> oh, right
20:13:40 <omnId> 100+ line program as your intro to haskell?  Isn't that a bit much?
20:14:05 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3635#a6
20:14:42 <omnId> *both* of them you silly silly person.
20:14:44 <Karle> sorry it is late and I forgot to delete another fromsignal
20:14:47 <oerjan> Karle: you still have a fromSignal there
20:15:06 <chessguy> omnId, well, to be fair, it probably _should_ only be about a 20-line program
20:15:28 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3635#a7
20:16:54 <nburlett> scsibug: so, I do a sudo make install from your tarball?
20:17:29 <oerjan> Karle: it seems like updateTable misses an argument
20:17:39 <oerjan> in its definition
20:18:02 <oerjan> or possibly scanl2SY uses it with too many
20:18:20 <omnId> Karle: perhaps it would be easiest to paste the whole thing.
20:18:24 <Karle> I think it needs signal
20:18:49 <oerjan> first guess is that update_table should take _two_ signals
20:19:22 <scsibug> nburlett: you need to do ./configure, and then sudo make install
20:19:36 <Karle> alright .... here it comes
20:19:46 <oerjan> er, two AbstExts
20:19:52 * nburlett blindly follows instructions
20:19:59 <hpaste>  Karle annotated "help" with "(no title)" at http://hpaste.org/3635#a8
20:20:44 <omnId> Karle: it's limited to 5K, try another pastebin
20:20:53 <Karle> ok
20:21:32 <Karle> omnId ... that was the whole file actually
20:22:16 <oerjan> Karle: i guess scanl2SY is defined in a library?
20:22:28 <Karle> oerjan ... yes
20:23:35 <oerjan> given the type we've seen for scanl2SY, update_table needs to take _two_ AbstExt arguments rather than one
20:23:43 <hpaste>  Karle pasted "synchronouse lib" at http://hpaste.org/3636
20:25:01 <oerjan> Karle: hm.  try using scanlSY instead of scanl2SY
20:25:16 <oerjan> it has the right type for your update_table
20:25:21 <Karle> oerjan... I will try
20:25:32 <oerjan> oh wait, not quite
20:25:38 <omnId> oh boy, this is a bit much.  Maybe you should start with a basic tut, Karle?
20:26:18 <oerjan> indeed.  i think at this rate you are not going to get through all the bugs even with our help.
20:26:39 <omnId> is this a homework assignment?  Playing of your own?  Have you read any tuts?  What have you used to get this far?
20:27:07 <Karle> oerjan... yes but very quickly
20:27:28 <Karle> homework  assignment
20:28:40 <Karle> still error with scanlSY
20:28:56 <oerjan> yeah, i was wrong about that.
20:29:28 <dons> anyone else assumed 'hadoop' was a haskell library? :)
20:29:49 <omnId> dons: what is it?
20:30:06 <P_D> mapreduce
20:30:13 <nburlett> scsibug: it seems to work
20:30:34 <oerjan> basically updateTable can only be used to handle one signal, while scanl2SY tries to use it to handle two at a time
20:31:03 <Karle> oerjan ... i see
20:31:15 <scsibug> nburlett: excellent, thanks.  always good to get some verification from something besides my abused 2-year old 10.4 install.
20:31:42 <scsibug> nburlett: how do you have readline installed?
20:31:47 <omnId> we'd need a lot more background on the details of your assignment (and a lot more time) to suggest many improvements.
20:32:08 <Karle> oerjan ... this case we can force it to handle one at the time right?
20:32:09 <nburlett> scsibug: I have both the Darwin Ports and the default versions
20:32:22 <scsibug> nburlett: does ghci work alright then?
20:32:46 <nburlett> scsibug: yes, that's how I tested it
20:32:53 <scsibug> sweet, excellent
20:33:20 <oerjan> Karle: you can write a new version of update_table that handles two at a time (it could use the old one), or you could change update_pr to only take 1 at a time, i don't know which one you need
20:33:31 <nburlett> I'd love to get it to build on 10.5
20:33:54 <scsibug> nburlett: send me your email address, and i'll let you know if I make any progress
20:34:04 <Karle> oerjan... the first case
20:34:09 <Karle> i guess
20:34:12 <omnId> Karle: depends on what it *does*, and whether you need it.  Sure you can make addition take only one number but I don't know if that's what will be correct for your problem statement.
20:34:27 <omnId> > let (+) x = x Prelude.+ x in (+) 12
20:34:29 <lambdabot>  24
20:34:40 <scsibug> /nburlett: i'm going out of town next week with my 10.5 intel laptop, so i'm definitely going to try to get it working.
20:35:04 <nburlett> scsibug: did you get my private message?
20:35:39 <Karle> omnId, I gotta take a look abit closer
20:35:56 <oerjan> Karle: you could try using update2_table t s1 s2 = update_table (update_table t s1) s2
20:36:22 <Karle> oerjan ...yes
20:36:44 <idnar> hAdoop
20:36:55 <omnId> if, of course, that's what you need update_pr to do...
20:39:22 <Karle> it passes the line
20:39:28 <Karle> it works
20:40:11 <Karle> thanks
20:41:37 <oerjan> :)
20:42:26 <Karle> why are you guys so good in Haskell?
20:42:45 <Karle> for research?
20:43:07 <omnId> for fun :D
20:43:27 <Karle> amazing!
20:43:27 <oerjan> hey i'll go with that too
20:43:49 <oerjan> there are of course some people here who do it professionally too
20:44:09 <Karle> in which application haskell is used?
20:44:13 <ddarius> The majority of the people here don't do it for research or class or work.
20:44:23 <Karle> i see
20:44:26 <dfranke> hmm
20:44:29 <dfranke> Preprocessing library base-3.0.0.0...
20:44:29 <dfranke> Running Haddock for base-3.0.0.0...
20:44:29 <dfranke> Warning: The documentation for package rts-1.0 is not installed. No links to it will be generated.
20:44:32 <kilimanjaro> ddarius, the majority of people in here idle :)
20:44:33 <SamB_XP> which is too bad :-(
20:44:36 <dfranke> <built-in>:1:0:  error: ""<command" is not a valid filename
20:44:36 <dfranke> make[1]: *** [doc.library.base] Error 1
20:44:54 <Karle> kilimanjaro, :)
20:45:02 <ddarius> kilimanjaro: They don't all talk at the same time, but many of them do say something sometimes.
20:45:23 <ddarius> There are probably Haskellers in every time zone.
20:46:08 <oerjan> might wonder about some of the mainly ocean ones
20:46:28 <ddarius> oerjan: You might, but I wouldn't be surprised (though I wouldn't be surprised the other way)
20:46:41 <darinm> who was having those readline problems earlier?
20:47:50 <sorear> everyone
20:47:58 <darinm> :)
20:48:07 <sorear> OSX doesn't ship with readline
20:48:11 <Karle> derive_adr_A::Signal [(Int,Port)]->Address
20:48:21 <sorear> it ships with a different and incompatible library with the same name
20:48:38 <psnively> LOL
20:48:47 <Karle> derive_adr_A  (Prst (a,p)):-NullS) = pick_adr (headS(a,p))
20:49:02 <Karle> this gives errors as well
20:49:04 <mauke> unbalanced parens
20:49:18 <SamB_XP> sorear: since when does everyone have a copy of that ?
20:50:34 <allbery_b> all the readline complaints so far have been on osx
20:50:44 <allbery_b> which is nothing new for gcc + osx...
20:51:01 <psnively> Heh.
20:51:14 * allbery_b wishes apple had left well enough alone, it was fine as editline
20:51:18 * bos wonders how much beer is going to help the writing process this evening
20:51:27 <psnively> bos: LOTS of beer.
20:51:41 <newsham> is www.haskell.org hosed right now?
20:51:48 <darinm> yeah
20:51:48 <psnively> newsham: Yes.
20:51:48 <allbery_b> @fct slow?
20:51:49 <lambdabot> Maybe you meant: fact ft
20:51:49 <ddarius> @fact slow?
20:51:49 <lambdabot> slow?: Yes, haskell.org seems slow. We think it's because of the new GHC release.
20:51:56 <darinm> heh
20:51:59 <dfranke> so, haddock-0.8 doesn't seem to build in ghc-6.8, and haddock.ghc seems to choke on the ghc-6.8 source.
20:52:08 <darinm> nice
20:52:14 <dfranke> so what's the right way to build the ghc library docs?
20:52:24 <bos> @fact pony?
20:52:24 <lambdabot> I know nothing about pony?
20:52:26 <Flynsarmy> not equal in Haskell is \= isn't it?
20:52:30 <allbery_b>  /=
20:52:35 <conal> waern told me today that he's working on haddock.ghc getting through ghc-6.8.1 base.
20:52:36 <Flynsarmy> allbery_b: Thanks
20:52:39 <bos> @fact+ yes, you can have a pony.
20:52:40 <lambdabot> I know nothing about yes,
20:52:57 <bos> hmm, @fact is opaque to me.
20:53:05 <ddarius> bos: If you were expecting consistency in user interface, lambdabot was not the place to look.
20:53:06 <allbery_b> it's @fact-set
20:53:08 <omnId> @list fact
20:53:08 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-update
20:53:14 <allbery_b> you can have multiple facts
20:53:20 <allbery_b> with the same name
20:53:27 <allbery_b> so it's not just fact+
20:53:32 <ddarius> @help fact-update
20:53:33 <lambdabot> Define a new fact, overwriting
20:53:37 <bos> ddarius: yeah, i figured that out a long time ago.
20:53:38 <ddarius> @help fact-set
20:53:38 <lambdabot> Define a new fact, guard if exists
20:53:51 <allbery_b> @help fact-snoc
20:53:51 <lambdabot> snoc information to fact
20:53:52 <psnively> I'll tell you one thing...
20:53:54 <bos> @fact-set pony yes, you can have a pony.
20:53:55 <lambdabot> Fact recorded.
20:53:58 <bos> @fact pony?
20:53:59 <lambdabot> I know nothing about pony?
20:54:01 <bos> @fact pony
20:54:01 <lambdabot> pony: yes, you can have a pony.
20:54:05 <bos> ok.
20:54:15 <psnively> The GHC 6.8.1 boot process is EXCRUCIATING on a 1.67 GHz PowerPC G4.
20:54:23 <dmwit> ?fact-snoc pony but only if you're good.
20:54:23 <lambdabot> Fact altered.
20:54:26 <dmwit> ?fact pony
20:54:26 <lambdabot> pony:  but only if you're good.yes, you can have a pony.
20:54:30 <Karle> I ran into another bug
20:54:40 <SamB_XP> didn't lambdabot already have some kind of fact-like functionality?
20:54:40 <dmwit> Looks like a cons to me.
20:54:53 <allbery_b>  @where isn't @fact
20:54:54 <ddarius> ?fact-cons pony and if we have the money
20:54:54 <lambdabot> Fact altered.
20:54:59 <ddarius> @fact pony
20:54:59 <lambdabot> pony: and if we have the money  but only if you're good.yes, you can have a pony.
20:55:00 <allbery_b> possibly ti should be
20:55:04 <allbery_b> heh
20:55:15 <ddarius> @where pony
20:55:15 <lambdabot> I know nothing about pony.
20:55:21 <dmwit> ?were wolf
20:55:22 <lambdabot> Aroooooo!
20:55:27 <dmwit> hee hee!
20:55:32 <allbery_b> *snrk*
20:55:35 <SamB_XP> hahahahahaha
20:55:37 <psnively> ?there wolf. ?there castle.
20:55:37 <lambdabot> I know nothing about wolf..
20:55:47 <SamB_XP> @help were
20:55:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:55:57 <dmwit> Spell-corrects to ?where.
20:55:59 <dmwit> ?where wolf
20:56:00 <lambdabot> Aroooooo!
20:56:15 * omnId just now gets that joke >_>
20:56:16 <SamB_XP> ah. the period had me confused
20:56:20 <conal> @where+ pony http://sc.tri-bit.com/Pony
20:56:20 <lambdabot> I will remember.
20:56:33 <sclv> is there a way to get a dump of the current contexts of the where and fact datastores?
20:56:48 <dmwit> ?where state
20:56:49 <lambdabot> I know nothing about state.
20:57:09 <dmwit> sclv: Yes, but I don't remember where it is. =P
20:57:10 <allbery_b> @help @state
20:57:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:57:14 <allbery_b> @help state
20:57:15 <lambdabot> state is a module.
20:57:19 <dmwit> ?where lambdabot
20:57:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:57:21 <allbery_b> @list state
20:57:21 <lambdabot> state has no visible commands
20:57:32 <sclv> @list where
20:57:32 <lambdabot> where provides: where url what where+
20:57:46 <oerjan> @url pony
20:57:46 <lambdabot> http://sc.tri-bit.com/Pony
20:57:48 <omnId> @what wolf
20:57:48 <lambdabot> Aroooooo!
20:58:00 <darinm> so what's the procedure to build 6.8.1 on os x, assuming one has readline from macports?
20:58:03 <dmwit> Here we go:
20:58:13 <dmwit> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
20:58:13 <lambdabot> Title: Index of /~dons/lambdabot/State
20:59:29 <dmwit> Actually, looking at the "karma" file there, I don't really think that's recent.
20:59:33 <Olathe> http://www.haskell.org/ghc/download_ghc_681.html
20:59:59 <Olathe> Sometime soon, I'll have the address for the actual download.
21:02:06 <Karle> I ran into another bug
21:02:36 <Karle> ERROR file:.\switch_syn.hs:99 - Type error in explicitly typed binding
21:02:37 <Karle> *** Term           : Prst (a,p) :- NullS
21:02:37 <Karle> *** Type           : Signal (AbstExt (a,b))
21:02:37 <Karle> *** Does not match : Signal [(Int,Port)]
21:02:45 <dmwit> ?hpaste
21:02:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:02:55 <Karle> I cannot match the two types
21:03:40 <Karle> pick_adr:: Signal [(Int,Port)]->Address
21:03:40 <Karle> pick_adr (Prst (a,p):-NullS) = a
21:06:16 <oerjan> ah
21:06:24 <oerjan> Karle: i think here you do need fromSignal
21:06:50 <oerjan> or...
21:07:00 <Karle> signal maybe?
21:07:14 <oerjan> no they're both Signal
21:07:47 <dfranke> is there a mirror from which I can fetch the standard library API docs for 6.8 while haskell.org is hosed?
21:08:02 <oerjan> lessee, AbstExt is that thing with Prst?
21:08:14 <Karle> yes
21:09:31 <Flynsarmy> How do you create a list of infinate size again? [1, 2, 3, ...] ?
21:09:33 <ddarius> normSquared = join dot
21:09:41 <oerjan> > [1..]
21:09:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:10:11 <Cale> > let xs = 1 : map (+1) xs in xs
21:10:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:10:24 <omnId> dfranke: don't they come locally with an install?
21:10:26 <ddarius> @src Floating
21:10:26 <lambdabot> class  (Fractional a) => Floating a  where
21:10:26 <lambdabot>     pi                                                      :: a
21:10:26 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
21:10:26 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
21:10:26 <lambdabot>     (**), logBase                                           :: a -> a -> a
21:10:58 <Flynsarmy> oerjan: Was there a way to do it where you could input several chars? i tried [1, 3, 5..] but it didn't work
21:11:03 <dfranke> omnId: I downloaded the sources, not the binaries, and those require them to be built using haddock.  But haddock is choking.
21:11:11 <Cale> > [1,3..]
21:11:12 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
21:11:28 <Cale> (that's as many terms as it'll handle though
21:11:29 <Cale> )
21:11:37 <Cale> > [1,3..27]
21:11:39 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27]
21:12:01 <Flynsarmy> > [1,3,5..]
21:12:02 <lambdabot>  Parse error at "..]" (column 7)
21:12:29 <omnId> [x,y ..] is translated to enumFromThen x y, so another argument wouldn't make sense.
21:12:49 <oerjan> > 1:[3,5 ..]
21:12:51 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
21:13:08 <Cale> Well, it could if we had some kind of quadratic interpolation prelude function as well :)
21:13:13 <Flynsarmy> I was trying to create one of space characters
21:13:47 <Cale> Space characters?
21:13:55 <Cale> > replicate 10 ' '
21:13:56 <lambdabot>  "          "
21:14:17 <oerjan> Karle: what about pick_adr s = a where Prst (a,_) = fromSignal s
21:14:25 <Flynsarmy> Figured it out. i was using "s instead of 's. Thanks guys
21:15:00 <Karle> oerjan .. thanks
21:15:00 <oerjan> er, pick_adr s = head a where Prst (a,_) = fromSignal s
21:16:40 * SamB_XP discovers that the "real-life" portion of his facebook friends list is almost subsumed by someone else's friends list
21:17:17 <oerjan> oh wait, that may not be it either
21:17:50 <oerjan> pick_adr s = a where Prst ((a,_):_) = fromSignal s
21:18:10 <dmwit> > unwords . replicate 5 $ " "
21:18:12 <lambdabot>  "         "
21:18:35 <oerjan> although since i'm not sure how AbstExt is defined it's not quite clear if Prst takes just the same type as its argument
21:19:05 <oerjan> @src unwords
21:19:06 <lambdabot> unwords [] = ""
21:19:06 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
21:20:01 <oerjan> @check \l -> unwords l == concat (intersperse " " l)
21:20:05 <Karle> Abst :: AbstExt a
21:20:05 <Karle> Prst :: a -> AbstExt a
21:20:06 <lambdabot>  OK, passed 500 tests.
21:20:39 <oerjan> oh, so there might be an Abst instead
21:20:53 <oerjan> well, anyhow if there is there won't be an address inside it
21:21:18 <oerjan> so matching Prst will be enough.  It might fail with an empty list anyhow.
21:22:33 <oerjan> although if you wanted to guard against errors, the result should probably be Maybe Address rather than just Address.
21:23:31 <oerjan> but i think my last version of pick_adr may at least be correctly typed
21:26:08 <Karle> oerjan, should it look like this?
21:26:11 <Karle> pick_adr:: Signal [(Int,Port)]->Address
21:26:11 <Karle> pick_adr s = a
21:26:11 <Karle>        where
21:26:11 <Karle>        Prst ((a,_):_) = fromSignal s
21:26:57 <oerjan> yeah
21:27:56 <oerjan> well you could make that Int into Address too
21:28:50 <oerjan> pick_adr :: Signal Table -> Address if i understand correctly
21:29:33 <dfranke> gah, this sucks.  There's got to be a ghc-6.8 documentation bundle accessible somewhere.
21:30:53 <SamB_XP> @google ghc docs 6.8
21:30:55 <lambdabot> http://koji.fedoraproject.org/koji/buildinfo?buildID=19881
21:30:56 <lambdabot> Title: Build Info | Koji
21:32:03 <Karle> oerjan, Int into Address... what actually you mean?
21:33:04 <oerjan> well, you have type Table = [(Int,Port)]
21:33:12 <Karle> yes
21:33:13 <oerjan> so why not use that in the signatures too
21:34:50 <Karle> i know what you mean now
21:36:19 <Karle> oerjan, some complaints
21:36:21 <Karle> ERROR file:.\switch_syn.hs:101 - Type error in right hand side
21:36:21 <Karle> *** Term           : fromSignal s
21:36:21 <Karle> *** Type           : [[(Int,Port)]]
21:36:21 <Karle> *** Does not match : AbstExt [(a,b)]
21:37:30 <oerjan> oh right
21:37:50 <oerjan> what is the type you _want_ pick_adr to have?
21:38:00 <Karle> Int
21:38:07 <oerjan> the whole type
21:38:11 <oerjan> not just the result
21:38:14 <Karle> it will return Int
21:38:28 <oerjan> not just the result
21:38:37 <Karle> pick_adr:: Signal [(Int,Port)]-> Address
21:39:05 <oerjan> remove the Prst
21:40:09 <Karle> ERROR file:.\switch_syn.hs:101 - Type error in right hand side
21:40:09 <Karle> *** Term           : fromSignal s
21:40:09 <Karle> *** Type           : [[(Int,Port)]]
21:40:09 <Karle> *** Does not match : [(a,b)]
21:40:38 <oerjan> oh
21:40:51 <oerjan> what is the type of fromSignal?
21:41:27 <Karle> fromSignal :: Signal a -> [a]
21:41:51 <oerjan> so you get a list of lists...
21:42:20 <oerjan> (((a,_):_):_) = fromSignal s
21:42:21 <Karle> and my Address is INT
21:42:30 <Karle> Int
21:42:38 <oerjan> i know
21:44:12 <Karle> what does it do (((a,_):-
21:44:21 <oerjan> i find it a bit weird that you actually want this function, it seems to pick the first address (if any) from the first table (if any) in the list of tables produced by the signal
21:44:27 <Karle> the expression
21:44:35 <oerjan> it's a pattern match
21:45:20 <Karle> thanks... I think maybe I do not need this function at all
21:45:24 <Karle> :)
21:45:33 <Karle> I am a newbie in programming too
21:45:38 <oerjan> ic
21:45:45 <Karle> it has been a long time
21:46:01 <Karle> I have been working in analog design for many years
21:46:37 <oerjan> oh, well, then at least you should understand signals :D
21:47:16 <Karle> hehe :)
21:50:07 <oerjan> if this Signal thing is anything like the monads/comonads/arrow sort of stuff that tends to crop up in haskell, then my intuition says you rarely want to convert Signals into lists except at the very top of the program, when using the system you have made
21:50:42 <oerjan> so that makes the pick_addr function somewhat dubious.
21:51:17 <Karle> i see
21:52:20 <Karle> well......... It is almost 6 am
21:52:37 <oerjan> here too
21:52:49 <Karle> gotta to sleep a bit before continuing with my small project again
21:52:56 <Karle> Where are you from oerjan?
21:53:05 <oerjan> norway
21:53:15 <Karle> I am from Sweden
21:53:23 <Karle> not really I live here
21:53:35 <oerjan> i thought i heard shapr speak swedish to you a while ago
21:53:50 <Karle> i did not catch it
21:54:04 <Karle> shapr is from Sweden
21:55:07 <allbery_b> <shapr> Karle: Det √§r inte s√• roligt p√• engelska.
21:55:07 <allbery_b> <shapr> er, p√• svenska
21:55:23 <Karle> just det
21:55:29 <allbery_b> ~2h ago
21:55:32 <allbery_b> @seen shapr
21:55:33 <lambdabot> shapr is in #scannedinavian, #xmonad, #haskell-blah, #haskell and #ghc. I last heard shapr speak 2h 11m 54s ago.
21:55:46 <Karle> I have been busy with the project
21:55:51 <oerjan> that a question?  i am not quite sure if he is from there (his name is Shae Erisson, which doesn't sound quite swedish to me) or if he has just lived there a long time
21:56:10 <allbery_b> he lived there for a while and thenmoved back to the US
21:56:14 <allbery_b> IIRC
21:56:30 <Karle> i see
21:56:35 <allbery_b> and, "Ericsson"
21:57:08 <oerjan> er, his ircname says Erisson
21:57:31 <allbery_b> hm.  I *think* that is a typo.  not certain
21:57:45 <Karle> great ... very nice chatting with you guys ... I got a lot of help
21:57:56 <allbery_b> form of name does strike me as Scandinavian though
21:58:12 <oerjan> yes, it's really the "Shae" which doesn't fit
21:58:16 * allbery_b should go to bed anyway
21:58:17 <ddarius> :t min
21:58:19 <lambdabot> forall a. (Ord a) => a -> a -> a
21:58:34 <ddarius> His name is Erisson
21:58:48 <Karle> me too...... thanks everyone .... very much to you , oerjan
21:58:50 <ddarius> He's from Alabama
21:59:46 <oerjan> his middle name Matijs sounds Dutch
22:00:22 <Karle> bye
22:00:26 <oerjan> bye
22:06:11 <ddarius> His birth name was Robert Benjamin Gilliam.
22:07:04 <scook0> is this #haskell or #shapr? ;)
22:09:52 <ddarius> scook0: The first user (in this incarnation) of #haskell was #shapr
22:09:54 <ddarius> er shapr
22:09:57 <ddarius> cripes
22:09:59 <oerjan> GHC.Conc.numCapabilities is Int, not IO Int? o_O
22:10:13 <ddarius> > GHC.Conc.numCapabilities
22:10:20 <lambdabot>   Not in scope: `GHC.Conc.numCapabilities'
22:10:27 <oerjan> i'm reading the 6.8.1 release notes :)
22:10:35 * wli ponders EfNet #haskell
22:11:04 <oerjan> like FreeNode #haskell, but without all the politeness and helpfulness?
22:11:30 <wli> Not quite the reason why.
22:11:33 * oerjan is just guessing on that.
22:11:33 <dmwit> oerjan: Presumably it's constant for the entire run of the program.
22:11:43 <dmwit> (?)
22:11:53 <oerjan> but nevertheless, it is not constant when compiling
22:12:19 <dmwit> Neither is
22:12:27 <dmwit> unsafePerformIO (readFile "foo")
22:12:44 <oerjan> i don't think that counts
22:13:14 <dmwit> Same idea; you want those things to be constant for a given run of the program (but not nececssarily between runs).
22:13:15 <oerjan> maybe stdin/stdout are better examples
22:16:29 <sjanssen> stdin/out/err are constants in Unix :)
22:16:36 <oerjan> it seems like something which could bite if you try to make haskell distributed, such that where a function runs could change.
22:16:53 <oerjan> or thread.
22:18:08 <sjanssen> well, all sorts of things will need to be reconsidered
22:18:46 <sjanssen> Ptr, Handle, maybe even maxBound :: Int are shaky under distribution
22:18:53 <dmwit> oerjan: Just so you know, I agree that it should be an IO Int... but I can see why they might make it an Int instead.
22:19:14 <oerjan> hm, true
22:20:28 <cpfr> hey
22:20:31 <oerjan> although i cannot see how you can move computations if fundamental data types are changing
22:20:57 <cpfr> is there a repository available of all the major papers that shaped developed in haskell
22:21:21 <oerjan> @where papers
22:21:21 <lambdabot> I know nothing about papers.
22:22:02 <P_D> I'm trying to build harpy in 6.8 and I'm getting a bunch of package is hidden errors on Text.PrettyPrint.HughesPJ, Data.Array.IArray, Data.Map and System.Cmd.  What's the right thing to modify to unhide / fix the build?
22:22:16 <allbery_b> the .cabal file
22:22:27 <sjanssen> P_D: you have to change the build-depends in the .cabal file
22:22:28 <cpfr> lambdabot help us!
22:22:29 <allbery_b> all those used to be in base
22:22:40 <oerjan> @go haskell papers
22:22:42 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/papers.html
22:22:42 <lambdabot> Title: Simon Peyton Jones: papers
22:22:52 <oerjan> not the worst place to start, i think
22:23:21 <P_D> sjanssen allbery_b: Thanks
22:24:15 <sjanssen> this is going to be such a huge FAQ for the next month or so...
22:25:07 <oerjan> @where base
22:25:07 <lambdabot> http://darcs.haskell.org/packages/base/
22:25:23 <cpfr> oerjan, if i just take papers written by the major fp theorists am i fine
22:25:54 <oerjan> @go haskell papers site:haskell.org
22:26:10 <lambdabot> Plugin `search' failed with: thread killed
22:26:12 <oerjan> eek
22:26:33 <oerjan> @go haskell papers
22:26:34 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/papers.html
22:26:34 <lambdabot> Title: Simon Peyton Jones: papers
22:26:38 <oerjan> @go haskell papers site:haskell.org
22:26:53 <lambdabot> Plugin `search' failed with: thread killed
22:26:55 <oerjan> google must actually ping the site? o_O
22:27:09 <P_D> sorry afor another silly question:  Flag for enabling forall style types?
22:27:31 * P_D awaits the return of haskell.org
22:27:34 <cpfr> haskell.org is gettting pounded pretty hard now
22:28:40 <oerjan> WE'RE HELPLESS!
22:29:59 <tessier> http://ansuz.sooke.bc.ca/bonobo-conspiracy/?i=786
22:30:01 <tessier> ROFLMAO
22:30:02 <lambdabot> Title: Bonobo Conspiracy Web comic #786: Lambada calculus
22:30:03 <tessier> That's great. :)
22:31:56 <oerjan> oh wait... i can look it up in hugs
22:32:02 <cpfr> @go haskell papers site:haskell.org
22:32:18 <lambdabot> Plugin `search' failed with: thread killed
22:33:56 <oerjan> or not.
22:35:47 <oerjan> P_D: try the --supported-languages flag
22:36:13 <P_D> -fglasgow-exts in every source file did the trick
22:36:21 <oerjan> (fortunately i have the release notes open in a window since earlier today)
22:36:44 <oerjan> oh.
22:37:47 <oerjan> btw i have the list of new packages in that window too if you need it.
22:38:56 <P_D> I've been having another problem that goes back to 6.6, and that's building FFIed stuff.  I've got a main in C and various code in haskell.  What I did with 6.6 was ghc -o x.exe x.cpp x.hs -lHSlib1 -lHSlib2 HSstaticlib.o etc.  6.8 makes this much less convenient as it moves each lib out into its own directory.  Does a correct (builtin) way to pull the libraries in exist?
22:41:15 <dons> you could link the libs together into a single archive, if you're doing that a lot
22:41:54 <P_D> that's more or less the same as dumping it into a makefile
22:42:55 <sjanssen> P_D: use -package
22:43:07 <sjanssen> P_D: assuming the libraries are registered with ghc-pkg
22:43:35 <P_D> sjanssen: fantastic, thanks
22:44:12 <sjanssen> can Cabal build executables where main() is in C?
22:44:41 <P_D> well ghc --make chokes on it
22:45:32 <P_D> great, I'm back up and running on 6.8, thanks again
22:47:53 <thetallguy> Anyone here familiar with the Debian packaging of Haskell libraries?
22:48:34 <thetallguy> I've got the ghc6-doc package installed, but it doesn't have the haddock docs for QuickCheck.  They don't seem to be in the libghc6-quickcheck-dev package, either.
22:48:59 <thetallguy> Anyone know where they might be?
23:07:26 <araujo> http://programming.reddit.com/info/5yigz/comments/c029tni
23:13:41 <Cale> @remember dons After Chuck Norris helped Simon Peyton Jones fix the bugs in the GHC type checker, GHC 12.5 can statically guarantee you get laid.
23:14:47 <oerjan> 12.5?  got a while to wait then.
23:20:42 <Olathe> The site works again :)
23:20:50 <Olathe> Sort of
23:22:30 <dfranke> I'm still timing out.
23:25:58 <glguy> Who has a mirrored src tarball they want to share :)
23:26:11 <dons> mm
23:27:09 <dfranke> glguy: I'll upload one, one sec.
23:28:33 <Olathe> Source: http://www.haskell.org/ghc/dist/6.8.1/ghc-6.8.1-src.tar.bz2 Extra-libs: http://www.haskell.org/ghc/dist/6.8.1/ghc-6.8.1-src-extralibs.tar.bz2 Windows: http://www.haskell.org/ghc/dist/6.8.1/ghc-6.8.1-i386-windows.exe
23:28:56 <glguy> Olathe: I wouldn't be asking in channel if the main mirror was available :)
23:29:14 <dfranke> glguy: http://dfranke.us/ghc-6.8.1-src.tar.bz2
23:29:17 <dfranke> extralibs is still uploading.
23:29:24 <glguy> thank you
23:29:41 <dfranke> done.  http://dfranke.us/ghc-6.8.1-src-extralibs.tar.bz2
23:30:08 <Olathe> I know. That's just for the people who are trying to get the page that tells them where the page that has links to the actual things.
23:30:22 <glguy> dfranke: done, thanks
23:30:47 <dfranke> glguy: k.  I'll leave it up there and see how much it takes to knock over Dreamhost :-)
23:31:30 <dfranke> probably considerably less than their advertised quotas.
23:33:03 * dfranke still needs a copy of the library docs, though
23:34:21 <dfranke> How long is this going to go on, I wonder?
23:34:58 <Olathe> Bah.
23:35:07 <dmwit> I'm helping by not attempting to get 6.8 from anywhere.
23:35:09 <dmwit> =)
23:35:16 <Olathe> It fails on Windows if the path to it has a space in it.
23:35:47 <dfranke> I'm helping by downmodding the announcement on Reddit :-)
23:35:54 <dmwit> heh
23:36:49 <dmwit> ?quote dfranke [on the haskell.org slowdown] I'm helping by downmodding the announcement on Reddit
23:37:01 <dfranke> so does anyone have a copy of the binary dist (any architecture)?
23:37:05 <Korollary> lol
23:37:12 * glguy wonders if compiling it on OS X requires any tricks
23:37:19 <oerjan> @botsnack
23:37:31 <dmwit> ?quote+ dfranke [on the haskell.org slowdown] I'm helping by downmodding the announcement on Reddit
23:37:43 <dfranke> glguy: I heard it's broken on Leopard.
23:37:43 <dmwit> Damn it, that's not the right command either.
23:37:46 <scook0> clearly lambdabot is too busy trying to download 6.8.1
23:37:59 <Olathe> @slap lambdabot
23:38:00 <oerjan> glguy: there were several comments here about problems with readline, iirc
23:38:03 <scook0> it's @remember, I think
23:38:07 <dmwit> scook0: Yeah.
23:38:13 <glguy> oerjan: You mean the same problems as 6.6.1?
23:38:16 <dmwit> Might as well wait until \bot responds to somebody, though. =)
23:39:16 <oerjan> something about readline meaning something different on Macs than elsewhere...
23:40:50 <glguy> I've got the GNUReadline and GMP frameworks installed
23:44:29 <dmwit> glguy: That's not the problem; apparently it sees the system's libreadline before your gnureadline install.
23:44:43 <dmwit> Somebody here said they solved it earlier, let's have a grep through the logs...
23:44:45 <Olathe> Bah, now I can't compile anything.
23:44:48 <glguy> yeah, you had to work around that in 6.6.1 too
23:45:23 <dmwit> glguy: Try pinging LoganCapaldo.
23:51:41 <scodil> > take 4 "ping"
23:53:39 <glguy> http://mult.ifario.us/articles/2006/10/17/ghc-6-6-and-mac-os-x-readline-quick-fix
23:53:43 * glguy found this
23:53:49 <glguy> don't know if it works yet
23:56:43 <dmwit> > maxBound :: Int
23:56:51 <dmwit> oh right
23:57:57 <darinm> glguy: I got it to compile that way, basically
23:58:18 <darinm> although when I try to run the compiled ghci I'm getting some error
23:58:38 <darinm> *shrug*.. too lazy to track it down.  Guess I'll wait for someone to put together a binary
