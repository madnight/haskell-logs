00:01:15 * omnId strips off his clothes and dances around the obviously empty room
00:02:02 * jql puts a new tape in the channel video recorder
00:05:01 <quicksilver> OK. Can anyone think of a Foldable that isn't a Functor?
00:05:11 <quicksilver> @instances-importing Data.Foldable Foldable
00:05:13 <lambdabot> Maybe, []
00:08:09 <quicksilver> I find a reddit post claiming that Set is not a Functor
00:08:14 <quicksilver> but I don't believe that to be true
00:08:26 <quicksilver> Sets are Functors, it's just our type system gets confused by the constraint
00:17:17 <hpaste>  omnId annotated "Compile-time evaluation" with "slightly less repetition." at http://hpaste.org/3584#a3
00:27:32 <scook0> quicksilver: you might say that set is a functor, but Set is not a Functor
00:27:51 <scook0> (in much the same way that Set is not a Monad)
00:35:38 <quicksilver> scook0: fair enough, but that's not what I want
00:35:49 <quicksilver> scook0: I'm wondering if there is anything foldable but not functorial
00:36:03 <quicksilver> scook0: cos I'm trying to understand why Functor isn't a pre-req for Foldable
00:36:31 <quicksilver> scook0: the best I can come up with so far is that the designers wanted fmap to commute with fold, and it doesn't do that in general...
00:36:50 <omnId> *CompileTime> length $(compileTimeIO (readFile "CompileTime.hs"))
00:36:50 <omnId> 1185
00:36:57 <omnId> \o/  small successes...
00:37:13 <uccus> hi,... does anyone have time to kill? :)
00:37:33 <uccus> I am looking at http://www.haskell.org/haskellwiki/Quantified_contexts
00:37:34 <lambdabot> Title: Quantified contexts - HaskellWiki
00:37:45 <uccus> and I am quite confused what it is about
00:38:42 <uccus> I mean, I am a newbie, and I don't understand contexts very well. can someone explain the proposal to me with enough examples for me to grasp it?
00:39:39 <omnId> uccus: it's really quite exotic.  Maybe not quite newbie material.
00:40:16 <uccus> that's what I thought to. but I would like to know anyway.
00:40:24 <quicksilver> uccus: if you're happy with Monoid and Monad, then the simplest exacmple is the MonadPlus one.
00:41:10 <quicksilver> which says "If m is a monad, and 'm a' is a monad for all possible types a, then m is a MonadPlus'
00:41:21 <uccus> all of Monoid, Monad and MonadPlus are well-defined typeclasses, without worrying so much about the context, right? I mean, what does "context" mean in this context? :)
00:41:25 <omnId> monoid* for the second one
00:41:48 <quicksilver> thanks omnid
00:41:49 <quicksilver> stupid fingers
00:41:58 <quicksilver> which says "If m is a monad, and 'm a' is a monoid for all possible types a, then m is a MonadPlus'
00:41:58 <uccus> no worries
00:42:00 <omnId> monad is a familiar finger macro, yes :)
00:42:13 <quicksilver> uccus: the point is to specify classes using more complex rules
00:42:20 <quicksilver> such as embedding 'for all possible types' in a rule
00:42:25 <quicksilver> which currently we can't do
00:42:44 <uccus> what about Monoid (m a)? doesn't it say "for all possible types"?
00:42:57 <quicksilver> it does, but you can't embed it into a larger context
00:43:18 <uccus> that's ... umm ... why I wanted to know what context means here
00:43:51 <uccus> I think it goes somewhat like this... qsort :: (Ord a) => [a] -> [a]
00:43:52 <omnId> context means typeclass restrictions on a type variable (to a first approximation...)
00:44:08 <omnId> (Ord a) => is the context of that type.
00:44:13 <uccus> here Ord says elements of the list much be comparable
00:44:34 <uccus> right... so what is this larger context you are talking about?
00:44:56 <salierix> I can't seem to compile the cabal package for binary-0.4.1
00:45:04 <salierix> It says: Setup.lhs: binary.cabal:22: Invalid syntax (no colon after field name)
00:45:33 <omnId> guard :: (Monad m, forall a. Monoid (m a)) => Bool -> m ()
00:45:50 <omnId> that says 'm' is a monad, and 'm a' is a monoid regardless of 'a'.
00:46:23 <uccus> oooooh!
00:46:26 <uccus> I get it!
00:46:45 * uccus thinks
00:47:00 <omnId> I don't know how you would assert the monoidness of 'm a' though.  I'm not sure what the instance(s) would look like.
00:47:06 <omnId> quicksilver?
00:48:23 <uccus> then, for a specific monad m, you have to _ensure_ that Monoid (m a) is defined where a is free... that is... the declaration should be like Monoid (SomeMonad a) rather than Monoid (SomeMonad Bool)? is the second a valid declaration anyway?
00:49:02 <omnId> instance Monoid [a] where mempty = []; mappend = (++) -- something like this I think.
00:50:00 <uccus> which brings me to the stupid question... can I declare instance Monoid [Bool] where ...?
00:50:10 <omnId> uccus: not in H98.
00:50:29 <uccus> then what good is guard :: (Monad m, forall a. Monoid (m a)) => Bool -> m ()?
00:50:58 <omnId> say you had an instance Class (Either Int b) and instance Class (Either a String).  If you had an Either Int String, which instance would it use?
00:51:05 <uccus> oh.. I see what you mean. does that declaration have to do anything with overlapping instances or ...
00:51:52 <uccus> so I can enable this kind of declarations with overlapping instances?
00:52:04 <omnId> not sure which specific extension it is.
00:52:08 <uccus> making sure myself that such ambiguities would not arise?
00:52:14 <omnId> FlexibleInstances I think.
00:52:23 <uccus> ok... the specific of the instances is not my concern :)
00:52:38 <omnId> you're talking about the proposal?
00:53:05 <omnId> I don't think quantified contexts is implemented anywhere.
00:53:18 <uccus> no I was talking about the idea of not being able to decide which instance it should use
00:53:49 <uccus> so I think I'm not out-of-track yet
00:54:27 <omnId> Printf uses an IsChar class having just Char to get around this:  instance IsChar c => PrintfResult [c] where ...
00:54:41 <uccus> so do you have any idea whether quantified context (the proposal) can solve problems or express things more efficiently than the other extensions?
00:54:56 <omnId> *shrug*  It is interesting.
00:55:39 <uccus> well... 8-) it _looked_ interesting to me... but I couldn't find anything anywhere on it
00:56:17 <uccus> not on the wiki, not on the mailing list... so I thought it is not worth investigating :s
00:57:07 <uccus> [so the only instance of IsChar is Char?]
00:57:20 <uccus> [but no rule ensures that?]
00:57:24 <omnId> yep, and the methods are not exported, so you can't make any more instances
00:57:39 <uccus> thanks omnId for your help
00:58:02 <omnId> sure
01:00:50 <EvilTerran> with fundeps, "class IsChar c | -> c where ..." would have the effect of saying "c is uniquely determined (by nothing)", so would prevent other instantiations. dunno if they did that, though.
01:01:28 <omnId> Printf is all H98
01:01:38 <scook0> EvilTerran: is that actually valid, or are you speculating?
01:01:50 <EvilTerran> it's valid fundeps, iirc
01:01:55 <scook0> creepy
01:02:11 <quicksilver> show uses ShowList for a similar kind-of reason
01:02:17 <quicksilver> not exactly the same
01:02:34 <omnId> ShowList?  you mean showList?
01:02:36 <quicksilver> but to get around instance limitations
01:02:38 <scook0> quicksilver: for special-casing strings, you mean?
01:02:50 <uccus> actually judging from the general vibe I thought fundeps are conceptually problematic and decided not to study them at all. bad decision?
01:03:06 <scook0> simple fundep stuff is fine
01:03:18 <EvilTerran> they'll be (mostly) superseded by type families fairly soon, i think
01:03:25 <uccus> I think I understand simple fundeps
01:03:29 <omnId> the cool thing is they give you a prology language in the type system!
01:03:30 <quicksilver> uccus: fundeps in isolation are not really problematic. What's problematic is writing a compiler which can decide if your program satisfies a set of fundeps :)
01:03:43 <uccus> but didn't have the guts to go out and look for complex ones :)
01:03:46 <scook0> once type families get a stable release, fundeps will be much less interesting for most purposes
01:04:13 <omnId> so many different type system features...
01:04:23 <quicksilver> because fundeps simply declare an intention (I want b,c to depend on a,e) but don't indicate why that should be true.
01:04:39 <quicksilver> so the compiler has to try to check if you're "playing by the rules" of your own fundeps.
01:05:22 <scook0> do fundep problems only arise when monkeying with overlapping instances, and the like?
01:05:34 <scook0> or do fundeps alone constitute a hairy problem?
01:05:53 <quicksilver> there is a very simple elegant criterion for fundeps
01:06:03 <quicksilver> the Coverage Condition, basically
01:06:22 <quicksilver> which says that if a -> b, the type of b must actually "mention" a in some concrete way
01:06:29 <quicksilver> e.g. b = [a]
01:06:33 <EvilTerran> fundeps are (almost) entirely to restrict polymorphism in situations where it'd never be valid and would require explicit typing otherwise
01:06:36 <quicksilver> then it's obvious that a -> [a]
01:06:46 <uccus> omnId said: "the cool thing is they give you a prology language in the type system!" which is cool, I agree, and can it by done with type families as well?
01:06:48 <quicksilver> because there is exactly one type [a] for each type a
01:07:18 <quicksilver> however, it turns out that whilst the coverage condition is simploe and fairly elegant
01:07:30 <quicksilver> it's not sufficient to write lots of useful programs :(
01:07:38 <quicksilver> in particular, it's not sufficient to write the mtl
01:07:48 <quicksilver> which is a key motivational library for MPTCs.
01:08:03 <uccus> monad transform library? what does MTL mean?
01:08:09 <omnId> correct
01:08:42 <uccus> once again... do type families give me a "prology language in the type system" as well?
01:08:56 <quicksilver> no, I don't believe they do
01:09:10 <uccus> and when you said, a "prology language in the type system" did you mean just fundeps or MPTCs?
01:09:11 <quicksilver> unless it's embedded slightly deeply and non-obviously
01:09:15 <omnId> I think it's more Haskelly, but I know basically nothing about 'em.
01:09:36 <quicksilver> of course, typeclass constaints them selves are prologgy.
01:09:39 <omnId> MPTCs + fundeps
01:09:50 <uccus> was that desirable in any way? having a copy of the language in the type level?
01:09:54 <quicksilver> but constraint resolution is a very simple and obviously terminating bit of rpolog
01:10:05 <quicksilver> it's just counting sets, really :)
01:10:36 <uccus> I guessed that... :) connection with prolog that is...
01:10:46 <uccus> good to know it makes sense to you too
01:11:37 <uccus> so are type families less expressive? more expressive? not directly comparable to fundeps?
01:11:50 <quicksilver> Incomparable.
01:11:53 <quicksilver> I think.
01:11:59 <quicksilver> That is, both less expressive and more expressive.
01:12:03 <EvilTerran> intersecting, but neither is a superset
01:12:20 <uccus> then do they have any good theoretical property over fundeps?
01:12:33 <quicksilver> It is widely hoped that the things you can do with fundeps but not with ~ATFs are not interesting.
01:12:37 <quicksilver> I'm not sure if that's true.
01:12:39 <uccus> aaargh my English sucks
01:13:00 <quicksilver> uccus: Yes, they don't need some horrible and ahrd to explain conditions to terminate :)
01:13:07 <omnId> uccus: you're not native?  Couldn't tell.  :)
01:13:17 <uccus> hehehe... thanks
01:13:31 <quicksilver> Also, may people think they are easier to understand. I think.
01:13:59 <uccus> but I thought you said deciding fundeps are not so hard either!
01:13:59 <omnId> many*,  heh, typos afflict you regardless of nativeness :)
01:14:09 <EvilTerran> some natives' English sucks too, mind ;)
01:14:20 <omnId> kno it duzzint
01:15:03 <uccus> so fundep checking is not guaranteed to terminate?
01:16:37 <EvilTerran> it is, as long as you don't use it with UndecidableInstances
01:16:48 <uccus> makes sense
01:16:48 <EvilTerran> but that applies equally to normal typechecking
01:16:56 <uccus> thanks a lot guys
01:18:17 <omnId> EvilTerran: that particular sentence looks wrong, but I'll be darned if I could phrase it correctly.
01:18:42 <EvilTerran> "it's not the fundeps that might make typechecking diverge, it's the undecidable instances"
01:18:44 <omnId> "some natives' Englishes such too"?
01:18:50 <omnId> suck*
01:19:12 <EvilTerran> oh, right, that one. "some natives suck at English too" would work.
01:19:22 <omnId> that's no fun :)
01:19:35 <omnId> gotta have the plural possessive.
01:19:47 <EvilTerran> "I'm a native, and my English sucks" :P
01:20:56 <quicksilver> n the sentence "your English is better than my English" how many Englishes are there? :)
01:21:03 <omnId> two
01:21:08 <omnId> :P
01:21:12 <quicksilver> it has a capital letter, so presumabl there is only one of it, but...
01:21:45 <omnId> there are two "English"es.  And yes that's a plural quotation.
01:22:08 <quicksilver> Yeah. There are two "English"es. But htat's not what I asked :)
01:22:37 <osfameron> I usually say "english" if I'm not speaking about the UK english
01:23:00 <osfameron> (which is the usage from The Empire Writes Back, a classic on postcolonial literary theory :-)
01:23:11 * omnId speakes teh olde Angle-ish.
01:23:11 <quicksilver> Thre is something odd about Traversable.
01:23:26 <quicksilver> If Functor gives you 'fmap', and Foldable gives you mapM_
01:23:44 <quicksilver> intuitively it feels like you should be able to derive mapM from those two
01:23:55 <quicksilver> you have effects without values, and values without effects
01:24:05 <quicksilver> seems like you should be able to get both at once without an extra method
01:24:08 <quicksilver> but you can't...
01:24:13 <ricky_clarkson> I speak English English.
01:24:14 <quicksilver> I can't put my finger on why not
01:25:35 <omnId> @. id @ @run unwords . filter (all isUpper) . words $ @show @yow
01:25:37 <lambdabot>   "I KEN PAYMENTS NERVOUS BREAKDOWN"
01:27:14 <quicksilver> null (a \\ b) is permutation-ignoring equality for lists, isn't it?
01:27:23 <quicksilver> hmm
01:27:35 <quicksilver> null (a \\ b) && null (b \\ a) perhaps
01:28:15 <quicksilver> I'm trying to pull together a haskellwiki article on Foldable and Traversable. It's more fiddly than I expected.
01:31:06 <scook0> quicksilver: I assume you're aiming for something more class-general than (==) `on` sort
01:33:16 <quicksilver> scook0: maybe. My version is O(n) not O(n log n) too. Seemed more elegant.
01:33:33 <quicksilver> scook0: but yes, I'm exploring the lines between the varioius 'coollection' types
01:34:48 <scook0> [Snow, IceCubes] :: Coollection ;)
01:35:44 <scook0> hmm, how is yours O(n)?
01:36:02 <scook0> seems more like O(mn)
01:36:45 <omnId> *CompileTime> $(compileTimeEval ('a','b'))
01:36:45 <omnId> ('a','b')
01:36:51 <omnId> HOLY CRAP I PULLED IT OFF!
01:37:12 <omnId> one more type down...
01:37:28 <omnId> well, many more types anyway, all the tuples.
01:38:17 <quicksilver> scook0: ah, ood point. Me stupid :)
01:45:28 <omnId> many people ask if GHC will evaluate toplevel constants at compile time, you know, since Haskell is pure it'd be great if those computations could be done once and not use cycles when running.  With my compileTimeEval, arbitrary expressions do just that, they get evaluated and the expanded expression is spliced in.
01:45:42 <omnId> s/when running/during runtime/
01:46:03 <aleator> @seen dcoutts
01:46:03 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 17h 24m 39s ago.
01:46:08 <aleator> @seen dcoutts_
01:46:08 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 1d 12h 39m 56s ago.
01:46:42 <omnId> so if you had some data in a file just out of convenience, you could say: data = $(compileTimeIO $ parseFile $ readFile "data.txt")
01:48:11 <omnId> anyway I think it's awesome.
01:48:26 <scook0> omnId: that's pretty shiny
01:49:05 <quicksilver> omnId: it is awesome
01:49:12 <omnId> somewhat fragile, though.  The boundary between Data.Generics and Template Haskell is kinda borked.
01:49:37 <quicksilver> omnId: you should post ot to the cafe
01:49:45 <hpaste>  omnId annotated "Compile-time evaluation" with "find errors for me :)" at http://hpaste.org/3584#a4
01:50:19 <omnId> quicksilver: do I have to sign up or just email somewhere?
01:50:46 <quicksilver> omnId: erm, you probably can't post if not subscribed, I guess
01:50:49 <omnId> copy/paste into CompileTime.hs, load into ghci, :set -fth, play around with the splices.
01:51:03 <quicksilver> omnId: but you can subscribe and opt not to receive email messages
01:51:40 <omnId> oops, pasted the code in the middle of a change.
01:53:04 <hpaste>  omnId annotated "Compile-time evaluation" with "that was dumb :)" at http://hpaste.org/3584#a5
01:53:31 <omnId> I think I will post to -cafe@, but maybe tomorrow.
02:07:23 <omnId> gmapQ is still somewhat magical to me, though :)
02:14:15 <ricky_clarkson> I just watched the sicp lecture where they introduced memoisation.
02:14:58 <ricky_clarkson> Is there a way of implementing that without side effects?  I realise Haskell does it anyway, thanks to laziness.
02:15:33 <therp> ricky: http://www.haskell.org/haskellwiki/Memoization
02:15:35 <lambdabot> Title: Memoization - HaskellWiki
02:15:39 <therp> yes there is
02:16:02 <therp> there is even a memoizing fix point operator
02:18:54 <ricky_clarkson> Why is Memoizable needed?  I'd think you could memoise anything.
02:20:04 <Syzygy-> DRMacIver: You still alive?
02:20:40 <DRMacIver> Syzygy-: No.
02:20:47 <Syzygy-> Good to hear.
02:20:51 <DRMacIver> On grounds of it being morning. :)
02:20:54 <DRMacIver> How goes?
02:21:00 <Syzygy-> Just fine.
02:21:09 <Syzygy-> Started tapping away at a thesis.
02:21:17 <Syzygy-> sqrt sends her regards too.
02:21:21 <Syzygy-> We kinda miss you.
02:24:12 <DRMacIver> Aww
02:24:15 <DRMacIver> I suppose I could fix that. :)
02:31:38 * wli is a very happy camper.
02:32:34 <scook0> @hoogle multiparam
02:32:35 <lambdabot> Distribution.Extension.MultiParamTypeClasses :: Extension
02:33:01 * wli sings the praises of cabal, hackage, HSSL, ghc-6.9, et al.
02:56:39 <ttfh> if i make a "newtype" from a monad and use "deriving Monad", is there a nifty way to get a lifting function for my new monad?
02:59:00 <scook0> ttfh: isn't that just your constructor?
02:59:53 <ttfh> scook0: hmm, yes
03:00:24 <ttfh> :-)
03:02:50 <ttfh> hmm, I had two "returns" after one another inside a do-block, it was confusing
03:03:39 <ttfh> I keep writing code that works, but I don't know what's going on...
03:05:24 <aleator> dcoutts: ayt? I've got some criticisms of gtk2hs after a week of use.
03:05:52 <scook0> @seen dcoutts
03:05:52 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 18h 44m 28s ago.
03:14:38 <omnId> http://programming.reddit.com/info/5zo1o/comments/
03:14:40 <lambdabot> Title: programming: Compile-time evaluation in Haskell
03:21:44 <quicksilver> ricky_clarkson: the reason memoization isn't enabled universally is it is a pessimisation
03:21:54 <quicksilver> ricky_clarkson: it transforms programs into exponentially slower ones
03:22:06 <quicksilver> that's not considered a useful feature, as a rule.
03:22:24 <ricky_clarkson> Because the memos stay around too long?
03:22:45 <quicksilver> ricky_clarkson: I was exagerrating for effect, of course :) Sometime's its an optimisation.
03:22:48 <quicksilver> but, yes, that's exactly it.
03:22:59 <ricky_clarkson> Could you have some kind of weak memo then?
03:23:02 <quicksilver> It's a very hard problem to decide when to throw the memos away.
03:23:13 <quicksilver> What would be your weakness criterion?
03:23:35 <ricky_clarkson> Cache misses. ;)
03:23:47 <quicksilver> for example, there are a whole load of algorithms which run over a list in constant space
03:24:01 <quicksilver> because they discard list elements when done, and produce new ones only as needed
03:24:09 <quicksilver> careless globali memoisation breaks that.
03:24:13 <ricky_clarkson> Does Haskell always regenerate the elements?
03:24:16 <ricky_clarkson> ..of a list
03:24:47 <quicksilver> haskell saves stuff when you keep references around
03:24:53 <quicksilver> it GC's it when you don't
03:25:07 <quicksilver> memoization strategies by their very nature keep references around.
03:25:15 <ricky_clarkson> Ok, so the naive fibonacci will always be very slow in Haskell?
03:25:16 <quicksilver> the hard decision is 'how long' :)
03:25:38 <quicksilver> ricky_clarkson: no, the naive fibonacci only references 3 cells at a time
03:25:46 <quicksilver> ricky_clarkson: it only keeps alive references to the last two
03:26:15 <quicksilver> so it runs in constant space
03:26:40 <ricky_clarkson> By naive I mean the one that does no explicit caching/memoisation.
03:27:05 <quicksilver> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:27:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:27:12 <quicksilver> that one?
03:27:35 <scook0> I'm looking for a way to (polymorphically) generate a random number 0 <= a < n
03:27:48 <scook0> so far the best I've found is 0 <= a <= n, any ideas?
03:27:50 <ricky_clarkson> @unpl 1 : 1: zipWith (+) fibs (tail fibs) in fibs
03:27:50 <lambdabot>  Parse error at "in" (column 37)
03:27:59 <omnId> randomR (0, n - 1)
03:28:09 <ricky_clarkson> @unpl 1 : 1: zipWith (+) fibs (tail fibs)
03:28:10 <lambdabot> 1 : 1 : zipWith (+) fibs (tail fibs)
03:28:12 <scook0> omnId: that only works for integral types, sadly
03:28:17 <omnId> oh, (<) including [n-1..n)
03:28:28 <scook0> ideally I need something that works for floats as well
03:28:51 <ricky_clarkson> quicksilver: No, one that just calculates one value.
03:28:52 <pastorn> @let fibs = 1 : 1: zipWith (+) fibs (tail fibs)
03:28:54 <omnId> Float's randomR might be left-closed
03:29:01 <pastorn> @unpl fibs
03:29:03 <lambdabot> Defined.
03:29:03 <lambdabot> fibs
03:29:07 <pastorn> nice...
03:29:14 <quicksilver> ricky_clarkson: eh? that calculates all the values?
03:29:14 <scook0> according to the docs it's unspecified
03:29:28 <quicksilver> ricky_clarkson: I don't know what you mean by 'one value'
03:29:38 <scook0> i.e. the caller must be prepared to accept both endpoints, but the implementation isn't obliged to ever return either
03:29:56 <quicksilver> scook0: if you consider the floats to be continuous then the probability of getting an endpoint is zero anyway, so who cares? :)
03:29:56 <scook0> which is a pretty crummy spec, if you ask me
03:30:05 <ricky_clarkson> quicksilver: (Num a) => a->a
03:30:25 <wli> ricky_clarkson: http://hpaste.org/1945 does no memoization or caching
03:30:29 <quicksilver> ricky_clarkson: you want ot calculate the nth term in the fibonaccis sequence
03:30:30 <wli> > let { fib :: Int -> Integer ; fib n = let { fib' (f, g) p | p = (f*(f+2*g), f*f+g*g) | otherwise = (f*f+g*g, g*(2*f-g)) } in snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] } in fib 99
03:30:31 <quicksilver> ricky_clarkson: ?
03:30:32 <lambdabot>  218922995834555169026
03:30:40 <ricky_clarkson> quicksilver: Yes.
03:30:51 <quicksilver> ricky_clarkson: well then I don't know what you mean by the 'obvious naive algorithm'
03:30:53 <scook0> quicksilver: the problem is finding something that works for both integers and floats
03:31:03 <quicksilver> if you mean fibs n = fibs (n-1) + fibs (n-2)
03:31:06 <scook0> without additional typeclasses
03:31:08 <ricky_clarkson> ..and more importantly, to know whether Haskell would always do this slowly.
03:31:17 <quicksilver> then yes, that doesn't memoize anything
03:31:43 <ricky_clarkson> Is there a reason the language doesn't memoise for things like that?
03:31:49 <quicksilver> yes
03:31:53 <quicksilver> because it is a very stupid thing to do
03:31:55 <wli> ricky_clarkson: You can't always expect compilers to rewrite your algorithms for you. Sometimes you will actually have to do algorithmic work.
03:31:56 <quicksilver> :)
03:32:02 <quicksilver> that's what I was saying to start with
03:32:06 <EvilTerran> alternatively, it would be a very clever thing to do
03:32:14 <quicksilver> memoizing all functions slows down your code absurdly
03:32:18 <ricky_clarkson> wli: Sure, but for simple cases the compiler could do it.
03:32:18 <EvilTerran> but to the point of being too difficult for any current compiler to do it well
03:32:27 <quicksilver> the clever thing is to decide which ones are worth memoizing
03:32:34 <quicksilver> but that's really very hard
03:32:37 <ricky_clarkson> quicksilver: I'm only suggesting that the compiler could decide itself.
03:32:45 * quicksilver nods
03:32:49 <quicksilver> it's a sensible suggestion
03:32:53 <quicksilver> it's extremely hard to do
03:33:03 <quicksilver> feel free to design an algorithm :)
03:33:04 <ricky_clarkson> Would it be easier for a JIT to do?
03:33:26 <quicksilver> if you had enough static analysis power to know in advance how often a function is called and on what parameters
03:33:33 <quicksilver> then you can compute a static table up front :)
03:33:42 <quicksilver> but interesting programs aren't generally amenable to that analysis
03:34:14 <wli> ricky_clarkson: Try out the fib implementation I pasted. It should do rather well.
03:34:32 <quicksilver> wli: it is rather clever but it's not really getting to ricky_clarkson's point :)
03:34:52 <quicksilver> wli: we're talking about memoization in general with fibs as an example, not fast algorithms for fibs :)
03:35:21 <ricky_clarkson> So you still have to explicitly decide whether to memoise, ok.
03:35:45 <quicksilver> ricky_clarkson: for comparison, the function "fibs n = let list_fibs = (zipwith definition) in list_fibs !! n" keeps a memo around for a single call
03:36:03 <quicksilver> so when calculating fibs n, it only calculates each of fibs 1 .. fibs (n-1) once each
03:36:11 <quicksilver> but it doesn't memoize between calls
03:36:35 <quicksilver> meanwhile if you hoist 'list_fibs' up to the top level it lasts forever
03:36:40 <ricky_clarkson> I don't understand that implementation but I think I understand you.
03:36:43 <quicksilver> so it will never be collected
03:37:09 <wli> quicksilver: It's a bit more than clever, actually. You may find it interesting compare it to all extant implementations.
03:37:41 <ricky_clarkson> Hmm, I always thought extant was a typo.. seems not.
03:37:48 <DRMacIver> It sometimes feels like the instance on referential transparency really hinders code reuse. I'm wondering about the following example: I have a [IORef Int]. I want to sort this by the current values of the contents. Obviously this should have type [IORef Int] -> IO [IORef Int]. But I can't use sortBy because there's no transparent way of doing "order by the current value", even though the underlying logic should be exactly the same.
03:38:00 <DRMacIver> Am I looking at things the wrong way?
03:38:09 <wli> quicksilver: To compare it to all extant Haskell implementations, that is. ;)
03:38:38 <DRMacIver> (I know I can use unsafePerformIO to wrap this so that it 'works', but I don't think that invalidates my point)
03:38:47 <quicksilver> DRMacIver: you aren't looking at it the wrong way, no
03:38:49 <quicksilver> DRMacIver: it's a fair point
03:39:00 <quicksilver> DRMacIver: you can write 'sortByM' though
03:39:01 <omnId> @type readIORef
03:39:10 <lambdabot> Not in scope: `readIORef'
03:39:24 <scook0> DRMacIver: you should be able to do a decorate-sort-undecorate
03:39:25 <quicksilver> DRMacIver: such that sortByM (liftM2 (<)) does what you want
03:39:42 <quicksilver> scook0: no, he can't. It can never be sort.
03:39:45 <omnId> @type liftM sort . mapM readIORef
03:39:46 <lambdabot> Not in scope: `readIORef'
03:39:52 <omnId> @type liftM sort . mapM Data.IORef.readIORef
03:39:53 <lambdabot> forall a. (Ord a) => [GHC.IOBase.IORef a] -> IO [a]
03:40:03 <scook0> quicksilver: not even with a monadic decorate?
03:40:10 <quicksilver> scook0: because there is no way you can turn sort into a kleisli
03:40:19 <quicksilver> I don't think
03:40:21 * quicksilver ponders
03:40:21 <DRMacIver> quicksilver: Yes, I know. And that's probably what I'd end up doing. But that still means you need monadic and non-monadic versions of all the functions you want to use this way.
03:40:24 <quicksilver> maybe there is, actually
03:40:28 <quicksilver> DRMacIver: Yes.
03:40:36 <quicksilver> DRMacIver: I agree with your suggestion that it's a limitation
03:40:50 <quicksilver> DRMacIver: it's hard to abstract over "possibly going via a type constructor
03:41:05 <quicksilver> DRMacIver: of course, sortByM is strictly more general
03:41:11 <quicksilver> DRMacIver: just use the identity monad for sortBy
03:41:22 <DRMacIver> Modulo unwrapping the newtyping for the identity monad, yes.
03:41:28 <quicksilver> right
03:41:59 <scook0> ideally you'd write everything monadically, and use the identity monad for normal code
03:42:04 <scook0> but that's obviously a pain
03:42:17 <quicksilver> but perhaps a pain which some compiler support could alleviate
03:42:20 <DRMacIver> Ideally ideally that would be inferred by the compiler. :)
03:42:32 <quicksilver> however, it's not entirely simple
03:42:36 <DRMacIver> Yeah.
03:42:38 <quicksilver> if you force me to write "sort" monadically
03:42:45 <quicksilver> you force me to choose the effect order at every level
03:42:48 <quicksilver> which is kind of boring
03:42:56 <quicksilver> and not something I'm interested in when I write a sorting algorithm
03:43:06 <scook0> or the compiler reconstructs a more-or-less arbitrary ordering for you
03:43:11 <ricky_clarkson> quicksilver: Does Haskell have a 'stream' thing as mentioned in sicp, with memoisation built in?
03:43:34 <DRMacIver> ricky_clarkson: It's called 'list' :)
03:43:36 <scook0> memoising stream ... isn't that just a lazy list?
03:43:48 <ricky_clarkson> Does list memoise?
03:44:36 <scook0> if you're passing around the same list thunk, laziness should take care of that, I think
03:44:36 <hpaste>  fox pasted "(no title)" at http://hpaste.org/3595
03:44:39 <DRMacIver> Strictly speaking, in Haskell 98 that's not guaranteed behaviour. However all major Haskell implementations are call by need (have I got that right?) so yes.
03:44:59 * ricky_clarkson is officially less baffled now.
03:45:35 <quicksilver> scook0: I was wrong. Sorry.
03:45:40 <scook0> the whole non-strict/lazy distinction
03:45:44 <scook0> quicksilver: on DSU?
03:45:49 <fox86> hmm, in the code that i pasted, should i make "readData" take an argument and then call it with "readData filename" instead? now i am treating the function "filename" as a "global var".. i'm not used to FP
03:45:57 <quicksilver> :t liftM (map fst . sortBy (comparing snd)) . mapM (\x -> Data.IORef.readIORef x >>= \v -> return (x,v))
03:45:58 <lambdabot> forall a. (Ord a) => [GHC.IOBase.IORef a] -> IO [GHC.IOBase.IORef a]
03:46:04 <scook0> quicksilver: I have a feeling I know why you thought it was impossible
03:46:08 <quicksilver> scook0: you can lift "sort" and that's how you do it :)
03:46:43 <scook0> the trick is that you have to know ahead of time all the I/O you want to do
03:46:58 <scook0> you can't have your sort function dictating what I/O happens (unless you do unsafe stuff)
03:48:40 <scook0> i.e. you can't pass a kleisli arrow to a function expecting a function, but you can pull the data out of the monad *first*, and perform pure operations on that
03:49:30 <scook0> (I figured this stuff out the hard way, not so long ago)
03:50:51 <fox86> http://hpaste.org/3595 ... should i make "readData" take an argument and then call it with "readData filename" instead? now i am treating the function "filename" as a "global var".. i'm not used to FP
03:51:05 <DRMacIver> Ah ha. I see. Thanks.
03:51:40 <scook0> fox86: well, it all depends on what you're actually looking to do
03:51:52 <scook0> but in that case, it's likely that filename should be a parameter, yes
03:52:03 <fox86> scook0: okay, thanks
03:52:15 <scook0> e.g. if you want to be able to specify the filename on the command line, or something
03:52:49 <scook0> at the moment it's completely hard-coded
03:53:26 <quicksilver> scook0: that's applicative style, in other words
03:53:37 <fox86> scook0: yes, i just want to make it easy to change the filename easily from within the code at the moment
03:53:40 <quicksilver> scook0: you can lift applicative stuff but not general monadic stuff?
03:54:05 <quicksilver> DRMacIver: solved your problem with a monadic Schwartzian transform :)
03:54:20 <scook0> uh, isn't all monadic stuff also applicative by implication?
03:54:25 <quicksilver> scook0: yes, definitely
03:54:25 <wolverian> perl coder detected!
03:54:37 <scook0> hey, I was going to call it schwartzian
03:54:46 <quicksilver> scook0: but my point is, to do this kind of lift your actual use of stuff has to be applicative only
03:54:46 <wolverian> oh, so it's spread? cool.
03:54:59 <quicksilver> scook0: you couldn't do the "kind of thing you can only do in a monad"
03:55:06 <scook0> wolverian: not really; I picked it up from perl folk ;)
03:55:12 <quicksilver> it has spread, I believe
03:55:16 <quicksilver> it's quite widely known
03:55:19 <wolverian> scook0, then you're one of the spreaders :)
03:55:22 <quicksilver> but I don't deny being a perl programmer
03:55:53 <wolverian> well, me neither.
03:55:54 <scook0> wolverian: Perl 6 folk, in fact
03:56:26 <DRMacIver> quicksilver: A what now?
03:57:08 <scook0> quicksilver: I remember formulating something in terms of "history-independent" monads
03:57:12 <wolverian> scook0, perl 6 integrated it, too: it has a sort that takes an extractor function instead of a comparator.
03:57:12 <scook0> but I forget the details
03:57:14 <quicksilver> http://en.wikipedia.org/wiki/Schwartzian_transform
03:57:15 <lambdabot> Title: Schwartzian transform - Wikipedia, the free encyclopedia
03:57:40 <quicksilver> DRMacIver: it's like "sortBy comparing f" but it saves the working of calling 'f' lots of times
03:57:42 <wolverian> scook0, e.g. what sortBy should be, I sometimes feel..
03:57:51 <quicksilver> DRMacIver: if f is expensive, you call it at most once per item
03:58:00 <viklund> Is there a highlevel function to beutify this:
03:58:16 <wolverian> scook0, of course it's not applicable (pardon the pun) to the monadic separation.
03:58:17 <viklund> > scanl (\a b -> divsum a) 220 (replicate 4 1)
03:58:21 <lambdabot>   Not in scope: `divsum'
03:58:27 <viklund> ;)
03:58:35 <quicksilver> scook0: I suspect your history-independent moands are actually applicatives. Interesting.
03:58:41 <scook0> wolverian: have you seen the on combinator?
03:58:50 <viklund> I don't want the second argument in the function from scanl...
03:58:57 <scook0> quicksilver: well, the only interesting example I found was Reader
03:59:02 <scook0> which I was trying to generalise from
03:59:07 <quicksilver> scook0: basically, an Applicative is a monad in which you could take 'sequence' as the primitive instead of >>=
03:59:08 <viklund> so the number of repititions is the length of the list...
03:59:21 <wolverian> scook0, I think so. where is it?
03:59:41 <quicksilver> scook0: i.e. if you promise to only do stuff using >> or sequence, but never >>= directly, that's applicative style.
03:59:52 <scook0> on bin proj x y = (proj x) `bin` (proj y)
04:00:07 <scook0> so you can do compare `on` snd
04:00:18 <scook0> or (+) `on` head
04:00:24 <scook0> or all manner of cool stuff
04:00:30 <wolverian> isn't that comparing
04:00:39 <scook0> wolverian: it's more general
04:00:41 <wolverian> oh, wait. right
04:00:42 <DRMacIver> quicksilver: Ah, right.
04:00:53 <scook0> I think (compare `on`) is comparing
04:01:21 <nornagon> :t on
04:01:22 <lambdabot> Not in scope: `on'
04:01:31 <scook0> quicksilver: my definition of "history-independent" was x >> y == y
04:01:43 <quicksilver> scook0: ah that's different
04:01:47 <scook0> but I never got a chance to think that deeply about it
04:01:59 <quicksilver> scook0: that's actually "side-effect free"
04:02:21 <wolverian> scook0, it's cool, but it doesn't do the schwartzian transform for you.. I'm trying to think how to generalise that
04:02:23 <quicksilver> (or, if you prefer, side-effects unobservable)
04:02:59 <wolverian> scook0, (that is, decorate-sort-undecorate)
04:02:59 <scook0> wolverian: it's only really relevant in the sense that it generalises comparing
04:03:03 <wolverian> right.
04:03:09 <quicksilver> scook0: closely related is 'commutative'
04:03:12 <scook0> and comparing + sortBy = schwartzian
04:03:24 <quicksilver> scook0: many commutative monads are side-effect free.
04:03:32 <quicksilver> all side-effect free monads are certainly commutative.
04:03:39 <wolverian> scook0, schwartzian transform implies caching the expensive computation
04:03:45 <pjd> when did "keyed sort" become "Schwartzian" :(
04:03:59 <wolverian> pjd, when us ugly perl coders got our hands on it! ha ha ha!
04:04:21 <scook0> ah, maybe I've been thinking sloppily
04:04:44 <scook0> you're right, comparing + sortBy != schwartzian
04:04:49 <quicksilver> semantically it is
04:04:54 <quicksilver> the different is only performance
04:04:56 <quicksilver> :)
04:05:05 <scook0> which is sort of the point :0
04:05:09 <quicksilver> right
04:05:11 <wolverian> heh
04:05:40 <scook0> I was subconsciously assuming that since the (parametric) types matched, the behaviour would be identical
04:05:47 <scook0> but it wasn't sufficiently identical
04:06:24 <scook0> actually, I have no idea what I was thinking at this point
04:08:00 <scook0> map (first decorate) >>> sortBy (comparing fst) >>> map fst
04:08:36 <quicksilver> ack! backward pipeline!
04:08:38 <quicksilver> ;)
04:08:55 <quicksilver> and my answer to DRMacIver's problem was the mapM / lift version of that
04:09:02 <scook0> the whole point of DSU being that you un-fuse the decorate from the sortBy
04:09:12 <wolverian> scook0, that's certainly tidier than map (\x -> (x, f x))
04:09:18 <scook0> arrows ftw
04:09:38 <quicksilver> I wonder if the IO arrow would be enough
04:09:49 <quicksilver> rather than using the IO monad as I did
04:10:00 <scook0> you'd have to Kleisli the reads
04:10:17 <quicksilver> :t readIORef
04:10:25 <quicksilver> :t Data.IORef.readIORef
04:10:26 <lambdabot> Not in scope: `readIORef'
04:10:26 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
04:10:31 <quicksilver> hmm
04:10:34 <quicksilver> they are kleisli?
04:10:43 <quicksilver> oh, I see, you mean the newtype constructor
04:10:44 * quicksilver nods
04:10:50 <quicksilver> that's what I meant by 'the IO arrow'
04:10:51 <scook0> it always annoys me that you can't use arrow combinators without newtype-ing kleislis
04:10:54 <quicksilver> 'Kleisli IO'
04:11:21 <scook0> quicksilver: I was more referring to the constructor
04:11:26 <quicksilver> I understand
04:12:17 <quicksilver> erm
04:12:23 <quicksilver> is there an arrow version of map?
04:12:36 <scook0> map in what sense?
04:12:48 <quicksilver> in the sense of "map (first decorate) >>> sortBy (comparing fst) >>> map fst"
04:13:12 <quicksilver> I'm trying to arrow-ize what I did before
04:13:22 <scook0> I think you'd Kleisli a mapM in IO
04:13:32 <quicksilver> ah
04:13:33 * quicksilver nods
04:13:38 <scook0> then pure the sort >>> undecorate
04:14:01 <scook0> "I think you'd Kleisli a mapM in IO" <-- I enjoyed that sentence
04:14:15 <quicksilver> :t (Kleisli (mapM Data.IORef.readIORef))
04:14:22 <lambdabot> forall a. Kleisli IO [GHC.IOBase.IORef a] [a]
04:15:18 <scook0> urk
04:15:20 <quicksilver> scook0: isn't your pipeline missing a 'dup'
04:15:21 <quicksilver> ?
04:15:28 <quicksilver> you have to \a -> (a,a)
04:15:32 <quicksilver> before you map (first decorate)
04:15:40 <scook0> yeah
04:16:00 <quicksilver> well perhaps map (decorate && id)
04:16:06 <quicksilver> well perhaps map (decorate &&& id)
04:16:07 <scook0> :t mapM (runKleisli (first $ Kleisli readIORef))
04:16:08 <lambdabot> Not in scope: `readIORef'
04:16:15 <scook0> :t mapM (runKleisli (first $ Kleisli Data.IORef.readIORef))
04:16:16 <lambdabot> forall d a. [(GHC.IOBase.IORef a, d)] -> IO [(a, d)]
04:16:48 <scook0> :t mapM (runKleisli ((Kleisli Data.IORef.readIORef) &&& pure id)
04:16:49 <lambdabot> parse error (possibly incorrect indentation)
04:17:00 <scook0> :t mapM (runKleisli ((Kleisli Data.IORef.readIORef) &&& pure id))
04:17:02 <lambdabot>     Ambiguous occurrence `pure'
04:17:02 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
04:17:02 <lambdabot>                           or `pure', imported from Control.Arrow
04:17:21 <scook0> :t mapM (runKleisli ((Kleisli Data.IORef.readIORef) &&& idA))
04:17:23 <lambdabot> Not in scope: `idA'
04:17:35 <quicksilver> nasty having to Kleisli and unKleisli around the mapM
04:17:51 <scook0> yeah, that's what I hate
04:18:07 <scook0> it would be easier if you made aliases k and rk
04:18:10 <quicksilver> :t Kleisli . mapM . runKleisli
04:18:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => Kleisli m a b -> Kleisli m [a] [b]
04:18:15 <quicksilver> that's what you want
04:18:18 <quicksilver> "mapMK"
04:19:15 <scook0> mapMK ((k readIORef) &&& arr id) -- something like that
04:19:27 <scook0> still pretty gross
04:20:23 <quicksilver> now, how do I lift 'sortBy' into my Kleisli IO [] ?
04:20:54 <vali> does haskell encourage top-down or bottom-up programming?
04:20:54 <scook0> arr?
04:21:03 <scook0> the rest of the computation is pure
04:21:10 <quicksilver> ah yes, of course
04:21:10 <quicksilver> thanks
04:21:17 <scook0> (which makes arrow-ing the first bit a waste of time, really)
04:21:25 <pjd> vali: yes
04:21:37 <TSC> vali: I don't think it encourages much either way
04:21:47 <vali> oh
04:21:50 <quicksilver> :t let mapMK = Kleisli . mapM . runKleisli in mapMK (Kleisli Data.IORef.readIORef &&& (arr id)) >>> arr (sortBy (comparing fst)) >>> arr (map snd)
04:21:52 <lambdabot> forall a. (Ord a) => Kleisli IO [GHC.IOBase.IORef a] [GHC.IOBase.IORef a]
04:21:58 <quicksilver> scook0: woot :)
04:22:08 <vali> any recommendations?
04:22:24 <TSC> vali: Maybe it's better for bottom-up than other languagues, because it's easy to compose small functions
04:22:39 <wolverian> what the heck is Kleisli? :)
04:22:50 <vali> TSC: okay, sounds good
04:22:57 <scook0> wolverian: I remember trying to find out who he is/was
04:23:00 <scook0> never found much
04:23:07 <wolverian> I mean what it is doing there!
04:23:09 <TSC> But Haskell won't design your program for you (:
04:23:16 <wolverian> you funny person
04:23:16 <vali> TSC: thanks!
04:23:36 <quicksilver> wolverian: trying to recast the lifted IO sort I did
04:23:43 <quicksilver> wolverian: as part of a generic pattern, by using arrows
04:23:54 <quicksilver> the Kleisli arrow comes from a monad, it's the one we want here
04:24:03 <wolverian> hm.. so the kleisli lets you wrap some sorts of monadic actions into an arrow?
04:24:12 <quicksilver> scook0: given that 'mapM' really belongs in Traversable
04:24:15 <scook0> wolverian: I wasn't being funny, actually
04:24:20 <quicksilver> scook0: there is a very odd traversable instance going on here
04:24:24 <wolverian> scook0, well, you succeeded anyway :)
04:25:09 <scook0> wolverian: basically, a Kleisli arrow is (a -> m b), for some monad m
04:25:17 <scook0> (this assumes you understand arrows)
04:25:21 <wolverian> yes
04:25:38 <scook0> but (a -> m b) has the wrong kind for the Arrow typeclass
04:25:47 <scook0> so you have to do nasty newtype wrapping/unwrapping
04:26:14 <wolverian> I'm still a bit unclear _why_ you use it
04:26:41 <scook0> why you use the wrapper, or why you'd use kleisli arrows at all?
04:26:52 <wolverian> latter
04:27:16 <scook0> because, uh, arrows are cool? :)
04:27:39 <scook0> but yeah, I've never really bothered much with kleislis
04:27:43 <quicksilver> scook0: definite newtype KleisliTraversable m t = Kleisli m (t a) (t b)
04:27:44 <wolverian> so it's not because it'd be more type safe?
04:27:49 <quicksilver> scook0: if you can follow that
04:27:51 <scook0> most of my arrow stuff is in (->)
04:27:59 <scook0> nah
04:28:22 <wolverian> oh, I was under that impression, thus confused, because I couldn't see where that would come about from
04:28:26 <wolverian> thanks :)
04:28:29 <quicksilver> scook0: then, we have Monad m,Traversable t => Traversable (KleisliTraversable m t)
04:28:42 <scook0> it's just the desire to use the cool arrow combinators for monadic stuff
04:28:54 <quicksilver> scook0: with mapM (for example) defined as Kleisli . mapM . runKleisli
04:29:01 <wolverian> yeah, I get it now. thanks
04:29:18 <quicksilver> scook0: there is something a bit weird when orthogonal class hierarchies coincide
04:29:25 <quicksilver> scook0: you get all kinds of 'cross-instances'
04:29:41 <quicksilver> which are fiddly to write down, but the methods are always some obvious wrap/unwrap thing
04:29:46 <scook0> I have been known to declare "special-purpose" arrow-inspired combinators for raw kleislis
04:30:38 <scook0> quicksilver: sadly, my brain is turning to mush at this late hour
04:30:47 <scook0> (if it hadn't become apparent already)
04:35:16 <quicksilver> scook0: fair enough. I don't think my observation was *very* interesting.
04:35:22 <quicksilver> scook0: it was just a sea of newtypes
04:35:34 <quicksilver> scook0: I wanted not to have to declare mapMK explicitly
04:35:42 <quicksilver> scook0: I wanted mapMK to be 'obvious'.
04:36:01 <quicksilver> I thought, well, mapM is really a method of Traversable. So there must be something here that I can make Traversable.
04:37:37 <scook0> I'm not really familiar with Traversable, myself
04:38:27 <quicksilver> think of it as "the right generalisation of lists so that you can define mapM"
04:38:38 <quicksilver> :t mapM
04:38:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:38:49 <quicksilver> what other types other than [] does this make sense for?
04:38:52 <quicksilver> answer: traversable.
04:38:55 <scook0> yeah, I have the haddock page open
04:46:25 <hpaste>  fox pasted "Reading lines" at http://hpaste.org/3596
04:46:56 <vali> i have read the contents of a file and now i am trying to read lines from that file.. not sure where to begin with the latter
04:47:17 <paczesiowa> :t lift
04:47:22 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
04:47:30 <paczesiowa> @src lift
04:47:30 <lambdabot> Source not found. Do you think like you type?
04:52:20 <scook0> vali: if you've read the contents of a file into a string
04:52:26 <scook0> you can use lines on that string
04:53:09 <scook0> I'm not sure what the usual technique is for line-by-line reading
04:53:41 <scook0> looks like it's hGetLine
04:54:45 <DRMacIver> I thought that *was* the usual technique?
04:54:52 <DRMacIver> Reading it into a string I mean
04:54:54 <DRMacIver> On grounds of lazy IO
04:55:39 <vali> readLines file = putStrLn $ lines file
04:56:05 <vali> this one complains because it gets a [String] instead of String
04:56:32 <paczesiowa> mapM_ putStrLn
04:56:38 <scook0> lazy I/O summons goblins
04:56:53 <paczesiowa> why?
04:57:00 <vali> hmm goblins
04:57:02 <DRMacIver> Lazy IO is great. I just wish it took a different form. :)
04:59:46 <quicksilver> lazy IO summons goblins which eat all your cookies
04:59:58 <quicksilver> not always a bad thing, if you're on a diet
05:00:53 <vali> i'm thin
05:03:27 <vali> i guess trying to parse files is a stupid thing to begin with
05:04:20 <quicksilver> nah, parsing files is good
05:04:30 <shubalub> it's surprisingly hard :/
05:06:06 <vali> this approach: http://hpaste.org/3597 says that "lines" needs a String and that i'm giving it [String]. not sure how to solve that
05:07:44 <scook0> vali: lines has type String -> [String]
05:07:46 <roconnor> @hoogle [String] -> String
05:07:47 <lambdabot> Prelude.unlines :: [String] -> String
05:07:47 <lambdabot> Prelude.unwords :: [String] -> String
05:07:47 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
05:07:58 <scook0> meaning it takes a string, and splits it into a list of strings
05:08:09 <roconnor> @type concat
05:08:10 <lambdabot> forall a. [[a]] -> [a]
05:08:12 <scook0> but you're then feeding it into putStrLn, which expects only one string
05:08:41 <roconnor> vali: use something like concat, unlines, or unwords
05:08:42 <scook0> there are a few different ways to fix it, depending on what you plan to do next
05:08:51 <roconnor> > concat ["Hello","World"]
05:08:58 <lambdabot>  ghc-6.6: could not execute: gcc
05:09:07 <scook0> o_O
05:09:07 <roconnor> > unwords ["Hello","World"]
05:09:08 <lambdabot>  ghc-6.6: could not execute: gcc
05:09:12 <idnar> oh dear.
05:09:17 <roconnor> > unlines ["Hello","World"]
05:09:17 <lambdabot>  ghc-6.6: could not execute: gcc
05:09:20 <scook0> @botsmack
05:09:21 <lambdabot> :)
05:10:41 <haraldk> > [1,2,3]
05:10:48 <lambdabot>  ghc-6.6: could not execute: gcc
05:12:29 <roconnor> vali: sorry I didn't look at your problem carefully until now
05:12:55 <roconnor> vali: what is readLines supposed to do exactly?
05:13:41 <vali> roconnor: i have read file with readData and i want readLines to split that into lines
05:14:37 <vali> roconnor: i am trying to parse files like AC_GT_A_A AA_G_C_TT and count how many of the letters are placed in the same spot etc
05:14:46 <roconnor> vali: so the lines function splits it into lines
05:14:57 <roconnor> you don't need to write your own function.
05:15:17 <scook0> heh, testing sequence alignments
05:15:42 <vali> scook0: yes
05:15:56 <roconnor> vali: you can use print to print (almost) anything
05:16:08 <roconnor> thus readLines file = print $ lines file
05:16:13 <roconnor> will print the list of lines.
05:16:23 <vali> roconnor: ah
05:16:28 <roconnor> or you can do
05:16:39 <roconnor> thus readLines file = mapM_ putStrLn $ lines file
05:16:46 <roconnor> that will run putStrLn on each line
05:16:46 <scook0> vali: in the version you pasted, readData doesn't actually pass the data to readLines
05:16:53 <scook0> it just prints it straight back out
05:17:01 <roconnor> and you will get the same thing you would have gotten with putStrLn file
05:17:17 <vali> oh, i only pasted the function that isn't working
05:17:20 <vali> i have some more code
05:17:27 <scook0> ah
05:17:38 <hpaste>  fox pasted "Reading lines 3" at http://hpaste.org/3598
05:17:43 <vali> there
05:18:04 <scook0> vali: in hpaste, you can use the "annotate" link to add stuff to an existing paste
05:18:15 <vali> scook0: oops. i didn't know
05:18:41 <scook0> it's not that obvious, but I try to spread the word :)
05:18:56 <vali> i was looking for "edit" somewhere
05:20:10 <hpaste>  scook0 annotated "Reading lines 3" with "splitting completeSet into lines" at http://hpaste.org/3598#a1
05:21:30 <araujo> what is the command to add a link in lambdabot ?
05:21:51 <scook0> you mean @where+ perhaps?
05:22:07 <scook0> (which will add stuff to @where)
05:45:42 <Botje> @quote oleg
05:45:42 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
05:51:51 <vali> are there any haskell books that are worth buying? or should the wikibooks and yaht be sufficient?
05:52:10 <pgavin> vali: school of expression by paul hudak
05:52:41 <pgavin> vali: there's another one I can't think of at the moment, also...
05:52:56 <jeffz> vali: http://www.haskell.org/haskellwiki/The_Monad.Reader issue 7 has a review of Programming in Haskell by Graham Hutton
05:52:57 <lambdabot> Title: The Monad.Reader - HaskellWiki
05:53:50 <quicksilver> vali: books are subjective. I believe the hutton book is pretty god
05:53:53 <quicksilver> good
05:53:57 <quicksilver> but it is aimed at beginniners
05:54:08 <jeffz> i can't say how i've found it so far because i haven't started reading it.. just trying to wash my hands of some C code before diving into Haskell
05:54:42 <vali> well i'm definitely a beginner
05:56:49 <ttfh> what's the opposite of lifting? dropping?
05:57:17 <fasta> ttfh: I don't think anyone figured out how to drop something.
05:57:46 <allbery_b> I think in Haskell lingo you don't drop something, you run it.  (e.g. runState)
05:58:19 <allbery_b> "evaluate" might be more general
05:58:20 <quicksilver> ttfh: colifting ?
05:58:44 <ttfh> hmm, i think it's a kind of running I'm after
05:58:53 <quicksilver> yes, it is
05:59:15 <ttfh> colifting sounds scary because it has "co" in it
05:59:20 <quicksilver> that was the idea
05:59:27 <quicksilver> I just made it up to stand scary
05:59:34 <quicksilver> s/ta/ou/
06:00:19 <ttfh> hehe
06:00:48 <quicksilver> in general you ought to be able to run any part of the stack
06:00:59 <quicksilver> (subject to constaints on what run means)
06:01:41 <quicksilver> 'runFooT' runs the top of the stack
06:02:02 <ttfh> hmm, of course the kind of "dropping" i was thingking of would be a bad idea, in the IO monad f.ex
06:02:12 <allbery_b> yep
06:02:36 <quicksilver> lift runBarT runs the next level down
06:02:39 <quicksilver> etc
06:03:29 <ttfh> yes, so I should provide a "runBar" for my monad rather than a "dropBar", even though in this case it would be safe
06:03:53 <quicksilver> yes, runBar is the conventional name
06:04:04 <quicksilver> note that 'runBar' doesn't always have a particular type
06:04:07 <quicksilver> if you see what I mean
06:04:14 <quicksilver> e.g. runState requires you to provide the state
06:04:23 <quicksilver> runWriter returns not only the result, but also the log
06:04:25 <quicksilver> etc
06:04:42 <quicksilver> so the 'run' functions are obviously connected, but their types depend on the monad.
06:04:46 <quicksilver> runList returns a list of results.
06:04:49 <ttfh> but there is such a thing as colifting?
06:04:57 <quicksilver> not in the context of monads, no
06:05:06 <ttfh> but in comonads?
06:05:12 <quicksilver> you could call it that, yes
06:05:23 <quicksilver> but I thik they normally call it 'run' in fact
06:05:30 <quicksilver> ut there would be a certain logic in calling it colift
06:05:52 <ttfh> and what do they call "run"?
06:06:03 <quicksilver> well in teh environment comonad
06:06:06 <quicksilver> (env,value)
06:06:12 <quicksilver> mm
06:06:15 <quicksilver> actually I'm confused
06:06:23 * quicksilver thinks harder
06:06:31 <quicksilver> people don't often use comonad stacks :)
06:06:52 <quicksilver> I'm not entirely sure I have a good enough mental model of that, sorry.
06:08:44 <ttfh> I don't have any mental model of it at all, I just recalled something about comonads being the dual of monads, so it would make sense if the operations you do on a monad had ha co-something dual
06:12:03 <fasta> I have a LaTeX document in which I would like to show some Haskell code. I know there's lhs2tex, but it seems that lhs2tex assumes that to see a rendering of the document it first needs to completely be processed by lhs2tex. There's a FAQ on it, but I don't understand the answer. I just want to include relatively small pieces of Haskell code in a convenient way.
06:12:11 <ttfh> hmm, a "dropbar" is something you put on a bike i think
06:13:38 <earthy> fasta: that is possible, but not recommended
06:14:09 <earthy> you'll need to \usepackage{lhs2TeX_poly}
06:14:27 <fasta> earthy: why is it not recommended?
06:15:15 <earthy> because the only way to do it is to use external \begin{code}\end{code} blocks as follows
06:15:18 <earthy> \begin{figure}
06:15:21 <earthy> \input{model/LifSem}
06:15:23 <earthy> \caption{The added semantics for $L_3$}
06:15:26 <earthy> \label{fig:skipassignifSem}
06:15:29 <earthy> \end{figure}
06:15:32 <earthy> where model/LifSem.lhs is a literate haskell file
06:15:55 <earthy> plus, you'll have to explicitly include the 'correct' packages for lhs2TeX to work
06:16:00 <twanvl> you could just use \verbatim or the listings package
06:16:10 <earthy> yah, but that's ugly
06:16:20 <fasta> earthy: Do you use Emacs to edit LaTeX?
06:16:25 <earthy> nope, I use vim
06:16:49 <earthy> oh, and one of the more important issues: lhs2TeX likes to process it's own style file as well
06:16:55 <fasta> earthy: so, I assume you do "make" when you want to see a preview?
06:17:12 <earthy> so, normally, the style file is explicitly included in the output of lhs2TeX
06:17:25 <earthy> (the lhs2TeX_poly.sty that I refered to is a nasty hack ;))
06:17:35 <earthy> fasta: indeed.
06:18:06 <earthy> @paste
06:18:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:19:07 <hpaste>  earthy pasted "Example Makefile for lhs2TeX for just including code snippets" at http://hpaste.org/3599
06:19:52 <fasta> earthy: what's -rm?
06:20:14 <fasta> earthy: a safe version of rm?
06:20:39 <earthy> - as the first character of a Makefile command line silences the output of that command
06:22:06 <fasta> earthy: how fast is lhs2tex? Is it noticable?
06:22:12 <earthy> not really
06:22:19 <earthy> it is really quite fast
06:24:12 <roconnor> @go 1 CAD in USD
06:24:13 <lambdabot> 1 Canadian dollar = 1.0502 U.S. dollars
06:24:25 <roconnor> @go 1 AUD in USD
06:24:26 <lambdabot> 1 Australian dollar = 0.9239 U.S. dollars
06:30:52 <fasta> earthy: I cp foo.tex foo.lhs; Copied the hello world example to my document(keeping into account to remove the extra begin and end document, etc);lhs2tex foo.lhs and I got an error related to | near an equation* environment.
06:31:50 <earthy> yeah, that is to be expected
06:32:03 <earthy> lhs2TeX treats | | as markers for inline code
06:32:24 <earthy> so |liftM| will be typeset as if it were the function
06:32:35 <earthy> (there *is* a reason I went to the trouble of hacking around lhs2TeX :))
06:32:58 <fasta> earthy: Hmm, it's not important after all.
06:33:01 <earthy> (and it is exactly that: it is harder work to retrofit an existing TeX file to circumvent the stuff that lhs2TeX claims)
06:33:46 <earthy> at least, in my case it was
06:34:27 <fasta> LaTeX is just a kludge, imho. TeXMacs is a much better idea.
06:34:56 <fasta> It's just that its userbase is too small and you cannot really fight userbase.
06:35:11 <Syzygy-> fasta: Apples and oranges.
06:35:26 <fasta> Syzygy-: elaborate
06:35:39 <Syzygy-> LaTeX and TeXMacs are different things filling different niches.
06:35:42 <fasta> TeXMacs contains a text format and a structured editor.
06:35:55 <Syzygy-> Ah, that's what you're talking about.
06:36:11 * Syzygy- is used to thinking of TeXMacs as just the structured editor...
06:36:11 <fasta> Syzygy-: what were you talking about?
06:36:20 <fasta> Ok
06:36:32 <Syzygy-> Basically ignoring the underlying textformat.
06:36:35 <quicksilver>  TeXMacs is for structured documents, LaTeX is a turing-complete page layout language
06:36:38 <fasta> Syzygy-: have you used it for anything significant?
06:36:55 <quicksilver> it's very difficult to design a structured document editor which copes with unforeseen complexity
06:36:57 <Syzygy-> fasta: Nope. I grew too annoyed by the UI pecularities and gave ti up for AucTeX+Emacs.
06:36:59 <integral> page layout isn't turing complete?
06:37:00 <quicksilver> like new kinds of diagram and stuff
06:37:04 <fasta> quicksilver: Are you saying TeXMacs isn't a turing-complete page layout language?
06:37:08 <quicksilver> yes.
06:37:12 <quicksilver> that is my belief.
06:37:14 <quicksilver> I could be wrong.
06:37:40 <quicksilver> can you design an entirely new kind of diagram, like a graph computed by an energy-minimisation algorithm, in texmacs?
06:37:50 <fasta> AFAIK, TeXMacs reimplemented the algorithms in TeX in Scheme.
06:38:02 <fasta> So, my current belief is that they can do the same.
06:38:32 <quicksilver> I think they implemented the linebreak + paragraph break algorithms
06:38:48 <quicksilver> I don't think they implemented the ability to embed arbitrary programs and compute arbitrary diagrams
06:39:02 <quicksilver> or at least, I don't think they exposed that ability in a way users can use it.
06:39:10 <fasta> quicksilver: I think you can use Scheme to do so.
06:39:17 <quicksilver> But, I haven't looked at it properly for many years. It may have changed, or I may have misunderstood.
06:41:13 <quicksilver> hmm
06:41:21 <quicksilver> I think it embeds complex diagrams by calling latex
06:41:26 <quicksilver> and embedded the PS produced
06:41:41 <quicksilver> that's what I gather from the xypic plugin, anyway
06:41:51 <quicksilver> so really it relies on latex underneath for the clever stuff.
06:43:01 <fasta> Practically I cannot even use TeXMacs, since it segfauls...
06:43:28 <fasta> But that might be a packaging problem
06:43:56 <Flynsarmy> Trying to write a function that inputs a FilePath and exports a String containing the text in the file but can't quite get it. Closest i came was do source <- readFile a; putStr a. Any ideas?
06:44:46 <quicksilver> Flynsarmy: that sounds close to me
06:44:58 <daniel_larsson> readFile alone should do it
06:45:07 <quicksilver> :t \a -> do {source <- readFile a ; putStr a}
06:45:08 <daniel_larsson> @t readFile
06:45:08 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:45:09 <lambdabot> FilePath -> IO ()
06:45:26 <quicksilver> Flynsarmy: well that prints it to the standard output
06:45:28 <Flynsarmy> readFile converts to an IO (). i need to make it a string
06:45:35 <quicksilver> :t readFile
06:45:37 <lambdabot> FilePath -> IO String
06:45:43 <quicksilver> no, readFile makes it a string :)
06:45:51 <quicksilver> it was your putStr that made it into ()
06:46:43 <daniel_larsson> And your code prints the fliename to stdout, the contents (source) is disregarded
06:46:49 <Flynsarmy> newFunction a = readFile a returns: Couldn't match expected type [Char] against inferred type IO String
06:47:21 <daniel_larsson> Yes, you need to be in the IO monad
06:48:11 <Flynsarmy> daniel_larsson: Sorry i'm new to Haskell, waht's the IO monad?
06:48:17 <Flynsarmy> daniel_larsson: Sorry i'm new to Haskell, waht's the IO monad?
06:49:33 <ricky_clarkson> Hmm, pressing return has side effects, be careful how many times you do it.
06:50:01 <sw17ch> Flynsarmy: i had a few people on here explain a lot of that to me last night =)
06:50:04 <doserj> http://www.haskell.org/haskellwiki/Introduction_to_IO
06:50:05 <lambdabot> Title: Introduction to IO - HaskellWiki
06:50:24 <Flynsarmy> Thanks fellas :)
06:50:34 <quicksilver> Flynsarmy: the type "IO String" means "this is a series of instructions/actions/interactions with the environment, which will, when run, produce a string"
06:50:34 <ricky_clarkson> Flynsarmy: Haskell has a big separation between code that you run just to get results from, i.e., code that if run a million times would always give the same thing, and code that Does Stuff(tm).
06:50:45 <ricky_clarkson> IO is for stuff that does stuff.
06:50:56 <quicksilver> Flynsarmy: for example "getLine" has type "IO String". Each time you run it, it (most likely) gives a  different result.
06:51:11 <quicksilver> Flynsarmy: something with merely type 'string' would be the same everyt ime, by definition.
06:52:03 <ricky_clarkson> @check \x -> (x :: String) == x
06:52:04 <lambdabot>  ghc-6.6: could not execute: gcc
06:52:05 <sw17ch> quicksilver++
06:53:05 <ricky_clarkson> I think IO should be called Kansas.
06:53:28 <idnar> hahaha
06:55:21 <paczesiowa> quicksilver: how about getLine :: () -> String ?
06:56:27 <daniel_larsson> It would return the same string for equal values of () :)
06:57:14 <hpaste>  (anonymous) pasted "weird IO" at http://hpaste.org/3600
06:57:21 <paczesiowa> look at that:>
06:57:47 <daniel_larsson> Well, with unsafePerformIO all bets are off
06:58:03 <sw17ch> Flynsarmy: http://tunes.org/~nef/logs/haskell/07.11.01
06:58:14 <sw17ch> Flynsarmy: look around 21:15:21
06:58:26 <sw17ch> Cale gave a good explanation of monads last night
06:58:31 <Flynsarmy> sw17ch: Thanks
06:58:33 <paczesiowa> unsafePerformIO is there only to make it work with ghc
06:58:37 <fasta> paczesiowa: what do you want to do?
06:59:07 <paczesiowa> my teacher told me that this is what IO looked many years ago in haskell
06:59:16 <opqdonut> ?remember ricky_clarkson I think IO should be called Kansas.
06:59:16 <lambdabot> Good to know.
06:59:20 <opqdonut> :)
07:01:36 <sw17ch> Flynsarmy: if you're looking at the log from yesterday, you'll want to look at the beginning of today for the end of the conversation :P
07:01:53 <Flynsarmy> sw17ch: Going through it now
07:02:13 <Flynsarmy> All i'm really after is a way to convert an IO String to a String though
07:02:26 <Flynsarmy> or a list of strings
07:02:28 <Saizan_> Flynsarmy: you can't.
07:02:47 <paczesiowa> fasta: I don't want to do anything with that, just it looks like that getLineSE doesn't return the same thin all the time
07:03:14 <fasta> paczesiowa: my understand is that IO worked differently years ago.
07:03:19 <fasta> understanding*
07:03:25 <paczesiowa> Flynsarmy: you want smth like: line <- getLine
07:03:29 <Saizan_> Flynsarmy: you can only "lift" your function that wants a String in the IO monad
07:03:32 <opqdonut> Flynsarmy: you do that by "running" the action, for example with ....
07:03:33 <opqdonut> yeah, what paczesiowa said
07:04:16 <daniel_larsson> Flynsarmy: in your original example, if you replace putStr a with putStr source, you should get the contents of the file on screen
07:04:36 <daniel_larsson> source has type String, which is what you want
07:04:42 <sw17ch> Saizan_: liftM?
07:04:44 <paczesiowa> fasta: but that code works today! and unsafe or not it doesn't return the same value all the time
07:05:07 <Flynsarmy> daniel_larsson: Yea i knew how to print out th econtents of the file. I was trying to stick the file into a list of strings though because i feel more comfortable with strings
07:05:28 <fasta> paczesiowa: So?
07:05:50 <daniel_larsson> as I said, using unsafePerformIO and all bets are off
07:08:06 <quicksilver> paczesiowa: right. getLineSE isn't a function.
07:08:18 <quicksilver> paczesiowa: getLineSE is a mangled mess.
07:08:27 <paczesiowa> well there is no way to implement that function without unsafePerformIO (whether you want it to return String or IO String) it must be provided by standard library/compiler
07:08:29 <quicksilver> unsafePerformIO isn't haskell :)
07:08:51 <Flynsarmy> daniel_larsson: For instance if it were a list of strings i'd be able to print out just the first line but with IO string i really don't have any clue how to do that
07:09:07 <quicksilver> Flynsarmy: you do it all inside a do block
07:09:25 <quicksilver> suppose "x" is IO [String] and you want to use a [String]
07:09:28 <quicksilver> you write:
07:09:31 <quicksilver> do y <- x
07:09:38 <quicksilver>    ... do stuff with y ...
07:09:46 <quicksilver> now "y" is [String]
07:09:48 <pjd> Flynsarmy: or with fmap
07:09:54 <quicksilver> and you can use ordinary String stuff on y
07:09:58 <quicksilver> well [String] stuff
07:10:09 <pjd> or <$>!
07:10:41 <Saizan_> and we've lines to split a String in a list of lines
07:10:45 <Saizan_> ?type lines
07:10:47 <lambdabot> String -> [String]
07:11:58 <Flynsarmy> readFile returns an IO String. If i say source <- readFile a, source isn't a [String]
07:12:28 <daniel_larsson> try do lines <- readFile a >>= return . lines
07:12:55 <daniel_larsson> erm... might want to name it differently than lines there (the first one)
07:14:10 <pjd> lines <$> readFile a
07:14:22 <Saizan_> do string <- readFile a; let listofstrings = lines string;
07:14:43 <paczesiowa> I'm not telling that this () -> () is good, it works in simple examples, but it's too hard to maintain, e.g. if we change "putStrLnSE (reverse line) `seq` f ()" to "f $ putStrLnSE (reverse line)" it still works, but then if we remove that top-level patternmatching "f () =" to "f x =" it stops working.
07:15:58 <quicksilver> paczesiowa: 'not good' is an understatement
07:16:10 <quicksilver> paczesiowa: it's totally and utterly wrong. It's rubbish. It's meaningless.
07:16:27 <quicksilver> paczesiowa: haskell types *mean* something. Those things claim to be one type and no longer are that.
07:16:32 <quicksilver> paczesiowa: that's not haskell :)
07:16:39 <quicksilver> it's a bit like ML.
07:16:42 <quicksilver> but ML doesn't have functions.
07:18:46 <paczesiowa> I can gross you out with more examples:P e.g. dialog based IO from 10 years ago
07:22:53 <daniel_larsson> paczesiowa: The question isn't whether you can write this in haskell or not. You can. But you're circumventing the type system in dangerous ways, and very odd things can happen, unless you use these "functions" in very restricted ways.
07:23:31 <daniel_larsson> well, you can write these things using GHC, rather than in haskell, I guess I should say
07:24:23 <fxr> mrd: I sent http://hpaste.org/3505 to hxt developers, no answer yet. Could you please send a mail to uwe?
07:26:13 <paczesiowa> I know that (or rather I've been told that many times and I believe it) but this kind of history lesson makes you appreciate the beauty of monads (especially IO)
07:30:23 <Flynsarmy> WHat's the difference between mapM and mapM_?
07:31:23 <Syzygy-> @src mapM
07:31:24 <lambdabot> mapM f as = sequence (map f as)
07:31:26 <arcatan> I gather mapM_ ignores results?
07:31:28 <Syzygy-> @src mapM_
07:31:28 <lambdabot> mapM_ f as = sequence_ (map f as)
07:31:37 <Cale> Flynsarmy: mapM just drops all the results and returns ()
07:31:39 <Syzygy-> Well ... that was enlightening. :P
07:31:46 <Cale> @src sequence
07:31:46 <lambdabot> sequence ms = foldr k (return []) ms
07:31:46 <lambdabot>     where
07:31:46 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:31:49 <Cale> ugh
07:31:52 <Cale> heh
07:31:58 <Cale> sequence [] = return []
07:32:14 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
07:32:19 <Flynsarmy> Cale: gotcha, thanks
07:32:20 <Cale> sequence _ [] = return ()
07:32:23 <davidL> Is there a list of universities that are teaching Haskell? I remember seeing this one time. Or does anyone have recommendations for universities which teach it? ;)
07:32:27 <Cale> sequence_ [] = return ()
07:32:39 <Cale> sequence_ (x:xs) = do x; sequence_ xs
07:32:49 <paczesiowa> davidL: where are you from?
07:32:50 <Cale> there we go :)
07:32:53 <Flynsarmy> I'm an Aussie at Griffith. We're doing a course on it this semester but the course got scrapped :( Won't be there next year
07:33:02 <davidL> paczesiowa, Illinois, USA
07:33:13 <Cale> Flynsarmy: That's sad
07:33:23 <paczesiowa> nvm then:D
07:33:45 <Flynsarmy> Cale: At first i hated haskell but now i'm glad we were taught it. I had previously never seen a functional programming language before.
07:34:16 <Cale> davidL: Unfortunately it doesn't seem to be as popular in North America as it is in Europe and Australia.
07:34:21 <Flynsarmy> I didn't even know they existed. It's interesting to see the differences between Haskell and Java/C
07:34:27 <Cale> Flynsarmy: yeah
07:34:34 <davidL> That's a shame.
07:35:48 <Cale> There are quite a few places where Haskell is the first programming language you see though
07:36:07 <paczesiowa> heaven?
07:36:11 <Cale> heh
07:37:03 <davidL> I suppose starting with SICP is nearly as good.
07:37:16 <opqdonut> we do neither here...
07:37:16 <Flynsarmy> Our lecturer told us that you can do alot with very little code in haskell and it's a huge time saver. But things are so incredibly complicated that even when writing little code it's taking FAR longer than it would with other languages
07:37:21 <opqdonut> basic teaching is with java
07:37:39 <davidL> opqdonut: that is what I want to avoid
07:37:39 <opqdonut> and after that it's pretty much language-agnostic
07:37:41 <Cale> Flynsarmy: It just takes practice
07:37:42 <opqdonut> (luckily)
07:37:51 <paczesiowa> Flynsarmy: that's just the beggining
07:38:15 <Cale> Flynsarmy: As you internalise the abstractions better, it gets faster to write.
07:39:03 <Cale> Flynsarmy: Since you can get a lot done with a very small amount of code, at the very least you get the benefit of being able to get up from your chair and walk around while programming.
07:39:46 <shapr> @. id @ @run unwords . filter (all isUpper) . words $ @show @yow
07:39:47 <lambdabot>   ghc-6.6: could not execute: gcc
07:39:48 <shapr> :-(
07:40:03 <Flynsarmy> If haskell doesn't have variables, what is the let statement? Couldn't i stick like 5 let statements at the top of my function like i would in java with a Int x = 4 etc?
07:40:22 <opqdonut> let is just naming things
07:40:32 <paczesiowa> besides, haskell is the most advanced language right now, there wont ever be a book "learn haskell in 24h" (as there are for simpler languages like java), so it's not a suprise that it't not easy to master
07:40:39 <opqdonut> it isn't a variable because you can't change it's value
07:40:56 <osfameron> I think people do still call them variables though :-)
07:41:00 <idnar> Flynsarmy: it would be more like const int x = 4;
07:41:03 <paczesiowa> > let x = 5 in (let x = x+1 in x)
07:41:04 <lambdabot>  ghc-6.6: could not execute: gcc
07:41:20 <Flynsarmy> idnar, opqdonut: True
07:41:31 <quicksilver> paczesiowa: however, you are wrong to suggest that haskell was ever like that
07:41:37 <quicksilver> paczesiowa: haskell was *never* like that
07:41:43 <quicksilver> paczesiowa: haskell has always had pure IO
07:43:45 <paczesiowa> quicksilver: maybe it so long ago that there even wasn't haskell
07:43:48 <pejo> opqdonut, you can't change variables in lambda calculus either, but everybody I know call them variables.
07:43:57 <quicksilver> Oh, I see on the cafe that yet another newbie got bitten by unsafe lazy IO
07:44:11 <paczesiowa> quicksilver: but some other early pure fp
07:44:11 <quicksilver> how long until people realise that it is a poor default API?
07:44:21 <sw17ch> Can i get my own personal lambdabot running on my machine? having access to @src would be great... :)
07:44:22 <quicksilver> paczesiowa: if it had IO as you describe, it wasn't pure. End of story.
07:44:41 <quicksilver> paczesiowa: haskell's spiritual predecessor was Gopher, and it had pure IO.
07:44:47 <quicksilver> ML-type languages work that way, of course
07:44:48 <opqdonut> pejo: yeah haskell has mathematical variables instead of programming language ones
07:44:51 <quicksilver> but they're not pure :)
07:45:14 <quicksilver> pejo: in (\x -> x + 1) x is a variable, because it varies over successive calls to the function
07:45:23 <quicksilver> pejo: that's the sense in which these things can vary, even in haskell
07:46:10 <pejo> quicksilver, I'm merely arguing against changing names of things we're already familiar with.
07:48:00 <quicksilver> pejo: I agree. these things *are* variables.
07:48:16 <quicksilver> pejo: however, I understand why opqdonut chose to not call them variables, too :)
07:48:39 <quicksilver> pejo: as a teaching technique, it is helpful to differentiate them from the kind of mutating variables many other languages have.
07:48:52 <quicksilver> paczesiowa: I believe haskell is no harder than java, actually.
07:49:00 <quicksilver> (not that I mean haskell is easy. I just believe java is hard)
07:49:56 <sw17ch> quicksilver: i think that Java is easier depending on your background
07:49:58 <paczesiowa> basics are easy (factorail, fibs), but monads, monad transformers are hard to understand
07:50:26 <paczesiowa> once you understand them, it's very easy to use them, but still you gotta understand them first
07:50:30 <shapr> Monads are very easy to define, but they do a lot of stuff.
07:50:56 <doserj> monads are not hard to understand, but apparently hard to explain *cough*
07:50:58 <quicksilver> sw17ch: yes. If your background includes already knowing java, java is easy :)
07:51:13 <quicksilver> sw17ch: if you already know french, you can speak parisien quite well.
07:51:36 <quicksilver> sw17ch: I jest :) but the point is, people who find java 'easy' are people who already know C++, or javascript, or at least delphi or VB.
07:51:41 <arcatan> luckily monads are easy to use
07:51:45 <quicksilver> in isolation object-orientation is REALLY HARD
07:51:56 <shapr> quicksilver: truly
07:51:59 <quicksilver> everyone I know, who learnt OO, took a long time to get their head around it.
07:52:05 <pejo> quicksilver, well, we all dislike mutation. But saying that it's not a variable because you can't mutate it makes it a lot harder to read a lot of the stuff written about functional languages.
07:52:07 <quicksilver> (and many of them failed, to be honest)
07:52:13 <osfameron> and Java's OO system has some hard-to-understand horridness to it
07:52:16 <quicksilver> pejo: I agree with you absolutely.
07:52:18 <pejo> quicksilver, for the students, once they come out of the course that is.
07:52:45 <sw17ch> quicksilver: learning haskell has been about as difficult as learning my first (procedural) language was
07:52:52 <quicksilver> sw17ch: yes, I agree
07:53:03 <quicksilver> sw17ch: and if it happened that your first (Ever) programming language had been haskell
07:53:11 <sw17ch> quicksilver: but to be honest, it's much more gratifying ... i think you can do more with Haskell than any language I've encountered
07:53:15 <quicksilver> sw17ch: I daresay you wouldn't have found it much harder than that :)
07:53:25 <sw17ch> @quote unlearn
07:53:25 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
07:53:27 <quicksilver> learning to program is hard
07:53:32 <quicksilver> doesn't matter what language :)
07:53:37 <quicksilver> the thing about haskell is it's more different
07:53:39 <sw17ch> programming is hard =)
07:53:49 <quicksilver> more different from what most practical programmers already know
07:53:50 <davidL> interesting quote
07:53:54 <quicksilver> rather than harder, in isolation
07:53:58 <sclov> Learning what all those type signatures meant without a good basic tutorial was what drove me mad at first.
07:54:12 <quicksilver> sclov: yes. The error messages can be unpleasant too.
07:54:26 <quicksilver> sclov: but, on the other hand, new java programmers also spend forver trying to get a file to compile.
07:54:49 <sclov> haha yeah I also spent way too long understanding fromIntegral
07:54:50 <sw17ch> haha... no kidding. i still don't know how to compile java files (i hate java)
07:55:08 <osfameron> yes, I'd forgotten that java error messages were also pretty bad
07:55:48 <davidL> java is interpreted, no? unless you compile it with gcj
07:56:01 <quicksilver> I've not really known a language/system where the errors were firendly on newbies.
07:56:05 <osfameron> it's compiled to bytecode
07:56:07 <sw17ch> Java isn't interpreted...
07:56:11 <sclov> osfameron: what drove me nuts before nice IDEs was that you only got one at a time. so you'd add a catch for something you forgot to handle, and then you'd try to comple and get told to add another! etc.
07:56:23 <quicksilver> To understand what you've done wrong generally just does require a good chunk knowledge of the system.
07:56:28 <quicksilver> (in any system)
07:56:33 <quicksilver> newbies don't have that by definition.
07:56:46 <quicksilver> it's quite hard to imagine in many cases what a good error message would actually be...
07:56:47 <sw17ch> In C, i know what i did wrong quite quickly... unless it's one of those scary wrongs dealing with spaghetti code and ghosts
07:57:09 <sw17ch> > 1 + + 1
07:57:09 <lambdabot>  Parse error at "+" (column 5)
07:57:14 <sw17ch> that's a pretty good one
07:57:27 <sw17ch> > 4 :: IO String
07:57:28 <lambdabot>   add an instance declaration for (Num (IO String))
07:57:28 <lambdabot>     In the expression: 4
07:57:28 <lambdabot> ...
07:57:31 <sw17ch> that is not
07:57:53 <quicksilver> agreed :)
07:57:57 <davidL> osfameron, the bytecode is interpreted by the VM though
07:57:58 <pejo> quicksilver, I think that's a fair research question for the HCI people. Much stuff isn't really technically hard, it's a soft side.
07:58:21 <quicksilver> pejo: ye, it's quite interesting.
07:58:54 <pejo> quicksilver, but the target should be programmers, not grandma that most other "usability" research seems focused towards.
07:59:32 <sw17ch> haskell isn't a language you can "guess" at things very easily with
07:59:42 <osfameron> quicksilver: I still think perl's error messages are rather good (compared with most)
07:59:51 <dylan> my own usability study on my mother (55) seems to indicate that keyboard-based interfaces are easier to understand. :)
07:59:53 <osfameron> davidL: yes, and assembly code is interpreted by the chip
08:00:06 <sw17ch> where things like PHP (gosh, i'm sorry for even saying that in here), you can guess at almost anything and get it right
08:00:22 <sclov> A-and
08:00:36 <sclov> ... the chip is interpreted by physics!
08:00:36 <dylan> sw17ch: it's easy to guess at a function given a type signature.
08:00:40 * roconnor wonders if right means ``compiles'' rather than ``correct''
08:00:43 <sw17ch> ah, very true
08:00:56 <quicksilver> davidL: but the *java* isn't interpreted. bytecode is.
08:00:58 <geocalc> haskell for grandma !
08:00:59 <quicksilver> davidL: quite different.
08:01:07 <sw17ch> ghaskell!
08:01:11 <quicksilver> davidL: there is still a substantial compilation process.
08:01:11 <Cale> sw17ch: You could add an instance of Num for IO String, and then 4 would actually produce one :)
08:01:22 <Syzygy-> roconnor: With a good enough type system, why should there be a difference? ;)
08:01:29 <sw17ch> Cale: building on last night... i haven't gotten to instances much yet =)
08:01:30 <quicksilver> davidL: we could imagine compiling haskell to a bytecode and it would still be compiled...
08:01:41 <Cale> sw17ch: It would be a ridiculous thing to do for that particular type, but in general, it's hard to say which types could be made instances of Num reasonably.
08:01:50 <quicksilver> too late, him run away
08:01:52 <davidL> That makes sense
08:02:04 <sw17ch_> well that was unfortunate
08:02:11 <quicksilver> ;)
08:02:16 <roconnor> Syzygy-: I agree. but ``easy to get things right in PHP'' could only possibly mean ``easy to get things to complie in PHP''.
08:02:28 <quicksilver> sw17ch_: you missed wisdom from Cale ! :)
08:02:36 <osfameron> sclov: very true!
08:02:45 <sw17ch_> and now i'm sw17ch_ =(
08:02:56 <sw17ch_> Cale: please repeat?
08:03:04 <idnar> yeah, basically the difference is that PHP doesn't bother telling you that you did something wrong
08:03:09 <Cale> <Cale> sw17ch: It would be a ridiculous thing to do for that particular type, but in general, it's hard to say which types could be made instances of Num reasonably.
08:03:20 <quicksilver> idnar: no. Your customers do that instead.
08:03:20 <idnar> I'm reminded of one guy in my Computer Studies class
08:03:26 <roconnor> idnar: that's a good way of putting it.
08:03:27 <quicksilver> idnar: (assuming you're doing php for a website)
08:03:30 <osfameron> no, but it's also true to say that haskell doesn't make brute force algorithms easy to write
08:03:30 <Cale> Integer literals like 4 will work with any instance of Num at all.
08:03:43 <sw17ch_> HTML does not tell you you're wrong either
08:03:50 <Cale> So Haskell actually has programmable integer literals :)
08:04:06 <idnar> the language of choice for that class was Visual Basic (although I ended up writing my final project in C++), and I was watching some guy trying to get his code to run; he was missing a bunch of "end if" statements, and he was basically just randomly inserting them to make the syntax errors go away
08:04:08 <davidL> quicksilver, is it correct to think of compilation on different levels of abstraction?
08:04:14 * roconnor finds that brute force search algorithms are particularly easy to write in Haskell.
08:04:21 <idnar> quicksilver: heehee
08:04:21 <Cale> (which is why that error message says there's no instance of Num, and not that the type doesn't match Integer or something)
08:04:35 <quicksilver> davidL: yes
08:04:46 <Cale> I suppose it could be worded a little more nicely.
08:04:57 <quicksilver> davidL: java compiles 'relatively less', in the sense that it doesn't even remove types
08:05:12 <sclov> Except for generics. :-(
08:05:13 <quicksilver> davidL: java bytecode still has the machinery of method dispatch tables and so on
08:05:21 <quicksilver> tis a bit of a mess, to be honest
08:05:24 <roconnor> Cale: maybe ``I got and IO String and expected an instance of Num'
08:05:28 <quicksilver> but it does enable a high level of dynamic linking
08:05:38 <quicksilver> in contrast, haskell compiles out types
08:05:47 <idnar> well, that might not be such a great error message
08:05:47 <quicksilver> and can often optimise away dynamic dispath
08:05:50 <idnar> but on the other hand, it beats this:
08:06:01 <roconnor> Cale: make it read more like a type error.
08:06:08 <Cale> roconnor: In fact, it could even make use of the fact that it's a literal here, and tell you that integer literals require an instance of Num
08:06:12 <sclov> Expected and Inferred are such weird ways to tell you which type was which -- took me a whole to sort out the difference.
08:06:39 <davidL> thanks, I had always thought that compilation meant program -> native machine code
08:06:42 <quicksilver> sclov: yes, because the thing about type unification is its fundamentally bidirectional
08:06:59 <quicksilver> sclov: so you're not really sure which direction the compiler came from when it "Expected" that...
08:07:04 <sw17ch_> davidL: compiling can be done to C code as well
08:07:07 <quicksilver> and which direction it came form when it "inferred" the other
08:07:16 <osfameron> roconnor: oh, interesting
08:07:18 <quicksilver> indeed, haskell used to compile to C
08:07:21 <hpaste>  idnar pasted "snippet of a C++ compiler error" at http://hpaste.org/3601
08:07:25 <quicksilver> and still does a bit, sometimes.
08:07:36 <roconnor> quicksilver: isn't there a clear environment vs term distiction when a type error occurs?
08:07:45 <quicksilver> roconnor: not in my head :)
08:07:49 <sw17ch_> that is a glorious error
08:07:51 <quicksilver> roconnor: there probably is in GHC's head, though?
08:07:53 <idnar> actually, I wish I still had the rest of that output, it was a beautiful one
08:08:08 <quicksilver> yes, C++ template errors are a thing of beauty
08:08:13 <quicksilver> but we shouldn't be smug about that
08:08:24 <quicksilver> typeclass errors get pretty horrible
08:08:39 <idnar> it's not the structure of the error that's the problem, really, it's just that all the information overwhelms you
08:08:47 <quicksilver> if you use stacks of (e.g.) monad transformers you can get some nasty stuff
08:09:06 <quicksilver> Cale: I had an observation about Kleisli and Traversable.
08:09:35 <Cale> Some of the most horrible typeclass errors I've ever dealt with have been the most sublime moments with Haskell's typechecker in general though.
08:10:10 <Cale> Like, I've had Haskell's typechecker actually tell me that I fundamentally misunderstood something about the algorithm I was implementing.
08:10:15 <quicksilver> :t Kleisli . mapM . runKleisli
08:10:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => Kleisli m a b -> Kleisli m [a] [b]
08:10:33 <quicksilver> Cale: I wanted to do that. mapM instide the kleisli arrow
08:10:50 <Cale> that's rather nice.
08:10:55 <quicksilver> Cale: and I thought 'there must be a Traversable instance, of which that is the natural definition of mapM'
08:11:09 <quicksilver> Cale: because Traversable is the corect abstraction of 'junk you can mapM over'
08:11:13 <quicksilver> and I come up with
08:11:19 <idnar> :hoogle Traversable
08:11:22 <idnar> @hoogle Traversable
08:11:23 <lambdabot> No matches found
08:11:51 <Cale> but, does Traversable really work with Arrows?
08:12:04 <quicksilver> newtype KTraversable m t a = Kleisli m (t a) (t a)
08:12:23 <Cale> ah, neat
08:12:33 <quicksilver> then instance Monad m, Traversable t => Traversable (KTraversable m t)
08:12:41 <Cale> (newtype constructor, but whatever)
08:12:46 <quicksilver> which is still not right, because it fixes the types at both ends :(
08:12:57 <Cale> hmm
08:13:05 <roconnor> Traversableoid!
08:13:16 <quicksilver> I mean, it type checks, module syntax errors
08:13:24 <quicksilver> but I should be able to have different as and bs
08:13:26 <Cale> newtype KTraversable m t a b = KT (Kleisli m (t a) (t b))
08:13:38 <Cale> make it an arrow instance?
08:13:50 <quicksilver> but now (KTraversable m t) is the wrong kind to be a Traversable instance...
08:14:12 <Cale> yeah, because the Traversable interface only works for functors
08:14:30 <quicksilver> but it *ought* to be possible
08:14:41 <quicksilver> my intution tells me that Traversable is the interface for 'mapM-like-stuff'
08:14:45 <Cale> hehe
08:14:53 <Cale> yeah, I suppose perhaps :)
08:14:56 <quicksilver> and Kleisli . mapM . runKleisli is obviously mapM-like
08:15:12 <Cale> Its type doesn't look like the type of mapM anymore though
08:15:15 <Cale> does it?
08:15:23 <quicksilver> :t Kleisli . mapM . runKleisli
08:15:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => Kleisli m a b -> Kleisli m [a] [b]
08:15:37 <quicksilver> no, it's a generalisation of mapM into arrows
08:15:45 <sw17ch_> quicksilver: could you define interface in this context?
08:15:48 <quicksilver> well, Kleisli arrows in particular, I guess
08:15:51 <Cale> mapM :: (a -> m b) -> t a -> m (t b)
08:16:08 <quicksilver> sw17ch_: which context?
08:16:26 <sw17ch_> quicksilver: what is the Traversable interface?
08:16:35 <roconnor> quicksilver, Cale: isn't the solution to make a new Traversableoid class?
08:16:37 <Cale> sw17ch_: We just mean "set of methods"
08:16:44 <quicksilver> @docs Data.Traversable
08:16:44 <lambdabot> Data.Traversable not available
08:16:48 <Cale> sw17ch_: It's actually a typeclass :)
08:16:51 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Traversable.html
08:16:53 <lambdabot> http://tinyurl.com/ylnfaa
08:17:52 <quicksilver> Cale: the context, fwiw, was the following. DRMacIver wanted to sort a list of IORefs by their contents
08:18:07 <quicksilver> Cale: I initially showed how to lift sortBy into the IO monad
08:18:22 <quicksilver> Cale: and scook0 pointed out that actually it's an arrow computation, not an IO one
08:18:28 <quicksilver> and we come up with the following monstrosity
08:18:37 <quicksilver> :t let mapMK = Kleisli . mapM . runKleisli in mapMK (Kleisli Data.IORef.readIORef &&& (arr id)) >>> arr (sortBy (comparing fst)) >>> arr (map snd)
08:18:39 <lambdabot> forall a. (Ord a) => Kleisli IO [GHC.IOBase.IORef a] [GHC.IOBase.IORef a]
08:18:56 <Cale> I'd probably have just mapM'd the computation which extracts the contents and pairs it with the original IORef, then sorted those pairs by their first component :)
08:19:01 <quicksilver> right
08:19:03 <quicksilver> that's what I did
08:19:11 <quicksilver> and that above is the arrow version of what you just said :)
08:19:15 <Cale> yes
08:19:30 * idnar 's head explodes
08:19:43 <quicksilver> it's nice because it reuses the pure part "sortBy (comparing fst) >>> map snd"
08:19:56 * roconnor wipes off bits of idnar's brain
08:20:02 <quicksilver> so you can see it really is the same sort algorithm
08:20:22 <quicksilver> but then I wondered what mapMK really was
08:20:23 <sw17ch_> no... i can't see that =)
08:20:36 <sw17ch_> but then again... after that last example.... i can't see anything
08:20:49 <quicksilver> damn, your eyes must have exploded
08:20:56 <quicksilver> that happens sometimes with type hackery
08:21:03 <sw17ch_> hehe
08:21:11 <sw17ch_> ah, speaking of types...
08:21:12 <Cale> I actually have trouble reading it with the arrows pointing the wrong way ;)
08:21:29 * Cale is far too used to the backwards nature of composition :)
08:21:47 <sw17ch_> Say I'm implementing an abstract syntax tree... I'm probably best off making a bunch of nested data types... right?
08:21:54 <Cale> probably
08:22:25 <Cale> With AST's in particular, it's good to add a type parameter so that you can later annotate the trees with other values
08:22:35 <sw17ch_> that's kinda what I was thinking
08:22:38 <roconnor> he he, nested data types.
08:23:13 <Cale> The types should look something like a grammar for your abstract syntax.
08:23:19 <sw17ch_> ideally, i'd like to have a slot for each basic element so that I can evaluate the tree to that point
08:23:30 <sw17ch_> Cale: that's exactly what i was thinking
08:24:39 <quicksilver> Cale: what's even cooler is to put a (* -> *) parameter around the mutual recursion
08:24:54 <quicksilver> Cale: then you can, at a later date, make your tree non-deterministic, or partial, or MVarred up etc
08:27:43 <roconnor> quicksilver: whoa
08:27:44 <Botje> I'm reading the paper on lightweight monadic regions by oleg & co
08:28:01 <Botje> am I right in thinking that arrows would be a better fit?
08:28:15 <Botje> since they're already parametrized in two dimensions..
08:28:19 <quicksilver> Botje: sounds unlikely that oleg would have missed that :)
08:28:30 <quicksilver> but, I haven't read the paper
08:28:34 <sw17ch_> *head hurts
08:28:52 <Botje> i'll read the paper through first, then
08:29:17 <quicksilver> I only know of two interesting uses of arrows. And one isn't an arrow.
08:29:24 <quicksilver> The parser combinators, which are cool.
08:29:31 <dons> did you include hacking tuples in pointfree style?
08:29:38 <quicksilver> And the TV stuff, which is abusing the class and isn't actualy an arrow.
08:29:40 <quicksilver> dons: no :P
08:29:44 <shapr> quicksilver: What about reversible code?
08:29:47 <dons> you should. that's the main user.
08:29:58 <quicksilver> shapr: that's really cool. I don't know of it though :)
08:30:15 <quicksilver> I thought I had an arrow, once.
08:30:17 <ricky_clarkson> Yeah, one of you guys has to write something popular on point-free programming.
08:30:18 <quicksilver> But it wasn't.
08:30:23 <Saizan_> ?type liftM (liftM $ map snd . sortBy (comparing fst)) $ mapM (liftM2 (liftM2 (,)) Data.IORef.readIORef return) -- i'm almost surprised this works
08:30:25 <lambdabot> forall a. (Ord a) => [GHC.IOBase.IORef a] -> IO [GHC.IOBase.IORef a]
08:30:26 <quicksilver> for roughly the same reason that TVs aren't.
08:30:37 <quicksilver> Saizan_: that was my first version, basically
08:30:42 <ricky_clarkson> I wrote a crappy "look what I found" article about it and it's top in google..
08:30:45 <quicksilver> Saizan_: although I had more points.
08:31:11 <quicksilver> Saizan_: my arrow verson was an attempt to separate the pure parts out better.
08:31:47 <shapr> quicksilver: http://www.cs.indiana.edu/~sabry/papers/quantumArrows.ps http://www.cs.indiana.edu/~sabry/papers/super-arrows-j.ps http://www.cs.ru.nl/~heunen/talks/2006/arrows/arrows-talk.pdf http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
08:32:09 <Botje> argh! more reading material
08:32:15 <Botje> I was hoping to play some more ET: quake wars today :)
08:32:20 <shapr> Guess not :-)
08:32:22 <Cale> ricky_clarkson: haha :)
08:32:31 <Cale> http://rickyclarkson.blogspot.com/2007/09/point-free-programming-in-java-7-beyond.html
08:32:34 <lambdabot> Title: Ricky's technical blog: Point-free Programming in Java 7 - Beyond Closures, http://tinyurl.com/22m3yw
08:32:41 <Cale> Is that it?
08:32:53 <quicksilver> shapr: Ah yes. I knew about that but only in the context of invertible parsers.
08:32:57 <ricky_clarkson> Cale: Yes.
08:32:58 <quicksilver> shapr: i.e. get your pretty printer for free.
08:33:04 <Cale> at least http://en.wikipedia.org/wiki/Pointless_topology is on the same page of results
08:33:35 <Cale> (which is of course the intellectual forebear of points-free programming)
08:33:39 <quicksilver> shapr: trying to think of other interesting classes of reversible computation.
08:33:51 <ricky_clarkson> Cale: Which I didn't know at the time..
08:33:56 <shapr> quicksilver: Any sort of codec? zlib, zip, serialization?
08:33:57 <quicksilver> shapr: maybe reversable image manipulation might be interesting.
08:33:59 <ricky_clarkson> I'd mainly seen it in this channel tbh.
08:34:07 <roconnor> all computation can be made reversable.
08:34:14 <sw17ch_> what function is used to convert an ascii character to it's numerical value?
08:34:21 <Cale> ord
08:34:22 <roconnor> (by copying the input into the output)
08:34:25 <Botje> Data.ord
08:34:26 <Cale> or fromEnum
08:34:30 <Botje> Data.Char.ord
08:34:30 <Botje> even
08:34:33 <ricky_clarkson> @hoogle Char -> Int
08:34:33 <lambdabot> Char.digitToInt :: Char -> Int
08:34:34 <lambdabot> Char.ord :: Char -> Int
08:34:37 <Cale> > fromEnum 'a'
08:34:39 <lambdabot>  97
08:34:44 <shapr> roconnor: Yeah, but when would it be especially handy to have the inverse of some code automatically produced for you?
08:34:51 <Cale> fromEnum has the nice property that it's in the Prelude
08:34:55 <sw17ch_> Marvelous, thanks
08:35:07 <sw17ch_> Cale++ Botje++ ricky_clarkson++
08:35:10 <Botje> .oO( we could hack GHC to automatically do such lookups )
08:35:14 <shapr> lambdabot++
08:35:18 <ricky_clarkson> Is Haskell's -> syntax mainly there because it was there in maths?
08:35:20 <shapr> @karma Cale
08:35:20 <lambdabot> Cale has a karma of 49
08:35:27 <ricky_clarkson> \x -> x*2
08:35:29 <sw17ch_> @karma lambdabot
08:35:29 <lambdabot> lambdabot has a karma of 51
08:35:32 <shapr> ricky_clarkson: I'd guess it came from the lambda calculus conventions.
08:35:33 <roconnor> shapr: think of the energy savings! $$$
08:35:34 <Botje> "unknown function ord, but I found a function with the same type and name over there"
08:35:35 <Cale> ricky_clarkson: in lambdas?
08:35:45 <ricky_clarkson> Cale: Yes.
08:35:51 <shapr> roconnor: Weren't we discussing clockless/reversible logic on -blah a few weeks back?
08:35:55 <Cale> ricky_clarkson: Actually the classical lambda calculus uses a dot there instead
08:35:58 <Botje> roconnor: I'd rather save  than $$$ =)
08:36:04 <ricky_clarkson> Java 7 is planning to use =>, and I've already seen some moaning about it.
08:36:05 <quicksilver> ricky_clarkson: in my experience, in maths that's normally a dot
08:36:11 <Cale> ricky_clarkson: and the symbol most mathematicians use is |-->
08:36:15 <roconnor> shapr: maybe.  I like talking about those things.
08:36:16 <ricky_clarkson> I thought a dot was composition.
08:36:17 <Botje> (those are euros, if your client is utf-8-disabled)
08:36:21 <Cale> (without a lambda)
08:36:23 <quicksilver> but yes, you sometimes so x |-> x+1
08:36:30 <dylan> java 7 is using => for what?
08:36:31 <quicksilver> ricky_clarkson: composition is a circle
08:36:43 <ricky_clarkson> dylan: function types, and anonymous functions.
08:36:44 <Cale> ricky_clarkson: no, an actual period. In mathematics, composition is a small, vertically centred circle
08:36:50 <ricky_clarkson> {int=>int} blah={int x=>x*2}
08:36:52 <dylan> java is getting function types?
08:36:53 <quicksilver> ricky_clarkson: small hollow circle about half the radius of an 'o' at the vertical center
08:37:02 <quicksilver> ricky_clarkson: while composition is a solid dot down at the baseline
08:37:04 <shapr> Oh rodent fornication... ACM wants me to pay money to read the invertible arrows paper.
08:37:12 <ricky_clarkson> Cale: Ah.  ASCII is killing me.
08:37:19 <Cale> That is, it's written like  f.g.x.fx(gx)
08:37:20 <quicksilver> shapr: there is a free copy I thought
08:37:33 <shapr> quicksilver: Yeah, I think I have a free copy, I wonder where I left it...
08:37:41 <Cale> (supposing that your IRC client supports unicode)
08:37:52 <ricky_clarkson> (it does)
08:37:53 <shapr> It just pisses me off that the link from haskellwiki leads to the "pay money" link.
08:37:56 <dylan> lambda looks like like an 'n' with this font
08:38:00 <ricky_clarkson> I can't read maths papers because they use Greek abbreviations for the ascii I know and love.
08:38:09 <Cale> hehe
08:38:13 <quicksilver> shapr: http://citeseer.ist.psu.edu/alimarine05there.html
08:38:15 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming (ResearchIndex)
08:38:32 <Cale> x instead of return x?
08:38:32 <shapr> A curse upon scientific paper publishers! May Elsevier and all the rest be sodomized by syphilitic camels!
08:38:44 <quicksilver> shapr: click on 'Cached : PDF' top right
08:38:47 <quicksilver> shapr: Job done.
08:38:58 <shapr> quicksilver: Not done until I add that to haskellwiki...
08:39:00 <Cale> @remember shapr A curse upon scientific paper publishers! May Elsevier and all the rest be sodomized by syphilitic camels!
08:39:00 <lambdabot> Good to know.
08:39:01 <quicksilver> ;)
08:39:20 <shapr> Oboy, I hope I get into the next HWN with that quote.
08:39:39 <arcatan> who's Elsevier?
08:39:46 <shapr> @go elsevier knuth
08:39:54 <lambdabot> http://linkinghub.elsevier.com/retrieve/pii/S0097316504001621
08:39:58 <shapr> hmm, maybe not
08:40:15 * Cale screws over Elsevier by simply making use of his friend's library proxy account :)
08:40:15 * shapr googles around...
08:40:44 <quicksilver> shapr: http://opendotdotdot.blogspot.com/2007/10/of-open-source-open-access-and-donald.html
08:40:48 <quicksilver> ?
08:40:57 <shapr> Cale: I won't do that, much like I won't download music without consent of either the artist or publisher or whatever.
08:41:19 <ricky_clarkson> Are the guys who wrote QuickCheck residents here?
08:41:28 <shapr> Cale: But since one of my functions in the Haskell community is to spread the knowledge of interesting and new things, I refuse to mention pay-only papers to anyone.
08:41:38 <shapr> I figure, if nobody knows about 'em, they'll all die out.
08:41:42 <Cale> What we really should have everyone do is have all the graduate students in the world re-write up all the really important papers in their own words, and then put that all on the web.
08:41:55 <shapr> ricky_clarkson: No, but several people here have hacked on or extended QC, you have some questions?
08:42:02 <Cale> Like, as part of their thesis process.
08:42:02 <shapr> Cale: good idea!
08:42:11 <shapr> We'll call it, Project Knuthenberg.
08:42:16 <ricky_clarkson> shapr: I'd just like to suggest they include a pdf version of quick.ps on the site.
08:42:33 <ricky_clarkson> shapr: I had to scp it somewhere, run ps2pdf and scp it back again.
08:42:45 <shapr> Oh, you're on windows, yeah?
08:42:58 <shapr> arcatan: http://boscoh.com/science/how-the-scientific-publishing-industry-began-to-eat-itself
08:43:00 <ricky_clarkson> Right.  Cygwin doesn't seem to have it, unless I'm really determined.
08:43:01 <lambdabot> Title: Trapped in the USA: How the Scientific Publishing Industry Began to Eat Itself, http://tinyurl.com/23z2rl
08:43:11 <shapr> That's part of the whole Elsevier deal.
08:43:20 <ricky_clarkson> it=ps2pdf
08:43:21 <Cale> shapr: There's also a huge problem with the way things are presently done, at least in many areas of mathematics, in that publishers have a tendency to want authors of papers to keep things short.
08:43:44 <ricky_clarkson> Cale: Is that why so many papers are incomprehensible?
08:43:50 <Cale> As a result, you end up with papers which are largely incomprehensible to all but the 5 people working on that particular area.
08:44:08 <ricky_clarkson> I was reading one with great cartoons.  As soon as the cartoons finished, the Greek started.
08:44:14 <Cale> Even their grad students have to spend 3 pages of work to see the connection between two adjacent lines.
08:44:16 <shapr> arcatan: In a nutshell, authors usually have to sign much/most/all of their publishing rights to the publisher, other authors do the copyediting and refereeing, and then the publisher charges an obscene amount of money for a journal subscription, or for an electronic copy of the article.
08:44:34 <shapr> In short, scientific journals serve no useful purpose.
08:44:42 <ricky_clarkson> shapr: I wish more knowledgeable people would blog instead of write papers.
08:45:00 <quicksilver> the good thing about scientific journals is the refereeing, basically
08:45:02 <Cale> I think papers are a great format with a bad publishing system.
08:45:04 <quicksilver> the weeding out
08:45:11 <quicksilver> all kinds of idiots (no offence) can write blogs
08:45:22 <Cale> quicksilver: Right, and if people just realised that there are other ways that can be managed, we'd be set :)
08:45:25 <quicksilver> only some very particular kinds of idiots can publish in well-known journals.
08:45:27 <fasta> quicksilver: all kinds of idiots write in journals too.
08:45:31 <ricky_clarkson> quicksilver: Sure, and we're all good at filtering each other's.
08:45:40 <quicksilver> fasta: you stole my joke, but I had a better punchline :P
08:45:54 <shapr> The only reason that scientific journals still exist is that most universities pay their professors according to the number/quality of papers that they publish, and the universities only know how to measure that with hardcopy publications.
08:45:54 <Cale> The blog though is one of the worst methods of organisation of content ever devised.
08:45:55 <ricky_clarkson> I look forward to the day I remove the javablogs RSS feed from my reader.
08:45:57 <fasta> quicksilver: Peer-reviewing does not work, imho, currently.
08:46:02 <mrd> there's some efforts to get out free journals
08:46:17 <fasta> quicksilver: to peer-review an article you need a _lot_ of time.
08:46:17 <quicksilver> fasta: it does not work perfectly. Perhaps it doesn't even work all that well. But I'm sure it works better than nothing at all.
08:46:23 <shapr> mrd: Yeah, like The Monad.Reader
08:46:27 <fasta> quicksilver: it's basically write-only culture now.
08:46:32 <quicksilver> true
08:46:35 <ricky_clarkson> Cale: Blogs for ad-hoc stuff, wikis for the rest?
08:46:36 <quicksilver> but not entirely true
08:46:36 <mrd> well
08:46:37 <shapr> fasta: And I have an idea for fixing that!
08:46:39 <quicksilver> like most of these things :)
08:46:46 <mrd> there's a nice complexity journal which is free
08:46:51 <shapr> I want to mix a wiki with a blog and call it The Monad.Writer
08:46:52 <quicksilver> I'm not in academia now, but when I was, people *did* read each others papers
08:46:58 <quicksilver> at least, the people I knew did.
08:47:11 <Cale> ricky_clarkson: That would be better. I recommend not just allowing everyone to edit everything though.
08:47:14 <shapr> I want to get into academia.
08:47:17 <quicksilver> and there was a real sense that the good journals and conferences helped point towards the good stuff.
08:47:22 <quicksilver> shapr: FLEE! FIRE! FLEE!
08:47:27 <fasta> quicksilver: it's not just about "reading", it's about "critically reading" it.
08:47:27 <quicksilver> shapr: (do anything else...)
08:47:27 <Cale> ricky_clarkson: PlanetMath has a good approach
08:47:28 <shapr> quicksilver: Why so?
08:47:36 <Cale> ricky_clarkson: Though there are things still missing from that.
08:47:43 <quicksilver> shapr: badly paid; unappreciated; overworked with admin;
08:47:50 <quicksilver> shapr: oh, and they wouldn't give me a job ;)
08:48:34 <shapr> quicksilver: btw, I think the quote is Fear! Fire! Foe! if you were going for Tom Bombadil's air raid siren imitation.
08:48:44 <quicksilver> yeah, probably
08:49:00 <fasta> Some people don't need to be refereed and it's a joy to read completely correct articles containing new stuff.
08:49:16 <mrd> i don't think anyone goes into academia for the pay..
08:49:38 <byorgey> shapr: I thought that was the Hobbits in Buckland, not Tom Bombadil
08:50:08 <shapr> Oh, maybe so...
08:50:18 <quicksilver> fasta: that's true. That kind of person often publishes preprints from their own website, though.
08:51:38 <shapr> I concede the JRRT geekiness contest to byorgey :-)
08:58:00 <jgfjgjsdfjsdfsd> hi
08:58:26 <Errrick> can somebody help me with something veery stupid ?
08:58:49 <Errrick> I want a simple division from two integers
08:58:54 <Errrick> that returns a float value
08:59:00 <Errrick> why is that so difficult ?!?!?!
08:59:08 <roconnor> > fromIntegral 7 / fromIntegral 8
08:59:09 <lambdabot>  0.875
08:59:21 <Errrick> ok, i'll try that
08:59:22 <byorgey> shapr: hehe, well, I just reread Fellowship recently, which is the only reason I remembered it in that much detail =)
08:59:23 <Errrick> thanks a lot
08:59:23 <roconnor> Errrick: no automagic conversion to floating point, because it is dangerous
08:59:49 <sw17ch_> roconnor: how is the actual conversion done?
09:00:03 <sw17ch_> @src fromIntegral
09:00:03 <lambdabot> fromIntegral = fromInteger . toInteger
09:00:28 <sw17ch_> @src fromInteger
09:00:28 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:00:38 <sw17ch_> @src toInteger
09:00:38 <lambdabot> Source not found. There are some things that I just don't know.
09:00:50 <Errrick> ERROR file:.\TP.hs:47 - Instance of Fractional Integer required for definition of publicoPromedio
09:00:54 <Errrick> :(
09:01:00 <Errrick> this is what I have:
09:01:12 <Errrick> publicoPromedio banda = fromIntegral (sum [ x | (a,b,x) <- (eventosBanda banda eventos) ] / (fromIntegral.toInteger) (length (eventosBanda banda eventos)))
09:01:26 <roconnor> @check \x y -> (fromInteger x == (fromInteger y::Double)) ==> x == y
09:01:28 <lambdabot>  Arguments exhausted after 100 tests.
09:01:39 <roconnor> ... not the best property for quickcheck
09:02:13 <roconnor> sw17ch_: I think fromInteger is part of the Num class
09:02:31 <roconnor> I forget which class toInteger is in.
09:02:42 <Errrick> I only want a simple average function :(
09:02:45 <wli> Integral
09:02:55 <Errrick> im using winhugs btw
09:02:56 <roconnor> Errrick: the average of integers may not be an integer.
09:03:14 <Errrick> ok, but how can i convert those Integers ?
09:03:20 <Errrick> like to float or double
09:03:24 <roconnor> @type fromIntegral
09:03:26 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:03:43 <roconnor> fromIntegral converts numbers to thingies.
09:03:51 <Errrick> I see
09:03:53 <Errrick> i tried that
09:03:58 <Errrick> but didnt work
09:04:02 <roconnor> oh?
09:04:02 <fasta> Anyone using mmm-mode with Haskell + LaTeX?
09:04:04 <roconnor> @paste
09:04:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:04:14 <wli> :t avg xs = sum xs / genericLength xs
09:04:16 <lambdabot> parse error on input `='
09:04:25 <Errrick> this is what i got
09:04:27 <wli> :t let avg xs = sum xs / genericLength xs in avg
09:04:28 <Errrick> publicoPromedio banda = fromIntegral (sum [ x | (a,b,x) <- (eventosBanda banda eventos) ] / (fromIntegral.toInteger) (length (eventosBanda banda eventos)))
09:04:28 <lambdabot> forall a. (Fractional a) => [a] -> a
09:05:23 <roconnor> publicoPromedio banda = fromIntegral (sum [ x | (a,b,x) <- (eventosBanda banda eventos) ] / (fromIntegral (length (eventosBanda banda eventos)))
09:05:37 <Errrick> ok
09:05:42 <Errrick> ill try that
09:06:43 <Errrick> YEEEY
09:06:47 <Errrick> thanks a lot roconnor
09:08:06 <sw17ch_> is there a chance any one has tried to port Haskell to something other than x86, sparc, or powerPC?
09:08:51 <Flynsarmy> If i have a function func String -> String and it starts off with: func a = do, how do i return the string at the end of the function?
09:09:14 <dons> sw17ch_: sure. anything from arm, to mips64, to ia64. pretty much anything moderately common
09:09:27 <dons> sw17ch_: did you have something in mind?
09:09:32 <sw17ch_> what about something smaller and embedded like M68K?
09:09:34 <sw17ch_> ColdFire
09:09:40 <dons> i've used ghc and hugs on m68k
09:09:45 <sw17ch_> no way
09:09:49 <sw17ch_> do tell
09:09:54 <dons> i think ghc actually ships for m68k in debian?
09:09:56 <malsyned> So if I build up a computation using >>> between functions (taking advantage of the instance ArrowApply (->)), I get this neat left-to-right, pipeline-looking definition.  Is there anything I can put at the left hand of such a chain to act as a data source?  So that, say, rather than saying (dropWhile (<17) >>> head) (iterate (*2) 1) I can say iterate (*2) 1 `mysteryOperator` dropWhile (<17) >> head ?
09:10:01 <dons> and nhc98 definitely does
09:10:16 <malsyned> s/>>/>>>/
09:10:20 <wli> arm's where embedded's at
09:10:30 <dons> http://www.haskell.org/nhc98/download.html
09:10:31 <lambdabot> Title: nhc98 download page
09:10:34 <earthy> wli: that's not entirely true
09:10:37 <dons> see the netbsd pages
09:10:40 <sw17ch_> I do a lot of ARM and M68K at work, and would love to find an alternative to C
09:10:43 <dons> pmax,amiga,atari,cobalt,sun3,m68K
09:11:10 <dons> nhc98 is a haskell compile for embedded/resource constrained environments, so would be one option.
09:11:20 <sw17ch_> that's fantastic....
09:11:22 <Flynsarmy> func :: String -> String
09:11:23 <Flynsarmy> func a = do
09:11:25 <Flynsarmy>   ...
09:11:26 <mrd> > arr [2..] >>> dropWhile (<17>
09:11:26 <lambdabot> Unbalanced parentheses
09:11:28 <Flynsarmy>   return "hi"
09:11:29 <Flynsarmy> no dice :(
09:11:29 <mrd> > arr [2..] >>> dropWhile (<17>
09:11:29 <lambdabot> Unbalanced parentheses
09:11:30 <mrd> > arr [2..] >>> dropWhile (<17)
09:11:36 <sw17ch_> dons: how well does the standard library support cross the lines?
09:11:38 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
09:11:44 <earthy> flynsarmy: what do you mean no dice?
09:11:54 <mrd> > arr (const [2..]) >>> dropWhile (<17)
09:11:55 <lambdabot>  Add a type signature
09:11:55 <Flynsarmy> not returning that string
09:11:58 <mrd> blah
09:11:58 <dons> sw17ch_: the base library is fairly well supported, but most 3rd party libs onlh work with ghc
09:12:03 <mrd> one sec
09:12:23 <sw17ch_> dons: is there a good list of the base library stuff?
09:12:25 <Flynsarmy> earthy: Trying to figure out how to return the value at the end of the funciton if it starts off with a do
09:12:42 <dons> sw17ch_: yeah, on haskell.org under libraries
09:13:00 <malsyned> mrd: I don't think anything before the >>> is going to work, because no matter what you'll still be producing a function that takes an argument.  The closest I've gotten so far is ((arr.const) (iterate (*2) 1) >>> dropWhile (<17) >>> head $ ()
09:13:02 <sw17ch_> Standard Libraries then?
09:13:04 <dons> nhc is slightly unsupported
09:13:08 <dons> yep
09:13:23 <dons> it would be worthwhile seeing if you can get ghc to target the arch first
09:13:25 <earthy> > let f = do b <- map toUpper; return b in f "small"
09:13:26 <lambdabot>  "SMALL"
09:13:37 <malsyned> > (arr.const) (iterate (*2) 1) >>> dropWhile (<17) >>> head $ ()
09:13:39 <lambdabot>  32
09:13:47 <malsyned> but that $ () at the end is pretty ugly.
09:14:13 <sw17ch_> i would much rather have GHC target the arch...
09:14:24 <mrd> > flip id (iterate (*2) 1) (takeWhile (<17) >>> head)
09:14:26 <lambdabot>  1
09:14:29 <sw17ch_> dons: though, as usual... code space is always limited
09:14:39 <mrd> > flip id (iterate (*2) 1) $ takeWhile (<17) >>> head
09:14:40 <lambdabot>  1
09:15:00 <sw17ch_> dons++
09:15:03 <dons> sw17ch_: what kind of constraints do you have?
09:15:27 <wli> Cleaning up libs and/or implementations so they work with nhc98, yhc, etc. sounds like gruntwork it may be possible to point people at.
09:15:28 <dons> i suppose you could also run the hugs interpreter
09:15:32 <dons> that would be very easy to get going
09:15:49 <sw17ch_> 128K code space... :(
09:15:49 <mrd> malsyned: yea probably.  HXT has its own operator for this purpose, for that matter.
09:15:53 <sw17ch_> this is really small
09:15:56 <shapr> dons: Should there be images on HaskellUserLocations?
09:16:30 <sw17ch_> so i have the usual problem of "crap, hello world is 500K"
09:16:46 <dons> shapr: hmm, i haven't been able to generate the maps in a while
09:16:49 <dons> and won't get time to do so
09:17:10 <dons> sw17ch_: well, 180k assuming you use split objs. but nhc gives you 8k hello world
09:17:18 * shapr tries to make maps
09:17:28 <dons> shapr: the scripts i used are at the bottom of the page, iirc
09:17:46 <sw17ch_> Well... lets see...
09:17:50 <dons> 128k crikey
09:17:53 <dons> that's pretty tight
09:18:09 <dons> maybe forth perhaps? :)
09:18:21 <sw17ch_> we fit a small web server, a networking stack, and a 485 bus running around 12MBit =)
09:18:28 <dons> cool
09:18:36 <sw17ch_> all in C
09:18:40 <sw17ch_> so... a bit hard to maintain
09:18:44 <dons> i don't think ghc is going to fly though, in that small an environment
09:18:52 <sw17ch_> yeah, i'm not planning on using it here...
09:19:00 <sw17ch_> but i've been hoping to get something else i could possibly use
09:19:12 <sw17ch_> i'm in a small enough company where the developers/engineers have a lot of leeway in the tools they use
09:19:25 <dons> hehe, me too
09:19:33 <sw17ch_> i've thought about trying to port SBCL or get Guile to run as an interpreter
09:19:38 <earthy> Flynsarmy: also,   func a = do return 'h'
09:19:44 <sw17ch_> really though, i'd rather use Haskell... something about the strict typing
09:19:50 <shapr> sw17ch_: You could try jhc if you don't have a long running process.
09:19:59 <earthy> > let f a = return 'h' in f "asdf"
09:20:01 <lambdabot>   add an instance declaration for (Show (m Char))
09:20:07 <dons> well, i wouldn't recommend jhc, since not enough haskell programs are comilable with it
09:20:07 <sw17ch_> shapr: months to years... :(
09:20:14 <shapr> oh
09:20:15 <earthy> > let f :: String -> String ;f a = return 'h' in f "asdf"
09:20:17 <lambdabot>  "h"
09:20:30 <dons> however, nhc or ghc are possibles, depending on available ram / code size
09:20:49 <sw17ch_> oh well i'm sure i could figure something out =)
09:21:02 <malsyned> mrd: I think the operator I want is "flip ($)" with the right precedence.
09:21:04 <sw17ch_> We're looking at other work that will have more room for hardware
09:21:19 <sw17ch_> The next revision of the project I'm refering to will have much... much more
09:21:25 <dons> we use haskell for low level/on-metal stuff too, typically with ghc
09:21:40 <sw17ch_> dons: which architectures? how much memory?
09:21:40 <dons> or with custom compilers for custom languages
09:21:58 <sw17ch_> ... which company? :P
09:22:05 <dons> not really small. small x86 iirc, galois.com
09:22:26 <dons> though for very small things, like fpgas, we write our own compilers for haskell-like languagers
09:22:50 <sw17ch_> dons: sounds very fun
09:24:05 <sw17ch_> dons: well cool. i'll have to keep this all in mind. perhaps I can snag one of the free demokits at work and see what I can do with it
09:24:42 <dons> cool
09:24:51 <malsyned> mrd: looks like this works: source = flip ($); infixr 2 source
09:25:01 <malsyned> (with backticks around source)
09:25:13 <malsyned> nope I lied.
09:25:41 <shapr> swiert: Are you using embedded x86?
09:26:39 <dons> ooh ghc-6.8.1-src.tar.bz2                           02-Nov-2007 00:36  6.7M
09:27:53 <shapr> where?
09:28:06 <shapr> I want a torrent!
09:28:26 <cjay> it's not final. I've seen the modification date of the tarball change several times
09:28:47 <quicksilver> Cale: well, I have another one for ou
09:28:55 <Cale> okay
09:29:00 <quicksilver> Cale: how come there isn't a Data.Sequence.filter ?
09:30:20 <Cale> good question
09:30:44 <quicksilver> \f -> Data.Foldable.foldMap (\a -> if f a then Control.Applicative.pure a else mempty)
09:30:50 <quicksilver> :t \f -> Data.Foldable.foldMap (\a -> if f a then Control.Applicative.pure a else mempty)
09:30:58 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Applicative f, Data.Foldable.Foldable t, Monoid (f a)) => (a -> Bool) -> t a -> f a
09:31:01 <quicksilver> I believe that is the correct generalisation
09:31:11 <quicksilver> (unify 'f' and 't' to the same type)
09:31:32 <quicksilver> for any Foldable 'f' which is also an Applicative, and such that 'f a' is always a monoid, that is "filter"
09:31:50 <quicksilver> it generalise List.filter
09:32:00 <quicksilver> but also works for Sequence
09:32:39 <Cale> But is it the most efficient way to do it, I wonder.
09:32:54 <doserj> Data.Sequence.fromList . List.filter . Data.Foldable.toList -- *duck*
09:33:31 <Cale> Right, that way is clearly questionable, because nothing of the existing tree structure is preserved.
09:33:48 <idnar> is that a hylomorphism?
09:34:06 <pjd> or are you just happy to see me?
09:34:34 <Cale> We really ought to have Data.FingerTree in the GHC libraries
09:34:38 <shapr> Yes!
09:34:44 <shapr> pjd: hah!
09:36:01 <pjd> idnar: it's a transform, but not a hylomorphism (AFAIK)
09:36:23 <Cale> Also, I have no idea why there's no priority queue implementation, since it's so easy once you have the finger trees which Data.Sequence is based on.
09:36:56 <quicksilver> yeah
09:36:59 <quicksilver> I didn't use fromList
09:37:05 <quicksilver> because I was trying to get at the essence of it
09:37:18 <quicksilver> it's quite interesting that [] and Sequence are both 'Foldables but also Monoids'
09:37:29 <quicksilver> with the obvious abuse of notation when it comes to kinds there
09:37:49 <Cale> Well, they're also MonadPlus'es
09:37:53 <quicksilver> binary trees, however, are not monoiad
09:37:57 <quicksilver> right, same thing
09:38:05 <quicksilver> MonadPlus is the higher-kinded Monoid
09:38:12 <quicksilver> plus some naturality contraints
09:38:32 <quicksilver> I was getting onto the monadplus part, actually
09:38:36 <quicksilver> they're both foldables but also monoids
09:38:37 <Cale> hehe, Monad is also the higher-kinded Monoid, in a different way :)
09:38:40 <quicksilver> :t foldMap
09:38:42 <lambdabot> Not in scope: `foldMap'
09:38:51 <quicksilver> :t Data.Foldable.fold
09:38:53 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
09:39:00 <quicksilver> :t Data.Foldable.foldMap
09:39:02 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
09:39:06 <quicksilver> sorry, thats the one I want
09:39:15 <quicksilver> it turns out that if you are both Foldable and Monoid
09:39:22 <quicksilver> then foldMap becomes concatMap
09:39:24 <quicksilver> (in a sense)
09:39:30 <quicksilver> and hence, it becomes a candidate for >>=
09:39:37 <quicksilver> so if you're both Foldable and (pointwise) Monoid
09:39:44 <quicksilver> you are a Monad (and indeed MonadPlus)
09:40:02 <quicksilver> using >>= = foldMap
09:40:24 <Cale> Heh, foldr on Seq is implemented as foldr f z (Seq xs) = foldr (flip (foldr f)) z xs
09:43:40 <Cale> It seems that foldr and foldl are implemented directly on the structure
09:43:49 <Cale> But foldMap gets the default implementation
09:43:53 <Cale> foldMap f = foldr (mappend . f) mempty
09:44:13 * byorgey tries to get his head around that definition of foldr for Seq
09:44:59 <byorgey> this is Seq from Data.Sequence?
09:45:26 <Cale> yes
09:45:51 <Cale> byorgey: it's foldr'ing over the FingerTree which the Seq constructor just wraps
09:46:31 <mrd> trees with fingers freak me out
09:46:44 <Syzygy-> What are those?
09:46:50 <byorgey> Cale: hm, ok
09:46:52 <Syzygy-> The same as trees with half-edges?
09:46:57 <doserj> foldr f z (Deep _ pr m sf) = foldr f (foldr (flip (foldr f)) (foldr f z sf) m) pr
09:46:57 <byorgey> it's been too long since I read that paper
09:47:01 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
09:47:03 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
09:47:11 <Cale> "Simple"
09:47:12 <Cale> hehe
09:47:21 * byorgey rolls his eyes
09:47:26 <doserj> that's from the Foldable instance for Fingertrees
09:47:27 <quicksilver> Cale: I'm not sure there is anything much wrong with foldMap
09:47:58 <quicksilver> anyhow, it's pretty odd that Data.Sequence doesn't have filter
09:48:09 <Cale> quicksilver: probably not. I do sort of wonder if something which operated directly on the trees would work better.
09:48:35 <quicksilver> and I think you can make a case for filter in Foldable
09:48:41 <quicksilver> sure, it has an extra Monoid constraint
09:48:45 <quicksilver> but it's a useful function
09:49:03 <quicksilver> I actually think length should be a *method* of Foldable
09:49:05 <Cale> I'm a little scared of some of the operations on Data.Sequence because I've had good and bad experiences with that data structure.
09:49:20 <Cale> It's very good as long as you're never reduced to going through it linearly.
09:49:26 <quicksilver> presumably if you're not using [], fusion doesn't work?
09:49:34 <quicksilver> so all the clever ghc optimisations for that go to pot
09:49:44 <Cale> Well, it theoretically could work.
09:49:49 <quicksilver> you are better bracketing your stuff in toList/fromList
09:49:52 <Cale> But there's probably no rules for it.
09:50:01 <quicksilver> toList/fromList are build/foldr written
09:50:21 <quicksilver> so fromList . map f . map g . toList will fuse
09:50:30 <quicksilver> but presumably fmap f . fmap g won't
09:50:56 <Cale> That's not quite ideal though. There's going to be Streams with fusion soon enough :)
09:51:00 * quicksilver nods
09:51:10 <quicksilver> anyhow, foldable needs a length method
09:51:29 <Cale> really?
09:51:34 <quicksilver> foldr (const (+1)) 0 works
09:51:39 <quicksilver> if I got that right
09:51:39 <Cale> Oh, I suppose it could use one.
09:51:44 <quicksilver> so it's type-safe
09:51:48 <quicksilver> but it would be better as a method
09:51:53 <quicksilver> because some instances can do it faster :)
09:52:36 <quicksilver> Cale: can you think of an instance of Foldable which isn't a functor?
09:53:04 <quicksilver> I can think of instances where the functoriality isn't natural, relative to the fold
09:53:10 <quicksilver> but not instances where it doesn't exist at all
09:54:33 <Cale> The only thing I could think of is if somehow there was a type whose functoriality was only contravariant which was also Foldable, but that sounds implausible.
09:55:14 <quicksilver> while we're pondering, I find Traversable slightly baffling. Functor gives you map, and Foldable gives you mapM_
09:55:27 <quicksilver> it seems sensible to suggest that Functor and Foldable together would be enough to give you mapM
09:55:38 <quicksilver> becuase mapM is just like aspects of map and mapM_
09:55:40 <quicksilver> but it isn't :)
09:58:21 <oerjan> mapM_ throws away the internal structure...
09:58:28 <quicksilver> right
09:58:37 <quicksilver> but map (fmap) keeps it
09:58:43 <quicksilver> so the two together....
10:04:24 <oerjan> > runState (mapM (\_ -> do modify (+1); get) $ repeat ()) 0
10:04:26 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:05:50 <oerjan> > runState (mapM (\_ -> do modify (+1); get) $ M.fromList[(i,()) | i <- [0..100]]) 0
10:05:51 <lambdabot>  Couldn't match expected type `[a]'
10:05:52 <EvilTerran> i was thinking something involving Writer (or WriterT) might work
10:06:50 <oerjan> > runState (Data.Traversable.mapM (\_ -> do modify (+1); get) $ M.fromList[(i,()) | i <- [0..100]]) 0
10:06:52 <lambdabot>  (fromList [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,...
10:08:00 <oerjan> you can get something like mapM except it produces a list instead
10:08:09 <quicksilver> yes
10:08:13 <quicksilver> that's quite true
10:08:20 <quicksilver> it's reconstructing the old "shape" that's tricky
10:08:34 <quicksilver> but the bit that feels, intuitively, wrong
10:08:43 <quicksilver> is that 'fmap' has the power to reconstruct the old shape...
10:08:57 <quicksilver> but somehow not in a way which you can combine correctly
10:09:04 <oerjan> on the other hand, if you start with something filled only with ()'s as above...
10:09:22 <oerjan> then you have no way of constructing anything whose entries are not constant
10:09:40 <oerjan> i think
10:09:58 <oerjan> *anything structure-preserving
10:11:07 <quicksilver> oerjan: yes, that is correct
10:11:14 <quicksilver> oerjan: since fmap only lets you apply functions
10:11:21 <quicksilver> oerjan: and functions can only return one answer for () :)
10:11:31 <quicksilver> oerjan: so you have your finger on the nub of it
10:11:34 <quicksilver> but still, it feels odd to me :)
10:11:38 <quicksilver> slightly mysterious
10:11:42 <mrd> if cabal is looking for Distribution.Simple.Setup does that mean the Setup.lhs file was written for Cabal 1.2?
10:12:19 <quicksilver> oerjan: I think it's porbably poor intuition to think of mapM as the 'core' of Traversable
10:12:26 <EvilTerran> going the other way's quite a lot easier
10:12:29 <quicksilver> oerjan: the 'core' is actually sequence, and that's the point.
10:12:47 <quicksilver> oerjan: you can just use fmap to get yourself a tree filled with monad actions
10:12:48 <EvilTerran> mapM -> mapM_ and mapM -> fmap are both pretty trivial
10:12:57 <quicksilver> oerjan: but you need sequence to execute them
10:13:00 <quicksilver> EvilTerran: right
10:13:06 <quicksilver> EvilTerran: mapM obviously decomposes to the two
10:13:14 <quicksilver> EvilTerran: but it is still 'more than the sum of the two'
10:13:24 <quicksilver> EvilTerran: you also need sequence
10:13:30 <quicksilver> (and then you don't need mapM_ any more)
10:13:41 <EvilTerran> yeah, fmap and mapM_ aren't a partition of mapM ;)
10:13:50 <quicksilver> but fmap and sequence are
10:13:54 <EvilTerran> i guess they intersect a bit as well as leaving gaps
10:14:18 <EvilTerran> @docs Data.Traversable
10:14:19 <lambdabot> Data.Traversable not available
10:14:25 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Traversable.html
10:14:27 <lambdabot> http://tinyurl.com/yr8jrn
10:14:32 <quicksilver> happen to have it open in a browser window ;)
10:14:34 <quicksilver> so that was easy
10:14:47 * EvilTerran remembers that xchat is broken, so that's not helpful anyway
10:15:03 <quicksilver> ewll the tinyrul is easy to copy
10:15:15 <EvilTerran> "open in browser"'s never worked on this computer, and since i updated, i can no longer copy-and-paste out of xchat either. it's very annoying.
10:15:21 <EvilTerran> i think i might switch client
10:15:37 <EspenG> d
10:16:09 <quicksilver> EvilTerran: I run irssi. And a terminal app which lets me click on links.
10:16:36 <EvilTerran> i suspect these problems come with the territory of using an unofficial port of a GTK app to windows
10:17:05 <oerjan> Salga por favor de mi silla.
10:17:08 <oerjan> argh
10:17:56 <oerjan> pasted instead of opening a menu
10:18:02 <sclov> ok i have a question about kinds. Arrow a needs a to be of *->*->*
10:18:10 <EvilTerran> yes
10:18:42 <sclov> So I'm trying to play with a list arrow of [(a->b)] but I can't get the kinds to match.
10:18:56 <sclov> Is this haskell's way of telling me this is a stupid idea?
10:19:05 <oerjan> you'll need a newtype
10:19:26 <oerjan> newtype LArr a b = [a -> b]
10:19:42 <oerjan> er, newtype LArr a b = LArr [a -> b]
10:19:48 <sclov> ah. that's irritating.
10:20:01 <sclov> oerjan++
10:23:53 <sclov> ok another stupid question -- how do I extract back out of the newtype?
10:24:10 <sclov> I think I know this but my brain is at half speed today.
10:25:14 <byorgey> sclov: pattern-match?
10:25:22 <Jaak> newtype Foo a = F a; unFoo (F x) = x
10:25:29 <byorgey> sclov: i.e. func (LArr foo) = ...
10:25:51 <sclov> oh my... make that one-sixteenth speed and grinding down.
10:25:53 <oerjan> may also want newtype LArr a b = LArr {getLarr :: [a -> b]}
10:26:07 <oerjan> then you can use the getLarr function
10:27:47 <oerjan> @src Cont
10:27:47 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
10:27:54 <oerjan> :t runCont
10:27:56 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
10:28:21 <oerjan> is an example
10:28:41 <byorgey> @src Sum
10:28:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:28:59 <byorgey> =(
10:29:20 <oerjan> newtype Sum a = Sum { getSum :: a } deriving (Eq, Ord, Read, Show, Bounded)
10:29:50 <fox86> i have managed to read a line from a file... how can i read lines (and eventually process them) until the end of the file? http://hpaste.org/3605
10:29:56 <oerjan> instance Num a => Monoid (Sum a) where mempty = Sum 0 Sum x `mappend` Sum y = Sum (x + y)
10:30:59 <oerjan> (add ; between 0 and Sum, irssi removes tabbed line breaks)
10:32:08 <oerjan> fox86: use hIsEOF h to check for EOF before each hGetLine
10:32:54 <oerjan> if you are not doing output between reads, hGetContents may be simpler
10:33:34 <oerjan> it reads the whole file into a String, lazily as needed
10:33:54 <EvilTerran> lines.hGetContents
10:34:02 <fox86> oerjan: hmm. i have a file with data such as "ABC  ADC" and i want to say something like "2 matching chars"
10:35:16 <oerjan> is this on two lines or on one?
10:35:29 <fox86> oerjan: the file is full of lines such as that one
10:35:57 <oerjan> each line containing two words separated by space?
10:36:05 <byorgey> > words "ABC   ADC"
10:36:07 <lambdabot>  ghc-6.6: could not execute: gcc
10:36:13 <byorgey> eh?
10:36:14 <fox86> oerjan: they are separated by tabs
10:36:19 <oerjan> ok
10:36:34 <byorgey> fox86: use 'words' to split them into words
10:36:51 <byorgey> fox86: then you can do something like zipWith (==) and count the Trues
10:36:56 <oerjan> byorgey: won't work if there may be spaces
10:37:18 <byorgey> oerjan: oh, does words produce empty words if there are multiple spaces?
10:37:22 <oerjan> > span (/= '\t') "ABC\tADC"
10:37:23 <lambdabot>  ghc-6.6: could not execute: gcc
10:37:24 <byorgey> I can never remember
10:37:36 <oerjan> *sigh
10:37:42 <oerjan> no, it doesn't
10:38:00 <byorgey> oerjan: oh, I see, you mean if the words contain spaces
10:38:07 <byorgey> true
10:38:17 <fox86> the words shouldn't contain spaces
10:38:24 <oerjan> to find the first tab and split on that, span is nice
10:38:24 <byorgey> ok, then words should work
10:38:47 <byorgey> what's wrong with \bot?
10:38:57 <fox86> oerjan: you're at the same uni as i am
10:39:00 <oerjan> @vixen Are you not feeling well?
10:39:01 <lambdabot> nevermind about that
10:39:25 <oerjan> fox86: ah.  actually i am using my old student account.
10:39:37 <oerjan> not really at uni any more
10:39:44 <fox86> oerjan: i see. i was beginning to think there were other haskellers at my uni
10:41:42 <oerjan> fox86: i recall a professor from math in a haskell web discussion a while ago at the GoodMath/BadMath blog, so there is at least one
10:42:07 <fox86> oerjan: ah, cool
10:42:20 <oerjan> not sure how deeply he was into it
10:45:39 <oerjan> anyway, your problem can be almost completely expressed as a chain of higher-order function
10:45:53 <oerjan> which is pretty common in haskell
10:47:52 <oerjan> although one thing is that explicit file close may not work well with lazy input from hGetContents
10:48:42 <bos> heh, it almost definitely won't work well.
10:50:00 <fox86> oerjan: hmm. i think i should start with some easier problems, because i'm pretty stuck. any recommendations on simple things i could try to program?
10:50:00 <oerjan> unless you are opening many files, explicit close is just a bother
10:50:20 <dons> i should just release System.IO.Strict
10:50:26 <dons> in the general strict package
10:50:28 <dons> hmm
10:51:09 <dnox> dons: any progress in hs-plugins or/for win lately?
10:51:09 * wli hasn't had issues with file handle closing since the Simons fixed the leak he tripped over when writing the imap module.
10:51:38 <dons> dnox: i don't maintain hs-plugins beyond the bare minimum, so unsure.
10:51:46 <oerjan> i thought your problem was fairly simple...
10:52:02 * mrd begins to compile ghc on an 8-way Xeon
10:52:06 <dnox> dons: oh is there no use for something like it anymore?
10:52:07 <fox86> oerjan: not for me ;)
10:52:33 <dons> dnox: oh, definitely. i just don't have time to maintain it much
10:52:41 <dons> just enough for lambdabot, basically
10:52:45 <dnox> ok
10:52:56 <dons> you could look at the ghc-api if you need loading that will work on windows
10:53:05 <oerjan> > 1+1 -- lambdabot is ill
10:53:06 <lambdabot>  ghc-6.6: could not execute: gcc
10:53:26 <dons> huh
10:53:27 <dons> nice.
10:53:44 <dons> i should move lambdabot to code.haskell.org
10:53:47 <allbery_b> dnox: someone realy needs to do an api-copmpatible replacement for hs-plugins using the ghc-api, to solve protabiulity and version skew issues
10:53:52 <dons> yep
10:54:05 * allbery_b notes he can't type again today :/
10:54:14 <dons> ?quit fishies
10:54:18 <dnox> allbery_b: not me though, i've used haskell way to little and got so much other to do :/
10:54:36 <dons> ?uptime
10:54:44 <lambdabot> uptime: 20s, longest uptime: 1m 10d 23h 44m 29s
10:54:47 <dons> > 1
10:54:54 <lambdabot>  ghc-6.6: could not execute: gcc
10:54:56 <dons> hmm
10:55:08 <dons> $ which gcc
10:55:09 <dons> /usr/bin/X11/gcc
10:55:11 <dons> ??!
10:55:23 <allbery_b> oh dear
10:55:27 <fox86> hehehe
10:55:27 <kosmikus> interesting
10:55:38 <allbery_b> someone botched openbsd's switch to the new x11 paths?
10:55:49 <allbery_b> or is /usr/bin/X11 a symlink to /usr/local/bin?
10:55:50 <dons> no, this is a university debian box
10:56:10 <allbery_b> /usr/bin/X11 -> . ?
10:57:02 <dons> yeah
10:57:11 <dons> is this some weird new debian thing?
10:57:27 <oerjan>  > worked 51 mins ago
10:57:39 <dons> hmm 4am Sydney time.
10:57:49 <allbery_b> /usr/bin/X11 is some new x.org thing
10:57:59 <allbery_b> making it == /usr/bin would be a standard Debian thing
10:58:20 <allbery_b> (well, a way to force x.org's new layout into Debian's standard layout)
10:58:26 <dons> > 1
10:58:27 <lambdabot>  gcc: error trying to exec 'as': execvp: Input/output error
10:58:33 <dons> urghsome
10:59:00 <dons> > 1
10:59:01 <lambdabot>  gcc: error trying to exec 'as': execvp: Input/output error
10:59:21 <dons> > 1
10:59:22 <lambdabot>  1
10:59:26 <dons> rocking
10:59:29 <allbery_b> (in fact it's really a very old thing; the X386 folks broke away from /usr/{bin,lib}/X11, XFreee86 continued it, x.org is switching back to old style)
10:59:38 <dons> > map (^2) [1..]
10:59:39 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
11:00:44 <Cale> gcc?
11:01:02 <wli> /usr/{bin,lib}/X11/ are bizarre and break from the longstanding /usr/X11R6/bin/ precedent (or for more recent, /usr/X11R7/bin/ etc.).
11:01:13 <allbery_b> wly: you're too young
11:01:17 <wli> > let f x = let t = sinh pi ; t2 = t * t ; c = cos x ; hi = recip t ; lo = recip . sqrt $ t2 + 1 in (2 * (recip . sqrt $ t2 + c * c) - (lo + hi))/ (hi - lo) ; g x = let gs = scanl1 (+) $ zipWith (*) (iterate (/2) (1/2)) [f (x / fromRational r) | r <- tail rationals] in snd . head . dropWhile (\(nxt, prv) -> abs ((nxt - prv)/(nxt + prv)) > 1e-12) $ zip (tail gs) gs in map g [0, 0.1 .. 3.1] :: [Double]
11:01:17 * Cale thought native code generation was the way of the future :)
11:01:17 <lambdabot>   Not in scope: `rationals'
11:01:28 <allbery_b> /usr/{X386,X11R6} was the break from tradition
11:01:53 <allbery_b> but you linux-is-the-world types are too young to remember anything else
11:01:58 <allbery_b> :)
11:01:59 <wli> Argh, rationals is huge.
11:01:59 <Cale> dons: You should add Math.OEIS to the lambdabot includes :)
11:02:18 <wli> allbery_b: Linux? I'm a Solaris baby.
11:02:36 <allbery_b> so why aren't you whininbg about /usr/openwin? :)
11:03:22 <dons> Cale: mmm!
11:03:31 <dons> Cale: want commit access to lambdabot ?
11:03:34 <wli> allbery_b: I remember it being there. It seemed too vendor-specific for me.
11:03:36 <dons> code.haskell.org/lambdabot
11:03:41 <dons> since that would be a great feature
11:03:49 <Cale> It's trivial to add :)
11:03:58 <dons> and i'm encouraging you to add it :)
11:04:02 <allbery_b> /usr/{X386,X11R6} was the same vendor braindamage as /usr/openwin
11:04:03 <wli> allbery_b: The SVR4-style affairs were also there.
11:04:12 <allbery_b> about time it ended
11:04:16 <Cale> hehe, all right, how do I commit the change?
11:04:37 <dons> do you have an account on code.haskell.org yet?
11:04:51 <Cale> no
11:04:59 <dons> please request one then, http://community.haskell.org/admin/account_request.html
11:05:00 <lambdabot> Title: Account Request
11:05:07 <dons> and igloo will add your ssh key
11:05:18 <dons> then you can darcs pull and push at will from code.haskell.org/lambdabot
11:05:49 <Cale> okay
11:06:05 <Cale> So, just the contents of id_dsa.pub goes in that box?
11:06:15 <wli> allbery_b: At least the SVR4 nomenclature was vendor-neutral and vaguely consistent with the rest of userspace. /usr/{bin,lib}/X11 invert the app category and bin vs. lib as compared to the rest of the universe.
11:06:17 <dons> yeah
11:07:13 * allbery_b shrugs
11:07:21 <allbery_b> blame the MIT folks for the original
11:07:39 <allbery_b> I could argue for /usr/X11/bin, but /usr/X11R?/bin iffy
11:08:01 <allbery_b> x.org revving to X11R7 showed the flaw in that setup
11:08:18 <oerjan> fox86: unless your program really needs interactive synchronization then in haskell it is often nice to let IO be a thin wrapper around a pure computation from strings to strings.  Something like main = putStr . processData =<< readFile filename
11:08:41 <wli> It was handy for having X11R5 and X11R6 apps simultaneously installed.
11:09:33 <fox86> oerjan: yes, i've seen an example like that
11:09:55 <allbery_b> R5/R6 wasn's a big enough leap to really need it, though.  think the last such was R3->R4
11:11:13 <oerjan> and then if it is doing something line by line you can do processData = unlines . map processLine . lines
11:13:11 <oerjan> so then you may just have left to write processLine
11:13:22 <jedbrown> Why would Data.Map not respect my new ordering?
11:13:23 <jedbrown> Should (sort . toAscList == toAscList)
11:13:45 <jedbrown> Should ((sort . toAscList) == toAscList)
11:13:48 <jedbrown> rather.
11:14:05 <Cale> it should
11:14:16 <Cale> as long as the Ord instance is a valid total ordering
11:14:44 <Cale> http://en.wikipedia.org/wiki/Total_order -- here's a list of the laws
11:14:45 <lambdabot> Title: Total order - Wikipedia, the free encyclopedia
11:14:51 <jedbrown> I believe it is.
11:14:56 <jedbrown> Let me paste.
11:15:20 <hpaste>  jedbrown pasted "My funny ordering" at http://hpaste.org/3606
11:16:15 <hpaste>  jedbrown annotated "My funny ordering" with "(no title)" at http://hpaste.org/3606#a1
11:16:29 <quicksilver> it's not obvious to me that is a total ordering
11:16:35 <quicksilver> I would write a quickcheck rule for the transitive property
11:16:40 <quicksilver> and see if QC can find anything
11:17:15 <oerjan> i think it is total
11:18:14 <oerjan> it's essentially comparing by (maximum $ dens p, reverse $ dens p, nums p)
11:18:45 <oerjan> (in fact you could simplify it to that)
11:18:47 <jedbrown> Yes, there may be a cleaner way to write that.
11:19:27 <oerjan> so the only question is whether it can treat unequal things as equal.
11:19:47 <oerjan> but since dens and nums give all information, it shouldn't.
11:19:51 <int-e> > map msum [[EQ, EQ], [LT, GT], [EQ, GT]]
11:19:52 <lambdabot>  Couldn't match expected type `m a' against inferred type `Ordering'
11:20:00 <Cale> uh, are you sure?
11:20:04 <Cale> hmm
11:20:36 <jedbrown> We only get EQ if dens match and nums match.
11:20:48 <int-e> > map mconcat [[EQ, EQ], [LT, GT], [EQ, GT]]
11:20:49 <Cale> yes, I suppose so
11:20:50 <lambdabot>  [EQ,LT,GT]
11:21:36 <int-e> oerjan: even if that would happen, the map would eliminate duplicate keys. besides, Data.List.sort is a stable sort.
11:21:52 <int-e> (I'm not sure whether Haskell 98 guarantees the latter.)
11:22:17 <int-e> nm,
11:22:17 <twanvl> it does
11:22:56 <Cale> H98 makes a lot of guarantees which it doesn't intend to make, but I think that's one which is probably safe to say :)
11:23:06 <int-e> the stable sort wouldn't help if the map contained duplicate keys.
11:23:58 <jedbrown> The issue is toAscList gives me (Point [1%2]) before (Point [1%1]) which is wrong.
11:24:28 <jedbrown> It isn't a stability issue.  Rather it seems to be not using my ordering at all.
11:24:51 <Cale> hmm
11:25:10 <Cale> And this is a (Set Point)?
11:25:18 <Cale> It really can't use any other ordering
11:25:29 <Cale> hmm
11:25:30 <jedbrown> It acts as though my definition for Point was deriving Ord.
11:26:24 <oerjan> > sortBy (comparing $ liftM3 (,,) (maximum . map denominator) (reverse . map denominator) (map numerator)) [[1%2], [1%1]]
11:26:26 <lambdabot>  [[1%1],[1%2]]
11:26:47 <jedbrown> However, Data.Set.toAscList gives me the correct ordering.
11:27:25 <jedbrown> oerjan: Oooh.  comparing-fu.
11:28:03 <Cale> *Main> testSet
11:28:03 <Cale> fromList [Point [1%1],Point [1%2]]
11:28:03 <Cale> *Main> S.toAscList testSet
11:28:03 <Cale> [Point [1%1],Point [1%2]]
11:28:15 <Cale> Your code works for me
11:28:38 <Cale> *Main Data.List> sort . S.toAscList $ testSet
11:28:38 <Cale> [Point [1%1],Point [1%2]]
11:28:42 <jedbrown> Cale: It works with sets for me.  But not with Map.
11:28:53 <int-e> > toAscList . fromList $ [(Point [1%2], 0), (Point [1%1],0)]
11:28:54 <int-e> [(Point [1%1],0),(Point [1%2],0)]
11:28:54 <lambdabot>   Not in scope: data constructor `Point'
11:28:56 <jedbrown> Cale: strangely.
11:28:57 <Cale> Oh, your map is indexed by Points?
11:29:12 <jedbrown> Yes.
11:29:23 <Cale> what are the values in the map?
11:29:30 <jedbrown> Cale: Map Point Double
11:29:33 <int-e> can you show more complete code?
11:29:34 <Cale> okay...
11:30:48 <Cale> *Main> M.toAscList testMap
11:30:48 <Cale> [(Point [1%1],0.66),(Point [1%2],0.65)]
11:30:54 <Cale> works for me?
11:31:19 <jedbrown> Cale: ghc6.6.1?
11:31:28 <Cale> yes
11:31:45 <Cale> Make sure that you don't have stray .o files lying around
11:31:55 <oerjan> jedbrown: no modules that have not been recompiled, reloaded or something?
11:32:32 <oerjan> (which i think is the same as what Cale said)
11:32:37 <jedbrown> No, I'm running in the interpreter and have reloaded.
11:32:42 <int-e> no unjustified use of fromAscList or similar functions?
11:32:53 <Cale> But the interpreter will load .o files if they're available.
11:33:22 <Cale> testMap = M.fromList [(Point [1%2], 0.65), (Point [1%1], 0.66)]
11:33:30 <Cale> that's the map I'm using to test it
11:35:36 <jedbrown> Okay, I have (toAscList.fromList.toAscList /= toAscList)
11:36:35 <jedbrown> Which is awful strange.
11:37:08 <Cale> Is your Map consistent?
11:37:34 <Cale> i.e. does  valid  give True when applied to it?
11:38:08 <dino-> I'm having a strange problem, working on a Gentoo-based server at work, they installed the ghc (6.6.1) for me. But I get odd errors when compiling things and ghci just dies with "Loading package base ... linking ... done.\nKilled"
11:38:39 <dons> what arch?
11:38:45 <dino-> Wondering if we have any Gentooers here to whom that looks familiar. Not finding much on the big G.
11:38:45 <hpaste>  (anonymous) annotated "My funny ordering" with "strangeness" at http://hpaste.org/3606#a2
11:38:53 <dino-> dons: Unsure beyond i686
11:39:02 <dons> not seen that. sounds like ghci is broken somehow
11:39:04 <dino-> I don't have perms to cat /proc/cpuinfo
11:39:22 <jedbrown> Cale: no, valid gives False.
11:39:54 <Cale> jedbrown: That'd be your problem then
11:40:05 <dino-> dons: Ok. Thank you.
11:40:06 <int-e> jedbrown: so what does sampleCFunc do to build the map?
11:40:13 <Cale> jedbrown: How are you creating the map?
11:40:17 <c> dino-: ulimit -a. maybe watch memory use?
11:40:37 <jedbrown> Cale: I found the problem:
11:40:38 <jedbrown> sampleCFunc f = M.fromDistinctAscList . L.map (id &&& (f . physical))
11:40:49 * int-e sighs
11:40:58 <Cale> doh
11:41:07 <jedbrown> And the ordering I generate the points on is no longer ordered.  Now that I changed the ordering.
11:41:14 <int-e> I did ask about fromAscList and friends 8 minutes ago.
11:41:14 <Cale> Use fromList unless you're really really sure
11:41:48 <jedbrown> Cale: It used to be, but then I screwed with the ordering.
11:42:02 <dino-> c: I see a lot of 'unlimited' in there.
11:42:06 * jedbrown feels stupid, but much happier now.
11:43:54 <calvins> Good afternoon everybody! I'm trying to fix a space leak and have a question about GHC and the UNPACK pragma and strict constructor fields...
11:44:05 <calvins> What are the conditions that would cause this not to be an optimization?
11:44:16 <calvins> If I read the GHC doc correctly, pattern matching on the constructor is okay and will not cause reboxing, but being passed to a function that takes the value as a non-strict function WILL cause reboxing.
11:44:22 <calvins>  Is this correct?
11:44:30 <calvins> Are there other ways that reboxing can be forced?
11:45:11 <Cale> Passing an unboxed thing to a polymorphic function will force it to be boxed.
11:45:13 <calvins> I meant "as a non-strict argument"
11:45:33 <calvins> Ah, okay. That's helpful.
11:45:37 <Cale> (at least, I can't imagine how it wouldn't)
11:46:17 <calvins> Is it correct that pattern matching is okay if the argument is strict?
11:46:32 <calvins> pattern matching on the constructor
11:47:32 <Cale> hmm
11:47:46 <Cale> pattern matching on something makes that argument strict
11:48:14 <Cale> (because you have to evaluate the argument in order to decide which pattern matches)
11:48:55 <calvins> oh, okay. i was making the argument strict, like: f !(T foo) = foo
11:48:57 <sclov> .msg lamdabot @djinn [a->b] -> [(a,c)->(b,c)]
11:49:07 <calvins> so perhaps the bang pattern is redundant
11:49:18 <oerjan> calvins: unless T is a newtype it is redundant
11:49:24 <Cale> Unless T is a newtype, yeah
11:49:25 <sclov> .msg lamdabot @djinn [a->b] -> [(a,c)->(b,c)]
11:49:47 <calvins> hmmm, why is newtype different?
11:50:01 <Cale> Newtype constructors don't really "exist"
11:50:08 <oerjan> sclov: /msg
11:50:15 <sclov> oerjan -- yeah, slippery fingers
11:50:23 <Cale> They're simply there to let the type system do its thing and are gone by the end of compilation
11:50:25 <oerjan> however, djinn doesn't understand lists
11:50:52 <Cale> So pattern matching (T foo) doesn't take any work when T is a newtype
11:51:01 <calvins> okay, that makes sense why pattern matching wouldn't do anything and it wouldn't be strict
11:51:01 <Cale> (and doesn't do any evaluation)
11:51:27 <calvins> any general hints anybody can offer for tracking down space leaks?
11:51:33 <dons> profile!
11:51:34 <calvins> I've been profiling using GHC
11:51:37 <Cale> heap profiling
11:51:43 <dons> ghc -prof -auto-all ?
11:51:50 <calvins> that's what I have, dons
11:51:51 <dons> then inserting cost centres on interesting subexpressions
11:52:07 <dons> {- SCC "suspicious" -} my expr
11:52:11 <calvins> but I see a call to List.sort where all the allocation is happening, and nothing more than that
11:52:23 <dons> maybe its not a space leak then?
11:52:31 <dons> are you just using lists inapparopriately?
11:52:46 <calvins> well, it is a very small list, with only 30 items or so
11:52:54 <dons> hmm, sounds like you might have missed -auto-all flag?
11:53:12 <Cale> Can we see the profiling output?
11:53:14 <dons> yeah
11:53:16 <Cale> !paste
11:53:16 <hpaste> Haskell paste bin: http://hpaste.org/
11:53:23 <calvins> okay, will paste
11:53:27 <dons> and double check you compiled with both -prof -O and -auto-all
11:53:27 <sclov> Whew! \bot solved my type problem!
11:53:31 <dons> sclov: :)
11:57:49 <fasta> Ok, I found another annoying thing about Haskell.
11:58:51 <Philippa> took you that long?
11:58:56 <fasta> I have a list of (String, <heavily overloaded function type>). I only use the first component of this list in another function.
11:59:33 <fasta> It then claims there are no instances that are that general.
12:00:13 <Philippa> yeah, so laziness doesn't get you out of being well-typed
12:00:18 <twanvl> The string could depend on the type of the second part
12:00:19 <nominolo> use zip variant with polymorphic recursion
12:00:43 <Philippa> because if it did then Haskell'd just be a dynamically-typed language with a smart implementation
12:00:51 <Cale> I don't understand your situation.
12:00:57 <Philippa> you could always pass in undefined?
12:01:17 <Cale> The function which you're trying to call is a class function?
12:01:28 <hpaste>  calvins pasted "profiling output for memory problem" at http://hpaste.org/3607
12:01:31 <fasta> Cale: the problem is that I do not call the function.
12:01:45 <Cale> Why are you passing both components if you're only using the String?
12:01:58 <fasta> Cale: because I still had that list and wanted to reuse some code.
12:02:06 <Cale> map fst
12:02:11 <calvins> i pasted. it cut off most of the profile output, but the important stuff is showing...
12:02:19 <nominolo> zipPoly :: [(String, forall a. Foo a -> b)] -> [String]
12:02:36 <nominolo> should be possible to implement
12:02:49 <nominolo> (and typecheck)
12:02:53 <Cale> calvins: Okay, clearly a lot of allocation is done in 'ordered'
12:03:03 <araujo> The lambda is your master .... Follow the lambda .... Praise the lambda .... http://xach.com/misc/lambda.html
12:03:08 <calvins> yeah, intuitively it seems way, way too much
12:03:12 <fasta> nominolo: But that requires me to first wrap it.
12:03:37 <fasta> Cale: I used forM_ foos $\(str, _)
12:03:43 <Cale> calvins: That doesn't necessarily mean that this is what's causing high memory usage, just that the allocation is happening there
12:04:05 * oerjan goes insane and starts running after araujo with a polymorphic axe
12:04:10 <calvins> yeah, it could be happening anywhere due to laziness, right?
12:04:19 <nominolo> fasta: you can always chose a language without sensible type inference
12:04:19 <araujo> muahahaha
12:04:44 <Cale> fasta: and it complains?
12:04:48 <oerjan> oh wait, i was insane already. nevermind.
12:04:51 <Cale> fasta: what's the type of foos?
12:05:26 <roconnor> \me worries about the lack of polymorphism in ($)
12:05:44 <nominolo> :t ($)
12:05:50 <Cale> well, foos must have some type [(a,b)] for some a and some b
12:05:52 <lambdabot> forall a b. (a -> b) -> a -> b
12:06:00 <oerjan> oh right, essentially the runST issue again?
12:06:09 <Cale> no, that can't be happening here
12:06:22 <roconnor> oh, okay
12:06:23 <fasta> Cale: I tried with map fst and it doesn't work.
12:06:23 <nominolo> roconnor: you mean add a class-constrained variant of ($) ?
12:06:31 <Cale> fasta: what's the type of foos?
12:06:33 <Philippa> fasta: why the $?
12:06:40 <fasta> Philippa: convenience
12:06:46 <oerjan> fasta: what happens if you replace $ with parentheses?
12:06:50 <fasta> oerjan: same issue
12:06:54 <fasta> oerjan: already tried that
12:06:58 <Cale> fasta: what's the type of foos?
12:07:00 <Philippa> for that matter, where's the rest of the lambda body?
12:07:09 <Cale> Philippa: presumably on the next lines
12:07:11 <roconnor> nominolo: some versions of GHC don't allow the arguments of $ to be polymorphic.
12:07:17 <Cale> That's an idiom with forM_
12:07:23 <roconnor> nominolo: rumour has it it is fixed in 6.8
12:07:27 <nominolo> roconnor: oh.  didn't know that
12:07:29 <Cale> forM_ somelist $ \x -> do
12:07:30 <Cale>   ...
12:07:48 <Cale> saves you from typing a close paren at the end of the do block
12:08:04 <MyCatSchemes> :t forM_
12:08:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:08:09 <kosmikus> roconnor: I don't think it's fixed in general. My understanding was that a quick hack has been added to make it work in some frequently used cases.
12:08:26 <MyCatSchemes> Cale: forM is foldM with the arguments swapped?
12:08:27 <fasta> I have not found it to be fixed in any case.
12:08:29 <oerjan> roconnor: rumor has it the hack was so awful it was removed again.
12:08:32 <Cale> fasta: you never answered me
12:08:35 <fasta> I use 6.9
12:08:39 <fasta> Cale: I am working on that
12:08:44 <fasta> Cale: It takes quite long to load
12:09:06 <hpaste>  calvins annotated "profiling output for memory problem" with "the relevant compare functions" at http://hpaste.org/3607#a1
12:09:13 <Cale> MyCatSchemes: it's mapM with the args swapped
12:10:08 <Cale> calvins: why is everything strict?
12:10:08 <hpaste>  calvins annotated "profiling output for memory problem" with "more code for memory problem" at http://hpaste.org/3607#a2
12:10:41 <calvins> Cale: i tried making everything strict and UNPACKing the Node type to see if I could reduce memory consumption
12:10:42 <Cale> Holy bang-patterns batman
12:10:52 <MyCatSchemes> Cale: ohhhhh, my bad, danke.
12:11:11 <calvins> I had the problem initially when everything was lazy and not using bang patterns, then I went bang-pattern crazy, as you noticed.
12:11:42 <Cale> Usually just one will do it, if well-placed
12:11:58 <fasta> Cale: http://paste.debian.net/41339
12:12:00 <calvins> i wasn't sure, so used the shotgun approach
12:12:01 <Cale> ordered !ts = sort $! ts -- this is redundant
12:12:13 <calvins> the $! is redundant, you mean
12:12:16 <Cale> yes
12:12:22 <calvins> because the bang pattern already does it.
12:12:24 <Cale> also, sort is strict
12:12:30 <Cale> so there's no point at all
12:12:36 <fasta> Cale: (that's the type)
12:13:06 <calvins> yeah, i figured that, my paranoia got the better of me, and I kept adding more and more in case i was not understanding when strictness occurs..
12:13:25 <Cale> fasta: it can't determine which instance you want, because you only use the first component of the pairs. Specify a concrete type for foos, and it will know which instance is needed in order to compute foos.
12:13:36 <roconnor> I see an ST!
12:13:38 <roconnor> :)
12:13:54 <Cale> The ST isn't the problem
12:14:03 <roconnor> Cale: sorry, you are right
12:14:05 <oerjan> calvins: sometimes strictness can make it _worse_, i hear
12:14:25 <Cale> calvins: okay, so let's take a look at what your code is actually doing...
12:14:35 <calvins> oerjan: yeah, i realize that, but the problem existed when everything was completely lazy. it was actually worse initially.
12:14:47 <Cale> can you give me an overview of the structure of the computation?
12:15:01 <calvins> at the end of the day, the expensive thing that is happening is bytestring comparisons
12:15:04 <calvins> okay, overview:
12:15:18 <calvins> i have a list of triples, which is a 3-tuple of Node objects
12:15:34 <calvins> Nodes can be of several different types, represented by the ADT Node
12:15:57 <calvins> when i sort a bunch of triples, i want to sort in the intuitive way:
12:16:08 <Cale> is the Node a recursive type?
12:16:25 <calvins> UNode before BNode, BNode before BNodeGen, and BNodeGen before LNode..
12:16:25 <Cale> or will nodes generally be individually small?
12:16:28 <calvins> no, not recursive
12:16:34 <Cale> okay
12:16:45 <Cale> So if there's lots of data, it's because of the list
12:17:01 <calvins> the nodes have a FastString type that contains the actual data value
12:17:11 <calvins> FastString is an Int and a ByteString
12:17:19 <calvins> the Int allows for fast equality testing
12:17:23 <Cale> okay
12:17:28 <calvins> and otherwise I have to do ByteSTring comparisons
12:17:32 <Cale> A strict or lazy bytestring?
12:17:35 <calvins> Strict
12:18:09 <Cale> all right, so as soon as it first needs any individual bytestring, it will completely evaluate it and allocate memory for it
12:18:26 <Cale> What's the typical length of one of these?
12:18:31 <calvins> yeah, and i've tried to force that to be strict so that it will have happened a long time ago
12:18:49 <calvins> around 30 to 40, which can get really expensive to do lots of comparisons...
12:19:14 <calvins> so since most of the bytestrings have a common prefix for almost all of the string value, i store them in reverse...
12:19:36 <calvins> so that the comparison will only need a few characters to test for the comparison
12:19:44 <Cale> all right
12:20:22 <calvins> originally, the bytestrings come from parsec and String values, but I convert to bytestring as early as possible and do not use plain strings anymore..
12:20:32 <Cale> I don't think you can unpack a bytestring into a constructor.
12:20:45 <Cale> So it's still going to be a pointer.
12:21:19 <int-e> it's a single constructor datatype, sure you can unpack it
12:21:26 <Cale> oh, right
12:21:31 <Cale> okay, it's really just a Ptr
12:21:37 <calvins> okay
12:22:09 <Cale> So yes, you can, but it's not quite the same as packing the contents of the ByteString into the constructor.
12:22:23 <calvins> but it shouldn't cause problems, right?
12:22:30 <Cale> no, that's fine
12:22:46 <Cale> run the program with +RTS -hc
12:22:56 <calvins> will do, what is hc?
12:22:58 <Cale> and run hp2ps on the resulting .hp file
12:23:07 <Cale> Heap profiling by cost centre
12:23:08 <calvins> ah, heap profiling?
12:23:09 <int-e> I wonder what happens if you replace the  ordered  function by one that just forces the whole list.
12:23:17 <calvins> okay, will do now...
12:23:39 <calvins> int-e: you mean not sorting, or forcing and then sorting?
12:23:39 <Cale> ordered does force the whole list already of course.
12:23:52 <Cale> But it also sorts it
12:23:58 <int-e> I meant not sorting at all.
12:24:01 <calvins> just a sec, will run with -hc...
12:25:01 <Cale> calvins: Also note that you don't need a bang pattern on anything which does a proper pattern match.
12:25:19 <calvins> there is no problem if i don't sort
12:25:25 <Cale> calvins: Bang patterns are only meaningful when applied to single variable patterns or newtypes
12:25:30 <calvins> Cale: thanks, i'll remember that
12:25:55 <Cale> because in order to decide which pattern matches, it has to evaluate the value as far as the bang pattern will anyway
12:26:13 <int-e> @index rnf
12:26:13 <lambdabot> Control.Parallel.Strategies
12:26:23 <fasta> Cale: isn't there some ultra-generic function that can express fst without wrapping?
12:26:37 <Cale> fasta: The problem is not actually the fst.
12:27:05 <Cale> fasta: It's that the resulting list of pairs depends on the type of the second component of those pairs.
12:27:29 <fasta> Cale: the problem is that since the function isn't used, the type still contains type variables and there is no instance with type variables in it.
12:27:34 <calvins> is there a way to upload an attachment to hpaste? i have the ps file, which doesn't look terribly helpful. just confirms that something is very wrong
12:27:40 <fasta> Cale: right?
12:27:41 <Cale> fasta: It can't possibly know which code to use to generate the list without knowing the full type of the list of pairs, so that it knows which instance to use.
12:28:13 <Cale> It's similar to the problem you have with:
12:28:15 <fasta> Cale: this is a decidable problem
12:28:29 <fasta> Cale: in the concrete way I use it in my program.
12:28:35 <fasta> Cale: it's simply a compiler limitation.
12:28:48 <fasta> Cale: and one that will never be accepted as "bug"
12:28:50 <Cale> I don't think it is.
12:29:03 <fasta> Cale: since it complicates the implementation with lots of special cases.
12:29:04 <Cale> I think it's not possible to know which code is supposed to be used.
12:29:38 <fasta> Cale: Oh, I see I didn't explicitly tell you that the first list is constant.
12:30:15 <fasta> Cale: this implies that map fst will always return the same value, assuming lazy list components.
12:30:19 <Cale> fasta: see that humongous typeclass context on the type of algorithms_names2?
12:30:53 <Cale> it's a *parameter* to algorithms_names2
12:31:13 <Cale> That is, algorithms_names2 is really a function.
12:31:31 <Cale> Without that parameter, there is *no way* that it can calculate the list.
12:31:34 <fasta> Cale: in the implementation it's a function.
12:31:48 <Cale> Well, semantically as well.
12:32:08 <fasta> Cale: AFAIK, in this case it holds that for any implementation of the type class it holds that map fst returns the same
12:32:12 <Cale> Unless you know which instance is to be applied to the type context, you can't know the value you get.
12:32:25 <fasta> Cale: can you provide an example in which my "
12:32:31 <fasta> Cale: theorem" is not true?
12:33:09 <Cale> You can't know which instances exist.
12:33:20 <Cale> Because future modules can always define new ones.
12:33:34 <fasta> Cale: I know that, but still I believe that.
12:33:44 <fasta> Cale: just provide a counter-example if you know one.
12:34:06 <Cale> A counterexample to what?
12:34:31 <hpaste>  sclv pasted "List Arrows" at http://hpaste.org/3608
12:36:12 <calvins> how about bang patterns inside a pattern match: foo (T !f) = f, where T is not a newtype. In that case, it is required to ensure strictness, right?
12:36:42 <fasta> Cale: I claim that regardless of what instance one defines for my type class(any type class), map fst will still return the same result.
12:37:05 <Cale> It will cause f to be evaluated up to determining its top level constructor, as if you'd pattern matched on the top level constructor of f
12:37:07 <fasta> Cale: It should be the same as: map fst [("a",show)]
12:37:15 <Cale> fasta: I don't have your code.
12:37:32 <fasta> Cale: The only problem is that ghci "solves" that already
12:37:39 <Cale> huh?
12:37:41 <fasta> Cale: there is a flag to disable that, though
12:38:07 <Cale> Should I give you an example with similar types where the instance used matters?
12:38:14 <eventualbudda> is the Clean language still active? i was reading something about it vs haskell, but it seems kinda dormant
12:38:20 <fasta> Cale: that would be perfect
12:39:01 <calvins> so foo (T !f) = ... does not cause f to be evaluated in and of itself?
12:40:23 <Cale> !paste
12:40:23 <hpaste> Haskell paste bin: http://hpaste.org/
12:41:16 <hpaste>  Cale pasted "example" at http://hpaste.org/3609
12:41:52 <Cale> calvins: only when foo x is evaluated of course
12:42:20 <Cale> It'll evaluate x, and if it matches T f, it'll evaluate f before returning the RHS of the equation
12:42:35 <Cale> eventualbuddha: it's not terribly active
12:42:44 <calvins> okay, that's what i thought, thanks
12:42:49 <Cale> eventualbuddha: It still has some users, but not nearly as active as Haskell
12:43:08 <Cale> calvins: But note that if f is something like a list, this only means evaluating it up to the first cons cell.
12:43:31 <Cale> (not necessarily even the contents of the first element of the list!)
12:43:45 <eventualbuddha> Cale: the benchmarks i saw were saying that it's (somewhat) faster than Haskell, but i didn't see a date on the benchmarks. know whether that's still the case?
12:44:05 <calvins> yeah, i realize that about lists and related types..
12:44:06 <Cale> eventualbuddha: GHC is getting better, it's fairly competitive now.
12:44:23 <calvins> i'm going to go through my code and remove the unnecessary bang patterns and try to clean things up...
12:44:23 <MyCatSchemes> eventualbuddha: it is, unfortunately. GHC's getting faster all the time, though, fortunately.
12:44:38 <Cale> eventualbuddha: Clean had a really good native code generator
12:44:39 <calvins> thanks for the help Cale
12:44:43 <calvins> how do i give karma?
12:44:47 <Cale> calvins: Cale++
12:44:51 <calvins> cale++
12:44:53 <calvins> cale++
12:44:55 <eventualbuddha> Cale, MyCatSchemes: cool, thanks for the info
12:45:01 <Cale> calvins: any luck with the memory usage?
12:45:18 <Cale> calvins: how does the heap profile look?
12:45:23 <calvins> i will clean things up based on the better understanding i have now
12:45:25 <eventualbuddha> Cale: what does ghc generate?
12:45:30 <fasta> Cale: interesting example
12:46:06 <calvins> the heap profile just shows 2 functions that have absurd amount of allocation, but the names get truncated, so I'm not sure exactly where it's happening within ordered/...
12:46:08 <fasta> Cale: actually, it's not the same
12:47:04 <fasta> Cale: but it seems the a parameter can be changed to String, right?
12:47:11 <Cale> fasta: of course
12:47:12 <fasta> Cale: which would make it the same problem.
12:48:02 <Cale> eventualbuddha: Well, it generates native code, just not as well as the Clean compiler could. However, they've got some really smart people working on it now, and they'll apparently be doing lots more work on GHC's code generator throughout this year and 2008.
12:48:41 <eventualbuddha> Cale: sweet. now i just need a project to use haskell so i can learn it..
12:48:46 <Cale> eventualbuddha: They're at the point where single optimisations are providing 15% speedups and such.
12:49:04 <Cale> (across a fairly comprehensive benchmark library)
12:50:32 <Cale> eventualbuddha: also, we're already at the point where we can be competitive with C in some cases
12:51:04 <Cale> For example, some code using bytestrings can actually come out faster than the equivalent (library-function-calling) C code.
12:51:29 <shapr> Where's the latest ghc 6.8 source tarball?
12:52:22 <Cale> eventualbuddha: GHC's RULES mechanism is really nice
12:52:42 <Cale> eventualbuddha: It means that library authors can put domain-specific optimisations into their libraries.
12:53:18 <Cale> eventualbuddha: which means that, after inlining, various algebraic transformations can take place on code which no C compiler could ever hope to figure out.
12:54:30 <Cale> Between this sort of thing and concurrency, I'll be surprised if the average Haskell program doesn't run faster than the average C program in 10 years.
12:55:22 <huamn_> hmm, I have a problem when implementing Show to my own type because it seems that I get extra "" around my strings which I do not want ... I'm basicly doing like: shows ("Foo " ++ (show 234)) and using showsPrec
12:56:06 <Cale> huamn_: how are you displaying the result?
12:56:32 <huamn_> when i say (show mytype) ghci prints out "\"Foo 234\""
12:56:47 <Cale> ah, right, yes
12:57:01 <Cale> your problem is that the show instance for Strings adds quotes
12:57:17 <huamn_> How can I prevent that?
12:57:18 <Cale> so, remove the shows there, and you should be fine
12:57:23 <huamn_> hmm
12:57:33 <huamn_> ah, I just return the string?
12:57:41 <Cale> Well, from show, yes
12:57:52 <calvins> Oops, mispelled as cale earlier.. Cale++ Cale++
12:57:57 <calvins> Cale++
12:58:06 <calvins> doesn't lambdabot respond when it happens?
12:58:16 <Cale> nope
12:58:19 <Cale> @karma
12:58:19 <lambdabot> You have a karma of 54
12:58:25 <Cale> but the effect happens :)
12:58:36 <huamn_> Cale, but I'm trying to create a function which has a type signature like showsMyMsg :: MyMsg -> ShowS
12:58:58 <Cale> huamn_: Well, type ShowS = String -> String
12:59:13 <Cale> > shows 5 . shows 8 $ ""
12:59:15 <lambdabot>  "58"
12:59:18 <Cale> > shows 5 . shows 8 $ "hello"
12:59:20 <lambdabot>  "58hello"
12:59:39 <Cale> shows is just supposed to prepend the shown string
13:00:07 <Cale> however, you don't have to implement showsPrec or shows by hand
13:00:21 <Cale> Just implement show, and it'll handle the other two with default instances.
13:00:27 <nbb> hi, FFI gurus! what's the best way to read a C struct from a posix file descriptor? fdRead returns String, hGetBuf wants Handle ...
13:00:28 <Cale> er, default methods
13:01:28 <Cale> @hoogle Fd -> IO Handle
13:01:29 <lambdabot> No matches, try a more general search
13:01:29 <Lemmih> nbb: See 'fdToHandle'.
13:01:40 <Cale> yeah, you want fdToHandle
13:02:01 <Cale> Why didn't Hoogle find that?
13:02:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#v%3AfdToHandle
13:02:12 <lambdabot> http://tinyurl.com/ypw9v7
13:02:36 <Cale> @hoogle fdToHandle
13:02:36 <lambdabot> No matches found
13:02:45 <nbb> that should do, thanks!
13:02:47 <Cale> I guess it just doesn't index the Posix library.
13:06:46 <dmwit> Is there a place I can browse the module hierarchy?
13:07:34 <hpaste>  huamn pasted "Extra """ at http://hpaste.org/3610
13:07:49 <Cale> dmwit: There is, for the packages that come with GHC
13:07:52 <conal> dmwit: there's http://www.haskell.org/ghc/docs/latest/html/libraries/
13:07:55 <huamn_> Cale, could you take a look at that, because I didn't quite grasp the idea :(
13:07:56 <Cale> right
13:08:07 <dmwit> Cale, conal: Thanks.
13:08:17 <huamn_> there's a simple example of my problem, how should I do it to not add the extra "" with that shows
13:08:34 <Cale> huamn_: Is there a particular reason you're implementing showsPrec and not just show?
13:08:48 <huamn_> that's how it was done in the gentle introduction to Haskell :P
13:08:58 <conal> hackage builds lots of docs, but i don't know if it gives any kind of overall (cross-package) module hierarchy view
13:08:58 <Cale> your problem is that shows which is applied to "Foo " ++ a ++ " " ++ (show b)
13:09:04 <Cale> which is a string
13:09:21 <Cale> > shows "Hello"  "...extra"
13:09:23 <lambdabot>  "\"Hello\"...extra"
13:09:36 <Cale> see, the show instance for strings quotes them
13:09:46 <Cale> You can write:
13:09:56 <Cale> showsFoo (Foo a b) x = "Foo " ++ a ++ " " ++ (show b) ++ x
13:10:00 <Cale> if you really want
13:10:20 <huamn_> but what should I really write? =)
13:10:28 <Cale> instance Show Foo where
13:10:37 <Lemmih> I'd write: showsProc _ (Foo a b) = showString "Foo" . showString a . shows b
13:10:38 <Cale>    show (Foo a b) = "Foo " ++ a ++ " " ++ (show b)
13:11:04 <huamn_> I remember seeing some discussion that ++ -additions are slow
13:11:17 <Cale> Yeah, that's what the ShowS stuff is designed to avoid
13:11:42 <Cale> They're only slow however if you have a large number of small appends to the end of a string.
13:12:00 <huamn_> which is why I tried to do it with the ShowS -stuff... is there a way to do it with those ShowS-things without adding extra quotes?
13:12:05 <Cale> If you're adding to the beginning of a string, it's fast.
13:12:09 <pejo> Cale, as for hoogle - ndm said something about that the next version will fix many of the matching problems in the current one.
13:12:11 <Cale> absolutely
13:12:18 <Cale> Lemmih just showed how
13:12:24 <huamn_> okay
13:12:27 <Cale> well, sorta
13:12:39 <conal> there's dons's dlist -- O(1) append & snoc
13:12:53 <Cale> showString "Foo " . showString a . showString " " . shows b
13:12:54 <conal> it's a very old trick, neatly wrapped up in a haskell lib
13:13:06 <conal> generalizing ShowS
13:13:10 <Cale> I usually just use the trick directly.
13:13:39 <huamn_> whoo, it works
13:13:41 <huamn_> thanks a lot
13:13:50 <huamn_> so showString is basicly the answer
13:13:59 <conal> huamn_: congrats :)
13:14:01 <Cale> yeah
13:14:58 <fasta> Cale: But... you apply functions to construct the list, which doesn't make it the same.
13:15:25 <Cale> fasta: It's the same thing as far as types are concerned
13:15:49 <Cale> fasta: there's no way that it can know based on the type of your thing that the first components don't depend on the chosen instance
13:16:36 <fasta> Cale: In [("a", f)], isn't it trivially true that the first component doesn't depend on f?
13:16:49 <Cale> yes, but that's not what you've written
13:17:08 <fasta> Cale: what have I written according to you?
13:17:17 <fasta> Cale: since that _is_ what I have written.
13:17:46 <int-e> fasta: the type checker does not care about what you have written
13:17:55 <int-e> fasta: when type checking a different function
13:18:03 <Cale> You've written  algorithms_names2
13:19:51 <fasta> Cale: yes, and that is a constant list, with no applications.
13:19:58 <int-e> fasta: you're really expecting the compiler to constant fold the  map fst algorithms_names2  that you wrote, and reconsider the inferred type from the result. it doesn't do that.
13:20:22 <fasta> int-e: no, I wasn't.
13:20:35 <fasta> int-e: I was saying that it was decidable.
13:20:44 <fasta> int-e: in this particular case.
13:20:59 <Cale> There's no way to encode that decidability in the type system.
13:21:25 <Cale> Why is it so hard to just specify a concrete type?
13:21:48 <int-e> or separate the two lists.
13:22:01 <Cale> Yeah, you could just have two lists.
13:22:10 <Cale> Which would also solve the problem.
13:22:26 <fasta> int-e: yes, that's what I did already (about an hour ago, I guess)
13:24:16 <fasta> Cale: what do you mean by "the type system"?
13:24:34 <fasta> Since it wouldn't be impossible to design _a_ type system to do so.
13:25:10 <Cale> actually, that's a good question
13:25:45 <Cale> I'm not sure that it can always be inferred that component won't depend on the typeclass -- at least, you can't do it perfectly.
13:28:18 <Cale> I suppose you could do it relatively well.
13:28:34 <Cale> It would make lots of types look horribly ugly though
13:29:07 <Storm> hello everybody
13:29:17 <Cale> Because you'd have to express the dependence of each structural component of a type on each of the class constraints.
13:29:34 <Cale> hello
13:30:09 <Storm> iam new to this stuff but i was just wondering where is Agood place to start learning how to build a chat bot
13:30:26 <Cale> Storm: dons has a tutorial about that
13:30:41 <Storm> where can i find that at
13:30:48 <Cale> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
13:30:49 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
13:30:54 <Cale> (found it :)
13:30:56 <Storm> ok thanx alot
13:38:34 <Cale> !paste
13:38:34 <hpaste> Haskell paste bin: http://hpaste.org/
13:39:44 <hpaste>  Cale pasted "Performance example for huamn_" at http://hpaste.org/3611
13:40:16 <Cale> huamn_: Check that out for a good example of where function composition is a heck of a lot faster than list concatenation :)
13:40:57 <conal> Cale: alternatively, perhaps use dlist to make inorderSlow be fast.
13:41:13 <Excedrin> did anyone read the qmail paper that's on programming.reddit right now? It's very interesting.
13:41:23 <conal> which i think means it looks like inorderSlow but works like inorder
13:41:34 <dons> Cale: meet Caleb, he's an xmonad user with a confusing nick
13:41:40 <Caleb> lol
13:41:42 <Cale> hehe :)
13:42:35 * Caleb is sorry his nick confuses dons
13:42:49 <dons> its ok :)
13:43:38 <conal> dons: is your code repo server down?
13:43:55 <Cale> I just noticed that too, while trying to read the documentation for DList
13:52:06 <conal> dons: i like dlist for how it abstracts out the accumulator pattern.  i'm guessing it has the usual drawback of losing computation sharing when moving from a data structure to a function representation.
13:52:45 <conal> for instance, if dlist had a "filter" operation, i suspect the filtering would get redone every time a dlist is used
13:53:42 <noteventime> Hi ho
13:53:48 <dmwit> Hiya, noteventime!
13:54:15 <noteventime> Does anyone know what the latest version number of the Haskell OpenGL-language binding is?
13:54:45 <noteventime> There's a version 2.2.1 in the Gentoo repositories
13:55:18 <Caleb> dons: can i pm you for a second
13:58:19 <dmwit> noteventime: I don't think the OpenGL binding has been touched for a while.
13:58:39 <noteventime> dmwit: I'll use the once that are available then :-) Thanks
13:59:09 <Zao> ghc-pkg list on 6.8.1 reports OpenGL-2.2.1.1
14:11:31 <uwi> i was reviewing wxhaskell calculator but it keep giving me an err
14:12:43 <uwi> is there anyone here
14:12:46 <uwi> ???
14:12:47 <dons> yo!
14:12:52 <dons> so what error?
14:12:53 <uwi> ok
14:12:58 <dons> wxHaskell is only lightly maintained.
14:13:09 <dons> you might try instead the gtk2hs clock and library
14:13:12 <dons> ?where gtk2hs
14:13:13 <lambdabot> http://haskell.org/gtk2hs/
14:14:10 <dons> they have a nice clock demo, http://haskell.org/gtk2hs/gallery/cairo-clock/Cairo_Clock_medium
14:14:12 <lambdabot> Title: Gtk2Hs Screenshot Gallery :: Cairo Clock :: Cairo_Clock_medium
14:15:04 <dons> here's the gtk2hs calculator, http://darcs.haskell.org/gtk2hs/demo/calc/
14:15:05 <lambdabot> Title: Index of /gtk2hs/demo/calc
14:15:35 <hpaste>  uwi pasted "calc" at http://hpaste.org/3612
14:16:03 <dons> ok, and what error do you get?
14:16:44 <uwi> it says something about STack error
14:16:59 <dons> so its not a wxHaskell error though
14:17:07 <uwi> nope
14:17:13 <dons> can you paste the error please?
14:18:06 <uwi> hold on
14:19:37 <user317> in mergeIO, what does it mean that the results are merged into a single output list
14:20:13 <uwi> In the secon arg of 'controller', namely '((Stack []), [])'
14:20:26 <uwi> couldn't match 'Stack Int' against '(a,b)
14:20:32 <uwi> Expected type: Stack Int
14:20:41 <uwi> Inferred type: (a,b)
14:20:48 <uwi> In the secon arg of 'controller', namely '((Stack []), [])'
14:20:57 <user317> oh i see, they are just concatinated
14:21:46 <uwi> i am gonna post the three file and u run and ompile them
14:21:47 <uwi> ok
14:24:44 <user317> is there anything that will evaluate [IO a] -> IO [a] but in parallel?  like a parallel sequence that forks for every element and waits untill they are all evaluated?
14:25:17 <hpaste>  uwi pasted "ALU" at http://hpaste.org/3613
14:25:39 <dons> user317: parMap
14:25:45 <hpaste>  uwi pasted "GUI" at http://hpaste.org/3614
14:25:46 <dons> or just mapM_ forkIO
14:25:55 <dons> then wait on the result
14:26:03 <dons> there's lots of ways to code that
14:26:04 <hpaste>  uwi pasted "controller" at http://hpaste.org/3615
14:26:34 <uwi> posted the three segments
14:27:00 <uwi> have a look at it and tell me what's the error please
14:27:41 <dons> what line does the type error say ?
14:29:46 <user317> dons, by wait on the result, do you mean waiting on an MVar like in the forkIO example?
14:30:29 <dons> user317: yeah, or a Chan or something like that.
14:30:41 <dons> presumably you want the main thread to wait on the children to complete?
14:30:44 <uwi> it says something  is wrong with line 135 of the GUI.hs
14:31:33 <user317> dons, yea, i just want to farm out a bunch of work to different machines, and collect it when i am done
14:31:39 <sclov> uwi: your GUI.hs paste only goes up to line 73.
14:32:14 <dons> user317: cool. I'd probably return results back over a Chan (Maybe a)
14:32:21 <dons> and have the threads write Nothing when they're done.
14:32:41 <dons> user317: there's an example in `pqc', parallel quickcheck, on hackage
14:32:43 <dons> its very small
14:32:59 <uwi> can't bother
14:33:06 <uwi> foreget it guys
14:33:15 <uwi> thanks anyway
14:34:18 <dons> uwi: look carefully at the line and column number in your type error -- it will tell you where the problem is.
14:35:11 <sclov> @. elite keal
14:35:11 <lambdabot> PrIMaRy ElEM3Nt4l aS5u/\/\p+I0n Of INTeGEr C0effi(I3N7S t0 ROo7z in CouN7ING syt3/\/\ is wrong
14:35:29 <sclov> yr answer ^^
14:39:44 <sjanssen> this is fun!
14:39:50 <sjanssen> hey everyone!
14:39:59 <oklopol> super hi
14:40:07 <sjanssen> i feel a bit strange
14:40:14 <byorgey> hey sjanssen, how's NE?
14:40:23 <sjanssen> its hmm. nice. i think
14:40:26 <conal> NE?
14:40:28 <sjanssen> its flat
14:40:30 <byorgey> Nebraska
14:40:34 <conal> oh
14:40:44 <byorgey> that's where the REAL sjanssen lives =)
14:40:52 <sjanssen> i got to school and hack lambdas all night
14:41:06 <sclov> sounds rad!
14:41:20 <conal> sjanssen: what school?
14:41:20 <sjanssen> my code is nice. i like stuff.
14:41:36 <sjanssen> university of nebraska-lincoln
14:41:42 <sjanssen> i hack xmonad a lot
14:41:53 <sjanssen> australians are weird
14:41:58 <byorgey> hehe
14:42:25 <Apocalisp> G'day, Bruce!
14:43:12 <sjanssen> i know of no one by that name here in nebraska
14:43:44 <dons> oh, that was totally weird
14:45:04 <Apocalisp> @seen arnar
14:45:04 <lambdabot> arnar is in #haskell. I don't know when arnar last spoke.
14:57:39 <ddarius> Monte Carlo based global illumination raytracing techniques or non-wellfounded set theory with applications?
14:59:56 <TomMD> Is there any location diagrams of the users of #haskell? I.e. a map showing where each #haskeller is at in the world.
15:00:00 <dons> ?map
15:00:00 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:00:07 <dons> which got moved to the new wiki
15:00:51 <TomMD> is this something lambdabot automatically does periodically?
15:01:06 <byorgey> TomMD: no, you have to add yourself.
15:01:23 <conal> cool idea, though
15:01:59 <conal> using /whois info
15:02:07 <TomMD> Thats what I was thinking.  If you could just do a '@user-locations' and have lambdabot provide you a link to the users world locations on google maps... hehe!
15:02:09 <conal> and annotaing wht user name if given
15:02:42 <byorgey> that wouldn't have very good resolution, though
15:03:03 <dcoutts> dons: ah yes, that gtk2hs clock. I recently bound the extra functions needed to actually make that transparent.
15:03:15 <TomMD> nah, but fun.  users could register a more accurate location with lambdabot if they wish.  It would fail over to the whois info.
15:03:53 <conal> personal url also
15:03:56 <byorgey> true, it's a fun idea
15:06:47 <conal> any openGL'ers here?
15:07:57 <dcoutts> conal: only a beginner
15:08:35 * dcoutts means he is only a beginner, not that there are only beginners here
15:10:15 <conal> i'm wondering what sort of 2D image support openGL has. or even how to thing GL'ily about images.  textures on a quad?  other choices?
15:11:01 <conal> also, how best to get fast, good-looking image resampling (rescaling), with sub-pixel motion.
15:11:37 <conal> i'm working on a new representation for infinite continuous images etc (functions over an infinite continuous domain)
15:14:54 <dcoutts> conal: GL support various raw image formats, like RGB(A) and you can turn those into textures
15:15:41 <oklopol> > 7
15:15:43 <lambdabot>  7
15:15:47 <oklopol> i KNEW it
15:15:50 <dcoutts> conal: as for resampling, not sure, you can move the camera position of course, but I don't know what kind of texture resampling that gives you, or if it's configurable
15:16:36 <dcoutts> conal: check the OpenGL site, it's the best source of docs, then secondarily consult the haskell OpenGL haddock docs
15:16:40 <Zao> Usually bilinear, or trilinear if you have mipmaps.
15:17:06 <conal> dcoutts: okay thanks.  i'll also poke around in the red book (http://fly.cc.fer.hr/~unreal/theredbook ) and see if i can get oriented
15:17:08 <lambdabot> Title: OpenGL Programming Guide (Addison-Wesley Publishing Company): Table of Contents
15:17:39 <ddarius> @check 7 == 7
15:17:39 <conal> Zao: i do have something very like mipmaps. sort of a mipmap zipper
15:17:40 <lambdabot>  OK, passed 500 tests.
15:18:21 <conal> Zao: do you know where interpolation and mipmaps are specified?
15:18:37 <conal> i'd guess with texture mapping
15:18:37 <Cale> @scheck 7 == 7
15:18:39 <lambdabot>   Completed 1 test(s) without failure.
15:18:59 <Zao> You specify the mipmap levels and the mini/maxi-fication filters when creating the texture.
15:19:37 <conal> Zao: got it.
15:20:06 <fasta> How can I use runCommand with multiple arguments?
15:20:46 <conal> is there other support in OpenGL for filtered image presentation besides in texture mapping?  i see glDrawPixels, but i'm guessing it's just 1-to-1 with the framebuffer.
15:20:46 <sjanssen> @hoogle runCommand
15:20:47 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
15:21:06 <sjanssen> fasta: it passes the string to your shell for interpretation
15:21:12 <fasta> I essentially did runCommand ("./Foo " ++ "arg1 " ++ " arg2" ++ " arg3" )
15:21:29 <fasta> sjanssen: shouldn't that work then?
15:21:32 <conal> oh, i see glPixelZoom.  but no mention of filtering
15:21:37 <hpaste>  Zao pasted "createTexture" at http://hpaste.org/3618
15:21:51 <fasta> sjanssen: in the ./Foo program (also Haskell) getArgs returns an empty list.
15:23:10 <conal> Zao: neat.  thanks.
15:23:12 <Zao> conal: I'm afraid I can't offer much insight into that, I'm generally just happy with trilinear filtered textures.
15:24:30 <conal> Zao: is one of 3 filter directions ("tri") mipmap level?
15:24:30 <Zao> readImage :: FilePath -> IO (Size, PixelData Word8), where the PixelData is constructed with PixelData RGBA UnsignedByte buf, where buf is a Ptr.
15:25:07 <Zao> I think so, yes.
15:25:21 <conal> trilinear is probably enough for me also.
15:25:23 <Zao> I seem to have misplaced my docs for the library though.
15:25:58 <sjanssen> fasta: eg. runCommand "ls -l" works here
15:26:23 <conal> Zao: in createTexture, is the "1" choosing from some kind of finite supply of texture spaces?
15:26:25 <fasta> sjanssen: odd, I will check the entire command again then.
15:27:17 <Zao> conal: It's a count of the amount of textures to generate, I believe.
15:29:04 <fasta> sjanssen: odd, it does work when I run it in ghci.
15:30:43 <LoganCapaldo> it's a sign
15:31:03 <LoganCapaldo> Haskell is telling you your program should have an interactive toplevel
15:31:08 <Zao> conal: The first parameter to textureFilter is the minification filter, while the second one is the magnification filter.
15:31:33 <Zao> So I suppose the Maybe there is for the mipmap filtering.
15:32:36 <conal> Zao: i wonder why use different filters.
15:32:43 <conal> i'm assuming minification means scaling down
15:33:23 <thoughtpolice> i recently came on an article on reddit about writing a game in a week. personally, game programming was the reason i got into programming (typical) and i've never taken the dive into writing something, although i've always wanted to. thing is, i've been with haskell long enough to the point where i want to use it (rather than something like pygame,) but i'm having trouble finding resources or pointers. any tips?
15:33:47 <dons> games in haskell, in particular?
15:33:55 <LoganCapaldo> @go Frag
15:33:57 <lambdabot> http://en.wikipedia.org/wiki/Fragged
15:33:57 <lambdabot> Title: Frag - Wikipedia, the free encyclopedia
15:33:59 <dons> did you check the games category on the wiki?
15:34:03 <dons> and mun's thesis on games?
15:34:03 <LoganCapaldo> hmm
15:34:06 <thoughtpolice> dons: ah, no.
15:34:10 <thoughtpolice> i'll look it up right quick
15:34:14 <LoganCapaldo> I should've stuck a haskell in that query
15:36:50 <conal> apparently glPixelZoom does no interpolation (http://www.groupsrv.com/computers/about22212.html ), and texturing is the way to go.
15:36:55 <thoughtpolice> dons: found it, thanks. :) for the past while i've been pondering on something like this so hopefully this will be a starting point. maybe writing something sufficiently complex will help with getting more into writing idiomatic haskell (testing, purity, etc. etc..)
15:43:34 <dons> dcoutts: you like build systems, this might be an interesting read, http://undeadly.org/cgi?action=article&sid=20071102210124
15:43:36 <lambdabot> Title: make -j4 p2k7
15:43:41 <dons> dcoutts: btw, when are you going to start a blog?
15:43:56 <dons> hands up if you want dcoutts to write a blog!?
15:43:59 <dcoutts> dons: oh yes, that. :-) I keep meaning to start one.
15:44:07 <dcoutts> where would I host it?
15:44:16 <dons> hmm.
15:44:17 * dcoutts does not believe in livejournal etc
15:44:22 <dons> on a machine you own.
15:44:26 <dcoutts> right
15:44:26 <dons> or maybe code.haskell.org
15:44:34 <dons> that's where i was thinking of moving mine
15:44:35 <dcoutts> or have login access to at least
15:44:52 <dcoutts> haskell.org/~duncan might be a bit cheeky
15:44:58 <dons> heh
15:45:04 <dcoutts> dunno if we should host stuff like that there
15:45:18 <dcoutts> and I'm not sure if community.h.o is ok
15:45:23 <Heffalump> you're welcome to an account on urchin.earth.li
15:45:38 <dcoutts> Heffalump: thanks, I'll bear that in mind
15:45:50 <ari> "Lightly maintained"?
15:45:51 * omnId kills himself.
15:46:09 <omnId> All the pain in implementing 'toExp' and it already exists...
15:46:37 <dons> dcoutts: did you just get an invite to be an earth.ling?
15:46:40 <omnId> Ah, well, I learned me some Data.Generics :)
15:46:42 <dons> that's pretty prestigious
15:46:50 <dcoutts> dons: seems so :-)
15:47:03 <hpaste>  keseldude pasted "isPrime (I'm proud of myself)" at http://hpaste.org/3619
15:49:24 <Heffalump> it's not the same thing :-)
15:50:11 <dons> maybe we can be martia.in's or something instead
15:50:20 <dons> venusi.an's
15:50:25 <thoughtpolice> i would offer you space but i don't host my own blog either. :( a friend in sweden does. i learned that geographic evils can bite you pretty hard when you need something supported. :(
15:51:33 <Heffalump> dons: you're also welcome to an account if it would be useful, though I guess you can use galois servers conveniently
15:52:18 <kscaldef> where is .li?
15:52:34 <Heffalump> Liechtensten. earth.li is just a vanity domain, though.
15:54:36 <seanmce> stylesheet = thelink ! [href "style.css", rel "stylesheet", thetype "text/css"] << ""
15:54:37 <seanmce> where can I learn about the ! and << operators here?
15:54:47 <dons> ?index (!)
15:54:48 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
15:55:07 <dons> oh, that's the html package
15:55:10 <dons> ?docs Text.Html
15:55:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
15:57:12 <seanmce> docs just give me the type definition.
15:57:45 <seanmce> wait I'll look at Data.Array
15:57:45 <ac> seanmce: (!) just retrieves an element from an array
15:58:03 <ac> seanmce: like (!!) for lists
15:58:13 <dons> seanmce: yeah, the type often documents precisely what it does,if you can think in a typesy way
15:58:39 <ac> :t (!)
15:58:40 <ari> Actually... http://www.haskell.org/ghc/docs/latest/html/libraries/html/Text-Html.html#t%3AADDATTRS
15:58:41 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
15:58:42 <lambdabot> http://tinyurl.com/2qgf4r
15:59:01 <ari> (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
15:59:02 <ac> so you see it takes an Array, an index for that array, and returns an element
16:00:36 <seanmce> why did I need << ""
16:01:19 <ari> (<<) :: HTML a => (Html -> b) -> a -> b
16:02:03 <ari> Seems like a case of the "use function composition to avoid list concatenation" trick to me
16:02:21 <hpaste>  omnId annotated "Compile-time evaluation" with ":'(" at http://hpaste.org/3584#a6
16:07:31 <seanmce> I get it now thanks.
16:08:07 <omnId> @instances-importing Text.Html HTML
16:08:11 <lambdabot> Char, HotLink, Html, HtmlTable, HtmlTree, [a]
16:11:08 <omnId> Cale: you know the compile-time thing?
16:12:07 <omnId> Cale: I more-or-less finished it.  You know what's absolutely hilarious?  It already existed.  D:
16:12:24 <Cale> hehe
16:12:29 <Cale> In what form?
16:12:42 <omnId> Language.Haskell.TH.Syntax.lift
16:13:05 <keseldude> don't feel bad. You learned something new!
16:13:28 <omnId> I learned that I should poke around the docs more before diving in head first...
16:14:27 <omnId> Cale: compare http://hpaste.org/3584#a6 with the previous annotations.
16:14:29 <Cale> I was almost certain there was an easy way to do that with TH, but couldn't remember what it was.
16:14:46 <Cale> It's been quite a while since I looked at TH at all.
16:17:13 <Cale> It feels like there should be an even better way than Lift, but I guess not.
16:17:52 <omnId> my toExp is basically lift with a Data a context instead of a Lift a context.
16:18:10 <ac> Are there any UI libraries out there that use channels (or something similar) for handling IO with the user?
16:18:20 <Cale> It would be nice if there was some inaccessible-except-through-TH expression form which just took any value and produced an expression of that type by doing the evaluation at compile time.
16:18:49 <ac> I think what I want is a UI library that doesn't trap you in a main event loop
16:19:45 <Cale> There are various things people are working on with regard to functional reactive programming, but I'm not sure how complete any of them are as of yet.
16:20:34 <ac> Cale: Like Grapefruit? I couldn't get that to compile. How similar is FRP to channels?
16:21:17 <Cale> Grapefruit?
16:21:55 <Cale> oh, that's interesting
16:22:03 <keseldude> how can i get mp3/flac playback with haskell? if anyone knows...
16:22:27 <dons> you want a library?
16:22:31 <keseldude> i guess so
16:22:39 <dons> check the sound libraries on hackage.haskell.org
16:22:42 <dons> or just fork mpg321
16:22:46 <dons> on your .mp3
16:22:54 <dons> see also hmp3, the haskell mp3 playe4r
16:23:00 <keseldude> k thanks
16:23:18 <fasta> dons: play4r looks nicer ;)
16:23:22 <Cale> ac: like some of the higher level libraries here http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries#High-level
16:23:24 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yvrplw
16:23:44 <fasta> Anyone a screen user?
16:23:46 <twanvl> Cale: That shouldn't be very hard actually, just evaluate it, use Data.Generics to convert to to a TH expression, and splice that in.
16:23:46 <dons> fasta: no it doesn't. that's an objective fact. the type system checks it, in fact
16:23:56 <fasta> How do I get out of scroll mode?
16:24:08 <Cale> twanvl: That's what omnId did
16:24:16 <Cale> twanvl: It doesn't work universally.
16:24:16 <twanvl> yes
16:24:20 <Zao> fasta: <Esc>
16:24:40 <twanvl> why not?
16:24:52 <Cale> Because not everything is an instance of Data.
16:24:53 <fasta> Zao: heh, I tried C-a <ESC> again
16:24:53 <Zao> If by "scroll mode" you mean copy mode, the one one gets from ^A-<Esc>.
16:25:03 <fasta> Zao: thanks
16:25:03 <omnId> twanvl: turns out TH has a Lift class with lift :: Lift a => a -> ExpQ, so all my work was for naught.  Data.Generics is basically not neccessary.
16:25:18 <Zao> You could also have whacked Enter twice to copy nothing.
16:25:23 <Cale> omnId: Well, your thing would be useful for writing instances of Lift
16:25:36 <Cale> omnId: Lift is just what your thing does, but not automatic.
16:25:48 <omnId> instance Data a => Lift a where lift = toExp -- yes, I have extended the Lift class by everything in Data.
16:26:15 <ac> Cale: that's where I found Grapefruit, whic seemed to be the most interesting out of all of them
16:26:52 <ac> Do FRP systems use something like channels underneath?
16:27:51 <fasta> The position of +RTS -RTS and actual arguments doesn't matter, right?
16:27:52 <KatieHuber> is there an actual description of what FRP is somewhere?
16:28:06 <KatieHuber> http://haskell.org/frp is singularly unhelpful
16:28:07 <Cale> ac: What, like Control.Concurrent.Chan?
16:28:12 <lambdabot> Title: Functional Reactive Programming Research
16:28:14 <Cale> I suppose they could.
16:28:24 <KatieHuber> and reading the YaMPA core interface isn't particularly illuminating either
16:28:44 <ac> Cale: yeah
16:28:58 <LoganCapaldo> I still don't see how you can escape the "main event loop". You can hide it, you can move it to the OS, but I don't think you can escape it.
16:28:59 <ac> KatieHuber: I think it's basically data flow
16:29:02 <oerjan> fasta: except that if -RTS is last you can leave it out, i think
16:29:16 <conal> i don't think any frp impls use channels.  afaik, they're demand-driven
16:29:56 <conal> i've been playing with data-driven impls lately: in Phooey, TV, and Eros
16:30:30 <ac> conal: what do those do?
16:30:52 <conal> @wiki Phooey
16:30:53 <lambdabot> http://www.haskell.org/haskellwiki/Phooey
16:30:55 <conal> @wiki TV
16:30:55 <lambdabot> http://www.haskell.org/haskellwiki/TV
16:30:58 <conal> @wiki Eros
16:30:58 <lambdabot> http://www.haskell.org/haskellwiki/Eros
16:31:05 <conal> @where Eros
16:31:05 <lambdabot> http://conal.net/papers/Eros
16:31:52 <conal> Phooey is a GUI lib.
16:32:11 <ac> I think it would be cool to write some sort of declarative pixel lever GUI library
16:32:23 <conal> TV (tangible values) is a general approach to things that run (tangible) and are still composable.  I have examples on the wiki page for IO-style and for GUI-style interfaces.
16:32:58 <conal> and Eros is like TV but bypassing syntax.  you do functional programming by interacting directly with GUI-wrapped pure values.
16:33:17 <conal> They run on top of the DataDriven library.
16:33:20 <conal> @wiki DataDriven
16:33:20 <lambdabot> http://www.haskell.org/haskellwiki/DataDriven
16:33:53 <ac> It would make writing certain graphical tomfoolery really easy, like fractals, CA, etc
16:34:31 <conal> ac: that's what i've been playing with for years.  still lots of room for improvement.
16:35:14 <ac> conal: yeah, if you could just declare a formula for each pixel, like "p(x,y) = p(x,y-1)" you would get a vertical scrolling
16:35:24 <ac> conal: you could do all sorts of fun stuff
16:35:45 <conal> ac: i bet you'd love Pan.  Have you seen it?
16:35:47 <conal> @where Pan
16:35:47 <lambdabot> I know nothing about pan.
16:35:52 <conal> @where pan
16:35:53 <lambdabot> I know nothing about pan.
16:35:59 <conal> @where+ pan http://conal.net/Pan
16:35:59 <lambdabot> I will remember.
16:36:15 <conal> @where+ pajama http://conal.net/Pajama
16:36:15 <lambdabot> It is stored.
16:36:24 <ac> So you're one of the creators of Pan? I've heard of it, but haven't downloaded it yet
16:36:25 <conal> i love lambdabot
16:36:51 <conal> ac: yep.  check out the papers & gallery on the web page.
16:37:20 <conal> pajama is pan compiling into java code, so it runs on the web.
16:37:34 <conal> i'm still tinkering with this stuff.
16:37:40 <scook0> @remember AndrewCoppin Mathematicians like to ask "interesting" questions. Unfortunately, at least in mathematics, "interesting" tends to correlate with "this may take several human lifetimes to solve"...
16:37:40 <lambdabot> Good to know.
16:38:22 <olsner> @quote
16:38:22 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
16:39:03 <olsner> hmm... I thought that was the plan for Perl6 :P
16:39:35 <allbery_b> perl6 kinda needs to hasten itself first :)
16:39:35 <scook0> olsner: hey, it worked for me! ;)
16:39:53 * LoganCapaldo castes haste on perl6
16:40:07 <scook0> "Perl 6 is suddenly moving faster!"
16:46:46 <dataangel> Is there a lambda calculus expression evaluator somewhere that will show each intermediate step? Playing around with lambdas and it would be very helpful
16:46:59 <ac> conal: what tools did you use for the code generation in Pan?
16:47:01 <fasta> dataangel: PLT Scheme has one, IIRC.
16:47:35 <ac> Yes, DrScheme has a nice step through evaluation thingy
16:48:13 <fasta> conal: are you sure that Pajama ever starts up?
16:48:18 <ac> There's also a tool for simply expanding them via the replacement model of execution
16:48:20 <dataangel> err, but PLT scheme doesn't behave like real lambda calculus, right?
16:48:26 <ac> (I think)
16:48:32 <ac> dataangel: why not?
16:48:35 <dataangel> I'm playing with church numerals
16:48:38 <fasta> dataangel: uh... why wouldn't it?
16:48:46 <ac> dataangel: Scheme works fine for church numerals
16:48:51 <dataangel> guess I'm not familiar enough with scheme ;p
16:48:58 <fasta> dataangel: it behaves more than real lambda calculus than Haskell
16:49:36 <ac> conal: and how hard was it?
16:49:43 <fasta> conal: yep, you sucessfully brought Firefox in a state where it doesn't respond.
16:49:51 * dataangel aptitude install's drscheme
16:49:53 <fasta> successfully*
16:50:07 <ac> conal: also, is there a Linux version?
16:50:11 <fasta> dataangel: Debian is not up to date.
16:50:20 <johnnowak> dataangel: you may need to run drscheme in one of the student modes to get the graphical evaluation stepper
16:50:20 <fasta> dataangel: but might be new enough, though
16:50:28 <dataangel> running ubuntu
16:50:51 <fasta> dataangel: then it probably is even worse
16:51:05 <dataangel> ubuntu's packages are usually newer than debians, how do you reason that?
16:51:14 <ac> yeah, that's what I thought
16:51:21 <fasta> dataangel: how do you reason that?
16:51:22 <ac> feisty + universe is pretty reasonable
16:51:47 <dataangel> fasta: Empirically :P Just about everything I install @_@
16:52:33 <ac> Although actually I have drscheme in /usr/local/bin, so I must have agreed with fasta
16:52:35 <fasta> dataangel: I can't help it that Ubuntu ships software that's about the same as experimental.
16:52:58 <dataangel> fasta: admittedly I haven't run debian personally, so maybe their experimental repos or something are newer, but hell, debian finally switched to Xorg not too long ago
16:53:06 <fasta> dataangel: and AFAIK, Ubuntu doesn't target programmers in any way.
16:53:26 <conal> ac: about code gen in Pan, we rolled our own, in haskell.
16:53:34 <fasta> dataangel: witnessed by a rather slow adoption of ghc-6.6.1, IIRC
16:53:34 <dataangel> fasta: ? I simply said ubuntu packages are usually newer. I'm not asking you to justify that debian doesn't run experimental apps.
16:53:59 <conal> no -- there's no linux version of pan, or any working version.  there have been some other implementations that don't compile.
16:54:03 <fasta> dataangel: newer than "what"?
16:54:13 <conal> ac: previous message was for you
16:54:14 <ac> fasta: often I run in to broken package version dependencies when I try to install -dev packages in ubuntu
16:54:28 <ac> conal: oh :-(
16:54:30 <dataangel> fasta: No, but ubuntu uses debians packages as a base and then chooses apps to use newer versions of -- as a result ubuntu packages are usually newer,  especially near the beginning of a release cycle
16:54:43 <conal> ac: pajama is an updated pan and theoretically runs on linux.  it's not as fast as pan but pretty fast still.
16:55:02 <dataangel> it's impossible for ubuntu to be behind debian in package versions except late into a release's life
16:55:04 <fasta> dataangel: newer than "what"?
16:55:09 <ac> conal: you must have used the Java compiler tools
16:55:25 <conal> ac: yes -- i generate java source code and invoke javac
16:56:07 <conal> what i really want to do is get better performance out of a straight haskell version.
16:56:11 <ac> conal: I think it would be neat to have an interactive environment that did something like that, so you could redefine things in an interactive fashion
16:56:15 <conal> and tie in to Eros.
16:56:22 <fasta> @where pajama
16:56:22 <lambdabot> http://conal.net/Pajama
16:56:26 <conal> ac me too
16:56:36 <dataangel> fasta: Than what's in debian's normal repo. If you're about to mention experimental repos we're already in agreement, as I mentioned before. I can't help but you're being pedantic over a pointless point.
16:56:48 <dataangel> s/but/but feel
16:56:59 <ac> conal: that's kind of why I was experimenting with generating mandelbrot sets in plain Haskell. I think I discovered that GHC's performance for that kind of thing isn't quite good enough
16:57:11 <fasta> dataangel: There is no such thing as "normal".
16:57:42 <fasta> dataangel: there's "Stable", "Testing", "Unstable" and "Experimental" for end-users.
16:57:49 <LoganCapaldo> what about weak head?
16:57:57 <dataangel> fasta: I'm glad that you can't find a repo with that literal name, but if you weren't being deliberately thick you'd know what I meant, troll. "Stable"
16:58:14 <ac> conal: quicksilver and I experimented with the code for a while, and couldn't get anything that was faster than about 20 to 50x slower than a C implementation
16:58:21 <conal> ac: what gives me hope is that dons and others are learning how to get really good preference out of declarative haskell code.
16:58:26 <fasta> dataangel: most Debian desktops do not use Stable, AFAIK.
16:58:26 <dataangel> yeesh
16:58:34 <conal> ac: pretty discouraging
16:58:46 <fasta> dataangel: and since we were talking about desktops...
16:59:09 <dataangel> fasta: My understanding is most people run unstable, yes?
16:59:14 <dataangel> most desktops that is
16:59:20 <ac> conal: I think GHC performs very nicely compared to C in most cases, but this kind of code just isn't one of those cases I guess
16:59:22 <conal> ac: what kind of arrays?
16:59:30 <fasta> dataangel: most tech-savvy people, yes.
16:59:41 <ac> conal: no arrays. just a tight loop generating a list passed to withArray
16:59:52 <conal> ac: maybe not.  it's a case i care a lot about though.
16:59:56 <ac> conal: but withArray was not the bottle neck, because I eventually tested it without that
17:00:17 <ac> conal: I might examine the assembly at some point
17:00:29 <fasta> dataangel: anyway, "Debian - OLD"- Ubuntu - NEW" is too simple.
17:00:37 <dataangel> fasta: alright, so if ubuntu uses those packages as a base, but uses newer versions of some packages (which may or may not be from debian's experimental repo), then the average tech-savvy ubuntu user is going to be running newer packages than the tech-savvy debian user, yes? Case closed.
17:00:55 <conal> ac: or the core code
17:01:01 <ac> conal: that's what I meant
17:01:07 <conal> ac: could you eliminate the list?
17:01:17 <dataangel> Arguably ubuntu would lie somewhere between debian unstable and debian experimental because which packages they use is case by case.
17:01:37 <ac> conal: that definitely wasn't the bottleneck. Because I replaced it with a (+), and it got slower
17:02:12 <ac> conal: somebody in this channel reasoned it was simply GHC not compiling well for tight loops
17:02:19 <conal> ac: hm.  do you know how much time is spent in allocation & gc?  and are you getting unboxed computations?
17:02:20 <ac> conal: would have to look at the logs to remember who
17:02:49 <ac> conal: I don't know what those things mean (except gc)
17:03:19 <fasta> ac: what things?
17:03:24 <fasta> ac: you mean MUT etc?
17:03:50 <ac> "allocation", "unboxed computations". Not clear on those yet
17:04:21 <ac> I think unboxed means dealing with actual values instead of thunks, but I wouldn't put money on it
17:04:29 <conal> ac: are you using OpenGL to display?
17:04:35 <ac> conal: yeah, want to see the code?
17:04:59 <conal> ac: yes.  i'm just starting to learn opengl
17:05:18 <ac> conal: I have a couple OpenGL programs
17:05:20 <conal> i'm using windows, but soon i'll have a linux machine set up.
17:05:26 <conal> ac: i'd love to see them
17:05:42 <ac> let's see here, I hpasted one a while back, let's see if I can dig it up
17:07:52 <ac> conal: I can't find it. I'll write a real simple program....
17:08:39 <conal> ac: i'm particularly interested in 2D rendering, which i assume you did for mandelbrot
17:08:55 <ac> conal: yeah, I'm going to write a simplest 2D rendering program
17:09:26 <Trinithis> I have a quick question: What is the difference between Int and Integer?
17:09:33 <ac> Trinithis: Integer is unbounded
17:09:34 <Jaak> > maxBound ::Int
17:09:36 <lambdabot>  2147483647
17:09:38 <Jaak> > maxBound ::Integer
17:09:39 <lambdabot>   add an instance declaration for (Bounded Integer)
17:09:39 <lambdabot>     In the expression: ma...
17:09:46 <Trinithis> thx
17:09:56 <oerjan> > product [1..10000] :: Integer
17:09:57 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
17:10:22 <scook0> > (maxBound + 1) :: Int
17:10:23 <lambdabot>  -2147483648
17:10:38 <oerjan> > succ maxBound :: Int
17:10:39 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
17:11:26 <jcreigh> what?! Clearly that should yield minBound :)
17:11:41 <scook0> > (fromIntegral (maxBound::Int) + 1) :: Integer
17:11:42 <lambdabot>  2147483648
17:11:54 <oerjan> nope, succ is required to catch bounds
17:12:14 <scook0> "The calls succ maxBound and pred minBound should result in a runtime error."
17:12:38 <jcreigh> so that means that succ != (+1)
17:12:50 <scook0> so it's not quite *required*
17:12:56 <oerjan> > [maxBound-3 :: Int ..]
17:12:58 <lambdabot>  [2147483644,2147483645,2147483646,2147483647]
17:13:42 <scook0> "enumFrom and enumFromThen should be defined with an implicit bound"
17:14:20 <oerjan> > [maxBound-7, maxBound-5 :: Int ..]
17:14:21 <lambdabot>  [2147483640,2147483642,2147483644,2147483646]
17:14:39 <oerjan> > [maxBound-6, maxBound-4 :: Int ..]
17:14:41 <lambdabot>  [2147483641,2147483643,2147483645,2147483647]
17:14:47 <Trinithis> I'm guessing then Float is a subset of Double?
17:15:03 <oerjan> sizewise, yes
17:15:12 <omnId> > bitSize (0::Float)
17:15:13 <lambdabot>   add an instance declaration for (Bits Float)
17:15:13 <lambdabot>     In the expression: bitSize...
17:15:56 <oerjan> > floatRange (undefined :: Float)
17:15:57 <lambdabot>  (-125,128)
17:16:01 <oerjan> > floatRange (undefined :: Double)
17:16:02 <lambdabot>  (-1021,1024)
17:16:41 <oerjan> > floatDigits (undefined :: Float)
17:16:42 <lambdabot>  24
17:16:47 <oerjan> > floatDigits (undefined :: Double)
17:16:49 <lambdabot>  53
17:17:17 <oerjan> > floatRadix (undefined :: Float)
17:17:17 <omnId> @. id @ @run unwords . filter (all isUpper) . words $ @show @yow
17:17:20 <lambdabot>  2
17:17:20 <lambdabot>   "I COLOR VIBRATING"
17:17:29 <oerjan> > floatRadix (undefined :: Double)
17:17:30 <lambdabot>  2
17:18:19 <oerjan> @. id @ @run unwords . sort . words $ @show @yow
17:18:21 <lambdabot>   "I Yow! below just line! poverty the went"
17:18:31 <jcreigh> 147483643,2147483645,2147483647]
17:18:31 <jcreigh> 147483643,2147483645,2147483647]
17:18:46 <jcreigh> grr. I should really find the cause of that weird mouse glitch sometime.
17:19:09 <hpaste>  ac pasted "OpenGL 2D demo" at http://hpaste.org/3620
17:19:24 <ac> conal: that's about as simple as it gets
17:21:42 <hpaste>  ac annotated "OpenGL 2D demo" with "To get colors..." at http://hpaste.org/3620#a1
17:23:18 <ac> conal: and once you have code for texture generation, the rest of 2D graphics is a breeze
17:23:53 <lament> @. id @ @run unwords . sort . words $ @show @yow
17:23:55 <lambdabot>   "... My a field is mind potato"
17:24:03 <lament> i think they make more sense this way.
17:24:57 <conal> ac: thanks.  i'll give it a go once i can figure out how to get the haskell glut package to install.  maybe a newer ghc snapshot will have it.
17:25:08 <ac> conal: yeah, I didn't install anything
17:25:12 <ac> conal: I have GHC 6.8
17:25:23 <omnId> @. id @ @run unwords . sort . words &&& id $ @show @yow
17:25:25 <lambdabot>   ("My a fun! is life of patio","My life is a patio of fun!\n")
17:25:30 <conal> ac: windows woes :p
17:25:34 <ac> conal: GHC should compile that out of the box
17:26:30 <omnId> @. id @ @run let w f = unwords . f . words in w sort &&& w (filter (all isUpper)) &&& id $ @show @yow
17:26:32 <lambdabot>   ("... HUMAN NUTRITIONAL REPLICAS VATS YEAST are inserted into of",("HUMAN RE...
17:27:34 <enzo> Question:
17:28:07 <omnId> @let sortNoCase = sortBy (compare `on` toLower)
17:28:18 <lambdabot> Defined.
17:28:48 <omnId> @. read @ @run unwords . sortNoCase . words $ @show @yow
17:28:49 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
17:28:57 <dino-> :t on
17:28:58 <lambdabot> Not in scope: `on'
17:29:23 <omnId> (f `on` g) x y = f (g x) (g y)
17:30:03 <dino-> ok
17:30:44 <oerjan> something strange with read
17:31:00 <oerjan> it failed several times yesterday too
17:31:04 <twanvl> ?type sortNoCase -- monomorphism?
17:31:05 <lambdabot> Not in scope: `sortNoCase'
17:31:12 <omnId> @read "testing inner\" quotation marks"
17:31:12 <lambdabot>  testing inner" quotation marks
17:31:21 <oerjan> > [sortNoCase, ()]
17:31:22 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
17:31:26 <ari> Whoohoo!
17:31:50 <omnId> @. id @ @read @run [minBound..maxBound] :: [Char]
17:31:51 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
17:31:52 <ari> > "parentheses? )"
17:31:53 <lambdabot>  "parentheses? )"
17:31:56 <twanvl> @let sortNoCase' = sortBy (compare `on` map toLower)
17:31:58 * ari hugs lambdabot
17:32:06 <omnId> @read "bad" things
17:32:07 <lambdabot> Defined.
17:32:07 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
17:32:38 <omnId> twanvl: oops :)
17:32:40 <P_D> @src on
17:32:40 <lambdabot> (*) `on` f = \x y -> f x * f y
17:32:42 <twanvl> @. read @ @run unwords . sortNoCase' . words $ @show @yow
17:32:43 <lambdabot>  a box Did DIGITAL find in of VELVEETA? WATCH YOU YOUR
17:34:14 <oerjan> twanvl: i understand you wrote @@, are you fixing the bug that prevents it working first on the line in public?
17:34:30 <omnId> @@ @run product [1..10]
17:34:38 <twanvl> yes, I fixed that
17:35:05 <omnId> @. id @ @run unwords . sortNoCase . words $ (@show @yow) -- to see what read gets
17:35:05 <twanvl> all we need now is for dons to rebuild and restart the bot
17:35:06 <lambdabot>   Couldn't match expected type `Char' against inferred type `String'
17:35:27 <omnId> @read Couldn't match blah blah
17:35:27 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
17:35:31 <omnId> right.
17:36:02 <omnId>  @run should give Maybe Result :)
17:36:26 <oerjan> hm...
17:37:06 <omnId> oerjan: I'm not serious o_O
17:37:37 <omnId>  @maybeRead, then? :D
17:38:07 <omnId>  @maybeRead NOT IN QUOTES!! -> NOT IN QUOTES!!,  @maybeRead "QUOTES!!" -> QUOTES!!
17:39:28 <oerjan> @let maybeString s = case reads s of [(s',_)] -> Just s'; _ -> Nothing
17:39:32 <thetallguy> Anyone know if there's a way to determine what the minimum granularity of a threadDelay call is?
17:39:38 <omnId> @. id @ @run unwords . map sortNoCase . words $ (@show @yow) -- hehe, I'll use my broken sortNoCase
17:39:39 <lambdabot> Defined.
17:39:40 <lambdabot>   "'Im !!EGIILORSU I elov a amn hitw a !!ACEEHIIPR Eipqu em hitw !!EIILMSSS"
17:40:38 <ac> conal: do you have any ideas on creating a Pan-like system that can do interactive compilation?
17:40:45 <omnId> thetallguy: threadDelay 1 picosecond and subtract? :)
17:40:54 <oerjan> @. id @ @run maybeString @run unwords . sortNoCase . words $ (@show @yow)
17:40:55 <lambdabot>   Parse error at "type" (column 38)
17:41:10 <oerjan> @. id @ @run maybeString @show @run unwords . sortNoCase . words $ (@show @yow)
17:41:12 <lambdabot>   Nothing
17:41:29 <thetallguy> omnId: I was hoping for something a little more... specified
17:41:55 <omnId> @index threadDelay
17:41:56 <lambdabot> GHC.Conc, Control.Concurrent
17:41:59 <oerjan> @. id @ @run maybeString @show @run unwords . sortNoCase' . words $ (@show @yow)
17:42:02 <lambdabot>   Nothing
17:42:03 <omnId> @docs Control.Concurrent
17:42:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
17:42:10 <oerjan> whoops
17:42:25 <oerjan> @. id @ @run unwords . sortNoCase' . words $ (@show @yow)
17:42:25 * wli had a readM :: (Monad m, Read r) => String -> m r
17:42:26 <lambdabot>   "a adorable and ASYLUM!! clever I'm in INSANE very YOW!!"
17:42:43 <oerjan> @. id @ @show @run unwords . sortNoCase' . words $ (@show @yow)
17:42:44 <lambdabot>   " \"53 And B.C. can conquered Egypt I in it Murray My prove too!! uncle\""
17:42:56 <oerjan> @. id @ @show @run unwords . sortNoCase . words $ (@show @yow)
17:42:57 <lambdabot>   " Couldn't match expected type `Char' against inferred type `String'"
17:43:34 <oerjan> @. id @ @run reads @show @run unwords . sortNoCase' . words $ (@show @yow)
17:43:36 <lambdabot>   []
17:43:49 <conal> ac: (back from a phone call): yes definitely interactive compilation, in the context of Eros
17:43:55 <oerjan> oh wait
17:44:17 <oerjan> @let maybeRead s = case reads s of [(s' :: String,_)] -> Just s'; _ -> Nothing
17:44:17 <lambdabot>  Parse error in pattern
17:44:19 <conal> i want the whole syntax/compilation aspect to be completely invisible.
17:44:35 <oerjan> @let maybeRead s = case reads s of [(s',_)] -> Just (s' :: String); _ -> Nothing
17:44:46 <lambdabot> Defined.
17:45:05 <twanvl> @. id @ @run unwords . sortNoCase' . words $ (@show @quote) ++ " What are you all trying to do here?"
17:45:07 <lambdabot>   "(^-^) all are as can do Failure02 haskell have here? in korean like says: s...
17:45:12 <oerjan> @. id @ @run maybeRead @show @run unwords . sortNoCase' . words $ (@show @yow)
17:45:14 <lambdabot>   Just "a I nude Psychoanalysis?? rap session!!! this thought was"
17:46:33 <wli> :t let readM s = case reads s of [(x, _)] -> return x ; _ -> throwError "readM: no parse" in readM
17:46:34 <lambdabot> forall (m :: * -> *) a. (Read a, MonadError [Char] m) => String -> m a
17:46:47 <oerjan> twanvl: someone suggested @run should return Maybe String
17:47:38 <thetallguy> Ah, there's someone who might know.
17:48:05 <thetallguy> sorear: you know any tricks about determining the minimum overhead of a threadDelay?
17:48:20 <sorear> thetallguy: OS?
17:48:29 <wli> It's the granularity of setitimer in Linux.
17:48:38 <sorear> thetallguy: it costs something like 500ms on OSX due to a bug
17:48:45 <thetallguy> In practice, Linux
17:48:53 <thetallguy> but the point is I don't wish to hard code it.
17:49:04 <thetallguy> I supposed I could write a binary search
17:49:19 <sjanssen> @src threadDelay
17:49:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:49:20 <sorear> why do you need this information?
17:49:26 <thetallguy>  but I was wondering if there was some obscure library call that would tell me.
17:49:55 <thetallguy> I've started the timing library I was talking about a week or two ago
17:49:59 <wli> ISTR it being reported in the ELF AUXV.
17:50:25 <thetallguy> and it occurred to me that I might want to make it   :: a -> IO Maybe NominalDiffTime
17:50:33 <thetallguy> if the time was below the granularity
17:50:48 <asl> Okay, so I was looking over the old summer of code project to make a version of ByteString generalized over any Storable a
17:50:53 <thetallguy> I saw the bug about OSXZ
17:50:55 <asl> which seems like a neat idea
17:51:05 <thetallguy> that was part of my motivation
17:51:09 <sorear> thetallguy: a) that's not even kind-correct b) scheduling granularity (threadDelay) has nothing to do with timer granularity (getCPUTime)
17:51:26 <sorear> asl: It is.
17:51:26 <sethk> asl, there is a more recent and more general replacement for ByteString
17:51:26 <thetallguy> Heh.
17:51:35 <thetallguy> You are correct.
17:51:45 <asl> sorear, sethk: okay
17:51:49 <thetallguy> Sorry, I was confused because I wrote a test suite that uses threadDelay
17:51:56 <sorear> sethk: do tell.  dons will be very interested to know.
17:51:56 <thetallguy> Got my problems crossed.
17:51:58 <asl> where's the code? I was wondering how they did it ^_^
17:52:11 <sethk> sorear, well, dons wrote the new one.  Did I get it backwards?
17:52:17 <sorear> yes
17:52:17 <asl> um ...
17:52:19 <sethk> sorear, is ByteString the new one?  :)
17:52:22 <sorear> yes
17:52:24 <sethk> sorry about that  :)
17:52:27 <asl> it's okay!
17:52:32 <asl> okay
17:52:36 <thetallguy> Cool, well then I'll just publish it and wait for comments.
17:52:41 <sethk> My hearts in the right place.  :)
17:52:42 <sorear> asl: there isn't any, I beleive funding was not provides (Haskell.org gives 100 problems, Google funds ten)
17:53:03 <asl> sorear: well, it's in some SoC darcs repo
17:53:10 <asl> anyway, the point I'm driving at
17:53:36 <shapr> Is there a list of new features in ghc 6.8?
17:53:37 <asl> is the project looks like it stopped at defining the malloc function
17:54:10 <asl> for multiple things of type Storable a
17:54:14 <sjanssen> asl: I wrote the code in question
17:54:18 <asl> oh! okay
17:54:23 <asl> hah
17:54:26 <ac> conal: guess I have to read about Eros
17:54:45 <luqui> wow... the cellular automata comonad thing is some of the most beautiful programming I've ever seen....
17:55:06 <exDM69> what on earth is that?
17:55:16 <asl> sjanssen: I was just wondering how to get a witness of the particular instance of Storable to do the malloc
17:55:33 <luqui> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
17:55:36 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
17:56:07 <sjanssen> @hoogle allocArray
17:56:11 <lambdabot> Foreign.Marshal.Array.mallocArray :: Storable a => Int -> IO (Ptr a)
17:56:11 <lambdabot> Foreign.Marshal.Array.reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
17:56:11 <lambdabot> Foreign.Marshal.Pool.pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
17:56:34 <asl> sjanssen: I guess that takes care of that.  of to the sources
17:56:38 <sjanssen> asl: just use mallocArray, your return type should constrain it appropriately
17:56:51 <exDM69> I wish I knew Haskell better. I have a big project that would be ideal for Haskell. Or some parts of it at least.
17:57:09 <exDM69> it's so frustrating to write higher order programming with C++
17:57:14 <asl> sjanssen: I figured it was possible, I just was curious how. and someone has done it, so that makes answering my question easier
17:57:18 <sorear> @seen dpiponi
17:57:18 <lambdabot> I saw dpiponi leaving #haskell 2d 5h 56m 1s ago, and .
17:57:22 <keseldude> what project?
17:57:50 <DannoHung> Has anyone here successfully built GHC under a clean Leopard?
17:58:20 <sorear> DannoHung: No.
17:58:30 <sjanssen> asl: also, see Data.StorableVector.Base.unsafeCreate
17:58:34 <DannoHung> Dang, Hugs worked...
17:58:39 <luqui> exDM69, writing a "real" project is the best way to learn haskell
17:58:50 <exDM69> luqui: yes, I agree
17:58:52 <sorear> DannoHung: All versions of GHC since 0.00something *absolutely require* a previous version of GHC to be installed.
17:58:56 <sorear> DannoHung: Get a binary.
17:59:06 <exDM69> luqui: but this one involves a significan amount of graphics and IO
17:59:11 <DannoHung> Ohhhhh... whoops, thought port would take care of that for me.
17:59:30 <sorear> And this 0.00somthing was in the late 80's, well before Leopard.
17:59:33 <exDM69> luqui: and I recon it would be better to write something more simple (on the I/O aspect) first
17:59:57 <sjanssen> asl: it's not exported from the main module because it can be used unsafely
18:00:08 <sjanssen> asl: also, I'm curious what use you have for it
18:00:15 <DannoHung> So, wait, if you want to bootstrap onto a new platform, you've gotta do a bunch of incremental installs from 0.00wahtever?  Pain.
18:01:18 <allbery_b> DannoHung: no, youc an tell ghc to dump out ANSI C code
18:01:25 <sorear> DannoHung: I think the sources have been lost for some critical link.  Porting these days involves cross-compilation, which GHC supports very poorly.  (Or so I've heard)
18:01:57 <DannoHung> Glad I'm probably never gonna have to do that.
18:03:01 <asl> sjanssen: because the code didn't compile
18:03:13 <asl> sjanssen: and that's the function it got stuck on
18:03:30 <shapr> @seen conal
18:03:31 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 19m 10s ago.
18:03:47 <shapr> conal: What was the order you suggested, applicative functors, monads, then monad transformers? Was there another step?
18:04:27 <sjanssen> asl: it builds fine here
18:04:28 <thetallguy> shapr: order for what?
18:04:44 <asl> sjanssen: so I got to wondering what the trick was for getting the type witness, which was to create an auxillar function that takes the witness as it's first parameter, and then feed it "undefined"
18:05:21 <shapr> thetallguy: Conal suggested that monad transformers and monads would be easier if people understood applicative functors first, but I thought there might be another step in there somewhere.
18:05:35 <thetallguy> shapr: arrows, possibly
18:05:36 <sjanssen> asl: you can constrain the type allocated by the return type
18:05:39 <shapr> Ah, probably so!
18:05:53 <thetallguy> every monad is an AF
18:06:03 <thetallguy> and every AF is an Arrow
18:06:19 <sjanssen> asl: eg. "mallocV :: Storable a => Int -> IO (StorableVector a)" will work automatically
18:06:20 <asl> sjanssen: yeah, I was just wondering how mallocArray did at, as sizeOf requires an argument.  I checked the code, and I'm happy now
18:06:24 <thetallguy> That's ta scale that conal has been sliding along, looking for the right place to land.
18:06:25 <twanvl> every AF is an arrow transformer
18:06:35 <sjanssen> asl: I'd like to know how your build failed
18:07:02 <shapr> So, Functor -> AF -> monad -> arrow, yeah?
18:07:19 <thetallguy> twanvl: not an Arrow?
18:07:41 <thetallguy> shapr: that line isn't well defined for me
18:07:53 <twanvl> you could apply it to (->) or something
18:08:06 <thetallguy> but AF and monad are reversed
18:08:20 <thetallguy> every monad is an AF, b ut not every AF is a monad
18:08:54 <asl> sjanssen: well, I was just building with ghc --make Data.Storable to see what it did.  I haven't tried following the real build procedure yet
18:09:05 <thetallguy> There's a functional peal by Patterson and Macbride on AF's that goes through this
18:10:05 <thetallguy> s/peal/pearl
18:10:22 <oerjan> is the arrow you get from the applicative of a monad the same as the kleisli arrow of the monad?
18:10:23 <shapr> thetallguy: Cool, I'll look it up.
18:10:41 <oerjan> i did not have that impression
18:10:43 <sjanssen> asl: the build system #defines some variables that are used in conditional compilation
18:10:59 <thetallguy> shapr: link is in the man page for Control.Applicative
18:11:20 <oerjan> so it would be Functor -> Applicative -> Monad <- Arrow
18:11:22 <omnId> luqui: Indeed it is.  I haven't read that article in months.  Having just read it again, I understand it, and it is beautiful!
18:11:25 <thetallguy> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
18:11:28 <lambdabot> Title: Applicative Programming with Effects
18:11:32 <sjanssen> asl: would storablevector packaged up as a standalone package be useful to you?
18:12:05 <shapr> thetallguy: Thanks
18:12:06 <asl> sjanssen: not immediately.  It was just mentioned on haskell-cafe so I thought I'd see how it worked.
18:14:24 <asl> sjanssen: using the real build process seems to build.
18:16:03 <asl> sjanssen: oo, it build, but my build of 6.9 doesn't seem to like it very much
18:16:14 <asl> sjanssen: built, rather
18:16:40 <sjanssen> asl: probably because it has a copy of Data.ByteString which already comes with ghc >= 6.8
18:16:41 <oerjan> interestingly the Applicative structure of a Monad seems to partially determine its join too...
18:16:46 <sjanssen> erm, 6.6 rather
18:17:08 <asl> sjanssen: yeah, that looks like it.  I told it not to expose those modules from the package, but that may have messed it up more
18:22:01 <oerjan> @check \f x y -> join (fmap (\a -> fmap (f a) y) x) == (liftM2 f (x::[Bool]) (y::[Bool]) :: [Bool])
18:22:10 <lambdabot> Terminated
18:22:15 <oerjan> eek
18:22:22 <exDM69> what's fmap?
18:22:35 <omnId> exDM69: depends on the type.
18:22:39 <omnId> @src [] fmap
18:22:39 <lambdabot> fmap = map
18:22:47 <omnId> @src Maybe fmap
18:22:47 <lambdabot> fmap _ Nothing       = Nothing
18:22:47 <lambdabot> fmap f (Just a)      = Just (f a)
18:23:09 <oerjan> @check \f x y -> join (fmap (\a -> fmap (f a) y) x) == (liftM2 f (x::[()]) (y::[Bool]) :: [Bool])
18:23:15 <lambdabot> Terminated
18:23:24 <oerjan> @check \f x y -> join (fmap (\a -> fmap (f a) y) x) == (liftM2 f (x::[()]) (y::[()]) :: [Bool])
18:23:30 <lambdabot> Terminated
18:23:37 <oerjan> too much for lambdabot :(
18:23:56 <omnId> exDM69: it kinda applies the function to the value inside the structure.
18:24:21 <omnId> though that's a rather limited metaphor.
18:24:24 <exDM69> I didn't quite get it but perhaps I will
18:24:28 <exDM69> sometime
18:24:34 <sjanssen> asl: darcs get http://code.haskell.org/~sjanssen/storablevector
18:24:37 <lambdabot> Title: Index of /~sjanssen/storablevector
18:26:20 <oerjan> @check let f = (==) in \x y -> join (fmap (\a -> fmap (f a) y) x) == (liftM2 f (x::[Bool]) (y::[Bool]) :: [Bool])
18:26:22 <lambdabot>  OK, passed 500 tests.
18:26:31 <oerjan> yay
18:26:57 <oerjan> @check let f = (&&) in \x y -> join (fmap (\a -> fmap (f a) y) x) == (liftM2 f (x::[Bool]) (y::[Bool]) :: [Bool])
18:26:59 <lambdabot>  OK, passed 500 tests.
18:27:08 <DannoHung> Man, installing ghc is a little obtuse
18:27:22 <oerjan> seems generating functions is heavy work
18:28:28 <oerjan> @check let f = (&&) in \x y -> join (fmap (\a -> fmap (f a) y) x) == (liftM2 f x y :: Maybe Bool)
18:28:28 <lambdabot>        add an instance declaration for (Arbitrary (Maybe Bool))     In the ex...
18:28:35 <twanvl> aren't you just saying that liftM2 == liftM2 here, assuming bind bind is defined in terms of join and fmap?
18:29:12 <oerjan> twanvl: note that fmap and liftM2 are essentially Applicative
18:29:31 <twanvl> there is a liftA2
18:29:38 <oerjan> what i am saying is that join for some values can be determined by just the applicative subset
18:29:46 <asl> sjanssen: that worked better than my hatchet-job.
18:30:04 <oerjan> assuming the applicative comes from a monad in the usual way
18:30:25 <oerjan> those values are sort of "rectangular", i think
18:31:39 <twanvl> ap combines two structures, while join combines a whole structure full of structures
18:31:58 <oerjan> yep.
18:32:07 * wli has never figured out ap.
18:32:17 <ramza3> is there an algorithms channel
18:32:25 <oerjan> and if all the substructures have the same form, you can rewrite it with liftA2
18:32:30 * twanvl didn't either, until he figured out <*>
18:32:34 <ramza3> on freenode
18:32:43 <asl> @t <*>
18:32:44 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:32:55 <asl> @type (<*>)
18:32:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:35:28 * wli has no idea about (<*>)
18:36:08 <omnId> (<*>) = ap, modulo the lack of class Applicative m => Monad m
18:36:11 <oerjan> Using this you can ask what would be the monad corresponding to ZipList.  Turns out if it exists, join must be taking the main diagonal of a matrix...
18:36:35 <twanvl> f <$> x <*> y <*> z == liftM3 f x y z
18:37:01 <omnId> = pure f <*> x <*> y <*> z
18:37:16 <omnId> (pure = return, modulo same)
18:37:28 <oerjan> i think it exists, although i doubt it is uniquely defined on non-rectangular matrices...
18:37:34 <twanvl> a ZipList monad is possible, but not (easily) with that type ([])
18:38:05 <omnId> twanvl: I was told I ZipList monad is possible, but not with the current instance's pure.
18:38:18 <twanvl> hmm
18:38:24 <omnId> pure = repeat, join xss = <take the diagonal>
18:38:40 <oerjan> what's wrong with that?
18:38:44 <twanvl> that doesn't satisfy the monad laws
18:38:52 <omnId> pure = (:[]), in the current instance
18:38:58 <oerjan> omnId: no!
18:39:04 <omnId> hm?
18:39:11 <oerjan> we are not talking about the Applicative defined for []
18:39:17 <omnId> oh.
18:39:19 <oerjan> there is a ZipList newtype
18:39:34 <oerjan> and it _does_ use repeat
18:39:47 <omnId> > pure 1 :: ZipList Int
18:39:48 <lambdabot> Terminated
18:39:56 <omnId> > take 5 $ pure 1 :: ZipList Int
18:39:57 <lambdabot> Terminated
18:40:04 <omnId> > take 5 $ Control.Applicative.pure 1 :: ZipList Int
18:40:05 <lambdabot>  Couldn't match expected type `ZipList Int'
18:40:12 <omnId> rawr
18:40:18 <omnId> oh, take
18:40:21 <twanvl> imagine a kind of 'cube', first taking the diagonal in one direction and then in the other can produce a different result from first taking the diagonal first in the other and then in the one direction.
18:40:23 <omnId> > Control.Applicative.pure 1 :: ZipList Int
18:40:24 <lambdabot>   add an instance declaration for (Show (ZipList Int))
18:40:30 <asl> @src ZipList Control.Applicative.pure
18:40:31 <lambdabot> Source not found. Just try something else.
18:40:55 <omnId> > getZipList $ Control.Applicative.pure 1 :: ZipList Int
18:40:56 <oerjan> twanvl: i didn't get a problem when i imagined it
18:40:59 <lambdabot>  Couldn't match expected type `ZipList Int'
18:41:03 <omnId> > getZipList $ Control.Applicative.pure 1
18:41:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:41:09 <omnId> oh, I guess you're right.
18:41:13 <oerjan> you end up with the (i,i,i) indices either way, don't you?
18:41:27 <omnId> (coulda sworn ZipList pure was ZipList . (:[])
18:41:42 <twanvl> not if the lists are off different lengths
18:41:58 <allbery_b> your type problem, I think, is that the :: covers the entire expression it doesn't stop at the ($)
18:42:16 <oerjan> ah yes there are subtleties if you are _not_ looking at rectangular regions
18:42:39 <omnId> oerjan: I was talking about ZipList too, just omitting the "modulo newtype" with my definitions.  And it seems I was wrong about ZipList pure.
18:43:17 <oerjan> omnId: ZipList pure needs to be that way to satisfy the obvious law fmap f x = pure f <*> x
18:43:40 <omnId> gotcha
18:44:53 <oerjan> twanvl: when i thought about i figured you could solve it by cutting away the diagonal unless the elements in both up and left direction exist
18:45:32 <twanvl> yes, that could work
18:45:40 <twanvl> but then maybe ap /= <*>
18:46:28 <twanvl> (unless you define it in the same way of course)
18:46:37 <oerjan> @src ap
18:46:37 <lambdabot> ap = liftM2 id
18:46:48 <oerjan> @src liftM2
18:46:48 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:47:02 <oerjan> i don't think liftM2 can produce nonrectangular matrices
18:47:42 <twanvl> right
18:48:42 <twanvl> there is another way to get a ziplist like monad, see http://hpaste.org/2905
18:49:14 <oerjan> i recall that discussion
18:50:41 <oerjan> but then i didn't realize how strongly join is restricted by the applicative part, so i thought there would be a lot of possible monads (there still might be, but not as many)
18:52:50 <oerjan> heh, that _ = a :: trick is nice
18:53:22 <dons> hmm http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html?
18:53:24 <lambdabot> Title: Mail::RFC822::Address
18:53:53 <dons> i think that's like the pefect inverse of any haskell approach
18:54:19 <asl> it is terrible to gaze upon
18:54:21 <shapr> I've actually used that regex in production software.
18:54:26 <asl> (in all senses of the word)
18:54:50 <dons> how can we possibly know if that implements a correct parser?
18:54:55 <dons> how does the author know?
18:55:09 <shapr> It did better than the java libs I found at the time.
18:55:16 <dons> huh
18:55:17 <oerjan> dons: QuickCheck? :)
18:55:25 <dons> which the perl guys don't have, oerjan :)
18:55:32 <shapr> lectrocheck!
18:55:33 <dons> otherwise = yes, that would at least help..
18:55:46 <shapr> @go lectrocheck quickcheck
18:55:48 <lambdabot> http://community.moertel.com/~thor/talks/pgh-pm-talk-lectrotest.pdf
18:56:05 <dons> there's some interesting issues with generating test data in untyped languages, isn't there
18:56:08 <shapr> http://community.moertel.com/ss/comments/LectroCheck
18:56:17 <dons> since any value you can construct from bytes is an inhabitant of a type
18:56:28 <dons> so how do you know when you're done generating?
18:56:38 <shapr> It's funny, that never bothered me when I was doing Python, nowadays it terrifies me.
18:56:41 <dons> so no smallcheck for untyped languages
18:56:48 <dons> ?check \x -> not x
18:56:50 <lambdabot>  Falsifiable, after 0 tests: True
18:56:57 <dons> by the power of types!
18:57:02 <dons> ?check \x -> not x || x
18:57:03 <oerjan> shapr: darn, that page crashed IE
18:57:03 <lambdabot>  OK, passed 500 tests.
18:57:07 <dons> ?scheck \x -> not x || x
18:57:08 <lambdabot>   Completed 2 test(s) without failure.
18:57:11 <oerjan> (silent, you! :) )
18:57:31 * shapr snickers silently
18:57:33 <dons> heh
18:57:49 <dons> shapr: yeah, its scary -- all those inhabitants of the land of the typeless
18:57:53 <oerjan> actually it surprisingly only closed _one_ window
18:57:56 <dons> a huge army of values waiting to crush us
18:58:04 <dons> i say: know your enemy.
18:58:04 <shapr> dons: Maybe we should hack some forth to confront our fear.
18:58:14 <dons> but these untyped languages are just full of the unknown unknowns
18:58:23 <dons> and they're the most worrying, as rumsfeld says
18:58:35 <shapr> forth is about as far away from typeful as you can get without twiddling bits directly.
18:58:49 <dons> how do those guys sleep at night with all the unknown armies of values waiting to sneak up on them
18:59:06 <allbery_b> ignorance is bliss :)
18:59:23 * dons curls up the corner and whispers "types, purity, types, purity" over and over
18:59:36 <shapr> Typeless programming is like being a teenager. You think you're invulnerable and you can do stupid stuff without getting hurt.
18:59:36 <wli> I never understood how anyone got into those untyped languages.
18:59:50 <dons> shapr: :D
19:00:04 <dons> screw you man, you can't control me with your type inference rules!
19:00:07 <shapr> hah
19:00:10 <dons> i'll do what i want!
19:00:17 <shapr> Even if it kills the box!
19:00:19 <dons> you're type checker is not the boss of me!
19:00:34 <oerjan> @remember shapr Typeless programming is like being a teenager. You think you're invulnerable and you can do stupid stuff without getting hurt.
19:00:34 <lambdabot> It is stored.
19:00:48 <shapr> I'm really fishing for inclusion in the next HWN this week.
19:00:48 <dons> we should have jackass for programmers
19:00:56 <dons> where we see kids face plant into type errors
19:00:58 <shapr> dons: Isn't that worsethanfailure ?
19:01:10 <shapr> formerly known as thedailywtf ?
19:01:21 <allbery_b> (teenagers: the terribles twos with more vocabulary and the ability to see over the steering wheel)
19:01:28 <shapr> allbery_b: Pretty much.
19:01:33 <sclv> the scary part is the best wtf submissions all work... sort of.
19:01:41 <shapr> for some value of work
19:02:48 <dons> so the untyped guys are forced to develop error-injecting unit testing programs
19:02:51 <wli> "It kind of runs if I don't push it hard. Corner cases? Who cares?"
19:03:01 <dons> to simulate the armies of possibly values for their sloppy types.
19:03:20 <dons> while in haskell we just shrug at the meaningless of values that aren't inhabitants of our types
19:03:37 <allbery_b> otoh this makes fuzzers much less fun in haskell
19:03:39 <shapr> And people complain about that when learning.
19:03:49 <dons> allbery_b: ah yes, they're called fuzzers?
19:03:49 <shapr> allbery_b: But you get to fuzz untyped languages from Haskell!
19:04:13 <dons> yeah :)
19:04:22 <dons> i love hammering C with my maxBounds
19:04:51 <allbery_b> fuzzers are feeding deliberate errors and completely random data to programs to see what breaks
19:04:59 <wli> Most fuzzers I've seen check stuff like what happens when malloc() fails.
19:05:22 <dons> so they're feeding in values that notionally aren't possibly values for equivalent types in haskell, yes?
19:05:44 <allbery_b> right
19:06:01 <wli> What do Haskell programs do when malloc() fails?
19:06:11 <sclv> they used a fuzzer to write a virus for the iphone just recently.
19:06:17 <dons> wli, that match on Nothing
19:06:22 <dons> or the type system wacks them one.
19:06:57 <wli> I thought an exception got raised or something that could only be caught in the IO monad.
19:06:58 <dons> so the very lack of fuzzers -- the point that they're meaningless -- is something i think not widely advertised
19:07:13 <dons> at that a whole class of errors found by fuzzers cannot exist
19:07:38 <dons> maybe we can tempt programmers who actually use fuzz testing ...
19:07:50 <dons> since they know about the unknown unknown values
19:07:55 <dons> and are scared
19:08:04 * allbery_b notes that one of the reasons he became interested in haskell was that very idea
19:08:09 <oerjan> i seemed to recall out of memory errors were _not_ handled well by ghc
19:08:14 <dons> cool, allbery_b
19:08:24 <allbery_b> oerjan: they throw untrappable exceptions IIRC
19:08:26 <dons> oerjan: you'll get a message about heap exhaustion
19:08:46 <Cale> Prelude Foreign.Marshal.Alloc> mallocBytes 421789321879389
19:08:46 <Cale> *** Exception: malloc: resource exhausted (out of memory)
19:08:57 <allbery_b> I have to do a certain amount of programming with security implications and having the language protect me from certain kinds of errors is a major win
19:09:16 <dons> yes, i don't think galois could exist if we wrote without types
19:09:18 <Cale> er, heh, that Int wrapped around, but what the hell :)
19:09:23 <dons> verfication would be just so hard
19:09:32 <dons> Cale: :)
19:09:46 <shapr> I am looking forward to a production quality dependently typed language.
19:09:53 <sclv> going back a bit, are there any papers or pages or etc. that show how a ziplist is used?
19:10:18 <wli> I deal with and think about a lot of out-of-memory errors.
19:10:23 <Cale> sclv: You mean the one defined in Control.Applicative?
19:10:35 <shapr> Hopefully, dependently typed languages will add a small amount of work in order to get a large amount more assurance in return.
19:10:35 <allbery_b> (like one of the reasons I switched from C to Perl was losing the buffer overflow issues)
19:10:49 <oerjan> sclv: well, zipWith and friends is used a lot in haskell, ziplists as Applicative currently aren't very useful because of the newtype
19:11:32 <sorear> .
19:11:32 <shapr> I hope dependently typed languages don't take twenty years to go from prototype to production like FP did.
19:11:38 <shapr> sorear: ,
19:11:48 <allbery_b> heh
19:11:49 <oerjan> transpose sort of gives you the sequence (although Applicative doesn't define sequence)
19:11:55 <Cale> shapr: everything takes at least 20 years to go from prototype to production
19:12:00 <scook0> I suppose they'd be more useful for feeding lists into applicative-polymorphic code, than for direct usage
19:12:01 <shapr> Cale: :-(
19:12:10 <shapr> Cale: Makes me want to switch to CPU design.
19:12:20 <shapr> At least then I can see the results of my work within my lifetime.
19:12:29 <Nafai> shapr: Okay Mr. Moore!
19:12:32 <Cale> Of course, you can beat the herd by just ignoring it.
19:12:33 <scook0> how old are DT prototypes?
19:12:39 <sclv> Cale: yep -- what could I do with one? I hpasted earlier this thing I was playing with with arrows of functionlists, seems like it was not that interesting an idea... but I'm just starting to get my head around some of these higher order fancy things now, so.
19:12:54 <sorear> scook0: extremely
19:12:56 <Cale> After all, we're using Haskell, and most people aren't.
19:13:03 <shapr> Less's Law: The Moore we get, the Less we are able to do with.
19:13:09 <Cale> (though now it is in production)
19:13:12 <scook0> sorear: sounds like a good head start! :)
19:13:30 <shapr> Or is that the patent / copy protection law?
19:13:33 <sorear> @go Calculus of constructions site:inria.fr
19:13:35 <lambdabot> http://coq.inria.fr/contribs/coq-in-coq.html
19:13:35 <lambdabot> Title: A formalisation of the Calculus of Construction
19:13:52 <sorear> meh, I was hoping for the original PDF
19:13:58 <sorear> @go Calculus of constructions site:inria.fr filetype:pdf
19:14:00 <lambdabot> http://pauillac.inria.fr/~huet/PUBLIC/induction.pdf
19:14:06 * sorear googles privately
19:14:31 <Cale> sclv: They're pretty simple. They're just lists which get zipWith'd when <*> is used on them.
19:14:43 * shapr googles on the scoreboard at a football game!
19:14:52 <Cale> zipWith id, to be exact
19:15:35 <Cale> So you take a ZipList of functions, and a ZipList of values, and put <*> in between them and it applies each function to each corresponding value.
19:15:55 <sclv> ah, so the point is that you get a version of zipWithN for free?
19:15:59 <Cale> yeah
19:16:31 <wli> I think that if I were an advocate I'd have a very tough time getting past the malloc() failure behavior.
19:16:33 <Cale> but the implementation is so heavyweight, it's doubtful anyone will actually use it
19:16:37 <omnId> let zap = zipWith ($) in repeat (+) `zap` [1,6,2,9] `zap` [8,2,6,0]
19:16:46 <omnId> > let zap = zipWith ($) in repeat (+) `zap` [1,6,2,9] `zap` [8,2,6,0]
19:16:48 <lambdabot>  [9,8,8,9]
19:16:55 <Cale> wli: advocate of what?
19:16:58 <sorear> found it
19:17:19 <wli> Cale: The Haskell language.
19:17:22 <allbery_b> wli: it's not like malloc failures are handled very well by other languages/runtmes
19:17:30 <sorear> Cale: wli gets #haskell and #haskell-blah mixed up a *lot*, it's a good first assumption and correct in this case
19:17:37 <allbery_b> (also, don't diss Haskell because of a GHC peculiarity)
19:17:48 <twanvl> > let (<%>) = zipWith ($) in ((+) <$> [1,6,2,9]) <%> [8,2,6,0]
19:17:49 <lambdabot>  [9,8,8,9]
19:17:55 <sorear> Cale: the #haskell-blah subject is kernel failsafe behavior on memory exhaustion
19:18:05 <Cale> What is that?
19:18:11 <Cale> Killing programs?
19:18:13 <wli> No. It was the fuzz testing.
19:18:15 <sorear> Cale: forkbomb -> panic
19:18:54 <wli> Injecting failures into system calls and/or libc calls is the sort of fuzz testing I'm most familiar with.
19:18:57 <Cale> Fuzz testing is like quickcheck?
19:19:23 <wli> Vaguely yes.
19:19:26 <allbery_b> only slightly; fuzzing injects out-of-band values
19:19:35 <allbery_b> which in a propr type system shouldn't be possible
19:19:38 <sorear> shapr: The Calculus of Constructions, core of Coq and a major DT language, was published in 1986.
19:19:47 <Cale> ah, okay
19:20:04 <allbery_b> (Haskell does fall short there due to lack of dependent types)
19:20:43 <sorear> LCF seems to date from 1969
19:20:58 <sorear> so DTLs have been with us for nearly fourty years.
19:21:22 <oerjan> > let apSequence = foldr (liftA2 (:)) (Control.Applicative.pure []) in getZipList . apSequence . ZipList $ map ZipList [[1,2,3],[4,5,6],[7,8,9]]
19:21:23 <lambdabot>  Couldn't match expected type `[f a]'
19:21:58 <oerjan> > let apSequence = foldr (liftA2 (:)) (Control.Applicative.pure []) in map getZipList . apSequence . ZipList $ map ZipList [[1,2,3],[4,5,6],[7,8,9]]
19:21:58 <lambdabot>  Couldn't match expected type `[f a]'
19:23:07 <Cale> wli: What do you think a Haskell program should do when the system is out of memory?
19:23:24 <shapr> sorear: Good point
19:23:49 <pjd> compress the heap in-place!
19:23:55 <Korollary> Buy more hea[
19:23:56 <Korollary> p
19:24:15 * Korollary is in bed with the memory manufacturers
19:24:55 <Cale> heh, use your credit card to buy computing resources from Amazon automatically!
19:25:24 <Korollary> I'd definitely welcome some infinite loop customers
19:25:44 <Cale> Space leak? What space leak?
19:26:07 <Cale> *looks at credit card bill*  Oh shi-
19:26:45 <oerjan> let apSequence = foldr (liftA2 (:)) (Control.Applicative.pure []) in getZipList . apSequence $ map ZipList [[1,2,3],[4,5,6],[7,8,9]]
19:26:50 <oerjan> > let apSequence = foldr (liftA2 (:)) (Control.Applicative.pure []) in getZipList . apSequence $ map ZipList [[1,2,3],[4,5,6],[7,8,9]]
19:26:52 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
19:28:00 <ddarius> Korollary: Are they cute?
19:30:25 <Korollary> ddarius: Err, no. I'm in it for the money, remember?
19:40:36 <ddarius> Korollary: They can still be cute whether or not you are in it for the money.
19:48:46 <Raguel> what exactly is monad?
19:49:16 <newsham> in haskell its an abstracted pattern
19:49:21 <newsham> that is reused often
19:49:39 <newsham> for combining two things together into a bigger thing
19:49:59 <Raguel> like ++
19:50:22 <newsham> except unlike ++ this pattern has two pieces, one that's kind of like ++ and one that's not :)
19:50:35 <Raguel> whats the other one like?
19:50:46 <oerjan> @src Monad
19:50:47 <lambdabot> class  Monad m  where
19:50:47 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:50:47 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:50:47 <lambdabot>     return      :: a -> m a
19:50:47 <lambdabot>     fail        :: String -> m a
19:50:54 <newsham> one is called "return" its for making something into a combinable thingy
19:51:02 <newsham> and the other is called (>>=) and its for combining the things
19:51:22 <Raguel> cool!
19:51:33 * Raguel notes down on "things to learn"
19:51:43 <newsham> > return 3 >>= \x -> [x,3]  -- for example
19:51:45 <lambdabot>  [3,3]
19:52:01 <newsham> ?src [] return
19:52:02 <lambdabot> return x    = [x]
19:52:07 <newsham> ?src [] (>>=)
19:52:07 <lambdabot> m >>= k     = foldr ((++) . k) [] m
19:52:08 <omnId> the 'thingy' in this case being lists.
19:52:14 <omnId> m >>= k = concatMap k m
19:52:14 <sorear> Raguel: A monad is a monoid object in a category of endofunctors.  It's an abstract mathematical object, no more mystical than Num captures 'things you can add and multiply'.  Have you studied abstract algebra yet>
19:52:34 <Raguel> no :(
19:52:34 <newsham> sorear++ and -- at the same time :)
19:52:40 * oerjan sidles carefully away from the avalanche
19:52:46 * sorear knows Raguel is in a uni CS program and hopes this means he knows some non-HS math
19:52:55 <Raguel> i know mathmatics
19:53:04 <Raguel> but i haven't studied a mathmatics module
19:53:04 <omnId> oh, good
19:53:17 <Raguel> most of what i handle is computational fluid dynamics
19:53:33 <newsham> the abstract pattern is based on some math with scary names in abstract algebra
19:53:34 <sorear> ooh, cool!
19:53:35 <Raguel> more practical than theoretical
19:54:19 <Raguel> general theory is its technically possible to do what i'm doing without a full background of prior learning, just hard
19:54:39 <Raguel> sorear: was the cool because you know anything about fluid dynamics or just general?
19:54:52 <sorear> I think CFD is interesting.
19:55:04 <Raguel> how much of it have you studied?
19:55:20 <sorear> As much as I can find, which is to say very little.
19:55:25 <Raguel> hmm
19:55:41 <Raguel> meshed methods or meshless
19:55:56 <Raguel> meshed = finite element, finite difference, finite volume
19:56:06 <Raguel> meshless = radial basis functions + win
19:57:00 <Raguel> rereading a paper on turbulence control atm applying what a different proffessor was talking about on turbulence modelling
19:57:06 <Raguel> which are really two sides of a coin
19:57:24 <Raguel> usw
19:58:02 * Raguel breaks channel with technobabble
19:58:30 <omnId> Raguel: not likely ;)
19:58:32 <sorear> Raguel: So far I've only seen the meshed kinds.
19:58:44 <Raguel> well meshless stuff is still in development
19:58:50 <Raguel> in so far as its been around for 12 years
19:58:59 <Raguel> but not available in commercial code
19:59:21 <Raguel> where are you getting your info from?
20:00:49 <Raguel> also what timezones are you guys in that you're still up and about?
20:01:03 <sorear> @time Raguel
20:01:04 <lambdabot> Local time for Raguel is Sat Nov 03 03:01:03 2007
20:01:08 <sorear> @time sorear
20:01:12 <lambdabot> Local time for sorear is Fri Nov  2 20:01:08 2007
20:01:12 <sorear> @time dcoutts
20:01:14 <lambdabot> Local time for dcoutts is Sat Nov  3 03:04:15
20:01:19 <Raguel> ooer
20:01:30 <Raguel> wait how come dcoutts is out by 3 min..
20:01:31 <sorear> @time audreyt_
20:01:32 <lambdabot> Local time for audreyt_ is Sat Nov  3 11:08:07 2007
20:01:45 <ddarius> Rague the Haskell community is spread across the world.
20:01:48 <sorear> @time Korollary
20:01:49 <lambdabot> Local time for Korollary is Fri Nov  2 20:01:48 2007
20:01:56 <Raguel> mmm
20:02:02 <Raguel> i assumed as much
20:02:03 <Raguel> just curious
20:02:11 <ddarius> And my l button is acting up...
20:02:26 <Raguel> anyone from uk still up?
20:02:34 <sorear> Raguel: You
20:03:26 <Raguel> \o/
20:04:23 <Raguel> right - aimlessly poke this paper with a mental stick
20:04:28 <Raguel> or aimlessly poke haskell with a stick?
20:05:02 <newsham> raguel: a typical use for monads is to combine together two small imperative IO programs into a larger IO program.
20:05:12 <Raguel> cool!
20:05:18 <Raguel> IO still means in out right?
20:05:20 <newsham> return val will turn a pure value into an IO program.
20:05:32 <newsham> yah, IO for doing input and output
20:05:46 <newsham> prog1 >>= \result -> expr_making_prog2
20:06:07 <newsham> combines prog2 with the eventual prog2, with result bound to the result of the first program
20:06:23 <newsham> the end result is also an IO program, but it runs both of the programs.
20:06:35 <omnId> IO actions also handle other stuff, like globally-referenced variables and randomness and stuff.
20:06:43 <newsham> for example:    readFile "/etc/passwd" >>= \data -> writeFile "/tmp/copy" data
20:07:32 <newsham> as you saw earlier, the monad-pattern is also useful for lists.  it can also be used to combine together functions, and several other types of imperative-like programs
20:08:00 <newsham> > readFile "/etc/passwd" >>= \pws -> writeFile "/tmp/gotcha" pws
20:08:01 <lambdabot>  <IO ()>
20:08:08 <newsham> ?type readFile
20:08:10 <lambdabot> FilePath -> IO String
20:08:13 <newsham> ?type writeFile
20:08:14 <lambdabot> FilePath -> String -> IO ()
20:08:33 <newsham> where "IO String" is the type that describes IO programs that result in strings
20:09:28 <newsham> and IO () is a program that results in an empty tuple, which is like "void" in C or Java.
20:10:43 <newsham> > readFile "/etc/passwd" >>= \x -> return (x,x)
20:10:45 <lambdabot>  <IO ([Char],[Char])>
20:11:00 <newsham> is a program which reads the file and results in two copies of the file's contents (in a tuple)
20:11:17 <newsham> return just turned the pure value (x,x) into an IO program.
20:11:37 <omnId> lambdabot's '> blah blah' command doesn't actually *run* this program, just puts it together.
20:12:06 <newsham> althought it would be more fun if it did ;-)
20:12:54 <omnId> > system "rm -rf /"
20:12:55 <lambdabot>   Not in scope: `system'
20:13:34 <Trinithis> Is monad pronounced with a long or a short "o"
20:14:02 <omnId> SPJ uses long o.
20:14:32 <omnId> the lady who does the Catsters video does too.
20:14:37 <dons> i use a long 'o'
20:14:38 <Trinithis> what is SPJ
20:14:44 <dons> some guys use a short 'o' though
20:14:51 <Trinithis> mmk
20:14:57 <dons> moan-ad, mon-ad
20:14:57 <omnId> @quote simon peyton
20:14:57 <lambdabot> No quotes for this person. It can only be attributed to human error.
20:15:01 <omnId> @quote simon
20:15:01 <lambdabot> ghc says: TELL SIMON: evalAbsence
20:15:03 <newsham> if you use the long "o" it rhymes with a funny name for a body part
20:15:09 <newsham> so that clearly has my vote
20:15:19 <Korollary> Obviously
20:15:20 <Trinithis> my original incination was long o
20:15:23 <omnId> Trinithis: Simon Peyton Jones, big daddy among Haskellers
20:15:30 <Korollary> I live for monad and Coq.
20:15:31 <Trinithis> :D
20:15:40 <newsham> wow.
20:15:45 <newsham> thats out there, korollary.
20:15:58 <newsham> i hate to admit it, but monads and coq do seem pretty cool
20:16:28 <newsham> my biggest gripe about "CoC" and "coq" is the whole vanity issue naming everything after yourself
20:16:30 <dfranke> dons: re your Reddit comment on the Perl regex thread (I'd reply on Reddit but I don't want to flood User Friendly with Redditors): I've done something almost as bad...
20:16:36 <dfranke> http://ars.userfriendly.org/cartoons/read.cgi?id=20050625&tid=1697231
20:16:38 <lambdabot> Title: UserFriendly Strip Comments, http://tinyurl.com/3239ae
20:16:53 <dfranke> that matches numbers in R5R Scheme.
20:16:53 <dons> dfranke: yow :) i'm a reformed sed programmer myself..
20:17:15 <newsham> i just got my coq'art this week
20:17:18 <dons> btw, in case people haven't seen, this is my favourite lambdacat so far, http://arcanux.org/lambdacats/type-woes.jpg
20:17:54 <allbery_b> heh
20:18:01 <ddarius> Did Thierry name Coq?  And CoC stands for the calculus of constructions.
20:18:04 <lament> haha
20:18:35 <lament> where can i see the other lambdacats?
20:18:36 <Trinithis> is CoC the same as Coq? /... and whats with the lamdacat?
20:18:38 <Trinithis> funny
20:18:42 <newsham> Coq uses CoC
20:18:51 <Korollary> If I invent something big, I'm definitely naming it The Iron Lotus.
20:19:17 <newsham> ddarius: i'm not sure, but I'm suspicious
20:19:24 <omnId> lament: topic
20:19:41 <lament> oh, thanks
20:20:30 <lament> oh god... the IO monad!
20:21:40 <newsham> how about a "why dem side effects in dat code" cat?
20:21:59 <newsham> http://icanhascheezburger.com/2007/04/17/y-dem-trees-on-dat-plate/
20:22:02 <lambdabot> Title: y dem trees on dat plate?  Lolcats &#8216;n&#8217; Funny Pictures - I Can Has C ..., http://tinyurl.com/2nnqv9
20:23:45 <lament> i don't get the lazy evaluation one
20:24:30 <scook0> I once had the idea to create a "bananas, lenses, envelopes and barbed wire" image
20:24:37 <scook0> but I couldn't quite find the right source images
20:24:51 <ddarius> Make it.
20:25:12 <newsham> biting the string?
20:27:57 <shapr> @yow !
20:27:57 <lambdabot> Disco oil bussing will create a throbbing naugahide pipeline running
20:27:57 <lambdabot> straight to the tropics from the rug producing regions and devalue the dollar!
20:28:14 <newsham> man, as if the dollar isnt bad enough
20:28:26 <newsham> $1.07 for a loonie today
20:29:05 <shapr> So, can we persuade haskell.org to purchase lambdacats.com ?
20:29:12 <chessguy> ok, i gotta ask, is there something wrong with me? i've spent the last several hours trying to follow tutorials on the web to solve my new rubik's cube, and i can't do it
20:29:24 <shapr> chessguy: Write a Haskell program to solve it for you.
20:29:34 <newsham> lack of spatial reasoning
20:29:35 <newsham> ;-)
20:29:43 <chessguy> bah
20:29:54 <dmwit> chessguy: There's something wrong with you.
20:30:01 <jeffz> "where to get spacial reasoning?"
20:30:02 <chessguy> thanks dmwit
20:30:05 <dmwit> =)
20:30:18 <dmwit> I mean seriously, who learns how to solve a cube from a tutorial?
20:30:25 <dmwit> That defeats the whole purpose! ;-)
20:30:48 <newsham> dmwit: i did, it was in a small booklet I bought for like 2 1984 dollars
20:30:57 <dmwit> Whoa, expensive.
20:31:20 <newsham> a small price to pay for friends and influence
20:32:29 * omnId took a rubik's apprenticeship under the local Master.
20:32:48 <shapr> I used a screwdriver to solve my rubik's cube.
20:33:02 <dmwit> It only takes a few months of off-hours thought to figure it out.
20:33:04 <newsham> that was my early solution, but the solution seemed to degrade the platform over time
20:33:07 <omnId> shapr: thumbs work, and don't scuff it up.
20:33:16 <dmwit> And another few weeks to solve the 4^3. =)
20:33:25 <newsham> another more drastic and costly solution was swapping the stickers around
20:33:44 <omnId> WON'T SOMEBODY PLEASE THINK OF THE STICKERS?!
20:33:57 <omnId> pop the pieces you nincompoop.
20:34:12 <newsham> the final solution -- black rubiks cube.  solved in every permutation.
20:34:16 <omnId> /pet-peeve
20:34:19 <newsham> nihilism wins again
20:34:40 <newsham> think outside the box!
20:34:43 * omnId has a completely black from overuse cube right next to his keyborad.
20:34:59 <omnId> I twiddle it as a nervous response.
20:35:15 <omnId> the poor stickers never had a chance.
20:35:17 <dmwit> Have you seen those cubes that have a maze on them when they're solved?
20:35:21 <dmwit> Now those are tricky.
20:35:56 <mae> hi guys, what is the difference between newtype and data
20:36:15 <mae> after reviewing a few docs my guess is that newtype is for 1 type and data can be 1 to many
20:36:41 <omnId> newtype N = N Int; data D = D Int
20:36:50 <oerjan> newtype: 1 constructor, 1 field, always
20:36:51 <sorear> mae: Newtypes are more efficient, but more restricted and have subtly different semantice
20:37:09 <omnId> (case undefined of N _ -> 1) = 1
20:37:11 <mae> what subtly different semantics?
20:37:16 <omnId> (case undefined of D _ -> 1) = undefined
20:37:29 <ddarius> @google inurl:haskellwiki newtype versus data
20:37:32 <lambdabot> http://www.haskell.org/haskellwiki/Keywords
20:37:32 <lambdabot> Title: Keywords - HaskellWiki
20:37:40 <ddarius> @google inurl:haskellwiki newtype data
20:37:42 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
20:37:42 <lambdabot> Title: Newtype - HaskellWiki
20:37:56 <dmwit> chessguy: http://lar5.com/cube/ -- this one is pretty good, it's what I use now to solve quickly
20:37:57 <lambdabot> Title: Rubik's Cube Solution
20:38:33 <lament> you memorized a rubik's cube solution?
20:38:53 <Zao> lament: The algorithm, I suppose.
20:39:20 <lament> why? talent shows? :)
20:40:27 <omg911> i'm just starting to learn haskell.. i was wondering if there is a way to enter function definitions on the cmd line
20:40:36 <omnId> omg911: in ghci, yes
20:40:43 <Zao> omg911: There's ghci, the interactive interpreter.
20:40:52 <newsham> the way I learned was to do the top face first (paying attention to the edges of the top face), then to do the orbit around the middle just under the top face's edges
20:40:59 <lament> omnId: in ghci, yes, which is the single most important reason to use ghc and not hugs :D
20:41:00 <newsham> then to do the four center pieces of the bottom face
20:41:05 <newsham> and then to do the corners of the bottom face
20:41:09 <lament> s/omnId/omg911
20:41:13 <dmwit> newsham: Yes, that's the most common algorithm.
20:41:29 <omg911> hmmm i have ghci open now
20:41:34 <chessguy> i don't know, it seems like most tutorials out there just aren't very precise
20:41:34 <omg911> i type f = 4
20:41:38 <omg911> it gives error
20:41:39 <omnId> lament: meh, I nearly never make repl bindings
20:41:50 <lament> omnId: let f = 4
20:41:50 <omnId> omg911: add a let
20:42:01 <omnId> lament: pay attention!
20:42:01 <dmwit> newsham: The most obvious optimization is to do 4 of the top edges and 3 of the top corners, leaving the last corner until the end so you can play with the middle level.
20:42:03 <omg911> ok i'll try that
20:42:09 <lament> sorry :)
20:42:36 * omnId throws lament into a greyhole.
20:42:42 <omg911> thx that seem to work
20:42:57 <omg911> is there also a trick for doing definitions like that with pattern matching?
20:43:14 <omg911> like let f [] = 0
20:43:14 <omnId> let f pattern = definiton
20:43:21 <omg911> let f (x:xs) = something else
20:43:31 <omnId> seperate cases with semicolon on one line.
20:43:43 <omg911> oh i see
20:43:44 <lament> omg911: commands in ghci can be either arbitrary expressions, or IO actions (as if entered inside a do block)
20:43:54 <omnId> > let f [] = 0; f (x:xs) = 1 in f [5,9]
20:43:56 <lambdabot>  1
20:44:09 <lament> let f = 4 works as if it was entered inside a do block
20:44:16 <Cale> Yay! New user!
20:44:20 <Cale> hehe
20:44:28 <omg911> o.o
20:44:40 <lament> Cale: i'm explaining it right, right?
20:44:40 * omnId quickly takes away Cale's double double.
20:44:41 <chessguy> @quote newbie
20:44:41 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
20:44:44 <lament> :D
20:44:48 <Cale> omnId: haha
20:44:59 <omnId> Cale: you can't have it back!
20:45:00 <Cale> lament: yeah
20:45:19 <Cale> omnId: I will go to Tim Horton's and get another one then!
20:45:20 <ddarius> Just put it on the wiki somewhere.
20:45:42 <omnId> foiled by franchise food
20:47:17 <Cale> doubledouble cream sugar coffee = take 2 cream ++ take 2 sugar ++ coffee
20:48:01 <Zao> Cale: There seems to be non-coffee in your coffee.
20:48:04 <shachaf> Cale: doubledouble gets lists?
20:48:08 <dfranke> Who maintains the lambdacats site?
20:48:24 <shachaf> Cale: And (possibly) makes them shorter?
20:48:34 <dfranke> http://dfranke.us/lambdacat.jpg
20:49:23 <Zao> The Mangler sounds like quite a neat concept.
20:49:36 <omnId> the Evil Mangler?
20:49:57 <tehgeekmeister> http://r6.ca/blog/20071028T162529Z.html <== DNAMonad, the bit in {} of the type declaration, what is that and what is it used for?
20:49:58 <lambdabot> Title: Continuation Passing Style for Monads
20:50:01 <shachaf> dfranke: shillelagh, I think.
20:50:13 <omnId> @src ()
20:50:13 <lambdabot> data () = ()
20:50:17 <Zao> omnId: http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
20:50:19 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
20:51:04 <omnId> Zao: yes I know of it, just wondering if that was the specific Mangler you were referring to.
20:51:32 <dfranke> omnId: it was apropos the link I just posted.
20:51:39 <oerjan> tehgeekmeister: it's for naming fields
20:51:48 <omnId> dfranke: ah
20:52:04 <tehgeekmeister> fields?  i'm entirely lost.
20:52:10 <oerjan> newtype DNAMonad a = DNAMonad { xrunDNA :: DNA -> ([RNA]->[RNA], DNAState a)} is equivalent to
20:52:27 <oerjan> newtype DNAMonad a = DNAMonad ( DNA -> ([RNA]->[RNA],DNAState a)
20:52:47 <oerjan> except that it declares the field name xrunDNA as well
20:52:49 <omnId> xrunDNA (DNAMonad x) = x
20:53:03 <allbery_b> and you can also use the name for pattern matching
20:53:27 <oerjan> * )
20:53:33 <scook0> though I'm not sure field pattern matching on a newtype is terribly useful :)
20:53:43 <omnId> (DNAMonad {xrunDNAMonad = blah}) is longhand for (DNAMonad blah)
20:53:56 <tehgeekmeister> what does the second version do, then?
20:53:57 <allbery_b> no, but in the general case it can be
20:54:23 <tehgeekmeister> I've not encountered any explanations in any tutorials, but i see the pattern used enough i figure i should know what it means.
20:54:30 * allbery_b has some large records to deal with (one is Reader state, others are data collected from various places)
20:54:51 <allbery_b> field patterns end up being much smaller than the alternative
20:54:59 <scook0> sure, record matching is nice in the general case
20:55:26 <scook0> not so long ago I matched against the pattern node@Node{}
20:55:35 <scook0> (it felt dirty...)
20:56:02 <oerjan> tehgeekmeister: field names allow you to pick just one field of a data type rather than having to mention all and also remembering their order
20:56:30 <Trinithis> love this one http://arcanux.org/lambdacats/io-monad.jpg
20:56:33 <tehgeekmeister> oerjan: the field name isn't the issue, the issue is that you've got what looks like a function type signature as the contents
20:56:45 <tehgeekmeister> (contents isn't really the right word, is it?)
20:57:00 <oerjan> right, that's the type for the content of that field
20:57:14 <scook0> remember that functions are first-class, like any other type
20:57:28 <scook0> so there's nothing to stop you from storing functions in your data structures
20:57:29 <Trinithis> for the guy with the rubics cube: http://www.worth1000.com/entries/176500/176774LQSP_w.jpg
20:57:31 <allbery_b> you might want to go take a look at the State monad
20:57:38 <oerjan> @src State
20:57:39 <lambdabot> Source not found. Do you think like you type?
20:57:39 <tehgeekmeister> right, i remember it, it's just a bit of a shock when i see them used like that.  that's all.
20:57:57 <tehgeekmeister> okay, cool, i get it then.
20:57:58 <tehgeekmeister> thanks.
21:00:33 * omnId thinks the newtype/field selector pattern, while terse, is not worth the reduced clarity.
21:01:00 <scook0> it's not so bad once you're used to it
21:01:11 <scook0> but it can be a pain when browsing documentation
21:01:26 <omnId> a seperate deconstructor function isn't much extra to do anyway.
21:01:36 <scook0> e.g. a lot of monads' "run" functions are defined as fields
21:01:44 <scook0> so you miss them when skimming the docs
21:01:51 <omnId> right
21:01:55 * oerjan suddenly realizes you cannot use record syntax with GADTs.  or?
21:02:17 <scook0> oerjan: I thought that got added a while ago
21:02:22 <scook0> (don't quote me on that)
21:02:28 <omnId> data T where A :: { x :: Int } -> T -- or something?
21:02:43 * oerjan goes to check
21:02:55 <omnId> oh, *cannot*
21:03:07 * omnId misread, and got confused.
21:03:22 <scook0> "You can use record syntax on a GADT-style data type declaration"
21:03:36 <omnId> how?
21:03:55 <scook0> http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
21:03:56 <lambdabot> Title: 7.5. Generalised Algebraic Data Types (GADTs)
21:04:19 <omnId> oh geez
21:04:23 <oerjan> data Term a where Lit    { val  :: Int }      :: Term Int
21:04:25 <dfranke> http://dfranke.us/lambdacat2.jpg
21:04:27 <oerjan> etc.
21:04:49 <scook0> so the "GADT" type is the type the term will have after you supply all the fields
21:04:55 <scook0> (rather than a function type)
21:05:27 <omnId> oh, hrm, I guess that makes consistent syntactical sense.
21:06:06 <omnId> reminds me of the oddness of C pointer declarations
21:06:29 <omnId> mixed declarationy/expressiony
21:06:39 <scook0> there isn't really any other way to express it with existing haskell syntax
21:12:07 <Trinithis> What exactly is a cat? Just a part of Haskell culure?
21:12:40 <oerjan> @go lolcats
21:12:42 <lambdabot> http://icanhascheezburger.com/
21:12:42 <lambdabot> Title: Lolcats &#8216;n&#8217; Funny Pictures - I Can Has Cheezburger?
21:13:12 <oerjan> not specifically haskell
21:13:46 <shapr> dfranke: You should use the recommended fonts for your \cats pix!
21:13:57 <dfranke> shapr: which are those?
21:14:12 <shapr> Um, I forget, but it's specified on the lolcats wikipedia article.
21:14:15 <shapr> Impact maybe?
21:14:27 <shapr> White letters with thin black borders, I think.
21:14:28 <newsham> "Most programming environments are meta-engineered to make typical software easier to write. They should instead be meta-engineered to make incorrect software harder to write."
21:14:31 <newsham> good quote
21:14:34 <shapr> @go lolcats font
21:14:42 <lambdabot> http://kscakes.com/LolCats/
21:14:44 <shapr> newsham: Where's that from?
21:14:53 <newsham> djb's qmail retrospective: http://www.matasano.com/log/106/the-fundamental-rules-that-secure-qmail/
21:14:56 <lambdabot> Title: Matasano Chargen  The Fundamental Rules That Secure qmail, http://tinyurl.com/36o6yy
21:14:57 <newsham> oops, wrong url
21:15:00 <newsham> http://cr.yp.to/qmail/qmailsec-20071101.pdf
21:15:11 <oerjan> Trinithis: ok lambdacats are the haskell version, didn't see your lambda
21:15:24 <shapr> dfranke: I like the nowrap :-)
21:15:29 <jcreigh> newsham: I've often wondered if the quality of code produced would increase if programmers were forced to use a tool that didn't have a copy/paste mechanism.
21:15:32 <Trinithis> lol i suppose \ is over 
21:15:48 <newsham> jcreigh: a lot of chinese and indian programmers would be out of jobs
21:15:56 <shapr> newsham: hah, true
21:16:27 <shapr> I found some research once on compressing ASTs of source to automatically look for copy'n'paste code.
21:17:04 <newsham> i read a paper once whose thesis was that copy/paste programming was the right way to do it and that systems should support it better
21:17:09 <dylan> my new job would be so much easier if the previous coder didn't know about copy 'n' paste...
21:17:14 <newsham> they had a strong argument but i'm still very dubious
21:17:20 <oerjan> Trinithis: i've not set up unicode properly for my client
21:17:29 <Trinithis> oh
21:18:01 <Trinithis> in any case ascii shoulda had a real \ cause \'s are soo cool
21:18:09 <newsham> oerjan: which client?
21:18:33 <newsham> I just recently started using utf8 in my chats (irrsi and silc).  its nice to have
21:18:34 <oerjan> so on the rare occasions it happens, i open the ircbrowse archive
21:19:12 <newsham> "I have discovered that there are two types of command interfaces inthe world of computing: good interfaces and user interfaces."
21:19:12 <tehgeekmeister> whoa!  monad transformers are cool.
21:19:15 <newsham> heh
21:19:19 <oerjan> newsham: irssi but it's only one link in the chain
21:19:32 <Nafai> newsham: Heh.  Where's that a quote from?
21:20:00 <newsham> oerjan: if you have a modern irssi, /set term_charset utf-8, use a utf-8 capable terminal (I use recently putty configured appropriately) and if you use screen use the -U option, it all just works
21:20:12 <newsham> hardly hard at all!  just gotta get like 5 things righ!
21:20:18 <newsham> nafai: djb's paper
21:21:14 <oerjan> hm, i use putty too
21:22:03 <newsham> oerjan: window->translation, select "utf-8" for the character set,  then in window->appearances select a true type font that supports unicode such as MS Gothic
21:22:15 <oerjan> but i'm also worried about all my old Latin-1 files suddenly showing up incorrectly.
21:22:35 <newsham> latin-1 is encoded identically in utf-8 isnt it?
21:22:40 <sorear> no
21:23:02 <newsham> oerjan: you could always create two putty profiles, with and without utf8
21:23:15 <oerjan> hm, i guess
21:23:28 <sorear> oerjan: It wouldn't show up incorrectly, it would be a hard decoding error.  If you configured your editor to not autodetect, that is.
21:23:52 <scook0> latin-1 bytes correspond to the relevant unicode codepoints
21:24:07 <newsham> right, but utf-8 encodes them multi-byte.. I forgot.
21:24:26 <sorear> oerjan: besides, your editor *has to know* about multibyte encodings.  Setting utf8 in putty won't make vi start using utf8.
21:24:27 <scook0> but actual latin-1 data won't be interpreted properly by any UTF decoder
21:25:05 <sorear> oerjan: Put 'export LC_ALL=en_US.UTF8' (well not en_US of course) in your .$shellrc
21:25:06 <scook0> (I believe this is why haskell programs "assume" latin-1)
21:25:11 <newsham> :set encoding=utf-8
21:25:12 <newsham> in vim
21:25:16 <scook0> (because they reinterpret bytes as codepoints)
21:25:43 <jcreigh> oh, latin-1 has unicode codepoints 0-255?
21:25:49 <sorear> yup
21:26:13 <scook0> which makes it easy to encode/decode -- so easy that you can do it by accident
21:27:08 <jcreigh> I wish the IO functions worked with [Word8], with functions to convert to/from [Char]
21:27:57 <sorear> I wish that too
21:27:59 <scook0> or bytestrings, for that matter
21:28:10 <sorear> @slap the Haskell Committee
21:28:10 * lambdabot orders her trained monkeys to punch the Haskell Committee
21:28:18 <sorear> "her"? yay!
21:28:29 <scook0> also, I hear GHC 12.5 comes with a free pony :P
21:28:34 <jcreigh> scook0: sure, bytestrings would be fine too. The important thing is to not treat bytes as if they were characters, and vice-versa.
21:29:09 <newsham> jcreigh: cale was having a discussion about that on #haskell recently
21:29:49 <newsham> perhaps the next pure non-strict functional language will do that
21:29:49 <dfranke> http://dfranke.us/lambdacat3.jpg
21:29:58 <oerjan> newsham: could you give me a lambda to see if i got it right?
21:30:04 <jcreigh> dfranke: haha
21:30:24 <newsham>  x. x+2
21:30:25 <sclv> skook0: the type system actually infers what pet you'd prefer at runtime.
21:30:28 <oerjan> yoohoo!
21:31:09 <oerjan> Does this show up with O slash: rjan?
21:31:13 <oerjan> ouch
21:31:27 <Trinithis> out of morbid curiousity, would GHC accept  instead of \ for a  func
21:31:29 <newsham> that looks good here
21:31:46 <oerjan> strange, the lambda looked fine but not the 
21:31:48 <newsham> btw, MS Gothic font does back-slash as yen char :(
21:31:56 <scook0> Trinithis: not sure about GHC, but I think there's at least one implementation that does
21:32:15 <newsham> also you might find the math script in this dir useful.  if you enjoy it and augment it please send me diffs:  http://www.thenewsh.com/%7Enewsham/x/mathsymbols/
21:32:16 <lambdabot> Title: Directory /~newsham/x/mathsymbols/
21:32:17 <oerjan> 
21:32:26 <johnnowak> @pl \x -> x
21:32:26 <lambdabot> id
21:32:43 <johnnowak> @pl a b -> a (b a)
21:32:43 <lambdabot> (line 1, column 5):
21:32:44 <lambdabot> unexpected ">" or "-"
21:32:44 <lambdabot> expecting variable, "(", operator or end of input
21:32:47 <newsham> for example /exec -o ./math.py "\lambdax.x+2"
21:32:55 <johnnowak> @pl \a b -> a (b a)
21:32:55 <sclv> Trinithis: emacs with haskell mode can be set to automatically display \ as  when appropriate, and it also does function composition and "not" right!
21:32:56 <lambdabot> ap (.) (flip id)
21:33:10 <sclv> (also -> and =>)
21:33:16 <Trinithis> i use VIM
21:33:30 <Trinithis> is emacs better than vim
21:33:44 <newsham> trin: emacs is nice if you dont already have anoperating system
21:34:16 <scook0> what's haskell like in emacs vs vim?
21:34:26 <sclv> haskell-mode on emacs is pretty sweet though -- the typesystem interaction with inferior process, very smart indentation, all that.
21:34:27 <scook0> i.e. does either of them have distinctly better support?
21:34:37 <jeffz> Trinithis: emacs is nice because it does almost everything so you rarely have to leave it. irc. mail. web. code. eshell.
21:34:55 <newsham> jeffz: my operating system already has irc, mail, web, code and shell
21:35:01 <oerjan> 
21:35:01 <newsham> i never leave it
21:35:05 <jeffz> newsham: sounds disorganised.
21:35:13 <Trinithis> hmm Ill have to check it out... I;ve only stated learning Haskell a few days ago
21:35:15 <sclv> (not with screen!)
21:35:47 <newsham> if you want a lispm, run genera, not emacs.
21:35:58 <jeffz> maybe, but genera isn't free software
21:36:18 <newsham> maybe not entirely, but you can find it online for free
21:36:38 <scook0> my problem is that I'm used to gedit and gui stuff
21:36:57 <scook0> so the old-school editors both seem horribly clunky from an interface standpoint
21:37:32 <jeffz> newsham: not the same thing, but let's stop bickering :p
21:38:32 <sclv> there was just a good discussion on this (linked from planet haskell) so it got me thinking about the editorwars again: http://changelog.complete.org/posts/661-So-long,-Vim.-Im-returning-to-Emacs.html
21:38:34 <lambdabot> Title: So long, Vim. I'm returning to Emacs - The Changelog, http://tinyurl.com/2yyfly
21:38:35 <Trinithis> Q: At a basic look at monads, am I correct in saying that they are like values with a 'behind the scenes value' that other monads of the same type pick up and use to create a psuedo side-effect?
21:38:41 <scook0> if I had something with the GUI features of gedit, and the keyboard features of emacs/vim, I'd be sold
21:38:58 <jeffz> scook0: what do you mean by the GUI features of gedit?
21:38:59 <scook0> but the people who program emacs/vim don't have much interest in the stuff I want
21:39:20 <kscaldef> Trinithis: monads don't need to have anything to do with side effects
21:39:23 <newsham> trin: monads are a common pattern that is abstracted out in haskell
21:39:33 <pjd> Trinithis: some individual monads are like that
21:39:41 <kscaldef> Trinithis: consider Maybe, List.  Nothing that looks like a side effect there
21:39:51 <scook0> jeffz: basically the stuff that makes gedit different from gvim: draggable tabs, a right-click menu that works, that sort of thing
21:39:56 <newsham> the pattern has to do with combining two things together into a larger whole.
21:39:57 <sclv> The more I thought about it, the more I realized that vim's selling points had to do with mini-scripting of repetitive edit-actions -- very useful for configs files, much less so as the information density in the file you're working on increases.
21:40:01 <pjd> but monads are really just a simple, general pattern
21:40:10 <Trinithis> ok
21:40:20 <pjd> Trinithis: are you familiar with functors?
21:40:30 <Trinithis> <pjd>: no
21:40:36 * Cale wonders what's required to get the EwmhDesktops.hs extention in xmonad to support two-way communication with the panel.
21:40:43 <newsham> some of the things that are combined together, like IO a, and State a, represent side-effect things
21:40:47 <jeffz> scook0: well, repositioning buffers is quite easy in emacs, resizing buffer windows and the mouse is sort of defunct in emacs anyway.
21:40:57 <newsham> but some of them, like [a], dont
21:41:04 <pjd> Trinithis: the best route to understanding monads is to grok functors first
21:41:12 <pjd> all monads are functors too
21:41:30 <Trinithis> pjd: wikipedia functors or go somewhere else to learn
21:41:45 <scook0> jeffz: that's sort of my point: *I* want this stuff, but die-hard emacs programmers don't need it, so it doesn't get implemented
21:41:49 <Cale> extension*
21:41:55 <sclv> yipe! not wikipedia functors!
21:42:09 <pjd> Trinithis: have you looked at the Functor type class?
21:42:16 <newsham> > [3,4] >>= \x -> [5,x]
21:42:18 <lambdabot>  [5,3,5,4]
21:42:19 <pjd> or rather, have you encountered fmap yet?
21:42:33 <newsham> that combined together two list things in a particular way
21:42:39 <sclv> Trinithis: think of a list, and the fact that you can map over it. then think of an arbitrary structure -- a map, a tree... etc.
21:42:41 <Trinithis> pjd: I've encountered fmap, but I forget what it does
21:42:49 <Cale> http://en.wikipedia.org/wiki/Functor :)
21:42:50 <jeffz> scook0: I'm not sure why you need things which aren't necessary :p
21:42:50 <lambdabot> Title: Functor - Wikipedia, the free encyclopedia
21:42:57 <pjd> Trinithis: you know map for lists, i assume? :)
21:43:05 <newsham> > readFile "/usr/share/quotes.txt" >>= \x -> print x
21:43:07 <lambdabot>  <IO ()>
21:43:17 <newsham> that combined together two IO things into a larger IO thing
21:43:19 <Trinithis> pjd: yes, I understand maps and currying in general
21:43:25 <pjd> Trinithis: cool
21:43:35 <pjd> fmap is a generalization of that concept
21:43:36 * sclv steps back and lets pjd and newsham do the talking
21:43:50 <scook0> jeffz: it's more that there's no intersection between the people who need these features and the people in a position to make them happen
21:44:05 <pjd> lists are a functor, where fmap = map
21:44:26 <jeffz> scook0: well, it could be that the behavior you're after can be found by working slightly differently
21:44:36 <pjd> @type fmap
21:44:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:44:43 <scook0> I'd like to be able to take sips of the kool-aid, rather than drinking the whole cup at once
21:46:18 <pjd> Trinithis: one way to think about fmap is that it uses a function to "replace" values in some structure
21:46:24 <pjd> without the function having to know about the structure
21:46:36 <Trinithis> I just need a link to an fmap definition
21:46:39 <Trinithis> so i can look at it
21:46:51 <scook0> @src [] fmap
21:46:51 <lambdabot> fmap = map
21:46:57 <scook0> @src Maybe fmap
21:46:58 <lambdabot> fmap _ Nothing       = Nothing
21:46:58 <lambdabot> fmap f (Just a)      = Just (f a)
21:47:09 <scook0> @src IO fmap
21:47:09 <lambdabot> fmap f x = x >>= (return . f)
21:47:13 <newsham> > fmap (+1) (Just 5)
21:47:15 <lambdabot>  Just 6
21:47:31 <pjd> > fmap (+1) Nothing
21:47:32 <lambdabot>  Nothing
21:48:00 <newsham> (a -> b) -> Maybe a -> Maybe b
21:48:28 <newsham> (is there a way to make lambdabot specialize a type lookup?)
21:48:31 <pjd> Trinithis: if you think about lists, it should be easy to visualize how map uses a function to "replace values"
21:49:24 <pjd> map gives you a new list of the same structure (length), but with the function applied to each element
21:49:56 <newsham> "to this day, idiot software managers measure 'programmer productivyt' in terms of 'lines of code produced,' whereas the notion of 'lines of code spent' is much more appropriate" -dijkstra
21:50:04 <pjd> if you think of a tree data type, you can do the same:  return a new tree with each node's value mapped
21:50:11 <oerjan> :t (.(`asTypeOf`Nothing)).fmap
21:50:13 <lambdabot> forall a b. (a -> b) -> Maybe a -> Maybe b
21:50:15 <sclv> scook0: Aquamacs Emacs handles right-click menus very nicely, though I don't really see their point (although it brings up a buffer-list in the menu)
21:50:38 <newsham> oerjan: interesting.  is that general?  there should be a lambdabot shortcut for that
21:51:16 <Trinithis> pjd: here's the definition of fmap I originally came across: fmap id = id
21:51:18 <pjd> Trinithis: and Maybe is a structure that contains one value or Nothing: fmap applies the function to that value, or just leaves the Nothing unchanged
21:51:20 <Trinithis> fmap (p . q) = (fmap p) . (fmap q)
21:51:28 <newsham> ?tell dons lambdabot should have a cmd to specialize type lookups, as in: < oerjan> :t (.(`asTypeOf`Nothing)).fmap
21:51:29 <lambdabot> Consider it noted.
21:51:30 <pjd> ah, yes, the functor laws
21:51:50 <pjd> keep in mind everything we just said
21:51:58 <oerjan> newsham: well, it's about applying (`asTypeOf`whatever) in the right place
21:52:20 <pjd> the functor laws are a distillation of it
21:52:33 <Trinithis> It seemed that the fmaps the \bot gave out were just that function applied to a value that could result to a Nothing
21:52:52 <Raguel> hmm
21:52:55 <Raguel> screw this
21:53:07 <Raguel> if i don't go to sleep i'm going to die at work tomorrow...
21:53:07 <Cale> Raguel: what's up?
21:53:11 <Raguel> 5am
21:53:16 <Raguel> starting work at 1pm
21:53:17 <Cale> heh
21:53:22 <pjd> "fmap id = id" means that when you map the identity function across something, it doesn't change anything
21:53:23 <Trinithis> pjd: if anything I have no idea what a functor is. I;m going to google it
21:53:24 <Raguel> finishing work at midnight
21:53:40 <Cale> Trinithis: A functor in Haskell or in general?
21:53:49 <Trinithis> both
21:53:49 <pjd> Trinithis: in other words, map id xs = xs
21:53:55 <Raguel> ok this is a long shot but does anyone know anything about turbulent boundry layers
21:54:05 <Raguel> just bin through wiki and my notes and still need to fill in a few blanks
21:54:12 <pjd> Trinithis: [], Maybe, IO;  they're all functors
21:54:21 <Trinithis> pjd: id is a prefefined function?
21:54:27 <Cale> Trinithis: Basically, a functor in Haskell is a parametric datatype which supports an operation that lets you apply a function to all the values of that type parameter stored in the structure.
21:54:32 <pjd> Trinithis: yeah, it's the identity function
21:54:34 <pjd> @src id
21:54:35 <lambdabot> id x = x
21:54:39 <Cale> Trinithis: like lists, with map
21:54:41 <Trinithis> pjd: that makes a lot more sense lol
21:54:53 <Cale> > fmap (*10) [1,2,3,4,5]
21:54:54 <lambdabot>  [10,20,30,40,50]
21:54:58 <pjd> Trinithis: ok, so you're comfortable with fmap id = id ?
21:55:01 <Cale> > fmap (*10) (Just 3)
21:55:02 <lambdabot>  Just 30
21:55:04 <Raguel> oh well
21:55:09 <Raguel> night all
21:55:09 <Trinithis> pjd: yes
21:55:29 <Trinithis> > map (*10) [1,2,3,4,5]
21:55:30 <lambdabot>  [10,20,30,40,50]
21:55:33 <Trinithis> > fmap (*10) [1,2,3,4,5]
21:55:34 <lambdabot>  [10,20,30,40,50]
21:55:38 <pjd> the next one you might have encountered for lists already: fmap (p . q) = (fmap p) . (fmap q)
21:56:35 <pjd> it means that when you map functions across something, it doesn't matter whether you do it separately or together (so to speak)
21:57:03 <Trinithis> basically order doesnt matteR?
21:57:08 <Trinithis> kinda
21:57:09 <Cale> In general, a functor T is a function which sends the objects of one category to the objects of another, and the arrows f: X -> Y of the first category to corresponding arrows Tf: TX -> TY in the target category, such that T id_X = id_(TX), and T(f . g) = Tf . Tg whenever the composition makes sense.
21:57:15 <scook0> > fmap (show . (+1)) [1, 2, 3]
21:57:17 <lambdabot>  ["2","3","4"]
21:57:26 <pjd> Trinithis: nah, the order matters
21:57:26 <Cale> But that requires you to know what a category is.
21:57:29 <scook0> > fmap show . fmap (+1) $ [1, 2, 3]
21:57:30 <lambdabot>  ["2","3","4"]
21:57:50 <Cale> In this case, both the categories involved are the category of Haskell types, and Haskell functions are the arrows between them.
21:57:52 <pjd> but it doesn't matter whether you do two separate maps of q and p
21:58:05 <pjd> or one map of both
21:58:54 <pjd> Trinithis: think of lists again
21:59:16 <Trinithis> so (fmap g).(fmap q) = fmap (g.q)
21:59:24 <Cale> yes
21:59:31 <Trinithis> i see
21:59:50 <Trinithis> cale: still need to read what you wrote above
21:59:54 <Cale> fmap is the arrow part of the functor, and the type constructor is the object part
22:00:14 <Cale> Do you know the basic definition of a category?
22:00:25 <Cale> If not, then I'll explain that first :)
22:00:41 <Trinithis> Cale: is 'arrow' a technical term?
22:00:43 <Cale> yes
22:01:04 <Trinithis> similar to the -> used in function type defs?
22:01:16 <Cale> yeah, sort of
22:01:33 <Cale> Well, a particular arrow in the category of Haskell types and functions is just a Haskell function
22:02:03 <Cale> If A and B are Haskell types, then an arrow f: A -> B is a Haskell function f :: A -> B
22:02:20 <Cale> So Haskell's notation maps onto category theory notation fairly well :)
22:02:55 <Trinithis> If "an arrow f: A -> B is a Haskell function f :: A -> B", why have 2 different ways of sayin it
22:03:10 <Cale> Well, the first bit of notation was from mathematics.
22:03:17 <Trinithis> ok
22:03:22 <Cale> The second bit of notation is from Haskell.
22:03:38 <Cale> In general
22:03:41 <Trinithis> is there a way where I can split my screen to sub frames?
22:03:56 <Cale> um, depends on your IRC client?
22:04:02 <pjd> Trinithis: GNU Screen?
22:04:14 <Trinithis> I dont know
22:04:17 <Trinithis> Xchant
22:04:21 <Trinithis> xchat*
22:04:29 <Cale> I don't think it has a way, but it might :)
22:04:32 <oerjan> Trinithis: arrows in mathematics are much more general than just functions, which are a special case
22:04:37 <thetallguy> I really like thename Xchant.
22:04:41 <Trinithis> lol
22:04:47 <pjd> thetallguy: seconded
22:04:55 <thetallguy> Ohm manepadme Ohm
22:05:06 <thetallguy> event
22:05:11 <Cale> In general, a category C consists of the following:
22:05:11 <thetallguy> Ohm...
22:05:27 <Cale> A collection Ob(C) of so-called objects of C
22:05:51 <thetallguy> (not to be confused with a sea of objects)
22:05:56 <Trinithis> lol
22:06:09 <Trinithis> are catagories like sets in set theory
22:06:13 <Trinithis> or different
22:06:14 <Cale> and for every pair X, Y of objects in Ob(C), a set Hom(X,Y) of arrows (or homomorphisms, or just morphisms) from X to Y
22:06:17 <pjd> or ObjC
22:06:23 <Cale> Yeah, Set is another category
22:06:28 <thetallguy> Sets are an example of a category
22:06:30 <Cale> the category of sets, and functions between sets
22:06:58 <Cale> If f is an an arrow in Hom(X,Y), we write f: X -> Y
22:06:59 <Trinithis> Cale, are you the Cale that posted tutorials for me on Dynamic drive?
22:07:09 <Cale> um, I might have been?
22:07:10 <Cale> hehe
22:07:18 <Cale> Oh, yes, I probably was.
22:07:20 <Trinithis> cgibbard?
22:07:22 <Cale> yes
22:07:24 <Trinithis> ok
22:07:56 <Cale> Now, there's a couple more things we need before we have a category
22:08:18 <Cale> 1) For every object X of the category, there is an arrow id_X : X -> X
22:08:51 <Trinithis> like a+0=a or a*1=a?
22:09:08 <Cale> 2) If g: X -> Y, and f: Y -> Z are arrows, then there is some arrow f . g : X -> Z
22:09:16 <thetallguy> more like f x = x
22:09:20 <Trinithis> ok
22:09:22 <mae> what is the most mature haskell gui bindings
22:09:24 <Cale> Well, it is rather like that
22:09:31 <mae> what are rather
22:09:32 <Cale> But with respect to composition:
22:09:47 <Cale> 3) if f : X -> Y is any arrow
22:09:59 <Cale> then f . id_X = f = id_Y . f
22:10:22 <Cale> Lastly
22:10:23 <thetallguy> the id function is unary (one argument)
22:10:38 <Trinithis> to be clear.. one sec
22:10:42 <Cale> f . (g . h) = (f . g) . h, whenever the compositions make sense
22:10:54 <Cale> and that's all.
22:10:54 <thetallguy> the 0/1 examples you gaves are elements that cause binary functions to have simple behavior.
22:11:28 <Cale> In some sense, id is an element which causes a binary function to have simple behaviour
22:11:33 <Cale> that binary function is composition
22:11:46 <thetallguy> Well said.
22:11:48 <Trinithis> binary function meaning?
22:11:49 <Cale> id is the identity with respect to composition
22:11:54 <Cale> Having two parameters
22:12:02 <TSC> mae: I can't comment on maturity, but gtk2hs is quite usable
22:12:04 <oerjan> and btw you can get categories in which 0 and 1 _are_ id arrows
22:12:10 <thetallguy> function of 2 arguments
22:12:10 <oerjan> monoid categories
22:12:32 <thetallguy> f:: a -> b   unary
22:12:33 <Cale> Rather like 0 + a = a, we have  id . f = f
22:12:42 <thetallguy> f :: a -> b -> c    binary
22:12:44 <Cale> (If you'll permit me to leave off the subscript)
22:13:07 <Cale> (.) is defined in Haskell, as the composition of Haskell functions
22:13:20 <thetallguy> and oh what a joy it is to have
22:13:46 <Cale> "Objects" in the sense of category theory in Haskell are just Haskell types
22:13:57 <Cale> and arrows are the functions which go between those types
22:14:13 <Trinithis> ok i see that
22:14:22 <thetallguy> so, that begs the question...
22:14:32 <thetallguy> ...why do we have Control.Arrow?
22:14:41 <Cale> That's Arrow in a different sense
22:14:52 <thetallguy> Ignore the peanut gallery
22:15:03 <Cale> (It has a category theoretic explanation, but it's not the obvious one)
22:15:30 <Cale> Which is why I like to call the Control.Arrow arrows "Hughes arrows".
22:15:36 <Trinithis> quick question: how long have you guys known haskell?
22:15:42 <Cale> Trinithis: a few years
22:15:43 <thetallguy> who's arrows?
22:15:59 <thetallguy> Hughes arrows.
22:16:02 <thetallguy> I like it.
22:16:03 <Cale> thetallguy: Hughes is the guy who invented them, so they get his name :)
22:16:08 <dfranke> Dangit.  I can't seem to think of a good caption for this one.  http://mfrost.typepad.com/cute_overload/images/2007/07/04/forgot_dee_sparklers.jpg
22:16:10 <lambdabot> http://tinyurl.com/2ha7v7
22:16:11 <thetallguy> I know.
22:16:12 <pjd> Trinithis: you don't strictly need the category theory background to just use functors, in case you're worried
22:16:22 <thetallguy> It's an old joke
22:16:31 <Cale> dfranke: TEH IMPOSSIBEL JUST HAPPENED?!
22:16:37 <pjd> you just need the basic intuition covered above
22:16:51 <Trinithis> pjd: I probably should learnin it anyway at a later time.. I'm a math major
22:16:58 <dfranke> Cale: somebody already used that one
22:16:58 <pjd> Trinithis: oh, awesome :)
22:17:13 <Cale> Trinithis: cool :)
22:17:19 <thetallguy> dranke: head not found!???
22:17:31 <Cale> Trinithis: Haskell is a really nice language for math people :)
22:17:47 <Trinithis> and I'm going to try to minor/ another major in comp sci
22:17:54 <thetallguy> Cale: it's a really nice language for hackers, too
22:17:57 <pjd> Trinithis: do you have any more questions about (Haskell) Functors?
22:17:58 <Trinithis> lol
22:18:22 <Trinithis> pjd: perhaps. I just need a few mins to read the info you all gave me and soak it in
22:18:44 <thetallguy> s/mins/days
22:18:48 <pjd> Trinithis: when in doubt, just think of the basic functors: lists, Maybe, etc.
22:19:03 <Cale> Waaahh! The gnome windowlist and workspace switcher ignore my clicks in xmonad!
22:19:11 <thetallguy> but that's a good thing
22:19:21 * Cale complains :)
22:19:40 <Cale> thetallguy: a good thing?
22:19:45 <pjd> Trinithis: oh, and IO is a good example of a functor which isn't a data structure along the lines of [] / Maybe
22:19:56 <Trinithis> ok
22:20:07 <pjd> Trinithis: how much Haskell IO have you done?
22:20:19 <thetallguy> Don't be discouraged if it takes you longer to understand.  The abstractions can be difficult to understand, if you don't have the need for them yet.
22:20:39 <thetallguy> but ultimately, we believe they will serve you well.
22:20:47 <Trinithis> pjd: very very basic suface stuff
22:20:57 <pjd> that's probably all you need :)
22:21:18 <thetallguy> Cale: I've seen people give up because they didn't get it right away.
22:21:21 <Trinithis> pjd: I havent really sat down and programmed much in haskell.... mainly just reading about it
22:21:41 <pjd> you can think of IO Foo as a Foo which hasn't arrived yet, right?
22:21:49 <Cale> thetallguy: oh, I sorta thought you were talking about my xmonad complaint ;)
22:21:50 <thetallguy> Dang it, andyjgill needs to fix his computer
22:21:54 <thetallguy> lol
22:22:05 <thetallguy> Cale: no, I'm not that mean.
22:22:08 <Trinithis> All I can say is that Haskell is addicting and very enticing. Hell, I dreamed about Haskell the past 2 nights
22:22:16 <thetallguy> oog
22:22:21 <pjd> Trinithis: like getLine :: IO String
22:22:41 <Trinithis> :pjd yes
22:23:15 <conal> anyone here use opengl with cygwin?  i'm getting lots of link errors.
22:23:21 <thetallguy> Trinithis: This will give you nightmares:
22:23:27 <thetallguy> import Data.List
22:23:27 <thetallguy> primes = nubBy (((>1) .) . gcd) [2..]
22:23:32 <pjd> Trinithis: now, you can't do anything with an IO directly
22:23:33 <Trinithis> O,o
22:23:46 <Cale> > nubBy (((>1) .) . gcd) [2..]
22:23:48 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:23:52 <conal> and is opengl or glut known to wedge ghci?
22:24:11 <thetallguy> conal: hmmm....
22:24:21 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
22:24:22 <thetallguy> conal: glut might well
22:24:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:24:56 <thetallguy> Cale: that's the formulation I prefer.  Seems clearer.
22:25:09 <pjd> > nubBy ((1<) `dot` gcd) [2..]
22:25:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:25:19 <thetallguy> What I love about that is that there's really no cheating
22:25:35 <conal> thetallguy: i can get along without glut eventually.  but for now i like being able to run other people's code, and mostly they use glut.
22:25:45 <thetallguy> Usually, when you have such concise expression, the language has been tailored for that problem specifically
22:25:53 <Cale> yeah
22:26:01 <thetallguy> In haskell, it's just tailored for concise computation
22:26:07 <Cale> The primes are an easy concept, they should be easy to express ;)
22:26:18 <thetallguy> conal: glut's event loop takes over
22:26:27 <thetallguy> conal: hence my dislike of it.
22:26:40 <oerjan> > scanl1 (*) [1..]
22:26:42 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
22:26:43 <thetallguy> conal: callbacks, infinite loops, brain damage
22:26:56 <pjd> Trinithis: anyway, so in terms of the previous discussion, IO Foo is a "structure" containing a Foo
22:26:59 <dfranke> http://dfranke.us/lambdacat4.jpg
22:27:17 <thetallguy> Hehe
22:27:34 <Trinithis> pjd: ok
22:27:44 <thetallguy> Think of a caption for this one: http://stockwits.com/Photos/Maddie/p_IMG_1140.JPG.html
22:27:46 <lambdabot> Title:
22:27:51 <Cale> thetallguy: yeah, the trouble with callbacks is that they have a stupid noncompositional type
22:27:54 <Trinithis> (>>) is called 'then' right?
22:28:01 <pjd> Trinithis: and you can can fmap things across it just like other functors
22:28:01 <Cale> Trinithis: yep
22:28:14 <thetallguy> Cale: many more problems than that
22:28:19 <pjd> @type fmap length getLine
22:28:20 <lambdabot> IO Int
22:28:24 <conal> thetallguy: maybe i'll punt glut and just start playing in wxHaskell
22:28:38 <Cale> thetallguy: That I think is the root of many of the problems
22:28:44 <thetallguy> Would you like my X/GL event loop?
22:28:51 <thetallguy> You would have to adapt to Windows
22:28:56 <pjd> Trinithis: in that case, fmap length :: IO String -> IO Int
22:28:57 <thetallguy> but it wouldn't be huge
22:29:11 <thetallguy> Cale: yes, I agree
22:29:37 <thetallguy> Cale: but there are many more aspects of UI work that aren't even close to addressed in these models
22:29:41 <pjd> just like it's (f)map length :: [String] -> [Int] for lists
22:29:52 <pjd> or fmap length :: Maybe String -> Maybe Int
22:30:04 <pjd> @type fmap length
22:30:05 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f Int
22:30:07 <thetallguy> Cale: for example, there is no notion that approximations are good in graphics
22:30:23 <pjd> in each case, you're instantiating the f with a Functor instance
22:30:28 <thetallguy> Cale: and callbacks leave no room for handling that nicely
22:30:40 <Trinithis> in some cases is fmap the same as map
22:30:49 <pjd> in the list case, yes
22:31:15 <Trinithis> is one a general form of the other? or are they in essense two different beasts
22:31:22 <thetallguy> Question for all: my brother is visiting, a biologist (entomologist) and asked for the third time, what is FP and why should I care?
22:31:27 <thetallguy> What would you say?
22:31:28 <pjd> fmap is the general form
22:31:36 <scook0> fmap is a generalisation of map, for the case where things aren't necessarily lists
22:31:46 <Trinithis> o
22:31:54 <Zao> thetallguy: A few months ago, there was a discussion on haskell-cafe about an "Elevator pitch" for Haskell.
22:32:08 <scook0> (I think historically, what we now know as fmap was just known as map, which was always polymorphic)
22:32:10 <thetallguy> Trinithis: many  believe the specialized list map should go away, and fmap should become map
22:32:12 <Trinithis> is there a point to map over fmap then? type safety?
22:32:15 * tessier is famous
22:32:17 <Cale> thetallguy: I'd say it's another approach to the whole problem of writing computer programs, which is highly promising as it has many benefits over conventional approaches.
22:32:17 <thetallguy> Zao, yes
22:32:37 <pjd> Trinithis: not really;  that's just how it ended up
22:32:45 <thetallguy> Zao, but my answer was very different than that of the elevator pitch
22:33:03 <thetallguy> zoa: in elevator, the thought is you're talking to management of a computer industry
22:33:05 <salierix> Wouldn't it be better if Haskell was strict by default and lazy on request rather than the way it is now?
22:33:05 <pjd> map for lists has a much longer history in programming :)
22:33:07 <oerjan> @quote monomorph
22:33:08 <lambdabot> ghc says: Implicit parameters escape from the monomorphic top-level binding(s)
22:33:11 <Cale> salierix: I don't think so
22:33:13 <scook0> Trinithis: excessive polymorphism can produce odd error messages, especially for newbies
22:33:19 <pjd> that too
22:33:21 <thetallguy> here I'm talking to someone who wants to develop a new model of animal behavior
22:33:22 <Cale> salierix: I can explain why.
22:33:26 <oerjan> @quote scare.of
22:33:26 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
22:33:28 <scook0> and can introduce ambiguity in some cases
22:33:29 <salierix> Ok.
22:33:42 <thetallguy> sallerix: see History of Haskell paper
22:33:47 <Cale> salierix: Basically, we can categorise data into two chunks
22:34:20 <Cale> salierix: I'll call some data 'small' or 'large' depending on whether it has few or many separately evaluable components.
22:34:40 <thetallguy> Cale: he wanted more detail
22:34:44 <Cale> For example, a long list is generally 'large' in this sense, because each of the elements can be separately evaluated
22:34:48 <pjd> Trinithis: there are a couple of places in Haskell where you'll find both general and specialized versions of some (conceptual) function
22:35:14 <Trinithis> pjd: :D
22:35:16 <Cale> thetallguy: Well, for one functional languages generally do a good job of supporting something called referential transparency.
22:35:18 <sclv> pjd: s/couple/many/
22:35:24 <pjd> sclv: :)
22:35:28 <scook0> (I think laziness is a bit like GC, in that you get some extra advantages from making it ubiquitous instead of optional)
22:35:37 <Cale> thetallguy: This is the property that when you apply a function to the same value, it gives the same result.
22:35:45 <pjd> Trinithis: ok, so back to IO
22:35:55 <Cale> thetallguy: It makes things easier to test, and easier to reason about.
22:36:08 <sclv> Sometimes I get the sense that the whole history of haskell is the history of increasingly powerful generalizations.
22:36:30 <scook0> sclv: which would explain the whole "category theory gateway drug" thing
22:36:30 <pjd> Trinithis: if you've ever done any event-based programming, a very good intuition of the IO functor is that fmap adds a callback
22:36:30 <Cale> Also, functional languages tend to make functions first-class. Which means that you can manipulate them like any other value in the language.
22:36:37 <thetallguy> Cale: he understood my exp.  of ref. trans, but not why it was important.
22:36:47 <Cale> thetallguy: Is he a programmer?
22:36:53 <dfranke> http://dfranke.us/lambdacat5.jpg
22:36:55 <salierix> I can't seem to download the history of haskell paper. Who knew Microsoft Research had such a slow server...
22:36:58 <pjd> Trinithis: fmap (*2) . fmap length $ getLine
22:37:01 <thetallguy> Cale: examples of what to reason about were hard to come by
22:37:14 <Cale> thetallguy: well, everything -- does your program work?
22:37:16 <thetallguy> Cale: not really, but a scientist, so familiar
22:37:19 <thetallguy> lol
22:37:19 <Trinithis> pjd: $ ?
22:37:30 <pjd> oh, that's just function application
22:37:38 <thetallguy> I ended up invoking Fran
22:37:40 <pjd> but low priority
22:37:52 <pjd> the above is the same as (fmap (*2) . fmap length) getLine
22:38:10 <Trinithis> ok
22:38:11 <pjd> or fmap (*2) (fmap length getLine)
22:38:23 <Cale> Deciding whether a function does what you want it to or doesn't is all about breaking it down and understanding its parts. When you have referential transparency, those parts will always behave the same way wherever they occur.
22:38:28 <pjd> a common idiom you'll encounter is foo . bar . baz $ x
22:38:29 <thetallguy> compare  moving an object i a circle by running an event loop, updating obj.x and obj.y with new values every iteration
22:38:42 <pjd> instead of foo (bar (baz x))
22:38:45 <sclv> scook0: I'm just recently pondering if there are any structures in haskell that can be viewed as rings -- i.e. where mplus distributes over another a->a mapping.
22:38:58 <thetallguy> with    obj = translate (cos(t), sin(t), ball)
22:39:15 <Cale> Without referential transparency, the context in which everything is running matters much more, and you have to examine things step by step every time.
22:39:31 <Trinithis> so $ forces a right associative parenthesis factor type of deal?
22:39:42 <Cale> salierix: Okay, so, why lazy evaluation is important... :)
22:39:56 <salierix> I was just about to ask.
22:39:59 <pjd> so "fmap (*2) . fmap length $ getLine" is like making a request for a line, and adding two callbacks:  length and (*2)
22:40:11 <Cale> salierix: We can classify functions which act on data roughly into a few categories based on the "size" of the input and output.
22:40:12 <pjd> Trinithis: yeah, more or less
22:40:14 <thetallguy> Cale: he didn't understand that, until I explained that a) it was hard to prove correctness with imperative and b) multi-core machines would run such things no faster.
22:40:37 <sclv> thetallguy: maybe if you could explain that it meant that equations in scientific papers could correspond in provable ways to programs
22:41:12 <pjd> Trinithis: in terms of callbacks, it should be obvious how the above is equivalent to fmap ((*2) . length) getLine
22:41:13 <Cale> salierix: In the case Small -> Small, lazy and strict are about the same
22:41:14 <thetallguy> Cale: oddly, he understood the point when I said that Intel was developing a new FP language so that people would actually get speedups with 8 core machines, which are due out sooner than we think.
22:41:27 <Cale> salierix: In the case Small -> Large, lazy is always better
22:41:35 <thetallguy> sclv: yes, when I said something like that, he appreciated it.
22:41:39 <pjd> or how fmap id getLine == getLine
22:42:02 <Cale> salierix: In the case Large -> Large, if you can stream, lazy is better, otherwise it doesn't make a difference
22:42:21 <pjd> those are the "obvious" properties captured by the functor laws
22:42:31 <Cale> salierix: In the case Large -> Small, if you're searching for something, lazy is better, otherwise, strictness is better
22:42:52 <Cale> salierix: So it's just one case where strict evaluation wins.
22:43:09 <Cale> and in all the other cases, it either makes no difference, or lazy wins.
22:43:31 <pjd> Trinithis: making sense? :)
22:43:46 <salierix> Cale, but aren't the cases where strictness wins more common than cases where lazy wins?
22:43:51 <Cale> Not really.
22:43:59 <Trinithis> pjd: I'm kind of jumping between areas. so much to read :D
22:44:12 <sclv> salierix: whats yr use case?
22:44:14 <Cale> also, they happen to usually be capturable using particular higher-order functions
22:44:16 <thetallguy> Thanks for the feedback guys.
22:44:32 <thetallguy> Conal, if you want my horrible event loop, ping me in the A.M.
22:44:41 <Cale> Because functions which are Large -> Small are often catamorphisms, like foldl
22:44:51 <Cale> So we write a strict version, foldl'
22:45:11 <salierix> Uh, catamorphism?
22:45:16 <Cale> and then that captures a wide class of problems where strictness is better
22:45:39 <Cale> Well, I'm using the term a little loosely there
22:45:51 <kscaldef> thetallguy: 8 core machines are available now
22:46:02 <Cale> A catamorphism is generally a function which collapses a data structure according to some recursive process.
22:46:13 <Trinithis> Well guys, I'm going to bed. Thanks for all the help. I'll save the text
22:46:22 <Cale> Trinithis: g'night
22:46:53 <Cale> anyway, what I mean to say is just that often the stuff which needs to be strict can be written once and reused.
22:47:01 <Cale> also
22:47:04 <thetallguy> kscaldef: 8 core processors
22:47:09 <Cale> If you have a strict default
22:47:11 <thetallguy> single chip
22:47:25 <Cale> Then people tend to write strict library functions, even when they *could* write lazy ones
22:47:43 <Cale> because the library authors don't want to go to the hassle of annotating things to be lazy
22:47:44 <thetallguy> According to the Intel guy, much sooner than you think, because they are hitting the wall on mips
22:47:48 <kscaldef> thetallguy: yeah, I was guessing that was what you meant
22:47:53 <Cale> and this ruins the main benefit of laziness
22:48:03 <dfranke> http://dfranke.us/lambdacat6.jpg
22:48:08 <kscaldef> 4 core CPU are in consumer machines now
22:48:08 <thetallguy> at CUFP
22:48:08 <Cale> which is that it buys you new ways to piece programs together from smaller programs
22:48:25 <scook0> @where bananas
22:48:25 <lambdabot> I know nothing about bananas.
22:48:30 <wli> Out of curiosity, did they say what "the wall" for MIPS was?
22:48:40 <Cale> For example, if I want to write a function to test if one string is a substring of another:
22:48:43 <oerjan> @go bananas
22:48:44 <lambdabot> http://en.wikipedia.org/wiki/Banana
22:48:45 <lambdabot> Title: Banana - Wikipedia, the free encyclopedia
22:48:45 <scook0> @go bananas lenses envelopes barbed wire
22:48:45 <thetallguy> wll: no
22:48:47 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
22:48:47 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
22:48:48 <salierix> Cale, what do you mean by "annotating things to be lazy"?
22:48:52 <thetallguy> not in that talk
22:48:58 <wli> 4 cores were in consumer machines as of PPro.
22:49:14 <Cale> salierix: in a strict language with optional support for laziness
22:49:18 <wli> It's above 4 that's new.
22:49:23 <salierix> Oh.
22:49:30 <thetallguy> on one chip?
22:49:42 <wli> No, not 4 cores on one chip.
22:49:52 <Cale> isSubstringOf x y = any (isPrefixOf x) (tails y)
22:50:01 <kscaldef> 4 cores on one chip
22:50:03 <Cale> You would never see someone write that in a strict language
22:50:06 <scook0> Cale: the funny thing is that in some cases if the library code is insufficiently monadic, you're hosed anyway
22:50:08 <thetallguy> He was talking about the end of moores law
22:50:17 <Cale> scook0: I'm not so sure about that
22:50:21 <wli> thetallguy: Where?
22:50:40 <Cale> scook0: Monadic code is fundamentally different from pure code, and the monadic generalisations are not obvious.
22:50:48 <Cale> (nor are they in general unique)
22:51:06 <scook0> sure
22:51:12 <thetallguy> http://cufp.galois.com/slides/2007/AnwarGhuloum.pdf
22:51:15 <Cale> Plus, what's wrong with pure libraries :)
22:51:27 <thetallguy> Nested Data Parallel Programming at Intel.
22:51:28 <thetallguy> Anwar Ghuloum, Intel.
22:51:32 <thetallguy> CUFP, 2007
22:51:36 <scook0> but in cases where you *know* there should be a monadic version, it's annoying that the author didn't provide one
22:51:57 <salierix> Another question I have is what's to stop people from writting their code completely in the IO monad?
22:52:13 <Cale> salierix: nothing except common courtesy
22:52:18 <wli> Common sense?
22:52:18 <scook0> salierix: disapproving frowns?
22:52:27 <sclv> skook0: what libraries are you talking about?
22:52:27 <thetallguy> sallerix: they find it's not reusable
22:52:56 <thetallguy> sallerix: composition is an amazing tool
22:53:16 <scook0> sclv: my gripes aren't motivated by a specific library ... in fact they're mostly motivated by my own insufficiently-monadic code
22:53:20 <conal> thetallguy: i'm visiting anwar at intel on thursday
22:54:11 <scook0> e.g. I recently had a situation where I really wanted to pass (a -> IO b) to a function expecting (a -> b), which is not possible in general
22:54:26 <scook0> (though I'm sure you could do some evil trickery with unsafePerformIO and NFData)
22:55:36 <scook0> but in that case I ended up rewriting my app to be pure -- there was about a 50% speed hit, but the code was much nicer
22:56:03 <sclv> skook0 -- how did you magic out that IO in the return type anyway? you must have had unsafePerformIO somewhere else to begin with?
22:56:39 <scook0> I changed my data structures to use IArray instead of MArray
22:56:53 <scook0> so that all my reads would be pure, and the problem went away
22:56:54 <Cale> Which pure function did you want to use?
22:57:01 <thetallguy> conal: I had forgotten that his stuff was so close to C++
22:57:12 <scook0> Cale: one that I wrote myself
22:57:16 <Cale> ah, okay
22:57:19 <thetallguy> conal: unfortunate.  Understandable.
22:57:46 <conal> thetallguy: i missed his cufp talk.  close to c++. hmm.
22:58:00 <thetallguy> See the link above for PDF
22:58:01 <Cale> scook0: yeah, with higher order functions it's hard, but then if you wanted to write an IO version of the thing you had, you'd have had lots more work to do
22:58:12 <thetallguy> I just browsed it.  Vector processing focus
22:58:14 <Cale> scook0: Since you'd have to decide on the sequencing of all the effects.
22:58:22 <scook0> Cale: in my case, half of my program wanted to be pure, and the other half wanted to be impure
22:59:11 <Cale> what did the a -> IO b functions do?
22:59:48 <conal> thetallguy: i'm reading it now.  thanks.
22:59:49 <scook0> Cale: read action-value estimates for a reinforcement learning agent
23:00:00 <thetallguy> This time for sure, Rocky!  Off to bed.
23:00:35 <conal> i love that cartoon
23:00:57 <thetallguy> Not that lesson...
23:01:06 <thetallguy> snore
23:01:21 <conal> now watch me pull a rabbit out of a hat ...
23:01:33 <conal> guess i got the wrong hat
23:03:25 <wli> CUFP?
23:03:38 <conal> commmercial uses of FP
23:04:58 <wli> So it sounds like FP is vaguely taking off within Intel.
23:05:59 <scook0> let me know when they bring out a reduceron ;)
23:07:26 <conal> wli: interest is brewing.  some at apple apparently as well.  i'm visiting there next week as well.
23:10:44 <conal> seafood: howdy
23:19:05 * hgolden is away: sleeping...
23:37:45 <wli> That's good. It's all dictated from the top down, so that's how it's done.
23:48:02 * Cale switches back to metacity because it fully supports EWMHints.
23:48:47 <wli> What's metacity?
23:48:56 <dmwit> Gnome's window manager.
23:49:03 <araujo> wli, it's a city to build cities
23:49:21 <wli> What are EWMHints?
23:50:07 <Cale> http://standards.freedesktop.org/wm-spec/wm-spec-1.3.html#id2506353
23:50:11 <lambdabot> Title: Extended Window Manager Hints, http://tinyurl.com/2ygo9e
23:50:45 <araujo> I thought it was an acronym for "Environment Windowing Manager Haskell interface for Sudoku"
23:51:07 * wli clearly hasn't the foggiest clue of what's happening in userspace, desktop, or HCI.
23:51:57 * wli may not even know what they really are, save userspace from the POV of a kernel programmer.
23:53:26 <Cale> Basically, without them, the gnome panel window list and workspace switcher don't quite work.
23:54:05 <Cale> There's a plugin for xmonad which gives partial support, but I'm not sure how to complete it.
23:54:47 <wli> > let readM s = case reads s of [(x, _)] -> return x ; _ -> throwError "readM: no parse" in (readM "hello" :: Either String Int, readM "20" :: Either String Int)
23:54:49 <lambdabot>  (Left "readM: no parse",Right 20)
23:55:31 * wli wishes.
23:55:46 <wli> :t let readM s = case reads s of [(x, _)] -> return x ; _ -> throwError "readM: no parse" in readM
23:55:47 <lambdabot> forall (m :: * -> *) a. (Read a, MonadError [Char] m) => String -> m a
23:56:20 <wli> s/throwError/fail/ and it could be in the Prelude...
23:56:54 <Cale> or, just move throwError into the Prelude, and get rid of fail.
23:57:45 <wli> Not really possible since MPTC et al are still not "standard," but I wish.
23:58:27 <Cale> Well, we could take a cut down version
23:58:51 <Cale> with just string errors ;)
23:59:00 <sjanssen> Cale: which parts were you missing?
23:59:05 <wli> It'd have to avoid nameclashes with the MTL but anyway.
23:59:28 <Cale> sjanssen: the parts which make it so that when you click on the windowlist/pager, something actually happens
23:59:55 <Cale> Ideally, selecting a window would take you to its workspace and focus it
