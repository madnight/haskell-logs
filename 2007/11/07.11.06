00:10:17 <faxathisia> *grr*
00:10:37 <faxathisia> trouble with parsec >:|
00:10:51 <wolverian> growling will help
00:11:17 <faxathisia> I tried angry stare but it didn't work :E
00:14:25 <faxathisia> aw well I thought I could lex and parse in one pass but it looks like I gotta do it in two
00:35:02 <Cale> ac: What's wrong with it?
00:44:10 <ac> Cale: all packages I attempted to install produced "cabal: dist/Conftest.c: openFile: does not  exist"
00:44:33 <ac> Cale: I gave up and downgroaded to ghc6.6 and installed all the packages using apt
00:47:33 <ac> I didn't really have a ligitimate reason to use 6.8
00:54:15 <xif> sorry for being OT
00:54:39 <xif> is there a way to revert to a specific version with darcs?
00:55:19 <sjanssen> xif: was the version --tag'ed?
00:55:40 <osfameron> ooops.  I think I volunteered to talk about haskell at the London Perl Workshop (only 5 minute lightning talk, but now I have to actually write the bloody thing)
00:55:41 <xif> sjanssen: nope, just recorded
00:55:55 <xif> osfameron: bloody hell ;-)
00:56:02 <xif> </englishman>
00:56:11 <sjanssen> xif: you can 'darcs unpull' patches that you don't want
00:56:14 <roconnor> osfameron: wow, and I thought my 20 talk would be short
00:56:29 <sjanssen> xif: note that this totally destroys the patch
00:56:46 <xif> (what can you say teach newbs about Haskell in 5 minutes?)
00:56:52 <xif> sjanssen: sucks.
00:57:04 <xif> sjanssen: all I want is to travel back and forth between versions.
00:57:10 <xif> the way you can do in SVN.
00:57:11 <osfameron> xif, roconnor: well, the perl community likes lightning talks.  And haskell is a little off topic to be fair :-)
00:57:17 <osfameron> but I don't suppose I can really "teach" anything
00:57:17 <xif> s/versions/revisions/
00:57:26 <osfameron> more just a case of "hey, look, this was fun!"
00:57:27 <sjanssen> xif: perhaps you can use two repositories?
00:57:42 <roconnor> xif: I'm told that a branches is the solution to all problems in darcs
00:58:08 <xif> perhaps I should just use SVN :-/
00:58:29 <xif> roconnor, sjanssen: the full story is this:
00:58:37 <xif> I have some code, that's performance critical
00:58:47 <xif> now what I'm doing is testing all sorts of versions of it
00:59:14 <xif> i.e. going two revisions back, testing performance, then going two revisions forwards, testing again
00:59:28 <xif> etc.
00:59:37 <sjanssen> xif: sounds like you want several repositories
00:59:48 <sjanssen> keep one master repo with all the patches in it
00:59:59 <xif> sjanssen: and?
01:00:18 <sjanssen> then 'darcs get' that repo, use 'darcs unpull' to remove certain patches from it, then run your tests
01:00:31 <xif> hm
01:00:40 <xif> sounds a bit too complicated for what I need right now
01:01:04 <xif> with SVN, I can just `svn revert` to a specific revision
01:01:10 <xif> (which is all I need right now)
01:01:26 <xif> and if I want to make changes to past revisions, and merge them back, I'd use branches
01:01:45 <xif> both sound easier than the way darcs does it...
01:01:51 <sjanssen> I don't think the darcs workflow is complicated
01:02:00 <sjanssen> 'darcs get' is a really really cheap operation
01:03:47 <sjanssen> erm, wait a minute,  SVN requires that you talk to a central server, yeah?
01:05:43 <sjanssen> the darcs model I've proposed is actually emulating a central server
01:06:22 <sjanssen> consider the repo with all patches in it to be the server, and your working copy to be the client
01:07:35 <sjanssen> after recording each patch in the client, push it to the server (to make sure the server always has a copy)
01:08:08 <sjanssen> when you want to measure historical versions, just 'darcs unpull'.  When you want to get back to the present, 'darcs pull'
01:11:31 <quicksilver> because branching is such a nightmarish disaster in CVS and SVN
01:11:37 <quicksilver> people who are used to those systems are scared of branching
01:11:51 <quicksilver> in modern VCSes (bzr,hg,darcs) branching is cheap and natural
01:12:19 <quicksilver> and it's the primitive on which you build more complex operations
01:12:28 <quicksilver> instead of being a scary high-level effect which people try to avoid
01:12:55 <xif> actually branching isn't that much of a "nightmare" in SVN
01:13:07 <xif> nothing like what it was in CVS
01:13:22 <xif> maybe I'll look into it more deeply
01:13:55 <xif> (it's just the idea of creating a separate repo for each branch seems too heavy)
01:14:31 <sjanssen> xif: heavy in what way?
01:14:50 <xif> sjanssen: overkill
01:14:58 <xif> hey, you have a chris2 here as well
01:15:32 <ac> xif: I'd agree, as sometimes a branch may only consist of a few different files
01:15:43 <chris2> xif :)
01:15:49 <xif> ac: yup
01:15:54 <quicksilver> well disk space is cheap
01:16:02 <quicksilver> but some systems support lightweight branching
01:16:06 <quicksilver> with most of the stuff being shared
01:16:12 <sjanssen> xif: yes, you do get more flexibility from a separate repository.  My point is that a separate repo doesn't cost anything
01:16:48 <xif> quicksilver: which systems?
01:17:00 <xif> sjanssen: *nod* I should look into it
01:17:05 <sjanssen> 'darcs get' on a local respository is very fast and uses very little extra diskspace
01:17:08 <dobblego> ?hoogle (Monad m) => m [a] -> (a -> m b) -> m [b]
01:17:09 <lambdabot> No matches, try a more general search
01:17:14 <xif> BTW, how's Hg / bzr compared to darcs?
01:17:21 <dobblego> it seems like this function should exist
01:17:41 <xif> sjanssen: (won't it take exactly the same amount of space as the source repo?)
01:18:03 <sjanssen> xif: nope, darcs uses hard links for the patch data
01:18:16 <xif> ah, cool
01:18:30 <quicksilver> bzr supports a setup with shared 'patches'
01:18:38 <quicksilver> but admittedly the actual working files will be in two places
01:18:53 <quicksilver> so you don't pay for two repos, but you do pay for two copies of the actual files
01:19:26 <xif> quicksilver: if darcs uses hard links as sjanssen said, it sounds like it's even better than the system you described.
01:19:51 <quicksilver> dob
01:19:57 <glguy> hardlinks only work on the same filesystem. Fortunately git supports both hard links, and a delegate repository
01:20:02 <xif> because the real cost is the extra copies for each file, and in the system sjanssen described, only the changed files would cost.
01:20:20 <sjanssen> xif: actually, I was slightly inaccurate
01:20:56 <chris2> glguy: does that delegate stuff work fine now?
01:20:58 <sjanssen> xif: the active files are copied, only the internal patch bundles are hardlinked
01:21:39 <glguy> chris2: I haven't used it, just read about it, with git's branching ability there isn't much need to clone the repository locally
01:22:00 <glguy> or to worry about multiple copies of the working directory
01:22:04 <chris2> so you can just say "this remote repo is the parent"? last time i tried (few months ago?) that didnt work well
01:22:08 <dobblego> :t \as g -> as >>= (\as -> sequence(map g as)) -- does this function already exist somewhere?
01:22:10 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m [a] -> (a -> m a1) -> m [a1]
01:22:13 <xif> hehe, so how's git / darcs / hg / bzr in general, compared to each other?
01:22:17 <chris2> but would be pretty easy to do, at the cost of a bit of traffic
01:22:23 <sjanssen> dobblego: mapM
01:22:35 <dobblego> gah, thanks
01:23:18 <sjanssen> dobblego: actually, not quite the same as mapM, but very close
01:23:20 <xif> (btw, looks like the canonical darcs solution for the original question is to rollback + unrecord
01:23:20 <glguy> chris2: I don't know if it works remotely, I thought that the point was to support local links
01:23:30 <chris2> ah, sure, local works
01:23:31 <glguy> what is the original question?
01:23:38 <sjanssen> @type \mxs f -> mapM f =<< mxs
01:23:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m [a] -> (a -> m b) -> m [b]
01:24:06 <xif> glguy: traversing the revisions tree with darcs
01:24:26 <takamura> hi
01:24:27 <xif> going back to revision 'foo', then going to revision 'bar', then going back to latest revision.
01:24:36 <glguy> darcs doesn't have a revision tree
01:24:38 <dobblego> @type \mxs f -> mapM mxs >>= f
01:24:39 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => (a -> m b) -> (m [b] -> [a] -> b1) -> [a] -> b1
01:24:41 <glguy> it has a patch pool
01:25:07 <dobblego> @type \mxs f ->mxs >>= mapM f
01:25:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m [a] -> (a -> m b) -> m [b]
01:25:19 <xif> glguy: so how would you do that if you need to?
01:25:47 <glguy> things like that being ugly are why I don't use darcs
01:26:08 * xif nods
01:26:13 * chris2 nods too
01:26:18 <xif> which is why I'm shopping for an alternative
01:26:23 <sjanssen> "revision tree" seems like an artificial concept to me
01:26:29 <xif> glguy, chris2: which do you use then?
01:26:39 <xif> git?  bzr?
01:26:45 <chris2> i use darcs for my small personal projects. git for the rest
01:27:16 <sjanssen> how well does git do on cherry picking?
01:27:19 <chris2> the former mainly because of the superior emacs integration and easy static serving
01:27:20 <glguy> fine
01:27:24 <xif> chris2: (actually, this is a small, personal project)
01:27:26 <chris2> sjanssen: fine in general
01:27:41 <xif> it's a personal branch of a large Subversion repo
01:28:07 <sjanssen> I don't see how you can reconcile cherry picking with a sequence of revisions
01:28:12 <xif> I manage it with Darcs because my limited experience told me it's super-simple
01:28:29 <xif> but it seems Darcs is only really simple for the simple operations.
01:28:32 <glguy> sjanssen: when you cherry pick a change, it doesn't keep teh same unique id
01:28:44 <glguy> sjanssen: but it does keep the same content and message
01:28:49 <sjanssen> glguy: isn't that a problem come merge time?
01:29:10 <chris2> darcs is nice for sharing patches, but as soon as you need some kind of "history", one quickly runs into trouble
01:29:10 <sclv> ?ty \x y -> join $ (liftM2 forM) x y
01:29:11 <glguy> sjanssen: no. git's default merge algorithm notices that two branches are trying ot accomplish the same task
01:29:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m [a] -> m (a -> m b) -> m [b]
01:29:18 <chris2> same for trying to force applying patches
01:29:48 <glguy> sjanssen: in darcs, merging the same change on each side the of merge under different names is a conflict
01:29:51 <glguy> in git it isn't
01:30:15 <glguy> the git-cherry command helps to find commits that exist only one one of two branches
01:30:28 <chris2> darcs has a nice theory that unfortunately isnt how the real world works :)
01:30:35 <glguy> for when you've been picking between branche
01:30:36 <glguy> s
01:31:27 <glguy> chris2: what advantage does darcs have over git for static serving?
01:31:53 <chris2> it makes one file per patch, not one file per file
01:32:02 <chris2> and repacking breaks rsync easily
01:32:04 <glguy> chris2: that's what "packs" are for
01:32:26 <faxathisia> Is there any kind of desirable attribute of having certain code written using no recursive types?
01:32:32 <chris2> i guess i could make a pack per patch
01:32:46 <faxathisia> they seem to make a point about whether or not the thing uses recursive types ..
01:33:04 <glguy> chris2: you can make one pack for the whole repo if you wanted
01:33:05 <sjanssen> faxathisia: "they"?
01:33:15 <faxathisia> the authors of LogicT
01:33:19 <glguy> chris2: git-gc helps here iirc
01:33:21 <faxathisia> e.g.
01:33:27 <faxathisia> We are less fundamentalistic here, compared to SVCT.hs and permit some use of recursive types (lists)""
01:33:35 <faxathisia> & "This is an optimized implementation with no recursive types"
01:33:55 <chris2> glguy: i guess i should just use push to the server, and not rsync
01:34:02 <faxathisia> just wondering why they might be stating that explicitly?
01:34:09 <quicksilver> dobblego: there is a general convention to use 'kleisli style'
01:34:28 <quicksilver> dobblego: mapM is in 'kleisli style' because the "m" is only at the right-hand-end of arrows
01:34:54 <dobblego> what m?
01:35:00 <quicksilver> dobblego: that turns out to be fairly general, since it's always easy to bind a monadic action to a pure part, by >>= a.k.a kleisli composition
01:35:04 <quicksilver> the monadic m
01:35:06 <quicksilver> :t mapM
01:35:07 <dobblego> > "mapM" !! 3 -- that m?
01:35:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:35:09 <lambdabot>  'M'
01:35:23 <glguy> with darcs you can't tell if you have the same repository as someone else without a network connection
01:35:31 <glguy> *direct
01:35:34 <quicksilver> there are two ms in the type "(a -> m b) -> [a] -> m [b]"
01:35:41 <dobblego> ah right
01:35:47 <glguy> anyway.... :)
01:35:54 <dobblego> I see waht you're saying, thanks
01:35:58 <sjanssen> glguy: this seems trivial to add
01:36:10 <quicksilver> and both are on the right hand end of arrows :)
01:36:14 <sjanssen> just a simple checksum on the checksums of the patches
01:36:18 <faxathisia> no-one has any ideas why that might be :S
01:36:35 <glguy> sjanssen: and you can't easily revert to a checksum once you've moved on in darcs, given this trivial addition
01:36:44 <quicksilver> faxathisia: not using recursive types makes it easier to prove your code is total
01:36:50 <quicksilver> faxathisia: i.e. guaranteed to terminate
01:36:53 <faxathisia> ooh
01:37:03 <faxathisia> ok do you know what I could read about wrt that?
01:37:04 <sjanssen> glguy: sure you can, name repository states with 'darcs tag'
01:37:07 <faxathisia> or look up or whatever
01:37:23 <glguy> sjanssen: tagging every state you've been at manually isn't really a solution
01:37:26 <glguy> it is a workaround
01:37:34 <quicksilver> @go total functional programming turner
01:37:37 <lambdabot> http://www.jucs.org/jucs_10_7/total_functional_programming
01:37:38 <lambdabot> Title: (D. A. Turner) Total Functional Programming
01:37:45 <sjanssen> glguy: yes, but you *can* name the useful states
01:37:54 <faxathisia> great, thanks very much!
01:38:03 <quicksilver> faxathisia: that's quite a good article if it's the one I'm thinking of
01:38:56 <glguy> sjanssen: yeah, just sounds like a lot of work for a problem that's already solved
01:39:21 <sjanssen> glguy: also, doesn't git destroy this property by changing the names of cherry-picked patches?
01:39:41 <glguy> it doesn't change them
01:39:43 <glguy> it creates new ones
01:39:44 <faxathisia> O_o
01:39:45 <glguy> with new names
01:39:46 <faxathisia> fib (n+2) = fib (n+1) + fib (n+2)
01:39:53 <glguy> the old ones still exist
01:39:55 <glguy> to be reverted to
01:39:55 <faxathisia> I think they made a mistake :P
01:40:10 <quicksilver> :)
01:41:18 <sjanssen> glguy: when I pull patch with id X from another repository, what patches are added to my repository?  Just one patch Y with identical structure?
01:41:45 <glguy> if you cherry pick a change from one branch into yours
01:41:49 <glguy> then yes
01:41:59 <glguy> that is what happens
01:42:20 <glguy> because the resulting repository state is different, so its name must be
01:42:25 <xif> (hm, it seems git isn't even centralized)
01:42:34 <glguy> neither is darcs
01:42:37 <quicksilver> or bzr
01:42:38 <xif> err, *distributed
01:42:39 <quicksilver> or hg
01:42:40 <quicksilver> :P
01:42:46 <quicksilver> ah
01:43:05 <sjanssen> glguy: and what is the result state when I cherry-pick the rest of the patches from that foreign repository?
01:43:14 <xif> glguy, quicksilver: http://info.wsisiz.edu.pl/~blizinsk/git-bzr.html
01:43:18 <lambdabot> Title: Maciej Blizi≈Ñski &mdash; Git and Bazaar
01:43:22 <glguy> sjanssen: did you pick them out of order?
01:43:32 <glguy> creating a different history?
01:43:34 <xif> "First is that you need to install Git on the server you want to upload your changes to."
01:43:43 <xif> are you sure Git isn't centralized?
01:44:03 <sjanssen> glguy: sure, for the sake of argument
01:44:13 <glguy> sjanssen: then that's what happens
01:44:17 <dobblego> I love how #haskell people embrace argument :)
01:44:23 <Japsu> xif: replace "server" with "peer" if that bothers you ;)
01:44:30 <glguy> xif: that has nothing to do with centralized
01:44:41 <quicksilver> xif: yes
01:44:48 <quicksilver> xif: because you *also* have git locally
01:44:54 <quicksilver> xif: and you don't need to use the remote server
01:45:00 <quicksilver> you install git remotely if you want to publish
01:45:04 <sjanssen> glguy: then it seems that cherry-picking doesn't interact well with a revision history
01:45:05 <quicksilver> but you can work disconnected
01:45:09 <quicksilver> and you can push to another server
01:45:15 <quicksilver> sjanssen: yeah, I don't really believe in cherry-picking.
01:45:28 <quicksilver> sjanssen: but maybe I'm lucky because I've never worked in a project which needs it :)
01:45:48 <quicksilver> xif: so, it's de*central*ized, because there is no need to a central server. you can have many servers.
01:45:57 <quicksilver> xif: bzr, by contrast, is completely serverless
01:46:00 <quicksilver> (the server is optional)
01:46:09 <quicksilver> although it can be a bit faster if you use one, for some things
01:46:35 <quicksilver> xif: that tutorial seems like a fair enough summary to me, though
01:46:48 <quicksilver> as it happens, I couldn't care less about SVN integration :)
01:46:57 <quicksilver> but it's clear enough that if you care about it, it's a nifty feature.
01:47:14 * xif nods
01:47:36 <quicksilver> I've used bzr for all new projects since about two years, and never looked back.
01:47:43 <quicksilver> and we use it at work.
01:48:34 <reffie> cvs 4 life
01:49:18 <dobblego> file.txt.1 file.txt.2 file.txt.3 4 life
01:49:36 <glguy> directory based branching sucks when you want to grab someone's repository who is working in multiple branches
01:49:47 <glguy> and you have to manually pull all of them
01:50:35 <alar> which of Text.Regex backends is the least hungry for memory?
01:50:55 <quicksilver> the default one just binds to your C library
01:51:02 <quicksilver> that should be fairly memory efficient I would think
01:51:32 <quicksilver> glguy: that's certainly true, but to me that sounds like a really weird thing to do :)
01:51:40 <quicksilver> glguy: the system you use affects the way you think
01:51:50 <quicksilver> glguy: to me, grabbing is a decision you would make on a per-branch basis.
01:52:31 <glguy> its a decision you can't make in the context of your tool, you need out of band info to even know it is something you need ot decide to do..
01:53:56 <quicksilver> I wouldn't say "I want all of glguy's work" I'd say "I want to see his yi-thoughtcontrol branch"
01:54:00 * quicksilver shrugs
01:54:30 <glguy> quicksilver: I might say, I want all the stuff on the common repository
01:54:53 * quicksilver shrugs
01:55:08 <glguy> or "update all of my branches in one command"
01:55:13 <glguy> instead of interspersing cd
01:55:42 <quicksilver> for i in thought-control hamster-maker lead-to-gold; do cd yi-$i; bzr update; done
01:55:50 <quicksilver> I sort-of take your point
01:55:53 <quicksilver> but I don't find it convincing :)
01:56:10 <glguy> right, I don't like having to hack functionality back in with shell scripts that should already be in shell scripts
01:56:31 <glguy> and rather than writing them myself and you writing them yourself
01:56:47 <glguy> I want them to be common so we find all the bugs and don't have to maintain them separately
01:57:40 <glguy> and can I get a copy of that lead-to-gold repository?
01:58:01 <quicksilver> funny. I get more requests for hamster-maker, as a rule.
01:58:18 <glguy> I have enough hamsters...
01:58:27 <quicksilver> "But only god can make hamsters!" Not any more...
02:03:18 <quicksilver> I would say, contrarily, that it's often not necessary to add functionality which already exists in the shell, to applications
02:03:24 <quicksilver> that is a failure of modularity
02:03:57 <quicksilver> for example, 'cat' doesn't do glob or ~-expansion on its parameters
02:04:21 <ac> how do I figure out what the version of a particular library I have installed is?
02:04:58 <quicksilver> ghc-pkg -l
02:05:25 <ac> quicksilver: thanks
02:06:53 <glguy> quicksilver: when something is complicated enough to merit a shell script, and the script is general enough to be reused or can be made as such, then there is no reason not to share them. and if there isn't a reason to not share, then you might as well not make the user jump through a second hoop and just include them
02:07:06 <glguy> manually enumerating all of the branches to update isn't a solution
02:07:25 <glguy> I figure this discussion is more for the lurkers than you or I, I don't think we are going to change opinions ;)
02:10:09 <glguy> quicksilver: the branch per directory idea isn't orthogonal to allowing the tool to manage those directories
02:12:48 <ac> does the containers library come with ghc?
02:12:53 <sjanssen> ac: yes
02:13:37 <ac> so why would cabal tell me that the "containers -any" dependency is missing?
02:14:40 <sjanssen> ac: which version of GHC?
02:14:48 <ac> 6.6.1
02:14:58 <sjanssen> containers is new in 6.8.1
02:15:10 <ac> oh, so I should go ahead and download it and install it?
02:15:36 <sjanssen> no, that functionality was included with the base package in 6.6.1
02:15:44 <ac> that's what I thought
02:15:54 <sjanssen> so just remove containers from build-depends
02:15:56 <ac> so I figured downloading it and installing it might do strange things
02:16:09 <sjanssen> OOC, which package depends on containers?
02:16:29 <ac> Cabal actually
02:17:14 <sjanssen> do you mean Cabal, or cabal-install?
02:17:31 <ac> just cabal (1.2.2)
02:19:53 <sjanssen> Cabal shouldn't depend on containers with GHC 6.6.  Something strange is going on
02:20:13 <ac> sjanssen: maybe it thinks I have a later version of GHC?
02:20:35 <ac> sjanssen: it's also depending on things like "old-time" which I assume also are in base
02:20:49 <sjanssen> yes
02:20:52 <ac> and process, directory, etc
02:21:11 <sjanssen> view 'Setup configure --verbose' and look for anything out of place
02:22:44 <ac> oh no, I messed things up. I thought pretty was not already there and installed it. Now I have two versions of the same package
02:24:45 <ac> so now I don't know what the original problem was. I guess I'll try to undo the damage some other time
02:27:53 <joelr1> good morning
02:28:59 <joelr1> ChilliX: any news on that _environ?
02:29:25 <Skyp> hm, if I write func (x:xs) = x in haskell, it gives me the first element... Is this special for the cons-operator? would it be possible in haskell to write an operator which splits off the last element of a list, e.g. func (ys|y) = y?
02:30:08 <wolverian> no. :(
02:30:15 <matthew-_> not on a list
02:30:23 <matthew-_> this is because a haskell list isn't a list. it's a stack
02:31:06 <daniel_larsson> It's because (:) is a constructor. Only constructors work in pattern matches (no?)
02:31:10 <Skyp> ah, ok...
02:32:58 <sjanssen> daniel_larsson: correct, except for numeric patterns and n+k
02:33:22 <daniel_larsson> sjanssen: ah, right
02:33:50 <sjanssen> and then we've got views... :)
02:34:34 <matthew-_> sjanssen: would you say that the ViewL and ViewR in Data.Sequence are views?
02:34:53 <mattam> they are.
02:34:55 <sjanssen> ViewL and ViewR are types
02:35:14 <matthew-_> yep. so by views you mean the snoc stuff in wadler's paper?
02:35:20 <sjanssen> but they're intended to be used as views
02:35:36 <matthew-_> right, I see
02:35:50 <mattam> well, view_L + View_L constitutes a view maybe ?
02:36:11 <sjanssen> mattam: yeah, that seems right
02:36:11 <mattam> Is there some formal definition ?
02:36:28 <sjanssen> it's hard to say, because there have been several proposals for views in Haskell
02:36:32 <mattam> ok
02:37:16 <sjanssen> in the implementation in GHC HEAD, views are just pattern matching on the result of function application
02:38:13 <hpaste>  MonkeeSage pasted "How to make show return parsed list instead of printing it?" at http://hpaste.org/3688
02:46:23 <MonkeeSage> Hello, I'm very new to Haskell and parsec. I'm trying to write a simple parser for VIM colorscheme files. So far I've got a basic parser that prints the tokens I want.
02:46:42 <MonkeeSage> I'm not sure how to convert the show function to return the list of tokens rather than printing it. What I have so far: http://hpaste.org/3688
02:48:46 <sjanssen> MonkeeSage: what should it return if the parse fails?
02:50:31 <MonkeeSage> An empty string or list is fine. I'll be checking that later on (I only want to work with lines where the first token is "hi"), right now I'm just trying to get a list of tokens to work with.
02:57:02 <hpaste>  sjanssen annotated "How to make show return parsed list instead of printing it?" with "parseOrError" at http://hpaste.org/3688#a1
02:57:28 <sjanssen> MonkeeSage: ^^^
02:58:00 <mux> @let splits xs = takeWhile (not . null . snd) $ map (flip splitAt xs) [1..]
02:58:13 <mux> > splits [1..9]
02:58:16 <lambdabot> thread killed
02:58:17 <lambdabot>   Not in scope: `splits'
02:58:21 <mux> hum.
02:58:24 <araujo> morning
02:58:52 <mux> > let splits xs = takeWhile (not . null . snd) $ map (flip splitAt xs) [1..] in splits [1..9]
02:58:53 <lambdabot>  [([1],[2,3,4,5,6,7,8,9]),([1,2],[3,4,5,6,7,8,9]),([1,2,3],[4,5,6,7,8,9]),([1...
03:02:38 <SimeonK> hehe
03:02:48 <SimeonK> I just recieved my first bonus point :)
03:03:03 <mux> bonus point?
03:03:56 <SimeonK> mux :: at school ;)
03:04:09 <mux> oh. :-)
03:04:13 <SimeonK> subject "Introduction to functional programming"
03:06:26 <MonkeeSage> sjanssen: Thanks. :) For some reason I kept thinking that 'IO a' should be the return type. A question, though; in your annotation, doesn't 'error' cause a non-recoverable error? I'd like to simply pass over parsing errors and use only the lines that are properly parsed. (Again, I'm a newbie, sorry if the answer is obvious).
03:06:53 <sjanssen> MonkeeSage: yes, error does cause a non-recoverable error
03:07:12 <sjanssen> perhaps you should replace it with []?
03:11:58 <MonkeeSage> When I try [], I get an error about rigid variable 'a' not matching inferred type [a1]... mapM_ (print . parseOrError frags) ds
03:12:39 <sjanssen> you'll have to change the type signature too
03:13:05 <sjanssen> parseOrError :: Parser [a] -> String -> [a]
03:14:02 <arossato> anyone having problems in building ghc-6.8.1 documentation?
03:14:25 <MonkeeSage> Aha! Thank you kindly. :)
03:19:16 <ivanm> arossato: they seem to have shifted the directory
03:19:38 <ivanm> so it could be being built, but  just not where you expect it
03:19:43 <MonkeeSage> sjanssen: So in parseOrError, when I hit the Right, I'm returning a [Char] (=String), which is a successful parse, and when I hit the Left I'm returning a []? So the type sig. is [a]? Is that right? (Sorry for my dumb questions.)
03:20:08 <sjanssen> MonkeeSage: yes, that's right
03:20:45 <sjanssen> actually, you're not necessarily returning [Char], it could be [anything]
03:21:42 <MonkeeSage> Ah. I remember. That's what the polymorphic [a] is for, yes?
03:22:56 <sjanssen> yep
03:24:05 <MonkeeSage> Alright. Thanks again! :)
03:34:12 <adept> have somebody perchance already built 6.8.1 for Debian etch? :)
03:40:23 <ivanm> I presume log == natural logarithm with logBase being for any base?
03:40:47 <quicksilver> > log 1
03:40:49 <lambdabot>  0.0
03:40:52 <quicksilver> > log 10
03:40:53 <lambdabot>  2.302585092994046
03:40:57 <quicksilver> looks like it to me :)
03:41:35 <ivanm> just checking... since to me, log = log_10 and ln = log_e
03:41:59 <quicksilver> yeah
03:42:06 <quicksilver> really that is a more correct convention
03:42:12 <quicksilver> but log = log_e seems to have taken over
03:42:23 <quicksilver> :t ln
03:42:25 <lambdabot> Not in scope: `ln'
03:43:53 <glguy> What's the trick to building darcs with ghc 6.8.1? (specifically switching openFd to fdToHandle
03:46:22 <swiert> @yow
03:46:23 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
03:46:38 <swiert> Quiet morning...
03:48:35 <profmakx> glguy: I have been told not to try until darcs is fixed :/
03:59:29 <fasta> There is no way to do a full ghci re-initialization at run-time, is there?
03:59:48 <SamB_XP> full?
04:00:02 <SamB_XP> you could always re-exec it ;-P
04:00:14 <fasta> (problem being that installing a package is not noticed by ghci)
04:01:09 <fasta> Not a huge problem, but mere lack of polish.
04:01:55 <ivanm> @seen roconnor
04:01:55 <lambdabot> I saw roconnor leaving ##logic, #not-math, #haskell-overflow, #haskell-blah and #haskell 1h 53m 56s ago, and .
04:03:52 <SamB> well, you could :set -package-conf /usr/lib/ghc-6.?/package.conf
04:04:15 <SamB> not sure how useful that would be...
04:04:29 <SamB> but it doesn't give an error message...
04:11:07 <ivanm> @ask roconnor where did you get your different algorithms for the trigonemtric functions?
04:11:08 <lambdabot> Consider it noted.
04:21:18 <Lycurgus> Arthmetic approximations to trig functions are fairly well known I should think.
04:21:35 <SamB> yeah... does roconner use really odd ones?
04:26:44 <aleator> Hey. How do I force readFile/hGetContents to read stuff "Now" instead of waiting to consume it lazily?
04:28:21 <SamB> well, you could either use a strict bytestring, or you could force a call to length on the data...
04:31:10 <aleator> SamB: is "!l <- length stuff" enough?
04:31:22 <aleator> I mean leet
04:31:24 <fasta> I have a string of Haskell code, can I pretty print that?
04:31:25 <aleator> let
04:33:46 <scook0> let won't force it
04:34:07 <scook0> I tend to do length stuff `seq` return ()
04:34:14 <scook0> but there might be a better way
04:34:18 <fasta> scook0: rnf
04:35:04 <fasta> Actually, it depends on exactly what you want to do
04:35:11 <scook0> fasta: in this case it's lazy I/O, so length should be sufficient
04:35:19 <scook0> though I guess rnf more clearly captures the intention
04:38:05 <fasta> aleator: yes
04:38:13 <fasta> aleator: that's enough
04:38:24 <fasta> scook0: note the !
04:39:19 <aleator> scook0: Control.Parallel.rnf?
04:40:10 <SimeonK> ah
04:40:30 <scook0> @hoogle rnf
04:40:30 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
04:40:49 <SimeonK> @hoogle zipWith
04:40:49 <scook0> yeah
04:40:50 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
04:40:50 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
04:40:50 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
04:40:53 <SimeonK> wow :)
04:47:07 <mcp_> Hello again. I've got a list of Int's and want to calculate its sum (yielding an Integer). the sum command is  "Num a => [a] -> a". Will converting my Int-list to an Integer-list before applying sum do what i want?
04:47:33 <dmwit> yes
04:47:54 <mcp_> dmwit, thank you
04:50:27 <mcp_> Difference between Int and Integer is, that Integer can hold really big values, right? To test I'd like to know the bounds of Int. Someone knows it?
04:51:17 <SamB> minBound, maxBound
04:52:12 <dcoutts> > maxBound :: Int
04:52:17 <lambdabot>  2147483647
04:52:25 <dcoutts> > maxBound :: Integer
04:52:25 <lambdabot> Terminated
04:52:35 <ivanm> heh
04:52:59 <dcoutts>     No instance for (Bounded Integer)
04:52:59 <dcoutts>       arising from a use of `maxBound' at <interactive>:1:0-7
04:53:01 <ivanm> though I didn't realise that Integer was an instance of Bounded
04:53:06 <dcoutts> it's not
04:53:07 <mcp_> dcoutts, thx. I'd have never been able to figer out how to use maxBound myself
04:53:25 <dcoutts> mcp_: look at it's type in ghci
04:53:35 <dcoutts> mcp_: that's a good starting point for most functions
04:53:44 <dcoutts> @type maxBound
04:53:46 <lambdabot> forall a. (Bounded a) => a
04:54:05 <dcoutts> @src Bounded
04:54:06 <lambdabot> class  Bounded a  where
04:54:06 <lambdabot>     minBound, maxBound :: a
04:56:20 <joelr1> how do i push -odir build -hidir build into ghci from ghci itself?
04:56:40 <joelr1> same with -package-conf ../inplace.conf
05:04:33 <Beelsebob_> > let f c n = (1 + c / n) ^ n in f 1 2
05:04:41 <lambdabot>  Add a type signature
05:06:45 <balodja> may be **?
05:06:55 <Beelsebob_> yeh... what I find interesting
05:07:08 <balodja> > let f c n = (1 + c / n) ** n in f 1 2
05:07:09 <Beelsebob_> is that if you go into ghci, and define let f c n = (1 + c / n) ^ n
05:07:10 <lambdabot>  2.25
05:07:20 <Beelsebob_> it does *not* catch the type error at compile time
05:07:36 <Beelsebob_> there's no concrete types that can satisfy it
05:08:44 <quicksilver> Beelsebob_: yes, but you might define same later
05:08:49 <quicksilver> Beelsebob_: typeclasses are open
05:08:52 <Beelsebob_> ah, good point
05:09:03 <quicksilver> there's nothing wrong with the type of f, per se
05:09:20 <quicksilver> it just happens that you none of the prelude types satisfy those constraints
05:09:38 <Beelsebob_> okay, so if I invoke the compiler on that it should catch it
05:09:43 <Beelsebob_> because it knows it's a closed system
05:09:47 <quicksilver> nope
05:09:54 <quicksilver> compiled code is not a closed system
05:09:59 <Beelsebob_> hmm?
05:10:02 <quicksilver> you can link the produced .o file with more new stuff later
05:10:08 <Beelsebob_> bah
05:10:08 <Beelsebob_> true
05:10:22 <quicksilver> f :: (Fractional a, Integral a) => a -> a -> a
05:10:27 <quicksilver> perfectly sensible type
05:10:37 <Beelsebob_> yep
05:10:41 <quicksilver> it just happens that you and I know the semantics of Fractional and Integral aren't really compatible
05:10:48 <quicksilver> but the class system doesn't model that
05:11:36 <Beelsebob_> yep
05:11:38 <Beelsebob_> makes sense
05:12:13 <roconnor> @src Fractional
05:12:13 <lambdabot> class  (Num a) => Fractional a  where
05:12:13 <lambdabot>     (/)             :: a -> a -> a
05:12:13 <lambdabot>     recip           :: a -> a
05:12:13 <lambdabot>     fromRational    :: Rational -> a
05:12:24 <roconnor> @src Integral
05:12:24 <balodja> @type (^)
05:12:25 <lambdabot> class  (Real a, Enum a) => Integral a  where
05:12:25 <lambdabot>     quot, rem, div, mod :: a -> a -> a
05:12:25 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
05:12:25 <lambdabot>     toInteger           :: a -> Integer
05:12:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:13:10 <roconnor> toInteger!
05:13:10 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
05:13:44 <roconnor> @seen ivanm
05:13:44 <lambdabot> ivanm is in #xmonad, #haskell and #gentoo-haskell. I last heard ivanm speak 20m 43s ago.
05:13:54 <ivanm> hey roconnor
05:14:05 <roconnor> I'm not sure I understand your question.
05:15:04 <ivanm> all your definitions for cos, tan, etc. that you have in your fewdigits code... where did you get them all from?
05:15:34 <roconnor> They are essentially the taylor series of them.
05:18:08 <Karle> hi
05:18:47 <roconnor> hi
05:20:29 <hpaste>  Karle pasted "help" at http://hpaste.org/3689
05:21:54 <Karle> roconnor, could you please help?
05:22:32 <Karle> the line number is wrong, sorry
05:22:58 <Saizan_> Karle: the pattern for the second argument of findportT in the last line is wrong
05:23:17 <Saizan_> Karle: [(addr_t,port_t):ts]  should be ((addr_t,port_t):ts)
05:23:25 <hpaste>  Karle annotated "help" with "help" at http://hpaste.org/3689#a1
05:24:06 <roconnor> maybe you want ``findporT pkgP [ts]''?
05:24:10 <Saizan_> and, are you sure findportT takes a list of tables and not a table?
05:24:57 <roconnor> oh
05:25:02 <roconnor> listen to Saizen_
05:25:04 <roconnor> :)
05:25:09 <ivanm> roconnor: *nod*
05:25:29 <Karle> Saizan_ , let me take a look
05:26:48 <roconnor> > sqrt pi
05:26:53 <lambdabot>  1.7724538509055159
05:28:06 <Karle> Saizan, yes it should be a list of tables
05:29:15 <ivanm> roconnor: so the whole basis of your datatype is to constrain it between upper and lower bounds?
05:29:36 <roconnor> ivanm: CReals or ICReals?
05:29:47 <hpaste>  (anonymous) annotated "help" with "(no title)" at http://hpaste.org/3689#a2
05:30:10 <ivanm> roconnor: well, ICReals store the bounds, but CReals just re-calculate them all the time, right?
05:30:15 <Karle> Saizan_, when I changed to ((addr_t,port_t):ts) ... I ran into error message for the next line
05:30:20 <roconnor> ivanm: that's right
05:30:21 <Saizan_> Karle: ok, then, you know that a pattern like [(addr_t,port_t):ts] only look at the first table? because it's like (((addr_t,port_t):ts):[])
05:31:02 <Karle> Saizan_, i am a beginner
05:31:17 <Svrog> Karle: http://hpaste.org/3689#a2
05:31:36 <Saizan_> in fact this is a think every beginner has to learn
05:31:40 <Svrog> no idea what you're trying to do but at least it compiles now :P
05:31:40 <Saizan_> *thing
05:32:13 <Svrog> i also removed that overlapping pattern
05:32:48 <Svrog> oops
05:33:03 <Karle> Svrog, thanks it works
05:33:03 <Svrog> maybe that should go back - dunno - anyway that should help you out
05:33:09 <Svrog> np
05:34:48 <Karle> Svrog , what is dunno?
05:34:54 <Svrog> nope, i was right the first time - that pattern would never be matched
05:35:04 <Svrog> i was talking about the pattern i removed
05:37:29 <Karle> alright
05:38:49 <bparkis> Suppose that instead of solving the maximum flow problem for networks, you have a region in space with a continuous flow density function specifying the maximum flow per unit volume through each unit of space
05:39:17 <bparkis> is this a problem that has been considered?
05:39:48 <fasta> bparkis: home work?
05:39:52 <bparkis> no not homework
05:40:17 <fasta> bparkis: It's the same problem.
05:40:40 <bparkis> or in the plane, suppose you divide the plane into polygonal regions, each region with a constant flow density per unit area
05:40:48 <bparkis> and you want to maximize the flow there
05:41:14 <bparkis> i don't think it's the same problem, i think it might be solvable by similar methods (perhaps by imposing a grid)
05:41:44 <fasta> bparkis: You mean that for example you have a bottle and want to know how much water you can poor into it per second?
05:42:12 <bparkis> no i don't think that could be modeled this way
05:42:25 <bparkis> more like, you have a sponge with varying density and you want to know how much water can flow through it per second
05:43:24 <fasta> bparkis: define your problem better
05:43:28 <bparkis> one way is to use the network flow methods, i.e. divide up the sponge into its cells and bound the flow from each cell to its neighbors depending on cell wall size
05:43:47 <bparkis> but that really only works for the sponge case because the sponge has compartments
05:43:55 <bparkis> more generally it's only an approximation
05:44:43 <quicksilver> sounds like a differential equation with boundary conditions
05:44:55 <quicksilver> and, off-hand, it sounds like one of the soluble ones but I wouldn't be sure
05:45:17 <quicksilver> the heatflow equation is \nabla^{2} = 0
05:45:20 <bparkis> well let me think about exactly how to formally model it but it's not a DE because the constraint is a _maximum capacity_ constraint
05:45:38 <bparkis> the problem is restricting the flow to be less than some function
05:45:38 <quicksilver> the water flow isn't the same, because water unlike heat is incompressible
05:45:43 <quicksilver> but it sounds similar
05:46:35 <bparkis> you would have a capacity function C(x, y, z), and you want to find a flow F such that F <= C for all points, and F is a valid flow function
05:47:31 <bparkis> and you want to maximize the integral of F over part of the boundary (flow emanating from the "source")
05:49:28 <bparkis> which I guess means, F <= C and the divergence of F is 0
05:52:16 <bparkis> except at the source and sink on the boundary
05:53:10 <matthew_-> would anyone be interested in writing a full SMTP daemon in Haskell?
05:58:47 <Karle> I could compile my program ... but it does not work
05:58:49 <Karle> :(
05:59:23 <matthew_-> are you sure it's written in haskell?
06:00:24 <Karle> matthew_, yes it is written in haskell
06:00:41 <matthew_-> hmmm. normally haskell programs work. ;-)
06:01:01 <matthew_-> um, well, you could try showing us the problematic bits using hpaste:
06:01:05 <matthew_-> !hpaste
06:01:11 <matthew_-> @where hpaste
06:01:11 <lambdabot> I know nothing about hpaste.
06:01:15 <matthew_-> @hpaste
06:01:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:01:19 <matthew_-> ahh! finally!
06:01:28 <rby> Karle: what do you mean by "it doesnt' work" (is it "it doesn't print anything ?")
06:01:58 <Karle> some process in the program do not function or something
06:03:08 <Karle> let me show you
06:04:19 <Saizan_> non-exhaustive patterns?
06:04:29 <Karle> hpaste.org
06:04:51 <xif> quicksilver, sjanssen: some research reveals that Bazaar is probably the most awesome of all VCSs, but it's also the slowest.
06:05:15 <xif> Git is somewhat more complex, but it's by far the fastest, and Hg is somewhere in the middle.
06:05:16 <hpaste>  Karle pasted "help" at http://hpaste.org/3690
06:05:33 <matthew_-> xif: speed is actually a concern?
06:05:52 <xif> matthew-_: on a large enough code-base - it is.
06:06:12 <xif> though probably not for most projects out there.
06:06:33 <xif> Bazaar's speed was a problem for a Mozilla-sized codebase
06:06:44 <matthew_-> xif: right. I read that too.
06:06:57 <matthew_-> xif: quite. speed matters when importing a code base, sure - that's what the mozilla ppl were doing no?
06:07:15 <xif> matthew-_: that actually took them a full month of runtime
06:07:22 <matthew_-> for general day-to-day stuff, speed doesn't really raise its head does it?
06:07:34 <xif> matthew-_: but they also suffered slowness in day-to-day operations like diff
06:07:34 <matthew_-> xif: then they shouldn't write so much code ;-)
06:08:00 <matthew_-> if they wrote in Haskell then diffs would be faster!
06:08:03 <xif> "A month to import might be ok, if day-to-day operations were on par with Mercurial (or even CVS), but jst did some tests, and found out that, unfortunately, they weren't."
06:08:18 <xif> test results: http://weblogs.mozillazine.org/jst/archives/2006/11/vcs_performance.html
06:08:21 <lambdabot> Title: Jst's Blog: bzr/hg/git performance, http://tinyurl.com/yuyd3p
06:08:21 <matthew_-> fair enough. been a few months since I read that.
06:08:37 * matthew_- is a monotone man
06:08:51 <xif> BTW, how would you say: "depending on arising issues"?
06:09:33 <matthew_-> I don't know how to answer that question via IRC
06:11:34 <ttfh> Karle: you've come across a case that isn't covered by your definition of findporT
06:13:16 <Karle> ttfh, one line was deleted there
06:13:19 <Karle> must be it
06:13:30 <Svrog> nope
06:13:38 <Svrog> the line that was deleted didnt do anything
06:14:10 <Karle> Svrog removed one pattern there
06:14:14 <Svrog> yes
06:14:20 <Svrog> because it was never matched
06:14:28 <quicksilver> xif: bzr has massively improved its performance since November 2006
06:14:40 <quicksilver> xif: (spurred on by the various communications of the mozilla community)
06:14:50 <quicksilver> xif: however, it's still slower than git, definitely.
06:15:50 <Karle> findporT    _    Abst         =  [([],[])]  ---- this was the original
06:16:05 <Karle> but I changed to  findporT    _    []          =  [([],[])]
06:16:32 <ttfh> the first pattern would match anything, but the second wouldn't
06:18:46 <Karle> when I put it back ... the error occurs
06:19:04 <Karle> ERROR file:.\Switch_ut.hs:67 - Type error in explicitly typed binding
06:19:04 <Karle> *** Term           : Abst
06:19:04 <Karle> *** Type           : AbstExt a
06:19:04 <Karle> *** Does not match : [Table]
06:19:17 <ttfh> sorry, my mistake :-(
06:19:22 <Karle> line 67 is the line
06:19:39 <ttfh> the first pattern doesn't match anything, of course
06:20:28 <Karle> then it must be something else
06:22:12 <Karle> it seems like update_tablE is never called
06:23:27 <mdmkolbe|ubunt1> Anyone know what the timeline for when Ubuntu will include GHC 6.8?
06:24:35 <quicksilver> Karle: yes, nothing in the code calls update_tableE
06:25:14 <xif> mdmkolbe|ubunt1: (probably depends on someone creating a proper .deb rather than on Ubuntu / Canonical)
06:25:58 <arossato> I had some issue in building the documentation for ghc-6.8.1 in slackware: docbook xsl stylesheets are installed in /usr/share/xml/dockbook/xsl-stylesheets-1.72.0, and this directory is not checked by ./configure (but I think this is a configure issue): do you think should I report the problem to the ghc team?
06:26:07 <xif> quicksilver: yeah, I'll probably use Bazarr, because it seems best feature-wise, and because my codebase isn't Mozilla-sized yet, and because I like canonical
06:26:32 <RayNbow> just wondering... is it possible to interrupt a calculation in ghci? :p
06:26:38 <RayNbow> in Hugs Ctrl+C does the trick
06:26:45 <quicksilver> ctrl-C should work in ghci too
06:26:49 <xif> quicksilver: (it is to be expected for bzr to be slower than git, what's interesting is how it compares to Hg after those changes)
06:27:22 <quicksilver> RayNbow: ctrl-C works for me
06:27:27 <RayNbow> hmm... odd...
06:30:10 <gnomnain> RayNbow: windows user ?
06:30:21 <joelr1> has anyone built darcs with 6.8.1 on leopard? i get configure: error: Couldnt figure out how to call GHC.Handle.openFd!
06:30:39 <quicksilver> joelr1: I beleive this is a well known error
06:30:51 <quicksilver> joelr1: the advice I've seen is "please wait for fix"
06:30:51 <joelr1> quicksilver: is there a workaround?
06:30:57 <joelr1> quicksilver: oh...
06:31:00 <joelr1> thanks then
06:34:22 <Karle> quicksilver, I have to call update_tablE in update_pR but I dont know how ..any suggestions?
06:34:43 <RayNbow> gnomnain: yes
06:35:07 <gnomnain> RayNbow: i have the same problem
06:36:12 <RayNbow> gnomnain, I did find this: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-windows.html
06:36:14 <lambdabot> Title: 12.2. Running GHCi on Windows, http://tinyurl.com/2elevn
06:38:14 <quicksilver> Karle: if I might suggest, it seems to me that your program is too complex for your level of understanding of haskell
06:38:28 <quicksilver> Karle: you were doing some pretty strange pattern bindings
06:38:39 <quicksilver> and I think it's easier to learn these things with a similper code which you can easily change
06:38:53 <quicksilver> and test
06:39:32 <Karle> quicksilver, i agree
06:39:58 <Karle> well....
06:40:58 <Karle> totally agree
06:44:57 <yaxu> hoogle seems a bit broken at the moment
06:46:19 <Karle> be right back ... thanks for your helps
06:46:22 <Karle> :)
06:46:43 <RayNbow> hmm, is ghci's :set +s accurate?
06:47:22 * RayNbow is amazed that the naive recursive version of the Fibonacci function uses like 190 MB of memory
06:47:33 <RayNbow> (calculating fib 30)
06:47:41 * fasta is not
06:47:45 <yaxu> i can pattern match empty lists with foo [] = 0 , is there a similarly easy way to do that with a Set ?
06:47:51 <yaxu> from Data.Set
06:48:17 <fasta> RayNbow: why are you amazed?
06:48:57 <yaxu> foo x | size x == 0 = 0
06:48:58 <RayNbow> well, I expected that it would be space inefficient
06:49:02 <yaxu> i guess
06:49:17 <fasta> RayNbow: it is space inefficient.
06:49:17 <mauke> foo x | null x = 0
06:49:35 <RayNbow> fasta: but I didn't expect it to be that bad :p
06:50:00 <yaxu> nicer mauke
06:50:37 <fasta> RayNbow: it will be about an order of magnitude less with ghc.
06:50:50 <mauke> why does Mike Oldfield - Etude sound like it's from Mischief Makers?
06:51:13 <nominolo> @users
06:51:13 <lambdabot> Maximum users seen in #haskell: 424, currently: 385 (90.8%), active: 12 (3.1%)
06:52:55 <RayNbow> fasta: ah thanks for pointing that out :)
06:52:59 <naranha> why doesn't the function abstraction in the last line work: http://hpaste.org/3691. It says too few args for d
06:53:18 <fasta> RayNbow: but your algorithm stinks, you know that, right?
06:53:46 <RayNbow> fasta: I know
06:53:58 <naranha> for me it's not much more than (+).(+3) , which works
06:54:12 <naranha> (+3).(+) i mean
06:54:16 <RayNbow> I just wanted to demonstrate the inefficiency to someone else
06:54:23 <mauke> naranha: because there's no String in there
06:54:25 <RayNbow> but I just didn't expect that much memory use
06:54:45 * RayNbow prefers the fibs = 0:1:zipWith (+) fibs (tail fibs) definition
06:55:05 <naranha> yes , but that's the point, i want it to return a Function of type Delta Int
06:55:28 <naranha> and just modify the result
06:55:48 <opqdonut> is there something like a State [a] monad where operations consume the stream
06:55:56 <opqdonut> (coding a simple parser)
06:56:14 <mauke> naranha: (shiftStates n .) . d
06:56:44 <naranha> great, thank you!
06:58:48 <fasta> RayNbow: oh, someone else who thinks Haskell is like dynamic programming?
07:01:13 <quicksilver> opqdonut: that's called the 'supply' monad
07:01:20 <quicksilver> opqdonut: tehre is an possible implementation on the wiki
07:01:29 <quicksilver> opqdonut: which, indeed, uses State [a] behind the scenes
07:01:52 <quicksilver> opqdonut: I wrote a similar one myself in the process of implementing zipWith for traversable
07:02:06 <RayNbow> fasta: no, it was just a random demonstration... no specific reason :)
07:02:26 <opqdonut> quicksilver: yeah i thought this would be an usual idiom
07:02:39 <opqdonut> tho now that i think about it, tail recursion on the remaining stream would work also
07:02:45 <ToRA> @type State $ (head &&& tail)
07:02:47 <lambdabot> forall a. State [a] a
07:03:22 <quicksilver> opqdonut: yes, it does
07:03:45 <quicksilver> opqdonut: but on having it as a monad frees you from that particular tail recursion
07:04:04 <quicksilver> opqdonut: i.e. it abstracts that part and doesn't force you into explicitly using that control flow
07:04:39 <opqdonut> quicksilver: actually i already did the parser with parsec but my instructor wants it hand-coded
07:04:46 * quicksilver nods
07:04:54 <opqdonut> and i'm only parsing a very simple suffix grammar
07:05:00 <opqdonut> (regexes to be exact)
07:05:03 <quicksilver> the simple classic encoding of a parser is [a] -> (v,[a])
07:05:08 <opqdonut> yep
07:05:10 <quicksilver> which is precisely State [a]
07:05:12 <quicksilver> by hand
07:05:15 <opqdonut> mhmm
07:05:27 <quicksilver> doing State by hand is quite often more pleasant :)
07:05:43 <opqdonut> but i'll probably mix semantics and parsing and just have a tail-recursive [a] -> v
07:06:14 <naranha> mauke: could you tell me what the additional dot in the function application does? I thought the dot operator is simply defined as (f.g) x = f(g x) , which doesn't make much sense here
07:06:55 <quicksilver> naranha: yes, that's exactly what it means
07:07:02 <quicksilver> naranha: but here he's taking a section of it
07:07:15 <quicksilver> (f.) means (\g -> (f.g))
07:07:25 <quicksilver> [just like (3+) means (\g -> 3+g)]
07:07:34 <joelr1> is there a cpp as a library, in haskell?
07:08:05 <naranha> ah right, now i get it
07:08:08 <quicksilver> naranha: "shiftStates n" has type [Int]->[Int]
07:08:35 <quicksilver> d has type Int -> String -> [Int]
07:08:42 <quicksilver> these are not composable :)
07:09:08 <quicksilver> in effect, .-sections allow you to compose 'in different arguments'
07:09:15 <quicksilver> or 'functions of different arity'
07:09:54 <mauke> it's the difference between f (g x) y and f (g x y)
07:09:56 <naranha> why are they not composable, the "return type" of d is [int]
07:10:03 <quicksilver> naranha: because it isn't :)
07:10:11 <quicksilver> naranha: the "return type" of d is String -> [Int]
07:10:14 <mauke> the return type of d is String -> [Int]
07:10:49 <naranha> ah ok, seems there's still much to learn
07:11:08 <mauke> a -> b -> c is the same as a -> (b -> c)
07:11:08 <mauke> that's what currying is all about
07:11:12 <quicksilver> there is always much to learn, grasshoppper :)
07:11:48 <naranha> sure, well, thanks again
07:13:57 <fasta> > ("a"++"b"++) "c" -- doesn't work, but it could
07:14:04 <lambdabot>      The operator `++' [infixr 5] of a section
07:14:05 <lambdabot>         must have lower preced...
07:14:44 <fasta> (don't paste a better version, since I already know how to write it with sections. )
07:24:18 <ac> http://math.ucr.edu/home/baez/week73.html
07:24:19 <lambdabot> Title: week73
07:25:25 <ac> I really like that explanation. A couple years back I attempted to read "Basic Category Theory for Computer Scientists" and concluded category theory was beyond my reach at the time, and it turns out it's in fact very simple
07:29:30 <ac> I want to slap the person who recommended that book to me
07:30:27 <matthew_-> ac: the ben pierce book?
07:32:02 <ac> matthew_-: yeah. I'm not saying it's a bad book
07:32:30 <matthew_-> no no. don't worry - I've got it, I've just never bothered to read it!
07:33:01 <ac> I wish the guy had just given me an english explanation of what they are in response to "what's category theory"
07:34:00 <sek> that book is so clear and simple
07:34:16 <ac> sek: the first page was
07:34:22 <ac> sek: er, the first paragraph
07:34:28 <sek> have you tried reading MacLane's book?
07:34:43 <ac> sek: I don't think so. What's it called?
07:34:53 <sek> Categories for the Working Mathematician
07:35:08 <Olathe> Is there a "Categories for computer programmers" ?
07:35:08 <ac> sek: the problem is, I'm not a computer scientist or a mathematician by any means
07:35:17 <ac> Olathe: that would be the book for me
07:35:24 <sek> Pierce's book is a "toilet read", compared to the intesity of the other one
07:35:45 <Olathe> If it's really intestiny, it might be a good bathroom book, though.
07:35:53 <sek> hah
07:37:41 <quicksilver> fasta: well, it doesn't let you section wrong-associative operators
07:37:53 <quicksilver> fasta: so you can do (a~b~) iff ~ is left-assoc
07:38:17 <fasta> quicksilver: what' the difference between "a" ++
07:38:37 <quicksilver> fasta: (a~b~) is parsed as ((a~b)~)
07:38:49 <quicksilver> so it's only a sensible thing to do if ~ is left-assoc
07:39:03 <quicksilver> I agree that it could be parsed as \x -> (a~(b~x))
07:39:08 <quicksilver> it just happens not to be
07:39:19 <quicksilver> simpler this way, in some sense, I suppose
07:39:22 <fasta> quicksilver: "a" ++ ("b" ++ "c") and ("a" ++ "b") ++ "c"
07:39:37 <quicksilver> fasta: yes, the language has no concept of 'truly associative'
07:39:47 <quicksilver> fasta: the language always picks left or right associative
07:39:50 <mauke> you could even turn (a + b *) into (a +) . (b *)
07:39:51 <mauke> you don't need associativity
07:39:59 <quicksilver> (And for ++ it's just as well it does)
07:40:07 <quicksilver> since ++ right-assoc is much more efficient
07:40:12 <fasta> quicksilver: you can define an associative operator in Haskell
07:40:21 <quicksilver> but you cannot tell the compiler you have done so
07:40:28 <quicksilver> there is no compiler or language support for true associativity
07:40:36 <fasta> infix 5 <operator>
07:40:50 <opqdonut> where is the instance Monad (Either String) declared?
07:40:52 <quicksilver> that forbids it entirely
07:40:54 <opqdonut> :i Either
07:40:57 <fasta> Oh, I see your point
07:41:00 <quicksilver> infix without left or right forbids you to chain more than one
07:41:06 <quicksilver> > True==True==True
07:41:07 <lambdabot>      precedence parsing error
07:41:08 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
07:41:15 <mauke> opqdonut: probably in a module imported by Control.Monad.Error
07:41:16 <fasta> quicksilver: right, I realized that.
07:41:19 <quicksilver> ^^ forbidden because == was declared infix
07:41:40 <opqdonut> Could not find module `Control.Monad.Error':
07:41:41 <fasta> quicksilver: so, another misfeature to add to the list :)
07:41:48 <quicksilver> so why did you say " you can define an associative operator in Haskell" "infix 5 <operator>"
07:41:48 <opqdonut> i've got 6.6.1
07:42:07 <fasta> quicksilver: because I didn't realize it then.
07:42:09 <quicksilver> opqdonut: seems you don't have the mtl installed then?
07:42:21 <mauke> http://haskell.org/ghc/docs/6.6.1/html/libraries/mtl/Control-Monad-Error.html
07:42:22 <quicksilver> I don't think it's a misfeature really
07:42:23 <lambdabot> http://tinyurl.com/ys5r39
07:42:23 <benny91> opqdonut: get GHC 6.8.1 free! today ;)
07:42:29 <idnar> @instances Monad
07:42:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:42:31 <opqdonut> quicksilver: ah, must be it
07:42:32 <quicksilver> true associativity is quite hard to get right
07:42:38 <opqdonut> damn debian packaging
07:42:42 <idnar> hmm, that didn't quite help
07:42:58 <benny91> opqdonut: uh, debian ?, get it free! in 1-2 years :)
07:43:17 <mauke> gentoo is still at 6.4 AFAIK
07:43:18 <fasta> benny91: I had it before it came out
07:43:24 <fasta> benny91: :)
07:43:38 <benny91> fasta: from an official debian repos ?
07:43:44 <quicksilver> debian has 6.6.1 in etch
07:43:47 <quicksilver> has done from ages
07:43:50 <quicksilver> for ages
07:43:58 <benny91> fasta: or are you developing ghc :) ?
07:44:16 <quicksilver> opqdonut: apt-get install libghc6-mtl-dev ?
07:44:18 <quicksilver> not that hard :)
07:44:19 <fasta> benny91: I just needed a newer ghc, since ghc-6.6.1 was too buggy to accept my code.
07:44:27 <opqdonut> quicksilver: yeah, got it already
07:44:32 <opqdonut> just didn't realise it had been split
07:44:51 <fasta> benny91: no, I compiled from source.
07:45:03 <benny91> fasta: debian repos are quite "slow" anyway :p
07:45:06 * ac is waiting for 6.8 to appear in gutsy
07:45:16 <benny91> fasta: ah :)
07:45:29 <fasta> benny91: That might be because they do proper packaging in some cases.
07:45:49 <quicksilver> the debian ghc packages are uploaded by the same man who posted the GHC release announcment
07:45:50 <fasta> benny91: and for ghc it's because Igloo is the package maintainer and he is quite busy.
07:45:58 <quicksilver> so I doubt he will be that far behind
07:46:04 <benny91> fasta: if they are in "stable" they are stable, really
07:46:24 <fasta> Is GHC in Debian Stable?
07:46:43 <fasta> I am quite sure Debian doesn't fix bugs in it.
07:46:48 <benny91> fasta: I'm not sure, but I guess it was when I had debian
07:46:48 <fasta> (if it was)
07:46:52 <Itkovian> any ghc for macosx, version 6.8.x?
07:46:59 <fasta> Itkovian: yes
07:47:04 <fasta> Itkovian: posted on some mailing list
07:47:06 <ac> fasta: is there also an ubuntu package maintainer, or do the same people make debian and ubuntu packages?
07:47:07 <Itkovian> l33t
07:47:08 <fasta> Itkovian: ghc-users, IIRC
07:47:13 <fasta> ac: no idea
07:47:14 <Itkovian> thx
07:47:30 <benny91> is this a "cafe"-channel btw. or is it a strict haskell channel?
07:47:38 <fasta> benny91: cafe
07:47:42 <benny91> fasta: great :)
07:47:45 <benny91> #lisp hates me already :(
07:47:49 <quicksilver> ac: ubuntu in many cases take the debian package, check they're ok, and upload them to ubuntu.
07:47:54 <fasta> benny91: but there is no #haskell strict
07:48:16 <fasta> benny91: it's not a license to chatter.
07:48:23 <fasta> benny91: there's #haskell-blah for that
07:48:45 <b_jonas> I agree. This is a pure channel. #haskell-blah for side-effects.
07:48:47 <ac> quicksilver: for some reason I thought updates made there way in to ubuntu releases faster than debian, but if that's the usual process, that can't be true
07:48:50 <benny91> ah, great :), *remembers* I joined that channel a long time already
07:48:54 <benny91> *ago
07:49:03 <quicksilver> ac: ubuntu make *stable* releases much more often
07:49:09 <quicksilver> ac: debian *unstable* can be pretty fast, though
07:49:14 <quicksilver> ac: (depending on the maintainer)
07:49:15 <benny91> ok, sorry, didn't mean to offend anybody :)
07:49:37 <ac> quicksilver: ah. And ubuntu doesn't have an unstable equiv.?
07:49:55 <quicksilver> this channel is fairly reactive. If there are people pursuing serious haskell business, like trying to help a newbie with some code, people generally pipe down
07:50:05 <quicksilver> if it's quiet, then people fee free to chat about all sorts.
07:50:07 <pejo> Itkovian, the thing posted to ghc-users was for Leopard only afaik.
07:50:13 <ac> back when I used plain debian I always had unstable and experimental in my sources.list
07:50:17 <quicksilver> ac: ubuntu does have an unstable too, I thnk
07:50:20 <Itkovian> I knew it had to upgrade!
07:50:25 <Olathe> Bubble sort sucks.
07:50:26 <Itkovian> Now I have a reason too
07:50:38 <benny91> quicksilver: ah :) ok
07:50:40 <quicksilver> ac: they have a smaller set of packages, and they QA them faster, and they set release deadlines fairly firmly.
07:50:50 <idnar> they don't really have an unstable equivalent yet, I don't think; they've got something like testing, though
07:50:56 <benny91> (fedora got 6.6.1 packages as well, btw.)
07:50:57 <fasta> Itkovian: or upgrade to Debian ;)
07:51:03 <quicksilver> ac: debian has a massive set of packages, tends to release 'when its ready' and depends on volunteers not paid employees.
07:51:07 <Itkovian> fasta: I think not
07:51:08 <quicksilver> mostly.
07:51:15 <b_jonas> quicksilver: failrly firmly eh,
07:51:17 <Olathe> I wonder if there are any sorts that are faster in all cases than quicksort.
07:51:21 <pejo> Itkovian, heh. Might be worth waiting a little and see what falls out, I'd say. There's atleast one data loss thing described for leopard already.
07:51:27 <quicksilver> Olathe: radix sort!
07:51:34 <Itkovian> pejo: I know
07:51:35 <b_jonas> they're more firm than debian's but not so firm either
07:51:37 <Olathe> That's slower in some cases.
07:51:40 <ac> idnar: what's the testing equiv.?
07:51:40 <benny91> quicksilver: what about heap-sort?
07:51:49 <Itkovian> I usually wait for the .1 patch before upgrading
07:51:49 <MyCatSchemes> RAWR
07:52:08 <quicksilver> Olathe: bucket sort is O(n)
07:52:17 <quicksilver> radix sort is O(n) if you do it right
07:52:22 <quicksilver> they don't suit all datasets though
07:52:25 <pejo> Itkovian, nods. And I can't imagine that it will take that long for 6.8.1 binaries for older versions.
07:52:25 <Olathe> Well, O(n log(k))
07:52:31 <quicksilver> yes
07:52:37 <quicksilver> everything on comptuers is log(k) though
07:52:47 <quicksilver> because memory access is log(k)
07:52:50 <quicksilver> :P
07:53:00 <Olathe> Right. What I mean is that quicksort can sort two 256-bit numbers faster than radix sort.
07:53:24 <Olathe> Radix sort needs O(256n)
07:53:36 <Olathe> Or something similar.
07:53:37 <b_jonas> what? quite the contrary
07:53:47 <Olathe> You could use a different base, I'm sure.
07:53:53 <Cale> O(256n) = O(n)
07:53:57 <Olathe> I know.
07:54:11 <b_jonas> memory access is O(1/log(n)) time if n is the size of memory
07:54:27 <b_jonas> because as computers get faster, they get more memory as well
07:55:17 <sieni> b_jonas: I was thinking about the same :-)
07:55:41 <Cale> O(1/log(n))?
07:56:12 <hpaste>  joed pasted "OSX ghci 6.8.1 from source packages" at http://hpaste.org/3692
07:56:48 <Olathe> Well, time to go.
07:57:36 <hpaste>  omg911 pasted "my evaluator" at http://hpaste.org/3693
07:57:53 <Cale> Do you mean that as computers get more memory, they get faster?
07:57:53 <omg911> can someone help me with the type system pls
07:58:03 <Cale> okay
07:58:36 <omg911> i'm trying to program a genetic programming system
07:58:39 <Cale> omg911: I think you're missing a little something about the syntax of data declarations
07:59:28 <omg911> what do you mean?
07:59:29 <Cale> In each branch of the data declaration after the equals sign, you have a data constructor, followed by a list of types of its parameters
07:59:42 <Cale> For example, your data declaration:
07:59:49 <Cale> data Terminal = Variable | Constant
08:00:10 <Cale> defines a new type Terminal whose only two values are literally Variable and Constant
08:00:18 <Cale> Not values of types Variable and Constant
08:00:37 <Cale> Somehow I get the impression that you really wanted something more like:
08:00:45 <Cale> data Terminal = V Variable | C Constant
08:01:07 <Cale> You need data constructors to pattern match against, so that you know what type the parameter will be.
08:01:22 <omg911> ok so what does the "Variable" mean in that case
08:01:30 <hpaste>  osfameron pasted "fizzbuzz" at http://hpaste.org/3694
08:01:37 <Cale> In my new line?
08:01:39 <omg911> it can be the parameter for the type?
08:01:40 <omg911> yes
08:01:42 <osfameron> meh... work vs haskell...
08:01:53 <Cale> It's the type of parameter that the data constructor V takes.
08:02:01 <Cale> So then you'll have:
08:02:08 <Cale> V :: Variable -> Terminal
08:02:52 <Cale> Perhaps the GADT syntax would make it clearer what's going on here. In that syntax, the datatype as you currently have it would be written:
08:02:58 <Cale> data Terminal where
08:03:03 <Cale>    Variable :: Terminal
08:03:08 <Cale>    Constant :: Terminal
08:03:17 <Cale> Whereas you probably want something like:
08:03:22 <Cale> data Terminal where
08:03:28 <Cale>    V :: Variable -> Terminal
08:03:35 <Cale>    C :: Constant -> Terminal
08:03:58 <omg911> ok i sorta see it now
08:04:08 <Cale> (of course, you can choose other names than V and C, you can even call them Variable and Constant, since they're in a different namespace from the types Variable and Constant
08:04:10 <Cale> )
08:04:34 <Cale> What you've written is equivalent to   data Terminal = V | C
08:04:58 <omg911> yeah what i'm trying to say is terminal is a variable or constant
08:05:11 <omg911> i wanted to use the variable or constant constructor
08:05:29 <Cale> Yeah, but Haskell doesn't have untagged unions, so you need to give names to the different cases
08:06:21 <Cale> It's important for type inference to be able to distinguish between a value of type Variable, and a value of type Terminal, since they're separate types.
08:07:20 <Cale> But if there were no tag to tell which was which, it wouldn't necessarily be able to determine what was meant if you just wrote X, say.
08:08:02 <omg911> ok so if i wanted to same something like data Terminal = Terminal V | Terminal C
08:08:15 <omg911> i need to use separate names for each of those constructor?
08:08:24 <Cale> oh, yes, that too
08:08:32 <Cale> and those V and C would need to be types
08:09:11 <Cale> It goes  <name of new data constructor> <type of parameter> <type of parameter> ...
08:09:33 <quicksilver> omg911: it is a common idiom to use data Terminal = Variable Variable | Constant Constant
08:09:40 <quicksilver> omg911: arguably that's confusing :)
08:09:44 <quicksilver> omg911: but it's common enough
08:09:57 <quicksilver> omg911: here the first 'Variable' is the tag-name, and the second refers to the type you just defined.
08:10:48 <omg911> uh wouldn't it expect Variable to be defined already?
08:11:01 <omg911> and your creating another constructor that's defined
08:11:02 <quicksilver> yes
08:11:13 <quicksilver> constructors and types live in separate namespaces
08:11:22 <quicksilver> so if you have a constructor and a type with the same name, it won't confuse the compiler
08:11:26 <quicksilver> it may, however, confuse you :)
08:12:06 <omg911> i mean so you have V = V Int then T = V V
08:12:17 <omg911> when you try to construct V wouldn't it get confused?
08:12:18 <Cale> data constructors live in the world of values, while types and type constructors live in their own separate world on the right of the ::
08:12:19 <salierix> Is haskell.org down again?
08:12:43 <Cale> omg911: Oh, those tags clash
08:12:53 <Cale> data V = V Int
08:12:54 <quicksilver> omg911: yeah, that's right. That's using V as a tag twice
08:12:58 <Cale> data T = T V
08:12:59 <quicksilver> omg911: that would confuse it
08:13:11 <Cale> My example would be fine though
08:13:33 <quicksilver> omg911: well it wouln't be confused. It would just flat-out complain.
08:13:34 <quicksilver> :)
08:13:49 <omg911> quicksilver: that's  what i was asking because in your example i alreayd defined Variable
08:13:57 <omg911> data Terminal = Variable Variable | Constant Constant
08:14:17 <salierix> ?
08:14:32 <quicksilver> omg911: no, you hadn't
08:14:41 <quicksilver> omg911: not as a constructor
08:14:48 <quicksilver> omg911: data Variable = X | Y
08:14:52 <omg911> oh ok
08:14:54 <quicksilver> omg911: that's fine. Using constructors X and Y
08:15:28 <Cale> Variable there is a type-constructor, and X and Y are data-constructors
08:16:00 <omg911> ah i see the difference between the two type of constructors now
08:16:15 <Cale> data Foo = A B C | D E F
08:16:26 <Cale> Foo, B, C, E, F are type constructors
08:16:32 <Cale> A, D are data constructors
08:17:03 <salierix> What is this an obfuscation contest?  ;)
08:17:08 <omg911> so you only use type constructors in data definitions and type signnitures?
08:17:20 <quicksilver> that's right
08:17:30 <Cale> yeah
08:17:39 <quicksilver> in fact, with GADT syntac, data definitions are also turned into type signatures
08:17:46 <quicksilver> at that point, you only ever use them in type signatures
08:17:49 <quicksilver> nice simple rule
08:17:59 <quicksilver> well, and class instance definitions.
08:18:03 <salierix> Speaking of GADT, what is it?
08:18:06 <Cale> Yes, Haskell should have adopted the GADT syntax from the beginning really.
08:18:10 <omg911> yeah
08:18:27 <b_jonas> what's that?
08:18:28 <omg911> GADT an extension?
08:18:31 <b_jonas> yes
08:18:32 <quicksilver> yes
08:18:36 <quicksilver> it's a different way of writing types
08:18:47 <b_jonas> what's GADT?
08:18:50 <quicksilver> instead of data Foo = Bar | Baz
08:18:56 <quicksilver> you write data Foo where {
08:19:01 <quicksilver> Bar :: Foo
08:19:02 <Cale> Well, GADTs proper are parametric types where some of the constructors can produce values of less than completely polymorphic type... for example:
08:19:03 <quicksilver> Baz :: Foo
08:19:04 <quicksilver> }
08:19:14 <Cale> data Expr a where
08:19:17 <b_jonas> hmm
08:19:25 <Cale>    Const :: Int -> Expr Int
08:19:37 <Cale>    Plus :: Expr Int -> Expr Int -> Expr Int
08:19:43 <b_jonas> yes, that magic
08:19:47 <Cale>    IsZero :: Expr Int -> Expr Bool
08:20:14 <Cale>    If :: Expr Bool -> Expr a -> Expr a
08:20:18 <Cale> er
08:20:21 <Cale>    If :: Expr Bool -> Expr a -> Expr a -> Expr a
08:20:48 <benny13> Cale: wow, hpaste.org <-
08:20:57 <salierix> So why is it not being added to Haskell'?
08:21:00 <Cale> well, I'm just typing this on the fly
08:21:02 <wli> http://holomorphy.com/~wli/polylambda.pdf
08:21:04 <quicksilver> salierix: it's added to GHC
08:21:04 <Cale> salierix: It's in GHC
08:21:25 <salierix> But probably not haskell'
08:21:29 <Cale> right
08:21:31 <wli> Some subtyping crud in there, but it covers kindings.
08:21:38 <Cale> because it's kinda experimental still
08:22:02 <Cale> GADTs also subsume existential types
08:22:13 <Cale> You can write things like...
08:22:15 <salierix> What are they?
08:22:18 <Cale> data Showable where
08:22:29 <Cale>   S :: (Show a) => a -> Showable
08:22:44 <Cale> then S has exactly the type I wrote there
08:23:05 <Cale> That is, it takes anything in the class Show as a parameter, and forgets its original type.
08:23:27 <quicksilver> salierix: http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs
08:23:27 <Cale> Thereafter, all you can do with that value when you get it out is apply methods of the class Show to it.
08:23:28 <lambdabot> Title: GADTs - Haskell Prime - Trac
08:23:34 <quicksilver> salierix: adopt: "Probably no"
08:23:38 <Cale> So it's kind of like an upcast in OO programming.
08:24:09 <salierix> quicksilver, that's why I asked actually.
08:25:04 <quicksilver> I don't know what Cons: "complex interaction with type classes" is supposed to mean
08:25:12 <quicksilver> that sounds like the most substantial 'con' to me
08:25:37 <quicksilver> apart from the generic "moving away from Damas-Milner" objection, I guess
08:26:36 <salierix> So I know the Haskell syntax and a few monads but I'm still not able to make anything yet...
08:27:05 <shapr> salierix: You could make a text fractal.
08:27:17 <opqdonut> is there something like words that takes the element to split on as an argument?
08:27:33 <byorgey> opqdonut: no! *sob*
08:27:42 <opqdonut> :(
08:27:47 * osfameron dislikes words and unwords
08:27:58 <quicksilver> opqdonut: this comes up several times a week :)
08:28:05 <opqdonut> yeah i'd guess :)
08:28:53 <quicksilver> http://groups.google.com/group/fa.haskell/browse_frm/thread/65411ac5d9694108/7e418c0867cff1f4?#7e418c0867cff1f4
08:28:55 <lambdabot> Title: fa.haskell | Google Groups, http://tinyurl.com/ysqet7
08:29:18 <quicksilver> opqdonut: is one discussion. IN the message from me in that thread I give my opinion on why it doesn't exist.
08:30:12 * osfameron hugs perl's split :-)
08:30:18 <ac> salierix: HOpenGL or gtk2hs are fun to play with
08:31:03 <salierix> I was thinking of making a sudoku game.
08:31:33 <osfameron> quicksilver: I imagine there would be some combinators that could be tastefully arranged to produce the various functions as needed
08:33:19 <matthew_-> so, the CS and mathsy people here. Talk to me about reducible graphs?
08:35:22 <shapr> matthew_-: What about them?
08:35:43 <matthew_-> apparently control flow graphs which are reducible graphs have lots of interesting properties
08:35:58 <byorgey> so, uh... those reducible graphs are looking pretty reducible this year, huh?  <-- reducible graph small talk
08:36:11 <matthew_-> but I've just found a paper that claims to convert irreducible control flow graphs to reducible control flow graphs...
08:36:27 <shapr> matthew_-: Got an url?
08:36:38 <matthew_-> shapr: http://citeseer.ist.psu.edu/janssen97making.html
08:36:40 <lambdabot> Title: Making Graphs Reducible with Controlled Node Splitting - Janssen, Corporaal (Res ...
08:36:50 <swiert> what's a reducible graph?
08:37:47 * alar has almost missed interesting talk about control flow graphs
08:37:52 <matthew_-> swiert: um, I'm not sure I trust myself to give an accurate description
08:38:23 <matthew_-> swiert: I think a control flow graph that has no loops is a reducible graph, but that's almost certainly an "if", not an "iff"
08:41:40 <swiert> hmm. so it's an acyclic graph, where every node is reachable from the initial node s.
08:41:51 <swiert> ok. learned something new today.
08:42:55 <b_jonas> salierix: sudoku game? too late, it's been done (http://www.de.ioccc.org/whowon2006.html)
08:42:56 <lambdabot> Title: Who won the 19th IOCCC
08:43:28 <swiert> or http://www.haskell.org/haskellwiki/Sudoku
08:43:29 <lambdabot> Title: Sudoku - HaskellWiki
08:44:56 <matthew_-> swiert: um, well it seems that if you take your control flow graph and remove the back edges, if the remaining graph is acyclic, then the control flow is reducible
08:46:39 <matthew_-> but there's a precise definition of back edge in that the edge you're removing must point to a node that dominates the node from which the edge comes
08:47:07 <tunnuz> hi
08:47:21 <Vq^> hello tunnuz
08:47:31 <tunnuz> what's the correct way to track functions' execution time in ghci?
08:47:33 <swiert> matthew_- but def 2.2 doesn't say anything about removing backedges etc. It just says it needs to be acyclic.
08:47:36 <tunnuz> hi Vq
08:48:12 <dons> http://haskell.org/haskellwiki/Timing_computations
08:48:13 <lambdabot> Title: Timing computations - HaskellWiki
08:48:14 <swiert> tunnuz: http://www.haskell.org/haskellwiki/Timing_computations
08:48:15 <lambdabot> Title: Timing computations - HaskellWiki
08:48:21 <tunnuz> thank you :D
08:48:22 <Notrix> hi, is there a built-in function that convert a string to its float value ? eg : "2.0" -> 2
08:48:23 <swiert> damn. dons beat me to it.
08:48:34 * dons blows smoke from his pistol
08:48:45 <ari> > (read "2.0") :: Float
08:48:48 <lambdabot>  2.0
08:48:57 <matthew_-> swiert: but it's talking about the graph G = (N, FE, s) where N is the set of nodes from the control flow, FE is the set of Forward Edges (i.e. E - BE ; defined above) and s is the starting node
08:49:14 <tunnuz> mmm
08:49:15 <Notrix> > (read "3.32")
08:49:16 <lambdabot>  Exception: Prelude.read: no parse
08:49:18 <tunnuz> there's a better way
08:49:26 <tunnuz> my teacher just typed a command on ghci
08:49:28 <EvilTerran> ?type read
08:49:30 <lambdabot> forall a. (Read a) => String -> a
08:49:32 <dons> tunnuz: are you just looking for :set +s ?
08:49:42 <dons> Prelude> :set +s
08:49:42 <dons> Prelude> 1+2
08:49:42 <dons> 3
08:49:43 <dons> (0.02 secs, 4953712 bytes)
08:49:46 <ari> > (read "3.32") :: Float
08:49:48 <lambdabot>  3.32
08:50:05 <ari> :t read
08:50:07 <EvilTerran> Notrix, read can't work out what type to produce based on the string, only on the return type
08:50:07 <lambdabot> forall a. (Read a) => String -> a
08:50:28 <swiert> matthew_-: you're right. that's a bit confusing.
08:50:31 <EvilTerran> because the string might vary at runtime, and the type's gotta be resolved at compile-time
08:50:38 <Notrix> oh right
08:50:47 <Notrix> so i have to add :: Float for converting into float
08:50:56 <EvilTerran> if it can't work it out from context, yeah
08:51:20 <EvilTerran> > read "12.3" + sqrt 2
08:51:22 <lambdabot>  13.714213562373097
08:51:31 <Notrix> ok I see :)
08:51:34 <Notrix> thank you very much
08:51:46 <b_jonas> > read "12.3" + 2
08:51:47 <lambdabot>  Exception: Prelude.read: no parse
08:51:55 <EvilTerran> no probs
08:52:40 <EvilTerran> btw, the reason why the error is "no parse" instead of "i don't know what type this is" is that things tend to default to Int
08:54:03 <dons> this is very interesting: http://www.langpop.com/
08:54:11 <shapr> EvilTerran: I'd guess that read defaults to Int, and the Int parser just fails instead of falling back to the Float parser.
08:54:18 <dons> we need to diversify! why is there so much haskell on reddit and ltu, and none on slashdot...
08:54:27 <matthew_-> standards?
08:54:30 <matthew_-> self respect?
08:55:01 <EvilTerran> shapr, yeah, that's what i meant
08:55:01 <dons> the yahoo rankings, first graph, mirror the tiobe index.
08:55:08 <dons> but i prefer ltu's rankings :)
08:55:17 <thetallguy> MyCatSchemes: interesting handle you've got
08:56:18 <chessguy> dons, at least we beat OCaml :)
08:56:44 <swiert> why is lisp so popular?
08:57:09 <chessguy> swiert, for most people, lisp is the first thing that comes to mind when you mention functional programming
08:57:16 <thetallguy> swiert: 'cause it has many of the benefits of FP and it's easy to learn
08:57:18 <dons> swiert: usa bias, and reddit previously being written in lisp
08:57:36 <thetallguy> swiert: also, people love what they've struggled through hell with.
08:57:52 <ari> dons: All the slashdotters are still thinking in perl
08:58:02 <dons> yep
08:58:11 <matthew_-> slashdotters think?
08:58:17 <thetallguy> ari: you can't actually think in perl
08:58:18 <dons> the 'normalised discussion' values at the end are useful
08:58:21 <ari> dons: I think we should allow them to at least get to Ruby before introducing Haskell :p
08:58:32 <Vq^> matthew_-: it's still a theory
08:58:48 <matthew_-> Vq^: no soundness proof will ever be forthcoming ;)
08:58:50 <swiert> Lisp even beats Haskell by a mile on slashdot...
08:59:07 <chessguy> i'm not sure including 'C' in a search term is very fair
08:59:24 <chessguy> it depends on the search algorithm, but i could see it winding up just searching for the letter c
08:59:27 <ac> swiert: Lisp has been around for a long time
08:59:29 <matthew_-> or c#
08:59:29 <thetallguy> That's a good graph.   I'm surprised we beat cobol
08:59:38 <joed> I think the lisp more is inferred knowledge from Eric S. Raymonds how to be a hacker article
08:59:42 <thetallguy> and I'm surprised that lisp is only 3x
08:59:45 <swiert> It be interesting to see what the normalized discussion would be without taking slashdot into account.
09:00:52 <dons> also relevant is tiobe's google index, http://www.tiobe.com/tpci.htm
09:00:54 <lambdabot> Title: TPCI - TIOBE Programming Community Index
09:01:02 <dons> where we doubled our % of hits this month, climbing 2 places
09:01:08 <swiert> chessguy: Yeah. It seems like C is pretty common on lambda the ultimate.
09:01:23 <ac> It's my uninformed opinion that even though haskell's been around for over a decade, it's only recently started to compete with common lisp on a practicality level
09:01:24 <dons> you can predict the rankings by googling for "haskell programming" before the end of the month, and seeing if it is up or down on today's value :)
09:01:24 <swiert> but that might be people talking about categories instead of programming languages ;)
09:01:34 <chessguy> swiert, yeah, but most mentions are probably "well, at least it's not C!"
09:01:37 <dons> ac, seems reasonable.
09:01:57 <dons> though common lisp seems dauntingly impractical :) where's there darcs/xmonad/pugs? :)
09:02:04 <b_jonas> that sounds like C++
09:02:24 <thetallguy> dons: don't knock it, they had whole machines
09:02:31 <glguy> needed
09:02:32 <dons> they did!
09:02:35 <ac> dons: there's stuff like maxima
09:02:38 <dons> back when spj was using S and K spoons
09:03:01 <thetallguy> dons: appartently it was amusing to redefine the global atom for T
09:03:12 <swiert> ac: I don't mean to put lisp down at all. I was quite surprised they were so popular (mainly on reddit).
09:03:30 <dons> i've a theory lisp's rise and fall held back FP for 15 years or so
09:03:41 <b_jonas> dons: what about google trends: http://www.google.com/trends?q=java%2C+c%2C+haskell
09:03:41 <ac> dons: and there's Stump (supposedly a tiling window manager written entirely in common lisp, which I've never heard of until 20 seconds ago)
09:03:42 <lambdabot> Title: Google Trends: java, c, haskell
09:03:47 <thetallguy> dons: interesting
09:04:04 <dons> b_jonas: oh, can't really use google trends, since haskell collides with a football team
09:04:13 <jjore-w> I was reading an old ACM paper "Dataflow Machine Architecture" the other day and was pleasantly surprised to find precursors to Haskell and Erlang in there but implemented as hardware. It was neat.
09:04:17 <thetallguy> ouch
09:04:17 <dons> well, you can get some sense, i guess
09:04:33 <thetallguy> jjore-w: is that by arvind?
09:05:03 <ac> swiert: I wasn't trying to defend lisp at all, but I was surprised you'd expect Haskell to already be more popular
09:05:08 <salierix> How much have the hits to haskell.org been growing?
09:05:09 <chessguy> dons, b_jonas, why does haskell show as a flatline on google trends? that's odd
09:05:13 <dons> ac, yes, that's a good point.
09:05:20 <osfameron> most of the google hits for haskell in that seem to be relating to a baseball player of that name...
09:05:26 <b_jonas> chessguy: because people search for java and c much more, it's almost 0
09:05:45 <b_jonas> chessguy: try just http://www.google.com/trends?q=+haskell&ctab=0&geo=all&date=all&sort=0
09:05:46 <jjore-w> thetallguy: no, http://portal.acm.org/citation.cfm?id=28055&coll=ACM&dl=ACM&CFID=41849647&CFTOKEN=35567064 is Veen.
09:05:47 <lambdabot> Title: Google Trends: haskell, http://tinyurl.com/25vg2h
09:05:49 <lambdabot> Title: Dataflow machine architecture, http://tinyurl.com/29g6jl
09:05:59 <dons> salierix: we don't have those numbers at hand
09:06:02 <salierix> "haskell" is surprisingly common on Google news.
09:06:08 <swiert> ac: fair enough. Maybe I'm just surrounded by Haskell programmers ;)
09:06:13 <chessguy> interesting
09:06:34 <ac> swiert: yeah, surely it won't be much longer :)
09:06:37 <chessguy> perhaps this is more appropriate, given the football team dons pointed out: http://www.google.com/trends?q=+haskell+-ball&ctab=0&geo=all&date=all&sort=0
09:06:39 <lambdabot> Title: Google Trends: haskell -ball, http://tinyurl.com/37jtuh
09:07:04 <thetallguy> jjore-w: thanks.  I see he cites arvind.  I don't remember that paper.
09:07:39 <ac> swiert: on the other hand though, look at Scheme... since when has that surpassed common lisp? On the gripphand hand though, Haskell seems to be accelerating
09:07:51 <ac> *gripping hand
09:08:11 <shapr> ac: Mote in God's Eye?
09:08:14 <jjore-w> I read the paper because I like Oz's capabilities and was vaguely interested in taking a go at trying them out in the Parrot VM.
09:08:42 <dons> I think we could do more to get stories from reddit/ltu onto slashdot
09:08:43 <swiert> ac: Yep. Haskell really is starting to cause a buzz.
09:08:51 <ac> shapr: yep
09:08:55 <dons> that's an obvious thing. anyone use slashdot enough to submit stories?
09:08:56 <swiert> dons: Slashdot is pretty hard to get stories onto...
09:09:05 <salierix> http://www.google.com/trends?q=haskell%2Clisp&ctab=0&geo=all&date=all&sort=0
09:09:07 <lambdabot> Title: Google Trends: haskell,lisp, http://tinyurl.com/2gkeqr
09:09:09 <dons> since we do as a community produce a lot of interesting things -- some would have to make it across the divide
09:09:17 <swiert> I remember the ICFP programming team having trouble to get a story about the contest on...
09:09:25 <dons> :(
09:09:59 <shapr> salierix: On the downside, that also includes Haskell Indian Nations and various counties, cities, and people named Haskell.
09:10:04 <dons> also, it points that our dominance of programming.reddit.com isn't yet complete
09:10:05 <dons> :)
09:10:16 <dons> nor on LtU! our homeground.
09:10:29 <shapr> Conversely, lisp includes speech impediments, so I guess it's roughly fair.
09:10:45 <ricky_clarkson> Many languages are hard to compare using non-semantic search.
09:10:46 <dons> we could lift our freshmeat score by importing hackage to freshmeat
09:10:47 <shapr> dons: I used to post lots to LtU, but some users there really get on my nerves.
09:10:53 <ricky_clarkson> Clearly the web needs static typing.
09:10:57 <dons> so people searching for code come across the haskell solutions more often
09:11:17 <ac> dons: how are you getting statistics attached to domains?
09:11:28 <salierix> http://www.google.com/trends?q=haskell%2CC%2B%2B
09:11:29 <lambdabot> Title: Google Trends: haskell,C++
09:11:31 <dons> dcoutts, Igloo: does that make sense? import more src into freshmeat as a means of ensuring people know about haskell solutions to their problems?
09:11:40 <dons> amazon, hmm, we'll have to write more books.
09:11:40 <thetallguy> http://www.alexa.com/data/details/traffic_details?site0=haskell.org&site1=common-lisp.net&y=r&z=3&h=300&w=610&range=3y&size=Medium&url=flashgot.net
09:11:42 <lambdabot> Title: Traffic Details for: flashgot.net/, http://tinyurl.com/2xtkk2
09:12:32 <dons> also, everyone add the phrase "haskell programming" to their blogs and email, since that's what tiobe's ranking phrase is.
09:12:44 <shapr> Ah, cool
09:12:45 <dons> ?google site:unsw.edu.au haskell programming
09:12:46 <lambdabot> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16
09:12:47 <lambdabot> Title: Haskell hacking
09:12:47 <thetallguy> dons: good to know
09:12:48 <dons> ;)
09:12:55 <dcoutts> dons: I'm not sure that freshmeat is terribly relevant is it?
09:12:57 * shapr quickly adds an lj post about haskell programming
09:13:09 <dcoutts> dons: maybe that's just because I never use it :-)
09:13:11 <dons> dcoutts: well, i did note a little flurry of hits around the ghc release on freshmeat
09:13:23 <dcoutts> but does anyone read them?
09:13:27 <dons> but we actually get more coverage i think from getting apps into debian and other big distros
09:13:35 <shapr> I agree.
09:13:39 <shapr> xmonad is in debian/unstable! yay!
09:13:43 <dons> it is!
09:13:46 <shapr> nomeata++
09:13:46 <dons> and we got some reviews
09:13:51 <shapr> @karma nomeata
09:13:51 <lambdabot> nomeata has a karma of 2
09:13:57 <dons> http://blog.harnir.net/2007/11/05/review-xmonad-window-manager/
09:13:58 <lambdabot> Title: Text mode heaven ª Review: xmonad window manager
09:14:03 * dcoutts notes that the gentoo, fedora & debian teams are currently hard at work packaging ghc-6.8.1
09:14:06 <dons> yeah, joachim's work from the hackathon.
09:14:09 <quicksilver> the total possible market for a good programming language is pretty small
09:14:19 <quicksilver> simply because most people aren't programmers
09:14:25 <thetallguy> dcoutts: and we appreciate that effort
09:14:26 <salierix> dons, were you searching for xmonad on google blog search? ;)
09:14:28 <quicksilver> and many programmers are 'casual php hacker' type programmers
09:14:32 <dons> salierix: yes.
09:14:37 <shapr> quicksilver: What about excel, etc?
09:14:37 <dons> i have an rss feed actually
09:14:45 <osfameron> @index second
09:14:45 <lambdabot> Control.Arrow
09:14:51 <quicksilver> shapr: right. but people learn excel piecemeal, and only by necessity
09:15:01 <thetallguy> dcoutts: I offered to help igloo, but he thinks he can get it done faster by himself.  Probably right.
09:15:03 <shapr> But if Haskell became the scripting language for excel...
09:15:04 <quicksilver> shapr: like, they may use no functions at all for their first year. then they learn SUM().
09:15:07 <dons> salierix: most of the world i suck through rss these days
09:15:14 <quicksilver> shapr: and then SUM() is the only thing they use for anothe three years.
09:15:25 <quicksilver> shapr: takes a long time to become a programmer at that rate :)
09:15:39 <dcoutts> dons: if the hackage rss feed had more info do you think we could get it syndicated where more people would read it?
09:15:40 <salierix> I still find haskell hard to use...
09:15:40 <thetallguy> dcoutts: would be nice to keep those up to date, though.  We hope to run our autobuilder on ghc head and make an archive for it publicly available.
09:15:47 <shapr> quicksilver: Still, some people learn it.
09:15:57 <thetallguy> salierix: it takes time
09:16:32 <dcoutts> dons: btw, since releases are such good publicity, I think we should propose a haskell toolchain packaging project
09:16:43 <dons> dcoutts: great idea
09:17:10 <dcoutts> dons: it'd be a project to manage unified haskell toolchain releases, ie ghc + tools, standard useful libs
09:17:13 <salierix> I think we need a book about how to use haskell in practice. Using haskell in the real world as it were. ;)
09:17:15 <dons> the rss feeds we really could improve, and syndicate to say, planet.
09:17:28 <dons> salierix: sounds like a great idea.
09:17:42 <dcoutts> dons: and tested together on several arches, it should define the standard platform that we expect people to package for their distros
09:17:43 * dylan_ wishes he had a haskell job
09:18:19 <quicksilver> if Yi is successful that will increase haskell's market, I suspect
09:18:29 <salierix> Yi?
09:18:32 <quicksilver> that makes it all the more important that Yi's scripting interface turns out not too ugly :)
09:18:34 <dcoutts> dons: it'd be managed on top of hackage, along with buildbots etc
09:18:36 <dylan> people can't write such horrible code in haskell.
09:18:38 <quicksilver> salierix: a haskell editor
09:18:42 <quicksilver> @go haskell yi
09:18:44 <lambdabot> http://haskell.org/haskellwiki/Yi
09:18:44 <lambdabot> Title: Yi - HaskellWiki
09:19:39 <thetallguy> dylan: you can write horrible code in any language
09:20:00 <dylan> I doubt a haskell programmer would write functions that have no return value and instead set 10 or so globals
09:20:29 <dylan> especially in a language where multiple return values are possible...
09:21:05 <dons> mm. maybe it is time to set up success@haskell.org ...
09:21:15 <thetallguy> dylan: there are constructs that are equally as hard to understand.
09:21:16 <dylan> cccheck_expired($ccnumber); if ($CCexpired) { ... }
09:21:33 <thetallguy> dylan: but they are easier to fix in Haskell...
09:21:42 <MyCatSchemes> thetallguy: danke. I usually just waste it by passing it to hGetContents, though.
09:21:43 <dylan> this is really hard to fix.
09:21:50 <dons> dcoutts: yes, i think the standard haskell platform idea is strong.
09:22:03 <dons> there's a toolchain and lib set that should be ubiquitous
09:22:11 * dons `ap` work. bbl
09:22:36 <dcoutts> dons: right, and each release specifies a set of versions of the components that are known to work together, like gnome, or a distro
09:23:11 <swiert> I love this desktop: http://www.haskell.edu/athletics/wallpaper/football_800x600jpg.jpg
09:23:14 <lambdabot> http://tinyurl.com/2ax28j
09:23:20 <swiert> We should invite these guys to the next ICFP.
09:23:24 <daniel_larsson> dcoutts: does hackage have enough information to build rpm/deb/... packages, or are distros too dissimilar for that?
09:24:15 <dcoutts> daniel_larsson: that's probably not the right approach, however people have made tools to build distro packages from cabal packages, but then those packages are managed via the distro rather than via hackage
09:24:48 <dcoutts> hackage should not provide distro packages, the distro should do that
09:25:12 <daniel_larsson> dcoutts: yes, sounds reasonable
09:25:59 <quicksilver> dylan: I think it's true that haskell, overall, does more to discourage foolish practice.
09:26:21 <quicksilver> dylan: however one can imagine similarly hideous code which is a function in some monad which alters 10 internal monad state things
09:26:25 <quicksilver> dylan: and returns nothing
09:26:26 <dylan> quicksilver: haskell code is easier to throw away,too
09:26:51 <daniel_larsson> Though, there's always those hackage packages that won't make it into distros. I guess package building from hackage should be boilerplate
09:28:06 <salierix> So far I've found that haskell seems to force you to really think about each line.
09:28:12 <notsmack> www.haskell.org is downish?
09:28:30 <salierix> Not anymore.
09:28:39 <Spark> if you've been writing programs without thinking about each line then i fear for your job
09:29:57 <salierix> Spark, haskell is very information dense.
09:31:37 <shapr> Spark: Yeah, I agree with salierix. When I was first on #haskell, I asked Heffalump to explain a twenty page Haskell program to me. Since twenty pages of Python would only take ten minutes or so to understand, I didn't know why Heffalump was somewhat dismissive :-)
09:32:53 <shapr> Python requires a lot more boilerplate code than Haskell.
09:34:17 <quicksilver> haskell has almost unparallelled ability to abstract repeated typing
09:34:34 <quicksilver> the only other languages which can do better are those which are really text macro languages
09:34:38 <quicksilver> like web and tex
09:34:48 <quicksilver> which is even better because it can abstract *all* repetition
09:34:52 <quicksilver> but they have some problems of their own :)
09:35:10 <newsham> gzip is pretty good at abstracting repeated typing
09:35:23 <osfameron> heh
09:35:25 <ricky_clarkson> quicksilver: How 'bout lisp?
09:35:54 <salierix> I'm not saying it.
09:36:03 <ac> newsham: yeah, I actually write gzipped code with a hex editor
09:36:10 <quicksilver> ricky_clarkson: lisp + macros, definitely
09:36:14 <ac> newsham: saves my RSI
09:36:17 <newsham> do you draw the tree out on the whiteboard first?
09:36:19 <quicksilver> ricky_clarkson: lisp + macros is almost a text macro language
09:36:22 <newsham> or do you just start typing?
09:36:33 <quicksilver> ricky_clarkson: lisp without macros is no better than haskell, I think
09:36:37 <quicksilver> (and worse in other ways)
09:36:38 <ricky_clarkson> More of an ast language.
09:36:43 <quicksilver> yeah
09:36:43 <quicksilver> true
09:36:53 <quicksilver> but with a pretty generic flexible ast
09:37:08 <salierix> Don't lisp macros make it harder to read code?
09:37:10 <newsham> tree preprocessor
09:37:19 <mauke> reader macros.
09:37:30 <Saizan_> but you can't have type hackery in lisp..
09:37:47 <quicksilver> salierix: they do indeed, yes. That is one of the "problems of their own" I was referring to.
09:37:54 <ricky_clarkson> salierix: You could say that about any abstraction, and be wrong or right depending on the use.
09:38:05 <quicksilver> salierix: on the other hand some haskell abstraction patterns make harder to read code too :)
09:38:08 <quicksilver> until you understand them
09:38:10 <ricky_clarkson> See, foldl is hard to read, should just write loops in assembler!
09:38:22 <quicksilver> but I like to think that the type system imposes a much-needed regularity
09:38:28 <quicksilver> certainly it helps me a lot
09:38:29 <newsham> "any sufficiently powerful construct can make your code harder to read"
09:38:41 <quicksilver> quite
09:39:29 <newsham> didnt goedle say that or something?
09:39:43 <quicksilver> ;)
09:39:47 <quicksilver> something a bit like that, yes
09:40:09 <ricky_clarkson> Saizan_: You can have type hackery in lisp, you have a turing-complete macro-expansion stage to mess with.
09:40:12 <ac> ricky_clarkson: you're obviously being facetious, but I'll state anyway that once you know what foldl does, it's easier to read than a recursive function
09:40:14 <luqui> Sometimes in ghci (6.8.1) when I type an infinite loop I can't Ctrl-C out of it
09:40:17 <ricky_clarkson> ..it's just not trying to help you.
09:40:24 <luqui> filter (const False) [1..]
09:40:28 <luqui> <Ctrl-C>
09:40:31 <Saizan_> ricky_clarkson: but i've to implement prolog myself!
09:40:34 <luqui> <interactive>: exception :: GhcException
09:40:38 <luqui> and then it just hangs
09:40:47 <luqui> I have to ctrl-z and kill...  what's up with this?
09:41:44 <ricky_clarkson> ac: Thanks, you just showed my point.  Macros don't make code harder to read, unless you write bad ones or don't understand the macro.
09:41:49 <quicksilver> ac: I think ricky_clarkson was making a rhetorical point, which is that any kind of abstraction is unclear until you know what it means.
09:42:05 <salierix> luqui, it seems to work fine for me.
09:42:06 <quicksilver> ac: I.e. mapM is pretty obscure, until you know what it does. Once you know what it does, it's better than writing it out longhand ;)
09:42:22 <luqui> salierix, hmm...
09:42:31 <salierix> luqui, Windows?
09:42:41 <luqui> nope, linux
09:42:50 <salierix> Hm, me too.
09:42:51 <luqui> latest from portage overlay...
09:42:55 <ac> ricky_clarkson: yeah, I was just stating the point I thought you were trying to make
09:43:24 <ricky_clarkson> Heh.
09:43:50 <salierix> What does mapM do again? ;)
09:44:03 <newsham> the more powerful the abstraction, the more unclear it is until you understand it :)
09:44:05 <quicksilver> runs a bunch of monadic actions, and collects the results in a list
09:44:16 <luqui> mapM print ["I", "like", "bagels"]
09:44:28 <quicksilver> that's a funny use
09:44:33 <quicksilver> cos the results you collect won't be interesting :)
09:44:34 <newsham> mapM_ ?
09:44:34 <luqui> (probably mapM_ in that case...)
09:44:36 <ac> salierix: then there's also the convenient mapM_ which discards the results
09:44:38 <quicksilver> they'll be [(),(),()]
09:44:40 <quicksilver> but that's the idea
09:44:48 <salierix> I get it.
09:45:12 <quicksilver> mapM (\q -> putStrLn q >> getLine) ["Name","Sex","Age"]
09:45:20 <quicksilver> ask each of three questions, get an answer
09:45:23 <quicksilver> collect answers into a list
09:45:32 <newsham> forM_ ["I", "Like", "Bagels"] (\x -> print x)
09:45:45 <newsham> for x in ["I", "Like", "Bagels"] : print x
09:46:03 <shapr> @remember newsham Newsham's Law: the more powerful the abstraction, the more unclear it is until you understand it :)
09:46:03 <lambdabot> Good to know.
09:46:13 <shapr> @quote newsham
09:46:13 <lambdabot> newsham says: there are Just 1 types of people, Nothing and those who understand monads
09:46:19 * shapr laughs
09:47:31 <salierix> Speaking of which, just who's idea was lambdacats?
09:47:54 <luqui> the naturality of the Maybe constructors has allowed for many jokes...
09:48:02 <ricky_clarkson> @quote Either
09:48:02 <lambdabot> kyevan says: I haven't tried learning C++, from what I've seen, simple c++ is readable pretty easily, complex C++ makes me want to hide in the closet.  (I'm not refering to my sexuality, either)
09:48:49 <ricky_clarkson> Ah, that must be the guy who write the HTTP (referer) spec!
09:49:00 <ricky_clarkson> wrote
09:49:25 <Lycurgus> RFC are comitte written mostly
09:50:28 <quicksilver> I'm not sure that's true. I think the RFCs are mostly written by 1-3 people. Sometimes committees will refine/discuss/update/republish them though.
09:50:42 <quicksilver> certainly they mostly only have a small number of named authors.
09:52:00 <Lycurgus> yes it's the committee invovlement that breaks the clarity sole authorship would engender
09:52:06 <luqui> lazy bitestring is the best...
09:52:19 <ac> luqui: yeah that one made me laugh
09:53:22 <salierix> What would be a simple project for a haskell newbie like myself?
09:53:22 <quicksilver> whole-program-optimising partial-evaluating haskell-compiler?
09:54:07 <Lycurgus> salerix: he's kidding
09:55:00 <newsham> what are your interests?
09:55:02 <quicksilver> salierix: I would say, work on something you find fun
09:55:07 <quicksilver> salierix: cos that's most motivating
09:55:18 <quicksilver> salierix: I enjoy playing with opengl, for example. Nice visible results.
09:56:08 <salierix> I'll find something I guess.
09:56:11 <newsham> write a tiny web server? write a program to generate fractal images?  write a program to guess an item with 20 quesitons?
09:56:25 <quicksilver> simple chat protocol?
09:56:41 <newsham> write a filesystem using delimited continuations?
09:56:48 <quicksilver> ;)
09:57:04 <Raguel> what does that netsplit mean?
09:57:07 <sw17ch> salierix: i'm working on a language analysis program =)
09:57:21 <newsham> raguel: there are multiple chat servers on irc.  sometimes they lose connection with each other
09:57:21 <Tobsan> Raguel: that's when servers lose connection between each other
09:57:32 <Tobsan> ah, newsham was faster
09:57:32 <newsham> so the chat network becomes partitioned and then later comes back together again
09:57:32 <shapr> Raguel: We each connect to an IRC server, and the IRC servers connect to each other. Sometimes the servers lose connection to each other.
09:57:35 <shapr> bah
09:57:41 <Tobsan> xD
09:57:45 <quicksilver> @quote stereo
09:57:45 <lambdabot> stereo says: The stereo quote is bad and you should *feel* bad.  This has been a public service announcement.
09:57:49 <quicksilver> :(
09:57:51 <shapr> @quote stereo
09:57:51 <lambdabot> stereo says: The stereo quote is bad and you should *feel* bad.  This has been a public service announcement.
09:57:58 <shapr> @quote 'in stereo'
09:57:58 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
09:58:00 <shapr> bah
09:58:06 <quicksilver> why is the stereo quote bad?
09:58:17 <shapr> I don't know.
09:58:19 <quicksilver> I disagree. It was entirely appropriate.
09:58:19 <quicksilver> and very true.
09:58:20 <Olathe> No one knows.
09:58:27 <quicksilver> and a genuine quotation, at that.
09:58:57 <newsham> stereo quotes allow logical inconsitencies into the system
09:59:53 <Raguel> hmmm
09:59:59 <ac> salierix: I'm going to write a web forum using HAppS, and give an honest attempt at pushing Bram's law
10:00:13 <Raguel> "never let fear stop you from doing anything without the credible risk of permenant injury"
10:00:52 <Saizan_> ?google Bram's law
10:00:54 <lambdabot> http://www.advogato.org/person/Bram/diary.html?start=68
10:00:54 <lambdabot> Title: Advogato: Blog for Bram
10:00:55 <ac> Raguel: sometimes you can missjudge the "credible risk" part. That's what fear is good for
10:01:17 <Raguel> a slight improvement on "you have nothing to fear but fear itself" cos i'm mortified by the idea of being stuck in a wheelchair or worse braindamaged
10:01:44 <quicksilver> @quote stereo!
10:01:44 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
10:01:49 <Raguel> well if its like "this could be fun if this all goes tits up i'm gonna end up looking like an idiot" isn't credible risk of injury
10:01:52 <quicksilver> that's bizarre
10:01:52 <newsham> if you're stuck in a wheel chair you'll probably have more haskell time.
10:01:56 <quicksilver> why C-a-l-e ?
10:02:05 <newsham> if you're braindamaged, you'll be too happy to know the difference
10:02:14 <quicksilver> cale hacked something in to stop himself getting highlighted?
10:02:18 <quicksilver> @quote newsham
10:02:18 <lambdabot> newsham says: there are Just 1 types of people, Nothing and those who understand monads
10:02:23 <quicksilver> @quote quicksilver
10:02:23 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
10:02:26 * quicksilver shrugs
10:02:38 <byorgey> the real C-a-l-e didn't like it when the IRC window kept flashing when people quoted @stereo all the time =)
10:02:42 <ac> quicksilver: it was masked during a long discussion about wether the quote should be removed entirely
10:02:57 <Raguel> yeah i'm more worried about braindamaged - imagine sitting in front of a computer and realising that things that came naturally to you were almost impossible like calculating the square root of 16 or writing a simple program
10:03:16 <Raguel> and KNOWING that you could do it before
10:03:17 <newsham> imagine the joy of watching the flashing lights
10:03:29 <newsham> ignorance is bliss.
10:03:36 <Excedrin> mmmm flashing lights
10:04:06 <Raguel> unfortunatly learning beautiful methods then becoming unable to do what you learned isn't ignorance, its torture
10:05:00 <newsham> other things you would be ignorant of besides the square root of 16: gwb, petrodollars, iran, deadlines, the line between social acceptance and inappropriate behavior, what your wife told you to do 3 minutes ago, ...
10:05:48 <Raguel> well it would be like losing your eyes - you know what its like to see, and know you'll never be able to again
10:06:07 <Raguel> and brain damage doesn't make you ignorant, it would be like the ultimate writer's block
10:06:22 <ac> newsham: some brain deficits can be remarkably specific
10:06:36 <puusorsa> tourette for teh win
10:07:18 <ac> it totally depends on the type of damage. For practically every mental ilness, it seems there is a varient of it that leaves the sufferer ignorant of the actual condition
10:07:53 <newsham> you say frontal lobotomy I say bottle in fronta me..
10:07:57 <newsham> potato potahtoe
10:07:59 <wli> Raguel: Stop describing my programming career.
10:08:33 <ac> *illness, variant
10:08:55 <Raguel> but suddenly aquiring one and knowing what its like NOT to have one!
10:09:16 <ac> Raguel: yeah that would be terrible
10:10:14 <Raguel> so thats about all i fear
10:10:24 <ac> and the thing is, I'd choose to be able to comprehend what's wrong over not, because then there's at least a chance of relearning
10:10:41 <Raguel> not if you've got a chunk of you're head missing ;)
10:10:51 <newsham> i fear my country is being hijacked.. but I guess thats for another channel
10:12:22 <Raguel> haha - you're american :P
10:13:50 <joelr1> folks, what's ":$" in the following? data HTypeTerm = Con String | HTypeTerm :$ HTypeTerm | Var String
10:14:03 <int-e> an infix data constructor
10:14:06 <ddarius> joelr1: An infix constructor
10:14:19 <joelr1> int-e, ddarius: what's that?
10:14:33 <ddarius> joelr1: The same thing as a normal constructor, just infix.
10:14:40 <ddarius> I.e. the same thing as Con or Var
10:14:43 <int-e> it's a constructor (like Con and Var) with two arguments, written as an infix operator.
10:15:06 <joelr1> but it only takes 1 argument, no?
10:15:16 <daniel_larsson> 2 HTypeTerms
10:15:20 <int-e> infix operators starting with : are treated similarily to identifiers starting with capital letters.
10:16:02 <joelr1> so how do you write out the construction of HTypeTerm?
10:16:05 <daniel_larsson> joelr1: "HTypeTerm :$ HTypeTerm" is the definition
10:16:11 <joelr1> foo :$ bar?
10:16:34 <int-e> yes. Con "foo" :$ Con "bar"
10:16:48 <Raguel> fubar?
10:17:05 <joelr1> i see...
10:17:32 <newsham> joel: colon is a capital punctuation.
10:17:57 <newsham> so you can use it for constructors (infix) just like you use lowercase punctuation for infix functions
10:18:11 <joelr1> so, basically, a type term is a con or a var or either on both sides of :$... wierd
10:18:25 <newsham> joel: here's one you already know:   (:)
10:18:29 <newsham> > 1 : 2 : 3 : []
10:18:31 <lambdabot>  [1,2,3]
10:18:36 <mauke> a type term is a con or a var or a :$
10:18:44 <joelr1> newsham: right, (:)
10:19:19 <joelr1> mauke: so having used :$ for the type term i can't use it as a constructor of another type, right?
10:19:27 <ac> so (:) is both a capital, and a lowercase constructor?
10:19:33 <mauke> right
10:19:36 <ddarius> ac:; ?
10:19:39 <mauke> unless it's in a different module
10:19:40 <joelr1> fair enough
10:19:44 <nominolo> @pl \ c -> c <*> bla <*> blub
10:19:44 <lambdabot> (<*> blub) . (<*> bla)
10:19:45 <newsham> ac: why both?
10:19:45 <mauke> ac: there are no lowercase constructors
10:20:07 <nominolo> @pl \ c -> c <$> bla <*> blub
10:20:07 <lambdabot> (<*> blub) . (<$> bla)
10:20:11 <ac> mauke: guess I meant function
10:20:33 <mauke> uppercase = constant, lowercase = variable
10:20:33 <nominolo> @pl \ c -> (c <$> bla) <*> blub
10:20:34 <lambdabot> (<*> blub) . (<$> bla)
10:21:00 * ddarius doesn't get what is surprising/difficult/wierd about this.
10:23:56 <ac> newsham: you said a colon was capital punctuation, but "1 : []" is a function application, right?
10:24:37 <newsham> no, colon is the cons constructor
10:24:37 <ddarius> ac: As is Just 3
10:24:56 <newsham> data [] a = [] | a : ([] a)
10:24:58 <newsham> kinda sorta
10:25:21 <mauke> ac: constructors that take arguments are functions
10:25:41 <newsham> yah, sorry, perhaps I should say "constructor-function"
10:25:43 <ddarius> :t Just
10:25:47 <ddarius> :t (:)
10:25:51 <ddarius> newsham: No you shouldn't.
10:25:52 <lambdabot> forall a. a -> Maybe a
10:25:53 <lambdabot> forall a. a -> [a] -> [a]
10:26:44 <ac> just ignore me, I'm a little tired
10:27:00 <newsham> s'ok, i'm always a little tired (or at least thats my excuse)
10:27:10 <exDM69> I wrote my first bigger piece of Haskell yesterday. It's an algorithm related to a card game. Now I have a hard time figuring out where to go next, how to make a game loop. any suggestions?
10:27:33 <Olathe> What is the loop supposed to do ?
10:28:11 <exDM69> what a card game usually does :)
10:28:27 <exDM69> each player takes a turn, plays some cards, takes some
10:28:43 <Olathe> OK, can you write a function that does one iteration ?
10:28:47 <newsham> gameLoop = player >>= machine >>= gameLoop   ?
10:28:57 <ddarius> >> gameLoop
10:29:20 <Olathe> >> destroys information.
10:29:32 <newsham> yah I prob forgot a state arg of some sort
10:29:40 <exDM69> I have some trouble figuring out how to store state
10:29:41 <ddarius> Olathe: gameLoop doesn't take an argument.
10:29:52 <Olathe> Ahh.
10:29:53 <newsham> my pseudo code doesnt type check.
10:29:56 <Olathe> Never mind.
10:30:01 <newsham> ddarius would make a great front end
10:30:12 <ddarius> Maybe if gameLoop was in a class...
10:30:29 <exDM69> my solution would look pretty much like the YAHT's "RealWorld solution". (realWorld', result) = function realWorld
10:30:31 <ac> exDM69: Perhaps you could store state in a record, and simply pass that to gameLoop?
10:30:33 <Raguel> question: would you rather hang around somewhere that makes you smarter but makes you feel dumb or hang somewhere that makes you dumber but makes you feel smart?
10:30:50 <ddarius> Raguel: You tell me.
10:30:51 <ac> exDM69: game loop would then make some IO calls, construct a new record, and recurse
10:30:52 <exDM69> ac: what's a record?
10:31:06 <ac> exDM69: named tupple, esentially
10:31:43 <ac> *essentially
10:31:48 <ddarius> and *tuple
10:31:53 <newsham> gameLoop st = player st >>= machine >>= gameLoop
10:32:17 <ddarius> let f @@ g = \x -> g x >>= f
10:32:20 <Raguel> ddarius: everyone has their own truth and their own answer
10:32:26 <ac> exDM69: but don't pay attention to me, because everyone else here will give better advice
10:32:31 <ddarius> gameLoop = player @@ machine @@ gameLoop
10:33:13 <Olathe> @src (@@)
10:33:14 <lambdabot> Source not found. Take a stress pill and think things over.
10:33:18 <Olathe> @src :(
10:33:19 <lambdabot> Source not found. Are you on drugs?
10:33:27 <exDM69> I don't understand what's >>=
10:33:40 <exDM69> perhaps I'll do some more reading and then get back to it
10:33:42 <ibid> Olathe: was defined two lines earlier :)
10:34:26 <ddarius> Except it's backwards (well it's the right way, but I'm using it backwards)
10:34:46 <ddarius> It should be gameLoop = gameLoop @@ machine @@ player
10:34:47 <Olathe> >>= uses a function to transform the value in the monad somehow.
10:34:57 <ibid> exDM69: >>= is geek-speak for do (not used the same way, but they do roughly the same things)
10:35:15 <ddarius> @@ is Kleisli composition
10:35:15 <lambdabot>  is Kleisli composition
10:35:16 <Botje> ibid: "do" is a bit more pronouncable :)
10:35:24 <ddarius> Um... thank you lambdabot
10:35:24 <exDM69> thanks for the tips, do you have any recommended reading?
10:35:32 <ibid> Botje: yeah, and it causes semicolon cancer:)
10:35:48 <Botje> glad I don't have one of those :)
10:36:01 <exDM69> ibid: :D
10:36:09 <newsham> exDM69: perhaps the tutorial on writing an irc bot?
10:36:25 <exDM69> I could look it up
10:36:48 <ibid> exDM69: actually, do is syntactic sugar for >>= (hence the joke)
10:37:22 <newsham> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:37:24 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
10:37:39 <Olathe> Roll your own sushi bot.
10:37:45 <ac> so could someone tell me how what I described is equivalent to using >>=?
10:38:13 <Olathe> ac: What did you describe ?
10:38:37 <ac> starting out with an initialState record, passing it to gameLoop, and having gameLoop call itself with a modified state record
10:39:11 <ibid> ac: if gameLoop is pure, you don' need >>=
10:39:11 <newsham> hmm.. maybe the bot isnt the closest match..
10:39:31 <ac> ibid: I was assuming the new state record would depend on IO calls
10:40:02 <ibid> ac: but if not, gameLoop initialState = do nextState <- doStuff ; gameLoop nextState ought to work?
10:40:12 <ibid> ac: which is trivial to rewrite using >>= :)
10:40:47 <int-e> ac: if you have functions  player, machine :: MyState -> IO MyState, then gameLoop st = player st >>= machine >>= gameLoop   will pass the state through the loop.
10:40:56 <Olathe> @undo do nextState <- doStuff
10:40:56 <lambdabot>  Parse error at end of input
10:40:59 <newsham> ac:  when I said   gameLoop st = player st >>= machine >>= gameLoop    that is also passing around the initial state and modified state like you said
10:41:02 <Olathe> @undo do { nextState <- doStuff }
10:41:03 <lambdabot>  Parse error at "}" (column 27)
10:41:05 <Olathe> :(
10:41:12 <Olathe> I don't really use do notation at all.
10:41:39 <int-e> @undo do { nextState <- doStuff; loop nextState }
10:41:39 <lambdabot> doStuff >>= \ nextState -> loop nextState
10:42:00 <conal> or: gameLoop = player >=> machine >=> gameLoop
10:42:12 <newsham> gameLoop st = do {st' <- player st; st'' <- machine st; gameLoop st'' }
10:42:16 <newsham> is the do equivalent
10:42:17 <ibid> @type >=>
10:42:19 <lambdabot> parse error on input `>=>'
10:42:23 <ibid> @type (>=>)
10:42:25 <int-e> Olathe: ghc would say: "the last statement in a 'do' construct must be an expression"
10:42:25 <lambdabot> Not in scope: `>=>'
10:42:38 <conal> @type (Control.Monad.>=>)
10:42:40 <lambdabot> Not in scope: `Control.Monad.>=>'
10:42:45 <conal> mrph?
10:43:05 <ibid> @index (>=>)
10:43:05 <lambdabot> bzzt
10:43:09 <ibid> @index >=>
10:43:09 <lambdabot> bzzt
10:43:14 <ibid> h√∂
10:43:24 <conal> it's in 6.8.1
10:43:29 <conal> (>=>)       :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
10:43:33 <ibid> what does it do?
10:43:41 <conal> f >=> g     = \x -> f x >>= g
10:43:41 <ibid> ach
10:43:47 <ac> int-e: I see. Doesn't that assume the machine always goes second?
10:43:57 <int-e> ibid: the same as ddarius' @@
10:44:11 <int-e> ac: yes. it's a simplified example.
10:44:12 <Olathe> @src >>--> :(
10:44:13 <lambdabot> Source not found. Do you think like you type?
10:44:20 <ibid> int-e: no, ddarius' @@ flipped :)
10:44:29 <conal> oh -- i missed that part of the conversation.
10:44:40 <newsham> you could make the machine go first and then sometmes have the machine's first turn be a nop
10:44:40 <ac> int-e: cool, now I think I understand >>=, though I won't truely understand it until I use it a bunch
10:44:55 <ac> *truly
10:45:06 <int-e> ibid: oh. but it's how he used it: gameLoop = player @@ machine @@ gameLoop
10:45:21 <newsham> do { x <- act1; expr x }   is    act1 >>= \x -> expr x
10:45:26 <ibid> right
10:45:34 <ibid> i think he said something about flipping it :)
10:45:36 <Olathe> @undo x <- act1; expr x
10:45:37 <lambdabot>  Parse error at "<-" (column 3)
10:45:39 <ac> I'll save ">=>", "@@", and friends for a later date
10:45:41 <Olathe> @undo { x <- act1; expr x }
10:45:41 <lambdabot>  Parse error at "{" (column 1)
10:45:42 <newsham> do { a; b; c }  is   do { do {a;b}; c}
10:45:47 <Olathe> Damn you @undo !
10:45:50 <Olathe> @help undo
10:45:51 <lambdabot> undo <expr>
10:45:51 <lambdabot> Translate do notation to Monad operators.
10:45:58 <Olathe> @undo do { x <- act1; expr x }
10:45:58 <lambdabot> act1 >>= \ x -> expr x
10:46:14 <conal> or just act1 >>= expr
10:46:21 <ibid> @undo \x -> do { y <- x ; expr y }
10:46:21 <lambdabot> \ x -> x >>= \ y -> expr y
10:48:30 <Olathe> @redo me >>= funkytown
10:48:30 <lambdabot> do { a <- me; funkytown a}
10:49:20 <ac> exDM69: everything's crystal clear now, eh?
10:49:26 <newsham> ?pl (\a -> this a house)
10:49:26 <lambdabot> flip this house
10:49:40 <ibid> hah!
10:50:07 <exDM69> ac: yes, I know what to do next - read
10:50:07 <Olathe> Heheh
10:50:22 <ac> exDM69: ;)
10:51:13 <ac> sometimes Haskell reminds me of Perl
10:51:25 <newsham> > "3" + 5
10:51:33 <lambdabot>   add an instance declaration for (Num [Char])
10:51:33 <lambdabot>     In the expression: "3" + 5...
10:51:34 <ac> (I mean that in a good way, I suppose)
10:51:42 <newsham> *phew*  still not perl.
10:51:59 <byorgey> @. pl undo do { x <- act1; expr x }
10:52:00 <lambdabot> expr =<< act1
10:52:16 <ibid> newsham: that's just a instance Num [Char] away :)
10:52:33 <byorgey> "Haskell... not Perl... unless you want it to be!"
10:52:38 <Olathe> @. pl undo do { a <- me; funkytown a}
10:52:38 <lambdabot> funkytown =<< me
10:52:41 <Olathe> :(
10:52:48 <Olathe> Get the direction right, @pl !
10:52:49 <newsham> even if you make an instance of Num [Char], that "3"+5 is illegal.
10:52:52 <newsham> ?type (+)
10:52:54 <lambdabot> forall a. (Num a) => a -> a -> a
10:53:05 <newsham> [Char] != Int
10:53:11 <mauke> 5 :/: Int
10:53:27 <newsham> true.
10:53:36 <newsham> but I had intended it to be :)
10:53:44 <mauke> > 5 :: String
10:53:45 <lambdabot>   add an instance declaration for (Num String)
10:53:45 <lambdabot>     In the expression: 5
10:53:45 <lambdabot>     I...
10:53:52 <mauke> see? an instance is all you need
10:53:59 <newsham> in perl you can add "5" :: String with 3 :: Int
10:54:06 <newsham> and that is the expression I had inteded to write
10:55:45 <ac> :t (:/:)
10:55:47 <lambdabot> Not in scope: data constructor `:/:'
10:56:00 <newsham> i think he means  not-::
10:56:18 <ac> oh I see
11:03:59 <eDDDDDer> good evening ;)
11:04:29 <eDDDDDer> is there an easy way to define a function with two different lists? to reverse eg. [1,2,3] -> [3,2,1] ?
11:05:34 <Olathe> Where do two different lists come into reversing one list ?
11:07:04 <eDDDDDer> my first thought was to go thru the first list and fill the vars into the second
11:07:48 <Liskni_si> @src reverse
11:07:49 <lambdabot> reverse = foldl (flip (:)) []
11:07:53 <Liskni_si> oh.
11:07:58 <Olathe> eDDDDDer: Ahh.
11:08:28 <eDDDDDer> im pretty sure my tutor at university will rip my head off if i c&p this ;)
11:08:33 <Olathe> > let rev xs = rev' xs [] where rev' original result = ...
11:08:34 <lambdabot>  Parse error at "..." (column 54)
11:08:55 <Olathe> That sort of thing will allow you to use two lists to do a reverse.
11:09:06 <eDDDDDer> hm, okay
11:11:11 <Olathe> > let sum xs = sum' xs 0 where sum' [] result = result; sum' (x:xs) result = sum' xs (result + x) in sum [1..100]
11:11:13 <lambdabot>  5050
11:11:34 <Olathe> There's an example of using that sort of thing to solve a problem.
11:16:00 <phlpp> hi!
11:17:02 <hpaste>  Karle pasted "please explain this code for newbie" at http://hpaste.org/3695
11:18:57 <thetallguy> Karle, there are some types missing there
11:19:31 <thetallguy> do you have some specific questions?
11:19:38 <hpaste>  Karle annotated "please explain this code for newbie" with "data type" at http://hpaste.org/3695#a1
11:19:56 <Karle> yes
11:20:01 <Karle> thetallguy
11:20:32 <Karle> especially add_to_cache_fn
11:20:42 <Karle> the logic there  I do not understand
11:21:01 <int-e> @type insert
11:21:10 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
11:21:16 <thetallguy> Okay.  Well, if the cache is empty, it puts in the given data
11:21:53 <Olathe> What monad, in a nondeterministic way, takes a list and applies a function to an element and the list without that element ?
11:22:19 <thetallguy> if the cache is not empty, it only adds the data if there is no existing element with op, etc equal
11:23:01 <thetallguy> Karle: are you familiar with the @ syntax?
11:23:10 <Karle> no
11:23:24 <thetallguy> I would guess knowing that would make it clear
11:23:34 <Karle> thetallguy can it be written with @
11:23:41 <Karle> *without
11:23:52 <newsham> > let all@(a,b) = (1,3) in (a, all, b)
11:23:54 <lambdabot>  (1,(1,3),3)
11:23:56 <thetallguy> f  tuple@(x,y) = tuple
11:24:03 <thetallguy> ==
11:24:13 <thetallguy> f (x,y) = (x,y)
11:24:16 <newsham> the "all@" names the entirety of what is matched by (a,b)
11:24:48 <newsham> it can definitely be written without @.
11:24:56 <thetallguy> Karle: to write it without, you just pattern match element by element
11:25:03 <Olathe> f = id
11:25:08 <thetallguy> but then you have to reconstruct the object on the right hand side.
11:25:17 <thetallguy> The @ lets you name big chunks and refer to them.
11:25:42 <thetallguy> Kind of like $0 in awk, referring to the whole line instead of individual fields.
11:25:49 <newsham> so for example in the last line..  you could get rid of "pkg@" but every place you see "pkg" you'd have to write "(id,op,var1,var2,result)"
11:26:46 <int-e> I wonder why the first line doesn't read  add_to_cache_fn [] pkg = [pkg]  or   add_to_cache_fn [] pkg@(id,op,var1,var2,result) = [pkg]
11:26:51 <thetallguy> Does that help?
11:27:09 <int-e> err
11:27:17 <Karle> thetallguy ... yes
11:27:18 <thetallguy> int-e, it looked like certain fields got dropped
11:27:21 <int-e> sorry. It drops the id.
11:27:27 <Karle> yes int-e
11:27:42 <Karle> Can you write in a much simpler way?
11:27:48 <Karle> rewrite I mean
11:28:01 <ac> Olathe: you just created an iterative function up there
11:28:06 <thetallguy> Not the way it is structured
11:28:07 <int-e> Tuples with more than 3 elements are evil :)
11:28:23 <thetallguy> You could if they were records
11:28:54 <thetallguy> The key would be to encapsulate the types better
11:28:59 <Olathe> ac: The sum ?
11:29:04 <thetallguy> that business of dropping the id is a bit weird.
11:29:12 <thetallguy> or at least clumsy
11:29:14 <ac> Olathe: yeah
11:29:17 <newsham> fix the problem, not the solution :)
11:29:18 <Olathe> ac: Yep :)
11:29:21 <Olathe> > (>> Nothing) (Just 5)
11:29:23 <lambdabot>  Nothing
11:29:34 <thetallguy> I would start by abstracting the cache
11:29:40 <ac> Olathe: which brings me to the question: given Haskell's laziness, is there any point in creating tail recursive functions?
11:30:02 <Olathe> That's the style of functional programming I'm used to.
11:30:13 <bos> tail recursive functions can often be actively harmful in haskell.
11:30:15 <Heffalump> @seen augustss
11:30:15 <lambdabot> Last time I saw augustss was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #
11:30:15 <lambdabot> unicycling and #xmonad 4d 1h 36m 1s ago, and .
11:30:22 <thetallguy> if you have an equal operator and perhaps an extraction operator, then it becomes simpler
11:30:26 <newsham> "actively" ?
11:30:27 <Olathe> I know. I get stack overflows a lot.
11:30:38 <newsham> i would think they'd be passively harmful in a non-strict language ;-)
11:30:40 <Olathe> @seen Olathe
11:30:41 <lambdabot> You are in #haskell-blah and #haskell. I last heard you speak 1s ago.
11:30:41 <Vq^> ac: there can be a point
11:30:52 <bos> newsham: neener neener
11:30:52 <thetallguy> but really, you should just remove the id before doing the cache operation
11:31:01 <Olathe> If the compiler could optimize well, it wouldn't matter quite so much.
11:31:19 <ac> Vq^: what would that point be?
11:31:27 <Olathe> Always using thunks or whatever people keep saying it does is not such a good thing.
11:33:00 <Karle> thanks for your inputs
11:33:03 <Karle> :)
11:33:55 <Olathe> What's a concise way of solving these two people in a boat at a time problems.
11:33:56 <Olathe> ?
11:34:07 <Olathe> Is there some monad or something ?
11:34:18 <opqdonut> a graph of all the states and transitions
11:34:20 <opqdonut> and bfs
11:34:31 <opqdonut> at least that's the standard one
11:34:58 <Olathe> What monad does breadth first search ?
11:35:12 <Olathe> List ?
11:35:25 <ac> how do I remove a package? ghc-pkg unregister seems to remove it from the package database, but not actually delete the files from my lib directory
11:36:15 <bos> ac: use rm
11:36:15 <Vq^> ac: the implementation of sum and product are good examples
11:37:03 <opqdonut> Olathe: list does dfs, tho there is  a bfs version iirc too
11:37:28 <Olathe> Oh, you're right.
11:37:33 <Olathe> Laziness strikes again !
11:45:02 <Taejo> i'm getting 404s from hoogle: The requested URL /ghc/docs/latest/html/libraries/base/Prelude.html was not found on this server.
11:45:23 <mauke> known problem
11:46:36 <Taejo> I thought it probably was... just checking
11:47:23 <mauke> it works if you change latest to 6.6.1
11:47:40 <Taejo> yeah, got that
11:47:42 <Taejo> thx
11:48:37 <hpaste>  infrared pasted "How to make this code more haskellish?" at http://hpaste.org/3696
11:49:24 <infrared> just did a ruby quiz #76 in haskell as an exercise. i'd like to hear if anything can be improved there
11:51:14 <conal> infrared: what's shuffle and why is it IO?
11:51:38 <conal> infrared: why is there any IO?
11:52:15 <dankna> probably it's IO because it uses randomness?
11:52:30 <infrared> it's a modules which shuffles a list and its IO because it uses System.Random
11:52:56 <conal> infrared: got it.
11:53:41 <conal> infrared: i like your (start++) . (++end) .  you could use it in replaceSlice also and eliminate the last formal parameter.
11:54:27 <infrared> conal: ok, good idea
11:55:04 <conal> infrared: even define and reuse: surround start end = (start++) . (++end)
11:55:15 <infrared> i don't feel assemble is the best name, maybe "around" would be better?
11:55:26 <infrared> or surround :)
11:56:50 <conal> infrared: i'd isolate the IO-ness to main.
11:58:23 <infrared> yeah, i didn't like the way IO infected replaceSliceUsing, subRegexp and others once I put scrambleWord into the program
11:59:35 <infrared> just don't have a good idea how to do that, both replaceSliceUsing and subRegexp are not pure, because they return different results each time
12:00:09 <Saizan_> you can make them take the generator as an argument
12:00:34 <conal> IO is semantic cancer.
12:00:55 <infrared> Saizan_: can you give an example?
12:02:35 <Saizan_> infrared: shuffle :: [a] -> IO [a] ?
12:02:36 <conal> infrared: how about showing us shuffle?
12:02:58 <infrared> conal: shuffle is a copy from http://haskell.org/haskellwiki/Random_shuffle :)
12:02:59 <lambdabot> Title: Random shuffle - HaskellWiki
12:03:01 <conal> infrared: then we can see how IO is used internally and suggest an alternative.
12:03:57 <Saizan_> infrared: basically you want to use that shuffle' instead
12:04:01 <infrared> internals of the shuffle are not really relevant to this quiz
12:04:13 <infrared> Saizan_: i did use shuffle', but renamed it to shuffle :)
12:04:43 <Saizan_> infrared: what's the type of your shuffle?
12:04:53 <infrared> shuffle :: [a] -> IO [a]
12:05:01 <Saizan_> then you didn't use shuffle'
12:05:07 <conal> infrared: (i'm still opening the wiki page over my satellite connection.)  the idea is to use a pure variant of shuffle that takes an extra argument, computed in IO
12:05:18 <conal> i.e., computed in main using IO
12:05:34 <infrared> ok, i used shuffleIO
12:05:42 <infrared> which is built on top of shuffle'
12:06:03 <conal> is haskell.org slow or just my satellite connection?  (i live in the woods.)
12:06:27 <infrared> haskell.org works fine for me
12:06:29 <Olathe> It's slo....o......o......w.
12:06:43 <Vq^> works fine from here as well
12:06:51 <Saizan_> k, if you use just shuffle' you can keep you other functions pure, threading a StdGen generated in main
12:06:52 <Olathe> Lies ;|
12:07:05 <Olathe> I can't get it to come up here :(
12:07:42 <lament> i can't get it to come up either
12:07:59 <dolio> Works here.
12:08:01 <lament> obviously some of us in the channel have a haskell.org dysfunction
12:08:04 <Olathe> http://haskell.org/
12:08:06 <lambdabot> Title: Haskell - HaskellWiki
12:08:08 <lament> this is a serious medical problem
12:08:10 <Olathe> lambdabot can get it :|
12:08:24 <shapr> haskell.org works for me
12:08:41 <hpaste>  infrared annotated "How to make this code more haskellish?" with "Added definition of around." at http://hpaste.org/3696#a1
12:08:45 <dolio> http://www.haskell.org/haskellwiki/Haskell_Quiz/Text_Munger
12:08:46 <lambdabot> Title: Haskell Quiz/Text Munger - HaskellWiki
12:08:51 <dolio> That has two solutions, by the way.
12:09:17 <infrared> yeah, had seen that already
12:09:19 <Olathe> hookedonphonics.com worked for me
12:09:37 <mrd> there's probably drugs these days to help people who can't get their haskell.org up
12:09:38 <infrared> but those are not very readable, at least for noob me
12:10:08 <dolio> Aww, now my feelings are hurt. :)
12:10:16 <Saizan_> infrared: http://haskell.org/haskellwiki/New_monads/MonadRandom
12:10:17 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
12:10:28 <infrared> dolio: sorry :)
12:11:54 <infrared> ok, there's the code of MonadRandom, any examples of how to use it?
12:12:37 <conal> infrared: use fmap, liftM or <$> in replaceSliceUsing, instead of do.
12:13:01 <conal> (until you've eliminated the IO there)
12:14:00 <conal> infrared: also rename (start,end) to "borders" and use "uncurry slice"
12:14:30 <Taejo> how do I construct a map from an assoc list?
12:14:38 <Taejo> nevermind
12:15:26 <conal> infrared: oh -- you're using start & end elsewhere.  How about pairing consistently and adding a simple type alias: type Borders = (Int,Int).
12:15:59 <conal> infrared: then you won't have to uncurry slice (since slice won't be curried)
12:16:23 <infrared> yeah, was thinking about that, but idea of doing:
12:16:24 <infrared> sliceFromStart = slice 0
12:16:29 <infrared> was just too nice :)
12:16:57 <conal> yup.  you'd have sliceFromStart = uncurry slice 0
12:17:12 <conal> no -- curry slice 0
12:17:21 <infrared> ok, i'll give it a try then
12:17:48 <conal> these are all fiddly bits.  disentangling IO is the main thing.
12:18:21 <conal> surgically extract most of the IO tumor and apply chemo
12:18:27 <infrared> i'll work on those simple things first and then try to remove the IO
12:19:08 <conal> sure
12:19:09 <infrared> any other comments, about commenting/indenting scheme maybe? i have no idea what the haskell good coding standards are
12:20:05 <conal> infrared: indentation looks good to me, except the where in scrambleWord
12:20:21 <conal> it looks attached to the else
12:21:22 <infrared> where should "where" go, directly after liftM call?
12:21:32 <lament> heh, tried contacting haskell.org by IP, firefox finally timed out after 10 minutes
12:22:58 <conal> infrared: i'd put it in column 1, indented more than scrambleWord but less than if
12:23:09 <conal> or make it a "let" in the else.
12:23:18 <conal> really, i'd inline all three
12:23:22 <conal> start/middle/end
12:24:59 <infrared> I like naming things, good names make things much more readable
12:33:56 <hpaste>  infrared annotated "How to make this code more haskellish?" with "Added Borders definition" at http://hpaste.org/3696#a2
12:34:51 <infrared> ok, i'll take a break now and then try to remove IO
12:35:49 <conal> infrared: good luck
12:37:00 <infrared> thanks for all your help so far, #haskell rocks
12:37:14 <Tobsan> of course it does
12:37:34 <conal> hard
12:38:39 <shapr> And it's all because of the great people who show up here!
12:55:45 <Heffalump> 'lo
12:56:05 <ndm> lo Heffalump
12:56:06 <lambdabot> ndm: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:57:50 <ndm> @tell dcoutts just dump it into http://www.haskell.org/hoogle/res/gtk.txt and hoogle should start to use it
12:57:50 <lambdabot> Consider it noted.
12:58:02 <kawfee> lambdabot How many do I have?
12:58:03 <ndm> @tell dcoutts with an appropriate backup of that file first, since these things can go a bit hairy
12:58:03 <lambdabot> Consider it noted.
12:58:30 <ndm> @tell SamB_XP the GHC release added version numbers in packages, i intend to unbork them tomorrow
12:58:31 <lambdabot> Consider it noted.
13:00:20 <dottedmag> I've tried to build .debs for 6.8.1 (forward-porting patches from debian's 6.6.1), and have got interesting problem: install target fails due to DESTDIR somehow not passed to the utils/ makefile, so compilation fails being unable to "rm -f -f $DESTDIR/bin/ghc-pkg-6.8.1". Anyone experienced it? Trac search gives nothing.
13:05:11 <hpaste>  Taejo pasted "quickcheck causes link error" at http://hpaste.org/3697
13:05:35 <byorgey> Taejo: use --make
13:05:37 <Taejo> I'm guessing I need to add a linker flag, but I don't know what
13:05:44 <Taejo> thx, byorgey
13:17:25 <infrared> removing IO from my ruby quiz example (http://hpaste.org/3696#a2) means i will end up with RandomMonad in type definitions instead of IO, yes?
13:17:43 <infrared> *MonadRandom
13:18:02 <bos> you might be able to thread a list of random numbers through
13:18:11 <bos> but otherwise, yes
13:19:23 <infrared> it doesn't seem to be a big gain
13:19:36 <infrared> why leaving it as IO is bad?
13:20:14 <bos> because that means your code can do anything it wants in addition to generating random numbers.
13:20:53 <bos> whereas if you use only MonadRandom, you typically know your code can't be doing I/O or otherwise affecting stuff it shouldn't be.
13:21:56 <infrared> it won't affect anything except for the random generator state
13:22:12 <bos> right
13:22:53 <sorear> .
13:24:18 <infrared> so, more generally, i should use custom monads for controlling states of the things i define, while IO monad is for "the everything else", state of the outside world. does that make sense?
13:35:58 <byorgey> infrared: yup, that makes sense
13:36:05 <vvv> what's the difference between `runhaskell Setup.lhs configure --prefix=$HOME' and the same command with `--user' added?
13:36:31 <byorgey> infrared: also, keep in mind that most of the time, "custom monads" can be whipped up easily just by combining a few monad transformers to get the features you want.
13:36:39 <sorear> vvv: with --user it's a) willing to use local packages to satisfy deps b) 'install' uses the local database
13:37:18 <vvv> sorear: does this mean, that I can omit `--user' in `install' command?
13:37:23 <sorear> yes
13:37:32 <vvv> sorear: thnx :)
13:37:33 <sorear> --user configure implies --user install
13:37:38 <infrared> monad transformers, have to read about it :)
13:37:58 <vvv> infrared: nice motto, imho
13:38:06 <vvv> :)
13:38:59 <infrared> every sentence with a monad inside makes a good motto ;)
13:41:08 <hpaste>  dottedmag pasted "xmonad can't find X11" at http://hpaste.org/3698
13:42:02 <kolmodin> dons: the performance chart of different compilers over the nofib suit, is it still out there somewhere? I can't seem to find it
13:43:03 <kolmodin> oh, found it
13:43:48 <hpaste>  vvv annotated "xmonad can't find X11" with "try adding `--user'" at http://hpaste.org/3698#a1
13:43:53 <byorgey> infrared: if you want to read about monad transformers, there are two things you MUST read.  do not accept substitutes. =) they are:
13:43:59 <byorgey> @go monad transformers step-by-step
13:44:02 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
13:44:02 <lambdabot> Title: Monad Transformers Step by Step
13:44:10 <byorgey> @go how to use monad transformers
13:44:10 <shapr> byorgey: What about starting with applicative functors?
13:44:21 <lambdabot> http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
13:44:21 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers
13:44:36 <byorgey> mmm, that one might be good too but not what I was looking for
13:44:48 <byorgey> @go calewiki monad transformers
13:44:51 <lambdabot> http://swik.net/monad+transformers
13:44:51 <lambdabot> Title: monad + transformers - SWiK
13:45:31 <thoughtpolice> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
13:45:32 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
13:45:41 <byorgey> there it is, thanks thoughtpolice
13:45:43 <thoughtpolice> good read. i use that approach in my IRC bot. :)
13:46:09 <byorgey> shapr: you mean as an approach to learning about monads/monad transformers?
13:46:26 <quicksilver> CosmicRay: ping
13:46:45 <shapr> byorgey: Yeah
13:46:57 <byorgey> shapr: interesting, I'm not sure.
13:47:06 <shapr> conal suggested it to me.
13:47:15 <byorgey> shapr: that's not the way *I* learned it so I don't have a good perspective on it
13:47:31 <byorgey> well, conal suggests AFs for everything, but that doesn't mean it's not a good idea =)
13:47:35 <shapr> heh
13:48:03 <byorgey> ask me again in a few years once I've taught a class on advanced functional programming in Haskell =)
13:48:55 <vvv> @help go
13:48:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:49:09 <byorgey> vvv: it's a google 'I'm feeling lucky' search
13:49:09 <shapr> byorgey: heh
13:49:15 <infrared> thanks for the links, added to my toread list :)
13:50:02 <vvv> byorgey: @botsnack
13:50:04 <vvv> :)
13:50:10 <quicksilver> CosmicRay has written a *lot* of haskell stuff, hasn't he?
13:50:28 <byorgey> :)
13:50:29 <CosmicRay> pong
13:50:37 <quicksilver> CosmicRay: Data.ConfigFile
13:50:44 <CosmicRay> yes, I wrote that
13:50:54 <CosmicRay> what's up?
13:50:55 <quicksilver> CosmicRay: I'm sure you know this, but I'm just reading the docs. It's docced as 'portable' but it ain't :)
13:51:04 <CosmicRay> in what way?
13:51:06 <quicksilver> CosmicRay: it uses MPTCs and overlapping instances
13:51:16 <byorgey> sure it is.  just put it on a floppy disk...
13:51:22 <quicksilver> ;)
13:51:24 <CosmicRay> oh, I meant portable in that the format is portable (I think)
13:51:32 <CosmicRay> anyway it does work under both hugs and ghc
13:51:39 * quicksilver nods
13:52:02 <quicksilver> other haddock pages I've read documented their major extensions from haskell98 in the 'Portabiity' field
13:52:08 <quicksilver> (top right of haddock output, very corner)
13:52:16 <quicksilver> although I'm not sure what it's really intended to mean :)
13:52:18 <CosmicRay> oh, well if I said "portable" there that probably is a bug
13:52:56 <CosmicRay> although it does work everywhere people seem to want to use it ;-)
13:53:11 <CosmicRay> quicksilver: same goes for the stability field in the cabal files
13:53:31 <quicksilver> CosmicRay: another point (I'm only reading the docs, haven't tried to use it yet) is that 'get' says it can work with any instance of Read
13:53:38 <quicksilver> but the type says to mean, only for Nums
13:53:44 <quicksilver> (Num t, Read t) => Get_C t
13:53:45 <CosmicRay> ConfigFile uses a portable file format.  it's the same format as ConfigParer (python) and ConfigParser (ocaml) and Windows ini use
13:53:54 * quicksilver nods
13:54:04 * CosmicRay pulls up the docs
13:54:32 <dons> http://programming.reddit.com/info/5zzly/details
13:54:33 <CosmicRay> are you looking at a different "get" than me?
13:54:33 <lambdabot> Title: programming: Benchmarking ray tracing: Haskell vs. OCaml: the Haskell programs a ...
13:54:36 <dons> yay lennart
13:54:39 <CosmicRay> get :: MonadError CPError m => ConfigParser -> SectionSpec -> OptionSpec -> m a
13:54:56 <CosmicRay> oh nm, ICWYM
13:54:59 * quicksilver nods
13:55:03 <quicksilver> looking at the instances
13:55:07 <quicksilver> maybe I misunderstood?
13:55:33 <CosmicRay> no, that is a defect in the docs, it would seem.
13:55:48 <quicksilver> I was thinking of writing my own config parser
13:55:50 <CosmicRay> I will have to look at the code and see why the Num t
13:55:53 <quicksilver> so I searched hackage
13:55:56 <quicksilver> and found yours :)
13:56:12 <CosmicRay> if you think it sucks, patches are always welcome ;-)
13:56:21 <CosmicRay> hackage does seem to be growing increasingly useful lately
13:56:36 <CosmicRay> I need to write ConfigFile-HDBC to use HDBC as a backend for this someday.
13:57:01 <Schmallon> Is there any way to get Tab-Completion in the emacs mode?
13:57:20 <quicksilver> I don't think it sucks :)
13:57:25 <quicksilver> Schmallon: M-/
13:57:37 <CosmicRay> do you mean M-/ -- the dynamic abbrev completion?
13:57:43 <Schmallon> great, thanks!
13:57:45 <CosmicRay> Tab is usually the indent key in emacs
13:57:55 <quicksilver> CosmicRay: It's not much like the one I was thinking of writing
13:58:02 <Schmallon> yeah, i'm new to emacs :-)
13:58:02 <quicksilver> but there are lots of choices in config file writing
13:58:11 <thoughtpolice> dons: upvote. :) interesting results...
13:58:24 <CosmicRay> quicksilver: do you think it will fill your needs?  I want to make it as broadly useful as possible.  config file parsing library proliferation annoys me.
13:58:33 <quicksilver> Schmallon: there is also #emacs, which is a more-or-less helpful channel. Not as friendly as this one, though, and haskell-related emacs questions are quite welcome here.
13:58:48 <dons> thoughtpolice: yeah, anything that kicks harrop's dodgy methodologies i'm happy with :)
13:58:49 <quicksilver> CosmicRay: I was more interested about the "next stage" actually, not the file parsing bit
13:58:54 <thoughtpolice> dons: it seems as the differences between the old code on 6.8.1 as opposed to 6.6.1 are quite different, mostly from pointer tagging I would assume?
13:59:01 <CosmicRay> quicksilver: what's the next stage?
13:59:08 <quicksilver> CosmicRay: the construction of a proper (strictly typed) data type from the parsed data
13:59:13 <CosmicRay> ah
13:59:24 <Schmallon> @quicksilver: thanks!
13:59:24 <lambdabot> Unknown command, try @list
13:59:27 <quicksilver> going from semi-structured to strictly typed
13:59:33 <dons> thoughtpolice: that probably helps , and the strictness analyser, inliner,and new optimisations
13:59:41 <thoughtpolice> i have 6.8.1 installed but I'm waiting until at least hs-plugins or some equivilant is available. that way I can at least still keep working on my irc bot (hs-plugins seems broken on my openbsd box)
13:59:49 <quicksilver> CosmicRay: I was thinking of doing it as applicative combinators
13:59:50 <CosmicRay> so you are thinking of something like HaskellDB, only layering atop a config file instead of a library like HDBC?
13:59:55 <thoughtpolice> well, built, not installed.
14:00:05 <quicksilver> CosmicRay: because applicatives can collect multiple errors before aborting
14:00:12 <quicksilver> CosmicRay: well 'like' HaskellDB but much simpler
14:00:12 <CosmicRay> ah, handy.
14:00:17 <dons> oh, but that doesn't show up on reddit!
14:00:24 <CosmicRay> yes, I was talking at a highly abstract level there ;-)
14:00:24 <dons> its coming from a blogspot link
14:00:25 <dons> fixing...
14:00:35 <thoughtpolice> that's a pretty annoying bug. :(
14:00:42 <dons> grr
14:00:43 <thoughtpolice> i wonder how many emails the reddit admins have gotten...
14:00:49 <quicksilver> CosmicRay: primitives for "parse this config bit using read", "parse this config bit with a fallback default if it's omitted"
14:00:52 <dons> ?tiny-url http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
14:00:53 <lambdabot> http://tinyurl.com/25sj6t
14:00:55 <quicksilver> CosmicRay: that sort of thing
14:01:16 <quicksilver> CosmicRay: then you either get the right data strcuture out, or get a list of errors "required field missing, field failed to parse, etc etc"
14:01:26 <dons> http://programming.reddit.com/info/5zzmu/comments/
14:01:28 <lambdabot> Title: programming: Benchmarking ray tracing: Haskell vs. OCaml: the Haskell programs a ...
14:01:38 <CosmicRay> sure.
14:02:01 <CosmicRay> you know, you may still find the ConfigParser parser useful for reuse.
14:02:08 <CosmicRay> at its heart, it give you a [(String, [(String, String)])]
14:02:17 <quicksilver> CosmicRay: I may use the ConfigFile itself as a backend
14:02:23 <CosmicRay> where the outer level represents named sections and the inner level represents the options
14:02:26 <quicksilver> CosmicRay: and provide combinators which access sections
14:02:26 * quicksilver nods
14:02:34 <CosmicRay> quicksilver: I will definitely be interested in your result
14:02:37 <quicksilver> yes ultimately that's the semi-structured data problem
14:02:46 <quicksilver> going from Map String String to TypedADT
14:02:48 <CosmicRay> I could see some uses for it
14:02:52 <CosmicRay> right
14:02:55 <quicksilver> CosmicRay: also, commandline options
14:03:02 <quicksilver> CosmicRay: commandline options are quite like config data
14:03:09 <quicksilver> CosmicRay: they can be missing, and they have format requirements
14:03:16 <CosmicRay> yes.  GetOpt sucks but I haven't quite figured out how to fix it without spending too much time on it
14:03:47 <bos> dcoutts: ping
14:03:57 <quicksilver> CosmicRay: I didn't even look at getopt yet
14:03:59 <bos> @seen dcoutts
14:03:59 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 2h 38m 35s ago.
14:04:03 <quicksilver> CosmicRay: I got distracted by configfile :)
14:04:07 <quicksilver> CosmicRay: I have a skittish mind
14:04:11 <CosmicRay> command line options can be a real problem.  single-letter options, double-letter options, options taking args, options not taking args, options invalid in combination with other options, args that aren't options
14:04:32 <CosmicRay> GetOpt was Good Enough so I didn't bother writing something there ;-)
14:04:54 <CosmicRay> I only write libraries when what's there annoys me so intensely that I can't bear to use it ;-)
14:07:37 <CosmicRay> time for me to run...
14:09:38 <hpaste>  edd pasted "'selfmade' reverse" at http://hpaste.org/3699
14:09:46 <eDDDDDer> yes i did! :o
14:10:36 <RayNbow> eDDDDDer, that last line...
14:10:47 <RayNbow> "reverseList (x:xs) = reverseList xs : x" <-- this one
14:10:58 <RayNbow> that's not correct
14:11:02 <RayNbow> :t (:)
14:11:04 <lambdabot> forall a. a -> [a] -> [a]
14:11:38 <RayNbow> : wants the first argument to be an element (type a) and its second argument to be a list (type [a])
14:11:46 <eDDDDDer> yeh :(
14:11:49 <eDDDDDer> that's my problem
14:11:58 <RayNbow> you could type "reverseList (x:xs) = reverseList xs ++ [x]" though
14:12:27 <eDDDDDer> hm. i only tried  "reverseList (x:xs) = reverseList xs ++ x"
14:12:42 <eDDDDDer> so i got to create a list out of x by using [] before i can add it?
14:12:44 <Taejo> isn't that quadratic, RayNbow?
14:13:02 <RayNbow> Taejo: hmm?
14:13:14 <quicksilver> yes, it is
14:13:25 <EvilTerran> you make O(n^2) list cells for a length n list
14:13:29 <Taejo> reverse only needs linear time
14:13:30 <quicksilver> but that doesn't matter too much if the objective is to get use to haskell & types
14:13:37 <Taejo> true
14:13:39 <eDDDDDer> thanks a lot RayNbow.. you saved my day :)
14:13:43 <quicksilver> after all the efficient reverse is in the library :)
14:13:46 <quicksilver> @src reverse
14:13:46 <lambdabot> reverse = foldl (flip (:)) []
14:13:54 <Nafai> What's constructor specilization that dons mentions as a new feature of GHC 6.8.1?
14:14:27 <RayNbow> quicksilver, foldl brackets to the left, right?
14:14:28 * shapr wants to know!
14:14:54 <Taejo> writing code that's in the wrong soft-O bugs me, even (especially?) at the early stages
14:15:04 <shapr> Is there a changelog that lists new features in 6.8.1 ?
14:15:07 <thoughtpolice> Nafai: http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
14:15:09 <lambdabot> Title: Constructor specialisation for Haskell programs, http://tinyurl.com/2qf2ur
14:15:10 <Olathe> What is a soft-O ?
14:15:20 <quicksilver> Nafai: in some circumstances, if the function "g" obviously produces a "Just", and you use it thus: case g of Just x -> ...
14:15:26 <quicksilver> the case can be eliminated entirely
14:15:28 <Taejo> Olathe, like big-O but ignoring logarithmic factors
14:15:29 <quicksilver> and the 'Just' as well
14:15:34 <thoughtpolice> shapr: there's probably a changelog in the repo, but, http://haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html
14:15:35 <lambdabot> Title: 1.4. Release notes for version 6.8.1, http://tinyurl.com/3yjyhg
14:15:44 <Olathe> Ahh.
14:15:55 <Taejo> soft-O is written as an O with a tilde accent
14:15:58 <sorear> Nafai: It's just an optimization
14:16:09 <idnar> √ï()
14:16:22 <Olathe> A guy with wavy hair.
14:16:30 * Nafai nods
14:16:34 <Nafai> Thanks, makes sense
14:17:00 <shapr> thoughtpolice: Thanks!
14:17:02 <Taejo> Nafai, it's quite a significant one, AFAIR... looking for my ICFP proceedings
14:17:31 <thoughtpolice> shapr: personally, i'm looking forward mostly to integrated HPC :) (i could never get hmake to install correctly...)
14:18:10 <thoughtpolice> the new type family stuff looks interesting too (although experimental,) but I have no idea really what it is or how it works so :(
14:19:17 <sw17ch> any word on if 6.8.1 has made it to any distros yet?
14:19:46 <\\> gentoo installed it a while ago on an upgrade here
14:20:08 <thoughtpolice> i'm checking archlinux, but for some reason I doubt it... (probably still at ghc 6.6)
14:20:18 <\\> take that back. it got killed running out of RAM compiling itself. and the binary is only at 6.6
14:20:30 <Taejo> Nafai, it constructor specialisation gives average 10% speedup on nofib (and up to 39%)
14:20:30 * \\ never successfully compiled ghc. ever.. always either overheat or killed :)
14:20:56 <thoughtpolice> i've compiled all my installations of ghc, iirc.
14:21:06 <\\> yeah. one time i got it. proably enabling more swap will solve it
14:21:20 <\\> g++ takes ~1gb for large cpp files itself. so i cant complain
14:21:21 <kawfee> thoughtpolice Did I commit a crime?
14:21:39 <thoughtpolice> kawfee: ?
14:22:13 <kawfee> sorry, I thought you were here to arrest me for all those thought I had when I saw that super model show with the victoria secret models
14:22:24 <kawfee> thoughts
14:22:35 <kawfee> my bad, back to your work
14:24:12 <thoughtpolice> :)
14:26:12 <pejo> Taejo, didn't the pointer tagging do quite a lot as well?
14:26:25 <dons> yep
14:26:36 <Taejo> pejo, I think it was also around 10%
14:26:59 <sw17ch> \\, are you running an overlay on gentoo?
14:27:16 <sw17ch> \\, i have ~amd64 set, but i'm still only getting 6.6.1
14:27:18 <\\> no. going to, as cant find xmonad in the main tree
14:27:19 <Taejo> if only I could find those damn proceedings...
14:28:23 <sw17ch> looks like the newest gentoo has is 6.6.1 which is unstable for every arch but x86
14:28:32 * \\ joins #gentoo-haskell
14:28:34 <\\> lets take it there :)
14:29:38 <mrd> @type (\\)
14:29:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:34:18 <sjanssen> augustss++ nice benchmarking article
14:35:22 <cafr> harrop is obnoxious, but i wonder if the tone of augustss sort of veers towards harrop
14:37:21 <dons> mm.
14:37:48 <dons> at least it sets the record straight. perhaps now we can get back to fighting python?
14:38:01 <Nafai> I'm surprised Harrop hasn't replied on augustss' blog
14:38:42 <dons> he probably doesn't care as long as people are visiting his book page
14:38:57 <dons> i wonder how the wider ocaml community feels about jdh's tactics
14:38:57 <Nafai> True :)
14:39:10 <Nafai> Harrop is their dons :)
14:39:20 <dons> i hope not.
14:39:22 <\\> dono about that.
14:39:23 <pejo> dons, can he possibly get rich by selling that book? It seems like a very small community to sell to.
14:39:49 <pejo> And if he can't get rich by doing it - why push it so hard?
14:40:06 <dons> and why do so by fracturing the FP community
14:40:18 <cafr> naah, harrop is so transparently self-promotional, it's sickening. Doesn't he know that it's backfiring?
14:40:36 * \\ definitely avoided book, not only due to price, but incessant spam
14:40:45 <Nafai> dons: I was just kidding :)
14:40:48 <sjanssen> @quote JonHarrop
14:40:49 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
14:40:50 <dons> phew!
14:40:55 <sjanssen> @quote JonHarrop
14:40:56 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
14:40:58 <sjanssen> @quote JonHarrop
14:40:58 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
14:41:11 <sjanssen> I thought there were more quotes
14:41:12 <dons> maybe the hwn quote wasn't in @quote
14:41:31 <sjanssen> @quote Harrop.
14:41:31 <lambdabot> No quotes match. Sorry.
14:41:58 <olsner> I must say I somewhat agree though
14:41:59 <Excedrin> "OCaml continues to be his main revenue stream, with sales of all of our OCaml-related products having increased four fold over the past year."
14:42:35 <dons> Excedrin: is that jdh talking about himself in 3rd person?
14:42:42 <Excedrin> yea, I think so
14:42:58 <dons> sure, that's a reasonable quote. the hwn one from last week was funnier though
14:43:04 <Excedrin> from here http://www.dotnetrocks.com/default.aspx?showNum=266
14:43:05 <lambdabot> Title: .NET Rocks!
14:43:23 <dons> "As Haskell has shown, laziness cannot be implemented efficient at all."
14:43:43 <cafr> Well, just to play devil's advocate here. Laziness does make complexity reasoning harder. Opacity implies unpredictability?
14:44:01 <Excedrin> the quote I found addresses this: <pejo> dons, can he possibly get rich by selling that book? It seems like a very small community to sell to.
14:44:06 <dons> harder, certainly.
14:44:18 <pejo> cafr, I think we all agree that laziness has its fair share of problems.
14:44:35 <dons> good thing we can program in strict haskell when needed:)
14:45:13 <pejo> Excedrin, so he's selling "a lot" according to his own marketing. Guess he either wrote a damn fine book or people are actually buying his propaganda.
14:45:26 <dons> or ...
14:45:43 <dons> well, "lot" is hard to quantify
14:46:01 <cafr> @pejo: Some problems = opportunities. It's precisely because laziness is "hard" that it's interesting.
14:46:01 <lambdabot> Unknown command, try @list
14:46:06 <dons> but, the big concern is his attempts to fracture the community by encouraging infighting.
14:46:23 <dons> the lisp guys have it worst, I think.
14:47:34 <pejo> cafr, I'm not convinced that is the reason laziness is interesting.
14:47:47 <pejo> dons, oh, I fully agree with you.
14:49:31 <ddarius> dons: Most people in one of these communities don't take him seriously
14:50:28 <cafr> Why is he so anti-lisp, btw? Where's the competition?
14:50:49 <\\> Qi for scientists?
14:50:53 * \\ signs up on waitlist
14:51:40 <Cale> In my mind, the real reason that laziness is interesting is that it opens up new options for composability of software.
14:51:44 <mrd> cafr: general old crotchety ML programmer-ness
14:52:20 <ddarius> Most MLers tend not to actively care one way or another about Lisp.
14:52:27 <olsner> hehe, "I am not sure I would trust a company whose representatives have time for trolling, it means that their time is not very valuable."
14:52:37 <mrd> I disagree.  Most MLers I know actively hate lisp.
14:52:41 <olsner> (post about jon harrop on comp.lang.lisp)
14:53:14 <mrd> though they tend to characterize it in such a way that makes me think they last touched Lisp in the 70s
14:53:40 <ddarius> mrd: They go out of their way to attack Lisp?
14:53:44 <mrd> yes
14:54:12 <Cale> Laziness might be tricky to implement well, but it's clearly worthwhile because of the way in which it lets you break down problems, and is desirable in most cases. Of course, without studying it, you're never going to get good at implementing it effectively, so that's kind of what Haskell is about.
14:54:58 <ddarius> mrd: My experience on c.l.s is that the only MLer there that had issues with it and stated them was a former Scheme implementor.
14:55:13 <ddarius> c.l.l didn't really have MLers come by that often.
14:55:44 <ddarius> And by "kind of" Cale means ""
14:56:03 <ddarius> (At least back in the day.)
14:56:10 <mrd> i wasn't really thinking of newsgroups
14:56:14 <psnively> Eh, I'm with Tim Sweeney on this... lazy is probably the wrong default. But lenient would be good.
14:56:15 <cafr> cale, pejo: I exaggerate, I take back the "precisely" part. I was thinking of Okasaki and his "Purely Functional."
14:56:28 <mrd> i never lurked on cls
14:56:31 <bos> my, our regex library bindings are slow and arcane
14:57:24 <ddarius> cafr: Okasaki wasn't trying to overcome "performance problems" with laziness.
14:57:29 <pejo> cafr, you mean his book? It contains ML versions of most of the stuff.
14:57:32 <luqui> what does the +r ghci flag do?
14:57:41 <salierix> So who is this Harrop guy?
14:57:42 <luqui> I don't know what "revert top level expressions" means
14:58:04 <olsner> how does lenient evaluation differ from lazy?
14:58:05 <psnively> Jon Harrop is a big O'Caml fan who is a bit, er, exhuberant in his presentation style.
14:58:14 <sorear> salierix: some evil person on the mailing list
14:58:30 <Tobsan> no use modelling a mule using oCaml...
14:58:30 <bos> s/exuberant/annoying and dishonest/
14:58:31 <Tobsan> hehehe
14:58:33 <mrd> olsner: doesn't necessarily postpone all evaluation til the last moment
14:59:03 <mrd> though that makes it sound non-deterministic
14:59:19 * bos resorts to compiling a regexp by hand and executing it with unsafePerformIO
14:59:26 <mrd> i suppose one thing you could do is make some data structures lazy and some eager
14:59:36 <mrd> bos: use the tdfa-regex package?
14:59:51 <salierix> Doesn't ghc already do that?
15:00:13 <bos> mrd: i have a group in my regexp, and regex-tdfa falls back to terrible performance if capturing groups
15:00:23 <cafr> salierix: Jon Harrop is an incorrigible one-man consultancy that understands the self-promotion game. Squeaky screaming wheel gets the oil.
15:00:40 <mrd> oh. ugh.  but then again, that's not regular =)
15:00:53 <mrd> oh wait, no backreferences right?
15:01:04 <bos> no backrefs
15:01:05 * mrd thwonks self
15:01:13 <olsner> but that sounds like just what you'd get from a strictifying optimizing compiler for a lazy language
15:01:25 <mrd> cafr: trolling internet newsgroups is profitable?
15:01:30 <mrd> no wonder it's so commonplace
15:01:39 <bos> dons: i posted augustss's article earlier today
15:02:27 <olsner> ... and "lazy" gives more freedom to the compiler than "lenient", right?
15:02:53 <alexj> @seen Igloo
15:02:53 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 5h 42m 48s ago.
15:02:59 <salierix> Anyone know how long it usuallly takes for gentoo to update the ghc package?
15:03:05 <cafr> mrd: in the same way that paris hilton leaking self-pr0n is profitable. I'm not actually saying that she did it, but it helps.
15:03:33 <salierix> Helps what? She doesn't do anything.
15:04:05 <olsner> so, where would a lenient evaluation compiler give a result that is different from what e.g. ghc does when strictifying lazy evaluations?
15:04:18 <cafr> Nowhere -- that's the point
15:04:19 <alexj> any reason why TH that generates code does not behave the same as putting the same code in manually?  I am doing (runIO $ print $ pprint $ result).  If I paste the result in, things compile.  If I put the TH call in I get a type objetion.
15:04:22 <mrd> no
15:04:41 <mrd> olsner: for example, a list like take 1 [1,undefined] -- might be undefined in lenient eval
15:04:53 <alexj> fwiw, the pasted code is: "class HasComponent st\n    where withComponent :: With Component st a\n          component :: st -> Component"
15:05:47 <pejo> mrd, that sounds non-deterministic
15:05:51 <mrd> indeed
15:06:13 <cafr> mrd: But that's not Haskell then, a "non-strict purely functional language" iirc
15:07:13 <dons> bos, ah links blocked on reddit.
15:07:28 <dons> bos, note also popular links on the subreddit get auto-promoted to the main reddit now...
15:07:32 <bos> reddit has been sucking hard since the upgrade.
15:07:43 <bos> it's barely worth the trouble of using now.
15:07:59 <dons> we need to maintain a presence outside LtU though :)
15:08:14 <cafr> salierix: She's a big nasty corp in the attention economy, worth bajillions of attention credits
15:08:15 <dons> see http://www.langpop.com/ for why ..
15:08:16 <lambdabot> Title: Programming Language Popularity
15:09:51 <alexj> anyone here a template haskell jock?
15:10:12 <alexj> or can recommend one?
15:10:17 * olsner ponders creating an alter ego trolling every forum alive with random "Haskell is better than X" tidbits
15:10:19 <bos> alexj: you're it :-)
15:10:33 <alexj> luvely.
15:10:43 <dons> alexj: try Igloo in a few hours
15:10:53 <salierix> What does @ mean on the left side of a function declaration?
15:11:29 <bos> it lets you refer to a value that you're also inspecting the contents of
15:12:07 <dons> ok, now augustss is on the reddit front page.
15:12:15 <Excedrin> looks like slashdot is clearly the next community to infiltrate
15:12:35 <dons> so this is a weird feature, since it means more subreddit-popular articles will make the frontpage
15:12:36 <bos> salierix: so if you're looking at a value of (Either left right), you can use either@(Either left right) and have either be bound to the entire value
15:13:50 * ddarius shoots Excedrin.
15:14:08 <psnively> reddit was upgraded? To what?
15:14:10 <ddarius> dons: That seems retarded.
15:14:23 <cafr> pejo: re: okasaki. The ML-ness or otherwise of his programs shouldn't obscure the major theme of his book. 2nd paragraph of thesis abstract: "we expose the fundamental role of lazy evaluation in amortized functional data structures."
15:15:14 <bos> psnively: it's now stupid 2.0 compliant
15:15:51 <ddarius> bos: I think stupid has a much higher version number than that.
15:16:44 <psnively> I can see no obvious difference with programming.reddit.com.
15:16:45 <luqui> is there a good tutorial or example for Data.Graph.Inductive somewhere?
15:17:04 <ddarius> luqui: There's the paper(s) on it.
15:17:18 <cafr> luqui: Isn't that Erwig's work?
15:17:41 <olsner> Papers are not documentation.
15:17:47 <salierix> thanks bos.
15:17:57 <ddarius> olsner: Many are better than typical documentation.
15:18:10 <ddarius> At least for "tutorial"/"example" type stuff.
15:18:14 <ddarius> A reference is still nice.
15:20:25 <salierix> If Harpy was ever added to GHC, would that mean we could use it in benchmarks? Or would that be cheating? ;)
15:20:53 <ddarius> salierix: Harpy is just a library.
15:21:06 <olsner> surely the papers are relevant for what they are relevant for, but it's somewhat intimidating to try to look up the docs for a module and only find "this is described in this paper" and a link to a paper
15:21:16 <mrd> um, the paper is easy to read
15:21:28 <mrd> what more would you like, spoonfeeding?
15:21:31 <salierix> So are ByteStrings.
15:21:38 <ddarius> olsner: There is absolutely no reason that should be intimidating.
15:21:58 <olsner> yeah, the intimidation usually ensues after opening the PDF
15:23:26 <cafr> mrd: Not spoonfeeding, but how about "meeting up halfway"?
15:23:49 <LoganCapaldo> @type rnf
15:23:51 <lambdabot> forall a. (NFData a) => a -> Done
15:24:12 <cafr> The professional programmer doesn't (should?) read academia.
15:24:43 <ddarius> cafr: The professional programmer should be scared of a paper just because it's an academic paper?
15:24:48 <LoganCapaldo> I'm a professional programmer, and I struggle thru papers on occasion :)
15:26:11 <Beelsebob> LoganCapaldo: that's somewhat the point -- struggle through
15:26:12 <salierix> Is there a list of all the Haskell papers for download?
15:26:22 <Beelsebob> academic work is annoyingly hard to penetrate
15:26:24 <SamB> cafr: the professional programmer sure sounds like an idiot to me. well, or he isn't a functional programmer, and the academic papers are half nonsense...
15:26:26 <Beelsebob> and usually neadlessly so
15:27:00 <mrd> Erwig's paper is not that way.  it's filled with tons of examples.
15:27:05 <cafr> Yeah, the same way Javanese is half nonsense ... sigh
15:27:13 <pejo> salierix, any particular branch you're looking for? "Haskell papers" is somewhat of a broad scope.
15:27:18 <mrd> he does assume you know what a graph is.
15:27:32 <mrd> that might be more than the typical "professional" programmer knows these days
15:27:36 <ddarius> If you are being recommended a paper it either isn't hard to read or the "difficulty" is difficult to avoid.
15:27:56 <SamB> any introductory text will tell you what a graph is
15:28:10 <salierix> pejo, nothing specific in mind. I would just like to browse.
15:28:14 <ddarius> SamB: "text" sounds too much like "paper" for my tastes
15:28:17 <LoganCapaldo> mmm graph paper
15:28:26 <SamB> ddarius: I was thinking more like a book
15:28:37 <ddarius> salierix: There is a link on Haskell.org
15:28:44 <ddarius> SamB: And my comment was sardonic.
15:28:58 <SamB> I don't even remember what that *means*
15:29:06 <ddarius> @wn sardonic
15:29:08 <lambdabot> *** "sardonic" wn "WordNet (r) 2.0"
15:29:08 <lambdabot> sardonic
15:29:08 <lambdabot>      adj : disdainfully or ironically humorous; scornful and mocking;
15:29:08 <lambdabot>            "his rebellion is the bitter, sardonic laughter of all
15:29:08 <lambdabot>            great satirists"- Frank Schoenberner; "a wry pleasure
15:29:10 <lambdabot>            to be...reminded of all that one is missing"- Irwin
15:29:11 <LoganCapaldo> it's like sarastic, but more academic
15:29:12 <lambdabot>            Edman [syn: {wry}]
15:29:17 <SamB> I always always always forget what sardonic means
15:29:23 <SamB> LoganCapaldo: hahahaha
15:30:12 <cafr> salierix: a secret: read papers starting from the Bib, the way pros do
15:30:13 <Excedrin> instead of documentation, library authors should make youtube videos, that way it's accessible to illiterate professional programmers
15:30:37 <LoganCapaldo> mmm illiterate porgramming
15:30:47 <ddarius> Actually, it would be awesome if all Simon Peyton Jones' papers were in video form presented by him.
15:30:51 <LoganCapaldo> Doe ghc support .ilhs files?
15:30:52 <SamB> youtube videos might be occasionally useful
15:31:10 <SamB> and yes SPJ papers on youtube would be WAAAAY COOL
15:31:17 <SamB> no matter how useless
15:31:28 <LoganCapaldo> comments and variables of a length greater than one coudl be considered syntax error
15:31:33 <dcoutts> bos: pong
15:31:35 <ddarius> SamB: Look at the popularity of the Catsters
15:31:47 <olsner> illiterate programming? wouldn't that be lolcode
15:31:59 <SamB> I looked at the catsters stuff but I was in over my depth on the first one :-(
15:32:09 * ddarius has an epiphany and suddenly understands UML
15:32:17 <SamB> ddarius: 'tis not possible
15:32:21 <cafr> math is a beeyotch to learn without bioware
15:32:22 <SamB> UML doesn't MEAN anything
15:32:23 <Beelsebob> ddarius: o.O
15:32:38 <ddarius> SamB: Consider the context of my statement...
15:32:40 <salierix> Simon Peyton Jones catch phrase seems to be "Does that make sense?"
15:32:51 <bos> dcoutts: er, um, i forget
15:32:53 <LoganCapaldo> Oh god another one
15:33:00 <dcoutts> bos: heh :-) perhaps gtk2hs build?
15:33:01 <SamB> that's a pretty good catchphrase
15:33:26 <LoganCapaldo> I swear every math professor I ever had said "Does that make sense" after every statement as though it were a magic incantation to make it make sense for all of us
15:33:42 <ddarius> LoganCapaldo: How often did you say "No"?
15:33:47 <cafr> Try catching him after class
15:33:48 <SamB> I bet some of them said "do you have any questions?"
15:34:07 <SamB> LoganCapaldo: you are supposed to say "no" if not
15:34:19 <SamB> then the part where he makes it make sense is where he tries to explain it more
15:34:35 <LoganCapaldo> I know you're supposed to say no :)
15:34:47 <LoganCapaldo> they just all seemed excessively found of the phrase
15:34:47 <salierix> That just means you're the only one dumb enough not to understand.
15:35:05 <dcoutts> bos: so did the tarball I gave you build ok for the fedora packages?
15:35:11 <SamB> salierix: rarely does it mean that
15:35:20 <SamB> well.
15:35:22 <SamB> for me!
15:35:25 <LoganCapaldo> I don't think anyone ever said yes though
15:35:27 <pejo> salierix, I think it somewhat depends on culture, but quite often people are too afraid to look stupid to ask, although nobody understood.
15:35:27 <bos> dcoutts: i got distracted before i submitted the build job. i've submitted one now.
15:35:36 <dcoutts> bos: I'll have a few changes, to make things work more reliably when people have several versions of dependent packages available
15:35:52 <SamB> sometimes I didn't figure out if I understood yet or not though
15:35:54 <salierix> SamB, it was a joke... I think ;)
15:35:58 <ddarius> LoganCapaldo: The question is usually to solicit "no"s not "yes"s, but "yes" would also be a perfectly acceptable response.
15:36:04 <LoganCapaldo> I also had a philosophy professor who did the "does that make sense" thing
15:36:04 <pejo> salierix, that last "to ask" = when asking.
15:36:07 <dcoutts> bos: what's your deadline again?
15:36:16 <LoganCapaldo> that was amusing
15:36:26 <ddarius> LoganCapaldo: Well for philosophy then you are required to answer "no" to each of those questions.
15:36:30 <SamB> if mine had done that I would have said "no" a lot
15:36:53 <SamB> my philosophy professor seemed to have a lot of trouble with the material ;-)
15:37:11 <SamB> well, actually I think he was just a grad student or something...
15:38:09 <cafr> so many universities classes are overrated these days
15:38:24 <SamB> to be fair, this was at a community college...
15:38:44 <SamB> now what I want to know is why my statics professor is so fond of the law of sines...
15:39:43 <cafr> maybe we should move this to haskell_blah or _overflow?
15:39:58 <LoganCapaldo> Does that make sense?
15:40:01 <dolio> Yeah, you're choking out all the other traffic. :)
15:40:39 <salierix> Did anyone do any benchmarks of ghc 6.6.1 vs ghc 6.8.1 yet?
15:40:54 <LoganCapaldo> haven't you heard the party line?
15:41:05 <LoganCapaldo> it's 10-15% faster from pointer tagging alone
15:41:06 <salierix> I would be interested in just how much pointer tagging made a difference.
15:41:10 <salierix> Er.
15:42:05 <LoganCapaldo> Does  Language.Haskell parse all of H98?
15:43:36 <salierix> It would be interesting to make a graph showing ghc performance over time.
15:45:48 <bos> dcoutts: soonish
15:48:55 <sjanssen> LoganCapaldo: it doesn't support n+k patterns IIRC
15:49:11 <LoganCapaldo> I so don't care about those
15:50:56 <salierix> Why do n+k patterns even exist? I haven't really seen anyone use them yet.
15:51:24 <dolio> It allows you to use numbers as if they're defined inductively.
15:51:25 <LoganCapaldo> to write pretty looking versions of fobbonactorial
15:51:37 <LoganCapaldo> *fibbonatorial
15:51:42 <marceau> is (x:xs) not an "n+k" type pattern?
15:51:43 <LoganCapaldo> *fibonactorial
15:51:55 <LoganCapaldo> marceau: no
15:52:14 <thoughtpolice> marceau: not really, (x:xs) is a pattern match against lists, I believe n+k patterns are only for types of Num
15:52:21 <thoughtpolice> but I'm not really sure so take lots of salt with that
15:52:23 <marceau> i don't mean literally of course
15:52:27 <LoganCapaldo> > let f (n+1) = n in f 4
15:52:27 <lambdabot>  Parse error in pattern at "in" (column 17)
15:52:43 <byorgey> marceau: it's the same idea of destructuring an inductively defined data type, yes.
15:52:48 <marceau> if integers are defined inductively...
15:52:54 <LoganCapaldo> I can't even get teh example right
15:54:24 <ddarius> Integers aren't defined "inductively" in Haskell
15:55:22 <salierix> > (\(n+1) -> n) 5
15:55:22 <lambdabot>  Parse error in pattern at "->" (column 9)
15:55:50 <mauke> :t (\(n+1) -> n) 5
15:55:50 <salierix> Hmm, works in ghc.
15:55:52 <lambdabot> forall t. (Integral t) => t
15:55:54 <thoughtpolice> dons: btw I noticed your reference to harrop (i believe) in your comment on proggit, there a sort of beef there? :) if so I'd love to see links. usenet(?) wars intrigue me (i used to spend time on comp.lang.asm which was full of that)
15:56:09 <hpaste>  dbueno pasted "Interactive process interaction hanging" at http://hpaste.org/3700
15:56:21 <Cale> salierix: n+k patterns are kind of semi-deprecated
15:56:28 <dolio> @quote JonHarrop
15:56:29 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
15:56:37 <dbueno> Would someone be willing to dispense advice on interactive with interactive processes?
15:58:42 * Cale wonders about what buffering modes the handles returned by runInteractiveProcess are in.
15:59:03 <ivanm> dolio: as you have shown, JonHarrop speaks english goodly :p
15:59:12 <Cale> hmm, also endACL2 won't do anything
15:59:24 <chessguy> @quote
15:59:24 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
15:59:39 <byorgey> ivanm: I think you mean 'wellly' ;)
15:59:43 <chessguy> @source Prelude
15:59:44 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
15:59:46 <ivanm> heh
15:59:52 <dolio> Heh.
16:00:01 <dolio> @quote JonHarrop
16:00:01 <lambdabot> JonHarrop says: In Haskell, programmers write declaratively and often optimize by randomly fiddling until the current version of GHC happens to reduce it in an asymptotically more efficient way.
16:00:20 <chessguy> wow
16:00:28 <Cale> (return $ hPutStrLn stdin "(good-bye)\n") is an IO action which does nothing, but returns the IO action which if run, would put the string "(good-bye)\n\n" to the handle stdin
16:00:34 <dolio> He's a character.
16:00:45 <Cale> http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
16:00:47 <lambdabot> Title: Things that amuse me, http://tinyurl.com/25sj6t
16:00:49 <Cale> meanwhile...
16:00:51 <ivanm> dolio: whats his hex value? ;-)
16:00:52 <chessguy> @seen JonHarrop
16:00:53 <lambdabot> I haven't seen JonHarrop.
16:01:04 <dbueno> Cale: Won't the fact that endACL2 i occurs in the "do" in the IO monad result in forcing it?
16:01:20 <dolio> Those are quotes I pulled out of comp.lang.functional back when I was reading it.
16:01:25 <chessguy> ivanm, that was evil
16:01:26 <LoganCapaldo> Those quotes are from mailing list or wahtever aren't they?
16:01:31 <ivanm> chessguy: :D
16:01:35 <dons> LoganCapaldo: yeah
16:01:37 <Cale> dbueno: In order to run the hPutStrLn stdin "(good-bye)\n" which is returned by endACL2, you'd have to write:
16:01:45 <Cale> a <- endACL2 i
16:01:46 <Cale> a
16:01:51 <Cale> Or:
16:01:56 <Cale> join (endACL2 i)
16:02:14 <Cale> But the issue is really just that you shouldn't have that return there.
16:02:14 <dbueno> Cale: what about 'return $! hPutStrLn ...'
16:02:20 <Cale> That's exactly the same
16:02:22 <dbueno> Cale: Oh.
16:02:28 <Cale> Evaluating an IO action does nothing
16:02:29 <dbueno> Duh.
16:02:38 <Cale> It's only executing it that causes the effects to happen
16:02:53 <aixo> hello, can i express and discuse a problem or only it's for the compiler
16:02:58 <aixo> ?
16:03:03 <dbueno> Cale: Right; I thought 'do endACL2 i' would execute it.
16:03:16 <mauke> do X is just X
16:03:17 <chessguy> doesn't seem like there's that much to be gleaned from http://darcs.haskell.org/packages/base/Prelude.hs
16:03:22 <chessguy> aixo, fire away
16:03:44 <mauke> "do" is for wrapping more IO around something, not removing (= executing) it
16:03:48 <EvilTerran> @where prelude
16:03:49 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
16:04:00 <EvilTerran> ^^ that one tends to be more generally useful, chessguy
16:04:03 <aixo> sorry, i didn't want to bother
16:04:07 <aixo> bye
16:04:09 <chessguy> aha
16:04:09 <dbueno> mauke: Actually, I have 'do { ... ; endACL2 i; ... }
16:04:11 <ddarius> do neither "adds" nor "removes" IO
16:04:16 <chessguy> aixo, go ahead and ask
16:04:25 <chessguy> aixo, we love questions here
16:04:54 <aixo> oh, i just think that you want to qick me
16:05:13 <Cale> dbueno: it would if you didn't wrap the thing up using return
16:05:14 <aixo> my english is not good and i'm tired
16:05:30 * chessguy ties aixo down and forces him to ask the channel haskell questions
16:05:36 <hpaste>  dbueno annotated "Interactive process interaction hanging" with "No more return" at http://hpaste.org/3700#a2
16:05:37 <Cale> dblog: Note that (return $ hPutStrLn stdin "(good-bye)\n") :: IO (IO ())
16:05:45 <dbueno> Cale: Okay.  That's what I thought.  I've pasted a modified version.
16:05:59 <Taejo> aixo, nobody's going to do anything except help
16:06:38 <Cale> dbueno: One thing that you'll want to check is the buffering mode of the handles returned by runInteractiveCommand
16:06:45 <Cale> hGetBuffering will tell you that
16:06:53 <dbueno> Interestingly, the code gets to "matching..." before hanging.
16:06:58 <dbueno> Cale: Looking it up...
16:07:00 <Cale> You probably want line buffering
16:07:26 <aixo> i have a plain text file, inside i hav a table defined with the chars '+' and '-', i.ex.: +-----+
16:07:50 <aixo> i want to get this file and translate it to html
16:08:08 <zeeeee> is there a way to get ghc to compile haskell to some *readable* c source? this would be extremely valuable in understanding how haskell gets compiled, the performance costs of various constructs, etc.
16:08:12 <aixo> and i don't know yet how i would do it
16:08:25 <zeeeee> i tried ghc -C, but that basically produces assembly
16:08:34 <chessguy> aixo, that sounds interesting. what is your level of skill in haskell?
16:09:02 <enzo> > head [ tail [1,2,3] ]
16:09:07 <aixo> zero
16:09:11 <lambdabot>  [2,3]
16:09:26 <aixo> i only want the algorithm
16:09:26 <mauke> zeeeee: readable C means performance loss
16:09:31 <dons> aixo: so you can write a parser, and use the xhtml package to print it out as html
16:09:31 <enzo> head.tail[1,2,3]
16:09:36 <dons> that should be very easy
16:09:45 <aixo> but i don't find any channel to discuse my problem
16:09:49 <dbueno> Cale: BlockBuffering.
16:10:31 <zeeeee> mauke, i understand, but it's possible the result is usually not too far off
16:10:49 <chessguy> aixo, can you paste a small example table?
16:10:51 <chessguy> !paste
16:10:51 <hpaste> Haskell paste bin: http://hpaste.org/
16:10:58 <mauke> you may be better off looking at the generated core (disclaimer: I've never done that)
16:11:04 <dbueno> Cale: Were you suggesting I change all to LineBuffering, or just stdout?
16:11:15 <zeeeee> mauke, generated core?
16:12:12 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
16:12:14 <lambdabot> Title: 5.16. Debugging the compiler, http://tinyurl.com/t96uq
16:12:28 <Taejo> aixo, do you want to do this to learn haskell or because you need it done?
16:12:58 <LoganCapaldo> Hey IO doesn't have to be State RealWorld right? You could do it as Cont () or something couldn't you?
16:13:11 <enzo> Hi everyone, I'm just a beginner and I can't figure this out: I want to extract the 2nd element in a list of three elements. So I tried head [ tail [1,2,3] ] but I don't get 2 as my answer. Can anyone explain?
16:13:14 <aixo> i want a channel where discuse my problem
16:13:19 <joelr1> good evening
16:13:23 <ddarius> LoganCapaldo: IO doesn't -have- to be anything.
16:13:26 <bos> LoganCapaldo: ghc's IO was continuation based over a decade ago
16:13:28 <sjanssen> zeeeee: jhc tends to produce C code that is more readable
16:13:36 <joelr1> ChilliX: i'm still wondering why you can build ghc without a problem and i can't
16:13:42 <mauke> enzo: head [x] == x
16:13:52 <idnar> enzo: you're constructing a list of one element, the return value of tail; then you take the head of that list, giving you just the tail of [1,2,3]
16:13:56 <mauke> enzo: head [ tail [1,2,3] ] == tail [1,2,3] == [2,3]
16:14:04 <EvilTerran> > [tail [1,2,3]]
16:14:05 <lambdabot>  [[2,3]]
16:14:09 <EvilTerran> > (tail [1,2,3])
16:14:11 <lambdabot>  [2,3]
16:14:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3701
16:14:17 <LoganCapaldo> ddarius: well it has to be a Monad right? :)
16:14:18 <sjanssen> > head (tail [1, 2, 3])
16:14:20 <lambdabot>  2
16:14:25 <EvilTerran> [1,2,3]!!1
16:14:27 <idnar> enzo: you probably want head (tail [1,2,3]) or head . tail $ [1,2,3] or [1,2,3] !! 1
16:14:27 <zeeeee> sjanssen, that's surprising
16:15:38 <bos> LoganCapaldo: no
16:16:00 <sjanssen> zeeeee: why?  Compilation via ANSI C is one of JHC's primary goals, GHC only uses C because it doesn't have a really nice code generator yet
16:16:07 <zeeeee> mauke, hm. i think that would produce more questions than answers
16:16:25 <aixo> http://hpaste.org/3701
16:16:36 <zeeeee> sjanssen, i didn't know that. i just knew that jhc had aggressive optimization
16:16:42 <aixo> hey, i think i have a way to solve my problem
16:16:43 <ChilliX> joelr1: Using my binary can't you build ghc?
16:16:58 <ChilliX> I mean using my binary for bootstrapping.
16:17:02 <zeeeee> sjanssen, afaik ghc could be producing ansi c as well, laced with those stg macros
16:17:06 <aixo> just simplyfliying the problem
16:17:27 <joelr1> ChilliX: i can build but i don't get to run. still missing _environ
16:17:27 <LoganCapaldo> bos: no it doesn't have to be a monad?
16:17:31 <zeeeee> would be good if there was an example
16:17:35 <Taejo> yes, aixo?
16:18:18 <bos> LoganCapaldo: that's right.
16:18:39 <aixo> yes, while i was drawing it in a paper my mind only think in all the cases
16:18:42 <Cale> dbueno: Probably safest to have everything be line buffered
16:18:44 <LoganCapaldo> Don't thk it's haskell anymore then "To achieve this, Haskell uses a monad to integrate I/O operations into a purely functional context." -- http://www.haskell.org/onlinereport/io-13.html
16:18:52 <ChilliX> joelr1: That
16:18:56 <ChilliX> oops
16:18:59 <joelr1> ChilliX: that var lives in /usr/lib/*crt*.o which is supposed to be linked in by gcc automatically. i'm wondering if ghc doesn't do that somehow
16:19:04 <ChilliX> joelr1: That is strange
16:19:13 <bos> LoganCapaldo: no, that's just the convention. did you see my comment that haskell IO used to be continuation-based?
16:19:20 <aixo> the trees don't let me see the forest
16:19:51 <LoganCapaldo> I know you don't the IO monad to be pure functional but I'm pretty sure the report defines Haskell's I/O as monadic
16:19:56 <Cale> LoganCapaldo: I tend to think of IO as being a GADT which encodes descriptions of I/O actions
16:20:03 <Cale> something like...
16:20:09 <dbueno> Cale: So I line buffered both stdin to and stdout from the process (I don't even use stderr), and inserted print statements (which I annotated my original post with).
16:20:16 <Cale> http://hpaste.org/3673
16:20:22 <chessguy> @instances-importing Bounded
16:20:23 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
16:20:28 <ChilliX> joelr1: I wonder whether there is any other library (besides the GMP framework) that you have still from Tiger that might be picked up when compiling ghc on your machine.
16:20:32 <Cale> dbueno: and it's getting stuck?
16:20:35 <dbueno> And it still hangs, but only after the "matching ..." print statement.  And if I just "return True" instead of regex-matching, it works.
16:20:40 <Taejo> aixo, what I would do is: see where the +s are in the first row to find the column widths
16:21:10 <dbueno> Cale: I'm thinking maybe there's something weird about the semi-closed state hGetContents causes, since I send more input to the process after calling hGetContents
16:21:22 <Cale> oh
16:21:28 <Cale> yeah, that could be problematic
16:21:42 <aixo> yes, thats the idea
16:21:46 <joelr1> ChilliX: no, no, it's very simple: the ONLY place where that symbol exists is in /usr/lib/*crt*.o. the only place that refers to that symbol is hscore_environ in the bowers of ghc. so the only way to solve this is to link against /usr/lib/*crt*.o which is what gcc does.
16:21:50 <Cale> To be honest, I haven't used runInteractiveCommand all that much
16:21:56 <dbueno> But that should have nothing whatsoever to do with matching -- and if I remove matching, it works.
16:22:03 <Cale> There is a library which is supposed to make this sort of thing easier
16:22:18 <aixo> and if there is any error line then ignore it
16:22:21 <hpaste>  dbueno annotated "Interactive process interaction hanging" with "with line buffering" at http://hpaste.org/3700#a3
16:22:27 <joelr1> ChilliX: did you tweak any build settings when building your ghc?
16:22:45 <dbueno> Cale: Do you know which library?
16:22:53 <joelr1> ChilliX: could it be that by default ghc builds with -fasm and does not use gcc nowadays?
16:23:01 <Cale> dbueno: just looking for it
16:23:07 <dbueno> Basically I need to screen scrape the output of an interactive process -- I'm not married to hGetContents, it just seemed like the path of least resistance.
16:23:10 <dbueno> Cale, Thanks.
16:23:26 <ChilliX> joelr1: No, I did a vanilla compile
16:23:28 <dbueno> ... and I don't want to kill and re-start the process for every query.
16:23:32 <Cale> http://software.complete.org/hsh
16:23:33 <lambdabot> Title: HSH
16:23:36 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH-1.2.4
16:23:38 <lambdabot> http://tinyurl.com/2vmqhk
16:23:41 <joelr1> ChilliX: i'm baffled!
16:24:04 <dbueno> Cale: Looking....
16:24:37 <ChilliX> joelr1: I looked around on google a bit yesterday regarding _environ and people seem to stumble acorss this problem when upgrading macos or other BSD systems sometimes.
16:24:54 <ChilliX> It usually seemed to a matter of some outdated library lying around
16:25:15 <bos> dcoutts: http://koji.fedoraproject.org/koji/taskinfo?taskID=228690
16:25:17 <lambdabot> Title: Task Info | Koji
16:25:36 <ChilliX> joelr1: the big question is how to find that library
16:25:41 <joelr1> ChilliX: i just ran nm on the built ghc binaries in stage1 and stage2 and both define environ. looking further.
16:26:20 <ChilliX> Maybe if you compare the nm output of my binary versus the one you built
16:29:03 <Taejo> I hope he solved his problem
16:29:16 <joelr1> ChilliX: it all boils down to _environ. if it's there then it will run. D = run, U = won't
16:30:03 <ChilliX> And other Haskell programs that you compile with my binary are fine?  It's just ghc itself that you cannot compile?
16:30:05 <joelr1> ChilliX: now here's the weird bit! ghc in stage1 and 2 has it defined, right? i do an install and it disappears!!!
16:30:33 <Pseudonym> Why does Haskell and Fibonacci numbers seem to go together?
16:30:45 <exDM69> Pseudonym: :)
16:30:47 <joelr1> ChilliX: everything compiles. when you try to run ghc and it loads base, it discovers that base has extern _environ. so long as environ is in the ghc proper everything is fine
16:30:49 <ChilliX> joelr1: So can you run the compiler you compiled inplace?
16:30:50 <Pseudonym> http://andrew.bromage.org/fib.jpeg
16:31:05 <joelr1> ChilliX: how would i do that? sorry for the dumb question.
16:31:42 <ChilliX> joelr1: not dumb at all, I guess, it's a feature mostly used by developers: try teh folowing
16:31:57 <ChilliX>  compiler/stage2/ghc-inplace --interactive
16:32:08 <ChilliX> This is from the ghc source root
16:32:16 <joelr1> ChilliX: i think i found the reason. the size of the binaries in stage1 and 2 is different from installed ghc. which tells me something is stripping the installed binaries.
16:32:17 <chessguy> hm, there is indeed a lot of good stuff in the prelude
16:32:48 <ChilliX> joelr1: That should be the install-sh script
16:33:28 <joelr1> ChilliX: inplace is fine. again, environ is defined in both compilers. it disappears after installation so it must be something in the install script. maybe strip is being run on the installed binary. need to check
16:34:56 <ChilliX> joelr1:  I have -r-xr-xr-x  1 root  wheel  339664 Sep 24 08:42 /usr/bin/strip
16:35:15 <dbueno> Cale: Thanks for the pointer, but it looks like they provide nice ways of muxing fork() with other stuff.  In other words, the caller blocks until the process dies.
16:35:27 <dbueno> I need somehow to interactive with a process that stays alive.
16:35:30 <joelr1> ChilliX: install.sh can be invoked with -s to strip. trying to track down if that's being used
16:35:51 <joelr1> in fact, i'm just gonna run strip on the staged compiler to see if environ disappears
16:36:56 <joelr1> ChilliX: yep, that's it. strip blows away unused symbols, apparently. since environ is not being used it's being stripped.
16:37:13 <joelr1> ChilliX: the solution is to not run install.sh -s
16:38:07 <joelr1> ChilliX: i can't figure out who runs install-sh, though
16:38:16 <ac> silly question here: What's all y'all's favorite programming paradigm (as in, "constraint based", "data flow", "functional", "object oriented" (heh), etc?
16:38:31 <dons> ac, that's a silly question
16:38:38 <dons> ;)
16:38:46 <ac> I know, just oblige me
16:39:01 <dons> "effective"
16:39:02 <joelr1> ChilliX: be back shortly
16:39:25 <P_D> Anyone know what happened to --mk-dll?  Some alternative build method?
16:39:27 <idnar> that's kinda like asking what your favourite source of nourishment is, and listing "carbohydrates, proteins, vitamins" etc.
16:39:27 <joelr1> ChilliX: again, the issue is stripping of the ghc binaries during installation which removes _environ
16:39:58 <ac> would anybody agree with me that monadic operators tend to make your code look like data flow programming?
16:42:00 <davidL> dons: src/System/Plugins/PackageAPI.hs:64:20: Not in scope: data constructor `InstalledPackageInfo'  (plugins-1.0)
16:42:32 <dons> davidL: grab the darcs version. it won't work with 6.8 yet though
16:42:49 <davidL> same error with darcs :-\
16:43:08 <Pseudonym> ac: Yes and no.
16:43:10 <dons> hmm. the darcs version compiles for me with 6.6.x
16:43:19 <Pseudonym> I think arrow operators are worse in that respect.
16:43:30 <dons> oh, hmm. maybe the cabal lib changed, i haven't noticed
16:43:33 <davidL> dons: with darcs cabal?
16:43:41 <ac> Pseudonym: "worse" as in making it look more or less like data flow programming? ;)
16:43:53 <thoughtpolice> dons: any eta on when plugins will be ready for 6.8? or are you too busy to deal with it as of current? i would be interested in doing it myself, but i don't know much about linker internals or how exactly all of hs-plugins is organized, otherwise i'd give it a go.
16:44:08 <thoughtpolice> since my bot is just about ready it might be something fun and interesting to hack on until I find something else, though
16:44:18 <Pseudonym> More like braindead dataflow programming.
16:44:26 <Pseudonym> Nothing will make your code look like Euler.
16:44:37 <dons> thoughtpolice: no eta yet. i don't know of any major impediments though
16:44:52 <dons> thoughtpolice: i'd look seriously at using the ghc-api loader we wrote in yi
16:44:57 <Pseudonym> In fact, lazy streams probably make your code look more like good dataflow programming than anything else.
16:45:05 <dons> as that reuses more of ghc's internal code, and will break less often
16:45:11 <dons> also, you can load bytecode
16:45:45 <Pseudonym> Does anyone learn Jackson Standard Design any more?
16:46:15 <Pseudonym> Or whatever the hell it's called.
16:46:17 <thoughtpolice> dons: I still have my metaplug library around... i've had a version that should compile with 6.8 on my windows box, but the major limitation is the monomorphic restraint and apparently loading new object files into memory. although I can create a new ghc session with -fforce-recomp enabled, it doesn't reload new code...
16:46:25 <thoughtpolice> otherwise i'd have already migrated it, most likely
16:46:57 <ac> Pseudonym: I had in mind something like ">>=", where you chain together several functions and leave out the argument
16:47:04 <dons> thoughtpolice: right.
16:47:36 <Pseudonym> ac: That would be Kleisli composition.
16:47:41 <Pseudonym> i.e. arrow notation.
16:47:53 <thoughtpolice> there's an unload primitive in compiler/main/GHC.hs iirc though, which might solve the problem, but I've yet to invest enough time to get to the point where i can call it.
16:47:58 <Pseudonym> :t (@@)
16:48:00 <lambdabot> Not in scope: `@@'
16:49:09 <ArmchairDeity> random question: do you ever see people in here who are learning haskell for fun?
16:49:17 <thoughtpolice> dons: if I can get that fixed I think I'd remove the need for hs-plugins at that point; the only reason I haven't installed ghc 6.8 is because my irc bot requires hs-plugins because it does hot code swapping (applying the idea from the yi paper)
16:49:21 <Zao> ArmchairDeity: I do.
16:49:29 <Zao> ArmchairDeity: Learning Haskell for fun, that is.
16:49:30 <sjanssen> ArmchairDeity: that's probably the majority
16:49:38 <ArmchairDeity> cool... then I'm not THAT weird
16:49:39 <ArmchairDeity> :)
16:49:41 <thoughtpolice> and I haven't released it yet. plus it would just be nice if it could compile with 6.8 before I release it.
16:50:02 <LoganCapaldo> is anyone in here not in here for fun?
16:50:25 <thoughtpolice> dons: if it proves to be infeasible to unload code from memory using the ghc api though i might give a shot at hacking hs-plugins for the functionality... although it might be ugly as hell.
16:50:29 <chessguy> @losers
16:50:29 <lambdabot> Maximum users seen in #haskell: 424, currently: 379 (89.4%), active: 22 (5.8%)
16:50:30 <idnar> define "for fun"
16:50:36 <ArmchairDeity> ahh, I'm in the room to ask questions... I'm learning Haskell for fun (well, and just for the expansion)
16:51:07 <idnar> I'm not doing anything "practical" with Haskell at the moment, but I'd like to start using Haskell in my projects when it becomes feasible
16:52:09 <chessguy> @quote expand
16:52:10 <lambdabot> ghc says: Bad eta expand
16:52:32 <ArmchairDeity> cool... a friend of mine says Haskell is awesome and everyone should learn a funcitonal language
16:52:48 <ArmchairDeity> so I thought I'd take the plunge... I installed the Haskell plugin for Eclipse
16:52:53 <Pseudonym> ArmchairDeity: Actually, we like that better, a little.  You're unlikely to pass off a homework question to us. :-)
16:53:11 <ArmchairDeity> LOL pseudonym... that's awesome.
16:53:34 <faxathisia> Hello
16:53:40 * chessguy remembers writing all his scheme asignments in haskell and then porting
16:54:04 <faxathisia> Can I write my own 'deriving' thingy?
16:54:06 <chessguy> hi faxathisia
16:54:35 <mauke> faxathisia: no, unless you hack the compiler
16:54:36 <LoganCapaldo> @go TH Derive
16:54:38 <lambdabot> http://www.agu.org/pubs/crossref/1999/1998GL900262.shtml
16:54:38 <lambdabot> Title: An upper limit on the spontaneous fission decay constant of 232Th derived from x ...
16:54:50 <LoganCapaldo> I fail at @go
16:54:59 <chessguy> @go template haskell derive
16:55:01 <lambdabot> http://osdir.com/ml/lang.haskell.template/2005-01/msg00014.html
16:55:13 <chessguy> heh
16:55:17 <chessguy> not much better :)
16:55:38 <hpaste>  Saizan pasted "is this a bug?" at http://hpaste.org/3702
16:55:44 <LoganCapaldo> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
16:55:44 <lambdabot> Title: Data.Derive: A User Manual
16:55:59 <kawfee> Anyone heard of RPI.edu?
16:56:34 <sjanssen> Saizan_: Double isn't an instance of Monoid because there are several reasonable choices
16:56:36 <davidL> I get mail from them all the time, I don't know if that counts :-\
16:57:06 <faxathisia> :D
16:57:07 <Saizan_> sjanssen: err, the point is that GHC is complaining about a lack of Monoid instead of a lack of Zero
16:57:12 <faxathisia> I'll try template haskell soon
16:57:34 <Saizan_> +instance of
16:57:50 <dbueno> Does anyone know why the System.Process.runInteractiveProcess doc recommends using forkIO to run hPutStr?
16:57:53 <dbueno> http://haskell.org/ghc/docs/latest/html/libraries/process-1.0.0.0/System-Process.html
16:57:55 <lambdabot> http://tinyurl.com/2b9tjj
16:58:31 <sjanssen> Saizan_: hmm, hard to say
16:58:48 <dons> yeah, that's a jaffacake-ism
16:58:56 <ArmchairDeity> this is a cool room
16:58:57 <dataangel> From http://www.haskell.org/haskellwiki/Monads_as_containers : "Like Haskell lists, all the elements which a monadic container holds at any one time must be the same type (it is homogeneous)." Every example I see of Monads has them being a container for only one type anyway. IO () not IO Int () Char :P Are some monads associated with multiple types or something? I don't see how that comes out to multiple objects either...
16:58:58 <lambdabot> Title: Monads as containers - HaskellWiki
16:59:02 <ArmchairDeity> geekier than most I hang out in... I like ti
16:59:23 <LoganCapaldo> @instances-importing Monoid
16:59:24 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
16:59:49 <LoganCapaldo> Isn't it Sum Double or Product Double ?
16:59:55 <chessguy> dataangel, no, they're all one type, that's the poing
17:00:10 <LoganCapaldo> I don't think there's a Monoid instance for Int Double, etc.
17:00:28 <Saizan_> i should have used a Foo class..
17:01:12 <davidL> dons: what version of cabal do you use to build hs-plugins?
17:01:30 <dataangel> chessguy: I guess the part I'm confused about is: what are the elements which a monadic container holds? Before I thought that the M in "M a" was a constructor, not a type constructor, so it seemed like there was one value of type "a" associated with the monad, but now it's talking about multiple values, so I'm confused.
17:01:30 <dons> i used 1.16 last time, since it only builds with ghc 6.6.x anyway
17:01:50 <scook0> dataangel: remember that [] is a monad
17:02:01 <LoganCapaldo> oh wait
17:02:03 <LoganCapaldo> nvm
17:02:09 <LoganCapaldo> that's totally bizzare
17:02:11 <mauke> dataangel: a monadic container doesn't have to contain any elements
17:02:13 <dataangel> scook0: I don't know enough about monads to understand why
17:02:15 <LoganCapaldo> ignore me
17:02:16 <chessguy> dataangel, personally, i don't like the metaphor of a monad as a container
17:02:23 <mauke> that's because monads aren't containers :-)
17:02:33 <scook0> like all monad metaphors, it has its ups and downs
17:02:37 <kawfee> mauke!
17:02:39 <kawfee> hrm
17:02:43 <kawfee> wtf is mauke doing in here
17:02:48 <kawfee> I thought this was #c when I saw him
17:02:49 <mauke> being awesome, as usual
17:02:54 <goalieca> monads are condoms
17:03:02 <kawfee> are not
17:03:07 <kawfee> condoms ruin the fun
17:03:16 <goalieca> monads protect you from nasty io effects
17:03:20 <goalieca> just like a condom
17:03:20 <kawfee> right
17:03:23 <mauke> unsafePerforateIO
17:03:23 <chessguy> scook0, oh, i get it! so a monad is something for which metaphors to describe it are only partially accurate
17:03:27 <kawfee> condoms suck
17:03:43 <goalieca> kawfee codes in ocaml
17:03:45 * chessguy has a blinding flash of understanding
17:03:54 <kawfee> liar
17:03:56 <scook0> a monad is an endofunctor equipped with a pair of natural transformations obeying particular laws
17:03:58 <goalieca> nasty animal those camels
17:04:10 <scook0> any other description is necessarily an approximation
17:04:16 <ari> Monads are fractals?
17:04:30 <kawfee> I got mo monads than you.
17:04:31 <goalieca> category theory to me.. looks a lot like group theory.. but way more abstract and nonsense
17:04:42 <joelr1> ChilliX: back
17:04:48 <kawfee> monads provide protection
17:04:56 <scook0> goalieca: that is more or less the point, I think ;)
17:04:57 <kawfee> like a black box
17:05:08 <dataangel> I just don't see how monads are containing anything
17:05:12 <mauke> or a transparent box, in the case of Identity
17:05:25 <chessguy> dataangel, in the same way that functions "contain" things
17:05:35 <goalieca> i can see the whole point of lambda calculus.. and recursion and combinators and that.. but category theory seems absolute bs
17:05:40 <scook0> some monads are indeed "containers", like [], Maybe, and Identity
17:05:55 <scook0> for other monads, the "container" interpretation needs some creativity
17:06:04 <dataangel> In the IO monad for example, it seems like monads are a fancy hack for forcing evaluation order by making each step an argument to the next step, very continuation style-y. But I don't see how anything is contained :/
17:06:07 * goalieca says monads are a hack to let haskell do imperative coding :P
17:06:14 <mauke> thinking in terms of fmap/join helps with that
17:06:18 <faxathisia> goalieca: not really
17:06:19 <SamB_XP> goalieca: the IO monad is
17:06:20 <lambdabot> SamB_XP: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:24 <SamB_XP> @messages
17:06:24 <chessguy> Cale's difintion of container in this instance is a little different from what most would think of
17:06:24 <lambdabot> ndm said 4h 7m 53s ago: the GHC release added version numbers in packages, i intend to unbork them tomorrow
17:06:26 <scook0> e.g. a value (IO a) is essentially an imperative program that "contains" a value of type a as its return value
17:06:26 <mauke> dataangel: IO is a magic box
17:06:31 <faxathisia> goalieca: look at the List monad
17:06:44 <idnar> dataangel: well, you could say that IO String is a funny thing that "contains" a String value
17:06:51 <faxathisia> goalieca: you can use it in a much more declarative way really
17:06:56 <dataangel> oic
17:07:00 <mauke> dataangel: opening the box has the side effect of creating the value inside on the fly
17:07:23 * SamB_XP hands idnar an unsafePerformIO
17:07:23 <scook0> a value in the Reader monad contains a family of values indexed by the context value supplied
17:07:24 <sorear> Pseudonym++
17:07:38 <ArmchairDeity> hey seancorfield
17:07:40 <chessguy> lately, i've been thinking of monads as a way to combine functions together
17:08:15 <dataangel> idnar: Still, then it seems like there is only one value
17:08:30 <idnar> dataangel: some monads can only contain a single value
17:08:40 <mauke> dataangel: every time you open the box you can see a different value
17:08:50 <mauke> but yes, conceptually every box contains a single value
17:08:56 <scook0> IO (Either AliveCat DeadCat)
17:09:24 <Pseudonym> sorear: What's that for?
17:09:40 <sorear> Pseudonym: Clever use of arcane mathematics award
17:09:45 <Pseudonym> Ah.
17:09:52 <Pseudonym> The fibonacci generator?:
17:09:56 <sorear> yes
17:09:57 <ivanm> sorear: where?
17:10:02 <faxathisia> I missed it ;\
17:10:05 <Pseudonym> ivanm: haskell-cafe
17:10:10 <sorear> ivanm: On the mailing list, grep for field extension
17:10:49 <idnar> scook0: Schroedinger's Monad?
17:11:21 <scook0> well, more like Schroedinger's monadic value, since the actual monad is IO
17:11:55 <scook0> but there's probably a way to define a Schroedinger monad :)
17:12:01 <idnar> Schroedinger's Monadic Cat
17:12:07 <goalieca> Maybe Maybe?
17:12:19 <P_D> IO.
17:12:20 <LoganCapaldo> Mu Maybe
17:12:27 <chessguy> i believe sigfpe was doing some work on defining quantum mechanics in haskell
17:12:35 <scook0> actually, I wonder if Schroedinger's box would be a "good" metaphor for different monads
17:12:49 <goalieca> chessguy, great.. then we can use haskell on quantum computers :P
17:12:54 <LoganCapaldo> a metaphor based ona metaphor?
17:12:59 <chessguy> goalieca, not likely
17:13:01 * goalieca head asplode
17:13:17 <LoganCapaldo> I don't know if that's a good idea
17:13:37 <scook0> LoganCapaldo: well, I think you've answered my question :)
17:13:44 <idnar> more like emulating a quantum computer in haskell
17:13:47 <chessguy> oh, for a minute, i thought LoganCapaldo was recommending against allowing one's head to explode
17:13:58 <idnar> hahaha
17:14:05 <goalieca> WIkipedia's category theory page: http://en.wikipedia.org/wiki/General_abstract_nonsense
17:14:13 <scook0> that would be a rather closed-minded attitude to take
17:14:15 <scook0> (zing!)
17:14:31 <chessguy> wow
17:14:36 <chessguy> that was awful
17:14:41 * faxathisia cries
17:14:43 * idnar cringes
17:14:47 <scook0> \o/
17:14:53 <idnar> you must be related to me, that kind of awfulness runs in my family
17:15:38 <chessguy> idnar, that must be relatively awful
17:15:44 <faxathisia> @index on
17:15:44 <lambdabot> bzzt
17:15:50 <faxathisia> :O
17:16:23 <ivanm> Pseudonym, sorear: can't seem to find it :s ... maybe I accidentally deleted that digest...
17:16:29 * ivanm goes to look online
17:16:42 <faxathisia> @hoogle (a -> a -> b) -> (a -> c) -> (c -> c -> b)
17:16:43 <lambdabot> No matches, try a more general search
17:16:47 <idnar> chessguy: it's dead funny actually
17:16:59 <idnar> chessguy: my grandfather died a few years ago
17:17:02 * idnar runs
17:17:21 <faxathisia> > ((== `on` (`mod` 3) 1 4)
17:17:21 <lambdabot> Unbalanced parentheses
17:17:39 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2007-November/034174.html
17:17:40 <lambdabot> Title: [Haskell-cafe] Fibbonachi numbers algorithm work TOO slow., http://tinyurl.com/278hup
17:17:57 <Saizan_> Leonardo of Pisa? he meant "da Vinci" i suppose, and i don't recall any connection with Fibonacci..
17:18:24 <ivanm> Pseudonym: hmmm.... don't recall seeing that one at all...
17:18:24 <faxathisia> Saizan_: http://en.wikipedia.org/wiki/Fibonacci
17:18:25 <lambdabot> Title: Fibonacci - Wikipedia, the free encyclopedia
17:18:28 <mauke> Saizan_: wtf?
17:18:35 <faxathisia> Fibonacci is his nickname :p
17:18:38 <ivanm> unless you just sent it so I haven't gotten it yet?
17:19:47 <Saizan_> ok, just never seen the real name..
17:20:02 <faxathisia> > (== `on` (`mod` 3) 1 4)
17:20:02 <lambdabot>  Parse error at "`on`" (column 5)
17:20:40 <faxathisia> @pl (\x y -> (x mod 3) == (y mod 3))
17:20:40 <lambdabot> (. flip ($ mod) 3) . (==) . flip ($ mod) 3
17:21:49 <faxathisia> :t on
17:21:51 <lambdabot> forall t1 t2 t. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
17:21:57 <faxathisia> @docs on
17:21:58 <lambdabot> on not available
17:22:00 <LoganCapaldo> @type (`id`)
17:22:02 <lambdabot> parse error on input `)'
17:22:26 <faxathisia> > (== `on` (`mod` 3)) 1 4
17:22:27 <lambdabot>  Parse error at "`on`" (column 5)
17:22:34 <LoganCapaldo> @type \x -> (`id` x)
17:22:36 <lambdabot> forall t t1. t -> (t -> t1) -> t1
17:22:38 <faxathisia> > ((== `on` (`mod` 3)) 1 4
17:22:38 <lambdabot> Unbalanced parentheses
17:22:42 <faxathisia> > ((==) `on` (`mod` 3)) 1 4
17:22:44 <lambdabot>  True
17:22:47 <faxathisia> >:|
17:22:48 <prophet_> The monads as containers page explains how >>= would be fined if fmap/join were primitives. How would fmap as a primitive work? How would you know what's "contained" in a monad, so that you can apply the given function?
17:23:20 <mauke> prophet_: you know it because you defined the monad in question
17:23:25 <faxathisia> Where is on from?
17:23:29 <LoganCapaldo> prophet_: it would depend on the monad. for list it's map for instance
17:23:48 <Saizan_> ?index on
17:23:48 <lambdabot> bzzt
17:23:54 <Saizan_> Data.Function?
17:23:57 <LoganCapaldo> Same as when >>= is the primitive
17:24:05 <P_D> Is GHC thread safe?  Can I use the windows thread creation functions on foreign export funcs?
17:24:21 <scook0> 6.8 has it in Data.Function
17:24:31 <faxathisia> I better get 6.8 ..
17:24:47 <scook0> or you could just define your own
17:25:02 <faxathisia> ?djinn (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
17:25:03 <lambdabot> f a b c _ = a (b c) (b c)
17:25:26 <scook0> heh, I think I've tried that one before :)
17:25:32 <faxathisia> @@ ?djin :t on
17:25:32 <lambdabot> Plugin `compose' failed with: Unknown command: "djin"
17:25:35 <faxathisia> hmm :|
17:25:39 <faxathisia> @@ ?djinm :t on
17:25:39 <lambdabot> Plugin `compose' failed with: Unknown command: "djinm"
17:25:49 <scook0> on bin proj x y = (proj x) `bin` (proj y)
17:26:13 <firefly> if the ghc 6.6.1 terminates abruptly with exit code 141, would anybody happen to know why?
17:26:29 <prophet_> "The list monad, in some sense, models computations which could return any number of values... Such computations are known in computer science as nondeterministic." Is that really true? I thought nondeterministic meant there were multiple routes that can be taken (like in NFAs). Is there some other context where it means variable number of return values?
17:26:42 <prophet_> whoops
17:27:04 <LoganCapaldo> teh variable number of rturn values are results of taking those alternate routes
17:27:07 <firefly> (I'm using runInteracticeCommand/ waitForProcess together with forkIO to pass data in and out of the processes stdin/stdout)
17:27:22 <scook0> dataangel: it's nondeterministic "from a certain point of view"
17:27:25 <firefly> my program doesn't run to completion, it just halts.
17:27:40 <chessguy> > do { x <- [1..5]; y <- [1..5]; return (x,y) }
17:27:40 <dataangel> LoganCapaldo: NFAs still either fail or accept (only 1 return value)
17:27:42 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
17:27:52 <firefly> Same thing happens inside of ghci -- ghci abruptly terminates with exit code 141 (as determined by echo $?)
17:27:59 <firefly> There are no error messages of any sort.
17:28:17 <chessguy> prophet_, in the above code, you could see x and y as being chosen non-deterministically
17:28:23 <mauke> dataangel: the values are the routes through the NFA
17:28:24 <LoganCapaldo> dataangel: I do not see how that is relevant?
17:28:26 <Cale> dataangel: In a nondeterministic Turing machine, all possible paths are taken
17:28:40 <chessguy> err, dataangel ^^
17:29:48 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (100*x+10*y+z)
17:29:50 <lambdabot>  [146,147,148,156,157,158,246,247,248,256,257,258,346,347,348,356,357,358]
17:30:04 <Raguel> hmm
17:30:17 <Raguel> starting learning haskell from the bottom
17:30:19 <Raguel> with hugs
17:30:26 <Raguel> and trying to do 7 'div' 3
17:30:31 <Cale> 7 `div` 3
17:30:36 <Raguel> ooer
17:30:41 <Raguel> ah `
17:30:44 <Cale> right
17:30:45 <Raguel> that makes more sense
17:30:51 <Raguel> :)
17:30:56 <dataangel> Cale: err, I guess NFAs aren't the best example, but a nondeterministic algorithm for example doesn't necessarily have multiple return values
17:31:17 <Cale> dataangel: well, it might only end up resulting in one
17:31:22 <Cale> dataangel: But that's a special case
17:31:34 <SamB_XP> yeah, it need not be the case
17:31:48 <Cale> dataangel: The point is that intermediate computations are allowed to try multiple values.
17:32:18 <Cale> or have multiple results which are treated one at a time
17:32:29 <Cale> (or in parallel, if you'd prefer)
17:32:55 <dataangel> k, I think I follow
17:33:24 <Raguel> yay i writed a program that works :)
17:33:30 * Raguel is proud of himself
17:33:39 <Raguel> ... i'll be quiet now
17:33:40 <davidL> is the definition for the fibonacci sequence flexible? ie, can the first term in the sequence be either 0 or 1?
17:33:58 <cafr> > ((==) `on` (`mod` 3)) 1 4
17:34:00 <lambdabot>  True
17:34:11 <Cale> Raguel: What does your program do?
17:34:16 <chessguy> davidL, hmm, maybe a question for #math?
17:34:22 <Cale> davidL: sure, like anything in mathematics
17:34:39 <Raguel> cale: it double and quadruples numbers
17:34:54 <Raguel> double x = x + x stuff
17:34:58 <Cale> ah :)
17:35:13 <Raguel> i have 7 hours till i go to lectures...
17:35:16 <davidL> well someone on the mailing list corrected this: fibs = 1 : 1 : zipWith (+) fibs (tail fibs) to this: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:35:22 <omnId> Cale knows all about those programs :)
17:35:24 <SamB_XP> Raguel: you might want some sleep then
17:35:27 <chessguy> Raguel, plenty of time to write a chess program
17:35:33 <cafr> davidL: if you go by the closed form solution that jerzy gave, it's 1. Of course, one may argue whether that's /the/ closed form.
17:35:59 <Raguel> sam: sleep is for people who have too much time on their hands
17:36:08 <Raguel> chess: hehe - sure why not ;)
17:36:09 <chessguy> @pl \x -> x + x
17:36:09 <lambdabot> join (+)
17:36:14 <joelr1> dons: where can i read more on constructor specialization?
17:36:16 <SamB_XP> Raguel: you'd be surprised
17:36:24 <SamB_XP> I think my time works better when I sleep more
17:36:34 <chessguy> > (join (+)) 2
17:36:35 <faxathisia> :t join
17:36:37 <lambdabot>  4
17:36:37 <LoganCapaldo> again with the denigration of sleep. Sleep is good people! I promise!
17:36:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:36:40 <Raguel> sam: i have stuff to get done and i'm cutting down to 3 hours
17:36:49 <Raguel> sleep IS fun
17:36:57 <Cale> davidL: Some people find it nicer to have F_n = n for n < 2
17:37:07 <dons> joelr1: there's spj's last paper
17:37:15 <Raguel> and i now do it purely for recreation and mental maintinence
17:37:15 <SamB_XP> Raguel: when you have things to get done is an especially good time to sleep
17:37:22 <Pseudonym> Obviously not for n < 0
17:37:30 <joelr1> dons: got a pointer?
17:37:35 <faxathisia> Which monad is + ? :|
17:37:40 <Pseudonym> But yeah, f 0 = 0, f 1 = 1 makes a certain amount of sense.
17:37:46 <Raguel> sam: what if you could cut out the need for catch up sleep and the feeling of being tired?
17:37:47 <dons> ?google constructor specialisation site:microsoft.com
17:37:47 <Cale> Pseudonym: what are these "negative numbers" you speak of? :)
17:37:48 <lambdabot> http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
17:37:48 <lambdabot> Title: Constructor specialisation for Haskell programs
17:37:49 <thoughtpolice> http://research.microsoft.com/~simonpj/papers/spec-constr/index.htm
17:37:50 <lambdabot> Title: Constructor specialisation for Haskell programs, http://tinyurl.com/2qf2ur
17:37:52 <faxathisia> :t join (+)
17:37:54 <lambdabot> forall a. (Num a) => a -> a
17:37:54 <thoughtpolice> damn, lambdabot beat me :(
17:37:55 <chessguy> joelr1, no pointers allowed in here! try ##c++
17:38:02 <SamB_XP> Raguel: you can't catch up much sleep...
17:38:04 <Pseudonym> The question is actually not whether or not Fibonacci numbers start at zero, but whether or not counting starts at zero.
17:38:05 <Cale> davidL: But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
17:38:07 <davidL> Well some interesting properties emerge when you let the first term = 0, like if m divides n then Fib(m) divides Fib(n)
17:38:10 <faxathisia> is Num a monad?
17:38:15 <Pseudonym> Do you start at fib 0 or fib 1?
17:38:25 <thoughtpolice> Num is a typeclass.
17:38:28 <Raguel> sam: i don't catch up sleep, i just use drugs that allow me to go without
17:38:30 <faxathisia> Fib(0) = 0, Fib(1) = 1 is a reasonable definition
17:38:33 <chessguy> @instances-importing Monad
17:38:34 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:38:37 <LoganCapaldo> @remember Cale But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
17:38:38 <lambdabot> Nice!
17:38:43 <Raguel> sam: its very useful
17:38:47 <SamB_XP> Raguel: even on adderall I still need a good deal of sleep
17:38:52 <Pseudonym> You can extend fibonacci numbers to negative indices using f(n+1) = f(n) + f(n-1)
17:39:10 <faxathisia> I don't understand join at all :|
17:39:21 <joelr1> dons, thoughtpolice: thanks
17:39:24 <SamB_XP> Cale: instead, it is a council of math professors
17:39:26 <Raguel> sam: there there - i have a LOT to get done and therefore NEED the night - if only for recreation
17:39:27 <faxathisia> how can you apply it to (+)? since it requires a Monad?
17:39:32 <Cale> faxathisia: join x = do y <- x; z <- y; return z
17:39:36 <davidL> my teacher nearly kicked me out of class when I argued with him that the fibonacci sequence starts at 0 :-(
17:39:37 <Cale> ah
17:39:43 <Cale> Hehe, that's the ((->) e) monad
17:39:47 <Raguel> monad just reminds me of ergo proxy
17:39:58 <faxathisia> Cale: How do you pronounce that?
17:40:01 <Cale> That is, functions from a fixed type e
17:40:11 <SamB_XP> except they usually actually have two or three councils
17:40:16 <Cale> Sometimes known as the (lightweight) reader monad
17:40:25 <faxathisia> ((->) e) is anything from e -> e ?
17:40:36 <Raguel> btw does it unsettle anyone that there isn't a formal semantics for haskell?
17:40:36 <Cale> ((->) e) a = e -> a
17:40:44 <faxathisia> hm
17:40:47 <faxathisia> ok thanks Cale
17:40:49 <SamB_XP> Raguel: a little bit
17:40:50 <faxathisia> I better find out about reader monad
17:40:50 <Cale> Raguel: There used to be. It would be nice to have.
17:40:55 <Cale> faxathisia: I'll explain
17:40:58 <SamB_XP> Cale: where did it go?
17:41:03 <Raguel> its like someone got drunk, invented a gadget, then when he woke up couldn't quite draw a blueprint
17:41:12 <Raguel> and i'm guessing it got swallowed when bits were added?
17:41:13 <LoganCapaldo> ((->) e) is one of my favoritest monads
17:41:16 <sethk> Raguel, how did you know I got drunk?
17:41:18 <SamB_XP> Raguel: at least we have some microsemantics
17:41:25 <Cale> faxathisia: Basically, in that monad, to "run" a computation, you apply it to the parameter which the overall computation has been applied to
17:41:29 <Cale> So for example
17:41:37 <Raguel> drunk and programming go hand in hand
17:41:45 <chessguy> @remember Raguel does it unsettle anyone that there isn't a formal semantics for haskell? its like someone got drunk, invented a gadget, then when he woke up couldn't quite draw a blueprint
17:41:46 <lambdabot> I will never forget.
17:41:47 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
17:41:49 <lambdabot>  ("hello","olleh","HELLO")
17:41:50 <Raguel> or at least hand in bowl of warm water
17:42:25 <Cale> SamB_XP: Haskell changed, but nobody bothered to update the formal semantics
17:42:30 <SamB_XP> Cale: ah
17:42:36 <SamB_XP> Cale: that sounds about right ;-)
17:42:43 <cafr> LoganCapaldo: yeah the exponent monad is cool
17:42:50 <Raguel> i vote graham hutton does it
17:42:53 <SamB_XP> I guess that's why we have the microsemantics nowadays?
17:42:57 <faxathisia> Cale: You know when you say "run" a computation of a Monad.. is the actual running just some concept which you have a couple rules about.. and derive >>= and return from those rules?
17:44:04 <Cale> Well basically, it's the stuff which is going on inside of (x >>= f) in order to take the result of x and be able to apply f to that.
17:44:40 <Raguel> and come to think of it he's probably gonna read this log and then tell me on thursday why he doesn't have time to ;)
17:44:52 <Cale> So, what has to happen in order to turn a value of type M a into a value of type a so that bind can apply the function of type a -> M b which it gets?
17:45:17 <faxathisia> ah ok
17:45:18 <Cale> In this case, a value of type M a is just a function e -> a
17:45:33 <Cale> and the whole computation is a function e -> b
17:45:37 <firefly> where can I see what exit codes the GHC runtime may halt with?  I'm trying to find out what 141 means.
17:45:54 <firefly> (on Ubuntu Gutsy Gibbon, ghc 6.6.1)
17:46:00 <Cale> So it can just take the parameter of type e which it gets and use it to turn x :: e -> a into a value of type a
17:46:16 <sw17ch> how does one parameterize datatypes in a 'data'
17:46:41 <omnId> sw17ch: put type parameters on the data's lhs.
17:46:54 <chessguy> sw17ch, Tree is a good example: data Tree a = Leaf a | Branch (Tree a) (Tree a)
17:46:59 <chessguy> something along those lines
17:47:03 <omnId> data ParamdType a = Blah a | Foo a a
17:47:06 <faxathisia> Cale: I see, thanks :D
17:47:15 <sw17ch> merci beacoup!
17:47:20 <sw17ch> omnId++ chessguy++
17:47:27 <faxathisia> Cale: And reader is some generalization of ((->) e)?
17:47:27 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
17:47:29 <chessguy> de nada
17:47:29 <lambdabot>  [5,7,10,25,32]
17:47:40 <Cale> reader is just ((->) e) wrapped up in a newtype
17:48:39 <faxathisia> What's the point in that? :|
17:48:52 <cafr> clarity
17:49:08 <cafr> the two monads are semantically equivalent
17:49:14 <Cale> faxathisia: sometimes it makes things more obvious, sometimes it's just annoying
17:49:26 <faxathisia> *g*
17:49:35 <faxathisia> so I just learned how 2 new monads work at once
17:49:54 <faxathisia> thanks a lto
17:49:57 <faxathisia> *lot
17:50:10 <Cale> So do you see how join works now?
17:50:14 <faxathisia> yeah
17:50:18 <faxathisia> It's very clever
17:52:08 <faxathisia> I can't think of any functions of type m (m a) though
17:52:15 <faxathisia> other than in ((->) e))
17:52:24 <Cale> Well, try the list monad
17:52:25 <LoganCapaldo> return . return
17:52:31 <faxathisia> ok
17:52:40 <Cale> There, m (m a) is just [[a]]
17:52:53 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
17:52:55 <lambdabot>  [1,2,3,4,5,6,7,8]
17:52:57 <pjd> Maybe (Maybe a)
17:53:07 <LoganCapaldo> I want to solve a sudoku.
17:53:18 <LoganCapaldo> in the type system.
17:53:23 <Raguel> ooo
17:53:27 <omnId> > join (Just (Just 1))
17:53:28 <lambdabot>  Just 1
17:53:51 <idnar> > join Nothing
17:53:52 <lambdabot>  Nothing
17:54:03 <Cale> Who had the question about the GHC exit codes?
17:54:12 <omnId> @src join
17:54:12 <lambdabot> join x =  x >>= id
17:54:20 <omnId> @src Maybe (>>=)
17:54:21 <lambdabot> (Just x) >>= k      = k x
17:54:21 <lambdabot> Nothing  >>= _      = Nothing
17:54:23 <pjd> > join $ Just Nothing
17:54:24 <lambdabot>  Nothing
17:54:32 <Cale> Oh, firefly.
17:54:34 <chessguy> @undo do y <- x; z <- y; return z
17:54:34 <lambdabot> x >>= \ y -> y >>= \ z -> return z
17:54:41 <firefly> Cale, I did.
17:55:00 <chessguy> @pl \x -> x >>= \ y -> y >>= \ z -> return z
17:55:00 <lambdabot> join
17:55:03 <chessguy> bah
17:55:07 <firefly> I just apt-got the source for ghc6 and grepped for 141 but didn't find anything interesting.
17:55:20 <sorear> firefly: what's 141?
17:55:28 <Cale> firefly: http://darcs.haskell.org/ghc-6.8/ghc/rts/Main.c seems to use constants, and I don't know where they're defined
17:55:36 <firefly> the exit code that the runtime system aborts with :(
17:55:46 <sorear> firefly: 141 isn't an exit code
17:56:01 <sorear> firefly: bash does very stupid things with the kernel status indicator
17:56:01 <firefly> Oh, right, bit 7 is set, you mean?
17:56:12 <sorear> firefly: what you're actually seeing is signal 17
17:56:45 <sorear> firefly: what does kill -l say?  (signal numbers are not portable)
17:56:55 <firefly> 17, how so?
17:56:58 <firefly> 17 = SIGCHLD
17:56:58 <SamB_XP> sorear: is signal 11 portable?
17:57:29 <sorear> SamB_XP: yes, as is 9, but Old Unix didn't even *have* signals 16+
17:57:43 <SamB_XP> 'cause I got signal 11 even in DOS
17:57:53 <firefly> shouldn't I get an exception instead of the runtime system aborting?
17:58:02 <firefly> It happens even from within ghci!
17:58:10 <sorear> firefly: of course!
17:58:10 <Cale> firefly: which version of ghc?
17:58:15 <sorear> firefly: this is a BUG
17:58:19 <sorear> 17:26 < firefly> if the ghc 6.6.1 terminates abruptly with exit code 141, would anybody happen to know why?
17:58:21 <firefly> 6.6.1
17:58:24 <Cale> ah
17:58:25 * chessguy always gets a chuckle out of hearing sorear talking about how things _used_ to be, and knowing that he's probably talking about a time before he was even alive
17:58:40 <SamB_XP> chessguy: what is so funny about that?
17:58:41 <Raguel>  heh
17:58:47 <sorear> I've got a freakish memory for historical texts
17:58:57 <SamB_XP> we are so young half the stuff worth talking about happened before we were born
17:59:01 <sw17ch> @paste
17:59:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:59:16 <Raguel> sam: the irony of remembering the good old times when they predate your memory
17:59:26 <chessguy> sorear, i think you've just got a freakish memory period :)
17:59:31 <sorear> firefly: http://hackage.haskell.org/trac/ghc/wiki/ReportABug
17:59:32 <Raguel> sam: its like saying "i miss queen victoria"
17:59:33 <lambdabot> Title: ReportABug - GHC - Trac
17:59:44 <chessguy> ah yes, good old vickie
17:59:50 <Raguel> now that was a kickass queen
17:59:51 <SamB_XP> Raguel: I could, you know, actually run ancient UNIX...
17:59:53 <firefly> yeah, I guess I'll have to report it.
17:59:59 <enzo> Does anyone know of a self-explanatory tutorial on on web programming in Haskell for someone with NO experience in web programming?
18:00:01 <Raguel> queen victoria ran linux
18:00:03 <Cale> firefly: is there a particular program which you're running or does this just happen on its own?
18:00:04 <SamB_XP> except that I couldn't stand the terminal
18:00:13 <firefly> I just thought I would pop in here to get help on either working around it or reporting it better.
18:00:28 <Raguel> enzo: i can recommend you the book i have in my hand - programming in haskell by graham hutton
18:00:36 <SamB_XP> (believe me, I've tried it. having no working backspace is NOT FUN!)
18:00:41 <firefly> Cale, I'm running "cat xxx" with runInteractiveCommand
18:00:43 <sorear> enzo: You don't want to do web programming
18:00:52 <sorear> SamB_XP: I presume you tried #? :P
18:01:03 <SamB_XP> tried #?
18:01:09 <hpaste>  sw17ch pasted "AST: Second Try" at http://hpaste.org/3703
18:01:09 <Raguel> wow - i'd just been using /=/
18:01:09 <enzo> no I do
18:01:10 <sw17ch> omnId: is there any way to reduce the redundant looking code (Representations and Values) in my paste?
18:01:15 <firefly> then I use forkIO (or forkOS) to give it some input, just for kicks, plus read its output.
18:01:18 * chessguy "does web programming" for a living, and wonders what's so bad about it
18:01:23 <sorear> SamB_XP: yes, teletype era UNIX processed   ld#s   as   ls
18:01:35 <Cale> !paste
18:01:35 <hpaste> Haskell paste bin: http://hpaste.org/
18:01:35 <SamB_XP> oh, wierd shit
18:01:37 <Raguel> chess: the internet IS for porn - not programming
18:01:41 <SamB_XP> I did not think to try that, no
18:01:42 <Cale> can you paste it?
18:02:04 <SamB_XP> though I can see why that would be a better choice than backspace
18:02:09 <SamB_XP> that really explains a lot ;-)
18:02:15 <firefly> sure.
18:02:28 <SamB_XP> sorear: what did they do when they wanted to type #?
18:02:58 <sorear> \#
18:03:02 <SamB_XP> ah
18:03:05 <chessguy> &#;
18:03:07 <chessguy> :)
18:03:17 <Cale> Man, the libraries documentation URL layout is getting worse with each version of GHC. Now the URLs include version numbers which means I'll need up update all my bookmarks every time the version changes.
18:03:21 <SamB_XP> that's &sharp;, you nitwit
18:03:35 <chessguy> SamB_XP, bite me
18:03:40 <hpaste>  firefly pasted "aborts, SIGCHLD" at http://hpaste.org/3704
18:03:46 <SamB_XP> Cale: you would like a forwarding address?
18:03:53 <Raguel> man #haskell and funny symbols in odd places and #math with its attempts at ascii notation
18:03:57 <SamB_XP> or symlinks or something?
18:04:01 <Cale> SamB_XP: yeah, for each module.
18:04:04 <LoganCapaldo> Cale: clearly you need to upgrade from bookmarks to boorkmarlets which first qury for the latest version and then construct the url :)
18:04:06 <Cale> Either would do
18:04:15 <Raguel> i swear it just looks like a line retarded faces
18:04:31 <SamB_XP> LoganCapaldo: that sounds like a lot of trouble
18:04:42 <chessguy> bookmarklets rock
18:04:43 <SamB_XP> unless you can have a bookmarklet folder that munges the bookmarks under it
18:04:50 * sorear throws a Œª at Raguel
18:04:52 <LoganCapaldo> anyhing worth doing is :)
18:04:58 <firefly> I should probably also paste in some stuff the program can parse...
18:05:11 <Raguel> eek - a sharpened boomerang!
18:05:12 <SamB_XP> LoganCapaldo: I mean a lot of trouble per bookmark...
18:05:27 <Cale> firefly: btw, you have tab characters in your source file
18:05:41 <hpaste>  firefly pasted "input for my testcase" at http://hpaste.org/3705
18:05:42 <Cale> (which is not a good idea in general)
18:05:49 <Raguel> cale doesn't like tabs :P
18:05:59 <Raguel> i'm gonna use single spaces for my indentations
18:06:00 <firefly> but they are 8 spaces and everything :)
18:06:05 <Cale> Haskell implementations don't like tabs either
18:06:07 <SamB_XP> it is only advisable for makefiles
18:06:14 <Raguel> screw 8 spaces - i'm gonna use ONE
18:06:16 <SamB_XP> firefly: well, that's good anyway ;-)
18:06:28 <SamB_XP> you know the one true TAB
18:07:51 <Cale> that doesn't crash for me in 6.8.1
18:07:58 <Cale> On your given input.
18:08:06 <firefly> how big is your xxx file?  it is 118 chars here.
18:08:20 <Cale> you mean the input?
18:08:30 <sw17ch> is there a way to reduce the data types below the first on in this paste? http://hpaste.org/3703
18:08:43 <sw17ch> and by reduce, i mean... make less redundant
18:08:48 <joed> ChilliX_: ping?
18:08:54 <hpaste>  firefly pasted "'xxx' file" at http://hpaste.org/3706
18:09:13 <omnId> sw17ch: omit them completely? :)
18:09:33 <firefly> I compile with ghc -thread --make test/partela.hs
18:09:33 <SamB_XP> firefly: why are you feeding your program tiny porn?
18:09:46 <Raguel> wtf??
18:09:59 <sw17ch> omnId: i got close to that point...
18:10:03 <firefly> and run it with test/partela < test/basic.ptl (the second file I pasted in)
18:10:06 <Cale> firefly: ah, I was just  mainFile "input.dat"
18:10:16 <Raguel> oh god can you imagine writing ascii porn that was at the same time valid haskell...
18:10:24 <omnId> sw17ch: what's with the String representations?
18:10:37 <LoganCapaldo> @remember SamB_XP  why are you feeding your program tiny porn?
18:10:37 <lambdabot> I will never forget.
18:10:42 <sw17ch> omnId: i have bigger and better plans for the "Representations" later
18:10:43 <faxathisia> > ((==) `on` toConstr) (Nothing :: Maybe ()) (Just () :: Maybe ())
18:10:45 <lambdabot>   Not in scope: `toConstr'
18:10:50 <firefly> I can crash ghci with mainFile "test/basic.ptl"
18:10:52 <faxathisia> > ((==) `on` Data.Generics.toConstr) (Nothing :: Maybe ()) (Just () :: Maybe ())
18:10:53 <lambdabot>  False
18:11:02 <faxathisia> omg
18:11:09 <faxathisia> I got True for that
18:11:11 <sw17ch> omnId: maybe.. for now.. .i just want to know why i can't do something like data Representation = AtomRepresentation String | StringRepresentation String | ...
18:11:13 <firefly> It might matter that there is an xxx file that cat can send to stdout.
18:11:17 <sw17ch> omnId: and have it work with the LispExpr
18:11:31 <faxathisia> :S
18:11:36 <faxathisia> What is going on?
18:11:43 <firefly> So the files are:  test/partela.hs (1st paste), test/basic.ptl (2nd paste) and xxx (3rd paste)
18:12:03 <SamB_XP> faxathisia: crazy shit, obviously
18:12:28 <firefly> SamB_XP: err wha'?
18:12:59 <faxathisia> hmm
18:13:10 <faxathisia> I have a data type like   If | Then | Const Int | ...
18:13:18 <omnId> sw17ch: you might put the values' types in the LispExpr type.  data LispExpr = StringValue StringRep String | BoolValue BoolRep Bool | ListValue ListRep [ListExpr]
18:13:21 <omnId> ... etc
18:13:48 <faxathisia> Is there another way to check if two are equal (ignoring parameters) than writing out
18:14:07 <faxathisia> eql If If = True; eql (Const _) (Const _) = True ; ...
18:14:10 <thoughtpolice> damnit. :( i installed ghc 6.8.1, so now I can't build my irc bot anymore...
18:14:28 <thoughtpolice> guess I'll just have to wait until hs-plugins is working on 6.8 or something...
18:14:54 <hpaste>  Cale pasted "partela" at http://hpaste.org/3707
18:15:52 <faxathisia> Is there anything which goes from e..g Just 3 -> "Just"?
18:15:52 <Eelis> if i want to request the addition of missing values for System.Posix.Resource.Resource, do i really have to go through all the "proposal" hassle described at  http://www.haskell.org/haskellwiki/Library_submissions ?
18:15:53 <lambdabot> Title: Library submissions - HaskellWiki
18:16:29 <omnId> faxathisia: show . Data.Generics.toConstr
18:16:50 <faxathisia> omnId: ah good idea thanks
18:17:17 <Cale> firefly: I'm getting exit status 0
18:17:37 <firefly> Cale, it crashes in the same way here on Ubuntu Feisty Fawn, too :(
18:17:46 <firefly> ghc 6.6
18:18:08 <Cale> I'm using gutsy, with the generic binary for GHC 6.8
18:18:12 <Cale> (6.8.1)
18:18:37 <firefly> Thanks, I'll try that next.
18:20:12 <faxathisia> :t on
18:20:21 <lambdabot> forall t1 t2 t. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
18:20:25 <faxathisia> ?djinn (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
18:20:25 <lambdabot> f a b c _ = a (b c) (b c)
18:21:01 <faxathisia> haha that's not on
18:21:03 <faxathisia> > let on a b c _ = a (b c) (b c) in ((==) `on` (`mod` 3)) 1 5
18:21:05 <lambdabot>  True
18:21:08 <faxathisia> > let on a b c _ = a (b c) (b c) in ((==) `on` (`mod` 3)) 1 4
18:21:09 <lambdabot>  True
18:21:20 <faxathisia> Should never have trusted a computer to program for me!
18:21:56 <Cale> odd that it doesn't find the solution which uses all the inputs
18:22:10 <LoganCapaldo> djinn is lazy
18:22:13 <faxathisia> I feel silly for not noticing that in so log
18:22:15 <faxathisia> long
18:22:24 <Cale> Djinn does try to optimise its use of the inputs
18:22:48 <faxathisia> @src on
18:22:48 <lambdabot> (*) `on` f = \x y -> f x * f y
18:23:41 <LoganCapaldo> that deinition uses everything but n+k :)
18:24:29 <darrint> On trying to start a happs app I get: *** Exception: Prelude.read: no parse. What does that mean?
18:25:44 <alexj> darrint: you probably need to wipe your state.  you modified it in some way and didn't write a migration (or you are using an old version of happs)
18:26:08 <SideFFect> allo
18:26:33 <hpaste>  sideffect pasted "new_bsearch" at http://hpaste.org/3708
18:26:34 <darrint> alexj: noob question, where is that state? It's a file I can delete, no?
18:26:40 <SideFFect> new code im working on
18:26:57 <darrint> alexj: btw, saw the bliptv video of your talk. Very helpful.
18:27:07 <Pseudonym> Excellent!  We like new code!
18:27:19 <alexj> darrint: _local and thanks
18:27:39 <SideFFect> hehe
18:27:46 * scook0_ throws a newline at SideFFect :)
18:27:50 <SideFFect> see, now I have the j and k
18:27:54 <Pseudonym> SideFFect: Yeah, I was about to say that.
18:27:54 <SideFFect> and lol yeah I need newlines
18:28:07 <SideFFect> im just trying to get it working w/ the split function now
18:28:18 <SideFFect> oh, the professor gave us an extension....until next tuesday lol
18:28:34 <SideFFect> but id rather do it tonight and thats that
18:28:54 <darrint> alexj: Yep. that did it.
18:29:26 <hpaste>  Pseudonym annotated "new_bsearch" with "layout" at http://hpaste.org/3708#a1
18:29:50 <SideFFect> ahh much nicer :P
18:30:00 <SideFFect> I used the ; because the indents in haskell scared me :p
18:30:01 <Pseudonym> This isn't how I'd write it.
18:30:08 <Pseudonym> I'd use where clauses.
18:30:29 <Pseudonym> But anyway, it's your code.  I just did some s/;/^M/
18:30:55 <SamB_XP> SideFFect: I think I like GADTs better than "until next tuesday"
18:31:27 <scook0_> SamB_XP: I see what you did there
18:31:48 <SideFFect> gadt?
18:32:34 <scook0_> generalized algebraic data types, a language extension (hence the pun)
18:33:14 <chessguy> wow, this channel is corny tonight
18:33:17 <SideFFect> ah
18:33:21 <SideFFect> didnt get it but ok :P
18:33:37 <scook0_> chessguy: I accept full responsibility
18:35:23 <LoganCapaldo> sweet!
18:35:36 * LoganCapaldo unloads all his responsibilities onto scook0_
18:35:45 <SideFFect> heh
18:35:53 <chessguy> scook0_, you were supposed to say "amaize-ing, isn't it?"
18:36:25 <chessguy> sheesh, i totally set you up for that
18:38:16 <SideFFect> question: are do's only used in monads?
18:38:34 <SideFFect> my teacher was telling me I was very wrong on the exam because I used do's to anbswer qs
18:38:53 <chessguy> SideFFect, do-notation de-sugars to >>'s and >>='s, so it is inherently monadic, yes
18:38:57 <scook0_> yes, do-notation is just syntactic sugar for monad operations
18:39:31 <scook0_> though I suppose you could write all of your code in the identity monad
18:40:00 <SideFFect> damn good thing I didnt argue with him heh
18:40:49 <SideFFect> but in the YAHT the author uses do with a normal function
18:41:06 <Cale> oh?
18:41:08 <SideFFect> like askForWords = do putstrLn etc, word <- getLine
18:41:15 <Cale> yeah, that's using a monad
18:41:23 <Cale> in particular, the IO monad
18:41:27 <SideFFect> ahh
18:41:33 <firefly> getLine returns IO String
18:41:35 <SideFFect> what exactly IS a monad?
18:41:39 <Cale> askForWords is being defined as an IO action
18:41:46 <ivanm> SideFFect: good question!
18:41:49 <Cale> A monad is a type constructor, together with some operations
18:41:54 <LoganCapaldo> wella monad is like schroedingers cat...
18:41:58 <LoganCapaldo> don't listen to me
18:41:58 <ivanm> heh
18:42:00 <SideFFect> and if I would have known about the do's I would have not used it on exam and saved like 10 points :(
18:42:05 <LoganCapaldo> I have no self control
18:42:12 <ivanm> LoganCapaldo: awwww..... I wanted to hear what you were going to come out with!
18:42:16 <SideFFect> ahh type constructor
18:42:19 <Cale> Do you know about data declarations and type constructors?
18:42:28 <ivanm> maybe that can be a new blog post... "Monads as Schrodinger Cats" :p
18:42:31 <SideFFect> data Type you mean?
18:42:41 <Cale> yeah, with a single type parameters
18:42:43 <Cale> -s
18:42:47 <SideFFect> yeah
18:42:53 <Cale> So for example:
18:43:00 <Cale> data Maybe a = Nothing | Just a
18:43:12 <Cale> Maybe here is a type constructor with a single parameter
18:43:12 <SideFFect> yeah maybe is nothing or just a
18:43:29 <Cale> and it also turns out to be a monad, once you have appropriate operations
18:43:32 <SideFFect> and we can use type Maybe for other functions right?
18:43:40 <Cale> You have to define  return and (>>=)
18:43:44 <LoganCapaldo>  ivanm I take you missed that from earlier?
18:43:51 <ivanm> obviously
18:43:59 <Cale> Well, most monads are just plain old Haskell datatypes.
18:44:08 <ivanm> LoganCapaldo: I'm just flitting in and out
18:44:11 <SideFFect> im sure that'll be for next assignment
18:44:12 <Cale> The IO monad is a little special for being built-in
18:44:14 <scook0_> (which is why IO is a little unusual as a monad)
18:44:18 <SideFFect> he started briefly on them
18:44:28 <Cale> So for the Maybe monad
18:44:31 <Cale> return x = Just x
18:44:38 <Cale> Nothing >>= f = Nothing
18:44:45 <Cale> Just x >>= f = f x
18:45:06 <Cale> So return and bind are really just ordinary functions.
18:45:07 <SideFFect> a bit confused, but ill grasp it eventually :P
18:45:19 <Cale> Okay, let's start from the bigger picture.
18:45:29 <EvilTerran> @src IO return
18:45:29 <lambdabot> return x    = returnIO x
18:45:36 <LoganCapaldo> lol
18:45:40 <EvilTerran> ...
18:45:42 <EvilTerran> @src IO (>>=)
18:45:42 <lambdabot> m >>= k     = bindIO m k
18:45:49 <LoganCapaldo> double lol
18:45:50 <EvilTerran> @src IO
18:45:51 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
18:45:59 <ivanm> LoganCapaldo: why, what did you say earlier?
18:46:01 <Cale> Please don't look at that definition of the IO monad
18:46:06 <SideFFect> heh dont worry
18:46:16 <EvilTerran> thank heavens, i was expecting that to be "type IO = IOIO IOIOIO" or something
18:46:22 <Cale> http://hpaste.org/3673  gives a much better idea of how to think of it
18:46:30 <Cale> (the IO monad)
18:46:45 <EvilTerran> (old macdonald had a side-effect, ee IO IO)
18:46:50 <dataangel> Haskell/bash question: I'm going through the scheme in 48 hours tutorial and trying to add support for escaped quotation marks ("\""). The string it tests against is taken from the command line. How do I test properly whether my code works from bash? If I do: ./scheme "hello" I'm not sure if bash is throwing away the quotes, or if they're included, and if I escape them, I don't know if they're going to haskell escaped or together or what :P
18:46:59 <Cale> That is, you can just picture it as a datatype with constructors for the IO primitives, and return and bins
18:47:01 <Cale> bind*
18:47:21 <SideFFect> ahh
18:47:25 <SideFFect> I kinda get it now
18:47:28 <LoganCapaldo> ivanm: it wasn't me so much we won't from monads as containers to monads as containers that magically create their contents when you open the box to the wisdom of trying to explain monads in terms of of a metaphor invovling the box schrodinger put the cat in
18:47:32 <EvilTerran> dataangel, bash does no substitution of *anything* in single-quotes, iirc
18:47:38 <Cale> The Haskell runtime system interprets that datastructure and carries out the actions.
18:47:44 <ivanm> LoganCapaldo: ahhh
18:47:48 <Cale> But ordinary evaluation doesn't do much with it.
18:47:48 <gvdm_other> dataangel: if thats on the cmd line i'd try escaping those quotes to get them to haskell
18:47:51 * ivanm wishes he didn't miss that :(
18:48:04 <ivanm> "monads as animal abuse aids"
18:48:13 <EvilTerran> dataangel, try just echoing the parameter back on stdout or something; that aughta give you an idea of what you're really getting
18:48:18 <SideFFect> i see
18:48:27 <dataangel> EvilTerran: thought of that just as you said it :)
18:48:31 <dataangel> thanks
18:48:32 <Cale> SideFFect: Functional programmers really dislike solving problems too directly.
18:48:40 <EvilTerran> :)
18:48:41 <SideFFect> yeah lol
18:48:46 <SideFFect> its an odd way to think
18:48:50 <SideFFect> ti beat around the bush
18:48:52 <SideFFect> to*
18:48:54 <Cale> We like to have solutions which are not brittle to design changes.
18:49:03 <EvilTerran> it helps us get nice long lists of references on our papers
18:49:17 <SideFFect> well...there goes my full program...my MAIn thing I learned in software engineering...design for change
18:49:18 <SideFFect> :P
18:49:22 <Cale> If the customer changes one little thing about how something works, it shouldn't cause us to have to rewrite everything.
18:49:40 <SideFFect> yeah, theres patterns that handle that
18:49:44 <SideFFect> design patterns that is
18:49:45 <LoganCapaldo> oh dear god yes
18:49:47 <LoganCapaldo> design for change
18:49:50 <Cale> So rather than write programs directly, we often find it's nice to design small languages which embed within the language we're using
18:49:57 <LoganCapaldo> or at least try to
18:50:06 * goalieca hates OOP and actors
18:50:07 <Cale> and which have domain-specific properties
18:50:11 <ivanm> LoganCapaldo: know from experience, do you?
18:50:19 <SideFFect> so you can change the monand and it changes the program...instead of modyfying the program directly
18:50:22 <SideFFect> like programming w/ modules
18:50:26 <SideFFect> in imperitive
18:50:33 <LoganCapaldo> ivanm: everyday ;)
18:50:33 <Cale> Er, well, that's something a little later
18:50:42 * EvilTerran dislikes OOP's tendency to add buzzwords to concepts that work fine elsewhere too
18:50:51 <ivanm> EvilTerran: like "Patterns"?
18:50:56 <Cale> Such languages have come to be known as combinator libraries.
18:51:03 <SideFFect> sounds cool :D
18:51:07 <Cale> You have some notion of a "computation" in your language
18:51:07 <SideFFect> I am COMBINATOR
18:51:19 <Cale> and functions which combine those into larger computation
18:51:20 <Cale> s
18:51:22 <goalieca> I AM Y-TERMINATOR
18:51:39 <Cale> For instance, in a parsing library, we might have simple parsers which parse single characters
18:51:40 * goalieca cocks guns
18:51:48 <Cale> and then ways to join those together into larger parser
18:51:49 <Cale> s
18:51:49 <EvilTerran> ivanm, like that, yes. or a lot of stuff that basically boils down to "separation of concerns" and "chosing the right abstraction" etc
18:51:55 <ivanm> yeah
18:51:58 <Cale> damn, what's with me and the s key
18:52:01 <Cale> anyway :)
18:52:08 <SideFFect> i shoukld have come here before the test :P
18:52:20 <ivanm> that stupid patterns subject I had to take last year was the closest I've come to failing a subject at uni :s
18:52:31 <ivanm> mainly because I didn't see the point in any of it
18:52:35 <Cale> So, after a while we started to notice that lots of the combinator libraries we were writing involved very similar means of combination
18:52:36 <SideFFect> lol yeah, patterns is hard
18:52:40 <SideFFect> and its all applied in java
18:52:42 <SideFFect> least for us
18:52:53 <Cale> and one of these types of combinator library is the monadic one
18:52:55 <EvilTerran> although, amusingly, my OOP lecturer finally instroduced inheritance (about a week-fortnight after interfaces), and immediately shot it down as Often A Bad Idea
18:53:01 <EvilTerran> with a nice example of it breaking spectacularly
18:53:05 <SideFFect> ah, so thats where monads re useful
18:53:06 <SideFFect> are*
18:53:07 <scook0_> EvilTerran: oh, I approve
18:53:09 <Cale> So what is a monadic combinator library?
18:53:24 <Cale> It's a library where your "computations" have *results*
18:53:37 <dfranke> hmm
18:53:37 <SideFFect> I see
18:53:40 <dfranke> :t (,) "foo"
18:53:42 <lambdabot> forall b. b -> ([Char], b)
18:53:46 <Cale> So if you're encoding that as a datatype, you have a type constructor C
18:53:46 <dfranke> :t ("foo",)
18:53:48 <lambdabot> parse error on input `)'
18:53:56 <dfranke> this strikes me as a bit irregular.
18:53:57 <Cale> and then (C a) is a computation which results in a value of type a
18:54:09 <Cale> and then there are a few basic ways to build up computations
18:54:10 <EvilTerran> scook0_, indeed. i believe i'd already encountered such an example via a link from here
18:54:22 <SideFFect> thats just defining types in a normal language
18:54:38 <LoganCapaldo> dfranke: it has struck me as ireggular also
18:54:42 <Cale> For any value x, whatsoever, (return x) is the computation which "does nothing" (whatever that means for your library), and returns the value x
18:54:47 <LoganCapaldo> but what are ya gonna do?
18:54:58 <Cale> If x and y are computations
18:55:10 <dfranke> Why can't it just be generalized so that (,"foo",,) means \x y z -> (x,"foo",y,z) ?
18:55:15 <Cale> Then  x >> y  is the computation which runs x, throws away its result, then runs y, returning its result.
18:55:18 <scook0_> EvilTerran: I remember doing a great big software design assignment not long after I started learning Haskell
18:55:24 <scook0_> my designs were ... interesting :)
18:55:28 <EvilTerran> dfranke, i think someone complained that ((,),(,)) would be unintuitive
18:55:36 <SideFFect> return = Return
18:55:37 <SideFFect> ah
18:55:40 <EvilTerran> er, wait, you can do that anyway.
18:55:43 <EvilTerran> i don't know, then. =/
18:55:51 <goalieca> EvilTerran, that looks like boobs to me ( , ) ( , )
18:55:57 <ivanm> because no-one thought/implemented that before?
18:56:02 <dfranke> EvilTerran: anyone who writes that expression in production code deserves all the brokenness they get.
18:56:03 <EvilTerran> ?type ((,),(,)) -- not :: a -> b -> c -> d -> ((a,b),(c,d))
18:56:06 <lambdabot> forall a b a1 b1. (a -> b -> (a, b), a1 -> b1 -> (a1, b1))
18:56:10 <Cale> Now that's great, but we'd usually want a way to direct the rest of the computation based on results of each computation in it.
18:56:12 * ivanm washes goalieca's mind with industrial grade cleaning fluid
18:56:25 <scook0_> tuple sections can turn typos into bizarre problems
18:56:26 <Cale> So we have a generalisation of >> called >>=
18:56:27 <SideFFect> ok whoa dude, geting too advanced
18:56:33 <sjanssen> dfranke: I'd love to have tuple sections in Haskell
18:56:34 <SideFFect> let my brain relax lol
18:56:41 <Cale> Okay, I'll slow down and give an example of what I mean.
18:56:43 <Cale> In the IO monad
18:56:45 <SideFFect> we didnt even start monads yet :P
18:56:46 <EvilTerran> scook0_, hehe
18:56:50 <SideFFect> just barely touched it
18:56:51 <sjanssen> I write (flip (,) x) far too often
18:57:00 <Cale> We have  putStrLn :: String -> IO ()
18:57:03 <EvilTerran> (re interesting designs)
18:57:18 <Cale> that is, it's a function which takes a String and produces an IO computation which results in an empty tuple
18:57:27 <SideFFect> yeah
18:57:36 <Cale> and we also have:  getLine :: IO String
18:57:46 <Cale> which is an IO computation which results in a String
18:57:54 <Cale> also called an IO action
18:57:56 <SideFFect> yep
18:58:08 <Cale> Okay, so presently, using >> we can write:
18:58:17 <Cale> main = getLine >> putStrLn "Hello"
18:58:26 <SideFFect> lol thats C talk!
18:58:29 <SideFFect> or c++
18:58:34 <SideFFect> cout
18:58:36 <Cale> Which gets a line of text from the user and then prints "Hello" on the screen.
18:58:44 <LoganCapaldo> main = getLine >>= putStrLn
18:58:49 <Cale> However, >> doesn't give us a way to use the result of getLine
18:58:56 <Cale> which is where >>= comes in
18:59:10 <SideFFect> = takes and stores
18:59:11 <SideFFect> ?
18:59:18 <Cale> = isn't a separate thing here
18:59:19 <Cale> >>=
18:59:24 <Cale> Is all one symbol
18:59:26 <SideFFect> yeah
18:59:32 <Cale> oh
18:59:33 <Cale> I see
18:59:42 <LoganCapaldo> >> is just a castrated >>=
18:59:44 <Cale> It does a similar thing to >>
18:59:56 <gvdm_other> SideFFect: think a pipeline with the output of first function to input of second, and you can chain these together (or just have a do statement)
18:59:58 <Cale> but rather than having a computation on its right hand side
19:00:00 <scook0_> (and it has nothing to do with bit-shifting or assignment)
19:00:08 <SideFFect> ahh I get it
19:00:09 <Cale> it takes a function from possible results of the first computation
19:00:16 <Cale> to "what to do next"
19:00:17 <SideFFect> eww bit shifting
19:00:22 <LoganCapaldo> a >> b = a >>= \_ -> b
19:00:32 <SideFFect> ha cool I get it
19:00:40 <SideFFect> input to output to input and so on
19:00:44 <Cale> So yeah,
19:00:57 <Cale> main = getLine >>= (\x -> putStrLn x)
19:01:13 <Cale> is the program which gets a line of text from the user, and then prints it back out
19:01:18 <SideFFect> yeah :D
19:01:24 <omnId> (getLine :: IO String) >>= (putStrLn :: String -> IO ()) :: IO () -- getLine is a computation that results in a String, (>>=) hooks another computation on its end.
19:01:35 <Cale> So in general, a monad is something which has *some* definition of return and (>>=)
19:01:44 <Cale> It might be *vastly* different from IO
19:01:45 <omnId> putStrLn takes the result string and makes a new computation IO ()
19:01:54 <SideFFect> cool thx for explanation :D
19:01:57 <Cale> But the "shape" of how we combine our computations is the same.
19:02:28 <Cale> The reason for making this abstraction is that once we've recognised it, we can write code which works in any monad
19:02:48 <Cale> That code is likely to be very much like control structures
19:02:50 <omnId> do notation is just syntax sugar for applying the (>>=) operator.  That is, 'do { pat <- exp ; ... }' equals 'exp >>= \pat -> do { ... }'
19:03:12 <SideFFect> cool
19:03:15 <dfranke> Cale: the List monad doesn't feel much like a control structure.
19:03:34 <Cale> dfranke: by control structures here, I'm talking about things like mapM, sequence, etc.
19:03:48 <Cale> "when" would be another good example
19:03:56 <Cale> Basically, all the stuff in the Control.Monad library.
19:03:58 <SideFFect> hey for my else
19:04:06 <SideFFect> on the last line
19:04:13 <SideFFect> can I have an else then | cases?
19:04:30 <Cale> No, but you could if you used case
19:04:34 <Cale> case x of
19:04:38 <Cale>   True -> ...
19:04:46 <Cale>   False | ... -> ...
19:04:50 <Cale>         | ... -> ...
19:05:01 <SideFFect> like is there someway to call my split function, and then do what I had working before?
19:05:05 <omnId> (if .. then .. else ..) is an expression form.  Guards are part of pattern-matching syntax.
19:05:19 <SideFFect> meaning the x < r = find x ls stuff
19:06:19 <SideFFect> haskell has alot of "no, you cant do that"
19:06:23 <omnId> SideFFect: if you want find to act like the imperative one that narrows down the j and k without narrowing down cs, then you won't be able to use your splitIn2 function.
19:06:23 <Cale> btw, I invite you to read http://www.haskell.org/haskellwiki/Monads_as_computation at some point, which goes over what I just discussed, but might be clearer and in better detail.
19:06:24 <lambdabot> Title: Monads as computation - HaskellWiki
19:06:26 <dfranke> Cale: well, I guess I've simply never found [] all that useful as a monad.  I find it much more readable to use concatMap or comprehensions.
19:06:32 <SideFFect> whereas imperitive languages allow more freedomg I find
19:06:40 <Cale> dfranke: comprehensions are essentially using [] as a monad
19:06:54 <Cale> also, the stuff in Control.Monad provides really useful list operations
19:06:57 <SideFFect> yeah I thought id need a new fct
19:06:59 <dfranke> Cale: yes, but the comprehension syntax makse more sense
19:07:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
19:07:06 <SideFFect> now I gotta split by hand sigh...
19:07:07 <scook0_> SideFFect: often it's more like "you can't do that; it doesn't even make sense!"
19:07:07 <omnId> dfranke: maybe not, but liftM2 and sequence and things are handy to have without needing more specific versions.
19:07:11 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
19:07:24 <Cale> > filterM (const [True,False]) [1,2,3]
19:07:25 <SideFFect> splitAt 2 [12,34,56]
19:07:25 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
19:07:49 <Cale> The list monad is really nice for writing depth first searches
19:08:12 <Cale> You essentially get to write the search as if it was a breadth first search
19:08:26 <SideFFect> splitAt 1 [12,34,56]
19:08:32 <SideFFect> code doesnt work? :P
19:08:33 <omnId> SideFFect: do you still want it to behave like the imperative one, narrowing down j and k like yesterday?
19:08:40 <SideFFect> yeah I do
19:08:55 <Cale> That is, you need only write some  State -> [State] function which produces the options to search through from a given state
19:08:56 <ivanm> SideFFect: you need a ">" at the beginning to get code to be executed by lambdabot
19:09:03 <SideFFect> ah
19:09:05 <omnId> SideFFect: then find will need to take two more arguments, j and k, and you'll recurse with different values of those.
19:09:06 <Cale> and then bind will fit those together nicely
19:09:07 <ivanm> > splitAt 1 [12,34,45]
19:09:09 <lambdabot>  ([12],[34,45])
19:09:14 <ivanm> ^^ see?
19:09:19 <SideFFect> heh yeah
19:09:22 <Cale> and produce a depth first search
19:09:37 <LoganCapaldo> @run 1 + 1 -- you can spell it @run also
19:09:39 <lambdabot>  2
19:09:48 <SideFFect> and omnID but how can find take two new arguments when they are computed?
19:10:04 <Cale> Of course, bind is concatMap, but if you have a lot of those, and they're involved, the do-notation is nice.
19:10:20 <SideFFect> theres the do's again
19:10:43 <omnId> SideFFect: j will start as 0 and k as (length cs), then you'll narrow down which side of cs x occurs in and recurse with a new j or k.
19:10:53 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (100*x + 10*y + z)
19:10:54 <lambdabot>  [146,147,148,156,157,158,246,247,248,256,257,258,346,347,348,356,357,358]
19:11:08 <Cale> Of course, that's the same as
19:11:10 <SideFFect> but then how would the user type that imn?
19:11:11 <scook0_> (I recently found list-do quite useful for generating parameter sets for simulations)
19:11:13 <SideFFect> in*
19:11:14 <ArmchairDeity> hehe w00t
19:11:14 <ArmchairDeity> module Hello where
19:11:14 <ArmchairDeity> main = putStrLn "Hello, World!"
19:11:19 <ArmchairDeity> it works! lmao
19:11:22 <Cale> > [100*x + 10*y + z | x <- [1,2,3], y <- [4,5], z <- [6,7,8]]
19:11:23 <lambdabot>  [146,147,148,156,157,158,246,247,248,256,257,258,346,347,348,356,357,358]
19:11:29 <Cale> ArmchairDeity: :)
19:11:32 <omnId> ArmchairDeity: congrats :)
19:11:35 <SideFFect> find 4 0 100 [1..100]
19:11:35 <SideFFect> ?
19:11:53 <omnId> 0 99 actually
19:11:56 <Cale> ArmchairDeity: who says IO is hard in a purely functional language? :)
19:12:06 <ArmchairDeity> it seems silly, what with all this talk of monads and Fibonacci numbers, but it's nice to do something simple first
19:12:08 <SideFFect> so the user has to enter the range AND the list?
19:12:11 <SideFFect> kinda silly no?
19:12:16 <SideFFect> must be a nicer solution
19:12:22 <SideFFect> where all it takes in is x and list
19:12:27 <omnId> SideFFect: right but that's what you wanted.
19:12:32 <SideFFect> the teacher said he wants two functions
19:12:35 <SideFFect> find and split
19:12:39 <Cale> ArmchairDeity: of course, the full significance of what you've really done there can probably wait :)
19:12:47 <SideFFect> and expects find.split
19:12:50 <SideFFect> to do what it does
19:12:55 <omnId> find' x cs = find x 0 (length cs) cs -- you could write a simpler function which starts things off, SideFFect
19:13:02 <dons> dcoutts__: can you make cabal -j3 work :)
19:13:19 <omnId> SideFFect: if you're splitting the lists themselves, you won't have any j and k indices to word with, so it's one or the other.
19:13:24 <Cale> ArmchairDeity: But you've essentially constructed a value which represents the computation you want done, and then the runtime system took that value apart and followed the instructions.
19:13:38 <ArmchairDeity> exactly!
19:13:49 <hpaste>  luqui pasted "Coroutines?" at http://hpaste.org/3709
19:13:56 <luqui> is that possible?
19:13:59 <SideFFect> as I said...too many "no cant do that" in haskell
19:14:12 <omnId> SideFFect: you couldn't do that in *any* language.
19:14:24 <SideFFect> its done in imperitive?
19:14:33 <ArmchairDeity> OK, so now it's time to implement a web server/programming platform in Haskell heh
19:14:39 <SideFFect> each new list becomes its own j and k
19:14:57 <ArmchairDeity> in yer face, Python
19:15:14 <omnId> if you're ripping apart a list and recursing with the sublists, you've lost the larger list that the j and k index into, so *don't* split the list and just recurse with different j and k.
19:15:27 <SideFFect> but we have to :P
19:15:29 <omnId> j and k are indeces, no?
19:15:39 <SideFFect> yes they are
19:16:01 <luqui> nobody has any idea about http://hpaste.org/3709?
19:16:07 <SideFFect> ahh dont split the list
19:16:12 <SideFFect> I just move around in it
19:16:22 <SideFFect> just clicked heh
19:16:27 <SideFFect> now gotta see how to do that :P
19:16:54 <Cale> luqui: seems like it should
19:17:04 <luqui> I'm wondering if it needs some state though
19:17:26 <SideFFect> I get it... length `div` 2 gives the middle, so thats my H, and I compare my x to that and move back/forth accordingly!
19:18:26 <SideFFect> and then I can call the find again with the new j and k...which is find'
19:18:49 <SideFFect> so all the fist find does is take in the x and list and test for the dumb j+1 k thing
19:18:54 <SideFFect> then it goes to find `
19:18:58 <SideFFect> find'*
19:20:16 <SideFFect> he said we COULD use a global variable to store the x but doesnt matter
19:20:24 <SideFFect> does my soln seem good?
19:20:26 <ArmchairDeity> I have a hugs98 session running in a window in Eclipse
19:20:38 <ArmchairDeity> if I want to reload my source file, what's the command, or do I have to restart the hugs session?
19:20:46 <omnId> SideFFect: yes, it's exactly what the imperative version does.
19:20:57 <gvdm_other> ArmchairDeity: should be :l, no?
19:20:59 <joed> Hmm, anyone else having issues with 6.8.1 ghci and _environ loading on Leopard?
19:21:15 <SideFFect> cool...I like when ppl help me make things click :P
19:21:16 <sorear> joed: huge numbers
19:21:21 <SideFFect> now lets see if I can do it :P
19:21:31 <ArmchairDeity> ahhhh ok
19:21:36 <faxathisia> *grr*
19:21:39 <sorear> joed: as in the mailing list has been discussing little else the last two days
19:21:44 <faxathisia> I wrote a parser for this grammer
19:21:44 <joed> sorear: Any place to start digging besides xcode?
19:21:51 <faxathisia> now I have to write an unparser too :
19:21:57 <joed> sorear: Ah, sorry, I'm not subscribed.
19:21:59 <faxathisia> can't that just happen magically?
19:22:20 <ArmchairDeity> gvdm_other, it's :reload
19:22:29 <ArmchairDeity> realoads the current source file
19:22:53 <ArmchairDeity> err... reloads
19:23:53 <gvdm_other> ArmchairDeity: obviously too much ghci for me
19:24:23 <ArmchairDeity> hehe
19:24:33 <ArmchairDeity> at the moment I'm just sticking with hugs
19:24:40 <ArmchairDeity> since I need all of them I can get
19:24:54 <ivanm> gvdm_other: ghci does the same
19:25:15 <ivanm> so you can't blame your choice of interpreter on your lack of knowledge! :p
19:26:25 <ArmchairDeity> if it weren't for you, gvdm_other, I'd not have known about the VI-like syntax within hugs, however
19:26:37 <ArmchairDeity> and :help is very :helpful
19:26:55 <ArmchairDeity> sorry, it's :?
19:26:59 <SideFFect> dang it
19:27:10 <SideFFect> isnt there someway to mix thens and elses?
19:27:15 <SideFFect> I think this is going wrong
19:27:15 <SideFFect> then putStrLn("Sorry, j+1 = k")
19:27:15 <SideFFect>                 else find' (x j k cs)
19:27:28 <SideFFect> one of type string, one of other type I guess?
19:27:28 <Cale> what's with your indentation?
19:27:37 <Cale> putStrLn is an IO action
19:27:45 <Cale> what does find' result in?
19:27:46 <luqui> Is it possible to have a pure weak table; i.e. a mapping from objects of some (specific) type a to objects of an (arbitrary) type b, such that whenever the a dies, the table discards the value of b?
19:27:49 <SideFFect> yeah that was the error IO -> [a]
19:27:50 <luqui> if that makes sense...
19:28:12 <SideFFect> this is my find'
19:28:13 <SideFFect> find' x j k bs = let h = length bs `div` 2 in bs
19:28:20 <luqui> obviously in order for this to be referrentially transparent the table must not be iterable...
19:28:21 <scook0_> both branches of an if must have the same type
19:29:22 <Cale> luqui: well, there's http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/System-Mem-Weak.html
19:29:24 <lambdabot> http://tinyurl.com/2b8u5y
19:29:29 <SideFFect> so how can I output an error and then go to another function?
19:29:31 <SideFFect> cases?
19:29:42 <SideFFect> case 1: error
19:29:45 <Cale> luqui: which you can use along with unsafePerformIO to construct things like that I think
19:29:45 <SideFFect> case 2: find'
19:30:10 <Cale> SideFFect: the error has to become part of the output of the function
19:30:18 <SideFFect> how so?
19:30:20 <scook0_> SideFFect: do you have a relevant paste?
19:30:24 <Cale> SideFFect: or else it is the total output of the function
19:30:27 <LoganCapaldo> SideFFect: case branches have to be the same type too
19:30:28 <luqui> Cale, yeah, I pretty quickly concluded that i needed unsafePerformIO...
19:30:31 <SideFFect> from my current code?
19:30:53 <hpaste>  sideffect pasted "test-code" at http://hpaste.org/3710
19:30:58 <SideFFect> pasted
19:31:17 <Cale> note that you've only passed find' one parameter there
19:31:23 <SideFFect> yeah
19:31:25 <scook0_> luqui: don't weak references typically need a "dereference" operation that turns them into real references?
19:31:26 <SideFFect> I was just testing
19:31:45 <SideFFect> so I have to get rid of my putstrln and send it to find' and then show error?
19:32:06 <scook0_> SideFFect: what's the type of find supposed to be?
19:32:18 <Cale> You can return a different value from find in the case that j+1 == k
19:32:20 <SideFFect> the output type? havent determined yet :P
19:32:38 <luqui> scook0, i don't follow
19:32:39 <Cale> If find was constructing an action, then you could have the action that it built involve that putStrLn
19:32:41 <SideFFect> so I can return find' x 1 2 cs
19:32:51 <Cale> however, something makes me think this isn't what you're after
19:33:02 <luqui> scook0, no, I just want a mapping from objects to other objects that will discard the values that can never be reached anymore
19:33:10 <Cale> Why does find' have 4 parameters?
19:33:20 <SideFFect> thats what someone was saying before
19:33:30 <Cale> It only uses bs
19:33:44 <SideFFect> but I need to find j and k each time
19:33:44 <luqui> hmm that's interesting... I need them to be some sort of unique...
19:33:52 <SideFFect> or can I go back and forth from find and find'
19:34:10 <Cale> well, yeah, you can write mutually recursive things in general
19:34:18 <Cale> I don't really understand what this code is trying to do
19:34:27 <Cale> A type signature for this would be helpful.
19:34:34 <scook0_> luqui: ah, so you're after a (non-iterable) mapping that discards entries if the key can be GC'd
19:35:00 <luqui> scook0, yes... essentially pure references of some sort...
19:35:07 <omnId> Cale: it should recursively narrow down the bounds j and k without splitting cs.  He needs it to imitate the imperative version.
19:35:15 <luqui> I'm trying to make a monad transformer like state, but allows the creation of references
19:35:20 <luqui> (a lot like ST really, but in a transformer)
19:35:22 <SideFFect> yeah
19:35:28 <SideFFect> how do I fix it :P
19:35:35 <scook0_> luqui: yeah, sounds like you need unsafePerformIO, encapsulation, and a few proofs :)
19:35:40 <Cale> okay
19:35:43 <luqui> :-)
19:35:50 <Cale> first thing would be to have
19:36:08 <omnId> find x cs = find' 0 (length cs) cs, to start
19:36:23 <omnId> (length cs - 1), rather
19:36:31 <Cale> heh, I was just typing that
19:36:57 <hpaste>  firefly pasted "threads+runInteractiveCommand => SIGCHLD" at http://hpaste.org/3711
19:37:02 <Raguel> how long is the list of all library functions in haskell and how many should one have memorised
19:37:02 <Cale> er, you want x to be a parameter of find' as well, unless find' is in a where clause
19:37:13 <firefly> I have a shorter, self-contained test case for my SIGCHLD bug now.
19:37:18 <Cale> Raguel: extremely long?
19:37:21 <Raguel> and is there a good resource for searching through them?
19:37:25 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
19:37:27 <lambdabot> http://tinyurl.com/2rgl8s
19:37:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
19:37:55 <Raguel> how many do you typically have memorised
19:37:56 <omnId> @go tour of the haskell prelude
19:37:57 <lambdabot> http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html
19:37:57 <lambdabot> Title: A Tour of the Haskell Prelude
19:38:05 <Cale> Raguel: I have no idea :)
19:38:13 <Raguel> heh
19:38:33 <omnId> Raguel: at least a couple dozen *very* small *very* simple functions.
19:38:51 <Cale> I'd start with the Prelude
19:38:54 <Cale> and then Data.List
19:38:59 <Cale> and possibly Control.Monad
19:39:08 <scook0_> Raguel: most of the stuff in Prelude is worth knowing about
19:39:10 <Raguel> are foreign ones in other languages (doubtful) or something odd?
19:39:23 <Cale> huh?
19:39:29 <scook0_> there are lots of cool combinators in Control.Arrow and Control.Applicative, but they're a bit more advanced
19:39:34 <Raguel> ah hyperlinks
19:39:39 <Cale> That sentence no verb?
19:39:40 <ArmchairDeity> OK can someone tell me where there's a langref for Haskell?
19:39:40 <Raguel> heh they are other lanugage stuff
19:39:48 <Raguel> but other programming languages
19:39:48 <scook0_> @where report
19:39:48 <lambdabot> http://www.haskell.org/onlinereport/
19:40:00 <Cale> ArmchairDeity: also see the links I just pasted
19:40:00 <omnId> ArmchairDeity: there's the haskell 98 report
19:40:01 <ArmchairDeity> and I have to say... this room is cool and the people are super helpful, thanks everyone
19:40:16 <SideFFect> can I have an else let h = length etc
19:40:16 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
19:40:18 <SideFFect> is that legal?
19:40:23 <ArmchairDeity> OOH perfect, thank you!
19:40:23 <dons> ArmchairDeity: we try hard :) i'm glad that's the experience you've had the last few hours
19:40:28 <omnId> SideFFect: perfectly so.
19:40:34 <SideFFect> cool
19:40:37 <SideFFect> lets try something...
19:40:43 <none> hey guys, how do I use the writeFile functon to overwrite a prvious file
19:40:44 <Cale> SideFFect: "let <decls> in <expr>" is always an expression
19:40:53 <none> ???
19:40:58 <SideFFect> :D
19:41:02 <sw17ch> what's a good example to explain how to use "instance" and "class"
19:41:10 <Cale> none: The obvious way, but be careful if you're using it with readFil
19:41:15 <Cale> readFile*
19:41:35 <omnId> sw17ch: hrm, I suppose you could look at the Prelude's specification.
19:41:39 <Cale> none: readFile is lazy, which means that you end up with a string that actually does the IO as it's evaluated
19:41:45 <none> i read the file first the convert it to uppercase then want to write it back to the same file
19:42:07 <SideFFect> can I output a string w/ an integer value? is that legal?
19:42:07 <pjd> sw17ch: probably Num
19:42:18 <SideFFect> if my type already outputs ->String
19:42:24 <scook0_> sw17ch: are you talking about syntax, or design?
19:42:26 <omnId> SideFFect: you can hava a (String, Int) pair.
19:42:28 <dfranke> how is (<=) defined on Strings containing non-ASCII characters?  Is it based on scalar unicode values, or does it use the Unicode Collation Algorithm?
19:42:32 <SideFFect> very cool :D
19:42:40 <omnId> dfranke: code points iirc
19:42:48 <sw17ch> scook0_: design
19:42:52 <sw17ch> i have a data type
19:43:16 <Cale> none: You just have to be certain that the file's been completely read before you start to write it.
19:43:28 <SideFFect> else let in putStrLn...legal?
19:43:30 <none> when i write back the file and open it, it is blank
19:43:31 <dfranke> omnId: ok, so in ISO jargon, the UCS_BASIC collation?
19:43:34 <sw17ch> and i want to make a class that will "print" a specific part of each of the various possible sub types (what's the proper word?)
19:43:38 <Cale> none: an easy hack for doing that is to import Control.Exception (evaluate), and then  evaluate (length cs)
19:43:50 <hpaste>  dataangel pasted "Trouble matching escaped quotes w/ Parsec. Help?" at http://hpaste.org/3712
19:43:51 <omnId> dfranke: not sure, don't know that jargon :D
19:43:52 <Cale> none: where cs is the string you got from readFile
19:44:06 <omnId> SideFFect: if the function results in an IO action, yes.
19:44:06 <sw17ch> data A = A String String | B String Int
19:44:10 <gwern> does anyone know who runs the technical side of the haskell wiki? ie sysadminning the mediawiki installation
19:44:24 <Cale> none: That will ensure that the whole file is actually read before you start writing (which truncates the file)
19:44:37 <omnId> SideFFect: but Integer and IO () are not compatible types, so you couldn't use both at the same time.
19:44:54 <Cale> none: Another way to do it would be to use strict IO functions
19:45:02 <scook0_> sw17ch: as a rule of thumb, I find that you rarely need to define typeclasses in application code -- they're more useful in library code (though obviously there are many exceptions)
19:45:09 <omnId> SideFFect: I suppose you could return Either (IO ()) Int, but that's *probably* not what you want.
19:45:12 <SideFFect> so how would I have my else let output something?
19:45:34 <none> i use a recursive function to convert the string to Upper
19:45:48 <omnId> SideFFect: if you want print debugging, there's the slightly unusual Debug.Trace.trace function.
19:45:50 * ddarius uses map toUpper
19:45:53 <none> convert (x:xs) = toUpper x : convert xs
19:46:07 <omnId> @src map
19:46:08 <lambdabot> map _ []     = []
19:46:08 <lambdabot> map f (x:xs) = f x : map f xs
19:46:22 <omnId> map toUpper = convert
19:46:26 <sw17ch> scook0_: I'm writing a lisp parser... perhaps i'm picking the wrong approach. i have a "LispExpr" data type that represents any expression you can have in Lisp. I have a few sub-pieces in side each LispExpr data type... and want functions to change them, or retrieve them, or do other fancy things with them
19:46:27 <dibblego> doesn't GHC 6.8.1 come with a fancy new debugger?
19:46:27 <none> > map toUpper "the"
19:46:30 <lambdabot>  "THE"
19:46:35 <none> ok
19:46:40 <none> ncie
19:47:12 <SideFFect> ok, can I call a function after an else let?
19:47:15 <Cale> import qualified Data.ByteString.Char8 as B; main = do s <- B.readFile "hello"; B.writeFile "hello" (B.map toUpper s)
19:47:18 <faxathisia> sw17ch: you reading write yourself a scheme in 24?
19:47:29 <SideFFect> else let h = l `div`2 in find etc
19:47:40 <sw17ch> faxathisia: i have the document open... but i'm doing osmething significantly differnt
19:47:51 <sw17ch> i've gone through that one once already... but admittedly, it was a while ago
19:47:59 <Cale> I suppose I could also write you a nice interactFile just using the stuff in System.IO
19:47:59 <scook0_> sw17ch: that sort of thing is typically just done with ordinary functions
19:48:09 <Cale> I wish there were an interactFile in the libraries.
19:48:11 <faxathisia> sw17ch: out of intrest what sort of thing are you doing?
19:48:22 <scook0_> sw17ch: do you have a concrete example of some functionality you need?
19:48:37 <omnId> faxathisia: scroll up, sw17ch explained to scook0_
19:48:46 <sw17ch> faxathisia, it's my senior project. i'm doing some proof of concept for a larger idea i have, and need a working AST for *some* language..
19:49:13 <sw17ch> faxathisia: in this case .. i need to preserve all the syntax that was in the original source file... so it's a parser where whitespace is relevant and no tokens are discarded
19:49:42 <faxathisia> interesting
19:49:47 <scook0_> data Lam = Var String | Abs String Lam | App Lam Lam -- :)
19:49:54 <faxathisia> why?
19:50:13 <hpaste>  sw17ch annotated "AST: Second Try" with "(no title)" at http://hpaste.org/3703#a1
19:50:16 <LoganCapaldo> scook0_: unmatched parentheses
19:50:19 <sw17ch> faxathisia, see hpaste
19:50:22 <sw17ch> ot
19:50:25 <sw17ch> it's what i have so far
19:50:27 <ArmchairDeity> hey seancorfield
19:50:34 <ArmchairDeity> or scorfield even
19:50:36 <scook0_> LoganCapaldo: (:[])
19:50:46 <sw17ch> omnId, the latest paste includes my changes... thanks for your help earlier
19:51:06 <LoganCapaldo> > 2 -- :)
19:51:08 <lambdabot>  2
19:51:16 <LoganCapaldo> ah it's fixed
19:51:20 <scook0_> so I guess it's more of a "concrete syntax tree" than an abstract one :)
19:51:26 <omnId> > "(" -- )
19:51:27 <lambdabot>  "("
19:51:27 <faxathisia> haha
19:52:36 <omnId> sw17ch: do you want to add the other cases to LispExpr's getRepresentation?
19:52:37 <sw17ch> faxathisia, if you looked at the paste, all i'm trying to do is create a common function to extract the first part of the data type or the second part... the "Representation" or the "Value"
19:52:59 <faxathisia> sw17ch: representation (AtomExpr x _)  = x
19:53:04 <sw17ch> omnId, yes... i was hoping i could do it without having to have an instance for each of AtomExpr, StringExpr...
19:53:08 <faxathisia> sw17ch: representation (StringExpr x _)  = x
19:53:11 <faxathisia> sw17ch: and so on
19:53:16 <firefly> Cale, I have a much shorter, self-contained program that shows the bug under all three versions of ghc/ghci I have, including 6.8.1.
19:53:18 <sw17ch> faxathisia, so it has to be done for each eh?
19:53:39 <firefly> http://hpaste.org/3711
19:53:46 <omnId> sw17ch: instance associates one type with a class, you only have one type, but it needs more cases for its constructors.
19:53:54 <faxathisia> sw17ch: so where are you going with this, it seems very strange :)
19:54:14 <sw17ch> faxathisia, this specific case? or the project as a while?
19:54:16 <sw17ch> whole*
19:54:36 <SideFFect> ugh stupid rules
19:54:51 <SideFFect> can I have an else let h = etc in fctname
19:54:57 <SideFFect> to pass h to fct
19:54:57 <Cale> um, I get the expected result, I think
19:54:58 <SideFFect> er wait
19:55:03 <sw17ch> how would the instance for my "value" function go (since i have funny differences in the second attribute)
19:55:06 <Cale> oh, no
19:55:09 <omnId> SideFFect: sure
19:55:21 <faxathisia> @src fromIntegral
19:55:21 <lambdabot> fromIntegral = fromInteger . toInteger
19:55:31 <omnId> sw17ch: you might have a simple non-string'd LispExpr type, then another data LispExprRep = LER String LispExpr
19:55:31 <Cale> Oh, I see what's happening
19:55:52 <Cale> firefly: I think your main thread is dying before the forked processes have a chance to finish
19:55:59 <faxathisia> sw17ch: You couldn't have a function which returns different types
19:56:09 <ArmchairDeity> lambda calculus???
19:56:22 <omnId> ArmchairDeity: what of it?
19:56:34 <sw17ch> faxathisia, well.. that brings me to my previous data problem... i'm not good at figuring out how to make things "go"
19:56:50 <faxathisia> sw17ch: You want to write an interpreter now?
19:56:55 <sw17ch> i originally had data types for the first parameter and the second,
19:57:07 <ArmchairDeity> I was just reading up on "the haskell kernel"
19:57:08 <sw17ch> faxathisia, not an interpreter so much as just a good AST
19:57:12 <ArmchairDeity> omnid
19:57:16 <sw17ch> faxathisia, the interpreter isn't necessary for the project
19:57:19 <faxathisia> I think you have a fine AST
19:57:20 <ArmchairDeity> and it says it boils down to lambda calc
19:57:23 <sw17ch> only a limited one will be needed
19:57:24 <firefly> Cale, I think so too -- but how do I wait for a thread?
19:57:25 <omnId> ArmchairDeity
19:57:41 <omnId> ArmchairDeity: pretty much, with some extra stuff.
19:57:57 <sw17ch> faxathisia, what i really want is this -- rep :: LispExpr -> String
19:58:02 <faxathisia> sw17ch: It might be a good idea to create a LispValue type though which each LispExpr's value is
19:58:04 <Cale> firefly: I suppose the simplest way is to have the thread set an MVar when it's done.
19:58:19 <faxathisia> sw17ch: so instead of AtomExpr       String String, you have AtomExpr       String LispValue
19:58:22 <sw17ch> faxathisia, is there a chance you could help me with that... i've tried it several different times and can never get it right
19:58:28 <firefly> but that will still have a race, won't it?
19:58:35 <faxathisia> sw17ch: yeah
19:58:37 <sw17ch> faxathisia, originally i had AtomExpr AtomRep AtomValue
19:58:51 <sw17ch> faxathisia: i believe the original code is in the paste if you look up higher
19:58:57 <firefly> the useful work of the thread will be over but the thread context or what ever the runtime system uses internally to represent the thread might not be reaped until later.
19:59:19 <hpaste>  faxathisia annotated "AST: Second Try" with "rep" at http://hpaste.org/3703#a2
19:59:41 <ArmchairDeity> omnID: I shoulda gone to college ;)
19:59:43 <firefly> I think what happens is a bad interference between "unreaped" thread contexts and runInteractiveCommand, possibly because the latter forks in a way that isn't nice to the threads.
19:59:47 <sw17ch> faxathisia: cool... but what about for value?
19:59:59 <firefly> (but it's just a loose guess at the moment)
20:00:02 <faxathisia> sw17ch: I want to show you how I'd do it.. I'm pasting
20:00:07 <sw17ch> ah, alright
20:00:08 <sw17ch> thanks
20:01:35 <hpaste>  faxathisia annotated "AST: Second Try" with "LispValue" at http://hpaste.org/3703#a3
20:02:10 <omnId> sw17ch: wait one moment...
20:02:25 <SideFFect> how do i start using | after a let?
20:03:02 <faxathisia> sw17ch: That's how I'd set it out anyway
20:03:19 <hpaste>  omnId annotated "AST: Second Try" with "will this do for your needs?" at http://hpaste.org/3703#a4
20:03:33 <omnId> sw17ch: ^
20:03:45 <faxathisia> sw17ch: if you wanted to e.g. add two LispValues, You can just do add (LispDouble x) (LispDouble y) = LispDouble (x+y) ; add _ _ = LispError or something similar
20:04:23 <omnId> sw17ch: also, ouch, long names :P
20:04:54 <sw17ch> omnId: none of my professors have used haskell more than a few minutes...
20:04:56 <faxathisia> sw17ch: What sorts of things do you actually want to use the AST for though?
20:05:06 <sw17ch> faxathisia: relation graphing
20:05:09 <faxathisia> sw17ch: also did my paste make sense
20:05:30 <sw17ch> faxathisia, can i just use the link you gave originally?
20:05:46 <sw17ch> faxathisia, nm, found it
20:05:48 <Cale> firefly: turns out you don't need the forkOS's
20:06:15 <Cale> firefly: It still dies with the threaded runtime even when running runTest all in a single thread.
20:06:20 <omnId> sw17ch: do you need, for example, the component elements in a list to themselves have string representations, or just for the whole list?
20:06:41 <sw17ch> omnId: everything needs to know what source code it came from
20:06:57 <wli> SideFFect: let mySqrt x | x < 0 = error $ "mySqrt: trying to take sqrt of negative number " ++ show x | x == 0 = 0 | otherwise = let xs = iterate (\t -> (t + x / t) / 2) ((x + 1) / 2) in snd . head . dropWhile (\(u, v) -> abs ((u - v) / (u + v)) >= 1e-10) . zip xs $ tail xs
20:07:07 <faxathisia> You should probably use a SourceCode type instead of String then
20:07:07 <omnId> sw17ch: then change faxathisia's paste so that the LispValue type includes LispExpr values mutually recursively.
20:07:12 <sw17ch> omnId: the top level list (the program) will have the entire source file as its representation
20:07:34 <sw17ch> omnId: mutually recursively?
20:07:37 <faxathisia> storing the line and column
20:08:06 <omnId> LispExprs are representations with values, LispValues are values whose subvalues have representations.
20:08:08 <faxathisia> sw17ch: I don't really know what you mean by relation graphing
20:08:12 <omnId> sw17ch: ^
20:08:24 <omnId> sw17ch: like in my paste
20:08:27 <hpaste>  Cale annotated "threads+runInteractiveCommand => SIGCHLD" with "firefly: simplified" at http://hpaste.org/3711#a1
20:08:39 <sw17ch> (a (x) (b x)) (b (x) (a x))
20:08:48 <sw17ch> a references b, and b references a
20:08:48 <firefly> Cale, thanks.  Now I know that it's not just when I run it it fails.  (btw tested the version I pasted on ghc 6.4.2 on a gentoo -- fails same way there).
20:08:54 <omnId> sw17ch: LispExpr values use the LispExpr' type, LispExpr' values use the LispExpr type.
20:09:41 <omnId> sw17ch: did you see my last paste?
20:09:57 <Cale> firefly: It looks like it's something just wrong with the way that runInteractiveCommand interacts with the threaded runtime.
20:10:02 <sw17ch> omnId: yes... i'm still working out how it works :)
20:10:12 <dataangel> Using Parsec, how do I say, "Match any character except P, unless P is preceded by a backslash." ? (char '\\' >> char '\"') <|> (symbol <|> letter <|> digit) doesn't seem to work
20:10:43 <firefly> Cale, yeah :(
20:11:18 <omnId> dataangel: (string "\\p" >> return 'p') <|> noneOf "p" -- should work
20:11:30 <firefly> Is calling hGetContents on out enough if the external program outputs more than say 4K?
20:11:37 <firefly> won't it cause a deadlock?
20:11:42 <Cale> grumble, Source Code links are gone from the new haddock docs
20:12:10 <sw17ch> faxathisia, your paste works except that you get illegal conditions accepted...
20:12:18 <faxathisia> sw17ch: And you want to create a graph like [(a, b),(b, a)] ?
20:12:22 <omnId> Cale: grumble indeed
20:12:25 <sw17ch> AtomExpr "let" False
20:12:26 <dataangel> omnId: Ah, I see why that works type wise (not realizing I should use 'return' is what was preventing me from using 'string') but why doesn't my version work? It accepts non-escaped P's
20:12:36 <faxathisia> sw17ch: Yes, that's fine
20:12:37 <Cale> hGetContents shouldn't really do much of anything until the string starts getting demanded
20:12:57 <sw17ch> faxathisia, at first, yes... later something more graphical
20:13:01 <firefly> the string isn't consumed until after waitForProcess (which must execute and return due to the IO monad threading stuff) and a process that tries to output "enough" will fill the pipe between the parent and the child.
20:13:04 <omnId> dataangel: 'p' is included in letter.
20:13:05 <Cale> However, it might read in one bufferful of data from the file, I'm not sure.
20:13:18 <faxathisia> sw17ch: As long as you create a correct AST and ensure any transformation you perform on it keeps it correct.. The thing is always correct
20:13:26 <Cale> yeah, let's stick an evaluate in between there
20:13:31 <faxathisia> sw17ch: Well I think there is no need to store any source code in your AST then
20:13:36 <sw17ch> faxathisia, I don't trust my self that much =)
20:13:41 <firefly> that tends to cause such programs to sleep until their stdout becomes ready for output again... which never happens because we don't consume the string :)
20:13:57 <sw17ch> faxathisia: i want to create that graph with actual source if i can
20:13:57 <faxathisia> sw17ch: (and did you mean (defun a (x) (b x)) (defun b (x) (a x)) or something similar?)
20:14:04 <dataangel> omnId: Err, my mistake, P was just for example. P is actually a quote mark ("). Which is not in symbol, digit, or letter :P
20:14:08 <sw17ch> faxathisia, yes, sorry
20:14:11 <faxathisia> sw17ch: ok I have an idea
20:14:12 <firefly> Cale, ok, but that only delays the problem slightly so it handles say 8K of output rather than 2M.
20:14:24 <omnId> @type parse
20:14:27 <lambdabot> Not in scope: `parse'
20:14:36 <faxathisia> sw17ch: I think the easiest thing to do would be write a simple AST which has no annotations yet, just the lisp data itself
20:14:39 <Cale> er, it actually has no impact here
20:14:44 <faxathisia> sw17ch: And then create [(a,b),(b,a)] from it
20:14:59 <faxathisia> sw17ch: Once you are at that stage, It should be quite straightforward to add SourceCode annotation to each node of the AST
20:15:15 <faxathisia> sw17ch: And extract it to create a visual graph later on
20:15:19 <firefly> The traditional C way to handle this is to have a loop that uses select() and/or non-blocking reads.
20:15:26 <dataangel> omnId: just tested, your version has the problem as well :/
20:15:36 <sw17ch> faxathisia, hmmm...
20:15:36 <firefly> I figured a nicer way would be to read until EOF in a separate thread...
20:16:18 <firefly> I've noticed that there are often subtle errors in programs that call external programs because they fail to empty the pipe that connects to the external program's stdout.
20:16:21 <omnId> dataangel: are you sure it's not getting included in any other parsers?
20:16:24 <Cale> Turns out that it dies on the hPutStr
20:16:40 <Cale> er, no
20:16:54 <Cale> you need the waitForProcess to be there as well
20:16:55 <sw17ch> faxathisia, actually, that's how i'm planning it. i just wanted to get the framework worked out... because i don't think it 's going to take me long at all to get the parserworking
20:17:30 <dataangel> omnId: Hrm... how do I trace which one it's matching? The usual error pattern match trick won't work since the parsers don't take any parameters
20:17:38 <P_D> IO programs freezing?
20:17:57 <faxathisia> sw17ch: I'd also recommend putting all your current code aside to write the 'vanilla' version
20:18:02 <P_D> I was having a problem today with hFlush locking when called in DllMain, or a thread spawned from DllMain
20:18:44 <faxathisia> sw17ch: (and represent lists as conses.. not as lists & dotted pairs that's really bizarre and will probably make things difficult)
20:18:44 <omnId> dataangel: Debug.Trace.trace is just enough evil for print debugging :)
20:19:05 * dataangel wishes he had GHC 6.8
20:19:11 <davidL> I can't get hs-plugins (darcs) built: src/System/Plugins/PackageAPI.hs:64:20: Not in scope: data constructor `InstalledPackageInfo'  I'm using GHC 6.6.1 and Cabal-1.1.6.2
20:19:20 <omnId> dataangel: trace is in 6.6
20:19:37 <dataangel> omnId: But not the new debugger I saw in the release notes :)
20:20:15 <omnId> faxathisia: it's too bizzare for the 'scheme in 48 hours' tutorial :)
20:20:19 <omnId> *not*
20:20:24 <omnId> not too bizarre
20:22:00 <hpaste>  Cale annotated "threads+runInteractiveCommand => SIGCHLD" with "the ever-shrinking test case" at http://hpaste.org/3711#a2
20:22:27 <davidL> how do you build hs-plugins? :-[
20:22:39 <Cale> oh, *that's* interesting
20:22:41 <wli> I honestly don't know when the next time is that I could get a solid 48-hour block of time.
20:22:53 <Cale> It dies even *without* the threaded runtime, it just takes longer
20:23:12 <wli> As far out in advance as I'm scheduled I have zero such blocks of time.
20:23:24 <faxathisia> wli: Just write a Jot or Iota then :)
20:23:36 <Cale> firefly: try my new testcase
20:24:12 <wli> Cale: I don't think I'm a good enough programmer anymore to get anything meaningful done in 48 hours.
20:24:25 <Cale> me?
20:24:29 <firefly> I just did -- :)
20:24:40 <firefly> crashes here too.
20:25:15 <firefly> I've been looking at the implementation of runInteractiveCommand and the reason for the bug is painfully obvious now :(
20:25:32 <firefly> it's a plain old race.
20:25:47 <firefly> the forked process dies before waitForProcess is called.
20:25:49 <wli> Races are not so obvious.
20:25:52 <dibblego> augustss++
20:26:00 <Cale> If I remove the hPutStr now, I get:
20:26:00 <wli> That's a good diagnosis.
20:26:01 <firefly> the runtime doesn't set up a signal handler for SIGCHLD.
20:26:04 <faxathisia> I quite like Parsec
20:26:05 <Cale> firefly: /bin/sh: setNonBlockingFD: invalid argument (Bad file descriptor)
20:26:25 <faxathisia> Can anyone name some parsers for haskell which work in a quite different way though?
20:26:35 <firefly> faxathisia: Happy?
20:26:36 <faxathisia> parser generators*
20:26:40 <firefly> oh
20:27:03 <firefly> Cale, what do you mean?
20:27:04 <faxathisia> ok Happy sounds like yacc
20:27:11 <Cale> runTest :: String -> IO ()
20:27:11 <Cale> runTest s = do putStrLn s
20:27:11 <Cale>                (inp, out, err, ph) <- runInteractiveCommand ("true")
20:27:11 <Cale>                waitForProcess ph
20:27:11 <Cale>                return ()
20:27:17 <faxathisia> is there any really unusual types of parser generator?
20:27:29 <hpaste>  dataangel pasted "(no title)" at http://hpaste.org/3713
20:27:43 <firefly> faxathisia: google for packrat -- there's a Haskell implementation of packrat parser generators
20:27:48 <faxathisia> ok
20:28:01 <Cale> faxathisia: Most parser generators have a similar kind of user interface as that, but might be very different internally, and in what kind of code they generate
20:28:08 <dataangel> omnId: I pasted what I have with an example string. Any ideas?  http://hpaste.org/3713
20:28:23 <faxathisia> Cale: I'm thinking about using LogicT to make a parse
20:28:43 <faxathisia> hopefully any parser you write can be used as an unparser too
20:28:53 <Cale> firefly: on my machine that runs for a while, but eventually dies with that setNonBlockingFD error
20:29:04 <Cale> even with the unthreaded runtime
20:29:12 <omnId> one minute.
20:29:51 <Cale> hmm, with the *threaded* runtime, it seems to run much longer -- I haven't yet had a crash
20:30:06 <omnId> (print = putStrLn . show, btw...)
20:30:07 <Cale> So this might be two bugs ;)
20:30:33 * firefly is currently running it with -threaded
20:31:09 <omnId> dataangel: what do you expect main to print?
20:31:10 <faxathisia> dataangel: What are you trying to write a parser for?
20:31:20 <sw17ch> omnId: in your paste, i just have one question.. .is there a good way to get the "value" ? or the LispExpr' part?
20:31:23 <Cale> I'm up to 54k or so
20:31:25 <dataangel> omnId: match failure
20:31:25 <faxathisia> dataangel: Is it just a quoted string with escape chars inside?
20:31:33 <sw17ch> omnId: other than that, that is exactly waht i need
20:31:40 <faxathisia> dataangel: e.g. parse "foo\"bar"
20:31:54 <dataangel> faxthisia: Basically, I'm just trying to add support for allowing escaped quote marks ATM, but eventually the others yeah
20:31:55 <omnId> dataangel: but parseEscapeChar is defined as parsing a character.
20:32:02 <firefly> I ctrl-c'ed it.  In any case, I know what's going wrong -- I'd consider not installing a signal handler for SIGCHLD in runInteractiveCommand a bug.
20:32:07 <omnId> sw17ch: f (Expr _ v) = v
20:32:16 <firefly> (oh, and "hi" wli :) )
20:32:17 <faxathisia> dataangel: So you want to write a parser for quoted strings with \ escapes?
20:32:25 <dataangel> faxathisia: Yes
20:32:37 <dataangel> omnId: ... hrm. Shouldn't I be getting a type error?
20:32:46 <sw17ch> omnId: never mind... i was still thinking class
20:33:01 <Cale> Do you get the setNonBlockingFD crash without the threaded runtime?
20:33:16 <omnId> dataangel: nope, parseEscapeChar eats one character and then stops.  Subsequent parsers may eat more.
20:33:32 <firefly> I've never seen that crash.  Only the silent exit code 141 one.
20:33:51 <dataangel> omnId: I must be conceptually confused... if it only parses one character at a time, how does string "\\\"" even make sense? It's two chars.
20:34:01 <omnId> string = between (char '"') (char '"') stringContents
20:34:06 <Cale> I can't make it happen with the threaded runtime, but it happens usually fairly quickly here (before 10000)
20:34:09 <omnId> dataangel: well, two chars in that case :)
20:34:14 <Cale> without -threaded
20:34:22 <omnId> stringContents = many1 ((string "\\\"" >> return '"') <|> noneOf "\"")
20:34:29 <omnId> string = between (char '"') (char '"') stringContents
20:34:33 <Cale> in fact, usually before 2000
20:34:52 <firefly> hmm.... this makes me wonder...  if no SIGCHLD handler is installed, how can a program ever work that uses runInteractiveCommand with getProcessExitCode instead of waitForProcess?
20:36:22 <dataangel> oooooh... matches as many as it can, then stops... so it's failing after h :P
20:36:40 <dataangel> err well here it's only eating h because it matches right away...
20:36:53 <hpaste>  faxathisia annotated "(no title)" with "you can split it into two sections" at http://hpaste.org/3713#a1
20:37:00 <faxathisia> dataangel: There is an example
20:37:21 <Cale> firefly: Make sure to create a ticket
20:37:26 <davidL> how do I set a specific version in build-depends?
20:37:36 <firefly> Cale, definitely!
20:37:37 <dataangel> oh hrm... so the problem I was observing was that it was matching, it's just that for the bad string rather than detecting that it's a badly formatted string, it takes the unescaped quotation as the end of the string.
20:37:52 <Cale> davidL: I think you can do  containers == 0.1.0.0
20:37:53 <dataangel> I expected it to not match at all
20:38:03 <faxathisia> dataangel: Well you had noneOf \ but you should have noneOf \ and "
20:38:05 <Cale> Or containers >= 0.1.0.0
20:38:06 <davidL> thank you Cale
20:38:07 <omnId> dataangel: wait one moment, pasting...  (it's slow!)
20:38:23 <faxathisia> dataangel: Which would be liek noneOf ['"', '\\'] or noneOf "\\\""
20:38:59 <hpaste>  omnId annotated "(no title)" with "(no title)" at http://hpaste.org/3713#a2
20:39:22 <omnId> dataangel: ^
20:39:53 <omnId> probably should be 'many' instead of 'many1'
20:40:11 <dataangel> I got it :)
20:40:37 <dataangel> now I'm trying to change the parser so that it outputs the parsed value when it finds one, so I can examine it next time
20:41:52 <dataangel> but show doesn't work on custom datatypes. My custom datatype is a union of a bunch of types that show can handle though... is there an easy way to get it to just use whatever it usually would for the contained type? data LispVal = Atom String | List [LispVal] | ... etc.
20:42:54 <omnId> dataangel: deriving Show?
20:43:02 <faxathisia> haha everyone is writing a Lisp
20:43:08 <dataangel> omnId: will it work automagically? :P
20:43:26 <faxathisia> It will display them as haskell types
20:43:34 <dataangel> wow that worked @_@
20:43:35 <faxathisia> you can also write a lisp show instance
20:44:18 <omnId> instance Show LispVal where show (Atom s) = ... ; show (List xs) = ... ; ...
20:47:05 <omnId> @@ @read @run wordsWise sortNoCase' $ (@show @yow) ++ (@show @brain)
20:47:07 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
20:47:20 <omnId> @kick @read
20:47:20 <lambdabot> Maybe you meant: dice dict kind
20:47:32 <sw17ch> faxathisia, did i miss something?
20:48:04 <faxathisia> sw17ch: You're not the only one writing a Lisp :)
20:48:14 <sw17ch> who else?
20:50:49 <firefly> apropos races and threads: isn't there a race in forkChild here: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Concurrent.html
20:50:51 <omnId> @@ @run wordsWise sortNoCase' $ (@show @yow) ++ (@show @brain)
20:50:51 <lambdabot> http://tinyurl.com/2ytfbv
20:50:52 <lambdabot>  "-- An any BUY COMMUNIST conclude Did disorder does eating game INK-LING? no...
20:51:20 <firefly> forkChild reads from an MVar, does something with the list of thread ids it reads, and then writes it back to the same MVar.
20:51:50 <firefly> As long as forkChild is only called under very controlled circumstances (such as: only in the main thread) things will be fine.
20:53:49 <firefly> If it can be called from threads we have a race...  this will lead to waitForChildren not actually waiting for all children.
20:54:40 <Cale> er
20:54:50 <sjanssen> firefly: it's safe as long as the only functions that modify 'children' are 'forkChild' and 'waitForChildren'
20:54:52 <Cale> using readMVar or takeMVar?
20:55:24 <firefly> how is it safe if more than one thread can fork children?
20:55:24 <sjanssen> firefly: remember that takeMVar blocks when the MVar is empty
20:55:24 <Cale> oh, I see what code you're talking about
20:55:42 <firefly> sjanssen: doh.  Thanks :)
20:55:52 <Cale> yes
20:56:14 <dataangel> How do scheme radix prefixes work? Do you just write "#b101010" or "#oA9F42" ?
20:56:18 <Cale> and takeMVar automatically empties the MVar as soon as it's full
20:56:55 <davidL> what goes in passwd.rc for lambdabot?
20:57:13 <Cale> a doublequoted string
20:57:17 <Cale> for the password
20:57:26 <Cale> "itisasecret"
20:57:35 <davidL> thanks
20:57:38 <sorear> Cale: no...
20:57:42 <Cale> no?
20:57:44 <Cale> oh
20:57:48 <Cale> heh, that's changed
20:58:13 <Cale> msg freenode:nickserv identify itisasecret
20:58:14 <sorear> davidL: it's sourced by the main rcfile, so it should be a complete command, like  'msg freenode:nickserv identify foobar'
20:58:29 <davidL> oh ok
20:58:35 <davidL> makes sense, thanks again
20:58:39 <sorear> davidL: it could be in online.rc, but this way dons doesn't have to check his pw into the repo
20:58:41 <faxathisia> dataangel: http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%25_idx_228
20:58:43 <lambdabot> Title: Revised^5 Report on the Algorithmic Language Scheme, http://tinyurl.com/29ttf5
20:58:49 <faxathisia> dataangel: (radix prefixes are #b (binary), #o (octal), #d (decimal), and #x (hexadecimal).)
21:00:14 <dataangel> faxathisia: I read that actually and still wasn't sure if it was simply stuck in front of the number, or separated by a space or what
21:00:15 <SideFFect> ouu too much haskell lol
21:00:19 <SideFFect> for my head heh
21:00:43 <faxathisia> dataangel: Yeah just exactly what you said, but your octal number is invalid
21:01:06 <dataangel> faxathisia: why?
21:01:13 <faxathisia> octal is base 8
21:01:17 <sw17ch> omnId: thanks again... i think i have my stuff figured out hnow
21:01:17 <dataangel> oh right :P
21:01:24 * dataangel hits head against desk
21:01:47 <omnId> sw17ch: :D
21:02:38 <omnId> dataangel: I think there's also #<radix>r<number>
21:03:02 <omnId> #3r1211222101
21:03:12 <sw17ch> #36rDATAANGEL
21:03:17 <dataangel> lol
21:03:17 <faxathisia> omnId: What is that r6rs?
21:03:19 <sw17ch> dataangel: i have parsec code that parses that
21:03:26 <sw17ch> dataangel: if you're interested
21:03:34 <omnId> *shrug*
21:03:36 <dataangel> sw17ch: nah, I'm writing it to get my feet wet
21:03:40 <sw17ch> oic =)
21:03:40 <faxathisia> never heard of it
21:03:47 <sw17ch> it took me a while :(
21:03:53 <dataangel> encouraging ;p
21:04:02 <twb> faxathisia: a Scheme specification that discards the traditional requirement of unanimity.
21:04:02 <sw17ch> dataangel: let me know how it turns out for you =) I'd like to see another implementation
21:04:33 <Cale> firefly: actually, now that I think about it, I'm not convinced that my thing is actually a bug. I'm creating lots of zombie processes.
21:04:39 <faxathisia> twb: I was asking which scheme #<radix>r is from
21:05:04 <Cale> (well, a separate bug)
21:05:22 <hpaste>  sw17ch annotated "AST: Second Try" with "AST: Final" at http://hpaste.org/3703#a5
21:05:23 <twb> faxathisia: it's from Common Lisp
21:05:43 <faxathisia> ah ok
21:05:50 <firefly> Cale, you mean the last thing you pasted?  You shouldn't get zombies (at least not a build up of them) because the code still calls waitForProcess to reap them.
21:05:55 <twb> Hmm, no specbot
21:06:16 <dataangel> What's the best way to match against something or nothing? i.e. I want to check for #o, #b, etc. but they should be optional.
21:06:17 <twb> http://www.lispworks.com/documentation/HyperSpec/Body/02_dhj.htm
21:06:18 <lambdabot> Title: CLHS: Section 2.4.8.10
21:06:30 <faxathisia> sw17ch: Did you get my comment earlier about representation of lists?
21:06:43 <sw17ch> faxathisia: yes, but to be honest... iddn't quite follow
21:06:54 <Cale> ah, right
21:07:01 <faxathisia> sw17ch: (a b c . d) is best expressed as (a . (b . (c . d)))
21:07:16 <twb> faxathisia: it is?
21:07:41 <faxathisia> *for the purposes of inspecting and manipulating an AST
21:07:44 <wli> Every language runs off AST dumps^W^WS-exprs until you write a parser for it. ;)
21:08:15 <faxathisia> It's going to be difficult if you seperate lists and dotted pairs when they are the same thing
21:08:29 <Cale> hmm, yeah, that is mysterious then
21:08:32 <faxathisia> If you use conses the whole time, it should be easier
21:08:36 <twb> separate
21:08:39 <sw17ch> faxathisia: i was working off from the DottedList example here: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
21:08:41 <lambdabot> http://tinyurl.com/2yojoc
21:08:44 <twb> Actually, I'm not sure now
21:09:10 <twb> sw17ch: I think Riastradh did a more featureful Scheme in Haskell, FWIW
21:09:34 <twb> IIRC Si48h does some nasty things
21:09:40 <twb> Like weak typing
21:10:17 <sw17ch> twb: really, i just need to recognize the syntax... i have no intention of actually interpreting the code at all yet
21:10:36 <sw17ch> twb: my project doesn't require that much (if any) interpretation must be done
21:11:36 <sw17ch> faxathisia: my code does at least provide for being able to hold (a . (b . (c . d))), correct?
21:11:43 <sw17ch> faxathisia: if so, that's all I really need right now
21:11:56 <hpaste>  sideffect pasted "always bad?" at http://hpaste.org/3714
21:12:08 <faxathisia> sw17ch: Are you aware that (a . (b . (c . d))) is equivalent to (a b c . d)
21:12:11 <SideFFect> can someone tell me why it always gives sorry j+1 =k!
21:12:15 <sw17ch> faxathisia: yes
21:13:03 <faxathisia> sw17ch: I suggest you use the canonical representation so you can have a single representation for each expression and exploit the languages homoiconicity.. makes processing it a lot more natural
21:13:28 <faxathisia> sw17ch: in other words, drop list and dotted pair and use conses for everything.. note that parsing and storing as an AST can uses different representations
21:13:33 <sw17ch> faxathisia: so, for my list representation, use a recursive structure rather than the list i have currently?
21:13:51 <sw17ch> faxathisia: so store the tree as a set of conses
21:13:55 <faxathisia> sw17ch:  | LispCons LispValue LispValue
21:13:59 <faxathisia> sw17ch: as in my paste
21:14:42 <sw17ch> faxathisia: hmm.. now that i'm thinking about it... yeah, i'll give that a shot
21:14:49 <faxathisia> I can only imagine things being harder with the current representation which makes the distinction between lists and pairs
21:15:38 <dfranke> I want to print certain trace messages only when assertions are turned on.  I'm doing it by writing: assert (trace "foo" True) -- which looks a bit silly.  Is there a better way?
21:15:56 <Cale> SideFFect: try with  find 1 [1,2,3,4]
21:16:03 <sw17ch> faxathisia: i guess i was originally thinking all i'd ever have to do with a list is concatenate the representations of the LispExpressions contained therein
21:16:22 <sw17ch> faxathisia: but the recursive representation would make things easier, now that i think about it
21:16:23 <Cale> oh, yeah, it still hits that case
21:16:30 <faxathisia> sw17ch: cool, I hope it helps
21:16:54 <Cale> SideFFect: are you really supposed to be using splitIn2?
21:17:25 <Cale> find 2 [1,2,3,4]
21:17:28 <wli> Try find (== 1) [1..4]
21:17:35 <faxathisia> sw17ch: You can just traverse the tree recursively (stopping at quotes), make a list of the car of everything and there's all the functions or macros a bit of code calls
21:17:37 <Cale> That won't hit the j+1 == k case
21:17:38 <wli> Or find (==2) [1..4]
21:17:57 <faxathisia> sw17ch: so for a given definition that would be how you get [(a,b)] which you would append with [(b,a)] later, in your previous example
21:18:36 <omnId> SideFFect: I wrote a brain-dead translation of your teacher's http://hpaste.org/3682 into Haskell.  I think it has an error!
21:19:02 <SideFFect> whats that omni?
21:19:06 <bparkis> suppose you have a solution for the flow problem for undirected networks (i.e. c(a, b) = c(b, a)).  Can you use this to solve the flow problem for directed networks?
21:19:08 <SideFFect> and cale, why wont it?
21:19:43 <Cale> Because it finds the element before it ever has to examine a case where the list is short
21:19:47 <omnId> *Main> find 9 [0..9]
21:19:52 <omnId> -1
21:20:09 <wli> Is this shadowing the Prelude's find?
21:20:17 <omnId> yes
21:20:24 <Cale> wli: The Prelude doesn't have a find, does it?
21:20:29 <Cale> Isn't that in Data.List?
21:20:37 <bparkis> i.e. can the flow problem for directed networks be solved by decomposing the directed network into some undirected networks, solving the flow problem on those, and combining?
21:20:44 <hpaste>  glguy pasted "xmonad.hs for built in status bar" at http://hpaste.org/3715
21:20:44 <omnId> wli, Cale: er, yes actually
21:20:48 <wli> I think the Prelude (re-)exports it.
21:20:52 <wli> Maybe I'm wrong.
21:21:06 <Cale> cale@zaphod:~$ ghci
21:21:06 <Cale> GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
21:21:06 <Cale> Loading package base ... linking ... done.
21:21:06 <Cale> Prelude> :t find
21:21:06 <Cale> <interactive>:1:0: Not in scope: `find'
21:21:07 <lambdabot> Title: The Glasgow Haskell Compiler
21:21:11 <SideFFect> hum...what am I doing wrong?
21:21:12 <omnId> from ghci: Module `Prelude' does not export `find'
21:21:22 <SideFFect> and omni, you didnt explain what u meant about teacher error?
21:22:07 <omnId> SideFFect: in my translation, searching a list for x, where x is the *last* element, doesn't find it.  I may have an error, though.
21:22:10 <bparkis> the simplest way to do that is to create 2^E undirected networks, one for each possible direction of flow for each edge
21:22:21 <bparkis> but this is not practical
21:22:53 <omnId> *Main> map (\x -> find x [0..9]) [-2..11]
21:22:57 <omnId> [-1,-1,0,1,2,3,4,5,6,7,8,-1,-1,-1]
21:23:25 <SideFFect> now im confused :P
21:24:37 <hpaste>  omnId annotated "imper_teach" with "braindead translation.  Did I make any errors?" at http://hpaste.org/3682#a1
21:25:51 <Cale> yeah, I just ran the teacher's code by hand
21:26:00 <Cale> and it failed to find 5 in [1,2,3,4,5]
21:26:17 <monochrom> Yay!
21:26:18 <SideFFect> so im not going nuts for nothing?
21:26:20 <Cale> It terminates the loop too early.
21:26:30 <omnId> also:
21:26:37 <omnId> *Main> find 1 [0]
21:26:39 <faxathisia> how does DPL work?
21:26:48 <Cale> So when j was 4 and k was 5, it stopped
21:26:52 <omnId> Interrupted. -- infinite loop!
21:27:01 <omnId> searching a one-element list diverges.
21:27:22 <Cale> and then checked to see if x (which was 5) was equal to a[j] = a[4] = 4, which is false
21:27:27 <faxathisia> maybe the evaluation of a DPL program is really weird?
21:27:31 <Cale> and so it returns 0, which is incorrect
21:27:33 <sw17ch> faxathisia: mind if i ask what your line of work is that you know these things like you do?
21:27:56 <SideFFect> where does this leave me? :P
21:28:18 <faxathisia> sw17ch: I'm just enjoy programming so I do it a lot :p
21:28:22 <omnId> SideFFect: with broken code from your prof.
21:28:23 <Cale> With a buggy imperative program to translate into Haskell?
21:28:46 <SideFFect> :D what can I tell him he needs to change?
21:28:47 <Cale> It's quite reasonable to translate it, even though it's totally broken.
21:29:02 <SideFFect> er, well then tell me what I should watch out for?
21:29:13 <darinm> "let {ghc-6.8.1: panic! (the 'impossible' happened)"
21:29:17 <darinm> woot
21:29:43 <Korollary> high five
21:29:56 <omnId> SideFFect: I dunno, I have a lot of trouble understanding it.  It's been a while since I coded in one of your bizarre "imperative" languages with the weird implied sequencing. :)
21:29:56 <darinm> "a static opt was looked at too early!"
21:30:03 <darinm> that mean anything to anyone?
21:30:14 <sw17ch> faxathisia++
21:30:28 <Cale> Just tell him that searching for 5 in [1,2,3,4,5] doesn't work, and that searching through a list of length 1 will loop forever when the thing being searched for is larger than the list element.
21:30:58 <firefly> Cale, your setNonBlockingFD bug is a bug in the test case -- it leaks file descriptors because it never calls hClose
21:31:02 <omnId> Cale: nope, find 0 [0] = _|_
21:31:17 <Cale> firefly: ah, right
21:31:23 <omnId> Cale: or did I misunderstand you? :)
21:31:30 <SideFFect> sigh... heh... what do I need to change to fix my program tho?
21:31:53 <Cale> omnId: well, in some other cases as well ;)
21:32:19 <Cale> SideFFect: you want to fix it to have the same bugs as your prof's?
21:32:20 <omnId> Cale: searching any list of length one will diverge.
21:32:40 <omnId> :D
21:32:54 <Cale> omnId: oh, yes
21:32:56 <SideFFect> lol no I want to fix it so its right :P
21:33:03 <SideFFect> then I can tell him his was buggy :P
21:33:09 <sw17ch> whoever was asking about haskell web applications earlier might want to look at this: http://www.defmacro.org/ramblings/haskell-web.html
21:33:10 <lambdabot> Title: Haskell and Web Applications
21:33:18 <Cale> omnId: because k and j are only ever set to h, which will be (1 + 1) div 2
21:33:21 <Cale> which is 1
21:33:25 <Cale> So they never change
21:33:37 <omnId> right.
21:33:45 <Cale> and the condition on the loop will always succeed then
21:34:01 <dataangel> Why does readOct return a list of tuples? Why does it even bother with the tuple, let alone the list of them? :P
21:34:18 <Cale> SideFFect: well, this j+1 <> k test is completely silly
21:34:29 <omnId> dataangel: does it give a ReadS?
21:34:33 <Cale> It should be j <> k
21:34:36 <twb> http://members.cox.net/stefanor/vty/_darcs/patches/ hasn't had any new patches since last December; how do I work out if this is "the" Vty repo?
21:34:37 <lambdabot> Title: Directory listing
21:34:53 <sorear> twb: ask
21:34:59 <nburlett> did the Put monad not get pulled with the Data.Binary package when it was merged into the base?
21:35:02 <twb> Ahem.
21:35:07 <dataangel> omnId: No :t readOct gives Num a => a -> [(a, String)]
21:35:08 <sorear> twb: the answer is yes, sadly
21:35:08 <twb> Where is the canonical Vty repo?
21:35:12 <omnId> dataangel: the String in the tuple's snd is the unparsed remainded after parsing the number, and if there are multiple acceptable parses, each is returned in the list.
21:35:14 <SideFFect> so do I email him, or just fix it myself?
21:35:15 <twb> Darn.
21:35:21 <omnId> @type readOct
21:35:23 <shortcircuit> Dear God, there's a lot of people in here.
21:35:23 <Cale> SideFFect: I'd do both :)
21:35:23 <lambdabot> forall a. (Num a) => String -> [(a, String)]
21:35:25 <dataangel> omnId: whoops got that slightly wrong
21:35:33 <Cale> shortcircuit: there are?
21:35:36 <Cale> @users
21:35:36 <omnId> shortcircuit: yes :)
21:35:37 <lambdabot> Maximum users seen in #haskell: 424, currently: 359 (84.7%), active: 24 (6.7%)
21:35:37 <dataangel> omnId: Num a => String -> [(a, String)]
21:35:41 <SideFFect> hehe ok ill email him and tell him I tried it imperitively and it doesnt give what you said
21:35:41 <omnId> @src ReadS
21:35:42 <lambdabot> Source not found. I feel much better now.
21:35:48 <faxathisia> yeah there is :p
21:35:48 <sorear> twb: wli is working on a new version, ask him for a preview
21:35:49 <Cale> It's not recordbreaking ;)
21:35:53 <dataangel> omnId: How would you have multiple acceptable parses of a hex number?
21:35:56 <twb> sorear: basically I wanted to play with implementing a rougelike, and didn't want to deal with the various horrible curses FFIs in Lisps and Schemes
21:36:00 <dataangel> omnId: Or an octal one?
21:36:08 <twb> wli: ping
21:36:09 * dataangel bangs head, octal != hex
21:36:22 <twb> dataangel: it is, for very small values of 16
21:36:25 <faxathisia> twb: It's impossible to make a good binding for curses
21:36:30 <twb> faxathisia: granted
21:36:37 <twb> faxathisia: IIUC, Vty is not a curses binding
21:36:41 <faxathisia> oh cool
21:36:45 <Cale> shortcircuit: are you new to Haskell or just to this channel? (Or have I somehow just not run into you yet?)
21:36:47 <twb> But by `horrible' I meant `incomplete, buggy, wrong'
21:37:01 <shortcircuit> Cale: Kinda both.
21:37:04 <omnId> dataangel: dunno, but lots of parsey bits use type ReadS a = String -> [(a, String)] for that occasion, so they are the same and hook together in the same way.
21:37:05 <sorear> vty is a very incomplete curses replacement
21:37:26 <twb> sorear: initially I want something easy to understand, because I am very ignorant
21:37:30 <sorear> I wrote it for a program long ago, and since then I've had neither intrinsic interest nor more users
21:37:31 <Cale> Welcome then, make sure to ask any questions you might have :)
21:37:36 <shortcircuit> Cale: Actually, I run a programming chrestomathy site, and wondered if anyone would be interested in filling out some of the tasks with Haskell code.
21:37:53 <sorear> twb: vty is *very* easy to understand, I wrote it out of frustration with the curses documentation
21:38:00 <twb> sorear: good, good.
21:38:15 <Cale> shortcircuit: I'll take a look
21:38:43 <twb> sorear: does it do terminfo-y stuff, or is it even simpler than that?
21:39:01 <shortcircuit> And my wireless keyboard is failing...need o fn ateries.
21:39:10 <SideFFect> good email to prof?
21:39:10 <SideFFect> Professor, I ran your code imperatively just to get a better grasp and it doesnít workÖI think itís buggy.
21:39:11 <SideFFect> Searching for 5 in [1,2,3,4,5] doesnít return it, and searching through a list of length 1 loops forever when the item being searched for is larger then the list element.
21:39:11 <SideFFect> Any ideas?
21:39:26 <Cale> er
21:39:38 <Cale> actually searching through *any* list of length 1 will loop forever
21:39:47 <Cale> (we figured that out later)
21:39:51 <SideFFect> alrighty
21:39:54 <SideFFect> heh :P
21:39:54 <omnId> SideFFect: "searching through a list of length one loops forever" period.
21:39:57 <shortcircuit> Ah...the keyboard just drifted out of freq lock.  Fixed.
21:39:57 <Cale> Well, omnId already knew :)
21:39:59 <twb> SideFFect: why would a student send you that?
21:40:05 <shortcircuit> Cale: Anyway, the site is rosettacode.org.
21:40:13 <Cale> twb: He's a student, and sending his prof that
21:40:16 <twb> I see.
21:40:24 <SideFFect> its on its merry way
21:40:24 * twb rereads with new context
21:40:47 <twb> I would point out the use of "smart" quotes is annoying because you're not using UTF-8 and my client is lazy
21:40:51 <sorear> twb: haha, no.  ansi escapes only (this is much of wli's focus)
21:41:07 <omnId> twb: probably copy/pasted from Word :)
21:41:09 <twb> sorear: icky.
21:41:23 <SideFFect> now I see what he answers :P
21:41:27 <nburlett> SideFFect: what code is this?
21:41:33 <SideFFect> and in mean time I try to fix my own code heh
21:41:36 <firefly> Cale, files as http://hackage.haskell.org/trac/ghc/ticket/1842
21:41:36 <twb> omnId: I didn't want to cast such a slur
21:41:38 <lambdabot> Title: #1842 (runInteractiveCommand should install SIGCHLD handler) - GHC - Trac
21:41:43 <omnId> nburlett: http://hpaste.org/3682
21:41:51 <SideFFect> thanks :)
21:42:26 <nburlett> SideFFect: what course?
21:42:55 <Cale> firefly: you seem to like braces and semicolons ;)
21:42:59 <SideFFect> comp 348: Principles of programming languages
21:43:26 <firefly> I just didn't bother to fix the formating up... :/
21:43:45 <twb> Some day, some one is going to come up with a meaningful unit name
21:43:52 <nburlett> SideFFect: Concordia U?
21:44:16 <SideFFect> yep! you went there?
21:44:31 <Cale> firefly: which editor do you use, btw?
21:44:38 <nburlett> SideFFect: no, I can google :->
21:44:46 * nburlett went to Cornell
21:44:55 <SideFFect> hehe thought so
21:44:56 <firefly> gedit
21:45:08 <omnId> SideFFect: do you see how I translated your prof's code into Haskell?
21:46:10 <SideFFect> yeah, im seeing how its done now...but I cant use all those imports, not that im using that anyway
21:46:46 <omnId> SideFFect: the Unsafe and Concurrent were just to get the trace debugging function.
21:46:47 <Cale> SideFFect: the only imports are for the tracing
21:47:21 <SideFFect> ohh
21:47:46 <Cale> and to hide the Prelude's version of !! so that he can define it locally
21:48:02 <SideFFect> yeah my code has lots of !! :P
21:48:23 <omnId> Cale: now that I look at it, it shouldn't be ambiguous, should I shouldn't need to hide it.
21:49:34 <Cale> Really, that prof's code is a *great* example of why understanding the behaviour of imperative programs is hard.
21:49:41 <omnId> Cale: do you happen to know if using a qualified name (Prelude.!!) when you haven't imported the module qualified (just non-qualified) is Haskell 98?
21:49:43 <Cale> and why referential transparency is good
21:49:50 <hpaste>  calvins pasted "Question about inlining" at http://hpaste.org/3716
21:50:01 <omnId> /agree Cale
21:50:20 <SideFFect> heh
21:50:26 <nburlett> durr.. what's this: "unknown scattered relocation type 4"
21:50:31 <SideFFect> too bad I was brought up an imperitive boy :P
21:50:33 <calvins> good evening, i just pasted a code snippet that is exhibiting some bizarre (to me) behavior
21:50:46 <Heffalump> omnId: yes, it is
21:50:46 <SideFFect> and its used everywhere for jobs
21:50:48 <omnId> Don't fight it!!  Give in to the side of good!!
21:50:54 <SideFFect> hehe
21:50:54 <calvins> does anybody see a problem with that code, or may I have hit a GHC bug?
21:51:06 <omnId> thanks, Heffalump
21:51:42 <Cale> calvins: well, one thing I'd be careful about is that when there are multiple errors, which message you get is not guaranteed
21:51:50 <SideFFect> for your code, when I run find 5 [1..5] it returns 3...whats 3?
21:51:53 <SideFFect> the position?
21:52:06 <calvins> oh, that's good to know
21:52:19 <calvins> in that case though, it should either fail in both cases or in neither case though
21:52:32 <calvins> because it's the same code, just with the guards in a different order
21:52:34 <Cale> that's true
21:52:48 <calvins> so they should both get checked either way, but somehow that's not what's happening
21:52:54 <omnId> SideFFect: yes
21:53:05 <omnId> SideFFect: try searching for 'o' in "hello world"
21:53:22 <SideFFect> so then its wrong then? because 5 obv isnt in position 3?
21:53:27 <omnId> SideFFect: different types and it's less confusing :)
21:53:34 <Cale> calvins: yes, that seems kind of strange.
21:53:38 <Cale> calvins: Which GHC?
21:53:43 <omnId> wait, it gave 3?!
21:53:45 <calvins> Cale: 6.8.1
21:53:50 <Cale> hmm
21:54:08 <SideFFect> yeah gives -1 the hello world
21:54:17 <omnId> *Main> find 5 [1..5]
21:54:20 <omnId> -1 -- SideFFect
21:54:31 <omnId> that's what it gave when I ran the copy/pasted code
21:54:40 <SideFFect> why did it give me 3?
21:54:41 <Cale> wait, -1?
21:54:47 <Cale> why not 0?
21:54:53 <omnId> SideFFect: gremlins
21:54:58 <calvins> okay, i'll make a simple test case and submit a bug report
21:55:05 <omnId> Cale: find ... = (...) - 1
21:55:08 <Cale> calvins: Yeah, that seems sane
21:55:10 <calvins> assuming it still shows up in a simpler case...
21:55:34 <calvins> thanks for the confirmation
21:55:35 <Cale> omnId: oh, then that's a difference between the imperative code and your code
21:55:51 <omnId> Cale: just in the result :)
21:56:17 <omnId> but yeah, you're right
21:56:22 <Cale> actually, why are you subtracting that 1?
21:56:46 <omnId> for 0-indexing, like normal people use :P
21:56:46 <SideFFect> i hope I didnt send the teacher the email for nothing :P
21:56:52 <Cale> ah
21:56:59 <Cale> SideFFect: no, it's fine
21:57:13 <Cale> SideFFect: the imperative code is broken, and I've checked that by hand
21:57:15 <omnId> SideFFect: nah, delete the (...) - 1 and it still behaves the same.
21:58:32 <SideFFect> isnt -1 needed to go to end of list?
21:59:05 <Cale> It's only giving -1 because the original behavior was to give 0 when the element wasn't found, and he's explicitly subtracting 1
21:59:25 <omnId> SideFFect: his code indexes from 1 and returns 0 on failure, my code does the same, but subtracts 1, so it indexes from 0 and gives -1 on failure.
21:59:34 <SideFFect> ohh
22:00:17 <omnId> you can change the one line of code to: 'find x a = find' 1 (length a) where' if it bothers you :)
22:00:48 <faxathisia> what is find suppose to be?
22:01:10 <omnId> faxathisia: findIndex on sorted list, binary search
22:01:24 <faxathisia> hm : |
22:01:25 <SideFFect> heh :P
22:01:32 <faxathisia> I think a List is really not appropriate
22:01:46 <omnId> faxathisia: as does everyone else.
22:01:48 <faxathisia> but I actually don't know about any structure in haskell which has O(1) acess
22:02:00 <omnId> MArrays should
22:02:11 <omnId> (or something like it)
22:02:56 <hpaste>  nburlett pasted "Data.Binary.Put doesn't work ?-<" at http://hpaste.org/3717
22:03:23 <nburlett> could someone take a look at the code I posted and tell me wtf I'm doing wrong?
22:03:26 <SideFFect> find 5 [1..5] works now?
22:03:29 <SideFFect> gives 4
22:04:47 <omnId> SideFFect: what did you change?
22:05:11 <SideFFect> took off the -1
22:05:31 <monochrom> nburlett: are you supposed to use Data.ByteString or Data.ByteString.Lazy? The type error seems to say the second. Anyway, check the type of runPut again.
22:05:48 <omnId> SideFFect: taking away the subtraction at the end wouldn't get rid of the infinite loop in the middle.
22:05:53 <Cale> SideFFect: that's wrong
22:06:11 <nburlett> monochrom: runPut :: Put -> ByteString
22:06:27 <SideFFect> you guys just said to take away the -1? :P
22:06:37 <omnId> nburlett: same ByteString type?
22:06:38 <Cale> SideFFect: no, taking that away is fine
22:06:46 <monochrom> Both Data.ByteString and Data.ByteString.Lazy provide a "ByteString" type, same local name. Which one is it?
22:06:52 <Cale> it's just that 4 is an incorrect response
22:06:56 <nburlett> omnId: I have no idea
22:07:01 <SideFFect> how so? 0-4
22:07:04 <SideFFect> is the number 5
22:07:08 <monochrom> They are different, but same name.
22:07:13 <Cale> It's not using 0-indexing
22:07:28 <SideFFect> its using 1 indexing?
22:07:36 <Cale> It's using 1-indexing. The correct response would be 5
22:07:51 <SideFFect> oh... so it doesnt work for anything then?
22:08:01 <SideFFect> I tried find 14 [1..14] and it gave 13
22:08:07 <nburlett> monochrom, omnId: no, they seem to be different... odd
22:08:11 <Cale> that's strange actually
22:08:19 <monochrom> It is likely you have to go through the entirety of the Data.Binary.Put doc page to find out.
22:08:34 <Cale> because when I run the code by hand, it doesn't find the last element at all
22:09:31 <Cale> yeah, you must have changed something else
22:09:32 <SideFFect> actually ur right
22:09:36 <Cale> I just ran the Haskell code.
22:09:41 <SideFFect> find 14 [1..14] gives 13
22:09:42 <Cale> without the -1
22:09:46 <Cale> and it gives 0 for that
22:09:50 <Cale> *Main> find 14 [1..14]
22:09:50 <Cale> 0
22:09:50 <SideFFect> find 14 [1..15] gives 13
22:09:58 <omnId> nburlett: try importing Data.ByteString.Lazy as B
22:10:02 <SideFFect> did you take off the -1?
22:10:07 <Cale> yes
22:10:19 <SideFFect> odd ill paste what im using
22:10:31 <nburlett> omnId: woo
22:10:37 <hpaste>  sideffect pasted "see-same" at http://hpaste.org/3718
22:10:53 <hpaste>  Cale annotated "imper_teach" with "translation with same behaviour as imperative code" at http://hpaste.org/3682#a2
22:11:01 <nburlett> omnId: that seems to have let it build
22:11:12 <Cale> SideFFect: you missed the definition of !!
22:11:27 <Cale> SideFFect: the Prelude's !! uses 0-based indexing
22:11:43 <Cale> It's important to replace it with a version which does 1-based indexing if you're translating the code.
22:11:47 <SideFFect> yeah I know?
22:11:50 <SideFFect> oh...
22:12:00 <Cale> http://hpaste.org/3682#a2
22:12:10 <monochrom> By following the hyper-link in "runPut :: Put -> ByteString" it is revealed to be the Lazy one.
22:12:48 <monochrom> The error message, of course, prophesized it.
22:13:14 * monochrom hugs GHC error messages. They're informative and to-the-point!
22:13:23 <SideFFect> it doesnt end if the list is 2 digits tho
22:13:29 <SideFFect> meaning it gives the final answer
22:13:37 <hpaste>  Cale annotated "imper_teach" with "could also do this" at http://hpaste.org/3682#a3
22:14:23 <SideFFect> hm
22:14:38 <roger`> hi, I'm reading programming in haskell, there is an exercise in chapter 4 "Consider a function safetail :: [a] -> [a] that behaves as the library function tail, except that safetail maps the empty list to itself, whereas tail produces an error in this case" - what does it mean, "maps the empty list to itself"?
22:14:57 <Cale> safetail [] = []
22:15:17 <omnId> a function is a mapping from inputs to outputs
22:15:20 <roger`> Cale: I was thinking that, but it seemed to simple
22:15:47 <SideFFect> weird how it cant find the last element
22:16:05 <hpaste>  nburlett annotated "Data.Binary.Put doesn't work ?-<" with "it builds, ship it" at http://hpaste.org/3717#a1
22:16:08 <monochrom> It is that simple.
22:16:23 <Cale> SideFFect: it should be pretty obvious why it doesn't
22:16:30 <nburlett> monochrom: I didn't quite realize there were two different types
22:16:38 <Cale> SideFFect: try carrying out the steps of the imperative algorithm on paper
22:16:43 <nburlett> monochrom: it now segfaults ;-<
22:16:47 <SideFFect> will do :D
22:17:00 <monochrom> That is interesting :)
22:17:08 <roger`> Cale: thanks
22:17:23 <Cale> SideFFect: basically, it's stopping when it still has two possible elements to choose between
22:17:47 <Cale> SideFFect: and if the element is not the first of those two, then it fails to find it
22:17:58 <SideFFect> ohh true, the j+k thing
22:18:05 <SideFFect> I was wondering...its a dumb loop invariant
22:18:21 <SideFFect> what happens if u search for 14 and it comes down to 13,14...why stop?
22:18:22 <SideFFect> its dumb
22:18:33 <nburlett> wtf
22:18:37 <nburlett> can someone try my modified code?
22:18:45 <omnId> thinking in these ugly details makes my head hurt
22:18:53 <monochrom> If it typechecks and segfaults, it's probably an internal problem you can't solve.
22:19:06 * omnId wants to run back to simple pure functional programming
22:19:17 <Pseudonym> A program is type-correct if my favourite typechecker accepts it.
22:19:23 <Pseudonym> If yours doesn't, tough.
22:19:27 <nburlett> monochrom: I agree.. I just want to know if it does on other people's computers
22:19:47 <Cale> nburlett: what's your program
22:19:48 <Cale> ?
22:19:57 <omnId> Cale: http://hpaste.org/3717
22:20:08 <nburlett> Cale: what omnId said
22:20:33 <omnId> annotation #1
22:20:45 <nburlett> yeah, annotation #0 doesn't build
22:20:57 <monochrom> The only thing you can do is ensure library compatibility, i.e., use the right versions, also make sure both "binary" and "bytestring" are built by the same compiler same version, and make sure you're actually link them (rather than linking other versions). If all those are done, there is nothing more you can do.
22:21:17 * omnId has no Binary, so no test.
22:21:26 <Cale> here it just prints an empty line
22:21:31 <Cale> no segfault
22:21:35 <nburlett> huh
22:21:53 <nburlett> I grabbed my ghc 6.8.1 from scsibug
22:21:54 <monochrom> printing an empty line is right. (actually it contains one space, as induced by putWord8 32)
22:21:55 <dons> nburlett: the last program should be fine. check that your binary version is linked against your bytestring version (i.e. build bytestring then binary).
22:22:05 <omnId> nburlett: give it a stern talking-to and try again.
22:22:08 <Cale> yes, I see that
22:22:13 <dons> if it still segfaults, could be a ghc bug, or a library bug
22:22:34 <SideFFect> do you guys get paid for this? or its volunteer work?
22:22:37 <nburlett> bytestring came from the ghc installation, I think
22:22:54 <omnId> SideFFect: I do it for fun :)
22:23:09 <SideFFect> true, id help too if I could
22:23:15 <SideFFect> well, in anything else heh
22:23:15 <nburlett> SideFFect: me too, although I probably make more problems than I solve
22:23:16 <monochrom> Make sure, then, that binary was built by the same ghc installation.
22:23:26 <SideFFect> hehe
22:23:33 <dons> how do you compile it?
22:23:44 <monochrom> different ghc installations => different ABI  :)
22:23:44 <Cale> I do it for fun as well, but if you want to pay me for it, I have a paypal account ;)
22:23:47 <dons> one empty line, no segfault, in ghci
22:24:03 <dons> same when compiled, -O
22:24:09 <dons> and -O2
22:24:22 <SideFFect> heheh
22:24:27 <dons> ok, no bugs here. make sure you're running the latest binary
22:24:38 <SideFFect> I offered to pay to write me this, everyone firmly said no (evn tho I was kidding :P)
22:24:42 <dons> as there was an issue in the 0.3 release, that interacted with ghc's optimisations
22:24:47 <nburlett> I built both the binary library  and my program with "runhaskell"
22:24:53 <nburlett> binary-0.4.1
22:25:06 <omnId> SideFFect: mail me a check
22:25:06 <dons> so you're running the program with runhaskell?
22:25:16 <SideFFect> lol
22:25:18 <nburlett> that, or compiling with cabal
22:25:18 <dons> which is ghci. can you check it compiled?
22:25:23 <SideFFect> postdated for yr 3000 ok?
22:25:25 <monochrom> Sometimes runhaskell is an older version of ghc.
22:25:34 <dons> oh hmm. that's useful monochrom
22:25:36 <nburlett> how do I tell?
22:25:48 <dons> can you try: $ echo main | ghci A.hs
22:26:19 <monochrom> In some cases, when you start with an old version of ghc, and then you build or install a new version, runhaskell and runghc are not updated!
22:26:36 <dons> nburlett: and also $ ghc -o A A.hs --make ; ./A
22:26:50 <nburlett> where A.hs is my file?
22:26:53 <dons> yep
22:27:07 <dons> you're saying your last hpaste crashes?
22:27:12 <monochrom> --make implies -o A  :)
22:27:14 <dons> the simple one that should just print a byte?
22:27:20 <dons> monochrom: true.
22:27:26 <nburlett> dons: excatly
22:28:05 <nburlett> omg my computer is slow
22:28:15 <nburlett> ok, the echo | ghci crashe
22:28:23 <dons> huh. and compiled?
22:28:30 <dons> any messages at all about why?
22:28:33 <dons> which ghci version?
22:28:37 <nburlett> 6.8.1
22:28:41 <dons> arch?
22:29:11 <monochrom> How to determine runhaskell's version?
22:29:33 <nburlett> dons: architecture is PPC
22:29:40 <nburlett> dons: Mac OS X Leopard (10.5)
22:29:43 <phlpp> 'morning
22:30:27 <SideFFect> its 1:30am here
22:30:28 <SideFFect> :P
22:30:44 <omnId> SideFFect: that's morning, isn't it?
22:30:44 <phlpp> 07:30 in the morning here
22:31:29 <nburlett> dons: when I build I get "unknown scattered relocation type 4"
22:31:45 <SideFFect> lol it is
22:31:47 <nburlett> about 20 times
22:31:49 <SideFFect> kinda
22:32:12 <omnId> @@ @read @run wordsWise (filter (all isUpper)) @show @yow
22:32:13 <lambdabot>  I SELL OUT
22:32:35 <phlpp> eh? :D
22:32:40 <phlpp> @yow
22:32:40 <lambdabot> I'm dressing up in an ill-fitting IVY-LEAGUE SUIT!!  Too late...
22:32:58 <dons> nburlett: ah!
22:33:01 <omnId> @@ @read @run wordsWise sortNoCase' @show @yow
22:33:03 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
22:33:04 <dons> nburlett: i call shennagins then.
22:33:16 * omnId pokes @read
22:33:17 <nburlett> dons: ok... I have no idea :-<
22:33:30 <dons> nburlett: i think its a ghci bug on your arch (probably)
22:33:35 <scsibug> nburlett: having problems with my build?
22:33:35 <lambdabot> scsibug: You have 1 new message. '/msg lambdabot @messages' to read it.
22:33:37 <dons> are you unable to compile at all?
22:33:41 <omnId> ah!  It must fail when @run truncates the right side with a ...
22:33:45 <nburlett> I can compile some things
22:33:52 <dons> nburlett: because people are getting segfaults in ghc itself on ppc/leopard
22:33:55 <nburlett> I think
22:34:00 <dons> with this scattered message
22:34:23 <dons> are you unable to compile it at all?
22:34:34 <dons> anyone have osx/x86 handy with 6.8?
22:34:39 <scsibug> i do...
22:34:42 <dons> glguy: nburlett gets "unknown scattered relocation type 4"
22:35:02 <glguy> I get that too, but I don't know what is to be done for it :-/
22:35:07 <dons> and his ghci segfaults on this simple program: http://hpaste.org/3717#a1
22:35:15 <nburlett> hmm.. I thought I could build things
22:35:16 <glguy> mine segfaults on: ghc --version
22:35:16 <dons> glguy: did you get a working ghci?
22:35:17 <nburlett> maybe I can't
22:35:20 <SideFFect> ok guys...im off to play guitar hero 3 then sleep :D
22:35:29 <SideFFect> thanks to everyone for the help! (that helped)
22:35:35 <SideFFect> ill be back tomor with more problems lol
22:35:38 <nburlett> glguy: mine doesn't segfault there
22:35:43 <nburlett> but mine is scsibug's
22:35:49 <nburlett> scsibug: yes, it hates me
22:35:55 <scsibug> "Could not find module 'Data.Binary.Put'"
22:36:05 <nburlett> scsibug: you need the binary module
22:36:08 <scsibug> is this something i need to install?
22:36:10 <scsibug> ah, ok
22:36:13 <dons> scsibug: install binary 0.4.1 from hackage
22:36:49 <dons> so the only place we've reproduced this issue is osx/ppc/6.8?
22:36:50 <hpaste>  (anonymous) annotated "Data.Binary.Put doesn't work ?-<" with "simplified test case" at http://hpaste.org/3717#a2
22:37:10 <dons> do any programs work in ghci? :)
22:37:40 <nburlett> Prelude> filter (>3) [1..10]
22:37:40 <nburlett> [4,5,6,7,8,9,10]
22:37:42 <nburlett> yes
22:37:48 <dons> ok. so that simple case works here too. i'm really suspicious its this unstable ghc on leopard/6.8/ppc
22:38:03 <scsibug> I get the same message as nburlett posted in hpaste on 10.5/intel
22:38:13 <dons> scsibug: but does the program run?
22:38:31 <scsibug> it doesn't compile
22:39:10 <dons> nburlett: can you make a ghc bug report about this? use the minimal example that crashes, include the scattererd relocation message, and that it works everywhere else
22:39:23 <dons> and all other info we asked for.
22:39:32 <dons> can you compile with -fasm or -fvia-C ?
22:40:00 <scsibug> sorry, i didn't see the most recent paste
22:40:08 <scsibug> it runs, no errors
22:40:23 <scsibug> is it supposed to print something?
22:40:37 <dons> one blank line
22:40:44 <dons> no segfaults :)
22:40:48 <scsibug> ok, works then
22:41:09 <omnId> perhaps 32 should be changed to something more visible :)
22:41:12 <monochrom> It prints " \n"
22:41:20 <dons> ok. thanks scsibug
22:41:23 <nburlett> yeah, 42 is probably better
22:41:25 <dons> nburlett: there you go, ppc issue only.
22:41:33 <nburlett> gah
22:41:33 <omnId> > chr 42
22:41:35 <lambdabot>  '*'
22:41:36 <dons> glguy: the dangerous platform.
22:41:42 <nburlett> > chr 52
22:41:42 <scsibug> I can try on ppc 10.4, if that would help
22:41:43 <lambdabot>  '4'
22:41:51 <dons> but pretty sure that means its a ghc issue, not the library
22:41:51 <nburlett> > chr 0x42
22:41:52 <lambdabot>  'B'
22:41:56 <nburlett> > chr 0x32
22:41:57 <lambdabot>  '2'
22:42:00 <nburlett> ahh, there it is
22:42:01 <nburlett> :->
22:42:10 <omnId> hm?
22:42:48 <nburlett> I was trying to figure out why 32 was a space... I remembered it being the number 2
22:42:50 <monochrom> I am impressed by MacOS and MacBooks, PowerBooks, ...  But only two things are holding me up: price, and all these ghc problems. :)
22:43:07 <omnId> map chr [0x30..0x39] == ['0'..'9']
22:43:15 <scsibug> i'll be upgrading to 10.5/ppc on sunday, so I may go through all these problems I'm seeing other people have :/
22:43:46 <scsibug> no problems on 10.4/ppc w/ 6.8.1, fyi
22:44:12 <scsibug> for that snippet with binary
22:44:16 <omnId> nburlett: go with 42 in the bug report :)
22:44:33 <nburlett> ghc -o fail fail.hs --make -fasm ; ./fail  # BOOM
22:44:41 <dons> scsibug: huh. that's interesting.
22:44:50 <dons> nburlett: ok, can you try -fvia-C ?
22:44:54 <nburlett> ghc -o fail fail.hs --make -fvia-c ; ./fail # BOOM
22:45:05 <nburlett> where do I report bugs?
22:45:05 <dons> with -O ?
22:45:08 <dons> ?bug
22:45:08 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:45:32 <dons> "no problems on 10.4/ppc w/ 6.8.1, fyi" seems significant
22:45:47 <dons> scsibug: so 10.5/x86 is fine? was that your earlier test?
22:45:55 <scsibug> yes
22:45:56 <dons> and 10.4/ppc is also fine?
22:45:58 <dons> huh.
22:45:59 <scsibug> indeed
22:46:04 <nburlett> ghc -o fail fail.hs --make -O ; ./fail # BOOM
22:46:13 <dons> nburlett: ok. i think we have narrowed it down very well.
22:46:33 <dons> minimal program, specifically 10.5/ppc/6.8, ghci/-fvia-C/-fasm
22:46:34 <nburlett> TICKET_CREATE privileges are required to perform this operation
22:46:39 <dons> guest/guest login
22:47:06 <omnId> leave a name and email in your ticket summary.
22:49:47 <nburlett> component?
22:50:32 <dons> compiler ?
22:50:34 <dons> anything ?
22:51:02 <nburlett> k
22:53:33 <nburlett> http://hackage.haskell.org/trac/ghc/ticket/1843
22:53:34 <lambdabot> Title: #1843 (ghc 6.8.1 broken on Mac OS X Leopard) - GHC - Trac
22:54:28 * Lycurgus has 10.4.10 on an eMac recently upgraded from an iMac and isn't thinking about using haskell on it at the moment; maybe never.
22:54:28 <nburlett> oh well, I guess I'm done working on this project for now
22:54:45 <omnId> add your ByteString and Binary versions in a comment.
22:55:23 <dons> thanks nburlett. yeah, ensure they know which binary and bytestring to use
22:55:24 <dons> ghc-pkg list
22:56:43 <kfish> hi dons, OceanSpray
22:57:05 <kfish> dons: can i proofread your thesis? ;-)
22:57:32 <mwc> dons: dissertation time?
22:57:58 <nburlett> updated
22:57:59 <goalieca> don't envy him...
22:58:16 <mwc> goalieca: I'm still stuck as a lousy masters student
22:58:21 <mwc> so yes, yes I will
22:58:22 <mwc> he's done
22:58:34 <mwc> I have at least 3 more years of this shit
22:58:53 <goalieca> mwc, i'm a lousy masters student but i don't think i see the point in a phd
22:58:53 <OceanSpray> hiya kfish
22:59:10 <mwc> goalieca: depends on your goals. what do you want to do?
22:59:19 <goalieca> and mwc.. a phd is at least 3 or 4 years all by itself
22:59:37 <mwc> goalieca: not if I can direct transfer after 1 year of masters program
22:59:39 <goalieca> my goals? well.. probably just be a clinical engineer
22:59:39 <mwc> they do that here
22:59:39 <Lycurgus> nburlett: it really irritates me that they (apple) went Intel. I presume no ghc target is any better tested/robust/whatever than the Linux x86 port.
22:59:55 <twb> What does a clinical engineer do?
23:00:01 <nburlett> Lycurgus: huh?
23:00:18 <quicksilver> twb: builds clinics? :P
23:00:20 <Lycurgus> design and manage clinical studies>
23:00:24 <Lycurgus> ?
23:00:24 <twb> Lycurgus: because POWER is a technically superior architecture?
23:00:40 <Lycurgus> no just different
23:00:49 <goalieca> twb, hospital and medicine. they need engineers to manage and get things "just working" and purchased, and developped, and researched
23:00:52 <mwc> twb: at least it has more than general registers than addressing modes ;)
23:01:04 <twb> goalieca: so ping machines and stuff?
23:01:11 <nburlett> mmm, ppc
23:01:13 <twb> goalieca: or drug design?
23:01:15 <goalieca> twb , no! i'm not tech suppor
23:01:26 <goalieca> biomedical engineering.. ie: engineering of medical devices
23:01:30 <mwc> oh dear, what have I started
23:01:38 <twb> I call dem ping machines
23:01:49 <twb> Cos dey go `ping' unless you die
23:01:51 <goalieca> i hope your next CT scan pings you to death :-)
23:02:06 <twb> If you die, they go `eeeeeeeeee'
23:02:10 <omnId> The machines that go "Ping!"?
23:02:13 <goalieca> that's only an ecg
23:02:15 <nburlett> heh, my friend is working on a Biomedical PhD
23:02:27 <goalieca> biomedical FTW!
23:02:33 <goalieca> honestly.. all i'm doing now is math.
23:02:34 <goalieca> :(
23:02:39 <twb> Math owns
23:02:47 <twb> It is not polluted by nasty reality
23:02:50 <mwc> tell me about it. All I do these days is functional analysis
23:02:56 <nburlett> yeah, he's doing MRI stuff... math math math
23:03:06 <goalieca> nburlett, i'm doing DT-mri stuff
23:03:12 <goalieca> the diffusion tensor makes it sound fancier
23:03:15 <goalieca> ;)
23:03:35 <Lycurgus> haskell would have been appropropriate for a call I got from some venture a few months back based on an integration of, as you say, "ping machines".
23:03:47 <nburlett> goalieca: interesting... sounds familiar.. what school?
23:03:51 <mwc> Lycurgus: hahaha, as long as they didn't do it in C# and ASP ;)
23:04:03 <goalieca> nburlett, a canadian school by the name of SFU
23:04:05 <twb> mwc: but those are the FUTURE!
23:04:15 <twb> Didn't you GET the MEMO?
23:04:18 <nburlett> goalieca: ahh, he's at Cornell
23:04:21 <twb> Yow!
23:04:35 <goalieca> linq is poluted
23:05:04 <mwc> AbstractMemoFactory.GetGeneralMemoFetcher().SeekGeneralMemos("Future")
23:05:15 <Korollary> nice
23:05:17 <goalieca> mwc, design patterns blind my eyes
23:05:23 * nburlett banishes mwc
23:05:25 <goalieca> if i see "factory" one more time i kill you all
23:05:29 <mwc> goalieca: isn't linq basically a broken monad?
23:05:36 <Korollary> factor...ial
23:05:45 <goalieca> !slap Korollary
23:06:10 <Korollary> shush. Naslund sucks.
23:06:10 <Lycurgus> mwc: I don't recall but it definitely wasn't anything like haskell, don't know if they had decided
23:06:49 <goalieca> Korollary, i agree with you. he's been useless for a few years now
23:06:58 * goalieca cheers for the habs thuogh
23:07:01 <Korollary> damn. I thought that would be insulting to you
23:07:10 <wli> I've never even heard of Naslund.
23:07:15 <goalieca> Korollary, in vancouver we worship luongo and linden
23:07:17 <Korollary> ok Toskala sucks
23:07:27 <goalieca> lol. toronto sucks
23:07:30 <Korollary> waits that toronto
23:07:31 <wli> Or Toskala.
23:07:46 <Korollary> Luogno is sucking this season tho
23:07:50 <Korollary> err luongo
23:08:06 <goalieca> luongo doesn't know how to skate or move laterally. that's why he always gets beat on breakaway
23:08:14 <Korollary> big guy
23:08:22 <goalieca> bigger equipment
23:35:39 <nburlett> good night all
23:39:06 * mwc refreshes apt for the 8th time tonight. Still no GHC 6.8.1 :(
23:39:29 <mwc> hint hint, Igloo ;)
23:40:53 <hpaste>  sjanssen pasted "spawnPipe" at http://hpaste.org/3719
23:41:56 <hpaste>  glguy pasted "create dzen handle" at http://hpaste.org/3720
