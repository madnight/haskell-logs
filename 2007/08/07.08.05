00:04:09 <int-e> > let roll n xs = let (as, b:bs) = splitAt (n-1) xs in b : as ++ bs in roll 4 [1..5]
00:04:10 <lambdabot>  [4,1,2,3,5]
00:05:28 <timthelion> that works
00:06:47 <wli> Is that roll? I thought it was pick.
00:08:29 <int-e> no, pick preserves the 4 in the tail
00:09:34 <wli> Sorry, thanks.
00:11:23 <int-e> > let roll n m xs = let (as, bs) = splitAt n xs; (as0, as1) = splitAt m as in as1 ++ as0 ++ bs in (roll 4 1 [1..5], roll 4 3 [1..5]) -- more powerful this way.
00:11:25 <lambdabot>  ([2,3,4,1,5],[4,1,2,3,5])
00:12:22 <shapr> @yow !
00:12:22 <lambdabot> My mind is a potato field ...
00:12:59 <timthelion> what does that do?
00:14:03 <int-e> roll the first n elements of the list to the left by m places. (for 0 <= m <= n)
00:14:35 <timthelion> oh, so now it's like shifting a substring
00:14:38 <int-e> hmm. rotate is a better verb.
00:27:47 <int-e> > let splitKnot 0 ts xs = (ts, xs); splitKnot n ts (x:xs) = let (ys', xs') = splitKnot (n-1) ts xs in (x:ys', xs'); roll n m xs = let (as, bs) = splitKnot n as0 xs; (as0, as1) = splitKnot m bs as in as1 in (roll 4 1 [1..5], roll 4 3 [1..5]) -- no (++) :)
00:27:49 <lambdabot>  ([2,3,4,1,5],[4,1,2,3,5])
00:30:06 <int-e> (splitKnot is a variant of splitAt which is suitable for knot tying; we have  splitAt n xs = splitKnot n [] xs , modulo behaviour when n > length xs)
00:34:23 <RyanT5000> huh... this is an interesting use of typeclasses
00:34:31 <RyanT5000> class Rootable r where {}
00:34:38 <RyanT5000> then i have some instances
00:35:01 <RyanT5000> it's just to identify which phantom types can be provided to a particular function
00:35:12 <RyanT5000> which does some stuff on Ptrs
00:35:41 <RyanT5000> i never thought i'd end up using an empty class seriously
00:36:17 <Royal_Son> hello :)
00:36:49 <shapr> hiya
00:38:00 <RyanT5000> hi
00:39:40 <Royal_Son> hello shapr and RyanT5000
00:39:42 <Royal_Son> :)
00:40:58 <hpaste>  Royal_Son pasted "Trying to convert decimal int to binary string..." at http://hpaste.org/2072
00:41:10 <sorear> read
00:41:14 <sorear> > read "1234"
00:41:15 <lambdabot>  1234
00:41:45 <sorear> > showIntAtBase intToDigit 2 100 ""
00:41:46 <lambdabot>        add an instance declaration for (Integral (Int -> Char))
00:41:46 <lambdabot>     In the ex...
00:41:53 <sorear> > showIntAtBase 2 intToDigit 100 ""
00:41:54 <lambdabot>  "1100100"
00:42:00 <sorear> Royal_Son: Int is not deciman
00:42:04 <sorear> *decimal
00:42:32 <sorear> Royal_Son: The immediate problem with your code is that + is for numbers only
00:42:35 <Royal_Son> Well i use the word decimal but i mean integer
00:42:39 <sorear> Royal_Son: ++ is used for strings
00:42:47 <int-e> Royal_Son: |dI == 0 = 0 -- the right 0 is not a string. (decimalToBinary (dI div 2))+"1" -- you need ++ to concatenate strings.
00:42:50 <Royal_Son> aha
00:42:54 <Royal_Son> thank you
00:43:32 <sorear> Royal_Son: But see my showIntAtBase example; the function you're trying to write already exists (import Numeric)
00:43:52 <int-e> Royal_Son: with those changes it should work, but all numbers will have a leading 0 and it's inefficient because you're building a string (which is a linked list) by concatenating at the end.
00:44:00 <Royal_Son> sorear : I appreciate that but I am supposed to write my own one for an assignment
00:44:19 <sorear> Royal_Son: Oh, ok then :
00:44:20 <sorear> )
00:45:10 <Lemon> are haskell lists null-terminated too?
00:45:15 <Royal_Son> hmm still getting the same error
00:45:20 <int-e> no, they are []-terminated
00:45:25 <RyanT5000> Lemon: yes, but null is called []
00:45:33 <Royal_Son> i'll have another look
00:45:34 <RyanT5000> Lemon: also, what int-e said :)
00:45:39 <int-e> Royal_Son: oh you want  div dI 2
00:46:10 <int-e> Royal_Son: or  dI `div` 2
00:46:14 <sorear> Lemon: They are just like LISP lists
00:46:20 <kaol> > [1..] -- this isn't null terminated
00:46:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:46:38 <Lemon> ok, how to I kill someone with my nick?
00:46:41 <sorear> Lemon: (noting you have the same hostmask as a #lisper (or was it #scheme?), I assume that is meaningful to you)
00:46:49 <Lemon> -NickServ- Unknown command [kill]
00:46:54 <glguy> Lemon: ghost
00:46:54 <Lemon> I'm OceanSpray
00:46:56 <sorear> Lemon: /msg nickserv recover Lemon <password>, iirc
00:46:56 <int-e> Lemon: /msg nickserv ghost nick password
00:46:58 <Lemon> oh righrt
00:47:20 <sorear> :10 -!- OceanSpray [n=Shinku@cpe-76-169-78-244.socal.res.rr.com] has joined #haskell
00:47:23 <sorear> 00:43 -!- Lemon [n=Shinku@cpe-76-169-78-244.socal.res.rr.com] has joined #haskell
00:47:23 <Royal_Son> you're right int-e
00:47:26 <Royal_Son> thankyou
00:47:40 <OceanSpray> there.
00:47:55 <sorear> OceanSpray: It actually wasn't hard to guess that you're Lemon, since you have the same localname and ip ;)
00:48:03 <OceanSpray> yeah
00:48:17 <dons> anyone using the xmonad tabbed layout, btw?
00:48:28 <dons> who'd like to supply a nice screenshot for the xmonad web site?
00:48:39 <OceanSpray> ok, I found that Value = Pair Value Value | ... is a bit problematic for parsing.
00:49:04 <dons> so you're implementing a scheme or lisp or something, you've decided?
00:49:14 <OceanSpray> yeah
00:49:35 <dons> what's problematic about parsing into your Value type?
00:49:47 <dons> are you using  parser library, or writing your own recursive descent parser?
00:49:58 <OceanSpray> Parsec
00:50:10 <dons> good choice.
00:51:17 <dons> we've a lot of tutorials about parsec, http://haskell.org/haskellwiki/Blog_articles/Parsing#Parsec
00:51:18 <lambdabot> Title: Blog articles/Parsing - HaskellWiki
00:51:59 <sorear> From Niklas R√∂jemo's thesis ... "1. Smallest the minimum Haskell program main _ = []"
00:52:04 <sorear> Wow, that's old.
00:52:18 <dons> huh
00:52:23 <dons> well, that's circa 92 or so?
00:52:27 <int-e> oh stream based IO :)
00:52:42 <dons> looks elegant, doesn't it? :)
00:53:09 <dons> main = id -- echo ?
00:53:20 <int-e> cat
00:53:44 <int-e> main = main  is just as long as  main _ = []  ;)
00:55:21 <int-e> So we're no worse off today, except that our minimal haskell program no longer terminates.
00:56:05 <RyanT5000> main = noMsg
00:56:16 <RyanT5000> int-e: just as good, if you're counting tokens rather than characters :P
00:56:16 <int-e> oh main = id. right.
00:56:59 <RyanT5000> int-e: that doesn't work
00:57:19 <glguy> RyanT5000: he is refering to stream IO, not monadic
00:57:20 <int-e> RyanT5000: but it worked with stream based IO, and is shorter than main _ = []
00:57:39 <RyanT5000> glguy: ah, ok, i thought he was comparing to modern-day stll
00:57:43 <RyanT5000> right
01:00:04 <sorear> no, main = id won't work
01:00:19 <sorear> main :: [Responce] -> [Request]
01:01:12 <timthelion> http://hpaste.org/2073 what does this mean?
01:01:56 <int-e> timthelion: don't compare to [], use null instead
01:02:32 <timthelion> thanks
01:02:39 <int-e> timthelion: xs /= ys requires the elements of the lists to be comparable, even when one of the lists is empty.
01:02:54 <int-e> (there's nothing special about empty lists on the type level)
01:03:04 <Saizan> timthelion: you get that error because of the monomorphism restriction btw
01:03:54 <int-e> Saizan: it sounds like there's an explicit type signature for the surrounding function
01:05:11 <Saizan> int-e: uhm, yeah
01:10:17 <Boney> I'm used to useing test driven development with Java and Python.  But it doesn't seem to fit with Haskell.
01:10:48 <Boney> Since Haskell is better at catching errors.  And the code I write is much closer to my intentions.
01:11:25 <Boney> Are tests such as Unit Tests still useful with Haskell?  Or is it better to test the higher level things?
01:13:09 <RyanT5000> Boney: we have QuickCheck, which is useful, as well as HUnit
01:13:36 <Saizan> xmonad makes extensive use of quickcheck expliting the fact that the main logic is all pure
01:14:17 <RyanT5000> Boney: using the type system amounts to writing a proof of certain properties of your code; however, it's unlikely that you want to *prove* everything in your specification, and Haskell's type system isn't general enough to prove everything about your code
01:14:44 <RyanT5000> e.g., someone correct me if i'm wrong, but you can't prove the commutativity of your functions using the haskell type system
01:14:50 <RyanT5000> (whereas you could have unit tests for it)
01:15:20 <RyanT5000> basically, unit tests pick up wherever the type system leaves off; the haskell type system just takes you a lot further than most
01:15:35 <dons> yes, we use QuickCheck in preference to unit tests (more general, more automated)
01:15:41 <dons> and type system support when feasible
01:15:55 <dons> ?check \x -> reverse (reverse (x :: [Int])) == x
01:15:57 <lambdabot>  OK, passed 500 tests.
01:16:14 <dons> ?scheck \x -> reverse (reverse (x :: [Int])) == x -- SmallCheck, a bit smarter
01:16:15 <lambdabot>   Completed 25059 test(s) without failure.
01:16:29 <dons> Boney: do you have any links for QuickCheck?
01:16:41 <dons> ?google Introduction to QuickCheck
01:16:43 <lambdabot> http://haskell.org/haskellwiki/Introduction_to_QuickCheck
01:16:43 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki
01:17:30 <RyanT5000> dons: what about corner cases? is quickcheck likely to catch cases where only -1 causes a problem, e.g.
01:18:31 <dons> yes, esp. if you are careful to use generators that specifically work on corner cases
01:18:57 <dons> you can also tune the generators to generate test specific problematic values
01:19:14 <dons> and of course, unit tests are just 0-arity quickchecks
01:19:33 <RyanT5000> dons: cool; i'll have to check that out next time i don't trust my code
01:19:35 <RyanT5000> hm
01:19:48 <RyanT5000> i probably trust my code too much :P
01:19:56 <RyanT5000> then again, i put a *lot* of stuff into the type system
01:20:07 <Boney> Yes.  I've used things like this.  I was just wondering about testing in the context of the type system.  Which you have anwsered.
01:20:10 * wli tries to figure out >>= for his parsers.
01:20:19 <RyanT5000> Boney: good :)
01:21:34 <xerox> wli: Parsec automatically refactors left-recursive grammars with chainl.
01:23:57 <wli> I think my nondeterministic linear bounded automaton -based combinators might get a tad slow anyway.
01:24:34 <dons> i don't trust any of my code :(
01:25:07 <dons> Boney: yeah, you move between type system guarntees and QuickCheck testing , where appropriate
01:25:19 <dons> sometimes manual proofs (on paper) with QuickCheck to ensure things don't change, is worthwhile too
01:26:24 <RyanT5000> dons: i've never really had a good reason to not trust haskell code i've written; nearly every bug i've ever gotten has been something like "you forgot to call render in your rendering loop"
01:26:36 <dons> we even teach courses on this stuff (type systems, testing, proofs) http://www.cse.unsw.edu.au/~cs4181/
01:26:36 <lambdabot> Title: COMP4181/9181: Language-based Software Safety
01:26:40 <RyanT5000> maybe it means my code isn't complicated enough :P
01:28:25 <RyanT5000> dons: where should i apply to grad school (in a year)? i want to work on dependent types, prog lang HCI, interoperability, partial evaluation, and a couple of other things (subject to reduction without notice when thesis is due)
01:29:40 <dons> what country are you in? the US?
01:29:51 <dons> or you think internationally?
01:29:53 <RyanT5000> dons: yeah, boston, but i don't particularly mind going overseas
01:30:12 <RyanT5000> dons: as long as it's an english-speaking country, i have no qualms
01:30:41 <dons> dependent types eh? language theory eh? hmm. Pyou could got to Portland, or CMU, Chalmers. hmm. where's smerdy at (Berkley?)
01:30:53 <dons> find out where the top dependent type guys are, and go and study there.
01:31:04 <dons> i suggest hanging out with conor mcbride :)
01:31:40 <dons> i think picking the school based on researchers you want to work with is a good strategy
01:31:50 <RyanT5000> yeah, that's what everyone's told me, and it makes sense
01:32:09 <Adamant> does Cambridge have a good PL theory group?
01:32:21 <dons> yeah, the more visible your supervisors work, the better chance you'll end up working on something really innovative, and interesting
01:32:24 <RyanT5000> now i just have to figure out how to convince them that as degree in law is a good thing :)
01:32:34 <Syzygy-> RyanT5000: Note, btw, that as a native english speaker you should have no major problems going to Chalmers. Swedes are not native english-speakers, but pretty darned well-trained.
01:32:49 <reffie> ugh i really wish there was a debugger
01:32:59 <dons> reffie: you have a bug?
01:33:00 <glguy> reffie: wish granted
01:33:05 <dons> maybe you could try the ghci debugger?
01:33:11 <dons> (its in ghc head, if you can get a snapshot)
01:33:13 <xerox> reffie: there is something in ghc 6.7
01:33:19 <reffie> i can't compile ghc
01:33:22 <RyanT5000> Syzygy-: yeah; also, i figure that as long as they speak enough calculi i know... :)
01:33:30 <reffie> right now i need to change my functions to be in the IO monad so that i can print messages
01:33:37 <reffie> and it's a pain in the ass
01:33:43 <dons> reffie: hmm, use 'trace'
01:33:44 <xerox> ?docs Debug.Trace
01:33:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
01:33:46 <glguy> reffie: if you are just doing it for a quick debug, use trace
01:33:50 <RyanT5000> actually, my law school thesis will probably end up being something resembling a "real-world calculus" if i can pull it off
01:33:51 <dons> don't chnge your code to debug it :)
01:33:55 <reffie> !!!
01:34:01 <dons> :t Debug.Trace.trace
01:34:03 <lambdabot> forall a. String -> a -> a
01:34:12 <glguy> ?karma
01:34:12 <lambdabot> You have a karma of 0
01:34:15 <dons> trace (show (x,y,z)) $ rest of my code
01:34:15 <glguy> dons: what gives ? :(
01:34:19 <dons> hmm?
01:34:26 <xerox> d xs x = trace (xs ++ show x) x
01:34:32 <int-e> all karma gone.
01:34:34 <int-e> @karma-all
01:34:35 <lambdabot>  "agentz"               31
01:34:35 <lambdabot>  "moritz"               29
01:34:35 <lambdabot>  "+"                    18
01:34:35 <lambdabot>  "masak"                 9
01:34:35 <lambdabot>  "C/C"                   5
01:34:37 <lambdabot> [78 @more lines]
01:34:42 <dons> oh, looks like it died in the big power failure
01:34:46 <dons> it'll be in the darcs repo though
01:34:57 <int-e> C/C is cute
01:35:12 <glguy> int-e: ?
01:35:18 <Syzygy-> +++
01:35:19 <xerox> two eyes and a beak?
01:35:27 <Syzygy-> @karma-all
01:35:27 <lambdabot>  "agentz"               31
01:35:27 <lambdabot>  "moritz"               29
01:35:27 <lambdabot>  "+"                    19
01:35:27 <lambdabot>  "masak"                 9
01:35:27 <lambdabot>  "C/C"                   5
01:35:29 <lambdabot> [78 @more lines]
01:35:52 <int-e> @karma --
01:35:52 <lambdabot> -- has a karma of 0
01:35:55 <reffie> thanks
01:36:01 <reffie> trace looks like it could help me
01:36:03 <Syzygy-> ----
01:36:15 <int-e> (--- could come from pasting diffs)
01:36:23 <xerox> ?karma (--
01:36:24 <lambdabot> (-- has a karma of 0
01:36:29 <int-e> glguy: no, I just like that it got karma.
01:36:42 <JBGood25> @karma (
01:36:42 <lambdabot> ( has a karma of 2
01:36:51 <Vq^> karmasystem--
01:36:55 <xerox> @karma )
01:36:56 <lambdabot> ) has a karma of 0
01:36:59 <glguy> ?quote stereo
01:37:00 <lambdabot> C'ale says: Welcome to #haskell where your questions are answered in majestic stereo!
01:37:02 <xerox> unbalanced parens...
01:37:10 <int-e> huh. why the '?
01:37:11 <reffie> god bless trace!!!
01:37:12 <glguy> well... at least the quotes are still there
01:37:16 <int-e> @quote
01:37:16 <lambdabot> elpolilla says: <elpolilla> no se, me desperte pq tenia ganas de cagar | <elpolilla> y termine cagando, ba√±andome y despues en la pc xD
01:37:19 <glguy> int-e: Cale doesn't like getting pinged?
01:37:21 <xerox> reffie: repent!!!
01:37:32 * glguy doesn't care for foreign languge ?quotes tough
01:37:34 <glguy> though
01:37:35 * reffie reverts his change to make his code non-pure
01:38:08 <glguy> ?quote plane
01:38:09 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
01:38:09 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
01:38:35 <int-e> now we know why dons doesn't trust his code
01:39:42 <skew> why wouldn't he? Even his C is written by Haskell programs these days
01:40:21 <dons> :) that's true
01:41:09 <RyanT5000> did any of you read the voting machines pen. test report posted on slashdot earlier?
01:41:43 <RyanT5000> lol
01:52:07 <RyanT5000> aw; class constraints aren't allowed in foreign declarations
01:53:26 <tcr> Record fields seem to have their own namespace, blech. :)
01:53:45 <RyanT5000> tcr: what?
01:53:50 <RyanT5000> tcr: oh, rihgt
01:53:59 <RyanT5000> tcr: you mean in updates
01:54:09 <tcr> RyanT5000: Yay.
02:02:15 <wli> Parser combinator writing can get mindbending.
02:11:12 <wnoise> wli: so can using, sometimes.
02:13:06 <wnoise> wli: (I have an issue with Frisby where the natural thing is to want multiple entry points into a recursive do block.  I'm not yet sure how to get around this.)s
02:16:52 <wnoise> I mean, I suppose I can stick everything in there, but ugh.  And it'd be nice to have the bindings available outside, for testing purposes.
02:17:35 <oerjan> have you tried returning a tuple or record?
02:18:52 <wnoise> That would have type PM s (a, b), where I want (PM s a, PM s b).
02:19:30 <oerjan> you can split it up later with liftM
02:21:21 <wnoise> Hmm.  Well, I can't say definitively that it wouldn't work.  I'll try that tomorrow.
02:22:16 <wli> wnoise: I'm just writing an LBA affair.
02:22:50 <wnoise> wli: LBA?
02:23:29 <wli> wnoise: Linear Bounded Automaton
02:24:01 <wnoise> wli: Ah.
02:25:30 <arcatan> little big adventure
02:40:09 <glguy> lambdabot needs this command...
02:40:10 <glguy> 19:20 < simonrvn> !wayttd SKOM
02:40:10 <glguy> 19:20 < dpkg> What Are You Trying To Do, SKOM?
02:42:13 <glguy> ?quote SKOM
02:42:14 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
02:43:13 <oerjan> @seen SKOM
02:43:13 <lambdabot> I haven't seen SKOM.
02:44:15 <glguy> he sounded a bit familiar, I wonder who I was thinking of
02:44:18 <glguy> ?seen mwilson
02:44:19 <lambdabot> I haven't seen mwilson.
02:48:01 <wli> These parser combinators are turning into an unmitigated disaster.
02:48:17 <arcatan> turn undead
02:48:51 <d-bug> wli, you don't want to see the un-monadic parser mess I did last night
02:49:22 <wli> d-bug: heh
02:50:05 <d-bug> i know something is wrong when a certain pattern is everywhere... case expr of Nothing -> Nothing Just(xxxx) -> something
02:50:19 <xpika> if i compile a wxwidgets program under opendarwin does that mean it will run on a mac?
02:50:58 <oerjan> d-bug: that's a Maybe monad pattern
02:51:29 <Eelis> > fmap (+1) (Just 3)
02:51:30 <lambdabot>  Just 4
02:51:33 <Eelis> > fmap (+1) Nothing
02:51:34 <lambdabot>  Nothing
02:51:39 <Eelis> d-bug: perhaps you could use fmap.
02:51:51 <xerox> > fmap (+2) (*5)
02:51:52 <lambdabot>  <Integer -> Integer>
02:52:16 <d-bug> ah, I've gotten into monads yet despite reading about them. I figured there would be a nice way to have general "traversers" for the maybe type
02:52:25 <d-bug> thanks, i'll read more about this
02:53:33 <d-bug> Was 10 years ago since I was a SML fan, then working etc and now I find my mind too closed to grok obvious things in Haskell with ease
02:53:55 <Saizan> do xxxx <- expr; something xxxx
02:55:13 * glguy tries to find the context for Saizan's explaining expr >>= something
02:55:56 <Saizan> it was more a rewrite of  case expr of Nothing -> Nothing Just(xxxx) -> something
02:56:24 * Saizan notices that his intervents have become more and more random lately
02:56:27 <glguy> I made the connection after I learned to use the PgUp key
02:57:30 <Saizan> your channel buffer is too short :P
02:57:45 <glguy> agreed
02:58:09 <glguy> I've got a thing for 80x24 terminals though
02:58:21 <d-bug> Saizan, I think I grok that pattern :)
02:58:31 <Syzygy-> glguy: I tend to use 80x80 instead
02:58:41 <d-bug> Saizan, either things continue with Just's or the whole thing is Nothing
02:58:43 <Syzygy-> Neatly fills a screen vertically.
02:59:01 <glguy> Syzygy-: I tend to like huge fonts
02:59:16 <glguy> I like being able to see the details of the letterforms
03:00:00 <RyanT5000> i use several 80x20 stacked on the right and a giant master on the left, which is either emacs or a browser
03:00:08 <RyanT5000> (dwm-style, except i use gnome, lol)
03:00:36 <glguy> I try for two fullscreened PuTTYs, one on each monitor
03:00:38 <Syzygy-> Left: a stack of tabbed terminals and emacsen. Right a single firefox.
03:01:22 <RyanT5000> i wish i had the time to contribute to xmonad
03:01:48 <RyanT5000> there's a ton of stuff from both dwm and ion that i'd like to add
03:01:53 <d-bug> even Emacs looks great on OS X
03:02:09 <d-bug> <3 OS X font rendering
03:02:10 <glguy> a terminal is a terminal ;)
03:02:31 <RyanT5000> glguy: i think he hit on the one thing that could possibly differentiate them :P
03:03:03 <xerox> Syzygy-: what screen dimension and resolution?
03:03:06 <glguy> Apple tries to render fonts to that they look correct on the page at the cost of their apperance on the screen
03:03:18 <glguy> and Microsoft tries the opposite approach
03:03:21 <Syzygy-> xerox: I think 17" or 19", and with 1280x1024.
03:03:30 <RyanT5000> glguy: yeah, and linux just sucks
03:03:33 <glguy> I've got a PowerBook too... and d-bug is right that there is a difference there
03:04:03 <xerox> Syzygy-: crazy, I've got only two terms on the left and one emacs on the right, in 20", 1600x1200 or something.
03:04:21 <Syzygy-> xerox: Note that I tab all my terms together.
03:04:35 <Syzygy-> And equip my fluxbox with nice keyboard shortcuts to go through the tabstack
03:04:35 * glguy uses screen for multiple terms
03:04:55 <d-bug> just look: http://83.227.204.254/~tommy/Stuff/lovemac.png
03:05:08 <d-bug> oh, and don't read the haskell code :)
03:05:26 <xpika> lexical error in string/character literal (UTF-8 decoding error)
03:05:28 <xpika> :(
03:06:02 <xerox> Syzygy-: screenshot?
03:06:12 <d-bug> but the monitor matters too, I currently use an Eizo L768 , 1280x1024, text looks like on paper
03:06:29 <d-bug> then I brought home the monitor from work, a Samsung 204B with 1600x1200
03:06:35 <Syzygy-> xerox: No can do - I'm not at my office.
03:06:43 <d-bug> but my eyes hurt, and text looked too sharp and small
03:06:54 <d-bug> so I switched back
03:07:07 <glguy> d-bug: OS X.5 should address that, no?
03:07:28 <d-bug> hope so.
03:07:57 <d-bug> but i think i'll look into dpi numbers for my next monitor, so I don't end up with too high resolution for the area
03:14:14 <d-bug> that Maybe Monad works great, thanks
03:14:21 <wli> d-bug: Use a bigger font.
03:15:05 <wli> I think my type of parsers is wrong.
03:15:39 <wli> data Parser t nt = Parser ([Either t nt] -> [([Either t nt], [nt], [Either t nt])])
03:16:25 <wli> Maybe it should be data Parser t nt = Parser ([t] -> [([t],nt,[t])])
03:27:18 <tcr> I wish they made it `do { let foo <- mapM f xs; let bar = map g ys; }'  instead of the `do { foo <- mapM f xs; let bar = map g ys; }'... Having these two syntaxes mixed up looks kind of ugly.
03:29:35 <wli> 52G
03:33:56 <Botje_> tcr: the let kind of tells you it's a regular function application.
03:33:57 <wli> 59G
03:37:20 <ari> @bot
03:37:20 <lambdabot> :)
04:01:06 <xpika> > do {print;print} 3
04:01:07 <lambdabot>  Parse error
04:01:13 <xpika> > do {print;print} $ 3
04:01:15 <lambdabot>  <IO ()>
04:01:22 <xpika> it only prints 1 3
04:01:25 <Botje_> :t print >> print
04:01:27 <lambdabot> forall a. (Show a) => a -> IO ()
04:01:50 <Botje_> @undo do { print; print }
04:01:51 <lambdabot> print >> print
04:02:30 <Botje_> @pl \x -> print x >> print x
04:02:30 <lambdabot> liftM2 (>>) print print
04:02:46 <Botje_> xpika: you can use that instead ?
04:02:56 <ari> @src (->) (>>)
04:02:56 <lambdabot> Source not found. Are you on drugs?
04:03:04 <ari> @src ((->) e) (>>)
04:03:04 <lambdabot> Source not found. stty: unknown mode: doofus
04:03:35 <oerjan> @src (->) (>>=)
04:03:35 <lambdabot> f >>= k = \ r -> k (f r) r
04:03:47 <oerjan> (>> has a default)
04:03:49 <xpika> i would use ;mapM_ ($3) [print,print] but it looks bad
04:06:05 <Botje_> xpika: what about replicateM 2 $ print 3 ?
04:09:40 <pjd> join (>>) $ print 3
04:09:43 <pjd> heh
04:32:36 <wli> Okay, I think I've got a modest lib.
04:35:20 <wli> Massive nontermination. :(
04:38:23 <wli> Ah, >>= is wrong.
04:42:57 <Eelis> anyone else find it curious that the darcs logo seems to suggest centralization?
04:48:48 <wli> Okay, I think I've got it.
05:04:47 <dons> Eelis: interesting!
05:06:13 * d-bug wonders what speed/code size a git-compatible vcs written in Haskell would achieve
05:07:00 <dons> i don't see any major barriers to good performance. its all in the algorithms
05:07:09 <rehges> d-bug: why would you want to replace the git core?
05:07:12 <dons> and string processing is fast
05:07:23 <dons> just no one understands the git algorithms :)
05:07:44 <d-bug> rehges, to make it more portable perhaps, to see live Haskell performance on real-world problems
05:08:54 <d-bug> dons, yeah, that's a big problem since it's hard to rewrite it in a more fp way if you don't understand the c-version
05:09:06 <dons> do we need more evidence? somewhere between 2x slower than C and 30x faster than python
05:09:20 <dons> yeah. i'd start with the patch theory paper and implement that
05:09:30 <dons> rather than whatever filesystem stuff git does
05:10:08 <dons> this paper, http://www.cs.nott.ac.uk/~wss/Publications/PrincipledVersionControl.pdf
05:10:25 <dons> start with the theory, get it right, then implement a system for that model.
05:10:32 <dons> otherwise you end up with something no one understands
05:10:38 <dons> like every other RCS :)
05:12:12 <wli> I'd start with a bloody database.
05:12:40 <wli> Something is wrong.
05:12:47 <dons> wli, code trouble?
05:13:01 <wli> let { rat0 = integer <|> (do { char '(' ; r <- rat ; char ')' ; return r }) ; rat1 = fmap product (sepBy1 rat0 (char '*' <|> char '/')) ; rat = fmap sum (sepBy1 rat1 (char '+' <|> char '-')) } in runParser (do { r <- rat ; eof ; return r })  "(2+3)*5"
05:13:01 <wli> [("+3*5",2,""),("(2+3)*",5,""),("2+*5",3,""),("*5",5,"")]
05:13:02 <reffie> somethnig IS wrong.
05:13:04 <dons> i see strange garbled comments from you about small libraries, non termination?
05:13:07 <dons> worrying signs?
05:13:26 <wli> I NIH'd parser combinators, apparently wrongly.
05:13:55 <wli> http://holomorphy.com/~wli/Radical.lhs.txt
05:14:00 <dons> the xmonad extensions page has been updated, btw, all your xmonad haxors, http://xmonad.org/contrib.html
05:14:01 <lambdabot> Title: xmonad : extensions
05:14:50 <dons> wli, what's portland like this time of year?
05:15:07 <dons> i'm moving in 3 weeks -- getting quite excited :)
05:15:14 <wli> dons: Slightly too warm for me. Not too humid. A little dry. Heavy pollen.
05:15:24 <dons> too warm? sounds good.
05:15:28 <dons> ?temp
05:15:28 <lambdabot>   now 11.0∞, min 8.5∞, max 19.0∞, rain 0.0mm, wind 18km/h W
05:15:30 <dons> too cold here
05:15:43 <Stinger> wheres here?
05:15:45 <Vq^> dons: nice temp
05:15:49 <dons> sydney.
05:15:56 <Stinger> could be worse
05:16:05 <Stinger> you could live in Canberra or something
05:16:11 <dons> colder in Stinger-land?
05:16:14 <roconnor> ``consider an N-bit elegant program. It turns out that its complexity is very close to N, within a fixed number of bits. So elegant programs are right on the borderline between structure and randomness. They have just enough structure to be self-delimiting!
05:16:19 <Stinger> nah pretty mild here
05:16:22 <dons> yeah, my sister lives in canberra. always bloody cold
05:16:49 <dons> roconnor: huh, what's that from?
05:16:54 <dons> roconnor: sounds rather curious
05:17:05 <roconnor> http://www.cs.auckland.ac.nz/~chaitin/unknowable/ch6.html
05:17:06 <lambdabot> Title: Chaitin, The Unknowable
05:19:13 <dons> heya bens_
05:19:46 <wli> dons: We'll have to do coffee or some such.
05:21:09 <dons> definitely.
05:21:29 <dons> I need to find the real coffee shops around town too
05:27:04 <d-bug> ?temp
05:27:05 <lambdabot>   now 11.0∞, min 8.5∞, max 19.0∞, rain 0.0mm, wind 20km/h W
05:27:47 <d-bug> actually, it's 23 deg C here
05:27:50 <d-bug> u liar!
05:27:57 <d-bug> liarbot
05:29:08 <dons> she only knows her own temperature
05:38:59 <bens_> hey dons
05:40:31 <RyanT5001> so... i have a problem with GC again: it seems that Haskell has no idea how much space SpiderMonkey's heap is using, so it never bothers to do garbage collection
05:41:34 <RyanT5001> so if i do repeated allocations, haskell never bothers releasing its pointers to SM's objects
05:41:41 <RyanT5001> since the pointers are tiny compared to the objects
05:41:43 <bens_> dons: there's a good one in glebe :)
05:43:15 <RyanT5001> woah
05:43:17 <RyanT5001> here's a new one
05:43:26 <RyanT5001> <interactive>: internal error: interpretBCO: unknown or unimplemented opcode 40812
05:43:38 <RyanT5001> GHCi just spit that at me
05:43:57 <RyanT5001> *spat
05:52:29 <xtacy[]> hi ...
05:52:35 <RyanT5001> hi
05:52:49 <xtacy[]> I have a question in Pattern matching
05:52:56 <RyanT5001> go ahed
05:53:00 <RyanT5001> *ahead
05:53:04 <wli> Okay, first the grammar was wrong.
05:53:14 <wli> Second there's a lack of laziness somewhere.
05:53:25 <xtacy[]> I guess there are modules which can read a string and split it apart ...
05:53:43 <xtacy[]> According to some rules, or a Grammar that I describe
05:53:57 <xtacy[]> Is there some reason why I couldnt do something like:
05:54:17 <xtacy[]> break_apart ('(':xs:')') = print xs
05:54:26 <xtacy[]> to remove the parenthesis in an expression? :)
05:55:27 <Vq^> xtacy[]: you can't match on the last element like that
05:55:30 <RyanT5001> xtacy[]: yes; the (:) operator needs to have a string on the end
05:55:46 <Stinger> '(':xs:")"
05:55:56 <xtacy[]> Vq^: Fine, because where the ')' should match, strictly speaking is undefined.
05:56:01 <RyanT5001> right, but then that will only work on a string of length 3
05:56:13 <RyanT5001> and xs will be a character
05:56:38 <RyanT5001> : is right-associative, so a:b:c is equivalent to a:(b:c)
05:56:55 <xtacy[]> Oh .
05:56:57 <RyanT5001> the thing on the right of it always has to be a list (a string is a list)
05:57:37 <RyanT5001> so you can do ('(':xs) to match a parenthesis on the head of the string
05:57:44 <RyanT5001> but you can't match things at the very end of the string
05:57:46 <xtacy[]> So, the question boils down to, (x:xs) match the first character
05:57:51 <xtacy[]> RyanT5001: Thanks :)
05:57:53 <RyanT5001> xtacy[]: yes
05:58:06 <RyanT5001> xtacy[]: no problem
05:58:20 <RyanT5001> xtacy[]: if you want to do more complex stuff, you can look at Parsec, which is a parser library
05:58:28 <xtacy[]> RyanT5001: I guess thats because there is ambiguity
05:58:31 <kalven> how do I find out the range of Int?
05:58:36 <RyanT5001> xtacy[]: there are several other parser libraries for haskell, too
05:58:49 <RyanT5001> kalven: maxBound
05:58:55 <RyanT5001> > maxBound :: Int
05:58:55 <drigz> how can you put a type signature on a name bound within a do-block?
05:58:56 <Vq^> xtacy[]: parsec has a function called parens which solves that problem
05:58:59 <lambdabot>  2147483647
05:59:05 <kalven> RyanT5001: thanks
05:59:20 <drigz> eg do (a :: Int) <- read (readFile "num.txt")
05:59:20 <xtacy[]> RyanT5001: So they accept grammar in some form, and parse it ... That would be cool
05:59:35 <xtacy[]> Vq^: I will check that out right away,
05:59:35 <RyanT5001> drigz: i usually put it at the end of the line, and wrap it in the name of the monad
05:59:38 <Vq^> xtacy[]: it is cool :)
05:59:55 <xtacy[]> Vq^: I have been learning OCaml and Haskell side by side :)
05:59:57 <drigz> RyanT5001: is there no way to put it on a different line?
06:00:13 <xtacy[]> Till now there are lots of similarities! Yet to see the differences,
06:00:24 <RyanT5001> drigz: not that i know of
06:00:32 <RyanT5001> drigz: however, what you're doing is illegal anyway
06:00:32 <xtacy[]> I was particularly interested in it, as it claims it can produce *faster than C++* code!
06:00:46 <drigz> RyanT5001: ok. luckily mine signature is small, so your way works perfectly.
06:00:49 <drigz> thanks
06:01:04 <drigz> *my
06:01:07 <RyanT5001> drigz: you need to put the readFile on a separate line
06:01:16 <drigz> oops, forgot the liftM
06:01:41 <RyanT5001> do { f <- readFile "num.txt" ; let i = read f :: Int }
06:01:47 <d-bug> xtacy: mlton is also interesting, it has unboxed floats and ints
06:02:01 <RyanT5001> drigz: yeah, that works
06:02:33 <xtacy[]> Do you guys know of any good "Whats the best way to learn a language" kind of tutorial that you might have come across?
06:02:42 <xtacy[]> I have been trying lots of ways, some have worked out for me ...
06:02:53 <xtacy[]> But I would love to hear other people's thoughts on this
06:03:05 <d-bug> read some, program some, read some, program some etc
06:03:27 <RyanT5001> xtacy[]: exactly what d-bug said; also, hanging out in this channel isn't a bad thing to od
06:03:30 <RyanT5001> *do
06:03:32 <d-bug> boring answer, i know
06:03:44 <xtacy[]> d-bug: Thats what I have been doing!
06:03:58 <Vq^> playing around with lambdabot is quite educational...
06:04:09 <xtacy[]> RyanT5001: Yeah, we do learn a lot from other's questions ... Discussions do bring out interesting ideas
06:04:28 <RyanT5001> xtacy[]: you could try reading random other people's code, e.g. stuff in hackage
06:04:57 <xtacy[]> Ah, interesting
06:05:10 <RyanT5001> that'll help you pick up on idioms and such
06:06:21 <Vq^> there are some quite good tutorials out there as well, the wikibook for example
06:06:35 <xtacy[]> Vq^: Been following Wikibooks only.
06:06:48 <xtacy[]> The collection of resources on Haskell, in HaskellWiki is amazing
06:06:59 <RyanT5001> xtacy[]: i read YAHT (yet another haskell tutorial) and the "2 dozen questions" tutorial
06:07:04 <RyanT5001> i found both to be quite good
06:07:28 <RyanT5001> other than that, just try to use the hardest features you can all the time
06:07:49 <xtacy[]> RyanT5001: Nice...
06:08:01 <xtacy[]> RyanT5001: Another method I have found useful, is to contrast languages
06:08:26 <xtacy[]> I am now learning OCaml and haskell at the same time. It might turn out to be a bad idea, but still ...
06:08:33 <RyanT5001> no, that seems like a good idea
06:09:04 <RyanT5001> OCaml and Haskell are fairly similar, but not too much to learn a lot by contrasting them
06:09:04 <xtacy[]> RyanT5001: speaking of which, I tried including some dialects of Lisp into it too :-)
06:09:08 <RyanT5001> ew
06:09:09 <RyanT5001> lol
06:09:11 <RyanT5001> i could never stand lisp
06:09:21 <xtacy[]> Lots of stupid Parens :D
06:09:24 <d-bug> lisp is very nice IMHO
06:09:26 <RyanT5001> lol yeah
06:09:40 <RyanT5001> i used to hate lisp because of parens
06:09:45 <RyanT5001> now i hate it because of side-effects
06:09:53 <RyanT5001> (which means i hate basically every language)
06:09:57 <RyanT5001> (except haskell)
06:10:29 <Vq^> xtacy[]: maybe you should try 'Write Yourself a Scheme in 48 Hours' then ;D
06:10:37 <Vq^> xtacy[]: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:10:38 <xtacy[]> Vq^: I have seen that one!
06:10:59 <xtacy[]> I have kept a list of things to do, my progress etc, in a nice org-file...
06:11:49 <Vq^> it has a nice parsec chapter quite early
06:12:03 <xtacy[]> http://www.cs.iitm.ernet.in/~jvimal/haskell.html
06:12:06 <lambdabot> Title: haskell
06:12:32 <xtacy[]> Hmm, did the bot go through my page to get that title?
06:12:42 <xtacy[]> Didnt expect that
06:14:05 <RyanT5001> xtacy[]: lambdabot does a lot of nifty stuff :)
06:14:35 <d-bug> like lying about the temperature here :)
06:14:53 <xtacy[]> strip_paren = ('(':xs:")") = print xs, and calling with "(a+b+c*d)" doesnt work.
06:15:02 <xtacy[]> Ah, I guess it will work only with 3 chars...
06:16:38 <RyanT5001> xtacy[]: yeah
06:17:52 <xtacy[]> alright guys, cya later... will keep visiting often :-)
06:18:03 * xtacy[] goes away, to have dinner
06:32:52 <mathias> How to combine StateT, IO and ST in one do block? Something like runStateT (do putStr ""; put ""; newSTRef "";return ()) ()) should work then. The issue is that doing it with either IO or ST seems to work, but not with both.
06:33:22 <xerox> mathias: why both ST and IO?
06:35:38 <xerox> mathias: i.e. IO provides IORefs, so you just need data M a = M { runM :: StateT MState IO a } deriving ( Functor, Monad, MonadState MState, MonadIO ) run :: MState -> M a -> IO (a,MState) run s = flip runStateT s . runM
06:35:51 <mathias> xerox: Because it already is ST in the code I have and I want to add IO.
06:36:04 <kpreid> hmm
06:36:21 <xerox> mathias: I'm not sure how you stack IO and ST together.
06:36:26 <kpreid> sounds like you want ioToST :: IO a -> ST RealWorld a -- except that doesn't exist
06:36:45 <mathias> xerox, is that impossible?
06:37:36 <kpreid> mathias: define a type class whose instances are ST and IO, with a method for turning an ST action into it, for ST it's id and for IO it's stToIO
06:37:41 <xerox> mathias: you might want to change the code from using STRefs to IOREfs.
06:37:55 <RyanT5001> is there an ST transformer?
06:38:05 <RyanT5001> writing an ST transformer is probably "the right way" to do this
06:38:18 <int-e> @index unsafeIOToST
06:38:18 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
06:38:27 <RyanT5001> then you can just have StateT s ST a IO b
06:38:41 <RyanT5001> well, with some parenthesization
06:39:09 <RyanT5001> it would be good to have an ST transformer, i think :)
06:39:13 <kpreid> mathias: do you have some code you want to convert from ST to IO, or is it for ST but you want to parameterize it with actions that might be IO?
06:39:40 <mathias> kpreid: the latter
06:39:44 <Lemmih> RyanT5001: There's no STT same reason there's no IOT, I believe.
06:39:52 <kpreid> mathias: okay, use the typeclass I described
06:41:04 <int-e> @type \(GHC.IOBase.IO x) -> GHC.ST.ST x -- yuck
06:41:07 <lambdabot> forall t. IO t -> GHC.ST.ST GHC.Prim.RealWorld t
06:41:08 <RyanT5001> Lemmih: hm...
06:41:08 <kpreid> class Vars m a where liftVars :: ST a -> m a; instance Vars ST where liftVars = id; instance Vars IO where liftVars = stToIO
06:41:13 <kpreid> mathias:
06:42:15 <kpreid> then myAction a v = do x <- liftVars $ readSTRef v; x' <- a v; liftVars $ writeSTRef x
06:43:02 <kpreid> oops, I forgot the state type variable
06:44:03 <kpreid> myAction has a type something like  (Vars s m, Monad m) => m a -> STRef s a -> m ()
06:45:04 <kpreid> revised typeclass: class Vars s m where liftVars :: ST s a -> m a; instance Vars a ST where liftVars = id; instance Vars RealWorld IO where liftVars = stToIO
06:46:43 <wli> These things shouldn't care whether the things are recursive or not... YTF are they bombing out.
06:46:49 <mathias> kpreid: how does that relate to the example code I introduced above?
06:47:31 <mathias> kpreid, I don't see that I can now use putStr and newSTRef.
06:48:12 <kpreid> (lift . liftVars . newSTRef)
06:48:18 <kpreid> (liftIO putStr)
06:48:24 <kpreid> er
06:48:25 <kpreid> (liftIO . putStr)
06:50:32 <mathias> kpreid, Then I get something:: (Num s, MonadIO m, Vars s1 m) => m ((), s)
06:50:37 <Saizan> RyanT5001: you can't write STT because when you runST you lose the implicit state, with no way to restore it later
06:50:51 <mathias> kpreid: on which I cannot use runST
06:51:01 <kpreid> mathias: right, you don't use runST
06:51:18 <mathias> kpreid: how do I run it?
06:51:22 <kpreid> it's an IO action
06:51:27 <kpreid> in the usual way you run IO
06:51:28 <RyanT5001> Saizan: and you couldn't do something clever involving fix?
06:52:16 <RyanT5001> i.e.: interleaving ST and IO actions
06:52:26 <mathias> kpreid: I run an IO action by evaluating it at the promt. When I do that I get:  No instance for (Show (m ((), s)))
06:52:30 <RyanT5001> i guess that would probably kill your performance anyway
06:53:01 <kpreid> mathias: add a type signature, myAction ... :: IO ((), Integer)
06:53:16 <Philippa> Saizan: you could write something "a bit like STT", but it'd need a different executional model to allow backtracking
06:53:26 <kpreid> mathias: that happens because it has a polymorphic type (m ...) and the repl doesn't know that the instantiation you want is IO
06:53:40 <Philippa> RyanT5001: think about it - you'd need to keep a heap history
06:53:50 <Philippa> that requires a much more involved implementation than ST itself has
06:53:55 <mathias> kpreid: No instance for (Vars s IO)
06:54:11 <RyanT5001> yeah; i don't pretend to understand how ST works
06:54:21 <kpreid> mathias: did you include my second instance declaration?
06:54:36 <mathias> kpreid: the one with RealWorld?
06:54:40 <kpreid> ys
06:54:40 <mathias> kpreid: yes
06:54:44 <kpreid> hmmm
06:55:26 <kpreid> seems like there ought to be a fundep but that would break the ST case
06:55:47 <kpreid> hey, any typeclass hackers want to tell us how to resolve s to RealWorld?
06:55:54 <wli> I guess I'm discovering what the pain with recursion is wrt. parser combinators.
06:56:27 <blackdog> what's that debugging function that prints something and returns its second argument?
06:56:32 <kpreid> mathias: ok, different strategy with fewer funky bits...
06:56:45 <mathias> kpreid:  class Vars s m | m -> s where liftVars :: ST s a -> m a
06:56:54 <mathias> kpreid: it works
06:56:56 <kpreid> huh
06:57:21 <kpreid> I would think that would be wrong for Vars s ST since s has multiple possible values
06:57:31 <kpreid> (each phantom type)
06:57:37 <mathias> kpreid: what was your other strategy?
06:58:10 <kpreid> class Vars v m where newVar :: a -> m (v a); readVar :: v a -> m a; ...
06:58:16 <kpreid> then instantiate that for ST s and IO
06:58:59 <kpreid> or rather, for (STRef s) (ST s) and IORef IO
06:59:15 <ski> MonadRef
06:59:22 <kpreid> yeah
06:59:29 <RyanT5001> we need a modular monad system
06:59:47 <wli> What is a modular monad system?
06:59:50 <RyanT5001> where you can build complicated monads easily
07:00:08 <kpreid> distinguish this from monad transformers
07:00:18 <RyanT5001> sorry, i've been up for a long time and am a little inarticulate
07:00:47 <mrd> kpreid: "easily"
07:01:01 <kpreid> heh
07:01:02 <RyanT5001> kpreid: not O(n) code to lift into a particular monad
07:01:12 <kpreid> RyanT5001: ding. okay.
07:01:23 <RyanT5001> i mean, stacking 3, 4, 5, monads is semi-acceptable
07:01:30 <RyanT5001> i use ErrorT pretty heavily
07:01:33 <kpreid> I suspect that's actually impossible...
07:01:42 <kpreid> in the general case, for arbitrary modules, I mean
07:01:53 <kpreid> but it would be nice to be wrong
07:01:58 <RyanT5001> kpreid: yeah, but that's just because haskell's type system isn't powerful enough
07:02:11 <wli> ErrorT rocks.
07:02:36 <kpreid> Do I misremember, or did the original monad transformers ("modular interpreters") paper have something clever for lifting?
07:02:53 <RyanT5001> i didn't read it
07:03:00 <RyanT5001> i mean, you could maybe define your own stuff
07:03:07 <kpreid> something like the MonadIO etc. mechanism but without the n^2 typeclasses
07:03:09 <RyanT5001> i.e.: make a MyMonad type
07:03:31 <RyanT5001> then just rename lift_n for each monad
07:03:34 <mrd> yea it did
07:03:45 <wli> Yeah, the O(n^2) instance requirement plus the module system limitations really make it Hell.
07:03:57 <RyanT5001> yeah, instances are terrible
07:04:02 <RyanT5001> they're the worst kind of global variable
07:04:08 <RyanT5001> they're literally virulent
07:04:20 <RyanT5001> they need to be scoped
07:04:36 <RyanT5001> i don't know how to do it; maybe implicit parameters?
07:05:22 <RyanT5001> the idea that a single type would have a single instance of a class is fundamentally flawed, imo
07:06:17 <kpreid> RyanT5001: Monoid is an interesting test case: can whatever-your-solution-is handle the two monoids of Num?
07:06:17 <RyanT5001> why would *everyone* want to use dons's serialization routines just because they like Data.Binary.Binary as a class
07:06:36 <RyanT5001> kpreid: i have a solution?
07:06:37 <RyanT5001> lol
07:06:46 <kpreid> I mean, use it when evaluating a solution
07:06:53 <RyanT5001> ah ok
07:07:03 <mrd> well, you could get rid of type-classes and stick to functors =)
07:07:20 <RyanT5001> well, i do plan on writing a language at some point
07:07:26 <wli> Okay, that's interesting.
07:07:26 <RyanT5001> i don't believe in ad-hoc polymorphism
07:07:33 <RyanT5001> so i won't have typeclasses
07:07:45 <RyanT5001> however, i'm determined to have something very similar
07:07:54 <RyanT5001> because they are very useful when you don't have conflicts
07:08:35 <RyanT5001> (of course i know you can newtype everything if you want; i don't consider that a solution)
07:08:37 <wli> runParser rat "2+3" and runParser (do { r <- rat ; return r }) behave differently. I suspect this means brokenness.
07:08:57 <mrd> which parser
07:09:20 <wli> mrd: http://holomorphy.com/~wli/Radical.lhs.txt
07:09:24 <shachaf> wli: It does. Which parseer are you talking about?
07:09:27 <RyanT5001> yes, i'm pretty sure (>>= return) is supposed to be id
07:09:47 <mrd> perhaps your monad instance is screwy
07:10:12 <wli> mrd: Yes, the trick is to figure out how.
07:10:18 <mrd> yea i dont see it
07:11:27 <RyanT5001> wli: is there a reason you wrote a monad library rather than hand-coding the parser?
07:11:34 <RyanT5001> wli: i'm fairly certain it would've been easier
07:11:42 <ski> wli : i like 'ErrorT' except for the requirement on the 'Error' class
07:11:43 <wli> RyanT5001: Hand-coding is BS.
07:11:55 <RyanT5001> wli: well, i generally agree with that sentiment, but...
07:12:05 <Philippa> RyanT5001: the moment you start factoring out your hand-coding you're at least 50% of the way to the monad lib anyway
07:12:24 <RyanT5001> Philippa: maybe; his grammar isn't very complicated
07:12:46 <RyanT5001> it depends, in this case, i think, mostly on how subject to change the grammar is
07:13:10 <yaxu> hi all
07:13:11 <yaxu> i've got phd funding :)
07:13:20 <RyanT5001> that's cool; what're you doing?
07:13:26 <Philippa> yaxu: 'grats!
07:13:47 <wli> RyanT5001: It's subject to change to a non-context-free language.
07:14:10 <Syzygy-> Yo yaxu
07:14:14 <Philippa> wli: did you have a good reason to not use parsec?
07:14:16 <Syzygy-> GREAT!
07:14:29 <ivant> yaxu, cool!
07:14:31 <twanvl> You can still parse non-context free languages with Parsec
07:14:32 <yaxu> RyanT5001: hang on let me remember the title
07:14:36 <wli> Philippa: Left recursion annoyed the living #@$* out of me.
07:14:46 <Syzygy-> yaxu: Where? How long? Who'll be advising? What you gonna write about?
07:14:47 <Philippa> ah, how're you tackling it?
07:14:49 <RyanT5001> wli: well, then i guess you need a really good parser library :)
07:15:02 <wli> Philippa: Writing parser combinators from scratch.
07:15:08 <Philippa> it's never really got to me that much, I'm using to chain*...
07:15:10 <yaxu> "Live Coding Music: A dynamic domain specific language for music improvisation, with models of use towards computational creativity"
07:15:14 <Philippa> yeah, but what's different about 'em?
07:15:23 <Philippa> what lets them not get stuck in a loop?
07:15:55 <wli> Philippa: They're modelled on nondeterministic linear-bounded automata. Apparently they're getting stuck in loops anyway.
07:16:32 <ski> wli : 'split' ?
07:16:42 <yaxu> Syzygy-: goldsmiths college, london, 3 years, geraint wiggins, music, word morphology, physical model synthesis, sound representation, computational creativity etc
07:16:51 <yaxu> i shall be mostly using haskell :)
07:16:55 <sorear> @users
07:16:55 <lambdabot> Maximum users seen in #haskell: 382, currently: 326 (85.3%), active: 18 (5.5%)
07:17:07 <Philippa> wli: yeah, you can't really build parser combinators that don't without building an explicit rep of the grammar that marks out the loops appropriately
07:17:13 <Syzygy-> yaxu: COOOOOOL!
07:17:23 <Syzygy-> yaxu: PLEASE keep me up to date when you start getting things done!
07:17:30 <ivant> yaxu, do you have a blog?
07:17:48 <yaxu> my blog is at http://doc.gold.ac.uk/~ma503am/
07:17:50 <wli> ski: The things have to be able to do reductions from basically anywhere in the input. The only essential requirement is that they reduce the input length at each step.
07:17:51 <kpreid> @tell ndm I did a little more work in my Yhc.Core-based project -- I don't suppose there's a way to get function argument types? Also, is the pattern in a CoreCase *always* a CoreApp (CoreCon _) _? And is that documented anywhere?
07:17:52 <lambdabot> Consider it noted.
07:17:52 <lambdabot> Title: Alex McLean
07:18:17 <yaxu> oh, did i just make a factoid?
07:18:30 <kpreid> no
07:18:33 <ski> wli : why such strange special cases ?
07:18:36 <yaxu> Syzygy-: ok :)  i have to finish my msc thesis soon which is very much in the same area...  will let you know when it's done
07:18:38 <wli> Philippa: Looks like I better make that, then.
07:18:43 <wli> ski: What do you mean.
07:18:48 <ski> wli : e.g. 'split [x]' vs. 'split [x,y]'
07:18:56 <Philippa> wli: look at frisby, it might do it
07:18:59 <ski> s/split/splits/
07:19:34 <ski> why not three alternative splits of '[x,y]', instead of just one ?
07:19:36 <wli> ski: Brute-force while barely awake to get the things to avoid generating empty prefixes and suffixes.
07:19:45 <sorear> kpreid: No, No, and Yes.
07:19:58 <ski> splits [x] = [([],[x]),([x],[])]
07:20:03 <sorear> kpreid: Core is almost completely type erased
07:20:07 <ski> is generating empty prefix alt. suffix
07:20:17 <wli> ski: [] and [x] are there basically just to keep pattern matching from puking and are never intended to be used.
07:20:35 <sorear> kpreid: A pattern can also be a literal or a single identifier
07:20:37 * ski is not sure what that means ..
07:20:38 <wli> ski: [x,y] is the true base case.
07:20:47 <kpreid> ah, doh
07:20:48 * desp just read the SPJ paper on memoization using weak pointers and stable names
07:20:58 <desp> has anything better came up since '99?
07:21:06 <desp> with regard to memoization
07:21:11 <wli> ski: [] and [x] are basically error cases but I do something there to avoid errors getting thrown.
07:21:19 <ski> strange
07:21:31 * desp pokes sorear
07:21:40 <sorear> hi desp!
07:21:42 <wli> ski: splits' in like fashion needs at least 3.
07:21:46 <desp> sorear: hello
07:22:30 <desp> sorear: are you familiar with the SPJ paper on memoization?
07:22:30 <hpaste>  drigz pasted "is there a nicer way to do this?" at http://hpaste.org/2076
07:22:48 <sorear> kpreid: http://haskell.org/pipermail/yhc/2007-August/001039.html <- most recent reference on Yhc.Core case syntax
07:22:49 <lambdabot> Title: [Yhc] Yhc.Core Proposal: Split out CoreLit's from CoreExpr, Add CoreAlt
07:22:51 <drigz> ^ that code seems really ugly / convoluted to me
07:22:54 <sorear> desp: yes a bit
07:23:00 <desp> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
07:23:01 <lambdabot> Title: Simon Peyton Jones: papers
07:23:18 <desp> sorear: I was just wondering if that'd be the best way, or if anything else came up since '99
07:23:30 <xtacy[]> yaxu: do you have a link of the software that generates Music? (the first video, Canntaireachd ...)
07:23:33 <sorear> desp: nope, still the best way afaik
07:23:38 <desp> aight, thanks
07:23:41 <desp> @where memoization
07:23:41 <lambdabot> I know nothing about memoization.
07:23:47 <kpreid> sorear: I see
07:23:47 <desp> @where+ memoization http://research.microsoft.com/Users/simonpj/Papers/weak.htm
07:23:47 <lambdabot> Done.
07:23:59 <sorear> drigz: doesn't look much worse than my best attempt :(
07:24:20 <kpreid> hmm
07:24:44 <wli> Philippa: I'm having a tough time figuring out how to make the grammar constructors look like monads.
07:24:46 <kpreid> how about [edge (x,y) (x-1,y) | x > 0] ++ [... | x < w-1] ...
07:25:15 <yaxu> xtacy[]: i don't have time to package it, i could give you the source as is though if you like
07:25:16 * sorear finally figures out how to type check pattern bindings
07:25:35 <xtacy[]> yaxu: sure, I want to try it out :)
07:26:10 <kpreid> sorear: the reason I asked was my experiment is compiling a Haskell module to a dynamic target language; I'd like to enforce the Haskell types at the boundaries of the module
07:26:29 <kpreid> hm, maybe I could correlate with the module pre-compilation
07:26:43 <wli> sorear: Do tell. I've some difficulty with that myself.
07:27:51 <yaxu> xtacy[]: http://yaxu.org/tmp/canntaireachd.tar.gz
07:28:36 <xtacy[]> yaxu: thanks!
07:29:01 <sorear> wli: Treat the value equation as a type eqation during unification.  (x,y) = (1,2)    1. create fresh tyvars a, b for x, y  2. instantiate 1 (Num c => c), 2 (Num d => d)  3. unify the lhs and rhs types (,) a b = (,) c d => [ c |-> a , d |-> b ]  4. you're done, you may generalize
07:29:21 <sorear> Perfectly obvious now in hindsight...
07:29:33 <yaxu> xtacy[]: you'll need supercollider and hsc installed: http://slavepianos.org/rd/r/darcsweb.cgi?r=hsc3;a=headblob;f=/Help/Tutorial/Tutorial.lhs
07:29:36 <lambdabot> Title: darcs - hsc3, http://tinyurl.com/2lldnm
07:30:03 <yaxu> xtacy[]: which i think means either linux or mac os, those instructions are i think linux specific
07:30:06 <xtacy[]> Okay ... yaxu, whats with the '>' at the beginning of every line in the code?
07:30:10 <hpaste>  kpreid annotated "is there a nicer way to do this?" with "with list comprehension and @" at http://hpaste.org/2076#a1
07:30:15 <Philippa> xtacy[]: literate haskell
07:30:16 <sorear> xtacy[]: Bird tracks
07:30:43 <yaxu> xtacy[]: yep, .lhs files just put > in front of all the code lines
07:30:50 <xtacy[]> Oh.
07:31:03 <shachaf> wli: Your (>>=) says "(pfx', nt, []) <- p pfx", and when that doesn't match, it returns [].
07:31:13 <yaxu> xtacy[]: and the compiler / interpreter ignores everything else
07:31:20 <hpaste>  ski annotated "is there a nicer way to do this?" with "another version" at http://hpaste.org/2076#a2
07:31:26 <sorear> http://haskell.org/onlinereport/syntax-iso.html#sect9.4
07:31:27 <lambdabot> Title: Haskell 98 Syntax
07:31:34 <yaxu> xtacy[]: in other words, comments become the default, it's handy when you're writing more documentation than code :)
07:31:43 <xtacy[]> yaxu: :)
07:32:29 <xtacy[]> Nice ...
07:36:25 <hpaste>  kpreid annotated "is there a nicer way to do this?" with "with map and filter" at http://hpaste.org/2076#a3
07:36:33 <wli> shachaf: hmm?
07:38:38 <shachaf> wli: In your parser's (>>=). It seems to assume (at least) that at least one of (p pfx) will return a tuple whose third element is [].
07:38:54 <wli> shachaf: require
07:44:05 <shachaf> wli: Hmm, the problem seems to be with the second pattern match? "runParser (f nt) sfx)" returns a list of tuples, and they don't always have an empty list as their first element.
07:44:56 <wli> shachaf: The notion is that the reductions should be carried out adjacently.
07:45:36 <wli> shachaf: Those conditions establish adjacency (albeit after generating more possibilities than strictly necessary).
07:46:51 <wli> shachaf: Without adjacency there is no way to represent the result, for one.
07:47:26 <RyanT5001> could anyone suggest a paper to read about dependent typing?
07:47:52 <RyanT5001> something relatively introductory would be best, but i'll make my way through anything
07:48:09 <shachaf> wli: Well, in the case of return, (runParser (return 'a') "1234") returns [("1",'a',"234"),("12",'a',"34"),("123",'a',"4")].
07:48:37 <wli> shachaf: I have no idea what return should really do.
07:49:18 <edwinb> RyanT5001: how about the epigram tutorial?
07:49:19 <wli> shachaf: There's no good choice of where to split the input.
07:49:24 <shachaf> wli: It should be a parser that matches and consumes no input.
07:49:32 <pjd> RyanT5001: "Why Dependent Types Matter"?
07:49:35 <RyanT5001> edwinb: i've read/worked through that; i'm looking for something more in depth
07:49:48 <edwinb> ah, in that case Why Dependent Types Matter might be a good one
07:50:30 <wli> shachaf: The parsers I tried (and failed) to build here are probably just not monads.
07:50:50 <RyanT5001> pjd sounds like my kind of thing :)
07:50:50 <Botje_> kpreid: you could use inRange
07:51:39 <Botje_> [ edge (x,y) | (x,y) <- [...], x `inRange` (0,w-1) && y `inRange` (0,h-1) ]
07:51:41 <RyanT5001> i'll see if they talk about any of the reasons *i* think dependent types matter :P
07:52:00 <wli> shachaf: I started off with data Parser t nt = Parser ([Either t nt] -> [Either t nt])
07:52:12 <edwinb> RyanT5001: why do you think dependent types matter?
07:52:12 <kpreid> Botje_: that would include diagonals and identity, not just the four
07:52:22 <Botje_> ehh
07:52:25 <Botje_> no?
07:52:25 <edwinb> (if that's not too big a question...)
07:52:33 <kpreid> er...oh
07:52:33 <Botje_> put the four in place of that [...]
07:52:38 <kpreid> sorry, misread
07:52:56 <Botje_> and possibly re-label the arguments to x' and y'
07:52:59 <kpreid> also, my map/filter version used the wrong variables in the filter lambda
07:53:13 <Botje_> hmm
07:53:15 <Botje_> hang on
07:53:18 <Botje_> you can do one better
07:53:26 <wli> shachaf: Then I tried data Parser t nt = Parser ([Either t nt] -> ([Either t nt], nt, [Either t nt]))
07:53:51 <Botje_> ((0,0),(w-1,h-1)) `inRange` (x,y)
07:54:06 <kpreid> ha! yes!
07:54:20 <Botje_> for added effect, flip inRange
07:54:42 <kpreid> filter (((0,0),(w-1,h-1)) `inRange`)
07:54:48 <wli> shachaf: There isn't a notion of an "input to consume" so much as a string from which it plucks out a substring on which it carries out a reduction.
07:55:01 <Botje_> no need for the ``
07:55:02 <RyanT5001> edwinb: i think they can make programs much more expressive, to the point of displacing many other language features
07:55:10 <ski> wli : you seem to be nondeterministically splitting the input terminals in '(>>=)' .. but why can your parsers then return two lists of terminals ?
07:55:13 <Botje_> filter (inrange ((0,0),(w-1,h-1)))
07:55:26 * ski hms
07:55:53 <RyanT5001> edwinb: if you combine them with staged computation and partial evaluation, i'm pretty convinced you can describe almost everything from haskell better than haskell does
07:56:25 <edwinb> it does seem to me that many crazy type system extensions can be handled just as nicely with dependent types
07:56:32 <hpaste>  kpreid annotated "is there a nicer way to do this?" with "improved filter, thanks to Botje_" at http://hpaste.org/2076#a4
07:56:35 <Botje_> kpreid: and you can generate those four like this: [ (x',y') | d <- [-1,1], (x',y') <- [(x+d,y),(x,y+d)]]
07:56:37 <wli> ski: It nondeterministically picks a substring to reduce. The first of the triple is the unaffected prefix. The third of the triple is the unaffected suffix. The middle of the triple is the result of the reduction.
07:57:04 <RyanT5001> edwinb: yeah; i've been thinking about how to design a language for a couple years now
07:57:18 <ski> wli : so every subparsers then is meant to get the total whole of the input tokens ?
07:57:26 <RyanT5001> edwinb: i eventually arrived at a conclusion that functions whose return type depends on their input value were necessary
07:57:31 <edwinb> RyanT5001: we had a paper on staging with dependent types in GPCE last year (shameless self promotion: http://www.dcs.st-and.ac.uk/~eb/writings/verified_staged.pdf :))
07:57:31 <RyanT5001> then i learned about epigram, etc.
07:57:43 <kpreid> Botje_: clever, I'm not sure that's an improvement, unless we were working in more than 2 dimensions
07:57:44 <RyanT5001> edwinb: cool
07:57:45 <wli> ski: Yes, including the results of the prior reductions, actually.
07:58:05 <RyanT5001> edwinb: basically, i want to do a Ph.D. writing a language with those 3 features
07:58:10 <ski> wli : but those could be of other types, no ?
07:58:33 <hpaste>  Botje annotated "is there a nicer way to do this?" with "(no title)" at http://hpaste.org/2076#a5
07:58:41 <wli> ski: Maybe it should actually be Parser t nt = Parser ([Either t nt) -> Maybe nt)
07:58:55 <edwinb> RyanT5001: have you seen what Tim Sheard's gang are up to with Omega?
07:58:56 <Botje_> yours is clearer, though
07:59:04 <RyanT5001> edwinb: i haven't looked at that nearly enough
07:59:13 <ski> wli : that sounds even more strange .. how's that going to be a 'Functor' ?
07:59:20 <kpreid> Botje_: that has its own benefits though; just one comprehension
07:59:35 <wli> ski: I don't know. I don't think it can be (nor a monad, either).
07:59:49 <RyanT5001> @where omega
07:59:49 <lambdabot> I know nothing about omega.
08:00:18 <RyanT5001> @where+ Omega http://www.pervasive.jku.at/About_Us/Staff/Blaschek/Omega/_Report/Introduction.html
08:00:18 <lambdabot> Done.
08:00:28 <Botje_> kpreid: it desugars to the same, so doesn't quite matter
08:00:44 * ski thinks one could do a parsing monad(?) based on nondeterministically splitting input, and passing down local tokens to comsume (no tokens returned)
08:00:51 <kpreid> Botje_: I meant for readability.
08:00:54 <RyanT5001> edwinb: ew, it's object oriented? what's the point of that?
08:01:01 <wli> ski: Maybe the only way to represent it is as Map [Either t nt] nt
08:01:27 <edwinb> RyanT5001: that looks like a different Omega...
08:01:29 <wli> ski: I'm all ears.
08:01:30 <ski> wli : that seems to fix you to a specific 'nt' type, no ?
08:01:45 * edwinb googles
08:01:56 * Syzygy- tries to get Coq to prove simple group theory arguments.
08:01:57 <wli> ski: I don't know what you mean.
08:02:08 <Syzygy-> And I don't seem to wrestle it in the right direction.
08:02:23 <Botje_> kpreid: well, it was fun
08:02:34 <Botje_> but i have to write some more drivel into my paper now
08:02:39 <sorear> Syzygy-: Have you seen Georges Gonthier's paper on group theory in Coq?
08:02:42 <Botje_> (7 pages to go; 2 weeks to go)
08:02:44 <Syzygy-> sorear: Nope.
08:02:46 <Syzygy-> Link?
08:02:49 <ski> wli : for 'Parser nt', if 'Parser' would be a monad, then we must be able to vary the 'nt' type arbitrarily (look at type of '(>>=)')
08:03:02 <ski> @type (>>=)
08:03:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:03:06 <RyanT5001> will this work?
08:03:09 <RyanT5001> @where- Omega
08:03:09 <lambdabot> Maybe you meant: where where+
08:03:13 <RyanT5001> :(
08:03:13 <edwinb> RyanT5001: I can't connect to pdx.edu at the minute, it seems, but googling for "Tim Sheard Omega" gets what you want
08:03:29 <RyanT5001> edwinb: ah, thanks
08:03:49 <ski> sorear : was it Gonthier who formalized the four-color problem ?
08:03:54 <sorear> http://www.cs.unibo.it/~tassi/coqfinitegroups.pdf
08:03:55 <RyanT5001> edwinb: yeah, it appears to be down
08:03:56 <sorear> ski: yeah
08:04:18 <ski> @type (++)
08:04:20 <wli> ski: I don't see the problem.
08:04:20 <lambdabot> forall a. [a] -> [a] -> [a]
08:04:58 <RyanT5001> edwinb: the other thing i'm interested in is programming language HCI - i.e. IDEs that actually do stuff, instead of just being crappy hacks of parsers sitting on top of Notepad
08:04:59 * Syzygy- was trying for something simple like - a left unit with left inverses is a right unit...
08:05:35 <ski> wli : oh .. we must be able to use both 'm a' and 'm b' .. here 'Parser nt0' and 'Parser nt1' .. so if you're thinking of a list of partial reductions from the input terminal list, then you'll generally have many different 'nt' types, there (no single one)
08:05:55 <edwinb> RyanT5001: I think it would be really interesting to look at that in the context of dependently typed programming
08:06:03 <RyanT5001> edwinb: yep :)
08:06:10 <RyanT5001> edwinb: i've been planning this for a really long time, lol
08:06:17 <edwinb> plenty of PhDs available there ;)
08:06:22 <wli> ski: Generally you've got to take a coproduct over all the possibilities.
08:06:23 <RyanT5001> edwinb: yeah, that's the idea
08:06:34 <RyanT5001> edwinb: but first i have to get done with *law* school
08:06:38 <RyanT5001> edwinb: lol what was i thinking
08:06:51 <RyanT5001> edwinb: to be fair, law is pretty interesting too
08:07:07 <Botje_> :t inRange . (,)
08:07:09 <lambdabot>     Couldn't match expected type `(a, a)'
08:07:09 <lambdabot>            against inferred type `b -> (a1, b)'
08:07:10 <edwinb> interesting combination ;)
08:07:11 <ski> wli : which you can only do if you know all of them, no ?
08:07:24 <Botje_> @pl \a b -> inRange (a,b)
08:07:24 <lambdabot> (inRange .) . (,)
08:07:36 <wli> ski: Why wouldn't you know all of them?
08:07:48 <RyanT5001> edwinb: mostly, i was pissed off at DMCA and other similar things, and i wanted to understand the situation; plus, being more educated about the way the US political and economic systems work is always good
08:08:03 <Botje_> :t (0,0) `(inRange .) . (,)` (10,10)
08:08:03 <RyanT5001> edwinb: then, i got into harvard, so i didn't really feel like i had a choice, lol
08:08:05 <lambdabot> parse error on input `('
08:08:28 <ski> wli : if this is a parser *combinator*library*, then one can't know that beforehand .. mayhaps this can be solved anyway, i don't see how
08:08:42 <kpreid> Botje_: you can't use expressions in ``
08:08:46 <Botje_> myeah
08:09:05 <wli> RyanT5001: If you want to understand the US' political and economic system you only need to study medieval Europe and ancient Rome.
08:09:32 <RyanT5001> wli: yeah, there are some scary parallels, although i don't understand them much at all
08:09:54 <wli> ski: fmap can just map the keys and the elements. No big deal.
08:10:25 <RyanT5001> wli: i just understand the general problem of everyone getting lazy because they basically have everything they want
08:10:35 <RyanT5001> wli: which we definitely have a problem with
08:10:41 <ski> wli : anyway, my idea for nondeterministic splitting is to start with inverse of '(++)' .. giving nondeterministic results 'split :: [a] -> NonDet ([a],[a])' (where 'type Nondet a = [a]').. so here 'newtype Parser t nt = MkP {runP :: [t] -> NonDet nt}'
08:11:13 <RyanT5001> wli: i mean, i could work at a convenience store and have enough money to live in a nice neighborhood in cambridge, ma, and buy a new computer every 2 years or so
08:11:30 <wli> RyanT5001: Oh dear. I'm not going to even try to fix this.
08:11:44 <wli> ski: I have no idea how that works or if it does.
08:11:59 <RyanT5001> wli: ?
08:12:44 <pjd> RyanT5001: obligatory mention;  have you looked at Jonathan Edwards's work? (Subtext, etc.)
08:12:47 <wli> ski: Typically reductions are carried out on mixtures of terminals and nonterminals.
08:13:06 * ski nods
08:13:26 <RyanT5001> pjd: nope, at least not that i remember
08:13:48 <ski> wli : womething like 'return nt = MkP $ \ts -> do guard (null ts); return nt','ma >>= amb = MkP $ \ts -> do (ts0,ts1) <- split ts; a <- ma `runP` ts0; amb a `runP` ts1'
08:13:52 <pjd> might be of interest: http://subtextual.org/
08:13:53 <lambdabot> Title: Subtext home
08:13:55 <wli> ski: Somewhere something has to figure out how to pass mixtures of terminals and nonterminals to the parsers.
08:14:13 <ski> wli : i don't see why you need this ..
08:14:19 <pjd> check out the papers
08:14:24 <RyanT5001> pjd: thanks
08:14:34 <wli> ski: It's how linear-bounded automata work.
08:14:40 <ski> wli : hm .. or maybe you said earlier you want to be able to do context-sensitive grammers ?
08:14:51 <wli> ski: They finish when they reduce the input to a single symbol.
08:15:44 <RyanT5001> so i read STG machine the other day; i was wondering: why isn't the code for a closure in the heap? wouldn't it normally be a pretty small amount of code? this would save an indirection
08:16:03 <RyanT5001> i can see a caching issue with it, but it's not obviously inferior (to me)
08:16:34 <RyanT5001> also, then you don't have to have an array of free variables, you can put them in as immediates or whatever you think is best
08:16:40 <desp> @where FiniteMap
08:16:40 <lambdabot> I know nothing about finitemap.
08:16:51 <RyanT5001> @where Data.Map
08:16:52 <lambdabot> I know nothing about data.map.
08:16:52 <sorear> RyanT5001: In general, it's not a small amount of code; 5-20 instructions.  It would massively bloat the heap
08:16:58 <sorear> @docs Data.Map
08:16:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
08:17:03 <sorear> @hackage FiniteMap
08:17:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FiniteMap
08:17:13 <desp> is Map the same thing as FiniteMap?
08:17:17 <RyanT5001> sorear: ah, ok
08:17:28 <desp> ah
08:18:14 <RyanT5001> sorear: of course, you could always store a 5-byte jump
08:18:43 <mathias> What's the difference between the heap and the stack, performance wise? Aren't the heap and stack man made abstractions for something that's just a pile of memory locations that are adressable all in the same time?
08:18:44 <RyanT5001> sorear: so if you had one particular kind of closure that was less than 5 bytes and fairly common, you could really exploit that a lot
08:19:02 <wli> Okay, represent a production rule by an enum tag, basically (tag, listOfPredicates); slide the list of predicates over the input, when all evaluate to True reduce, with result (tag, listOfSymbols), except this is not monadically representible either.
08:19:23 <RyanT5001> mathias: yes, they're "man-made", although intel chips know about the stack
08:19:31 <sorear> RyanT5001: and 3 bytes of alignment ;)  What would that save over doing the indirection by hand?  Either way you need to indirect through the heap, but something tells me unpredictable code fetches are worse than unpredictable data fetches
08:20:15 <sorear> mathias: Stacks are less flexible, but in general much faster, so the compiler tries to move as much as possible there
08:20:18 <RyanT5001> sorear: you're probably right; i just wonder if there's a case of an 8-byte codeblock that could be made really common
08:20:30 <RyanT5001> mathias: however, not all memory addresses are the same speed, becuase some of them are in cache
08:20:41 <RyanT5001> stacks tend to exhibit much better locality
08:20:53 <RyanT5001> which means the top of them is much more likely to be in-cache
08:21:31 <RyanT5001> sorear: another question about STG: why are there constants? why not just put everything on the heap, and make the executable just be a heap image?
08:21:41 <RyanT5001> sorear: i meant globals, not constants
08:21:58 <mathias> In what way do the intel chips know more about the stack? Is it just the cacheing?
08:22:18 <sorear> RyanT5001: Mostly because people were writing compilers back then, not image systems ;)
08:22:49 <wli> mathias: Caching is funny, direct %esp/%rsp manipulations are weirdly slow, etc.
08:22:51 <RyanT5001> mathias: well, there are dedicated instructions for it; i don't know whether they actually do anything special
08:23:04 <RyanT5001> sorear: i hate people
08:23:24 <sorear> RyanT5001: Also, putting the info tables on the heap means you have to use the info table pointers during marking, which means every node suddenly has 20-50% more pointers
08:23:29 <RyanT5001> ^ "people" is universally quantified
08:24:15 <RyanT5001> sorear: crap, now i have to look up infotables again, lol
08:26:34 <zvrba> mathias: huh, the "only" thing special about stacks on x86 is that reloading SS disables interrupts for the duration of the next instruction
08:26:49 <zvrba> and rsp/esp are treated as an ordinary register
08:27:08 <sorear> zvrba: that's the only thing semantically special, but iirc there are non-semantic differences
08:27:30 <sorear> zvrba: of course, since Intel doesn't publish timing tables anymore, it's all just rumor
08:28:57 <zvrba> sorear: i've just looked into AMD optimization guide and mov to/from RSP has the same latency as all other MOVs
08:29:04 <wli> zvrba: They are not. Time arithmetic on them.
08:29:31 <Syzygy-> HAH!
08:29:45 <Syzygy-> I managed to prove what I wanted!
08:29:51 <zvrba> wli: what kind of arithmetic?
08:30:08 <wli> zvrvba: and (bitmasking)
08:30:26 <zvrba> AMDs instruction tables make no difference between registers
08:30:28 <wli> zvrvba: I don't see much AMD material so I've no idea there.
08:30:48 <wli> zvrba: But I can definitely see it on Intel.
08:30:51 <jatqceer> does the bang-patterns work the same as a `seq` b `seq` False = undefined?
08:31:08 <RyanT5001> pjd: this subtext thing seems ok, but i'm having a really hard time understanding the way their *language* works
08:31:27 <RyanT5001> pjd: specifically their State thing, which is... a monad? or.. something?
08:31:38 <zvrba> it might be different on intel, though
08:31:44 <zvrba> for AMD it's documented to be the same
08:31:56 <zvrba> wli: how do you measure time?
08:32:17 <xerox> Syzygy-++
08:32:31 <wli> zvrba: oprofile's sampling of perfctr's
08:32:53 <zvrba> ah. did you try to use rdtsc ?
08:32:55 <Syzygy-> xerox: :)
08:33:11 <wli> zvrba: OOOE vs. rdtsc. You tell me.
08:33:15 <zvrba> wli: what is the difference, btw? and where is the code you made?
08:33:35 <zvrba> wli: you put rdtsc before/after the loop.
08:33:48 <wli> zvrba: Not enough. Barriers/etc. are required.
08:33:56 <zvrba> it's enough
08:34:03 <zvrba> rdtsc is serializing instruction
08:35:22 <zvrba> anyway, food. bbl.
08:36:26 <desp> hrm
08:38:21 <ddarius> Syzygy-: What did you prove?
08:40:23 <Syzygy-> ddarius: That a left unit is a right unit, supposing both inverses exist.
08:40:25 <Syzygy-> In Coq.
08:42:20 <ddarius> I would think that would be pretty straightforward to do even formally in Coq.
08:43:40 <Syzygy-> ddarius: Sure. So far, my main problem has been wrestling with the Coq proof system.
08:44:12 <ddarius> I should learn to use one of those systems.
08:46:01 <Syzygy-> Now. How the bloody heck do I say "Apply the function (m x -) to both sides" to Coq?
08:48:28 <edwinb> you probably want f_equal
08:50:43 <Eelis> Syzygy-: (m x -) is not a valid Gallina term, is it?
08:51:48 <Eelis> (by the way, #coq exists.)
08:51:57 <Syzygy-> Eelis: No it isn't.
08:52:03 <Syzygy-> And I almos tassumed #coq would....
08:52:39 <drigz> my god, sometimes i'm shocked by how easily haskell code ends up working
08:52:56 <jfredett> drigz: i know, its great, isn't it?
08:53:18 <kpreid> drigz: did you see our suggestions about your "edges"?
08:53:38 <drigz> kpreid: yeah, i did. sorry i didn't say anything, i got absorbed writing it a different way
08:53:58 <drigz> i ended up using filter isValidPoint [(x-1,y),...]
08:54:06 <drigz> but thanks
08:54:37 <drigz> the [(x-1,y) | x < 0] ++ ... is a very nice way of writing code though
08:56:07 <desp> hrm
08:56:17 <desp> the memoizer code given in the SPJ paper doesn't quite work
08:56:28 * ddarius is confused.  There were six origami axioms, then someone found a seventh and proved them complete, now someone is claiming that one of the original six is all that's needed.
08:57:02 <desp> have scoping rules for where clauses changed since '99?
08:58:19 * wli tries to figure out how to deal with semantic actions.
08:58:26 <Saul_> @src Ord
08:58:26 <lambdabot> class  (Eq a) => Ord a  where
08:58:26 <lambdabot>     compare      :: a -> a -> Ordering
08:58:26 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:58:26 <lambdabot>     max, min         :: a -> a -> a
08:59:18 <Saul_> @src Eq
08:59:19 <lambdabot> class  Eq a  where
08:59:19 <lambdabot>     (==), (/=)   :: a -> a -> Bool
09:00:07 <rehges> @src LifeTheUniverseAndEverything
09:00:07 <lambdabot> Source not found. Where did you learn to type?
09:00:13 <monochrom> ddarius: it's ok. if six axioms are complete, seven axioms are too.
09:01:57 <sorear> But are seven axioms consistent?
09:02:37 <rapido> i just finished implementing enchilada in haskell
09:02:49 <wli> What's enchilada?
09:02:55 <rapido> haskell is perfect for DSL
09:03:12 <rapido> enchilada is a purely functional concatenative language
09:03:25 <wli> What's a concatenative language?
09:03:42 <ddarius> monochrom: Yes, but why would they feel the need for a seventh if they were already complete with just the sixth.
09:03:45 <rapido> forth, joy, factor, cat and enchilada
09:04:47 <rapido> concatenative language: wherein can just concatenate two well-formed expressions to form a new well-formed expression
09:04:57 <rapido> can <- you can
09:05:00 <monochrom> They guessed six were incomplete. But it remained a guess.
09:05:44 <rapido> i think it is called point-free style in the functional world
09:06:37 <monochrom> I think there is a little bit more in point-free than concatenative.
09:07:12 <rapido> monochrom: types?
09:08:07 <rapido> anyway, porting enchilada to haskell was a breeze
09:08:18 <rapido> and the code looks so much nicer
09:08:32 <rapido> the speed of ghc is amazing as well
09:08:51 <rapido> the resulting compiled code i mean
09:09:47 <ddarius> rapido: Porting from where?
09:10:01 <rapido> i have tried various languages: java, scheme, factor
09:10:37 <rapido> java was ugly but readable
09:10:46 <sfultong> is it just me, or are the pages linked off of http://www.haskell.org/all_about_monads/html/index.html broken?
09:10:47 <lambdabot> Title: All About Monads
09:10:57 <sfultong> starting with "doing it with class"
09:11:23 <rapido> scheme was ok but there i don't like the non-standardness of scheme
09:11:48 <rapido> factor was short and sweat but produced unreadable code
09:11:57 <monochrom> If you look at point-free with a concatenative lens, you may identify at least two concatenators: function application and function composition.  "f g h . k p . a b c d".  It is as though you have a tree rather than a sequence.
09:12:02 <rapido> (at least for me)
09:12:21 <rapido> monochrom: interesting
09:13:04 <kpreid> application is not concatenative
09:13:07 <rapido> monochrom: enchilada uses balanced trees for both data *and* reducible expressions.
09:13:14 <kpreid> becuase "g h" is not a fragment of "f g h"
09:13:31 <kpreid> the best similar thing is >>>
09:14:21 <rapido> monochrom: a guess when i look through my lens i only see function composition
09:14:55 <desp> whew.
09:15:22 <rapido> monochrom: enchilada is like lisp but then build on immutable balanced binary trees instead of list
09:15:23 <rapido> s
09:17:08 <rapido> just take a look: http://enchilada.javaforge.com/
09:17:56 <rapido> i may have to change that into haskellforge
09:19:01 * ddarius discovers a paper that has magically appeared on his harddrive.
09:20:42 <desp> hrm
09:21:00 <rapido> in enchilada, equality is probabilistic
09:21:30 <rapido> this means you can have efficient distributed equality with a very small change of a false positive
09:21:34 <desp> @where memoization
09:21:34 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
09:21:39 <desp> is anyone familiar with this paper?
09:21:58 <desp> I've been trying to use the code presented in it
09:22:29 <rapido> in haskell, you can't compare pointers for fast equality
09:22:35 <desp> and I'm not sure if it actually works correctly
09:22:54 <desp> rapido: you can compare StableNames
09:23:12 <rapido> desp: but not across different machines
09:23:34 <desp> in distributed Haskell...?
09:24:11 <rapido> desp: .... don't know distributed haskell ... but my guess that it is difficult if not impossible
09:24:43 <desp> rapido: "Glasgow Parallell Haskell distributes a single logical Haskell heap over a number of disjoint address spaces."
09:24:44 <rapido> or it doesn't scale because you have to have a central 'naming' service
09:24:56 <desp> "Pointers between these sub-heaps go via stable names, thus allowing each sub-heap to be garbage collected independently."
09:25:21 <rapido> desp: but doesn't that imply a central naming service?
09:25:46 <shapr> desp: Ooh, what's that from?
09:25:54 <desp> @where memoization
09:25:54 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
09:26:13 <shapr> Does it also talk about ways to do data locality?
09:26:28 <desp> shapr: not sure what you mean by that
09:26:29 <rapido> desp: very interesting stuff
09:27:06 <desp> rapido: I imagine that there is indeed a central naming service, since they appear to talk about a central heap
09:27:14 <desp> but I'm not familiar with GPH
09:27:14 <shapr> desp: Does it talk about how to get a sub-heap for each NUMA node?
09:27:24 <desp> shapr: no, they mention GPH only in passing
09:27:40 <desp> there's a reference, though
09:27:47 <ddarius> "Workshop on Mathematically Structured Functional Programming"
09:27:55 <rapido> desp: there is the difference between distributed computing and SMP
09:27:58 <wli> ddarius: Sounds interesting.
09:28:33 <rapido> when you want to scale in a distributed setup you can't have a central component
09:28:38 <desp> shapr: P. Trinder, K. Hammond, J. Mattson, A. Partridge, and S. P. Jones. GUM: a portable parallel implementation of Haskell. In SIGPLAN Symposium on Programming Language Design and Implementation (PLDI'96), Philadelphia. ApCM, May 1996
09:29:03 <shapr> Nifty
09:29:28 <rapido> my guess is that hashes of immutable values can serve as names
09:29:45 <rapido> and hashes don't need a central service
09:29:54 <rapido> they can be calculated locally
09:30:05 <desp> rapido: sure, as long as you forego laziness
09:30:08 <rapido> but can be compared peer-to-peer
09:30:34 <rapido> desp: i have created a nice hack around laziness
09:30:42 <rapido> you can also hash lazy structures
09:30:51 <desp> really.
09:31:02 <monochrom> how? how?
09:31:05 * monochrom drools
09:31:21 <rapido> just think of hashing a thunk
09:32:02 <rapido> in the end, a thunk is just a delayed computation (<-data)
09:32:03 <desp> the peer-local address of a thunk?
09:32:20 <rapido> desp: in enchilada, code is data (like in lisp)
09:32:26 <monochrom> But the thunk "1+2" has a different hash value from the whnf "3". Isn't that going to be a problem?
09:32:38 <rapido> monochrom: you are correct
09:33:31 <rapido> but when hashes *aren't' equal, then you just do normal (deep) equality
09:34:15 <rapido> so when values are equal that doesn't mean their hashes are equal
09:34:40 <rapido> but when hashes are equal then the values have high probability that they are equal
09:34:48 <ddarius> "Boom hierarchy"
09:35:15 <rapido> ddarius: what's that?
09:35:24 <desp> rapido: so you're hashing the code of a thunk?
09:35:33 <rapido> desp: more or less, yes
09:35:47 <Heffalump> is there any facility for (unsafely) getting at pointer values in GHC, instead of just comparing them for equality?
09:35:52 <ddarius> As far as I can tell, some ways of relating standard collections.
09:36:05 <desp> Heffalump: peek?
09:36:13 <ddarius> unsafeCoerce?
09:36:48 <desp> ah, *value*
09:37:06 <ddarius> http://citeseer.ist.psu.edu/bunkenburg93boom.html
09:37:08 <lambdabot> Title: The Boom Hierarchy - Bunkenburg (ResearchIndex)
09:37:11 <Heffalump> I want to be able to look them up, not just compare two for equality.
09:37:18 <Heffalump> just to provide a fast path optimisation
09:38:22 <rapido> ddarius: it's a dutch word: boom (<-tree)
09:39:28 <wli> Well, I've got grammar-building combinators. Now what?
09:41:31 <rapido> wli: what are your referring to?
09:41:52 <wli> rapido: Left recursion.
09:42:14 <wli> http://holomorphy.com/~wli/Grammar.lhs.txt
09:42:30 <wli> I guess semantic actions are a big if.
09:43:06 <ddarius> @google "Algebras for combinatorial search"
09:43:07 <lambdabot> http://citeseer.ist.psu.edu/767521.html
09:43:07 <lambdabot> Title: Algebras for combinatorial search (ResearchIndex)
09:43:10 <wli> The monadic behavior is not quite what one would expect.
09:43:46 <ddarius> wli: That's usually a bad thing.
09:44:12 <wli> ddarius: Well, the parser combinators are monadic actions that return grammars instead of results per se.
09:44:45 <wli> ddarius: Essentially because they need a name supply monad (I use my little CounterT for the occasion).
09:47:00 <ddarius> wli: There are two ways of thinking about that: 1) you have monadic functions that build grammars or 2) that isn't any different from e.g. a Parsec style approach.
09:47:21 * wli boggles.
09:50:06 <wli> ddarius: What's option (2) mean?
09:50:31 <ddarius> wli: You could implement Parsec as building a grammar data type and then interpreting it.
09:51:27 <wli> ddarius: That's what I would rather do, but it's not apparent how to pull that off.
09:51:50 <desp> my god, this doesn't work at all
09:54:31 <wli> ddarius: For the moment I'm clueless as to how to deal with semantic actions, too.
09:56:46 <desp> is there a way to run IO actions in ghci?
09:56:57 <Botje_> just evaluate them
09:57:11 <Botje_> Prelude> putStrLn "forty-two"
09:57:11 <Botje_> forty-two
09:57:36 <desp> > makeStableName 1
09:57:37 <lambdabot>   Not in scope: `makeStableName'
09:57:48 <desp> > System.Memory.StableName.makeStableName 1
09:57:49 <lambdabot>   Not in scope: `System.Memory.StableName.makeStableName'
09:57:52 <desp> ugh
09:57:55 <Botje_> no, \bot won't let you run IO actions
09:58:23 <desp> Prelude System.Mem.StableName> let m = makeStableName 1
09:58:23 <desp> Prelude System.Mem.StableName> :t m
09:58:23 <desp> m :: IO (StableName Integer)
09:58:40 <Botje_> yes
09:58:51 <Botje_> now do name <- m
09:59:17 <Botje_> creating an IO action isn't the same as executing it :)
09:59:25 <desp> right
09:59:31 <desp> I was missing the arrow
09:59:33 <desp> thanks
09:59:43 <desp> yes, it seems obvious now ;)
09:59:52 <monochrom> Oh, \bot is not latex code for bottom :)
10:00:17 <Botje_> \bot _IS_ a giant timesink
10:01:08 <rapido> desp: what's the result you're getting from makeStableName?
10:01:28 <desp> I am getting a different result every time
10:01:40 <desp> for the same value
10:01:48 <desp> which makes me wonder exactly what the hell is going on here
10:02:21 <Botje_> it's an IO action? :)
10:02:21 <rapido> desp: different execution contexts?
10:02:55 <rapido> not very stable then those stableNames
10:03:54 <sfultong> > error "fun is bad"
10:03:56 <lambdabot>  Exception: fun is bad
10:04:32 <desp> hmmm.
10:05:38 <ddarius> Isn't makeStableName supposed to return a different value every time?
10:06:16 <desp> no.
10:06:25 <rapido> ddarius: yes, it's like a allocating memory on the heap and getting a pointer to it
10:07:09 <desp> no.
10:07:32 <desp> @where memoization
10:07:32 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
10:07:38 <desp> ddarius: have you read this?
10:08:45 <desp> wait. maybe I am reading it wrong...
10:08:53 <ddarius> desp: Maybe a long time ago.
10:09:15 <ddarius> desp: You are doing something like let x = [3] in liftM2 (==) (makeStableName x) (makeStableName x)
10:09:29 <laz0r> hi #haskell, i am just wondering: is there something like trace from ocaml in haskell?
10:09:36 <ddarius> Debug.Trace.trace
10:09:36 <laz0r> http://caml.inria.fr/about/taste.en.html
10:09:37 <lambdabot> Title: A Hundred Lines of Caml
10:09:42 <laz0r> scroll down to the bottom
10:09:44 <rapido> desp: what's your take on probabilistic equality? - would you trust it?
10:09:46 <laz0r> uh
10:09:51 <laz0r> ah, great
10:09:55 <laz0r> i'll check it out
10:09:58 <laz0r> thx
10:10:09 <ddarius> laz0r: No there isn't really.
10:10:22 <rapido> desp: do you trust bittorrent? :)
10:11:33 <desp> rapido: um.
10:11:44 <desp> I'm sorry, but I'm in the middle of debugging this bloody thing
10:11:44 <wli> Hmm, there is something wrong with the types of these semantic actions.
10:11:55 <laz0r> ddarius, what about this: http://www.haskell.org/hat/?
10:11:56 <lambdabot> Title: Hat - the Haskell Tracer
10:11:57 <desp> ddarius: I'm just trying to get SPJ's memoizer to work
10:12:22 <ddarius> laz0r: That would do it, but it's not as convenient as OCaml's #trace.
10:12:36 <wli> ddarius: BTW I took a shot at getting ghci to parse typedefs at the cmdline. I found the type parsing function and choked from there.
10:12:40 <desp> ddarius: and it fails to memoize the fibs example given in the paper
10:12:53 <rapido> desp: ahh, ok, i won't bother you for now
10:13:58 <ddarius> desp: I believe there is a section in the user guide about these things.  You may want to look at it as that paper is eight years old.
10:15:21 <wli> I wonder if GADT's could be a solution to the semantic type problem. Or maybe existential types. Or something like that.
10:15:23 <ddarius> Or maybe there isn't...
10:16:58 <desp> so
10:19:43 <sorear> re.
10:20:09 <desp> sorear: arg
10:20:33 <desp> sorear: I am completely unable to get the StableName-based memoizer to work properlyu
10:20:43 <sorear> desp: Oh?
10:25:03 <SamB> what's with this build slave, I wonder: http://darcs.haskell.org/buildbot/head/x86-64%20Linux%20head%20fast
10:25:05 <lambdabot> Title: x86-64 Linux head fast Builder, http://tinyurl.com/yohxn5
10:25:36 <hpaste>  desp pasted "SNMap.hs" at http://hpaste.org/2078
10:25:47 <SamB> oh, maybe it's for manually-triggered builds...
10:25:52 <hpaste>  desp pasted "Memo.hs" at http://hpaste.org/2079
10:26:01 <SamB> that would explain why it's green but hasn't built anything much lately
10:26:08 <hpaste>  desp annotated "Memo.hs" with "Main.hs" at http://hpaste.org/2079#a1
10:26:20 <desp> gah.
10:26:26 <desp> well, split into two pastes
10:26:41 <desp> sorear: could you be so kind and take a look?
10:27:12 <sorear> wekk what's the symptom?
10:27:45 <hpaste>  desp annotated "Memo.hs" with "symptom" at http://hpaste.org/2079#a2
10:27:51 <SamB> sorear: did you mean "well"?
10:27:57 <sorear> yes.
10:28:12 * SamB was looking for something said by someone named "wekk"
10:29:20 <sorear> don't see anything obviously wrong, sorry
10:29:54 <desp> it just seems to me that StableNames are completely unsuitable to this task
10:30:34 <desp> which means the paper is basically completely out of touch with reality
10:30:42 <desp> which seems kind of odd to me
10:31:18 <SamB> what are these "StableName" things
10:31:28 <SamB> I though that was an ancient name for StablePtr?
10:31:53 <desp> they are like StablePtrs, but they allow objects to be GCd
10:32:38 <SamB> where does the System.Mem heirarchy come from?
10:32:59 <desp> GHC?
10:33:28 <SamB> oh, huh
10:33:34 <SamB> I don't remember seeing it before
10:33:55 <SamB> but even this old House GHC has it
10:34:08 <SamB> and hugs too
10:37:05 <SamB> eek
10:37:44 <SamB> these weak reference finalizers are allowed to ressurect the thing referenced weakly?
10:38:48 <desp> I think not
10:39:27 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
10:39:29 <lambdabot> http://tinyurl.com/25thsv
10:40:22 <SamB> it sounds like the kind of thing intended to make the user's life easier but which ends up just making things more difficult for everyone :-(
10:40:31 <ddarius> desp: Your definition of memo is different from the one in the paper.
10:41:03 <wli> There has to be some sort of typesystem trick for this.
10:41:15 <SamB> for what?
10:41:16 <desp> ddarius: syntactically, yes. semantically, though?
10:41:27 <ddarius> desp: You are playing with unsafePerformIO.
10:41:31 <desp> ddarius: the definition of memo' and finalizer given in the paper does not compile
10:41:42 <ddarius> desp: All I mentioned was memo.
10:41:46 <wli> SamB: Semantic actions in these bloody grammars.
10:41:57 <ddarius> desp: Have you tried the definition of memo that is in the paper?
10:42:02 <desp> yes, I have
10:42:23 <desp> it does not make a difference
10:42:51 <hpaste>  desp annotated "Memo.hs" with "original memo" at http://hpaste.org/2079#a3
10:43:06 <SamB> wli: is that one of your contrived problems or is that a real problem?
10:43:21 <wli> SamB: FOAD
10:43:28 <desp> oh, the Shows are leftovers from tracing
10:43:32 <SamB> wli: I meant...
10:44:00 <SamB> is this for learning or for actual use?
10:44:07 * SamB is just curious
10:46:36 <ddarius> desp: Have you tried it without the Show contexts (and thus without the traces)?  It should be no trouble telling an exponential and linear fibonacci apart.
10:46:45 * SamB wonders how StableNames are of any use -- there's nothing in the documentation that indicates that they would be
10:46:56 <desp> ddarius: yes, I have; fib 100 appears exponential
10:47:28 <Philippa> SamB: you can use them to spot loops in values, for example
10:47:30 <ddarius> desp: Did you try let x = 3 :: Integer in liftM2 (==) (makeStableName x) (makeStableName x) ?
10:47:44 <Philippa> read the paper that introduced them? (same one that introduced unsafePerformIO)
10:48:02 <desp> ddarius: that gives true
10:48:25 <sorear> desp: How about let x = 3 :: Integer; y = 3 :: Integer in ...
10:48:54 <sorear> desp: And what happens when you use Int?  The GHC runtime hash-conses small Ints (up to 256 iirc)
10:49:24 <ddarius> desp: Also have you traced the size of the SNMap?
10:49:57 * EvilTerran blinks at the GHC Core paper
10:49:57 <desp> aha
10:50:16 <desp> sorear: with x and y, the result is False
10:50:44 <desp> ddarius: yes, I traced the contents, and as I said before, makeStableName returns different SNs for the same values
10:51:14 <desp> Prelude System.Mem.StableName> let { x = 3 :: Integer ; y = 3 :: Integer } in Control.Monad.liftM2 (==) (makeStableName x) (makeStableName y)
10:51:14 <desp> False
10:51:34 <SamB> desp: the documenation cleverly fails to state that it ever will return the same SN twice
10:52:27 <SamB> also, fwiw, makeStableName doesn't evaluate it's first argument
10:54:46 <desp> indeed
10:55:24 <Botje_> ?src left
10:55:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:56:36 <SamB> so basically, as far as the documentation goes, you can't really expect more from it than from Data.Unique...
10:57:20 <ddarius> desp: How did makeStableName work with Ints or how does it work with fib :: Int -> Int?
10:58:28 <desp> ddarius: makeStableName returns two different SNs for two different Ints
10:58:37 <desp> same as with Integers
10:59:05 <desp> well, that wasn't very clear, so:  let { x = 3 :: Int ; y = 3 :: Int } in Control.Monad.liftM2 (==) (makeStableName x) (makeStableName y)  -->  False
11:00:09 <ddarius> desp: Have you tried compiling and compiling with optimizations?
11:01:37 <desp> hmm.
11:02:12 <desp> yes, both.
11:02:55 <desp> compiling does not help; compiling with optimizations floats out the redundant calculation of fib 3, so I replaced it with fib 4
11:03:05 <desp> the resulting trace shows that memoization is still not happening
11:03:46 <hpaste>  desp annotated "Memo.hs" with "trace of fib 3 and fib 4, with -O2" at http://hpaste.org/2079#a4
11:05:32 <ddarius> Bah.  fib is not a good example as you'd want to memoize based on value not address for it.
11:07:01 <desp> well, what can I say...
11:07:09 <desp> that's the example the authors gave :)
11:08:25 <sorear> @users
11:08:25 <lambdabot> Maximum users seen in #haskell: 382, currently: 342 (89.5%), active: 16 (4.7%)
11:09:02 <ddarius> desp: You could make a maximally shared complete binary tree and use a memoized size function.
11:11:33 <desp> I think I'm going to forget this approach
11:12:21 <ddarius> desp: If it doesn't work in the example I just described, then it's useless.
11:12:31 <fnord123_> If I have an unambiguous name in a successfully imported module, and I'm told that it's not in scope, and I try using ModuleName.DataType, how might I analyse the problem so I can start using this name?
11:12:59 <desp> ddarius: I actually need it to work in circumstances similar to fib, so... :)
11:13:11 <desp> thanks for your help
11:16:54 <oerjan> fnord123_: is this a data constructor?
11:17:01 <oerjan> do you have an export list?
11:17:06 <fnord123_> oerjan: yes.
11:17:52 <fnord123_> FWIW, I'm toying with MonadUndo: http://haskell.cs.yale.edu/haskellwiki/New_monads/MonadUndo
11:17:53 <lambdabot> Title: New monads/MonadUndo - HaskellWiki
11:17:58 <oerjan> data types must be exported as Type(..) if you want to include all constructors with pattern matching
11:19:30 <oerjan> if you just list the constructor separately i vaguely recall you just get it as a function, not as a pattern.
11:20:10 <kpreid> I'd expect you get a type with that name exported rather than a value constructor, if you list it separately
11:20:27 <oerjan> ...maybe
11:20:55 <kpreid> and I'd assume that if you want to export some constructors, it's Type(Constr)
11:21:03 <oerjan> yeah
11:21:45 <oerjan> maybe it is the fields that get exported as functions if you separate them.
11:22:18 <fnord123_> well, even functions don't seem to work. For example, if i try to use "blankHistory" it's not in scope.
11:22:37 <oerjan> what does your import declaration look like?
11:22:46 <fnord123_> "import MonadUndo"
11:22:50 <oerjan> and also, the export declaration i guess
11:23:05 <fnord123_> export decl is in the url I passed earlier.
11:23:07 <Cale> fnord123_: blankHistory isn't exported
11:23:45 <fnord123_> doh. too much shotgun trial/error since im confused enough
11:24:00 <Cale> actually, possibly it should be
11:24:26 <Cale> Really though, I think History, current, undos and redos shouldn't have been exported.
11:25:16 <Cale> yeah, there we go (edited the page)
11:25:24 <wli> data Grammar t a = Grammar { startSymbol :: Integer, ruleSet :: [Production t a] }
11:25:35 <Cale> er, hmm...
11:25:53 <desp> ddarius, sorear: I reimplemented the memoizer without StableNames, and it works great
11:26:03 <wli> data Production t a = Production { leftHandSide :: Integer, leftContext, rightContext, rightHandSide :: [Either t Integer], action :: ([t] -> a) }
11:26:18 <Cale> nah, I'll put them back :)
11:26:27 <Cale> That's what the 'history' action is for :)
11:26:58 <lament> what's the html tag for typewriter text?
11:26:58 <Cale> It allows you to observe the current history, but not to edit it.
11:27:14 <ddarius> desp: Simply using Eq?
11:27:15 <Cale> Hence, blankHistory is useless outside the module itself.
11:27:19 <oerjan> <code> or <tt>, i think
11:27:25 <lament> thanks
11:27:39 <desp> ddarius: using a Map and function arguments for keys, so requiring Ord
11:27:48 <lament> i'm... writing a tutorial about monads :D
11:27:48 * wli notes that Production.action is not working out very well.
11:27:55 <oerjan> (at least i've used <code> frequently on the esolangs wiki)
11:28:05 <wli> lament: ooh, I need all the monad tutorials I can get.
11:28:18 <lament> :D
11:28:31 <hpaste>  desp pasted "IOMap.hs" at http://hpaste.org/2080
11:28:38 <ddarius> desp: Okay.  That is the right way to handle something like fib.
11:28:40 <oerjan> lament: i hear that's a phase everyone goes through.  and that most of them end up pretty horrible, confusing people even more.
11:28:42 <hpaste>  desp annotated "IOMap.hs" with "Memo.hs" at http://hpaste.org/2080#a1
11:28:52 <hpaste>  desp annotated "IOMap.hs" with "Main.hs" at http://hpaste.org/2080#a2
11:28:54 <Cale> fnord123_: try something like  evalUndo (do { put 5; undo; get }) 0
11:29:08 <desp> if anyone cares
11:29:13 <desp> :)
11:29:30 <SamB> I never finished my tutorial. Though it wasn't about monads per-se.
11:29:31 <lament> oerjan: i'll be careful.
11:29:41 <oerjan> lament: oh, and of course <pre> for larger excerpts
11:29:43 <ddarius> Cale: Hmm, MonadTransactionT
11:29:46 <desp> blah, spurious Shows again.
11:30:12 <fnord123_> Cale: "not in scope: "put" ... "get"
11:30:13 <ddarius> lament: Why do you think another is necessary anyways?
11:30:47 <Cale> fnord123_: Have you imported Control.Monad.State? Perhaps it would be a good idea for MonadUndo to reexport those.
11:30:48 <wli> lament: Please, lots of exercises.
11:31:06 <lament> ddarius: oh, i don't
11:31:27 <fnord123_> I agree it would be good for it to re-export them. :)
11:31:31 <Cale> done.
11:31:32 <cognominal__> is there a constructor for Integers?  I have found   toInteger but this is more a type convertor
11:31:46 <oerjan> cognominal__: not really
11:31:48 <Cale> cognominal__: no.
11:31:52 <SamB> cognominal__: there might be two, but you aren't allowed to use them
11:31:53 <desp> > 1 :: Integer
11:31:55 <lambdabot>  1
11:31:58 <Cale> cognominal__: Internally, there is.
11:32:17 <cognominal__> ok, thx
11:32:21 <chessguy> hmm, i wonder if you could somehow get atomicity of transactions for free using monads
11:32:34 <oerjan> cognominal__: but you can pattern match against numbers, of course
11:32:37 <Cale> data Integer
11:32:37 <Cale>   = GHC.Num.S# GHC.Prim.Int#
11:32:37 <Cale>   | GHC.Num.J# GHC.Prim.Int# GHC.Prim.ByteArray#
11:32:37 <Cale>         -- Defined in GHC.Num
11:32:45 <SamB> cognominal__: honestly, you don't want to use them ;-)
11:32:47 <fnord123_> fwiw, you export History again
11:33:22 <cognominal__> I was just curious... not that I like consistency for sake of consistency
11:33:53 <SamB> cognominal__: was there any particular reason you were wondering this?
11:34:05 <oerjan> cognominal__: S# and J# are not portable between compilers of course.
11:34:18 <Cale> You can sort of think of every integer literal as a constructor for Integer
11:34:27 <Cale> Especially since they're allowed in patterns.
11:34:28 <ddarius> cognominal__: You can view Integer as being data Integer = 0 | 1 | 2 | ...
11:34:39 <cognominal__> I am still in the process of learning Haskell. My way of doing it is asking all sort of weird questions
11:34:45 <Cale> :)
11:35:12 <SamB> cognominal__: well, I mean, what were you thinking about when you decided to ask this question?
11:35:57 <desp> is it possible to use pattern matching and/or guards in lambda expressions?
11:36:09 <cognominal__> a constructor build "things". An integer is a "thing". Does it have a constructor?
11:36:10 <SamB> desp: yes but not terribly useful
11:36:14 <ddarius> desp: You can use pattern matching, but not different cases.
11:36:23 <SamB> cognominal__: the nearest thing is a numeric literal
11:36:30 <desp> ddarius: ah
11:36:50 <cognominal__> I don't say all my question are meaningful. It is just a way to learn actively.
11:36:59 * SamB wonders what the report says about pattern matching -0
11:38:09 <cognominal__> Samb: I would agree that would be a totally satisfying answer but  Prelude> :t 1
11:38:09 <cognominal__> 1 :: (Num t) => t
11:38:16 <Cale> cognominal__: Actually, 'constructor' is sort of a funny term, because the really special thing about constructors in Haskell is less that they build things, but more that you can take things apart based on them.
11:38:28 <Tac-Tics> Can somebody explain what the difference is between fmap and lift?
11:38:36 <Botje_> :t fmap
11:38:37 <Cale> Tac-Tics: fmap and liftM?
11:38:37 <Botje_> :t liftM
11:38:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:38:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:38:48 <Cale> Just that fmap is a bit more general.
11:38:52 <cognominal__> so that gives me a Num which is a "wider thing" than a interger. Yes I know about Nums and type classes
11:39:09 <Cale> cognominal__: That's because 1 is sugar for fromInteger 1
11:39:10 <SamB> cognominal__: so?
11:39:28 <Cale> (where the latter 1 is a "real" Integer
11:39:31 <Cale> )
11:39:40 <SamB> which is a really confusing explanation
11:39:51 <Tac-Tics> Functors are not necessarily Monads, right?
11:39:56 <SamB> Tac-Tics: indeed
11:40:04 <Cale> Tac-Tics: no, but Monads are necessarily Functors.
11:40:09 <Tac-Tics> What are functors useful for?
11:40:11 <Tac-Tics> ah
11:40:20 <SamB> unfortunately sometimes people forget to write Functor instance for a Monad
11:40:29 <Winterstream> Tac-Tics: Right. But all Monads are Functors.
11:40:38 <Cale> Tac-Tics: As far as Haskell is concerned, they're exactly the kind of data structures where you can apply a function to all the elements.
11:40:55 <SamB> take Language.Haskell.TH.Q as a practical example of a Monad that someone forgot a Functor instance for
11:40:57 <desp> I'm getting a lot of warnings about "Defaulting the following constraint(s) to type `Integer'"
11:40:58 <cognominal__> so I asked myself the wau to construct an integer and found toInteger wich was nice but dit not really answer my original question
11:41:14 <Cale> :t toInteger
11:41:16 <SamB> cognominal__: basically, you use (1 :: Integer)
11:41:16 <lambdabot> forall a. (Integral a) => a -> Integer
11:41:27 <kpreid> cognominal__: btw, you can create your own things without visible constructors. just define them in a module and don't export the constructors
11:41:28 <cognominal__> but the answer, there is no "external" constructors for Integers is fine by me.
11:41:35 <Tac-Tics> so like, a "set" type would be a functor?
11:41:37 <Tac-Tics> but not a monad?
11:41:43 <kpreid> cognominal__: then you've done exactly the same thing as is done for Integer
11:41:44 <desp> how can I get rid of them?
11:41:56 <SamB> desp: :: Integer
11:41:58 <Cale> Tac-Tics: Actually, in an ideal world, it would be both, but Haskell won't let you write either instance.
11:42:02 <cognominal__> kpreid: I agree
11:42:13 <Tac-Tics> what do you mean Cale?
11:42:15 <desp> @type (sum [1..100])^2 - sum [n^2 | n <- [1..100]]
11:42:17 <lambdabot> forall t. (Enum t, Num t) => t
11:42:20 <Cale> Tac-Tics: This is because typically, Set data structures require something like Ord in order to do fmap or bind.
11:42:27 <SamB> Tac-Tics: the Ord constraint messes the whole thing up
11:42:39 <Cale> Tac-Tics: But the Functor and Monad classes define fmap and bind to be unboundedly polymorphic.
11:43:16 <Tac-Tics> what does that mean? X-D
11:43:28 <Cale> Well, consider trying to do something like
11:43:57 <oerjan> Tac-Tics: basically, you cannot define a set data structure whose elements are an arbitrary type
11:43:59 <Cale> fmap (\x f -> f x)
11:44:01 <hpaste>  desp pasted "irritating warning" at http://hpaste.org/2081
11:44:07 <desp> SamB: ^
11:44:09 <Cale> :t (\x f -> f x)
11:44:11 <lambdabot> forall t t1. t -> (t -> t1) -> t1
11:44:11 <Tac-Tics> Couldn't one then in theory define a hashed-implemented set to give it functor-like superpowers?
11:44:37 <Cale> Tac-Tics: It still needs equality testing.
11:44:45 <Cale> (or Hashable)
11:44:57 <Cale> You can't hash just anything.
11:45:00 <desp> it seems that (^) causes those warnings
11:45:08 <Cale> In particular, you can't hash functions.
11:45:14 <Cale> (because they're not observable)
11:45:27 <desp> ahh, 2 :: Integer
11:45:27 <SamB> desp: what -W flags are you using?
11:45:32 <desp> SamB: -Wall
11:45:42 <SamB> desp: hmm.
11:45:51 <SamB> well perhaps you shouldn't?
11:46:03 <desp> SamB: what would you suggest, then?
11:46:08 <SamB> or you could just use a square function...
11:46:13 <Tac-Tics> but set provides its own map, I see
11:46:21 <Tac-Tics> hmm
11:46:31 <Tac-Tics> Types confuzzle me
11:46:35 <Tac-Tics> ^^
11:46:45 <desp> I could, indeed. the warning seem just quite spurious to me
11:47:02 <Cale> The Set type is actually one of the best examples of a monad, if only this little hitch didn't prevent it from being an instance :)
11:47:23 <Cale> It's actually a monad on a subcategory of the category of Haskell types.
11:47:24 <Tac-Tics> ah, I think I kinda get it
11:47:38 <SamB> desp: also you should call that file problem6.hs
11:47:50 <SamB> ;-P
11:47:50 <Tac-Tics> so the reason Set isn't a monad or functor is simply because it can't be when the type of Set doesn't have Eq?
11:47:56 <desp> SamB: right back at you
11:48:11 <Cale> Yeah, you need to constrain the type parameter it's being applied to.
11:48:16 <Tac-Tics> So if you had a special case of set which only worked for Int, Bool, String, Char, etc, it would work
11:48:20 <ddarius> It doesn't really matter too much if some Monad doesn't have a functor instance since you can always write, instance Functor TheMonad where fmap = liftM.
11:48:41 <Tac-Tics> but with Functions computational limits make you go "aw crap" and you can't do it
11:48:41 <SamB> ddarius: actually you can't
11:48:45 <oerjan> Tac-Tics: that wouldn't need a special case of Set, but a special case of Monad
11:49:02 <SamB> ddarius: if you write that, then your code is liable to break when the library is fixed ;-)
11:49:04 <Cale> But consider something like  fmap (\x y -> y x) :: (Functor f) => f a -> f ((a -> t) -> t)
11:49:33 <ddarius> SamB: If they change the interface, then your code is going to break.
11:49:36 <Tac-Tics> I think I understand that a little better maybe
11:49:41 <Cale> So if Set was an instance of Functor, you'd be able to specialise that to
11:49:47 <desp> square = (^ (2 :: Integer)) -- I think this is the ugliest Haskell code I've ever written
11:49:48 <Cale> Set a -> Set ((a -> t) -> t)
11:49:58 <mrd> if haskell used module functors instead of typeclasses, you could probably write monad structures for specific instances of sets
11:50:00 <Cale> but there's clearly no way for that to work
11:50:06 <Tac-Tics> is there a Poset type class?
11:50:16 <Cale> There could be, but isn't.
11:50:22 <ddarius> square = join (*)
11:50:22 <fnord123_> Cale, weird. The code you suggested (evalUndo (do {...}) 0 ) works in ghci but not when I compile from a file. "No instance for (Num (IO a)) arising from the literal `0' at MonadUndo.t.hs:5:40"
11:50:22 <DRMacIver> desp: Why would you write that instead of square a = a * a ?
11:50:24 <SamB> ddarius: really the best thing to do is work around it while you wait for them to fix it...
11:50:24 <oerjan> desp: that 2 should default to Integer anyway
11:50:26 <Tac-Tics> reading through the set class, the method "isProperSubsetOf" and the length of the name makes me cry
11:50:34 <fnord123_> "Possible fix: add an instance declaration for (Num (IO a))"
11:50:38 <desp> oerjan: it defaults with a warning
11:50:46 <desp> oerjan: http://hpaste.org/2081
11:50:47 <Cale> fnord123_: what file are you trying to compile?
11:50:51 <desp> DRMacIver: you're right!
11:50:51 <Cale> !paste
11:50:51 <hpaste> Haskell paste bin: http://hpaste.org/
11:50:53 <SamB> Tac-Tics: consider that isSubsetOf exists as well
11:50:55 <oerjan> desp: yeah, i recall someone complaining about that on haskell-cafe
11:50:56 <Cale> please paste it :)
11:50:58 <mrd> Tac-Tics: heh, too bad no one's thought of a good way to do \subset in ascii
11:51:00 <ddarius> Are Sets Ord instances?
11:51:06 <SamB> Tac-Tics: also that's a module, not a class, isn't it?
11:51:12 <Cale> ddarius: yes
11:51:12 <oerjan> they were trying to compile with all warnings turned into errors...
11:51:23 <DRMacIver> desp: I think there's an optimiser failure which means that version is even noticably faster. :)
11:51:33 <desp> hah
11:51:35 <Cale> Ord a => Ord (Set a)
11:51:44 <Tac-Tics> what is a module and not a class, SamB?
11:51:53 <SamB> DRMacIver: quite so
11:52:05 <pgavin> does anyone know a good website that links haskell monads & arrows to traditional category theory?
11:52:09 <SamB> DRMacIver: something about not having induction over Int or something?
11:52:13 <Tac-Tics> It would be cool to have a special keyboard which had keys for common mathematics symbols built into it
11:52:17 <Cale> Tac-Tics: You're reading through the Set module, there is no Set class.
11:52:21 <SamB> or Integer I guess
11:52:29 <ddarius> pgavin: Moggi's Notions of Computation.
11:52:34 <SamB> if Integer were defined:
11:52:47 <Cale> fnord123_: ?
11:52:50 <DRMacIver> SamB: I don't understand why it's there. :) All I know is that people have complained about the fact that a lot of constant expressions with numeric literals don't get optimised as well as one would hope.
11:52:56 <SamB> data Integer = P | I Integer | C Integer, we wouldn't have this problem
11:53:00 <shachaf> Tac-Tics: If you use GTK, you can use SCIM to type some LaTeX symbols.
11:53:03 <chessguy> @bot
11:53:04 <lambdabot> :)
11:53:14 <chessguy> @go haskell
11:53:16 <lambdabot> http://www.haskell.org/
11:53:17 <lambdabot> Title: Haskell - HaskellWiki
11:53:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2082
11:53:22 <Cale> DRMacIver: That's what the SPECIALISE pragma is for :)
11:53:23 <Tac-Tics> Cale: Did I call it a class? I'm am educated in OOP, so when I hear data Set, I think class Set
11:53:26 <SamB> (note: that's an ICFP contest joke)
11:53:31 <fnord123_> http://hpaste.org/2082
11:53:36 <pgavin> ddarius: cool, thanks
11:53:56 <Cale> fnord123_: main has the wrong type, also, you forgot the parameter to put
11:53:57 <mrd> it doesn't help that many OO languages confuse modules and classes
11:54:14 <Tac-Tics> ‚àÄx: x >= 0
11:54:26 <hpaste>  Cale annotated "(no title)" with "corrections" at http://hpaste.org/2082#a1
11:54:36 <fnord123_> oh i typed that in since copy/paste was putting in some chinese characters for some reason
11:54:45 <oerjan> mrd: i believe Scala does so deliberately and brilliantly
11:54:55 <Tac-Tics> In OOP, class = data type. In Haskell, class = class type... or in Java or something, it's like an Interface
11:55:03 <fnord123_> sweet. print $ evalBlahblah works a treat.
11:55:04 <oerjan> i.e. their classes are generalized enough to _include_ modules
11:55:11 <Cale> Tac-Tics: yeah
11:55:15 <DRMacIver> oerjan: I think Scala conflates modules and objects rather than classes.
11:55:24 <Cale> Tac-Tics: class -> typeclass :)
11:55:33 <d-bug> like interfaces with virutal concrete methods :)
11:55:33 <DRMacIver> oerjan: But I might be wrong.
11:55:44 <oerjan> DRMacIver: maybe, perhaps it's functors that become classes
11:56:13 <DRMacIver> Possibly. I'm not entirely sure.
11:56:17 <DRMacIver> I need to do more Scala. :-/
11:56:42 <Cale> Typeclasses are really distinguished from classes by the fact that the operations are carried around separately from the data they act on.
11:56:42 <GoAwayStupidAI> I always thought Haskell's use of "class" was more consistent with the set theoretic definition of "class": http://en.wikipedia.org/wiki/Class_%28set_theory%29
11:57:04 <Cale> Yes, it is :)
11:57:11 <Cale> (and that's why the term is being used)
11:57:16 <GoAwayStupidAI> whew...
11:57:21 <newsham> i always thought it was more consistent with what you would have to go to class to learn
11:57:21 <DRMacIver> Yeah. It's still an unfortunate name clash. :)
11:57:23 <GoAwayStupidAI> I come from C++ land to ;-)
11:57:34 <GoAwayStupidAI> but I definitely like haskell's use better
11:58:02 <Cale> I really don't care about name clashes. Haskell's a different language, it's allowed to use names to mean different things :)
11:58:09 <Cale> (cf. return)
11:58:14 <DRMacIver> Sure
11:58:18 <DRMacIver> It doesn't bother me especially.
11:58:27 <DRMacIver> But it can occasionally cause confusion.
11:58:44 <Tac-Tics> I don't know why, but learning haskell more than other languages, I never quite know which module a function is defined in
11:58:56 <mrd> :info function
11:59:01 <Tac-Tics> I never had such a problem with it in Python or Java or other languages
11:59:09 <Tac-Tics> :info isProperSubsetOf
11:59:13 <Cale> Tac-Tics: You haven't noticed the Index feature of the hierarchical library docs yet? :)
11:59:18 <GoAwayStupidAI> A module can re-export the definitions in another module
11:59:19 <mrd> try it in GHCi, tac
11:59:21 <GoAwayStupidAI> which is handy
11:59:22 <drigz> @hoogle isProperSubsetOf
11:59:22 <Tac-Tics> ah
11:59:23 <lambdabot> Data.IntSet.isProperSubsetOf :: IntSet -> IntSet -> Bool
11:59:23 <lambdabot> Data.Set.isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
11:59:24 <Tac-Tics> hehe, yeah
11:59:27 <Tac-Tics> @info
11:59:27 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
11:59:27 <GoAwayStupidAI> but I can get confused tracking things down
11:59:29 <Tac-Tics> does that work?
11:59:35 <Tac-Tics> @info isProperSubsetOf
11:59:35 <lambdabot> isProperSubsetOf
11:59:37 <mrd> its broken for some reason
11:59:42 <Cale> @info isProperSubsetOf
11:59:42 <lambdabot> isProperSubsetOf
11:59:43 <Tac-Tics> silly lambda bot
11:59:45 <Cale> heh
11:59:50 <ddarius> Tac-Tics: Program in Smalltalk for a while...
11:59:52 <mrd> but @hoogle works
11:59:53 <Alleria> now if GoA actually built locally...
11:59:54 <Cale> @index isProperSubsetOf
11:59:54 <Tac-Tics> @info  = id
11:59:55 <lambdabot> Data.IntSet, Data.Set
11:59:55 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
12:00:07 <Tac-Tics> what's smalltalk like?
12:00:07 <Cale>  @index works
12:00:16 <oerjan> @help info
12:00:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:00:23 <oerjan> @list info
12:00:24 <lambdabot> No module "info" loaded
12:00:26 <mrd> a pretty neat lightweight OO language with functions everywhere hiding as blocks
12:00:30 <Cale> Tac-Tics: Purely OO, rather lightweight syntax, everything is mutable.
12:00:44 <ddarius> They love dynamic dispatch.
12:00:50 <Tac-Tics> when you say mutable, you mean like, public visibility?
12:00:53 <oerjan> it's got to be something typo corrected
12:00:55 <Cale> Tac-Tics: Also, it has a history of having very graphical user environments.
12:01:00 <ddarius> Tac-Tics: No, reflective.
12:01:01 <fnord123_> Tac-Tics: It's dynamically typed OO language. Useful for gui programming and most environments use a running image rather than files
12:01:04 <mrd> @google squeak smalltalk
12:01:08 <lambdabot> http://www.squeak.org/
12:01:08 <lambdabot> Title: Squeak: Squeak
12:01:14 <Cale> Yeah, install squeak and try it :)
12:01:18 <oerjan> @indo test
12:01:18 <lambdabot> test
12:01:26 <mrd> its definitely worth checking out, just for the perspective
12:01:30 <oerjan> @imho test
12:01:31 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "oerjan!n=oerjan@hagbart.nvg.ntnu.no", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@imho test"]} rest:"test"
12:01:33 <Cale> I was able to learn enough to write some small things in about a day. :)
12:01:52 <oerjan> o_O
12:01:57 <ddarius> Trying to find where a method is -actually- defined is a nightmare.
12:02:02 <Cale> It's fun, but I found myself constantly amazed that it didn't just shake itself to pieces.
12:02:06 <mrd> ddarius: why? ask the environment
12:02:42 <fnord123_> The mousiness of smalltalk environments alarms me.
12:02:49 <oerjan> @imfo test
12:02:49 <lambdabot> Unknown command, try @list
12:02:55 <ddarius> mrd: And it returns 100 methods, some related some not.  And that's if you are lucky enough that it doesn't do something completely crazy and not use the dynamic dispatch.
12:03:12 <oerjan> @mnfo test
12:03:13 <lambdabot> test
12:03:18 <mrd> heh, i suppose. welcome to OO.
12:03:25 <oerjan> @inmo test
12:03:26 <lambdabot> test
12:03:33 <oerjan> @infm test
12:03:33 <lambdabot> Unknown command, try @list
12:03:39 <Cale> Anything can theoretically interfere with the operation of anything else. I wrote a little object to cheat at the example minesweeper game by looking inside the cell that it was placed over.
12:03:48 <Cale> (A mine detector)
12:04:52 <oerjan> @list id
12:04:52 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
12:05:14 <ddarius> @list kind
12:05:14 <lambdabot> type provides: type kind
12:05:49 <ddarius> @eval
12:06:02 <oerjan> @nfo test
12:06:02 <lambdabot> Maybe you meant: bf ft undo
12:06:12 <oerjan> hm...
12:06:29 <oerjan> @info do x <- hi mom; return ho
12:06:29 <lambdabot> hi mom >>= \ x -> return ho
12:06:33 <ddarius> @echo foo
12:06:33 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "ddarius!n=derek@74.197.12.46", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo foo"]} rest:"foo"
12:06:34 <oerjan> success!
12:06:58 <ddarius> @undo test
12:06:58 <lambdabot> test
12:06:59 <chessguy> @quote bf
12:06:59 <lambdabot> <erg0t> says: @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
12:07:25 <oerjan> @cho foo
12:07:26 <lambdabot> Maybe you meant: choice-add choose echo
12:07:35 <ddarius> @help choose
12:07:35 <lambdabot> choose. Lambdabot featuring AI power
12:07:38 <Tac-Tics> @bf +++++++++++++++++++++++++++++++++++++++.
12:07:38 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
12:07:44 <chessguy> @choose foo
12:07:44 <lambdabot> foo
12:07:49 <oerjan> @help echo
12:07:49 <koala_man> I want to write a function that goes over a [String] and compares certain entries to one of the past n (say 10) elements. how would I do that efficiently?
12:07:49 <lambdabot> echo <msg>. echo irc protocol string
12:07:53 <Tac-Tics> oh god! I broke lambdabot's pipe!
12:08:12 <oerjan> Ceci n'est pas une pipe
12:09:12 <chessguy> koala_man, what do you mean compare? you mean test to see if it occurs iin the past n elements?
12:09:31 <Saizan> koala_man: while traversing the list you keep a reversed copy of the elements traversed by consing them to an accumulator
12:09:54 <ddarius> @choose foo bar baz
12:09:54 <lambdabot> foo bar baz
12:09:56 <Tac-Tics> http://lukeplant.me.uk/blog.php?id=1107301645
12:09:58 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
12:10:01 <Tac-Tics> have you guys seen that blog post?
12:10:15 <Tac-Tics> It's funny because of how true it is
12:10:22 <DRMacIver> Yeah
12:10:36 <Tac-Tics> the other day at work, I found myself wanting to return a tuple in PHP
12:10:41 <Tac-Tics> =-(
12:10:54 <DRMacIver> Can't you just return an array?
12:11:06 <therp> tac-tics: yes. I found myself unable to code C a few months ago
12:11:15 <koala_man> Saizan: but that will make the list pretty huge after a while
12:12:23 <Tac-Tics> DRMaclver: that's what I did
12:12:35 <Tac-Tics> but you can't unpack it like in Python
12:12:43 <chessguy> lol
12:12:51 <chessguy> i like ndm's response
12:12:51 <chessguy>  Neil Mitchell
12:12:51 <chessguy> 31 Aug 2006 00:15
12:12:51 <chessguy> At least you don't have to use C?
12:12:58 <koala_man> chessguy: yes
12:13:04 <allbery_b> ...or perl
12:13:12 <Tac-Tics> I had to do
12:13:12 <Tac-Tics> $ret = func($params);
12:13:12 <Tac-Tics> $val1 = $ret[0];
12:13:12 <Tac-Tics> $val2 = $ret[1];
12:13:31 <Tac-Tics> three lines when all I wanted was to return a two-part value
12:13:38 <chessguy> i definitely see his first point. i'm not so sure about his second, though
12:14:06 <Tac-Tics> it depends on the language and you're training
12:14:20 <chessguy> i don't think knowing haskell makes you obfuscate code in other languages
12:14:26 <Tac-Tics> if you write functional code, your coworkers might not be smart enough with FP to "get" it
12:14:44 <wli> ddarius: Any suggestions on how to incorporate semantic actions in all this?
12:14:47 <mrd> yea i'm spoiled now.  don't want to write code in other languages.  not sure what i'd do if i had to get a real job.
12:14:51 <DRMacIver> chessguy: It does if you try to write Haskell in other languages, which can occasionallly be tempting. :)
12:15:01 <ddarius> There are better ways of writing OOP code that is consonant with some FP practices.
12:15:08 <allbery_b> I see his second point fairly clearly, btw.  Try writing functional style in perl sometime
12:15:20 <EvilTerran> allbery_b, you can easuly return multiple values in perl...
12:15:21 <chessguy> well, sure. but the _concepts_ of haskell can still improve imperatively-written code
12:15:25 <chessguy> i.e., modularity
12:15:29 <allbery_b> (I actually do it sometimes, but it makes ordinary obfuscated perl code look transparent...)
12:15:29 <chessguy> abstraction
12:15:30 <koala_man> Tac-Tics: why couldn't you do return (3,4); and ($a, $b) = subname(); ?
12:15:31 <chessguy> etc.
12:15:32 <DRMacIver> chessguy: Absolutely.
12:15:38 <ddarius> wli: Where's a paste?
12:15:43 <wli> chessguy: Separation/layering of types of effects.
12:15:52 <allbery_b> evilterran: no, the haskell blog article, not the multiple values thing
12:15:54 <DRMacIver> chessguy: Knowing Haskell can be very helpful in writing other languages, but it requires a lot of discipline to not go overboard with it.
12:15:56 <EvilTerran> aha
12:16:02 <Tac-Tics> it's PHP... which doesn't have a tuple type as far as I know
12:16:13 <wli> ddarius: It's too large to paste (though I could, in principle, paste in pieces). http://holomorphy.com/~wli/Grammar.lhs.txt has the code.
12:16:14 <ddarius> Don't try to write monadic code in Java and you should be good.
12:16:15 <allbery_b> chessguy said he didn't see the second point.  I most definitely do
12:16:26 <DRMacIver> ddarius: Even vaguely functional code, really. :-/
12:16:37 <koala_man> Tac-Tics: ah, I was thinking perl
12:16:38 <DRMacIver> ddarius: Although hopefully that's changing.
12:16:42 <Tac-Tics> ah
12:17:07 <wli> DRMacIver: Haskell helps build up the skills for heavy bondage and discipline programming
12:17:20 <allbery_b> I'm afraid to ask how java will mess up monads :)
12:17:33 <Tac-Tics> Java, monads?
12:17:35 <DRMacIver> allbery_b: Not monads, just first class functions. :)
12:17:36 <chessguy> allbery_b, what i intended to say was that i could *see* his second point, but didn't agree with it
12:17:58 <Tac-Tics> Java doesn't even get higher order functions, Monads don't belong there
12:18:24 <drigz> i read some functional C code a while back
12:18:30 <wli> allbery_b: I'm not sure Java's type system can absorb constructor classes as required for monads. Maybe F-bounded polymorphism could help, but I doubt it.
12:18:31 <ddarius> wli: You might be interested at looking at attribute grammars.
12:18:50 <chessguy> @go wikipedia attribute grammar
12:18:52 <lambdabot> http://en.wikipedia.org/wiki/Attribute_grammar
12:18:52 <lambdabot> Title: Attribute grammar - Wikipedia, the free encyclopedia
12:19:18 <DRMacIver> wli: augustss and I ended up talking about how one might get monad like things to work in Java's type system in my interview at Credit Suisse.
12:19:24 <ddarius> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
12:19:26 <lambdabot> Title: HUT / Attribute Grammar System
12:19:50 <DRMacIver> wli: The basic conclusion was that maybe you could sortof fake it by adding extra type parameters, but it was never going to work very well.
12:20:00 <DRMacIver> (I think. I don't remember the details)
12:20:18 <oerjan> i recall when i looked at Scala it seemed to have some monadic _syntax_ (for comprehension stuff), but not any real type support
12:20:39 <oerjan> i think it just accepted anything with the right method names
12:20:43 <wli> ddarius: I guess the Utrecht bits might help with ideas on how to get things past the type system.
12:20:49 <DRMacIver> oerjan: Well, the comprehension stuff is very specialised to iterables.
12:21:23 <Cale> koala_man: map f . scanl (flip (:)) []
12:21:27 <oerjan> DRMacIver: it is? i may have misunderstood it then.
12:21:39 <Cale> > scanl (flip (:)) [] [1..10]
12:21:41 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[8...
12:21:58 <DRMacIver> oerjan: Possibly I have. But certainly my impression of it is that it's specifically designed for iterator comprehensions rather than general purpose monadic code.
12:22:25 <wli> ddarius: Hmm, the Utrecht attribute grammar system seems to be parser generator -oriented, which doesn't help much.
12:23:17 <oerjan> DRMacIver: that is what the syntax is like, but recall that comprehensions are really just monadic sugar in disguise
12:23:31 <DRMacIver> Yeah, I know.
12:23:43 <oerjan> my first impression on seeing it was, anyhow, "wow! thinly disguised monads"
12:23:50 <DRMacIver> But recall that Haskell list comprehensions aren't just monadic sugar in disguise. :)
12:23:52 <Cale> koala_man: You can also stick a  take (n-1)  in there in order to limit the number of elements retained.
12:23:57 <DRMacIver> I think Scala's are the same.
12:24:10 <Cale> > scanl (flip (:) . take 2) [1..10]
12:24:12 <DRMacIver> But it's possible I've totally misunderstood.
12:24:13 <Cale> > scanl (flip (:) . take 2) [] [1..10]
12:24:13 <lambdabot>  <[Integer] -> [[Integer]]>
12:24:14 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2],[5,4,3],[6,5,4],[7,6,5],[8,7,6],[9,8,7],[10,9,8]]
12:24:24 <koala_man> Cale: oooh, thanks
12:24:52 <Tac-Tics> is there a good way to get a comprehensive list of types of a given class?
12:25:17 * oerjan goes to look it up
12:25:20 <Cale> Tac-Tics:  :info Ord
12:25:32 <Tac-Tics> is it really that simple?
12:25:33 <Tac-Tics> cool
12:26:13 <Tac-Tics> does info only search the current module list? or does it search all modules you have installed?
12:27:04 <shachaf> Tac-Tics: Only the current module list.
12:27:22 <shachaf> Tac-Tics: Lambdabot has a few modules loaded, maybe you can try that.
12:27:25 <shachaf> @instances Ord
12:27:26 <Tac-Tics> yeah
12:27:27 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
12:27:36 <allbery_b> lambdabot alsi has @instances-importing
12:27:51 <allbery_b> so you can import various modules and see how the list changes
12:29:18 <shachaf> Tac-Tics: Are you looking for something specific?
12:29:47 <Tac-Tics> yes and no
12:29:50 <oerjan> DRMacIver: "The precise meaning of generators and guards is defined by translation to invocations of four methods: map, filter, flatMap, and foreach. These methods can be implemented in different ways for different carrier types."
12:29:52 <Tac-Tics> Looking around at MonadPlus
12:30:17 <DRMacIver> Hm
12:30:22 <DRMacIver> oerjan: I stand corrected.
12:30:28 <DRMacIver> oerjan: Thanks.
12:30:29 <Tac-Tics> and trying to figure out what guard does exactly
12:30:38 <Tac-Tics> with different types
12:30:50 <DRMacIver> Those are more useful than I thought then.
12:31:03 <allbery_b> @src guard
12:31:04 <lambdabot> guard True  =  return ()
12:31:04 <lambdabot> guard False =  mzero
12:32:18 <allbery_b> so, it does nothing when the condition is true, and immediately returns the monad's "zero" (which generally shortcircuits out of the current computation) when it's false
12:33:12 <Tac-Tics> LB told me that IO is a MonadPlus, but mzero :: IO () gives me an error
12:33:22 <allbery_b> not last I checked t wasn't
12:33:29 <allbery_b> @instances MonadPlus
12:33:30 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:33:38 <allbery_b> hm, but that says it is.  odd
12:33:40 <ddarius> @src IO mzero
12:33:41 <lambdabot> mzero       = ioError (userError "mzero")
12:34:01 <allbery_b> every time I use guard in IO I get a type error
12:34:02 <ddarius> allbery_b: Any library could make IO an instance of MonadPlus.
12:34:18 <oerjan> Tac-Tics: it's _supposed_ to be an error, but not a type one of course
12:34:35 <oerjan> > do print "hi"; mzero
12:34:36 <lambdabot>  Add a type signature
12:34:43 <allbery_b> (don't think I've tried it since 6.6 though; maybe it was added in 6.6.1)
12:35:00 <oerjan> > do print "hi"; guard True
12:35:02 <lambdabot>  <IO ()>
12:35:14 <Tac-Tics> Each Monad function is like a mystery to be solved. You can have the definition in front of you, but you don't know what it means for a given Monad until you try it out.
12:35:54 <ddarius> Tac-Tics: They behave fairly uniformly.
12:35:56 <Tac-Tics> IO isn't a MonadPlus on ghc, but it is for lambdabot it seems
12:36:31 <Tac-Tics> ddarius: not until you "get" it though. and I haven't yet =-P
12:37:05 <ddarius> Tac-Tics: Ideally we want mzero >>= f = mzero.
12:37:16 <ddarius> That gives a feel for what it does in all cases.
12:37:42 <Cale> There's a rather cheap way to make IO into a "MonadPlus" by having mzero throw an exception and mplus catch it.
12:37:54 <Cale> But it's really a "MonadOrElse"
12:37:55 <oerjan> @src IO mplus
12:37:56 <lambdabot> m `mplus` n = m `catch` \_ -> n
12:38:05 <oerjan> which is exactly what this does
12:38:05 <Cale> (kind of like Maybe)
12:38:07 <EvilTerran> ... that's dodgey
12:38:20 <shachaf> @src IO mzero
12:38:20 <lambdabot> mzero       = ioError (userError "mzero")
12:38:46 <allbery_b> hm, my (old) HEAD doesn't have IO MonadPlus either
12:38:52 <EvilTerran> Tac-Tics, have you met sequence?
12:39:04 <allbery_b> (and darcs bombs updating, have to flush and restart again I guess)
12:39:06 <EvilTerran> > sequence ["abc","def"]
12:39:07 <lambdabot>  ["ad","ae","af","bd","be","bf","cd","ce","cf"]
12:39:09 <oerjan> must be in some module
12:39:14 <Tac-Tics> I used it once I think when I wanted to make some IO code shorter
12:39:32 <EvilTerran> there's one to work out ;]
12:39:34 <Tac-Tics> When I looked at hogl, I didn't want to write vertex3f a million times
12:39:52 <Tac-Tics> @src sequence
12:39:53 <lambdabot> sequence ms = foldr k (return []) ms
12:39:53 <lambdabot>     where
12:39:53 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:40:06 <Cale> That's a terrible definition
12:40:12 <Cale> sequence [] = return []
12:40:22 <Tac-Tics> > sequence []
12:40:23 <lambdabot>   add an instance declaration for (Show (m [a]))
12:40:27 <Tac-Tics> err
12:40:30 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
12:40:46 <Cale> or:  sequence = foldr (liftM2 (:)) (return [])
12:41:11 <shachaf> ~\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\....................................................................................................................................................................]
12:41:17 <shachaf> \\+
12:41:19 <shachaf> Oops.
12:41:24 <allbery_b> cat on keyboard alert
12:41:32 <Tac-Tics> is sequence on List the cartesian product?
12:41:32 <shachaf> allbery_b: Exactly. :-)
12:41:38 <shachaf> Tac-Tics: Yes.
12:41:42 <ari> shachaf: That's almost like fix show
12:41:44 <ari> > fix show
12:41:45 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:41:49 <Tac-Tics> it's always something rediculously simple like that
12:41:59 <shachaf> > filter (=='"') . fix $ show
12:41:59 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
12:42:08 <EvilTerran> CAT-LIKE TYPING DETECTED
12:42:37 <EvilTerran> (http://icanhascheezburger.com/2007/05/15/cat-like-typing-detected/)
12:42:38 * SamB wishes GHCi would respect ^C in the middle of a line
12:42:40 <lambdabot> Title: I CAN HAS CHEEZBURGER? ª Blog Archive CAT-LIKE TYPING DETECTED ´, http://tinyurl.com/3yy6b6
12:42:48 <Tac-Tics> if you had two lambdabots in the same channel, it would be fun to try and get them to talk to each other
12:42:50 <SamB> (sooner)
12:43:05 <Tac-Tics> SamB: I agree
12:43:16 <shachaf> Tac-Tics: Well, sorear's done that, I think.
12:43:21 <shachaf> Tac-Tics: With lambdabot and mbot.
12:43:27 <shachaf> Tac-Tics: Using ?where.
12:43:42 <Tac-Tics> ?where
12:43:43 <lambdabot>  @where <key>, return element associated with key
12:43:50 <sorear> ?where poke
12:43:51 <lambdabot> I know nothing about poke.
12:43:53 <sorear> ?where ping
12:43:53 <lambdabot> :(
12:43:58 <Tac-Tics> ?where are my pants?
12:43:59 <lambdabot> I know nothing about are.
12:44:00 <sorear> ?where prod
12:44:00 <lambdabot> I know nothing about prod.
12:44:02 <Tac-Tics> hehe
12:44:03 <sorear> ?where ?where
12:44:03 <lambdabot> I know nothing about ?where.
12:44:05 <Tac-Tics> ?where pants
12:44:05 <lambdabot> I know nothing about pants.
12:44:09 <Tac-Tics> awesome
12:44:10 <shachaf> > filter (/='\"') (fix show)
12:44:15 <lambdabot>  "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
12:44:15 <sorear> oh good, looks like it was feleted
12:44:30 <Tac-Tics> @type fix
12:44:32 <lambdabot> forall a. (a -> a) -> a
12:44:51 <shachaf> @src fix
12:44:51 <lambdabot> fix f = let x = f x in x
12:44:55 <shachaf> fix f = f (fix f)
12:45:10 <Tac-Tics> ah
12:45:11 <sfultong> fellated?
12:45:15 <Tac-Tics> it's called like what it is
12:45:59 * sorear switches qhc to use an Applicative structure for typechecking.  no more monads!
12:46:30 <sjanssen> neat
12:46:45 <EvilTerran> Tac-Tics, fix is the Y combinator, if that helps
12:46:48 <wli> Oh dear, what's an Applicative?
12:46:54 <Tac-Tics> EvilTerran: yeah I gathered that
12:47:08 <sjanssen> wli: something between Functor and Monad
12:47:22 <sjanssen> wli: they support 'return' and 'ap'
12:47:45 <Radek> Hi. I'm very fresh to Haskell and I'm trying to write very very simple application using Glade and Gtk2Hs. Simply. When hitting button, label should show value of my funtion sqare. square :: Int -> Int \ square x = x * x. I cannot make it work. My button handler code is: onClicked button do $ \ value <- square 2 \ label <-  xmlGetWidget lohaXml castToLabel "label" \labelSetText label ( value )
12:48:14 <Radek> can anybody help me with this?
12:48:31 <wli> sjanssen: I wonder what you call something that supports join but not return.
12:48:39 <sorear> Radek: you need more parens.  2 \ label ... is a syntax errror, 2 (\ label ...) should work
12:48:40 <desp> @paste
12:48:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:48:53 <shachaf> sorear: Radek is using '\\' for '\n'.
12:49:05 <Tac-Tics> does lambda bot support variable bindings at all?
12:49:06 <EvilTerran> Radek, try "let value = square 2" rather than "value <- square 2"
12:49:08 <Radek> sorear: I used '\' to indicate line break
12:49:20 <EvilTerran> also
12:49:22 <EvilTerran> @tutorial
12:49:22 <shachaf> Radek: Try moving the $ to the left of the do?
12:49:22 <lambdabot> Unknown command, try @list
12:49:24 <sorear> Radek: oh, sorry
12:49:26 <EvilTerran> @where tutorial
12:49:27 <lambdabot> http://www.haskell.org/tutorial/
12:49:29 <Radek> indentation/syntax is not a problem (I think).
12:49:47 <Radek> it fails with Couldn't match expected type `IO t' against inferred type `Int'
12:50:00 <desp> Radek: it is a problem; use EvilTerran's suggestion
12:50:12 <shachaf> @paste You can usually use hpaste for multi-line code, by the way.
12:50:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:50:47 <desp> Radek: also, I recommend http://en.wikibooks.org/wiki/Haskell
12:50:49 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
12:51:04 <Tac-Tics> > let x = 4
12:51:04 <lambdabot>  Parse error
12:51:08 <Tac-Tics> aww
12:51:11 <shachaf> > let x = 4 in x
12:51:12 <EvilTerran> <- extracts a value from the monadic action on its right; "let ... =" assigns the value directly
12:51:13 <lambdabot>  4
12:51:16 <EvilTerran> @let x = 4
12:51:18 <lambdabot> Defined.
12:51:20 <EvilTerran> > x
12:51:21 <lambdabot>  4
12:51:24 <Tac-Tics> oh!
12:51:25 <EvilTerran> @undef x
12:51:27 <shachaf> > do { let x = 4; return x } :: [Int]
12:51:27 <lambdabot> Undefined.
12:51:28 <Tac-Tics> hurray
12:51:28 <lambdabot>  Parse error
12:51:34 <Tac-Tics> are those bindings per user?
12:51:41 <shachaf> EvilTerran: @undefine doesn't work that way.
12:51:45 <EvilTerran> > x
12:51:46 <lambdabot>   Not in scope: `x'
12:51:49 <shachaf> EvilTerran: It removes all the definitions.
12:51:54 <EvilTerran> hmm?
12:52:00 <EvilTerran> @help undef
12:52:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:52:11 <shachaf> @help undefine
12:52:12 <lambdabot> undefine. Reset evaluator local bindings
12:52:27 <EvilTerran> ah. okay. hope no-one had anything important in there ;]
12:52:38 <Radek> Thanks! It works now.. Thank you very much.
12:52:55 <desp> I always store my most valuable code on lambdabot
12:52:59 <Tac-Tics> @let fa f x = if x == 0 then 1 else x * f(x-1)
12:52:59 <EvilTerran> seems to me @reset would be a better name than @undefine in that case, but okay.
12:53:01 <lambdabot> Defined.
12:53:08 <Tac-Tics> @let fact = fix fa
12:53:11 <lambdabot> Defined.
12:53:14 <Tac-Tics> > fact 0
12:53:15 <lambdabot>  1
12:53:20 <Tac-Tics> > fact 5
12:53:21 <lambdabot>  120
12:53:24 <Tac-Tics> neat
12:53:43 <shachaf> @let fox = fix
12:53:45 <lambdabot> Defined.
12:54:16 <oerjan> @reset
12:54:17 <lambdabot> Unknown command, try @list
12:54:35 <EvilTerran> > fix $ (1:) . (1:) . (zipWith (+) =<< tail)
12:54:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:56:09 <desp> anyone playing with projecteuler?
12:56:11 <EvilTerran> hm. that (=<<)'s operating in (->)e, right?
12:56:25 <shachaf> EvilTerran: It looks that way.
12:56:25 <EvilTerran> ?type zipWith (+) =<< tail
12:56:27 <lambdabot> forall a. (Num a) => [a] -> [a]
12:56:42 <EvilTerran> @src (->) =<<
12:56:42 <lambdabot> Source not found. My pet ferret can type better than you!
12:56:51 <shachaf> @src (-.) =>>
12:56:52 <lambdabot> Source not found. Wrong!  You cheating scum!
12:56:54 <shachaf> @src (-.) >>=
12:56:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:57:03 <shachaf> @src (->) (>>=)
12:57:03 <lambdabot> f >>= k = \ r -> k (f r) r
12:57:08 <EvilTerran> ah. thanks.
12:57:59 <EvilTerran> so f =<< g = join (f . g)
12:58:16 <EvilTerran> i'll remember that for future horrible obfuscation ;D
12:58:19 <shachaf> (=<<) :: (a -> e -> b) -> (e -> a) -> e -> b
12:58:59 <Tac-Tics> is there an implementation of Haskell written in Haskell?
12:59:05 <shachaf> Tac-Tics: GHC.
12:59:13 <Tac-Tics> for seriously?
12:59:16 <Tac-Tics> cool
12:59:17 <EvilTerran> > fix $ (1:) . (1:) . join (zipWith (+) . tail)
12:59:19 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:59:33 <Tac-Tics> fixpoint languages are cool
13:00:43 <EvilTerran> hehe... from wikipedia: Y = (L L L L L L L L L L L L L L L L L L L L L L L L L L); L = \abcdefghijklmnopqstuvwxyzr -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
13:01:03 <Tac-Tics> yeah
13:01:34 <Tac-Tics> I wonder if you can do that for any language
13:02:10 <shachaf> Tac-Tics: Do what?
13:02:22 <Tac-Tics> write a Y combinator with an embeded sentence
13:02:44 <sebell> Hi all, is it possible to do a GHC 6.6.1/6.7 build with static GMP on Mac OS X Intel?
13:02:59 <shachaf> Tac-Tics: You can't write fix the "standard" way in Haskell without explicit recursion, by the way (as far as I know).
13:03:07 <shachaf> (Or can you?)
13:03:19 <EvilTerran> @let l = a b c d e f g h i j k _ m n o p q s t u v w x y z r = (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
13:03:19 <lambdabot>  Parse error in expression
13:03:23 <Tac-Tics> yeah, I found that out. It's kinda sad
13:03:44 <EvilTerran> @let l a b c d e f g h i j k _ m n o p q s t u v w x y z r = (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
13:03:45 <lambdabot> <local>:4:60:     Occurs check: cannot construct the infinite type:       t  ...
13:03:53 <SamB> @pl fix f = let x = f x in x
13:03:53 <lambdabot> fix = fix id
13:03:56 <SamB> hmm.
13:04:00 <Tac-Tics> why does the lambda based fix fail on an infinite type while the recursive version doesn't?
13:04:17 <SamB> @let fix f = let x = f x in x
13:04:17 <lambdabot> <local>:2:7:     Ambiguous occurrence `fix'     It could refer to either `fix...
13:04:22 <shachaf> @pl q f = let x = f x in x
13:04:22 <lambdabot> q = fix
13:04:29 <SamB> @let fix' f = let x = f x in x
13:04:31 <sorear> Tac-Tics: Because Haskell's core (non-recursive) type system was designed to make infinite loops impossible.
13:04:31 <lambdabot> Defined.
13:04:36 <SamB> > fix' id
13:04:37 <lambdabot>  Exception: <<loop>>
13:04:55 <sorear> Tac-Tics: It's not possible using only lambdas to write a well-typed non-terminating program.
13:05:09 <EvilTerran> @let y = \f -> (\x -> f x x) (\x -> f x x)
13:05:09 <lambdabot> <local>:5:31:     Occurs check: cannot construct the infinite type: t = t -> ...
13:05:28 <EvilTerran> ah. it's a typing thing.
13:05:31 <shachaf> > fix' haskell
13:05:32 <lambdabot>  "haskell'"
13:05:40 <Tac-Tics> sorear: I bed to differ
13:05:44 <Tac-Tics> > cycle ["infinite", "loops"]
13:05:45 <lambdabot>  ["infinite","loops","infinite","loops","infinite","loops","infinite","loops"...
13:05:54 <EvilTerran> > haskell
13:05:55 <lambdabot>  Add a type signature
13:06:01 <shachaf> Tac-Tics: That's using more than lambdas.
13:06:02 <EvilTerran> ?type haskell
13:06:03 <shachaf> @src cycle
13:06:04 <lambdabot> Not in scope: `haskell'
13:06:04 <lambdabot> cycle [] = undefined
13:06:04 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:06:06 <Tac-Tics> > tail $ cycle ["infinite", "loops"]
13:06:08 <lambdabot>  ["loops","infinite","loops","infinite","loops","infinite","loops","infinite"...
13:06:08 <Tac-Tics> hehe
13:06:33 <sorear> What shachaf said.
13:06:46 <EvilTerran> the difficulty is recursive bindings
13:07:10 <EvilTerran> (including explicit recursive calls)
13:07:39 <Tac-Tics> what is the function to return the last elemnt of a list again?
13:07:47 <sorear> last
13:07:49 <Tac-Tics> ah
13:08:04 <Tac-Tics> sometimes you ask questions which contain the answer to themselves
13:08:06 <oerjan> how completely cryptic and unintuitive :D
13:08:30 <Tac-Tics> I remembered init was the counterpart to tail
13:09:02 <EvilTerran> > let { factors n = filter ((0==).(n`mod`)) [1..n-1]; perfect n = sum (factors n) == n } in filter perfect [1,3..]
13:09:06 <lambdabot> Terminated
13:09:17 <EvilTerran> > let { factors n = filter ((0==).(n`mod`)) [1..n-1]; perfect n = sum (factors n) == n } in filter perfect [2,4..]
13:09:21 <sorear> Haskell's core type system (no data types, classes, or recursive bindings) is equivilent to Œª‚Üí, which has been proven incapable of expressing infinite loops.  (adding the first or third is sufficient to break this)
13:09:24 <lambdabot> Terminated
13:09:26 <shachaf> > last [last] [first] (+1) (last [id &&& id] 1)
13:09:28 <lambdabot>  (2,1)
13:10:04 <sorear> GHC's rankN polymorphism gives us the power of the second order polymorphic system F2.
13:10:08 <EvilTerran> hm
13:10:24 <Tac-Tics> I think haskell was invented for the sole purpose that each well-known function could be arbitrarily obfuscated to the coder's satisfaction
13:10:42 <shachaf> @go haskell obfuscation contest
13:10:44 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
13:10:44 <lambdabot> Title: Obfuscation - HaskellWiki
13:11:19 <sorear> Haskell can *not* currently express programs in Barendregt's Œªœâ
13:12:47 <oerjan> @remember Tac-Tics I think haskell was invented for the sole purpose that each well-known function could be arbitrarily obfuscated to the coder's satisfaction
13:12:48 <lambdabot> Done.
13:13:12 <sieni> <3
13:13:14 <Tac-Tics> heh
13:13:23 <Tac-Tics> random syntax question
13:13:27 <Tac-Tics> is there a reason why this doesn't work?
13:13:30 <Tac-Tics> > x where x = 5
13:13:31 <lambdabot>  Parse error
13:13:37 <Tac-Tics> > x where {x = 5}
13:13:37 <lambdabot>  Parse error
13:13:43 <Tac-Tics> how do you use where on a single line?
13:13:47 <sorear> Tac-Tics: where is only valid in declaration right-hand sides
13:13:55 <sorear> Tac-Tics: the corresponding expression form is let
13:14:00 <sorear> > let {x = 5} in x
13:14:02 <lambdabot>  5
13:14:15 <chessguy> > let x = 5 in x
13:14:16 <lambdabot>  5
13:14:17 <oerjan> Tac-Tics: that works in Hugs but not in ghc
13:14:23 <Tac-Tics> @let y = x where x = 5
13:14:25 <lambdabot> Defined.
13:14:28 <Tac-Tics> y
13:14:29 <Tac-Tics> >y
13:14:34 <Tac-Tics> > y
13:14:36 <lambdabot>  5
13:14:40 <Tac-Tics> there we go
13:14:45 <Tac-Tics> thanks, oerjan
13:14:49 <Saizan> > ler y = x where x = 5 in y
13:14:49 <lambdabot>  Parse error
13:14:52 <sorear> It works in Hugs because it is valid syntax in Gofer.  They probably just forgot to remove it, being C and all ;)
13:14:59 <shachaf> > let { y = x where { x = 5 } } in y
13:15:00 <Saizan> > let y = x where x = 5 in y
13:15:01 <lambdabot>  5
13:15:03 <lambdabot>  5
13:15:40 <oerjan> i thought it was just an interactive convenience (which it is)
13:16:03 <Cale> Hugs.Base> (x where x = 5)
13:16:03 <Cale> ERROR - Syntax error in expression (unexpected keyword "where")
13:16:06 <Cale> yes.
13:16:06 <chessguy> @unlet y
13:16:06 <lambdabot>  Parse error
13:16:12 <chessguy> @delete y
13:16:12 <lambdabot> y
13:16:22 <shachaf> chessguy: No, @undefine doesn't work that way.
13:16:26 <Tac-Tics> Is there a command for LB to query all let bindings?
13:16:29 <shachaf> @help undefine
13:16:29 <lambdabot> undefine. Reset evaluator local bindings
13:16:38 <chessguy> hm, i think it used to
13:16:39 <shachaf> chessguy: You can remove just one binding
13:16:44 <chessguy> > y
13:16:46 <lambdabot>  5
13:16:51 <chessguy> @undefine
13:16:53 <lambdabot> Undefined.
13:16:56 <chessguy> > y
13:16:57 <lambdabot>   Not in scope: `y'
13:17:04 <shachaf> > fix' haskell
13:17:05 <lambdabot>   Not in scope: `haskell'
13:17:32 <EvilTerran> @let x = 1
13:17:34 <lambdabot> Defined.
13:17:37 <EvilTerran> @let x
13:17:38 <lambdabot>  Parse error
13:17:44 <EvilTerran> @let x = undefined -- ;]
13:17:45 <lambdabot> <local>:2:0:     Multiple declarations of `L.x'     Declared at: <local>:1:0 ...
13:17:49 <EvilTerran> damnit.
13:18:13 <sorear> @unlet
13:18:15 <lambdabot> Defined.
13:18:15 <sorear> @undefine
13:18:17 <lambdabot> Undefined.
13:18:20 <Tac-Tics> Syntax Error in file #haskell
13:26:47 <Tac-Tics> does anyone have any books on haskell?
13:26:58 <Tac-Tics> I'm looking at the list of textbooks on Haskell.org
13:27:03 <Tac-Tics> but does anyone here actually own any of them?
13:27:51 <sfultong> I have The Haskell School of Expression: Learning Functional Programming Through Multimedia
13:28:08 <sfultong> it's not very introductory, despite the title
13:28:14 <EvilTerran> i've read the Bird book -- it seems good, not that i have anything to compare it to
13:28:29 <chessguy> Tac-Tics, i have several of them
13:28:58 <Tac-Tics> chessguy: which do you like the best
13:29:22 <Tac-Tics> sfultong, evilterran: how do you like the ones you have?
13:29:26 <EvilTerran> "Richard Bird -- Introduction to Functional Programming using Haskell", that is. he suggested it himself, being my functional programming lecturer ;]
13:29:27 <chessguy> i have "The Haskell Road...", "Programming in Haskell", "HSOE", and "TAPL"
13:29:44 <chessguy> Tac-Tics, i don't know, they're all different
13:30:34 <sfultong> I have found it somewhat helpful, but... it doesn't really seem written to my style of learning
13:30:36 <EvilTerran> i've used Bird mainly as a textbook, so my experiences won't necessarily be that helpful, either.
13:31:00 <Heffalump> I think it's the only Haskell book I've ever actually read.
13:31:07 <pejo> EvilTerran, having the author as a lecturer helps somewhat too.
13:31:15 <sfultong> although, it did help me understand lazy evaluation to the point of getting corecursion for the first time
13:31:54 <chessguy> @where bird
13:31:54 <lambdabot> I know nothing about bird.
13:31:58 <chessguy> @where books
13:31:58 <lambdabot> I know nothing about books.
13:32:02 <Tac-Tics> hah
13:32:02 * chessguy sighs
13:32:33 <chessguy> @go bird Introduction to Functional Programming using Haskell
13:32:35 <lambdabot> http://web.comlab.ox.ac.uk/oucl/publications/books/functional/
13:32:35 <lambdabot> Title: Introduction to Functional Programming
13:33:10 <chessguy> @where+ bird http://vig.prenhall.com/catalog/academic/product/1,4096,0134843460,00.html
13:33:10 <lambdabot> Done.
13:33:22 <EvilTerran> pejo, that's true.
13:33:55 <sfultong> @where bot
13:33:55 <lambdabot> I know nothing about bot.
13:34:03 <sfultong> @where life
13:34:03 <lambdabot> I know nothing about life.
13:34:15 <sjanssen> what sort of brackets/bracket combinations are unused in Haskell?  I'm thinking about idiom brackets
13:34:27 <sjanssen> is [{ }] available?
13:35:14 <ibid> sjanssen: what do you mean by idiom brackets?
13:35:21 <ibid> sjanssen: { } are used in the syntax
13:35:38 <shachaf> ibid: [{ f x y z }] -> f <$> x <*>y <*> z -- sjanssen: Yes?
13:35:44 <sjanssen> ibid: are you familiar with 'return'/'ap' style?
13:36:03 <ibid> sjanssen: not by that name, but i might recognise it if i see it
13:36:07 <sjanssen> return (+) `ap` readLn `ap` readLn -- for example
13:36:21 <sjanssen> or see shachaf's example
13:36:26 <ibid> sjanssen: i can probably read that, yes :)
13:36:31 <ibid> sjanssen: not used it much
13:36:49 <shachaf> sjanssen: Why not (+) `fmap` readLn `fmap` readLn?
13:37:17 <shachaf> sjanssen: (Or liftM. The return makes it much harder to read, for me.)
13:37:29 <sjanssen> @type (+) `fmap` readLn `fmap` readLn
13:37:31 <lambdabot>     Couldn't match expected type `a -> a1'
13:37:31 <lambdabot>            against inferred type `IO a2'
13:37:37 <xerox> ap
13:37:43 <xerox> the second one
13:37:44 <sjanssen> shachaf: it doesn't type
13:37:55 <shachaf> Oops, I meant ap.
13:38:00 <shachaf> sjanssen: Why not (+) `fmap` readLn `ap` readLn?
13:38:07 <shachaf> Sorry, I mistyped. :-)
13:38:09 <sjanssen> that's fine too
13:38:16 <sjanssen> anyway, idiom brackets avoid this alltogether
13:38:35 <sjanssen> we might write [{ (+) readLn readLn }]
13:38:36 <ibid> sjanssen: can you please tell me what idiom brackets are :)
13:38:44 <shachaf> sjanssen: I think it would be nicer than the (<- ...) cdsmith wants to implement.
13:38:55 <wli> Okay, the project SamB told me to work on is too hellish.
13:38:55 <Syzygy-> sjanssen: Is this the XXXmorphism things?
13:38:55 <shachaf> ibid: [{ f x y z }] -> f <$> x <*>y <*> z -- sjanssen: Yes?
13:39:12 <ibid> is that supposed to be a genuine syntax extension?
13:39:23 <sjanssen> ibid: just a simple desugaring from " [{ f a_0 ... a_n }]" to "return f `ap` a_0 ... `ap` a_n"
13:39:37 <shachaf> It can be implemented without a syntax extension too, right? There was the iI/Ii thing.
13:39:51 <sjanssen> Syzygy-: I don't know
13:39:53 <shachaf> Though having its own syntax is nicer.
13:39:58 <sjanssen> shachaf: but it's ugly
13:40:00 <ibid> sjanssen: ok. note that {} is reserved syntax :)
13:40:09 <SamB_XP_> wli: the CAS?
13:40:10 <shachaf> sjanssen: Exactly.
13:40:11 <ibid> sjanssen: and thus requires syntax modifications
13:40:18 <sjanssen> ibid: yes, I know
13:40:30 <wli> SamB_XP: How many hostmasks do you have, anyway?
13:40:31 <sjanssen> the shape of the brackets doesn't matter
13:40:32 <ibid> sjanssen: that's what i was getting at the whole time :)
13:40:47 <wli> Well, I'll talk momentarily.
13:40:56 <shachaf> Would [<>] work?
13:41:00 <shachaf> @ty [<5]
13:41:02 <lambdabot> forall a. (Num a, Ord a) => [a -> Bool]
13:41:05 <shachaf> I guess not.
13:41:28 <shachaf> We need more shapes!
13:41:30 <oerjan> what?
13:41:40 <sjanssen> > [{ 3 }]
13:41:41 <lambdabot>  Parse error
13:41:44 <oerjan> [<5] cannot be right
13:42:00 <sjanssen> I think [{ might be available
13:42:02 <sjanssen> sorear: do you know?
13:42:13 <EvilTerran> ?type [<5,3>]
13:42:15 <lambdabot> parse error on input `]'
13:42:35 <wli> SamB_XP: The parsing needs to be quasi- natural language -ish to deal with math newbies not being having the foggiest idea how to rigorously format their input.
13:42:47 <SamB_XP_> wli: oh.
13:42:55 <SamB_XP_> I hadn't thought of that
13:43:08 <sjanssen> shachaf: regardless of the syntax, I agree that idiom brackets seem much more promising
13:43:39 <wli> SamB_XP: So multiplication by juxtaposition (and hence ambiguity) need handling, as well as subtleties that are rather contorted even in LR parsers involving exponent precedence.
13:44:01 <sjanssen> I also propose that "[{ do f a b }]" desugars to "join (return f `ap` a `ap` b)"
13:44:10 <shachaf> sjanssen: I wasn't sure about the (<-) (or a different syntax) before, but after reading some of the arguments on that thread I don't think I'm for it.
13:44:25 <wli> SamB_XP: Specifically the precedences on the left and right sides differ.
13:44:29 <sjanssen> because I think the explicit joins muddy it up a bit
13:44:51 <sorear> sjanssen: { is only legal following do, let, of, where, beginningoffile, and conid.
13:44:58 <wli> SamB_XP: In addition handling nasties like 2^-3
13:45:18 * sorear notices that it's rather hard to tell the difference betewwn literal '{' and EBNF's { in the Report
13:45:35 <shachaf> sjanssen: How would you use the join?
13:45:45 <wli> SamB_XP: I've done this in Mercury before, where it was not quite so difficult.
13:45:47 <sjanssen> shachaf: I really don't want to explain to a newbie why "if nullPtr p then 0 else (<- peek p)" crashes
13:46:06 <wli> SamB_XP: There, the backtracking built into the language saved my arse.
13:46:10 <sjanssen> shachaf: you need a join when you're applying a function that's already monadic in an idiom bracket
13:46:23 <sorear> wli: You can do that easily in Haskell too.
13:46:25 <sorear> @src Read
13:46:25 <lambdabot> class Read a where
13:46:26 <lambdabot>   readsPrec    :: Int -> ReadS a
13:46:26 <lambdabot>   readList     :: ReadS [a]
13:46:26 <lambdabot>   readPrec     :: ReadPrec a
13:46:26 <lambdabot>   readListPrec :: ReadPrec [a]
13:46:32 <EvilTerran> ... is this happening on cafe?
13:46:51 <sjanssen> sorear: do you see any other practical difficulties with [{ ?
13:47:02 <wli> sorear: I sure hope you're not suggesting Read is remotely relevant to all this.
13:47:17 <sorear> sjanssen: no, other than it slowly fills up token space
13:47:30 <sorear> wli: Read not per se.  ReadS
13:47:35 <sjanssen> @type return putStrLn `ap` getLine
13:47:37 <lambdabot> IO (IO ())
13:47:37 <SamB_XP_> maybe Haskerl isn't very far off?
13:47:41 <EvilTerran> @where cafe
13:47:41 <lambdabot> I know nothing about cafe.
13:47:48 <wli> SamB_XP: The extensibility comes in because it's extremely flaky and needs a great deal of adjustments.
13:48:04 <sjanssen> @type join (return putStrLn `ap` getLine) -- see what I mean, shachaf?
13:48:05 <lambdabot> IO ()
13:48:09 <wli> SamB_XP: Even the Mercury code I wrote before has lingering corner cases.
13:48:13 <sorear> sjanssen: you don't want the join; idiom brackets use a pure first function
13:48:27 <sorear> sjanssen: eg [[(:) x xs]] from the paper
13:48:38 <sjanssen> sorear: yes, but it's convenient to use this syntax with monadic functions too
13:48:45 <shachaf> sjanssen: OK, I see, but I'm not sure [{ do ... }] would be the best syntax for that.
13:49:01 <sjanssen> shachaf: perhaps not
13:49:04 <shachaf> sjanssen: Since do has another meaning, generally.
13:49:16 <xerox> sjanssen: last yeat ag anglohaskell liyang has given a talk on idiom brackets, maybe he could share some thoughts.
13:49:30 <sjanssen> I also like that we could have a cool syntax for return: [{ x }]
13:49:42 <monochrom> What is the Language.Haskell.Extension name for GADT? I.e., what to write in a LANGUAGE pragma?
13:49:51 <shachaf> sjanssen: If monad comprehensions were working, [x] could be return too. :-)
13:50:04 <sjanssen> true, true
13:50:05 <SamB_XP_> shachaf: I'm not sure that's desirable
13:50:13 <shachaf> SamB_XP_: Possibly not.
13:50:26 <wli> sorear: reads/ReadS have inappropriate operator precedence built in but maybe it can be ignored. I found, however, that the form of nondeterminism required involved splitting a list in the middle.
13:50:37 * SamB_XP_ was thinking that would be a list, and you'd need a | to make it a comprehension
13:50:56 <sjanssen> [ x |], perhaps?
13:50:57 <shachaf> SamB_XP_: I remember you said that. But [] for return is nice too. :-)
13:51:08 <shachaf> SamB_XP_: Or what sjanssen said.
13:51:12 <SamB_XP_> shachaf: what?
13:51:16 <SamB_XP_> [] for return?
13:51:23 <shachaf> SamB_XP_: [x] for (return x).
13:51:24 <shachaf> .
13:51:37 <SamB_XP_> that sounds like that corner case of the list-section proposal...
13:51:49 <wli> sorear: reads/ReadS only do nondeterminism involving as-of-yet-unconsumed input, basically allowing partial parses of prefixes instead of the interior.
13:52:55 <shachaf> SamB_XP_: It could usually be inferred that it's a list, I think.
13:53:18 <shachaf> > [1 |]
13:53:19 <lambdabot>  Parse error
13:53:28 <wli> sorear: I'm going over the old code to make sure it wasn't exclusively an artifact of left recursion in Prolog.
13:53:38 <shachaf> > [1 | True]
13:53:40 <lambdabot>  [1]
13:54:03 * SamB_XP_ was thinking of how it wasn't clear what "[]" ought to mean with list sections
13:54:05 <shachaf> Hmm, [x |] could work, if monad comprehensions did.
13:54:36 <SamB> speaking of monad comprehensions...
13:54:46 <sorear> SamB_XP_: it would be unambiguous if we used terminators!
13:54:48 <xerox> monochrom - It seems it should be GADTs <http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions> but it doesn'e exist in <http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html>.
13:54:48 <SamB> http://hackage.haskell.org/trac/ghc/ticket/1580
13:54:48 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions>
13:54:49 <lambdabot> Title: #1580 (Get GHC happy with alternate base packages (split base)) - GHC - Trac
13:55:05 <SamB> http://hackage.haskell.org/trac/ghc/wiki/BaseSplit
13:55:07 <lambdabot> Title: BaseSplit - GHC - Trac
13:56:25 <monochrom> thanks xerox
13:56:47 <xerox> you're welcome
13:57:43 <SamB> so anyone who wants monad comprehensions, look at those two pages (especially the wiki page)
13:59:08 <SamB> (and, like, add stuff)
13:59:30 <wli> sorear: I can't tell offhand if there's anything essential there relative to the earlier bison code. It's too big for an easy review.
14:02:09 <shachaf> sjanssen: Do you have any other ideas for the join?
14:02:39 <sjanssen> shachaf: not off the top of my head.  Do you?
14:03:31 <shachaf> sjanssen: Not yet. I just think do would be a bit odd, since normally do x = x.
14:03:37 <sjanssen> yeah
14:04:01 <shachaf> sjanssen: How do you think you'll handle [{ f (x y) z }]?
14:04:34 <sjanssen> shachaf: return f `ap` (x y) `ap` z
14:04:56 <sjanssen> you can have nested [{ brackets, if you want
14:06:02 <sjanssen> instead of [{ f m (return 1) }], [{ f m [{ 1 }] }]
14:06:48 <shachaf> sjanssen: What about infix operators? [{f $ x y }], for a simple example.
14:07:49 <sjanssen> shachaf: I think that should be interpreted as [{ ($) f x y }]
14:08:02 <HairyDude> hmm, ghci doesn't seem to like monadic 'let'
14:08:19 <sjanssen> or, return ($) `ap` f `ap` x `ap` y
14:08:24 <wli> It does, the syntax is different.
14:08:48 <HairyDude> > do x <- [1,2,3]; let x2 = x * 2; return x2
14:08:49 <lambdabot>  Parse error
14:08:50 <shachaf> sjanssen: Which is different from [{ f (x y) }]
14:08:58 <sjanssen> shachaf: right
14:09:09 <shachaf> sjanssen: OK. It seems a bit odd that what's inside the [{}] looks like normal Haskell syntax, but isn't, really.
14:09:12 <wli> Hairy: Use braces.
14:09:14 <HairyDude> > do { x <- [1,2,3]; let x2 = x * 2; return x2 }
14:09:15 <lambdabot>  Parse error
14:09:22 <sjanssen> oh, actually, it should be [{ ($) f (x y) }]
14:09:38 <shachaf> sjanssen: Oh, right.
14:09:45 <wli> > do { x <- [1,2,3]; let { x2 = x * 2 } ; return x2 }
14:09:45 <Igloo> > do x <- [1,2,3]; let {x2 = x * 2}; return x2
14:09:46 <lambdabot>  [2,4,6]
14:09:47 <lambdabot>  [2,4,6]
14:10:00 <oerjan> HairyDude: it thinks you are trying to redefine return inside the let, which therefore does not end
14:10:18 <HairyDude> ah
14:10:52 <shachaf> sjanssen: Which is still different?
14:10:55 * wli looks for polymorphic native Haskell linear algebra libs.
14:11:07 <Syzygy-> wli: Tell me when you found one.
14:11:20 <oerjan> actually it may have to decide already on the ;
14:11:22 <shachaf> sjanssen: id <$> f <*> (x y) doesn't return the f.
14:11:45 <sjanssen> shachaf: yes, it's different
14:12:02 <sjanssen> shachaf: IMO, this is only surprising for $, for operators like +, this is what we want
14:12:06 <shachaf> [{ id x }] /= [{ x }].... Of course, that's the whole point.
14:12:15 <shachaf> sjanssen: That's true.
14:12:25 <sjanssen> Haskellers tend to forget that $ isn't special syntax
14:12:29 <wli> Syzygy-: I'm examining candidates already to determine their suitability.
14:13:42 <shachaf> sjanssen: I sometimes wish it behaved a bit more like special syntax.
14:13:50 <shachaf> sjanssen: (Though I like the fact that it isn't, of course.)
14:14:00 <oerjan> shachaf: thinking of runST?
14:14:25 <shachaf> oerjan: For example. :-)
14:14:36 <shachaf> oerjan: And also, it doesn't work for types (of course).
14:14:48 <shachaf> Not that it's generally needed.
14:15:01 <oerjan> hm... it actually could, couldn't it?
14:15:17 <oerjan> type f $ a = f a _could_ work
14:15:36 <oerjan> er, except for "case" issues
14:15:42 <oerjan> (doesn't start with :)
14:17:33 <shachaf> oerjan: Hmm, it seems to work, actually (with :$, of course).
14:17:40 <sorear> shachaf: runST $ foo is perfectly sensible, it's just that GHC's implementation of impredicativity is crippled
14:17:55 <sorear> @go ML to the power of System F
14:17:57 <lambdabot> http://gallium.inria.fr/~remy/work/mlf/icfp.pdf
14:18:09 <sorear> those people have figured out how to do it.
14:18:11 <oerjan> also type declarations may not be of polymorphic kind may they?
14:18:45 <shachaf> oerjan: Except that it remembers the (:$) for too long, maybe.
14:19:00 <shachaf> Types don't really need ($), I think.
14:20:00 <wli> Syzygy-: Vectro has some Gaussian elimination that looks vaguely polymorphic, but not too much else and it looks like its focus is on GSL or otherwise C floating point library integration (this is all for working over algebraic number fields as I'm thinking of it).
14:20:25 <wli> Syzygy-: http://ofb.net/~frederik/vectro/
14:21:30 <Syzygy-> wli: For algebraic number fields, but alas without a current Haskell binding, you could always glance at Pari/GP...
14:23:23 <wli> Syzgy-: The symbolic breakdowns of the operations for calc101.com -like step-by-step printouts are vastly more important than speed.
14:24:05 <Syzygy-> wli: Ahhhhh.....
14:25:47 <wli> Syzygy-: You're on EfNet #math, aren't you?
14:26:39 <Syzygy-> Yeah.
14:26:44 <wli> Syzygy-: I've brought up this sort of thing before there.
14:26:57 <Syzygy-> I'm not always reading there.
14:40:40 <xerox> sorear: actually runST $ foo works in GHC HEAD.
14:41:44 <oerjan> Is there anything GHC HEAD doesn't do? :D
14:42:41 <HairyDude> (.) would be more handy for types than ($), I think
14:43:18 <wli> Also flip
14:43:59 <shachaf> HairyDude: Yes, I was actually thinking of (.) and flip, more than ($), but ($) reminded me.
14:45:05 <sorear> xerox: runST $ foo works, but (flip ($)) foo runST doesn't
14:45:23 <hpaste>  HairyDude pasted "type composition with a MPTC and associated type synonym" at http://hpaste.org/2084
14:45:28 <HairyDude> would that work?
14:46:01 <HairyDude> oh, except the name for the type synonym is wrong of course
14:46:13 <xerox> sorear: hehe, I got as far as |($) runST foo|, which works.
14:46:27 <shachaf> What does || do?
14:46:28 <monochrom> IIRC, impredicative polymorphism was introduced to permet runST $ foo.
14:46:34 <monochrom> s/permet/permit/
14:46:48 <hpaste>  HairyDude annotated "type composition with a MPTC and associated type synonym" with "better name" at http://hpaste.org/2084#a1
14:46:52 <glguy> monochrom: when was it introduced/
14:46:55 <monochrom> 6.6.1
14:47:11 <sorear> monochrom: In 6.6, you have to give an explicit type signature for that $.
14:47:24 <monochrom> Yeah.
14:47:51 <sorear> in MLF you can order it however you want, and it will work.  The *only* place type signatures are required by MLF is higher-rank lambda binders.
14:47:57 <sorear> eg, runST itself
14:50:16 <HairyDude> hmm. higher-order type synonyms might be a nice application for kind polymorphism :)
14:50:37 <HairyDude> I bet it would play merry hell with type inference though
14:51:47 <oerjan> not necessarily, since type synonyms are macros
14:52:19 <oerjan> i.e. they don't need to be inferred
14:58:07 <glguy> Is anyone here running Debian stable + ghc 6.6.1?
15:01:06 <shapr> @yow !
15:01:06 <lambdabot> On SECOND thought, maybe I'll heat up some BAKED BEANS and watch REGIS
15:01:07 <lambdabot> PHILBIN ...  It's GREAT to be ALIVE!!
15:01:21 <sorear> glguy: my sarge install is still at 6.6.0
15:01:38 <glguy> sarge is pre-etch?
15:01:55 <sorear> glguy: 3.1?
15:02:03 <sorear> glguy: oh right, they did bump stable...
15:02:07 * sorear forgot.
15:02:28 <glguy> I don't so much mind running old versions of most packages
15:02:35 <glguy> but I don't really want to run old haskell packages
15:04:37 <edwinb> Anyone using the latest hs-plugins with ghc 6.4.1 by any chance?
15:05:09 <sorear> edwinb: No.  They are incompatible.
15:05:13 <edwinb> curses
15:05:22 <edwinb> the README is out of date then...
15:05:45 <sorear> edwinb: when you say latest, do you mean darcs repo or hackage?
15:05:52 <edwinb> darcs
15:05:52 <sorear> darcs repo is 6.6.x only
15:06:09 <edwinb> I suppose it's time to upgrade then
15:06:30 <edwinb> that'd explain why it works quite happily on the machine I have ghc 6.6.1 on...
15:29:25 <Tac-Tics> @type sequence
15:29:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:29:28 <Tac-Tics> @type sequenceM
15:29:30 <lambdabot> Not in scope: `sequenceM'
15:30:29 <oerjan> what would you expect sequenceM to do?
15:31:11 <Tac-Tics> exist in scope? =-P
15:31:41 <shachaf> Tac-Tics: Why?
15:31:47 <oerjan> no, i mean, what is it, if different from sequence?
15:31:50 <Tac-Tics> I'm thinking of sequence_
15:31:54 <Tac-Tics> @type sequence_
15:31:55 <shachaf> Tac-Tics: Oh.
15:31:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:32:13 <oerjan> @hoogle (Monad m) => [m a] -> m ()
15:32:14 <lambdabot> Prelude.head :: [a] -> a
15:32:14 <lambdabot> Prelude.last :: [a] -> a
15:32:35 <hpaste>  Marc Weber pasted "printf and ambiguous type variable? signature is given" at http://hpaste.org/2085
15:32:47 <oerjan> probably that bug mentioned earlier today?
15:32:52 <oerjan> (in hoogle)
15:34:02 <shachaf> MarcWeber: Not related, but is Nix written in Haskell?
15:34:07 <sorear> MarcWeber: GHC can't know that the second argument to printf "...%s..." will be a string
15:34:25 <sorear> MarcWeber: You'll need to wrap *that* whole argument in (::String)
15:35:34 <MarcWeber> shachaf: No, C++
15:35:49 <MarcWeber> sorear: (s::String) isn't enough ?
15:36:13 <sorear> MarcWeber: I just said it is.
15:36:14 <sorear> 15:33 < sorear> MarcWeber: You'll need to wrap *that* whole argument in (::String)
15:36:33 <sorear> oh, s
15:36:33 <MarcWeber> sorear: printf "(%s)" (s::String) did result in the same error.
15:36:48 <sorear> No, s is fine.
15:36:54 <xerox> > printf "(%s)" "foo" :: String
15:36:56 <lambdabot>  "(foo)"
15:37:02 <sorear> MarcWeber: You'll need to wrap the outer argument in (::String) too
15:37:55 <Lemmih> MarcWeber: The result type of printf isn't necessarily a String.
15:37:56 <MarcWeber> sorear: Thanks. Sure. printf can return String or ... -> arg -> String
15:38:15 <oerjan> also it can return IO ()
15:39:31 <MarcWeber> . o O ( once again the problem wasn't ghc but the person using it :)
15:41:14 <oerjan> Exception: EBKAC Error
15:42:08 <xerox> ('P':)
15:43:41 <oerjan> that particular problem exists at google, which showed EBKAC first
15:43:44 <reffie> what does "this function is not refernetially transparent" mean
15:44:07 <shachaf> reffie: It can return different values when you call it multiple times.
15:44:18 <reffie> ah
15:44:34 <shachaf> reffie: A referentially transparent function will always use only its arguments to compute its return value.
15:44:45 <shachaf> reffie: Which one are you thinking of? unsafePerformIO?
15:45:14 <reffie> trace
15:45:28 <Binkley> yes, trace uses unsafePerformIO
15:45:34 <shachaf> reffie: Oh, the other one.
15:45:37 <reffie> what exactly is the point of unsafePerformIO?
15:45:47 <Binkley> reffie: it makes some things more conveniently
15:45:48 <shachaf> reffie: It can also mean that it performs side effects.
15:46:05 <Binkley> for example, GHC uses it to define mutable global variables that you can reference without being in the IO monad
15:46:11 <Binkley> that doesn't mean you should use it, though :-)
15:46:12 <xerox> reffie: it's mostly used for FFI purposes
15:46:17 <OceanSpray> I'm having trouble compiling my parser with parsec
15:46:18 <shachaf> reffie: I guess that's what I meant; trace does predictably return its second argument.
15:46:31 <OceanSpray> it says:     Failed to load interface for `Parsec':
15:46:41 <shachaf> OceanSpray: Text.ParserCombinators.Parsec?
15:46:45 <reffie> ?src trace
15:46:45 <lambdabot> trace string expr = unsafePerformIO $ do
15:46:46 <lambdabot>     hPutStrLn stderr string
15:46:46 <lambdabot>     return expr
15:46:49 <reffie> aha!
15:46:54 <reffie> everythng is explained
15:46:55 <xerox> OceanSpray: do you use -package parsec or --make?
15:47:00 <OceanSpray> -package
15:47:22 <xerox> And import Text. ... .Parsec?
15:47:25 <OceanSpray> yeah
15:47:57 <xerox> Do you have parsec installed? Does it come up in ghc-pkg list?
15:48:27 <OceanSpray> parsec-2.0
15:48:28 <OceanSpray> it's there
15:49:13 <Binkley> OceanSpray: can you paste your code and the error message?
15:49:15 <Binkley> @paste
15:49:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:49:25 <OceanSpray> sure
15:51:12 <hpaste>  OceanSpray pasted "screw.hs" at http://hpaste.org/2086
15:51:45 <Binkley> OceanSpray: there's your error, you wrote "Test.ParserCombinators..."
15:51:50 <Binkley> it should be "Text" instead of "Test"
15:51:56 <OceanSpray> oh whoops
15:52:12 <OceanSpray> ok... now it's giving me other errors
15:52:38 <OceanSpray> "not in scope: 'lexeme'" and similar
15:53:04 <OceanSpray> aren't those part of parsec?
15:53:05 <shachaf> @index lexeme
15:53:05 <lambdabot> Text.ParserCombinators.Parsec.Token
15:53:16 <Binkley> yeah, you may need to import that too
15:53:21 <OceanSpray> :\
15:54:14 <Tac-Tics> how does one write a section for the - operator?
15:54:18 <Tac-Tics> like (-3)?
15:54:19 <xerox> subtract
15:54:30 <Tac-Tics> (-3) is the literal value though, right?
15:54:45 <Tac-Tics> ah
15:54:49 <Tac-Tics> subtract the word
15:54:50 <Tac-Tics> heh
15:54:54 <Tac-Tics> @type subtract
15:54:56 <lambdabot> forall a. (Num a) => a -> a -> a
15:54:59 <Tac-Tics> yay
15:55:18 <shachaf> @pl \x -> x - 3 -- lambdabot can help!
15:55:18 <lambdabot> subtract 3
15:55:18 <oerjan> @src subtract
15:55:19 <lambdabot> subtract x y = y - x
15:55:46 <Tac-Tics> thanks
16:01:36 <OceanSpray> what exactly is num?
16:01:56 <oerjan> @src Num
16:01:56 <lambdabot> class  (Eq a, Show a) => Num a  where
16:01:57 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:01:57 <lambdabot>     negate, abs, signum     :: a -> a
16:01:57 <lambdabot>     fromInteger             :: Integer -> a
16:02:21 <oerjan> @instances Num
16:02:26 <lambdabot> Double, Float, Int, Integer
16:02:28 <hpaste>  OceanSpray annotated "screw.hs" with "screw.hs" at http://hpaste.org/2086#a1
16:03:01 <oerjan> @instances-importing Data.Complex Data.Ratio Num
16:03:02 <lambdabot> Complex a, Double, Float, Int, Integer, Ratio a
16:03:08 <OceanSpray> why can I do LispVal = Symbol String, but not | Number Num ?
16:03:30 <Tac-Tics> Num is a typle class, not a type
16:03:33 <oerjan> Num is not a type, it is a class of types
16:03:47 <OceanSpray> wha
16:03:55 <oerjan> in Haskell, those are very different things
16:04:11 <Tac-Tics> couldn't you do: Num a => data LispVal = .... | Number a?
16:04:30 <OceanSpray> Ah screw it
16:04:32 <Tac-Tics> (I need to brush up on my type syntax)
16:04:42 <OceanSpray> I'm sticking with Int for now
16:04:50 <Tac-Tics> yeah
16:04:50 <OceanSpray> oh great
16:04:53 <OceanSpray> more errors
16:04:55 <Binkley> OceanSpray: might want to use Integer unless you know you need Int for performance
16:04:57 <sorear> Tac-Tics: Yes you can, but it's a very bad idea.
16:05:09 <Tac-Tics> oh, sorear, teach me about this "very bad idea"
16:06:20 <sorear> Tac-Tics: If you existentially quantify over the type of number, the system will create separate warm fuzzy variables for each box you unpack, making arithmetic essentially impossible.  It won't break anything, but it will be insideously useless.
16:07:08 <Tac-Tics> Understanding is truly a heirarchy
16:07:44 <Tac-Tics> Tac ansews OceanSpray's question. He doesn't understand the answer. This brings to Tac's mind a question of his own. He asks sorear, but he does not understand sorear's anser
16:07:46 <Tac-Tics> ^^
16:08:02 <Binkley> And suddenly, the novice was enlightened.
16:08:34 <shachaf> sorear: "Warm fuzzy variables"?
16:08:40 <shachaf> sorear: Does this have to do with monads?
16:09:04 <sorear> shachaf: No, the proper technical term is Skolem constants in this case
16:11:25 <oerjan> Tac-Tics: and now it passes to shachaf :)
16:11:31 <OceanSpray> using parentheses eliminated most of the errors
16:11:37 <OceanSpray> but this one...
16:11:57 <Binkley> what, "warm fuzzy variable" isn't a proper technical term?
16:12:18 <oerjan> Binkley: sure it is
16:12:22 <shachaf> @quote fuzzy
16:12:22 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
16:12:35 <OceanSpray> screw.hs:44:26:    Couldn't match expected type `TokenParser st'           against inferred type `GenParser Char () LispVal'    In the first argument of `lexeme', namely        `(lispSym <|> (lispPair <|> (lispStr <|> lispNum)))'    In the first argument of `many1', namely        `(lexeme (lispSym <|> (lispPair <|> (lispStr <|> lispNum))))'    In the expression:        many1 (lexeme (lispSym <|> (lispPair <|> (lispStr <|> lispNum)
16:12:35 <OceanSpray> )))
16:13:10 <qwr> someone hacking scheme in 48h
16:13:20 * wli should do that at some point.
16:13:39 <OceanSpray> I have no idea what's going on here.
16:13:53 <chessguy> OceanSpray, can you paste your code?
16:13:58 <OceanSpray> I did.
16:14:12 <Binkley>  hpaste:  OceanSpray annotated "screw.hs" with "screw.hs" at http://hpaste.org/2086#a1
16:14:21 <chessguy> oh, sorry
16:14:36 <chessguy> where is line 44?
16:14:42 <OceanSpray> the last block
16:14:43 <sorear> OceanSpray: You need to pass the value you got from makeTokenParser as the first argument to lexeme
16:15:09 <OceanSpray> how do I do that?
16:15:19 <OceanSpray> I'm not aware of using makeTokenParser anywhere
16:15:37 <Tac-Tics> is there a standard function that takes a list of functions and an argument and lists the results of applying each function to that argument?
16:15:41 <Tac-Tics> like the reverse of map?
16:15:48 <qwr> i get another error... Class `Num' used as a type
16:15:55 <Binkley> @hoogle [(a -> b)] -> a -> [b]
16:15:55 <OceanSpray> oh whoops
16:15:56 <lambdabot> No matches, try a more general search
16:16:00 <qwr> is this same source?
16:16:03 <OceanSpray> lemme annotate it again
16:16:21 <Tac-Tics> sometimes I wonder if it's easier just to write the function in haskell than to try and explain it to the fine folks of this chatroom
16:16:25 <hpaste>  (anonymous) annotated "screw.hs" with "(no title)" at http://hpaste.org/2086#a2
16:17:05 <Binkley> Tac-Tics: sometimes it's easier. then you can wait for someone else to point out to you years later that you could have used a standard library function :-)
16:17:23 <qwr> ok
16:18:02 <Tac-Tics> heh yeah
16:18:07 <JBGood25> @pl \f a -> map (\x-> x a) f
16:18:07 <lambdabot> flip (map . flip id)
16:18:43 <Tac-Tics> woot
16:18:46 <stepcut> > map  ($ 2) [(+1), (*2)]
16:18:48 <lambdabot>  [3,4]
16:18:53 <Tac-Tics> learning is fun
16:18:55 <mrd> map ($arg)
16:18:56 <mrd> yea
16:19:08 <shachaf> > sequence [(+1),(*2)] 5
16:19:09 <lambdabot>  [6,10]
16:19:31 <Tac-Tics> For the last hour, I've been trying to turn the neighborCount function for Conway's Game of Life into a proper Haskellist function
16:19:45 <stepcut> @pl (\x -> map ($ x))
16:19:45 <lambdabot> map . flip id
16:20:02 <stepcut> > (map . flip id)  2 [(+1), (*2)]
16:20:03 <lambdabot>  [3,4]
16:20:16 <Tac-Tics> @let revmap [] arg = []; revmap (f:fs) arg = (f arg) : revmap fs arg
16:20:20 <lambdabot> Defined.
16:20:28 <Tac-Tics> revmap [id, (+1), (+2)] 0
16:20:39 <Tac-Tics> > revmap [id, (+1), (+2)] 0
16:20:40 <lambdabot>  [0,1,2]
16:20:43 <shachaf> Tac-Tics: revmap = sequence
16:20:56 <Tac-Tics> for seriously
16:20:56 <shachaf> > sequence [id, (+1), (+2)] 0
16:20:57 <lambdabot>  [0,1,2]
16:21:00 <Tac-Tics> that makes me sad
16:21:01 <Tac-Tics> heh
16:21:12 <Tac-Tics> shachaf++
16:21:18 <shachaf> Tac-Tics: With the (r ->) monad. I don't know if you're supposed to understand that yet, though.
16:21:33 <Tac-Tics> is that how you raise karma with LB?
16:21:43 <sorear> yes
16:21:44 <shachaf> > map ($ 0) [id, (+1), (+2)] -- I think this is clearer, though.
16:21:45 <lambdabot>  [0,1,2]
16:21:49 <Tac-Tics> @karma
16:21:49 <lambdabot> You have a karma of 0
16:21:57 <sorear> @karma
16:21:57 <lambdabot> You have a karma of 1
16:22:07 <Tac-Tics> @let point i j = sequence (map toOffset (sequence (replicate 2 [(-1) .. 1]))) (i, j)
16:22:08 <sorear> The bot got its state erased recently.
16:22:08 <lambdabot> <local>:2:26: Not in scope: `toOffset'
16:22:08 <shachaf> Will the old karma ever get reset?
16:22:11 <sorear> @karma-all
16:22:11 <lambdabot>  "moritz"               34
16:22:11 <lambdabot>  "agentz"               31
16:22:11 <lambdabot>  "+"                    19
16:22:11 <lambdabot>  "masak"                 9
16:22:11 <lambdabot>  "lwall"                 6
16:22:13 <lambdabot> [85 @more lines]
16:22:23 <shachaf> The #perl6-ers, as usual.
16:22:24 <Binkley> heh, + sure has a lot of karma
16:22:32 <shachaf> +++
16:22:48 <Tac-Tics> @let toOffset [x, y] = \(a, b) -> (x + a, y + b)
16:22:49 <lambdabot> Defined.
16:22:57 <Tac-Tics> @let  point i j = sequence (map toOffset (sequence (replicate 2 [(-1) .. 1]))) (i, j)
16:23:00 <lambdabot> Defined.
16:23:08 <Tac-Tics> > point (0, 0)
16:23:09 <lambdabot>        add an instance declaration for (Enum (t, t1), Num (t, t1))
16:23:09 <lambdabot>     In the...
16:23:14 <shachaf> > point 0 0
16:23:15 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(0,-1),(0,0),(0,1),(1,-1),(1,0),(1,1)]
16:23:18 <Tac-Tics> oh yeah
16:23:19 <Tac-Tics> whoops
16:23:22 <Lemmih> ++
16:23:28 <nn-on-bluetooth> #gen-2
16:23:38 <Tac-Tics> point 1 1
16:23:45 <Tac-Tics> > point 1 1
16:23:46 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
16:23:51 <Tac-Tics> cool!
16:23:57 <shachaf> Tac-Tics: That sequence is definitely confusing, ignoring the rest of the code.
16:24:09 <shachaf> Tac-Tics: (Since sequence has many meanings in Haskell.)
16:24:24 <Tac-Tics> yeah it is
16:24:41 <glguy> Tac-Tics: try replicateM
16:24:54 <qwr> OceanSpray: lexeme wants TokenParser (lexer) as first argument
16:24:57 <Tac-Tics> @info replicateM
16:24:57 <lambdabot> replicateM
16:25:03 <Tac-Tics> oh yeah
16:25:06 <Tac-Tics> broken
16:25:11 <shachaf> @ty replicateM
16:25:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
16:25:15 <shachaf> @src replicateM
16:25:15 <lambdabot> replicateM n x = sequence (replicate n x)
16:25:16 <Tac-Tics> what module is replicateM located?
16:25:29 <shachaf> @index replicateM
16:25:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:25:40 <mrd> @seen dons
16:25:41 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 10h 50m 8s ago.
16:25:50 <mrd> @localtime dons
16:25:51 <lambdabot> Local time for dons is Mon Aug  6 09:25:20 2007
16:25:59 <oerjan> Tac-Tics: @info is not broken, it is simply not there, so lambdabot corrects it silently to @undo
16:26:13 <shachaf> @help undo
16:26:14 <lambdabot> undo <expr>
16:26:14 <lambdabot> Translate do notation to Monad operators.
16:26:19 <shachaf> Oh, right.
16:26:32 <mrd> it's DWLBTYM
16:26:43 <shachaf> @info do { x <- y; y <- z; return (z x) }
16:26:43 <lambdabot> y >>= \ x -> z >>= \ y -> return (z x)
16:26:49 <glguy> ?losers
16:26:49 <lambdabot> Maximum users seen in #haskell: 382, currently: 326 (85.3%), active: 20 (6.1%)
16:26:51 <Tac-Tics> > point 3 3
16:26:53 <lambdabot>  [(2,2),(2,3),(2,4),(3,2),(3,3),(3,4),(4,2),(4,3),(4,4)]
16:27:05 <Tac-Tics> I need to work on cleaning up that function now
16:27:29 <Tac-Tics> but I got it working
16:27:37 <shachaf> Tac-Tics: What is that function supposed to be?
16:27:48 <Tac-Tics> a function to generate neighboring points in conway's game of life
16:27:52 <glguy> > let f (x,y) = [(u,v) | u <- [x-1..x+1], v <- [y-1..y+1]] in f (3,4)
16:27:54 <lambdabot>  [(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,3),(4,4),(4,5)]
16:27:58 <shachaf> Oh.
16:28:16 <Tac-Tics> http://www.alpheccar.org/www/content/user_1/content_0/78/Main.hs
16:28:20 <Tac-Tics> the "life" function in that code
16:28:21 <glguy> Tac-Tics: that's probably a generally clearer way to write it
16:28:25 <shachaf> There you go, glguy cleaned it up for you. :-)
16:28:26 <|Winterstream|> Anyone care to give a quick rundown of how a delimited continuation differs from a normal one? :)
16:28:28 <Tac-Tics> I've always written it that way
16:28:37 <Tac-Tics> but I wanted to know the cool FP way of doing it
16:28:46 <glguy> > let f (x,y) = liftM2 (,) [x-1..x+1] [y-1..y+1] in f (3,4)
16:28:48 <lambdabot>  [(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,3),(4,4),(4,5)]
16:28:54 <Tac-Tics> and now that I have the answer, I don't understand it
16:29:17 <shachaf> Tac-Tics: There, glguy gave you a "cool GP way of doing it" too.
16:29:29 <Tac-Tics> yeah, I see that
16:29:31 <shachaf> Tac-Tics: Though they're really equivalent.
16:29:34 <Tac-Tics> yeah
16:29:53 <JBGood25> list monad?
16:29:59 <glguy> JBGood25: yeah
16:30:03 <Tac-Tics> I am still trying to develop a good sense of the cleanest way to define stuff in Haskell
16:30:10 <wli> GP == Generic Programming ?
16:30:15 <Tac-Tics> time to go for now though
16:30:21 <Tac-Tics> thanks for all your help guys
16:30:23 <Tac-Tics> you've been great
16:30:50 <|Winterstream|> Anyone?
16:31:02 <glguy> > let f (x,y) = (,) `liftM` [x-1..x+1] `ap` [y-1..y+1] in f (3,4)
16:31:04 <lambdabot>  [(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,3),(4,4),(4,5)]
16:31:18 <OceanSpray> I'm out of ideas.
16:31:23 <OceanSpray> How do I fix my parser?
16:31:52 <shachaf> > fix parser
16:31:52 <lambdabot>  Couldn't match expected type `a -> a'
16:32:00 <Binkley> > fix "parser"
16:32:01 <lambdabot>  Couldn't match expected type `a -> a'
16:32:04 <shachaf> > fix parser
16:32:05 <lambdabot>  "Magic"
16:32:12 <mrd> > fix ("parser":)
16:32:13 <lambdabot>  ["parser","parser","parser","parser","parser","parser","parser","parser","pa...
16:32:16 <Binkley> > fix (const "parser")
16:32:17 <lambdabot>  "parser"
16:32:33 <lament> damn, my attempt at a monad tutorial is going nowhere.
16:32:36 <oerjan> > parser 0
16:32:37 <lambdabot>  "Magic"
16:32:45 <mrd> someone is being clever
16:32:48 <shachaf> lament: Don't worry, we're here to help with that too. :-)
16:32:49 <Binkley> make love, not monad tutorials
16:32:58 <oerjan> mrd: shachaf, obviously
16:33:05 <mrd> lament: perhaps you'd do better with an Arrow tutorial?
16:33:08 <lament> shachaf: perhaps somebody should write a "Writing monad tutorials" tutorial?
16:33:12 <wli> Hey, I could use the monad tutorials, especially if they've got lots of exercises.
16:33:15 <|Winterstream|> Arrrgh. No, make delimited continuation tutorials! :)
16:33:22 <shachaf> lament: I've suggested that before.
16:33:31 <Binkley> ?remember lament perhaps somebody should write a "Writing monad tutorials" tutorial?
16:33:31 <lambdabot> Done.
16:33:35 <shachaf> People should make comonad tutorials now.
16:33:43 <Binkley> no, they should make monad cotutorials
16:33:49 <oerjan> Binkley: beat me to it :D
16:33:55 <wli> I'd appreciate arrows, comonad, Template Haskell, and GADT tutorials while we're at it.
16:33:56 <Binkley> that will make you unlearn everything that's in the monad tutorials
16:34:02 <|Winterstream|> ha ha ha
16:34:03 <wli> Fundeps, too.
16:34:05 <shachaf> Nobody @remembered me for it! :-(
16:34:18 <Binkley> shachaf: sometimes you're the windshield, sometimes you're the bug
16:34:22 <|Winterstream|> Binkley: No, you would simply colearn everything
16:34:23 <kjdf> does anyone know (and has an opinion) on Curry language? - http://en.wikipedia.org/wiki/Curry_%28programming_language%29
16:34:25 <|Winterstream|> he
16:34:32 <shachaf> @quote colearn
16:34:32 <lambdabot> No quotes match. I feel much better now.
16:34:41 <shachaf> @quote \<co
16:34:42 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
16:34:47 <shachaf> @quote \<co
16:34:48 <lambdabot> glguy says: 11th commandment, don't use cygwin because it is crap
16:34:56 <Binkley> so true
16:35:08 <mrd> i've been working on a "using" arrows tutorial (hxt).
16:35:19 <wli> mrd: Awesome!
16:35:33 <mrd> it's not a deep theory thing though
16:35:42 * glguy didn't actually say that
16:35:43 <wli> mrd: I wouldn't understand the deep theory anyway.
16:35:48 <glguy> or was drunk or something at the time
16:35:51 <glguy> and just doesn't remember it
16:36:02 <Korollary> glguy: you the attorney general?
16:36:07 <dolio> kjdf: The mailing list seems pretty dead.
16:36:07 <Binkley> haha
16:36:11 <|Winterstream|> BTW, did I ramble on about functional programming being awesome a couple of minutes ago? I typed some stuff, but my connection was screwed. Not sure whether anything got through...
16:36:13 <mrd> glguy: well, it was on the third tablet ...
16:36:31 <lament> |Winterstream|: no.
16:36:32 <glguy> I'm not disagreeing... :)
16:36:32 <mrd> 19:34 -!- Winterstream [n=kvirc@dsl-244-162-70.telkomadsl.co.za] has quit [Read error: 110 (Connection timed out)]
16:36:36 <sorear> glguy: Nov 11, 2006
16:36:40 <|Winterstream|> Heh
16:36:48 <glguy> sorear: oh, cool I'll read the logs
16:36:51 <mrd> @wiki HXT/Practical
16:36:51 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical
16:37:02 <lament> Winterstream: but we already know it's awesome.
16:37:04 <sorear> 10:21 and 19 seconds clog time
16:37:37 <augustss> Winterstream: not that we mind hearing it again :)
16:37:43 <shachaf> @localtime clog
16:37:44 <lambdabot> Local time for clog is Sun Aug  5 16:37:44 2007
16:37:56 <lament> so, what is so awesome about this functional programming thing?
16:37:58 <shachaf> Isn't clog time sorear time?
16:38:01 <shachaf> @localtime sorear
16:38:03 <lambdabot> Local time for sorear is Sun Aug  5 16:37:29 2007
16:38:10 <mrd> calif
16:38:15 <sorear> yup.
16:38:34 <Winterstream> lament: Hehe. Of course. I was sounding off because I had finished Hu√©t's paper on "The zipper" and was suitably impressed. I really hope more of these fantastic ideas get popularized. I think I should do a Java (*vomit*) implementation of "The zipper" and release it. Hopefully it will convince some Javaistas.
16:38:39 <glguy> sorear: chaf> @localtime clog
16:38:42 <oerjan> cmeme uses UTC in the logs, i think
16:38:45 <glguy> sorear: http://tunes.org/~nef/logs/haskell/06.11.11
16:38:51 <glguy> I don't think I said anything tha tday?
16:38:59 <sorear> glguy: Sep 11, sorry
16:39:00 <lament> Winterstream: convince of what, that Java is a great functional language? :)
16:39:02 * shachaf 's time zone is secret.
16:39:23 <sorear> glguy: of course NINE would be NOVEMBER... *slap*
16:40:23 <Winterstream> lament: Almost as a great a functional language as C :). At least in Java, functional datastructures work because of garbage collection. I wouldn't want to consider what using functional datastructures would be like without garbage collection...
16:40:26 <Binkley> sorear: how did you find that? usually when I google for stuff that should be in the #haskell logs, it doesn't come up
16:40:40 <qwr> lament: you'll never know without trying and learning the "patterns" possible in functional programming
16:40:57 <sorear> stefan@stefans:/var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au$ grep -r commandment .
16:40:59 <lament> sorear: blame romans and their -2-indexed arrays :)
16:41:32 <sorear> Yes, I have 200MB of irc logs sitting on my hard drive just for this. :)
16:41:46 <shachaf> sorear: Is there a reason you use /var for that?
16:41:55 <chessguy> @yow
16:41:55 <lambdabot> I want you to organize my PASTRY trays ... my TEA-TINS are gleaming in
16:41:55 <lambdabot> formation like a ROW of DRUM MAJORETTES -- please don't be FURIOUS with me --
16:42:41 <glguy> I don't like reading things that I wrote in IRC in the past any more than I like proofreading my own essays :)
16:42:46 <sorear> shachaf: aiui, /var is intended to be stuff of relatively low importance, the sysadmin could wipe /var without seriously upsetting the system, so I keep my downloads "cache" there
16:43:07 <Binkley> srsly, reading things I wrote on IRC is embarrassing
16:43:09 <shachaf> sorear: Who is the sysadmin? :-)
16:43:12 <Binkley> even if it's from yesterday
16:43:17 <glguy> /var/tmp vs /tmp... isn't one expected to survive a reboot?
16:43:20 <sorear> me. :)  I like patterns
16:43:25 <shachaf> Binkley: Even if it's just at the top of the screen.
16:43:33 <Binkley> yes
16:43:34 <sorear> glguy: /var is supposed to last slightly longer, yeah
16:43:56 <shachaf> sorear: I would think that I'd want everything that's mine to be in ~, though.
16:44:47 <shachaf> sorear: Perhaps ~/var?
16:45:10 <sorear> shachaf: I keep stuff in ~ iff it's *mine*, in a quasi-copyright sense of ownership.  Stuff that I merely have copies of, I leave elsewhere.
16:45:30 <shachaf> sorear: Hmm.
16:45:40 <ezraburgh> coq
16:46:36 <shachaf> sorear: It's easy to turn "something you have a copy of" into "something that's yours" (i.e., there's something that you added would take effort to add again, though).
16:46:47 <shachaf> sorear: What do you do then? Keep a patch in ~?
16:46:55 <Winterstream> Is a delimited continuation a continuation which is limited to a certain region of a program, like say a monad?
16:47:20 <shachaf> Winterstream: I think Pugs has a short explanation of delimited continuations in its source somewhere.
16:47:23 <sorear> shachaf: Move the whole thing into ~
16:48:02 <shachaf> sorear: I'd think that's a fine distinction, then, that would involve a lot of unnecessary moving.
16:48:12 <shachaf> sorear: Especially if they're on different partitions.
16:48:30 <glguy> shachaf: are you bored? :-p
16:48:50 <Winterstream> scachaf: I'll have a look. Thanks.
16:49:38 * Winterstream is so going to have to write up Wikipedia entries for all these interesting, yet mind bending topics. Once he understands them, of course...
16:49:44 <kjdf> Winterstream: you can try this as well: http://community.schemewiki.org/?composable-continuations-tutorial
16:49:48 <shachaf> glguy: OK, I'll stop. :-)
16:49:49 <lambdabot> http://tinyurl.com/yy2eux
16:50:08 * shachaf is going to be using a new computer soon, and hopes the filesystem won't get too messed up.
16:50:26 <shachaf> Since that's a lot of trouble to fix later.
16:50:29 <lament> see, Winterstream just called a monad "a region in a program"
16:50:32 <shachaf> s/fix/change/
16:50:41 <lament> and then people wonder why people find monads confusing!
16:50:59 * wli should tackle arrows.
16:51:01 <Winterstream> lament: well, I didn't mean it that way exactly
16:51:03 <lament> this is the kind of stuff i wanted my tutorial to address :)
16:51:22 <ddarius> What "Tutorial: Monad Tutorials suck!"
16:51:24 <sorear> lament: He called *a* monad a region in the program.
16:51:29 <shachaf> Winterstream: Does http://svn.openfoundry.org/pugs/src/Pugs/AST/Eval.hs help?
16:51:39 <sorear> A Haskell program is actually a Perl interpreter.
16:51:42 <wli> What Monad tutorials are lacking IMHO is more extensive problem sets.
16:52:04 * sorear <3 quantifiers
16:52:12 <Winterstream> lament: What I meant is that I understand there is a monad implementing delimited continuations. So that monad is a specific region of one's program :)
16:52:33 <Winterstream> kjdf & shachaf: Thanks :)
16:52:59 <lament> Winterstream: no, see, that's a monadic type, and its values might well be defined in regions of your program :)
16:53:21 <Winterstream> kjdf++
16:53:25 <Winterstream> shachaf++
16:53:52 <Winterstream> lament: Arrgh. Nit picking! :)
16:53:55 <OceanSpray> ARRRGH
16:54:12 <lament> Winterstream: i'm not attacking anything you said, or saying you should have said it differently :)
16:54:16 <shachaf> People are giving me an unusual (for me) amount of karma today, I think.
16:54:23 <OceanSpray> How do I 'convert' a CharParser or GenParser to a TokenParser?
16:54:24 <shachaf> Not that I'd go so far as to java ++.
16:54:39 <lament> Winterstream: but... when similar confusion occurs in a _tutorial on monads_, that's bad
16:54:44 <lament> and it does
16:55:06 <Winterstream> lament: Ahh. Granted. Goodness me, that would be bad.
16:55:41 <Winterstream> lament: If you have plenty of examples and plenty of exercises in your tutorial, it'd be great
16:56:10 <Winterstream> lament: And leave the Maybe and List monads until right at the end! :)
16:56:35 <lament> i'm trying to make a tutorial specifically for people who got confused by other explanations.
16:56:35 <shachaf> Winterstream: Why?
16:56:51 <Winterstream> lament: It just astounds me that so many tutorials begin with the Maybe monad. It just meant nothing to me as an introductory monad.
16:57:21 <lament> Winterstream: what would you start with?
16:57:58 <lament> Winterstream: the problem with starting with IO is that IO is magical, but monads aren't, and when I first encountered IO and monads, I got confused and thought that it's monads that are magical.
16:58:15 <Winterstream> shachaf: In retrospect I'd have to say that starting with IO or an interpreter (as in Wadler's original paper) is a good way. It's just my opinion. But understanding that one is "snapping together" a bunch of blocks to build a "program" helped me.
16:58:26 <Winterstream> lament: See above :)
16:58:37 <Winterstream> lament: That is true too.
16:58:47 <shachaf> Winterstream: But lists are actually "useful" monads, if that's what you want.
16:59:14 <samreid> what the monad tutorial starts with probably depends on the goal of the monad tutorial
16:59:21 <Winterstream> lament: The magic frightened me. The expectation of magic immediately placed me on my guard.
16:59:32 <shachaf> Winterstream: I'd think Identity/Maybe/List and then Reader/State/Writer would be a good order.
16:59:33 <lament> but that's the entire point
16:59:34 <Winterstream> On the other hand, I was lead to monads via IO
16:59:37 <lament> there's _no_ magic in monads
16:59:47 <shachaf> Winterstream: Possibly a simple parser monad is nice too.
16:59:50 <lament> so there's no reason to be on guard
16:59:59 <coderdave> hey, using haskell can you hook into api's such as ogl, win32, or is it possible to write your own hooks?
17:00:05 <lament> there _is_, however, some magic in IO
17:00:16 <ddarius> coderdave: Yes.
17:00:39 <Winterstream> lament: I know. But I was, because I had this massive expectation that I was about to read about something very hard...
17:00:52 <coderdave> ddarius, would you happen to know any resources that I can do further research into?
17:01:01 <ddarius> coderdave: The FFI specification.
17:01:03 <ddarius> @where ffi
17:01:03 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
17:01:24 <ddarius> coderdave: There are already bindings to Win32 and OpenGL by the way.
17:01:32 <lament> Winterstream: yes, which is i'm not sure about starting with IO.
17:01:35 <ddarius> @docs
17:01:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:01:35 <Winterstream> lament: What is magic about IO? I'm asking because I might genuinly be missing out on something
17:01:53 <ddarius> IO is magical in all languages.
17:01:55 <coderdave> ddarius, you've been incredibly helpful
17:01:56 <shachaf> Winterstream: Implement it.
17:01:59 <coderdave> thanks :)
17:02:11 <kilimanjaro> IO is carried out by leopluridons
17:02:15 <kilimanjaro> oops, I meant monads!
17:02:20 <Winterstream> magical leopluridons
17:02:22 <Winterstream> ha ha ha
17:02:39 <Winterstream> oh crap. battery going going. I hate Lenovos!
17:02:59 <Winterstream> Ciao everyone!
17:03:12 <lament> i'll answer later, then :)
17:03:30 <Winterstream> I'll be back :)
17:03:46 <chessguy> a link to a very interesting google video on interval arithmetic just got posted on -cafe
17:03:57 <Winterstream> As forward payment...
17:03:58 <ddarius> @google "affine arithmetic"
17:03:59 <Winterstream> lament++
17:04:01 <lambdabot> http://www.ic.unicamp.br/~stolfi/EXPORT/projects/affine-arith/
17:04:01 <lambdabot> Title: Affine Arithmetic Project
17:04:02 <lament> what's the lambdabot syntax for telling people stuff?
17:04:04 <chessguy> seems like the sort of thing that haskell would be good at
17:04:07 <Winterstream> Ciao! :)
17:04:09 <chessguy> @tell lament like this
17:04:09 <lambdabot> Consider it noted.
17:04:10 <ddarius>  @tell
17:05:03 <oerjan> OceanSpray: read the parsec manual at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html, in particular the section "Lexical analysis"
17:05:12 <lament> Winterstream: you're still here :)
17:05:12 <lambdabot> lament: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:02 <shachaf> lament: Perhaps Winterstream doesn't use run an IRC client locally.
17:07:37 <lament> @tell Winterstream (on why IO is magical) Consider (print "hello"). It would appear to a newbie to FP that this prints "hello". Actually it doesn't - it's just a value. However, if you type it into an interactive interpreter, it DOES print hello, adding to the confusion.
17:07:37 <lambdabot> Consider it noted.
17:08:19 <ddarius> > print "hello"
17:08:19 <shachaf> lament: I'd say IO is magical because you can't write your own.
17:08:21 <lambdabot>  <IO ()>
17:08:38 <shachaf> > print (print "hello")
17:08:39 <lambdabot>  <IO ()>
17:08:41 <shachaf> > fix print
17:08:42 <lambdabot>  <IO ()>
17:08:47 <shachaf> There, fixed.
17:09:00 <OceanSpray> ok, readin;
17:09:26 <lament> @tell Winterstream What the interpreter should really do is just return the IO value (lambdabot does this); so you need to explain that the interpreter treats IO values as a special case. The important part is that all this magic has nothing to do with the concept of monads.
17:09:27 <lambdabot> Consider it noted.
17:10:42 <lament> @tell Winterstream s/really do/do according to the usual rules/
17:10:42 <lambdabot> Consider it noted.
17:13:58 <lament> i hope lambdabot will relay the messages in the order given? Are they sequenced? :D
17:14:00 <wli> mrd: Your arrows tutorial doesn't seem to be too far along.
17:14:39 <lament> or should i have started with @tell Winterstream do {   ;)
17:14:54 <Cale> lament: I hope it doesn't just preserve the last one you sent :)
17:14:56 <mrd> still working on it
17:15:02 <mrd> also its more hxt-oriented than arrows
17:15:10 <mrd> need some more good examples
17:15:46 <wli> mrd: Programming problems really help. Things with skeleton code, test drivers, etc.
17:15:52 <mrd> not sure if i should do less code or more code
17:15:54 <coderdave> just curious, how long would it take an experienced/professional c++ programmer to pick up haskell?
17:16:03 <mrd> some people complain one way or the other
17:16:21 <mrd> wli: well i tried to present it as programming problems. i think.
17:16:33 <Cale> coderdave: A month or two, depending on how quickly you can forget everything you know about C++ :)
17:16:49 <coderdave> really, that long?
17:16:49 <wli> mrd: Mostly code helps when I have to write it. I didn't bothe reading any of the YAHT prose, for example. I just marched through the problems.
17:16:56 <coderdave> crazy..
17:16:56 <lament> Cale: instance Monad LambdaBotMessage where a >> b = b? :)
17:17:13 <Cale> coderdave: Well, it depends on where you count to.
17:17:32 <Cale> coderdave: I'm still learning Haskell-related things, and I started 3 years ago :)
17:18:02 <coderdave> was it your first language?
17:18:18 <Cale> No, I already knew a dozen or so.
17:18:21 <mrd> wli: yea that was my problem with the existing material too.  i ended up figuring things out from the haddocks and types.
17:18:40 <Cale> coderdave: I could write useful programs very soon after.
17:19:04 <Cale> But I didn't really feel properly comfortable until about my second month.
17:19:25 <coderdave> ic - that is unfortunate, I was hoping I could pick this up in a few weeks
17:19:36 <Cale> Well, give it a shot and see where you get :)
17:19:45 <Cale> The tutorials are better now than they used to be.
17:19:56 <samreid> coderdave: depends how much time per day you spend :P
17:20:04 <coderdave> i will - i'm starting with the yet another haskell tutorial..
17:20:05 <Cale> That's also true :)
17:20:21 <kjdf> mrd: can you give link to your tutorial?
17:20:51 <Cale> coderdave: It's decent -- when it comes to learning I/O and monads, I'll point you at some specific other resources though. :)
17:21:24 <coderdave> ok, i'll be sure to ask when i get to that point
17:22:08 <mrd> @wiki HXT/Practical
17:22:09 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical
17:22:15 <kjdf> yaht then 'all about monads' seems to be a fine combination
17:22:22 <kjdf> mrd thanks
17:24:02 <coderdave> do they have debuggers for this language?
17:24:21 <sorear> No practical ones.
17:24:22 <shachaf> coderdave: There will be a debugger in the next version of GHC.
17:24:24 * mrd is a debugger
17:24:37 <coderdave> jeez, that's a shame :(
17:24:47 <shachaf> mrd: Yes, #haskell is another one.
17:24:51 <mrd> i dunno, never really felt the need for a debugger
17:24:54 <shachaf> mrd: But also still in development.
17:24:56 <lament> on the plus side, there's no bugs, ever!
17:24:58 <Cale> coderdave: If we needed them more, there would be better ones :)
17:25:15 <mrd> debugger is a very imperative oriented tool usually
17:25:21 <Cale> coderdave: There's going to be an interactive debugger in GHCi 6.8
17:25:29 <wli> coderdave: The emphasis in Haskell is on formal methods.
17:25:34 <coderdave> well, computers are imperative..
17:25:38 <wli> coderdave: Analyzing code before it ever runs.
17:25:41 <shachaf> coderdave: But Haskell isn't.
17:25:41 <coderdave> ic
17:25:50 <Cale> Haskell's evaluation strategy is very much not imperative.
17:25:54 <dons> coderdave: have you got a bug, or just preemptively suspect you'll need a debugger?
17:26:06 <coderdave> dons, the latter
17:26:33 <coderdave> just setting up my environment today to begin learning
17:26:35 <lament> let's be reasonable, implying "you don't need a debugger for haskell" is just silly
17:26:44 <lament> of course you need a debugger, and no, there aren't any :)
17:26:52 <Cale> The type system catches about 90% of the bugs which would be runtime bugs in most other languages.
17:26:54 <lament> but people manage
17:26:54 <dons> for now, there's Debug.Trace, if you need to understand if a piece of code is evaluated, and QuickCheck, for semi-formal checking of code. i wouldn't worry about the debugger yet -- it'll be out soonish, and some will use it, but its not critical
17:27:09 <wli> coderdave: The "way you program" is also different. You do a lot more thinking up-front. Lots of writing docs to explain things to yourself and very little code.
17:27:15 <Cale> The rest of the bugs are usually truly cases where you've not understood what it is that you're actually trying to do.
17:27:38 <wli> coderdave: (A lot of things that take tons of code in other languaes are one-liners in Haskell.)
17:27:42 <Cale> Also, Haskell functions are *way* easier to test than imperative code.
17:27:56 <dons> coderdave: so the main things are to just install ghc, and a few packages from haskell (like mtl, quickcheck, binary)
17:27:57 <wli> ghci is already a debugger to me.
17:28:04 <wli> It's simple.
17:28:09 <mrd> hey dons, speaking of bugs and errors
17:28:16 <coderdave> ok - will do
17:28:17 <Cale> Because they're referentially transparent -- you basically don't have to work so hard at building up a complicated context in which some code will have to run.
17:28:22 <mrd> is there any weird behavior with hs-plugins and the propagation of exceptions?
17:28:29 <mrd> (known)
17:28:33 <wli> Load the module. Fiddle with the piece of code you want to observe the behavior of.
17:28:40 <dons> yeah, debuggers are less obvious, since there's no state to reconstruct, to reproduce a bug all you need to do is run a functoin with its arguments
17:28:45 <dons> not actually set up some machine state.
17:28:51 <dons> yay for not being an imperative language
17:28:58 <wli> A lot of times it doesn't take QuickCheck to spot what you're computing being off.
17:29:09 <Cale> Yeah, when you get right down to it, debuggers are all about reproducing state.
17:29:18 <dons> mrd, not that i know of
17:29:40 <coderdave> and haskell has no means of setting up state?
17:29:45 <mrd> i made a printf format error in a plugin, so it raised an error.  but i couldn't seem to catch it anywhere.
17:29:53 <mrd> i'll try to isolate it then
17:30:01 <Cale> coderdave: It does, but you have very fine control over that.
17:30:03 <wli> coderdave: It has ways of doing so, but they're extremely disciplined.
17:30:19 <coderdave> ok - guess ill just have to read and see for myself :P
17:30:20 <Cale> coderdave: So if you just need one state parameter, you can have just that.
17:30:34 <dons> it avoids mutable state (similar to erlang, if you know that)
17:30:49 <coderdave> no - but i understand the paradigm
17:31:07 <Cale> All the way up to full IO where you have as much state as you'd like.
17:31:17 <mrd> dons: i've been using (abusing?) hs-plugins by unloadAll on all my plugins, then making them all, and then loading them all back again.  it seems to work, but it is a bit odd about shared module dependencies.
17:31:33 <Cale> (and can do basically anything you can do in C, if you're willing to try :)
17:31:49 <mrd> i have to recompile those separately with ghc -c, and sometimes it just crashes anyway (changing instances seems to do this)
17:32:01 <wli> coderdave: State is so thoroughly regimented that it prevents a lot of bugs just because of that.
17:32:16 <wli> coderdave: This is even when being stateful, mutable, and so on.
17:32:48 <Cale> coderdave: In the end, your top-level program is an IO-thing, so you do have full control, but you tend to get your actual I/O over with quickly, and write the important part of your program (the model from MVC) in pure functions.
17:32:52 <wli> coderdave: Different kinds of effects are separated into separate, stackable environments.
17:33:11 <coderdave> mvc, as in model view client? or something else
17:33:22 <Cale> model view controller
17:33:23 <Cale> yeah
17:33:28 <wli> coderdave: And those environments are orthogonal, so they don't interfere with each other.
17:33:42 <coderdave> right
17:33:50 <wli> coderdave: This alone prevents a lot of the sorts of bugs that would occur in imperative languages.
17:34:24 <samreid> hi, are there any performance advantages to using one of (StateT (a,b) m) or (StateT a (StateT b m)) instead of the other?
17:35:18 <mrd> samreid: seems like the former will save you headaches
17:35:25 <wli> coderdave: The state modifications are typically also very precisely controlled. The type system is used to classify the valid states, and the access methods exposed only permit valid state transitions, and it's all checked by the compiler with its typesystem. So the way this all works relegates a debugger to something rather obscure.
17:35:43 <Cale> samreid: I actually don't know, but regardless, make sure that you newtype the monad that you construct, and write some wrappers around the state transformations.
17:36:04 <Cale> samreid: If you do that, it should be easy to change it later.
17:36:22 <Cale> (because you'll only have to rewrite the gets and puts in one place)
17:36:22 <wli> What's the deal with the O(n^2) instance decls wrt. monad transformers again?
17:36:26 <samreid> naturally
17:36:28 <samreid> thanks
17:36:39 <Cale> wli: You mean the lifting instances?
17:36:47 <wli> Cale: Yeah.
17:37:02 <coderdave> well, sounds like i've got some fun times ahead, time to start reading. thanks for the insight
17:37:04 <coderdave> take care
17:37:12 <dolio> They're far more convenient than 'lift (lift (lift ...))'
17:37:39 <wli> dolio: I think there's another way to implement monad transformers that avoids the O(n^2) mess.
17:37:48 <Cale> wli: In order to avoid having to write a lot of lifts, there are instances which ensure that, for instance, the writer operations work on a StateT of a monad which supported the writer operations.
17:37:51 <wli> dolio: Never mind the mutual recursion.
17:38:07 <Cale> wli: The way to avoid the O(n^2) instances is just to not write them in the first place.
17:38:10 <wli> Cale: Yeah, I've written instances for all this.
17:38:23 <dolio> There's monad co-products. But the lift-instances can be non-trivial.
17:38:27 <wli> Cale: Well, then you go back to StateT (a,b) m a
17:38:36 <Cale> They're strictly unnecessary, so long as you're going to newtype the monad you construct and write all your own operations anyway.
17:38:52 <wli> Cale: Anyway, ISTR mention of a different definition in some paper being mentioned.
17:39:01 <Cale> But yeah, they can be sort-of tricky to write.
17:39:29 <Cale> Oh, there are also other ways to combine functionality.
17:39:47 <EvilTerran> can you do fixity declerations for tycons?
17:39:55 <wli> yes
17:40:14 <Cale> Like writing functions  sequence :: m (n a) -> n (m a)
17:40:49 <Cale> Well, it's pushing it a little to call that sequence :)
17:41:01 <samreid> it would be nice to have  deriving (AllOtherMonadClasses)
17:41:14 <chessguy> hey Cale, you would enjoy the google video someone just linked to on -cafe
17:41:18 <Cale> samreid: You can derive them one by one.
17:41:32 <chessguy> on interval arithmetic
17:41:34 <EvilTerran> wli, so if you've got data (a :%: b) = a :%: b; infixr ... :%:, does that affect the tycon and the constructor>
17:41:38 <EvilTerran> *?
17:41:57 <Cale> Interval Arithmetic?
17:42:31 <Cale> chessguy: Ah, you already said that :)
17:42:32 <chessguy> yup, representing values as intervals, as a replacement to floating point arithmetic
17:42:32 <sorear> EvilTerran: data (a :%: b) is illegal.  tycons must be prefix in Haskell 98.
17:42:56 <EvilTerran> i'm thinking of GHC 6.6.1 here
17:42:58 <Cale> Yeah, I know what interval arithmetic is, I just missed where you clarified which video :)
17:43:03 <chessguy> ah
17:43:07 <hpaste>  jhujhiti pasted "X11-extras install log" at http://hpaste.org/2087
17:43:17 <Cale> http://video.google.com/videoplay?docid=-2285617608766742834
17:43:18 <lambdabot> Title: A Google Opportunity in Numerical Computing
17:43:30 <chessguy> it seems like the sort of thing that haskell would be good at
17:44:31 <chessguy> and the implementation in the paper that email links to seems very straightforward, too. though i don't know enough of the technical details to understand his problems with it
17:45:35 <dibblego> ?type liftM
17:45:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:45:47 <shachaf> dibblego: Oh, someone in #scala wanted to talk to you.
17:45:47 <chessguy> (a -> b) -> m a -> m b
17:45:51 <Cale> It would be rather cool to have a library for generalised "set arithmetic", where your inputs would be perhaps intervals (or balls in C), and you could query the outputs to see if those results were possible or not (at which point the real computation would take place)
17:45:54 <shachaf> dibblego: I think it was ed1t.
17:46:01 <dibblego> ?type zipWith
17:46:03 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:46:04 <dibblego> shachaf, ok thanks
17:46:23 <dibblego> ?type zipWith3
17:46:25 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:46:28 <dibblego> ?type liftM2
17:46:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:46:43 <Cale> The trouble with keeping everything as intervals is that you can slowly lose information as your computation proceeds.
17:46:45 <mrd> @djinn [([a],b)] -> [(a,b)]
17:46:46 <lambdabot> -- f cannot be realized.
17:46:49 <shachaf> dibblego: What are you trying to achieve with these ?types?
17:46:55 <wli> Cale: I think there's something like Traversable.sequence
17:46:56 <dibblego> shachaf, just remembering :)
17:47:05 <shachaf> dibblego: Oh.
17:47:06 <chessguy> Cale, you mean by having overly-wide intervals?
17:47:07 <Cale> wli: yeah, but it's not quite the right generalisation
17:47:12 <shachaf> dibblego: Are you thinking of ZipList?
17:47:13 <Cale> chessguy: yeah
17:47:21 <dibblego> shachaf, what is ZipList?
17:47:34 <EvilTerran> Cale, the same problem applies to floating point, it's just the loss of precision is harder to quantify.
17:47:34 <Cale> Doing something like a Fourier transform with interval arithmetic can leave you with basically no information left.
17:47:47 <chessguy> Cale, yeah, the video claims that some tricks are being found to narrow the intervals
17:48:03 <shachaf> dibblego: An Applicative in which liftM2 (actually, liftA2) = zipWith, for example.
17:48:10 <Cale> Even though FFT's actually *do* work with floating point -- just they work probabilistically.
17:48:15 <wli> Cale: Well, if there are instances of Traversable for both the relevant monads, I suppose it works.
17:48:17 <dolio> > getZipList $ (,) <$> ZipList [1..3] <*> ZipList [4..7]
17:48:19 <lambdabot>  [(1,4),(2,5),(3,6)]
17:48:26 <shachaf> > liftA2 (+) (ZipList [1,2,3]) (ZipList [4,5,6])
17:48:27 <lambdabot>   add an instance declaration for (Show (ZipList a))
17:48:28 <Cale> So I suppose you'd need some sort of probabilistic representation :)
17:48:35 <shachaf> > getZipList $ liftA2 (+) (ZipList [1,2,3]) (ZipList [4,5,6])
17:48:36 <Cale> wli: yeah
17:48:36 <lambdabot>  [5,7,9]
17:48:51 <wli> Cale: Or otherwise an instance of Traversable for the outer monad.
17:49:28 <shachaf> @src ZipList pure
17:49:28 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:49:34 <shachaf> @src ZipList (<*>)
17:49:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:49:40 <shachaf> pure = repeat, I think?
17:49:47 <Cale> wli: Yeah, that's nearly the right abstraction :)
17:50:03 <Cale> wli: Really, you want one where both are specifically monads :)
17:50:30 <shachaf> pure x = ZipList (repeat x)
17:50:31 <coderdave> so in this tutorial, there are functions like read, show, etc. are these part of the standard library that is packaged with all haskell compilers, or is it part of the language itself
17:50:31 <shachaf> ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
17:50:40 <shachaf> coderdave: Standard library.
17:50:42 <EvilTerran> coderdave, part of the library
17:50:52 <EvilTerran> @docs Prelude
17:50:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:50:59 <shachaf> coderdave: Even operators (like +) are just functions in the standard library.
17:51:04 <Alleria> > 3 % (4 % 5)
17:51:05 <lambdabot>   add an instance declaration for (Integral (Ratio t))
17:51:10 <chessguy> @src show
17:51:10 <lambdabot> show x = shows x ""
17:51:14 <EvilTerran> @source Prelude
17:51:14 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:51:16 <chessguy> @hoogle shows
17:51:17 <lambdabot> Prelude.shows :: Show a => a -> ShowS
17:51:17 <lambdabot> Prelude.ShowS :: type ShowS
17:51:17 <lambdabot> Prelude.showsPrec :: Show a => Int -> a -> ShowS
17:51:20 <coderdave> ok, cool thanks
17:51:51 <EvilTerran> coderdave, those two links could be worth a look, depending on how much haskell you know
17:52:24 <EvilTerran> actually, not the latter (@source). the former (@docs) *is* useful, tho.
17:52:38 <coderdave> ok, i'll keep it open while reading this
17:52:42 <Cale> coderdave: The Prelude has a lot of really beautiful things in it -- most people rewrite half of it themselves without realising it as they learn the language :)
17:52:43 <coderdave> thanks
17:52:56 <chessguy> coderdave, what tutorial are you going through?
17:53:06 <coderdave> yet another haskell tutorial
17:53:41 <chessguy> ah, a classic
17:58:40 <coderdave> so the prelude is the standard library for haskell?
17:59:18 <sorear> a tiny piece of it
18:00:18 <samreid> coderdave: it's the part that you don't have to explicitly import.
18:00:27 <sorear> it's like java.lang.* or  $CORE::, it's the library fragment that's so important you don't need to explicitly import it
18:00:41 <chessguy> @where dons
18:00:41 <lambdabot> http://www.cse.unsw.edu.au/~dons
18:00:49 <coderdave> ic
18:00:57 <coderdave> makes sense
18:01:35 <coderdave> the haskell hierarchical libraries page seems like the place i need to be for my documentation
18:02:18 <kjdf> question - what is a difference between applicative functor and a monad?
18:03:00 <kjdf> applicative doesn't have >>=, but it has 'ap' - can't they be expressed by each other?
18:03:06 <kjdf> (I mean ap and >>=)
18:03:53 <samreid> coderdave: see also the Libraries part of http://www.haskell.org/onlinereport/ .  So you get an idea (in some cases) of some that are particularly useful.
18:03:54 <lambdabot> Title: The Haskell 98 Language Report
18:04:10 <dons> -- If @f@ is also a 'Monad', define @'pure' = 'return'@ and @('<*>') = 'ap'@.
18:04:15 <dons> is how they're connected
18:05:07 <Alleria> My "intent" is 3 % (4 % 5). How do I get Haskell to actually give me back a ratio?
18:05:09 <dons> and ap can be written with some >>='s
18:05:21 <kjdf> but not the other way around?
18:05:22 <dons> > 3 / (4 / 5) :: Rational
18:05:23 <lambdabot>  15%4
18:05:43 <sorear> kjdf: applicative functors are strictly less powerful.  ([], map, repeat, zipWith ($)) is an Applicative, but there exists no corresponding monad.
18:05:51 <Alleria> dons: will that work for arbitrary precision?
18:05:58 <dons> its arbtirary precision, yep.
18:06:07 <dons> ?docs Data.Ratio
18:06:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
18:06:38 <sorear> @users
18:06:38 <lambdabot> Maximum users seen in #haskell: 382, currently: 318 (83.2%), active: 15 (4.7%)
18:07:11 <Alleria> dons: thanks. I understood that ratio types are arbitrary precision... I wasn't sure if (bignum1 / bignum2) :: Rational would give arbitrary precision...
18:07:19 <Alleria> or instead round off first, and then stuff that into a ratio.
18:07:52 <wli> Alleria: Rational is just Ratio Integer; you can have Ratio Int if you want.
18:08:14 <Alleria> wli: ahh, that clarifies things. Thanks! :-)
18:08:14 <dons>     (x:%y) / (x':%y')	=  (x*y') % (y*x')
18:08:18 <dons> is defined for Rationals
18:08:42 <Alleria> ahh
18:09:12 <wli> Alleria: It'll do gcd for you automatically, too.
18:09:47 <Alleria> wli: neat!
18:12:35 <dons> jfredett: around?
18:13:01 <dons> any chance you can change your grey on black blog colours -- I find it very difficult to read (so I'm probably not alone)
18:13:35 <matt__r> dons?
18:13:55 <dons> hey matt__r
18:14:33 <matt__r> hey - I was wondering if you can tell me how you created the "lines of code" and "lines of comments" graphs you have for xmonad
18:15:08 <dons> oh, i used the script in ghc, countlines.pl
18:15:17 <dons> then graphed them with gnuplot, using settings from darcs-graph
18:15:22 <dons> ?where darcs-graph
18:15:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/darcs-graph.html
18:15:38 <matt__r> cool - I have darcs graph so I should be able to work it out from there
18:15:42 <matt__r> thanks :)
18:16:08 <dons> the other thing i'm thinking about is committer graphs, http://www.cse.unsw.edu.au/~dons/tmp/x.png
18:16:25 <dons> though i hear these days that 10x10 pixel graphs are better than pie charts
18:16:32 <matt__r> thats cool - I was thinking of test graphs
18:16:34 <dons> but it would be nice to generate all 4 graphs from darcs-graph.
18:16:35 <shachaf> dons: Is lambdabot a committer?
18:16:43 <dons> shachaf: strangely.
18:16:46 <matt__r> ah- I reckon those pixel graphs are a fad
18:16:53 <dons> matt__r: coverage graphs, you mean, for tests?
18:17:04 <dons> matt__r: oh, and sparklines. we need sparklines too :)
18:17:14 <matt__r> dons: well, that would be cooler, I was just thinking about number of test
18:17:21 <dons> ah yes
18:17:38 <matt__r> compare it to number of lines and I think it tells at least some kind of story about how development is going
18:17:46 <dons> yeah, that's good
18:17:59 <matt__r> if lines go up and tests don't, you probably have a problem :)
18:18:49 <matt__r> hmmm - sparklines - I don't know about that
18:19:00 <matt__r> they look like data mis-representers to me
18:19:00 <OceanSpray> It seems that the manual on the parsec TokenParser is out of date.
18:19:14 <dons> matt__r: :) another fad.
18:19:20 <matt__r> yeah :)
18:19:50 <samreid> personally I prefer graphs where you have to drop random pins and measure probability of hitting certain colored squiggles
18:20:15 <dons> matt__r: this thing, inline tiny squiggles, http://paperandpencil.typepad.com/home/images/tufteSparklines.gif
18:20:22 <matt__r> although - a parkline would be great for making a small project look big
18:20:48 <matt__r> but a graph without a scale is just bollocks
18:20:49 <jfredett> dons, (about the blog) yeh, I've been fiddling around with the colors, I'll get something readable eventually. :/
18:21:46 <dons> i think anything on black is a bad idea :) let the people who like that, set it manually
18:21:54 <jfredett> lol
18:21:58 <jfredett> yeh
18:22:25 <jfredett> I just don't like Bright white,
18:22:31 <jfredett> and colors annoy me
18:22:34 <jfredett> :)
18:22:36 <matt__r> my sister (who is a graphic designer) gave me great advice "don't try anything fancy - you geeks are always making the ugliest things"
18:22:40 <matt__r> I think se was right
18:22:43 <dons> i like this guy, http://www.rubrication.net/2007/04/24/strong-specifications/
18:22:45 <lambdabot> Title: Rubrication ª The type says everything
18:22:51 <dons> matt__r: yeah.
18:22:56 <matt__r> number one rule "never use gradients in any way shape or form"
18:23:00 <dons> heh
18:23:09 <matt__r> number 2 rule "copy off womeone who knows what they are doing" :)
18:23:29 <jfredett> matt__r: Good artists create, Great artists Steal?
18:23:51 <dons> this is also nice, http://nitens.org/taraborelli/latex
18:23:53 <lambdabot> Title: Dario Taraborelli: The beauty of LaTeX
18:23:56 <matt__r> jfredett: I ain't no artist :)
18:24:11 <Lycurgus> womenone, I liek that.
18:24:23 <dons> hmm. i think i'll set up my site like that latex guy actually. its very nice
18:24:28 <jfredett> matt__r: ... :/
18:24:35 <OceanSpray> I need help.
18:24:38 <OceanSpray> Serious help.
18:24:48 <OceanSpray> Substantial help.
18:24:50 <dons> what's happening, OceanSpray ? types not checking? functions not applying?
18:24:52 <Cale> OceanSpray: hehe :)
18:24:59 <matt__r> OceanSpray:  I never played with the token stuff in parsec
18:25:03 <OceanSpray> NOTHING is happening.
18:25:03 <Cale> OceanSpray: Psychiatric help?
18:25:06 <OceanSpray> that's the problem
18:25:10 <Cale> OceanSpray: hehe
18:25:14 <jfredett> bah, I hate white! :/
18:25:21 <Cale> OceanSpray: okay, what program are you trying to run?
18:25:24 <Binkley> psychiatric help, 5 cents
18:25:26 <Binkley> #haskell is IN
18:25:28 <jfredett> *hunts around for blog colorschemes, :/
18:25:30 <OceanSpray> I'm trying to parse the simplest of lisp exressions, and it won't even compile
18:25:38 <kpreid> Whee! My crazy new cellular automaton implementation works!
18:25:42 <OceanSpray> OTZ
18:25:43 <Cale> !paste
18:25:43 <hpaste> Haskell paste bin: http://hpaste.org/
18:25:49 <OceanSpray> it's been pasted.
18:25:51 <matt__r> jfredett: check out daring fireball
18:26:00 <OceanSpray> at...
18:26:08 <OceanSpray> http://hpaste.org/2086#a2
18:26:16 <jfredett> maybe browns? :/
18:26:22 <Cale> OceanSpray: Text.ParserCombinators.Parsec
18:26:30 <Cale> (Not Test)
18:26:39 <OceanSpray> yeah, that's been fixed already
18:26:46 <Cale> oh, I see
18:26:50 <Cale> What's the new error?
18:26:55 <jfredett> matt__r: go get your sister to design my blog, :P
18:26:56 <OceanSpray> well...
18:27:19 <Cale>     Couldn't match expected type `TokenParser st'
18:27:19 <Cale>            against inferred type `GenParser Char () LispVal'
18:27:20 <Lycurgus> funny he doesn't mention latex2html
18:27:24 <Cale>     In the first argument of `lexeme', namely
18:27:24 <Cale>         `(lispSym <|> (lispPair <|> (lispStr <|> lispNum)))'
18:27:28 <matt__r> OceanSpray: too much to take in - do you have some test for the simple parsers?
18:27:49 <dibblego> "The most important open question of complexity theory is whether the complexity class P is the same as the complexity class NP, or is merely a subset as is generally believed." -- shouldn't this be s/subset/superset?
18:28:04 <dibblego> i.e. P is a superset of NP
18:28:12 <OceanSpray> what do you mean, test for the simple parsers?
18:28:14 <Cale> ah
18:28:22 <mrd> dibblego: huh
18:28:34 <matt__r> OceanSpray: like listNum and listStr
18:28:40 <Lycurgus> dibblego: don't think so.
18:28:41 <samreid> dibblego: no
18:28:50 <Cale> lexeme is an operation on TokenParsers, which extracts the lexeme parser field.
18:28:53 <mrd> dibblego: the question is P \subset NP, or P = NP
18:29:04 <matt__r> OceanSpray: with parsec, I always build up very slowly, testing each parser as I go
18:29:11 <dibblego> mrd, yes, so the statement is worded poorly
18:29:13 <OceanSpray> alrighty
18:29:30 <OceanSpray> commenting out stuff now
18:29:30 <Cale> What were you intending lexeme to do there?
18:29:35 <Cale> Why?
18:29:56 <Cale> You can probably comment out the import of Text.ParserCombinators.Parsec.Token
18:30:04 <matt__r> OceanSpray: However, if that was your error case posted then it looks like lexeme is just getting an argument of the wrong type - but I don't know much about lexeme
18:30:05 <mrd> dibblego: i read it as (1) "P is the same as NP" or (2) "P is a subset of NP"
18:30:06 <Cale> and then define lexeme appropriately
18:30:11 <mrd> which sounds right
18:30:12 <OceanSpray> I thought you could combine it so that it parses those things passed to it and then ignores the trailing whitespace.
18:30:15 <dibblego> mrd, yeah so did I second time :)
18:30:52 <matt__r> OceanSpray: I am usually explicit about whitespace when using parsec
18:31:34 <matt__r> spaces is very helpful there
18:31:48 <Cale> Oh, you also appear to be using whiteSpace, that's also from .Token
18:32:17 <OceanSpray> yup
18:32:24 <samreid> OceanSpray: TokenParser is used for making a bunch of useful parsers out of a LanguageDef, it seems
18:32:33 <OceanSpray> actually, I'm really comfused right now
18:32:42 <OceanSpray> how DO you use TokenParser?
18:32:57 <OceanSpray> I read that manual, but it made no sense at all.
18:32:59 <matt__r> OceanSpray: I don't
18:33:10 <mrd> basically
18:33:12 <samreid> OceanSpray: the real type of whiteSpace is whiteSpace :: TokenParser st -> CharParser st ()
18:33:21 <mrd> define a lexer using makeTokenParser and some definition
18:33:37 <mrd> then, you supply that lexer as the first parameter to the various Token-based combinators. like whiteSpace.
18:33:42 <OceanSpray> ah
18:33:48 <mrd> for example, lexer = makeTokenParser haskellStyle
18:33:49 <OceanSpray> that made a lot more sense
18:34:01 <mrd> myWhiteSpace = whiteSpace lexer
18:34:17 <mrd> actually, i usually import Token qualified, so i don't pollute my namespace
18:34:35 <OceanSpray> I'm going to try that
18:34:38 <mrd> and finally
18:34:52 <mrd> overall = do { whiteSpace; x <- myStuff; eof; return x }
18:35:01 <mrd> should be the combinator supplied to parse.
18:35:28 <mrd> where whiteSpace = Token.whiteSpace lexer
18:35:51 <OceanSpray> hm
18:35:52 <samreid> OceanSpray: TokenParser was defined by  data TokenParser st = TokenParser { identifier :: CharParser st String, reserved :: String -> ..., ..... } -- and Haddock draws the docs for dataconstructors with named fields in the same fashion
18:36:05 <OceanSpray> how do I make a LanguageDef?
18:36:20 <mrd> i would base it off an existing one
18:36:22 <OceanSpray> it gives me a bunch of "not in scope"
18:36:28 <mrd> emptyDef, haskellStyle.  get them from the .Language mod
18:36:41 <Cale> OceanSpray: You tend not to though.
18:36:46 <mrd> its a big record type, you can set various fields to useful things.
18:37:16 <mrd> ?where parsec
18:37:17 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
18:37:21 <Cale> I suppose you can sort of use the Haskell one :)
18:37:30 <mrd> the parsec documentation has a nice section on this
18:37:38 <mrd> @hoogle trim
18:37:38 <lambdabot> No matches found
18:38:08 <samreid> OceanSpray: seems like you should want to stick with .Prim and .Char for now.
18:38:49 <Cale> A bigger problem is that lispExpr is a Parser [LispVal], but in various places in that code, it appears to be used as if it was a Parser LispVal
18:38:50 <samreid> er, .Combinator and .Char and .Prim... er... Parsec
18:39:17 <mrd> @localtime mrd
18:39:21 <lambdabot> Local time for mrd is Sun Aug  5 21:38:51 2007
18:39:22 <samreid> also, your lispExpr can't parse expressions that have sub-expressions
18:39:30 <Cale> So either its type needs to change, or the places which use it need to use it differently.
18:39:54 <Cale> Well, lispPair calls lispExpr
18:40:00 <Cale> (via inParens)
18:40:16 <samreid> oh, you have a point
18:40:32 <Cale> But there's a problem there, because you have
18:40:35 <samreid> if you want to write (+ . (2 . (3 . ())))
18:40:37 <Cale> car <- lispExpr
18:40:50 <Cale> which means that car is a list of LispVals
18:41:01 <Cale> But then you have  return (Pair car cdr)
18:41:14 <Cale> which seems to require that car be a LispVal
18:42:25 <OceanSpray> I changed the type of lispExpr shortly after I pasted that
18:42:46 <OceanSpray> now it's a Parser LispVal
18:50:06 <OceanSpray> guys?
18:50:41 <samreid> yes?
18:53:23 <jfredett> http://disparatemathematician.blogspot.com/ --any better, folks?
18:53:25 <lambdabot> Title: The Disparate Notions of a Lowly Mathematician
18:54:12 <hpaste>  OceanSpray annotated "screw.hs" with "(no title)" at http://hpaste.org/2086#a3
18:55:43 <samreid> OceanSpray: why are you using a TokenParser?
18:56:18 <samreid> or a LanguageDef
18:56:26 <OceanSpray> does it matter?
18:56:34 <OceanSpray> besides
18:56:57 <OceanSpray> TokenParser shortened up several functions
18:57:22 <OceanSpray> see lispNum, lispStr and lispSym
18:58:36 <Cale> Seems reasonable :)
19:00:15 <RyanT5000> how do i make GHC's heap play nicely with another one (presumably a libc heap)
19:00:47 <OceanSpray> now, hm
19:00:58 <OceanSpray> why isn't makeTokenParser in scope?
19:01:05 <OceanSpray> what do I have to import to get it?
19:01:22 <samreid> P.makeTokenParser
19:01:48 <OceanSpray> oh
19:01:49 <OceanSpray> right
19:02:17 <OceanSpray> and here come a host of new errors
19:04:25 <dons> RyanT5000: ?
19:04:30 <dons> play nicely?
19:05:02 <RyanT5000> dons: i'm linking to libmozjs, and when i allocate and deallocate a bunch of objects with both it and haskell, i eventually get a weird error
19:05:27 <RyanT5000> dons: in ghci, it's something like "unknown bytecode <random number here"
19:05:59 <RyanT5000> which i presume means that libmozjs is overwriting ghci stuff
19:06:17 <dons> ok, sounds like a gc bug. you should report that with a test program with exactly how to reproduce it
19:06:27 <dons> see what happens in ghc, too. since ghci/bytecode is quite a different beast
19:06:32 <RyanT5000> alright
19:06:57 <dons> it is possibly you're doing something wrong: once you call C, you better be sure the C is well behaved
19:07:22 <SamB> do not neglect the possibility of a libmozjs bug ;-)
19:07:34 <SamB> or user error
19:07:41 <RyanT5000> yeah, certainly it could be me or libmozjs
19:08:14 <RyanT5000> i'm only doing allocation with mallocForeignPtr, newStablePtr, and libmozjs functions
19:08:40 <SamB> hmm. apparantly watching shakespear plays does not affect your genius rating on Project Euler
19:08:59 <wli> omfg "genius rating?"
19:09:47 <OceanSpray> ok, I need a way to say "try these parsers, and if none of them match, put this value in this variable"
19:12:33 <allbery_b> variable?
19:12:39 <OceanSpray> constant
19:12:41 <OceanSpray> whatever
19:12:47 <OceanSpray> assign it
19:13:04 <RyanT5000> so, the GHC program is doing something totally unexpected
19:13:33 <SamB> wli: well it says "you are x% genius" depending on how many problems you've solved
19:13:53 <SamB> really what it should say is not genius, but something a bit less inventive-sounding...
19:13:53 <Cale> OceanSpray: do you mean, return this value?
19:13:58 <OceanSpray> yes
19:14:02 <Cale> return
19:14:17 <Cale> return x is the parser which does no parsing and returns x
19:14:20 <RyanT5000> i have a function mkRooted that (among other things) runs mallocForeignPtr and prints a "+", and then sets the finalizer of the foreignptr to a function that (among other things) prints a "-"
19:14:23 <OceanSpray> oh
19:14:24 <OceanSpray> thanks
19:14:28 <SamB> like "you are x% mad mathemetician" or something
19:15:11 <OceanSpray> alright, I got my parsers compiling right
19:15:15 <dolio> x% brute-force searcher.
19:15:16 <OceanSpray> now, on to testing...
19:15:19 <SamB> I was at like 11% or something before seeing Romeo and Juliet, and now (after finishing the solution for problems 18 and 67) I'm at 13%
19:15:46 * SamB <3 free shakespeare
19:16:27 <SamB> dolio: "brute force" is a relative term
19:16:35 <SamB> I had to implement the Sieve of Atkin, anyway
19:17:08 <dolio> Well, a lot of the early ones are pretty easy to solve without thinking much about the problem at all.
19:17:14 <SamB> and I used dynamic programming at least twice so far (three times if you count 18 and 67 seperately)
19:17:19 <dolio> They put an end to that after a while.
19:17:39 <dolio> And, yeah, dynamic programming lets you solve even some of the harder ones pretty mindlessly.
19:17:53 <jfredett> Project Euler?
19:18:01 <SamB> I have to admit a LOT of the individual problems have been solved without much thinking about them
19:18:06 <SamB> by me
19:18:37 <SamB> but some of that was because I could reuse something I made for another problem
19:18:40 <dolio> Same here. If they require thought and reading, I usually get sidetracked. :)
19:18:42 <jfredett> the higher numbered problems get alot tougher
19:18:49 <SamB> not because the problem didn't require thinking
19:18:49 <jfredett> my favorite was the monopoly simulation
19:19:06 <SamB> and I think a lot of it was because I wrote in a language with bignums and lazy lists ;-)
19:19:34 <OceanSpray> uh...
19:19:48 <SamB> OceanSpray: hmm?
19:19:55 <SamB> don't mind me! state your concerns
19:20:22 <jfredett> yah, noone really pays attention to SamB most of the time, we just humor him every now and again. :)
19:20:25 <OceanSpray> something about not being able to use show
19:20:36 * jfredett pokes SamB.
19:20:38 <jfredett> :)
19:20:42 * SamB ducks
19:20:46 <dolio> I must say, my favorite Haskell solution on that site is for the triangle path search.
19:20:56 * SamB actually tries to strangel jfredett 
19:21:00 * jfredett oversteps and loses balance, falling to the floor
19:21:12 <dolio> I used dynamic programming for that, but someone else wrote a one-liner with foldr.
19:21:15 * jfredett corrects SamB as he's being throttled, "It's Strangle"
19:21:26 <SamB> dolio: did it work for 67 too?
19:21:32 <SamB> or was that a different one?
19:21:42 <SamB> which problem number do you mean?
19:21:47 <OceanSpray>     Possible fix: add an instance declaration for (Show LispVal)
19:21:47 <dolio> Was 67 just a much larger version of a previous problem?
19:21:52 <OceanSpray> how do I do that?
19:22:07 <SamB> 67 is a much larger version of 18
19:22:13 <SamB> which is not brute-forceable
19:22:22 <SamB> dolio: have you done 67 yet?
19:22:31 <dolio> Yes, 18 and 67.
19:22:34 <SamB> okay.
19:22:35 <jfredett> at the end of your structure, OceanSpray
19:22:44 <jfredett> add a deriving Show
19:22:58 <SamB> I was going to say, if not, you could just re-use that dynamic program from 18
19:23:13 <jfredett> eg:
19:23:13 <jfredett> data LispList a = Nil
19:23:13 <jfredett>                       | Cons a List a
19:23:13 <jfredett>                       deriving Show
19:23:15 <dolio> Oh, actually, I just brute-forced 18 without dynamic programming.
19:23:20 <dolio> :)
19:23:23 <SamB> oh?
19:23:25 <jfredett> (hopefully the spacing was preserved there
19:23:28 <dolio> 67 required dynamic programming.
19:23:31 <jfredett> if not I can paste it)
19:23:46 <OceanSpray> hold on
19:23:57 <SamB> I probably would have used the dynamic programming way anyway
19:24:23 <SamB> easier than figuring out how to brute-force it ;-)
19:24:40 <hpaste>  OceanSpray annotated "screw.hs" with "(no title)" at http://hpaste.org/2086#a4
19:25:07 <SamB> dolio: so did you say someone got 67 with a single fold?
19:25:40 <samreid> OceanSpray: put  deriving Show  at the end of your  data LispVal  definition
19:25:45 <hpaste>  jfredett annotated "screw.hs" with "(no title)" at http://hpaste.org/2086#a5
19:25:52 <jfredett> right, OceanSpray, so that should fix it
19:25:55 <OceanSpray> ok
19:26:01 <dolio> SamB: More or less.
19:26:04 <jfredett> I just added "deriving Show" to the end of data LispVal
19:26:04 <samreid> or let jfredett do it
19:26:21 <OceanSpray> IT COMPILED
19:26:24 <OceanSpray> MWAHAHAHAHAHA!
19:26:24 <jfredett> you can usually derive alot of the simpler classes, (Eq, Ord, Show, etc)
19:26:35 <jfredett> you can also always write your own instance, too
19:26:36 <OceanSpray> now, to test it out
19:26:43 * OceanSpray crosses his fingers
19:26:46 <jfredett> eg instance Show LispVal where ...
19:27:07 <SamB> OceanSpray: it must surely work ;-P
19:27:12 <dolio> SamB: It's a complicated fold, but you can build it all out of standard combinators, as I recall.
19:27:14 <SamB> since, you know, it compiled
19:27:31 <SamB> dolio: easier my way I think
19:27:32 <OceanSpray> [karl@myhost Haskell]$ ./screw "(a (b c))"
19:27:32 <OceanSpray> value: Pair (Symbol "a") (Pair (Pair (Symbol "b") (Pair (Symbol "c") Null)) Null)
19:27:37 <jfredett> OceanSpray: yah, typically, if it typechecks, it'll probably do what you want
19:27:42 <SamB> I actually did it very bunglingly
19:27:42 <OceanSpray> hm
19:27:44 <OceanSpray> interesting
19:27:56 <mrd> @hoogle popen
19:27:57 <lambdabot> No matches found
19:28:06 <jfredett> no dotted pairs for your lisp, OceanSpray? :P
19:28:14 <OceanSpray> a lot of "Pair"s and "Symbol"s in there
19:28:21 <SamB> OceanSpray: it doesn't work quite as well on more advanced programs
19:28:23 <OceanSpray> well, I haven't worked on the output yet
19:28:26 <jfredett> well, you have a pair of a and (b c)
19:28:37 <SamB> but it's ALMOST always a good sign when the program compiles ;-)
19:28:42 <jfredett> and then a pair of b and (c null)
19:28:47 <OceanSpray> SamB, what do you mean?
19:28:49 <dolio> SamB: Did you solve those two?
19:28:51 <OceanSpray> more advanced?
19:28:52 <jfredett> yah- i dont think its parsing right
19:28:53 <mrd> is there a way to grab the output of a runCommand into a String
19:28:53 <SamB> (if you were expecting to have broken compilation, it's a bad sign)
19:28:57 <mrd> (direct)
19:29:00 <SamB> dolio: which two?"
19:29:06 <SamB> 18 and 67?
19:29:09 <dolio> SamB: Yeah.
19:29:12 <SamB> yeah.
19:29:19 <jfredett> you should be getting (Pair (Symbol 'a') (Pair (Symbol 'b') (Symbol 'c')))
19:29:23 <jfredett> or something like that
19:29:25 <SamB> those are the two I finished after Romeo and Juliet
19:29:32 <dolio> SamB: "main = print (foldr1 reduce triangle) where reduce a b = zipWith (+) a (zipWith max b (tail b))"
19:29:39 <OceanSpray> jfredett, that would give (a b c)
19:29:48 <SamB> dolio: hmm.
19:29:50 <OceanSpray> actually, (a b . c)
19:29:50 <SamB> that's cute
19:29:54 <jfredett> hmm
19:30:01 <jfredett> i dunno, I've never really wrote a lisp parser
19:30:03 <dolio> Yeah.
19:30:06 <jfredett> so there you go
19:30:07 <jfredett> :P
19:30:15 <OceanSpray> brb dinner
19:30:26 <jfredett> hmm, back to work for me
19:30:28 <SamB> jfredett: the guy is right
19:30:36 <SamB> that would be (a b . c)
19:30:48 <wli> Parsing Lisp doesn't sound terribly difficult, but anyway.
19:31:12 <SamB> I think it's harder to print than to parse
19:31:13 <jfredett> SamB, okay
19:31:17 <jfredett> sounds good to me
19:31:18 <jfredett> :P
19:32:11 <SamB> jfredett: I don't know about your earlier query though
19:32:27 <SamB> I think his printer probably does need work
19:32:46 <jfredett> prolly
19:32:48 <jfredett> no worries
19:33:00 <jfredett> bah, stupid mtl library. :/
19:33:17 <jfredett> hmm
19:33:26 <SamB> hey, as long as it turns out more sensible than the one that was in the ICFP 2006 contest
19:33:28 <Cale> jfredett: What's wrong with it?
19:33:53 <SamB> their LISP printer had wierd errors
19:34:00 <jfredett> I'm trying to simultaneously use ghc-6.6.1 and get xmonad to emerge in gentoo
19:34:31 <SamB> jfredett: maybe you should compile it manually instead?
19:34:41 <jfredett> SamB I might have too
19:34:45 <SamB> dcoutts: what's the point of an xmonad ebuild anyway?
19:35:33 <jfredett> bah, it's just complaining about ghc-6.4.2
19:35:41 <jfredett> theres gotta be a way to fix it
19:35:42 <jfredett> :/
19:37:53 <kilimanjaro> install 6.6.whatever?
19:38:05 <kilimanjaro> ohh sorry
19:38:06 <kilimanjaro> I misread
19:38:10 <jfredett> well, 6.6.1 is installed
19:38:21 <jfredett> it seems to want 6.4, these are mutually exclusive though
19:38:24 <SamB> jfredett: see what code is responsible for the complaint?
19:38:25 <kilimanjaro> outdated in ports?
19:38:29 <kilimanjaro> portage
19:38:31 <kilimanjaro> whatever it is called
19:38:40 <SamB> I couldn't get xmonad to build WITH 6.4
19:38:52 <jfredett> yah, well its the mtl-1.0 library
19:38:56 <jfredett> thats causing the problem
19:39:03 <SamB> I have an mtl-1.0 library
19:39:16 <SamB> maybe you should unpull stuff until it works ;-)
19:39:24 <jfredett> hmm
19:40:10 <SamB> there is an #xmonad too, btw
19:40:18 <jfredett> well, when I try to run it, it wants =dev-lang/ghc-6.4*
19:40:26 <SamB> what?
19:40:33 <SamB> are you still trying to ebuild it?
19:40:41 <SamB> emerge, whatever
19:40:42 <jfredett> yeh- I'm fiddling with settings
19:41:04 <SamB> debian isn't crazy enough to package stuff like xmonad. by which I mean Igloo isn't crazy enoughto package it.
19:41:35 <SamB> I think it would be easier to build it manually
19:41:46 <jfredett> probably,
19:46:38 <jfredett> SamB, installing manually worked, :/
19:59:40 <hpaste>  kpreid pasted "surprisingly fast Life implementation" at http://hpaste.org/2088
19:59:55 <kpreid> and when I say "surprisingly fast", I mean "I was surprised it wasn't horribly slow"
20:00:26 <kpreid> and I think it's a clever representation
20:00:28 <jfredett> kpreid: Haskell is always full of surprises
20:00:29 <jfredett> :)
20:00:55 <OceanSpray> goddamn it
20:01:01 <OceanSpray> () doesn't parse right
20:01:07 <hpaste>  kpreid annotated "surprisingly fast Life implementation" with "OpenGL display" at http://hpaste.org/2088#a1
20:01:10 <jfredett> apparently, comonads are really good for cellular automata, kpreid
20:01:31 <sorear> ick, torus
20:01:51 * sorear plays Life on Z^2
20:01:58 <kpreid> sorear: I have one of those too.
20:02:10 <kpreid> sorear: I couldn't think of how to do it with this representation though.
20:02:48 <jfredett> I'd like to see a library for generating and displaying generic automata, (something like ALPACA, but in Haskell. :) )
20:02:51 <sfultong> when I saw Z^2 I thought an infinite grid of integers
20:03:16 <kpreid> jfredett: this is pretty generic; any suggestions?
20:03:25 <sorear> sfultong: What do you think it is now?
20:03:35 <sorear> sfultong: I *did* mean the infinite grid
20:03:45 <sfultong> oh... ok
20:03:59 <jfredett> kpreid: I'm no expert, I've only fiddled with ALPACA cursorily, so I guess not w/ the suggestions
20:04:03 <sfultong> then originally I thought it was some sort of handheld device
20:04:12 <sfultong> or... I mean, not originally
20:04:21 <kpreid> sorear: care to write a buildRandomInfinite?
20:05:10 <jfredett> i do like that the whole implementation of this bit only took what, 50-75 lines?
20:05:25 <kpreid> 75
20:05:31 <jfredett> nice
20:06:08 <sorear> :t Control.Monad.Writer.Writer
20:06:17 <lambdabot> forall a w. (a, w) -> Writer w a
20:06:21 <Cale> coderdave: How's Haskell going?
20:08:04 <OceanSpray> hm
20:08:10 <OceanSpray> now it gives me an infinite loop
20:08:17 * kpreid is disappointed nobody had anything to say about his grid representation.
20:08:26 <wli> kpreid: What grid is this?
20:08:35 <jfredett> i dont have the resources to run or comprehend your code
20:08:40 <jfredett> but it certainly looks nifty
20:08:51 <kpreid> wli: http://hpaste.org/2088
20:09:16 <dropdrive> Cale: I saw you talking to wli about getting co/monads from adjoint functors.  My question is, which of Haskell's standard (?) monads actually arise in this way?
20:09:52 <Cale> Well, it turns out that all of them do, in a couple of "trivial" ways.
20:10:41 <Cale> But I think the reader monad occurs in a more interesting way.
20:11:47 <sfultong> damn, hscurses only lets me use 8 custom colors at once
20:13:24 <dropdrive> Cale: How about something simple like the list monad?
20:14:08 <Randroid> "Haskell is always full of surprises." Isn't that the truth? No language has bent my mind the way this one has.
20:14:16 <sfultong> I guess linux allows you to have truecolor terminals in X or with framebuffer... but does anyone know if it's possible to have truecolor in ssh?
20:15:19 <Cale> sfultong: sure, I don't think ssh does any filtering of control codes.
20:16:01 <sfultong> ah, thanks
20:16:45 <sfultong> does this look broken to anyone else? http://www.haskell.org/all_about_monads/html/class.html
20:16:46 <lambdabot> Title: Doing it with class
20:17:17 <sorear> sfultong: I don't see anything obviously wrong
20:17:45 <sfultong> huh... it's all garbage on my browser
20:18:08 <sfultong> maybe my cache is messed up for some reason
20:18:38 <Cale> dropdrive: hmm... I don't immediately see a way that's not just one of the two ways that all monads arise from, but I don't know.
20:19:22 <dropdrive> Cale: Sorry, I'm really dense.  So what's the adjoint pair in this case?
20:22:25 <Tac-Tics> > sequence [id, (+1), (+2)] 0
20:22:26 <lambdabot>  [0,1,2]
20:22:47 <Tac-Tics> why is that giving me an error when I run in ghci?
20:23:02 <Tac-Tics> "No instance for (Monad ((->) a))"
20:23:30 <Tac-Tics> actually, what does that even mean
20:25:35 <sfultong> yeah, that error really confused me as well when I first saw it
20:26:06 <sfultong> I'm not certain, but I believe ghc thinks you are trying to use the reader monad
20:26:24 <Cale> dropdrive: Okay, do you know what the Kleisli category for a monad is?
20:26:39 <Cale> Tac-Tics: import Control.Monad.Instances
20:26:50 <Cale> (or Control.Monad.Reader, if you have an older GHC)
20:27:13 <Tac-Tics> what does that do?
20:27:21 <Tac-Tics> what is imported that makes it happy?
20:27:31 <Cale> Tac-Tics: It imports the instance of Monad necessary to make that work.
20:27:40 <Cale> Specifically, Monad ((->) e)
20:27:48 <sfultong> I don't think he actually wants the reader monad, though
20:27:54 <sfultong> ... do you, Tac-Tics?
20:27:55 <Cale> oh?
20:28:11 <glguy> Tac-Tics: if you want to do that without the ((->) e) monad, try: map ($ 0) [id,(+1),(+2)]
20:28:12 <dropdrive> Cale: I do, and now a Google search has answered my question.  Thanks.
20:28:17 <Cale> sequence [id, (+2), (*2), (^2), (2^)] 5
20:28:20 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
20:28:22 <lambdabot>  [5,7,10,25,32]
20:28:26 <Cale> dropdrive: oh, hehe
20:28:40 <Tac-Tics> what is -> I guess is the logical follow up question
20:28:44 <Tac-Tics> @src sequence
20:28:44 <lambdabot> sequence ms = foldr k (return []) ms
20:28:45 <lambdabot>     where
20:28:45 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
20:28:58 <Cale> dropdrive: Yeah, any monad factors via the Kleisli category and the Eilenberg-Moore category.
20:29:02 <Tac-Tics> I looked this up earlier today didn't I?
20:29:03 <Tac-Tics> hmm
20:29:06 <kpreid> -> is the function type constructor
20:29:06 <Cale> Tac-Tics: Let me define that better
20:29:12 <Tac-Tics> hehe
20:29:12 <Tac-Tics> yeah
20:29:14 <Cale> sequence [] = return []
20:29:30 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
20:29:57 <Cale> So it runs each of the actions in the list in turn, and returns a list of the results.
20:30:16 <OceanSpray> ok, I fixed the null parsing error
20:30:18 <Tac-Tics> in neither of those definitions does -> appear
20:30:22 <OceanSpray> NOW, it's on to printing
20:30:26 <Cale> -> is a type constructor
20:30:33 <Cale> Specifically, the type constructor of functions
20:30:37 <Tac-Tics> ah
20:30:47 <Cale> ((->) e) is that partially applied
20:30:52 <Tac-Tics> yeah
20:31:03 <Cale> So ((->) e) a = e -> a is the type of functions from e to a
20:31:28 <Cale> In this monad, an 'action' is just a function which takes a parameter of type e
20:31:29 <Tac-Tics> so ((->) e) is a monad then?
20:31:42 <Cale> and 'running' that action just consists of applying it
20:32:14 <Tac-Tics> sometimes I feel when I'm learning Haskell that all the bits of info are floating around in my brain, but they haven't congealed yet
20:32:14 <Cale> You can think of the value of type e to which the actions are being applied as a sort of 'global environment'
20:32:21 <Cale> So...
20:32:48 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
20:32:50 <lambdabot>  ("hello","olleh","HELLO")
20:33:13 <Cale> Does that help? :)
20:33:18 <OceanSpray> hey guys
20:33:34 <OceanSpray> how do I go about printing out data structures?
20:33:35 <Tac-Tics> Cale, yes it does help. Now that I know it is hopelessly complicated, I can give up
20:33:38 <Tac-Tics> Cale++
20:33:39 <Cale> hehe
20:33:42 <Tac-Tics> j/k, I'll get it soon
20:33:45 <Cale> It's not that bad, really :)
20:33:53 <Cale> Each of the 'actions' is being 'run' by applying it to the parameter that the whole computation is passed.
20:33:55 <Tac-Tics> why do people keep saying that?
20:34:03 <Cale> So in that case, I passed it "hello"
20:34:06 <Tac-Tics> yeah
20:34:21 <Cale> and 'id', the identity function, returned "hello"
20:34:26 <jfredett> Tac-Tics: because its not, its just that people dont _think_ they can understand these things, so they sabotage themselves
20:34:27 <Cale> reverse returned "olleh"
20:34:36 <Cale> and map toUpper returned "HELLO"
20:34:39 <jfredett> the concept is easy, convincing yourself the concept is easy is hard
20:34:58 <Cale> jfredett: yep :)
20:35:18 <sfultong> the concept is easy... figuring out why you don't understand it is hard :-P
20:35:34 <Binkley> /leave #haskell
20:35:36 <Binkley> oops
20:35:38 <Cale> So this monad somehow arranges that every computation gets passed that parameter that we passed to the do-block as a whole.
20:35:57 <sfultong> I meant you as in.... one
20:36:09 <Cale> So, how might it do this?
20:36:22 <Cale> Well, first of all, let's decide what 'return' should do :)
20:36:44 <Cale> 'return x' is always the computation which ignores everything else that's going on, and just returns x regardless.
20:37:03 <Cale> In this case, our computations are functions which take a parameter of type e
20:37:13 <Cale> So  return x = \e -> x
20:37:33 <Cale> It's just going to ignore that parameter and return x
20:37:47 <Cale> > (return 5) 7
20:37:48 <lambdabot>  5
20:37:53 <Cale> seems right :)
20:38:11 <dibblego> ?type return 5
20:38:13 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
20:38:29 <Cale> In this case,  return 5 :: e -> Integer
20:38:40 <Cale> (or Num n => e -> n)
20:39:30 <Cale> Now, bind -- before we go on, let's look at what the type of bind should be:
20:39:47 <Cale> In general, (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
20:40:09 <Cale> So in this case, (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
20:40:31 <Tac-Tics> so then why aren't monad instances kept in the prelude?
20:40:32 <Cale> Or...
20:40:45 <Cale> I really think this instance should be in the Prelude, but it's not.
20:40:51 <Tac-Tics> yeah
20:40:59 <Tac-Tics> so what is the actual monad then?
20:41:07 <Tac-Tics> @type sequence
20:41:08 <Cale> The actual monad is ((->) e)
20:41:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:41:21 <Tac-Tics> when I do sequence [id, (+1), (+2)] 0
20:41:31 <Cale> sequence :: [e -> a] -> e -> [a]
20:41:36 <Cale> In this monad.
20:41:49 <Cale> That should almost tell you what it does.
20:41:58 <Cale> There's only one nonstupid function of that type.
20:41:59 <Tac-Tics> yeah
20:42:28 <Cale> Should I finish describing what bind does?
20:42:39 <Cale> You could probably write it yourself, given its type.
20:42:49 <Cale> (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
20:43:18 <Cale> (f >>= g) x = g (f x) x
20:43:45 <Cale> To 'run' f, we apply it to x
20:43:57 <Cale> then pass the result to g to get another action to run
20:43:58 <Tac-Tics> yeah
20:44:06 <Cale> and then run that by applying it to x
20:44:07 <Tac-Tics> I don't get where the second x comes from yet
20:44:25 <Tac-Tics> so f takes one parameter
20:44:27 <Tac-Tics> and g takes two
20:44:28 <Cale> right
20:44:33 <Tac-Tics> so if I have
20:44:38 <Tac-Tics> f >>= g >>= h
20:44:51 <Tac-Tics> h would be of... umm... two still?
20:45:16 <Cale> >>= is left associative...
20:45:20 <Cale> (f >>= g) >>= h
20:45:22 <Cale> yes
20:45:36 <Cale> But if you had:
20:45:56 <Cale> f >>= \x -> g >>= h
20:46:03 <Cale> then g would just have one again
20:46:15 <Cale> (and h would have two)
20:47:01 <Tac-Tics> > (do {x <- id; y <- reverse; z <- map toUpper; return (x,y,z)}) "hello"
20:47:02 <lambdabot>  ("hello","olleh","HELLO")
20:47:17 <bos> @pl \x g a -> g (f a x)
20:47:18 <lambdabot> flip (.) . flip f
20:47:23 <OceanSpray> for a data structure LispVal = Pair LispVal LispVal ,
20:47:30 <Cale> So here, "hello" is that x, and it just gets passed down to everything.
20:47:33 <OceanSpray> how do you access the first and the second?
20:47:34 <Tac-Tics> yeah
20:47:42 <kpreid> OceanSpray: pattern matching
20:47:47 <OceanSpray> ?
20:47:51 <Cale> OceanSpray: pattern matching. In an expression, use case
20:47:58 <Cale> case mylispval of
20:48:09 <Cale>    Pair x y -> ...x...y...
20:48:27 <OceanSpray> oh, right
20:48:29 <Cale> Tac-Tics: Kind of a neat monad, eh?
20:48:30 <Tac-Tics> id >>= (\x -> reverse >>= (\y  -> map toUpper >>= (\z -> (x, y, z))))
20:48:37 <Tac-Tics> I'm sure it's very neat
20:48:42 <Tac-Tics> I need to just try it out a few times
20:48:45 <Cale> > id >>= (\x -> reverse >>= (\y  -> map toUpper >>= (\z -> (x, y, z))))
20:48:46 <lambdabot>  Couldn't match expected type `[Char] -> b'
20:48:53 <Tac-Tics> if ghci didn't exist, I would never have bothered with Haskell at all
20:49:08 <Cale> > (id >>= \x -> reverse >>= \y  -> map toUpper >>= \z -> return (x, y, z)) "hello"
20:49:09 <lambdabot>  ("hello","olleh","HELLO")
20:49:12 <bos> @pl \f z xs -> foldr (flip (.) . flip f) id xs z
20:49:12 <lambdabot> flip . flip foldr id . (flip (.) .) . flip
20:49:14 <Tac-Tics> the first week I played with Haskell, the error messages from wrong types almost got me to give up on it
20:49:21 <Tac-Tics> but I fought through the difficulties
20:49:23 <Tac-Tics> and now I see
20:49:27 <Tac-Tics> they don't actually ever end
20:49:29 <Cale> > (id >>= (\x -> reverse >>= (\y  -> map toUpper >>= (\z -> return (x, y, z))))) "hello"
20:49:30 <Tac-Tics> but I'm cool with it by now
20:49:31 <lambdabot>  ("hello","olleh","HELLO")
20:49:40 <Cale> Tac-Tics: Oh, they do :)
20:49:50 <Cale> Tac-Tics: How long have you been learning?
20:49:55 <Cale> Just a couple weeks?
20:49:59 <Tac-Tics> what is Haskell good at once you're done learning it all?
20:50:02 <Tac-Tics> pretty much
20:50:05 <Tac-Tics> almost a month I think
20:50:18 <Cale> Yeah, I didn't feel too comfortable until around 2 months.
20:50:20 <OceanSpray> when using case,
20:50:30 <OceanSpray> how do you get 'else'?
20:50:35 <SamB_XP_> OceanSpray: _
20:50:37 <Cale> _ -> ...
20:50:43 <OceanSpray> oh ok
20:50:44 <OceanSpray> thanks
20:50:48 <Cale> _ is the pattern which binds no variables, and matches everything
20:50:48 * chessguy still doesn't feel comfortable after almost a year :)
20:50:56 <SamB_XP_> or even x ->
20:51:49 <Tac-Tics> I can't imagine how impossible and inaccessable the language must be to someone who hasn't done any FP at all
20:51:50 <Cale> Tac-Tics: But there's always some new esoteric thing which you could learn :)
20:51:56 <Tac-Tics> yeah
20:52:00 <Tac-Tics> Esoteric is my middle name
20:52:20 <chessguy> Tac-Tics, not impossible, just...mind-expanding
20:52:22 <Cale> Tac-Tics: Because this is a research language, so while you're learning, there are people out there coming up with new cool things for you to try out :)
20:52:38 <OceanSpray> Haskell is a research language?
20:52:40 <chessguy> i didn't know any FP before haskell, but i've learned a TON from it
20:52:41 <Cale> Yes :)
20:52:51 <OceanSpray> oh wow
20:52:52 <Tac-Tics> I just wish Haskell had a wider range of libraries
20:52:58 <OceanSpray> it's pretty practical as such
20:53:05 <Tac-Tics> It has a nice library set with OpenGL and Networking and GTK and such
20:53:11 <Cale> OceanSpray: yes, that's why I love it :)
20:53:22 <Cale> OceanSpray: It's the most practical research language ever :)
20:53:50 <Tac-Tics> but I come from Python where... if you need a library for grading the quality of livestock, it comes standard with the installation
20:54:06 <Cale> heh
20:54:15 <SamB_XP_> OceanSpray: you didn't see "A Taste of Haskell"?
20:54:21 <OceanSpray> nope
20:54:32 <Cale> Tac-Tics: Yeah, our community isn't yet large enough to support such a vast range of libraries.
20:54:33 <SamB_XP_> SPJ mentioned that near the beginning
20:54:42 <SamB_XP_> Tac-Tics: ... not quite
20:54:48 <chessguy> @remember Tac-Tics but I come from Python where... if you need a library for grading the quality of livestock, it comes standard with the installation
20:54:48 <lambdabot> Done.
20:54:52 <Cale> Tac-Tics: There have been a lot of libraries written in Haskell and then left to decay, unfortunately.
20:54:56 <Tac-Tics> yeah
20:55:00 <SamB_XP_> Tac-Tics: and if it did, it wouldn't work right!
20:55:04 <Tac-Tics> yeah
20:55:07 <Cale> (and they decay kinda rapidly, because Haskell changes a lot)
20:55:09 <wli> Same as any other language.
20:55:09 <Tac-Tics> I've only run into that with Python once
20:55:16 <SamB_XP_> Cale: some of them may be recoverable
20:55:28 <Cale> Oh, I'm sure they are. :)
20:55:46 <Cale> It'd largely be fixing pretty minor things.
20:56:15 <Cale> Like how fromInt no longer exists.
20:58:29 <Cale> A GTK version of Fudgets would be pretty cool :)
20:59:19 <timthelion> is IO impossible in a function which recturns X but not IO?
20:59:26 <Cale> timthelion: yes
20:59:38 <Cale> timthelion: What is it that you're trying to do?
20:59:43 <wli> timhellion: What you need there are (of course) monad transformers.
20:59:52 <Cale> Not necessarily :)
21:00:01 <Tac-Tics> What gets me about Haskell is I wouldn't know how to structure larger programs
21:00:04 <timthelion> I'm trying to call allocNamedColor in an xmonad layout algorith
21:00:05 <timthelion> m
21:00:09 <wli> Well, there are exceptions to everything.
21:00:20 <Tac-Tics> Even when I'm not using an OOP language, I still think in terms of mutable data structures
21:00:24 <SamB_XP_> Tac-Tics: well. it's easier in Haskell than in other languages
21:00:38 <Cale> I think of monad transformers as a way to construct monads I'm interested in, rather than a way to get effects to where I want them.
21:00:48 <jfredett> Tac-Tics: That'll change, eventually
21:00:49 <timthelion> Tac-Tics: the thing about unix, is that you oughtn't make larger programs
21:00:53 <Cale> ... and I think of monads as domain specific languages
21:00:58 <dibblego> Tac-Tics, even when I use an imperative language, I think in terms of immutable data structures (actually, so does everyone else if you quiz them)
21:01:01 <SamB_XP_> what do monad transformers have to do with effects ;-)?
21:01:07 <jfredett> Immutable structures are far more useful...
21:01:35 <Tac-Tics> maybe I should redo my statement
21:01:41 <Tac-Tics> It's really hard to hack a haskell program
21:01:47 <SamB_XP_> Tac-Tics: what kinds of programs do you write?
21:02:04 <Tac-Tics> in python, I usually start out with just making everything global to start with, then when I figure out where I'm going, I wrap stuff up into classes
21:02:13 <Tac-Tics> SamB_XP_: I don't even know X-D
21:02:19 <wli> Tac-Tics: You're not supposed to hack. You're supposed to work things out before you start.
21:02:34 <Tac-Tics> hacking is a way to discover what it is you are trying to work out
21:02:34 <SamB_XP_> I write bottom-up
21:02:36 <jfredett> wli, true that.
21:02:36 <Cale> timthelion: hmm, can you have it take the colour as a parameter instead?
21:02:48 <SamB_XP_> usually
21:02:49 <dibblego> wli, no the compiler is supposed to fail because you haven't worked things out from the start :)
21:02:56 <wli> Tac-Tics: It works differently.
21:03:20 <wli> Tac-Tics: You want to start by modelling small parts of your problem, and then piecing those parts together into a larger model of it.
21:03:26 <SamB_XP_> Tac-Tics: what do your python programs do?
21:03:41 <dibblego> hacking is a form of undisciplined thought, brought about by deficiencies in cognition and the ability to perform thought experiment; I suggest brain exercises such as chess
21:03:47 <dibblego> *inability
21:03:53 <glguy> do any of you have UTF-8 support working in Debian
21:03:55 <timthelion> Tac-Tics: there have been 4 stages for me in learning to program, there's been the goto stage the functions but global stage and the rework indefinatly stage which I'm on right now, and then hopefully enlightenment
21:04:07 <wli> Tac-Tics: The way that breaks down is a little bit differently.
21:04:21 <SamB_XP_> glguy: not really
21:04:22 <Tac-Tics> I guess I don't write many large programs anyway
21:04:27 <wli> Tac-Tics: Essentially because the constructs are different.
21:04:32 <Tac-Tics> but the last thing I did that I really liked was a word game
21:04:37 <Cale> Tac-Tics: Here, you tend to start out with the interesting bits of your program -- that is, the model itself, if you're into OO-speak (model-view-controller). Haskell programmers tend to think of I/O after the fact in most things.
21:04:37 <timthelion> Cale: um, defaultLayouts doesn't return IO either :(
21:04:45 * wli primarily modifies large programs as opposed to writing them from scratch.
21:04:45 <SamB_XP_> xterm keeps crashing on me when I accidentally look at ELF files
21:04:55 <Tac-Tics> I wrote a multiplayer word game
21:04:58 <SamB_XP_> or .gz files
21:05:00 <Tac-Tics> where the server gives you a word
21:05:06 <Tac-Tics> and you have to find subwords of that word
21:05:11 <Cale> timthelion: hmm, I have no idea about the structure of xmonad. I suppose I could take a look.
21:05:16 <wli> A multiplayer network game sounds like fun.
21:05:28 <Tac-Tics> so "metropolis" has "pole" and "metro" and "met"
21:05:31 <Tac-Tics> but not "meatloaf"
21:05:41 <SamB_XP_> well, actually, one of the first things I might write would be a parser for my input data
21:05:55 <jfredett> Effectively, Programming is like playing with legos, you don't use giant bricks to build a lego building, you use lots of little bricks.
21:06:17 <Tac-Tics> jfredett, I like that
21:06:22 <wli> Databases could get interesting.
21:06:42 <timthelion> jfredett: no, you take the legos, and you heat up some watter, make a wax shell, put the legos in the water in, and let them melt into place.
21:06:51 <jfredett> Further, Lego's are immutable, a lego brick that isn't solid isn't worth much
21:07:12 <SamB_XP_> timthelion: what?
21:07:28 <SamB_XP_> wax shells good custom bricks do not make!
21:07:28 <jfredett> if lego bricks were made out of water, all that'd happen when you tried to use them is that you'd get wet.
21:07:38 <timthelion> SamB_XP_: if you pour hot enough water over them, they will melt!
21:07:47 <jfredett> SamB_XP_ == Yoda?
21:08:00 <SamB_XP_> timthelion: also... the wax would melt before the legos, no?
21:08:07 <timthelion> oh, shut up!
21:08:15 <jfredett> lol, pwnt.
21:08:16 <SamB_XP_> do I have to try it?
21:08:24 <Cale> Oh no, I feel an awful monad tutorial coming out of this conversation.
21:08:26 <timthelion> yes,
21:08:32 <SamB_XP_> I think you forgot the plaster step
21:08:44 <SamB_XP_> wax model.
21:08:48 <SamB_XP_> plaster mold.
21:08:51 <SamB_XP_> melt wax
21:09:03 <SamB_XP_> now you have an empty plaster mold
21:09:03 <OceanSpray> showVal (Pair car cdr) = --what the hell do I put here!?
21:09:20 <JBGood25> yes, lost wax casting might work
21:09:20 <SamB_XP_> OceanSpray: well, something like
21:09:21 <Cale> OceanSpray: some recursive thing?
21:09:36 <OceanSpray> I was thinking recursive
21:09:39 <SamB_XP_> "(" ++ showTail (Pair car cdr)
21:09:56 <Tac-Tics> have any of you used hsdl before?
21:10:23 <SamB_XP_> OceanSpray: I think that's what I did the last time I wrote a lisp printer. not sure.
21:10:40 <SamB_XP_> for all I know, that was in Python ;-)...
21:12:03 <SamB_XP_> OceanSpray: ... something like that
21:12:31 <SamB_XP_> perhaps it ought to be:
21:12:49 <SamB_XP_> "(" ++ showVal car ++ showTail cdr
21:13:12 <SamB_XP_> showTail Nil = ")"
21:13:21 <SamB_XP_> etc.
21:13:40 <SamB_XP_> OceanSpray: how does that sound?
21:14:05 <OceanSpray> orz
21:14:07 <mrd> btw, Text.PrettyPrint is nice for printing s-expressions
21:14:30 <SamB_XP_> this may well be!
21:14:38 <SamB_XP_> I don't think I've actually ever tried that
21:17:10 * wli notes Ratio really doesn't like polynomials despite their being integral domains.
21:17:36 <wli> I wonder if I can override that instance...
21:18:53 <OceanSpray> 'where' can be used in a function without do, right?
21:19:11 <OceanSpray> just showVal (Pair car cdr) = ...
21:19:20 <OceanSpray>                  where ...
21:19:21 <OceanSpray> ?
21:19:25 <dibblego> OceanSpray, ys
21:19:26 <dibblego> *yes
21:19:36 <OceanSpray> ok thanks
21:21:53 <Cale> okay, got xmonad to build using the new x11-extras
21:22:23 <dons> good, Cale.
21:22:27 <Cale> Looks like they modified things to be less haskellish?
21:22:30 <dons> yep, the darcs version needs the darcs X11-extras
21:22:39 <dons> oh? they?
21:22:40 <Cale> ah, okay
21:23:22 <Cale> x11-extras 0.2 looks slightly less Haskellish than 0.0. Names have changed to use underscores rather than camelCase
21:23:34 <SamB_XP_> Cale: huh?
21:23:39 <dons> they did?
21:23:46 <SamB_XP_> since when does X11 favor underscores?
21:23:59 <Cale> unless I'm smoking crack, which is quite possible :)
21:24:15 <dons> I think you're smoking crack, Cale
21:24:17 <Cale> hehe
21:24:28 <dons> one or two might have snuck in, I suppose. but the api didn't fundamentally change
21:25:06 <Cale> hmm...
21:25:18 <dons> look at Graphics.X11.Xlib.Extras.hsc
21:25:22 <Cale> oh, haha
21:25:33 <Cale> I think I might have an idea what went wrong...
21:25:45 <Cale> ah
21:25:47 <Cale> heh
21:26:15 <Cale> I just patched an *old* version of xmonad to work with x11-extras 0.2, rather than paying attention :)
21:26:32 <dons> ah scary
21:26:35 <Cale> (not having noticed that darcs put my new copy in xmonad_0
21:26:38 <Cale> )
21:26:58 <Cale> okay, that makes more sense :)
21:27:29 <Cale> Still, the names look a little less Haskellish in x11-extras 0.2 than they were in x11-extras 0.0
21:27:54 <sjanssen> Cale: yeah, we went with _'s for field names
21:27:59 <sjanssen> mostly following X11's lead
21:28:04 <Cale> ah
21:28:36 <dons> yeah, there's some X11 binding conventions being followed
21:29:32 <Cale> Oh, I need genuinely darcs versions of X11 and X11-extras?
21:29:39 <sjanssen> just X11-extras
21:29:49 <wli> Damn, no way to hide instances.
21:29:53 <sjanssen> the released X11-1.2.2 should be fine
21:30:40 <Cale> actually, if you guys are here, you should help timthelion :)
21:30:44 <wli> I don't think I'm capable of writing anything anyone would actually use anymore.
21:31:20 * wli shoots for a MUSH.
21:32:43 <hpaste>  OceanSpray annotated "screw.hs" with "screw" at http://hpaste.org/2086#a6
21:32:47 <wli> Argh! The HaskellDB tutorial has vaporized.
21:33:38 <wli> I've got another dumb idea.
21:33:59 <wli> Cale: Want a code monkey to write skeleton code for exercises in monad tutorials?
21:34:06 <Cale> OceanSpray: you might like to use  concat ["(", showVal car, showVal cdr, ")"]
21:34:30 <wli> Cale: Name the problems and I'll slap code together.
21:34:37 <SamB_XP_> Cale: that's not correct
21:34:50 <Cale> er, yeah, showTail, sorry :)
21:35:00 <OceanSpray> oh
21:35:01 <OceanSpray> ok
21:35:13 <Cale> (I just mean the concat usage, I didn't look too closely :)
21:37:20 <Cale> heh, clowns to the left, jokers to the right :)
21:37:58 <wli> undefined :: Either Clowns Jokers
21:38:43 <Cale> data Stack a = Stack { focus  :: !a        -- focused thing in this set
21:38:43 <Cale>                      , up     :: [a]       -- clowns to the left
21:38:43 <Cale>                      , down   :: [a] }     -- jokers to the right
21:38:43 <Cale>     deriving (Show, Read, Eq)
21:39:02 <dons> everyone loves that comment
21:39:39 <wli> I've not seen it.
21:40:47 <OceanSpray> now that I've got input and output figured out
21:41:02 <OceanSpray> I can move on to the meat of the problem
21:41:28 <OceanSpray> see, I'm implementing a fexpr-based lisp with first class environments
21:41:40 <Tac-Tics> ugg... new lesson being learned
21:42:01 <Tac-Tics> type X = X {a :: Int, b :: Int} declares functions named a and b in the function namespace
21:42:06 <Tac-Tics> so you can't do
21:42:13 <Tac-Tics> type Player = Player {id :: Int...}
21:42:22 <Tac-Tics> type Tank = Tank { id :: Int ...
21:43:01 <Cale> timthelion: Oh! X is a newtype over IO
21:43:15 <Cale> timthelion: Er, a newtype of a monad transformer over IO
21:43:41 <Tac-Tics> is there a good way to get by this limitation?
21:43:53 <Cale> timthelion: If you're constructing a computation of type X, you can use the 'io' function to lift an IO computation to the X monad.
21:44:16 <allbery_b> tac-tics: most of us use prefixes on the field names
21:44:17 <Cale> Tac-Tics: prefix the field extractors.
21:44:23 <Tac-Tics> yuck
21:44:26 <Cale> pId, tId
21:44:30 <allbery_b> there are other ways to hack around it, mostly ugly
21:44:36 <Cale> or playerId, tankId
21:44:41 <allbery_b> (for example, using typeclasses to share names)
21:44:45 <Cale> Or create a typeclass and write the extractors yoursel
21:44:46 <Cale> f
21:45:25 <allbery_b> but in general, yes, record syntax has quite a few anomalies.  wait until you get to play with updates :)
21:45:26 <Tac-Tics> if I put them in separate modules, I could make use of the qualification, couldn't I?
21:45:27 <timthelion> Cale: ok, thanks
21:46:13 <allbery_b> not to say annoyances
21:46:23 <allbery_b> yes, modules are another ugly hackaround
21:46:37 <allbery_b> but the difference between A.x and a_x is so minimal I'd not bother
21:51:01 <timthelion> what is the purpose of the Eq a => after :: but before the rest of the type definition?
21:52:44 * wli encounters trouble remember his password for the postgresql database.
21:53:15 <timthelion> wli: isn't that what the area under your keyboard is for?
21:53:26 <wli> timhelion: That's insecure.
21:53:44 <timthelion> wli: ;)
21:53:50 <Tac-Tics> Type class question!
21:53:55 <Cale> timthelion: It says that 'a' is any type which satisfies the class Eq
21:54:03 <Tac-Tics> In Eq, the minimum definition is (==)
21:54:09 <Tac-Tics> and (/=) is created automatically
21:54:20 <Tac-Tics> can you do those "minimum-and-automatic" definitions yourself?
21:54:26 <Cale> Tac-Tics: yeah
21:54:45 <Tac-Tics> do you just give the definitions in terms of the undefined operators/methods?
21:54:51 <timthelion> Cale: so it bassically culls the polymorphism to make for errors on build not on run?
21:54:51 <Cale> You can define default implementations in the class-definition.
21:54:58 <Cale> And in the instances, you're allowed to override them.
21:55:02 <Tac-Tics> ah
21:55:03 <Tac-Tics> coolness
21:55:24 <Cale> timthelion: It bounds the polymorphism, yeah. It is a genuine part of the type system too.
21:56:10 <Cale> timthelion: It's also not optional -- if you try to delete the typeclass constraint, you'll get an error when the function tries to use (==)
21:56:23 <timthelion> that's actually pretty cool.  I guess it makes a whole bunch of exceptions impossible since you don't get that evil cannot compair sometype bugs
21:56:29 <Cale> (So there's no potential for leaving it out and getting a runtime error)
21:56:34 <Cale> yeah
21:56:41 <OceanSpray> Are hashtables built into Haskell, or do I have to import a package?
21:56:50 <OceanSpray> while we're at it
21:56:51 <Binkley> OceanSpray: Data.Map
21:57:03 <Cale> OceanSpray: There's a package, but you probably want Data.Map, rather than a real hashtable.
21:57:03 <OceanSpray> what's the best way to represent variables?
21:57:12 <OceanSpray> ok, Data.Map
21:57:14 <dibblego> OceanSpray, by not using Haskell :)
21:57:22 <Cale> OceanSpray: variables?
21:57:31 <OceanSpray> well, symbols that point to values.
21:57:35 <wli> Okay, the problem is that my password is empty and somehow that doesn't work over the wire.
21:57:39 <dibblego> OceanSpray, Haskell does not have variables; nothing can vary
21:57:46 <Cale> dibblego: sure it does
21:57:49 <OceanSpray> I'm doing a lisp implementation
21:57:49 <Cale> f x = x + 1
21:57:49 <allbery_b> Data.Map or Reader / ReaderT
21:57:54 <Cale> x is a variable there :)
21:57:54 <OceanSpray> not Haskell
21:57:59 <timthelion> wli ofcourse it doesn't!
21:58:03 <dons> for a symbol table, people usually use Data.Map
21:58:04 <Binkley> variables don't, constants aren't
21:58:10 <dibblego> Cale, I put little subscripts on them in my head :)
21:58:25 <Cale> OceanSpray: If you're in IO, you probably want something like an IORef or an MVar.
21:58:40 <OceanSpray> what?
21:58:45 <OceanSpray> what are those?
21:58:45 <dons> isn't OceanSpray asking about how to represent lisp variables inside his interpreter, which is written in haskell?
21:58:53 <OceanSpray> dons, yes
21:58:55 <allbery_b> that's my impression
21:59:04 <dons> i.e. as values in the environment. so Data.Map Name Value
21:59:05 <Cale> An IORef is essentially a mutable cell which you can create, pass around, and update.
21:59:13 <Cale> (all in IO of course)
21:59:26 <allbery_b> State or maybe StateT IO
21:59:29 <Cale> :t Data.IORef.newIORef
21:59:31 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
21:59:37 <Cale> :t Data.IORef.readIORef
21:59:39 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
21:59:45 <Cale> :t Data.IORef.writeIORef
21:59:47 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
21:59:53 <timthelion> applyMagnifier :: Eq a => ModDo a
21:59:55 <timthelion> applyMagnifier r s wrs =
21:59:56 <dons> right, but these aren't what you want for OceanSpray's interpreter...
21:59:58 <Cale> Why does it have to say GHC.IOBase?
22:00:05 <timthelion> how can it take arguments yet not take arguments?
22:00:14 <Cale> timthelion: hm?
22:00:18 <dons> timthelion: expand what ModDo a is
22:00:24 <dons> its likely a type synomym for a function
22:00:29 <Cale> ah, I see
22:00:32 <timthelion> oh,
22:00:59 <dons> OceanSpray: so you'll want to import Data.Map, and define a variable and value type, for your symbol table
22:01:09 <dons> and then some operations on that type (get/set/scope etc)
22:01:23 <OceanSpray> right.
22:01:46 <OceanSpray> thing is, though
22:02:15 <OceanSpray> I've got a set! and bind!, which do different things,
22:02:29 <OceanSpray> namely, change the value and change the binding
22:02:43 <OceanSpray> does Data.Map allow for something like that?
22:02:51 <dons> ok. you'll need to write down the semantics for those operations then, in terms of how they update the symbol table
22:02:53 <Cale> OceanSpray: Since you're modelling a changing value, as you recursively evaluate the expression, you'll need to carry around that map, and pass a modified copy of the map down to future calls.
22:02:59 <dons> sure, its just a mapping of names to values.
22:03:21 <Cale> Note that a value can be added to a Data.Map in O(log n) time, due to sharing.
22:03:40 <OceanSpray> also, I've got first class environments.
22:03:42 <Cale> So it doesn't really create a full copy, even though the structure is immutable.
22:04:10 <OceanSpray> I know, a bit too much to chew for a beginner, but it's for a specific purpose.
22:04:20 <Cale> okay
22:04:31 <dons> yep, this is all fine though. people use Map to implement environments for interpreters all the time
22:04:34 <dons> ?docs Data.Map
22:04:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
22:05:06 <Cale> (you don't have to worry about the details I just mentioned, I'm just dissuading the idea that an immutable structure is going to hurt performance)
22:05:12 <Tac-Tics> what is the best way to define operators for addition and scalar multiplication for a vector type?
22:05:44 <Tac-Tics> if you try and use +
22:05:47 <Tac-Tics> it yells at you
22:05:56 <Tac-Tics> because it's in Num in the prelude
22:06:01 <Cale> Tac-Tics: define infix operators. I like  .+. for addition and *. for scalar multiplication
22:06:24 <Cale> Or <+> and *>
22:06:38 <dons> define an instance of Num for your vector type?
22:06:46 <Cale> (also, <* can be handy for multiplying by a scalar on the other side)
22:07:07 <Cale> Scalar multiplication has the wrong type for (*) to be used.
22:07:08 <dons> (though the math guys might yell at you if you do that, people have been known to do it)
22:07:21 <Cale> So you really can't.
22:07:32 <Cale> I suppose if it's R^3, you could make that cross product.
22:07:50 <Cale> It's kind of pointless though, since all the Num algorithms will actually break.
22:08:11 <Cale> Since they typically rely on properties which your instance won't have.
22:08:50 <Tac-Tics> what are the default infix strengths for + and *?
22:09:08 <Cale> infixl 6 +
22:09:11 <Tac-Tics> ah
22:09:11 <Tac-Tics> yeah
22:09:14 <Cale> infixl 7 *
22:09:15 <Tac-Tics> @info (*)
22:09:15 <lambdabot> (*)
22:09:17 <Tac-Tics> err
22:09:19 <Tac-Tics> yeah
22:09:20 <Cale> you can ask ghci
22:09:25 <dons> use :info in ghci
22:09:29 <Tac-Tics> I did
22:16:37 <RyanT5000> are there any type systems that can express things like commutativity, transitivity, etc.?
22:16:43 <sorear> Yes.
22:16:48 <RyanT5000> sorear: which?
22:16:52 <wli> Dependent type systems, of course.
22:17:08 <RyanT5000> wli: what? how can they express it?:
22:17:18 <sorear> Coq < Check plus_comm.
22:17:18 <sorear> plus_comm : forall n m : nat, n + m = m + n
22:18:02 <wli> RyanT5000: Basically list comprehensions over types and terms. "For all members of a type" sorts of affairs.
22:18:50 <RyanT5000> what about function reversibility; i presume coq can do that too?
22:18:50 <Cale> Wouldn't those be set comprehensions then?
22:19:24 <wli> RyanT5000: In essence all (\(x,y) -> x + y == y + x) [(x, y) | x <- [minBound .. maxBound], y <- [minBound .. maxBound]]
22:19:46 <wli> RyanT5000: Where minBound and maxBound can be infinite.
22:19:57 <wli> Cale: Technically yes.
22:20:07 <RyanT5000> wli: i still don't see how that relates to dependent types
22:20:24 <sorear> RyanT5000: sure, you can have forall x, foo (bar x) = x
22:20:27 <wli> RyanT5000: The property can be part of the type.
22:20:36 <sorear> RyanT5000: Because that forall is a dependant product.
22:20:46 <RyanT5000> sorear: hm
22:20:48 <Cale> x in T, y in T => x + y == y + x
22:20:51 <wli> (sorear's doing far better here)
22:20:54 <RyanT5000> wli: i obviously have a lot more to learn about dependent types
22:21:08 <sorear> RyanT5000: forall n m, n + m = m + n   means  (n :: nat) -> (m :: nat) -> (=) ((+) n m) ((+) m n)
22:21:35 <sorear> RyanT5000: Basically, dependent products are just like functions except that the return type can depend on the *specific* input.
22:21:50 <RyanT5000> sorear: yeah, i understand that
22:21:53 <sorear> RyanT5000: so you can write a function like
22:22:12 <RyanT5000> sorear: so if we have the type of (+) :: Int -> Int -> Int
22:22:21 <RyanT5000> how do i change that to make it also say "and it's commutative"?
22:22:25 <sorear> Coq < Check fun x : bool => if x return if x then nat else bool then 0 else true.
22:22:29 <sorear> fun x : bool => if x as x0 return (if x0 then nat else bool) then 0 else true : forall x : bool, if x then nat else bool
22:22:52 <sorear> RyanT5000: Usually one would do that as a separate property.
22:23:03 <sorear> Coq < Check plus.
22:23:03 <sorear> plus : nat -> nat -> nat
22:23:27 <sorear> So plus_comm takes any two numbers and returns a proof that + commutes them.
22:23:28 <RyanT5000> sorear: maybe the best way for me to learn this is just to start playing around with coq
22:23:56 <RyanT5000> sorear: ah, ok
22:27:13 <TSC> Can someone help me with this ST type error?
22:27:15 <hpaste>  TSC pasted "ST type error" at http://hpaste.org/2089
22:27:29 <TSC> It seems like the two "s" type variables are not unified
22:27:51 <TSC> If there's some other way to write the type annotation for the freeze line, I'd love to hear it
22:31:01 <SamB_XP_> TSC: you'd probably get better help if you pasted the whole thing
22:31:04 <SamB_XP_> ST is wierd like that
22:31:16 * SamB_XP_ goes to bed
22:31:31 <TSC> I think I've found a workaround
22:32:05 <TSC> I annotate the type of "before" somewhere else
22:34:36 <SamB_XP_> STArrays especially are rather finicky, type-wise
22:35:07 <SamB_XP_> well, STUArrays are worse
22:35:21 * SamB_XP_ wonders where he left his book...
22:35:51 <TSC> It's working now, happily
22:36:05 <coderdave> so /m h
22:36:08 <coderdave> fib 0 = 0; fib 1 = 1; fib n = f(n - 2) + f(n - 1)
22:36:10 <SamB_XP_> cool
22:36:11 <sorear> Yeah.  unsafePerformIO is much friendlier.
22:36:18 <coderdave> hm, there is something not right with that..
22:36:19 <SamB_XP_> sorear: agreed
22:36:27 <coderdave> i put in fib 2 and it returns 0
22:36:41 * SamB_XP_ actually goes upstairs now
22:36:43 <TSC> Shouldn't "f(n-2)" be "fib (n-2)" ?
22:36:45 <SamB_XP_> (found my book)
22:36:52 <coderdave> oh, do you need the space?
22:36:56 <TSC> No
22:37:00 <TSC> I mean fib, not f
22:37:02 <sorear> coderdave: No, you need the "ib"
22:37:10 <coderdave> oh, hehe
22:37:11 <sorear> fib 0 = 0; fib 1 = 1; fib n = f(n - 2) + f(n - 1)
22:37:13 <coderdave> its getting late..
22:37:27 <sorear> @let fib 0 = 0; fib 1 = 1; fib n = fib(n - 2) + fib(n - 1)
22:37:29 <lambdabot> Defined.
22:37:39 <sorear> WARNING!  exponential time
22:37:41 <TSC> > fib 5
22:37:42 <coderdave> yah, that was a silly mistake
22:37:43 <lambdabot>  5
22:37:52 <TSC> > fib 1000
22:37:55 <dons> hey coderdave. back for more lambda fun I see?
22:37:55 <lambdabot> Terminated
22:37:58 <TSC> Aww
22:38:12 <coderdave> dons, never left..still working on it :P
22:38:21 <dons> cool! :)
22:38:29 * wli attempts to refresh his memory wrt. databases.
22:38:56 <dons> writing fibonaccis is the helloworld of haskell programming, we even have a page on it, http://haskell.org/haskellwiki/The_Fibonacci_sequence
22:38:56 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
22:39:24 <Tac-Tics> In Haskell, what is a good solution to the problem of allowing certain global constants to be determined by some sort of config file?
22:39:28 <sorear> We have a much better page on factorials.
22:39:45 <sorear> Tac-Tics: Compile the config file into your program a la xmonad.
22:39:45 <dons> Tac-Tics: one way to do that is to suck them into a ReaderT monad
22:39:49 <TSC> Tac-Tics: Reader monad
22:39:56 <dons> or compile the file in, and just access them directly
22:40:23 <Tac-Tics> compiling them in is a gross idea. the whole point is to make it user editable
22:40:33 <dons> so you could use, for example, show/read to store haskell data in a config file, then read it in at start up, into a Reader monad
22:40:37 <Tac-Tics> Can someone give me a 2 minute rundown on reader?
22:40:46 <dons> Tac-Tics: it has the advantage that you can write arbitrary functions in the config file
22:40:55 <dons> and use arbitrary haskell libraries. that can turn out to be rather useful
22:40:57 <TSC> Tac-Tics: Do you know the state monad?
22:41:01 <Tac-Tics> yes
22:41:02 <sorear> > sequence [(+1), (+2), (+3)] 10 -- quick intro to the power of reader!
22:41:03 <lambdabot>  [11,12,13]
22:41:05 <dons> but yes, its a particular design decision not everyone wants to take
22:41:11 <TSC> It's read-only state, basically
22:41:31 <sorear> > ap(++)show"ap(++)show"  -- more reader mania!
22:41:32 <lambdabot>  "ap(++)show\"ap(++)show\""
22:41:45 <dons> you 'main' function would reda the config file, then run the rest of the program with runReaderT or runReader
22:42:00 <dons> providing the initial config state as a read-only environment
22:42:23 <wli> dons: I somehow got in that page.
22:42:28 <dons> you did, wli.
22:42:34 <dons> with your bold claims :)
22:42:54 <wli> How bold?
22:42:55 <dons> Just (u, v) -> unfoldl f v ++ [u] is interesting
22:43:09 <dons> `Fastest Fib in the West' is oh, moderately bold?
22:43:32 <wli> dons: I've since even run into needs for unfoldAccumL/unfoldAccumR
22:43:38 <Tac-Tics> can someone give me a quick one-liner of Reader monad code so I can try it out?
22:43:49 <dons> wli, hmm, isn't unfoldr already an accumulator?
22:43:52 <Tac-Tics> I'm looking at the docs and they are confusing
22:44:02 <dons> :t runReader
22:44:04 <lambdabot> forall r a. Reader r a -> r -> a
22:44:21 <wli> dons: I wanted/needed another accumulator for some reason.
22:44:35 <dons> > let config = 7 in    runReader config (do x <- ask ; return (x,x+1))
22:44:36 <lambdabot>        add an instance declaration for (Num (Reader (t (t1, t1)) a))
22:44:36 <lambdabot>     In t...
22:45:13 <dons> > let config = 7 in runReader (do x <- ask ; return (x,x+1)) config
22:45:13 <wli> dons: I'm not sure when I coined the phrase that it was a claim per se...
22:45:14 <lambdabot>  (7,8)
22:45:29 <dons> Tac-Tics: here 'config' is the values you read in at start up
22:45:38 <Tac-Tics> yeah
22:45:44 <dons> the Reader then threads that through your program, and you can get them at any time with 'ask'
22:46:23 <dons> :t do x <- ask ; return (x,x+1)
22:46:24 <lambdabot> forall (t :: * -> *) t1. (Num t1, MonadReader t1 t) => t (t1, t1)
22:46:27 <wli> dons: I've since bettered it by getting rid of the (^) usage, specializing the input argument to Int and result to Integer, and using bit operations instead of list operations and arithmetic to accomplish the bitreversal... I pasted it somewhere on hpaste.
22:46:29 <Tac-Tics> so any function at all that I want to allow a config variable to be used, I have to return a reader type?
22:46:35 <O1athe> How would the fastest fib be written on one line ?
22:46:44 <dons> Tac-Tics: you just supply your config data as the 2nd argument to runReader
22:46:47 <dons> and it can be any type of data
22:46:56 <dons> O1athe: with lots of `;' ?
22:47:12 <Cale> Tac-Tics: However, you can also use the lightweight reader monad that we were looking at before.
22:47:16 <wli> dons: http://hpaste.org/1945
22:47:17 <dons> and yeah, code that needs the config values is either in Reader, or passed on the stack
22:47:49 <Cale> Tac-Tics: Just using functions that basically take the environment as their first parameter.
22:48:10 <dons> yeah, that's the erlang way :) they don't have monads
22:48:18 <Cale> Well, that is a monad :)
22:48:20 <dons> its simpler for small programs
22:48:29 <Tac-Tics> yeah
22:48:34 <Tac-Tics> that would be the easy way
22:48:39 <TSC> @hoogle (m Bool) -> m () -> m ()
22:48:40 <lambdabot> No matches, try a more general search
22:48:45 <Cale> (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:48:46 <dons> the Reader just abstracts over passing that environment around
22:48:47 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:48:48 <lambdabot>  ("hello","olleh","HELLO")
22:49:19 <Cale> So you can use the monad operations to pass that parameter around for you.
22:49:28 <dons> Cale, oh did you have a type synonym or something for Env -> a -> b functions?
22:49:40 <Cale> You could, if you wanted.
22:49:49 <Cale> Or you can just use the monad :)
22:49:56 <dons> Tac-Tics: so do you have enough material to get started now?
22:49:59 <Cale> and don't worry about type synonyms :)
22:50:03 <dons> know how to read and write a file with 'show/read' ?
22:50:12 <dons> and then plug that config stuff into your program?
22:50:15 <Tac-Tics> I have enough to play with now
22:51:14 <O1athe> @let fib1 n = snd . foldl fib' (1, 0) . map (toEnum . fromIntegral) $ unfoldl divs n; where; unfoldl f x = case f x of; Nothing -> []; Just (u, v) -> unfoldl f v ++ [u]; divs 0 = Nothing; divs k = Just (uncurry (flip (,)) (k `divMod` 2)); fib' (f, g) p; | p = (f*(f+2*g), f^2 + g^2); | otherwise = (f^2+g^2, g*(2*f-g))
22:51:14 <lambdabot>  Parse error
22:51:24 <O1athe> How do I fix that ?
22:51:38 <dons> is it h98?
22:51:47 <dons> where;
22:51:48 <dons> look wrong
22:51:51 <O1athe> No idea.
22:52:31 <wli> dons: AFAICT the outcome of the haskell-cafe thread cited was that Gosper-Salamin bested all of the examined options (which did not include my implementation). I basically did a check and found that performance was largely equivalent on bitsparse numbers and I dominated Gosper-Salamin on bit-dense numbers, so (AFAICT) it's got little or no serious competition.
22:52:35 <sorear> O1athe: You don't replace newlines with semicolons in general
22:53:34 <O1athe> When are semicolons used ?
22:53:40 <wli> rarely
22:53:41 <dons> wli, cool.
22:54:01 <Cale> O1athe: between lines which would be on the same level in layout
22:54:23 <O1athe> How are the pipes that start lines handled when you put it on one line ?
22:54:26 <dons> so basically at the end of each declaration, or branch of a case/ifthenelse
22:54:32 <dons> without ;
22:54:37 <Cale> O1athe: they're all smashed together
22:54:46 <Cale> (the |'s already delimit them)
22:54:47 <dons> > f x | x == 1 = 2 | x == 3 = 2 | otherwise = 0 in f 2
22:54:47 <lambdabot>  Parse error
22:54:53 <Cale> let
22:54:55 <dons> > let f x | x == 1 = 2 | x == 3 = 2 | otherwise = 0 in f 2
22:54:56 <lambdabot>  0
22:55:05 <dons> > let in 2
22:55:06 <lambdabot>  2
22:55:11 <dons> mwhaha
22:55:31 <dons> > let in let in let in let in let "me" = 'out" in "now"
22:55:31 <lambdabot>  Improperly terminated character constant
22:55:36 <dons> > let in let in let in let in let "me" = "out" in "now"
22:55:37 <lambdabot>  "now"
22:56:25 <dons> :t let in let in let in let in let me = ?out in ?now
22:56:27 <lambdabot> forall t. (?out::t_a2qY, ?now::t) => t
22:56:58 <dons> :t let in let in let in let in ?please ?this ?is ?crazy ?? ?stuffs
22:57:01 <lambdabot> Not in scope: `??'
22:57:05 <dons> :t let in let in let in let in ?please ?this ?is ?crazy ?(?) ?stuffs
22:57:07 <lambdabot> Not in scope: `?'
22:57:07 <lambdabot>  
22:57:07 <lambdabot> <interactive>:1:54: Not in scope: `?'
22:57:17 <hpaste>  anon pasted "monad ([])" at http://hpaste.org/2090
22:57:18 <dons> :t ?(?)
22:57:20 <lambdabot> parse error on input `?'
22:57:30 <dons> :t let (?) = 1 in (?)
22:57:32 <lambdabot> forall t. (Num t) => t
22:57:37 <dons> :t let (?) = 1 in ?(??)
22:57:39 <lambdabot> parse error on input `?'
22:57:52 <dons> inneresting
22:58:15 <dons> :t ?implicit ?parameters ?are ?just ?insane ?what ?was ?simon ?thinking
22:58:18 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8. (?implicit::t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8, ?parameters::t, ?are::t1, ?just::t2, ?insane::t3, ?what::t4, ?was::t5, ?simon::t6, ?thinking::t7) =>
22:58:18 <lambdabot> t8
22:58:30 <O1athe> Ahh, got it in four lines.
22:58:33 <O1athe> > fib1 100
22:58:35 <lambdabot>  354224848179261915075
22:58:49 <wli> > let { fib' (f, g) p | p = (f*(f+2*g), f^2 + g^2) | otherwise = (f^2+g^2, g*(2*f-g)) ; fib :: Int -> Integer ; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] } in fib 100
22:58:51 <lambdabot>  354224848179261915075
22:58:53 <dons> cool cats
22:59:05 <dons> so who's can compute the largest fib before the time out? :)
22:59:14 <dons> whose. code. ?can ?do ?it
22:59:24 <O1athe> wli: Ahh, thanks.
22:59:36 <dons> > fib1 110
22:59:37 <lambdabot>  43566776258854844738105
22:59:41 <dons> > fib1 500
22:59:43 <lambdabot>  1394232245616978801397243828704072839500702565876973072641089629483255716228...
22:59:45 <dons> > fib1 1000
22:59:47 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
22:59:49 <dons> > fib1 10000
22:59:50 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
22:59:52 <dons> > fib1 100000
22:59:53 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
22:59:55 <dons> > fib1 1000000
22:59:56 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
22:59:58 <dons> > fib1 100000000
23:00:02 <lambdabot> Terminated
23:00:05 <sorear> dons: show is 10x slower than fib
23:00:13 <sorear> > fib1 100000000 `seq` ()
23:00:14 <dons> just as long as we don't show too much
23:00:17 <lambdabot> Terminated
23:00:27 <sorear> dons: gmp foreign calls are strict ;)
23:00:44 <dons> i suppose that _is_ fairer, but not as fun
23:00:49 <sorear> hmm.  does Integer show actually use the gmp Integer->String routines?
23:00:55 <sorear> @src Integer show
23:00:58 <dons> oh hmm. /no/ i think
23:01:04 <dons> there was a thread recently, and we got patches
23:01:07 <lambdabot> Source not found. I feel much better now.
23:01:34 <dons> sorear: look at jprinth
23:01:47 <dons> -- Divide an conquer implementation of string conversion
23:01:47 <dons> jtos :: Integer -> String -> String
23:05:11 <wli> My new fib gets fib (10^9) `seq` () in 95.74s but that's not terribly stressful.
23:07:47 <wli> The next barrier is of course the 64-bit one, 10^18 is the highest power of 10 representible in 64 bits.
23:07:49 <Tac-Tics> Trying to change my code to use Reader seems to require I make lots and lots of changes
23:08:02 <Tac-Tics> How is reader easier than passing an extra param?
23:08:57 <wli> One might be able to cram 10^19 into a Word64 I suppose.
23:09:37 <wli> I don't remember how the divide and conquer radix conversions work offhand.
23:10:14 <wli> Maybe that's a good problem for people.
23:10:23 <sorear> wli: think for a moment about how many bits would be required to store F_10^18, and how long it would take to fill that much memory
23:10:52 <wli> sorear: Oh, I'll run out of address space (never mind physical memory).
23:10:53 <sorear> > 1.616 ** (10 ** 18)
23:10:55 <lambdabot>  Infinity
23:11:00 <Binkley> heh
23:11:09 <Binkley> filling an infinite amount of memory takes a long time
23:11:15 <Tac-Tics> it seems like Writer just requires extra code
23:11:23 <Tac-Tics> when all it is is an extra parameter
23:11:33 <Tac-Tics> which you can do Monad stuff to
23:11:42 <TSC> @type (\ (x,y) -> show x ++ show y)
23:11:43 <sorear> > logBase 2 1.616 * (10 ** 18)  -- did I get my logbase formula right?
23:11:44 <lambdabot> forall t t1. (Show t, Show t1) => (t, t1) -> [Char]
23:11:45 <lambdabot>  6.924271980897078e17
23:11:52 <sorear> 7e17 bits
23:11:57 <sorear> > logBase 256 1.616 * (10 ** 18)  -- did I get my logbase formula right?
23:11:58 <lambdabot>  8.655339976121347e16
23:12:21 <wli> sorear: Yeah.
23:12:23 <sorear> 86 million gigabytes
23:13:02 <sorear> that's still something like $30 million of disks ;)
23:13:30 <TSC> Is ST worth the trouble?  It seems like the typing would be easier if I simply used IO
23:13:59 <jfredett> more like 15, sorear, maybe 20 if you're looking for a really redundant setup (My dad works for EMC. :) )
23:14:08 <jfredett> Where Data Lives. :)
23:14:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2091
23:14:23 <bitwize> Do Haskell's `case' expressions match on values? or only on structure?
23:14:27 <jfredett> wow, what a vauge paste.
23:14:30 <Binkley> hmm, 86 million gigabytes is about 2 million iPods
23:14:30 <sorear> bitwize: Both.
23:14:51 <TSC> Binkley: What's that in metric libraries of congress?
23:14:53 <bitwize> okay, cool.
23:15:00 <sorear> yeah, but we all know iPods cost a lot more than their hdds
23:15:05 <Binkley> yah, true
23:15:13 <bitwize> I was able to verify that GHC's `case' works on both; but didn't know if that were standard.
23:15:15 <sorear> @remember TSC What's that in metric libraries of congress?
23:15:15 <lambdabot> Done.
23:15:19 <Binkley> I was off by a factor of ten or something
23:15:21 <Binkley> math is hard
23:15:37 <sorear> let's go monading?
23:15:40 <wli> I used ((10.0**18) * logBase 256 ((sqrt(5)+1)/2))/ 2^30 to estimate the number of GB.
23:15:42 <jfredett> lol
23:15:46 <wli> sorear: Yes, let's.
23:16:01 <Binkley> To quote someone I knew once, "Math is hard, let's do category theory!"
23:16:18 <wli> Let's monad something right now.
23:16:23 <Binkley> just monad it
23:16:42 <wli> Someone come up with a quick idea of what to monad quick.
23:17:31 <jfredett> lol, WhatToDo a >>= IDontKnow = WhatDoYouWantToDo
23:17:44 <jfredett> (I'm not monad guru, so who knows if thats right)
23:18:46 <wli> Well, one of the rather basic things is error reporting.
23:19:06 <Tac-Tics> I really still need to figure out a better way to write functions which make use of a config file
23:19:34 <Tac-Tics> threading a config object to every function just seems really wasteful
23:20:21 <wli> Well, I'm going to let fib (10^10) spin and cook something.
23:20:38 <kfish> let's monad config!
23:21:00 <wli> I was plotting to try to learn HaskellDB tonight but I apparently am pig ignorant of basic database affairs, so I'm not getting anywhere with that any time soon.
23:21:29 <kfish> wli, i started doing that on friday and ended up learning happs instead ;-)
23:21:51 <wli> kfish: I'm not really dealing with web-oriented things for this, though.
23:21:54 <Tac-Tics> kfish: Did you just verbatize the word 'monad'?
23:22:07 <Binkley> did you just verbatize the word "verb"?
23:22:19 <Tac-Tics> Binkley: ...yeah
23:22:23 <Binkley> ;-)
23:22:40 <wli> My thought was to write a MUSH as an exercise in the database affairs as they appear in Haskell so I can dump things into database when needed later.
23:25:06 <bitwize> The verbed form of verb is, in fact, "to verb".
23:25:49 <kfish> irc :: BadGrammar ()
23:25:59 <bitwize> http://www.youtube.com/watch?v=uPP6Wj9esKw
23:26:22 <wli> I think fib (10^10) is going to exhaust the 32-bit address space.
23:26:26 <wli> 23826 wli       15   0 3216 3705m 3.1g  10m S 1   78 81.3   8:01 ghc-6.6.1
23:27:54 <wli> yep, it killed ghci
23:28:03 <OceanSpray> nighty night
23:29:42 <wli> I've got a good one. How do you get command-line editing like ghci but still catch signals?
23:30:08 <kfish> bitwize, that was the best video about monads ever!
23:30:52 <bitwize> You haven't seen the one with Mortimer Ichabod Monad yet.
23:33:23 <sorear> wli: It can be done.  I'm not sure how, but vty was able to capture signals with a immediate-mode tty in Haskell, so obviously it's possible for a Haskell line editor to handle signals.
23:34:07 <wli> sorear: Is ghci's line editor written in 100% Haskell?
23:34:21 <sorear> wli: No, it's readline.
23:34:46 <wli> sorear: So somehow ghci has figured out how to catch signals while using readline.
23:38:05 <wli> utils/Panic.lhs:180 installSignalHandlers :: IO ()
23:42:39 <wli> Is there any magic to get things like file names, function names, line numbers, etc. interpolated in strings (for error message generation)?
23:43:06 <pjd> Haskell line input library required?
23:43:15 <pjd> hasline
23:49:48 <wli> I'm not sure how to translate this to an un-threaded environment just yet.
23:51:33 <zvrba> what are you working on
23:51:33 <zvrba> ?
23:52:11 <zvrba> wli: btw.. function entry/exit is arithmetic over ESP/RSP. it'd be counter-productive to make that slower than arithmetic over ordinary registers.
23:59:48 <sorear> Is there a subset of the computable complex numbers containing the rationals with decidable comparison and closed under exponentials, logarithms, and the field operations?
