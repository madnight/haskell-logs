00:35:44 <fax> hi
00:36:02 <Botje_> hello!
00:36:59 <fax> I was wondering if anyone has any documents (Ideally something with code) which enumerates true Theorems based on axioms/rewrite rules?
00:37:28 <Botje_> no idea what you're talking about, sorry
00:37:33 <Botje_> but i'm sure someo f the other guys will
00:37:41 <Botje_> (or girls)
00:37:45 <fax> It's ok I don't either :p
00:37:49 <fax> I am trying to find out
00:39:51 <dons> fax, you want to prove theorems using term rewriting?
00:40:10 <dons> or haskell programs via equational reasoning/rewriting?
00:40:36 <fax> I want to take a set of axioms, and enumerate every theorem that can be derived from them
00:40:51 <dons> have you any experience with theorem provers like Isabelle or Coq?
00:41:22 <fax> I did half of the Coq tutorial but it was too hard :|
00:41:26 <dons> maybe grab Isabelle or Coq, and start playing around with them. its a big area.
00:41:29 <fax> like a year ago or somthing
00:41:47 <dons> you know about free theorems from types in haskell?
00:41:49 <dons> ?free map
00:41:51 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
00:42:02 <dons> gives a ruel that holds based on the type of map
00:42:04 <fax> I just came across it search but not didn't understand what it as
00:42:04 <dons> ?free id
00:42:05 <lambdabot> f . id = id . f
00:42:13 <dons> is true, based on the type of 'id'
00:42:55 <fax> ?free f . id
00:42:56 <lambdabot> Extra stuff at end of line
00:42:59 <Olathe> What is $map ?
00:43:38 <fax> :t $map
00:43:40 <lambdabot> parse error on input `$'
00:43:43 <fax> :/
00:44:01 <Olathe> I suppose it has to be the same as map.
00:44:05 <newsham> "enumerate every theorem" .. arent there usually a large number of theorems for most sets of axioms?
00:44:23 <fax> newsham: I think countably infinite
00:44:41 <newsham> arent there more facts than proofs?
00:45:08 <newsham> even countably infinite could take a long time :)
00:46:15 <fax> Is there some tutorials for Coq you would recommend?
00:46:32 <newsham> there's a #coq channel on this irc server
00:46:51 <newsham> there webpage has a tutorial or two, but i found them hard to follow
00:47:01 <fax> me too :[
00:47:18 <newsham> i found the isabelle tutorial easier to follow
00:47:41 <newsham> alas no #isabelle channel
00:48:13 <fax> ok I haven't looked at Isabelle, I will do this now
00:48:18 <fax> thanks guys :D
00:48:21 <Olathe> Coq !
00:49:06 <newsham> fax: I put together a teaser intro:  http://www.lava.net/~newsham/formal/reverse/
00:49:07 <lambdabot> Title: Formal methods: Reverse
00:49:24 <fax> ah, thanks!
00:49:42 <newsham> online tutorial that seems pretty good:  http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle/doc/tutorial.pdf
00:49:45 <lambdabot> http://tinyurl.com/y7rybl
00:51:21 <Olathe> ?free (+)
00:51:21 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:51:23 <Olathe> :(
00:53:22 <scodil> how do you compose monadic functions? like if f :: a -> b, and g :: b -> c, I can do g . f to get a -> c, but if they're monadic I can't do g =<< f, only \x -> g =<< f x.  Is there a standard combinator for this kind of thing?
00:55:30 <Botje_> uh?
00:55:42 <Botje_> g . f would be equivalent to f >>= g
00:56:58 <scodil> i get type errors if i don't fully apply it
00:57:42 <Botje_> =<< and >>= have a very low precedence, yes
00:58:19 <Olathe> > let f x = [x + 1] in let g x = [x * 2] in f =<< g =<< [1, 2, 3]
00:58:28 <lambdabot>  [3,5,7]
00:58:31 <Olathe> Speed it up, botty !
00:59:45 <Olathe> It should be f :: a -> Monad b and g :: b -> Monad c, if I got the syntax correct.
01:00:17 <scodil> :t let f x = [x + 1] in let g x = [x * 2] in f =<< g
01:00:19 <lambdabot>     Couldn't match expected type `[]' against inferred type `(->) a'
01:00:19 <lambdabot>     Probable cause: `g' is applied to too few arguments
01:00:41 <scodil> i want f =<< g, as an expression, so I can further compose it with other stuff
01:00:55 <scodil> like you can do with h . (g . f)
01:01:10 <scodil> how do i do that?
01:02:12 <scodil> :t let f x = [x + 1] in let g x = [x * 2] in \x -> f =<< g x
01:02:14 <lambdabot> forall a. (Num a) => a -> [a]
01:12:57 <Olathe> Yeah, that's it.
01:13:01 <Olathe> > let (.<<) f g = (\x -> f =<< (g x)) in let q x = [x + 1] in let r x = [x * 2] in let s = q .<< r in s =<< [1, 2, 3]
01:13:03 <lambdabot>  [3,5,7]
01:18:55 <Olathe> Ah hah !
01:18:58 <Olathe> > let (.<<) f g = (\x -> f =<< (g x)) in let q x = return (x + 1) in let r x = return (x * 2) in let s = q .<< r .<< q .<< r in s =<< [1, 2, 3]
01:18:59 <lambdabot>  [7,11,15]
01:20:13 <Olathe> return is pretty spiffy.
01:21:37 <ivant> good morning, #haskell
01:22:17 <Olathe> Good morning.
01:23:28 <desp> hm
01:24:10 <desp> can someone tell me why Control.Monad.Error requires either the noMsg or strMsg function?
01:25:13 <desp> this requires me to add an UnusedError constructor to my Error instance
01:26:00 <desp> which, of course, doesn't hurt, but...
01:26:25 <LeCamarade> Is there a uncode-good version of mxrvt that I can use with Xmonad?
01:27:07 <ivant> LeCamarade, urxvt
01:27:23 <ivant> LeCamarade, it is called rxvt-unicode, if I'm not mistaken
01:28:21 <ivant> desp, are you sure you need Error transformer then? maybe MaybeT?
01:28:55 <desp> ivant: not ErrorT, Error.
01:29:20 <ivant> desp, ah, sorry
01:29:41 <desp> ivant: example 1 given in the Error class description (http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html) shows a similar situation
01:29:43 <lambdabot> http://tinyurl.com/sw72f
01:29:53 <desp> they define a custom error type with several constructors
01:29:55 * pjd gets hit by a gigantic flash of insight
01:30:10 <pjd> return == liftM0!
01:30:13 <desp> and one constructor is left unused, only for the purpose of defining the class functions
01:30:18 <bluestorm> LeCamarade, did you see the quite recent "Declarative Assembler" on LtU ?
01:30:18 <LeCamarade> :o)
01:30:24 <desp> pjd :)
01:30:38 <bluestorm> (i saw it yesterday and thought it may interest you)
01:31:19 <LeCamarade> bluestorm: Um ... no? Even though I've been reading LtU. Link, s'il vous plait?
01:31:24 <bluestorm> http://lambda-the-ultimate.org/node/2414
01:31:25 <lambdabot> Title: Declarative Assembler | Lambda the Ultimate
01:31:30 <ivant> desp, on the other hand, you can pattern match in the catch block
01:31:34 <LeCamarade> :o)
01:31:53 <desp> ivant: sure, of course.
01:32:03 <desp> I just dislike having to define a dead value
01:32:15 <desp> I guess I could make my own Error monad
01:32:15 <bluestorm> i didn't read it, so you'll be the only one to blame if you don't like it :-'
01:33:49 <ivant> hmm. now I have two papers by Kahl opened in my browser instead of one
01:35:12 <LeCamarade> Gon' read that ...
01:35:26 <LeCamarade> :o)
01:36:24 <fax> @_@
01:36:24 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
01:36:34 <fax> isabelle bus errors so I try to run coq instead and it freezes
01:36:38 <fax> (both in emacs0
01:36:51 <fax> I have bad luck :|
01:38:37 <desp> is anyone here familiar with the way the RTS uses select() calls?
01:42:17 <Dogg> http://www.streetracers.de.tp/?wid=9128
01:42:18 <lambdabot> Title: Streetracers
02:02:59 <bwx> what's the difference between Set.elems and Set.toList?
02:04:12 <ivant> @src Set.elems
02:04:13 <lambdabot> Source not found. My pet ferret can type better than you!
02:04:18 <ivant> @src Data.Set.elems
02:04:18 <lambdabot> Source not found. You type like i drive.
02:04:44 <ivant> bwx, as far as I recall, they are identical
02:09:07 <bwx> thanks
02:20:47 <desp> @hoogle Typeable
02:20:48 <lambdabot> Data.Typeable :: module
02:20:48 <lambdabot> Data.Typeable.Typeable :: class Typeable a
02:20:48 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
02:21:28 <desp> "    Can't make a derived instance of `Typeable ECode'
02:21:30 <desp>       (You need -fglasgow-exts to derive an instance for this class)"
02:22:08 <desp> any ideas what Language value this would be?
02:22:21 <desp> (trying to avoid the OPTIONS pragma)
02:22:59 <desp> ah, never mind. GeneralizedNewtypeDeriving :)
02:34:11 <tuomov> Isn't there a ready function somewhere, for pairing two functions for either
02:34:42 <tuomov> and monadic at that, kind of like fmapM
02:34:45 <tuomov> eitherfM f _ (Left a) = liftM Left $ f a
02:34:45 <tuomov> eitherfM _ g (Right b) = liftM Right $ g b
02:35:33 <tuomov> Perhaps even (Either f g) could be a type with special properties, but I couldn't find anything..
02:36:43 <tuomov> I'd expect that to be useful often..
02:42:21 <Heffalump> I don't often find a need for it. I think that's a special instance of the concept of a Bifunctor.
02:42:34 <Heffalump> But the nice thing about Haskell is that it's easy to write your own utility functions if needed.
02:43:46 <wli> :t \f g -> liftM (either f g)
02:43:51 <lambdabot> forall a c b (m :: * -> *). (Monad m) => (a -> c) -> (b -> c) -> m (Either a b) -> m c
02:44:05 <wli> Not quite...
02:46:29 <tuomov> one can always write a zillion utility functions, but would rather use a ready one, if one could find it
02:46:40 <tuomov> the haskell libs are bloatware from which it is impossible to find anything..
02:46:56 <fax> I don't agree
02:47:14 <tuomov> monolithic crap
02:47:15 <fax> I found it quite easy to navigate the HTML documentation
02:47:50 <tuomov> just like the kernel, distros, etc.
02:48:06 <tuomov> trying to provide a huge collection of Everything
02:48:29 <psykotic> hoogle is pretty good for searching the existing libs
02:48:38 <psykotic> @hoogle (a -> b) -> (c -> d) -> Either a c -> Either b d
02:48:39 <lambdabot> No matches, try a more general search
02:48:56 <ivant> :-)
02:49:02 <psykotic> well, it doesn't exist :)
02:49:08 <psykotic> if it did, it'd show up
02:49:51 <ivant> it exists in the arrows library, as far as I recall
02:51:00 <wli> @djinn Monad m => (a -> m c) -> (b -> m d) -> Either a b -> m (Either c d)
02:51:00 <lambdabot> Cannot parse command
02:51:46 <ivant> how can I convert String into the UTF8 string ([Word8] would be ideal)?
02:53:28 <ivant> @ty ord
02:53:30 <lambdabot> Char -> Int
02:54:23 <desegnis> ivant, try utf8-string from hackage
02:54:41 <desegnis> stringToBytes :: String -> [Word8] looks promising
02:54:50 <ivant> thanks
02:55:03 <desegnis> oh, wait
02:55:25 <desegnis> It is simply defined as map (toEnum . ord)
02:55:29 <tuomov> forget UTF8, use the locale
02:55:30 <ivant> oh, actually, I know that I always have latin1 chars in my string, so a simple map (fromInteger.ord) will do
02:55:32 <tuomov> no thanks to monocultures
02:55:47 <tuomov> it sucks that GHC went that way too
02:56:02 <tuomov> -- -*- encoding: foo; -*- What's so difficult?
02:56:19 <ivant> tuomov, how about boundaries with other systems?
02:56:30 <tuomov> ?
02:57:01 <ivant> suppose I need to set X window property which happens to be a UTF8 string
02:57:11 <tuomov> that's a broken design
02:57:15 <tuomov> COMPOUND_TEXT!
02:57:22 <tuomov> but the FDO folks are monoculturists
02:57:27 <tuomov> all their shit demands UTF8, even in the APIs
02:58:04 <fax> Why is that a broken design?
02:58:14 <tuomov> demanding a particular _hard-coded_ encoding
02:58:16 <ivant> tuomov, I don't care if it is broken as long as I can't fix it. I can only conform
02:58:27 <tuomov> wchar_t is ok, because the actual encoding isn't specified
02:58:30 <fax> tuomov: What's the difference between -one- encoding, and a finite number of encodings?
02:58:31 <tuomov> same with locales
02:58:37 <tuomov> i.e. C multibyte stuff
02:58:37 <fax> tuomov: It doesn't make any difference
02:58:42 <desegnis> Cabal question
02:58:42 <desegnis> Given a directory “data” in my source tree, and data-files: data/foo in the cabal file, cabal will copy it to something like /usr/share/$package/data/foo. Is there a way to have /usr/share/$package/foo, without messing up the source tree?
02:59:02 <tuomov> fax: the problem with a hard-coded encoding is that you're stuck to that encodingn forever
02:59:07 <tuomov> you can't change it by just changingn a library
02:59:11 <tuomov> because everything assumes that encoding
02:59:17 <fax> tuomov This is my point, the same problem applies to a finite number of encodings
02:59:19 <tuomov> (or better than library: locale setting)
03:00:01 <tuomov> applications should never have to deal with encodings
03:00:08 <takamura> hi!
03:00:16 <tuomov> The C 'char' is the biggest mistake in software design history..
03:00:24 <tuomov> or char*..
03:00:24 <fax> tuomov: ##c
03:00:44 <ivant> tuomov, obviously it doesn't work when all applications use whatever encoding they want (and yes, we have to stick with C 'char')
03:00:46 <tuomov> and in particular IO with that
03:01:09 <tuomov> locale specifies the encoding to be used for files etc. for which no more detailed information is provided
03:01:22 <tuomov> but this modern breed of monoculturists thinks that no locale is not to be used; utf-8 is
03:01:53 <tuomov> the big problem in the first place being that text files don't carry encoding informatino
03:01:56 <ivant> tuomov, I use characters from different locales as filenames on my filesystems. What should I do then?
03:02:11 <tuomov> utf a fucking utf-8 locale
03:02:15 <tuomov> s/utf/use/
03:02:21 <tuomov> I use too
03:02:33 <tuomov> but I don't think programs should be even aware that I use an utf-8 locale
03:02:39 <tuomov> it should be a black box that I can change at any time
03:02:57 <tuomov> but the present trend is that programs and apis and everything is highly-aware and demands utf-8
03:03:03 <tuomov> and I want nothing nto do with that kind of shit
03:03:24 <tonfa> tuomov: but if you need to communicate with other you have to translate it to a different encoding anyway
03:03:35 <tonfa> so why not just use utf8 internally ?
03:03:46 <ivant> so you want everything to be the same, but utf8 shouldn't have any name :-)
03:03:47 <tuomov> yes, and libraries should handle that
03:03:54 <Heffalump> oh, not again
03:04:06 <Heffalump> we already went through this on #darcs a while ago :-)
03:04:11 <tuomov> and either specify encoding if the protocol supports that, or use the worse hard-coded encoding if the protocol demands that
03:04:19 <tuomov> but e.g. the FDO monoculturists demand that even APIs are passed utf-8
03:04:29 <tuomov> hard-coded, not some Abstract Application Internal Encoding even
03:04:31 <wli> The internationalization and localization situation is screwed up.
03:04:33 <tuomov> such as wchar_t
03:04:34 <wli> FDO?
03:04:38 <tuomov> freedesktop.org
03:04:39 <tonfa> Heffalump: and what did you do, in hg we store utf8 internally
03:05:13 <Heffalump> darcs's log messages are just ASCII, IIRC
03:05:16 <tuomov> and use locale the communicate; a decent approach
03:05:25 <tuomov> s/the/to/
03:05:32 <tonfa> Heffalump: ok, username too ?
03:06:10 <Heffalump> tuomov: re eitherfM, how do you reconcile your claim that the haskell libs are bloatware with your belief that they should have yet more stuff in them to satisfy your request?
03:06:38 <tuomov> umm, I want more clear modularity
03:06:45 <Heffalump> tonfa: yeah. I doubt it's ideal, but I don't think there've been many complaints apart from tuomov.
03:06:47 <tuomov> but at least GHC comes with Everything
03:07:01 <tonfa> Heffalump: ok
03:07:02 <Heffalump> tuomov: well, such a function would fit well into Control.Monad, what more modularity would you want?
03:07:02 <tuomov> and stuffed into some strict hierarchy
03:07:24 <Heffalump> but as was pointed out, it's not needed given liftM (either f g)
03:07:46 <wli> \f g -> liftM (either f g) doesn't quite work.
03:07:57 <wli> :t \f g -> liftM (either f g)
03:08:03 <lambdabot> forall a c b (m :: * -> *). (Monad m) => (a -> c) -> (b -> c) -> m (Either a b) -> m c
03:08:09 <wli> It's the wrong type.
03:08:11 <Heffalump> oh, right
03:08:15 <wli> By a long longshot.
03:08:18 <matthew-_> what type do you want?
03:08:31 <Heffalump> (a -> c) -> (b -> d) -> m (Either a b) -> m (Either c d)
03:08:46 <Heffalump> there's probably some arrow combinator that does the right thing :-)
03:09:04 <tuomov> Heffalump: clearer libraries and library boundaries instead of some arbitrary global semantic hierarchy
03:09:17 <wli> (a -> m c) -> (b -> m d) -> Either a b -> m (Either c d)
03:09:28 <ricky_clarkson> Sounds like the kind of mind that wants the WWW to be split into categories too.
03:09:40 <tuomov> LibFOO.whatever instead of Data.Bar.Quk.Asdf from libfoo, Asdf.Wwerwe.ASDF from libFOO, etc.
03:10:02 <tuomov> and the libFOO module even being just a local name..
03:10:04 <matthew-_> hang on, you want module names to start with Lib ?
03:10:09 <Heffalump> most people find the namespacing being very useful
03:10:19 <tuomov> matthew-_: no, just example
03:10:41 <ivant> what's wrong with Data.Bar then?
03:10:42 <tuomov> dividing things into clear modules from different authors, instead of constructing a monolithic hierarchy
03:11:11 <Heffalump> Once I bring in the mtl, I don't really care that some stuff in Control.Monad is from base and some stuff is from it
03:11:14 <Saizan> :t \f g -> liftM (f ||| g)
03:11:16 <lambdabot> forall b d c (m :: * -> *). (Monad m) => (b -> d) -> (c -> d) -> m (Either b c) -> m d
03:11:50 <wli> :t liftM2 (|||)
03:11:51 <lambdabot> forall (a :: * -> * -> *) b d c (m :: * -> *). (ArrowChoice a, Monad m) => m (a b d) -> m (a c d) -> m (a (Either b c) d)
03:11:56 <Heffalump> authors are of course free to put their own stuff in a library-specific top-level hierarchy if they so choose
03:12:21 <tuomov> but soon you'll find it all included in GHC's mega-hierarchy...
03:12:34 <Heffalump> I think the goal is to get stuff out of GHC, not put more in.
03:12:45 <tuomov> I don't think that's happening..
03:13:02 <matthew-_> tuomov: hackage is growing faster than GHC's libraries
03:13:12 <Heffalump> certainly more things are being split into separate packages that come along with GHC
03:13:29 <Heffalump> and apart from fps, nothing's gone into the GHC dist for a while
03:13:36 <Saizan> :t \f g -> liftM (f +++ g)
03:13:37 <lambdabot> forall b c b' c' (m :: * -> *). (Monad m) => (b -> c) -> (b' -> c') -> m (Either b b') -> m (Either c c')
03:14:01 <Heffalump> and distros like Debian are starting to ship the GHC packages in separate distro packages
03:14:05 <matthew-_> Saizan collects the prize
03:14:16 <tuomov> distros are fucked
03:14:18 <wli> @djinn Monad m => Either (m a) (m b) -> m (Either a b)
03:14:18 <lambdabot> Cannot parse command
03:14:21 <Heffalump> I think wli might have been right about the type, not me.
03:14:35 * Heffalump remembers he was planning on playing with xmonad
03:14:55 <wli> :t let eitherM f _ (Left x) = liftM Left $ f x ; eitherM _ g (Right y) = liftM Right $ g y in eitherM
03:14:57 <lambdabot> forall t (m :: * -> *) a t1 a1. (Monad m) => (t -> m a) -> (t1 -> m a1) -> Either t t1 -> m (Either a a1)
03:16:02 <Saizan> well, is Either Traversable?
03:16:04 <tuomov> get shit out of ghc, and stop trying to categorize it in a global hierarchy, instead just using the package names as top-level identifiers (possibly configurable by the user: -package Foo=foo)
03:16:15 <wli> Perhaps \f g -> fmap Left f ||| fmap Right g
03:16:40 <Heffalump> tuomov: not going to happen :-)
03:16:45 <Heffalump> the latter, that is
03:16:51 <tuomov> yeah, because people are obsessed with Huge Structures
03:17:06 <tuomov> trying to build a Categorized Collection of Everything
03:17:10 <Heffalump> that's your problem, not theirs
03:17:27 <Saizan> wli: (f =<<)
03:17:27 <tuomov> all the "modern" languages seem to be suffering from that
03:17:34 <wli> :t \f g -> (liftM Left . f) `either` (liftM Right . g)
03:17:36 <lambdabot> forall a a1 a11 (m :: * -> *) b. (Monad m) => (a -> m a11) -> (b -> m a1) -> Either a b -> m (Either a11 a1)
03:18:03 <tuomov> attempts at global name hierarchies, instead of local decentralised naming
03:18:10 <wli> Saizan: The argument is not monadic. f =<< is inappropriate.
03:18:12 <Heffalump> perhaps that's because people find them useful
03:18:36 <tuomov> the kind of people who think in terms of big hierarchies, perhaps
03:18:40 <wli> @pl \f g -> (liftM Left . f) `either` (liftM Right . g)
03:18:40 <lambdabot> (. (fmap Right .)) . either . (fmap Left .)
03:18:45 <Saizan> ah i thought the type was the one you gave to djinn
03:18:49 <wli> Not useful.
03:18:52 <Heffalump> though Java doesn't really, since everything is namespaced by supplier
03:19:12 <Heffalump> I think most people find a standardised hierarchy cognitively useful. I certainly do.
03:19:17 <tuomov> well, there's that convention for third party stuff
03:19:19 <wli> Saizan: I gave several types to it, some subsidiary to the whole.
03:19:26 <tuomov> but there's still a huge hierarchy of sun's shit iirc
03:19:30 <dcoutts> pgavin: pong
03:19:30 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:20:09 * yaxu hugs System.Console.Readline
03:20:13 <desp> > let foo_ = 1 in foo_
03:20:14 <lambdabot>  1
03:20:16 <desp> > let foo_' = 1 in foo_
03:20:17 <lambdabot>   Not in scope: `foo_'
03:20:19 <desp> > let foo_' = 1 in foo_'
03:20:21 <tuomov> I find being able to pick single useful libraries easily much more useful
03:20:21 <lambdabot>  1
03:20:25 <desp> hrm
03:20:26 <psykotic> does anyone here use inf-haskell.el for emacs and know how to make emacs pipe <tab> to the ghci process for tab completion of nanes?
03:20:29 <psykotic> *names
03:22:20 <tuomov> cabal/hackage/whatever also sucks for setting policy on version numbers..
03:22:27 <desp> what is going on?
03:22:46 <desp> oh.
03:22:46 <tuomov> sigh, even there people couldn't refrain from trying to specify how things are to be named... just like arch
03:22:49 <evir> psykotic: That'd be nice.
03:22:58 <desp> too tired. wrote :: instead of =.
03:23:54 <gleb> psukotic: I didn't even knew that ghci allowed TAB-completion, thanks :)
03:24:20 <gleb> s/psukotic/psykotic/
03:24:25 <tuomov> bah
03:25:48 <desp> is mzero in IO "return ()"?
03:26:09 <Heffalump> no, mzero should never be return ()
03:26:20 <Heffalump> I would guess it's some kind of throw.
03:26:53 <desp> can I generalize "return ()" to any Monad?
03:27:05 <xerox> return () isn't general enough? (:
03:27:20 <desp> hm.
03:27:28 <desp> perhaps I'm reading this error message wrong.
03:27:55 <Heffalump> return () should work in any Monad.
03:28:28 <ivant> return whatever should work in any monad
03:28:30 <Heffalump> the type system guarantees that if return works at all, then return () will work
03:29:06 <ivant> oh, no, not necessarily
03:29:15 <desp> http://hpaste.org/2422
03:29:19 * Heffalump realises that instance Monad Bottom where return x = undefined ; m >>= f = undefined
03:29:22 <desp> hpaste, url
03:29:25 <Heffalump> probably satisfies the monad laws
03:29:35 <desp> hpaste! hpaste!
03:29:53 <desp> xerox: what am I doing wrong with the return () ? :)
03:30:01 <Heffalump> it's not the return ()
03:30:08 <Heffalump> it's the throw, it returns a non-monadic type
03:30:28 <desp> Heffalump: m ECode?
03:30:31 <xerox> desp: throwError misses an argument
03:30:40 <desp> ahh. *slaps self*
03:30:51 <Heffalump> namely ECode -> M ECode :-)
03:31:59 <desp> right :)
03:32:04 <desp> @hoogle (<<)
03:32:05 <lambdabot> Did you mean: (<<)
03:32:05 <lambdabot> Prelude.undefined :: a
03:32:05 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:32:27 <desp> yes, I did mean (<<)
03:34:54 <Heffalump>  @hoogle seems a bit...broken :-)
03:36:04 <desp> @type (<<)
03:36:06 <lambdabot> Not in scope: `<<'
03:38:36 <Saizan> @hoogle <<
03:38:36 <lambdabot> Text.Html.(<<) :: HTML a => (Html -> b) -> a -> b
03:38:37 <lambdabot> Control.Arrow.(<<<) :: Arrow a => a c d -> a b c -> a b d
03:38:37 <lambdabot> Control.Arrow.(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
03:39:06 <desp> hmm.
03:39:18 <desp> no dual operator to >>, then?
03:46:14 <roconnor> @bab nl en Zigeunerschnitzel
03:46:15 <lambdabot>   gypsy escalope
03:46:31 <roconnor> @dict escalope
03:46:31 <lambdabot> Supported dictionary-lookup commands:
03:46:31 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
03:46:31 <lambdabot> Use "dict-help [cmd...]" for more.
03:46:48 <desp> roconnor: a burger
03:47:17 <desp> ;)
03:47:53 <roconnor> ``It is usually a pork schnitzel with a spicy sauce of bell peppers, tomatoes and onions.
03:48:00 <desp> actually a thin meaty thing
03:48:17 <roconnor> desp: like a schnitzel :)
03:49:49 <desp> for me schintzels (sznycle) have a different meaning; usually made from ground meat :)
03:50:18 <evir> Schnitzel are definively different from burgers... :-)
03:50:44 <tonfa> :t (&&&)
03:50:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:51:18 <roconnor> crap, my wireless mac address has rubbed off the bottom of my computer
03:51:50 <Mat^> guys, did your haskell code also looked crappy at the begining? :S I mean, I look at it and feel like a dumb ;S
03:51:58 <Mat^> (my code, it's horrible)
03:52:05 <desp> why?
03:52:10 <desp> @hpaste
03:52:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:52:14 <xerox> roconnor: iwconfig ?
03:52:23 <Mat^> desp: It's 35 KB
03:52:33 <roconnor> Is there any way look up my orginal MAC address?
03:52:42 <roconnor> before I changed it in software?
03:52:45 <desp> Mat^: so is it uniformly stupid all over? ;)
03:52:55 <Mat^> desp: I just don't know how to make it clean, and look nice
03:52:59 <Mat^> it's mess ;>
03:53:09 <Mat^> desp: yes! ;>
03:53:35 <roconnor> Mat^: we can help.
03:54:16 <roconnor> maybe you can paste the crapiest part.
03:54:53 <Mat^> well, It's hard to find crapiest part
03:55:20 <desp> it's hard for us to suggest anything meaningful
03:55:24 <Mat^> It's just, I have maaaaaaany diffirent datas, many diffirent functions, and it all mixes
03:55:27 <desp> if you don't give an example
03:55:36 <Mat^> wait
03:59:34 <Mat^> http://phpfi.com/258595
03:59:35 <lambdabot> Title: nopaste: pastebin with syntax highlighting
04:00:06 <desp> @hpaste
04:00:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:00:07 <Mat^> I mean graphically, everything is mixed, is there any tutorial how can I help it? :P
04:02:10 <Cale> all these create_x_expr functions don't seem to gain much...
04:02:49 <Mat^> just wanted to have shorter expressions ;P
04:03:31 <Cale> hmm
04:04:10 <yaxu> given an array of filepaths, how do i get an array of file contents?
04:04:40 <xerox> yaxu: mapM readFile
04:04:46 <Cale> yaxu: Data.Traversable.mapM readFile
04:04:50 <desp> Mat^: http://hpaste.org/2423
04:04:57 <desp> for a start
04:05:09 <yaxu> thanks!
04:05:52 <Mat^> desp: =]
04:05:55 <desp> try using 2-space tab stops
04:05:57 <Mat^> desp: nice ;>
04:07:29 <desp> http://hpaste.org/2423#a1
04:08:00 <roconnor> desp: I usually go even thinner.
04:08:18 <roconnor> by just a little
04:08:23 <desp> roconnor: pardon?
04:08:28 <roconnor> my where statements only get 1 space
04:08:32 <desp> oh
04:08:41 <Mat^> 2 space tabs can make life prettier ;> that's sure
04:08:45 <desp> I'm still trying to work out a nice style for my own
04:08:58 <desp> projecteuler helped me with that a little
04:08:59 <Mat^> but what about function naming?
04:09:08 <roconnor> desp: what you have is pretty close to what I do
04:09:10 <Mat^> there are so many functions in one file, that i start to loose control
04:09:24 <desp> roconnor: I've found that aligning stuff to the right of keywords kills me
04:09:29 <desp> Mat^: oh, use modules!
04:09:37 <desp> Mat^: it's quite simple,r eally
04:09:55 <Mat^> mhm
04:10:29 <Mat^> that would be nice, to split parser/intermediate language generator etc
04:11:56 <desp> go for it
04:13:29 <Mat^> http://hpaste.org/2424
04:13:43 <Mat^> and that's one thing that I really don't like
04:14:04 <Mat^> big structure to make function return many things
04:14:17 <Mat^> actually, hold things
04:14:19 <Cale> http://hpaste.org/2423#a2
04:15:10 <Mat^> ;>
04:15:33 <desp> http://hpaste.org/2424#a1
04:15:49 <desp> Cale: I disagree
04:16:06 <Mat^> that looks better
04:16:09 <desp> Cale: I find aligning stuff to the right of keywords makes functions uncomfortable imbalanced
04:16:16 <desp> s/ble/bly/
04:16:31 <desp> of course, that's just my personal aesthetic opinion :)
04:16:34 <Mat^> but is there any way to avoid passing this structure everywhere in the function?
04:17:17 <Cale> Mat^: well, you can use a state monad, but it is a sign that maybe there's another way to handle things
04:17:17 <desp> Mat^: C_case_is_frowned_upon_in_Haskell, wePreferCamels
04:17:28 <Heffalump> individual taste, surely
04:17:28 <Olathe> Eww.
04:17:31 <Heffalump> though I prefer camels.
04:17:43 <roconnor> Mat^: http://hpaste.org/2423#a3
04:17:48 <Olathe> Camels are the animals of SATAN !
04:18:09 <roconnor> Mat^: I could probably do something nicer if I knew the semantics of what I was editing ;)
04:18:11 <Mat^> desp: oh, it's habbit ;>
04:18:59 <Mat^> roconnor: but it's way better anyway! ;>
04:19:20 <Mat^> I just need to understand that ;P
04:19:47 <desp> here's a bit of code that shows how I indent stuff
04:19:55 <Cale> Mat^: so what's the idea behind this? You're walking over the parse tree and executing the code, modifying the Semantic_an_status as you go?
04:20:03 <roconnor>  Mat^: If you are not a haskell expert it is important to realize that because evaluations are lazy, you can make declarations that are nonsencial in some cases.
04:20:05 <desp> Mat^: http://pastie.textmate.org/90873
04:20:05 <Mat^> Cale: yes
04:20:07 <lambdabot> Title: #90873 - Pastie
04:20:25 <roconnor> Mat^: because the expressions will only be evaluated in the cases where they are used.
04:20:27 <Mat^> Cale: I attach errors, and warnings
04:20:56 <Mat^> roconnor: I know that ;>
04:20:57 <wli> I wish there were a style standard of some sort.
04:21:07 <Mat^> but I'm not sure, if I use it propper, but well ;>
04:21:13 <Cale> desp: heh, you really do start a new line after let and do and where :)
04:21:22 <desp> Cale: I do :)
04:21:24 <Cale> but not after in
04:21:57 <Mat^> Cale: it's random ;>
04:22:02 <Mat^> oh, sorry ;P
04:22:05 <desp> actually, I start a new line when I open a new block
04:22:11 <desp> "block"
04:22:58 <wli> Your tabs are so tiny as to be visually insignificant.
04:23:05 <desp> Cale: I was aligning things the way you do for a while, but then I noticed I spend way too much time re-aligning my code after editing
04:23:10 <wli> :set ts=1 or something?
04:23:17 <Mat^> Cale: I need this structure mostly, because I need to know, what identifiers are registered in the function, so there are no few variables with the same identifier
04:23:25 <ivant> @index asks
04:23:26 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
04:23:32 <desp> @slap wli
04:23:33 * lambdabot smacks wli about with a large trout
04:23:37 <desp> :)
04:23:44 <Mat^> and I found it might be usefull to create intermediate language by the way
04:23:48 <Cale> desp: I spend so little time typing code compared to thinking about it that I really don't care if it takes longer to type one way.
04:24:16 <wli> Well your tabs are far beyond microscopic.
04:24:22 <roconnor> Cale: I always wondered how programmers get RSI.
04:24:31 <roconnor> Cale: I spend at least 50% of my time thinking
04:24:34 <roconnor> if not more.
04:24:36 <Cale> roconnor: Probably from IRC :)
04:24:54 <dcoutts> @seen dons
04:24:55 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 42m 41s ago.
04:24:56 <ivant> @index ord
04:24:57 <lambdabot> Data.Char
04:24:58 <Cale> (Or programming in Java ;)
04:25:21 <Mat^> I spent about 90% of my time thinking how to code something in haskell ;P
04:25:25 <wli> Cale: You should see what asm and C do relative to Java... it's bad, real bad.
04:25:41 <desp> I think people get RSI by forcing their hands to lie on the "home row".
04:26:30 <Cale> wli: Used inappropriately? Sure.
04:27:36 <Cale> There's something that annoys me more about Java in that it has some high level abstractions, but the amount of cruft is just so high that you barely get any benefit with regard to the amount of code you have to type.
04:27:38 <wli> I wonder what diff(1) and patch(1) would look like in Haskell.
04:31:39 <wli> Is there anything non-obvious about diff(1) and patch(1)? I wonder.
04:32:06 <bluestorm> sounds like a good idea for a project of yours :-'
04:32:30 <wli> NIH'ing quilt in Haskell?
04:33:03 <bluestorm> porting diff(1) to Haskell
04:33:08 <bluestorm> hm
04:33:42 <taruti> darcs probably has it already
04:33:47 <desp> doesn't darcs have it?
04:33:53 <bluestorm> hm
04:33:53 <wli> Good point.
04:33:56 <bluestorm> you're right ^^
04:33:56 <desp> heh.
04:33:59 <bluestorm> hm
04:34:07 <wli> @go darcs
04:34:09 <lambdabot> http://darcs.net/
04:34:09 <lambdabot> Title: darcs
04:34:16 <Mat^> learning language by writting compiler is bad idea (this is my coursework) ;>. I'll now try to make my code usable ;) Cu gus and thanks for advices! ;]
04:34:26 <bluestorm> i would be mean to say "i mean, porting to an efficient version" right now
04:34:55 <bluestorm> hm
04:35:04 <Cale> Mat^: yeah, sorry we can't be more helpful, but that really is quite a lot of code to sort through :)
04:35:49 <Cale> Mat^: flaten = concat
04:36:16 <Cale> make_instruction_list = map Instruction_simple
04:36:18 <Mat^> Cale: but now I'll be able to make code mode readable ;>
04:36:57 <Mat^> Cale: yes, now I know (about map ;>) I used it somewhere later
04:37:05 <Mat^> but I still don't know much of standard library ;P
04:37:06 <Cale> show_instructions = concat . intersperse " . " . map show
04:37:21 <Mat^> (look "just_find" "find_and_get" etc)
04:38:00 <Mat^> mhm
04:38:05 <Cale> :t find
04:38:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
04:38:11 <oerjan> Mat^: i recommend browsing the Data.List documentation, at least
04:38:16 <oerjan> for a start
04:38:19 <Mat^> ;P
04:38:35 <Cale> Oh, it's
04:38:40 <taruti> "concatWith c = concat . intersperse c" is quite nice, seems like every time I need intersperse it is followed by concat
04:38:50 * wli checks out darcs' unstable repo.
04:38:57 <Cale> just_find cmp xs a = any (\x -> cmp x a) xs
04:39:42 <Cale> just_count cmp xs a = length . filter (\x -> cmp x a) $ xs
04:40:00 <Mat^> :>
04:40:11 <Mat^> I have to understand \x -> thing first ;>
04:40:19 <Cale> Oh, it makes a function
04:40:23 <taruti> that is a lambda
04:40:26 <Cale> > (\x -> x^2) 5
04:40:27 <lambdabot>  25
04:40:44 <Mat^> Cale: ahm
04:40:45 <Cale> (\x -> x^2) is the function which squares its argument
04:41:03 <bwx> how can i improve this function? http://hpaste.org/2425
04:41:06 <Cale> (\x -> cmp x a) is the function which takes the parameter x and returns cmp x a
04:41:42 <Mat^> lambda just substitutes right?
04:41:57 <Cale> yeah
04:42:07 <Cale> If I get what you're asking :)
04:42:16 <oerjan> for a slightly subtle definition of "just"
04:42:23 <Cale> (\x -> x^2) 5 = 5^2 = 25
04:42:35 <Mat^> my english is far from being fluent, so it's sometimes difficult ;P
04:42:40 <Mat^> oerjan: ;>
04:42:45 <Cale> It's rather like   let f x = x^2 in f 5
04:43:07 <Mat^> ok
04:43:10 <desp> (\x -> cmp x a) == (cmp a) , no?
04:43:18 <Cale> desp: no
04:43:22 <Cale> It's flip cmp a
04:43:23 <oerjan> flip cmp a
04:43:36 <desp> right.
04:43:37 <oerjan> or (`cmp` a)
04:43:40 <Cale> right
04:46:40 <Mat^> Oh, btw, is it propper place to ask about parsec?
04:46:49 <oerjan> certainly
04:46:59 <Mat^> (one moment)
04:47:38 <Mat^> http://hpaste.org/2426
04:47:59 <Mat^> I have one issue - have a look at operator "<-", it's assignement operaotr
04:48:01 <Mat^> operator
04:48:11 <wli> Darcs/Diff.lhs and Darcs/Patch/Apply.lhs seem pertinent.
04:48:29 <Mat^> and, when I for example try parse expression "a <- 5", it makes
04:48:45 <Mat^> "a < (-5)" instead of "(a) <- (5)"
04:48:49 <oerjan> right, you need to (1) put <- first, (2) put a try around it
04:48:59 <bwx> i'm having trouble understanding GADT
04:49:14 <Cale> http://hpaste.org/2425#a1 -- bwx
04:49:42 <Mat^> oerjan: but hmmm
04:50:04 <bwx> Cale: can you please explain why this is better?
04:51:28 <Cale> bwx: That's kind of subjective. I think it's a little clearer.
04:51:28 <oerjan> oh, maybe you don't need try
04:51:43 <bwx> Cale: what about performance?
04:51:44 <oerjan> if reservedOp does that automatically
04:51:57 <Cale> I think it's the same.
04:52:05 <desp> > let f p x = if p x then Just x else Nothing in f (== 0) 0
04:52:14 <oerjan> Mat^: by first, i mean before < in the table
04:52:14 <lambdabot>  Just 0
04:52:15 <desp> is there a built-in function that does this?
04:52:42 <oerjan> oh wait, they're grouped by precedence?
04:53:10 <Mat^> oerjan: yes
04:53:15 <Mat^> oerjan: I cannot do that
04:53:15 <desp> @hoogle (a -> Bool) -> a -> Maybe a
04:53:15 <lambdabot> No matches, try a more general search
04:53:22 <Cale> bwx: also, yours stack overflows on large cases
04:53:23 <desp> @hoogle a -> (a -> Bool) -> Maybe a
04:53:23 <lambdabot> No matches, try a more general search
04:53:27 <Cale> *Main> mapFind (==767376000000) m
04:53:28 <Cale> *** Exception: stack overflow
04:53:28 <Cale> *Main> mapFind' (==767376000000) m
04:53:28 <Cale> Just (876000,767376000000)
04:53:35 <Mat^> Cale: "<" has higher priority than "<-" :S
04:53:37 <Cale> *Main> let m = M.fromList [(x,x^2) | x <- [1..1000000]]
04:53:39 <Mat^> sorry
04:53:39 <oerjan> i see, this may be a bug in reservedOp - it doesn't check for maximal munch?
04:53:40 <Mat^> oerjan:
04:53:58 <Mat^> I would rather say it's my fail
04:54:14 <Cale> *Main> mapFind' (==767376000000) m
04:54:14 <Cale> Just (876000,767376000000)
04:54:14 <Cale> (0.78 secs, 0 bytes)
04:54:22 <DRMacIver> desp: It could probably more idiomatically expressed as \x -> do { guard (p x); return x; }
04:54:23 <Cale> It's pretty fast, regardless :)
04:54:44 <DRMacIver> desp: But I don't think there's a built in function.
04:54:55 <bwx> Cale: ok thanks!
04:55:26 <DRMacIver> Or maybe listToMaybe [ x | p x ]
04:55:35 <Mat^> Or I guess it's language fail, because everytime
04:55:40 <DRMacIver> err. That's "listToMaybe [x | p x]"
04:55:50 <Mat^> "<-" is propper, then "<" -expression is also propper :S
04:55:50 <desp> DRMacIver: ah.
04:56:15 <DRMacIver> (Alas for the lack of monad comprehensions)
04:56:17 <oerjan> Mat^: yes, but you would expect maximal munch as haskell itself requires
04:56:39 <oerjan> in haskell, < and <- are both legal tokens
04:57:09 <DRMacIver> oerjan: But not neccessarily legal identifiers.  <- is reserved syntax...
04:57:44 <Mat^> I guess that best option is to change '<-' to '='
04:57:56 <oerjan> DRMacIver: doesn't matter here
04:58:02 <DRMacIver> ok
04:58:25 <oerjan> Mat^: but won't that give you a == problem?
04:58:45 <Mat^> oerjan: I guess not
04:58:53 <Mat^> because there is no unary '=' operator
04:59:18 <DRMacIver> desp: Sorry, my list comprehension version doesn't work, obviously. :)
04:59:43 <Mat^> exp_a == exp_a must be (exp_a) == (exp_a)
05:00:02 <desp> DRMacIver: don't worry, I didn't like it anyway ;)
05:00:23 <DRMacIver> Heh
05:00:35 <DRMacIver> The guard one *is* better though. :)
05:00:54 <desp> yeah.
05:01:10 <oerjan> Mat^: i am not sure that parsec is that clever
05:01:29 <DRMacIver> (And works for arbitrary MonadZero instances as a bonus)
05:01:32 <Mat^> oerjan: it works ;>
05:01:37 <oerjan> oh wait...
05:01:49 <DRMacIver> Sorry, MonadPlus (sigh again)
05:02:47 <DRMacIver> @pl \p x -> do { guard (p x); return x; }
05:02:47 <lambdabot> (line 1, column 12):
05:02:47 <lambdabot> unexpected "{"
05:02:47 <lambdabot> expecting variable, "(", operator or end of input
05:02:48 <oerjan> i was going to suggest you could change < to use notFollowedBy (char '-')
05:03:10 <DRMacIver> @pl \p x ->  guard (p x) >> return x
05:03:10 <lambdabot> (`ap` return) . (((>>) . guard) .)
05:03:16 <DRMacIver> Hm.
05:03:20 <DRMacIver> Gross.
05:04:00 <Mat^> oerjan: it would be ok ;>
05:04:05 <Mat^> everything depends on my teacher
05:04:06 <Mat^> ;S
05:04:55 <oerjan> i suppose = works because == is tested first
05:05:38 <ivant> > map ord "Compiz"
05:05:40 <lambdabot>  [67,111,109,112,105,122]
05:05:47 <Mat^> = works also because of, even if it will match "expression =" it will not match right-side expression
05:05:53 <Mat^> there is no expression starting with "="
05:06:11 <oerjan> Mat^: btw have you defined reservedOpNames?
05:06:16 <Mat^> oerjan: yes
05:06:26 <ivant> > map (printf "%x" . ord) "Compiz"
05:06:27 <lambdabot>  Add a type signature
05:06:33 <Mat^> I've put there every operator I might use ;P
05:06:58 <ivant> > map (printf "%x" :: Int -> String) $ map ord "Compiz"
05:07:00 <lambdabot>  ["43","6f","6d","70","69","7a"]
05:07:54 <gkr> @type printf
05:07:56 <lambdabot> forall r. (PrintfType r) => String -> r
05:08:49 <oerjan> Mat^: this is _very_ weird, because "The lexeme parser (reservedOp name) parses (symbol name), but it also checks that the name is not a prefix of a valid operator."
05:09:11 <oerjan> so it _should_ have recognized <-
05:09:51 <Mat^> I guess, by 'valid operator' manual means valid custom not-reserved operator right?
05:10:43 <Mat^> it checks '<' it's not prefix of valid custom operator (in my case), everything fits
05:10:53 <Mat^> so it chooses to use < not <-
05:11:12 <oerjan> no i would certainly expect it to check for <-
05:11:50 <oerjan> have you defined opStart and opLetter?
05:12:41 <Mat^> I might be wrong, but I had problems with that :P
05:13:03 <oerjan> it may be that it only checks against those, and not against the reserved op list. but for things to work properly, every reserved op should be of the same form.
05:13:08 <Mat^> so I defined those that way, that every reservedOp is not valid ;P
05:13:43 <oerjan> that might actually be the cause of your last problem
05:14:25 <oerjan> on opLetter: "This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the reservedOp parser won't work correctly."
05:14:33 <Mat^> I made it, because when I had @@@@int (which means '4-dim array of ints') it said, that @ is prefix of valid operator ;P
05:14:56 <Mat^> :S I didn't read manual well ;P
05:15:07 <Mat^> my fail
05:15:23 <oerjan> well it is a big manual :)
05:16:20 <oerjan> it seems like you can leave out opStart however
05:16:41 <Mat^> and I was way to optimistically - I started project way too close deadline ;>
05:16:53 <kpreid> I've got a code fragment which is "sequence_ . concatMap (map o . f) . g $ z". Any suggestions as to make it clearer what this does? (f and g are list-generating functions, and are longer expressions in the actual code)
05:17:09 <Mat^> oerjan: now I see solution with @, I might set "@" as valid opStart, and not set "@" as valid letterOp
05:17:21 <Mat^> if I get it right
05:17:36 <Mat^> opLetter
05:18:07 <oerjan> ah right that might work too
05:18:32 <kpreid> actually, never mind, I just realized that it's two mapM_s
05:20:07 <Mat^> maybe I should warn user, that "<-" has been read as assignement, not less and minus ;P
05:20:21 <fax> <- is perfect for assignment
05:20:47 <fax> I wish people could have used that instead of = in the past :/
05:20:56 <Mat^> if (a<-b) probably would compile not way user would like to ;>
05:21:13 <Botje> pfft. you're the compiler writer, you make the choice.
05:21:25 <Botje> and a < -b doesn't occur all too often.
05:21:29 <Mat^> Botje: well, actually my teacher :
05:21:30 <Mat^> :P
05:21:31 <kpreid> Mat^: prohibit lack of whitespace around <- :)
05:21:49 <Mat^> kpreid: ? ;>
05:22:04 <kpreid> Mat^: then the compiler would reject a<-b
05:22:19 <Mat^> ah, I didnt' see 'lack' ;>
05:22:19 <Botje> or assume "<-" is "<-", not "< -"
05:22:22 <kpreid> it would allow only a <- b or (a< -b or a < -b)
05:23:20 <oerjan> kpreid: that doesn't fit into parsec's lexer model however.
05:23:28 <Mat^> or just use '=' as assignement operator, and everything will work fine ;>
05:24:15 <Mat^> oh, one more tiny problem ;>
05:24:26 <Mat^> parsing chars, ie 'a' etc
05:24:38 <oerjan> char 'a'
05:24:51 <Mat^> I used reservedOp "'" ; d <- anyChar ...
05:25:09 <oerjan> that would skip space after '
05:25:12 <Mat^> right
05:25:23 <v0|d> :t flip
05:25:26 <oerjan> so use char '\'' instead, i guess
05:25:28 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
05:25:28 <Mat^> so I might use char '\'' instead?
05:25:44 <Mat^> ok ;>
05:25:51 <oerjan> remember to skip whitespace after the final '
05:26:08 <Mat^> lexeme (...)
05:26:27 <Mat^> and everything seems to work fine
05:26:35 <Mat^> haskell made me to use voodoo programming ;P
05:28:27 <Mat^> oerjan: thanks! things now are seems more clear to me ;]
05:28:47 <oerjan> you're welcome
05:29:28 <oerjan> to me too, i had to check the manual myself
05:29:39 <Mat^> ;>
05:32:12 <oerjan> afk
05:32:57 <jedai> How do you get hpaste to announce a paste ? I checked the announce box, but I don't see any announcement ?
05:33:13 <Saizan> that should suffice
05:33:26 <desp> the hpaste bot has ran out of hpaste
05:33:29 <Saizan> but the bot is not here?
05:33:47 <desp> s/ran/run/
05:34:03 <desp> (right?)
05:35:06 <jedai> I pasted http://hpaste.org/2425#a3 on bwx question (well I'm a bit late, my IRC client was stuck a little... ^^ )
05:38:34 <fasta> What is MyProject.Test.sat_sugg<cut off> in a -hd profile? sat_sugg is not anything I defined.
05:39:42 <fasta> It creates a massive space leak.
05:41:42 <jedai> bwx: If you're still there, you should check my paste, I think it's better than Cale suggestion (or yours)
05:45:52 <yaxu> jedai: impressively short
05:47:46 <jedai> yaxu: Yep, but more important, I find it express the idea clearly ^^
05:54:56 <roconnor> does jim apple hang out here?
05:55:32 <bwx> jedai: cool thanks i'm looking at it...
05:56:21 <yaxu> jedai: yes that as well :)
05:57:04 <kpreid> It just occurred to me that you can use <- to reify any pattern match failure.
05:57:07 <kpreid> > do {[a] <- return []; return a} :: Either String ()
05:57:10 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:4-6"
05:57:37 <xerox> wow.
05:58:27 <xerox> That constrains the 'a' though.
05:58:39 <kpreid> That's just the type sig to make it concrete
05:59:00 <bwx> jedai: converting to a list is not slow?
06:02:08 <Saizan_> bwx: we hope it's deforested
06:05:26 <jedai> bwx: Yep, it's deforested, even in interpreted mode (in GHCI) so a fortiori when compiled, in fact the list don't exist, it's compiled to a loop
06:07:09 <jedai> bwx: Try it and you'll see that in GHCi it's faster than Cale version (it might not be the case when compiled with optimisation, but it won't be slower), there's no stack overflow, and it's short :)
06:07:16 <bwx> jedai: cool. does the loop break as soon as an element is found, or does it always loop through all the elements?
06:07:59 <jedai> bwx: Yep, the loop break as soon that the element is found, since find immediately return, and toList is lazy
06:09:37 <bwx> sweet
06:12:26 <jedai> @src find
06:12:27 <lambdabot> find p          = listToMaybe . filter p
06:12:29 <Cale> jedai: You're certain about that deforestation? I think it will at least create the cons cells, they'll just be destroyed again immediately.
06:13:10 <SamB_XP> Cale: that sounds SLOOW
06:13:19 <jedai> Cale: Maybe you're right, to be sure I should inspect the compiler output, but I'm not too good at that... :)
06:13:22 <SamB_XP> are you sure they won't just be left for the GC?
06:16:02 <jedai> bwx: Thing is filter produce its output lazily, and listToMaybe only need the head (if it exists), the beauty of lazy evaluation is that it allows you to reuse components efficiently without a complicated interface :)
06:16:10 <desp> hrm
06:17:43 <Cale> http://hpaste.org/2427
06:18:06 <Cale> It looks like it really is creating the list to me.
06:18:40 <Cale> er, that was truncated a bit, but the important stuff seems to be there.
06:22:02 <Cale> Main.a =
06:22:02 <Cale>   case GHC.List.filter @ (GHC.Num.Integer, GHC.Num.Integer) Main.lvl2 Main.lvl8
06:22:02 <Cale>   of wild_a1Ip {
06:22:02 <Cale>     [] -> Data.Maybe.Nothing @ (GHC.Num.Integer, GHC.Num.Integer);
06:22:02 <Cale>     : a1_a1Is ds1_a1It ->
06:22:02 <Cale>       Data.Maybe.Just @ (GHC.Num.Integer, GHC.Num.Integer) a1_a1Is
06:22:04 <Cale>   }
06:22:53 <sorear> Cale: is hpaste down again?
06:23:02 <Cale> Just the bot
06:23:44 <Cale> (“It's just a simple functional language” is an unregisterised trademark of Peyton Jones Enterprises, plc.)
06:23:49 <Cale> ahaha
06:23:59 <Cale> (that's in the GHC documentation)
06:24:33 <SamB_XP> what does the plc stand for?
06:24:46 <SamB_XP> programming language compilers?
06:24:59 <Cale> Public Limited Company, ordinarily
06:25:36 <wli> "Limited" refers to "limited liability."
06:25:53 <sorear> eek, x^2
06:26:39 <oerjan> sorear: what do you have against a harmless polynomial?
06:27:13 <sorear> oerjan: when GHC gains the ability to properly compile x^2 into x*x, I'll stop eeking.
06:27:16 <Cale> Looking at the core for it?
06:27:45 <sorear> Cale: no, I've just had lots of bad experiences with ^2 performance (and the Core confirms no inlining)
06:27:47 <fasta> How can I know what's taking up all the space when it are compiler generated symbols?
06:27:53 <Cale> Heh, somehow I think there are bigger fish to fry still :)
06:28:11 <sorear> ^2 has a pretty big effect
06:28:16 <SamB_XP> many of those fish may be hoist with the same petard
06:28:33 <sorear> consider that you're not even matching against a constant!
06:28:36 <fasta> Are strictness annotations for function that have no conditionals redundant?
06:28:51 <fasta> functions*
06:29:21 <fasta> The "Performance" wiki page contains way too little information to help me.
06:29:41 <Cale> sorear: Does GHC normally assume much about instances apart from the type?
06:30:03 <fasta> All I know is that memory usage depends on how long it runs.
06:30:04 <sorear> Cale: what else is there to assume?
06:30:12 <Cale> sorear: I'm not certain that you can prove x^2 = x*x without knowing that the appropriate instances of Num and Integral are actually reasonable.
06:30:23 <Cale> I suppose that it could at least specialise.
06:30:29 <Igloo> The real problem with ^2 is that (^) is lazy in its first argument
06:30:40 <sorear> Cale: actually, it's very easy
06:30:44 <sorear> @src (^)
06:30:44 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:30:45 <Igloo> as x^0 = 1
06:30:48 <sorear> @src ^
06:30:49 <lambdabot> Source not found. You type like i drive.
06:31:15 <SamB_XP> Igloo: hmm.
06:31:22 <sorear> anyways, just unfold the definition of ^ and evaluate the recursion on the second argument
06:31:24 <SamB_XP> Haskell' should fix that
06:31:26 <Cale> I suppose you could look for common numeric types and optimise the construction of products.
06:31:28 <Saizan_> the profiler cheat to get a stack trace doesn't work if the exception is caught, right?
06:31:39 <Cale> SamB_XP: Are you sure?
06:31:42 <SamB_XP> Saizan_: it does
06:32:11 <Cale> It's actually kind of a good thing that x^0 doesn't need to evaluate x.
06:32:16 <sorear> Igloo: so you're saying that if ^ was strict, then x ^ 2 :: Integer  would be compiled to x * x ?
06:32:19 <SamB_XP> Cale: hmm.
06:32:22 <SamB_XP> well.
06:32:42 <SamB_XP> okay, I guess you might be right
06:32:52 <Igloo> No, but it would be a lot better than it is now
06:32:55 <SamB_XP> anyway, ^ 2 uses 2 :: Integer
06:33:17 <Cale> Yeah, once there are constants of known type, it should be able to do better.
06:34:05 <wli> -Wall complains about defaulting and I've taken to doing everything necessary to shut up -Wall.
06:34:06 <Cale> It could might help to optimise the construction of powers by doing divide and conquer, to keep the intermediate products of similar size.
06:34:26 <sorear> Cale: that's how the definition of ^ works
06:34:36 <SamB_XP> Cale: divide is slow!
06:34:38 <Cale> Oh, good :)
06:34:48 <Cale> SamB_XP: Are you being facetious?
06:34:53 <SamB_XP> yes
06:34:59 <wli> sorear: Does it bitreverse or just use duplication on even powers?
06:35:25 <sorear> wli: I have no idea what you're talking about
06:35:30 <jedai> Hmm... I just tried to change x^2 for x*x, and it slowed down the program (with -O2), does it seems like normal behaviour to you ?
06:35:50 <wli> sorear: For divide-and-conquer exponentiation.
06:35:53 <sorear> no... does x contain redexes?
06:36:21 <sorear> wli: what's bitreversing?
06:36:29 <sorear> wli: what's duplication on even powers?
06:36:34 <jedai> sorear: look at the paste by Cale, that's the program I'm speaking about
06:38:56 <wli> sorear: duplication is pow x n | r == 0 = t | otherwise = x * t where { (q, r) = n `divMod` 2 ; t = (pow x q)^2 }
06:39:32 <wli> sorear: bit reversal reverses the bits of n and builds the result bottom-up
06:40:24 <sorear> sounds like they would make the same number of arbitrary-precision operations and thus be equally fast in practice
06:40:43 <wli> sorear: Bitreversal's faster by some constant factor.
06:43:45 <SamB_XP> wli: it might depend on how fast you can bitreverse?
06:47:59 <wli> Yes.
06:48:15 <wli> For Int it
06:48:20 <wli> For Int it's trivial.
06:48:36 <wli> You don't need to construct the bitreversed number. Just traverse the bits in reverse order.
07:06:34 <Philippa> is there any good tutorial material on gtk2hs's tree stores, model etc?
07:06:47 <Philippa> or even just an overview with more info than I'll find in the haddock?
07:09:04 <bwx> Philippa: the manual at www.gtk.org has a treeview overview
07:11:30 <fxn> which is the type of a function that has no argument and returns a constant Int ?
07:12:16 <Saizan_> fxn: Int
07:14:12 <hpaste>  fxn pasted "(no title)" at http://hpaste.org/2428
07:14:34 <fxn> Saizan_: that one is correct then? (it is an exercise from Programming Haskell)
07:14:46 <fxn> "in" Haskell sorry
07:14:58 <jedai> fxn: Yes, it's correct
07:15:15 <jedai> fxn: But why don't you run it and see for yourself ?
07:15:26 <fxn> does that define a function because of the "="? looks like a regular variable assignment
07:15:50 <Saizan_> fxn: well a function without argument it's just a value
07:15:55 <fxn> jedai: I know it works, my question is about formal stuff
07:16:43 <fxn> Saizan_: but technically it is still a function right? to have a variable you need to use let, where, etc
07:16:56 <jedai> fxn: As Saizan said, but in Haskell, don't forget even a value isn't really just a "value", in fact your example contain a computation that won't be run if you don't use this value
07:16:57 <Lemmih> fxn: In Haskell there's no difference between functions and variables.
07:17:00 <Saizan_> since there's no assignment there's no distinction
07:17:48 <Saizan_> fxn: even with let, where, .. you don't have a variable if by variable you mean mutable cell
07:18:13 <fxn> I mean, where n = length xs
07:18:22 <Saizan_> you're just defining equations
07:18:46 <jedai> fxn: Why would let or where make it any different ? You can define functions with arguments even in let and where, you know ?
07:19:10 <fxn> so I need to think in terms of equation rewriting and graph computation decomposition etc
07:20:00 <fxn> jedai: I see
07:20:07 <Saizan_> yup, you have definitions that are lazily reduced
07:20:33 <jedai> fxn: You don't "need to" though it's pretty close to how Haskell works, this question was probably asked to make you conscious of the fact that there aren't really difference between "value" and "function" in Haskell
07:21:17 <bwx> how can i test if an element appears more then once in a list?
07:21:53 <jedai> bwx: An element you know, or just check if the list contains doublons ?
07:22:06 <bwx> if the list contains doublons
07:22:32 <jedai> bwx: nub l == l
07:23:05 <LoganCapaldo> @type \list -> not null [ () | x <- list, y <- list, x == y ]
07:23:13 <jedai> bwx: That should work well for small lists (small being raltive to your need)
07:23:14 <lambdabot>     Couldn't match expected type `Bool'
07:23:14 <lambdabot>            against inferred type `[a] -> Bool'
07:23:15 <LoganCapaldo> @type \list -> not $ null [ () | x <- list, y <- list, x == y ]
07:23:17 <lambdabot> forall t. (Eq t) => [t] -> Bool
07:23:19 <twanvl> or: any . ((>1) . length) . group . sort
07:23:42 <kjdf> @src nub
07:23:43 <lambdabot> nub = nubBy (==)
07:23:58 <kjdf> @src nubBy
07:23:58 <lambdabot> nubBy eq []             =  []
07:23:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:24:22 <LoganCapaldo> > \list -> not $ null [ () | x <- list, y <- list, x == y ] $ [1,1..]
07:24:23 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
07:24:32 <LoganCapaldo> > (\list -> not $ null [ () | x <- list, y <- list, x == y ]) [1,1..]
07:24:34 <lambdabot>  True
07:24:48 <kjdf> > nub [1, 2, 1]
07:24:49 <Saizan_>  any . (not . null . drop 1) . group . sort
07:24:49 <lambdabot>  [1,2]
07:24:56 <LoganCapaldo> > any . ((>1) . length) . group . sort $ [1,1..]
07:24:57 <lambdabot>  Couldn't match expected type `a -> Bool'
07:25:07 <LoganCapaldo> > (any . ((>1) . length) . group . sort)  [1,1..]
07:25:08 <lambdabot>  Couldn't match expected type `a -> Bool'
07:25:32 <fxn> LoganCapaldo: that one is lazy in the sense that if there's a doublon it halts the computation of list x list one it finds one?
07:25:32 <Saizan_> never use length if you don't need to, you can choke a webserver!
07:25:34 <jedai> bwx: Saizan_'s solution is probably better for bigger lists
07:25:39 <LoganCapaldo> > (any . (not . null . drop 1) . group . sort) [1,1..]
07:25:39 <lambdabot>  Couldn't match expected type `a -> Bool'
07:25:42 <LoganCapaldo> arg
07:25:57 <LoganCapaldo> how can I demonstrate my point if I can't get other peoples code to work? :)
07:26:07 <Saizan_> :D
07:26:12 <Saizan_> ?ty any
07:26:12 <jedai> LoganCapaldo: any (not . null . drop 1) . group . sort
07:26:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:26:24 <jedai> LoganCapaldo: You have one point too many
07:26:34 <LoganCapaldo> > let foo = any (not . null . drop 1) . group . sort in foo [1,1..]
07:26:37 <lambdabot> Terminated
07:26:40 <LoganCapaldo> there!
07:26:43 <LoganCapaldo> :p
07:27:05 <Saizan_> > sort [1,1..]
07:27:09 <lambdabot> Terminated
07:27:15 <jedai> > let foo l = nub l == l in foo [1,1..]
07:27:18 <lambdabot> Terminated
07:27:38 <jedai> > let foo l = nub l /= l in foo [1,1..]
07:27:42 <lambdabot> Terminated
07:27:59 <Saizan_> > (\list -> not $ null [ () | x <- list, y <- list, x == y ]) (2:[1,1..])
07:28:01 <lambdabot>  True
07:28:18 <ivant> lambdabot says: Terminated. I'll be back
07:28:27 <xerox> Saizan_: s/()/undefined/ :D
07:28:57 <Saizan_> > (\list -> not $ null [ () | x <- list, y <- list, x == y ]) ([2])
07:28:58 <lambdabot>  True
07:29:04 <LoganCapaldo> aha
07:29:05 <LoganCapaldo> bug
07:29:14 <fxn> Saizan_: that one skips the diagonal?
07:29:47 <LoganCapaldo> silly me
07:29:48 <xerox> any (uncurry elem) . pick
07:29:58 <LoganCapaldo> @src pick
07:29:58 <lambdabot> Source not found. That's something I cannot allow to happen.
07:30:01 <xerox> Cale: where did you have pick ? (:
07:30:21 <jedai> Strange, nub [1,1..] == [1,1..] should terminate...
07:30:22 <Saizan_> fxn: i was just trying to find a bug in LoganCapaldo's solution :>
07:31:27 <Saizan_> fxn: and no, it doesn't skip it.. that's the problem
07:31:38 <fxn> > (\list -> length list == length [ x | x <- list, y <- list, x == y ]) ([2])
07:31:40 <lambdabot>  True
07:32:01 <fxn> > (\list -> length list != length [ x | x <- list, y <- list, x == y ]) ([2])
07:32:02 <lambdabot>   Not in scope: `!='
07:32:12 <LoganCapaldo> @type any (map isJust) map (\(x:xs) -> find x xs) . map tails
07:32:13 <fxn> how's != in Haskell
07:32:14 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Bool]'
07:32:14 <lambdabot>     In the first argument of `any', namely `(map isJust)'
07:32:20 <LoganCapaldo> @type find
07:32:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:32:24 <xerox> fxn: that doesn't work, but it is /=
07:32:38 <LoganCapaldo> @type any (map isJust) map (\(x:xs) -> find (== x) xs) . map tails
07:32:40 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Bool]'
07:32:40 <lambdabot>     In the first argument of `any', namely `(map isJust)'
07:32:55 <fxn> xerox: why?
07:33:01 <LoganCapaldo> @type any (map isJust) . map (\(x:xs) -> find (== x) xs) . map tails
07:33:03 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Bool]'
07:33:03 <lambdabot>     In the first argument of `any', namely `(map isJust)'
07:33:07 <LoganCapaldo> @type any
07:33:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:33:17 <LoganCapaldo> @type any isJust . map (\(x:xs) -> find (== x) xs) . map tails
07:33:19 <lambdabot> forall a. (Eq [a]) => [[a]] -> Bool
07:33:33 <LoganCapaldo> Hrm
07:33:40 <EvilTerran> @type any . map (\(x:xs) -> x `elem` xs) . map tails
07:33:42 <lambdabot>     Couldn't match expected type `a -> Bool'
07:33:42 <lambdabot>            against inferred type `[Bool]'
07:33:58 <EvilTerran> @type any (\(x:xs) -> x `elem` xs) . map tails
07:33:59 <lambdabot> forall a. (Eq [a]) => [[a]] -> Bool
07:34:03 <matthew-_> fxn: it's closer to the mathematical symbol that way
07:34:20 <Saizan_> @type any (\(x:xs) -> x `elem` xs) . tails
07:34:22 <lambdabot> forall a. (Eq a) => [a] -> Bool
07:34:23 <fxn> matthew-_: yeah, I asked why it does not work
07:34:24 <ivant> @ty fromMaybe
07:34:25 <lambdabot> forall a. a -> Maybe a -> a
07:34:27 <LoganCapaldo> @type any (\(x:xs) -> x `elem` xs) . tails
07:34:28 <lambdabot> forall a. (Eq a) => [a] -> Bool
07:34:37 <EvilTerran> what're we trying to define here, exactly?
07:34:43 <LoganCapaldo> >  any (\(x:xs) -> x `elem` xs) . tails [2]
07:34:44 <lambdabot>  Couldn't match expected type `a -> [[t]]'
07:34:49 <LoganCapaldo> >  any (\(x:xs) -> x `elem` xs) . tails $ [2]
07:34:50 <lambdabot>   Non-exhaustive patterns in lambda
07:34:57 <LoganCapaldo> >  any (\(x:xs) -> x `elem` xs) . tails $ [1,1..]
07:34:58 <lambdabot>  True
07:35:03 <Saizan_> EvilTerran: check if a list contains duplicates
07:35:04 <LoganCapaldo> demonstrate how silly I am?
07:35:07 <xerox> any (\xs -> case xs of [] -> False; (x:xs) -> elem x xs) . tails
07:35:16 <xerox> It would be nicer with list catamorphism
07:35:30 <xerox> any (list False elem) . tails
07:35:39 <EvilTerran> quite. i want one of those.
07:35:43 <matthew-_> > let (!=) = (/=) in 6 != 5 -- for fxn
07:35:44 <lambdabot>  True
07:35:49 <LoganCapaldo> >  any (foldr elem False) . tails $ [1,1..]
07:35:50 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
07:35:54 <fxn> matthew-_: heh :-)
07:36:24 <Cale> what are you writing?
07:36:25 <Saizan_> > any (\xs -> case xs of [] -> False; (x:xs) -> elem x xs) . tails $ (2:[1,1..])
07:36:29 <lambdabot> Terminated
07:36:31 <Cale> Testing for duplicates?
07:36:32 <xerox> LoganCapaldo: can't do it that way
07:36:37 <LoganCapaldo> clearly not
07:36:39 <matthew-_> fxn: it's just a choice. Someone, some time ago decided to use /= rather than !=
07:36:47 <xerox> Cale: yup
07:36:50 <Cale> The trivial  nub xs == xs  is actually surprisingly good at that.
07:37:09 <fxn> matthew-_: yeah, that's fine, I understood that the solution was wrong conceptually
07:37:14 <LoganCapaldo> Cale, I was complaining about [1,1..]
07:37:17 <jedai> Cale: but not on the clever [1,1..] example they chosed...
07:37:29 <fxn> in addition to the syntax error
07:37:40 <xerox> It can't terminate anyway.
07:37:45 <fxn> > (\list -> length list /= length [ x | x <- list, y <- list, x == y ]) ([2])
07:37:46 <lambdabot>  False
07:37:50 <fxn> that one
07:38:01 <fxn> > (\list -> length list /= length [ x | x <- list, y <- list, x == y ]) ([2, 2])
07:38:03 <lambdabot>  True
07:38:08 <matthew-_> fxn: sorry, I missed the first half of the conversation and misunderstood your question. Sorry.
07:38:16 <xerox> fxn: that returns true only if the list is of all equal elements
07:38:21 <EvilTerran> xerox, it should be able to terminate when a duplicate is found
07:38:24 <Cale> ah, yeah, because nub of that doesn't have a second element
07:38:24 <fxn> > (\list -> length list /= length [ x | x <- list, y <- list, x == y ]) ([2, 2, 3])
07:38:25 <lambdabot>  True
07:38:30 <xerox> fxn: in which case it is faster to do null . tail . group
07:38:46 <fxn> xerox: see counterexample
07:38:48 <xerox> Oh.
07:38:52 <Cale> (1:[1..]) does work though (not the same list)
07:39:11 <fxn> xerox: I think that condition on the diagonal is an iff
07:39:37 <jedai> Cale: Yep I know, an infinite list of one element is the only example that stuck nub xs == xs
07:39:58 <fxn> you have at least the diagonal returned, and you have more than those iff there are duplicates on the diagonal
07:40:28 <jedai> Cale: but it can be considered a bug in the function since it definitely should be able to conclude in that case...
07:40:38 <xerox> fxn: cool :)
07:41:00 <Cale> You could do something like  any (\x -> x == nub x) . inits
07:41:10 <fxn> nevertheless that one works on finite lists only, that's right?
07:41:27 <Cale> That's almost certainly much worse though :)
07:41:40 <fxn> you could have a solution that was able to give True on infinite lists
07:41:51 <Cale> er
07:41:56 <xerox> Can you?
07:41:56 <LoganCapaldo> fxn: You could?
07:41:57 <jedai> fxn: Are you speaking about your solution, in which case yes, but the x == nub x works on infinite list
07:42:00 <LoganCapaldo> I hope not?
07:42:07 <Cale> any (\x -> x /= nub x) . inits  rather
07:42:22 <jedai> fxn: but not on circular list of only one element
07:42:28 <fxn> yeah, I mean an implementation, a solution to the problem, the one based in length can't
07:43:00 <LoganCapaldo> Oh I misread
07:43:21 <LoganCapaldo> I thought you meant an implementation that would return True if given any infinite list
07:43:40 <fxn> in Perl you iterate and maintain a hash table and halt as soon as a counter is teo
07:43:42 <fxn> two
07:44:25 <jedai> fxn: Yep, you can do that in Haskell too, but Haskell is pretty list centred, so most try to use list operation to do that
07:44:39 <EvilTerran> > (\xs -> (case xs of (x:y:_) | x == y -> True; _ -> False) || nub xs == xs) [1,1..]
07:44:41 <lambdabot>  True
07:44:54 <jedai> fxn: Beside it requires Ord on the element of the list, and not just Eq
07:45:43 <jedai> EvilTerran: foo 1:[2,2..] ?
07:46:03 <fxn> jedai: I don't see hash tables in the index of "Programming in Haskell", where can I learn about them?
07:46:11 <ndm> @seen sorear
07:46:11 <lambdabot> sorear is in #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 2m 30s ago.
07:46:13 <EvilTerran> huh. quite.
07:46:15 <Cale> > or . ap (zipWith member) (scanl (flip Data.Set.insert) empty) $ [1..100000]
07:46:15 <lambdabot> Terminated
07:46:18 <jedai> > (\xs -> (case xs of (x:y:_) | x == y -> True; _ -> False) || nub xs == xs) (2:[1,1..])
07:46:19 <Cale> > or . ap (zipWith member) (scanl (flip Data.Set.insert) empty) $ [1..10000]
07:46:20 <lambdabot> Terminated
07:46:22 <lambdabot> Terminated
07:46:24 <Cale> > or . ap (zipWith member) (scanl (flip Data.Set.insert) empty) $ [1..1000]
07:46:25 <lambdabot> Terminated
07:46:27 <Cale> uh...
07:46:32 <Cale> > or . ap (zipWith member) (scanl (flip S.insert) empty) $ [1..1000]
07:46:33 <lambdabot> Terminated
07:46:35 <Cale> > or . ap (zipWith S.member) (scanl (flip S.insert) empty) $ [1..1000]
07:46:36 <lambdabot> Terminated
07:46:37 <LoganCapaldo> > 1 + 1
07:46:38 <Cale> huh
07:46:39 <lambdabot>  2
07:46:39 <ndm> sorear: you were saying my optimisations seem to offer different benefits from Jhc, care to expand?
07:46:42 <EvilTerran> O(n^2) causing trouble, methinks.
07:46:43 <Cale> > or . ap (zipWith S.member) (scanl (flip S.insert) S.empty) $ [1..1000]
07:46:44 <lambdabot>   Not in scope: `S.insert'
07:46:44 <ndm> my Jhc knowledge is minimal
07:46:58 <Cale> > or . ap (zipWith Data.Set.member) (scanl (flip Data.Set.insert) Data.Set.empty) $ [1..1000]
07:47:00 <lambdabot>  False
07:47:07 <Cale> > or . ap (zipWith Data.Set.member) (scanl (flip Data.Set.insert) Data.Set.empty) $ [1,1..]
07:47:09 <lambdabot>  True
07:47:10 <jedai> fxn: HashTable are in the standard lib, and you can use Map to get the same propriety (almost)
07:47:22 <Cale> > or . ap (zipWith Data.Set.member) (scanl (flip Data.Set.insert) Data.Set.empty) $ "Hello"
07:47:23 <lambdabot>  True
07:47:25 <fxn> jedai: thanks
07:47:38 <Cale> That works reasonably well.
07:47:51 <LoganCapaldo> Cale, is true found dups, or is true no dups?
07:48:02 <Cale> True is found dups
07:48:07 <LoganCapaldo> oh wait
07:48:12 <LoganCapaldo> I can't spell "helo"
07:48:17 <jedai> fxn: Use Map rather than HashTable except if you have a specific need, since HashTable is IO bound
07:48:27 <LoganCapaldo> silly me
07:48:38 <fxn> jedai: what does IO bound mean?
07:49:20 <LoganCapaldo> I thought one of the great wise ones in here told me the std hashtable was slower than the std map?
07:49:25 <LoganCapaldo> for some reason
07:49:26 <jedai> fxn: I meant to say that HashTable isn't a functional structure in the sense that you can't modify it in place while keeping the previous version
07:49:41 <LoganCapaldo> nasty constant factors or something
07:49:47 <SamB> jedai: we're pretty sure it is also slow
07:49:57 <sorear> ndm: Back when nobench compared Haskell implementations, the jhc/ghc ratios it gave were quite different from yours.
07:50:09 <fxn> jedai: ok
07:50:14 <jedai> LoganCapaldo: Well that make a second reason not to use it (I think the hash function isn't that great and the implementation isn't quite up to par)
07:50:25 <ndm> sorear: were they better than mine?
07:50:31 <sorear> ndm: for instance, jhc does an extremely good job on digits-of-e1 (I think 5x faster), but actually makes digits-of-e2 slower
07:51:02 <sorear> ndm: no, just apparently uncorrelated
07:51:03 <fxn> jedai: do lists have any means in the language for in-place modifications? or does the std library in general work always copying lists?
07:51:16 <ndm> hehe
07:51:25 <ndm> digits-of-e2 gets quite a lot of list fusion from GHC, that may be it
07:51:38 <SamB> fxn: there's no way to modify those lists in-place
07:52:16 <jedai> fxn: list are linked list, so when you take the tail, you don't need to copy it, thus there's a great potential for sharing tails of lists
07:52:23 <ivant> @hoogle Monad m => m a -> m (Maybe a) -> m a
07:52:24 <lambdabot> Prelude.asTypeOf :: a -> a -> a
07:52:24 <lambdabot> Prelude.const :: a -> b -> a
07:52:24 <lambdabot> Prelude.seq :: a -> b -> b
07:52:28 <ndm> sorear: any notions of why Jhc might be 5x faster on e1?
07:52:32 <SamB> unless you want to do unsafe coercions, modify the raw heap, and obtain totally undefined behaviour
07:52:42 <fxn> jedai: I see that's great
07:52:43 <ivant> @ty liftM fromMaybe
07:52:45 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Maybe a1 -> a1)
07:52:46 <sorear> ndm: don't recall, sorry
07:52:48 <SamB> which might be good for kicks but not  much else
07:52:57 <ndm> yeah, its hard to pin these things down
07:53:18 <ivant> @ty liftM2 fromMaybe
07:53:19 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Maybe a1) -> m a1
07:53:28 <ndm> but i guess if it got 5x faster, then my 15% is a bit crap - I'll have to see if i can do better
07:54:03 <LoganCapaldo> @ty (<.> . <$>)
07:54:05 <lambdabot> parse error on input `.'
07:54:19 <sorear> ndm: adding new compilers to the nobench harness isn't too hard, only 6 lines or so to get jhc working... granted it's make and not haskell... but you might want to look into that for your Big Comparisons
07:54:53 <ivant> @ty liftM2 fromMaybe (undefined :: a) undefined
07:54:55 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1
07:55:15 <ivant> @ty liftM2 fromMaybe (undefined :: a)
07:55:16 <ndm> sorear: i tried, but it doesn't work under windows with mingw
07:55:17 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m (Maybe a1) -> m a1
07:55:26 <EvilTerran> @ty ((<.>) . (<$>))
07:55:28 <lambdabot> Not in scope: `<.>'
08:04:24 <SamB> sorear: do you know if JohnMeacham_ has gotten anywhere with the PNG format for object files?
08:04:48 <sorear> SamB: No.
08:11:20 <ivant> @ty guard
08:11:22 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:11:41 <ivant> guard null (Just [])
08:11:46 <ivant> > guard null (Just [])
08:11:46 <lambdabot>  Couldn't match expected type `Bool'
08:12:48 <samreid> > Just [] >>= guard . null
08:12:50 <lambdabot>  Just ()
08:13:03 <Lemmih> @seen Igloo
08:13:03 <lambdabot> Igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 9m 24s ago.
08:13:22 <EvilTerran> > Just [1] >>= guard . null
08:13:24 <lambdabot>  Nothing
08:13:49 <Igloo> hi
08:14:33 <wli> > Just [] >>= guard . not . null
08:14:34 <lambdabot>  Nothing
08:14:35 <ddarius> :t <*>
08:14:36 <lambdabot> parse error on input `<*>'
08:14:42 <ddarius> :t (<*>)
08:14:44 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:15:13 <wli> SamB: wtf? PNG for *object files*? I mean, you can stuff all that in there but it's more oriented toward images.
08:15:15 <ivant> @djinn Maybe [a] -> Maybe a
08:15:15 <lambdabot> f _ = Nothing
08:15:23 <jedai> :t <$>
08:15:25 <SamB> wli: well, it's not really PNG
08:15:25 <lambdabot> parse error on input `<$>'
08:15:37 <EvilTerran> (<$>) = fmap
08:15:46 <SamB> it's got somewhat less in common with PNG than MNG and JNG do
08:15:50 <wli> > Just [1..3] >>= guard . not . null
08:15:51 <lambdabot>  Just ()
08:15:55 <EvilTerran> but only for applicative functors. i think.
08:16:04 <SamB> but it uses the same basic file format
08:16:20 <SamB> not that it's implemented yet or anything
08:16:25 <ivant> wli, I also need to get the value of the head out :-)
08:16:27 <jedai> :t (<$>)
08:16:28 <wli> SamB: I know the concept. But why?
08:16:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:16:54 <SamB> wli: the idea is that it doesn't need to read all of the chunks at once
08:17:07 <SamB> to save time and RAM
08:17:25 <wli> > Just [1..3] >>= \xs -> do { guard $ not $ null xs ; return $ head xs }
08:17:27 <lambdabot>  Just 1
08:17:32 <EvilTerran> > let foo = liftM2 (>>) (guard . not . null) Just in (foo [1,2,3], foo [])
08:17:33 <lambdabot>  (Just [1,2,3],Nothing)
08:18:31 <ivant> @pl \xs -> guard $ not $ null xs >> return $ head xs
08:18:31 <lambdabot> guard . not . liftM2 (>> return) null head
08:18:41 <sorear> lambdabot: 08:12 < Igloo> hi
08:19:04 <wli> @pl \xs -> guard (not $ null xs) >> return (head xs)
08:19:05 <lambdabot> ap ((>>) . guard . not . null) (return . head)
08:19:06 <sorear> Lemmih: he ponged
08:19:18 <wli> $ has precedence
08:19:35 <EvilTerran> > (listToMaybe [1..], listToMaybe [])
08:19:37 <lambdabot>  (Just 1,Nothing)
08:19:55 <ivant> EvilTerran, cool!
08:20:01 <wli> > join $ liftM listToMaybe $ Just [1..3]
08:20:02 <lambdabot>  Just 1
08:20:04 <EvilTerran> @index listToMaybe
08:20:05 <lambdabot> Data.Maybe
08:20:08 <wli> > join $ liftM listToMaybe $ Just []
08:20:09 <lambdabot>  Nothing
08:20:13 <Altair^> eh... I tried to calculate 1000**1000 with ghci, which of course did not work, because ** takes a floating num and therefore goes infinity, however, I coded the following function: let exp x 1 = x; exp x y = x * (exp x y-1), which does not work either, why?
08:20:19 <wli> ivant: Try that instead.
08:20:27 <ivant> yes, thanks!
08:20:28 <EvilTerran> > 1000^1000
08:20:30 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
08:20:58 <Lemmih> sorear: Indeed.
08:21:18 <EvilTerran> Altair^, function application binds tighter than any infix operator, so your second equation there is exp x y = x * ((exp x y) -1)
08:21:25 <Heffalump> Altair^: "and therefore goes infinity"?
08:21:39 <SamB> wli: see http://repetae.net/john/repos/jhc/Support/CFF.hs
08:21:44 <wli> Altair: Try 1000^1000
08:21:48 <SamB> compare with PNG spec
08:21:58 <Altair^> Heffalump: says "Infinity" I meant
08:21:59 <Heffalump> oh, overflows, right
08:22:18 <pgavin> dcoutts, ping
08:22:22 <hsuh> i met haskell another day and found it beautiful, while ocaml syntax just seems to get in my way... so my new plan is to learn haskell and then, if i ever need more speed, code in ocaml....what do you think about it
08:22:38 <EvilTerran> > fromInteger (1000^1000) :: Double
08:22:39 <lambdabot>  Infinity
08:22:43 <Heffalump> if you need more speed just improve GHC ;-)
08:23:07 * hsuh did not take the compiler course :)
08:23:12 <ddarius> if you need more speed write better code, GHC is not slow
08:23:23 <bwx> i wonder if there are any programmers who have moved from haskell to ocaml
08:23:30 <wli> SamB: I know all about abusing file formats in this manner. I just suspect there'd be better ones; one can literally do similar within ELF as it stands.
08:23:33 <wli> bwx: moi
08:23:45 <bwx> wli: why?
08:23:59 <hsuh> well, nice to hear that from you
08:24:13 <SamB> wli: but these object files don't contain machine code
08:24:14 <hsuh> i just got a little (bad) impression from this post :http://lambdaman.blogspot.com/2006/01/how-much-speed-are-you-willing-to-give.html
08:24:16 <wli> bwx: Overloading, laziness, purity, etc.
08:24:17 <lambdabot> Title: One for the Morning Glory: How much speed are you willing to give up for pretty  ..., http://tinyurl.com/32bd8h
08:24:21 <SamB> wli: they contain IR code
08:24:27 <wli> SamB: ELF need not contain machine code either.
08:24:28 <Altair^> EvilTerran: I fixed it like you said, but it still goes *** Exception: stack overflow
08:24:30 <SamB> namely E code
08:24:31 <ddarius> wli: He asked the other way.
08:24:33 <bwx> wli: those are all things that haskell has and ocaml doesn't
08:24:35 <SamB> anyway ELF is more complicated
08:24:54 <wli> bwx: woops, I moved from ocaml to Haskell, sorry.
08:25:01 <jbalint> (in gtk2hs/cairo) is there a reason why surface size can only be obtained in a render action?
08:25:09 <SamB> there's little reason to bother with ELF when it doesn't buy you a thing
08:25:13 <EvilTerran> Altair^, yes, that's not surprising, given that you're recursing in a way that doesn't unroll, 1000 deep.
08:25:20 <wli> SamB: The things built into the file format help with dynamic linking.
08:25:36 <SamB> wli: E code isn't supposed to be dynamically linked
08:25:47 <Altair^> EvilTerran: it fails with exp 2 3, too
08:25:48 <SamB> it's supposed to be optimized
08:26:00 <Altair^> so it is broken otherwise too
08:26:02 <wli> SamB: They help with static linking as well.
08:26:15 <SamB> wli: it isn't supposed to be linked, it's supposed to be inlined
08:26:22 <EvilTerran> > let exp x 1 = x; exp x y = x * exp x (y-1) in exp 2 3
08:26:23 <lambdabot>  8
08:26:31 <ddarius> bwx: http://haskell.org/haskellwiki/Wc#Data.ByteString
08:26:32 <lambdabot> Title: Wc - HaskellWiki
08:27:17 <EvilTerran> Altair^, the line i had above wasn't a correction, it was just showing how the compiler sees your code. the line i just had there _is_, however, a correction.
08:27:37 <SamB> wli: and it works better if JHC doesn't have to read everything into ASTs, regardless of whether or not it gets used
08:28:50 <ddarius> sorry, s/bwx/hsuh
08:29:00 <SamB> unfortunately JohnMeacham doesn't seem to have pushed any code for this besides the CFF implementation
08:29:53 <SamB> wli: I'll admit that this PNG-based format doesn't seem exactly ideal ;-)
08:30:07 <ddarius> hsuh: The main issue that code had was using Haskell's String type which is a list of characters and is extremely poor for this kind of thing.
08:30:22 <SamB> but it seems better to start with simple clunky solutions than complicated ones, when tools won't help you
08:30:28 <wli> SamB: Doesn't matter if you inline or insert the address. It just has ready-made tables of where things are.
08:30:43 <ddarius> Nowadays ByteStrings are used and as demonstrated in the page that I referenced.  The naive bytestring code is as fast as C.
08:30:57 * EvilTerran thinks... would it maybe be worthwhile having some kind of class MonadCast m n where mcast :: m a -> n a?
08:31:38 <ddarius> EvilTerran: Someone suggested and implemented something similar, but I believe with n fixed to IO.
08:32:02 <EvilTerran> then instance MonadCast [] Maybe where mcast = listToMaybe; instance MonadCast Maybe [] where mcast = maybeToList; etcetc
08:32:35 <LoganCapaldo> I wouldn't name it MonadCast/mcast then
08:32:38 <EvilTerran> (noting that (mcast :: Maybe a -> a) . (mcast :: [a] -> Maybe a) != id
08:32:58 <LoganCapaldo> I'd call it MondConv/mconv or something
08:33:13 <Cale> NatTrans
08:33:33 <wli> SamB: Seriously. ELF doesn't care what you stuff into it. You could literally use it to do something like tar(1).
08:33:35 <EvilTerran> yeah, "convert"'s a better term for it than "cast". "rebox", maybe, seeing as i'm not sure if it'd make sense for anything other than monad-as-containers.
08:33:38 <SamB> wli: so are there any decent, general ELF libraries for Haskell?
08:33:52 <wli> SamB: Not that I'm aware of.
08:33:57 <Cale> It's the NatTrans class that was in Gofer.
08:34:23 <wli> SamB: I'm not really aware of any PNG encoding libraries for Haskell that don't operate on the assumption you're working with an image, either.
08:34:26 <EvilTerran> @go NatTrans Gofer
08:34:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/icfp06/tests/QuickCheckUtils.hs
08:34:34 <SamB> you may notice the brevity of this CFF implementation?
08:34:56 <hpaste>  fxn pasted "pythagorean triples up to n" at http://hpaste.org/2430
08:35:05 <SamB> in case I forgot...
08:35:10 <SamB> http://repetae.net/john/repos/jhc/Support/CFF.hs
08:35:27 <wli> SamB: By the time you flesh it out with the facilities to find a function you want inlined and so on, it won't be so brief.
08:35:38 <fxn> that's another exercise, is there a way to skip (y, x) after we've found (x, y) ?
08:35:57 <SamB> wli: at least that layers nicely
08:35:59 <fxn> (the exercise do not ask to remove those)
08:36:09 <Cale> hmm, dons had a copy of the old Prelude...
08:36:49 <SamB> with ELF it's a challange just to come up with a representation you're happy with...
08:37:09 <wli> Not sure what you mean.
08:37:46 <SamB> who wants to write a whole dang ELF library just for one program?
08:38:15 <EvilTerran> > [ (x,y,z) | z <- [1..], y <- [1..z], x <- [1..y], x*x + y*y == z*z ]
08:38:17 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,...
08:38:52 <SamB> especially when you get little or no benefit from ELF tool support?
08:38:53 <fxn> EvilTerran: great
08:39:18 <SamB> anyway, you want to make it reusable, right?
08:39:32 <SamB> so how exactly do you make a reusable ELF library with Haskell?
08:39:40 <EvilTerran> fxn, haskell is great for stuff like that :D
08:39:51 <Cale> http://www.cse.unsw.edu.au/~dons/cc.prelude -- 404
08:39:55 <Cale> dons!
08:39:56 <Cale> hehe
08:40:12 <|Jedai|> fxn: And then you do takeWhile ((< n) . fst) is you really want them up to n
08:40:12 <Cale> hmm, maybe in the archive
08:40:26 <Cale> http://www.filewatcher.com/p/gofer230a.tar.gz.758151/cc.prelude.html
08:40:27 <Cale> aha
08:40:29 <lambdabot> Title: gofer230a.tar.gz/cc.prelude - Package Browser, http://tinyurl.com/3c85py
08:40:30 <Cale> there's a copy
08:40:40 <Cale> class (Functor f, Functor g) => NatTransf f g where
08:40:40 <Cale>     eta :: f a -> g a
08:40:50 <fxn> pyths n = [(x, y, z) | x <- [1..n], y <- [x..n], z <- [(x^2+y^2)..n], x^2 + y^2 == z^2]
08:40:51 <Cale> Look at all the nice stuff in there too
08:40:59 <Cale> class (Functor left, Functor right) => Adjoint left right where ...
08:41:00 <fxn> that one seems buggy but I don't know why
08:41:20 <wli> That is sexy.
08:41:21 <EvilTerran> > let f@(_:g)=1:1:zipWith(+)f g in f
08:41:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:41:37 <Cale> and somehow it all got pared down to what we have today
08:41:42 * EvilTerran is golfing the classic fibs definition
08:41:42 <SamB> wli: especially when there are both the linking and execution views of ELF to contend with...
08:42:10 <wli> SamB: And if you don't want to deal with linking why bother?
08:42:13 <EvilTerran> > let n = 40 in [(x, y, z) | x <- [1..n], y <- [x..n], z <- [(x^2+y^2)..n], x^2 + y^2 == z^2]
08:42:15 <lambdabot>  []
08:42:15 <|Jedai|> fxn: it should be : pyths n = [(x, y, z) | x <- [1..n], y <- [(x+1)..n], z <- [(y+1)..n], x^2 + y^2 == z^2]
08:42:18 <Cale> and foldl' and scanl' were both in the prelude.
08:42:38 <leo2007> hi folks
08:42:41 <fxn> ah, the list for z is nonsense
08:42:43 <Cale> leo2007: hello
08:42:44 <SamB> wli: well maybe JHC doesn't want that
08:42:45 <EvilTerran> fxn, if z starts at x^2+y^2, z^2 is always gonna be > x^2+y^2
08:42:53 <|Jedai|> fxn: Oops : pyths n = [(x, y, z) | x <- [1..n], y <- [x..n], z <- [y..n], x^2 + y^2 == z^2]
08:43:09 <SamB> wli: but it's not too good of a library if it doesn't have that
08:43:10 <wli> Cale: This beats the living daylights out of the current Prelude even with the namespace subdivision.
08:43:25 <Cale> wli: I know. It's really really sad.
08:43:52 <wli> Cale: What on earth happened?
08:43:53 <fxn> |Jedai|: yeah
08:43:55 <Cale> There were a bunch of people on the standards committees who just hated polymorphism a whole lot.
08:43:57 <leo2007> is possible to add another system-wide package.conf? My default system-wide package.conf is in /usr/lib/ghc-6.6.1 and I'd like it to include another one in /usr/local/haskell/
08:44:19 <|Jedai|> fxn: Though of course, you might want to optimize and in reality, except 0, you can't have n^2 + n^2 = n^2, so you could change those bounds a little bit
08:44:42 <fxn> |Jedai|: yep
08:44:59 <bwx> Cale: who?
08:45:08 <leo2007> any help?
08:45:09 <fxn> I needed to refresh I can use "x" in the list for "y"
08:45:28 <Cale> bwx: I can't remember who it was exactly. I remember getting that impression from reading the mailing list archives.
08:45:47 <Cale> leo2007: I'm afraid I have no idea...
08:46:22 <wli> I want monad comprehensions and this kind of Prelude back.
08:46:26 <Cale> Also note takeUntil which has been removed.
08:46:26 <EvilTerran> fxn, in a list comprehension, you can use anything that appears to the left of the current doodad.
08:47:06 <fxn> EvilTerran: is "doodad" jargon?
08:47:09 <EvilTerran> up to the |, that is. the stuff to the left of the | is spiritually at the RHS of the comprehension. ;]
08:47:09 <bwx> Cale: were they the same people who put fail in Monad?
08:47:26 <Cale> bwx: Possibly -- it happened around the same time.
08:47:37 <EvilTerran> fxn, no, not really. i think the term i wanted was "generator, guard, or let{} binding"
08:47:41 <wli> Cale: Most importantly, are they gone now?
08:47:44 <Cale> bwx: Monad comprehensions were removed and that started an avalanche of mistakes.
08:48:08 <wli> Cale: Can they be undone?
08:48:22 <Cale> wli: Well, sure, if we don't mind breaking lots of code :)
08:48:41 <EvilTerran> > [ y | x <- [1..10], let y = x*x, odd y ] -- a comprehension with a generator, a let binding, and a guard, in that order
08:48:43 <lambdabot>  [1,9,25,49,81]
08:48:46 <Cale> I really think we need to add support for alternate base libraries to GHC.
08:49:01 <Cale> Let's fork fptools :)
08:49:04 <sorear> I wish haskell' would make up its mind on whether or not it's going to be compatible
08:49:15 <fxn> EvilTerran: excellent
08:49:20 <ndm> sorear: and make up its mind whether its going to merely be, or not
08:49:22 <Igloo> sorear: compatible in what sense?
08:49:23 <SamB> remember to hack on http://hackage.haskell.org/trac/ghc/wiki/BaseSplit
08:49:25 <EvilTerran> :D
08:49:25 <lambdabot> Title: BaseSplit - GHC - Trac
08:49:40 <ndm> what we need is modular base libraries, and several compilers
08:49:47 <sorear> Igloo: Any haskell98 program is valid haskell'
08:49:52 <ndm> once we've got that, we can start again with evolving and changing
08:49:58 <Igloo> sorear: It won't be
08:50:04 <wli> I think it'll take more than base libraries to get monad comprehensions back.
08:50:04 <Cale> SamB: Is anyone knowledgeable working on that?
08:50:08 <LoganCapaldo> > [ y | x <- [1..10], y <- x * x, odd y] -- does this work?
08:50:09 <lambdabot>   add an instance declaration for (Num [t])
08:50:09 <lambdabot>     In a list comprehension: y <-...
08:50:12 <SamB> Cale: not yet :-(
08:50:25 <Cale> wli: Sure, but monad comprehensions will require breaking changes to base
08:50:27 <int-e> LoganCapaldo: ITYM  let y = x*x
08:50:27 <ndm> personally, i like list comps
08:50:28 <SamB> also feel free to comment on the ticket
08:50:32 <Cale> (at least, to be done right)
08:50:37 <SamB> some confusion as to the goal has been expressed
08:50:38 <LoganCapaldo> int-e, I know what I mean :)
08:50:56 <LoganCapaldo> hence the comment
08:51:00 <int-e> LoganCapaldo: whether it works or not depends on your num instances, obviously
08:51:02 <Cale> and some of those should be done anyway, like the elimination of fail and restoration of the do-notation translation to its former glory.
08:51:22 <SamB> hmm. I think I've got an idea.
08:51:22 <Cale> (though the latter is also in the compiler)
08:51:30 <SamB> I'm going to say that what we want to do is split base *in*
08:51:34 <LoganCapaldo> @type odd
08:51:36 <lambdabot> forall a. (Integral a) => a -> Bool
08:51:44 <Cale> SamB: hm?
08:51:47 <int-e> ok, Integral, too, then
08:51:52 <SamB> we want to move the core of it in further
08:51:54 <Mat^> Stack space overflow: current size 8388608 bytes.
08:52:06 <Mat^> is it possible? or I have infinite loop somewhere?
08:52:09 <Igloo> SamB: That's no different to moving the rest of it out
08:52:09 <SamB> the parts you need to get the compilers to work at all
08:52:28 <Mat^> (recursion shouldn't have more depth than ~15 let's say)
08:52:29 <SamB> it's a matter of names
08:52:29 <wli> Cale: What's this about do notation?
08:52:33 <Cale> Mat^: look for tail recursion -- it's commonly the cause of that
08:52:47 <Cale> wli: The do-notation translation in 1.4 was better.
08:52:48 <SamB> well, and of darcs repositories
08:52:55 <LoganCapaldo> the irony
08:53:11 <SamB> anyway, was there any request to move the rest of it out?
08:53:15 <Cale> In particular, if you tried to match against a pattern which could possibly fail, then you'd get a MonadZero constraint.
08:53:19 * Igloo isn't particularly interested in names; they can be cahnged easily. It's untangling the code that is the hard apart
08:53:20 <LoganCapaldo> tail recursion, prevention or cause of stack overflows
08:53:27 <Cale> and there was none of this fail nonsense
08:53:30 <Mat^> Cale: yes, it is ;>
08:53:33 <Igloo> We have been working on moving the rest of it out for months...
08:53:41 <bwx> anyone know of an example of a State monad combined with an Error monad?
08:53:43 <Mat^> I set 1GB stack and now I'm sure there is infinite recursion :P
08:53:51 <Cale> Mat^: okay
08:53:58 <SamB> Igloo: well. yeah.
08:53:59 <Igloo> and also looked at working on the other end, but that proved harder
08:54:07 <SamB> but sometimes it might be easier to start at one end than the other end
08:54:09 * Igloo didn't really get the point of your wiki page or ticket
08:54:09 <LoganCapaldo> IO is a State monad w/ an Error monad aint it? :)
08:54:20 <Igloo> Yes, we tried that too
08:54:23 <EvilTerran> @paste , Mat^?
08:54:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:54:26 <SamB> Igloo: perhaps the wiki page was outdated
08:56:04 <SamB> so what are you doing about wired-in things?
08:56:50 <Igloo> How do you mean? Syntax is gradually becoming more rebindable
08:57:37 <Igloo> But in the absence of extensions the language requires that certain syntax has a certain meaning
08:57:46 <SamB> well... say monads.
08:58:19 <Igloo> If you have a need for rebindable monad syntax in particular then file a ticket for (just) that
08:58:43 <SamB> can I use a package that provides an alternative definition of return, >>=, >>, and fail without -fno-implicit-prelude?
08:58:46 <Igloo> Ideally with the motivation behind it
08:59:47 <Igloo> No, and I don't think you should be able to
08:59:58 <SamB> well that's where we differ
09:00:02 <Cale> Igloo: We want to replace the monad class.
09:00:27 <SamB> how are we supposed to experiment with the future without it?
09:00:34 <Igloo> Then you need rebindable monad syntax and to use -fno-implicit-prelude
09:00:41 <Igloo> By using the -fno-implicit-prelude flag
09:00:42 <SamB> that's disgusting
09:00:50 <EvilTerran> being able to replace the entire heirarchy'd be nice. make class Functor m => Monad m or instance Monad m => Functor m or something.
09:01:16 <Cale> Really what we need to be able to do is to fork all of base, and have a switch to choose the new one.
09:01:21 <wli> Brilliant, mzero is FITA. MonadPlus and MonadZero are fused/intermixed/confused somehow.
09:01:23 <SamB> yes
09:01:36 <SamB> of course we'd have to use all different other packages too
09:01:45 <EvilTerran> proper maths heirarchy...
09:02:08 <Cale> SamB: right
09:02:10 <SamB> wli: we know
09:02:21 <monochrom> Sorry, I want to pick on the word "maths". It should be "numbers".
09:02:31 <SamB> monochrom: I want both
09:02:40 <Igloo> If you call your package base with a different versino number then it would work, assuming -package base-n does the right thing
09:02:44 <wli> What happened to the adjoint bit?
09:02:46 <EvilTerran> monochrom, let's be more general. "abstract algebras".
09:02:49 <SamB> Igloo: that's evil
09:02:52 <SamB> see
09:03:03 <EvilTerran> :D
09:03:07 <Cale> Igloo: that's good to know, except that we might get in the way of the other branch :)
09:03:14 <SamB> it's not the same branch
09:03:20 <SamB> so...
09:03:23 <fasta> SamB: Igloo is just before a release. Don't ask too much ;)
09:03:31 <Cale> hehe
09:03:31 <wli> Call it base-666
09:03:35 <Igloo> Oh, sure, you couldn't publish it under the name base
09:03:38 <SamB> hmm.
09:03:39 <wli> That ought to buy some time.
09:03:46 <sorear> base-777 maybe?
09:03:54 <SamB> yeah, 777 is better
09:04:03 <SamB> we can change to 666 if it gets too nasty
09:04:07 <wli> Pick any sufficiently large number. It need not even exceed 1000.
09:04:43 <Igloo> But -fno-implicit-prelude is how you tell GHC you don't want to use the Haskell 98 stuff...
09:05:12 <SamB> that's very kludgy
09:05:17 <wli> There's plenty that's hardwired. I suppose the specifics can be haggled over once you're out of release mode.
09:05:18 <Igloo> No it isn't
09:05:26 <sorear> this kind of revolution can't be done bottom up
09:05:27 <SamB> base-777 is kludgy too
09:05:41 <Igloo> How is it different to "a switch"?
09:05:49 <wli> SamB: Who cares? The big issues are hardwired things.
09:05:53 <SamB> but it seems like a much nicer kludge
09:05:56 <EvilTerran> Igloo, it's still a little limited, i think. at the very least you've got to work with the existing desugaring, even if that means inappropriately-named functions
09:06:14 <wli> SamB: Like what it takes to get Monad comprehensions back and do notation desugaring.
09:06:18 <Igloo> EvilTerran: And what would you propose instead?
09:06:18 <SamB> wli: at least if we went that route we'd have some code to bargain with
09:06:29 * xerox tries time nice make -j 10
09:06:37 <SamB> having code to bargain with is always nice
09:06:45 <wli> SamB: Which route?
09:06:51 <ivant> xerox, how many cpus/cores?
09:06:53 <SamB> the base-777 route
09:07:03 <xerox> ivant: two cores, -j 3 took 14 mins yesterday.
09:07:13 <EvilTerran> Igloo, i propose fixing -fno-implicit-prelude, or devising something stronger. maybe a preprocessing sweep over the parse tree before de-sugaring
09:07:39 <Igloo> EvilTerran: Fixing -fno-implicit-prelude how?
09:07:47 <SamB> anyway I'm going to go try forking base
09:07:51 <ivant> xerox, I've seen rather strange suggestion to do -j 2*NumberOfCores several times
09:07:55 <EvilTerran> there are things that don't get separated from the prelude properly with it, iirc.
09:07:59 <sorear> Igloo: How about making -fimplicit-prelude use Prelude, but not necessarily base:Prelude, rather using the normal module-finding scheme?
09:07:59 <wli> Actually it shouldn't take very long to hammer out a neo-1.4 Prelude. Why not hammer it out and actually start pointing out where hardwired things need fixing.
09:08:13 <ivant> xerox, 14 mins, hmm, linux kernel?
09:08:14 <xerox> ivant: somebody suggested to go high with the number, at least 4, just a test :)
09:08:20 <sorear> Igloo: then if you have mybase:Prelude.>>=, it will work with do-notation
09:08:21 <xerox> ivant: GHC.
09:08:22 <fasta> ivant: ghc probably
09:08:22 <Igloo> SamB: Just to be clear, you definitely should go putting things like base-777 in things like hackage
09:08:27 <Igloo> Gah
09:08:29 <EvilTerran> Igloo, for one, i don't think you can do monad comprehensions with -fno-implicit-prelude
09:08:32 <SamB> Igloo: I know
09:08:33 <Igloo> SamB: Just to be clear, you definitely shouldn't go putting things like base-777 in things like hackage
09:09:04 <xerox> ivant: the cores are spinning fast :)
09:09:17 <SamB> hackage is no good for hacking anyway
09:09:23 * EvilTerran thinks that his preprocessing sweep would probably have to come in before the typechecker, in case you wanted to do funny things involving alternate class heirarchies.
09:09:36 <Igloo> EvilTerran: Sure, more syntax needs to be rebindable, but I don't see how that helps "inappropriately-named functions"
09:09:43 <sorear> Igloo: did you see my proposal in there?
09:09:52 <EvilTerran> Igloo, it wouldn't be a complete fix, but it'd be good enough, i think.
09:10:27 <EvilTerran> maybe make some aliases for prelude functions that could be used in desugaring to have more general names.
09:10:28 <Igloo> sorear: Yeah; that would be possible, I think
09:11:27 <ddarius> {-# REWRITE fail = const mzero #-}
09:11:42 <EvilTerran> ... meh. if I want to jump in pre-typing, i can't just wrap the module in $(preprocess [d| ... |])
09:11:48 <SamB> EvilTerran: you obviously need to hack GHC to get monad comprehensions, yes
09:12:09 <Saizan_> ddarius: you could just put fail in MonadZero
09:12:21 * sorear wants the entire syntax to be defined using redefinable macros of some sort
09:12:23 <SamB> EvilTerran: how about we just have the typechecker check types based on the the types of the functions used in desugaring?
09:12:27 <ddarius> Saizan_: Not with fail already in Monad.
09:12:28 <EvilTerran> is it possible to hook into the complilation process and tweak the parse tree pre-typechecking?
09:12:30 <xerox> ivant: ah too bad ghc didn't compile. an error at 5mins.
09:12:55 <SamB> sorear: #perl6 has a place for you
09:13:05 <ivant> xerox, your cpu got so confused because of very hard -j 10 work :-)
09:13:18 <xerox> ivant: no, Cabal is broken again :)
09:13:33 <EvilTerran> samb, yes, that'd work most of the time, but you might want to do something that's wholly incompatible with the current desugaring.
09:13:36 <sorear> Igloo: hmm.  it would be hard to actually *write* mybase, because you can't use standard Prelude functions - only GHC.Base, which is ugly in a potentially portable library
09:13:47 <SamB> EvilTerran: like what?
09:13:48 <EvilTerran> hijacking do{} or something horrid like that.
09:13:52 <sorear> Igloo: we'd need some way to force a specific package on imports
09:13:52 <SamB> oh
09:13:53 <SamB> well
09:14:00 <SamB> that's not even syntax trees is it?
09:14:05 <EvilTerran> it could be.
09:14:06 <xerox> ivant: or maybe I broke it :P
09:14:13 <Igloo> sorear: You can't use GHC.Base either, unless you're looking forward to a time when base is more split up?
09:14:27 <Igloo> Oh, n/m, ISWYM
09:14:28 <cpoucet> lo
09:14:35 <SamB> EvilTerran: you could just write a preprocessor that GHC can call...
09:14:48 <SamB> at the expense of confusing type errors
09:14:58 <EvilTerran> SamB, can you use GHC to yoink out a parse tree in the first place, though?
09:15:01 <Igloo> sorear: Most of the Prelude functions you can probably get from elsewhere in the hierarchy
09:15:04 <sorear> EvilTerran: but what if someone wants to add μdo ?
09:15:06 <SamB> EvilTerran: no
09:15:16 <SamB> they run earlier than that
09:15:43 <EvilTerran> "hey GHC, give me a parse tree. don't bother to typecheck." <time passes> "hey, GHC, have this (slightly different parse tree). compile plzkthx"
09:15:57 <EvilTerran> s/parse tree)/) parse tree/
09:18:22 <SamB> they run on text
09:18:28 <SamB> so you have ultimate power
09:18:42 <fasta> Running on text also gives ultimate slowness.
09:18:46 <SamB> (but poor control)
09:19:14 <fasta> All these cool transformations are cool, but start to become impractical relatively fast.
09:19:31 <fasta> Unless you have a compile farm.
09:20:40 <EvilTerran> SamB, i'm not familiar with getting at parse trees and suchlike from within haskell... can you get a Language.Haskell.Syntax.Something without it going through a typechecker?
09:21:25 <sorear> EvilTerran: lambdabot uses L.H.S, and look:
09:21:26 <sorear> > let (x+1) = 2 in x
09:21:26 <lambdabot>  Parse error in pattern
09:21:32 <EvilTerran> =/
09:21:34 <sorear> perfectly valid haskell.
09:21:50 <EvilTerran> TH seems to do fine, but that uses GHC directly, right?
09:21:55 <sorear> yes
09:22:06 <EvilTerran> (and indeed at compile-time)
09:22:44 <EvilTerran> i basically want to be able to run some TH *before* the typechecker runs on the file being transformed, i guess
09:23:54 <EvilTerran> TH's parse-tree structures don't enforce typing, AFAICT, so that should be possible
09:24:12 <wli> I have a cunning plan.
09:24:20 <wli> (1) write an alternative prelude
09:24:31 <wli> (2) demonstrate a need for some fixup or other
09:24:36 <wli> (3) ...
09:24:39 <wli> (4) profit!
09:25:26 <Igloo> There have been patches to do that, but they've never managed to get to the point of being applied
09:25:54 <ivant> wli, there is NumericPrelude which is kind of alternative :-)
09:29:02 <sorear> @users
09:29:02 <lambdabot> Maximum users seen in #haskell: 385, currently: 371 (96.4%), active: 12 (3.2%)
09:29:29 <sorear> sjanssen: 2007.08.24.20.15.23 < bens> @seen sjannsen
09:32:31 <sjanssen> @seen bens
09:32:31 <lambdabot> bens is in #xmonad and #haskell. I last heard bens speak 13h 14m 12s ago.
09:38:39 <ricky_clarkson> Hmph - no ghc in cygwin..
09:38:47 <EvilTerran> windows ghc?
09:39:45 <mdmkolbe> ricky_clarkson: porting ghc to cygwin has been on the wish list for some time but I don't think anyone is working on it at the moment.  (You could though.)
09:40:58 <wli> There had to have been some kind of outcry.
09:41:20 <EvilTerran> is there a haskell->liskell transformer?
09:45:18 <SamB> sorear: obviously L.H.S is in the "no n+k" camp
09:45:42 <nomeata> OT: Can someone recommend a goot latex forum? #latex has hardly ever been helpful so far.
09:45:51 <Igloo> SamB: L.H.S?
09:46:01 <SamB> Igloo: Language.Haskell.Syntax
09:46:06 <Igloo> Ah
09:46:13 * sorear wishes haskell had short module names
09:46:41 <ddarius> Hmm, yet another significant project in OCaml that doesn't use the O.
09:46:58 <Heffalump> I've never talked to anyone that does
09:47:06 <ddarius> sorear: Why?
09:47:11 <Heffalump> at least, not that I can remember
09:47:57 <sorear> ddarius: because typing import Control.Monad.Reader gets tiring after the dozenth module
09:48:11 <SamB> copy and paste
09:48:14 <SamB> or something
09:48:26 <bwx> or code completion
09:49:04 <SamB> I admit I'd love if you could say import Control.Monad.{Reader,Writer}
09:49:16 <SamB> or whatever
09:49:21 <ddarius> SamB: That's -really- unnecessary.
09:49:34 <SamB> yeah, yeah
09:49:45 <SamB> code completion is probably the best idea
09:50:28 <wli> What's code completion?
09:50:45 <sorear> an extremely dumb kludge for dumber languages
09:50:57 <sorear> popularized by IDEs for Java and COBOL
09:51:23 <sorear> fills in pages of boilerplate so that the language designers don't have to do extra work
09:52:22 <ivant> what happens if we try to peek data from 0 ptr?
09:52:22 * Igloo wonders what divergences there are from H98 in the libraries already
09:52:27 <sorear> btw, anyone who remembers the discussion of Smerdyakov's broken slides - I just managed to ask him, his reply is "I don't care, install OpenOffice"
09:52:53 <sorear> ivant: you read whatever is at  address 0
09:52:58 <sorear> ivant: nothing magic
09:52:59 <Igloo> ivant: whatever you would get from dereferencing 0 in C
09:53:03 <SamB> sorear: I thought it just filled in parts of symbol names
09:53:04 <hpaste>  lowik pasted "prolog bin" at http://hpaste.org/2432
09:53:14 <ivant> sorear, I'd expect core dump in C :-)
09:53:41 <Igloo> Then that's what you'd get in Haskell
09:53:55 <ivant> can I catch it then? :-)
09:53:55 <ddarius> Igloo stole the exact words out of my mouth.
09:53:56 <SamB> so that you could type like Con<TAB>Mon<TAB>Re<TAB>
09:53:58 <wli> ivant: You mean UNIX userspace?
09:54:00 <SamB> or something
09:54:10 <ivant> wli, yep
09:54:23 <wli> The bare metal doesn't really care what you map to address 0.
09:54:26 <SamB> wli: why specify UNIX?
09:54:54 <SamB> well I guess coredumps themselves are atypical in DOS
09:54:59 <wli> SamB: AIUI various non-UNIX kernels do something different with translations in/around address 0.
09:55:03 <SamB> but I got signal 11 all the same
09:56:34 <sorear> wli: doesn't even need to be non-UNIX
09:56:34 <ddarius> Why are many graphics APIs harder to use than using the hardware directly would be?
09:56:39 <wli> Linux used to have ABI's allowing the zero page to be mapped to something valid.
09:56:47 <wli> sorear: True enough.
09:56:48 <SamB> used to?
09:56:53 <SamB> what do you mean, used to?
09:56:57 <sorear> wli: on BSD, valid addresses range from 0 to brk()
09:57:00 <wli> SamB: Removed for security reasons recently AIUI.
09:57:04 <SamB> WHAT
09:57:08 <SamB> I WANT IT BACK!
09:57:10 <sorear> you should see the save code in monop :)
09:57:16 <SamB> my poor DOS programs :-(
09:57:50 <wli> SamB: Well, it was a roothole in Linux so it needed closing.
09:57:51 <sorear> does linux still support VM86 mode, or do you have to use hardware emulators?
09:58:09 <SamB> wli: how could that have been the hole?
09:58:26 <wli> sorear: It's still there but it's barely maintained if at all (and widely regarded as a gaping roothole).
09:59:23 <wli> SamB: Linux relies somewhat on addresses below 4KB and above ~0UL-4KB to fault.
09:59:30 <wli> SamB: In-kernel.
09:59:39 <SamB> wli: that was a poor design decision...
10:00:00 <SamB> what's it for?
10:00:02 <wli> SamB: Good luck undoing design decisions (witness similar resistance in ghc).
10:00:14 <sorear> so, if we had strong types, we could map files anywhere?
10:00:18 <wli> SamB: Generating traps at appropriate times.
10:00:26 <SamB> which times?
10:00:43 <sorear> Oops: kernel NULL pointer dereference
10:00:45 <wli> SamB: I didn't pay all that much attention to it.
10:00:59 <wli> sorear: That's one. I am not sure it's the only one.
10:01:29 <SamB> well.
10:01:44 <SamB> hmm.
10:02:03 <wli> SamB: Anyway, userspace piggybacks atop kernelspace or vice-versa so where the kernel insists on receiving a trap on a 0 dereference when userspace maps 0 it's broken.
10:04:02 <bwx> code completion for haskell: http://img207.imageshack.us/img207/2310/testvz5.jpg
10:04:04 * SamB looks at his books
10:04:54 <xerox> bwx: oh. where is that?
10:05:20 * ddarius realizes he has DVD-Rs.
10:06:00 <bwx> xerox: it's a haskell IDE i'm working on
10:06:08 <xerox> Nice :)
10:06:27 * ddarius starts downloading SICP lectures.
10:12:10 <SamB> wli: too bad virtual 8086 mode requires the emulated address space to start from 0 :-(
10:14:53 <monochrom> I love code completion for Haskell.
10:15:21 <wli> SamB: I believe this was noticed when the change went in.
10:16:20 <SamB> wli: so why's it bad to dereference NULL pointers anyway?
10:16:49 <wli> SamB: Mostly it's that it overrides the kernel's assumptions.
10:16:54 <SamB> yeah.
10:17:01 <wli> SamB: I did not pay close attention to it.
10:17:02 <SamB> now you have me wondering about ReactOS
10:17:12 <bwx> xerox: here's a more recent screenshot: http://img521.imageshack.us/img521/4817/testna1.png
10:17:17 <ricky_clarkson> *NULL: the most global variable.
10:17:47 <allbery_b> dereferencing a NULL pointer is almost always a program bug; it's helpful if it causes a core dump/debug break insteqad of returning something which is probably wrong
10:18:26 <SamB> in particular, I'm wondering if you could just mark the first page as absent on entry to the kernel instead of forbidding it's use...
10:18:52 <SamB> of course then you'd need to avoid syscalls involving that region
10:18:58 <SamB> but that's probably not hard
10:19:06 <Saizan_> bwx: i hope it only looks like eclipse ;)
10:19:26 <SamB> especially not if you have the first MB mirrored in the second MB
10:19:38 <wli> SamB: It wouldn't be difficult. Efficiency OTOH...
10:19:57 <SamB> yeah
10:20:02 <SamB> that's what I'm wondering about
10:20:26 <bwx> Saizan_: i've never used eclipse. the look is inspired from microsoft visual studio
10:23:08 <monochrom> I like eclipse.
10:23:30 <SamB> wli: then there might be the option of just leaving the bit as "absent" most of the time and only set it to "present" when needed
10:23:43 <yaxu> anyone know if it's possible to pull lines out of the history of System.Console.Readline?
10:24:03 <yaxu> i see addHistory but no getHistory :/
10:24:32 <wli> SamB: It's all possible. Whether anyone considers it worth the effort is an open question.
10:25:01 <SamB> yeah
10:28:23 <ivant> @index alloca
10:28:23 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
10:30:08 <SamB> hmm wait.
10:30:18 * SamB wonders
10:31:32 * Stevie wonders
10:31:57 <SamB> oh rats. it really does use the linear address space for this :-(
10:32:07 <sorear> why don't we just rewrite the kernel in a typed language?
10:32:12 <SamB> heyhey!
10:32:16 <SamB> segments!
10:32:21 <ddarius> sorear: C is typed.
10:32:28 <sorear> SamB: Don't work in VM86 mode.
10:32:45 <sorear> SamB: Or rather, work in the (less useful) 8086 way.
10:32:55 <SamB> hmm wait I guess you can't have a segment start partway in
10:33:15 <sorear> SamB: Sure you can.  growsdown bit
10:33:29 <SamB> oh sweet
10:33:32 <sorear> SamB: stack segments on the 286 went from TOS to FFFF
10:33:44 <SamB> you could have the kernel use one of those
10:33:46 <sorear> you have to either start at 0, or end at FFFF
10:34:01 <SamB> normally
10:34:05 <sorear> or end at FFFFFFFF
10:34:10 <SamB> possibly always
10:34:31 <SamB> so it couldn't possibly get confused and dereference a NULL pointer
10:34:38 <SamB> does that make sense?
10:35:20 <sorear> yes.
10:35:28 <sorear> now try convincing Linus
10:35:30 <SamB> wli: what think you?
10:37:11 <wli> SamB: Segments make things very slow unless they're the trivial 1:1 sorts.
10:37:23 <SamB> wli: they do?
10:37:31 <wli> Yes.
10:39:20 <SamB> is there documentation about this?
10:40:42 <waern>  bwx: is that GtkSourceView?
10:42:39 <bwx> waern: yes
10:42:57 <waern> bwx: ok, cool
10:43:53 <bwx> waern: the main thing GtkSourceView is missing is code folding
10:44:19 <waern> bwx: oh, ok. So it has code completion boxes now?
10:44:53 <bwx> waern: no, that is my own implementation
10:45:01 <waern> bwx: ah ok
10:45:13 <bwx> waern: inspired by the way they do it in monodevelop
10:45:35 <waern> bwx: I'm working on a gtk2hs binding to scintilla
10:45:47 <waern> but I haven't touched it in a couple of months now
10:45:56 <bwx> that would be awesome
10:46:54 <bwx> would that be able to support wysiwyg haddock comment editing?
10:47:01 <waern> it's working but the API needs to be a bit more type safe... here's a screen shot: http://www.dtek.chalmers.se/~davve/haste2-new.png
10:47:21 <Mat^> quick question: what is logical not operator in haskell?:S
10:47:37 <sorear> > not (2 == 3)
10:47:39 <lambdabot>  True
10:47:41 <waern> bwx: hmmm.. possibly.
10:47:46 <waern> that would be cool =)
10:48:10 <Mat^> uch
10:48:13 <Mat^> thanks ;>
10:48:15 <gwern> not?
10:49:20 <bwx> waern: looks good
10:51:33 <gwern> > :t (!)
10:51:34 <lambdabot>   parse error on input `:'
10:51:42 <waern> bwx: the haskell lexer in scintilla is a bit bad though
10:51:54 <mdmkolbe> @hoogle transpose
10:51:54 <lambdabot> List.transpose :: [[a]] -> [[a]]
10:51:54 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
10:52:06 <bwx> waern: it can't be worse then the one in gtksourceview
10:52:13 <waern> bwx: heh :)
10:52:39 <waern> lemmih took the visual haskell lexer and used it with gtkSourceView
10:52:46 <bwx> even vim seems to get long {- block comments -} messed up
10:53:00 <gwern> > :type (!)
10:53:00 <waern> bwx: yeah
10:53:00 <lambdabot>  Parse error
10:53:20 <desegnis> My vim messes indentation after comments
10:54:25 <SamB> wli: what do you mean by "1:1"?
10:58:59 <SamB> do you mean that the base address field in the segment descriptor is 0, or does the segment have to be an expand-up segment with the limit at the max too?
11:02:30 <jedai> @seen dburrows
11:02:30 <lambdabot> I haven't seen dburrows.
11:03:26 <phobes> ‌/join
11:10:29 <luctaesch> hello. I am a noob. i recompiled ghc 6.6.1 and lib arrow failed saying Control/Arrow/Internals.hs:29:0:    Failed to load interface for `Control.Arrow.Operations
11:11:28 <Saizan_> nothing more?
11:11:46 <luctaesch> no
11:12:10 <luctaesch> this is the lib provided with the 6.6.1 compiler.
11:12:18 <luctaesch> most of the other lib installed fined
11:13:01 <luctaesch> any issue having 6.6. on the machine ? ( i need a ghc anyway)
11:13:34 <Saizan_> no, it should work
11:14:00 <luctaesch> i tried a makeclean akeagain nce 6.6.1 was intalled
11:15:25 <Saizan_> does it complain that Control.Arrow.Operations can be found in multiple packages?
11:17:16 <luctaesch> non that i see
11:17:44 <luctaesch> I scanned all path and all are /usr/local when 6.6  was /usr
11:23:36 <Saizan_> @where haddock.ghc
11:23:37 <lambdabot> I know nothing about haddock.ghc.
11:24:16 <bwx> @where quickcheck
11:24:16 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
11:24:27 <Saizan_> is there an haddock that works even if you use TH?
11:25:34 <mdmkolbe> Any good ideas for the name of a function that take the front half or back half of a list?
11:25:53 <gravity> halves?
11:26:10 <koala_man> mdmkolbe: foo and bar
11:26:14 <wli> It's usually better to take even and odd halves.
11:26:35 <monochrom> splitAt (length / 2)
11:27:06 <monochrom> That is my proposal for the name, to be clear.
11:27:11 <mdmkolbe> wli: by even and odd do you mean [0,1,2,3] -> ([0,2], [1,3])?
11:27:38 <wli> mdmkolbe: Sort of but basically.
11:28:19 <mdmkolbe> wli: that doesn't work for what I'm doing.  I need to implement the morton-ordering transform found in JPEG compression.
11:28:37 <wli> Well then you have to do what it says.
11:29:50 <JohnMeacham_> SamB sorear: it is almost fully working. the only thing missing is libraries on top of libraries. I will check in the changes soon.
11:30:18 <mdmkolbe> @pl unzip . map f
11:30:19 <lambdabot> unzip . map f
11:30:19 <SamB> JohnMeacham_: yes, I caught myself before claiming you'd done nothing ;-)
11:30:42 <SamB> JohnMeacham_: wli seems to think you should use ELF, not PNG, for some reason ;-)
11:31:12 <mdmkolbe> SamB: ?!
11:31:18 <wli> Well, ELF has convenient symbol tables for linking, whether statically or dynamically.
11:31:33 <SamB> you have strange ideas about convenience ;-)
11:31:55 <luctaesch> for my libs that does not compile, is suppose i cannot use a lib compiled with 6.6 in 6.6.1 ?
11:31:57 <SamB> JohnMeacham_: but what does he know. he's just a kernel hacker ;-P
11:31:58 <wli> You have to fish out the bodies to inline anyway, so you'll have some equivalent anyway.
11:32:17 <mdmkolbe> SamB: what sort of thing is being encoded?  Isn't PNG for images and ELF for binaries?
11:32:28 <SamB> mdmkolbe: it isn't really PNG exactly
11:32:47 <SamB> but uses the same basic chunk format as PNG, MNG, and JNG
11:32:57 <fasta> Have you ever used Core for something non-trivial?
11:33:06 <fasta> About 90% of the core I see consists of types.
11:33:23 <mdmkolbe> SamB: so it's PNG but with non-standard tags?
11:33:31 <SamB> fasta: that's because it is the essence of your code ;-P
11:33:43 <hsuh> any emacs users ?
11:33:49 <mdmkolbe> hsuh: yes
11:33:51 <conal> hsuh: yep
11:33:51 <hsuh> that code haskell inside emacs of course
11:33:56 <SamB> mdmkolbe: well, more like it's not PNG but uses the same nameless chunked file format
11:34:00 <conal> hsuh: i do
11:34:13 <hsuh> folks, i am trying to setup emacs for writing haskell but i cant understand what the haskell-mode does for me
11:34:13 <SamB> mdmkolbe: with a different magic number though
11:34:24 <fasta> SamB: well, "Core" makes little sense to me, maybe I should read those papers.
11:34:25 <hsuh> for example the "semi-automatic" indentation
11:34:35 <mdmkolbe> hsuh: it makes your life harder
11:34:38 <SamB> fasta: that was mostly a joke
11:34:48 <conal> hsuh: syntax coloring
11:34:48 <hsuh> i cant understand how it makes things easier
11:35:01 <hsuh> i mean, i have to press tab several times to get the right alignment
11:35:02 <SamB> fasta: I believe the real reason is that the types are, um, big
11:35:06 <fasta> SamB: also, it seems to pass a 32 element function all the time.
11:35:25 <fasta> SamB: which seems isomorpic to a class I defined
11:35:33 <hsuh> conal: syntax coloring is fine, but in terms of indenting
11:35:45 <fasta> But I thought that was a dictionary
11:35:53 <fasta> Not a 32 parameter function
11:36:07 <conal> hsuh: i usually get a few choices as well.  most of them make sense to me as alternatives.
11:36:16 <mdmkolbe> hsuh: I've never gotten along with the indentation in haskell-mode.  Since indentation indicates block grouping in haskell there are multiple possible indentations, so haskell-mode cycles though all of them
11:36:37 <hsuh> mdmkolbe: but shouldn't the same indentation be the default ?
11:36:44 <hsuh> unless there was a do.. etc
11:36:46 <conal> hsuh: e.g., continue a def or start a new one
11:36:47 <fasta> When you look at the performance wiki, one might think: hmm, this Core is a good idea.
11:37:15 <Liskni_si> one might expect the innermost indentation to be the first alternative
11:37:20 <fasta> When one looks at the stuff I am looking at...
11:37:21 <Liskni_si> s/might/would/
11:37:27 <conal> hsuh: what's a example of a default you don't like?
11:37:29 <mdmkolbe> hsuh: maybe but haskell-mode tries to be smart.  for example an "if ...\n<tab>" is almost certain to need to be indented one more level
11:37:38 <hsuh> hm..
11:38:01 <monochrom> Indeed, suppose I write "x <- y" on a line, and you are asked to guess my indentation the next line. Without knowing whether I conspire "z <- y" or "+ 2", you can't.
11:38:16 <hsuh> lets see, i am in a buffer trying to understand this
11:38:39 <mdmkolbe> hsuh: I usually leave haskell-mode off.  (Part of that is that I'm constantly using different machines and setting up haskell-mode on each of them isn't worth the effort when I don't get along with it anyway.)
11:38:41 <hsuh> i am copying a
11:38:58 <conal> hsuh: please use hpaste if it's more than 2 lines
11:38:58 <hsuh> source code to see how haskell-mode indents it
11:39:12 <monochrom> Perhaps auto-indentation is a poor idea afterall. Indeed, it is not much easier than auto-coding.
11:39:22 <conal> hsuh: (i mean if you want to show us some code)
11:39:29 <hsuh> conal: i was going to
11:39:40 <hsuh> if i type main = do combine c c
11:39:47 <hsuh> where do you expect the next line start ?
11:39:49 <hsuh> (a let)
11:40:00 <monochrom> The next line is "+ 2"?
11:40:19 <hsuh> monochrom: no, its let b = combine ...
11:40:21 <conal> hsuh: yeah.  i don't like that default either.
11:40:33 <monochrom> Well, if you have already entered the let, sure.
11:40:42 <conal> i'd like to align with "combine", not "c"
11:40:52 <SamB> monochrom: well, it wouldn't be impossible to (a) base it off the relevent indentation from the previous line and (b) provide a mechanism to return to selected previous indentations, would it?
11:41:03 <SamB> or lines
11:41:18 <ricky_clarkson> Is there any particular reason that :t \x -> x gives t -> t, while :t (==) is in terms of a?
11:41:32 <ricky_clarkson> :t id is in terms of a too.
11:41:34 <lambdabot> parse error on input `in'
11:41:57 <monochrom> SamB: isn't that what emacs haskell-mode does already? I.e., the origin of the complaint.
11:42:09 <monochrom> err maybe not.
11:42:10 <SamB> it doesn't friggin *work*
11:42:42 <monochrom> Well other languages don't suffer this problem.
11:43:04 <monochrom> Other languages don't suffer this problem because they mandate lots of { } so it's trivial to indent.
11:43:18 <psykotic> ricky_clarkson, the latter have type signatures that mention the free type variable a explicitly. in the \x -> x case, the type inferencer has to generate a type variable name itself.
11:43:31 <ricky_clarkson> Ah, makes sense.
11:43:31 <SamB> Python hasn't got this problem because identifying the current and previous levels is easy there
11:43:32 <conal> hsuh: how about contacting the haskell-mode maintainer(s) and suggesting this change to the ordering of choices?  if they have a reason for the current ordering, you'll find out.  and if not, maybe they'll change it.
11:43:42 <monochrom> The whole point of layout is you provide the indentation and the computer finds out what you mean, not the other way round.
11:43:48 <SamB> and the standard style is to use a constant number of spaces per level, even
11:44:09 <hsuh> conal: i'm too much of a newbie to start suggesting
11:44:15 <hsuh> conal: i am trying to learn haskell
11:44:21 <andyjgill> Does anyone want to help evaluate some new Haskell benchmark applications for suitability?
11:44:31 <hsuh> conal: and before i do that i'd like to have a easy way to type programs
11:44:34 <SamB> monochrom: it makes about as much sense as completion in an XML editing mode, and is probably a bit harder to actually do...
11:44:41 <mdmkolbe> andyjgill: evaluate how?
11:45:21 <SamB> since, you know, XML is a lot easier to parse
11:45:31 <andyjgill> nofib is based on 10 year old haskell programs, and I want to help build a new set of benchmarks.
11:45:46 <monochrom> Haskell layout is much more complicated than Python layout. You are allowed "x = do y". If that were removed, you get the same ease as Python layout.
11:45:49 <conal> hsuh: ok
11:46:01 <andyjgill> by taking some haskell applications, and packaging them for measurements.
11:46:02 <SamB> monochrom: yeah. that's basically what I mean
11:46:05 <hsuh> maybe i should just turn indenting off
11:46:13 <SamB> Haskell layout is more complicated
11:46:17 <monochrom> Indeed, in emacs haskell-mode, if you write "x = do", and put the y on the next line, it guesses right.
11:46:24 <andyjgill> but I want some help with the evaluations.
11:46:25 <SamB> and conventions much much less established
11:46:58 <SamB> andyjgill: evaluations?
11:47:23 <andyjgill> What applications are suitable? I'm going to set out a call for applications, then measure them.
11:47:31 <SamB> ah.
11:47:36 <mdmkolbe> monochrom: don't forget the hole "do if .. then ... else ..." problem.  I'm fuzzy on the details, but I know haskell-mode isn't able to handle that or something
11:47:38 <andyjgill> Things like Haskell 98'ish-neess,
11:47:44 <andyjgill> build system complexity.
11:48:07 <ricky_clarkson> Would it be possible to provide an implementation of t -> t that didn't return its input value?
11:48:18 <ricky_clarkson> E.g., that read from some cache of values or something.
11:48:28 <SamB> if you want to do benchmarking for things with nontrivial build systems you're in for some pain
11:48:38 <fasta> ricky_clarkson: no
11:48:41 <SamB> well. probably.
11:48:48 <andyjgill> I know.
11:48:51 <fasta> ricky_clarkson: with another type it could
11:48:57 <andyjgill> Thats why I want some help
11:49:00 <SamB> unless you can just build them from cabal or something
11:49:05 <monochrom> ricky_clarkson: unless t is less polymorphic, e.g., member of some type class that supports this.
11:49:13 <fasta> ricky_clarkson: e.g. if it would be enumerable, it would be possib;e
11:49:16 <ricky_clarkson> Ok.
11:49:40 <mdmkolbe> ricky_clarkson: symantically there are only two functions that have type "t -> t".  One is "id" the other is "const undefined".  Implementations might used the input to cache the result and make an output, but they would still be implementing either "id" or "const undefined".
11:50:02 <hsuh> what about haskell simple-indent ?
11:50:02 <ricky_clarkson> :t const undefined
11:50:07 <lambdabot> forall a b. b -> a
11:50:24 <mdmkolbe> :t const undefined :: t -> t
11:50:26 <lambdabot> t -> t :: forall t. t -> t
11:50:46 <mdmkolbe> (t -> t is a sub-type of a -> b)
11:51:04 <ricky_clarkson> Ok.
11:51:04 <fasta> :t undefined:: a-> a
11:51:06 <lambdabot> forall a. a -> a
11:51:32 <ricky_clarkson> Is it possible to construct a type signature for which the only implementation would be x -> y -> x+y ?
11:52:03 <mdmkolbe> ricky_clarkson: I assume you mean "\x y -> x + y"
11:52:10 <ricky_clarkson> Yes, oops.
11:52:18 <mdmkolbe> @pl \x y -> x + y
11:52:18 <lambdabot> (+)
11:52:22 <mdmkolbe> :t (+)
11:52:24 <lambdabot> forall a. (Num a) => a -> a -> a
11:52:36 <mdmkolbe> @djinn (Num a) => a -> a -> a
11:52:42 <mdmkolbe> :t (-)
11:52:43 <lambdabot> forall a. (Num a) => a -> a -> a
11:53:26 <ricky_clarkson> Is it possible, but not within Haskell's type system?  Does it need dependent types?
11:53:36 <mdmkolbe> ricky_clarkson: unless you add dependant types, (+) will have the same type as (-) and \x y -> 0  and (*), etc.
11:53:42 <ricky_clarkson> Ok.
11:53:45 <EvilTerran> it needs a class constraint or something on the type
11:53:57 <mdmkolbe> @info Num
11:53:57 <lambdabot> (Num)
11:54:04 <mdmkolbe> @class Num
11:54:04 <lambdabot> Unknown command, try @list
11:54:07 <JohnMeacham_> SamB: hrm? I am not sure why ELF would be more appropriate. You can see the code in Support/CFF.hs, the PNG file format is very well thought out actually and very simple and I hate to reinvent wheels.
11:54:22 <EvilTerran> otherwise, you know nothing about the value you're given other than its type. as such, there's only two values of the same type you can return: that, and bottom.
11:54:23 <SamB> JohnMeacham_: I know ;-)
11:54:35 <EvilTerran> if you knew more you could do more, but you don't, so you can't.
11:54:44 <wli> Well, if you want to reinvent the symbol table, fine by me.
11:55:05 <JohnMeacham_> SamB: I suppose I can check in the current code now. I just can't do a library build at the moment, and people tend to notice that.
11:55:19 <SamB> JohnMeacham_: don't bother
11:55:26 <mdmkolbe> JohnMeacham_, SamB: what are you putting in this PNG/ELF.  If it is exe type data, then there are a lot of utilities that understand that when it is in an ELF but not a PNG.
11:55:51 <SamB> mdmkolbe: it's not
11:55:54 <wli> mdmkolbe: Understanding ELF is on a per-arch basis, so they actually won't.
11:56:14 <wli> mdmkolbe: The bytecode format (or whatever) won't be one of the arches they understand.
11:56:32 <JohnMeacham_> SamB: but the compile-edit loop should be much much faster now. it can pull just what is needed to fully typecheck everything really fast so it can blaze through that and give any type errors quickly, before going on to the heavy lifting.
11:56:39 <SamB> JohnMeacham_: oh.
11:56:46 <SamB> what prevents you from building the libs then?
11:56:47 <mdmkolbe> wli: wouldn't programs like "nm" still be of use?
11:56:52 <SamB> mdmkolbe: why?
11:57:00 <JohnMeacham_> SamB: oh, just some bugs I have not fixed yet.
11:57:08 <wli> mdmkolbe: Possibly though they may have spurious dependencies on architecture.
11:57:23 <SamB> mdmkolbe: the offsets are irrelevant and JHC could list the names anyway
11:57:48 <SamB> JohnMeacham_: well, it might be interesting
11:57:53 <SamB> how many of the libs can you build?
11:58:42 <JohnMeacham_> mdmkolbe: no, right now my 'ho' files are just a serialized haskell data type, however, depending on what jhc is doing, it might just need certain bits of the datatype, or others might be optional. so I needed a new file format that allowed multiple sections that could be individually addressed and compressed, I based this new file format on the PNG format because it is particularly well thought out.
11:59:27 <SamB> PNG is indeed well thought out
12:00:43 <mdmkolbe> JohnMeacham_: ok, that makes sense.  PNG is very extensible.  I'm not sure how extensible ELF is.
12:00:45 * gwern would be happier with PNG if PNG files weren't currently responsible for crashing half my apps. life without your favorite browser sucks!
12:00:47 <JohnMeacham_> mdmkolbe: the output of 'nm' wouldn't make much sense as it is not an object file format in any traditional way. though, I did consider using ELF and 'ar' archives at various points. It is not impossible I might do something with them in the future, but not for 'ho' files.
12:00:49 <SamB> long enough ago, I guess, that the problems they had with fairly small files are the problems we have now with much larger ones
12:01:05 * mdmkolbe muses about whether there is value to making an ELF'ish PNG for regular binaries
12:01:21 <SamB> gwern: well, the chunk layout is probably not what crashes your apps
12:01:45 <JohnMeacham_> mdmkolbe: yeah, I made the code to support files of that format pretty general, it can be useful as an independent haskell library.
12:01:56 <gwern> SamB: I have no idea what about the responsible PNGs is responsible. some PNGs work some don't and nobody else seems to have the same bug. it's quite aggravating
12:09:44 <mdmkolbe> eek...JPEG isn't morton order.  It's this strange back and forth zigzag.  (See http://en.wikipedia.org/wiki/Image:JPEG_ZigZag.svg)  Any ideas how to encode that into haskell?
12:09:46 <lambdabot> Title: Image:JPEG ZigZag.svg - Wikipedia, the free encyclopedia
12:10:03 <psykotic> mdmkolbe, most people use a lookup table, which you can probably find in a million places.
12:10:35 <psykotic> since the block size is fixed at 8x8, that's the easy way out
12:10:55 <sorear> .
12:10:57 <wli> The zigzag can probably be written in Haskell.
12:10:57 <mdmkolbe> psykotic: yeah, but I'd rather a more algorithmic definition as a matter of principal
12:11:33 <psykotic> btw there's already a nice literate haskell program for monochrome jpegs
12:11:57 <psykotic> http://www.imperialviolet.org/binary/jpeg/
12:11:57 <mdmkolbe> psykotic: the one by "Jeroen Fokker"?
12:11:58 <lambdabot> Title: Exploring JPEG
12:12:04 <psykotic> no, that one
12:13:12 <mdmkolbe> psykotic: thx, I'll use it as a reference, but I notice that even it uses a lookup table
12:13:17 <psykotic> it also doubles as the nicest introduction to the algorithmic basics of jpeg i've seen
12:13:20 <psykotic> yes
12:13:24 <psykotic> it's rather silly not to use one
12:14:03 <wli> They're just SW->NE diagonals in alternating orders.
12:14:28 <psykotic> yep, it's pretty easy. and those on the diagonals are those with constant x+y sum. so you do something like...
12:15:17 <EvilTerran> > [(i,n-i) | n <- [0..7], i <- [0..n]]
12:15:19 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
12:15:37 <wli> not quite
12:15:40 <psykotic> although you have to reverse the other based on n
12:15:42 <wli> alternating diagonals
12:15:48 <psykotic> so you use the parity of n somehow, should be easy
12:15:56 <EvilTerran> > [(if odd n then id else flip) (,) i (n-i) | n <- [0..7], i <- [0..n]]
12:15:57 <lambdabot>  [(0,0),(0,1),(1,0),(2,0),(1,1),(0,2),(0,3),(1,2),(2,1),(3,0),(4,0),(3,1),(2,...
12:17:04 <EvilTerran> > [(if odd n then id else flip) (,) i (n-i) | n <- [0..15], i <- [0..n], i < 8, (n-i) < 8]
12:17:05 <lambdabot>  [(0,0),(0,1),(1,0),(2,0),(1,1),(0,2),(0,3),(1,2),(2,1),(3,0),(4,0),(3,1),(2,...
12:17:31 <wli> EvilTerran: There you go.
12:17:36 <EvilTerran> :D
12:17:45 <psykotic> > map (\(x, y) -> x + y*8) [(if odd n then id else flip) (,) i (n-i) | n <- [0..15], i <- [0..n], i < 8, (n-i) < 8]
12:17:46 <lambdabot>  [0,8,1,2,9,16,24,17,10,3,4,11,18,25,32,40,33,26,19,12,5,6,13,20,27,34,41,48,...
12:18:15 <SamB> wli: what did you mean by 1:1 for segments exactly?
12:18:19 <mdmkolbe> That looks good for encoding.  What about decoding?
12:18:38 <psykotic> mdmkolbe, you build the lookup table and invert it.
12:18:48 <EvilTerran> > sort [(if odd n then id else flip) (,) i (n-i) | n <- [0..15], i <- [0..n], i < 8, (n-i) < 8] == [(x,y) | x <- [0..7], y <- [0..7]]
12:18:48 <wli> SamB: Base 0, size 4G
12:18:49 <lambdabot>  True
12:18:58 <wli> SamB: The case is specially optimized.
12:19:09 <SamB> so the size 4G part is critical?
12:19:17 <wli> SamB: Yes.
12:19:20 <SamB> rats.
12:19:22 <wli> SamB: And base 0, too.
12:19:24 <EvilTerran> fantastic, it's even right =]
12:19:32 <mdmkolbe> EvilTerran: I see what you mean
12:19:46 <EvilTerran> mdmkolbe, that was just a sanity check on my part
12:20:20 <mdmkolbe> well, if you zip with [0..] and then sort by the fst, you get the inverted lookup table
12:21:43 <diotalevi> This is an utter newb questions but given "foo x = x * pi" which I've typed "foo :: Int -> Float", what do I have to do to fix the typing so it works?
12:21:52 <EvilTerran> > sort [f (,) i (n-i) | n <- [0..15], let f = if odd n then id else flip, i <- [0 `max` (n-7)..n `min` 7]] == [(x,y) | x <- [0..7], y <- [0..7]] -- more efficient formulation
12:21:54 <lambdabot>  True
12:22:07 <mauke> diotalevi: you need to convert the x to Float first
12:22:12 <diotalevi> So how?
12:22:13 <SamB> wli: that part wouldn't have been a problem for this scheme, since it'd need to preserve offsets anyway...
12:22:17 <SamB> oh well.
12:22:19 <mauke> fromIntegral x
12:22:31 <mauke> also, why Float? Double is much awesomer
12:23:07 <roconnor> diotalevi: don't worry about asking that question.  It's a fairly unique issue with Haskell.
12:23:27 <EvilTerran> ?type fromInteger
12:23:29 <lambdabot> forall a. (Num a) => Integer -> a
12:23:36 <mdmkolbe> @type fromIntegral
12:23:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:23:47 <mauke> it also happened to me, and I already knew OCaml :-)
12:23:50 <EvilTerran> @src fromIntegral
12:23:50 <lambdabot> fromIntegral = fromInteger . toInteger
12:23:52 <diotalevi> I swear - I was trying to read the prelude docs and there's no pointers there on how to do this thing.
12:24:18 <mauke> yeah, you have to know how it works to understand how it works
12:24:25 <diotalevi> I was using fromInteger which then complained about some Num type. I'd try using Num instead of Int and it'd complain that I can't use Num.
12:24:40 <EvilTerran> Num is a class of types, rather than a type itself
12:24:44 <EvilTerran> ?t 4
12:24:44 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
12:24:46 <mauke> :t fromInteger
12:24:48 <EvilTerran> ?type 4
12:24:48 <lambdabot> forall a. (Num a) => Integer -> a
12:24:50 <lambdabot> forall t. (Num t) => t
12:25:05 <mauke> diotalevi: fromInteger takes an Integer, not an Int
12:25:10 <EvilTerran> "(Num t) => t" means t can be any numeric type
12:25:18 <wli> Try fromIntegral
12:25:21 <diotalevi> Just for kicks I tried inventing names like toFloat or using a constructor like (Float x) and that didn't work either.
12:25:30 <diotalevi> the latter I actually thought might be reasonable.
12:25:49 <mauke> not really
12:25:51 <mauke> not as a constructor
12:25:57 <diotalevi> And what's the deal with Integer not being an Int and the reverse?
12:26:01 <pgavin> @seen dcoutts
12:26:01 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 7h 45m 10s ago.
12:26:10 <mauke> diotalevi: Int is fixed-width integers, Integer is bignums
12:26:15 <diotalevi> I think I was running into Integer somewhere around then too.
12:26:30 <mauke> > 100^100 :: Int
12:26:31 <lambdabot>  0
12:26:33 <mauke> > 100^100 :: Integer
12:26:35 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
12:26:42 <Modius> Is Num not a type in Haskell?  I cannot get my function's first line fetch :: Num -> Integer to compile
12:26:46 <mauke> Modius: no
12:26:51 <mauke> Num is an interface
12:26:52 <diotalevi> So what is this - all the newb stuff is defined as "just doesn't work?"
12:27:18 <mauke> Modius: you could say fetch :: (Num a) => a -> Integer
12:27:40 <diotalevi> It's frustrating. The error messages are verbose and purport to be helpful but just lead me on a goose chase.
12:28:02 <mauke> in the beginning, it may be easier to ask for help here first
12:28:19 <mauke> (until you understand what the hell the compiler is thinking)
12:28:37 <oerjan> > sortBy (uncurry (+)) (join (liftM2 (,)) [0..7])
12:28:38 <lambdabot>      Occurs check: cannot construct the infinite type:
12:28:38 <lambdabot>       a = (a, a) -> Or...
12:29:04 <diotalevi> Ok, well thanks much, all. That pointer helped.
12:29:08 <mauke> what the
12:29:31 <oerjan> > sortBy (comparing . uncurry (+)) (join (liftM2 (,)) [0..7])
12:29:32 <lambdabot>      Occurs check: cannot construct the infinite type:
12:29:32 <lambdabot>       b = (b -> a, b -...
12:29:46 <oerjan> sheesh
12:30:03 <mauke> > join (liftM2 (,)) [0 .. 7]
12:30:04 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(1,0),(1,1),(1,2),(1,3),(1,...
12:31:25 <mauke> > sortBy (comparing $ uncurry (+)) (join (liftM2 (,)) [0..7])
12:31:26 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
12:31:45 <oerjan> right
12:32:19 <oerjan> too much cruft to be shorter..
12:33:24 <EvilTerran> join (liftM2 (,)) = cartesian product with self, right?
12:33:35 <Saizan_> right
12:33:40 <roconnor> mauke: very nice
12:34:57 <bwx> what is coarbitrary of quickcheck supposed to do?
12:35:12 <oerjan> bwx: generate functions from a type
12:35:35 <oerjan> @src Arbitrary
12:35:36 <lambdabot> Source not found. That's something I cannot allow to happen.
12:35:37 <EvilTerran> that's not quite right, it goes (n,0),(0,n+1); it should go (n,0),(n+1,0)
12:35:49 <EvilTerran> (obnoxious though that may be)
12:36:11 <bwx> oerjan: i don't understand
12:36:21 <EvilTerran> ?type coarbitrary
12:36:22 <lambdabot> Not in scope: `coarbitrary'
12:36:42 <bwx> coarbitrary :: a -> Gen b -> Gen b
12:38:53 <oerjan> the coarbitrary for a is used in the arbitrary for a -> b
12:39:24 <oerjan> instance (Arbitrary a, Arbitrary b) => Arbitrary (a -> b) where arbitrary         = promote (`coarbitrary` arbitrary) coarbitrary f gen = arbitrary >>= ((`coarbitrary` gen) . f)
12:40:02 <oerjan> promote :: (a -> Gen b) -> Gen (a -> b)
12:40:02 <oerjan> promote f = Gen (\n r -> \a -> let Gen m = f a in m n r)
12:40:33 <oerjan> i guess it is still not obvious how it works :>
12:40:49 <bwx> no i am totally confused by quickcheck :(
12:41:26 <Saizan_> however you need it only if you want to test higher order functions involving that type
12:42:33 <bwx> ok, i'll forget about coarbitrary for now. how can i use arbitrary to create random values of my type?
12:43:58 <bwx> my type has a default value "default", and it can be manipulated with f1 :: Int -> MyType -> MyType, and f2 :: Either String Bool -> MyType -> MyType
12:44:30 <bwx> i need to apply random varying sequences of f1, f2 to default, in order to come up with random values. how do i do this?
12:45:08 <phobes> Does anyone know why this is disallowed?  listOfId :: [forall a. a->a]
12:45:36 <mauke> phobes: because forall is not a keyword in haskell 98. you need to enable extensions
12:45:36 <opqdonut> phobes: see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
12:45:38 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
12:45:40 <opqdonut> that explains it iirc
12:45:43 <mdmkolbe> > [[((i+j)*(i+j+1))%2+(if odd (i+j) then i%1 else j%1)| j <- [0..7]] | i <- [0..7]] -- In case anyone was curios
12:45:45 <lambdabot>  [[0%1,1%1,5%1,6%1,14%1,15%1,27%1,28%1],[2%1,4%1,7%1,13%1,16%1,26%1,29%1,43%1...
12:45:48 * mdmkolbe leaves
12:45:53 <opqdonut> mauke: no, i think that doesn't work even with extensions on
12:45:53 <phobes> mauke: even with extensions
12:45:54 <opqdonut> iirc
12:46:06 <mauke> :(
12:46:06 <phobes> > id :: [forall a. a->a]
12:46:06 <lambdabot>  Parse error
12:46:19 <phobes> opqdonut: know why?
12:46:31 <phobes> > [id] :: [forall a. a->a]
12:46:31 <lambdabot>  Parse error
12:46:33 <mauke> works here
12:46:35 <opqdonut> phobes: look at that link
12:46:43 <bparkis> can you use pattern matching in an unnamed lambda?
12:46:45 <opqdonut> iirc it explained it
12:46:48 <phobes> ok
12:46:49 <mauke> *Main> :t spork
12:46:49 <mauke> spork :: [forall a. a -> a]
12:46:52 <opqdonut> too drunk to look it up meself
12:47:02 <oerjan> bwx: i recall that Gen is a monad and you can define arbitrary with monadic code
12:48:00 <conal> bparkis: yes.  \ (x,y) -> ...
12:48:15 <opqdonut> tho you can only match one case
12:48:26 <conal> right
12:48:33 <opqdonut> or well, you can do multiple cases with case: \x -> case x ...
12:49:37 <phobes> mauke:  Ya, it works for me too ...
12:49:48 <phobes> opqdonut:  The link you gave was where I read it didn't work
12:49:54 <phobes> weird
12:50:00 <opqdonut> wow
12:50:38 <bwx> oerjan: hm......
12:51:56 <fasta> Why is Data.Ix the way it is?
12:52:09 <phobes> @hoogle [a->b]->[a]->[b]
12:52:10 <lambdabot> No matches, try a more general search
12:52:28 <fasta> It seems the class has a bloated interface, but it might be that there is a good reason for it.
12:52:37 <oerjan> bwx: the -- derived section of QuickCheck.hs lists several utility functions for helping with this
12:52:47 <mauke> :t zipWith id
12:52:52 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
12:53:00 <phobes> thx
12:53:20 <monochrom> Data.Ix is not bloated.
12:54:42 <phobes> well, it doesn't seem to work
12:54:48 <phobes> afterall
12:55:00 <phobes> > [forall a. a->a]
12:55:00 <lambdabot>  Parse error
12:55:03 <phobes> grr
12:55:08 <bwx> oerjan: thanks i'll see if i can figure it out
12:55:11 <phobes> > zipWith id ([id, id]) [2, 2]
12:55:13 <lambdabot>  [2,2]
12:55:23 <phobes> > zipWith id ([id, id] :: [forall a.a->a]) [2, 2]
12:55:23 <lambdabot>  Parse error
12:55:36 <phobes> Does lambdabot not have extensions on?
12:55:43 <mauke> I don't think so
12:55:47 <oerjan> bwx: i suppose you would write a subfunction of the type Gen (MyType -> MyType), generate a list of that, and fold it
12:56:03 <opqdonut> i prefer
12:56:08 <opqdonut> :t zipWith ($)
12:56:10 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
12:56:14 <opqdonut> makes clearer that it's function application
12:56:19 <phobes> well I have extensions on and I get this error:
12:56:20 <phobes>    Couldn't match expected type `b -> c'
12:56:20 <phobes>            against inferred type `forall a. a -> a'
12:56:20 <phobes>       Expected type: [b -> c]
12:56:20 <phobes>       Inferred type: [forall a. a -> a]
12:56:20 <phobes>     In the second argument of `zipWith', namely
12:56:22 <mauke> but ($) is id :-)
12:56:22 <phobes>         `([id, id] :: [forall a. a -> a])'
12:56:24 <phobes>     In the expression:
12:56:26 <oerjan> :r replicateM
12:56:26 <phobes>         zipWith id ([id, id] :: [forall a. a -> a]) [2, 2]
12:56:30 <oerjan> :t replicateM
12:56:30 <conal> opqdonut: me too
12:56:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:56:57 <phobes> nm, makes sense
12:57:08 <bwx> oerjan: the thing that makes it a little more complicated is that there are certain rules about which functions can be applied to MyType under different circumstances
12:57:31 <oerjan> bwx: ouch, so not every sequence of f1's and f2's works?
12:57:47 <bwx> indeed
12:58:27 <bwx> i have something like "add" and "remove" functions, and you are only allowed to call remove if you previously called add with the same parameter
12:59:26 <fasta> monochrom: it should just have a tuple with the bounds.
12:59:26 <oerjan> bwx: hm... you might want to use StateT [Param] Gen to keep track of your used parameters
12:59:41 <fasta> monochrom: not 4 methods that can be implemented when one has the bounds.
13:00:03 <bwx> oerjan: that sounds about right, but i'm still pretty confused about the whole thing :|
13:00:04 <monochrom> Can the other methods be still as fast?
13:00:37 <fasta> monochrom: I suspect so, yes.
13:00:58 <tonfa> how do you printf a Word8 value ?
13:01:30 <oerjan> > printf "%d" (1 :: Word8) :: String
13:01:31 <lambdabot>   add an instance declaration for (PrintfArg Word8)
13:01:31 <lambdabot>     In the expression: pr...
13:01:37 <mauke> you convert it to something printf understands first
13:01:57 <monochrom> I don't understand "just have a tuple with the bounds". Could you write the class declaration in your mind?
13:01:57 <sjanssen> > printf "%d" (fromIntegral (1 :: Word8))
13:01:58 <lambdabot>  Add a type signature
13:02:03 <tonfa> like Char ?
13:02:16 <mauke> yeah, or Int
13:02:24 <oerjan> > printf "%d" (toInteger (1 :: Word8))
13:02:25 <lambdabot>  Add a type signature
13:02:31 <oerjan> > printf "%d" (toInteger (1 :: Word8)) :: String
13:02:32 <lambdabot>  "1"
13:02:43 <tonfa> I see
13:02:44 <tonfa> thanks
13:03:14 <oerjan> sjanssen: printf is so overloaded you have to fix the type of all its arguments and the result
13:03:20 <fasta> monochrom: hmm, never mind
13:03:40 <monochrom> hehe
13:05:22 <oerjan> bwx: i suppose Gen is "simply" a monad with utility functions for making random choices of various values, the rest of the problem should be just generic monadic code
13:06:10 <bwx> oerjan: hm.... i'll try playing around with it
13:07:14 <phobes> opqdonut:  I agree about zipWith ($) ... zipWith id was quite a puzzlement
13:07:29 <opqdonut> :)
13:07:46 <geezusfreeek> :t zipWith ($)
13:07:48 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
13:07:58 <mauke> ($) = id
13:08:19 <mauke> :t [id, ($)]
13:08:21 <lambdabot> forall a b. [(a -> b) -> a -> b]
13:08:43 <alar> I see palomer banned by ChanServ
13:09:02 <alar> @seen palomer
13:09:02 <lambdabot> I saw palomer leaving #haskell 14d 12h 56m 30s ago, and .
13:09:11 <opqdonut> mauke: yeah, of course they're equivalent
13:09:11 <sjanssen> @seen notpalomer
13:09:12 <lambdabot> I saw notpalomer leaving #haskell 11d 23h 49m 26s ago, and .
13:09:16 <sjanssen> @seen palonotmer
13:09:16 <lambdabot> I saw palonotmer leaving #haskell 11d 23h 27m 42s ago, and .
13:09:20 <opqdonut> ($) is just clear at once for everybody
13:09:22 <opqdonut> i'd say
13:09:33 <mauke> 'id' was obvious to me :-)
13:09:50 <opqdonut> :)
13:11:09 <tonfa> it works :)
13:11:10 <tonfa>  hex [0, 0]
13:11:11 <tonfa> "0000"
13:13:03 <phobes> :t ($)
13:13:05 <lambdabot> forall a b. (a -> b) -> a -> b
13:13:24 <phobes> ok, ($) /= id
13:13:28 <mauke> a.k.a. (a -> b) -> (a -> b)
13:13:32 <phobes> ya
13:13:40 <phobes> ($) is id with a more specific type
13:13:43 <mauke> ($) :: (a -> b) -> (a -> b); ($) = id
13:13:49 <phobes> :t id
13:13:51 <lambdabot> forall a. a -> a
13:15:10 <tonfa> @hoogle [a] -> [(a,a)]
13:15:10 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
13:16:00 <mauke> :t map (join (,))
13:16:02 <lambdabot> forall a. [a] -> [(a, a)]
13:16:41 <oerjan> :t join zip
13:16:43 <lambdabot> forall a. [a] -> [(a, a)]
13:17:17 <oerjan> :t join (liftM2 (,))
13:17:19 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m a2 -> m (a2, a2)
13:18:20 <oerjan> i guess the first two are equivalent
13:19:09 <tonfa> i wanted to do [a1,b1,a2,b2,...] -> [(a1,b1), (a2,b2), ...]
13:19:19 <oerjan> oh
13:19:35 <tonfa> something like zip l (tail l) and filtering even value ?
13:20:52 <opqdonut> tonfa: well i'd just do
13:21:16 <opqdonut> > let f [] = []; f (x:y:xs) = (x,y):f xs in f [1,2,3,4,5,6]
13:21:19 <lambdabot>  [(1,2),(3,4),(5,6)]
13:21:25 <opqdonut> pattern match ftw
13:21:37 <mauke> > let f [] = []; f (x:y:xs) = (x,y):f xs in f "lol"
13:21:38 <lambdabot>   Non-exhaustive patterns in function f
13:21:53 <mauke> > let f (x:y:xs) = (x,y):f xs; f _ = [] in f "lol"
13:21:56 <lambdabot>  [('l','o')]
13:22:27 <opqdonut> well if he really wants to do that i'd guess he can guarantee length being even :)
13:22:39 <tonfa> yep
13:23:59 <int-e> > unfoldr (\xs@ ~(x:y:xs') -> guard (not . null . drop 1 $ xs) >> return ((x,y),xs')) "abcdefg"
13:24:01 <lambdabot>  [('a','b'),('c','d'),('e','f')]
13:24:03 <tonfa> i'm just writing the binascii.hexlify/unhexlify of python
13:25:13 <EvilTerran> > unfoldr (\xs -> do x:y:zs <- return xs; return ((x,y),zs)) [1..]
13:25:15 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
13:25:26 <EvilTerran> or, with lambda-match,
13:25:26 <int-e> oh right
13:25:44 <EvilTerran> unfoldr (|x:y:zs -> return ((x,y),zs)) [1..]
13:25:54 <EvilTerran> but we haven't got that =/
13:26:28 <opqdonut> what's |x:y:zs?
13:26:43 <int-e> > let f xs = [(x,y) | (x,y,n) <- zip3 xs (tail xs) [1..], odd n] in f "abracadabra"
13:26:45 <lambdabot>  [('a','b'),('r','a'),('c','a'),('d','a'),('b','r')]
13:26:47 <sorear> a tyop
13:27:25 <EvilTerran> no, it's lambda-match. it's one of the proposals for haskell'.
13:27:44 <tonfa> what does it mean ?
13:27:55 <EvilTerran> (| PAT -> EXP) would desugar to (\fresh -> case fresh of PAT -> EXP; _ -> mzero)
13:28:12 <opqdonut> ahh
13:28:21 <EvilTerran> (or "fail" rather than mzero)
13:28:35 <mauke> no, not fail :(
13:28:36 <int-e> hmm. that would make unfoldr really useful
13:28:38 <EvilTerran> like things bound in do{}blocks
13:29:21 <EvilTerran> because that little bit of desugaring being peculiar to do ... <- ... is *weird*.
13:29:49 <oerjan> it's also in list comprehensions
13:30:05 <EvilTerran> well, that's just a less polymorphic do{} ;p
13:30:44 <tonfa> :t readHex
13:30:47 <lambdabot> forall a. (Num a) => String -> [(a, String)]
13:31:37 * EvilTerran has a sneaky feeling he's going to end up trying to hack in ghc fairly soon
13:33:19 <ddarius> EvilTerran: Why not?
13:33:34 <EvilTerran> because it's Big And Scarey?
13:34:54 <tonfa> is reading a hexadecimal value ambiguous ?
13:35:01 <tonfa> why does it returns a list
13:35:29 <oerjan> tonfa: just to be compatible with the ReadS type used in the Read class
13:35:45 <oerjan> also, to signal failure with an empty list
13:35:54 <ddarius> tonfa: You might want to read something after that hexadecimal number.
13:35:59 <SamB> and so it can read just part of the string
13:36:20 <oerjan> @src ReadS
13:36:20 <lambdabot> Source not found. Wrong!  You cheating scum!
13:36:25 <oerjan> @src Read
13:36:25 <lambdabot> class Read a where
13:36:25 <lambdabot>   readsPrec    :: Int -> ReadS a
13:36:25 <lambdabot>   readList     :: ReadS [a]
13:36:25 <lambdabot>   readPrec     :: ReadPrec a
13:36:25 <lambdabot>   readListPrec :: ReadPrec [a]
13:36:40 <tonfa> and if my string has length 2 and i don't care what is after ?
13:37:00 <tonfa> should I use something else ?
13:37:23 <oerjan> tonfa: if you don't care just throw it away
13:38:01 <tonfa> fst . head ?
13:38:04 <ddarius> :t listToMaybe . reads
13:38:09 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
13:38:18 <ddarius> :t fmap fst . listToMaybe . reads
13:38:19 <lambdabot> forall a. (Read a) => String -> Maybe a
13:38:32 <tonfa> ok thanks
13:38:45 <ddarius> fst . head would be fine assuming you don't mind a pattern match error if it doesn't parse.
13:38:59 <tonfa> maybe is nicer I suppose
13:39:00 <tonfa> right ?
13:39:29 <ddarius> It depends on what you're going for, but with Maybe you can always use fromJust if you don't mind a pattern match error
13:39:34 <ddarius> You can't nicely go the other way.
13:39:40 <oerjan> @hoogle ReadS a -> a
13:39:41 <lambdabot> No matches, try a more general search
13:41:24 <EvilTerran> ?src ReadS
13:41:25 <lambdabot> Source not found. It can only be attributed to human error.
13:42:06 <EvilTerran> > ($"") :: ReadS a -> a
13:42:07 <oerjan> type ReadS a = [Char] -> [(a,[Char])]
13:42:07 <lambdabot>   ($ "")
13:42:07 <lambdabot>     In the expression: ($ "") :: ReadS a -> a
13:42:07 <lambdabot>     In the definition ...
13:42:24 <EvilTerran> > fst . head . ($"") :: ReadS a -> a
13:42:25 <lambdabot>  Add a type signature
13:42:33 <oerjan> EvilTerran: that's ShowS you're thinking of
13:43:27 <oerjan> well, possibly
13:43:50 <EvilTerran> don't think so, no
13:44:04 <EvilTerran> ?type fst . head . ($"") :: ReadS a -> a
13:44:06 <lambdabot> ReadS a -> a :: forall a. ReadS a -> a
13:44:18 <EvilTerran> ... okay then.
13:44:20 <hsuh> hey, remember that i was complaining about haskell mode?
13:44:52 <monochrom> Yeah, you wanted the computer to write programs automatically.
13:44:56 <opqdonut> :D
13:45:11 <hsuh> monochrom: sort of :) i want to take it all back! its great, mainly the inferior mode, it rules!
13:45:37 <EvilTerran> uh... the inferior mode is superior?
13:45:46 <hsuh> indeed!
13:46:09 <monochrom> Nice. Some indentation issues should be fixed, but some just can't be.
13:46:20 <hsuh> yes, they cant
13:47:03 <hpaste>  tonfa pasted "emulate binascii.unhexlify from python" at http://hpaste.org/2434
13:47:10 <tonfa> this is how it looks
13:47:57 <Saizan_> well, if you're going to use fromJust you could use head in the first place
13:48:11 <tonfa> it yields the same error ?
13:48:14 <fasta> What would be the fastest way to parse number,number,number/n* into a list of list of [number]? I used Parsec, which looks nice, but is slow.
13:48:17 <Saizan_> similar
13:48:20 <tonfa> I'm still a noob
13:48:22 <Saizan_> > fromJust Nothing
13:48:23 <lambdabot>  Exception: Maybe.fromJust: Nothing
13:48:25 <tonfa> thanks
13:48:27 <Saizan_> > head []
13:48:27 <oerjan> tonfa: i see you are converting (a,b) back to [a,b]
13:48:28 <lambdabot>  Exception: Prelude.head: empty list
13:49:00 <tonfa> oerjan: hum, you're right
13:49:06 <tonfa> take 2 instead ?
13:49:14 <tonfa> splitAt
13:49:29 <oerjan> unfoldr (Just . splitAt 2)
13:49:50 <tonfa> @src unfoldr
13:49:51 <lambdabot> unfoldr f b  = case f b of
13:49:51 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
13:49:51 <lambdabot>    Nothing        -> []
13:50:24 <fasta> Is there a version of read which reads a number from a string and returns the number and the string left?
13:50:29 <koala_man> @src group
13:50:30 <lambdabot> group = groupBy (==)
13:50:36 <EvilTerran> ?type readS
13:50:38 <lambdabot> Not in scope: `readS'
13:50:40 <koala_man> @src groupBy
13:50:41 <lambdabot> groupBy _  []       =  []
13:50:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:50:41 <lambdabot>     where (ys,zs) = span (eq x) xs
13:50:47 <Saizan_> fasta: there's readInt in ByteString
13:50:58 <EvilTerran> ?type reads
13:51:01 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:51:15 <oerjan> > map fst . listToMaybe . readHex . takeWhile (not . null) . unfoldr (Just splitAt 2) $ "01ffa2"
13:51:16 <lambdabot>  Couldn't match expected type `t -> a -> Maybe (a1, a)'
13:51:23 <EvilTerran> > reads "23 skidoo" :: [(Int,String)]
13:51:24 <lambdabot>  [(23," skidoo")]
13:51:28 <opqdonut> :D
13:51:30 <opqdonut> 23 skidoo
13:51:34 <EvilTerran> > head . reads "23 skidoo" :: (Int,String)
13:51:35 <lambdabot>  Couldn't match expected type `a -> [a1]'
13:51:45 <EvilTerran> well, you get the idea.
13:51:50 <oerjan> > map (fst . listToMaybe . readHex) . takeWhile (not . null) . unfoldr (Just splitAt 2) $ "01ffa2"
13:51:51 <lambdabot>  Couldn't match expected type `(a, b)'
13:52:06 <Saizan_> Just . spliAt 2?
13:52:12 <Saizan_> t
13:52:13 <EvilTerran> reads returns a list of possible parses. intended for use in the [] monad, i think.
13:52:40 <EvilTerran> > unfoldr (Just . splitAt 2) "foo"
13:52:43 <lambdabot>  ["fo","o","","","","","","","","","","","","","","","","","","","","","","",...
13:52:47 <EvilTerran> > unfoldr (Just . splitAt 2) "fooo"
13:52:48 <lambdabot>  ["fo","oo","","","","","","","","","","","","","","","","","","","","","",""...
13:52:51 <oerjan> > map (fst . listToMaybe . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2) $ "01ffa2"
13:52:52 <lambdabot>  Couldn't match expected type `(a, b)'
13:52:59 <Saizan_> String -> [(a,String)] is a monad
13:53:22 <oerjan> Saizan_: add State to it
13:53:22 <EvilTerran> Saizan_... that's a writer-transformed nondeterminism monad, right?
13:53:31 <oerjan> i mean StateT
13:53:58 <EvilTerran> state-transformed? meh.
13:54:12 <Saizan_> i think it corresponds to ListT (State String)
13:54:26 <Saizan_> no..
13:54:55 <Saizan_> StateT String []
13:55:39 <oerjan> > map (head . map fst . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2) $ "01ffa2"
13:55:40 <lambdabot>  [1,255,162]
13:55:48 <oerjan> finally
13:56:16 <mauke> try { return 42; } finally { return 0; }
13:57:40 <oerjan> > map (fst . head . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2) $ "01ffa2"
13:57:42 <lambdabot>  [1,255,162]
13:58:13 <bwx> how can i see the values that arbitrary is generating?
13:58:22 <fasta> @hoogle readInt
13:58:22 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
13:58:23 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
13:58:23 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
13:58:30 <EvilTerran> @hoogle trace
13:58:31 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:58:31 <oerjan> bwx: generate, i think
13:58:31 <lambdabot> Debug.Trace :: module
13:58:31 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
13:58:34 <fasta> Saizan_: where?
13:59:41 <oerjan> bwx: you can use vector n arbitrary to generate a list of them at once
14:00:11 <Saizan_> ?type Data.ByteString.Char8.readInt
14:00:13 <lambdabot> Data.ByteString.Base.ByteString -> Maybe (Int, Data.ByteString.Base.ByteString)
14:00:20 <bwx> oerjan: hm.... thanks
14:03:30 <fasta> Saizan_: thanks
14:03:37 <oerjan> > map (map fst . mapM readHex . takeWhile (not . null) . unfoldr (Just . splitAt 2)) ["01ffa2", "fnord."]
14:03:38 <lambdabot>  Couldn't match expected type `(a, b)'
14:06:15 <oerjan> > map (mapM (liftM fst . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2)) ["01ffa2", "fnord."]
14:06:17 <lambdabot>  [[[1,255,162]],[]]
14:15:58 <EvilTerran> good lord!
14:16:17 <bwx> yes my son?
14:16:42 <EvilTerran> yes, quite... I just switched back to this tab and saw oerjan's... curious construction, there.
14:17:16 <mauke> @unpl map (mapM (liftM fst . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2))
14:17:17 <lambdabot> map (\ c -> mapM (\ f -> liftM fst (readHex f)) (takeWhile (\ l -> not (null l)) (unfoldr (\ o -> (Just) (splitAt 2 o)) c)))
14:18:31 <oerjan> that was a bit excessive, i guess
14:18:55 <EvilTerran> > unfoldr (liftM2 (>>) (guard . not . null) (Just . splitAt 2)) "qwertyuiop"
14:18:56 <lambdabot>  ["qw","er","ty","ui","op"]
14:20:11 <oerjan> > map (mapM (listToMaybe . map fst . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2)) ["01ffa2", "fnord."]
14:20:12 <lambdabot>  [Just [1,255,162],Nothing]
14:20:48 <bwx> does it make sense to have a StateT X (State Y), or should i just use a State (X, Y) ?
14:21:20 <oerjan> the point of this and the previous is that mapM collapses it all if one bit is faulty
14:21:51 <Saizan_> bwx: StateT X (State Y) doens't work well with the MonadState class
14:22:00 <oerjan> bwx: State (X, Y) should normally be simpler
14:22:11 <mauke> or even State CustomStruct
14:22:16 <oerjan> you need lift to get at the Y otherwise
14:22:17 <mauke> selector functions ftw
14:23:01 <Saizan_> bwx: i'd use State Record  where data Record = R {x :: X,y :: Y } and use gets x.. gets y
14:23:06 <oerjan> unless i guess your code is really two-tiered and you only access X in that bit that has it in the type
14:23:48 <oerjan> *, i guess, if
14:24:50 <bwx> oerjan: i'm working on your idea of StateT [Param] Gen, but it seems that i also need to store the resulting value as a state
14:26:09 <oerjan> bwx: you do have the option to thread them explicitly if that is simpler
14:26:40 <bwx> oerjan: yeah but i can't seem to figure out how to thread them
14:27:28 <oerjan> bwx: a recursive function with params and value as parameters?
14:27:50 <bwx> hm..... i'll have to think about this some more
14:38:05 <fasta> @localtime dons
14:38:06 <lambdabot> Local time for dons is Sun Aug 26 07:37:05 2007
14:42:13 <bwx> oerjan: alright, i got it!
14:43:39 <tonfa> runhaskell Setup.lhs configure --prefix=~/local
14:43:49 <tonfa> after installing a hackage package like this
14:44:00 <tonfa> do I have to change something in my environment ?
14:44:13 <tonfa> (like PYTHONPATH for python)
14:44:15 <oerjan> bwx: great :)
14:44:46 <sorear> tonfa: no.
14:45:03 <tonfa> sorear: it will "just work" ?
14:45:18 <sorear> tonfa: right.  there is a global package database (always in $HOME/.ghc) which tells ghc where to look.
14:45:48 <tonfa> ok I needed --user for install
14:45:57 <sorear> and another system-wide one for packages installed as root without --user
14:46:09 <tonfa> ok
14:46:13 <tonfa> thanks
14:47:15 <jbalint> @hoogle mcons
14:47:16 <lambdabot> Data.Generics.Basics.fromConstr :: Data a => Constr -> a
14:47:16 <lambdabot> Data.Generics.Basics.fromConstrB :: Data a => a -> Constr -> a
14:47:16 <lambdabot> Data.Generics.Basics.fromConstrM :: (Monad m, Data a) => m a -> Constr -> m a
14:47:20 <jbalint> what is mcons?
14:48:35 <Cale> jbalint: looking at the Prelude code for sequence?
14:48:37 <tonfa> I just installed http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.3
14:48:40 <lambdabot> http://tinyurl.com/25ptqt
14:48:41 <jbalint> Cale: Yes...
14:48:48 <tonfa> the package is supposed to be Data.Binary ?
14:48:49 <Cale> jbalint: check the where clause :)
14:49:07 <jbalint> Cale: heh, sorry.. thanks :)
14:49:12 <oerjan> @src sequence
14:49:12 <lambdabot> sequence ms = foldr k (return []) ms
14:49:12 <lambdabot>     where
14:49:12 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
14:49:14 <Cale> That's kind of an odd way to write it though
14:49:20 <Cale> and @src is even worse
14:50:05 <Cale> Either you write it the tidy way:   sequence = foldr (liftM2 (:)) (return [])
14:50:12 <Cale> or:
14:50:19 <Cale> sequence [] = return []
14:50:27 <desp> (:))
14:50:41 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
14:51:35 <bwx> what happens in quickcheck if i do elements of empty list?
14:51:38 <Cale> The way with foldr emphasizes the fact that it replaces list structure with program structure.
14:52:01 <jbalint> Ok
14:52:17 <oerjan> bwx: don't do that?
14:52:25 <Cale> Basically, it takes a list of actions and produces an action which runs each in turn, producing a list of results.
14:52:55 <Cale> In the list monad, "running" a list means selecting one of its elements in all possible ways, so:
14:53:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
14:53:04 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
14:53:14 <oerjan> bwx: either !! or choose gives a runtime error
14:53:18 <oerjan> is my guess
14:54:01 <Cale> In the ((->) e) monad, "running" a function means applying it to the parameter that the overall function has been applied to:
14:54:18 <Cale> > sequence [id,(+2),(*2),(^2),(2^)] 5
14:54:19 <lambdabot>  [5,7,10,25,32]
14:54:49 <jbalint> Whats ((->) e) monad?
14:55:02 <Cale> Functions from the type e
14:55:29 <jbalint> ah
14:55:32 <Cale> If you already know about the reader monad, it's the same thing
14:55:42 <jbalint> ok, i'm good to go. thanks for the info :)
14:56:04 <ivant> how reader monad is useful?
14:56:12 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:56:15 <lambdabot>  ("hello","olleh","HELLO")
14:56:24 <TSC> ivant: You can use it to store a read-only "environment"
14:56:54 <ivant> TSC, why can't I simply use good ol' State monad?
14:56:55 <Cale> (and make local changes to that environment)
14:57:17 <oerjan> ivant: i think Reader is better for laziness sometimes
14:57:23 <shapr> Multiple threads in C, will automatically use other CPUs like ghc-smp, right?
14:57:24 <Cale> ivant: You can, but you risk having non-local propagation of state when you don't need it.
14:57:57 <conal> > liftA3 (,,) id reverse (map toUpper) "hello"
14:57:59 <lambdabot>  ("hello","olleh","HELLO")
14:58:11 <conal> (or liftM3)
14:58:18 <Cale> right :)
14:58:25 <ivant> Cale, ah, you're saying that I can change the environment state inside the reader monad, but it won't be visible from outside?
14:58:35 <ivant> what is meant by outside then?
14:58:40 <TSC> The caller
14:58:41 <Cale> ivant: You can change the environment only locally
14:59:14 <TSC> A bit like a let-binding
14:59:18 <conal> Cale: i like your uses of ((->) a).  nice tricks!
14:59:39 <Cale> conal: We've come to really enjoy it around here
14:59:43 <Cale> > join (*) 5
14:59:45 <lambdabot>  25
14:59:49 <conal> pretty
15:00:01 <tnks> Is there a programming language term that refers to the reuse of a calculated value?
15:00:03 <Cale> > map (ap (,) (^2)) [1..10]
15:00:04 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
15:00:18 <Cale> tnks: sharing?
15:00:34 <ivant> memoizing?
15:00:44 <tnks> It seems to come naturally to Haskell with referential transparency and lazy evaluation, but neither of those terms are it.
15:00:50 <conal> Cale: that's  a beauty!
15:00:58 <tnks> ivant: yeah... memoizing seems close to it.
15:01:41 <tnks> actually, I think memoization is dead on
15:01:53 <tnks> the term just slipped my mind.
15:02:01 <Cale> ap is S and return is K
15:03:12 <Cale> fmap is (.)
15:03:34 <Cale> It's a really nice instance :)
15:03:35 <conal> applicative functors
15:04:30 <Cale> It really ought to be in the Prelude.
15:05:06 <conal> gee.  ap (,) is a really nice idiom i didn't know.
15:05:56 <ddarius> :t ap (,)
15:05:58 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
15:09:20 <Cale> > let fibs = fix ((0:) . (1:) . ap (zipWith (+)) tail) in fibs
15:09:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:09:50 <oerjan> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
15:09:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:10:10 <Heffalump> ooh, yes
15:10:25 <Cale> > fix ((0:) . scanl (+) 1)
15:10:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:10:39 <conal> zowie!
15:11:31 <conal> hm.  where is that mind benders wiki page?
15:11:35 <conal> (haskell wiki)
15:12:09 <oerjan> @go blow your mind haskell
15:12:11 <lambdabot> http://www.haskell.org/haskellwiki/Blow_your_mind
15:12:11 <lambdabot> Title: Blow your mind - HaskellWiki
15:12:21 <conal> thanks
15:12:43 <xerox> Do you know if there's a field in .cabal to pass options to configure?
15:18:32 <marcotmarcot> Hello there.
15:19:45 <bwx> ok quickcheck found a bug, but i can't figure out where in the code the bug is
15:19:48 <TSC> Hi
15:20:51 <marcotmarcot> I already asked this two times here, but I'm asking again.  It's about Text.Xhtml.Strict, wouldn't it be better if all functions were HTML a => a -> HTML, and then no << would be necessary?
15:21:08 <oerjan> bwx: did you get the error case properly displayed?  i recall this was a problem with functions.
15:21:43 <bwx> oerjan: yes, i see the bad value, but i don't know which random steps were taken to get to it
15:22:18 <oerjan> you might want to generate a representation of the steps together with the value
15:23:15 <xerox> Anybody built ghci on osx recently?
15:23:23 <bwx> yeah, that might make things a bit more complex though.... i'm trying my luck with Debug.Trace
15:27:59 <hpaste>  navi pasted "can we improve this?" at http://hpaste.org/2436
15:28:31 <ivant> oops, that was me on hpaste, with my usual nick
15:30:12 <monochrom> about as good as it gets
15:31:25 <ivant> I wish I could write "createSupportWindow" only once, but couldn't find a good way to do this
15:31:28 <ddarius> maybe can get rid of one of the cases.
15:32:03 <shapr> Hm, I've never created a torrent before, how do I do that with debian/unstable?
15:32:10 * shapr wants to torrent Hamming's videos
15:33:52 * shapr suspects xerox is downloading hamming videos now
15:34:02 * shapr moves to #haskell-blah
15:34:39 <hpaste>  sjanssen annotated "can we improve this?" with "a little better?" at http://hpaste.org/2436#a1
15:36:26 <oerjan> sjanssen: i am not sure that is well typed?
15:36:46 <ivant> sjanssen, isValidWindow is Window→X Bool, so no need to fmap there
15:37:06 <oerjan> valid is X Bool not Bool
15:37:09 <sjanssen> oerjan: correct
15:37:13 <sjanssen> several problems here
15:37:35 <oerjan> ivant: he is trying to mix X and Maybe
15:37:53 <hpaste>  conal annotated "can we improve this?" with "maybe" at http://hpaste.org/2436#a2
15:38:21 <ivant> oerjan, I tried to do this, but it only obscured the intent
15:38:25 <sorear> @users
15:38:26 <lambdabot> Maximum users seen in #haskell: 385, currently: 367 (95.3%), active: 19 (5.2%)
15:38:26 <conal> i wonder if it could be more beautiful, though
15:39:02 * mdmkolbe returns
15:39:07 <hpaste>  sjanssen annotated "can we improve this?" with "correct?" at http://hpaste.org/2436#a3
15:39:33 <monochrom> ok, I like that.
15:39:54 <ivant> @ty maybe
15:40:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:40:24 <oerjan> conal: as you see, not well-typed
15:40:54 <conal> oerjan: no?
15:41:03 <hpaste>  sjanssen annotated "can we improve this?" with "grrr" at http://hpaste.org/2436#a4
15:41:43 <conal> i'd like to see a solution with only one operation that examines cases.
15:41:45 <ivant> sjanssen, that looks better, I was stuck typechecking the previous one in my brain
15:41:50 <oerjan> conal: you're just missing a flip i think
15:42:15 <conal> oerjan: yes, of course.  thanks.
15:43:13 <hpaste>  conal annotated "can we improve this?" with "oerjan's fix" at http://hpaste.org/2436#a5
15:43:36 <ivant> @ty maybe (return False) a b
15:43:38 <lambdabot> Not in scope: `a'
15:43:38 <lambdabot>  
15:43:38 <lambdabot> <interactive>:1:23: Not in scope: `b'
15:43:39 <conal> pretty obscure, and not very pretty.
15:43:51 <ivant> @ty maybe (return False) (undefined :: a) (undefined :: b)
15:43:52 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool
15:44:19 <ivant> @ty maybe
15:44:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:44:52 <conal> ?ty maybe id
15:44:53 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
15:47:48 <ivant> sjanssen, still cannot understand your solution completely, but it seems to typecheck ok :-) still thinking
15:47:56 <conal> anyone know how to make firefox plugins?
15:48:40 <ivant> conal, I did a prototype of one once, but that was couple of years ago
15:48:57 <metaperl> yo, what is syntax for a single character in haskell?
15:49:11 <conal> i bet we could make some nifty plugins in haskell, given the html libs.
15:49:26 <augustss> metaperl: 'a'
15:49:46 <metaperl> augustss: thanks. and a string looks like "this" {* right? *}
15:49:55 <augustss> yes
15:49:56 <sorear> "this" {-  right! -}
15:50:00 <xerox> conal: gtk2hs has got some kind of binding with mozilla and firefox
15:50:01 <metaperl> oh! :)
15:50:10 <sorear> (* *) is SML, I think you may have mixed it up
15:50:10 <conal> xerox: oh??
15:50:16 <ivant> conal, they use javascript, and I'm not sure it'd be easy to mix it with haskell binaries
15:50:27 <ivant> but we can compile haskell to JavaScript :-)
15:50:36 <oerjan> > case Nothing of x@~(Just w) -> x
15:50:37 <lambdabot>  Parse error in pattern
15:50:37 * xerox launches linux and chets
15:50:44 <oerjan> > case Nothing of x@(~Just w) -> x
15:50:44 <lambdabot>  Parse error in pattern
15:50:51 <oerjan> > case Nothing of x@(~(Just w)) -> x
15:50:53 <lambdabot>  Nothing
15:50:54 <conal> ivant: yhc?
15:50:58 <oerjan> bah
15:51:40 <oerjan> i'll just use fromJust
15:52:03 <ivant> conal, I think so. But it was very slow when they just created it
15:52:19 <xerox> conal: there's --enable-mozilla and --enable-firefox in the configure, but it seems to be the other way around, they enable a widget with mozilla/firefox html display capabilities. Nevermind.
15:52:34 <hpaste>  oerjan annotated "can we improve this?" with "Another simplification" at http://hpaste.org/2436#a6
15:53:19 <conal> xerox: mozilla-based html rendering in a widget?
15:54:05 <xerox> conal: yeah
16:01:27 <conal> xerox: neat.  mozembed allows some event interception.  http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-MozEmbed.html .  i don't see any way to mess with the html from there.
16:01:28 <lambdabot> http://tinyurl.com/32gemt
16:21:06 <shapr> @seen earthy
16:21:07 <lambdabot> earthy is in #haskell. I don't know when earthy last spoke.
16:21:11 <shapr> aww
16:23:09 <fasta> shapr: don't you experience space leaks in HApps?
16:23:43 <shapr> There are some space leaks in HAppS, yes.
16:24:10 <fasta> shapr: how do you find them?
16:24:12 <shapr> fasta: Lemmih found and fixed some, probably not all. Have you seen something specific that we could improve?
16:24:47 <shapr> Anyone interested in getting the Hamming on Hamming videos, join #haskell-blah.
16:24:53 <ivant> :-)
16:24:55 <fasta> shapr: no, I was thinking of finding advice how to find my huge space leaks, as the profiling tools don't work.
16:25:10 <shapr> fasta: Profiling tools don't work for what?
16:26:06 <Igloo> hamming as in error correction?
16:26:12 <shapr> Yeah, that guy.
16:26:23 <fasta> shapr: they are rather buggy
16:26:34 <shapr> fasta: Got any specifics?
16:26:55 <fasta> shapr: -hc generates compiler symbols
16:27:04 <fasta> shapr: -hd generates compiler symbols
16:27:22 <sorear> fasta: I've got a three page transcript; shall I upload it to an unguessable URL and pm it to shapr?
16:27:53 <fasta> sorear: ok
16:32:00 <ivant> oh, 18 hours
16:32:06 <ivant> and counting
16:33:28 <hpaste>  twanvl annotated "can we improve this?" with "There is a generic problem here (getting off topic)" at http://hpaste.org/2436#a7
16:37:36 <tonfa> it there a way to create a type like [Word8] of length 20 ?
16:37:40 <bwx> is it ever a good idea to run quickcheck for several hours? or does that mean that something is horribly wrong with my tests?
16:38:22 <oerjan> it should only run a fixed number of tests
16:38:52 <bwx> yeah, but i'm boosting up the count in order for it to detect rare corner cases
16:39:18 <oerjan> perhaps look at smallcheck?
16:39:39 <oerjan> it's exhaustive up to a given size, i think
16:39:57 <fasta> bwx: depends on the nature of your tests
16:41:19 <ddarius> bwx: Do you know what these corner cases are, or are you hoping quickcheck will discover some?
16:41:39 <bwx> i've deliberately introduced a bug into my code, and quickcheck only finds it after 373 tests, and when i tweaked a param to make it more subtle, then quickcheck only found it after 46154 tests
16:41:51 <xerox> tonfa: yes, a bunch of ways are explaned here <http://okmij.org/ftp/Haskell/number-parameterized-types.html>
16:42:35 <tonfa> xerox: many thanks
16:42:51 <tonfa> btw it's sad that the haskell.org doc doesn't have more google juice
16:42:54 <hpaste>  conal annotated "can we improve this?" with "Applicative & variations" at http://hpaste.org/2436#a8
16:43:07 <fasta> bwx: I had tests that triggered only after >200,000 tests
16:43:31 <fasta> bwx: I think small check is more efficient, but they both have their uses for non-monadic code.
16:43:40 <pjd> bwx: proof that we need proofs
16:44:34 <newsham> it is called "quick check"
16:45:41 <fasta> pjd: right
16:46:28 <Maddas> newsham: that's testing, not proving :)
16:46:38 <fasta> I would like that for GHC the proof that forall compiler generated symbols, none of them is shown to me.
16:46:53 <newsham> its true
16:56:22 <shapr> bwx: Are you using QuickCheck 2.0 ? It produces much better tests.
16:56:39 <bwx> shapr: i'm not sure, i'm using whatever came with ghc 6.6
16:57:25 <shapr> bwx: In that case, darcs get http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
16:57:29 <lambdabot> Title: Index of /QuickCheck
17:02:31 <tonfa> hum
17:03:39 * thoughtpolice just got done reading the yi paper and making his irc bot hot-swappable :)
17:04:18 <lambdabot> o/~ Don't you wish your IRC bot was hot like me... o/~
17:04:23 <ddarius> thoughtpolice: Using hs-plugins?
17:04:28 <newsham> ?farber
17:04:28 <lambdabot> Unknown command, try @list
17:04:48 <thoughtpolice> ddarius: yeah. i don't know though, since 6.8 is coming out soon, I might try and opt for using the ghc api
17:04:57 <thoughtpolice> since i've been experimenting with it lately
17:06:04 <ddarius> You could kill two birds with one stone and try to present GHC-API with an hs-plugins interface if that would be worthwhile.
17:06:13 <fasta> Is the continuation monad by any change a known source of space leaks?
17:06:18 <fasta> chance*
17:06:19 <thoughtpolice> but right now this is working pretty good. all the actual plugging-based code is fairly contained
17:06:21 <bwx> ddarius: i think dons is planning on doing that anyway
17:06:27 <ddarius> I do too.
17:06:37 <thoughtpolice> so swapping one for the other should be somewhat painless
17:06:46 <Pseudonym> fasta: I don't think so.
17:06:47 <ddarius> But I'm sure he wouldn't mind if someone else did it for him.
17:06:47 <thoughtpolice> although it'll take a little more experimenting with the GHC API
17:07:00 <Pseudonym> Though I've certainly written CPS code that leaks if I wasn't careful.
17:07:04 <thoughtpolice> ddarius: you mean basically a wrapper around the ghc api?
17:07:08 <Pseudonym> I suppose it depends how you use it.
17:07:13 <ddarius> thoughtpolice: Yes.
17:07:52 <thoughtpolice> ddarius: I've actually been thinking about that. when I started reworking my bot I realized the code was somewhat hard to deal with so I started rewriting for an v0.3. when I decided on doing that,
17:08:11 <thoughtpolice> I figured wrapping the ghc api in a thin manner would probably be a good way to do it, once I got the code off the ground a little.
17:08:42 <fasta> Pseudonym: I do millions of operations in the continuation monad and with every operation it seems to want more.
17:08:45 <fasta> Pseudonym: (memory)
17:08:59 <thoughtpolice> ddarius: it would definately be useful, though. if I give it a go hopefully the results will be usable by others ;)
17:09:10 <bwx> i found a few things missing in ghc api, like a way to get a list of all available packages, and a way to get a list of all the modules that a specific package exposes
17:09:16 <fasta> Pseudonym: and since the source doesn't contain any strictness annotations, I would think it contains space leaks.
17:09:26 <Pseudonym> fasta: All I can suggest is do space profiling.
17:09:38 <Pseudonym> If you're doing millions of operations, you should be able to see it
17:09:44 <fasta> Pseudonym: I can quickly reply that I get compiler generated symbol.s
17:09:58 <fasta> Pseudonym: in short: the tools are worthless
17:10:16 <ddarius> The goggles, they do nozzink!
17:10:40 <fasta> I think I will just eliminate the continuation monad and see whether it makes any difference.
17:10:40 <conal> dons told me recently that he won't have much time to work on a new hs-plugins.  i'd really love to see someone pick up on that project, as i need it for Eros.
17:11:07 <thoughtpolice> bwx: looking at my package.conf, it looks like some of that code could be cribbed from cabal. would be useful in a wrapper.
17:11:30 <thoughtpolice> conal: yes he's said the same, he's not working too hard on keeping hs-plugins recent.
17:11:53 <conal> thoughtpolice: broken on windows! :(
17:12:20 <thoughtpolice> conal: yes I noticed so. :(
17:12:42 <conal> please let me know how it goes.  btw, will you be at Hac II?
17:12:52 <shapr> I think everybody needs hs-plugins for something.
17:13:03 <thoughtpolice> conal: me? no.
17:13:23 <bwx> thoughtpolice: well, "ghc-pkg list" command works, and also "ghc-pkg describe time"
17:13:25 <thoughtpolice> shapr: yes, it seems just upon mentioning it a wrapper would be more useful to people than I originally though. :)
17:13:36 <shapr> I'd like to use hs-plugins too.
17:13:50 <conal> shapr: what for?
17:14:11 <shapr> I've forgotten at the moment.. but I have a bunch of ideas...
17:14:24 <conal> thoughtpolice: what's your bot?
17:14:34 <thoughtpolice> i'm going to have to find some projects to keep my sanity when school starts on monday. so maybe a wrapper would be a good project.
17:14:35 <shapr> Oh, I'd like to use it for HAppS plugins, that's for sure.
17:14:45 <conal> i'm curious about what people might do with hs-plugins.
17:14:47 <shapr> thoughtpolice: What school?
17:14:48 <thoughtpolice> conal: it's just a small irc bot.
17:14:54 <thoughtpolice> shapr: high school. last year, too.
17:15:08 <shapr> I can see why you need a sanity inducing project.
17:15:12 <conal> !
17:15:13 <shapr> I hate high school with a passion.
17:15:17 <thoughtpolice> conal: the 0.1 used hs-plugins just for, well, actual plugins.
17:15:40 <Pseudonym> I'm one of the few who didn't mind high school
17:15:45 <Pseudonym> Mind you, it wasn't a US public school.
17:15:51 <Pseudonym> THat helps, I suspect.
17:15:55 <thoughtpolice> like I said, in the midst of working on 0.2, I kind of realized the code was a little too hard to work with and it wasn't realizing what I wanted, so i just took what was still usable (very little) and started on 0.3.
17:16:34 <thoughtpolice> shapr: quite agreed. btw, I remember you saying happs 0.9 would be released soon, I actually installed 0.8.8 today, should I've waited perhaps? :)
17:16:45 <shapr> thoughtpolice: Yeah, 0.9.1 was sort of released yesterday.
17:17:09 <shapr> Sort of meaning that it has a few bugs, and I'd like to fix those before doing a full on announcement.
17:17:37 <thoughtpolice> fair enough. :) also, the happs.org homepage is missing a lot of stuff it seems (tarballs and docs and the like)
17:17:52 <shapr> Yeah, it requires darcs to download at the moment.
17:18:04 <shapr> And there aren't docs so much, but HAppS-Begin is a demo app.
17:18:43 <bwx> happs seems to be fully documented with haddock
17:18:49 <conal> shapr: i still haven't used happs.  can it chat with client-side js code?
17:19:01 <shapr> conal: Hm, it could, yeah.
17:19:24 <shapr> But you'd probably want to hack the syb-with-class xml deriving code to do JSON for that.
17:20:13 <conal> shapr: sure.  i've been waiting for some inspiration about a web app with interesting server & client communication.
17:20:22 <bparkis> wow the recent article on image resizing on slashdot is very cool, check out the google video
17:20:38 <bparkis> it's eerie how well it appears to work
17:20:50 <conal> shapr: also, is happs suitable for real-time multi-user interaction (IRC etc)?
17:21:00 <shapr> conal: What about a version of hpaste that talks to lambdabot's eval plugin? Multiple users could visit an hpaste page with the pasted code loaded into eval.
17:21:08 <shapr> conal: Yeah, I think so.
17:21:33 <conal> shapr: neat idea.
17:21:47 <bparkis> http://www.youtube.com/watch?v=vIFCV2spKtg
17:21:54 <bparkis> oh not a google video, youtube video
17:22:33 <conal> i've been noodling over a chat room with downloadable interactive graphics.  especially if the graphics could interact with each other.
17:22:57 <thoughtpolice> bparkis: the internet scares me. :(
17:22:59 <shapr> Or, what about using http://www.bluishcoder.co.nz/2007/08/svg-video-demo.html to do an online pan?
17:23:00 <lambdabot> Title: Bluish Coder: SVG Video Demo
17:23:04 <bwx> conal: i'm working on a haskell web framework designed for "real time multi user interaction"
17:23:20 <conal> bwx: yeah?  cool.  tell me more
17:23:56 <bwx> conal: http://darcs.mutantlemon.com/tanius/README
17:24:10 <bwx> conal: you can also checkout the darcs repository, and compile the chat example
17:24:12 <dansa`> What does (a -> b -> b) -> b mean?
17:24:15 <conal> bwx: thanks.  oh yeah.  i tried it once.
17:24:32 <shapr> bwx: That's cool.
17:24:45 <metaperl> dansa`: a function which takes args of type a and b and returns value of type b is passed in and a value of type b is returned overall
17:24:46 <conal> shapr: for online pan, svg would be terribly restrictive.  simple graphics.  no real interaction.  have you seen pajama?
17:25:22 <metaperl> dansa`: my_func two_arg_function = b
17:25:25 <metaperl> is a possible implementation
17:25:28 <shapr> I've seen the page, but I don't run flash or java in my browser.
17:25:41 <conal> shapr: :P
17:25:47 <dansa`> metaperl: i don't get your first sentence very well
17:25:56 <metaperl> dansa`: ok....
17:26:00 <shapr> hiya metaperl, ltns!
17:26:10 <dansa`> returns value of type b (...) the rest seems not to fit in the sentence
17:26:12 <metaperl> shapr: true, true. good to see thou against
17:26:24 <metaperl> @hoogle (a -> b -> b)
17:26:25 <lambdabot> Prelude.const :: a -> b -> a
17:26:25 <lambdabot> Prelude.seq :: a -> b -> b
17:26:25 <lambdabot> Control.Parallel.par :: a -> b -> b
17:26:44 <metaperl> what is the type signature for length
17:26:46 <metaperl> how do I get that
17:26:51 <metaperl> i'm trying to help dansa` out
17:26:52 <shapr> :t length
17:26:54 <lambdabot> forall a. [a] -> Int
17:27:13 <dansa`> right, shapr answered
17:27:13 <conal> shapr: not even flash?
17:27:23 <oerjan> @djinn (a -> b -> b) -> b
17:27:23 <lambdabot> -- f cannot be realized.
17:27:24 <shapr> conal: I'm using a 64bit linux system.
17:27:32 <metaperl> ok dansa` let's say you had a function which took an integer and a character and returned the ascii successor of that character. what type signature would that have?
17:27:46 <shapr> And I'd rather not use closed source non-standard stuff if at all possible.
17:28:01 <shapr> Admittedly, Java no longer fits into that category.
17:28:04 * shapr installs the java plugin
17:28:04 <dansa`> :: Integer -> Char -> Char
17:28:29 <metaperl> dansa`: good. so let's call that a -> b -> b
17:28:32 <conal> shapr: i'm watching the svg video demo.  cool.
17:28:36 <dansa`> okay
17:28:40 <bwx> quickcheck finally found an error case after 761389 tests :O
17:28:41 <metaperl> and let's call that function char_succ
17:28:45 <dansa`> okay
17:28:54 <metaperl> ok
17:29:17 <conal> anyone know how fast ActionScript 3 is?  compared with Java speed?
17:29:28 <metaperl> so if my_func took that function as an argument and returned a character, then it's signature would be (a -> b -> b) -> b
17:29:36 <bwx> probably up to 100 times slower
17:29:40 <metaperl> because the signature of char_succ is a -> b -> b
17:29:56 <dansa`> right
17:30:01 <shapr> bwx: Is that with QC 2.0?
17:30:04 <metaperl> that seems like a weird type signature... where did you get it?
17:30:09 <bwx> shapr: no
17:30:12 <dansa`> from winhugs
17:30:12 <metaperl> @hoogle (a -> b -> b) -> b
17:30:13 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
17:30:13 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
17:30:13 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
17:30:15 <conal> i don't know of any reasonably fast client-side computation engine other than java.
17:30:23 <dansa`> and from paul hudak's book
17:30:43 <bwx> conal: we need a haskell browser plugin =)
17:30:44 <dansa`> :t foldl
17:30:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:30:53 <dansa`> i thought it should be:
17:31:04 <dansa`> forall a b. (a -> a -> a) -> [a] -> a
17:31:11 <dansa`> i mean, remove the b from the forall :)
17:31:12 <sorear> TAL ftw
17:31:30 <metaperl> I dont know... I just happened to be in this channel... I'm doing J these days
17:31:51 <dansa`> but even accepting that there may be something more general (and hence the b), I still dont get why after (...) we need -> a
17:32:23 <conal> bwx: or a haskell plugin-generator.  i don't what a haskell plugin would be.  oh -- maybe a meta-plugin that wraps hs-plugins/ghc-api.
17:32:23 <oerjan> > foldl (\n c -> 10*n + digitToInt c) 0 "123"
17:32:25 <lambdabot>  123
17:32:43 <oerjan> dansa`: ^^ example that a /= b
17:33:03 <dansa`> oerjan: i'm sorry?
17:33:29 <conal> bmx: so, how is Tanius going?
17:33:47 <oerjan> :t \n c -> 10*n + digitToInt c
17:33:49 <lambdabot> Int -> Char -> Int
17:33:54 <oerjan> > foldl (\n c -> 10*n + digitToInt c) 0 "123"
17:33:56 <lambdabot>  123
17:33:59 <thoughtpolice> what main advantages does QC 2.0 give?
17:34:06 <bwx> conal: going good. i'm working on a real world application using it
17:34:15 <thoughtpolice> does it generate better tests, for the most part? or is there something else to go with that.
17:34:30 <oerjan> so in this case we use foldl :: (Int -> Char -> Int) -> Int -> [Char] -> Int
17:34:40 <dansa`> oerjan: i think you're trying to tell me something in haskell lingo, but i barely understand anything basics of it
17:34:50 <dansa`> any of the basics of it
17:35:18 <conal> bwx: i tried out your chat room a while back.  is that your app, or another?  something with non-text media?
17:35:37 <thoughtpolice> dansa`: the last -> a tells you what the resulting type of the expression is.
17:35:51 <dansa`> thoughtpolice: that's true... i think i just saw what's going on
17:36:02 <dansa`> the () is the function-argument
17:36:07 <thoughtpolice> dansa`: you'll find after little experimentation types say a lot
17:36:12 <Mat^> my first 60KB of haskell code now creates intermediate code and has typechecker, sorry for spamming, I am just so happy :P
17:36:19 <bwx> conal: my app has chat included in it, but it is much bigger then that
17:36:41 <bwx> conal: btw, i am also thinking of adding a "realtime reddit" example to Tanius
17:37:17 <bwx> ... where stories and comments fade in immediately as they are posted, and you can also interact with other people who are online
17:37:20 <dansa`> the next argument (after (...)) is the init value and the next is the list to be operated on and the last thing is the return value of fold; i think i get it now.
17:37:31 <dansa`> the init value is used when the list is empty []
17:37:37 <conal> bwx: way cool :)
17:37:48 <dansa`> that's what i call the init value
17:37:59 <oerjan> dansa`: actually it is always used to start with
17:38:08 <dansa`> oerjan: it what?
17:38:42 <oerjan> you always start with the init value, even if the list is non-empty
17:39:02 <oerjan> (unless you use foldl1)
17:39:43 <dansa`> well, the way hudak writes the function seems to be the last thing used (that is, after traversing the whole list, [] is passed) and then the init value is used
17:39:59 <dansa`> shall i write how he writes?
17:40:19 <oerjan> if it is short
17:40:38 <dansa`> fold op init [] = init
17:40:38 <dansa`> fold op init (x : xs) = x `op` fold op init xs
17:41:03 <oerjan> dansa`: that's foldr not foldl
17:41:38 <dansa`> foldl is written in the same way regarding the use of init
17:42:00 <sjanssen> not so:
17:42:03 <sjanssen> @src foldl
17:42:03 <lambdabot> foldl f z xs = lgo z xs
17:42:03 <lambdabot>     where lgo z []     =  z
17:42:03 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:42:11 <sjanssen> erm, not very clear
17:42:38 <sjanssen> foldl f z (x:xs) = foldl f (f z x) xs
17:42:49 <sjanssen> foldl f z [] = z
17:42:52 <ddarius> That's bizarre.  Why have f in the lexical scope but not z?
17:43:04 <ddarius> Oh nevermind.
17:43:12 * ddarius wasn't looking properly.
17:43:38 <bwx> time to sleep
17:44:04 <conal> bwx: sweet dreams.  please let me know when you have a demo ready.
17:44:07 <oerjan> dansa`: in foldl, the init is changed by the recursion, so the init that is applied with [] is not actually the real initial one
17:44:33 <oerjan> unless the list was empty from the start
17:44:59 <bwx> conal: sure thing. later all
17:45:01 <oerjan> with foldr, however, the same init is passed through all levels
17:48:05 <dansa`> oerjan: that's correct; i see what you were saying now
17:48:18 <dansa`> i mean: i now see what you were saying then :)
17:48:46 <oerjan> fine :)
17:56:09 <hpaste>  jan annotated "mo' lambdabot woes" with "xx" at http://hpaste.org/30#a1
17:58:18 <shapr> Who's building lambdabot?
17:58:59 <thoughtpolice> last night my lambdabot fell ill :(
17:59:38 <ddarius> 30?
17:59:46 <shapr> 30 what?
18:00:17 <ddarius> http://hpaste.org/30
18:00:58 <ddarius> Some kind of bizarre spam?
18:01:36 <kpreid> random scribbler
18:18:59 <phobes> What does lgo stand for / mean?
18:19:26 <sorear> @go lgo
18:19:29 <lambdabot> http://www.lgo.org.uk/
18:19:29 <lambdabot> Title: The Local Government Ombudsman
18:19:54 <phobes> sorear: in the definition of fold :)
18:19:59 <phobes> foldl ^^
18:21:30 <oerjan> local gensym, obfuscated
18:23:18 <oerjan> least guessable option
18:23:40 <phobes> @src foldr
18:23:40 <lambdabot> foldr k z xs = go xs
18:23:40 <lambdabot>     where go []     = z
18:23:40 <lambdabot>           go (y:ys) = y `k` go ys
18:23:51 <phobes> L apparently stands for left
18:37:23 <keturn> I'm working through YAHT, and am having a bit of trouble getting data type definitions.   I have '''data Quadruple a1 a2 b1 b2 = Quad a1 a2 b1 b2; Quad :: a -> a -> b -> b -> Quadruple a a b b''' but ghc claims Invalid Type Signature.
18:38:30 <dolio> Quad :: a1 -> a2 -> b1 -> b2 -> Quadruple a1 a2 b1 b2
18:38:31 <ddarius> keturn: You can't give data constructors type signatures (they don't need them).
18:38:52 <dolio> They're automatically deduced from the data declaration.
18:39:12 <ddarius> They aren't deduced, they're specified by the data declaration.
18:39:26 <dolio> Well, yeah, that's a better word. :)
18:45:03 <keturn> ok, so "data Quadruple a a1 b b1 = Quad a a b b" appears to be what I wanted.  But it's taking me a while to grok this...  I guess the parameter names in the constructor definition (right hand side) must appear in the data type definition (left hand side),
18:45:11 <keturn> but not all the names on the left must appear on the right?
18:45:33 <oerjan> right, those that don't are called phantom types
18:46:30 <keturn> or perhaps "must appear in the left hand side _or_ otherwise be in scope (e.g. Int)"
18:46:35 <sorear> yes.
18:47:05 <oerjan> well Int is a type constructor, while a and b are type variables.
18:47:24 <sorear> there isn't really a difference in this context
18:47:27 <chessguy> @hoogle Int
18:47:31 <lambdabot> Data.Int :: module
18:47:31 <lambdabot> Prelude.Int :: data Int
18:47:31 <lambdabot> Text.Read.Int :: Integer -> Lexeme
18:47:53 <sorear> keturn: what language(s) are you familiar with?
18:48:14 <keturn> sorear: most familiar with C and Python
18:50:31 <keturn> and the names I use for those type variables, they only appear in that one line (and hence the documentation or whatever), but I needn't use those names when pattern matching or anything.
18:55:29 <dons> ?users
18:55:29 <lambdabot> Maximum users seen in #haskell: 385, currently: 351 (91.2%), active: 7 (2.0%)
18:55:50 <phobes> hmmm, I recall seeing 409 I thought, just the other day
18:56:00 <phobes> this lambdabot hasn't been around very long I guess
18:56:08 <dons> yeah, 419. there was a lambdabot crash, and it lost that state
19:00:01 <nicodaemos> Does anyone know how to tell haddock to use the docs on haskell.org for any missing names?
19:01:21 <thoughtpolice> my lambdabot is still quite sick. :(
19:01:24 <thoughtpolice> can't imagine why
19:06:04 <nicodaemos> Did I ask a dumb question or is noone else generating docs using haddock and having problems?
19:07:08 <dons> nicodaemos: oh, i don't think many people bother trying to link to haskell.org docs
19:07:12 <dons> its a good idea though
19:07:59 <nicodaemos> maybe I'm not doing the right thing, please educate me.  I'm generating some docs on some of my code.
19:08:48 <nicodaemos> And my installation might be a bit messed up as it can't find many names like Int, Binary, etc.
19:09:45 <nicodaemos> It generates docs on my code just fine ... it just can't find docs for all the dependencies ... I thought I could just say go to haskell.org to resolve all them.  ;-)
19:10:22 <thoughtpolice> that would definately be useful just to link to the online docs. :)
19:11:45 <nicodaemos> I'm not a fan of Java the language, but they did handle this part well with the JavaDoc tool.  You could just point it to a URL or two to find any missing dep docs and it would handle it.
19:12:17 <phobes> GADTs seem to be 1) a strict generalization of phantom types, and 2) alot less quirky syntax-wise...   are those statements both fair?
19:13:09 <mrd> sure
19:13:19 <thoughtpolice> seems good enough
19:14:37 <thoughtpolice> nicodaemos: perhaps a patch to haddock is in order? :)
19:16:11 <ddarius> phobes: Some early GADT like proposals were called "first class phantom types"
19:16:18 <ddarius> @google first class phantom types
19:16:21 <lambdabot> http://techreports.library.cornell.edu:8081/Dienst/UI/1.0/Display/cul.cis/TR2003-1901
19:16:21 <lambdabot> Title: First-Class Phantom Types
19:16:26 <bens> nicodaemos: there's a --html-location=URL option for runhaskell Setup.lhs haddock. I haven't been able to make it work right though.
19:16:53 <phobes> ddarius: So is it possible that the old phantom types would be phased out in a later Haskell version?
19:17:29 <SamB> phobes: it seems impossible
19:17:49 <phobes> Haskell doesn't seem to have one type system, so much as dozens of little type systems
19:17:52 <SamB> though the old type syntax could concievably be phased out
19:18:17 <thoughtpolice> i don't know how you could 'phase out' phantom types.
19:18:20 <conal> phobes: phantom types are an idiom rather than a language feature.
19:18:38 <dolio> They're also a strict generalization of existential types.
19:18:53 <dolio> At least, the Haskell/GHC sort.
19:19:02 <phobes> conal:  Hmm.... maybe I don't understand how they work then
19:19:29 <thoughtpolice> phobes: well, in the basic sense when you have something like data ABC a = XYZ, a is a phantom type already.
19:19:31 <phobes> ok nm, I see how they work
19:19:32 <nicodaemos> thoughtpolice: my Haskell-fu is still not very strong but this might be a good learning experience.
19:19:34 <SamB> phobes: though some apparantly didn't think they were legal when they were first introduced
19:19:44 <thoughtpolice> nicodaemos: quite so. :)
19:19:45 <phobes> I misunderstood what was happening on one of the examples
19:20:38 <ihope> That sort of phantom type is useful for keeping type safety in a hetero... uh, mixed list.
19:20:49 <phobes> ok, retract everything I just said about phantom types ... they fit in nicely with the type system
19:21:03 <nicodaemos> bens: thanks for the suggestion, I was hoping to slowly build up to defining Cabal packages for my stuff.  Maybe its time to dig into the haddock source.
19:21:11 <maskd> has anyone managed to build X11-1.2.2 on a bsd system? i get this error: http://hpaste.org/2429 (and upgrading cabal didn't fix it)
19:23:18 <thoughtpolice> maskd: probably dons. i would try it out on my obsd box but it's down right now and I don't even think I have x11 itself installed.
19:29:37 * shapr boings
19:32:38 * thoughtpolice blings
19:32:46 <ddarius> Crap
19:33:32 <SamB> dons: we seriously need profile images :-(
19:34:23 <ddarius> I guess I will get to see the quality difference between the DivX and MPEG versions.
19:35:07 <ricky_clarkson> ddarius: sicp?
19:35:12 <ddarius> Yes.
19:35:20 <ricky_clarkson> I find the 256k MPEGs ok, the 64K unwatchable.
19:35:40 <ricky_clarkson> And I find wget -c very useful.
19:35:56 <ddarius> I only bothered with the 256k, but it seems only the first four seem to have those versions on archive.org
19:36:04 <ricky_clarkson> No, the rest do too.
19:36:17 <ricky_clarkson> Click on the bit at the left that says HTTP under the animated gif.
19:36:32 <ricky_clarkson> I'm up to 5b or 6a.
19:36:44 <ddarius> Ah, they hide them for some reason.
19:36:55 <ricky_clarkson> Lack of nous, most likely.
19:42:00 <ddarius> The MPEG version seems noticeable better.
19:42:20 <ddarius> I'm not sure if it's worth the time or space though.
19:43:07 <ricky_clarkson> Do you mean DIVX?
19:43:27 <ddarius> No, the MPEG2 versions.
19:52:07 <ricky_clarkson> The mpegs are smaller, I don't understand.
19:52:16 <ricky_clarkson> Unless you're comparing it to the PDF of the book, of course.
19:53:00 <ddarius> ricky_clarkson: What are you talking about?
19:53:14 <ricky_clarkson> The download formats for sicp.
19:53:17 * ricky_clarkson blinks.
19:54:47 <ddarius> On the actual SICP lectures page the DivX versions are about 1/3rd to 1/2 the size.  On archive.org, the mp4==DivX are about 1/10th the size.
19:58:53 <Olathe> How do I do a bitwise XOR ?
19:59:03 <sorear> `xor`
19:59:16 <sorear> @hoogle xor
19:59:16 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
19:59:30 <sorear> > 69 `xor` 105 :: Int
19:59:31 <lambdabot>  44
19:59:39 <Olathe> Thanks.
20:05:06 <Olathe> Where's a listing of what basic functions (like replicateM, concat, nubBy, etc.) exist and what they mean ?
20:05:47 <ddarius> @google zvon haskell reference
20:05:49 <lambdabot> http://www.zvon.org/other/haskell/Outputglobal/index.html
20:05:49 <lambdabot> Title: Haskell
20:07:34 <Olathe> Thanks.
20:07:50 <ddarius> It's not comprehensive.
20:09:09 <ddarius> This http://www.haskell.org/ghc/docs/latest/html/libraries/index.html is comprehensive, but more terse in places.
20:13:14 <hpaste>  keturn pasted "YAHT Exercise 4.6, 4.7, attempt 1" at http://hpaste.org/2438
20:13:31 <keturn> ok...  I'm butchering this here.  What am I missing?
20:15:07 <ddarius> keturn: It all looks right to me except you don't have a "case" for the 4-tuple in your Either ... type.
20:15:33 <keturn> ddarius: seriously?  that's how it's _supposed_ to look?
20:15:52 <ddarius> keturn: It's a pointless exercise.
20:18:55 <ddarius> There are ways of making the 4.6 exercise code shorter.
20:21:06 <keturn> I hoped there were.   Any pointers?
20:21:21 <ddarius> It's not really pretty and vaguely hacky.
20:23:48 <shapr> @users
20:23:48 <lambdabot> Maximum users seen in #haskell: 385, currently: 347 (90.1%), active: 9 (2.6%)
20:24:00 <dons> hey shapr
20:24:03 <shapr> hiya!
20:25:03 <pjd> i think the honorable thing to do would be to generate it with a Perl script
20:25:37 <ddarius> pjd: Heck, TH can easily do it before you go that route. Lord.
20:26:01 <keturn> oh, hey, there are solutions in the back of the book
20:26:12 <pjd> ddarius: but that doesn't show the proper level of respect to the problem
20:26:39 <ddarius> keturn: The solution it provides is unlikely to be the shortest version ((or) the version I'm thinking of.)
20:28:17 <dons> ivant: are you Ivan Tarasov? (if so, thanks for the xmonda AWt info!)
20:29:02 <ddarius>  /whois ivant
20:30:01 <dons> ircname  : Ivan Tarasov
20:30:02 <dons> :)
20:30:53 <keturn> but the thing that's troubling me is ...  why do I have to pattern match on each stupid constructor, when they're all (supposedly) constructing the same Type?
20:31:25 <dons> in general, you mean?
20:31:34 * idnar waves to pjd
20:31:39 <keturn> yeah.
20:32:06 <dons> constructors are run time tags for different values of some type
20:32:06 <ddarius> keturn: How else would you expect to do it?
20:32:29 <dons> so, unless you want to treat all constructors of a type the same way, you need to match those tags to dispatch to different behaviour
20:32:38 <dons> case x of Just x -> x ; Nothing -> 1
20:32:42 <SamB> if you do want to treat 'em all the same
20:32:53 <SamB> you might as well forget about the type, too ;-P
20:33:34 <dons> keturn: the yaht example is sort of a degenerate case to teach pattern matching and algebraic data types
20:33:40 <pjd> keturn: generally you *want* to match on each constructor because they each mean something useful
20:33:43 <dons> typically you don't write code  like that, but it explains the concepts
20:33:53 <pjd> which is not the case in this artificial example
20:34:16 <SamB> would perhaps have been better to pick a toy exaple rather than an artificial one?
20:34:34 <ddarius> To illustrate, for a binary tree you have data Tree a = Leaf a | Branch (Tree a) (Tree a) and you certainly want to handle leafs and branches differently in pretty much all cases.
20:34:36 <dons> matching the empty list is a simple example of why it matters
20:35:20 <keturn> so why are there even type variables on the left hand side, when they can only be accessed through a particular constructor?
20:35:40 <ddarius> keturn: Huh?
20:35:40 <keturn> (lhs of a data type definition)
20:36:21 <keturn> why not "data Tree = Leaf a | Branch (Tree)"?  oh.  I guess it's because it is a "tree of a's."
20:37:34 <pjd> yeah;  the a after Leaf would be unbound
20:37:59 <maskd> dons: have you managed to build X11-1.2.2 on a bsd system? i'm getting this error: http://hpaste.org/2429
20:38:54 <keturn> ...this is going to take a while longer to sink in.
20:39:43 <dons> maskd: yeah, on openbsd
20:39:51 <dons> maskd: edit the .buildinfo file and remove the -R flag
20:39:55 <dons> its a cabal bug i think
20:41:27 <maskd> now it says 'Shared object "libX11.so.6" not found'
20:43:24 <pjd> maskd: is your libX11.so actually in /usr/X11R6/lib ?
20:43:43 <pjd> or in /usr/local/lib ?
20:44:09 <maskd> it's in /usr/X11R6/lib
20:52:38 <sjanssen> maskd: xmonad users hit this issue often http://xmonad.org/faq.html#x11
20:52:40 <lambdabot> Title: xmonad : frequently asked questions
20:54:19 <maskd> yeah, i did that, but it didn't work
20:55:45 <sjanssen> maskd: you added "extra-lib-dirs: /usr/X11R6/lib" to the X11.buildinfo?
20:58:15 <maskd> no, only X11.cabal
20:58:48 <maskd> adding it to X11.buildinfo didn't work either
21:01:16 <dons> maskd: removing the -R from the buildinfo after configure-- did you try that?
21:02:00 <maskd> yes
21:07:33 <Figs> oh, how I love abusing operators... http://rafb.net/p/gulgnN47.html
21:07:35 <lambdabot> Title: Nopaste - "Project Greenspun"
21:07:55 <Figs> not *really* lisp, but it looks funny :)
21:08:09 <Figs> I thought you guys might like a nice joke :)
21:23:12 <nornagon> Figs: that's evil
21:24:27 <Figs> thank you ^_^
21:26:16 <desp> dons: ping
21:26:50 <desp> are repeated lazy bytestring appends efficient? or should I use Binary.Put?
21:28:19 <desp> append appears to be listed as O(n); I presume that should probably be O(n/c) -- the length of the spine
21:28:27 <sjanssen> desp: which direction are you appending?
21:28:51 <sjanssen> repeated "shortstring ++ longstring" should be fine
21:28:57 <desp> sjanssen: appending to the tail
21:29:04 <sjanssen> but "longstring ++ someotherstring" is bad
21:29:13 <desp> sjanssen: bytestrings.
21:29:18 <sjanssen> the rules are pretty much like lists
21:29:33 <desp> ah. ok
21:29:36 <sjanssen> desp: right, ++ means Data.ByteString.Lazy.append
21:29:42 <desp> it does? ok :)
21:29:52 <sjanssen> I'm just being lazy :)'
21:29:59 <desp> ;)
21:30:40 <sjanssen> like lists, but with a better constant factor
21:30:59 <desp> right
21:41:20 <dons> desp: yeah, its n/k
21:46:48 <desp> dons: does create reallocate the resulting ByteString?
21:47:15 <desp> dons: I'm simply copying data from the C side, like this:
21:47:16 <desp> s <- create (fromIntegral n) (\dp -> memcpy dp sp n >> return ())
21:47:39 <desp> should I use unsafeCreate to save on the realloc?
21:57:51 <FMota> Alright, now here's another philosophical question that is not at all pertinent to haskell, but is encompassed in the wide range of topics spoken in #haskell...
21:58:33 <FMota> Would a language have to be able to distinguish between a type and elements of that type in order to be considered dependently typed?
22:00:15 <FMota> What I mean by this is, in this language, Nat stands for all the natural number, not for the type "Nat".
22:00:48 <FMota> ?users
22:00:48 <lambdabot> Maximum users seen in #haskell: 385, currently: 338 (87.8%), active: 3 (0.9%)
22:01:55 <FMota> :/
22:03:43 <ddarius> FMota: No.
22:03:59 <FMota> ty.
22:04:05 <FMota> I didn't think so either.
22:10:13 <dolio> "Ralf replied that in generic programming, values depend on types whereas in a dependent type system, types depend on values."
22:10:53 <FMota> :)
22:11:05 <dolio> That being where the 'dependent' comes from.
22:11:18 <FMota> makes sense
22:11:22 <dolio> Types depending on types is parametric polymorphism.
22:11:33 <dolio> Values depending on values is... every programming language with functions?
22:12:12 <FMota> the thing with this language is that there is a very blurry distinction between types and values.
22:12:41 <FMota> "types" are just multiple values
22:13:14 <dolio> You can look at types that way in other languages, too.
22:13:24 <dolio> The type T is the set of all values in T.
22:14:53 <FMota> yep
22:16:16 <sorear> dolio: You just reinvented the λ-cube.
22:16:36 <sorear> @google lambda calculi with types barendregt
22:16:40 <dolio> sorear: Well, I didn't. I'm just parroting something I read somewhere.
22:16:40 <lambdabot> http://citeseer.ist.psu.edu/barendregt92lambda.html
22:16:40 <lambdabot> Title: Lambda Calculi with Types - Barendregt (ResearchIndex)
22:16:44 <dolio> :)
22:17:50 <FMota> :o How did you make the lambda sign? I'm jealous.
22:19:18 <sorear> Control-shift-3BB
22:19:39 <mdmkolbe3> Earlier today someone mentioned that there was a thread on haskell-cafe about a state monad where the state chagnes type.  Anybody got a link to that?  Or summary of the result?  (I've come up with a solution, but I want to see if someone else already proposed it.)
22:19:39 <SamB> sorear: what libs?
22:19:46 <SamB> what apps?
22:19:49 <sorear> SamB: urxvt
22:19:57 <sorear> SamB: the manpage says it's an ISO standard
22:20:07 <sorear> SamB: but I've yet to see another implementation :(
22:20:20 <SamB> I think the ISO standard is a bit vague on the two keys used to initiate it?
22:20:25 <SamB> maybe not too vague
22:20:30 <FMota> hmm
22:20:34 <FMota> doesnt work on my imac
22:20:43 <SamB> but I looked at some of the pages and it didn't seem too clear
22:20:44 <FMota> (Colloquy)
22:20:46 <sorear> @go david roundy restricted monads
22:20:48 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg18848.html
22:20:48 <lambdabot> Title: [Haskell-cafe] rebinding >>= for restricted monads
22:21:00 <SamB> they used like a snowflake for the control part or something...
22:21:13 <sorear> @go david roundy restricted monads site:haskell.org
22:21:14 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020709.html
22:21:15 <lambdabot> Title: [Haskell-cafe] AT solution: rebinding >>= for restricted monads
22:21:46 <desp> " Could not find module `Data.Binary.Builder': it is a member of package binary-0.3, which is hidden"
22:21:47 <SamB> sorear: mail-archive is cooler than pipermail...
22:21:52 <desp> why does that happen?
22:22:10 <sorear> SamB: it also doesn't bind
22:22:16 <sorear> s/bind/connect/
22:22:28 <sorear> desp: you forgot to include binary in your cabal file
22:22:35 <desp> sorear: ah, thank
22:22:36 <desp> s
22:22:51 <sorear> mdmkolbe3: anyways, see that thread, especially the reply by malcolmw
22:23:23 <shapr> sorear: Do you know if anyone has tried to do the shootout with JHC?
22:23:37 <sorear> shapr: Nope, but we've done nobench
22:23:41 <mdmkolbe3> thx, WitnessMonad looks like exactly the solution I was thinking of.
22:24:02 <shapr> jhc isn't self hosting yet, right?
22:24:16 <sorear> shapr: it can't even handle all of nobench imaginary ;)
22:24:44 <sorear> and it takes 700MB to compile the Prelude
22:26:04 <shapr> @where nobench
22:26:05 <lambdabot> I know nothing about nobench.
22:26:13 <shapr> Is there a darcs repo for nobench?
22:26:40 <shapr> aha
22:26:56 <shapr> @where+ nobench http://www.cse.unsw.edu.au/~dons/nobench.html
22:26:56 <lambdabot> Done.
22:28:50 <shapr> Whoa, nobench was executed on that sixteen cpu box?
22:29:12 <sorear> shapr: note that at one point nobench compared haskell implementations (ghc, ghci, hugs, yhc, nhc, jhc-grin, jhc-ghc, ghc-6.7, ghc-fasm)
22:29:18 <sorear> shapr: yes :)
22:29:24 <sorear> shapr: it IS for benchmarks
22:29:38 <shapr> Wow, spiffy. Did ghc get +RTS -N16 ?
22:29:51 <sorear> shapr: we should petition dons to run real nobench again, this fusion stuff is getting boring
22:30:07 <sorear> shapr: doubt it, dons said the point was amd64 performance
22:30:14 <sorear> :)
22:30:28 <sorear> note that my replies are out-of-order and interleaved
22:30:57 <SamB> sorear: just like execution!
22:31:23 <SamB> fortunately none of them read memory others write to
22:32:54 <shapr> sorear: Is a there TODO list for jhc?
22:33:22 <SamB> dons: you should benchmark compile times
22:33:22 <sorear> shapr: Yes, but it seems to be called JohnMeacham_
22:33:34 <shapr> hah
22:33:54 <SamB> he said he had some bugs in his new stuff to work out
22:33:58 <SamB> or something like that
22:34:12 <SamB> but he's almost got JHC going with vastly reduced requirements
22:34:41 <shapr> I wonder if it's close to self-hosting.
22:34:44 <shapr> That would be very spiffy.
22:34:54 <FMota> what's JHC?
22:35:06 <FMota> I mean, hows it different from GHc?
22:35:10 <SamB> one TODO item is to get JHC and the FFI spec to agree about foreign export wrappers ;-P
22:35:10 <FMota> Java?
22:35:15 <SamB> FMota: JohnMeacham_
22:35:23 <FMota> oh
22:35:29 <shapr> FMota: Nah John's HaskellCompiler.
22:35:31 <pjd> FMota: http://repetae.net/john/computer/jhc/jhc.html
22:35:32 <lambdabot> Title: Jhc
22:35:41 <shapr> FMota: It uses GRIN for one thing, that's way different.
22:35:42 <FMota> ty
22:35:46 <SamB> and it uses E
22:35:58 <shapr> @go urban boquist grin thesis
22:36:00 <SamB> which is based on a Pure Type System thingy
22:36:01 <lambdabot> http://www.cs.chalmers.se/~boquist/phd/
22:36:01 <lambdabot> Title: Abstract
22:36:17 <shapr> That thesis is lots of fun to read, though I still have one big outstanding question about it...
22:36:18 <SamB> and at the moment it also uses a gread deal of RAM and CPU time
22:36:21 <FMota> :o
22:36:31 <SamB> er. great.
22:36:41 <shapr> FMota: On the good side, once that great deal of ram and cpu is used, the resulting program is *tiny*
22:36:47 <SamB> apparantly the former is almost fixed
22:36:56 <shapr> In fact, I ran some of the resulting programs on my Nokia 770.
22:37:01 <SamB> to some extent or other
22:37:14 <FMota> :o
22:37:15 <FMota> nice
22:37:18 <SamB> I want to use it to write some IEEE conversion routines in C ;-P
22:37:35 <FMota> I like the idea of doing as much as possible at compile time
22:37:37 <SamB> IEEE floating point, that is
22:37:46 <shapr> I'd like to add a native code generator to JHC.
22:39:33 * shapr tries to build nobench with jhc
22:41:02 <SamB> somebody should look at those "output errors" with hugs
22:43:12 <SamB> what's calander do, I wonder...
22:43:22 <shapr> sloccount says that jhc is 45kloc.
22:43:28 <SamB> nhc98 seems to have whooped GHC's ass on it
22:43:56 <SamB> ... and ghci has whooped GHC's ass too, though not quite as much
22:44:28 <SamB> the more you optimize it the slower it goes?
22:44:38 <FMota> :/ You know what sucks about building your own language? You have to make a compiler or an interpreter for it before you can start self-hosting it.
22:44:57 <SamB> you know what sucks more?
22:45:03 <SamB> you have to write a compiler in *it*
22:45:26 <FMota> heh. That's the part to look forward to
22:45:50 <FMota> assuming your language is easy to compile and to make compilers from, of course
22:45:56 <SamB> maybe you could write a comiler in a relate language and translate it
22:46:05 <SamB> *related
22:46:22 <SamB> *compiler, too
22:46:23 <FMota> oh cr*p, I used a preposition at the end of a fragment. :/
22:46:33 <FMota> (or whatever its called)
22:46:41 <FMota> I suppose
22:46:41 <SamB> FMota: heh, this ain't no stinkin' english class
22:46:47 <FMota> I could write the compiler in Haskell
22:47:03 <FMota> but I don't know enough Haskell
22:47:43 <FMota> I do know enough C to at least make a bare-bones interpreter
22:48:02 <FMota> (e.g. the interpreter wouldn't have to check for correctness)
22:53:35 <shapr> cool, I built the bernouilli program for nobench.
22:53:38 <shapr> Sure did take a long time.
23:41:05 <paolino> being a Functor si teh intersection between a Monad and a Comonad ?
23:42:16 * paolino  woke up with this in the mind :P
23:52:29 <dons> ?users
23:52:29 <lambdabot> Maximum users seen in #haskell: 385, currently: 331 (86.0%), active: 3 (0.9%)
23:53:38 <desp> boing
23:54:39 <paolino> :i Comonad
23:56:59 <paolino> mmhh .there is no Comonad definition in the base
