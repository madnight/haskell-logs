00:00:15 <sorear> luqui: well, haskell won't write it for you
00:01:00 <hpaste>  glguy annotated "expr example" with "now with spaces and parens" at http://hpaste.org/2106#a2
00:01:05 <wli> reffie: The thing actually checks for errors so it may not be the swiftest.
00:07:39 <wli> glguy: The space handling isn't completely there...
00:07:49 <glguy> wli: oh? which did I miss?
00:08:07 <wli> glguy: I'm fishing for it.
00:08:23 <wli> glguy: "1 + 2*3" seems to break it.
00:08:34 <glguy> wli: not on mine..
00:08:39 <glguy> wli: maybe use a later paste?
00:10:19 <wli> glguy: Well, I've edited MiniCalc.lhs in-place.
00:10:46 <glguy> and my challenge is to figure out why it doesn't work i that context? :)
00:11:08 <glguy> , [ Infix ('+' `is` (+)) AssocLeft , Infix ('-' `is` (-)) AssocLeft
00:11:12 <glguy>  is c f = char c >> return f
00:11:16 <glguy> I was playing with that
00:11:22 <wli> "1+ 2*3" breaks but "1 +2*3" doesn't.
00:11:28 <glguy> I don't know if that affects readability in a positive way or not :)
00:11:36 <glguy> interesting..
00:11:45 <glguy> now it broke on mine
00:11:46 <glguy> good
00:11:48 <glguy> easier to isolate
00:12:12 <wli> glguy: parseAdd = char '+' >> spaces >> return (+) fixes.
00:13:04 <glguy> ah
00:13:23 <glguy> that makes sense then, since at the innermost level, I don't wrap in spaces again
00:13:30 <glguy> I only do that as the math expr level
00:13:35 <glguy> which odesn't get repeated
00:13:37 <glguy> without ( ) s
00:13:50 <wli> glguy: The parens need to eat spaces, too.
00:14:17 <glguy> maybe between spaces spaces needs to be moved into the toplevel of sub_expr =
00:14:27 <wli> between (char '(' >> spaces) (char ')' >> spaces) math_expr <|> fmap read (many digit)
00:14:51 <wli> I'm not sure the first of those two is necessary; I think things only need to eat suffixes.
00:15:32 <glguy>   sub_expr = between spaces spaces $
00:15:32 <glguy>               between (char '(') (char ')') math_expr
00:15:32 <glguy>               <|> number
00:16:12 <wli> spaceWrap p = between spaces spaces ; char' = spaceWrap . char ; etc.
00:16:33 <glguy> if you spacewrap just sub_expr, it seems to do just fine
00:17:12 <hpaste>  glguy annotated "expr example" with "updated space wrap" at http://hpaste.org/2106#a3
00:19:27 <wli> glguy: Maybe that was it.
00:20:56 <glguy> You don't have to like Parsec any more than before, but hopefully that makes it more bearable :)
00:22:40 <wli> It helps some.
00:27:37 <glguy> wli: liftM csCounter get     is  gets csCounter
00:28:06 <wli> glguy: Thanks.
00:28:17 <glguy> let me know if I get annoying, I won't be offended
00:28:22 <glguy> I know that I will often go to far
00:28:50 <glguy> liftM Foldable.toList $ gets csHistory   is gets (Foldable.toList . csHistory)
00:29:01 <wli> glguy: Not at all. This sort of idiomatic thing is what I'm looking for.
00:35:48 <glguy> wli: are you using a thread list because this application is going to go parallel?
00:36:30 <wli> glguy: No, it's because that's how signals are supposed to be handled according to some haddock stuff I would have to dig for.
00:36:46 <glguy> oh, ok
00:36:55 <glguy> I'll admit I haven't done much with signals in Haskell
00:37:15 <wli> glguy: The way the test is supposed to work is that I substitute readline or myHomeBrewReadLine for getLine
00:37:58 <glguy> when is a case that the threadList would change though?
00:38:02 <glguy> that's what I was trying to understand
00:38:20 <glguy> or that the synchronization would be needed
00:38:22 <wli> glguy: Presumably if/when other IO slaves get involved.
00:38:27 <glguy> ok
00:38:57 <glguy> also, what is the significance of putChar '\LF' before putStrLn?
00:39:05 <glguy> does that have something to do with buffering?
00:40:01 <wli> glguy: Well, if I don't move to a new line, the message starts in the middle of wherever the user left the cursor in the line with garbage before it instead of on a line by itself.
00:40:25 <glguy> wli: I meant rather than:   putStrLn $ "\LF
00:40:26 <glguy> err
00:40:30 <glguy> " ++ name ++ ...
00:40:53 <glguy> also the use of \LF over \n
00:40:58 <wli> glguy: Just to make it stand out that there was a newline getting shoved in there.
00:41:03 <glguy> ok, cool
00:41:53 <wli> glguy: '\LF' was chosen to match the escape sequences emitted by various things.
00:42:25 <wli> glguy: Although the C forms seem to be coming out in ghci when I try it now.
00:42:33 * reffie notes his raytracer is progressing well: http://kaede.iichan.net/cg/src/1186471629272.png
00:42:58 <wli> reffie: Did my mkMatrix code help at all?
00:43:19 <reffie> wli i realized i could just bypass the list and build the array directly
00:44:31 * glguy actually had the occasion to use mapAndUnzipM at work :)
00:44:51 <wli> glguy: It looks like only certain escape sequences use the mnemonics.
00:44:57 <wli> > show '\^['
00:44:59 <lambdabot>  "'\\ESC'"
00:45:27 <wli> > show '\^@'
00:45:28 <lambdabot>  "'\\NUL'"
00:46:02 <wli> glguy: I want it to match show output, so it goes to C.
00:47:16 <glguy> > show '\LF'
00:47:17 <lambdabot>  "'\\n'"
00:47:26 <wli> glguy: The main thing here is the precise formatting behavior when SIGINT happens.
00:48:03 <glguy> wli: withMVar_ with obviate the need for return ()
00:48:27 <glguy> hmm...
00:48:30 <glguy> maybe that doesn't exist
00:48:49 <glguy> oh well :)
00:49:29 <glguy> OH, but the return value of mapM_ is passed through
00:49:33 <glguy> so the return () still isn't needed :)
00:52:44 <osfameron> moin
00:52:45 <glguy> wli: you ought to consider making: "$1 + 2" parsable
00:52:50 <glguy> or does that work and I'm missing something
00:53:25 <glguy> eval would just need access to history
00:53:35 <wli> glguy: Planned for later. And it has access to history.
00:53:50 <glguy> Â‰execCmd does, but not eval... right?
00:54:14 <wli> glguy: Oh, woops, eval is pure. It can be fixed.
00:54:23 <glguy> or passed as a parameter
00:54:55 <glguy> to avoid having to liftM2 (operators) (eval l) (eval r)
00:54:58 <glguy> all over
00:56:13 <wli> I don't see the harm in a little lifting.
00:56:30 <glguy> then its settled ;)
00:57:05 <osfameron> is it possibly, purely functionally, to have a variable that refers to another variable that in return refers back to it?
00:57:18 <glguy> yup
00:57:18 <osfameron> e.g. a cyclic thing
00:57:24 <glguy> lets play:
00:57:24 <wli> osfameron: Mutual recursion is easily possible.
00:57:44 <osfameron> I was struggling with this yesterday (in Perl) and the easiest way seemed to be to evade the PF thing completely and just update in place with the new reference...
00:57:49 <osfameron> how is it done?
00:58:05 <glguy> > let evns = 0 : map succ ods ; ods = map succ evns in (take 5 evns, take 5 ods)
00:58:13 <lambdabot>  ([0,2,4,6,8],[1,3,5,7,9])
00:58:37 <glguy> I guess that i didn't need to obfuscate that since evens and odds aren't in scope... ever
00:58:59 <osfameron> eeeeek!
00:59:17 <glguy> osfameron: meet laziness
00:59:23 <glguy> laziness, osfameron
00:59:32 <osfameron> pleased to meet you, laziness
00:59:37 <sorear> glguy: even if they were!  haskell is lexically scoped!
00:59:51 <glguy> sorear: I try to avoid shadowing, nonetheless ;)
01:00:17 <osfameron> but lets say you're making a doubly linked list (I was playing with a zipper tree, but as I didn't understand that, let's try a simpler example :-)
01:00:24 <osfameron> how do you get the two nodes to refer to each other ?
01:00:54 <glguy> osfameron: the doubly linked list example is often called "tying the knot" at least on the haskell wiki
01:01:10 <wli> Is there a (!!) that returns Maybe?
01:01:20 * osfameron looks at http://www.haskell.org/haskellwiki/Tying_the_Knot thanks
01:01:21 <lambdabot> Title: Tying the Knot - HaskellWiki
01:01:22 <glguy> http://www.haskell.org/haskellwiki/Tying_the_Knot
01:01:23 <lambdabot> Title: Tying the Knot - HaskellWiki
01:01:26 <glguy> yeah, that :)
01:01:29 <osfameron> :D
01:01:29 <sorear> wli: Yes, but it isn't named
01:01:40 <wli> sorear: IOW not in the libs?
01:01:56 <wli> (I can easily implement it.)
01:01:59 <sorear> yeah.
01:02:30 <osfameron> oh dear, examples and no descriptions..
01:02:32 <apfelmus> wli: it's called "flip lookup" :)
01:02:45 <osfameron> I'll have to come back to it when I'm not pretending to be at work (*cough*)
01:02:54 <glguy> > xs !!! n = listToMaybe (drop n xs)
01:02:54 <lambdabot>  Parse error
01:03:04 <glguy> > xs !!! n = listToMaybe (drop n xs) in [2,2,5,3] !!! 3
01:03:04 <lambdabot>  Parse error
01:03:19 <glguy> > let xs !!! n = listToMaybe (drop n xs) in [2,2,5,3] !!! 3
01:03:20 <lambdabot>  Just 3
01:03:23 <glguy> > let xs !!! n = listToMaybe (drop n xs) in [2,2,5,3] !!! 10
01:03:25 <lambdabot>  Nothing
01:03:27 <glguy> :)
01:03:37 <int-e> > let xs !!! n = listToMaybe (drop n xs) in [2,2,5,3] !!! (-1)
01:03:38 <lambdabot>  Just 2
01:03:47 <glguy> int-e: whose side are you one??
01:03:49 <glguy> on*
01:04:19 <glguy> > let xs !!! n = guard (n >= 0) >> listToMaybe (drop n xs) in [2,2,5,3] !!! -2
01:04:20 <lambdabot>      precedence parsing error
01:04:20 <lambdabot>         cannot mix `(!!!)' [infixl 9] and prefi...
01:04:28 <glguy> well... whatever :)
01:04:41 <glguy> its only going to get uglier
01:04:48 <reffie> ghc sure is slow
01:05:04 <glguy> [] !! -1
01:05:07 <glguy> > [] !! -1
01:05:08 <lambdabot>      precedence parsing error
01:05:08 <lambdabot>         cannot mix `(!!)' [infixl 9] and prefix...
01:05:14 <glguy> > [] !! (-1)
01:05:15 <lambdabot>  Exception: Prelude.(!!): negative index
01:05:37 <glguy> > let xs !!! n = guard (n >= 0) >> listToMaybe (drop n xs) in [2,2,5,3] !!! (-2) -- didn't realize that was the problem
01:05:38 <lambdabot>  Nothing
01:06:32 * glguy thinks that drop (negative number) should *put the elements back*
01:06:46 <int-e> sure :)
01:06:47 <dolio> It's no fun if it doesn't use unsafePerformIO.
01:08:00 <glguy> int-e: do you think it was an accident that drop can take a negative argument, but !! can't?
01:08:17 <glguy> not so much that !! can't
01:08:20 <glguy> but that drop does
01:08:42 <int-e> glguy: I doubt it - drop also works on the other end of the spectrum (dropping more elements than the list has)
01:08:49 <glguy> or taking more
01:09:01 <glguy> since those two are paired up
01:09:46 <glguy> osfameron: you there?
01:10:11 <Korollary> I never liked drop
01:10:32 <osfameron> glguy: hi, in and out :-)
01:10:47 <glguy> if you think that tying the knot is cool, look around for some uses of mfix/mdo
01:11:29 <glguy> one case that I used that recently was in a function that does monadic parsing / rewriting of wiki text
01:11:37 <osfameron> the name "mfix" implies it's a) related to monads and b) related to fix... the combination of which might make my head explode
01:11:44 <glguy> it returns image names with then are converted
01:11:46 <glguy> and passed back in
01:12:08 <glguy> but both activities are monadic
01:12:10 <osfameron> I'll have to work through tying the knot in my copious free time, I've saved the examples to look at later
01:13:05 <int-e> > map (take 4) $ mfix (\x -> [[],1:x,2:x]) -- hmm
01:13:05 <glguy> there are other ways to accomplish that, but that was how it fit best in that instance
01:13:06 <lambdabot>  [[],[1,1,1,1],[2,2,2,2]]
01:14:07 <Korollary> @src mfix
01:14:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:14:14 <glguy> the parallel to mfix and OO I saw was that you can work with an object in a constructor in C++ before it has finished constructing
01:14:26 <glguy> x <- buildWidget a b c x
01:15:31 <Korollary> actually you can't do that in C++
01:15:45 <glguy> in C++ it is done all inside the constructor
01:15:53 <glguy> you can do it in Haskell all inside as well I guess
01:15:56 <Korollary> no virtual calls in constructors, tho
01:15:57 <glguy> this wasn't my example :-p
01:16:00 <glguy> ah
01:17:07 <glguy> did you see the placement `new` post to reddit?
01:17:24 <Korollary> Yes.
01:17:30 <wli> glguy: refresh ;)
01:17:40 <glguy> I feel like I missed out when I used to use C++
01:17:50 <Korollary> I don't think so.
01:17:51 <glguy> so much I didn't know :)
01:18:12 <glguy> wli: poking about
01:18:18 <dolio> Cue qwe1234 rant on the evils of garbage collection.
01:18:21 <Korollary> The C++ hackery involving corners of C++ tend to be not worth much.
01:18:44 <osfameron> they say that the C++ template system is lovely and sophisticated if you really grok it
01:19:09 <glguy> wli: what is the difference in spaces and optional spaces?
01:19:10 <Korollary> It's powerful. Lovely wouldn't be my choice.
01:19:14 <glguy> spaces = many isSpace
01:19:21 <wli> glguy: I'm not sure there is one.
01:19:21 <glguy> many is 0 or more
01:20:09 <wli> glguy: Yeah, I just needed spaceWrap in enough places.
01:20:46 <glguy> wli: since the white space is never relevent... maybe you could just filter it all out at the beginning :)
01:20:57 <glguy> oh
01:20:58 <glguy> nvm
01:21:02 <glguy> then:  1 2 + 3 is 15
01:21:04 <Korollary> aka tokenization?
01:21:58 <wli> glguy: There is a thought here, albeit not a coherent one.
01:22:00 <Korollary> I don't know what you're doing, but you may be interested in a lexer perhaps.
01:22:19 <glguy> wli: your drop (fromIntegral n) is genericDrop n
01:22:32 <wli> Well, I'm happy with just cramming the expression crud into the fewest lines possible.
01:24:52 <desp> glguy: hi
01:25:04 <glguy> hi
01:25:19 <desp> glguy: do you think you could give me a not-quite-spoiling hint for problem 14 (Collatz sequences)? :)
01:26:31 <desp> glguy: I've memoized the Collatz function, but it still appears to take far too long to calculate a million sequences
01:27:22 <glguy> desp: people in the forums are brute forcing it... not even using memoization
01:27:39 <desp> hm.
01:27:47 <desp> in Haskell as well?
01:28:11 <desp> perhaps I should try it in C
01:28:21 <glguy> desp: make sure that you only call the memoized functions on values less than the current one
01:28:40 <reffie> what's the difference between currying and partial function application?
01:28:52 <glguy> reffie: currying is the transformation of a function that takes a tuple
01:29:00 <glguy> into one that takes a value and returns a function
01:29:12 <glguy> partial function application is the next step
01:29:20 <glguy> where you actually apply some of the arguments
01:29:22 <glguy> to return a new function
01:29:50 <glguy> :t curry
01:29:55 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
01:30:17 <glguy> in haskell, partial application looks like this:
01:30:23 <glguy> :t (+) 1
01:30:24 <lambdabot> forall t. (Num t) => t -> t
01:30:44 <glguy> (kind of, since all functions are curried...)
01:31:04 <glguy> by default, with the f x y z = syntax
01:31:25 <reffie> how can functions that don't take a tuple be curried?
01:31:32 <glguy> they can't
01:31:47 <reffie> but you just said every function is curried
01:32:10 <opqdonut> :t let f x y = x+y in f 1
01:32:12 <lambdabot> forall t. (Num t) => t -> t
01:32:17 <opqdonut> see?
01:32:21 <glguy> all I meant that is in say C++, you define functions:  f(x,y,z)
01:32:30 <glguy> haskell, you can just say: f x y z
01:32:33 <reffie> opqdonut yes, i understand what partial application is
01:32:42 <reffie> but i always thought it was the same thing as currying
01:32:43 <glguy> (or you could have said, in Haskell:  f (x,y,z)
01:32:57 <reffie> or rather, i thought currying was partial application
01:33:03 <opqdonut> reffie: well currying is defining functions in a way that makes partial application possible
01:33:15 <reffie> i see
01:33:42 <reffie> basically currying creates the partially applicable functions?
01:33:54 <wli> glguy: Well, now it's doing what it's meant to do.
01:34:22 <wli> glguy: --getLine behaves as it should, and --readline does not.
01:34:38 <Cale> currying is the process of taking functions which take a tuple as a parameter (that is, functions of multiple arguments), and turning them into functions which take the first component of that tuple and return a function which takes the rest of the parameters.
01:34:59 <Cale> @type curry
01:35:00 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
01:35:01 <wli> curry f x y = f (x, y)
01:35:11 <glguy> wli: that is uncurry
01:35:16 <glguy> err
01:35:16 <wli> ergh yes
01:35:19 <Cale> No, that's curry :)
01:35:19 <glguy> lol, i'm dumb
01:35:31 <glguy> but smart enough to kno I'm dumb
01:35:34 <glguy> :)
01:35:44 <wli> I've always thought it would be handy to have e.g. curry3 f x y z = f (x, y, z)
01:35:58 <wli> Not to mention fst/snd analogues for triples.
01:36:07 <Cale> Yeah, I think that may have even been in earlier Preludes.
01:36:09 <reffie> wli yes
01:36:19 <Cale> But people don't really use triples all that much anyway.
01:36:21 <wli> I run into triples just often enough for it to be painful to live without.
01:36:35 <Cale> I suppose they do show up here and there :)
01:37:25 <glguy> :t curry3
01:37:28 <lambdabot> Not in scope: `curry3'
01:37:47 <wli> SamB wrote some tupling thing that might come in handy.
01:38:05 <wli> Basically to emulate ML-style #1, #2, #3, etc.
01:39:27 <wli> glguy: Anyway I now have MiniCalc.lhs acting as an effective demo of the readline vs. ^C issue.
01:39:46 <quicksilver> I use triples, but I normally prefer explicit pattern matching to fst-like functions
01:40:02 <quicksilver> I don't find fst makes for particularly readable code, because it doesn't remind you what it is
01:40:23 <glguy> wli: and it looks good too :)
01:40:31 <wli> Arrow analogues of first, second, (***), and (|||) might help, too.
01:41:14 <glguy> desp: I was a ble to brute force it in Haskell easily..
01:41:20 <desp> hrm
01:41:31 <glguy> emertens@lintel:~$ time ./p14
01:41:32 <wli> glguy: Probably the only clunky part is the succcessive ErrorT unwrapping of parseLine and execCmd errors.
01:41:36 <glguy> real    0m6.690s
01:41:36 <glguy> user    0m6.652s
01:41:36 <glguy> sys     0m0.140s
01:42:06 <glguy> desp: without using anything fancy
01:42:23 <wli> glguy: Oh, yeah, I wanted to pretty-print recalled expressions normalized wrt. whitespace in some way but can't be arsed to actually implement it.
01:42:30 <desp> I must be doing something quite wrong, then
01:42:52 <glguy> desp: and I just cut my time in half :)
01:42:57 <desp> heh
01:45:15 <desp> huh
01:45:41 <desp> I brute forced it using C for now, but it seems I have the wrong answer
01:45:51 <glguy> what answer?
01:46:31 <desp> ah, one sec
01:47:13 <desp> yeah, overflow bit me.
01:47:27 <desp> okay, I'll try and speed up my haskell, then
01:49:36 <glguy> memoization is the difference between 21 seconds and 6 seconds for me
01:49:38 <osfameron> is "literate haskell" really literate programming?
01:50:03 <osfameron> I thought there was also the concept of "weaving" or ordering the chunks differently depending on audience (e.g. computer vs reader)
01:50:34 <desp> my C prog goes in 0.726s
01:51:16 <glguy> default(Int) shaved seconds off mine
01:52:11 <Cale> osfameron: The order of declarations in a Haskell program doesn't matter.
01:52:53 <Cale> (So it might as well be the human-readable one)
01:52:57 <integral> Cale: 'import' statements don't need to be at the top?
01:53:07 <osfameron> Cale: good point!  so it's literate by default...
01:53:10 <Cale> Oh, I suppose those do, yes :)
01:53:17 <ivanm> and the module decleration...
01:53:19 <osfameron> and exports
01:53:21 <Cale> and the module decl
01:53:26 * integral would just like to see nested modules and multiple modules in a file
01:53:33 <Cale> But everything else can be moved around however you'd like :)
01:53:36 <osfameron> but then again, you'd tend to want those at the top of the human readable version too
01:54:01 <Cale> Yeah, there's no real reason other than that for that restriction.
01:55:46 <desp> is it possible to add to a module from multiple files?
01:55:50 <desp> like namespaces in C++
01:56:02 <wli> glguy: Okay, now it normalizes expressions in the history with respect to whitespace.
01:56:32 <wli> glguy: Ah, I know why not to preprocess it. Parse error reporting.
01:57:12 <glguy> ah
01:57:52 <mauke> desp: not really
01:58:04 <ari> desp: You can write a module that imports and re-exports several modules
01:58:17 <desp> right
01:58:19 <mauke> (this is like "using" in C++)
01:58:43 <Cale> heh, you can use the C preprocessor ;)
01:58:43 <desp> yeah, I had in mind the adding to namespaces thing
01:59:13 <ari> In fact, you can apparently just name modules in the export list
01:59:14 <desp> more clearly -- extending an already defined namespace
01:59:24 <ari> module HaskoreLoader (module HaskoreLoader, module Basics, module Performance, module HaskToMidi, module TestHaskore, module ReadMidi)
01:59:36 <quicksilver> desp: that violates the compilation model, though
01:59:49 <desp> ah
01:59:52 <osfameron> glguy: http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html  gives a bit more explanation (I don't think I will easily understand the examples on the wiki page)
01:59:54 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
01:59:59 <quicksilver> desp: the compiler believes that, if it doesn't know anything about Foo.Bar, it's sufficient to go and compile Foo/Bar.hs
02:00:08 <desp> quicksilver: I see
02:00:14 <quicksilver> desp: if you could add to modules from anywhere, it would have to go look everywhere
02:00:31 <quicksilver> I'm not particularly suggesting it's the right choice, but it is a nice simple compilation model.
02:00:33 <glguy> desp: do you care to see my haskell code?
02:00:43 <desp> glguy: sure, I'd like to
02:00:43 <glguy> before i blow it away :)
02:00:52 <desp> looking through the forums now
02:00:52 <glguy> can i /msg it?
02:00:56 <desp> yep
02:04:40 <wli> I long-since did the Collatz thing with dynamic programming.
02:06:07 <glguy> wli: anything more complicated than "if the number in question is less than the starting point, reuse the old answer" ?
02:07:31 <wli> It was a long one-liner in ghci which I think did more than that.
02:08:38 <hpaste>  desp annotated "p14" with "p14'" at http://hpaste.org/2107#a1
02:08:42 <desp> argh
02:08:45 <desp> ignore that
02:09:06 <wli> I don't seem to be able to set the line number, GRRR.
02:14:54 <wli> much better
02:16:26 <glguy> oops, looks like I'm expected to go to bed
02:16:29 <glguy> goodnight all
02:16:51 <wli> 'night
02:20:57 <matthew-_> Can I assume, that if I have a String with '\n' chars in it but no '\r' chars in it, and I'm not on a *nix, and I use putStr, that the '\n' chars will be silently converted to something sensible?
02:21:42 <quicksilver> if you didn't open your output handle in binary mode
02:21:47 <matthew-_> uh hu
02:21:48 <quicksilver> then, I believe, you can assume that
02:21:51 <matthew-_> ok
02:22:00 <quicksilver> that's the meaning of binarymode (don't translate \n)
02:22:08 <matthew-_> ahh, that makes sense then.
02:22:10 <matthew-_> thank you
02:22:53 <quicksilver> matthew-_: I don't have a non-unix like platform to test that on, though :)
02:23:21 <quicksilver> if you have 'od' you can try:  ghci -e 'putStr "\n"' | od
02:23:45 <quicksilver> for me, this demonstrates that it prints a 000012
02:23:51 <quicksilver> which is expected, since OSX thinks it's unix
02:24:33 <matthew-_> yeah, I only have linux systems here
02:24:40 <matthew-_> so I'm similarly limited!
02:24:46 <quicksilver> I have a windows PC but no ghc on it
02:24:59 <quicksilver> which sits on my desk gathering dust
02:25:04 <quicksilver> except when I need to test something in IE6
02:26:03 <osfameron> meh.  /me is far too stupid to understand any of those doubly-linked list examples
02:36:12 <Lycurgus> yous must not be a veteran haskeller then. Any experienced C programmer handles lls by second nature and C is way dumb compared to Hassell
02:36:54 <ivant> Lycurgus, Haskellblad?
02:37:12 <Lycurgus> apparently.
02:37:15 <osfameron> Lycurgus: indeed not.  But doubly linking lists seems rather trivial if done imperatively.  Create two nodes - set the reference of one to the other and vice versa-
02:37:34 <int-e> (pure) doubly linked lists are hard.
02:38:27 <mauke> and/or useless
02:38:36 <int-e> they're also not very useful I think, because you can't modify them without copying the whole list
02:39:07 <osfameron> true
02:39:35 <osfameron> I was trying to play with zippers, and for some reason I got the idea that I wanted a zipping node (rather than a thread and then a set of normal nodes)
02:39:52 <osfameron> which got me trying to have nodes pointing to each other, and then I got confused and started to cry :-)
02:40:07 <int-e> hehe
02:40:28 * int-e hands osfameron a tissue
02:40:35 <osfameron> *sniff*, thanks :-)
02:40:43 * matthew-_ hands osfameron Data.Sequence
02:40:47 <matthew-_> ;-)
02:42:09 <dons> ?bug
02:42:10 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
02:43:39 <osfameron> matthew-_: ta, that doesn't seem to be doubly linked though either ?
02:44:58 <matthew-_> osfameron: no, I was being slightly silly. It is quite fast though so it might be suitable, I don't know
02:45:06 <int-e> osfameron: why do you want to have a doubly linked list anyway?
02:45:24 <dons> http://programming.reddit.com/info/2d00g/comments
02:45:25 <lambdabot> Title: Binding Haskell to C structs (reddit.com)
02:45:25 <int-e> osfameron: Data.Sequence has pretty decent random access to 'lists'.
02:45:54 <osfameron> int-e: I wanted a node in a tree that has a Left, a Right, and possibly an Up (if it's part of a zipped traversal)
02:46:07 <osfameron> I think this was an error on my part in how to implement a Zipper, bbut that's why I wanted it.
02:46:32 <quicksilver> my understanding is that you can have zippers with lefts rights and ups
02:46:38 <quicksilver> and you don't need any double-links to do it
02:47:09 <osfameron> But the Up of a Node will have either Left or Right pointing back to Node
02:47:10 <int-e> osfameron: ah the trick with the zipper is to store the spine to the current node as a context. it's done precisely so that the circular links can be avoided
02:47:12 <xerox> osfameron: is your type the standard binary tree?
02:47:59 <osfameron> full-disclosure:  I was coding this up in Perl rather than haskell...  but in, er, fairly haskelly perl
02:48:28 <osfameron> int-e: yeah, I think I realise that now.  The "Theseus and the Minozipper" example has a separate thread context, but I think I was trying to be "clever"
02:49:12 <osfameron> but yeah, it was a red-black tree, so (Data, Left, Right, Colour)
02:50:30 <tuxplorer> I'm badly in need of a detailed HAppS study material.. I would like to see some sample realworld code and understand HAppS intricacies.. the tutorial available on happs.org is just a start point and nothing more.. someone please suggest me some good place to go and study HAppS.
02:51:31 <wolverian> hm, bitc looks like an interesting language
02:55:52 <Cale> tuxplorer: Is the source to Pass.net any good?
02:56:01 <wli> wolverian: What's interesting about it?
02:57:12 <wolverian> its goals
03:01:10 <wli> wolverian: I've never even heard of it.
03:01:29 <tuxplorer> Cale: I never heard of it before.. lemme check.. Right now, I'm just trying to understand the source of hpaste.. but thought it would be better if I would get some text which would explain parts of code descriptively, and let me understand some good practices and approaches..
03:01:38 <wli> http://holomorphy.com/~wli/MiniCalc.pdf
03:01:48 <osfameron> neither has google
03:02:14 <osfameron> ah, ok http://www.bitc-lang.org/
03:02:15 <lambdabot> Title: The BitC Programming Language
03:03:05 <dons> get ur HWN! http://sequence.complete.org/hwn/20070723
03:03:07 <lambdabot> Title: Haskell Weekly News: July 23, 2007 | The Haskell Sequence
03:03:14 <dons> oh hang on . wrong link
03:03:29 <dons> stupid new drupal
03:05:38 <dons> here! http://sequence.complete.org/hwn/20070807
03:05:39 <lambdabot> Title: Haskell Weekly News: August 07, 2007 | The Haskell Sequence
03:05:42 <quicksilver> yay1
03:05:44 <wli> dons: I've written a demonstration of the issue I have with readlien and signal handling.
03:06:14 <dons> great wli.
03:06:24 <Lycurgus> it's got some nice stuff (drupal) worth using as recovered functionality like organic groups
03:06:45 <wli> dons: http://holomorphy.com/~wli/MiniCalc.lhs
03:06:55 <dons> ask about it on the -cafe@
03:07:24 <RyanT5000> is there a type for non-unicode strings?
03:07:40 <mauke> [Word8]?
03:08:05 * wli is loath to make google-able mailing list posts.
03:08:10 <RyanT5000> oh wait, i actually need it to be 0-terminated too; i guess i'll use CString
03:08:28 <RyanT5000> (that mostly just means it can't have 0s in the middle of it)
03:09:33 <dons> RyanT5000: you want byte strings?
03:09:39 <dons> CString yeah
03:09:54 <RyanT5000> yeah; although does CString do that check at conversion-time?
03:10:20 <mauke> CString is just Ptr CChar
03:10:36 <RyanT5000> mauke: oh, right, you have to do IO to get it
03:10:41 <RyanT5000> that's not what i want
03:10:55 <RyanT5000> i want a pure string with a static guarantee that it contains no nulls
03:11:02 <RyanT5000> (and is full of Word8's)
03:11:11 <RyanT5000> i.e. something that can always be safely converted into a CString
03:11:25 <wli> "The application itself is contrived. I have no interest in extending it or making it remotely meaningful. The signal handling behavior is the content here."
03:11:27 <quicksilver> do a newtype over a String or ByteString
03:11:43 <quicksilver> depending which storage style you fancy
03:11:56 <wli> OTOH it might be good to cherrypick for skeleton code for monadic programming exercises.
03:12:08 <RyanT5000> quicksilver: yeah, i guess i'll do that
03:12:33 <RyanT5000> if you `show` a string, can it generate characters outside the range [1..255]?
03:13:05 <quicksilver> if you show it, it generates unicode escapes
03:13:11 <quicksilver> for anything big
03:13:25 <RyanT5000> quicksilver: that sounds like the right thing for my application, i think
03:14:14 <quicksilver> > show (map chr [65,0,255,256,257])
03:14:16 <lambdabot>  "\"A\\NUL\\255\\256\\257\""
03:14:18 <quicksilver> for example
03:14:34 <quicksilver> show also generates the quotes of course
03:14:38 <RyanT5000> quicksilver: yeah, i just didn't know if that was *guaranteed*
03:14:45 <RyanT5000> quicksilver: i'll just strip those ;)
03:14:54 <quicksilver> RyanT5000: and it escapes any internal quotes...
03:15:00 <quicksilver> RyanT5000: and any internal backslashes
03:15:02 <RyanT5000> quicksilver: that won't hurt anything
03:15:19 <quicksilver> I've not seen the guarantee written down
03:15:38 <quicksilver> btu I strongly suspect the output of show :: String -> String is 7-bit
03:16:06 <RyanT5000> quicksilver: i think i'll just assume it :P
03:16:46 <quicksilver> it seems to be escape character clean, too
03:17:00 <quicksilver> > show (map chr [0..33])
03:17:02 <lambdabot>  "\"\\NUL\\SOH\\STX\\ETX\\EOT\\ENQ\\ACK\\a\\b\\t\\n\\v\\f\\r\\SO\\SI\\DLE\\DC...
03:17:11 <quicksilver> chars under 32 all escaped
03:17:52 <RyanT5000> quicksilver: i'll write a quick function to try all the characters :P
03:18:09 <quicksilver> > show (map chr [0..255])
03:18:10 <lambdabot>  "\"\\NUL\\SOH\\STX\\ETX\\EOT\\ENQ\\ACK\\a\\b\\t\\n\\v\\f\\r\\SO\\SI\\DLE\\DC...
03:18:11 <quicksilver> not that hard :)
03:18:18 <RyanT5000> yep
03:18:23 <quicksilver> > show (map chr [minBound..maxBound])
03:18:24 <lambdabot>  Exception: Prelude.chr: bad argument
03:18:28 <quicksilver> if you really mean ALL
03:18:34 <quicksilver> > show (map chr [minBound .. maxBound])
03:18:35 <lambdabot>  Exception: Prelude.chr: bad argument
03:18:37 <quicksilver> that's odd
03:18:41 * quicksilver thinks
03:18:43 <quicksilver> ah!
03:18:47 <RyanT5000> > length ['\NUL'..]
03:18:48 <lambdabot>  1114112
03:18:49 <dons> your challenge this week: a shorter palindrome checker than:
03:18:51 <dons> ?let palindrome x = and [a == b | a <- take (length x `div` 2) x | b <- reverse x]
03:18:51 <lambdabot>  Parse error
03:19:02 <quicksilver> > show (['\NUL' ..])
03:19:04 <lambdabot>  "\"\\NUL\\SOH\\STX\\ETX\\EOT\\ENQ\\ACK\\a\\b\\t\\n\\v\\f\\r\\SO\\SI\\DLE\\DC...
03:19:09 <RyanT5000> dons: better challenge: palindromic palindrome detector
03:19:11 <dons> I think there must be a nice golf of this
03:19:29 <opqdonut> > min&&&max . map ord . show $ map chr [0..255]
03:19:30 <lambdabot>  (<[Char] -> [Char]>,<[Int] -> [Int]>)
03:19:45 <opqdonut> hrmm
03:19:47 <xerox> > ap (==) reverse "onaricidicirano" -- dons
03:19:48 <lambdabot>  True
03:19:49 <opqdonut> ahh
03:19:54 <opqdonut> > (min&&&max) . map ord . show $ map chr [0..255]
03:19:56 <lambdabot>  (<[Int] -> [Int]>,<[Int] -> [Int]>)
03:19:59 <opqdonut> no
03:20:09 <quicksilver> dons: what is a palindrome checker? why not palindrome x = x == reverse x ?
03:20:36 <dons> ?pl split (f,g) a = (f a, g a)
03:20:36 <lambdabot> split = uncurry (liftM2 (,))
03:20:43 <dons> quicksilver: oh, based on a blog post
03:20:55 <dons> zip the list with its second half
03:21:24 <RyanT5000> are there any palindromic haskell programs that do something?
03:21:30 <RyanT5000> (i'm not including "main=main"
03:21:31 <RyanT5000> )
03:21:35 <JBGood25> :t uncurry (&&&)
03:21:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
03:21:44 <quicksilver> RyanT5000: that's not palindromic?
03:21:51 <matthew-_> RyanT5000: bisimulation would suggest main=main doesn't do anything
03:21:55 <JBGood25> :t uncurry (***)
03:21:57 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
03:21:59 <dons> :t \(f,g) a = (f a, g a)
03:21:59 <quicksilver> RyanT5000: maybe you mean "main=niam\nniam=main' ?
03:22:01 <lambdabot> parse error on input `='
03:22:03 <dons> :t \(f,g) a -> (f a, g a)
03:22:04 <lambdabot> forall t t1 t2. (t -> t1, t -> t2) -> t -> (t1, t2)
03:22:07 <RyanT5000> quicksilver: it is, but it doesn't do anything
03:22:19 <RyanT5000> quicksilver: that was why i put that requirement in there :P
03:22:20 <xerox> > ((+2) &&& (*3)) 10
03:22:21 <lambdabot>  (12,30)
03:22:30 <quicksilver> RyanT5000: how is that palindromic?
03:22:43 <quicksilver> > "main=main" == "niam=niam"
03:22:44 <lambdabot>  False
03:22:53 <opqdonut> ahh
03:22:56 <mauke> nom nom nom
03:23:01 <RyanT5000> quicksilver: lol you're totally right :P
03:23:04 <RyanT5000> quicksilver: i was thinking in tokens
03:23:12 <RyanT5000> quicksilver: even though i did mean characters
03:23:13 <JBGood25> hey, he didn't accept my comment
03:23:17 <opqdonut> > (minimum&&&maximum) . map ord . show $ map chr [0..255]
03:23:19 <lambdabot>  (32,126)
03:23:22 <opqdonut> there
03:23:25 <opqdonut> :)
03:23:28 <quicksilver> opqdonut: :)
03:23:48 <opqdonut> mixed up min and minimum :)
03:24:02 <quicksilver> I bet you could write a palindromic haskell program which did something
03:24:05 <quicksilver> interesting challenge
03:24:24 <matthew-_> @type <<
03:24:25 <lambdabot> parse error on input `<<'
03:24:28 <matthew-_> @type (<<)
03:24:30 <lambdabot> Not in scope: `<<'
03:24:37 <matthew-_> that's gonna hurt then
03:24:52 <RyanT5000> quicksilver: i think you should write a palindromic program that checks palindromes :)
03:24:56 <matthew-_> if you have >>= and =<< then you'd really want >> and << for the palindrome
03:24:57 <RyanT5000> quicksilver: then feed it to itself
03:25:37 <quicksilver> matthew-_: well you might have to define the combinators in the program itself
03:26:02 <matthew-_> define << in terms of >> such that it's a palindrome?!
03:26:05 <quicksilver> matthew-_: however, definitions which do anything more than foo=bar seem to cause a problem
03:26:05 <RyanT5000> btw, why are there 1114112 characters?
03:26:21 <quicksilver> RyanT5000: well there aren't, exactly
03:26:28 <quicksilver> RyanT5000: but that's the size of the unicode code point
03:26:30 <mauke> > ""++ printf "%x" 1114112
03:26:31 <dcoutts> RyanT5000: that's the maximum defined by Unicode
03:26:32 <lambdabot>  "110000"
03:26:36 <RyanT5000> ah, ok
03:26:38 <matthew-_> Are we just talking that each line must be palindromic? Or all lines, concatted must be palindromic?
03:26:40 <quicksilver> RyanT5000: I beliieve there are unused chars within that range
03:26:43 <olathe> The palindromes should have a length that's palindromic, too.
03:26:46 <quicksilver> matthew-_: all lines concatted
03:26:47 <RyanT5000> matthew-_: the latter
03:26:58 <RyanT5000> matthew-_: including the '\n's
03:27:06 <matthew-_> eek. Good luck. That might be harder than the ICFP 2007
03:27:11 <quicksilver> however, given a definition of the form name=expr
03:27:14 <opqdonut> so no final \n allowed :)
03:27:19 <quicksilver> if you want it to be valid in reverse
03:27:22 <matthew-_> given you'd have to mirror '\n' with 'n/'
03:27:26 <quicksilver> then the expr has to have quite a restricted form
03:27:34 <quicksilver> matthew-_: \n is a single char :P
03:27:34 <RyanT5000> opqdonut: unless you put a beginning \n :)
03:28:06 <matthew-_> quicksilver: you mean it shouldn't still be palindromic after the program text is sent through show ?
03:28:08 <RyanT5000> matthew-_: also \ mirrors to \, not /
03:28:24 <RyanT5000> matthew-_: no, i'm talking about *bytes* of the .hs file
03:28:30 <quicksilver> matthew-_: no, it should be palindromic in hs
03:28:32 <quicksilver> matthew-_: not in show
03:28:42 <matthew-_> gah, that's not hard enough
03:29:09 <Japsu> Prelude> let pal a = a == reverse a -- a esrever == a = a lap tel
03:29:10 <Japsu> Prelude> pal "let pal a = a == reverse a -- a esrever == a = a lap tel"
03:29:10 <Japsu> True
03:29:12 <Japsu> do I win?
03:29:14 <matthew-_> no
03:29:15 <Japsu> ^____^
03:29:18 <Japsu> :<
03:29:20 <Japsu> I knew it.
03:29:27 <RyanT5000> Japsu: lol, that's a good trick :P
03:29:42 <Japsu> No, that's cheating. :)
03:29:50 <RyanT5000> Japsu: i guess the challenge needs to be revised to also say "no comments"
03:29:58 <Japsu> yeah. most certainly.
03:29:58 <Japsu> :P
03:30:07 <matthew-_> I think it should be palindromic bitwise
03:30:12 <opqdonut> :DD
03:30:17 <RyanT5000> matthew-_: lol
03:30:21 <opqdonut> or palindromic parse-tree-wise
03:30:24 <matthew-_> get your unicode out boys!
03:30:52 <RyanT5000> matthew-_: once i see your bytewise-palindromic program i'll start asking about bitwise-ones :P
03:31:21 <matthew-_> Actually, I think the heap should maintain a bitwise palindromic invariant throughout runtime
03:31:32 <RyanT5000> lol
03:35:15 <yaxu> http://yaxu.org/hello.avi # dorky 'speech' synthesis with haskell
03:35:32 <RyanT5000> > null $ filter (\o -> o < 1 || o > 255) $ map ord $ show $ ['\NUL'..]
03:35:36 <lambdabot> Terminated
03:35:40 <RyanT5000> lame
03:35:42 <RyanT5000> it's True
03:36:24 <RyanT5000> meaning that (show :: String -> String) never produces anything not valid in a CString, unless it depends on the order of the input characters
03:36:33 <RyanT5000> (which it *really* shouldn't)
03:42:49 <quicksilver> > not . any (\o -> o < 1 || o > 255) . map ord . show $ ['\NUL'..]
03:42:53 <lambdabot> Terminated
03:42:57 <quicksilver> RyanT5000: ^^ more idiomatic, although not any faster
03:43:16 <RyanT5000> ah
03:43:28 <RyanT5000> i've never had occasion to use any before
03:43:35 <RyanT5000> thanks
03:43:36 <quicksilver> @pl \o -> o < 1 || o > 255
03:43:36 <lambdabot> liftM2 (||) (< 1) (> 255)
03:43:36 <opqdonut> > not . any (\o -> o <= 32 || o >= 126) . map ord . show $ ['\NUL'..]
03:43:38 <lambdabot>  False
03:44:05 <quicksilver> opqdonut: ITYM <, not <=
03:44:13 <opqdonut> ahh
03:44:19 <xerox> > (\f x -> ((f (\f -> (f (\f x -> x)))) ((f (\f x -> x)) x))) (\f x -> ((f (\f -> (f (\f x -> x)))) ((f (\f x -> x)) x))) ()
03:44:21 <lambdabot>  ()
03:44:21 <opqdonut> > > (minimum&&&maximum) . map ord . show $ map chr ['\NUL'..]
03:44:21 <lambdabot>  Parse error
03:44:25 <opqdonut> > (minimum&&&maximum) . map ord . show $ map chr ['\NUL'..]
03:44:26 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
03:44:34 <opqdonut> > (minimum&&&maximum) . map ord . show ['\NUL'..]
03:44:35 <lambdabot>  Couldn't match expected type `a -> [Char]'
03:44:36 <opqdonut> ::whistle
03:44:42 <opqdonut> > (minimum&&&maximum) . map ord $ show ['\NUL'..]
03:44:43 <opqdonut> bah
03:44:46 <lambdabot> Terminated
03:44:50 <opqdonut> kinda embarassing these
03:45:40 <opqdonut> (*** Exception: stack overflow
03:45:43 <opqdonut> my ghci throws
03:45:53 <opqdonut> weird
03:46:58 <opqdonut> Prelude Control.Arrow Data.Char Data.List> (foldl1' min&&&foldl1' max) . map ord $ show ['\NUL'..]
03:47:02 <opqdonut> (32,126)
03:47:04 <opqdonut> as expected
03:47:08 <opqdonut> just needed a bit of strict love
03:47:16 <opqdonut> > (foldl1' min&&&foldl1' max) . map ord $ show  ['\NUL'..]
03:47:20 <lambdabot> Terminated
03:47:25 <quicksilver> it's not about strictness
03:47:32 <quicksilver> it's about dons' machien being a bit busy
03:47:41 <quicksilver> and the expression taking slightly too long
03:48:11 <RyanT5000> pah, wallclock time
03:48:28 <RyanT5000> that's pretty sweet though; we have a covert channel into dons' machine
03:48:57 <quicksilver> well he has to kill off long-running processes somehow
03:48:58 <opqdonut> quicksilver: yeah, it's just that the strict version was faster for me
03:49:01 <dons> heh
03:49:16 <dons> > (foldl1' min&&&foldl1' max) . map ord $ show  ['\NUL'..]
03:49:20 <RyanT5000> we can totally smuggle several bits per minute out of his machine if we manage to plant a cooperating program in a highlevel area in his machine
03:49:20 <lambdabot> Terminated
03:49:26 <RyanT5000> (which i'm sure he has >.>)
03:49:29 <quicksilver> dons: lambdabot compiles with -O2 anyway doesn't it?
03:49:34 <dons> > 1+2
03:49:36 <lambdabot>  3
03:49:37 <dons> -O i think
03:49:43 <dons> $ uptime
03:49:43 <dons>  20:49:11 up 10 days,  6:44,  3 users,  load average: 0.07, 0.07, 0.08
03:49:52 <dons> the machines not very loaded. but you only get 3 seconds
03:49:58 <quicksilver> should -O should be able to strictness analyse that
03:50:02 <quicksilver> should run very fast compiled
03:50:06 <quicksilver> I would have thought
03:50:13 <opqdonut> yeah
03:50:14 <opqdonut> true
03:50:37 <xerox> > (foldl1' min &&& foldl1' max) . map ord $ ['\NUL'..]
03:50:39 <lambdabot>  (0,1114111)
03:50:40 <quicksilver> it runs fairly slow in my ghci, but that's interpreted..
03:51:03 <quicksilver> > (foldl1 min &&& foldl1 max) . map ord $ ['\NUL'..]
03:51:05 <lambdabot>  (0,1114111)
03:51:08 <quicksilver> :)
03:51:20 <quicksilver> > (foldl1 min &&& foldl1 max) . map ord . show $ ['\NUL'..]
03:51:24 <lambdabot> Terminated
03:51:29 <RyanT5000> ord is  doing some weird unicode thing?
03:51:37 <quicksilver> it's not doing anything weird
03:51:41 <xerox> quicksilver: why the show?
03:51:44 <dons> it doesn't really compile to stunning code
03:51:45 <quicksilver> it's showing you the unicode code point for that char
03:51:52 <quicksilver> xerox: because that was the question we were investigating
03:51:53 <RyanT5000> oh wait, i meant show
03:51:54 <dons> foldl1 is a cased foldl' , not inlined
03:51:57 <quicksilver> xerox: "is show 7-bit clean"
03:52:31 <dons> better code from the stream lib
03:52:38 <RyanT5000> xerox: i wanted to know whether shown strings were save for conversion to CString
03:52:46 <dons> you actually get a Main.$wgo5 :: GHC.Prim.Int# -> [GHC.Base.Int] -> GHC.Prim.Int#
03:53:53 <taruti> RyanT5000: data MyType = MyType; instance Show MyType where show _ = "\0\0\0"
03:54:21 <dons> dcoutts: Data.List makes me sad. I want Data.List.Stream pretty much all the time
03:54:48 <xerox> dons: when is it going to enter GHC? During the Hackaton maybe?
03:55:04 <dons> hmm. list comprehensions need to fuse better
03:55:16 <dons> too fragile at the moment. that's the hold up
03:55:25 <dcoutts> aye
03:55:25 <dons> so if you could all agree you don't need list comprehensions to fuse
03:55:27 <dons> we could proceed
03:55:33 <dcoutts> heh heh
03:55:34 <RyanT5000> taruti: i meant "shown strings" as in "strings passed through show"
03:55:45 <taruti> ah.
03:55:47 <RyanT5000> taruti: not "all results of show"
03:55:49 <xerox> Oh I see. I think SPJ says list comp are difficult to fuse in ToH too.
03:55:51 <dons> dcoutts: Data.List could do with some INLINE pragmas
03:55:56 <quicksilver> dons: I thought the existing (pre-stream) fusions were all designed precisely to fuse list comps?
03:56:12 <dons> they have a good desugaring, foldr/build , yep.
03:56:23 <xerox> dons: list comprehensions are basically concatMaps, aren't they?
03:56:23 <dons> list comprehensions are just translated directly into build and foldr things
03:56:27 <dons> xerox: right
03:56:32 <dcoutts> dons: on what? doesn't ghc figure it out anyway based on size heuristics?
03:56:48 <quicksilver> dons: so, what's the problem? is there an incompatibility between foldr/build fusion and also having good stream fusion? do they conflict somehow?
03:56:54 <dons> dcoutts: hmm. ah, its probably the manually recursive stuff not getting inlined
03:57:28 <dcoutts> dons: you mean top-level recursive, like foldl' without a worker or something ?
03:57:33 <dons> things like foldl1
03:57:49 <xerox> ?src foldl1
03:57:49 <lambdabot> foldl1 f (x:xs) = foldl f x xs
03:57:49 <lambdabot> foldl1 _ []     = undefined
03:58:04 <dcoutts> hmm, I'd thought they were defined in wrapper/worker style
03:58:29 <dons> Main.a =
03:58:29 <dons>   case Main.eta of wild_a1eB {
03:58:29 <dons>     [] -> Data.List.lvl29 @ GHC.Base.Int;
03:58:29 <dons>     : x_a1eH xs_a1eI ->
03:58:29 <dons>       Data.List.foldl' @ GHC.Base.Int @ GHC.Base.Int GHC.Base.$s$dmmin1 x_a1eH xs_a1eI
03:58:32 <dons>   }
03:58:40 <dons> for foldl1 min
03:58:51 <dons> import Data.List.Stream, and
03:59:01 <dons> Main.$wgo5 =
03:59:01 <dons>   \ (ww_s23Y :: GHC.Prim.Int#) (w_s240 :: [GHC.Base.Int]) ->
03:59:01 <dons>     case w_s240 of wild1_a1ir {
03:59:01 <dons>       [] -> ww_s23Y;
03:59:03 <dons>       : x_a1iu xs_a1iv ->
03:59:06 <dons>         case x_a1iu of wild11_a1Vt { GHC.Base.I# y1_a1Vv ->
03:59:08 <dons>         case GHC.Prim.<=# ww_s23Y y1_a1Vv of wild2_a1Vw {
03:59:11 <dons>           GHC.Base.False -> Main.$wgo5 y1_a1Vv xs_a1iv;
03:59:13 <dons>           GHC.Base.True -> Main.$wgo5 ww_s23Y xs_a1iv
03:59:16 <dons>         }
03:59:18 <dons> kick some butt
03:59:33 <xerox> hehe
03:59:44 <dons> the min got put in the body of foldl1, and the whole thing unboxed into the user's code
04:00:04 <dons> Main.a is;
04:00:05 <dons> Main.a =
04:00:05 <dons>   case Main.eta of wild_a1ig {
04:00:05 <dons>     [] -> Data.List.Stream.errorEmptyList @ GHC.Base.Int Main.lvl3;
04:00:05 <dons>     : x0_a1io xs0_a1ip ->
04:00:08 <dons>       case x0_a1io of w_X24f { GHC.Base.I# ww_s23Y ->
04:00:10 <dons>       case Main.$wgo5 ww_s23Y xs0_a1ip of ww1_s244 { __DEFAULT ->
04:00:13 <dons>       GHC.Base.I# ww1_s244
04:00:20 <dons> so a call to wgo5, rather than foldl' $s$dmmin1
04:00:37 <dcoutts> dons: in ghc head foldl' is defined with a worker, like we do in our lib
04:00:45 <dcoutts> foldl' f z xs = lgo z xs
04:00:45 <dcoutts>     where lgo z []     = z
04:00:45 <dcoutts>           lgo z (x:xs) = let z' = f z x in z' `seq` lgo z' xs
04:01:11 <dons> so its going to call to the worker with $s$dmmin1
04:01:23 <dons> hmm, i should see which is faster..
04:01:24 <dcoutts> not if foldl' gets inlined
04:01:37 <dcoutts> since that'll generate a specialised lgo
04:01:48 <dons> which doesn't happen in ghc with Data.List
04:01:56 <dcoutts> which version are you testing?
04:02:07 <dons> 6.6.1 / Data.List versus our streams with the same compiler
04:02:07 <dcoutts> older ghc used a directly recursive foldl'
04:02:21 <vincenz> dons: !
04:02:23 <dons> yeah, not Igloo's new one
04:02:26 <vincenz> dons: @paste!
04:02:31 <dcoutts> dons: so make sure you know what source code you're comparing against
04:02:36 <dons> @slap vincenz
04:02:36 * lambdabot beats up vincenz
04:02:40 <vincenz> @slap dons
04:02:40 * lambdabot smacks dons about with a large trout
04:04:24 <dons> vincenz: you need to see core occasionally, to have something to aspire to
04:05:05 <vincenz> dons: I realize that, but we advocate using @paste for snippets and then you violate what we advocate with > 35 lines
04:05:37 <vincenz> Gotta set a good example.
04:07:29 <dons> yeah, i know. its quiet, that's the usual excuse.. but don't worry, i won't paste any more Fc at you
04:07:47 <vincenz> Thanks :)
04:07:55 <dons> i'd be happy to see other peoples badly optimised Core though
04:07:59 <dons> feel free to toss it by
04:08:05 <vincenz> Well it's interesting, just not to see your window scroll by :)
04:08:12 <xerox> How does one do multiline strings in haskell modules? Hmm.
04:08:21 <vincenz> xerox: With ++?
04:08:31 <Cale> xerox: concat :)
04:08:31 <xerox> I thought it could be done without.
04:08:32 <dons> nah, string gaps, or unlines [ x, y, z]
04:08:47 <dons> > "foo\       \ bar"
04:08:48 <lambdabot>  "foo bar"
04:08:55 <xerox> Ah, TWO \.  Thanks dons.
04:09:02 <dons> i'm one of 3 people who actually use that feature
04:09:07 <Cale> heh
04:09:16 <xerox> ^_^
04:09:21 <vincenz> One thing I've alway sdisliked about the \ approach in C is that it breaks as soon as you have a space after it.
04:09:40 <dons> that's C for you.
04:09:46 <Cale> Yeah, I don't really find it much better than applying unlines or concat to a list of strings.
04:09:47 <vincenz> dons: I've used it once for a prelude-module definition for my MiniML Compiler :)
04:09:58 <RyanT5000> c - "not whitespace dependent: except when it is"
04:10:02 <dons> Cale, there's a performance benefit with bytestring literals though :)
04:10:10 <Cale> dons: hehe :)
04:10:33 <dons> you can write packAddress "ajkd\   \sdfad"# and get an O(1) string literal in the text segment
04:10:47 <dons> should you need that
04:11:05 <dons> you know, for oh, fast web server 404 pages or something
04:11:12 <RyanT5000> lol
04:11:43 <quicksilver> dons: is it possile to make that kind of optimisation apply to concat, too?
04:11:59 <quicksilver> dons: RULES for partial evaluation :)
04:12:03 * xerox hugs dons -- I do!
04:12:23 <dons> hmm. you'd need concat to spot string literals, concat them at compile time, then a pack rule to fire
04:12:43 <vincenz> dons: That or just have a smart partial-evaluator
04:12:47 <quicksilver> yeah, I don't really understand how the pack rule works
04:12:57 <quicksilver> I'm just curious how close you can get to partial evaluation
04:13:00 <quicksilver> with the current system
04:13:05 <vincenz> Oh, nm, ,quicksilver already said so :)
04:13:21 <quicksilver> (I would note that concat for a 404 error page is still amortized O(1))
04:13:31 <quicksilver> just not O(1) on first call
04:13:54 <xerox> dons: how do you enable ".."# to parse?
04:13:57 <dons> it doesn't do the concat at compile time now
04:14:24 <dons> you want a bytestring, xerox ?
04:14:27 <xerox> Yes.
04:14:55 <matthew-_> announce: DisTract 0.2.5 released; http://www.distract.wellquite.org/
04:14:59 <lambdabot> Title: start [DisTract]
04:15:17 <dons> {-# OPTIONS -fglasgow-exts #-}
04:15:17 <dons> import Data.ByteString.Base
04:15:17 <dons> main = print $ packAddress "some \
04:15:18 <dons>                 \ thing fishy"#
04:15:28 <dcoutts> dons: packAddress isn't O(1) as it has to do strlen
04:15:28 <dons> matthew-_: cool!
04:15:36 <dons> yeah, you really want unsafePackAddress :)
04:15:44 <dons> which is kinda unsafe (so ssss dcoutts )
04:15:52 <dcoutts> :-)
04:16:05 <earthy> how kinda?
04:16:19 <dons> earthy: you need to compute the length statically, which is tedious
04:16:20 <quicksilver> a general partial evaluation framework for GHC would be cool
04:16:28 <dons> :t Data.ByteString.Base.unsafePackAddress
04:16:36 <lambdabot> Int -> GHC.Prim.Addr# -> Data.ByteString.Base.ByteString
04:16:46 <earthy> ah
04:16:55 <dons> but you do get:
04:16:56 <dons>   Data.ByteString.Base.PS
04:16:56 <dons>     "some  thing fishy" (GHC.ForeignPtr.PlainForeignPtr var#_a1b8) 0 17
04:17:01 <dons> constructed at compile time
04:17:03 <xerox> dons: OK cool, so I'm adding strict-bytestring to parsec to test :)
04:17:22 <earthy> so, that's a place where we can use TH ftw
04:17:31 <dons> musasabi used this for a big speedup in the HAppS web server
04:17:43 <dons> string literals constructed at compile time == good for web servers
04:17:49 * earthy nods
04:17:58 <dons> yeah, but no unboxed string literals in TH :|
04:18:16 <earthy> hm. that sucks
04:18:23 <dons> so you can't say unsafePackAddress $(length x) x
04:18:52 <earthy> ofcourse, the alternate approach is to simply load the strings once at inittime
04:19:00 <earthy> but that makes initialization costly
04:19:08 <dons> right, packAddress does strlen , and that's reasonably cheap.
04:19:09 <earthy> and you might not be able to evade that
04:19:21 <dons> the only place I've ever heard this was worth it was happs trying to beat apache benchmarks
04:19:23 <xerox> Do you happen to have Data.ByteString.headAndTail handy?
04:19:33 <dons> xerox: uncons?
04:19:35 <xerox> The unsafe evil fast version.
04:19:50 <dcoutts> xerox: I gave you the code for uncons the other day :-)
04:19:56 <dons> uncons s = (w2c (unsafeHead s), unsafeTail s)
04:19:57 <xerox> dcoutts: yeah for .Lazy
04:20:16 <xerox> I guess I'll change LPS to PS
04:20:19 <dons> ghc loves uncons for some reason
04:20:20 <dcoutts> xerox: oh, ok, like dons says, just use unsafeHead and unsafeTail
04:20:37 <dcoutts> there's no work that can be shared between them, unlike for .Lazy
04:20:53 <quicksilver> dons: yeah, strlen is O(n) and yet somehow still 'very cheap O(n)' :)
04:20:54 <xerox> Alright.
04:21:15 <dons> quicksilver: yeah, its literally a strlen call too
04:21:45 <quicksilver> it's hard to imagine a circumstance where the strlen time is noticeable compared to the 'copy-to-ethernet-card' time
04:22:01 <quicksilver> even with DMS
04:22:02 <quicksilver> DMA
04:24:04 <taruti> quicksilver: if it is inlined in an unsuitable fashion and not hoisted out of all loops.
04:33:19 <roconnor> @go 735 s in min
04:33:22 <lambdabot> http://www.ciao.co.uk/Indesit_IDL_735_S__6357037
04:33:22 <lambdabot> Title: Indesit IDL 735 S : Read reviews and compare prices at Ciao.co.uk
04:33:28 <roconnor> @go 735 s in minutes
04:33:29 <lambdabot> 735 seconds = 12.25 minutes
04:34:26 * wli thought the compiler was supposed to figure those things out.
04:36:04 <quicksilver> @go speed of light in furlongs per fortnight
04:36:05 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
04:36:10 <quicksilver> wli: which things?
04:36:30 <wli> quicksilver: Inlining and loop hoisting.
04:36:48 <olathe> @go Watts in kg/s
04:36:50 <lambdabot> http://www.scenta.co.uk/tcaep/maths/siunits/index.xml
04:36:54 <quicksilver> wli: yeah, it does. A pretty good job.
04:37:25 <olathe> Bah.
04:37:33 <quicksilver> olathe: I don't imagine it will do the mass-energy conversion for you
04:37:34 <olathe> @go Joules in kg
04:37:35 <lambdabot> 1 kilograms = 8.98755179 x 10^16 joules
04:37:44 <olathe> It does, but it's not too smart.
04:37:53 <olathe> I wish it did all of them.
04:39:32 <MarcWeber> I've added gtk2hs to the nix distribution system. there wasn't much trouble. Does work on linux only yet. But I still have to ask one of the defs to apply this small patch.
04:39:40 <MarcWeber> @ dcoutts
04:41:55 <dcoutts> MarcWeber: yes?
04:42:14 <hpaste>  drigz pasted "stack overflow" at http://hpaste.org/2108
04:42:21 <xpika> is there a strict version of >>=
04:42:25 <drigz> can someone help me with that stack overflow?
04:42:42 <dcoutts> MarcWeber: btw, you might want to look into doing a tool to auto-generate nix packages from cabal packages, we've got one for gentoo ebuilds, see hackport
04:42:52 <drigz> on second thoughts, it may also be because i'm not using a strict scanl - is scanl the same as foldl?
04:43:35 <dcoutts> MarcWeber: and if you try something like that for nix, it'd be helpful if you report on what cabal features are missing that'd make it easier to auto-generate nix packages
04:44:53 <quicksilver> drigz: did you try it compiled with -O2
04:46:04 <xpika> can i check if something == undefined?
04:46:29 <wli> Is there a MonadNondet class floating around somewhere?
04:46:38 <quicksilver> xpika: no, that's the halting problem :)
04:46:41 <drigz> quicksilver: still happens i'm afraid
04:46:50 <quicksilver> xpika: if you manage to do that, the world will explode
04:47:03 <quicksilver> @src scanl
04:47:04 <lambdabot> scanl f q ls = q : case ls of
04:47:04 <lambdabot>     []   -> []
04:47:04 <lambdabot>     x:xs -> scanl f (f q x) xs
04:47:25 <ari> xpika: With ChasingBottoms you can, but not always, and you shouldn't do it anyway because, as mentioned, it will make the world explode
04:48:33 <drigz> i tihnk it must be the scanl because if you remove the scanl there's no stack overflow
04:49:11 <quicksilver> as far as I can see, scanl will quite happily ignore the first 999 999 elements in the list
04:49:19 <Saizan> ?src scanr
04:49:20 <lambdabot> scanr _ q0 []     =  [q0]
04:49:20 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
04:49:20 <lambdabot>     where qs@(q:_) = scanr f q0 xs
04:49:22 <quicksilver> wel, they'll be thunks but they won't get evaluated very far
04:49:23 <drigz> and sum (take 1000000 deltas) works fine
04:49:39 <quicksilver> however the 1000000th element does contain a very big (+) expression
04:49:45 <quicksilver> which you want to strictify :(
04:50:08 <quicksilver> @src scanl'
04:50:08 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:50:28 <quicksilver> I'm not sure teh best way to do that
04:51:06 <Saizan> scanl' f !q ls = ..?
04:51:19 <drigz> replacing scanl (+) 0 deltas with map (\n -> sum (take n deltas)) [0..] works
04:51:32 <drigz> i guess you could make scanl' like that but with foldl' instead of sum
04:54:03 <Saizan> i think that just consuming your elements would be enough
04:54:05 <drigz> scanl' f q ls = map (foldl' f q) (inits ls) seems to take forever
04:55:56 <drigz> and yet scanl' f q ls = map (\n -> foldl' f q (take n ls)) [0..] works fine
04:56:00 <drigz> it's just very ugly
04:57:43 <dons> ?src scanl
04:57:44 <lambdabot> scanl f q ls = q : case ls of
04:57:44 <lambdabot>     []   -> []
04:57:44 <lambdabot>     x:xs -> scanl f (f q x) xs
04:58:17 <quicksilver> drigz: you don't want to strictify the list
04:58:24 <quicksilver> drigz: you only want to strictify the expressions in the list
04:58:30 <quicksilver> drigz: (and then, only if they're accessed
04:58:32 <dons> somethiing like:
04:58:33 <dons> scanl f !q ls = q : case ls of
04:58:33 <dons>                       []   -> []
04:58:33 <dons>                       x:xs -> scanl f (f q x) xs
04:58:34 <dons> ?
04:58:39 <vincenz> scanl'
04:58:49 <quicksilver> dons: doesn't that force all the qs?
04:58:52 <vincenz> dons: that whould do it
04:59:01 <quicksilver> dons: you only want to force qs if they are actually inspected
04:59:14 <vincenz> quicksilver: no you want to save from having really big expressions in your q's
04:59:24 <vincenz> quicksilver: for instance if f is an integer op, qs are a list of ints
04:59:28 <Saizan> quicksilver: you'll only force the qi you are accessing and the ones before
04:59:36 <vincenz> scanl (+) 1 [[1..]
04:59:36 <dons> another scanl
04:59:37 <dons> scanl f q xs0 = q : go q xs0
04:59:37 <dons>   where go q []     = []
04:59:37 <dons>         go q (x:xs) = let q' = f q x
04:59:37 <dons>                        in q' : go q' xs
04:59:40 <quicksilver> oh, you do force all the qs I see
04:59:42 <vincenz> dons: the prior was better
04:59:44 <quicksilver> they're shared anyway
04:59:50 <quicksilver> forgot that :)
04:59:56 <dons> a bit more obvious how to strictify the latter though, as the control is explicit
05:00:04 <vincenz> dons: the prior is what you want
05:00:08 <vincenz> dons: you want to force your q's
05:00:09 <quicksilver> but that's OK that they're shared because the ones you don't use get collected
05:00:11 <vincenz> up to how far you inspect em
05:00:17 <drigz> the prior one has a stack overflow
05:00:20 <vincenz> cause you'r returning q: ...
05:00:24 <drigz> *former
05:02:09 <vincenz> drigz: how's that?
05:02:38 <hpaste>  xpika pasted "help with IORef" at http://hpaste.org/2109
05:03:00 <drigz> vincenz: just copied it in and ran it?
05:03:01 <vincenz> dons: I honestly do not see the diff between the prior and the second, there's no arguments that are saved from the input except the 'f'
05:03:10 <vincenz> drigz: with whtat test case?
05:03:20 <vincenz> drigz: could you @paste a test-module?
05:03:55 * wli tries to figure out how to translate [minBound .. maxBound] from a monad comprehension into modern Haskell.
05:03:59 <vincenz> drigz: what is your test case?
05:04:18 <hpaste>  drigz annotated "stack overflow" with "test module" at http://hpaste.org/2108#a1
05:04:20 <xpika_> can catch catch undefined errors
05:04:31 <xpika_> ?
05:04:50 <Saizan> vincenz: i think dons meant that the scanl with "go" is easier to strictify, not that it was yet strict
05:04:50 <desegnis> not Prelude.catch
05:05:04 <desegnis> but Control.Exception.catch (IIRC)
05:05:16 <quicksilver> xpika_: you can, but that's realy not a sensible way to work
05:05:17 <vincenz> Saizan: right, but I fail to see in what sense it is easier to strictify
05:05:28 <wli> foldr mplus mzero $ map return [minBound .. maxBound]
05:05:43 <vincenz> drigz: thanks
05:05:51 <drigz> np
05:05:52 <Saizan> vincenz: well the accumulator is more explicit maybe?
05:05:54 <desegnis> quicksilver, well, sometimes you must
05:05:55 <MarcWeber> dcoutts: Too late. I've already written it. But I still have to test all those packages.. I've already reported that. :)
05:05:58 <vincenz> Saizan: not really
05:06:16 <drigz> the first two commented out ones work (on GHC -O2)
05:06:19 <xerox> wli: there's one Monad NonDet here http://www.haskell.org/haskellwiki/Sudoku
05:06:20 <vincenz> drigz: could it be that your stack overflow is in deltas being too lazy
05:06:20 <lambdabot> Title: Sudoku - HaskellWiki
05:06:34 <MarcWeber> dcoutts: But I don't know yet which is the best way in general. It's no trouble for nix having arbitrary combinations of ghc and libraries installed.
05:06:57 <quicksilver> desegnis: really? when 'must' you use undefined?
05:07:09 <quicksilver> desegnis: I would always throw a custom exception, if that's what I wanted to do.
05:07:09 <vincenz> drigz: I see the problem
05:07:09 <wli> xerox: I was sort of looking for something to use for monad transformer instances.
05:07:10 <drigz> vincenz: originally i thought the problem would be in deltas, but the other scanl' implementations seem to work
05:07:11 <vincenz> drigz:  you have a typo!!
05:07:16 <MarcWeber> I still wonder wether it's desirable to have name such as ghc-6.6.1-cabal-1.1.7 and the like to distinguish them
05:07:18 <vincenz> drigz: scanl' = .... scanl
05:07:20 <vincenz> no '
05:07:29 <drigz> ah :D
05:07:30 <xerox> wli: there you find NondetT.
05:07:34 <xpika_> my hpaste http://hpaste.org/2109 gives me *** Exception: Prelude.undefined
05:07:44 <desegnis> quicksilver, I meant, sometimes you must deal with code that might result into undefined
05:08:01 <wli> xerox: e.g. instance MonadNondet m => instance MonadNondet (t m) where ...
05:08:03 <xerox> Which does really look like ListT.
05:08:07 <drigz> well spotted, it works now
05:08:18 <wli> xerox: A standard API question
05:08:30 <drigz> should scanl' be in Data.List?
05:08:38 <quicksilver> desegnis: do you mean undefined, or do you mean _|_ ?
05:08:43 <drigz> since so many people say how bad foldl on its own is
05:09:18 <vincenz> what option do I need to enable bangpatterns?/
05:09:19 <Eelis> what's the closest thing i can get to a word boundary (\b in PCRE) using Parsec ?
05:09:25 <hpaste>  (anonymous) annotated "help with IORef" with "nothing to do with IORef" at http://hpaste.org/2109#a1
05:09:32 <desegnis> quicksilver, I think I really mixed these up
05:09:46 <xerox> wli: and what should MonadNondet provide?
05:09:50 <vincenz> drigz: worksk fine :)
05:09:55 <vincenz> dons: your version 1.0 works fine
05:10:11 <dcoutts> MarcWeber: did you say you had a gtk2hs patch?
05:10:27 <drigz> vincenz: -fbang-patterns
05:10:31 <wli> xerox: No idea offhand. The main thought was that if there were a standard I should write to it.
05:10:33 <vincenz> drigz: thanks
05:10:39 <drigz> although i guess you worked it out
05:10:43 <quicksilver> desegnis: 'undefined' is a keyword which (happens) to throw an expection and so (happens) to be catchable
05:10:50 <MarcWeber> dcoutts: No a nix patch
05:10:53 <quicksilver> desegnis: but this is implementation defined, and really bad code styling
05:11:01 <desegnis> quicksilver, but I think catching user errors (error "something") may be what xpika wanted
05:11:02 <quicksilver> desegnis: if you want that kind of behaviour, use a real exception.
05:11:18 <quicksilver> desegnis: right. use a real error/exception and catch that.
05:11:29 <dcoutts> MarcWeber: ah ok
05:11:31 <quicksilver> desegnis: on the other hand if you might get _|_
05:11:31 <MarcWeber> . o O I need virtualizing support :(
05:11:35 <quicksilver> well, that is a fact of life
05:11:40 <quicksilver> but you certainly can't catch it :)
05:12:06 <xerox> wli: I recently added state to a backtracking computation written in monadic style. Everythin I needed to do was going from [a] to ListT (State s) a, and using option :: (MonadPlus m) => [a] -> m a; option = msum . map return.
05:12:14 <desegnis> quicksilver, do I understand right that at least in GHC undefined throws an Exception in a similar way as error does? (except that undefined does not tell you anything about the kind of error)
05:12:34 <wli> xerox: Sounds good.
05:12:59 <quicksilver> desegnis: yes, it does
05:13:03 <hpaste>  xpika annotated "help with IORef" with "catch undefined" at http://hpaste.org/2109#a2
05:13:08 <desegnis> quicksilver, good
05:13:08 <quicksilver> desegnis: but it's a silly think to use/rely on
05:13:23 <hpaste>  (anonymous) annotated "help with IORef" with "you were catching only IO exceptions..." at http://hpaste.org/2109#a3
05:13:24 <Saizan> xpika_: you have to use Control.Exception.catch instead of Prelude.catch
05:13:52 <quicksilver> xpika_: but, don't do that
05:14:02 <quicksilver> xpika_: use 'error' or throw a real exception
05:14:17 <drigz> is there a way to make programs profile more accurately
05:14:44 <drigz> because mine doesn't run for very long and so only gets 7 ticks in
05:14:54 <drigz> and sometimes there's no easy way to make it run longer
05:15:06 <quicksilver> drigz: just put a main wrapper around it which runs it multiple times?
05:15:49 <xerox> wli: It was surprisingly good. It didn't quite work when I tried with ListT (Cont ..). :-)
05:15:57 <hpaste>  (anonymous) annotated "help with IORef" with "(no title)" at http://hpaste.org/2109#a4
05:16:21 <desegnis> quicksilver, well, I promise you never to use undefined :)
05:16:21 <desegnis> except sometimes I use it for functions that I have not yet implemented, just to see whether I got the typing right
05:16:38 <quicksilver> that's fine, yes
05:16:49 <desegnis> fine
05:16:54 <quicksilver> i's relying on the behaviour of undefined I was objecting to
05:17:07 <quicksilver> since that's what we have error/throw for
05:18:00 <roconnor> @go 204 s in minutes
05:18:01 <lambdabot> 204 seconds = 3.4 minutes
05:19:00 <drigz> quicksilver: is there an easy way to do that when your program fills up parts of lazy arrays?
05:19:10 <drigz> i guess you could rewrite it so there were all local to a function
05:19:42 <drigz> but it would be a lot harder than adding -ticktime=10
05:25:03 <ricky_clarkson> Grr, I'm trying to read Paul Sander's 1991 paper about network simulation in Haskell, and I can't manage to log in to the ACM thing.
05:26:10 <vincenz> ricky_clarkson: need to be an ACM member
05:26:13 <Cale> ricky_clarkson: Unless you've paid for an ACM account, or are at an institution which has...
05:26:42 <ricky_clarkson> Cale: I am at one, but have NFI who can tell me the details of it.
05:26:59 <ricky_clarkson> Well, I assume I am, as it's a large Uni.
05:27:39 <Cale> ricky_clarkson: At a lot of places, the library will have a proxy which you can use your ID# to log in with and then have access to ACM and other journals.
05:27:52 <eivuokko> Any Windows haskell users here that could help me to test cabal2wix-generated installers a bit?
05:28:03 <ricky_clarkson> Is there anywhere else it's available, or some possible way of knowing what I should actually type in the "Web Account:" box after having registered with a free account?
05:28:45 <matthew-_> ricky_clarkson: most places I know of that have subscriptions just use host/IP authentication, so nothing to type in
05:29:03 <ricky_clarkson> matthew-_: I'm on their network now.
05:30:52 <Cale> What was the title of the paper?
05:30:54 <vincenz> ricky_clarkson: normally if your uni has access, you need to do nothing at all
05:30:56 <ricky_clarkson> Aha, found it on the intranet site.  I still don't like that it had to be paid for.
05:31:10 <quicksilver> Cale: "Experiments in Haskell - A Network Simulation Algorithm"
05:31:11 <ricky_clarkson> vincenz: I just had to use their login link instead of going to acm.org directly.
05:31:15 <vincenz> ricky_clarkson: ah
05:31:31 <vincenz> ricky_clarkson: you're the java ricky_clarkson ?
05:32:27 <ricky_clarkson> I wear a few hats.
05:32:30 <ricky_clarkson> And headphones.
05:32:45 <vincenz> just remember your nick for some reason from a long ago past
05:33:55 <njbartlett> @seen dons
05:33:55 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 33m 59s ago.
05:34:35 <ricky_clarkson> vincenz: I'm still doing Java, but using Scheme for fun, and learning from Haskell's mistakes.
05:34:39 * ricky_clarkson ducks.
05:34:42 * vincenz nods
05:35:22 <wli> ricky_clarkson: Do tell wrt. Haskell's mistakes.
05:35:50 <dons> njbartlett: ?
05:36:15 <njbartlett> dons: Oh hi.. was just about to email you..
05:36:27 <dons> mail away :) its late here.
05:36:44 <nornagon> spj is such an adorable dork :D
05:36:49 <njbartlett> Will do, getting late here too ;-)
05:37:05 <nornagon> (watching his keynote at OSCON)
05:37:10 <wli> Hmm, how to stop an iteration once you hit mzero...
05:38:00 <quicksilver> wli: unfold? takeWhile?
05:38:06 <ricky_clarkson> wli: imnsho, Haskell mixes a type system and a language too much - I'd rather program ad hoc when I like then for code sections I want to prove, prove them.
05:38:32 <wli> quicksilver: I was hoping for something that wouldn't depend on the monad.
05:39:08 <quicksilver> wli: neither of those will depend on the monad
05:39:25 <quicksilver> wli:  but you might need to tell me a little more about what you're doing, including what 'iteration' means in this context :)
05:39:54 <wli> quicksilver: unfold insists that the monad be Maybe, takeWhile insists that the monad be [ ], so they certainly do depend on the monad.
05:40:10 <njbartlett> ricky_clarkson: So you want to shift in and out of statically type-checked code? Have you looked at Wadler's "links" language?
05:40:11 <quicksilver> you don't have to replace your monad with them
05:40:17 <quicksilver> wli: you use them inside your monad
05:40:26 <dons> the python/haskell conjecture: for every program in python, there exists a shorter encoding of the same program in haskell
05:40:26 <ricky_clarkson> njbartlett: Yes, no.
05:41:12 <wli> dons: Perhaps a Python-to-Haskell compiler that optimizes for expression size is in order?
05:41:17 <dons> we saw with RLE yesterday, then palcheck today, now def palcheck(x): return x == x[::-1]  vs palcheck = ap (==) reverse
05:41:31 <Cale> ricky_clarkson: I'm curious what sorts of code you might write where type inference isn't enough to give you something like that.
05:41:34 <xerox> :)
05:41:43 <njbartlett> ricky_clarkson: It's worth a look, although it's not really a practical thing you can use yet. He's done a lot of work on the theoretical aspects of more-statically-typed code interacting with less-statically-typed code (put that way because he regards it as a continuum rather than a binary choice)
05:41:44 <ricky_clarkson> njbartlett: links looks like a statically typed language.
05:41:49 <dons> I'm intrigued: maybe there is /no/ python program which is not shorter in haskell
05:42:32 <Cale> (Of course, inferred types are still checked, but you at least don't have to worry about them so long as they line up reasonably)
05:43:07 <wli> quicksilver: Well, right now I'm trying:
05:43:11 <ricky_clarkson> Cale: If you have two types that are virtually identical, sometimes you want to allow unchecked coercion between them.
05:43:42 <wli> quicksilver: iterateM f x = xs where xs = mdo ; next <- f x ; return next `mplus` (f =<< xs)
05:43:43 <ricky_clarkson> Cale: And there are times when you just want to run the code, because it might work, or you know it will work but cannot (yet) prove it to the type system.
05:44:19 <ricky_clarkson> Cale: Then there's the old one of type systems having limitations anyway - e.g., Haskell lacks infinite types.
05:44:34 <Cale> I can't say I've ever had a type error where I didn't end up realising that I'd actually done something stupid :)
05:45:03 <quicksilver> ricky_clarkson: not sure what you mean by infinite types; haskell has recursive types
05:45:09 <njbartlett> ricky_clarkson: There are Haskell programmers who would say that often the type checker knows better than they do whether their program is going to work or not. I'm one of them.
05:45:09 <mauke> just recurse through newtype
05:45:22 <ricky_clarkson> quicksilver: \f x -> f f x
05:45:30 <mauke> quicksilver: probably something like a@(a -> a)
05:45:37 <mauke> that's the type of all lambda calc values
05:45:43 <quicksilver> ricky_clarkson: you can do that with an explicitly defined type
05:45:55 <quicksilver> ricky_clarkson: (not that it's useful in real programs, most of the time)
05:45:57 <ricky_clarkson> quicksilver: I don't know how to do that *now*.
05:46:14 <njbartlett> As for coercions, if two types are almost identical and you want to write polymorphic code that will work on either, then you can just define a typeclass and make them both instances
05:46:15 <ricky_clarkson> So I'd like to just run the code, and if it works, then maybe I'll look into how to persuade the type system.
05:46:19 <ricky_clarkson> Haskell doesn't give me that.
05:46:32 <quicksilver> wli: and you want to keep doing that until you get mzero and then stop?
05:46:46 <wli> quicksilver: Yes.
05:46:48 <mauke> Haskell code depends on the type system
05:47:01 <Cale> ricky_clarkson: Do you write a lot of code which requires self-application?
05:47:01 <ricky_clarkson> njbartlett: Typeclasses have to have names - you could end up with an explosion of names for very simple things.
05:47:04 <dons> ricky_clarkson: do you have a use for it? the oh 2 times a year anyone in here needs that, they use a newtype
05:47:04 <mauke> you can't really run Haskell without a typechecker
05:47:07 <ricky_clarkson> Cale: No.
05:47:36 <wli> I can't be arsed to deal with language advocacy. I've got monadic mindbending to do.
05:47:39 <Cale> Infinite types are usually terribly impractical things
05:48:19 <Cale> I'd be really interested to see examples of practical code which fails the occurs check.
05:48:21 <wli> Sadly only a couple more hours of that before kernel hacking begins. :(
05:48:46 <Cale> (but would be correct otherwise)
05:48:57 <ricky_clarkson> However, I like my language to let me do anything I can think of.
05:49:40 <quicksilver> wli: that mdo is unecessary, by the way
05:49:41 <earthy> then Haskell is not for you. :P
05:49:43 <mauke> main = maek 3d shooter plz
05:49:56 <Cale> I suppose that's kind of the main philosophical breaking point here. :)
05:50:06 <wli> quicksilver: I've already rewritten it as iterateM f x = xs where xs = f x `mplus` (f =<< xs)
05:50:16 <Cale> I prefer that my language prevents me from screwing up. :)
05:50:55 <wli> Cale: No language can do that for me. Some just help me find more mistakes earlier than others.
05:51:06 <osfameron> I find haskell so hard that I can't get to the point of learning to do enough to actually screw up with it...
05:51:13 <psykotic> mauke, syntax error. it's main = can i haz 3d shooter plz
05:51:18 <quicksilver> wli: or just iterateM f x = f x `mplus` (iterateM f x) >>= f ?
05:51:45 <mauke> osfameron: ... just as planned
05:51:45 <wli> quicksilver: Space leak; no CSE in Haskell.
05:52:09 <olathe> It doesn't do CSE ?
05:52:17 <quicksilver> it does actually
05:52:22 <quicksilver> but only for fairly simple cases
05:52:24 <wli> olathe: No, because it leads to even worse space leaks.
05:52:39 <Cale> wli: Oh, sure, I can still screw up with Haskell -- it's just that it catches so much.
05:52:41 <wli> olathe: Well, highly restricted as quicksilver says.
05:52:48 <dons> ricky_clarkson: if you're confident, just wrap everything in a dynamic type, and pay a runtime cost of failure. if you're really confident, use coerce.
05:52:59 <olathe> Oh, I can see how that'd happen. Alright.
05:53:04 <quicksilver> wli: I'm having difficulty seeing how that can ever terminate unless you have a short-circuiting `mplus` ?
05:53:06 <wli> Cale: I think of it as a sort of automated assistant.
05:53:26 <quicksilver> wli: I suppose if you have a productive `mplus` it can be productive, though
05:53:27 <wli> quicksilver: That's basically what I'm looking for, I guess.
05:54:24 <quicksilver> wli: if your monad supports Eq, then you can just check for mzero
05:54:29 <quicksilver> wli: and stop when you find one
05:55:08 <quicksilver> :t let iterateM f x = xs where xs = if (f x == mzero) then mzero else f x `mplus` (f =<< xs) in iterateM
05:55:10 <lambdabot> forall a (m :: * -> *). (Eq (m a), MonadPlus m) => (a -> m a) -> a -> m a
05:55:10 <wli> I guess that'll have to do.
05:55:33 <quicksilver> MonadPlus doesn't have an 'isZero' method after all
05:57:18 <ricky_clarkson> I wouldn't have understood Haskell's 'fix' without having dealt with \f x -> f f x already in Lisp.
05:57:52 <Lycurgus> as the let macro?
05:57:59 <dons> ?src fix
05:57:59 <lambdabot> fix f = let x = f x in x
05:58:01 <dons> that one?
05:58:54 <quicksilver> ricky_clarkson: which is odd, because I always understood the haskell one much more easily
05:59:06 <quicksilver> I guess I have more of a typed intuition
05:59:16 <quicksilver> so the obviously well typed haskell one is clearer to me
05:59:19 <osfameron> what is the scheme version?
05:59:33 <vincenz> quicksilver: idem
05:59:36 <xerox> fix's type is a lie.
05:59:37 <koala_man> I'm trying to stick a hundred thousand elements in a few hundred maps, but I run out of stack space at about 70k. what can I do about this?
05:59:52 <osfameron> quicksilver: it's also typed+lazy - if you are thinking eagerly, it doesn't make any sense no matter how well typed it is
05:59:58 <dons> koala_man: you've got what data structures?
06:00:09 <dons> koala_man: in Data.Map?
06:00:15 <quicksilver> koala_man: `seq` the maps so they're forced instead of building up huge stack frames/thunks
06:00:18 <quicksilver> I expect
06:00:26 <dons> are you using the strict insertWith' ?
06:00:43 <quicksilver> yeah, or strictified inserts
06:00:49 <quicksilver> which is a bit less code noise, perhaps
06:00:53 <koala_man> ah
06:01:03 <Cale> ricky_clarkson: really?  fix f = let x = f x in x
06:01:20 <koala_man> isn't this the kind of thing the compiler should do when it figures out there's not enough stack space?
06:01:23 <Cale> Seems much clearer than the typical lambda calculus definition to me :)
06:01:34 <EvilTerran> ?type \f x -> f f x
06:01:36 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
06:01:36 <lambdabot>     Probable cause: `f' is applied to too many arguments
06:01:45 <ricky_clarkson> I'm not actually typing really slowly, just on a dodgy wireless connection.
06:01:46 <ricky_clarkson> Yes, that one.
06:01:58 <dons> koala_man: strictify elements? no. you could also increase the stack size +RTS -K20M for example
06:02:15 <dons> I wonder how useful a node-strict Data.Map would be. hmm
06:02:19 <ricky_clarkson> (that one meant yes, that 'fix').
06:02:36 <dons> a bit like Nil | Node !a (Tree a) (Tree a)
06:02:42 <EvilTerran> koala_man, i think you'll need -fdwim for that. but, as it is, nothing's forced unless it has to be or you tell it to be
06:02:53 <EvilTerran> ;]
06:02:54 <koala_man> dons: I mean try to evaluate parts of the stack to reduce its size, instead of building it bigger and bigger and then crash
06:02:58 <ricky_clarkson> osfameron: A Scheme version is something like (lambda (f x) (f f x))
06:03:02 <Cale> Alternately you can even write  fix f = f (fix f), though it's a little less efficient.
06:03:08 <mauke> ricky_clarkson: that doesn't look like fix
06:03:11 <wli> quicksilver: iterateM f x = xs where xs = do let y = f x ; if y /= mzero then y `mplus` (iterateM f =<< y) else mzero
06:03:12 <dons> koala_man: yeah, sometimes a bit of eager eval can be useful
06:03:12 <ricky_clarkson> It's related.
06:03:13 <Cale> ricky_clarkson: that's not fix
06:03:21 <mauke> it's "rec"
06:03:21 <vincenz> ricky_clarkson: you mean
06:03:29 <vincenz> (lambda (f x) (f (f x)))
06:03:29 <dons> koala_man: its a complex change to the runtime, usually you should just fix the space leak that caused the stack use
06:03:36 <ricky_clarkson> I started with \f x -> f f x, which isn't possible in Haskell.
06:03:39 <ricky_clarkson> vincenz: No.
06:03:48 <dons> which is almost always trivial to fix (i.e. insertWith')
06:03:49 <EvilTerran> def. (f f) x
06:04:07 <koala_man> dons: why would you call it a leak?
06:04:07 <mauke> (define (fix f) (lambda (x) (f (fix f) x)))
06:04:07 <EvilTerran> means you can recurse without language support.
06:04:17 <EvilTerran> (ish)
06:04:25 <dons> koala_man: lots of elements, building up a big stack of unevaluated insertions?
06:04:28 <EvilTerran> and i thought that was the point of fix...
06:04:40 <Cale> Understanding fixed point combinators in the simply typed lambda calculus is way harder than understanding the Haskell definition of fix
06:04:41 <ricky_clarkson> fix lets you recurse without a name.
06:04:43 <dons> better to say, hey compiler, i want these done strictly (rather than changing the runtime to try to guess)
06:04:50 <mux> you can't implement fix if you don't have a recursive let, iirc
06:04:53 <ricky_clarkson> Cale: I found the opposite.
06:04:53 <Cale> er, untyped :)
06:05:02 <Cale> Why?
06:05:05 <mux> fix can be considered a derived form of letrec
06:05:26 <dons> yeah. its nice having letrec built in :)
06:05:28 <Cale> fix f = f (fix f) is surely pretty easy to understand?
06:05:28 <koala_man> dons: so basically lazy evaluation is just a bunch of leaks that you should have to try to fix? how about adding manual memory management as well :O
06:05:34 <EvilTerran> Cale, i was going to say, i didn't think you could define it in the simply-typed \calc
06:05:37 <quicksilver> dons: Data.Map is already shape-strict and key-strict
06:05:39 <ricky_clarkson> Because the definition of fix in Haskell makes no sense to me.
06:05:43 <Cale> EvilTerran: yeah, you can't
06:05:47 <dons> koala_man: hmm, no, not really. sometimes its critical, sometimes not
06:05:47 <quicksilver> dons: I think that's the obvious setup
06:05:51 <mux> koala_man: you can call malloc in haskell if you want to ;-)
06:05:57 <dons> quicksilver: yeah, i notice it is key strict. that's good
06:06:02 <quicksilver> dons: having it value-lazy seems like the right default
06:06:03 <dons> so really here insertWith' is needed
06:06:09 <EvilTerran> which is nice if you want to be sure there's no infinite loops, but it does mean a lack of codata.
06:06:16 <quicksilver> dons: it's spine-strict too; or tree-strict or whatever
06:06:23 <Cale> ricky_clarkson: Perhaps it's confusing because Haskell expressions are evaluated outermost first?
06:06:27 <dons> yeah, that's a bit unusual, don't you think, quicksilver ?
06:06:38 <mauke> ricky_clarkson: you just take a function and feed it its own return value
06:06:42 <mauke> what could be simpler? :-)
06:06:51 <wli> quicksilver: I still don't like it. y <- f x should short circuit when f x is mzero
06:07:05 <dons> koala_man: what's the key type, btw? Int?
06:07:06 <EvilTerran> fix (1:) = let x = 1:x in x
06:07:07 <quicksilver> dons: the balancing algorithm would strictify large chunks of tree fairly eagerly anyway
06:07:20 <dons> yeah, I guess that's the case. so may as well say so explicitly
06:07:20 <quicksilver> dons: I imagine they decided it was easier to make it strict up front and save some space to boot
06:07:28 <Cale> Or  fix f = x where x = f x -- this just says that x is a fixed point of f
06:07:29 <dons> yep
06:07:31 <EvilTerran> @src String show
06:07:31 <lambdabot> Source not found. Take a stress pill and think things over.
06:07:35 <koala_man> dons: String
06:07:48 <mauke> @src [] show
06:07:48 <quicksilver> dons: of course, you could debate having a lazy Ord instance
06:07:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:07:51 <dons> for 100k+ elements? might be safer to use ByteString
06:07:54 <quicksilver> dons: and not wanting to be fully key-string
06:07:57 <quicksilver> dons: key-strict
06:07:59 <EvilTerran> @src Char showLost
06:07:59 <lambdabot> Source not found. My pet ferret can type better than you!
06:07:59 <Cale> It's got to be right, because you can see the equation for a fixed point *right there*.
06:08:32 <quicksilver> dons: e.g. the ord instance between some abitrary precision real type
06:08:32 <mux> clearly, fix = let x = f x in x is the cutest way of defining fix ever
06:08:33 <EvilTerran> @src Char showList -- :P
06:08:33 <lambdabot> Source not found. My mind is going. I can feel it.
06:08:38 <quicksilver> dons: only forces enough to prove the comparision
06:08:40 <dons> koala_man: i'd probably go with ByteString keys, with a table that size. Map ByteString e
06:08:44 <wli> quicksilver: iterateM f x = xs where xs = do { y <- f x ; (return y) `mplus` (iterateM f y) }
06:08:46 <dons> quicksilver: hmm, yes.
06:08:48 <wli> quicksilver: That works.
06:08:58 <EvilTerran> mux: that way makes sense if you look at cases like fix (1:) etcx
06:09:05 <Cale> Whereas with something like \f.(\x.f (x x)) (\x.f (x x)), it's not at all clear what that does without a lot of thinking.
06:09:13 <dons> koala_man: oh, then again, if they're very short strings. hmm.
06:09:13 <quicksilver> I'm with Cale on this one :)
06:09:17 <mux> Cale: yeah
06:09:19 <eivuokko> Windows users, please help me test windows installer (msi) package generator.  Details at http://www.haskell.org/pipermail/cabal-devel/2007-August/000754.html
06:09:21 <lambdabot> Title: Call for testers: cabal2wix 0.1.0, http://tinyurl.com/2tmx3e
06:09:23 <vincenz> Cale++
06:09:26 <mux> or Y
06:09:27 <mux> :)
06:09:50 <dons> koala_man: anyway, let me know if insertWith' fixed the issue. I'm a little intrigued
06:09:50 <ricky_clarkson> I had to stumble across fix in Scheme and then realise that it was the same as Haskell's.
06:10:11 <ricky_clarkson> I can find the paper I want when I'm not logged in - http://portal.acm.org/citation.cfm?id=647556.729890
06:10:13 <lambdabot> Title: Experiments in Haskell - A Network Simulation Algorithm
06:10:28 <ricky_clarkson> ..but then when I am logged in it won't appear, no matter how I esearch.
06:10:33 <ricky_clarkson> Or search.
06:10:34 <mux> surely, the scheme version can't be written the same as in haskell, because the haskell way of defining fix needs laziness to work?
06:11:18 <Cale> Strict evaluation makes fix really tricky to write
06:11:34 <vincenz> strict evaluation is premature optimization
06:11:38 <ricky_clarkson> Then I must have written a different combinator, ah well.
06:11:39 <int-e> mux: In a sense it works; if your function is strict (f _|_ = _|_), bottom is the smallest fixed point.
06:11:43 <dons> don't they have to move it under a lambda? or otherwise fake laziness?
06:11:46 <quicksilver> @quote premature
06:11:46 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
06:11:57 <int-e> mux: and non-termination is a special kind of bottom
06:11:58 <quicksilver> @remember vincenz strict evaluation is premature optimization
06:11:58 <lambdabot> Done.
06:11:58 <mux> int-e: heh, well yeah, but it's not that useful :)
06:12:13 <vincenz> quicksilver: :D
06:12:29 <koala_man> dons: I still get overflows
06:12:43 <dons> koala_man: is the code terribly long? Could you paste or link to it?
06:12:58 <dons> what's it do? read a words file or somethiing?
06:13:05 <ricky_clarkson> Cale: Your point about wanting a language that doesn't let you screw up - I argue that such a language makes it harder to learn.
06:13:23 <ricky_clarkson> I know there are some people who have started with Haskell, and apparently are doing quite well..
06:13:34 <mux> I've started with Locomotive Basic 1.0
06:13:42 <dons> some people like to drive down the road on the wrong side too, ricky_clarkson :)
06:13:47 <dons> these road rules are so hard!
06:14:00 <mux> that wasn't very haskell-ish
06:14:03 <dons> i'm going off road, now!
06:14:09 * earthy laughs
06:14:10 <vincenz> dons: very dynamic
06:14:13 <dons> we should send the types police to chase people!
06:14:20 <ricky_clarkson> dons: Would you like a car that refused to drive on the wrong side of the road?
06:14:32 <mux> the type soundness police
06:14:35 <vincenz> ricky_clarkson: a car would imiplement both type-classes obviously!
06:14:39 <vincenz> instance DriveLeft Car where
06:14:44 <vincenz> instance DriveRight Car where ..
06:14:53 <dons> ricky_clarkson: serisouly, f f x you do with newtype recursion. next problem?
06:14:59 <earthy> ricky_clarkson: would you put diesel fuel in a gasoline powered car?
06:15:00 <matthew-_> vincenz: I'd parameterise the car itself
06:15:07 <vincenz> matthew-_: good point, since you could have two types of cars
06:15:10 <dons> we're trying to avoid the sins of the past here, and improve software quality, by disallowing everything first
06:15:27 * Philippa_ showed someone some Haskell last night and she commented that that's what she thought programming was going to be like when she first started doing compsci
06:15:27 <mux> hah
06:15:27 <dons> we already had 50 years of allowing everything, and that hasn't worked
06:15:29 <vincenz> instance (LeftWheel car) => DriveLeft car where
06:15:31 <mathias_> How can I quickcheck a function of type (Vars s t, MonadIO t, Show a)=> t Bool?
06:15:32 <vincenz> instance (LeftWheel car) => DriveRight car where
06:15:36 <quicksilver> do I smell an overextended analogy?
06:15:37 <vincenz> RightWheel ...
06:15:38 <matthew-_> that way you'd specify a road as data Road a = Road (Car a) (Car a)
06:15:38 <ricky_clarkson> dons: I'd rather allow everything else, but shout at the programmer.
06:15:43 <koala_man> dons: well, it's 86 lines
06:15:52 <vincenz> matthew-_: only two lanes?
06:15:57 <quicksilver> Philippa_: did you have the impression that was considered a good thing or a bad thing?
06:16:03 <vincenz> matthew-_: what about those streets with ambiguous middle lanes?
06:16:04 <mauke> Haskell can create the roads for you if you give it a strongly typed car
06:16:21 <dons> ricky_clarkson: well, there's C++ for that. its working well for some. but can blow up spectacularly. basic point about which way to programming nirvana. some of us like living in safe societies, others like anarchy with a gun.
06:16:24 <matthew-_> vincenz: data Road a = Road [(Car a)] (Maybe StupidAccident) [(Car a)]
06:16:34 <vincenz> ;D
06:16:41 <dons> but if you get shot, people mightn't come to your help
06:16:49 <ricky_clarkson> dons: Some safe societies can live with guns.
06:16:53 <ricky_clarkson> Switzerland is one.
06:16:54 <dons> at least here in haskell, we'll all be shocked, and likely catch the guy who did it, if you get shot
06:17:09 <vincenz> ricky_clarkson: switzerland is a destructive community
06:17:10 <mauke> hey, getting segfaults in haskell is trivial
06:17:19 <vincenz> ricky_clarkson: the population is strictly decreasing due to the laws on becoming swiss
06:17:19 <dons> yeah, its a bit like switzerland here. we hae unsafeCoerce#, but we tend not to tell anyone
06:17:40 <mauke> *(char *)1  /* C */
06:17:56 <mauke> peek (nullPtr `plusPtr` 1 :: Ptr CChar)  -- Haskell
06:18:04 <dons> ricky_clarkson: anyway, what was your on-topic question again? or just a general complaint about type systems? :)
06:18:07 <ricky_clarkson> dons: I'd rather default to unsafeCoerce then invoke a type checker for certain parts of code.
06:18:18 <vincenz> dons: heh, was just about to say the same thing
06:18:20 <dons> wow. that's pretty insane. i think you're in the wrong channel.
06:18:30 <dons> you know that means you need to check things at runtime?
06:18:36 <dons> and you don't know it goes wrong until it does?
06:18:53 <mauke> unsafeCoerce doesn't need runtime checks
06:18:54 <dons> please don't write any pace maker software that i might need to use
06:18:55 <matthew-_> dons: it's really like Java though - you can do casts if you want, thus really you can't trust anything the type checker says
06:19:26 <Cale> http://hpaste.org/2110 -- an example of using a Haskell definition of fix, step-by-step.
06:19:27 <scook0> the difference is that Java can tell when you screw up
06:19:56 <mux> we have the Safe lib, now we need the Unsafe lib, but fromJust, head, unsafeCoerce, unsafePerformIO, etc
06:20:06 <mux> s/but/with/ damnit
06:20:08 <ricky_clarkson> dons: I'm trying to download a Haskell paper from ACM but I'm having difficulty.  That's where I started here.
06:20:19 <dons> oh boo on ACM. is it on scholar.google.com?
06:20:28 <dons> they seem to find the homepages of papers a bit better
06:20:40 <matthew-_> ricky_clarkson: also, if you know they authors of the paper, search for them directly
06:20:50 <matthew-_> most authors put papers up on their own web pages
06:20:56 <dons> nice Cale. you should stick it on the wiki
06:21:01 <quicksilver> dons: no it's not, i looked
06:21:10 <quicksilver> dons: well, it is, but the only reference is to the ACM site
06:21:15 <dons> the authors want their work to disappear :/
06:21:35 <quicksilver> one of the co-authors is Runciman
06:21:42 <quicksilver> I imagine he's responsive to emails
06:21:45 <dons> ah , ok. we can get hold of him.
06:21:50 <quicksilver> if not, I suspect ndm can get hold of the paper for us :)
06:21:51 <dons> you'd imagine that, but ndm would tell you otherwise :)
06:22:13 <dons> ricky_clarkson: ok, so `ndm' here is runciman's student. he can get you the paper i think.
06:22:16 <dons> @seen ndm
06:22:16 <lambdabot> ndm is in #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when ndm last spoke.
06:22:27 <ricky_clarkson> I'd have been less annoying if my screen session didn't keep freezing. ;)
06:22:36 <Cale> ricky_clarkson: does that example help to clarify how fix works in Haskell?
06:22:46 <dons> probably written in a language that allows unsafe coerce by default.
06:23:08 <matthew-_> dons, you wouldn't be trolling there would you? ;)
06:23:21 <mathias_> Is there any practical library for testing monadic(including IO) code?
06:23:39 <dons> matthew-_: hmm, QC2 has an approach to this. there's some recent papers on the topic
06:23:53 <vincenz> dons: wrong tab-complete
06:23:53 <dons> hunit lets you write unit tests for IO, if that's all you need, mathias_ ?
06:23:54 <matthew-_> no, that was for mathrick, not me
06:24:04 <dons> mathias_: sorry
06:24:10 <matthew-_> agh, grrr, so many matthew derived names!
06:24:17 <dons> the channel is too big
06:24:25 <mauke> data Mathrick deriving (Matthew)
06:24:26 <dons> i think we should really try the unique prefix idea
06:24:27 <quicksilver> mathias_: it's actually rather easy to knock up your own tests since haskell is so easy to abstract
06:24:31 <dons> 0000-shapr
06:24:36 <dons> 0001-Pseudonym
06:24:37 <dons> etc.
06:24:38 <quicksilver> mathias_: but check out HUnit and QC2
06:24:40 <ricky_clarkson> Cale: It's interesting, but I'm not sure I understand it properly.  Don't worry, I'll go and read stuff
06:24:43 <vincenz> dons: that'd still make you type 4 characters
06:24:50 * vincenz votes that noone is allowed to have the same initial character
06:25:01 <mauke> vincenz: unicode!
06:25:01 <xerox> ?djinn
06:25:02 <lambdabot> Cannot parse command
06:25:08 <dons> ok, i suppose 999 is probably a reasonable limit for the next 18 months or so
06:25:10 <Cale> ricky_clarkson: All that you do is replace matching left hand sides with right hand sides, basically.
06:25:11 <vincenz> mauke: no, only keyboard characters
06:25:13 <xerox> ?djinn (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
06:25:13 <lambdabot> f a b c = b (\ d -> c (a d))
06:25:49 <quicksilver> I am actually somewhat surprised that peek isn't called unsafePeek
06:26:01 <vincenz> > length $ ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_[-"
06:26:03 <lambdabot>  65
06:26:06 <Cale> dons: Oh, we're just going to have to split into #haskell-1 and #haskell-2, where people are randomly redirected ;)
06:26:06 <dons> quicksilver: yeah, FFI perogative
06:26:08 <ricky_clarkson> dons: scholar.google.com just points back at acm.  I'll ask ndm.  Thanks.
06:26:16 <mathias_> Where can I find quickcheck2?
06:26:20 <ndm> ricky_clarkson: what do you want?
06:26:34 <ricky_clarkson> ndm: "Experiments in Haskell-A Network Simulation Algorithm"
06:26:34 <matthew-_> dons: don't use numbers, that's only base 10. Use lower and upper case letters.
06:26:42 <dons> mathias_: http://www.cs.chalmers.se/~bringert/darcs/QuickCheck ?
06:26:44 <ricky_clarkson> By Paul Sanders.
06:26:46 <lambdabot> Title: Index of /QuickCheck
06:26:52 <matthew-_> dons: 26^2 is 676 so that should be enough - just two chars each
06:26:55 <vincenz> Cale: I propose we instead push through on the concept upon which the internet is based: isolation.  Send everyone to their own channel.
06:26:57 <ndm> quicksilver: i suspect Colin is more responsive to papers when he's not on holiday, but i bet he is otherwise
06:27:05 <dons> ?tiny-url dons
06:27:06 <lambdabot> Url not valid.
06:27:07 <ndm> I can get Colin's papers, but usually only in paper format...
06:27:10 <dons> ?tiny-url http://dons
06:27:11 <lambdabot> http://tinyurl.com/2ywqw9
06:27:18 <dons> i can be: 2ywqw9-dons
06:27:23 <xerox> ?tiny-url http://xerox
06:27:24 <lambdabot> http://tinyurl.com/5ma8a
06:27:28 <quicksilver> ndm: yes, I wasn't intending to suggest otherwise. Quite the contrary.
06:27:32 <ricky_clarkson> ndm: Ok, thanks.
06:27:35 <vincenz> @tiny-url http://vincenz
06:27:35 <dons> 2ywqw9-dons Erroneous Nicknam!
06:27:36 <lambdabot> http://tinyurl.com/3584yh
06:27:40 <xerox> :(
06:27:42 <vincenz> @tiny-url http://vincenz
06:27:43 <lambdabot> http://tinyurl.com/3584yh
06:27:44 <Cale> vincenz: That's an excellent idea!
06:28:04 <mauke> ricky_clarkson: any language that lets you run arbitrary machine code is unsafe enough for me
06:28:19 <Cale> http://www.dons.com/
06:28:21 <lambdabot> Title: Dons.com - Used Books, Comics and More
06:28:22 <mauke> (I know how to do it in C, Perl and Haskell)
06:28:31 <n2ywqw9-dons> i do hve used books, comics and more!
06:28:37 <xerox> http://www.xerox.com
06:28:40 <lambdabot> Title: Xerox Document Management, Color Printers, Copiers, Business Consulting Services
06:28:48 <ricky_clarkson> mauke: Why would you want to run arbitrary low-level code when you can run arbitrary high-level code?
06:28:49 <n2ywqw9-dons> its all for sale! http://www.cse.unsw.edu.au/~dons/sale/
06:28:49 <lambdabot> Title: Don and Suzie go to the USA
06:28:55 <n2ywqw9-dons> if anyone wants any stuff?
06:29:02 <dons> that nick is scary
06:29:12 <mauke> ricky_clarkson: to scare people
06:29:13 <vincenz> dons: yeah,, reminds me of m4st3r..
06:29:46 <dons> x3584yh-vincenz, yeah
06:29:59 <matthew-_> xerox: do you/did you use to play a lot of BZFlag?
06:30:03 <vincenz> dons: there was no x
06:30:17 <xerox> matthew-_: nope.
06:30:31 <dons> `Copyright Â©1973 - 2007, Don's Paperback Books' seems implausible for  a website.
06:30:33 <EvilTerran> dons, do you have freecycle in your part of the world?
06:30:34 <xerox> http://www.cale.com
06:30:35 <lambdabot> Title: Cale's Immaturity Dojo - More fun than a kick in the crotch - www.cale.com
06:30:35 <dons> explains how he got dons.com though
06:30:36 <matthew-_> xerox: ahh ok. your nick is the same as a player on BZFlag I used to know...
06:30:45 <Cale> xerox: hahaha
06:30:51 * xerox laughs.
06:30:55 * vincenz snickers
06:31:06 <vincenz> hmm
06:31:09 <EvilTerran> dons, just a thought, for anything you can't get rid of otherwise
06:31:09 <dons> EvilTerran: yeah, we're using that actually, as well
06:31:11 <vincenz> http://www.vincenz.com
06:31:18 <vincenz> why does that map to www.xxxxx.com ?
06:31:27 <quicksilver> domain squatting
06:31:27 <dons> yeah. i suspect 90% of stuff we'll just have to give away :)
06:31:47 <vincenz> dons: why are you selling it all?
06:32:04 <dons> moving to portland in 3 weeks
06:32:06 <vincenz> just get a transfo for the electronics
06:32:21 <quicksilver> they're becoming monks and devoting their lives to brewing beer on a mountain top
06:32:25 <dons> nah, student junk
06:32:28 <Cale> Wow, the domain squatters couldn't even be bothered to write a script to splice the URL in.
06:32:29 <quicksilver> and meditating on type hackery
06:32:34 <matthew-_> dons: you going to work with Tim Sheard et al?
06:32:40 <quicksilver> Cale: or they did, and they managed to break it :)
06:32:40 <vincenz> Cale: yeah
06:32:42 <dons> close, galois.com.
06:32:52 <matthew-_> ahh. What do they do?
06:32:59 <bitwize> dons: congratulations :)
06:33:00 <vincenz> dons: not going to miss ozzy?
06:33:03 <Cale> http://www.quicksilver.com/
06:33:03 <lambdabot> Title: Quicksilver Software Inc
06:33:14 <bitwize> They do high-security high-availability software using haskell
06:33:23 <vincenz> Cale: odd it doesn't map to the much more famous clothing brand
06:33:25 <matthew-_> dons: and is this just an internship or is your PhD now finished?
06:33:28 <dons> vincenz: maybe. we'll see. portlandis nice too.
06:33:32 <dons> matthew-_: finishing up, yep.
06:33:36 <dons> its a legit job.
06:33:37 <matthew-_> congrats
06:33:38 <quicksilver> Cale: hmm that game looks quite good. maybe I'll buy it!
06:33:42 <vincenz> dons: well enjoy :)
06:33:44 <bitwize> vincenz: I assure you he's going to have fun in Portland. It's a hell of a town.
06:33:52 <mathias_> What can I do about "Could not find module `x': it is a member of package 'y'  which is hidden during a cabal build step?
06:33:56 * xerox high-fives dons
06:34:02 <dons> woot!
06:34:04 <psykotic> dons: do they have their own version of ghc, or is that someone else?
06:34:27 <mauke> mathias_: add package y to the .cabal file
06:34:31 <quicksilver> mathias_: (1) wonder if you're using an out-of-date name for an obsolete module
06:34:34 <vincenz> bitwize: spiffy :)
06:34:40 <quicksilver> mathias_: (2) consider mauke's solution :)
06:34:49 <mathias_> mauke, what is the syntax for that?
06:35:07 <psykotic> bitwize, and portland has The Bookstore To End All Bookstores
06:35:08 <dons> psykotic: not sure i can say.
06:35:11 <mauke> uh, let me check
06:35:16 <psykotic> dons: ok :)
06:35:17 <dons> certainlyu ghc is used
06:35:22 <bitwize> AMEN!
06:35:22 <mathias_> mauke, got it.
06:35:26 <ricky_clarkson> My reason for wanting that paper is that I have a network simulator, and it relies on fairly uncontrolled side-effects.  I was trying to see how a Haskeller might do it.
06:35:35 <mauke> build-depends:
06:35:57 <bitwize> not to mention The Strip Club District To End All Strip Club Districts
06:36:02 <dons> ricky_clarkson: a simulator? probably with a model of the effects? (or just with an effect monad for the kind of thing you want)
06:36:18 <psykotic> dons: i think i was thinking of bluespec, but that's someone else :)
06:36:31 <dons> ah yeah, these are the cryptol compiler guys
06:37:15 <ricky_clarkson> ..the packet routing relies on the side effects.
06:37:22 <LeCamarade> Anybody know where I can _download_ the SPJ videos, rather than stream them?
06:37:31 * shapr wants to know too
06:37:32 <mathias_> Where can I find the documentation for Quickcheck2 (as the documentation does not build)?
06:37:34 <psykotic> LeCamarade, the same place, at blip.tv
06:37:48 <LeCamarade> psykotic: Them guys only stream.
06:37:50 <psykotic> LeCamarade, you can just wget the movs
06:37:53 <psykotic> nah
06:37:54 <matthew-_> dons: how many of galois's customers are in the arms business / mercenaries?
06:37:57 <wli> ricky_clarkson: Pureness is not about the absence of side effects, but rather the regimentation thereof.
06:38:02 <dons> ricky_clarkson: you'd use control side effects then (or build a model). that's the two approaches taken usually (particular for hard core verficiation stuff, a model would be used)
06:38:04 <LeCamarade> anybody: So you know? :-D
06:38:12 <ricky_clarkson> dons: Ok.
06:38:18 <psykotic> LeCamarade, i wgetted them without any problems...
06:38:32 <mauke> LeCamarade: http://www.haskell.org/pipermail/xmonad/2007-August/001586.html
06:38:33 <lambdabot> Title: [Xmonad] Video, slides and Haskell Workshop demo
06:38:51 <dons> EvilTerran: there's direct links on the video page on haskell.org
06:38:56 <dons> LeCamarade: sorry
06:39:07 <LeCamarade> psykotic: It is `I wgot them' :o)
06:39:08 <dons> ?go haskell video presentations
06:39:10 <lambdabot> http://haskell.org/haskellwiki/Video_presentations
06:39:10 <lambdabot> Title: Video presentations - HaskellWiki
06:39:11 <EvilTerran> ?
06:39:11 * LeCamarade goes to that URL ...
06:39:27 <Igloo> Did Isaac marry a Miss Potoczny?
06:39:29 <ricky_clarkson> One thing that stops me from regimenting what I do have is that there is a packet queue, which listeners can add packets to, which could easily be made pure, but then sometimes I (currently) need to know when the queue is empty - there is a listener for that.
06:39:42 <dons> ricky_clarkson: you might look at the H monad in the house operation system (haskell monad for hardware/device drivers0
06:39:45 <ricky_clarkson> ..I'm struggling to wrap my head around what to do with that.
06:40:13 <dons> seems fairly straight forward. Maybe Queue ?
06:40:19 <shapr> Igloo: You mean, what's Anna's maiden name?
06:40:22 <dons> or MVar Queue ?
06:40:29 <Igloo> shapr: Yes
06:40:30 <dons> Igloo: looks like it, eh?
06:40:41 <matthew-_> ricky_clarkson: IME there's always a way to do it, but it might be quite different from what you imagined. In the process of getting there, you'll probably learn a vast amount and often end up with a more powerful solution anyway.
06:40:56 <ricky_clarkson> matthew-_: Sure, just need a starting point.
06:41:32 <wli> ricky_clarkson: Regimentation is simply organization, systematization, et al. If you can't approach your problem in a systematic and organized fashion, you have bigger problems than the programming language you code in.
06:41:51 <dons> you'd just build the queue type, and a test for empty, so far nothing too scary
06:42:09 <dons> empty :: Queue a -> Bool
06:42:13 <dons> push/pop/ etc.
06:42:29 <ricky_clarkson> dons: I already have that.  I was looking to have the listeners return the packets they want to enqueue, rather than jutst enqueuing them.
06:42:43 <ricky_clarkson> Is that folly?
06:42:52 <dons> hard to say. not enough info about the problem.
06:43:03 <dons> a general rule would be to ensure the type states everything the function does
06:43:08 <wli> Someone mentioned SCTP earlier.
06:43:09 <dons> and don't try to do more than one thing, if you're building a model.
06:43:30 <wli> SCTP has the interesting feature of reliable out-of-order delivery, not that any of the protocol stacks implement it.
06:44:19 <mauke> reliably out-of-order?
06:45:10 <LeCamarade> I'm wgetting the videos. Thanks, all.
06:45:26 <wli> mauke: Yes. Things keep track of what didn't make it by means different from mere counters, and retransmit, retry, etc.
06:45:32 <ricky_clarkson> dons: Overall, a problem I have is that sometimes I need to merge networks - so that 3 simulated networks become one, still with 3 views, but the same packet queue across them.  I thought if I could effectively remove the packet queue that would be easier.
06:45:35 <dons> LeCamarade: get the pdf slides too, they explain the tals a lot
06:45:56 <ricky_clarkson> dons: I suppose I can solve it without doing that.
06:46:08 * ricky_clarkson wanders off for coffee and thought.  Thanks for the input.
06:46:08 <dons> ricky_clarkson: sounds like a big design issue: pen and paper time?
06:46:13 <LeCamarade> dons: Link, s'il vous plaît?
06:46:22 <dons> LeCamarade: the video page has a pdf link under the .movs
06:46:49 <LeCamarade> Ah.
06:51:26 <psykotic> dons: btw i saw your DList thing, very nice. do you know of any other cute examples of "replacing data structures with (lazy) code" like that?
06:51:39 <psykotic> dons: i remember dave bayer posted a really nice lazy merge that did something along those lines
06:52:03 <dino-> (reads scrollback) dons: Congratulations on your new position.
06:53:25 <dons> psykotic: hmm, there's bound to be some others out there. the dlist one is well known -- but i don't know of a paper on it (probably something from the mid 80s )
06:53:28 <dons> dino-: thanks
06:53:56 <psykotic> dons: maybe some of okasaki's work qualifies?
06:54:31 <dons> oh, yes. there's got to be some laziness tricks in there (though he did a lot of his work in SML)
06:54:43 <anybody> hm i'm a little confused. is "(expr=name) where name = ..." the same as "let name=.... in (expr=name)" ?
06:55:05 <EvilTerran> yes. approximately.
06:55:08 <vincenz> psykotic: DList thing? was it through tieing the knot?
06:55:10 <dons> expr = name is a declaration
06:55:10 <psykotic> dons: SML with laziness extensions
06:55:16 <desegnis> anybody, expr = let name = ... in name
06:55:26 <EvilTerran> wait, you can't say let ... in expr=name
06:55:27 <psykotic> vincenz, basically you represent a list as a function [a] -> [a] which prepends itself to the given list.
06:55:33 <dons> vincenz: lists with good append via function composition
06:55:38 <psykotic> vincenz, then you can implement append via composition, etc
06:55:58 <EvilTerran> anybody, "expr = name where name = ..." is the same as "expr = let name = ... in name"
06:56:09 <vincenz> rightio
06:56:17 <anybody> k. thx.
06:56:23 * vincenz thought of double instead of derived when he saw D
06:56:27 <dons> useful for Writer monads (and other appendish lists)
06:56:40 <vincenz> dons: that's the principle we employed for our dna compiler
06:56:43 <anybody> so why would you choose the where instead of let... in.. ?
06:56:55 <vincenz> anybody: perrsonally I think it clutters less
06:57:03 <vincenz> anybody: so .. aesthetics :)
06:57:03 <dons> anybody: where is often clearer
06:57:04 <EvilTerran> anybody, "let ... in ..." is an expression, and is valid anywhere an expression is. "where"s can only be used in certain places, but are more aesthetically pleasing (to some)
06:57:20 <dons> people seem to start with 'where', move to 'let', and then revert back to 'where'
06:57:27 <anybody> lol
06:57:29 <dons> thompson's book doesn't even mention case or let :)
06:57:39 <psykotic> sometimes let/in makes more sense. like if i'm tying the knot, i might do let x = f x in x
06:57:46 <dons> those 1st gen haskellers are some funny guys :)
06:57:52 <EvilTerran> anybody, also, a where is visible across all guarded parts of a definition
06:57:54 <vincenz> psykotic: I only use let when I'm using monadic lets
06:58:01 <mux> I like where better for indenting, makes things nicer
06:58:02 <vincenz> cant get around those
06:58:12 <dons> i wish where was an expression form
06:58:12 <mux> but the fact that it applies to the outer scope only forces me to use let instead sometimes
06:58:23 <psykotic> dons: so it could attach anywhere?
06:58:29 <dons> map (\x -> y where y = -x) [1..10]
06:58:32 <quicksilver> anybody: no, it's not
06:58:34 <Igloo> dons: let is where-as-an-expression-form
06:58:35 <psykotic> mux: not just the outer scope. any definition, i think.
06:58:38 <dons> yeah, sometimes let is a bit icky
06:58:48 <quicksilver> anybody: let name=... in (expr=name) isn't legal haskell
06:58:53 <dons> Igloo: let with keywords in the middle :)
06:58:57 <Cale> I kind of like the fact that where can scope over guards.
06:59:01 <quicksilver> anybody: the body of a let (that is, the "in" part) must be an expression
06:59:03 <psykotic> cale: yep
06:59:04 <quicksilver> anybody: not a definition
06:59:15 <psykotic> cale: without that guards would be a lot less useful (too unreadable).
06:59:21 <vincenz> what I dislike, however, are nested where's
06:59:24 <anybody> quicksilver: i got that already. thx. anyway
06:59:27 <vincenz> though sometimes they're required
06:59:35 <vincenz> however, typically that's a refactoring hint :)
06:59:39 <psykotic> yep
06:59:45 <xerox> > map negate [1..10]
06:59:46 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
07:00:02 <vincenz> > [-1,-2..-10]
07:00:03 <lambdabot>   Not in scope: `..-'
07:00:05 <vincenz> > [-1,-2.. -10]
07:00:06 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
07:00:13 <psykotic> @info mfix
07:00:13 <lambdabot> mfix
07:00:33 <dons> someone should try to use mdo today.
07:00:46 <psykotic> what useful instances does MonadFix have? someone mentioned the instance for lists the other day, but it seems to be pretty useless.
07:00:48 <dons> we need a weekly survey of fun extensions no one uses
07:01:14 <psykotic> dons: i'm sure oleg has some code in which he uses mdo to launch a nuclear missile in 5 lines of code
07:01:15 <dons> Maybe, IO ?/
07:01:17 <vincenz> <troll> bytestrings!
07:01:34 <vincenz> psykotic: oh, MAD?
07:01:39 <vincenz> psykotic: mutually assured destruction?
07:01:39 <dons> instance MonadFix ((->) r) where
07:01:39 <dons>     mfix f = \ r -> let a = f a r in a
07:01:41 <vincenz> that why you need the 'fix' ?
07:01:51 <dons> now that's underexploited I suspect
07:01:52 <psykotic> heh
07:02:00 <psykotic> ah, for tying the knot.
07:02:03 <wli> dons: Mixing Boolean expressions and pattern matching in pattern guards.
07:02:12 <xerox> dons: that's mind bending, ask ski :)
07:02:18 <psykotic> that's so hairy to grok that i usually do it out in the open, where it's obvious to everyone :)
07:02:38 <dons> psykotic: that's not the haskell way though! ;)
07:02:41 <psykotic> hah
07:03:02 <psykotic> fortunately i don't need to do that very often. although i tied the knot through a Map the other day and it worked on the first try.
07:03:03 <dons> you're supposed to encode the nuclear missle launch in the whitespace, and infer which instances are getting used
07:03:31 <wli> dons: f tbl x y z | x /= 0 , Just y' <- lookup y tbl , z' <- lookup z tbl = ...
07:03:33 <vincenz> dons: you need to tie the knot
07:03:39 <dons> truly, haskell function glue is as baroque as string regex glue in perl
07:03:59 <dons> manipulating functions is lifted to a high art form
07:04:06 <wli> psykotic: Is this tying the knot thing just a data structure that's self-referential via mutual recursion?
07:04:21 <vincenz> wli: yes
07:04:48 <wli> How dull. Not much more than fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:04:54 <vincenz> wli: not really
07:04:56 <psykotic> it's way more hairy, trust me
07:05:01 <psykotic> wli: try this, then.
07:05:04 <vincenz> wli: there's more interesting case
07:05:08 <vincenz> wli: for instance circular lists
07:05:11 <vincenz> erm
07:05:12 <vincenz> doubly linked lists
07:05:17 <wli> vincenz: That is a circular list.
07:05:22 <mrd> sure, but it's the same principle
07:05:24 <psykotic> suppose you have a collection of labeled nodes with outgoing labeled edges.
07:05:36 <psykotic> data LabeledNode a = Node a [a]
07:06:00 <dons> sometimes i'm kind of surprised at the cool glue haskell provides for manipulating functions. just sipmle things like &&& and *** are missing in other functional languages -- and we're only just realising how to use them to glue functions around.
07:06:09 <wli> vincenz: Um, doubly-linked lists are an intensional affair; they're not definable except via pointer manipulation.
07:06:12 <psykotic> take a list of those, an assignment of nodes to labels, and turn it into a graph, with "pointers" and so on
07:06:18 <vincenz> wli: they are if you tie the knot
07:06:40 <dons> Cale, you know what I mean? for a functional language, it took us an awful long time to start getting used to , say, the (-> a) monad.
07:06:49 <mrd> you can create cyclical graphs in haskell using mutual recursion
07:06:58 <psykotic> mrd: yep, that's the point.
07:07:08 <psykotic> although here you need something like a Map to tie the knot... it's a lot less simpler than doing a doubly linked list, for example.
07:07:21 <psykotic> and the Map needs to be sufficiently lazy
07:07:25 <mrd> and in fibs you use a list to do so
07:07:26 <wli> vincenz: I'm sure that I would dispute the reality of the double linkage.
07:07:35 <mrd> same idea
07:07:45 <psykotic> wli: it's Real.
07:07:55 <wli> Convince me.
07:07:57 <vincenz> psykotic: funny guy :P
07:08:03 <vincenz> double ... real..
07:08:05 <dons> mm, speaking of dlists, i wonder how many people noticed it used an SMP parallel testsuite
07:08:14 <mrd> doubles aren't real!
07:08:31 <vincenz> mrd: they exist, don't they ?!
07:08:50 <psykotic> data Node a = N { label :: a, prev :: DNode a, next :: DNode a}
07:09:18 <dons> looks like an xmonad stack :)
07:09:31 <vincenz> singleton x = let node = N { label = x, prev = node, next = node}
07:09:33 * psykotic switches to emacs, brb to paste
07:09:38 <mrd> well ok, they're real, but only in the subset sense =)
07:09:41 <vincenz> ... in onde
07:09:45 <vincenz> s/onde/node
07:09:48 <vincenz> and then you can move along
07:09:51 <vincenz> and insert at any place
07:09:54 <vincenz> using the doubly linked list idea
07:09:56 <vincenz> O(1) insertion
07:10:00 <dons> hmm, i wonder what the link between differentiated lists and doubly linked lists.
07:10:02 <psykotic> right. and you could make it nonsingular if you had a sentinel for marking ends
07:10:08 <psykotic> err, noncicular
07:10:16 <vincenz> psykotic: circular ++
07:10:31 <vincenz> but ok
07:10:32 <psykotic> :)
07:10:34 <vincenz> if you want
07:10:54 <vincenz> data Node a = N { label :: a, prev :: Node a,, next :: Node a} | M { prev :: Node a, next :: Node a }
07:11:05 <vincenz> now you can embed multiple 'lists' into one structure :)
07:11:25 <wli> Okay, I concede.
07:11:32 <vincenz> even better
07:11:36 <vincenz> if you put extra pointers in M
07:11:41 <vincenz> you can have fast skipping from list to list
07:11:53 <vincenz> hmm
07:11:57 <vincenz> now I wantto make skiplists ..
07:12:00 <xerox> dons: aw mdo isn't available in lambdabot.
07:13:41 <psykotic> wli: now try general graphs with cycles. :)
07:13:44 <vincenz> data SkipList a = N { value :: a, nexts :: [SkipList a] }
07:13:47 <vincenz> \o/
07:13:51 <mathias_> How do I remove QuickCheck-2.0?
07:13:55 <ddarius> insertion is not O(1)
07:14:03 <vincenz> ddarius: in a doubly linked list?
07:14:05 <vincenz> yes it is
07:14:17 <psykotic> wli: you can still use circular definitions, but because of the "shape" of the recursion isn't fixed (unlike the doubly linked list case--the shape of the recursion is dictated by the particular graph) you need to use a data structure to help you tie the knot.
07:14:18 <ddarius> vincenz: Not when you make it via circular programming in Haskell.
07:14:29 <mathias_> (since my other code cannot find coarbitrary anymore)
07:14:31 <vincenz> ddarius: how's that?
07:14:42 <vincenz> oh right, unlinking
07:14:46 <vincenz> ddarius: ammortized O(1)
07:14:52 <wli> psykotic: data Vertex t = Vertex { label :: t , adjacencyList :: [Vertex t] }
07:15:14 <psykotic> wli: you just defined a data structure. :)
07:15:19 <ddarius> Everytime you insert an element, you need to rebuild the whole list.
07:15:24 <psykotic> now try building it
07:15:25 <vincenz> ddarius: it's ammortized O(1)
07:15:42 <wli> psykotic: Building it is difficult, of course.
07:15:52 <psykotic> wli: like, for example, say you have a file containing lines like this: 'A: B C D' which says that vertex with label A is linked to vertices with labels B, C and D.
07:16:19 <psykotic> wli: it's actually surprisingly easy, but a little brain-bending.
07:16:26 <ddarius> vincenz: Maybe if you don't use the list for anything between insertions.
07:16:42 <vincenz> ddarius: whenever you move left or right, you only force recalculation of that element
07:16:48 <vincenz> so that ammortizes into the O(1) of movement
07:17:01 <psykotic> wli: basically you have a Map with labels as keys and vertices as values.
07:17:18 <psykotic> wli: and you define the map in terms of itself, circularly.
07:17:32 <mathias_> ghc-pkg list contains QuickCheck-1.0.1. Why can't ghci find it?
07:19:03 * ddarius can't get a Google cache page of TyingTheKnot
07:20:19 <psykotic> wasn't it moved over to the new wiki?
07:20:52 <psykotic> hmm, looks like it wasn't
07:21:23 <shapr> Was the old wiki removed?
07:21:35 <psykotic> yep
07:21:37 <shapr> aww
07:21:39 <psykotic> kind of annoying
07:21:44 <ddarius> Very annoying!
07:21:54 <psykotic> i always thought the new one was supposed to be a clone
07:22:06 <shapr> The big problem with the old one was that it didn't have an explicit license.
07:22:12 <shapr> I kept meaning to fix that...
07:22:20 <wli> psykotic: No problem. Build up the list of edges in edgeList, then vertices = [Vertex { label = v , adjacencyList = [v' | v' <- vertices, label v' `elem` nub ([v' | v' <- map snd $ filter (first (==v)) edgeList ] ++ [v'| v' <- map fst $ filter (second (==v)) edgeList])]
07:22:30 <ddarius> Stuff was supposed to be hand migrated there but people, for many reasons good and bad, didn't migrate much of the content.
07:22:51 <shapr> matthew-_: ghc-pkg unregister
07:23:03 <shapr> matthew-_: Is 1.0.1 hidden?
07:23:22 <xerox> dons: would it be hard to enable parallel list comprehension and mdo in @run ?
07:23:58 <wli> psykotic: | v <- nub (map fst edgeList ++ map snd edgeList) sorry.
07:24:37 * SamB wishes GHC would work with valgrind's memcheck tool...
07:25:27 <sjanssen> xerox: it'd require extending Language.Haskell to support that syntax
07:25:41 <sjanssen> xerox: or figuring out how to use GHC's parser rather than Language.Haskell
07:25:52 <doserj> ddarius: http://209.85.129.104/search?q=cache:2bMPeBBPsyMJ:haskell.cs.yale.edu/hawiki/TyingTheKnot
07:25:54 <lambdabot> http://tinyurl.com/3b6o6k
07:26:00 <SamB> ddarius: I think one of the main reasons was licensing...
07:26:09 <ddarius> SamB: That's definitely one of them.
07:26:10 <xerox> http://www.lochan.org/2005/keith-cl/pub/TyingTheKnot.html
07:26:12 <lambdabot> Title: TyingTheKnot
07:26:12 <SamB> another may have been that it wasn't made terribly easy
07:26:14 <xerox> sjanssen: ah I see.
07:26:26 <xerox> sjanssen: not quite straightforward.
07:26:33 <SamB> for one thing, you couldn't mark a page on the old wiki to say where it had gone
07:26:38 <sjanssen> xerox: we have to preparse the code before sending it to GHC to avoid code injection attackts
07:26:43 <ddarius> xerox: That copy is very old.
07:26:48 <xerox> ddarius: yes :(
07:27:06 * ddarius points wli at doserj's link.
07:27:33 <dons> xerox: if there's flags specifically for those features
07:27:36 <xerox> http://web.archive.org/web/20030331085702/http://haskell.org/wiki/wiki?TyingTheKnot
07:27:38 <lambdabot> Title: TyingTheKnot, http://tinyurl.com/3anaj5
07:27:43 <dons> xerox: the problem is that they all get turned on with -fglasgow-exts, which isn't safe
07:27:52 <dons> as well as the parser issues
07:28:07 <ddarius> SamB: Whatever the reasons, there is still tons of good stuff on HaWiki that never got migrated.  For example, the whole CommonHaskellIdioms page and it's links.
07:28:10 <SamB> dons: there WILL be
07:28:11 <xerox> ddarius: maybe that's better.
07:28:20 <SamB> ddarius: yeah
07:28:22 <SamB> well, was
07:28:24 <sjanssen> dons: newer LANGUAGE pragmas should allow for finer grained control over extensions
07:28:26 <wli> ddarius: I've been there before. Am I so far off/
07:28:34 <SamB> I guess the data is still there though
07:29:04 <SamB> Igloo said he just took out the redirection from /hawiki to the wiki CGI...
07:29:16 <ddarius> xerox: Better, but still way out of date.
07:29:30 * SamB walks the dog
07:30:24 <ddarius> wli: I was originally going to reference it simply for the more interesting example of using circular programming for dealing with forward references.
07:31:05 <wli> psykotic: The code appears to work with minor syntax cleanups (missing/misplaced parens, s/first (==v)/(==v) . fst/, etc.)
07:31:26 <psykotic> wli: yep, the idea is sound.
07:31:37 <vincenz> I think the sound is more picture
07:31:39 <vincenz> erm
07:31:39 <vincenz> the iidea
07:31:41 <thepointer> http://hpaste.org/2111
07:31:46 <vincenz> sound is so 90s
07:31:47 <thepointer> i'm 'very' new to haskell
07:32:07 <hpaste>  Hyjiskalakwe pasted "ge microwave oven turntable" at http://hpaste.org/2112
07:32:08 <thepointer> i don't properly understand how function types are described, and not sure what the error means
07:32:21 <hpaste>  wli pasted "cyclic graph structure" at http://hpaste.org/2113
07:32:26 <xerox> > round (logBase 10 (fromInteger (31337 :: Integer)))
07:32:27 <vincenz> @type f x = round logBase 10 . fromInteger $ x
07:32:28 <lambdabot>  4
07:32:29 <lambdabot> parse error on input `='
07:32:36 <vincenz> @type let f x = round logBase 10 . fromInteger $ x in f
07:32:38 <lambdabot>     No instance for (RealFrac (a -> a -> a))
07:32:38 <lambdabot>       arising from use of `round' at <interactive>:1:10-25
07:32:42 <xerox> missed a . :)
07:32:47 <vincenz> @type let f x = round.  logBase 10 . fromInteger $ x in f
07:32:48 <vincenz> xerox: thx
07:32:49 <lambdabot> forall b. (Integral b) => Integer -> b
07:33:04 <wli> ddarius/psykotic/vincenz: I don't believe this is an area where I have trouble.
07:33:40 <thepointer> hrmm
07:34:06 <EvilTerran> ... have the spammers started getting 'round the filter again?
07:34:12 <thepointer> i'd actually want it to be: digits n = round (logBase 10 n) + 1
07:34:20 <wli> dons: How is the splitting up of -fglasgow-exts into things one can turn on and off individually going?
07:34:22 <EvilTerran> @seen glguy
07:34:22 <lambdabot> I saw glguy leaving #haskell 5h 17m 35s ago, and .
07:34:48 <Igloo> wli: It is complete
07:34:52 <mrd> there is some kind of LanguageFeature option you can use
07:34:54 <EvilTerran> @tell glguy more spam? http://hpaste.org/2112
07:34:54 <lambdabot> Consider it noted.
07:34:54 <wli> Igloo: Awesome!
07:35:00 <xerox> thepointer: digits n | n < 0 = digits (negate n) | n == 0 = 0 | n > 0 = 1 + round (logBase 10 (fromIntegral n))
07:35:01 <mrd> not sure where the docs are
07:35:52 <wli> How about a divide and conquer radix conversion algorithm? ;)
07:35:55 <thepointer> so logBase needs two floats as input?
07:35:56 <xerox> thepointer: must be careful with the doman of log :)
07:36:00 <xerox> Yup.
07:36:29 <thepointer> i think my core problem is i dont understand how function types are described
07:36:30 <xerox> They must also be of the same floating point type, as enforced by its type signature logBase :: (Floating a) => a -> a -> a.
07:36:32 <thepointer> in documentation
07:37:01 <thepointer> ah ok.. so the 10 can automatically be changed to floating by the compiler
07:37:19 <xerox> thepointer: The contexts before => you can read them e.g. (Foo a) means "a is a member of Foo", where a is a type, and Foo a set of types.
07:37:23 <EvilTerran> mrd, wli, http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma ?
07:37:24 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/ysbfs7
07:37:37 <mrd> yea
07:37:49 <thepointer> is Foo called a class in that case?
07:37:58 <mrd> do you need 6.6.1 for that?
07:38:13 <xerox> thepointer: a type class, yes. You can use :info Foo in GHCi to see what types are in Foo at a given moment in time.
07:38:27 <thepointer> ah ok
07:38:29 <wli> EvilTerran: Why are you pointing me at that? (I'm sure it'll be informative, though.)
07:38:32 <mnislaih> anyone knows of a Test.QuickCheck.Batch implementation for QuickCheck 2.0 ?
07:38:38 <thepointer> awesome, i'll work with it from here
07:38:39 <mrd> wli: split up extensions
07:38:40 <EvilTerran> 1532<wli> dons: How is the splitting up of -fglasgow-exts into things one can turn on and off individually going?
07:38:44 <thepointer> thanks very much xerox
07:38:50 <xerox> thepointer: you're very welcome :)
07:38:56 <wli> EvilTerran: Aha.
07:39:46 <wli> What's a nice, efficient way to find logBase 2 of an integer, or otherwise the highest significant bit...
07:40:02 <wli> An Integer, even.
07:40:41 <mrd> highest significant bit? Data.Bits?
07:40:42 <wli> I can't be arsed. jstor apparently has it.
07:41:04 <quicksilver> wli: to be realy efficient you'd need to hook into the right gmp call, I think
07:41:05 <wli> mrd: There's no special method and bitSize for Integer just throws an exception.
07:41:13 <mrd> ugh
07:41:20 <wli> quicksilver: Yeah.
07:41:40 <xerox> bitSize :: a -> Int
07:41:41 <xerox> Return the number of bits in the type of the argument. The actual value of the argument is ignored. The function bitSize is undefined for types that do not have a fixed bitsize, like Integer.
07:41:53 <quicksilver> wli: if you don't care that much I'd just compare against increasing powers of two
07:42:03 <quicksilver> wli: or repeatedly divide by two
07:42:12 <quicksilver> wli: I suspect the former is probably faster but I'm often wrong
07:42:24 <wli> quicksilver: shiftL
07:42:47 <quicksilver> I don't know if shiftL has an efficient gmp implementation
07:42:50 <quicksilver> if it does, then yes
07:43:09 <wli> quicksilver: Worst case they're raising 2 to powers internally.
07:43:10 <thepointer> btw xerox: would you have used the technique i did to find how many digits in a number?
07:43:23 <quicksilver> > length . takeWhile (>0) . iterate (`shiftR` 1) $ 1000
07:43:24 <lambdabot>  10
07:43:30 <quicksilver> wli: that's not a bad start
07:43:31 <xerox> thepointer: yeah that's fine.
07:44:21 <quicksilver> wli:  you can optimise later if it's too slow
07:44:30 <thepointer> xerox: i had a thought just now that maybe converting to string then finding the length could be better (my concepts from other languages)
07:44:47 <quicksilver> wli: (one of the nice thing about functions with very obvious exact semantics is you know you can swap them out later for a hand-optimised version without changing the semantics of your code)
07:46:21 <ddarius> Depending on the invariants on the representation, you might be able to get it quickly by breaking open the Integers.
07:47:00 <wli> Yeah, that's the winning approach. Scan the array from its upper bound.
07:47:27 <ddarius> wli: If the array is as small as possible, then you should only need to check the highest byte.
07:48:14 <wli> ddarius: It probably won't be aligned quite that well, and the termination condition is just an inequality test anyway.
07:49:06 <wli> If unboxed boolean arrays are implemented as bits anyway, why do we bother with gmp again?
07:49:15 <dons> Igloo: we should send invites to the SoC guys ASAP?
07:49:41 <xerox> > until ((<=0).fst) ((`shiftR` 1)***(+1)) (10,0) :: (Integer,Int) -- wli
07:49:42 <lambdabot>  (0,4)
07:49:50 <xerox> snd . :)
07:50:05 <wli> xerox: Very pretty.
07:50:26 <dons> until is under used
07:50:35 * xerox nods
07:50:46 <xerox> dons: invites for what?
07:51:06 <quicksilver> I don't know if I prefer wlis version
07:51:19 <dons> hackathon
07:51:21 <quicksilver> I actually like the way my version implicitly counts by using length and the list
07:51:32 <dons> Igloo: do you think you could do that today?
07:51:35 <xerox> dons: good idea :)
07:51:39 <sjanssen> @type until
07:51:41 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:51:45 <dons> yeah xerox, its in Freiburg. just around the corner
07:51:55 <dons> ?go haskell hackathon freiburg
07:51:57 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg20369.html
07:51:57 <lambdabot> Title: [Haskell] ANNOUNCE: Haskell Hackathon 07 II: Freiburg: Oct 5-7
07:51:59 <xerox> 280km for me, I think I'll be there.
07:52:12 <dons> xerox: check the page, send your registration details. you can go to the haskell workshop too
07:52:26 <vincenz> dons: it moved?
07:52:44 <dons> ?
07:53:13 <vincenz> nm, I thought it was earlier
07:53:17 <vincenz> dons: is there housing?
07:53:39 <dons> there's backpackers, hotels etc. you can organise with other people attending (see the page) to split a room
07:53:58 <vincenz> I admit I'm very tempted
07:54:24 <dons> yeah, we've got lots of space this time, up to 50. so you euro guys in the area should think hard about it :)
07:54:27 <xerox> dons: you'll arrive from .au too?
07:54:37 <dons> well, i'll be there for ICFP and HW anyway
07:54:44 <xerox> Cool.
07:54:56 <thepointer> im aus
07:55:15 <dons> hey thepointer
07:55:20 <dons> learning haskell this session?
07:55:31 <thepointer> yeah.. uni course
07:55:35 <dons> at unsw?
07:55:37 <ddarius> wli: Don't we use GMP for the algorithms.
07:55:44 <thepointer> nah griffith uni in brisbane
07:55:53 <wli> ddarius: Interesting. What is it used for?
07:56:07 <dons> thepointer: ah interesitng. didn't know haskell was taught up there. cool
07:56:14 <dons> thepointer: good place to hang out to pick up tricks and tips
07:56:21 <thepointer> this place?
07:56:22 <dons> anyway, late now. bedtime.
07:56:24 <dons> thepointer: yeah
07:56:35 <dons> nytol
07:56:45 <thepointer> no idea what nytol means, but night
07:56:48 <ddarius> wli: All Integer manipulations (? am I misunderstanding the question?)
07:58:09 <ptolomy> Hm.. so is pointer tagging now fully implemented in GHC head?
07:58:17 <vincenz> dons: how does the organisation work
07:58:45 <mux> what's pointer tagging?
07:59:24 <vincenz> ah, ,too late
07:59:27 <vincenz> dcoutts: you around?
07:59:33 <vincenz> Lemmih: or you?
07:59:42 <dcoutts> vincenz: yerp
07:59:52 * Lemmih is here but slightly out of phase.
08:00:10 <vincenz> how does the organization at the hackathon workk?
08:00:45 <sjanssen> ptolomy: I think so, I remember seeing the patch fly by the mailing list
08:00:55 * quicksilver laughs at "generating 10 random grids takes about 1 second, solving an actual puzzle should be faster because the solution space is more tightly constrained"
08:01:22 <dcoutts> vincenz: we have some people who are vaguely resonsible for organising, do you have a more specific question? :-)
08:01:27 <ptolomy> sjanssen:  Yeah, I saw that too, but I also seem to remember hearing about it earlier. I'm pretty excited about it, but I want to restrain myself until I'm sure it is official and I hear some first-hand account. :)
08:01:48 <vincenz> dcoutts: well yes, let's say that me, joe-schmoe arrives there...
08:01:54 <vincenz> dcoutts: then what, I just sit down and hack on my own thing?
08:02:06 <dcoutts> vincenz: if you want to, but it'd be nice to collaberate
08:02:15 <vincenz> dcoutts: right, so how does that work?
08:02:22 <sjanssen> ptolomy: well, a darcs patch from one of the Simons that says "This implements pointer tagging as seen in our paper" is pretty official, I think :)
08:03:04 <mux> if you guys could explain to me what pointer tagging is, I'll join the fun and get excited about it with you!
08:03:07 <ptolomy> I suppose so. :) The improvements it claims are... exciting.
08:03:09 <quicksilver> ptolomy: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
08:03:12 <quicksilver> ?
08:03:12 <lambdabot> Title: Commentary/Rts/HaskellExecution/PointerTagging - GHC - Trac, http://tinyurl.com/3b6bw7
08:03:13 <dcoutts> vincenz: well we are all there in one room with wifi so we can get together in groups and discuss stuff and hack on things
08:03:14 <ptolomy> mux: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
08:03:15 <lambdabot> Title: Commentary/Rts/HaskellExecution/PointerTagging - GHC - Trac, http://tinyurl.com/3b6bw7
08:03:17 <mux> thanks :-)
08:03:20 <ptolomy> oh. Heh.
08:03:22 <quicksilver> heh :)
08:03:38 <vincenz> dcoutts: so first there's some generic introductory session, to get to know people, and then a generic meeting with everyone to say who works on what?
08:04:12 * ptolomy is practically philosophically skeptical when it comes to things that delight him. "Okay, you've shown it to me, proven it to me, but how do I know this isn't just a magnificent dream?"
08:05:56 <quicksilver> I wonder which version it went into
08:07:19 <vincenz> dcoutts: just not sure how you get the right people working with the right people, especially if new people show up that don't know all the people face2face (for instance, me)
08:07:54 <Lycurgus> ptolomy: is yours a more than methodological solipsism?
08:09:16 <ptolomy> I think.. no.
08:10:01 <Lycurgus> pointer tagging best done in hardware (like the Burroughs machines did/do)
08:10:10 * ptolomy really needs to bone up on his epistemology.
08:10:36 <ptolomy> If somebody can make GHC do pointer tagging on my hardware, I'll give them $5.
08:10:46 <quicksilver> Lycurgus: it's still a handy optimisation even done in software
08:11:03 <dcoutts> vincenz: right, we introduce everyone, people say what they're interested in working on and we get into smaller groups
08:11:10 <vincenz> dcoutts: ah, thanks :)
08:11:11 <dcoutts> vincenz: people flit from one thing to another too
08:11:20 <vincenz> dcoutts: I was more scared of arriving there and not knowing where to start
08:13:03 <dcoutts> vincenz: right, well there will be plenty of things to do
08:13:53 <vincenz> thanks :)
08:14:00 <wli> quicksilver: boundBits n = let boundBits' (p@(n,shft),_) = let shft' | shft == 0 = 1 | otherwise = 2*shft ; p' = (shiftR n (shft' - shft), shft') in (p',p) in let ((_,hi),(_,lo)) = until ((<=0) . fst . fst) boundBits' ((n, 0), undefined) in (lo, hi)
08:14:15 <vincenz> dcoutts: not so muchthat there's plenty to do, just more of how to get started, but since you have a premeeting ... that's ok :)
08:14:30 <dcoutts> @arr!
08:14:30 <lambdabot> Shiver me timbers!
08:14:51 <quicksilver> wli: heh :)
08:15:04 <dylan> Siver me thimbers!
08:19:34 <malsyned> Does a fixity declaration have to precede any use of that operator?
08:19:57 <malsyned> lexically precede, I mean.
08:20:11 <quicksilver> I don't believe so no
08:20:18 <quicksilver> as long as it's in the right scope
08:20:25 <quicksilver> fixity declarations can, I believe, be local
08:20:50 <ddarius> yep
08:20:56 <malsyned> that's got to make parsing Haskell tricky.
08:21:10 <vincenz> how so?
08:21:14 <vincenz> first parse top-decls
08:21:16 <vincenz> then parse exprs
08:21:25 <malsyned> I guess by "tricky" I meant "not one-pass"
08:21:37 <vincenz> one-pass compilers are prematurely optimized.
08:22:16 <quicksilver> in a lazy language the different between one-pass and multi-pass is much less obvious to the program
08:22:34 <ari> Pah, quicksilver
08:22:34 <quicksilver> demand-driven evaluation means you have to worry less
08:22:45 <quicksilver> I meant 'programmer' not 'program' :)
08:22:50 <ari> I was about to say "You could always pretend to compile in one pass but really steal stuff from the future" :(
08:22:51 <malsyned> right.
08:23:39 <malsyned> But you'd have to parse the exps just enough to tell where they ended, then go back and re-parse them with fixities taken into account.
08:23:42 <malsyned> wouldn't you?
08:24:31 <sjanssen> malsyned: usually, all operators are parsed as if they're "infixr 0"
08:24:52 <Philippa_> vincenz: in some languages, a single pass is a lot easier to write until you hit a certain level of complexity
08:25:12 <sjanssen> then, once you've got fixity information for each identifier, the compiler repairs the parse tree
08:26:31 <malsyned> does assuming them all to be infixr 0 instead of infixl 0 make that transformation more natural?
08:26:33 <quicksilver> except you don't actually have to separate concerns in such a visible way
08:26:34 <vincenz> Philippa_: yeah, in some languages, GOTO is easier than proper control structures :)
08:26:48 <quicksilver> if you are writing your compiler in haskell
08:26:56 <quicksilver> you can just 'steal the fixities from the future'
08:27:02 <quicksilver> as ari said
08:27:22 <malsyned> well, now I'm going to have to resist reading the ghc source instead of doing my job all day.
08:27:41 <ddarius> malsyned: Read some, that should solve that quickly.
08:27:43 <quicksilver> but it's quite natural not to think of fixity work as part of the parse
08:27:55 <quicksilver> you parse into something which looks like
08:28:07 <quicksilver> infixexpr = expr op expr op expr op expr op expr
08:28:17 <quicksilver> and then you transform that later into an expression tree
08:28:21 <vincenz> right
08:28:24 <vincenz> you parse it as a list :)
08:28:27 <vincenz> thne use the Fixity module
08:28:30 <vincenz> which comes with GHC
08:28:34 <vincenz> whch is REALLY easy to use
08:28:39 <quicksilver> keeping the form which 'looks like' the source for longer
08:28:45 <quicksilver> helps with good error messages too
08:28:58 <quicksilver> although admittedly, really good error messages in complex parsers are HARD
08:29:01 <vincenz> that's how I have a very generic parsing system that easily extends to other languages :)
08:29:07 <vincenz> I can just define my fixities and operators in a table
08:29:08 <quicksilver> it's so easy to write a very powerful parser
08:29:10 <vincenz> instead of altering my rules
08:29:13 <quicksilver> and not have good provision for errors :)
08:29:35 <vincenz> quicksilver: I think error handling is an underestimated cost of compilers
08:29:52 <quicksilver> I've written quite a few compilers in my time
08:30:01 <quicksilver> without exception, their error handler was dire to awful
08:30:02 <quicksilver> :)
08:30:13 * vincenz idems
08:30:19 <quicksilver> partly because I'm lazy and they were never intended to be used by anyone except me
08:30:26 <quicksilver> and partly just because it's hard to do it right
08:31:39 <malsyned> I'm always impressed by compiler writers who bother to try to continue after the first error in order to give you further errors.
08:32:16 <malsyned> they're doing extra work in order to accommodate a program which is never going to compile anyway.
08:32:21 <vincenz> quicksilver: I'm sure there's some pattern there that has not been grasped yet that will make error handling in compilres much better
08:32:27 <vincenz> s/better/easier
08:32:28 <quicksilver> I really wish ghc (well, especially ghci) would compile the 'maximal working' subset of definitions in a file
08:32:35 <quicksilver> when I have a type error in foo
08:32:44 <quicksilver> I want to be able to inspect the types of subexpressions in foo
08:32:48 <quicksilver> and see where I went wrong
08:32:56 <quicksilver> so I want other definitons (as far as possible) loaded
08:33:52 <malsyned> here here.
08:36:48 <dcoutts> quicksilver: yes that'd be cool for an IDE but it's a lot of work in the ghc front end I think
08:37:44 <quicksilver> dcoutts: it would be cool even without an IDE
08:37:49 <quicksilver> dcoutts: with an ide it would be cooler
08:38:15 <quicksilver> dcoutts: given a parser it wouldn't be hard to binary chop the definitions in the top level
08:38:26 <quicksilver> dcoutts: searching for a maximal compiling subset
08:38:49 <quicksilver> dcoutts: given a parser + a scope analyzer, it wouldn't be hard to produce a dependency graph and do it properly
08:39:23 <dcoutts> quicksilver: it should be easier than that, with a recoverable parser, one just does name analysis to see which definitions are complete and don't depend on borken things
08:39:26 <dcoutts> right
08:39:40 <dcoutts> and one can subsitute some broken things for undefined
08:39:57 <quicksilver> I'm not even suggesting it should recover from broken parses
08:40:06 <quicksilver> it would be enough to cope with a correct parse, but a type error
08:45:59 <hpaste>  wli pasted "bitreversal etc. for Integer" at http://hpaste.org/2114
08:46:27 <quicksilver> wli: continuing your search for programs which are palindromic at the bit-level? :)
08:46:46 <wli> quicksilver: No, it's just useful.
08:47:01 <quicksilver> well yes, I was joking...
08:58:27 <roconnor> > sum [48, 80, 28, 96] `div` 4
08:58:30 <lambdabot>  63
09:06:29 <lament> Bullies at school used to tease little Huet: "Hey fool, your zipper's undone and the monad's sticking out!"
09:06:47 <quicksilver> !
09:06:59 <mux> lol
09:07:22 <kolmodin> :D
09:07:55 <cjeris> @remember lament Bullies at school used to tease little Huet: "Hey fool, your zipper's undone and the monad's sticking out!"
09:07:55 <lambdabot> Done.
09:24:28 <hpaste>  wli annotated "bitreversal etc. for Integer" with "divide and conquer gone wrong" at http://hpaste.org/2114#a1
09:41:28 <quicksilver> oh nice, another DB lazines thread I can get angry about!
09:41:33 <quicksilver> I missed that one...
09:51:50 <matthew-_> mmm. overflow of numeric values seems not to be defined in haskell98 report
09:52:41 <glguy> here there be dragons?
09:52:41 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:53:29 <glguy> @tell EvilTerran maybe it is spam... but it isn't particularly effective spam :)
09:53:29 <lambdabot> Consider it noted.
09:53:44 <EvilTerran> i'm here! i'm here!
09:53:44 <lambdabot> EvilTerran: You have 1 new message. '/msg lambdabot @messages' to read it.
09:53:47 <EvilTerran> @messages
09:53:48 <lambdabot> glguy said 19s ago: maybe it is spam... but it isn't particularly effective spam :)
09:54:20 <glguy> all gone
09:54:45 <EvilTerran> i do wonder about the large amounts of meaningless spam.
09:55:00 <glguy> when I saw that... I was compelled to buy a microwave oven, however
09:55:16 <EvilTerran> i guess either it's incompetence or people trying to confuse bayesian filters
09:55:38 <EvilTerran> either that or the internet is becoming sentient and trying to communicate with us O.o
09:56:07 <wli> EvilTerran: Perhaps methods superior to Bayesian filtering should be devised.
09:56:08 <ricky_clarkson> The internet *is* a PHP programmer?
09:56:14 <glguy> I love when you are using a program and you think *man... I wish it had this one feature* and then you open your eyes and it does!
09:59:41 <glguy> how do I specify in a make file that an action should always be run
09:59:56 <glguy> so that ghc --make can decide how much work to do
10:00:07 <glguy> instead of make needing to be told all of the dependencies of something
10:00:23 <dylan> .PHONY: build
10:00:24 <EvilTerran> .PHONY: your-target
10:00:32 <dylan> build:\n\tghc --make
10:00:42 <glguy> wonderful, thanks
10:01:02 <EvilTerran> if you want it to always happen regardless of which target you start at, you also want
10:01:04 <EvilTerran> *: your-target
10:01:33 <EvilTerran> (might be useful for version control or something)
10:01:46 <glguy> so... is there a HsMake where you specify your make information as a Haskell script
10:01:56 * EvilTerran goes away
10:01:59 <glguy> and just run it with runghc as a #! at the top?
10:04:58 <malsyned> Is there a more up-to-date description of Template Haskell than SPJ's 2002 paper?  In particular, have any of the suggestions from "A Report from the Field" been implemented?
10:06:48 <malsyned> @where th
10:06:48 <lambdabot> http://www.haskell.org/th
10:07:37 <SamB> malsyned: let me look at that again
10:08:13 <DaveCGI378> so i read the http://en.wikibooks.org/wiki/Haskell/Understanding_monads , and to be honest it looks like a way to pass around extra data implicitly from the random #s example. what does it have to do with doings things "in order" ?
10:09:58 <desegnis> Dave, well I have not (yet) read that article, but passing something around means doing things in order because you pass something around from somewhere to somewhere else, so you have Â»somewhereÂ« before Â»somewhere elseÂ«
10:10:06 <shapr> DaveCGI378: Haskell has no execution order specified, but you can specify order with (a -> m b) expanding to (a -> m (b -> m c)) etc
10:10:37 <DaveCGI378> shapr: i am not sure i can quite grasp that yet, are there any good examples of that
10:11:26 <DaveCGI378> although i do remember right associativity meaning you can beta reduce less
10:11:30 <shapr> DaveCGI378: You can easily get 'order' by making sure that the next function gets called by the previous function, right?
10:11:57 <Igloo> DaveCGI378: The way you get evaluation order is to write primitives like putStr that evaluate the bit of "extra data" they are passed before actually putting the string on the screen
10:12:30 <SamB> malsyned: hmm, for 2.3: it doesn't have name splicing, and you still can't call things defined in the same module, but not within the splice
10:12:42 <Igloo> DaveCGI378: In actual fact that bit of extra data doesn't exist in the final code, but conceptually it does (and it does as a Haskell value until the last stage of the compiler)
10:13:06 <SamB> malsyned: for 3.3: there is now a "reify" function
10:13:08 <SamB> @hoogle reify
10:13:09 <lambdabot> Language.Haskell.TH.reify :: Name -> Q Info
10:13:09 <lambdabot> Language.Haskell.TH.Syntax.qReify :: Quasi m => Name -> m Info
10:13:39 <SamB> oh, btw, if you want to write this on a wiki page, go ahead
10:14:53 <DaveCGI378> shapr: I think I see...the (b -> m c) will never be evaluated until the outer (a -> m (...)) begins to be evaluated
10:15:06 <monochrom> @tell dons the monochrom quote in HWN is an age-old one! :)
10:15:06 <lambdabot> Consider it noted.
10:15:17 <SamB> malsyned: I get the impression that TH is still ignorant of whether a data constructor has been declared in infix or prefix form
10:15:45 <SamB> malsyned: at least, Data.Derive.{Read,Show} don't act on that...
10:15:46 <arpa121> hi I'm new in haskell what is haskell ?
10:16:02 <arpa121> !haskell
10:16:07 <SamB> 'tis a fun programming language
10:16:08 <DaveCGI378> haskell is cool
10:16:11 <DRMacIver> Hm. :)
10:16:12 <SamB> functional, too
10:16:18 <DaveCGI378> shapr: so if you wanted to program sequentially you would do it in that style ?
10:16:19 <DRMacIver> Interesting advantages of having a language geek for a CTO.
10:16:20 <malsyned> arpa121: from the home page haskell.org: "Haskell is a general purpose, purely functional programming language featuring static typing, higher order functions, polymorphism, type classes, and monadic effects. Haskell compilers are freely available for almost any computer."
10:16:37 <DRMacIver> < coworker> I think we should write this project in Skala. < cto> Hm. That's an interesting idea. I'll take a look at the language.
10:16:39 <SamB> malsyned: hmm. that doesn't say anything about Haskell being fun
10:16:51 <arpa121> cool
10:16:56 <malsyned> SamB: There's an "Edit this page" link ;)
10:17:19 <SamB> malsyned: what page though?
10:17:27 <malsyned> http://haskell.org/haskellwiki/Haskell
10:17:28 <lambdabot> Title: Haskell - HaskellWiki
10:17:36 <SamB> oh, that
10:17:43 <SamB> I thought we were talking about th still ;-)
10:18:07 <malsyned> nope.  I was responding to your criticism of the quote as not saying that Haskell is fun.
10:18:17 <monochrom> Hmm. HWN issue 64! 2^6!
10:18:21 <shapr> DaveCGI378: Yeah, that's how the ordering is forced. But there's more to monads than ordering.
10:18:40 <SamB> yeah. figured that out from the URL ;-)
10:19:03 <DaveCGI378> shapr: the ordering was really the most important to me, since obviously you want the IO to be done before the IO processing stuff is invoked
10:19:27 <DaveCGI378> shapr: what else is there besides carrying state and ordering?
10:19:56 <shapr> Well, monads are an abstraction like objects are an abstraction.
10:20:05 <malsyned> SamB: I'm going to have to digest the haddock page for TH before I know whether I have other questions.
10:20:08 <malsyned> thanks for it.
10:20:17 <DaveCGI378> shapr: great.. a whole new paradigm to learn :-)
10:20:48 <shapr> DaveCGI378: Yup, exactly. Look at the Maybe monad. It's not really about ordering or state carrying, it's about ... well...
10:20:51 <malsyned> DaveCGI378: one of my favorite applications of monads are the way the list monad and Maybe monad work.  I don't think those have much at all to do with state or ordering.
10:21:21 <DaveCGI378> shapr: i read about that, how is that different then the SML          type Option = Some 'a | Nothing ?
10:21:30 <malsyned> shapr: How would you describe how those monads are used?  as functors?
10:21:49 <lament> DaveCGI378: all a type needs to be monadic is provide three functions obeying simple laws. These functions can do many different things, so intuition about one monadic type doesn't necessarily apply to another.
10:21:59 <malsyned> DaveCGI378: there's the Maybe type, which is just what you've described.  but Maybe is also declared as an instance of Monad, so you can use do notation to interesting effect.
10:22:19 <lament> s/three functions/two functions
10:22:20 <rubyruy> I'm  trying to actually write some haskel code for the first time... are values returned by actions for-ever trapped to being tagged as "IO" ? How does one do anything useful with them ?
10:22:38 <wli> rubyruy: Monad transformers.
10:22:40 <DaveCGI378> lament: but surely they all impose order and allow you to pass nested functions :)
10:23:02 <malsyned> > (\x -> do {contents <- x; return (contents + 1)}) (Just 5)
10:23:06 <lament> rubyruy: x <- getLine  -- x is a string, not at all IO
10:23:07 <lambdabot>  Just 6
10:23:13 <malsyned> > (\x -> do {contents <- x; return (contents + 1)}) Nothing
10:23:14 <lambdabot>  Nothing
10:23:28 <olsner> > fmap (+1) (Just 5)
10:23:30 <lambdabot>  Just 6
10:23:32 <ricky_clarkson> rubyruy: IO isn't something you need to escape from.
10:24:00 <malsyned> olsner: right.  but I was trying to demonstrate using "do" notation for a monad that wasn't about imposing ordering or passing functions.
10:24:42 <rubyruy> but when writing my own actions, do i not have to use return to get anything back? (which in turn transforms any type a into IO a ?
10:25:05 <DaveCGI378> monads sound hard to really understand well.
10:25:19 <malsyned> > (\l -> do {item <- list; return (item + 1)}) [1, 4, 15]
10:25:21 <lambdabot>   Not in scope: `list'
10:25:25 <olsner> malsyned: yeah.. just got an urge ;-)
10:25:27 <malsyned> > (\l -> do {item <- l; return (item + 1)}) [1, 4, 15]
10:25:29 <lambdabot>  [2,5,16]
10:25:32 <lament> DaveCGI378: instead, it might be more profitable to try to understand _specific_ monadic types
10:25:48 <lament> DaveCGI378: look at the Maybe monad and how return and >>= are implemented for it
10:25:58 <DaveCGI378> sure if that helps me understad monads in general
10:26:37 <shapr> DaveCGI378: Nah, they're pretty easy to understand.
10:26:58 <DaveCGI378> shapr: yeah well i think classes are pretty easy to understand, and they all seemed very hard to me before i learned them
10:27:03 <desegnis> rubyruy, you only have to use the IO monad when doing IO. otherwise, just keep with pure functions, which you may then use from your IO actions
10:27:53 <shapr> DaveCGI378: Well, keep in mind that monads are extremely easy to understand. The simple three law definition is all of it. The exciting part is how much stuff you can do with them!
10:28:10 <shapr> DaveCGI378: Have you read http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html and http://www.haskell.org/all_about_monads/html/ ?
10:28:12 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
10:28:15 <DaveCGI378> shapr: fine!!! i must go grab a haskell interpreter then
10:28:22 <malsyned> I agree with shapr that you're better off understanding various monads than you are trying to understand "Monads".  The monadic interface is so abstract as to be nearly impossible to describe.
10:28:25 <arpa121> I think haskell is powerfull tools for hardware coding isn't it?
10:28:29 <DaveCGI378> is there a haskell in a box or something like that?
10:28:44 <malsyned> DaveCGI378: install GHC and then run GHCi to get an interpter.
10:28:45 <wolverian> hm, nice, hxt got pickling and unpickling. too bad I have no idea how to use that feature :(
10:28:52 <malsyned> s/interpter/interpreter/
10:29:40 <malsyned> DaveCGI378: or just type lines starting with >  into #haskell and have lambdabot do the work ;)
10:29:42 <arpa121> where can Download best compiler for haskell ? please help
10:29:46 <arpa121> !Compiler
10:30:04 <DaveCGI378> can you overload haskell functions?
10:30:08 <hkBst> !ghc
10:30:13 <arpa121> !ghc
10:30:15 <hkBst> @where ghc
10:30:15 <lambdabot> http://haskell.org/ghc
10:30:31 <lament> DaveCGI378: okay, step 1 for understanding monads: You need to understand functions, types and type classes first :)
10:30:56 <DaveCGI378> mmm yeah, i use sml before so i figure id jump right in
10:31:06 <lament> does sml have type classes?
10:31:18 <DaveCGI378> dont think so
10:31:22 <SamB> what's the mediawiki for a line through something?
10:31:22 <DaveCGI378> whats a type class?
10:31:28 <lament> DaveCGI378: then that's what you should look at first.
10:31:48 <lament> (because monadic types are just instances of the type class Monad)
10:31:51 <DaveCGI378> is there a haskell EXE for windows that i can run and it will give me everything
10:32:03 <lament> DaveCGI378: yes, google for ghc.
10:32:39 <glguy_> DaveCGI378: if you are allergic to console applications, there is WinHugs and Visual haskell for visual studio (you'll want to get over that allergy eventually though)
10:34:27 <DaveCGI378> glguy_ im not allergic, i just running on windows right now (left my linux laptop at home) and dont want to go through a hassle
10:37:27 <arpa121> some one could come to PM I have to many question in haskell I'm new in haskell help me plz
10:37:46 <malsyned> arpa121: why are you interested in Haskell?
10:37:54 <malsyned> arpa121: and have you read any of the Haskell tutorials?
10:37:59 <malsyned> @where yaht
10:37:59 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:38:05 <malsyned> that tutorial is a good place to start.
10:38:18 <glguy> arpa121: #haskell loves to answer questions, feel free to post directly
10:38:27 <malsyned> DaveCGI378: http://www.haskell.org/ghc/download_ghc_661.html#windows
10:38:28 <lambdabot> Title: GHC: Download version 6.6.1
10:38:29 <arpa121> I don't know anything about haskell - I only read somehting abou that in haskell.org but i have too many question about that
10:38:42 <malsyned> arpa121: what's your level of programming experience?
10:38:48 <arpa121> My question is what we can do with haskell specially ?
10:39:00 <DaveCGI378> oooh type classes are neat
10:39:05 <lament> arpa121: Write programs
10:39:07 <arpa121> malsyned I'm MCSD I'm professional in .NET
10:39:08 <malsyned> DaveCGI378: correct!  they're my favorite.
10:39:15 <earthy> arpa121: we can program without having to worry about side effects most of the time
10:39:18 <nopcode> arpa121: rotfl
10:39:34 <DaveCGI378> arpa121: if you like C# 3.0 you will love haskell
10:39:44 <arpa121> I love C#
10:39:51 <arpa121> C# is my life
10:39:53 <earthy> the ideas of LINQ actually gestated in Haskell
10:39:57 <malsyned> arpa121: probably the most interesting thing to me about Haskell is that it is lazily evaluated, so you can deal with potentially infinite data structures.  Also, although this isn't quite as revolutionary, first-class functions allow a lot of concise solutions.
10:39:59 <DaveCGI378> 3.0 though?
10:39:59 <arpa121> really ?
10:40:04 <earthy> but came to full fruition in C#
10:40:15 <arpa121> LINQ is amazing thing in .NET
10:40:18 <earthy> arpa121: the name Erik Meijer mean anything to you?
10:40:18 <arpa121> I love lINQ
10:40:22 <ndm> I love C#, but a lot of the things going into C# 3.0 feel a bit hacky
10:40:27 <DaveCGI378> a lot of new C# features are borrowed from functional languages such as haskell
10:40:36 <lament> arpa121: for a simple example of what haskell can do that other languages have probelms with: [1..] is a list containing all natural numbers from 1 up
10:40:43 <ndm> things like the type inference in C# aren't as principled, general or predictable as in haskell
10:41:14 <olsner> C# has type inference?
10:41:16 <ndm> and things like inheritance, interfaces, base classes etc. can all start to make semantics non-intuitive
10:41:28 <drigz> olsner: will do, apparently
10:41:31 <ndm> olsner: in 3.0, in a limited number of circumstances
10:41:40 <ndm> in particular in lambda's it has type inference
10:41:42 <DaveCGI378> type inference in C# kind of sucks since expressions need to be bound to a delegate, and you can have multiple delegates with different type parameters that actually represent the same type
10:41:47 <arpa121> OK , how can I learn haskell ? do you have any recommand book ?
10:41:48 <glguy> very limited local inference
10:41:59 <earthy> arpa121: The Haskell School of Expression is good.
10:42:07 <drigz> arpa121: Yet Another Haskell Tutorial is often recommended
10:42:07 <arpa121> where is that?
10:42:07 <earthy> but the haskell tutorials on haskell.org/learning are also good
10:42:17 <DaveCGI378> they could've just had canonic type delegates imho
10:42:20 <olsner> seems I actually may have to learn C# in order to hate it properly
10:42:33 <nopcode> why is everyone jumping on the M$ bandwagon?
10:42:38 <DaveCGI378> olsner: you cant be hating C#, they have too many functional features now :P
10:42:46 <lament> arpa121: get some tutorial, YAHT (Yet Another Haskell Tutorial) is often recommended, and if something is unclear, ask here.
10:42:52 <earthy> nopcode: M$ hands out heaps of money to language designers
10:42:54 <drigz> arpa121: http://en.wikibooks.org/wiki/Haskell
10:43:11 <nopcode> earthy: yeah but why do so many people _use_ their commercial lock-in crap?
10:43:15 <arpa121> but I'm new in haskell how can I undrestant codes in haskell ?
10:43:28 <lament> arpa121: by learning it, silly.
10:43:30 <earthy> arpa121: the tutorial starts from scratch
10:43:31 <ndm> arpa121: you might like graham huttons book
10:43:39 <ndm> @google graham hutton book haskell
10:43:40 <DaveCGI378> nopcode: dude, they made a superior product. until sun wakes the fuck up and makes java not suck, developers cant help but use the superior language
10:43:41 <johnnowak> For every Haskell programmer gained by saying "I you like C#, you'll love Haskell", I wonder how many would-be ex-Lispers run away screaminig.
10:43:42 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
10:43:42 <lambdabot> Title: Programming in Haskell
10:43:51 <olsner> DaveCGI378: but as long as they do it wrong, it's fine ;-)
10:43:59 <earthy> nopcode: because it actually does much of what it's supposed to do at a price people are willing to pay for. plus, it has strong network effects
10:44:01 <ndm> arpa121: by that, read it, and you will know haskell ^^^
10:44:24 <nopcode> earthy: you mean they're willing to sell their soul? ;P
10:44:25 <DaveCGI378> olsner: yeah well they do make things wrong 99% of the time. C# is in the 1% (un)fortunately
10:44:29 <earthy> johnnowak: if you love lisp, you'll probably like haskell. :)
10:44:31 <nopcode> earthy: can't be that good
10:44:32 <byorgey> johnnowak: we should just say, "If you like C#, you'll love Haskell.  If you hate C#, you'll probably love Haskell, too."
10:44:38 <arpa121> thanks everybody
10:44:54 <DaveCGI378> i learned lisp a few days ago, i dont like that its dynamically typed though
10:44:54 <earthy> nopcode: what soul? :P
10:44:58 <johnnowak> Fair enough.
10:44:59 <nopcode> earthy: ;)
10:45:01 <lament> If you like *foo*, you'll like Haskell!
10:45:13 * earthy likes sex, will ik like haskell? :P
10:45:18 <lament> earthy: absolutely.
10:45:23 <arpa121> what can We do in haskell that we can't do in C# ?
10:45:26 <lament> haskell is just like sex
10:45:37 <earthy> arpa121: nothing.
10:45:47 <DaveCGI378> continuations
10:45:50 <kilimanjaro> arpa121, it's not a matter of "what", rather a matter of "how".
10:45:54 <olsner> >>= - practice safe I/O
10:45:59 <johnnowak> you don't need to be a MCSD to use haskell
10:46:04 <drigz> arpa121: it's just more fun changing random things until the stack overflows and memory leaks disappear
10:46:07 <lament> johnnowak: LOL
10:46:16 <arpa121> :))
10:46:17 <ndm> C# is a great language, Haskell programs will be a lot shorter
10:46:33 <drigz> you have to debug when you use C#
10:46:35 <ndm> maybe 4 to 10 times shorter
10:46:43 <arpa121> no I don't mean that - I mean haskell has ATOM , isn't it ? what we can do with haskell and ATOM?
10:46:48 <ndm> drigz: you can't debug when you use haskell
10:47:04 <glguy> if you use < 6.7 :)
10:47:06 <arcatan> what can we do in haskell that we can't do in brainfuck?
10:47:13 <int-e> arcatan: I/O
10:47:21 <lament> brainfuck has IO
10:47:30 <DaveCGI378> ya know, it all gets run as binary at the end of the day, so you can do anything in anything
10:47:32 <lament> nothing other than stdin/stdout, though
10:47:33 <nopcode> false ftw
10:47:36 <DaveCGI378> i just like putting in less effort to do simple things
10:47:37 <int-e> multi-threading
10:47:46 <nopcode> why is everyone so obsessed about brainfuck, false is so much nicer :(
10:47:49 <arpa121> what is ATOM and what we can do with that?
10:47:52 <int-e> lament: I know but just stdin and stdout access isn't interesting
10:47:53 <lament> nopcode: false has a problem that all variables are global
10:48:02 <nopcode> lament: *G*
10:48:09 <lament> nopcode: if they were local to functions, false would be much nicer
10:48:13 <olsner> nopcode: what's false like?
10:48:14 <nopcode> hehe
10:48:26 <nopcode> olsner: basically forth with one-character operations
10:48:31 <byorgey> arpa121: I haven't heard of ATOM.
10:48:43 <olsner> ah, sounds pretty nice
10:48:43 <nopcode> arpa121: it's a building block of matter and stuff
10:48:47 <nopcode> you can... exist using it
10:49:00 <arpa121> !ATOM
10:49:22 <DaveCGI378> hmm... type classes are like classes without state
10:49:25 <lament> nopcode: also, if you're interested in esolangs other than just brainfuck, join #esoteric :)
10:49:40 <lament> DaveCGI378: they're a lot like interfaces
10:49:44 <earthy> arpa121: do you mean STM? Software Transactional Memory?
10:49:46 <nopcode> lament: hmm, not that much anymore :D
10:49:59 <DaveCGI378> lament: well i meant the methods
10:50:13 <DaveCGI378> lament: the instance delclarations is the proper term i think
10:50:17 <olsner> there's always Jot - every string of bits is a program ;-)
10:50:20 <byorgey> arpa121: hm, there's an embedded domain-specific language (EDSL) in Haskell for describing Hardware called Atom... but somehow I don't think that's what you're referring to?
10:52:27 <malsyned> DaveCGI378: yeah.  Type Classes are like Interfaces.  Instances are like implementations of Interfaces.
10:53:27 <DaveCGI378> why would you have to do "instance (Eq a) => Eq (Tree a) where" when writing an instance declaration for Tree a => a -> a -> Bool instead of "instance Eq (Tree a) where" ?
10:54:03 <byorgey> DaveCGI378: Because Tree a is only an instance of Eq if a is.
10:54:47 <DaveCGI378> ah... nice
10:55:12 <DaveCGI378> surprisingly that makes perfect sense
10:55:16 <byorgey> =)
10:58:44 <lament> Does haskell claim to be typesafe?
10:58:50 <byorgey> DaveCGI378: of course, you COULD define an instance Eq (Tree a), but that has to work for Trees of *any* type, so the comparison of trees for equality would have to proceed without examining the stored values.
10:58:58 <CosmicRay> what do you mean by typesafE?
10:59:01 <arpa121> wow It's so amazing think for fun :)) haha I think I'll love haskell
10:59:13 <DaveCGI378> of course haskell is type safe
10:59:26 <byorgey> DaveCGI378: which could make sense if, e.g. you only cared about the shape of trees in determining whether trees are "equal".
10:59:43 <DaveCGI378> byorgey: sure :-)
11:00:25 <CosmicRay> lament: I think the answer is yes, in any case.  Haskell does not support casting.
11:00:40 <drigz> lament: what are you referring to by haskell?
11:00:40 <CosmicRay> in fact, haskell has no need for casting
11:00:49 <SamB> malsyned: okay, I've listed the wishlist items from "Template Haskell: A Report From The Field"
11:00:54 <byorgey> arpa121: =)
11:01:14 <SamB> malsyned: I may not have formatted them in the best way possible though
11:01:36 <lament> It just feels that saying that "let foo 1 = 1 in foo 2" is NOT a run-time type error is sophistry.
11:02:03 <DaveCGI378> its not. its a static type error
11:02:05 <SamB> lament: we don't have that kind of type
11:02:17 <olsner> is that a type error?
11:02:24 <lament> no, it's not a type error
11:02:25 <byorgey> > let foo 1 = 1 in foo 2
11:02:27 <CosmicRay> Prelude> let foo 1 = 1
11:02:27 <CosmicRay> Prelude> foo 2
11:02:27 <CosmicRay> *** Exception: <interactive>:1:4-12: Non-exhaustive patterns in function foo
11:02:27 <SamB> lament: you want to use a different typesystem, you can make your own programming language
11:02:27 <lambdabot>   Non-exhaustive patterns in function foo
11:02:31 <DaveCGI378> its probably a parsing error
11:02:35 <byorgey> nope, run-time error
11:02:37 <opqdonut> CosmicRay: no
11:02:37 <lament> DaveCGI378: nope, it's a run-time error
11:02:39 <DaveCGI378> 1 isnt exactly a pattern for a type
11:02:48 <CosmicRay> you can also use -Wall -Werror to ghc to make it an error at compile time
11:02:54 <opqdonut> well it is a type error in the sense that 2 is outside the domain of the function
11:02:58 <DaveCGI378> lament: why would that be a runtime error?
11:03:00 <CosmicRay> Prelude> :t foo
11:03:00 <CosmicRay> foo :: (Num t1, Num t) => t -> t1
11:03:01 <lament> opqdonut: yes, that's my point.
11:03:11 <lament> DaveCGI378: because that's how haskell works.
11:03:15 <malsyned> SamB: nice
11:03:27 <opqdonut> i agree with SamB tho
11:03:27 <DaveCGI378> you can declare functions on specific values?
11:03:40 <lament> DaveCGI378: yes.
11:03:43 <malsyned> DaveCGI378: 1 is a pattern.  it's a pattern matching the single value '1'.  Yes, you can declare functions on specific values.
11:03:58 <glguy>  Control.Exception.catch ( let f 1 = 1 in if f 2 == 1 then return 'a' else return 'b' ) (\ _ -> return 'c' )
11:04:00 <lament> SamB: i don't think you understand my point.
11:04:05 <CosmicRay> there is simply an implicit foo _ = error "Non-exhaustive..." here
11:04:10 <malsyned> and what that was an example of was a "Non-exhaustive pattern"
11:04:26 <SamB> lament: your point is that you want ... some kind of really advanced typesystem
11:04:28 <CosmicRay> but as I said, it is possible to make that a compile-time error.
11:04:31 <pjd> lament: that's what -fwarn-incomplete-patterns
11:04:33 <lament> SamB: no, that's not my point.
11:04:34 <pjd> ...is for
11:04:43 <byorgey> DaveCGI378: pattern-matching is one of the fundamental ways to define functions in Haskell.  patterns can include constant values.
11:04:55 <CosmicRay> if you want a data type that has only one acceptable value, just say data Useless = Useless
11:05:11 <Khoth> Or use ()
11:05:16 <malsyned> > let {foo 1 = 1; foo n = foo (n - 1) + 1} in foo 3
11:05:18 <lambdabot>  3
11:05:24 <CosmicRay> you defined a function that was valid from any number to any number.  it wasn't even restricted to ints.
11:05:24 <SamB> lament: that's not a type error in any of the typesystems we use, okay?
11:05:33 <lament> SamB: that's what i meant by "sophistry"
11:05:43 <SamB> (for Haskell, I mean)
11:05:51 <lament> SamB: because semantically, the difference between foo 2 and foo "wrong type" is minimal
11:05:57 <malsyned> DaveCGI378: see the use of a constant in a pattern match?  (one that doesn't result in an error)
11:06:15 <lament> SamB: both 2 and "wrong type" are outside of the domain of foo
11:06:39 <SamB> if you want a typesystem that can have a type for 1 and only 1... well... you can probably find one somewhere
11:06:40 <CosmicRay> lament: not true.  the way you defined the function, you defined it to be valid from any number to any number.
11:06:41 <pjd> lament: what don't you like about -fwarn-incomplete-patterns then?
11:06:42 <dylan> technically '2' just results in undefined.
11:06:46 <malsyned> lament is looking for a language where functions are actually mathematical functions, not partial functions.
11:06:52 <malsyned> but such a language is not turing complete, right?
11:06:59 <SamB> malsyned: eh?
11:07:15 <pjd> that makes it a static warning (or error, with -Werror)
11:07:21 <lament> malsyned: i'm not looking for any such language! Haskell is great!
11:07:25 <CosmicRay> sounds to me like he wants an Enum
11:07:27 <lament> :\
11:07:54 <SamB> lament: if you find a language where "let fun 1 = 1 in fun 2" is a type error, it won't be Haskell
11:08:08 <malsyned> There was a paper about a subset of Haskell that allowed you only to create complete functions.  It was interesting, but it limited the kinds of problems you could solve.
11:08:35 <lament> SamB: have you read what i said?
11:09:10 <SamB> lament: look, I'm pretty sure this "domain" business would throw a wrench into that whole "type inference" thing
11:09:40 <lament> yeah, of course it would.
11:09:41 <paolino> hi, how do I take from [1..] until I have sum s ?
11:09:45 <lament> it's probably practically impossible
11:10:10 <SamB> in some typesystem other than that of Haskell, yes, that's a type error
11:10:29 <CosmicRay> paolino: is this a homework assignment of some sort?
11:10:49 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2115
11:10:50 <lament> SamB: _obviously_ it is not a type error in haskell
11:10:52 * SamB wonders if you can make a typesystem such that no matter what you write you have a type error
11:10:54 <lament> SamB: i am perfectly aware of that
11:11:00 <paolino> Ex50 eulerproject
11:11:01 <SamB> lament: okay then
11:11:02 <rubyruy> what is the problem with the following: http://hpaste.org/2115
11:11:11 <rubyruy> (note: newbishness)
11:11:18 <CosmicRay> SamB: smells like Java.  Isn't that why we cast everything to Object? ;-)
11:11:27 <SamB> anyway, I think that would correspond with Python's ValueError...
11:11:31 <lament> SamB: however, with a definition like, python is also statically typed and typesafe
11:11:41 <lament> SamB: which makes the terms basically meaningless...
11:11:57 <SamB> lament: hmm.
11:12:08 <lament> s/definition like/definition like that
11:12:08 <rubyruy> specifically above paste is complaining about "Couldn't match expected type `User' against inferred type `a b'"
11:12:25 <SamB> lament: hmm.
11:12:31 <CosmicRay> rubyruy: what is the type of User?
11:12:32 <SamB> you raise a valid point.
11:12:33 <rubyruy> User
11:12:36 <int-e> rubyruy: you're mixing monad actions with pure values. You have to make a decision.
11:12:52 <CosmicRay> and there's that.
11:13:00 <paolino> CosmicRay: other then mapM under Cont
11:13:00 <paolino> ehm foldM
11:13:07 <CosmicRay> rubyruy: sorry.  how is User defined?
11:13:16 <glguy> rubyruy: return doesn't do what you think it does?
11:13:19 <int-e> rubyruy: either make all values on the right side of the -> arrows in the case monadic - using 'do' notation for example, or make them all pure. (just values, no 'do')
11:13:35 <int-e> rubyruy: in the first case you probably also want
11:13:48 <int-e> rubyruy: just 'user' instead of 'return user' at the end
11:13:52 <rubyruy> but doesn't return return make it "pure" ?
11:13:59 <rubyruy> s/return//
11:14:06 <Khoth> No., return wraps it in the monad
11:14:08 <glguy> rubyruy: return isn't for escaping a value from a functinon
11:14:28 <glguy> return creates a monadic value that returns the specified thing
11:14:48 <lament> rubyruy: What type do you want the value "user" to be, (User) or (IO User)?
11:14:53 <rubyruy> oh wait --- the first branch is returning User, the second branch is IO User
11:14:57 <rubyruy> right right right
11:15:22 <lament> good :)
11:15:46 <CosmicRay> tada
11:16:35 <CosmicRay> from what we see here, we do not know for sure that it is IO User.  It could be any monad...   but since you're calling something named "prompt", seems reasonable ;-)
11:17:25 <SamB> lament: you know, Python *is* type safe compared to C...
11:17:27 <lament> by the way, why is the type of hpaste  (a -> b) -> f a -> f b ?
11:17:43 <SamB> lament: I haven't the foggiest
11:17:56 <SamB> @djinn (a -> b) -> f a -> f b
11:17:56 <ivant> @hoogle (a->b)->f a -> f b
11:17:57 <lambdabot> -- f cannot be realized.
11:17:57 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:17:57 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:17:57 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:18:09 <rubyruy> CosmicRay: so the idea is that since getUser must interact with the world, it necessarily can only return IO User (not just User)
11:18:16 <CosmicRay> SamB: one of my coworkers has been trying to track down a bug in evolution.  they have function pointers casted to void all over the place
11:18:18 <int-e> rubyruy: to explain the error message: the second value isn't really IO User, it's m User for *any* monad m. This is why the error message says 'a b' and not something more useful like 'IO a' or 'IO User'.
11:18:36 <byorgey> :t fmap
11:18:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:18:47 <byorgey> no idea why that's the type of hpaste though
11:19:05 <hpaste>  CosmicRay annotated "(no title)" with "(no title)" at http://hpaste.org/2115#a2
11:19:08 <SamB> lament: I wondered that myself
11:19:23 <CosmicRay> or you could put the returns in each case statement
11:19:30 <CosmicRay> err alternative
11:20:13 <rubyruy> well i do want  2 returns i guess
11:20:56 <lament> that's code duplication :)
11:21:07 <lament> in embryonic stages
11:21:10 <hpaste>  rubyruy annotated "(no title)" with "this seems to work :)" at http://hpaste.org/2115#a3
11:21:55 <CosmicRay> note that you could jsut have said return (User "foob" "bars")
11:21:57 <rubyruy> the reason they are actions instead of values is that now i'm going to replace the explicity User constructors with actions that load a user object from a serialized file or create a new one
11:21:59 <CosmicRay> as you did in the first alternative
11:22:04 <rubyruy> i know
11:22:21 <glguy> or if you are dead set on using let, let usr = .... in return usr
11:22:40 <rubyruy> btw - is Data.Binary the cheap/easy way to serialize data in haskell ?
11:22:47 <Khoth> Maybe the f in (a->b)->f a->f b is the "on the internet" functor, applied to a code modifying function
11:22:53 <rubyruy> (compare to Pickle in Python or Marshall in Ruby)
11:23:48 <byorgey> (Internet f) => (Buggy -> Elegant) -> f Buggy -> f Elegant
11:23:52 <dV__> rubyruy, cheap and easy way is show/read
11:24:07 <rubyruy> show/read is reversable ?
11:24:15 <rubyruy> even for complex data ?
11:24:15 <lament> byorgey: hmm :)
11:24:30 <glguy> rubyruy: it is supposed to be
11:24:30 <dV__> read . show = id
11:24:47 <rubyruy> ahh
11:24:50 <lament> now, to convince everybody that show is just like xml... :)
11:24:56 <dylan> :t read . show
11:24:58 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:25:16 <rubyruy> lament: i guess i could see the parallel to json notation :p
11:25:16 <Khoth> :t show . read
11:25:18 <lambdabot> String -> String
11:25:19 <byorgey> rubyruy: in particular, if you let ghc derive Read/Show instances, then yes.
11:25:29 <johnnowak> lament: a few more lispers just ran off, way to go
11:25:48 <rubyruy> ok cool so i can just read/write the string to a file eh?
11:26:10 <Baughn> rubyruy: Data.Binary may be smaller, but it's distinctly less readable
11:26:21 <lament> johnnowak: sorry, s/xml/sexprs
11:26:24 <rubyruy> got it :p
11:26:47 * Baughn ponders implementing a slime backend for ghc/liskell
11:27:16 <CosmicRay> slime?  liskell?
11:27:37 <Khoth> Hm. Why does show . read do what it does, rather than just giving "error: silly buggers"?
11:27:45 <Baughn> SLIME - Superior Lisp INteraction Mode (it is). Liskell - a lisp-type syntax translator for haskell.
11:27:57 <CosmicRay> syntax translator?
11:28:02 <johnnowak> are the syntax errors on the liskell front page some sort of joke?
11:28:20 <Baughn> CosmicRay: It doesn't actually change the language. Much.
11:28:21 <CosmicRay> is that what I think it means?
11:28:36 <CosmicRay> interesting.
11:29:01 <Baughn> I've been trying to improve haskell-mode, but everywhere I turn, haskell's insane syntax stops any progress. :/
11:29:23 <byorgey> Khoth: what's wrong with show . read?
11:29:44 <Khoth> It defaults to something numeric in the middle
11:29:49 <lament> is liskell worth it somehow?
11:29:55 <lament> what is it for, macros?
11:29:58 <Baughn> lament: Well, it'll fix my syntax woes
11:30:17 <Baughn> And I find lisp syntax more aesthetically appealing and simpler to use than haskell syntax
11:30:19 <johnnowak> yes, macros
11:30:21 <lament> Baughn: so you'd use it just because it "makes haskell look different", without other benefits?
11:30:25 <Khoth> > (show . read ) "6"
11:30:27 <lambdabot>  "6"
11:30:34 <Khoth> > (show . read ) "Nothing"
11:30:36 <Baughn> lament: No, as I said it fixes my syntax woes
11:30:36 <lambdabot>  Exception: Prelude.read: no parse
11:30:50 <Baughn> lament: I'd use it because it will let me make a haskell-mode that actually works
11:30:50 <lament> Baughn: well, s/different/better
11:30:51 <taruti> and the metaprogramming is probably less painful than TH
11:31:09 <johnnowak> "probably"
11:31:15 <Baughn> It is
11:31:26 <doserj> > (show . (read ::Maybe ())) "Nothing"
11:31:27 <taruti> johnnowak: it is hard to make it more tedious and hard ;)
11:31:27 <lambdabot>  Couldn't match expected type `Maybe ()'
11:31:38 <doserj> > (show . (read ::Strin -> Maybe ())) "Nothing"
11:31:38 <Baughn> (show . read) (cycle "2")
11:31:39 <lambdabot>   Not in scope: type constructor or class `Strin'
11:31:39 <johnnowak> taruti: hehe
11:31:40 <lament> is liskell a preprocessor?
11:31:42 <Baughn> > (show . read) (cycle "2")
11:31:45 <doserj> > (show . (read ::String -> Maybe ())) "Nothing"
11:31:46 <lambdabot> Terminated
11:31:47 <lambdabot>  "Nothing"
11:31:52 <taruti> lament: yes.
11:31:56 <Baughn> Not id, I see. :P
11:32:19 <byorgey> Khoth: ah, well, the problem with read is that it has to know what type it needs to produce before it actually runs.
11:32:31 <Baughn> lament: The exciting part is going to be mangling Haskell to conform to Slime expectations, such as being able to mutate programs over time
11:32:37 <byorgey> Khoth: type inference can't happen at runtime.
11:32:42 <taruti> lament: 1) parse lisp, 2) allow metatransforming on the lisp parse tree, 3) transform it into a haskell parse tree, 4) feed that to GHC
11:33:02 <Baughn> Khoth: Though you can get arbitrarily close to a Variant type if you need one
11:33:03 <Khoth> byorgey: Yes, but I'd expect an error at compile time rather than it picking some arbitrary middle type
11:33:06 <byorgey> Khoth: so in order to do *something* useful in GHCi, it defaults to Integer.
11:33:21 <doserj> Khoth: it gives an error at compile time
11:33:35 <malsyned> hGetContents performs Lazy IO, like getContents, right?
11:33:44 <byorgey> Khoth: I think it only defaults like that in GHCi.
11:33:50 <taruti> malsyned: yes
11:34:24 <malsyned> taruti: so it would be a mistake to call hGetContents, then waitForProcess, then do something with the result of hGetContents?
11:34:37 <taruti> yes
11:34:38 <Khoth> Ah, yes. GHC complains, as I'd expected ghci to
11:34:44 <Baughn> malsyned: That'd deadlock
11:35:14 <Baughn> malsyned: Try something like "a <- hGetContents h; last a `seq` waitForPRocess"
11:35:22 <byorgey> Khoth: yeah, GHCi has a few weirdnesses like that with the intention of shielding new users from incomprehensible error messages
11:35:26 <malsyned> for the same reason that calling hGetContents and then hClose would cause future uses of the result of hGetContents to find themselves in possession of an empty string.
11:35:37 <EvilTerran> byorgey, s/GHCi/Haskell/
11:35:43 <malsyned> Baughn: that's just making the IO strict instead of active, isn't it?
11:35:44 <malsyned> er
11:35:46 <byorgey> EvilTerran: well, that too =)
11:35:46 <malsyned> strict instead of lazy
11:35:51 <Baughn> malsyned: Well, yes
11:35:57 <taruti> malsyned: better yet have separate threads for that since stderr exists too...
11:35:58 <EvilTerran> *grumble unary minus mutter*
11:36:34 <malsyned> can't this problem be solved without sacrificing lazy IO by calling waitForProcess (or hClose) after any IO that needs the result of hGetContents?
11:36:47 <byorgey> EvilTerran: I hate unary minus with the passion of a thousand monads.
11:36:50 <Saizan> i just a <- hGetContents h; forkIO (waitForProcess); consume a
11:37:08 <Baughn> malsyned: What /is/ the problem, exactly?
11:37:17 <EvilTerran> byorgey, i agree. next complaint: monomorphism restriction!
11:37:33 <malsyned> I guess there isn't a problem.  just a pitfall.
11:37:42 * ddarius prefers the current unary minus story to all of the alternatives he is aware of.
11:38:09 <ddarius> The monomorphism restriction, I agree, is more a trap than a boon.
11:38:26 * malsyned doesn't see what is so wrong with doing away with unary minus and just having a "neg" function.
11:38:46 <malsyned> Saizan: that looks good.  Thanks for the tip.
11:38:47 <mrd> someone proposed a syntax involving backticks `-` for resolving it
11:38:51 * Baughn would be okay with just saying (- 0 x)
11:38:52 <ddarius> malsyned: People entering expecting -13 to work.
11:39:08 <malsyned> ddarius: people enter expecting side-effects, too ;)
11:39:08 <opqdonut> ?instances Functor
11:39:16 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:39:21 <int-e> malsyned: well apart from breaking existing programs. And I'd really like to have unary minus as part of number literals.
11:39:31 <ddarius> malsyned: Not really.
11:39:36 <Saizan> malsyned: i'm not sure how safe it is
11:40:32 <int-e> then -13 would still work.  \x -> -x  would not work but replacing that by \x -> neg x  seems to be far less of a nuisance to me.
11:40:44 <malsyned> int-e: that would be fine too.  I think it's pretty easy to deal with the idea that -5 means something different from (- 5).  We already have Foo.Bar and (Foo . Bar) meaning different things, and (in Template Haskell) $a and ($ a) meaning different things.
11:41:22 <ddarius> \x -> -x ~> negate
11:41:41 <int-e> ddarius: bad example.
11:41:50 <int-e> ddarius: that is, I chose it poorly.
11:42:04 <wli> Unary minus' "painfulness" is largely an artifact of weak parsing algorithms like LL(1).
11:42:22 <SamB> what is this about -5 meaning something wierd?
11:42:41 * SamB does NOT want -5 to mean fromInteger (-5 :: Integer)
11:42:41 <int-e> malsyned: and actually I'd be really happy to write   f 0 -1 2 -3  instead of f 0 (-1) 2 (-3)
11:42:42 <Philippa_> wli: it's a bit more involved with Haskell
11:42:49 <int-e> SamB: uh why not?
11:42:57 <ddarius> Sections are the "different" thing.  It makes sense to have the "normal" thing be what you get.
11:43:12 <SamB> int-e: well, I want it to mean negate (fromInteger (5 :: Integer))
11:43:15 <int-e> SamB: that it means  negate (fromInteger 5)  today is another nuisance.
11:43:20 <Philippa_> juxtaposition doesn't mean anything valid in many operator grammars - it does in Haskell
11:43:24 <SamB> int-e: I USE that
11:43:32 <int-e> SamB: err what on earth for?
11:43:40 <SamB> PDP-1 arithmatic, duh
11:43:41 <malsyned> SamB: is writing ((- 5) :: Integer) really that bad?
11:43:42 <ddarius> Your PDP stuff.
11:43:45 * ddarius is slow.
11:43:49 <int-e> SamB: I usually think it's a nuisance to not have proper negative literals.
11:43:56 <malsyned> er
11:44:01 <SamB> I don't mind if -5 means that though
11:44:04 <malsyned> nevermind, that didn't make any sense.
11:44:32 <wli> Philippa: Sections and interoperating with user-defined infix operators (and maybe literals) seem like most of it.
11:44:35 <int-e> you could still write  negate 5.
11:44:43 <SamB> int-e: not in patterns
11:45:13 <SamB> hmm. you know, I don't think Haskell 98 actually says what this means:
11:45:19 <int-e> and in any case fromInteger -5 and negate (fromInteger 5) should mean the same thing for any Num instance.
11:45:23 <SamB> f (-1) = 2
11:45:48 <sjanssen> SamB: desugars to "f x | x == -1 = 2"
11:46:04 <sjanssen> where the "-1" desugaring is established elsewhere
11:46:07 <Philippa_> wli: those're actually not so bad, if you know how to write the parsers in general then you just construct one in response to fixity declarations. The juxtaposition is a much bigger problem, it loses you a lot of properties. foo - 123 is ambiguous
11:46:26 <SamB> sjanssen: where's that established for "numeric literals"?
11:46:38 <ohub> @src fmap
11:46:38 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:46:45 <ddarius> @src [] fmap
11:46:45 <lambdabot> fmap = map
11:47:01 <ohub> hmh
11:47:10 <ddarius> @src Functor
11:47:11 <lambdabot> class  Functor f  where
11:47:11 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:47:16 <byorgey> ohub: fmap is part of the Functor type class, so the implementation is different for each instance of Functor.
11:47:30 <ohub> byorgey: ah, ok
11:47:36 <SamB> int-e: where are you pulling all of these laws from?
11:47:38 <ohub> Need to go and learn what Functors are
11:48:16 <sjanssen> SamB: see 3.17.2
11:48:17 <ddarius> ohub: For Haskell's purposes, they are type constructors that are instances of that class, i.e. that have a fmap operation defined.
11:48:38 <SamB> sjanssen: that's the informal semantics
11:48:50 <int-e> SamB: nowhere in particular but rings are a reasonable model for Num, and fromInteger should be the homomorphism from Z to that ring.
11:49:34 <sjanssen> SamB: case v of { k -> e; _ -> e' } = if (v==k) then e else e'
11:49:34 <sjanssen> 	where k is a numeric, character, or string literal.
11:49:39 <sjanssen> SamB: that's from the formal semantics
11:49:41 <ohub> @src Maybe fmap
11:49:41 <lambdabot> fmap _ Nothing       = Nothing
11:49:41 <lambdabot> fmap f (Just a)      = Just (f a)
11:49:42 <int-e> SamB: I know that Haskell has no requirement for this. But I think it would be a good requirement to have.
11:49:42 <SamB> int-e: since when did Haskell 98 have reasonable models?
11:50:00 <ohub> ddarius: aah, ok! Thanks.
11:50:12 <SamB> sjanssen: since when is, say, "-1" a numeric literal?
11:50:14 <byorgey> ohub: you can think of a functor as any sort of 'container' which comes along with an operation that 'lifts' a regular function (a->b) into a function from a container of a's to a container of b's.
11:50:15 <wli> Philippa: I'm trying to think of how feasible cutting down parses to something reasonable is.
11:50:19 <sjanssen> SamB: it's not
11:50:36 <malsyned> what's the best way to signal an error within the IO monad?
11:50:43 <SamB> sjanssen: well then how come I can use it as a pattern
11:51:17 <Philippa_> wli: ultimately that ambiguity stays in place, especially given the silly things you can do if you redefine Num and play with extensions on
11:51:19 <sjanssen> SamB: ahh, this is a good point
11:51:28 <sjanssen> SamB: yeah, I think it is missing in the report
11:51:35 <byorgey> ohub: for example, the list type is a functor: [a] is a container of a's, and if you have a function that takes a's to b's, then you can use fmap to make it into a function from lists of a's to lists of b's.
11:51:50 <SamB> I hope GHC's interpretation is the one that gets standardized
11:52:13 <sjanssen> SamB: what is GHC's interpretation?
11:52:15 <int-e> SamB: and I'm not proposing to change Haskell 98 anyway.
11:52:18 <ohub> byorgey: It just feels that the name fmap is somewhat misleading for example for Maybe.
11:52:22 <byorgey> ohub: hope that makes a little sense... at any rate you can probably read a much more coherent explanation somewhere else =)
11:52:30 <byorgey> ohub: why is that?
11:52:41 <ddarius> ohub: The types pretty much tell the whole story.
11:52:46 <ddarius> :t fmap
11:52:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:52:54 <olsner> :t maybe
11:52:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:53:20 <SamB> sjanssen: well, to see if the pattern "-1" matches the expression "x", it checks whether "negate 1 == x"
11:53:21 <ohub> byorgey: Well, I'm confusing map with fmap. but maybe fmap is general thing compared to map is only for lists?
11:53:29 <byorgey> ohub: exactly.
11:54:10 <byorgey> ohub: fmap is a general thing; the way fmap works for lists is map.  but for Maybe, fmap is different.
11:54:20 <byorgey> @src Maybe fmap
11:54:20 <lambdabot> fmap _ Nothing       = Nothing
11:54:20 <lambdabot> fmap f (Just a)      = Just (f a)
11:54:32 <ohub> byorgey: yes, I think I get it now. Thanks!
11:54:32 <Khoth> @src maybe
11:54:33 <lambdabot> maybe n _ Nothing  = n
11:54:33 <lambdabot> maybe _ f (Just x) = f x
11:54:42 <byorgey> ohub: sure!
11:54:57 <SamB> ohub: if you've been reading oldish papers, once map WAS fmap
11:55:02 <SamB> that is, once we had
11:55:04 <sjanssen> SamB: also, there's "lpat6 	 -> 	 - (integer | float) 	 (negative literal)" in the syntax for patterns
11:55:12 <SamB> class Functor f where
11:55:18 <ohub> SamB: nope, haven't read anything old
11:55:21 <sjanssen> SamB: so there is such a thing as "negative literal" for patterns
11:55:33 <SamB>     map :: (a -> b) -> f a -> f b
11:55:45 <newsham> what do the lazy bottoms think of total functional programming?
11:55:53 <wli> Philippa: I think giving juxtaposition higher precedence resolves most of it.
11:56:01 <SamB> sjanssen: sure, so Haskell 98's grammar has a way to parse it
11:56:07 <SamB> but doesn't say what it means
11:56:22 <SamB> sjanssen: that helps a lot </sarcasm>
11:56:41 <sjanssen> newsham: the lazy "bottoms" clearly don't believe in total FP
11:57:13 <newsham> they dont believe it exists?  or they view it as a threat to their way of life? :)
11:57:34 * SamB wonders if ~(_|_) would be a good logo for them
11:58:26 <ivant> @pl \p -> zip (f p) [0..]
11:58:27 <lambdabot> flip zip [0..] . f
11:58:45 <byorgey> flip zip!
11:59:05 <sjanssen> SamB: I think it's pretty clear that the pattern "(-1)" becomes "if negate 1 == var ..."
11:59:12 <rehges> @t flip zip
11:59:13 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
11:59:20 <rehges> @type flip zip
11:59:22 <lambdabot> forall a b. [b] -> [a] -> [(a, b)]
11:59:41 <malsyned> Anybody got an opinion on the "right" way to signal an error in the IO monad?
11:59:51 <xerox> :t throw
11:59:53 <lambdabot> Not in scope: `throw'
12:00:02 <xerox> Aw.  Oh well.  'error' ?
12:00:02 <anybody> malsyned: i don't know
12:00:06 <ddarius> instance Num Reify where (+) = Plus; (-) = Minus; negate = Negate; fromInteger = FromInteger etc.  then you can see exactly how it is interepreted.
12:00:23 <ddarius> ioError
12:00:25 <xerox> You can catch exceptions in the IO monad, malsyned. Check Control.Exception documentation.
12:00:33 <newsham> ErrorT IO ?
12:00:33 <sjanssen> SamB: the report doesn't come out and say it definitively, but I don't see another reasonable interpretation
12:00:38 <malsyned> xerox: I don't want to catch one, I want to throw one.
12:00:42 * atsampson fails to get the Maybe monad to do what he wants, and decides he really wants a Probably monad ;)
12:00:58 <xerox> atsampson: what's a Probably monad?
12:01:17 <newsham> Probably a = Usually a | NotThisTime
12:01:26 <xerox> That's Maybe :)
12:01:26 <atsampson> it'd be like the Maybe monad, but >>= would keep trying until it got an answer that wasn't Nothing ;)
12:01:33 <ddarius> (Probability, Maybe a)
12:01:37 <anybody> is there a Never monad too?
12:01:39 <newsham> no, Maybe a = Just a | None
12:01:53 <ddarius> data Never a = Never
12:01:55 <newsham> Never a = Sorry
12:01:56 <xerox> malsyned: I suppose `error' is okay.
12:02:06 <byorgey> atsampson: what are you trying to do?
12:02:20 <eivuokko> malsyned, fail, maybe, if you don't have anyone to catch the error.
12:02:20 * ddarius points out that such a "Never" monad wouldn't be a computational monad a la Moggi.
12:02:55 <xerox> instance Functor Never where fmap f _ = Never `asTypeOf` f (undefined `asTypeOf` Never) ?
12:02:56 <kaol> Never = Nothing | Just _|_
12:02:58 <newsham> Sorry >>= m = Sorry
12:03:15 <newsham> return x = Sorry
12:03:23 <atsampson> byorgey: I've got a load of matcher functions that return Just something-that-matched or Nothing, and I want to try them one after another
12:03:33 <wli> Alethic, epistemic, temporal, and deontic modalities for the LogicT monad? ;)
12:03:37 <ddarius> newsham makes the strict Never monad.
12:03:40 <sjanssen> xerox: I think the asTypeOf is not needed
12:04:01 <byorgey> > Just 2 `mplus` Just 3
12:04:03 <lambdabot>  Just 2
12:04:03 <xerox> sjanssen: it needs to be g's b
12:04:09 <byorgey> > Nothing `mplus` Just 5
12:04:10 <xerox> f's b
12:04:11 <lambdabot>  Just 5
12:04:15 <ddarius> :t msum
12:04:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:04:46 <ddarius> fmap f Sorry = Sorry will work
12:04:52 <byorgey> atsampson: yep, I think you want mplus and/or msum (which is just a fold using mplus)
12:04:54 <xerox> ah.
12:04:55 <sjanssen> xerox: Haskell knows how to constrain the type
12:05:03 <xerox> Alright.
12:05:34 <byorgey> > msum [Just 2, Just undefined]
12:05:35 <lambdabot>  Just 2
12:05:43 <opqdonut> hi ohub
12:05:55 <ohub> opqdonut: hi :)
12:06:14 <anybody> omg monads are so weird. i'm just reading the haskell wikibook and don't get it. is there any other good resource for monads? wikipedia?
12:06:16 <opqdonut> kinda  embarassin me checking out those functor instances here
12:06:25 <opqdonut> didn't realize you were on the channel also :)
12:06:29 <ohub> :P
12:06:50 <ddarius> anybody: How are they weird?
12:07:26 <lament> > (read . show) 1
12:07:28 <lambdabot>  1
12:07:33 <lament> hm
12:07:51 <ddarius> lament: That's the easy way.
12:08:20 <lament> it doesn't work in ghci. What's the easy way that works in ghci (given that i don't know the type of the argument to show)?
12:08:33 <byorgey> anybody: lots. not Wikipedia though.  you could try Cale's new tutorial: http://www.haskell.org/haskellwiki/Monads_as_computation
12:08:34 <lambdabot> Title: Monads as computation - HaskellWiki
12:08:59 <anybody> ddarius: the >>= operator is so strange. i'm not really sure where the state is. "M a -> (a -> M b) -> M b" is it a? and then b? or is it encapsulated in M?
12:09:03 <byorgey> anybody: there's also the meta-tutorial which has links to other monad tutorials/explanations: http://haskell.cs.yale.edu/haskellwiki/Meta-tutorial
12:09:05 <lambdabot> Title: Meta-tutorial - HaskellWiki
12:09:09 <opqdonut> anybody: in M
12:09:11 <Botje_> anybody: the state is in M.
12:09:16 <lament> is there a way to force show to annotate numbers with their type, so I can get them back with read?
12:09:26 <lament> or a way to force read to read them anyway?
12:09:31 <anybody> thx for the links
12:09:32 <kpreid> lament: no
12:09:39 <lament> > read "1"
12:09:40 <opqdonut> > read "1" :: Float
12:09:41 <lambdabot>  1
12:09:42 <lambdabot>  1.0
12:09:45 <opqdonut> there
12:09:46 <opqdonut> :)
12:09:53 <kpreid> lament: read has to have some concrete type before it can even be run
12:09:54 <ddarius> anybody: There is not necessarily any state at all.
12:10:05 <kpreid> lament: if you want just read.show, then do this:
12:10:23 <ddarius> anybody: But one thing to consider, for M = Id (>>=) :: a -> (a -> b) -> b which is just application flipped.
12:10:26 <ddarius> :t flip ($)
12:10:28 <lambdabot> forall a b. a -> (a -> b) -> b
12:10:44 <kpreid> let rs :: (Read a, Show a) => a -> a; rs = read . shoe
12:10:46 <kpreid> then use rs
12:10:54 <kpreid> then if the input is concrete so is the output
12:12:12 <byorgey> ddarius: somehow I kind of doubt that helps... =)
12:12:14 <newsham> consider: M a = (\s -> (s,a));     Ma -> (a -> M b) -> M b    is   (state -> (state,a)) -> (a -> state -> (state, b)) -> (b -> (state, b))
12:12:30 <newsham> so you can see how the "M" lets the state be threaded
12:12:58 <ddarius> byorgey: (>>=) does perfectly map to (flipped) application in an effectful language.
12:15:36 <byorgey> ddarius: I know, I was just wondering whether that would be useful information for anybody (the nick, not the pronoun).  It's hard to know what will be helpful for people learning and what will be too much, I guess I just didn't want anybody to feel bad if they didn't understand what you wrote.
12:16:13 <anybody> byorgey: well i don't understand it but I don't feel bad about it either ;-)
12:16:22 <Khoth> Maybe is a nice monad for trying to work out what's going on with things
12:16:24 <byorgey> anybody: good =)
12:16:46 <anybody> byorgey: i wouldn't expect to understand all of haskell in half a day
12:16:50 * ddarius would prefer he understood it whether or not he felt bad about it.
12:17:07 <byorgey> anybody: you only started learning Haskell today?
12:17:10 <anybody> byorgey: just started 7 hours ago
12:18:12 <byorgey> anybody: in that case, welcome, and take your time =)
12:18:37 <byorgey> anybody: it took me a few weeks before I felt that I really understood monads
12:18:49 <anybody> byorgey: omg
12:19:29 <byorgey> anybody: by which I mean, I kept discovering new things that I hadn't quite understood before, not that I was completely confused for two weeks =)
12:19:38 <SamB> hmm. what should I call an integral type based on this:
12:19:48 <SamB> data Nat = P
12:19:48 <SamB>          | I Nat
12:19:48 <SamB>          | C Nat
12:20:17 <Botje> Picnic!
12:20:23 <opqdonut> ;D
12:20:24 <SamB> um.
12:21:05 <Khoth> BinaryInteger?
12:21:19 <SamB> in case it isn't obvious, P means zero, I x means 0 + 2*x, and C x means 1 + 2*x
12:21:34 <newsham> SamB: what about F?
12:21:52 <SamB> newsham: um, that's handled in a preprocessor
12:22:17 <Botje> SamB: BitType?
12:22:26 <Botje> TypedBit? :)
12:22:31 <lament> kpreid: no, i don't want read.show, but somebody mentioned earlier today that show/read could be used as a way to serialize haskell values...
12:22:35 <SamB> fine, BitInteger is okay...
12:22:54 <kpreid> lament: right, but you have to have a type to read
12:23:15 <hpaste>  wli annotated "bitreversal etc. for Integer" with "slow but working radix conversion" at http://hpaste.org/2114#a2
12:23:18 <kpreid> think about this: the program *which calls read* has to specify a type, to work with it
12:23:31 <kpreid> on the other hand, maybe you'd like Data.Generics' gread/gshow
12:23:47 <SamB> kpreid: that doesn't work too well :-(
12:23:54 <lament> i just want a simple way to serialize objects, i don't know how it's "normally" done in haskell
12:23:59 <Khoth> It'll probably work out better if you actually do something with the stuff you read, so it gets some constraint on it
12:24:12 <kpreid> lament: what khoth said.
12:24:29 <kpreid> lament: when you actually *use* read/show to serialize *something in particular*, the type will be properly fixed
12:24:31 <wli> lament: read/showor Data.Binary if speed/format/size is an issue.
12:24:34 <anybody> byorgey: is this right?: a monad is basically a mapping: value -> (value,state) ?
12:24:59 <byorgey> anybody: no, a monad doesn't necessarily involve state.
12:25:18 <anybody> byorgey: oh. hrm
12:25:18 <SamB> wli: Data.Binary is good sizewise since when?
12:25:20 <byorgey> anybody: that is a particular kind of monad (a State monad).
12:25:42 <anybody> byorgey: k. nvm then ;-)
12:25:47 <SamB> @src State
12:25:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:25:54 <SamB> @unmtl State
12:25:54 <wli> SamB: AIUI it produces smaller representations of data than Read/Show.
12:25:54 <lambdabot> err: No applications
12:25:58 <SamB> @unmtl State a
12:25:58 <lambdabot> State a
12:26:06 <SamB> arg.
12:26:14 <byorgey> anybody: try reading Cale's tutorial that I linked above, I think it's a good explanation of what monads really are.
12:26:15 <SamB> @unmtl StateT s IO
12:26:16 <lambdabot> err: Unknown MTL(1)
12:26:24 <Khoth> @src State a
12:26:25 <lambdabot> Source not found. Wrong!  You cheating scum!
12:26:26 <samreid> data State s a = State { runState :: a -> (a,s) }, I think
12:26:26 <SamB> @unmtl StateT s (Writer w)
12:26:26 <lambdabot> err: Unknown MTL(1)
12:26:34 * SamB wonders what unmtl is FOR
12:26:36 <samreid> er, newtype
12:27:23 <sjanssen> @unmtl State s a
12:27:24 <lambdabot> s -> (a, s)
12:27:34 <sjanssen> @unmtl StateT s (Writer w) a
12:27:35 <lambdabot> s -> (a, s, w)
12:27:44 <samreid> ack, s ->
12:28:16 <int-e> @unmtl ListT Maybe a
12:28:16 <lambdabot> Maybe [a]
12:28:31 <wli> anybody: I think of monads as involving 3 parts: (1) return, so there's a way to set up a monad object from just an element of the type it's parametrized on, (2) fmap, so there's a way to use a function to transform the object like map does for lists, and (3) join, which means there's a sensible way to convert a monad of a monad of the things to just an ordinary monad, like concat for lists.
12:30:39 <glguy> @type bind m f = join $ fmap f m
12:30:40 <lambdabot> parse error on input `='
12:30:43 <glguy> @type bind m f = join $ fmap f m in bind
12:30:45 <lambdabot> parse error on input `='
12:30:48 <wli> anybody: For instance, an expression tree parametrized on variable types is a monad. return is just returning a variable whose identity is what you're returning. fmap just applies a function to every variable ID in the syntax tree. If you've got a syntax tree of syntax trees it has a standard interpretation as an un-nested syntax tree, basically by attaching every syntax tree used as a variable ID in place of the variable expression.
12:30:55 <glguy> @type let bind m f = join $ fmap f m in bind
12:30:57 <lambdabot> forall (f :: * -> *) a a1. (Monad f, Functor f) => f a -> (a -> f a1) -> f a1
12:31:04 <glguy> shesh :) you think I'd learn
12:31:28 <wli> anybody: lists work out this way too. return x = [x] is obvious, fmap is just map, and join is concat.
12:31:39 <glguy> @type let bind m f = join $ liftM f m in bind
12:31:41 <lambdabot> forall (m :: * -> *) a1 a. (Monad m) => m a1 -> (a1 -> m a) -> m a
12:32:28 <wli> anybody: Same for Maybe. return = Just, fmap f Nothing = Nothing, fmap (Just x) = Just (f x), join Nothing = Nothing, join (Just Nothing) = Nothing, join (Just (Just x)) = Just x
12:33:14 <samreid> anybody: learn to use do notation for lists, IO, State, and Maybe, and then implement your own (>>=) function using do notation, and you should be more comfortable
12:33:23 * glguy finds the nick "anybody" to make for confusing conversation
12:33:41 * anybody confused too now
12:33:45 <samreid> mr. anybody: and consider a change of nick :P
12:33:50 <wli> anybody: Looking at it this way helps me a lot. It also helps to learn to do it other ways, because (>>=) is how you really use it, so understanding (>>=) as a primitive is very important.
12:35:01 <anybody> wli: i don't see where the fmap comes from. in the wikibook there is only mention of >>= (join) and return
12:35:13 <glguy> >>= isn't join
12:35:20 <EvilTerran> >>= is bind
12:35:24 <anybody> >>= is map?
12:35:27 <anybody> oh
12:35:39 <wli> anybody: x >>= f = join (fmap f x)
12:36:00 <Khoth> anybody: You might want to write code using Maybe, State, IO etc for a bit, and then work out how they work later, after getting a feel for what they do
12:36:09 <int-e> and  fmap f x = x >>= return . f
12:36:14 <EvilTerran> alternatively, fmap f x = do { x' <- x; return (f x) }
12:36:26 <EvilTerran> sorry, return (f x') of course
12:36:45 <wli> To get off the ground I found it easier to use (return, fmap, join) as primitive.
12:36:47 <byorgey> anybody: they're trying to drown you in Haskell, just don't pay attention and learn at your own pace if you're confused =)
12:36:51 <EvilTerran> @src liftM
12:36:52 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:37:02 <EvilTerran> ?type liftM
12:37:03 <EvilTerran> ?type fmap
12:37:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:37:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:37:11 <anybody> byorgey: ok
12:37:21 <newsham> ?src [] (>>=)
12:37:21 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:37:28 <EvilTerran> (fmap = liftM for monads)
12:37:49 <wli> xs >>= f = concatMap f xs for lists.
12:38:01 <int-e> join in the state monad isn't the simplest operation to grasp :)
12:38:12 <wli> Expression trees are vastly more enlightening.
12:38:23 <wli> int-e: It made sense to me, actually.
12:38:29 <ddarius> wli: Your interpretation works for all free monads.
12:38:34 <int-e> I found >>= easier
12:38:46 <xerox> Where's the good old Monads as containers.
12:39:06 * ddarius poos on Monads as Containers.
12:39:27 <xerox> <http://www.haskell.org/haskellwiki/Monads_as_Containers>
12:39:33 <byorgey> that gives me a great idea for a new monad tutorial!
12:39:50 <xerox> anybody - try reading that, I found it useful when I started.
12:39:51 <wli> The substitution monad on expression trees is incredibly enlightening. It just needs a more verbose and newbie-friendly exposition (and, for that matter, modernized code) than Mark Jones' old papers.
12:39:57 <byorgey> think of a monad as a container of poo...
12:40:39 <anybody> xerox: thx.
12:41:07 <wli> If it took me 9 years to smoke out what was going on in springschool95.ps it needs some breaking down into newbie-friendlier terms.
12:42:16 <glguy> wli: Functional Programming with Overloading and Higher-Order Polymorphism?
12:42:40 <glguy> err nvm
12:43:11 <ddarius> (>>=) can generally be related to substitution.
12:43:35 <glguy> wli: do you have a copy laying around?
12:43:56 <glguy> oh, maybe that was it
12:44:23 <igel> good evening everyone
12:44:32 <anybody> lol , monads as a spacesuit
12:44:32 <wli> glguy: That was it, yes.
12:44:39 <anybody> i guess i'll go with that analogy
12:44:43 <igel> how can i split a module into several files?
12:44:52 <igel> is there something like #include?
12:45:02 <wli> igel: import
12:45:12 <samreid> igel: you can export modules in the export list
12:45:14 <igel> i always get circular dependencies
12:45:28 <wli> igel: Write .hi-boot files. They're easy.
12:45:30 <ivant> @djinn [(a,b)]->([a],[b])
12:45:34 <lambdabot> -- f cannot be realized.
12:45:45 <ddarius> djinn doesn't do recursive types
12:46:03 <EvilTerran> ?type unzip
12:46:05 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
12:46:20 <ddarius> @hoogle [(a,b)] -> ([a],[b])
12:46:20 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
12:47:41 <wli> Is "classify" a good name for foldr ((first . (:)) ||| (second . (:))) ([],[]) ?
12:47:52 <wli> Or is "segregate" better?
12:47:53 <ivant> thanks!
12:48:01 <xerox> That looks nice.
12:48:03 <Botje> wli: that looks an awful lot like unzip
12:48:07 <Botje> :t unzip
12:48:09 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
12:48:12 <wli> :t foldr ((first . (:)) ||| (second . (:))) ([],[])
12:48:14 <lambdabot> forall b c. [Either b c] -> ([b], [c])
12:48:20 <xerox> splitEithers
12:48:23 <Botje> *duh*
12:48:38 <wli> xerox: splitEithers is actually pretty good, too.
12:48:42 <Botje> first /= fst of course, nevermind :)
12:49:06 <igel> wli: can you give me a hint where to find a description for these files?
12:49:07 <samreid> centrifugeEithers
12:49:16 <igel> i'm not finding much in the ghc-documentation
12:49:24 <xerox> wli: and that definition is really nice :)
12:49:25 <igel> but i'm probably just blind ;)
12:49:42 <wli> :t let { split = (first . cons) ||| (second . cons) ; cons = mappend . return } in Data.Foldable.foldr split (mempty, mempty)
12:49:43 <quicksilver> wli: it's called splitEithers in a ghc bug report somewhere
12:49:44 <lambdabot> forall a (m :: * -> *) (t :: * -> *). (Monad m, Monoid (m a), Data.Foldable.Foldable t) => t (Either a a) -> (m a, m a)
12:49:52 <wli> quicksilver: Nice.
12:49:55 <quicksilver> wli: where they debate adding it to Data.Either
12:50:01 <quicksilver> wli: although not with your cool definition :)
12:50:02 <Baughn> :t (|||)
12:50:04 <wli> :t liftM2 (,) (return ||| const mzero =<<) (const mzero ||| return =<<)
12:50:05 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
12:50:06 <lambdabot> forall (m :: * -> *) b c. (MonadPlus m) => m (Either b c) -> (m b, m c)
12:50:55 <quicksilver> wli: normally you see \l -> ([x | Left x <- l],[x | Right x <- l])
12:51:02 <xerox> I wonder if it changes the order.
12:51:09 <wli> quicksilver: That's equivalent to liftM2 (,) (return ||| const mzero =<<) (const mzero ||| return =<<)
12:51:36 <xerox> > foldr ((first . (:)) ||| (second . (:))) ([],[]) [Left 1, Right 2, Left 3, Right 4]
12:51:38 <lambdabot>  ([1,3],[2,4])
12:52:14 <Lamperi> ~.
12:52:39 <quicksilver> > (\l -> ([x | Left x <- l],[x | Right  x <- l])) [Left 1, Right 2, Left 3, Right 4]
12:52:41 <lambdabot>  ([1,3],[2,4])
12:52:44 <xerox> Ah, fold*r*.
12:52:53 <xerox> It's building up a big thunk, alright.
12:53:29 <quicksilver> :t first . (:)
12:53:30 <lambdabot> forall d a. a -> ([a], d) -> ([a], d)
12:54:27 <wli> quicksilver: Foldable.foldr ((first . mappend . return) ||| (second . mappend . return)) (mempty, mempty) is both single-pass and quite general.
12:54:35 <igel> wli: ah, just found it, thanks for the hint :)
12:55:28 <quicksilver> wli: yes, very cute
12:55:51 <wli> quicksilver: I polished up @pl's and mauke's results by hand for that.
12:55:54 <quicksilver> :)
12:56:52 <quicksilver> :t mappend . return
12:56:54 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => a -> m a -> m a
12:57:22 <quicksilver> wli: restricts you to Monoids which are also monads, in which case you might as well use mplus?
12:57:31 <quicksilver> :t mplus . return
12:57:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => a -> m a -> m a
12:58:05 <quicksilver> wli: you don't really want return there, you want something more general...
12:58:14 <wli> quicksilver: Oh?
12:58:54 <wli> quicksilver: Maybe Data.Foldable.foldr ((first . mplus . return) ||| (second . mplus . return)) (mzero, mzero) ?
12:59:31 <atsampson> byorgey: that should work nicely, ta :)
13:00:02 <byorgey> atsampson: glad to hear it.
13:00:15 <byorgey> wli: why do you need to involve monads at all?
13:00:27 <xerox> byorgey: to subsume lists
13:00:33 <wli> byorgey: They're more general than lists.
13:00:34 <quicksilver> byorgey: for return
13:00:50 <quicksilver> byorgey: really he wants a Monoid-with-return
13:00:52 <quicksilver> byorgey: or something
13:00:57 <sjanssen> wli: how about 'foldMap (return ||| return)'?
13:01:25 <byorgey> ok, never mind, now I get it
13:02:12 <wli> sjanssen: Typechecking?
13:02:20 <sjanssen> wli: sorry, that's not quite right
13:02:27 <quicksilver> or is it foldable-with-return over a monoid?
13:02:49 <quicksilver> [] is Monad, Foldable, and Monoid..
13:02:54 <quicksilver> (and MonadPlus)
13:05:15 <wli> quicksilver: Dumping the Monoid for MonadPlus seems possible.
13:05:28 <byorgey> hm, is mappend . return for lists the same as (:)?
13:05:45 <wli> byorgey: pretty much
13:05:49 <EvilTerran> ?type mappend
13:05:51 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:06:07 <EvilTerran> @src mappend
13:06:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:06:10 <EvilTerran> @src [] mappend
13:06:11 <lambdabot> Source not found. stty: unknown mode: doofus
13:06:13 <wli> :t mappend . return
13:06:15 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => a -> m a -> m a
13:06:37 <wli> :t (mappend . return) `asTypeOf` (:)
13:06:39 <lambdabot> forall a. a -> [a] -> [a]
13:06:49 <sjanssen> @pl \x -> (x, mempty)
13:06:49 <lambdabot> flip (,) mempty
13:07:33 <byorgey> ah, ok, it just clicked =)
13:08:00 <DRMacIver> sjanssen: Or id &&& const mempty
13:08:23 <wli> sjanssen: There's no product monoid instance that I'm aware of (though maybe there should be).
13:08:54 <DRMacIver> Hm. In fact that's just second $ const mempty
13:08:57 <sjanssen> wli: there is (Monoid a, Monoid b) => Monoid (a, b)
13:09:06 <xerox> DRMacIver: no, those are different
13:09:14 <wli> sjanssen: Hmm, then it should work.
13:09:16 <xerox> DRMacIver: the latter is id *** const mempty
13:09:35 <DRMacIver> Oh, so it is.
13:09:38 <DRMacIver> My mistake.
13:09:58 <sjanssen> foldMap ((return &&& mempty) ||| (mempty &&& return))
13:10:15 <sjanssen> I don't know my way around Control.Arrow very well, is there a better way to write that?
13:10:33 <wli> sjanssen: Very slick.
13:10:37 <xerox> Where's foldMap?
13:10:41 <wli> sjanssen: I think you've crushed it.
13:10:47 <wli> xerox: Data.Foldable.
13:11:25 <sjanssen> small mistake: foldMap ((return &&& const mempty) ||| (const mempty &&& return))
13:11:25 <xerox> Nice.
13:11:46 <xerox> It needed strange monoid instances :)
13:11:55 <Arpa121> Hello gays :D do you remember me ?!
13:12:47 <sjanssen> @type (|||)
13:12:49 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
13:12:49 <DRMacIver> sjanssen: Hm. I feel like there should be some cunning thing you can do with flip that elimiinates the repetition of const mempty &&& return
13:12:52 <sjanssen> @type either
13:12:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:13:03 <DRMacIver> sjanssen: But I don't see it at the moment.
13:13:23 <sjanssen> so ||| is just either in any arrow
13:13:34 <sjanssen> @type (&&&)
13:13:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:14:42 <DRMacIver> Do I need to link to my article again? :)
13:15:09 <notpalomer> hello, what do you guys use as an infinite list of variable names?
13:15:31 <sjanssen> palomer, notpalomer, notnotpalomer, etc.
13:16:12 <DRMacIver> > ["foo", "bar"..]
13:16:13 <lambdabot>   add an instance declaration for (Enum [Char])
13:16:13 <lambdabot>     In the expression: ["foo"...
13:16:16 <DRMacIver> Oh well. :)
13:16:31 <notpalomer> let variables = "palomer" ++ map ("not"++) variables in variables
13:16:38 <notpalomer> > let variables = "palomer" ++ map ("not"++) variables in variables
13:16:39 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
13:16:49 <notpalomer> > let variables = ["palomer"] ++ map ("not"++) variables in variables
13:16:50 <lambdabot>  ["palomer","notpalomer","notnotpalomer","notnotnotpalomer","notnotnotnotpalo...
13:16:58 <sjanssen> > mapM (flip replicateM "ab") [1..]
13:17:02 <lambdabot> Terminated
13:17:32 <sjanssen> > flip replicateM "ab" =<< [1..]
13:17:33 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
13:17:50 <byorgey> hi Arpa121, how goes it?
13:17:50 <sjanssen> replace "ab" with ['a' .. 'z'] for best results
13:18:34 <wli> sjanssen: How should I cite you?
13:18:45 <sjanssen> whoa, cite me?
13:18:48 <sjanssen> wli: Spencer Janssen
13:20:41 <xerox> ?fresh
13:20:41 <lambdabot> Haf
13:20:52 <xerox> exactly that :)
13:21:42 <Arpa121> byorgey its so fun and nice
13:21:46 <glguy> Alright, time's up. Let's do this
13:21:58 <Arpa121> could we work with Database in haskell ?
13:22:11 <adamjones> Can anyone confirm that the Graphics.SOE in ghc6.6 works as intended for the School of Expression book? I'd rather know now than halfway through if I need to dig around for another copy of the library.
13:22:17 <wli> Arpa121: Sure. Try HaskellDB, HSQL, hAppS, etc.
13:22:22 <glguy>  ?remember Arpa121  could we work with Database in haskell ?
13:22:32 <sjanssen> glguy: too many spaces
13:22:38 <glguy> sjanssen: intentional ;)
13:22:38 <xerox> adamjones: yes, there's also a cario-based vector-graphics version in Gtk2Hs of SOE :)
13:22:52 <glguy> ?quote predi
13:22:52 <lambdabot> ddarius says: What's a predicate?
13:22:57 <adamjones> xerox: thanks.
13:23:08 <kpreid> "is a predicate" is a predicate
13:23:25 <sjanssen> Exception: <<loop>>
13:23:33 <matthew-_> a isn't a predicate, it's a pronoun ;)
13:24:37 <xerox> sjanssen: > mdo { os <- Just (1:map (+1) es); es <- Just (map (+1) os); return (transpose [os,es]) }
13:25:04 <xerox> I thought you turned in a lambdabot :D
13:25:48 <sjanssen>  Parse error
13:26:00 <xerox> argh :)
13:27:26 <olsner> anyone here who can explain that "I wish. It's machine code." meme?
13:28:30 <adamjones> olsner: oslhttp://www.encyclopediadramatica.com/Machine_Code
13:28:31 <lambdabot> Title: Machine Code - Encyclopedia Dramatica
13:28:43 <adamjones> err, http://www.encyclopediadramatica.com/Machine_Code
13:28:47 <lambdabot> Title: Machine Code - Encyclopedia Dramatica
13:29:15 <olsner> adamjones: yeah, been there.. says it's "self-explanatory"
13:29:30 <DukeDave> Can anyone recommend any papers / literature on first class functions?
13:29:31 <adamjones> It's a 4chan meme pulled from some DC comic.
13:29:57 <adamjones> The 4chan part means "logic is an optional feature", if that helps.
13:29:58 <DukeDave> I need something to cite like "treating functions as first class object first arose.." :)
13:30:41 <olsner> adamjones: yeah, I guess extracting meaning from 4chan is a fruitless endeavor
13:31:30 <EvilTerran> i dunno, there's the occasional good intellectual conversation
13:32:24 <Baughn> EvilTerran: On _4chan_?
13:33:10 <EvilTerran> yeah. there seems to be a higher density of smart people playing stupid than is at first apparent
13:34:18 <byorgey> DukeDave: maybe a good place to start is Backus' Turing award lecture?
13:34:25 <byorgey> @go Backus Von Neumann style
13:34:28 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
13:35:11 <EvilTerran> "papercraft & origami" and "photography" tend to be pretty good, fehrinstance
13:35:17 * EvilTerran wanders off
13:35:28 <byorgey> DukeDave: that's probably not the first place anyone thought about first-class functions, but it's a good first-order approximation
13:35:32 <DukeDave> Ah yes I forgot about that, cheers byorgey
13:35:51 <igel> @users
13:35:51 <lambdabot> Maximum users seen in #haskell: 371, currently: 356 (96.0%), active: 20 (5.6%)
13:36:20 <malsyned> Can anyone suggest possible reasons why an IO action involving runInteractiveProcess would work just fine from ghci, but then lock up when run from a compiled program?  I'm on win32.
13:36:31 <DukeDave> A paper I'm reading now states LISP was the first language to support them :|
13:37:12 <igel> malsyned: i had a comparable problem with splitting off a gtk-thread
13:37:27 <augustss> DukeDave: The term "first class function" is old.  Maybe Joe Stoy's book on denotational semantics is a good place to start digging.  If you can find it.
13:37:48 <malsyned> DukeDave: first-class functions predate computer programming languages.  You could go all the way back and cite Church's paper on Lambda Calculus.
13:37:50 <xerox> malsyned: what's the code?
13:37:52 <augustss> DukeDave: LISP got it wrong at first
13:37:57 <malsyned> Hang on, I'll paste
13:37:58 <malsyned> @hpaste
13:37:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:38:23 <monochrom> malsyned: I guess different buffering policies.
13:38:32 <augustss> DukeDave: Is it the term or the concept you are looking for?
13:38:37 <mrd> the original lisp paper and interpreter describes a language based on lambda-calculus, but it failed to implement the scoping rules correctly.
13:38:56 <mrd> this was later rectified by scheme
13:39:04 <igel> malsyned: iirc our problem was the difference between forkIO and forkOS
13:39:13 <igel> (light-weight and os-threading)
13:39:24 <Heffalump> what is 4chan, and why have I just heard about it for the first time ever in two places almost simultaneously?
13:39:39 <igel> it's just a mere guess, but it sounds like the same problem-class ;)
13:39:51 <wli> I've got a testcase for the usage of readline going wrong, but no solution. :(
13:40:32 <olsner> Heffalump: it's the bottom of the internet
13:40:37 <xerox> Heffalump: something like a forum, based on images, I think
13:40:43 <hpaste>  malsyned pasted "Interaction with the psftp prompt" at http://hpaste.org/2116
13:41:35 <Heffalump> forums should all be news anyway.
13:41:53 <monochrom> malsyned: definitely buffering. do you hFlush after hPutStr?
13:42:01 <malsyned> nope
13:42:15 <adamjones> Heffalump: then it is a message board with images, and lots of (faked or genuine) stupidity.
13:42:16 <monochrom> If you don't hFlush, the psftp process never receive anything.
13:42:29 <malsyned> so after getContents >>= hPutStr inH, I should hFlush inH?
13:42:52 <igel> yeah, ghci does no buffering
13:42:58 <monochrom> No. hPutStr inH cmds; hFlush inH
13:43:22 <malsyned> oh.  duh.  I was reading the wrong function for  a sec there.
13:43:34 <igel> or set the buffer to NoBuffering
13:43:43 <monochrom> Not very efficient.
13:43:47 <igel> yes
13:44:02 <igel> but it's one of the few differences between ghci and a compiled .hs
13:44:04 <malsyned> ay!  that did it.  thanks!
13:44:05 <monochrom> Also, if psftp is buggy, NoBuffering triggers some other bugs in psftp.
13:44:07 <igel> ghci does no buffering
13:46:26 <monochrom> (If I wrote any program reading from stdin or socket, I would easily introduce that bug too. Basically, I issue a "read" syscall, then I expect one complete line in it. That means you issue one single "write" syscall to send me your line. If you NoBuffering, you likely split it into as many "write"s as there are characters. I read an incomplete line and get confused.)
13:48:05 <monochrom> (Yeah yeah, I should loop over "read" until I accumulate a complete line. But if I write in C rather than Haskell, you can see how much more work that means, and I'm lazy.)
13:48:30 <notpalomer> hmm
13:48:44 <notpalomer> well, andAlso :: m a -> m a -> m a is pretty screwy
13:48:56 <notpalomer> the right signature should be m a -> m a -> m ()
13:49:05 <timthelion> in vim, is it possible to have the types of functions displayed in the type of the function overwhich the cursor is, in the status line?
13:49:13 <monochrom> (Of course, it's also likely that one hPutStr translates to just one "write" under NoBuffering, and there is no problem.)
13:49:19 <notpalomer> or else you get a weird algebra
13:49:43 <igel> monochrom: so you need to flush after each linebreak?
13:49:49 <monochrom> Yes.
13:49:51 <igel> that should be quite easy
13:50:10 <monochrom> Oh, LineBuffering does all the work for us. :)
13:50:17 <igel> hlineFlush :: Handle -> String -> ...
13:50:20 <igel> argh ok :)
13:50:50 <igel> otherwise there would have been a short way using takeWhile and mapM ;)
13:51:35 <monochrom> But there are network protocols not based on line. They're based on packets. One packet means one "write" or "read". There you have to be more paranoid.
13:52:36 <igel> shure
13:53:06 <igel> i stumbled over that flushing-thing looking vor divisors of large numbers
13:53:16 <igel> in ghci they were nicely printed one by one
13:53:33 <monochrom> heh heh heh!
13:53:41 <igel> after compiling the program i wondered why on earth it took him so long to find the 2 :)
13:57:26 <mrd> timthelion: got clause reinke's vimscripts?
14:00:11 <shapr> Is Foo.Bar a legal name for cabal packages?
14:01:23 <shapr> Or, will it cause any problems if I put a package in hackage that's named that way?
14:01:45 <shapr> Ah, it isn't legal.
14:01:48 <shapr> too bad
14:02:07 <hpaste>  trie pasted " functional dep" at http://hpaste.org/2117
14:02:13 <drigz> shapr: why is it illegal?
14:02:42 <shapr> drigz: Because cabal won't parse the package name field when it has a dot in it, I assume.
14:03:32 <drigz> aren't there lots of ones like Data.ByteString? or is that not the name?
14:03:36 <trie> quick question about function dependencies - How is the declaration of type One' legal in http://hpaste.org/2117 ?
14:03:41 <drigz> apparently not
14:04:02 <sjanssen> trie: there aren't any functional dependencies in the code you've pasted
14:04:55 <sjanssen> trie: also, the "Nat n" constraint only applies on *construction* of a 'Nat' (by using the Succ constructor)
14:05:07 <trie> sjanssen: Oops correct not yet! Right now I am just curious why "type One' = Succ Bool" compiles
14:05:12 <sjanssen> actually, I misread that
14:05:37 <sjanssen> trie: because class constraints on data types only apply when building a value with a constructor
14:05:59 <sjanssen> you can always write "undefined :: Succ String", or whatnot
14:06:50 <trie> ok thanks, That would explain that.
14:09:48 <Cale> Hello
14:10:17 * bos watches some farbrausch demos. golly wow.
14:11:43 <malsyned> is there a version of hPutStr that doesn't translate '\n' to CRLF on win32?
14:12:14 <Japsu> bos: watch also LifeForce and Iconoclast by Andromeda Software Development
14:12:28 <sjanssen> malsyned: open the handle in binary mode
14:12:29 <Japsu> they kick... keister
14:12:51 <malsyned> sjanssen: I asked the wrong question.  I meant to type putStr, not hPutStr.
14:13:16 <sjanssen> malsyned: hSetBinaryMode stdin True -- should work
14:13:29 <sjanssen> s/stdin/stdout
14:13:35 <malsyned> I'll give it a shot.
14:14:48 * monochrom naughtily suggests erasing win32 :)
14:15:35 <malsyned> monochrom: just as soon as Microchip development tools start supporting Linux.
14:16:00 <xerox> shapr: more changes to parsec, now all of it can be run on every instantiated Stream, libraries too :)
14:17:25 <monochrom> Hmm, I heard of the name Microchip from Dilbert cartoons. :)
14:17:25 <sjanssen> xerox: what is a Stream?
14:17:26 <bos> Japsu: thanks for the pointers
14:17:31 <xerox> If people are willing to try it, I'd appreciate feedback <http://darcs.haskell.org/~paolo/darcs/parsec/>.
14:17:51 <xerox> sjanssen: something that provides head and tail.
14:17:59 <Japsu> bos: yeah np... LifeForce won the Demo competition at Assembly last Saturday night, it was absolutely stunning
14:19:21 <xerox> I.e. nothing like the Stream datastructure used for Stream fusion. Something like [tok], which parsec always used, or ByteString.Char8, or ByteString.Lazy.Char8, or ...
14:19:46 <mornfall> anyone can tell me why let x = y where y = x in x hangs ghci? :)
14:20:10 <xerox> > let x = y where y = x in x
14:20:12 <lambdabot>  Exception: <<loop>>
14:20:20 <monochrom> infinite loop.
14:20:23 <xerox> Right?
14:20:38 <mornfall> infinite loop, yes, but it doesn't produce cpu activity... or doesn't seem to
14:20:40 <monochrom> you may as well write "z = z"
14:20:52 <mornfall> sits there doing nothing
14:21:03 <ray> > let x = x in x
14:21:04 <lambdabot>  Exception: <<loop>>
14:21:11 <ray> same thing
14:21:13 <mornfall> right
14:21:26 <sjanssen> mornfall: yeah, that is weird
14:21:27 <xerox> It isn't supposed to do much anyway :)
14:21:47 <monochrom> ghci does deviate from compiled code in pathological cases like these.
14:21:58 <mornfall> i've figured it'd either yell at me or grind cpu or something
14:22:20 <monochrom> deadlock is also a legitimate behaviour.
14:22:24 <Cale> mornfall: In a compiled program it'll throw an exception, as you can see there.
14:22:29 <mornfall> right
14:22:39 <mornfall> whatever :-) i've asked out of sheer curiosity
14:22:46 <mornfall> thanks for answers
14:22:56 <Cale> (because it'll detect that you're trying to evaluate something that you're already trying to evaluate)
14:23:33 <monochrom> If I knew ghci internals, I would explain it. But I don't. However, I do know that ghci bytecode is still different from compiled code, so deviations don't surprise me.
14:33:02 <rubyruy> what is the bracket function?
14:33:18 <sjanssen> @hoogle bracket
14:33:19 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:33:19 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
14:33:19 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
14:33:19 <glguy> rubyruy: the parsec one?
14:33:22 <glguy> oh
14:33:26 <glguy> nvm, the IO one
14:33:30 <glguy> (isn't a parsec one)
14:33:51 <glguy> bracket has three arguments: a way to instanciate resources, a way to use them and a way to clean up
14:34:03 <glguy> if the "use them" part fails , they are still passed to the clean up
14:35:11 <rubyruy> where is it documented? i don't see it System.IO
14:35:49 <xerox> ?docs Control.Exception -- there
14:35:49 <lambdabot> Control.Exception -- there not available
14:35:52 <xerox> haha
14:36:00 <xerox> ?docs Control.Exception
14:36:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
14:36:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Abracket
14:36:25 <lambdabot> http://tinyurl.com/sqmlj
14:36:29 <rubyruy> i thought haskell perfered to do exceptions using the Maybe type ?
14:36:53 <Cale> IO also has its own exception mechanism though.
14:36:53 <bos> rubyruy: no, there's a bunch of ways to handle errors
14:37:31 <wli> ErrorT a.k.a. Either exceptionType resultType is nice.
14:41:36 <xerox> ?type (Control.Exception.throwDyn, Control.Exception.catchDyn)
14:41:38 <lambdabot> forall exception b a exception1. (Typeable exception, Typeable exception1) => (exception -> b, IO a -> (exception1 -> IO a) -> IO a)
14:54:35 <malsyned> Do I return ExitStatusFailed Int or ExitStatusSuccess from main in order to return an exit code to the shell?
14:55:05 <mrd> ExitStatusSuccess returns the 0 code
14:55:11 <xerox> You can directly return the Int if you want.
14:55:12 <sjanssen> @hoogle exit
14:55:13 <lambdabot> System.Exit :: module
14:55:13 <lambdabot> System.exitFailure :: IO a
14:55:13 <lambdabot> System.exitWith :: ExitCode -> IO a
14:55:22 <sjanssen> malsyned: exitWith
14:55:24 <xerox> exitWith is probably cleaner
14:55:31 <Cale> malsyned: You  exitWith ExitSuccess or exitWith (ExitFailure n)
14:55:57 <malsyned> So I'd do (waitForProcess pid >>= exitWith) then.
14:57:07 <malsyned> Thanks guys.
15:00:04 <chessguy> 'evening
15:01:41 <chessguy> wow, quiet in here tonight
15:02:04 <MisterN> @type (->)
15:02:07 <lambdabot> parse error on input `->'
15:03:17 <hpaste>  lament pasted "Interactive dictionary with IORefs" at http://hpaste.org/2119
15:04:20 <lament> is this how you would implement a user-modifiable dictionary, or is it unidiomatic?
15:06:36 <Cale> lament: That'll work :)
15:07:00 <noteventime> Wow, this channel is pretty large :-)
15:07:25 <lament> yay
15:08:00 <nburlett> @pl \x -> x y z
15:08:00 <lambdabot> flip ($ y) z
15:08:02 <Cale> noteventime: Learning Haskell?
15:08:09 <noteventime> Cale: Yes
15:08:14 <wli> lament: hmm
15:08:28 <nburlett> hm... I think my point-full version is better
15:08:32 <Cale> noteventime: Cool, make sure to ask lots of questions :)
15:08:41 <SamB> @. pl djinn (a -> b) -> (a -> c -> d) -> (b -> c -> d)
15:08:41 <lambdabot> (line 1, column 1):
15:08:42 <lambdabot> unexpected "-"
15:08:42 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
15:08:43 <noteventime> I know some OCaml :-P
15:08:48 <SamB> @djinn (a -> b) -> (a -> c -> d) -> (b -> c -> d)
15:08:48 <lambdabot> -- f cannot be realized.
15:09:05 <noteventime> And some Lisp, I hope it will make things a little easier
15:09:12 <Cale> noteventime: Ah, yeah, it'll be easier for you :)
15:10:11 <chessguy> @kind ((->) r)
15:10:13 <lambdabot> Not in scope: type variable `r'
15:10:14 <SamB> oh, that's just (.)
15:10:21 <noteventime> Haskell seems way more readable than OCaml. Even though the syntax (at least to a novice) looks rather similar.
15:10:42 <Cale> Yeah.
15:10:57 <SamB> @djinn (a -> b) -> (c -> a) -> (c -> b)
15:10:57 <lambdabot> f a b c = a (b c)
15:10:58 <noteventime> Can I define functions in the interactive environment?
15:11:08 <noteventime> I always seem to get "unexpected ="
15:11:11 <Cale> noteventime: In GHCi, you can use  let ...
15:11:18 <Cale> let f x = x + 1
15:11:29 <noteventime> Ok, but not in hugs?
15:11:47 <Cale> Yeah, hugs only wants expressions
15:11:48 <noteventime> I just compiled ghc, I was using hugs before
15:12:04 <noteventime> Took hours as I also had to compile GCC 4.2 X-D
15:12:08 <Cale> What platform?
15:12:16 <noteventime> x86_64 linux 2.6
15:12:39 <lament> hm, now if i had a dictionary in which each individual value was also a dictionary, all these IORefs would get quite messy
15:12:40 <noteventime> Gentoo
15:12:56 <Cale> Ah, there's a binary package, you know :)
15:13:27 <noteventime> I figured I'd want gcc 4.2 sooner or later anyway
15:13:58 <noteventime> And I don't want to mess up portage (gentoos packaging system)
15:14:07 <SamB> what's "x * y = y * x" called again?
15:14:14 <Cale> SamB: Commutativity
15:15:19 <noteventime> Is it possible to write multi-line expressions in GHCi?
15:15:33 <sjanssen> noteventime: use ;
15:15:42 <Cale> By using explicit ;'s and possibly {}
15:15:45 <qwr> noteventime: if you know ocaml, learn haskell syntax (there isn't very much of it actually, just a bit some weird staff) and then go for some monad tutorial like all about monads ;)
15:16:02 <noteventime> I guessed that far, I was wondering if it could be avoided
15:16:05 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
15:16:05 <lambdabot> Title: Tour of the Haskell Syntax
15:16:35 <qwr> (and it is lazy of course...)
15:16:43 <noteventime> qwr: I kinda new about using {} and ;, I was wondering if there was some way to use the indentation style in GHCi :-)
15:17:04 <Cale> Yeah, laziness is a big sneaky difference. You end up writing things really inefficiently until you get used to that :)
15:17:08 <noteventime> Yes, I watched the videos from OSCon
15:17:23 <noteventime> Those got me started
15:17:37 <Cale> noteventime: nope -- GHCi/hugs are really to be thought of kind of like debuggers/testing tools
15:17:45 <noteventime> I was learning OCaml, but after watching the videos I figured I'd give haskell a shot
15:18:10 <Cale> You also can't define new types at the GHCi prompt.
15:18:18 <Cale> (or typeclasses)
15:18:29 <noteventime> ok
15:18:35 * SamB looks up "ring" and turns the definition into quickcheck properties
15:18:55 * qwr thinks both ocaml and haskell are useful...
15:19:05 <chessguy> SamB, what are you working on?
15:19:13 <Cale> So mostly you'll want to keep your editor open alongside GHCi and whenever you save your file in the editor, just type  :r  (or even just ':') in GHCi, and it'll reload the file.
15:19:23 <noteventime> I'm still amazed at how much more readable certain things are with pattern matching
15:19:23 <qwr> ocaml is a bit more low-level ;)
15:19:34 <chessguy> or just C-c C-r :)
15:19:48 <noteventime> Not that is really matters, but how do Haskell and OCaml compare performance wise?
15:19:49 <xerox> There's a hack to do multiline expr, where was it...
15:19:53 <chessguy> (if you use a real editor)
15:19:58 <ivant> is there some channel like #yi?
15:20:06 <chessguy> @where shootout
15:20:07 <lambdabot> http://shootout.alioth.debian.org/
15:20:19 <noteventime> Cale: Ahh, I've been reloading the file with :l
15:20:24 <noteventime> :r will come in handy
15:20:41 <noteventime> Is there some kinda of cheat sheet available?
15:20:53 <Cale> :?
15:21:05 <noteventime> perfect :-P
15:21:28 <SamB> chessguy: arbitrarily inefficient integers
15:21:32 <sorear> noteventime: Pretty comparable.  I wrote an Unlambda compiler, and targeted it to both OCamlopt and GHC -O2; the performance differences were immesurable.
15:21:38 <SamB> chessguy: because I'm too lazy to upgrade GHC
15:21:58 <noteventime> sorear: Ok
15:22:06 <sorear> noteventime: Of course, this completely ignores the effects of culture.  Haskell programmers tend to write laziness-intensive code, for instance, since it's so easy.
15:22:26 <noteventime> Sure, I just meant it in an informal kinda way :-)
15:23:50 <SamB> Haskell performance can only go up
15:23:53 <noteventime> I'm currently reading "A Gentle Introduction to Haskell 98". I find it OK this far, is it a good place to start?
15:24:17 <SamB> noteventime: some people think it brutal
15:24:18 <noteventime> I feel a lot more clean when doing things in Haskell and Lisp than when doing them in C++
15:24:36 <noteventime> SamB: As in too fast?
15:24:45 <SamB> not sure exactly
15:24:55 <noteventime> Ok :-P
15:24:56 <SamB> I don't remember what tutorial I used :-(
15:25:15 <noteventime> Well, as long as it doesn't have the same reputation as NeHe, I don't mind
15:25:29 <noteventime> :-) Just wanted to make sure I wasn't way off
15:25:31 <SamB> though I think I interleaved it heavily with the Haskell 98 report
15:25:31 <chessguy> what's NeHe?
15:25:42 <mrd> if you know ocaml then the gentle intro should be familiar
15:25:42 <noteventime> chessguy: An OpenGL tutorial page
15:25:52 <ddarius> @google NeHe Tutorial
15:25:54 <lambdabot> http://nehe.gamedev.net/
15:25:54 <lambdabot> Title: NeHe Productions: Main Page
15:26:12 <qwr> noteventime: the gentle introduction is good, if you like terse tutorials
15:27:13 <noteventime> qwr: Sounds good, I want to get a good quick overview of the language before I dig any deeper
15:28:23 <noteventime> Currently reading "The art of computer programming", I'm hoping to be able to combine it with learning Haskell
15:28:30 <Cale> noteventime: The syntax tour I linked to is probably handy if you're coming from O'Caml :)
15:28:56 <noteventime> Cale: Bookmarked ;-)
15:29:29 <noteventime> I always manage to confuse syntax (always trying to learn way to many languages at once)
15:29:35 <noteventime> So that reference is great
15:29:58 * ddarius should learn a new language.
15:30:05 <ddarius> Maybe I will look at factor.
15:30:10 <noteventime> After this I'll probably learn Prolog
15:30:15 <sorear> noteventime: Perhaps some sample code would be good?  http://haskell.org/onlinereport/standard-prelude.html  about 20 years old, and older is better with haskell code :)
15:30:16 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
15:30:31 <noteventime> sorear: I'm not good at learning from code :-)
15:30:42 <RyanT5001> is there a good coq tutorial? preferably as theoretically rigorous as possible (i want to end up knowing how it works, too)
15:31:04 <sorear> RyanT5001: Hmm.  Does the official tutorial count?
15:31:49 <sorear> ftp://ftp.inria.fr/INRIA/coq/current/doc/Tutorial.v.ps.gz
15:31:59 <sorear> http://coq.inria.fr/V8.1/tutorial.html
15:32:21 * SamB wants a version of quickCheck.hs that compiles the boilerplate program, with lots of profiling, and runs it with +RTS -xc -p and optionally -hsomething...
15:33:15 <noteventime> Somehow the differences between OCaml and Haskell reminds me of the differences between Common Lisp and Scheme
15:33:43 <hpaste>  wli annotated "Interactive dictionary with IORefs" with "another way to do it" at http://hpaste.org/2119#a1
15:33:59 <SamB> noteventime: hmm.
15:34:17 <SamB> well, scheme doesn't have laziness, but then CL isn't functional...
15:34:24 <noteventime> SamB: Haskell seems cleaner, smaller and more concise
15:34:48 <noteventime> Which is the same feeling I got after trying Scheme
15:35:13 <sorear> SamB: Scheme could have had laziness.  Around R3RS (iirc), Steele was very nearly won over by the proto-lazy-FP zealots.  (from the HistoryofHaskell paper)
15:35:49 <noteventime> I think there is a lazy library for Common Lisp or Scheme
15:36:02 <sorear> it's in the prelude iirc
15:36:05 <sorear> (delay EXPR)
15:36:35 <sorear> I know one of the big two MLs has a lazy special form
15:37:06 <hpaste>  wli annotated "Interactive dictionary with IORefs" with "brown paper bag patch" at http://hpaste.org/2119#a2
15:37:14 <sorear> (The only ML program I've written was the runtime support module for the aforementioned Unlmabda compiler)
15:37:37 <slava> on the other hand, scheme is utterly useless for real work :)
15:37:57 <noteventime> That isn't too big a problem for me :-)
15:38:19 <qwr> slava: only pure scheme
15:38:45 <ddarius> slava: Do you get the documentation too if you darcs get the source code to factor?
15:38:45 <mrd> slava: more a function of the community
15:38:46 <qwr> slava: its perfect extension language ;)
15:38:58 <SamB> hmm.
15:39:01 <sorear> slava: Good luck writing much of a real program in ANSI C, or Haskell 98.  The libraries are just too small.
15:39:04 <mrd> haskell could have easily been like scheme, but people pushed to make GHC practical
15:39:07 <SamB> James Clark didn't seem to think so...
15:39:16 * SamB points at DSSSL
15:39:19 <slava> sorear: my point exactly; CL gives you a bit more than just linked lists and lambdas
15:39:25 <bitwize> There are lots of practical schemes
15:39:31 <bitwize> And that may be the problem.
15:39:36 <bitwize> "So many standards to choose from!"
15:39:42 <noteventime> I was forced too teach some Java at school (it was either that or really learning it). I wish I could have used Scheme.
15:39:48 <mrd> right, and ghc pretty much got most of the activity in haskell
15:39:49 <slava> it is possible to write useful ANSI CL code; you won't get far with just R5RS
15:40:11 <bitwize> PLT, SISC, Chicken, Gambit, Scheme48...
15:40:17 <noteventime> Stalin
15:40:19 <mrd> bigloo
15:40:20 <sorear> we've also had more collaboration
15:40:20 <slava> ddarius: yes
15:40:24 <mrd> stk
15:40:29 * SamB thinks DSSSL is basically pure, though it has some things that are effected by the environment... he doesn't remember if there's a way to do "local" in DSSSL or not, though.
15:40:40 <slava> haskell is also a more interesting language than scheme, i think.
15:40:48 <mrd> having a type system, yes =)
15:40:48 <sorear> first there was HSLibs, the Standard Hugs/GHC Library Extension (FiniteMap, PPrint, erc)
15:41:04 <sorear> then we had the Standard Hierarchal Libraries
15:41:17 <sorear> now we have hackage/cabal
15:42:21 <bitwize> DSSSL has been obsolesced by XSLT, though.
15:43:30 <bitwize> @quote dsssl
15:43:30 <lambdabot> No quotes match. You type like i drive.
15:43:37 <bitwize> @quote scheme
15:43:37 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
15:44:20 <anybody> hm i'm confused. could someone look at exercise 7 please and tell me whether bind should rather be defined as bind f (x,seed) = ...? http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
15:44:23 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
15:45:23 <anybody> its the example with the random nubmers
15:45:30 <anybody> s/nubm/numb/
15:46:02 * nominolo_ likes scheme conceptionally but still feels CL to be more useful - and CL has slime
15:47:02 <byorgey> anybody: no, it's correct.  given the type of bind, what types do f, x, and seed have in bind f x seed?
15:48:32 <sorear> ghc-6.7.20070712: unknown package: lang
15:48:39 <sorear> What's lang/
15:49:07 <anybody> byorgey: i don't know. the types look so cryptic... i guess f should be (a ? StdGen ? (b,StdGen)) but where are x and seed? in the bind type definition?
15:49:12 <nominolo_> sorear: maybe something Ian hacked in today?
15:49:29 <byorgey> anybody: one thing you should know is that -> associates to the right, so that (StdGen -> (b,StdGen)) at the end of bind's type can also be written without parentheses.
15:49:33 <sorear> nominolo_: this is old code
15:49:42 <sorear> @seen
15:50:05 <anybody> byorgey: oh. so x is (StdGen ? (a,StdGen)) and seed StdGen ?
15:50:14 <byorgey> anybody: right.
15:50:57 <sorear> GHC HEAD doesn't seem to like > data Cross f g x = f x :*: g x deriving Show
15:51:18 <byorgey> anybody: this is a rather complex example, BTW... if you get it, awesome, if you don't, no worries, just come back to it later.
15:52:01 <byorgey> anybody: which is not to say you shouldn't try, of course =)
15:52:26 <lament> @type liftIO
15:52:28 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:52:52 <anybody> byorgey: well i'm not sure if there is any point in trying to understand it when i haven't used random so far. so i don't know how random works in haskell anyway
15:53:41 <byorgey> anybody: probably wise.  if you try to stuff too much knowledge in your brain without using it, most of it will just fall out anyway =)
15:54:53 <anybody> byorgey: yeah. maybe its time to stop for today. have been learning haskell for ~ 10 hours straight ;-)
15:55:26 <glguy> 10 lazy hours?
15:55:42 <anybody> glguy: well. haskell is a lazy language ;-)
15:55:53 <byorgey> anybody: I know the feeling, it's so awesome you don't want to stop. =)
15:56:02 <MisterN> laziness jokes are just great :D
15:56:30 <anybody> byorgey: yeah especially the pattern matching capabilities. thats what i always wished c++ should have
15:56:42 <glguy> ?quote C++
15:56:42 <lambdabot> vegai says: in soviet russia, YOU blow up GHC's brain!
15:56:47 <glguy> ?quote C\+
15:56:47 <lambdabot> RyanT5000 says: i wish i had been programming in haskell for 7 years rather than C++
15:56:52 <byorgey> anybody: yeah, pattern matching is pretty nifty.
15:56:56 <glguy> ?quote C\+
15:56:57 <lambdabot> qwe1234 says: i can program in assembly as well as i can program in c++
15:57:19 <anybody> ?quote C\+
15:57:19 <lambdabot> ozone says: joelr1: our C++ guru at work is getting a bit sick of me saying "ah, so that's like <x> in haskell, but not quite as elegant..."
15:57:32 <anybody> haha
15:57:37 <noteventime> haha
15:57:53 <anybody> ?quote C\+
15:57:53 <lambdabot> RyanT5000 says: i wish i had been programming in haskell for 7 years rather than C++
15:58:10 <anybody> hm lame. only that many cites?
15:58:14 <anybody> or is it randomized?
15:58:22 <noteventime> I do!
15:58:39 <anybody> noteventime: ?
15:58:42 <rehges> ?quote c\+
15:58:43 <lambdabot> dons says: C++: creating blub programmers since 1985
15:58:46 <byorgey> anybody: it's randomized
15:58:46 <Cale> anybody: The quote plugin picks a random quote
15:58:51 <sorear> @quote
15:58:51 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
15:58:52 <noteventime> anybody: Wish I'd been learning haskell instead of C++ :-P
15:58:52 <sorear> @quote
15:58:53 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
15:58:54 <sorear> @quote
15:58:54 <lambdabot> mathewm says: I think this channel is the killer-feature of Haskell
15:59:07 <MisterN> @src (>>)
15:59:07 <lambdabot> m >> k      = m >>= \_ -> k
15:59:18 <sorear> @uptime
15:59:18 <lambdabot> uptime: 1d 11h 31m 16s, longest uptime: 1m 10d 23h 44m 29s
15:59:22 <notpalomer> I'm trying to write an evaluator for lambda calculus with let bindings. I know that let a = <foo> in bar is equivalent to bar[fix (\a -> <foo>)/a], but how do you do that with multiple mutually recursive let bindings?
15:59:52 <notpalomer> anyone know a tutorial on writing such an evaluator?
16:00:04 <Heffalump> tuple them up is probably simplest
16:00:25 <sorear> notpalomer: well, there's Simon's exhaustive treatise on functional compilers, if you've got time for a 500-page book
16:00:41 <notpalomer> Simon peyton jones
16:00:46 <notpalomer> ?
16:00:49 <notpalomer> does he cover evaluators?
16:00:52 <sorear> Simon L. Peyton-Jones
16:00:57 <anybody> hm i'm just wondering whether i should study math first and then come back and learn haskell, or just learn haskell. or first learn haskell and then study maths
16:00:57 <wli> notpalomer: There's tupling and then there's lambda abstracting out the functions it calls.
16:01:29 <sorear> You could do delta-reduction lazily using a context a la Schem
16:01:31 <noteventime> sorear: The guy with the OSCon tutorial?
16:01:42 <sorear> noteventime: yes :)
16:01:51 <byorgey> anybody: study them in parallel!
16:01:52 <sorear> noteventime: he's actually done much more than that
16:01:57 <notpalomer> tupling? how does that work?
16:01:58 <Cale> noteventime: yeah
16:02:15 <notpalomer> delta reduction?
16:02:16 <noteventime> be right back, kb trouble
16:02:19 <anybody> byorgey: problem is i'm already studying mechanical engineering. doing my masters now...
16:02:32 <anybody> byorgey: and i also wanted to do physics.
16:02:51 <anybody> byorgey: but by the time i'm done with all this i will be an old man :-(
16:03:08 <byorgey> anybody: no, actually, you'll never be done!
16:03:09 <noteventime> I know that he is the main developer of GHC
16:03:25 <anybody> byorgey: oh. even worse
16:03:51 <Heffalump> notpalomer: transform let a = ... ; b = ... into let (a, b) = ...
16:04:09 <byorgey> anybody: there's so much to learn and not enough time... it's either depressing or exciting depending on your point of view (mine fluctuates hourly)
16:04:09 <Heffalump> and since a = fst (a, b) etc, you now have a single recursive binding over the tuple (a, b)
16:04:13 <Heffalump> so you can just use fix
16:04:33 <sorear> noteventime: He was also a founding member of the Haskell Committee and a lead of the FP group at Glasgow University, I think he chaired ICFP several times, and he's written a small boatload of papers about funmctional compilation technology
16:04:55 <anybody> byorgey: yeah. i'm manically depressed too ;-)
16:05:02 <byorgey> hehe
16:05:07 <ari> sorear: A *small* boatload?
16:05:26 * Boney is a programmer, getting married to a psycologist.
16:05:27 <noteventime> sorear: That's rather impressive :-)
16:05:30 <sorear> ari: I was thinking about physical boats
16:05:38 <notpalomer> Heffalump, how would I use fix? (I don't have pattern matching in my evaluator)
16:05:47 <noteventime> Boney: Collaborate on AI :-P
16:05:58 <Heffalump> well, you'd need some way to deconstruct (and build) tuples
16:05:59 <Boney> noteventime: yeah!  i know!
16:06:30 <Heffalump> but if you treat them as first-class, that's all you need
16:06:34 <Boney> It's just great how either of us can mention somebody like Alan Turing and know who we're talking about.
16:06:40 <wli> noteventime: let { f_1 ... = ... ; f_2 ... = ... ; ... ; f_n ... = ... } in ... be mutually recursive. Translate it to let { g_1 f_1 ... f_n ... = ... ; g_2 f_1 ... f_n ... = ... ; g_n f_1 ... f_2 ... = ... } = ... and pass the various f_i to the g_j at all call-sites.
16:07:28 <Boney> between us we are very academic.  And always needing to buy more bookshelves.
16:07:33 <wli> noteventime: The g_j to each other rather, sorry.
16:08:14 <notpalomer> wli, whoa whoa, let's take the simpler example of
16:08:22 <noteventime> wli: I beg your pardon
16:08:23 <wli> noteventime: I think it only works untyped.
16:08:26 <byorgey> anybody: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something like learn $ zip math haskell.
16:08:34 <notpalomer> let a = <foo> ; b = <bar> in baz
16:08:44 <wli> noteventime: Sorry, meant for notpalomer.
16:08:53 <ricky_clarkson> byorgey: Haha, I like that phrasing.
16:09:27 <noteventime> -_- I'm tired from reading all day, going to sleep
16:09:29 <Boney> how do we add that statment by byorgey to lambdabot quotes?
16:09:42 <Boney> lambdabot: quote?
16:09:51 <glguy> ?help remember
16:09:51 <lambdabot> quote <nick>
16:09:51 <lambdabot> remember <nick> <quote>
16:09:51 <lambdabot> Quote somebody, a random person, or save a memorable quote
16:10:05 <Cale> @remember byorgey if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something like learn $ zip math haskell.
16:10:05 <lambdabot> Done.
16:10:12 <Boney> YAY
16:10:24 <glguy> ?quote Cale
16:10:24 <lambdabot> Cale says: [more monad clarity] monads as food gathering in post-industrial America
16:10:29 <Boney> @quote byorgy
16:10:29 <lambdabot> No quotes match. My pet ferret can type better than you!
16:10:33 <notpalomer> wli, how would it work for that simpler example?
16:10:49 <Boney> @quote math
16:10:49 <lambdabot> math says: 2^20 ~= 10^6
16:10:59 <glguy> @yow
16:10:59 <lambdabot> One FISHWICH coming up!!
16:11:00 <Boney> nm.
16:11:07 <wli> notpalomer: Abstract out a and b from the bodies of a and b and call the new functions c and d. At all callsites substitute  a = c c d and d = d c d
16:11:17 <wli> notpalomer: Untyped only, of course.
16:11:42 <notpalomer> abstract out a and b?
16:11:50 <notpalomer> you mean fix (a-> <foo>) ?
16:11:54 <mm_freak> @quote science
16:11:54 <lambdabot> S.Behrens says: or maybe she is the Queen of Sciences and he is the Mack Daddy.
16:12:22 <wli> notpalomer: say f xs = case xs of { [] -> Nothing ; (y:ys) = 1 + f ys }
16:12:48 <notpalomer> that doesn't even type!
16:13:04 <glguy> s/Nothing/0
16:13:05 <wli> notpalomer: Our g would be g f xs = case xs of { [] -> Nothing ; (y:ys) = 1 + f ys }
16:13:15 <wli> notpalomer: Sorry 0
16:13:24 <glguy> fix g!
16:13:27 <sjanssen> instance Num a => Num (Maybe a) -- there, types now
16:13:31 <wli> glguy: yep
16:13:48 <glguy> the techincal term for g is "broken"
16:13:54 <wli> g f xs = case xs of { [] -> 0 ; (y:ys) = 1 + f ys }
16:14:04 <notpalomer> gotcha
16:14:36 <glguy> wli: are you trying to tell me that we have have recursion without recursive let bindings?
16:14:40 <notpalomer> so g = \f xs -> case xs of { [] -> 0 ; (y:ys) = 1 +f ys}
16:14:44 <wli> notpalomer: Then you pass g to itself as its first argument in lieu of f.
16:14:54 <notpalomer> glguy, yeah, using fix
16:15:14 <notpalomer> wli, right! that's what I proposed earlier
16:15:17 <wli> glguy: This is one of those cases where dynamic typing allows recursion.
16:15:21 <glguy> right :)
16:15:27 <glguy> I forgot to add the ":)"
16:15:41 <glguy> I'm going for the whole infomercial approach
16:15:47 <glguy> it slices *and dices*?
16:15:52 <notpalomer> so in my example, let a = <foo> in baz translates to baz [fix (\a -> <foo>)/a]
16:15:53 <glguy> I bet its expensive
16:15:56 <glguy> *free you say?*
16:15:57 <wli> notpalomer: it works just fine for n functions. It basically curries the thing.
16:16:13 <notpalomer> forget about functions, let's deal with values
16:16:19 <glguy> wli: the issue isn't dynamic typing as much as recursive types, no?
16:16:41 <notpalomer> now, how would that work with let a = <foo>; b = <bar> in baz ?
16:16:48 <wli> notpalomer: n values, sorry; anyway the tupling trick uncurried is passing the n functions as arguments.
16:17:05 <wli> notpalomer: curried rather
16:18:27 <notpalomer> so you get let a = g_1 g_1 ; b = g_2 g_2 in baz
16:18:36 <wli> notpalomer: a' = \a -> \b -> <foo> , b' = \a -> \b -> <bar>
16:19:02 <notpalomer> ah, so you get a' a b
16:19:04 <notpalomer> and b' a b
16:19:05 <notpalomer> right?
16:19:10 <notpalomer> or, rather
16:19:14 <notpalomer> a' a' b'
16:19:15 <wli> notpalomer: then [a' a' b'/a] and [b' a' b'/b]
16:19:16 <notpalomer> b' a' b'
16:19:22 <notpalomer> sweet!
16:19:25 <wli> notpalomer: yes
16:19:29 <notpalomer> gotcha!
16:19:31 * notpalomer does a dance
16:19:47 <notpalomer> any other alternatives?
16:19:56 <wli> notpalomer: it's the same as the tupling, only curried and not well-typed in most typesystems.
16:20:34 <wli> notpalomer: The other alternative involves tuples
16:20:42 <notpalomer> how does that work?
16:21:01 <wli> notpalomer: Basically it reduces mutual recursion to the single recursion case.
16:21:58 <notpalomer> how?
16:22:01 <wli> notpalomer: \t@(a',b',...) -> ([fst t/a]<foo>, [snd t/b]<bar>, ...)
16:22:13 <wli> notpalomer: Then fix
16:22:55 <wli> notpalomer: You get a univariate fix so as long as that types the whole thing types.
16:23:12 <notpalomer> seems a tad harder than the other method
16:23:19 <notpalomer> you can do this in lambda calculus?
16:23:55 <notpalomer> oh, I guess you can
16:24:00 <notpalomer> getting back to the previous example
16:24:04 <notpalomer> let a = a +1 in a
16:24:06 <wli> notpalomer: Untyped for the first, and both typed and untyped for the second, where the second requires a fixpoint operator from out of the blue
16:24:30 <notpalomer> a' = \a -> a + 1
16:25:06 <notpalomer> a' a' = a' + 1
16:25:15 <notpalomer> where did I go wrong?
16:26:16 <wli> notpalomer: a' a' = a' (\b -> b + 1) = (\b -> b + 1) + 1 hmm.
16:27:00 <wli> notpalomer: \a -> a + 1 isn't it.
16:27:14 <wli> notpalomer: a' = \a -> a a + 1 is it.
16:28:13 <wli> notpalomer: It still doesn't typecheck but anyway.
16:29:00 <notpalomer> so for a = <foo>, you need a' = \a -> [a a/a]foo
16:30:38 <wli> I think so. I'm wondering if I got the translation wrong. It's been almost a decade since I studied any of this.
16:31:42 <notpalomer> how does scheme do it?
16:33:59 <notpalomer> woop, brb
16:35:18 <visof> i use drscheme and when i use increment and decrement i had error" reference to undefined identifier: -1+" what do i do?
16:35:41 <ddarius> visof: Wrong channel?
16:36:00 <visof> oh sorry
16:36:04 <sorear> visof: I suspect spacing issue
16:36:45 <chessguy> was drscheme named after drhaskell, vice versa, or neither?
16:36:51 <chessguy> @seen ndm
16:36:51 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 5h 43s ago, and .
16:37:06 <ddarius> Neither
16:37:12 <chessguy> ah
16:37:26 --- mode: ChanServ set +o glguy
16:37:34 * chessguy dives for cover
16:37:37 --- mode: glguy set -b %*!*@196.218.142.218
16:37:48 --- mode: glguy set +b %*!*@196.218.142.238
16:37:55 --- mode: glguy set -o glguy
16:38:00 <chessguy> whew
16:38:28 <sorear> glguy: what's wrong with visof?
16:38:37 <glguy> sorear: he ban got mismatched
16:38:40 <glguy> his*
16:38:57 <stick_figure> how does one implement Show for custom data types?
16:39:05 <sorear> stick_figure: Deriving, if possible
16:39:14 <glguy> sorear: he was good for page after page of what is programming for
16:39:32 <glguy> and seemingly nonsensical questions, I replaced Igloo's /ban
16:39:42 <sorear> btw, he's still here
16:39:44 <sjanssen> stick_figure: stick "deriving Show" at the end
16:39:50 <glguy> sorear: it is a +q
16:41:17 <stick_figure> sjanssen, ok, I was googling slowly :)
16:41:26 * notpalomer finds it cool that fix (\f -> x (f x)) ~ fix
16:41:36 <notpalomer> err
16:41:46 * notpalomer finds it cool that fix (\f x -> x (f x)) ~ fix
16:42:30 <sorear> glguy: +q?
16:42:45 <glguy> it prevents the user from speaking or /nick changing
16:42:48 <chessguy> notpalomer,  what is ~ in that context?
16:42:55 <glguy> it is the more humane +b
16:43:18 <notpalomer> chessguy, equivalent
16:43:32 <notpalomer> @type (\f ->(\x ->f (x x))  (\x -> f (x x)))
16:43:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:43:34 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:43:48 <notpalomer> Y is not definable in haskell :(
16:43:54 <glguy> you need recursive types
16:44:00 <chessguy> not typable, you mean
16:44:05 <notpalomer> but it's the same as
16:44:26 <notpalomer> @type let f x = x (f x) in f
16:44:28 <lambdabot> forall t. (t -> t) -> t
16:44:34 <notpalomer> they're equivalent functions
16:44:39 <notpalomer> chessguy, righto
16:44:57 <ddarius> class BiFunctorNP f where bimap :: (a -> b) -> (a' -> b') -> f b a' -> f a b'; instance BiFunctorNP (->) where bimap g h f = g >>> f >>> h; fix = fix (join bimap)
16:45:00 <notpalomer> you don't need recursive types!
16:46:30 <ddarius> Doh, that don't work.
16:46:31 <ray> y f = f (y f), isn't it?
16:46:35 <anybody> ?42
16:46:35 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
16:47:01 <notpalomer> ray, yup
16:47:05 <sorear> notpalomer: Y is not definable in the simply-typed lambda calculus, which is the restriction of Haskell to lambda, application, and variables.  Adding any of let or data types makes it defiitable
16:47:08 <sorear> @src fix
16:47:09 <lambdabot> fix f = let x = f x in x
16:47:30 <notpalomer> sorear, by Y I mean
16:47:32 <ddarius> fix is a nice end of the hom-functor though.
16:47:36 <notpalomer> (\f ->(\x ->f (x x))  (\x -> f (x x)))
16:48:29 <sorear> notpalomer: There exist typable terms extensionally equivalent to that one.
16:48:42 <notpalomer> yup
16:48:47 <notpalomer> anyways, I'm off
16:48:48 <notpalomer> cheers!
16:51:10 * ddarius starts to build the factor vm
16:51:13 <lament> how do i run an external command and catch its output?
16:51:32 <lament> runInteractiveCommand?
16:52:24 <mrd> yes
16:52:37 <lament> damn :)
16:58:32 <chessguy> ddarius, what kind of language is factor?
16:58:43 <glguy> dynamically typed stack based
16:58:51 <glguy> its quite amazing
16:59:00 <sorear> chessguy: Forth with perly types
16:59:18 <glguy> slava32 is even in channel
16:59:21 <glguy> ?seen slava32
16:59:21 <lambdabot> slava32 is in #haskell. I don't know when slava32 last spoke.
16:59:24 <chessguy> interesting
17:00:09 <ddarius> @seen slava
17:00:09 <lambdabot> I saw slava leaving #haskell 12m 30s ago, and .
17:00:24 <ddarius> factorcode.org
17:02:41 * ddarius thinks that bug in lambdabot has been there longer than most of the people here have programmed in Haskell.
17:03:08 <dolio> Which? "and ."?
17:03:19 <ray> longer than i have at least
17:03:41 <MisterN> also, there is some slava32 guy online.
17:03:43 <ray> i don't even know when i wrote my first lines of haskell
17:06:45 <chessguy> @users
17:06:45 <lambdabot> Maximum users seen in #haskell: 371, currently: 347 (93.5%), active: 13 (3.7%)
17:07:05 <ddarius> @uptime
17:07:06 <lambdabot> uptime: 1d 12h 39m 3s, longest uptime: 1m 10d 23h 44m 29s
17:10:45 <mm_freak> 308 021002 -!- Irssi: Peak for #haskell@fn: 382 (Tue Jul 31 21:29:18 2007)
17:10:58 <mm_freak> something's wrong with lambdabot
17:11:11 <ddarius> lambdabot loses state upon occasion
17:11:47 <xerox> mm_freak: how do you get that info from irssi?
17:12:52 <Mitar> hmm, nobody seems to answer to my post to the Haskell Cafe list ... :-(
17:13:18 <Binkley> Mitar: what was your post?
17:13:24 <mm_freak> xerox: chanpeak.pl
17:14:38 <Mitar> about Interval Arithmetics in Haskell
17:16:38 <chessguy> Mitar, there was a bit of discussion here about it
17:17:28 <dibblego> ?instances Functor
17:17:30 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:17:44 <Mitar> really?
17:17:48 <Mitar> are there any logs?
17:17:52 <chessguy> sure
17:17:56 <Mitar> link?
17:17:57 <chessguy> @topic-tell #haskell
17:17:57 <lambdabot> ["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://
17:17:57 <lambdabot> tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]
17:18:03 <chessguy> @where logs
17:18:03 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
17:18:54 <Mitar> thanks
17:19:06 <chessguy> Mitar, nobody seemed to know of an implementation in haskell, but it does seem to be the sort of thing that haskell would be good at
17:19:08 <Mitar> which day ... if you remember?
17:19:09 <ddarius> What's the name of the substructural logic with weakening but not contraction (the other way around is relevant logic)
17:19:31 <chessguy> Mitar, whatever day you sent the email
17:19:32 <Mitar> i am thinking about implementing it maybe for a bsc
17:19:40 <ddarius> Mitar: You may also want to look at affine arithmetic.
17:19:46 <chessguy> bsc?
17:19:58 <Mitar> diploma
17:20:18 <xerox> Mitar: italian?
17:20:21 <Mitar> bachelor of science work ..
17:20:22 <Mitar> slovenian
17:20:28 <Mitar> i have a final work to do
17:20:29 <xerox> ah :)
17:20:36 <Mitar> to get my degree
17:20:43 <chessguy> xerox, nobody likes italians anyway :)
17:21:01 <chessguy> gee, i hope there are none in the channel :)
17:21:02 <dibblego> Italians make great motorcycles; one of mine is Italian
17:21:08 <Mitar> cheesguy, true :-)
17:21:14 <xerox> :(
17:21:21 <ddarius> dibblego: Riding Italians is rude.
17:21:30 <dibblego> ddarius, indeed!
17:21:45 <Mitar> but you could reply to the post ... it is really not nice to the novice to the list ...
17:22:24 <chessguy> Mitar, i'm certainly not qualified to comment on such things
17:22:32 <Mitar> :-)
17:22:35 <Mitar> no problem ..
17:22:35 <chessguy> i did watch the video though, and it was interesting
17:22:36 <dibblego> data FiniteList a = FL [a] !Int -- is this a suitable type for keeping a memoed length?
17:22:43 <dmwit> ClockTime has a Show instance, but no Read instance! =(
17:23:13 <dmwit> And it's Show instance loses precision really really hard.
17:23:19 <sorear> dmwit: The GHC User's Guide says "Don't use deriving(Read), it makes the compiler slow."  I think that bug has had a huge chilling effect.
17:23:23 <dmwit> Is there an alternative to ClockTime?
17:23:53 <xerox> dibblego: yeah, alternatively you can keep it in the type, Oleg has got code for that, in many flavours.
17:23:54 <sorear> > TOD 0 12345678
17:23:55 <lambdabot>   Not in scope: data constructor `TOD'
17:23:55 <dmwit> sorear: That's not the problem.
17:24:07 <sorear> > System.Time.TOD 0 12345678
17:24:07 <lambdabot>   Not in scope: data constructor `System.Time.TOD'
17:24:08 <mm_freak> | a `seq` b `seq` False = undefined  -- does GHC optimize this away properly?
17:24:10 <dibblego> xerox, what do you mean by "keep it in the type"?
17:24:14 <sorear> mm_freak: Yes.
17:24:19 <dmwit> sorear: The problem is that the "Show" instance has output like the "date" utility on *nix.
17:24:21 <mm_freak> ok, thank you
17:24:21 <matthew-_> err, use Data.Time rather than System.Time ?
17:24:26 <sorear> dmwit: Ouch.
17:24:38 <dmwit> sorear: So the Show instance has at best second-level precision. =(
17:25:12 <dmwit> matthew-_: Hmmm, that's not on Hoogle.
17:25:23 <dmwit> Thanks for the tip. =)
17:25:36 <xerox> dibblego: I mean <http://okmij.org/ftp/Haskell/number-parameterized-types.html>
17:25:55 <dibblego> xerox, thanks
17:28:55 <matthew-_> dmwit: np - it has full pico second precision and is easy to format and parse
17:29:05 <matthew-_> System.Time is known to be broken
17:30:08 <xerox> ddarius - Maybe this has got what you're looking for: "On Logics without Contraction" <http://web.archive.org/web/20020812135147/http://www.phil.mq.edu.au/staff/grestall/files/onlogics.pdf>
17:30:09 <lambdabot> http://web.archive.org/web/20020812135147/http://www.phil.mq.edu.au/staff/grestall/files/onlogics.pdf>
17:32:09 <ddarius> "Australasia"
17:34:53 <sorear> ddarius: Maybe you're thinking of Contraction-free sequent calculi like LJT?  (Without contraction, inhabitation is easily decidable; djinn uses one of these, the proof of correctness is *far* more subtle than the algorithm itself, and requires cut elimination)
17:34:56 <ddarius> Affine Logic
17:35:18 <ddarius> Now I need to remember why I wanted to know that.
17:35:58 <ddarius> Ah, I remember.
17:39:20 <markluffel> does anyone have experience with the haskell objective-c bindings (HOC) ?
17:39:22 <matthew-_> which is preferred? x = if c then f y else f z
17:39:33 <matthew-_> or x = f (if c then y else z) ?
17:39:47 <ddarius> The latter is lazier.
17:39:47 <sorear> x | c = f y
17:39:55 <sorear>   | otherwise = f z
17:40:12 <matthew-_> interesting. ta
17:41:26 <sorear> Awww.
17:41:34 <dibblego> is it true that "forall f. f is a bijection <-> f is a surjection ^ f is an injection" ?
17:41:38 * sorear finally gets why @djinn can't do instantiation
17:42:19 <glguy> dibblego: isn't that the definition?
17:42:23 <sorear> dibblego: it is true if you replace ^ by /\
17:42:27 <byorgey> dibblego: in a mathematical sense, yes
17:42:33 <sorear> dibblego: (^ is XOR, iirc)
17:42:38 <dibblego> sorear, I meant /\ sorry
17:42:46 <dibblego> thanks
17:42:49 <sorear> oh I was thinking C
17:43:00 <dibblego> I wish my keyboard had those characters
17:43:07 <dibblego> they are much better than English :)
17:43:23 <dibblego> \conjunction is what I meant
17:43:36 <ddarius> dibblego: It is true.
17:43:42 <dibblego> ddarius, thanks
17:45:04 <sorear> âˆ§ muahaha!
17:45:08 <glguy> âˆ§
17:45:09 <glguy> bah
17:45:13 <glguy> âˆ¨
17:45:37 <glguy> âˆ€ f. f ...
17:45:42 * sorear could use a better terminal font
17:45:43 <matthew-_> yeah, they're all in unicode somewhere. a friend of mine has a very modal setup with xmodmap where he can access most of those with few keypresses
17:46:10 <dibblego> âˆ€ f. f is bijective â†” f is surjective âˆ§ f is injective
17:46:24 <dibblego> matthew-_, I just @go mathematical symbols and copy/paste :)
17:46:25 <glguy> â‡”
17:46:32 <sorear> http://members.cox.net/stefanor/1186533945.png <- my symbols render soo badly...
17:46:41 * glguy uses misc-fixed
17:46:49 <glguy> to get lots of pretty symbols
17:48:08 <glguy> Ord Î± â‡’ [Î±] â†’ [Î±]
17:48:12 <sorear> I use misc-fixed normally, but urxvt switches to some other font for fancy math symbols
17:48:22 <dibblego> is there a good reason to use â‡” instead of â†” or vice versa? I can never find one
17:48:31 <glguy> sorear: when did you start using X11?
17:48:34 <dibblego> a reason that is
17:48:43 <sorear> glguy: several years ago
17:48:58 <glguy> oh... I thought you always said you used the console
17:49:03 <glguy> I assumed that meant the linux console
17:49:34 <glguy> I thought that was pretty hardcore to shun all of X11... and here you are using xmonad
17:50:15 <SamB> glguy: he used to use it occasionally, as I understand it...
17:50:34 <sorear> glguy: I did use the console for a while :)  I had to *stop* using X11, and liked it.
17:50:45 <sorear> Then xmonad came around.
17:51:05 <xerox> Anybody can access jstor?
17:51:44 <glguy> xerox: looks like your ISP can subscribe
17:53:40 <glguy> xerox: were you askign if someoen here could get something for you?
17:53:43 <glguy> or if it was public
17:54:20 <xerox> The former :)
17:54:54 <TSC> What are you looking for?
18:00:22 <samreid> hi, does anybody know of any situations where the [tok] argument of (nextPos :: SourcePos -> tok -> [tok] -> SourcePos) passed as the second argument in (tokenPrim showTok nextPos testTok) is actually used?
18:00:52 <xerox> Yes. It is used in `tokens', where actually those list of tokens are matched.
18:01:49 <dibblego> wikipedia states, "If both X and Y are finite with the same number of elements, then f : X â†’ Y is surjective if and only if f is injective", however, the first diagram shows a function that is surjective and appears to contradict this statement http://en.wikipedia.org/wiki/Surjective_function
18:01:51 <xerox> (...that list... those tokens, sorry it's quite late here :))
18:02:02 <samreid> ah, you mean 'token', yes.  Okay!
18:02:05 <dibblego> X and Y are domain and codomain of a function f in that statement
18:02:17 <samreid> thanks
18:02:22 <xerox> you're welcome.
18:03:22 <dibblego> er wait, mistake
18:03:26 <ddarius> Yeah.
18:03:31 <dibblego> my mistake, right?
18:03:34 <ddarius> Yes.
18:03:37 <dibblego> thanks
18:03:47 <ddarius> |X| /= |Y| in the first picture.
18:03:50 <dibblego> yep
18:04:08 <dibblego> I ignored that part of the statement for some reason
18:04:13 <aj-123> whats a good channel for basic Haskell questions?
18:04:15 <kjdf> is there a library which implements erlang-like distributed communication?
18:04:19 <dibblego> aj-123, #haskell !
18:04:20 <TSC> aj-123: This is it!
18:04:30 <kjdf> or in fact any higher level communication library
18:04:32 <ddarius> #lisp!
18:04:34 <thepointer> if i'm writing a function type and i want multiple arguments/parameters do i just write functionName :: TypeOfArg1 -> TypeOfArg2 -> TypeOfArgN -> TypeReturned ?
18:05:00 <TSC> thepointer: That's right
18:05:03 <TSC> For example:
18:05:12 <TSC> @type map
18:05:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:05:25 <TSC> (ignore the "forall a b.")
18:06:15 <thepointer> ok thanks TSC
18:06:31 <TSC> You're welcome
18:06:35 <Josh> samreid is a cock sucker
18:06:48 <Josh> he just told me in pm
18:06:57 <Josh> he likes to choke on cock
18:07:04 <sorear> and we care, why?
18:07:10 <dibblego> /ignore Josh
18:07:13 <Josh> cuz thats gay
18:07:34 <sorear> he's thousands of miles away.  I still don't see why you need to tell us.
18:07:55 <Josh> just so you can be careful
18:08:03 <Josh> don't want him asking if he can have your #
18:08:13 <Josh> to suck you off or somethn
18:08:22 <Josh> samreid, why are you gay?
18:08:31 --- mode: ChanServ set +o xerox
18:09:19 <samreid> what the hell
18:09:30 <ddarius> Are you waiting for something xerox?
18:09:30 <Josh> hey sam
18:09:30 <Josh> queer
18:09:35 <Josh> quit trying to suck others off
18:09:39 --- mode: xerox set +b *!*=Administ@*.dsl.hstntx.swbell.net
18:09:39 --- kick: Josh was kicked by xerox (xerox)
18:09:40 --- mode: ChanServ set +o Cale
18:09:46 <Cale> ah :)
18:09:49 <kjdf> another question - does it make sense to cabalize a program which depends on a c blob and is platform specific?
18:09:55 --- mode: xerox set -o xerox
18:10:00 <samreid> my gosh.  sorry.
18:10:17 <ddarius> samreid: I'm not all that sure how that is your fault.
18:10:33 <samreid> could have avoided it
18:11:02 <Josh> hey wtf xerox
18:11:17 <aj-123> so I have a module Test.hs that defines a function signum, but how do I specify to use the signum fn fron Test instead of Prelude in the interactive shell?
18:11:20 <Josh> gay ass bitch
18:11:23 <Josh> haskell is gay
18:11:25 <ddarius> Cale you still have op and know what to do, no?
18:11:28 <Josh> dumbasses
18:11:31 <xerox> Sigh.
18:11:33 <Josh> yall all suck cock
18:11:36 <thepointer> hi josh
18:11:40 <gg> fags
18:11:41 <joed> +b please
18:11:41 * Binkley has never known Haskell to have sex with other programming languages of the same sex
18:11:47 <jjj> assholes
18:11:52 <jjj> pussies
18:11:58 --- mode: Cale set +b *!*@222.231.63.18
18:11:59 --- kick: jjj was kicked by Cale (Cale)
18:12:22 <Cale> jeez, just when you think you can go back to what you were doing before... :)
18:12:25 <TSC> aj-123: Try Test.signum instead of plain signum
18:12:27 <joed> thank you.
18:12:29 <kjdf> Cale++
18:12:30 <sorear> Does he have any idea how dumb he looks right now?
18:12:34 <aj-123> thanks
18:12:35 <Binkley> sorear: doubtful
18:12:56 <Cale> If he keeps doing it, get an IRCop to give him a k-line.
18:13:12 <mm_freak> why did that take so long?
18:13:14 <dibblego> he's connecting on different IP addresses
18:13:48 <Cale> mm_freak: Because after he was kicked, I stopped paying attention :)
18:13:59 <mm_freak> hehe k
18:15:12 <dibblego> is the Foldable type-class a catamorphism?
18:16:52 <ddarius> @src Foldable
18:16:52 <lambdabot> Source not found. Are you on drugs?
18:16:55 <mm_freak> say i'm writing a C library for use from haskell, and i link GMP to the library staticallyâ€¦  does that work?
18:17:07 <ddarius> How did you know lambdabot? How did you know?
18:17:16 <matthew-_> dibblego: yes
18:17:25 <matthew-_> fold is a catamorphism
18:17:44 <dibblego> matthew-_, is that the very definition of a catamorphism though?
18:17:59 <matthew-_> err, I doubt it. But my category theory is non-existent
18:18:09 <dibblego> is seems that a catamorphism is just a fold, where the [] is a type parameter
18:18:18 <dibblego> so it is more general
18:18:41 <matthew-_> I would guess that catamorphisms are more general than folds. But that is a guess
18:20:02 <Cale> In general, I think of catamorphisms as being functions which replace the constructors of an algebraic type with other functions.
18:20:30 <dibblego> Cale, in a fold?
18:20:30 <SamB> Cale: isn't that just what they ARE?
18:20:47 <SamB> (the both of them)
18:21:37 <Cale> Well, I haven't seen a properly general definition, or gone to the trouble of checking that it's equivalent to that. However, this definition would mean that foldl is not a catamorphism.
18:21:59 <opening> if a data type T refers to another data type S, does the catamorphism for T take the constructors for S as arguments too?
18:22:16 <SamB> Cale: does that conflict with something?
18:22:16 <dibblego> no, Foldable, which might be across any algebraic type, not just lists
18:22:23 <SamB> oh.
18:22:25 <SamB> I see.
18:22:27 <ddarius> The words 'fold' and 'catamorphism' are used interchangeably.
18:22:42 <SamB> a fold can be more than that...
18:22:44 <aj-123> stupid question #2, in ghci, how do I show the definition of function?
18:22:50 <dibblego> "This way of looking at things provides a simple route to designing fold-like functions on other algebraic data structures, like various sorts of trees. One writes a function which recursively replaces the constructors of the datatype with provided functions, and any constant values of the type with provided values. Such a function is generally referred to as a catamorphism."
18:22:54 <dibblego> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
18:22:55 <Binkley> aj-123: you can't
18:22:58 <Cale> aj-123: :info f
18:23:04 <Binkley> never mind, ignore me
18:23:26 <dibblego> such a function (to me), is the Foldable type-class
18:23:44 <SamB> doesn't that just tell you where it is?
18:23:54 <Cale> er, yeah, that doesn't show the code.
18:24:10 <dibblego> open the GHC docs and click the source link
18:24:11 <Binkley> you can use lambdabot to show it, though:
18:24:14 <Binkley> @src map
18:24:14 <lambdabot> map _ []     = []
18:24:14 <lambdabot> map f (x:xs) = f x : map f xs
18:24:24 <dibblego> lambdabot's @src is screwy
18:24:27 <xerox> Together with Emacs and haskell-mode it shows the code, M-.
18:24:38 <Cale> @src sequence
18:24:38 <lambdabot> sequence ms = foldr k (return []) ms
18:24:38 <lambdabot>     where
18:24:38 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:24:52 <Cale> Some of lambdabot's source for things is not so fun to read though
18:25:02 <dibblego> ?info Foldable
18:25:02 <aj-123> ok, simple things I'm trying:
18:25:02 <lambdabot> Foldable
18:25:08 <aj-123> let f 1 = 1
18:25:13 <ddarius> Foldable is not the most natural way to generalize folds.
18:25:20 <aj-123> let f n = n * f(n-1)
18:25:28 <dibblego> ddarius, what do you mean?
18:25:29 <aj-123> only those two statements
18:25:45 <aj-123> is there any way to have it print out those two statements?
18:25:54 <aj-123> that define f that is?
18:25:57 <sorear> Cale: I think in some sense a catamorphism is the categorical morphism on least fixpoints of functors induced by a natural transformation on the underlying functors.
18:26:03 <Cale> aj-123: If you do that on the ghci prompt, the second f will shadow the first.
18:26:14 <sorear> Or something like that, anyway.
18:26:42 <aj-123> Cale: sure, I get it, but say I forgot what I typed early, is there a way for ghci to show me what it has for a func def?
18:26:53 <dmwit> Is there a nice way to hash passwords?
18:27:07 <dmwit> Hashtable.hashString doesn't really look like what I want, I think.
18:27:08 <Cale> aj-123: I don't think so. The best thing to do is to always put all your definitions into a file
18:27:27 <dons> btw, http://programming.reddit.com/info/2d7ra/details
18:27:27 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:27:28 <lambdabot> Title: First lucid explanation of what Haskell&#39;s monads really are? (reddit.com)
18:27:28 <ddarius> PhD or Post-Doc Haskell programmer in this http://www.willamette.edu/~fruehr/haskell/evolution.html does show a nice way to make a generic fold given a functor
18:27:30 <sorear> dmwit: fork md5sum, and don't forget to salt
18:27:30 <lambdabot> Title: The Evolution of a Haskell Programmer
18:27:51 <aj-123> Cale: ok, thanks.  just trying to figure how things happen
18:27:52 <ddarius> A catamorphism is the initial algebra of a functor.
18:28:06 <ddarius> Or rather the unique arrow from that to any other algebra.
18:28:16 <dons> i think we don't need more monad tutorials. we need better CS teaching :)
18:28:18 <dmwit> sorear: Mmmm, I'm going to have to look up "salt".  But I don't expect this to be a high-volume or high-privacy site.
18:29:25 <dmwit> Also, is there a way to not do it in IO?  It seems like something that should be deterministic.
18:29:32 <lament> yes.
18:29:43 <sorear> dmwit: Salting is pretty crucial.  You can crack N unsalted passwords for the price of 1, for almost all N
18:30:08 <Cale> I really wish reddit's listing was at least a little more deterministic than it was. It seems that I get a different subset of the new articles every time I refresh the page.
18:30:13 <sorear> dmwit: unsafePerformIO.  or the crypto package.
18:30:55 <dmwit> okay...
18:31:03 <kjdf> what is a security lattice?
18:32:03 <Cale> kjdf: http://en.wikipedia.org/wiki/Lattice_(order) -- it's a lattice of security permissions.
18:33:02 <aj-123> Cale: ok, maybe I don't understand shadow- does it mean replace?
18:33:08 <Cale> aj-123: yes.
18:33:13 <Binkley> time for the banhammer again
18:33:16 <Cale> aj-123: (essentially)
18:33:22 --- mode: Cale set +b *!*@218.22.112.166
18:33:22 --- kick: Josh was kicked by Cale (Cale)
18:33:27 <aj-123> :) ok, guess I didn't understand, lol
18:33:56 <Cale> aj-123: Well, other things might be in scope which use the old version still, but the old version will be otherwise inaccessible
18:34:03 <Cale> It's as if you've written:
18:34:12 <Cale> let x = 5
18:34:12 <Cale> let x = 6
18:34:29 <Cale> the second definition will make the first invisible.
18:34:48 <aj-123> sure, for example
18:34:50 <aj-123> let x = 5
18:34:54 <aj-123> let y = x
18:34:59 <aj-123> let x = 6
18:35:07 <Cale> Yeah, then y = 5 still.
18:35:10 <aj-123> yep
18:35:25 <matthew-_> > let x = 5; y = x; x = 6 in (x, y)
18:35:26 <lambdabot>      Conflicting definitions for `x'
18:35:26 <lambdabot>     In the binding group for: x, y, x
18:35:32 <matthew-_> gah
18:35:42 <Cale> hehe :)
18:35:58 <aj-123> which is why my f function above didn't work like I thought it should
18:35:58 <dmwit> sorear: Okay, so it's fine to store the salt in cleartext next to the (hashed) password?
18:35:59 <ddarius> > let x = 5; y = x in let x = 6 in (x,y)
18:36:00 <lambdabot>  (6,5)
18:36:12 <Cale> aj-123: Yeah, you have to put both bindings in the same let
18:36:17 <sorear> dmwit: yes, that's how it's normally done
18:36:24 <dmwit> fine
18:36:27 <dmwit> That's not so bad.
18:37:25 <aj-123> I see, so "let f 1 = 1; f n = n * f (n-1)" is what I wanted
18:38:06 <Cale> aj-123: yeah :)
18:38:38 <aj-123> f n = n * f (n-1)
18:38:48 <aj-123> just doens't work for some reason ;)
18:39:37 <Cale> aj-123: Of course, if you're writing this into a file, you don't need the lets.
18:40:00 <dons> Cale, so you keeping an eye on this abuse guy who's popping up?
18:40:25 <Cale> dons: Sort of, but I'm also playing a game, so I might miss him.
18:41:56 <samreid> I think he's done
18:45:18 <|Steve|> Where is tails defined?
18:45:36 <dolio> @index tails
18:45:37 <lambdabot> Data.List
18:45:44 <|Steve|> Ah @index. Thanks.
18:47:32 <fax> hello
18:48:00 <fax> where is there documentation for haskells (or a particular implementations) C interface?
18:48:07 <ddarius> @where ffi
18:48:07 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:48:11 <fax> thank you!
18:48:46 <fax> omg
18:49:03 <fax> it has c c++ .net java and window pascall calling conventions :D
18:49:13 <fax> thats insane
18:49:31 <proqesi`> is there a way to build or get ghc for OS X?
18:49:31 <Cale> fax: Well, it has whatever calling conventions the implementation supports.
18:49:56 <dolio> Sweet. I didn't realize we could take advantage of the ubiquitous Pascal libraries.
18:50:09 <joed> proqesi`: haskell.org
18:51:36 <Cale> dolio: I think windows libraries use pascal's calling convention.
18:51:47 <mm_freak> which calling convention does haskell use internally?  is it even specified?
18:51:55 <dolio> Ah.
18:51:59 <ddarius> mm_freak: Why would it be specified?
18:52:14 <proqesi`> do I need to take the .hc files and use them to bootstrap on OS X?
18:52:14 <SamB> mm_freak: the fact that you just used the word "internally" should be a clue
18:52:22 <ddarius> Sweet, factor uses quotations instead of control words.
18:52:41 <SamB> Cale: it's not really pascal's calling convention
18:53:00 <mm_freak> uhmâ€¦  maybe "when it gets compiled" would be a better term
18:53:11 <mm_freak> ddarius: just thought, maybe it is
18:53:20 <joed> proqesi`: download the binary and readline and gmp
18:53:30 <mm_freak> however, which calling convention does GHC use?  pascal, i presume?
18:53:34 <matthew-_> or use macports
18:53:39 <fax> hm ...
18:54:00 <fax> how do I call for example div_t div(int num, int denom); ?
18:54:00 <sorear> mm_freak: Something completely different.
18:54:16 <mm_freak> sorear: any papers?
18:54:21 <sorear> fax: You don't.  The FFI doesn't support structure returns :(
18:54:21 <fax> div_t is a struct with { int quot; int rem; }
18:54:27 <fax> aw man :[
18:54:28 <SamB> mm_freak: it doesn't even use ESP on i386...
18:54:32 <fax> thats a real shame
18:54:32 <thepointer> how would i convert a string to an integer
18:54:37 <sorear> thepointer: read
18:54:41 <thepointer> ok
18:54:42 <sorear> > read "123" :: Integer
18:54:44 <lambdabot>  123
18:54:50 <thepointer> ah cool
18:54:50 <SamB> mm_freak: GHC makes up the convention as it goes along anyway
18:54:56 <sorear> mm_freak: You could read the GHC Wiki
18:55:09 <SamB> mm_freak: (or might as well for all the good it does you)
18:55:35 <sorear> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
18:55:38 <lambdabot> Title: Commentary/Rts/HaskellExecution - GHC - Trac, http://tinyurl.com/2xet5k
18:55:46 <mm_freak> thanksâ€¦  sounds pretty interesting
18:56:18 <fax> is there any chance of that being added to haskell?
18:56:18 <thepointer> can read be used to convert from integer to string?
18:56:23 <fax> or to the FFI
18:56:35 <|Steve|> Can I do something like (\[] -> []; \(x:xs) -> ...) to pass to something like concatMap?
18:56:43 <hpaste>  jleedev pasted "rot13 filter" at http://hpaste.org/2120
18:57:10 <SamB> what was that ffi tool that actually works?
18:57:13 <SamB> c2hs?
18:57:18 <Binkley> |Steve|: you need to write it like (\ l -> case l of { [] -> []; (x:xs) -> ...})
18:57:41 <|Steve|> Binkley: Okay. I was hoping to avoid that.
18:58:04 <SamB> |Steve|: or you could just give it a name somewhere
18:58:41 <|Steve|> Right.
19:00:13 <dolio> Or you could go implement lambda-match (if that's the right one) in GHC. :)
19:00:44 <|Steve|> Is there a better way of doing this: concatMap (\l -> case l of {[] -> []; (x:xs) -> map ((,) x) xs}) . tails ?
19:01:05 <|Steve|> > concatMap (\l -> case l of {[] -> []; (x:xs) -> map ((,) x) xs}) . tails $ [1..5]
19:01:07 <Binkley> @pl concatMap (\l -> case l of {[] -> []; (x:xs) -> map ((,) x) xs}) . tails
19:01:07 <lambdabot> (line 1, column 28):
19:01:07 <lambdabot> unexpected "{"
19:01:07 <lambdabot> expecting variable, "(", operator or ")"
19:01:08 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
19:02:04 <dolio> It might look nicer as a comprehension.
19:02:26 <|Steve|> I couldn't think of how to do it as a list comprehension.
19:02:28 <dolio> > [ (a, b) | (a:xs) <- tails [1..5], b <- xs ]
19:02:30 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
19:02:39 <fax> > tails [1..5]
19:02:40 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
19:02:40 <|Steve|> Nice, thanks.
19:02:58 <DukeDave> Is lhs2TeX known to not escape $s ?
19:03:19 <fax> > [ (a, xs) | (a:xs) <- tails [1..5]]
19:03:20 <lambdabot>  [(1,[2,3,4,5]),(2,[3,4,5]),(3,[4,5]),(4,[5]),(5,[])]
19:03:35 <fax> cool
19:03:38 <DukeDave> It seems like the sort of thing it should do but my they surviving through to my .tex & breaking latex
19:08:26 <dmwit> ?pl \f -> g (f x) (f y)
19:08:26 <lambdabot> liftM2 g ($ x) ($ y)
19:09:02 <fax> :t $
19:09:04 <lambdabot> parse error on input `$'
19:09:07 <ddarius> :t ($)
19:09:09 <fax> :t ($)
19:09:09 <lambdabot> forall a b. (a -> b) -> a -> b
19:09:11 <lambdabot> forall a b. (a -> b) -> a -> b
19:09:18 <TSC> f $ x == f x
19:09:21 <fax> what?
19:09:21 <ddarius> :t id :: (a -> b) -> a -> b
19:09:23 <lambdabot> (a -> b) -> a -> b :: forall a b. (a -> b) -> a -> b
19:09:27 <ddarius> @src ($)
19:09:27 <lambdabot> f $ x = f x
19:09:41 <fax> :t ($ x)
19:09:42 <lambdabot> Not in scope: `x'
19:09:52 <fax> :t ($ (x :: Int))
19:09:52 <ddarius> :t ($ 9)
19:09:55 <lambdabot> Not in scope: `x'
19:09:55 <lambdabot> forall a b. (Num a) => (a -> b) -> b
19:10:05 <chessguy> @type ($ ?x)
19:10:07 <lambdabot> forall a b. (?x::a) => (a -> b) -> b
19:10:18 <fax> ooo
19:10:19 <fax> cool :D
19:10:23 <TSC> > ($ 9) (\x -> 2*x)
19:10:24 <lambdabot>  18
19:10:32 <fax> :o
19:10:47 <fax> > ($ (\x -> x x)) (\x -> x x)
19:10:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
19:10:48 <lambdabot>     Probab...
19:10:51 <TSC> So ($ 9) is a function that takes a function and applies it to 9
19:11:20 <fax> Can ($ (\x -> x x)) (\x -> x x) be valid?
19:11:20 <timthelion> I'm trying to use http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
19:11:22 <lambdabot> Title: Haskell mode for Vim
19:11:52 <timthelion> and Iget an error, can't find location of html documentation (set g:haddock_docdir),
19:12:27 <|Steve|> fax: You're trying to pass the lambda function (\x -> x x) to the function (\x -> x x). What would the type of x be?
19:12:28 <timthelion> so I set it like: let g:haddock_docdir = "path"... and it said pattern not found: docdir = g
19:12:38 <|Steve|> :t \x -> x x
19:12:39 <timthelion> can anyone help me?
19:12:40 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
19:12:40 <lambdabot>     Probable cause: `x' is applied to too many arguments
19:13:04 <fax> |Steve|: I see, it is infinite
19:13:14 <fax> its a recursive type with no possibility to terminate
19:13:23 <fax> isn't it?
19:14:45 <|Steve|> fax: And haskell doesn't like that.
19:14:52 <ddarius> fax: No, the type system is specifically designed to disallow such things.
19:15:33 <|Steve|> I think you can do such things in scheme: ((lambda (x) (x x)) (lambda (x) (x x))) is probably valid.
19:15:46 <Binkley> sure. scheme is untyped
19:15:49 <ddarius> |Steve|: That's because scheme is untyped.
19:15:52 <chessguy> sorry timthelion, i prefer emacs
19:15:52 <|Steve|> But it infinite loops.
19:16:11 <|Steve|> But that's obvious because scheme is applicative order evaluation.
19:16:18 <fax> > ($ \x->x+1 ) \x->x 3
19:16:18 <lambdabot>  Parse error
19:16:29 <fax> > ($ (\x->x+1)) (\x->x 3)
19:16:31 <lambdabot>  4
19:16:34 <fax> :D
19:17:08 <ddarius> ((lambda (x) (x x)) id) doesn't loop forever
19:17:17 <ddarius> :t (\x -> x x) id
19:17:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
19:17:19 <lambdabot>     Probable cause: `x' is applied to too many arguments
19:17:35 <fax> > ($ (\x->x+1)) (\x->1/x)
19:17:36 <lambdabot>   add an instance declaration for (Fractional (a -> a))
19:17:36 <lambdabot>     In the expression...
19:17:52 <ddarius> :t (\(x :: forall a. a -> a) -> x x) id
19:17:54 <lambdabot> forall a. a -> a
19:18:01 <chessguy>  > ($ (\x->x+1)) (\x->x)
19:18:07 <chessguy> > ($ (\x->x+1)) (\x->x)
19:18:09 <lambdabot>  <Integer -> Integer>
19:18:39 <fax> > ($ (\x :: Fractional ->x+1)) (\x->1/x)
19:18:40 <lambdabot>  Parse error
19:18:41 <chessguy> > (($ (\x->x+1)) (\x->x)) 4
19:18:43 <lambdabot>  5
19:19:02 <chessguy> so much cooler-looking than (+1) :)
19:19:10 <fax> haha
19:19:14 <chessguy> @pl (($ (\x->x+1)) (\x->x))
19:19:14 <lambdabot> (1 +)
19:19:54 <fax> wow
19:20:00 <fax> where is pl source code?
19:21:55 <Binkley> fax: http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Pl/
19:21:56 <lambdabot> Title: Index of /~dons/lambdabot/Plugin/Pl
19:22:06 <thepointer> http://hpaste.org/2121 <-- anyone able to tell me what 'Prelude.read: no parse' means?
19:22:09 <fax> > (iterate ((1/) . (1+)) 1) !! 50
19:22:10 <lambdabot>  0.6180339887498949
19:22:26 <fax> oh cool thanks Binkley
19:23:00 <Binkley> thepointer: it means you invoked read on a string that doesn't correspond to any Integer
19:23:02 <TSC> thepointer: In general, it means that read couldn't figure out how to convert the string into the type you wanted
19:23:07 <Binkley> (in this case)
19:23:25 <ivanm> I'm trying to find a good project topic I can use to do with concurrent haskell... any ideas?  physics-based preferably
19:23:30 <thepointer> hrm ok, thanks
19:24:40 <chessguy> > read ""
19:24:42 <lambdabot>  Exception: Prelude.read: no parse
19:24:47 <chessguy> > read " "
19:24:48 <TSC> thepointer: The problem is your strings have embedded quotes
19:24:48 <lambdabot>  Exception: Prelude.read: no parse
19:25:00 <TSC> Because of "show o"
19:25:06 <thepointer> ohhh
19:25:07 <TSC> I think you want show x ++ o
19:25:27 <TSC> To figure that out, I added the line
19:25:30 <TSC> reduce o i x | trace (show (o,i,x)) False = undefined
19:25:44 <SamB> hmm. it's funny that the Haskell report refers to the Common Lisp standard in a normative capacity
19:25:45 <TSC> above the definition of reduce, and added "import Debug.Trace"
19:25:50 <TSC> trace is pretty handy
19:25:57 <thepointer> hmm ok cool
19:26:01 <chessguy> nicely done, TSC
19:26:03 <thepointer> i was looking for something like that
19:26:31 <SamB> (see 6.4.5  Trigonometric Functions)
19:26:59 <chessguy> i guess trace relies on unsafePerformIO or some other such evil voodoo?
19:27:04 <TSC> I think so
19:27:06 <Binkley> @src Debug.trace
19:27:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:27:07 <sorear> ivanm: Write a SMP-parallel PDE solver with a real-time graphical display.
19:27:11 <Binkley> @src Debug.Trace.trace
19:27:11 <lambdabot> Source not found. Do you think like you type?
19:27:13 <sorear> @src trace
19:27:13 <Binkley> @src trace
19:27:13 <lambdabot> trace string expr = unsafePerformIO $ do
19:27:13 <lambdabot>     hPutStrLn stderr string
19:27:13 <lambdabot>     return expr
19:27:14 <lambdabot> trace string expr = unsafePerformIO $ do
19:27:14 <lambdabot>     hPutStrLn stderr string
19:27:15 <lambdabot>     return expr
19:27:17 <Binkley> yes
19:27:35 <SamB> chessguy: yes. but it's perfectly safe as long as you don't care if it trashes stderr
19:27:53 <Binkley> or prints out results in a weird order
19:28:01 <TSC> And you have to take care to actually evaluate the call (:
19:28:04 <sorear> that's not unsafety :)
19:28:07 <thepointer> that's very useful, thanks a bunch TSC
19:28:16 <TSC> thepointer: You're welcome
19:28:28 <sorear> unless you think truth is dangerous
19:28:36 <Binkley> truth is very dangerous!
19:28:40 <TSC> And danger truth
19:30:06 <sorear> unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
19:30:34 <sjanssen> @remember sorear unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
19:30:34 <lambdabot> Done.
19:30:38 <ddarius> CL got it from APL
19:31:23 <SamB> also if you don't follow the rules, you must suffer the consequences of the compiler assuming that you did follow them
19:31:25 <|Steve|> Does Haskell have any libraries for working with matrices?
19:31:39 <SamB> ddarius: so the report says
19:31:54 <|Steve|> In particular determinants of matrices.
19:33:02 <ivanm> sorear: that sounds like a bit too much work :p
19:33:20 <ivanm> I'd actually want some kind of system, etc to solve... not to write a generalistic tool
19:33:22 <chessguy> |Steve|, i think i saw something like that recently
19:33:27 <chessguy> |Steve|, let me look
19:33:34 <ivanm> |Steve|: there's HSL, IIRC (haskell scientific libraries)
19:33:43 <ivanm> or you might be able to use FFI to hook into LAPACK, etc
19:34:24 <chessguy> |Steve|, ah, this is what i was thinking of: http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Linear_algebra
19:34:27 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/2rt3uv
19:35:39 <|Steve|> Thanks.
19:35:40 <SamB> hmm, well I got my arbitrarily inefficient arithmatic working except for `quotRem`
19:36:37 <ivanm> SamB: arbitrarily inefficient? you wrote code that every now and then freezes up on you whilst it goes to grab a coffee? :p
19:37:00 <SamB> ivanm: a joking name for my inefficient arbitrary-precision arithmatic code...
19:37:07 <MarcWeber> How to register gtk2hs with ghc-6.6.1.2xxx (current) on windows using the installler?
19:37:16 <fax> arbitrary-precision not infinite ?
19:37:33 <SamB> I'm basically reimplementing Integer only slower and using about... oh...
19:37:58 <ivanm> SamB: ahh... that's what they all say! ;-)
19:38:04 <fax> Can't you leave this sort of thing to God SamB?
19:38:11 <ivanm> heh
19:38:29 <SamB> 96 times as much RAM
19:38:45 <chessguy> heh. the @pl code has lots of interesting comments in it :)
19:38:56 <ivanm> SamB: is that all? that's nothing!
19:38:57 <chessguy> "  -- What were they smoking when they decided >> should be infixl"
19:39:03 <Binkley> haha
19:39:11 <Binkley> @quote ghc
19:39:11 <lambdabot> ghc says: Type signature given for an expression
19:39:18 <ivanm> SamB: I'm sure if you really wanted to, you could get it to use 1000 times as much RAM!
19:39:45 <SamB> ivanm: yes well this was without trying
21:50:16 --- topic: '["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]'
21:50:16 --- topic: set by dons on [Wed Aug 01 17:42:19 2007]
21:50:16 --- names: list (clog blackdog_ Jaak Tac-Tics rubyruy jacquesmerde DaveCGI12345 mjl69 levitation[A] bos ikegami-- julian_ pgavin erg0t msouth mrsolo z` glguy araujo isaacd MarcWeber cmarcelo dxl geezusfreeek noclouds sjanssen GeoBesh seafoodX johnnowak kfish fax kjdf tizoc_ pupeno_ Eelis Binkley opqdonut_ jfredett Giraph uebayasi binary42 stick_figure ddarius boyscared Lemmih perspectival mm_freak augustss alexj dolio bitwize cognominal_ malsyned sorear)
21:50:16 --- names: list (Pupeno sioraiocht opening ozo rey_ slipstream Blwood yahooooo timthelion chr1s ski dblog Shimei dylan jwp daniel_larsson conal pjd profmakx Baughn kpreid AStorm Mentr3d thecrypto Averell tonfa sergiosdj arjanb arcatan progexp gmh33 sek_ thepointer maskd the_dormant acura ricky_clarkson beelsebob ixl shawn gogonkt_ liyang2 Adamant encryptio dakeyras dibblego quasisane Cale JohnMeacham laz0r joed shapr notpalomer shoffsta samreid kscaldef)
21:50:16 --- names: list (nnunley_ Nafai nominolo_ mlh psykotic rehges kolmodin nornagon Igloo Metabol Lycurgus zmike Nanar tessier_ Philippa_ toxic JBGood25 dcoutts__ arjanoosting edwinb elliottt thedward fuxxx f00li5h Aleksi ramkrsna purplepenguins Hirvinen dino- benny Kahdloc Nucleo_2 mr_ank dfranke benomatic _frederik_ GNU\caust1c integral xsdg ski_ Excedrin kalven Altair^ Vulpyne Liskni_si bens ray triplah_ lambdabot taruti Dunearhp genneth Lunar^ Japsu scook0)
21:50:16 --- names: list (JaffaCake noj jewel osfameron Syzygy- scaner newsham gattocarlo gvdm_other agoode jcreigh jgrimes olathe fnordus Muad_Dib ohub Khisanth Arnia wilx Tigge zvrba matthew-_ xinming falconair stevan dfeuer joe_k davidL Plareplane Eidolos xerox Laney shachaf nattfodd vsmatck TSC Xgc Saizan puusorsa zbrown kpk saccade Poeir Botje zamez Choko_ smkl opqdonut Thas dropdrive petekaz kilimanjaro orbitz SamB agemo pejo jql arguile_ SamB_XP Vq^ earthy)
21:50:16 --- names: list (mornfall cmeme scs gds jbalint thedatabase Alleria norpan jyasskin kosmikus sabakas1 deemon aking_ Wallbraker vincenz cameron dons lament klugez audreyt thorkilnaur eno reffie flux Maddas Shurique xian base_16 slava32 hpaste aleator eivuokko Daveman balodja atsampson seafood matthew_- jle kenn Mitar nothingmuch sphynx ulfdoz wolverian felipe oklopol kaol pragma_ magagr sieni qwr ibid Spark tuukkah Boney Shoragan Codex_ bdash hhg gaal)
21:50:16 --- names: list (dmwit lucca mux astrolabe |Steve| MikeJS koala_man Twigathy SimonRC bockmabe1 senikk phoniq qz mathrick quicksilver scw Lunchy savanni cods tessier caust1c moconnor ksandstr Korollary Heffalump yango cjay nopcode Lamperi mrd dgriffi3 wli allbery_b hellige lispy largos_ DRMacIver @ChanServ dcoutts_)
21:50:17 <DaveCGI12345> Cale okay i just finished reading it
21:50:32 <DaveCGI12345> Cale that seems to explain how to "use" IO, but I'm still fuzzy about *why* it works like that
21:51:04 <Cale> DaveCGI12345: Well, how would you have it work? It could work in lots of other ways, but a combinator library seems nicely functional.
21:51:12 <DaveCGI12345> no it works great for usage
21:51:29 <DaveCGI12345> my question is what do you add to the traditional functional model to make IO work?
21:51:54 <dons> the traditional model is to allow side effects without constraint
21:52:00 <DaveCGI12345> sorry
21:52:11 <DaveCGI12345> lets say i have pure functions with lazy evaluation. what would i add to that to allow IO?
21:52:13 <Cale> Well, you add some representation of IO values, and a program which sits alongside your functional evaluator and interprets the IO values as actual actions and performs them.
21:52:27 <DaveCGI12345> lazy evaluation for lambda calculus for example
21:52:37 <Tac-Tics> Traditional FP means the input is the program itself and the output is the final evaluation after you run it
21:52:58 <ddarius> DaveCGI12345: Perhaps you should look at what Haskell historically did before the IO monad and note that you can build an IO monad around those approaches.
21:53:03 <Cale> Then you ask the functional evaluator to evaluate a value of type IO (which is arbitrarily complicated), and as it constructs that IO value, you carry out the actions described.
21:53:18 <Cale> DaveCGI12345: Does that make sense?
21:53:34 <DaveCGI12345> Cale: but when does it know to execute the IO value?
21:53:40 <DaveCGI12345> ddarius, sure, what's that?
21:53:59 <Cale> As soon as it's finished evaluating enough of it that it can see a primitive IO action to be performed.
21:54:09 <Cale> So, like a getChar or something
21:54:23 <sorear> @users
21:54:23 <lambdabot> Maximum users seen in #haskell: 371, currently: 330 (88.9%), active: 21 (6.4%)
21:54:34 <DaveCGI12345> Cale, enough of "it" ?
21:54:47 <ddarius> http://citeseer.ist.psu.edu/30726.html
21:54:49 <lambdabot> Title: On the Expressiveness of Purely Functional I/O Systems - Hudak, Sundaresh, On (R ...
21:54:57 <Cale> DaveCGI12345: Well, barring a specific representation of IO values, it's hard to say exactly what it is. :)
21:55:09 <Cale> DaveCGI12345: But to a first approximation, you can imagine that >>= is a data constructor.
21:55:34 <Cale> and it just recurses to the left, evaluating the IO actions until it hits a primitive one
21:55:37 <ddarius> @flush
21:55:37 <lambdabot> Not enough privileges
21:55:39 <DaveCGI12345> so what? does that mean when you see >>= you fully reduce its argument?
21:56:40 <Cale> Its first argument, until you hit a primitive IO action, then that's executed, and it produces a value of the right type to apply the right argument to.
21:56:47 <Cale> (which produces another IO-thing)
21:57:02 <DaveCGI12345> >>= is infix or prefix ?
21:57:06 <Cale> infix
21:57:20 <Cale> So let's say you have getLine as an IO-primitive
21:57:26 <Cale> and you're executing the program
21:57:33 <Cale> getLine >>= putStrLn
21:57:39 <DaveCGI12345> so basically x >>= y, x is fully reduced before invoking y?
21:57:57 <SamB_XP> run, too...
21:58:00 <Cale> x is reduced, and then executed
21:58:14 <Cale> and the result of that execution is passed to the (pure!) function y
21:58:21 <Cale> which builds a further IO action
21:58:23 <DaveCGI12345> so >>= adds order to an otherwise unordered program?
21:58:26 <Cale> and then that action is executed
21:58:27 <kjdf> so how to make "Automaton a (e, b) c" out of a function arrow "(e, b) -> c" ?
21:58:36 <Cale> DaveCGI12345: It describes order.
21:58:43 <Cale> It might be easier to start with >>
21:59:04 <DaveCGI12345> it can describe order for all it wants, its not interesting unless that order is actually followed
21:59:10 <Cale> If x and y are IO actions, then (x >> y) is the IO action which when executed, executes x, throws away the result, then executes y.
21:59:58 <DaveCGI12345> yes, but thats not interesting either, unless x and y are complicated expressions which eventually both yield (IO a) and yet x is always guaranteed to reduce/execute before y
21:59:59 <Cale> So you can think of (>>) as a pure function which manipulates these IO values, which are like program scripts, basically by concatenating the program scripts.
22:00:32 <wli> catchIO m c = ErrorT $ catch (liftM return m) (runErrorT . c)
22:00:35 <Cale> x is guaranteed to reduce/execute before y because that's what the runtime system does with the resulting value.
22:00:49 <DaveCGI12345> " that's what the runtime system does with the resulting value." sorry didnt catch that part?
22:01:00 <Cale> You can't actually see how (x >> y) is represented, but it might as well be represented by simply recording x and y in a pair.
22:01:11 <SamB_XP> yes.
22:01:24 <shachaf> In IO, x is guaranteed to reduce/execute before y in (x >> y), unless you use an unsafe operation (is this right?).
22:01:33 <SamB_XP> IO could be like this:
22:01:51 <Cale> It's the RTS which has to care about executing them in the right order, and that's separate from the evaluation mechanism and the program you're writing.
22:02:22 <DaveCGI12345> Cale: so you're saying a property of haskell is that it brings order when using the >> and >>= operators?
22:02:33 <DaveCGI12345> and thats how IO is achieved?
22:02:33 <Cale> DaveCGI12345: on the IO type.
22:02:45 <DaveCGI12345> so is this a magical compiler feature?
22:02:50 <Cale> DaveCGI12345: In a sense, it doesn't matter that x and y are evaluated in any particular order there.
22:03:04 <Cale> Just that the effects are carried out in that order, which is a separate thing.
22:03:09 <DaveCGI12345> Cale: right, only as long as x is executed before y?
22:03:12 <Cale> yeah
22:03:28 <SamB_XP> data IO a where Return :: a -> IO a; Bind :: IO a -> (a -> IO b) -> IO b; HPutChar :: Handle -> Char -> IO (); ...
22:03:34 <Cale> and the thing which actually deconstructs the IO values is able to do that.
22:03:46 <SamB_XP> (well, except for that darned FFI ;-)
22:03:46 <DaveCGI12345> so.. IO value execution is magic right?
22:03:56 <Cale> Pretty much, yes.
22:04:00 <DaveCGI12345> wonderful...
22:04:06 <Cale> But you're not exposed to that magic.
22:04:13 <SamB_XP> well we have to keep the magic somewhere
22:04:18 <Binkley> @quote magic
22:04:18 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
22:04:38 <Cale> As a programmer, you're only required to describe an IO action, and you can do that in a purely functional way.
22:05:10 <DaveCGI12345> SamB_XP isnt that how the IO type class instance declaration already is?
22:05:17 <SamB_XP> @quote magic
22:05:17 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
22:05:45 <SamB_XP> DaveCGI12345: that's just the beginning of a GADT declaration
22:06:07 <Cale> DaveCGI12345: Data declaration, and while it could be like that, it actually cheats by just ensuring that the data dependencies are right, and using impure values.
22:06:13 <DaveCGI12345> Cale: so it seems like the compiler adds magic "execution" which can be ordered.. that puts me much at ease
22:06:38 <Cale> DaveCGI12345: But the only magic part of the execution is actually performing the actions.
22:06:42 <lament> it should. It's white magic, not black magic :)
22:06:46 <Cale> Everything else is pure.
22:06:54 <Cale> (in theory)
22:06:57 <DaveCGI12345> well, guaranteed ordering is pretty magical to me :P
22:07:06 <Cale> Well, we also have seq
22:07:11 <SamB_XP> Cale: Sure, your implementation cheats
22:07:17 <Cale> If you want to order evaluation, you can use that :)
22:07:22 <DaveCGI12345> its pointless
22:07:28 <DaveCGI12345> i can do that by building data dependencies :-)
22:07:39 <Cale> (though due to a bug in the standard, seq doesn't *quite* order the evaluation)
22:08:01 <roconnor> bug in the standard?
22:08:11 <SamB_XP> DaveCGI12345: with GHc it's done by having the compiler pull the wool over it's own eyes and pretend that it's passing the world around
22:08:12 <sjanssen> I don't think it's a bug
22:08:14 <Cale> Well, I suppose it depends.
22:08:34 <DaveCGI12345> I dont like this whole "world" examples
22:08:35 <Cale> It does manage to avoid discussing evaluation :)
22:08:49 <Cale> DaveCGI12345: Yeah, I really hate the RealWorld analogy.
22:08:52 <shachaf> Cale: What is the bug (/non-bug)?
22:09:22 <DaveCGI12345> i might not be thinking the same thing everyone else is thinking (its my first time hearing of this analogy), but from my POV that analogy would only amply describe side effects emanating from within the haskell program. what about side effects *outside* the program but affecting the program indirectly?
22:09:31 <Cale> shachaf: x `seq` y is not required to evaluate x before y, only to evaluate x before the result of y is returned.
22:09:32 <SamB_XP> DaveCGI12345, Cale: it's a false analogy, but the compiler can use it to keep the IO actions in order with data dependencies
22:09:56 <SamB_XP> @src IO
22:09:56 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:10:01 <Cale> DaveCGI12345: well, they're "part of the real world too"
22:10:28 <DaveCGI12345> yes but passing around a RealWorld state implies that our program changes it and passes a new value representing the state.
22:10:31 <goalieca> conceptual problem: State ideally should be at top level.. calling pure functions all the way down.
22:10:32 <SamB_XP> DaveCGI12345: that's actually how GHC treats the IO monad
22:10:33 <goalieca> but what if the bottom layer is a statefull algorithm. then its monad's all the way down (instead of turtles).
22:10:39 <DaveCGI12345> which is simply impossible when another program has changed your program's state
22:10:48 <sjanssen> DaveCGI12345: in an actual compiler (like GHC), RealWorld is just used as an artificial data dependency to guarantee evaluation order
22:10:53 <SamB_XP> DaveCGI12345: note that the State# RealWorld is completely imaginary
22:11:04 <Cale> DaveCGI12345: yeah, it kind of fails to take concurrency into account at all
22:11:05 <SamB_XP> it does not take up any registers or memory
22:11:31 <SamB_XP> JHC uses the same trick
22:11:36 <Cale> SamB_XP: Yeah, the compiler is cheating though. It has impure values with pure types.
22:11:38 <DaveCGI12345> that brings us beautifully to concurrency.. does haskell handle that at all?
22:11:39 <reffie> ?src foldr1
22:11:39 <lambdabot> foldr1 _ [x]    = x
22:11:40 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
22:11:40 <lambdabot> foldr1 _ []     = undefined
22:12:03 <SamB_XP> Cale: has it?
22:12:13 <Cale> SamB_XP: Yes.
22:12:16 <Tac-Tics> Poll: In a well written Haskell program, what is a healthy ratio of pure to IO code?
22:12:16 <Binkley> DaveCGI12345: there are extensions to Haskell that provide it
22:12:20 <reffie> ?src foldr
22:12:21 <lambdabot> foldr k z xs = go xs
22:12:21 <lambdabot>     where go []     = z
22:12:21 <lambdabot>           go (y:ys) = y `k` go ys
22:12:28 <SamB_XP> Cale: You aren't allowed to use the RealWorld more than once though, so you'll never catch it in a lie
22:12:29 <Binkley> Tac-Tics: 1/pi
22:12:36 <Tac-Tics> that's a lot of IO code
22:12:37 <Cale> Tac-Tics: depends on the application, but small.
22:12:40 <DaveCGI12345> well i guess you could use the IO monad to implement mutexes
22:12:43 <sjanssen> DaveCGI12345: it has a threading story similar to many other languages
22:13:03 <Tac-Tics> I think I managed to figure out how I want to solve my silly tank game's configuration problem
22:13:09 <SamB_XP> sjanssen: don't talk like that. it sounds sad!
22:13:16 <Tac-Tics> and that is, each object keeps the config information stored inside of it
22:13:31 <Tac-Tics> and then, each object is created with IO through the GameEnv object
22:13:32 <Cale> DaveCGI12345: The *standard* doesn't specify concurrency, but the implementations, GHC in particular have lots of cool concurrency stuff.
22:13:46 <Tac-Tics> I'm thinking I'm going to use the GameEnv object as the center for all my IO stuff
22:14:12 <Cale> DaveCGI12345: There's MVars, STM, Parallel evaluation annotations, and soon, nested data parallelism (parallel arrays)
22:14:35 <DaveCGI12345> explicit parallelism should be mostly unnecessary
22:14:40 <Cale> DaveCGI12345: There's a primitive  forkIO :: IO a -> IO ThreadId
22:14:45 <Tac-Tics> so creation of all my game objects would need to be managed by the GameEnvironment
22:14:50 <DaveCGI12345> just figure out when to thread implicitly? :P
22:14:53 <Tac-Tics> but all my game objects are kept pure
22:14:53 <Cale> DaveCGI12345: Which runs an IO action in a new thread.
22:14:59 <Cale> Then there's par
22:15:06 <SamB_XP> DaveCGI12345: that's the holy grail of purely functional programming
22:15:14 <sjanssen> DaveCGI12345: implicit parallelism is a really hard problem
22:15:22 <Cale> x `par` y  will spark x for potential parallel evaluation while returning the result of y.
22:15:23 <DaveCGI12345> SamB_XP, well its not that pure :)
22:15:28 <Cale> @type par
22:15:30 <lambdabot> forall a b. a -> b -> b
22:15:40 <SamB_XP> DaveCGI12345: implicit parallism is totally pure
22:15:40 <Cale> (par is nicely pure)
22:15:56 <DaveCGI12345> SamB_XP sorry how is that? the IO is still side effect
22:16:05 <SamB_XP> DaveCGI12345: you don't do it for IO stuff
22:16:13 <DaveCGI12345> well...yeah :)
22:16:22 <Cale> Par is sort-of-explicit parallelism. You don't have to worry about actually allocating things onto processors though.
22:16:23 <wli> Hmm, f ||| id probably has a simpler expression.
22:16:39 <Cale> It just evaluates things which have been sparked whenever there's a processor free.
22:16:39 <DaveCGI12345> yeah i am actually interested in doing implicit parallelism research ... we'll see if any professors at my school like me
22:16:40 <SamB_XP> @type (|||)
22:16:42 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
22:16:50 <SamB_XP> @instances ArrowChoice
22:16:51 <lambdabot> (->), Kleisli m
22:16:56 <Cale> Completely implicit parallelism is really really hard.
22:17:15 <DaveCGI12345> let it be hard, when its done, the world will be thankful
22:17:19 <Cale> Because it's very hard to know whether an expression will be expensive to evaluate or not.
22:17:23 <DaveCGI12345> explicit threading is the way of the dodo
22:17:24 <SamB_XP> DaveCGI12345: don't set your heart or not
22:17:30 <SamB_XP> it might be out of style
22:17:37 <Cale> There's lots in between explicit threading and implicit parallelism.
22:17:41 <Tac-Tics> Cale: It is expensive to know how expensive something is
22:17:43 <DaveCGI12345> SamB_XP, what might be out of style?
22:17:49 <Cale> Tac-Tics: that too :)
22:17:56 <SamB_XP> DaveCGI12345: funding for implicit parallism research
22:18:03 <DaveCGI12345> how's that?
22:18:16 <Cale> Data parallelism is a rather good compromise.
22:18:17 <SamB_XP> I imagine it goes in and out of style
22:18:26 <DaveCGI12345> Cale: whats the difference?
22:18:32 <SamB_XP> yes, data parallism does seem like a nice compromise
22:18:46 <SamB_XP> DaveCGI12345: it's actually a bit like par
22:18:48 <Cale> The programmer has to use explicit data structures which mark where the parallelism goes.
22:18:55 <SamB_XP> except you don't have to write par everywhere
22:19:00 <SamB_XP> you just use a parallel data structure
22:19:10 <DaveCGI12345> that sounds a little better
22:19:19 <Cale> For example, an array type which splits its computation across processors automatically.
22:19:27 <DaveCGI12345> i'd rather the programmer write a standard program and have it get parallelized as much as possible of course
22:19:43 <SamB_XP> and the P can also be used to stand for Packed, if you only have one CPU ;-P
22:19:47 <DaveCGI12345> dont see why research for that would go away, we seem to have hit the clockspeed per 1 processor limit..
22:20:12 <SamB_XP> well, data parallism is clearly practical
22:20:13 <Cale> DaveCGI12345: It's really hard to get new results there because people have actually been working on that a long time.
22:20:20 <Cale> (implicit parallelism)
22:20:40 <SamB_XP> and implicit parallelism is almost worse than the halting problem
22:20:42 <DaveCGI12345> Cale: great, maybe ill just implement some of the ideas and get rich instead :P
22:21:00 <SamB_XP> you'd want to know not only whether something halts or not, but how long it is likely to take ;-)
22:21:04 <DaveCGI12345> whats the problem? it doesnt need to be perfect after all
22:21:35 <Cale> The problem is that you actually get fairly mediocre benefits from it compared to data parallelism or explicit parallelism.
22:21:59 <sjanssen> DaveCGI12345: starting a new computation thread can be pretty expensive
22:22:11 <Tac-Tics> does if-then-else obey the whitespace rules? or are they freeform?
22:22:24 <sjanssen> especially if you end up forking that thread just to evaluate "1+1", or something silly
22:22:30 <Cale> Tac-Tics: Inside a do-block, it matters
22:22:35 <shachaf> Tac-Tics: Why wouldn't it?
22:22:36 <DaveCGI12345> practical approach: run performance benchmark alongside your program, then use the historical runtime data to figure out when to thread
22:22:46 <Tac-Tics> I was just wondering if it was a special operator
22:22:48 <Cale> Tac-Tics: It's best to align the 'then' and 'else', and indent them a little deeper than the 'if'
22:23:29 <Tac-Tics> sometimes I do it... for example if e then a else b with 'then' and 'a' on the same line. sometimes not
22:23:33 <DaveCGI12345> and isnt there a style you could code in that would be more conducive to concurrency? CSP or something like that
22:23:57 <Tac-Tics> since I've never had a problem with it, I wondered if it mattered at all
22:24:12 <SamB_XP> constraint satisfaction problems?
22:24:26 <DaveCGI12345> hmm no
22:24:37 <dolio> Communicating sequential processes, or something like that.
22:24:41 <Cale> Communicating Sequential Processes
22:24:41 <Cale> yeah
22:24:47 <DaveCGI12345> yeah
22:25:03 <Cale> It doesn't actually say how processes should be allocated onto processors though.
22:25:12 <Cale> (and that's the problem)
22:25:36 <DaveCGI12345> hm. maybe in the future processors will have 1 instruction to start a new thread
22:25:56 <goalieca> fork maybe,
22:26:00 <goalieca> but even so..
22:26:34 <goalieca> os probably needs to know ..
22:26:46 <Cale> If you have 100,000,000 elements to compute in parallel and sum up, you really don't want to schedule each of them individually.
22:27:15 <goalieca> Cale: so how about a gpu
22:27:27 <goalieca> coprocessor or something
22:27:34 <DaveCGI12345> ill take a nondeterministic turing machine for $1 plz
22:28:11 <Cale> You want to divide them into chunks of size roughly 100,000,000/n where n is the number of processors you have and then hand the work off to those processors, each of which does a tight loop.
22:28:45 <goalieca> isn't this data parallel paradigm
22:28:49 <Cale> But to know that you're going to need to do that, it seems that you need something more than just having the compiler guess at it.
22:28:55 <Cale> yes
22:29:11 <DaveCGI12345> hey you'd be pretty well off if you guessed and divided the syntax tree by n :)
22:29:48 <Cale> At least, in a Turing complete language
22:30:16 <Cale> If you want to design a special-purpose language for something like signal processing, I'm sure you can probably come up with something where splitting the work is much simpler.
22:32:02 <DaveCGI12345> i like the hinting with `par`
22:32:23 <Cale> You'll probably really like the nested data parallelism stuff :)
22:33:00 <Cale> You were going to store all that data in an array or something anyway, so why not have the data structure be the main unit of describing parallelism?
22:33:13 <kjdf> hm
22:33:21 <Cale> It also can be quite smart about chunking nested parallel computations.
22:33:30 <kjdf> why "plus1Auto :: Automaton (->) (Env,Int) Int" does work
22:33:34 <DaveCGI12345> maybe if my program isnt asynchronous IO yes
22:33:43 <SamB_XP> DaveCGI12345: see http://www.londonhug.net/2007/05/25/video-of-spjs-talk-is-now-online/
22:33:43 <Cale> yeah
22:33:45 <lambdabot> Title: Î»ondon HUG » Blog Archive » Video of SPJ&#8217;s Talk is now Online, http://tinyurl.com/yoq6w9
22:33:48 <kjdf> and "plus1Auto :: Automaton ((Env,Int) -> Int)" doesn't
22:34:29 <wli> ((ioError . userError) |||) seems handy
22:34:34 <kjdf> it says something about kind errors --  *->*->* vs *
22:34:43 <Cale> kjdf: because (->) is a parameter to Automaton
22:35:09 <Cale> It's not Automaton ((->) (Env,Int) Int)
22:35:14 <SamB_XP> DaveCGI12345: that's SPJ's talk about nested data parallelism
22:35:19 <kjdf> ok
22:35:21 <Cale> it's  ((Automaton (->)) (Env,Int)) Int
22:35:26 <SamB_XP> to the London HUG
22:35:30 <DaveCGI12345> microsoft eh?
22:35:45 <Cale> DaveCGI12345: Microsoft research, yeah
22:36:03 <DaveCGI12345> microsoft research sounds great. except for the part where they own your soul
22:36:03 <Cale> DaveCGI12345: Don't worry, he's a very open source guy :)
22:36:13 <goalieca> too bad none of the good stuff from MS research makes windows.
22:36:14 <Cale> All his code is BSD :)
22:36:14 <SamB_XP> did we forget to mention that Haskell is pure *evil*?
22:36:24 <Binkley> DaveCGI12345: yes, the employment agreements are signed in blood
22:36:38 <DaveCGI12345> Cale: oh wow even the code he makes at MS?
22:36:42 <Cale> DaveCGI12345: yes
22:36:45 <DaveCGI12345> cool
22:36:53 <Binkley> you have to sell your soul to work there but the coffee is great
22:36:58 <SamB_XP> DaveCGI12345: I get the impression that's where he makes almost all his code...
22:37:00 <Cale> DaveCGI12345: He's one of the main GHC developers.
22:37:01 <DaveCGI12345> hmm nested data parallelism? this sounds like something i never heard about
22:37:14 <SamB_XP> DaveCGI12345: indeed
22:37:15 <Cale> DaveCGI12345: yes, it's extremely cool :)
22:37:22 <DaveCGI12345> i know about flat.. and its boring lol
22:37:35 <SamB_XP> yes that's why this talk is longer than 15 minutes
22:38:12 <SamB_XP> or, should I say, if it were about flat data parallelism it wouldn't be more than 15 minutes
22:38:27 <SamB_XP> (nevermind that it would never have happened)
22:40:03 <Cale> DaveCGI12345: So this can actually parallelise effectively where your computation looks like a very unbalanced tree structure.
22:40:28 <DaveCGI12345> The data-parallel languages of the future will be functional languages
22:40:31 <DaveCGI12345> This guy rocks
22:40:33 <Cale> :)
22:41:08 <DaveCGI12345> but this looks very complicated and possibly even forcing the data structure designer to go crazy?
22:41:11 <DaveCGI12345> s/designer/implementer
22:41:13 <Cale> Yeah, you really need the sorts of guarantees that functional languages give you in order for any of this to make any sense.
22:41:27 <SamB_XP> DaveCGI12345: well the cool part is that you don't have to be the guy who goes crazy
22:41:30 <Cale> The implementer will need some pills, but they seem to have managed :)
22:41:42 <goalieca> how would star trek do it?
22:41:46 <goalieca> wwstd
22:41:47 <Cale> (this stuff is in development GHC)
22:41:50 <SamB_XP> I believe chak and his group are the ones who go crazy
22:42:06 <Cale> It'll be in 6.8 :)
22:42:07 <SamB_XP> goalieca: they'd farm it out to random holodeck simulations?
22:42:27 <DaveCGI12345> thats amazing
22:43:21 <DaveCGI12345> can this method be applied to custom data structures though?
22:43:50 <Cale> Yes, you can build custom data structures out of parallel arrays.
22:44:05 <SamB_XP> I'm not sure how that will work out
22:44:13 <DaveCGI12345> yeah this seems big on arrays
22:44:15 <SamB_XP> It shouldn't be too bad though
22:44:25 <DaveCGI12345> ill probably reread this presentation a few times later this week and understand it more
22:44:42 <SamB_XP> read?
22:44:44 <Cale> Usually by storing some kind of indexing/structure information in a parallel array alongside the contents.
22:44:50 <DaveCGI12345> yeah im looking at the ppt
22:45:00 <SamB_XP> hmm.
22:45:20 <goalieca> will this parallel array be monadic? (plz say no!)
22:45:25 <Cale> You're also allowed to have parallel arrays of parallel arrays
22:45:29 <Cale> goalieca: no
22:45:43 <SamB_XP> goalieca: of course not
22:45:47 <Cale> goalieca: In fact, that wouldn't even really work.
22:45:52 <SamB_XP> that would totally mess it up
22:46:10 <SamB_XP> it wouldn't be very parallel that way...
22:46:17 <goalieca> good. i haven't been following but I hate the idea that i have to think of things. I want a drop in replacement
22:46:22 <DaveCGI12345> well im glad i started getting interested in haskell
22:46:25 <DaveCGI12345> since its clearly the way of the future
22:46:33 <Cale> DaveCGI12345: indeed :)
22:46:34 <DaveCGI12345> Way of the FutureTM*
22:46:40 <SamB_XP> a way of the the future, anyway
22:46:57 <SamB_XP> it is much like the way of the future must needs be...
22:49:41 <Binkley> ?quote future
22:49:42 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
22:51:08 <dons> goalieca: they're pure arrays (of possibly nested type), that happen to run operations in parallel
22:51:12 <dons> transparently
22:51:26 <dons> and in native code. take that erlang ;)
22:51:36 <Cale> hehe
22:52:13 <wli> I wish you could do import Data.Map qualifying (map, lookup) etc.
22:52:29 <jfredett> Epigram makes my brain hurt
22:52:36 <jfredett> but its a good pain
22:52:46 * jfredett twitches
22:52:59 <jfredett> mmm, dependent types and first order logic
22:53:01 <dons> wli: ? import qualified Data.Map as M (map,lookup)
22:53:10 <dons> import Data.Map hiding (map,lookup)
22:53:20 <Cale> The concrete syntax is what bothers me most about Epigram.
22:53:46 <wli> dons: It would correspond to where only the symbols in the "qualifying" list need to be qualified.
22:53:58 <jfredett> it is a little weird
22:54:04 <jfredett> Epigram syntax
22:54:18 <jfredett> I might be able to get used to it, but its a little far and away from haskell
22:54:27 <wli> dons: If you hide them outright even the qualified names are rejected.
22:54:40 <Cale> (and I love layout, but that's just getting nuts :)
22:54:48 <jfredett> lol
22:55:20 <jfredett> See, if we had more clever ways of doing input to computers
22:55:22 <dolio> My concern is that it's a lot more verbose than, say, Haskell. But I guess they're looking into ways to alleviate that some.
22:55:39 <jfredett> like if we hadn't forced keyboards to only ever write by line
22:55:43 <dons> wli, really? with both imports?
22:55:45 <jfredett> Epigram would be no problem
22:55:46 <dolio> Not that it isn't doing more interesting stuff with that verbosity.
22:56:05 <wli> dons: Oh, you can import multiple times? That would solve it.
22:56:16 <Cale> DaveCGI12345: also see http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
22:56:17 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
22:56:38 <jfredett> dolio, Cale: I'm certainly no expert in Epigram (yet, or probably any time in the near future), but I think the benefits outweigh the costs
22:57:11 <wli> dons: Looks like import qualified Data.Map as Map ; import Data.Map hiding (map, lookup) then
22:57:17 <jfredett> just looking at the capabilities in the first few chapters of the primer,
22:57:20 <Cale> jfredett: and I'm sure they could come up with a flatter concrete syntax for it :)
22:57:22 <jfredett> its crazy
22:57:33 <jfredett> jfredett: well, they (kindof) have one
22:57:45 <Cale> It does seem worthwhile, but it seems like it gives up too much in the way of type inference
22:58:07 <jfredett> but it seems that its like not adding type-sigs to Haskell, it's possible, but those in the know usually don't do it.
22:58:20 <Cale> I rather like the Haskell approach of having fancier and fancier types, but preserving as much in the way of inference as possible.
22:58:28 <jfredett> yeh
22:58:30 <Cale> So only the fancy types have to be annotated.
22:58:41 <jfredett> I dunno
22:58:46 <jfredett> I annotate just about everything
22:58:59 <jfredett> unless its in a where clause, then I only annotate as needed
22:59:04 <Cale> I annotate everything at the top level.
22:59:08 <jfredett> I like annotations, they make me feel smart
22:59:20 <goalieca> would you annotate sum x y ?
22:59:38 <Cale> (well, mostly everything)
22:59:40 <Binkley> goalieca: usually people annotate top-level definitions
22:59:41 <SamB_XP> well first of all
22:59:48 <Binkley> rather than expressions
22:59:51 <SamB_XP> where did you get the Num instance for (a -> b)
23:00:03 <jfredett> goalieca: yep,
23:00:04 <Cale> Actually, for quick programs I'm likely not to annotate anything at all.
23:00:04 <hpaste>  aaim pasted "2.71828" at http://hpaste.org/2125
23:00:20 <jfredett> goalieca: I mean yep, what Binkley said
23:01:07 <jfredett> but generally, if I write a function, I annotate it, it helps me think about what I need in the function.
23:01:40 <jfredett> I find that thinking even on the superficial level about how to order the arguments to a function helps me write it more effectively
23:01:49 <jfredett> I usually do that while I annotate
23:02:04 <peterhunt> hi guys, i've been trying to learn haskell on and off for about a year (haven't had much time until now) and i was wondering if anyone had any ideas for a good sort of first large project i could attempt.
23:02:47 <goalieca> peterhunt: how about a maze program
23:02:51 <goalieca> random-generate
23:02:53 <goalieca> solution/hinting
23:02:58 <jfredett> goalieca: thats not a bad idea
23:03:12 <peterhunt> hmm
23:03:12 <wli> goalieca: Any specifications?
23:03:32 <jfredett> peterhunt: heck, you could write hunt the wumpus!
23:03:33 <peterhunt> i suppose that would give me an opportunty to learn some haskell-specific cool features?
23:03:50 <goalieca> Basically just a wall or a path. All paths must be connected. No cycles
23:03:56 <goalieca> only 1 solution
23:04:02 <jfredett> yeh, the Random and IO monads, at the least.
23:04:24 <jfredett> maybe zippers too, pete
23:04:38 <ricky_clarkson> I wrote a maze program when I was 10 in BASIC.  I was starting to tackle auto-generation when I realised that nobody wanted to play it and gave up.
23:04:58 <jfredett> come to think of it, Mazes are a big old pile of neat datastructures
23:05:00 <lament> ricky_clarkson: thus most young talents are buried forever.
23:05:01 <wli> ricky_clarkson: Fine, make it a MUSH.
23:05:13 <peterhunt> i could give it a shot. i know a decent amount of haskell and a bunch of SML
23:05:15 * jfredett wanders off in thought
23:05:18 <wli> Or MUD.
23:05:29 <peterhunt> (mainly i know how to write SML in haskell which is not really knowing haskell :))
23:05:30 <goalieca> lol. I whipped a maze-generator up in ~60 lines. The c# and c++ people did it in a lot more. Kinda worth bragging. But mine was the slowest :(
23:05:32 <Tac-Tics> lament: it's so true. Most people sell them selves way to short
23:05:35 <goalieca> well about the same speed as c#
23:06:22 <jfredett> peterhunt: as long as you dont write COBOL in Haskell, you should be fine. :P
23:06:31 <sorear> My first large program was a full-featured Game of Life program.
23:06:39 <lament> maze generator (pseudocode):   loop {print random_choice('\', '/')}
23:07:01 <sorear> lament: That will make islands, alas.
23:07:08 <jfredett> lament, cycles?
23:07:15 <lament> sorear: yes, it's not particularly smart :)
23:07:19 <goalieca> and must be 1 solution. only 1
23:08:10 <peterhunt> hmm
23:08:11 <jfredett> goalieca: probably use a randomly generated k-leaved-tree,
23:08:13 <sorear> Fortunately, a randomized DFS isn't much more work
23:08:15 <Tac-Tics> is there any way to write a function which mixes IO and State?
23:08:15 <jfredett> mark a random leaf node
23:08:18 <jfredett> and the root
23:08:19 <fax> while not perfect make-random-maze
23:08:21 <sorear> StateT IO
23:08:28 <Tac-Tics> ah crap, more to learn
23:08:31 <JBGood25> union find?
23:08:35 <peterhunt> for a start, data Cell = Path | Wall
23:08:40 <peterhunt> type Maze = [[Cell]]
23:08:46 <goalieca> jfredett: the one i did in haskell used an array, and a stack to keep track of path. it had a randomness component to branching
23:08:55 <JBGood25> it might be better to represent it as a graph
23:08:59 <jfredett> goalieca: Zipper!
23:09:22 <jfredett> now I'm gonna go write a Zipper based Maze generator, DFA's can wait, :P
23:09:26 <lament> Tac-Tics: wli has rewritten my short program that used iorefs with StateT, see http://hpaste.org/2119
23:09:42 <Tac-Tics> thanks lament, I'll take a look
23:09:45 <peterhunt> JBGood25: like a 3-ary tree?
23:10:19 <JBGood25> depends on how exactly you want to build it, but that might work
23:10:20 <Tac-Tics> is there any good reason to mix State and IO?
23:10:37 <lament> Tac-Tics: yes, you avoid the use of iorefs :)
23:10:38 <Tac-Tics> besides the fact that state doesn't allow me to update the screen and take input
23:10:39 <jfredett> Tac-Tics: is there any good reason _not_ too?
23:10:45 <Tac-Tics> just curious
23:11:01 <Tac-Tics> I am still very new to Haskell
23:11:18 <jfredett> Tac-Tics: heh, Everythings a good Idea, till its a bad Idea
23:11:38 <Tac-Tics> I get the feeling if all I ever use is the IO monad, someone here will shower me in holy monad fire and cleanse the evil from me.... leaving burn marks all over
23:11:51 <Binkley> ?remember Tac-Tics I get the feeling if all I ever use is the IO monad, someone here will shower me in holy monad fire and cleanse the evil from me.... leaving burn marks all over
23:11:51 <lambdabot> Done.
23:11:58 <jfredett> Tac-Tics: have you ever used Maybe?
23:12:01 <jfredett> :P
23:12:13 <Tac-Tics> jfredett: Just  yes
23:12:19 <jfredett> ...
23:12:26 <jfredett> Tac-Tics: That was good.
23:12:34 <lament> Tac-Tics: Certainly your entire program could be inside the main
23:12:37 <jfredett> better than the joke I was going to make
23:12:56 <lament> Tac-Tics: but if you somehow refactor it, chances are, many of the components won't need to care about IO
23:13:11 <Tac-Tics> yeah
23:13:19 <Tac-Tics> All I need IO for is eventually SDL
23:13:38 <Tac-Tics> everything else just makes sense to use State tied into my GameEnv type
23:15:10 <goalieca> do external language calls require monads?
23:15:42 <sorear> dons: thanks
23:15:59 <lament> i should hope so, unless the external language is referentially transparent
23:16:20 <peterhunt> goalieca: is it cheating to have the maze generator mark the cells which are along the solution path?
23:16:30 <Tac-Tics> You can probably write a foreign function and "fake" that it is a natural haskell function
23:16:38 <goalieca> peterhunt: no.. just don't show the user
23:16:47 <peterhunt> goalieca: got it
23:16:55 <sorear> lament: you can make that distinction on a function-by-function basis, foreign import ccall "math.h sin" sin :: CDouble -> CDouble -- no IO!
23:17:00 <goalieca> what if the algorithm internally uses states but is transparent to the outside
23:17:12 <lament> You are in a maze. Paths go east, north and west. The path that goes to the exit is to the west.
23:17:13 <goalieca> like i have fast calcs that can be done in c
23:17:13 <sorear> goalieca: that's what ST is for
23:17:34 <peterhunt> i have my data structure almost defined.
23:17:35 <SamB_XP> also Foreign.unsafePeformIO
23:17:39 <sorear> goalieca: and unsafePerformIO, and non-IO foreign imports
23:18:01 <SamB_XP> (Which is there in case you have some explicit marshalling to do)
23:18:01 <sorear> SamB_XP: the canonical location for that is System.IO.Unsafe nowadays ;)
23:18:03 <lament> (anybody remember the maze from Photopia?)
23:18:15 <SamB_XP> lament: do I ever
23:18:21 <SamB_XP> I loved that maze
23:18:23 <lament> :)
23:18:36 <SamB_XP> "Guess the verb" indeed!
23:18:53 <lament> i have to admit i had to get hints to get it, after which i stopped considering myself a genius
23:19:01 <SamB_XP> eh
23:19:01 <SamB_XP> eh
23:19:03 <SamB_XP> heh
23:19:05 <lament> :P
23:19:08 <SamB_XP> how long did you walk around?
23:19:56 <SamB_XP> had you seen the signs but ignored them?
23:20:04 <lament> yeah.
23:20:12 <SamB_XP> huh
23:20:20 <wli> I actually can't think of a good algorithm to randomly generate mazes offhand.
23:20:37 <SamB_XP> I just naturally followed the hint...
23:21:25 <SamB_XP> maybe because I have sensitive skin ;-)
23:21:43 <Tac-Tics> wli: try randomly adding edges between adjacent cells off of the solution path under the condition that the two verts the edge is added to have at most degree two after the edge is added
23:21:54 <dons> sorear: ?
23:22:12 <Tac-Tics> wli: at least, that's what I remember. I read an article on it a long long time ago
23:22:23 <sorear> dons: I would never have imagined how un-coq-like Isabelle is
23:22:36 <dons> heh
23:22:53 <dons> I find Isabelle rather Haskellish (well, ML ish)
23:23:11 <lament> please, remember to use the word un-coq-like in speech some time
23:23:15 <dons> its pretty natural to FP programmers (i've barely looked at Coq though)
23:23:33 <peterhunt> argh. i've been python-ing for too long
23:23:33 <dons> sorear: the next thing is Twelf, once you're done with Isabelle. Spec. for encoding up type systems and languages.
23:23:49 <sorear> lament: not until I know the correct pronunciation of Coq itself ;)
23:24:09 <SamB_XP> peterhunt: how has it manifested?
23:24:14 <lament> surely that's a FAQ?
23:24:18 <SamB_XP> sorear: what do you think?
23:24:29 <Tac-Tics> peterhunt: python is an excellent language. The language of elegant source layout. you can't overpython yourself.
23:24:40 <sorear> SamB_XP: I can think of two plausible ways.
23:24:41 <SamB_XP> sorear: ... coke?
23:24:54 <peterhunt> yes, but my brain is working in imperitive datastructures right now :)
23:25:00 <peterhunt> i love python though
23:25:17 <sorear> SamB_XP: with a slight twinge of w at the end
23:25:19 <sorear> ?
23:25:31 <SamB_XP> sorear: I was thinking like the soft drink
23:25:44 <wli> The "alternate language" I liked was Mercury. Of course, grunt work and day job affairs are all C.
23:26:00 <SamB_XP> sorear: the other one being, of course, "cock". which is the one everyone is always talking about...
23:26:12 <Tac-Tics> I was considering learning Ocaml, but the look of the source code turned me off. I like haskell because it is as close as you can get to Python's simple syntax in an FP lang
23:26:14 <lament> nobody knows french in here?
23:26:51 <SamB_XP> not I!
23:27:40 <TSC> Mais non
23:27:52 <ari> lament: #haskell.fr does :p
23:28:10 <sorear> My mom is a french teacher (by training, not occupation), and I don't know a sentence of it.  How shameful.
23:28:12 <dons> Tac-Tics: hah
23:28:35 <ricky_clarkson> sorear: Which part of that is shameful?
23:28:38 <wli> I think a MUD/MUCK/MUSH/MOO engine would be interesting to write, though I'm totally clueless wrt. ontology.
23:28:41 <dons> most here consider python syntax an ad hoc, informal implementation of haskell's layout rule (with tabs, and semi-broken list comprehensions :)
23:28:50 <jfredett> Jeu no comprens francais (It's been a while, forgive errors, sil vous plais.)
23:28:51 <dons> actually, even the python site says something about that
23:29:00 <sorear> dons: Our layout rule has tabs too!
23:29:03 <peterhunt> python is non shitty java
23:29:08 <dons> sorear: not compulsory ones
23:29:16 <bos> python got its layout rule from ABC.
23:29:17 <sorear> dons: neither does python
23:29:23 <jfredett> Haskell is non-shitty programming, :)
23:29:29 <wli> Well, if you have monad comprehensions, it's over except for maybe array comprehensions.
23:29:35 <sorear> @quote make
23:29:35 <lambdabot> cjeris says: and it's amazing what some languages do to make thinking impossible, seemingly justified by the assumption that no one thinks anyway, so it's more important to make non-thinking
23:29:35 <lambdabot> programming as easy as possible.  see ColdFusion.
23:29:46 <sorear> @quote make.*using
23:29:46 <lambdabot> ghc says: Warning: you can make GHC diverge by using SPECIALISE INLINE on an ordinarily-recursive function.
23:29:48 <sorear> @quote make.*using
23:29:48 <lambdabot> ghc says: Warning: you can make GHC diverge by using SPECIALISE INLINE on an ordinarily-recursive function.
23:30:45 <SamB_XP> neato
23:30:58 <jfredett> gnite folks
23:30:59 <bos> haskell got its layout rule from ISWIM, by way of Miranda and KRC. what's not clear is whether ABC got its layout rule from ISWIM, too.
23:31:09 <ricky_clarkson> "screw ruby on rails, I'm using snakes on a plane" - from lambdabot. ;)
23:31:18 <jfredett> lol
23:31:19 <SamB_XP> @quote snakes
23:31:19 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
23:31:21 <SamB_XP> @quote snakes
23:31:21 <jfredett> kickass
23:31:21 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
23:31:23 <SamB_XP> @quote snakes
23:31:23 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
23:31:25 <SamB_XP> @quote snakes
23:31:25 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
23:31:29 <SamB_XP> where's MY quote
23:31:35 <peterhunt> i'd be curious as to whether the haskell guys prefer ruby or python
23:31:36 <shachaf> SamB_XP: A lot of them are gone.
23:31:41 <SamB_XP> well, I'll say it again then
23:31:51 <jfredett> I am sick and tired of these mother frakking rubys on these mother frakking rails.
23:32:11 <ricky_clarkson> peterhunt: python is a begrudging FP language, whereas Ruby is proud of its FP constructs.
23:32:13 <SamB> Is that a Python web framework?
23:32:28 <SamB_XP> there. I said it again
23:32:40 <bos> $ ruby
23:32:40 <bos> bash: ruby: command not found
23:32:45 <bos> nuff said.
23:32:46 <SamB_XP> now someone can figure out how to @remember it
23:32:55 <dons> bos, heh
23:33:17 <dons> ricky_clarkson: does ruby have (.) ?
23:33:20 <shachaf> bos: You at least somewhat like Python, right?
23:33:24 <opqdonut> let id = fix . const -- hmm
23:33:31 <shachaf> dons: I don't think so.
23:33:33 <bos> shachaf: yeah, i like python quite a bit.
23:33:40 <opqdonut> > let id = fix . const in (id 1, id (+1))
23:33:42 <lambdabot>  (1,<Integer -> Integer>)
23:33:45 <opqdonut> :)))
23:33:50 <ricky_clarkson> dons: I don't use it - I'm not trying to defend it, etc., just commenting.
23:33:55 <dons> so its just the block/closure support? anything else FP-ish?
23:34:05 <dons> oh, just wondering what the FP support in ruby really is
23:34:07 <dolio> It's got continuations. :)
23:34:09 <SamB_XP> ricky_clarkson: you say you don't actually USE snakes on a plane?
23:34:10 <sorear> bos: IIRC the ruby environment is called irb
23:34:11 <bos> ruby's in my "i have no reason to care about it" box, next to actionscript and cobol.
23:34:23 <opqdonut> :D
23:34:29 <shachaf> dons: Python doesn't have much that's FP-ish either.
23:34:37 <dons> bos, come on! cobol! you musn't have read Ralf Lammels 'Let's stop bashing cobol' paper :)
23:34:38 <Tac-Tics> If I have all my code written so far with type: "State GameEnv a" and I switch to StateT GameEnv IO (), is there a way to get the State and StateT types to play together?
23:34:54 <bos> not caring isn't a negative thing.
23:34:57 <shachaf> sorear: Yes, but the Ruby interpreter is called ruby. It would still be found if Ruby was installed, probably.
23:34:57 <dons> Tac-Tics: you might want to pick just one
23:35:00 <bos> it's just not caring.
23:35:10 <SamB_XP> Tac-Tics: there is this thing called sed(1)
23:35:14 <bos> now php i have active bad feelings towards.
23:35:33 <Tac-Tics> Monad Transformers seem kinda clunky
23:35:37 <dons> http://www.cs.vu.nl/~ralf/Cobol/stop-bashing-cobol.pdf :)
23:35:42 <SamB_XP> Tac-Tics: also I use type synonyms for my transformer stacks
23:35:43 <sorear> shachaf: it's not like I've ever actually tried to use it
23:35:44 <Tac-Tics> SamB_XP: what is sed(1)?
23:35:47 <sorear> Tac-Tics: They are.
23:35:51 <shachaf> Didn't someone suggest GameMonad m => ..., or something like that, a while ago?
23:35:59 <dons> Tac-Tics: yeah, name the monad transformer, and if you need the StateT, avoid the State as well
23:36:00 <ricky_clarkson> bos: Don't worry, PHP is on suicide watch, thanks to an upgrade that most PHPers aren't interested in.
23:36:03 <wli> sorear: What's less clunky than monad transformers?
23:36:09 * shachaf uses Ruby for simple string processing.
23:36:14 <SamB_XP> so that I can just change the synonym (and the code that invokes the computation) when I add something to my stack
23:36:21 <shachaf> Not much more than that, usually.
23:36:25 <dons> newtype M a = M { unM :: StateT MyState IO a } deriving (Monad,MonadState, ...)
23:36:28 <sorear> Has anyone else noticed the massive drop-off in Haskell code quality coincident with the introduction of monads?
23:36:40 <dons> Tac-Tics: then you just program in the M monad, and forget about the stack
23:36:43 <wli> sorear: Are you kidding?
23:36:45 <Binkley> sorear: you programmed in Haskell before there were monads?
23:36:56 <dons> sorear: heh
23:36:57 <sorear> Binkley: No, but I've read papers that predate them
23:37:10 <dons> sorear: though, come on, applicative functors, arrows ...
23:37:17 <SamB_XP> sorear: so you mean PAPER quality?
23:37:39 <dons> sorear: so you think the decline of the functional pearl is related to the rise in monadic types, and the fall of pirates?
23:37:45 <dons> its plausible, i must say
23:37:48 <SamB_XP> PIRATES?
23:37:50 <sorear> dons: sure.  it's just that once monads came along, people just said "screw it, I'm gonna use a monad" and stopped looking for good abstractions
23:37:50 <SamB_XP> what?
23:37:57 <ricky_clarkson> Arr.
23:38:01 <SamB_XP> @arr
23:38:02 <lambdabot> Yo ho ho, and a bottle of rum!
23:38:04 <dons> SamB_XP: you heard me.
23:38:04 <SamB_XP> @arr
23:38:04 <lambdabot> Yo ho ho, and a bottle of rum!
23:38:07 <SamB_XP> @arr
23:38:07 <lambdabot> Ahoy mateys
23:38:08 <Binkley> @quote pirate
23:38:08 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
23:38:09 <bos> dons: that lammel slideset is demented :-)
23:38:20 <dons> Ralf's a cool guy
23:38:23 <Tac-Tics> dons: why did you say "MyState" in newtype M a = M { unM :: StateT MyState IO a }
23:38:45 <dons> Tac-Tics: for whatever your state type is
23:38:49 <dons> i didn't scroll up :)
23:39:00 <Tac-Tics> ah
23:39:00 <Tac-Tics> ok
23:39:04 <dons> i use, for example,
23:39:04 <dons> newtype X a = X (ReaderT XConf (StateT XState IO) a)
23:39:05 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
23:39:18 <SamB_XP> type MyState = GameEnv
23:39:22 <dons> then just program in the X monad, with magic access for ReaderT and StateT and IO
23:39:22 <SamB_XP> ;-P
23:39:22 <Tac-Tics> yeah
23:39:26 <Tac-Tics> I got that now
23:40:05 <dons> bos: i heard a story once that at a graduate teaching school, he got fun of for wearing a MSR tshirt
23:40:14 <dons> so the next day Ralf wore his east german communist party tshirt instead
23:40:24 <lament> dons: is there a reason why the monads are in that order, or is it arbitrary?
23:40:45 <dons> lament: its not arbitrary, but they can be restacked relatively harmlessly
23:40:45 <lament> oh, right
23:40:57 <Tac-Tics> hehe, Haskell makes programming safer by ensuring that the extent of your side effects is proportional to the amount of work you do to circumvent the language's purity
23:41:02 <bos> dons: wonderful!
23:42:33 <dons> http://programming.reddit.com/info/2dacw/details just to confuse people
23:42:34 <lambdabot> Title: Stop bashing COBOL! (pdf) (reddit.com)
23:43:07 <wli> I need to work on understanding arrow.
23:43:19 <Binkley> is that link broken for anyone else?
23:43:24 <Binkley> cs.vu.nl isn't resolving
23:43:48 <Binkley> oh well, google cache saves the day
23:44:01 <dons> works here?
23:45:59 <opqdonut> ?remember Tac-Tics Haskell makes programming safer by ensuring that the extent of your side effects is  proportional to the amount of work you do to circumvent the language's purity
23:45:59 <lambdabot> Done.
23:46:06 <opqdonut> ?quote circumvent
23:46:06 <lambdabot> Tac-Tics says: Haskell makes programming safer by ensuring that the extent of your side effects is  proportional to the amount of work you do to circumvent the language's purity
23:46:09 <opqdonut> :)
23:47:48 <Tac-Tics> so now that i have this StateT in place, I can just IO and/or modify from anywhere
23:48:12 <dons> yeah, though you'll need liftIO to lift IO actions
23:48:23 <dons> i usually alias: io :: IO a -> M a ; io = liftIO
23:48:36 <dons> then you tag io effects with 'io $ print "foo"'
23:48:38 <dons> and similar
23:48:48 <dons> check the xmonad source for examples
23:49:06 <Tac-Tics> It seems like there should be a way to be able to use IO in one function without propogating it to all the functions my game
23:49:21 <dons> breaks purity like crazy :)
23:49:22 <Tac-Tics> I found a number of examples and they seems pretty straightforward
23:49:27 <olsner> *billions* of lines of COBOL code... wow
23:49:30 <Tac-Tics> Is there a better way though?
23:49:32 <dons> you might want to ensure you have a pure model, and a wrapper io skin?
23:49:43 <dons> so most of the code is involved with manipulating purely functional data
23:49:57 <dons> and then there's a event handler/wrapper for taking events, modifying the model, and rendering back
23:50:02 <Tac-Tics> that's what I'm going for
23:50:06 <dons> cool.
23:50:14 <dons> so yeah, main = runM someeventhandler
23:50:18 <Tac-Tics> but this stateT thing is tempting me
23:50:21 <dons> the event handler just updates the pure model
23:50:23 <Tac-Tics> infinite power! the power of IO!
23:50:26 <Tac-Tics> is what it says
23:50:32 <dons> well, anything in StateT is going to be hard to QuickCheck..
23:50:46 <Tac-Tics> QuickCheck?
23:50:49 <dons> so be careful. or its just like programming in ML or something
23:50:55 <dons> for testing your game logic :)
23:50:57 <Tac-Tics> It just seems like StateT is very unHaskellesque
23:51:18 <dons> its just glue for passing your state as a parameter
23:51:30 <dons> so not really (but looks can be deceiving)
23:52:01 <Tac-Tics> yeah, but I expected it to have the ability to call functions with type "State GameEnv t"
23:52:14 <Tac-Tics> so that it gives a restricted access to IO
23:52:28 <Tac-Tics> and allows you to integrate it with existing state code
23:52:32 <dons> ah, i see. you want a IO layer, over a State layer, over a pure core
23:52:39 <Tac-Tics> yesm
23:52:46 <dons> so you separate statically the code that only updates the state, from that which can do any IO
23:53:00 <Tac-Tics> indeed
23:53:19 <Tac-Tics> so the GameEnv should be responsible for taking care of the updatates to the game object database
23:53:32 <Tac-Tics> and rendering and input to the game are handled in the mainloop
23:53:50 <Tac-Tics> so my mainLoop would have State-IO abilities
23:53:56 <Tac-Tics> or rather
23:54:00 <Tac-Tics> yeah
23:54:02 <dons> yeah, then it forks runState actions
23:54:06 <dons> which can only touch the state
23:54:06 <Tac-Tics> mainLoop = State+IO
23:54:15 <Tac-Tics> but updateGameLogic = just State
23:54:26 <Tac-Tics> ah
23:54:28 <dons> its a little unusual (i guess we just get lazy), but does make sense.
23:54:37 <dons> main = runStateT eventhandler
23:54:58 <dons> event (E x) = modify $ \s -> runState (e x) s
23:55:09 <wli> How do arrows relate to control?
23:55:15 <Tac-Tics> I do have access to the state don't I?
23:55:21 <dons> wli, they build up graphs of processes, rather than sequences
23:55:29 <dons> Tac-Tics: yeah. in StateT or State
23:55:54 <wli> dons: That could be handy if I could decipher it.
23:56:24 <dons> wli, instead of just: a >> b >> c
23:56:36 <dons> you can fork streams, loops, and other circuit-like pipes of data
23:56:55 <dons> i need 2-D ascii to draw it though :)
23:57:03 <Tac-Tics> actually the transformer lets me separate everything really nicely doesn't it? I can even make it so IO can't change the game state at all
23:57:08 <Tac-Tics> and run the IO separately
23:57:13 <dons> uncurry k . map (f && g) . group
23:57:20 <dons> f &&& g
23:57:23 <wli> dons: I won't figure it out from IRC; I'll have to do programming exercises involving them.
23:57:27 <dons> forks a two way stream of data in the middle there
23:57:32 <dons> wli, yep
23:57:52 <dons> Tac-Tics: yeah, that's the plan. you can fully specify which effects are available in which 'shell' of your program
23:58:04 <dons> so hopefully you can produce large portions of logic that are purely 100% functional, so very easy to get right
23:58:06 <Tac-Tics> Shell programming, eh?
23:58:22 <dons> inner and outer shells of effects
23:58:40 <wli> Layering effects.
23:58:57 <dons> Tac-Tics: like this: http://www.cse.unsw.edu.au/~dons/tmp/monad-stack-arch.png
23:59:10 <dons> that's the xmonad architecture, showing what effects are available at each layer
23:59:21 <lament> dons: if you realize you want to add another monad, is it easy?
23:59:32 <Tac-Tics> red = hot, don't burn yourself
23:59:42 <Tac-Tics> I think state should be like orange or pink or something
23:59:53 <Tac-Tics> but cool pic anyway ^^;
23:59:53 <dons> yeah, newtype T a = T (StateT IO a) --> newtype T a = T ( ReaderT (StateT IO)0 a
