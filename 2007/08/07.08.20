00:00:01 <lambdabot>  ["a","b","c"]
00:00:14 <glguy> > unfoldr (\b -> if null b then Nothing else Just (let (xs,ys) = break (=='/') b in (xs,drop 1 ys))) "a/b//c"
00:00:16 <lambdabot>  ["a","b","","c"]
00:01:59 <glguy> > unfoldr (\b -> guard(not $ null b) >> return (second (drop 1) (break (=='/') b))) "a/b//c"
00:02:01 <lambdabot>  ["a","b","","c"]
00:03:44 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just . second (drop 1) . break (=='/'))) "a/b//c"
00:03:45 <lambdabot>  ["a","b","","c"]
00:04:17 <glguy> > unfoldr(liftM2(>>)(guard.not.null)(Just .second(drop 1).break(=='/')))"a/b//c"
00:04:19 <lambdabot>  ["a","b","","c"]
00:04:22 <wli> sjanssen: What's going on with n = 3 there? Is that the board size?
00:04:22 <dolio> Clearly there ought to be 'f p g x = guard (not $ p x) >> return (g x)' somewhere in the standard libraries.
00:04:33 <sjanssen> wli: cell size
00:04:58 <sjanssen> wli: it's used to determine whether two coordinates are in the same box
00:05:14 <sjanssen> wli: would you like a description of the algorithm?
00:05:16 <glguy> paolino: didn't promise it'd be pretty
00:05:34 <wli> sjanssen: Yeah.
00:06:36 <sjanssen> search :: [(Coordinate, [Value])] -> [(Coordinate, Value)]
00:07:05 <sjanssen> the argument is the list of potential values that can fit in each square
00:07:46 <wli> okay
00:07:49 <glguy> in this case... unfoldr doesn't have much to offer since the explicit solution seems shorter and clearer...
00:07:53 <glguy> > let f "" = []; f xs = a : f (drop 1 b) where (a,b) = break (=='/') xs in f "a/b//c"
00:07:53 <sjanssen> at each step of 'search', we chose one of the potential values for the first coordinate in the list, and remove all coordinate, value pairs that conflict with that choice
00:07:54 <lambdabot>  ["a","b","","c"]
00:08:54 <sjanssen> eg. if we choose 3 for (0, 0), we know that 3 can't appear elsewhere in the first row or column, and it can't be in the upper left box
00:09:05 <wli> sjanssen: Sounds like a big fat list monad do { }
00:09:17 <sjanssen> wli: it is, essentially
00:09:24 <sjanssen> see the latest version of the paste
00:09:43 <wli> sjanssen: Yeah, I'm looking.
00:11:11 <dons> this is what happens,  http://blogs.msdn.com/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
00:11:12 <lambdabot> Title: LukeH's WebLog : Monadic Parser Combinators using C# 3.0, http://tinyurl.com/2srswy
00:11:52 <sjanssen> wli: does that illuminate things?
00:12:16 <sjanssen> 'add' is the procedure that prunes our search space
00:12:20 <wli> sjanssen: Yeah. The Int's for random crap kind of obfuscated it.
00:12:53 <sjanssen> it also sorts by the number of potential values in a square as an optimization
00:13:35 <wli> sjanssen: So what does the input to all this look like/
00:14:15 <hpaste>  sjanssen annotated "OCaml sudoku" with "with the emptyBoard" at http://hpaste.org/2348#a4
00:14:24 <sjanssen> wli: emptyBoard is one possible output
00:14:27 <sjanssen> s/output/input
00:15:42 <wli> okay, so that clears up more of how it works.
00:16:10 <sjanssen> 'search emptyBoard' produces all suduko solutions
00:16:13 <dolio> dons: So concise.
00:17:10 <dons> dolio: heh
00:17:43 <paolino> > (\p -> groupBy (const (not . p))) (=='/') "a/b/c"
00:17:45 <lambdabot>  ["a","/b","/c"]
00:17:53 <wli> I wonder how it would look as one huge do { }
00:18:19 <glguy> > (\p -> groupBy (const (not . p))) (=='/') "a/b//c"
00:18:20 <lambdabot>  ["a","/b","/","/c"]
00:18:46 <wli> I think it can be unraveled.
00:19:22 <paolino> @dict unraveled
00:19:23 <lambdabot> Supported dictionary-lookup commands:
00:19:23 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
00:19:23 <lambdabot> Use "dict-help [cmd...]" for more.
00:20:56 <sjanssen> wli: 'search' is really the only function that uses that sort of non-determinism
00:21:05 <glguy> Conclusion
00:21:06 <glguy> The little parser combinator framework here is very much a toy implementation.  It's horribly inefficient, doesn't do error reporting, and doesn't support any form of error recovery.  But it's a fun 150 lines of code!
00:21:18 <wli> sjanssen: add doesn't so much prune as it goes forward assuming that the chosen solution is the case.
00:21:48 <sjanssen> you might be able to simplify a bit by making select, invalid, add, etc. let bound variables in the do
00:22:19 <dolio> @remember JonHarrop Conversely, I find the practical problem of being unable to compare two values for equality in O(1) very disturbing...
00:22:19 <lambdabot> Done.
00:22:35 <sjanssen> dolio: reference?
00:22:43 <dolio> comp.lang.functional
00:23:35 <dons> glguy: so don't quit your day job yet to do C# monad hacking? :)
00:23:50 <glguy> dons: I quit my C# day job already to do Haskell hacking
00:24:01 <glguy> probably won't be going back
00:24:04 <dons> dolio: hah. typical JDH.
00:25:34 <dolio> Apparently he likes reallyUnsafePtrEquality.
00:25:41 <dolio> As does some Lisp guy.
00:25:42 <dolio> :)
00:25:56 <dons> dude, its fast!
00:26:14 <sjanssen> they just don't see the value of real purity
00:26:15 <Pseudonym> Hell, if you want a wrong answer, I can write a faster one.
00:26:16 <glguy> that's like saying "wait, you mean to tell me that Int has a maxbound??"
00:26:48 <glguy> its the sort of thing that you keep to yourself
00:26:58 <glguy> because you should have learned it years ago
00:27:31 <dolio> Of course, in OCaml, it's named ==, apparently.
00:27:36 <dolio> That's a little less scary.
00:27:46 <glguy> "it"?
00:27:53 <dolio> reallyUnsafePtrEquality
00:28:12 <glguy> what is the operator for actual equality
00:28:12 <sjanssen> there goes referential transparency
00:28:19 <dolio> =
00:28:35 <sjanssen> let x = foo in x == x -- True
00:28:39 <dons> :)
00:28:45 <sjanssen> foo == foo -- False
00:29:00 <sjanssen> where foo is some complicated (not shared) expression
00:29:01 <augustss> sjanssen: referential transparency is already gone in OCaml
00:29:54 <dons> i find that the hardest thing about reading ocaml : side effects dropped into the middle of an expression
00:30:09 <dons> and you have to step back and realise you have no idea now what the code is really doing
00:30:09 <glguy> dons: everyone likes easter eggs
00:30:31 <dons> glguy: they're a fun surprise!
00:30:33 <sieni> except perhaps customers
00:31:40 <sjanssen> augustss: I suppose you can't miss what you've never had ;)
00:32:06 <augustss> exactly
00:32:15 <opqdonut> :))
00:38:19 <sorear> C programmers break RT immediately.  O'Caml programmers do it after looking a few minutes for a better way.  Haskell programmers would rather jump off cliffs.
00:38:43 <opqdonut> ?remember sorear C programmers break RT immediately.  O'Caml programmers do it after looking a few minutes for a  better way.  Haskell programmers would rather jump off cliffs.
00:38:44 <lambdabot> Done.
00:38:55 <dons> sorear: you think the ocaml guy waits a few minutes? i've seen some surprising shootout code where they didn't hold back -- but it could just be the shootout.
00:39:09 <opqdonut> ?quote ocaml
00:39:10 <lambdabot> vincenz says: [Ocaml] used to be pretty, Haskell made it ugly
00:39:12 <dons> or say, the jdh soduku
00:39:13 <opqdonut> ?quote ocaml
00:39:13 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
00:39:26 <sorear> yeah, shooutout does bad things for style
00:39:26 <dons> qwe has so many fun ideas
00:40:04 <dons> sorear: yeah, basically you have to do exactly what the C or C++ version does usually, since they've already picked an optimal data structure and evaluation order
00:40:12 <opqdonut> the garbage collection isn't mandatory, you could just pass around a map with all the structures you use :)
00:40:17 <dons> there's some exceptions -- but the low level stuff is of that sort
00:41:36 <sorear> I would imagine that ICFP entries (regardless of language) are much more functional.
01:01:39 <reltuk> dons: like when qwe claimed polymorphic numeric constants didn't make any sense
01:03:23 <dons> oh, it was more zen than that. he claimed they didn't exist at all.
01:03:32 <dons> i still ponder that one in quiet moments.
01:05:40 <reltuk> I bet he's killer at a cocktail party
01:06:26 <njbartlett> About the RT thing... speaking as somebody who came from Java, I think it takes some time working with Haskell, getting pissed off that you can't have side effects, before you start to appreciate that it's actually a good thing
01:07:01 <dons> njbartlett: yeah, that seems reasonable.
01:07:15 <dons> the initial reaction is something near to disbelief, I've noticed :)
01:08:07 <iguana_> isn't Either a Monad?
01:08:13 <njbartlett> Yeah. And the next reaction is write everything in the IO monad
01:09:32 <dons> iguana_: yep.
01:10:01 <dons> ?src Either (>>=)
01:10:01 <lambdabot> Left  l >>= _ = Left l
01:10:01 <lambdabot> Right r >>= k = k r
01:11:03 <iguana_> hm, what does "No instance for (Monad (Either String))" tell me then?
01:11:31 <DRMacIver> Morning
01:12:44 <iguana_> (I want to use a StateT with an inner Either to pass errors)
01:14:49 <DRMacIver> iguana_: Hm. Maybe the monad instance is defined in some other module?
01:15:43 <doserj> Control.Monad.Error
01:16:28 <iguana_> ahhh
01:16:31 <iguana_> thanks!
01:17:44 <iguana_> hm, looking at Control.Monad.Error, I should probably be using ErrorT, shouldn't I?
01:19:42 <njbartlett> Maybe you want Control.Monad.Error.Class. It has this instance declaration:
01:19:57 <njbartlett> Error e => MonadError e (Either e)
01:20:19 <njbartlett> And String is an instance of Error
01:23:45 <psykotic> @info Error
01:23:46 <lambdabot> (Error)
01:23:51 <opqdonut> :D
01:48:46 <laz0r> is it possible to have multiple patterns in lambda notation?
01:50:18 <laz0r> map (\[] -> "*") [[],"a","b"] would not work because of the non-exhaustive pattern
01:50:47 <opqdonut> no
01:50:49 <doserj> map (\x -> case x of ...)
01:50:54 <opqdonut> you have to use \x -> case
01:50:57 <opqdonut> damn, too slow
01:51:00 <doserj> :)
01:51:15 <laz0r> ah, thanks
01:55:11 * osfameron looks at hints to Euler 18 and cries
02:01:42 <TSC> Isn't Euler problem 18 a straight
02:01:52 <TSC> ...-forward dynamic programming problem?
02:04:38 <osfameron> TSC: er... I guess dynamic programming problems are easy if you understand them?
02:04:55 <the_dormant> TSC: you can discard computed values in each step, so it's not necessary a dynamic programming kind of problem
02:05:40 <osfameron> I was just keeping a list of "this is my position and this is my sum" and then exponentially multiplying the size of my data structure...
02:06:03 <osfameron> which worked very well for the 4 row problem, but makes my laptop unhappy for the real question
02:07:51 <osfameron> can you necessarily discard computed values?  A low-scoring path at the top might lead to a higher scoring path below
02:08:41 <the_dormant> just go from the bottom
02:08:53 <sorear> trying to figure out a response to C.Maeder that won't start a flamewar, but the best I can come up with is "The road to perl is paved with "improvements" like this."  But it just feels so wrong to ignore a directly addressed message...
02:09:25 <doserj> osfameron: a naive recursive versions gives the result immediately in ghci for me
02:09:44 <popcount> How can I rewrite this s.t. it becomes lazy? \z -> filterM (\e-> liftM2 (>=) (bar e z) (bar e z)) list
02:09:59 <popcount> How can I rewrite this s.t. it becomes lazy? \z -> filterM (\e-> liftM2 (>=) (foobar e z) (bar e z)) list *
02:10:23 <gebb> osfameron: You don't need the path. Just the sum.
02:10:31 <sorear> popcount: You don't need to.  Just use a lazy monad.
02:10:41 <sorear> (or ideally none at all)
02:11:27 <osfameron> gebb: I suppose. I thought it would be useful to double check the results
02:11:46 <osfameron> doserj: oh, well, I was probably overcomplicating things due to having no idea how to write this in haskell
02:11:55 <the_dormant> gebb: it isn't that hard to keep the path too
02:12:25 <kral> ahoy
02:13:36 <osfameron> of course, I say "overcomplicated" but it's still only about 8 lines of code...  maybe I just underthought it
02:18:31 <fasta> I have a macro ASSERTM, which expands when DEBUG = 1. I call GHC as: ghc -cpp  -DDEBUG=0 <more options>. In the profile, the operation inside the ASSERTM still shows up. What am I doing wrong?
02:22:56 <sorear> using #ifdef maybe?
02:25:11 <fasta> *** Deleting temp files: ... I am interested in those temp files. How can I see them?
02:25:42 <sorear> Yes.
02:25:52 <fasta> -keep-tmp-files
02:26:03 <steven_ashley> well done
02:26:16 <fasta> GHC's manpage seemed to have improved.
02:26:43 <sorear> fasta: Even if it hadn't, this information has been in the HTML manual for as long as I can remember
02:27:09 <fasta> sorear: yes, but the HTML manual is not searchable
02:27:16 <sorear> fasta: Obviously, it's going to be a flag.  Scroll down to Flag Reference.  Oh look, 4.17.5. Keeping intermediate files
02:27:22 <sorear> ?!
02:27:22 <lambdabot> Maybe you meant: . v
02:28:06 <sorear> in MY browser of choice, / foo <RET> works.
02:28:15 <osfameron> doserj: OK!  got that working with a recursive solution
02:28:22 <sorear> I'm pretty sure FF and IE have it too.
02:28:26 <fasta> sorear: you have the one page version?
02:28:57 <sorear> No, but almost all questions can be answered using the TOC>
02:29:14 <fasta> sorear: most, yes. Let's stop this silly discussion.
02:29:34 <xerox> ?go Keeping intermediate files site:haskell.org/ghc/docs/latest/html/users_guide
02:29:36 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
02:29:36 <lambdabot> Title: 4.6. Filenames and separate compilation
02:30:40 <fasta> The "current" user guide or libraries are often broken.
02:30:53 <fasta> The only way to get the newest documentation is to build it yourself.
02:31:11 <fasta> (which was broken two days ago)
02:32:03 <osfameron> ah!  perhaps using !! to index in my first solution was a bad idea, as indexing on a list is O(n) rather than O(1) on an array
02:33:26 <doserj> osfameron: the index is quite small, so it shouldn't make much difference (I'm using !!)
02:34:02 <osfameron> doserj: oh!  well, $deity knows then.  I did get the hint to use "tail" from the wiki hints, but I'm doing it recursively for now
02:48:27 <dozer> is there interest in yet another suduko solver?
02:49:47 <roconnor> dozer: always
02:49:57 <popcount> dozer, one that works  parallel and is faster than any sequential C version.
02:49:57 <roconnor> @wki Suduko
02:49:58 <lambdabot> http://www.haskell.org/haskellwiki/Suduko
02:50:12 <roconnor> hmm
02:50:21 <roconnor> I wish @wiki was a bit more intellegent
02:50:21 <dozer> ouch - that's all blank now
02:50:39 <laz0r> @wki Sudoku
02:50:39 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
03:28:17 <osfameron> is it possible to do alternatives in a case statement?
03:28:24 <osfameron> like:  1,2,3 -> whatever;
03:28:42 <wli> What do you mean?
03:28:47 <wli> Pattern guards?
03:28:50 <Eelis>  x | x `elem` [1,2,3] -> whatever;
03:28:57 <wli> Yes, you can do pattern guards in a case statement.
03:29:01 <popcount> osfameron, no
03:29:09 <osfameron> ah, you use elem, ok
03:29:15 <osfameron> thanks :-)
03:29:20 <EvilTerran> wli, those are not pattern guards... those are just guards
03:29:42 <wli> I'm not convinced there's a distinction.
03:29:43 <Igloo> Or you can bind whatever in a where clause and use 3 case branches
03:29:52 <popcount> Pattern guards are p1, p2 = ... IIRC
03:29:53 <EvilTerran> a pattern guard would be x | Just y <- blah x -> ...
03:30:15 <EvilTerran> the guard BOOLEXP is the same as the pattern guard True <- BOOLEXP
03:34:28 <MyCatVerbs> What's guard used for, anyhoo? I'm not sure I understand it at all.
03:40:35 <dmwit> MyCatVerbs: I usually use guards to eliminate long if/then/else chains.
03:41:08 <popcount> dmwit, do you have an example of that?
03:41:28 <dmwit> not handy
03:42:31 <matt__r> MyCatVerbs: Guards also help when you need to choose between alternives based on values, not patterns
03:42:47 <matt__r> MyCatVerbs: lets see if I can come up with a good example.....
03:43:03 <MyCatVerbs> dmwit: ahh, ookie.
03:43:13 * MyCatVerbs <3 this room. You people are all just wonderful.
03:45:52 <hpaste>  mattr pasted "use for guards" at http://hpaste.org/2349
03:46:30 <matt__r> Check the example - without the guards, we would need to code the failure into each example
03:46:33 <Eelis> not the best of examples, because   theSame (LChar c) (LChar c') = c == c'
03:47:11 <matt__r> yeah - I know,
03:47:18 <matt__r> but I needed a short one
03:47:20 <matt__r> :)
03:47:51 <matt__r> any example sufficiently short for use as an explanation can be done trivially in haskell anyway :)
03:48:23 <popcount> matt__r, those are Haskell 98 guards
03:48:23 <iguana_> @pl \(k, v) -> show k ++ ":" ++ show v
03:48:23 <lambdabot> uncurry ((. ((':' :) . show)) . (++) . show)
03:48:31 <iguana_> hmmm ;)
03:48:52 <popcount> matt__r, I was interested in the non-Haskell 98 guards.
03:49:17 <Japsu> bah
03:49:23 <Japsu> data Lit = ... deriving (Eq)
03:49:30 <matt__r> ahhh - well the answer to that is "the example they used in the paper where they described them"
03:49:58 <wli> popcount: I use non-H98 guards all the time.
03:50:32 <popcount> Papers rarely contain good examples
03:50:38 <wli> http://hpaste.org/2337 <-- one case where I used them
03:51:20 <matt__r> popcount: I know that sounds flippant, but it is how I gained entry to other haskell extensions and *began* realising where they would be useful.  Like GADTs.  At first I could only just see why you would want them for an expression language, now I see them popping up all the time. However, if I went straight to other examples at the start, I was totally bemused.
03:52:04 <matt__r> its an exodus...
03:52:05 <wli> I don't understand GADT's yet.
03:52:14 <wli> matt__r: An exodus?
03:52:40 <matt__r> I just saw about 100 ** left the room messages
03:52:45 <matt__r> now they are all back :)
03:52:50 <matt__r> server glitch I guess
03:53:44 <osfameron> irssi++ # pretty netsplit info
03:54:31 <wli> I've got all that crap ignored (literally called "crap" by irciII-EPIC4 as a /ignore pattern).
03:54:32 <matt__r> wli: shall I give you the short and innacurate - but still enlightening version?
03:54:51 <matt__r> wli: of GADTs I mean
03:55:00 <MyCatVerbs> matt__r: ohhh, crap, sorry, wrong concept.
03:55:14 <wli> matt__r: Go for it.
03:55:35 <MyCatVerbs> matt__r: I was actually after a use for the "guard" function in Control.Monad. >_>
03:55:41 <MyCatVerbs> :t guard
03:55:43 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:56:13 <matt__r> wli: use GADTs when you want one of your constructors to have a more specific version of the full datatype's type
03:56:36 <MyCatVerbs> (func; | pred = expr; | pred2 = expr2... seems straightforwardly useful for terseness, to me)
03:56:37 <matt__r> you typically use this to add extra or tighter type contraints to some part of your program.
03:59:12 <wli> Now to develop the intuition of when it makes sense to use them.
04:05:47 <matt__r> wli: probably not as often as you might think :)
04:08:39 <wli> I've got TH and arrows to learn, too.
04:09:49 <matt__r> wli: just be sure you don't learn things you won't need.  I spent way too much of my PhD time learning new and exciting haskell extensions and then having no use for them :)
04:09:57 <matt__r> its fun, but I have work to do!
04:11:53 <wli> matt__r: Well, the whole reason I'm on about this is pedagogical, to "brush up" or "complete" learning from college, so...
04:12:05 <dons> ?users
04:12:05 <lambdabot> Maximum users seen in #haskell: 395, currently: 380 (96.2%), active: 11 (2.9%)
04:12:24 <matt__r> wli: aha - have fun then!
04:13:35 <wli> Well, there are plans within plans, but that's one of them.
04:14:59 <dmwit> MyCatVerbs: Oh!  That's a different story.
04:15:03 <dmwit> :t guard
04:15:12 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:16:15 <dmwit> > do { x <- [0..20]; guard (odd x); return x }
04:16:16 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
04:16:28 <dmwit> (Bad example, I know.)
04:16:38 <dmwit> ?instances MonadPlus
04:16:39 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
04:17:35 <dmwit> Monad comprehensions would desugar to use guard.
04:22:55 <tuxplorer> matt__r: it was a netsplit
04:23:22 <matt__r> tuxplorer: ??
04:23:41 <tuxplorer> http://en.wikipedia.org/wiki/Netsplit
04:23:42 <lambdabot> Title: Netsplit - Wikipedia, the free encyclopedia
04:25:10 <matt__r> tuxplorer: ahh - thanks
04:25:43 <MyCatVerbs> dmwit: no, good example! Thank you.
04:26:48 <MyCatVerbs> > [0..20] >>= (guard . odd)
04:26:50 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
04:26:58 <opqdonut> :))
04:27:04 <MyCatVerbs> ...methinks I did something vewwy vewwy wrong there.
04:27:15 <opqdonut> ?t guard
04:27:15 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
04:27:17 <wli> > [0..20] >>= (guard . odd >> return)
04:27:17 <lambdabot>  Add a type signature
04:27:19 <MyCatVerbs> > [0..20] >>= (\x->(guard . odd) >> return x)
04:27:20 <lambdabot>  Couldn't match expected type `[]' against inferred type `(->) a'
04:27:21 <opqdonut> :t guard
04:27:23 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:27:31 <wli> > [0..20] >>= (guard . odd . (>> return))
04:27:31 <opqdonut> see, m()
04:27:32 <lambdabot>   add an instance declaration for (Integral (a -> m a))
04:27:39 <MyCatVerbs> > [0..20] >>= (\x->(guard . odd $ x) >> return x)
04:27:42 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
04:27:45 <opqdonut> yeah
04:27:50 <EvilTerran> > [0..20] >>= liftM2 (>>) (guard . odd) return
04:27:50 <opqdonut> guard doesn't return the value
04:27:51 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
04:28:10 * EvilTerran mixes his monads
04:28:14 <MyCatVerbs> > { x <- [0..20]; True <- odd x; return x; }
04:28:15 <lambdabot>  Parse error
04:28:28 <opqdonut> do
04:28:32 <MyCatVerbs> > do { x <- [0..20]; True <- odd x; return x; }
04:28:32 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
04:28:36 <opqdonut> :)
04:28:40 <MyCatVerbs> > do { x <- [0..20]; True <- (odd x); return x; }
04:28:41 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
04:28:55 <MyCatVerbs> > do { x <- [0..20]; [True] <- (odd x); return x; }
04:28:55 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
04:29:03 <opqdonut> try let True = odd x
04:29:06 <opqdonut> or something
04:29:12 <opqdonut> or <- [odd x]
04:29:18 <wli> argh
04:29:19 <MyCatVerbs> > do { x <- [0..20]; <- [odd x]; return x; }
04:29:19 <lambdabot>  Parse error
04:29:24 <opqdonut> :)
04:29:29 <EvilTerran> (i think that liftM2 is in (e->), and the (>>)s are in list)
04:29:32 <tuxplorer> matt__r: ?
04:29:32 <MyCatVerbs> > do { x <- [0..20]; True <- [odd x]; return x; }
04:29:33 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
04:29:37 <opqdonut> EvilTerran: yeah
04:29:43 <tuxplorer> matt__r: :) welcome
04:29:43 <EvilTerran> @src (->)(>>=)
04:29:43 <lambdabot> Source not found. You speak an infinite deal of nothing
04:29:46 <EvilTerran> @src (->) (>>=)
04:29:46 <lambdabot> f >>= k = \ r -> k (f r) r
04:29:48 <MyCatVerbs> opqdonut: danke.
04:29:52 <doserj> > do { x <- [0..20]; guard (odd x); return x; }
04:29:54 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
04:29:55 <matt__r> tuxplorer: hello
04:30:13 * EvilTerran likes reader's liftM2 for pointsfreeing stuff.
04:30:15 <MyCatVerbs> @src (>>)
04:30:15 <lambdabot> m >> k      = m >>= \_ -> k
04:31:01 <EvilTerran> liftM2 f g h x = f (g x) (h x), i believer
04:31:05 <EvilTerran> -r
04:31:25 <wli> Well, I think I'm getting pretty good with monads, if nothing else.
04:32:53 <tuxplorer> matt__r: hi!
04:40:54 <EvilTerran> re, main server et al
04:41:13 <opqdonut> :)
04:45:52 <EvilTerran> ...does SYB do something that does the same job "deriving Functor", say, would do?
04:46:38 <EvilTerran> (instance Typeable1 t => Functor t where...?)
04:53:48 --- mode: irc.freenode.net set +o ChanServ
04:56:28 <Choko> @src foldl
04:56:29 <lambdabot> foldl f z xs = lgo z xs
04:56:29 <lambdabot>     where lgo z []     =  z
04:56:29 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
04:56:47 <EvilTerran> that's horrible!
04:57:10 <doserj> "@src" should really show the report definition :)
04:57:14 <wli> I can't imagine what that manual program transformation is for.
04:57:28 <opqdonut> mhmm
04:57:38 <EvilTerran> foldl f z [] = z; foldl f z (x:xs) = foldl f (f z x) xs; iirc.
04:58:14 <doserj> it is supposed to help the ghc optimiser (builder/consumer framework, i think)
04:58:22 <opqdonut> yeah
04:58:32 <EvilTerran> i agree with the sentiment that it should be the prelude definition
04:58:40 <EvilTerran> *report prelude
04:58:45 <opqdonut> doserj: that's how dons or somebody explained it here
04:58:47 <popcount> But the prelude is wrong in some cases
04:58:47 <wli> I guess it's something of a stopgap measure until the optimizer can do that for itself.
04:59:16 <araujo> morning
04:59:24 <opqdonut> morn
04:59:27 <EvilTerran> @src fold
04:59:28 <lambdabot> Source not found. Wrong!  You cheating scum!
04:59:29 <EvilTerran> @src foldr
04:59:29 <lambdabot> foldr k z xs = go xs
04:59:30 <lambdabot>     where go []     = z
04:59:30 <lambdabot>           go (y:ys) = y `k` go ys
05:04:10 <EvilTerran> ah, it would appear what i was looking for was gmapT . mkT
05:13:49 <popcount> If I have a function which only modifies one thing in a state monad, will that be inlined automatically?
05:14:32 <Lemmih> popcount: Yes.
05:14:54 <Lemmih> popcount: If your Haskell compiler feels like it.
05:15:49 <opqdonut> good answer :D
05:17:38 <wli> y=3^(1/2)*x is very very close to the curve 3*x^2-y^2=n
05:18:38 <popcount>  ./Main+RTS -K200M -p -xc -RTS shouldn't this make a Main.hp file when compiled with -prof -auto-all?
05:18:44 <popcount> +space
05:19:22 <DRMacIver> The monadic parser combinators for C# look really awful. :)
05:21:27 <Lemmih> popcount: I think you need -hc or something.
05:21:46 <Liskni_si> where is the definition of instance Functor ((,) a) ?
05:22:09 <opqdonut> ?index Functor ((,) a)
05:22:09 <lambdabot> bzzt
05:22:11 <opqdonut> bah
05:22:21 <popcount> Lemmih, thanks, I disabled that by accident
05:22:24 <opqdonut> i'g guess Control.Monad.Instances
05:23:16 <Liskni_si> opqdonut: that's it, thanks
05:23:31 <opqdonut> that's where all the funky instances are
05:24:36 <doserj> *all* is a bit exaggerated. It has only 4 instances (and only 1 Monad instance, acutally...)
05:24:52 <wli> I can bound it between 3^(1/2)*x >= y >= 3^(1/2)*x-n^(1/2) and x >= (n/3)^(1/2)
05:25:03 <doserj> but they are the funky ones, yes :)
05:26:20 <wli> As well as y <= x - 1
05:30:21 <popcount> If I do l <- expensive; l' <- expensive2; return () in the ST monad and l and l' are not used anywhere, and expensive does no writes, will the run-time cost be close to zero?
05:30:49 <wli> The active constraints seem to be x-1 >= y >= 3^(1/2)*x-n^(1/2) and x >= (n/3)^(1/2)
05:31:46 <wli> It looks like a big fat triangular wedge.
05:31:52 <ddarius> worker/wrapper
05:33:00 <ddarius> popcount: Where is the prelude wrong?
05:33:22 <wli> x <= (n^(1/2)-1)/(3^(1/2)-1) from the intersection point of the triangle, but one can do better when 0 <= x-1-(3^(1/2)*x-n^(1/2)) <= 1
05:34:03 <ddarius> Be sure to give it lots of coffee before hand.
05:34:12 <popcount> ddarius, various lazy behaviours are not desirable. If you take the position that the prelude is the definition and therefor is correct, you would be right, of course.
05:34:18 <wli> It's just x <= (n^(1/2)-2)/(3^(1/2)-1)
05:35:07 <ddarius> C# has monadic parser combinators?
05:35:49 <Cale> fail is in Monad. I'd say that's a bug :)
05:36:24 <doserj> Functor is not a superclass of Monad (also a but :)
05:36:27 <doserj> *bug
05:36:28 <popcount> Cale, and where should the pattern match goes wrong semantics go then?
05:36:34 <Cale> popcount: MonadZero
05:36:42 <Cale> popcount: Just like in Haskell 1.4
05:37:14 <doserj> Eq, Show are superclasses of Num...
05:37:18 <Cale> If you attempt a possibly failing pattern match, you get a MonadZero constraint, because the translation uses mzero
05:37:47 <doserj> Cale: it should still use fail:: String -> m a
05:38:02 <doserj> with default implementation fail _ = mzero
05:38:08 <Cale> doserj: Sure if you want to add that to the MonadZero class.
05:38:10 <EvilTerran> nothing stopping that being a method of MonadZero
05:38:18 <doserj> yep
05:38:32 <Cale> Oh, and the associativity of ($) is wrong
05:38:40 <Cale> That's a rather big one :)
05:41:26 <doserj> (and foldl shouldn#t be in the prelude *cough*)
05:41:39 <opqdonut> :D how so?
05:41:48 <Cale> Nah, it should, it's just that foldl' should perhaps be as well.
05:42:07 <fasta> Are there some inherent inefficiencies in using lots of STRefs?
05:42:18 <fasta> Lots is "thousands"
05:43:08 <ddarius> fasta: No.
05:43:32 <fasta> I implemented a doubly linked list, but it spends all the time in that thing. I think I disabled all the debugging code already.
05:43:42 <Cale> Then there's the exception system and the difference between Prelude.catch and Control.Exception.catch
05:43:47 <fasta> AFAIK, everything should be constant time operations.
05:44:03 <opqdonut> well constant time doesn't tell much :)
05:44:17 <fasta> opqdonut: how complicated can a doubly linked list be...
05:44:45 <fasta> I think I will just try to make a million element list and see what happens.
05:46:35 <fasta> mapM <newtype constructor> is a nop, right?
05:46:52 <opqdonut> huh?
05:46:54 <popcount> er map
05:47:16 <opqdonut> don't know how well the compiler optimizes it
05:47:25 <ddarius> fasta: Possibly, but unlikely.  It will most likely recreate the list, but maybe not.
05:47:26 <fasta> popcount: Yes, you are right, map.
05:47:29 <ddarius> Check the core.
05:47:53 <popcount> :)
05:48:06 <DRMacIver> You presumably could define a rewrite rule to change map <newtype constructor> into unsafeCoerce. :)
05:48:10 <ddarius> I imagine there is some optimization that makes map id go away and a newtype constructor shouldn't get in the way but...
05:49:08 <fasta> This is the best format -ddump-prep?
05:49:44 <Saizan> -ddump-simpl i think
05:50:09 <fasta> (and where does it dump it?)
05:50:49 <Saizan> (stdout iirc)
05:51:10 <roconnor> http://www.haskell.org/haskellwiki/Performance/GHC#Core_by_example
05:51:12 <lambdabot> Title: Performance/GHC - HaskellWiki, http://tinyurl.com/yduwfl
05:51:34 <fasta> Right, stdout...
05:53:06 <fasta> Heh, it doesn't fit on my terminal.
05:53:46 <roconnor> Simon Peyton-Jones says: GHC doesn't do full CSE.
05:53:49 <roconnor> :(
05:53:53 <roconnor> :'(
05:54:02 <roconnor> WTF?
05:54:14 <roconnor> :@
05:54:28 <xerox> Right. You ought to name things explicitly to enable sharing.
05:54:49 <ddarius> roconnor: Doing full CSE is a bad thing.
05:55:07 <roconnor> Yeah, but doing CSE hand makes programs hard to read.
05:55:07 <ibid> roconnor: iirc full CSE creates memory leaks
05:55:21 <roconnor> and makes my code look like OCaml
05:55:25 <ddarius> roconnor: Harder to read ... or exponential memory leaks...
05:55:30 <ibid> roconnor: so you need to apply judgment in when to do it
05:55:55 <roconnor> I was promised the compiler would be smart enought to make these decisions.
05:56:32 <ddarius> let powerset [] = [[]]; powerset (x:xs) = powerset xs ++ map (x:) (powerset xs) -- good
05:56:34 <ibid> to make the tradeoff between speed and memory? the problem is, the compiler cannot read you mind
05:56:42 <ibid> *your
05:56:58 <roconnor> I knew it was all lies
05:56:58 <ddarius> let powerset [] = [[]]; powerset (x:xs) = xss ++ map (x:) xss where xss = powerset xs -- bad
05:57:07 <roconnor> I'm going to program in ocaml.
05:57:08 <fasta> () !k !n !alt !a1 !a2 !a3 !a4 !a5 !a6 !a7 !a8 !a9 !False <- how can this work? Since when is () a function?
05:57:26 <ari> Is there a way to explicitly name things without causing sharing, btw? I'm interested because I was bitten by naming [minBound..maxBound] once...
05:57:51 <ddarius> ari: You could add a () argument.
05:58:06 <roconnor> ibid: we already know how to make that trade off.  Got with speed, and screw memory.
05:58:07 <EvilTerran> > filterM (const [False,True]) "abcd" -- better, ddarius? ;]
05:58:08 <dons> fasta: that looks out of context -- and weird
05:58:09 <lambdabot>  ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","a...
05:58:11 <ddarius> Also if it's polymorphic it already won't be shared.
05:58:18 <roconnor> ibid: if there is a memory leak, fix it with annotations.
05:58:48 <ibid> roconnor: so that's why gtk2hs wouldn't install on my old laptop, screw the installation causing trashing
05:59:06 <ibid> roconnor: the annotation is, do you name it or not :)
05:59:11 <ddarius> roconnor: There is a special relativity in program execution where space and time are intermingled.
06:00:09 <ddarius> The "good" definition of powerset recalculates powerset xs the "bad" definition does not but takes a combinatorially large amount of memory which is going to destroy performance.
06:00:16 <ibid> roconnor: sometimes going for more memory causes a performance loss which is not comparable to the intended performance gain (if the working set exceeds main memory size)
06:00:26 <roconnor> ibid: but the default is backwards. Do CSE unless I tell it not to.
06:00:42 <roconnor> ibid: most of the time CSE is safe I assume.
06:01:12 <|Jedai|> @src List
06:01:12 <lambdabot> Source not found. Wrong!  You cheating scum!
06:01:19 <fasta> I never heard of bigForth before: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=bigforth&lang2=ghc
06:01:20 <|Jedai|> @src length
06:01:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:01:22 <lambdabot> Title: Forth bigForth benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer L ..., http://tinyurl.com/2ua2y9
06:01:28 <Saizan> @source Data.List
06:01:28 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:01:55 <fasta> dons: http://www.haskell.org/haskellwiki/Performance/GHC#Core_by_example
06:01:56 <ibid> roconnor: the problem is, without CSE you can predict the memory usage better. with CSE, you can't apply the laziness assumption to reason for memory consumption
06:01:58 <lambdabot> Title: Performance/GHC - HaskellWiki, http://tinyurl.com/yduwfl
06:02:30 <roconnor> ibid: not doing CSE is like saying that we should work in a strict language and just use lambdas to simulate laziness when you need it.
06:03:00 <ddarius> I'd rather the source do what I'm telling it to do.
06:03:07 <ibid> roconnor: no, it's not
06:03:22 <ibid> roconnor: CSE is a problem precisely because we work with a lazy language
06:03:47 <roconnor> roconnor: but CSE is only possible in pure langauges.
06:04:02 <roconnor> ugh
06:04:08 <roconnor> ibid: but CSE is only possible in pure langauges.
06:04:14 * roconnor is still talking to himself.
06:04:25 <DRMacIver> CSE is possible in almost every language. You just need to guarantee that the particular expression has no side effects when evaluated.
06:04:42 <DRMacIver> It's not like C compilers haven't been doing CSE for years. :)
06:04:58 <roconnor> DRMacIver: sure, in little tiny cases.
06:05:02 <fasta> How am I supposed to see the "core" when it's still running?
06:05:03 <ibid> roconnor: purity and laziness are separate issues
06:05:09 * DRMacIver shrugs
06:05:14 <fasta> It keep spitting out code.
06:05:32 <ddarius> fasta: Pipe it to a file.
06:05:58 <roconnor> Now I have to go give every common expression it's own fucking name.
06:06:02 <ibid> roconnor: optimization should be _opti_mization, not pessimization
06:06:03 <roconnor> god damn it.
06:06:27 <ibid> not every one of them
06:06:33 <ibid> the compiler does do some CSE
06:06:33 <fasta> ddarius: it's more than a MB of output already
06:06:41 <ibid> basically when it can prove it's safe
06:06:50 <roconnor> Instead GHC does "opportunistic CSE".  If you have
06:06:50 <roconnor>         let x = e in .... let y = e in ....
06:06:50 <roconnor> then it'll discard the duplicate binding. But that's very weak.
06:06:55 <fasta> ddarius: 2,6M now
06:07:03 <roconnor> ibid: is that the extend of CSE?
06:07:12 <ddarius> fasta: What the heck are you doing?
06:07:24 <ibid> roconnor: well, i haven't studied the ghc optimizer recently :)
06:07:40 <fasta> ddarius: I gave that dump flag to my main project build command.
06:07:51 <fasta> ddarius: it are about 70-80 modules.
06:08:10 <fasta> ddarius: nothing terribly odd, right?
06:08:11 <ddarius> Don't you just want to dump the result of one of them?
06:08:19 <roconnor> ibid: the optimizer does all sorts of things that can make execuction worse.
06:08:44 <fasta> ddarius: I am not sure which one is the problem.
06:08:54 <fasta> ddarius: 8,2M already...
06:09:03 <ibid> roconnor: in some special cases, perhaps. generally it tries to avoid that sort of things
06:09:13 <roconnor> Is CSE that bad?
06:09:24 <roconnor> that it doesn't even qualify?
06:09:57 <ddarius> fasta: ?  I thought you just wanted to see if the map NewTypeConstructor was taken out.  "Dumping the core" just dumps the intermediate language of your code.
06:10:23 <ddarius> roconnor: Exponential space consumption isn't that bad?
06:10:39 <roconnor> ddarius: but how common is that.
06:10:51 <fasta> ddarius: well, I didn't want to see only that.
06:10:54 <ibid> roconnor: yes, it can bite hard and often (full CSE, that is)
06:10:54 <roconnor> ddarius: I mean the inliner can go into an infinite loop, that's far wrose.
06:11:33 <roconnor> *sigh*
06:11:45 <ddarius> roconnor: The inliner going into a loop doesn't lead to me having slow programs.
06:11:55 <roconnor> ddarius: it leads you to having no programs.
06:12:31 <fasta> The compiler could say: warning not applying full cse opportunity here and there (like SBCL does)
06:12:34 <DRMacIver> Why is this really a big problem? Do you really get that many hard to compute common subexpressions which you want eliminated?
06:12:41 <ddarius> And CSE doesn't often cause exponentially bad space-usage (simply because people don't often make code that generates exponential amounts of stuff) but it does often cause space-leaks.
06:13:23 <ddarius> Why not have it say: warning full cse opportunity taken here.
06:13:27 <diakopter> I'm having trouble building lambdabot on debian sid (ghc 6.6.1).
06:13:30 <fasta> What does an @ mean in core output?
06:13:37 <fasta> The Core format is not documented, is it?
06:13:39 <rhz> Haskell Equational Reasoning Assistant. Where is this?
06:13:53 <ddarius> The compiler shouldn't be warning you about compiling your code as written.
06:13:56 <roconnor> DRMacIver: I want to write clear code, and that sometimes means writing common subexpressions.  I expected the compiler to remove them for me.
06:14:22 <wli> I've got a Frankenstein Debian due to lots of packages from unstable atop normal stable.
06:14:31 <roconnor> fasta: I think @ has something to do with type variable parameters.
06:15:38 <diakopter> re: lambdabot - Setup.hs can't find haskell-src-any
06:17:24 <diakopter> anyone have any tips?
06:17:39 <fasta> roconnor: dictionary passing?
06:17:57 <roconnor> fasta: could be.
06:18:41 <fasta> diakopter: lambdabot is not designed s.t. other people can compile it.
06:18:52 <fasta> diakopter: it's natural that it's hard to install
06:19:30 <diakopter> fasta: ok... I want to set up an instance to run on the magnet network
06:20:14 <diakopter> fasta: I wasn't complaining, btw... no need to justify why it doesn't work with every single system/setup :P
06:20:23 <cognominal__> are Simon Peyton jones and Mark P. Jones from the same family? just curious...
06:20:30 <wli> No.
06:21:20 <fasta> Was the single origin theory solved while I was away? ;)
06:21:20 <cognominal__> the first is English and the second American apparently
06:22:46 <mudge> anyone here?
06:23:13 <mudge> its empty at 6:20 in the morning
06:23:15 <rhz> no
06:23:20 <mudge> ok
06:23:27 <mudge> i wonder where haskellers are from
06:23:32 <evir> It's not 6:20 everywhere. :-)
06:23:33 <wli> I'm here.
06:23:36 <opqdonut> it's 16:20 here
06:23:39 <earthy> 15:22
06:23:41 <roconnor> @losers
06:23:41 <lambdabot> Maximum users seen in #haskell: 395, currently: 385 (97.5%), active: 23 (6.0%)
06:23:43 <evir> 15:22.
06:23:45 <opqdonut> channel was quite active until just a minut ago
06:23:45 <wli> It's 6:20 in PDX.
06:23:54 <earthy> that's weird
06:23:58 <earthy> must be 2 minutes off. :P
06:23:59 <mudge> oh
06:24:20 <diakopter> fasta: and I can't install http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-1.0 because I don't have/want an X server running...
06:24:23 <lambdabot> http://tinyurl.com/3yxn4n
06:24:41 <fasta> diakopter: why does it require X?
06:24:50 <diakopter> fasta: I don't know...
06:25:01 <fasta> diakopter: are there no dummy x servers?
06:25:01 <diakopter> I was hoping someone here could tell me
06:25:15 <fasta> diakopter: like /dev/null for sound drivers
06:25:33 <mudge> i was wondering,  how long do you have to study and write haskell until you're no longer a newbie?
06:25:50 <Syzygy-> mudge: Some say that you end being a newbie with the first own monad tutorial you write. ;)
06:26:19 * mrd is still a newbie
06:26:31 <roconnor> I'd guess about 3 years
06:26:33 <mudge> Syzygy: ah, well I'm on my way then, as I've already wrote a Currying tutorial: http://www.nickmudge.info/?post=42
06:26:36 <lambdabot> Title: Explanation of Haskell Currying
06:26:57 <mudge> but haven't even really begun to start studying monads
06:27:03 <Syzygy-> mudge: Currying - the programmatic version of the isomorphism Hom(AxB,C) -~-> Hom(A,Hom(B,C))
06:27:04 <desegnis> mudge, depends on for whom you do not want to be a newbie. A PhD with a Haskell-related thesis topic will probably do in most cases, though
06:27:07 <Syzygy-> :)
06:27:08 <mudge> ah 3 years
06:27:19 <fasta> Getting the first element of a tail recursive list generating function is bound to be slow, right? :)
06:27:27 <Syzygy-> desegnis: I'm wondering whether my thesis topic qualifies for that.
06:27:52 <hpaste>  diakopter pasted "(no title)" at http://hpaste.org/2350
06:27:56 <desegnis> Syzygy, the topic being?
06:28:26 <mudge> I don't go to college so a PhD in Haskell related thesis topic won't happen I don't think,   unless you don't have to go to college to get PhD
06:28:46 <mrd> honorary doctorate?
06:28:49 <Syzygy-> desegnis: Computation of A-infinity structures in group cohomology. One of my thesis chapters will discuss a Haskell implementation of one of the most relevant algorithms for my work.
06:29:00 <mudge> yea, is it possible to get honorary doctorates?
06:29:02 <fasta> mudge: phdonly50dollar.com
06:29:11 <Syzygy-> mrd: You don't tend to write a thesis for a honorary doctorate.
06:29:27 <roconnor> mudge: I suppose one can ask you to write factorial in haskell to judge your progress. :)
06:29:36 <opqdonut> :)
06:29:39 <mrd> you tend to have already demonstrated qualifications ;)
06:30:24 <Syzygy-> > let fac n = prod [1..n] in fac 5
06:30:26 <lambdabot>   Not in scope: `prod'
06:30:29 <Syzygy-> Hmmm.
06:30:32 <Syzygy-> > let fac n = product [1..n] in fac 5
06:30:33 <lambdabot>  120
06:30:37 <Syzygy-> Hah.
06:30:42 <roconnor> Syzygy-: nice work.
06:30:49 <Syzygy-> :)
06:30:54 <doserj> diakopter, try "runghc Setup.hs configure"
06:31:02 <wli> I have no qualification for anything. I just sort of barely learned how to deal with monads after 10 years, which probably puts me in the "don't touch" category, since 10 years to figure out monads probably means there's something wrong with me.
06:31:04 <mudge> fasta: the phdonly50dollar.com  URL didn't work
06:31:15 <roconnor> Syzygy-: you have level ``Tenured professor''
06:31:23 <Syzygy-> roconnor: Great. Does it come with tenure?
06:31:32 <doserj> diakopter, you are calling Setup.hs as a shell script, an "import" happens to be a command that queries the X Server
06:31:46 <roconnor> Syzygy-: nope
06:31:51 <Syzygy-> Awwwwww
06:32:03 <wli> (OTOH I've by no means been trying on any sort of regular or consistent basis over that time period.)
06:32:15 <desegnis> Syzygy, that topic sounds good enough. Just add a footnote saying that the complete Haskell implementation, covering everything what you discuss, is just too trivial.  (Sorry, I'm not enough into CS/maths to really talk about this :-/)
06:32:24 <Syzygy-> desegnis: Pbtbtbtbtbt. :)
06:32:38 <Syzygy-> desegnis: I'm currently trying to get my implementation published in a mathematics journal.
06:32:41 <Syzygy-> :)
06:32:43 <mudge> oh so it is possible to get an honorary doctorate,   do you think it is hard?
06:33:01 <Syzygy-> mudge: Being famous and doing good work for a discipline tends to be a couple of the prerequisites.
06:33:03 <opqdonut> well you have to be linus torvalds or somesuch person, mostly
06:33:37 <Syzygy-> opqdonut: The two major universities in Stockholm awarded, within a few years from another, honorary doctorates to Linus Torvalds and Bill Gates while I was still studying here...
06:33:48 <opqdonut> yeh :)
06:33:55 <Syzygy-> I think the Linus doctorate was more or less a reaciton to the Gates one. IIRC
06:34:11 <fasta> I heard Bill G. also got one from the maffia.
06:34:40 <mudge> neat
06:34:50 <diakopter> doserj: thanks :)  that helped a lot; it got further.
06:34:58 <mudge> well maybe if you ask for one its easier than universities just giving you one
06:35:45 <Syzygy-> mudge: I should think most universities would be offended if you waltz in and ask for a honorary degree.
06:36:05 <doserj> not if you offer to finance a new department :)
06:36:15 <opqdonut> i think honorary degrees are nothing to count on :)
06:36:47 <mudge> maybe we should get honorary Phds  when we understand monads,  after all it can take up to 10 years
06:37:11 <opqdonut> there is nothing to understand in monads :)
06:37:14 <opqdonut> don't stress it
06:38:04 <roconnor> opqdonut: there is Kleisli arrows to understand.
06:38:09 <Syzygy-> opqdonut: They're only monoidal objects in the comma category anyway. Or was it the functor category?
06:38:38 <opqdonut> nah, i didn't mean in the ct sense but in the "programmer's abstraction" sense :)
06:38:58 <opqdonut> but yeah, if you do ct they're trivial too
06:38:58 <Syzygy-> mudge: I'm getting the feeling that your idea of a PhD differs significantly from that of most in the academia.
06:39:10 <Cale> Syzygy-: They're monoid objects in the category of endofunctors over the category of Haskell types
06:39:11 <roconnor> Do monad tutorials talk about the importance of  functions of the type a -> m b ?
06:39:22 <Syzygy-> opqdonut: Note that I did CT before I did HAskell, and was drawn here by the density of CT in the community.
06:39:27 <Syzygy-> Cale: Yeah, that's it. Thanks!
06:39:30 <mudge> whoa, Benjamin Franklin  got an honorary phd
06:39:40 <opqdonut> Syzygy-: ok
06:40:07 <opqdonut> i think having so many CT guys around is one of the reasons people think haskell is hard to learn :)
06:40:20 <opqdonut> but in the end, "you could've invented monads"
06:40:53 <roconnor> CT clarifies so many things though.
06:40:53 <opqdonut> coming either from a CT or a programminf point of view
06:40:55 <mudge> opqdonut: what is CT?
06:41:00 <opqdonut> Category Theory
06:41:12 <mudge> is that a programming language?
06:41:18 <opqdonut> a branch of mathematics
06:41:18 <Syzygy-> No.
06:41:29 <fasta> Is there a lazy foldM?
06:41:30 <opqdonut> monads and functors and so on come from there
06:41:32 <wli> I'm totally ignorant of category theory and it's resisted various meager efforts of mine to understand it for over half my lifetime (15+ years).
06:41:33 <mudge> i'm jokin ;)
06:41:42 <mudge> i'm surprized no one laughed at that
06:41:42 <Syzygy-> mudge: It's hard to tell.
06:41:53 <mudge> lol
06:41:54 <wli> Pass the dunce cap my way.
06:42:02 <Syzygy-> mudge: The difference between "ignorant" and "joking" can be very thin at times.
06:42:16 <opqdonut> true, true
06:42:21 <mudge> well you guys are awfully nice
06:42:27 * roconnor often thinks of CT as Church's Thesis.
06:42:42 <opqdonut> roconnor: i think of it as counter-terrorists mostly
06:42:50 <opqdonut> tho not when i see it on #haskell :)
06:42:56 <roconnor> opqdonut: we lead different lives
06:42:56 * Syzygy- leaves the keyboard for now.
06:43:01 <roconnor> :)
06:43:10 <opqdonut> :)
06:44:08 <cognominal__> the problem is not so much category than the example given in category book are from areas unkown from us. Now that I learn haskell, category theory starts to make sense
06:47:36 <cognominal__> s/example/examples/
06:47:36 <DRMacIver> roconnor: Category theory doesn't so much clarify as obfuscate in pretty ways. ;)
06:47:36 <matthew-_> mmmm. London Hug soon. Geeks + Beer = happiness
06:47:36 <roconnor> I should go to the hackathon this year
06:47:36 <roconnor> @seen dons
06:47:36 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 49m 16s ago.
06:47:38 <roconnor> @time dons
06:47:39 <lambdabot> Local time for dons is Mon Aug 20 23:46:47 2007
06:48:13 <mudge> you know what sucks about an honorary PHd is that I think by the time that you get it,  you don't need it
06:50:04 <opqdonut> ya think?
06:50:35 <njbartlett> DRMacIver: Got a good question for you from a commenter on the London HUG blog
06:50:46 <njbartlett> How on earth do you recognize a collection of Haskellers in a pub?
06:51:14 <wli> njbartlett: I stand out like a sore thumb in most pubs.
06:51:54 <DRMacIver> Ha.
06:52:00 <DRMacIver> That's a good question. :)
06:52:11 <DRMacIver> (Thanks. I should have been checking that comment thread)
06:52:18 <wli> Though it's doubtful anyone would suspect me of being a Haskeller.
06:52:31 <DRMacIver> njbartlett: Hm. I see no comments...
06:52:52 <DRMacIver> Anyway, I'll bring a sign saying London HUG. :)
06:53:01 <wli> Is there a PDX HUG yet?
06:53:22 <wli> Or is PDX considered to be one huge HUG as it stands? ;)
06:53:25 <DRMacIver> (Which is humourously open to misinterpretation for those who don't know what it means, but never mind...)
06:53:28 <DRMacIver> PDX?
06:53:39 <pejo> wli, Portland State University?
06:54:01 <wli> PDX is an abbreviation for "Portland Oregon"
06:54:26 <evir> Wow, neither a D nor an X are in that name.
06:54:32 <wli> The abbreviation is borrowed from the airport code.
06:55:33 <DRMacIver> Ah
06:55:34 <wli> And yes, PDX has PSU, OGI, and Galois.
06:56:01 <SamB_XP> I thought PSU was Penn State University
06:56:19 <wli> It is also that. They're conflicting abbreviations/acronyms.
06:56:22 * DRMacIver thought it was Power Supply Unit. :)
06:56:50 <SamB_XP> DRMacIver: that's not an organization, so it doesn't conflict much
07:04:48 <njbartlett> DRMacIver:
07:04:54 <DRMacIver> njbartlett:
07:05:01 <njbartlett> Grr, sorry :-)
07:05:34 <njbartlett> It was a first-time commenter, so I needed to approve it. Getting so much comment spam at the moment!
07:05:42 <DRMacIver> Ah, right.
07:06:02 <njbartlett> It's a shame I don't have time to send you one of my London HUG shirts. Although, I only have XL...
07:06:30 <fasta> $f2 in module Foo is taking 66% of all the time. Is there any way to find where that is exactly?
07:07:01 <DRMacIver> njbartlett: Oh well. :)
07:07:03 <opqdonut> add cost centers?
07:12:32 <Cale> I wonder if you could make a tower defense game based on the lambda calculus... hmm :)
07:12:38 <fasta> How can I inline a method with {-# INLINE liftST #-}?
07:13:04 <fasta> It seems it cannot be placed in a class implementation
07:13:40 <wli> gah, gnuplot is so weak; there's no implicit plotting command
07:14:01 <fasta> opqdonut: that's a rather inefficient algorithm
07:14:12 <desegnis> Question time. Is there a very good reason newtypes exist in Haskell? Books say that the compiler can then optimize the constructor away, but what would prevent it from optimizing if I used data instead of newtype?
07:14:45 <DRMacIver> desegnis: I think newtype deriving seems to be the big thing.
07:15:16 <DRMacIver> (Basically you can lift type class implementations from the old type to the new one)
07:15:33 <fasta> DRMacIver: heh, talking about not answering the question... :)
07:15:51 <doserj> desegnis: "data" constructors are lazy, newtype constructors are strict, so the compile cannot always optimize the data constructors away
07:16:06 <DRMacIver> fasta: Well, it's a good reason for newtype to exist in that it's something you can't do with 'data'.
07:16:09 <fasta> desegnis: newtype and data are about the same modulo that the newtype has an implicit !.
07:16:25 <fasta> DRMacIver: no, because that wasn't in H98.
07:16:30 <DRMacIver> Oh, wasn't it?
07:16:35 <desegnis> ah, fasta, doserj, that makes sense to me
07:16:37 <DRMacIver> My mistake then. :)
07:16:53 <desegnis> DRMacIver, I was just wondering... but np ;)
07:17:15 <DRMacIver> Anyway, it's still a good reason for newtype to exist in Haskell, just not in Haskell98. ;)
07:17:42 * wli adds an NIH of gnuplot to the long TODO.
07:17:51 <doserj> newtypes are a very nice sweet spot between type and data declarations
07:18:02 <doserj> having the best of both worlds
07:18:11 <fasta> So... nobody knows about the inline question?
07:18:19 <fasta> Or cares (more likely)
07:18:35 <desegnis> well, now I'm wondering why we have newtypes if we have data ... ! ... anyway. The ! are Haskell98 too, aren't they?
07:19:10 <fasta> desegnis: in data type definitions, yes.
07:19:22 <ivant> wli, no wonder gnuplot doesn't support implicit plotting. It is very nontrivial to implement it correctly. Cylindrical decomposition and such stuff
07:19:27 <fasta> desegnis: yes, you could argue about that with somebody else. ;)
07:19:55 <roconnor> fasta: How can you inline a class method?
07:19:55 <desegnis> fasta, :)
07:20:09 <roconnor> fasta: shouldn't you write a speciallized version and inline that?
07:20:10 <fasta> roconnor: very funny
07:20:14 <wli> ivant: I'm not sure what you mean about cylindrical decomposition. I mostly thought of e.g. BFGS to find starting points and so on.
07:20:19 * roconnor is confused.
07:20:20 <fasta> roconnor: oh, it wasn't a joke.
07:20:25 <fasta> roconnor: sorry ;)
07:20:29 <roconnor> :)
07:20:37 <roconnor> fasta: maybe I didn't read back far enough
07:20:44 <fasta> roconnor: yes, that's the only logical alternative without anyone answering.
07:20:50 <fasta> roconnor: I'd thought about that already.
07:20:53 <wli> ivant: And from a starting point just follow the tangent.
07:21:03 <roconnor> fasta: okay, it's also the best idea I have.
07:21:29 <ivant> wli, suppose you want to draw a curve which corresponds to x^2+y^2=1. How would you do it?
07:22:24 <desegnis> fasta, well, you cannot inline a class method if you use it on a polymorphic value, because then you wouldn't know what method to choose. or didn't I read far enough back either?
07:22:30 <fasta> ivant: solve the equation first if it's decidable
07:22:33 <ivant> wli, the correct answer is, you use the cylindrical algebraic decomposition algorithm to get two solutions which are easy to plot
07:22:34 <wli> ivant: Find a solution via BFGS, follow the tangent in both directions until it either falls off plotting boundaries or the two traversals meet.
07:22:54 <ivant> fasta, haha, this is an NP problem :-)
07:23:15 <fasta> ivant: NP? Where do you read that?
07:23:32 <wli> ivant: Or if not using a minimization algorithm on the square of the residual, then a direct root-finding method.
07:23:48 <ivant> fasta, reading right now about it: it is equivalent to Positivstellensatz
07:24:26 <ivant> wli, using your method you'd get only one half of the circle (or do I miss some point?)
07:24:26 <wli> ivant: I've never even heard of the cylindrical algebraic decomposition algorithm.
07:24:51 <fasta> ivant: Ok, in that case, I would still try to solve it when it takes less than 10 seconds.
07:25:06 <ivant> wli, http://mathworld.wolfram.com/CylindricalAlgebraicDecomposition.html
07:25:08 <lambdabot> Title: Cylindrical Algebraic Decomposition -- from Wolfram MathWorld, http://tinyurl.com/338vjm
07:25:12 <wli> ivant: Following the tangent should lead all the way around the circle; following it in both directions gets the two cursors to meet.
07:25:13 <xerox> wli: there's this thing which draws charts, I'm not sure how advanced it is, but it spits out pretty graphics: <http://www.dockerz.net/software/chart.html>
07:25:16 <fasta> ivant: after 10 seconds, tell the user: "do you want to continue this lengthy computation?"
07:25:36 <ivant> wli, oh, I see what you mean
07:26:17 <ivant> wli, so you're computing gradient and try to chose it so that you're always at the solution
07:26:23 <wli> ivant: Yes.
07:27:11 <ivant> fasta, and do so every 10 seconds :-)
07:27:13 <wli> ivant: This is just for plane curves anyway, so I'm not concerned with anything like full generality in n dimensions.
07:27:22 <roconnor> xerox: I've hacked on the charting library, it's fun!
07:27:35 <ivant> wli, what should you do when you have more than one branch? :-)
07:27:43 <roconnor> xerox: I always wanted to replace gnuplot with a haskell library.
07:27:43 <xerox> roconnor: cool, what have you hacked on it?
07:28:07 <roconnor> xerox: I wrote a routine to automatically generate log axis from a data set.
07:28:22 <wli> xerox: That looks useful.
07:28:26 <ivant> wli, e.g. ((x-1)^2+y^2-1)((x+1)^2+y^2-1)=0
07:28:37 <roconnor> xerox: My function is actually kinda crappy, but it is the best automatic log axis generation that I've seen :)
07:28:37 <fasta> ivant: nah, there's C-c for that.
07:29:31 <xerox> roconnor: I see :)  This is one of the main users of the cairo library bindings so far.  Graphics look indeed quite nice.
07:29:48 <ivant> fasta, hmm, I have a plan, we can pretend doing some serious computations until the user gives up :-)
07:29:58 <roconnor> xerox: I need to make an SVG backend.
07:30:19 <fasta> ivant: that works until the user finds a different implementation.
07:30:20 <wli> ivant: I don't know how to deal with that offhand.
07:30:30 <ivant> roconnor, and a TeX (eps) backend
07:30:33 <ivant> roconnor, :-)
07:30:38 <xerox> roconnor: there is one, I think!
07:30:55 <roconnor> then I could have pretty charts for my blog
07:31:33 <ivant> wli, I only wanted to say that probably gnuplot isn't the right tool for such things. Mathematica can do implicit plots
07:32:02 <ivant> wli, probably Maple can also
07:32:07 <roconnor> the charting library doesn't chart mathematical functions, .. but it could
07:32:10 <xerox> roconnor: the svg stuff was in fluctuating stages when I implemented that. There were two or three options, none of them officially supported, but maybe the situation has changed now. I believe dcoutts__ has written some binding code for one of them at the time.
07:32:21 <wli> ivant: Well, I'm not really willing to deal with Mathematica. Some chunk of Haskell code to do it might be nice, too.
07:32:38 <roconnor> xerox: well... we don't need GTK to do an SVG backend.
07:33:01 <roconnor> roconnor: wait, is Cairo part of GTK?
07:33:06 * roconnor gets so confused.
07:33:11 <xerox> roconnor: right. No it isn't.
07:33:43 <ivant> wli, I thought of implementing cylindrical decomposition algorithm in Haskell some time ago, but fortunately I don't need it. It is quite involved and I don't really understand most of it yet
07:34:01 <roconnor> xerox: anyhow, it needs to be done sometime;  hopefully if I just wait long enough it will appear. ... That happens surprisingly often.
07:34:04 <wli> ivant: I'm not sure how cylindrical decomposition applies to all this.
07:35:03 <wli> ivant: e.g. how it deals with your disjoint circles.
07:35:04 <xerox> roconnor: maybe you are a sleepwalking coder ;-)
07:35:13 <roconnor> And with augustss' math expression printer, one could make nicely labeled mathematical plots.
07:35:36 <roconnor> xerox: maybe, but usually other people are to blame.
07:36:11 <ivant> wli, to put it simply, it decomposes an inequality (e.g. x^2+y^2<1) into separate "cylinders" of the form a<x<b, f(x)<y<f(g),... (e.g. -1<=x<=1, -sqrt(1-x^2)<y<sqrt(1-x^2) )
07:37:23 <ivant> wli, more precisely, it decomposes to the conjunction/disjunction of such cylinders
07:37:35 <wli> ivant: Yeah, I just don't see how it solves your disjoint circle problem.
07:38:40 <ivant> wli, oh, when we're talking about equations like x^2+y^2=1 it decomposes into (-1<=x<=1 && y=-sqrt(1-x^2)) || (-1<=x<=1 && y=sqrt(1-x^2))
07:39:15 <wli> ivant: The most I can see happening here is factoring the multivariate polynomial somehow.
07:39:32 <ivant> wli, so you have 2 branches here. we'd get 4 branches for the previously mentioned equation
07:39:55 <ivant> wli, yes, that's the basic idea, however it also includes separation into branches
07:41:00 <wli> Okay, so it differs from Wolfram's description in being boundary-based.
07:42:11 <ivant> wli, what do you mean by boundary-based?
07:42:22 <glen_quagmire> http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics/Solutions#Multiple_Constructors   I don't get this Either stuff
07:42:24 <wli> So given f(x_1,...,x_n) = 0, solve for x_n, disjoin for each root of f(x_1,...,x_n) as a polynomial in x_n over R[x_1,...,x_{n-1}]
07:42:25 <lambdabot> http://tinyurl.com/25x7pf
07:42:45 <sjanssen> @yow!
07:42:45 <lambdabot> I guess it was all a DREAM ... or an episode of HAWAII FIVE-O ...
07:42:48 <glen_quagmire> fromTuple (Two a b) should return (a,b)
07:42:58 <glen_quagmire> but, instead it returns Left (Right (a,b))
07:43:26 <axm> has someone here experience with automatic decisions about program equivalence (maybe using something like Term Rewrite Systems)?
07:43:29 <wli> ivant: Wolfram's description would yield -1 <= x <= 1, -(1-x^2)^(1/2) <= y <= (1-x^2)^(1/2) vs. what you described.
07:43:49 <sjanssen> glen_quagmire: it *can't* return (a, b), because (a, b) and (a, b, c) are different types
07:44:17 <sjanssen> glen_quagmire: 'Either a b' is one way to express sum types
07:44:28 <ivant> wli, sort of (this is elimination==projection), however CAD can decompose (f(x)>0 && g(x)>0 && ...)
07:44:32 <sjanssen> it means we _either_ have a value of type 'a', or a value of type 'b'
07:44:43 <glen_quagmire> sjanssen: then what is Left 1?
07:44:57 <xerox> sjanssen: do you remember a nice way to write splitBy?
07:44:58 <SamB_XP> axm: I'm under the impression that it's very hard
07:45:00 <glen_quagmire> :t Left 1
07:45:02 <lambdabot> forall t b. (Num t) => Either t b
07:45:12 <sjanssen> that has type 'Either Integer a'
07:45:13 <ivant> wli, you're probably talking about x^2+y^2<=1?
07:45:29 <sjanssen> (or Num t => ..., I'm trying to simplify a bit ;)
07:45:34 <xerox> I think it was an unfoldr, or something.
07:45:38 <wli> ivant: I have no idea how one does this when they're transcendental equations or not solvable in closed form.
07:45:47 <axm> same here, at the moment it is more the termination question that is considered
07:46:22 <SamB_XP> axm: hmm, you have to solve the halting problem, no? so it's tricky.
07:46:29 <sjanssen> @src Either
07:46:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:46:44 <glen_quagmire> fromTuple (Two 1 2) returns  Left (Right (1,2)) ..So, do I need type of fromTuple to see what is Left (Right ..) ?
07:46:50 <axm> in my case i could live with a timeout
07:46:52 <wli> ivant: That is even if one only considers plane curves.
07:46:53 <ivant> wli, there is a thing which I learned today: it is called algebraic numbers (actually I probably had learnt it at some point of algebra course)
07:46:56 <sjanssen> data Either a b = Left a | Right b -- | means or/choice/sum type
07:47:27 <SamB_XP> ivant: what are those?
07:47:29 <sjanssen> glen_quagmire: yes, the type of fromTuple says what the type of (Left (Right ...)) should have
07:47:35 <wli> ivant: I remember a little Galois theory from my freshman year. What about them?
07:47:37 <ivant> wli, algebraic numbers are those which can be represented as a solution of a polynomial (univariate)
07:47:38 <glen_quagmire> fromTuple :: Tuple a b c d -> Either (Either a (a,b)) (Either (a,b,c) (a,b,c,d))   -- according to this function type, I know Left (Right (a,b))   is of type (a,b)
07:47:43 <axm> I got the impression the TRS people do that as well as last resort
07:47:46 <ptolomy> good lordie.. I go on vacation for a week, and when I come back I have 48 messages waiting for me in my Cafe folder. I'm not getting any work done today.
07:47:53 <SamB_XP> ivant: ah.
07:48:01 <glen_quagmire> sjanssen: ah thank you. so there is no way to return just (a,b)
07:48:01 <ivant> wli, and the good thing is that they form a field
07:48:07 <sjanssen> glen_quagmire: no, (Left (Right (a, b)) :: Either (Either (a, b) ???) ???
07:48:12 <SamB_XP> ptolomy: you don't have to read your whole cafe folder at a time
07:48:26 <wli> ivant: Sure, Q[x]/(p(x)) where p(x) is the minimal polynomial.
07:48:27 <sjanssen> glen_quagmire: the type says that the thing that fits in (Left (Right ???))
07:48:30 <ivant> wli, and there is some theory behind saying how to add and multiply them
07:48:32 <sjanssen> is of type (a, b)
07:48:57 <ptolomy> SamB_XP: I don't have to finish a whole box of oreos in one sitting either, but I will pretty much every time.
07:49:00 <wli> ivant: The number field is isomorphic to Q[x]/(p(x)), yes.
07:49:23 <SamB> ptolomy: you need less money
07:49:27 <glen_quagmire> :t Left (Right (1,2))
07:49:29 <lambdabot> forall t t1 a b. (Num t, Num t1) => Either (Either a (t, t1)) b
07:50:02 <glen_quagmire> oh haskell is challenging
07:51:11 <earthy> programming is
07:51:12 <wli> ivant: Where's this come into the picture? Algebraic extensions of Q[y]?
07:51:13 <ptolomy> SamB: If I keep spending my time at working reading unrelated mailing lists all day, it won't be a problem. :)
07:51:32 <earthy> haskell just doesn't put drudgery in the way of the challenge
07:51:54 <earthy> (well, not much drudgery at least)
07:52:10 <sjanssen> glen_quagmire: btw, we wouldn't usually write a function like 'fromTuple' in Haskell
07:52:23 <wli> ivant: Or, rather, when eliminating y, the implicit solutions are represented as elements of Q[x]/(p(y)) where p(y) has coefficients in Q[x]?
07:52:35 <sjanssen> encoding the sum of more than one data type is really annoying with Either
07:52:47 <wli> GRR
07:53:07 <wli> ivant: Q[x][y]/(p(y)) where p(y) has coefficients in Q[x]
07:54:30 <wli> ivant: One more time: Q(x)[y]/(p(y)) where p(y) has coefficients in Q(x), Q(x) being the rational function field with indeterminate x vs. Q[x] being the ring of polynomials in x with coefficients in Q.
07:55:08 <ivant> oops, sorry, I was distracted by the phone call
07:57:17 <wli> ivant: Am I anywhere near close?
07:57:44 <ivant> wli, I don't know the details exactly (and I also remember too little from the Galois theory), but I expect this to be right when eliminating y, the implicit solutions are represented as elements of Q[x]/(p(y)) where p(y) has coefficients in Q[x]
07:58:22 <wli> ivant: I think Q(x)[y]/(p(y)) where p(y) has coefficients in Q(x), Q(x) being the rational function field with indeterminate x vs. Q[x] being the ring of polynomials in x with coefficients in Q.
07:58:43 <ivant> wli, I learnt about algebraic numbers today which explained some of the things I didn't know about the possible implementation before, but I'm nowhere near the real knowledge of how the algorithm works
08:00:54 <glen_quagmire> sjanssen: yup. i sensed this was for exercise. if haskell was like this, it wouldn't be so enterprise ready
08:01:16 <wli> I'm mostly trying to find ways to enumerate solutions to 4*x^2+y^2=n, 3*x^2+y^2=n, and 3*x^2-y^2=n for all possible n in order so I can count the number of solutions for each polynomial for each n of some form.
08:01:17 <sjanssen> bleh, "enterprise ready"
08:01:37 <wli> Methods involving isqrt seem to be unacceptably slow.
08:01:44 <DRMacIver> sjanssen: Haskell is web 2.0 enabled. ;)
08:02:03 <ivant> wli, where nZ?
08:02:16 <ivant> wli, oh, I mean nN
08:02:57 <wli> ivant: n in N, with various lower bounds assumeable even (basically one can just tabulate the first few primes to accommodate any small lower bound).
08:03:50 <wli> 4*x^2+y^2 is for n = 1 mod 4, 3*x^2+y^2 is for n = 1 mod 6, and 3*x^2-y^2 is for n = 11 mod 12.
08:04:25 <ivant> wli, let me digest this
08:04:43 <wli> ivant: Only natural number solutions are of interest, where for 3*x^2-y^2 it's furthermore required that x > y
08:04:57 * ndm just managed to beat GHC on nqueens :-)
08:04:57 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
08:05:00 <wli> ivant: In fact positive natural number solutions, x, y >= 1.
08:05:44 <ndm> @tell ddarius yes, but if you have a good "nice intro" paper or technical summary paper i'd appreciate it, most of them were written in not very accessible manners
08:05:44 <lambdabot> Consider it noted.
08:05:56 <ndm> (or maybe i've been spoiled by SPJ papers...)
08:07:52 <ivant> wli, not sure if it helps you, but here is a very good workshop materials which are talking about the existence of solutions (and dual problems): http://www.control.lth.se/seminars/SanjayLall-2004-12/
08:07:54 <lambdabot> Title: Semi-definite Programming Relaxations and Algebraic Optimization with Engineerin ...
08:08:11 <ivant> wli, probably you can restate your problem in the suitable form
08:08:22 <wli> ivant: They're not optimizations of course...
08:08:27 <ricky_clarkson> ndm: Just glancing at your homepage - what do you think of restarts (a la lisp) instead of crashes?
08:08:44 <ivant> wli, they are equivalent/dual to the optimization problems :-)
08:09:02 <ivant> wli, basically, this is what the workshop is about
08:09:06 <wli> ivant: The problem here is largely related to enumeration.
08:09:34 <jedai> @source Control.Monad
08:09:34 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
08:09:39 <ivant> wli, SAT problem is about enumeration too :-)
08:09:40 <wli> ivant: It's no problem at all to find solutions. It's to enumerate them in such a way that I can count the solutions for a given n.
08:10:10 <wli> ivant: Basically a number is prime depending on whether the number of solutions is even or odd.
08:10:20 <wli> ivant: (and it being squarefree)
08:10:56 <ndm> ricky_clarkson: hmm, no particular opinion - never used restarts, and obviously crashes are something you don't want to happen
08:11:25 <wli> ivant: Using this to sieve for primes is called the Sieve of Atkin. It's an array-based algorithm to sieve over finite intervals as presented in its paper.
08:12:55 <wli> ivant: It's faster than Eratosthenes et al in the array-based context. However, its not so straightforward to translate it to generating infinite lists of primes as is possible for Eratosthenes et al.
08:13:08 <ricky_clarkson> ndm: If crash means segfault or equivalent, then yes.  If a crash means getting bottom, then there seem to be cases where avoiding the crash is worse than having the crash.
08:13:14 <ivant> wli, I feel that I don't really follow you, too many maths for me today (I've digested a large chunk of that workshop today)
08:14:16 <wli> ivant: In order to generate infinite lists of primes, you have to be able to get some kind of ordering constraint on the n so that f(x,y)=n where f is one of 4*x^2+y^2, 3*x^2+y^2, or 3*x^2-y^2
08:15:08 <ivant> wli, what is the connection of primes and these functions?
08:15:11 <wli> ivant: Getting this set up to find solutions for a particular n at each iteration is not hard but it is slow.
08:15:15 <ndm> i am now also faster than GHC on the primes benchmark in nofib!
08:15:16 <ricky_clarkson> ndm: I work in the CS dept at Salford, and I don't know anyone here who has done even a quarter of the amount of useful work that you have.
08:15:33 <wli> ivant: A squarefree number is prime if the number of solutions to f(x,y) = n is odd.
08:15:39 <mrd> ndm: are you calculating by hand? =)
08:16:05 <ndm> ricky_clarkson: avoiding bottom usually isn't that hard, esp if you have a tool like Catch and are willing to do some work, some people (Turner) even think that avoiding partial patterns entirely isn't that hard
08:16:16 <ndm> ricky_clarkson: thanks :) - although stanford checker is dead cool
08:16:18 <shapr> Good morning #haskell!
08:16:21 <ivant> ndm, are you good at executing DNA sequences? I mean, comparing to the ghc :-)
08:16:28 <ivant> Good morning, shapr
08:16:33 <ndm> (but dead secret, sadly)
08:16:45 <ndm> ivant: i should be faster, but nofib first :)
08:16:49 <wli> ivant: The way the array-based algorithm works is just traversing a region and flipping bits in a table corresponding to the value of f(x,y) for each n in the region. If n is out of bounds it's ignored.
08:16:57 <ndm> mrd: yes, breaking a sweat, but just outpacing GHC :)
08:17:24 <wli> ivant: Generating an infinite lazy list of primes makes the region infinite.
08:17:49 <wli> ivant: There needs to be some way to tell when we're done looking at candidates for a given n.
08:17:51 <ivant> wli, aha, I'm starting to understand it
08:18:05 <mrd> humans emit much nicer error messages than ghc, at least
08:18:23 <ndm> not true in my case, error "crap" is the only one that hardcoded
08:18:24 <wli> ivant: Otherwise we can't decide whether n is a member of the infinite list of primes or not and the iteration it's translated to never terminates.
08:18:36 <ndm> (and i'm not kidding, my version really does replace all error messages with error "crap")
08:20:56 <wli> So anyway I now have something like bounds on x and y in terms of n, which I'm not entirely sure how to translate to anything that would help with this.
08:22:38 <wli> The basic thought is that we're going over pieces of the first quadrant and given that we've iterated over so much of the first quadrant, we want to know lower bound on the n's whose primality is not fully determined.
08:27:07 <ivant> wli, I'm still not sure what your algorithm is, but here is what I understood:
08:27:24 <Botje> "The" ? :)
08:28:19 <ivant> wli, for each n in [1..], you want to count the number of integer solutions to {f(x,y)=n}
08:28:32 <wli> [2..] but yes
08:28:51 <wli> ivant: http://www.ams.org/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf
08:28:55 <lambdabot> http://tinyurl.com/2sno9x
08:28:56 <wli> ivant: That's the algorithm.
08:29:11 <ivant> wli, I don't have an access to ams
08:29:29 <wli> ivant: You don't need it. I have no such access and can view it.
08:30:00 <ivant> wli, it says Subscription is required for AMS and AMS-distributed electronic journal access
08:30:13 <wli> ivant: It's available from citeseer also.
08:30:17 <Botje> ivant: tried bugmenot ?
08:31:00 <wli> ivant: http://citeseer.ist.psu.edu/452169.html
08:31:01 <lambdabot> Title: Prime Sieves Using Binary Quadratic Forms - Atkin, Bernstein (ResearchIndex)
08:31:27 <Tac-Work> Does anyone know if it's possible to use #!/usr/bin/env runhaskell at the top of a haskell program?
08:31:46 <Tac-Work> I want to run haskell as a shell script-like program, but it gives a syntax error
08:32:02 <ivant> wli, so you do something like length [undefined| x<-[0..xmax], y<-[0..ymax], f x y = 0 ]
08:32:17 <mrd> Tac-Work: it's easiest in a .lhs file
08:32:31 <wli> ivant: Vaguely yes.
08:32:53 <Tac-Work> what's a .lhs file?
08:33:01 <wli> Literate Haskell
08:33:02 <ivant> wli, and the problem you have is that you can't find xmax and ymax?
08:33:14 <ivant> wli, or I'm missing some other part?
08:33:26 <mrd> Literate Haskell -- either "Bird"-style where "> " prefixes every line of code, or "LaTeX"-style where code is surrounded by \begin{code} ... \end{code}
08:33:48 <Tac-Work> that sounds like a big workaround
08:34:05 <wli> ivant: No. It's that doing it that way is dogslow. It has to be an iteration over portions of the first quadrant without explicitly searching for solutions for a particular n otherwise it's too slow.
08:34:07 <Tac-Work> it seems like runhaskell should have a flag built into it for ignoring the first line or something
08:34:18 <mrd> on the contrary, Literate programming is a good thing to get accustomed to
08:34:30 <ndm> grr, literate programming is horrid
08:34:46 * ndm has an item on his todo list, to remove .lhs source from yhc
08:35:01 <ivant> wli, dogslow, yes :-) what is first quadrant?
08:35:53 <wli> ivant: x, y > 0
08:36:09 <wli> ivant: Except for 3*x^2-y^2, where the search is over x > y > 0
08:36:18 <mrd> LaTeX-style will have minimal impact on your code layout
08:36:20 <shapr> Man I love this job.
08:37:50 <ivant> wli, oh, you mean we don't want to search over all [0..xmax]*[0..ymax] for solutions. Yes, I was supposing that
08:37:53 <Syzygy-> shapr: How so?
08:38:12 <shapr> Syzygy-: I get to hack on very cool Haskell code every day.
08:38:17 <Syzygy-> Nice
08:38:28 <shapr> And I'm working on stuff I've been dreaming about writing for years.
08:38:41 * Nafai hates this job
08:39:03 <ivant> wli, so is there some useful criteria for choosing parts of [0..xmax]*[0..ymax]?
08:39:12 <shapr> I wished I had this Haskell ADT <-> XML that uses syb-with-class for as long as I've been using Haskell.
08:39:24 <sjanssen> shapr: any chance alexj is hiring?
08:39:27 <wli> ivant: Yeah, there are congruence constraints on x and y.
08:39:32 <krishn_bhakt> Anything like R coded in Haskell?
08:40:07 <byorgey> sjanssen: heh, I just asked the same question the other day =)
08:40:15 <krishn_bhakt> :)
08:40:25 <shapr> sjanssen: Yeah, there's a chance :-)
08:40:30 <byorgey> sjanssen: but don't worry, I'm not actually very serious about it, I was just curious
08:41:17 <conal> shapr: what's HappS's business model?  selling consulting?
08:41:34 <ivant> wli, oh, are they simply following the curve in this paper?
08:42:43 <wli> ivant: They can get away with that because they have some sort of bounded region.
08:43:26 <ivant> wli, don't you have it bounded for each n as well?
08:43:40 <wli> ivant: I originally tried to follow successive regions of the form used in the paper but the algorithm appeared to be broken.
08:43:59 <wli> ivant: Algorithm(s) rather.
08:44:19 <hpaste>  osfameron pasted "how do I memoize this? (long division function)" at http://hpaste.org/2351
08:44:45 * osfameron thinks of words like "fix" and "lifting" but is getting confused
08:44:45 <ivant> wli, suppose we take 4x^2+y^2=n
08:46:26 <ivant> wli, we start with (x,y)=(0, floor $ sqrt n) and move along the curve until we hit ((/2) $ floor $ sqrt n, 0) counting the number of integer solutions
08:46:48 <shapr> conal: That's part of it, but being able to implement new ideas for websites quickly is the biggest part.
08:46:50 <ivant> wli, thus you don't even need an array
08:47:21 <ivant> wli, and the number of tests can be made quite small if we are smart in following the curve
08:47:24 <ptolomy> Anyone aware of a haskell library that facilitates message-passing concurrency in a nicely abstracted way?
08:47:29 <wli> ivant: The specific form of the bound and the specific tracing method are the parts killing me here.
08:47:44 * ivant starts remembering what he read about ellipse drawing in some book about computer graphics
08:47:47 <wli> ivant: It's also a family of curves.
08:48:12 <wli> ivant: The paper claims to draw explicitly on graphics algorithms for level curve tracing.
08:48:25 <ivant> wli, what do you mean by family of curves? you execute the algorithm for each fixed n
08:48:43 <ivant> wli, wow, I'm close to getting the idea :-)
08:49:59 <wli> ivant: Well, not so much executing the algorithm for each fixed n but implicitly considering f(x,y)=n for each fixed n.
08:50:19 <krishn_bhakt> is there any book which explains 'algorithms and data-structures' using Haskell
08:50:39 <shapr> @seen dcoutts
08:50:39 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-overflow, #haskell and #ghc 3d 1h 30m 44s ago, and .
08:50:42 <shapr> aww
08:50:44 <wli> It's implicit because there is a sort of "batch" of n's considered in each region 60*L <= n < 60*(L+B)
08:51:15 <shapr> Who's the most active Cabal hacker these days? Is it dcoutts?
08:51:23 <ivant> wli, what's the difference? why can't you do map isPrime [3..] where isPrime traces 3 curves?
08:51:25 <wli> Somehow it constructs a region of the plane/lattice.
08:51:48 <wli> ivant: The curves are for mostly disjoint subsets of integers, for one.
08:52:41 <wli> ivant: 4*x^2 + y^2 = n for n `mod` 4 == 1, 3*x^2 + y^2 == n for n `mod` 6 == 1, and 3*x^2 - y^2 = n for n `mod` 12 == 11
08:52:57 <byorgey> krishn_bhakt: there's a list of Haskell books here: http://haskell.org/haskellwiki/Books_and_tutorials
08:52:58 <lambdabot> Title: Books and tutorials - HaskellWiki
08:53:21 <byorgey> krishn_bhakt: in particular you might take a look at Chris Okasaki's book, "Purely Functional Data Structures"
08:53:22 <shapr> Now that HAppS is split into several darcs repositories, I wish that cabal-install could pull new patches for a bunch of repos, and rebuild packages with new patches, *and* all packages that depend on packages with new patches.
08:54:23 <ivant> wli, do these equations are joined with && or ||?
08:54:41 <mnislaih> shapr: that sounds good. Why not fill a feature request thinking in the incoming Hackathon ?
08:54:46 <ivant> wli, why do we have these `mod` something?
08:55:16 <wli> ivant: They're only valid tests for n of the congruence classes mentioned.
08:55:37 <shapr> mnislaih: Yeah.. but I'm not sure how version dependency would work... unless darcs tag were used to match up a tag to a version?
08:55:58 <wli> ivant: Whenever the sequences intersect the results for different f's will agree except where n within the intersection is not squarefree.
08:56:33 <shapr> Hiya d-bug
08:56:45 <mnislaih> shapr: but then cabal-install would have to understand darcs ?
08:56:54 <shapr> Yeah, that's what I'm wondering...
08:57:02 <wli> ivant: This is basically resolved by moving to mod 60 and making the congruence classess for the different binary quadratic forms' tests completely disjoint.
08:57:23 <shapr> Or darcs would have to be served up by things that understood http://foo.com/repo?tag=0.9
08:57:23 <daniel_larsson> hackage has idea where the source code is, apart from the tarball uploaded, right?
08:57:28 <wli> ivant: (actually I think mod 12 would be sufficient)
08:57:33 <d-bug> hi ho
08:57:38 <daniel_larsson> err... has *no* idea..
08:57:39 <Choko> @wiki primes
08:57:39 <lambdabot> http://www.haskell.org/haskellwiki/primes
08:57:42 <shapr> d-bug: Godmorgon!
08:57:48 <d-bug> tack :)
08:57:51 <shapr> daniel_larsson: I think that's correct.
08:57:57 <xerox> daniel_larsson: it could, if the .cabal fice specified a repository
08:58:11 <byorgey> osfameron: check out http://www.haskell.org/haskellwiki/Memoization
08:58:12 <lambdabot> Title: Memoization - HaskellWiki
08:58:21 <shapr> xerox: That's a good point.
08:58:54 <shapr> But still, how would you pull to a certain version in the cabal file?
08:59:41 <byorgey> osfameron: the general idea is to change the longdiv function so it takes an extra parameter f, which it calls instead of calling itself recursively: longdiv f x y = ... f (x * 10) y ...
08:59:49 <ivant> wli, ok, I need to get some tea and continue reading about the systems of multivariate polynomial inequations. Thanks for taking time to explain me this thing, sounds like a cool way to sieve (although I'd need to read the paper some time later)
08:59:51 <xerox> shapr: I think darcs can pull exact tags?
09:00:03 <byorgey> osfameron: applying fix to that would give you back your original longdiv function
09:00:19 <shapr> xerox: How often does a darcs tag match the cabal file version?
09:00:22 <byorgey> osfameron: but you can transform it with a 'memoize' function before applying fix
09:00:49 <xerox> shapr: exactly as often as when packages are uploaded to hackage, in principle, I think.
09:01:03 <shapr> hmm
09:01:07 <shapr> That's a good point.
09:01:11 <osfameron> byorgey: thanks for the wiki ref
09:01:50 <xerox> shapr: actually, it probably must be the case, hackage does a lot of checks to incoming packages. Or if it is not yet enforced, it might be. We've got a community server paid for by the soc money anyway :)
09:01:54 <byorgey> osfameron: sure.  skimming the wiki page it looks like it's not explained as well as it could be, but there are also some links at the bottom which might be useful too.
09:02:24 <shapr> xerox: Yeah, that would be a useful convention, to have code version match up with darcs tag.
09:02:38 <byorgey> osfameron: I'd explain it myself but I don't remember all the details off the top of my head =)
09:03:11 <daniel_larsson> shapr: You want cabal-install to find versions in darcs repos that haven't been uploaded to hackage yet?
09:03:22 <osfameron> byorgey: hehe, thanks anyway :-)  it's probably best I work through the Fine Manual first anyway to try to understand it myself
09:03:47 <byorgey> osfameron: indeed.
09:04:18 <shapr> daniel_larsson: I'm not sure. I know I want cabal-install to pull the latest patches from many repos, and then rebuild the repos that have new code, and all repos that depend on those repos.
09:05:06 <shapr> That's pretty important to me because HAppS has just been split into several repositories.
09:05:12 <fasta> shapr: Cabal has no trust built-in, right?
09:05:12 <shapr> What's the best solution for that?
09:05:41 <shapr> fasta: I'm not sure, I don't think so.
09:05:49 <fasta> Not having trust in a new package system is a rather bad idea.
09:05:58 <fasta> Even Java has had that for years.
09:06:13 <eivuokko> shapr, You can make a makefile;  Depend on darcs inventory and write stamps for successfull build + register.
09:06:14 <mnislaih> shapr, what about a local hackage set up ?
09:06:21 <fasta> ADSF has for years
09:06:31 <shapr> fasta: Feel free to fix it :-)
09:06:32 <fasta> (and probably other systems)
09:06:49 <roconnor> fasta: what's trust?
09:07:21 <shapr> eivuokko: Hm, that would work.
09:07:29 <fasta> roconnor: I put a package on Cabal. You install the package. You lost your home dir.
09:07:41 <alexj> shapr: it would take a really small modification of searchpath to have it always try to get the most recent files from the internet rather than using the local cache.
09:07:41 <alexj> I think that would do what you want.  Modifying searchpath to use darcs to grab repos instead of curl would also be relatively easy, but a larger task.
09:07:53 <Tac-Work> @src fromInt
09:07:53 <lambdabot> Source not found. Where did you learn to type?
09:08:04 <shapr> fasta: Ah, it does require a login to upload to Hackage.
09:08:15 <fasta> shapr: and anyone can register?
09:08:24 <shapr> No, you have to get admin approval.
09:08:27 <roconnor> fasta: can anyone upload to Cabal?
09:08:29 <fasta> shapr: or does it go through some non-trivial process?
09:08:42 <fasta> shapr: e.g. you need to give physical address
09:08:52 <fasta> shapr: passport identification ;)
09:08:55 <roconnor> fasta: oh, you are asking.
09:09:14 <shapr> Well, I only had to ask... but then, I've met most people in the community.
09:09:16 <ndm> fasta: you ask Ross, he gives you a login
09:09:22 <daniel_larsson> fasta: show me another package system that asks for passport identification ;)
09:09:25 <ndm> shapr: for everyone its just a question of ask
09:09:28 <fasta> e.g. roconnor should be able to pounch my face when I do something malicious.
09:09:40 <roconnor> @slap fasta
09:09:41 * lambdabot slaps fasta
09:09:49 <shapr> ndm: oh
09:09:54 <fasta> Otherwise, it's just waiting for the system to be exploited.
09:09:54 <roconnor> just testing
09:09:58 <ndm> shapr: but you are still special ;-)
09:10:06 <shapr> daniel_larsson: Actually, debian does.
09:10:36 <wli> I didn't know the wiki had Euler problem pages.
09:10:39 <daniel_larsson> I'm sure hackage doesn't yet need to though )
09:10:57 <eivuokko> Hackage had gnupg-based authentication in past.
09:10:59 <shapr> fasta: In any case, if you think it's a serious problem, go fix it!
09:11:05 <oerjan> @users
09:11:05 <lambdabot> Maximum users seen in #haskell: 404, currently: 402 (99.5%), active: 23 (5.7%)
09:11:07 <eivuokko> But it was pretty experimental at the time.
09:11:07 <shapr> eivuokko: Yeah, true.
09:11:26 <oerjan> O_O
09:11:31 <roconnor> oerjan: wan't the maximum seen lower than that a few hours ago?
09:11:43 <oerjan> i recall it being around 380
09:11:49 <shapr> Yay, we got over 400!
09:11:57 <fasta> I will believe that number when active is higher than 100.
09:12:14 <fasta> Some people are logged in three times.
09:12:23 <shapr> fasta: It's the real number.
09:12:30 <shapr> fasta: I was on #haskell when it had one user :-)
09:12:49 <fasta> shapr: I know, but the ratio active/all is so low
09:13:01 <roconnor> fasta: I'm interested in how you think a trust system should work.
09:13:06 <daniel_larsson> How's "active" defined?
09:13:13 <lament> shapr: my channel just hit an all-time peak yesterday due to being featured on reddit, and i can't say i'm very happy about that :)
09:13:17 <shapr> When enough people get active, it's hard to have a conversation.
09:14:21 <fasta> roconnor: getting a good trust system requires some thought, but I would look at ASDF and make it user friendly.
09:14:35 <roconnor> @where ASDF
09:14:36 <lambdabot> I know nothing about asdf.
09:14:45 <shapr> fasta: I do agree that people who write code and are actively learning more Haskell contribute the most, so idle #haskell clients aren't a big indicator of community activity.
09:14:49 <fasta> roconnor: also advocato has some ideas
09:14:50 <roconnor> asdf?  were you just pounding on your keyboard?
09:14:56 <roconnor> ;)
09:15:05 <shapr> advogato?
09:15:13 <lament> if you take asdf and try to make it user-friendly, you'll get aoeu
09:15:14 <fasta> shapr: right
09:15:27 <shapr> I like the debian approach.
09:15:44 <oerjan> lament: seeing that 404, i wondered if #haskell had been somewhere too (but reddit is full of haskell already, iiuc)
09:15:58 <fasta> lament: that's a joke, right?
09:16:07 <lament> fasta: yes. It's very funny. Laugh.
09:16:08 <shapr> fasta: Yes, it's a dvorak joke!
09:16:26 <fasta> lament: I suspected that within a second, but it could have been some lame Lisp pun.
09:16:32 <shapr> aoeu is the left hand home row on dvorak.
09:16:48 <roconnor> fasta: http://constantly.at/lisp/asdf/  <- this?
09:16:49 <lambdabot> Title: asdf Manual
09:17:00 <shapr> daniel_larsson: I think active is "spoke in the last two hours".
09:17:01 <lament> oerjan: reddit is chock-full with haskell but i haven't seen explicit mentions of the irc channel
09:17:12 <fasta> roconnor: right
09:17:18 <lament> shapr: if active ever rises too high, it will be hell.
09:17:26 <fasta> roconnor: maybe asdf-install is the actual crypto tool
09:17:37 <fasta> roconnor: I don't know, as I am not a hard-core CL user
09:17:45 <shapr> lament: Nah, I think it'll just move some conversation to #haskell-overflow or spoken language specific channels.
09:18:25 <osfameron> byorgey: yeah... the wiki article suggests implementing memoFix in terms of "memoize", about which it is mysteriously silent.  I'll have to look at this later, the email threads seem very much in terms of lazy lists, whereas I *think* I need Data.Map
09:18:25 <ivant> I wonder when #haskell_ru would be more than 10 active users :-)
09:18:29 <oerjan> does anyone have a theory why #haskell has so many inactive users?
09:18:37 <lament> shapr: i assume #debian has all those extra channels, but it's hell anyway
09:18:40 <oerjan> and btw are they always inactive?
09:18:52 <xerox> ivant: hey, ten is pretty nice, we'd like to have ten in .it :)
09:18:57 <ricky_clarkson> #debian has all those extra channels, yes.
09:19:04 <shapr> oerjan: No, they're not always inactive. I think there are just a few major reasons for inactive users on #haskell
09:19:17 <oerjan> would it be possible to ask lambdabot for the number of nicks that have not spoken in a given period?
09:19:28 <shapr> Some people want to learn Haskell, and they idle here and osmose information before they get around to really jumping in...
09:19:29 <ivant> oerjan, it's really hard to have that many conversations going on at the same time
09:19:36 <ivant> oerjan, , I mean, to follow them
09:19:44 <alexj> shapr: just pushed modification to search path add --newest to have it always try to pull the newest versions of the modules from net rather than use the local cache.
09:19:52 <shapr> Some people have real jobs and lives that suck up most of their time, but want to keep up with the cool stuff going on here, so they idle and then jump in when they're active.
09:19:56 <shapr> alexj: spiffy, thanks!
09:20:05 <osfameron> shapr: I think it's hard to osmose on #haskell though, at least without sufficient maths/comp sci background
09:20:16 * wli <-- realjobbing
09:20:24 <glen_quagmire> jobbing?
09:20:33 <shapr> osfameron: Yeah, sometimes that's true.
09:21:00 <pejo> oerjan, I'm usually inactive when I do other things. And sometimes I just read the stuff said in the channel. I the same goes for many people in here.
09:21:05 <lament> there's a lot of idlers in every big channel
09:21:17 <lament> some people join tens of channels and never talk in any of them
09:21:27 <shapr> lament: Hey, have you written any Haskell code lately?
09:21:40 <lament> shapr: a little
09:21:48 <shapr> Anything nifty?
09:21:54 <lament> i'm writing a tagger to manage all the junk in my public_html... so, no :)
09:22:06 <shapr> Sounds nifty to me.
09:22:10 <oerjan> lament: perhaps the fraction is not so different in #haskell, then?
09:22:14 <daniel_larsson> shapr just described me, more or less :) I'm not very active around here
09:22:22 <shapr> haha
09:22:40 <ivant> xerox, we had 6 active maximum, as far as I know, but that was when we were participating in the ICFP contest this year
09:22:50 <ivant> xerox, we simply occupied the channel :-)
09:23:13 <glen_quagmire> come to #haskell-women
09:23:16 <ivant> xerox, now it's mostly 2 users, me and lambdabot included
09:23:17 <shapr> Sometimes I'm not very active on #haskell for months at a time. But I'll come back and be active at some point :-)
09:23:41 * ivant thinks that he doesn't qualify for #haskell-women
09:23:51 * shapr neither
09:24:05 <shapr> lament: Got any source online?
09:24:08 <lament> no
09:24:10 <shapr> aww
09:24:32 <lament> you just wanna see random haskell source, or some proof that i actually program? :)
09:25:12 <shapr> Well, tagging all the stuff in my ~/public_html would be cool, but I don't know how I'd do it, so I thought I'd see how you did it.
09:25:21 <shapr> Sounds useful.
09:25:48 <glen_quagmire> I wrote this function: sex :: (Male a) -> (Female b) -> a
09:25:54 <lament> i'm a bit fuzzy on the details myself
09:26:10 <lament> guess type based on extension, ask the user to fill in a basic description
09:26:25 <lament> then generate an html page with a list of files for each type
09:26:40 <Botje> glen_quagmire: ITYM sex :: (Adult a) -> (Adult b) -> Maybe (Either a b)
09:26:49 <lament> track files by md5 so you notice when they simply get renamed, and keep the old info
09:27:26 <lament> by md5 and inode actually
09:27:34 <glen_quagmire> hah Botje
09:28:13 <roconnor> glen_quagmire: what are you doing with people's sex?
09:28:40 <Vulpyne> Giggety.
09:29:07 <glen_quagmire> that sex funciton can be useful for game of life
09:29:18 <lament> shapr: better tell me this. You have two files, a.txt and b.txt. You open both in an editor, swap their contents and save them. Would you say the files were renamed, or that their contents changed, or that the new files are independent from the old files? :)
09:29:44 <roconnor> glen_quagmire: conway's life, or that board game?
09:30:36 <oerjan> lament: if they have different permissions, then the effect may actually be different
09:31:06 <lament> for extra fun, we can afterwards swap their filenames, too.
09:31:25 <lament> and perhaps permission flags if you wish :)
09:32:06 <oerjan> lament: aiming for the equivalent of referential transparency?
09:32:18 <lament> a simpler statement of the problem is: we create a new file, copy all content from the old file, and delete the old file.
09:32:52 <lament> mutability introduces all sorts of object identity problems :)
09:33:34 <glen_quagmire> roconnor: conway's life
09:33:49 <ivant> glen_quagmire, I don't remember a notion of sex there :-)
09:33:49 <oerjan> lament: indeed. what if there were other hard links to the same file...
09:33:52 <roconnor> glen_quagmire: Aren't the cells sexless?
09:33:59 * glen_quagmire loses
09:34:39 <lament> oerjan: or just copies. That's another issue.
09:35:47 <oerjan> lament: i suggest the only proper solution is to create a custom monad to model and experiment with the problem ;)
09:36:19 <lament> silly haskellers, "create a monad" is their solution to everything :)
09:36:40 <oerjan> lament: i was just trying to get back on topic
09:36:57 <oerjan> you could try with an arrow if you want
09:37:04 <lament> fine, fine
09:38:47 <Tac-Work> I think I should write a monad which writes other monads
09:39:31 <oerjan> i never meta-monad i didn't like
09:39:46 <glguy> @slap oerjan
09:39:46 * lambdabot slaps oerjan
09:40:04 <oerjan> ouch :D
09:52:27 <mrd> lament: except when "create an Arrow" is the solution
09:54:43 <glen_quagmire> yay gtk2hs compiled when I used -O0 option
09:58:45 <glguy> is there a good way to "trim" (remove leading whitespace) a string in the shell
09:59:08 <Vulpyne> sed 's/^ *//g'
09:59:29 <oerjan> i don't think you need g
09:59:41 <Vulpyne> That's probably true. Habit.
10:02:09 <oerjan> also, that may trim whitespace from each line, if that is a problem
10:04:42 <glguy> I ended up using ^\s*
10:04:48 <glguy> but that does exactly what I needed
10:41:53 <glen_quagmire> i'm making gtk2hs package. I built it using --without-pkgreg . in the post installation script for the package, how do I register it to GHC?    ghc-pkg register /path/to/gtk2hs/imports/glib/System/Glib.hi   ?
10:43:27 <glen_quagmire> oh i think it's .conf file.. i was looking for .cabal file
10:45:08 <shapr> Ya know, I'd like to have lambdabot show all the darcs patches I've submitted to various community projects, that would be nifty.
10:46:26 <sjanssen> it'd be really neat if http://www.ohloh.net supported darcs
10:46:28 <lambdabot> Title: Ohloh, the open source network
10:47:10 <glguy> what is the purpose of the 'x' in [ "x${SOME_VAR}" = "xSOME_VAL" ]
10:47:11 <glguy> ?
10:47:16 <glguy> (bash script)
10:48:03 <oerjan> perhaps to make sure it's a string and not number comparison?
10:48:15 * earthy nods
10:48:21 <earthy> but not only that
10:48:46 <earthy> it's also to make sure that the variable expansion for ${SOME_VAR} does not result in the empty string
10:48:49 <Vulpyne> To make sure the left side can't expand to blank.
10:48:59 <Vulpyne> But since there's the quotes, it's kinda not necessary.
10:49:02 <glguy> what is the consequence of a blank left side?
10:49:03 <earthy> for that may well break the implementation of test
10:49:16 <Vulpyne> [ = "SOME_VAL" ] is an error.
10:49:48 <glguy> but "" = "SOME_VAL" is ok?
10:49:54 <Vulpyne> Yeah.
10:50:01 <Vulpyne> Some people just get in the habit of doing it that way.
10:50:05 <Vulpyne> Even if they quote the string.
10:50:05 <earthy> glguy: may be okay, depending on which particular instance of bourne-like shell you have
10:50:14 <glguy> hm, ok
10:50:16 <glguy> just curious
10:50:26 <earthy> Vulpyne: you haven't yet run into almost-standard implementations of the bourne shell, have you?
10:51:02 <Vulpyne> Bash or bust!
10:51:05 <earthy> ghe
10:51:20 <earthy> busybox ships with 3 versions of its shell
10:51:37 <earthy> they are somewhat sh compatible... for differing values of somewhat
10:51:43 <earthy> whole worlds of pain there. ;)
10:51:46 <shapr> sjanssen: Yeah, I agree.
10:52:01 <shapr> sjanssen: But it wouldn't be too hard to write our own.
10:52:24 <sjanssen> dons already has some stuff that comes close
10:52:31 <pejo> Vulpyne, or take /bin/sh in Solaris. I bet the older AIX and HP-UX shells are somewhat broken too.
10:53:23 <wli> The pain in/around shells is really signal and tty handling.
10:53:49 <wli> This is not even considering line editing.
10:59:17 <shapr> sjanssen: Is his code online?
10:59:43 <fasta> What's a fast way to pass alternating False and True to a loop? I.e. a function that should be executed in the loop should first execute with the argument False, and then with True etc. I can zip (infinite_list_false_and_true) other_args and then apply foreach, but I would like to eliminate the list completely.
11:00:15 <wli> cycle [False, True] seems plausible.
11:01:35 <fasta> wli: did you read that last part of the last sentence?
11:01:45 <xerox> > let f x n | n > 0 = (n,x) : f (not x) (n-1) | otherwise = [] in f True 10
11:01:47 <lambdabot>  [(10,True),(9,False),(8,True),(7,False),(6,True),(5,False),(4,True),(3,False...
11:02:11 <fasta> I wonder what's faster.
11:02:46 <wli> Just pass the arg. Deforestation can handle it.
11:04:48 <mrd> deforestation is killing millions of endangered cons cells
11:05:11 <thetallguy> those things grow like weeds
11:05:15 <oerjan> @remember mrd deforestation is killing millions of endangered cons cells
11:05:15 <lambdabot> Done.
11:06:04 <thetallguy> I have some that mutated into cosn cells
11:06:12 <thetallguy> and now my screen is all wavy
11:06:19 <fasta> My profile shows all black with "OTHER" costs.
11:06:26 <fasta> That's good, I guess.
11:08:58 <byorgey> @botsnack
11:08:58 <lambdabot> :)
11:09:14 <byorgey> oh no!  lambdabot!
11:09:28 * byorgey sobs
11:09:43 <SamB> what?
11:11:20 <oerjan> @boss
11:11:20 <lambdabot> Maybe you meant: b52s docs
11:11:26 <byorgey> !
11:11:37 <byorgey> lambdabot's a bit laggy today...
11:12:02 <oerjan> not to me
11:12:19 <oerjan> not that much
11:12:31 <byorgey> oh... maybe it's byorgey's internet connection that's laggy?
11:12:56 <oerjan> definitely not enough to sob about, anyhow :)
11:12:59 <byorgey> weird... when I typed @botsnack it took about two minutes for the :) to show up
11:13:30 <oerjan> oh? i saw them within seconds, i think
11:13:57 <oerjan> not quite sure, since i wasn't really paying attention
11:14:35 <byorgey> no matter, all is right with the world once more
11:14:39 <byorgey> @botsnack
11:14:39 <lambdabot> :)
11:19:13 <shapr> Monads turn break action into full auto.
11:19:48 <shapr> Does main-is: handle hs-source-dirs ?
11:21:40 <glen_quagmire> why is that type of foldl and foldr are different?
11:22:16 <fasta> glen_quagmire: because otherwise the replace with ':' method doesn't work anymore.
11:22:22 <Vulpyne> HappS doesn't support SSL, does it?
11:22:26 <glen_quagmire> it seems like arguement order is different for the function passed to foldl/r
11:22:38 <fasta> glen_quagmire: that's because it is different
11:22:59 <shapr> Vulpyne: It would support ssl behind apache, but it doesn't support SSL directly. I don't think it would be hard to add though.
11:23:14 <Vulpyne> Ah.
11:23:16 <glen_quagmire> oh i see. (:)  is   list_element : accumulator
11:23:22 <Vulpyne> Hmm, I guess I wanted to do outgoing SSL connections, actuall.
11:23:22 <Vulpyne> y
11:23:24 <conal> @pl \ m g -> m >>= \ x -> g x >> return x
11:23:24 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
11:23:31 <Vulpyne> I really wish there was something like Twisted for Haskell. :(
11:23:33 <conal> ick.
11:23:34 <glen_quagmire> so, any other function f should be    f list_element accumulator
11:23:35 <oerjan> glen_quagmire: it's so that if the argument is a function you can just place it between the list elements, with the initial element at the proper end
11:23:58 <oerjan> and parentheses stacked correctly
11:24:09 <fasta> oerjan: if the argument is a function? What argument isn't a function?
11:24:14 <oerjan> *function = operator
11:24:24 <oerjan> typed the opposite of what i meant
11:24:26 <thetallguy> conal: that really is ugly
11:24:40 <shapr> Vulpyne: http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/ should be easy to integrate, especially since the author hsgnutls wrote much of the core HAppS code.
11:24:42 <lambdabot> Title: hsgnutls
11:24:50 <conal> @ty \ m g -> m >>= \ x -> g x >> return x
11:24:53 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> m a
11:24:58 <Vulpyne> shapr: Thanks.
11:25:02 <conal> @ty \ m g -> m >>= g `mappend` return
11:25:04 <lambdabot> forall a (m :: * -> *). (Monoid (a -> m a), Monad m) => m a -> (a -> m a) -> m a
11:25:17 <conal> better.  hm.  less general type.
11:25:18 <glen_quagmire> hrm i don't think I don't understand foldl/r fully
11:25:20 <oerjan> e.g. foldl (-) 1 [2,3,4] = ((1-2)-3)-4, foldr (-) 1 [2,3,4] = 2-(3-(4-1))
11:25:45 <conal> oh -- because (>>) discards info.
11:26:40 <conal> i'd like to see (>>) have type m () -> m a -> m a, for better type-checking.
11:26:56 <conal> and use `mappend` instead for monoidal accumulation.
11:27:03 <fasta> How can I surpress the redundant import warnings that result from a call to a CPP macro?
11:27:07 <glen_quagmire> oerjan: is that all one needs to know? it says foldl is more efficient. I'm not sure why
11:27:20 <fasta> suppress*
11:27:56 <oerjan> conal: and use an ignore :: m a -> m () operator like in ocaml?
11:28:06 <thetallguy> @ty (>>)
11:28:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:28:20 <fasta> If I could mix import statements there wouldn't be a problem.
11:28:21 <conal> oerjan: yes: fmap (const ())
11:29:00 <thetallguy> conal: wouldn't that defeat the purpose?
11:29:11 <conal> whenver i use (>>) on a more general type, it turns out to be a bug that gets past the type-checker.
11:29:15 <fasta> conal: that would be horrible
11:29:27 <conal> thetallguy: which purpose is that?
11:29:32 <oerjan> glen_quagmire: foldl', not foldl, or you lose most of the efficiency unless the compiler can deduce strictness
11:29:41 <thetallguy> conal: it's purpose is to throw away that information
11:30:07 <conal> thetallguy: maybe there are two purposes, and we can separate them.
11:30:16 <thetallguy> conal: it's purpose is to implement sequencing only
11:30:45 <conal> thetallguy: another is to elide the "\ () ->"
11:30:50 <thetallguy> conal: which is why I never use it
11:30:58 <thetallguy> conal: so I see your point
11:31:05 <EvilTerran> i see where you're coming from, conal, but it'd be contraversial. you could, perhaps, use a (>>!) operator of your own devising or something
11:31:12 <thetallguy> conal: yes.
11:31:41 <conal> EvilTerran: yes, I could.  The bummer is that do notation desugars into >> and not >>!
11:31:46 <thetallguy> conal: The purpose is to implement only sequencing
11:31:46 <eivuokko> Maybe there the (>>) (and it being in Monad class) have something to do with desugaring do and efficiency (at that time)?
11:31:55 <thetallguy> conal: the elision is there for brevity
11:32:03 <SamB> conal: at least you can't throw out the information and then accidentally pull something out of your ass instead of using the information like in C
11:32:20 <conal> eivuokko: do you mean a third purpose of keeping constant stuff out of a lambda??
11:32:40 <EvilTerran> conal, otherwise it'd have to desugar into an equivalent, but uglier, construct.
11:32:48 <thetallguy> conal: I guess I don't fully understand what you want the type checker to do here?
11:32:53 <conal> thetallguy: agreed.  i like the brevity, and i'd like better static checking.
11:32:58 <thetallguy> conal: warn you that you are throwing info away?
11:33:11 <conal> thetallguy: exactly
11:33:23 <glen_quagmire> :t foldl'
11:33:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:33:28 <thetallguy> conal: isn't that the same roughly as an _ in the pattern world?
11:33:39 <EvilTerran> unless you want to require all lines with implicitly discarded results in do{}s to return ().
11:33:44 <thetallguy> conal: oh, I see, no, it's more like an unused reference
11:33:47 <conal> and if i want to throw away info, i use the general tool of const (), rather than a monad-specific tool.
11:33:53 <glen_quagmire> how come my GHCi doesn't know foldl' ?
11:34:01 <int-e> glen_quagmire: import Data.List
11:34:04 <fasta> glen_quagmire: :m + Data.List
11:34:08 <EvilTerran> thus requiring an explicit ignore function. as others've mentioned, it's a brevity vs sanity checking thing...
11:34:24 <shapr> :t foldl'
11:34:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:34:31 <shapr> @index foldl'
11:34:31 <lambdabot> Data.List
11:34:34 <oerjan> thetallguy: ocaml does this with it's ; operator, if the first argument does not have type () it gives a warning
11:34:35 <EvilTerran> conal, you might be able to do something with -fno-implicit-prelude, but it'd be ugly.
11:34:37 <thetallguy> conal: so you again lose the brevity
11:34:56 <glen_quagmire> oh now it knows thanks
11:34:57 <thetallguy> oerjan: yes
11:35:00 <oerjan> *() = unit
11:35:04 <Heffalump> apart from compiler warnings, you don't get complaints when you throw away values in pure code, normally
11:35:26 <thetallguy> conal: I guess that explains why I never use (>>)
11:35:26 <eivuokko> conal, Hmm?  I've just assumed (>>) is an artifact of efficient do-translation.  Not sure if lambda would be the source of such problems.
11:35:32 <SamB> conal: where have you actually done this?
11:35:57 <conal> SamB: lost valuable info?
11:36:06 <thetallguy> but I imagine that I've used the equivalent in do notation often
11:36:07 <SamB> forgot to use it
11:36:19 <EvilTerran> it seems to me that typing >> instead of >>= should be a type error in most cases
11:36:34 <SamB> and couldn't you just as easily have bound a variable but forgotten to use it?
11:36:59 <conal> SamB: when i forget to use a bound var, ghc tells me.  and i'm glad.
11:37:18 <SamB> so you'd be happy if a warning could be devised?
11:37:21 <fasta> I think an electro-shock when you forget something works better.
11:38:20 <conal> fasta: please file that feature request with the ghc folks.  but make it optional, okay?  ;)
11:38:37 <SamB> yeah.
11:38:42 <SamB> not everyone has the hardware for that
11:39:00 <conal> SamB: sure, a warning would be enough.
11:39:11 <conal> SamB: even off by default.
11:39:19 <SamB> have you created a ticket?
11:39:24 <segher> everyone who lets me install hardware for them has hardware for it :-)
11:39:32 <Eelis> i would like such a warning
11:39:33 <conal> SamB: areyou asking me or fasta?
11:39:39 <SamB> conal: you
11:40:02 <evir> Huh? Could not find module `Control.Monad.Error'
11:40:07 <evir> Where do I get that from?
11:40:36 <eivuokko> evir, mtl
11:40:51 <conal> SamB: i don't know how the warning idea could work.  (>>) is not built-in language magic.  It's just a method.
11:40:56 <evir> eivuokko: mtl?
11:40:59 <thetallguy> conal: why are you using (>>)?
11:41:20 <eivuokko> evir, package named mtl
11:41:27 <evir> eivuokko: Ah, thank you.
11:41:39 <fasta> Is there a project transformation that removes all unused imports?
11:41:40 <conal> thetallguy.  i'm not.  it comes out of do notation.  which i also rarely use now that i'm into applicative.
11:41:48 <thetallguy> conal: I still don't see why you would use it in place of (>>=)
11:41:53 <thetallguy> conal: ah
11:42:04 <thetallguy> conal: yes, now I understand
11:42:06 <fasta> Who said Real Programmers don't need refactoring tools...
11:42:43 <thetallguy> conal: so rephrased, you would like a warning if any generated valud in a do doesn't get used?
11:43:15 <Heffalump> all he needs is a new warning in GHC if you use m a where a isn't () as the LHS of a >>
11:43:18 <eivuokko> Except ()?
11:43:20 <conal> thetallguy: yeah.  it comes down to that.  if i used (>>), i'd want the same.
11:43:26 <thetallguy> conal: I'm glad to hear that about the do/applicative.  I'm intending to follow you down that path soon
11:43:37 <Heffalump> (with appropriate translation back if it came from a desugared do)
11:44:21 <glguy> conal: I'm trying to figure out what's going on from the backlog... are you saying that getLine >> getLine  should cause a warning?
11:44:22 <conal> thetallguy:  i'm delighted with applicative.  so very elegant.  and inherently more optimizable than monads.  i'd be happy to answer questions.
11:44:25 <thetallguy> conal: I expect to write some combinators that spit out actionscript graphics objects and I think this issue will come up
11:44:49 <thetallguy> conal: excellent.  I will be talking more with you.
11:44:57 <thetallguy> conal: by the way, this is Cliff Beshers
11:45:03 <conal> thetallguy: oooh!  i'm very interested in that application.
11:45:12 <conal> thetallguy:  Cliff!!
11:45:34 <thetallguy> conal: yes, I'm sure.  Things will be picking up in the graphics department
11:45:46 <thetallguy> conal: I'm no longer at Linspire
11:45:49 <conal> thetallguy: what are you up to?  you left Linspire, right??
11:46:11 <thetallguy> conal: David Fox and I are starting a company to do math skills on the web for kids
11:46:29 <thetallguy> conal: you've been talking to stepcut
11:46:45 <conal> thetallguy: stepcut??
11:47:04 <conal> thetallguy: wow -- your app sounds very fun.  i don't know david.  perhaps i could help
11:47:20 <thetallguy> conal: Hmm... If not stepcut, then who told you about Linspire?
11:47:33 <thetallguy> conal: stepcut == Jeremy Shaw
11:48:19 <conal> thetallguy: i don't remember where i heard that you left.  i don't know jeremy either.  is he from linspire?
11:48:49 <thetallguy> conal: yes, he is still there.  The only other people I've told are Norman R and Jeremy G
11:49:05 <thetallguy> conal: not that it matters, but I'm curious
11:49:24 <thetallguy> conal: I've been meaning to get in touch with you about this.  David and I will be at ICFP
11:49:24 <conal> hm.
11:50:08 <conal> thetallguy: wonderful.  i'll be in Frieburg from Sept 25 thought Oct 7.  Staying at the Black Forest Hostel.
11:50:09 <thetallguy> conal: stepcut may have told someone else who told someone else.  Just curious about connections
11:50:24 <thetallguy> We arrive the 28th, I think
11:50:26 <thetallguy> Friday
11:50:44 <conal> staying for the hackathon?
11:50:47 <thetallguy> We're at someplace wiht a wonderful name
11:51:00 <thetallguy> conal: maybe Friday
11:51:25 <thetallguy> conal: we've promised to be in Munich sometime that weekend
11:51:37 <thetallguy> conal: well, I've promised.
11:51:44 <conal> thetallguy:; what's going on in munich?
11:51:55 <thetallguy> conal: oktoberfest!
11:52:49 <conal> thetallguy: oh! btw, what's your nick mean?
11:52:51 <thetallguy> conal: a friend will be there for oktoberfest, another is a professor there, and I want to visit the place since I was there for a college semester .
11:53:02 <thetallguy> conal: uhhh...
11:53:15 <conal> oh -- i misparsed!
11:53:21 <thetallguy> conal: lol
11:53:22 <conal> i read "theta"
11:53:33 <conal> :)
11:53:39 <thetallguy> conal: I was going to say, I must not have made much of an impression...
11:54:03 <thetallguy> conal: lol  Very amusing
11:54:16 <thetallguy> conal: what's your preferred email?
11:54:19 <conal> thetallguy: a different impression.  and favorable.
11:54:30 <thetallguy> conal @elliott.net or something?
11:54:54 <conal> thetallguy: see the bottom of http://conal.net
11:54:55 <lambdabot> Title: Conal Elliott's home page
11:55:23 <conal> thetallguy: IM info there also
11:55:29 <fasta> Does anyone of you mount /tmp on a ramdisk to speed up compilation?
11:56:05 <thetallguy> conal: good, I don't have to remember how many l's an t's in Elliott
12:07:51 <Eelis> can lambdabot show operator fixities?
12:08:11 <glen_quagmire> :t (+)
12:08:13 <lambdabot> forall a. (Num a) => a -> a -> a
12:08:17 <mauke> :i (+)
12:08:30 <mauke> @info (+)
12:08:31 <lambdabot> ((+))
12:08:34 <mauke> :(
12:08:55 <oerjan> mauke: @info is actually @undo, spell corrected
12:09:07 <mauke> hahaha
12:09:18 <mauke> makes "sense"
12:10:44 <EvilTerran> @index (+)
12:10:44 <lambdabot> Prelude
12:10:59 <eivuokko> Heh, that's nasty spell correction.
12:11:02 <oerjan> @list type
12:11:03 <lambdabot> type provides: type kind
12:11:50 <EvilTerran> @where Prelude
12:11:50 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
12:11:56 <glen_quagmire> what is fixities? infix vs. outerfix?
12:11:59 <glen_quagmire> i mean, prefix
12:12:04 <Eelis> so then, no way to query fixity? can i drop this in a suggestion box somewhere?
12:12:05 <EvilTerran> "infixl 6  +, -"
12:12:08 <mauke> infixl 6 +
12:12:24 <mauke> it works in ghci
12:12:43 <glen_quagmire> :i infixl
12:12:47 <paolino> can I use a parsec function to make an instance of Read ?
12:12:47 <oerjan> glen_quagmire: precedence and associativity
12:13:13 <glen_quagmire> hrm those aren't part of haskelll type
12:13:23 <shachaf> @where report
12:13:23 <lambdabot> http://www.haskell.org/onlinereport/
12:13:31 <glen_quagmire> :: a -> b -> c  -- no way to tell
12:13:48 <oerjan> glen_quagmire: fixities are declared with infixl, infix or infixr
12:14:13 <Tac-Work> Is there a way to defined + on functions such that f + g = \x -> f x + g x?
12:14:18 <Eelis> @todo-add Operator fixity querying.
12:14:18 <lambdabot> Entry added to the todo list
12:14:19 <Tac-Work> I'm getting type errors
12:14:20 <glen_quagmire> oh infixl was a keyword
12:14:30 <shachaf> Tac-Work: There's liftM2 (+).
12:14:33 <mauke> Tac-Work: for some functions, yes
12:14:42 <byorgey> Tac-Work: yes, you have to define a Num instance for functions.
12:14:43 <paolino> I tried http://sequence.complete.org/node/117 but it doesn't compile
12:14:46 <lambdabot> Title: instance Read a, given a Parsec parser | The Haskell Sequence
12:15:06 <mauke> basically, you can lift Num to Applicative
12:15:18 <oerjan> paolino: what error do you get?
12:15:25 <byorgey> Tac-Work: see http://www.haskell.org/haskellwiki/Num_instance_for_functions
12:15:26 <lambdabot> Title: Num instance for functions - HaskellWiki
12:15:42 <paolino>    Illegal instance declaration for `Read a'
12:15:42 <paolino>         (The instance type must be of form (T a b c)
12:15:42 <paolino>          where T is not a synonym, and a,b,c are distinct type variables)
12:15:42 <paolino>     In the instance declaration for `Read a'
12:16:10 <oerjan> paolino: sounds too general
12:16:27 <shachaf> paolino: Did you use -fallow-undecidable-instances?
12:16:40 <paolino> yes in the PRAGMA
12:16:55 <EvilTerran> Tac-Work, i think the approach would be something like instance Num b => Num (a -> b) where ....
12:17:01 <Tac-Work> "This article is in category Proposals in order to show people that this idea was already proposed, but that one should think twice implementing it."
12:17:13 <byorgey> Tac-Work: just using liftM2 (+) as shachaf suggests is probably a better idea though.
12:17:15 <Tac-Work> hmm
12:17:22 <Tac-Work> yeah
12:17:32 <byorgey> Tac-Work: right.  you can do it, but there are good reasons not to.
12:17:33 <Saizan> paolino: -fglasgow-exts?
12:17:44 <byorgey> Tac-Work: which is not to say you can't/shouldn't.
12:17:45 <EvilTerran> but, as others've mentioned, it'd be restricted. the first problem that springs to my mind is that you'd have to instantiate Read as well
12:18:02 <shachaf> paolino: It works if you add -fglasgow-exts.
12:18:05 <EvilTerran> although "read = const . read" might be sufficient
12:18:06 <paolino> shachaf  UndecidableInstances
12:18:56 <Tac-Work> Is there a reason 'read' throws an error instead of returning a Maybe?
12:18:58 <oerjan> EvilTerran: Num doesn't require Read
12:19:07 <oerjan> but Show
12:19:13 <shachaf> Tac-Work: there's reads.
12:19:15 <shachaf> @ty reads
12:19:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:19:43 <Tac-Work> yeah, I saw that yesterday
12:19:51 <mauke> Num requires Eq and Show for no good reason
12:19:56 <damg> is there a way to define a data type which is a subset of an existing one? e.g. natural numbers
12:20:07 <EvilTerran> sorry, Show. what am i talking about...
12:20:27 <EvilTerran> damg, unfortunately there's no easy way.
12:20:33 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
12:20:55 <EvilTerran> but you could create a newtype, and instantiate it to Num etc with bounds checking in all the methods.
12:22:07 <damg> EvilTerran, ok, thank you, I'll do an instance
12:24:17 <paolino> TypeSynonymInstances in the PRAGMA , thanks
12:25:27 <oerjan> > let x a b = (+ a $ b) in "Test"
12:25:28 <lambdabot>      The operator `+' [infixl 6] of a section
12:25:28 <lambdabot>         must have lower precede...
12:25:32 <oerjan> hah!
12:26:29 <sorear> @users
12:26:29 <lambdabot> Maximum users seen in #haskell: 411, currently: 408 (99.3%), active: 22 (5.4%)
12:27:02 <oerjan> > (+ a $ b)
12:27:03 <lambdabot>   Not in scope: `b'
12:27:16 <mauke> > (+ ?a $ ?b)
12:27:17 <lambdabot>  Parse error
12:27:23 <oerjan> > (+ 0 $ 0)
12:27:23 <lambdabot>      The operator `+' [infixl 6] of a section
12:27:24 <lambdabot>         must have lower precede...
12:29:21 <Winterstream> Hi everyone :)
12:30:02 <byorgey> hi Winterstream =)
12:33:05 <ivant> > (/2) $ 8
12:33:07 <lambdabot>  4.0
12:33:21 <ivant> wow, cool, prefix notation
12:33:43 <ivant> > ((/ 2) 8)
12:33:44 <lambdabot>  4.0
12:33:44 <EvilTerran> > (/ 8 2) -- hey look, lisp is a subset of haskell :D
12:33:45 <lambdabot>   add an instance declaration for (Num (t -> a))
12:33:51 <ivant> yep :-)
12:33:59 <EvilTerran> > ((/) 8 2) -- hey look, lisp is a subset of haskell :D
12:34:01 <lambdabot>  4.0
12:34:04 <EvilTerran> there we go. =p
12:35:45 <Tac-Work> That is such a syntax error in lisp
12:36:24 <EvilTerran> it was a joke anyway.
12:36:43 <byorgey> Tac-Work: true.  I don't think EvilTerran was claiming that lisp is a *syntactic* subset of Haskell. =)
12:36:48 <desp> actually, isn't every language a subset of lisp?
12:36:56 <desp> or lisp.
12:37:07 <shachaf> (let ((/ (lambda () /))) ((/) 8 2))
12:37:07 <Adamant> Turing completeness FTW
12:37:17 <shachaf> Tac-Work: Besides, it's not a syntax error -- the syntax is fine.
12:37:17 <Tac-Work> desp: even better, every language is a subset of every other language
12:37:19 <desp> Adamant: expressiveness-wise
12:37:46 <ivant> desp, I'd go as far as defining the equivalence classes then
12:38:32 <desp> this reminds me to learn template haskell
12:48:33 <glen_quagmire> if I want to query for avialable operations on Char, what should I do?
12:48:58 <mauke> read the docs for all installed libraries
12:49:04 <glen_quagmire> ?hoogle Char -> [Char]
12:49:08 <lambdabot> No matches, try a more general search
12:49:13 <Cale> http://haskell.org/hoogle/?q=Char
12:49:14 <lambdabot> Title: Char - Hoogle
12:49:24 <mauke> glen_quagmire: show, (: [])
12:49:54 <glen_quagmire> oh i thik i need String
12:50:16 <Cale> String = [Char]
12:55:58 <EvilTerran> @instances Char
12:56:00 <lambdabot> Couldn't find class `Char'. Try @instances-importing
12:56:05 <EvilTerran> buu
13:16:04 <opqdonut> nicest way to check for no duplicates in list?
13:16:12 <opqdonut> \xs -> length (nub xs) == length xs -- ?
13:16:30 <ari> ap (==) nub
13:16:31 <mauke> :t ap (==) nub
13:16:33 <lambdabot> forall a. (Eq [a], Eq a) => [a] -> Bool
13:16:37 <mauke> stereo!
13:17:00 <opqdonut> well yeah that's just nub xs == xs
13:17:03 <ari> Incidentally, that's the only place where I know how to meaningfully use ap :(
13:17:19 <mauke> :t nub >>= (==)
13:17:20 <Cale> ari: ap (,) is also handy
13:17:21 <lambdabot> forall a. (Eq a, Eq [a]) => [a] -> Bool
13:17:23 <Syzygy-> Does that really do it?
13:17:29 <Cale> > ap (,) (^2) 5
13:17:30 <lambdabot>  (5,25)
13:17:42 <Cale> > map (ap (,) (^2)) [-10..10]
13:17:43 <Syzygy-> > (ap (==) nub) [1,2,3,2,4] [4,2,3,2,1]
13:17:44 <lambdabot>  [(-10,100),(-9,81),(-8,64),(-7,49),(-6,36),(-5,25),(-4,16),(-3,9),(-2,4),(-1...
13:17:44 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Bool'
13:17:48 <Syzygy-> No wait.
13:17:52 <Syzygy-> > (ap (==) nub) [1,2,3,2,4]
13:17:52 <mauke> > ((^2) >>= (,)) 5
13:17:54 <lambdabot>  (25,5)
13:17:55 <lambdabot>  False
13:17:59 <kilimanjaro> I wish I knew what "nub" and "ap" were abbreviations of
13:18:00 <Syzygy-> Yeah, I guess it does.
13:18:10 <Syzygy-> kilimanjaro: ap would be apply or application. *guess*
13:18:15 <mauke> kilimanjaro: nub isn't an abbreviation AFAIK
13:18:18 <Cale> kilimanjaro: nub is not an abbreviation
13:18:34 <kilimanjaro> Let me guess, nub is the sound made by the act of nubbing?
13:18:38 <byorgey> "ap" is presumably an abbreviation for "apply"
13:18:38 <Cale> ap is short for apply
13:18:39 <ari> The stereo is strong tonight
13:19:02 <byorgey> @go define nub
13:19:04 <lambdabot> http://www.thefreedictionary.com/nub
13:19:06 <kilimanjaro> Haskell has concise syntax, you guys don't really need to start removing letters from words do you?
13:19:08 <conal> ap also opens the way to applicative functors!
13:19:11 <Cale> nub n.  3. The heart of a matter; the crux or central point of a discussion, argument, etc.
13:19:24 <Olathe> kilimanjaro: y
13:19:34 <kilimanjaro> Olathe, :)
13:19:57 <mauke> ITYM "k"
13:20:23 <Cale> 1834 S. SMITH Sel. Lett. J. Downing lxx. 205 That's pretty much the nub of the business. 1859 J. R. BARTLETT Dict. Americanisms (ed. 2) 297 The nub of a story is the point or gist of it. 1899 Scribner's Mag. 25 105/2 It's the nub of the whole matter. 1933 P. G. WODEHOUSE Heavy Weather viii. 166 The problem..is, how the hell is one to get it away from the blighter? Quite. That is, as you might say, the n
13:20:23 <Cale> ub? 1974 Times 22 Oct. 14/6 The nub of the judges' difficulty lay in..the claim..that the judge had no authority in law to give a direction binding on the press. 1999 Independent 3 June II. 11/5 Decide on the nub of your idea, then sell it doggedly to the people who you think could help.
13:20:47 <Cale> (usage examples :)
13:22:34 <Cale> kilimanjaro: the idea is that ap is largely used as an infix operator, so you want it to be short.
13:23:06 <Cale> return f `ap` x `ap` y `ap` z is the same as liftM3 f x y z (but obviously gives a generalisation)
13:24:16 <conal> as pure f <*> x <*> y <*> z is liftA3 f x y
13:24:43 <conal> (oops -- add in the z's)
13:24:49 <desp> @pl (\d i j k l -> liftM fromBool (f d i j k l))
13:24:49 <lambdabot> ((((fmap fromBool .) .) .) .) . f
13:24:51 <desp> ugh
13:24:53 <conal> liftA3 f x y z
13:25:22 <conal> desp: there's a really lovely way to look at that one
13:25:33 <desp> conal: huh?
13:25:39 <desp> @hoogle liftA3
13:25:40 <lambdabot> No matches found
13:25:49 <conal> desp: do you know about first & second?
13:25:57 <conal> @ty first
13:26:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:26:03 <conal> @ty second
13:26:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
13:26:08 <conal> @ty (.)
13:26:10 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:26:32 <conal> if you specialize first & second to the (->) arrow, then (.) has the same form
13:27:01 <conal> it directs functions into the result part of a function.  just as first & second direct functions into the fst & snd of pairs.
13:27:14 <desp> hmm
13:27:22 <desp> so how would this little bit of code look like?
13:27:26 <conal> see http://www.haskell.org/haskellwiki/DeepArrow
13:27:27 <lambdabot> Title: DeepArrow - HaskellWiki
13:27:57 <conal> like ((.).(.).(.).(.)) fromBool f
13:28:09 <Syzygy-> > first (+2) (2,3)
13:28:14 <lambdabot>  (4,3)
13:28:15 <Syzygy-> > second(*3) (2,3)
13:28:17 <lambdabot>  (2,9)
13:28:20 <desp> huh
13:28:33 <desp> that certainly does make an interesting graphic pattern
13:28:35 <conal> that's why i use "result" as a synonym for (.) in this kind of use.
13:28:45 <desp> but I'm not comfortable in using that in this code ;)
13:28:49 <desp> s/in/with/
13:29:38 <conal> desp: check out DeepArrow.  maybe you'll get comfortable.  mixing first, second & result in arbitrary compositions makes for a nice way of doing "deep editing" of values.
13:29:53 <conal> better yet, it generalizes way beyond functions, to "deep arrows"
13:30:23 <desp> as soon as I have some breathing time ;)
13:30:24 <conal> and is the theoretical basis of eros
13:30:27 <conal> @where eros
13:30:27 <lambdabot> http://conal.net/papers/Eros
13:30:29 <conal> desp: no prob
13:30:39 <desp> functional manipulation of images sounds quite interesting
13:31:09 <conal> desp: :)  it's a lovely fit.  the simplest approach imaginable to image synthesis & manipulation.
13:31:27 <conal> and way more expressive than conventional approaches.
13:31:55 <falconair> conal, i tried sending you a private message ... basically an apology for not getting back to you about algorithmic trading with app. functors
13:32:41 <conal> falconair: hm.  i missed your message.  no problem.  i have lots of stimulating things going on right now.  when you're ready, just let me know.
13:32:58 <arjanb> falconair: you need to identify with nickserv to be able to send pm's
13:33:08 <sorear> falconair: you can only send PMs if you are idnentified OR the target has umode +6
13:33:33 <falconair> cool, your work looks very interesting ... the scala folks are also coming out with an FRP framework ... using their for comprehensions
13:33:39 * sorear has umode +6, gets PMs from everybody, and has never seen one of those spams that supposedly motivated the restriction...
13:33:51 <pjd> sorear: ditto
13:35:54 <waern> falconair: cool.. have the scala folks built anything on top of that framework also?
13:35:59 <conal> btw, has anyone here read "Monads for incremental computing" (http://www.citeulike.org/user/conal/article/1554283 )?  it's another precursor to app functors
13:36:00 <lambdabot> Title: CiteULike: Monads for incremental computing
13:36:39 <conal> falconair: Scala & FRP?  do you have a pointer?
13:37:01 <falconair> conal: i didn't realize "Monads for incremental computing" was in any way related to app functors...gives m even more reason to check it out ... i read that paper in relation to "Incremental Algorithms" by Johan Jeuring
13:37:24 <falconair> sorry, no pointers for Scala FRP yet, the author of the dissertation will be releasing it shortly (I believe)
13:37:57 <ivant> ?ty ((.).(.).(.).(.))
13:37:59 <lambdabot> forall a a1 a2 b c a3. (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
13:38:33 <ivant> ?ty ((.).(.).(.).(.).(.)
13:38:35 <ivant> ?ty ((.).(.).(.).(.).(.))
13:38:35 <lambdabot> parse error (possibly incorrect indentation)
13:38:37 <lambdabot> forall a a1 a2 a3 b c a4. (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
13:38:48 <ivant> aha, I see where it's going
13:38:51 <pjd> ivant: yay for the dots
13:38:56 <conal> falconair: thanks for the ref.  i'll check it out.
13:39:53 <conal> ivant: nice, yes??
13:39:53 * ivant thinks there should be some cute haskell code obfuscater
13:40:08 <EvilTerran> it's called pl
13:40:17 <conal> ?ty (first.(.).second.(.).(.).first)
13:40:19 <lambdabot> forall d a d1 a1 a2 b c d2. (b -> c) -> (a -> (d1, a1 -> a2 -> (b, d2)), d) -> (a -> (d1, a1 -> a2 -> (c, d2)), d)
13:40:44 <pjd> dot (dot3, dot4 etc.) should be standardized
13:40:48 <EvilTerran> @pl \xs ys -> map (zip xs . repeat) ys
13:40:49 <ivant> EvilTerran, no, @pl is often easy and it doesn't obfuscate complete programs
13:40:49 <lambdabot> map . (. repeat) . zip
13:40:52 <conal> > let result = (.)
13:40:53 <lambdabot>  Parse error
13:40:58 <byorgey> @. unpl pl \x y -> y y x
13:40:58 <lambdabot> (\ b c -> ((\ d -> d) >>= \ e -> e) c b)
13:41:02 <falconair> conal: no problem, I've been trying to convince Johan to put out a functional pearl using his techniques...the paper I mentioned earlier is quite old and the notation is very difficult to read
13:41:03 <EvilTerran> that was a joke...
13:41:07 <Cale> It would be nice to have a Mathematica-frontend-like Haskell environment.
13:41:21 <EvilTerran> @let result = (.) -- conal
13:41:26 <lambdabot> Defined.
13:41:28 <conal> falconair: thanks for the warning.
13:41:30 <byorgey> how about unpl . pl ? =)
13:41:32 <conal> EvilTerran: thanks!
13:41:36 <xerox> Cale: definitely.
13:41:39 <waern> Cale: yes!
13:41:47 <EvilTerran> > result (*2) (+1) 6
13:41:49 <lambdabot>  14
13:41:52 <conal> ?ty first.result.second.result.result.first
13:41:54 <lambdabot> Not in scope: `result'
13:41:54 <lambdabot>  
13:41:54 <lambdabot> <interactive>:1:20: Not in scope: `result'
13:42:03 <Cale> Especially with the new "UI controls as values" approach. :)
13:42:04 <conal> hm
13:42:07 <EvilTerran> ah. yeah, ?type can't see ?let'd stuff
13:42:18 <Cale> I wonder how much trouble we'd be in to steal that idea :)
13:42:43 * monochrom contemplates Haskell programming using Wii and PS3 input devices, a la Mathematica.
13:42:51 <Cale> :)
13:42:52 <conal> why doesn't 'result' work?
13:43:20 <Cale> hmm, is @let broken?
13:43:22 <xerox> ?type result=(.) in first.result.second.result.result.first
13:43:24 <lambdabot> parse error on input `='
13:43:24 <conal> Cale: "the new "UI controls as values" approach. " ?
13:43:29 <xerox> let :)
13:43:47 * kaol considers using MaybeT in his code, just for the heck of it (monad transformers, eek, never used those before)
13:44:04 <Cale> conal: Are you generally familiar with mathematica?
13:44:06 <EvilTerran> Cale, i think someone's done something like that for haskell. built on top of wxHaskell, iirc.
13:44:18 <ivant> Cale, the bad thing about Mathematica frontend is that the editor there is not very good for writing programs. Although it is nice for typing mathematical expressions
13:44:32 <conal> Cale: i used it a bunch in 1989 but not much since
13:44:34 <xerox> ivant: it got really better in this last version. Really.
13:44:35 <Cale> ivant: It's gotten much better in that regard lately.
13:44:51 <kaol> am I right in thinking that IO can be the inner monad?
13:44:56 <Cale> ivant: It even colours variables differently depending on whether they're free or bound.
13:45:07 <conal> Cale: does it have functional UIs?
13:45:17 <ivant> xerox, Cale, is it any better on linux now? it was completely unusable when it was, I think, 5.2
13:45:18 <Cale> conal: It has something which is very FRP-like
13:45:34 <xerox> ivant: yup.
13:45:39 <conal> Cale: oh, yeah.  some kind of dynamic values that propagate.
13:46:05 <conal> Cale: and tie in to UIs.
13:46:07 <monochrom> Yes kaol. I use "CCT r IO a" all the time. "CCT" is the delimited continuation monad transformer. (package CC-delcont)
13:46:09 <ivant> anyway, I switched from Mathematica to Haskell for writing my thesis anyway
13:46:29 <xerox> ivant: the synhl for example is quite advanced, arguments change color as they are bounded or not. Visual hints for missing arguments, and so on.
13:46:36 <Cale> conal: As the simplest possible example, if you evaluate  Dynamic[x]  in the frontend, it will appear to evaluate to the current value of x, but what's really there is a box which the frontend keeps updated automatically with the present value of x.
13:46:47 <EvilTerran> Cale, have you seen Phooey?
13:46:51 <Cale> EvilTerran: yep
13:47:01 <ivant> xerox, in 5.2 the frontend was so buggy I couldn't even use it
13:47:05 <conal> ?type let result=(.) in first.result.second.result.result.first
13:47:07 <lambdabot> forall d a d1 a1 a2 b c d2. (b -> c) -> (a -> (d1, a1 -> a2 -> (b, d2)), d) -> (a -> (d1, a1 -> a2 -> (c, d2)), d)
13:47:26 <ivant> xerox, I mean, on linux. It was completely screwed up
13:47:37 <Cale> conal: This scales all the way up to things like plots. There are also controls, which take Dynamic values as parameters in order to manipulate the values which they view.
13:47:40 <augustss> @djinn (b -> c) -> (a -> (d1, a1 -> a2 -> (b, d2)), d) -> (a -> (d1, a1 -> a2 -> (c, d2)), d)
13:47:40 <lambdabot> f a (b, c) =
13:47:40 <lambdabot>     (\ d ->
13:47:40 <lambdabot>      case b d of
13:47:40 <lambdabot>      (e, f) -> (e,
13:47:40 <lambdabot>                 \ g h ->
13:47:42 <lambdabot>                 case f g h of
13:47:44 <lambdabot>                 (i, j) -> (a i, j)),
13:47:46 <lambdabot>      c)
13:47:52 <conal> there we go.  see how the string of first etc give a path in the type saying exactly where to direct a function.
13:47:53 <EvilTerran> crikey.
13:47:54 <xerox> ivant: on osx now the ui is native, on linux it is probably not, but mixes nicely
13:48:03 <conal> augustss: howdy!
13:48:14 <augustss> Hi Conal
13:48:27 <Cale> For example, Slider[Dynamic[x], {0,1}] will give a slider control which manipulates the present value of x.
13:48:38 <conal> about Phooey: i'm drastically simplifying the implementation and removing the arrows interface and maybe the monad one.
13:49:04 <ivant> xerox, I recall they used motif or something on linux
13:49:06 <SamB> xerox: by native do you mean "not written in Java"?
13:49:09 <Cale> Controls like that are first class values, and can be manipulated in the same ways that all expressions can.
13:50:01 <ivant> SamB, I wish they had the frontend implemented in Java. At least then I could make it work on my linux laptop
13:50:10 <ivant> s/could make/could have made/
13:50:20 <SamB> what other non-native ways are there to write it?
13:50:41 <conal> Cale: does mathematica separate controls and time-varying values cleanly?  for instance, let s = slider (...) in s + s.  one slider or two?
13:50:48 <ivant> SamB, write UI engine from scratch, I guess
13:51:28 <SamB> conal: I don't think you can do that cleanly without purity...
13:51:47 <Cale> conal: You'd get two sliders manipulating the same value. Actually, heh, you'd get 2 <slider>
13:51:55 <SamB> heh
13:52:11 <Cale> (because + is normal addition, and mathematica simplifies the expression blindly)
13:52:19 <SamB> why wouldn't it be 2<slider>
13:52:20 <conal> SamB: oh, i see.  the dynamic is an argument to Slider, saying what it's to side-effect.  :P
13:52:25 <Cale> right
13:52:33 <xerox> SamB: like this, hang on
13:53:03 <conal> Cale: which simplification would be mistaken.
13:53:22 <conal> i don't know how to clean up that confusion w/o monads, AFs, or arrows.
13:53:57 <kaol> hmm? is there no MaybeT in ghc 6.6.1's libraries?
13:54:08 <kaol> or am I looking at the wrong places...
13:54:10 <SamB> ivant: how is writing a toolkit from scratch any less native than ... well, anything?
13:54:15 <xerox> SamB <http://img403.imageshack.us/my.php?image=plotow2.png>
13:54:48 <samreid> kaol: no.  But http://www.haskell.org/haskellwiki/New_monads/MaybeT
13:54:49 <lambdabot> Title: New monads/MaybeT - HaskellWiki
13:54:58 <Cale> http://cale.yi.org/autoshare/Screenshot-Dynamic.png -- like this, as you drag the slider, the 3D plot updates in real-time.
13:55:23 <xerox> :)
13:55:30 <conal> Cale: very nice.  :)
13:55:39 <ivant> SamB, I wouldn't call UI native if it has its own window-/controls-drawing engine (as well as different user interaction behaviour)
13:56:06 <ivant> oh, cool
13:56:13 <SamB> ivant: ALL guis on Linux have this to some extent or other...
13:56:25 <conal> btw, more cheerleading for AFs.  we don't need AF transformers, because AFs compose, unlike monads.
13:56:50 <ivant> SamB, except for console-based programs (which are not gui-based, though)
13:57:12 <SamB> even aptitude!
13:57:15 <conal> with monads, we have Reader & ReaderT, Writer & WriterT, etc.  with AFs, just g `O` f.
13:57:29 <ivant> xerox, is it still hell to debug complex Mathematica programs?
13:57:40 <xerox> ivant: they seem to have a debugger.
13:57:42 <monochrom> Evail.
13:58:00 <wolverian> AF?
13:58:07 <conal> applicative functor
13:58:28 <ivant> xerox, they had Debug functions since, maybe 2.2 or even earlier, but they were completely unusable for any non-trivial purposes
13:58:29 <wolverian> thanks :)
13:59:21 <xerox> ivant: I'm not sure, ever debugged anything in Mathematica.
13:59:45 <ivant> xerox, that's one of the reasons I switched to haskell
14:00:15 <ivant> xerox, in haskell we have a cool type-checker
14:00:22 * xerox makes a screencast :)
14:00:57 * ivant waves hand hoping to get into the screencast
14:01:40 <Cale> ivant: I mostly do functional programming anyway, so there's not much use for a debugger there.
14:02:47 <ivant> Cale, so did I, but Mathematica is very sloppy in returning corner-case results, thus it was sometimes hard to track down, at what place exactly I get an empty list/head application
14:03:05 <conal> Cale: not a run-time debugger anyway. ;)
14:03:23 <Cale> yeah
14:03:42 <Cale> The evaluation mechanism is really crazy though :)
14:03:43 <ivant> Cale, I guess my coding style had some serious problems, but I couldn't come up with a good one, which would provably eliminate such bugs from my code
14:03:48 * kaol considers using ListT instead since it's already in ghc and it's almost like MaybeT
14:04:02 <Cale> kaol: Watch out, sometimes it doesn't produce a monad.
14:05:13 <llewyenoh> if i wanted to print the date (in the '+%A %m/%d %r'), should i be using System.Time or Data.Time? and what's the difference?
14:05:35 <llewyenoh> *in the format
14:05:42 <Cale> Data.Time.Format
14:06:06 <llewyenoh> ok, thanks
14:06:18 <Cale> The time libraries are fairly comprehensive, but currently are not completely integrated.
14:06:45 <Cale> System.Time has the standard (H98) time library with a few small extensions
14:07:04 <llewyenoh> ah, i see
14:07:06 <Cale> Data.Time has a large number of useful time and date manipulation stuff
14:07:25 <Cale> er, things :)
14:07:43 <llewyenoh> hm.....
14:07:48 <Baughn> I'm probably overlooking something obvious, but - how do I parse a timestamp back in from a string (on 6.6)?
14:07:59 <hpaste>  dozer pasted "where does Int come from?" at http://hpaste.org/2353
14:08:06 <dozer> weird - I'm getting a crazy error
14:08:12 <dozer> is it me being dumb (again)?
14:08:33 <Cale> getCurrentTime will get you a UTCTime which you can then use the formatTime function on
14:08:39 <EvilTerran> @kind Either
14:08:41 <lambdabot> * -> * -> *
14:08:50 <EvilTerran> Either needs two type parameters...
14:09:00 <Cale> EvilTerran: It might be partially applied there
14:09:22 <EvilTerran> Cale, not in the type sig for a value, surely?
14:09:22 <dozer> of course, but it's partially applied - gets attached to the 'a' of PU a
14:09:30 <llewyenoh> what's the difference between parseTime, readTime, and formatTime?
14:09:35 <Cale> EvilTerran: PU might take a functor as a parameter
14:09:59 <EvilTerran> oh, yeah, i see. i'm silleh.
14:10:21 <kosmikus> dozer: what's the type of unpickleDoc?
14:10:45 <Cale> llewyenoh: formatTime is for converting times into strings
14:10:58 <hpaste>  dozer annotated "where does Int come from?" with "with unpickleDoc" at http://hpaste.org/2353#a1
14:11:14 <llewyenoh> Cale: so i'm assuming that's the one i want?
14:11:23 <Cale> llewyenoh: parseTime and readTime are similar, except that parseTime gives a Maybe t value, whereas readTime will throw an exception if parsing fails.
14:11:30 <Cale> llewyenoh: yeah
14:11:49 <Cale> llewyenoh: er, similar to each other :) They're for turning strings into times
14:12:08 <kosmikus> dozer: is there a non-standard definition of trace in scope?
14:12:28 <llewyenoh> Cale: almost like a reverse formatTime?
14:13:12 <dozer> kosmikus: possibly - I don't explicitly import one
14:13:16 <Cale> llewyenoh: yes
14:14:10 <viklund_> Hello! How do I patternmatch a type constructors name?
14:14:22 <Cale> viklund_: f TyCon = ...
14:14:38 <Cale> viklund_: Or do you mean something else?
14:14:42 * wli wishes there were a time formatting thing that did the "right thing" for program timings by default.
14:14:59 <kosmikus> viklund_: a type constructor is a type, do you mean a data constructor?
14:15:03 <viklund_> I don't know yet, need to check the TyCon thing...
14:15:06 <viklund_> ahh, yes
14:15:14 <dozer> kosmikus: mentioning Debug.Trace.trace explicitly seems to have fixed it - thanks
14:15:23 <viklund_> kosmikus: yes
14:15:37 <kosmikus> dozer: you're welcome
14:15:39 <kosmikus> viklund_: then what Cale said ...
14:15:45 <Cale> viklund_: That was just the name of the data constructor to match
14:16:03 <Cale> (I probably should have corrected that naming issue as well ;)
14:16:18 <Cale> If you have
14:16:23 <Cale> data T = A | B | C
14:16:27 <Cale> then you can write:
14:16:29 <Cale> f A = 5
14:16:31 <Cale> f B = 7
14:16:35 <Cale> f C = 12
14:16:50 <Cale> Or is that not what you mean?
14:17:24 <viklund_> Kind of, I have data T = A {stuff} | B {possibly other stuff}
14:17:33 <Cale> okay
14:17:36 <viklund_> and only want to know if it's an A or a B
14:17:44 <Cale> ah, there's a nice trick for that:
14:17:52 <Cale> f (A {}) = ...
14:17:56 <Cale> f (B {}) = ...
14:18:13 <Cale> This is actually permitted, even if you didn't define T using record syntax.
14:18:24 <viklund_> Cale: Great! I'll do that then
14:18:26 <monochrom> Interesting! Nice.
14:18:44 * wli usually does f (A _) = ... ; f (B _) = ...
14:18:52 <llewyenoh> Cale: do i have to do anything special to get Data.Time.Format?
14:18:55 * dozer does as well
14:19:06 <Cale> wli: The only problem there is that it's annoying if the number of fields changes.
14:19:08 <llewyenoh> Cale: since importing it directly doesn't seem to be working
14:19:15 <wli> (insert additional underscores as-needed
14:19:15 <viklund_> see you later guys!
14:19:30 <Cale> llewyenoh: oh...
14:19:35 <Cale> llewyenoh: Which GHC version?
14:19:36 <wli> Cale: Yes, I see a distinct advantage in the record syntax.
14:19:41 <Cale> llewyenoh: It appears to be new.
14:19:51 <llewyenoh> 6.6
14:20:18 <wolverian> possibly you want to install libghc6-time-dev
14:20:21 <Cale> ah, Data.Time.LocalTime
14:20:45 <EvilTerran> Cale, does that work with parameterless constructors?
14:20:54 <Cale> EvilTerran: yeah
14:21:03 <monochrom> nullity
14:21:13 <ari> > 0/0
14:21:18 <lambdabot>  NaN
14:21:34 <ari> > 0^0
14:21:35 <lambdabot>  1
14:22:02 <llewyenoh> Cale: ah, ok, it finds that, but i'm having trouble figuring out what to pass to formatTime
14:22:07 <Cale> I really like that Haskell largely gets 0^0 right. (Modulo issues with Complex)
14:22:31 <SamB> Cale: I think that's probably a bug
14:22:33 <sjanssen> > 0**0
14:22:35 <lambdabot>  1.0
14:22:47 <sjanssen> > 0**0 :: Complex Double
14:22:48 <lambdabot>  NaN :+ NaN
14:22:58 <sjanssen> > 0^0 :: Complex Double
14:22:59 <roconnor> > exp (log 0 * 0)
14:22:59 <lambdabot>  1.0 :+ 0.0
14:23:01 <lambdabot>  1.0
14:23:01 <Cale> http://www.haskell.org/ghc/docs/6.6/html/libraries/time/Data-Time-LocalTime.html#v%3AformatTime
14:23:03 <lambdabot> http://tinyurl.com/24m4h5
14:23:07 <roconnor> > exp (log 0 * 0)
14:23:08 <lambdabot>  1.0
14:23:09 <SamB> Cale: unless that's actually ambiguous?
14:23:13 <roconnor> awsome!
14:23:15 <Cale> SamB: It's a spec-bug.
14:23:29 <SamB> Cale: spec bugs are bugs too
14:23:32 <Cale> right :)
14:23:39 <Cale> They're just worse
14:23:51 <SamB> yes
14:23:53 <llewyenoh> Cale: right, but where can i get a timelocale?
14:23:57 <SamB> because you have to argue intent!
14:24:32 <Cale> llewyenoh: If you click on TimeLocale there, you'll be sent to the documentation for that, and you should see defaultTimeLocale :: TimeLocale
14:24:34 <SamB> and if the committee is gone, that can also be problematic
14:25:14 <llewyenoh> Cale: oh, my bad. thanks
14:28:55 <dozer> @hoogle arrL
14:28:55 <lambdabot> No matches found
14:29:09 <dozer> :(
14:29:30 <Cale> And now... a definition from "The Age of Wire and String".
14:29:40 <Cale> Rare Waters, The:  Series of liquids containing samples of the first water. It is the only water not yet killed. It rims the eyes, falls from them during certain times, and collects at the feet, averting the clasp of hands, which are dry, and need it.
14:30:25 <monochrom> Is that a haskell program trying to get out.
14:32:43 <reffie> only the mediocre man is always at his best
14:35:12 <Cale> Rhetoric:  The art of making life less believable; the calculated use of language, not to alarm but to do full harm to our busy minds and properly dispose our listeners to a pain they have never dreamed of. The context of what can be known establishes that love and indifference are forms of language, but the wise addition of punctuation allows us to believe that there are other harms -- the dash gives the reader a cle
14:35:12 <Cale> ar signal that they are coming.
14:36:10 <monochrom> Does anyone know what is happening to Cale's computer? Is it gaining self-consciousness?
14:36:19 <lament> cale is trying to fail the turing test
14:36:19 <Cale> This is a great book. :)
14:36:30 <llewyenoh> could someone tell me what i'm doing wrong here?: http://hpaste.org/2354
14:36:52 <Cale> llewyenoh: getCurrentTime is an action, you have to run it
14:37:00 <greenrd> Cale: Did you by any chance find it while searching for boxes and bananas?
14:37:03 <Cale> llewyenoh: do t <- getCurrentTime
14:37:10 <Cale> and then putStrLn $ ...
14:37:20 <EvilTerran> main = putStrLn . formatTime defaultTimeLocale "+%A %m/%d %r" =<< getCurrentTime
14:37:30 <llewyenoh> oh, i see
14:37:43 <llewyenoh> thanks, both of you
14:38:06 <EvilTerran> greenrd, sounds like a monad tutorial in the making ;]
14:38:10 <lament> getAncientTime
14:38:20 <Cale> haha
14:38:47 <Cale> getCurrentThompson
14:38:53 <dozer> woot! I have a version of XmlPickle that reports errors on deserialization!
14:41:48 <Cale> greenrd: The whole book is written as a sort of report on aspects of a universe a few milligrams away from our own. The passages have the overall style of making sense, but it's as if the words are not content to mean what they usually mean, though they preserve many of their existing relationships to one another.
14:42:20 <greenrd> I see
14:42:26 <dozer> sounds like a certain category of novel
14:42:56 <sieni> Cale: a few milligrams of acid perhaps?
14:43:02 <greenrd> so you are looking for isomorphisms? ;)
14:43:03 <Cale> sieni: that was the idea, yeah
14:44:19 <Cale> There might not actually be a direct translation, but just reading the passages without thinking about them too closely has a kind of dreamlike aspect to it through which meaning is still conveyed.
14:46:48 <Cale> I suspect it's sort of an elegy to the author's brother.
14:49:41 <llewyenoh> why does %S return a number with decimal points after it?
14:49:54 <llewyenoh> isn't that the one that truncates the decimal?
14:50:28 <Cale> hmm
14:51:06 <Cale> that's a good question...
14:51:28 <Botje> ooh, i bugrepped that
14:51:40 <llewyenoh> so it's actually a bug?
14:51:44 <SamB> Text.Printf doesn't follow printf(3) very well yet
14:51:48 <Botje> apparently you're supposed to use a package on hackage instead of the GHC-provided one
14:51:59 <llewyenoh> ah, ok
14:51:59 <Cale> ah
14:52:02 <Botje> (time, iirc)
14:52:23 <SamB> oh, that's for time?
14:52:25 <SamB> sorry.
14:52:38 <shapr> I wonder if GHC will build on the Tilera cpu...
14:54:40 <EvilTerran> anyone else about who's familiar with the "data types a la carte" paper?
14:56:39 <ddarius> "we are on a bit of a sticky wicket"
14:56:39 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
14:58:22 * EvilTerran notices that his prime factor finding program is still crunching away, severl hours after he started it
14:59:57 <EvilTerran> so much for trying to factorise a certain hex number starting 09F9... I can't even remember why i wanted to do that; i just found a bit of haskell that did it in my dumping folder and spotted the memory leak that meant it died after a few minutes.
15:00:16 <EvilTerran> ...and so, having fixed that, ran it again. ;]
15:01:29 <EvilTerran> looks like it's been running full-tilt on one of my processors since then
15:02:58 <xerox> puff, pant, done.
15:03:18 <xerox> Now, where to upload a video...
15:03:40 <SamB> video?
15:03:52 <xerox> Right.
15:04:09 <SamB> what video?
15:04:16 <xerox> A screencast.
15:04:43 <SamB> how about google videos?
15:04:45 <wli> EvilTerran: What algorithm?
15:05:05 <xerox> Oh well.
15:06:16 <xerox> http://darcs.haskell.org/( {
15:06:16 <xerox> http://darcs.haskell.org/  {-1.1, 0.9},
15:06:16 <xerox>   {-1.4, 0.3}
15:06:17 <xerox>  } )ops
15:06:17 <lambdabot> Title: Index of /
15:06:19 <xerox> ...ops.
15:07:43 <ddarius> EvilTerran: So far Data Types a la Carte looks like a collection of well-known folklore.
15:10:49 <damg> what's the right way to convert an Integer to an Int?
15:11:06 <pjd> fromInteger?
15:11:26 <damg> ah, thank you very much
15:11:41 <pjd> the result can actually be any Num instance
15:12:19 <ddarius> fromIntegral
15:14:43 <damg> thank you
15:17:07 <phobes> Has anyone looked at augustss' post on quick sort?
15:17:15 <phobes> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
15:17:17 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2hq6cn
15:22:02 <mrd> phobes: what about it?
15:27:12 <greenrd> He's right you know.
15:27:32 <greenrd> The commonly-given example of quicksort in Haskell, isn't quicksort.
15:28:17 <wli> Eratosthenes likewise.
15:28:22 <bluestorm> :]
15:28:49 <DRMacIver> There is indeed an alarmingly large proportion of blatant lies among the common "Look, isn't Haskell awesome!!" examples given to newbies. ;)
15:29:08 <SamB> DRMacIver: I thought the sieve thing was just ignorance
15:29:17 <bluestorm> hm
15:29:19 <DRMacIver> SamB: Well, probably. A lot of them are. :)
15:29:37 <SamB> blatant lies are a lot different from ignorance
15:29:43 <bluestorm> the sieve one is dangerous because the complexity completely changes
15:29:45 <ray> that's because if you show people real awesome things, they won't know what you're talking about!
15:29:48 <DRMacIver> SamB: Ok. blatant untruths.
15:29:49 <bluestorm> but isn't this one harmless ?
15:30:00 <SamB> but I think we all realize the quicksort isn't quite the same
15:30:16 <augustss> but not all realize it
15:30:28 <bluestorm> i mean, maybe it isn't a "in-place array qsort" but it has the good complexity and feature most of the qsort ideas anyway, doesn't it ?
15:30:29 <ray> maybe it should be called quickishsort
15:31:01 <DRMacIver> (Other common untruths including the standard burbling about memoising, CSE and automatic parallelisation)
15:31:07 <ddarius> Here's my somewhat direct translation http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
15:31:09 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
15:31:31 <ihope> I think this shift/reset implementation is pretty simple.
15:31:41 <ihope> Apart from the obvious nontermination in reset.
15:31:51 <mrd> bluestorm: not really
15:32:05 <ihope> ...Well, that's not a non-simplicity so much as an inaccuracy. But I'll have to terminate it somewhere.
15:32:08 <mrd> first of all, quick sort requires a randomized pivot
15:32:46 <bluestorm> hm
15:32:55 <mrd> otherwise the worst-case is not guaranteed to be O(nlogn)
15:32:57 <bluestorm> aren't you talking of randomized quickosrt ? ^^
15:33:01 <bluestorm> hm
15:33:18 <bluestorm> randomized quicksort isn't guaranteed to be O(nlogn)
15:33:24 <DRMacIver> Surely randomising something can't change the *worst case* guarantee.
15:33:27 <augustss> mrd: you can't guarantee O(n log n) even with a random pivot
15:33:33 <SamB> oracle!
15:33:38 <augustss> you could pick the wrong one all the time
15:33:40 <mrd> you can on average
15:33:43 <DRMacIver> Because you can always have bad luck and choose exactly the wrong pivot. :)
15:33:49 <mrd> this is weird sounding
15:34:01 <mrd> saying things like that is not how you do randomized analysis
15:34:18 <augustss> you said worst case
15:34:19 <DRMacIver> You're talking about *expected* time. That's not the same as worst case...
15:34:22 <SamB> mrd: well if you want to be stastical you better use a real RNG
15:34:34 <SamB> and, yeah, that's not worst case anymore, it's true
15:34:38 <DRMacIver> By virtue of meaning something completely different. :)
15:34:39 <monochrom> ihope: how could you manage to get reset to nonterminate?!
15:34:49 <mrd> an attacker cannot figure out the worst case input of a randomized quick sort
15:34:58 <bluestorm> yes, but it exists, still
15:35:04 <SamB> mrd: that would be where you are wrong
15:35:10 <augustss> attacker?  We're talking worst case here
15:35:11 <mrd> ignoring pseudo random problems
15:35:11 <SamB> the attacker is allowed to use an oracle ;-)
15:35:30 <monochrom> Pointfree debates.
15:35:38 <augustss> yes
15:35:43 <ddarius> mrd: Having qsort run O(n^2) is hardly a DoS attack.
15:35:45 <samreid> If oracles are possible, then the RNG could use a counter-oracle.
15:35:57 <SamB> actually, the attacker is allowed to destroy all universes not giving the worst case
15:36:08 <DRMacIver> > fix ("you're wrong! No, " ++)
15:36:08 <bluestorm> :p
15:36:16 <bluestorm> "complexity theory : a game semantic"
15:36:16 <lambdabot>  "you're wrong! No, you're wrong! No, you're wrong! No, you're wrong! No, you...
15:36:23 <DRMacIver> monochrom: Something like that? :)
15:36:28 <monochrom> hahahaha
15:36:39 <LoganCapaldo> counter-oracle
15:36:41 <LoganCapaldo> hehehhe
15:37:05 <mrd> the O(nlog n) on randomized quicksort is a worst-case expected time bounds
15:37:10 <SamB> @remember DRMacIver <monochrom> Pointfree debates. <DRMacIver> > fix ("you're wrong! No, " ++)
15:37:10 <lambdabot> Done.
15:37:10 <LoganCapaldo> I'm going to have to find a way to use that in normal conversation
15:37:31 <monochrom> the oracle destroys all non-worst case worlds. the counter-oracle destroys all worst case worlds. what is left?
15:37:59 <ddarius> Peace and quiet.
15:38:21 <monochrom> I guess. No more pointfree debates.
15:38:22 <ray> > fix error
15:38:25 <lambdabot>  Exception: <<loop>>
15:38:25 <SamB> monochrom: the fact that both are imaginary?
15:38:33 <SamB> ray: hahahaha
15:38:39 <monochrom> hhahahahaha
15:38:42 <ray> it's a lot more impressive in ghci
15:38:57 <LoganCapaldo> Wait, I haven't done the fix error thing in the channel?
15:39:16 <LoganCapaldo> I so made that joke a while a go
15:39:19 <LoganCapaldo> to myself
15:39:20 <LoganCapaldo> alone
15:39:22 <SamB> ray: it's funnier here
15:39:22 <ray> i'm sure you've fixed plenty of errors
15:39:22 <LoganCapaldo> apparently
15:40:31 <mrd> the recurrence relation for randomized quick sort is: T(n) = (n-1) + (1/n) \sum_{i=0}^{n-1}{ T(i) + T(n-i-1)).
15:40:47 <SamB> ray: though there is a certain amount of humour involved in having the exception handler repeatedly re-raise the same exception...
15:40:57 <mrd> when you solve a closed form for that you get T(n) <= cn ln n
15:42:56 <mrd> and ddarius, you'd be surprised.  one time I compared a naive deterministic qsort to a randomized in-place version, and the difference was something like 2 orders of magnitude.
15:43:13 <augustss> mrd: I agree for expected time.  I don't know what you are really arguing about :)
15:43:23 <mrd> it's expected worst-case time
15:43:30 <ray> that introduction page compares lazy evaluation to unix pipes, completely sidestepping the issue of #%)&*@ buffering
15:43:45 <SamB_XP> mrd: asymptotic worst-case time
15:44:08 <augustss> mrd: yes.  But there is still a sequence that will give you O(n^2)
15:44:37 <wli> There's always heapsort for determinism.
15:44:39 <LoganCapaldo> This is why we just need to use radiix sort for everything
15:44:44 <LoganCapaldo> O(n) all the way
15:44:49 <samreid> lies
15:44:49 <LoganCapaldo> or counting sort
15:44:59 <DRMacIver> How about we stop using terms which we obviously can't agree on and instead go to definitions...
15:45:08 <augustss> O(n), but for a different way of measuring n
15:45:29 <monochrom> Like, is non-termination a side-effect?
15:45:49 <LoganCapaldo> I know, defining the ordering to be the order the container is in. then you get O(1) sorting
15:45:49 <augustss> good question!
15:46:30 * monochrom notes down: do not use "natural numbers" when DRMacIver is around...
15:46:45 <mrd> augustss: that's like saying "well, quantum theory predicts that you could teleported to timbuktu. the chance is only one in two hundred gazillion"
15:47:20 <ihope_> What's radix sort O(n) in?
15:47:28 <augustss> mrd: I'd agree with that statement
15:47:29 <monochrom> the number of things to be sorted
15:47:33 <DRMacIver> monochrom: I'm only saying this because they're obviously talking past eachother when I'm sure if they just defined their terms there would be no argument. ;)
15:47:39 <ray> logancapaldo: i'll implement that one in a library for you
15:47:41 <augustss> ihope: number of bits in the input
15:47:57 <ihope_> And already I've been given two different answers.
15:48:42 <monochrom> The two answers are proportional to each other, for each thing to be sorted has a fixed number of bits.
15:49:25 <monochrom> I mean all the things have equal number of bits.
15:49:35 <samreid> As you grow the number of distinct elements to be sorted, the number of bits grows as log(n).
15:49:47 <mrd> number of buckets, basically
15:50:18 <wli> There's also proxmapsort.
15:50:59 <SamB_XP> monochrom: OPTION BASE 0
15:51:32 <monochrom> Please don't remind me of BASIC. :)
15:51:44 <mrd> monochrom: epigram  talks about a monadic approach to general recursion, istr
15:52:48 <monochrom> Interesting!
15:54:01 * alar doesn't understand how general recursion can be approached with a monad
15:54:18 <Cale> alar: hmm?
15:54:43 <augustss> alar: the simple answer, take general recursion out of the language and then provide fix in a monad
15:55:03 <Cale> oh, I was missing context :)
15:55:03 <mrd> :t mfix
15:55:05 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
15:56:15 <DRMacIver> I'm not sure I follow what the monad operations would be...
15:56:32 <DRMacIver> Oh, is it just the identity monad with mfix attached?
15:56:36 <ddarius> DRMacIver: It's just the identity monad.
15:56:48 <DRMacIver> That's less exciting than I imagined. :)
15:57:02 <alar> augustss: do you mean "IO" monad? or something that encapsulates "outside world"
15:57:03 <ddarius> Though semantically it adds a "point".
15:57:25 <DRMacIver> (I suppose it couldn't be anything else though)
15:57:28 <DRMacIver> Ah, undefined?
15:57:32 <augustss> alar: no, just a monad with fix.  like the identity monad with fix
15:57:35 <Korollary> alar: iirc, not just IO
15:57:40 <ddarius> DRMacIver: Yes.
15:57:46 <xerox> DRMacIver: many monads are MonadFix.
15:58:06 * alar doesn't understand why monad is the right place to define fix
15:58:50 <ddarius> alar: It isn't necessarily, but it was effectively the monad Moggi was first looking at before he came to Notions of Computation.
15:58:59 <augustss> alar: it might not be the "right" way.  but this way, if you ever use fix you'll have a monadic type.  so you know that if there's a possibility of non-termination you'll have this monadic type
16:00:06 <Korollary> augustss: but, how do you take general recursion out of haskell? Doesn't its type system allow me to write my own fix?
16:00:15 * alar understands now
16:00:25 <alar> augustss: thank you
16:00:45 <ddarius> Korollary: Only with recursive types.
16:02:01 <Korollary> ddarius: so I still have general recursion on lists
16:02:02 <augustss> Korollary: you'd have to restrict recursive types too
16:02:25 <llewyenoh> can anyone tell me what function/libraries i need to use to set a timezone on a timelocale?
16:02:41 <Saizan> > let x = x in x -- is this recursive?
16:02:42 <lambdabot>  Exception: <<loop>>
16:02:51 <ddarius> Saizan: Clearly.
16:02:53 <mrd> @src fix
16:02:54 <lambdabot> fix f = let x = f x in x
16:02:54 <augustss> Saizan: yes
16:03:54 <Saizan> :t let x = x in x
16:03:56 <lambdabot> forall t. t
16:04:13 <augustss> Korollary: many recursive types are ok.  there are simple syntactic restrictions that give you many of the ok ones
16:04:19 <Saizan> ehm, as a type?
16:05:20 <augustss> Korollary: Haskell is clearly too far down the general recursion track to go back.  but in a new design you could
16:06:05 <wli> What's this for? Termination analysis?
16:06:32 <ddarius> @users
16:06:32 <lambdabot> Maximum users seen in #haskell: 411, currently: 380 (92.5%), active: 22 (5.8%)
16:06:42 <alar> yes, there is implicit fix in "let"
16:08:04 <Korollary> I suppose you can have that monad now and leave the responsibility of not using GR outside that monad to the users like the proof of monad laws for instances.
16:09:20 <augustss> wli: it's for stamping out the evil General Recursion! :)
16:10:12 <llewyenoh> how can i get the equivalent output of the UNIX date command in haskell? getClockTime returns UTC, i believe. the timezones are not applied.
16:10:29 <monochrom> Recall that in djinn the type "a -> b" means also a function that terminates.
16:11:05 <rc-1> http://paste.lisp.org/display/46447 check at bottom what this could be replaced with :)
16:11:13 <Korollary> llewyenoh: System.Time has some formatting functions iirc
16:11:17 <pjd> stupid question: what's an example use of the MonadFix List instance?
16:11:28 <sieni> llewyenoh: have you tried googling "unix date haskell"?
16:11:34 <pjd> i tried to wrap my head around it yesterday without too much success
16:12:17 <llewyenoh> sieni: yeah, but for some reason, mine's not taking a timezone
16:12:20 <ihope> Well, here's my completely untested shift/reset implementation, complete with nontermination in reset: http://pastebin.ca/664947
16:12:49 <llewyenoh> sieni: i already have a date being printed out, it's just in the wrong timezone
16:13:58 <Liskni_si> well, getClockTime returns the unix timestamp, more or less. there's no timezone in it at all, of course
16:14:17 <llewyenoh> Liskni_si: right, so how can i apply one?
16:14:34 <llewyenoh> Liskni_si: besides manually adding through addUTCTime, i mean
16:15:13 <Liskni_si> llewyenoh: the toCalendarTime should be the equivalent of localtime(3)
16:16:09 <llewyenoh> Liskni_si: ah, there we go.
16:18:40 <ddarius> pjd: I find using the mdo syntax more illuminating than using mfix directly.
16:28:43 <phobes> My reason for citing augustss' article was that I think that kind of code is a good example of why you should have macros in Haskell :)
16:29:31 <phobes> Compare that implementation to an implementation of quicksort in an imperative language ... it has alot of complicated plumbing
16:29:46 <phobes> (maybe not too complicated, but quick a bit of plumbing anyway)
16:30:19 <phobes> And I'm not sure there's anything more general about it than what could be extracted from an implementation in the imperative language
16:30:56 <ddarius> phobes: That code is specifically designed to look like and mimic the imperative code.
16:31:18 <phobes> ddarius: but imperative code isn't that ugly :)
16:31:41 <Tac-Tics> that depends
16:31:46 <phobes> with macros you could hide alot of the plumbing there
16:32:17 <ddarius> augustss: By the way, why not uncurry qsort'?
16:33:25 <ddarius> phobes: The plumbing of the algorithm or the plumbing of the "look like C-ness"?
16:33:47 <phobes> well, like ... "iLTj = i < (j :: E m i)"
16:34:19 <phobes> I had to stop and scratch my head to figure out what was going on
16:35:46 <phobes> I'm sure that's largely just Haskell inexperience, but I don't see any value added by this syntax compared to an imperative language...
16:36:16 <lament> augustss: the formatting on your blog is broken for me (firefox), by the way
16:36:24 <phobes> It's like an embedded imperative DSL with bad syntax
16:36:25 <dolio> The value is that you get to write most of your code in Haskell.
16:36:33 <SamB> phobes: well there isn't really any when we're just writing imperative code...
16:36:44 <ddarius> phobes: It's not trying to add value it's -only- trying to look like C.  Nevertheless it does add value, albeit not necessarily with respect to a decent imperative language.
16:37:23 <phobes> Sorry, I think I'm not communicating my point well - I understand the advantages of Haskell over the imperative language, even in this case
16:37:38 <phobes> you've encapulated the mutation
16:38:02 <phobes> but if you added macros to Haskell, it looks like you could have a *nice* embedded DSL for imperative code that had the same properties as that code
16:38:19 <phobes> except with more sane syntax for imperative work
16:38:23 <SamB> you may overestimate macros ;-)
16:38:24 <dons> isn't it just a fun exercise in how far you can push embedded syntax?
16:38:34 <Korollary> dons: not fun
16:38:55 * ddarius agrees with both SamB and dons on this.
16:39:03 <dolio> What was wrong with the line you posted? Are macros going to infer the type that GHC doesn't?
16:39:43 <dons> it is slightly common to add new syntax with a preprocessor, btw. harp does that (the fancy regex library)
16:40:23 <alar> dons: I'm sure I can't push embedded syntax farther than Oleg does
16:40:26 <phobes> dolio:  Think what that code would look like in an imperative language and you'll see the difference
16:40:37 <dons> alar: :)
16:40:58 <dolio> You mean 'iLTj = i < j'?
16:41:48 <ddarius> phobes: In most imperative languages that would look like 'iLTj = i < j' modulo any type annotation that may be necessary.
16:41:55 <DukeDave> Hey team, can anyone (karma on offer!) suggest a reason why hugs would complain "Ambiguous variable occurrence" cite 'Hugs.Prelude.or' as the other 'or' when I've got 'import Hugs.Prelude hiding or'... It troubles me :|
16:42:02 <phobes> Aren't i and j _integers_?
16:42:14 <phobes> Indices
16:42:41 <phobes> Any decent imperative language wouldn't have any trouble inferring the type of those variables
16:43:03 <phobes> The way monads are typed in Haskell isn't really that strong I think
16:43:07 <dolio> It wouldn't? How much type inference does C do?
16:43:15 <phobes> decent****
16:43:21 <phobes> I did say decent
16:43:36 <dolio> So, that's, what? C# 3.0?
16:43:42 <SamB> and which ones are decent?
16:44:05 <phobes> So I don't actually want to claim a decent one exists
16:44:15 <phobes> But haskell with nice syntax would probably be a good start
16:44:18 <SamB> C# 3.0 is the only one I've heard of that meets this restriction, yes...
16:44:28 <ddarius> Haskell does have nice syntax.
16:44:29 <phobes> C++ 0x has auto
16:44:35 <EvilTerran> DukeDave, have you tried it in ghc too?
16:44:41 <phobes> IMO Haskell doesn't have nice syntax for imperative work
16:44:53 <phobes> I do really like Haskell's syntax for functional code
16:45:04 <ddarius> Haskell is not an imperative language.
16:45:05 <dons> phobes: i think that's uncontested -- the syntax is optimised for functions
16:45:09 <DukeDave> EvilTerran, all, just sorted, apparently List exports 'or' as well :|
16:45:28 <phobes> I seem to recall someone (SPJ) saying that "haskell is the best imperative language in the world"
16:45:29 <EvilTerran> yeah, i was about to suggest hiding Data.List.or too
16:45:33 <dons> not mutable updates. and mutation is considered fundamentally unsound
16:45:41 <dons> so the lightest syntax, whitespace and . is given to composition and appication of functions
16:45:44 <ddarius> phobes: That's not contradictory...
16:45:48 <phobes> ddarius: true
16:45:56 <Tac-Tics> "return" isn't a good name either for the monad function
16:46:07 <Tac-Tics> once you realize "monads are sorta like imperative"
16:46:11 <dons> safest, most flexible, was the point I think. (first order actions! programmable monadic effects)
16:46:15 <Tac-Tics> it's easy to mess up with "return"
16:46:24 <SamB> Tac-Tics: ... so?
16:46:26 <EvilTerran> what about such things as http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html, ddarius? ;]
16:46:28 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
16:46:41 <phobes> I can follow that ... but it's kind of far from the most convenient for many imperative programming tasks
16:47:24 <lament> Tac-Tics: brown is not a good color for a bike shed.
16:47:38 <Tac-Tics> return doesn't return anything
16:47:40 <Tac-Tics> it packs it
16:47:42 <phobes> It also seems to me that Monads aren't typed strongly enough for what you'd want in an imperative language
16:47:42 <SamB> lament: hahahahahaha
16:47:57 <phobes> I don't see anyway to express state changing types
16:47:59 * EvilTerran wonders if he's come up with a good excuse for -fallow-incoherent-instances or whatevr it's called
16:48:20 <ddarius> EvilTerran: No, you have not.
16:48:35 <EvilTerran> it's still an excuse, i'm not denying that ;]
16:48:44 <monochrom> The "haskell is the best imperative language" quote is from http://research.microsoft.com/%7Esimonpj/Papers/marktoberdorf
16:48:45 <lambdabot> Title: Simon Peyton Jones: papers
16:51:47 <lament> btw am i the only one who thinks this is pathetic: http://haskell.org/haskellwiki/Comparison_of_functional_programming_languages
16:51:49 <lambdabot> Title: Comparison of functional programming languages - HaskellWiki, http://tinyurl.com/26neho
16:51:59 <SamB> lament: no!
16:52:11 <SamB> I think it is pathetic just by looking at the URL
16:52:15 <lament> it's linked directly from the intro to haskell page
16:52:27 <phobes> dolio:  BTW In defense of C, ...  "int i,j;" is a heck of alot easier to read than "iLTj = i < (j :: E m i)"  :)
16:52:30 <SamB> in particular, how it is in haskell.org/haskellwiki/
16:53:23 <ddarius> phobes: int i,j; isn't the same thing.
16:53:26 <dons> lament: hmm? its a very old table from the mid90s
16:53:46 <dons> lament: do you think its wrong?
16:53:53 <phobes> ddarius:  No, it's not, but that's how you'd do it in C
16:53:55 <monochrom> I don't understand the complaint.
16:54:07 <phobes> at no loss of generality AFAICT
16:54:08 <EvilTerran> er... those do completely different things...
16:54:41 <SamB> phobes: in C, you'd do it like this:
16:54:51 <SamB> int iLTj = i < j;
16:54:56 <dmwit> dons: Not necessarily wrong, just woefully incomplete.
16:54:57 <lament> dons: it's not about factual correctes, it's about the fact that that's what Introduction#Comparisons_to_other_languages links to.
16:54:58 <ddarius> phobes: Presumably it should be possible to put the type annotations at the binding sites.
16:55:06 <phobes> SamB:  No, in C there would be no point of creating a variable for iLTj... you'd just repeat i < j
16:55:16 <lament> dons: (and it's the only content of that section)
16:55:27 <ddarius> phobes: You can do that in augustss code too.
16:55:45 <phobes> ddarius: Yes, but the reason he made a variable is because that code that needs to be repeated has the ugly cast
16:55:48 <EvilTerran> phobes, given enough context, the type shouldn't be necessary in haskell either
16:55:50 <monochrom> A decent language, imperative or functional, is likely bound to admit a few undecidable types, and you will have to annotate.
16:56:20 <phobes> .... we're talking about inferring that the loop variable is an integer... this isn't the halting problem
16:56:37 <SamB> phobes: have you tried it the way you'd like it to be?
16:56:45 <timthelion> would it be possible to make/already has been, a pure piping system for haskell, so that you could compile an executable that instead of returning X() would return some pure data that could be piped to another precompiled program?  this would be identical to a directory with a tone of .o files and one .hs that contained includes, and main = function . function .funcion... except that you could add a function defined in one
16:56:50 <EvilTerran> even if it requires more type information than you'd provide just as you go along, there's usually more elegant ways of adding inferences than that.
16:56:51 <phobes> SamB:  No - does it work?
16:57:10 <SamB> phobes: I'm not sure
16:57:11 <phobes> SamB:  I have been working under the assumption that the code needed to be structured like this for a reason
16:57:18 <ddarius> phobes: Why do you keep saying integer.  Does E m i look like Int to you?
16:57:35 <SamB> that's another good point
16:57:43 <EvilTerran> timthelion, sounds like you'd need some kind of general serialization system
16:57:52 <SamB> this code does buy you polymorphism that you'd need to use at least C++ to get...
16:58:10 <timthelion> EvilTerran: that would defeat the purpose of strict typing :(
16:58:11 <phobes> ddarius:  If those variables aren't integers, can you tell me what value this generalization gets me?
16:58:26 <phobes> Those would be integer loop indices in C.  What else could they be? and why is that helpful?
16:58:34 <EvilTerran> not necessarily, with Typeable you should be able to encode the type in the frozen form
16:58:43 <ddarius> phobes: It will run in a variety of monads and for a variety of array index types.
16:58:59 <SamB> ddarius: phobes has got a point though
16:59:13 <phobes> ddarius:  Fair enough.  In "templatized" C++ code, that would translated to "IndexType i,j"
16:59:28 <phobes> The rest would look the same
16:59:31 <lament> premature generalization sounds almost as bad as premature optimization
16:59:47 <monochrom> Naw. Premature specialization is the evil one.
16:59:53 <SamB> but Ix doesn't work in reverse so it is USEFUL
17:00:02 <SamB> even if it doesn't seem like it ought to be necessary
17:00:06 <timthelion> EvilTerran: It's possible for a C program to pass a pointer to a peice of memory.  if there was some kind of deamon that would keep the memory without needing serialisation...
17:00:41 * EvilTerran envisages class Freeze a where { freeze :: a -> ByteString; thaw :: ByteString -> a }; instance Data a => Freeze a where...
17:01:38 <EvilTerran> timthelion, **boggle**. i lack sufficient knowledge of OSes to even start to know how that works in the context of protected memory etc.
17:01:42 <timthelion> EvilTerran: but isn't that just copying a string of bytes to an enumerable string of bytes so that they may be transfered to a file or over a network stream?
17:01:43 <SamB> monochrom: have you heard of yagni? now it's a bit less applicable when it comes to FP since sometimes generality actually makes code easier to write...
17:01:54 <SamB> (by removing confusing specifics from the picture ;-)
17:02:10 <EvilTerran> but it sounds like, modulo that, what you're saying sounds perfectly possible
17:02:17 <ihope> `b' is bound by the type signature for `>>=' at <no location info>
17:02:26 <ihope> Is it supposed to say that?
17:02:44 <SamB> ihope: well maybe it should say what module >>= comes from,
17:02:53 <EvilTerran> timthelion, no, you could use the methods from class Data to fold/unfold arbitrary types. not sure how you'd deal with infinite structures, though.
17:02:59 <SamB> but it isn't supposed to say what file and line
17:03:17 <monochrom> I haven't heard of yagni
17:03:30 <SamB> monochrom: "you aren't going to need it"
17:03:37 <monochrom> Yay!
17:03:52 <monochrom> Err nevermind.
17:03:54 <SamB> yay what?
17:03:59 <EvilTerran> monochrom, it's rule #1 of optimisation. rule #2 (for experts only!) is "you aren't going to need it *yet*" ;)
17:04:35 <SamB> I thought it was rule 2 of XP
17:04:36 <phobes> EvilTerran: You mean rule #1 of design, right?
17:04:43 <monochrom> "need" is a big big grey area.
17:04:55 <EvilTerran> phobes, pardon my premature specialisation :D
17:04:59 <phobes> : )
17:06:42 <EvilTerran> timthelion, so what are you envisaging? some way of having (parts of) the runtime heap in a bit of program-neutral memory?
17:07:21 <EvilTerran> timthelion, it seems to me that there'd be some ambiguity in knowing when a program had "finished running", eg in the case of infinite structures
17:07:34 <dons> @seen glguy
17:07:34 <lambdabot> glguy is in #haskell. I last heard glguy speak 5h 23m 12s ago.
17:07:55 <EvilTerran> timthelion, and that some kind of stream interface, with the programs running in parallel, would be better suited to the lazy paradigm
17:11:55 <EvilTerran> it might even be possible to do something involving bidi communication between the programs and unsafePerformIO to have transparent inter-program laziness
17:18:06 <dons> ?users
17:18:06 <lambdabot> Maximum users seen in #haskell: 411, currently: 369 (89.8%), active: 14 (3.8%)
17:18:09 <dons> wow
17:18:13 <dons> that's  just crazy stuff
17:18:37 <dons> sjanssen wins the prize
17:18:59 <ihope> The channel population prize?
17:19:02 <wli> What prize is this?
17:19:13 <sjanssen> YES!
17:20:23 <ihope> sjanssen: what prize did you win?
17:20:30 <ihope> The Winning This Prize Prize?
17:21:07 <sjanssen> 18:18:06 <dons> so how about 400 by say, next July?
17:21:16 <sjanssen> 18:19:32 <sjanssen> August.
17:22:20 <zmike> Is there a prize for recruiting the person that bumps this channel one user over #ruby-lang?
17:22:29 <dons> that will be a glorious day :)
17:22:40 <zmike> not long now!
17:22:43 <dons> i think we're about 20 off their average?
17:22:43 <llewyenoh> can someone look at http://hpaste.org/2356 and give me suggestions on how to convert that bit from perl to haskell?
17:23:01 <llewyenoh> if possible, maybe suggestions on better efficiency?
17:23:03 <dons> #ruby-lang Current: 393, Avg: 387, Max: 470
17:23:09 <dons> #haskell Current: 370, Avg: 349, Max: 411
17:23:38 <Korollary> llewyenoh: you seem to need popen
17:23:48 <ihope> So 23 people required.
17:23:57 <EvilTerran> llewyenoh, i say keep using perl, if you can.
17:24:00 <Korollary> well, maybe not a full popen
17:24:04 <llewyenoh> Korollary: only solution? i'm trying to avoid that if possible?
17:24:35 <EvilTerran> that looks to be something perl'd be strong at, and haskell weak at
17:24:48 <ihope> I could write a bot to join this channel that many times, but I'd probably get K-lined :-P
17:24:56 <llewyenoh> yeah, unfortunately all the rest of the code i'm adding it into is haskell
17:25:00 <EvilTerran> unless there's some kind of library interface to xwininfo
17:25:05 <llewyenoh> and perl would be another dependency
17:25:13 <llewyenoh> i think there is, isn't there?
17:25:22 <Korollary> llewyenoh: That `` notation is syntactic sugar for popen kinda stuff. See System.Process.runProcess. You'll need to read from the handle.
17:26:09 <llewyenoh> Korollary: yeah, but i'm pretty sure there's an X interface for haskell, isn't there?
17:26:11 <EvilTerran> llewyenoh, if there's a C library for getting the same information, the FFI would by far be a better approach to anything involving subprocesses and string processing, IMO
17:26:44 <llewyenoh> FFI?
17:26:52 <EvilTerran> @where FFI
17:26:52 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
17:28:15 <Korollary> llewyenoh: Yes. I've never used it. But, the xmonad folks certainly have.
17:28:20 <llewyenoh> i don't like the way i had to do it in perl, because i basically did a system call
17:28:37 <Saizan> llewyenoh: for an X interface see X11 and X11-extras on hackage
17:28:40 <llewyenoh> right, i'm actually merging this part into xmonad (Config.hs) specifically
17:28:58 <Saizan> or darcs repos..
17:29:04 <EvilTerran> @where xmonad
17:29:04 <lambdabot> http://xmonad.org/
17:29:05 <sjanssen> llewyenoh: we've got some tools for grabbing window names in XMonadContrib
17:29:22 <llewyenoh> oh yeah, NamedWindow
17:29:40 <llewyenoh> but the thing is, i need to get pidgin's
17:29:52 <llewyenoh> not the one that's currently selected
17:29:59 <jedai> llewyenoh: What's wrong with a system call in this case ? Except performance maybe, but anyway if you're trying to get this information, xwin will be available, it's not like you're adding a dependance ?
17:30:13 <llewyenoh> jedai: only performance
17:30:30 <llewyenoh> jedai: i prefer a native solution, if possible
17:30:31 <wolverian> llewyenoh, mind you, pidgin has a perl api
17:30:56 <EvilTerran> does pidgin have a C api?
17:31:10 <jedai> llewyenoh: Everybody does, but you don't always have the time for such niceties...
17:31:27 <llewyenoh> jedai: yes, i know, which is why i'm checking before i actually use the system call method
17:31:28 <EvilTerran> ...or you could implement a chat program in haskell. :D
17:31:28 <wolverian> EvilTerran, yes.. :)
17:31:48 <wolverian> it has a dbug interface, so anything that talks to dbus can talk to pidgin
17:31:51 <wolverian> er, s/dbug/dbus/
17:32:08 <dons> interesting, the ocaml channel hasn't grown at all since last Dec
17:32:08 <wli> EvilTerran: What sort of chat program?
17:32:16 <dons> when #haskell reached 300
17:32:21 <EvilTerran> port pidgin?
17:32:27 <wli> EvilTerran: And what algorithm are you using to factor numbers?
17:32:28 <dons> however, the #erlang channel has come out of nowhere to 100 users
17:32:47 <gravity> The telepathy folks would probably love your support more than the pidgin folks
17:33:08 <EvilTerran> wli, naive dividing by each prime in turn repeatedly until it goes no further, then progressing to the next prime
17:33:22 <llewyenoh> wolverian: unfortunately, i'm trying to get away from perl. if only they had a haskell one.
17:33:23 <EvilTerran> (the leak was in my list-of-primes generation method)
17:33:37 <wli> EvilTerran: Oh dear. No ECM or MPQS?
17:33:43 <wolverian> llewyenoh, there are haskell dbus bindings
17:34:04 <EvilTerran> wli, i wrote this the first time 'round when i was in my first term at uni. don't give me that much credit ;]
17:34:04 <llewyenoh> wolverian: hm, i think that may be the best method then. i'll investigate that
17:34:49 <llewyenoh> wolverian: that would be better than using the X haskell bindings, right?
17:35:00 <EvilTerran> ...how do you get the name out of a NamedWindow?
17:35:15 <EvilTerran> show?
17:35:19 <wolverian> llewyenoh, probably, given that pidgin can run outside X too.. (windows)
17:35:31 <wolverian> well, not sure if dbus runs on windows
17:35:32 <llewyenoh> EvilTerran: yeah
17:35:47 <EvilTerran> wolverian, didn't llewyenoh say he was writing for xmonad anyway?
17:36:02 <wolverian> oh, I didn't notice that
17:36:09 <wolverian> then I don't know which would be better.
17:36:44 <EvilTerran> (which doesn't, AFAIK, run on windows. unless someone reimplemented the X server in those 500 lines of haskell when i wasn't looking)
17:36:44 <llewyenoh> hm, ok
17:36:53 <llewyenoh> hahahahha no, i doubt it
17:37:10 <llewyenoh> i'll just go with whichever ends up being the easiest to learn and pick up
17:37:13 <dons> can i get one for lambdabot? --> http://www.tilera.com/products/processors.php
17:37:14 <lambdabot> Title: Tilera Corporation
17:37:21 <EvilTerran> (this qualifies as Very Very Unlikely, IMO)
17:37:58 <hpaste>  Jeda annotated "Pidgin Message Count: convert from Perl to Haskell" with "With system calls (ugly and not complete)" at http://hpaste.org/2356#a1
17:41:20 <hpaste>  sphynx pasted "Different implementations of 'pairs'" at http://hpaste.org/2357
17:42:01 <Nucleo_> This isn't exactly Haskell, but are there updated instructions anywhere on how to get Hudak's SOE GraphicsLib to play nice with GHC?
17:42:10 <Nucleo_> (or modern Hugs, for that matter?)
17:42:15 <hpaste>  sphynx annotated "Different implementations of 'pairs'" with "'pairs' fixed" at http://hpaste.org/2357#a1
17:43:12 <sphynx> hi all!
17:43:22 <sphynx> I've inserted one question, could you please take a look?
17:43:52 <sphynx> I have two different implementations of same function - one uses zip of two lists, another uses list comprehension
17:44:15 <Korollary> Nucleo_: I think there's a  Graphics.SOE
17:44:28 <sphynx> list comprehension version is slower and I wonder why, cause it seems that it is simpler
17:45:00 <Nucleo_> Korollary: oh, thanks much! Hey, it's part of HHL, even!
17:48:30 <mudge> hi people
17:48:35 <mudge> how's the haskell code?
17:48:38 <ihope> Ello.
17:48:44 <ihope> What do you mean?
17:48:57 <dons> hot mudge, hot!
17:49:36 <araujo> slowly taking over the world
17:49:38 <byorgey> sphynx: I'm not sure, but with optimization turned on (-O2 to ghc) they're about the same speed
17:50:39 <mudge> nice!
17:50:41 <Korollary> @where performance
17:50:41 <lambdabot> http://haskell.org/haskellwiki/Performance
17:50:47 <Korollary> good read
17:51:32 <sphynx> byorgey: hmm, I will try with -O2 now.
17:51:55 <sphynx> byorgey: I've played with this in ghci
17:52:29 <drigz> sphynx: have you got the :: Int -> ... type annotation on pairs2 as well?
17:53:00 <Olathe> sphynx: How do you get it to tell you the timings ?
17:53:04 <mudge> what stuff have you been working on lately dons?
17:53:09 <drigz> Olathe: :set +s in ghci
17:53:28 <Olathe> Ahh, thanks :)
17:53:32 <drigz> sphynx: -O2 isn't necessary, but it seems to be the difference between interpreting and compiling
17:53:46 <jedai> drigz: Not the problem, I've tried with both without type annotation
17:53:52 <drigz> with -O2, pairs2 seems considerably faster
17:55:27 <sphynx> drigz: Yeah, interesting
17:55:50 <sphynx> for me too pairs2 is faster when compiled and slower when interpreted
17:55:52 <gravity> Of the 8 ways listed here of handling errors (http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors) what's the one people generally use?
17:55:55 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
17:56:06 <gravity> I've done catch in my basic stuff, but it doesn't really scale
17:56:13 <drigz> sphynx: it seems to be a list comprehension specific thing, map (\n -> (n, x-n)) [k .. div x 2] works fine
17:56:40 <drigz> maybe it's because of all the indirection from the list monad?
17:56:45 <Olathe> For me, both implementations take about 3.5 seconds.
17:57:33 <Olathe> Oh, wait.
17:58:07 <dons> gravity: catch for small thiings, then an error monad for larger things (or catch )
17:58:24 <dons> eric's article gives a good summary.
17:58:27 <Olathe> Never mind.
17:58:45 <gravity> dons: Ok, cool. The error monad looked right, but monad transformers still mystify me a bit
17:58:48 <Olathe> 3.5s and 11.3s.
17:58:49 <drigz> sphynx: http://haskell.org/onlinereport/exps.html#list-comprehensions this is how the list comprehension is desugared
17:58:50 <lambdabot> Title: The Haskell 98 Report: Expressions
17:58:56 <gravity> dons: Thanks!
17:59:17 <sphynx> Olathe: when compiled?
17:59:23 <drigz> so it desugars to concatMap (\n -> [(n, x-n)]) [k .. div x 2]
17:59:59 <drigz> which i assume is slow because of all the concatenation
18:01:21 <sphynx> drigz: but when it's compiled with GHC - some specific optimization come into game, right?
18:01:43 <sjanssen> yes, that should all be fused
18:01:48 <jedai> sphynx: but of course the concatMap of one element lists is optimised in "append" I believe ?
18:01:49 <drigz> sphynx: yes, i assume GHC sees that you're just doing a map, and so gets rid of the concat stage
18:04:45 <jedai> drigz: You're probably right, pairs3 k x = map (\n -> (n, x - n)) [k.. x `div` 2] is the fastest for me
18:04:55 <mudge> what do you guys prefer,  GHC or Hugs?
18:05:06 <dons> ghc, no question. mudge
18:05:33 <dons> see here for part of the reason why: http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
18:05:33 <lambdabot> Title: nobench: Haskell implementation shootout
18:05:48 <jedai> mudge: GHC is the future (Ok, I only know GHC so... ^^ ) I heard Hugs has some interesting aspects but for now I'm trying to learn Haskell with GHC
18:06:09 <sphynx> yeah, drigz's map version is faster in interpreted and compiled both versions
18:07:22 <jedai> sphynx: Is it faster than pairs2 ?
18:07:32 <jedai> sphynx: when compiled ?
18:07:47 <EvilTerran> i thought GHC was the present, and YHC is the future
18:08:49 <Korollary> One day there will be pissing matches between haskell compilers. Probably not today.
18:09:50 <SamB> I thought GHC was the slow, and ndm's thing was the fast
18:10:11 <dons> teh fast! ftw!
18:10:13 <drigz> if you compile with optimisations on, map seems exactly the same as the LC version
18:10:47 <dons> check what core it produces. that's the only way to really understand things (--dump-simpl | HsColour -tty | less -r)
18:10:49 <EvilTerran> could have a look at the Core output?
18:11:47 <drigz> i get really confused by core
18:11:54 <Korollary> SamB: you're just biased because ndm hangs out here more than JaffaCake
18:11:54 <drigz> i know it's meant to be 'readable'
18:11:57 <drigz> but my god
18:12:07 <SamB> I didn't mention JHC
18:12:12 <jedai> drigz: Which probably means it's compiled to the same code
18:12:19 <SamB> JHC promises fast code, next year, if you have enough RAM
18:12:35 <Korollary> SamB: 2GB enough?
18:12:42 <SamB> Korollary: could be
18:13:04 <SamB> maybe next year JHC will go faster and use less RAM
18:13:04 <sjanssen> JHC and Vista have the same hardware requirements
18:13:09 <SamB> actually could be much sooner
18:13:20 <drigz> jedai: yes, i assume it is
18:13:43 <SamB> sjanssen: really?
18:13:53 <sjanssen> SamB: I'm just kidding
18:14:11 <SamB> vista takes 2gb?
18:14:16 <drigz> it's a crazy man who tries to run JHC without a recent graphics card
18:14:18 * EvilTerran would prefer a subset of haskell that's isomorphic (is this right?) to core
18:14:26 <sphynx> jedai: yes, pairs3 is faster than pairs2
18:14:35 <joed> Hmm, programming in Haskell has a wild price range in the US. From $36 in store to $115  Hard Cover.
18:14:35 <SamB> actually I can compile the Prelude in less than 24 hours with only 512 MB RAM, I think
18:14:49 <EvilTerran> (ie something that translates back-and-forth in a way that someone who knew both could do easily in hir head)
18:15:18 * EvilTerran ponders devising such a transformer himself, as an exercise in learning Core in nothing else
18:15:43 <SamB> if I had shaders, I'd want to see a Haskell compiler put them to use
18:15:50 <SamB> fortunately I don't have them ;-)
18:16:48 <jedai> drigz: I completely agree with you... I don't understand the output, even on the simplest program, I should learn to do it though, it looks like it could be interesting to understand what's really going on
18:16:50 <drigz> EvilTerran: most of the syntax is fine, it's the GHC.List.polyfoldr2 and the names like ww1_s1ej that get me
18:17:22 <drigz> it'd be nice to format the single-option case statements and nested lets to something more natural
18:17:30 <drigz> and maybe take out some of the {;;}s
18:17:51 <EvilTerran> hm... turn it as far back into haskell as possible while maintaining the optimisations?
18:18:22 <dons> anyone else think lukeplant's blog should have just used happs?
18:18:24 <drigz> change the case .. { GHC.Base.False -> ... ; GHC.Base.True -> ... } into ifs, perhaps
18:18:27 <mudge> are Hugs and GHC pretty compatible?  If you wrote a 500 line program in GHS,  will it compile without much fuss on Hugs?
18:18:28 <dons> fork hpaste, you got yourself a blog
18:18:35 <dons> or you know, read/show.
18:18:51 <drigz> mudge: if you write it in haskell98, then yes
18:19:16 <byorgey> dons: it had occurred to me, yes...
18:19:17 <mudge> drigz: is it pretty easy to write in haskell98 and not stray?
18:19:30 <drigz> mudge: depends what you're trying to do
18:19:35 <drigz> but yes, i think so
18:19:47 <dons> hmm, i'm inclined to roll a blosxom-alike blog software as a demo
18:19:51 <dons> should do that on the plane next week
18:19:56 <mudge> drigz: cool thanks
18:20:08 <EvilTerran> it's difficult to stray by accident, i think, given that you need compiler flags for most (all?) extensions
18:20:26 <drigz> mudge: performance will vary wildly, though
18:24:13 <mudge> drigz: why's that?
18:24:26 <ihope> Who's using "GHC.Base.True" rather than importing?
18:24:38 <drigz> mudge: because hugs is an interpreter, and doesn't do anything like the same kind of optimisations that GHC will
18:24:44 <mudge> oh
18:24:48 <drigz> see the conversation we were having earlier for an example
18:25:21 <jedai> sphynx: Put a type annotation on pairs3 too, it seems to make a difference
18:25:45 <glen_quagmire> man fold and continuation are very difficult to understand
18:26:13 <EvilTerran> ihope, GHC Core is, because everything has to be fully qualified in it
18:26:45 <twanvl> When you understand them, they are not all that hard to understand :)
18:27:00 * EvilTerran tries to work out how fold and continuations are related
18:27:28 * glen_quagmire tires to implement foldl/r using continuation
18:27:29 <Cale> glen_quagmire: what are you reading?
18:27:34 <glen_quagmire> YAHT
18:27:38 <Cale> ah, yeah
18:27:47 <Cale> that's sort of a rough spot :)
18:28:05 <Cale> if you'd like more on folds, I wrote the wikipedia article :)
18:28:10 <glen_quagmire> is wikibooks better? I'm reading yaht because I printed them all
18:28:29 <glen_quagmire> Cale: did you also write haskell wiki 's fold?
18:28:43 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
18:28:44 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
18:28:58 <glen_quagmire> http://www.haskell.org/haskellwiki/Fold
18:28:59 <lambdabot> Title: Fold - HaskellWiki
18:29:14 <Cale> yeah
18:29:22 <Cale> err...
18:29:32 <glen_quagmire> they used same images. so i was wondering
18:29:35 <Cale> Yeah, I think so
18:29:51 <Cale> Some changes have happened to both :)
18:30:47 <Cale> So, implementing a fold with continuations...
18:31:06 <glen_quagmire> yes. there are answers on the back
18:31:08 <Cale> The basic idea there is that your fold function is going to take an extra parameter
18:31:14 <dons> http://programming.reddit.com/info/2h3b3/comments
18:31:15 <lambdabot> Title: Arrows, like Monads, are Monoids :: PDF (reddit.com)
18:31:38 <Cale> and then instead of returning its usual result, it will apply the function which is that extra parameter to that result
18:32:12 <glen_quagmire> hah i hope when i figure this out, what you said would make sense
18:32:26 <Cale> Normally, you have:
18:32:30 <Cale> foldr f z [] = z
18:32:38 <Cale> So with the continuation:
18:32:49 <Cale> foldrk f z [] k = k z
18:33:11 <Cale> Similarly:
18:33:22 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
18:33:34 <Cale> So you'd have:
18:33:58 <Cale> foldrk f z [] k = k (f x (foldrk f z xs k))
18:34:39 <Cale> at least, that's one way to interpret it :)
18:35:05 <glen_quagmire> i get the [] case part
18:35:30 <Cale> The other part you have some choice in what gets done with the recursive call.
18:36:03 <glen_quagmire> foldrk f z (x:xs) k = k (f x (foldrk f z xs k))
18:36:18 <glen_quagmire> are real haskell programs use single variable names?
18:36:26 <glen_quagmire> like, a, b, x, xs...etc
18:36:46 <Cale> Yeah, when there's nothing better to call them.
18:37:22 <Cale> Like, if they're so polymorphic that there's no point in giving them a longer name, because they could be interpreted as practically anything :)
18:38:01 <glen_quagmire> i see that makes sense
18:38:06 <SamB> which happens rather a lot
18:41:10 <ihope> It's recently become obvious to me that experience is required when you're doing stuff like trying to implement monad transformers :-)
18:41:40 <mudge> dons: you here?
18:41:58 <Cale> ihope: I think it's easiest to start off by implementing a few simple monad transformers in terms of StateT.
18:42:40 <mudge> why is it that whenever I post something to reddit programming it never shows up,  even in the "new" section?
18:42:43 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadSupply -- this one is a good example to read
18:42:44 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
18:42:48 <EvilTerran> @seen dons
18:42:49 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 11m 34s ago.
18:43:04 <Cale> mudge: what's your username?
18:43:04 <sphynx> could ypu please point me where is the problem in this code with Data.Map:
18:43:05 <sphynx> createZMap = foldl' (\m n -> M.insert n (z n) m) M.empty [1..2000]
18:43:32 <sphynx> I just want to save all values of z(x), x <- [1..2000] to table to use later
18:43:47 <sphynx> it says Stack overflow even for 2000 values of z
18:43:52 <dons> mudge: ?
18:43:55 <mudge> mudge_programmer
18:44:06 <mudge> my reddit username is mudge_programmer
18:44:24 <twanvl> sphynx: Why not use fromList?
18:44:56 <mudge> dons: I just posted your post in USENET about #haskell reaching 400 users to reddit programming: http://programming.reddit.com/info/2h3ec/comments
18:44:57 <lambdabot> Title: #haskell irc channel reaches 400 users (reddit.com)
18:45:17 <dons> cool :)
18:45:38 <dons> it was a post to haskell-cafe@, which google threads into news too, btw.
18:45:39 <lament> so it will reach 500 very soon :)
18:45:55 <dons> lament, i think this is possible, yes.
18:46:12 <sphynx> Data.Map.fromList [(x, z x) | x <- [1..2000]]
18:46:13 <mudge> i found your post on fa.haskell
18:46:17 <sphynx> the same result
18:46:24 <Cale> sphynx: are you sure it's that code which is the problem?
18:46:29 <dons> it took 5 years to reach 200, 1 year to reach 300, and 2/3 year to reach 400
18:46:34 <Cale> sphynx: that works for me at the ghci prompt
18:46:46 <Cale> dons: uh oh
18:46:51 <dons> :)
18:47:09 <dons> ?users
18:47:09 <lambdabot> Maximum users seen in #haskell: 411, currently: 376 (91.5%), active: 13 (3.5%)
18:47:16 <shapr> yarr
18:47:18 <dons> and we jumped by 20 users last night alone
18:47:31 <sphynx> Cale: uh, really, stupid me :) I've changed already z to getting from table instead of actually evaluating function )
18:47:31 <Cale> heh, floodbots? :)
18:47:54 <dmwit> So I asked this a few days ago, but haven't really figured out an answer yet.
18:48:12 <dmwit> Is it possible to get the difference between two UTC times (i.e. in Data.Time)?
18:48:18 <joel> any gtk2hs users willing to walk me through ModelView?
18:48:23 <Cale> sphynx: but yeah, using fromList is probably easier to read
18:48:26 <dmwit> Specifically, so that I can break it down into text that says something like, "2 days apart" or so?
18:48:26 <dons> dmwit: yeah, timeDiff
18:48:30 <mudge> dons: just asking,    whenever I post to reddit programming,   my posts never show up anywhere,  not even in the "new" section,   do you have any idea why?
18:48:40 <dmwit> dons: It returns a NominalDiff, which has no functions that act on it!
18:48:44 <dons> mudge: hmm, seems odd. i note your last post has 0 points too
18:48:46 <dmwit> And it's an algebraic newtype.
18:48:56 <dons> dmwit: hmm. i only use TimeDiff from System.Time
18:48:59 <dmwit> (i.e. the constructor is hidden from importing.)
18:49:02 <Cale> diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
18:49:14 <dmwit> Cale: Yes, but then what?
18:49:14 <Cale> dmwit: what do you mean?
18:49:27 <mudge> yea,  all my posts are 0  because my posts never show up anywhere
18:49:31 <Cale> Enum NominalDiffTime,Eq NominalDiffTime,Fractional NominalDiffTime,Num NominalDiffTime,Ord NominalDiffTime,Real NominalDiffTime,RealFrac NominalDiffTime,Show NominalDiffTime
18:49:43 <mudge> really frustrating
18:49:54 <mudge> I wonder if my IP is blocked for some reason from reddit.com
18:50:01 <mudge> no reason though,  I"ve been good
18:50:03 <dons> mudge: well, your post made it through. hmm
18:50:09 <mudge> it did?  Where?
18:50:31 <dons> well, the link you posted :)
18:50:31 <mrd> mudge: consider yourself lucky
18:51:03 <mudge> it has 0 points,  is anyone in here going to vote on it?
18:51:10 <mrd> took me months to break the reddit habit
18:51:37 <dons> mudge: i voted, but it didn't show up
18:51:43 <dons> reddit bugs?
18:52:04 <dmwit> Perfect, the Rational instance is just what I wanted.
18:52:07 <dmwit> Thanks, Cale.
18:52:12 <Cale> dmwit: no problem :)
18:52:16 <mudge> well,   I had a different user account,  mudge,   and I had the same problem,  which is why I created a new user account
18:52:23 <mudge> damn!!!
18:52:27 <mudge> so frustrating!
18:52:32 <dons> http://programming.reddit.com/info/2h3hn/comments
18:52:33 <lambdabot> Title: Growing online communities: Haskell IRC channel reaches 400 users (reddit.com)
18:52:50 <dons> so that worked ? hmm :|
18:54:08 <mudge> dons: Yea!  it worked,   and your post is at the top of "new": http://programming.reddit.com/new
18:54:09 <lambdabot> Title: reddit.com: programming - newest submissions
18:54:12 <mudge> quick everyone vote
18:54:30 <dons> weird
18:54:37 <mudge> yea,  it makes me so mad
18:54:57 <mudge> I'm going to post it on Hacker News now,   at least that works for me
18:55:37 <kfish> mudge: perhaps it's because you are using the nickname of a famous cracker ... ;-)
18:55:48 <mudge> really?
18:55:54 <mudge> you think that might really be why kfish?
18:56:25 <kfish> http://en.wikipedia.org/wiki/Mudge
18:56:26 <lambdabot> Title: Mudge - Wikipedia, the free encyclopedia
18:56:41 <dons> so... who wants to place bets on when the channel reaches 500..
18:56:42 <mrd> Mudge was also the name of my dorm when I lived in one
18:56:57 <dons> and becomes the largest PL channel on freenode..
18:57:04 <kfish> dons: sweet :-)
18:57:06 <dons> alternately, a betting market for when we go past ruby-lang
18:57:27 <kfish> mudge, not necessarily the reason, but your nick could confuse people
18:58:00 <gravity> In a way it's sad that we're close to ruby-lang. I'd bet most of the ruby-related traffic is in the rails channel.
18:58:05 <glen_quagmire> ?hoogle fold
18:58:06 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
18:58:06 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
18:58:06 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
18:58:16 <dons> mudge: yeah, i think your nick or ip is banned somehow
18:58:23 <dons> mudge: looks like you commented on the irc article?
18:58:29 <dons> but the comment was also blocked
18:58:47 <zmike> sad my ass
18:59:05 <dons> gravity: yeah, #rails is a bit bigger
18:59:06 <dons> 50 or so users
18:59:12 <mudge> dons: yea
18:59:16 <gravity> zmike: It shows what a kiler app can do
18:59:19 <mudge> dons: I did comment on it
18:59:26 <mudge> dons: why?
18:59:38 <dons> mudge: i've no idea. kfish's theory is the most plausible so far
18:59:44 <dons> somehow you're on a blacklist it seems
18:59:49 <mudge> dons: you think if I got a new account without the name "mudge"  it might work?
18:59:52 <dons> maybe
18:59:58 <zmike> I guess it's right that Ruby's identity is hard to separate from Rails now
19:00:11 <mudge> okay,  I figure I'm either blacklisted with my IP address or the nick
19:00:20 <dons> mudge: yeah
19:00:45 <dons> gravity: #rubyonrails , Current: 464, Avg: 465, Max: 588
19:00:59 <dons> #ruby-lang Current: 389, Avg: 387, Max: 470
19:01:00 <mudge> I posted the #haskell 400 users announcement on hacker news: http://news.ycombinator.com/item?id=44581
19:01:03 <lambdabot> Title: Hacker News | Growing online communities: Haskell IRC channel reaches 400 users
19:01:13 <gravity> geez
19:01:17 <gravity> dons: That's incredible
19:01:29 <Korollary> 10 Billion Monad Tutorials Served
19:01:42 <dons> gravity: its always interesting seeing chans that sit below their long term average though
19:01:56 <dons> so ruby-lang is growing, while rails is stalling.
19:02:01 <mudge> gravity: don't forget to vote
19:02:05 <mrd> Korollary: will monads have to come with nutrition labels?
19:02:05 <dons> haskell sits way above its long term average, so its still growing
19:02:55 <mudge> dons: what do you mean "long term average" ?
19:03:04 <mrd> eliminate monad "trans" fats
19:03:10 <monochrom> haha
19:03:12 <dons> mudge: the average channel size
19:03:25 <mudge> oh i see
19:04:05 <Korollary> mrd: "We don't evaluate it till you order"
19:04:22 <mudge> hey, the post has 3 points now on hacker news: http://news.ycombinator.com/newest
19:04:26 <lambdabot> Title: Hacker News | New Links
19:04:47 <mudge> in only 7 minutes
19:05:37 <ray> 4 points!
19:05:55 <mudge> 5 points!
19:07:27 <ray> there's also a link to http://savingtheinternetwithhate.com/
19:07:29 <lambdabot> Title: Utu: here
19:07:30 <lament> it's already on programming.reddit
19:07:44 <ray> i wish i had that domain
19:07:49 <SamB> that's not very surprising ;-)
19:07:51 <lament> (the #haskell announcement)
19:08:16 <lament> (i mean, it's visible on the front page)
19:08:39 <SamB> oh
19:09:01 <SamB> well, um, don't all new reddit posts go there?
19:09:19 <SamB> anyway it's not surprising to see something posted so quickly with dons around...
19:10:25 <mudge> hey,  the 400 users on #haskell is now number two on the front page of Hacker News: http://news.ycombinator.com/news
19:10:26 <lambdabot> Title: Hacker News | Top Links
19:10:56 <chessguy> @type max . ?maximise' . ?highfirst . (mapTree :: Tree a -> Tree a) ?static . ?prune 8 . (gametree :: Tree a)
19:10:58 <lambdabot> Not in scope: `mapTree'
19:10:58 <lambdabot>  
19:10:58 <lambdabot> <interactive>:1:84: Not in scope: `gametree'
19:11:13 <chessguy> @type max . ?maximise' . ?highfirst . (?mapTree :: Tree a -> Tree a) ?static . ?prune 8 . (?gametree :: Tree a)
19:11:15 <lambdabot>     No instance for (?mapTree::Tree a -> Tree a)
19:11:15 <lambdabot>       arising from use of implicit parameter `?mapTree'
19:11:17 <lament> so now the same crowd that spammed #esoteric yesterday will spam #haskell :)
19:12:34 <mudge> the 400 users #haskell post is also now on the front page of reddit programming: http://programming.reddit.com/
19:12:35 <lambdabot> Title: reddit.com: programming - what&#39;s new online
19:12:40 <chessguy> @type max . ?maximise' . ?highfirst . (?mapTree :: (Tree a -> Tree a)) ?static . ?prune 8 . (?gametree :: Tree a)
19:12:42 <lambdabot>     No instance for (?mapTree::Tree a -> Tree a)
19:12:42 <lambdabot>       arising from use of implicit parameter `?mapTree'
19:14:02 <coffeemug> hey everyone
19:14:06 <mudge> hey coffeemug
19:14:17 <coffeemug> I got tired of coding in Lisp
19:14:28 <mudge> coffeemug:  I love your articles on your website
19:14:30 <coffeemug> and decided to take a day off to do some Haskell stuff :)
19:14:31 <mudge> i've read a bunch of them
19:14:41 <coffeemug> mudge: thanks
19:14:59 <mudge> coffeemug: How is weblocks?
19:15:04 <coffeemug> mudge: I kind of stopped writing *about* software lately and started writing *actual software*
19:15:19 <coffeemug> it's going really well
19:15:39 <mudge> cool
19:15:45 <SamB> I'm just trying to boot ReactOS
19:15:46 <coffeemug> I just needed a break from Lisp for a day :)
19:15:55 <mudge> nice
19:15:58 <dons> coffeemug: nice :)
19:16:01 <coffeemug> hey dons
19:16:02 <dons> so what you looking to hack on?
19:16:08 <coffeemug> well
19:16:16 <coffeemug> I have a purely hypothetical excercise here
19:16:22 <coffeemug> that I made up for myself :)
19:16:30 <coffeemug> basically Haskell does real currying
19:16:33 <coffeemug> which is nice
19:16:41 <SamB> did you know that most of NT's shutdown logic is implemented in userspace?
19:16:43 <coffeemug> but sometimes it's useful to curry last argument
19:16:56 <coffeemug> so I wrote a function curryAfter
19:16:57 <coffeemug> like this
19:17:01 <coffeemug> curryAfter fn arg1 = \arg2->fn arg2 arg1
19:17:21 <dons> yep ok.
19:17:24 <coffeemug> this way I can do: mapR = curryAfter map
19:17:31 <dons> ?pl curryAfter fn arg1 = \arg2->fn arg2 arg1
19:17:31 <lambdabot> curryAfter = flip
19:17:31 <chessguy> @pl curryAfter fn arg1 = \arg2->fn arg2 arg1
19:17:31 <lambdabot> curryAfter = flip
19:17:35 <dons> :)
19:17:35 <chessguy> lol
19:17:45 <coffeemug> and then: mapR [1, 2, 3, 4] (1+)
19:17:46 <dons> ?src flip
19:17:46 <lambdabot> flip f x y = f y x
19:17:47 <coffeemug> hehe
19:17:49 <coffeemug> thanks
19:17:53 <shapr> hiya coffeemug, ltns!
19:17:54 <dons> yeah, that's usually called 'for'
19:18:00 <coffeemug> hey shapr
19:18:10 <dons> for [1..4] (+1) -- that kind of thing
19:18:19 <coffeemug> dons: yeah, but the problem with flip
19:18:24 <coffeemug> is that it works for two arguments
19:18:36 <coffeemug> I wanted curryAfter to curry as many arguments as I want
19:18:43 <SamB> would be kind of cool if the code for shutdown in ROS's csrss wasn't about twice as long as xmonad though...
19:18:49 <chessguy> yes, one common idiom for sort of 'indexed' loops is flip map [1..n] $ \i -> ...
19:18:54 <coffeemug> that's the excercise :)
19:19:30 <chessguy> i thought dons was nuts the first time i saw him write that idiom :)
19:19:41 <dons> coffeemug: ah i see.
19:19:56 <coffeemug> dons: I think there are some research papers on this stuff
19:20:06 <coffeemug> multivariadic functions in Haskell
19:20:08 <coffeemug> and such
19:20:11 <dons> there's similar tricks with variadic stuff, yeah
19:20:14 <dons> see printf.
19:20:20 <dons> you use a typeclass to suck up the arguments
19:20:25 <SamB> I think you won't find a trick for this
19:21:02 <chessguy> SamB, oh ye of little faith :)
19:21:30 <coffeemug> yeah, I have to take a look
19:21:34 <SamB> I think this because the obvious way runs into an ambiguity in the case of polymorphic functions
19:21:44 <coffeemug> ?src printf
19:21:44 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:21:50 <coffeemug> hehe
19:21:55 <coffeemug> it was worth a try :)
19:22:36 <SamB> hmm, what does halt(8) do anyway?
19:22:36 <chessguy> @hoogle printf
19:22:37 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
19:22:37 <lambdabot> Text.Printf :: module
19:22:37 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
19:22:42 <Saizan> @source Text.Printf
19:22:42 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
19:22:51 <chessguy> Saizan beat me too it :)
19:22:59 <chessguy> s/oo/o/
19:24:35 <coffeemug> curryAfter is a pretty cool utility :)
19:24:39 <coffeemug> I use it in Lisp all the time
19:24:44 <coffeemug> would be useful in Haskell too
19:24:50 <coffeemug> perhaps with a shorter name, though
19:25:12 <desp> curAr
19:25:16 <mudge> hey have you guys checked out hacker tracker?
19:25:18 <chessguy> curryAFter isn't bad
19:25:31 <mudge> http://hackrtrackr.com/
19:25:43 <mudge> might be interesting if there was a haskell hacker tracker
19:26:17 <coffeemug> mudge: yeah, I saw that
19:26:27 <coffeemug> these trackers are pretty cool
19:26:52 <chessguy> @where map
19:26:52 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:26:59 <coffeemug> ok
19:27:00 <mudge> coffeemug: when are you coming out with your next article?
19:27:13 <chessguy> hmm, apparently it got moved
19:27:18 <SamB> http://www.ohloh.net/projects/5798?p=GHC
19:27:20 <lambdabot> Title: GHC - Ohloh
19:27:33 <coffeemug> mudge: I have a few unfinished ones
19:27:40 <coffeemug> one about multimethods/multidispatch
19:27:41 <SamB> look! a map!
19:27:43 <Saizan> i was searching a general way to go from   ... -> r -> a to r -> ... -> a last time i was binding a C library using a monad made of ReaderT r IO
19:27:46 <coffeemug> and one about coroutines
19:27:57 <SamB> http://www.ohloh.net/projects/4078?p=HUGS
19:27:58 <lambdabot> Title: HUGS - Ohloh
19:28:01 <SamB> look! a smaller map!
19:28:05 <coffeemug> Weblocks is heavily based on multimethods and will soon be heavily based on coroutines
19:28:13 <coffeemug> so I want to write these two articles to advertise it
19:28:15 <SamB> also a strange correlation between using hugs and using VisualBoyAdvance
19:28:18 <coffeemug> but I am not sure when it will happen
19:28:43 <SamB> it's even stranger if you look at VisualBoyAdvance's side and see that it is second only to the correlation between using that and using ZSNES
19:28:56 <coffeemug> ok, so I also have a style improvement excercise :)
19:29:09 <SamB> dons: just look at this! http://www.ohloh.net/projects/369
19:29:10 <lambdabot> Title: VisualBoyAdvance - Ohloh
19:29:22 <coffeemug> I wrote code to generate all subsets of a list
19:29:46 <coffeemug> basically I take an integer, and for each set bit grab list contents
19:29:57 <coffeemug> code looks like this
19:30:03 <coffeemug> subset :: [a] -> Int -> [a]
19:30:03 <coffeemug> subset l i = map (\(_, j)->j) $ filter (\(a, _)->testBit i a) $ zip [0..] l
19:30:09 <coffeemug> subsets :: [a] -> [[a]]
19:30:09 <coffeemug> subsets l = map (subset l) [0 .. 2 ^ length l - 1]
19:30:13 <SamB> dons: hello?
19:30:29 <coffeemug> first one returns a subset for a given integer
19:30:34 <coffeemug> and second one returns all subsets
19:30:39 <chessguy> @pl \(_,j) -> j
19:30:39 <lambdabot> snd
19:30:44 <chessguy> first of all :)
19:30:55 <mudge> coffeemug: cool look forward to the articles
19:30:57 <dons> SamB: ?
19:30:58 <SamB> coffeemug: you should use Integer
19:31:02 <dons> maps are interesting, yes.
19:31:05 <SamB> dons: see on the right there
19:31:20 <chessguy> @l \(a,_) -> t i a
19:31:20 <lambdabot> Maybe you meant: learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban . pl v
19:31:25 <coffeemug> ah, snd, nice
19:31:26 <chessguy> @pl \(a,_) -> t i a
19:31:26 <lambdabot> t i . fst
19:31:33 <SamB> where it says "People who use VisualBoyAdvance also use:"
19:31:42 <coffeemug> SamB: Integer is too big
19:32:07 <SamB> dons: now the ZSNES stands out really nicely, but if you look closely you'll see that HUGS is taller than all the rest!
19:32:14 <coffeemug> SamB: it will be impossible to generate all subsets for lists so huge that they require integer for bitsetting
19:32:16 <SamB> (if necessary, look at the HTML)
19:32:21 <coffeemug> hmm, although with lazyness...
19:32:50 <SamB> coffeemug: I admit it'd be silly in J
19:32:56 <SamB> to even attempt
19:33:04 <SamB> but this ain't J
19:33:45 <coffeemug> hmm
19:33:46 <SamB> dons: isn't that a bit odd?
19:33:54 <coffeemug> what's the @l @pl business? :)
19:33:55 <ShockSMX> is wxhaskell the top choice for a haskell UI? or are there other things?
19:34:14 <SamB> ShockSMX: usually I hear about gtk2hs these days
19:34:20 <dons> ShockSMX: gtk2hs is preferred
19:34:24 * ShockSMX takes a look
19:34:26 <dons> ?where gtk2hs
19:34:26 <lambdabot> http://haskell.org/gtk2hs/
19:34:28 <chessguy> coffeemug, @l was a typo for @pl
19:34:38 <ShockSMX> thanks
19:34:47 <coffeemug> and what's pl? :)
19:34:54 <chessguy> coffeemug, @pl is for figuring out so-called "point-free" forms of code
19:34:55 <SamB> I've got evidence that the maintainer of gtk2hs is probably still alive
19:34:59 <sorear> coffeemug: @pl is an optimizing compiler from Haskell to a combinator calculus (vast extension of SKI)
19:35:00 <SamB> ;-P
19:35:22 <chessguy> @pl add x y = x + y
19:35:22 <lambdabot> add = (+)
19:35:32 <sorear> @pl \a b c -> c b a
19:35:33 <lambdabot> flip (flip . flip id)
19:35:43 <chessguy> coffeemug, it figures out how to write a function without mentioning the parameters
19:35:51 <coffeemug> ahh, I see
19:35:54 <sorear> flip, ., id are Curry's B C and I resp
19:36:04 <dfranke> dons: you need to defect from Reddit and come over to news.yc.  As of this moment, your email about #haskell hitting 400 users just made the #1 spot.
19:36:12 <coffeemug> @pl \a b->b a
19:36:12 <lambdabot> flip id
19:36:15 <coffeemug> hehe
19:36:17 <coffeemug> cool :)
19:36:34 <ray> looks pointless to me
19:36:53 <monochrom> I think dons is interested in getting the whole world to talk about haskell.
19:37:09 <chessguy> coffeemug, so your code is equivalent (based on those @pl's to subset l i = map snd $ filter (testBit i . fst) $ zip [0..] l
19:37:25 <mudge> hey the "400 users on #haskell" is number one on the Hacker News frontpage: http://news.ycombinator.com/news
19:37:26 <lambdabot> Title: Hacker News | Top Links
19:37:33 <chessguy> oops, i missed a paren. guess i wouldn't be a very good lisper :)
19:37:39 <coffeemug> chessguy: yeah, but it's still ugly :)
19:37:42 <coffeemug> subset l i = map snd $ filter (testBit i . fst) $ zip [0..] l
19:37:46 <coffeemug> subsets l = map (subset l) [0 .. 2 ^ length l - 1]
19:37:51 <coffeemug> look at the first one
19:37:52 <dfranke> mudge: read back a few lines...
19:37:57 <coffeemug> l i is beginning to be flipped
19:38:05 <coffeemug> and l at the end is begging to be removed
19:38:15 <coffeemug> so the whole thing would be pointfree
19:38:19 <coffeemug> but then subsets won't work
19:38:50 <chessguy> @pl subset l = \i -> map snd $ filter (testBit i . fst) $ zip [0..] l
19:38:51 <lambdabot> subset = (map snd .) . flip (filter . (. fst) . testBit) . zip [0..]
19:38:57 <Saizan> you could use (flip subset l)
19:39:15 <coffeemug> haha
19:39:16 <mudge> dfranke: oh thanks I see!
19:39:18 <coffeemug> that's pretty cool :)
19:39:32 <chessguy> coffeemug, probably not an improvement though :)
19:39:36 <coffeemug> but I am not sure if it's better
19:39:40 <coffeemug> yeah :)
19:39:49 <dons> dfranke: hmm. you think ycombinator is where its at these days?
19:39:52 <chessguy> sometimes @pl totally blows up
19:39:53 <coffeemug> ok, I think Saizan's idea is better
19:39:54 <Saizan> @pl subset i l = map snd $ filter (testBit i . fst) $ zip [0..] l
19:39:54 <lambdabot> subset = (map snd .) . (. zip [0..]) . filter . (. fst) . testBit
19:40:22 <dfranke> dons: as of last week, the site was renamed from "startup news" to "hacker news".
19:40:26 <mudge> dons: news travels faster at Hacker News
19:40:42 <Saizan> i'd settle for subset i = map snd . filter (testBit i . fst) . zip [0..]
19:40:47 <coffeemug> dfranke: it's still startup news though
19:40:51 <dons> you can't vote down on 'hacker news'?
19:40:53 <coffeemug> I didn't see very much worthy hacker content
19:40:54 <mudge> for some strange reason the smaller programming news sites are better
19:41:02 <dfranke> dons: you can vote down comments but not submissions
19:41:07 <dons> interesting
19:41:08 <mudge> for instance Hacker News doesn't ban me for no reason
19:41:18 <chessguy> coffeemug, i think the real issue is this business with zipping with [0..]
19:41:26 <mudge> coffeemug: good point
19:41:37 <coffeemug> coffeemug: yeah, but that's the most elegant thing I came up with :)
19:41:47 <coffeemug> to use the index
19:41:53 <mudge> coffeemug: but Hacker News just started last week,  before that it was focused on Start Up News
19:42:03 <chessguy> coffeemug, another idiom might come in handy
19:42:07 <Saizan> > filterM (const [False ..]) [1..3] -- seen this?
19:42:10 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
19:42:31 <mudge> this is paul graham's announcement about Hacker News: http://ycombinator.com/hackernews.html
19:42:32 <lambdabot> Title: Hacker News
19:42:32 <chessguy> Saizan, don't blow his mind yet :)
19:42:36 <chessguy> sheesh
19:42:53 <monochrom> hehehe
19:43:03 <coffeemug> chessguy: it's ok I'm familiar with this stuff
19:43:11 <coffeemug> just haven't touched it in months so I'm a bit rusty
19:43:12 <coffeemug> :)
19:43:34 <dfranke> Saizan: I had to stare at that for a while, but that's really cool.
19:43:48 <dfranke> Saizan: up there with Duff's Device in genius and perversity.
19:43:51 <Saizan> heh, i've first read about haskell on defmacro, so i've some mind blowing credit :D
19:44:09 <coffeemug> Saizan: hehe, that's pretty cool
19:44:15 <coffeemug> you've outhaskelled me :)
19:44:23 <chessguy> let subset = (map snd .) . flip (filter . (. fst) . testBit) . zip [0..] in subset [1..5]
19:44:29 <chessguy> > let subset = (map snd .) . flip (filter . (. fst) . testBit) . zip [0..] in subset [1..5]
19:44:30 <lambdabot>  Add a type signature
19:44:30 <SamB> hmm. I think I'm experiencing the NT equivalent of init(1) failing to start because it can't dlopen() a library...
19:45:07 <chessguy> > let subset = (map snd .) . flip (filter . (. fst) . testBit) . zip [0..] in subset [1..5] :: [Int]
19:45:08 <lambdabot>  Couldn't match expected type `[Int]'
19:45:30 <chessguy> hmm
19:45:37 <Saizan> coffeemug: that's because i'm on this channel since then
19:45:39 <chessguy> > let subset = (map snd .) . flip (filter . (. fst) . testBit) . zip [0..] in subset [1..5] 3
19:45:40 <lambdabot>  Add a type signature
19:45:45 <chessguy> wtf
19:45:53 <coffeemug> Saizan: yeah, too much Lisp in my system :)
19:46:18 <ShockSMX> can you guys explain what that does:
19:46:19 <ShockSMX> [22:37pm] <Saizan> > filterM (const [False ..]) [1..3] -- seen this?
19:46:49 <coffeemug> ok
19:46:53 <coffeemug> let's unfold it :)
19:47:04 <dfranke> ShockSMX: remember that for lists, >>= is concatMap.
19:47:04 <ShockSMX> i'm just trying to grasp some haskell basics
19:47:09 <chessguy> @src filterM
19:47:09 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:47:10 <coffeemug> filterM (const [False True]) [1, 2, 3]
19:47:17 <chessguy> ShockSMX, it's not basic
19:47:38 <ShockSMX> i figured. i know duff's device, though, so i was trying to figure out what this is doing.
19:48:23 <dfranke> ShockSMX: they have nothing to do with each other besides being weird :-)
19:48:47 <ihope> :set -fglasgow-exts, then :r, and I get an error message that includes (Use -fglasgow-exts to allow multi-parameter classes)
19:48:56 <gipper> Is this a good place to ask about a type-checker issue?
19:48:57 <phobes> > [False ..]
19:48:58 <lambdabot>  [False,True]
19:49:00 <phobes> weird
19:49:07 <coffeemug> does filterM operate on List or Maybe?
19:49:13 <coffeemug> I can't figure that out
19:49:13 <chessguy> @type FilterM
19:49:15 <lambdabot> Not in scope: data constructor `FilterM'
19:49:19 <chessguy> @type filterM
19:49:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
19:49:22 <ray> false < true for some good reason i forgot
19:49:25 <ShockSMX> alright
19:49:28 <pjd> ShockSMX:
19:49:29 <pjd> > filter (const False) [1..3]
19:49:29 <pjd> > filter (const True) [1..3]
19:49:31 <lambdabot>  []
19:49:31 <lambdabot>  [1,2,3]
19:49:32 <ihope> > False < True
19:49:34 <lambdabot>  True
19:49:54 <pjd> ShockSMX: that's using filter to select no element, or all elements
19:50:02 <ShockSMX> okay
19:50:04 <coffeemug> ahhh I see
19:50:14 <glen_quagmire> > let cfold' f z [] = z; cfold' f z (x:xs) = f x z (\y -> cfold' f y xs); cfold f z l = cfold' (\x t g -> f x (g t)) z l; in cfold (+) 0 [1,2,3]
19:50:15 <lambdabot>  6
19:50:20 <coffeemug> filterM gets all permutations
19:50:27 <phobes> @src filterM
19:50:27 <pjd> coffeemug: yes, exactly :)
19:50:27 <lambdabot> Source not found. You type like i drive.
19:50:39 <coffeemug> but then how does it filter out duplicates?
19:50:51 <pjd> coffeemug: there are no duplicates
19:50:52 <glen_quagmire> do you comprehand that code?
19:50:52 <phobes> There are no duplicates
19:51:07 <ihope> So I'm getting this error in GHCi telling me to turn on -fglasgow-exts, but it's already on, as far as I can tell.
19:51:12 <pjd> the list monad chooses every combination of choosing either True or False for each value
19:51:18 <coffeemug> pjd: [1, 2, 3] and [3, 2, 1]
19:51:40 <pjd> coffeemug: filter doesn't change the order, and neither does filterM
19:51:58 <coffeemug> right but those two are different permuations
19:52:01 <coffeemug> permutations
19:52:06 <coffeemug> which a List monad would return
19:52:15 <phobes> coffeemug: This generates combinations, not permutations
19:52:36 <coffeemug> ahhh
19:52:41 <coffeemug> list monad is combinations
19:52:42 <pjd> coffeemug: only [True, False] is in the list monad
19:52:50 <chessguy> well, no
19:52:51 <pjd> the input list just gets used as a plain list
19:52:55 <chessguy> list monad is non-determinism
19:53:30 <coffeemug> yeah, I need to go back to the books :)
19:53:46 <pjd> so filterM (const [True, False]) just says "for every item, either include it or don't"
19:54:00 <chessguy> coffeemug, i doubt you've run across anything like monads in lisp :)
19:54:00 <pjd> it doesn't change the order of the input items
19:54:18 <coffeemug> chessguy: you could most definetly do monadic style programming in Lisp
19:54:25 <coffeemug> chessguy: it's just not nearly as pleasant :)
19:54:56 <coffeemug> at least not in Common Lisp where you have to take care of a million variants of progn
19:55:12 <SamB> I'd like to steal your technique for implementing return
19:55:16 <chessguy> > do { x <- [1..10]; y <- [1..10]; guard (x + y == 19); return (x,y) }
19:55:17 <lambdabot>  [(9,10),(10,9)]
19:55:33 <chessguy> > do { x <- [1..10]; y <- [1..10]; guard (x + y == 6); return (x,y) }
19:55:35 <lambdabot>  [(1,5),(2,4),(3,3),(4,2),(5,1)]
19:55:53 <phobes> Will lambdabot remember definitions?
19:55:56 <chessguy> coffeemug, you see, it nondeterministically chooses x and y.
19:55:59 <pjd> chessguy: monads hide everywhere!
19:56:21 <pjd> Lisp version: (amb-eval (filter (lambda _ (amb #t #f)) xs))
19:56:25 <chessguy> @help let
19:56:27 <lambdabot> let <x> = <e>. Add a binding
19:56:28 <lament> nondeterministically is not the right word
19:56:36 <chessguy> phobes, ^^
19:56:38 <phobes> thanks
19:56:41 <coffeemug> well it's not nondetermenistic
19:56:50 <coffeemug> you get all combinations of two lists
19:56:53 <lament> right
19:56:54 <coffeemug> and return the results that work
19:56:57 <pjd> lament: right, there was a discussion on reddit about the term
19:57:08 <coffeemug> it's basically bruteforcing
19:57:15 <chessguy> well, the list monad IS nondeterminism
19:57:18 <coffeemug> but doesn't look like bruteforcing because List monad hides it
19:57:19 <chessguy> @where sudoku
19:57:19 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
19:57:28 <gipper> Pardon... Using Data.HashTable.lookup, where HashTable :: String Type, I get a typecheck error saying that it expected 'Maybe Type' but inferred 'IO (Maybe Type)'  ---- my question: though I have 'return'ed the value, I can't seem to overcome the typecheck -- I don't know what's going on
19:57:43 <mudge> dons: it was my nick on reddit programming that was banned I think,  because I registered a new nick on reddit without "mudge" in it and it works
19:57:51 <lament> boo, the #haskell 400 user article is slowly falling off programming.reddit
19:57:53 <chessguy> coffeemug, well that's the point. if you hid it, then you can't really say how it does it.
19:58:03 <coffeemug> you could call a O(n!) nondeterminism too
19:58:04 <mudge> it's a bit of a liability being named after a famous cracker
19:58:13 <coffeemug> when you bruteforce through all solutions
19:58:40 <mudge> boo
19:58:48 <chessguy> coffeemug, that sudoku wiki entry has an interesting discussion of th elist monad and nondeterminism
19:59:16 <mudge> lament: going strong on Hacker News though
19:59:28 <chessguy> gipper, can you paste your code?
19:59:30 <chessguy> @paste
19:59:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:59:52 <chessguy> gipper, i doubt return does what you think it does :)
20:00:12 <mudge> lament: what are you talking about?  the haskell post moved up to number 9
20:00:13 <gipper> undoubtably
20:00:16 <chessguy> return lifts a value into a monad, it doesn't strip it off
20:00:25 <chessguy> s/it/the monad/
20:01:17 <hpaste>  gipper pasted "(no title)" at http://hpaste.org/2358
20:01:54 <Cale> gipper: H is HashTable?
20:01:56 <chessguy> @type Data.HashTable.lookup ?locals ?str
20:01:58 <lambdabot> forall key val. (?locals::Data.HashTable.HashTable key val, ?str::key) => IO (Maybe val)
20:02:00 <gipper> Indeed
20:02:10 <Cale> gipper: You don't need that return at all
20:02:20 <chessguy> yeah, just drop the "return $"
20:02:25 <gipper> tried it with...tried it without...
20:02:25 <Cale> But you should consider not using Data.HashTable
20:02:33 <gipper> Why?
20:02:41 <Cale> Because it sucks compared to Data.Map
20:02:59 <dons> gipper: its slower than Data.Map or Data.IntMap or Data.Sequence, doesn't hold as many elements, and is tainted
20:03:41 <dons> there's some rare uses for an optimised hashtable, but not sure if there's any for HashTable itself.
20:03:42 <chessguy> gipper, by the way, x <- return y is just 'let x = y', i think
20:03:46 <gipper> :) Those are all very good reasons
20:03:47 <Cale> It should really either be removed from the libraries or replaced with a better implementation.
20:03:50 <dons> yeah
20:03:53 <dons> ditch it.
20:04:01 <dons> Igloo: can we remove HashTable into its own package?
20:04:05 <gipper> Excellent -- thank you
20:04:12 <glguy> ?seen Igloo
20:04:13 <lambdabot> Igloo is in #haskell, #haskell-soc, #happs, #ghc and #darcs. I last heard Igloo speak 5h 36m 54s ago.
20:04:13 <dons> Cale, i bet we could get it removed with a good libraries@ proposal
20:04:41 <Cale> dons: At least hidden -- I think it's used directly by GHC somehow?
20:04:53 <dons> ghc uses its own in the rts.
20:04:56 <dons> not the haskell one though
20:05:00 <Cale> (though one could make a fairly strong argument that GHC shouldn't use it either :)
20:05:04 <gipper> Is there perhaps a index page I might reference off the top of your head as to troublesome/most useful datastructures (no trouble -- Google knows all)
20:05:07 <dons> simonm added it for a shootout strings benchmark long ago, iirc
20:05:16 <dons> gipper: oh, good idea. hmm.
20:05:35 <dons> we don't have a page yet. but you should almost always consider Data.Map for lookup structures
20:06:17 <chessguy> or a Bimap, once it's written :)
20:06:23 <Cale> gipper: Data.List (obviously), Data.Map, Data.Set (and the Int* variations), Data.Sequence are the really beautiful structures.
20:06:32 <Cale> We really need a Data.Rel
20:06:53 <chessguy> Cale, Data.Rel?
20:07:26 <Cale> A proper implementation of general relations, with good performance and all the desirable operations.
20:07:33 <gipper> Perhaps on a related note -- I love the API docs, but I am a "learn by example" person -- any pointers on content for these structures?
20:08:15 <mudge> coffeemug: you there?
20:08:18 <coffeemug> yes
20:08:19 <gipper> It can be internal to projects -- I just want some clue as to proper usage
20:09:07 <mudge> coffeemug: just curious, I've seen some people complain about libraries in Common Lisp,  making it hard to do things like Web programming and maybe database access
20:09:24 <mudge> since your building a web framework in common lisp,  I'm curious about your opinion
20:09:26 <chessguy> gipper, Data.Map is a dictionary type of data structure
20:09:30 <coffeemug> well
20:09:34 <mudge> like this entry: http://www.ketralnis.com/roller/dking/entry/20070609
20:09:36 <lambdabot> Title: David King : Weblog
20:09:51 <coffeemug> not sure if you've seen the demo
20:09:52 <coffeemug> http://72.249.76.121/
20:09:53 <lambdabot> Title: Weblocks Demo - A Technology Demonstration
20:10:00 <coffeemug> it works
20:10:07 <Cale> gipper: Hmm, there are probably bits of code lying around which use them, I might be able to find something...
20:10:08 <coffeemug> so I don't know what they're complaining about
20:10:19 <coffeemug> I read this guy's article
20:10:22 <Cale> gipper: Mostly, if you just follow the type signatures, it's fairly straightforward.
20:10:28 <gipper> Indeed
20:10:32 <mudge> I'm checking out the demo
20:10:37 <coffeemug> and all the libraries he's complaining about are defacto standard and are one google search away
20:10:51 <coffeemug> so I really don't know
20:10:56 <chessguy> > let m = Data.Map.fromList (zip [0..] "abcdefghijklmnopqrstuvwxyz") in m Data.Map.! 15
20:10:56 <coffeemug> I'm sure some libraries are missing
20:11:01 <coffeemug> but not the ones he's talking about
20:11:04 <lambdabot>   Not in scope: `Data.Map.!'
20:11:38 <chessguy> sigh
20:11:50 <chessguy> gipper, in theory, that would return 'o'
20:11:53 <Cale> > M.empty
20:11:54 <lambdabot>  fromList []
20:12:00 <mudge> coffeemug:  thanks,   someone from #lisp just told me that that guy is detached from reality
20:12:05 <Cale> > M.insert 0 "Hello" M.empty
20:12:07 <lambdabot>  fromList [(0,"Hello")]
20:12:14 <gipper> Many thanks
20:12:20 <chessguy> > let m = M.fromList (zip [0..] "abcdefghijklmnopqrstuvwxyz") in m M.! 15
20:12:22 <lambdabot>  'p'
20:12:27 <chessguy> p?
20:12:37 <chessguy> oh, i started at 0
20:12:48 <coffeemug> mudge: lisp is probably missing some esoteric libraries you might end up needing
20:12:59 <glguy> has (!) always been in Data.Map?
20:13:01 <coffeemug> but not such common stuff as FFI, SQL access, Web, etc.
20:13:39 <Cale> > M.fromListWith (+) (zip "abracadabra" [1,1..])
20:13:41 <lambdabot>  fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
20:14:00 <mudge> coffeemug: ah, thanks
20:14:02 <chessguy> Cale, cute
20:14:19 <pjd> nifty
20:14:39 <glguy> Was Data.Map in 6.2.2?
20:15:04 <coffeemug> btw, another way to do that
20:15:08 <Cale> glguy: no, it was Data.FiniteMap
20:15:11 <coffeemug> would be
20:15:11 <Cale> http://www.haskell.org/ghc/docs/6.2.2/html/libraries/
20:15:47 <coffeemug> hmm one sec
20:16:39 <Cale> > map (head &&& length) . group . sort $ "abracadabra"
20:16:41 <lambdabot>  [('a',5),('b',2),('c',1),('d',1),('r',2)]
20:18:13 <gravity> Sweet, my first usage of a monad transformer along with custom data type.
20:18:14 <dmwit> :t M.fromListWith
20:18:16 <lambdabot> Couldn't find qualified module.
20:18:28 <Cale> :t Data.Map.fromListWith
20:18:30 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
20:18:52 <chessguy> gravity++ good job!
20:18:59 <dmwit> oh neat
20:19:24 <gravity> :-)
20:19:59 <Cale> > M.fromListWith (+) (zip "abracadabra" [1,1..]) ! 'r'
20:20:00 <lambdabot>  Couldn't match expected type `Array i e'
20:20:04 <Cale> > M.fromListWith (+) (zip "abracadabra" [1,1..]) M.! 'r'
20:20:06 <lambdabot>  2
20:20:46 <Cale> > M.lookup 'r' (M.fromListWith (+) (zip "abracadabra" [1,1..]))
20:20:47 <lambdabot>   add an instance declaration for (Show (m a))
20:20:54 <Cale> > M.lookup 'r' (M.fromListWith (+) (zip "abracadabra" [1,1..])) :: Maybe Integer
20:20:55 <lambdabot>  Just 2
20:21:25 <ddarius> Ich bin froh.
20:21:59 <Cale> > M.size (M.fromListWith (+) (zip "abracadabra" [1,1..]))
20:22:01 <lambdabot>  5
20:23:02 <chessguy> let count c s = M.fromListWith (+) (zip "abracadabra" [1,1..]) M.! c in count 'a' "abracadabra"
20:23:06 <chessguy> > let count c s = M.fromListWith (+) (zip "abracadabra" [1,1..]) M.! c in count 'a' "abracadabra"
20:23:07 <lambdabot>  5
20:23:13 <chessguy> > let count c s = M.fromListWith (+) (zip "abracadabra" [1,1..]) M.! c in count 'e' "abracadabra"
20:23:14 <lambdabot>  Exception: Map.find: element not in the map
20:24:06 <Cale> > let count c s = M.findWithDefault 0 c (M.fromListWith (+) (zip s [1,1..])) in count 'e' "abracadabra"
20:24:08 <lambdabot>  0
20:24:12 <Cale> > let count c s = M.findWithDefault 0 c (M.fromListWith (+) (zip s [1,1..])) in count 'a' "abracadabra"
20:24:14 <lambdabot>  5
20:24:27 <dmwit> > let count c = length . filter (== c) in count 'a' "abracadabra"
20:24:28 <lambdabot>  5
20:24:38 <Cale> Indeed :)
20:25:11 <chessguy> dmwit, that's beside the point
20:25:18 <dmwit> I know, I know.
20:25:24 <glguy> > 5
20:25:26 <chessguy> party popper!
20:25:26 <lambdabot>  5
20:25:48 <chessguy> glguy, is that a random number generator? :)
20:26:05 <hpaste>  int-e annotated "Regular expressions" with "use an infinite trie-like structure" at http://hpaste.org/2341#a3
20:26:09 <dmwit> Mine could never be used to count occurrences of multiple letters in the same string, unless you don't have a good CS demon on your shoulder. ;-)
20:26:23 <int-e> DRMacIver: paste annotation for you :)
20:27:11 <pjd> *head asplode*
20:28:29 <chessguy> oh coffeeguy, have you seen this?
20:28:31 <wli> I think the FSM might be more compact a data structure.
20:28:40 <chessguy> @go haskell write yourself scheme 48 hours
20:28:43 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:28:43 <lambdabot> Title: Write Yourself a Scheme in 48 hours
20:28:51 <Cale> Flying Spaghetti Monster
20:28:55 <sorear> @users
20:28:55 <lambdabot> Maximum users seen in #haskell: 411, currently: 374 (91.0%), active: 16 (4.3%)
20:29:06 <glguy> yikes
20:29:14 <wli> What, no "Write Yourself a Haskell in 48 Hours?"
20:29:21 <chessguy> coffeemug, oops, that link was for you, not coffeeguy
20:29:50 <coffeemug> yeah
20:30:09 <coffeemug> before I saw that
20:30:12 <coffeemug> I wrote this though: http://www.defmacro.org/ramblings/lisp-in-haskell.html
20:30:13 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
20:30:20 <chessguy> nice
20:31:14 <ddarius> Sweet. http://www.tyingtheknot.com/
20:31:15 <lambdabot> Title:
20:31:45 <ddarius> Er, .org
20:31:58 <mudge> I'm new to IRC,  why do so many people not leave the channel when they go away?
20:32:16 <coffeemug> mudge: why leave?
20:32:18 <mudge> when they are gone from the computer,  they keep in the #haskell channel
20:32:20 <dons> so they can read comments in scrollback, for one.
20:32:20 <coffeemug> if your computer is running all day
20:32:35 <dons> people can talk to you as if you're here, and then you can reply later
20:32:36 <ddarius> mudge: It also keeps their logs complete.
20:33:03 <pjd> what's the difference between "strong" and non-strong monads/functors?
20:33:48 <ddarius> pjd: Whether the defining attributes are "internal" or not (similarly for strong adjunctions).
20:33:50 <mudge> ok, thanks guys,  I'll guess I'll do that too,  keep in the channel when I'm away
20:34:08 <mudge> since I'm committed
20:34:16 <dons> cool :)
20:34:52 <jtokle> i'm looking at some ffi code, trying to learn
20:35:02 <pjd> internal?
20:35:07 <ddarius> pjd: A strong functor is not just a function Hom(A,B) -> Hom(FA,FB), but also an arrow B^A -> FB^FA
20:35:08 <jtokle> what's up with the "newtype Foo = Foo (Ptr Foo)" idiom?
20:35:36 <ddarius> jtokle: So you don't mismatch your Ptr's and so that you can hide that it is a Ptr.
20:35:45 <mrd> typing /quit is hard work
20:35:53 <dons> yeah, you wrap the Ptr so you can't confuse different Ptrs.
20:35:53 <Modius> Has anyone on here (particularly C# programmers in their day jobs) used things like Map and Intersperse, etc. in their non-FP languages?  How easy is the practice to get accepted by others?
20:35:53 <int-e> DRMacIver: I should've thought of this yesterday, of course it is possible to simply build a 'map' that contains *all* possible regular expressions, and let lazy evaluation take care of the rest.
20:35:54 <pjd> ddarius: what's the ^ there?
20:36:24 <pjd> ...opposite category?
20:36:31 <ddarius> pjd: Exponentiation.  I.e. an object representing the arrows from A to B.
20:36:39 <pjd> oh
20:37:01 <chessguy> coffeemug, it looks like your Context thing snuck in before you intended it to
20:37:06 <chessguy> (in that blog)
20:37:32 * ddarius wrote some lazy stream stuff in C# and used it, but wasn't trying to have it accepted by other coworkers.
20:37:46 <ddarius> It's really important to memoize that stuff...
20:37:49 <chessguy> coffeemug, oh! never mind, it's my brain that's malfunctioning
20:37:57 <coffeemug> chessguy: I'm not sure what you meant
20:38:09 <lament> is it easy to use higher-order functions in C#?
20:38:16 <ddarius> cofeemug: It sounds like that's a good thing.
20:38:20 <ddarius> lament: Yes.
20:38:27 <Modius> C# benefits from having IEnumerable<T> yielding/coroutine functions
20:38:39 <Modius> What C# lacks is a userbase that can tolerate having code turned "inside out" into functional :)
20:38:48 <ddarius> Especially, presumably in C#3.0 but even in 2.0 it's not bad just more verbose than one is used to in Haskell.
20:39:08 <dons> ddarius: did you see the parser combinators in C# 3.0 yesterday?
20:39:09 <ddarius> The yielding stuff is fairly nice.
20:39:11 <Modius> What C# 3 will bring (not counting Linq; but straight up functional equivalents) is the extra inferencing.
20:39:23 <coffeemug> ddarius: how is it nice if it's only limited to iterators?
20:39:23 <ddarius> dons: I heard someone mention them, but I didn't get a link.
20:39:24 <dons> i wonder if the future will look kinda like a borken haskell.. :|
20:39:38 <Modius> Haskell = C# 8.0
20:39:39 <coffeemug> it's just a bunch of nice special cases
20:39:51 <dons> ddarius: http://blogs.msdn.com/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
20:39:53 <lambdabot> Title: LukeH's WebLog : Monadic Parser Combinators using C# 3.0, http://tinyurl.com/2srswy
20:39:53 <coffeemug> all put together very nicely
20:40:02 <ddarius> Modius: It's looking like it will be relatively close, but not =.
20:40:07 <dons> augustss made the point that it is not polymorphic in the monad though
20:40:16 <Modius> Lot of haskell/FP guys on teh language team as I heard it.
20:40:16 <dons> so you need to rewrite your monad ops for each use
20:40:35 <pjd> ddarius: wait, is Hom(A,B) the set of morphism from A to B?
20:40:45 <Modius> The new syntax hints at where they're heading, although you're right, they'll slowly go as far as the average C# programmer will tolerate, then discard when the language is sufficiently bogged down with trash.
20:40:47 <ddarius> pjd: Yes.
20:40:53 <pjd> how does that differ from the set of arrows from A to B?
20:41:06 <pjd> (i.e. B^A, if i'm following)
20:41:09 <ddarius> pjd: It doesn't.  "arrow" and "morphism" are synonymous.
20:41:15 <ddarius> B^A is an object not a set.
20:41:23 <SamB> iterate until you reach nirvanna?
20:42:23 <ddarius> pjd: Strength doesn't really matter for Haskell because all it's monads are inherently strong.  For semantics, it mostly means that monads respect the lexical environment.
20:44:42 <pjd> ah
20:44:46 * pjd sees faint light
20:45:25 * ddarius should email that monadic parser combinators in C# 3.0 to a coworker of his.
20:46:08 <pjd> is the difference that the *function* Hom(A,B) -> Hom(FA,FB) implies less about the resulting transformation than B^A -> FB^FA ?
20:46:35 <pjd> that is, the latter implies the compositionality and such normally associated with arrows/morphisms, but the former not?
20:47:17 <pjd> or am i talking nonsense
20:47:27 <ddarius> pjd: I'm not really following what you are saying.  The difference is a function Hom(A,B) -> Hom(FA,FB) is outside the category and an arrow B^A->FB^FA is inside the category.
20:48:44 <mudge> @seen simonpj
20:48:44 <lambdabot> I haven't seen simonpj.
20:48:47 <pjd> i *think* i mean the same
20:50:04 <ddarius> The arrow B^A -> FB^FA being inside the category also means that it is "structured" in the ways that arrows are in that category which is stronger than just being able to turn an arrow A->B into an arrow FA->FB "somehow".
20:50:16 <pjd> right
20:50:18 <ddarius> E.g. for CPO the function is continuous.
20:51:27 <pjd> that (i think) is what i was trying to say with "[additionally] implies the [etc.] normally associated with morphisms [in that category]"
20:53:17 <pjd> ddarius: thanks for the explanation
20:54:10 <ddarius> Strength for monads can be reduced to having a natural transformation AxTB -> T(AxB).  For Haskell that can easily be written strength (a,mb) = do b <- mb; return (a,b) and you can see how "performing" mb preserves the environment 'a'.
20:54:47 <ddarius> I believe there are some straightforward laws it has to satisfy as well.
20:55:37 <ddarius> Probably along the lines of liftM fst (strength (a,mb)) == return a
20:56:10 <ddarius> Not quite that.
20:56:30 <pjd> "[the monad laws] boil down to the axioms that M be a strong monad, in the categorical sense."
20:56:32 <pjd> wooh!
20:56:36 <pjd> i think i actually get that
20:56:58 <ddarius> Also, Moggi require \eta (that is return) to be mono.
20:57:22 <pjd> (mono = monomorphism?)
20:57:25 <ddarius> Yes.
20:57:58 <ddarius> There is more or less only one monad implementable in Haskell that has a non-mono return.
20:59:30 <pjd> the null monad?
20:59:45 <ddarius> The "constant" one, yes.
21:00:10 <pjd> :D
21:00:27 <ddarius> pjd: Why is it the only one?
21:01:24 <pjd> because any other return must be information-preserving for the monad laws to be satisfied
21:02:04 <ddarius> pjd: Nope.  That may be true, but is not it.  Why can you not even write another non-mono return?
21:02:18 <pjd> hmm
21:02:58 <phobes> Because of Haskell's crappy type system
21:03:32 <ddarius> return not being mono means return x == return y even though x /= y.  For the constant monad we do it by simply making forall x,y. return x == return y.  There's your hint.
21:04:28 * pjd ponders
21:04:40 <coffeemug> ehh
21:04:50 <coffeemug> all this lisp coding made me forget how deliciously sexy haskell can be :)
21:05:01 <coffeemug> at least out of the box haskell
21:05:13 <coffeemug> assuming you believe much of haskell can be recreated in lisp :)
21:05:35 <ddarius> coffeemug: I don't believe that.
21:05:53 <ddarius> (At least not in a meaningful way, unless by lisp you mean Scheme perhaps and then I still don't believe it.)
21:05:53 <Korollary> recreated as in turing tarpit?
21:05:59 <coffeemug> well, lazyness can be
21:06:06 <coffeemug> monads can be
21:06:12 <coffeemug> type system probably cannot be
21:06:15 <dons> you need the enforced purity and a type system though :)
21:06:17 <pjd> wasn't the first(ish) Haskell implementation created in Lisp?
21:06:21 <dons> otherwise its no fun
21:06:21 <coffeemug> so we have 2 out of 3 defining features of haskell :)
21:06:22 * pjd ducks
21:06:27 <ddarius> coffeemug: Laziness, no except in Scheme.  Monads, yes but that's not hard.
21:06:39 <coffeemug> laziness most definetly can be
21:06:40 <conal> pjd: yale haskell
21:06:44 <coffeemug> even in CL
21:07:00 <coffeemug> enforced purity, no
21:07:01 <Korollary> Is delay/force in CL proper or are they extensions?
21:07:07 <pjd> ddarius: be right back, coffee
21:07:16 <coffeemug> there is no delay force
21:07:18 <ddarius> coffeemug: You can easily make thunks, but you can't locally express the effect of laziness everywhere.
21:07:22 <coffeemug> but they're pretty easy to write
21:07:42 <Korollary> yes
21:07:54 <Korollary> I was wonderding if they were common extensions, too
21:07:58 <ddarius> I.e. to make your code lazy you need to transform all of it to use delay/force.  You can't just add it where you like.
21:08:08 <coffeemug> you just transform (delay expr) to (lambda () expr)
21:08:11 <ddarius> (To some extent you can, but not completely.)
21:08:24 <coffeemug> ddarius: right
21:08:40 <coffeemug> certainly not easy to make the whole thing suddenly lazy
21:08:46 <ddarius> With continuations it may be possible to do that.
21:08:55 <Korollary> it's a radical approach anyway
21:09:32 <ddarius> "that" meaning if I pass my lazy-f function to the normal mapcar it would do the right thing.
21:19:38 <pjd> ddarius: ok, i think i see
21:19:41 <pjd> it hinges on return's polymorphism?
21:19:51 <ddarius> pjd: Yes.
21:20:19 <pjd> that is, you can make it non-mono by inspecting the value
21:20:32 <pjd> but that makes the return no longer polymorphic
21:20:50 <phobes> parametricity theorem
21:20:54 <ddarius> Yep, except that you can also make it non-mono by simply dropping it which is what the constant monad does.
21:20:59 <pjd> parawhatnow?
21:21:09 <ddarius> phobes: Indeed.  Naturality/parametricity.
21:21:22 <mudge> coffeemug: how does the language/libraries support of Common Lisp compare to Haskell?
21:21:27 <pjd> ddarius: right
21:21:28 <ddarius> pjd: You know what a natural transformation is in category theory?
21:21:34 <mudge> for Web programming that is
21:22:10 <ddarius> You can do it almost as a case analysis: you can drop the argument, duplicate it, or shuffle it about corresponding to the proof rules weakening, contraction and identity/axiom respectively.
21:22:13 <pjd> ddarius: i believe my understanding is a firm "maybe"
21:22:45 <pjd> oh, i didn't consider duplicating it
21:22:59 <mrd> mudge: i'm not coffeemug and this isn't really the place to discuss it, but I did work on CL web apps before learning Haskell
21:23:14 <pjd> oh, but duplicating it is mono, so nevermind
21:23:23 <coffeemug> mudge: CL is different
21:23:36 <mrd> they generally take an OO approach
21:23:50 <coffeemug> its libraries (aside from some high quality common stuff) feel like unorganized "good enough" bits and pieces
21:24:06 <coffeemug> I write a lib that's good enough for me, release it, you bite the bullet and use it
21:24:16 <coffeemug> eventhough it has a lot of holes
21:24:17 <pjd> ddarius: would that be proof rules as in Hindley-Milner?
21:24:30 <coffeemug> Haskell feels like a more unified effort
21:24:38 <coffeemug> I don't know
21:24:43 <coffeemug> as far as web app is concerned
21:24:46 <ddarius> coffeemug: That's because there's a smaller more coherent community.
21:24:58 <coffeemug> both Haskell and CL are just fine
21:24:58 <mrd> since Haskell effort concentrates around GHC
21:25:27 <coffeemug> I think it's possible to create a much cooler web app in Haskell than in CL
21:25:29 <ddarius> pjd: Proof rules of logic in general.  In particular substructural proof rules that often go without saying (e.g. see linear logic).
21:25:57 <ddarius> coffeemug: I don't.  The insides might be prettier but as far as the outsides are concerned they should be equi-expressive.
21:25:59 <coffeemug> but it will take expert knowledge of Haskell (which is very time consuming to obtain), some additions to GHC, and lots of time
21:26:14 <coffeemug> ddarius: I disagee
21:26:19 <coffeemug> one example
21:26:31 <coffeemug> in Haskell it's trivial to enforce no side effects on GET requests
21:26:35 <coffeemug> in CL it's impossible
21:26:45 <ddarius> What does that matter to the end-user?
21:26:56 <coffeemug> ddarius: not one bit
21:27:05 <coffeemug> ddarius: when I said "cooler" I meant what I'd like to program in
21:27:11 <coffeemug> end user will see the same thing :)
21:27:26 <ddarius> So "web app [framework]" or some such.
21:27:45 <coffeemug> oh sorry
21:27:50 <coffeemug> I meant framework
21:27:58 * ddarius is just persnickety.
21:28:11 <pjd> ddarius: thanks again;  that was most enlightening
21:28:33 <coffeemug> I generate UI automatically from dataypes in Lisp
21:28:36 <coffeemug> and it works really well
21:28:43 <coffeemug> but it could work significantly better in Haskell
21:28:55 <coffeemug> because you can encode *and* enforce stuff with the typesystem
21:29:08 <ddarius> coffeemug: See TV perhaps? (though not web-based)
21:29:28 <phobes> because your Lisp code has side-effects in response to GET requests?
21:29:32 <coffeemug> CL's typespecs are nice and expressive but they have very weak spots
21:29:35 <coffeemug> ddarius: TV?
21:30:00 * conal 's ears perk up
21:30:00 <coffeemug> phobes: there is no way for me to *ensure* someone won't write a side-effect function on get
21:30:22 <conal> TV will be web based!
21:30:25 <ddarius> http://conal.net/papers/Eros/
21:30:25 <lambdabot> Title: Tangible Functional Programming
21:30:29 <Korollary> conal: an unlucky abbreviation
21:31:00 <Korollary> How about Enterprise Values instead?
21:31:04 <conal> also http://www.haskell.org/haskellwiki/TV
21:31:05 <lambdabot> Title: TV - HaskellWiki
21:31:10 <conal> Korollary: Enterprise??
21:31:47 <conal> @where TV
21:31:48 <lambdabot> I know nothing about tv.
21:31:56 <coffeemug> hehe
21:31:57 <coffeemug> that's cool
21:31:59 <conal> @where+ http://www.haskell.org/haskellwiki/TV
21:31:59 <lambdabot> Done.
21:32:05 <coffeemug> I tried to do something similar (but less abstract) here
21:32:06 <coffeemug> http://www.defmacro.org/ramblings/haskell-web.html
21:32:07 <conal> @where TV
21:32:07 <lambdabot> I know nothing about tv.
21:32:08 <lambdabot> Title: Haskell and Web Applications
21:32:36 <Korollary> I think it's where+ keyword uri
21:32:38 <coffeemug> I basically generated HTML UI from datatypes
21:32:43 <coffeemug> same thing I do in Lisp
21:32:49 <maskd> @where http://www.haskell.org/haskellwiki/TV
21:32:51 <coffeemug> but it's just cooler in Haskell because of its type system
21:33:00 <conal> @where+ TV http://www.haskell.org/haskellwiki/TV
21:33:01 <lambdabot> Done.
21:33:06 <conal> @where TV
21:33:06 <lambdabot> http://www.haskell.org/haskellwiki/TV
21:33:08 <conal> !
21:33:12 <conal> i love lambdabot
21:33:51 <Korollary> @remember conal i love lambdabot
21:33:51 <lambdabot> Done.
21:33:51 <conal> @where DeepArrow
21:33:51 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
21:34:08 <coffeemug> yeah, lambdabot is a strike of genious
21:34:09 <coffeemug> :)
21:34:30 * lambdabot preens
21:34:47 <ddarius> lambdabot is the steady accretion of... stuff over the course of four or five years.
21:34:57 <ddarius> Or rather unsteady actually.
21:35:38 <pjd> ddarius: ...ok, dare i ask what costrong means?
21:35:52 <ddarius> It constantly amazes me how far lambdabot has come despite being born as a code toy and essentially always being that.
21:36:11 <pjd> i'm trying to figure out what arrows need reversing
21:36:14 <ddarius> pjd: I've never even heard of costrong, and I don't really see how there could be a conotion.
21:36:32 <ibid> heh, isn't costrong weak? :)
21:36:58 <pjd> ddarius: i'm reading the "Arrows, like Monads, are Monoids" paper
21:37:21 <ibid> from my perspective, as a #haskell idler, lambdabot just appeared and grew
21:37:22 <ibid> :)
21:37:40 <Pseudonym> Actually, it wasn't even born as a toy.  It was born as a test.
21:37:52 <Pseudonym> I just wanted to work out how the socket library works.
21:38:00 <ibid> at one point, there was no lambdabot. then everybody was toying with lambdabot
21:38:19 <ibid> then the channel flooded with @yarr
21:38:24 * lambdabot purrs
21:38:37 <coffeemug> @yarr
21:38:37 <lambdabot> Avast!
21:38:39 <coffeemug> lol
21:38:43 <coffeemug> @lol
21:38:44 <lambdabot> Maybe you meant: let pl url yow
21:38:51 <coffeemug> heh
21:39:03 <coffeemug> @pc a $ b
21:39:04 <lambdabot> Maybe you meant: pl rc
21:39:14 <pjd> while talking about the (i guess you would call it) arrow lifting functor in Hask, it says "This functor is strong in its second argument, and costrong in its first"
21:39:19 <coffeemug> @pc \a b-> a $ b
21:39:19 <lambdabot> Maybe you meant: pl rc
21:39:24 <ibid> @let pl url yow
21:39:25 <lambdabot>  Parse error
21:39:34 <ibid> i did what the bot asked!
21:39:40 <coffeemug> @pl \a b-> a $ b
21:39:40 <lambdabot> id
21:39:42 <coffeemug> ah
21:39:52 <coffeemug> @pf \a b-> a $ b
21:39:53 <lambdabot> Maybe you meant: bf pl
21:40:10 <coffeemug> sorry for flooding :)
21:40:19 <shachaf> @pointful id
21:40:19 <lambdabot> (\ a -> a)
21:40:27 <ddarius> pjd: Yes, I guess that makes sense.
21:41:50 <ddarius> pjd: There's a general notion of strength and then the arrow/monad specific one.
21:43:53 <dons> http://programming.reddit.com/info/2h4pl/comments
21:43:54 <lambdabot> Title: New work appearing at the 2007 Haskell Workshop (reddit.com)
21:44:26 <Korollary> '4
21:44:31 <Korollary> argh sorry
21:44:42 <dons> ``4'' iirc
21:45:13 <ddarius> 1904 the year of the great 0 shortage.
21:46:46 <coffeemug> Run-time Code Generation in Haskell
21:46:48 <mudge> ddarius, coffeemug,  thanks for you answers to my question about haskell/lisp Web libraries
21:46:51 <coffeemug> that sounds interesting
21:46:59 <coffeemug> mudge: just pick one and jump in
21:47:04 <coffeemug> mudge: it really doesn't matter
21:47:17 <mudge> ok, thanks,  I"m going to jump in Haskell
21:47:33 <coffeemug> mudge: but if you pick Haskell be prepared to spend a lot of time getting nothing done because you don't understand how some things work
21:47:42 <coffeemug> it's true about Lisp as well, of course
21:47:56 <dons> i think it depends on the programmer
21:48:01 <mudge> I've been reading Programming in Haskell,   been doing the exercises: http://nickmudge.info/haskell.html
21:48:02 <coffeemug> but Lisp lets you get useful stuff done faster, I think
21:48:04 <lambdabot> Title: Haskell Notes
21:48:12 <coffeemug> if you're new to the language
21:48:14 <dons> and how deep imperative/mutable thinking is embedded.
21:48:22 <coffeemug> dons: I don't think so
21:48:31 <dons> that's been my experience and observation
21:48:37 <coffeemug> Haskell forces you to do some mindbending stuff for somewhat easy things
21:48:37 <mudge> coffeemug: I've been studying Haskell enough already to not get a lot done
21:48:39 <dons> the more imperative they think, the more they struggle
21:48:43 <phobes> I think there's also an issue of how much your problem really involves state and mutation
21:48:51 <scodil> anyone know of any simple programs that use haskelldb and sqlite? or any other good material for lightweight haskelldb usage?
21:48:59 <phobes> If you're writing a simulator for some complex process, you're going to be fighting Haskell alot
21:49:05 <dons> scodil: i think maybe hope, the blog program, uses haskelldb?
21:49:17 <coffeemug> dons: well, I don't struggle with functional approach/lazyness/purity
21:49:29 <dons> phobes: sounds like you should be using a pure model and a stateT monad :)
21:49:41 <coffeemug> my struggles in Haskell usually involved understanding complex type system issues
21:50:25 <coffeemug> and the fact that doing something simple like introspection required me to spend many hours reading SYB papers
21:50:32 <mudge> I feel like I got familiar with and could use Common Lisp in June and July,  a month and a half time,   I"m 20 days into Haskell and it is a lot slower,  and it is causing me to think differently,  and I like it,  and it makes me very curious
21:50:57 <coffeemug> mudge: basically if you're in a hurry to get something done, use CL
21:51:19 <mudge> when I was writin in Common Lisp,  I kept making Common Lisp be an imparative language,  but with more function calls
21:51:22 <coffeemug> mudge: if you can take some extra time and want to bend your mind, use Haskell
21:51:28 <dons> coffeemug: i'm not sure introspectoin is simple. that's the perspective you bring from other paradigms
21:51:42 <phobes> dons:  The problem I have is that Haskell doesn't let me easily organize and compartmentalize my state ... to do that it looks like I need to involve a bunch of monad transformers
21:51:53 <coffeemug> dons: it's much simpler to understand in other languages
21:51:58 <dons> considering the semantics for introspection are terribly hairy, its a mistake to say its simple. much like IO -- not simple to describe
21:51:58 <Modius> mudge:  Lisp isn't forcing you into anything.  I've written a CL library (imperfect but workable) that rips off a lot of haskell laziness/functionality; but any 2 CL programmers can be programming in a radically different way
21:51:59 <mudge> thanks, coffeemug,  I've got plenty of time to learn  so I'll learn and write more Haskell
21:52:14 <ddarius> Introspection isn't too bad.
21:52:22 <coffeemug> it's not, once you get it
21:52:23 <dons> phobes: right, you should have seperate state types, and separate monads to run things
21:52:33 <ddarius> coffeemug: Reflection is bad.
21:52:43 <Modius> mudge:  CL or Haskell (or even C#), IMHO, it's worth eating a bit of pain to learn functional/stateless as it's a benefit in all the languages
21:52:52 <coffeemug> reflection is another word for introspection :)
21:53:17 <dons> its fine when your language is built around having runtime access to the interpreter
21:53:23 <dons> but that doesn't mean its simple to write down how it works
21:53:24 <ddarius> coffeemug: I limit introspection to just being able to look at things like run-time types, while I allow reflection to allow you to change them.
21:53:30 <mudge> Modius:  ah thanks
21:54:18 <mudge> but I imagine that if you write enough haskell you eventually think enough in it that you can write applications fast in haskell?
21:54:35 <dons> definitely.
21:54:36 <ddarius> mudge: Of course.
21:54:38 <coffeemug> ddarius: I think of reflection as of broken AMOP
21:54:55 <coffeemug> mudge: yes, it will just take longer
21:55:08 <coffeemug> I remember I was being fairly proficient in Haskell
21:55:14 <coffeemug> even though I didn't grok everything at the time
21:55:21 <coffeemug> but most things I was able to comprehend
21:55:22 <mudge> is there more benefit to think and write in haskell than not?   I guess that is a pretty subjective question
21:55:32 <coffeemug> mudge: just do it :)
21:55:39 <coffeemug> it's worth it
21:55:52 <dons> you understand programming once you've learnt haskell - concepts are made explicit that are implicit or poorly understood elsewhere
21:56:00 <mudge> I write PHP for my day job,   I'm already thinking of ways to turn my PHP code into a more functional style
21:56:18 <coffeemug> mudge: that's a curse of learning a functional language
21:56:19 <ddarius> mudge: Run! Run now while you can!
21:56:22 <coffeemug> day job becomes hell :)
21:56:34 <mudge> haha
21:56:35 <dons> and what with monads in C#, you'll need to know this stuff inside out to get a basic enterprise job soon
21:56:56 <ddarius> Interviewer question: "What is a monad?"
21:57:05 <mudge> already people are looking at me funny at work when I say I've been studying Common Lisp and Haskell
21:57:23 <coffeemug> dons: I don't know about that :)
21:57:26 <dons> "How would you solve this efficiently with 64 cores available, without shared state" ? :)
21:57:28 <phobes> heh, the enterprise community has yet to have its way with monads... the haskell crowd might not recognize them
21:57:50 <dons> phobes: i already don't recognise some stuff in C# that's supposed to be inspired by haskell
21:58:00 <dons> its like saying ruby is a lisp :)
21:58:01 <phobes> AbstractMonadFactory<...>
21:58:08 <coffeemug> oh, people thought of me as INSANE when I left my job
21:58:13 <dons> or  those "java is a lisp" guys
21:58:19 <coffeemug> hmm
21:58:24 <coffeemug> let me paste my farewell letter
21:58:33 <coffeemug> so you get a sense for how crazy they thought I am :)
21:59:13 <dolio> Everything is lisp. :)
21:59:38 <mudge> coffeemug: okay,  where you pasting your farewell letter?
21:59:42 <coffeemug> hmm
21:59:45 <coffeemug> I'm trying to find a place
21:59:52 <coffeemug> to paste stuff
21:59:56 <wli> dolio: Not Fortran (it predated Lisp).
22:00:10 <dolio> A rare exception. :)
22:00:14 <ddarius> wli: You think that would stop them?
22:00:19 <coffeemug> what's a good site for pasting text and sending link?
22:00:22 <shachaf> @paste ?
22:00:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:00:36 <wli> ddarius: Not really.
22:00:44 <hpaste>  coffeemug pasted "Farewell Letter" at http://hpaste.org/2359
22:01:12 <phobes> dons:  Let's say I have a simulation of objects of various types A, B, C, D...   and then I have functions updateA, updateB, interactAandB, etc.  How would you set that up in Haskell?
22:02:07 <wli> Heh, I guess I've not been brave enough to choose Sussman and Minsky over Oracle and Sun.
22:02:15 <dons> State monad, with a pure data structure for the simulation
22:02:28 <dons> phobes: see xmonad for example, pure internal model, State monad for the updates
22:02:48 <Korollary> coffeemug: That's a bit of a crazy goodbye letter
22:02:53 <dons> people do lots of model/simulatoin stuff in haskell, since you can get references implementations pretty clear
22:02:53 <wli> (I'm the Linux sparc32 maintainer and works for Oracle.)
22:03:14 <phobes> dons:  Just one State monad?  What's the type of updateA?
22:03:20 <coffeemug> yeah, it was a bit insane
22:03:28 <mudge> wow
22:03:29 <coffeemug> but I grew fond of my coworkers
22:03:40 <coffeemug> I wanted them to learn what I'm about :)
22:03:40 <phobes> dons:  You don't want to just throw all of your objects into one "world state" and have updates on that
22:03:49 <mudge> did people reply to your letter?
22:03:55 <coffeemug> and not think of me as "some dude who talks of crazy languages all the time"
22:04:03 <coffeemug> yeah, people replied
22:04:14 <phobes> dons:  It seems cleaner to me to have a function that can update an A, a function that can update a B, etc.
22:04:19 <coffeemug> mostly saying "wow, I'll look into this stuff"
22:04:22 <wli> coffeemug: What did they say?
22:04:43 <coffeemug> I think I pushed some people over the edge so they started looking into these things
22:04:46 <coffeemug> which was my intention :)
22:04:48 <phobes> dons:  But if you go down the road of giving each of those functions their own types, it seems like you end up going crazy with monad transformers
22:04:50 <coffeemug> so I'm happy
22:05:08 <coffeemug> phobes: I know what you mean, I had the same issue
22:05:09 * ddarius would probably use an Erlang-style message passing approach.
22:05:22 <wli> The last time I left a job I just dropped off my laptop and notified them that I'd taken up a job elsewhere.
22:05:23 <sjanssen> phobes: in FP, we usually avoid the "update" entirely, if at all possible
22:05:41 <coffeemug> I don't know, depends where you work
22:05:45 <coffeemug> I was working with nice people
22:05:49 <wli> I saw no reason to explain myself.
22:05:52 <coffeemug> and I get attached to people :)
22:05:59 <dons> phobes: you'd use record update syntax, wouldn't you?
22:06:07 <mudge> coffeemug: you have enough money to live on for awhile?
22:06:11 <dolio> sjanssen: Did you ever send your sudoku solver to the mailing list?
22:06:17 <wli> I was asked to explain myself in the exit interview anyway.
22:06:25 <sjanssen> dolio: no, haven't yet.  Thanks for the reminder
22:06:25 <coffeemug> mudge: I live with my parents for now and I saved up some money
22:06:41 <mudge> oh okay
22:06:47 <coffeemug> I do feel a lot of pressure to get a job from everywhere around me :)
22:06:48 <mudge> curious,  how old are you coffeemug?
22:06:53 <coffeemug> 24
22:07:01 <mudge> wow, you're so young
22:07:09 <mudge> I'm 23
22:07:18 * ddarius will soon be 23.
22:07:18 <mudge> but you know way more than me
22:07:24 <coffeemug> I don't know man
22:07:31 <coffeemug> you know in russian there are two words for "you"
22:07:34 <mudge> wow,  ddarius,  your really young too
22:07:36 <ddarius> mudge: You'd think such things would happen when one is young.
22:07:38 <coffeemug> one you use for people your age
22:07:42 <ddarius> mudge: Don't ask sorear his age...
22:07:48 <coffeemug> and the other you use for people senior to you, or older, etc.
22:07:56 * wli is 31.
22:08:03 <coffeemug> so recently I went to some wedding and one 16 year old girl used the other "you"
22:08:06 <coffeemug> not the friendly one
22:08:07 <mudge> haha,   I don't know   just sometimes seems like really smart people are older
22:08:14 <coffeemug> so that's when I knew I'm getting old :(
22:08:23 <mudge> we're so sophisticated
22:08:37 <mudge> how old is sorear?
22:08:41 <mudge> I like old people
22:09:04 <sorear> mudge: You misread his intonations greatly
22:09:28 <wli> I may be 31, but I've got the Haskell-fu of the average 9-year-old.
22:09:30 <magnus_> coffeemug: I think it is "la resistance", not "le"
22:09:52 <coffeemug> magnus_: yes, I spent a lot of time trying to figure that out
22:10:11 <mudge> sorear: oh, did I get it the exact oppisite way?
22:10:13 <coffeemug> magnus_: couldn't figure it out and finally settled for "le" :)
22:10:18 <phobes> dons: Use record update syntax and not use a state Monad at all?
22:10:19 <sorear> mudge: Yup.
22:10:22 <sorear> <- 16
22:10:24 <scodil> anyone know what the Doc type is? HaskellDB uses it but its not linked into their docs.
22:10:24 <magnus_> coffeemug: good enough :)
22:10:41 <mudge> nice sorear!
22:11:08 <dons> phobes: record updates of the state monad contents
22:11:14 <jcreigh> yeah, sorear keeps us all humble.
22:11:18 <dons> phobes: have a look at how the state components in xmonad are structured
22:11:33 <phobes> dons: ok will do
22:11:51 <phobes> I'll have to get darcs :)\
22:12:09 <mudge> dons: how old are you?
22:12:21 <coffeemug> mudge: age is irrelevant
22:13:00 <mudge> yea, age is irrelevant
22:14:19 <sorear> mudge: It should be easy for you to find that he is a final-year PhD student
22:14:39 <phobes> I hear he's on the 10 year plan though
22:15:07 <sorear> no, he's in a country that would never admit to having ten year plans
22:15:20 <mudge> australia?
22:15:42 <sorear> yes
22:15:55 <sorear> 22:03 -!-    #xmonad dons      H   0  i=dons@pill01.orchestra.cse.unsw.EDU.AU [dons]
22:16:01 <sorear> .AU
22:16:07 <ddarius> For now...
22:16:30 <sorear> soon, he'll be in a country with even less inclination to admit them
22:17:10 <mudge> I picked dons specifically,  asking him his age,  because I like him,  and he's one of my favorite IRC people
22:17:22 <coffeemug> :)
22:17:37 <coffeemug> it would be good to go back to grad school
22:17:42 <phobes> You should have said that before he kill filed you
22:17:51 <mudge> no really?
22:18:08 <coffeemug> unfortunately most grad schools suck
22:18:11 <coffeemug> :)
22:18:22 <mudge> coffeemug: you went to gradschool?
22:18:26 <coffeemug> no
22:18:27 <ddarius> America: Stealing the best and brightest since 1787
22:18:29 <coffeemug> but I want to
22:18:30 <nornagon> sorear: what was your pure-haskell curses replacement called again?
22:18:31 <littledan> they do?
22:18:41 <sorear> vty
22:18:46 <nornagon> ah, right
22:18:55 <coffeemug> and good ones don't like the fact that I spent time coding 3D demos rather than worked on a good GPA :)
22:19:06 <mudge> phobes:  did he really killfile me?
22:19:10 <mudge> don: are you there?
22:19:16 <mudge> dons: are you there?
22:19:19 <nornagon> i'm considering writing a little roguelike with haskell, is vty good for per-character things or is it mostly per-line stuff?
22:19:21 <phobes> oh you were really asking?  No, I'm sure he's just afk :)
22:19:32 <mudge> haha,  okay
22:19:41 <nornagon> because istr that writing a single character to a specific location on the screen was a little convoluted last time I looked
22:19:45 <phobes> I'm with you - dons is a great guy :)
22:19:52 <phobes> g'night all
22:19:54 <ddarius> mudge: If you were so annoying that he felt like killfiling you, he'd probably just kickban you instead.
22:20:08 <sorear> nornagon: it was originally written for a roguelike, but of a very different model from curses
22:20:15 <nornagon> oh :)
22:20:37 <mudge> ddarius: okay, thanks,  good to know
22:20:47 <sorear> nornagon: it's designed for programs that don't bother with imperatively scribbling on bits of the screen, instead just recomputing the whole thing
22:21:16 <scodil> so what do you do when you get a pattern match failure in a library function?
22:21:25 <mudge> phobes: goodnight
22:21:27 <nornagon> sorear: er? not quite sure what you mean
22:21:29 <ddarius> scodil: Cry.
22:21:43 <nornagon> (also, does it support xterm-256color? unicode?)
22:21:51 <scodil> anyone here use haskelldb? specifically the dbspec part?
22:21:56 <nornagon> oh, yes unicode
22:22:11 <nornagon> (so @wiki Library/VTY tells me)
22:22:22 <sorear> nornagon: no xterm-256color yet, there isn't even support for multiple terminal types yet
22:22:29 <nornagon> *nod*
22:22:41 <nornagon> well the other option i have is to write it with opengl
22:22:42 <sorear> nornagon: if you want the fancy features, talk to wli, he's rewriting it currently
22:22:52 <nornagon> which is evil, but much more flexible :)
22:22:57 <sorear> nornagon: or you could just use hscurses
22:23:06 <nornagon> yeah, i thought about that too
22:23:12 <ddarius> You can have your roguelike screen on the side of a cube!
22:23:28 <nornagon> @tell wli new VTY should include xterm-256color support!
22:23:28 <lambdabot> Consider it noted.
22:23:32 <nornagon> ddarius: heh
22:23:47 <nornagon> ddarius: mostly it's the fact that opengl supports 24-bit colour
22:23:57 <nornagon> + transparency if I go insane
22:27:19 <mudge> coffemug: what does that russia reference mean in your letter?  "take russia out of a guy"  "take a guy out of russia"
22:27:53 <coffeemug> mudge: I said I prefer social responsibility to greed
22:27:59 <coffeemug> that's communism basically
22:28:02 <coffeemug> it's just a pun :)
22:28:06 <sorear> > lcm [1..180]
22:28:07 <lambdabot>   add an instance declaration for (Integral [t])
22:28:07 <lambdabot>     In the expression: lcm (...
22:28:16 <sorear> > foldr1 lcm [1..80]
22:28:17 <lambdabot>  32433859254793982911622772305630400
22:29:14 <mudge> coffeemug: okay
22:29:54 <mudge> coffeemug: I'm still not sure what you mean by it,  you prefer communism over greed?
22:30:32 <coffeemug> mudge: it's kind of hard to explain
22:30:35 <coffeemug> it's just a joke
22:30:52 <oerjan> @hoogle (a -> a -> a) -> [a] -> a
22:30:53 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
22:30:53 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
22:30:53 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
22:31:06 <mudge> you mean like if a guy is living in Russia and the culture of russia becomes apart of him,   then you take him out,   that russian culture is still apart of him?
22:31:14 <coffeemug> mudge: yes
22:31:22 <coffeemug> mudge: are you a native english speaker?
22:31:28 <mudge> yea, that make sense
22:31:30 <mudge> yes
22:31:43 <mudge> are you?
22:31:49 <coffeemug> american?
22:31:53 <coffeemug> no, I'm russian :)
22:32:01 <mudge> oh,  cool
22:32:03 <lament> you should know that "a" and "part" in "a part" are spelt apart :)
22:32:08 <mudge> yea, I am american
22:32:12 <mudge> I live in California
22:32:29 <lament> coffeemug: #haskell.ru :)
22:32:42 <lament> er, it's #haskell_ru. Whichever
22:32:45 <coffeemug> that exists?
22:32:55 <lament> it had two speakers earlier today...
22:33:24 <coffeemug> it's pretty much empty
22:33:28 <coffeemug> lament: you're russian too?
22:33:35 <lament> yes
22:33:49 <coffeemug> you still live there?
22:33:53 <lament> no
22:34:06 <mudge> I'm the furthest hacker to the right in California on the Hacker Tracker map: http://hackrtrackr.com/
22:34:26 <coffeemug> I think localized tech resources are stupid
22:34:39 <coffeemug> they only unnecessarily fragment tech community
22:34:44 <coffeemug> everyone should settle on a language and use it
22:34:50 <coffeemug> and currently that seems to be english
22:35:04 <coffeemug> and if it tips to, say, French, I'll gladly learn that
22:35:05 <lament> that's an exceedingly utilitarian way of looking at it.
22:35:17 <nornagon> i think the language should be haskell
22:35:19 <nornagon> :D
22:35:21 <coffeemug> heh
22:35:49 <coffeemug> It's just silly that you limit resources to a small group of people
22:35:57 <sorear> I vote for higher-order logic.
22:35:58 <coffeemug> artificially by choosing a language other than english
22:36:01 <mudge> coffeemug:  I agree
22:36:07 <lament> coffeemug: not limit, augment
22:36:22 <lament> probably all #haskell_ru speakers are in #haskell anyway
22:36:48 <lament> (certainly true at the moment, since i'm the only person there :) )
22:36:51 <coffeemug> lament: it would only be "augment" if people translated resources
22:37:05 <coffeemug> but there is some very interesting original research
22:37:10 <coffeemug> in russia, china, etc/
22:37:23 <coffeemug> that the whole world can't access because it's in russian, chinese
22:37:36 <coffeemug> Ruby didn't become a hit until they translated the docs :)
22:37:43 <lament> yeah, but IRC isn't "the docs"
22:37:56 <coffeemug> yeah, IRC is fine
22:38:07 <lament> of course it's silly to not publish stuff in english
22:38:12 <coffeemug> I guess IRC logs provide some long term value but very little
22:38:20 <coffeemug> I'm mostly talking about web resources
22:38:42 <ddarius> If they were better organized, #haskell IRC logs would provide quite a bit of value.
22:39:05 <lament> ddarius: arranged into a novel? :)
22:39:12 <nornagon> hmph, what do I need to do to profile stuff again? I've got ghc -prof -auto-all, then I ./executable +RTS -p
22:39:20 <mudge> hey coffemug,  is it okay if I post your letter on reddit programming an Hacker News?
22:39:21 <nornagon> then i vi executable.prof, and it's empty
22:39:24 <Japsu> all the problems of modern computation, solved - in thirty million lines of IRC logs!
22:39:27 <pjd> edited, annotated editions of the logs would be really nifty
22:39:40 <coffeemug> mudge: yes, it's fine
22:39:44 <nornagon> each day should be indexed :)
22:40:13 <mudge> coffeemug: but should be the title!
22:40:22 <mudge> but what should be the title
22:40:42 <mudge> sorry my fingers recrurse and get ahead of themselves
22:40:50 <coffeemug> that I don't know :)
22:41:00 <coffeemug> you'll get the karma or whatever they call it
22:41:03 <coffeemug> you come up with the title :)
22:41:09 <mudge> k
22:42:13 <ddarius> You could probably write a half-way interesting book on the history of #haskell.
22:42:29 <nornagon> (include haskell-cafe for extra points)
22:42:43 <lament> /biography of shapr
22:43:06 <lament> "One man's dream" or something
22:43:10 <lament> :D
22:43:31 <ddarius> Something like a lot of little vignettes of #haskell "characters" may be readable as a non-technical thing.
22:43:37 <nornagon> Hmph... my random terrain generation code seems to be digging into swap :-(
22:44:23 <lament> you gotta dig to create mountains...
22:44:33 <nornagon> hur hur
22:44:44 <mudge> coffeemug: so you want to start a start up with your technology?
22:45:28 <phr_> so i wrote "wc" in haskell, i.e. "do {a<-getContents; print $ length $ words a}" and compiled with ghc it's 20x slower than the unix wc command.  any suggestions?
22:45:45 <ddarius> @google wc in Haskell
22:45:46 <coffeemug> well, I persue multiple goals
22:45:47 <lambdabot> http://haskell.org/haskellwiki/Wc
22:45:47 <lambdabot> Title: Wc - HaskellWiki
22:45:50 <oerjan> phr_: bytestrings
22:45:52 <sorear> phr_: talk to ndm
22:45:59 <coffeemug> either get someone to appreciate my work and hire me
22:46:09 <coffeemug> get someone to appreciate my work and get me into a good grad school
22:46:13 <sorear> oerjan: ndm makes that [Char] wc 10% faster than the naive C wc
22:46:18 <coffeemug> or if top two fail, start a startup
22:46:21 <coffeemug> with the tech
22:46:36 <ddarius> phr_: Read that wiki page.
22:46:41 <phr_> yeah the wiki page looks good
22:48:44 <ddarius> Read http://www-users.cs.york.ac.uk/~ndm/downloads/ Faster Haskell for the 5 second overview of what sorear is talking about.
22:48:47 <lambdabot> Title: Neil Mitchell - Downloads
22:49:10 <phr_> heh the wiki page doesn't say anything about harpy ;)
22:49:22 <phr_> but anyway it's counting lines instead of words
22:49:24 <sorear> As it shouldn't.
22:49:25 <ddarius> phr_: It was probably last editted before Harpy was annouced.
22:49:26 <phr_> is there a B.words function?
22:49:39 <mudge> coffeemug:  okay,   I think its a lot of fun to start a startup
22:49:39 <ddarius> phr_: Probably.
22:49:50 <phr_> sorear given how nuts it goes with the C FFI, i'd expect harpy is fair game as well
22:49:54 <sorear> ddarius: Is there any point to dynamic code generation for such a fundamentally static task as word-counting?
22:50:00 <thedatabase> evening all --- I have a quick quickcheck question.  I have a generator doublesList, and can happily write checks beginning 'forAll doublesList $ \ds -> ....', but now suppose I'd like to test with some ints as well; naively I'd like to write something like 'forall [doublesList, intsList] $ \[ds,is] -> .....' but Haskell barfs with Couldn't match expected type `Gen a' against inferred type `[a1]', and now I'm rather choking myself :)
22:50:00 <thedatabase> --- can anyone help?
22:50:21 <coffeemug> startups are fun
22:50:33 <sorear> thedatabase: split the quantifier is the easiest way
22:50:36 <ddarius> sorear: Not really.
22:50:54 <sorear> forAll doublesList $ \ds -> forAll intsList $ \is -> ...
22:51:14 <coffeemug> startups are fun
22:51:35 <mudge> coffeemug:  I posted the letter on Hacker News: http://news.ycombinator.com/newest    seemed like Farewell Letter    was the best name
22:51:37 <lambdabot> Title: Hacker News | New Links
22:51:52 <coffeemug> but if I can get a job working next to very smart people or getting into grad school it'll work as well for me
22:51:58 <thedatabase> thanks sorear!  I managed by defining a new generator but I knew there had to be an easier way.  Much appreciated
22:52:10 <mudge> figured I see how it did on Hacker News,   then try it on reddit programming
22:52:37 <mudge> i like hacker News better,  it is smaller and the news moves faster
22:53:11 <coffeemug> I like programming.reddit better
22:53:11 <thedatabase> thinking I need to do something monadic still scares my away from realizing easy ones like this!
22:53:16 <coffeemug> articles are more technical
22:53:29 <coffeemug> hacker news is mostly get rich schemes for now
22:55:28 <mudge> yea,  hopefully it gets more technical as it goes along,  hopefully it becomes more hacker news
22:55:37 <nornagon> grr, why isn't my profiling info showing up? I compiled with -prof -auto-all and ran with +RTS -p, but the $PROG.prof file is empty
22:56:02 <mudge> I think Hacker News is a good opportunity to start posting good technical articles as they just switched their theme to Hackers
22:56:41 <mudge> good night
22:56:46 <coffeemug> gn
22:58:29 <Korollary> nornagon: there's a runtime flag you need to add iirc
22:59:20 <nornagon> Korollary: Yeah, it's +RTS -p
22:59:21 <nornagon> hrm
22:59:31 <nornagon> i made a dummy test program with no OpenGL stuff or anything
22:59:35 <nornagon> and it works now :/
22:59:52 <nornagon> perhaps before it was exiting with an error and the profiling stuff took that to mean "onoez, didn't work"?
23:00:56 <mudge> coffeemug:  check out my blog sometime: http://www.nickmudge.info/
23:00:59 <lambdabot> Title: Nick Mudge's Weblog
23:01:26 <coffeemug> will do
23:01:45 <coffeemug> oh yeah
23:01:48 <coffeemug> I saw your blog :)
23:01:51 <coffeemug> I read it sometimes
23:02:00 <coffeemug> just didn't realize it's you
23:02:13 <mudge> haha,  no way,  really?
23:02:23 <mudge> you've seen it before?
23:02:29 <coffeemug> yeah
23:02:34 <coffeemug> not sure how I got to it though
23:02:39 <coffeemug> so I couldn't tell you
23:03:24 <mudge> well that's cool, and make me happy
23:03:26 <mudge> good night
23:05:23 <sorear> mudge: oh, your first name is Nick and your last name is Mudge?  heh, I totally misread that domain name the first few times
23:05:57 <ddarius> sorear: You need to get off IRC.
23:06:03 <mudge> lol
23:07:00 <desp> hm
23:07:15 <desp> so "_ <- f" is invalid in do-notation?
23:07:23 <shachaf> I don't think so.
23:07:31 <desp> I thought this would be a good way to write "specifically ignore the result"
23:07:41 <glguy> > do { _ <- [1,2]; return 3 }
23:07:42 <lambdabot>  [3,3]
23:07:53 <desp> hm
23:07:55 <desp> oops.
23:07:57 <dolio> > do { [1,2] ; return 3 }
23:07:58 <lambdabot>  [3,3]
23:11:10 <coffeemug> > do { [1,2]; [3,4]; return 5 }
23:11:12 <lambdabot>  [5,5,5,5]
23:11:23 <coffeemug> > do { [1,2]; [3,4]; return [5, 6] }
23:11:25 <lambdabot>  [[5,6],[5,6],[5,6],[5,6]]
23:12:17 <coffeemug> > do { i<-[1,2]; j<-[3,4]; return (i, j) }
23:12:19 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:12:48 <coffeemug> > do { i<-[1,2]; j<-[3,4]; k<-[5,6]; return (i, j,k) }
23:12:50 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
23:12:57 <coffeemug> hmm, I should really do this locally :)
23:13:01 <glguy> > Control.Applicative.pure (,) <*> [1,2] <*> [3,4]
23:13:02 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:13:02 <elliottt> > do { i<-[1,2]; j<-[3,4]; guard (i*j < 3); return (i,j)}
23:13:04 <lambdabot>  []
23:14:07 <coffeemug> @where Contro.Applicative.pure
23:14:07 <lambdabot> I know nothing about contro.applicative.pure.
23:14:08 <pjd> > (,) <$> [1,2] <*> [3,4]
23:14:09 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:14:13 <coffeemug> @where Control.Applicative.pure
23:14:13 <lambdabot> I know nothing about control.applicative.pure.
23:14:18 <coffeemug> hmm
23:14:22 <coffeemug> ?where Control.Applicative.pure
23:14:22 <lambdabot> I know nothing about control.applicative.pure.
23:14:33 <coffeemug> how do I find something out about it? :)
23:14:35 <elliottt> @hoogle pure
23:14:36 <lambdabot> Control.Arrow.pure :: Arrow a => (b -> c) -> a b c
23:14:42 <glguy> not that one :)
23:14:46 <elliottt> whoops
23:14:48 <elliottt> wrong pure :)
23:14:59 <Botje> > sequence [[1,2],[3,4],[5,6]]
23:14:59 <pjd> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
23:15:00 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
23:15:01 <lambdabot> http://tinyurl.com/yyo64c
23:15:19 <opqdonut> ?src [] ap
23:15:19 <lambdabot> Source not found. My mind is going. I can feel it.
23:15:24 <glguy> > liftM2 (,) [1,2] [3,4]
23:15:25 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:15:30 <shachaf> @ty Control.Applicative.pure
23:15:32 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
23:15:34 <shachaf> @src ap
23:15:35 <lambdabot> ap = liftM2 id
23:15:36 <glguy> so many ways to accomplish such a trivial task :O)
23:16:08 <coffeemug> hehe
23:16:11 <shachaf> @src [] (<*>)
23:16:11 <lambdabot> (<|>) = (++)
23:16:12 <coffeemug> coma is a list constructor?
23:16:19 * desp is happy to have triggered such an euphoric rush of activity
23:16:26 <shachaf> That's not right.
23:16:28 <phr_> has anyone written something like mnesia in haskell?
23:16:41 <glguy> coffeemug: comma is a tuple constructor
23:16:59 <coffeemug> ah
23:17:03 <glguy> shachaf: you mean the Alternative instance?
23:17:13 <glguy> :-/
23:17:18 <dolio> desp: The key is, '_ <- m' is a waste of typing. You can just write 'm'. :)
23:17:50 <opqdonut> :)
23:17:54 <shachaf> @src [] (<*>)
23:17:55 <lambdabot> (<|>) = (++)
23:18:08 <shachaf> I asked for (<*>), not (<|>).
23:18:23 <dolio> Heh.
23:18:26 <coffeemug> > filterM (const [True, False]) [1, 2, 3, 4]
23:18:28 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
23:18:32 <coffeemug> this is beautiful
23:18:35 <shachaf> [] (<*>)
23:18:36 <shachaf> (<*>) = ap
23:18:40 <pjd> coffeemug: it is
23:18:46 <shachaf> From lambdabot's State.
23:19:09 <glguy> > filterM(\_->[False ..])[1..4] -- in the spirit of keystroke reduction ;)
23:19:09 <lambdabot>  Unbalanced parenthesis
23:19:12 <glguy> bah
23:19:12 <elliottt> [(x,y)|x<-[1,2],y<-[3,4]]
23:19:15 <elliottt> > [(x,y)|x<-[1,2],y<-[3,4]]
23:19:17 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
23:19:34 <desp> dolio: I know it's redundant; I said, I thought it's a good way to mark that I'm explicitly ignoring the return value
23:19:48 <glguy> > filterM(\_->[False ..])[1..4]
23:19:50 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
23:20:01 <glguy> so lambdabot checks parentheses in comments?
23:20:29 <coffeemug> btw, I recently discovered --diff-command in darcs
23:20:34 <coffeemug> it rocks :)
23:20:38 <shachaf> > ()
23:20:40 <lambdabot>  ()
23:20:42 <shachaf> > () -- )
23:20:42 <lambdabot>  Unbalanced parenthesis
23:20:49 <glguy> have you discovered the diff command on hpaste? :)
23:20:54 <coffeemug> now I finally found source control nirvana
23:21:01 <coffeemug> no :)
23:21:06 <desp> someone will knock it over any second now
23:21:49 <shachaf> desp: Doesn't not using <- also mark that?
23:22:54 <shachaf> Oh, I see.
23:23:00 <shachaf> [] (<*>)
23:23:01 <shachaf> (<|>) = (++)
23:23:14 <shachaf> (From State/source)
23:23:38 <nornagon> Is there some way to get +RTS -hc to not truncate the names of cost centres it generates?
23:23:47 <nornagon> I get foo/bar/baz/quux...
23:23:58 <nornagon> instead of foo/bar/baz/quux/etc
23:24:03 <coffeemug> I still don't quite understand while filterM works
23:24:04 <elliottt> @source Control.Applicative.(<*>)
23:24:04 <lambdabot> Control.Applicative.(<*>) not available
23:24:13 <coffeemug> how would it look in do notation?
23:24:14 <shachaf> That should be fixed; do I tell dons?
23:24:30 <glguy> yeah
23:24:30 <shachaf> @src filterM
23:24:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:24:32 <desp> shachaf: I do think that a specific syntactic form saying "ignored" carries more meaning than the lack of such form
23:24:36 <desp> s/lack/absence/
23:25:00 <shachaf> desp: Well, (>>) also means "ignored", right?
23:25:01 <opqdonut> coffeemug: basically filterM p list = do { k <- list; True <- p; return k}
23:25:20 <desp> shachaf: sure.
23:25:35 <pjd> True <- p ?
23:25:41 <pjd> you can do that?
23:25:43 <opqdonut> pjd: pattern matching
23:25:44 <opqdonut> yep
23:25:48 <opqdonut> if p is not true it fails
23:25:49 <shachaf> opqdonut: Not True <- p k?
23:25:52 <coffeemug> what's p?
23:25:59 <opqdonut> shachaf: yeah that rather :))
23:25:59 <pjd> heh
23:26:01 <pjd> nifty
23:26:01 <opqdonut> but anyways
23:26:32 <coffeemug> what would p be?
23:26:37 <shachaf> > let fM p xs = do { k <- xs; True <- p k; return k } in fM (const [True,False]) [1,2,3]
23:26:39 <lambdabot>  [1,2,3]
23:26:51 <opqdonut> hmm, not quite, then
23:26:53 <shachaf> Not really...
23:26:57 <shachaf> @source Data.List
23:26:58 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
23:27:13 <shachaf> @ty let fM p xs = do { k <- xs; True <- p k; return k } in fM
23:27:15 <lambdabot> forall t (t1 :: * -> *). (Monad t1) => (t -> t1 Bool) -> t1 t -> t1 t
23:27:33 <opqdonut> isn't it in control.monad?
23:27:43 <opqdonut> ?hoogle filterM
23:27:44 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
23:27:44 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
23:27:44 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
23:28:09 <shachaf> It is.
23:28:16 <shachaf> Sorry.
23:28:30 <elliottt> is it possible to tell parsec, take any character up to "\r\n", but don't consume the "\r\n" ?
23:29:10 <shachaf> filterM _ [] = []; filterM p (x:xs) = do { flg <- p x ys; <- filterM p xs; return (if flg then x:ys else ys) }
23:29:19 <pjd> coffeemug: predicate
23:29:20 <shachaf> It's somewhat more complicated. :-)
23:29:25 <nornagon> Blah. My program is spending most of its time in GC, but the @wiki Space Leaks page is empty.
23:29:42 <Botje> nornagon: get a bigger heap! =)
23:29:44 <nornagon> How do I go about fixing it? Profiling has pointed out the function doing all the allocing.
23:29:49 <glguy> desp: actually, using _ <- changes the meaning
23:29:55 <nornagon> Botje: Not helpful, I think :-P
23:30:01 <nornagon> my function's broken somehow
23:30:02 <glguy> "sort of"
23:30:10 <glguy> _ <- m   desugars into  >>= \_ ->
23:30:15 <glguy> m   desguars into  m >>
23:30:25 <glguy> and the implementation for >> can be different to improve efficiency
23:30:27 <opqdonut> and >> desugars into >>= \_ ->
23:30:32 <opqdonut> ah, yeh okay
23:30:51 <opqdonut> is it different in any of the stock monads?
23:31:00 <shachaf> @src Monad
23:31:00 <lambdabot> class  Monad m  where
23:31:00 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
23:31:00 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
23:31:00 <lambdabot>     return      :: a -> m a
23:31:00 <lambdabot>     fail        :: String -> m a
23:31:06 <shachaf> Why is (>>) in there?
23:31:22 <hpaste>  nornagon pasted "Function using up all my space" at http://hpaste.org/2360
23:31:24 <glguy> shachaf: efficiency
23:31:24 <Botje> so implementations can override it for optimization
23:31:29 <glguy> shachaf: it has a default implementation
23:32:35 <shachaf> glguy: I know.
23:32:40 <desp> glguy: I see.
23:32:44 <shachaf> glguy: Does that really make any noticeable difference?
23:32:52 <glguy> with optimizations enabled -O2, the behavior gets even weirder I think
23:33:05 <coffeemug> @source Control.Monad.filterM
23:33:05 <lambdabot> Control.Monad.filterM not available
23:33:11 <coffeemug> @source filterM
23:33:11 <lambdabot> filterM not available
23:33:14 <hpaste>  glguy pasted ">> and >>=" at http://hpaste.org/2361
23:33:15 <desp> glguy: I do hope the optimizer would catch that, though
23:33:18 <shachaf> coffeemug: Use @src for things like this.
23:33:25 <shachaf> coffeemug: (Thoug it doesn't have filterM.)
23:33:35 <shachaf> coffeemug: @src is for functions, @source is for files.
23:34:00 <coffeemug> thanks
23:34:03 <coffeemug> ahhh, I see how it works
23:34:08 <glguy> shachaf: I'm sure that it depends on the monad
23:34:27 <shachaf> Hmm.
23:34:32 <shachaf> @src [] (>>)
23:34:32 <lambdabot> m >> k      = foldr ((++) . (\ _ -> k)) [] m
23:34:41 <coffeemug> it keeps applying the monad to the smaller and smaller list
23:34:43 <glguy> in my paste, test1 only evaluates >>=, and test2 only evaluates >>
23:34:47 <coffeemug> Eureka!!!!
23:34:48 <coffeemug> :)
23:34:53 <coffeemug> boo
23:34:57 <coffeemug> there's no magick in it
23:35:00 <coffeemug> just computation :(
23:35:15 <coffeemug> thanks for nothing
23:35:18 <coffeemug> the magick is gone
23:35:19 <coffeemug> :)
23:35:21 <coffeemug> magic
23:35:50 <pjd> coffeemug: right, it's just filter with the result made monadic
23:37:08 <coffeemug> pjd: I just didn't realize it applies the list monad to smaller and smaller list
23:37:19 <coffeemug> or any monad to smaller and smaller list
23:38:28 <Japsu> > -- no comment
23:38:35 <lambdabot>   parse error on input `}'
23:38:39 * Japsu whistles
23:38:43 <coffeemug> > do { i <- [False ..]; j <- [1, 2, 3, 4]; return (i, j)}
23:38:44 <lambdabot>  [(False,1),(False,2),(False,3),(False,4),(True,1),(True,2),(True,3),(True,4)]
23:41:08 <coffeemug> @src filterM
23:41:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:41:21 <coffeemug> @source Control.Monad
23:41:21 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
23:43:47 <coffeemug> all right
23:43:53 <coffeemug> this was fun :)
23:43:55 <coffeemug> gn everyone
23:50:05 <nornagon> Hr, most of my allocation seems to be in modify (// changes)
23:50:23 <nornagon> maybe it's creating a new array instead of making the modifications in place :/
23:50:40 <scook0> nornagon: Array or DiffArray?
23:50:44 <nornagon> Array
23:51:02 <scook0> well, yes, that's what Array does when you update, I'm afraid
23:51:05 <nornagon> aha :)
23:51:18 <nornagon> I guess I can use DiffArray without much disruption?
23:51:27 <scook0> nornagon: yeah, the interface is the same
23:51:33 <nornagon> excellent
23:51:33 <scook0> just the performance characteristics are different
23:51:35 <nornagon> I'll try that
23:51:39 <nornagon> thanks very much!
23:52:33 <nornagon> hm
23:52:45 <nornagon> I switched import Data.Array for Data.Array.Diff and recompiled
23:52:50 <nornagon> but I'm getting the same stuff :/
23:53:17 <nornagon> oh, er, I guess I need to change my type annotations too :P
23:53:33 <opqdonut> :)
23:54:10 <nornagon> ... hm, now it is much slower to run...
23:54:10 <wli> Sorry about that. Some hangup with my DSL circuit needing resetting.
23:54:11 <lambdabot> wli: You have 1 new message. '/msg lambdabot @messages' to read it.
23:54:18 <nornagon> but much less GC
23:54:20 <nornagon> >.>
23:55:33 <scook0> nornagon: DiffArray lookups are slower
23:55:36 <opqdonut> the good ole' memory-performance tradeoff
23:55:40 <scook0> presumably due to the extra indirection
23:55:42 <nornagon> scook0: ah
23:55:48 <nornagon> scook0: I have a lot of both :(
23:55:54 <opqdonut> nornagon: what do you want to do with the datastructure?
23:56:05 <opqdonut> you might want to consider sequence for efficient modification and lookup
23:56:06 <nornagon> opqdonut: It's for generating random terrain
23:56:07 <opqdonut> or Map
23:56:09 <wli> nornagon: Specific tty/pty capabilities are not of interest. Any specific capabilities should arise naturally from proper interpretation of termcap/terminfo.
23:56:20 <nornagon> wli: Well, awesome, then :)
23:56:23 <scook0> you could also try batching your updates better
23:56:45 <scook0> since I presume there's only one copy made for each (//)
23:57:31 * wli vaguely wonders if p^2|(10^(10^n)-1)/9 for any p > 3.
23:58:34 <nornagon> yes, it does turn out that the lookups are taking up most of the time/alloc :/
23:58:50 <scook0> my current project gets better performance with Array than DiffArray
23:58:53 <nornagon> I don't know how much more I can batch my updates
23:59:06 <scook0> because it does so many lookups, and all the updates are heavily batched
23:59:49 <scook0> there's also mutable arrays, if you're willing to go down that road
