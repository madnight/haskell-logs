00:03:51 <sorear> Haskell has no support for general unary operators :(
00:03:51 <wli> Nope, unary - is special-cased.
00:03:51 <wli> I don't see any special reason you couldn't throw in more if you wanted in terms of language implementation.
00:03:51 <sorear> Several of the ML-family languages have user-defined mixfix and prefix operators.
00:03:51 <lucca> well, prefix-unary is kinda covered by general function application...
00:03:51 <lament> yeah, all "normal" haskell functions are unary
00:03:51 <sorear> This is not a coincidence.  Mandatory declaration-before-use makes things much easier.
00:03:51 <wli> sorear: mixfix?
00:03:51 <sorear> wli: like (foo,bar) for tuples
00:03:58 <wli> Yeah, that'd be handy.
00:04:09 <wli> List-like constructs, too.
00:04:32 <augustss> There was a fairly sophisticated proposal for operator (prefix, infix, postfix, mixfix) when Haskell was designed, but people wanted to keep it simple.
00:04:53 <wli> We've long-since blown past that. ;)
00:05:09 <augustss> I'm afraid so
00:05:29 <celtics_fan> can I have some help installing xmonad
00:05:40 <shachaf> celtics_fan: #xmonad?
00:05:52 <shachaf> celtics_fan: Helpful people over there. :-)
00:06:02 <wli> I shouldn't go on about feature requests when I don't know how to use the features already there, though.
00:07:40 <celtics_fan> yes
00:07:53 <celtics_fan> I grabbed it and it says 4 dependencies
00:08:08 <celtics_fan> archlinux (my distro) Instaled ghc just fine
00:08:33 <shachaf> celtics_fan: Try asking in #xmonad. You'll need to get the dependencies yourself, probably.
00:08:40 <celtics_fan> wll I started
00:08:50 <celtics_fan> and it complains that the first one
00:09:06 <celtics_fan> (supposedly included with ghc) is not there)
00:09:43 <celtics_fan> using the  runhaskell Setup.lhs configure --prefix=/home/gavin
00:09:44 <celtics_fan> Configuring X11-extras-0.2...
00:09:44 <celtics_fan> configure: /usr/bin/ghc-pkg
00:09:44 <celtics_fan> configure: Dependency base-any: using base-2.0
00:09:44 <celtics_fan> Setup.lhs: cannot satisfy dependency X11>=1.2.1
00:09:49 <shachaf> @paste your errors? And then ask in #xmonad.
00:09:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:10:02 <sorear> celtics_fan: Some foolish distributors unbundle the standard libraries from GHC. look for a package named libghc6-x11-dev or similar.
00:13:53 <ddarius> What is the moral equivalent of pokeCString?
00:14:16 <sjanssen> sorear: saying "foolish" isn't quite fiar
00:14:20 <sjanssen> s/fiar/fair
00:14:23 <sorear> ddarius: eek, probably a buffer overflow bug :)
00:14:32 <ddarius> Or rather, String -> Ptr CChar -> IO ()
00:14:59 <lament> rape
00:15:07 <sjanssen> sorear: IMO, it doesn't make much sense to package X11 bindings with GHC
00:15:23 <shachaf> sjanssen: I'd agree.
00:15:35 <shachaf> Though mtl might make sense to bundle.
00:15:55 <sorear> ddarius: hmm, pokeArray0
00:15:58 <sorear> ?
00:18:26 <ddarius> Bah.
00:18:47 * ddarius will not prematurely optimize, map castCharToCChar and pokeArray0 it is.
00:22:40 <Binkley> premature evil is the root of all optimization
00:23:10 <lament> that's deep
00:24:02 <shachaf> Optimizational prematurity is the evil root.
00:24:50 <mornfall> :-)
00:25:10 <mornfall> premature root is the evil of all optimization
00:25:23 <lament> prematuring is the root of all evil optimization
00:26:53 <Binkley> I think we've mined that vein as deeply as possible
00:27:03 <shachaf> No, of course not.
00:27:05 <ClaudiusMaximus> nah, there's plenty more permutations left
00:27:22 <shachaf> Rooting evilly is the optimizational prematurity.
00:27:42 <shachaf> Evil optimization is prematurely rooted.
00:27:56 <ClaudiusMaximus> > product [1..(length . words $ "premature optimization is the root of all evil")]
00:27:58 <lambdabot>  40320
00:28:05 <ddarius> :t foldM
00:28:07 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
00:28:11 <shachaf> Premature optimization is the root of all evil... No? :-(
00:28:28 <ddarius> This will be a mildly hair fold.
00:29:17 <shachaf> Mild hair folds this will.
00:35:19 <ddarius> Except for one ridiculously insane function, this is pretty small.
00:41:00 <Japsu> I'm trying to compile Data.Derive from DARCS on Ubuntu Feisty. I have libghc6-filepath-dev installed but I'm getting "Setup.hs: cannot satisfy dependency filepath-any" nonetheless. Any idea on how to fix this?
00:41:31 <shachaf> @where filepath
00:41:31 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
00:41:50 <shachaf> Maybe you need to use that?
00:41:56 <sorear> Japsu: FilePath was fairly recently renamed filepath.  You can probably make it work by editing derive's build-depends.
00:42:00 <shachaf> Wait, wasn't FilePath new in 6.6.1?
00:42:09 <sorear> shachaf: "I have libghc6-filepath-dev installed"
00:42:18 <Japsu> Build-Depends:  base, template-haskell, filepath, mtl
00:42:29 <Japsu> It's all lowercase there.
00:42:40 <sorear> Japsu: change that to FilePath, which is what it used to be called in the 6.6.0 times
00:42:49 <Japsu> Hmm
00:42:51 <Japsu> let's see
00:43:01 <sorear> Japsu: the debian package is lowercase because debian package names are made of lowercase characters...
00:43:19 <Japsu> yeah
00:43:24 <Japsu> sorear: that works, thanks
00:43:55 <Japsu> got it configured
00:43:57 * shachaf was only causing trouble, sorry.
00:44:53 <Japsu> Hehe. Derive has 10x the number of files Binary has, and yet Binary took 2x the time to compile.
00:45:38 <Japsu> So. Now I have Data.Binary and Data.Derive... let's see if I can make something fun[nk]y with these
00:50:38 <OceanSpray> symLookup :: LispVal -> LispEnv -> LispErrT LispVal
00:50:46 <OceanSpray> symLookup _ NullEnv = throwError NoVal
00:50:50 <OceanSpray> how come this doesn't work?
00:51:11 <shachaf> @ty throwError
00:51:13 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
00:51:25 <shachaf> OceanSpray: What's the error?
00:51:39 <OceanSpray> I get Couldn't match expected type `LispVal -> LispErr'
00:51:39 <OceanSpray>            against inferred type `LispErr'
00:52:20 <shachaf> OceanSpray: What is LispErrT?
00:52:37 <OceanSpray> type LispErrT = Either LispErr
00:53:09 <OceanSpray> data LispErr = Default | ...etc.
00:54:39 <shachaf> OceanSpray: Oh, NoVal gets an argument?
00:54:58 <shachaf> OceanSpray: NoVal :: LispVal -> LispErr?
00:55:34 <OceanSpray> what
00:56:04 <OceanSpray> wait, how'd you know I have a NoVal data constructor?
00:56:24 <shachaf> 03:50 < OceanSpray> symLookup _ NullEnv = throwError NoVal
00:56:35 <OceanSpray> oh
00:56:51 <shachaf> OceanSpray: Where you need to give it a LispVal?
00:57:17 <shachaf> data LispErr = Default | NoVal LispVal | ...?
00:57:24 <OceanSpray> NoVal takes one LispVal as an argument, yes
00:58:02 <OceanSpray> OH
00:58:02 <kjdf> is it possible to express zipwith using map?
00:58:07 <OceanSpray> right
00:58:07 <shachaf> OceanSpray: So in throwError x, x should be :: LispErr.
00:58:08 <OceanSpray> thanks
00:58:15 <kjdf> or define zipWith for Data.Traversable
00:58:22 <shachaf> kjdf: What do you mean?
00:58:28 <shachaf> kjdf: With map how?
00:58:43 <wli> kjdf: zipWith f xs ys = map (uncurry f) $ zip xs ys
00:59:05 <shachaf> OceanSpray: It would've been easier if you'd expanded the ... for LispErr. :-)
00:59:09 <ddarius> @index (=<<)
00:59:09 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:59:19 <OceanSpray> lol
00:59:25 <shachaf> wli: Writing zipWith using zip is cheating. :-)
00:59:35 <kjdf> I am just wonderig if it's possible to generalize my class from lists to all Data.Traversable types
00:59:51 <shachaf> @src Traversable
00:59:52 <lambdabot> class (Functor t, Foldable t) => Traversable t where
00:59:52 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
00:59:52 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
00:59:52 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
00:59:52 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
01:00:59 <dolio> http://okmij.org/ftp/Algorithms.html#zip-folds
01:01:00 <shachaf> @ty liftA2
01:01:06 <lambdabot> Title: Algorithms and Data Structures
01:01:08 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
01:01:12 <wli> > let zipWith' _ [] _ = [] ; zipWith' _ _ [] = [] ; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys in zipWith' (,) [1..10] ['a'..'j']
01:01:14 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(10...
01:01:51 <wli> shachaf: Happy now?
01:01:51 <dolio> You might be able to turn that into something with Traversable.
01:01:57 <kjdf> thanks dolio, will read
01:02:19 <shachaf> wli: That's still only on lists.
01:02:38 <wli> Yes.
01:02:44 <shachaf> wli: And not in terms of map at all; it uses explicit recursion.
01:03:58 <dolio> Actually, foldable, for foldr.
01:06:08 <mae> is there a slicker way to write this?
01:06:10 <mae> response_for person | person `elem` ["Simon", "John", "Phil"] =
01:06:10 <mae>   "I think Haskell is a great programming language"
01:06:25 <dolio> Oh, but, perhaps not, again, because that'll flatten whatever data structure you're passing in into a list.
01:06:42 <dolio> Maybe it's doable with Traversable, though. Not sure.
01:11:07 <ddarius> :t peek
01:11:16 <lambdabot> Not in scope: `peek'
01:11:54 <DRMacIver> Morning
01:17:57 <ddarius> :t unzip3
01:17:59 <lambdabot> forall a b c. [(a, b, c)] -> ([a], [b], [c])
01:18:33 <ddarius> @index unzip3
01:18:33 <lambdabot> Data.List, Prelude
01:19:08 <shachaf> @ty unzipWith
01:19:10 <lambdabot> Not in scope: `unzipWith'
01:20:23 <augustss> unzipWith?
01:20:36 <shachaf> It wouldn't make much senes. :-)
01:20:48 <shachaf> s/es/se/
01:20:51 <augustss> exactly
01:20:59 <shachaf> I was just wondering.
01:22:20 <dcoutts> @seen bwwx
01:22:20 <lambdabot> I saw bwwx leaving #haskell 1h 9m 20s ago, and .
01:22:33 <dolio> Huh, so, after playing a bit, I don't think a generalized zipWith is going to work with Traversable.
01:22:39 <dcoutts> MarcWeber: pong
01:22:39 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:22:51 <Khoth> unzipWith :: (a->(b,c)) -> [a] -> ([b],[c]) ?
01:23:20 <dolio> You'd need a class that takes into account the fact that you have to match structure.
01:23:29 <dolio> And prune appropriately.
01:24:17 <elliottt> map . uncurry?
01:25:24 <dolio> You could probably do it with one of Oleg's generalized zippers.
01:25:50 <dolio> Well, maybe.
01:27:04 <dolio> At that point, though, it's probably easier to write a typeclass for zipWithN.
01:28:11 <goltrpoat> i can't help but feel two things as a result of that conversation:  a) oleg's "functions with the variable number of (variously typed) arguments" deal probably addresses it, b) why would it be ever needed??
01:30:17 <goltrpoat> i mean, if N isn't known at runtime, then you fold zip over a list of lists, surely
01:30:25 <goltrpoat> er.  compile time, rather.
01:30:32 <dolio> goltrpoat: Are you talking about the one on the mailing list where someone wants a (essentially) dependently-typed zipWith?
01:30:49 <goltrpoat> yeah, i thought that's what the current conversation was about
01:31:13 <dolio> Oh. I thought it was about zipping data structures other than lists.
01:31:21 <dolio> Like, trees.
01:31:27 <goltrpoat> ahh
01:32:05 <dolio> I don't know why the person wanted the zipWithN, exactly.
01:32:16 <dolio> Although, lisp/scheme has it.
01:32:24 <goltrpoat> wait.  to zip two trees non-trivially (i.e. we don't just exploit postorder, say), don't you need them to be isomorphic
01:32:27 <dolio> Their map is variadic.
01:33:09 <dolio> Well, if they're not the same shape, you just prune to the shorter one at any given branch.
01:33:15 <dolio> Just like zipWith prunes to the shorter list.
01:33:52 <goltrpoat> ah right.
01:35:01 <goltrpoat> i just asked myself how i'd make a leafy tree an instance of Applicative a few hours ago, and ended up with a tree of intermediate results.  (Node f g) <*> t = Node (f <*> t) (g <*> t).  trying to figure out what that's useful for.
01:36:15 <goltrpoat> since pure = Leaf, and (Leaf f) <*> t = fmap f t, all the normal identities hold
01:36:26 <goltrpoat> so.. surely, it makes sense in some universe.
01:38:13 <matt__r> I have a challenge for you all
01:38:24 <matt__r> I need the coolest time waster you can think of
01:38:27 <desegnis> @type (<*>)
01:38:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:38:43 <matt__r> by time waster I mean an expression that just takes a long time to calculate
01:38:58 <ivant> matt__r, the last ICFP contest is certainly the one hell of a cool time waster
01:39:06 <matt__r> the only contraint on the final result is that it is short and predictable.
01:39:12 <matt__r> ivant: haha
01:39:27 <Khoth> last (reverse [1..])
01:39:43 <matt__r> I wrote a new testcontroller for hunit and I want a test suite to show it off
01:40:10 <matt__r> so I need about 10 test that take about a second each so you can see the cool bar fill up with green from the left
01:40:33 <matt__r> Khoth: I tried that but i am still waiting for the answer :)
01:41:07 <ClaudiusMaximus> > last (reverse [1..maxBound]::[Int])
01:41:10 <goltrpoat> matt:  huffman encoder + 5 gig file?
01:41:12 <lambdabot> Terminated
01:41:22 <ivant> matt__r, @go ackermann function
01:41:33 <goltrpoat> take about a second to run and about 10 minutes to code
01:41:41 <wli> I appear to have implemented a root-finding method consisting of tracking the boundaries of an interval, the function's values and its derivative's values at the endpoints, and then finds a rational function of degree type (3, 2) interpolating the function and its derivatives at the boundary points and midpoint, solves the cubic in the numerator, and then takes the best available bounds from the choice of the midpoint, the in-bounds roots of the cubic, and the p
01:41:56 <sorear> wli: cut off at "and the p"
01:41:58 <goltrpoat> wli:  got cut off after "and the p"
01:42:07 <wli> "and the prior bounds"
01:42:36 <sorear> Something tells me the secant method would be simpler :)
01:42:41 <goltrpoat> isn't that a restricted version of pade approximants?
01:42:44 <goltrpoat> or am i not following
01:42:49 <ivant> wli, roots of what kind of functions can it find?
01:43:13 <goltrpoat> sorear:  and potentially divergent
01:43:18 <ivant> wli, can it find the roots of n-variable functions?
01:43:19 <wli> goltrpoat: Well, if you generalize Pade approximants to have multiple centers (as I'm exploring elsewhere).
01:43:31 <wli> ivant: No. It's line search only.
01:44:10 <sorear> goltrpoat: Only if you give it badly behaved functions
01:44:17 <ivant> wli, oh, bummer. I need some good algorithm, that can be guaranteed to find a root if there is one
01:44:34 <goltrpoat> wli:  so you're fitting a rational function of degree type (3,2) based on the endpoints' derivatives and values, then bisect, bound and repeat?
01:44:42 <sorear> The numerical accuracy rules are sufficient to guarantee termination in most cases
01:45:20 <wli> goltrpoat: No, based on the endpoints' and the midpoints' derivatives and values. I'd only consume 4 degrees of freedom with the endpoints, not 6.
01:45:25 <matt__r> ClaudiusMaximus: thanks :)
01:45:31 <sorear> wli: What function are you rooting?
01:45:35 <matt__r> ivant: thanks :)
01:46:00 <wli> sorear: Well, I've been testing against the Lambert W function since there's an analytic approximation there to check against.
01:47:21 <wli> goltrpoat: Basically I get information from both the endpoints and the midpoint in the interior so I get a fair amount of behavior captured. Plus the rational interpolant has the nice pole-capturing property.
01:47:34 <ddarius> :t fromMaybe
01:47:37 <lambdabot> forall a. a -> Maybe a -> a
01:47:44 <ddarius> maybe
01:47:59 <ddarius> :t maybe
01:48:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:48:07 <dolio> :t flip maybe id
01:48:09 <lambdabot> forall a. a -> Maybe a -> a
01:48:21 <goltrpoat> wli:  yeah, i remember NR talking about pade approximants being "uncanny" in capturing the behavior of a function
01:48:28 <goltrpoat> or some such word.
01:48:38 <ivant> matt__r, another good one is implementing some sieve of eratosthenes algorithm, see http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
01:49:02 <elliottt> ?hoogle a -> [a]
01:49:02 <lambdabot> Prelude.repeat :: a -> [a]
01:49:03 <lambdabot> List.intersperse :: a -> [a] -> [a]
01:49:03 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
01:49:07 <wli> goltrpoat: Efficiency in practice doesn't appear to be all that impressive, but that's partly due to the Maple-generated expressions for the numerator cubic's coefficients not being the best wrt. numerical stability. I'd be better off solving the linear system directly or some such.
01:49:52 <matt__r> ivant: perfect, and I have a good reason to use the dodgy version
01:50:03 <wli> goltrpoat: This is something like a cross between a Pade approximant and an Hermite interpolant. A Pade approximant only deals with a series expansion around one center; this deals with series expansions around 3 centers.
01:50:40 <goltrpoat> wli:  usually, if i have a polynomial i'm solving for whose coefficients "aren't the best wrt numerical stability," i look at orthogonal families of polynomials
01:50:48 <desegnis> Is there a particular benefit in having all of Monoid, MonadPlus and Alternative? Seems to me that just Monoid would do
01:51:48 <wli> goltrpoat: The way I computed them was plugging the linear system into Maple and having it spit out symbolic expressions for the cubic's coefficients. This is not the best way to compute them.
01:52:00 <goltrpoat> right
01:54:05 <goltrpoat> what you said reminds me of things like.. fitting a chebyshev polynomial and then doing something silly like converting to polynomial coefficients.  unstable as hell.  almost as unstable as what you'd get if you took the original problem and fitted the polynomial to it directly.
01:55:02 <goltrpoat> so like i said, unstable coefficients automatically makes me think "write it as something other than c_n x^n + ... + c_1 x + c_0"
01:55:32 <dolio> MonadPlus and Alternative definitely don't both need to exist, but Applicative is pretty new.
01:55:42 <dolio> Not sure about killing them both and just using Monoid.
01:56:13 <wli> goltrpoat: The coefficients aren't unstable. The expressions Maple spat out are numerically unstable/etc. For instance, expanding out z*(a+b)^2 as z*a^2+2*z*a*b+z*b^2
01:56:34 <goltrpoat> right
01:56:50 <goltrpoat> as in, wouldn't you rather keep it as z*(a+b)^2
01:57:11 <wli> goltrpoat: Anyway, the curve-fitting tactic is essentially how everything else (Newton, Muller, Laguerre, et al) works.
01:57:29 <wli> goltrpoat: Yes, there was just no convenient option for it.
01:57:38 <goltrpoat> yeah, i know.
01:57:50 <goltrpoat> well.. almost everything else
01:59:13 <wli> goltrpoat: It's decent for a proof of concept, though, which basically centers around showing that the multicentered Pade / rational Hermite affairs are vaguely useful.
02:00:10 <wli> goltrpoat: One "nifty trick" is that the coefficients of the denominator polynomial need never be computed.
02:01:12 <goltrpoat> you mean between changes of interval?
02:01:24 <goltrpoat> or overall
02:01:48 <desegnis> dolio, ok
02:01:50 <ivant> matt__r, oh, and take a look at the language shootout problems (and yes, there are solutions in Haskell)
02:02:21 <dolio> desegnis: You could probably just use Monoid, but that's a lot less obviously monad/applicative related.
02:03:09 <goltrpoat> i mean, surely it's not constant throughout the whole process :)
02:04:34 <wli> goltrpoat: Overall. You basically only care about solving the numerator cubic, and you can eliminate the denominator coefficients from the equations. When the smoke clears, you just don't have to deal with the denominator at all.
02:05:56 <wli> goltrpoat: The only effect of the quadratic denominator is to alter the equations for the coefficients of the cubic to solve.
02:07:17 <desegnis> dolio, it's difficult for me to see the value of isomorphic classes, only with different constraints. that's like introducing (class Eq a => FloatingPlus a where (.+) :: a -> a -> a) or similar
02:08:08 <desegnis> bad example, of course...
02:08:46 <wli> goltrpoat: The basic trick is that Pade approximants can be phrased as (d^k/dx^k)(p(x)-q(x)*f(x))|_{x=x_0} = 0 for 0 <= k <= n right?
02:08:51 <goltrpoat> wli:  i don't follow.  if f(x) ~= q(x)/p(x) on some interval, and p(x) is a constant polynomial, then why not just fit f(x) p(x).
02:09:14 <goltrpoat> right
02:09:21 <wli> goltrpoat: The denominator is not constant. The coefficients are merely not used.
02:09:35 <goltrpoat> ohh
02:09:59 <wli> goltrpoat: You're not evaluating the rational function, you're using cubic equations to solve for the roots of the rational function, i.e. its numerator.
02:10:17 <goltrpoat> sorry, brainfart.
02:10:40 <|Steve|> Is there a clever way in haskell using list comprehensions to specify multiple elements of the list at once. Something like [x,negate x|x<-[1..5]] would give me [1,-1,2,-2,3,-3,4,-4,5,-5]?
02:11:08 <wli> goltrpoat: Now extend the system of equations to (d^k/dx^k)(p(x)-q(x)*f(x))|_{x=x_j} = 0 for 0 <= k <= n, and 1 <= j <= m
02:11:10 <goltrpoat> > concat [[x, negate x] | x <- [1..5]]
02:11:12 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5]
02:11:41 <|Steve|> That would seem to be inefficient.
02:11:46 <wli> goltrpoat: That's how I get my multicentered Pade approximants.
02:12:03 <wli> goltrpoat: and/or rational Hermite interpolants.
02:12:16 <dolio> > [1..5] >>= \x -> [x, negate x]
02:12:18 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5]
02:12:28 <Heffalump> |Steve|: the syntax you describe first has been suggested, but never implemented
02:12:53 <Heffalump> it'd be likely to have the same efficiency as the version with concat anyway; desugaring of list comprehensions uses concat generally.
02:13:14 <Heffalump> (and fusion ought to remove any inefficiency anyway)
02:13:28 <goltrpoat> wli:  sec, digesting.
02:13:39 <|Steve|> Heffalump: Okay. Since order doesn't really matter, I'll use two lists and concat them.
02:15:16 <goltrpoat> wli:  where are the x_j's coming from?
02:16:17 <wli> goltrpoat: They're pre-specified interpolation knots.
02:16:29 <goltrpoat> pre-specified?
02:16:41 <psykotic> goltrpoat, yo
02:16:44 <goltrpoat> psyk
02:16:52 <Heffalump> two separate lists might be rather less efficient, since a lot of work will be done twice
02:17:15 <wli> goltrpoat: The problem specification is essentially the same as the Hermite interpolation problem for polynomials, except that a rational function is to be determined.
02:18:42 <wli> goltrpoat: Hermite interpolation is just like Lagrange interpolation except that at each knot some number of derivatives whose number varies according to the knot are also to be interpolated. i.e. the interpolant's derivatives must also match the preassigned derivative values.
02:18:53 <goltrpoat> er.  i thought you were talking about *fitting* a rational hermite-like function to the function on the interval in question, finding the zeroes, and rinse lather repeat
02:19:10 <goltrpoat> how do the pre-specified knots enter the picture
02:19:11 <wli> goltrpoat: I am/was.
02:19:24 <goltrpoat> i mean, fitting and pre-specified knots, those two things seem to be at odds.
02:19:27 <wli> goltrpoat: The endpoints and midpoint of the interval are the knots.
02:19:55 <goltrpoat> so.. when you say pre-specified, you don't mean user specified :)
02:20:03 <Saizan> how would you debug a "Maybe.fromJust: Nothing"
02:20:05 <Saizan> ?
02:20:12 <wli> goltrpoat: In this case, the user is the solver.
02:20:17 <goltrpoat> and..  m is just the polynomial degree
02:20:34 <goltrpoat> -1
02:20:54 <goltrpoat> scratch the -1.
02:20:55 <wli> goltrpoat: Hmm? There's a degree type associated with rationals, not just a degree.
02:21:04 <OceanSpray> :t liftM
02:21:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:21:14 <ddarius> Saizan: Compile with profiling -auto-all; run with +RTS -xc
02:21:18 <goltrpoat> but i thought you said the denominator was fixed
02:21:42 <goltrpoat> oh crap.  no you didn't say that.
02:21:53 <goltrpoat> i do believe i follow now.
02:22:09 <Saizan> ddarius: will that work even if the exception is catch-ed?
02:22:28 <OceanSpray> :t lift
02:22:30 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
02:22:48 <wli> goltrpoat: The denominator is not fixed. Its coefficients merely don't enter the calculations directly. They influence the numerator's coefficients, but only the numerator's coefficients are directly used by the expressions for the solutions for the zeroes of the rational Hermite/multicenter Pade interpolant.
02:23:07 <ddarius> Saizan: I don't think so.
02:23:09 <ddarius> But it may.
02:23:42 <wli> goltrpoat: The source is useless; it mostly looks like Maple took a dump in a Haskell file.
02:24:07 <wli> Essentially because that's precisely what happened.
02:24:59 <goltrpoat> i think i'm still confused about how that can be the case, actually.  specifically, i'm not sure how the denominator's coefficients are going to influence the numerator's coefficients unless they share a root
02:25:02 <wli> goltrpoat: When solving for the zeroes of a rational function, all you do is find the roots of the numerator.
02:25:31 <psykotic> and then reject the ones cancelled by the denominator's roots, surely?
02:25:45 <goltrpoat> ohh.
02:25:47 <goltrpoat> thanks.
02:25:53 <wli> psykotic: I presume there is no cancellation.
02:25:55 <psykotic> which means you also have to find the multiplicity of everything, i think
02:26:11 <psykotic> wli, k
02:28:00 <wli> Basically the linear system for the coefficients involves the denominator's coefficients, too. When you're done solving it, you throw away the denominator's coefficients. Now, since the equations are nonsingular, none of the coefficients need be expressed in terms of any of the others in a symbolic solution (e.g. Cramer's rule).
02:28:44 <Smokey`> goltrpoat, psykotic... just out of interest, what're you guys using Haskell for?
02:28:48 <wli> That is the sense in which the denominator's coefficients are ignorable.
02:29:09 <psykotic> Smokey`, not games, if that's what you mean. not yet anyway.
02:29:38 <psykotic> my game-related hacking in haskell is limited to a bejeweled clone i wrote on a plane a few years ago.
02:29:57 <axm_> hi, i am new and have some problems with building hws. it compiles but produces linker errors for packages that are recognized as valid installed in the configure phase. somewhere i have read, hws was written for for ghc5 (is that the reason why the dependencies are messed up?) - would that be the part to investigate or should i rather look, if my system is screwed up (includes are in the right place but libs are not or likewise)?
02:29:58 <ClaudiusMaximus> > [1..3] `zipWith (+)` [4..6]  -- just wondering if this syntax is allowed...
02:29:58 <lambdabot>  Parse error
02:30:11 <goltrpoat> smokey:  games, in a limited capacity (DSL compilers).  prototyping, tools.
02:30:14 <Smokey`> psykotic: hehe, no I wasn't interested in that. :)   I'm more of a graphics person, than a games person...
02:30:44 <psykotic> Smokey`, i've been working on a ray tracer. but nothing real time. the opengl bindings for haskell all seem to be woefully behind in their support for extensions.
02:30:49 <Smokey`> 2D/3D graphics, and related tools/middlewaer development (not necessarily real time)
02:30:50 <goltrpoat> wli:  i think i'm forgetting something major about pade approximants.
02:31:00 <Smokey`> psykotic: most certainly agreed re: gl bindings
02:31:28 <psykotic> and actually, the bindings all seem a bit too fancy
02:31:43 <psykotic> i just want something at the level of the c gl api. it's a low level api in spirit.
02:31:43 <goltrpoat> fancy?
02:31:49 <goltrpoat> oh
02:31:52 <psykotic> they try to introduce all kinds of layers and abstractions
02:31:54 <Cale> axm_: I'm not really sure, but http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/WSP-0.1.6.tgz built and installed fine for me under GHC 6.6 on Ubuntu.
02:31:59 <lambdabot> http://tinyurl.com/3a7gp9
02:32:04 <psykotic> i just want something dumb. because that way i don't have to work hard to support new extensions.
02:32:04 <goltrpoat> i'm fine with the level of abstraction, actually.  i just wish it wasn't 1.4
02:32:14 <Cale> axm_: (after modifying the .cabal a bit)
02:32:15 <axm_> same system and compiler here.
02:32:27 <Smokey`> I've got an old haskell ray tracer lying around somewhere... (again, far from real time...  I hit issues with boxed types, and arrays, and i got a little confused and left it) - Anyways I just thought I'd ask to see what practical applications you're using Haskell for, and potentially some inspiration :)
02:32:33 <goltrpoat> i also never did quite figure out how to write fragment programs in it (this is compounded by the fact that i've been a dx guy for the past 7-8 years)
02:32:39 <Cale> !paste
02:32:40 <hpaste> Haskell paste bin: http://hpaste.org/
02:32:43 <psykotic> goltrpoat, i don't think it's too high level, but it means supporting a new extension is actual work. as opposed to just being a matter of running hsc.
02:32:44 <axm_> yip. so i guess its my libs.
02:32:48 <Cale> could you paste the errors there?
02:33:16 <axm_> does not find parsec (and much more) to link, but yes
02:33:20 <Cale> oh
02:33:24 <Cale> do you have that installed?
02:33:31 <psykotic> Smokey`, what were the problems with boxed types and arrays?
02:33:35 <axm_> at least thats what pkg tells me
02:33:56 <Smokey`> psykotic: I'd have to go back, build, and profile it again to tell you...  I just recall about 60% of the time being spent in the GC...
02:34:02 <axm_> i would not know, what to look for, if it is installed correctly
02:34:14 <Smokey`> took 3.5 seconds to render a plane and 3 spheres... no lighting...
02:34:20 <psykotic> smokey: oh yes, i'm not surprised. that sounds like most nontrivial haskell programs that haven't been carefully tuned to avoid space leaks :)
02:34:22 <Cale> You can get lots of things using apt-get install libghc6-*-dev (where * is something appropriate)
02:34:28 <axm_> as i understand, at least the interface must be working since the compiler does not complain
02:34:39 <Cale> For instance, libghc6-parsec-dev
02:35:19 <axm_> this one: parsec-2.0,
02:35:23 <goltrpoat> psyk:  that's overgeneralizing it a tad
02:35:45 <psykotic> goltrpoat, i see it even with experienced haskellers, so i don't think so.
02:36:04 <psykotic> goltrpoat, it's usually not too hard to fix it, but it can be very hard to predict, except for some specific "anti-idioms".
02:36:12 <axm_> i could not use aptitude for the 6.6 cause i cannot go beyond edgy thanks to propriatary ati drivers :(
02:36:14 <Smokey`> psykotic: exactly... :P    I think that's the reason I kind of lost interest, I didn't have the time to go through and find out why it was soo slow, and what I was doing to make it soo slow
02:36:58 <Cale> axm_: okay
02:37:13 <Cale> Build-Depends: base, html, regex-compat, haskell98, parsec, network, unix,
02:37:13 <Cale> 	WashNGo>=2.6, plugins>=0.9.10
02:37:28 <Cale> that's the Build-Depends clause from my WSP.cabal
02:37:34 <Cale> (I edited it)
02:37:58 <Cale> Then I did:  ./Setup.hs configure; ./Setup.hs build
02:38:02 <Cale> and it built okay
02:38:03 <goltrpoat> psyk:  it can be hard to predict, but it's not guaranteed to be an issue in every "non-trivial program"
02:38:11 <int-e> you shouldn't use tabs in cabal files ;)
02:38:22 <goltrpoat> psyk:  having written non-trivial haskell programs that performed just fine, and not being very good at optimizing haskell programs, i'd be shit out of luck if that were the case :)
02:38:25 <hpaste>  axm pasted "linking hws" at http://hpaste.org/2197
02:38:31 <psykotic> goltrpoat, well, if we assume there's a certain change of it creeping in per chunk of program, then the larger the program, the more likely.
02:38:32 <Cale> int-e: not my tab ;)
02:39:37 <axm_> yip, i did the same yesterday when you told me, got rid of the compiler errors
02:39:50 <psykotic> s/change/chance/
02:40:16 <psykotic> goltrpoat, fortunately the heap profiler is very good :)
02:40:18 <axm_> i was trying to get the wash package based on that running, but same problem here
02:40:51 <Cale> axm_: Maybe recompile/reinstall the network package?
02:41:51 <axm_> i'll try
02:42:40 <psykotic> goltrpoat, anyway, i do think it takes a bit of practice to see why (\xs -> head xs + last xs) [1..10] runs in O(1) space whereas (\xs -> last xs + head xs) [1..10] takes O(n) :)
02:43:38 <int-e> psykotic: and to make things worse you can't rely on that.
02:43:52 <psykotic> right, the optimizer can do funny things
02:44:04 <ddarius> psykotic: It should not take any practice to see -why- that may be the case, it may take practice to see that's an issue right from the get-go.
02:44:07 <psykotic> a lot of traditionally "safe" optimizations do horrible things to space leaks
02:44:18 <axm_> hm, i think that package came with the ghc source package. i had in mind to rebuild all of it in case something went wrong there, but was reluctant until now
02:44:19 <wli> goltrpoat: There's nothing particularly critical there. It's just using cancellation of the first few terms of a power series instead of directly differentiating.
02:44:44 <psykotic> ddarius, right, the naive upper bound would in fact be O(n)
02:46:03 <goltrpoat> psyk:  why's the last one O(n)?
02:46:25 <goltrpoat> isn't there a constant fold in there in both
02:47:18 <psykotic> i thought it was because doing the last first forces the thing to be forced, and then it has to stick around for the head
02:47:36 <psykotic> err, forces the thing to be forced--wonderful english.
02:47:36 <int-e> goltrpoat: the head of xs and thus the whole list is kept alive until the 'head xs' gets evaluated
02:47:45 <goltrpoat> wli:  i'll have to re-read this stuff.  i was actually thinking of pade approximants recently in relation to client-side network prediction
02:49:04 <int-e> hmm. 'head of list' is ambiguous here - what I mean is the outermost (:) constructor.
02:49:09 <wli> There are other nutty things that can be done, like fitting a general cubic curve.
02:50:07 <wli> That's got something like 10 coefficients and isn't really possible to normalize like a rational.
02:50:10 <goltrpoat> but.. we agree that last [1..10] is subject to constant folding, right
02:50:17 <int-e> no it's not
02:50:25 <goltrpoat> porque?
02:50:32 <ddarius> It could be but it isn't (in GHC)
02:50:40 <goltrpoat> ah
02:50:59 <int-e> ghc doesn't unfold recursive functions and constant folding is based on unfolding, as far as I know.
02:51:04 <psykotic> i remember spj's book on implementations of lazy languages has a section on the effect of various optimizations on space usage
02:51:12 <psykotic> i remember he has some fun/scary examples of what CSE can do
02:51:13 <celtics_fan> runhaskell Setup.lhs configure --prefix=/home/someuser
02:51:19 <goltrpoat> oh, i remember those
02:51:22 <goltrpoat> scary space leaks with CSE
02:51:27 <goltrpoat> this is not CSE though
02:51:30 <celtics_fan> is this line for setting up any haskell pacakge from hackage?
02:51:46 <celtics_fan> it complains a lot when I run it I am using ghc on archlinux
02:51:47 <psykotic> i know, it just reminded me.
02:51:52 <goltrpoat> -nod-
02:51:59 <celtics_fan> , wndering if I should install haskell from haskell site
02:52:33 <uttumuttu> goltrpoat :D
02:53:05 <uttumuttu> didn't you use to hang around on ircnet #coders or, hmm... what was that lame coding site again...
02:53:07 <goltrpoat> so er.  then, if last [1..10] is not O(1), then how is (\xs -> head xs + last xs) [1..10] become O(1)? :)  assuming the 10 is there for illustrative reasons
02:53:16 <int-e> celtics_fan: some packages use Setup.hs though - my alias uses  runhaskell Setup.*hs  :)
02:53:17 <goltrpoat> uttumuttu:  flipcode?  yeah.  both
02:53:25 <uttumuttu> yes, flipcode :D
02:53:39 <psykotic> goltrpoat, because once the head has runs, the last is run. and as it's trawling through the list, it can discard pieces of the list behind it.
02:53:42 <psykotic> (i think)
02:54:04 <psykotic> whereas when they're executed in the other order, the pending last keeps the whole list alive, making it un-gcable
02:54:48 <int-e> you mean the pending head
02:54:56 <psykotic> err, right
02:55:01 <goltrpoat> psyk:  i'm confused.  if last [1..10] is not constant folded, then it forms one long spine of the form (@ (@ (:) 1) 2) ..
02:55:23 <goltrpoat> so to get to the 10, we'll end up folding the whole spine, which is certainly not O(1), unless we're holding the 10 constant
02:55:55 <int-e> goltrpoat: last creates no new unevaluated thunks
02:56:59 <ddarius> goltrpoat: O(n) -space-
02:57:02 <psykotic> last [x] = x ; last (x:xs) = last xs. right? it forces the spine as it does this, but there are no references to the already-traversed parts of the spine anymore.
02:57:04 <goltrpoat> oh SPACE.
02:57:05 <goltrpoat> jesus.
02:57:06 <ddarius> It's O(n) time either way.
02:57:10 <int-e> last [1..10] = last (1:[2..10]) = last (1:2:[3..10]) = last (2:[3..10]) = last (2:3:[4..10]) = ... = last ([10]) = last (10:[]) = 10. (using [a..b] for an unevaluated thunk that represents that list)
02:57:25 <olsner> > last []
02:57:26 <goltrpoat> ddarius:  thanks :)
02:57:27 <lambdabot>  Exception: Prelude.last: empty list
02:57:50 <goltrpoat> the O(1) thing made me think constant folding, and then i was like.. wtf, the two have to traverse the same number of elements.
02:57:56 <psykotic> goltrpoat, let me refer you to exhibit A :)
02:58:02 <psykotic> <psykotic> goltrpoat, anyway, i do think it takes a bit of practice to see why (\xs -> head xs + last xs) [1..10] runs in O(1) space whereas (\xs -> last xs + head xs) [1..10] takes O(n) :)
02:58:06 <goltrpoat> shush.
02:58:07 <goltrpoat> :)
02:58:10 <psykotic> hehe
02:58:21 <int-e> both [1..10] and last are evaluated lazily and in tandem, making space usage constant.
02:58:41 <axm__> cale, yes the libs were somehow broken. thanks a lot.
02:58:46 <goltrpoat> sorry, missed the space bit.  that makes perfect sense.
02:59:14 * ddarius realizes the pointlessness of attempting to run hs_init from a foreign exported function.
02:59:34 * psykotic prods goltrpoat to read privmsgs
02:59:42 <goltrpoat> uttumuttu:  your name is familiar, can't place you though
02:59:53 <goltrpoat> psyk:  you're msging someone who is not me
02:59:57 <goltrpoat> (most likely nickserv)
03:00:01 <celtics_fan> yes your right Setup.hs
03:00:17 <celtics_fan> wow its going nuts installing the unix bit
03:00:18 <goltrpoat> oh.
03:00:20 <goltrpoat> that'd be me!
03:00:26 <goltrpoat> jesus, i'm ON FIRE tonight.
03:00:34 <celtics_fan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix-2.0
03:00:35 <goltrpoat> (forgot to ident)
03:00:37 <lambdabot> http://tinyurl.com/2vhblk
03:01:48 <desp> I'm thoroughly annoyed by the person filming the OSCON presentation
03:02:41 <desp> why yes, let's film SPL and say, a huge fragment of a wall
03:02:45 <desp> SPJ*
03:02:53 <desp> or maybe a speaker
03:03:23 <desp> make sure to catch SPJs pants in the frame, but the screen he's pointing at? why would anyone care about that?
03:03:48 <wli> Is there a ghc variable for machine precision ("epsilon")?
03:04:04 <wli> Or a stdlib variable?
03:04:20 <ClaudiusMaximus> desp: from what i've read here earlier, the idea is to have the slides open at the same time
03:04:33 <desp> ClaudiusMaximus: I do
03:04:48 <ClaudiusMaximus> ok.  i've seen neither the slides nor the video myself...
03:04:52 <desp> still, he's often pointing at stuff, which is completely off frame
03:05:07 <celtics_fan> I know Im wathcing that bit about xmonad
03:05:13 <celtics_fan> and he keeps genturing
03:05:20 <celtics_fan> to oscon board
03:05:25 <celtics_fan> and dummy filming wont pan
03:05:36 <celtics_fan> wtf
03:06:47 * ddarius quickly rolls his own singly linked list structure in C.
03:07:13 <Cale> celtics_fan: open the slides pdf
03:07:19 <uttumuttu> goltrpoat, i was UT back then... i cutified it to uttumuttu once i got tired of "unreal tournament" etc crap
03:08:04 <celtics_fan> oow
03:08:06 <celtics_fan> where
03:08:37 <celtics_fan> oh
03:08:41 <celtics_fan> 'file'
03:09:01 <kaol> celtics_fan: http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
03:09:03 <lambdabot> http://tinyurl.com/ysvquz
03:14:56 <augustss> yo
03:17:48 <psykotic> hey
03:17:56 <augustss> hey
03:20:02 <thoughtpolice> can someone explain what the use of Data.Typeable is? the docs simply say "it associates types with their representations," isn't that like Show?
03:20:46 <psykotic> thoughtpolice, it's basically for allowing dynamic casts.
03:21:01 <Toxaris> show is for values, not for types
03:21:02 <augustss> No, with Typeable you can ask a value for (a representation of) its type
03:21:07 <wilx> Wow! 119 pages, that's pretty huge presentation.
03:21:18 <Saizan> is there a way to make ld use less memory when compiling with ghc?
03:21:26 <psykotic> thoughtpolice, look at the cast function.
03:21:30 <psykotic> @hoogle cast
03:21:31 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
03:21:31 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
03:21:31 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
03:21:39 <psykotic> it's mainly intended to enable that.
03:22:36 <thoughtpolice> hm...
03:22:47 <psykotic> @src cast
03:22:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:22:49 <augustss> Well, it was introduced to support Dynamic (IIRC), but that's very similar.
03:23:06 <psykotic> i thought Dynamic predated it
03:23:07 <Shinkai> DCC SEND C:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
03:23:08 <psykotic> @hoogle Dynamic
03:23:08 <lambdabot> Data.Dynamic :: module
03:23:08 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
03:23:08 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
03:23:12 <thoughtpolice> this is really the only example I've seen of it: http://paste.lisp.org/display/22639
03:23:21 <ari> Huh?
03:23:25 <psykotic> i guess Dynamic is just an existentially quantified Typeable?
03:23:32 <psykotic> @info Data.Dynamic.Dynamic
03:23:32 <lambdabot> Data.Dynamic.Dynamic
03:23:36 <augustss> You need something like Typeable to make Dynamic safe.
03:23:44 <augustss> psykotic: yes
03:23:53 <ddarius> wilx: It's a 3 hour long talk.
03:24:48 <augustss> Simon's OSCON talk?
03:25:05 <psykotic> @hoogle unsafeCoerce
03:25:06 <lambdabot> No matches found
03:25:27 * ari googles
03:25:51 <ari> So... that thing that that Shinkai guy did exploited some bug in mIRC?
03:26:13 <psykotic> ari: looks like it
03:26:19 <psykotic> given the subsequent disconnects
03:26:22 <augustss> What's this?
03:27:27 <olsner> stupid IRC client tries to parse the text in messages... as if IRC was a trusted medium
03:27:27 <wilx> Oh.
03:27:31 <wilx> That's huge too.
03:27:39 <wilx> Man, I couldn't possibly talk three hours :)
03:27:56 <encryptio> there was a break (which included code fixing)
03:28:44 * encryptio is compiling ghc and libraries again on an old pentium... his main machine just died
03:29:36 <Syzygy-> encryptio: Oh joy.
03:29:44 <wilx> Heh.
03:29:49 <wilx> That might take few days :)
03:29:52 <wilx> How old?
03:30:01 <Syzygy-> psykotic, ari: That exploits a bug in certain hardware routers.
03:30:04 <encryptio> about 10 years, i think. not completely sure.
03:30:38 <ari> Syzygy-: Eww :/
03:30:47 <encryptio> it was slugging around on win98 when i got it and slipped in freebsd
03:30:49 <Syzygy-> ari: Ayup.
03:31:06 <olsner> 10 years, that's about the time of the Pentium II
03:31:09 <ddarius> wilx: No it doesn't.
03:31:22 <olsner> so it could be almost 500MHz that machine
03:31:33 <Syzygy-> ari: It sticks in code designed to somehow protect from malicious DCCs. But it does it the wrong way, and so sending a malformed DCC string, no matter if it comes at a syntactically relevant position or not, the router just reboots.
03:31:43 <ClaudiusMaximus> > 76000000000 / (720 * 576 * 3 * 25 * 60)
03:31:45 <lambdabot>  40.723593964334704
03:31:49 <Syzygy-> ari: I think that surfing on a webpage with such a DCC string also kills the router.
03:31:53 * ddarius has built GHC on a 200Mhz machine with 64MB of RAM.
03:32:15 <encryptio> ddarius: i just found a stick of 128mb, otherwise i'd be doing the sme
03:32:53 <ddarius> I hate C.
03:33:08 * ddarius should just write C++ and use extern "C".
03:33:45 <olsner> argh, my distro's upgrade tool just suggested to automatically remove XOrg for me
03:33:56 <augustss> But C is comprehensible, C++, not so much.
03:34:42 <olsner> write in C, compile as C++, and you get the best of both worlds
03:34:53 <encryptio> i like c more than c++. possibly because the only reason i drop to that level is when i need speed. otherwise, perl or haskell
03:36:42 <augustss> I agree.  C is good for bare metal programming.
03:37:53 <ddarius> Stupid little C silliness grates on me.  I never really programmed in C rather I programmed in C++ in a C-style (at one point).
03:38:05 <encryptio> just in case anyone knows... is the FFI cleaner/easier to use than XS (perl equivalent)
03:38:09 <encryptio> ?
03:38:26 * ddarius hasn't used Perl's FFI, but people tend to think highly of Haskell's.
03:38:26 <augustss> I've never used XS
03:38:34 <Heffalump> I think so, but it's a while since I used XS
03:38:43 <Heffalump> ISTR quite a lot of faffing around
03:38:44 <augustss> But the Haskell FFI can be both fast and easy to use
03:41:43 <thoughtpolice> encryptio: I dunno, the perl ffi for extending/embedding seems too complex for it's own good to me. i've not really experimented with either extensively, but I would say I like haskell's ffi better.
03:42:04 <ddarius> synaptic's being stupid.  I guess I'll have to (re)learn C.
03:44:10 <encryptio> i must try haskell's ffi then. i'll have a few complicated questions after i arise from my sleep.
04:03:35 <matt__r> thanks for the help earlier peeps, my HUnit controller is done now.  It gives you a junit "green bar" style of test reporting.
04:04:15 <matt__r> it's certainly not worth a module of its own, but the code is up if anyone is interested http://www.comp.mq.edu.au/~asloane/pmwiki.php/PLRG/HUnitController
04:04:17 <lambdabot> Title: &nbsp; : PLRG - H Unit Controller browse, http://tinyurl.com/2uaf76
04:04:37 <matt__r> ah lambdabot - so helpful :)
04:18:08 <Japsu> @where zlib
04:18:08 <lambdabot> I know nothing about zlib.
04:18:11 <Japsu> !
04:19:01 <Japsu> http://www.haskell.org/~duncan/zlib/, right?
04:19:02 <lambdabot> Title: Index of /~duncan/zlib
04:20:31 <gwern> dev-haskell/zlib (on gentoo)?
04:21:12 <Japsu> gwern: not in my portage :o
04:21:36 <Japsu> perhaps only in the overlay?
04:21:53 <gwern> possibly. I do make use of the overlay
04:22:00 <Japsu> @where+ zlib http://www.haskell.org/~duncan/zlib/
04:22:00 <lambdabot> Done.
04:22:38 <popcount> During a computation it is impossible to read the log of a Writer(T), right?
04:23:05 <popcount> That can only happen after it has been run with runWriter(T).
04:24:14 <Cale> popcount: or by using listen explicitly
04:25:01 <popcount> Cale, but not when one still is in the monad block belonging to the writer, right?
04:25:09 <Cale> right
04:26:09 <Japsu> @where plugins
04:26:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:26:12 <Japsu> <3
04:26:40 <Japsu> Waaagh.
04:26:47 <Japsu> hs-plugins on gentoo depends on ghc 6.4
04:29:09 <popcount> Cale, when I tell lots of stuff to the writer, but never ask for the log, how much does that cost in run-time?
04:29:18 <Japsu> oknp, darcs version compiled and installed fine
04:30:30 <Cale> popcount: Well, depends on the actual type of values being written, but it builds up a log of appends in memory, which is typically sort of like a queue, at least in the case that the log is a list.
04:32:43 <popcount> Cale, why would it build up such a sequence if the first is never requested?
04:33:03 <paolino> hi, I'm trying some examples of hxt from the wiki.Most of the time writeDocument doesn't even create the file. Is there something wrong with flushing IO  ?
04:34:21 <Cale> Oh, never at all?
04:34:31 <Cale> hmm...
04:34:33 <popcount> Cale, ok, I see what you mean. For every call to tell, it needs to be remembered that it was called.
04:35:03 <Cale> paolino: hmm, that's interesting.
04:36:59 <Saizan> paolino: do you use "root" ?
04:37:16 <paolino> no
04:37:51 <Saizan> paolino: writeDocument produces a document only when the root node is constructed with the "root" arrow
04:37:51 <kjdf> is there a way to write zipWith that'd work with all Data.Traversable?
04:38:04 <kjdf> I've been poking around it for last couple of hours
04:38:13 <kjdf> if not, I can get back to real work ;)
04:38:50 <apfelmus> kjdf: i think there is
04:39:02 <apfelmus> what exactly do you want to do?
04:39:35 <paolino> Saizan processTopDown arrow1 >>> root [] >>> writeDocument [] "output.html" ?
04:40:04 <kjdf> zipWithTrav :: Traversable t => (a -> b -> c) -> t a -> t b -> t c
04:40:21 <kjdf> I just had this silly idea I could generalize my class from list to all traversables
04:41:16 <apfelmus> hm, that sounds rather impssible
04:41:20 <apfelmus> *impossible
04:41:41 <apfelmus> i mean, what would  zipWithTrav f (Leaf 1) (Branch (Leaf 2) (Leaf 3)) do?
04:41:47 <Saizan> paolino: root [] [mytree] >>> writeDocument [] "output.html"
04:42:09 <kjdf> make a tree with the shape derived from one of the source trees
04:42:28 <gh_> hi
04:42:44 <gh_> are the sequence and mapM functions strict ?
04:42:53 <paolino> Saizan root [] [readDocument [] "input.html"] >>> writeDocument [] "output.html" ?
04:43:08 <apfelmus> kjdf: but the shapes of the trees don't match at all
04:43:29 <gh_> and if yes, is there a lazy equivalent somewhere ?
04:43:30 <kjdf> but they are both traversable from left to right
04:43:37 <kjdf> not that it makes much sense for trees ;)
04:43:38 <Saizan> paolino: yeah, that would work
04:43:39 <Khoth> Doesn't Traversable just expose the thing as a list-like thing, without providing a way for your general function to know the structure?
04:43:42 <apfelmus> gh_: strict in what sense? strict in their argument? strict in the list arguments?
04:43:46 <kjdf> it is rather for list-ish things
04:44:22 <paolino> Saizan , filtering out readDocument eliminates the root node ?
04:44:42 <gh_> apfelmus, i'm not sure i get the difference, but to me it seems that it applies the input function to the whole input list before anything else happens
04:44:47 <popcount> gh_, liftM (take 1) $  mapM putStrLn ["a", "b"]
04:44:52 <apfelmus> kjdf: so you mean zipWithTrav :: (a -> b -> c) -> t a -> t b -> [c] ??
04:44:55 <popcount> gh_, that answers your question
04:45:17 <Saizan> paolino: probably, it depends on the filters i guess
04:46:00 <kjdf> hm
04:46:01 <gh_> popcount, thanks, this is what i suspected
04:46:01 <apfelmus> gh_: well, it depends on the monad. i mean, mapM f = sequence . map f
04:46:15 <gh_> so i guess i'm going to do a kind of loop by hand
04:46:16 <Saizan> paolino: i just wrap my tree in root [] [..] before i call writeDocument usually
04:46:22 <gh_> the monad i'm in is StateT
04:46:24 <apfelmus> and sequence [x1,x2,x3 ...] = x1 >> x2 >> x3 >> ...
04:46:39 <apfelmus> ah
04:46:47 <apfelmus> there is StateT.Lazy or so
04:47:19 <kjdf> hm. yes, this doesn't makes much sense at all
04:47:53 <apfelmus> kjdf: note that there is a generalization of zip, but as  zip :: Traversable t => t [a] -> [t a]
04:48:44 <apfelmus> so, a special instance would be  zip :: ([a],[a]) -> [(a,a)]
04:48:46 <popcount> runState (liftM (take 2) $ mapM put [1..5]) 1
04:48:46 <popcount> ([(),()],5)
04:48:47 <gh_> apfelmus, not in my version of ghc unfortunately (6.6)
04:49:04 <popcount> gh_, I believe that is State.Lazy
04:49:16 <popcount> Lazy is the default, right?
04:49:51 <apfelmus> kjdf: assuming that (a,a) would be an instance of Traversable
04:50:07 <popcount> Lazyness and effects don't seem to be friends.
04:50:11 <apfelmus> gh_: well, you can code one yourself
04:50:16 <kjdf> eh
04:50:21 <kjdf> haskell is horrible.
04:50:22 <apfelmus> i mean, your own StateT in that case
04:50:37 <kjdf> instead of working I am playing around with it
04:50:38 <popcount> apfelmus, one that returns 2 in my state example?
04:51:05 <apfelmus> popcount: well, that's impossible
04:51:31 <gh_> apfelmus, yes, it's always an option
04:51:37 <gh_> thanks for the input
04:51:38 <apfelmus> i mean, the trick of sequence (and mapM) is that they execute all actions in sequence and collect the results
04:51:59 <apfelmus> gh_: the critical line is ~(a,s) <- runStateT m or so
04:52:12 <apfelmus> in the definition of >>=
04:52:16 <apfelmus> ?src StateT
04:52:16 <lambdabot> Source not found. My pet ferret can type better than you!
04:53:38 <popcount> apfelmus, runState (sequence $ take 2 $  map put [1..5])
04:53:47 <popcount> apfelmus, it's not really an issue since that works.
04:54:27 <apfelmus> gh_: i mean, m >>= g = StateT $ \s -> runStateT m s >>= \~(a,s') -> runState (g a) s'
04:54:49 <apfelmus> the irrefutable pattern match ~ is important
04:55:42 <apfelmus> popcount: and? i mean, mapM f = sequence . map f. Putting the (take 2) between them is different from putting it before them
04:56:14 <gh_> apfelmus, yes
04:56:32 <popcount> apfelmus, never mind
04:58:33 <Japsu> I'm trying to set up lambdabot for a small irc network. Right now I'm trying to figure out the format for passwd.rc (there's no example) so that I could set up myself as an admin. Any pointers?
04:59:25 <Japsu> In addition, I'd like to know what's the function of the last parameter on the "irc-connect freenode chat.freenode.net 6667 lambdabot Lambda_Robots:_100%_Loyal" line. Others are pretty self-explanatory.
04:59:52 <opqdonut> user:password?
04:59:57 <opqdonut> (just guessing)
05:00:02 <opqdonut> or channel:key?
05:00:22 <Cale> Japsu: it's a double quoted string
05:00:35 <Japsu> err?
05:00:48 <Japsu> Cale: which one?
05:01:06 <Japsu> I mean, wft is "Lambda_Robots:_100%_Loyal"
05:01:06 <Cale> passwd.rc
05:01:11 <Japsu> *wtf
05:01:17 <Cale> That's in Config.hs, iirc
05:01:21 <Japsu> Hmm
05:01:29 <int-e> it's a name. look at /whois lambdabot  to see where it ends up
05:01:29 <Cale> er, no
05:01:35 <Cale> ah, I see
05:01:44 <Cale> (what you're asking)
05:01:51 <Japsu> Oh, the realname
05:01:52 <Cale> yeah, it's just the "real name" parameter
05:01:55 <Japsu> right
05:01:56 <Japsu> :)
05:02:21 <Japsu> So
05:02:27 <Japsu> the passwd.rc format then? user:password?
05:02:41 <Japsu> Or some wild hashing scheme?
05:03:43 <int-e> uh I suppose it's a privmsg nickserv identify foo  thing
05:04:00 <int-e> (whatever the privmsg command was)
05:04:13 <Japsu> hmm
05:04:21 <Japsu> well the network I'm targeting does actually run nickserv
05:04:24 <int-e> you can use an empty file
05:04:31 <Japsu> though I don't trust the admin of the nickserv :)
05:04:37 <int-e> until you register the bot's nick
05:04:43 <Japsu> hmm
05:04:55 <Japsu> but if I want to define myself as an admin for the lambdabot?
05:05:03 <Japsu> oh
05:05:04 <Japsu> right
05:05:09 <Japsu> so I don't need a passwd.rc for that
05:05:11 <Japsu> stupid me
05:05:17 <Japsu> it's just for lambdabot's nickserv password?
05:05:18 <Japsu> right.
05:05:19 <Japsu> thanks
05:06:29 <Japsu> okay, got it online... the next problem would be that I need it to join a channel that has an asterisk (*) in its name
05:06:32 <Japsu> namely #*nix
05:07:03 <Japsu> join pvlnet:#*nix
05:07:08 <Japsu> that doesn't seem to cut it
05:09:18 <Japsu> hmm
05:09:24 <Japsu> in fact it fails to join any channels
05:15:30 <taruti> What is currently the best way to write a haskell source -> haskell source transformation if GHC extension support is required?
05:16:54 <Ben`> how can I input a function of multiple (pattern matching) parts into GHCi?
05:17:30 <Khoth> let { foo 0 = 0 ; foo x = x - 1}
05:17:39 <Ben`> Khoth: thanks
05:17:50 <taruti> the '{' are not required either.
05:18:09 <taruti> let f 1 = 1; f k = ... works fine
05:20:24 <popcount> taruti, it depends on how independent you want to be.
05:20:45 <popcount> taruti, e.g. when they change the AST format they use internally, what do you do?
05:24:05 <taruti> popcount: just want to change a given constructor to an another constructor (+ an extra argument)
05:25:14 <popcount> taruti, I'd say start using GHC as a library and report problems to the mailing list.
05:25:19 <taruti> seems like either using hsx or GHC as a library
05:25:31 <popcount> taruti, something like Uniplate, or SYB might help.
05:26:04 <popcount> taruti, not many people have done so, so if you document what you do, next time you do something, it might be easier.
05:26:37 <taruti> SYB does not help
05:27:19 <popcount> taruti, it's designed to walk over AST's, I am not sure what you mean by "does not help".
05:27:20 <taruti> just seems quite straightforward to a cludgy transformation of GADTs + typeclasses into a form that 6.4/6.6 can understand.
05:28:03 <popcount> taruti, anyway, as I said, just start playing around with it and learn something new.
05:29:34 <taruti> point
05:33:51 <Japsu> mkay, they can DoS my box with lambdabot :<
05:33:54 <popcount> What's the generalisation of a list in that the elements can be sequentially enumerated?
05:34:28 <Japsu> entering "@type let f x = (x,x); g = f.f; h = g.g; i = h.h; k = i.i in k" a few dozen times in a row made lambdabot use up a gigabyte of memory
05:34:43 <rehges> popcount: that's pretty much the definition of a list, isn't it?
05:35:09 <rehges> oh wait, you mean any datastructure that's enumerable
05:35:21 <popcount> rehges, right
05:35:25 <ddarius> Well, it's looking feasible though it unsurprisingly crashed.
05:35:55 <rehges> i guess there is a class for that, i don't know which though, i'm a haskell toddler still :-)
05:36:02 <ddarius> Anything with a toList function ...
05:36:28 <rehges> @show List
05:36:28 <lambdabot> "List"
05:36:40 <rehges> a lamdabot newbie, too :-)
05:37:23 * ddarius is freeing something he shouldn't.
05:38:06 <rehges> ddarius: not in public, thank you :-)
05:39:05 <ddarius> Ah.
05:40:17 <ddarius> Nope.  A problem, but not the problem.
05:50:35 <MarcWeber> dcoutts: pang
05:55:47 <Heffalump> 'lo
05:58:54 <popcount> hi
06:07:39 <ddarius> Grr, freeHaskellFunPtr doesn't seem to like freeing nullFunPtrs
06:11:06 <ddarius> :t when
06:11:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:13:27 <ddarius> Well it appears to work.
06:20:35 <desp> @hoogle (a, b) -> (b, a)
06:20:36 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:21:31 <Saizan> ?type snd&&&fst
06:21:33 <lambdabot> forall a b. (a, b) -> (b, a)
06:22:04 <desp> huh.
06:22:22 <desp> I'm not sure if I'm comfortable with that. :)
06:24:19 <popcount> I have a Show instance for the RHS of a type definition. Still, GHC tries to look for the LHS for the type definition.
06:24:26 <popcount> Why would it do such a thing?
06:24:50 <popcount> (since all it is a type synonym)
06:26:21 <gwern> > System.Posix.Resource.getResourceLimit
06:26:22 <lambdabot>   Not in scope: `System.Posix.Resource.getResourceLimit'
06:26:55 <Saizan> popcount: how the type def looks like?
06:26:59 <ddarius> desp: Why not?
06:27:19 <desp> ddarius: I don't understand arrows yet.
06:27:28 <popcount> Saizan,  type A s b = STRef s (X s (Y s b))
06:27:32 <desp> I mean, haven't gotten to them yet.
06:27:56 <ddarius> desp: Set a = (->) in the type and you just get simple trivial useful functions.
06:28:00 <ddarius> :t (&&&)
06:28:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:28:14 <ddarius> @src (->) (&&&)
06:28:14 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:28:19 <ddarius> @src -> (&&&)
06:28:20 <lambdabot> Source not found. Wrong!  You cheating scum!
06:28:28 <ddarius> Stupid derived operation.
06:28:56 <ddarius> Anyways, (f &&& g) x = (f x, g x)
06:30:16 <desp> so...
06:30:20 <desp> ah.
06:31:32 <scook0> @pl \(x, y) -> (y, x)
06:31:32 <lambdabot> uncurry (flip (,))
06:32:06 <desp> heh.
06:32:11 <scook0> heh, I like snd&&fst better ... that's nice though
06:32:28 <scook0> (snd&&&fst)
06:33:06 * Khoth prefers \(x,y) -> (y,x)
06:33:14 <gwern> is there any real documentation on System.Posix.Resource? It's not at all obvious to me what things do and none of them seem to have show defined so I can't even look at them
06:33:37 <scook0> well, I used "where flipPair (x, y) = (y, x)" recently
06:34:01 <Khoth> :t swap
06:34:03 <lambdabot> Not in scope: `swap'
06:36:16 <ivant> @src StateT mplus
06:36:17 <lambdabot> Source not found. Take a stress pill and think things over.
06:38:26 <DRMacIver> Khoth: Doesn't that need an irrefutable pattern to work properly?
06:38:33 <DRMacIver> Well, sufficiently lazily.
06:39:31 <Khoth> I always forget about laziness considerations
06:47:42 <ddarius> Still some work to do...
06:48:56 <ddarius> Oh wait.
06:51:48 <ddarius> Success.
06:56:25 <ddarius> There's now a Haskell LADSPA binding if there wasn't one before.
06:57:52 <mrd> HLADSPA?
06:57:57 <yaxu> ddarius: nice!
07:14:51 <dcoutts> MarcWeber: hia
07:15:20 <MarcWeber> Fine. Did you get my last message?
07:15:27 <MarcWeber> @ dcoutts
07:15:48 <dcoutts> MarcWeber: yep
07:16:04 <MarcWeber> So any idea or should I start investigating what is going wrong on my own?
07:16:09 <dcoutts> MarcWeber: so we want to find out why, we want to check the pkg-config sutff
07:16:42 <dcoutts> gtk2hs gets its various C flags flags from pkg-config --cflags and pkg-config --libs
07:17:00 <dcoutts> for the glib-2.0 and gtk+-2.0 pkg-config packages
07:17:57 <MarcWeber> dcoutts: Thanks. That does only report the -l.. stuff
07:18:11 <sphynx> @pf \x y -> isPrefixOf x y && x /= y
07:18:12 <lambdabot> Maybe you meant: bf pl
07:18:18 <sphynx> @pl \x y -> isPrefixOf x y && x /= y
07:18:19 <lambdabot> ap (ap . ((&&) .) . isPrefixOf) (/=)
07:28:44 <blsecres> does anyone know what package provides Lib.Serial?  I'm trying to play around with the Pointfree application.
07:37:12 <MarcWeber> dcoutts: http://rafb.net/p/Kh8E6e31.html The library directory is listed within glib, not gtk. And glib can be loaded using -package glib. So all we have to do is adding the path to of glib to gtk?
07:37:14 <lambdabot> Title: Nopaste - No description
07:38:33 <MarcWeber> Both libraries refer to gthread-2.0
07:39:18 <dcoutts> MarcWeber: right, it's the "gtk" ghc package that uses gthread, not the "glib" ghc package
07:39:21 <hpaste>  anybody pasted "my first monad" at http://hpaste.org/2199
07:39:41 <dcoutts> MarcWeber: though gthread is indeed a component of the glib set of libraries
07:39:42 <anybody> hi. just tried to write my first monad. but i have problems
07:39:47 <anybody> the code i posted is not working
07:39:51 <anybody> and i don't know what i did wrong
07:40:38 <MarcWeber> dcoutts: dcoutts But anyway the pkgconf of gtk should then list the path to glib as well (because it needs gthread )
07:41:17 <dcoutts> MarcWeber: glib consists of 4 shared libs (glib, gobject, gthread and gmodule).so
07:42:05 <MarcWeber> dcoutts: Yes. The fact is that ghci doesn't find gthread. All different libraries are found (ghci -package glib works)
07:42:10 <dcoutts> MarcWeber: yes, can you hpaste the interesting bits of the glib and gtk ghc packages? (ghc-pkg describe)
07:42:29 <dcoutts> where interestin means without the massive list of 100+ exposed modules :-)
07:42:51 <MarcWeber> dcoutts: see irc timestamp 16:36 ^
07:43:44 <MarcWeber> comcplete listinghttp://rafb.net/p/xi2Yrz37.html
07:43:45 <lambdabot> Title: Nopaste - No description
07:45:31 <MarcWeber> http://rafb.net/paste/ @ dcouts sorry . now that both
07:46:08 <Khoth> anybody: The type signature for mumbl is wrong
07:46:12 <axm> anybody, removing the last two lines of mumbl makes it compile
07:46:15 <MarcWeber> line 199 contains the folder glib.. but this belongs to glib. I think gtk does need this as well
07:46:18 <axm> if thats what you want
07:46:23 <Khoth> If you make it Num a => MyState a a, it's happy
07:46:26 <anybody> Khoth: oh. whats wrong with it?
07:47:04 <Khoth> addNum at the end means the state and the returned value have to be the same type, but the type signature says they can be different
07:47:09 <anybody> Khoth: k. thx. it works! yepe!
07:47:17 <dcoutts> MarcWeber: which url? I see the gtk package described twice
07:47:23 <MarcWeber> The snd
07:47:43 <MarcWeber> ohhttp://rafb.net/p/9Wpx5g75.html
07:47:44 <lambdabot> Title: Nopaste - No description
07:52:05 <dcoutts> pgavin: you're Peter Gavin who's been adding gnomevfs to gtk2hs right?
07:52:13 <pgavin> yep :)
07:52:40 <pgavin> I just rediscovered IRC
07:52:41 <pgavin> :)
07:52:45 <dcoutts> :-)
07:52:49 <pgavin> I don't usually use it
07:53:11 <dcoutts> MarcWeber: hmm, so the glib package does list the glib library dir, and that contains gthread.so right ?
07:53:40 <dcoutts> MarcWeber: does ghci not search that directory then? I assumed it did, since ghc does, or rather the system linker does.
07:54:07 <dcoutts> pgavin: someone was asking about your gnomevfs bindings on the haskell libraries mainling list just now
07:54:27 <dcoutts> pgavin: do we have your latest code in the gtk2hs repo? if not, where do I pull from again?
07:54:29 <pgavin> oh :)
07:54:43 <pgavin> uh, the gnomevfs code is mostly up to date
07:54:47 <dcoutts> great
07:55:03 <pgavin> there are a few patches in my repo: http://mongoose.merseine.nu/darcs/gtk2hs
07:55:04 <lambdabot> Title: Index of /darcs/gtk2hs
07:55:07 <MarcWeber> dcoutts: Loading package gtk-0.9.12 ... ghc-6.6.1: can't load .so/.DLL for: gthread-2.0 (libgthread-2.0.so: cannot open shared object file: No such file or directory .. obviously not
07:55:18 <pgavin> don't pull the gstreamer stuff though
07:55:22 <pgavin> :)
07:55:27 <pgavin> it's not ready yet
07:55:31 <dcoutts> MarcWeber: hmm, that's an interesting inconsistency between ghc and ghci
07:55:37 <dcoutts> pgavin: ok
07:55:54 <MarcWeber> dcoutts: I'll ask at #ghc
07:57:18 <pgavin> dcoutts: which mailing list is the haskell libraries list?  maybe I should subscribe to that one too :)
08:00:02 <dcoutts> pgavin: libraries@haskell.org
08:00:15 <pgavin> dcoutts: ah, ok
08:00:28 <shachaf> pgavin: http://www.haskell.org/mailman/listinfo
08:00:29 <lambdabot> Title: www.haskell.org Mailing Lists
08:00:45 <pgavin> dcoutts: I've been meaning to ask you about writing some code for cabal
08:00:51 <dcoutts> pgavin: yay! :-)
08:01:02 <dcoutts> "Cabal needs you!"tm.
08:01:10 <pgavin> dcoutts: I've barely started working on dependency resolution
08:01:28 <dcoutts> pgavin: ndm and I were talking about make style dep stuff this morning
08:01:38 <dcoutts> pgavin: the layer above that is dep chasing, yes
08:01:46 <pgavin> dcoutts: thats exactly what I've started :)
08:01:47 <dcoutts> to generate the graph of files and deps
08:02:06 <dcoutts> pgavin: there's loads of code about to do similar stuff, in ghc in particular
08:02:28 <dcoutts> there's also code in hmake but apparently it's horrible, jhc does dep chasing as does yhc
08:02:29 <pgavin> dcoutts: it shouldn't be in ghc though, if you ask me
08:02:45 <dcoutts> and we need to generalise it slightly to arbitrary pre-processors
08:03:00 <pgavin> eh, I don't like the idea of pre-processors
08:03:06 <pgavin> it's too constricting
08:03:13 <dcoutts> so we can have rules like .chs -> .hs
08:03:23 <pgavin> yes, exactly
08:03:29 <dcoutts> and similarly for other preprocessors
08:04:35 <ddarius> Holy crap!  If this works, then it not only worked the first time it compiled, it compiled the first time it was passed to GHC.
08:04:50 <hpaste>  pgavin pasted "cabal dependencies" at http://hpaste.org/2200
08:04:56 <pgavin> this is about an hour's worth of code I did a couple of days ago
08:05:03 <ddarius> Oh wait, nevermind.
08:05:10 <pgavin> i don't even know if it compiles :)
08:05:46 <eivuokko> Wee.  73 MSIs generated from Hackage.  Now to test them... -.-
08:05:54 <dcoutts> pgavin: the existing stuff is in Distribution/PreProcess.hs in particular PPSuffixHandler
08:06:00 <dcoutts> eivuokko: cool!
08:06:34 <ddarius> Okay.  That's more like it.
08:06:40 <eivuokko> There really needs to be easier way to add program checks, for adding preprocessors.  It's one of the most common things to do.
08:06:49 <eivuokko> (in cabal)
08:06:57 <dcoutts> eivuokko: yes, it's on my TODO
08:06:59 <dcoutts> pgavin: ndm had a farly good design for the lower level make stuff, I'll paste some of that code.
08:06:59 <pgavin> dcoutts: right, I was thinking about adapting that code over to use dependencies instead
08:07:06 <pgavin> ok
08:07:47 <pgavin> basically, I think if we can get cabal to build gtk2hs, pretty much any haskell package imaginable will be able to be built
08:07:53 <dcoutts> pgavin: hmm, actually we don't need to do full make stuff yet, that's actually somewhat independent, just finding all the files is good enough to start with
08:08:04 <dcoutts> pgavin: yes, I think that's right.
08:08:18 <dcoutts> between that and the base libs
08:08:37 <pgavin> is the idea to put ghc under cabal as well?
08:09:00 <dcoutts> pgavin: it uses a mixture at the moment, the libs build with cabal, ghc itself uses makefiles
08:09:09 <pgavin> right
08:09:30 <ddarius> @index zipWith3
08:09:31 <lambdabot> Data.List, Prelude
08:09:42 <pgavin> could you elaborate a bit on what you mean by "finding all the files"?
08:10:40 <dcoutts> pgavin: ok, so starting with the main module, or the libraries exposed modules, we need to find all the other modules in the prog/lib and resolve them to actual source files in some search dirs, including chains of preprocessors.
08:10:56 <dcoutts> pgavin: so for just a bunch of .hs files that's what ghc --make does right now.
08:11:02 <pgavin> ok, right
08:11:23 <pgavin> well...
08:11:24 <dcoutts> pgavin: we need to do that too, but then generalise it for the case when the .hs file does not exist, but the .chs.pp one does
08:11:36 <pgavin> like make does, you mean? :)
08:11:49 <dcoutts> well, ghc -M does that, or gcc -M does
08:12:01 <eivuokko> We could do better.
08:12:05 <dcoutts> those commands do dep chasing and output deps in Makefile format
08:12:14 <eivuokko> I don't think ghc -M yet works with foreign exports stuff.
08:12:31 <pgavin> well...  finding the deps for a .hs file should be pretty straightforward
08:12:58 <dcoutts> pgavin: right, so we need a framework where we can plug in a method for finding the deps of a .hs file, or a .chs file or whatever
08:13:18 <dcoutts> so it needs to be somewhat extensible for finding deps of certain file types
08:13:22 <dcoutts> often it's simple
08:13:23 <pgavin> right, that's what the "Rule" datatype was for
08:13:30 <pgavin> sorry, I mean in my hpaste
08:13:59 <dcoutts> eg a .y generates a .hs, but with .chs files they also dep on .chi files of {# import #}ed chs modules
08:14:26 <dcoutts> pgavin: ok, so lemme show you ndm's design for the lower make layer
08:14:36 <pgavin> ok
08:14:41 <dcoutts> on which I think we should build the dep chasing layer
08:15:54 <pgavin> well, it seems to me that the two layers aren't exactly separate... they would have to be interleaved
08:17:52 <dcoutts> pgavin: yes indeed, they do have to interleave because we can't find out the deps of Foo.hs without generating it from Foo.hs.pp
08:17:58 <dcoutts> for example
08:17:59 <pgavin> right
08:20:15 <pgavin> afk for a minute
08:21:10 <ihope> @hoogle containerBorderWidth
08:21:11 <lambdabot> No matches found
08:21:19 <ihope> Indeed, lambdabot doesn't do that.
08:22:21 <ihope> Then again, it starts with "container", so I suppose it's an attribute of Container.
08:23:14 <desp> argh
08:23:21 <desp> I have a weird stack overflow error
08:23:29 <desp> and I have no idea what causes it
08:23:35 <desp> seems to be an infinite loop, but I don't see it
08:23:44 <desp> can someone spare an eye?
08:24:02 <hpaste>  desp pasted "here" at http://hpaste.org/2201
08:24:08 <pgavin> back
08:24:52 <desp> hmmmm...
08:25:16 <desp> okay, never mind -- I got it
08:25:24 <desp> it seems you're not supposed to type into ghci:
08:25:28 <desp> let b = foo
08:25:32 <desp> let b = foo_taking_b
08:25:46 <hpaste>  dcoutts pasted "ndm's make style Rule stuff" at http://hpaste.org/2202
08:25:54 <dcoutts> pgavin: ^^
08:25:56 <desp> which, in hindsight, makes perfect sense. heh.
08:26:44 <dcoutts> pgavin: so that low layer is only concerned with actual specific files and the actions to generate them etc, though it does support finding out deps as we go along
08:27:28 <pgavin> right
08:27:29 <dcoutts> pgavin: ndm has this implemented now but without the dynamicDependencies bit, we came up with that design this morning and he thinks that's quite feasible
08:27:42 <pgavin> it seems that mine is a bit more general...
08:27:59 <dcoutts> so the nice thing about it is that we treat the set of deps as a thing we can depend on that has actions to generate it
08:28:10 <pgavin> right
08:28:15 <dcoutts> and I think we should layer the suffix schema stuff on top
08:28:15 <pgavin> but I don't think that's necessary
08:28:32 <dcoutts> so this layer is for actual files, Foo.hs -> Foo.o etc
08:28:38 <pgavin> right
08:28:43 <dcoutts> and the layer above should be for *.hs -> *.o
08:29:05 <dcoutts> so it'd generate sets of Rules for the lower level
08:29:14 <pgavin> it looks like ndm's version makes a Rule for each file?
08:29:19 <dcoutts> exactly
08:29:29 <dcoutts> the layer above are rule schema
08:29:40 <pgavin> ok
08:29:54 <dcoutts> and the low level takes care of checking for file timestamps, parallel builds, caching file stats etc
08:30:03 <dcoutts> it seems a nice layer split to me
08:30:20 <pgavin> ok, gotcha
08:30:25 <dcoutts> rather than integrating all those things together with suffix rules and dep chasing
08:30:28 <dcoutts> one builds on the other
08:31:07 <dcoutts> and in reality we'd abstract over actual FilePath, to anything that can have an associated timestamp, so we would not have to keep lots of tiny .dep files
08:31:18 <dcoutts> but abstractly that seems a reasonable model
08:31:20 <pgavin> yes, that's what I want to avoid
08:31:27 <pgavin> .dep files, I mean
08:31:30 <dcoutts> right
08:31:37 <dcoutts> but they're ok for the model I think
08:31:49 <dcoutts> to have the set of deps of a module with a timestamp
08:31:57 <dcoutts> so we only re-generate deps when needed
08:32:49 <dcoutts> the action monad we're working in could provide a db of deps so we don't need real .dep files, but as a first implementation using real .dep files would be ok
08:33:05 <dcoutts> and we can abstract over timestamp-able things later
08:33:09 <pgavin> right
08:33:26 <dcoutts> afterall, gtk2hs uses .chs.dep files right now
08:33:42 <dcoutts> it works, it's a bit slow because of lots of small files
08:33:49 <dcoutts> but that's just an optimisation
08:33:58 <dcoutts> we should make it work right first
08:34:04 <pgavin> right
08:34:37 <dcoutts> so the next layer up should be a SuffixRule or something
08:35:04 <dcoutts> and then code that takes [SuffixRule] -> [Rule]
08:35:05 <pgavin> you could go more abstract than Suffixes, though
08:35:09 <dcoutts> perhaps yes
08:35:33 <pgavin> FilePath -> Bool would work
08:35:40 <dcoutts> aye
08:35:41 <pgavin> or use regexps
08:35:51 <dcoutts> FilePath -> Bool is more general
08:35:54 <pgavin> right
08:36:14 <dcoutts> [RuleSchema] -> [SearchDir] -> IO [Rule] or something
08:36:34 <pgavin> right
08:36:35 <dcoutts> hmm, though perhaps the search dirs are different for different file types? or perhaps not.
08:36:48 <dcoutts> it's simpler if they are not
08:36:56 <pgavin> I agree
08:37:25 <pgavin> is [SearchDir] even necessary?  why not just SearchDir?
08:37:33 <dcoutts> we always have several
08:37:49 <pgavin> oh, right :)
08:37:56 <dcoutts> the user can specify several
08:38:26 <dcoutts> and furthermore, we put pre-processed files into build dirs other than the src dirs
08:38:34 <dcoutts> so we try and keep the src dirs clean
08:38:39 <dcoutts> ideally read-only
08:38:49 <pgavin> so, somehow the user can put new RuleSchemas and Rules in the Setup.hs
08:39:06 <dcoutts> later :-)
08:39:12 <pgavin> :)
08:39:23 <dcoutts> lets think about that later, when the design is clearer
08:39:27 <pgavin> right
08:39:31 <dcoutts> hmm, now this isn't enough...
08:39:34 <dcoutts> [RuleSchema] -> [SearchDir] -> IO [Rule]
08:40:02 <dcoutts> since not only do new deps appear when we convert Foo.hs.pp -> Foo.hs
08:40:11 <pgavin> well
08:40:23 <dcoutts> ie we discover that Foo.o will require Bar.hi (since Foo imports Bar)
08:40:29 <pgavin> right
08:40:35 <pgavin> but that's a dependency of Foo.o
08:40:37 <dcoutts> but if Bar was not an exposed module then we never made any Rule for it
08:40:51 <pgavin> but that's ok
08:41:02 <dcoutts> we don't know the deps for Foo.o (except Foo.hs) until Foo.hs is up to date
08:41:04 <pgavin> as long as Foo.hs gets scanned for deps after its generated
08:41:14 <dcoutts> right, so they must be interleaved
08:41:18 <pgavin> yep :)
08:41:33 <dcoutts> and the current Rule that I pasted does not allow for new Rules, just new deps
08:41:44 <dcoutts> not new Rules for building that dep
08:41:52 <dcoutts> grr
08:42:17 <pgavin> I thought about using schemas for rules, actually
08:42:23 <dcoutts> mm
08:42:27 <pgavin> I eventually decided against them
08:42:44 <dcoutts> perhaps we need to integrate them
08:42:47 <dcoutts> or alternatively...
08:43:22 <dcoutts> when the low level Rule chaser finds a dep it does not know how to build then it runs an action that tries to find out
08:43:32 <dcoutts> which might expand into more deps or might fail
08:43:53 <dcoutts> so perhaps that's just another param to the Rule interpreter
08:44:22 <dcoutts> runRules :: [Rule] -> (FilePath -> IO [Rule]) -> IO ()
08:44:24 <dcoutts> or something
08:44:32 <pgavin> did you happen to look at http://hpaste.org/2200?
08:44:47 <dcoutts> not closely, looking now..
08:45:21 <dcoutts> bear in mind that a rule has multiple targets
08:45:34 <dcoutts> eg ["Foo.o", "Foo.hi"]
08:45:39 <dcoutts> and possibly more
08:45:52 <pgavin> right
08:45:57 <dcoutts> ndm's current make code will select the best rule if there are several to make a target
08:46:05 <pgavin> umm
08:46:11 <pgavin> I think that should be an error
08:46:31 <pgavin> I mean, to have multiple ways to make a file
08:46:56 <dcoutts> eg if theres a rule to build ["Foo.o", "Foo.hi"] and another rule to build ["Foo.o", "Foo.hi, "Foo.p_o", "Foo.p_hi"] and we only want "Foo.o" then it selects the first rule
08:47:09 <pgavin> hmm
08:47:27 <dcoutts> he says a real example is .hpc files
08:47:35 <pgavin> I think things like profiling should be selected explicitly
08:47:46 <pgavin> what's .hpc?
08:48:03 <pgavin> ok, nm
08:48:04 <pgavin> found it
08:48:07 <dcoutts> when doing a build using hpc, the haskell program coverage tool, it generates an extra .hpc file
08:48:28 <b_jonas> in that case, wouldn't the .o generated differ as well?
08:48:38 <dcoutts> hmm, posibly
08:49:05 <dcoutts> I'm not sure that the overlap is all that necessary, but the fact that rules produce multiple output is essential to model
08:49:14 <pgavin> right
08:49:23 <dcoutts> for .o and .hi, and similarly for .hs and .chi outputs from c2hs
08:49:30 <pgavin> right
08:49:38 <pgavin> and _stub.[ch] and _split/*
08:49:46 <dcoutts> yes
08:49:54 <dcoutts> we can argue with ndm wether the overlap is an important issue or not
08:50:59 <dcoutts> ndm does say that it's nice, as far as is possible to find as much of the dep graph as possible before doing any building
08:51:07 <dcoutts> since it allows dry runs
08:51:20 <dcoutts> you can see what would be rebuilt
08:51:32 <dcoutts> but in some cases, we just don't know until we're part way through
08:51:47 <pgavin> right
08:52:19 <pgavin> I don't know that dry runs are very useful though :)
08:52:29 <pgavin> unless you're running patch :)
08:52:38 <b_jonas> dry runs are useful
08:52:48 <ddarius> Now there is a peek implementation so the bindings can be used for hosting plugins as well as making them.
08:53:07 <dcoutts> make has it, it's useful for debugging, it could be used to generate straight line build scripts
08:53:18 <dcoutts> dunno, perhaps it's not that essential
08:53:43 <dcoutts> interleaving dep chasing and building is essential though
08:54:01 <dcoutts> but that doesn't necessarily mean we have to integrate te dep chasing and building code though
08:56:20 <pgavin> dcoutts: you can generate straight line build scripts as a side-effect of a normal build process
08:56:29 <dcoutts> pgavin: true
08:56:48 <pgavin> in fact, I would say that's the *correct* way to do it :)
08:56:56 <b_jonas> is dry run difficult to implement though? I thought it was just not executing most commands and passing the dry-run flags to submakes
08:57:04 <pgavin> because if the build fails, the script will inevitably fail as well
08:57:27 <dcoutts> b_jonas: sometimes we need to run some pre-processors before even finding what other modules to build
08:57:28 <pgavin> b_jonas: you need to actually build stuff to find out what needs to be built
08:58:05 <b_jonas> pgavin: sure, but that just shows how dry-run is not always applicable easily
08:58:26 <b_jonas> in some simpler cases, just having a marker for commands to run even in dry run works
08:58:29 <b_jonas> but not always
08:58:52 <pgavin> b_jonas: sure, you could do that
08:59:11 <b_jonas> the problem with building build scripts is that you can't emulate -k mode, only normal, dry-run, and -i modes with it
08:59:31 <dcoutts> lets get the interleaving issue right first, that's the most important
08:59:50 <b_jonas> and -k mode is damn useful
09:00:10 <pgavin> i suppose if you had static as well as dynamically generated dependencies, you could do a pretty good dry run
09:00:42 <b_jonas> or you could do something like building some target (make dep) non-dry first
09:01:24 <b_jonas> I hacked some changes in a homemade dependency-generating makefile system once
09:01:27 <b_jonas> it was ugly
09:01:34 <b_jonas> s/changes/fixes/
09:02:06 <b_jonas> especially because I couldn't really checked whether those changes broke anything on other systems
09:02:13 <b_jonas> (it had to work on cygwin as well)
09:03:38 <pgavin> I'd like to get some kind of design doc up somewhere, so that we can get some ideas down before coding it out
09:04:04 <pgavin> maybe a wiki page somewhere
09:05:52 <b_jonas> it had the bug that when gcc -M failed, there was no rule generated so the old invalid .o file was kept and never rebuilt
09:06:33 <pgavin> b_jonas: ah, right :)
09:07:14 <ohub> Is there any place to download non-flash versions of A Taste of Haskell videos?
09:07:15 <b_jonas> I changed that by deleting the .o file at make dep time, but that's not a really good solution
09:07:38 <pgavin> b_jonas: gnu make supports deleting targets when the dependencies fail to build
09:08:03 <pgavin> b_jonas: you have to flag the targets you want deleted, though
09:09:16 <mrd> did someone piece together those haskell videos into some kind of music video montage?
09:09:47 <b_jonas> pgavin: I know, I always use that flag
09:10:08 <b_jonas> but I don't know how it would help here when the making of the rule fails
09:10:42 <pgavin> make the .o depend on the .dep file
09:10:50 <b_jonas> pgavin: yes, that could work
09:11:01 <b_jonas> (or another file made at make dep time)
09:11:06 <b_jonas> that's what I should do
09:11:07 <pgavin> right
09:11:54 <b_jonas> but that's not ideal either, because then the object is gonna be deleted at make time, isn't it?
09:13:05 <b_jonas> oh wait
09:13:08 <b_jonas> that's not a problem
09:13:22 <b_jonas> because that's what happens when compiling that object fails anyway
09:13:36 <pgavin> is it normal to have a 400MB wtmp file?
09:14:25 <desp> ohub: the links in the topic?
09:14:59 <ohub> desp: yeah, I just noticed the small texts in the corner. Thanks :)
09:15:07 <desp> :)
09:15:19 <desp> be sure to get the presentation pdf as well
09:15:42 <ohub> where's those?
09:15:52 <desp> another small link
09:16:02 <desp> otherwise it can be painful to watch, with the cameraman busily filming everything but the things SPJ is pointing to
09:16:08 <shachaf> Perhaps the topic should point to @wiki Video presentations?
09:16:13 <shachaf> @wiki Video presentations
09:16:13 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
09:16:28 <desp> ohub: click "More" to get a link to the slides
09:16:49 <desp> shachaf: yeah.
09:22:30 <njbartlett> It's actually really hard to video Simon and his slides at the same time
09:22:54 <njbartlett> He bounces all over the room, and his slides are at 12 point or something
09:23:11 <ohub> Maybe someone should edit the videos to contain slides in appropriate places
09:23:42 <ohub> but dunno, need to watch it first :)
09:24:04 <njbartlett> Yeah. I wanted to do that for the NDP video but it needs some seriously expensive, professional video software
09:25:05 <ohub> why?
09:25:28 <chessguy> ugh, i just realized that i have a fold pattern, but i have no idea which fold to choose
09:27:14 <chessguy> or if it even matters
09:27:25 <desp> when in doubt, choose foldl'
09:27:34 <augustss> when in doubt, choose foldr
09:27:42 <augustss> :)
09:27:48 <desp> depends on the doubt ;)
09:28:09 <olsner> when in doubt choose a fold
09:28:19 <augustss> foldr is better for laziness
09:28:28 <augustss> but not good for accumulation
09:28:54 <Japsu> today I played counter-strike. my nick was "fold over the headshot monad".
09:29:02 <Gwern-away> neat. by going 'setResourceLimit ResourceOpenFiles (ResourceLimits (ResourceLimit 0) (ResourceLimit 0))' in System.Posix.Resource, you can prevent yourself from doing file IO
09:29:07 <desp> groan
09:29:11 <chessguy> @seen Cale
09:29:11 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 4h 27m 18s ago.
09:29:16 <njbartlett> Japsu: Do headshots have side effects?
09:29:41 <Japsu> njbartlett: I'd guess you could classify the red splash as one.
09:29:54 <olsner> it's somewhat like error "Headshot"
09:30:07 <chessguy> Japsu, come on now, it's lunchtime here
09:30:09 <njbartlett> But how does >>= work?
09:30:22 <Japsu> chessguy: :P
09:33:14 <njbartlett> augustss: How did the last London HUG go? I've been really crap at organising them properly, since I've been out of the country for so bloody long
09:34:30 <chessguy> @tell Cale you know what would go really well with your fold diagrams is a series of questions to ask to determine which fold you need, once you've identified a fold pattern in your code
09:34:31 <lambdabot> Consider it noted.
09:34:36 <augustss> njbartlett: it was a rather small crowd, perhaps 10
09:35:12 <augustss> njbartlett: I think we need a mailing list.  I know Im not going to check the web site often enough.  maybe we already have a mailing list?
09:35:39 <njbartlett> augustss: Hmm. I shall have to do better. I'm in Japan for the rest of the month, but have deputized DrMacIver to organise the August meeting.
09:35:42 <anybody> hey a little question. is some_list !! n really of complexity O(n) ?
09:35:52 <chessguy> anybody, yes
09:35:58 <chessguy> @src (!!)
09:35:58 <lambdabot> xs     !! n | n < 0 = undefined
09:35:59 <lambdabot> []     !! _         = undefined
09:35:59 <lambdabot> (x:_)  !! 0         = x
09:35:59 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:36:03 <ddarius> @index replicate
09:36:03 <lambdabot> Data.List, Prelude
09:36:09 <augustss> njbartlett: I don't care about August, I'll be in Sweden. :)
09:36:13 <anybody> thx
09:36:27 <njbartlett> augustss: Actually Ganesh has already setup a mailing list, I just need to publicise it! I probably need to send a one-off direct email to everybody who registered for the first meet
09:36:27 <Heffalump> we have a mailing list (two, in fact)
09:36:48 <augustss> njbartlett: good idea
09:37:22 <Heffalump> the most recent blog entry on http://www.londonhug.net describes the lists
09:37:24 <lambdabot> Title: ondon HUG
09:37:57 <chessguy> heh, cute
09:38:19 <njbartlett> Got to get the lambda in somehow ;-)
09:39:36 <njbartlett> Anybody know of a decent mailmerge application (preferably for the Mac)? I really don't fancy sending out 65 emails manually
09:40:26 <Heffalump> why not just BCC?
09:40:29 <olsner> sounds like a shellscript
09:42:25 <njbartlett> IME bulk-BCC email ends up in most people's spam folders. Whereas if you send directly to the person with their name at the top it generally gets through. As long as you don't mention V14GR4
09:43:39 <wilx> :)
09:44:32 <Heffalump> 12 people or so have subscribed, so some people are paying some attention
09:45:49 <mae> what is the most hackerish thing you could possibly ever do in ghci
09:47:23 <dcoutts> mae: it'd have to involve forking threads and using the GHC api I reckon
09:48:13 <mae> hmm
09:48:27 <mae> does ghc use green threads or system threads?
09:49:04 <Gwern-away> mae: both, I think
09:49:35 <ddarius> mae: Define "hackerish".
09:49:41 <Gwern-away> I know it has lightweight erlang style threads for sure
09:49:56 <ddarius> :t (forkIO, forkOS)
09:50:00 <lambdabot> Not in scope: `forkIO'
09:50:00 <lambdabot>  
09:50:00 <lambdabot> <interactive>:1:9: Not in scope: `forkOS'
09:50:02 <njbartlett> Yup, both. Threads are lightweight, but it also is able to exploit multicores by having a number of real system threads.
09:50:42 <SamB_XP> and you can have a Haskell thread that has it's very own OS thread, too
09:51:14 <Gwern-away> SamB_XP: is that what forkOS is for?
09:51:22 <SamB_XP> in case you need to use some library that either uses TLS or just doesn't like you to call it from multiple threads
09:51:27 <SamB_XP> Gwern-away: yeah
09:51:48 <SamB_XP> (that is, some C library)
09:52:12 <b_jonas> doesn't the side-effectless nature help create efficent threads?
09:53:26 <sjanssen> well, IO actions are side effecting
09:53:26 <SamB_XP> b_jonas: hmm. some, yes. but when you do explicit threading, there actually are side-effects
09:53:39 <sjanssen> @type Control.Concurrent.forkIO
09:53:40 <njbartlett> In general you should use green threads wherever possible, and leave the number of OS threads as a configuration option. Ideally the number of OS threads should be about the same as the number of cores/CPUs on the end user's machine. Of course, nasty blocking system calls can sometimes bugger you up
09:53:41 <lambdabot> IO () -> IO GHC.Conc.ThreadId
09:53:57 <SamB_XP> I mean, it certainly helps that most data structures are immutable
09:54:06 <mauke> @index par
09:54:06 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
09:54:52 <SamB_XP> njbartlett: GHC makes extra threads sometimes to deal with blocking foreign calls
09:56:57 <b_jonas> (not that I really understand how mixed green/os threading could ever be made to work even in such a language)
09:58:28 <taruti> threads have IO-computations and thus they can mutate things.
09:58:31 <SamB_XP> b_jonas: well, the RTS makes a certain number of OS threads on which to schedule unbound Haskell threads
09:58:32 <puusorsa> how do i do this: do { rp <- realpath "."; outm $ show $ split3 (rp++"foo.bar")}  without using do, just >>= ?
09:58:47 <SamB_XP> (based on some RTS flag)
09:59:02 <mauke> @undo  do { rp <- realpath "."; outm $ show $ split3 (rp++"foo.bar")}
09:59:02 <lambdabot> realpath "." >>= \ rp -> outm $ show $ split3 (rp ++ "foo.bar")
09:59:08 <chris2> is there any AH material already online, slides or something?
09:59:20 <puusorsa> oh damn .. \thingy
09:59:21 <puusorsa> thanks
09:59:25 <puusorsa> too obvious
09:59:35 <mauke> @. pl undo  do { rp <- realpath "."; outm $ show $ split3 (rp++"foo.bar")}
09:59:36 <lambdabot> outm . show . split3 . (++ "foo.bar") =<< realpath "."
09:59:36 <ddarius> :t pokeElemOff
09:59:38 <lambdabot> Not in scope: `pokeElemOff'
09:59:46 <puusorsa> even better
09:59:49 <ddarius> :t Foreign.Storable.pokeElemOff
09:59:51 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> Int -> a -> IO ()
10:00:01 <SamB_XP> on certain foreign calls, it uses an extra OS thread for the call in case it blocks
10:00:41 <SamB_XP> when you call forkOS, it creates a Haskell thread bound to a new OS thread
10:00:46 <puusorsa> must learn to use more lambdabot features, tried pl but didn
10:00:51 <puusorsa> t know i need undo too
10:04:07 <shachaf> @pl f () -- Why does @pl do this?
10:04:07 <lambdabot> f
10:04:29 <mauke> bug
10:04:42 <mauke> @pl f 'x'
10:04:42 <lambdabot> f 'x'
10:04:52 <mauke> @pl () f
10:04:53 <lambdabot> (f)
10:05:09 <mauke> apparently it thinks () is for grouping
10:05:29 <shachaf> That's odd.
10:05:52 <Heffalump> (..) is a little weird, they are significant for n-tuples where n /= 1
10:06:39 <shachaf> @pl f (x,y,z) = x -- It would have trouble with this, right?
10:06:40 <lambdabot> (line 1, column 11):
10:06:40 <lambdabot> unexpected "="
10:06:40 <lambdabot> expecting variable, "(", operator or end of input
10:06:43 <ddarius> Hmm, my plugins work in Audacity, but they still seem to crash on unloading.
10:07:22 <anybody> hm. when i have a record Game and i want to only change one entry is there something shorter than e.g. "addPlayer p g = Game{players= p: players g,pot=pot g,board=board g,cards = cards g, gen = gen g}  " ?
10:07:35 <mauke> yes!
10:07:49 <Toxaris> Game {players = p : players g}
10:07:51 <mauke> addPlayer p g = g{ players = p : players g }
10:07:53 <shachaf> anybody: You don't need to name the parts that stay the same.
10:08:15 <anybody> shachaf: oh. neat
10:08:29 <shachaf> This does sometimes cause a problem with laziness, right?
10:08:32 <anybody> Toxaris: how does he know in your case that he should return g as game?
10:08:58 <shachaf> anybody: Toxaris may have meant g { ... }?
10:09:05 <anybody> shachaf:  ah k
10:09:18 <shachaf> Toxaris: Did you? :-)
10:09:30 <anybody> shachaf: lol
10:09:35 <Toxaris> shachaf, anybody: yes ignore me I'm talking nonsense
10:11:13 <mae> hmm.. so then nested data parallelism looks promising
10:11:27 <anybody> damn. my code just became significantly shorter ;-)
10:11:58 * ddarius didn't really change anything and it worked this time.
10:13:11 <ddarius> Now it's back...
10:13:19 <Gwern-away> kind of cirious. what does it mean to have a type sig of ':: IO t  IO t'?
10:13:36 <mauke> it could mean anything
10:13:39 <Heffalump> it means you take an IO action returning t, and you produce another IO action returning t
10:13:45 <opqdonut> :t liftM id
10:13:50 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
10:13:57 <ddarius> :t id :: IO t -> IO t
10:13:59 <lambdabot> IO t -> IO t :: forall t. IO t -> IO t
10:14:01 <Gwern-away> so if you applied liftM, any function could be passed in?
10:14:08 <opqdonut> yup
10:14:23 <SamB_XP> Heffalump: I guess we don't *have* 1-tuples for that reason...
10:14:23 <opqdonut> any pure funcition of type a->a that is :)
10:14:26 <Gwern-away> alright. that's what I thought it'd do
10:14:40 <ddarius> Gwern: It doesn't just have to be the lifting of a pure function.
10:14:51 <ddarius> There are endless possibilities.
10:15:07 <Gwern-away> oh dear. including IO?
10:15:46 <mauke> :t (?x >>)
10:15:48 <lambdabot> forall (m :: * -> *) a b. (?x::m a, Monad m) => m b -> m b
10:16:06 <ddarius> Gwern-away: (Ignoring unsafePerformIO) You aren't going to have IO happen on application any more than you do with putStr :: String -> IO (), but of course the end result can perform some IO.
10:16:12 <Saizan> ?type let formatHardDisk :: IO (); formatHaskDisk = undefined; in \x -> formatHardDisk >> x
10:16:14 <lambdabot> Not in scope: `formatHardDisk'
10:16:14 <lambdabot>  
10:16:14 <lambdabot> <interactive>:1:66: Not in scope: `formatHardDisk'
10:16:42 <Saizan> Hask :D
10:17:00 <Gwern-away> ddarius: that's too subtle for me, I'm afraid
10:17:09 <ddarius> Gwern-away: Various examples, \action -> action >> action, \_ -> putStr "Hello", \action -> putStrLn "before" >> action >> putStrLn "after"
10:17:56 <ddarius> Actually, the last two are slightly (but reparably) off.
10:19:09 <ddarius> In general, you can perform the passed in action 0 or more times, select any one of the results or none, and perform any other IO you feel like as well.
10:19:22 <ddarius> @free IO t -> IO t
10:19:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:19:28 <ddarius> @free f :: IO t -> IO t
10:19:28 <lambdabot> $map_IO g . f = f . $map_IO g
10:19:59 * Gwern-away ponders a modification of that: ':: (a1 -> t) -> IO a1 -> IO t'
10:20:24 <mauke> looks like liftM
10:20:41 <matthew-_> or fmap
10:20:46 <ddarius> Gwern-away: That has more or less exactly the same possible use cases.
10:20:54 <Gwern-away> yupzors, with an additional argument to supply to the passed=in function that liftM is lifting
10:21:09 <shachaf> @ty liftM
10:21:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:21:24 <shachaf> Looks exactly like liftM. :-)
10:21:39 <Gwern-away> but the (a1 -> t) part would seem to disallow the passedin function to surreptiously use IO functions (excepting the unsafe stuff)
10:22:03 <shachaf> Gwern-away: That's liftM.
10:22:06 <matthew-_> @type join . liftM
10:22:08 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
10:22:09 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
10:22:23 <shachaf> @ty (join .) . liftM
10:22:25 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
10:22:27 <matthew-_> @type join liftM
10:22:28 <lambdabot> forall a1. (a1 -> a1) -> a1 -> a1
10:22:46 <matthew-_> what shachaf did...
10:22:47 <Gwern-away> what's join? I don't think I've seen that one before
10:22:52 <matthew-_> @src join
10:22:52 <lambdabot> join x =  x >>= id
10:22:58 <shachaf> join = (>>= id)
10:23:14 <shachaf> m >>= f = join (fmap f m)
10:23:18 <augustss> > join (*) 5
10:23:20 <lambdabot>  25
10:23:24 <matthew-_> basically, if you have a value of type m (m a) then join'ing it takes it to m a
10:23:25 <ddarius> Parametricity does not restrict (a -> b) -> IO a -> IO b to being only liftM
10:23:37 <shachaf> For example, for [], join = concat, fmap = map.
10:23:45 <mauke> > join liftM sqrt 16
10:23:46 <lambdabot>  2.0
10:23:54 <shachaf> So l >>= f = concat (map f l) -- almost exactly the definition.
10:24:13 <matthew-_> I never like examples that rely on numbers or -> r as monads...
10:24:14 <shachaf> > join liftM id 3
10:24:16 <lambdabot>  3
10:24:16 <ddarius> :t \f m -> m >> m >>= f
10:24:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
10:24:19 <opqdonut> concatMap = concat . map
10:24:24 <shachaf> matthew-_: Numbers aren't monads.
10:24:24 <ddarius> :t \f m -> m >> m >>= return . f
10:24:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
10:24:43 <shachaf> matthew-_: And it's (r ->). What's wrong with that?
10:25:15 <ddarius> (r ->) == (->) r
10:25:34 <shachaf> ddarius: Yes, but the "->" wasn't in parentheses... :-)
10:25:48 <ddarius> Nor was the "-> r".
10:26:12 <shachaf> ddarius: That's the "->" I meant.
10:26:31 <ddarius> shachaf: I know, there was only one.
10:26:32 <hpaste>  gwern pasted "running pure function with reduced privileges, hopefully" at http://hpaste.org/2204
10:26:37 <shachaf> ddarius: "or -> r as monads" -- "->" is used as infix.
10:27:16 * Gwern-away stares at the conversation in dazzlement. I don't know what y'all and lambdabot are talking about, but it sure looks impressive
10:27:24 <shachaf> Gwern-away: Those are weird arrows in your types, they show up as question marks.
10:27:57 <Gwern-away> shachaf: unicode stuff, yes. look nice in emacs tho
10:28:08 <shachaf> @pl \f b -> limitResources >> liftM f b
10:28:08 <lambdabot> ((limitResources >>) .) . fmap
10:28:18 <shachaf> Gwern-away: And GHC accepts that?
10:28:35 <Gwern-away> shachaf: thus far. I haven't tried it on -Wall -Werror or anything
10:28:44 <matthew-_> shachaf: nothing's wrong with them. I just feel that they're not exactly ideal material for introducing monads et al
10:28:46 <Gwern-away> shachaf: you mean the unicode, or the haskell code itself?
10:28:55 <shachaf> Gwern-away: The Unicode.
10:29:25 <Gwern-away> shachaf: emacs is just changing the font on the fly - it's not actually changing the underlying ascii stuff. I'm fairly sure ghc wouldn't like it if it did that
10:29:37 <Gwern-away> you can use unicode variables, I hear, but that's about it
10:29:43 <ddarius> It shouldn't accept the code, as there seems to be several undefined identifiers.
10:30:07 <shachaf> matthew-_: They're not difficult to understand if you think of types, but introducing Reader first may be a good idea.
10:31:52 <shachaf> Gwern-away: "but  all the way to 19" -- isn't emacs  overdoing it, a little bit? :-)
10:32:06 <shachaf> (If that not sign passed through...)
10:32:22 <Gwern-away> shachaf: I find it readable!  is so much more elegant and concise than 'not'! :)
10:32:40 <Gwern-away> ddarius: what's undefined?
10:33:01 <matthew-_> bottom? ;)
10:33:34 <shachaf> Gwern-away: Sure, it's readable (though I probably wouldn't want the word to be replaced by the symbol...), but is it doing that on purpose?
10:34:15 <Gwern-away> matthew-_: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
10:34:27 <Gwern-away> shachaf: what do you mean by on purpose?
10:34:29 <matthew-_> Gwern-away: you're kidding?
10:34:29 <shachaf> Gwern-away: 1 :: a?
10:34:33 <b_jonas> lol
10:34:53 <ihope> tail [] = 1. :-)
10:34:58 <matthew-_> Gwern-away: you realise the unlikelihood of that stopping them from crashing right?
10:35:21 <Gwern-away> was joke, was joke!
10:35:29 <matthew-_> sorry, was a scary joke!
10:35:39 <chessguy> @remember Gwern actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
10:35:39 <lambdabot> Done.
10:36:01 <ddarius> halfgig and teribyte at the least
10:36:27 <Gwern-away> ddarius: aren't they defined in the where? I thought I had them there. maybe I didn't paste everything
10:37:19 <hpaste>  Gwern annotated "running pure function with reduced privileges, hopefully" with "oops. didn't copy all of it." at http://hpaste.org/2204#a1
10:37:55 <Gwern-away> yes, well you could guess what halfgig and teribyte were defined to anyway
10:38:51 <Gwern-away> interestingly, it seems that on my os, my ulimits prevent me from setting FileSize that high anyway
10:39:21 <newsham> gwern: dont you want to chroot and drop your uid too?
10:39:33 <glguy> Gwern-away: you are allowed to write: Resource(..)
10:39:42 <Gwern-away> newsham: I'm working on that. first I'm getting the resource limits straightened out
10:39:46 <glguy> Gwern-away: or Resource(ConstructorA,ConstructorB)
10:39:59 * ddarius is going to have to look at Audacity's source.
10:40:07 <Gwern-away> newsham: problem is, chroot requires root, and changing uid/gid to nobody as well
10:40:21 <Gwern-away> glguy: what do you mean?
10:40:38 <b_jonas> Gwern-away: isn't that because it won't fit in a 32-bit word or something?
10:41:10 * b_jonas checks what type rlim_t is on his system to be sure
10:41:45 <Gwern-away> b_jonas: no, I think it's because of the ulimit calls in my shell - soft is 7000000 and the hard limit 68730328
10:41:45 <glguy> Gwern-away: just that you can write: import System.Posix.Resource ( Resource(..) ) , for example
10:41:49 <glguy> instead
10:42:09 <Gwern-away> glguy: really? so that would import all of the various Resource-s?
10:42:10 <b_jonas> Gwern-away: ah yes, I should have thought of that
10:42:25 <glguy> Gwern-away: yes
10:42:33 <b_jonas> you have to ignore the error it gives in that case (the problem is that that particular errno is overloaded with something else)
10:43:56 <b_jonas> but that type is 32-bit on my system (unsigned long int on a linux-x86)
10:44:19 <Gwern-away> b_jonas: I did see an interesting email:
10:44:24 <Gwern-away> "With all the discussion about the tradeoff between physical memory size and maximum virtual memory size awhile\ back, I was surprised to find that the RLIMIT_AS (address space) limit is about 2GB, and it doesnt seem possi\
10:44:28 <Gwern-away> ble for a process to get more VM than that." <http://www.ussg.iu.edu/hypermail/linux/kernel/9903.0/0287.html>
10:44:45 <Gwern-away> they were blaming some sort of C data type for it, iirc
10:44:50 <b_jonas> Gwern-away: that would depend on how you compile your kernel I think
10:45:17 <b_jonas> on a 32-bit system where you normally have 32-bit pointers, you can't have more than 4G anyway
10:45:46 <b_jonas> and I think there's some kernel option that puts a boundary between user and kernel address space at 2G as an optimization
10:45:59 <b_jonas> and people usually had that enabled because they don't have so much memory
10:46:05 <b_jonas> (but ask on #linux to be sure)
10:47:57 <newsham> b: I think the line's at 3G typically these days.  so 3G user and 1G kernel, no?
10:48:13 <newsham> ie. stack at 0xbffffffc and kmem at 0xc0000000
10:48:46 <pejo> b_jonas, it's more book-keeping to split at 3G than 2G, and getting 4G to userspace incurs some (measurable) overhead iirc.
10:48:48 <newsham> (in linux)
10:49:14 <newsham> pejo: yah, you need special operations to copyin/copyout if you're not sharing address space
10:49:18 <xerox> ?yow
10:49:19 <lambdabot> Yow!  I just went below the poverty line!
10:49:41 <b_jonas> newsham, pejo: no idea
10:49:48 <b_jonas> I don't know linux that much
10:50:04 <newsham> oh you mean at 3G instead of 2G.  you can have no split at all if you want (all 4G for user mem) but that requires the special copyin/out stuff
10:50:24 <pejo> b_jonas, the mail you linked to is from 1999 though, lots have happened since then. (Machines with 4G isn't that uncommon, and running out of address space on 32 bit machines isn't uncommon either).
10:50:31 <newsham> at 3G vs. 2G isnt that much different.  you just cant do the simple bit check (and with 0x80000000) to measure which side of the line you're on
10:50:41 <b_jonas> pejo: Gwern linked to that
10:50:51 <pejo> Doh, sorry. Mis-attribute.
10:51:06 <newsham> pejo: yah, and who buys 32bit cpus anymore?  core 2 duo, amd64, etc...
10:51:35 <newsham> 32bit cpus are going to eol
10:51:39 <pejo> newsham, my Mac which is a little more than a year old has a 32 bit CPU. ;)
10:51:41 <olsner> they don't really make them anymore, do they?
10:51:41 <matthew-_> newsham: that's not the point - who runs 64-bit desktops is more the issue
10:51:47 <b_jonas> newsham: mine is a 64-bit too but I have it only since two months and was yet lazy to reinstall linux
10:51:53 <newsham> yah, last year was the last of the 32bit years :)
10:52:01 <b_jonas> so I'm still running the 32-bit one
10:52:09 <olsner> pejo: how old is that?
10:52:14 <newsham> matt: people who run out of address space do :)
10:52:18 <SamB_XP> newsham: does that mean that 32-bit software is going to EOL?
10:52:22 <newsham> plus you can run a 64bit OS and still support 32bit apps
10:52:33 <newsham> samb: yah, in about 15 or 20 yrs? :)
10:52:35 <pejo> olsner, you mean how long ago "little more than a year" is? 14-16 months I think.
10:52:41 <b_jonas> address space is not the only thing why you'd change to 64 bits I think
10:52:47 <SamB_XP> newsham: could be
10:52:53 <glguy> more registers
10:52:54 <newsham> bjonas: thats the compelling reason.
10:53:06 <matthew-_> newsham: it's an awful shame there is no 64-bit linux acroread, for example. Is a serious problem when wishing to install a 64-bit linux...
10:53:09 <SamB_XP> newsham: is it?
10:53:20 <newsham> people dont give up software compatibility just for wider and more registers, unfortunately.
10:53:20 <olsner> pejo: any core 2 duo cpu or forward is 64-bit, only the 64-bit support isn't used as a selling point as AMD uses it
10:53:21 <glguy> bigger Int
10:53:22 <b_jonas> glguy: exactly, and (hopefully) better instruction set as well (on x86 vs x86_64)
10:53:46 <olsner> and x86-64 is finally unsegmented!
10:53:55 <newsham> matt: you cant run 32bit linux apps in linux/amd64?  i can run normal 32bit freebsd apps in freebsd/amd64
10:53:56 <b_jonas> unluckily many people who buy pentiums don't even know if it's 64 bit
10:53:59 <pejo> I come from a Solaris perspective, but there we run 32 bit applications on a 64 bit OS quite happily. Unless you need the extra space you usually get better performance with them as well. (But sparc is less starved on registers than ia32, admittedly).
10:53:59 <b_jonas> I think
10:54:07 <newsham> (unfort ghci doesnt yet support freebsd/amd64 :(
10:54:08 <b_jonas> olsner: does that really help?
10:54:13 <matthew-_> newsham: you can. but some play more nicely than others
10:54:18 <olsner> no, but it is cleaner
10:54:44 <b_jonas> olsner: sure. especially if you have the extra registers so you don't want to do hacks with the segment registers
10:54:46 <matthew-_> newsham: the real way to do it is with chroots in 32-bit world, or with virtualisation. But such solutions introduce other pain
10:55:08 <newsham> matt: yah, i am debating installing a full 32bit system in a chroot jail.
10:55:18 <newsham> but I really would rather not :(
10:55:18 <pejo> olsner, hm? I merely stated that I bought a 32 bit Mac last year.
10:55:35 <olsner> the 32-bit support and virtualization and stuff still need the hardware for segments though, so they probably gain very little with that simplification
10:55:44 <newsham> I can just imagine installing something in it that requires a billion large dependencies and ending up with lots of duplicated large packages (liek tetex)
10:55:50 <b_jonas> in my experience, I could run 32-bit programs on a 64-bit server well, but I couldn't find documentation about how to make a cross-gcc from x86_64 to x86
10:55:56 <b_jonas> only the other way
10:56:08 <SamB_XP> b_jonas: it's the same procedure, though
10:56:12 <olsner> pejo: I'm thinking it really does have 64-bit support, only mac os isn't 64-bit until Leopard
10:56:31 <SamB_XP> you must simply use the appropriate target designation
10:56:46 <b_jonas> SamB_XP: well, you need to have the libraries too
10:56:54 <b_jonas> it's not exactly the gcc itself that's difficult
10:56:59 <SamB_XP> oh.
10:57:05 <pejo> olsner, no, those machines were later. Probably q3 or q4.
10:57:17 <olsner> too bad...
10:57:27 <newsham> b: yah, having your entire environment set up is the problem.. which is a compelling reason to install a full 32-bit set of userland in a chroot jail
10:57:47 <newsham> so far I've just been doing 32-bit builds from a vmware that I run on my desktop
10:57:57 <SamB_XP> olsner: I guess they saved some bits in operand encoding by cutting out the segment registers
10:58:04 <b_jonas> newsham: sure, but that won't get you a compiler that's running in 64-bit mode and if we belive 64-bit mode is faster than that would help
10:58:31 <olsner> 64-bit operations are just 32-bit operations with a 64-bit operand prefix... so, nothing pretty there ;-)
10:58:33 <b_jonas> SamB_XP: I doubt, because segments were always done by prefixes on x86
10:58:50 <SamB_XP> hmm.
10:58:51 <b_jonas> except for the implicit segment of a couple of instructions
10:58:51 <SamB_XP> point
10:59:07 <b_jonas> and the implicit stack segment of coutse
10:59:29 <b_jonas> otoh that could have saved a couple of 1-byte instruction places
10:59:35 <b_jonas> x86 was running out of those
11:00:21 <b_jonas> but I don't actually know anything about x86_64
11:00:22 <olsner> I'd like to go back in time and replace 8086 with some kind of RISC platform
11:00:32 <olsner> preferably 32-bit
11:00:37 <SamB_XP> hahaha
11:00:46 <b_jonas> 32-bit?
11:00:47 <sfultong> I should be able to do:
11:00:48 <b_jonas> no way
11:00:49 <sfultong> case 3 of
11:00:49 <sfultong>       n
11:00:49 <sfultong>       | n == 0 -> putStrLn "0"
11:00:49 <sfultong>       | n == 1 -> putStrLn "1"
11:00:59 <b_jonas> do you know how little memory PCs had back then?
11:00:59 <olsner> the world should sue intel for the horror of the x86 instruction set
11:01:05 <newsham> olsner: i have a feeling a $80k ibm pc desktop machine would not have been a commercial success
11:01:38 <olsner> yeah, I know, 32-bit would be impractical... let's say replace 386 with MIPS and an instruction emulator
11:01:38 <sfultong> cisc is certainly a terror rendered upon programmers
11:01:50 <newsham> transmeta?
11:01:58 <pejo> olsner, as time goes by, the % of transistors dedicated to translating the instruction set will go down, since the instruction set is fairly constant.
11:02:06 <sfultong> actually, I was thinking of transmeta... they may be an exception
11:02:53 <sfultong> but still... there must always be a better way than cisc... it violates my sensibilities
11:03:08 <b_jonas> cisc can be good I think
11:03:22 <newsham> vax and 680x0 had nice instruction sets.
11:03:22 <b_jonas> I mean, it can have a higher performance if you know how to compile to it
11:03:34 <dfranke> Weird, what is this?  I wrote a data definition deriving (Eq,Ord), and Haddock is showing me this:
11:03:34 <newsham> btw, why do you care?  how often does the iset affect you personally?
11:03:37 <dfranke> (Eq prin, ??? prin) => Eq (117PrivacyPolicy prin)
11:03:40 <dfranke> (Ord prin, ??? prin) => Ord (118PrivacyPolicy prin)
11:03:48 <olsner> the approach that apple has taken with their 68k->PPC->Intel transitions has been quite successful in rolling out the old stuff and eventually replacing it with new stuff
11:03:49 <dfranke> (meh, ignore those numbers)
11:03:58 <dfranke> Where is that ??? coming from?
11:04:10 <sfultong> newsham: ok, I guess you have a point there... although perhaps new OSes would be more prevalent without cisc
11:04:18 <newsham> people who should care are people who have to decode, simulate or model arbitrary ia32/em64_t instructions
11:04:24 <olsner> 8086->286->386->x86_64 have all failed in that respect, keeping all that legacy around
11:04:49 <b_jonas> but I wonder why 386 didn't drop some 8086/286 instructions in 32-bit mode
11:05:00 * sfultong is a supporter of slash and burn upgrading
11:05:05 <newsham> sfultong: the most expensive part of getting a new OS developed and adopted is device drivers.
11:05:08 <SamB_XP> x86_64 failed the least, in my opinion
11:05:14 <b_jonas> is there a #haskell-offtopic or something?
11:05:17 <newsham> dont think the iset affects it much
11:05:28 <sfultong> newsham: yes... and what are device drivers written in? asm, right?
11:05:36 <olsner> newsham: that does crop up from time to time... things like virtualization (hot-hot nowadays, as you surely know) need to emulate the instructions that aren't hardware-virtualized
11:05:41 <newsham> no, pretty much entirely in C.
11:05:50 <sfultong> well, with lots of asm directives
11:05:52 * SamB_XP thought they were written in MSVC++
11:06:24 <b_jonas> have you heared about this project btw: http://www.homebrewcpu.com/
11:06:26 <lambdabot> Title: Homebrew CPU Home Page
11:06:39 <newsham> yah, pretty impressive.
11:06:49 <dfranke> sfultong: you only need a little bit of ASM for basic stuff like addressing the PCI bus, and you only need to write that code once for n different drivers.  After that it's C all the way.
11:07:07 <newsham> why do you need assembly for addressing the pci bus?
11:07:20 <ddarius> b_jonas: Yes there is.
11:07:26 <SamB_XP> newsham: how do you address the PCI bus?
11:07:27 <dfranke> sfultong: look through the Linux source and see how much ASM you see.  Not very much.
11:07:33 <newsham> if its memory mapped IO you do it with normal C memory operations.  if its inb/outb, you call an inb/outb C wrapper.
11:07:38 <olsner> but then there's the boot loader, where you go through 20+ years of intel history before arriving in the present time
11:07:42 <sfultong> ah... well, I don't really know what I'm talking about :-P
11:07:51 <newsham> in fact, if your OS is half decent, it completely hides the bus access for you so that your device driver works cross platform
11:08:05 <b_jonas> ddarius: what's its name?
11:08:11 <ddarius> #haskell-blah
11:08:21 <newsham> dd: sorry.
11:08:57 <b_jonas> olsner: that's true
11:09:18 <olsner> even the friggin' A20 line is still there
11:09:30 <SamB_XP> I'd hope so
11:09:42 <b_jonas> though it's not only intel's but the pc's
11:09:55 <SamB_XP> the trouble is that it's still got that gating thing going on
11:10:05 <b_jonas> like how the bios loads only one sector of hard disks (even if it can do multiple from cd-roms)
11:10:06 <olsner> I hope there comes a time in 40-50 years when I can make loads of money by just superficially knowing about these things
11:12:53 <b_jonas> olsner: how are you imagining that?
11:13:23 <olsner> if such a time does not come, this information is useless to me ;-)
11:13:31 <b_jonas> in a circus where you do things with an IMB XT no-one would think possible?
11:14:06 <newsham> this topic should go to #haskell-blah
11:14:42 <arcatan> or #haskell-overflow
11:15:17 <b_jonas> like, does any 32-bit compiler actually emit XLAT or SAHF istructions?
11:15:32 <b_jonas> or _did_ any past 32-bit compiler do that?
11:15:46 <monochrom> IBM XT!!
11:16:10 <b_jonas> oh yeah, the PC keyboard handling has some history in it too
11:16:14 <olsner> when 386 was new, doing significant work in assembly probably wasn't uncommon
11:16:50 <b_jonas> olsner: ok, did anyone write XLAT or SAHF instructions in their assembly files apart from testing the cpu?
11:17:15 <olsner> no idea ;-) to be honest I don't even know what those instructions do
11:17:31 <ihope> What do they do?
11:17:32 <b_jonas> perhaps I should make those instructions an error in a cpu emulator and fire they system on
11:17:35 <b_jonas> :)
11:18:02 <b_jonas> ihope: XLAT is a one-byte instruction doing something like AL <- [BX+AL]
11:18:23 <b_jonas> and SAHF copies AH to the lowest byte of FLAGS
11:18:52 <b_jonas> (you sometimes needed LAHF which did the reverse for some floating-point magic)
11:19:02 <opqdonut> well i'd imagine SAHF might be used in somebody's calling conventions
11:19:06 <ihope> x86 sounds rather ugly.
11:19:18 <olsner> ihope: correct ;-)
11:19:27 <b_jonas> I belive those are remnants from before 8086, like 8080 or 4040
11:19:34 <monochrom> Very CISCy. Not RISCy at all.
11:20:00 <b_jonas> opqdonut: no, we have PUSHF and POPF for pushing the whole flag (d)word and the interrupt mechanism doing those automatically
11:20:28 <opqdonut> hmm true
11:20:35 * b_jonas checks the manual
11:21:53 <b_jonas> there's also a third one-byte instruction you rarely need inherited from 286 where by convention only instructions related to protected mode and such could be 2-byte
11:23:00 <shachaf> > s (s (k s) (s (k k) (s (k s) (s (s (k s) k) (k i))))) (k k) (,) 1 2
11:23:02 <lambdabot>  (2,1)
11:23:07 <olsner> @src s
11:23:07 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:24:53 <olsner> b_jonas: which instruction is that?
11:25:34 <b_jonas> ARPL
11:27:07 <fnord123> @k Control.Monad.State
11:27:08 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . v
11:27:32 <fnord123> @king Control.Monad.State
11:27:33 <lambdabot> Maybe you meant: kind ring
11:27:44 <fnord123> @kind Control.Monad.State
11:27:46 <lambdabot>     Not in scope: type constructor or class `Control.Monad.State'
11:28:07 <olsner> ARPL, sounds funny
11:28:25 <b_jonas> these were probably free to include in 32-bit mode if they had to support them in 16-bit as well, so they landed in the specs as well
11:28:38 <b_jonas> olsner: should I quote the manual or do you have one at you?
11:29:10 <olsner> google had the answer ;-) ARPL - Adjusted Requested Privilege Level of Selector
11:29:46 <b_jonas> I keep an old 386 programming manual and an IBM XT manual in my room
11:30:16 <b_jonas> the XT one has a full bios listing in assembly with the interface in comments
11:30:32 <olsner> yeah, I've read that one! XT Technical Reference
11:30:39 <b_jonas> it's a good one
11:30:43 <olsner> we had one with the family XT
11:31:03 <olsner> and an 8086 (or was it 8088?) assembly reference
11:31:13 <b_jonas> it also has all the circuit diagrams
11:31:23 <b_jonas> yep, there's a quick reference for assembly
11:31:59 <b_jonas> (8086 and 8088 are the same except that 8088 has a 16-bit data bus, the xt has that)
11:32:08 <olsner> *8-bit?
11:32:14 <b_jonas> yep
11:32:15 <b_jonas> 8-bit
11:32:17 <b_jonas> sorry
11:32:46 <olsner> i.e. 8088 is the budget-8086... always mix them up though
11:33:10 <b_jonas> I didn't actually use that book much because I have better 8086 programming and BIOS-call references.
11:33:22 <b_jonas> not that I used those much either
11:33:34 <b_jonas> because I'm too young for them
11:33:55 <b_jonas> I wrote only a few assembly programs on DOS
11:34:02 <olsner> knowledge in that category is things you should strive not to use, and unlearn as far as possible, IMO
11:34:28 <b_jonas> olsner: actually, knowing how a cpu (any cpu) works could help I think
11:34:41 <b_jonas> the BIOS/DOS call knowlege doesn't, I admit
11:35:13 <litb> i just calculatd factorial 200
11:35:22 <monochrom> You need it to implement new peripheral hardware and firmware for that computer.
11:35:30 <litb> is the number which is displayed right? can it really handles those numbers?
11:35:33 <litb> looks really large
11:35:35 <olsner> learn 8086 assembly -> learn how CPU:s work -> unlearn 8086 assembly
11:36:07 <ski> 680x0
11:36:17 <palgolak> hi all
11:36:21 <monochrom> Yes litb. If you see hundreds of digits, it's working fine.
11:36:42 <monochrom> > length (show (product [1..200]))
11:36:43 <lambdabot>  375
11:36:54 <monochrom> You expect 375 digits :)
11:37:07 <olsner> yeah, I guess you should really learn a lot of assembly languages to take in the difference, much as it is useful to try many paradigms of programming
11:38:05 <monochrom> If you're using ghc, it calls GMP to do the arithmetic. GMP is unlikely to be buggy for this simple task. The data transfer between GHC and GMP is unlikely to be buggy for this simple task, too.
11:38:21 <palgolak> Is there a project in need of volunteers? I've went through a couple of Haskell tutorials and would like to develop the skills.
11:39:10 <monochrom> I think all projects are.
11:39:25 <b_jonas> olsner: yeah, or better, learn how a better cpu works
11:39:53 <b_jonas> also, knowing how a video card and a crt monitor worked could have helped back when I was using SVGATextMode
11:40:12 <olsner> omniscience is the way to go, really
11:40:52 <monochrom> omniscience and abstraction is very powerful.
11:41:03 <Heffalump> dcoutts was looking for people to help with Cabal
11:41:21 <marcotmarcot> Hello.
11:41:33 <b_jonas> evalj: #":!200
11:41:33 <evalj> b_jonas: 1
11:41:59 <b_jonas> evalj: #":!200x
11:42:00 <evalj> b_jonas: 375
11:42:05 <b_jonas> yep, 375 digits
11:42:11 <opqdonut> :D
11:42:18 <palgolak> Heffalump: thanks
11:43:19 <marcotmarcot> How can I get utf-8 output in haskell? I'm editing an utf-8 teste.hs file with main = putStrLn "".  When I run it with runghc, it prints the output in iso-8859-1.
11:44:23 <Saizan> you need to convert it to uft8 octects first
11:44:32 <Saizan> ?hackage utf8-string
11:44:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
11:44:40 <sjanssen> system.io--
11:47:35 <marcotmarcot> So by default GHC works with iso-8859-1?
11:48:55 <sjanssen> marcotmarcot: not exactly
11:49:04 <litb> hmm, i don'T understand this
11:49:12 <sjanssen> by default, GHC truncates all characters to 8 bits
11:49:13 <marcotmarcot> sjanssen: So how is this defined?
11:49:15 <litb> box a b c = a * b * c
11:49:16 <marcotmarcot> hum...
11:49:21 <litb> that is the function definition i have
11:49:39 <marcotmarcot> sjanssen: but it turns '' (utf-8 in the source code) into iso-8859-1 ''.
11:49:41 <litb> how can i say that the result type has to be a String ?
11:49:45 <sjanssen> (not just by default, this is the only Char based output method supported)
11:49:56 <litb> so i can use "putStrLn box 1 2 3"
11:50:12 <litb> box a b c = a * b * c :: Int -> Int -> Int -> String
11:50:16 <litb> that does not work
11:50:52 <marcotmarcot> sjanssen: So I shouldn't use Char?
11:51:02 <monochrom> putStrLn (box 1 2 3)
11:51:10 <shachaf> monochrom: Not show?
11:51:12 <sjanssen> marcotmarcot: the situation is a bit complicated
11:51:24 <shachaf> litb: You want box a b c = show (a * b * c)
11:51:34 <marcotmarcot> =(
11:51:44 <monochrom> I only fixed the parenthesizing.
11:51:51 <shachaf> litb: And the type signature should be on its own line: box :: Int -> Int -> Int -> String
11:51:54 <sjanssen> marcotmarcot: GHC can read UTF-8 formatted files, and can handle Char (and String) literals with any Unicode code point perfectly
11:51:59 <shachaf> monochrom: Oh, never mind.
11:52:05 * shachaf missed the message above.
11:52:08 <sjanssen> marcotmarcot: you only encounter a problem when performing input or output
11:52:13 <monochrom> There are many things to fix.
11:52:31 <shachaf> litb: monochrom was also right -- you would call it in parentheses.
11:52:36 <monochrom> The Hamming distance from the original to the correct is like O((code size)^2) :)
11:53:32 * monochrom wonders why it's so hard to learn any new computer language.
11:53:34 <litb> shachaf: is it converted to a string then, automatically?
11:53:40 <marcotmarcot> sjanssen: hum... But it should be unicode, shouldn't it?
11:53:43 <shachaf> litb: No.
11:53:59 <shachaf> litb: Nothing is converted to a String automatically... Except for [Char]. :-)
11:54:12 <sjanssen> marcotmarcot: putChar takes the smallest byte of the given character and prints it.  So if you've got something greater than 255, you see truncation
11:54:22 <sjanssen> marcotmarcot: what "it" do you mean? :)
11:54:23 <monochrom> UNLEARN PERL
11:54:45 <litb> shachaf: ah, i see. the parens are to say that box is a function, and not a parameter of putStrLn  ?
11:54:48 <marcotmarcot> sjanssen: I thought that everything in haskell standard was suposed to be utf-8.
11:54:57 <sjanssen> marcotmarcot: no, everything is Unicode
11:55:05 <shachaf> litb: Yes.
11:55:12 <xerox> What's a good paper to read about implementing monad transfomers? I'm finding it a quite difficult business.
11:55:14 <sjanssen> UTF-8 is an encoding, a way to turn Unicode characters in to bytes
11:55:14 <shachaf> f x y = (f x) y
11:55:29 <sjanssen> Unicode is the standard that specifies what these characters are
11:55:42 <shachaf> xerox: Try looking at the mtl source?
11:55:44 <marcotmarcot> sjanssen: hum... I didn't know about that difference very much.
11:56:19 <shachaf> xerox: What transformer are you trying to make?
11:56:23 <sfultong> Anyone ever wish for a function split :: a -> (a -> b) -> (a -> c) -> (b -> c -> d) -> d?
11:56:28 <monochrom> xerox: perhaps the original monad transformer paper? I don't know, I haven't read it, but I learned it without reading anything.
11:56:29 <marcotmarcot> sjanssen: but is this in the standard or is just the ghc implementation?
11:56:44 <xerox> shachaf: I am reimplementing mtl transformers to spot the pattern.
11:57:09 <ihope> @djinn a -> (a -> b) -> (a -> c) -> (b -> c -> d) -> d
11:57:10 <lambdabot> f a b c d = d (b a) (c a)
11:57:19 <xerox> monochrom: do you remember its title?
11:57:27 <monochrom> No.
11:57:31 <sjanssen> marcotmarcot: the standard says that Haskell strings are Unicode, but the behavior of the IO routines isn't specified
11:57:38 <DRMacIver> monochrom: Is it? I've never noticed.
11:57:51 <DRMacIver> (hard to learn new programming languages)
11:57:57 <marcotmarcot> sjanssen: and in GHC it's converting from utf-8 to iso-8859-1?
11:58:10 <sjanssen> marcotmarcot: that's not quite accurate
11:58:26 <xerox> shachaf: by the way, the overall project goal is to write the Parsec monad transformer.
11:58:47 <sfultong> @pl (\a b c d -> d (b a) (c a))
11:58:48 <lambdabot> ap (flip . (((.) . flip . flip id) .) . flip id) (flip id)
11:58:49 <marcotmarcot> sjanssen: it's strange cause in GHCi it putStrLn "" works.
11:58:55 <marcotmarcot> sjanssen: but not in runhaskell.
11:59:09 <shachaf> xerox: Oh, right, you're Paolo.
11:59:30 <sjanssen> marcotmarcot: that's probably some strange interaction with readline
11:59:46 <monochrom> DRMacIver: I'm observing other people, not you and me, struggling, e.g., the edit distance from their attempted writing to the closest correct writing is like may-as-well-completely-rewrite.
11:59:50 <marcotmarcot> runhugs also work.
12:00:01 <ivant> marcotmarcot, which version of ghc are you using? is it 6.6?
12:00:27 <dcoutts> hia xerox :-)
12:00:43 <marcotmarcot> ivant: Yes.
12:01:12 <ivant> marcotmarcot, ghc 6.6 assumes that your source files are in utf8, that may be the problem with 
12:01:15 <sfultong> >let split = (\a b c d -> d (b a) (c a))
12:01:19 <sfultong> > let split = (\a b c d -> d (b a) (c a))
12:01:20 <lambdabot>  Parse error
12:02:00 <DRMacIver> monochrom: Maybe the problem is that learning new languages isn't hard enough?
12:02:03 <ivant> marcotmarcot, i.e., if your file is in some other encoding, you'd have problems with getting unicode characters parsed correctly
12:02:04 <sfultong> ... parse error? what obvious thing am I missing here
12:02:08 <marcotmarcot> ivant: It happens the same with 
12:02:24 <marcotmarcot> ivant: My whole system is utf-8
12:02:35 <litb> so, how can i convert the return value of box to a string?
12:02:36 <sfultong> > let split = ap (flip . (((.) . flip . flip id) .) . flip id) (flip id)
12:02:37 <lambdabot>  Parse error
12:02:44 <monochrom> Sounds interesting. How do you mean?
12:02:44 <shachaf> @source Control.Monad.Reader
12:02:44 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
12:03:24 <doserj> sfultong: let ... *in* ...
12:03:31 <marcotmarcot> It's very strange for me that it works with ghci but not with runhaskell.
12:03:32 <ivant> @index get
12:03:33 <lambdabot> Control.Monad.State, Control.Monad.RWS, Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.ParserCombinators.ReadP, Distribution.
12:03:33 <lambdabot> Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
12:03:36 <marcotmarcot> And that it works in Hugs.
12:03:49 <sfultong> doserj: oops, I was in ghci mode
12:03:50 <marcotmarcot> And that in runghc it converts from utf-8 to iso-8859-1
12:04:07 <DRMacIver> monochrom: I'm not entirely sure. But I've often observed that making things harder can cause them to be more tractable. If something is easy, it's usually because you already know how to do it. If you already know how to do it, you have preconceptions which get in your way.
12:04:23 <marcotmarcot> With ghc (compiler) it don't work also.
12:04:29 <doserj> sfultong, you can try @let
12:04:40 <sfultong> > let split = (\a b c d -> d (b a) (c a)) in split (,) (-1) (+1) 4
12:04:41 <lambdabot>        add an instance declaration for
12:04:42 <lambdabot>       (Num (t -> (a -> b -> (a, b)) ->...
12:04:45 <sjanssen> marcotmarcot: yes, in this case we happen to get "" represented in IO-8859-1
12:05:11 <sfultong> doserj: ahh, thanks... I knew there was a way
12:05:16 <marcotmarcot> sjanssen: but why when it's run with ghci (let main = putStrLn ""; main) it doesn't convert it?
12:05:46 <xerox> Hello dcoutts :)
12:05:55 <sjanssen> marcotmarcot: on my system, GHCI outputs the same thing as runghc
12:06:15 <sjanssen> marcotmarcot: GHC uses the readline library, perhaps it is changing some of your terminal's settings
12:06:58 <monochrom> That does not explain why people struggle with Haskell, a language that is a clean break from other computer languages. However, I can also offer a way out: people preconceive Haskell to be "just another computer language", and so they are tricked. If you sold it as "the mother tongue of Martians", perhaps they'll actually pick it up comfortably. :)
12:07:28 <sfultong> @et split = (\a b c d -> a (b d) (c ad)
12:07:28 <lambdabot> Maybe you meant: ft let
12:07:34 <sfultong> @et split = (\a b c d -> a (b d) (c ad))
12:07:34 <lambdabot> Maybe you meant: ft let
12:07:39 <sfultong> @let split = (\a b c d -> a (b d) (c ad))
12:07:40 <lambdabot> <local>:20:26:     Ambiguous occurrence `split'     It could refer to either ...
12:07:43 <marcotmarcot> sjanssen: even when I run ghci > output it outputs only utf-8 characters.
12:07:59 <sjanssen> marcotmarcot: how do you know that they're UTF-8 characters?
12:08:01 <sfultong> @let sfun = (\a b c d -> a (b d) (c ad))
12:08:02 <lambdabot> <local>:22:31: Not in scope: `ad'
12:08:05 <sfultong> @let sfun = (\a b c d -> a (b d) (c a d))
12:08:07 <mrd> DRMacIver: that sounds like the advice about proofs "if you are having trouble proving a theorem, try to prove something stronger"
12:08:12 <lambdabot> Defined.
12:08:24 <marcotmarcot> sjanssen: I'm using file -i
12:08:26 <sfultong> > sfun (,) (+1) (-1) 0
12:08:27 <lambdabot>        add an instance declaration for
12:08:28 <lambdabot>       (Num ((t -> t2 -> (t, t2)) -> t ...
12:08:35 <sfultong> > sfun (,) (+1) (*2) 0
12:08:36 <lambdabot>      Occurs check: cannot construct the infinite type:
12:08:36 <lambdabot>       t2 = t2 -> (t, t...
12:08:48 <marcotmarcot> sjanssen: when I run with runghc, file -i returns iso-8859-1 file, when I run with ghci, utf-8.
12:08:57 <DRMacIver> mrd: Probably, yes. That's always been my strategy. :)
12:09:14 <sorear> .
12:09:25 <xerox> > ((+1) &&& (*2)) 0 -- sfultong ?
12:09:26 <lambdabot>  (1,0)
12:09:29 <sorear> Sun Jul 29 04:53:47 PDT 2007  Ian Lynagh <igloo@earth.li> * bytestring is now in its own package
12:09:32 <sorear> yay.
12:09:38 <monochrom> If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
12:10:07 <monochrom> or is to algebraic topology? I forgot.
12:10:12 <monochrom> s/to/it/
12:10:18 <sfultong> xerox: what class is &&& from?
12:10:19 <sorear> Abstract algebra would probably be more useful.
12:10:20 <xerox> There exists both.
12:10:33 <mrd> group theory
12:10:39 <mrd> why not
12:10:43 <monochrom> No, sorear, I'm trying to say "category theory" without those exact two words. :)
12:10:45 <mrd> sfultong: Arrow
12:10:46 <xerox> sfultong: it is an Arrow combinator, used in its (->) instance.
12:10:48 <sfultong> xerox: and yes, that seems what I'm looking for
12:10:50 <sfultong> thanks
12:11:01 <marcotmarcot> And I can't use hugs cause I want to use Text.XHtml.Strict
12:11:06 <xerox> sfultong: check out all of that instance, it has got useful combinators.
12:11:30 <litb> isn't there a toStr(Int) or something ?
12:11:43 <mauke> > show 42
12:11:45 <lambdabot>  "42"
12:11:58 <litb> but it prints it out
12:12:03 <mauke> no, it doesn't
12:12:03 <shachaf> litb: No.
12:12:07 <shachaf> @ty show
12:12:08 <litb> hmm, ok
12:12:09 <lambdabot> forall a. (Show a) => a -> String
12:12:11 <sfultong> (read :: Int) "5"
12:12:13 <monochrom> that's the REPL printing it out.
12:12:13 <sfultong> > (read :: Int) "5"
12:12:14 <lambdabot>  Couldn't match expected type `Int'
12:12:26 <mauke> > read "5" :: Int
12:12:28 <lambdabot>  5
12:12:29 <litb> then ghci confused me
12:12:38 <monochrom> ghci is a REPL.
12:12:44 <sorear> marcotmarcot: For now, you can use the 'utf8-string' package from Hackage
12:12:44 <shachaf> litb: Why? Does it confuse you when you type "1 + 1"?
12:12:55 <monochrom> All REPL must be confusing.
12:12:58 <shachaf> litb: Because it prints the answer out?
12:13:07 <monochrom> I recommend learning all languages without REPLs.
12:13:13 <litb> because i cannot seem to differentiate a print-out and a return from a function
12:13:14 <marcotmarcot> sorear: It makes things very much more complicated.
12:13:21 <litb> monochrom: REPL ?
12:13:25 <monochrom> Yes, that's the problem wth REPLs.
12:13:28 <shachaf> litb: Look at the type. :-)
12:13:38 <DRMacIver> monochrom: ML totally spoiled me there. :)
12:13:41 <xerox> litb: yes, be careful, it prints out values of type (Show a) => a as well as (Show a) => IO a.
12:13:44 <reltuk> :set +t
12:13:46 <mauke> (loop (print (eval (read))))
12:13:55 <shachaf> litb: If it doesn't end with IO something, it won't print.
12:13:57 <DRMacIver> monochrom: When I first came to Haskell I was very confused because none of the code examples worked when I typed them into the REPL...
12:14:00 <sorear> marcotmarcot: How so?  I'm sure glguy would like to know.
12:14:04 <sorear> @time glguy
12:14:05 <lambdabot> Local time for glguy is Sat Aug 11 17:34:35 2007
12:14:13 <reltuk> @time lambdabot
12:14:13 <lambdabot> I live on the internet, do you expect me to have a local time?
12:14:31 <litb> shachaf: the IO type is always printed in screen immediately if it is constructed?
12:14:31 <shachaf> @localtime dons
12:14:32 <lambdabot> Local time for dons is Mon Aug 13 05:13:55 2007
12:14:42 <sfultong> @localtime sfultong
12:14:43 <lambdabot> Local time for sfultong is Sun Aug 12 15:14:08
12:14:45 <monochrom> It's the same problem with Perl or Python or Ruby or ...
12:14:51 <shachaf> litb: No, IO means that it can print.
12:14:54 <nautican> layout causes part of the problem
12:14:58 <sorear> "Cabal now depends on teh containers package"
12:15:11 <monochrom> "I type in 1+1 and it prints the answer out. I don't want printing. I just want to return the answer."
12:15:17 <mrd> heh
12:15:34 <mrd> REPLs aren't useful for learning because of a simple newbie mistake which gets corrected easily?
12:15:36 <monochrom> I'm not mocking you. I'm saying REPLs are evil.
12:15:54 <shachaf> Perhaps show is a somewhat ambiguous name.
12:15:54 <b_jonas> monochrom: but then you have to learn about IO before you could use the REPL
12:16:04 <sorear> How can you have a rePl without printing?
12:16:16 <monochrom> I actually side with Dijkstra on learning programming. He says you don't even want to execute your programs on a computer at all.
12:16:26 <sjanssen> REL
12:16:38 <monochrom> REL = /dev/null :)
12:16:40 * ibid learned programming by that method
12:16:40 <litb> monochrom: wft is REPL?
12:16:52 <monochrom> I think someone answered that?
12:16:54 <chessguy> @go wikipedia REPL
12:16:56 <lambdabot> http://en.wikipedia.org/wiki/REPL
12:16:56 <lambdabot> Title: Read-eval-print loop - Wikipedia, the free encyclopedia
12:17:02 <ibid> though i didn't even know dijkstra then
12:17:08 <marcotmarcot> sorear: I'll have to enconde and decode...
12:17:10 <b_jonas> sjanssen: well, that's what a unix shell does until you add the exit code to the prompt
12:17:18 <sorear> marcotmarcot: Really?
12:17:19 <nautican> basically, a repl is an interactive interpreter
12:17:28 <marcotmarcot> sorear: I just wanted to understand why it works in hugs and in ghci but not in runghc and ghc.
12:17:30 <sorear> marcotmarcot: Why can't you just use System.IO.UTF8.print etc?
12:17:36 <litb> ok, another question
12:17:45 <reltuk> whether REPLs are good for learning programming is a different question than whether they are good for learning a programming language or for writing a piece of software
12:17:55 <reltuk> s/writing/helping to write/
12:17:56 <nautican> I like them for debugging
12:17:58 <litb> if the last statement of my function is not an expression, how can i fix that?
12:18:08 <marcotmarcot> sorear: hum, I haven't seen that, it makes things simplier.
12:18:10 <mrd> monochrom: it's difficult to learn without feedback
12:18:22 <mrd> monochrom: running your program on a computer is excellent feedback
12:18:28 <monochrom> Presumably there is a teacher giving feedback.
12:18:31 <litb> because i have that main function, and wanted to define a res variable at the end of it, just to see whether it works
12:18:35 <b_jonas> I like repls (and evalbots)
12:18:43 <litb> now, ghc complains that the last thing must be an expression.
12:18:52 <mrd> monochrom: then you are running your program on the teacher ;)
12:19:00 <marcotmarcot> But still I'm a bit confused with what ghc is doing.
12:19:11 <chessguy> litb, can you @paste your code?
12:19:13 <b_jonas> though I sometimes use the shell as a rel instead, running commands with name-of-programming-language -e 'expression' instead
12:19:14 <chessguy> @paste
12:19:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:19:17 <marcotmarcot> The strangest thing for me is the different results from ghc and ghci.
12:19:19 <monochrom> You write the program and you also write down invariants and assertions and efficiency arguments. The teacher then comment on correctness as well as simplicity and elegance.
12:19:22 <mrd> but yea -- that kind of opinion is ridiculous to someone like me, who learned pretty much all programming without any human interaction
12:19:23 <sorear> marcotmarcot: Because the GHC runtime (used by compiled GHC programs) doesn't support UTF8 I/O.  GHC itself has a work-around, which is why you don't notice in GHCi.  Hugs completely supports UTF8 IO.
12:19:46 <sfultong> >  fmap (+1) (3,4)
12:19:49 <shachaf> The Little Schemer does that (it's entirely on paper, written in a question-and-answer style).
12:19:52 <lambdabot>  (3,5)
12:19:55 <monochrom> Yes, mrd, run it on a teacher, not on a computer.
12:19:57 <marcotmarcot> sorear: and why can't I use this work-around in my GHC programs?
12:19:58 <hpaste>  litb pasted "error" at http://hpaste.org/2207
12:20:07 <wolverian> has anyone looked at generating haskell types from XML schemas, e.g. with XSD?
12:20:25 <mrd> monochrom: the fact is, there aren't enough teachers to make that work -- much less qualified ones willing to teach kids
12:20:27 <monochrom> I can see there is a way to computerize the teacher.
12:20:29 <shachaf> litb: You can't have <- or let at the end of a do block.
12:20:32 <sorear> marcotmarcot: You can.  utf8-string contains a copy of it.
12:20:35 <sfultong> silly me... I just realized that (,) was isomorphic to Either
12:20:43 <chessguy> litb, just put another line: return ()
12:20:47 <sorear> sfultong: not quite
12:20:56 <sfultong> what's different?
12:21:01 <litb> chessguy: ah, ok. thanks
12:21:02 <shachaf> chessguy: No point, if the let isn't used anyway.
12:21:06 <shapr> SHAZAM!
12:21:07 <sorear> sfultong: one is a product, the other is a sum
12:21:09 <litb> but i need that do block. or?
12:21:16 <reltuk> mrd: I think the point might be that there is value in actually working through the execution of a program yourself, without going to the computer immediately and seeing what the result is
12:21:21 <marcotmarcot> sorear: hum... thanks.
12:21:25 <chessguy> shachaf, he just wants it to compile, he knows he's not going to use it
12:21:26 <litb> is it some kind if iterative construct?
12:21:28 <sorear> sfultong: (,) Bool Bool has 10 inhabitants.  Either Bool Bool has only 7.
12:21:31 <reltuk> knuth has similar thoughts on the study of algorithms and the likes
12:21:33 <litb> err, imperative
12:21:51 <mrd> of course.  computer code is pretty irrelevant to that.
12:21:51 <sfultong> sorear: oops, right...
12:21:52 <shachaf> litb: box's type should be ... -> String.
12:22:00 <monochrom> Sorry, I'm great at starting controversies. :)
12:22:03 <shachaf> litb: (Types usually go above definitions, by the way.)
12:22:12 <cognominal_> I am trying to build lambdabot and I get Setup.hs: cannot satisfy dependency plugins>=1.0
12:22:14 <litb> shachaf: yes, i already corrected it
12:22:24 <cognominal_> what do I need?
12:22:32 <shachaf> litb: Do-notation is just syntax sugar.
12:22:33 <sorear> cognominal_: hs-plugins
12:22:33 <monochrom> You need oxygen.
12:22:38 <sorear> @where hs-plugins
12:22:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:22:43 <litb> shachaf: actually, i didn'T wanted to paste it that fast. but when i found the error, i alread pasted =)
12:22:54 <sfultong> @where love
12:22:55 <lambdabot> I know nothing about love.
12:22:57 <cognominal_> monochrom: I know that :)
12:23:02 <mrd> @where honor
12:23:02 <lambdabot> I know nothing about honor.
12:23:19 <litb> shachaf: ah, i don'T need that do ?
12:23:28 <monochrom> Sorry, I'm great at starting controversies and stating tautologies. I cover the full spectrum. :)
12:23:45 <shachaf> litb: You do, probably.
12:23:56 <sorear> cognominal_: notes: 1. lambdabot 4.0 is hopelessly obsolete  2. you need darcs hs-plugins for GHC 6.6.x, the released version won't do  3. the darcs hs-plugins is not compatible with GHC 6.4.x, you'll need the released version
12:24:01 <shapr> @where shapr
12:24:01 <lambdabot> http://www.ScannedInAvian.com/hope
12:24:02 <shapr> oooh
12:24:09 <chessguy> litb, yes, you do, unless you want to re-write it much more messily
12:24:10 <mrd> @remember lambdabot I know nothing about love.
12:24:10 <lambdabot> Done.
12:24:14 <shachaf> litb: However, when you let ... or ... <- ..., you need to have something afterwards.
12:24:22 <desp> hmm
12:24:44 <desp> any ideas why Data.Graph.topSort includes unreachable vertices in the resulting list?
12:24:44 <shachaf> litb: It can't be the last "statement" in a do block.
12:25:10 <litb> shachaf: i see
12:25:59 <shachaf> litb: Which tutorial/book are you using?
12:26:04 <mrd> monochrom: that style of learning works well for mathematically minded folks like Dijkstra, but for the rest of us, we like flashing lights and bells and whistles
12:26:10 <chessguy> litb, shachaf's point is that it's because of how the do block translates. it's a shortcut for something more complex, and if you don't have the right thing at the end of the block, the complex thing doesn't make sense
12:26:16 <ddarius> desp: Shouldn't it?
12:26:25 <sorear> desp: it was probably motivated by the main use of topological sorting, which is to say writing Haskell typecheckers; you want to type-check a definition even if it isn't used
12:26:34 <desp> ah.
12:27:08 <monochrom> Don't leave out the unreachable :)
12:27:48 <desp> they're doomed anyway :)
12:28:05 <DRMacIver> monochrom: Back on the earlier point (as I missed your response before), my point is that although Haskell is a radically different way of doing things than people are used to, they're often using it to do the same things.
12:28:14 <arcatan> hi shapr
12:28:22 <shapr> hiya arcatan
12:28:24 <monochrom> Yes DRMacIver absolutely.
12:29:19 <ddarius> They should be using it to do the same things.
12:29:21 <DRMacIver> And I think that's what causes a lot of the cognitive dissonance. Which is I guess what you meant in your point about martians. :)
12:29:42 <litb> shachaf: i used the wikiboox and the 10 minutes tutorial
12:29:44 <DRMacIver> ddarius: I'm not exactly saying that it's a bad thing to do. I'm merely observing that the familiarity can cause problems.
12:29:47 <monochrom> You have to say something like "Haskell is not for programming! Haskell is for the games Martian kids play!"
12:29:52 <litb> but i find that the wikibook does not what it claims it does
12:30:12 <litb> i cannot find informations such as "how to convert strings to numbers"
12:30:35 <shachaf> litb: That's probably not important yet.
12:30:49 <chessguy> @hoogle Num a => String -> a
12:30:53 <lambdabot> Prelude.error :: String -> a
12:30:53 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:30:53 <lambdabot> Prelude.fail :: Monad m => String -> m a
12:31:02 <shachaf> litb: You want to learn the basics of how things work first, probably.
12:31:09 <chessguy> @type read
12:31:14 <lambdabot> forall a. (Read a) => String -> a
12:31:15 <shachaf> litb: (It's read, though.)
12:31:32 <shachaf> @hoogle String -> a
12:31:33 <lambdabot> Prelude.error :: String -> a
12:31:33 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:31:34 <lambdabot> Prelude.fail :: Monad m => String -> m a
12:31:36 <shachaf> @hoogle+
12:31:36 <lambdabot> Prelude.read :: Read a => String -> a
12:31:38 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
12:31:40 <lambdabot> Control.Monad.Error.strMsg :: Error a => String -> a
12:32:14 <mrd> monochrom: and then people will say "well, screw the games Martian kids play.  I'm learning C# so I can become a Microsoft shill"
12:32:37 <sorear> mrd: Do we really care about those people?
12:32:40 <monochrom> May be better off for everyone.
12:32:43 <desp> @pl reachableVertices g = filter (\v -> (not . null . reachable g) v) (vertices g)
12:32:43 <lambdabot> reachableVertices = ap (filter . ((not . null) .) . reachable) vertices
12:33:05 <desp> @pl (\v -> (not . null . reachable g) v)
12:33:06 <lambdabot> not . null . reachable g
12:33:08 <SamB> > approxRational 0.4 pi
12:33:09 <lambdabot>  0%1
12:33:12 <litb> > read("12")
12:33:14 <lambdabot>  12
12:33:19 <litb> ah, great
12:33:20 <mrd> > approxRational pi 0.4
12:33:21 <lambdabot>  3%1
12:33:24 <SamB> oh.
12:33:27 <SamB> no wonder...
12:33:30 <mrd> yea it confused me the other day too
12:33:32 <desp> oh, right.
12:33:34 <sorear> > approxRational pi 0.0001
12:33:36 <lambdabot>  333%106
12:33:41 <shachaf> litb: You should probably not use that syntax, by the way.
12:33:46 <oncenull> > (+) 3 4
12:33:47 <lambdabot>  7
12:33:50 <SamB> they put the arguments in the wrong order!
12:33:54 <shachaf> litb: You call functions with a space, not with parentheses.
12:34:11 <mrd> sorear: i don't know. some people might.
12:34:13 <shachaf> > read "12"
12:34:14 <lambdabot>  12
12:35:09 <litb> alright
12:35:17 <monochrom> C# is getting better.
12:35:19 <b_jonas> parenthesis around the whole call, isn't it?
12:35:30 <mrd> if you want Haskell to be less popular, you should tell Simon to stop being so good at promoting it
12:35:41 <litb> shachaf: but if i remove () from show(a * b * c) i get an error
12:35:43 <shachaf> b_jonas: They aren't required like in LISP. :-)
12:35:54 <desegnis> b_jonas, parentheses in Haskell are just for grouping, and for tuples
12:35:58 <mauke> litb: precedence
12:35:59 <b_jonas> shachaf: yeah, I know. haskell has $ and stuff.
12:36:08 <desegnis> b_jonas, and for sections, I should add
12:36:13 <mauke> litb: function application binds tighter than *
12:36:16 <shachaf> b_jonas: No, I mean, you can say "f a b" instead of "(f a b)".
12:36:18 <desp> hg.
12:36:22 <desp> wrong.
12:36:32 <b_jonas> shachaf: sure
12:36:40 <shachaf> b_jonas: As desegnis said, parentheses are just for grouping, tuples, and sections.
12:36:51 <osfameron> and for disambiguating negative numbers
12:36:51 <b_jonas> yes, I know
12:36:54 <shachaf> b_jonas: Unlike LISP, they don't *apply* the function.
12:37:14 <b_jonas> only... if you use only function calls and no other syntax, it gets similar to that
12:37:14 <monochrom> All is not lost. More and more blogs are noting that Haskell is a paradigm shift. People will understand.
12:37:15 <litb> ah, makes sense
12:37:16 <ddarius> litb: It's common in Haskell to write show (a * b * c) rather than show(a * b * c); it's more consistent.
12:37:20 <desegnis> osfameron, which I hate when bitten by (- x) not being a section
12:37:33 <b_jonas> I know that it's not actually doing the call
12:37:33 <shachaf> b_jonas: Well, not, functions are curried.
12:37:33 <osfameron> and for describing the types of functions arguments in type signatures...
12:37:45 <b_jonas> shachaf: yep, I know that too
12:37:48 <shachaf> b_jonas: Imagine "(((f a) b) c)".
12:37:52 <osfameron> desegnis: yeah, it's the worst of both worlds
12:37:53 <litb> i'm getting to it, slowly
12:38:08 <shachaf> osfameron: That's grouping, no?
12:38:45 <b_jonas> actually, even my translator (http://www.math.bme.hu/~ambrus/pu/olvashato/) omits (most) unneccessary parenthesis in its output, it doesn't put one for every call
12:38:47 <lambdabot> Title: Olvashato compiler
12:39:50 <b_jonas> though you don't actually see that much because of the lots of tuples used (instead of curried functions)
12:40:06 <osfameron> shachaf: oh, I suppose it could be - I modelled that as something different
12:42:38 <shachaf> > (s (k s) k) (+1) (*2) 5
12:42:39 <lambdabot>  11
12:42:46 <b_jonas> hmm, I'm wrong
12:42:57 <b_jonas> it actually seems to output a parenthesis for every function call...
12:43:31 <mauke> > (ap (const ap) const) (+1) (*2) 5
12:43:33 <lambdabot>  11
12:43:55 <b_jonas> even when it's clearly unneccesary
12:44:00 <b_jonas> oh well
12:48:22 <zekus_> hello everybody
12:48:44 <desegnis> Just reading about zippers on the wiki: using Tree (Maybe a) instead of Tree (Maybe a). hm, am I missing something? :)
12:49:16 <desegnis> http://www.haskell.org/haskellwiki/Zipper
12:49:17 <lambdabot> Title: Zipper - HaskellWiki
12:49:32 <zekus_> i'm trying to install gtk2hs but at the ende of the make command it gives an error: c2hsLocal: gtkmozembed.h: File does not exist
12:49:32 <sorear> zekus_: hello!
12:49:45 <arcatan> hello somebody!
12:49:46 <zekus_> i am on linux platform
12:50:13 <sorear> zekus_: ooh.  ./configure reported that you have mozembed?
12:50:19 <desegnis> zekus, strange, ./configure should already state it if you don't have mozembed
12:50:31 <chessguy> desegnis, what is your queston?
12:50:43 <zekus_> sorear: yes it is
12:50:52 <sorear> zekus_: maybe it could be made to work by passing --without-mozembed to ./configure
12:50:55 <chessguy> desegnis, oh, i see now
12:50:58 <zekus_> only sourceview and documentation is "no"
12:51:02 <desegnis> chessguy, I'm wondering what the difference between Tree (Maybe a) and Tree (Maybe a) is
12:51:11 <sorear> zekus_: but even if you can make it work, definitely report this to dcoutts when he wakes up
12:51:16 <mauke> desegnis: the second one should be Tree a
12:51:24 <zekus_> sorear: does it cause any problems later?
12:51:31 <desegnis> mauke, thanks
12:51:48 <sorear> zekus_: No, it will just mean you can't use mozembed
12:52:17 <sorear> zekus_: Which isn't a terrible loss, if you've ever seen mozembed in action you'll know why :)
12:52:33 <zekus_> sorear: i did not see it before.
12:52:45 <chessguy> mauke, darn you, i knew that one!
12:52:49 <sorear> zekus_: more evidence you won't miss it
12:52:51 <zekus_> sorear: is it about the old mozilla look and feel
12:53:06 <zekus_> ?? if so really not very impressive
12:53:10 <sorear> zekus_: no, it's about running a web browser inside your program
12:53:17 <desegnis> chessguy, mauke; I still don't see what exactly that sentence is telling me; but I understand the idea of the context, so this does not matter
12:53:17 <litb> is there a gui toolkit for haskell?
12:53:27 <sorear> zekus_: which makes your program leak memory just as badly as FF itself
12:53:27 <zekus_> sorear: oo not a big loss really
12:53:54 <sorear> litb: Yes, there are at least ten.
12:53:55 <mauke> desegnis: it means you could represent trees with holes in them by using Tree (Maybe a) instead of Tree a
12:54:02 <chessguy> desegnis, the point is, that you could look at that diagram and say "but why not just use Tree (Maybe a) instead of Tree a", but that pisses the point that the hole should be unique
12:54:08 <chessguy> uh, misses
12:54:19 <zekus_> sorear: do you think gtk2hs is a good choice against wxHaskell or something about Tcl/Tk
12:54:41 <chessguy> desegnis, it's worded pretty poorly
12:54:56 <sorear> zekus_: gtk2hs is a pretty good choice these days.  it works pretty well for me, it's mature and stable
12:55:21 <desegnis> mauke, chessguy; yes, both of you made it perfectly clear, while the text does not
12:55:25 <sorear> zekus_: I've never tried wxHaskell but (blub paradox, I know) I can't imagine it being significantly better
12:55:27 <litb> wow, wxHaskell!! is it working good?
12:55:53 * SamB 's seen mozembed in action ... from Haskell code ... made him wish for XPCOM bindings :-(
12:56:41 <desegnis> mauke, chessguy; best to simply remove that sentence, so nobody has to be confused as I've been
12:57:11 <chessguy> desegnis, well, it does make a good point, even if it does so unclearly. i'll do some copy editing on it
12:58:31 <desegnis> chessguy, splendid
12:59:24 <Korollary> litb: I'd search the mailing list for that because I remember something about wxhaskell having compile problems. I believe gtkhs has no problems. There are also others if you look at haskell.org libraries page.
13:00:58 <chessguy> desegnis, ok, refresh and see if it's clearer now
13:03:00 <desegnis> chessguy, I still find the instead a little confusing. it sounds as if Tree a was a good representation of a context
13:03:05 <zekus_> sorear: this it gives c2hsLocal: gtkmozembed.h: File does not exist
13:03:16 <zekus_> should i use a without option for this too?
13:03:29 <chessguy> ok
13:04:24 <anybody> hm. is it not possible to have 'where' inside a lambda expression?
13:04:42 <shachaf> anybody: No.
13:04:48 <anybody> shachaf: why not=
13:04:49 <anybody> ?
13:04:53 <desegnis> chessguy, maybe sth. along the lines of: ... Tree (Maybe a), where the hole is represented by Nothing. However, this ...: There is exactly one hole for one context.
13:04:57 <shachaf> anybody: Where is only for function definitions.
13:05:05 <anybody> shachaf: okie. thx
13:05:09 <shachaf> anybody: You can use let, though.
13:05:16 <shachaf> anybody: Why do you need where?
13:05:20 <monochrom> only when you write like (x = blah where ...)
13:05:40 <monochrom> if you don't mind, (\x -> let me = x+1 in me*me)
13:06:02 <desegnis> > let a = b where b = 1 in a
13:06:04 <lambdabot>  1
13:06:20 <shachaf> > let a = b where b = a in a
13:06:21 <lambdabot>  Exception: <<loop>>
13:06:40 <monochrom> incidentally, (\x -> let me = you where you = x+1 in me*me) also works, just to confuse you. :)
13:07:06 <monochrom> Ah, I'm slower. :)
13:07:08 <chessguy> desegnis, ok, refresh again
13:07:30 <Khoth> > let x = x in [x]
13:07:31 <lambdabot>  Exception: <<loop>>
13:07:36 <monochrom> hole, context? you looking at zippers?
13:07:51 <desegnis> chessguy, better!
13:07:52 <chessguy> monochrom, yes, copy-editing http://www.haskell.org/haskellwiki/Zipper
13:07:53 <lambdabot> Title: Zipper - HaskellWiki
13:08:53 <sfultong> there should be an online reference on pure functional data structures
13:09:12 <sfultong> I probably should just learn more database theory
13:09:41 <litb> is there an official book, where language constructs are shown?
13:09:48 <litb> like, how to code a loop, and so on?
13:10:11 <sjanssen> "how to code a loop" . . . litb is in for a surprise or two :)
13:10:23 <ibid> there is an official book, but it doesn't tell you that (except implicitly)
13:10:36 <chessguy> litb, do you think that's air you're breathing?
13:10:38 <sjanssen> litb: the specification of the language is available online and in print
13:11:05 <anybody> shachaf: i just used it. and the code looked better with it
13:11:29 <litb> hmm
13:11:32 <monochrom> I don't understand chessguy's comment. :)
13:11:45 <chessguy> monochrom, it's from The Matrix
13:11:53 <mrd> @type iterate
13:11:55 <lambdabot> forall a. (a -> a) -> a -> [a]
13:11:57 <monochrom> Ah, now it's clear.
13:12:01 <chessguy> when neo's mind is in the process of getting turned inside-out
13:12:35 <mrd> @type either "Red Pill" "Blue Pill"
13:12:36 <litb> yeah, when they fight in than room
13:12:36 <lambdabot>     Couldn't match expected type `a -> c'
13:12:37 <lambdabot>            against inferred type `[Char]'
13:12:41 <litb> *that
13:12:46 <monochrom> "Wake up from your enslaving Matrix programming illusion. Learn Haskell."
13:12:59 <mrd> @type either (const "Red Pill") (const "Blue Pill")
13:13:01 <lambdabot> forall a b. Either a b -> [Char]
13:13:02 <shachaf> sjanssen: Have you had any more ideas on the idiom brackets, by the way?
13:13:14 <sjanssen> shachaf: not really
13:13:18 <desegnis> sounds like There is no loop!
13:13:23 <litb> "forall a. (a -> a) -> a -> [a]" woot?
13:13:33 <monochrom> There is no Cabal either...
13:13:36 <Khoth> :t loop
13:13:36 <mrd> @type fix
13:13:39 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
13:13:39 <lambdabot> forall a. (a -> a) -> a
13:13:46 <nautican> litb: I'd recommend Yet Another Haskell Tutorial
13:13:46 <mae> are there any tools for generating xml diffgrams in haskell?
13:14:00 <chessguy> desegnis, the loop is only in your brain
13:14:16 <monochrom> @remember chessguy the loop is only in your brain
13:14:16 <lambdabot> Done.
13:14:21 <litb> is there a wikipage for that stuff where it is explained more elaborative?
13:14:22 <shachaf> sjanssen: I think [{}] isn't bad, if it's not taken.
13:14:27 <visof> can i find something like DRscheme for Haskell?
13:14:30 <litb> or a good tutorial about that?
13:14:37 <nautican> http://darcs.haskell.org/yaht/yaht.pdf
13:14:37 <chessguy> @where YAHT
13:14:37 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:14:47 <chessguy> litb, ^^
13:15:02 <litb> great
13:15:03 * shachaf thinks people reading YAHT should just ignore the first IO section.
13:15:04 <litb> thanks
13:15:05 <chessguy> enjoy the ride :)
13:15:13 <litb> =)
13:15:20 <monochrom> Someone some time ago asked for a listing of Haskell language constructs. (He didn't asked for loops; he knew there isn't one.) Eventually he settled with the wikibook.
13:15:21 * litb riding on yaht
13:15:49 <shachaf> @ty until -- loop?
13:15:52 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
13:16:45 <mauke> @type replicateM_ -- loop.
13:16:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
13:17:11 <shachaf> @ty foldr -- loop?
13:17:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:17:33 <Khoth> @ty map -- loop?
13:17:35 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:17:48 <shachaf> @ty sequence_ . repeat -- loop?
13:17:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:18:10 <mauke> @type fix . (>>)
13:18:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:18:13 <chessguy> litb, here's probably the short answer to your question about loops: http://en.wikibooks.org/wiki/Haskell/Recursion#A_quick_aside
13:18:55 <shachaf> I think fix wins, regarding loops.
13:21:40 <dcoutts> zekus_: having problems compiling gtk2hs?
13:21:53 <zekus_> dcoutts yes ido
13:22:13 <zekus_> it says gtkmozembed.h: File does not exist
13:22:15 <dcoutts> zekus_: using the 0.9.12 tarball? what OS ?
13:22:31 <zekus_> yes. on linux platform
13:24:27 <zekus_> dcoutts: i tried --withou-mozembed but it does not work
13:24:36 <zekus_> *without*
13:24:42 <dcoutts> zekus_: if you want the mozilla widget then lets investiage further, otherwise lets just use --disable-mozembed
13:25:21 <zekus_> dcoutts it should be --without-mozembed or --disable-mozembed?
13:25:27 <dcoutts> zekus_: though, acutually you might need to use --disable-firefox --disable-xulrunner --disable-seamonkey if you have any of those installed
13:25:38 <dcoutts> zekus_: the ./configure --help says all the options
13:26:00 <dcoutts> zekus_: since the mozembed binding can use any of xulrunner, mozilla, firefox or seamonkey
13:26:05 <zekus_> dcoutts what is te cost of disabling these features
13:26:19 <dcoutts> zekus_: you'll not get the mozilla html rendering widget
13:26:29 <zekus_> i wanna try the gtk2hs only for now
13:26:42 <goalieca> i'm trying to run GHCbarchart.tcl from the profiler. I keep getting Error: unknown namespace in import pattern "blt::tile::*"
13:26:48 <mauke> I don't think you're going to embed a browser
13:27:22 <dcoutts> zekus_: right, so you can disable the mozembed component
13:28:02 <zekus_> dcoutts it is not seems a big loss yes i'll try. you say it must be like --disable-FOO not --without-FOO
13:28:04 <zekus_> ??
13:29:42 <chessguy> @hoogle foldM
13:29:46 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
13:29:46 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:29:46 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
13:30:37 <ddarius> So the problem is audacity not me.
13:31:02 <ddarius> Whew.
13:36:13 <chessguy> @type mapM_
13:36:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:36:53 <int-e> > [Just 1.0, Just 0.0, Just (-0.0), Just (-1.0)]
13:36:54 <lambdabot>  [Just 1.0,Just 0.0,Just -0.0,Just (-1.0)]
13:37:07 <sfultong> what's a good introductory resource on Arrows?
13:37:18 <shachaf> @where arrows
13:37:19 <lambdabot> http://www.haskell.org/arrows/
13:37:28 <int-e> the show instance for double is flawed :/
13:37:29 <sfultong> I found that...
13:37:39 <shachaf> > show (-0.0)
13:37:40 <lambdabot>  "-0.0"
13:37:49 <shachaf> > show (-1.0)
13:37:51 <lambdabot>  "-1.0"
13:37:55 <monochrom> There is a HXT tutorial that serves the dual purpose of introducing arrows too.
13:38:03 <int-e> > show (Just (-0.0))
13:38:04 <lambdabot>  "Just -0.0"
13:38:16 <monochrom> But it is not the one I wrote. :) Mine is incomplete.
13:38:17 <shachaf> > read (show [Just 1.0, Just 0.0, Just (-0.0), Just (-1.0)]) :: [Maybe Double]
13:38:18 <lambdabot>  [Just 1.0,Just 0.0,Just -0.0,Just (-1.0)]
13:38:32 <chessguy> sfultong, there's also the first chapter in the advanced track at http://en.wikibooks.org/wiki/Haskell
13:38:59 <hpaste>  desegnis pasted "(no title)" at http://hpaste.org/2209
13:39:00 <sfultong> chessguy: thanks
13:39:07 <int-e> > Just -0.0 -- haskell isn't that forgiving though
13:39:08 <lambdabot>        add an instance declaration for (Fractional (a -> Maybe a))
13:39:19 <sfultong> what's HXT?
13:39:27 <desegnis> (arg! sorry for spam)
13:39:31 <gwern> I remember hearing once that there was a haskell version of SICP. does anyone know where it is?
13:39:33 <int-e> an xml library
13:39:48 <monochrom> "scheme in 48 hours"
13:40:16 <monochrom> I mean: search for "scheme in 48 hours"
13:40:32 <gwern> monochrom: really? I thought that was constructing a scheme in haskell, whereas SICP was supposed to be more all-of-computer-science-worth-knowing-ish
13:40:36 <shachaf> > read "Just - 0.0" :: Maybe Double
13:40:37 <lambdabot>  Just -0.0
13:40:53 <desp> is there a built-in function that takes every nth element of a list?
13:40:59 <monochrom> Oh! Sorry, I misread.
13:41:23 <int-e> desp: no, but try something like  map head . iterate (drop n)
13:41:25 <chessguy> @hoogle Int -> [a] -> [a]
13:41:26 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
13:41:26 <lambdabot> Prelude.take :: Int -> [a] -> [a]
13:41:26 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
13:41:31 <monochrom> Hrm. I don't know of one!
13:41:48 <int-e> desp: and add a takeWhile (not . null) in the middle
13:41:50 <desp> int-e: sure, I can build it; just asking to see if I'm not just missing it :)
13:41:52 <chessguy> @hoogle+
13:41:55 <desp> thanks
13:41:56 <shachaf> > map head . takeWhile (not . null) . iterate (drop 5) [1..20]
13:41:57 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
13:42:01 <shachaf> > map head . takeWhile (not . null) . iterate (drop 5) $ [1..20]
13:42:02 <lambdabot>  [1,6,11,16]
13:42:18 * gwern was sure I've seen one before
13:42:35 <chessguy> @type foldr
13:42:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:46:20 <dcoutts> zekus_: did you get it to build ok?
13:46:46 <zekus_> dcoutts yes i just run the hello world program without any problerms
13:47:09 <zekus_> dcoutts i used dsable mozembed and firefox
13:47:17 <zekus_> then it works
13:48:37 <zekus_> dcoutts: sorear: thanks for help. good evening.
13:49:01 <litb> hm, how can i define a function in ghci interactive mode?
13:49:23 <int-e> you can use let
13:49:25 <eivuokko> Using let.  let foo x = x+1
13:49:25 <Khoth> let foo x = -x
13:49:33 <int-e> let add5 x = 5+x
13:49:36 <litb> great
13:49:37 <desp> let foo x = x * x
13:49:47 <sieni> eivuokko: I was about to say the same
13:50:33 <eivuokko> sieni, it seems stereo is not enough for #haskell, are we going for surround now? ;)
13:50:40 <anybody> hey is there a library that simplifies accessing state monad members? atm i'm doing this: "setSomeMemberVar value = State $ \g->((),g{var=value})". but having to put State $ \g-> in all methods is becoming annoying...
13:51:01 <sjanssen> anybody: use 'modify'
13:51:04 <shachaf> anybody: Isn't that the point of the State monad?
13:51:35 <sjanssen> modify (\s -> s {var = value})
13:51:48 <anybody> sjanssen: where is that defined?
13:51:52 <anybody> sjanssen: what library?
13:51:54 <shachaf> Control.Monad.State
13:51:55 <monochrom> #haskell is aiming at full 7.1 Dolby Digital now :)
13:51:58 <shachaf> @index modify
13:51:58 <lambdabot> Control.Monad.State, Control.Monad.RWS
13:52:12 <anybody> thx
13:52:13 <gwern> ah, here it is: http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages only 2 chapters though
13:52:15 <lambdabot> Title: Topics:SICP in other languages - CTMWiki, http://tinyurl.com/yvqsht
13:53:23 <anybody> sjanssen: ah right. modify almost exactly what i was looking for
13:54:08 <sjanssen> anybody: furthermore, if you're using the State constructor explicity, you're probably doing something wrong ;)
13:54:21 <Saizan> modify f = gets f >>= put
13:54:25 <anybody> sjanssen: should it work without it?
13:54:36 <sjanssen> get, put, modify, runState are all preferred over using the State constructor
13:54:58 <anybody> oh. didn't know that. i never used nomads before
13:55:03 <shachaf> anybody: You shouldn't refer to State at all, ideally, in your functions.
13:55:06 <anybody> s/nomads/monads/
13:55:09 <shachaf> anybody: Just to MonadState.
13:55:33 <sfultong> I use nomads in my spice trade
13:55:57 <wli> sfultong: The spice must flow.
13:56:20 <sfultong> ah, yes... just don't become an engorged worm on a cart
13:56:28 <Saizan> so, why is the constructor exported at all?
13:56:50 <ihope> So that you can if you really need to, I guess.
13:57:00 <ihope> If you have a need for speed? :-)
13:57:04 <sfultong> I'm of the opinion that generally constructors shouldn't be exported
13:57:14 <shachaf> anybody: Are you using do-notation at all?
13:57:50 <anybody> shachaf: yes i am
13:58:01 <chessguy> @src Tree
13:58:01 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:58:06 <chessguy> @src Data.Tree
13:58:06 <lambdabot> Source not found. You speak an infinite deal of nothing
13:58:11 <Saizan> ihope: that should have been managed with INLINE pragmas or such
13:58:14 <chessguy> ugh
13:58:20 <shachaf> @source Data.Tree
13:58:20 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
13:58:22 <sfultong> broccoli brains... I do like that insult
13:58:27 <chessguy> sfultong, anyway, what about the Tree data constructors?
13:58:28 <ihope> Ooh, @source!
13:58:35 <chessguy> s/ors/or/
13:58:47 <sfultong> although, cauliflower brains would probably be more visually accurate
13:59:21 <sfultong> chessguy : ok, maybe them... and maybe Either and maybe Maybe
13:59:54 <chessguy> :)
14:00:02 <chessguy> i think there are plenty of times that it's appropriate
14:00:05 <shachaf> sfultong: That's a weird expression.
14:00:05 * sfultong feels a bit hydrocephalic today
14:00:16 <shachaf> "and maybe Either and maybe Maybe"
14:00:35 <shachaf> How much would you have to add to it so it would type-check?
14:00:44 <sfultong> I like how programming breaks english grammar
14:00:48 <Saizan> it depends on if the contructors are implementation details or an interface for the user
14:02:26 <wli> data AtLeafOneOf t t' = OnlyFirst t | OnlySecond t' | Both t t'
14:02:34 <wli> No point in hiding its constructors.
14:02:45 <Saizan> then you've those cases like Data.Set where exporting the construcor is bad because you won't be able to modify it later without breaking code, and not exporting it is also bad because you can't extend the functionality without hacking base
14:03:17 <Saizan> (so i need to build an useless Seq just to pick some random elements)
14:07:14 <ddarius> There are cases where using encapsulation is clear, namely when some invariants must be maintained.
14:07:58 <ddarius> Many of the day-to-day Haskell data types are "free" and as such have no invalid states.
14:08:32 <sfultong> shachaf: your comment reminded me of this: http://www.scwu.com/bookreviews/h/FfordeJasperWellofLostPlotsThe.shtml
14:08:37 <lambdabot> Title: Steven Wu's Book Reviews: Well of Lost Plots, The (Jasper Fforde), http://tinyurl.com/2nbwdl
14:09:08 <sfultong> although I haven't actually read the book, I've heard of it, and probably should want to read it
14:09:28 <wli> Sometimes the constructors maintain the invariants on their own.
14:09:47 <wli> e.g. data NEL t = NELUnit t | NELCons t (NEL t)
14:11:46 <chessguy> sfultong, that looks very amusing
14:12:10 <shachaf> sfultong: My comment?
14:12:29 <chessguy> i love the random comparison to a chocolate orange
14:12:29 <shachaf> Oh.
14:13:42 <sfultong> yeah, my sister was reading it a while ago, and she read that part aloud
14:14:10 <sfultong> have I been programming too much if parsing the redundancy in the grammar seems not very difficult to me? :-P
14:14:36 <ddarius> wli: Free semigroup
14:15:02 <ddarius> sfultong: No, quite the opposite.
14:15:43 <anybody> shachaf: so far i used "type MyStateMonad a = State Game a" as monadic type. is there a more elegant solution? like deriving from MonadState?
14:16:13 <shachaf> anybody: You can use a newtype if you want.
14:16:26 <mauke> newtype MyType a = MyType {unMyType :: State Game a} deriving (Monad, Functor, MonadState Game)
14:16:33 <shachaf> anybody: (By the way, you can just say "type MyStateMonad = State Game")
14:16:56 <desp> @pl f xs = 1 : g xs
14:16:56 <lambdabot> f = (1 :) . g
14:16:56 <anybody> shachaf: oh. didn't know that either ;-)
14:17:54 <sfultong> anybody: making a game+
14:17:55 <sfultong> ?
14:18:02 <anybody> sfultong: yup.
14:18:19 <anybody> sfultong: a little project to learn haskell
14:18:26 <chessguy> anybody, what kind of game?
14:19:05 <anybody> chessguy: nothing too complicated. just texas holdem'
14:19:10 <chessguy> ah, nice
14:19:24 <sfultong> anybody: yeah, I'm using the same strategy to learn haskell myself
14:19:44 <sfultong> although as I learn more, I keep rewriting my code, so I don't really get anywhere in terms of a finished product
14:19:46 <anybody> sfultong: thats the way i learn almost everything.
14:19:53 <chessguy> i suspect it will be more complex than you think though :)
14:19:55 <anybody> yeah same here ;-)
14:20:21 <chessguy> unless you've already written it in another language
14:20:23 <anybody> yeah the biggest problem i have is how to thread IO through the GameState monad
14:21:04 <shachaf> anybody: You can use StateT over IO.
14:21:10 <sfultong> yeah... I hate simultaneously trying to learn stuff while trying to organise the code in my head... it's really slow
14:21:21 <mauke> newtype MyType a = MyType {unMyType :: StateT Game IO a} deriving (Monad, Functor, MonadState Game, MonadIO)
14:21:22 <shachaf> Didn't someone talk about that on -cafe some time ago? Using MonadGame?
14:21:48 <anybody> chessguy: i'm quite proficient in c++. i know some javascript, pascal, ruby, python and assembler so i don't think that i will have any problems apart from haskell specific ones ;-)
14:22:30 <chessguy> anybody, ok. some of the algorithms are not simple, though. particularly finding the rank of a hand
14:23:11 <anybody> chessguy: yeah i guess so. but the internet is your friend ;-)
14:24:06 <shachaf> I think it's at http://www.haskell.org/pipermail/haskell-cafe/2007-May.txt .
14:24:15 <anybody> oh mauke so this StateT is just a Monad pair container?
14:24:51 <mauke> I don't know what a monad pair container is but StateT is a monad transformer :-)
14:25:15 <anybody> mauke: i meant a monad containing 2 other monads
14:25:33 <mauke> kind of
14:25:43 <shachaf> anybody: StateT adds a "state layer" over another monad.
14:29:52 <anybody> mauke: the first example you you showed me about deriving from MonadState added this unMyType indirection. so how will i be able to access the elements of Game now? gets $ elemName . unMyType ?
14:30:11 <mauke> no, just gets elemName
14:30:31 <shachaf> anybody: unMyType is like runState.
14:30:34 <mauke> this layering doesn't affect the state
14:31:25 <chessguy> > length [[Nothing|_<-[1..8]]|_<-[1..8]]
14:31:27 <lambdabot>  8
14:31:45 <tga> hello
14:32:05 <chessguy> hi tga
14:32:52 <litb> that yaht rocks
14:33:07 <chessguy> @instances-importing Num
14:33:08 <lambdabot> Double, Float, Int, Integer
14:33:30 <mauke> @instances-importing Data.Ratio Num
14:33:31 <lambdabot> Double, Float, Int, Integer, Ratio a
14:34:41 <tga> stupid question.. why does something like "foo x = x + 1" gives me a parse error in ghci?
14:34:59 <samreid> tga: you mean let foo x = ...
14:35:05 <dcoutts> tga: it's like you're in the IO monad, so use let ...
14:35:28 <dcoutts> tga: the ghci prompt is like a do block, not a top level module declaration
14:35:29 <mauke> tga: because it's not an expression :/
14:35:37 <anybody> hrm
14:35:44 <anybody> make: Can't make a derived instance of `MonadState GameState'
14:35:45 <tga> ah, got it
14:35:50 <anybody> mauke: Can't make a derived instance of `MonadState GameState'
14:36:01 <mauke> anybody: {-# OPTIONS_GHC -fglasgow-exts #-}
14:36:02 <chessguy> probably need -fglasgow
14:36:19 <tga> I wanted to try something quickly in ghci and couldn't figure out what was going on
14:36:41 <OceanSpray> how do I figure out what type something is during compile time?
14:36:45 * tga is pulling a 'learn Haskell in two days' thing for school
14:37:01 <mauke> OceanSpray: huh?
14:37:12 <mauke> why don't you do it at programming time?
14:37:20 <OceanSpray> that's the problem
14:37:22 <OceanSpray> I can't.
14:37:31 <OceanSpray> I have NO idea what the type of this things is
14:37:44 <monochrom> Perhaps OceanSpray is encountering type errors and wants to investigate.
14:37:47 <dcoutts> OceanSpray: if it's an expression, use ghci to help you
14:38:09 <dcoutts> OceanSpray: eg: at the ghci prompt say > :type 1+1
14:38:26 <OceanSpray> but it's in the middle of this 200 line program
14:38:44 <dcoutts> OceanSpray: then the trick is to add type annotations to things you think you know the type of
14:39:00 <dcoutts> OceanSpray: that'll help you to narrow down where you and the compiler disagree
14:39:29 <yetAnotherOne> Can i turn a handle into a stream?
14:39:41 <dcoutts> yetAnotherOne: hGetContents ?
14:39:49 <sorear> .
14:40:04 <shachaf> /
14:40:28 <yetAnotherOne> thanks
14:40:32 <hpaste>  OceanSpray pasted "lisp interpreter" at http://hpaste.org/2210
14:41:06 <mauke> cut off
14:41:24 <OceanSpray> oh damn
14:41:37 <mauke> hpaste sucks like that
14:42:11 <anybody> mauke: but why does it work even if the state is wrapped twice?
14:42:23 <mauke> huh?
14:42:52 <shachaf> anybody: Nothing is wrapped twice.
14:42:57 <hpaste>  OceanSpray annotated "lisp interpreter" with "(no title)" at http://hpaste.org/2210#a1
14:42:58 <anybody> mauke: in you first example. Game is inside State and then inside MyState
14:43:06 <mauke> anybody: not really
14:43:20 <OceanSpray> hold on, what
14:43:26 <mauke> but it Just Works(tm) because MonadState is a typeclass
14:43:31 <OceanSpray> is there a line limit or something?
14:43:38 <mauke> OceanSpray: file size limit
14:43:50 <shachaf> 5K, I think?
14:43:54 <hpaste>  litb pasted "damn!" at http://hpaste.org/2211
14:44:11 <litb> what is wrong with this? i don't see it
14:44:12 <shachaf> litb: You forgot do.
14:44:15 <shachaf> litb: Or in.
14:44:19 <hpaste>  OceanSpray annotated "lisp interpreter" with "(no title)" at http://hpaste.org/2210#a2
14:44:20 <shachaf> litb: Either would work.
14:44:29 <mauke> anybody: there's an instance MonadState MyType Game, so gets returns you a plain Game
14:44:37 <OceanSpray> ok there
14:44:57 <litb> shachaf: but in the tutorial , they use no do
14:45:03 <shachaf> litb: So use an in.
14:45:08 <litb> main = putStrLn "hello"
14:45:12 <litb> they do it like this
14:45:13 <shachaf> litb: You need "in" for "let".
14:45:32 <shachaf> > let x = 3 in putStrLn "hello!"
14:45:34 <lambdabot>  <IO ()>
14:45:40 <OceanSpray> see envLookup, with envMap and val?
14:46:06 <litb> hmm
14:46:20 <OceanSpray> when I try to compile it, ghc gives me  Couldn't match expected type `IORef LispVal'
14:46:20 <OceanSpray>            against inferred type `Maybe a'
14:46:24 <litb> and in says that i really want to define x ?
14:47:08 <shachaf> > let x = 3 in 1 + x
14:47:09 <lambdabot>  4
14:47:15 <chessguy> @type toList
14:47:17 <lambdabot> Not in scope: `toList'
14:47:22 <Khoth> Suggests that val is an IoRef LispVal instead of Maybe something-or-other
14:47:23 <chessguy> @type Data.Map.toList
14:47:25 <lambdabot> forall k a. Data.Map.Map k a -> [(k, a)]
14:47:41 <yetAnotherOne> Is there anyway to turn a Handle which i got from accept to a Stream which is useable with Network.HTTP?
14:47:43 <shachaf> litb: Which tutorial is this?
14:47:47 <litb> ah, in links statements together?
14:47:50 <mauke> OceanSpray: the problem is probably the val <-
14:47:52 <litb> it is yaht
14:47:53 <shachaf> litb: No.
14:48:00 <shachaf> litb: There are no statements in Haskell.
14:48:01 <OceanSpray> mauke: ?
14:48:02 <mauke> OceanSpray: try  let val = Data.Map.lookup str envMap  instead
14:48:32 <samreid> litb: where in yaht?
14:48:38 <chessguy> @check Data.Map.toList (Data.Map.fromList (s::String)) == s
14:48:39 <lambdabot>   Not in scope: `Data.Map.fromList'
14:48:51 <litb> samreid: page 22
14:48:52 <chessguy> @type Data.Map.fromList
14:48:54 <lambdabot> forall k a. (Ord k) => [(k, a)] -> Data.Map.Map k a
14:49:07 <Toxaris> litb: "in" is part of the syntax of "let": it's "let <some definitions> in <an expression>"
14:49:36 <chessguy> anybody know if that equivalence should hold?
14:49:39 <Toxaris> > let x = 21 in 2 * x -- like this, litb
14:49:40 <lambdabot>  42
14:49:52 <samreid> litb: page 22 has   main = putStrLn "Hello World"
14:50:03 <litb> Toxaris: ah, so that let returns an expression as required by the main function?
14:50:09 <litb> samreid: yes
14:50:13 <litb> i modified it
14:50:26 <Toxaris> litb: yes, let ... in ... is itself an expression
14:50:36 <litb> but what i don't get is, why can i define variables. but cannot call a function?
14:50:46 <OceanSpray> I keep on getting incorrect indentation
14:50:47 <litb> i.e on page 21, there are variables defined in the file
14:50:52 <OceanSpray> how do I use a let inside a do?
14:50:57 <litb> if i put a function call under them, i get an error
14:51:09 <mauke> litb: you can't have freestanding expressions
14:51:15 <mauke> this is similar to C++
14:51:18 <Khoth> OceanSpray: have a line like "let foo = x + 1"
14:51:26 <hpaste>  fxn pasted "help with parse error" at http://hpaste.org/2212
14:51:27 <litb> mauke: oh
14:51:49 <chessguy> @bot
14:51:49 <lambdabot> :)
14:51:50 <Toxaris> > do {let x = 3; return x} :: Maybe Int -- like this, OceanSpray
14:51:50 <lambdabot>  Parse error
14:51:56 <shachaf> chessguy: No, it shouldn't.
14:52:00 <mauke> Toxaris: not if you use {}
14:52:00 <chessguy> @where xmonad
14:52:01 <lambdabot> http://xmonad.org/
14:52:05 <mauke> fxn: missing "in"
14:52:08 <OceanSpray> okay
14:52:10 <chessguy> shachaf, why not?
14:52:10 <Toxaris> mauke: why not :(
14:52:17 <mauke> because it's evil
14:52:21 <fxn> mauke: where? (hey!)
14:52:30 <mauke> > do {let {x = 3}; return x} :: Maybe Int
14:52:31 <lambdabot>  Just 3
14:52:34 <shachaf> chessguy: For one, fromList doesn't take a String. :-)
14:52:52 <Toxaris> mauke: oh ok, no layout inside of no-layout
14:52:55 <chessguy> ugh
14:52:56 <shachaf> chessguy: It takes a list of pairs.
14:52:57 <chessguy> i'm a moron
14:53:15 <shachaf> Prelude Test.QuickCheck Data.Map> quickCheck (\s -> Data.Map.toList (Data.Map.fromList (s::[(Int,Int)])) == s)
14:53:17 <mauke> fxn: the syntax is  let <DEF> in <BODY>
14:53:31 <shachaf> Falsifiable, after 4 tests:
14:53:33 <shachaf> [(2,0),(1,2)]
14:54:45 <fxn> mauke: oh yes
14:54:47 <shachaf> There's no Arbitrary Char instance anyway. :-)
14:55:06 <OceanSpray> ok, I'm getting the same type mismatch errors
14:55:22 <shachaf> OceanSpray: What errors?
14:56:32 <OceanSpray>     Couldn't match expected type `LispVal'
14:56:32 <OceanSpray>            against inferred type `IORef LispVal'
14:56:42 <OceanSpray> oh wait...
14:56:42 <Toxaris> chessguy: given that Data.Map is some kind of search tree, how could that equivalence hold?
14:56:53 <mauke> that's a different error
14:57:04 <OceanSpray> each time I try to fix it, the line number of the error changes.
14:57:07 * shachaf didn't think it made much sense.
14:57:11 <OceanSpray> orz
14:57:12 <litb> hmm, doesn't fg mean g(f) ?
14:57:26 <mauke> litb: no
14:57:27 <shachaf> litb: What's that Unicode?
14:57:32 <shachaf> litb: Composition?
14:57:34 <mauke> degree :-)
14:57:44 <shachaf> Oh.
14:57:53 * shachaf hasn't seen that in Haskell.
14:57:59 <sorear> Composition is 
14:58:11 * shachaf feels left out of the Unicode Club.
14:58:16 <mauke> U+2218 (0xe2 0x88 0x98): RING OPERATOR []
14:58:29 <litb> it is the circle thing
14:58:31 <sorear> Alias names:  composite function  APL jot
14:58:42 <sorear> See also:  U+00B0 DEGREE SIGN  U+25E6 WHITE BULLET
14:58:45 <mauke> yes, but how do I type that?
14:59:05 <EvilTerran> Alt+numpad?
14:59:06 <sorear> C-S-2218 in any ISO 14755 compliant environment
14:59:17 <mauke> 
14:59:22 <mauke> awesome
14:59:33 <Toxaris> litb: f . g means the function wich is applied by first applying g, then f
14:59:35 <EvilTerran> that looks like the same line-noise as the last one, to me ;]
14:59:40 <EvilTerran> @src (.)
14:59:40 <lambdabot> (.) f g x = f (g x)
14:59:41 <ddarius> @src (.)
14:59:41 <lambdabot> (.) f g x = f (g x)
14:59:46 * shachaf 's environment is not ISO 14755 compliant...
14:59:49 <ddarius> (f . g) x = f (g x)
14:59:59 <EvilTerran> stereo, etc.
15:00:06 <shachaf> 
15:00:10 <shachaf> What's that
15:00:17 <shachaf> s/$/?/
15:00:20 <mauke> U+00AA (0xc2 0xaa): FEMININE ORDINAL INDICATOR []
15:00:21 <EvilTerran> feminine ordinal indicator?
15:00:34 <EvilTerran> more stereo, etc.
15:00:36 <shachaf> Hmm. I guess that didn't work...
15:00:47 <mauke> but mine is scripted!
15:01:06 <EvilTerran> well, _I_'m just that good naturally ;]
15:02:09 <mauke> I  Unicode!
15:02:38 <fxn> shachaf: you mean what's does that glyph mean?
15:02:49 <sorear> mauke: more favorites: 3BB  39B  3B1  3B2  2200  2203  3B7  22A5  F6  2208  2264  2265  AC  2192  2227  2228  222A  2229  2237 
15:02:58 <osfameron> oh!  the superscript a is a feminine ordinal!  I never knew that
15:03:00 <EvilTerran> i tall-box-outline japanese character it too, mauke.
15:03:03 <osfameron> what's the male ordinal?
15:03:12 <fxn> 
15:03:14 <EvilTerran> osfameron, superscript "o"
15:03:27 <Toxaris> what *
15:03:28 <EvilTerran> think "ballerino" vs "ballerina", etc.
15:03:29 <osfameron> oh, so the Italian/Spanish noun endings
15:03:35 <mauke> latin!
15:03:36 <sorear> How does one determine the geneder of an ordinal number?
15:03:41 <sorear> *gender
15:03:43 <Toxaris> what *is* a feminine ordinal indicator?
15:03:47 <mauke> sorear: my font doesn't have the last one
15:03:49 <fxn> sorear: depends on the thing it is counting
15:03:50 <osfameron> Latin?  Isn't that "us"? ;-)
15:04:07 <lament> Toxaris: the short for "primera" (first) is "1a"
15:04:08 <sorear> , +1, [0], etc
15:04:15 <lament> Toxaris: the short for "primero" is "1o"
15:04:19 <sorear> what are the gendes of numbers like those?
15:04:37 <mauke> neutral
15:04:37 <osfameron> why does it need a unicode point anyway?  can't they just use superscript "o" and "a" ?
15:04:46 <Toxaris> lament: like in 1st, 2nd, ... but gender-aware?
15:04:56 <lament> Toxaris: yes.
15:05:01 <osfameron> I mean, in English we use superscript "st" or "th" or "nd" (handy) and I don't expect there's a codepoint for each of those
15:05:13 <fxn> sorear: in Spanish you say "el corredor llego primero", but "la corredora llego primera" (corredor == runner)
15:05:28 <fxn> sorear: it depends on the gender od the noun
15:05:30 <EvilTerran> i'm sure there is, osfameron. it escapes me ATM, but there almost certainly is.
15:05:35 <sorear> fxn: ah, right...
15:05:47 * sorear just loves little variations like that...
15:05:54 * sorear hates plurals in english
15:05:57 <lament> that's not a little variation
15:06:10 <EvilTerran> heck, there's unicodepoints for things like all the numerals and maths operators in superscript and subscript
15:06:11 <lament> that's an extremely important grammar rule
15:06:14 <OceanSpray> I'm seeing ghosts here
15:06:17 <lament> that pervades the entire language
15:06:18 <fxn> sorear: and the fact that it is s superscript depends on the conventions in the language, that happens in Catalan as well but we don't use superscripts, plain "1er", "2a", etc.
15:06:36 <OceanSpray> It looked like the function type declaration is changing
15:06:56 <EvilTerran> there's all sorts of things in unicode that're better left to the display system than the text encoding, IMO.
15:07:09 <shachaf> fxn: I have no idea.
15:07:16 <shachaf> fxn: It was my attempt to type another one.
15:07:29 <Toxaris> EvilTerran: how should the display system know what is meant if I type 1st?
15:07:33 <hpaste>  xterminus pasted "(no title)" at http://hpaste.org/2213
15:07:48 <EvilTerran> Toxaris, by supporting typesetting, if you want to do anything fancy.
15:08:07 <EvilTerran> whatever happened to plaintext being a lowest common denominator?
15:08:17 <Toxaris> EvilTerran: hmm ok :)
15:08:18 <lament> define plaintext
15:08:31 <EvilTerran> lament, EBCDIC
15:08:34 * EvilTerran ducks
15:09:39 <EvilTerran> i guess unicode is part of the same school of thought that CSS etc is part of. separation of content and style an' all that.
15:09:44 <ddarius> sorear: Learn Japanese.
15:09:59 <EvilTerran> given that they attach meanings rather than appearances to codepoints.
15:10:19 <Toxaris> in some languages, cardinal numbers are gender-aware, too (like "ein Mann" (a man) but "eine Frau" (a woman) in german). a few languages have a gender-aware cardinal two, coming from ancient times when there were singular, dual and plural...
15:10:26 <sorear> ddarius: You can't read Japanese at 8 points, and I can't live without a 212 column terminal.
15:10:29 <sorear> :P
15:10:43 <ddarius> sorear: You need less characters, so that isn't as critical.
15:11:10 <shachaf> In Hebrew, most numbers are gender-aware.
15:11:19 <EvilTerran> i've seen legible hiri and kata at 8pt.
15:11:22 <Baughn> ddarius: Except where you mix english code and japanese comments. Tough luck getting those to write comments in english.
15:11:24 <ddarius> Is yod masculine?
15:11:40 <ddarius> EvilTerran: It's the Kanji that'd get you.
15:11:42 <lament> Toxaris: the word "one" is declined in gender in many languages in which other numbers aren't, so it's a bad example
15:11:53 * EvilTerran 's sister imports collectible virtual pets from japan, y'see.
15:12:06 <lament> Toxaris: for example, Spanish and Russian.
15:12:16 <EvilTerran> when your screen's a 32x16 LCD, you're a little restricted
15:12:23 * ddarius hates gender in languages.
15:12:52 * sorear hates all built-in redundancy
15:13:06 <ddarius> sorear: You should -really- learn Japanese then.
15:13:07 <Toxaris> lament: a special case is a bad example for a special case? oups, I haven't written that I'm aware that it's a special case. I meant "in some languages, some cardinal numbers ..."
15:13:11 <monochrom> 32'x16' LCD would be a dream. :)
15:13:15 <Baughn> sorear: Don't think "redundancy", think "opportunities to make a hash of the sentence"
15:13:17 <lament> Toxaris: right
15:13:59 <lament> i don't know of any languages where all cardinals show gender agreement, although i'm sure they exist
15:13:59 <dbremner> sorear- or think ECC for the brain.
15:14:31 <ddarius> Japanese doesn't have a future tense, it has plurals and pronouns but they are never used, and you typically omit the subjects (or more) of sentences.
15:14:39 <EvilTerran> monochrom, pixels, not inches, i'm afraid.
15:14:52 <sorear> EvilTerran: ' is feet. :)
15:14:56 <EvilTerran> (or indeed feet, as you wrote it there... wow, that _would_ be a dream)
15:15:07 <lament> ddarius: but it also has counter words, which are an enormous pain
15:15:14 <ddarius> lament: True.
15:15:18 * monochrom has a crazy idea. Make a language in which prime numbers are female, composite numbers are male, and 1 and 0 have some other genders too.
15:15:32 <lament> 1 is a transvestite!
15:15:38 <sorear> dbremner: I have nothing against well-designed modular codes... but sadly I'm afraid foos/foo can't hold a candle to Reed-Solomon or similar at the same data rate
15:15:39 <lament> and 0 is asexual
15:15:39 <Toxaris> because prime numbers are sexy?
15:15:39 <Baughn> monochrom: ..what's 2?
15:15:42 <shachaf> How about negative numbers?
15:16:02 <monochrom> 2 is a prime number.
15:16:04 <sorear> Transfinite numers?
15:16:20 <Baughn> Nullity?
15:17:03 <lament> This is why you people shouldn't be ever allowed to design anything for any purpose.
15:17:25 <monochrom> 32 pixels x 16 pixels is barely enough for an icon, I agree.
15:18:05 <DaveCGI769> does haskell escape things such as "\r\n" into the literals CLRF automatically
15:18:12 <dbremner> sorear- if you want a language w/o redundancy, try creating a language like Heinlein's Speedtalk.
15:18:18 <DaveCGI769> if it does, how do i not do that? if it doesnt, how do i do that?
15:18:30 <mauke> DaveCGI769: huh?
15:18:31 <shachaf> DaveCGI769: Why do you use a different number every time?
15:18:46 <DaveCGI769> shachaf: its automatically generated
15:19:10 <sjanssen> DaveCGI769: you want to shut off CRLF translation when doing IO?
15:19:14 <DaveCGI769> ok normal strings "abc" are ['a', 'b', 'c']
15:19:25 <sorear> dbremner: I'd like to figure out a way to insert zlib in my IO pathway
15:19:35 <monochrom> "\\r\\n"  '\\'
15:19:38 <DaveCGI769> my question is "\r\n" == ['\', 'r', '\', 'n'] or is it [CR, LF]
15:19:46 <mauke> > length "\n"
15:19:47 <lambdabot>  1
15:19:53 <Toxaris> > "\r\n" !! 0
15:19:55 <lambdabot>  '\r'
15:20:09 <Baughn> DaveCGI769: It performs C-style backslash expansion
15:20:14 <sorear> > map fromEnum "\r\n"
15:20:15 <lambdabot>  [13,10]
15:20:27 <DaveCGI769> how do i turn off the C-style backslash expansions
15:20:28 <monochrom> > map fromEnum "\\r\\n"
15:20:29 <lambdabot>  [92,114,92,110]
15:20:51 <mauke> DaveCGI769: you don't
15:20:56 <sorear> DaveCGI769: You can't.  Doubling backslashes should be good enough for anybody. :)
15:21:00 <DaveCGI769> i want to
15:21:03 <DaveCGI769> for regular expressions
15:21:07 <hpaste>  yetAnotherOne pasted "Problems with Network.HTTP" at http://hpaste.org/2214
15:21:10 <monochrom> download the GHC source code...
15:21:11 <yetAnotherOne> I want to turn the Handle cHandle into something which can be used by Network.HTTP
15:21:16 <DaveCGI769> so i can type in things like "\s" instead of "\\s"
15:21:27 <EvilTerran> you could use a different character...
15:21:29 <Baughn> DaveCGI769: You can't do that, Dave
15:21:37 * EvilTerran has used ` for this purpose
15:21:43 <monochrom> type in? as in you use getLine to read from stdin?
15:22:15 <EvilTerran> (mnemonic: *back*slash, *back*tick)
15:22:17 <Baughn> DaveCGI769: \\ should be good enough for anyone. And when you try to decode \\\\\ in a three-level expansion.. think of unix.
15:22:41 <shachaf> Baughn: Five backslashes?
15:23:05 <Baughn> shachaf: One of the levels has rather odd escape rules
15:23:11 <EvilTerran> leaning toothpick syndrome!
15:23:12 <pjd> yay for raw string syntax
15:23:19 <geezusfreeek> i think DaveCGI769  is just trying to prevent it from looking like Java regexes
15:23:35 <pjd> Python++
15:23:36 <monochrom> I think it's a very strange question.
15:23:57 <monochrom> It also lacks context, like all strange questions do.
15:23:58 <EvilTerran> (from perl, where you need to escape forward-slashes in the normal regex syntax as well)
15:23:59 <dcoutts> @seen SyntaxNinja
15:24:00 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs, #haskell-blah and #haskell-soc 2d 20h 18m 27s ago, and .
15:24:35 <mauke> EvilTerran: actuall, you don't
15:24:41 <geezusfreeek> DaveCGI769, if it bothers you too much, you could always just write a function to desantize a string that has invalid characters for regexes into backslashed equivalents or something
15:24:48 <mauke> regex syntax doesn't care about slashes :-)
15:24:48 <wli> I'm baffled as to why my elliptic curve code isn't doing so well on 2^(2^7)+1 even though it gets near-instant results on 2^1039-1
15:25:14 <DaveCGI769> geezusfreeek: how would i do taht exactly ?? "\s" just returns a lexical error
15:25:15 <geezusfreeek> or vice versa
15:25:21 <sorear> mauke: I think he hasn't discovered m| yet
15:25:26 <EvilTerran> mauke, i said the _normal_ syntax in _perl_, ie /.../. m(.)...\1 is not quite normal.
15:25:40 <DaveCGI769> sorear: what is m|
15:25:41 <sorear> perl's learning curve is a 4% grade, 3000mi long
15:25:45 <mauke> EvilTerran: it's also a syntax error
15:25:51 <sorear> haskell is a 10mi sheer cliff ;)
15:25:56 <EvilTerran> um?
15:26:04 <dcoutts> @tell SyntaxNinja we need to do some cabal-devel mailing list admin tasks, apparently the cvs-ghc list lets through darcs patches, we should do the same
15:26:04 <lambdabot> Consider it noted.
15:26:12 <geezusfreeek> DaveCGI769, i really wouldn't worry about it... i don't think most people mind using some backslashes every once in a while
15:26:17 <monochrom> sorear: that must mean I'm 50mi tall. :)
15:26:20 <dbremner> Baughn- it might be worth adding raw string literals to Haskell 2.
15:26:20 <mauke> m(.) . ..<- parse error here
15:26:38 <EvilTerran> um. i was expressing regex syntax in regex syntax.
15:26:47 <wli> I bet there's something wrong with the PRNG in System.Random that's killing me.
15:26:57 <geezusfreeek> > "\s"
15:26:57 <lambdabot>  Illegal escape sequence
15:26:59 <EvilTerran> an ugly mixture of PCREs and POSIX REs, mind, but still.
15:27:04 <mauke> EvilTerran: m() is actually the normal syntax. it's just that m// lets you omit the m
15:27:06 <geezusfreeek> > "\\s"
15:27:08 <lambdabot>  "\\s"
15:27:32 <EvilTerran> mauke, i define "normal" to be "what gets used most of the time". which is, in my experience, /.../
15:27:37 <Toxaris> why are RegExps encoded as strings, unlike all other DSL's in Haskell?
15:27:48 * monochrom is on the blink to ask, but still hesitant: what is the real question?
15:28:31 <mauke> EvilTerran: yes, unless the pattern contains /
15:28:32 <pjd> hmm, has anyone attempted something like http://www-static.cc.gatech.edu/~shivers/papers/sre.txt in Haskell?
15:28:44 <sorear> Toxaris: Because Haskell syntax isn't terse enough to express regex syntax
15:29:18 <shachaf> sorear: How close could you get?
15:29:32 <EvilTerran> mauke, which it doesn't. most of the time. which is what i'm talking about.
15:29:53 <Baughn> shachaf: You tell me. Start with parsec.
15:30:15 <sorear> shachaf: char 'f' `cat` (char 'o' <|> char 'O') `cat` char 'o'  or so ...
15:30:26 <shachaf> You can use postfix operators like (*), for example.
15:30:26 <ddarius> sorear: You could do better than that.
15:31:05 <monochrom> You could define a library such that (s "a*" "b") makes sense.
15:31:17 <osfameron> foldl cat [char 'f', (char 'o' <|> char 'O'), char 'o']  ?
15:31:22 <sorear> e *> 'f' *> (e *> 'o' <|> e *> 'O') *> 'o'
15:31:35 <anybody> where can i find an example of using the StateT nomad with IO ?
15:31:35 <mauke> EvilTerran: you said "you need to escape forward-slashes in the normal regex syntax".  I'm saying you don't, because 1) you could switch to a different delimiter and 2) this is not regex syntax anyway
15:31:57 <samreid> anybody: http://xmonad.org/
15:31:59 <lambdabot> Title: xmonad : a tiling window manager
15:32:02 <anybody> do i have to "lift" actions from the IO monad to the StateT IO monad?
15:32:07 <sorear> This would be much easier with some kind of idiom-syntax:
15:32:07 <EvilTerran> I. am. talking. about. most. perl. that. i. have. seen. goddamnit.
15:32:12 <monochrom> Yes you have to, anybody.
15:32:14 <shachaf> anybody: The reverse.
15:32:18 <anybody> samreid: thx.
15:32:31 <shachaf> anybody: You lift from StateT to IO.
15:32:31 <sorear> [[ e 'f' ([[e 'o']] <|> [[e 'O']]) 'o']]
15:32:36 <shachaf> anybody: Using liftIO.
15:32:46 <mauke> @type liftIO
15:32:46 <anybody> shachaf: and liftIO is already defined?
15:32:48 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:33:04 <shachaf> anybody: Yes.
15:33:08 <shachaf> anybody: Some people call it IO.
15:33:14 <shachaf> @go roll your own irc bot
15:33:16 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
15:33:16 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
15:33:17 <Baughn> instance RegexElem String where ...
15:33:23 <shachaf> That uses ReaderT with IO.
15:33:27 <EvilTerran> mauke, in my experience, the majority of regexes in perl code use //. as such, i consider // to be perl's "normal regex syntax". and i was only referring to perl's "normal syntax", as would be apparent if you'd quoted the whole line there.
15:34:39 <monochrom> Example code for anybody and everybody.  main = evalStateT (do { s <- get; liftIO (print s) ) 0
15:34:41 <mauke> the // aren't part of the regex syntax, they're perl/quoting syntax.  e.g. tr/// doesn't have anything to do with regexes
15:35:03 <monochrom> I made some typo there. I missed a }
15:35:04 <shachaf> monochrom: More interesting would be to put something that you gotLine.
15:35:15 <marcotmarcot> Hey guys, I just made a simple html page with xhtml, take a look.
15:35:19 <EvilTerran> it's a bit of syntax normally used in perl for regexes! it's perl's regex syntax!
15:35:20 <monochrom> Yes. Please do expand on that example and play!
15:35:42 * shachaf has "used" StateT before.
15:35:42 <marcotmarcot> The haskell source code is in the end of the file, Cdigo fonte: http://marcotmarcot.googlepages.com/index.html
15:35:44 <lambdabot> Title: Trabalhos da filosofia
15:35:47 <monochrom> Also, please don't argue on anal things!
15:35:52 <marcotmarcot> xhtml is nice.
15:36:05 <EvilTerran> why the hell are we arguing about such a bloody trivial bit of semantics as whether or not the regex quoting syntax is part of the regex syntax?!
15:36:37 <sorear> why the hell are we arguing about the syntax of a feature in a different language?
15:36:41 <EvilTerran> i say it is, you say it isn't, and in the end, it's completely beside the point anyway.
15:37:07 <EvilTerran> damnit. that's the last time i make an off-the-cuff comment about an imperative language in a functional language's channel.
15:37:21 <monochrom> Perl is a functional language.
15:37:25 <monochrom> (duck) XD
15:38:09 <monochrom> Please laugh and have some drink you like and take it easy. :)
15:38:27 <EvilTerran> i thought it was perfectly clear what i meant, and any imprecision in my language was purely in the interests of keeping things terse. didn't expect to get into an argument over semantics.
15:38:36 <sorear> marcotmarcot: nice.  looks very good even in elinks here..
15:39:05 <EvilTerran> monochrom, only insofar as, say, lisp is a functional language. and (compared to haskell, anyway) i'd say it isn't.
15:39:31 <monochrom> Yes.
15:39:45 <EvilTerran> side effects etc.
15:39:48 <DaveCGI769> hate to say it, but regexps are probably the easiest way to work with strings in a very compact manner.. of course when you start using dozens of them you should be writing a parser instead
15:39:54 <sorear> There is no such thing as a functional language, only functional programmers
15:40:04 <ddarius> There are functional programmers?
15:40:05 <monochrom> Yes, DaveCGI769.
15:40:07 <sorear> Is Haskell functional?  Ask Bulat!
15:40:14 <DaveCGI769> lambda calculus is functional
15:40:15 <sorear> Ask Hughes!
15:40:16 <monochrom> Why Bulat?
15:40:17 <EvilTerran> more like varying degrees of dysfunctional programmers.
15:41:04 <monochrom> I am dysfunctional. I haven't learned comonads yet.
15:41:09 <sorear> monochrom: Because he is most vocal about the need for Haskell to support more paradigms
15:41:17 <monochrom> Ah. Thanks.
15:41:33 * ddarius agrees with EvilTerran and from his experience would probably not put Haskellers at the "better" end of that particular scale...
15:41:59 <Toxaris> DaveCGI769: what feature of RegExps makes them easy?
15:42:09 * monochrom parodes a Phil Wadler opening sentence. "Should I be logical or illogical?"
15:42:26 <DaveCGI769> Toxaris: compactness
15:42:35 <monochrom> The Phil Wadler opening sentence is: "Should I be pure or impure?"
15:42:42 <samreid> Toxaris:  I'll chime in:  they prevent you from making your language of acceptable inputs complicated.
15:42:43 <DaveCGI769> its like pattern matching for strings
15:42:47 <EvilTerran> they're a very expressive way of expressing string processing
15:43:35 <DaveCGI769> fast expressiveness is easier than writing a parser just to parse one simple string
15:44:03 <EvilTerran> bothering with a dedicated parser is premature optimisation in a lot of cases.
15:44:43 <anybody> yepee! thx. its working
15:44:56 <DaveCGI769> last time i used regexes was to parse the domain name out of a url, while also verifying it was a proper http url at the same time. this was only used once in the initialization of the program
15:44:59 <EvilTerran> although there'd be something to be said for compile-time regex parsing. maybe with TH.
15:45:17 <DaveCGI769> it was much easier than handwriting a recursive descent code
15:45:33 <osfameron> monochrom: yeah, perl supports many functional idioms.  (Though, as I've realised, not as nciely as haskell...)
15:45:36 <Toxaris> DaveCGI769: sure. nobody handwrites recursive descent code, everyone uses Parsex
15:45:39 <Toxaris> Parsec
15:45:47 <DaveCGI769> compile-time regex parsing would be great, it doesnt need to be perl-style at all ..
15:46:13 <DaveCGI769> Toxaris: oh sorry, this was in a C++ app actually, i havent had to parse anything in haskell yet
15:46:19 <litb> i don'T understand the lambda calculus business
15:46:32 <Baughn> It'd also fit neatly into a framework for general compile-time evaluation and runtime partial evaluation, if ghc had one
15:46:33 <monochrom> You are evil. All of you. Very evil ideas you have put forth.  (By "evil" I mean brilliant. I love all of you. :) )
15:46:38 <litb> for me it is just a "inline function"
15:46:51 <litb> where is the whole mathematical stuff there?
15:47:06 <DaveCGI769> the evaluation is mathematical
15:47:24 <DaveCGI769> you arent restricted to eager evaluation in lambda calculus
15:47:27 <mauke> guess who invented functions?
15:47:34 <EvilTerran> forth is an evil idea...
15:47:39 <ddarius> mauke: It wasn't Church.
15:47:42 <monochrom> hahahaha
15:47:44 <DaveCGI769> also in pure lambda calculus you only have the lambdas.... no literals of any kind sorry
15:47:59 <mauke> ddarius: one of his friends, then!
15:48:11 <Baughn> mauke: It'd have to be a ghost
15:48:15 <ddarius> mauke: The idea of a function is very very old.
15:48:36 <Baughn> ddarius: Is it, really?
15:48:37 <ddarius> Church certainly did much to advance and formalize computable functions though.
15:48:38 <Toxaris> ok, so the success of RegExp is based on (1) RegExp is a parser combinator aproach and (2) RegExp syntax is compact. for languages /= Haskell, (1) is better then all alternatives because there are no other combinator libraries. but in Haskell, RegExp needs (2) to win against Parsec & Co.
15:48:39 <monochrom> But the point is the idea came from math.
15:48:59 <Baughn> I'd have /expected/ the idea of functions to be a couple millenia old, but I'm not betting on anythong more than four or five hundred years
15:49:00 <ddarius> Baughn: It's not Pythagoras old, but it's certainly well before the 20th century.
15:49:18 <chessguy> > iterate (+2) 3
15:49:19 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
15:49:36 <DaveCGI769> how would you extract a domain name out of a http url with parsec?
15:50:00 <marcotmarcot> sorear: it's very simple html.. =D
15:50:14 <Toxaris> (and of course, RegExp matching is faster then general string matching. but who knows or cares... not even all RegExp implementors, from what I
15:50:17 <DaveCGI769> in regex its just /https?:\/\/([^\]*)\// and $1 has the domain name
15:50:18 <Toxaris> I've heard.
15:50:20 <ddarius> DaveCGI769: Since you can trivially embed regular expressions into Parsec, with no more effort than you would with regular expressions.
15:51:38 <DaveCGI769> you can do anything in anything, its just a matter of expressivity
15:51:52 <anybody> Baughn: function. 1964  Gottried Leibniz
15:52:07 <anybody> Baughn: arrrgh. 1694
15:52:09 <ddarius> DaveCGI769: You can't embed Parsec into regexes and further I said "trivially".
15:52:10 <sorear> anybody: Leibniz wasn't alive then
15:52:23 <anybody> sorear: yeah. typo
15:52:31 <Toxaris> DaveCGI769: something like   string "http://" >> (many (noneOf "/") `sepBy` char '.')
15:52:48 <oerjan> DaveCGI769: between (string "http" >> optional (char '?')) (char '\\') (many (noneOf "\\"))
15:53:10 <TSC> I think you'd want an optional 's', not '?'
15:53:17 <mauke> and /, not \
15:53:20 <oerjan> er, right
15:53:38 <Toxaris> it's an one-liner, as it should be
15:53:53 <oerjan> cannot read today
15:54:08 <monochrom> but can you parse today? :)
15:54:13 <puusorsa> and write?
15:54:24 <monochrom> Parsec. What do you want to parse today?
15:55:05 <Toxaris> unlike the RegExp aproach, it's Haskell, so it's typechecked etc.
15:55:10 <bitwiseshiftleft> question: if I declare a class Ref r m with an instance MonadIO io => Ref IORef io, why does it complain "No instance for (Ref r IO)"?
15:55:57 <monochrom> We should cook up some Microsoft mockery for Haskell stuff.  The slogan for Parsec may be: "What do you want to parse today?"  The slogan for Haskell itself may be: "The FUN starts now!"
15:56:25 <bitwiseshiftleft> monochrom: haha, SPJ can get right on that...
15:57:42 <chessguy> @type isNothing
15:57:46 <mauke> bitwiseshiftleft: hmm, maybe because r /= IORef?
15:57:49 <chessguy> @type isJust
15:57:50 <lambdabot> forall a. Maybe a -> Bool
15:57:52 <lambdabot> forall a. Maybe a -> Bool
15:57:59 <chessguy> @src isNothing
15:57:59 <lambdabot> isNothing Nothing = True
15:58:00 <lambdabot> isNothing _       = False
15:58:04 <chessguy> heh
15:58:09 <chessguy> @src isJust
15:58:09 <lambdabot> isJust Nothing = False
15:58:09 <lambdabot> isJust _       = True
15:58:30 <bitwiseshiftleft> mauke: r is arbitrary.  I'm just using Ref member functions on it
15:58:33 <oerjan> bitwiseshiftleft: without functional dependencies it cannot deduce IORef from IO or vice versa
15:58:46 <bitwiseshiftleft> oerjan: hm, ok
15:59:19 <bitwiseshiftleft> but, i cannot put a functional dependency on it, because i have ST and STM instances, and someone could declare those as MonadIOs later (even though they generally aren't)
15:59:50 <oerjan> bitwiseshiftleft: i think i have seen such a Ref class described as problematic to do
15:59:58 <bitwiseshiftleft> i see
16:00:51 <oerjan> also, note that the context on the left is never considered when matching instances
16:01:06 <bitwiseshiftleft> context on the left?
16:01:31 <oerjan> the MonadIO io is ignored until after the instance has been decided
16:02:07 <bitwiseshiftleft> i see
16:02:21 <bitwiseshiftleft> so i have to specify io in the instance declaration
16:05:43 <chessguy> @pl ie b pl pos = in (g b pl pos)
16:05:43 <lambdabot> (line 1, column 13):
16:05:43 <lambdabot> unexpected "="
16:05:43 <lambdabot> expecting variable, "(", operator or end of input
16:05:56 <chessguy> @pl ie b pl pos = iN (g b pl pos)
16:05:56 <lambdabot> ie = ((iN .) .) . g
16:06:34 <desp> 'Her parting remark was You know, Haskell actually never liked the name Haskell.'
16:06:38 * desp laughs
16:07:01 <chessguy> @pl h a b c = f (g a b c)
16:07:01 <lambdabot> h = ((f .) .) . g
16:07:08 <chessguy> is there really not a better way to write that?
16:07:23 <chessguy> i guess it's not quite f . g
16:08:17 <EvilTerran> some people @let (f .: g) x y = f (g x y), (f .:: g) x y z = f (g x y z), etc. you might be able to do something for the n-ary case with Applicative, alternatively.
16:08:42 <mauke> @where oleg
16:08:43 <lambdabot> http://okmij.org/ftp/
16:08:45 <chessguy> eww
16:08:50 <chessguy> thast's still pretty ugly
16:09:12 <Baughn> chessguy: I've been staring at that, and fail to see why it /isn't/ h = f.g. It'll probably come to me.
16:09:21 <chessguy> Baughn, yeah, i'm not sure
16:09:47 <chessguy> the only thing i can think is that it's because g is applied to all three args
16:09:55 <mauke> if it was, h a b would be f (g a) b
16:09:55 <chessguy> @src (.)
16:09:55 <lambdabot> (.) f g x = f (g x)
16:10:14 <mauke> i.e. all arguments after the first would be shoved into f
16:10:16 <mauke> not g
16:10:31 <Toxaris> f . g $ a b c  ==  f (g a) b c  /=  f (g a b c)
16:10:52 <chessguy> yeah, what Toxaris said
16:11:34 <mauke> chessguy: http://okmij.org/ftp/Haskell/types.html#polyvar-comp
16:11:35 <lambdabot> Title: Haskell Programming: Types
16:11:38 <Toxaris> hmm, but   f . g $ a b c  ==  f (g (a b c))   because of the $, but you say what I mean
16:11:39 <chessguy> funkinessocity
16:11:57 <dcoutts> @tell SyntaxNinja we need to do some cabal-devel mailing list admin tasks, apparently the cvs-ghc list lets through darcs patches, we should do the same
16:11:57 <lambdabot> Consider it noted.
16:12:00 <dcoutts> doh!
16:12:16 <chessguy> @slap dcoutts
16:12:16 <lambdabot> why on earth would I slap dcoutts
16:13:07 <dcoutts> @tell SyntaxNinja oops, duplicate message, but while I'm thinking about it, perhaps you can send me the cabal-devel mailing list admin passwd, I've only got the moderator passwd. I'd like to experiment with allowing non-subcribers to post again.
16:13:08 <lambdabot> Consider it noted.
16:13:20 <dcoutts> chessguy: :-)
16:13:29 <chessguy> mauke, "We need the extension of multi-parameter classes and functional dependencies."
16:13:32 <chessguy> mauke, ewww
16:13:45 <dcoutts> @slap dcoutts the muppet
16:13:45 <lambdabot> why on earth would I slap dcoutts the muppet
16:13:52 <chessguy> lol
16:14:00 <dcoutts> chessguy: lambdabot like me it seems :-)
16:14:03 <oerjan> @slap chessguy
16:14:03 * lambdabot beats up chessguy
16:14:07 * chessguy gries
16:14:10 <chessguy> cries, even
16:14:15 <dcoutts> @vixen you like me don't you :-)
16:14:15 <lambdabot> yeah, i like
16:14:21 <ddarius> Multi-Parameter Type Classes and Functional Dependencies naturally go together.
16:14:36 <chessguy> ddarius, yeah, but i generally stay away from extensions
16:14:37 <dcoutts> ddarius: or indexed type families
16:14:50 <mauke> chessguy: so you don't use monad transformers?
16:14:53 <chessguy> ddarius, since my haskell-fu isn't strong enough to have a clue what they do to my code
16:15:05 <Toxaris> chessguy: why? they make Haskell even more funny :)
16:15:07 <chessguy> monad transformers aren't H98?
16:15:18 <dcoutts> nope
16:15:20 <sorear> mauke: You don't need fancy extensions for monad transformers
16:15:29 <mauke> well, MonadReader/MonadState/etc are multiparameter classes
16:15:39 <sorear> you don't need them
16:15:42 <mauke> and Control.Monad isn't a H98 name
16:16:24 <chessguy> well, ok, i guess we need to distinguish between H98 and GHC without extensions
16:16:38 <ddarius> You could certainly use monad transformers without leaving H98 though it wouldn't be as much fun.
16:17:35 <chessguy> anyway
16:17:38 <chessguy> back to hacking :)
16:17:40 <Toxaris> chessguy: I don't understand all Haskell extensions, but I don't understand full H98, either. So why should I restrict myself to H98? Maybe some extensions are more important to learn then some features of H98? I like Haskell because it's a modern language. Why should I restrict to some outdated subset of it's current state?
16:18:11 * EvilTerran likes to do hairy things with multi-parameter typeclasses.
16:18:56 <chessguy> Toxaris, i guess i just don't want to write code that's dependent on extensions, when it could just as easily be written slightly differently, and not depend on extensions
16:19:10 <chessguy> out of ignorance on my part
16:20:32 <chessguy> plus, don't you lose some portability when you depend on extensions?
16:20:46 <sorear> I wish
16:21:01 <Toxaris> sure, my code could not be ported to one of the many existing non-ghc Haskell compilers like, hmm, yes, like all of them
16:21:02 <mauke> portability to what?
16:21:46 <chessguy> oh, i didn't think most compilers supported all the extensions
16:22:01 <mauke> what exactly do you mean by "most compilers"?
16:22:11 <chessguy> non-ghc
16:22:17 <mauke> ...
16:22:34 <peter_12> dow anyone know what GMP is and why I need it on my Mac to install Haskell?
16:22:39 <peter_12> *does
16:22:39 <chessguy> @where gmp
16:22:40 <lambdabot> I know nothing about gmp.
16:22:44 <mauke> peter_12: bignum library
16:22:50 <peter_12> ahh
16:23:10 <peter_12> mauke: thanks. now google can find it
16:23:13 <EvilTerran> hugs supports a few extensions...
16:23:50 <monochrom> GMP does the big-integer arithmetic.
16:24:36 <sorear> Why don't the Mac people ship GMP?
16:24:55 <chessguy> @pl gS b pl pos = case b | pos of { Nothing -> Nothing; Just p -> Just (pl ! p)
16:24:55 <lambdabot> (line 1, column 31):
16:24:55 <lambdabot> unexpected "{"
16:24:55 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
16:25:07 <chessguy> @pl gS b pl pos = case b | pos of { Nothing -> Nothing; Just p -> Just (pl ! p) }
16:25:07 <lambdabot> (line 1, column 31):
16:25:07 <lambdabot> unexpected "{"
16:25:07 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
16:25:09 <sorear> Do any other popular unixen not provide it as a first-class package?
16:25:10 <chessguy> sigh
16:25:13 <monochrom> Even many unix people don't use GMP.
16:25:41 <oerjan> chessguy: @pl doesn't do case
16:25:43 <balodja> chessguy: about @pl h a b c = f (g a b c). may be something like that: ((.) $ (.) $ (.) f) g
16:25:43 <sorear> chessguy: @pl doesn't do pattern matching to any significant deggree
16:25:46 <monochrom> Most unixen provide it as a first-class package, but still not installed automatically.
16:25:49 <zmike> 7/win 13
16:26:18 <oerjan> chessguy: try using liftM (pl !) (b | pos)
16:26:23 <mauke> it's "unices" :-)
16:26:36 <sorear> monochrom: But why don't they make it as easy as 'apt-get install libgmp3' is here ?
16:26:44 <chessguy> @type (|)
16:26:45 <sorear> it's not exactly a rare package
16:26:46 <lambdabot> parse error on input `|'
16:26:51 <sorear> chessguy: it's a syntax error
16:26:57 <monochrom> I really don't know.
16:27:00 <sorear> chessguy: | is an illegal operator
16:27:14 <chessguy> oerjan, did you mean b ! pos?
16:27:39 <puusorsa> sorear, like, "sudo port install gmp" ?
16:27:45 <sorear> chessguy: http://haskell.org/onlinereport/lexemes.html#sect2.4
16:27:46 <lambdabot> Title: Haskell 98 Lexical Structure
16:27:53 <puusorsa> gmp                            devel/gmp      4.2.1        GNU multiple precision arithmetic library
16:28:05 <monochrom> It's even harder to answer than "why don't highschools teach logic".
16:28:21 <sorear> puusorsa: Yeah, like that, except not requiring you to install a completely separate 3rd party package manager
16:28:22 <shachaf> Is there any @pl way to write (\(a,_,_) -> a) without defining a function like fst?
16:28:25 <chessguy> monochrom, i don't know, that one's pretty tough
16:28:37 <EvilTerran> shachaf, no.
16:28:44 <sorear> puusorsa: if you're going to do that, you might as well switch to one of the linux distros...
16:28:44 <puusorsa> well you need to install it anyway for osx to be usable
16:28:46 <shachaf> I didn't think there was.
16:28:54 <puusorsa> ..and i like osx
16:29:07 <oerjan> chessguy: i just copied you b | pos, which is a syntax error already
16:29:11 <oerjan> (i think)
16:29:19 <sorear> don't you lose almost all the niceness when you smash a Debian/ppc userland on top?
16:29:30 <puusorsa> debian?
16:29:35 <EvilTerran> shachaf, i think there are some general tuple manipulation functions available, but they're either limited ones involving a class Tuple or they use templates
16:29:42 <chessguy> oerjan, ah, yes, you did mean b ! pos then :)
16:29:46 <monochrom> "port" would be those *BSD's.
16:29:51 <rehges> gmp builds natively just fine on osx, no need for any of that darwinports nastiness
16:29:54 <puusorsa> nothing to do with debian
16:29:54 <chessguy> or rather, i did :)
16:29:55 <Lemon> Can two keys in a Data.Map point to the same value?
16:30:07 <oerjan> *your
16:30:08 <ddarius> Lemon: Why not.
16:30:14 <sorear> puusorsa: I know, I've only been usign Debian for 3-4 years now...  what a slipup
16:30:17 <Lemon> I mean, ONE AND THE SAME
16:30:23 <ddarius> Lemon: Why not?
16:30:28 <EvilTerran> Lemon, try it. see if anything explodes.
16:30:30 <monochrom> It can.
16:30:34 <samreid> Lemon: what do you mean, "one and the same"?
16:30:36 <EvilTerran> @docs Data.Map
16:30:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
16:30:39 <sorear> > M.fromList [(1,'a'), (2,'a')]  -- Lemon
16:30:41 <lambdabot>  fromList [(1,'a'),(2,'a')]
16:30:50 <chessguy> oerjan, shazam!
16:31:02 <monochrom> In fact, even M.fromList [(1,x), (2,x)] is just fine.
16:31:06 <puusorsa> what's nasty about darwinports?
16:31:12 <chessguy> @src liftM
16:31:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:31:18 <Lemon> "one and the same" as in if I modify the value via one key, the other key sees the change too.
16:31:28 <mauke> you can't modify values
16:31:29 * shachaf is on http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html now (though at the very bottom)... That may not be something to be proud of.
16:31:30 <lambdabot> Title: #haskell @ freenode.org stats by dons
16:31:35 <puusorsa> i've had an apple less than a year and i find it nice not nasty
16:31:46 <EvilTerran> > let m = M.fromList [(1,m)] in m
16:31:46 <lambdabot>      Occurs check: cannot construct the infinite type: a = M.Map t a
16:31:47 <lambdabot>       Ex...
16:31:49 <EvilTerran> aww.
16:31:50 <Toxaris> chessguy: are you aware that   case x of Nothing -> Nothing, Just x -> Just (f x)   is   fmap f x  or  liftM f x   or  f <$> x
16:31:55 <samreid> Lemon: maps don't let you modify values via keys.  Any "modification" operations on Data.Map maps will make a brand new map.
16:31:56 <elasticdog> puusorsa: macports now :-)
16:31:57 <mauke> a value just is.
16:31:58 <ddarius> Lemon: You can't modify them.
16:32:04 * sorear wonders if he's still the most prolific human
16:32:04 <chessguy> Toxaris, i am now :)
16:32:12 <Lemon> but I got a IORef (Map String (IORef LispVal))
16:32:17 <puusorsa> elasticdog, *ports, whatever, what's nasty about it?
16:32:22 <ddarius> Lemon: Which means nothing.
16:32:29 <Lemon> orz
16:32:36 <elasticdog> puusorsa: don't know...that's what I use too, and find it great for a number of applications
16:32:52 <mauke> Lemon: you can modify what an IORef refers to, but it's still the same IORef
16:32:57 <Lemon> yes
16:32:58 * chessguy is still trying to figure out why. 
16:32:58 <mauke> i.e. it should just work :-)
16:33:05 <Lemon> oh?
16:33:08 <puusorsa> rehges, sorear ?
16:33:10 <chessguy> @src (>>=) Maybe
16:33:10 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:33:18 <chessguy> @src Maybe (>>=)
16:33:19 <lambdabot> (Just x) >>= k      = k x
16:33:19 <lambdabot> Nothing  >>= _      = Nothing
16:33:28 <puusorsa> caffeine - do stupid things faster!
16:33:30 <chessguy> ah, that would do it
16:33:51 <Lemon> so you mean, if I got two keys that point to the same IORef inside that map, and I writeIORef a value into it via one key, the other key 'sees' it too?
16:33:54 <Toxaris> chessguy: a good rule of thumb seems to be: never use case for built-in datatypes like [], (,) or Mabye without looking for a builtin function wich abstracts the very pattern you want
16:33:55 <sorear> @all-dicts rehges
16:33:56 <lambdabot> No match for "rehges".
16:33:58 <sorear> puusorsa: ?
16:34:08 <ddarius> Lemon: They're the same IORef.
16:34:11 <mauke> Lemon: yes
16:34:17 <chessguy> Toxaris, interesting rule
16:34:22 <chessguy> @spell rehges
16:34:36 <puusorsa> someone please explain what's nasty about macports?
16:34:46 <Lemon> the problem is, though, that I have no idea how to make two keys point to the same IORef.
16:34:50 <chessguy> puusorsa, in another channel maybe
16:34:51 <ddarius> If you writeIORef r 3 >> readIORef (fst (r,10)), you're going to get 3. r == r == r.
16:35:12 <ddarius> :t Data.Map.insert
16:35:14 <lambdabot> forall k a. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
16:35:40 <Toxaris> chessguy: the same seems to be valid for do-notation and explicit recursion
16:35:43 <ddarius> Map.insert "foo" r (Map.insert "bar" r Map.empty)
16:35:48 <Lemon> ok, here...
16:36:05 <dcoutts> puusorsa: it can't be nasty, macports has got an up-to-date gtk2hs package :-)
16:36:31 <rey_> does anybody know of haskell implementations (or other functional languages) for tiny systems?
16:36:40 <rey_> I've been given a programmable gameboy cartridge
16:36:47 <hpaste>  OceanSpray annotated "lisp interpreter" with "(no title)" at http://hpaste.org/2210#a3
16:36:47 <Toxaris> chessguy: at least that's the direction my Haskell style is currently moving to. more one-line folds and use of Control.AbstractConcept, less explicit whatever
16:36:55 <dcoutts> rey_: you can get hugs for hand held things
16:37:06 <chessguy> Toxaris, sounds like a good direction to be moving in
16:37:07 <rey_> apparently a gameboy has a custom 8080 and 8k ram
16:37:10 <sorear> chessguy, puusorsa: #haskell-blah is for things like this
16:37:18 <OceanSpray> otz
16:37:26 <OceanSpray> anyways
16:37:26 <dcoutts> rey_: or yhc should also be portable to smaller devices, it uses a bytecode interpreter
16:37:31 <chessguy> sorear, excuse me?
16:37:40 <sorear> 16:34 < chessguy> puusorsa, in another channel maybe
16:37:52 <chessguy> oh, i thought you meant my discussion with Toxaris
16:38:05 <chessguy> i could care less what channel he takes it to, as long as it's not here
16:38:17 <OceanSpray> in envInsert, I used v <- liftIO (newIORef val)
16:38:23 <dcoutts> rey_: the yhc bytecode interpreter is fairly portable C, and you can compile on a more powerful machine so no need to get the actual yhc compiler running on the small box
16:38:25 <OceanSpray> and then just inserted that.
16:38:50 <peter_12_> when I do ./configure how can I tell where the readline library is on my computer? Seems that ./configure can't find it
16:38:58 <OceanSpray> now, of course, newIORef val creates a NEW IORef
16:39:11 <puusorsa> well rehges started it, if we have to start pasting what everyone said instead of just letting the subject go .. 022925  rehges> gmp builds natively just fine on osx, no need for any of that darwinports nastiness
16:39:44 <OceanSpray> what would be a good, easy way to insert synonyms?
16:39:52 <rey_> dcoutts: i don't think *real* haskells are possible
16:40:00 <mauke> OceanSpray: insert v again
16:40:01 <rey_> that's 8 KILOBYTE ram :)
16:40:03 <sorear> rey_: you'll definitely want yhi, since with Hugs you get the full parser overhead and can't cross-compile...  4369 stefan    18   0 21088  10m 1448 S  0.0  2.7   0:00.13 hugs
16:40:09 <sorear> rey_: 20M virt ;)
16:41:01 <dcoutts> rey_: yhc's bytecode interpreter is pretty smal I believe, how small do you need?
16:41:33 <wli> dcoutts: 8KB
16:41:41 <dcoutts> rey_: is that 8k for bytecode or also for the program code? everything in 8k?
16:41:49 <rey_> no, 8k ram, 32k rom
16:41:54 <dcoutts> ah ok
16:41:59 <dcoutts> that's not too bad then
16:42:09 <rey_> actually, more with bank switching
16:42:36 <rey_> I'm not quite sure what the card I have supports
16:42:40 <sorear> rey_: definitely look at nyhc and gofer
16:42:49 <dcoutts> the interpreter may well fit in 32k and the bytecode is fairly compact I believe, ask the yhc folk for more technical details
16:42:52 <rehges> puusorsa: any package in macports only works together with any other package in macports, that's what i hate about it.  plus, everything is installed in a different location from where everything (except macports stuff itself) expects it
16:43:17 <puusorsa> thanks <3
16:43:22 <rehges> and lastly, they build everything with quite a few patches applied, half of them wrong
16:43:33 <sorear> Hah, I tried to check how much memory yhi needed using a simple infinite loop program
16:43:39 <sorear> IT HAD A SPACE LEAK! :P
16:43:46 <dcoutts> uh oh :-)
16:43:57 <sorear> foo x = foo (x+1)
16:44:04 <rehges> puusorsa: this channel just scrolls to fast for me to reply quickly to everything -- by the time i notic my tab went blue the thing scrolled up five meters
16:44:14 <dcoutts> sorear: no tail recursion perhaps?
16:44:25 <oerjan> sorear: no strictness analysis?
16:44:45 <dcoutts> ah, definately no strictness analysis
16:44:51 <puusorsa> and i'd need to register to enable private messages.. bit inconvinient
16:44:51 <sorear> Anyways, with that leak fixed yhi is quite happy to run in 3K
16:44:57 <dons> ?users
16:44:57 <lambdabot> Maximum users seen in #haskell: 375, currently: 342 (91.2%), active: 25 (7.3%)
16:45:01 <dcoutts> so it's building a bigger and bigger thunk
16:45:08 <dcoutts> g'morning dons
16:45:43 <dons> hey dcoutts
16:45:54 <oerjan> so foo x = foo $! x+1 should work
16:46:19 <sorear> oerjan: yeah, that's what I'm using
16:46:26 <sorear> and it runs stably in 3K
16:46:29 <MarcWeber> dcoutts: Any plan how to proceed?
16:46:38 <sorear> 3K max heap means that I'd know if it was leaking :)
16:46:58 <dcoutts> MarcWeber: I think we should just duplicate the glib ghc package flags into the gtk ghc package
16:47:33 <dcoutts> MarcWeber: would you be able to test the darcs version of gtk2hs if I tried a patch for it?
16:47:48 <MarcWeber> Sure. Using darcs in nix is no problem :-)
16:48:01 <dcoutts> ok
16:48:41 <desp> "Later, Haskell added support for a third convention, literate comments, which first appeared in OL at the suggestion of Richard Bird. For obvious reasons, these non-comment indicators came to be called Bird tracks."
16:48:48 * desp laughs even more
16:49:00 <glguy> prod
16:49:02 <glguy> @users
16:49:02 <lambdabot> Maximum users seen in #haskell: 375, currently: 341 (90.9%), active: 29 (8.5%)
16:49:34 <sorear> desp: Reading AHoH?
16:49:42 <desp> sorear: yep
16:50:47 <mae> if i wanted to get a data structure in haskell that represents my nodes, attributes, and content for an xml document.. how could i do this? Haxml HXT and Text.Xhtml/Text.Html all are centered around combinators and i can't figure out where to get my hands on the raw structure that was output
16:51:34 <nornagon> data Tag a = Tag a [Tag a]?
16:52:11 <nornagon> oh, attributes and content
16:52:14 <nornagon> nevermind :/
16:53:15 <EvilTerran> mae, it depends heavily on how much detail you need, nornagon's suggestion being at one end and something that's aware of namespaces, <![CDATA[...]]> and whatnot at the other.
16:54:56 <mae> EvilTerran: i just need the names, attributes, and content..
16:55:00 <dcoutts> dons: btw, we've not explicitly decided who is giving the icfp talk, but I assume it's me so I'll start making some slides?
16:55:10 <mae> EvilTerran: and i need to be able to recursively traverse it
16:55:13 <MarcWeber> dcoutts: prepared.
16:55:19 <EvilTerran> actually, mae, in Text.HTML, the "toHtml" function seems it should yield a bunch of things you can pattern-match on
16:56:31 <EvilTerran> Text.XHtml, likewise.
16:57:30 <dcoutts> MarcWeber: I'm looking at other stuff atm, but if you want to patch it locally, try changing the lines in configure.ac about GTKHS_PACKAGE_FILTER_LIBS so that the second arg is always []
16:57:58 <monochrom> HaXml has a very elaborate data structure for representing XML parse trees. In fact, HaXml's combinators are so inexpressive that you must mess with the parse tree yourself.
16:58:22 <mae> EvilTerran: it outputs html? well i mean how can i view the structure when i run toHtml in ghci i just get the string put to stdout.. how can i see the structure?
16:58:46 <EvilTerran> mae, no, it outputs something of type "HTML", not of type "String".
16:58:47 <MarcWeber> dcoutts: Thanks. I'll try
16:59:08 <EvilTerran> HTML is a concrete datatype representing a parse tree, from what i can tell.
16:59:08 <narain> hi all, what's a good book to pick up category theory from?
16:59:14 <mae> EvilTerran: yeah something of type html.. its built up of [HtmlElement]
16:59:24 <mae> EvilTerran: how can i print out this structure?
16:59:26 <ddarius> Categories for the Working Mathematician.
16:59:32 <narain> john baez, the mathematical physicist, recommends lawvere and schanuel's "conceptual mathematics"
16:59:36 <narain> is that good?
16:59:56 <narain> ddarius: thanks, how is it?
17:00:07 <ddarius> A bunch of #haskellers read it together a long while back (not including me).  They didn't seem too impressed by it (Conceptual Mathematics)
17:00:30 <ddarius> narain: It's the "bible" of Category theory, but that said it's not as heavy as you would think.
17:01:12 <wli> I have never seen a category theory book that enlightened me.
17:01:22 <ddarius> It does use a lot of examples from other branches of mathematics.
17:01:23 <narain> would it be appropriate for a cat theory newbie?
17:01:25 <ddarius> wli: Me neither.
17:01:27 <desp> @quote hackery
17:01:27 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
17:01:49 <ddarius> narain: It depends on what other mathematics you know, your level of "mathematical maturity" and what you want to get out of it.
17:01:54 <wli> Categories for the Working Mathematicians has baffled me for the past decade.
17:02:17 <ddarius> wli: Really?  I've read much heavier things that it e.g. Toposes, Triples, and Theories.
17:02:20 <wli> And I'm not discernibly closer to getting through page 1 than I was when I bought it.
17:02:43 <wli> ddarius: Maybe I'm dumber. Maybe I'm lacking mathematical maturity. etc.
17:02:46 <ddarius> The Introduction is excellent.
17:03:07 <narain> ddarius: hmm, ok, i'll give it a look, thanks!
17:03:44 <ddarius> narain: One much easier and cheaper resource that I highly recommend is Barr and Wells' ESSLLI lecture notes.
17:04:24 <ddarius> http://folli.loria.fr/cds/1999/esslli99/courses/barr-wells.html
17:04:28 <lambdabot> Title: Courses: Barr / Wells
17:04:40 <narain> i'm not too worried about prices, i plan to pick up books from my univ library
17:05:01 <narain> but if the lecture notes are a gentler intro, that would be a plus
17:06:23 <ddarius> You are likely more versed in the examples Barr and Wells cover (which are CSy) than the ones Mac Lane covers.
17:06:55 <ddarius> However, it's missing some things and doesn't quite emphasize some aspects to my liking.
17:07:16 <narain> ah, i can see graphs and functional programming bits in there
17:07:43 <ddarius> graphs, FP, lambda calculus, state machines, automata etc.
17:07:59 <narain> nice... this looks like a great place to start
17:08:04 <narain> but eventually i'd like to go through a full mathematical book as well
17:08:38 <monochrom> I learned category theory from two sources. Richard Bird's "The Algebra of Programming" (costly book). M. M. Fokkinga's "A Gentle Introduction to Category Theory" (free downloadable).
17:09:06 * ddarius prefers working with the homs
17:09:08 <glguy> ?where xmonad
17:09:08 <lambdabot> http://xmonad.org/
17:09:18 * ddarius prefers working with the hom-sets rather than the mediating morphisms and initiality.
17:09:20 <OceanSpray> okay, I got this
17:09:23 <monochrom> They are FPers. Those two sources immediately apply to FP.
17:10:04 <OceanSpray> I jsut have to make envLookup return an IORef LispVal, and have envSet, envBind and envInsert take an IORef LispVal as an argument
17:10:09 <ddarius> I didn't read the Algebra of Programming, but Fokkinga's paper certainly doesn't go much beyond FP though.
17:10:21 <OceanSpray> that'll work, right?
17:10:36 <wli> I've got the Algebra of Programming. It completely blew me away in/around anything theoretical.
17:10:40 <narain> FP isn't my only motivation for category theory though
17:11:13 <ddarius> narain: What other directions do you want to go with it?
17:12:06 <narain> i also want to be able to read posts by john baez and the n-category cafe without 99% of it flying over my head :)
17:12:11 <monochrom> It took me three months to read three chapters of Algebra of Programming. :)  And I haven't dared read the rest. :) :)
17:12:18 <narain> ^^ mathematical physics
17:12:45 <narain> they're very big on category theory these days
17:12:56 <ddarius> narain: Some of them, yes.
17:13:55 <desp> wow, AHoH is excellent.
17:14:39 <narain> AHoH?
17:15:06 <desp> @where+ ahoh http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
17:15:06 <lambdabot> Done.
17:15:13 <narain> ah
17:15:21 <ddarius> desp: Did you ever read the Haskell Retrospective?
17:15:33 <desp> not yet
17:15:40 <ddarius> It's quite enjoyable.
17:15:53 <desp> I've just finished the OSCON talk, which referred me to AHoH
17:16:10 <desp> thanks for the recommendation
17:16:48 <desp> ddarius: you do mean the slides linked from the AHoH page?
17:18:58 <chessguy> @type fromMaybe
17:19:00 <lambdabot> forall a. a -> Maybe a -> a
17:19:11 <oerjan> @type maybe
17:19:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:19:23 <chessguy> @src fromMaybe
17:19:23 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
17:19:30 <chessguy> bah
17:19:42 <oerjan> @src maybe
17:19:42 <lambdabot> maybe n _ Nothing  = n
17:19:42 <lambdabot> maybe _ f (Just x) = f x
17:19:57 <chessguy> oerjan, i know what maybe is, and it's not what i want
17:19:58 <ddarius> desp: Yes.
17:20:22 <desp> chessguy: what do you want, then?
17:20:26 <oerjan> so what do you want? :)
17:20:28 <chessguy> @hoogle Maybe a -> a
17:20:28 <lambdabot> Maybe.fromJust :: Maybe a -> a
17:20:28 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
17:20:28 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:20:31 <chessguy> fromJust
17:20:41 <ddarius> narain: You may find the preprints here http://www.acsu.buffalo.edu/~wlawvere/downloadlist.html interesting if somewhat... weird. (Parts of it makes perfect sense and parts don't connect to anything for me.)
17:20:42 <lambdabot> Title: downloadlist.html
17:20:43 <oerjan> > fromJust Nothing
17:20:45 <lambdabot>  Exception: Maybe.fromJust: Nothing
17:20:54 <ddarius> The reprints are certainly worth reading.
17:20:54 <chessguy> i'm well aware of that
17:22:10 <narain> ddarius: i'm sorry, i've forgotten the context, what are those papers for?
17:22:51 <ddarius> CT + Physics
17:24:00 <narain> ah. thanks for the recommendation
17:27:18 <anybody> is there a function like forM that alows an additional predicate to break the loop?
17:27:38 <anybody> s/break/break out of/
17:28:13 <Tac-Tics> Why is it that the Report says that modules can be mutually recursive, but yet I am getting errors for cyclic import dependencies?
17:28:45 <monochrom> Some compilers e.g. GHC has not fully implemented that requirement.
17:28:55 <encryptio> Tac-Tics: the implementation of mutually recursive modules requires "boot" modules in the case of ghc.
17:28:58 <chessguy> @pl \x -> x .&. 0x88 == 0
17:28:58 <lambdabot> (0 ==) . (.&. 136)
17:29:15 <Tac-Tics> Boot modules?
17:29:27 <chessguy> @pl \x -> 0 = 0x88 .&. x
17:29:27 <lambdabot> (line 1, column 9):
17:29:27 <lambdabot> unexpected "="
17:29:27 <lambdabot> expecting variable, "(", operator or end of input
17:29:28 <oerjan> is there any working compiler that does implement it without further ado?
17:29:35 <chessguy> @pl \x -> 0 == 0x88 .&. x
17:29:35 <lambdabot> (0 ==) . (136 .&.)
17:29:45 <Tac-Tics> that seems like something kinda important to just "leave out" of your implimentation
17:29:58 <narain> does ?pl know that == is commutative?
17:30:14 <narain> how did it turn == 0 into 0 == the time before last?
17:30:16 <monochrom> I wouldn't know how to implement it.
17:30:33 <Twigathy> surprise butsechs
17:30:46 <xerox> narain: one clever guy wrote that :)
17:30:55 <Igloo> narain: It does know it, in as much as it is possible to know something that is false  :-)
17:31:28 <narain> Igloo: ?
17:31:45 <ddarius> anybody: Actually forM can do that.  Alternatively, you may find foldM or a use of foldr more direct.
17:31:52 <Igloo> narain: You can define (==) for a type such that it is non-commutative
17:32:06 <anybody> ddarius: how can forM do that?
17:32:14 <encryptio> Igloo: is that legal for the definition of the Eq class?
17:32:18 <ddarius> anybody: By the proper choice of monad.
17:32:18 <monochrom> Does it involve MonadPlus?
17:32:23 <monochrom> Ha!
17:32:33 <anybody> ddarius: Maybe monad?
17:32:36 <xerox> Igloo: ?pl will not support user-defined types, anyway.
17:32:38 <Igloo> encryptio: I don't know if the report mentions it or not
17:32:55 <ddarius> anybody: That would be one possibility depending on what you were going for.
17:33:05 <Igloo> ?pl \x y -> y == x
17:33:05 <lambdabot> (==)
17:33:12 <xerox> Or maybe it would, treating them... oh.
17:33:20 <monochrom> I believe it is expected that == is an equivalence relation.
17:33:34 <anybody> ddarius: hm. i already have a StateT. combinding this with maybe will make it too complicated for me ;-)
17:33:45 <anybody> s/combinding/combining/
17:33:47 <ddarius> And it's expected that (+) is associative, but we live with what we've got.
17:34:30 <chessguy_> err, how is it that i have to import Data.Map so that i always have to qualify anything i use from it?
17:34:45 <chessguy> wireless--
17:34:46 <chessguy> @bot
17:34:47 <lambdabot> :)
17:35:13 <ddarius> chessguy: You could hide a small chunk of the Prelude instead.
17:35:22 <monochrom> Data.Map contains name clashes with even the Prelude.
17:36:41 <monochrom> You could qualify the Prelude instead!  P.return (P.show P.Nothing)
17:36:43 <glguy> chessguy: are you asking how to import it?
17:36:49 <glguy> chessguy: or why that is the case
17:36:53 <chessguy> glguy, yes, how
17:37:02 <glguy> import qualified Data.Map as Map
17:37:07 <glguy> import Data.Map (Map)
17:37:10 <chessguy> hm, i'm doing that
17:37:35 <chessguy> but when i define a function called valid, it clashes with something in Data.Map
17:38:06 <chessguy> but i thought that if i were going to refer to Data.Map.valid, i would have to do Map.valid, so it shouldn't be ambiguous
17:39:24 <monochrom> I don't receive that error.
17:39:33 <glguy> chessguy: maybe you are importing in two places
17:39:35 <monochrom> import qualified Data.Map as M
17:39:40 <monochrom> valid = 5
17:39:45 <monochrom> Compiles fine.
17:40:19 * osfameron brute forces Euler 9 (pythagorean triple where a+b+c==1000), reads from forum that there is an elegant way to do it
17:40:46 <chessguy> @paste
17:40:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:40:53 <desp> @let n00b = nub
17:41:00 <lambdabot> <local>:23:7:     Ambiguous type variable `a' in the constraint:       `Eq a'...
17:41:16 <desp> aw
17:41:21 <xerox> osfameron: there it is <http://okmij.org/ftp/Haskell/FBackTrack.hs>
17:41:21 <monochrom> monomorph!
17:41:31 <hpaste>  chessguy pasted "namespace clash" at http://hpaste.org/2215
17:41:37 <desp> monochrom: perish!
17:41:39 <oerjan> @let n00b x = nub x
17:41:45 <lambdabot> Defined.
17:41:48 <chessguy> by the way, glguy, there's a bug in hpaste
17:41:53 <chessguy> C-y doesn't work :)
17:42:08 <monochrom> chessguy: line 5 spoils the show
17:42:22 <chessguy> augh!
17:42:25 <chessguy> how'd that get in there
17:42:35 <chessguy> son of a priest
17:42:41 <monochrom> bugs! they creep in behind your back! :)
17:43:08 <glguy> chessguy: C-y ?
17:43:26 <chessguy> glguy, emacs joke
17:43:44 <glguy> oh, I use linux and windows ;)
17:43:54 <monochrom> Hrm! Browser supposed to know C-y? :)
17:44:05 <chessguy> monochrom, that would be why it was a joke
17:44:08 <shachaf> glguy: p (or "+p) doesn't work, if you're a vi(m) user.
17:44:15 <shachaf> chessguy: That's the browser's job.
17:44:24 <xerox> Mine does :)
17:44:30 <shachaf> chessguy: All hpaste provides is the textarea.
17:44:33 <chessguy> xerox, does which
17:44:42 <chessguy> shachaf, it was a JOKE
17:44:53 <xerox> Safari knows C-y, that is.
17:44:56 <chessguy> > liftM humor #haskell
17:44:57 <lambdabot>   Not in scope: `haskell'
17:45:03 <chessguy> good grief
17:45:09 <glguy> chessguy: check your import ;)
17:45:10 <monochrom> I have a crazy idea! Add javascript to hpaste to support all major keybindings of all major editors! Just the keybindings for "paste" will do! C-y, Ctrl-V, Shift-Insert, etc.
17:45:23 <chessguy> glguy, hm?
17:45:30 <glguy> chessguy: "not in scope: haskell"
17:45:30 <encryptio> monochrom: "p" too?
17:45:31 <glguy> :)
17:45:37 <monochrom> Oh yeah!
17:45:37 <shachaf> monochrom: There's a javascript vi implementation.
17:45:37 <chessguy> ah
17:45:39 <osfameron> xerox: eeek!  that's a scary monady  version.  But apparentlt it's possible to rewrite the triple amd then solve the problem algebraically without recursion.
17:45:40 <ihope> > #haskell
17:45:40 <lambdabot>  Parse error
17:45:45 <oerjan> > map #map
17:45:46 <lambdabot>   Not in scope: `#'
17:45:52 <ihope> > haskell#
17:45:52 <lambdabot>  Parse error
17:45:57 <ihope> Mph.
17:46:02 <xerox> osfameron: well, there's a parametrization that gives you them all, indeed.
17:46:21 <oerjan> let m #n = m+n in 1 #2
17:46:34 <oerjan> > let m #n = m+n in 1 #2
17:46:35 <lambdabot>  3
17:46:40 <monochrom> Hrm! Browser's job is to come up with emacs jokes?  (duck)
17:47:09 * chessguy throws small farm animals in monochrom's direction
17:47:13 <shachaf> monochrom: Emacs does that very well itself.
17:47:28 <monochrom> emacs is a browser too...
17:47:40 <shachaf> monochrom: Emacs is also a joke. :-)
17:47:53 <glguy> ?remember shachaf  monochrom: Emacs is also a joke. :-)
17:47:53 <lambdabot> Done.
17:47:55 <monochrom> you will win lots of enemies for that... :)
17:47:55 <chessguy> uh-oh
17:48:09 * glguy needed a good ?quote emacs
17:48:12 * chessguy dives for cover
17:48:14 <chessguy> @quote emacs
17:48:15 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
17:48:18 * shachaf regrets it already.
17:48:24 <glguy> @quote emacs
17:48:24 <lambdabot> emu says:  it's translating to chinese? emacs has become sentient?! and it's a grad student?!
17:48:28 <shachaf> @help forget
17:48:29 <glguy> @quote Emacs
17:48:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:48:29 <lambdabot> emu says:  it's translating to chinese? emacs has become sentient?! and it's a grad student?!
17:48:39 <ddarius> osfameron: Hmm, a+b+c=1000 makes a,b,c puts a,b,c in a barycentric coordinate system.
17:48:42 <glguy> shachaf: looks like you are safe, there's a lot of noise
17:48:55 <shachaf> @forget
17:48:55 <lambdabot> Unknown command, try @list
17:48:57 <shachaf> @uptime
17:48:57 <lambdabot> uptime: 6d 13h 20m 46s, longest uptime: 1m 10d 23h 44m 29s
17:49:05 <glguy> @quote joke
17:49:05 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
17:49:13 <osfameron> ddarius: huh?
17:49:35 <wli> Well, a^2+b^2=c^2 and a+b+c=1000 gives a^2+b^2=(1000-a-b)^2
17:49:43 <glguy> @quote vim
17:49:43 <lambdabot> No quotes match. You speak an infinite deal of nothing
17:49:58 <shachaf> vim++
17:50:22 <shachaf> It hasn't made any enemies, see?
17:50:58 <monochrom> infinity * 0 = ?
17:51:07 <oerjan> > [(m,n) | m <- [1..999], n <- [1..999], m^2+n^2 == (1000-m-n)^2]
17:51:11 <lambdabot>  [(200,375),(375,200)]
17:51:13 <ddarius> osfameron: I want to see if I can visually "see" the result.
17:51:50 <desp> @quote vim
17:51:50 <lambdabot> No quotes match. That's something I cannot allow to happen.
17:52:04 <osfameron> oerjan: yeah, the forums rewrite the triples in terms of "m" and "n" - is that a standard notation?
17:52:21 <desp> actually, all OS X programs know C-y
17:52:28 <desp> s/all/all good Cocoa/
17:52:31 <oerjan> osfameron: m and n are the default arbitrary integers in math :)
17:52:38 <desp> and other emacs key bindings
17:52:41 <osfameron> "every pytagorean triple can be written as  k { m^2 - n^2, 2 m n , m^2 + n^2 }"
17:52:54 <desp> and using some nifty Cocoa tricks, you can even do the same for vim key bindings
17:53:16 * desp pokes monochrom
17:53:28 <wli> Perhaps they're integer solutions to ab = 500000
17:53:28 <monochrom> yes desp?
17:53:44 <osfameron> oerjan: oh!  I always used x,y,z or i,j,k... or maybe I didn't, haven't studied maths for a long time
17:53:47 <desp> monochrom: just getting your attention re the browser hrm
17:53:53 <tga> in something like 'b f = f (\ x -> \y -> x)' why does the last 'x' make sense? shouldn't it be a 'y'?
17:54:06 <monochrom> Interesting.
17:54:12 <shachaf> oerjan: Isn't n usually first?
17:54:17 <oerjan> osfameron: well, i,j,k work too
17:54:31 <monochrom> tga: the author wants to say "ignore parameter y".
17:54:38 <oerjan> shachaf: if it's alone, but if they are two m is next
17:54:50 <monochrom> E.g., one way to define "const" is: const x y = x.
17:55:31 <tga> monochrom: but in the function y why is x still defined? isn't y something like y(y) = (something to do with y)?
17:55:45 <monochrom> ???????
17:56:05 <shachaf> > (\x -> (\y -> x + y)) 5 3
17:56:06 <glguy> tga: \ x -> \ y -> whatever   -- is -- \ x y -> whatever
17:56:07 <lambdabot>  8
17:56:24 <monochrom> there is no function y.
17:56:36 <tga> d'oh. got it, thanks
17:57:05 <oerjan> tga: an expression inside \y -> ... can use any variables available from further out as well
17:57:21 <ddarius> :t curry -- tga: ponder this
17:57:23 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:57:41 <shachaf> :type should work.
17:58:04 <tga> I guess I knew this from reading :types but the lambdas put me off
17:58:53 * tga digs further into tutorials
17:59:09 <oerjan> shachaf: when i name variables starting with x, i usually go x,y,z,w,v...
17:59:14 <glguy> :t \ f -> \ a -> \ b -> f (a,b)
17:59:16 <lambdabot> forall t t1 t2. ((t, t1) -> t2) -> t -> t1 -> t2
17:59:26 * monochrom tosses more sugar lambdas to the channel for greater confusion :)
17:59:33 <glguy> @yow
17:59:34 <lambdabot> My EARS are GONE!!
18:00:20 <ddarius> Hmm, looking at Math World apparently you could look for the symmedian point.
18:00:27 <oerjan> mm, sugar lambdas
18:06:12 <sorear> @users
18:06:12 <lambdabot> Maximum users seen in #haskell: 375, currently: 341 (90.9%), active: 19 (5.6%)
18:06:35 <sorear> @uptime
18:06:35 <lambdabot> uptime: 6d 13h 38m 23s, longest uptime: 1m 10d 23h 44m 29s
18:07:33 <oerjan> @ultima
18:07:33 <lambdabot> uptime: 6d 13h 39m 22s, longest uptime: 1m 10d 23h 44m 29s
18:13:39 <wli> a=r+s+1000, b=s-r+1000, then they're on the hyperbola s^2 - r^2 = 500000
18:15:56 <tga> reality check: is b :: ((t -> t1 -> t) -> t2) -> t2 equivalent to b(f(g(x,y)))?
18:16:29 <wli> a=r+1000, b=s+1000, it's the hyperbola r*s=500000
18:16:46 <oerjan> @djinn ((t -> t1 -> t) -> t2) -> t2
18:16:49 <lambdabot> f a = a (\ b _ -> b)
18:17:11 <tga> mm, neat, can I do this in ghci?
18:17:41 <glguy>  @djinn is not native to ghci
18:17:55 <glguy> @help djinn
18:17:56 <lambdabot> djinn <type>.
18:17:56 <lambdabot> Generates Haskell code from a type.
18:17:56 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:18:17 <glguy> but the source is available there
18:18:23 <glguy> so you could probably still run that in ghci
18:18:24 <tga> cool
18:18:35 <oerjan> @where ghci-on-acid
18:18:36 <lambdabot> I know nothing about ghci-on-acid.
18:18:38 <tga> well, that's what my definition here was and I was wondering what it does exactly
18:18:40 <tga> then what would  b f = f (\ x -> \ y -> x) do?
18:18:46 <ddarius> There is also GHCi on Acid that puts the power of lambdabot into GHCi.
18:18:57 <tga> ah, I found that online
18:19:04 <tga> I think I have it downloaded someplace
18:19:06 <oerjan> well, that is b f = f const
18:19:11 <glguy> that takes a function, and applies it to const
18:19:26 <ddarius> @. free type let b f = f const in b
18:19:28 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:19:33 <oerjan> @pl b f = f const
18:19:33 <lambdabot> b = ($ const)
18:19:42 <ddarius> @free ($ const)
18:19:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:19:51 <ddarius> Stupid foralls
18:19:56 <ddarius> :t ($ const)
18:19:58 <lambdabot> forall b a b1. ((a -> b1 -> a) -> b) -> b
18:20:05 <ddarius> @free ((a -> b1 -> a) -> b) -> b
18:20:06 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:20:16 <glguy> @free map f xs
18:20:16 <lambdabot> Extra stuff at end of line
18:20:18 <ddarius> @free f :: ((a -> b1 -> a) -> b) -> b
18:20:18 <lambdabot> (forall f1 f2. (forall x. g . f1 x = f2 (g x) . h)               =>                k (p f1) = q f2) => k (f p) = f q
18:20:28 <tga> so basically that function only gets the first parameter?
18:21:02 <ddarius> const returns it's first parameter and discards it's second.
18:21:44 <ddarius> Which is to say, for any x, const x is "constantly" x
18:22:01 <oerjan> @where+ ghci-on-acid http://www.cse.unsw.edu.au/~dons/code/goa/
18:22:01 <lambdabot> Done.
18:22:15 <hpaste>  tga pasted "(no title)" at http://hpaste.org/2216
18:22:19 <glguy> > let b f = f const in b (\ sel -> sel 1 2 )
18:22:20 <lambdabot>  1
18:22:24 <tga> this is what I'm trying to figure out
18:22:26 * sorear thinks that his job as lambdabot tech support would be much easier if GoA was never written
18:23:02 <oerjan> @where ghci on acid
18:23:02 <lambdabot> I know nothing about ghci.
18:23:15 <sorear> tga: b (a 7 8), reduce the left outermost redex
18:23:17 <glguy> tga: a 7 8     takes a function, and applies it to 7 8
18:23:43 <sorear> tga: a 7 8 (\ x -> \y -> x) , reduce left outermost redex
18:23:56 <sorear> tga: (\ x -> \y -> x) 7 8 , reduce left outermost redex
18:24:05 <sorear> tga: (\y -> 7) 8 , reduce left outermost redex
18:24:13 <sorear> tga: 7 , done.
18:24:26 * tga digesting
18:26:13 <wli> [(i, j) | i <- [0..5], j <- [0..6], (i, j) < (5 - i, 6 - j), let (a, b) = (1000 - 2^i*5^j, 1000 - 2^(5-i)*5^(6-j)) in a^2 + b^2 == (1000 - a - b)^2 && a > 0 && b > 0 && a + b < 1000]
18:26:22 <tga> ah, a 7 8 is _applied to_ the lambda stuff
18:26:47 <sorear> yes.
18:27:26 <tga> the 'reduce left' method helps a lot with understanding things like this
18:31:07 <wli> I suppose one could more generally consider triples (x, y, z) which solutions of some homogeneous quadratic form lying on some plane.
18:31:59 <anybody> !quit
18:33:04 <glguy> :t flip . flip id
18:33:06 <lambdabot> forall b c a. a -> b -> (a -> b -> c) -> c
18:33:13 <wli> Even more generally, integer points in the intersection of a quadric over Z[x,y,z] with a linear form in Z[x,y,z].
18:36:57 <oerjan> @. pl djinn a -> b -> (a -> b -> c) -> c
18:36:57 <lambdabot> f = flip . flip id
18:37:02 <wli> Or whatever.
18:37:30 <glguy> @djinn a -> b -> (a -> b -> c) -> c
18:37:30 <lambdabot> f a b c = c a b
18:41:51 <hpaste>  aleko_ pasted "Arrow combinator for n-ary functions" at http://hpaste.org/2217
18:42:20 <aleko_> i'm new to arrows, but I wrote an interesting combinator. could somebody take a look at it?
18:42:27 <tga> I'm not having much luck with google.. what does (a.b.c) notation do again?
18:42:45 <aleko_> it's so simple, I'm sure it's been done before, but I don't know where to look to find out
18:43:01 <aleko_> thanks in advance
18:43:09 <matt__r> haskell module strangeness.....
18:43:12 <shapr> @users
18:43:12 <lambdabot> Maximum users seen in #haskell: 375, currently: 340 (90.7%), active: 13 (3.8%)
18:43:28 <tga> when a, b, c are functions
18:43:30 <oerjan> @src (.)
18:43:30 <lambdabot> (.) f g x = f (g x)
18:43:35 <tga> ah
18:43:41 * tga figured as much, just couldn't find it anywhere
18:43:43 <matt__r> I have a module `Test.TestIntegration` (in a file called TestIntegration.hs, in a Folder called Test)
18:43:55 <matt__r> In the same folder I have Test.Tests in file Tests.hs
18:43:58 <aleko_> it basically does &&&, but over any number of parameters (not just 2), and doesn't create a tuple
18:44:22 <monochrom> Functional programming "a . b . c" is like Unix shell scripting "c | b | a"
18:44:27 <matt__r> but I can't get ghci to load Tests.hs since it can never resolve the import of Test.TestIntegration
18:45:09 <matt__r> No matter what combination of Test.TestIntegration, TestIntegration, module Test..... I use
18:45:16 <tga> neat, so it's like c(b(a(args)))
18:45:29 <glguy> arg
18:45:37 <monochrom> Err a(b(c(args)))
18:45:52 <tga> uh, okay
18:46:08 <monochrom> In "c | b | a" the implicit input is from stdin.
18:46:34 <monochrom> In "a . b . c" the input is not present yet.
18:48:53 <aleko_> is anyone familiar with arrows?
18:48:55 <balodja> every object in shell has input(domain) and output(kodomain)? :))
18:49:06 <balodja> That's shell category :)
18:49:29 <glguy> kodomain, does that only hold in ksh?
18:49:30 <monochrom> Yes balodja :)
18:49:32 <oerjan> matt__r: what happens if you put a Main module importing them in the right spot?
18:49:40 <monochrom> hhahahaha
18:50:00 <monochrom> aleko_: I hope I am familiar with arrows enough.
18:50:10 <matt__r> oerjan: Tests.hs is that main module, I guess I can't work out what the right spot is
18:50:12 <aleko_> great
18:50:52 <aleko_> if you have a little time, could you give me your thoughts on what I pasted? (hpaste.org/2217)
18:51:06 <oerjan> matt__r: i mean, perhaps it is misinterpreting your directory structure because your initial file is not at the "top" level? (i am guessing)
18:51:21 <aleko_> it's like &&&, but for any number of parameters, and doesn't output a tuple
18:51:24 <matt__r> oerjan: yeah - you could be right, I will fiddle with that now
18:51:46 <aleko_> I'd much appreciate it
18:53:11 <oerjan> matt__r: try the -i option
18:54:14 <matt__r> oerjan: -i ??
18:54:43 <oerjan> -idirs This flag appends a colon-separated list of dirs to the search path.
18:55:05 <matt__r> oerjan: ahh - thankyou
18:55:28 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path
18:55:30 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/2y3hr6
18:55:52 <FMota> wow, big stepp up from #forth
18:55:58 <monochrom> I'm thinking how to use >>: for more things.
18:56:08 <FMota> there's 15x more people in here
18:56:18 <FMota> *step
18:56:22 <aleko_> monochrom: what do you mean? it can handle any number of parameters
18:56:41 <monochrom> Yes, I'm thinking how to use it to that end.
18:57:11 <monochrom> arr (2+) >>: arr (3+) >>: arr (4+) >>: multi (what do I do here?)
18:57:41 <aleko_> you stick a 3-ary function
18:57:58 <aleko_> multi just wraps a function so it can be used with the >>: combinator
18:58:07 <oerjan> FMota: fortunately not everyone tends to talk at the same time
18:58:26 <FMota> yes, that would make it very confusing :o
18:58:46 <matt__r> oerjan:  thanks for your help
18:59:04 <oerjan> matt__r: you're welcome, i take it worked then?
18:59:09 <aleko_> you can then pipe the output with >>>, just like normal
18:59:41 <matt__r> oerjan: in the end the problem was that ghci was loading the package with Test.TestIntegration that I have previously installed with setup install (and forgot about).  With -hide-package .. I got it to work the way I wanted.
19:00:16 <newsham> http://www.youtube.com/watch?v=6BEsZMvrq-I
19:00:31 <oerjan> matt__r: oh :)
19:00:40 <desp> "attempting to use module `Euler.Uncommon' (Euler/Uncommon.hs) which is not loaded"
19:00:51 <desp> any ideas why ghci doesn't just load the module automatically?
19:00:59 <desp> that's just mean
19:01:03 <aleko_> monochrom: arr (2+) >>: arr (3+) >>: arr (4+) >>: multi (\x y z -> x + y + z) >>> arr (show)
19:01:09 <aleko_> contrived example
19:01:13 <monochrom> I'm doing: runA (arr (2+) >>: arr (3+) >>: arr (4+) >>: multi (\x y z -> (x,y,z))) 2.  It gives (6,5,4) rather than (4,5,6).
19:01:15 <matt__r> desp: what does ghc-pkg list tell you ?
19:01:29 <desp> "I know this is a module, I know where it is, but I'm going to make you type :load ThatModule anyway"
19:01:41 <aleko_> oh, dang - forgot to mention. the parameters go in backwards.
19:01:49 <desp> matt__r: that's not a registered module
19:01:49 <monochrom> hehe ok
19:01:56 <aleko_> i have 2 solutions for fixing it
19:01:57 <desp> it's simply my local module
19:01:57 <monochrom> This is nice.
19:01:58 <matt__r> desp: ghci normally will load them for you
19:02:05 <aleko_> oh, well thanks
19:02:14 <matt__r> desp: oh
19:02:17 <OceanSpray> oh hey, it works now
19:02:18 <monochrom> You do not need "returnA >>>" in your tests.
19:02:32 <aleko_> and thank you again
19:02:44 * aleko_ slaps himself
19:02:53 <chessguy> @pl \x -> p x == t s
19:02:53 <lambdabot> (t s ==) . p
19:03:03 <chessguy> @pl \x -> t s == p x
19:03:03 <lambdabot> (t s ==) . p
19:03:21 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2218
19:03:30 <aleko_> i was thinking if I un-reverse the order, so that the function appears first, followed by its parameters, we could do a currying kind of thing
19:03:33 <monochrom> Nice, arr (2+) >>: arr even >>: arr (4+) >>: multi (\x y z -> (x,y,z))  also works. The components can be of different types.
19:03:48 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/2218#a1
19:03:49 <FMota> :/ I dislike funny syntax
19:03:56 <aleko_> @src even
19:03:57 <lambdabot> even n = n `rem` 2 == 0
19:04:03 <aleko_> ah
19:04:10 <OceanSpray> now, about this thing
19:04:22 <newsham> ?type not.even
19:04:24 <lambdabot> forall a. (Integral a) => a -> Bool
19:04:25 <OceanSpray> that dude from defmacro.com wrote his interpreter in 177 lines
19:04:38 <OceanSpray> I've got 237, and I'm not even done yet
19:04:46 <OceanSpray> what's going on?
19:04:53 <OceanSpray> how can I cut down on the LOC?
19:04:56 <newsham> ?type id.com
19:04:58 <lambdabot> Not in scope: `com'
19:04:59 <aleko_> if the order is un-reversed: multi (+) >: arr (2+)
19:05:09 <aleko_> you can return that, then finish it with another >:
19:05:11 <oerjan> FMota: are you the guy who made V?
19:05:21 <FMota> yes
19:05:23 <ddarius> aleko_: Consider how multi relates to the S combinator.
19:05:28 <FMota> it was an inspiration :/
19:05:41 <oerjan> FMota: i made a Haskell implementation of it
19:05:59 <FMota> oerjan: I saw that! Thank you!
19:06:01 <ddarius> Also consider unfolding some of the definitions of the ArrowApply operators for that (trivial) Arrow.
19:06:22 <FMota> I have no idea how to program in it, though. Its such a silly language.
19:06:25 <aleko_> *thank* you. I knew it had probably been done before
19:07:16 <tga> euh.. what does this mean exactly?
19:07:25 <tga> lambdabot: f $ x = f x
19:07:57 <ed1t> im trying to build my own calculator program like as "my own programming language
19:08:17 <ed1t> and i guess i need a parser....does anybody know of haskell parser
19:08:53 <OceanSpray> parsec
19:09:07 <TSC> tga: $ applies a function to an argument, so "f $ x" has the same effect as "f x"
19:09:23 <tga> TSC: why would anyone ever use it?
19:09:37 <monochrom> tga: That means if you write sin $ (x+y) it becomes sin (x+y). What's the point? The precedence of $ is set up so that you can just write sin $ x + y, no parenthesis necessary. That's all to it.
19:09:37 <aleko_> ddarius: from a googling, the S combinator looks exactly like my >: combinator
19:09:41 <aleko_> right?
19:09:54 <tga> got it, thanks
19:10:52 <TSC> tga: Apart from the precedence convenience, you can use it as an operator section
19:11:09 * Toxaris sometimes uses map ($ x)
19:11:16 <TSC> > map ($2) [even, odd]
19:11:18 <lambdabot>  [True,False]
19:11:25 <glguy> > sequence [even, odd] 2
19:11:26 <lambdabot>  [True,False]
19:11:34 <tga> yup, I found it used with map too
19:12:30 <Toxaris> > [even, odd] <*> Control.Applicative.pure 2 -- but this is cooler
19:12:31 <lambdabot>  [True,False]
19:13:25 <oerjan> > zipWith ($) [even, odd] [10,11]
19:13:27 <lambdabot>  [True,True]
19:13:40 <aleko_> well, thank you monochrom and ddarius, I have to go.
19:15:07 <Toxaris> aleko_: i'm absolutely not sure, but may it be that your combinator is equivalent or related to   \f g -> f &&& g >>> app  ?
19:15:19 <Toxaris> hmm too late
19:19:28 <ikegami--> @djinn (a -> b) -> (a, a) -> (b, b)
19:19:29 <lambdabot> f a (b, _) = (a b, a b)
19:22:15 <anybody> @dice
19:22:16 <lambdabot> unexpected end of input: expecting number
19:22:18 <Toxaris> > let f >>: g = f &&& g >>> app in const (+) >>: (+ 2) >>: (+ 3) $ 2
19:22:19 <lambdabot>  9
19:22:20 <anybody> @dice 2
19:22:20 <lambdabot> 2 => 2
19:22:24 <anybody> @dice 2
19:22:25 <lambdabot> 2 => 2
19:22:40 <anybody> @dice [1..6]
19:22:40 <lambdabot> unexpected "[": expecting number
19:22:49 <oerjan> @dice 2
19:22:49 <lambdabot> 2 => 2
19:22:54 <oerjan> @dice 100
19:22:54 <lambdabot> 100 => 100
19:22:58 <glguy> @dice d6
19:22:58 <lambdabot> unexpected "d": expecting number
19:23:00 <anybody> @dice help
19:23:00 <lambdabot> unexpected "h": expecting number
19:23:04 <glguy> @help dice
19:23:04 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
19:23:05 <anybody> @help dice
19:23:05 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
19:23:14 <glguy> @dice 1d6
19:23:14 <lambdabot> 1d6 => 3
19:23:56 <anybody> @dice 2d6
19:23:56 <lambdabot> 2d6 => 6
19:24:10 <anybody> @dice 3d6
19:24:10 <lambdabot> 3d6 => 14
19:24:18 <anybody> ha
19:24:40 <Toxaris> let f >>: g = f &&& g >>> app in const (,,) >>: (+ 2) >>: even >>: (+ 3) $ 2
19:24:43 <Toxaris> > let f >>: g = f &&& g >>> app in const (,,) >>: (+ 2) >>: even >>: (+ 3) $ 2
19:24:44 <lambdabot>  (4,True,5)
19:25:56 <anybody> @help bf
19:25:57 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
19:28:42 <glguy> the email, the email
19:29:52 <oklopol> @bf ++++++++[>++++++++<-]>+.+..-.
19:29:52 <lambdabot>  fd:25: hClose: resource vanished (Broken pipe)
19:30:03 <oklopol> i see :)
19:30:39 <oerjan> same as the @unlambda bug?
19:31:44 <oklopol> hmm
19:31:56 <oklopol> @unlambda `.ii
19:31:57 <lambdabot>  fd:25: hClose: resource vanished (Broken pipe)
19:32:01 <oklopol> ...
19:32:26 <oklopol> i do not exactly know what that means
19:32:46 <jsnx> :h @unlambda
19:32:57 <jsnx> :q
19:33:03 <jsnx> :lolz
19:33:21 <mm_freak_> @unlambda 1
19:33:21 <lambdabot>  fd:25: hClose: resource vanished (Broken pipe)
19:33:25 <oerjan> presumably the plugins have a common I/O problem
19:33:43 <oerjan> oh, it doesn't even get past parsing...
19:33:56 <oklopol> or then that's just what they want us to think.
19:33:58 <oerjan> (1 is not a legal unlambda program)
19:34:24 <mm_freak_> i don't even know what @unlambda does
19:34:29 <mm_freak_> @pl foo x = foo
19:34:30 <lambdabot> foo = fix const
19:34:34 <oerjan> @help unlambda
19:34:34 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
19:34:35 <oklopol> interprets an unlambda program
19:34:37 <jfredett> evaluates an unlambda expression, mm_freak
19:34:43 <jfredett> @google unlambda
19:34:45 <glguy> oklopol: it probably tries to do something with those handles, and then start interpreting the unlambda program
19:34:46 <lambdabot> http://www.madore.org/~david/programs/unlambda/
19:34:46 <lambdabot> Title: The Unlambda Programming Language
19:35:31 <sorear> oerjan: unlambda quite simply doesn't exist - dons forgot to install t
19:35:35 <phobes> How long will it take me to write a non-optimizing haskell compiler?
19:35:54 <oklopol> exactly 71 hours.
19:35:58 <oerjan> sorear: oh, strange error message though
19:35:58 <sorear> phobes: Much longer if you're a slacker like me
19:36:22 <sorear> oerjan: Not really.  Broken pipe is the tradition UNIX program-not-found error
19:36:43 * sorear has been slacking on Qhc for ~3 months now
19:37:07 <phobes> sorear: this is your haskell compiler?
19:37:13 <sorear> yes
19:37:18 <phobes> Non-optimizing?
19:37:20 <sorear> yes
19:37:27 <phobes> What are you targetting?
19:37:44 <sorear> the York bytecode machine
19:37:57 <phobes> How many LoC so far?
19:39:11 <sorear> stefan@stefans:~/qhc$ zcat _darcs/patches/*.gz | wc -l
19:39:11 <sorear> 1663
19:39:36 <sorear> I keep throwing away designs, though, so the actual maintaince load is much smaller.
19:39:55 <jsnx> sorear: what are you writing it in?
19:40:07 <phobes> java
19:40:46 <sorear> Haskell!
19:40:59 <phobes> sorear:  are you just handling haskell98?
19:41:07 <Toxaris> > let f >>: g = unwrapArrow $ WrapArrow f <*> WrapArrow g in const (+) >>: (+ 2) >>: (+ 3) $ 2
19:41:09 <lambdabot>  9
19:41:50 <Toxaris> > let f >>: g = unwrapArrow $ WrapArrow f <*> WrapArrow g in const (,,) >>: (+ 1) >>: (+ 2) >>: (+ 3) $ 2
19:41:52 <lambdabot>  (3,4,5)
19:43:36 <hpaste>  Toxaris annotated "Arrow combinator for n-ary functions" with "(>>:) is simply (<*>) for WrappedArrow as declared in Control.Applicative" at http://hpaste.org/2217#a2
19:45:49 <phobes> sorear: thanks for the info - I'll spend the next 71 hours coding and report back whether I'm a slacker
19:53:51 <jsnx> how do monads and continuations relate to one another?
19:54:15 <wli> Continuations are an instance of monads. There are continuation monads.
19:54:26 <wli> e.g. ContT
19:54:30 <sorear> All monads are continuations.
19:55:08 <jsnx> so, all continuations are monads and all monads are continuations?
19:55:18 <jsnx> continuations == monads ?
19:55:41 <wli> jsnx: I'd trust sorear above/beyond my own statement.
19:55:44 <sorear> jsnx: Are you familiar with Cayley's theorem?
19:55:45 <oerjan> @src ContT
19:55:45 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
19:56:28 <sorear> jsnx: It's sortof like the relationship between Turing machines and general machines
19:56:30 <jsnx> oerjan: why doesn't it say (Monad => m) ?
19:56:34 <jsnx> sorear: no
19:56:55 <sorear> jsnx: All Turing machines are general machines.  All general machines can be simulated by appropriate use of Turing machines.
19:57:24 <sorear> jsnx: All continuation structures are monads.  All monads can be simulate by appropriate use of (delimited) continuations.
19:57:26 <oerjan> jsnx: contexts on data types are of disputed value
19:58:34 <jsnx> oerjan: really? but doesn't that allow illegal continuation definitions in this case?
19:58:45 <jsnx> sorear: i am looking it over now
19:59:38 <oerjan> jsnx: the Monad m context is in the Monad (ContT r m) instance declaration
19:59:52 <GoAwayStupidAI> What differentiates delimited continuations?
20:00:02 <oerjan> so you cannot use ContT r m monadically without m being a monad
20:00:20 <jsnx> oerjan: ok, i understand what you mean now
20:00:35 <sorear> jsnx: Cayley's theorem would have made for a nice analogy, but if you don't already know it it will just complicate things.  Does the Turing-machine analogy make sense?
20:00:47 <jsnx> sorear: yes
20:01:00 <jsnx> sorear: i am reading the theorem and it is indeed complicated
20:01:09 <jsnx> however, i have a new question
20:01:09 <Toxaris> is there a formal meaning for "continuation" (like there is for monad)?
20:01:12 <oerjan> however, i just thought that by not putting it into the datatype itself, it might be possible to use ContT r m for restricted variants of Monads (like that Set monad with Eq or Ord restriction that keeps popping up)
20:01:29 <jsnx> oerjan: aye
20:02:05 <jsnx> in python, they have implemented a stackless variant to allow fuller use of continuations
20:02:17 <sorear> Toxaris: afaik, not in general.  But many small-step operational semantics use a context-parameter, which is a continuation
20:02:26 * sorear hates the word stackless
20:02:28 <jsnx> how do monads in haskell use stack space?
20:02:32 <sorear> there is too a stack!
20:02:37 <ddarius> Yoneda's lemma is easier and more general!
20:02:48 <jsnx> sorear: in stackless python?
20:02:48 <sorear> it's just implemented using the heap rather than pointer fudging!
20:03:10 <sorear> jsnx: Yes.  If there was no stack of activation records, procedures would never return.
20:03:33 <jsnx> sorear: so, it's just really huge?
20:03:34 <lament> "stackless" refers to the C stack
20:03:39 <lament> or something
20:04:06 <ddarius> Wow.  I've read about Yoneda generalizing Cayley's theorem, but never actually thought too hard about it.  It really is trivial.
20:04:32 <jsnx> okay, so in haskell, say i want to implement a big huge game like eve, with hella continuations, in haskell
20:04:42 <jsnx> would i use monads?
20:04:46 <lament> in haskell
20:04:52 <jsnx> would i run out of stack?
20:04:58 <oerjan> jsnx: it depends on the monad.  For example people switch between lazy and strict State monads to fix issues with memory use, which might include the stack
20:04:59 <dons> jsnx: quite possibly. to implement continuations you would
20:05:02 <sorear> jsnx: in "stackless" implementations, activation records have backlink pointers.  in "stackful" implementations, activation records are adjacent in memory.
20:05:07 <dons> for a game in haskell, you'd probably use arrows though
20:05:19 <sorear> arrows?
20:05:27 <dons> well, yampa
20:05:30 <dolio> That's what Frag does.
20:05:41 <dolio> As I recall.
20:05:44 <dons> yep
20:05:51 <Toxaris> sorear: so what does "all monads are continuation" mean? the purpose of every monad could be achieved by the use of continuations?
20:06:10 * sorear suspects there is a reason why monadic formulations like Gtk2hs are more popular than arrow code like Yampa
20:06:12 <ddarius> Toxaris: You can embed all monads into the (delimited) continuation monad.
20:06:16 <wli> Toxaris: Continuations could achieve what monads do.
20:06:20 <dons> i think the idea is that with continuations + state, you can implement every monad
20:06:22 <sorear> Toxaris: What you said.
20:06:27 <dons> and continuations are just a particular monad
20:06:33 <ddarius> sorear: If it -is- a monad, you might as well use the fact.
20:07:09 <dons> syntax for monads is simpler than syntax for arrows
20:07:21 <dons> arrows kind of need a 2-D style syntax :)
20:07:21 <wli> I should move on to learning arrows.
20:07:38 * oerjan recalls some theorem that all monads in Set are equivalent to generalized algebras
20:07:47 <sorear> ddarius: Arrows and monads have strong superficial differences - HXT uses a ArrowApply but not a Monad because it's a better fit for the problem domain.  I suspect the reverse is true of GUIs.
20:07:53 <jsnx> dons: what is yampa?
20:07:53 <lament> arrows are like monads, but instead of a sequence, you get an arbitrary graph?
20:07:57 <Toxaris> I would have thought this because of the type of (>>=)
20:08:10 <ddarius> oerjan: Algebras for a rather wide meaning of the term are all monadic over set.
20:08:17 <dons> jsnx: its a library for reactive programming, used for programming robots, games and similar things
20:08:22 <sorear> lament: Arrows are like monads, but you have to clear your flightpath with the FAA before you start flying.
20:08:24 <dons> ?google yampa
20:08:25 <oerjan> ddarius: i meant the reverse
20:08:26 <lambdabot> http://www.haskell.org/yampa/
20:08:26 <lambdabot> Title: Yampa
20:08:34 <sorear> lament: With Monads, you can make it up as you go along.
20:08:37 <jsnx> aha
20:08:54 * glguy doesn't understand the distinction that "everything done with monads could be done with continuations" since "everything done with monads can be done with pure functions"
20:09:28 <lament> sorear: but you still get an arbitrary graph? or otherwise, what's the advantage
20:09:39 <dons> they can't be done with continuations as is though. i thought it was continuations + state. ddarius, do you have a ref for delimited continuations can implement any monad?
20:10:09 <ddarius> glguy: Let's put it this way.  "Monadic style" is a global transformation.  If you alternatively use Continuation Passing Style, then all uses of monadic style are now local transformations.
20:10:17 <sorear> lament: The advantage is that the FAA (interpreter) knows what you are going to do in advance, and can do clever optimizations, like a parser library generating tables
20:10:23 <dolio> Oleg says that delimited continuations can be used to build ST, so...
20:10:27 <ddarius> @google "Representing Monads"
20:10:31 <lambdabot> http://portal.acm.org/citation.cfm?id=178047
20:10:31 <lambdabot> Title: Representing monads
20:10:34 <ddarius> @google "Representing Layered Monads"
20:10:36 <lament> sorear: ah, sounds boring
20:10:37 <lambdabot> http://portal.acm.org/citation.cfm?id=292540.292557
20:10:37 <lambdabot> Title: Representing layered monads
20:10:43 <dolio> In fact, his dynamic variables are sort of like that.
20:10:47 <ddarius> dons: Continuations + state <=> delimited continuations
20:10:49 <dons> yeah, i find it intuitively plausible that delimited continuations give you everything you need
20:11:01 <dons> ddarius: yeah, that's the correspondance i was thinkign of
20:11:48 <dons> delimited continuations are pretty uncommon still, though. dolio, do you know of implementations outside of ocaml and haskell?
20:12:07 <glguy> is there a packaged implementation in Haskell?
20:12:08 <kjdf> scheme
20:12:10 <dolio> 'r <- newSTRef v ; ...' --> 'r <- dnew ; dlet r v (...)'
20:12:11 <sorear> glguy: yes
20:12:14 <glguy> hackage?
20:12:15 <sorear> jsnx: Do you really want continuations, or just coroutines
20:12:20 <sorear> Yes
20:12:25 <dons> kjdf: scheme has *delimited* continuations?
20:12:31 <sorear> jsnx: since we can do the latter really cheaple
20:12:40 <dolio> dons: PLT Scheme has them, reportedly. Although not multi-prompt ones like the Haskell/OCaml ones.
20:12:42 <sorear> dons: sure, scheme is one of oleg's favorite languages
20:12:47 <kjdf> implemented as library, using call/cc and state
20:12:49 <ddarius> dons: Scheme has continuations and state, and yes, there are implementations that directly implement shift/reset.
20:12:59 <dons> right, so people have gone and implement shfit/reset
20:13:04 <dons> that's what I was wondering.
20:13:05 <phobes> sorear: Does your use of "Cayley's theorem" refer to the theorem from group theory?
20:13:10 <sorear> phobes: Yes.
20:13:27 <phobes> interesting...
20:13:32 <sorear> phobes: All groups are groups of permutations.  All groups of permutations are groups.
20:14:25 <jsnx> sorear: how do we do coroutines cheaply in haskell?
20:14:30 <jsnx> stm?
20:14:33 <sorear> jsnx: threads
20:14:44 <ddarius> A group is a category with one object and all arrows isomorphisms.  The Yoneda embedding, embedding C into the category of functors from C^op -> Set is full and faithful.  Cayley's theorem is an immediate corrollary.
20:15:05 <jsnx> sorear: that doesn't scale to eve-like levels, though, i'm sure
20:15:20 <sorear> jsnx: How many coroutines does eve use?
20:15:29 <sorear> jsnx: we should get about 4k/thread overhead
20:15:40 <jsnx> one for each user, ship, asteroid, anything
20:15:45 <ddarius> jsnx: No problem.
20:15:49 <dons> jsnx: haskell threads are based on `select'. so oh, 10k is doable naively. there's some optimised forms that use up to 10M haskell threads
20:16:14 <GoAwayStupidAI> I thought haskell had both "green" threads and native threads?
20:16:14 <jsnx> haskell threads are 'green' threads?
20:16:30 <sorear> jsnx: no, they're better :)
20:16:35 <dons> GoAwayStupidAI: yeah, light haskell threads map onto OS threads over several cores
20:16:47 <jsnx> sorear: well, can you explain that 'better' part?
20:16:53 <kjdf> dons: what kind of optimised forms?
20:16:54 <GoAwayStupidAI> I think they can be, but you can explicitly dispatch a 'thread' to run on a seperate OS thread
20:16:58 <glguy> dolio: there is a typo on your code.h.o page
20:17:05 <dons> jsnx: so libraries like yampa provide a thread abstraction, so you give a process to each object/agent in the game
20:17:08 <dolio> Oh?
20:17:08 <glguy> dolio: haskell is spelled wrong in the CC-delcont link
20:17:10 <dons> and you might have 100s of these
20:17:13 <dons> 1000s
20:17:15 <sorear> jsnx: GHC has most of an operating system inside, including a scheduler than can efficently map thousands of threads onto any number of native threads
20:17:28 <dons> kjdf: the epoll-based thread lib
20:17:30 <glguy> dolio: I wouldn't bring it up if it didn't stop me from cutting and pasting :)
20:17:32 <lament> it almost sounds like some kind of erlang
20:17:36 <jsnx> sorear: but how is that not a 'green thread' ?
20:17:39 <chessguy> glguy, you mean haskell isn't spelled s-c-h-e-m-e?
20:17:45 <ddarius> @google "Unifying Events and Threads"
20:17:47 <lambdabot> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
20:17:47 <lambdabot> Title: Unifying events and threads
20:18:02 <sorear> jsnx: Because people think green threads means that there is no possibility of parallel execution.
20:18:13 <jsnx> sorear: oh, i see
20:18:25 <sorear> GoAwayStupidAI: I think you misunderstood the forkOS documentation
20:18:34 <sorear> GoAwayStupidAI: it makes your program *slower*, not faster
20:19:03 <dons> GoAwayStupidAI: you can specify the number of real OS threads, yep
20:19:06 <glguy> Control/Monad/CC/Prompt.hs:38:7: Could not find module `Unsafe.Coerce':
20:19:10 <dolio> Fixed.
20:19:10 <dons> which likely depends on the number of cores you have
20:19:10 <jsnx> so, that answers one of my continuation questions...
20:19:21 <samreid> The funny thing about the group theory Cayley's theorem is that if you're used to Haskell's section syntax or are just likely to see "x + y" as a cute way of writing "(x +) y", the theorem's kind of obvious.
20:19:25 <glguy> dolio: does this need 6.7?
20:19:34 <jsnx> to make a big game, i can use haskell threads or the yampa facade
20:19:42 <dolio> glguy: Yeah.
20:19:43 <ddarius> samreid: The theorem is kind of obvious.
20:19:53 <dons> jsnx: yampa gives you the abstractions you need to program all the agents in a very high level style
20:19:55 <samreid> true, but obviouser :P
20:19:58 <dons> (see the Frag 3D game)
20:20:06 <jsnx> dons: thanks!
20:20:07 <dons> and then you might layer that over some SMP runtime threads
20:20:14 <dons> ?where Frag
20:20:14 <lambdabot> http://www.haskell.org/haskellwiki/Frag
20:20:16 <GoAwayStupidAI> sorear: I don't think it's guaranteed to slow the program down. I think it depends on the state dependencies between the haskell threads running in each native thread
20:20:17 <jsnx> now, what about continuations for web applications?
20:20:19 <glguy> dolio: what provides Unsafe.Coerce?
20:20:23 <dons> have a look at Mun's thesis on yampa and frag
20:20:27 <sorear> glguy: base
20:20:30 <jsnx> those are totally different, right?
20:20:40 <glguy> sorear: which version?
20:20:43 <sorear> 2.1
20:20:49 <sorear> which means nothing
20:20:54 <ddarius> jsnx: Why would they be?
20:21:11 <jsnx> ddarius: you have to save them so you can go 'back'
20:21:12 <glguy> sorear: but if things were done correctly... that version would have ticked?
20:21:14 * sorear REALLY thinks it should be illegal to create two different packages with the same name and version
20:21:29 <sorear> (Cabal-illegal, not law-illegal)
20:21:30 <dolio> glguy: It also uses GADT + typeclass interaction from 6.7.
20:21:33 <ddarius> jsnx: They need to be serializable, yes, but they are the same continuations.
20:21:50 <jsnx> ddarius: i don't mean save them as in serialize them...
20:22:06 <jsnx> ddarius: here's what i don't understand, i guess:
20:22:21 <jsnx> coroutines, unlike continuations, can not be reverted
20:22:37 <jsnx> so just having parallel threads of executions is not enough
20:22:55 <ddarius> @google "Subcontinuations from threads"
20:23:00 <lambdabot> http://www.springerlink.com/index/MR4593687L66372U.pdf
20:23:00 <lambdabot> Title: SpringerLink Home - Main
20:23:23 <ddarius> There's a available version of that somewhere.
20:24:47 <jsnx> ddarius: unfortunately, firefox and gui are both dead for me while i rebuild them
20:24:58 <jsnx> ddarius: i will dig it up when they are back
20:24:59 <sorear> jsnx: apt-get install elinks
20:25:16 <ray> apt-get install thing-that-converts-pdfs-to-text
20:25:17 <jsnx> sorear: it can read pdf?
20:25:30 <ray> (i know it must exist!)
20:25:51 <ddarius> @google pdf2txt
20:25:52 <sorear> jsnx: Sure, if you have a console PDF reader (like bmv) installed
20:25:53 <lambdabot> http://www.verypdf.com/pdf2txt/pdf2txt.htm
20:25:54 <lambdabot> Title: PDF to Text - convert Adobe PDF documents into ASCII text format with PDF to Tex ...
20:26:13 <ray> nice name
20:28:24 <jsnx> ddarius: so, basically, each session gets a thread, and underneath that thread is a tree of continuations
20:28:49 <jsnx> and these 'continuations' can be arrows, monads, &c. ?
20:29:31 <sorear> > undefined :: UArray Int Int
20:29:32 <lambdabot>   Not in scope: type constructor or class `UArray'
20:31:15 <jsnx> you know, actually, i've probably taken in more today than i'll be able to understand for awhile
20:32:39 <jsnx> are there any examples/tutorials of seaside like apps in haskell that i can take a look at? it might help me more, honestly, to see something concrete...
20:35:20 <jsnx> thanks for your time, everyone
20:37:52 <ddarius> @tell jsnx WASH http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
20:37:52 <lambdabot> Consider it noted.
20:38:04 <shapr> d00d
20:42:35 <sorear> > BS.length
20:42:43 <lambdabot>   Not in scope: `BS.length'
20:42:47 <chessguy> @paste
20:42:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:42:49 <sorear> > Data.ByteString.length
20:42:50 <lambdabot>   Not in scope: `Data.ByteString.length'
20:43:16 <hpaste>  chessguy pasted "anybody think this would be a useful function to send to libraries@?" at http://hpaste.org/2219
20:43:21 <sorear> > S.length
20:43:22 <lambdabot>  <Data.ByteString.Base.ByteString -> Int>
20:43:25 <sorear> aha
20:44:05 <oerjan> > last $ takeWhile ((/= 1).(1+).(2**).negate) [1..]
20:44:06 <lambdabot>  63.0
20:45:03 <oerjan> > last $ takeWhile ((/= 1).(1+).(0.5^)) [1..]
20:45:04 <lambdabot>  63
20:45:21 <glguy> chessguy: why is "takeWhile2 p p' (x:xs)" repeated 3 times?
20:45:41 <chessguy> glguy, with different guards
20:45:48 <glguy> yeah
20:46:01 <chessguy> oh
20:46:05 <chessguy> heh, i don't know
20:50:08 <oerjan> @src State
20:50:08 <lambdabot> Source not found. It can only be attributed to human error.
20:50:15 <oerjan> @src StateT
20:50:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:51:12 <glguy> :k State
20:51:13 <lambdabot> * -> * -> *
20:51:24 <OceanSpray> so, what would be a good way to implement continuations?
20:52:20 <sorear> ContT?
20:52:26 * sorear finds a new overflow bug in base
20:52:35 <sorear> looks much easier to exploit than the array bug
20:52:42 <OceanSpray> wut
20:52:47 <OceanSpray> :t ConT
20:52:49 <lambdabot> Not in scope: data constructor `ConT'
20:52:54 <OceanSpray> :t ContT
20:52:55 <sorear> :k ContT
20:52:57 <lambdabot> * -> (* -> *) -> * -> *
20:52:58 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
20:53:10 <sorear> @src ContT
20:53:10 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
20:53:14 <sorear> it's just CPS
20:53:31 <sorear> @src ContT callCC
20:53:31 <lambdabot> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
20:53:35 <sorear> @src ContT return
20:53:36 <lambdabot> return a = ContT ($ a)
20:53:39 <sorear> @src ContT (>>=)
20:53:40 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
20:53:42 <OceanSpray> and how would I use it?
20:54:05 <chessguy> @type maybe
20:54:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:54:56 <oerjan> > runState (do l <- State$span (<= 10); l2 <- State$break (<= 20); return (l1,l2)) [1..]
20:54:57 <lambdabot>   Not in scope: `l1'
20:55:07 <oerjan> > runState (do l1 <- State$span (<= 10); l2 <- State$break (<= 20); return (l1,l2)) [1..]
20:55:09 <lambdabot>  (([1,2,3,4,5,6,7,8,9,10],[]),[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
20:55:45 <oerjan> > runState (do l1 <- State$span (<= 10); l2 <- State$break (>= 20); return (l1,l2)) [1..]
20:55:46 <lambdabot>  (([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19]),[20,21,22,23,24,25,26...
20:56:13 <phobes> Do you guys use lambdabot when developing?
20:56:28 <glguy> not really
20:57:39 <TSC> I use it for reference sometimes
20:57:59 <shapr> I do
20:58:08 <TSC> For hoogle, for example
20:58:09 <TSC> Or @pl
20:58:21 <shapr> I used @index lots, but then, I wrote the first version of that plugin because I needed it.
20:58:54 <phobes> What editor do you use?
20:59:44 <shapr> I use emacs
20:59:48 <glguy> vim
20:59:56 <glguy> @quote joke
20:59:56 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
21:00:08 <glguy> ;)
21:00:08 <shapr> @quote holy
21:00:09 <lambdabot> shapr says: Hey, don't talk bad about my holy war!
21:00:25 <glguy> bah, you can't quote yourself :-p
21:00:28 <sorear> dons: Data.ByteString.concat harbors a integer-overflow bug that can be exploited fairly easily, if I can contrive for the bytestring to be allocated at a lower address than the retirement zone, it should be trivial to smash the TSO# and gain control of the runtime
21:00:33 * shapr snickers
21:00:53 <monochrom> haha
21:01:14 <monochrom> The first buffer-overrun exploit of Haskell web servers! :)
21:05:37 <sorear> Okay, I've found a sequence of allocations and garbage collections that should do what I want
21:06:43 <oerjan> > runState ((State . span) isDigit >>= State . splitAt . read) "5abcdefghijk"
21:06:44 <lambdabot>  ("abcde","fghijk")
21:08:07 <chessguy> @quote shapr
21:08:07 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
21:12:39 <oerjan> anyone else thought of using break/span/splitAt as State actions?
21:13:29 <monochrom> A parser does that.
21:14:28 <monochrom> Some implementations of delimited continuations does that too. They use their own stacks and discard a whole section once in a while.
21:17:05 <oerjan> @hoogle [a] -> ([a], [a])
21:17:09 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
21:17:09 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
21:17:09 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
21:17:36 <oerjan> oh, partition too, that could have weird effects
21:18:27 * dolio boggles at yet another 'monads are hacks for IO' comment.
21:18:31 <oerjan> @src partition
21:18:31 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
21:18:31 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
21:18:31 <lambdabot>                               | otherwise = (ts, x:fs)
21:19:01 <shachaf> dolio: Where?
21:19:10 <dolio> reddit of course.
21:22:26 <oerjan> @hoogle [a] -> (_, [a])
21:22:27 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
21:22:27 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
21:22:27 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:22:41 <shachaf> @hoogle+
21:22:42 <lambdabot> Data.List.mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:22:49 <phobes> I wonder if anyone has written a Monads in Perl tutorial
21:23:01 <shachaf> phobes: Very likely. :-)
21:23:05 <oerjan> @go monads in perl
21:23:08 <lambdabot> http://sleepingsquirrel.org/monads/monads.html
21:23:08 <lambdabot> Title: Monads in Perl
21:23:10 <shachaf> @wiki Monads in other languages
21:23:11 <lambdabot> http://www.haskell.org/haskellwiki/Monads_in_other_languages
21:24:05 <shachaf> @wiki Monad
21:24:05 <lambdabot> http://www.haskell.org/haskellwiki/Monad
21:24:11 <ddarius> Does no one notice that 90% of these "monad tutorials" look exactly the same.
21:24:30 <sorear> stefan@stefans:~/bsexp$ ./a.out
21:24:30 <sorear> TSO#: 0xb7802000
21:24:30 <sorear> BS 0xb7775008
21:24:36 <sorear> this is a Good Sign
21:24:42 <ddarius> Almost there.
21:24:51 <dons> please submit a patch/bug report
21:25:02 <dons> probably more useful than spending a day trying to exploit it
21:25:32 <sorear> Where do we send patches nowadays?
21:27:27 <sorear> dons: Should it be legal to create bytestrings larger than 2GB? (= "negative" sizes)
21:27:45 <augustss> ddarius: 90% look the same and don't get it quite right. :)
21:28:01 <ddarius> augustss: Yep.
21:28:15 <dons> sorear: so i guess you're looking at a malloc-based overflow issue?
21:28:28 * ddarius is with augustss.
21:28:32 <phobes> Monads are easy - they're like envelops  ... cf my tutorial
21:28:37 <geezusfreeek> yeah, the poor quality of most of the materials on monads on the internet is what took me so long to get it
21:28:59 <sorear> dons: what do you mean malloc-based?  this is pure haskell code here, uses an Int for find the size for a bytestring
21:29:24 <dons> sorear: oh, i was assuming you were playing some trick with the size of the buffer needed by concat
21:30:03 <sorear> dons: Yes, I'm playing a trick with the buffer size.  But malloc(3) isn't involved, only newByteArray#
21:30:05 <dons> i think we misunderstand each other. patches go to me, against either fps repo, or the bytestring repo
21:30:06 <sorear> +Pinned
21:30:08 <jsnx> phobes: where is the tutorial?
21:30:08 <lambdabot> jsnx: You have 1 new message. '/msg lambdabot @messages' to read it.
21:30:14 <sorear> okay
21:30:46 <shapr> Hey, tonight is Perseid meteor night!
21:31:23 * shapr goes outside to watch meteors
21:31:52 <Olathe> Sky sandwich ! Now more meteor than ever !
21:32:36 <mudge> hello
21:32:41 <geezusfreeek> hello
21:32:50 <sorear> hello
21:33:16 <mudge> i head that haskell might be good for writing compilers, interpreters etc.  at least for prototypes for these things
21:33:22 <mudge> anyone have any comment on that?
21:33:33 <sorear> it's quite correct
21:33:36 <geezusfreeek> absolutely true, if you want to take the time to learn
21:34:17 <mudge> does it take a long time to learn?   I mean if you don't know how to write a compiler or interpreter in any language,   might haskell take the same length of time to learn?
21:34:51 <sorear> It doesn't take a long time to learn by itself.
21:34:54 <jsnx> @google write yourself a scheme in 48 hours
21:34:56 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
21:34:56 <lambdabot> Title: Write Yourself a Scheme in 48 hours
21:35:11 <mudge> I heard that the perl 6 prototype is written in haskell
21:35:16 <thoughtpolice> mudge: i've only been with haskell for a little while, but I feel confident enough to the point where writing an interpreter seems like a very practical goal.
21:35:19 <jsnx> mudge: yes, it is
21:35:22 <dons> i think its not meant to be a prototype only, though.
21:35:41 <geezusfreeek> ah, i was going to link to that
21:35:42 <jsnx> mudge: it was the prototype, but now they are sticking with it
21:36:02 <geezusfreeek> mudge, that scheme in 48 hours tutorial is pretty good
21:36:03 <thoughtpolice> it's meant to bootstrap once the milestones are finished. audreyt is kind of indisposed for a while though. :(
21:36:15 <dons> there's a large list of compilers written in haskell here: http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
21:36:15 <sorear> merus: It's worth noting that all but one of the Haskell compilers is written in Haskell
21:36:17 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
21:36:25 <sorear> s/merus/mudge
21:37:06 <jsnx> has there been any work on operating systems in haskell?
21:37:11 <thoughtpolice> she needs time, hopefully she'll be back to hacking soon though. :)
21:37:13 <thoughtpolice> jsnx: house?
21:37:14 <glguy> jsnx: yes
21:37:14 <dons> yeah, there's a couple of kernels
21:37:31 <mudge> I'm checking out that Scheme in 48 hours,  looks really cool
21:37:36 <jsnx> thoughtpolice: house?
21:37:39 <shapr> mudge: Are you *the* mudge?
21:38:05 <jsnx> dons: neato. on the haskell wiki?
21:38:09 <phobes> I'm currently working on a haskell compiler in 71 hours
21:38:12 <thoughtpolice> jsnx: i have a link somewhere... i looked at it about a week ago.
21:38:14 <phobes> err, 70 h
21:38:24 <jsnx> thoughtpolice: what is house?
21:38:26 <dons> jsnx: yeah, look under 'operating systems'
21:38:28 <thoughtpolice> http://programatica.cs.pdx.edu/House/
21:38:29 <lambdabot> Title: House
21:38:39 <shachaf> @where house
21:38:39 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
21:38:58 <thoughtpolice> that works too.
21:39:28 <shapr> mudge: If you're the mudge of kingpin & mudge, you might find QuickCheck interesting, it'd be great for fuzzing.
21:41:06 <jsnx> shapr: who is "*the* mudge"
21:41:06 <jsnx> ?
21:41:13 <shapr> http://en.wikipedia.org/wiki/Mudge
21:41:14 <lambdabot> Title: Mudge - Wikipedia, the free encyclopedia
21:42:21 <mudge> Wow,    no,  i'm the other "the mudge"
21:42:30 <mudge> mudge is actually my last name
21:42:44 <shapr> Ah okay :-)
21:43:32 <mudge> that reminds me,  I need to get my bio on wikipedia
21:43:56 <mudge> I'm nick mudge: http://nickmudge.info/
21:44:11 <lambdabot> Title: Nick Mudge's Weblog
21:44:22 <oerjan> mudge: writing your own wikipedia article is frowned upon
21:44:47 <oerjan> or did you just mean user page?
21:45:21 <mudge> yea, I was just thinking that,  how do people get wikipedia bios?
21:45:37 <shapr> By becoming famous, usually.
21:45:39 <phobes> step 1: do something interesting :)
21:45:49 <mudge> ah, I guess I'll have to work on that then
21:46:16 <oerjan> http://en.wikipedia.org/wiki/WP:N
21:46:16 <thoughtpolice> heh, cult of the dead cow was founded in a town just an hour away from me. weird to think about. :)
21:46:18 <lambdabot> Title: Wikipedia:Notability - Wikipedia, the free encyclopedia
21:46:31 <mudge> thanks
21:46:54 <mudge> hey is lamdabot a person?  or a really smart reference bot?
21:47:00 <shapr> It's a bot.
21:47:06 <njbartlett> Being famous is good, but being notorious also works.
21:47:10 <geezusfreeek> mudge, the smartest bot i've ever seen
21:47:13 <mudge> no way?  I was joking,    it really is?
21:47:20 <thoughtpolice> mudge: yep.
21:47:25 <thoughtpolice> @version
21:47:25 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
21:47:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:47:40 <sorear> She really is a bot.
21:47:47 <mudge> http://dictionary.reference.com/
21:47:47 <lambdabot> Title: Dictionary.com
21:47:52 <mudge> wow, that is so cool
21:48:01 <shapr> mudge: There was some jabber support (re your blog post) for lambdabot.
21:48:06 <shapr> I don't know if it works or not.
21:48:08 <njbartlett> I'm not convinced. I think it's a mechanical turk.
21:48:08 <mudge> anyone know what language/technology it is written in?
21:48:14 <sorear> mudge: Haskell ;)
21:48:19 <thoughtpolice> @protontorpedo
21:48:19 <lambdabot> is haskell better than APL or perl or clisp?
21:48:48 <shapr> @quote
21:48:48 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
21:50:12 <oerjan> > let fib=1:1:zipWith(+)fib(tail fib) in fib
21:50:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:51:32 <mudge> has anyone read the book "Programming in Haskell"?
21:51:40 <mudge> by Graham Hutton
21:53:05 <mudge> 2 + 3
21:53:14 <shachaf> mudge: I've read it.
21:53:26 <phobes> > 2 + 3
21:53:27 <mudge> you think it is a good book to learn haskell?
21:53:28 <lambdabot>  5
21:53:35 <mudge> haha,  it added
21:54:13 <mudge> thanks phobes
21:55:08 <mudge> hi zvrba
21:55:16 <bitwize> @quote bitwize
21:55:16 <lambdabot> bitwize says: The combinator known as compose, Makes me extremely morose; The full stop is better, than writing it in letters, Which makes it uselessly verbose.
21:55:41 <shachaf> That doesn't really rhyme perfectly.
21:55:58 <bitwize> It doesn't, but here's a version that scans better at least: http://reddit.com/info/2dxfj/comments/c2e3fz
21:55:59 <lambdabot> Title: xkcd: Limerick (reddit.com)
21:56:00 <shachaf> "If it was just a dot, I would use it a lot,"?
21:56:27 <jsnx> 'twas it a dot, i'd use it a lot
21:56:48 <mudge> if I ate spegetthi I'd eat it a lot
21:56:54 <bitwize> shachaf: Someone here remarked "writing compose is uselessly verbose"; and that was my first stab at converting the statement to limerick form.
21:56:55 <mudge> oh, sorry
21:57:14 <shachaf> bitwize: Yes, I saw.
21:57:46 <jsnx> if it was -> unstressed stressed unstressed  i would use -> stressed unstressed unstressed
21:58:43 <jsnx> generally, that's overscore and circumflex
21:58:50 <jsnx> don't know really know the ascii way to write metrical feet
21:59:11 <geezusfreeek> @quote geezusfreeek
21:59:11 <lambdabot> No quotes match. Do you think like you type?
21:59:18 <geezusfreeek> yay
21:59:36 <sorear> @quote
21:59:36 <lambdabot> #perl says: <tech> who needs saneness
21:59:38 <sorear> @quote
21:59:38 <lambdabot> sorear says: We need to fork #haskell.  I can't read fast enough.
21:59:46 <geezusfreeek> i was half hoping lambdabot would lie and make something up :)
22:00:04 <bitwize> lambdabot must have taken a cue from Acid Burn.
22:00:39 <sorear> lambdabot is pretty dumb by IRCbot standards
22:00:45 <bitwize> @quote qwe1234
22:00:45 <lambdabot> qwe1234 says: in my very firm opinion, it's never your business to be figuring out pointer type at runtime.
22:00:53 <sorear> she doesn't even *try* to speak english
22:01:06 <phobes> @remember geezusfreeek "i was half hoping lambdabot would lie and make something up :)"
22:01:06 <lambdabot> Done.
22:01:14 <geezusfreeek> *sigh*
22:01:16 <blackdog> sorear: sure she does. she's just not very good at it.
22:01:38 <shachaf> The quotes aren't necessary.
22:01:40 <blackdog> @vixen
22:01:40 <lambdabot> You think this is a botiecall??
22:01:44 <blackdog> see what i mean?
22:01:50 * shachaf wishes people wouldn't use them.
22:01:54 <shachaf> @uptime
22:01:55 <lambdabot> uptime: 6d 17h 33m 43s, longest uptime: 1m 10d 23h 44m 29s
22:02:02 <phobes> @quote geezusfreeek
22:02:02 <lambdabot> geezusfreeek says: "i was half hoping lambdabot would lie and make something up :)"
22:02:05 <phobes> oops
22:02:07 <sorear> If you're going to ascribe intelligence to lambdabot, you might as well ascribe it to your shell prompt
22:02:17 <shachaf> dons: When is the next lambdabot restart scheduled?
22:02:33 <njbartlett> @let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
22:02:34 <lambdabot> <local>:24:0:     Multiple declarations of `L.fibs'     Declared at: <local>:...
22:03:22 <sorear> @undefine
22:03:26 <lambdabot> Undefined.
22:03:54 <shachaf> @let on f g x y = g x `f` g y
22:03:57 <lambdabot> Defined.
22:04:11 <shachaf> @let s x y z = x z (y z); k x _ = x; i x = x
22:04:13 <lambdabot> Defined.
22:14:53 <OceanSpray> what exactly does the <- operator do?
22:15:10 <oerjan> it's not an operator, it's syntax
22:15:50 <oerjan> @undo do x <- act1 ; rest
22:15:50 <lambdabot> act1 >>= \ x -> rest
22:17:33 <oerjan> (and that's a slight simplification of the desugaring, there is a complication in case of pattern failure)
22:17:58 <sjanssen> @undo do (Just x) <- act1; rest
22:17:59 <lambdabot> act1 >>= \ a -> case a of { (Just x) -> rest; _ -> fail ""}
22:18:25 <oerjan> oh, it does handle that
22:19:22 <oerjan> anyway, the rules are at http://haskell.org/onlinereport/exps.html#sect3.14
22:19:23 <lambdabot> Title: The Haskell 98 Report: Expressions
22:22:08 <Cale> OceanSpray: To take a more practical approach to your question, when v <- x occurs in a do-block, what happens is that x is run, and its result is given the name v.
22:22:08 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
22:22:44 <OceanSpray> hm
22:23:27 <Cale> Which monad are you working with? IO?
22:23:29 <OceanSpray> so a monad of type IO (), when <-'d into something, will give () to that?
22:23:45 <shachaf> OceanSpray: Yes.
22:23:54 <Cale> A computation of type IO (), yes
22:24:04 <OceanSpray> alrighty, got it now
22:24:26 <Cale> You might say "a computation typed in the monad IO"
22:24:57 <oerjan> IO () is not exactly the most useful case for this :)
22:25:11 <Cale> A better example would be something like
22:25:19 <Cale> do x <- getLine; putStrLn (reverse x)
22:25:31 <Cale> this will get a line from the user, and print it back out in reverse
22:25:46 <oerjan> @. pl undo do x <- getLine; putStrLn (reverse x)
22:25:46 <lambdabot> putStrLn . reverse =<< getLine
22:25:51 <bitwize> but that computation is of type IO String; i.e., it is a partial computation which yields a value of type String
22:25:58 <Cale> (x :: String) refers to the result of the computation getLine
22:26:54 <oerjan> @pl do x <- getLine; putStrLn (reverse x)
22:26:54 <lambdabot> (line 1, column 16):
22:26:54 <lambdabot> unexpected ";"
22:26:54 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
22:27:24 <shachaf> @. pl undo do x <- getLine; putStrLn (reverse x)
22:27:25 <lambdabot> putStrLn . reverse =<< getLine
22:27:34 <oerjan> i already did that
22:27:45 <shachaf> Oh, sorry.
22:27:50 <OceanSpray> I'm still confused as hell
22:28:02 <OceanSpray> and getting flooded with type mismatch errors
22:28:34 <shapr> @quote
22:28:34 <lambdabot> metaperl says: I never thought anyone could be on IRC as much as you and look that good
22:28:41 <shapr> heh, who's that about?
22:30:35 <Cale> OceanSpray: Make sure that you're not passing actions to functions when you mean to be passing their results.
22:30:55 <Cale> OceanSpray: for example, it doesn't work to write  putStrLn (reverse getLine)
22:31:08 <Cale> because getLine isn't itself a string
22:31:20 <Cale> it's an action which produces a string if you run it
22:31:33 <Cale> Does that make sense?
22:31:43 <sjanssen> 06.11.27:11:12:33 <metaperl> Cale - you look like a well-rounded person. I never thought anyone could be on IRC as much as you and look that good
22:31:49 <sjanssen> shapr: ^^^
22:31:58 <Cale> heh :)
22:32:36 <OceanSpray> yes, it does.
22:36:23 <OceanSpray> fuck, it's SO FRUSTRATING
22:36:32 <OceanSpray> I definitely bit off more than I can chew.
22:36:54 <Cale> OceanSpray: hmm... what are you attempting to do?
22:36:54 <OceanSpray> who's got enough free time to help me?
22:36:58 <Cale> I can help
22:36:58 <hpaste>  tga pasted "swapping tuples in a list" at http://hpaste.org/2220
22:37:07 <OceanSpray> ok, here
22:37:11 <tga> what's a nicer way of doing this than fst/snd?
22:37:17 <Cale> tga: swap (x,y) = (y,x)
22:37:26 <tga> oh.. I see..
22:37:36 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2221
22:37:38 <Cale> Or even just  swapall pairs = map (\(x,y) -> (y,x)) pairs
22:37:55 <shachaf> @pl swap (x,y) = (y,x)
22:37:56 <lambdabot> swap = uncurry (flip (,))
22:38:20 <OceanSpray> see the eval (Pair car cdr) ... = ... ?
22:38:52 <Cale> let proc = liftIO (readIORef p)
22:38:57 <oerjan> @unpl uncurry (flip (,))
22:38:57 <lambdabot> uncurry (\ b c -> (,) c b)
22:38:59 <Cale> It seems you want that to be
22:39:06 <Cale> proc <- liftIO (readIORef p)
22:39:06 <tga> cool
22:39:39 <OceanSpray> ok, forget about the p and the proc for a sec
22:39:48 <OceanSpray> that was just experimentation out of frustration
22:40:22 <Cale> okay...
22:40:39 <OceanSpray> what would be the easiest way to eval car, get that monadic LispErrT (IORef LispVal) into a LispProc, and use apply?
22:40:43 <Cale> I can't compile that module btw, because I don't have LispData
22:40:51 <OceanSpray> ok, here
22:40:57 <OceanSpray> I'll just paste all of em
22:41:44 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2221#a1
22:42:12 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2221#a2
22:42:41 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2221#a3
22:43:05 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2221#a4
22:43:17 <OceanSpray> and that's the program.
22:43:44 <Tac-Tics> Haskell is such a powerful language that it allows us to create vastly inferior languages with undeniable ease
22:44:09 <OceanSpray> what's that supposed to mean?
22:44:13 <OceanSpray> lisp is inferior?
22:44:13 <Tac-Tics> shrug
22:44:28 <Cale> okay
22:44:30 <Tac-Tics> I'm just bored and fail at Haskell today
22:44:32 <tga> chronologically
22:45:17 <Cale> aha
22:45:22 <bitwize> Lisp is so powerful it lets you merge it with an inferior language. Or something.
22:45:28 <bitwize> It's like a movable blub point.
22:45:34 <Cale> in apply, you're passing eval expr to envInsert
22:45:42 <OceanSpray> yes
22:45:58 <Cale> eval expr has type  (LispEnv -> LispErrT (IORef LispVal))
22:46:09 <OceanSpray> yes
22:46:24 <Cale> But it looks like envInsert wants an IORef LispVal
22:46:33 <Cale> so, we have to do two things:
22:46:45 <Cale> 1) Supply the current environment as a parameter to eval expr
22:46:48 <oerjan> OceanSpray: i see in the Main module you are passing newIORef ... to envInsert, that needs to be run first
22:46:58 <Cale> 2) Run the resulting computation in order to produce an IORef
22:47:26 <OceanSpray> the current environment is always supplied
22:47:33 <OceanSpray> it's one of the arguments
22:48:04 <Cale> env
22:48:06 <OceanSpray> so...
22:48:16 <OceanSpray> env :: LispEnv
22:48:20 <Cale> oh, we also have to return something else too
22:48:37 <Cale> envInsert is going to give us a  LispErrT ()
22:48:55 <Cale> but apply wants to be a LispErrT (IORef LispVal)
22:49:08 <OceanSpray> yes
22:49:12 <OceanSpray> that's a problem
22:49:14 <Cale> So it'll have to return an IORef of some description.
22:49:17 <Cale> Which one?
22:49:36 <OceanSpray> IORef Null ?
22:49:46 <Cale> Nope :)
22:50:00 <Cale> Well, maybe it could create a new one
22:50:15 <Cale> What is the IORef it returns supposed to signify?
22:50:46 <OceanSpray> I was thinking of replacing those LispErrT (IORef LispVal)'s with LispErrT (Maybe (IORef LispVal))
22:50:53 <Cale> We could do that.
22:51:15 <oerjan> why does it need the IORef around the LispVal anyhow?
22:51:16 <OceanSpray> I was half-way into coding that in when I got flooded with type mismatches again
22:51:32 <OceanSpray> because LispVals are supposed to be "mutable"
22:51:52 <oerjan> all of them?
22:52:00 <OceanSpray> that is, if I were to (define a 5) and then (define b a), a and b will both map to the same IORef,
22:52:15 <OceanSpray> thus, (set a 6) will make it so that b => 6 too
22:52:38 <OceanSpray> that part's already tested and workin'
22:52:55 <OceanSpray> envInsert, envSet and envBind work perfectly.
22:53:57 <OceanSpray> now, there's a reason I don't just go the "usual" lisp-interpreter way and have eval recognize define, set and bind as special forms
22:54:18 <OceanSpray> I'm actually trying to make them first-class, as per LispProc
22:54:46 <OceanSpray> that way, you can do (define foo set), and (foo a 42) will work
22:55:11 <OceanSpray> Oy, MONOLOGUE
22:56:44 * OceanSpray hears crickets.
22:57:13 <Cale> hmm...
22:58:08 <OceanSpray> now, as I said before, I bit off WAY more than I can chew
23:11:41 <dibblego> can C++ call into a Haskell application? (so that I can use BOINC for grid computing)?
23:12:29 <dons> dibblego: yeah, (via C).
23:12:35 <dibblego> ok cheers
23:12:48 <dons> dibblego: Heffalump or lennart have worked with C++/haskell interop, so they might have some advice
23:12:55 <dibblego> righto
23:14:10 <sorear> dons: kolmodin or augustss?
23:14:42 <bitwize> Why would C++ want to interact with Haskell? You could do functional programming well enough with C++, and have enough control over memory allocation to run it on a *real server* that doesn't use swap :)
23:15:13 <dibblego> bitwize, parodying someone/something in particular?
23:15:20 <sorear> There are two kinds of programs, fast programs and correct programs.  There is no middle ground
23:15:29 <sorear> dibblego: he's lost his individuality
23:15:42 <sorear> dibblego: he's been corrupted into a puppet of qwe1234
23:15:56 <dibblego> that guy is funny
23:16:05 <bitwize> His recent swap comments were particularly retarded. I couldn't resist.
23:16:42 <dolio> Resistance is futile.
23:17:15 <bitwize> Apparently real servers don't degrade gracefully under load; they crap out on you as punishment for not playing memory accountant.
23:17:38 <sorear> If qwe1234 cares so much about memory, he should stop using a language that manages the stack automatically.
23:17:42 <sorear> C--, not C++.
23:18:12 <dibblego> if qwe1234 could reason, then we wouldn't have a qwe1234
23:18:12 <dons> sorear: augustss (CS works with C++ & Haskell)
23:18:14 <dolio> Yeah, but C-- might not give him his important static guarantees.
23:18:22 <dons> is qwe1234 still around?
23:18:27 <bitwize> yeah.
23:18:29 <dons> i note linuxer has disappeared from reddit...
23:18:32 <sorear> does C++ give you *any*?
23:18:39 <bitwize> Now he's telling everybody they're idiots for turning swap on
23:18:45 <dolio> @quote qwe1234 static guarantee
23:18:45 <lambdabot> No quotes match. You type like i drive.
23:18:49 <shachaf> dons: Gone?
23:18:55 <sorear> oh wait yeah, const ptrs
23:19:05 <shachaf> dons: You should write one, then. :-)
23:19:10 <dons> no posts in 3 days from linuxer
23:19:14 <dons> since the 'linuxer sucks' thread
23:19:32 <dolio> @quote qwe1234 static compile-time
23:19:32 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
23:19:43 <dons> ah, but qwe is still around
23:20:00 <dibblego> lol
23:20:03 <opqdonut> :D
23:20:22 <vsmatck> Seems to miss a big point.
23:20:30 <opqdonut> o rly?
23:20:37 <vsmatck> quite rly
23:20:46 <glguy> ya rly!
23:20:47 <glguy> nowai
23:20:47 <sorear> vsmatck: He ought to use TALT, right?
23:20:59 <shapr> qwe1234 should just be nice
23:21:06 <opqdonut> and besides, preferring c++ because of _compile times_ is just too funny :D
23:21:06 <shapr> He's all about insulting people
23:21:20 <glguy> no he's not you suxor
23:21:28 <sorear> Can we exile him from earth?  PLEASE?
23:21:29 <dolio> @quote stfu
23:21:30 <lambdabot> qwe1234 says: stfu, troll.
23:21:34 <vsmatck> I don't think the quote was about the times was it?
23:22:15 <shapr> sorear: I'd vote for it.
23:22:41 <shapr> If nothing else, people like that can be a good way to see what not to do.
23:22:45 <glguy> that God hasn't smote him yet is an argument against said God's existence..
23:23:11 <bitwize> He prefers C++ because of the guarantees it can achieve *at* compile time.
23:23:20 <shapr> Or infinite patience...
23:23:23 <opqdonut> ?remember glguy [concerning qwe1234] that God hasn't smote him yet is an argument against said God's existence..
23:23:23 <lambdabot> Done.
23:23:38 <blackdog> shapr: shades of "Hitchhiker's Guide"...
23:23:40 <opqdonut> ?quote god
23:23:40 <lambdabot> qwe1234 says: if programming languages were gods, something like smalltalk would be Cloacina, the goddess of the sewers
23:23:45 <opqdonut> ?quote god
23:23:46 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
23:23:46 <lambdabot> godawful construct?
23:24:06 <dons> anyone got a theory on the linuxer disappearance?
23:24:17 <glguy> dons: his feelings were hurt?
23:24:28 <dons> did some reddit admins take to heart the comment about bots defeating submission quality control?
23:24:32 <monochrom> he moves on to Mac? :)
23:24:53 <glguy> naw reddit admins dont maintain the community
23:24:54 <dolio> Maybe he decided he finally had enough karma.
23:25:19 <byteshack> you all know if there is a gentoo ebuild for yi?
23:25:33 <sorear> Is that existential or universal?
23:25:42 <sorear> @seen dcoutts
23:25:42 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 6h 28m 11s ago.
23:28:02 <dons> glguy: yeah, so that's what would be surprising.
23:28:16 <dons> if he really left because we made such persuasive points :)
23:28:24 <dons> maybe he just got banned -- they do ban the odd user
23:29:27 <Binkley> well, why would they ban linuxer and not qwe1234? :-)
23:29:57 <opqdonut> Binkley: think what we'd miss out on if it were not for qwe1234
23:30:07 <opqdonut> linuxer was replacable
23:30:35 <Binkley> opqdonut: the repeated and nagging urge to slam one's head into a desk? :-)
23:30:53 <bitwize> We'd miss out on how *real* software engineering is done, instead of the scary branch-davidian cult stuff we do :)
23:31:58 <bitwize> That's a very Nuddsish trolling tactic btw; Nudds called people who wrote in C "C pushers" and wrote at length about their "cult", "sick religion", &c.
23:32:35 <dolio> What did he recommend? Assembly?
23:32:50 <bitwize> Yes.
23:33:04 <Binkley> I'm OK with C programmers as long as they don't flaunt it in public.
23:33:11 <bitwize> Of course he was handwavy about the details much as qwe1234 is but he seemed to suggest a sort of portable assembler
23:33:16 <sorear> I'm a C programmer.
23:33:23 <sorear> It's just one of my hammers, though.
23:33:28 <Binkley> And as long as they stay away from my children.
23:33:59 <sorear> I throw it at problems that are 1. extremely simple 2. performance constrained
23:34:20 <bitwize> what about memory constraints?
23:34:47 <sorear> Binkley: Memory constraints are a fiction invented by Korean megacorps to increase sales.
23:35:01 <sorear> s/Binkley/bitwize/
23:37:46 <OceanSpray> embedded applications?
23:38:14 <bitwize> There are still classes of problems for which memory management is done by the project team lead on a whiteboard -- I don't think Haskell would fit well there without being seriously constrained in some way :)
23:41:47 <OceanSpray> breakin' it down...
23:49:27 <OceanSpray> Cale, you still here?
23:54:06 <DRMacIver> Morning
23:54:17 <OceanSpray> Evening
23:55:38 <OceanSpray> ok guys:
23:57:27 <OceanSpray> I got an 'IORef Val' inside a 'do' in a function that's supposed to return a ValErrT (IORef Val)
23:57:57 <OceanSpray> how do I 'extract' the 'Val' in the IORef?
23:58:06 <shachaf> readIORef?
23:59:10 <OceanSpray> :t readIORef
23:59:12 <lambdabot> Not in scope: `readIORef'
23:59:16 <OceanSpray> :k readIORef
23:59:18 <lambdabot> Not in scope: type variable `readIORef'
23:59:51 <shachaf> @index readIORef
23:59:51 <lambdabot> Data.IORef
