00:01:28 <eivuokko> I don't know.  I wonder why it needs cabal head.
00:03:17 <eivuokko> I think, as a hack, you might be able to use Distribution.PackageDescription.flattenPackageDescription
00:04:40 <RogerTaylor> not to worry
00:04:50 <RogerTaylor> i'll just sift through all those deps by hand
00:05:05 <RogerTaylor> thanks for your time
00:05:09 <eivuokko> ie change readPackageDesciption into (fmap flattenPackageDescription readPackageDescription)
00:38:30 <DRMacIver> Morning
00:51:41 <hpaste>  sebell pasted "unsafePerformIO/-threaded troubles" at http://hpaste.org/2407
00:54:28 <LeCamarade> sebell: Hmm ... unsafe* should be pasted when it doesn't cause trouble ... :o)
00:55:36 <sebell> Ha. I wonder if it's necessary in this situation?? I would imagine I put it there for a reason ;)
00:56:04 <LeCamarade> :o)
00:56:53 <dons> someone made a joke today that everything in C++ is unsafe* -- 'cept the things that actually marked are safe*
00:57:40 <dons> sebell: oh, is that the known issue with threads racing on the a buffer with unsafePerformIO ?
00:57:56 <dons> (fixed in the head)
00:58:10 <Cin> LeCamarade: your nostrels have merged into one! lay off the cola
00:58:21 <sebell> dons: I lied, it's unsafeInterleaveIO - but I suspect it may be the same thing.
00:58:39 <LeCamarade> Hahahaha.
00:58:57 * LeCamarade refrained from the smiley ... the nose issue, you know. :o)
01:00:30 <LeCamarade> I'm going to be trying to write a mid-level functional programming language to _try_ and demonstrate that, with an aggressive-enough optimisation arsenal, functional programming is just a (provably-correct) notation for imperative coding.
01:00:56 <dons> isn't that already well known?
01:01:05 <dons> there's many many FP languages for high performance scenarios
01:01:09 <LeCamarade> dons: Not apparently - see how crappy GCC is.
01:01:23 <LeCamarade> I mean to x86 assembly ...
01:01:32 <shapr> LeCamarade: But GCC already uses SSA...
01:01:41 <LeCamarade> Nobody seems ready to write a kernel in an ML-esque ...
01:01:51 <shapr> What about the L4 kernel in Haskell?
01:01:53 <shapr> Or House?
01:02:05 <shapr> What about the Hardware monad mentioned in the House papers?
01:02:24 <dons> LeCamarade: maybe check out the benchmarks for the lazy, pure FP language Clean
01:03:16 <LeCamarade> Yeah, Clean and Haskell are the inspiration ...
01:03:33 <dons> don't forget OCaml
01:03:39 <LeCamarade> (No SSA in-between though ...)
01:04:00 * osfameron has heard a couple of times here that GCC is crappy.  Yet I thought it had a good reputation elsewhere - are there good papers or links for more details?
01:04:02 <shapr> in-between what?
01:04:41 <LeCamarade> Um ...  and I want it pure, if possible.
01:05:45 <LeCamarade> shapr: As in, I want from optimised AST to x86. I don't know how high that one is. The single-assignment and all that SSA use are supposed to be part of the langauge's main syntax.
01:06:45 <dons> might be easier to go via ANF form then, LeCamarade
01:06:58 <bluestorm> there were some OCaml kernel projects
01:07:01 <shapr> Yeah, Administrative Normal Form, w00!
01:07:03 <dons> SSA is a bit of a beast, so staying in a more obviously FP langugae for the intermediate form is a bit nicer.
01:07:14 <bluestorm> but i guess they were using the imperative part for the low-level stuff
01:08:04 <LeCamarade> bluestorm: It was called Riverside (or Oasis?). It stalled sometime, I think.
01:08:10 <bluestorm> hm
01:08:20 <bluestorm> i heard of Desert Spring Time and Funk
01:08:28 <bluestorm> (i think boss are dead now)
01:08:30 <LeCamarade> Oh, yeah. Desert Sprintg Time.
01:08:33 <bluestorm> s/boss/both/
01:09:02 <LeCamarade> s/Springt/Spring/gi  # and the type-checker let it through! X^(
01:09:37 <bluestorm> hm
01:10:25 <bluestorm> the coyotos project try to design a langage for kernel creation that would (might ?) be suited for formal verification
01:11:31 <LeCamarade> Me, I think if it is a micro-kernel, and the main parts are verified _and the interfaces_, *and a strong type system is used for the interfaces*, you get a very, very stable something.
01:12:11 <LeCamarade> More, even, than Singularity (which used annotations to take care of problems that don't occur in above-mentioned context).
01:13:10 <shapr> With sufficient type safety, you'd be able to dispense with memory protection.
01:13:32 <LeCamarade> shapr: Yeah, the Singularity guys showed that. :o)
01:14:12 <LeCamarade> shapr: In fact, if Haskell ever teaches the world _anything_ it will be the importance of a strong type-system and purity. Not even monads. :o)
01:14:57 <shapr> Lazy evaluation is self modifying programs done right.
01:15:37 <LeCamarade> In fact ... if we handle many of the dynamic concerns (memory protection, blind-faith-on-NULL, et cetera) in the type system (or, generally, compiler), we can put portability problems behind us.
01:16:08 <LeCamarade> I mean hardware portability ... /me is thinking about that ...
01:16:25 * shapr rebuilds the jhc libs one more time...
01:18:13 <bluestorm> hm
01:22:07 <bluestorm> the problem i see with purity here is that kernel programming has to do with hardware, wich use mutability
01:22:29 <bluestorm> (hardware is not liberated from Von Neumann style yet)
01:23:29 <bluestorm> purity looks like a good idea but in the end, kernel programmers think imperatively
01:23:59 <LeCamarade> bluestorm: Well, I think you can make the necessary transformations to represent correct imperativeness, froma pure form. For example, every recursion (not just tail) becoming a while loop ...
01:24:04 <bluestorm> i'm not sure forcing the to use a programming style that does not match the way they understand what they're doing is a good idea
01:24:07 <bluestorm> hm
01:24:45 <bluestorm> LeCamarade: i think it's important to build metaphor that would allow them to *think* in a pure form
01:25:08 <LeCamarade> When you remove intermediate lists (like what ndm is doing on Supero) you end up with what an imperativist would have written, only you mined it out of a purely-functional notation.
01:25:17 <bluestorm> just thinking "hey that's a loop, let's translate it into a recursive function" will not do the job
01:25:45 <bluestorm> hm
01:26:12 <LeCamarade> bluestorm: Well, that's part of what I am going to be trying to do in my lil' project. To see if I can generate very, very imperative and imperative-looking x86 from a _purely-functional language_. Because ...
01:26:14 <bluestorm> so you're saying "just change the way you write code, you'll get the same result but in a safer way" ?
01:26:26 <bluestorm> hm
01:27:05 <LeCamarade> ... for me, frankly, purely-functional is just a notation for imperative (an elevated way of expressing imperative).
01:27:14 <LeCamarade> bluestorm: Exactly.
01:27:35 <sorear> bluestorm: Sure, hardware is imperative, but most of what a (modern monolithic) kernel does isn't hardware - it's protocol and resource allocation.
01:27:44 <LeCamarade> Change the way you write code, write Haskell, be patient and let the compiler chug away and chug and chug and chug, and you get better, safer C.
01:28:20 <sorear> bluestorm: Linux has some fairly fancy algorithms for page cache management, process scheduling, and file storage, even if the device drivers are boring evil.
01:28:30 <bluestorm> hm
01:29:04 <bluestorm> i always thought filesystem should be written in a functionnal language ^^
01:29:18 <bluestorm> -n
01:29:28 <sorear> bluestorm: exactly.
01:29:37 <LeCamarade> If we can wait for the compiler to optimise HelloWorld.hs for three hours, it just might end up as int main(int argc, char ** argv){ printf("Hello, World!"); return 0;} Safely, and provably-correct. And QuickCheckable.
01:29:38 <osfameron> would you be able to get that to compile to sufficiently fast C by limiting the subset of Haskell that you used?
01:29:56 <sorear> balodja: that's what I'm saying - not all kernel code is imperative in nature
01:29:56 <bluestorm> hm
01:30:00 <sorear> osfameron: sure
01:30:11 <sorear> @go Wadler Listlessness is better than laziness
01:30:14 <lambdabot> http://portal.acm.org/citation.cfm?id=802020
01:30:14 <lambdabot> Title: Listlessness is better than laziness
01:30:28 <sorear> hmm, not useful :/
01:30:39 <LeCamarade> sorear: I've read that (and other similar papers) for a while over and over and thought. :o)
01:30:54 <LeCamarade> There is the one on deforestation. And the ndm stuff.
01:31:00 <bluestorm> it would be great if lambdabot had a acm account, able to share stuff :-‚Å∞
01:31:07 <sorear> never actually found a free citation, but Wadler did some work on compiling a subset of KRC to extremely efficient state machines
01:31:13 <LeCamarade> The ndm stuff has been inspirational. The guy is mining raw performance, for sure.
01:31:25 <bluestorm> (ndm stuff ?)
01:31:32 <sorear> @seen ndm
01:31:33 <lambdabot> I saw ndm leaving #haskell 9h 3m 46s ago, and .
01:31:35 <sorear> that guy.
01:31:41 <bluestorm> hm
01:31:47 <bluestorm> the Supero guy ?
01:31:47 <sorear> Neil David Mitchell
01:31:50 <LeCamarade> ?go deforestation for higher order functions wadler
01:31:52 <lambdabot> http://citeseer.ist.psu.edu/396613.html
01:31:52 <lambdabot> Title: Deforestation for Higher-Order Functions - Marlow, Wadler (ResearchIndex)
01:32:06 <bluestorm> yeah deforestation is cool
01:32:16 <LeCamarade> Yeah, the Supero guy.
01:33:43 <bluestorm> now i've read that deforestation paper, i feel uneasy each time i compose a fold with a map in ocaml ^^
01:34:59 <bluestorm> hm
01:35:59 <bluestorm> about the compilers, it seems to me that we (we = the clever guys that write compilers) are still missing basic things
01:36:38 <bluestorm> i read the spj introducory paper on GHC ("Compiling by transformation", iirc), and it looks like cooking sometimes
01:36:59 <bluestorm> "after that pass we do a simplification again, because we don't really know what could happen, that may be good"
01:38:05 <osfameron> heh
01:38:06 <bluestorm> i mean, there must be tools to be almost sure of what the effect of something will be
01:38:16 <LeCamarade> :o)
01:38:17 <bluestorm> we just haven't found them yet
01:38:37 <therp> away with turing completeness!
01:38:39 <LeCamarade> It's P = NP? all over again. :o)
01:38:45 <bluestorm> hm
01:39:10 <bluestorm> (did i say something related to turing completeness and/or P=NP ?)
01:39:24 <osfameron> how much does it cost to access the ACM library?
01:39:34 <Spark> type and effect systems, program analysis, theorem provers
01:39:35 <LeCamarade> osfameron: Not free?
01:39:35 <Spark> take your pick
01:39:40 <bluestorm> :]
01:39:52 <bluestorm> i was not meaning "effect" in that sense
01:40:08 <LeCamarade> osfameron: I get the ACM Queue ... for free. I thought it is the same for the libs.
01:40:20 <osfameron> LeCamarade: I always assumed it wasn't... ah!  It looks like there is a "limited" free registration
01:40:25 <bluestorm> (altought i actually don't know what " 'effect' in that sense " mean)
01:40:27 <bluestorm> hm
01:40:28 <LeCamarade> Grrr.
01:40:33 <therp> osfameron: are you enrolled in any university? I get ACM access through my university
01:40:38 <LeCamarade> Yay.
01:41:05 <LeCamarade> Or just pick-and-forget-to-return from the nearby library? ;o)
01:41:31 <osfameron> therp: nope.  But it does look like it's $198 with access to the library, which might be worth paying.
01:41:51 <LeCamarade> Usually you can get the papers elsewhere.
01:41:55 <therp> osfameron: $198 annually?
01:41:56 * bluestorm wants an Open Access ACM
01:42:04 <osfameron> therp: yeah
01:42:13 <osfameron> I did say /might/ ;-)
01:42:36 * therp refused his last conference paper to be added to the ACM digital library with the reason "no open access"
01:42:52 <bluestorm> congratulations :]
01:44:14 <Spark> people should just put papers on websites
01:44:23 <Spark> and maybe we should have a freshmeat style thing for new papers
01:44:31 <bluestorm> hm
01:44:32 <Spark> you will need review boards and conferences, but not actaul publications
01:45:07 <bluestorm> i think there need to be a peer-review somewhere
01:45:11 <Spark> s/will/still/
01:45:12 <therp> publications in dead tree form have become obsolete right..
01:45:25 <Spark> no, you can still print them out on your laser printer :>
01:45:33 <Spark> just pointless to print out massive books of them
01:45:39 <Spark> even at conferences i think
01:45:50 <osfameron> papers are still easier to read on paper
01:45:52 <Spark> it would be better to have a pile of each paper, and let people take the papers they are interested in
01:45:58 <osfameron> as PDF sucks as a screenreader format
01:47:15 <therp> hm for conferences it's handy to have the papers on paper.. but unless it's not some really huge conference that will be 100 prints.. compared to a sequel of harry potter this is negligible.
01:47:28 <Spark> yeah
01:47:42 <LeCamarade> a2ps -s duplex *.pdf& :o)
01:47:54 * therp wants a good e-paper reader
01:48:09 <Spark> paper: higher resolution, longer battery life, lighter, cheaper, less delicate, supports annotations, readable outside
01:48:20 <Spark> any more?
01:48:33 <LeCamarade> therp: Saw one on Click, sometime. Looks like paper. Bends. Uses a kind of static bitmap. Low power. Wow.
01:48:40 <bluestorm> readable in hostile environments
01:49:06 <bluestorm> (language class for example)
01:49:11 <Spark> readable on the front line of world war 1
01:49:21 <Spark> catches fire easily (yes, this is a bonus)
01:49:36 <LeCamarade> bluestorm: Just put it in the Latin textbook?
01:49:37 <Spark> can be made into an aircraft
01:49:51 <therp> spark :)
01:52:45 <eivuokko> *can be reused as aircraft ;)
01:54:26 <Spark> the only time i think an ebook reader would be useful is if you had thousands of papers on it
01:54:37 <Spark> but even then, i like to cross reference things
01:54:45 <Spark> there's no way it won't be inferior to paper
01:55:15 <eivuokko> Papers can be really annoying to read in wind, though.
01:56:39 <bluestorm> Spark: hm
01:56:45 <bluestorm> some thing are easier with a computer
01:56:54 <Spark> like causing yourself main and suffering
01:56:58 <bluestorm> search for example
01:56:58 <bluestorm> hm
01:57:06 <osfameron> it's the "formatted into 2 columns" thing that is rubbish on a computer
01:57:18 <osfameron> unless some ebook reader now handles that gracefully?
01:57:26 <bluestorm> i'm fond of the bibliography hyperlinks in the paper
01:57:26 <Spark> i dunno, columns are ok
01:57:27 <LeCamarade> iPaper would do all those things, I think. Jobs, you hear me???
01:57:31 <Spark> i usually code in multiple columns
01:57:56 <osfameron> Spark: even with having to scroll back up to the beginning of the 2nd column? I find it horrid
01:58:01 <bluestorm> in a dead tree form i never know what the [13] paper actually is
01:58:24 <osfameron> Spark: also, acquiring another column is tricky, as horizontal scroll is always really annoying and not optimized like vertical scroll with scrollwheel
01:58:47 <Spark> mm it doesn't make sense unless the screen is big enough for both
01:59:13 <bluestorm> (btw i don't know why everybody choose the [Index] form over the [NameYear] one, wich i find much better)
02:02:50 <dons> 2 columns are just so we can cram more in to 12 pages
02:03:14 <dons> doesn't help readers -- often you're asked to submit double spaces, single column for reviewers, before setting as 2 columns for the final version
02:03:25 <dons> to save the publishers some money, I guess
02:06:20 <bluestorm> hm
02:12:47 <olsner> can you fit more into a two-column page than a one-column page? sounds counterintuitive
02:13:57 <osfameron> yes, by making the type smaller :-)
02:14:07 <bluestorm> one column page use more space on each side
02:14:16 <ricky_clarkson> I hate reading PDFs with 2 columns, on a screen.
02:14:38 <osfameron> but it would be fine if pdf readers could unflow the columns.  But I guess it's hard because the whole point of PDF is to specify the layout, unlike HTML...
02:16:17 <flux> reading such pdfs would be nicer if the readers knew about the flow
02:22:32 <hpaste>  clemens pasted "all-my-patches.sh: extract all your darcs patches into .diffs (for GSoC participants)" at http://hpaste.org/2411
02:22:56 <opqdonut> :)
02:28:47 <shapr> @seen JohnMeacham
02:28:47 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I don't know when JohnMeacham last spoke.
02:29:56 <shapr> Any idea how I can get out of a while loop in a shell script when C-c is pressed?
02:31:09 <conal> @localtime shapr
02:31:09 <lambdabot> Local time for shapr is Fri Aug 24 04:29:07 2007
02:31:22 <conal> shapr: 4:30am?
02:31:26 <shapr> Well.. yeah.
02:31:34 <ibid> shapr: i usually put the loop in a subshell, seems to work
02:31:45 <shapr> @localtime conal
02:32:29 <conal> shapr: did you get a reply?
02:35:17 <olsner> something with trap could work (trap SIGINT "exit" or whatever the syntax is)
02:35:54 <olsner> and perhaps trap SIGCHLD too, to catch dying subprocesses
02:44:32 <LeCamarade> Them things remind me why I've never really done shell scripting, despite doing nearly 2x other languages. (And I'm a new-generation one, as well ...) :o)
03:15:12 <ski> *beep* *beep* *BEEP*
03:15:54 <conal> why so quiet here?
03:16:01 <xerox> did you hear the alarm?
03:16:11 <conal> alarm?
03:16:20 <[LeCamarade]> > repeat "Yell, yell, yell! \o/"
03:16:21 <lambdabot>  Illegal escape sequence
03:16:36 <[LeCamarade]> > repeat "Yell, yell, yell! \\o/"
03:16:38 <lambdabot>  ["Yell, yell, yell! \\o/","Yell, yell, yell! \\o/","Yell, yell, yell! \\o/",...
03:16:45 <xerox> okay... :)
03:20:27 <dons> ?yow!
03:20:28 <lambdabot> Well, I'm INVISIBLE AGAIN ... I might as well pay a visit to the LADIES
03:20:28 <lambdabot> ROOM ...
03:20:58 <xerox> ?yarr.
03:20:58 <lambdabot> Arr! Me ship be the biggest brig in the port!
03:30:29 <|Jedai|> @info Array
03:30:30 <lambdabot> (Array)
03:30:40 <|Jedai|> @info Data.Array
03:30:40 <lambdabot> (Data.Array)
03:30:47 <|Jedai|> @info IArray
03:30:47 <lambdabot> (IArray)
03:31:17 <xerox> What are you looking for?
03:31:33 <|Jedai|> xerox: The instances of Array
03:31:41 <xerox> ?docs Data.Array
03:31:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
03:32:33 <|Jedai|> xerox: Ok, but shouldn't info list them ?
03:32:38 <xerox> Then you also get Data.Array.IArray and Data.Array.MArray
03:32:51 <xerox> |Jedai|: it used to. But people thought it was too noisy.
03:33:04 <xerox> lambdabot also has got:
03:33:53 <xerox> ?instances Ix
03:33:54 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
03:33:58 <xerox> ?instances-importing Data.Array Ix
03:33:59 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
03:34:15 <xerox> ?instances-importing Data.Array.IArray IArray
03:34:16 <lambdabot> Array e
03:34:49 <xerox> Misses some, hehe.  You're better off reading ?docs Data.Array.IArray & co.
03:35:48 <Bourbaki> hello
03:36:03 <Bourbaki> is arr in the arrow notation coalgebraic?
03:36:37 <Bourbaki> while the arrow operators are algebraic
03:45:09 <zipMe> When should one use ByteStrings over Strings ???
03:46:14 <sieni> zipMe: when you are processing bytes instead of characters
03:46:45 <DRMacIver> Um..
03:46:49 <DRMacIver> What?
03:47:01 <mboes> hi #haskell, anyone know if there is a parser out that parses Haskell written in Parsec?
03:47:25 <|Jedai|> @hoogle comparing
03:47:29 <lambdabot> No matches found
03:47:32 <zipMe> sieni : can you give me a typical example ?
03:47:47 <EvilTerran> zipMe, for processing binary data. images, etc.
03:47:56 <EvilTerran> audio.
03:48:09 <DRMacIver> Um. Isn't ByteString intended as a straight String replacement?
03:48:10 <TSC> zipMe: You'd use bytestrings when you want efficiency at the expense of some convenience
03:48:19 <zipMe> EvilTerran : ok
03:48:29 <dcoutts> DRMacIver: almost, the behaviour is somewhat different
03:48:35 <DRMacIver> ok
03:48:36 <TSC> You can certainly use bytestrings for processing character data
03:48:59 <DRMacIver> I guess what I mean is that the distinction isn't "You use Strings for characters, ByteStrings for bytes".
03:49:12 <EvilTerran> "character" is a more abstract concept than "byte" -- a haskell Char is not necessarily a byte.
03:49:14 <zipMe> TSC : is the effciency given ? Because I've replaced Strings with BS in a toy program and it was slower :(
03:49:16 <DRMacIver> Which is what sieni and EvilTerran seem to be implying...
03:50:06 <TSC> zipMe: It probably depends on what you're doing
03:50:19 <EvilTerran> DRMacIver, i'm saying that the semantics of the functions on strings are for textual data, and the semantics of the functions on bytestrings are for bytes
03:50:22 <TSC> But for large input reading or processing, bytestrings should be faster
03:50:34 <EvilTerran> you can use either for either, but one should generally be easier than t'other
03:51:06 <EvilTerran> but sometimes it's desirable to use bytestrings rather than strings for text anyway, for performance reasons
03:51:09 <cognominal_> if you want all the hierarchy of abstracton of unicode (graphemes and all that), what is the appropriate library?
03:51:17 <dons> zipMe: it depends on what you're doing. you can't simply replace list cons with bytestring cons, for example, as the complexity changes.
03:52:44 <zipMe> dons : you mean replace strings with BS in my program at a later stage when i look for a performance bost ?
03:53:44 <dons> zipMe: you just can't naively replacement, since the very common (:) operator on lists has different complexity with strict bytestrings
03:54:02 <dons> s/replacement/replace with bytestrings/
03:54:05 <TSC> You'd need to stop doing list-y things
03:54:17 <dons> yeah, and try to do more substring oprations (like drop and take)
03:54:26 <dons> since they become O(1)
03:58:26 <|Jedai|> Where is comparing ? Or isn't it in the Standard libs ?
03:59:08 <[LeCamarade]> jedai: Comparing?
03:59:14 <psykotic> dons, i know you don't work on it, but since ndm isn't here--isn't the untypedness of yhc.core an issue for code generation? it seems... weird.
03:59:39 <jedai> [LeCamarade]: I saw it frequently, guess it's just a current idiom
03:59:43 <psykotic> dons, i mean, how do you generate efficient code if you throw away the types?
04:00:03 <jedai> [LeCamarade]: comparing f a b = compare (f a) (f b)
04:00:07 <doserj> jedai, it is in Data.Ord
04:00:16 <EvilTerran> @src comparing
04:00:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:00:21 <EvilTerran> @index comparing
04:00:22 <lambdabot> bzzt
04:00:25 <jedai> doserj: Thanks, hoogle doesn't find it
04:00:25 <dons> psykotic: it seems really weird, doesn't it.
04:00:36 <dons> psykotic: i don't know how they deal with that.
04:00:51 <psykotic> maybe they just feed it to ghc :)
04:01:10 <dons> they do do that :)
04:01:52 <dons> remember that compilation via transformation, and typed intermediate forms, was unusal in the early 90s when nhc was written
04:01:57 <Philippa> I think they're going to have problems with it... hmm. Actually, I think I might be able to find a problem already
04:02:06 <Philippa> namely polymorphic recursion
04:02:06 <dons> and yhc inherits that, i guess
04:02:24 <Philippa> if YHC doesn't keep type annotations at all, then feeding it back into GHC is likely to break
04:02:36 <psykotic> Philippa, yep, that was my first thought
04:02:55 <psykotic> and that's just h98. if they want to support higher-rank polymorphism there's no way around annotations for many cases.
04:02:58 <Philippa> and they're going to be in a world of pain if they add an extension like rank-n types
04:02:58 <dons> being able to typecheck the various forms in ghc has been a great win, just for getting the compiler right.
04:02:59 <Philippa> right
04:03:37 <dons> but coming up with a type system that lets you encode all the extensions you want is non-trivial -- which might be the main reason
04:03:55 <Philippa> yeah, it's an understandable one
04:04:25 <Philippa> though if you don't mind having to translate out type classes then a System F variant is likely to form at least the core of whatever you run with
04:05:19 <psykotic> dons: how does ghc deal with it? does it do type inference at the haskell level and then type checking at the core level?
04:05:36 <dons> yep
04:05:41 <dons> and again on C--
04:05:57 <Philippa> I believe it does inference-and-checking on the Haskell level?
04:06:00 * [LeCamarade] wonders how you can dodge a System F-like, really. Didn't know anyone was doing it.
04:06:07 <psykotic> i guess inference implies checking
04:06:13 <dons> `core lint' is basically just type checking System F
04:06:16 <psykotic> or rather, a reasonable definition would include it as a subset, i think
04:06:19 <dons> or system Fc, now.
04:06:31 <psykotic> (you let annotations generate constraints)
04:06:33 <Philippa> [LeCamarade]: being untyped
04:06:33 <dons> you could go the JHC way and use the lambda cube directly
04:06:57 <Philippa> yeah, but for certain values of System F-like that's still System F-like :-)
04:07:28 <[LeCamarade]> Philippa: Hmm ... but can you stand not being typed? :o)
04:07:51 <[LeCamarade]> I mean ... ML isn't better than Clisp for nothing ... ;o)
04:07:56 <Philippa> that's what the YHC folks're doing
04:08:16 <Philippa> though they've reached the point where I'm told they're not seeing any particular advantage in it any more
04:08:41 <psykotic> dons: btw what's the reason for re-doing the work at the C-- level? is it just a consistency work, or isn't there a way to translate the types from the Fc level?
04:08:41 <Philippa> bear in mind that I've had this argument with ndm before :-)
04:08:52 <psykotic> *consistency check
04:09:05 <Philippa> psykotic: I doubt there's a way to translate Fc types into it meaningfully
04:09:19 <Philippa> C--'s type system is more akin to C's
04:09:32 <psykotic> well, it seems like if they're reconstituted anyway, there might be a translation
04:09:36 <psykotic> essentially a type-level compilation
04:09:48 <Philippa> Fc's still erasable
04:09:53 <Philippa> that's part of the point
04:10:06 <psykotic> sure
04:10:38 <psykotic> most lambda calculi deserving of the name should be :)
04:10:48 <dons> psykotic: just consistency checking the C-- optimisations
04:11:00 <psykotic> right.
04:11:13 <psykotic> is it actually C-- or just a sorta-kinda C--?
04:11:16 <Philippa> and primitives and...
04:11:23 <dons> sorta kinda C--
04:11:31 <psykotic> i figure since GHC is the only real customer of it, its dialect might have drifted quite a lot to cope with new demands.
04:11:39 <dons> let me find the file, i wrote a description in it somewhere of what part of c-- we use
04:11:46 * Philippa screwed up an IL implementation of a primitive from the next language up once, it was a real PITA to debug
04:12:07 <richi_> is there anyway you can get the index number of an element in a list, i've used xs !! n but its not exactley what i want
04:12:28 <richi_> sorry im a haskell newbie, been doing java too long
04:12:29 <dons> http://darcs.haskell.org/ghc/compiler/cmm/PprCmm.hs
04:12:36 <Philippa> richi_: you mean, find the position of the first x in a list?
04:12:38 <dons> `Pretty-printing of Cmm as (a superset of) C--'
04:12:45 <richi_> yeah
04:12:48 <sieni> richi_: you can recover from that
04:13:02 <dons> lovely comments in that file :)
04:13:02 <richi_> i wish to
04:13:11 <dons> even cites the C-- reference
04:13:24 <Philippa> richi_: look up elemIndex in the docs for Data.List
04:13:31 <psykotic> dons: cheers
04:13:34 <richi_> ok thanks!
04:14:20 <psykotic> dons: you mentioned that typed intermediate languages are a relatively recent invention. what's the history behind that? it seems like a fairly obvious idea, so there must have been some technical obstacles?
04:14:36 <psykotic> dons: was the issue just finding a language that hit a balance between complete and simple?
04:15:24 <dons> psykotic: i know that in the early-mid 90s (and still today) you can get published with new typed intermediate forms, where all optimisations proceed by type-preserving transformations of the intermediate form
04:15:46 <dons> see the mid-90s ghc papers about compilation via transformation
04:15:56 <psykotic> okay, i will
04:16:00 <dons> they must have some historical work
04:16:25 <dons> it certainly takes the invention of sufficiently rich type systems
04:16:26 <Philippa> psykotic: the type systems available stank for a long time, and Curry-Howard took a while to permeate
04:16:33 <dons> yeah
04:16:40 <dons> jinx, modulo renaming ;)
04:16:42 <psykotic> well, system F was around
04:16:44 <Philippa> CPS and ANF were big leaps, too
04:16:47 <psykotic> since, what, late 70s? early 80s?
04:17:01 <Philippa> yeah, now consider how long that takes to reach compiler hackers
04:17:06 <psykotic> that seems to cover haskell 98 after dictionary passing translation
04:17:08 <dons> yeah, the step was then to say, "hey, let's just use that inside our compiler, not just for writing papers"
04:17:13 <psykotic> ok
04:17:19 <dons> same with the use of Henk/lambda cube, as a compiler intermediate form
04:17:55 <dons> the new System Fc paper might have some background too
04:18:08 <Philippa> new Fc paper? Where?
04:18:08 <psykotic> Philippa, using CPS as an intermediate form was late 70s. e.g. steele's RABBIT compiler was in 76 i think.
04:18:13 <dons> since it is really the latest and greatest in non-dependently typed IRs
04:18:14 <popcount> When I use iterateM and then take 5 results,  the computation fails, but when I use an expliticit counter with recursion to control whether the actions need to be executed and the construction of the list, everything is fine. In the state monad, iterateM does work as expected (lazily)
04:18:19 <psykotic> Philippa, and i think everyone knew of that work at the time.
04:18:23 <dons> psykotic: POPL this year?
04:18:41 <Philippa> psykotic: sure. OTOH, typed CPS is pretty painful - ANF was a /big/ deal in terms of people being willing to start playing
04:18:47 <psykotic> oh yeah, typed CPS is a bitch...
04:18:55 <psykotic> i don't think that was figured out until mid-late 80s
04:18:57 <Philippa> ndm: we think we've found a possibly issue with doing YHC Core -> GHC again
04:19:10 <Philippa> and ANF was 1993
04:19:13 <popcount> Could the fact that I use an STUArry be relevant?
04:19:19 <dons> and then finding the translation between SSA and ANF strengthens that further
04:19:19 <popcount> STUArray*
04:19:26 <ndm> Philippa: what?
04:19:37 <Philippa> polymorphic recursion
04:19:42 <ndm> and how do you upload a file onto the wiki? it seems to be broken for me
04:19:53 <ndm> Philippa: plus rank-2 types, plus unboxed kinds (realWorld#)
04:19:55 <Philippa> good question, I don't think I've done it with that wiki
04:20:14 <ndm> Philippa: i'm aware of these things in a kind of painful bites me in the ass every day kind of manner
04:20:20 <Philippa> :-) Fair enough
04:20:54 <Philippa> is there any plan to turn YHC Core typed?
04:21:06 <ndm> Philippa: no, since its a bad idea :)
04:21:35 <Philippa> *shrug* - fair enough, it'll mean you just can't keep using GHC as a back-end without a heavyweight translation though
04:22:06 <ndm> i know
04:22:18 <ndm> or lots of unsafeCoerce
04:22:37 <psykotic> ndm, have you written anything about the rationale behind untyped core?
04:22:46 <Philippa> psykotic: lots of argument in here :-)
04:23:16 <ndm> psykotic: no, i have discussed it with people though, i really should do - given how my viewpoint is 180 degrees opposite to all the professionals in the field
04:23:21 <psykotic> right :)
04:23:28 <psykotic> i guess your overriding concern is simplicity?
04:23:33 <ndm> yes
04:23:35 <richi_> ok i need some advice, i have a function which looks like this; updateRow (x:xs) n where x:xs is a list and n is the nth term of the list, so its an integer. So what i want to do is go to the nth position of the list then manipulate the element with another function. Is it better to use recursion or tweak with the elemIndex function
04:23:39 <dons> or is it a historical artifact of nhc ?
04:23:41 <psykotic> at what levels?
04:23:51 <ndm> and future stability - type systems change, Core doesn't
04:23:54 <psykotic> like, i know you have some nice backends, e.g. for js2
04:23:56 <dons> richi_: how about drop and take?
04:24:04 <mauke> splitAt!
04:24:06 <richi_> whats that
04:24:08 <psykotic> but it seems you could just write that wrt the erased core if you wanted, if it was typed
04:24:13 <dons> and make it higher order, so it takes a function to do the manipulation
04:24:15 <dons> :t splitAt
04:24:17 <lambdabot> forall a. Int -> [a] -> ([a], [a])
04:24:21 <dons> > splitAt 3 "haskell"
04:24:22 <lambdabot>  ("has","kell")
04:24:24 <ndm> psykotic: you can write a Core transformer in a few lines, if you have to massage a proof of types through it gets much more complex
04:24:35 <ndm> dons: originally, yes, now i think its a strength as well
04:25:12 <psykotic> ndm: you mean a transformer for the optimizer or something like that?
04:25:25 <dons> > let hack f s n = let (a,b) = splitAt n xs in a ++ case b of [] -> [] ; (x:xs) -> f x : xs in hack toUpper "haskell" 3
04:25:26 <lambdabot>   Not in scope: `xs'
04:25:26 <psykotic> you should be hacking in lisp! :)
04:25:31 <ndm> psykotic: just any type of transfomer, for analysis, for optimisation - anything
04:25:35 <psykotic> ok
04:25:44 <dons> > let hack f s n = let (a,b) = splitAt n s in a ++ case b of [] -> [] ; (x:xs) -> f x : xs in hack toUpper "haskell" 3
04:25:45 <lambdabot>  "hasKell"
04:25:52 <dons> richi_: like that/
04:26:02 <ndm> psykotic: working with a typed Core is more like dependently typed programming, its working in a typed language, where values have types which are runtime entities, and have to be proved
04:26:13 <dons> ?let hack f s n = let (a,b) = splitAt n s in a ++ case b of [] -> [] ; (x:xs) -> f x : xs
04:26:18 <lambdabot> Defined.
04:26:35 <dons> > hack id [1..10] 0
04:26:35 <hpaste>  (anonymous) pasted "iterateM laziness/non-termination" at http://hpaste.org/2412
04:26:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:26:49 <DRMacIver> Surely your arguments are the wrong way round? :)
04:26:49 <ndm> hmm, i have SPJ's slides but they are ~7Mb, zipping gets them to ~4Mb, but that won't fit on the wiki, since the size limit is too small
04:26:52 <dons> > hack (^2) [1..10] 3
04:26:53 <lambdabot>  [1,2,3,16,5,6,7,8,9,10]
04:27:35 <Philippa> hmm. Not sure I have the bandwidth available, unfortunately - given my allowance, hosting SPJ slides isn't much better than linking to myself on slashdot
04:27:41 <ndm> indeed
04:27:48 <richi_> let hack f s n = let (a,b) = splitAt n s in a ++ case b of [] -> [] ; (x:xs) -> f x : xs in hack toUpper ? this
04:27:50 <ndm> i'll try haskell.org/~neil
04:27:53 <dons> ndm , you can't upload them as images to the wiki?
04:27:54 <Philippa> who's the wiki admin these days?
04:28:00 <dons> Ashley yakely
04:28:01 <Philippa> dons: yuck!
04:28:03 <ndm> i have the bandwidth but not the quota on my uni system
04:28:08 <ndm> dons: no, too big
04:28:09 <dons> unsafeCoerce!
04:28:13 <popcount> Can anyone explain why that paste is not going to work?
04:28:45 <mauke> because ST isn't lazy like that
04:29:08 <popcount> State is lazy like that. What's the difference?
04:29:16 <dons> ST is a bit stricter :)
04:29:33 <popcount> But in ST you need to program in a C like manner.
04:29:43 <psykotic> popcount, i think you want sequence_ (take 1 $ iterate ...) or something
04:29:47 <mauke> ST has "real" side effects
04:29:50 <psykotic> err, hmm
04:29:52 <dons> you can probably get the same result with Control.Monad.State.Strict too (?)
04:30:12 * psykotic misread
04:31:19 <popcount> dons, I am not interested in getting the same undesirable result with State.
04:31:34 <psykotic> popcount, how about using MaybeT over ST and using mzero to terminate the iteration?
04:31:41 <psykotic> or something like that
04:32:06 <psykotic> or do you want to write it exactly like you're writing it?
04:32:20 <dons> popcount: my point was that by switching from State to State.Strict, you'd see the same result as with the strict ST monad.
04:32:26 <dons> which is a rather special state monad
04:33:48 <popcount> psykotic, I am not sure how mzero and iterateM would relate then.
04:34:21 <psykotic> my idea, which might be wrongheaded, is that you would use mzero inside the function you pass to iterateM when you want the recursion to terminate
04:34:57 <popcount> psykotic, but then I lots the value I am interested in
04:35:02 <popcount> psykotic, lost*
04:35:05 <psykotic> err, yeah. hmm.
04:35:10 <popcount> psykotic, mzero returns Nothing
04:35:30 <popcount> So, one would end up with contt
04:36:12 <Saizan_> throwError interestingresults in a EitherT Mytype ST
04:36:41 <ndm> http://www.haskell.org/haskellwiki/AngloHaskell/2007#Abstracts
04:36:42 <lambdabot> Title: AngloHaskell/2007 - HaskellWiki
04:36:44 <psykotic> since the iterateM accumulator is internal, iterateM would have to do that. very ghetto.
04:36:51 <ndm> thats all the slides from AngloHaskell, I'm pretty sure
04:36:56 <psykotic> not sure what else could be done though.
04:37:04 <popcount> Saizan_, that's a hack.
04:37:18 <popcount> Saizan_, and essentially equivalent to using continuations.
04:37:42 <psykotic> i think the strictness dooms you to another approach than what you're doing now.
04:37:55 <Saizan_> popcount: similar to break in imperative languages
04:38:11 <psykotic> you can't use iterateM, because it's accumulator is internal, so you'll never be able to get anything out of it if you have a strict monad
04:38:13 <popcount> Saizan_, right, and abortive continuation.
04:38:18 <popcount> Saizan_, an*
04:39:35 <psykotic> you could reimplement common lisp's LOOP :)
04:39:42 <psykotic> it has something like this, where you could accumulate things into a list and abort
04:39:50 * psykotic is kidding, before anyone burns him as a witch.
04:40:25 <psykotic> the equivalent here, though, would be a function that would pass in various escape continuations and other data to the passed function
04:40:35 <popcount> Yeah, I guess Common Lisp is clearly superior for this kind of task.
04:41:11 <dons> `accumulate things into a list and abort' sounds like unfoldr :)
04:41:28 <psykotic> that's a good point actually. is there an unfoldrM?
04:41:30 <dons> an anamorphism of some flavour, anyway
04:41:34 <psykotic> (well, it would be easy to write)
04:41:36 <mauke> @hoogle unfoldM
04:41:37 <dons> there is, people define it occasionally
04:41:37 <lambdabot> No matches found
04:42:22 <dons> you can write entire list libraries using unfoldr.
04:42:29 <dons> such a lovely function
04:42:32 <dons> ?karma unfoldr
04:42:33 <lambdabot> unfoldr has a karma of 7
04:42:37 <dons> and rightly so!
04:42:44 <popcount> @src unfoldr
04:42:45 <lambdabot> unfoldr f b  = case f b of
04:42:45 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:42:45 <lambdabot>    Nothing        -> []
04:42:53 <dons> new_b is ugly
04:42:56 <dons> b' please!
04:43:01 <mauke> newb!
04:43:04 <dons> i like 's' for state though
04:44:44 <dons>     unfold_unstream !s = case next s of
04:44:44 <dons>       Done       -> []
04:44:44 <dons>       Skip    s' -> expose s' $     unfold_unstream s'
04:44:45 <dons>       Yield x s' -> expose s' $ x : unfold_unstream s'
04:44:47 <dons> ;)
04:45:13 <psykotic> @type let unfoldrMaybe = catMaybe . unfoldr in unfoldrMaybe
04:45:15 <lambdabot> Not in scope: `catMaybe'
04:45:26 <psykotic> @type let unfoldrMaybe = catMaybes . unfoldr in unfoldrMaybe
04:45:27 <mauke> s
04:45:28 <lambdabot>     Couldn't match expected type `[Maybe a]'
04:45:28 <lambdabot>            against inferred type `b -> [a1]'
04:45:46 <mauke> :t (catMaybes .) . unfoldr
04:45:48 <lambdabot> forall a b. (b -> Maybe (Maybe a, b)) -> b -> [a]
04:45:54 <psykotic> yep
04:46:07 <psykotic> i was going to say, that's an often used variant of unfoldr
04:46:13 <psykotic> at least i find myself using it a lot
04:46:23 <psykotic> it's like having Skip in streams
04:46:31 <dons> ah, that's the `dot` op
04:46:39 <dons> ?let dot = (.) . (.)
04:46:41 <lambdabot> Defined.
04:46:47 <dons> :t catMaybes `dot` unfoldr
04:46:49 <lambdabot> Not in scope: `dot'
04:46:59 <dons> ?let foo = catMaybes `dot` unfoldr
04:46:59 <lambdabot> <local>:5:0:     Multiple declarations of `L.foo'     Declared at: <local>:1:...
04:47:11 <dons> ?let unfoldrMaybe = catMaybes `dot` unfoldr
04:47:13 <lambdabot> Defined.
04:47:24 <mauke> :t L.dot
04:47:26 <lambdabot> Couldn't find qualified module.
04:47:57 <dons> not exposed, qualifed, in ghci, which is used for type checking
04:48:19 <psykotic> i wonder if .. would be a good name for that. since it's like . but for two curried arguments.
04:48:37 <dons> we had an idea to start with . then .: then .:: or something once
04:49:15 <DRMacIver> .. doesn't seem to be a legal identifier.
04:49:26 <earthy> it's reserved syntax
04:49:45 <earthy> > take 20 [1..]
04:49:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
04:49:56 <DRMacIver> Ah, right.
04:50:41 <psykotic> yeah, forgot about that
04:50:47 <DRMacIver> ... is ok though. :)
04:51:31 <dons> another good one is (.) $ (.)
04:52:00 <dons> >  ((.)$(.)) (==) 1 (1+) 0
04:52:02 <lambdabot>  True
04:52:06 <psykotic> i think there should be a contest to invent the operator composition that is simultaneously the most aesthetically pleasing as an ascii drawing and as a haskell combinator
04:52:12 <DRMacIver> :t (.) $ (.)
04:52:12 <dons> heh
04:52:13 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
04:52:27 <dons> fairly clear, eh DRMacIver ?
04:52:28 <mauke> @. djinn type (.)$(.)
04:52:30 <lambdabot> f a b c d = a b (c d)
04:52:39 <dons> good thinking
04:52:41 <DRMacIver> dons: As mud. :)
04:52:56 <dons> its a functional language, it should have names for  these kinds of things!
04:53:30 <dons> @. pl . djinn type (.)$(.)
04:53:32 <lambdabot> f = ((.) .)
04:53:44 <nornagon> > let { wtf = 0 ; (?) = (*); (...) = (+) ; haskell = 1337 } in wtf? wacky... haskell
04:53:45 <lambdabot>   Not in scope: `wacky'
04:53:55 <nornagon> > let { wtf = 0 ; (?) = (*); (...) = (+) ; haskell = 1337 ; wacky = 0 } in wtf? wacky... haskell
04:53:56 <lambdabot>  1337
04:54:13 <nornagon> thanks, lambdabot.
04:54:14 * nornagon bows
04:54:20 <dons> haskell has support for functions, the way perl has support for regexes :)
04:54:20 * ivant starts using different types in Java to distinguish connections to different databases
04:54:30 <dons> ivant: woot!
04:54:42 <dons> type system ftw!
04:54:44 <DRMacIver> ivant: Doing type hackery in Java is the first step on the path to madness.
04:54:58 <ivant> dons, Haskell definitely changed my development style :-)
04:55:05 <dons> yeah, god forbid you'd encode program properties in the types! crazy talk ;)
04:55:16 <DRMacIver> dons: *in java* is the key part of that phrase. :)
04:55:19 <dons> :)
04:55:21 <mauke> http://mauke.ath.cx/stuff/perl/japh5.pl
04:55:48 <dons> heh
04:56:08 <LeCamarade> Like I said, Haskell will teach at least two things to the world: type-system's importance and purity's importance.
04:56:14 <DRMacIver> Haskell has definitely changed the way I write Java though.
04:56:31 <DRMacIver> Once I wandered aimlessly, just writing whatever seemed like a good idea at the time.
04:56:44 <DRMacIver> Now I wander very purposefully in order to resist the siren call of writing the damn stuff as if it were Haskell. :)
04:57:02 <osfameron> sometimes I wonder if the fact that you *can't* shotgun develop in haskell is one barrier to its adoption...
04:57:20 <ivant> DRMacIver, there is a russian proverb for this, which translates roughly as "lots of wisdom ‚Äî lots of grief"
04:57:33 <dons> ivant: oh, that's nice.
04:57:44 <DRMacIver> ivant: I like that.
04:57:48 <mauke> mo money, mo problems
04:58:09 <dons> its the inverse of ignorance is bliss?
04:58:19 <LeCamarade> :o)
04:58:35 <ivant> dons, sounds like it, but I suspect there should be two more intersections in between
04:58:43 <popcount> dons, how does unfoldrM solve this problem? I Just programmed an example with unfoldrM and it has the exact same problem.
04:59:03 <popcount> dons, even when I create a list of st actions to do, instead of executing them right away
04:59:10 <DRMacIver> ivant: The problem I find is that Java is insufficiently expressive to write as if it were Haskell. So most attempts to encode ideas from Haskell in Java result in really bad Haskell and even worse Java. :)
04:59:42 <mauke> just ignore the java type system
04:59:51 <osfameron> Java is also really painful with its operators and its braindead number classes
04:59:54 <mauke> write everything with Objects and cast as appropriate
04:59:57 <ivant> DRMacIver, they say that Scala isn't that bad after all, but you'd hardly switch an existing commercial project from java to scala
05:00:01 <osfameron> and lack of operator overloading etc.
05:00:05 <LeCamarade> Well, really ... type hackery is pattern-matching's friend. They should go together.
05:00:32 <DRMacIver> ivant: I still feel guilty about this, but I vetoed the idea of writing our current project in Scala. :(
05:00:38 <hpaste>  (anonymous) annotated "iterateM laziness/non-termination" with "(no title)" at http://hpaste.org/2412#a1
05:01:26 <popcount> dons, that's what I tried
05:01:44 <popcount> dons, the unfoldrM runs in the Maybe monad.
05:02:05 <DRMacIver> ivant: Problem is that unless you want to create an awful lot of wrappers over the existing APIs, your scala ends up looking a lot like Java and so has most of the associated problems.
05:02:23 <DRMacIver> ivant: But you've thrown away all the usual ways of coping with these problems by switching to a language without good tool support.
05:02:51 <dons> popcount: oh, i'd just write a loop, till you sort out the strictness of the monad you're in
05:03:05 <ivant> DRMacIver, I haven't yet enough time to try out Scala, but I really want to. Probably I'll write yet another DNA‚ÜíRNA decoder for a start
05:03:28 <popcount> dons, but how would unfoldrM work with ST?
05:03:31 <DRMacIver> (Morally writing those wrappers is probably the right thing to do. But although it might make you a happier, better person it will also take significantly longer and be more work. :) )
05:03:34 <xerox> err, sorry.
05:03:37 <DRMacIver> ivant: It's definitely worth a look.
05:03:40 <popcount> dons, Is Maybe a strict monad too?
05:03:40 <ivant> DRMacIver, what do you mean by tool support ‚Äî IDEs?
05:04:24 <xerox> > Just undefined >> Nothing
05:04:26 <lambdabot>  Nothing
05:05:19 <DRMacIver> ivant: Refactoring mostly, plus intelligent completion to a lesser degree. Because you're writing a huge amount of very imperative crap in order to use the existing APIs you really want the refactoring ability to support it.
05:06:11 <DRMacIver> (So, yes, IDEs)
05:06:13 <ivant> DRMacIver, refactoring ‚Äî yes. But I feel that vim-style completion is almost always enough (and sometimes even more powerful)
05:06:56 <ivant> DRMacIver, these were two separate statements :-)
05:07:20 <DRMacIver> ivant: Mm, yes, probably. I need to get more familiar with vim's completion capabilities. I can't really comment as to how they compare.
05:08:02 <DRMacIver> ivant: But IDEA's intelligent completion really can be pretty damn clever. :) It's possible Vim's is as good, but I'd be surprised if it were better.
05:08:56 <ivant> DRMacIver, it's completely different, and quite often you end up with lots of false-positives, but anyway what you're looking for is usually the closest match
05:09:39 <DRMacIver> ivant: I'm kinda skeptical. When you want to complete against existing APIs (not just stuff in your own code) that's an awful lot of context specific information for it to ignore.
05:10:13 <ivant> DRMacIver, right, there is a special plugin for that (but I don't use it)
05:10:16 <DRMacIver> ok
05:10:44 <DRMacIver> Anyway, I've done next to no Java development (beyond trivial examples) outside of an IDE, so I can't really comment on what it's like. :)
05:11:28 <njbartlett> DRMacIver: I used to do a lot of Java development in VIM. Couldn't go back to that now though
05:12:10 <njbartlett> You're absolutely right though. If you absolutely have to write Java -- or even Scala in the style of Java, because of library issues -- then you really really need decent IDE support
05:12:19 <wolverian> hm, did happs have a new release this week already?
05:12:44 <DRMacIver> I mean, it's not like I couldn't have written the project in Scala without an IDE.
05:13:04 <DRMacIver> It was that because it was so Java like as well as losing the IDE benefits I wasn't gaining much in the way of Scala benefits except a cleaner core semantics.
05:13:13 <DRMacIver> Which is *pleasant*, but not actually a productivity boost. :)
05:13:44 <DRMacIver> And at the end of the day what matters is how quickly I can get the product done and how good it is at the end of it, not my personal happiness with the development process.
05:14:57 <DRMacIver> Anyway, I need to get going. Back in an hour or so.
05:14:58 <ivant> DRMacIver, don't forget about bugfixing/support stage
05:15:10 <ivant> if it is cleaner, it is easier to support it
05:15:21 <LeCamarade> IDataGridColumsViewInterface
05:15:38 <DRMacIver> ivant: Sure. But I wasn't convinced that aggressively refactored Java code would be less clean than less aggressively refactored Scala. :)
05:15:39 <LeCamarade> That's part of a name of a class in .NET. IDEs are life in them languages.
05:16:10 <popcount> IDataGridColumsViewInterfaceControllerManager?
05:16:27 <LeCamarade> Oh, yeah. And it is case-sensitive. How insensitive.
05:16:27 <popcount> IDataGridColumsViewInterfaceControllerManagerFactory?
05:16:32 <LeCamarade> =))
05:16:47 <EvilTerran> IDataGridColumsViewInterfaceControllerManagerFactoryFactory!
05:16:49 <DRMacIver> LeCamarade: When you're using an IDE, the camel casing is actually a good thing.
05:17:12 <DRMacIver> LeCamarade: Because you can use it to guide autocompletion, and the name becomes IDGCCtrl-space :)
05:17:16 <DRMacIver> Anyway, really going.
05:17:36 <LeCamarade> DRMacIver: But who would have thought we'd create such monsters that we can't fire up editors anymore and _write programs_?
05:17:59 <LeCamarade> For me the name is IData<Tab>.
05:18:03 <popcount> oklopol, I tried tons of things, is there even a way to use unfoldrM with ST in any way?
05:18:33 <psykotic> popcount, i'm trying to cook up an example, hang on
05:18:53 <EvilTerran> anyone about who's read the Data Types A La Carte paper?
05:20:57 <EvilTerran> the gist of it being that, if, instead of having "data Foo = Bar Int | Baz Char", say, you have "class Foo; data Foo = Foo Int; instance Foo Bar; ... instance Foo Baz", it makes it simple for more data constructors to be added at a later data
05:21:00 <EvilTerran> *later date
05:21:20 <EvilTerran> (there's a bit more to it than that, involving type unions and things, but that's the important bit)
05:23:04 <EvilTerran> it's clever, but it seems to me that it'd be awfully difficult to write new functions that worked on this "a la carte type" (Foo a => a), other than by making them class methods. so this has made the addition of constructors simple and the addition of functions difficult, when it's usually vice-versa
05:23:14 <psykotic> @paste
05:23:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:23:39 <hpaste>  psykotic pasted "unfoldrM example in ST, for popcount" at http://hpaste.org/2413
05:24:41 <psykotic> popcount, how about that?
05:24:50 <psykotic> that will give you eyebleed, but it works
05:27:21 <dan_> hmm
05:27:34 <dan_> is there something wrong with the nhc source packeage?
05:27:47 <popcount> psykotic, that doesn't give me eyebleed, but it doesn't express the same idea.
05:28:03 <psykotic> popcount, you were asking for ST with unfoldrM
05:28:10 <psykotic> you can easily use this to get the effect of a length-limited iterate
05:29:23 <popcount> psykotic, why would it?
05:29:37 <popcount> psykotic, since you return Nothing, it will obviously terminate
05:30:02 <Mat^> *Main> :t parse parse_expression "" ""
05:30:02 <Mat^> parse parse_expression "" "" :: Either ParseError Expression
05:30:08 <psykotic> popcount, what is your question/problem?
05:30:15 <Mat^> can anyone tell me, where should I look for about "Either ..."
05:30:16 <Mat^> ?
05:30:25 <popcount> psykotic, the problem is that the iterateM we started with just generated an infinite list of things and then I wanted to select first X results from it.
05:30:39 <psykotic> right. so you can very easily get the effect of a fused take and iterate
05:30:49 <psykotic> you use foldrM with an counter that's hidden from the user
05:30:53 <EvilTerran> @docs Data.Either
05:30:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
05:31:01 <Mat^> EvilTerran: thanks! :>
05:31:16 <psykotic> i'm saying that you need to fuse them manually rather than write them separately. there's no way around it, because ST is strict....
05:31:17 <EvilTerran> no probs =]
05:31:46 <EvilTerran> there's really not much to Either
05:31:56 <popcount> psykotic, I already wrote such a fused solution, but that there's no way around it is rather disappointing.
05:32:16 <psykotic> popcount, you seem to have a misunderstanding about how ST works, then.
05:32:53 <psykotic> you wouldn't expect to run an infinite loop in C building up a list, and then take the first 2 items of that--the last part would never be reached
05:33:23 <popcount> psykotic, no, not in C, but in Haskell it should be possible.
05:33:24 <ndm> dons: any chance of making nobench work on windows?
05:33:30 <dan_> is there some secret to compiling nhc ?
05:33:31 <psykotic> not with ST. that's what everyone has been telling you.
05:33:36 <dan_> all of the packages i've got have missing files
05:33:53 <popcount> psykotic, yes, I know everyone has been telling me that.
05:34:28 <ndm> dan_ i've never managed it
05:35:07 <dmead_> sigh
05:35:21 <psykotic> popcount, so why are you using ST if you are so desperate for laziness?
05:35:28 <psykotic> you want to be able to have something like STRefs?
05:35:50 <popcount> psykotic, yes, STUArray
05:35:50 <dmead_> http://www.codinghorror.com/blog/archives/000818.html
05:35:52 <lambdabot> Title: Coding Horror: The "Works on My Machine" Certification Program
05:36:11 <psykotic> popcount, well, those are implemented as a c-level unboxed arrays. so no laziness, by construction. no way around it.
05:36:32 <popcount> psykotic, I only want laziness on the level of actions.
05:36:33 <dmead_> @seen dons
05:36:33 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 33m 43s ago.
05:37:12 <psykotic> popcount, in that case, it might be possible, but only if the number of actions you "take" (in this example) is determined outside of the monad
05:37:21 <richi_> does this statement make sense; findIndex(==(On || Off)) [x] == n ; where On and Off are enumerated types x is the first element of a list and n is an itneger
05:37:24 <popcount> psykotic, that is the case
05:37:36 <popcount> richi_, no
05:37:41 <richi_> why not
05:37:44 <popcount> richi_, types don't match
05:37:52 <popcount> richi_, ask ghci
05:37:57 <richi_> findIndex should be returning and int right
05:38:13 <popcount> richi_, || works on Bool
05:38:17 <popcount> richi_, two of them
05:38:26 <popcount> richi_, An "On" is not a Bool
05:38:39 <richi_> ohh ok,
05:38:46 <popcount> richi_, I didn't check for other problems
05:38:50 <popcount> richi_, just use ghci
05:39:04 <popcount> richi_, it would tell you the same and more
05:39:24 <Lamperi> ¬ß
05:39:49 <EvilTerran> richi_, findIndex (`elem` [On,Off]) would work
05:39:55 <richi_> i undersatnd now thanks, i was trying to say if either of these elements are in the list do this
05:40:15 <popcount> Lamperi, ÿ§
05:41:32 <gwern> I'm having some trouble with strings. So I've a function calling to X to get the copy-and-paste mouse selection, which returns a list of Word8, apparently. does a Word8 possibly correspond to a single character in UTF-8? (or to put it another way, do UTF-8 characters fit into a single Word8?)
05:41:45 <EvilTerran> or findIndex (liftM2 (||) (==On) (==Off))
05:42:27 <EvilTerran> gwern, any character with a codepoint <128 fits in a single word8. any other will take up several. that's kinda the point of utf-8.
05:42:46 <ddarius> Another multiparameter typeclass question answered with fundeps.
05:43:01 <EvilTerran> you can tell if there are any multi-byte characters by looking for Word8s with the high bit set.
05:43:14 <dons> ddarius: prize to the first to answer with associated types instead :)
05:43:15 <gwern> EvilTerran: hmm. I was misled by the 8s it would seem.
05:43:25 <ddarius> dons: Associated types have to work first.
05:43:42 <dons> they do, mostly
05:43:49 <dons> enough for the ndp library
05:43:49 <popcount> dons, aren't associated types less general?
05:43:59 <ddarius> In a stable release, and "mostly"...
05:44:02 <gwern> ok, so given a list of Word8s is there anything in the usual libraries to turn it into a UTF-8 string?
05:44:15 <dons> there's a translation between FDs and ATs
05:44:37 <popcount> dons, are you sure you don't mean the other way around?
05:44:39 <EvilTerran> gwern, i don't think so
05:45:12 * gwern wonders if show could handle it
05:45:18 <EvilTerran> @hackage encoding
05:45:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding
05:45:25 <dons> popcount: just trying to recall a recent conversation. we know all ATs are doable as FDs. but now with type families, I _think_ any valid ghc FD program is encodable with type families
05:45:30 <dons> popcount: but you'd have to check the papers
05:45:34 <dons> its been a while
05:45:58 <EvilTerran> gwern, i think that thar package should do what you want
05:46:33 <gwern> EvilTerran: yes, well I was really hoping for a way that would work with a default ghc installation. xmonad has enough dependencies as it is
05:46:34 <popcount> dons, I thought you didn't _know_ it, that's why I asked :)
05:47:20 <psykotic> popcount, sorry, got distracted by phone. the best i can think of ala what you want is to replicate n copies of your iterator f and then stick them all together by folding =<< over that.
05:47:51 <popcount> psykotic, ok, that sounds like a solution
05:49:51 <psykotic> @hoogle [a -> m a] -> a -> m a
05:49:52 <lambdabot> No matches, try a more general search
05:50:08 <ddarius> :t replicateM
05:50:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:50:34 <psykotic> ddarius, not that one
05:51:02 <dmead_> dons have you gotten nhc to build latley?
05:51:07 <psykotic> i guess it'll have to be foldr1 (=<<) or something like that
05:51:14 <popcount> psykotic, the replicate is redundant
05:51:24 <popcount> psykotic, otherwise, I think this is going to work.
05:51:35 <gwern> @hoogle Word8 -> Char
05:51:36 <lambdabot> No matches, try a more general search
05:51:38 <psykotic> popcount, as long as you're happy :)
05:53:48 <psykotic> popcount, actually what i described won't accumulate intermediate results, but that should be easily doable.
05:54:04 <popcount> psykotic, yes, I noticed already
05:54:19 <popcount> psykotic, I abandoned this approach, now.
05:54:37 <popcount> psykotic, a loop is easier, as dons already mentioned
05:55:28 <popcount> Still, one should be able to write the iterateM program.
05:55:39 <popcount> This is just premature optimization.
05:59:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2414
06:07:58 <popcount> Are operations on Int faster than on Double?
06:08:52 <Lemmih> popcount: I would think so, yes.
06:09:43 <dons> popcount: they compile to hardware ints and doubles, and use different hardware :)
06:10:27 <dons> > sum [1..10^7] :: Int
06:10:28 <lambdabot>  -2004260032
06:10:29 <dons> > sum [1..10^7] :: Double
06:10:33 <lambdabot> Terminated
06:10:34 <dons> :)
06:10:47 <dons> > sum [1..10^7] :: Integer
06:10:49 <popcount> dons, ok
06:10:50 <lambdabot> Terminated
06:10:57 <dons> > sum [1..10^6] :: Integer
06:10:59 <lambdabot>  500000500000
06:11:21 <dons> > sum [1..10^6] :: Double
06:11:23 <lambdabot>  5.000005e11
06:11:48 <dons> > sum [1..10^6] :: Fixed E12
06:11:52 <lambdabot> Terminated
06:11:56 <dons> > sum [1..10^5] :: Fixed E12
06:12:00 <lambdabot> Terminated
06:12:04 <dons> > sum [1..10^4] :: Fixed E12
06:12:08 <lambdabot> Terminated
06:12:13 <dons> > sum [1..10] :: Fixed E12
06:12:16 <lambdabot> Terminated
06:12:23 <dons> > 1 :: Fixed E12
06:12:24 <lambdabot>  1.000000000000
06:12:28 <dons> interesting
06:12:45 <SamB_XP> > sum [1..5] :: Fixed E12
06:12:49 <lambdabot> Terminated
06:12:55 <dons> something funny going on I think
06:12:55 <SamB_XP> > sum [1..3] :: Fixed E12
06:13:01 <lambdabot> Terminated
06:13:02 <ddarius> Jack enum instance?
06:13:05 <SamB_XP> > sum [1..2] :: Fixed E12
06:13:10 <dons> ddarius: oh hmm.
06:13:11 <ddarius> s/Jack/Jacked
06:13:12 <lambdabot> Terminated
06:13:17 <dons> > sum [1,2] :: Fixed E12
06:13:18 <SamB_XP> > [1..] :: Fixed E12
06:13:19 <roconnor> since when does lambdabot know about Fixed?
06:13:19 <lambdabot>  3.000000000000
06:13:19 <lambdabot>  Couldn't match expected type `Fixed E12'
06:13:22 <dons> ah ha
06:13:29 <SamB_XP> > [1..] :: [Fixed E12]
06:13:30 <lambdabot>  [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004,...
06:13:31 <dons> dodgy enumFromTo ?
06:13:36 <SamB_XP> !!!!
06:13:37 <dons> oh :)
06:13:48 <ddarius> Hey, that is the benefit of using fixed precision.
06:13:59 <dons> > [1..] :: [Double]
06:14:01 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
06:14:14 <dons> > [1..] :: [Fixed E6]
06:14:15 <lambdabot>  [1.000000,1.000001,1.000002,1.000003,1.000004,1.000005,1.000006,1.000007,1.0...
06:14:21 <ddarius> There is no "minimum" step amount for a Double.
06:14:22 <dons> > [1..] :: [Rational]
06:14:23 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1,17%1...
06:14:29 <ddarius> (At least not usefully.)
06:14:43 <dons> > [1..] :: [Complex Integer]
06:14:44 <lambdabot>   add an instance declaration for (RealFloat Integer)
06:14:44 <lambdabot>     In the expression: ...
06:14:50 <ddarius> But yes, the behaviour is unintuitive.
06:15:05 <dons> enumFromTo instances are famously dodgy though ;)
06:15:43 <roconnor> re: [1..] :: [Rational] WTF?
06:15:55 <dons> > sum [1..2] :: [Enum E6]
06:15:56 <lambdabot>      Class `Enum' used as a type
06:15:56 <lambdabot>     In the type `Enum E6'
06:15:56 <lambdabot>     In the type `[...
06:16:03 <popcount> What is Fixed?
06:16:03 <ddarius> roconnor: It's less wtf than Enum Double
06:16:04 <dons> > sum [1..2] :: [Fixed E6]
06:16:05 <lambdabot>   add an instance declaration for (Enum [Fixed E6])
06:16:10 * SamB_XP whispers "map unsafeCoerce# [(0 :: Int64)..] :: [Double]"
06:16:12 <dons> > sum [1..2] :: Fixed E6 -- tired
06:16:14 <lambdabot>  1500001.500000
06:16:25 <xerox> Enum Rational should use that tree that lists them all in simplified form
06:16:27 <roconnor> ddarius: enum double makes more sense than enum rational, although not by alot.
06:16:57 <ddarius> SamB_XP: Later elements would be smaller then.
06:17:15 <SamB_XP> ddarius: eh?
06:17:16 <ddarius> Perhaps Enum should be renamed or another class used.
06:17:24 <SamB_XP> I don't know what you mean
06:17:29 * EvilTerran was under the impression that enum instances were supposed to be a bijection with (an initial subset of) the integers
06:17:37 <ddarius> SamB_XP: The sign bit will eventually get set.
06:17:43 <SamB_XP> ddarius: no
06:17:48 <SamB_XP> I cleverly used Int64
06:17:51 <SamB_XP> not Word64
06:18:00 <xerox> the stern-becot tree
06:18:16 * ddarius has to go to work.
06:18:29 <dmead_> dons, any advice on getting nhc to work?
06:18:39 <dmead_> the source package seems to be a mess
06:19:06 <dons> dmead_: hmm. i just built it a few months ago without trouble
06:19:16 <dons> but nhc and yhc got merged since then, iirc
06:19:20 <dons> better talk to malcolm
06:19:22 <dmead_> did you have to do anything special?
06:19:23 <EvilTerran> > succ (! :: Fixed E6)
06:19:23 <lambdabot>  Parse error
06:19:24 <dmead_> ah
06:19:26 <EvilTerran> > succ (1 :: Fixed E6)
06:19:28 <lambdabot>  1.000001
06:19:38 <EvilTerran> that's _weird_.
06:19:47 <doserj> i would call it a bug
06:20:03 <dons> > [1..] :: [Complex  (Fixed E12)]
06:20:03 <lambdabot>        add an instance declaration for (RealFloat (Fixed E12))
06:20:03 <lambdabot>     In the exp...
06:20:09 <dons> > [1..] :: [Complex Double]
06:20:10 <doserj> [a..b] should mean the "same" numbers, no matter what type you use
06:20:10 <lambdabot>        add an instance declaration for (Enum (Complex Double))
06:20:10 <lambdabot>     In the exp...
06:20:23 <dons> oh, i can't enumerate the complex doubles, boo
06:20:36 <EvilTerran> doserj, i agree. as i said (or meant to say), bijection with the naturals, etc.
06:21:11 <dons> ?users
06:21:11 <lambdabot> Maximum users seen in #haskell: 385, currently: 373 (96.9%), active: 17 (4.6%)
06:21:24 <EvilTerran> huh? the max has gone down?
06:21:32 <dons> yeah, lambdabot bug
06:21:36 <dons> max is 419
06:21:56 <BobFunk> what's the preferred package for working with xml in haskell - haxml or Haskell XML Toolbox?
06:22:05 <dons> haxml or hxt :)
06:22:13 <dons> haxml is more traditional
06:22:25 <dons> but i'm not sure the winner is clear yet.
06:23:17 <SamB_XP> HXT still has bloated interfaces doesn't it?
06:23:28 <njbartlett> I like HXT
06:23:51 <njbartlett> Then again, I also like Bovril.
06:24:51 <EvilTerran> do you like marmite?
06:25:00 <dons> urgh. vegemite forever!
06:26:25 <SamB_XP> I think I'd like it if I didn't have to wade through so much crap to try and figure out how to use it
06:26:38 <SamB_XP> the Arrow idea seems good
06:27:17 <Saizan_> yeah, but there are too much obscure combinators maybe
06:27:36 <Saizan_> also you're forced to use it as a monad sometimes
06:28:55 <Saizan_> s/much/many/
06:29:32 <BobFunk> I'll go for haxml for now :)
06:30:06 <ski> 'Fixed E6' ?
06:30:11 <sorear> .
06:30:35 <psykotic> dons: how will you live without vegemite in the us? is it even available there?
06:30:49 <popcount> ...././.-../.-../--- -/...././.-./.
06:31:02 <Japsu> @help morse
06:31:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:31:06 <Japsu> bah
06:31:57 <ivant> @all-dicts vegemite
06:31:58 <lambdabot> No match for "vegemite".
06:32:49 <psykotic> ivant: a disgusting australian speciality--some kind of yeast thingy.
06:33:31 <xerox> ski: yeah what's that? (:
06:33:54 <ski> 'E6' and 'E12' meaning what ? 6 or 12 decimals ?
06:34:28 <ski> (and how many whole part digits, then ?)
06:34:53 <sorear> psykotic: a couple years ago, there was a .au native teaching at my school, I don't clearly remember the details but have been told she had no shortage of the stuff :)
06:35:53 <popcount> Nobody translated it yet? Morse exists for over a century!
06:36:42 <LeCamarade> Horror: I just named a variable qwe123.
06:37:13 * LeCamarade is ashamed of having literally eternalised the Troll.
06:37:36 <popcount> LeCamarade, you spelt my name wrong.
06:37:45 <popcount> Oops
06:37:55 <ski> how well does morse correspond to huffman encoding for, say, some standard letter frequencies for the english alphabet (well, plus some symbols, i guess) ?
06:38:07 <LeCamarade> popcount: You're qwe123?
06:38:30 <LeCamarade> GETTIM!!! NO LET HIM ESHKAPE!
06:38:40 <popcount> LeCamarade, no, I was just trolling.
06:38:53 <ski> popcount : so you admit it !
06:39:01 <popcount> LeCamarade, pretty convincing, wasn't it?
06:39:19 <LeCamarade> Phew. I already sent my assassins for you. Find a place to hide.
06:39:43 <LeCamarade> Too late to change stuff ...
06:39:55 <ski> just backtrack
06:40:00 <popcount> LeCamarade, unless you are the government, that won't work.
06:40:32 <b_jonas> evalj:: demorse =: ([:;[:([:<' ',~'._'{~[:}.#:)"0'? etaoinmsurwdkghvf?l?pjbxcyzq'&i.)
06:40:55 <b_jonas> evalj:: demorse =: ([:;[:([:<' ',~'._'{~[:}.#:)"0'? etaoinmsurwdkghvf?l?pjbxcyzq'&i.)
06:40:56 <evalj> b_jonas: |ok
06:41:06 <b_jonas> evalj:: demorse 'morse is easy'
06:41:07 <evalj> b_jonas: ... ._ .__ .._ .  _. .._  . .. .._ _.__
06:41:15 <b_jonas> hey, that's wrong
06:41:38 <b_jonas> I misspelled the alphabet somewhere... "is" should be .. ...
06:41:56 <b_jonas> evalj:: demorse =: ([:;[:([:<' ',~'._'{~[:}.#:)"0'? etianmsurwdkgohvf?l?pjbxcyzq'&i.)
06:41:56 <evalj> b_jonas: |ok
06:42:00 <b_jonas> evalj:: demorse 'morse is easy'
06:42:00 <evalj> b_jonas: __ ___ ._. ... .  .. ...  . ._ ... _.__
06:42:07 <b_jonas> looks better
06:42:20 <b_jonas> yep, definitely
06:43:48 * sorear reads a spj's AH2007 slides on assoc types
06:51:29 <b_jonas> I'll read http://home.pipeline.com/~hbaker1/NoMotionGC.html now
06:51:30 <lambdabot> Title: ACM Sigplan Notices 27,3 (March 1992), 66-70.
06:54:24 <b_jonas> hmm, perhaps I should read http://home.pipeline.com/~hbaker1/RealTimeGC.html first?
06:54:26 <lambdabot> Title: Comm. of the ACM 21, 4 (April 1978), 280-294.
07:17:38 <JaffaCake> http://haskell.org
07:17:47 <glen_quagmire> is not down
07:17:57 <JaffaCake> hmmm
07:18:50 <glen_quagmire> hrm maybe it's down. not responding. it did 5 minsa go
07:20:01 <byorgey> seems down to me atm
07:20:54 <JaffaCake> I'm investigating
07:21:08 <JaffaCake>  10:10:57  up 252 days, 17:59,  1 user,  load average: 137.02, 131.39, 128.17
07:21:14 <JaffaCake> did we get /.ed?
07:21:37 <glen_quagmire> maybe reddit
07:22:01 <glen_quagmire> someone questioned about combinators
07:22:12 <glen_quagmire> and people linked to haskell page
07:22:19 <JaffaCake> which page?
07:22:29 <glen_quagmire> http://haskell.org/haskellwiki/Super_combinator
07:23:01 <osfameron> super combinator!
07:24:28 <glen_quagmire> http://programming.reddit.com/info/2i9d6/comments  this was reddit post
07:24:43 <roconnor> > sqrt 720.815
07:25:07 <glen_quagmire> lambdabot: > sqrt 720.815
07:25:36 <glen_quagmire> sqrt(720.81500) = 26.8479981
07:30:24 <osfameron> oh "combinator" is a "less scary" word for Higher Order Function?  I was always quite scared by Combinator
07:31:06 <SamB> it sounds like a funny word for somethign that combines things to me
07:31:09 <SamB> not scary really
07:31:14 <mrd> combinators have no free variables
07:31:33 <osfameron> SamB: yes, but understanding what that *means* is the problem :-)
07:31:40 <EvilTerran> haskell.org isn't loading for me...
07:31:42 <osfameron> what are free variables ?
07:32:05 <mrd> ones you don't have to pay for
07:32:06 <glen_quagmire> free variables are those not bound to parameters
07:32:30 <mrd> free variables are those which appear in a term, but without any definition or binding
07:32:35 <glen_quagmire> haskell doesn't have variables
07:32:59 <mrd> in the term (\ x. y) the variable 'y' appears as a free variable
07:33:15 <glen_quagmire> haskell uses term 'variable' too?
07:33:21 <osfameron> so where does it come from ?
07:33:39 <glen_quagmire> y depends on the context
07:34:09 <scook0> an expression containing free variables is "incomplete"
07:34:16 <glen_quagmire> > \(x -> y)(1) where y = 2
07:34:23 <osfameron> ok
07:34:33 <osfameron> and a combinator doesn't have any of those
07:35:15 <osfameron> so basically it's just a function rather than a fragment of a function within a larger expression?
07:37:56 <glen_quagmire> haskell.org is slow but loads
07:38:50 <EvilTerran> ah, yes, it did load eventually
07:41:22 <glen_quagmire> i think the server is doing virus scan
07:47:06 <SamB> @spell succesful
07:47:52 <fla> :?
07:47:56 <fla> :?)
07:48:08 <osfameron> though actually, I'd make that just "it's a function"
07:48:42 <osfameron> because I don't think of (\x -> y) where y isn't defined as a whole function.  The function includes the lexical scope it closes over
07:50:09 <ski> it is "a" variable function
07:53:39 <msouth> samb: successful
07:55:57 <gle1> What's wrong with haskell.org today?
07:58:01 <fla> gle1: what are you talknig about?
07:58:18 <osfameron> the reddit effect, apparently
07:59:49 <Igloo> Which page?
08:07:50 <gle1> fla, Igloo: It takes forever to load. Maybe the problem is on my side though
08:08:31 <gle1> Igloo: any page: main page, hoogle search results
08:08:53 <gwern> > 2 ^ 8 -- 8 bits can have 256 states, iirc...
08:09:06 <Igloo> gle1: IM, which page is being hammered?
08:09:45 <gle1> Igloo: hammered?
08:10:51 <arcatan> hamstered
08:11:03 <dino-> hamstrung
08:11:57 <glen_quagmire> what is point free style?
08:12:24 <byorgey> glen_quagmire: defining functions without explicit reference to their parameters.
08:12:30 <glen_quagmire> func x l = map (\y -> y*x) l;     =>     func x = map (*x)  is this point free?
08:12:50 <glen_quagmire> like, should I eliminate all parametesr or part of parameters?
08:13:01 <gle1> @pl \x -> map (*x)
08:13:10 <pjd> glen_quagmire: it's point-free-er
08:13:14 <byorgey> glen_quagmire: to be strictly point-free you should eliminate all the parameters
08:13:25 <byorgey> glen_quagmire: but what pjd said is true too =)
08:13:27 <ski> map . (*)
08:13:29 <glen_quagmire> ah i see. I was confused doing this exercise
08:13:42 <pjd> ski: map . flip (*)
08:13:54 <ski> pjd : yes, strictly speaking
08:14:07 <pjd> (although (*) should probably be associative)
08:14:11 <gwern> > 2 ^ 8 -- 8 bits can have 256 states, iirc...
08:14:24 <ski> (pjd : itym commutative)
08:14:31 <pjd> err, right
08:14:41 <byorgey> I don't see any reason for (*) to be commutative
08:14:53 <byorgey> although in all built-in cases it is
08:14:54 <glen_quagmire> if you have (map (*)) , how wolud you call it?     type of map (*) is [Integer] -> [(Integer -> Integer)]
08:15:00 <sorear> gwern: won't work, JaffaCake killed it (not deliberately)
08:15:13 <ski> instance Num a => Num (Quaternion a)  -- eh ?
08:15:16 <glen_quagmire> func = map (*);    func 2 [1,2,3] won't work
08:15:17 <gwern> oh. I was kind of wonering why it was taking so long
08:15:29 <JaffaCake> sorear: what did I kill?
08:15:38 <sorear> 07:16 < JaffaCake> http://haskell.org
08:15:39 <arcatan> murderer!!
08:15:40 <byorgey> glen_quagmire: I think you want func = map . (*)
08:15:45 <JaffaCake> ah
08:15:48 <glen_quagmire> hoa flip works pjd
08:15:54 <byorgey> glen_quagmire: or map . flip (*)
08:16:06 <sorear> referencing a nonresponsive URL is an extremely good way to crash lambdabot.  Not that that isn't a bug.
08:16:13 <byorgey> glen_quagmire: keep in mind map (*) and map . (*) are very different =)
08:16:36 <glen_quagmire> oh
08:16:53 <byorgey> map (*) says, apply the (*) function to each element of a list
08:17:04 <byorgey> map . (*) says, first apply (*) to something, then apply map to the result of that
08:17:13 <gle1> sorear: So the problem with haskell.org is not on my side?
08:17:39 <glen_quagmire> byorgey: i can't understand why (map . (*)) 2 [1,2,3] works
08:17:39 <sorear> no
08:17:49 <sorear> someone reditt-dotted us!
08:17:55 <pjd> map (*) will give you a list of multipliers, map . (*) will give you a multiplier of lists
08:18:07 <dino-> (f . g) x == f ( g x )
08:18:33 <sjanssen> sorear: do we know why that happens?
08:18:54 <sjanssen> doesn't the title fetching happen asynchronously?
08:19:00 <glen_quagmire> so, (map . (*)) 2 [1,2,3] == map ((*) 2) [1,2,3] ?
08:19:06 <byorgey> glen_quagmire: right!
08:19:34 <glen_quagmire> byorgey: but isn't (*) taking 2 parameters? why does it not take [1,2,3] as 2nd parameter and spit out errors?
08:19:53 <byorgey> glen_quagmire: because function application is left-associative
08:19:56 <glen_quagmire> hrm type of (*) is Num a => a -> a-> a
08:20:09 <gle1> glen_quagmire: it's currying in action
08:20:34 <byorgey> (*) only applies to one parameter and returns another function, which is then the parameter to map
08:20:41 <pjd> glen_quagmire: because of the parens
08:20:52 <ski> sorear : 'redotted' mayhaps ?
08:20:53 <sjanssen> glen_quagmire: (map . (*)) 2 [1,2,3] == ((map . (*)) 2) [1,2,3]
08:21:10 <sjanssen> @src (.)
08:21:13 <pjd> you would otherwise have to write ((*) 2 [1,2,3])
08:21:37 <glen_quagmire> oh i was thinking left associative right associative
08:21:45 <dino-> pjd: That was well-said, list of multipliers..
08:21:49 <glen_quagmire> i mean, confused by left and right
08:22:15 <sjanssen> == (map ((*) 2)) [1,2,3]
08:22:32 <sjanssen> == map (2*) [1,2,3]
08:24:06 <glen_quagmire> oh type of (map . (*)) :: (Num a) => a -> [a] -> [a]
08:26:17 <olsner> anyone here have experience with xkernel (network protocol laboration/research kernel/simulator)?
08:26:40 <olsner> I'm thinking I might want to reimplement it all in a very short haskell program
08:30:18 <glen_quagmire> can all functions be point free-er ?
08:30:38 <gwern> glen_quagmire: normal ones sure but they're hideous! hideous!
08:31:00 <pjd> i don't think you can make point free functions any more point free
08:31:35 <hkBst> pjd: don't use any i's or j's ;)
08:31:43 <glen_quagmire> man this is a good exercise. converting functions to point free (parameterless)
08:32:02 <gle1> haskell.org is back, yay!
08:32:10 <gwern> glen_quagmire: pity lambdabot isn't up or you could enjoy the wonders of @pl
08:32:13 <pjd> hkBst: yay, ƒ±
08:32:28 <glen_quagmire> what is @pl?
08:32:41 <glen_quagmire> perl ?
08:32:45 <hkBst> pjd: look at my eyes  )
08:32:49 <Lemmih> glen_quagmire: Some think it's a pointless exercise.
08:32:55 <Vulpyne> It makes an expression pointfree-ish.
08:32:55 <dino-> glen_quagmire: pointless command for lambdabot.
08:32:55 <gwern> a lamdabot bot program sort of. it's pointless
08:33:03 <pjd> glen_quagmire: perl is probably not too far off, in some cases
08:33:10 <dino-> It's a derogatory term for pointfree, as it can lead to crazy ass obfuscated code.
08:34:15 <glen_quagmire> ah i see
08:34:17 <dino-> bot is down, eh?
08:34:35 <glen_quagmire> yes.
08:36:34 <Nucleo> @pl \x y -> compare y x
08:37:05 <gwern> > chr 1024
08:37:23 <Nucleo> doh
08:37:34 <ivant> @bot
08:37:37 <Nucleo> Time to try compiling GoA again.
08:37:40 <gwern> >.< lambdabot is still down isn't it
08:39:04 <gwern> ok, so I don't really understand something. my function was retuning Word8s which map onto ASCII fine using 'chr', right? but I want all the UTF stuff my system can show so I changed it to return Word16 which should be enough for all the weird UTF characters, but chr seems to just return '/2024' and what not for anything upwards of 256
08:39:11 <olsner> glen_quagmire: you can make any program completely point-free.. the end result is something like unlambda code (i.e. a fixed number of predefined functions applied to each other in various combinations)
08:39:47 <sorear> dcoutts *might* be able to fix her, if there's enough demand
08:40:07 <dcoutts> fix who?
08:40:30 <gwern> (lambdabot? perhaps she is tempestouous wench)
08:41:01 <glen_quagmire> olsner: since lambdabot does pointfree refactoring, i think it's a algorithimic procedure to convert any function point free
08:41:17 <glen_quagmire> if I find that algorithm, these exercises will be a breeze
08:42:39 <olsner> yes, converting arbitrary lambda expressions into combinations of S, K, I is a pretty simple algorithm (look at e.g. Lazy K for a scheme program that does it)
08:42:40 <sorear> it's Sch√∂rnfinkel's representation theorem *finds true name and link*
08:43:25 <dcoutts> gwern: sorry, I have no admin power over lambdabot
08:53:30 <sorear> dcoutts: it wouldn't help, the bot is so wedged that your @admin status is irrelevant
08:53:53 <sorear> dcoutts: I was referring to the fact that you are at UNSW
08:54:03 <dcoutts> sorear: I'm not. :-)
08:54:09 <dcoutts> sorear: that was only for 6 weeks
08:56:16 <glen_quagmire> what is UNSW ?
08:56:43 <dino-> University of New South Wales
08:56:45 <glen_quagmire> university of south wales?
08:56:49 <arcatan> Universal South Wales
08:57:19 <glen_quagmire> is that school the only school that teaches haskell?
08:57:47 <Igloo> No
08:57:48 <Botje_> not really
08:57:55 <Botje_> all the uni's in belgium teach it too.
08:58:09 <LeCamarade> Liar. UNSW means Haskell Place.
08:58:12 <Botje_> :)
08:58:13 <glen_quagmire> oh. Frag 3d fps was written by unsw
08:58:16 <nealar> the only school that teaches haskell to wales
08:58:25 <ivant> is SW a nice place to live?
08:58:26 <nealar> whales
08:58:33 <ivant> NSW I mean
08:58:44 <glen_quagmire> it's austrailia. it's tropical
08:58:55 <LeCamarade> glen_quagmire: Not all ...
08:59:00 <ivant> I know climate differs a lot there, from place to place
08:59:15 <ivant> alar, where is your ICFP contest report?!
08:59:23 <glen_quagmire> i heard austrailia is the only place where kangaroos live
08:59:54 <Igloo> I heard kangaroos are the only animals known to use Haskell
09:00:14 <ivant> do they bear children who talk Haskell?
09:02:54 <desegnis> you had to isolate them from their parents to have them talk Haskell. Kangaroo civilization obfuscates too much
09:03:25 <desegnis> Camel culture is worse, though
09:03:43 <glen_quagmire> is it possible to make a gui program that captures keyboard inputs and redirects those inputs to other gui program?
09:04:35 <sorear> No, the problem is underspecified.
09:06:44 <glen_quagmire> i'm thinking of a vim wrapper with haskell scriptablt engine.
09:07:15 <glen_quagmire> you can script key strokes in haskell and send it to vim
09:07:26 <jjore-w> Hey, so I'm reading 'Haskell School of Expression' and I'm having a hard time with the eta contractions. It sure looks like using those is a kind of obfuscation.
09:08:00 <jjore-w> "Here, I'll just not mention the other parameters to my function - they're implied."
09:08:03 <lament> glen_quagmire: it should certainly be possible with vim, since some clever folks embedded it into MS Visual Studio.
09:08:05 <glen_quagmire> jjore-w: (*) takes 2 parameters.   (*x) takes 1
09:08:23 * glen_quagmire googles
09:08:37 <jjore-w> glen_quagmire: yes, it's pretty obvious when your function is something like *.
09:08:48 <lament> jjore-w: are you talking about currying?
09:08:54 <conal> jore-w: eta contractions go along with thinking of functions as first class values.  as you get more comfortable with functions as values, i bet you'll like the eta-contracted form.
09:09:07 <jjore-w> It's less obvious when your function isn't as common.
09:09:21 <lament> jjore-w: all haskell functions take one argument.
09:09:43 <lament> jjore-w: and possibly return another function, that will take another argument.
09:09:59 <osfameron> I think they're lovely for arithmetic operators, but when you start having flip and . and $ with no argument then it mainly hurts
09:10:22 <jjore-w> lament: ok, fine, "all functions take one argument." except that A -> B -> C sure doesn't appear to me when programming like two, 1-arity functions.
09:10:46 <lament> jjore-w: but it's perfectly possibly to think of it this way
09:10:52 <lament> jjore-w: it's actually A -> (B -> C)
09:11:02 <osfameron> A TO THE B TO THE C!
09:11:04 <lament> take A, return (B -> C)
09:11:05 <sorear> ssskqooqojss
09:11:17 <lament> what sorear said
09:11:29 <sorear> I hate XOFF
09:11:33 <jjore-w> I can appreciate that everything curries and eta-contraction lets me omit redundant things but darn it! I'm just complaining (and this is purely a complaint) that it makes things obfuscated. To me.
09:11:41 <sorear> Espectally so when my control key sticks
09:12:08 <lament> jjore-w: yeah, you can certainly go overboard with it :)
09:12:12 <conal> jjore-w: yep.  more mysterious at the beginning.
09:12:21 * sorear sticks stty stop undef in his .bashrc
09:12:24 <glen_quagmire> jjore-w: yes it does. but sometimes it results in a cleaner code
09:13:01 <jjore-w> Hey, so are numbers and letters in Haskell also functions?
09:13:26 <sorear> no
09:13:26 <conal> jjore-w: no
09:13:28 <lament> jjore-w: no. they don't take an argument.
09:13:42 <glen_quagmire> :t (\ -> 1)
09:13:58 <Cale> Well, numbers sort of are ;)
09:14:11 <lament> > 1 2
09:14:12 <sorear> glen_quagmire: it's broken
09:14:18 <sorear> lament: it's not working
09:14:23 <Cale> (In that the implementation of polymorphism turns them into functions under the covers
09:14:25 <Cale> )
09:14:33 <osfameron> you can represent numbers as wrapped lambdas can't you?
09:14:42 <lament> > 1 2
09:14:44 <Cale> oh
09:14:44 <mbot>   add an instance declaration for (Num (t -> a))
09:14:44 <mbot>     In the expression: 1 2
09:14:44 <mbot>  ...
09:14:53 <psykotic> cale: i guess it would be more correct to say that numerals are, i guess.
09:14:53 <lambdabot2>   add an instance declaration for (Num (t -> a))
09:14:53 <lambdabot2>     In the expression: 1 2
09:14:53 <lambdabot2>  ...
09:15:01 <conal> oh -- polymorphic numbers are rep'd as functions.
09:15:03 <lament> STEREO!!!!
09:15:07 <Cale> heh
09:15:18 <jjore-w> so do numbers get represented as little opaque bits of native CPU numberness or as church numbers?
09:15:21 <Cale> mbot: @part #haskell
09:15:24 <sorear> jjore-w: former
09:15:36 <liyang> @hoogle a -> (a, a)
09:15:37 <lambdabot2> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
09:15:37 <lambdabot2> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
09:15:41 <lament> jjore-w: people do use haskell to write actual programs, so church numerals are out of the question :)
09:16:05 <Cale> jjore-w: the numeral 5 in your source code gets turned into fromIntegral <the real integer 5>
09:16:34 <glen_quagmire> jjore-w: do you think SOE is a good book?
09:16:35 <liyang> @hoogle a -> (a -> a -> b) -> b
09:16:36 <lambdabot2> Prelude.flip :: (a -> b -> c) -> b -> a -> c
09:16:38 <jjore-w> glen_quagmire: no.
09:16:39 <Cale> er fromInteger, rather
09:16:44 <Cale> So...
09:16:46 <jjore-w> But it's the one I've got right now.
09:16:48 <Cale> >  5 :: Float
09:16:49 <lambdabot2>  5.0
09:16:52 <Cale> >  5 :: Integer
09:16:53 <lambdabot2>  5
09:16:58 <Cale> >  5 :: Rational
09:16:59 <lambdabot2>  5%1
09:17:17 <Cale> Numerals can be turned into lots of different types depending on context.
09:17:42 <desegnis> jjore-w, you will at some point realize that SOE is indeed a good book ;)
09:17:44 <liyang> @hoogle pair
09:17:44 <lambdabot2> Control.Parallel.Strategies.parPair :: Strategy a -> Strategy b -> Strategy (a, b)
09:17:44 <lambdabot2> Control.Parallel.Strategies.seqPair :: Strategy a -> Strategy b -> Strategy (a, b)
09:17:44 <lambdabot2> System.Mem.Weak.mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))
09:17:56 <Cale> The way that this happens (in GHC, at least) is that a typeclass dictionary for Num contains a method for turning plain Integers into whatever numeric type we want.
09:17:58 <osfameron> jjore-w,. glen_quagmire:  I'm quite enjoying SOE, though I haven't had enough time to work throuhg it recently
09:18:38 <jjore-w> desegnis: no, SOE will never be a good book. What I've noticed is that the author likes to omit small but important steps in the descriptions of the transforms he's doing.
09:19:03 <osfameron> he also says "Now go away and implement fix.  It's a 'bit tricky'" :-)
09:19:07 <Cale> That dictionary is passed around as a parameter (in some intermediate form of the code) -- so in many cases 5 ends up having a Num dictionary as a parameter.
09:19:30 <jjore-w> That's my only real complaint about it btw. It makes it less good as something to learn from without having already known Haskell.
09:19:37 <Cale> osfameron: That's a more fair question in Haskell than it is in Scheme ;)
09:19:56 <osfameron> Cale: well, maybe comparatively.  It's still batshit insane though.
09:20:10 <Cale> heh
09:20:43 <Cale> I don't know, I haven't read the book, but I can imagine setting up the problem in such a way that people would get it.
09:20:58 <desegnis> jjore-w: I did not miss those when working through it. I do think that it is a little disordered, though (‚Äúwhere was that part  that I need for this exercise again...‚Äù)
09:21:38 <glen_quagmire> @pl map . (*)
09:21:38 <lambdabot2> map . (*)
09:21:51 <Cale> jjore-w: My comment about numbers being functions was somewhat facetious though. Really, the way that you tell something is a function in Haskell is to look at its type.
09:21:59 <glen_quagmire> @pl \f g l -> filter f (map g l)
09:21:59 <lambdabot2> (. map) . (.) . filter
09:22:06 <osfameron> like the exercise "is a shape convex" which requires a function "is point leftof a line" which is defined several chapters later
09:22:14 <Cale> If its type has '->' in it at the top level, then it is a function.
09:23:01 <glen_quagmire> :t (->)
09:23:03 <lambdabot2> parse error on input `->'
09:23:19 <Cale> (->) is a type constructor
09:23:33 <sorear> but is forall a. a  a function?
09:23:47 <Cale> sorear: no
09:23:50 <glen_quagmire> :t (. (.) .)
09:23:52 <lambdabot2> parse error on input `)'
09:23:59 <Cale> sorear: ;)
09:24:36 <desegnis> Cale, but it might be
09:24:40 <Cale> Well, of course, something of that type can be treated as a function.
09:24:53 <Cale> But only the undefined function, really :)
09:25:04 <lament> heh heh
09:25:27 <desegnis> Of course, (x :: forall a. a) is undefined anyway
09:25:49 <sorear> (x :: *) -> x   <- with the right type theory...
09:26:05 <glen_quagmire> @pl ((.) .) (*) 1 (+1) 2
09:26:05 <lambdabot2> 3
09:26:20 <Cale> Is (return 5) a function?
09:26:33 <lament> blah. Control.Concurrent says to read the paper "Concurrent Haskell". But Concurrent Haskell has a completely different API.
09:26:35 <Cale> Usually not, but again, it could be, due to polymorphism
09:26:47 <Cale> > (return 5) 7
09:26:49 <lambdabot2>  5
09:26:58 <desegnis> Control.Monad.Instances again :)
09:27:07 <lament> :t (return 5)
09:27:09 <lambdabot2> forall t (m :: * -> *). (Num t, Monad m) => m t
09:27:10 <Cale> I really want that instance to be in the Prelude.
09:28:09 <lament> :t (return 5) :: a -> b
09:28:11 <lambdabot2>     No instance for (Num b)
09:28:11 <lambdabot2>       arising from the literal `5' at <interactive>:1:8
09:28:18 <lament> okay i dunno :)
09:28:53 <glen_quagmire> what is Num (a->b) => ... ?
09:28:55 <Cale> :t (return 5) :: (Num a) => b -> a
09:28:57 <lambdabot2> (Num a) => b -> a :: forall b a. (Num a) => b -> a
09:28:57 <desegnis> :t return 5 :: Num b => a -> b
09:28:59 * shapr yawns
09:28:59 <lambdabot2> Num b => a -> b :: forall a b. (Num b) => a -> b
09:29:13 <sorear> glen_quagmire: Bogosity related to lambdabot's use of -fglasgow-exts
09:29:18 <glen_quagmire> how would you call (. 1)  ?
09:29:25 <glen_quagmire> :t (. 1)
09:29:27 <lambdabot2> forall b c a. (Num (a -> b)) => (b -> c) -> a -> c
09:30:03 <Cale> You need an instance which you don't have in order to make that work.
09:30:16 <Nafai> shapr: Morning!
09:30:36 <mauke> *Main> (. 1) exp ()
09:30:36 <mauke> 2.718281828459045
09:30:41 <mauke> (I have that instance)
09:31:02 <shapr> hiya Nafai, how's code?
09:31:04 <glen_quagmire> Num (a->b) instance?
09:31:14 <desegnis> with Num b => ...?
09:31:25 <mauke> instance (Num a, Applicative f, Eq (f a), Show (f a)) => Num (f a)
09:31:40 <glen_quagmire> can lambdabot explain an expression in english?
09:31:48 <glen_quagmire> (. map) . (.) . filter
09:32:02 <mauke> @unpl (. map) . (.) . filter
09:32:02 <lambdabot2> (\ g m d -> filter g (map m d))
09:32:05 <byorgey> glen_quagmire: erm, no
09:32:13 <byorgey> glen_quagmire: although that would be an interesting feature =)
09:32:21 <glen_quagmire> hoa unpl!
09:34:46 <arcatan> ooa hela natten
09:35:16 <glen_quagmire> hoa I found that GOA means lambdabot on ghc
09:35:29 <shapr> god morgon arcatan!
09:35:34 <mauke> actually, it means "ghci on acid"
09:36:20 <arcatan> god afton
09:36:32 <glen_quagmire> no linux distro has goa package
09:37:41 <desegnis> Is this #norway?
09:38:18 <sorear> glen_quagmire: I
09:38:26 <sorear> 'd be a bit annoyed if any did
09:38:31 <LeCamarade> Just gotta go. Just found our President has a Facebook.
09:38:33 <LeCamarade> :o(
09:38:38 <sorear> lambdabot is not even remotely releasable
09:38:40 <koala_man> #sweden, you mean
09:38:44 <LeCamarade> Need to drink the depression down.
09:39:17 <desegnis> koala_man, if you say so
09:39:25 <ddarius> sorear: Yep. It is a mere five years old or so.
09:39:50 <glen_quagmire> sorear: oh i see
09:40:22 <shapr> sorear: Why not?
09:40:26 <sorear> ddarius: age does not completely determine quality
09:41:21 <sorear> shapr: The build system is a joke (and when it was designed rightly so, only two or three people need to build a bot)
09:41:50 <shapr> Can you build lambdabot with cabal?
09:42:09 <sorear> It will break insidiously
09:42:44 <sorear> if you don't use the sh build, many of the plugins won't work
09:42:53 <shapr> desegnis: Ok, is hyv√§√§ huomenta better?
09:43:22 <osfameron> p√§iv√§√§!
09:43:27 <shapr> yeah!
09:43:47 <desegnis> ^^
09:44:48 <mauke> <+hex> GIMMEH UNIK id FROM lol l, cats c WEN SAEM l.id, cats.lol_id;
09:44:53 <mauke> behold! lolsql
09:45:32 <Vulpyne> DO NOT WANT.
09:47:20 <xerox> sjanssen: ping
09:47:45 <glen_quagmire> i give up building goa. it requires lambdabot
09:48:31 <sjanssen> xerox: pong
09:48:47 <shapr> mauke: Whoa, that's beautiful!
09:49:11 <glen_quagmire> @pl \f l -> l ++ map f l
09:49:11 <lambdabot2> ap (++) . map
09:49:28 <glen_quagmire> @index ap
09:49:29 <lambdabot2> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
09:49:29 <lambdabot2> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
09:49:37 <glen_quagmire> sorry, lambdabot2 doesn't take privatemsg
09:49:42 <alar> @info ap
09:49:42 <lambdabot2> ap
09:49:53 <alar> @hoogle ap
09:49:54 <lambdabot2> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
09:49:54 <lambdabot2> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
09:49:54 <lambdabot2> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
09:51:21 <xerox> sjanssen: hi. You were suggesting that with gadts one can avoid contexts in functions, but I can't quite get that behaviour. What I do is data Foo a were Foo :: (Cxt a) => Int -> a -> Foo a, but then any functionf that passes the 'a' parameter to other (library) functions that have the same Cxt constraint make GHC complay of not finding the constraint on the function f.
09:52:07 <sjanssen> xerox: you have to pattern match on Foo
09:53:24 <xerox> sjanssen: I must use library functions on the 'a' thing.
09:53:40 <xerox> I pattern match on (Foo i a) to get the a out, though.
09:55:02 <xerox> sjanssen: in particular 'a' is an array element type
09:55:16 <sjanssen> hmm
09:55:34 <sjanssen> I thought that was supposed to work
09:56:14 <xerox> Cale: any idea?
09:57:01 <Cale> xerox: Which GHC?
09:57:06 <xerox> 6.6.1
09:57:20 <Cale> No, you need 6.7 for the behaviour you're looking for
09:57:34 <xerox> Dang.
09:57:40 <Cale> It's part of the new type system stuff which SPJ did back a while ago.
09:57:54 <xerox> And it works exactly as I tried now?
09:58:16 <Cale> if I understand correctly what it is that you're doing, yes
09:58:27 <xerox> OK cool.
09:58:34 * xerox compiles.
10:02:31 <glen_quagmire> @pl \l -> foldr (\x y ->  f (y,x)) 0 l
10:02:31 <lambdabot2> foldr ((f .) . flip (,)) 0
10:03:22 <glen_quagmire> @unpl flip foldr 0 . flip . curry
10:03:22 <lambdabot2> (\ i -> foldr (\ e f -> curry i f e) 0)
10:12:57 <zipMe_> @type zipWith
10:12:59 <lambdabot2> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:13:43 <araujo> afternoon
10:14:00 <glguy> likewise :)
10:16:11 <sfultong> I forget... what's the haskell equivalent of Java's serializable interface?  I remember hearing about some sort of script to make a data type "serializable"
10:16:46 <mauke> @hoogle alignment
10:16:46 <lambdabot2> Foreign.Storable.alignment :: Storable a => a -> Int
10:16:46 <lambdabot2> System.Win32.Info.sM_MENUDROPALIGNMENT :: SMSetting
10:16:50 <mauke> Storable
10:17:07 <mauke> or Show
10:17:08 <kpreid> sfultong: you can use Read and Show, too
10:18:47 <sfultong> eww... System.Win32... :-P
10:19:02 <sfultong> kpreid: thanks, I'll look into that
10:19:59 <sfultong> for some reason I thought it was more complex than just using Read and Show
10:24:57 <Nucleo> Is it true that `rem` is faster than `mod` for positive numbers?
10:25:34 <milkcan> can someone help me to vandalize wikipedia
10:25:35 <arcatan> that sounds like a micro optimization
10:25:45 <arcatan> milkcan: sure!
10:25:56 <mauke> not this shit again
10:26:04 <Botje_> milkcan: you need to create a wikipedia monad first.
10:26:09 <mauke> ban plz
10:27:12 <milkcan> death to everyone who opposes or insults islam
10:27:24 <milkcan> islam is a peaceful religion and shouldnt be insulted
10:27:33 <milkcan> jews are pillaging innocent palestinians and raping their children
10:27:40 <milkcan> jews stole all diamond mines from palestinians
10:27:43 <arcatan> okay, wtf, ban plz
10:28:12 <zmike> haha
10:28:17 <mauke> milkcan is a known (lame) troll
10:28:27 <milkcan> i throw stones to jews
10:28:30 <milkcan> my stones crush israeli tanks
10:28:34 <milkcan> my father has eight donkeys
10:28:36 <arcatan> whoa, the example of mauke made me ask for someone to be banned. this channel has bad impact on me
10:29:05 <milkcan> allahu akhbar
10:29:07 <milkcan> god bless allah
10:29:14 <mauke> haha
10:29:18 <oerjan> arcatan: clearly you should ban yourself from it :D
10:30:33 <oerjan> "god bless allah"? >_O
10:31:17 <zmike> That's a recursive algorithm!
10:31:49 <arcatan> reminds me of GODs over Djinn
10:33:18 <bos> i wonder who k-lined them
10:33:19 <astrolabe> > 2
10:33:21 <lambdabot2>  2
10:33:27 <astrolabe> @list
10:33:28 <lambdabot2> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:34:04 <astrolabe> oh. He's gone?
10:34:41 <gwern> > 2 ^ 8
10:34:43 <lambdabot2>  256
10:34:47 <gwern> > 2 ^ 16
10:34:48 <lambdabot2>  65536
10:35:01 <ivant> > 2^256
10:35:02 <lambdabot2>  115792089237316195423570985008687907853269984665640564039457584007913129639936
10:35:24 <ivant> it is smaller than I thought
10:35:27 <gwern> I don't think we need a 256-bit address architecure anytime soon
10:35:38 <oerjan> > 2^65536
10:35:39 <lambdabot2>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
10:36:14 <dmead_> > 2^2^65536
10:36:16 <astrolabe> 2^n has approximately 10n/3 digits
10:36:18 <lambdabot2> Terminated
10:36:24 <ivant> > 65536 * log 2 / log 10
10:36:25 <lambdabot2>  19728.301795834668
10:36:28 <oerjan> > logBase 10 (2**256)
10:36:29 <lambdabot2>  77.06367888997917
10:36:38 <mauke> > log10 1
10:36:39 <lambdabot2>   Not in scope: `log10'
10:36:51 <astrolabe> er I mean 3n/10 digits
10:36:51 <ivant> 19729 digits
10:37:14 <oerjan> > logBase 10 2 * 65536
10:37:15 <lambdabot2>  19728.301795834668
10:37:23 <astrolabe> So lambdabot seems to be getting it wrong
10:37:29 <ivant> why?
10:37:37 <xerox> How do you compile happy on OSX?
10:37:45 <astrolabe> Ah.  i didn't see the ... at the end
10:37:53 <xerox> It needs happy to build, and there seem not to be any Intel OSX distribution of happy.
10:41:00 <gwern> bloody hell. is there any real documentation on the UTF encoding library?
10:41:25 <gwern> the darcs repo seems to just be code and not even a readme on what it does
10:42:56 <gwern> think I'll try utf8-string. maybe that will actually have informative comments
10:48:36 <Nucleo> Is there anything in HHL to deal with complex numbers? (or at least gaussian integers?)
10:48:36 <matthew-_> meh, haskell is self documenting. Honest.
10:49:11 <gwern> matthew-_: go play some more with @pl and tell yourself that :)
10:49:46 <matthew-_> gwern: @pl isn't that scary. It just might mean you spend 10 minutes starring at about 20 chars before you figure out what's going on
10:50:22 <oerjan> Nucleo: er, Data.Complex has complex numbers _but_ they must be floating, alas
10:50:24 <Cale> Nucleo: Data.Complex
10:50:36 <Nucleo> than you, oerjan & Cale
10:50:38 <Cale> Nucleo: You can easily implement Gaussian integers though
10:50:39 <oerjan> :t Complex
10:50:39 <Nucleo> thank
10:50:41 <lambdabot2> Not in scope: data constructor `Complex'
10:50:45 <lament> how do i add two Fractional numbers of different types? :\
10:51:00 <Cale> lament: Convert them to the same type using realToFrac
10:51:10 <Cale> (If possible)
10:51:21 <Cale> In general, it's not possible.
10:51:24 <lament>     Could not deduce (Real a) from the context (Fractional a)
10:51:25 <lament>       arising from use of `realToFrac' at test.hs:14:41-58
10:51:30 <Cale> Right.
10:51:50 <oerjan> lament: fractionals can be complex, e.g.
10:51:51 <Cale> Two fractional values might be in completely different fields.
10:51:55 <lament> nnnngh
10:52:01 <Cale> For example an element of Z_p and an element of C.
10:52:11 <Cale> It makes no sense to add those.
10:52:42 <lament> oh, okay, this type is actually Real too, i didn't notice.
10:52:44 <lament> yay
10:56:11 <zipMe_> @hoogle Char -> String
10:56:12 <lambdabot2> Network.URI.escapeURIChar :: (Char -> Bool) -> Char -> String
10:56:22 <oerjan> :t (:[])
10:56:24 <lambdabot2> forall a. a -> [a]
10:56:44 <zipMe_> oerjan : ta !
10:57:32 <oerjan> also just [c]
10:59:02 <zipMe_> oerjan: yes but I needed the section
11:02:55 <glguy> Does anyone happen to know if there are an guarantees on the order of takeMVar being performed matching the order that they are fulfilled?
11:05:24 <oerjan> "When multiple threads are blocked on an MVar, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using MVars."
11:05:34 <glguy> yeah, I just noticed that too :)
11:05:53 <glguy> http://hpaste.org/2417
11:06:01 <glguy> so I wonder why Qsem doesn't use this implementation then
11:07:22 <glguy> maybe because if two threads were trying to signal... and the threads that were waiting were slow to be awoken...
11:07:30 <glguy> the 2nd signalling thread would have to wait
11:07:45 <glguy> for the first waiting to take its ()
11:14:37 <xerox> Anybody on OSX intel has got happy installed by any chance?
11:16:25 <xerox> There's no happy in the ghc-6.6 bin dist, no happy in the ghc-6.6.1 bin dist, no happy on haskell.org/happy.  No happy :(
11:16:38 <lament> what's the analog of C sleep()? threadDelay?
11:17:40 <glguy> threadDelay
11:18:04 <bos> any cabal hackers around?
11:18:17 <Igloo> xerox: happy isn't meant to be in GHC bindists
11:18:33 <arcatan> how about banal hackers?
11:19:11 <thoughtpolice> lament: yeah
11:19:54 <thoughtpolice> xerox: is it just not resolving?
11:20:05 <thoughtpolice> page shows up fine and I can wget the sources
11:20:20 <xerox> Igloo: how does one bootstrap happy on osx intel?
11:20:32 <xerox> thoughtpolice: can you build them as well?
11:20:42 <xerox> thoughtpolice: on OSX intel anyway.
11:20:53 <thoughtpolice> xerox: I don't have an OS X box, sorry. :/ (linux)
11:20:56 <Igloo> xerox: If you have GHC then you can build happy
11:21:00 <zipMe_> xerox : yeah
11:21:10 <xerox> Igloo: I do have GHC.
11:21:22 <zipMe_> xerox : I have happy installed
11:21:27 <_roconnor> I'm getting tired of firefox always crashing
11:21:39 <glguy> _roconnor: uninstall some of your extensions
11:21:44 <_roconnor> It's probably flash's fault
11:21:45 <xerox> Setup.lhs: Error: Could not find location for program: happy
11:21:52 <zipMe_> configure: Using happy: /usr/local/bin/happy
11:22:00 <_roconnor> or maybe the spell check
11:22:02 <_roconnor> who knows
11:22:09 <Igloo> xerox: Is that really a fatal error?
11:22:13 <xerox> zipMe_: where do you have got it?
11:22:14 <dmead_> someonet tell me how to build nhc
11:22:15 <dmead_> :(
11:22:17 <xerox> Igloo: yes
11:22:19 <dmead_> before i /cry
11:22:45 <zipMe_> xerox : err... I know it doesn't sound good but I cant remember !
11:22:45 <xerox> Igloo: configure passes, build dies with that error
11:22:55 <thoughtpolice> dmead_: http://haskell.org/nhc98/install.html :)
11:22:55 <lambdabot2> Title: Building/installing nhc98
11:23:01 <zipMe_> xerox : I install too much stuff
11:23:10 <Igloo> xerox: are you building from darcs or from a tarball?
11:23:13 <dmead_> thoughtpolice, it doesn't work
11:23:19 <xerox> Igloo: tarball, happy-1.16
11:23:24 <zipMe_> xerox : I'm on GHC 6.6 though
11:23:31 <thoughtpolice> dmead_: :/ I can give a shot to compiling it on my linux box; what's the error?
11:23:40 <dmead_> it' smore than just errors
11:23:45 <dmead_> lots of files are missing in the tarball
11:23:49 <dmead_> :/
11:23:49 <thoughtpolice> hm bummer.
11:23:51 <thoughtpolice> just a sec.
11:24:03 <xerox> zipMe_: do you use macports, or install from haskell.org tarballs/darcs ?
11:24:17 <zipMe_> darwinports
11:24:20 <Igloo> xerox: Hmm, you should already have .hs files, then. Try deleting the .ly files?
11:25:17 <xerox> Igloo: that worked, now it is building.
11:26:03 <xerox> Yay!
11:26:29 <xerox> Igloo: same for alex.
11:26:47 <xerox> Setup.lhs: Error: Could not find location for program: alex
11:28:34 <xerox> Igloo: this one resolved deleting src/Scan.x
12:01:48 <Muuh> http://www.streetracers.de.tp/?wid=9139
12:01:50 <lambdabot2> Title: Streetracers
12:02:18 <Muuh> adresu:http://www.bsd.org.yu
12:16:04 <nominolo> @users
12:16:04 <lambdabot2> Maximum users seen in #haskell: 411, currently: 383 (93.2%), active: 2 (0.5%)
12:16:27 <xerox> Yuck! This was unexpected. real 14m57.972s  user 14m48.410s  sys 4m41.940s
12:16:37 <xerox> GHC "quick" build, make -j3
12:16:51 <nominolo> @users
12:16:52 <lambdabot2> Maximum users seen in #haskell: 411, currently: 385 (93.7%), active: 2 (0.5%)
12:17:01 <nominolo> 2 active users?
12:17:21 <nominolo> xerox: what machine?
12:17:45 <int-e> @users
12:17:45 <lambdabot2> Maximum users seen in #haskell: 411, currently: 385 (93.7%), active: 3 (0.8%)
12:17:51 <xerox> a macbook pro, 2.2ghz, 2Gb ram
12:18:00 <nominolo> xerox: also, on a dual-core, you can chose an even higher -jN
12:18:14 <xerox> What do you suggest?
12:18:23 <nominolo> dunno, at least -j4
12:18:35 <xerox> Alright :)
12:18:37 <nominolo> what os do you use?
12:18:39 <xerox> Next time.
12:18:40 <xerox> OS X
12:19:01 <nominolo> osx memory manager is really bad
12:19:23 <nominolo> so, i assume it could be even faster on a linux
12:19:31 <sjanssen> should be okay with 2GB of RAM though
12:19:31 <xerox> I guess so
12:19:48 <nominolo> sjanssen: it's mac os
12:19:53 <nominolo> but, yes
12:20:07 <sjanssen> nominolo: yeah, I know what you mean there
12:20:17 <sjanssen> I switched to Linux because I was tired of that
12:20:24 <nominolo> i strongly consider doing that too
12:20:38 <nominolo> which distro?
12:20:55 <xerox> ubuntu works nicely, from the latest release at least
12:21:22 <nominolo> ubuntu is debian compatible, isn't it?
12:21:32 <evir> Not really.
12:21:43 * gour is happy with arch
12:21:46 <evir> It uses the same package format, but you'll run into problems installing Debian packages on Ubuntu or vice versa.
12:21:55 <nominolo> i see
12:22:01 <evir> Because of different library versions, etc.
12:22:20 <nominolo> but they have aptitude, right?
12:22:31 <evir> Both, yes.
12:23:05 <nominolo> sjanssen: do you share your accounts between both os?
12:23:50 <sjanssen> nominolo: I use Gentoo.  It took quite a bit of tweaking, but it works well no
12:23:51 <sjanssen> w
12:23:53 <nominolo> sjanssen: i read it's possible, but you have to make sure to chose the right user id
12:24:18 <sjanssen> nominolo: yeah, I didn't bother with that
12:25:29 <dylan> sjanssen: have you heard anything about suspend-to-ram support for poor sods with ppc + nvidia cards?
12:26:01 <sjanssen> dylan: nah, I use Intel+Intel
12:26:16 <sjanssen> the Intel graphics cards have really nice Linux support
12:26:25 <dylan> Poop.
12:26:50 * dylan is stuck in OS X because of having the unlucky combination of PPC and nvidia. :(
12:27:19 <lament> are you dylan, the programming language?
12:28:06 <nominolo>  /whois dylan
12:28:30 <dylan> lament: I'm fairly certain I predate the language. :P
12:28:40 <ray> nah, he's bob dylan
12:28:41 <dylan> Not by much, but still.
12:28:45 <nominolo> as does Bob
12:28:59 <dylan> I was named after Dylan Thomas more so, I believe.
12:29:07 <lament> ooh
12:29:10 <dylan> I do not go gentle into that good night.
12:29:14 <lament> of all the dylans, that's clearly the coolest
12:30:30 <dylan> hrm, who maintains happs here?
12:30:46 <dylan> http://happs.org/auto/HAppS-0.8.8.tar.gz is a broken link.
12:31:03 <dylan> (on http://happs.org/HAppS/README.html#download)
12:31:03 <lambdabot2> Title: HAppS -- Haskell Application Server (version 0.8.8 )
12:31:16 <kaol> there's going to be a new HAppS version out real soon now
12:31:34 <kaol> I'd advise to not bother with the 0.8.8 version
12:31:49 <ray> i hear shapr maintains it
12:32:08 <ray> he mentioned an 0.9 version
12:33:05 <sm> bah.. it's been due for ever
12:33:20 * sm nags shapr
12:33:24 <ray> today's the day - i can feel it
12:33:53 <Dogg> http://www.streetracers.de.tp/?wid=9128
12:33:54 <lambdabot2> Title: Streetracers
12:34:22 <ivant> ban him finally
12:35:11 <xerox> Too late :-(
12:36:36 <ivant> can we teach lambdabot to ban those who send a link matching some regexp right after they connect?
12:37:03 <lament> what's the point?
12:37:11 <lament> if you could teach it to ban them _in advance_...
12:37:42 <yaxu> wasn't there something about a time travel monad?
12:37:50 <ivant> I believe lambdabot can do that, remember those "time travel monads"?
12:37:58 <ivant> :-)
12:38:24 <ivant> or was it simply the lazyness?
12:38:49 <yaxu> I guess laziness is a form of time travel :)
12:38:50 <lament> banning is neither a punishment (they don't care) nor a deterrent (they still don't care) nor does it prevent repeat offenses (they're gonna change IP anyway) nor does it block spam (since they say it once and go silent)
12:40:02 <xerox> yaxu: there's something that provides undo and redo
12:45:09 <SamB> the other option is to somehow get them k-lined
12:45:11 <ricky_clarkson> One could have a client that delays all messages until 30 seconds has passed without someone saying "can someone ban $SENDER?".
12:45:17 <SamB> they care about that
12:45:46 <SamB> ricky_clarkson: slow!
12:46:01 <evir> SamB: Then you need either to K-Line whole provider networks ... or they will just change their IP.
12:46:24 <SamB> won't it annoy them if they have to change IP too often?
12:46:25 <ricky_clarkson> SamB: It could show them instantly then retroactively remove them from your display.
12:46:57 <ricky_clarkson> Some big channels often have the entire broadband using population of Turkey on the banlist.
12:47:01 <SamB> ricky_clarkson: how about removing them from the logs?
12:47:10 <evir> SamB: Changing IPs is less annoying than making new K-lines.
12:47:13 <ricky_clarkson> I don't care about logs.
12:47:18 <evir> It's a matter of who gives up first. :-)
12:47:22 <SamB> evir: not if it's botomated
12:47:37 <SamB> and then you can K-line the whole ISP if you have to
12:47:56 <ricky_clarkson> #haskell isn't +r, that would 'help'.
12:48:21 <ricky_clarkson> Of course, the goal of having 1000 users would never be met with +r.
12:48:44 <evir> What's +r?
12:48:55 <ricky_clarkson> Only identified users.
12:54:23 <yaxu> i'm taking the example 'chat server' code that uses Network.Socket , and want to play with making a client for it...  will i become unstuck if I try using the higher level Network library for that?
12:54:30 <dmead_> uhh
12:54:33 <dmead_> someone remind me
12:54:39 <dmead_> comparing real numbers is bad right?
12:55:03 <yaxu> bad how?
12:55:17 <dmead_> bad as in 100 == 99.9999999
12:55:40 <dmead_> you'll get two reals whos difference is inside the precision of your arch
12:55:46 <dmead_> so they will be equal
12:56:03 <yaxu> > 100 = 99.99999999999999999999999
12:56:03 <lambdabot2>  Parse error
12:56:06 <yaxu> > 100 == 99.99999999999999999999999
12:56:08 <lambdabot2>  True
12:56:11 <dmead_> :<
12:56:29 <dmead_> > 100 == 99.99
12:56:30 <lambdabot2>  False
12:56:33 <dmead_> hmm
12:56:36 <dmead_> > 100 == 99.9900
12:56:37 <lambdabot2>  False
12:56:40 <dmead_> > 100 == 99.9999
12:56:41 <lambdabot2>  False
12:56:44 <dmead_> > 100 == 99.9999999
12:56:45 <lambdabot2>  False
12:56:47 <ricky_clarkson> Fascinating.
12:56:47 <dmead_> > 100 == 99.999999999
12:56:48 <lambdabot2>  False
12:56:52 <dmead_> > 100 == 99.99999999999
12:56:53 <lambdabot2>  False
12:56:56 <dmead_> > 100 == 99.999999999999999999
12:56:57 <lambdabot2>  True
12:56:58 <ricky_clarkson> At least use binary search.
12:56:58 <dmead_> > 100 == 99.9999999999999999
12:57:00 <lambdabot2>  True
12:57:01 <dmead_> hah
12:57:02 <dmead_> > 100 == 99.999999999999999
12:57:03 <lambdabot2>  True
12:57:05 <dmead_> > 100 == 99.9999999999999
12:57:07 <lambdabot2>  False
12:57:10 <dmead_> > 100 == 99.99999999999999
12:57:11 <lambdabot2>  False
12:57:14 <dmead_> > 100 == 99.999999999999999
12:57:15 <lambdabot2>  True
12:57:17 <dmead_> found it
12:57:35 <dmead_> what arch is it running on?
12:57:40 <ricky_clarkson> 19 9s, not even Erlang can boast that!
12:58:01 <dmead_> i'm actually writting an implementation in C
12:58:18 <dmead_> so it's going to be nowhere near as accurate as haskell
12:58:25 <dmead_> that is, if we're using Int class
12:58:43 <geezusfreeek> > 100%1 == 99999999999999999%1000000000000000
12:58:44 <lambdabot2>  False
12:58:47 <geezusfreeek> :)
12:58:48 <ricky_clarkson> Here's a challenge, write a type system that lets you use the IEEE formats but doesn't allow lossy calculations.
12:58:56 <yaxu> i hope no one minds me repeating my network question after all that :)
12:59:02 <yaxu> i'm taking the example 'chat server' code that uses Network.Socket , and want to play with making a client for it...  will i become unstuck if I try using the higher level Network library for that?
12:59:21 <dmead_> yaxu, you'll be fine
12:59:29 <dmead_> i have a chat server in java if you want to try and port it
12:59:30 <ricky_clarkson> (or makes you keep track of the accuracy range)
12:59:31 <yaxu> thanks
13:00:02 <dmead_> ricky_clarkson, could ass precison to the typing system
13:00:05 <dmead_> *add
13:00:06 <dmead_> xDD
13:00:09 <yaxu> oh i'm just doing something simple, but thanks dmead
13:00:31 <dmead_> yaxu, my thing is simple, just a peer to peer chat program
13:01:43 <yaxu> i know socket programming, this is my first go at haskell network code tho
13:01:56 <ricky_clarkson> dmead_: Of course, but the advantage of the IEEE formats is speed.
13:02:13 <ricky_clarkson> It'd be good to use them with predictable loss.
13:03:14 <dmead_> yeaa
13:03:19 <SamB> so you want to write a numerical analyst in the typesystem?
13:03:25 <dmead_> i'm trying to write a binary search through an array of floats in C
13:03:29 <dmead_> and it's not going so good
13:03:37 <ricky_clarkson> SamB: No, I want someone else to.
13:04:32 <SamB> ask oleg
13:04:35 <SamB> ;-P
13:04:58 <dmead_> > 100 == 99.999999999999999
13:05:00 <lambdabot2>  True
13:05:04 <dmead_> > 100 == 99.99999999999999
13:05:05 <lambdabot2>  False
13:05:10 <dmead_> hmm
13:05:14 <dmead_> must be using machine ints
13:05:20 <dmead_> cause thats the same precision i get in c++
13:05:57 <matthew-_> mmm. Float/Double should not be in Eq
13:06:30 <Liskni_si> Eq is a prerequisite for Ord, isn't it?
13:06:41 <matthew-_> no
13:06:45 <matthew-_> only if deriving
13:06:51 <Liskni_si> ah
13:06:56 <matthew-_> you can manually implement Ord without Eq
13:07:23 <Liskni_si> ghci's :info Ord says "class (Eq a) => Ord a where" though
13:07:26 <Liskni_si> does that matter?
13:07:55 <matthew-_> oh. that rather suggests I'm utterly wroong
13:09:18 <matthew-_> huh, I'm confused then. for some reason I thought you didn't need Eq.
13:10:08 <Heffalump> Ord defines total orders
13:10:17 <Heffalump> those don't make sense without an equality test too
13:10:37 <Heffalump> if you want partial orders you'd need to define something else
13:10:43 <matthew-_> huh. Bizarre. I was convinced. I wonder what I'm thinking of then
13:10:58 <Liskni_si> can't you decide equality by a <= a && a >= a ?
13:11:23 <Heffalump> Liskni_si: if you have a total order, yes
13:11:32 <Liskni_si> or is it just that it's logical to require the Eq class?
13:11:53 <ricky_clarkson> Just at random - how does comparison work on complex numbers?
13:11:59 <ricky_clarkson> Is i > 1?
13:12:06 <Heffalump> and once you've got a total order, you might as well have Eq so you can do it efficiently
13:12:46 <Heffalump> oh, wait partial orders have that property too. I think I was thinking of something weaker still.
13:12:50 <matthew-_> is there any class which you can derive instances for where the derivation requires an instance that isn't a superclass of the class in question?
13:13:11 <mm_freak> <matthew-_> mmm. Float/Double should not be in Eq   ‚áê why not?  they're comparable, so it makes sense for them to be in Eq‚Ä¶  whether that's a smart thing to do is another question and depends highly on the application
13:13:30 <Heffalump> derive in H98?
13:13:41 <matthew-_> Heffalump: yeah
13:14:01 <Heffalump> I don't think so.
13:14:09 <matthew-_> Heffalump: if not, I must be going mad. I'm sure I was told about such a case here on #haskell.
13:14:25 <Heffalump> oh, wait, there might be. I'll check.
13:15:42 <Heffalump> no, there aren't
13:15:58 <matthew-_> ok, I must have been confused or something.
13:16:04 <matthew-_> ooi, how did you check?
13:17:29 <Heffalump> by reading the report
13:17:33 <matthew-_> mm_freak, the varying resolution means that the Eq available on floating point doesn't reflect the expected behaviour of Eq. x + 1 == x
13:17:38 <Heffalump> there's only a very small number of derivable classes
13:17:39 <matthew-_> Heffalump: ahh!
13:19:02 <matthew-_> oh boy. we might just loose this match.
13:19:09 <kpreid> I think that's more usefully defined as a flaw in (+) than in (==)
13:19:24 <Liskni_si> not really in (+), i'd say
13:19:35 <kpreid> in the Float instance of (+), I mean
13:19:45 <Liskni_si> it might be just that the 1 actually falls to zero
13:19:47 <matthew-_> well, with suitable rearrangements, you can get to 1 == 0
13:19:50 <Liskni_si> but maybe the plus as well
13:19:54 <matthew-_> which even Float doesn't agree with
13:20:07 <matthew-_> so it's just terribly inconsistent - i.e. it doesn't obey maths
13:20:42 <matthew-_> anyway, I've ranted about this before...
13:20:49 <Heffalump> matthew-_: the cricket?
13:20:57 <matthew-_> Heffalump: yup
13:21:18 <matthew-_> with Colly + Bell in, I thought we might just do it...
13:21:22 <Heffalump> ouch, 5 down :-(
13:22:17 <matthew-_> mmm. run rate only to 7.3 though. It's still doable, though will require a lot of guts and probably a lot of luck
13:24:12 <fasta> How can I find space leaks?
13:24:27 <geezusfreeek> black magic
13:24:35 <xerox> sjanssen, Cale - update on GADT and functions' typesig context. It indeed works done that way :)
13:24:54 <sjanssen> xerox: but you needed 6.7 to make it work?
13:25:01 <geezusfreeek> i've not yet gotten to a need to find space leaks yet though, so my suggestion is probably not ideal
13:25:08 <xerox> sjanssen: yes.
13:25:42 <PaulAJ> I've had to find space leaks.  Basically I just used all the space profiling options and tried to understand what they were telling me.
13:26:12 <PaulAJ> Get the graphs out in postscript and view them.  Look for things that grow over time.  Then try to figure out where they are coming from.
13:26:21 <fasta> Ok, I now have the -hd profile
13:26:23 <PaulAJ> Like geezusfreeek says, its black magic.
13:26:28 <Heffalump> and hope you don't tickle a GHC bug in the process
13:26:39 <fasta> I see that (,) holds onto 90MB memory
13:26:51 <fasta> How do I interpret that information?
13:27:06 <fasta> Heffalump: too late for that, I already found one
13:27:19 <fasta> Heffalump: but it was fixed already :)
13:27:27 <Heffalump> is -hd a retainer profile?
13:27:27 * PaulAJ goes to look at the GHC manual for -hd
13:27:47 <fasta> http://haskell.org/ghc/dist/current/docs/users_guide/prof-heap.html#biography-prof
13:27:49 <lambdabot2> Title: 6.4. Profiling memory usage, http://tinyurl.com/28cfq7
13:27:50 <Heffalump> if not, that's probably what you want, if it's not obvious from the constructor what the problem is
13:28:18 <mm_freak> matthew-_: why?  Eq is not related to Num
13:28:26 <PaulAJ> Yeah, just found it.  Does the usage grow over time?
13:28:27 <Heffalump> oh, -hd is just a restriction option
13:28:30 <fasta> Heffalump: the profile doesn't tell _what_ use of (,) causes the problem.
13:28:31 <Heffalump> which major option did you use?
13:28:34 <fasta> PaulAJ: yes
13:28:53 <fasta> Heffalump: ./Main +RTS -p -hd -K900M -L35 -xc  -RTS
13:29:04 <fasta> Heffalump: that's all
13:29:21 <PaulAJ> This is true.  And thats the difficult bit.  One reason for naming your datatypes rather than anonymous tuples is that it helps narrow things down.
13:29:36 <fasta> PaulAJ: heh
13:29:46 <Heffalump> don't you need one of the options at the top?
13:29:53 <Heffalump> of 6.4.1
13:30:03 <PaulAJ> Try -hr for retainer profiling.  It tells you what is hanging on to this data.
13:30:39 <Heffalump> oh, I see. You aren't breaking it down at all.
13:30:43 <Heffalump> -hc is also a useful option
13:30:44 <PaulAJ> I never got it to work myself, due to a segmentation violation in the run time.  That was an earlier GHC version.
13:30:47 <Heffalump> Usually that's where I start.
13:30:53 <Heffalump> PaulAJ: me too, in 6.6
13:30:53 <fasta> Heffalump: I already tried hc
13:31:04 <fasta> Heffalump: it doesn't tell me anything about why it grows.
13:31:17 <PaulAJ> Did it tell you anything at all?  Like which function was the problem?
13:31:20 <Heffalump> oh, sorry, ignore me saying it's not a major option, I'm just blind.
13:31:58 <PaulAJ> If it just says its a CAF then thats not useful.  But if it tells you its your foobar function then that is useful.
13:32:20 <Heffalump> you can build with -caf-all if it just says CAF
13:32:30 <Heffalump> though that runs into yet more GHC bugs sometimes
13:32:38 <sfultong> hmm, 2 lambdabots?
13:32:45 <Heffalump> > 1
13:32:48 <lambdabot2>  1
13:32:54 <Heffalump> seems only one is alive
13:33:44 <sfultong> ah, I see
13:34:14 <PaulAJ> A common problem is unevaluated thunks.  Say you have a recursive function that calls itself with a function of an argument.  You can get a situation where the parameter never actually gets evaluated.  Instead you get a thunk for f x, then for f (f x), then for f ( f ( f x)), and so on.
13:34:31 <PaulAJ> fasta: you still there?
13:34:35 <fasta> PaulAJ: yes
13:35:18 <sfultong> > 1
13:35:20 <lambdabot2>  1
13:35:30 <fasta> PaulAJ: but I haven't heard anything that can help
13:35:36 <PaulAJ> If you are getting a chain of unevaluated thunks then judicious strictness annotations can solve the problem.
13:35:43 <PaulAJ> Its a bit difficult without seeing the code.
13:35:44 <sfultong> > let strange = fix (\x -> id . x)
13:35:44 <lambdabot2>  Parse error
13:36:04 <fasta> PaulAJ: compiling with -r crashes GHC
13:36:08 <fasta> PaulAJ: -hr *
13:36:36 <fasta> PaulAJ: also, again: what does the output of -hd mean?
13:36:58 <phobes> PaulAJ: you're saying there are examples where evaluation terminates with strictness annotations added that otherwise would diverge?
13:37:02 <Heffalump> it's telling you about the constructor that made the data
13:37:17 <Heffalump> phobes: not diverge, just use lots of memory (or run out of it)
13:37:31 <phobes> ok
13:37:50 <Baughn> > fix (\x -> id . x) 4
13:37:54 <lambdabot2> Terminated
13:38:10 <fasta> Heffalump: so, (,) creates the most "data". How can (,) cause, that as it's not recursive?
13:38:10 <PaulAJ> fasta: It gives you the closure that created the data.  For pure data this is the constructor (in your case (,)).  If you write something like (x *) which is a combination of a function call with some data then you get a compiler-generated name instead.
13:38:43 <PaulAJ> (,) is the data type.  What you want is the thing that calls it.
13:39:06 <fasta> And strictify that?
13:39:53 <PaulAJ> First find the cost centre (i.e. the function or bit of function that calls (,).  Then try to understand what the code is doing in terms of lazy evaluation.
13:39:54 <fasta> I am guessing a bit, since I don't understand the complete picture.
13:40:11 <oerjan> @hoogle [a->b]->[a]->[b]
13:40:12 <lambdabot2> No matches, try a more general search
13:40:25 <fasta> PaulAJ: can you give an example of how (,) might use lots of memory?
13:40:26 <PaulAJ> I know the feeling.  I've been there.  Figuring out memory allocation is definitely a weak point of Haskell in the real world.
13:40:47 <fasta> PaulAJ: I notice, please share your wisdom :)
13:41:04 <sjanssen> fasta: (,) will use lots of memory if you create lots of tuples
13:41:23 <kolmodin> :t zipWith ($)
13:41:25 <lambdabot2> forall a b. [a -> b] -> [a] -> [b]
13:41:46 <oerjan> kolmodin: i know, i wondered if it had a name (like "zap"?)
13:42:05 <kolmodin> not as far as I know
13:42:08 <PaulAJ> sjanssen is correct.  Thinking about it, I cant see how you could get a chain of thunks with (,) involved: the types wouldn't work.
13:42:22 <kolmodin> zap would be a cool name :)
13:42:48 <oerjan> it's to zipWith* what ap is to liftM*
13:42:58 <fasta> I create lots of tuple, but nowhere near 90MB of them
13:43:05 <fasta> At least not at the same time.
13:43:12 <fasta> At least that's not my intention.
13:43:25 <fasta> Note that this grows to 1GB.
13:43:34 <PaulAJ> Have you found the function that is creating all this memory?  compile with -prof -auto-all.  Then run with +RTS -hc to find the function.
13:43:59 <fasta> PaulAJ: The one allocating the most stuff is $f2
13:44:11 <fasta> PaulAJ: the one after it is also known to me: call it foo.
13:44:23 <fasta> PaulAJ: but they don't do anything with tuples.
13:44:48 <oerjan> they are both applicatives, but since lists can only be Applicative in one way without a newtype, <*> = ap on lists (i think)
13:45:11 <PaulAJ> You aren't using State or StateT monads by any chance?
13:45:17 <oerjan> > [(+2),(*2)] <*> [1,3]
13:45:18 <lambdabot2>  [3,5,2,6]
13:45:22 <fasta> PaulAJ: I am using StateT
13:46:07 <PaulAJ> Ahh! StateT creates tuples internally.  Now we are getting somewhere.  In the latest version State comes in lazy and strict variants.
13:46:15 <PaulAJ> Try the other one (lazy is the default).
13:46:18 <fasta> PaulAJ: I use the lazy variant
13:46:22 <sfultong> @src fix
13:46:22 <lambdabot2> fix f = let x = f x in x
13:46:24 <PaulAJ> Try strict.
13:46:26 <fasta> PaulAJ: ok, trying the strict one.
13:46:54 <PaulAJ> It could be that you are seeing a chain of states constructed by StateT.
13:47:28 <fasta> I hope that changing one line does it
13:47:30 <PaulAJ> BTW, are you compiling with optimisation on?  One of the big optimisations made by GHC is to strictify things where possible.
13:47:38 <fasta> PaulAJ: yes, O2
13:48:08 <fasta> It would be nice to say: stop compiling when you even touch Control.Monad.State.Lazy
13:48:35 <PaulAJ> Not necessarily.  Sometimes laziness is the right answer.  In fact its more often the right answer than strictness.
13:49:14 <fasta> PaulAJ: (,) still sky-rockets
13:49:33 <Heffalump> what did -hc say, anyway?
13:49:52 <Heffalump> it must have identified a few top SCC stacks
13:50:00 <fasta> Heffalump: $f2 and foo
13:50:08 <fasta> Heffalump: I already said earlier.
13:50:29 <Heffalump> ah, sorry
13:50:34 <PaulAJ> My guess is that $f2 is the state monad code.
13:50:49 <fasta> PaulAJ: suppose a lazy WriterT is also a recipe for disaster?
13:50:59 <xerox> There is no more {-# OPTIONS_GHC ... #-} in ghc-6.7 ?
13:51:01 <sorear> My guess is that it is the result of the recent changes to deriving.
13:51:04 <PaulAJ> Again, it depends.
13:51:08 <sorear> xerox: sure there are
13:51:27 <sorear> @seen dons
13:51:27 <lambdabot2> dons is in #haskell and #haskell-hac07. I last heard dons speak 1d 19h 56m 50s ago.
13:51:29 <Heffalump> I can't find it in scrollback, are they just too high level to tell you anything?
13:51:38 <sorear> Heffalump: no, $f2
13:51:48 <sorear> Heffalump: that's not a metavariable, that's a gensym
13:51:57 <Heffalump> foo, though
13:51:59 <xerox> hm, ghci doesn't read my -i/foo there.
13:52:02 <shapr> dylan: The release is imminent, so the new (not yet available) download links will work.
13:52:47 <PaulAJ> fasta: Try looking at your state data.  Also, what is the inner monad in your StateT?
13:53:09 <fasta> PaulAJ: WriterT
13:53:25 <Heffalump> what monoid?
13:53:47 <fasta> Heffalump: Doc
13:54:04 <fasta> Heffalump: implemented with <>
13:54:07 <PaulAJ> I think WriterT also uses (,).  It could also be a more likely culprit because you keep on adding to the writer data without reading it out.
13:54:27 <Heffalump> ISTR augustss found a space leak in that, or in HaXML's usage of it
13:54:32 <PaulAJ> Hence data stacks up.  Could this make sense?
13:54:34 <Heffalump> PaulAJ: really, where would it use it?
13:54:40 <koxinga> Hi, I am a complete beginner in haskell. I wanted to have a list of all lists of five numbers, the numbers being between 1 and 8, (something like [[1,1,1,1,1],[1,1,1,1,2], ... ,[8,8,8,8,8]])
13:54:50 <koxinga> I managed to do it, but my code is really ugly
13:54:55 <PaulAJ> Its been a while since I read All About Monads.
13:54:56 <Heffalump> fasta: try making a new version of Doc with deepSeqs in the mappend
13:55:00 <sorear> > replicateM 5 [1..8]
13:55:02 * PaulAJ goes to revise the WriterT monad.
13:55:03 <koxinga> Could someone show me an elegant way to do this ?
13:55:08 <lambdabot2>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,1,6],[1,...
13:55:25 <Heffalump> PaulAJ: oh, sorry, of course it would. It'd tuple the result and the writer output.
13:55:26 <koxinga> :D
13:56:10 <lament> arg indentation error.
13:56:34 <fasta> Heffalump: I doubt that is the problem as I don't write a lot to it.
13:56:40 <Heffalump> but I'm not convinced that the tuples in either State or Writer would lead to long-lived (,)s, because >>= would just deconstruct them straight away and nothing would hold on to them
13:56:42 <fasta> Heffalump: or is that immaterial?
13:56:43 <oerjan> @quote entire.program
13:56:43 <lambdabot2> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
13:56:43 <lambdabot2> for your entire program.")
13:56:52 <Heffalump> fasta: no, if you don't write a lot it's probably not that
13:56:55 <PaulAJ> Do you make lots of state changes without reading the state?  Or maybe some aspect of the state?
13:56:58 <sorear> @quote 2.line
13:56:58 <lambdabot2> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
13:57:27 <fasta> PaulAJ: I had another lazy State reference.
13:57:46 <fasta> PaulAJ: I will delete them _all_ first. (qualified imports, got to love them... :?)
13:57:56 <Olathe> @src replicateM
13:57:57 <lambdabot2> replicateM n x = sequence (replicate n x)
13:58:02 <lament> is there a way to get a more descriptive error message than parse error?
13:58:08 <Olathe> > replicateM 5 [1..8]
13:58:10 <lambdabot2>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,1,6],[1,...
13:58:17 <PaulAJ> Heffalump: the situation I've run into in the past with this had lazy fields in a state being repesented as a thunk that kept the previous state alive, and so on backwards.
13:58:20 <Olathe> > sequence (replicate 5 [1..8])
13:58:21 <lambdabot2>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,1,6],[1,...
13:58:29 <fasta> PaulAJ: ok, that helped a little
13:58:36 <sorear> lament: open the file in your text editor and scroll to where the error is listed
13:58:46 <koxinga> sorear:  thanks
13:58:52 <PaulAJ> What is the state argument to StateT type?
13:58:53 <fasta> PaulAJ: It doesn't sky-rocket, but it goes up about twice as slow
13:58:58 <sorear> no problem.
13:59:04 <fasta> PaulAJ: it also goes down sometimes, now.
13:59:05 <lament> sorear: that doesn't give a more descriptive error message :)
13:59:16 <Heffalump> PaulAJ: yeah, that makes sense, it's just that I doubt the (,) in the s -> (a,s) aspect of State would be the responsible one
13:59:18 <PaulAJ> I think we are homing in on the problem.
13:59:25 <koxinga> I still feel like there are a lot of very useful but hidden functions out there
13:59:42 <fasta> PaulAJ: data Foo a b = Foo a b, basically
13:59:51 <yaxu> lament: i find adding type definitions to my functions make the error messages more helpful
14:00:05 <sorear> yaxu: this is a parser error
14:00:22 <PaulAJ> Are you repeatedly changing either the a or b in Foo without using the value?
14:00:26 <yaxu> ah
14:00:29 <Vulpyne> And makes it so you get error messages when you don't understand what your function is doing ,which is good.
14:00:39 <fasta> PaulAJ: be more precise
14:01:02 <fasta> PaulAJ: I do change them both yes.
14:01:09 <jedai> koxinga: Well, it's just the list Monad (pretty useful), and you see replicateM from time to time (to repeat an action a certain number of time) in IO monad
14:01:11 <fasta> PaulAJ: mostly one at a time.
14:01:19 <PaulAJ> I'm wondering if you are putting data in the state that depends on the previous state.  If this doesn't get forced then lazy evaluation makes it a thunk.
14:01:32 <fasta> PaulAJ: I am
14:01:51 <PaulAJ> This thunk will hold the previous version of the data and keep it alive, hence it will accumulate in memory.
14:02:22 <fasta> PaulAJ: can you give a somewhat longer story on that?
14:02:29 <PaulAJ> Try using seq or defining data "Foo a b = Foo !a !b" (I think I have the syntax right.)
14:02:35 <fasta> PaulAJ: I have never seen a clear description of it by anyone.
14:02:40 * PaulAJ goes to check on GHC strictness annotations.
14:02:50 <fasta> PaulAJ: that's the right syntax
14:02:57 <Heffalump> fasta: it's like the way foldl accumulates stuff.
14:03:02 <Heffalump> Do you understand that?
14:03:02 <sjanssen> fasta: you want a description of data strictness?
14:04:09 <sjanssen> "data Foo = Foo !Int" means that every time you construct a Foo, the contents is seq'ed first.  "Foo x" in an expression becomes "x `seq` Foo x"
14:04:21 <fasta> sjanssen: no, not that.
14:04:31 <ivant> > 3.7*2.16
14:04:32 <lambdabot2>  7.992000000000001
14:04:56 <Cale> > 3.7 * 2.16 :: Rational
14:04:57 <fasta> Heffalump: I think I do, but I will say no.
14:04:58 <lambdabot2>  999%125
14:05:04 <PaulAJ> OK, here is how I think of GHC's evaluation model.  When you write something like "x = y + 1" it doesn't actually compute (y+1) immediately.  Instead
14:05:08 <earthy> @type liftM2 (||)
14:05:10 <lambdabot2> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
14:05:21 <earthy> wtf?
14:05:27 <PaulAJ> it creates a "thunk", which you can think of as a closure with no arguments.
14:05:28 <earthy> ah. lambda2. :)
14:05:31 <Heffalump> fasta: ok, so foldl f e (x:xs) = foldl f (f e x) xs
14:05:31 <fasta> It creates pointer to y + 1
14:05:39 <sorear> fasta: consider foldl (+) 0 [1,2,3,4,5,6,7]
14:05:47 <Heffalump> so where we once had e, we now have f e x, completely unevaluated.
14:05:55 <sorear> fasta: foldl (+) (0+1) [2,3,4,5,6,7]
14:05:59 <sorear> fasta: foldl (+) (0+1+2) [3,4,5,6,7]
14:06:01 <PaulAJ> fasta: yes.  The pointer is actually to a data structure that holds a pointer to the "y" value and a pointer to the "+1" function.
14:06:02 <sorear> fasta: foldl (+) (0+1+2+3) [4,5,6,7]
14:06:05 <Heffalump> for a long list, we end up with a long nested set of calls to f, all completely unevaluated
14:06:06 <sorear> fasta: foldl (+) (0+1+2+3+4) [5,6,7]
14:06:07 <PaulAJ> That is the thunk.
14:06:12 <sorear> fasta: foldl (+) (0+1+2+3+4+5) [6,7]
14:06:16 <sorear> fasta: foldl (+) (0+1+2+3+4+5+7) [7]
14:06:26 <fasta> PaulAJ: right, that's what I read on the sole useful page of some Haskell book.
14:06:27 <sorear> fasta: (0+1+2+3+4+5+6+7)
14:06:32 <sorear> fasta: (1+2+3+4+5+6+7)
14:06:34 <Heffalump> now, if you think of your state-monad using code, it is doing basically the same thing
14:06:35 <sorear> fasta: (3+3+4+5+6+7)
14:06:38 <sorear> fasta: (6+4+5+6+7)
14:06:39 <PaulAJ> When something forces the evaluation of x, the thunk gets replaced with the actual value.
14:06:41 <sorear> fasta: (10+5+6+7)
14:06:43 <sorear> fasta: (15+6+7)
14:06:46 <sorear> fasta: (21+7)
14:06:51 <sorear> fasta: 28
14:06:55 <Heffalump> each time you do an operation that modifies the state, you are forming a new unevaluated thing that depends on the old state
14:07:13 <Heffalump> so if you do that repeatedly without doing anything to cause it to be evaluated, you get a very big unevaluated thing
14:07:57 <PaulAJ> fasta: you mentioned that sometimes memory usage drops.  This is probably due to something forcing the state, or part of it, and hence doing all the deferred evaluations.  Then the final thunk gets replaced, and the chain of old values gets GC'd
14:07:59 <Cale> I suppose that's one thing which really takes a while to get your mind around with lazy languages -- in strict languages, expressions are sort of part of the code, but they're not "real", in the sense of existing as values at runtime.
14:08:38 <fasta> sorear: what is the value 0 + 1 + 2 + 3 in thunks?
14:08:43 <fasta> + of
14:08:52 <PaulAJ> So now all you have to do is figure out which bit of code and data is forming the chain of thunks, add a strictness annotation in just the right place, and hey presto, it works!
14:08:55 <fasta> sorear: It's not just one thunk AFAIK
14:08:57 <Cale> fasta: Well, it's (((0+1)+2)+3) really.
14:09:05 <fasta> Right
14:09:09 <sorear> fasta: yeah, I was using associativity
14:09:32 <Cale> and that's actually roughly how it's stored too
14:09:35 <fasta> sorear: but the data structure in memory has only one parsing.
14:09:39 <Heffalump> does the strict StateT just seq the state?
14:09:45 <PaulAJ> GHC profiling has a "retainer" profiling mode that tells you what is causing memory to be retained.  Maybe that will give you the clue.
14:09:52 <Heffalump> PaulAJ: he tried that, it crashed
14:09:56 <Cale> A perfectly acceptable way to think of unevaluated expressions is simply as trees of code.
14:10:14 <sorear> PaulAJ: you apparently aren't subscribed to glasgow-haskell-bugs@haskell.org :)
14:10:14 <Cale> (or really, graphs)
14:10:27 <PaulAJ> sorear: correct
14:10:38 <PaulAJ> Is this a known problem?
14:10:40 <fasta> sorear: you already noticed the bug report?
14:10:43 <sorear> PaulAJ: He's been one of the most prolific reporters recently
14:10:50 * Heffalump wonders where sorear gets time to read everything in the Haskell world ever :-)
14:11:06 <PaulAJ> sec.  Back soon.
14:11:11 <sorear> fasta: yes, I'm subscribed to the bug distribution list
14:11:13 <earthy> sometimes... the haskell libs aren't really nice
14:11:34 <earthy> filter (liftM2 (liftM2 (||))
14:11:34 <earthy>             doesFileExist
14:11:34 <earthy>             doesDirectoryExist
14:11:34 <earthy> )
14:11:40 <earthy> that's ugly. :)
14:12:00 <fasta> earthy: and it probably doesn't work
14:12:02 * PaulAJ gets back
14:12:07 <sjanssen> that doesn't look like it type checks either
14:12:32 <fasta> liftM2 (||) is almost always wrong
14:12:38 <fasta> It doesn't short circuit
14:12:54 <sjanssen> @hoogle doesFileExist
14:12:58 <lambdabot2> Directory.doesFileExist :: FilePath -> IO Bool
14:13:02 <PaulAJ> I also had -hr crash on me, back in 6.4.1 I think it was.  I was also doing things with stacks of monads.
14:13:03 <sorear> Neither action has side effects though.
14:13:08 <earthy> liftM2 (liftM2 (||)) doesFileExist doesDirectoryExist "~/Pictures/kinderen/"
14:13:23 <earthy> returns False on my system in ghci
14:13:23 <PaulAJ> fasta: Do you have an IO at the bottom of this stack?
14:13:46 <earthy> doesn't typecheck inside the filter though. :)
14:13:46 <sjanssen> earthy: 'filter' is the problem in your code -- should be filterM
14:13:48 <sorear> earthy: Do you have a directory named ~ ?
14:13:50 <lament> so the parser error is that i forgot the else part of an if.
14:14:02 <earthy> sorear: nope, sure don't
14:14:07 <earthy> I expect it to return false. ;)
14:14:17 <sorear> ok good ;)
14:14:20 <fasta> PaulAJ: yes
14:14:54 <PaulAJ> fasta: I bet the GHC bug has something to do with lots of chopped-up IO actions.
14:15:00 <glguy> liftM2 (||) can be a little trick because both the left and right hand side are evaluated before the || is performed
14:15:05 <glguy> tricky*
14:15:30 <fasta> PaulAJ: wow, you speak like a wizard ;)
14:15:31 <xerox> sjanssen: too bad data Foo a where Foo :: (Bar a) => a -> Foo a can't be a Functor.
14:15:46 <fasta> PaulAJ: or as someone who knows the compiler internals
14:15:57 <PaulAJ> fasta: No, just someone making a wild guess
14:16:13 <fasta> PaulAJ: it crashes pretty much instantly
14:16:19 <fasta> PaulAJ: so, I am not sure whether that's it
14:16:33 <sfultong> I wonder if anyone has considered implementing STM in hardware...
14:16:50 <PaulAJ> fasta: Yes, that was my experience.  I had something like a ContT StateT IO stack, so I wasn't overly suprised.
14:16:54 <sorear> fasta: GHC doesn't handle IO code very well, and deliberately turns most of the optimizations off to avoid introducing bugs
14:17:21 <sorear> sfultong: then it wouldn't be stm anymore :)
14:17:27 <sorear> sfultong: but I'm pretty sure there has been research
14:17:29 <sfultong> ok... htm
14:17:40 <xerox> sjanssen: GHC wants either (Bar b) in the Foo constructor, which is impossible, or both (Bar a, Bar b) in the constructor, which is also impossible.
14:17:57 <PaulAJ> sfultong: I think back in the 70s or 80s there was a trend for hardware features designed for high level languages
14:18:12 <PaulAJ> Mostly type tags in memory.  But it turned out not to be efficient enough.
14:18:12 <sfultong> like the lisp machine?
14:18:13 <fasta> PaulAJ: I use make_foo_state (error "state not yet defined") (error "main data structure not yet defined")
14:18:29 <fasta> PaulAJ: so, the strictness annotation calls error immediately
14:18:54 <earthy> but mostly I was trying to complain about 'no simple check to see if a filepath is valid'
14:19:18 <fasta> earthy: complaining doesn't help, writing libraries does.
14:19:33 <earthy> fasta: I know :)
14:19:41 <earthy> I just don't know what to name the function
14:19:46 <PaulAJ> Thats a problem.  In the short term try just having a valid but null state of some sort.
14:19:50 <jedai> earthy: doesFileExist isn't sufficient for you
14:20:03 <earthy> jedai: nope, as I need to operate on directories as well
14:20:14 <PaulAJ> In the long term, I'd have a think about your design.  Uninitialised variables are the sort of thing Haskell shouldn't have.
14:20:16 <earthy> that is: my code does sensible things on both
14:20:39 <PaulAJ> But its difficult to advise without knowing more about the code and the problem.
14:20:49 <earthy> but unsensible things on non-existing filepaths
14:21:02 <fasta> PaulAJ: hmm, well, I wanted to avoid the order of arguments problem that runState has.
14:21:03 <sorear> earthy: directories are a kind of file
14:21:09 <sorear> (on POSIX anyway)
14:21:16 <earthy> and according to the docs 'doesFileExist' returns False on directories
14:21:23 <fasta> PaulAJ: imagine runFoo <lots of code> argument
14:21:25 <sorear> that is incredibly dumb
14:21:25 <PaulAJ> fasta: what problem is that?
14:21:32 <earthy> (which I ought to test, but I have formed a habit of trusting the docs)
14:21:33 <sorear> fasta: flip it
14:21:36 <fasta> PaulAJ: one can use flip
14:21:37 <Heffalump> fasta: change your datatype to use a maybe, and make your utility functions that look up in the state check for the Nothing and raise the error there
14:21:44 <jedai> earthy: just tested...
14:21:44 <earthy> The operation doesFileExist returns True if the argument file exists and is not a directory, and False otherwise.
14:22:02 <sorear> dumb dumb dumb...
14:22:07 <earthy> jedai: on what platform, exactly?
14:22:17 <jedai> earthy: Windows XP
14:22:22 <fasta> Isn't adding Maybe adding another level of indirection?
14:22:32 <fasta> I intend to visit these values billions of times
14:22:47 <Heffalump> true
14:22:49 <earthy> right. :)
14:22:55 <earthy> the docs are wrong. :)
14:23:02 <earthy> or GHC is wrong. :)
14:23:05 <oerjan> sfultong: i am pretty sure i saw just the other day something about someone making some hardware supporting transactions
14:23:07 <Heffalump> is there no sensible default value?
14:23:36 <PaulAJ> fasta: Yes, I see.  But I would recommend putting <lots of code> in its own function.  More modular that way.
14:23:50 <sfultong> stm + many small cores could be fun... assuming it could be done without too much difficulty
14:24:32 <PaulAJ> fasta: By the way, I do have the same problem with mapM and mapM_, which is why I often define "forEach = flip mapM".
14:24:41 <fasta> PaulAJ: ok, I will follow the runState initializaton method
14:24:50 <fasta> PaulAJ: I do the same, but mine is in lowercase
14:24:58 <fasta> PaulAJ: and uses mapM_
14:25:01 <bos> PaulAJ: forM and forM_ are in Control.Monad
14:25:16 <fasta> bos: I know, and still I use foreach :)
14:25:19 <PaulAJ> Ahh.  I haven't used it since 6.6 came out.
14:25:21 <bos> uh, ok
14:25:30 <xerox> What's the solution to the problem of having constrained data but wanting to make a functor instance of that data?
14:25:37 <fasta> bos: actually, I have foreach = forM_
14:25:53 <xerox> That is, the problem of not being able to contraint fmap further?
14:26:17 <fasta> Hmm, I am lying again, I use the one from Foldable
14:26:33 <earthy> damn! that text is straight from the report
14:26:39 <earthy> The operation doesFileExist returns True if the argument file exists
14:26:40 <earthy> and is not a directory, and False otherwise.
14:26:41 <earthy> page 226
14:26:46 <geezusfreeek> i hear amd is going to be adding some transactional features in their mainstream chips sometime in the next year or two
14:26:50 <sjanssen> xerox: Functor2?
14:26:55 <jinjing> can Maybe be made an instance of Num?
14:27:02 <xerox> sjanssen: alright.
14:27:12 <sjanssen> xerox: see Oleg's discussion of constrained monads
14:27:13 <geezusfreeek> jinjing, it could, but it wouldn't make much sense to me
14:27:15 <earthy> jinjing: Maybe (a -> b)  would be tricky. :)
14:27:36 <geezusfreeek> err, yeah that too
14:27:42 <PaulAJ> fasta: I've got to go to bed now.  Hope you can figure it out.  If nothing else works, try just sticking seq or $! in likely looking places.
14:27:55 <xerox> sjanssen: will do.
14:27:57 <PaulAJ> Thats what I eventually wound up doing.  It took a while, but I got there eventually.
14:28:03 <PaulAJ> Bye all.
14:29:02 <jinjing> thanks :)
14:29:40 <fasta> PaulAJ: bye
14:29:59 <jedai> earthy: Hum, I just posted a "isValidPath" function on hpaste, it should have been announced, but... the link is http://hpaste.org/2419
14:31:06 <oerjan> !paste
14:31:16 <earthy> heck,  isValidPath :: FilePath -> IO Bool ;  isValidPath = liftM2 (liftM2 (||)) doesFileExist doesDirectoryExist   works...
14:31:29 <jedai> jinjing: Num a => Num (Maybe a) probably
14:31:32 <earthy> that's not the issue. :)
14:31:36 <desp> are there any Lisp fans here?
14:31:53 <earthy> it's just that the standard is dumb!
14:31:54 <jedai> earthy: but it's ugly and must evaluate both predicate
14:32:00 <earthy> jedai: true enough.
14:32:48 <jedai> earthy: Anyway, the whenM I introduced should really be in the standard too, it's useful in many case, you'll find it in other's code too
14:33:00 * earthy has seen it
14:33:08 <byorgey> desp: I like Lisp much more than, say, C++.  Does that make me a fan?
14:33:13 <earthy>     do  when (verbose opts) $ showGreeting
14:33:21 <earthy> directly from the same file. :)
14:33:42 <desp> byorgey: I just don't want to ask this in #lisp. ;) is there any reason why you'd prefer to code in Lisp instead of Haskell?
14:34:06 <jinjing>   
14:34:06 <jinjing> class Testable a where
14:34:07 <jinjing>   test :: a -> a -> Bool
14:34:07 <jinjing> instance Testable Maybe where
14:34:07 <jinjing>   test Nothing Nothing = True
14:34:28 <jedai> earthy: when is useful, but it's not whenM, what are you speaking about ?
14:34:50 <byorgey> desp: hm, can't think of any off the top of my head.
14:34:54 <jinjing> seems the compiler doesn't like it
14:35:00 <earthy> sorry, I'm not awake anymore
14:35:00 <earthy> :)
14:35:02 <byorgey> jinjing: Maybe by itself is not a type
14:35:17 <alar> @where haskell-mode.el
14:35:18 <lambdabot2> I know nothing about haskell-mode.el.
14:35:19 <jedai> jinjing: Maybe isn't a type, Maybe a is
14:35:21 <byorgey> jinjing: you need something like instance (Testable a) => Testable (Maybe a)
14:35:39 <alar> @google haskell-mode.el
14:35:41 <lambdabot2> http://haskell.org/haskell-mode/
14:35:41 <lambdabot2> Title: Haskell Mode for Emacs
14:35:51 <earthy> but, uhm, does (||) have to evaluate both arguments?
14:36:18 <jedai> earthy: No, but liftM2 (||) will evaluate both before applying ||
14:36:20 <desp> byorgey: I'm just wondering if I'm missing out on some enlightenment by not really grokking Lisp (only having written some coursework programs)
14:36:48 <earthy> ah, right
14:36:53 <earthy> it has to
14:37:01 <oerjan> @src filterM
14:37:01 <lambdabot2> Source not found. Where did you learn to type?
14:37:07 <oerjan> :t filterM
14:37:09 <lambdabot2> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:37:14 <byorgey> desp: not really, IMO, although I'm sure you could find people to disagree with me =)
14:37:34 <shapr> ibid: Loop in a subshell? How?
14:37:58 <desp> byorgey: looks like nobody here ;)
14:38:00 <earthy> @src liftM2
14:38:00 <lambdabot2> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:38:17 * earthy ponders
14:38:21 <earthy> nope, doesn't have to
14:38:36 <earthy> there's *no* forced order there
14:38:39 <jedai> earthy: In IO Monad it has to, in other monad it won't
14:38:45 <earthy> it's just that it just happens to in IO
14:38:54 <earthy> which kinda sucks
14:39:19 <earthy> otoh, in  (->) a  it don't matter
14:39:24 <byorgey> jinjing: by the way, just so you know we usually try not to paste code in the channel directly, so we have a site for pasting code: hpaste.org
14:39:31 <jedai> earthy: It will be true in other monads too, IO isn't the only one to enforce order of evaluation
14:40:03 <jedai> earthy: State.Strict for example I think
14:40:10 * earthy nods
14:40:28 <jinjing> byorgey, thanks
14:41:22 <byorgey> desp: I will say, however, that Paul Graham's "ANSI Common Lisp" is an excellent read, it's just that all the epiphanies I had while reading it have since been superseded by Haskell epiphanies
14:42:19 <desp> out of print and I've been unable to locate an ebook :(
14:42:38 <byorgey> really?  huh, I'm surprised
14:43:04 <desp> hm, wait
14:43:13 <jmelesky> desp: Lisp is better than any other language for realizing the coolness that is syntactic abstraction. however, it's debatable whether you need to have that realization.
14:43:18 <byorgey> desp: amazon seems to have it
14:43:18 <desp> I haven't checked for a while, looks like it back in print :)
14:43:23 <desp> it's*
14:43:28 <byorgey> yup =)
14:44:25 <jmelesky> personally, i find syntactic abstraction is much harder to use when your team size is greater than one
14:45:10 <desp> jmelesky: I've heard about template Haskell, but I haven't used it yet. do you suppose that it could be a contender here?
14:46:00 <sorear> not at all
14:46:20 <jmelesky> desp: i haven't worked with template haskell much, but it seems to be a very different approach to the same type of problem.
14:46:35 <newsham> its easy to write syntax rewriters when your syntax is just parenthesized lists.
14:46:44 <desp> Liskell :)
14:46:58 <newsham> of course its hard to write syntax when your syntax is just parenthesized lists
14:47:03 <newsham> and to read
14:47:52 <jmelesky> newsham: that's the thing, really. it's easy to transform abstract syntax trees. so if your language's syntax is just abstract syntax trees (like lisp), then macros are peachy keen.
14:48:26 <desp> sorear: could you say a few more words?
14:48:30 <newsham> lucky for us, macros arent as important in a lazy language
14:48:57 <newsham> since we can define control flow structures without worrying about args getting evaluated
14:49:17 <sorear> desp: TH combines a fraction of the power of Lisp macros with all the beauty and elegance of C++ templates.
14:49:18 <newsham> myif p t e = if p then t else e
14:49:26 <earthy> jmelesky: depends on the abstract syntax trees
14:49:27 <newsham> sorear++
14:49:28 <desp> ahh.
14:49:43 <jmelesky> newsham: it also helps that haskell encourages higher-order-ness so much
14:49:49 <earthy> jmelesky: some are quite a bit harder to transform than others
14:49:51 <Maddas> newsham: To be fair, I doubt that implementing things like that is one of the most common uses of macros.
14:50:02 <earthy> sorear: *snort*
14:50:09 <newsham> maddas: thats the original purpose macros were implemented in lisp, no?
14:50:16 <newsham> to build control flow structures from a small core language?
14:50:21 <desp> @remember sorear TH combines a fraction of the power of Lisp macros with all the beauty and elegance of C++ templates.
14:50:21 <Maddas> newsham: I doubt it.
14:50:21 <lambdabot2> Done.
14:50:32 <newsham> maddas: thats my understanding.
14:50:42 <jmelesky> earthy: i think certain transformations are more difficult, yes (hence the difficulty in writing optimizing compilers)
14:50:54 * Maddas doesn't really know anything about the original lisp constructs, to be honest
14:51:20 <newsham> maddas: imagine you only have "if" in lisp, and you want to build "while"
14:51:45 <earthy> jmelesky: oh, that's not even what I meant. a large, baroque syntax tree (such as the one for the haskell syntax in Language.Haskell) is harder to deal with than a simple one (such as for lisp)
14:51:56 <Maddas> newsham: Yes, I know that it's possible. But you introduce syntax there, you wouldn't do it as a function that doesn't evaluate its arguments :-)
14:52:21 <jmelesky> earthy: ah, but when you parse it into an abstract syntax tree, it all looks like lisp anyhow. it's just the base syntax that's the issue.
14:52:42 <earthy> uh, wha?
14:53:05 <earthy> should I read 'concrete syntax' where you just said 'base syntax'?
14:53:24 <newsham> "In contrast to most other major programming languages, Lisp allows the programmer to implement control structures using the language itself. Several control structures are implemented as Lisp macros, and can even be macroexpanded by the programmer who wants to know how they work."
14:53:32 <jmelesky> earthy: yeah, sorry about that
14:53:51 <earthy> okay, yeah, Language.Haskell already puts you up away from concrete syntax
14:54:07 <earthy> however, it is a large tree structure, with many types in that tree
14:54:13 <Maddas> newsham: Yes, it allows it, I've never disputed that. I'm just saying that this is not what most programmers use it for.
14:54:18 <earthy> walking it is decidedly boilarplate-prone
14:54:24 <newsham> *nod*
14:56:33 <Maddas> newsham: sorry if I'm being a nitpick :)
14:58:33 <Maddas> My attempts to pin down a nicer example of what I meant have been foiled by my unreliable internet connection.
15:11:58 <lament> damn, curses is so inefficient
15:14:53 <earthy> @src filter
15:14:54 <lambdabot2> filter _ []     = []
15:14:54 <lambdabot2> filter p (x:xs)
15:14:54 <lambdabot2>     | p x       = x : filter p xs
15:14:54 <lambdabot2>     | otherwise = filter p xs
15:15:45 <shapr> w00, it's HAppS 0.9.1 time!
15:15:53 * shapr parties like it's 1971
15:15:57 <ddarius> Is it FLM time?
15:16:05 <shapr> ddarius: Tonight, hopefully.
15:16:31 <byorgey> FLM?
15:16:36 * ddarius realizes that tonight for shapr = tonight for him.
15:16:38 <shapr> Since I was born in 1971, I think that means taking a nap...
15:16:48 * ddarius could go for a nap.
15:16:53 <shapr> heh, me too
15:16:57 <earthy> heh
15:17:02 <byorgey> Final Limit Monad?  Functional Language Maven?
15:17:11 * earthy should just go for a good night's sleep. :P
15:17:14 <shapr> Fermat's Last Margin!
15:17:21 <byorgey> oh, duh, I knew that =)
15:17:25 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
15:17:40 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
15:17:52 <byorgey> you're copying & pasting that, aren't you =)
15:17:58 <shapr> Why yes, I am!
15:18:00 <fasta> shapr: it's not vapourware anymore?
15:18:00 <ddarius> shapr: Is this the contents of the README?
15:18:02 <byorgey> hehe
15:18:32 <shapr> fasta: Actually, it's vaporware until I release it, but it mostly works if that's what you mean.
15:18:55 <Heffalump> so it's neither released nor online yet?
15:19:18 * Heffalump want :-)
15:19:47 <shapr> Heffalump: Hopefully I'll have working sources released tonight.
15:20:11 <Maddas> @yow
15:20:11 <lambdabot2> One FISHWICH coming up!!
15:20:20 <shapr> Is lambdabot down again?
15:20:27 <fasta> shapr: oh, I don't care about it that much. Nice that you did what you wanted to do.
15:20:32 <Maddas> Hmm?
15:20:39 <Maddas> The @yow seemed to work, didn't it :-)
15:20:43 <Maddas> Hi, by the way!
15:20:52 <ddarius> lambdabot2 /= lambdabot
15:21:13 <shapr> fasta: :-)
15:21:28 <Heffalump> shapr: nice
15:21:39 <ddarius> fasta is an automaton and never does what it wants to do.
15:21:52 <Maddas> shapr: great!
15:22:17 * Maddas pokes xerox
15:22:39 <ddarius> @seen xerox
15:22:40 <lambdabot2> xerox is in #haskell and #haskell.it. I last heard xerox speak 9m 50s ago.
15:23:02 <ddarius> @seen lambdabot2
15:23:02 <lambdabot2> Yes, I'm here. I'm in #haskell, #cdk, #bioclipse, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #haskell.fr,
15:23:02 <lambdabot2>  #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru and #haskell.se
15:23:20 * xerox pokes back Maddas 
15:23:24 <ddarius> @quote
15:23:24 <lambdabot2> metaperl says: I never thought anyone could be on IRC as much as you and look that good
15:23:44 <earthy> @seen lambdabot
15:23:45 <lambdabot2> lambdabot is in #haskell. I don't know when lambdabot last spoke.
15:24:13 <bwx> is there something like Data.Set, but where you can have more then one of the same element?
15:24:20 <alar> haskell.ru? sounds interexting
15:24:20 <lambdabot2> alar: You have 3 new messages. '/msg lambdabot2 @messages' to read them.
15:24:24 <earthy> you mean a list, bwx? :)
15:24:33 <Heffalump> the tehcnical name for that is a bag. Not sure if there's any standard library for it.
15:24:37 <ddarius> earthy an ordered list
15:24:37 <Heffalump> earthy: lists are ordered
15:24:42 * earthy knows
15:24:43 <TSC> bmx: Map a Int
15:24:45 <bwx> earthy: yeah, but where the order is not important, and fast element membership testing is needed
15:24:54 <TSC> (As in Data.Map)
15:25:12 <bwx> TSC: hm...
15:25:29 <earthy> Data.Map a Int would be the second attempt indeed, but that requires Ord on a
15:25:43 <bwx> Ord on a is ok
15:25:45 <TSC> How else would you get fast membership testingL
15:25:48 <oerjan> Data.Set also requires that
15:25:58 <earthy> or Data.Map a Integer if you want to put large amounts in your bags
15:26:05 <TSC> Then you can have "numberOfOccurrences = Data.Map.findWithDefault 0 ..."
15:27:51 <bwx> let's say i have a (Data.Set [Int]), and i know that all of the integers in the set are totally unique. what is the best way to remove the integer x from the set(if it exists)?
15:28:11 <earthy> ?
15:28:23 <oerjan> bwx: do you mean Data.Set Int ?
15:28:26 <bwx> f :: Int -> Data.Set [Int] -> Data.Set [Int]
15:28:34 <mauke> that doesn't make sense
15:28:37 <earthy> that's going to be hard
15:28:44 <byorgey> bwx: check out the Edison library, I think that has what you're looking for
15:28:52 <earthy> since you have no way of getting from the Int into the [Int] that is in the set
15:28:52 <Igloo> Set.map (delete x), give or take argument order
15:28:54 <byorgey> @where edison
15:28:54 <lambdabot2> http://www.eecs.tufts.edu/~rdocki01/edison.html
15:29:17 * earthy really should go to bed :P
15:29:21 <bwx> Igloo: how can i have that stop traversing after it succesfully finds x?
15:30:14 <oerjan> bwx: you might want to do something like Data.Map Int (Data.Set Int)
15:30:23 <byorgey> @localtime earthy
15:30:30 <oerjan> where each Int maps to the set containing it
15:30:31 <earthy> 00:30
15:30:34 <Igloo> The best way is to bat your paw at the factor of 2  :-)
15:30:56 * byorgey shoos earthy towards bed
15:31:14 <oerjan> however then you need to change each int in the set. hm.
15:31:27 <bwx> oerjan: well, each element of the set has some more data in addition to the list of Ints
15:33:35 <oerjan> bwx: i have a feeling that that requires unique id's to be made efficient
15:34:03 <oerjan> and a map from the ints to the elements
15:34:06 <oerjan> (by id)
15:35:42 <oerjan> as well as a map from id to element
15:37:10 <sorear> shapr: yup, JaffaCake broke her by accident and dons hasn't awoken to clean up
15:38:02 <Heffalump> what did JaffaCake do?
15:38:14 <sorear> lambdabot2: @part #haskell
15:38:22 <sorear> 07:16 < JaffaCake> http://haskell.org
15:38:44 <sorear> url plugin timeout -> instadeath
15:39:02 <sorear> bad way to check if sites are up :(
15:42:28 <lament> isn't haskell.org up?
15:43:46 <koxinga> it is
15:43:47 <sorear> it isn't 8 hours ago anymore :)
15:44:03 <sorear> @users
15:44:04 <lambdabot2> Maximum users seen in #haskell: 411, currently: 374 (91.0%), active: 13 (3.5%)
15:44:24 <oerjan> !
15:45:10 <dcoutts> @seen dons
15:45:11 <lambdabot2> dons is in #haskell and #haskell-hac07. I last heard dons speak 1d 21h 50m 33s ago.
15:45:42 <sorear> yeez, hac07 is long over
15:45:48 <sorear> @part #haskell-hac07
15:46:44 <sorear> uh, no, Oct 07
15:46:49 <sorear> @join #haskell-hac07
15:47:49 <shapr> sorear: Can't the url plugin get a timeout?
15:48:14 <sorear> shapr: All plugins get timeouts.  Besides, they run asynchronously.
15:48:45 <sorear> shapr: dons keeps muttering something about FFI nonsense
15:48:45 <lament> so why should this kill lambdabot?
15:48:50 <sorear> it shouldn't.
15:48:52 <lament> ah.
15:49:12 <lament> unsafe FFI call?
15:51:04 <sorear> ask dons
15:51:13 <sorear> he seems to be the one interested in this
15:53:51 <lament> i was just reading about unsafe ffi calls blocking all threads
15:54:32 <bwx> i am also confused by this. it seems like a major flaw in the GHC threading model
15:55:06 <Vulpyne> Isn't there a flag you can use to fix that?
15:55:30 <bwx> there is -threaded, but I'm not sure that it solves the problem completely
15:55:46 <lament> no, without -threaded all ffi calls block all threads
15:55:52 <lament> with -threaded, only unsafe ones
15:55:58 <Vulpyne> Ah.
15:56:16 <lament> i don't know what unsafe actually means :)
15:56:59 <mauke> I think it means "this function doesn't block and doesn't call back into haskell"
15:57:01 <bwx> but even with -threaded, the total number of threads that can be running is limited to the number of CPUs, so if you have lots of threads doing FFI calls, then they will end up blocking
15:57:44 <lament> bwx: but then they're system threads, and can be preempted by the OS scheduler
15:58:40 <lament> i would hope the url plugin does not block unix :)
15:58:42 <bwx> that's not what i understand
15:59:14 <Saizan> bwx you can use more OS threads than your numbers of cores
15:59:17 <sfultong> I don't see why all forkIO threads couldn't be in one forkOS thread, and all ffi calls be in their own forkOS calls... shouldn't that avoid any deadlocks?
15:59:48 <sorear> sfultong: you misunderstand forkOS
15:59:54 <sfultong> oh
16:00:26 <bwx> saizan: yeah, but then it's just a lot of guesswork on how many threads to use, and there are still no guarantees. why not have an additional "fork" function that actually forks a new real OS thread?
16:00:33 <sorear> GHC contains NPUS "capabilities" and an arbitrary number of "safe call workers"
16:00:55 <sorear> Each capabiltity runs Haskell code, preemptively scheduled inside GHC.
16:01:03 <sorear> The safe call workers form a thread pool.
16:01:21 <sorear> Unsafe foreign calls generate inline machine call instructions.
16:01:23 <sorear> Very fast.
16:01:25 <sorear> But -
16:01:38 <sorear> If the call blocks, that entire capability is unusable.
16:01:43 <sjanssen> bwx: there is forkOS, which creates a new OS thread bound to a Haskell thread
16:01:51 <sjanssen> but forkOS doesn't scale
16:02:17 <sorear> Safe calls allocate new threads from the thread pool, run the function, and only block one *haskell* thread.
16:02:22 <sorear> This is very slow.
16:02:35 <sorear> forkOS has nothing whatsoever to do with parallelism.
16:02:44 <bwx> sjanssen: so if i call forkOS 100 times, then i will have 100 OS threads, even if i run with -n1 ?
16:02:53 <sjanssen> bwx: that is correct
16:03:02 <sorear> forkOS creates a new thread and a new OS thread, and marks the OS thread as *bound* to the Haskell thread.
16:03:16 <sorear> The Haskell code does NOT run in the new OS thread!!
16:03:17 <sjanssen> you almost never want to use forkOS
16:03:23 <lament> sorear: ohhhhhhhhhhhhhh
16:03:28 <sjanssen> sorear: oh, it doesn't?  I didn't know that
16:03:35 <sorear> The *only* thing the new thread is used for is safe foreign calls.
16:03:56 <sorear> The purpose of this is to support libraries like OpenGL that use thread-local storage.
16:04:11 <sfultong> ok, I think I get it now
16:04:40 <bwx> sorear: so in between OpenGL calls, the OS thread is idle?
16:04:44 <sorear> yes.
16:04:55 <sjanssen> sorear: is this in the commentary somewhere?
16:05:14 <sorear> I hope so
16:05:47 <sjanssen> sorear: well, where else would you learn it? :P
16:06:27 <lament> in some research paper!
16:06:28 <lament> :)
16:07:26 <sjanssen> yes, I'm sure this is all well covered in the SMP Haskell paper
16:09:39 <sjanssen> awww, ghc trac is down
16:10:11 <sfultong> sorear: so is there anyway to preempt a ffi call in haskell?
16:10:26 <profmakx> its asleep. 1:15 am here
16:10:35 <newsham> if you check out ghc from darcs you get devel (6.7) branch?
16:10:39 <Igloo> Grr. Does anyone know if the trac worked since the earlier haskell.org problems?
16:10:40 <sorear> sfultong: exitImmediately :)
16:10:49 <Igloo> Oh, it's working now
16:10:49 <sfultong> heh... oh dear
16:11:04 <Igloo> newsham: If you get the HEAD you do, yes
16:12:16 <newsham> oh, hey, "Igloo", you're the guy in all those ghctrac reports :)
16:12:22 <newsham> the doc just says "darcs get http://darcs.haskell.org/ghc/"
16:12:28 <lambdabot2> Title: Index of /ghc
16:12:38 <newsham> igloo: do you know off hand if the 64-bit linker stuff has been resolved yet?
16:13:06 <Igloo> newsham: Which stuff?
16:13:14 <Igloo> newsham: That's the HEAD
16:13:41 <newsham> there were some hacks to work on linux (MAP_32BIT) which werent compatible with other systems (like FreeBSD)
16:13:43 <Igloo> <- As seen on TV! (well, trac, anyway)
16:13:58 <newsham> igloo: I think you also fixed some ghc bug on my box a while ago too
16:14:08 <shapr> yay!
16:14:21 <Igloo> Gregory is working on tidying up his fixes for FreeBSD
16:14:51 <newsham> the fixes he had so far were just for "ghc" though, no?  no ghci support (at least in the bins he put up)
16:16:30 <Igloo> I'm not sure
16:17:27 <newsham> oh well, pulling HEAD, seeing how far it gets.
16:17:44 <newsham> seems like theres a version running on openbsd/amd64, which I would think would imply proper functionality on freebsd/amd64
16:17:51 <sorear> @remember Igloo * fasta feels proud: some piece of code is now IO bound  <Igloo> That's easy. You just have to make a big enough space leak that you go into swap :)
16:17:51 <lambdabot2> Done.
16:23:24 <jbalint> is there any way to make a type the refers to itself, like type X = (Int, (Bool -> X))
16:23:38 <sjanssen> jbalint: you can use a newtype to break the recursion
16:23:49 <sjanssen> newtype X = X (Int, Bool -> X)
16:24:07 <jbalint> Ok, i will try that. Thanks sjanssen
16:36:00 <puusorsa> http://www.spacedaily.com/reports/University_Of_Minnesota_Astronomers_Find_Gaping_Hole_In_The_Universe_999.html
16:36:03 <lambdabot2> Title: University Of Minnesota Astronomers Find Gaping Hole In The Universe, http://tinyurl.com/2fgwj2
16:36:40 <jinjing> hmm, is that lambdabot a real bot?
16:36:49 <sorear> why wouldn't she be?
16:37:03 <puusorsa> she's imaginary
16:37:07 <lament> no, it's just a bot emulator.
16:37:08 <puusorsa> try rotating her 90 degrees
16:37:21 <sorear> @version
16:37:21 <lambdabot2> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
16:37:22 <lambdabot2> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:37:26 <sorear> ^^^ source code
16:38:24 <jinjing> so everytime it's mentioned, it gives out the soruce ...
16:39:01 <kpreid> jinjing: I'm curious. What would you consider not a real bot?
16:39:03 <puusorsa> http://img511.imageshack.us/img511/4841/bioshockyl7.jpg
16:40:40 <jinjing> like that :]
16:40:52 <bparkis> in haskell can you create an alias for a function type, like "alias SequenceF = Int -> a"?
16:40:54 <kpreid> Like what?
16:41:03 <puusorsa> bioshockykl!
16:41:07 <kpreid> bparkis: use 'type', just like for any other type?
16:41:08 <mauke> bparkis: yes, "type"
16:41:11 <bparkis> ah
16:42:09 <jinjing> is there a way to overload (+) without deriving from Num?
16:42:29 <lament> no :(
16:42:32 <mauke> no, (+) is a method in Num
16:43:31 <oerjan> bparkis: except you cannot have a on the right side without having it on the left, because it's a type variable
16:43:31 <jinjing> that's not good :(
16:43:37 <bwx> you can hide the prelude definition of (+) and then define your own
16:44:04 <kpreid> and with undecidable instances you can make your (+) use Num if possible
16:45:41 <desp> @pl f g h x = g x && h x
16:45:42 <lambdabot2> f = liftM2 (&&)
16:45:56 <oerjan> you can also cheat by making a Num where all the definitions except + are left out, i think
16:46:40 <oerjan> however you then get run time errors instead of static errors if you use any of the others anyway
16:47:04 * sfultong doesn't understand the desirability of operator overloading
16:47:30 <kpreid> @pl f (&&) (&&&&) x = ((x &&), (x &&&&))
16:47:31 <lambdabot2> (line 1, column 17):
16:47:31 <lambdabot2> unexpected "="
16:47:31 <lambdabot2> expecting variable, "(", operator or end of input
16:47:31 <jinjing> I"m writing a Vector type, but signum and abs :: a -> a doesn't really make sense
16:47:39 <jedai> sfultong: Operator overloading make sense when the semantic and the propriety of the operator stay the same
16:47:46 <kpreid> @pl f (&&) (&&&&) x = ((&&) x, (&&&&) x)
16:47:46 <lambdabot2> (line 1, column 17):
16:47:46 <lambdabot2> unexpected "="
16:47:46 <lambdabot2> expecting variable, "(", operator or end of input
16:47:59 <kpreid> @pl f x = ((&&) x, (&&&&) x)
16:47:59 <lambdabot2> f = liftM2 (,) (&&) (&&&&)
16:48:04 <kpreid> aw
16:48:07 <puusorsa> it's nice to be able to use tie-fighter operator
16:48:18 <puusorsa> |-|
16:48:23 <kpreid> I wanted f = (&&) &&& (&&&&)
16:48:43 <sfultong> :t (&&&&)
16:48:45 <lambdabot2> Not in scope: `&&&&'
16:48:54 <oerjan> kpreid: @pl doesn't understand arrows
16:48:56 <puusorsa> or xwings, >o<
16:48:59 <jedai> :t &&&
16:49:01 <lambdabot2> parse error on input `&&&'
16:49:04 <kpreid> I thought it used arrow combinators
16:49:05 <jedai> :t (&&&)
16:49:07 <lambdabot2> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:53:00 <byorgey> jinjing: you have two options: one is to give abs and signum dummy definitions (i.e. abs = undefined) and don't use them.
16:53:27 <desp> Ruby 1.9 -- now with Fiber!
16:53:35 <byorgey> jinjing: the other option is to create special vector arithmetic operators (like +. -. or something) and don't make a Num instance.
16:56:24 <jinjing> byorgey: for the second option, does it  mean defining (+) inside vector class or an external function like plusVector outside the class?
16:57:38 <byorgey> jinjing: I mean an external function like plusVector, except you don't have to give it such a long name, you could define your own operator like (+.) if you wanted
16:57:56 <byorgey> v1 (+.) v2 = ...
16:58:04 <byorgey> erm, v1 +. v2 =
16:58:51 <jinjing> thanks byorgey :) that makes a lot sense
16:59:00 <byorgey> jinjing: you're welcome =)
17:02:21 <desp> @bot
17:02:22 <lambdabot2> :)
17:02:58 <pgavin> @seen dcoutts
17:02:58 <lambdabot2> dcoutts is in #haskell. I last heard dcoutts speak 1h 17m 48s ago.
17:03:01 <jinjing> @bot
17:03:01 <lambdabot2> :)
17:03:03 <desp> she doesn't like private messages?
17:03:12 <mauke> NO U
17:03:12 <desp> @pl ((\x -> flashget ++ x ++ " C:\\\\Downloads\\\\").show)
17:03:12 <lambdabot2> (flashget ++) . (++ " C:\\\\Downloads\\\\") . show
17:03:34 <oerjan> not registered
17:03:49 <jinjing> @world of botcraft
17:03:51 <lambdabot2> No match for "of".
17:03:52 <lambdabot2> No match for "botcraft".
17:04:11 <pgavin> @list
17:04:12 <lambdabot2> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:04:18 <oerjan> @worl
17:04:30 <oerjan> @wor
17:04:51 <oerjan> @world of whatever
17:04:53 <lambdabot2> No match for "of".
17:04:53 <lambdabot2> No match for "whatever".
17:05:09 <oerjan> @orl of
17:05:09 <lambdabot2> I know nothing about of.
17:05:23 <oerjan> @rl of
17:05:23 <lambdabot2> Maybe you meant: pl rc url
17:05:52 <oerjan> @help url
17:05:52 <lambdabot2> url <key>. Return element associated with key
17:06:02 <oerjan> @url report
17:06:02 <lambdabot2> http://www.haskell.org/onlinereport/
17:06:07 <oerjan> @world report
17:06:08 <lambdabot2> No match for "report".
17:06:38 <oerjan> @wor of
17:06:39 <lambdabot2> No match for "of".
17:06:48 <oerjan> @wo
17:07:06 <oerjan> @help world
17:07:06 <lambdabot2> help <command>. Ask for help for <command>. Try 'list' for all commands
17:07:23 <jbalint> how would i go about calling an IO action in the predicate for the partition function?
17:07:34 <mauke> @hoogle partition
17:07:34 <lambdabot2> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
17:07:34 <lambdabot2> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
17:07:34 <lambdabot2> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
17:08:30 <mauke> you wouldn't use partition
17:08:41 <jbalint> Ok
17:09:28 <oerjan> well... you might
17:10:15 <oerjan> start with mapM pred list
17:10:55 <jbalint> not following
17:11:53 <pgavin> you'd call the pred on all items in the list
17:12:07 <oerjan> partition snd =<< liftM (zip list) (mapM pred list)
17:12:09 <pgavin> then call partition
17:12:29 <oerjan> er...
17:12:42 <mauke> :t \pred -> mapM (\x -> pred x >>= \c -> return ((if c then Left else Right) x))
17:12:44 <lambdabot2> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [Either a a]
17:12:49 <oerjan> :t ***
17:12:51 <lambdabot2> parse error on input `***'
17:12:54 <pgavin> @pl partition snd =<< liftM (zip list) (mapM pred list)
17:12:54 <lambdabot2> partition snd =<< fmap (zip list) (mapM pred list)
17:12:56 <oerjan> :t (***)
17:12:58 <lambdabot2> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:14:22 <jbalint> i kind of see. i think ill figure it out. thanks
17:14:35 <TSC> GHCi's brain exploded ):
17:14:37 <oerjan> :t flip liftM (mapM pred list) $ (fst *** fst) . partition snd . zip list
17:14:38 <lambdabot2> Not in scope: `list'
17:14:39 <lambdabot2>  
17:14:39 <lambdabot2> <interactive>:1:66: Not in scope: `list'
17:14:51 <oerjan> :t \pred list -> flip liftM (mapM pred list) $ (fst *** fst) . partition snd . zip list
17:14:52 <lambdabot2>     Couldn't match expected type `(a, b)'
17:14:53 <lambdabot2>            against inferred type `[(a1, Bool)]'
17:15:09 <oerjan> :t \pred list -> flip liftM (mapM pred list) $ map (fst *** fst) . partition snd . zip list
17:15:11 <lambdabot2>     Couldn't match expected type `[((a, b), (a1, b1))]'
17:15:11 <lambdabot2>            against inferred type `([(a2, Bool)], [(a2, Bool)])'
17:15:27 <pgavin> wouldn't it be easiest just to use primitive recursion?
17:15:37 <oerjan> :t \pred list -> flip liftM (mapM pred list) $ (map fst *** map fst) . partition snd . zip list
17:15:39 <lambdabot2> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m ([a], [a])
17:15:39 <pgavin> not to mention more straightforward?
17:15:46 <oerjan> probably :D
17:15:58 <pgavin> lol :)
17:16:44 <byorgey> aw, where's the fun in that? ;)
17:20:02 <jedai> :t \p l -> (map fst *** map fst) $ partition snd =<< liftM (zip l) (mapM p l)
17:20:04 <lambdabot2> forall a. (Monad ((,) [(a, Bool)])) => (a -> ([(a, Bool)], Bool)) -> [a] -> ([a], [a])
17:21:06 <oerjan> you need the liftM around the first part too
17:21:21 <jedai> :t \p l -> liftM (map fst *** map fst) $ partition snd =<< liftM (zip l) (mapM p l)
17:21:23 <lambdabot2>     Couldn't match expected type `([(a, b)], [(a1, b1)])'
17:21:23 <lambdabot2>            against inferred type `[(a2, Bool)]'
17:22:03 <oerjan> :t \p l -> liftM ((map fst *** map fst) . partition snd . zip l) (mapM p l)
17:22:04 <lambdabot2> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m ([a], [a])
17:22:43 <jedai> oerjan: Ok ! ^^ I think it's the one I prefer
17:22:57 <Mr_Awesome> haskell is insane...
17:23:30 <LoganCapaldo_> You may be right, Haskell may be crazy, but it just might be a lunatic you're looking for
17:23:41 <oerjan> it actually turned out pretty clean that way
17:24:03 <kpreid> Mr_Awesome: don't let the deep end of pointfreeness scare you off
17:24:03 <Saizan> join (***) $ map fst!
17:24:18 <lament> yeah, you can write unreadable code in any language
17:24:36 <jedai> Mr_Awesome: I find this very pretty in fact, it expressed a complex notion in a straightforward way
17:24:38 <byorgey> ah, but can you write unreadable, *elegant* code in any language?
17:25:26 <SamB> in whitespace, all code is unreadable
17:25:32 <jedai> lament: Well I have difficulty "writing" this kind of code, but with type annotation, I find it quite readable ^^
17:25:37 <dhpeterson> Mr_Awesome: i agree - but it's very interesting
17:25:55 <Maddas> jedai: straightforward as in 'fits into one straight line', yes :-P
17:25:55 <dhpeterson> i'm a bit of a haskell newbie i must admit
17:26:17 <Mr_Awesome> that certainly wasnt an insult
17:26:20 <dhpeterson> :)
17:26:28 <jedai> Maddas: No, as in reads right to left, composing functions :)
17:27:03 <SamB> jedai: more like straight backward
17:27:16 <SamB> unless your native language is hebrew
17:27:29 <jedai> SamB: Straightbackward... ^^
17:28:03 <jedai> SamB: Nope, but I read mangas...
17:28:11 <SamB> hehe
17:28:12 <Maddas> yeah, Japanese will do as well
17:28:25 <SamB> they write from top to bottom actually
17:28:35 <SamB> then right to left
17:28:38 <lament> they write in lots of different directions
17:28:40 <SamB> afaict
17:29:16 <jedai> Japanese is much more crazy than Haskell (I find it quite harder to learn anyway) ;-)
17:29:24 <SamB> it's hard to say when I can't read it, but I can't imagine they would have so few characters on a row otherwise
17:29:25 <Maddas_> SamB: sounds about right
17:29:31 <Saizan> the pages (and baloons) go from right to left
17:29:39 <SamB> quite so
17:29:44 <dons> ?users
17:29:44 <lambdabot2> Maximum users seen in #haskell: 411, currently: 366 (89.1%), active: 17 (4.6%)
17:29:48 <dons> hmm
17:29:57 <SamB> mixed with top to bottom
17:30:02 <SamB> and sometimes they do wierd things
17:30:03 <dons> sorear: url module failed in contextual handler: IRCRaised thread killed
17:30:11 <jedai> SamB: You're right, this is the traditional order  (top to bottom then right to left) but they also use the occidental order
17:30:12 <SamB> but then english-language comics do too
17:30:19 <dons> lambdabot2: @part #haskell
17:30:42 <SamB> yes I notice they seem to do it differently on computer displays
17:30:50 <sfultong> ah, dons is back to fix lambdabot
17:31:36 <desp> @bot
17:31:36 <lambdabot> :)
17:35:09 <dhpeterson> i am very confused by monads!
17:35:18 <dhpeterson> can someone explain these 2 cases:
17:35:30 <dhpeterson> replicate 10 ['a']
17:35:37 <dhpeterson> returns ... ["a","a","a", ...]
17:35:39 <dhpeterson> but
17:35:47 <Heffalump> ['a'] is the same as "a"
17:35:54 <dhpeterson> liftM (replicate 10) ['a']
17:36:09 <dhpeterson> returns ... ["aaaaa..."]
17:36:22 <dhpeterson> i'm trying to understand what liftM does
17:36:25 <dhpeterson> :)
17:36:25 <Heffalump> ok, so there you are lifting the function (replicate 10) into the list monad
17:36:30 <dhpeterson> yes
17:36:40 <dhpeterson> and i am trying to understand exactly what those words mean :)
17:36:47 <Heffalump> in the list monad, each element of a list is treated as a possible outcome of the computation
17:36:49 <dhpeterson> i'm a bit like a child with a gun atm!
17:37:04 <Heffalump> so ['a'] is saying "the only result is 'a'"
17:37:12 <dhpeterson> ok
17:37:13 <twanvl> liftM (replicate 10) ['a']  ==  map (replicate 10) ['a'] == [replicate 10 'a']
17:37:25 <SamB> dhpeterson: what? someone handed you an unsafePerformIO already?
17:37:29 * SamB takes it away
17:37:31 <dhpeterson> heh
17:37:33 <dhpeterson> no not yet
17:37:37 <dhpeterson> but i have read about that
17:37:51 <dhpeterson> twanvl: ok
17:37:57 <Heffalump> liftM f says "take a value from the monad, apply f, put the result back"
17:38:05 <dhpeterson> ok
17:38:11 <laz0r> is doing liftM (replicate 10) ['a'] the same as doing replicate 10 'a'?
17:38:18 <Heffalump> and since replicate 10 'a' = "aaa...", you get a single result of "aaaaa..."
17:38:29 <Heffalump> laz0r: no
17:38:30 <dhpeterson> ok
17:38:36 <Heffalump> but it is the same as doing [replicate 10 'a']
17:38:43 <laz0r> Heffalump, [replicate 10 'a'] i guess it is then
17:38:45 <dhpeterson> so how does that "work"
17:38:48 <laz0r> gah, im too slow
17:38:56 <Heffalump> dhpeterson: underneath the hood, you mean?
17:38:57 <dhpeterson> it's almost like  (in perl) a "scalar getting promoted to a list"
17:38:59 <dhpeterson> no
17:39:00 <dhpeterson> on top :)
17:39:06 <Heffalump> like I described
17:39:17 <Heffalump> I'm not quite sure what level of explanation you want here.
17:39:39 <Heffalump> when I say "underneath the hood" I don't mean the gory details of GHC, I just mean the definition of liftM and an explantion of that definition.
17:39:47 <dhpeterson> yeah that's what i mea
17:39:49 <dhpeterson> n
17:39:58 <oerjan> in the list monad, liftM = map
17:40:11 <dhpeterson> is liftM always == map
17:40:12 <Heffalump> ok, so liftM :: Monad m => (a -> b) -> m a -> m b
17:40:17 <Heffalump> no, it's not
17:40:17 <dhpeterson> ok
17:40:37 <Heffalump> that type corresponds to the informal description I gave above
17:40:46 <Heffalump> are you familiar with do notation?
17:40:48 <dhpeterson> yes i can see that
17:40:50 <dhpeterson> yes
17:40:54 <dhpeterson> (a bit)
17:41:00 <Heffalump> ok, so here's (one possible definition) of liftM:
17:41:02 <dhpeterson> only in relation to IO
17:41:11 <Heffalump> liftM f m = do v <- m ; return (f v)
17:41:16 <dhpeterson> yes
17:41:23 <Heffalump> which again corresponds quite closely to what I said.
17:41:25 <oerjan> @src liftM
17:41:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:41:39 <Heffalump> Take v out of the monad (<-), apply f to it (f v), put it back in the monad (return)
17:41:52 <dhpeterson> ok
17:41:56 <LoganCapaldo> I always think abotu it backwards
17:41:56 <dhpeterson> i'm geting it now
17:42:15 <Heffalump> there's also a slightly lower level explanation, based around the core monad operations
17:42:16 <LoganCapaldo> Think about it in terms of putting f into the monad
17:42:21 <dhpeterson> i have come across return but didn't realise that was stuffing a value back into the monad
17:42:38 <LoganCapaldo> although into the monad isn't an accurate turn of phrase
17:42:40 <oerjan> LoganCapaldo: You Could Have Invented Comonads!
17:42:43 <dhpeterson> Heffalump: no your current level is just about right
17:43:01 <dhpeterson> is there an example of where liftM is not a "map" like it is for a list
17:43:12 <Heffalump> yes, any other monad
17:43:19 <Heffalump> e.g. IO
17:43:23 <Heffalump> or State
17:43:24 <dhpeterson> ok so what is it there
17:43:26 <dhpeterson> IO
17:43:44 <Heffalump> well, the underlying parts of IO are implemented primitively
17:43:54 <Heffalump> so it's hard to give any other explanation that the definition of liftM
17:43:59 <mudge> hi haskell people
17:44:01 <dhpeterson> ok
17:44:38 <mudge> haskelling around the christmas tree
17:44:39 <dhpeterson> Heffalump: i think i need to do some more reading now, but thank you very much for your help
17:44:45 <dhpeterson> and the others who helped
17:44:46 <dhpeterson> :)
17:44:53 <dhpeterson> i think i am getting closer to comprehension!
17:45:09 <oerjan> list comprehensions?
17:45:11 <mudge> dhpeterson: about monads?
17:45:21 <LoganCapaldo> In State liftM takes a function and gives you back a function that besides doing what the function did before it passes the state along unchanged
17:45:29 <Heffalump> I would suggest you next look at the type signatures of (>>=) and return , and their definitions for particular monads
17:45:31 <dhpeterson> mudge: yep
17:45:37 <dhpeterson> ok
17:45:40 <Heffalump> again, IO is difficult to explain because these are primitives
17:45:47 <mudge> ah yea,  I haven't even really trying monads yet
17:45:53 <mudge> tried*
17:46:00 <dhpeterson> i'm reading "tour de monad" atm: http://members.chello.nl/hjgtuyl/tourdemonad.html
17:46:00 <mudge> tried learning
17:46:01 <lambdabot> Title: A tour of the Haskell monad functions
17:46:03 <Heffalump> but once you understand State, you can think of IO as State RealWorld, for some mythical "RealWorld" type that encapsulates the entire state of the outside world
17:46:20 <oerjan> > liftM (+1) (Just 2)
17:46:20 <dhpeterson> ok
17:46:28 <lambdabot>  Just 3
17:48:08 <Heffalump> oh, yeah, Maybe is a good one to look at too
17:49:57 <LoganCapaldo> Then again, Maybe Not ;)
17:50:52 <oerjan> @djinn Maybe (Not ())
17:50:53 <lambdabot> f = Nothing
17:52:08 <LoganCapaldo> For some reason I expected Not to be type Not = forall a. a -> Void
17:52:32 * LoganCapaldo apologizes for any syntax abuse
18:32:59 <sorear> dons: yup, I expected as much, and was even here to see it happen
18:33:55 <sorear> JaffaCake used lambdabot to check whether haskell.org was up (it wasn't)
18:34:10 <dons> hmm
18:55:33 <chessguy> 'evening
18:57:20 <byorgey> hi chessguy
19:01:17 <chessguy> mmm, quiet night
19:02:46 <chessguy> @where network
19:02:47 <lambdabot> I know nothing about network.
19:03:20 <sorear> ***NOISE!!***
19:03:51 <chessguy> thanks sorear :)
19:13:06 <shapr> Didn't ndm write a safeHead ?
19:15:13 <dolio> What's safeHead? Returns a Maybe?
19:15:17 <shapr> I guess there's no easy way to replace head with something that gives the name of the module it was called in when it gets [] ?
19:16:57 <shapr> I know jhc has a magic underscore, does ghc have anything like that?
19:22:23 <Olathe> If I have 100 groups of items, two items from different groups either work together or don't, how do I efficiently get a set of one item from each group ?
19:23:06 <desp> @hoogle Eq a => [a] -> [a] -> Bool
19:23:06 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
19:23:07 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
19:23:15 <desp> why no love for isInfixOf?
19:23:36 <dolio> The database is too old.
19:24:48 <desp> is there hope for auto-generating the database from the up-to-date docs?
19:44:29 <sorear> shapr: ghc has assert False undefined, which is just as magical but with the added insult of looking like a normal function call
19:47:37 <chessguy> desp, you'd have to ask ndm
19:47:54 <desp> mm
19:54:53 <mdmkolbe> How do I use QuickCheck when the values are floating point and may have a small amount of error in them? (They are actually Complex floats)
19:56:27 <LoganCapaldo> that seems borderline lost cause. Even if theres a withinEpisilon predicate or whatever, generating the floats seems like it would be a pain the neck
19:56:43 <LoganCapaldo> But this is the magical land of Haskell, so I'm probably wrong
19:57:29 <mdmkolbe> LoganCapaldo: the floats could be generated as ints, but a function gets applied to them that makes them into floats that then compare a reference implementation against my optimized version
20:00:33 <scodil> is there a way to change the type of the state in State or StateT mid-way through the computation? I just want to change some phantom type parameters. Like if the state is S p a, p is phantom, and I have a function f :: S p a -> m (S q b), I'd like to be able to just use >> to thread it, with do-sytax and all that. Is this feasible?
20:01:04 <sorear> desp: you can autogenerate the database, and that is infact what we do
20:01:29 <sorear> scodil: nope, you can't do it.  google for restricted state monads, there was a huge -cafe thread on the subject
20:01:54 <sorear> desp: the problem is that lambdabot contains a copy of hoogle.txt, and that copy is never updated
20:01:56 <scodil> bummer
20:02:28 <sorear> they're going to do it in darcs, so it can't be *too* painful :)
20:03:13 <Cale> scodil: You can have a State (Either a b) though.
20:05:36 <scodil> Cale: yeah its a static thing though. I'd like a static solution. its sort of like keeping track of which side of a bipartite graph you're on. if you know which side you start on, you can encode the info in the type
20:06:12 <sorear> scodil: you can't do it with a monad, but there are still other options!
20:06:17 <Cale> scodil: You could actually construct a library with a combinator like (>>) but which switched the state type.
20:06:18 <mdmkolbe> scodil: what do you mean when you say the state is phantom?
20:06:36 <mdmkolbe> scodil: does the state ever actually get a value?
20:07:18 <scodil> mdmkolbe: its like newtype PInt p = PInt Int, where p is either Odd or Even. then (++) :: PInt Odd -> PInt Even, etc..
20:08:19 <mdmkolbe> scodil: ok, I see
20:08:39 <scodil> i know there's monad-less ways to do it, i've done it with C++ templates and pure haskell functions, but I'm working on an IO-based solution so I wanted to play around with StateT
20:11:50 <mdmkolbe> Any good function names for the oposite of "interleave" (e.g.  foo [0,1,2,3,4,5,] -> ([0,2,4],[1,3,5]))?
20:12:05 <sorear> deal?
20:12:26 <mdmkolbe> sounds good
20:26:41 <mdmkolbe> :t  withinEpisilon
20:26:46 <mdmkolbe> @type  withinEpisilon
20:26:46 <lambdabot> Not in scope: `withinEpisilon'
20:26:47 <lambdabot> Not in scope: `withinEpisilon'
20:29:00 <Cale> :t  withinEpsilon
20:29:02 <lambdabot> Not in scope: `withinEpsilon'
20:31:00 <scodil> ok so I got a handful of functions, some do IO, some change the state without changing its type, and some change the state and its type. Is there anyway I'd be able to, say, take a list of these actions and sequence them? or put them all in a do-expression?
20:32:04 <mdmkolbe> scodil: could you use runStateT to extract the state and then wrap it back up into another state?
20:33:19 <scodil> yeah I guess, but I'm not super familiar with StateT. and if the state changes, that means the monad changes, right? so you can't use any standard monad stuff, and I have to thread the state parameter manually
20:34:17 <mdmkolbe> scodil: you'd only have to thread the state parameter for the functions that change the state type
20:34:56 <scodil> thats alot of them. er, a lot of the uses, anway
20:35:40 <Cale> scodil: Here's something to think about: what should the interface to the current state look like?
20:35:55 <Cale> (i.e. what functions and what types)
20:37:07 <mdmkolbe> scodil: could you factor the functions that change the state into a few key functions that do the state changing?  (e.g. inc :: StateT Even IO a -> StateT Odd IO a)
20:37:46 <scodil> ok so its like this: you're a bug on a surface, and you can move forward or backwards, and you can turn 90 degrees. Moving forward or backward requires IO (for now), and I'd like to encode North/South and East/West into the type. so an action would look like: runBug startPoint (do fwd;fwd;right;fwd;left;rev;right)
20:38:10 <scodil> and the result type would be parameterized by NS or EW
20:38:36 <Cale> So what's the type of right?
20:38:58 <scodil> Bug NS () -> Bug EW ()
20:39:18 <scodil> the actual location of the bug is internal state
20:39:25 <scodil> provided as the argument to runBug
20:39:31 <TSC> What about turning east to south?
20:39:38 <Cale> So you clearly can't use it as a line in a do-block -- at least, not without supplying it a parameter.
20:39:38 <mdmkolbe> Yeah, the way I suggested would make that: right (left (right (fwd >> fwd) >> fwd) >> rev) [assuming I transformed it right]
20:39:39 <scodil> that's left
20:39:54 <TSC> East to north, then
20:40:42 <scodil> no wait east to north is left. east to south is right. oops.
20:40:43 <Cale> This seems like an overly awkward thing to encode statically.
20:41:29 <scodil> I've done it at least two other times already. Just not in a monad. The thing is there are operations that take two bugs, and its an error if they're not similarly oriented
20:41:58 <Cale> If you want to think of turning as a computation which runs along with other computations in your block of code, you can't encode the direction you've turned s
20:42:08 <Cale> woops
20:42:15 <Cale> statically
20:42:55 <scodil> sure, you wouldn't be able to do something like: if someRuntimeVal then left else fwd. that should be a type error
20:43:17 <scodil> ah ok. well then i guess that rules out sequence
20:43:53 <Cale> yeah, especially as sequence takes a list of computations of the same type
20:45:20 <scodil> so is there any way i could at least have a uniform connector? instead of switching between . and >>= to compose things?
20:47:08 <scodil> i guess i can just work in IO and use >>=
20:50:27 <Cale> scodil: You could probably use a bunch of typeclass hackery
20:51:17 <Cale> another option would be to compute and validate the transformation you're going to do before executing the relevant IO
20:51:34 <Cale> Which isn't quite the same as getting static guarantees, but it's a little nicer.
20:51:58 <mdmkolbe> @pl concat . repeat
20:51:59 <lambdabot> join . repeat
20:52:35 <Seb_AU> Can anyone here spare a moment to help a newbie?
20:52:39 <Paczesiowa> hi, I got a question: is it normal that binaries produced by ghc (or generally haskell) are huge? this code: http://hpaste.org/2421 compiled takes >10mb of disk space:/
20:52:55 <scodil> Paczesiowa: that's been my experience
20:53:00 <dons> Paczesiowa: that likely means you've not got split objs enabled
20:54:47 <Seb_AU> Is there a function that will apply a function to the n'th element of a list, and then output the same list, but with the n'th element modified?
20:54:49 <jbalint> (in gtk2hs) is there a reason why surface size can only be obtained in a render action?
20:57:20 <sorear> Seb_AU: No, and usually it's indicative of bad design; are you sure you don't want a Map?
20:57:30 <Paczesiowa> dons: could you give me some link or smth? cant google anything besides mailing list posts
20:59:24 <dons> and that the program is linking a lot of external packages
20:59:43 <Seb_AU> I would map, but I can't figure out how to map selectivley - so far we have only learned mapping over entire lists.
21:00:19 <monochrom> Why not array?
21:00:39 <Seb_AU> sorry, I dont know what that is.
21:02:28 <Cale> Seb_AU: He was referring to the Data.Map datastructure, not map the list function.
21:03:23 <Seb_AU> Oh.
21:03:25 <Cale> Seb_AU: The trouble with such a function is that it is very expensive -- applyAt n f xs would cost O(n).
21:03:56 <Cale> It has to rebuild the entire initial segment of the list, though it can share the tail.
21:04:12 <Cale> If you really want it, it's not so hard to write.
21:04:34 <monochrom> It is possible to eliminate the need for it altogether, by re-design.
21:05:16 <ibid> shapr: stuff in parentheses is run in a subshell
21:06:42 <Seb_AU> OK, I'm not a very advanced programmer so I don't understand that entirely.  I do understand however that the idea would be to split the list, and modify, then ++ together again?
21:06:49 <Cale> right
21:07:08 <Cale> and  xs ++ ys  takes O(length xs) steps.
21:07:16 <Cale> [] ++ ys = ys
21:07:23 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
21:07:47 <Seb_AU> Yep, got that.
21:08:11 <Cale> So you can use something like splitAt for the splitting part
21:08:15 <Cale> :t splitAt
21:08:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
21:08:35 <Cale> lambdabot sure is slow lately
21:09:02 <Seb_AU> Thanks guys, I'll give that a shot.
21:09:03 <Cale> > splitAt 7 [1..10]
21:09:05 <lambdabot>  ([1,2,3,4,5,6,7],[8,9,10])
21:09:21 <Tac-Tics> > splitAt 5 [1,2,3,4,6,7,8,9,10]
21:09:22 <lambdabot>  ([1,2,3,4,6],[7,8,9,10])
21:09:40 <Tac-Tics> Touche Lambdabot
21:09:42 <Cale> > splitAt 5 [0..10]
21:09:44 <lambdabot>  ([0,1,2,3,4],[5,6,7,8,9,10])
21:09:54 <Tac-Tics> > splitAt 5 [5,5,5,5,5,5]
21:09:55 <lambdabot>  ([5,5,5,5,5],[5])
21:10:07 <encryptio> > splitAt 7 "Hello, World!"
21:10:08 <lambdabot>  ("Hello, ","World!")
21:10:18 <Tac-Tics> > splitAt (cycle [5])
21:10:19 <lambdabot>  Couldn't match expected type `Int' against inferred type `[t]'
21:10:31 <Tac-Tics> buh?
21:10:52 <encryptio> > splitAt 11 (repeat 5)
21:10:52 <Tac-Tics> oh
21:10:53 <lambdabot>  ([5,5,5,5,5,5,5,5,5,5,5],[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
21:10:58 <Tac-Tics> yes
21:11:18 <Tac-Tics> @src splitAt
21:11:18 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:11:30 <Tac-Tics> oh heh
21:11:34 <Cale> Yeah, that's not the real source :)
21:11:39 <Tac-Tics> I thought it split the list by it's position of the element
21:11:44 <Tac-Tics> fake source?
21:12:05 <encryptio> descriptive, correct, and inefficient source
21:12:10 <Cale> right
21:12:29 <Tac-Tics> this is probably where the fact I only came in during the second half of the conversation becomes important, right?
21:13:04 <Paczesiowa> let (a,b) = splitAt 5 [0..10]; f = (+1) in a ++ f (head b): tail b
21:13:38 <encryptio> > let (a,b) = splitAt 5 [0..10]; f = (+1) in a ++ f (head b): tail b
21:13:40 <lambdabot>  [0,1,2,3,4,6,6,7,8,9,10]
21:13:53 <Cale> > let applyAt n f xs = us ++ vs' where (us,vs) = splitAt n xs; vs' = case vs of [] -> []; (h:t) -> f h : t in applyAt 5 (*10) [0..10]
21:13:54 <lambdabot>  [0,1,2,3,4,50,6,7,8,9,10]
21:14:18 <Seb_AU_> Sorry, I was D/C'ed and just caught that function - very usefull.
21:14:36 <Paczesiowa> poor guy:D
21:14:40 <wli> <interactive>:1:0: Not in scope: `applyAt'
21:15:29 <Tac-Tics> @src applyAt
21:15:29 <lambdabot> Source not found. Are you on drugs?
21:15:30 <Cale> wli: That would be because you haven't defined it ;)
21:16:07 <Paczesiowa> so noone can help me with size of my binaries? c'mon I get everyday many mail offers of helping with size problems
21:16:16 <wli> I'll stick with Data.Map and Data.Sequence equivalence.
21:16:51 <Cale> Paczesiowa: They're statically linked.
21:17:07 <Cale> Paczesiowa: Unless you're on Mac OS X, there's nothing which can be done about it yet.
21:17:12 <Paczesiowa> Cale: so how do I do the opposite thing?
21:17:13 <Cale> But it's just a constant overhead.
21:17:24 <Paczesiowa> Cale: :/
21:17:52 <Cale> Increasing the size of your program will not result in a proportial increase in binary size.
21:18:01 <Cale> proportional*
21:18:20 <encryptio> otherwise ghc itself would be gigabytes in size =D
21:18:25 <Cale> heh
21:19:05 <Paczesiowa> that's good thing, but when 40 lines of code (written to download pr0n) result in 10x bigger binary than my kernel it kinda sucks
21:19:27 <Cale> Meh, the runtime is almost an operating system :)
21:19:32 * Tac-Tics goes to write a pr0n monad
21:19:47 <wli> What about -split-objs?
21:19:59 <Cale> wli: That's only on Mac OS X, afaik.
21:20:07 <monochrom> little boys in a washroom comparing sizes?
21:20:20 <Cale> Unless significant progress has been made on other platforms recently.
21:20:21 <Paczesiowa> where? gimme pics!
21:20:58 <monochrom> I'm trying to mock this size concern.
21:21:24 <Cale> What, are you honestly running low on disk space?
21:21:36 <Cale> heh, maybe with all that pr0n.
21:21:41 <Paczesiowa> :D
21:21:51 <wli> Not everything is stored on disk.
21:22:09 <monochrom> Just put your Haskell programs on a finger.
21:22:45 <Paczesiowa> but if I wanted to send somebody my "script" he would most likely think that there are several viruses inside
21:22:46 <monochrom> I bought a 256M finger for $0. Quite enough for all Haskell work.
21:22:53 <wli> Some systems load from flash.
21:23:22 <Cale> Jeez, even the program which runs to tell me how much memory other programs are using takes 16MB.
21:23:32 <Tac-Tics> How practical would it be to write an OS in haskell?
21:23:32 <sorear> Paczesiowa: I would think anything distributed as a binary only is malware
21:23:38 <sorear> @where House
21:23:39 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
21:23:49 <Cale> Tac-Tics: Fairly so.
21:24:15 <monochrom> You can send him 40 lines of Haskell code and also encourage him to learn Haskell.
21:24:23 <jbalint> is there a way to test for the empty list of the list type doesnt derive Eq?
21:24:24 <Paczesiowa> that OS would need live-BlueRay
21:24:25 <Tac-Tics> that'd be cool to have a linux-like OS written in Haskell, running some port of X and xmonad on top of that
21:24:35 <Cale> http://ogi.altocumulus.org/~hallgren/ICFP2005/
21:24:37 <lambdabot> Title: A Principled Approach to Operating System Construction in Haskell
21:24:45 <monochrom> > null ([] :: [IO ()])
21:24:47 <lambdabot>  True
21:25:05 <jbalint> thanks
21:25:07 <monochrom> In general it is indeed a bad idea to do "xs == []" at all.
21:25:11 <jbalint> ok
21:25:31 <Cale> length xs == 0 is even worse :)
21:26:56 <Tac-Tics> why is that?
21:27:08 <Cale> Tac-Tics: because it computes the length of the list :)
21:27:20 <encryptio> and thus evaluates all the constructors on the way =p
21:27:25 <monochrom> > length (repeat True) == 0
21:27:29 <lambdabot> Terminated
21:27:36 <Cale> > null (repeat True)
21:27:36 <monochrom> That is why.
21:27:37 <lambdabot>  False
21:28:14 <monochrom> Basically all habits you inherited from mainstream languages are bad.
21:28:16 <Cale> You only have to look at the top level constructor of the list to know if it is empty or not.
21:28:47 <Olathe> Cale: mbot fails on "> sequence (replicate 2 [1..8])", but not "> replicateM 2 [1..8]"
21:29:34 <Cale> Olathe: Control.Monad.Sequence
21:29:35 <Cale> er
21:29:38 <Cale> Control.Monad.sequence
21:30:03 <Cale> It's that import problem, mbot is using lambdabot source which is a few months old
21:30:32 <Olathe> Ahh.
21:30:34 <Olathe> Thanks.
21:31:02 <sorear> @Users
21:31:03 <lambdabot> Maximum users seen in #haskell: 385, currently: 355 (92.2%), active: 12 (3.4%)
21:31:34 <ramza3> active: 12, hehe
21:34:14 <reffie> http://images.bhxob.com/2007/1188003818412.png
21:35:28 <Olathe> reffie: ?
21:39:21 <FMotAFK> hrm..
21:41:00 <FMota> to support dependent types in a language, you need a type for types and be able to mix types and non-types to create new types, right?
21:42:18 <FMota> (I know this is not exactly relevant to haskell, btw. Sorry)
21:42:57 <olsner> sounds like something within the range of topics typically discussed in #haskell ;-)
21:43:29 * FMota thinks we should have #functional
21:43:42 <FMota> kinda like there's #forth and then there's #concatenative
21:44:02 <FMota> I guess it doesn't make much difference though
21:44:10 <monochrom> #pure-statictype-nonstrict-functional
21:44:41 <FMota> :o
21:50:07 <Cale> #pure-statictype-nonstrict-functional :Nick/channel is temporarily unavailable
21:50:19 <monochrom> haha
21:51:12 <FMota> anyway, I'm looking to epigram as a type model to my own language.
21:51:37 <FMota> Basically, I want to give it a nice syntax :)
21:52:01 <FMota> Just wanted to be sure I was including the right things.
22:07:14 <dolio> Even Haskell has types for types.
22:08:02 <dolio> It's more the mixing types and values to make types that gets you to dependent typing.
22:17:08 <scodil> are there any zippered tries out there? would a zippered version be faster if accesses were lexicographically clustered? or would the allocation overhead be too much?
22:19:44 <dons> that's an interesting idea
22:20:47 <scodil> are there any haskell Map-like structures that have something analogous to the STL's insert_with_hint (or whatever it's called)
22:21:00 <scodil> the zipper would be the hint in this case
22:25:29 <sorear> scodil: I wrote a program once, for constructing DAWGs from sorted word lists.  I forget what the gains from zipperizing were, but it was something like 20x
22:25:33 <sorear> (in C)
22:26:17 <scodil> nice
22:28:43 <Olathe> What is the W in DAWG ?
22:29:24 <dolio> Weighted.
22:30:22 <sorear> Word.
22:30:38 <dolio> Damn. :)
22:30:49 <Olathe> What's a word graph ?
22:31:03 <sorear> Don't ask me why.  I think "hash-consed PATRICIA trie" would be a better explanation.
22:32:44 * sorear implements the Presberger decision procedure
22:59:13 <dons> ?users
22:59:13 <lambdabot> Maximum users seen in #haskell: 385, currently: 349 (90.6%), active: 4 (1.1%)
23:03:44 <joed> dons, stats, lies, and damned lies.
23:15:50 <dons> ?where stats
23:15:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
23:16:20 <slava> dons: purely functional cowboys: http://factorcode.org/IMGP0074.jpg
23:16:47 <slava> dons: we took this one just for you :)
23:16:57 <dons> heh!
23:17:20 <dons> that's really cool :)
23:17:38 <slava> hacking on windows port: http://factorcode.org/foo/IMGP0026.jpg
23:17:40 <dons> oh, who's got the hard cover SPJ book?
23:17:58 <slava> erg has hundreds of cool and rare computer books
23:18:01 <dons> i don't think i've ever seen the dead tree version
23:18:30 <dons> okasaki's book is truly great
23:18:59 <dons> so who's who in that first photo?
23:19:30 <slava> i'm in the middle
23:19:47 <dons> nice monitor on the left, in the 2nd photo.
23:19:49 <slava> dharmatech (eduardo) is wearing the homeland security shirt, erg (doug) is the other guy
23:19:51 <dons> should run xmonad on it ;)
23:19:57 <slava> i have the same monitor at home
23:20:23 <dons> how's the hacking go?
23:20:29 <dons> get some milestones down?
23:20:51 <slava> i was finishing up with a new release. but mostly we explored new ideas and played around with stuff
23:21:20 <dons> cool. a big part of these hackathons is just getting better connections between people too, I've found
23:21:31 <slava> yup
23:21:36 <dons> you work better together once you've spent a few days locked in a room hacking
23:21:50 <slava> we hung out with some other cool people too
23:21:54 <slava> the rscheme developer lives in austin
23:22:02 <slava> rscheme is a scheme implementation with a persistent object store and real time gc
23:22:27 <dons> oh, that's interesting. we had a guy here yesterday wondering about starting an FP group in Austin too.
23:23:32 <dons> slava: did I mention I'm moving to the US next week? :)
23:23:49 <slava> where in the US?
23:23:58 <dons> 07.07.25:11:01:06 * Nafai wishes there was a Haskell or FP usergroup in Austin
23:24:06 <dons> Portland, OR
23:24:07 <dons> (working for galois.com)
23:24:07 <slava> we had lunch with nafai!
23:24:12 <slava> oh cool!
23:24:22 <dons> ah ha! now it makes sense what Nafai was talking about)
23:24:35 <dons> so yes, you can get paid to write haskell these days :)
23:25:30 <dons> morningroconnor
23:25:51 <roconnor> morning
23:26:10 <dons> did anyone else read the reddit article title ` Three Candidates Sign the Oath of Presidential Transparency' as an `Oath of Referential Transparency'?
23:27:02 <slava> now wouldn't that be cool?
23:27:17 <dons> that would really change politics :)
23:33:10 <LeCamarade> QuickChekable politics? Cummon.
23:45:19 <desp> is there a Cabal key that should be used to provide -prof -auto-all to GHC when attempting to build my library for profiling?
23:45:55 <newsham> there's a flag to Setup.hs configure
23:45:58 <newsham> -prof?
23:46:00 <desp> no, I don't mean that
23:46:16 <desp> it's -p, or --enable-library-profiling
23:46:23 <desp> but that doesn't appear to pass -auto-all to GHC
23:46:32 <newsham> sorry, thats all I know about tihs :)
23:46:36 <desp> no problem
23:46:55 <desp> I just barely recall a key like Profiling-options that should be used for this, but can't find it
