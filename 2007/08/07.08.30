00:00:12 <dblhelix> /s/less/less often
00:00:58 <ChilliX> dblhelix: I believe we have a proof (or maybe a handwavy argument somewhere) showing how type families are more general than FDs in that respect (ie, decidability check)
00:01:43 <dblhelix> ChilliX: okay, that's good news already (that is, if the delta does apply to realistic programs ;-))
00:02:46 <ChilliX> dblhelix: well, unfortunately, the combination of type families with GADTs make it much more restrictive than it would be otherwise
00:03:19 <ChilliX> Ie, in 7.2.3 on the web page, the condition 3 would not be necessary without GADTs
00:03:29 <dblhelix> ChilliX: because of the local equality constraints?
00:03:29 <ChilliX> and it is the most restrictive of the bunch
00:03:40 <ChilliX> dblhelix: exactlly
00:04:21 <ChilliX> on the other hand, we at least have some sort of idea how GADTs and type families interact (whereas with FDs this is more speculation than anything else AFAIK)
00:04:42 <ChilliX> and secondly, you can do some pretty cool stuff by combining type families with GADTs
00:05:20 <dblhelix> ChilliX: imagine what you could do if we could also close type families? ;-)
00:05:30 <ChilliX> (unfortunately, the interaction between the two in the implementation is still a bit buggy, but will be fixed soon)
00:05:46 <ChilliX> dblhelix:  yeah...that's our next project :)
00:06:31 <dblhelix> ChilliX: shouldn't be that hard, right? (but perhaps I've no idea what I'm talking about ;-))
00:07:30 <ChilliX> dblhelix: the problem is completeness, closedness leads to a stronger logic (ie, more lemmas a derivable), but that makes it harder for type inference to be complete
00:07:48 <takamura> hi
00:07:48 * dblhelix ponders
00:08:41 <dblhelix> ChilliX: I see (I think)
00:08:48 <ChilliX> assume Add is a closed type family defining addition on Peano numerals on the type level
00:08:51 <ChilliX> ah, ok
00:09:38 <sorear> Are we sure GADTs are worth it as an extension?  They seem to cause a disproportionate amount of pain and complexity.
00:09:54 <dblhelix> ChilliX: if you know that there's only one instance for C a, then every constraint of this form determines a?
00:10:08 <ChilliX> dblhelix: yep, that kind of reasoning
00:10:25 <ChilliX> sorear: they are also very powerful
00:11:11 <dblhelix> sorear: "haskell 98 should be enough for everone"?
00:12:26 <sorear> 1. MLF 2. GADTs can be church-encoded, if their need is rare enough
00:12:31 <dblhelix> ChilliX: aren't these the same issues that arise in total languages like epigram? (I'm not familiar with the details, but I can imagine)
00:12:56 <Philippa> sorear: yeah, so can pattern-matching in general. In a word, *ouch*.
00:13:35 <dblhelix> ChilliX: more general, in proof assistants?
00:13:47 <Philippa> fact is, if they're needed at all then they're needed enough that the encoding is far too painful
00:15:01 <ChilliX> dblhelix: yes.  our problem is that we want to infer types as far as possible
00:15:36 <dblhelix> mmm...
00:16:21 <dblhelix> ChilliX: interesting anyway... exciting even!
00:16:50 <sorear> I still think we haven't found the right approach to GADTs.
00:17:37 * sorear decides he's too tired to usefully continue.
00:20:40 <roconnor> sorear: don't do it.  You still have lots to live for!
00:20:56 <dblhelix> roconnor: heh
00:21:06 <gour> hi, recently i asked here about using UML with haskell and got some replies how its not much useful. however, conveying the message to my OO friends (C++), i got the question "So how do they design in Haskell before typing code?" Anyone can give some light?
00:21:54 <roconnor> people use UML before writing C++?
00:22:15 <gour> roconnor: my (c++) friend does
00:22:31 * sorear is blissfully mostly unaware what UML is
00:22:54 * Japsu is on a university course that teaches UML among other things
00:22:59 <roconnor> my gut reaction is that using UML before writing code is (more or less) independent of the language being used.
00:23:00 <gour> sorear: you want me to take away some of your bliss?
00:23:10 <sorear> gour: chalkboards, IRC, start-with-a-blank-file-and-refactor-until-it-works
00:23:31 <Japsu> drawing figures, divide and conquer
00:23:38 <pjd> roconnor: some people try to use UML as essentially a graphical representation of source coude
00:23:47 <gour> sorear: there are 3 devs in distributed environment, no chalkboards
00:23:57 <Japsu> virtual chalkboard!
00:23:59 <sorear> IRC!
00:24:03 <Modius> What's the name of the/a function that converts from [[a]] to [a] ? (By chaining the lists) ?
00:24:12 <Japsu> Modius: concat
00:24:12 <pjd> Modius: concat
00:24:16 <Japsu> @quote stereo
00:24:17 <lambdabot> No quotes match. Take a stress pill and think things over.
00:24:23 <Modius> Thanks
00:24:26 <gour> sorear: anything more concrete?
00:24:33 <roconnor> Modius: join!
00:24:35 <Japsu> Why why WHY has the majestical stereo quote been erased?!? >_<
00:24:37 <roconnor> oops
00:24:45 * dolio is with roconnor.
00:24:48 <pjd> mconcat!
00:24:55 <hpaste>  sjanssen pasted "type family bug?" at http://hpaste.org/2514
00:24:57 <roconnor> @hoogle mconcat
00:24:58 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
00:24:59 <gour> roconnor: so you think UML can be used?
00:25:00 <Japsu> > join [[1..5], [1..3]]
00:25:01 <lambdabot>  [1,2,3,4,5,1,2,3]
00:25:15 <sjanssen> ChilliX: would you like to take a look at http://hpaste.org/2514 ?
00:25:21 <Japsu> join is more general
00:25:26 <Japsu> @type join
00:25:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:25:36 <pjd> Japsu: it's differently general
00:25:39 <roconnor> gour: well I suppose so.  UML is for drawing out high level concepts for programming right?
00:25:42 <Japsu> yeah
00:25:56 <gour> roconnor: afacs, it is more suited for OO
00:26:06 <roconnor> gour: but I've never used UML, so I my confidence is very low.
00:26:11 <Japsu> UML isn't only class diagrams
00:26:11 <sorear> isn't Haskell high enough already?
00:26:26 <Japsu> there's also use case thingies, activity diagrams etc
00:26:44 <gour> any tool you can recommend instead of going into UML?
00:26:57 <pjd> Japsu: join can only flatten monads, while mconcat can flatten lists of any monoid
00:27:08 * roconnor suspects UML will be perfect for designing arrows for GUIs
00:27:08 <Japsu> hmm
00:27:29 <roconnor> maybe we can even compile something like UML directly to haskell arrow code.
00:27:33 <Japsu> arrows for GUIs sounds iteresting
00:27:37 <Japsu> +n
00:28:28 <pjd> gour: maybe worth mentioning is "type-driven" programming
00:28:55 * Japsu was thinking of implementing physical units as Haskell types the other day
00:29:01 <pjd> in Haskell, you can often take time to get the types right, and have the code just flow naturally from them
00:29:25 <roconnor> I agree with pjd.  In haskell one ususally makes data types, and the code almost follows directly from that.
00:29:57 <gour> so, then you recommend just to write down types and work on APIs
00:30:10 <pjd> probably
00:30:24 <pjd> another difference is that Haskell code tends to be compact
00:30:56 <pjd> you don't really end up such mass of classes that you need diagrams to navigate them
00:31:10 <gour> it's probably hard to accept for C++ folks
00:32:02 <gour> or those fiddling with class, state..diagrams
00:32:10 <pjd> for example, C++/Java/etc. have big and complicated iterator interfaces and helpers
00:32:25 <pjd> in Haskell, you basically have [a]
00:32:29 <dolio> Just have them talk to some Lisp people for a while. Then your Haskell methodology won't seem so insane. :)
00:33:00 <pjd> and it works because a plain Haskell list can contain any computation
00:33:06 <gour> dolio: well, they (OO people) tell me that "fp is for aliens" :-)
00:33:17 <roconnor> gour: *l*
00:33:21 <pjd> lazy evaluation just takes care of it
00:33:46 <pjd> gour: oh, state is the other biggy
00:34:29 <dolio> From what I've read on comp.lang.functional, the Lisp methodology is to fire up a Lisp environment, and randomly define procedures that might be related to the problem you're trying to solve. Then, eventually, you write some of those down permanantly, and that's your program. :)
00:34:51 <pjd> Haskell design tends to concentrate on the "what", rather than the how or when
00:35:07 <gour> true
00:35:32 <gour> spec is (almost) program
00:36:40 <pjd> well, i mean you don't find a need for things like UML behavioral diagrams
00:37:12 <gour> i'm glad i don't, just to forward the message to 'mentors'
00:37:18 <pjd> you're free to think in terms of values and invariant properties
00:37:29 <gour> hopefully, we're able to push haskell as the implem. lang ;)
00:37:41 <gour> s/hopefully/fortunately
00:39:00 <pjd> finally, you don't often find big hierarchies
00:39:28 <pjd> bits of code tend to be more separate, and you can think of them more in isolation
00:39:44 <gour> yes, and haskell module system is quite nice
00:40:07 <pjd> you have a combinatory approach
00:46:48 <blakkino> hello :) i'm using some tricks around MonadIO to use two Monads that do IO under the hood.. there isn't anythings better? somethings like a MonadTrans for IO?
00:47:45 <blakkino> my Monads do IO with a generic MonadIO and i have put there the other which is also a MonadIO
00:47:49 <blakkino> Monad
00:48:46 <blakkino> and i have a "custom" lift that do actions in the inside monad
00:49:12 <blakkino> the fun part is that i have taken a look at the profiler and my "custom" lift take somethings like 40% of total time :)
01:24:47 <beelsebob> hmm, that Monads in functional programming page needs editing
01:25:29 <beelsebob> it makes out that Haskell was specifically designed for you to work in a monad all the time
01:52:28 <xerox> ?get-shapr
01:52:29 <lambdabot> shapr!!
02:22:38 <wli> ghc does not want to build on my box; probably things trying to build half 64-bit and half 32-bit.
02:24:17 <pejo> @tell ndm I proved termination. See "Convergence of program transformers in the metric space of trees by Soerensen. Get the one from Science of Computer Programming.
02:24:17 <lambdabot> Consider it noted.
02:24:31 <pejo> Lovely, unbalanced quotes.
02:25:22 <Lemmih> wli: From darcs?
02:25:56 <wli> Lemmih: Yeah.
03:13:05 <xerox> newtype Line a = L { prev_ :: [a], (here:next_) :: [a], pos :: Int }
03:13:11 <xerox> Too bad that doesn't work :)
03:14:02 <psykotic> how would it be different than head : a, next : [a]
03:14:08 <psykotic> s/:/::/
03:14:20 <xerox> psykotic: handier for take and drop
03:14:43 <xerox> I guess I need next_@(here:_) :: [a] actually.
03:21:21 <roconnor> xerox: I think Conor was talking about an extended record syntax for something like this at dinner once.
03:22:19 <roconnor> hmmm, maybe it was different.
03:23:26 <roconnor> maybe he wanted to allow  someRecord{(foo,bar) = blob} instead of requiring someRecord{foo=fst blob, bar=snd blob}
03:23:45 <roconnor> for record updates
04:12:30 <gleb> @arrr
04:12:31 <lambdabot> Avast!
04:12:45 <gleb> @list
04:12:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:13:52 <gleb> @pl (\x y -> x*16 + y)
04:13:52 <lambdabot> (+) . (16 *)
04:15:00 <Saul_> Can anyone here help me?
04:15:07 <Saul_> type Value = String
04:15:07 <Saul_> type Constraint = Value -> Bool
04:15:07 <Saul_> check :: Value -> [Constraint] -> Bool
04:15:07 <Saul_> check v = foldr ((&&).(flip ($) v)) True
04:16:14 <Saul_> What I have now works, but I want to change the type of the check function a little, to [Constraint] -> Value -> Bool (and thus to [Constraint] -> Constraint)
04:16:22 <Saul_> Does anyone know how to do that?
04:18:11 <Saul_> (Without doing everything explicitly, I might add)
04:22:20 <Saul_> Maybe lambdabot knows :)
04:22:28 <Saul_> @pl flip (\v -> foldr ((&&).(flip ($) v)) True)
04:22:29 <lambdabot> flip (flip foldr True . ((&&) .) . flip id)
04:22:38 <Saul_> :D
04:22:56 <xerox> name something :)
04:23:49 <Saul_> xerox: What do you mean exactly?
04:24:16 <xerox> Oh, nothing. If you happy that way :)
04:25:01 <Saul_> Well I don't actually find flip (flip foldr True . ((&&) .) . flip id) very intuitive
04:27:57 <Saul_> @pl flip (\v -> and.map (flip ($) v))
04:27:57 <lambdabot> flip (all . flip id)
04:28:06 <Saul_> ok this is better :D
04:29:45 <mboes> Saul_: how about \cs v -> all id $ zipWith ($) cs (repeat v) ?
04:29:59 <mboes> the arguments are named but there's no explicit recursion
04:30:35 <wli> @pl output is not the sort of pointfree code one should actually write in most instances.
04:30:35 <lambdabot> (line 1, column 68):
04:30:35 <lambdabot> unexpected reserved word "in" or "i"
04:30:35 <lambdabot> expecting variable, "(", operator or end of input
04:30:55 <wli> ugh
04:31:18 <Saul_> wli: You might be right
04:31:28 <Saul_> mboes: I'll try out that one
04:32:40 <EvilTerran> all id = and
04:33:01 <mboes> EvilTerran: ah, yes. was looking for that one!
04:33:14 <EvilTerran> likewise, any id = or
04:33:37 <EvilTerran> @src any
04:33:37 <lambdabot> any p =  or . map p
04:36:17 <Saul_> I actually understand what lambdabot returned
04:36:39 <Saul_> It's actually pretty intuitive
04:53:04 <puusorsa> @src fix
04:53:04 <lambdabot> fix f = let x = f x in x
04:53:14 <Saul_> Actually it's not intuitive (and I don't think I really get it yet)
04:53:31 <Saul_> That it took me so long to realize that is a reason not to use it
04:54:54 <pippijn> hi all
04:55:23 <dons> hey pippijn. welcome!
04:56:33 <Paczesiowa> why "map ((- 1) . valToInt) fields)" doesn't compile, but s/-/+ compiles? there is a space so it shouldn't be treated like number
04:57:02 <ricky_clarkson> > (- 1)
04:57:03 <dons> I think you want `subtract'?
04:57:03 <lambdabot>  -1
04:57:09 <ricky_clarkson> > ((-) 1)
04:57:11 <lambdabot>  <Integer -> Integer>
04:57:14 <pippijn> Could not find module System.IO.UTF8
04:57:23 <pippijn> I'm wondering where this could be
04:57:23 <dons> pippijn: its in the utf8-string module on hackage
04:57:25 <idnar> > ((-) 1) 7
04:57:26 <lambdabot>  -6
04:57:35 <Paczesiowa> ricky_clarkson: tx!
04:57:36 <pippijn> hmm
04:57:37 <dons> :t subtract 1
04:57:39 <idnar> that's probably not what he wanted
04:57:39 <lambdabot> forall t. (Num t) => t -> t
04:57:45 <ricky_clarkson> Paczesiowa: Listen to dons, not me!
04:57:49 <dons> map (subtract 1) [1..10]
04:57:53 <dons> > map (subtract 1) [1..10]
04:57:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
04:58:00 <dons> > map ((-) 1) [1..10]
04:58:01 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
04:58:12 <dons> > map (1 -) [1..10]
04:58:14 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
04:58:16 <Paczesiowa> both solutions work, tx guys
04:58:20 <dons> > map (- 1) [1..10]
04:58:21 <lambdabot>   add an instance declaration for (Num (a -> b))
04:58:24 <Cale> > map (+ (-1)) [1..10]
04:58:25 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
04:58:27 <dons> silly `-'
04:58:31 <dons> cute, Cale
04:58:41 <idnar> oh, heh
04:58:44 <ricky_clarkson> Paczesiowa: How do both solutions work when they give you different results?
04:59:00 <Paczesiowa> ((-) 1) 2
04:59:10 <Paczesiowa> (subtract 1) 2
04:59:20 <dons> ?check \xs -> map (subtract 1) xs == map ( (-) 1) (xs :: [Int])
04:59:21 <lambdabot>  Falsifiable, after 0 tests: [-3,1]
04:59:25 <idnar> > ((-) 1) 2
04:59:26 <lambdabot>  -1
04:59:29 <idnar> > (subtract 1) 2
04:59:30 <Cale> Paczesiowa: If you want those evaluated, you need to prefix them with "> "
04:59:31 <lambdabot>  1
04:59:32 <Paczesiowa> I meant that bot solutions compile:D
04:59:42 <Paczesiowa> Cale: tx
04:59:54 <ricky_clarkson> Paczesiowa: Without dependent types, compilation doesn't mean the results are correct. ;)
05:00:09 <pippijn> where do I put those modules?
05:00:21 <dons> ricky_clarkson: well... ;)
05:00:31 <dons> > () :: () -- true enough
05:00:32 <lambdabot>  ()
05:00:53 <balodja> Guys, would you advise me some papers about lazyness? I want to know, which functions are treated to be tail-recursive, and which aren't.
05:00:53 <ricky_clarkson> dons: For -/negate.
05:01:01 <ricky_clarkson> er, subtract.
05:01:12 <dons> yeah :)
05:01:20 <ricky_clarkson> balodja: That doesn't have anything to do with laziness.
05:02:40 <balodja> and how to differ functions that are tail-recursive from those that aren't?
05:02:57 <ricky_clarkson> Do you know what tail recursion is?
05:03:36 <dons> balodja: oh, you're worried about building up unevaluated results?
05:06:29 <balodja> ricky_clarkson: eh, yep, notation for representing "big calls", that cannot be placed in stack in straight way
05:06:38 <balodja> data: exactly
05:07:44 <ricky_clarkson> balodja: In what I've read, it's a function that, as the last part of its evaluation, calls another function (possibly itself).
05:08:29 <pippijn> Could not find module `Network'
05:08:37 <pippijn> I can't find that one
05:09:23 <dons> pippijn: that's in the 'network' package
05:09:28 <Paczesiowa> did you try "-package network" ?
05:09:33 <dons> what project are you building, btw/
05:09:40 <BobFunk> hmm, having trouble figuring out the mkCdata function of HXT
05:09:42 <dons> ?hackage network
05:09:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network
05:09:53 <pippijn> dons: geordi
05:09:58 <pippijn> http://www.eelis.net/geordi/
05:10:01 <lambdabot> Title: geordi - C++ eval bot
05:10:07 <ricky_clarkson> > let fac=(\n a -> if n==1 then a*n else (fac (n-1) a*n)) in fac 10 1
05:10:08 <lambdabot>  3628800
05:10:14 <dons> huh, didn't know about this.
05:13:10 <BobFunk> keep getting the type error:  Couldn't match expected type `a n'
05:13:10 <BobFunk>            against inferred type `Data.Tree.NTree.TypeDefs.NTree'
05:13:23 <BobFunk> when trying to user mkCdata in transformations
05:29:25 <hkBst> is it possible to use [1..a] where a is a variable?
05:29:31 <xerox> Yes.
05:29:43 <xerox> That is just sintactic sugar for enumFromTo
05:30:12 <hkBst> oh, I see :)
05:30:14 <ricky_clarkson> > let a=5 in map (\x -> "yes") [1..a]
05:30:19 <lambdabot>  ["yes","yes","yes","yes","yes"]
05:30:22 <DRMacIver> Really rather superfluously sugared as well.
05:30:32 <DRMacIver> It's not like they couldn't have just defined a .. operator which did the same thing.
05:31:09 <psykotic> / let (...) = enumFromTo in 1...10
05:31:11 <xerox> No you can't.
05:31:14 <psykotic> > let (...) = enumFromTo in 1...10
05:31:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:31:23 <DRMacIver> Oh, right. That wouldn't allow the unbounded versions.
05:31:29 <psykotic> good point
05:31:39 <ChilliX> DRMacIver: well, [1,3..10] is not a binary op
05:31:49 <xerox> DRMacIver: well, it actually is possible to do both on the same.
05:32:00 <DRMacIver> That too. Sorry. My mistake. Please continue your previously scheduled conversation. :)
05:32:01 <psykotic> ChilliX, i find some of those uses to be rather silly. it shouldn't be in the language.
05:32:26 <xerox> Yeah fromenumTo I don't see how to do it :)
05:32:43 <EvilTerran> > let (...) = enumFrom in (1 ...)
05:32:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:33:20 <ChilliX> psykotic: silly? you may argue calling the function would have been that more verbose, but then it is really lightweight sugar, too (ie, low cost to implement)
05:33:35 <EvilTerran> hooray for postfix notation as a syntactic coincidence!
05:33:44 <psykotic> i dislike most non-general sugar
05:33:55 <ChilliX> would = would not
05:34:09 <psykotic> and the non-default-stepping list building notation is a very rarely useful variant
05:34:45 <EvilTerran> it's handy for going backwards
05:34:53 <psykotic> i would have been fine with an infix .. that could take an "infinity" as argument for the unbounded case
05:36:12 <psykotic> anyway, i'm fine with the current notation, it just seems like a rather random piece of exceptional sugar
05:36:13 <EvilTerran> in Haskell, that "infinity" would probably end up being represented by  1..Just 3 vs 1..Nothing
05:36:47 <EvilTerran> some of the Enum instances are a bit quirky, too
05:36:48 <psykotic> EvilTerran, you could have the Enum type class with an inf member
05:36:58 <EvilTerran> > [1::Integer,...]
05:36:58 <lambdabot>  Parse error
05:37:08 <EvilTerran> > [1::Integer ..]
05:37:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:37:14 <EvilTerran> > [1::Double ..]
05:37:15 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
05:37:20 <EvilTerran> > [1::Fixed E2 ..]
05:37:21 <lambdabot>   Not in scope: type constructor or class `E2'
05:37:26 <EvilTerran> ...
05:37:29 <EvilTerran> @docs Data.Fixed
05:37:29 <lambdabot> Data.Fixed not available
05:37:39 <EvilTerran> @hoogle Fixed
05:37:39 <lambdabot> System.Win32.File.dRIVE_FIXED :: DriveType
05:37:39 <lambdabot> System.Win32.Mem.gMEM_FIXED :: GlobalAllocFlags
05:38:06 <EvilTerran> bah. i give up. anyway. the instance Enum (Fixed a) doesn't do what you'd expect.
05:40:46 <EvilTerran> > [1::Fixed E6 .. ]
05:40:47 <lambdabot>  [1.000000,1.000001,1.000002,1.000003,1.000004,1.000005,1.000006,1.000007,1.0...
05:48:52 <roconnor> EvilTerran: I'm pretty sure that it is Enum Double that doesn't do what you expect.
05:49:27 <roconnor> [1::Double ..] is hardly an enumeration of all doubles not less than 1.
05:49:57 <EvilTerran> > [1::Rational, ..]
05:49:57 <lambdabot>  Parse error
05:49:59 <EvilTerran> > [1::Rational ..]
05:50:00 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1,17%1...
05:50:10 <EvilTerran> Fixed is very much the odd one out
05:50:12 <pippijn> dons: it works now
05:50:26 <pippijn> dons: my bot is in #geordi and called torres2
05:50:54 <roconnor> that goes for Rational too.
05:51:15 <roconnor> Double, Rational, they are all broken.
05:51:35 <roconnor> hopefully the will be removed in Haskell'
05:51:56 <roconnor> they
05:51:57 <EvilTerran> but they all act the same, and Fixed acts differently. that makes it de facto wrong, even if it's got the moral high ground.
05:52:22 <EvilTerran> sure, if you took out all of those, Fixed's would be right, but as it stands it isn't, IMO.
05:52:55 <roconnor> well, Fixed isn't part of the standard library, so I'm not sure it needs to be consistent with it.
05:53:09 <roconnor> although prehaps you mean that Fixed doesn't make a drop in replacement for Double.
05:53:22 <beelsebob_> hmmm
05:53:38 <beelsebob_> yeh [1::Rational ..] really doesn't do what I'd expect
05:54:03 <SamB_XP_> > [1::Rational ..]
05:54:05 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1,17%1...
05:54:06 <beelsebob_> I would have expected [1%1, 2%1, 1%2, 3%1, 2%2, 1%3.....
05:54:20 <EvilTerran> i'm thinking Enum's semantics are badly defined
05:54:25 <ricky_clarkson> After infinity it will do those.
05:54:31 <MyCatVerbs> beelsebob_: dovetailer? :)
05:54:31 <SamB_XP_> heh
05:54:33 <roconnor> EvilTerran: yeah, I'm starting to think that.
05:54:46 <beelsebob_> ricky_clarkson: exactly, it's using the wrong counting mechanism
05:54:47 <EvilTerran> although here's something odd:
05:54:52 <beelsebob_> there are rationals it won't count
05:54:56 <EvilTerran> > fromEnum [1 :: Fixed E6 ..]
05:54:56 <lambdabot>   add an instance declaration for (Enum [Fixed E6])
05:54:57 <lambdabot>     In the expression: fr...
05:55:02 <EvilTerran> > ma p fromEnum [1 :: Fixed E6 ..]
05:55:03 <lambdabot>   Not in scope: `p'
05:55:05 <EvilTerran> > map fromEnum [1 :: Fixed E6 ..]
05:55:06 <lambdabot>  [1000000,1000001,1000002,1000003,1000004,1000005,1000006,1000007,1000008,100...
05:55:08 <SamB_XP_> EvilTerran: I thought that was an accident
05:55:23 <EvilTerran> what was?
05:55:37 <roconnor> > fromEnum (1%2)
05:55:38 <lambdabot>  0
05:55:43 <SamB_XP_> dunno...
05:55:45 <ricky_clarkson> > map fromEnum [16777216 :: Float ..]
05:55:46 <lambdabot>  [16777216,16777216,16777216,16777216,16777216,16777216,16777216,16777216,167...
05:55:48 <roconnor> WTF?
05:56:00 <EvilTerran> ....
05:56:04 <SamB_XP_> roconnor: wtf what?
05:56:10 <EvilTerran> >  [16777216 :: Float ..]
05:56:11 <lambdabot>  [1.6777216e7,1.6777216e7,1.6777216e7,1.6777216e7,1.6777216e7,1.6777216e7,1.6...
05:56:15 <roconnor> fromEnum (1%2) == 0 !?
05:56:21 <EvilTerran> hooray for floating point!
05:56:29 <roconnor> okay, this enum class is totally borked.
05:56:58 <EvilTerran> it needs a set of axioms that should hold for instances, imo
05:57:11 <roconnor> presumable succ x === toEnum (fromEnum x + 1) ought to be an invarient.
05:57:24 <EvilTerran> there are some (http://haskell.org/onlinereport/basic.html#sect6.3.4), but not enough
05:57:25 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
05:58:24 <EvilTerran> > [succ x == toEnum (fromEnum x + 1) | x <- [0::Fixed E6 ..]]
05:58:28 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
05:58:35 <puusorsa> no haskell for .net yet?
05:58:40 <MyCatVerbs> EvilTerran: invariants are expensive. Not all applications can neccessarily affort to have variable precision, and fixed precision more or less *always* causes an invariant to break somewhere.
05:58:45 <MyCatVerbs> purplepenguins: F#?
05:58:56 <MyCatVerbs> Wait, no, that's ML. Sorry, my bad.
05:59:01 <puusorsa> MyCatVerbs, it's closer to ocaml
05:59:19 <MyCatVerbs> puusorsa: yeah, my bad.
05:59:32 <puusorsa> oh well guess i'll use it then. http://www.cin.ufpe.br/~haskell/haskelldotnet/ .. no releases yet ;(
05:59:34 <EvilTerran> MyCatVerbs, you could have invariants for Enum+Bounded instances, and invariants for all other Enum instances
05:59:35 <lambdabot> Title: The Haskell.NET Project
06:00:52 <MyCatVerbs> EvilTerran: surely it breaks things to say that there are invariants which must be held by any instance of Enum alone, but which don't have to hold if the structure is also an instance of Bounded? That's backwards to the way we normally define and use invariants. >>
06:00:53 <roconnor> Is thre a list of things that suck about Haskell on the wiki?  We need to add this Enum crap for Floats and Rationals.
06:01:18 <EvilTerran> okay, have BoundedEnum and InfiniteEnum classes. -.-
06:01:21 <roconnor> MyCatVerbs: exactly.  If you are going to have two differnt concepts, they should be two different classes.
06:01:59 <roconnor> EvilTerran: but Integer is both infinite and has a sane Enum instance.
06:02:13 <MyCatVerbs> roconnor: okay, admittedly that does suck, but it's intrinsic to *all* programming languages using IEEE floating point.
06:02:27 <EvilTerran> maybe Enum => BoundedEnum, Enum => InfEnum, and try to craft the invariants in a way that works
06:02:28 <SamB_XP_> yes, Integer's Enum instance is the only sane one I know of
06:02:40 <roconnor> MyCatVerbs: this isn't a floating point issue.  The instance of Enum for Rational is borked too.
06:02:42 <SamB_XP_> except the stupid fromEnum/toEnum hack
06:02:45 <EvilTerran> roconnor, i never contradicted you...
06:03:06 <EvilTerran> that's be an instance of InfEnum, i guess
06:03:36 <SamB_XP_> what would be the point of BoundedEnum and InfEnum?
06:03:37 <MyCatVerbs> roconnor: I fail to see the problem with it, it just behaves exactly the same way as all the machine-type enums do.
06:03:42 <roconnor> EvilTerran: We don't need BoundedEnum and InfiniteEnum, we need Enum, and something weaker for Floats and Rationals.
06:04:01 <EvilTerran> samB, never mind, that was just a random thought
06:04:14 <SamB_XP_> @google site:haskell.org suck
06:04:17 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/basicTypes/NameSet.lhs
06:04:17 <lambdabot> Title: CVS log for fptools/ghc/compiler/basicTypes/NameSet.lhs
06:04:22 <SamB_XP_> @google site:haskell.org things that suck
06:04:24 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/basicTypes/NameSet.lhs
06:04:25 <lambdabot> Title: CVS log for fptools/ghc/compiler/basicTypes/NameSet.lhs
06:04:25 <roconnor> @check \x -> succ (x::Integer) == (toEnum (succ (fromEnum x)))
06:04:27 <lambdabot>  OK, passed 500 tests.
06:04:32 <roconnor> @check \x -> succ (x::Rational) == (toEnum (succ (fromEnum x)))
06:04:33 <SamB_XP_> hmm.
06:04:34 <lambdabot>  Falsifiable, after 7 tests: 1%2
06:04:39 <EvilTerran> although i guess prescribing invariants that cover multiple classes is a bit hairy, IMO, it'd be nice to prescribe "forall x. succ x > x", etc
06:04:42 <roconnor> MyCatVerbs: that's the difference.
06:04:49 <SamB_XP_> apparantly google is pretty adamant that http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/basicTypes/NameSet.lhs sucks!
06:04:51 <lambdabot> Title: CVS log for fptools/ghc/compiler/basicTypes/NameSet.lhs, http://tinyurl.com/2shj75
06:05:04 <MyCatVerbs> roconnor: a dovetailer for rational numbers isn't really what you expect [ 1::Rational .. ] to produce, seeing how all the other instances of enum give you [ i, i+1, i+2... ] if you as for just [ 1.. ]
06:05:05 <SamB_XP_> @google site:haskell.org/haskellwiki suck
06:05:05 <lambdabot> No Result Found.
06:05:11 <SamB_XP_> @google site:www.haskell.org/haskellwiki suck
06:05:12 <lambdabot> No Result Found.
06:05:12 <MyCatVerbs> Er, [ i.. ]
06:05:22 <ricky_clarkson> site: takes a domain iirc.
06:05:45 <SamB_XP_> shapr: do you know of a page about things that suck?
06:05:52 <ricky_clarkson> java.sun.com?
06:06:10 <SamB_XP_> ricky_clarkson: on the haskell wiki, silly
06:06:34 <roconnor> MyCatVerbs: an enum for data Colours = Red | Green | Blue doesn't yield [Red, Red+1, Red+2]
06:07:12 <MyCatVerbs> roconnor: right, it yields [ Red, succ(Red), succ(succ(Red)) ]
06:07:47 <roconnor> so you expect [1::Rational, succ(1), succ (succ (1))]
06:07:48 <SamB_XP_> hmm, you know what I don't like?
06:07:53 <SamB_XP_> > succ maxBound
06:07:54 <lambdabot>  Add a type signature
06:07:57 <MyCatVerbs> roconnor: yarf, but And succ(x) happens to be defined as (\x->x+1)
06:07:58 <SamB_XP_> arg
06:08:03 <SamB_XP_> > succ maxBound :: Bool
06:08:04 * MyCatVerbs stab enter key.
06:08:05 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
06:08:10 <SamB_XP_> > succ maxBound :: Int
06:08:10 <roconnor> MyCatVerbs: yeah, but that is a crappy definition of succ.
06:08:11 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:08:19 <SamB_XP_> > succ maxBound :: Word
06:08:20 <lambdabot>  Exception: Enum.succ{Word}: tried to take `succ' of maxBound
06:08:23 <MyCatVerbs> roconnor: yarf, but succ happens to be defined as (\x->x+1) for all the other numerical classes.
06:08:33 <SamB_XP_> MyCatVerbs: you wish!
06:08:39 <SamB_XP_> > maxBound+1
06:08:39 <lambdabot>  Add a type signature
06:08:46 <SamB_XP_> > maxBound+1 :: Int
06:08:47 <lambdabot>  -2147483648
06:08:59 <MyCatVerbs> SamB_XP_: ?
06:09:05 <roconnor> > succ maxBound :: Int
06:09:06 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:09:19 <SamB_XP_> for those who missed it the first time round
06:09:34 <ricky_clarkson> > negative (-2147483648)
06:09:35 <lambdabot>   Not in scope: `negative'
06:09:42 <ricky_clarkson> > negate (-2147483648)
06:09:43 <lambdabot>  2147483648
06:09:47 <EvilTerran> MyCatVerbs, that's the sort of thing i'm saying about wanting to assert invariants that involved multiple classes
06:09:48 <SamB_XP_> hehe
06:09:54 <SamB_XP_> ricky_clarkson: that's defaulted to Integer
06:10:01 <MyCatVerbs> Okay, I've put it wrong. But all other numerical classes treat [ a,b .. c ] as linear interpolation between a and c with the step size set to (b - a).
06:10:11 <ricky_clarkson> > negate (-2147483648 :: Int)
06:10:12 <lambdabot>  -2147483648
06:10:19 <SamB_XP_> ricky_clarkson: the default defaults being (Integer, Double)
06:10:36 <roconnor> MyCatVerbs: yeah, but we cannot go around giving inconsistent interpetations of functions of a given class.
06:10:46 <EvilTerran> and all other numerical classes treat (succ a) as (a+1) (except in boundary cases)
06:11:07 <SamB> EvilTerran: you mean types
06:11:12 <MyCatVerbs> roconnor: how's it inconsistent? If it's treated as linear interpolation in all cases, surely that's the *definition* of consistency?
06:11:15 <EvilTerran> yes, types, sorry
06:11:22 <SamB> you're getting mixed up with just about every other language ;-P
06:11:43 * EvilTerran thinks an instance Num a => Enum a where... might work better, if just for the sake of consistency
06:11:45 <SamB> at least, that has anything called a class at all
06:11:55 <roconnor> I expect succ x === toEnum (succ (fromEnum x)) to be a property of enumerations.
06:12:17 <SamB> roconnor: I expect fromEnum/toEnum shouldn't be on Enum
06:12:42 <roconnor> succ is supposed to be the next largest element in the enumeration.
06:12:55 <roconnor> Rationals don't have a next largest element
06:13:11 <roconnor> they aren't enumerable with the standard ordering.
06:13:40 <MyCatVerbs> roconnor: so you're saying rationals shouldn't be instances of Enum at all?
06:13:43 <EvilTerran> if that's how Enum's meant to be defined, then yes, that makes perfect sense.
06:13:46 <roconnor> MyCatVerbs: yes.
06:14:02 <roconnor> MyCatVerbs: they could be an instance of something else.
06:14:15 <EvilTerran> but in that case, we've either got to scrap the [,..] sugar or move it into a different class
06:14:17 <roconnor> Perhaps even a superclass of Enum.
06:14:19 <SamB> I think Enum a should have two principle methods: one of type a -> a -> Integer, and one of type Integer -> a -> Maybe a
06:14:24 <MyCatVerbs> roconnor: I can see how that's more mathematically consistent than the current definition, but not more useful. Being able to write linear interpolations using enum syntax is quite useful.
06:14:53 <SamB> hmm.
06:14:56 <SamB> maybe not.
06:15:29 <roconnor> MyCatVerbs: well, it's not that useful.  I always write (map linearFunction [a::Integer,b..c])
06:15:38 <SamB> what kind of thing would we use for, e.g., [0, 0.1 ..] ???
06:16:05 <roconnor> map ((/10).fromInteger) [0..]
06:16:08 <roconnor> > map ((/10).fromInteger) [0..]
06:16:09 <lambdabot>  [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8...
06:16:30 <roconnor> But there is probably a way to have our cake and eat it too.
06:16:35 <SamB> yes
06:16:50 <SamB> but we need a better oven
06:17:13 <MyCatVerbs> OTOH, defining fromEnum and toEnum to return and take positions along the rational dovetail would be really cool. And it'd be self-consistent. And it'd allow you to do things like write [ 0::Rational .. ] to test things against every single rational number ever...
06:17:48 <SamB> MyCatVerbs: would be okay if it could be optimized for cases where rationals were unnecessary
06:17:48 <MyCatVerbs> But it'd still confuse the living *shit* out of people who expect it to behave like linear interpolation because that's how all the other number classes *just happen to* behave.
06:17:57 <SamB> oh.
06:18:00 <SamB> sorry
06:18:02 <SamB> got confuse
06:18:03 <SamB> d
06:18:21 <MyCatVerbs> SamB: bugger that, if people don't need rationals let 'em use floats. :)
06:18:40 <roconnor> MyCatVerbs: yeah, I'd be inclided to wrap Rational in a newtype before giving it an enumeration that doesn't respect <
06:18:59 <SamB> it'd be cool to have a better heirarchy to replace Enum, especially if we had type class synonyms...
06:19:21 <roconnor> SamB: didn't we get type class synonyms today?
06:19:33 <SamB> did we?
06:19:44 <SamB> roconnor: someone implemented them?
06:20:00 <dolio> No, we got associated type synonyms.
06:20:01 <roconnor> http://justtesting.org/post/10117783
06:20:03 <lambdabot> Title: Just Testing
06:20:06 <SamB> ah
06:20:10 <SamB> I was gonna say
06:20:21 <SamB> er.
06:20:21 <roconnor> dolio: oh right, sorry
06:20:38 <SamB> it's called "class aliases" apparently
06:24:04 <dolio> Now we just need associated classes, right? :)
06:24:47 <SamB> classes aren't even higher-order yet
06:25:11 <ChilliX> dolio: be careful what you are wishing for, you might get it: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions/ClassFamilies
06:25:14 <lambdabot> Title: TypeFunctions/ClassFamilies - GHC - Trac, http://tinyurl.com/27byjk
06:25:44 <dolio> ChilliX: Yeah, I knew you folks were considering it. :)
06:26:15 <ChilliX> Just making sure the degree of our insanity is being understood ;)
06:29:30 <SamB> ChilliX: huh. that's wierd!
06:29:54 * EvilTerran returns from making coffee
06:30:47 <EvilTerran> I'm thinking, it might make sense to have two classes; one for types which have a natural *injection* from (an initial subset of) the naturals, and one for types which have a natural *bijection* likewise
06:31:02 <roconnor> @kind []
06:31:04 <lambdabot> * -> *
06:31:18 <roconnor> > [1,2,3] :: [] Int
06:31:19 <lambdabot>  [1,2,3]
06:31:25 <roconnor> cool, I didn't know that.
06:31:39 <EvilTerran> @kind (->)
06:31:40 <lambdabot> ?? -> ? -> *
06:31:52 <SamB_XP_> EvilTerran: why the naturals?
06:32:07 <EvilTerran> why anything else?
06:32:22 <EvilTerran> it seems a sensible common ground for enumerable types
06:32:58 <SamB_XP_> what about Integer?
06:33:24 <EvilTerran> what about it? that's got a natural injection from the naturals, and a less-natural bijection
06:34:04 <SamB_XP_> usually people don't want to enumerate based on the bijection...
06:34:28 <EvilTerran> the bijection would be useful for cases when you actually want to enumerate the entire type
06:35:05 <EvilTerran> the injection would be good for when you just want a list of equidistant values or what-have-you.
06:36:01 <EvilTerran> so the current Enum instance for (Fixed a) is kinda like the bijection, and for Double is kinda like the injection
06:36:38 <SamB_XP_> what if you wanted to start from some negative number, or count down?
06:36:51 <EvilTerran> i think i see what you mean, actually. yeah, maybe "a contigous subset of the integers" would be better than "an initial subset ofthe naturals"
06:38:23 <EvilTerran> i like that. and it'd be easier to devise sensible invariants for those two classes than the current Enum class, methinks
06:38:50 <EvilTerran> not sure where such things as [0.1,0.2..] would fit in, though
06:41:52 <EvilTerran> they probably wouldn't. i haven't actually seen very many uses of that aspect of the Enum instances for the Fractionals
06:42:05 <EvilTerran> and map (/10) [1..] wouldn't be too painful
06:43:18 <roconnor> or [i/10 | i<-[1..]]
06:43:41 <EvilTerran> indeed.
06:44:01 <ricky_clarkson> Are comprehensions syntax sugar or a clever result of the type of []?
06:44:16 <sieni> > [7/2345..]
06:44:17 <lambdabot>  [2.9850746268656717e-3,1.0029850746268656,2.0029850746268654,3.0029850746268...
06:45:46 <EvilTerran> ricky_clarkson, very much syntactic sugar
06:46:16 <EvilTerran> they desugar mostly to concatMap, via do{}, guard, and (>>=)
06:47:02 <dcoutts> @yarr!
06:47:03 <lambdabot> Aye Aye Cap'n
06:47:08 <dcoutts> cabal-upload rocks
06:47:27 <EvilTerran> [f y | x <- foo, let y = g x, p x y] = do { x <- foo; let y = g x; guard (p x y); return (f y) }
06:47:57 <dolio> I doubt most implementations desugar them that way.
06:48:15 <EvilTerran> = foo >>= \x -> let y = g x in guard (p x y) >> return (f y)
06:48:53 <EvilTerran> = concatMap (\x -> let y = g x in ETCETC) foo
06:49:01 <EvilTerran> dolio, i know, but that's how i think about it
06:49:22 <dolio> Yeah, I do as well.
06:49:31 <dolio> Although they have their own set of rules in the report...
06:49:53 <EvilTerran> "list comprehensions are like do{} blocks in the list monad in a funny order" "do{} blocks are like (>>=) etc, and in the list monad (>>=) is like concatMap"
06:54:14 <dolio> [ f y | x <- foo, let y = g x, p x y ] = let { ok x = let { y = g x } in if p x y then [ f y ] else [] ; ok _ = [] } in concatMap ok foo
06:54:22 <pjd> do blocks are like for loops :)
06:54:24 <dolio> By those rules.
06:55:43 <EvilTerran> dolio, oh right. well, that's quite a lot neater than my via-three-different-things approach :D
06:56:48 <dolio> Clearly. :)
06:58:36 * EvilTerran prods C with a pointy stick
06:59:48 <EvilTerran> i wish people'd use consts, typedefs, and inline functions in place of #defines when at all possible (ie for pretty much anything other than conditional compilation). it'd make extracting meaning from C headers much easier.
07:00:29 <dolio> What if you have to compile your code in 1980?
07:00:30 <psykon> inline does not exist on C89
07:00:33 <mux> since inline functions are only standard since C99, you see how that can be a problem
07:00:48 <EvilTerran> yeah, it's only been standard for eight years... =/
07:00:48 <ricky_clarkson> EvilTerran: When I started in C, I thought header files were the documentation.
07:01:03 <mux> C99 wasn't supported well in 1999 :)
07:01:04 <dmead_> ricky_clarkson, aren't they ? :P
07:01:11 <psykon> lol
07:01:16 <mux> and this standard is still disputed
07:01:28 <geezusfreeek> huh, text.html outputs the doctype for HTML 3.2, yet it doesn't support some of the elements that were deprecated in HTML 4 and it also contains some of the new elements from HTML 4...
07:02:15 <EvilTerran> well, fortunately, nowadays most compilers do C99 fairly well, i think. and i get the impression a lot supported (or at least ignored) the "inline" keyword even before 1999
07:02:42 <mux> gcc supports __attribute__((__inline__)) since long indeed
07:02:53 <EvilTerran> and not only would it be easier to get info out of, they're much more hygenic than macros, too
07:03:09 <mux> gcc even supports annotating a function as pure
07:03:30 <EvilTerran> #define MAX(x,y) (x > y ? x : y)? enjoy your repeated evaluation when someone does MAX(foo(),bar()).
07:03:36 <geezusfreeek> i could probably make my own version of Text.Html to support HTML 4, but it'd be nicer if there is a version out there already... anybody know of one (Text.Xhtml doesn't count)?
07:04:33 <gleb> EvilTerran: how else could you define max in *C*?
07:04:55 <EvilTerran> gleb, polymorphically, or otherwise?
07:04:57 <ricky_clarkson> gleb: As a function.
07:05:15 <mux> you mean as 10 functions?
07:05:19 <EvilTerran> the problem with doing it as a function would be that you could only have one type, yes
07:05:24 <gleb> EvilTerran: yes, polymorphism in C is a problem
07:05:37 <pjd> mux: does gcc do anything with pure-annotated functions?
07:05:48 <EvilTerran> GCC had a more hygenic, but infinitely uglier, solution to that, too
07:05:52 <mux> pjd: yep, it enables some more optimizations (I don't know the specifics)
07:05:57 <dmead_> pure-annotated?
07:06:07 <dmead_> macros you mean?
07:06:14 <mux> no
07:06:15 <EvilTerran> #define MAX(x,y) ({ typeof(x) _x = x; typeof(y) _y = y; _x > _y ? _x : _y })
07:06:26 <mux> we're talking about the pure and pure2 annotations allowed by GCC
07:06:36 <pjd> heh, pure2?
07:06:37 <geezusfreeek> alright, i guess i'll just modify it myself then
07:06:40 <dmead_> eh?
07:07:04 <mux> info gcc explains the differences between those two
07:07:08 <EvilTerran> mux, dmead_, iirc, functions marked as pure for GHC would be run at compiletime if given constant parameters and you had optimisations on
07:07:14 <EvilTerran> *GCC
07:07:30 <dmead_> interesting
07:08:13 <EvilTerran> i believe the syntax is "__attribute__ ((pure)) int max (x,y) { return (x > y ? x : y) }"
07:08:33 <EvilTerran> s/(x,y)/(int x, int y)/
07:08:53 <EvilTerran> s/}/;}/
07:08:54 <EvilTerran> etc
07:08:54 <dmead_> ah
07:08:57 <dmead_> right
07:09:02 <dmead_> i've seen that along in games
07:09:04 <dmead_> *alot
07:09:10 <EvilTerran> it also implied such things as inline, i think
07:11:22 <dolio> Haskell has warped your brain. You're dropping semicolons and forgetting type annotations. :)
07:11:37 <dmead_> i'm trying to write C++ today
07:11:38 <idnar> heh
07:11:45 <dmead_> i haven't remembered a semicolon yet!
07:12:35 <EvilTerran> hehe. i think most C compilers actually work without the final semicolon in a block, altho GCC throws out a warning
07:13:19 <dmead_> o rly...
07:13:57 <dmead_> after or IN a block?
07:14:03 <dmead_> after a block you never should need one
07:14:09 <dmead_> {}; is redundant
07:14:14 <dmead_> {} is all you need
07:14:18 <EvilTerran> as in, { return (x > y ? x : y) } above
07:14:32 <dmead_> mmm
07:14:35 <dmead_> i think you still need it
07:14:50 <EvilTerran> it says "warning: missing final semicolon in block" or something, but iirc, it still compiles
07:15:05 <EvilTerran> a lot of C-like langauges officially allow it
07:15:25 <EvilTerran> (perl, for instance)
07:18:15 <EvilTerran> by the by, does GHC include a complete C compiler?
07:18:40 <EvilTerran> just wondering, seeing as it seems to be able to compile the --via-C output itself
07:18:57 <Saizan> it ships with gcc on windows
07:19:17 <dcoutts> and uses the system gcc on linux/unix/osx
07:19:40 <dcoutts> EvilTerran: it does include a complete C-- compiler though :-)
07:20:00 <EvilTerran> er.
07:20:07 * EvilTerran looks in his install folder
07:20:22 <EvilTerran> so it does! ... that was unexpected.
07:21:02 <dcoutts> EvilTerran: I think you mis-understand, and what did you find?
07:21:10 <EvilTerran> gcc
07:21:22 <dcoutts> that's gcc, not C--
07:21:56 * dcoutts realises EvilTerran may have been meaning gcc not C-- and shuts up
07:21:59 <EvilTerran> "1517<EvilTerran> so it does!" was in response to "1516<Saizan> it ships with gcc on windows"
07:22:10 <dcoutts> EvilTerran: :-)
07:25:22 <evir> Last week I tried writing a C program for the first time in years. It has been 10 lines long and crashed with a Segmentation Fault immediately.
07:25:45 <evir> Because I swapped the positions in "int main(char *argv[], int argc)"
07:27:28 <EvilTerran> =/
07:27:53 <evir> gcc hasn't even spit out warnings...
07:28:43 <ricky_clarkson> Haha.
07:29:17 <evir> Oh, and I just got it the wrong way around again... ;-)
07:30:14 <flux> evir, this is one thing you forgot also: -W -Wall ;-)
07:30:26 <flux> (atleast gcc 4.1.1 warns about that)
07:30:36 <evir> flux: Yes, it warns if you use -Wall.
07:31:29 <evir> flux: But I think this should be a higher priority warning, for there are few reasons for using wrong types in that case... :-)
07:32:04 <dolio> Comes up all the time at IOCCC. You don't want to discourage that. :)
07:33:42 <ricky_clarkson> I sometimes have to help someone teach Perl to newbies, and he doesn't use -w.  That's REALLY annoying.
07:34:18 * pjd thinks [1,3..10] should be done with a step
07:34:25 <idnar> -Werror
07:35:38 * EvilTerran does "use strict; use warnings" out of habit
07:35:54 <evir> Perl without strict is hardly usable.
07:36:43 <EvilTerran> quite.
07:37:00 <evir> All kinds of awkward errors arise just from mistyped variable names... :-)
07:37:02 <EvilTerran> use diagnostics; is great when you're first starting out
07:37:29 <EvilTerran> instead of just getting a warning, you get that *and* a paragraph explaining what you might've done wrong.
07:41:18 <EvilTerran> ghc might benefit from that, actually...
07:42:39 * EvilTerran considers that "option to add helpful blurb about warnings/errors" might be the sort of thing he could actually do
07:57:51 <fasta> I wish I could click on terminal output and jump to the line of code that generated it.
07:58:39 <EvilTerran> ...are Cabal packages fundamentally tied to POSIX OSen?
07:59:29 <flux> hmm.. something like greasemonkey for terminals could be fun. the output is not as structured though, so perhaps it wouldn't be as useful..
07:59:46 <fasta> flux: the idea would be to write structured output of course.
07:59:55 <flux> well, it could just as well be haskell plugins for terminal ;-)
07:59:59 <fasta> flux: I guess TeXmacs is designed for that.
08:08:43 <shachaf> fasta: Perhaps you could use vim's quickfix to do that, somehow?
08:12:19 <fasta> shachaf: what does quickfix do? I am not a hardcore vim user.
08:12:31 <mrd> fasta: you mean like you can do in emacs? and vim's quickfix.
08:12:58 <fasta> mrd: In Emacs you cannot do that, AFAIK.
08:13:01 <mrd> I just did it
08:13:18 <fasta> mrd: unlikely
08:13:30 <mrd> perhaps you'd like to come by and click on my error and see for yourself =)
08:13:59 <fasta> mrd: I am responsible for improving that feature through user feedback
08:14:05 <fasta> mrd: so, you don't understand
08:14:14 <oerjan> fasta: do you mean the actual program output, not the compiler messages
08:14:18 <fasta> oerjan: right
08:15:08 <mrd> sounds like a feature of Genera
08:15:51 <shachaf> QuickFix can work with more than compiler error messages, I think (I don't use it either, so I'm not sure, though).
08:16:10 <mrd> I've used QuickFix with Reinke's vimscripts
08:16:18 <mrd> that only handles compiler errors, afaik
08:16:25 <fasta> Heh, so the Lisp machine was the only environment that solved it the right way.
08:16:38 <fasta> Computer history is one big tragedy.
08:16:50 <adu> hello
08:16:54 <mrd> I would agree, except without the computer part.
08:17:37 <adu> how would one implement a determinant of an array of type "Array (Int,Int) Rational"
08:18:21 <roconnor> adu: intresting question.
08:18:53 <fasta> I wait for the day that 400 Haskellers say hello back.
08:19:01 <mrd> ?users
08:19:01 <lambdabot> Maximum users seen in #haskell: 392, currently: 374 (95.4%), active: 12 (3.2%)
08:19:19 * roconnor thinks step 1 is to abstract it to (Int,Int) ->  Rational
08:19:27 <oerjan> you could write a helper function that had lists of row and column indices
08:19:36 <adu> up until now I've been "thinking procedural" and implementing matrix inverse with gaussian row-reduction using (m // v) but i just realized i can use the determinant with Cramer's rule and get the same results in a more "thinking functional" way :)
08:19:44 <oerjan> and computed the determinant of the corresponding submatrix
08:20:05 <oerjan> actually, just one would need to be a list
08:20:22 <roconnor> and then maybe to ([Int] -> [Int] -> (Int, Int) -> Rational) where the lists tell which rows and columns are under consideration.
08:20:36 <fasta> roconnor: have you ever used the graphical heap profiler?
08:20:51 <roconnor> fasta: nope.  I'm not even sure I've used the heap profiler.
08:20:56 <roconnor> I probably should.
08:21:10 <fasta> roconnor: heh, your programs are fast the first time?
08:21:13 <adu> oerjan: do you think maybe doing it recursively by minors would be better?
08:21:28 <roconnor> fasta: nope. I usually look at the time profiler.
08:21:30 <fasta> I have lots about one third of LAG and VOID states.
08:21:31 <bos> @hoogle runInteractiveCommand
08:21:32 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
08:21:40 <roconnor> fasta: but I probably should look at the heap profiler.
08:21:52 <roconnor> fasta: I didn't know the heap profiler existed until a month ago.
08:22:18 <oerjan> actually, my suggestion would probably blow up exponentially
08:22:24 <fasta> Although it contains some output I don't understand and it's not perfect it does seem to work.
08:22:52 <roconnor> oerjan: does it really blow up?
08:23:06 <oerjan> too many minors to consider, aren't there?
08:23:26 <roconnor> oerjan: oh yeah
08:23:30 <adu> oerjan: well I'm thinking of doing it on 50x50 arrays at least
08:23:46 <roconnor> oerjan: wait, are minors repeated in the computation?
08:23:59 <oerjan> it was just that definition of determinant that sprang to my mind
08:24:18 <adu> oerjan: theres also the Sum Prod definition
08:24:28 <roconnor> oerjan: I guess they are repeated.
08:25:01 <oerjan> Sum Prod is probably even worse
08:25:08 <roconnor> so that means dynamic programming, or better yet, time to look up how to properly compute a det
08:26:07 <oerjan> i recall something about elementary operations
08:26:14 <adu> det(M) = sum[k_j =1..n, j=1..n] perm [k_j | j<-[1..n]] prod[i=1..n] M_(j, k_j)
08:26:19 <adu> i think
08:26:46 <roconnor> My initial guess it to do an LU decomposition, then you can take a product of the diagonal elements.
08:27:47 <adu> doesn't Haskell leave other langs in the dust when it comes to enumerating all possibilities?
08:28:06 <oerjan> adu: only in the program size
08:28:12 <adu> o
08:28:31 <oerjan> not so much in speed :(
08:29:13 <oerjan> a bad algorithm will be a bad algorithm, even if you write it in haskell
08:29:28 <adu> granted
08:29:39 <fasta> How much slower would something written in ST be as something written in C?
08:30:57 <MyCatVerbs> fasta: dunno. Try it and benchmark it? At a guess, I'd say about three or four times, but I have *no* source for that whatsoever.
08:32:06 <fasta> MyCatVerbs: well, porting one of my algorithms would take a bit too much work to do in C. I guess we are doomed for micro-benchmarks.
08:32:44 <earthy> well, there is the shootout
08:32:53 <earthy> and nobench, which has realistic programs
08:35:34 <roconnor> @type perm
08:35:36 <lambdabot> Not in scope: `perm'
08:37:32 <oerjan> i think elementary row operations would be doable in haskell
08:37:53 <oerjan> (1) find a row with first column non-zero
08:38:46 <fasta> What's the official location of nobench?
08:39:23 <oerjan> (2) rescale it to make first column 1
08:39:45 <oerjan> (3) add multiples of it to the other rows to make their first column zero
08:40:10 <oerjan> (4) now recurse using the remaining minor
08:40:18 <EvilTerran> (try not to divide by zero by mistake)
08:40:31 <oerjan> EvilTerran: that
08:40:42 <EvilTerran> > Nothing `compare` Just 0
08:40:43 <oerjan> 's just checking that the first column is not all zeros
08:40:44 <lambdabot>  LT
08:40:57 <EvilTerran> > Nothing `compare` Just ()
08:40:58 <lambdabot>  LT
08:41:03 <EvilTerran> @src Maybe
08:41:03 <lambdabot> data Maybe a = Nothing | Just a
08:41:10 <EvilTerran> alrighty.
08:41:34 <oerjan> EvilTerran: it's the default derivation i think
08:42:17 <EvilTerran> that's what i was thinking.
08:42:21 <fasta> Never mind, it seems it's dons'.
08:43:58 <oerjan> i am sure there are some evil issues if you are using floating point arithmetic, but this should work perfectly for rationals.
08:46:46 <oerjan> (apart from the possibility of huge numbers arising)
08:47:48 <Modius> What's the shortest haskell/command one would use to take a list and return a list of unique elements only
08:47:57 <olsner> nub
08:48:00 <wli> Modius: nub
08:48:03 <Modius> Thanks
08:48:31 <evir> If this was a gaming channel, one could take that as an insult.
08:48:49 <idnar> evir: wtf stfu
08:48:50 <olsner> how? it's a haskell function - gamers don't know haskell!
08:49:00 <evir> idnar: dieplzkthx
08:49:08 <idnar> evir: lol no u
08:49:15 <EvilTerran> zomglolwut
08:49:16 <idnar> this is vaguely disturbing
08:49:36 <Modius> If I'd have asked for the search clause they would have called you a nubBy
09:07:38 <adu> what do you think of my haskell code? :)
09:07:39 <adu> http://pastebin.com/m39463db6
09:10:49 <EvilTerran> er... what does it do?
09:12:37 <adu> gets the signature / permutation number / index inversion of a list
09:13:03 <adu> its required for the Sum-Prod definition of the matrix determinant
09:13:20 <adu> for some examples:
09:13:28 <EvilTerran> ah, permutation number. i see.
09:13:29 <adu> signature [1,2,3] == 1
09:13:36 <adu> signature [1,3,2] = -1
09:13:44 <adu> signature [1,2,2] == 0
09:13:46 <EvilTerran> why does it return zero if there're duplicates?
09:14:13 <adu> because you CAN'T get a list of duplicates by permuting the list [1..3]
09:15:33 <EvilTerran> so... its output is only defined for lists of distinct elements?
09:15:56 <sorear> hah, my amazingly unrigorous test of new GHCs (install xmonad) actually found a bug!
09:16:02 <adu> well, its output is only non-zero for lists of unique elements, yes, but is defined as 0 for lists of duplicates
09:16:03 <EvilTerran> (by "only defined for" i mean it'll do something arbitrary (in this case return 0) otherwise)
09:16:08 <oerjan> no, it's perfectly well-defined
09:16:23 <oerjan> it's just that swapping two elements always swaps the sign
09:16:40 <oerjan> so 0 is the only reasonable for non-unique
09:16:58 <EvilTerran> erm
09:17:01 <adu> oops i used too much code...
09:17:02 <adu> http://pastebin.com/m2b3ea116
09:17:08 <adu> thats better :)
09:17:35 <oerjan> however i think sum of products also blows up exponentially
09:17:59 <adu> oerjan: of course, you can't get away with things blowing up with determinants.
09:18:22 <adu> I think the best known determinant algorithm is O(n^2), the worst is O(n^3)
09:18:46 <oerjan> neither of those are exponential
09:19:02 <adu> but they still blow up
09:19:29 <EvilTerran> adu, how about this: http://pastebin.com/m6fa8e1dc
09:19:31 <adu> or maybe I'm thinking about solving linear systems in general...
09:20:08 <EvilTerran> it's conventional in haskell to, when you have a list of items, give it a plural name, so i've used the names "x" and "xs"
09:20:38 <adu> EvilTerran: wow thats nicer, thanks
09:20:51 <sorear> JaffaCake++ * fix compiling GHC 6.7+ with itself - compat needs -package containers now
09:20:54 <xerox> Why don't you use hpaste?
09:22:14 <EvilTerran> adu, pattern-matching on lists and suchlike is a very powerful aspect of haskell =]
09:22:23 <adu> hehe ok
09:22:32 <adu> i'm still learning
09:23:16 <EvilTerran> also, from your earlier paste, i think (ih - (div ih 2)*2) is just (mod ih 2), if i understand it right
09:23:33 <evir> Also, length == 1 may take much longer than just matching against [i].
09:23:54 <EvilTerran> and you can write div or mod (or any other function with 2 parameters) infix by wrapping its name in backticks, so that could be written (ih `mod` 2)
09:24:06 <adu> EvilTerran right, that ih - (div ih 2)*2) code was from before i did the (-1)^i thing, I forgot I could take it out... sorry
09:24:53 <EvilTerran> yes, as you say, it's not even necessary here. the mod function is worth remembering, though, as is infixing functions
09:25:27 <adu> right
09:26:27 <EvilTerran> hm... should the signature of [1,2,3] be 1? i thought no swaps => signature 0
09:26:41 <evir> -1 ^ 0 = 1
09:26:54 <adu> no swaps means 1
09:27:06 <adu> even swaps 1
09:27:09 <adu> odd swaps -1
09:27:14 <adu> impossible 0
09:27:24 <EvilTerran> ah, i see.
09:27:59 <evir> adu: Why don't you use the gauss algorithm for the determinant?
09:28:13 * EvilTerran was thinking signature was (number of swaps) `mod` 2, actually. i think that was the source of my confusion
09:28:16 <evir> Or a LU decomposition of the matrix to solve the linear system?
09:28:27 <adu> evir: because my head started hurting with all the (m // v) stuff and I couldn't figure out how to monad-pipe everything together
09:28:43 <adu> I got stuck on this question specifically:
09:28:48 <adu> If f :: I -> X -> X
09:28:57 <adu> How do i turn a list [i1,i2,i3,i4] into:
09:28:57 <adu> f i1 (f i2 (f i3 (f i4 x)))
09:29:22 <shapr> xerox: You called?
09:29:22 <xerox> foldr
09:29:23 <evir> foldr?
09:29:30 <EvilTerran> foldr
09:29:35 <EvilTerran> @src foldr
09:29:36 <lambdabot> foldr k z xs = go xs
09:29:36 <lambdabot>     where go []     = z
09:29:36 <lambdabot>           go (y:ys) = y `k` go ys
09:29:42 <Cale> foldr f z [] = z
09:29:44 <EvilTerran> ... shut up, lambdabot.
09:29:50 <xerox> shapr: ah yes. Do you have a link to the place showing those arrows that print out their tree of applications?
09:29:54 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
09:30:11 <adu> o right, i thought foldr was only for infix operators, i'm so silly...
09:30:32 <Cale> > foldr (\x y -> concat ["(f ",show x," ",y,")"]) "z" [1..5]
09:30:33 <chessguy> hmm. why isn't it defined that way in @src?
09:30:35 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
09:30:55 <EvilTerran> in order to even pass foldr an infix op, you have to turn it into a prefix function by parenthesising it
09:30:58 <xerox> chessguy: it's optimal, not for reading, but for some other purpose :)
09:31:00 <sorear> chessguy: because it isn't.  no better explanation has been proposed
09:31:06 <Cale> > foldl (\x y -> concat ["(f ",x," ",show y,")"]) "z" [1..5]
09:31:08 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
09:31:12 <EvilTerran> > (*) 2 3 -- infix op made prefix
09:31:13 <lambdabot>  6
09:31:15 <xerox> sorear: really? I thought there was SOME reason.
09:31:32 <EvilTerran> xerox, i presume that's how it's defined in GHC's libraries
09:31:39 <sorear> xerox: dons says that it's the library definition, but...
09:31:41 <sorear> @src sort
09:31:41 <lambdabot> sort = sortBy compare
09:31:44 <sorear> @src sortBy
09:31:44 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:31:50 <sorear> @src insertBy
09:31:50 <adu> so "foldr f x xs"?
09:31:50 <lambdabot> insertBy _   x [] = [x]
09:31:50 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
09:31:50 <lambdabot>                                  GT -> y : insertBy cmp x ys'
09:31:50 <lambdabot>                                  _  -> x : ys
09:31:56 <xerox> adu: right
09:31:58 <adu> ok
09:31:59 <adu> thanks
09:32:11 <xerox> sorear: ah, it's inconsistent throughout the library.
09:32:14 <Cale> @where Fold
09:32:14 <lambdabot> I know nothing about fold.
09:32:15 <sorear> > sort (reverse [1..100])
09:32:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:32:19 <Cale> @where FoldDiagrams
09:32:19 <lambdabot> I know nothing about folddiagrams.
09:32:19 <sorear> > sort (reverse [1..1000])
09:32:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:32:23 <EvilTerran> adu, yes. and the (:)s in the list will be replaced by (`f`)s, and the [] by x.
09:32:23 <sorear> > sort (reverse [1..10000])
09:32:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:32:32 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
09:32:33 <lambdabot> Title: Fold Diagrams - CaleWiki
09:32:41 <adu> later guys
09:32:46 <sorear> somehow I think a O(n^2) algorithm wouldn't sort a list of 10000 elements that fast!
09:32:49 <sorear> > sort (reverse [1..100000])
09:32:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:32:55 <sorear> > sort (reverse [1..1000000])
09:32:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:33:06 <Cale> sort is actually a merge sort
09:33:14 <sorear> GHC of course actually uses mergesort, but that's not what @src gives
09:33:16 <xerox> shapr: do you remember that?
09:33:26 <Cale> Yeah, @src just has its own database
09:33:36 <xerox> I think src reats fptools stuff?
09:33:39 <Cale> no
09:33:44 <shachaf> @src [] (<*>)
09:33:44 <lambdabot> (<|>) = (++)
09:33:52 <shachaf> That should also be fixed.
09:34:09 <shapr> xerox: The only thing I can remember like that is musasabi's regex arrows, is that what you mean?
09:34:14 * EvilTerran would expect src to use the definitions from the report
09:34:23 <chessguy> oh Cale, there was something i was going to ask you about
09:34:27 <chessguy> let me find the hpaste
09:34:27 <Cale> yeah?
09:34:32 <xerox> shapr: something like reification of arrows.. they outputted their own tree
09:34:43 <dolio> EvilTerran: It does, sometimes. :)
09:34:52 <EvilTerran> dolio, i mean always...
09:35:02 <shapr> xerox: It sounds familiar, but I don't remember.
09:35:22 <ddarius> :t randoms
09:35:24 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
09:35:32 <chessguy> Cale, http://hpaste.org/2508
09:36:01 <shapr> mmm, -XTypeFamilies
09:36:10 <Cale> chessguy: I'm not sure I understand that notation
09:36:27 <chessguy> KPk means white king, white pawn, black king
09:36:29 <ddarius> > take 50 (randoms (mkStdGen 1)) :: [Double]
09:36:30 <lambdabot>  [0.35925462466181596,0.33062336659771935,0.13648524126887446,0.5386400148362...
09:36:48 <chessguy> k = king, q = queen, b = bishop, r = rook, n = knight, p = pawn
09:37:03 <conal> shapr: do you know what's the status on type families?
09:37:30 <Cale> chessguy: Isn't any subset of the initial set of pieces which contains both kings possible?
09:37:30 <xerox> conal: Manuel recently updated the haskellwiki page on them I think
09:37:39 <chessguy> Cale, the tricky part (i think) is counting isomorphic configurations like KPk and Kkp only once
09:37:57 <chessguy> Cale, not quite that simple, because pawns can promote too
09:38:04 <chessguy> Cale, plus the isomorphism problem
09:38:33 * ivant hates the word reification
09:38:42 <conal> xerox: thanks.  looking
09:38:53 <Cale> Oh, right, that does make things trickier. Can all pawns be promoted without any captures?
09:39:15 <EvilTerran> chessguy, so what do you want? a list of all sets of pieces that can be on the board?
09:39:22 <Cale> (I don't think so :)
09:39:29 <EvilTerran> excluding ones where white and black are just swapped?
09:39:30 <chessguy> Cale, not for both sides, certainly
09:39:34 <Cale> Right.
09:39:40 <chessguy> EvilTerran, right, or at least a count
09:40:01 <Cale> That's pretty tricky then.
09:40:02 <chessguy> (i think the two problems are pretty much equivalent)
09:40:04 <hpaste>  oerjan pasted "determinant attempt" at http://hpaste.org/2516
09:40:24 <oerjan> tested only with 2*2 identity matrix
09:40:45 <oerjan> oh, and it uses list of lists
09:41:00 <Cale> You could create some rather nice quickcheck properties for det :)
09:41:01 <oerjan> oh wait
09:41:36 <oerjan> should subtract, not add
09:43:38 <dolio> Hmm, Haskell won't be ready for prime time until it has non-recursive let.
09:43:40 <chessguy> Cale, talking to some people elsewhere about the problem, i think we came up with an algorithm to do it, but i don't have a concise description of it yet
09:43:41 <ddarius> byorgey and I produced almost identical code independently which is probably a good thing
09:43:55 <ddarius> dolio: It does have a non-recursive let.
09:44:17 <hpaste>  oerjan annotated "determinant attempt" with "second attempt" at http://hpaste.org/2516#a1
09:44:18 <Cale> chessguy: Well, you'd have to classify minimal sets of captures necessary to allow the promotion of pawns.
09:44:44 <dolio> ddarius: It does? do?
09:44:46 <Cale> chessguy: Of course it's doable via brute force -- just not in a reasonable amount of time :)
09:44:52 <EvilTerran> why is a non-recursive let necessary?
09:45:00 <chessguy> Cale, :)
09:45:02 <ddarius> dolio: do works, yep.  There is also nesting lets and lambdas.
09:45:22 <dolio> EvilTerran: Someone wants to write: 'let x = foo * x in let x = bar * x in baz x'
09:45:30 <ddarius> There are admittedly minor issues with polymorphism then.
09:45:41 <dolio> EvilTerran: And not have fixpoints all over.
09:45:57 <ddarius> dolio: That doesn't say why it would be necessary.
09:46:02 <EvilTerran> dolio, **shrug**. some people want OO, too.
09:46:44 <dolio> I don't think it's necessary. But it's being requested.
09:47:03 <dolio> I'm not big on naming each intermediate piece of an arithmetic expression, myself.
09:47:10 <malcolmw> Is there anyone from galois around?
09:47:14 <chessguy> that's a LOT different from saying "haskell isn't ready for prime-time until the request is granted"
09:47:19 <chessguy> @seen glguy
09:47:19 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
09:47:27 <glguy> ?
09:47:40 <chessguy> malcomw, glguy. glguy, malcomw
09:47:52 <malcolmw> glguy: you work for galois?
09:47:59 <dolio> chessguy: I like hyperbole, though. :)
09:48:02 <glguy> malcolmw: yeah
09:48:08 <EvilTerran> me neither. especially not naming several different things with the same name. i can see no compelling reason for that to be useful, let alone necessary.
09:48:23 <malcolmw> glguy: I was wondering if SyntaxNinja is ill, or away, or something
09:48:24 <chessguy> dolio, hyperbole is the worst form of linguistic expression ever invented
09:48:55 <glguy> malcolmw: he was on a business trip
09:49:14 <malcolmw> glguy: due back before tomorrow noon?
09:50:41 <dolio> EvilTerran: If I were to guess wildly, I'd say it comes as a habit from C code like 'x += 5; x *= 10 ; ...'. But maybe people write Scheme code with nested lets like that, too (doubt it).
09:50:44 <oerjan> chessguy: nice :D
09:50:50 <Cale> chessguy: It reminds me of the problem of determining the number of valid n-by-n go positions (say, irrespective of which player's turn it is)
09:51:09 <Cale> chessguy: It's easy to get bounds, but hard to actually pin down.
09:51:24 <sorear> @remember chessguy dolio, hyperbole is the worst form of linguistic expression ever invented
09:51:24 <lambdabot> Done.
09:51:24 <chessguy> oerjan, hm?
09:51:35 <oerjan> chessguy: the hyperbole remark
09:51:36 <chessguy> oh
09:51:36 <EvilTerran> it seems to me it'd be easier to expess the number of possible go positions algebraically, but probably harder to actually work out
09:52:10 <chessguy> Cale, yeah, we had a rough upper bound last night of like 8 billion
09:52:13 <EvilTerran> chessguy, have you considered sending an email off to the Deep Blue people? they might've already worked this one out
09:52:22 <chessguy> ha!
09:52:28 <Cale> > 3^(19*19)
09:52:29 <lambdabot>  1740896506590319279071882380705643679466027249502635411948281187068010516761...
09:52:32 <chessguy> if so, they probably wrote it down and ate it
09:52:43 <Cale> There are fewer than that number of valid go boards :)
09:52:45 <EvilTerran> ;)
09:53:08 <EvilTerran> > length $ show $ 3^(19*19)
09:53:09 <lambdabot>  173
09:53:09 <chessguy> > length . show $ 3^(19*19)
09:53:11 <lambdabot>  173
09:53:11 <Cale> > 2^(19*19)
09:53:13 <lambdabot>  4697085165547666455778961193578674054751365097816639741414581943064418050229...
09:53:13 <EvilTerran> hah!
09:53:13 <chessguy> lol
09:53:13 <conal> is there a language extension (as in LANGUAGES pragma) for GADTs?
09:53:19 <Cale> and at least that many
09:53:40 <chessguy> > length . show $ 2^(19*19)
09:53:42 <lambdabot>  109
09:54:00 <dolio> conal: Not that I've come across.
09:54:04 <Cale> Only 64 orders of magnitude ;)
09:54:21 <wli> > 381 * logBase 10 2
09:54:22 <lambdabot>  114.69242834797681
09:54:28 <dolio> It's probably the most conspicuous feature left off the list.
09:54:31 <Japsu> > log (2^(19*19)) / log 10
09:54:32 <EvilTerran> > 19 * 19 * log 3 / log 10
09:54:33 <conal> dolio: thanks.  use the deprecated OPTIONS then?
09:54:33 <lambdabot>  172.24077295379814
09:54:34 <lambdabot>  108.6718284346972
09:54:43 <monochrom> "x += 5; x *= 10" looks like two-address assembly code. Someone hasn't even learned fortran.
09:54:43 <EvilTerran> > 19 * 19 * log 2 / log 10
09:54:45 <lambdabot>  108.6718284346972
09:54:52 <dolio> OPTIONS_GHC, probably.
09:55:08 * EvilTerran prefers that version. fewer xbawks hueg numbers.
09:55:15 <EvilTerran> (or the logBase version)
09:55:22 <wli> > 361 * logBase 10 2
09:55:23 <lambdabot>  108.67182843469719
09:55:41 <wli> > ceiling $ 361 * logBase 10 2
09:55:42 <lambdabot>  109
09:58:04 <chessguy> ok, back to the real world
09:58:10 <gkr> I compile a .hs, with -package WASH option. If I upload the binary to any webserver (maybe where it's not installed GHC), will it work?
09:58:18 <sorear> conal: ghc crew went on a non-standard-LANGUAGE-adding-binge lately
09:58:32 <sorear> gkr: yes, if the server has a compatible libc
09:58:41 <sorear> gkr: so linux/linux will probably work
09:59:11 * sorear notes that he's doing this for hpaste
09:59:54 <sorear> conal: because of #1653 I can't easily tell you what the option is however
10:00:13 * gkr so wonders why he's coding PHP
10:00:23 <sorear> GET HIM!
10:00:49 <gkr> :-)
10:00:55 <sorear>     Illegal generalised algebraic data declaration for `X'
10:00:55 <sorear>       (Use -XGADTs to allow GADTs)
10:01:03 <sorear> conal: managed to get GHC to tell me
10:02:08 <EvilTerran> -X?
10:02:15 <sorear> -X!
10:02:19 <conal> sorear: thanks.
10:02:44 <sorear> EvilTerran: {-# OPTIONS_GHC -XFooBarBaz #-} is equivalent to {-# LANGUAGE FooBarBaz #-}
10:02:44 * EvilTerran thought the relevant flag would've been -f<something>
10:02:55 <sorear> -f flags are so 2006
10:02:58 <EvilTerran> ahh. that makes sense, too.
10:03:02 <sorear> :)
10:03:23 <sieni> @remember sorear -f flags are so 2006
10:03:23 <lambdabot> Done.
10:03:35 <sieni> @quote 2006
10:03:35 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
10:03:38 <sieni> @quote 2006
10:03:38 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
10:03:42 <sieni> @quote 2006
10:03:43 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
10:03:48 <sieni> @quote flags
10:03:48 <lambdabot> shapr says: GHC has more flags than the UN
10:03:52 <sieni> @quote flags
10:03:52 <olsner> @quote 2007
10:03:52 <lambdabot> No quotes match. The more you drive -- the dumber you get.
10:03:52 <lambdabot> shapr says: GHC has more flags than the UN
10:04:00 <sieni> @quote -f
10:04:01 <lambdabot> dons says: -fglasgow-exts ~= -fhaskell-prime
10:04:04 <sieni> @quote -f
10:04:04 <lambdabot> ghc says: Use -fglasgow-exts to allow GADTs
10:04:10 <dolio> @quote -f.flags
10:04:10 <lambdabot> sorear says: -f flags are so 2006
10:04:18 <sieni> ahh
10:04:27 <EvilTerran> @help quote
10:04:27 <lambdabot> quote <nick>
10:04:27 <lambdabot> remember <nick> <quote>
10:04:27 <lambdabot> Quote somebody, a random person, or save a memorable quote
10:04:34 <sorear> @quote sorear
10:04:35 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
10:04:35 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
10:04:38 <sorear> @quote sorear
10:04:38 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
10:05:27 <conal> sorear: what version of GHC do you have?  my ghc-6.7.20070802 doesn't seem to know -XGADT
10:06:11 <dolio> -XGADTs
10:06:38 <conal> dolio: tx
10:08:51 <sorear> 0829 :)
10:09:09 <conal> weird.  when i use {-# OPTIONS_GHC -XGADTs #-} in a source file, ghc swallows it but won't parse my GADT.  does that option work for anyone?
10:09:19 <wli> I don't seem to be able to get gcc to build in current darcs.
10:09:27 <xerox> conal: use {-# LANGUAGE XGADTs #-}
10:09:49 <wli> ghc rather
10:09:50 <xerox> hehe, GADTs not XGADTs :)
10:10:51 <monochrom> How many computer scientists does it take to enable GADT in GHC?
10:11:08 <wli> monochrom: gamma
10:11:08 <conal> "{-# LANGUAGE GADTs #-}" doesn't work for me either: "cannot parse LANGUAGE pragma".
10:11:10 <EvilTerran> @users
10:11:10 <lambdabot> Maximum users seen in #haskell: 392, currently: 377 (96.2%), active: 18 (4.8%)
10:11:22 <EvilTerran> 377, monochrom
10:11:26 <conal> Can anyone confirm {-# LANGUAGE GADTs #-} ?
10:11:56 <sorear> works for me
10:12:05 <conal> sorear: thanks.  which ghc?
10:12:11 <sorear> {-# LANGUAGE GADTs #-}
10:12:11 <sorear> data X where Y :: X
10:12:17 <sorear> GHCi, version 6.7.20070829: http://www.haskell.org/ghc/  :? for help
10:12:18 <lambdabot> Title: The Glasgow Haskell Compiler
10:12:22 <EvilTerran> @docs Language.Haskell.Extensions
10:12:22 <lambdabot> Language.Haskell.Extensions not available
10:12:26 <EvilTerran> @docs Language.Haskell.Extension
10:12:26 <lambdabot> Language.Haskell.Extension not available
10:12:43 <sorear> EvilTerran: that module is obsolete, it's a string now
10:13:07 <conal> sorear: that's a pretty recent ghc!  maybe my 0802 isn't cutting edge enough.
10:13:38 * sorear also has 0828 :(
10:14:00 * EvilTerran is on 6.6.1... i get GADTs with -fglasgow-extension...
10:14:01 <EvilTerran> *s
10:14:35 <conal> EvilTerran: that's how i was getting it.  thought i'd get with the times
10:14:44 <EvilTerran> meh.
10:15:04 <wli> nativeGen/MachCodeGen.hs:111:27: Not in scope: `assignReg_I64Code'
10:17:14 * sorear doesn't get that error
10:17:30 <wli> I've no idea what hit me.
10:18:38 <sorear> wli: cpu?
10:18:43 <wli> I think something is confused as to whether it's doing a 32-bit or 64-bit build.
10:18:52 <wli> But have NFI where to look or what to do.
10:18:56 <sorear> wli: looks like that function is only defined on ppc, x86, and sparc
10:19:13 <wli> sorear: EM64T
10:20:12 <wli> 32-bit userspace (albeit with some 64-bit libs)
10:29:56 * wli tries with-gcc=
10:30:01 * wli tries with-gcc="gcc -m32"
10:33:42 <ihope> Is there a name for the function join . lift :: (Monad (t m), MonadTrans t, Monad m) =>
10:33:49 <ihope> Er.
10:33:59 <Saizan> ?type join . lift
10:34:01 <lambdabot> forall a (m :: * -> *) (t :: (* -> *) -> * -> *). (Monad (t m), MonadTrans t, Monad m) => m (t m a) -> t m a
10:34:08 <ihope> Yes, with that type :-)
10:34:35 <_roconnor> @hoogle m (t m a)  -> t m a
10:34:35 <lambdabot> Prelude.id :: a -> a
10:34:35 <lambdabot> Prelude.asTypeOf :: a -> a -> a
10:34:35 <lambdabot> Prelude.const :: a -> b -> a
10:34:43 <Saizan> @pl join . lift
10:34:43 <lambdabot> join . lift
10:34:46 <ihope> Does that have a name? I've been calling it halfJoin.
10:34:55 <Saizan> i don't think so
10:35:11 <ihope> Though I guess joinLift might be a better name.
10:35:32 <_roconnor> or liftJoin
10:35:59 <sorear> @users
10:35:59 <lambdabot> Maximum users seen in #haskell: 392, currently: 383 (97.7%), active: 12 (3.1%)
10:36:55 <ihope> Is it a lift that joins or a join that lifts? :-)
10:37:28 <ihope> I guess it's more of a join that lifts, making liftJoin better, yes.
10:38:27 <wli> After this I suppose I should try a 64-bit build.
10:38:39 <roconnor> @type join lift
10:38:41 <lambdabot>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
10:38:41 <lambdabot>     When matching the kinds of `t :: (* -> *) -> * -> *' and
10:38:57 <ihope> @type lift join
10:38:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => t ((->) (m (m a))) (m a)
10:39:08 <ihope> Oh, how wonderful.
10:39:38 <idnar> heh
10:39:44 <roconnor> ihope: that almost makes sense to me.
10:39:55 <ihope> What almost makes sense?
10:40:00 <roconnor> lift join
10:40:06 <ihope> Indeed.
10:40:32 <ihope> It's what you use in what's not quite a Reader monad.
10:41:29 <ihope> So, are you guys interested in yet another delimited continuation implementation?
10:47:20 <wli> --with-gcc="gcc -m32" didn't help.
10:54:00 <sioraiocht> so, I bought "Introduction to Functional Programming using Haskell" because it's the basis for a lot of the cirriculum at my university, I have to say I'm not a fan.
10:54:01 <sioraiocht> at all
10:54:50 <flux> well, I guess you'll need to pass the course anyway :)
10:54:57 <flux> what's your greatest gripe?
10:55:07 <sioraiocht> I don't like his pseudo-haskell notation
10:55:11 <dwx> sounds like a good university
10:55:44 <flux> pseudo haskell sounds very pseudo, considering some people may consider pseudo code
10:56:13 <sioraiocht> I don't have to take the course, but they're listing it as a coreq for something else I want to take, I'm praying the won't make me, as I'm more than qualified to test out of a class that says "functional programming, no previous programming experience required"
10:57:43 <sioraiocht> but anyway, i bought the book for the class to see what it was like
10:58:22 <sioraiocht> and he uses this weird notation for functions that is sort of like but really quite dissimilar to haskell
10:58:23 <sioraiocht> =p
10:59:00 <evir> Why is it called "using Haskell" then?
10:59:04 <evir> And how does it look like? :-)
10:59:32 <sioraiocht> he does talk about haskell specific programming
10:59:45 <sioraiocht> but he bolds and italicises things
10:59:57 <sioraiocht> and uses arrows and symbols that you could only get by using latex
10:59:57 <Lemmih> @seen dcoutts
10:59:57 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 3h 30m 49s ago.
11:00:14 <flux> sioraiocht, well, it's still 1:1 mappable to haskell
11:00:17 <flux> sioraiocht, right?
11:00:25 <sioraiocht> flux: yes, so far
11:00:47 <sioraiocht> but then he transitions without word from talking about functional programming to talking about haskell specific stuff
11:01:01 <sioraiocht> I mean, richard bird knows his stuff about both, no doubt about it, I just don't think it's very clear
11:01:13 <flux> it is infact quite common to see pdf-versions of haskell-programs using nicer symbols
11:01:15 <sioraiocht> if this were my first book in programming, which it is designed to be, I would not be happy
11:01:25 <sioraiocht> flux: that drives me nuts
11:01:38 <flux> sioraiocht, try to get over it ;)
11:02:00 <sioraiocht> I guess i'll have to, hehe
11:02:10 <flux> I supppose haskell would use those symbols if they were easier to enter and in ascii
11:02:21 <flux> I think there's a mode for Emacs that displays the code using those symbols
11:02:28 <osfameron> "nicer" ?
11:02:46 <flux> which one is nicer arrow, -> or the actual arrow character?
11:02:53 <osfameron> I hate "nice" typography, when it clearly has *nothing* to do with the way that you actually write the code
11:03:15 <sioraiocht> osfameron: yay!
11:03:30 <sioraiocht> flux: really? I don't care, I want the one that is used in source code
11:03:34 <sioraiocht> hehe
11:04:07 <sioraiocht> I mean, I guess I need to get used to it if I ever take a class that richard bird teaches..
11:05:58 <monochrom> I agree to disagree.
11:05:58 <EvilTerran> flux, i don't like the actual arrow character unless the head on it's nearly as big as a > sign. the one in Courier New, fehrinstance, looks pretty ugly IMO.
11:06:56 <sioraiocht> monochrom: with whom? hehe
11:06:56 <EvilTerran> but in general i don't mind a bit of typographical nicety in code snippets in papers and whatnot.
11:07:18 <monochrom> with the foregoing comments on Bird's book, ASCII, etc.
11:07:24 <sioraiocht> ah
11:07:26 <sorear> does it look like lhs2TeX output?
11:07:36 <wli> Probably.
11:08:22 <reilly> i find the nice typography very useful
11:08:24 <EvilTerran> it probably *is* lhs2TeX output. the .lhs > notation's even called "bird tracks"...
11:08:26 <sioraiocht> sorear: yes
11:08:34 <osfameron> reilly: why "useful"?
11:08:36 <johnnowak> i find it useless and distracting
11:08:48 <reilly> easier to scan visually
11:09:35 <monochrom> I find programmers picky on lexical matters and sloppy on semantics matters.
11:09:54 * sorear invokes Wadler's Law
11:10:18 <wli> Remind me of Wadler's law again.
11:10:24 <EvilTerran> i like the replacement of ``s with bold. that one makes a big difference, IMO.
11:10:31 <monochrom> hehehe
11:10:46 <osfameron> monochrom: that's maybe because syntax is easy to define whereas... actually, I still don't even really know what "semantics" means...
11:11:09 <sioraiocht> Semantics refers to aspects of meaning, as expressed in language or other systems of signs.
11:11:14 <reilly> semantics means means
11:11:20 <sioraiocht> that's wikipedia, not me =)
11:11:26 <osfameron> yeah - that's what I thought... but I don't know what it means :-)
11:11:30 <johnnowak> EvilTerran: sure, that's fine. but replacing ascii strings with special characters is bordering on downright stupid in my opinion when used in something aimed at new users of haskell
11:12:23 <reilly> hmmm .... ever used APL?
11:12:41 <johnnowak> no, I haven't
11:12:42 <EvilTerran> i don't mind, say, -> replaced with \rarr, tbh. as long as it's easy to figure out what characters are being replaced, it's fine by me.
11:12:59 <osfameron> rarr!
11:13:03 <osfameron> oh, not that kind of rarr
11:13:16 <reilly> literal rarr
11:13:29 <monochrom> Anyway, Wadler's law is at http://www.haskell.org/haskellwiki/Wadlers_Law
11:13:30 <lambdabot> Title: Wadlers Law - HaskellWiki
11:13:32 <EvilTerran> if you replace, say, ~~ with , i start to get a bit antsy
11:13:36 <reilly> oh, wrong context for \
11:13:57 <puusorsa> the emacs mode made lots of symbols look stupid
11:14:04 <reilly> i like the emacs mode
11:14:13 <osfameron> sorry, someone on another channel says "rarr" as a sort of positive roaring sound...
11:14:14 <pejo> EvilTerran, was the first character two tildes, and the second an a with a ^  above it?
11:14:24 <johnnowak> EvilTerran: It doesn't strike you as some sort of juvenile urge to decorate and prettify?
11:14:26 <EvilTerran> also replacing \ with , "forall." with \forall, etc is fine by me
11:14:26 <shachaf> @rarr!
11:14:27 <lambdabot> Maybe you meant: arr yarr
11:14:39 <EvilTerran> pejo, the second was two tildes one-on-top-of-the-other
11:14:41 <osfameron> yeah!  that kind of thing
11:14:43 <EvilTerran> approximately-equal-to
11:15:00 <reilly> lambda piracy
11:15:12 <sorear> anyways, kosmikus is right-over-there
11:15:35 <sioraiocht> @arr
11:15:36 <lambdabot> Drink up, me 'earties
11:15:37 <sioraiocht> ?
11:15:43 <EvilTerran> johnnowak, programming's an ugly business. suffer us our little forays into beauty. ;)
11:16:09 <johnnowak> you know nothing of beauty philistine!
11:16:18 <osfameron> heh, nice law
11:16:38 <osfameron> though I'd personally be capable of whining for much longer about multi-line strings (or the lack thereof) than about comments :-)
11:18:20 <kosmikus> sorear: where am I?
11:19:00 <sorear> kosmikus: In #haskell.  I was trying with that to stop an argument over the merits of lhs2TeX
11:19:36 <osfameron> does kosmikus defeat lhs2tex?
11:19:44 <monochrom> Actually "xE" was invented first, then "\x->E" later. Thus, it was not the case that "\x->E" was juvenilely beautified to "xE", but rather the case that "xE" was juvenilely asciified to "\x->E". There is a juvenile urge to type everything into the computer.
11:20:04 <osfameron> yeah, who needs those pesky computers
11:20:20 <osfameron> but on the other hand, that's what we work with, and the pretty stuff is maths...
11:20:35 <sioraiocht> regardless of the juvenility or the origins, i can't type the pretty lambda and arrow stuff
11:20:50 <EvilTerran> i'd rather write something on a whiteboard, then drag a highlighter over it to evaluate it
11:21:04 <monochrom> In a #math channel I saw a juvenile asking for this: any computer program to visualize the triangle inequality? I don't want to do it with paper and pencil. Talk about juvenile urges.
11:21:20 <EvilTerran> and you can type all that, with the right input setup
11:21:22 <osfameron> and even if you could on some systems, 90% of the machines you'd want to run it one wouldn't work because of the unicode toolchain being broken somewhere along the line...
11:21:44 <monochrom> "Can programming be liberated from the Plain ASCII File?"
11:22:00 <sioraiocht> no
11:22:02 * psykon stands up for the adoption of utf8 as the only charset
11:22:06 <johnnowak> It's not even anything to do with that. If you're writing Haskell, it should use Haskell's identifiers.
11:22:18 <sioraiocht> yes, that's the point =)
11:22:33 <EvilTerran> this reminds me of something someone said at anglohaskell. "I don't care whether it happens at compile-time or run-time! i don't even care about compilation! i want to tell my computer what i want it to do, and have it happen! don't hassle me with your irrelevant details!"
11:22:48 <monochrom> Anyway, Bird is of the kind who plans his programs on whiteboard or blackboard or paper, not the kind who rushes to the computer. That explains his notational choice.
11:23:13 <osfameron> meh... ascii works, unicode might work...  but yeah it's probably "right" in some way...
11:23:44 <shapr> pretty lambda!
11:23:55 <EvilTerran> similarly, given that, in haskell, "->" means "right-pointing single-stalk arrow", there's no harm in representing it that way, imo
11:24:41 <EvilTerran> and don't hassle me with your irrelevant details of how it's stored on disc! ;]
11:25:09 <monochrom> I agree that sample code on paper should equal code you enter to the computer. I just wish we can go back and re-define Haskell source code to use symbols.
11:25:33 <EvilTerran> we need latex2lhs!
11:25:37 <osfameron> yeah!
11:25:39 <shapr> Why not use a pretty lambda sort of emacs minor mode?
11:25:41 <kosmikus> sorear: I have no problems with people disliking lhs2tex, nobody is forced to use it ...
11:25:54 <EvilTerran> or image2lhs, even better!
11:26:00 <shapr> But lhs2TeX is just so cool!
11:26:15 <shapr> I hear that sjanssen is writing a blog server that will use it for its native format.
11:26:27 <osfameron> kosmikus: no, but (at least where I started following this conversation) was about an *introductory* book using it
11:26:38 <taruti> kosmikus: a way to combine lhs2tex and haddock in an intuitive manner would be nice.
11:26:44 <osfameron> which is annoying if they don't say (really really clearly) by the way please type \rarr as "->"
11:27:30 <monochrom> Regarding book code not recognized by computers, xE is not the biggest concern. I find "type X s a = s -> (a,s); instance Monad (X s) where ..." far more morbid.
11:27:38 <shapr> The problem as I see it is that haddock is html-only, and lhs2TeX is print-only. I want something that does both!
11:28:10 <SamB> is haddock html-only?
11:28:11 <kosmikus> me too
11:28:29 <taruti> shapr: haddock has many formats
11:28:42 <kosmikus> osfameron: it's a matter of taste, isn't it?
11:28:46 <sorear> shapr: including docbook iirc
11:29:48 <osfameron> kosmikus: No.  It's a matter of pedagogy.
11:30:04 <osfameron> kosmikus: If you show one thing, you can't expect a beginner to do another.
11:30:27 <shachaf> monochrom: That's not Haskell, but it gets the idea across more cleanly than a newtype. What's wrong with it?
11:30:27 <evir> "How do I type the <= symbol?"
11:30:51 <monochrom> You can't test it.
11:30:52 <osfameron> kosmikus: for academic papers, I won't argue.  If I had to write an academic paper, I'd do it *exactly* how everyone else did it, just to fit in to the culture.  But that's not the same thing as teaching it.
11:31:13 <monochrom>  ?
11:31:19 <kosmikus> osfameron: well, I probably won't convince you. but I would never have liked to learn from a book using typewriter.
11:31:31 <kosmikus> that's one of the reasons why I prefer the Bird book over Thompson, for instance.
11:31:52 <evir> monochrom: That's what I mean. You have these printed in the book and lots of beginner students will sit there and try typing these into their editor.
11:31:58 <osfameron> kosmikus: maybe not.  But you would still need a page or two (with maybe a nice table) telling you how to *type* the things.  If they had that, the rest of it is taste...
11:32:13 <osfameron> SOE does not have such a table (I think... I'm in Vienna, can't check my copy)
11:32:14 <kosmikus> osfameron: which book were you talking about, btw?
11:32:36 <kosmikus> SOE.
11:32:51 <sioraiocht> I prefer the Thompson...I just started looking at the Bird book and the notation drives me INSANE.   Beginner programmers would be so confused
11:32:53 <osfameron> kosmikus: the discussion was about the Bird book I think.  But I've seen the "nice" notation used in several tutorials (pdf etc) without any comment on how to type them
11:33:04 * Igloo wants concrete syntax in my programming books
11:33:24 <Igloo> Type theory books etc it doesn't matter for the most part
11:33:41 <sioraiocht> Igloo: agreed, but Birds book is supposed to be an introduction to programming
11:33:50 <kosmikus> osfameron: I agree that introductory books should have a table. Hutton's book has one.
11:34:11 <sioraiocht> and don't get me started on the greek symbols for type variables..
11:34:55 <Igloo> sioraiocht: I can't remember what Bird does, but I'd want it to use concrete syntax
11:34:57 <kosmikus> I don't think there'll be a consensus here. People have different taste. Academic papers are also often written in tt, not all use lhs2TeX or similar, so there's no need to fit in with a culture.
11:35:11 <sioraiocht> Igloo: he uses lhs2tex
11:35:34 <kosmikus> I prefer typeset code, others don't. Some people think Scheme syntax is the most beautiful and most readable syntax of all, I don't. So what?
11:35:51 <kosmikus> sioraiocht: actually, I don't think Bird uses lhs2TeX.
11:36:04 * johnnowak thinks scheme syntax is the most beautiful of all
11:36:05 <dcoutts> Lemmih: pong
11:36:06 <coffeemug> > do { x <- [1, 2, 3] }
11:36:07 <lambdabot>  Parse error
11:36:14 <coffeemug> > do { x <- [1, 2, 3]; }
11:36:14 <lambdabot>  Parse error
11:36:17 <sioraiocht> kosmikus: oh, well it looks a lot like it, hehe
11:36:19 <kosmikus> sioraiocht: he just typesets the code himself. I think I once explained lhs2TeX to Bird, and that certainly was *after* he wrote the book.
11:36:27 <johnnowak> unless we're including Joy or Factor
11:36:35 <sioraiocht> kosmikus: are you at Oxford?
11:36:55 * monochrom thinks Haskell has to most beautiful semantics of all.
11:36:56 <kosmikus> sioraiocht: no, but the community is (relatively) small, people meet regularly.
11:37:51 <kosmikus> sioraiocht: I know for certain that Hutton uses lhs2TeX.
11:38:03 <johnnowak> Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
11:38:12 <kosmikus> I'm not sure about SOE.
11:38:16 <monochrom> hahahaha
11:38:16 <osfameron> johnnowak: heh
11:38:26 <johnnowak> Or.. hexadecimal.
11:38:30 <monochrom> @remember johnnowak Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
11:38:30 <lambdabot> Done.
11:38:49 <sioraiocht> @quote Oxford
11:38:49 <johnnowak> yes, preserve my spelling error
11:38:49 <lambdabot> ghc says: Can't represent Oxford brackets
11:38:56 <sioraiocht> @quote Oxfor
11:38:56 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
11:39:03 <Lemmih> dcoutts: Did you mean to replace '#define USE_CAIRO' with 'define USE_CAIRO' in your last gtk2hs patch?
11:39:14 <dcoutts> Lemmih: no, thanks :-)
11:39:33 <dcoutts> Lemmih: I was just testing that it worked in the ! USE_CAIRO' case
11:40:56 <dcoutts> Lemmih: thanks, fixed.
11:45:32 <kosmikus> taruti, shapr: actually, I wanted to combine lhs2TeX and Haddock for a long time already, so I'm going to turn this into an experimentation project here at Utrecht. So, if by coincidence, there's an UUST master student on this channel looking for an experimentation project, please contact me ;)
11:47:16 <Gwern-away> I have a sort of algorithm question (I'd answer this directly by testing, but I can't seem to write the code properly). Suppose I wish to select a random line in a file (or a random member of a list), and I don't want to need to know the length (the obvious solution being to do something like 'list !! (random 1, (length list)'). I found a ruby description of an algorithm which basically runs like this: select the first line with probability 1/2; ...
11:47:29 <Gwern-away> ... if it fails, test the second with probability 1/3, if it fails, test the third with probability 1/4 and so on until you've successfully returned an item. My question is, would this work on infinite lists or is there some subtlety which means that in general it has to work on finite lists?
11:48:52 <ari> That's not anywhere close to a uniform distribution if you're looking for one, but otherwise there's no reason why it doesn't work for lists of arbitrary length
11:49:01 <int-e> Gwern-away: not quite. the idea is to scan through the file sequentially; you pick the first line; *replace* it by the second line with probability 1/2, then by the third with probability 1/3 and so on.
11:49:37 <Saizan> yeah, you need to give each element a chance :)
11:50:04 <int-e> Gwern-away: in particular no matter what you do you'll have to scan through the whole file - you need to know the file length (in lines) in the end to have a chance to be fair.
11:50:08 <Gwern-away> ari: well, as I understand it, it is impossible to have the same non-zero probability for each member of an infinite list
11:50:21 <drigz> Gwern-away: http://osfameron.vox.com/library/posts/page/1/
11:50:37 <int-e> Gwern-away: for infinite lists ... right you'll have to fix a non-uniform distribution
11:50:37 <Gwern-away> int-e: I'm not entirely interested in complete fairness, although that would be nice
11:51:44 <balodja> http://www.nyx.net/~gthompso/self_hask.txt
11:51:53 <Gwern-away> drigz: interesting. although it could probably be rewrittten to have a generator as an argument so you avoid the IO sig, I think...
11:51:55 <balodja> Is there more consice quine? :)
11:52:52 <ari> Gwern-away: Then assign a zero probability to each item and pick one ;)
11:52:55 <int-e> the simplest thing to do for infinite lists is probably to fix a number n such that the numbers 1..n occure with probability 1/2 and use an exponential distribution (pick the first element with probability x, otherwise pick one of the other elements - where x depends on n. (x = 1 - (1/2)^(1/n) ~= 1 - 1/(2n))
11:54:01 <Gwern-away> ari: I shall assign a zero probability to taking that algorithm seriously....
11:54:14 <drigz> @google haskell quine
11:54:16 <lambdabot> http://www.ipl.t.u-tokyo.ac.jp/~scm/
11:54:16 <lambdabot> Title: Shin-Cheng Mu
11:54:20 <dwx> is there a function f :: [a] -> Bool that says if the list if finite or infinite?
11:54:29 <int-e> err. ~= 1/(2n) - sorry.
11:54:43 <sjanssen> dwx: no, see the halting problem ;)
11:54:52 <Gwern-away> dwx: sure there is. evaluate each element, and if the function halts, it is finite
11:54:52 <drigz> balodja: http://www.iis.sinica.edu.tw/~scm/?p=5
11:54:59 <Gwern-away> if it never halts, then it's infinite
11:54:59 <lambdabot> Title: A Haskell Quine | Shin-Cheng Mu
11:55:17 <balodja> drigz: :)
11:55:35 <drigz> it's just that little bit more elegant
11:55:39 <int-e> so  f xs = last xs `seq` True ?
11:55:48 <Gwern-away> int-e: does it have to be an exponential distribution? or is the important thing that it converges on 0?
11:56:00 <int-e> (and f [] = True; it never gives a false answer.)
11:56:39 <sjanssen> @type foldr seq True
11:56:41 <lambdabot> forall a. [a] -> Bool
11:56:53 <sorear> > ap(++)show"ap(++)show"
11:56:54 <lambdabot>  "ap(++)show\"ap(++)show\""
11:56:58 <sjanssen> ah, that isn't quite right
11:57:11 <int-e> Gwern-away: it doesn't have to be exponential; you can pick any probabilities p_0, p_1, ... such that sum(p_i, i=0 to oo) = 1
11:57:50 <osfameron> well, the algorithm I used will work for infinite lists, it will just take a little time to return a result
11:58:02 <int-e> Gwern-away: Which implies, among other things, that the p_i will go to 0 as i goes to infinity
11:58:27 <Gwern-away> ah. I sort of see
12:04:04 <Saizan> osfameron: how can it work for infinite lists if you recurse on the tail everytime? (without producing any constructor)
12:06:50 <drigz> i thought he was using 'a little' to mean 'infinite'
12:07:01 <osfameron> yeah, sorry, standard facetious comment...
12:08:51 <Saizan> ah sorry :)
12:10:14 <osfameron> no no, sorry from me, I was one make the stupid comment :-)
12:11:02 <olsner> given infinite time, will a non-terminating program terminate?
12:11:08 <wli> It looks like I've got a fresher ghc now.
12:12:47 <wli> GHCi, version 6.7.20070830: http://www.haskell.org/ghc/  :? for help
12:12:48 <lambdabot> Title: The Glasgow Haskell Compiler
12:13:22 <Mr_Awesome> http://rafb.net/p/Dx65qW24.html  <-- could someone help me decipher the meaning of this error?
12:13:24 <lambdabot> Title: Nopaste - No description
12:14:09 <drigz> Mr_Awesome: it's expecting a value of type fac GHC.Base.Unit GHC.Base.Unit but you put a '1'
12:14:28 <drigz> so it tries to parse the literal '1' as that, but realises that it's not numerical type
12:14:44 <wli> @hoogle on
12:14:45 <Mr_Awesome> i see. why does it expect GHC.Base.Unit?
12:14:45 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
12:14:45 <lambdabot> System.Console.Readline.onNewLine :: IO ()
12:14:45 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
12:14:46 <ari> Mr_Awesome: (::) specifies types, (:) constructs lists
12:14:56 <monochrom> I haven't had experience with infinite time. I doubt anyone does. As a corollary, no one knows infinite time enough to theorize it. Without a verified theory, it's armchair philosophy to ask questions of it.
12:15:22 <Mr_Awesome> ari: damn ml... thanks :)
12:16:33 <ari> So... 1 == () in ghc types?
12:16:52 <sjanssen> @type () :: 1
12:16:54 <lambdabot>     Couldn't match expected type `GHC.Base.Unit'
12:16:55 <lambdabot>            against inferred type `()'
12:17:02 <sjanssen> ari: they seem to be different types
12:17:07 * ari sees
12:17:15 <drigz> @type 2 :: 1
12:17:17 <lambdabot>     No instance for (Num GHC.Base.Unit)
12:17:17 <lambdabot>       arising from the literal `2' at <interactive>:1:0
12:18:00 <sjanssen> @type () :: 2
12:18:02 <lambdabot> Only unit numeric type pattern is valid
12:18:05 <Mr_Awesome> btw, is that a decent way to create a list of factorials?
12:18:22 <sjanssen> > scanl1 (*) [1..]
12:18:23 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
12:18:29 <monochrom> For pastes I recommend...
12:18:31 <monochrom> @paste
12:18:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:18:48 <monochrom> It does Haskell highlighting.
12:18:56 <sjanssen> Mr_Awesome: yeah, your code is okay -- of course there are more idomatic ways ;)
12:19:18 <Mr_Awesome> sjanssen: maybe i need to become more familiar with the stdlib :)
12:19:27 <Mr_Awesome> monochrom: ah, ill keep that in mind
12:19:29 <idnar> @src scanl1
12:19:29 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
12:19:30 <lambdabot> scanl1 _ []     =  []
12:19:58 <byorgey> > fix ((1:) . zipWith (*) [2..])
12:20:00 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
12:20:01 <Mr_Awesome> @src scanl
12:20:01 <lambdabot> scanl f q ls = q : case ls of
12:20:01 <lambdabot>     []   -> []
12:20:01 <lambdabot>     x:xs -> scanl f (f q x) xs
12:20:07 <sjanssen> Mr_Awesome: yeah, you should study the Prelude, it's pretty small and packed with useful stuff
12:20:59 <idnar> ergh
12:21:04 <idnar> can't wrap my head around that definition of scanl1
12:21:13 <takamura> hi
12:21:13 <idnar> @unpl scanl f x xs
12:21:13 <lambdabot> scanl f x xs
12:21:24 <idnar> @pl scanl f x xs
12:21:24 <lambdabot> scanl f x xs
12:21:30 <takamura> :t scan1
12:21:32 <lambdabot> Not in scope: `scan1'
12:21:32 <sjanssen> idnar: do you know 'foldl'?
12:21:38 <takamura> :t scanl1
12:21:40 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
12:21:40 <idnar> er, yes, I guess that wouldn't do anything
12:21:43 <monochrom> Don't wrap your head around it. Wrap it around your head. I.e., Immerse yourself in it.
12:21:43 <idnar> sjanssen: more or less
12:21:57 <byorgey> scanl1 is just like scanl, except it uses the first list element as the starting point instead of a user-supplied value
12:22:00 <monochrom> Immersion is the proven way to learn foreign languages.
12:22:04 <idnar> oh wait, I see my problem
12:22:11 <idnar> I read the scanl in the definition as scanl1
12:22:14 <sjanssen> idnar: scanl1 is just foldl1, but it returns a list of the immediate results
12:22:32 * idnar puts his glasses on
12:22:39 <Mr_Awesome> @src scanr
12:22:40 <lambdabot> scanr _ q0 []     =  [q0]
12:22:40 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
12:22:40 <lambdabot>     where qs@(q:_) = scanr f q0 xs
12:22:53 <idnar> makes a lot more sense when I read the definition correctly ;)
12:23:11 <byorgey> spending time in #haskell is like being a foreign exchange student! =)
12:23:21 <Nafai> byorgey: Heh.  No kidding!
12:23:42 <takamura> yes, I learned a lot of English here :)
12:24:51 <dmead_> > -0 == +0
12:24:51 <lambdabot>  Parse error
12:24:53 <Mr_Awesome> > scanl (*) 1 [1..]
12:24:55 <dmead_> hah
12:24:55 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
12:25:08 <dmead_> ?src scanl
12:25:08 <lambdabot> scanl f q ls = q : case ls of
12:25:09 <lambdabot>     []   -> []
12:25:09 <lambdabot>     x:xs -> scanl f (f q x) xs
12:25:36 <dmead_> scanl is just a foldmap right?
12:26:00 <Mr_Awesome> > scanr (*) 1 [1..]
12:26:03 <lambdabot>  Exception: stack overflow
12:26:08 <Mr_Awesome> whee :)
12:26:34 <takamura> now lambdabot is dead?
12:26:43 <shachaf> @botsnack
12:26:44 <lambdabot> :)
12:26:51 <Japsu> takamura: why would it be? :)
12:26:55 <Mr_Awesome> take 5 $ scanr (*) 1 [1..]
12:27:05 <Mr_Awesome> > take 5 $ scanr (*) 1 [1..]
12:27:08 <lambdabot>  Exception: stack overflow
12:27:25 <takamura> just kidding
12:27:55 <shachaf> Mr_Awesome: Why do you expect that to work?
12:28:10 <shachaf> > scanr (*) 1 [1..5]
12:28:11 <lambdabot>  [120,120,60,20,5,1]
12:28:33 <shachaf> Mr_Awesome: You can think of scanr as "starting at the end of the list".
12:29:02 <sioraiocht> @src fmap
12:29:02 <lambdabot> Source not found. My mind is going. I can feel it.
12:29:08 <sioraiocht> @src fmap []
12:29:08 <lambdabot> Source not found. My pet ferret can type better than you!
12:29:11 <sioraiocht> grr
12:29:12 <shachaf> @src [] fmap
12:29:12 <lambdabot> fmap = map
12:29:19 <byorgey> > take 1 $ scanr (&&) (False : repeat True)
12:29:20 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[Bool]'
12:29:22 <sioraiocht> okay, what would fmap look like for Maybe?
12:29:25 <sioraiocht> @src Maybe fmap
12:29:26 <lambdabot> fmap _ Nothing       = Nothing
12:29:26 <lambdabot> fmap f (Just a)      = Just (f a)
12:29:29 <sioraiocht> okay
12:29:30 <sioraiocht> that makes sense..
12:29:39 <byorgey> > take 1 $ scanr1 (&&) (False : repeat True)
12:29:40 <lambdabot>  [False]
12:29:45 <shachaf> @instances Functor
12:29:46 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:30:01 <sioraiocht> where is (->) defined?
12:30:07 <shachaf> Control.Monad.Instances
12:30:18 <sioraiocht> @src (->)
12:30:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:30:32 <monochrom> (->) is built-in.
12:30:33 <shachaf> Oh, (->) is the function arrow.
12:30:44 <shachaf> As in :: a -> b.
12:30:57 <sioraiocht> I thought so, how is it an instance of a functor, then?
12:31:00 <shachaf> @src (->) fmap
12:31:00 <lambdabot> fmap = (.)
12:31:18 <sioraiocht> *head*
12:31:20 <sioraiocht> *hit*
12:31:23 <sioraiocht> *keyboard*
12:31:30 <Mr_Awesome> hahaha
12:31:49 <monochrom> @djinn (a->b) -> ((a->r) -> (b->r))
12:31:49 <lambdabot> -- f cannot be realized.
12:32:01 <monochrom> Oh, typo
12:32:07 <sjanssen> some believe that (.) should be replaced with fmap
12:32:08 <monochrom> @djinn (a->b) -> ((r->a) -> (r->b))
12:32:09 <lambdabot> f a b c = a (b c)
12:32:19 <monochrom> That is (.).
12:32:29 <osfameron> huh?  what is:   (->) fmap     ?
12:32:33 <shachaf> Yes, and also map.
12:32:49 <osfameron> :t -> fmap      -- says  parse error on input `->'
12:32:50 <shachaf> osfameron: It means for the (r ->) Functor.
12:32:51 <lambdabot> parse error on input `->'
12:33:16 <shachaf> osfameron: @src behaves differently for instances.
12:33:31 <monochrom> "(->) fmap" means "find me the fmap definition for (->)". You have to mention (->) since fmap is a class method, and you are looking for a known instance implementation.
12:33:37 <osfameron> oh.  so it's not a valid expression?
12:33:40 <sioraiocht> no
12:33:54 <sioraiocht> I'm unclear then, (->) is NOT a function, right?
12:33:55 <osfameron> ok.  thanks.  I'll ignore it for now until I understand it.
12:34:02 <monochrom> No.
12:34:03 <byorgey> sioraiocht: (->) is a type constructor.
12:34:07 <monochrom> I mean right.
12:34:14 <sioraiocht> okay
12:34:19 <shachaf> osfameron: Don't ignore it.
12:34:34 <shachaf> osfameron: When you say x + y, you really mean (+) x y.
12:34:37 <osfameron> shachaf: MY BRAIN IS FULL
12:34:43 <osfameron> shachaf: ok
12:34:45 <shachaf> osfameron: When you say a -> b, you really mean (->) a b.
12:34:49 * monochrom erases osfameron's brain
12:34:56 <osfameron> monochrom: er, thanks :-)
12:35:01 <wli> Where the devil is on?
12:35:09 <shachaf> Nowhere, in base 2.0.
12:35:19 <shachaf> In base 2.1 it's in Control.Function, I think.
12:35:23 <osfameron> shachaf: er, so a-> b -> c is (-> (->) a b ))  (or something) ?
12:35:26 <shachaf> @let on f g x y = g x `f` g y
12:35:31 <lambdabot> Defined.
12:35:44 <osfameron> er... * a b c I mean
12:35:47 <wli> ow do I specify base2.1?
12:35:58 <shachaf> (->) a ((->) b c)
12:36:10 <shachaf> wli: That's in GHC 6.7.
12:36:15 <monochrom> ghc -package base-2.1 ?  I don't actually know.
12:36:23 <osfameron> shachaf: except that that's not valid syntax ?
12:36:26 <shachaf> wli: For now you should just define it yourself, probably.
12:36:33 <shachaf> osfameron: It is valid syntax.
12:36:51 <shachaf> > let f :: (->) Int ((->) Int Int); f = (+) in f 3 2
12:36:52 <lambdabot>  5
12:37:15 * monochrom giggles and imagines some Scheme jokes
12:37:17 <osfameron> shachaf: ok.  That a) sort of makes sense and b) makes me want to hide behind the sofa
12:37:20 <wli> Could not find module `Control.Function':
12:37:38 <shachaf> wli: Are you using GHC 6.7?
12:37:42 <osfameron> shachaf: I think I was right to want to ignore it
12:37:44 <shachaf> wli: It's the development version.
12:37:52 <shachaf> osfameron: Why?
12:37:57 <wli> schachaf: GHCi, version 6.7.20070830
12:38:04 <shachaf> wli: Oh.
12:38:13 <shachaf> wli: Maybe Data.Function?
12:38:32 <wli> Data.Function.on :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:38:34 <osfameron> shachaf: because everything that you learn has a cognitive cost, and I've spent the last 3 days at a Perl conference and my brain is full.
12:38:35 <wli> There it is.
12:39:05 <osfameron> shachaf: and because I don't think I'm at the point in Haskell studies that I would actually *use* that.  So I'll put it to one side in my brain and come back to it when it's the right time.
12:39:14 <shachaf> Perl conference?
12:39:19 * shachaf hopes that's Perl 6. :-)
12:39:55 <shachaf> Here's a way of thinking about it: If you have "f a", you can replace it with "e -> a".
12:40:08 <shachaf> With the same e for the same f.
12:40:22 <shachaf> So fmap :: (a -> b) -> f a -> f b
12:40:39 <shachaf> So fmap :: (a -> b) -> (e -> a) -> (e -> b)
12:40:48 <shachaf> Does that make sense?
12:41:14 <wli> I wonder how I get a 64-bit ghc/ghci built.
12:42:19 <sioraiocht> is there ever going to be a new haskell report to replace haskell 98?
12:42:30 <monochrom> Yes.
12:42:33 <Saizan> haskell'
12:42:42 <osfameron> shachaf: heh... actually I missed most of the Perl6 stuff.  (I followed that for years... now getting a bit tired of it)
12:42:42 <drigz> (or haskell prime)
12:42:51 <sioraiocht> is it being developed now or...?
12:43:07 <monochrom> (or haskell 2, 3, 5, 7, ...)
12:43:13 <Lemmih> wli: You should be fine if you follow the installation guide to the letter.
12:44:28 <byorgey> sioraiocht: discussed, rehashed, decided, developed...
12:44:31 <drigz> sioraiocht: http://hackage.haskell.org/trac/haskell-prime/wiki/Status%27
12:44:33 <lambdabot> Title: Status' - Haskell Prime - Trac
12:44:53 <wli> Lemmih: The installation guide doesn't cover the weird 32-bit userspace on a 64-bit box with just enough 64-bit libs to get by scenario.
12:46:01 <Lemmih> wli: Oh well, guess you're on your own.
12:47:12 <wli> Lemmih: I probably won't get anywhere with it.
12:47:47 <wli> Lemmih: I don't know anything about ghc's internals or build system so I'm dead in the water after trying a few options to configure
12:48:45 <sorear> wli: describe your problem in #ghc and Igloo or JaffaCake will show up within a day
12:49:24 <Igloo> Are you trying to make a 32 or 64 bit GHC?
12:49:30 <wli> sorear: It's a pretty dumb "how do I build ghc" -type thing; the twist is relatively minor and not a true cross-compile.
12:49:41 <wli> Igloo: 64-bit now; I just succeeded with 32-bit.
12:49:56 <sorear> wli: This is not a dumb question!
12:51:06 <wli> sorear: Well, I'd consider it more "worthy" if it had something to do with code vs. just trying to compile stuff. But I suppose I have to walk before I can run.
12:51:20 <sioraiocht> if you compile ghc on OSX is it by default 64-bit?
12:52:18 <wli> Igloo: 32-bit went okay after overriding all the uname results inferred by configure for --target, --build, and --host.
12:52:29 <wli> Igloo: And, of course, CFLAGS="-m32"
12:54:54 <Igloo> No idea then
12:57:19 <Excedrin> I need to divide an integer in half, but if there's a remainder, I need to include it in one of the halves 50% of the time: (a, b) = (3 `div` 2, 3 `div` 2) -- like this, but I need to have a = 2 50% of the time and b = 2 50%, how can I do that?
12:57:32 <wli> Well, I'm trying now just nuking the CFLAGS with --build=i686-unknown-linux-gnu and both --target and --host =x86_64-unknown-linux-gnu
13:00:00 <takamura> Excedrin, it should be random?
13:00:02 <astrolabe> > divMod 7 2
13:00:03 <lambdabot>  (3,1)
13:00:33 <EvilTerran> Excedrin, do you want bankers' rounding or sth?
13:00:38 <Excedrin> yes exactly
13:00:56 <Excedrin> I'm using an Int as cents for a money type
13:01:19 <astrolabe> random functions aren't true functions, so you need to pass in (and probably return) a random seed somehow
13:02:14 <astrolabe> @type random
13:02:16 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
13:03:09 <thoughtpolice> @index unsafePerformIO
13:03:10 <lambdabot> System.IO.Unsafe, Foreign
13:03:27 <EvilTerran> > zip [0..] [n `div` 2 + if n `mod` 4 == 3 then 1 else 0 | n <- [0..]]
13:03:28 <lambdabot>  [(0,0),(1,0),(2,1),(3,2),(4,2),(5,2),(6,3),(7,4),(8,4),(9,4),(10,5),(11,6),(...
13:03:38 <EvilTerran> \n -> n `div` 2 + if n `mod` 4 == 3 then 1 else 0
13:04:00 <EvilTerran> should halve even numbers exactly, and round odd numbers' halvings to the nearest even number
13:04:18 <EvilTerran> which is, iirc, bankers' rounding
13:05:26 <EvilTerran> Excedrin, does that do what you neeD?
13:07:00 <Excedrin> umm, I can't have pennies appearing out of air, 7 halved is (3,4) or (4,3), but never (4,4)
13:07:30 <EvilTerran> oh, right... that's not bankers' rounding.
13:07:37 <astrolabe> Excedrin: When you said 'yes exactly', who were you agreeing with?
13:07:44 <EvilTerran> as I understand it, anyway.
13:07:51 <Excedrin> with takamura, it should be random
13:08:06 <EvilTerran> http://en.wikipedia.org/wiki/Banker%27s_rounding#Round-to-even_method
13:08:09 <lambdabot> http://tinyurl.com/25bp9q
13:08:34 <EvilTerran> sorry, i thought "yes exactly" was to me =/
13:09:51 <astrolabe> Excedrin: You should look at the chapter on Random in the report
13:10:41 <Excedrin> why does round (3 / 2) always return 2?
13:11:10 <astrolabe> > 3/2
13:11:11 <lambdabot>  1.5
13:11:13 <sjanssen> Excedrin: referential transparency
13:11:13 <puusorsa> should it return 4 sometimes
13:11:25 <sorear> because functions in haskell are deterministic!
13:11:32 <takamura> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Around
13:11:34 <lambdabot> http://tinyurl.com/y4wexy
13:11:36 <EvilTerran> and 2 instead of 1 because IEEE
13:12:02 <monochrom> round-to-even
13:12:53 <monochrom> Both Knuth and "What Every Computer Scientist Should Know about Floating-Point Arithmetic" explains the benefits of round-to-even.
13:12:58 <sorear> Excedrin: Rational pennies maybe?
13:13:26 * osfameron fails to understand comment at http://osfameron.vox.com/library/post/random-pain-in-haskell.html#comment-6a00c225240a9af21900e398a32ca30004
13:13:29 <lambdabot> http://tinyurl.com/36y69l
13:13:30 <astrolabe> > (round (3/2),round (5/2))
13:13:32 <lambdabot>  (2,2)
13:13:38 <EvilTerran> monochrom, i was just talking about round-to-even a minute ago; that's what my "bankers rounding" rant was on about
13:13:39 <osfameron> is the algorithm I used non-functional?  or not-functioning?
13:14:00 <monochrom> You can use delimited continuations to get non-deterministic functions. But in Haskell that has to happen in a monad.
13:14:26 <EvilTerran> does the report demand round-to-even semantics for the round function?
13:14:36 <waern> dcoutts: ping
13:14:57 <takamura> round to nearest integer
13:15:24 <monochrom> No, but IEEE does, since it actually heeds advice from mathematicians like Knuth rather than intuitionists like Guido.
13:15:26 <sorear> osfameron: don't worry, the commenter is just wrong
13:15:32 <osfameron> sorear: cool!
13:16:07 <sorear> osfameron: src/eat.c (IIRC) in the NetHack source distribution mentions the algoritm, and gives a proof of correctness
13:16:17 <EvilTerran> osfameron, that Tordek guy doesn't know what he's talking about. you're right.
13:16:39 <EvilTerran> monochrom, okay, so "and 2 instead of 1 because IEEE" was still right, then ;]
13:17:58 <monochrom> Oh, I read the report now. "round x returns the nearest integer to x, the even integer if x is equidistant between two integers."
13:18:32 <monochrom> Haskell also heeds scientific advice rather than "thinkers" like Larry Wall.
13:18:55 * monochrom thinks people think too much.
13:18:59 <byorgey> > round (1.5)
13:19:00 <lambdabot>  2
13:19:04 <byorgey> > round (2.5)
13:19:06 <lambdabot>  2
13:19:09 <EvilTerran> hm? what's Larry Wall got to do with this?
13:19:38 <monochrom> I just like to take an opportunity to insult two most prominent celebrities.
13:19:56 <augustss> monochrom: Haskell people think barely enough :)
13:20:06 * monochrom has Paul Graham on the next of his list :)
13:23:27 <EvilTerran> augustss, when using a perfect programming language, you wouldn't have to think. we're just closer than most to that goal. ;]
13:24:10 <Nafai> EvilTerran: I find it interesting you say that about Haskell.  Haskell hurts my brain and I have to think too much when trying to use it :)
13:24:21 <Excedrin> would using unsafePerformIO to implement stochastic rounding be horrible?
13:24:39 <EvilTerran> Nafai, compared to, say, C, or assembly, i think most'd agree Haskell requires less thinking
13:25:14 <Nafai> EvilTerran: Guess I'm not smart enough yet to say that :)
13:25:43 <EvilTerran> Excedrin, yes, unless you can guarantee a functionally pure interface to the bit doing the unsafePerformIO
13:26:36 <EvilTerran> so if you're sure you'd always return the same answer regardless of what IO goes on under the hood, go for it. otherwise, better not.
13:27:22 <augustss> Excedrin: stochastic rounding would be terrible
13:27:33 <Excedrin> augustss: what should I use instead?
13:27:52 <augustss> Excedrin: what's wrong with round-to-even?
13:28:07 <Excedrin> pennies disappearing
13:28:25 <augustss> Excedrin: not on average
13:28:51 <Excedrin> I can't have pennies disappear ever, it's not a question of average
13:29:31 <sorear> Excedrin: rational maybe?
13:29:34 <takamura> then, ceiling (x/2)
13:29:55 <augustss> Excedrin: I guess I don't understand your problem.  rounding will always make something disappear
13:30:02 <wli> 64-bit seems to have built on the first try.
13:31:04 <monochrom> why round?
13:31:07 <dcoutts> waern: pong
13:31:14 <monochrom> (why not square?  <duck>)
13:31:30 <waern> dcoutts: i'm using c2hs via cabal
13:31:33 <Excedrin> the problem is, Joe and Bob have 3 pennies and they decide to split them in half, I can't have Joe getting 1 and Bob getting 1 and I can't have them both getting two pennies, one gets 1 and one gets 2 this time, but next time perhaps the guy who got 2 will get 1 etc
13:31:44 <waern> dcoutts: need some way to tell c2hs to find gtk/gtk.h
13:31:57 <waern> dcoutts: seems like currently only include-dirs: is able to do that
13:32:04 <monochrom> See, "pennies disappearing" is the kind of advice I would attribute to those "thinkers", "intuitionists" I take great pleasure to insult.
13:32:13 <int-e> Excedrin: if you're good at splitting hairs you should have no problem with cutting a coin in two
13:32:21 <waern> dcoutts: but I don't want to specify the full path to the gtk include directory, obviously
13:32:44 <int-e> Excedrin: but the real answer is, give them both 1 coin, take 1 as a service fee for yourself.
13:32:59 <takamura> yeah
13:33:00 <waern> dcoutts: so shouldn't c2hs get the includes: field too?
13:33:13 <EvilTerran> Excedrin, how about swapping the two over every time you do an unfair split?
13:33:46 <augustss> Excedrin: ok, so if they repeat the splitting 100 times give them 150 pennies each
13:33:47 <monochrom> If you are splitting money, "round" is not for you.
13:34:10 <waern> dcoutts: so I can just say includes: gtk/gtk.h
13:34:16 <waern> dcoutts: in the cabal file
13:34:18 <EvilTerran> or work in Rationals as long as you can and work it out at the end
13:34:52 <augustss> Excedrin: if you want an ongoing splitting process you'll have to use random rounding and use random numbers in your algorithm
13:35:31 <dcoutts> waern: someone needs to know that it's -I/usr/include/gtk-2.0/ or something, we usually find that from the pkg-config program
13:35:47 <dcoutts> waern: cabal does pass the include-dirs along to c2hs I think, doesn't it?
13:36:58 <waern> dcoutts: oh, I thought gtk/gtk.h could always be found. ok.
13:38:01 <waern> dcoutts: yes it passes the include-dirs to c2hs, but I thought I must use includes: since I think that field can be used to specify a system installed header file without giving a full path. never mind that now
13:40:24 <waern> dcoutts: so the best way to solve this is by a hook that runs pkg-config, am I right?
13:41:11 <glen_quagmire> how do you print current working directory in ghci?
13:41:14 <glen_quagmire> :pwd
13:42:57 <glen_quagmire> oh windows version of ghci doesn't have tab completion
13:43:16 <cinimod> :!pwd
13:43:25 <EvilTerran> :!cd or :!pwd works, depending on OS
13:44:13 <glen_quagmire> yah windows sucks
13:44:55 <glen_quagmire> is there a way to start ghci on a specific directory?
13:45:13 <glen_quagmire> i'm making a windows batch script that'll add Open GHCi here context menu
13:45:33 <glen_quagmire> but i think i need readline for windows first
13:45:48 <xorAxAx> @src seq
13:45:48 <lambdabot> Source not found. stty: unknown mode: doofus
13:46:16 <wli> unknown command ':pwd'
13:46:26 <wli> GHCi, version 6.7.20070830
13:46:36 <xerox> :!pwd
13:52:55 <glen_quagmire> do you use ghc on cygwin?
13:55:51 <glen_quagmire> is there a gui version of ghci? that will have tab completion even on windows
14:04:19 <evir> osfameron: After reading the proof in the NetHack source, your pick actually also makes sense to me. :-)
14:04:41 <evir> osfameron: I just think that your text is suggesting an algorithm different from what the pick function is written like.
14:04:59 <EvilTerran> tab completion can happen on 'doze's command line, it just has to be written as a seperate set of functionality from the readline stuff, iirc
14:05:07 <evir> osfameron: The commecter probably has also read it wrong.
14:08:14 <osfameron> sorear, evir: oh, interesting - I read it somewhere (possibly Programming Perls?) ages ago, can't remember the reference, I definitely never read the nethack source...
14:09:03 <sorear> I'm *sure* NetHack is at least a secondary reference.
14:09:18 <evir> sorear: It is there, yes, in eat.c, as you mentioned.
14:09:39 <Botje> I believe it's also one of the famous "microsoft interview questions"
14:09:46 <evir> osfameron: It's just that (to me) your descriptions reads like: with 1/2 probability, choose the second, with 1/3 probability choose the third, with 1/4 probability choose the fourth.
14:09:53 * osfameron stabs the interview questions with a rusty spoon
14:09:58 <evir> Which would not yield the correct result.
14:10:15 <osfameron> evir: ah... sometimes I am less clear than I'd like, I'll reread
14:10:30 <drigz> evir: i agree, it took me a while to realise that the algorithm involved changing your choice
14:10:34 <evir> It's more like: with a 1/3 probability, exchange the third element with the one currently chosen.
14:11:10 <evir> "exchange" not like changine variables or positions ins lists or something... difficult to express. :-)
14:11:16 <osfameron> evir: ok, istr wondering if it was clear that "selecting" involved changing the selection
14:11:31 <osfameron> evir: I think I decided that the code was clearer than my explanation would be :-)
14:12:09 <evir> osfameron: I've not read the code first, because I just thought "that can't work". ;-)
14:12:20 <evir> But it's cool, definitively.
14:12:22 <osfameron> evir: hehe ;-)
14:12:44 <osfameron> yeah, I don't normally remember details of algorithms just like that :-)  I must have thought that one was pretty cool at the time
14:13:56 <evir> Just my "impiric proof" with (replicateM 100 (pick [1..10]) and counting the elements made me curious finally.
14:14:04 <evir> empiric
14:14:11 <evir> ;-)
14:14:22 <osfameron> oh!  you tested it empirically!  nice
14:14:42 * osfameron looks at http://nethack.wikia.com/wiki/NetHack_3.0.0/eat.c
14:14:44 <lambdabot> Title: NetHack 3.0.0/eat.c - Wikihack - a Wikia wiki
14:14:55 <monochrom> NetHack contains proofs?
14:15:51 <osfameron> can't find it in there
14:15:58 <osfameron> gosh, that code is chock full of magic constants
14:16:48 <evir> osfameron: It's missing there.
14:16:57 <evir> I have the source of nethack 3.4.3.
14:17:55 <hpaste>  Evir Drevo pasted "empiric pick" at http://hpaste.org/2518
14:18:05 <evir> osfameron: See the paste. Doesn't look too bad actually.
14:19:12 <Saul_> @pl \fs x -> and (unmap fs x)
14:19:12 <lambdabot> (and .) . unmap
14:19:22 <hpaste>  Evir Drevo annotated "empiric pick" with "the "proof" from nethack" at http://hpaste.org/2518#a1
14:19:35 <evir> And there goes the proof from the nethack source.
14:21:23 <evir> It's like: p(choose first) * p( choose second) * p( choose third) * p( choose fourth)
14:29:36 <dcoutts> waern: right, you need a hook to run pkg-config, or wait for me to add pkg-config support to cabal directly
14:29:58 <waern> dcoutts: oh, that would be nice
14:30:17 <waern> dcoutts: I'm adding a hook for now
14:30:21 <dcoutts> yep
14:30:40 <dcoutts> waern: and yes, includes can be use for system-installed things, but only if they're on the standard search path
14:30:50 <ddarius> hmm... I'm out of space
14:31:00 <pgavin> hello
14:31:09 <waern> dcoutts: yes, I thought gtk was on standard search path :-)
14:31:29 <dcoutts> hia pgavin
14:31:37 <pgavin> dcoutts, have you started on the pkg-config stuff?
14:31:47 <dcoutts> pgavin: not yet, but I was thinking of it
14:31:51 <pgavin> ok
14:31:59 <waern> dcoutts: just so you know: the docs doesn't say that the includes: field is passed to ch2s though
14:32:07 <dcoutts> pgavin: why, you want to look at it instead? :-)
14:32:10 <pgavin> lol
14:32:23 <pgavin> if you need me to, I can
14:32:44 <pgavin> you might have a better idea for it though
14:35:09 <pgavin> does cabal support in-place packages yet?
14:35:15 <Lemmih> dcoutts: Is the TreeStore/ListStore code going through some changes? Using the code triggers a lot of critical assertions.
14:39:09 <drigz> is there a nice way to build lists of the form xs ++ [f xs]
14:39:34 <monochrom> not sure you mean what you write.
14:39:45 <Heffalump> f :: [a] -> a ?
14:39:56 <pgavin> do you mean xs ++ map f xs?
14:40:05 <drigz> pgavin: no
14:40:16 <drigz> Heffalump: yeah
14:40:24 <monochrom> Also there are very few things nicer than a six-token attempt.
14:40:37 <drigz> i mean that each element of the list can be calculated using all the previous elements
14:40:53 <pgavin> fold
14:40:56 <EvilTerran> a sort of unscanr or something?
14:41:19 <Heffalump> drigz: can f take the elements in the opposite order?
14:41:25 <Heffalump> it'd be a lot more efficient
14:41:28 <drigz> Heffalump: yes
14:41:36 * FMota wonders how to represent ordinals in Sei...
14:41:40 <drigz> Heffalump: but it's going to reverse the list anyway in my case
14:41:53 <Heffalump> it'd be nicer to put stuff at the front, that's all
14:42:11 <EvilTerran> so, foo f xs = (f xs):xs okay?
14:42:17 <FMota> Is there a way of representing ordinal numbers in Haskell?
14:42:45 <drigz> Heffalump: i think that means you can't have an infinite result
14:42:52 <drigz> which isn't the end of the world, but it's always nice
14:43:54 <augustss> FMota: yes
14:44:03 * monochrom tries to recall how to do ordinals in HOL.
14:44:25 <augustss> FMota: you mean non-finite ordinals, I presume
14:44:32 <EvilTerran> drigz, is this supposed to be kinda iterate-esque?
14:44:37 <FMota> yes, non-finite
14:44:43 <FMota> the finite kind aren't too interesting :)
14:44:47 <monochrom> Ah, something stronger than the axiom of choice is used in HOL to get ordinals.
14:45:02 <oerjan> drigz: does foo f xs = xs+[f xs] not do what you want?
14:45:10 <oerjan> er, ++
14:45:15 <augustss> FMota: http://blog.jbapple.com/2007/06/ordinals-part-2.html
14:45:17 <lambdabot> Title: Everyone Else is Crazy: Ordinals, part 2
14:45:46 <monochrom> Hmm, the axiom of choice gives me successors. How do I get limits?
14:45:55 <drigz> oerjan: i want it to work like iterate though
14:46:07 <FMota> ty
14:46:16 <drigz> EvilTerran: so yes
14:46:19 <oerjan> drigz: can you give an example of what it actually should return?
14:46:32 <augustss> I also recommend Peter Hancock's thesis
14:46:48 <drigz> if f xs = sum xs, and you start with 1, you get [1, 1, 2, 4, 8, 16...]
14:47:19 <oerjan> ah
14:47:55 <FMota> htis is interesting :)
14:48:20 <oerjan> you mean start with 1 or with [1]?
14:48:27 <FMota> *this, sorry
14:48:41 <drigz> oerjan: well, the first element is one, but f [1] will be the first call
14:49:12 <hpaste>  drigz pasted "my best try" at http://hpaste.org/2519
14:49:28 <drigz> i also can't think of a nice name for it
14:49:35 <oerjan> > let foo f x = l where l = x : map f (inits l) in foo sum 1
14:49:36 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
14:49:44 <nomeata> HI. Does this warrant mention on http://www.haskell.org/haskellwiki/Blog_articles :http://www.joachim-breitner.de/blog/archives/262-Haskell-Syntax-Gem.html and if yes, where should it go?
14:49:45 <lambdabot> Title: Blog articles - HaskellWiki
14:49:51 <oerjan> > let foo f x = l where l = x : map f (tail (inits l)) in foo sum 1
14:49:52 <lambdabot>  Exception: <<loop>>
14:50:19 <Lemmih> > let foo f xs = let n = f (xs []) in n:foo f (xs . (n:)) in foo sum (1:)
14:50:21 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:50:33 <oerjan> nope
14:51:12 <Lemmih> > let foo f xs = let n = f (xs []) in n:foo f (xs . (n:)) in 1:foo sum (1:)
14:51:12 <oerjan> why the heck did it <<loop>>?
14:51:15 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
14:51:32 <byorgey> oerjan: inits isn't as lazy as it should be
14:51:38 <drigz> Lemmih: that's pretty much mine, but i give f the reversed list
14:51:43 <drigz> which saves the function composition
14:51:50 <drigz> @src inits
14:51:50 <lambdabot> inits []     =  [[]]
14:51:50 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
14:52:06 <oerjan> oh right, inits is too strict
14:52:47 <drigz> what's too strict about that?
14:53:05 * shapr boings!
14:53:07 <oerjan> > let foo f x = l where l = x : (tail . map f . inits) l in foo sum 1
14:53:07 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
14:53:12 <drigz> and why doesn't it use [] : instead of [[]] ++
14:53:45 <oerjan> (1) inits undefined should have been []:undefined
14:53:51 <byorgey> > let l = 1 : map sum (inits l) in l
14:53:52 <gigamonkey_> Are there any datastructures in Haskell that support O(1) updates and accesses?
14:53:52 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
14:54:06 <oerjan> (2) no idea
14:54:11 <Lemmih> drigz: To match the line above it.
14:54:19 <oerjan> byorgey: i already tried that
14:54:31 <byorgey> oerjan: I was just playing with inits
14:54:35 <augustss> gigamonkey_: only those that can store O(1) items
14:54:37 <monochrom> Hancock's recent paper "Programming interfaces and basic topology" scares me. :)
14:54:46 <augustss> gigamonkey_: unless you use, e.g., the ST monad
14:54:59 <gigamonkey_> augustss: that's sort of what I suspected
14:55:17 <oerjan> > let foo f x = l where l = x : (tail . map f . inits) l in foo sum 1
14:55:19 <lambdabot>  Exception: <<loop>>
14:55:24 <Cale> What about DiffArrays?
14:55:42 <Cale> DiffArrays have O(1) updates and accesses
14:55:44 <drigz> i just realised that this doesn't actually solve my problem :s
14:55:45 <augustss> Cale: not with the worst case usage pattern
14:55:55 <EvilTerran> > head $ inits undefined
14:55:57 <lambdabot>  Undefined
14:56:00 <etnt> can I do bit operations on Int's in Haskell ?
14:56:12 <Cale> augustss: Well, nothing in any language has O(1) updates and accesses if you're allowed to look at old copies :)
14:56:23 <drigz> etnt: import Data.Bits
14:56:24 <augustss> Cale: true :)
14:56:26 <EvilTerran> @docs Data.Bits
14:56:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
14:56:37 <etnt> drigz: nice, thx
14:57:08 <EvilTerran> drigz, what do you actually want to do?
14:57:22 <augustss> Cale: also, DiffArray and the ST monad are special; they can't be written (efficiently) in Haskell without some primitives
14:57:35 <drigz> EvilTerran: it's a project euler problem, so i don't want help with the actual problem
14:57:38 <Cale> of course, yeah
14:57:41 <drigz> but it's problem 122 if you're wondering
14:57:43 <EvilTerran> oh right, okay.
14:57:55 <drigz> i thought it was much easier than it is
14:58:06 <Lemmih> > let foo f i = map f $
14:58:06 <lambdabot>  Parse error
14:58:22 <gigamonkey_> Cale: so is the worst case for DiffArray always involve using the old values?
14:58:48 <|Jedai|> gigamonkey_: Yes, if you just use it in a pipeline fashion, it will be O(1) always
14:58:49 <Cale> gigamonkey_: Yeah, as you make updates, accesses to the old copies gets progressvely slower.
14:58:59 <Cale> get*
14:59:04 <augustss> What makes DiffArray tricky to use is lazy evaluation.  You don't know exactly when you're going to use the old copy.
14:59:16 <Lemmih> > let foo f i = i:map f (unfoldr (\b -> Just (b, f b:b)) [i]) in foo sum 1
14:59:19 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
14:59:59 <EvilTerran> sounds like they'd work well with uniqueness typing or sth
15:00:24 <augustss> with uniqueness typing you could use update in place
15:00:25 <wli> > let icbrt :: Integer -> Integer ; icbrt n = ceiling $ ((fromIntegral n)**(1/3) :: Double) in take 3 [(k, ijs) | k :: Integer <- [2..], let ijs = [(i, j) | i :: Integer <- [1 .. icbrt k], let j :: Integer = icbrt (k - i^(3::Int)), i < j, i^(3::Int) + j^(3::Int) == k], case ijs of { [] -> False ; [_] -> False ; _ -> True }]
15:00:25 <lambdabot>  Parse error
15:00:58 <wli> So much for that.
15:01:29 <wli> > let icbrt :: Integer -> Integer ; icbrt n = ceiling $ ((fromIntegral n)**(1/3) :: Double) in take 3 [(k, ijs) | k :: Integer <- [2..], let ijs = [(i, j) | i :: Integer <- [1 .. icbrt k], let j :: Integer = icbrt (k - i^(3::Int)), i < j, i^(3::Int) + j^(3::Int) == k], length ijs > 1]
15:01:29 <lambdabot>  Parse error
15:01:52 <EvilTerran> augustss, would it be possible to shoehorn equivalent behaviour into a monad?
15:02:00 <dcoutts> Lemmih: yeah, I'm not sure what caused those warning to start appearing, I'll need some investigation
15:02:07 <EvilTerran> actually, i guess that'd be having an array of IORefs, wouldn't it...
15:02:08 <jedai> EvilTerran: The equivalent of array with uniqueness typing is already IOArray or STArray
15:02:17 <EvilTerran> or that, yeah.
15:02:44 <oerjan> > let foo f x = l where l = x : map (f . flip take l) [1..] in foo sum 1
15:02:45 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
15:02:49 <dons> re.
15:02:51 <dons> ?users
15:02:51 <lambdabot> Maximum users seen in #haskell: 394, currently: 383 (97.2%), active: 26 (6.8%)
15:02:55 <Lemmih> > let x = 1:[sum (take n x) | n <- [1.. ]] in x
15:03:01 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
15:03:11 <mrd> should (a >> b) give the same behavior as (a `seq` b) in the IO monad?
15:03:32 <oerjan> mrd: certainly not
15:03:34 <Lemmih> drigz: That's about as pretty as I can make it.
15:03:52 <oerjan> seq evaluates, it does not run
15:04:12 <mrd> hm
15:04:15 <drigz> Lemmih: that's very nice
15:04:27 <drigz> thanks
15:04:29 <oerjan> in fact if a is not bottom, a `seq` b is completely equivalent to b
15:04:46 <Lemmih> dcoutts: The assert is from Gtk2HsStore.c:480
15:04:51 <ddarius> oerjan: Semantically...
15:05:23 <dons> woot, http://programming.reddit.com/info/2kbji/comments
15:05:24 <lambdabot> Title: Type synonym families for Haskell: now in GHC! (reddit.com)
15:05:42 <dcoutts> Lemmih: it's a correct assertion, the stamps should be the same
15:06:41 <Lemmih> dcoutts: iter->stamp is always 0.
15:06:48 <dcoutts> hmm
15:08:29 <oerjan> "Type checking of GADTs now requires a bit more type declarations:
15:08:59 <oerjan> sounds like type inference for GADTs went out the window?
15:09:08 <wli> w^3 + x^3 = y^3 + z^3 is slightly more involved than an elliptic curve. It's a cubic surface or something.
15:09:16 <takamura> @pl \x y -> f x == f y
15:09:16 <lambdabot> (. f) . (==) . f
15:09:50 <ddarius> :t join (liftM2 (==)) f
15:09:52 <lambdabot> Not in scope: `f'
15:09:56 <ddarius> :t join (liftM2 (==)) ?f
15:09:58 <lambdabot> forall a1 (m :: * -> *). (Eq a1, Monad m, ?f::m a1) => m Bool
15:10:08 <ddarius> point.
15:10:55 <EvilTerran> :t join (liftM2 (==) .)
15:10:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m a1
15:10:57 <lambdabot>     Probable cause: `.' is applied to too few arguments
15:11:47 <monochrom> GADT implementation is still evolving.
15:12:04 <takamura> @pl \(x,y) -> (f x, f y)
15:12:04 <lambdabot> f *** f
15:12:30 <oerjan> what, @pl knows about arrows?
15:12:34 <takamura> @index ***
15:12:34 <lambdabot> Control.Arrow
15:13:10 <wli> :t \cmp f -> curry (uncurry cmp . join (***) f)
15:13:12 <lambdabot> forall c b c1. (c1 -> c1 -> c) -> (b -> c1) -> b -> b -> c
15:13:12 <oerjan> @pl \(x,y) -> (f x, g y)
15:13:12 <lambdabot> f *** g
15:13:16 <shapr> What's the problem with Data.Binary in ghc 6.7?
15:13:33 <shapr> unknown symbol `stg_uncheckedShiftRL64' \n ghc-6.7.20070816: unable to load package `binary-0.3' ?
15:13:33 <shapr>  
15:14:00 <Lemmih> dcoutts: It's triggered on insert/prepend/append. demo/listtest and demo/treetest are affected.
15:14:18 <wli> :t \cmp f x y -> cmp (f x) (f y)
15:14:20 <dcoutts> Lemmih: yes, but I can't see why yet
15:14:20 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
15:14:35 <wli> @pl \cmp f -> curry (uncurry cmp . join (***) f)
15:14:35 <lambdabot> (curry .) . (. join (***)) . (.) . uncurry
15:14:49 <Lemmih> dcoutts: Ok, I'll stop poking you then (:
15:14:54 <bparkis> what does (.) mean?
15:14:56 <wli> Somewhat unsatisfying.
15:15:04 <dcoutts> Lemmih: you can keep investigating though :-) it's useful
15:15:10 <oerjan> @src .
15:15:10 <lambdabot> (.) f g x = f (g x)
15:15:17 <dcoutts> Lemmih: one way to find out might be to try reverting back to the class hierarchy change and see if that broke it
15:15:20 <bparkis> oh
15:15:29 <bparkis> then what does (a .) or (. b) mean
15:15:46 <Lemmih> ?unpl (a .)
15:15:46 <oerjan> bparkis: (.) a and flip (.) b
15:15:47 <lambdabot> (\ b e -> a (b e))
15:15:53 <Lemmih> ?unpl (. a)
15:15:53 <lambdabot> (\ b e -> b (a e))
15:15:57 <bparkis> (. b) g x = b g x?
15:16:00 <dcoutts> Lemmih: we changed the way we model the OOP classes with Haskell types/classes, I think the treeview break was at a similar time
15:16:18 <oerjan> no, b x g
15:16:55 <oerjan> or, (g . b) x
15:17:14 <oerjan> er, the first was wrong
15:17:37 <bparkis> ah so wait (. b) is not the same as ((.) b)
15:17:44 <oerjan> nope
15:17:49 <bparkis> what is it the same as without the infix
15:18:00 <shachaf> bparkis: flip (.) b
15:18:05 <oerjan> (. b) x = x . b = (.) x b
15:18:22 <shachaf> (s .) = (\x -> s . x)
15:18:23 <oerjan> (b .) x = b . x = (.) b x
15:18:32 <shachaf> (. s) = (\x -> x . s)
15:18:40 <oerjan> the first argument goes in the "empty spot"
15:18:46 <shachaf> That's the simplest way to look at it, I think.
15:19:01 <oerjan> and also the official translation
15:19:16 <takamura> @instances Arrow
15:19:17 <lambdabot> (->), Kleisli m
15:19:19 <bparkis> so (b .) g x = b g x?
15:19:25 <oerjan> no!
15:19:34 <shachaf> (b .) g x = b (g x)
15:19:35 <oerjan> = b (g x)
15:19:47 <bparkis> ok
15:19:52 <shachaf> Since (b .) g x = ... is equivalent to (.) b g x = ... .
15:19:59 <bparkis> ty that clears that up
15:20:03 <oerjan> the (b .) g = b . g translation works for any operator, not just .
15:20:19 <oerjan> but then you need to apply the definition of (.) itself
15:20:45 <TuringTest> dons and others: I see that "Type contexts (including super class and instance contexts) can have equational constraints of the form t1 ~ t2, where the two types t1 and t2 need to be rank 0 types."  Does this mean that oleg's  TypeEq trick is no longer needed?
15:21:33 <oerjan> (. b) g = g . b works for any operator except -
15:22:02 <oerjan> (because that's negation)
15:23:05 <dons> TuringTest: I suspect so.
15:23:45 <TuringTest> dons: Thanks
15:27:44 * thoughtpolice vrooms
15:28:20 <takamura> @pl (uncurry (==)) . (f *** f)
15:28:20 <lambdabot> uncurry (==) . (f *** f)
15:28:45 <oerjan> @unpl (uncurry (==)) . (f *** f)
15:28:45 <lambdabot> (\ c -> uncurry (==) ((f *** f) c))
15:29:06 <oerjan> that didn't exactly help either
15:29:21 <Botje> :t ***
15:29:23 <lambdabot> parse error on input `***'
15:29:24 <Botje> :t (***)
15:29:24 <takamura> it's only \x y -> f x == f y
15:29:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:30:17 <oerjan> usually called (==) `on` f these days
15:30:34 <takamura> :t on
15:30:36 <lambdabot> Not in scope: `on'
15:30:45 <Saizan> curry (uncurry (==) . join (***) f)
15:30:50 <Saizan> :t curry (uncurry (==) . join (***) f)
15:30:52 <lambdabot> Not in scope: `f'
15:30:55 <Saizan> :t curry (uncurry (==) . join (***) ?f)
15:30:57 <lambdabot> forall b c. (Eq c, ?f::b -> c) => b -> b -> Bool
15:30:58 <oerjan> except on is not in lambdabot yet
15:31:10 <EvilTerran> seems related to "comparing"
15:31:22 <EvilTerran> comparing = (compare `on`), methinks?
15:31:28 <Saizan> yup
15:31:28 <oerjan> yep
15:31:40 <olsner> Saizan: what's that you did with ?f ?
15:32:16 <Saizan> olsner: it's an implicit parameter, it takes f from the scope of the caller
15:34:22 <oerjan> > let a = ?x+1 in let ?x=1 in a
15:34:22 <lambdabot>  Parse error
15:34:47 <oerjan> :t let a = ?x+1 in let ?x=1 in a
15:34:49 <lambdabot> forall a. (Num a, ?x::a) => a
15:34:55 <oerjan> right, only in @type
15:39:36 <EvilTerran> @hoogle (a -> Bool) -> [a] -> ([a],[a])
15:39:37 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:39:37 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:39:37 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:39:43 <EvilTerran> ah, span, that's the one i want
15:40:44 <takamura> there is some lambdabot command like @pl that does transformations "a la squigol" on point-less expresions?
15:40:57 <oerjan> what's squigol?
15:41:02 <jbauman> @pl (f a) == (f b)
15:41:03 <lambdabot> f a == f b
15:41:09 <wli> A polytypic language.
15:41:12 <jbauman> oops
15:41:18 <ddarius> @pl \x -> map f (map g x)
15:41:18 <lambdabot> map (f . g)
15:41:27 <ddarius> Two 'g's
15:41:30 <ddarius> Squiggol
15:41:35 <takamura> http://citeseer.ist.psu.edu/meijer91functional.html
15:41:36 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
15:41:52 <takamura> have to find a better link
15:41:57 <takamura> for download
15:42:11 <ddarius> @google Bird-Meertens Formalism
15:42:13 <lambdabot> http://en.wikipedia.org/wiki/Bird-Meertens_Formalism
15:42:13 <lambdabot> Title: Bird-Meertens Formalism - Wikipedia, the free encyclopedia
15:42:21 <jbauman> @pl \f a b -> (f a) == (f b)
15:42:22 <lambdabot> flip =<< (((.) . (==)) .)
15:45:24 <dcoutts> dons: if you want to look at bytestring IO, be my guest :-)
15:46:20 <dcoutts> dons: in particular we've got too much copy'n'paste from GHC.Handle in things like getLine
15:46:46 <dcoutts> dons: and we still can't semi-close the Handle !! We need to get a function into GHC.Handle that does that for us.
15:48:34 <takamura> http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/nzfpdc-squiggol.ps.gz
15:48:36 <lambdabot> http://tinyurl.com/yt5xoj
15:50:00 <pgavin> dcoutts: cabal can't compile against not-yet-installed packages yet, can it?
15:50:09 <dcoutts> no, not yet
15:50:15 <mboes> hm, does anyone know why the type sig for mapState in Control.Monad.State is mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b rather than mapStateT :: (m (a, s) -> n (b, s')) -> StateT s m a -> StateT s' n b
15:50:27 <mboes> ie would it be possible to map the state to another type?
15:50:49 <dcoutts> pgavin: the approach for building multi-package systems without installing them would be to use a local package db and register locally
15:51:07 <oerjan> mboes: you would need to map the state in both directions
15:51:20 <oerjan> once on entrance, once on exit
15:51:31 <pgavin> dcoutts, so should I make a Makefile to take care of that part of it?
15:51:45 <dcoutts> pgavin: what're you doing?
15:51:50 <dcoutts> or trying to do
15:52:07 <pgavin> well, nothing yet, just thinking out ahead
15:52:09 <dons> dcoutts: yeah, i'm sure we used to beat 'cat.c' , or be very close
15:52:17 <dons> maybe that was mmapfile though :/
15:52:44 <dcoutts> dons: we were always around 2-3x slower, I thought because we were using lots of GC's chunks rather than a single cache-hot chunk.
15:52:51 <dons> ah, perhaps
15:52:54 <dcoutts> dons: I'd not realised there was so much copying
15:53:03 <mboes> oerjan: um, i don't quite understand why
15:53:03 <dcoutts> esp for lazy bs
15:53:14 <dons> hmm. yes.
15:53:33 <dcoutts> pgavin: you'd have to ./setup register --gen-pkg-config=foo.pkg
15:53:37 <oerjan> mboes: the wrapping monad would have to pass the state to the wrapped action somehow, and get one back
15:53:40 <pgavin> dcoutts, right
15:53:44 <dcoutts> pgavin: then register that foo.pkg in a local package db file
15:54:09 <dcoutts> pgavin: then pass --ghc-args=-package-conf=local.package.conf
15:54:12 <dcoutts> or something like that
15:54:15 <oerjan> @src StateT
15:54:15 <lambdabot> Source not found. My mind is going. I can feel it.
15:54:40 <oerjan> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
15:54:54 <mboes> oerjan: ah, i see. Hm, that's making things rather more complicated for me.
15:55:29 <pgavin> dcoutts, there could be a gtk2hs super-package which would be responsible for  building the build tools, then each of the sub-packages
15:55:56 <oerjan> mboes: it should be enough to add a single parameter to turn state in the opposite direction, i think
15:56:30 <dcoutts> pgavin: I'm not sure, I was thinking on possible solution would be to put the generated files into the cabal packages so those tools don't need to be run
15:56:52 <mboes> oerjan: yes, but that would require the new state to be isomorphic to the old one, which may or may not be the case.
15:57:05 <oerjan> (m (a, s) -> n (b, s')) -> (s' -> s) -> StateT s m a -> StateT s' n b
15:57:24 <oerjan> mboes: nope, they don't have to be exact inverses
15:57:36 <oerjan> oh wait...
15:57:38 <dcoutts> pgavin: remember that for distribution purposes we'd like gtk2hs to be a bunch of independent cabal packages
15:57:50 <oerjan> you probably want (s' -> s -> s)
15:57:51 <pgavin> right
15:58:00 <oerjan> to _fold_ the wrapped state back in, sort of
15:58:14 <dcoutts> pgavin: it's ok to use makefiles while doing development, to build without installing but we have to generate ordinary cabal packages in the end
15:58:50 <oerjan> like \x (x',y) -> (x,y)
15:58:55 <dcoutts> pgavin: so yeah, a makefile could arrange for the local registration by calling setup with the right args
15:59:10 <dcoutts> and build the code-gen tools
15:59:14 <mboes> oerjan: so you'd run the monad with a new state type, then restore the old one?
15:59:19 <oerjan> yep
16:01:28 <mboes> oerjan: so then you'd need to switch around s and s' in the type parameters for State: State s' m b -> State s n a, i think
16:02:11 <pgavin> dcoutts, so the top level makefile shouldn't need to be distributed, then
16:02:19 <dcoutts> pgavin: right
16:02:19 <oerjan> mboes: actually i may be mixing where things happen
16:02:58 <dcoutts> pgavin: make dist should do the right stuff and call cabal sdist on all the component packages, so we can upload them all to hackage with cabal-upload
16:03:12 <pgavin> right, ok
16:03:17 * dcoutts notes that cabal-upload makes things very quick and convenient to release new versions
16:03:25 <oerjan> the folding back would probably have to be in the (m (a, s) -> n (b, s')) part
16:03:30 <oerjan> then just (s
16:03:40 <oerjan>  (s' -> s) is necessary for the function
16:04:04 <dcoutts> pgavin: or when it gets to that stage we could think about extending cabal again to deal with multi-package systems
16:04:19 <pgavin> dcoutts, yes, that'd be ideal
16:04:27 <dcoutts> pgavin: but just getting to build glib or gtk is going to be a major achievement
16:04:52 <pgavin> dcoutts, right now my extra code is in a separate module, I suppose it will have to be copied into each subpackage
16:05:02 <pgavin> I mean, extra cabal code
16:05:24 <dcoutts> right, of course we'd like to minimise the amount of code in Setup.hs
16:05:27 <dcoutts> ideally to 0
16:05:58 <pgavin> right... but for the time being, I have to keep my dep code around :)
16:06:27 <mboes> oerjan: if you're willing to throw away the final state than the extra (s' -> s) parameter isn't necessary.
16:06:51 <Saizan> localState accessor setter m = get >>= \s -> let (a,s') = runStateT m (accessor s) in modify (setter s') >> return a
16:07:10 <EvilTerran> is there an integer-square-root function in the standard library?
16:07:20 <oerjan> mboes: no, s' -> s is for the _initial_ state
16:07:41 <dcoutts> pgavin: ah, the dep code, right, of course
16:08:06 <dcoutts> pgavin: or if it's easier, put it into cabal directly, in your local cabal copy
16:08:07 <monochrom> someone learning to use mapState and mapStateT? :)
16:08:19 <dcoutts> @hoogle sqrt
16:08:19 <lambdabot> Prelude.sqrt :: Floating a => a -> a
16:08:30 <dcoutts> EvilTerran: seems not
16:08:38 <oerjan> mboes: s' -> s is the accessor in Saizan's code
16:09:00 <pgavin> dcoutts, it's actually easier just to keep it in gtk2hs; then all I need to do is ghc --make ... if I make changes to the dep code
16:09:08 <dcoutts> aye
16:09:09 <oerjan> he's reversed s and s' from our types
16:09:14 <pgavin> dcoutts, I've actually fixed a couple things already
16:09:28 * EvilTerran thinks...
16:09:52 <EvilTerran> meh, i can't be bothered writing a O(log(sqrt(n))) one. O(sqrt(n)) should be fast enough for my purposes.
16:09:55 <mboes> oerjan: ah, i get it now :). Thanks for the code Saizan. Ands thanks for your help, oerjan.
16:10:47 <oerjan> mboes: although his setter is somewhat less general than our m (a, s) -> n (b, s')
16:11:16 <mboes> oerjan: quite. But it should suffice here i think.
16:12:17 <oerjan> monochrom: actually mapStateT was not general enough, because it maps everything _but_ the state :)
16:12:44 * shachaf just installed GHC 6.7(.20070830).
16:13:09 <monochrom> Oh! Misread. :)
16:13:32 <waern> dcoutts: why isn't c2hs on hackage?
16:13:39 <mboes> yeah, mapState is a bit of a misnomer
16:13:40 * monochrom is contemplating data transformation too, i.e., mapping the state.
16:13:40 <waern> dcoutts: and what's the latest released version? :)
16:14:05 <waern> dcoutts: I was struggling with it and realised my installed version is from 2005
16:14:33 <waern> I'm trying to do the same stuff I did with the gtk2hs-version of c2hs, but it doesn't seem to work
16:16:18 <shachaf> Does lambdabot work with GHC 6.7?
16:16:58 <sorear> Maybe.
16:17:21 <shachaf> Does hs-plugins work? That's what I'm having trouble with.
16:17:57 <mrd> would you think it strange if forkIO was a significant source of allocation in profiling?
16:20:01 <dcoutts> waern: I should make a release...
16:21:03 <waern> I don't get it though... I'm just using a #define to make c2hs recognize an identifier by a different name, that should work in both versions huh?
16:21:15 <waern> maybe something else is wrong...
16:21:29 <dcoutts> waern: the gtk2hs fork of c2hs does several things differently
16:21:33 <dcoutts> especially when it comes to cpp
16:21:41 <waern> oh :(
16:21:55 <waern> and the darcs version of c2hs does what?
16:22:05 <waern> does it have the gtk2hs stuff merged?
16:22:20 <dcoutts> no, the gtk2hs fork is a dead end
16:22:28 <dcoutts> we're trying to move to the mainline c2hs
16:22:36 <waern> hm
16:23:13 <dcoutts> waern: I need a release tag name...
16:23:24 <dcoutts> last one was called "Travelling Lightly"
16:23:45 <waern> hmm :)
16:24:39 <oerjan> "Smelling the Flowers"
16:24:41 <waern> usually, it's those things that stop you from making a release
16:25:04 <dcoutts> oerjan: cute :-)
16:25:25 <dcoutts> the one before that was called "Pressing Forward"
16:25:35 <dcoutts> seems to be some travelling theme :-)
16:26:01 <dcoutts> oh, maybe not, "Springtime" was the release before
16:26:21 <dcoutts> quick! someone give me a good name for the 0.15.0 release :-)
16:27:15 <oerjan> "Rainy Days"
16:27:25 <dcoutts> ok, done :-)
16:27:35 <dcoutts> sold to the man with the umbrella
16:28:00 <waern> dcoutts: ok, I've now tried the darcs version. same result. why do you abandon the gtk2hs version when it can do more stuff? :)
16:28:21 <waern> the #define trick I'm using is not particularly evil or anything
16:28:24 <dcoutts> waern: I'm not sure what stuff you mean
16:29:54 <waern> dcoutts: well, normal c2hs doesn't seem to accept my #define stuff
16:30:03 <waern> but ok, could be a fault on my part
16:30:10 <dcoutts> I don't know what your #define stuff is
16:30:10 <waern> probably is :)
16:32:36 <waern> dcoutts: it's just a simple #define that I use to get c2hs to recognize something by a different name. It worked with the gtk2hs c2hs
16:33:09 <dcoutts> waern: perhaps you can hpaste what you mean
16:35:48 <hpaste>  (anonymous) pasted "#define rename" at http://hpaste.org/2521
16:36:21 <bos> dammit
16:36:51 <bos> @seen dons
16:36:51 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 43m 37s ago.
16:37:15 <bos> @seen kolmodin
16:37:15 <lambdabot> kolmodin is in #xmonad, #darcs, #gentoo-haskell and #haskell. I last heard kolmodin speak 12h 19m 12s ago.
16:37:37 <sorear> Binary issues?
16:38:07 <bos> not exactly.  just sent a patch to add a new function to dons, wondered if he was around or on a plane.
16:38:14 <bos> good guess, though :-)
16:38:42 <bos> one can't read a nul-terminated string efficiently in the Get monad if one doesn't live inside Data.Binary.Get
16:39:02 <bos> so now there's getLazyByteStringNul
16:39:46 <ricky_clarkson> bos: does dons need new functions?
16:40:04 <bos> don't we all?
16:40:31 <dons> heh
16:40:52 <dons> bos, perhaps getLazyByteStringFromCString ?
16:40:56 <dons> since its in CString format?
16:41:07 <dons> you could provide ops for CString and CStringLen, actually
16:43:17 <dcoutts> bos, dons: I feel there are too many functions built into Binary, I wonder if we have the right primitives since we seem to keep having to add more operations
16:43:39 <dcoutts> hia SyntaxNinja
16:43:39 <dons> we keep adding type-specialised primitives
16:43:40 <dons> hmm
16:43:56 <bos> well, having the guts of the Get monad hidden make it hard to do anything efficiently from the outside
16:44:02 <dons> yeah
16:44:07 <dcoutts> true
16:44:30 <dcoutts> dons: new primitives for primitives like Float/Double, Foo32, Foo32be etc are ok
16:44:42 <dcoutts> it's the profusion of other stuff
16:45:03 <SyntaxNinja> y0y0 dcoutts
16:45:12 <dons> oh, strange primitives?
16:45:22 <dons> heya SyntaxNinja
16:45:23 <bos> dons: it's not a CString that i'm dealing with, it's a bufferful of MySQL protocol goo
16:45:28 <dcoutts> bos: otoh the internals of Get are pretty hard core, it's not a nice api to expose
16:45:35 <bos> yeah, i know.
16:45:58 <bos> well, actually i don't know. Get is really simple.
16:46:19 <Saizan> is there an option to make ghci expand type synonyms in types?
16:46:23 <bos> it's just a state monad with some fancy powdered sugar sprinkled on top.
16:46:34 <dcoutts> SyntaxNinja: cabal is doing pretty well atm I reckon, a big improvement in numbers of people sending patches and in the total number of patches flowing in
16:46:35 <SyntaxNinja> hi don!
16:46:43 <SyntaxNinja> dons: we're talking about where you're going to sit :)
16:46:43 <dcoutts> SyntaxNinja: including lots of cleanups
16:46:48 <dons> SyntaxNinja: i'm in the hotel. i hope you've got my desk ready.
16:46:51 <dons> SyntaxNinja: ah good!
16:46:53 <SyntaxNinja> dcoutts: awesome!  nice work.
16:46:53 <bos> dons should sit next to me.
16:47:03 <dons> bos :)
16:47:05 <dcoutts> bos: Get, ok yes, Put is more hard core
16:47:14 <bos> i'm in a coffee shop in the nicest neighbourhood in san francisco. what's not to like?
16:47:17 <SyntaxNinja> bos: we've got a desk for you too if you want ot :P
16:47:21 <SyntaxNinja> s/ot/it
16:47:26 <bos> SyntaxNinja: :-)
16:47:39 <dons> Heffalump, around?
16:47:45 <dcoutts> bos: it's too far way, that's all :-)
16:48:17 <bos> i dunno, if you've seen some of those galois types up close in a dark alley, you might want to be a long way away too :-)
16:49:19 <dons> galois types eh?
16:49:46 <bos> :-)
16:50:08 <bos> i'm a bad liar.
16:54:07 <shapr> bos: I don't believe you.
16:55:52 <sorear> dcoutts: cabal is broken on HEAD, but don'
16:56:12 <sorear> dcoutts: t waste too much time trying to fix it - it's a bug in System.Directory I reported earlier
16:56:37 <sorear> well semi-broken, it works for libraries
16:57:25 <dcoutts> sorear: copyfile ?
16:57:33 <sorear> dcoutts: yeah
16:57:46 <dcoutts> sorear: was it just permissions or something else?
16:57:55 <sorear> dcoutts: doesn't copy permissions, I had to manually chmod +x ~/bin/xmonad
16:58:02 <dcoutts> right
16:58:11 <waern> dcoutts: is the first line special in a .chs-file?
16:58:20 <shachaf> Various packages seem to want Data.ByteString.Base, which doesn't seem to be in http://darcs.haskell.org/packages/bytestring/Data/ByteString/ . Should I be using another package?
16:58:22 <lambdabot> Title: Index of /packages/bytestring/Data/ByteString
16:58:28 <dcoutts> waern: yes, it doesn't get parsed right :-)
16:58:33 <sorear> shachaf: they renamed it '.Internal'
16:58:40 <waern> dcoutts: arghgh! :)
16:58:46 <dcoutts> shachaf: .Internal and .Unsafe
16:58:49 <waern> dcoutts: so that was the problem all along
16:58:59 <dcoutts> waern: I hit that bug recently too :-)
16:59:13 <shachaf> And I have to change the source files everywhere to make it work?
16:59:34 <dcoutts> waern: the parser looks for beginning of lines as a literal "\n" so the first line doesn't get recognised
16:59:47 <waern> dcoutts: strange
16:59:57 <dcoutts> waern: so any # directives on that line get ignored, want to help re-write the chs lexer? :-)
16:59:58 <shachaf> I've been adding various dependencies to the .cabal files already, but I was hoping to leave the .hs files alone.
17:00:02 <shachaf> Is there another way?
17:00:15 <waern> dcoutts: I might, but not right now
17:00:45 <dcoutts> waern: ;-)
17:00:58 <shachaf> (Also, when I runhaskell Setup configure, c2hs complains about --numeric-version. Does this happen to other people?)
17:01:25 <dcoutts> shachaf: I fixed that today
17:01:36 <dcoutts> shachaf: depends on how much of the internals you're using, much of it has changed.
17:01:51 <thoughtpolice> dons: just read the reddit post about type synonym families. very cool. :)
17:02:14 <dcoutts> shachaf: to be specific, I fixed that in Cabal's darcs repo today
17:02:27 <dcoutts> the c2hs --numeric-version thing
17:02:41 <shachaf> dcoutts: Hmm. It doesn't seem to be installing well, let me see.
17:03:34 <shachaf> Hmm, it's getting 644 instead of 755. Is there a reason for that?
17:03:51 <dcoutts> what is ?
17:03:55 <dcoutts> a binary?
17:03:59 <shachaf> dcoutts: /usr/loca/bin/c2hs
17:04:10 <shachaf> (/local/)
17:04:24 <dcoutts> that'll be the bug sorear is talking about, in System.Directory
17:05:01 <shachaf> Should I just chmod it myself for now, then?
17:05:21 <sorear> yes
17:05:27 <shachaf> OK.
17:06:07 <sorear> dcoutts: how about adding a {-# DEPRECATED #-} module Data.ByteString.Base(module R) { import Data.ByteString.Unsafe as R; import Data.ByteString.Internal as R }
17:06:42 <dcoutts> sorear: hmm, I'm not sure how much it'd help, we've renamed a lot of the internal too
17:06:53 <mboes> oerjan, Saizan: here's what i wrote for localState, in case you're interested: localStateT f g m = StateT $ \s -> g (runStateT m (f s))
17:06:57 <sorear> oh.
17:06:59 <dcoutts> all the bytestring and lazy bytestring constructors
17:07:05 <mboes> as i understand that is what oerjan was thinking about
17:07:26 <dcoutts> sorear: in particular I've been changing the lazy bytestring representation
17:07:58 <shachaf> So I won't be able to compile anything that uses Data.ByteString.Base in 6.7 easily?
17:08:02 <dcoutts> the external api is preserved and we never promised to keep the .Base, it's deliberately exposing the internals
17:09:03 <dcoutts> shachaf: I think getting the internal code cleaned up is more important than not breaking the few bytestring extension modules that have to import the internals
17:09:59 <xerox> dcoutts: is ther an haddock online of the new api?
17:10:09 <shachaf> dcoutts: zlib? :-)
17:10:21 <shachaf> dcoutts: I agree, though.
17:10:23 <sorear> What are the plans for binary on 6.7?
17:10:29 <sorear> Since #1282 is fixed.
17:10:46 <dcoutts> shachaf: I'll update zlib at some point, don't worry
17:10:55 <oerjan> mboes: looks like it
17:11:04 <dcoutts> sorear: we'll update it to work with 6.8.x
17:11:11 <dcoutts> xerox: seems not
17:11:31 <shachaf> regex-posix, also.
17:12:06 * shachaf would like to have regex-posix/regex-compat working.
17:14:04 <bos> do we know who cabalised hsql-mysql ?
17:14:20 <bos> i just noticed that it claims to be BSD-licensed, but it needs to be GPLed
17:14:50 <bos> was it krasimir angelov?
17:16:15 <shachaf> Has someone gotten regex-compat working with 6.7?
17:19:15 <chessguy> @go 115 mm in inches
17:19:16 <lambdabot> 115 millimeters = 4.52755906 inches
17:22:29 <oerjan> cool!
17:23:52 <dcoutts> hia ChilliX
17:24:02 <ChilliX> Hi!!
17:24:08 <dcoutts> ChilliX: I'm just about to release c2hs-0.15.0 "Rainy Days"
17:24:39 <ChilliX> Yeah :)
17:24:58 <ChilliX> That's the UK release ;)
17:25:08 <ChilliX> (pretty sunnt here...)
17:25:15 <ChilliX> *sunny
17:26:56 <dcoutts> ChilliX: right, it's been that kind of summer here :-) actually oerjan suggested the name.
17:26:56 <shapr> Hiya ChilliX! Mr Funky!
17:27:25 <oerjan> so it's really the Norway release :)
17:27:31 <shapr> Yay Norway!
17:27:58 <ChilliX> hehe
17:28:03 <ChilliX> Moin shapr!
17:28:32 <ChilliX> Did you see?  Type families hit the wire.
17:29:58 <shapr> Yeah, cool!
17:30:10 <shapr> -XTypeFamilies !
17:30:21 <oerjan> :t (\>)
17:30:23 <lambdabot> Not in scope: `\>'
17:31:18 <thoughtpolice> hm I saw it on reddit but I'm still reading about it (not sure I still get it.) i should probably make a build of 6.7 to experiment with.
17:31:19 <pgavin> dcoutts, are you still around?
17:31:24 <dcoutts> @arr!
17:31:24 <lambdabot> Arrr!
17:31:34 <pgavin> lol
17:31:55 <shapr> I want a 6.7 build too!
17:32:02 <dcoutts> shapr: is that families of "XType"s or what ? ;-)
17:32:02 <shapr> I wonder if Igloo would be up for more ghc-cvs? :-)
17:32:11 <pgavin> when the whole Program type got implemented, didn't it become possible to pass arguments to programs in the .cabal file?
17:32:44 <dcoutts> pgavin: hmm, not sure about that, but certainly from the configure command line, --ghc-args=...
17:32:52 * sorear goes to reread the ATS papers
17:33:00 <shapr> dcoutts: Yeah, used to be A or B type personalities, but #haskell hackers are X type.
17:33:07 <pgavin> dcoutts, ok, I'll start from there then
17:33:27 <dcoutts> shapr: na, he's busy with doing the 6.8 release and then you can have a proper 6.8.1 deb
17:33:35 <pgavin> I'm trying to figure out the best way to get program arguments to the build rules
17:33:41 <dcoutts> shapr: ha, right :-)
17:33:52 <EvilTerran> =/
17:33:58 * EvilTerran has become a victim of code rot
17:34:14 <EvilTerran> i have a function that i could've sworn worked a while ago that doesn't work now...
17:34:23 <dcoutts> pgavin: what kinds of args? using the Program stuff should pass things in automagically
17:35:20 <pgavin> well, I'm thinking about pkg-config stuff
17:36:01 <pgavin> but also, passing the header file name to c2hs
17:36:12 <pgavin> that's something that should be doable in the .cabal file
17:36:13 * EvilTerran blinks
17:36:34 <pgavin> EvilTerran, what's the function?
17:37:36 <EvilTerran> it's :: [[a]] -> [a], and it's supposed to traverse the grid in upward diagonal strips, as in the countability of rationals proof...
17:38:11 <hpaste>  EvilTerran pasted "i don't know what i was thinking when i wrote this" at http://hpaste.org/2522
17:38:20 * sorear wonders how almost all type inference algorithms came to be called W or M
17:38:21 <xerox> > let (.) = fmap in sum $ (^2) . [1..5]
17:38:22 <lambdabot>  55
17:38:22 <dcoutts> pgavin: the header file name is already done automatically, at least for the PreProcessor abstraction
17:38:38 <dcoutts> pgavin: see the c2hs bit in the PreProcessor module
17:38:43 <pgavin> oh, duh.. :)
17:38:52 <pgavin> I forgot about that code
17:40:10 <hpaste>  EvilTerran annotated "i don't know what i was thinking when i wrote this" with "what it's meant to do" at http://hpaste.org/2522#a1
17:40:46 <EvilTerran> wait, that last thing's wrong. ignore it.
17:41:39 <hpaste>  EvilTerran annotated "i don't know what i was thinking when i wrote this" with "what it's *really* meant to do" at http://hpaste.org/2522#a2
17:42:09 <dcoutts> ChilliX: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c2hs-0.15.0
17:42:12 <lambdabot> http://tinyurl.com/ytho43
17:43:33 <chessguy> > [[(x,y) | x <- [0..] | y <- [0..]]
17:43:33 <lambdabot>  Parse error
17:43:41 <chessguy> > [[(x,y) | x <- [0..]] | y <- [0..]]
17:43:43 <lambdabot>  [[(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0),(11,0),...
17:44:31 <EvilTerran> > [[(x,y) | x <- "abc"] | y <- "ABC"]
17:44:32 <lambdabot>  [[('a','A'),('b','A'),('c','A')],[('a','B'),('b','B'),('c','B')],[('a','C'),...
17:45:13 <EvilTerran> AFAICT, that "weave" function is a transpose that can't deal with infinite lists, so it's all a bit pointless
17:46:15 <EvilTerran> (well, concat . transpose)
17:46:23 <oerjan> EvilTerran: i think maybe you forgot to shift the lists with respect to each other
17:46:33 <oerjan> (i recall that function from previously)
17:46:45 <dcoutts> @seen waern
17:46:45 <lambdabot> I saw waern leaving #ghc and #haskell 11m 11s ago, and .
17:46:59 <dcoutts> @tell waern c2hs-0.15.0 is out now on hackage
17:47:00 <lambdabot> Consider it noted.
17:47:17 <EvilTerran> hrm
17:47:18 <ChilliX> dcoutts: Great!  Thanks, but can't the author field have two names.
17:47:29 <ChilliX> You are doing more work on c2hs right now, then I do.
17:47:36 <oerjan> it goes straight down instead of diagonally
17:47:38 <dcoutts> ChilliX: oh, I added my name in the maintainer field
17:48:07 <dcoutts> ChilliX: well, if I do any more I'll bump myself up to co-author :-)
17:48:19 <ChilliX> ok :)
17:48:32 <ChilliX> I'll update the web site
17:48:37 <dcoutts> ta
17:48:44 <dcoutts> I'm sending an email to the c2hs list
17:48:56 <ChilliX> ok, thanks
17:49:46 <EvilTerran> oerjan, can you see a small modification to it that would fix this? i'm trying to work out how this could've got broken by typo
17:53:43 <oerjan> @pl f g x y = g x (h y)
17:53:43 <lambdabot> f = flip flip h . ((.) .)
17:54:01 <oerjan> @pl f x y = g x (h y)
17:54:01 <lambdabot> f = (. h) . g
17:55:14 <hpaste>  oerjan annotated "i don't know what i was thinking when i wrote this" with "perhaps this?" at http://hpaste.org/2522#a3
17:56:13 <EvilTerran> that seems to work... but i'm sure it wasn't quite so painful to behold...
17:56:43 <oerjan> basically the second argument of the folding function needs a [] prepended to it
17:57:02 <EvilTerran> yeah, i see
17:57:41 <byorgey> hm, the reverse monkey operator?  ([]:)
17:58:24 <oerjan> maybe the original was less point-free?
18:00:19 <EvilTerran> i think (([]:).) works, too
18:00:47 <oerjan> ah yes
18:00:57 <EvilTerran> that's a little nicer, and in the pointful version
18:01:27 <oerjan> i googled the original (http://hpaste.org/1787), it seems the same?
18:01:29 <dcoutts> ChilliX: thanks for updating the website, I've sent the announce. If I get positive feedback I'll send the announce to the Haskell mailing list too.
18:01:34 * dcoutts -> bed
18:01:51 <byorgey> night dcoutts
18:01:53 <ChilliX> Thaanks and good night
18:02:09 <EvilTerran> indeed. it seems odd that no-one noticed that time...
18:02:16 <EvilTerran> g'night dcoutts
18:06:39 <EvilTerran> shame about that function. the old one looked damn elegant, even if it didn't work =[
18:07:03 <oerjan> there seems to have been a group attempt at something like it earlier: hpaste.org/1338
18:10:02 <EvilTerran> hm... good to know i'm not missing an obvious solution
18:10:39 <EvilTerran> also amuses me that others also named it "weave"
18:11:35 <oerjan> yeah, that's how i found it with google
18:21:44 <hpaste>  EvilTerran annotated "i don't know what i was thinking when i wrote this" with "here's what i settled on" at http://hpaste.org/2522#a4
18:22:02 <EvilTerran> it's not as efficient as it could be for the restricted case i'm using it for, but hey, it does the job
18:53:05 <idnar> data Tree = Nil | Node !Int Tree Tree
18:53:15 <idnar> what does the !Int there mean?
18:53:19 <adu> hi
18:53:29 <oerjan> strict field
18:53:35 <sjanssen> idnar: the "!" means strict
18:53:39 <adu> hi oerjan, i remember you :)
18:53:54 <oerjan> likewise
18:53:56 <sjanssen> idnar: it means that field will be evaluated when you construct a 'Node'
18:53:56 <adu> how do i write a function like:
18:54:00 <adu> f 2 = [[k1, k2] | k1 <- [1..3], k2 <- [1..3]]
18:54:07 <adu> where 2 is actuallly n
18:54:11 <idnar> ah, got it
18:54:24 <idnar> oerjan, sjanssen: thanks :)
18:54:35 <oerjan> > sequence [[1..3],[1..3],[1..3]]
18:54:37 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
18:55:00 * shapr boings cheerfully
18:55:20 <sfultong> hi shaprboing
18:55:28 <shapr> Hm, shouldn't //input[@type=submit] find a submit button?
18:55:43 <shapr> Oh, I bet it's the quotes.
18:56:13 <shapr> duh
18:56:34 <adu> oh thanks :)
18:57:27 <oerjan> > let f [] = [[]]; f (x:xs) = [k:ks|k <- x, ks <- f xs] in f [[1..3],[1..3]] -- more directly
18:57:29 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
18:57:40 <adu> > sequence [[1..3] | _ <- [1..3]]
18:57:41 <lambdabot>  Illegal character ''\SOH''
18:57:53 <shapr> > '\BAH'
18:57:53 <lambdabot>  Illegal escape sequence
18:58:00 <shapr> > '\wtf'
18:58:01 <lambdabot>  Illegal escape sequence
18:58:03 <shapr> ah well
18:58:17 <sfultong> '\0x2343'
18:58:21 <sfultong> > '\0x2343'
18:58:21 <lambdabot>  Improperly terminated character constant
18:58:39 <chessguy> shapr, is that selenium?
18:58:47 <adu> > sequence [[1..2] | _ <- [1..2]]
18:58:49 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
18:58:51 <shapr> I'm using Selenium for webapp testing.
18:59:11 <chessguy> nice. i use it for the same :)
18:59:20 <chessguy> it needs a binding for haskell though :)
18:59:27 <sfultong> hmm, I've never used list comprehension with _
18:59:36 <adu> > let f n = sequence [[1..n] | _ <- [1..n]] in f 2
18:59:36 <oerjan> > replicate 2 [1..2]
18:59:37 <lambdabot>  [[1,2],[1,2]]
18:59:39 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
18:59:40 <shapr> chessguy: I've been wondering about that...
18:59:51 <shapr> Haven't looked into Selenium Remote Control yet though.
19:00:10 <adu> > sequence $ replicate 2 [1..2]
19:00:12 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
19:00:17 <oerjan> sfultong: it's the equivalence to an expression without <- in do
19:00:17 <adu> thats better
19:00:18 <chessguy> yeah, it lets you write in ruby, python, or html
19:00:26 <oerjan> *equivalent
19:00:44 <sfultong> orejan: in other words, ">>"
19:00:53 <sfultong> err, oerjan, I mean
19:01:00 <chessguy> it probably wouldn't be hard to write do a simple embedded language that could generate appropriate HTML
19:01:04 <ddarius> shapr: Was that XPath?
19:01:13 <shapr> ddarius: Yeah
19:01:56 <sfultong> > [1,2] >> [1,2]
19:02:02 <lambdabot>  [1,2,1,2]
19:02:03 <oerjan> > sequence . join (>>) $ [1..3]
19:02:04 <lambdabot>   add an instance declaration for (Show (m [a]))
19:02:11 * ddarius needs to find some water.
19:02:29 <sfultong> > [1..3] >> [1..3]
19:02:31 <lambdabot>  [1,2,3,1,2,3,1,2,3]
19:02:48 <oerjan> > join (>>) [1..3]
19:02:49 <lambdabot>  [1,2,3,1,2,3,1,2,3]
19:03:10 <oerjan> oh
19:04:09 <sfultong> I gotta make join part of my intuitive repertoire
19:04:36 <ddarius> sfultong: Please don't.
19:04:44 <sfultong> why not?
19:04:49 <oerjan> > (.return) . join (>>) $ [1..3]
19:04:50 <lambdabot>  Couldn't match expected type `m a -> a1'
19:05:15 <oerjan> > join ((.return).(>>)) $ [1..3]
19:05:16 <ddarius> sfultong: People don't actually use join like that in code and they rarely use join in it's general meaning either.
19:05:16 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
19:05:45 <sfultong> ddarius: oh, so what you're saying is that you're against obfuscation, eh? :-P
19:06:03 <ddarius> Yes.
19:06:08 <shachaf> ddarius: In the [] case, for example, is using concat recommended over using join?
19:06:11 <oerjan> > join (map . const) [1..3]
19:06:12 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
19:06:21 <ddarius> schachaf: Yes.
19:06:28 <sfultong> some would say that writing in a functional language with higher-order functions is already obfuscation :-P
19:06:50 <chessguy> shapr, i dunno, i'm not convinced yet that selenium isn't just an ugly hack
19:07:06 * shachaf imagines a functional language without higher-order functions.
19:07:18 <oerjan> > join (mapM . const) [1..3]
19:07:18 <ddarius> http://www.sac-home.org/
19:07:20 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
19:07:20 <sfultong> ok, I was a little redundant there
19:07:22 <lambdabot> Title: SAC-Home [Home]
19:07:28 <shapr> chessguy: Even so, my boss asked me to look into a Haskell interface, so...
19:07:34 <oerjan> yay!
19:07:37 <chessguy> ooooh, nice
19:08:04 <shapr> Looks like it'll be just an interpreter connected to an http client...
19:08:09 * shapr looks at HTTP.Browser
19:08:27 <bparkis> shachaf: that would mean no currying
19:08:51 <shachaf> bparkis: What do you mean? How would it still be a functional language?
19:09:00 <sfultong> yeah, it is possible to use a functional language without using higher-order functions... it's just kinda pointless
19:09:14 <bparkis> well a function that returns another function is a higher order function
19:09:18 <oerjan> shapr: wasn't there some early language where you couldn't define new combinators?
19:09:21 <ddarius> Some people, including me, define "functional" as having no side-effects.
19:09:31 <oerjan> *shachaf
19:09:32 <bparkis> so you can't have a function that takes one argument, and returns a function that takes another argument
19:09:45 <sfultong> yeah, I think anything not purely functional shouldn't be called functional
19:09:46 <shachaf> oerjan: Unlambda?
19:09:51 <ddarius> Categorically, currying is the source of all higher-order functions.
19:10:14 <bparkis> so every function would have to just be of one argument, and if you want more you would need tuples
19:10:42 <shapr> oerjan: What about SASL?
19:10:50 <ddarius> bparkis: Indeed, this leads to the kappa calculus.
19:10:59 <oerjan> shachaf: that's not an early language, i wonder if i am thinking of FP
19:11:55 <adu> isn't Unlambda based on S-K-I?
19:12:02 <int-e> yep
19:12:03 <oerjan> adu: yep
19:12:10 <shachaf> That's pretty early. :-)
19:12:10 <bparkis> does unlambda have I?
19:12:14 <adu> how would you define S in haskell?
19:12:16 <int-e> yes it does
19:12:17 <oerjan> bparkis: yep
19:12:20 <int-e> adu: ap
19:12:25 <shachaf> bparkis: It has even more combinators than SKI.
19:12:27 <ddarius> @pl \f g x -> f x (g x)
19:12:28 <lambdabot> ap
19:12:29 <int-e> @type ap
19:12:30 <chessguy> @bot
19:12:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:12:31 <lambdabot> :)
19:12:41 <adu> ddarius: no i mean points-free definition of S
19:12:43 <sfultong> @bottom
19:12:43 <lambdabot> Unknown command, try @list
19:12:44 <int-e> (with m = (r ->)
19:12:46 <int-e> )
19:13:11 <ddarius> adu: You could, but why?  The whole point is that S and K are defined with "variables" so nothing else need be.
19:13:30 <shachaf> adu: Defined in terms of what?
19:13:44 <oerjan> @pl \x y z -> x z (y z)
19:13:45 <lambdabot> ap
19:14:18 <adu> shachaf: haskell
19:14:27 <adu> as in I = id, K = const
19:14:41 <shachaf> adu: You can't define S in terms of I and K.
19:15:04 <shachaf> adu: Oh, that's not what you meant.
19:15:09 <adu> shachaf: i know but something like: S = (flip . const . join ...) or something
19:15:12 <SamB_XP_> X!
19:15:22 <shachaf> adu: I meant, in terms of what functions do you want to define it?
19:15:24 <int-e> shachaf: ap
19:15:24 <SamB_XP_> shapr can maybe tell you something
19:15:29 <shachaf> int-e: I know.
19:15:37 <shapr> ?
19:15:41 <shachaf> X = \x -> x S K, right?
19:15:43 <bparkis> adu you'd have to define flip, const, join, etc. which is no simpler
19:15:45 <EvilTerran> pointsfree code is done entirely using combinators. you've got to define at least one combinator in terms of something else (generally lambda abstraction/applicatiom)
19:16:08 <EvilTerran> @src (.)
19:16:08 <lambdabot> (.) f g x = f (g x)
19:16:14 <EvilTerran> @src flip
19:16:14 <lambdabot> flip f x y = f y x
19:16:19 <EvilTerran> @src curry
19:16:19 <lambdabot> curry f x y = f (x, y)
19:16:34 <EvilTerran> in the end, it all boils down to functions eventually
19:16:42 <SamB_XP_> with lambdas!
19:17:06 <sfultong>  @type iterate curry !! 10
19:17:13 * oerjan wonders if there is a turtle combinator
19:17:15 <sfultong> @type iterate curry !! 10
19:17:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
19:17:17 <lambdabot>     Probable cause: `curry' is applied to too few arguments
19:17:20 <ddarius> Green tea or black tea?
19:17:23 <SamB_XP_> sfultong: hahahaha
19:17:32 <oerjan> for when you really need to go all the way down
19:17:41 <SamB_XP_> oerjan: you mean fix turtle?
19:17:51 <shapr> shapr can maybe tell you wat?
19:18:06 <oerjan> perhaps
19:18:24 <SamB_XP_> @let turtle = fix turtle
19:18:25 <lambdabot> <local>:3:9:     Occurs check: cannot construct the infinite type: a = a -> a...
19:18:29 <SamB_XP_> aww
19:19:02 <SamB_XP_> oh, but that still leaves fix anyway ;-P
19:19:04 <ddarius> OCaml with -rectypes would allow that (modulo using an applicative fix function)
19:20:44 <oerjan> :t fix . fix
19:20:47 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
19:20:55 <ddarius> :t break fix
19:20:57 <lambdabot> [Bool -> Bool] -> ([Bool -> Bool], [Bool -> Bool])
19:21:45 <oerjan> :t fix (break fix . fst)
19:21:47 <lambdabot> ([Bool -> Bool], [Bool -> Bool])
19:22:32 <sfultong> stop it! the vebal and mathematical element of my brain are killing each other!
19:22:41 <sfultong> *elements
19:22:45 <oerjan> :t (fix . fst . fix) (break fix . fst)
19:22:48 <lambdabot>     Couldn't match expected type `[Bool -> Bool]'
19:22:48 <lambdabot>            against inferred type `a -> a'
19:23:19 <oerjan> :t (fix . head . fst . fix) (break fix . fst)
19:23:22 <lambdabot> Bool
19:24:04 <int-e> shachaf: yes that X works, X (X (X X)) = K and X K = S
19:27:05 <oerjan> :t (fix . head . fst . fix) (break fix . snd) -- more philosophical
19:27:08 <lambdabot> Bool
19:28:46 <sfultong> too bad there isn't a 'god' function
19:29:13 <jbauman> @pl \x -> x ap const
19:29:14 <lambdabot> flip ($ ap) const
19:29:24 <oerjan> god = fix djinn
19:29:56 <shachaf> god = god % djinn?
19:30:15 <oerjan> ah yes
19:30:44 <oerjan> god = fix (% djinn)
19:33:50 <shachaf> @god
19:33:50 <lambdabot> Maybe you meant: ghc id todo yow
19:34:44 <shachaf> @sf
19:34:44 <lambdabot> Done.
19:34:56 <shachaf> Hmm. What is that getting corrected to?
19:35:01 <newsham> > (\xs -> ((reverse.filter isAlpha) xs, xs)) "dogma? I am god!"
19:35:03 <lambdabot>  ("dogmaIamgod","dogma? I am god!")
19:35:11 <oerjan> @sfu
19:35:11 <lambdabot> Maybe you meant: bf ft src
19:35:15 <newsham> > (\xs -> ((reverse.filter isAlpha) xs, filter isAlpha xs)) "dogma? I am god!"
19:35:16 <lambdabot>  ("dogmaIamgod","dogmaIamgod")
19:35:23 <oerjan> @src
19:35:24 <lambdabot> src <id>. Display the implementation of a standard function
19:35:30 <oerjan> @bf
19:35:30 <lambdabot> Done.
19:35:40 * EvilTerran notes that his prime-number dumping program has got up to 2822143 in the last, oh, 3hr30
19:35:44 <oerjan> my guess on @bf
19:35:46 <EvilTerran> *2hr30
19:35:50 <shachaf> Oh, OK.
19:36:07 <shachaf> @bf is broken, though, I think. :-(
19:36:08 <lambdabot>  fd:25: hClose: resource vanished (Broken pipe)
19:36:11 <shachaf> As is @unlambda.
19:36:45 * EvilTerran is dumping primes to disk until he gets bored (or until Int overflows) for the purposes of Project Eulering
19:36:45 <oerjan> yep
19:37:43 <shachaf> Is this a 32-bit or 64-bit Int?
19:38:05 <EvilTerran> 32-bit
19:38:08 <EvilTerran> > maxBound :: Int
19:38:10 <lambdabot>  2147483647
19:38:25 <EvilTerran> i think i'll still get bored before it overflows
19:38:33 <oerjan> > bitSize (undefined::Int)
19:38:34 <lambdabot>  32
19:40:13 <EvilTerran> if i decide i need more than i'm generating now at a later date, it's definitely a heck of a lot faster to slurp them off disk than work them out again
19:40:39 <dibblego> hash them too
19:40:42 <EvilTerran> at this stage the slowdown from evaluating massive thunks is really getting rather noticable.
19:40:49 <EvilTerran> hash them?
19:40:56 <dibblego> for verification
19:41:08 <sfultong> heh, I thought the other hash
19:41:12 <EvilTerran> verify my primes?
19:41:33 * EvilTerran is confused
19:43:30 <oerjan> why should the thunks be massive?
19:44:23 <oerjan> hm, yes
19:44:57 <oerjan> it should be possible to strictify things
19:45:14 <EvilTerran> because they're effectively "\i -> i `mod` 2 /= 0 && i `mod` 3 /= 0 && i `mod` 5 /= 0 && i `mod` 7 /= 0 && i `mod` 11 /= 0 && ..."
19:45:47 <EvilTerran> strictifying would work, i guess, if i wanted to put an upper limit on the range i'm working in
19:46:50 <EvilTerran> i imagine i'm not being as efficient as i could be about this anyway, though. there's algorithms and algorithms.
19:48:23 <oerjan> yeah
19:49:01 <EvilTerran> i imagine the first 200k primes aughta last me through quite a few of the projecteuler problems, anyway.
19:49:32 <EvilTerran> heck, if i wanted *loads*, i'm sure you can download lists of the first umpteen gazillion primes all bzipped up and ready-to-use
19:50:02 <EvilTerran> there'll be *someone* on ebay selling the first 700MB of primes on CDR
19:50:03 <jbauman> but then it wouldn't seem handmade
19:50:35 <sorear> primes | bzip2 | nc 86.132.135.190 80
19:51:37 <EvilTerran> ...what's that IP?
19:52:08 <oerjan> host86-132-135-190.range86-132.btcentralplus.com
19:52:17 * EvilTerran has a look; ah, that'd be me, then.
19:52:27 <EvilTerran> well, the router.
19:53:24 <EvilTerran> (for the curious: the program i'm currently using is "primes = primesIn [2::Int ..] where primesIn (x:xs) = x : primesIn (filter (\y -> y `mod` x /= 0) xs)
19:53:24 <EvilTerran> "
19:53:39 <EvilTerran> oh, and main = mapM_ print primes
19:53:47 <EvilTerran> compiled with gcc -O2
19:54:00 <EvilTerran> that was as efficient as i could be bothered being
19:57:19 * sfultong goes to find a P prime generator ... "be back in a few"
19:59:56 <oerjan> EvilTerran's generator is P, isn't it?
20:01:17 <adu> has anyone seen http://www.primegrid.com/orig/torrent.php ?
20:01:19 <lambdabot> Title: Download Prime Lists
20:01:53 <EvilTerran> there we go! never mind CDs, they've got DVD-fuls
20:01:58 <adu> EvilTerran: :)
20:02:24 <EvilTerran> zero to... 35 BILLION?! O.O
20:03:03 <adu> hehe
20:03:11 <oerjan> not more?
20:03:28 <EvilTerran> that's only the first DVD...
20:03:40 <oerjan> oh
20:03:52 <EvilTerran> the last one's, what, 175 billion? i'm losing track of the 0s, but that seems plausible
20:04:29 <Pseudonym> This reminds me of the CD full of random bits.
20:04:38 * EvilTerran is tempted to get the first DVD in case he ever wants a helluvalot of primes
20:04:48 <Pseudonym> Created from a radioactive source mixed with sampled rap music.
20:04:58 <Pseudonym> And yes, it was called "white and black noise".
20:05:01 <aFlag> I have a list of tuples (SockAddr, String) I want to append a string to that string in the tuple if I can match the SockAddr. Otherwise I want to append to the list a new (SockAddr, String). What would be a nice way to do that? All I can think of is rather clumsy. And it seems like there's a neat way of doing it since map almost does it.
20:05:02 * sfultong wonders if anyone makes a living as a prime dealer
20:05:31 <Pseudonym> sfultong: I don't know anyone like that.  But... I have this friend of a friend...
20:05:39 * oerjan groans
20:05:52 <adu> lol
20:05:54 <Pseudonym> So if you want a couple of M's...
20:05:57 <sfultong> Pseudonym: heheh, re: white & black
20:06:16 <SamB_XP_> aFlag: use a Data.Map
20:06:25 <adu> i wish i knew how to factor
20:07:05 <sfultong> I know how to factor... just not efficiently
20:07:25 <SamB_XP_> aFlag: it has a function that'll do exactly what you want, if you tell it how to combine the strings
20:07:27 <segher> is there a standard function to give me the index of the first entry in a list that satisfies some predicate?
20:07:44 <SamB_XP_> @type find
20:07:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:07:52 <SamB_XP_> hmm.
20:07:55 <SamB_XP_> @type findIndex
20:07:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
20:08:02 <SamB_XP_> segher: that one
20:08:12 <segher> thanks!
20:08:16 <SamB_XP_> you are welcome
20:08:38 <adu> I'm so close to defining S
20:08:56 <segher> S f g x = f x (g x)
20:08:59 <adu> so far i got skiS = flip id ($!)
20:09:02 <segher> done :-)
20:09:11 <SamB_XP_> @pl flip id ($!)
20:09:11 <lambdabot> ($ ($!))
20:09:16 <SamB_XP_> @pl flip id ($)
20:09:16 <lambdabot> ($ id)
20:09:45 <SamB_XP_> @pl s f g x = f x (g x)
20:09:45 <lambdabot> s = ap
20:10:09 <EvilTerran> @src ap
20:10:10 <lambdabot> ap = liftM2 id
20:10:32 <byorgey> @type flip id ($)
20:10:35 <lambdabot> forall c a b. (((a -> b) -> a -> b) -> c) -> c
20:10:42 <byorgey> @type ap
20:10:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:10:54 <oerjan> adu: none of flip, id or ($!) duplicate anything, which you need for S
20:11:16 <oerjan> also $! is just $ with strictness
20:11:28 <adu> hmm
20:11:45 <byorgey> also, ($) == id
20:11:59 <adu> what do you mean "strictness"
20:12:17 <SamB_XP_> > fix (error $!)
20:12:18 <lambdabot>  Exception: <<loop>>
20:12:27 <oerjan> > const 1 $ undefined
20:12:28 <lambdabot>  1
20:12:29 <SamB_XP_> hmm. bad example
20:12:30 <byorgey> adu: it's the opposite of "laziness"
20:12:31 <adu> i thought strict was when the types were not allowed to be variant
20:12:32 <oerjan> > const 1 $! undefined
20:12:33 <lambdabot>  Undefined
20:12:45 <SamB_XP_> adu: eh???
20:12:46 <byorgey> adu: no
20:12:49 <oerjan> adu: that's monomorphic
20:13:03 <SamB_XP_> the only "variant" I can think of is from VB... ;-P
20:13:12 <adu> oh so ($!) evaluates x before f...
20:13:17 <oerjan> as opposed to polymorphic
20:13:29 <oerjan> right
20:13:31 <byorgey> adu: right.
20:13:31 <adu> ok
20:13:44 <aFlag> SamB_XP_, great, thanks :)
20:14:05 <SamB_XP_> aFlag: quite welcome
20:14:11 <adu> so skiS = liftM2 id ?
20:14:39 <oerjan> @pl liftM2 id
20:14:39 <lambdabot> ap
20:14:50 <oerjan> @src ap
20:14:50 <lambdabot> ap = liftM2 id
20:15:20 <oerjan> for the (e ->) monad
20:16:53 <adu> hmm
20:16:58 <oerjan> you might be able to use the &&& operator, or join
20:17:35 <oerjan> those can do duplication
20:18:49 * sorear observes that a -term is structurally valid in linear logic iff it can be expressed using only (.), flip, and id
20:19:18 <ddarius> eval = foldExp c k s
20:19:41 <byorgey> S f g = uncurry id (f &&& g)
20:20:03 <oerjan> are (.) and flip B and C?
20:20:10 <ddarius> Yes
20:20:11 <sorear> C and B
20:20:19 <ddarius> No, B = (.)
20:20:43 <sorear> argh...
20:21:26 <ddarius> You'd think C would be for Composition...
20:21:29 * oerjan never remembers which is which either
20:21:40 <Pseudonym> ddarius: Except that B and C stand for something German.
20:22:03 <shapr> I wish HUnit had explicit support for setup and teardown.
20:22:30 <Pseudonym> I remember them, because I think of them in terms of graph reduction.
20:22:36 <oerjan> @src flip
20:22:37 <lambdabot> flip f x y = f y x
20:22:42 <Pseudonym> B moves the argument to the left, C to the right
20:22:57 <Pseudonym> (B f g) x = (f x) g, (C f g) x = f (g x)
20:23:11 <Pseudonym> Ernm.
20:23:16 <Pseudonym> I just got that wrong, didn't I.
20:23:20 <kfish> i thought Bfgx = Bf(gx)
20:23:25 <kfish> i thought Bfgx = f(gx)
20:23:29 <Pseudonym> Yes, it is.
20:23:32 <Pseudonym> OK, ignore me.
20:23:36 <Pseudonym> I just happen to remember them. :-)
20:23:48 <Pseudonym> And, of coruse, (S f g) x = (f x) (g x)
20:23:53 * ddarius just has them remembered as well.
20:24:34 <Pseudonym> Now that I think about it, you can blame Haskell Curry for the names.
20:24:38 <ddarius> S and K can be given mnemonic English meanings and are pretty significantly related to evaluation in an environment (obviously)
20:24:50 <Pseudonym> In Schoenfinkel's work, they were called soemthing different.
20:25:00 <ddarius> I blame Turner.
20:25:07 <Pseudonym> B was called Z and C was called T.
20:25:35 <ddarius> That would be -much- clearer...
20:26:04 <oerjan> Zusammensetzung perhaps
20:27:43 <Pseudonym> Well I couldn't find his PhD thesis, but I did find his notes on camping supplies.
20:27:45 <Pseudonym> http://www.sadl.uleth.ca/gsdl/cgi-bin/library?e=d-00000-00---0curry--00-0--0-10-0---0---0prompt-10---4-------0-1l--11-en-50---20-about-logic--00-0-1-00-11-1-0utfZz-8-00&a=d&c=curry&cl=CL2&d=T220801A
20:27:47 <Pseudonym> Useful!
20:27:49 <lambdabot> Title: , http://tinyurl.com/2gmdpw
20:28:06 <byorgey> S = ((uncurry id .) .) . (&&&)
20:29:20 <oerjan> oh, Curry's thesis was actually in German
20:29:27 <Pseudonym> Yeah.
20:29:33 <Pseudonym> All the good logic work in 1930 was in German.
20:29:58 <aFlag> SamB_XP_, using Map didn't really work out all that good, SockAddr is instance of Eq, but not of Ord
20:30:25 <SamB_XP_> aFlag: hmm. wonder why not!
20:30:31 <SamB_XP_> it's not like it'd be that hard
20:30:52 <SamB_XP_> nevermind whether the order would make any apparant sense, as long as it was a full order...
20:31:08 <aFlag> I think the problem is because it has two constructors
20:31:13 <Pseudonym> http://www.sadl.uleth.ca/gsdl/cgi-bin/library?e=d-00000-00---0curry--00-0--0-10-0---0---0prompt-10---4-------0-1l--11-en-50---20-about---00-0-1-00-11-1-0utfZz-8-00&a=d&d=T290114A&p=full
20:31:14 <aFlag> one for inet and other for unix
20:31:15 <lambdabot> Title: 1, http://tinyurl.com/yvxxvf
20:31:22 <Pseudonym> "Das Paradoxen von Epimenides"
20:31:28 <Pseudonym> Good old Haskell.
20:32:10 <aFlag> I guess I could instantiate it and order by IP
20:34:10 <oerjan> aFlag: if it's a short list it might be cleaner to write a list function
20:35:01 <oerjan> findIndex and splitAt would work
20:36:04 <aFlag> it should be short
20:36:22 <shapr> yarr
20:38:17 <oerjan> so case findIndex ((==x).fst) l of Nothing -> l ++ ...; Just n -> case splitAt n l of (bef,(y,s):rest) -> bef++(y,s++...):rest
20:43:22 <aFlag> that looks good, but I already made an instance of Ord, so I guess I'll stick with it :P
20:43:31 <oerjan> ok
21:08:49 <shapr> What just happened to the internet?
21:09:03 <oerjan> ?
21:09:22 <Pseudonym> The tubes got blocked?
21:09:24 <sebell> The intertubes can get clogged from time to time
21:12:08 <SamB_XP_> that's what the hexadecimal bypass is for
21:12:26 <gvdm_other> 0x1A4
21:21:47 <kolmodin> question: is there some TH code (or similar) that can give me Show instances that work like this? http://docs.python.org/lib/module-pprint.html
21:21:48 <lambdabot> Title: 5.18 pprint -- Data pretty printer
21:22:20 <kolmodin> would be useful to dump structures while debugging
21:24:24 <oerjan> doesn't deriving (Show) do what you want?
21:25:19 <kolmodin> almost, yeah, but I think that output is hard to read
21:25:21 <SamB_XP_> oerjan: he wants Pretty, not Show
21:25:38 <kolmodin> aye
21:25:56 <oerjan> oh. a post-processor maybe?
21:26:01 <SamB_XP_> kolmodin: you can write some for Derive
21:26:26 <kolmodin> SamB_XP_: I can. but I was hoping someone else already had done it :)
21:26:40 <SamB_XP_> well, check the repository first
21:26:54 <SamB_XP_> oh. and some sort of tests would be nice!
21:27:06 <kolmodin> of derive?
21:27:34 <SamB_XP_> of your deriving
21:28:22 <kolmodin> huh?
21:28:34 <SamB_XP_> after you write it!
21:28:46 <kolmodin> :)
21:29:44 <kolmodin> ?localtime
21:29:48 <lambdabot> Local time for kolmodin is Fri Aug 31 06:25:34 2007
21:29:54 <sjanssen> kolmodin: try running the 'Show' output through Language.Haskell's pretty printer
21:30:18 <kolmodin> sjanssen: hmm, good idea. I'll try that quickly
21:30:37 <SamB_XP_> sjanssen: it will surely fail
21:30:43 <SamB_XP_> ... sooner or later
21:30:59 <kolmodin> hmm, yeah. that's only h98
21:31:50 <sjanssen> should be fine for all derived Show instances that don't have infix data constructors
21:32:51 <SamB_XP_> true
21:35:27 * oerjan doesn't see a way to use Pretty on the output of show
21:42:00 <gigamonkey_> mudge: did you just leave a comment on Coders at Work because of my latest blog post?
21:42:09 <dons> ?re
21:42:09 <lambdabot> Maybe you meant: read reconnect redo remember repoint rc
21:42:12 <dons> ?users
21:42:12 <lambdabot> Maximum users seen in #haskell: 394, currently: 357 (90.6%), active: 10 (2.8%)
21:43:45 <oerjan> @help repoint
21:43:45 <lambdabot> pointful <expr>. Make code pointier.
21:44:02 <oerjan> @list repoint
21:44:04 <lambdabot> pointful provides: pointful pointy repoint unpointless unpl unpf
21:44:22 <oerjan> O_o
21:44:29 <oerjan> @help pointy
21:44:29 <lambdabot> pointful <expr>. Make code pointier.
21:44:37 <oerjan> are all those synonyms?
21:44:53 <oerjan> @list pl
21:44:54 <lambdabot> pl provides: pointless pl-resume pl
21:44:59 <glguy> any arch linux users here?
21:45:22 <oerjan> @help pl-resume
21:45:22 <lambdabot> pl-resume. Resume a suspended pointless transformation.
21:45:27 <sebell> glguy: Once upon a time.
21:45:34 <jtokle> glguy: i use arch!
21:45:42 <jtokle> but i'm no kind of expert
21:48:05 <aFlag> isn't there a substring function?
21:48:11 <bos> aFlag: no
21:48:19 <bos> aFlag: use take and drop instead
21:48:26 <mudge> gigamonkey: yea
21:48:48 <oerjan> > take 5 . drop 5 $ [1..20]
21:49:07 <oerjan> @bot
21:49:14 <oerjan> whoops
21:49:26 <EvilTerran> um...
21:49:51 <aFlag> I want to see if a string is a substring of a given string there isn't a function for that?
21:50:00 <EvilTerran> aFlag, isInfixOf, iirc
21:50:00 <oerjan> isInfixOf
21:50:04 <EvilTerran> @bot
21:50:07 <EvilTerran> ...
21:50:23 <oerjan> ah, the panic of lambdabot withdrawal
21:51:23 <aFlag> hoogle doesn't seem to find that function
21:51:50 <dolio> Hoogle's database is too old.
21:51:50 <oerjan> Data.List
21:52:17 <dolio> @pl-resume
21:52:32 <dolio> I hope I didn't kill her.
21:53:00 <sorear> dons ...
21:53:48 <sorear> ah. :)
21:53:58 <dolio> There we go.
21:55:06 <jbauman> no more lambdabot?
21:55:35 <dolio> Not until the split is over.
21:55:48 --- mode: irc.freenode.net set +o ChanServ
21:55:59 <sorear> @bot
21:56:27 <EvilTerran> @bot!
21:57:32 <dolio> Oh well.
21:58:00 <dolio> I guess I won't try "@pl \a b c d e ... -> t h e q u i c k ..." in the future. :)
21:58:18 <oerjan> you did that?
21:58:26 <dolio> In a private message.
21:58:27 <EvilTerran> o god. that'd be horrible.
21:58:39 <lambdabot> :)
21:58:39 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
21:58:48 <EvilTerran> yay bot!
21:58:51 <mudge> wow
21:58:51 <mudge> will look like I disconnected for those other people?
21:58:51 <mudge> well I hope they all comeback
21:58:54 <mudge> dons: you there?
21:59:19 <Heffalump> mudge: yes, it will
21:59:28 <sorear> @activity-full 900
21:59:29 <lambdabot> 80*total 71*dolio 5*#haskell 3*byorgey 1*EvilTerran
22:00:12 <bos> @seen dons
22:00:12 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 18m ago.
22:00:53 <jtokle> there's a #haskell-soc?
22:02:11 <bos> hmm, binary has a strictness bug.
22:03:12 <kolmodin> bos: we had one when ByteString's Lazy.append was too strict. you've found another?
22:03:21 <bos> yes, in runGetState
22:03:55 <bos> the second element in the case expression causes more input to be demanded
22:04:05 <bos> second element in the pattern, that is
22:04:16 <bos> making that element of the pattern irrefutable fixes the problem
22:04:34 <mudge> bos: are you going to the functional programming meeting in San Francisco?
22:04:39 <bos> i would be lying if i said i knew exactly why that's a problem.
22:04:40 <bos> mudge: yes.
22:04:46 <mudge> bos: cool
22:04:59 <mudge> bos: did you see, I quoted you on my blog
22:05:22 <bos> mudge: no, are you syndicated on planet haskell?
22:05:42 <mudge> no, but I'd like to be!   I intent to write a lot more haskell stuff
22:09:41 <hpaste>  bos pasted "strictness bug in binary" at http://hpaste.org/2523
22:12:06 <bos> kolmodin: i sent a patch to dons just now to fix this.
22:13:02 <mudge> bos: just FYI: http://nickmudge.info/
22:13:03 <lambdabot> Title: Nick Mudge's Weblog
22:13:16 <bos> cheers
22:13:28 <kolmodin> bos: thanks
22:14:27 * bos is using binary to write a pure mysql client
22:14:56 * kolmodin is using binary to write a pure dbus client
22:15:12 <kolmodin> bos: neat!
22:15:33 <dons> ah, bos. right! well spotted
22:16:01 <mudge> question: what do you guys think about the idea of building your own datastorage mechanism for website data,  instead of using something like MySQL or PostgreSQL?
22:16:11 <bos> mudge: this is what happs already does
22:16:40 <jtokle> using binary?
22:17:05 <bos> my intention with the mysql client is to put it to dual use: both as a normal client and to monitor mysql traffic using pcap
22:17:11 <mudge> bos: cool
22:30:45 <sorear> @seen ibid
22:30:45 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
22:33:22 <sorear> @users
22:33:22 <lambdabot> Maximum users seen in #haskell: 394, currently: 357 (90.6%), active: 8 (2.2%)
22:34:31 <mudge> what's going on sorear?
22:34:48 <EvilTerran> man, not having to think about using arbitrary-sized integers rocks.
22:35:18 <sorear> mudge: 22:04 < mudge> no, but I'd like to be!   I intent to write a lot more haskell stuff
22:35:32 <sorear> mudge: ibid is the planet haskell maintainer
22:36:47 <mudge> sorear: oh thanks
22:37:18 <mudge> ibid: hello
22:37:48 <mudge> sorear: what IRC application do you use?  I'm thinking it might be a good idea for me to switch
22:37:56 <sorear> irssi
22:38:05 <mudge> ah, I've seen that one around
22:38:12 <mudge> it is command line based?
22:38:18 <EvilTerran> is there a cunning list monad way of saying "permutations of a list"?
22:38:57 <shachaf> mudge: Console-based.
22:38:58 <sorear> no, it's full screen
22:39:22 <mudge> oh okay
22:39:40 <mudge> I've been using KDE's Konversation
22:39:51 <sorear> mudge: or, you can handle Haskell but you're afraid of a puny excuse for a programming language like shell commands?
22:40:00 <sorear> :P
22:40:18 <mudge> haha
22:40:55 <mudge> sorear: what do you mean?
22:41:07 <sorear> 22:36 < mudge> it is command line based?
22:41:11 <oerjan> > perms [] = [[]]; perms l = [x:xs | (p,x:r) <- zip (inits l) (tails l), xs <- perms (p++r)] in perms [1,2,3]
22:41:11 <lambdabot>  Parse error
22:41:15 <mudge> oh okay
22:41:16 <mudge> yea
22:42:02 * shachaf is far more afraid of some GUIs than of most CLIs.
22:42:13 <ibid> mudge: pong
22:42:37 <mudge> when I started up IRC I wasn't sure how long I'd be using it,   so was just checking it out,    didn't want to learn a bunch of stuff if I wasn't really going to be using it
22:43:01 <ibid> mudge: your luck that i just woke up. usually people ping me in the middle of the night, when i'm abed :)
22:43:01 <oerjan> > let perms [] = [[]]; perms l = [x:xs | (p,x:r) <- zip (inits l) (tails l), xs <- perms (p++r)] in perms [1,2,3]
22:43:02 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
22:43:18 <shachaf> mudge: http://planet.haskell.org/policy.html may be helpful.
22:43:20 <lambdabot> Title: Membership policy - Planet Haskell
22:43:28 <mudge> but I know consider IRC a part of my regular programming education and experience,  so think it is worth getting more substantial about it,   like learning IRC commands in a console
22:43:53 <mudge> ibid: ah lucky me
22:43:56 <mudge> !
22:43:57 <oerjan> EvilTerran: came up the other day
22:44:02 * shachaf should learn more about IRC and irssi.
22:44:15 <ibid> mudge: you had something for me?
22:44:38 <mudge> yea!   I was wondering if you'd be willing to add my blog to planet haskell
22:44:51 <mudge> i sent you an email
22:45:07 <ibid> mudge: you've read http://planet.haskell.org/policy.html?
22:45:09 <lambdabot> Title: Membership policy - Planet Haskell
22:45:27 <ibid> mudge: recently? ok, i haven't read my mail since i went to bed about 12 hours ago
22:46:37 <mudge> yea, like  10 minutes ago
22:46:49 <ibid> ok :)
22:46:50 <ibid> just read
22:47:23 <mudge> ibid: i think my blog most falls under this policy point: also eligible are blogs that discuss Haskell-related matters frequently
22:48:00 <mudge> i plan to write a lot more haskell and functional programming specific blog posts about things that are happening and about neat programming stuff
22:48:18 <ibid> mudge: yeah, and you seem to be getting yourself into the community too, witness this channel :)
22:48:21 <mudge> things that are happening with haskell/functional programming, that is
22:48:30 <mudge> :)
22:48:32 <ibid> mudge: i'm adding you. will take a couple of minutes
22:48:56 <mudge> oh, awesome,  thanks!
22:51:09 <mudge> gees,  I found out one day that IRC is a treasure trove
22:51:35 <aFlag> I want to find out if a string has a substring FOO not preceded of \, on an imperative language I'd iterate over the string using a switch and a state variable. What would be the best approach for doing that on haskell?
22:51:39 <ibid> mudge: how long have you been ircing? (just curiosity)
22:52:16 <mudge> like two weeks
22:52:34 <mudge> two and half week maybe
22:52:50 <ibid> aFlag: my first idea would be to pattern-match that on the beginning of the string, and if no match, do a tail-recursive call dropping one (or more, depending) character from the start
22:53:04 <ibid> aFlag: probably isn't the best approach, though
22:53:36 <aFlag> hm I need something more general than that, actually because I have a list of substrings and I want to do that for all of them
22:53:51 <ibid> mudge: added
22:54:05 <aFlag> I'd have to do a bunch of pattern matching your way
22:54:11 <ibid> aFlag: ah, so the spec is not what you said :)
22:54:20 <mudge> awesome thanks
22:54:42 <aFlag> yeah, I tried to make it simpler, but I guess it was a wrong idea :P
22:54:44 <ibid> aFlag: i don't have an immediate solution for you on that. i'd consider regexps, for example
22:54:49 <aFlag> a bad idea
22:54:59 <aFlag> hm
22:55:13 <oerjan> aFlag: tails is a good function to use
22:55:14 <aFlag> regexps should solve it easily
22:55:38 <oerjan> hm...
22:55:47 <mudge> ibid: also just so you know a little about me:  In June I started getting interested in functional programming,  studying Common Lisp,   studied it until the end of July,  then got really interested in Haskell, and have been studing it ever since
22:56:04 <takamura> hi
22:56:16 <TSC> Hi
22:56:22 <ibid> mudge: if you want to tell people about it, blog :)
22:56:38 <mudge> ibid: haha, okay, thanks
22:56:52 <adu> well, I implemented the determinant algorithm
22:57:01 <adu> and its not very fast
22:57:14 <ibid> mudge: but do ping me if you lose interest in haskell, so i know to remove you from planet. i hate to have to judge people, so it's better if they request removal themselves, if appropriate :)
22:58:05 <oerjan> > let check sub s = or [sub `isPrefixOf` r | (c:r) <- tails (' ':s), c /= '\\'] in check "abc" "\\abc"
22:58:06 <lambdabot>  False
22:58:12 <mudge> ibid: okay, I will thanks
22:58:14 <oerjan> > let check sub s = or [sub `isPrefixOf` r | (c:r) <- tails (' ':s), c /= '\\'] in check "abc" "\\fabc"
22:58:15 <lambdabot>  True
22:59:08 <oerjan> adu: did you see my attempt on hpaste?
22:59:15 <mudge> ibid: thanks for adding me, I appreciate it
22:59:39 <ibid> mudge: but mind, that's only if you lose interest in a way that's likely to be permanent (or at least last months or years). no need to remove if you start writing on something else for a while, but plan to come back to haskell
22:59:52 <adu> oerjan: nope i didn't
23:00:01 <adu> oerjan: wanna see mine?
23:00:02 <adu> http://pastebin.com/m66fbcdf6
23:00:19 <mudge> ibid: okay,
23:00:44 <ibid> mudge: (also if you continue to qualify under some other point:)
23:00:55 <aFlag> > let check sub s = or [sub `isPrefixOf` r | (c:r) <- tails (' ':s), c /= '\\'] in check "abc" "xx\\abc"
23:00:56 <lambdabot>  False
23:00:58 <mudge> ibid: also    if you have any comments about any of the material that I might write,   good or bad,   if it is good contribution or not,   feel free to let me know
23:01:27 <aFlag> hm, wouldn't tails return a list with "\\abc" and "abc" in it?
23:01:41 <shachaf> aFlag: Yes.
23:01:45 <ibid> mudge: i deliberately avoid doing that
23:01:53 <mudge> ibid: haha,  okay
23:02:09 <shachaf> aFlag: Is that a problem?
23:02:22 <aFlag> it doesn't seem like it
23:02:26 <ibid> mudge: planet is not about "contributions" but about people
23:02:29 <aFlag> but I can't figure out why
23:02:51 <mudge> ibid: oh, good to know
23:02:56 <shachaf> aFlag: Because "sub `isPrefixOf` r", where r is the tail.
23:03:14 <mudge> Ibid:  and yea,   looking at it,  i see that
23:03:18 <shachaf> aFlag: That's also why the first ' ' isn't checked.
23:03:27 <oerjan> aFlag: i do a check on the character c just before r
23:03:45 <oerjan> and added a dummy ' ' for the start
23:04:13 <ibid> mudge: the qualification criteria are there just to make sure we don't have any irrelevant people there :)
23:04:28 <ibid> mudge: and to make my work more transparent :)
23:04:39 <mudge> ibid: okay, cool
23:04:46 <aFlag> hm, I think I get it
23:04:50 <ibid> mudge: and so i don't have to reject very often (as people will see my criteria) :)
23:05:32 <mudge> ibid: okay,    yea,  it's a particular niche,  but not too nichey
23:06:22 <ibid> mudge: sounds great, but i don't understand that :)
23:06:32 <mudge> ibid: I hate to use the term "niche" though,  when talking about people peopleness  but just have lack of a better term
23:07:13 <ibid> but i should shut up and get to a shower
23:07:31 <gigamonkey_> mudge: thanks for the comment on Coders at Work
23:07:37 <gigamonkey_> (that was you, right?)
23:07:46 <mudge> gigamonkey: yea
23:07:59 <gigamonkey_> I assume you saw my latest blog post and that's why you added a comment?
23:08:08 <mudge> gigamonkey: welcome,  I liked adding a comment
23:08:16 <mudge> gigamonkey: yea
23:08:30 <gigamonkey_> Anyway, congrats--your post was the first ham to be filtered by my newly installed spam filter.
23:08:35 <gigamonkey_> Very exciting.
23:08:53 <mudge> oh nice
23:09:19 <mudge> after I posted it I wondered if it would show up right away  because I had read about the new spam filter
23:09:20 <mudge> I guess it worked
23:09:43 <gigamonkey_> Yup. The spammers who are spamming me are diabolically stupid.
23:10:37 <mudge> ibid: I have a little blog aggregation experience,  I have an aggregator of government employees (or people in government) who blog about government: http://govfeed.com/blogs/aggregator.php
23:10:40 <lambdabot> Title: Government Feeds
23:11:17 <mudge> though I abandoned that government stuff long ago
23:12:07 <ibid> mudge: i have years of experience as a blogger aggregated by planet debian.  planet haskell is the only aggregator i've ever run :)
23:12:09 <mudge> gigamonkey: spaming is stupid, but why do you say they are stupid?
23:12:18 <adu> oerjan: did you test how fast your determinant attempt was?
23:12:46 <Pseudonym> Spammers are, generally, more often stupid than not.
23:12:54 <Pseudonym> They're the bottom feeders of the spam game.
23:14:47 <mudge> gigamonkey: it is nice to have at least some little association with really great stuff,  and I think your work is fantastic and the coders at work project a really great project and exciting
23:14:58 <adu> spam = Simple People with Absent Minds
23:15:15 <mudge> ibid: cool
23:16:55 <mudge> have you guys heard about the CSS display none  comment spam trick?
23:18:13 <adu> mudge: i used to use that on my "free-with-ads" host
23:18:43 <mudge> adu:  this trick: http://www.rustylime.com/show_article.php?id=338
23:18:44 <lambdabot> Title: How We Beat Comment Spam
23:19:10 <mudge> It's a nice system,   something fun to program too
23:19:18 <adu> mudge what made it easier is that they allways added stuff with the same class so i could just do: @adclass {display:none;}
23:19:22 <adu> or something
23:20:13 <mudge> adu:  cool
23:20:44 <mudge> adu:  you from washington dc?
23:20:51 <adu> no, MD
23:20:54 <adu> but close enough
23:21:11 <mudge> ah
23:21:14 <adu> my url lies
23:21:20 <mudge> you got a blog?   I'm blog crazy
23:21:25 <mudge> yea
23:21:27 <adu> no, i got a site tho
23:21:33 <adu> http://tetration.itgo.com
23:21:34 <lambdabot> Title: Home of Tetration
23:21:56 <adu> its been awhile since i updated it, 2005 i think
23:22:23 <adu> I could never keep up with a blog, i don't have that kind of commitment
23:22:33 <bos> woohoo! i can log into a mysql server!
23:23:08 <mudge> adu: cool,  bookmarked in del.cio.us
23:23:17 <mudge> adu:  oh,  what are you committed to?
23:23:49 <mudge> adu: are you a mathematician?
23:23:54 <oerjan> adu: i haven't tested it, no, but it should be polynomial if the rationals don't blow up
23:23:57 <adu> mudge: math, 5 websites for friends, school, job-searching, my own website, and a tetration forum
23:24:27 <chadz> salutations!
23:24:49 <mudge> adu: cool stuff
23:24:55 <mudge> hi chadz
23:25:06 <adu> mudge: I'm a coffee barista, but I do enough math to be considered a mathematician
23:25:32 <adu> wanna see one of the websites I've done?
23:25:50 <mudge> adu: interesting
23:25:58 <adu> http://rjohnson.phpwebhosting.com/tiki
23:26:08 <adu> its a customization of tikiwiki
23:27:18 <adu> I've applied to many schools, but it takes so long to be accepted I just learn about math while I'm waiting for schools to let me in...
23:27:45 <mudge> adu: very interesting
23:27:59 <mudge> adu:  aww,   schools overated
23:28:28 <adu> mudge: if you're interested in tetration specifically, theres a forum I've been into recently
23:28:35 <adu> just started a month ago
23:28:36 <adu> http://math.eretrandre.org/tetrationforum/
23:28:39 <lambdabot> Title: Tetration Forum
23:29:21 <mudge> thanks
23:29:38 <mudge> adu: I'm interested in understanding what tetration is,   looking up in wikipedia
23:29:50 <taruti> How safe are the default serialization instances Data.Binary against decoding malicious data?
23:30:16 <dons> not safe, really.
23:30:20 <bos> depends on what you mean by safe.
23:30:27 <dons> yeah :)
23:30:35 <mudge> ugh,  wikipedia the undecipherable
23:30:41 <taruti> true
23:31:00 <mudge> dons: how come the xmonad project isn't on your website project page?
23:31:07 <dons> it isn't?
23:31:26 <taruti> dons: is there a reason they couldn't be made safe?
23:31:54 <mudge> dons: see: http://www.cse.unsw.edu.au/~dons/code.html
23:31:54 <dons> what safety are you looking for?
23:31:54 <lambdabot> Title: software
23:32:04 <bos> taruti: depends on what you mean by safe.
23:32:18 <dons> mudge: ah, its on ~dons, but not on the code.html page
23:32:23 <dons> which is just a partial, obsolete list
23:32:25 <dons> i should remove that page :)
23:32:55 <taruti> dons: not being able to 1) mess up with memory, 2) create invalid values causing the program to crash (e.g. unsafeCoerce# fun), 3) consume arbitrary amounts of cpu/memory.
23:32:55 <mudge> dons: oh okay,  i see
23:32:59 <bos> taruti: they can't cause stack or heap corruption
23:33:13 <dons> taruti: the only one that's possible is the large memory one
23:33:24 <dons> you can ask for, say, a 4G array, without having to provide one as input
23:33:41 <dons> and you can fix that yourself by newtyping your type, and changing its serialisation to be incremental
23:33:50 <taruti> true
23:34:01 <taruti> hmm. ByteStrings probably have the same issue?
23:34:19 <mudge> adu: once I caculated the number of packets of surgar that are in a pepsi,   the number is 8,    it justifies me putting in at least 4 packets of sugar in my coffee,  since that's only half a pepsi
23:34:57 <dons> taruti: yep, look;
23:34:57 <dons> instance Binary B.ByteString where
23:34:57 <dons>     put bs = do put (B.length bs)
23:34:57 <dons>                 putByteString bs
23:34:57 <dons>     get    = get >>= getByteString
23:34:58 <mudge> adu: just curious what you might think of my logic (or math) on that
23:35:18 <dons> you could put a bogus int for the length, then it will attempt to read that many bytes
23:35:33 <taruti> hmm. so they need newtyping.
23:35:55 <taruti> which does not help if any system type contains them :(
23:35:57 <mudge> damn,  I spent all night on IRC instead of doing more haskell exercises from the programming haskell book
23:36:11 <adu> mudge: sounds logical
23:36:41 <adu> mudge: but that would seem to me to be a reason not to drink pepsi, not a justification for coffee
23:37:12 <mudge> adu: good point
23:37:29 <dons> taruti: hmm, for a safe serialisation lib, just write your own class (or newtype the types you want to make safer). we decide in favour of speed for the default Binary instances, but enourage people to write their own instances for other purposes
23:37:48 <dons> so you could do a SafeBinray that does say, Typeable checking, incremental allocation, and other sanity checks
23:38:09 <taruti> Typeable checking does not really help.
23:38:25 <dons> it helps some things
23:38:34 <Korollary> Wow. http://list.cs.brown.edu/pipermail/plt-scheme/2007-August/020327.html
23:38:36 <lambdabot> Title: [plt-scheme] The Lambda Calculus behind functional programming, http://tinyurl.com/2w67m9
23:38:47 <taruti> against honest mistakes, but probably not against an attacker.
23:39:04 <dons> taruti: anyway, your bounds-allocating bytestring instance is 3 lines of code away :)
23:39:21 <taruti> true.
23:40:00 <Korollary> dons, you still in .au?
23:40:38 <dons> for a few more hours
23:40:55 <dons> hotel wifi :)
23:41:08 <chadz> eek
23:41:13 <kfish> yow!
23:41:17 <chadz> someone's probably in your base right now deleting files.
23:41:26 <dons> heh
23:41:43 <Korollary> they can has cheezburger
23:41:44 <dons> i'd love to see someone attach my openbsd laptop in a hotel. that would be surprising :)
23:41:50 <dons> attac/k/
23:42:06 * dons greps the packet filter logs for clues
23:42:27 <Korollary> who's going to spam reddit while you're on the plane?
23:42:40 <dons> YOU SHOULD DO IT!
23:43:18 <shachaf> dons: You mean you haven't written a linuxer yet?
23:43:29 <Korollary> I shall submit blog entries praising C89.
23:43:42 <dons> Korollary: please do, that would be a welcome change :)
23:43:55 <dons> but COBOL is also good, don't forget that
23:44:15 <Korollary> "What you were never told about integral promotions"
23:44:17 <shapr> dons: We'll have a USDons party on #haskell when you get here!
23:44:33 <dons> heh
23:44:38 * dons <3 #haskell 
23:44:56 <Korollary> dons, ever been to the US before?
23:45:09 <shachaf> shapr: You are also in OR?
23:45:11 <dons> sure, every year or so for the last few years
23:45:18 <dons> conferences.
23:45:39 <chadz> was linuxer a bot or no/
23:45:45 <chadz> that post was amusing :)
23:46:06 <Korollary> maybe linuxer was like Bourbaki
23:46:11 <dons> oh?
23:46:38 <Korollary> a coalition of people all submitting under the pseudonym linuxer
23:46:54 <chadz> for what purpose?
23:47:10 <chadz> i suppose nerd fame is meaningful to some.
23:47:40 <dons> ?seen Bourbaki
23:47:40 <lambdabot> I saw Bourbaki leaving #haskell-blah 15h 13m 50s ago, and .
23:48:03 <adu> later
23:48:13 <dons> i reckon he was just a submission bot, and some rss feeds from google blog search
23:48:22 <dons> with a person occasionally commenting
23:49:27 <mudge> adu: later
23:50:21 <Lycurgus> in spite of the implications of the 'real' N. Bourbaki for the nick I believe the IRC user to be a natural person.
23:51:15 <Lycurgus> (operating a bot, operating a irc client, whatever)
23:52:02 <shapr> shachaf: Nah, I'm in Birmingham, Alabama
23:52:51 <chadz> ah
23:56:20 <glguy> does linux have an aggressive caching mode?
23:56:27 <glguy> I'd like to defer writes  for as long as possible
23:56:40 <glguy> to a usb drive in particular
