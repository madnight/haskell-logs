00:01:03 <Royal_Son> glguy : I'm sorry, I'm totally out of my depth here. I think i need a break and I'll come back when my head is clear
00:01:18 <glguy> Royal_Son: at least let me show you what you have to look forward to :)
00:01:32 <glguy> :t sortBy (\ (a,_,_,_) (b,_,_,_) -> compare a b)
00:01:34 <lambdabot> forall t t1 t2 t3. (Ord t) => [(t, t1, t2, t3)] -> [(t, t1, t2, t3)]
00:01:45 <Royal_Son> ??
00:01:52 <Royal_Son> wow
00:01:56 <Royal_Son> that's different
00:01:57 <glguy> Royal_Son: that's the way to use the standard library to do what you want
00:02:14 <dons> midfield: profiling was probably slowing it down
00:02:16 <glguy> I don't want you to get the idea that Haskell makes this stuff hard :)
00:02:24 <glguy> its just that its new to you right now
00:02:48 <EvilTerran> :t sortBy (comparing (\(x,_,_,_)->x)) -- how about this?
00:02:51 <lambdabot> forall t t1 t2 t3. (Ord t) => [(t, t1, t2, t3)] -> [(t, t1, t2, t3)]
00:02:55 <Royal_Son> how long does it take to get one's head around all this stuff ?
00:02:59 <sorear> ick, large tuples
00:04:38 <dons> Royal_Son: a couple of weeks and a good tutorial
00:05:10 <stepcut> shapr: Coyotos+BitC :)
00:05:37 <shapr> stepcut: I'd rather go for the L4 kernel that Rebekah is doing.
00:06:34 <stepcut> shapr: I'll wait till they are both out, have a Texas steel cage death match, and then pick the winner
00:13:41 <midfield> dons: the with and without profiling times are not too different...
00:14:05 <dons> midfield: very interesting. was the library you're using compiled with -O2 as well?
00:14:38 <midfield> dons: yes.
00:14:46 <Pastorn> how do i forget let-statements in a ghci session?
00:14:52 <glguy> :
00:15:57 <glguy> Pastorn: ^
00:16:02 <midfield> dons: btw strict updates didn't affect anything.
00:18:26 <dons> but the small case was magnitudes faster
00:18:31 <dons> so something funny is giong on
00:18:58 <midfield> dons: yes.  i'm probably doing something awful, but i can't see what
00:30:54 <midfield> dons: of course the frustrating thing is using a TVar (Data.Map k a) is much much faster than the "enlightened" version i tried to write (pushing TVars deep into the tree.)
00:32:10 <psykotic> i imagine an "enlightened" version would have to use some intermediate level of granularity
00:32:19 <psykotic> i.e. some kind of chunking
00:33:28 <midfield> psykotic: not exactly sure what you mean, but the hope was by pushing TVars into the tree, and using destructive updates, a higher degree of concurrancy could be had (updates to subtrees wouldn't lock the whole tree)
00:33:41 <dons> you might need lots of threads and lots of cpus to notice it :)
00:33:50 <psykotic> midfield, right, that's what i mean too. by chunking i mean you might want to store multiple tree nodes per tvar.
00:34:08 <psykotic> the two extremes would be one tvar per tree and one tvar per node
00:34:49 <midfield> dons: premature optimzating biting me in the arse again
00:35:52 <psykotic> btw, for concurrent trees, i'm reminded of the "crab locking" in gray, et al's book on transaction processing
00:36:09 <psykotic> they have this trick where they only ever hold locks for two consecutive nodes in a tree at once
00:36:38 <psykotic> (except for writes that require rejiggling the btree structure i guess)
00:37:02 <psykotic> doesn't seem transferrable to stm though
00:37:41 <glguy> as I learn more about Ruby and Javascript they have began to blur together
00:37:50 <midfield> psykotic: well, i was hoping that STM would perform better with node-level granularity, or higher granularity in general, the more processors you have
00:38:04 * glguy just butchered the tense of that sentence...
00:38:16 <psykotic> midfield, well, it depends on the degree of contention.
00:38:28 <taruti> STM has some O(n^2) parts in the code...
00:38:36 <psykotic> so, basically what dons said. node-level granularity would be good when you have a crapload of concurrent readers/writers.
00:38:52 <taruti> iirc
00:39:01 <psykotic> taruti, what's the n?
00:39:37 <midfield> taruti: n = number of TVars?
00:39:48 <taruti> psykotic: I think it was the number of tvars in the transaction. but I looked at the code in the winter so my memory is a little bit fuzzy.
00:40:00 <psykotic> what the hell
00:40:07 <psykotic> that would make STM useless, if so. i can't imagine it's that.
00:40:39 <psykotic> 1000 tvars in a transaction isn't that big a transaction, necessarily, and would be pretty bad with n^2 behavior
00:41:11 <psykotic> taruti, did you trigger this in your own code or was it just something you read?
00:41:47 <taruti> psykotic: was researching performance anomalities (why lots of tvars resulted in bad performance)
00:42:40 <Royal_Son> yum, that was a nice pizza
00:44:08 * sorear doesn't think stm or locks will ever be able to compete with direct use of atomic primops for stuff like trees
00:44:49 <psykotic> atomic primops in themselves aren't really applicable for many things, because they are usually word-based
00:45:04 <psykotic> they are only a "full" solution for simple linear structures that are linked list like
00:45:56 <psykotic> custom locking schemes can be made extremely fast. like crab locking for b-trees, which is used in basically all highly scalable relational database management systems.
00:45:58 <taruti> hmm, cannot find it in the code in a quick manner.
00:48:12 <taruti> at least both readTVar and writeTVar are O(number_of_tvars_in_transaction)
00:48:40 <psykotic> huh, why?
00:49:05 <taruti> psykotic: look in STM.c
00:49:29 <taruti> they call get_entry_for to find the entry in the trek
00:49:35 <taruti> *trec
00:49:45 <psykotic> is that a linear search?
00:49:55 <taruti> and get_entry_for uses FOR_EACH_ENTRY
00:50:23 <taruti> which is a linear search
00:50:35 <psykotic> weird that they don't use a hash table
00:50:58 <taruti> probably wanted to keep the impl simple
00:51:00 <psykotic> a linear search would probably outperform it up to, say, 20-30 entries
00:51:13 <taruti> and most of the examples have few TVars
00:51:22 <psykotic> well, if they intend it to be a toy, that's fine :)
00:51:40 <midfield> taruti: i think that is exactly it.  i'm going to rerun some tests to confirm...
00:51:44 <taruti> or just optimize it later
00:51:56 <psykotic> yeah, it's easy to change.
00:52:15 <sorear> It would be even better if the system could be optimized better by The Compiler.  too bad we can't hint "These two tvars will never alias"
00:52:15 <taruti> midfield: yes. I think the O(n^2) was me misremembering but the problem was the O(n) of the read and write operations.
00:52:23 <sorear> actually
00:52:32 <sorear> why do we need O(n) reads and writes?
00:52:39 <sorear> if we're willing to not coalesce
00:52:54 <taruti> O(log n) writes would be quite easy to do
00:53:00 <taruti> and it *is* open source.
00:53:06 <sorear> even O(1) looks feasable
00:53:10 <psykotic> taruti, that adds up to O(n^2) i think, so you were right.
00:53:28 <psykotic> taruti, if there's a tvar in your transaction you either read or wrote it. so that adds up to 1 + 2 + ... + n = O(n^2)
00:53:34 <taruti> sorear: true, but hashtables tend to have icky corner cases that trees don't.
00:53:46 <sorear> taruti: I'm not talking about hash tables
00:53:51 <taruti> hmm?
00:54:07 <sorear> taruti: I'm suggesting a linear ... oh nevermind not enough thinking
00:54:35 <psykotic> taruti, the icky corner cases of hash tables are not really issues in practice.
00:54:41 <psykotic> taruti, unless you're doing hard real time.
00:54:50 <sorear> or you're on a network :)
00:57:00 <midfield> ok, the problem was: i was reading in a list of key, values into the TMap in a single transaction.  that had O(n^2)-ish behavior.....doing it in individual transactions is fast.
00:57:31 <dons> ah
00:57:55 <sorear> if you're loading the whole map in one transaction, you should semantically be using one TVar
00:58:29 <taruti> midfield: yes. 1 var /transaction -> O(n), all vars in one transaction -> O(n^2) time.
00:59:00 <taruti> sorear: "TVar (Data.Map k v)" beats real STM trees in most scenarios
00:59:13 <taruti> which is kind of sad
01:00:35 <midfield> now it's within an order of magnitude of TVar (Data.Map k v)
01:00:38 <midfield> heh
01:02:07 <dons> you need more cores! :)
01:02:21 <midfield> i need a real computer.....centrino!
01:03:39 * profmakx wantee more than one core :/
01:04:23 <midfield> taruti: does that O(n^2) stat apply to read-only transactions too?
01:04:55 <taruti> midfield: readTVar is O(number_of_tvars_in_transaction)
01:05:50 <taruti> midfield: if you have any C experience STM.c is very readable code and does not depend on understanding the rest of the rts - so taking a look might make sense.
01:09:31 <midfield> taruti: thanks!
01:10:19 <midfield> unfortunately that makes foldr-ish operations rather expensive.....
01:10:33 <dons> taruti: that's good advice.
01:24:04 <midfield> ah crap.  since inserts are transactional, and they might touch O(log n) nodes, that makes inserts bloody expensive ..... well, i'm back to the drawing board.
01:25:50 <sorear> O(log^2 n) is still pretty good
01:26:04 <sorear> polylog time is considered essentially free
01:31:47 <taruti> sorear: isn't that O(n log n)? Since log n nodes are touched *and* the cost for accessing each node is O(n)?
01:32:17 <sorear> taruti: you're getting your n's mixed up
01:33:05 <sorear> taruti: you need to access O(log(size of tree)) nodes, but accessing each of O(K) tvars takes time O(K)
01:33:27 <sorear> taruti: substituding, that's O(log(size of tree)) * O(log(size of tree))
01:34:03 <taruti> point
01:53:42 <ivant> good day, #haskell!
01:58:20 <midfield> good night!
01:58:58 <dons> hey ivant
02:02:43 <ivant> is there ghc for sparc solaris?
02:03:07 <ivant> oh, yes!
02:08:09 <dcoutts> @seen shapr
02:08:09 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 2h 2m 32s ago.
02:09:31 <dcoutts> dylan: re glade thingie, are you using glade 3 rather than glade 2 ? if so you need to use widgetShowAll before mainGUI as glade 3 now makes widgets not visible by default.
02:09:31 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
02:09:43 <BobFunk> does Haskell have a function like rubys unique, to get all unique elements from a list?
02:09:54 <dcoutts> BobFunk: nub
02:10:03 <dcoutts> > nub "foobar"
02:10:05 <lambdabot>  "fobar"
02:10:23 <BobFunk> great - thanks :)
02:11:11 <roconnor> > nubBy(((>1) .) . gcd) [2..]
02:11:13 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
02:11:40 <shapr> dcoutts: You called?
02:11:46 <wli> scanr saves the day.
02:12:01 <roconnor> wli: shouldn't you use scanl?
02:12:07 <wli> No.
02:12:10 <roconnor> oh okay
02:12:19 <dcoutts> shapr: you were after me I think
02:12:21 <roconnor> weird.
02:12:34 <wli> The running sums need to be backward as scanr makes them.
02:13:01 <wli> And it's a short list.
02:13:14 <shapr> dcoutts: Oh yeah, I was trying to figure out how to get cabal-install to work with darcs repos, but I figured out that I need to talk to Lemmih, and that's somewhat easier and harder than I thought.
02:13:48 <dcoutts> shapr: you mean to download and install from a repo rather than from a tarball on hackage?
02:13:52 <roconnor> wli: okay, but scanr always makes me suspicous.
02:13:53 <wli> (In theory arbitrarily long but the algorithm is exponential in the length of that list anyway; the scanr step scarcely makes any sort of a difference.)
02:14:05 <dcoutts> shapr: or from a local build tree that you got with darcs?
02:14:16 <shapr> dcoutts: Either of those would be fine with me.
02:14:50 <dcoutts> shapr: cabal-install does neither :-) it doesn't do local unpacked cabal packages, only hackage
02:14:53 <shapr> dcoutts: HAppS is a bunch of different repos now, and it's a pain in the butt to make code changes to one repo that everything else depends on, and then reinstall them all by hand to test out stuff.
02:14:56 <wli> roconnor: The running sums involved need to be what scanr (+) 0 xs constructs. The problem is already near-impossible at list lengths as small as 100.
02:15:20 <dcoutts> shapr: have you discovered that you can register inplace?
02:15:23 <shapr> But cabal-install does dependencies, right?
02:15:23 <roconnor> wli: project euclid?
02:15:36 <wli> roconnor: Subsidiary to one of its problems.
02:15:57 <dcoutts> shapr: yes, cabal-install does inter-package deps for tarballs in a package db, like that of hackage
02:16:10 <wli> roconnor: Some brute-force to tide things over until I can figure out the pertinent number theory.
02:16:14 <shapr> And cabal-install just wraps cabal-setup for the rest, yeah?
02:16:45 <shapr> So I could just have a shell script that unregisters all the HAppS packages and reinstalls everything.
02:16:51 <dcoutts> shapr: no, it has no relation to cabal-setup it does not do the "do stuff in this build tree" that cabal-setup does
02:17:13 <dcoutts> shapr: I think the easiest way to work with multiple cabal packages is to register them inplace in their build trees
02:17:15 <shapr> How does cabal-install do stuff then?
02:17:41 <dcoutts> shapr: but it's not what you want anyway since it needs tarballs
02:17:58 <wli> roconnor: Well, actually it's refined enough to not really be brute-force anymore but it's still exponential.
02:18:01 <shapr> dcoutts: But that won't rebuild and reinstall, in the right order, all the libraries that depend on the one I just changed, right?
02:18:09 <dcoutts> shapr: runghc Setup register --inplace --user
02:18:30 <dcoutts> shapr: from then on, the current built version is the version that is registered
02:18:37 <shapr> It still means I have to do that in the right order by hand, or change a script when deps change.
02:19:18 <dcoutts> shapr: no, once it's registered inplace it's registered inplace
02:19:45 <oerjan> > scanr (+) 0 [1..100000]
02:19:47 <lambdabot>  [5000050000,5000049999,5000049997,5000049994,5000049990,5000049985,500004997...
02:19:54 <dcoutts> shapr: then doing ./setup build in that build tree and relinking some other code that deps on that package, uses the latest code
02:20:12 <wli> > zip [1..10] $ scanr (+) 0 [1..10]
02:20:13 <lambdabot>  [(1,55),(2,54),(3,52),(4,49),(5,45),(6,40),(7,34),(8,27),(9,19),(10,10)]
02:20:34 <shapr> But most of these repos import each other, though not cyclically, and code changes in one mean I have to rebuild anything that depends on those. And I want to write my own apps that use HAppS, and that leads to more changes...
02:21:09 <wli> > let invsq :: Integer -> Rational ; invsq x = let x' = fromIntegral x in 1/(x'*x') in zip [1..10] $ scanr (+) 0 $ map invsq [1..10]
02:21:10 <lambdabot>  [(1,1968329%1270080),(2,698249%1270080),(3,380729%1270080),(4,239609%1270080...
02:21:22 <dcoutts> shapr: right, yes you would need to recompilie those and ghc does not track module deps across packages, just whole package deps
02:21:29 <wli> Something approximately like that.
02:21:50 <wli> In actuality [(1/4, [2], zipWith (uncurry (,,)) (map (id &&& invsq) [3..n]) (scanr (+) 0 $ map invsq [3..n]))]
02:21:57 <shapr> Right, that's why I want to rip out the package dep code from cabal-install, and be able to change one darcs repo and have everything built in the right order.
02:22:20 <dcoutts> shapr: I see
02:23:03 <dcoutts> shapr: yeah that sounds like a reasonable medium term hack
02:23:17 <shapr> dcoutts: What's a better long term solution?
02:23:23 <dcoutts> shapr: ultimately I'd like cabal to cope with that properly
02:23:52 <shapr> How would it do that properly? Add support for local darcs repos as a source to cabal-install?
02:24:07 <wli> This probably represents the last possible refinement of brute force possible before the only thing plausible to do is working out the pertinent number theory.
02:24:15 <dcoutts> shapr: eg when we have a bunch of related packages in a single build tree, like gtk2hs, or the base libs, then cabal should track inter-package module deps and rebuild as required.
02:24:23 <shapr> wli: I didn't think you were ever going to say that :-)
02:24:38 <wli> shapr: What/why?
02:25:06 <shapr> wli: Your brute force hacks have repeatedly amazed me in the past.
02:25:19 <dcoutts> shapr: and also, I'd like to integrate cabal/cabal-install/cabal-setup into one program
02:25:24 <wli> shapr: Well, they only suffice in some cases.
02:25:27 <shapr> Yeah, I'd *really* like that.
02:26:03 <wli> shapr: Nuggets.hs for instance was a case where brute force was insufficient and so things required some number theory.
02:26:13 <dcoutts> shapr: the main difficulty with that is that different cabal progs have different deps, and we have to be very careful with deps or bootstrapping becomes very hard
02:27:00 <eivuokko> dcoutts, I don't understand why cabal-install needs to be merged with cabal.
02:27:27 <dcoutts> eivuokko: I only want to merge the UI, not merge at an underlying level
02:27:35 <wli> shapr: http://hpaste.org/2316#a2 <-- Nuggets.hs
02:27:57 <eivuokko> dcoutts, Aha.
02:29:05 <dcoutts> eivuokko: I had been thinking of some modular design where we can add new cabal commands with external progs or something, since we cannot have all of cabal-install's deps be deps of the Cabal lib
02:29:38 <dcoutts> eivuokko: another alternative might be to have a cabal command line UI program separate from the Cabal lib
02:29:44 <hpaste>  wli pasted "final brute force PE#152" at http://hpaste.org/2397
02:30:17 <eivuokko> dcoutts, Hehe.  My thoughts have been that distribution and distribution.simple should be diff libs;  But now I am thining Distribution.PacageDescription, Distribution.Setup and Distribution.Simple should all be different libs ;)
02:31:09 <wli> shapr: There's the brute-force bit I'm on about for you.
02:32:14 <eivuokko> dcoutts, Is it important that Cabal is one package (to ease bootstrapping)?
02:32:31 <dcoutts> eivuokko: not sure exactly
02:32:40 <eivuokko> dcoutts, Because in addition to those splits, preprocessors/tools could be their own lib.
02:32:43 <dcoutts> eivuokko: it depends on how we think it will bootstrap
02:32:51 <eivuokko> dcoutts, And bound by Setup.(l)hs
02:33:13 <dons> weird, http://tellmeastory.com/haskell/pages/default.cfm
02:33:14 <lambdabot> Title: The Hatching of Haskell
02:33:19 <dcoutts> eivuokko: we eventually want to move towards a command line program UI anyway, rather than Setup.lhs
02:33:35 <dcoutts> eivuokko: ie cabal-setup, though it should just be called cabal imho
02:33:38 <thepointer> what's the proper 'module Main(main) where' code that i should put at the top of a standalone script?
02:33:44 <eivuokko> dcoutts, I think that's long way ahead.  Still no resource files or DLLs etc... ;)
02:34:09 <dcoutts> eivuokko: hmm? what has cabal-setup got to do with dlls?
02:34:33 <dcoutts> Eidolos: and of course cabal-setup compiles Setup.hs if necessary
02:34:36 <dcoutts> oops
02:34:38 <dcoutts> eivuokko: ^^
02:34:56 <eivuokko> dcoutts, I am concerned about how Windows-related things will be usable.
02:35:27 <eivuokko> dcoutts, Cabal is now ok building block for maybe medium-sized haskell projects + unixy platforms;
02:35:31 <dcoutts> eivuokko: oh you mean if we're using a command line ui prog, well by splitting into lib and prog, we should be able to make a gui, like say himerge
02:35:38 <dcoutts> @where himerge
02:35:38 <lambdabot> http://www.haskell.org/~luisfaraujo/himerge/
02:35:46 <eivuokko> dcoutts, But it's really really insufficient for any sensible Windows project that doesn't target other haskell devels.
02:36:03 <eivuokko> No, I don't care about gui;  I care about tools and things cabal can do.
02:36:33 <dcoutts> eivuokko: ok, I'm not sure how talking about splitting and lib vs command line prog uis affect that
02:36:47 <xerox> dons http://tellmeastory.com/haskell/activity/
02:36:48 <lambdabot> Title: Haskell's Activity Page
02:37:32 <eivuokko> dcoutts, Splitting...doesn't.  Making cabal-install default...will make it much harder to adopt Cabal for anything but haskell-for-haskell devel in Windows.
02:37:40 <eivuokko> I think so, anyway.
02:37:48 <dcoutts> eivuokko: I'm not sure I see why
02:38:04 <eivuokko> dcoutts, See how broken visual haskell is already because of choices cabal made?
02:38:28 <dcoutts> eivuokko: is it? I thought it's problem was with Setup.lhs hooks
02:38:35 <eivuokko> Hooks?
02:38:41 <wli> I've not been able to get Visual Studio going on my laptop's Windows installation.
02:38:48 <dcoutts> eivuokko: VS does not use Setup.hs at all
02:39:11 <dcoutts> it uses just (it's own implementation of) the simple build system
02:39:48 <dcoutts> eivuokko: having a proper library api should make things easier for VS and other tools
02:39:56 <eivuokko> dcoutts, The problems are irregular .cabal files;  The lack of sensibly integrating "ways" and buildtypes (debug/profiling/release)
02:40:24 <eivuokko> dcoutts, And I think VS actually does compile and run Setup.hs;  I can't see how else it builds itself.
02:40:45 <eivuokko> (And I am fairly sure it does..original paper says it was used to develop itself)
02:41:10 <dcoutts> eivuokko: as I understand it, it just reads the .cabal file and implements much of it's own build system
02:41:11 <wli> shapr: You can see the brute-force versions earlier in the Nuggets.hs link.
02:42:05 <eivuokko> dcoutts, Anywya, that's not a big problem...it's small technical obstacle compared to high level design issues.
02:43:02 <dcoutts> eivuokko: for alternative UIs, I'd think splitting into a build lib and a command line UI prog would be good since it'd allow other UIs much more easily
02:43:18 <eivuokko> Cabal has a lot of implementation details, and unclear design choices, that make it hard to add typical things one needs for Windows devel.
02:43:48 <dcoutts> eivuokko: can you make a list of them and put them in a bug report so we don't forget
02:44:03 <dcoutts> eivuokko: we do need reminding of these windows things
02:44:13 <wli> ivant: Have you found methods beyond brute-force for PE#152 yet?
02:44:57 <ivant> wli, not yet. I hadn't a lot of time to think about it :-(
02:45:22 <ivant> brute-force won't work anyway
02:45:36 <eivuokko> dcoutts, It sounds silly...but I can't describe the issues clearly enough.  I am not actually interested, but I just see it can't be done the current way...
02:45:42 <ivant> wli, do you know the approaches to solving the diophantine equations?
02:46:00 <ivant> I imagine the way of representing PE#152 as several such
02:46:05 <wli> ivant: I mostly only know Pell's equation.
02:46:14 <dcoutts> eivuokko: that's a shame, if it can't be described it can hardly be solved.
02:46:16 <eivuokko> dcoutts, And bug reports like: "Cabal needs to support DLLs as final executable." are probably goign to get ignored, and consequences forgotten.
02:47:10 <dcoutts> eivuokko: it's not just you and me who hacks on cabal, anyone can decide to hack on dll support if they know what they need to do
02:47:34 <eivuokko> dcoutts, I tried, I've posted lots of Windows-style problems I had to cabal-devel@, people didn't answer/understand my mails;  I don't feel like writing bug reports.
02:47:35 <wli> ivant: Something like a cylindrical decomposition?
02:47:42 <ivant> wli, for each n we can build a system {1/2==1/x1^2+1/x2^2+...+1/xn^2,xi<=80}
02:47:48 <ivant> wli, no :-)
02:48:01 <eivuokko> dcoutts, Yes.  I know.
02:48:02 <ivant> wli, although I had an idea to try that direction :-)
02:48:16 <ivant> the first equation is a diophantine equation
02:48:23 <dcoutts> eivuokko: aye, true. Well I might go through and turn a few of your emails into bug reports so they don't get forgotten.
02:48:28 <ivant> we can rewrite it in a polynomial form
02:48:46 <dozer> @src sequence
02:48:47 <lambdabot> sequence ms = foldr k (return []) ms
02:48:47 <lambdabot>     where
02:48:47 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
02:48:51 <wli> ivant: Once it's rewritten as a polynomial it gets kind of messy.
02:49:06 <ivant> wli, I know, still, it's worth trying
02:49:23 <dozer> is sequence different from: foldl (>>=)
02:49:46 <ivant> wli, I think a good way to solve this problem is to solve some other PE problem first, which hints the ways of solving #152
02:50:24 <opqdonut> ?src sequence
02:50:24 <lambdabot> sequence ms = foldr k (return []) ms
02:50:24 <lambdabot>     where
02:50:24 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
02:51:21 <enolan> dozer: sequence returns a list of results, folding with >>= just performs a sequence of actions.
02:51:26 <enolan> @src sequence_
02:51:27 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
02:52:08 <wli> ivant: I suspect a connection with continued fractions.
02:53:37 <ivant> wli, I don't remember a lot about continued fractions either. It was like 7 years ago when I had my basic algebra course
02:54:22 <wli> ivant: Well, it's thoroughly disguised. My thought there revolves around the symmetric polynomials.
02:54:29 <dionoea> Hello. what structuredo you suggest using if I need an infinite list with fast access to a specific item (using something like !!n on normal lists ... but that seems to be slow on big lists)
02:54:34 <dionoea> ?
02:54:55 <ivant> dionoea, what can you sacrifice for having a fast access?
02:55:14 <ivant> dionoea, and what do you mean by fast? O(1) or O(log n) or what?
02:55:39 <opqdonut> dionoea: try sequences
02:55:46 <ivant> hmm, infinite
02:55:47 <dionoea> i guess that I won't be able to get much btter than O(log n) for an infinte list?
02:56:14 <dionoea> like some kind of infinite binary tree (that sounds weird)
02:56:20 <ivant> dionoea, sounds like you need something similar to a b-tree
02:56:21 <taruti> dionoea: well you could have a list with O(1) access to the first N elements.
02:56:24 * dionoea looks up sequences
02:56:34 <ivant> see Data.Sequence
02:56:35 <opqdonut> ?hoogle Sequence
02:56:35 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
02:56:35 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
02:56:35 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
02:56:43 <dionoea> thanks.
02:56:44 <taruti> dionoea: trees won't be O(1)
02:56:47 <opqdonut> yeah Data.Sequence is what you want
02:56:58 <dionoea> lists are 0(n) for !!n right ?
02:57:06 <taruti> yes
02:57:15 <dionoea> so anything better than that i'll take :)
02:57:18 <taruti> how large is n going to get?
02:57:34 <ivant> ∞, I expect
02:57:36 <ivant> :-)
02:57:45 <dionoea> I honestly don't know (I expect it to be a few million but that's a wild guess)
02:57:53 <ivant> otherwise he would not need an infinite structure
02:58:07 * taruti notes that is going to require lots of memory
02:58:28 <taruti> hmm. few million is not that bad if the elements are small
02:58:34 <ivant> taruti, only when you actually do the computation for a large n
02:59:03 <ivant> taruti, it's lazy, so it should be built on-demand
02:59:16 <wli> ivant: In principle enumerating rational points on n-spheres of radius 1/2 might turn up more points.
02:59:30 <wli> ivant: Or at least reduce the search space.
02:59:49 <enolan> > let inf = inf |> 1 in S.take 2 inf
02:59:50 <lambdabot>   Not in scope: `|>'
03:00:08 <taruti> ivant: true, but if it has an access pattern with random access to very large indexes the whole thing will be in memory.
03:00:52 <ivant> wli, well, you'd get a lot of such points (infinite, if I'm not mistaken)
03:01:51 <wli> ivant: True enough, but there are numerator constraints (1) and denominator bounds (<= 80) and coordinate inequalities (x_i < x_j whenever i < j) to work with.
03:02:48 <dionoea> hum ... Data.Sequence.fromList [0..] soundsl ike a bad idea :(
03:03:01 <ivant> wli, yep, but you still need to enumerate all the same points
03:03:42 <wli> ivant: Well, I don't know how to do it offhand so I'm not sure if something that cuts down the search space arises from it.
03:04:17 <ivant> wli, sounds suspiciously similar to the problem with following the ellipse curve in your prime sieve :-)
03:04:32 <ivant> but here you are in an n-dimensional space
03:04:32 <wli> ivant: It does, yes.
03:05:42 <oerjan> dionoea: you might want a trie
03:06:10 <oerjan> they are such infinite tree-structures as you mentioned
03:06:14 <wli> ivant: I'm at a similar loss to solve the polynomial equation arising from clearing denominators.
03:06:18 <oerjan> (well, they can be infinite)
03:07:12 <wli> ivant: Another idea I had was to try to arrange cancellation in the 2-adic representations.
03:08:47 <wli> ivant: It's almost a homogeneous linear equation there.
03:09:17 <ivant> wli, oh!
03:09:27 <wli> ivant: What?
03:09:40 <ivant> wli, (I didn't understood that part about 2-adic rep and homogeneous lin eq yet)
03:10:21 <ivant> wli, we can represent this problem as a system of polynomial equations
03:10:22 <wli> ivant: Solve mod 2, mod 2^2, mod 2^3, mod 2^4, etc.
03:11:00 <wli> ivant: So 3^{-2} mod 2^k, etc. except the even numbers don't have inverses.
03:11:24 <wli> ivant: Maybe a prime larger than any of the numbers is needed.
03:12:26 <ivant> wli, {1/2==a2/2^2+a3/3^2+...+a80/80^2, (ai*2-1)^2=1}
03:12:32 <ivant> wli, I think I got it!
03:13:08 <ivant> the problem above is a Semidefinite Programming problem and it is solvable in polynomial time!
03:13:29 <wli> ivant: Aha, that will do.
03:13:53 <ivant> wli, unfortunately I still haven't read enough about the methods to solve it :-)
03:14:28 <ivant> but that lies close to the topic of my research, so I'm going to do this when I get my hands on the paper and pen :-)
03:14:30 <wli> ivant: Well, it's not quite a semidefinite programming problem; there's no objective as of yet.
03:14:44 <ivant> wli, ok, it is dual to the SDP problem
03:15:10 <wli> ivant: (\sum a_k/k^2-1/2)^2 might make a good objective.
03:15:30 <ivant> objective must be linear
03:15:33 <ivant> that's the point
03:15:52 <wli> ivant: Quadratically constrained quadratic programming.
03:16:21 <ivant> ah, yes, but I don't remember whether it's in P
03:16:52 <wli> ivant: http://en.wikipedia.org/wiki/Quadratically_constrained_quadratic_program
03:16:53 <lambdabot> http://tinyurl.com/2ud4qb
03:17:25 <wli> ivant: It's all positive definite so interior point methods suffice.
03:17:25 <ivant> wli, haha, NP-hard :-)
03:17:55 <wli> ivant: Only for the non-convex case.
03:18:10 <ivant> wli, oh, I see then. Yes, that makes sense
03:18:36 <dionoea> ah, i found a better algorithm which doesn't need the !! lookup
03:19:07 <ivant> wli, so here you go, you only need to implement the solution search (or even hand-write the solution)
03:19:48 <ivant> wli, however O(n^78) might be quite bad
03:20:01 <wli> ivant: Second-order Karush-Kuhn-Tucker conditions should suffice.
03:22:11 <wli> ivant: I see one large problem with this.
03:22:26 <wli> ivant: Such methods don't find all possible solutions well.
03:22:43 <ivant> wli, oh, true
03:23:36 <wli> ivant: I think there are ways to solve linear Diophantine equations in numerous variables.
03:24:49 <wli> ivant: So basically treat the numerators as 0/1 variables and clear denominators, then Bezout.
03:25:31 <wli> ivant: Then it reduces to linear algebra.
03:25:41 <ivant> Bezout?
03:26:00 <wli> http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity
03:26:01 <lambdabot> Title: Bézout's identity - Wikipedia, the free encyclopedia
03:26:23 <ivant> oh, I was looking at Bézout Theorem
03:28:13 <ivant> wli, what is PID?
03:28:20 <wli> Principal Ideal Domain
03:28:22 <ivant> does {0,1} form a PID?
03:28:23 <sieni> principal ideal domain?
03:28:32 <wli> http://en.wikipedia.org/wiki/Principal_ideal_domain
03:28:32 <lambdabot> Title: Principal ideal domain - Wikipedia, the free encyclopedia
03:28:34 <sieni> yes
03:29:19 <oerjan> {0,1} is a field, no non-trivial ideals
03:29:32 <wli> I still don't see how to carry it off.
03:30:34 <wli> It makes more sense in 2-adics I think.
03:30:54 <oerjan> are you actually doing arithmetic (mod 2)?
03:31:12 <wli> The 2-adics are not Z/2Z
03:31:28 <oerjan> wli: i was referring to the {0,1} mention
03:31:50 * mux tosses some more lambdas in the channel
03:31:57 <wli> No, it can't be done mod 2.
03:32:05 <wli> There are too many zero divisors.
03:33:11 <oerjan> forget i said anything then :)
03:36:46 <EvilTerran> > map ($"") $ foldl (\(w:s) c -> (w.(c:)) : (if c=='.'then w:s else s)) [id] "foo.bar.baz"
03:36:47 <lambdabot>  ["foo.bar.baz","foo.bar","foo"]
03:38:37 <EvilTerran> (I'm playing programming golf in another channel, to, given a string, produce each prefix up-to-but-excluding a '.')
03:38:51 <EvilTerran> (including the whole string)
03:39:02 <EvilTerran> @pl (\(w:s) c -> (w.(c:)) : (if c=='.'then w:s else s))
03:39:03 <lambdabot> ap (ap ((.) . ap . ((:) .) . (. (:)) . (.)) (join . ((flip . flip (if' . ('.' ==))) .) . (:)) . head) tail
03:39:30 <Vq^> what does @pl think if' is?
03:39:47 <EvilTerran> @src if'
03:39:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:39:49 <opqdonut> if is the corresponding function
03:40:02 <opqdonut> > if True 1 0
03:40:02 <lambdabot>  Parse error
03:40:04 <opqdonut> > if' True 1 0
03:40:05 <opqdonut> bah
03:40:06 <lambdabot>   Not in scope: `if''
03:40:21 <opqdonut> well yeah that should evaluate to 1
03:40:26 <EvilTerran> if' True x _ = x; if' False _ y = y
03:40:40 <opqdonut> yup
03:41:13 <oerjan> > map reverse . iterate (tail . dropWhile (/= '.')) . reverse $ "foo.bar.baz"
03:41:14 <lambdabot>  Exception: Prelude.tail: empty list
03:41:27 <oerjan> > map reverse . iterate (drop 1 . dropWhile (/= '.')) . reverse $ "foo.bar.baz"
03:41:28 <lambdabot>  ["foo.bar.baz","foo.bar","foo","","","","","","","","","","","","","","","",...
03:42:01 <EvilTerran> imo, it should be called "bool", like "maybe" and suchlike
03:42:40 <ivant> wli, I've got the idea, but I'm not sure whether it is again an exponential search
03:43:08 <ivant> wli, oh, no, disregard that
03:45:59 <oerjan> :t &&&
03:46:01 <lambdabot> parse error on input `&&&'
03:46:05 <opqdonut> :t (&&&)
03:46:06 <oerjan> :t (&&&)
03:46:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:46:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:46:10 <opqdonut> :)
03:48:22 <oerjan> > [s | (s,'.':_) <- zip (inits l) (tails l) . (++".") $ "foo.bar.baz"]
03:48:23 <lambdabot>   Not in scope: `l'
03:49:06 <oerjan> > [s | (s,'.':_) <- liftM2 zip inits tails . (++".") $ "foo.bar.baz"]
03:49:07 <lambdabot>  ["foo","foo.bar","foo.bar.baz"]
03:49:15 <oerjan> > reverse [s | (s,'.':_) <- liftM2 zip inits tails . (++".") $ "foo.bar.baz"]
03:49:17 <lambdabot>  ["foo.bar.baz","foo.bar","foo"]
03:50:11 <EvilTerran> nice
03:51:56 <oerjan> > [reverse s | '.':s <- tails . reverse . (++".") $ "foo.bar.baz"]
03:51:58 <lambdabot>  ["foo.bar.baz","foo.bar","foo"]
03:52:25 <oerjan> > [reverse s | '.':s <- tails . ('.':) . reverse $ "foo.bar.baz"]
03:52:26 <lambdabot>  ["foo.bar.baz","foo.bar","foo"]
03:52:49 <hpaste>  TSC pasted "existential problem" at http://hpaste.org/2398
03:53:04 <TSC> Could some expert on existentials help me out with that paste?
03:53:12 <TSC> I want h to work, but without having to use fromIntegral
03:53:48 <TSC> Basically, I want to take a concrete type (Integer) and "cast" it to an existential type (some type that is a member of class Integral)
03:55:09 <oerjan> i assume you are not interested in just numerals (in which case h = 1 would do)
03:55:52 <TSC> Right, I really want to do it with my own type class
03:56:05 <oerjan> i really don't think haskell supports this, or wants to
03:58:04 <wli> ivant: Modulo p it seems to reduce to \sum a_k x_k^2 = b
03:58:35 <wli> ivant: n-variate Hasse-Minkowski?
03:59:10 <ivant> wli, could you explain? I'm not sure what are you doing? lhs mod p = rhs mod p for different p?
03:59:26 <wli> ivant: http://en.wikipedia.org/wiki/Hasse%E2%80%93Minkowski_theorem
03:59:27 <lambdabot> Title: Hasse–Minkowski theorem - Wikipedia, the free encyclopedia
03:59:41 <wli> ivant: http://en.wikipedia.org/wiki/Isotropic_quadratic_form
04:00:01 <oerjan> TSC: or rather, people might want haskell to support subtyping, but it makes type inference undecidable
04:00:41 <TSC> That's a shame
04:07:09 <wli> ivant: Well, I see the method of solution for the 3-variable case.
04:08:37 <wli> ivant: Not mod p but in p-adics.
04:09:05 <TSC> Looks like I have to work around it with a wrapper data type
04:11:25 <wli> ivant: I don't see how to generalize it to n dimensions, though. I only see an example of it for 3 variables.
04:12:34 <ivant> wli, I feel you're going at much better pace then I'm (but I'm switching between a glassfish server configuration, lunch-cooking and this problem) :-)
04:13:13 <wli> ivant: Another possibility might be to do it mod p for numerous p, and one *can* treat it as a vector space then -- basically via the Chinese Remainder Theorem.
04:13:44 <ivant> wli, that's what I was thinking of when I asked about mod p
04:14:41 <ivant> is there a search on hpaste?
04:15:18 <wli> I'm not sure how to get 0/1 solutions in terms of vector spaces properly. My wild guess is that it may arise from the reduced row echelon form of some matrix.
04:16:14 <ivant> is there a primes sieve one-liner?
04:16:24 <wli> numerous of them
04:16:34 <wli> nubBy(((>1) .) . gcd) [2..]
04:16:40 <ivant> 10x
04:16:50 <wli> ivant: There are better sieves ... hang on.
04:16:50 <ivant> I was lazy to write it myself :-)
04:16:55 <opqdonut> > nubBy (\x y -> y `mod` x == 0) [2..]
04:16:57 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:17:03 <ivant> I only need primes below sqrt(80) :-)
04:17:07 <opqdonut> tho i guess that gcd one is nicer
04:18:14 <ivant> > sqrt 80
04:18:15 <lambdabot>  8.94427190999916
04:18:24 <ivant> oh, I don't need a sieve :-)
04:18:25 <hpaste>  wli pasted "Eratosthenes for ivant" at http://hpaste.org/2399
04:18:29 <opqdonut> heh yeah
04:18:29 <ivant> [2,3,5,7] :-)
04:18:54 <wli> ivant: Okay, that may be overkill. ;)
04:19:21 <ivant> wli, I said one-liner :-)
04:19:41 <wli> ivant: Actually you probably want primes > 80 but never mind that.
04:19:44 <ivant> this one does something too complex :-)
04:20:03 <ricky_clarkson> I watched a video by Dijkstra where he showed that for a given algorithm to compute the hcf, the number of *iterations* to get there was the gcd.  At that point I went ooh.
04:20:03 <ivant> hmm, you may be right, but let's see
04:20:27 <ivant> @all-dicts hcf
04:20:28 <lambdabot> *** "hcf" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
04:20:28 <lambdabot> HCF
04:20:28 <lambdabot>      Hybrid Coordination Function (MAC, 802.11a)
04:20:28 <lambdabot>  
04:20:28 <lambdabot> *** "HCF" jargon "Jargon File (4.3.1, 29 Jun 2001)"
04:20:30 <lambdabot> [20 @more lines]
04:20:41 <ivant> @more
04:20:41 <lambdabot> HCF /H-C-F/ n. Mnemonic for `Halt and Catch Fire', any of several
04:20:41 <lambdabot>    undocumented and semi-mythical machine instructions with destructive
04:20:41 <lambdabot>    side-effects, supposedly included for test purposes on several
04:20:41 <lambdabot>    well-known architectures going as far back as the IBM 360. The MC6800
04:20:41 <lambdabot>    microprocessor was the first for which an HCF opcode became widely
04:20:43 <lambdabot> [15 @more lines]
04:21:01 <ricky_clarkson> Highest Common Factor - hmm, I think I've used the wrong term.
04:21:10 <wli> ricky_clarkson: Try lcm
04:21:17 <ricky_clarkson> Yes.
04:21:18 <wli> > 24 `lcm` 36
04:21:19 <lambdabot>  72
04:21:37 <TSC> ivant: You can search hpaste with google; e.g. http://www.google.com/search?hl=en&q=site%3Ahpaste.org+problem&btnG=Search
04:22:21 <ivant> TSC, thanks, I had such an idea, but wasn't sure google does index it
04:22:50 <wli> > 111111111111 `lcm` 11111111
04:22:52 <lambdabot>  1111222222221111
04:24:18 <ricky_clarkson> > -2 `lcm` 3
04:24:19 <lambdabot>  -6
04:24:33 <ivant> 0 `lcm` 0
04:24:38 <opqdonut> heh
04:25:05 <ivant> hmm, where is my answer?
04:25:10 <wli> > (((10^12-1) `div` 9) `gcd` ((10^8-1) `div` 9)) == ((10^(12 `gcd` 8)-1) `div` 9)
04:25:12 <lambdabot>  True
04:25:15 <EvilTerran> > 0 `lcm` 0
04:25:17 <lambdabot>  0
04:25:17 <opqdonut> > 0 `lcm` 0
04:25:18 <lambdabot>  0
04:25:18 <opqdonut> yeah
04:25:24 <ivant> ah, I'm dumb
04:25:26 <EvilTerran> --@quote stereo
04:25:32 <opqdonut> :)
04:25:46 <ricky_clarkson> @quote math
04:25:47 <lambdabot> math says: 2^20 ~= 10^6
04:25:48 <wli> > (((17^12-1) `div` 16) `gcd` ((17^8-1) `div` 16)) == ((17^(12 `gcd` 8)-1) `div` 16)
04:25:50 <lambdabot>  True
04:31:53 <wli> BTW there's an inefficiency in there; each multiple of a known prime should basically carry around its own wheel to spin.
04:37:12 <sieni> @quote sieni
04:37:12 <lambdabot> sieni says: the advantage of haskell is that it doesn't suck
04:37:17 <sieni> <3
04:37:25 <opqdonut> @quote wli
04:37:25 <lambdabot> wli says: I'd settle for getting laid a lot.
04:37:33 <opqdonut> @quote wli
04:37:34 <lambdabot> wli says: I'd settle for getting laid a lot.
04:37:37 <opqdonut> :)
04:38:10 <oerjan> ricky_clarkson: -2 `lcm` 3 parses as -(2 `lcm` 3), i think
04:38:19 <oerjan> > (-2) `lcm` 3
04:38:20 <lambdabot>  6
04:39:45 <olsner> > -2 `lcm` 3
04:39:47 <lambdabot>  -6
04:40:02 <Tchakkazulu> @quote lambdabot
04:40:02 <lambdabot> lambdabot says: tERmIN473d
04:40:11 <EvilTerran> @quote ghc
04:40:11 <lambdabot> ghc says: Exotic pattern inside meta brackets
04:40:21 <oerjan> > (0$0 `lcm`)
04:40:21 <lambdabot>      The operator `lcm' [infixl 9] of a section
04:40:22 <lambdabot>         must have lower prece...
04:40:28 <augustss> @quote
04:40:28 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
04:40:58 <oerjan> > (0$0 -)
04:40:59 <lambdabot>      The operator `-' [infixl 6] of a section
04:40:59 <lambdabot>         must have lower precede...
04:49:43 <phobes> > ($10.00)
04:49:44 <lambdabot>  Add a type signature
04:51:43 <oerjan> :t ($)
04:51:46 <lambdabot> forall a b. (a -> b) -> a -> b
04:51:50 <EvilTerran> > ($10.00) :: USD
04:51:51 <lambdabot>   Not in scope: type constructor or class `USD'
04:51:57 <EvilTerran> :D
04:53:53 <Japsu> :t ($10.00)
04:53:56 <lambdabot> forall a b. (Fractional a) => (a -> b) -> b
04:53:59 <oerjan> i imagine it could actually be made to work with some class instances
04:54:15 <Japsu> There, now just "type USD = (a -> b) -> b"
04:54:32 <oerjan> you also need a Num instance for a -> b
04:54:40 <opqdonut> heh
04:54:44 <oerjan> er...
04:55:02 <oerjan> for a
04:55:22 <b_jonas> :t ($10)
04:55:24 <lambdabot> forall a b. (Num a) => (a -> b) -> b
04:55:44 <oerjan> er, Fractional
04:59:36 <nornagon> > let each = (*4) in ($10) each
04:59:38 <lambdabot>  40
05:01:04 <olsner> nice ;-)
05:01:21 <kny> hehe
05:01:28 <Japsu> cool
05:02:20 <augustss> haha
05:02:40 <augustss> another nasty Haskell syntax hack :)
05:02:53 <nornagon> :)
05:04:28 <augustss> Haskell needs prefix and postfix operators as well
05:06:29 <olsner> making "nasty syntax hacks" into just "nasty syntax" ;-)
05:07:02 <EvilTerran> GHC does postfix operators, but you've got to parenthesize
05:07:27 <matt__r> postfix??
05:07:30 <EvilTerran> > let (?) = (*2) in (3?)
05:07:31 <lambdabot>  6
05:07:55 <matt__r> ah - unary postfix...
05:07:55 <EvilTerran> because (foo ??) is the same as (??) foo, you can use unary functions postfix :D
05:07:55 <ivant> wli, I think I've got an idea, but it's hard to explain it right now
05:08:20 <ivant> wli, I'd need to write down a lot of stuff and see if it works out
05:08:24 <EvilTerran> and prefix is just "(??) foo" :P
05:08:57 <ivant> wli, main idea is to build lots of equations `mod` p and see how many choices we can get
05:09:03 <EvilTerran> > (2 `sqrt`)
05:09:05 <lambdabot>  1.4142135623730951
05:09:27 <ivant> wli, each equation can give us maximum of 79 (or 78?) choices
05:09:44 <augustss> It feels silly to parenthesize postfix operators
05:14:00 <ivant> wli, all (==0) [a41,a43,a47,a53,a59,a61,a67,a71,a73,a79] == True
05:14:00 <nornagon> @help qc
05:14:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:14:08 <nornagon> @help quickcheck
05:14:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:14:13 <nornagon> @help list
05:14:14 <lambdabot> list [module|command]
05:14:14 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:14:35 <ivant> wli, I mean always, if I'm not mistaken
05:15:54 <nornagon> @help scheck
05:15:55 <lambdabot> scheck <expr>
05:15:55 <lambdabot> You have SmallCheck and 3 seconds. Test something.
05:16:22 <nornagon> @scheck (\a -> (a :: Float) > (a + a))
05:16:29 <nornagon> er
05:16:33 <nornagon> @scheck (\a -> (a :: Float) > (a + 1))
05:16:33 <lambdabot>   Failed test no. 1. Test values follow.: 0.0
05:16:35 <lambdabot>   Failed test no. 1. Test values follow.: 0.0
05:16:45 <nornagon> @scheck (\a -> (a :: Float) < (a + 1))
05:16:46 <lambdabot>   Completed 79 test(s) without failure.
05:16:48 <nornagon> d'oh :)
05:16:59 <MyCatVerbs> @help help
05:16:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:17:50 <nornagon> @scheck (\a -> 1 + (a - a) == (1 + a) - a) :: Float -> Bool
05:17:51 <lambdabot>   Completed 79 test(s) without failure.
05:18:16 <augustss_> @scheck (\ a b c -> (a+b)+c == a+(b+c::Float))
05:18:19 <lambdabot>   Completed 493039 test(s) without failure.
05:18:53 <nornagon> > let a = 10e20 in 1 + (a-a) :: Float
05:18:56 <lambdabot>  1.0
05:19:02 <augustss_> @check (\ a b c -> (a+b)+c == a+(b+c::Float))
05:19:03 <lambdabot>  Falsifiable, after 0 tests: -1.3333334, 4.0, 0.3333333
05:19:12 <augustss_> That's better
05:19:18 <nornagon> after 0 tests!
05:19:32 <augustss_> The mind boggles
05:20:29 <ivant> @pl \a b -> snd a == snd b
05:20:29 <lambdabot> (. snd) . (==) . snd
05:23:14 <nornagon> :t (>>>)
05:23:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
05:23:48 <nornagon> @src Arrow
05:23:48 <lambdabot> class Arrow a where
05:23:48 <lambdabot>     arr, pure   :: (b -> c) -> a b c
05:23:48 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
05:23:48 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
05:23:48 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
05:23:50 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
05:23:52 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
05:31:45 <Syzygy-> @kind (->) Char Bool
05:31:47 <lambdabot> *
05:31:54 <Syzygy-> @kind (->)
05:31:56 <lambdabot> ?? -> ? -> *
05:32:17 <Syzygy-> @type undefined :: ((->) Char Bool)
05:32:19 <lambdabot> ((->) Char Bool) :: Char -> Bool
05:47:02 <fasta> Can I rewrite data Foo s a = A (STArray s Int Int) to data Foo a = forall s. A (STArray s Int Int) or something like that?
05:48:57 <MyCatVerbs> fasta: sure, why not? It's a free country. Dunno whether it'll work or not, though. :)
05:49:34 <SamB_XP> I don't think so...
05:50:46 <desegnis> fasta, do you want to achieve something specific?
05:51:05 <fasta> desegnis: I thought of getting rid of the infecting s parameter.
05:51:21 <fasta> Hmm, it appears the code compiles.
05:51:37 <fasta> I wonder whether it also works when combined with other things
05:51:44 <desegnis> I suppose that if you do that rewrite, you won't be able to get the s out of the Foo. But I may be wrong, of course
05:51:45 <SamB_XP> just wait until you try using it with STToIO!
05:51:55 <SamB_XP> er.
05:51:58 <SamB_XP> stToIO
05:52:03 <opqdonut> hehe
05:53:00 <fasta> SamB_XP: ok, right, that needs a specific value for s.
05:53:17 <fasta> SamB_XP: but combining it with runST, should work, right?
05:53:29 <SamB_XP> you didn't try yet?
05:53:36 <fasta> SamB_XP: no
05:53:51 <SamB_XP> never declare something ST to work until you have
05:54:58 <desegnis> my guess would be that runST should work with it. who bets against me?
05:55:15 <SamB_XP> I've given up betting on ST
05:55:22 <desegnis> :)
05:55:30 <Saizan> i bet!
05:55:53 <pjd> shapr: http://www.math.uu.se/~georg/tt.dist/dist/
05:55:56 <lambdabot> Title: The tt program
05:56:31 <opqdonut> heh, coding something like that in C :D
05:57:24 <augustss_> A masochist :)
05:58:26 <fasta> SamB_XP: it works
05:58:36 <fasta> SamB_XP: it needs scoped type variables, but it works
06:03:23 <wli> opqdonut: People used to write compilers in asm, too.
06:05:30 <MyCatVerbs> wli: ehhh, bootstrapping.
06:06:18 <wli> Not entirely, since it took a while for it all to settle in. Still.
06:07:26 <wli> The footprint of this brute-force search is shockingly small.
06:07:39 <wli> At least when compiled with -O2
06:07:54 <wli> 28579 wli       25   0    5  5136 2996  888 R 3  100  0.1 223:23 invsq
06:09:28 <wli> RSS < 3MB, VSZ < 5MB
06:09:59 <fasta> wli: what brute-force search?
06:10:03 <wli> I'm flabbergasted. I usually expect space *leaks*, not mysteriously small space usage.
06:10:20 <wli> fasta: Oh, some Project Euler bullcrap.
06:10:26 <wli> fasta: (#152)
06:10:42 <olsner> all the space must have leaked away!
06:11:09 <fasta> Stop doing that!
06:11:41 <wli> fasta: http://hpaste.org/2397
06:13:10 <fasta> wli: mapM_ print $ [sort ns | (0, ns, []) -> <- <- what is that?      selections n `genericIndex` (n+5)]
06:13:35 <wli> fasta: Pattern match.
06:14:07 <fasta> wli: oh, right
06:14:11 <fasta> wli: I missed the comprehension
06:15:49 <fasta> wli: maybe you would like to name more functions?
06:16:07 <wli> fasta: Like what?
06:16:28 <fasta> wli:  [(1/4, [2], zipWith (uncurry (,,)) (map (id &&& invsq) [3..n]) (scanr (+) 0 $ map invsq [3..n]))]
06:16:49 <fasta> wli: I don't think anyone can tell within a second how this works.
06:16:57 <fasta> wli: except you
06:17:12 <wli> fasta: Not sure what you mean.
06:18:15 <fasta> wli: it's rather dense.
06:18:38 <wli> fasta: Maybe I should've used a list comprehension.
06:19:17 <wli> fasta: Except the scanr didn't fit.
06:21:31 <wli> fasta: Is there a specific question as to what it's doing? I'm sort of not seeing anything obvious to explain.
06:22:26 <fasta> wli: no, it was just a suggestion for style.
06:22:40 <fasta> wli: you should try reading this code in two years.
06:22:45 <Saizan> null ys is generally better than ys == []
06:23:03 <opqdonut> ?src null
06:23:03 <lambdabot> null []     = True
06:23:03 <lambdabot> null (_:_)  = False
06:23:06 <opqdonut> :)
06:23:13 <wli> Yeah, pattern match.
06:23:45 <wli> The algorithm is so poor there just isn
06:23:52 <wli> t much to salvage.
06:24:02 <sieni> I think (_:_) looks a bit... nsfw
06:27:06 <wli> | [] <- ys would've been best really.
06:30:06 <wli> fasta: There's nothing remotely subtle going on with the tidbit you complained about. Triples of numbers, their inverse squares, and running sums of the inverse squares are just not hard to figure out.
06:32:30 <wli> selectStep just doesn't do enough to be hard to figure out. Frankly I thought I was being generous by breaking up the one-liner I actually fed to ghci as much as I did.
06:36:23 <fasta> wli: I write my code, s.t. there is nothing to "figure out".
06:36:51 <fasta> wli: except for the inherent complexities of the algorithm involved.
06:37:20 <wli> Don't know what to tell you. I guess I'm used to the sorts of constructs I'm using.
06:38:39 <wli> I guess I've had 10 years of bad FP habits.
06:44:12 <wli> There's also a large difference in the way I write for code meant to be flushed down the toilet almost immediately and code to be presented anywhere that matters. For the latter, storybook comments and all sorts of clarity-enhancing devices go on (including reallyLongHighlyDescriptiveVariableNames).
06:45:03 <b_jonas> oh yeah. I use really ugly one and two letter variable names
06:45:21 <wli> It's (a) a Project Euler problem and (b) a non-solution of that largely for verification and comparison purposes
06:45:48 <b_jonas> sometimes I even use the same name for two things -- it depends on the language whether the parser can catch that easily
06:46:13 <wli> One and two letter variable names look nicer, though its self-explanatoriness is less.
06:46:33 <fasta> wli: I was assuming that since you showed the channel it was "good code" according to you. There's little point in propagating bad examples.
06:46:59 <wli> fasta: I showed the channel because the space usage was vastly less than expected.
06:47:13 <ricky_clarkson> wli: I avoid storybook comments because they make the code less fluid.
06:47:17 <ricky_clarkson> Harder to change.
06:47:43 <fasta> reallyLongDescriptiveNamesAreTheBest
06:47:48 <ricky_clarkson> no
06:48:05 <sieni> fasta: not until you run out of single-letter identifiers
06:48:09 <wli> fasta: The same code run in ghci eats GB of RAM. The exponential-ness of the algorithm suggests exponential space as well. For some reason when ghc-compiled it runs in 3MB.
06:48:35 <wli> fasta: That's why it was hpasted.
06:50:06 <wli> fasta: And as far as verification/comparison goes, the only way to compare it is to compare it to others' brute-force code. The problem is sufficiently resistant to brute force that it does not produce answers at all.
06:52:36 <olsner> is it possible that the optimization stage somehow produces a dynamic-programming version from the source?
06:53:44 <wli> olsner: My wild guess is not dynamic programming but some sort of enumeration -based algorithm that only considers one possible solution at a time while not storing any, accomplished via deforestation.
06:54:13 <olsner> so it is still really slow, only constant-space?
06:54:21 <wli> olsner: Basically yes.
06:55:23 <wli> olsner: It's using 8KB more RAM now after holding to 2996KB for over 8 hours.
06:55:42 <olsner> annoying how obscure the runtime behaviour of haskell programs can be sometimes
06:56:33 <SamB_XP> olsner: this is why you should do your computation at compile time
06:56:34 <b_jonas> it's lazy and functional, what d'you expect
06:56:46 <wli> I spend most of my time trying to figure out what things do operationally at work.
06:57:43 <SamB_XP> hey, at least *your* kernel usually boots
06:57:47 <wli> For writing Project Euler solutions in Haskell I don't even want to think about the fact a machine exists that has to execute it. I want pure equational reasoning and to forget such a thing as operational semantics even exists.
06:58:38 <olsner> I expect to have all the good things with laziness and functionality, but still be able to write code that easily and reliably translates to trivial constant-space algorithms when compiled
06:58:56 <wli> SamB_XP: Depends on what you mean by "my kernel" and "usually."
06:59:52 <wli> If you mean "kernels that I've patched" and "by proportion of the number of boots" the answer is actually that my kernels usualy *don't* boot.
07:00:41 <wli> If I just sat there and didn't crash and reboot things all the time I wouldn't be much of a kernel hacker.
07:01:03 <wli> If the thing boots, well, ship it and move on to the next patch.
07:01:24 <wli> (Oversimplified but you get the idea.)
07:01:44 <gleb> Do I understand correctly that most SPECIALIZE pragma works only in the module with definition of func I want to specialize?
07:01:53 <gleb> s/most///
07:02:10 <wli> If it works the first time you don't spend all that much time on it. You crank out more until you have to actually do work, i.e. figuring out why it didn't boot.
07:02:31 <SamB_XP> wli: well, at least you probably crash your own kernel ;-)
07:03:00 <SamB> I'm not much of a kernel hacker but I did fix a bug in ReactOS
07:03:08 <wli> SamB_XP: Yes, I do my best to avoid letting the bits that crash leave the shop.
07:03:50 <eivuokko> SamB,  how does ReactOS look like?
07:04:01 <ricky_clarkson> Do kernel hackers use stuff like vmware to see whether stuff boots but taking less time?
07:04:07 <wli> Very NT/Windows -like.
07:04:07 <SamB> eivuokko: well mine keeps mysteriously failing
07:04:13 <ricky_clarkson> I suppose most of them are interested in hardware devices, so probably not..
07:04:19 <therp> ricky: I used qemu for my kernel hacks
07:04:20 <SamB> oh, I forgot to rebuild after "make clean"
07:04:22 <wli> ricky_clarkson: Yes. I tend to use SimNow.
07:04:56 <therp> ricky: qemu is nice because it has a built in linux kernel loader, you don't need to write your kernel to a virtual device so that it's loaded by the boot loader -- qemu is the boot loader itself
07:05:03 <SamB> I wish qemu would let me break into tight loops with GDB
07:05:20 <SamB> I should probably try to fix that...
07:05:22 <wli> therp: SimNow does similar.
07:06:01 <therp> wli: ah, never heard of.. but I'm out of the kernel hacker scene anyway :) (strange attitude)
07:06:14 <SamB> ReactOS builds an install CD automatically
07:06:29 <SamB> and it's not hard to set it up to install automatically
07:06:33 <wli> therp: It's a commercial simulator.
07:06:58 <SamB> by not hard, I mean you do it by a cp command and uncommenting a line in an XML file
07:07:47 <wli> therp: You could hack/debug BIOS's on it if you wanted. Singlestep through triplefaults and into the BIOS. Trace anything. Break into anything. etc.
07:08:45 <wli> therp: You can write simulation code for new hardware devices in Python.
07:08:53 <SamB> wli: in Python?
07:08:56 <SamB> wierd
07:09:11 <SamB> it beats having to use C though I guess
07:09:16 <wli> SamB: Yeah. I've never looked into it (in part because I hate Python) but that's how it's done.
07:09:19 * SamB wonders if you can use rpython
07:09:24 <b_jonas> I don't dare to touch the kernel.  That guarantees stability even if I do stupid things in programs.
07:09:36 <SamB> b_jonas: wli is paid for it
07:09:36 <Vq^> wli: why do you hate python?
07:09:42 <b_jonas> well yeah.
07:10:08 <SamB> I personally think kernel hackers should go on sabbatical in userspace
07:10:17 <wli> Vq^: It's yet another one of those sucky OO interpreted languages.
07:10:38 <b_jonas> The most I've done is applying an existing patch to the kernel version it's intended to.
07:10:53 <SamB> I must admit that wli's assesment is correct, no matter how much I like(d) python
07:10:57 <wli> I think if I went on sabbatical I'd take a break from computers altogether. Maybe I would take up hairdressing in the interim.
07:11:04 <SamB> wli: hmm, or that
07:11:13 <SamB> whichever they prefer
07:12:44 <wli> Or something involving cosmetics or fashion.
07:13:15 <SamB> where by "that", I mean "something besides computers"
07:14:02 <SamB> oh, anyway, you wouldn't believe how simple this bug was to fix once I ran into the offending code ;-)
07:14:26 <wli> SamB: Do tell. I've not looked at ReactOS code in recent memory.
07:15:05 <wli> I wonder if anyone's tried hacking on House/hOp.
07:15:12 <SamB> someone clearly has
07:15:15 <SamB> or they wouldn't exist
07:15:22 <wli> I meant someone on this channel now.
07:15:24 <SamB> hehe
07:15:46 <b_jonas> I tried to read a few bits of kernel code though
07:16:06 <xerox> Me too. But I wasn't very motivated.
07:16:31 <wli> It takes a while to get into it.
07:16:41 <olsner> isn't house/hOp quite dead by now?
07:16:45 <wli> It took me about 2 years to get off the ground.
07:17:03 <SamB> here's the bug: http://www.reactos.org/bugzilla/show_bug.cgi?id=2408
07:17:06 <lambdabot> Title: ReactOS Homepage - Bug 2408 &ndash; KDBG's command disasm often crashes
07:17:48 <b_jonas> for example, I've verified in the linux source that it's absolutely forbidden for non-root to call the ioctl that sets the keyboard repeat rate
07:17:52 <gleb> I envy you guys :). How is it possible to get deep into math, Haskell, type hackery and kernel hacking at the same time
07:18:10 <FZ> :)
07:18:33 <osfameron> yeah, I'm thinking of taking a month study break after this contract to be able to really get any new learning done
07:18:37 <b_jonas> which is annoying if you plug out and in a keyboard which has a wrong default repeat rate, because only root can restore it
07:18:38 <wli> SamB: It doesn't show the patch.
07:18:41 <osfameron> (not sure I can afford it though)
07:18:54 <SamB> wli: yeah, I'm trying to find a place where you can see the code
07:18:59 <b_jonas> even if the right rate is set in the init scripts, once you pull it out, you're messed up
07:19:25 <wli> b_jonas: I picked up Haskell in college. I've used it in preference to Perl, Python, et al ever since.
07:19:54 <wli> b_jonas: I was a math major (among other things).
07:20:20 <wli> b_jonas: Kernel programming picked me out, not vice-versa.
07:20:26 <b_jonas> (wli: that's for gleb I think)
07:20:40 <wli> s/b_jonas/gleb/g
07:21:17 <b_jonas> it's a bit late to ask, but which kernel
07:21:33 <SamB> CIA seems down, so I've pasted the "before" code here: http://www.reactos.org/paste/index.php/0e01938/
07:21:42 <wli> b_jonas: I started on DYNIX/ptx, then moved to AIX, then to Linux.
07:22:02 <gleb> wli: is it possible to reach some degree of your level of expertise when you're 28 and you're paid for simple C++/C#?
07:22:40 <wli> gleb: I'm 31 now and didn't get out of college until I was 24.
07:23:04 <wli> gleb: The answer is yes, but you're probably vastly overestimating my expertise.
07:23:09 <SamB> wli: can you spot the bug?
07:24:02 <ricky_clarkson> gleb: You can be paid to drive a bus and still become a better programmer.
07:24:25 <SamB> wli: I'm going to guess that you can't
07:24:35 <wli> gleb: (a) I was a lousy math major and barely learned any of it (b) I was slow to start up in kernel hacking and am not really that great of one (c) I don't do anything serious in Haskell and basically can't.
07:24:56 <sieni> SamB: well at least there is one obvious bug.
07:25:02 <SamB> sieni: what's that?
07:25:51 <gleb> ricky_clarkson: :). yeah, i'm just grumbling.
07:26:14 <sieni> you have to be really _really_ careful what you pass to sprintf or vsprintf
07:26:37 <wli> SamB: (1) buffer might be too small (2) concurrent buffer access (3) not sure
07:26:48 <SamB> wli: concurrent buffer access?
07:26:55 <sieni> one should obviously be using vsnprintf
07:27:02 <eivuokko> SamB, buffer is static
07:27:07 <wli> SamB: e.g. more than one call to it happening at a time
07:27:33 <SamB> wli: I don't think you can have multiple kdbg sessions at a time ;-)
07:27:45 <SamB> the buffer thing is an issue, yes
07:27:47 <wli> SamB: Maybe not.
07:27:51 <SamB> but it hasn't bit me
07:28:13 <b_jonas> SamB: that's ugly. I had the problem that you can't launch gnome more than once as the same user on the same host.
07:28:17 <SamB> anyway, the real problem is that DbgPrint is printf-like
07:29:01 <SamB> b_jonas: it's a kernel debugger with keyboard input and serial port output
07:29:06 <wli> So it got passed something it interpreted as a format.
07:29:11 <SamB> it runs in the kernel
07:29:17 <SamB> wli: yup
07:29:33 <b_jonas> oh
07:29:41 <sieni> SamB: well, that's not obvious from the context.
07:29:49 <b_jonas> I thought it was just some ordinary debugger
07:29:50 <SamB> I think the bug was dormant for a while, at least for some, because they had it using intel format...
07:29:59 <wli> I should've guessed but it didn't quite say DbgPrintf()
07:30:25 <wli> SamB: Oh dear AT&T syntax will get massive interpretation as format strings.
07:30:30 <sieni> naturally if you want to print a string using printf, you do printf("%s", your_string); and not printf(your_string);
07:30:58 <SamB> wli: the surprising thing is that the kernel didn't crash immediately when that happened
07:30:59 <etnt> hm...I'm trying to find the Parsec homepage, seems to be down...
07:31:31 <etnt> anyone knows where I can find the darcs repository for Parsec ?
07:31:37 <SamB> it did produce a lot of "fatal error" messages though
07:31:45 <wli> SamB: You can chase a few wild pointers on average before you hit one wild enough to kill you.
07:31:46 <taruti> @where parsec
07:31:46 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
07:31:52 <taruti> hmm, that is wrong
07:32:06 <taruti> http://darcs.haskell.org/packages/parsec/
07:32:07 <lambdabot> Title: Index of /packages/parsec
07:32:14 <SamB> wli: yes but it doesn't chase wild pointers, it totally misaligns the stack
07:32:28 <SamB> well.
07:32:38 <etnt> taruti: great, thx!
07:32:40 <SamB> I suppose ebp might get it straightened out..
07:33:43 <SamB> anyway I'm pretty sure that code would have totally crashed a Linux kernel immediately
07:34:49 <SamB> and adding '"%s", ' is, imo, a pretty easy fix...
07:35:22 <SamB> though I only really found this by tracing through the code with gdb and qemu
07:36:01 <wli> SamB: Oh no, Linux sees really bad/weird memory corruptions all the time, even including bad stacks.
07:36:29 <wli> SamB: No good explanations as to how/why it survives them, but it often does.
07:36:30 <SamB> wli: well the thing is I'm pretty sure that code would have segfaulted in usermode
07:36:49 <SamB> based on some of the bugcheck codes that were being printed
07:37:04 <gleb> SamB: I'm surprised too see obvious potential buffer overflow in kernel code anyway
07:37:21 <SamB> well, this one would be hard to exploit
07:37:36 <wli> No segfaults in-kernel. If you access out-of-bounds memory in-kernel, things either drop dead or silently go on.
07:37:56 <SamB> really?
07:38:14 <wli> SamB: printf()/varargs is the real culprit. It doesn't deserve to live.
07:38:25 <MyCatVerbs> SamB: yeah, but the probability of the universe spontaneously collapsing is pretty high.
07:38:39 <SamB> I'm pretty sure this would have BSOD'd under slightly different circumstances
07:38:57 <wli> SamB: Yes, really. In DOS, for instance, you either silently keep running or spontaneously reboot(!).
07:38:59 <SamB> wli: I know.
07:39:07 <SamB> if I did that in Haskell, this would happen:
07:39:31 <SamB> > printf "push %ebp" :: String
07:39:33 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
07:39:57 <wli> SamB: The only difference between DOS and things like Linux here is that there's something that catches the exception and tries to recover set up for Linux/Solaris/UnixWare/etc.
07:39:59 <SamB> sure it's a dynamic error, but at least it's explicit
07:40:35 <wli> I thought Text.Printf was statically typed.
07:40:47 <gleb> SamB: if you did that in OCaml, it wouldn't compile. If you did that using GCC, you'd get a warning
07:40:51 <wli> Maybe not.
07:40:51 <SamB> it can't check the format string until runtime
07:41:32 <wli> Well, I've always maintained that format strings are unmitigated evil.
07:41:34 <SamB> gleb: GCC doesn't know about all the windowsy format characters, I think. so they don't have DbgPrint setup for that.
07:42:15 <gleb> SamB: yes, of course. since you speculated on using Text.Printf, I've speculated a little too.
07:42:54 <pejo> wli, doesn't coverity/sparse/etc catch a lot of those format string bugs and similar things?
07:43:01 <SamB> I wish you could include a program to extend the format-checking in the header for your library
07:43:11 * gleb wonders if it's hard to make statically-typed printf using TH
07:43:21 <SamB> gleb: not really
07:43:27 <wli> pejo: Don't really care. They're still totally evil.
07:43:32 <albertito> is it possible to write a non-trivial function (ie. not the identity) that returns itself?
07:43:33 <SamB> it's one of the examples in the papers
07:43:36 <SamB> @where th
07:43:37 <lambdabot> http://www.haskell.org/th
07:43:38 <wli> pejo: OTOH Cayenne does.
07:43:49 <SamB> gleb: if you look through the papers there, you'll find it pretty quickly
07:43:58 <wli> Dependent typing. ;)
07:44:06 <gleb> SamB:  ok, thanks.
07:44:16 <pejo> wli, yeah, go tell Linus that he wrote his kernel in the wrong language. ;)
07:44:26 * gleb thinks he should RTFM before asking stupid questions
07:44:28 <b_jonas> albertito: what do you mean by "returns itself"
07:44:56 <SamB> gleb: alternatively you could just do it
07:45:13 <wli> pejo: I would actually at most suggest an alternative formatting method besides printf() et al.
07:45:42 <gleb> albertito: I remember TaPL shows it as one of examples of recursive types
07:45:43 <SamB> the usual invocation is like $(printf "Hello, %s!\n") :: String -> String
07:45:44 <wli> Mutatis mutandis for scanf() et al.
07:46:14 <SamB> (that type was actually just for educational value, not part of the invocation)
07:46:30 <albertito> b_jonas: something like f1 1 = f1; f1 _ = f2 ; f2 1 = f2; f2 _ = f1. Not that I actually _need_ that, but it came up in a discussion and I got curious =)
07:46:58 <b_jonas> well, as far as I know, that depends on the language
07:47:15 <b_jonas> it would have a circular type which most statically typed language doesn't allow
07:47:31 <wli> I'm not entirely sure what I'd suggest as an alternative.
07:47:51 <b_jonas> but you can make a function that returns a constructed type that has the same function as a field
07:47:54 <wli> I vaguely favor things like print_int(), print_string(), etc.
07:47:56 <albertito> b_jonas: yeah, I was referring to Haskell in particular, because that issue came up in a C/C++ discussion
07:48:06 <b_jonas> it's definitely ont possible in C
07:48:15 <b_jonas> and the C faq tells that
07:48:29 <wli> I'm not entirely sure what I'd do for scanf().
07:48:32 <b_jonas> but there too you can return a struct with the function in a field
07:48:48 <SamB> wli: me either
07:48:54 <b_jonas> I'm not entirely sure but I think it's the same in C++
07:49:32 <albertito> b_jonas: no, not without casting. In C++ you can do it in a hacky way (http://www.gotw.ca/gotw/057.htm), and then the question that followed was 'so, is there any statically typed language that can do that?', and here I am...
07:49:44 <albertito> (sorry, bbiam)
07:49:48 <b_jonas> otoh, you can definitely do it in your avarage impure dynamically typed language (like scheme)
07:50:11 <b_jonas> I think there's a compiler for some statically typed language (sml iirc) that can allow such cyclic types as an option
07:50:38 <sjanssen> ocaml
07:50:39 <b_jonas> but it's not enabled by default because when you enable it, there are lots of type errors it won't catch
07:50:52 <gleb> albertito: ocaml with -rectypes : let rec f x = f
07:50:56 <b_jonas> that is, lots of code that don't really make sense but can be compiled type-safely that way
07:50:59 <b_jonas> that must be it
07:51:03 <gleb> val f : 'b -> 'a as 'a = <fun>
07:51:16 <SamB> sorear wrote a typechecker that can handle cyclic types
07:51:30 <b_jonas> but as I've said, you can avoid that with an extra type
07:51:33 <b_jonas> I have an example, awit...
07:51:34 <SamB> but I must admit when I get one of those it's usually an accident
07:52:14 <wli> SamB: It's not that involved. Just do the occurs check, if the type occurs in there, a mu is needed/inferred.
07:52:29 <b_jonas> here it is:  http://www.math.bme.hu/~ambrus/pu/olvashato/t2n.olv (http://www.math.bme.hu/~ambrus/pu/olvashato/index for docs)
07:52:31 <ricky_clarkson> > (\f x -> f f x)
07:52:32 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
07:52:32 <lambdabot>     ...
07:52:58 <b_jonas> the "loop_helperfunc" type is needed only to avoid cyclic types
07:53:15 <b_jonas> so http://www.math.bme.hu/~ambrus/pu/olvashato/t2n.sml compiles in standard ml
07:54:46 * b_jonas checks the C++ link (does it use templates in some tricky way?)
07:55:27 <wli> SamB: My best guess wrt. scanf() is probably some kind of parser combinator emulation.
07:56:38 <b_jonas> no, it just defnies a class that behaves as a function. that's no good.
07:57:01 <gleb> b_jonas: why not? it does the job
07:57:26 <b_jonas> sure it does, but it's not a function type that returns itself
07:57:50 <b_jonas> the wrapper struct does the job as well.
07:59:45 <gleb> b_jonas: it just reflects the fact that virtually all programming languages with structs/records/objects allow recursive types
08:01:23 <b_jonas> yes
08:02:11 <b_jonas> what about haskell btw?
08:02:31 <gleb> b_jonas: of course it does as well
08:02:44 <b_jonas> but, I mean,
08:03:01 <b_jonas> can you have a function that returns a function of the same type in haskell then?
08:03:31 <wli> Not that I'm aware of.
08:04:00 <b_jonas> though I admit, the class thing in c++ is close
08:04:10 <gleb> does PrintfType count as example?
08:04:23 <gleb> or Oleg's polyvariadic functions?
08:05:37 <albertito> back, sorry
08:06:16 <gleb> > :t printf
08:06:20 <lambdabot>   parse error on input `:'
08:06:45 <gleb> @list
08:06:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:07:11 <gleb> @type printf
08:07:13 <lambdabot> forall r. (PrintfType r) => String -> r
08:07:22 <gleb> @type (printf "" 1 2)
08:07:24 <lambdabot> forall t t1 t2. (Num t, Num t1, PrintfType (t -> t1 -> t2)) => t2
08:08:16 <xerox> Here's one..
08:08:27 <xerox> ?paste
08:08:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:09:46 <hpaste>  xerox pasted "a function of some type that returns a function of the same type" at http://hpaste.org/2400
08:12:13 <albertito> b_jonas: yeah, in dynamically typed languages it gets much easier... so far the C++ has been the better we found among statically typed ones :S
08:12:14 <gleb> xerox: maybe I'm missing something but reflect is just _|_, which can be given any type
08:12:36 <xerox> gleb: yes indeed
08:13:44 <xerox> gleb: you can make it nicer with incoherent instances, but I don't think you can do anything sensible with such a function
08:14:06 <b_jonas> albertito: I sort of feel that in a language with explicit type declarations (like C) it's sort of a syntax issue
08:14:54 <b_jonas> namely, you can declare an incomplete struct and then use pointers to it, but you cannot declare an "incomplete function type" and use pointers to it
08:15:28 <b_jonas> but I'm not sure it wouldn't have semantic problems as well if it was allowed
08:15:30 <wli> b_jonas: Mostly people just hack around it with void *
08:15:48 <b_jonas> wli: but that's bad. you should use a wrapper struct. really.
08:16:04 <xerox> gleb: wait, it *can* return something :)
08:16:13 <wli> b_jonas: I'm not sure anyone can be arsed to respect a typesystem so shot full of holes.
08:16:37 <b_jonas> wli: well, I'm more in a C++ mind now you know
08:16:52 <gleb> xerox: I guess monadic action that returns itself can be useful for its side effects. Like ConT State or somthing
08:16:58 <albertito> b_jonas: that was pretty much our conclusion regarding C/C++. But I thought I should give Haskell a shot because the type system is quite rich and maybe it allowed something like this
08:17:07 <wli> b_jonas: The same goes for C++
08:17:33 <b_jonas> wli: well, I won't argue about that on a haskell channel
08:18:28 <wli> b_jonas: It is possible to make C/C++ -like languages with far sounder, more rigorous/complete, etc. type systems.
08:18:40 <hpaste>  (anonymous) annotated "a function of some type that returns a function of the same type" with "(no title)" at http://hpaste.org/2400#a1
08:19:15 <hpaste>  xerox annotated "a function of some type that returns a function of the same type" with "one that returns something" at http://hpaste.org/2400#a2
08:19:29 <albertito> xerox: that paste (I didn't expected it to be announced here, sorry) is what I get when trying to load your example in ghci
08:19:46 <gleb> albertito: you missed pragma
08:20:02 <gleb> -fglasgow-exts will do the trick
08:20:12 <wli> b_jonas: It's actually sort of dull. The differences center largely around how specific syntactic constructs are typed.
08:20:20 <xerox> aw, the () is an 'a'
08:20:25 <xerox> typo, sorry
08:20:48 <albertito> gleb, xerox: thanks, sorry about that
08:20:50 <xerox> annotated the correction.
08:21:07 <wli> b_jonas: And ripping out untypable things like varargs.
08:21:48 <b_jonas> wli: I did say I'm in a C++ mind nowdays, and C++ is trying to banish varargs and some similar things
08:22:10 <ricky_clarkson> Java brought them in not long ago. ;)
08:22:29 <b_jonas> ricky_clarkson: not all varargs is C varargs
08:22:44 <gleb> b_jonas: I thought they are going to allow polyvariadic macros (and even templates)
08:22:45 <b_jonas> Java would probably have safer varargs
08:22:51 <ricky_clarkson> Java's are arrays.
08:22:52 <b_jonas> gleb: yes,
08:23:12 <b_jonas> there are polyvariadic macros in C99 and a different variant of them in gcc
08:23:27 <wli> In Java everyone hacks around the weak class system by coercing to/from Object or similar.
08:23:40 <b_jonas> and polyvariadic templates in the C++0X proposal
08:24:04 <b_jonas> but those aren't the unsafe things as C-like varargs
08:24:05 <ricky_clarkson> wli: That's not true these days.
08:24:21 <wli> Polyvariadic stuff everywhere. Oleg's idea seems to have spread like wildfire.
08:24:39 <wli> ricky_clarkson: Perhaps more discipline is enforced.
08:24:41 <b_jonas> because the preprocessor is a hack anyway but vararg macros won't cause segfaults and the like
08:25:00 <ricky_clarkson> wli: No, since generics there just aren't as many reasons to use Object.
08:25:23 <b_jonas> and I don't know much about vararg templates but they work by overloading (compile time) not the unsafe vararg thing
08:25:35 <wli> ricky_clarkson: ISTR the Java people ignored Wadler and did something broken there.
08:26:15 <ricky_clarkson> wli: You might be referring to erasure, where Java forgets most of its generics at runtime.
08:26:48 <albertito> xerox, gleb, b_jonas: thanks a lot! I'll think about that pastebin example later at home
08:27:05 <wli> ricky_clarkson: I'm thinking there's some hole in the generics' typesystem that Wadler's proposal didn't suffer from.
08:27:34 <SamB> ricky_clarkson: maybe he was thinking of how you can consider any array as an array of Object -- and you can pass it to something that will put objects in it -- or am I confused?
08:27:45 <gleb> albertito: you may want to check http://okmij.org/ftp/Haskell/vararg-fn.lhs as well
08:27:49 <SamB> well, if it wasn't that it was definately something else
08:28:02 <ricky_clarkson> SamB: That was there before generics, and generics has the opposite behaviour to that anyway.
08:28:08 <SamB> ah
08:28:08 <wli> SamB: ISTR it had to do with arrays.
08:28:17 <SamB> either way is bad though I think
08:28:22 <wli> SamB: But not that particular case. Something obscure.
08:28:41 <ricky_clarkson> SamB: Also, putting an Object into a wrong-typed array throws an exception, so it's not that bad.
08:28:43 <albertito> gleb: will do, thanks!
08:28:52 <wli> SamB: I think involving the ternary ? : operator.
08:29:01 <b_jonas> wli: could you tell how you thing the C++-like type system could be made better in your opinion, apart from removing varargs?
08:29:15 <SamB> ricky_clarkson: that's better than if it just resulted in a segfault if you tried to call methods or access fields that weren't there, yes...
08:29:18 <b_jonas> I'm not saying it's perfect, but I'm interested in what you refer to exactly
08:29:22 <ricky_clarkson> wli: There is something really retarded as a special case in the ternary operator.
08:29:54 <ricky_clarkson> wli: true ? new Integer(3) : new Double(5); gives 3.0 as a Double.
08:29:55 <phobes> b_jonas: Stroustrup has himself noted several places where C++ suffers from flaws of C
08:30:04 <gleb> b_jonas: C++ is inherently type-unsafe thanks to pointer arithmetics, it cannot be easily fixed
08:30:14 <phobes> Pointers being the main one
08:30:15 <wli> b_jonas: C++ basically needs to start over from the same point C needs to start over from, so it's not particularly interesting.
08:30:53 <b_jonas> that didn't sound very concrete.
08:31:03 <b_jonas> pointer arithmetic... yes
08:31:05 <b_jonas> that's true
08:31:11 <b_jonas> but it's not such a major fault
08:31:30 <b_jonas> it's just that pointer arith is allowed even if the pointer doesn't point to an array
08:31:35 <dylan> hmm, anyone have an example for inserting text into a gtk2hs TextView?
08:31:41 <phobes> The ability to cast anything to (void *) is obviously unsafe
08:31:43 <ricky_clarkson> If you just don't use pointer arithmetic, then you're safe, no?
08:31:47 <wli> b_jonas: Go back, fix up C, then start extending C with proper versions of C++'s extensions. Blah blah blah. It's all broken from a very low level on up.
08:31:54 <mauke> ricky_clarkson: that means you can't use arrays
08:32:11 <mauke> that includes strings
08:32:11 <wli> ricky_clarkson: Good luck getting by without arrays or pointers.
08:32:11 <b_jonas> I think "inherently type-unsafe thanks to pointer arithmetics" is not true
08:32:15 <dcoutts> dylan: oh, looks like there isn't one in the gtk2hs demos collection, but fear not, it's quite simple...
08:32:36 <ricky_clarkson> mauke: Then make a special case for arrays, or wrap up the pointer arithmetic for arrays in some utility functions so that you can easily spot bad ones.
08:32:38 <gleb> pointers to automatic objects shouldn't be compatible with pointers to store
08:32:41 <dylan> gtk2hs is rather nothing like the creeping horror of other gtk bindings. :)
08:32:45 <wli> b_jonas: It is when it's not bounds-checked.
08:32:49 <mauke> ricky_clarkson: http://mauke.ath.cx/stuff/c++/inheritance-breaks-type-safety.cc
08:32:57 <b_jonas> wli: so do you mean only pointer arithmetic and arrays?
08:33:02 <ricky_clarkson> wli: Getting by without pointer arithmetic isn't the same as getting by without pointers.
08:33:15 <b_jonas> because I'd like to know hear more concrete problems than "fix up C"
08:34:00 <b_jonas> wli: sure, but that's not a goal of C/C++. you cannot get complete type safety in a dynamic language like C++ and cannot have bounds checking without a slowdown.
08:34:01 <dcoutts> dylan: you need to use textBufferGetEndIter and textBufferInsert
08:34:07 <gleb> b_jonas: automatic type conversion rules are particularly nasty
08:34:13 <wli> b_jonas: No, that's not where I see the problems. C has varargs, implicit coercion weirdnesses, bad ? : typing rules, magic zero properties, etc.
08:34:16 * dylan hoogles those.
08:34:28 <b_jonas> just because you can reference invalid memory doesn't make it not "type safe" I think
08:34:37 <wli> b_jones: Not to mention statement/expression nastiness.
08:34:44 <phobes> wli:  What's the problem with the type of ? : -- ?
08:34:45 <b_jonas> gleb: do you mean the one with integers?
08:34:48 <b_jonas> and numbers
08:35:02 <ricky_clarkson> mauke: Is that the old "arrays of direct structs instead of arrays of pointers" problem?
08:35:12 <b_jonas> what do you mean by implicit coercion weirdness?
08:35:23 <mauke> ricky_clarkson: possibly
08:35:30 <b_jonas> magic zero... is that about null pointers or what?
08:35:37 <gleb> b_jonas: with array-to-pointer conversion, followed by pointer-to-derived object to pointer-to-base. it can hurt very much
08:35:57 <ricky_clarkson> Can't be bothered running it, but it seems like it would give a stupidly large number or whatever 42 ends up as when you convert its bits as an int to a float.
08:35:58 <osfameron> what's wrong with C's   "? :" construct ?
08:36:03 <b_jonas> hmm
08:36:12 <phobes> osfameron: that's what I want to know
08:36:13 <mauke> printf("%d\n", ({ goto lol; }), ({ lol: 42; }));
08:36:23 <phobes> That's news to me
08:36:34 <mauke> ricky_clarkson: depends on your optimization settings :-)
08:36:42 <gleb> b_jonas: ODR violations can be hard to detect (though it's about lack of real modules, not type system issue)
08:36:46 <wli> The implicit decay array to pointer conversion is one of the numerous implicit conversion issues.
08:37:14 <b_jonas> wli: yeah, the array thing
08:37:16 <mauke> wli: actually, that's just evaluation, not conversion
08:37:20 <b_jonas> I admit that's sort of nasty
08:37:44 <dylan> TextBufferClass c
08:37:46 <wli> Multidimensional arrays are nasty in C.
08:37:47 <dylan> err,
08:37:51 <wli> etc.
08:37:56 <dylan> how do I get a TextBufferClass c of a TextView?
08:38:04 <b_jonas> wli: oh sure but how would you make multidimensional arrays better?
08:38:26 <phobes> There's another problem with C++'s type system in calling virtual functions during construction / destruction
08:38:42 <dylan> I love google.
08:38:46 <dylan> er
08:38:47 <dylan> hoogle.
08:38:55 <wli> b_jonas: The obvious way, requiring compiler support for more than just "array of array" types.
08:38:57 <b_jonas> because if you want an array type that knows about its dimensions, then it's not a thing the core should address, you can do that as a class
08:39:38 <ricky_clarkson> The core should address it if it is faster done by the core.
08:39:50 <b_jonas> ricky_clarkson: but it's not
08:40:02 <b_jonas> the point with c++ classes like that is that they optimize well
08:40:05 <wli> b_jonas: What classes? I'm just on C.
08:40:26 <b_jonas> most of the small constructors and destructors and methods are inlined
08:40:41 <b_jonas> wli: oh well, if you want to stick with C then you get that
08:40:55 <phobes> pretty much anything with a loop isn't inlined
08:41:10 <gleb> b_jonas: the problem is general is outdated by now idea to have mix of high-level and low-level stuff in one language, with type system with no theoretical underpinnings that went through a series of modification, pathcing various holes
08:42:01 <wli> Yeah, the mix of high-level and low-level stuff is just nonfunctional.
08:42:03 <b_jonas> gleb: hum
08:42:09 <wli> C++ is not worth it.
08:42:37 <phobes> Unboxing in haskell is a pretty low level concept
08:43:25 <gleb> ok gotta go now. thanks for interesting discussion guys!
08:43:49 <b_jonas> one problem with the C++ type system is that it's easy to misuse it
08:43:59 <SamB> hard not to
08:44:04 <b_jonas> that's true for C++ in general
08:44:20 <SamB> it's even easier to shoot yourself in the foot with C++ than with C
08:44:25 <wli> gleb's statement (however garbled) seems to be the wrap-up for C++.
08:44:28 <b_jonas> yep, that's true
08:44:41 <b_jonas> but C++ is a very good tool if you learn it I think
08:44:44 <SamB> since there are so many more things that you can forget that the compiler probably won't tell you about
08:44:44 <mauke> did someone say template<typename T> operator T() ?
08:45:24 <SamB> mauke: you can't DO that
08:45:28 <b_jonas> SamB: sort of but no. it's not forget, but know wrong.
08:45:30 <wli> I learned C++ in school. I've never used it since.
08:45:32 <mauke> SamB: sure I can!
08:45:37 <SamB> you have to mention T in the argument list
08:45:43 <mauke> no :-)
08:45:49 <SamB> oh. no. what????
08:45:51 <mauke> there is no argument list here anyway
08:45:51 <wli> Not since the class that taught it, even.
08:45:58 <b_jonas> wli: school... that could be the problem
08:46:00 <SamB> what's that () then
08:46:11 <mauke> ok, it's an empty parameter list
08:46:24 <SamB> oh, parameter, argument, whatever...
08:46:28 <phobes> I find that it's confusing to some programmers to have . and -> to look up from structs depending on whether or not it's through a pointer
08:46:39 <SamB> I'd probably call them formal and actual if I wanted to be specific
08:46:41 <wli> b_jonas: If so it's not been a problem for 8 years.
08:46:45 <mauke> http://mauke.ath.cx/stuff/c++/awesome/null.hh
08:46:55 <phobes> So I add "Class &operator ->() { return *this; }" to all of my classes
08:47:00 <phobes> and just use -> everywhere
08:47:00 <b_jonas> wli: well, depends on what you work
08:47:06 <phobes>  : P
08:47:17 <b_jonas> for a kernel hacker, you probably don't need it
08:47:22 <mauke> phobes: yeah, because normal pointers are too easy
08:47:29 <mauke> phobes: you also need to confuse anyone who reads your code
08:47:49 <phobes> mauke: Yes, I'm joking of course
08:47:55 <mauke> hmm
08:48:02 <ricky_clarkson> If you use 15 idioms in every class, than each person who reads your code will be able to understand some part of it.
08:48:17 <ricky_clarkson> That might be an improvement.
08:48:18 <wli> b_jonas: Where would I need it? I've very rarely heard of userspace programmers using C++ even; mostly either they do low-level userspace in C or high-level userspace in crap like Perl/Python/Ruby/etc.
08:48:21 * SamB hopes RoS manages to make it through both phases of installation this time
08:48:37 <mauke> this is a bit like not understanding the difference between Int and m Int, or let x = foo vs. x <- foo
08:48:51 <mauke> so in conclusion, do notation needs to overload =
08:48:57 <b_jonas> but better than that is defining a numerical type where * is subtraction and + is division and use it mixed with the normal numbers.
08:49:04 <phobes> heh yes :)
08:49:17 <SamB> mauke: that sounds hard
08:49:22 <mauke> b_jonas: you definitely want to overload ,
08:49:27 <b_jonas> wli: well, I hear a lot about userspace programmers using Java and not much about them using C++, but that doesn't mean anything
08:49:28 <SamB> how will it know what to do if I write this:
08:49:36 <SamB> do x = [1,2,3]
08:49:38 <b_jonas> mauke++ indeed. and && and = too.
08:49:42 <SamB> er.
08:49:47 <wli> b_jonas: I never hear about Java, either.
08:49:51 <SamB> and then some stuff that uses x
08:49:58 <mauke> SamB: it just guesses
08:49:58 <SamB> like, oh, return x
08:50:11 <SamB> what does it guess?
08:50:12 <phobes> I always go through and change all of the standard libraries to use , instead of << and >> for streams
08:50:17 <b_jonas> well, I do write stuff for a C++ project in C++ (also in high-level languages) so I hear about it a lot
08:50:28 <SamB> mauke: how do you desugar it anyway/
08:50:34 <SamB> s|/|?|
08:50:35 <mauke> sort of like what C++ does when it sees template<typename T> struct Foo { ... { T::foo bar; } }
08:50:49 <b_jonas> and I also had to meet a java tool for it (but not program it luckily)
08:50:50 <mauke> wait, let's make that T::foo(bar);
08:51:26 <phobes> No it doesn't guess
08:51:39 <phobes> You now how to explicitly annotate if you mean :  typename T :: foo bar;
08:51:45 <phobes> how = have*
08:52:12 <mauke> SamB: desugar? you must be kidding
08:52:12 <phobes> which is usually what you want, so you have to annotate typename all over the place ...
08:52:25 <SamB> mauke: no, you
08:52:49 <mauke> we need several complex rules involving the surrounding types to determine which meaning is wanted
08:52:55 <b_jonas> yeah. now the bad _syntax_ is inherited from C
08:52:56 <mauke> and a special keyword to force one choice
08:53:12 <SamB> mauke: come back once you've written them on a napkin
08:53:32 * Botje wonders about the availability of A0 napkins
08:53:41 <SamB> Botje: I think they tear too much
08:53:54 <mauke> I'd like to see the C++ name lookup rules on a napkin
08:54:03 <Botje> make them in sheat-steel then :)
08:54:07 <SamB> I thought we were talking about Haskell
08:54:11 <wli> If I were going to design a better C from scratch, I'd probably start with an ML-like module system.
08:54:32 <SamB> huh
08:54:37 <SamB> how does that work for a C?
08:54:48 <phobes> ... That's like saying... if I were going to design a better C from scratch, I'd start with haskell
08:54:52 <hpaste>  b_jonas pasted "C++ puzzle" at http://hpaste.org/2401
08:55:00 <SamB> phobes: not quite as bad
08:55:02 <b_jonas> as for ugly syntax, that's an example
08:55:06 <glen_quagmire> what does first class module look like?
08:55:16 <wli> SamB: All module systems involve is namespace manipulation.
08:55:35 <SamB> wli: oh, I thought you meant that higher-order stuff
08:55:42 <wli> SamB: So there's no reason to limit them to first-order, crippledness, etc.
08:55:43 <mux> yay for first-class modules encoding using existential types
08:55:55 <SamB> you DID mean that higher-order stuff
08:56:14 <SamB> ... wouldn't that be a less-bad C++ rather than a better C?
08:56:19 * mux really like dealing with that part in TAPL
08:56:24 <mux> liked
08:57:22 <wli> SamB: Not really. The language itself would basically be like C; the module system would be the only "advanced" thing because it as zero runtime impact.
08:58:25 <b_jonas> wli: c++ does have zero runtime impact where possible
08:58:37 <wli> SamB: Namespace control is a very awkward aspect of large C projects. Witness the numerous "header cleanups" in Linux, for instance.
08:58:54 <b_jonas> virtual methods aren't like that but you can't substitute that with any zero-runtime-impact thing anyway usually
08:58:55 <pgavin> quick question: what does the "| m -> e" part of "class (Monad m) => MonadError e m | m -> e where..." mean?
08:59:04 <wli> b_jonas: C++ scarcely addresses the namespace control issues if at all.
08:59:07 <mauke> b_jonas: hmm, the :: is to make it find the right d, I guess
08:59:11 <b_jonas> wli: that's true
08:59:13 <pgavin> is that one of those functional dependencies things I've been hearing about?
08:59:14 <b_jonas> very true
08:59:17 <SamB> wli: it doesn't seem much like C if you essentially have templates...
08:59:18 <wli> b_jonas: The namspaces are very weak.
08:59:27 <b_jonas> they are.
08:59:31 <mauke> pgavin: yes
08:59:35 <b_jonas> I hate that part of C++
08:59:57 <sjanssen> pgavin: it's a fundep, it means that for any 'm' there is only one 'e'
09:00:13 <wli> SamB: C essentially already has this sort of thing done by recompiling the same C file with different values of various #defines
09:00:32 <sjanssen> ie. if you know the monad, you know the type of error it deals with
09:00:41 <pgavin> ok, thanks, I'll check out google :)
09:00:42 <wli> SamB: So all it's really doin gis getting the macro preprocessor out of that process.
09:00:58 <SamB> wli: that complicates building *a lot*, though
09:01:04 <SamB> doesn't it?
09:01:22 <wli> SamB: It does. Complex makefiles are used for such purposes.
09:01:34 <SamB> also means you basically need to keep the source to everything higher-order around
09:01:55 <SamB> wli: this sounds like it might complicate building for everyone to me...
09:01:59 <wli> SamB: There is also an alternative idiom of #including C files, and shoving code in headers that requires certain macros to be defined.
09:02:20 <SamB> but I suppose as a kernel hacker you selfishly just want to make your own life easier ;-P
09:02:47 <wli> SamB: No, the compiler does all the work. No one sees a difference whether they use it or not.
09:03:06 <wli> SamB: It essentially boils down to an analogue of precompiled headers.
09:03:23 <SamB> ah.
09:03:34 <SamB> not GCC's lame ones, though
09:04:12 <wli> It's an analogue; gcc's "lame ones" are essentially most of what all can be done for C on that front.
09:04:26 <SamB> eh?
09:04:28 <wli> With this "better C" there would be more done.
09:04:57 <SamB> I suppose I just think they took "precompiled" a bit literally ;-)
09:06:44 <glen_quagmire> b_jonas: <: is same as [.  int a<::> = {1,2,3}; is perfectly fine
09:07:04 <wli> SamB: Anyway, after the module system, a generic imperative language like one sees in various examples is most of what there is to it. Pointers, arrays, records, undiscriminated unions, destructive update, etc. are the same *concepts* as in C, but with the typing/semantic/syntactic constructs done in the "obviously correct" fashion.
09:07:11 <b_jonas> glen_quagmire: yep, that's the solution for one of the two questions
09:07:26 <glen_quagmire> int a<::>  = <% 1,2,3 %>;   so much html goodness
09:07:36 <b_jonas> "html" lol
09:07:48 <mauke> what, digraphs are html now?
09:08:13 <b_jonas> mauke: no but <% %> looks like some html templating stuff
09:08:15 <wli> SamB: First-order. Monomorphic. etc. Just like C, only done the sound way.
09:09:06 <SamB> now I can certainly see benefits here...
09:09:08 <mauke> bonus question: why is '#define not(x) !foo(x)' a parse error?
09:09:14 <SamB> in terms of code re-use and so on
09:09:31 <SamB> but I fail to see what errors it'd prevent
09:09:47 <wli> SamB: Look at the header disasters in the Linux kernel if you want to see why C so desperately needs a module system.
09:09:57 <SamB> hmm.
09:10:15 <SamB> you mean all those damn macros?
09:11:16 <wli> SamB: Worse. Unintended ordering dependencies, longstanding unintended entanglements between definitions that shouldn't be in the same header, single headers dragging in vast numbers of other, unrelated ones, etc.
09:11:28 <SamB> ah
09:13:08 <b_jonas> mauke: because it's a reserved word?
09:13:18 <b_jonas> no that's not eoungh
09:13:24 <mauke> ah, but the preprocessor doesn't care about keywords
09:13:35 <wli> SamB: There are a lot of saner alternative design decisions one can take along the way in the non-module language that prevent errors, like array/pointer and other conversion rules multidimensional array handling rules, getting rid of implicit coercion, etc.
09:13:36 <b_jonas> because it's a reserved word that gots changed by the preprocessor to !
09:13:52 <mauke> in other words, an operator symbol
09:13:58 <wli> SamB: Also hygienic macros for whatever standard preprocessing is to be done.
09:14:00 <mauke> 'not' is not an identifier in C++
09:14:29 <wli> SamB: Perhaps even integrating the macro preprocessing so that macros are scoped within modules.
09:14:46 <wli> SamB: (Scoping of macros being something of a major issue.)
09:14:51 <ricky_clarkson> ""not" cannot be used as a macro name as it is an operator in C++"
09:15:07 <mauke> this leads us to the next question: what's the most useless a) header b) keyword in C++?
09:15:11 <b_jonas> so what about the other question in the puzzle :)
09:15:16 <olsner> in VC++, the 'not' et al operator names are implemented as macros in a header file
09:15:17 <b_jonas> mauke: and?
09:15:31 <mauke> b_jonas: no
09:15:39 <b_jonas> "not" then
09:16:01 <mauke> no, those are useful if you don't have the symbols on your keyboard or whatever
09:16:17 <b_jonas> no no, you may not have | on your keyboard if you use 646 but you do have !
09:16:25 <mauke> (and they're not really keywords)
09:16:44 <b_jonas> so it's a real keyword? then "class"
09:16:56 <mauke> class has a real effect
09:17:11 <mauke> ok, you could use struct and type 'private' everywhere, but still
09:17:26 <b_jonas> yep, or "typename" in templates.
09:17:41 <b_jonas> you're not thinking of "int" which can be omitted or replaced by "signed", right?
09:17:46 <mauke> no
09:17:52 <mauke> I'm thinking of "auto"
09:17:57 <b_jonas> oh yeah
09:18:03 <b_jonas> indeed
09:18:10 <b_jonas> though gcc has found a use for it
09:18:37 <glen_quagmire> b_jonas: if you omit ::, d will refer to something else?
09:19:26 <wli> SamB: Check out Linux' rbtree.h for an example of where the bit where shoving a bunch of code in a header is used to work around the lack of ML-like modules in C.
09:20:03 <b_jonas> glen_quagmire: yes, but what's that something else?
09:20:16 <SamB> say
09:20:49 <wli> SamB: lib/radix-tree.c does the workaround with void * and passing numerical keys derived from the elements in the caller.
09:21:04 <SamB> would this allow the c-macro-expand equivalent to actually work?
09:21:14 <wli> SamB: Possibly.
09:21:26 <wli> SamB: cpumask_t is parametrized on the constant NR_CPUS
09:21:45 <SamB> hmm.
09:22:21 <wli> SamB: It features various inlines, data types, and out-of-line functions scattered all over dependent on NR_CPUS.
09:22:54 <wli> SamB: It could be a single coherent module if there were a real module system that could take NR_CPUS as a parameter.
09:23:34 <SamB> it wouldn't be a problem if Linux only supported up to 32 CPUs ;-P
09:23:37 <wli> So the lack of a module system in C hurts -- bad. Real bad.
09:24:07 <wli> SamB: Supporting only 32 cpus was a crippling limitation that I personally removed. cpumask_t is (or originally was) my code.
09:24:18 <SamB> a joke, sorry.
09:24:43 <glen_quagmire> hrm I think it should call a::<T>::c::n() ..no i give up
09:25:28 <b_jonas> glen_quagmire: compile it then, the error message gives a valuable hint
09:25:46 <glen_quagmire> error: type "d<a>::d" is not a class template
09:26:15 <b_jonas> and in what line?
09:26:18 <glen_quagmire> arg C++ is harder than xml
09:26:35 <glen_quagmire> T::template c<d>::n(); // <-----  this line
09:26:35 <b_jonas> well this is not a C++ code you'd typically write
09:27:26 <b_jonas> yep. so what does "is not a class template" mean, where is it expecting a class template
09:27:38 <b_jonas> and what is in that place and why isn't that a class template
09:27:45 <b_jonas> those are the two questions
09:27:49 <mauke> T::c?
09:27:55 <augustss> is this #c++ ?
09:28:08 <b_jonas> no, that's not the one
09:28:14 <b_jonas> augustss: yes, http://hpaste.org/2401
09:28:35 <b_jonas> T::c is a class template as in the original expression
09:29:39 <augustss> Well, I don't know and I don't want to know.  Haskell is obscure enough for me.
09:30:02 <augustss> Actually, I do want to know why you need the space
09:30:20 <mauke> digraphs
09:30:24 <mauke> <: is [
09:30:36 <lament> :>
09:30:37 <augustss> Oh, right.  Yuck
09:30:42 <mauke> similar to how you need the space in vector<vector<T> >
09:30:47 <mauke> >> is a lexeme
09:30:57 <augustss> Yes, I know about >>
09:31:01 <b_jonas> yep, though they want to change the >> thing in C++0X
09:31:04 <augustss> I had forgotten about <:
09:31:32 <ObeLisK_12183> Hey @All.. =))
09:31:51 <ObeLisK_12183> can somebody help me? =D on this site here: www.pennergame.de/ref.php?uid=12183
09:31:54 <ObeLisK_12183> thanks =)
09:32:01 <lament> er
09:32:40 --- mode: ChanServ set +o xerox
09:32:44 <b_jonas> tell me when I should tell the answer
09:32:45 --- mode: xerox set +b *!*=ObeLisK_@*.w.pppool.de
09:32:45 --- kick: ObeLisK_12183 was kicked by xerox (xerox)
09:32:52 --- mode: xerox set -o xerox
09:32:56 <glen_quagmire> what was the link?
09:32:59 <augustss> mauke: I should have remembered <:  I invented digraphs too for the first C compiler I wrote.  My terminal only had upper case.  But I think I used <: for {
09:33:36 <SamB> augustss: did you start so long ago that you didn't have standard digraphs yet?
09:33:40 <b_jonas> augustss: lolol
09:34:03 <lament> augustss: you wrote more than one C compiler?
09:34:18 <lament> some people never learn! :)
09:34:34 <b_jonas> but anyway, the digraphs (and the C two-char operators) are well-chosen, so you rarely get their two characters next to each other by accident
09:35:03 <b_jonas> this is one of those cases, though it's not really something you'd meet in a real program often
09:35:19 <xerox> glen_quagmire: I guess that if people click it, he obtains something, because he's spamming that url everywhere on freenode, and did spam it here in the past.
09:35:43 <lament> glen_quagmire: just change the uid and click on it
09:35:53 <lament> it'll benefit some random person
09:36:07 <lament> however the site is in german so i still have no clue what's going on
09:37:42 <glen_quagmire> oh it's pyramid phishing scheme
09:37:45 <augustss> lament: I wrote one C compiler is TMS9900 assembly language.  Then I rewrote the backend of the Unix C compiler (for PDP11) to target 9900.  So I've written 1.5 C compilers.  And then some other tiny C compiler.
09:38:17 <glen_quagmire> i never wrote a compiler. i gave up while writing a parser
09:38:33 <b_jonas> I wrote toy interpreters but nothing (yet) that really worked
09:38:33 * shapr yawns
09:38:34 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
09:38:35 <augustss> SamB: This was long before C was standardized at all.  There was only one C compiler, the one for PDP-11 that came with Unix.
09:39:05 <glguy> so is it inappropriate for me to spam haskell.org in #pennergame?
09:39:27 <b_jonas> I've yet to write an interpreter that has lambdas
09:39:31 <glguy> oh, i guess that might not be his site..
09:39:35 <SamB> augustss: you really wrote the second C compiler, or the others were just not available?
09:39:44 <wli> I've only written a toy C compiler for some compiler class that generated MIPS code and avoided a number of difficult constructs. The code quality was essentially macro-assembler.
09:40:18 <mwc> hahaha, moron: http://groups.google.com/group/comp.lang.dylan/msg/26dc460a2a5b58b1 See #2, the `failed religion' of static typing, where he claims static typers loath functions like (def (square x) (* x x))
09:40:20 <lambdabot> Title: What&#39;s new in Dylan? Is it even OO? - comp.lang.dylan | Google Groups, http://tinyurl.com/3dwv9u
09:40:25 <SamB> that sounds about on par with Turbo Pascal actually
09:41:13 <augustss> SamB: So at that time there were some other C compilers brewing.  There were actually two from Bell labs already.  So I won't claim I wrote the second one.  But before the internet it was hard to find what other people did and even harder to get the software they had made.
09:41:54 <mauke> zomg you're old
09:42:57 <SamB> augustss: hey, it's still hard to find lotsa stuff people do
09:43:00 <augustss> mauke: yep :)
09:43:06 <b_jonas> wait... tiny c compiler? are you the ioccc winner?
09:43:11 <mauke> unlikely
09:43:12 <augustss> b_jonas: yes
09:43:16 <SamB> w00t
09:43:18 <lament> whoa
09:43:19 <ndm> SamB, yes! everyone should be forced to blog their work!
09:43:24 <mauke> wait
09:43:26 <SamB> that compiler was crazy
09:43:38 <augustss> SamB: well, it was tiny
09:43:47 <SamB> yes
09:44:10 <augustss> you can only do so much in 1.5K characters
09:44:18 <SamB> try again in Haskell
09:44:21 <b_jonas> actually, bellard's tcc is even more crazy
09:44:23 <mauke> ah, that one
09:44:36 <wli> Wasn't there also a quine in 7 languages simultaneously?
09:44:51 <b_jonas> wli: that's easier to write
09:44:51 <SamB> b_jonas: isn't that one proprietary?
09:44:58 <olsner> wli: yes ;-)
09:45:19 <b_jonas> SamB: the ioccc version definitely isn't, and I think the real one is free as well
09:45:33 <SamB> I meant the other one
09:45:44 <SamB> not the one of IOCCC fame
09:45:56 <augustss> I'd like to do IOCCC again some time, but it's just too much work
09:46:07 <b_jonas> SamB: http://fabrice.bellard.free.fr/tcc/
09:46:09 <lambdabot> Title: TCC : Tiny C Compiler
09:46:30 <augustss> Well, the first two programs I entered in IOCCC wasn't that much work, but the C compiler was
09:46:41 <b_jonas> I'd like to try the IOCCC too but I'm lazy.
09:46:58 <SamB> wait, what did augustss write?
09:47:21 <mauke> a bytecode interpreter
09:47:24 <augustss> SamB: One program generated prime numbers and the other printed the decimals of e.
09:47:37 <SamB> oh.
09:47:41 <augustss> Both were lazy functional programs converted to C.
09:47:48 <mauke> heh
09:47:55 <augustss> Both got a prize of some kind
09:47:57 <ddarius> augustss advocating from the get go.
09:48:04 <b_jonas> SamB: 1996/august
09:48:11 <ndm> augustss: are you responsible for digits-of-e1 in the nofib suite?
09:48:34 <augustss> ndm: the haskell version yes.  But the idea isn't mine
09:48:51 <ndm> i have digits-of-e2 going 30% faster, but e1 is 10% slower :(
09:49:11 <augustss> Oh, there are two?  Dunno which is mine
09:49:26 <ndm> e2 has "contributed by John Hughes" at the top
09:49:37 <SamB> that's a lot of line noise!
09:49:41 <b_jonas> I wondered if an entry could do all the things that the FAQ entry "Are there types of entries that are submitted so frequently that the judges get tired of them?".
09:49:51 <b_jonas> But I'm not sure it would fit in a limit
09:50:01 <lament> is IOCCC still active?
09:50:05 <olsner> b_jonas: that's an excellent idea ;-)
09:50:06 <SamB> augustss: so what tiny C compiler did you write then?
09:50:09 <lament> the last results are from 2004...
09:50:10 <augustss> lament: now and then
09:50:32 <mauke> lament: 2005 here
09:50:36 <b_jonas> lament: but the 2007 one is in the final round
09:50:44 <b_jonas> the judging that is
09:51:08 <lament> oh
09:51:50 <b_jonas> here's what it lists: maze, tic-tac-toe, solitaire/othello, primes, quine, hello world, complex state machine/table, rot13, pi or e
09:52:01 <augustss> SamB: 1996
09:52:07 <SamB> nice. augustss has a lot of copycats
09:53:30 <mauke> heh write(1,&e->b["0123456789"],
09:53:52 <mauke> that's the only part that's "immediately obvious"
09:55:17 <b_jonas> I wonder if it would all fit in the size limits
09:55:41 <lament> heh, ioccc is awesome.
09:55:46 <b_jonas> it is
09:55:58 <lament> from a .hint file: "For additional obfuscation and conciseness, 'if' means 'while'."
09:56:39 <mauke> 1984/mullender.c
09:57:40 <augustss> mauke: yes, one of my favorites
09:57:43 <wli> I wonder how many of the IOCCC submissions are written by hand anymore.
09:57:49 <b_jonas> but I'm better in perl obfus than in C
09:58:06 <mauke> I have something similar that works on x86/linux, http://mauke.ath.cx/stuff/c/hell.c
09:58:19 <wli> Is there an obfuscated Haskell competition yet?
09:58:27 <augustss> There has been a few
09:58:33 <mauke> http://www.google.de/search?q=iohcc
09:58:34 <lambdabot> Title: iohcc - Google-Suche
09:58:35 <evir> @pl automates that to a certain extent.
09:58:36 <lambdabot> (line 1, column 36):
09:58:36 <lambdabot> unexpected end of input
09:58:36 <lambdabot> expecting white space or simple term
10:01:01 <ivant> wli, I remember, the History of Haskell paper told about such competitions in early 90s
10:01:26 <augustss> Yes, I ran one then
10:01:29 <wli> ivant: Monad comprehensions probably made them a lot easier.
10:04:16 <Lamperi> hmm, reilu kaksi vuotta siitä, kun olin ysillä
10:05:17 <augustss> Hey, I recognize one word!
10:05:57 <augustss> yksi, kaksi, kolme
10:06:03 <olsner> ;-)
10:06:22 <olsner> ei saa peitt, parasta ennen, yksi, kaksi, kolme ;-)
10:06:33 <ricky_clarkson> 1, 2, 3 in some language?
10:06:38 <b_jonas> finnish, yes
10:06:41 <augustss> Finnish
10:06:52 <lament> C and Perl seem to lend themselves to obfuscations in ways that other languages don't
10:06:53 <ricky_clarkson> Yes, thought it resembled Estonian.
10:07:24 <b_jonas> lament: true
10:07:33 <mauke> lament: 2000/dlowe.c
10:08:15 <ricky_clarkson> lament: Then C (well, C++) is used by idiots to explain why things like operator overloading are bad.
10:08:33 <ivant> we can use unicode characters in sources since ghc6.6 :-)
10:08:41 <ivant> good for obfuscation
10:09:08 <wli> Is unicode Greek lambda usable in place of \ ?
10:09:10 <b_jonas> ivant: yeah. you can use them in xml and C++ as well I think, but no-one actually does that
10:09:52 <ivant> b_jonas, I use greek names in my haskell sources (so that they could correspond to my maths writings)
10:10:16 <sjanssen> wli: no, it counts as a normal lower cased character
10:10:40 <b_jonas> ivant: but written in unicode or as english names like "alpha"?
10:10:48 <ivant> in unicode, of course
10:11:14 <mrd> ivant: i tried doing that but it caused some problems
10:11:47 <mauke> :t forM_ . zip [0 ..]
10:11:49 <ray> #define λ \
10:11:50 <lambdabot> forall (m :: * -> *) b t b1. (Monad m, Num t, Enum t) => [b1] -> ((t, b1) -> m b) -> m ()
10:11:51 <ivant> mrd, it works fine unless you want to use them for infix operators
10:11:55 <ray> and use cpp
10:12:12 <ivant> this is a known bug and I ought to file a bug report agains ghc, but didn't
10:12:23 <ivant> shame on me :-)
10:12:41 <wli> I use %format with lhs2TeX on English-written names of Greek letters.
10:12:48 <ivant> s/ought to filed/ought to have filed/
10:13:22 <mrd> emacs can display lambdas in place of text, don't know about other editors
10:14:23 <ray> any emacs-complete editor can
10:14:30 <b_jonas> :)
10:14:36 <b_jonas> "emacs-complete editor"
10:14:44 <glguy> ?quote joke
10:14:44 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
10:15:22 <mrd> hm. is emacs = co-emacs?
10:15:24 <ray> any sufficiently advanced editor is indistinguishable from emacs with weird keybindings
10:15:34 <mauke> ray: wrong
10:15:44 <mauke> emacs is always detectable by its weird cursor shape
10:15:56 <mauke> assuming you run it in a terminal
10:15:58 <ivant> and by its weird keybindings :-)
10:16:05 <mauke> those are rebindable
10:16:11 <mauke> but you can't configure the cursor
10:16:14 <mrd> my emacs and vim use the same cursor
10:16:38 <ivant> what's wrong with cursor in emacs?
10:16:43 <wli> nvi is too bloated. I should write a less bloated vi.
10:16:54 <mauke> emacs switches the cursor into "very visible" mode
10:16:57 <ivant> (I've never used it, seriously, vim is my religion)
10:16:57 <mrd> may i suggest 'ed'
10:17:11 <mauke> in my case, it changes from a blinking _ to a huge blinking block
10:17:28 <ray> i just get a white block, same as everything else
10:17:32 <ivant> mrd, I had fun on some boring .NET courses by using edlin to type sources
10:17:49 <mrd> mauke: everything on my system uses the blinking block.
10:18:01 * wli prefers ex to ed as far as line editors go.
10:18:04 <mauke> try the linux text console :-)
10:18:43 <ray> guess i don't support blinking here
10:19:08 <mauke> anyway, this is hardcoded into emacs
10:19:54 <mrd> darnit. now i'm going to be thinking about cursors instead of doing work.
10:20:44 <ray> the cursor curse
10:20:53 <ivant> by the way, is there any considerable yi-userbase?
10:21:25 <b_jonas> yi?
10:21:30 <ivant> @where yi
10:21:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
10:22:06 <zipMe> @users
10:22:06 <lambdabot> Maximum users seen in #haskell: 395, currently: 389 (98.5%), active: 19 (4.9%)
10:23:26 <oerjan> what, it got reset _again_?
10:23:43 <b_jonas> If I had lots of free time, I wrote a custom editor for myself
10:24:15 <ivant> b_jonas, why not try to help to improve yi, for example? :-)
10:24:23 <byorgey> oerjan: yeah =(
10:24:47 <lelf> mauke: there's item about that in emacs/etc/PROBLEMS ;-)
10:24:51 <b_jonas> ivant: I can take a look
10:25:01 <b_jonas> but I'd like an editor that's personalized for myself completely
10:25:05 <b_jonas> not a popular editor
10:25:27 <ivant> b_jonas, yi is not very popular yet :-)
10:25:34 <ivant> as far as I can see
10:25:42 <b_jonas> sure
10:25:46 <b_jonas> that's not really enough though
10:26:38 <b_jonas> I could tell what exactly I'd like from an editor but that would be flame so I won't do on this channel
10:26:58 <ricky_clarkson> b_jonas: I wrote a basic 'IDE' in Java in a couple of hours once (and then spent an entire semester getting students to do the same).
10:27:07 <ivant> b_jonas, there is #haskell-blah for that
10:27:22 <b_jonas> ivant: if you're interested...
10:27:59 <ivant> b_jonas, if it has some ideas which may improve the way I edit texts, then sure :-)
10:28:24 <b_jonas> no, not really
10:28:48 * wli wants no surprises. No fluff. etc.
10:32:14 <oerjan> > 0 == (-0.0)
10:32:16 <lambdabot>  True
10:33:07 <oerjan> > isNegativeZero (0 + (-0.0))
10:33:09 <lambdabot>  True
10:33:19 <oerjan> > isNegativeZero ((-0.0) + 0)
10:33:21 <lambdabot>  True
10:36:54 <mauke> > let x = 0 + (-0.0) in (x == 0, x < 0)
10:36:56 <lambdabot>  (True,False)
10:38:08 <Liskni_si> > isNegativeZero ((-0.0) + (-0.0))
10:38:10 <lambdabot>  True
10:39:18 <oerjan> > isNegativeZero 0 -- best to check
10:39:20 <lambdabot>  False
10:39:36 <olsner> > isNegativeZero (0 - 0)
10:39:37 <lambdabot>  False
10:42:41 <augustss> Floating point is just weird :)
10:44:10 <oerjan> augustss: someone on haskell-cafe wondered whether + was actually commutative, i figured if it wasn't then negative zero would be most likely to break it, but it seems to work
10:44:45 <oerjan> > isIEEE 0.0
10:44:47 <lambdabot>  True
10:44:57 <augustss> IEEE + is commutative
10:45:03 <mrd> its associative that'll break i think
10:45:08 <mauke> > isIEEE (undefined :: Double)
10:45:10 <lambdabot>  True
10:45:10 <augustss> It's one of the few laws that hold
10:45:19 <lament> yeah, associative will break of course
10:48:46 <oerjan> :t (?f $)
10:48:48 <lambdabot> forall a b. (?f::a -> b) => a -> b
10:50:10 <oerjan> haskell has sigils like perl - (f$) means f is a function :)
10:50:41 <augustss> lol
10:50:41 <b_jonas> that's like basic then because the silgil is after the name
10:50:48 <mauke> ($f) also works
10:50:55 <oerjan> (also inspired by a haskell-cafe question)
10:51:06 <oerjan> mauke: except that is not equivalent to f
10:51:58 <mauke> *Main> ($id) + ($id) $2
10:51:58 <mauke> 4
10:52:13 <lament> ugh
10:52:25 <oerjan> eek
10:52:28 <lament> perl!!!
10:52:30 <oerjan> :t ($id)
10:52:32 <lambdabot> forall b a. ((a -> a) -> b) -> b
10:53:09 <oerjan> er, you must have added a Num instance
10:53:27 <oerjan> or two
10:53:30 <mauke> Num a => Applicative (Num a)
10:53:35 <mauke> er
10:53:39 <mauke> Num (Applicative a)
10:53:57 <lament> cheater
10:54:53 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
10:55:26 <mauke> is this thing on?
10:55:28 <lament> no
10:56:51 <mauke> it is now
10:58:25 <lament> mauke: somehow it makes perfect sense that the icon of the site is a satanic symbol
10:58:55 <mauke> it's not satanic! don't you see the cute little hearts?
10:59:01 <lament> actually i don't :)
10:59:20 <lament> well, i see tiny red blobs but i certainly don't have enough imagination to think of them as hearts :)
10:59:45 <mauke> play more gameboy games
10:59:49 <lament> No.
10:59:58 <SamB> mauke: how many bitmaps in that icon?
11:00:14 <mauke> huh?
11:00:31 <SamB> nevermind
11:00:45 * SamB was thinking it was mauke's site
11:00:51 <mauke> it is
11:00:54 <SamB> oh
11:00:57 <oerjan> what icon? i cannot find any main page.
11:00:58 <mauke> I just don't know what "how many bitmaps" means
11:01:00 <SamB> I guess you don't know .ico then
11:01:05 <SamB> ?
11:01:10 <mauke> not really
11:01:21 <mauke> all I know is "save as", select ICO
11:01:35 <lament> oerjan: a little 16x16 (probably) sign in the corner of the firefox tab.
11:01:50 <SamB> typically a .ico file will at least have 16x16 and 32x32 bitmaps
11:01:59 <SamB> sometimes they'll have them at several color depths
11:02:13 <SamB> sometimes they'll go bigger (especially lately)
11:02:22 <SamB> apparantly in Vista you can embed PNGs in them somehow
11:02:57 <mauke> the PNG version says "16 x 16, 8-bit colormap, non-interlaced"
11:03:06 <ivant> @ty ceiling
11:03:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:04:21 <SamB> those things really are too tiny at typical resolutions to make out as hearts
11:05:38 <oerjan> i don't see the icon unless i add the site to my Favorites and load it from there
11:07:36 <SamB> huh, apparantly the name POSIX was RMS's idea...
11:07:56 <fourbissime> hello there. I'm having a problem and I don't understand the error message. I'm posting the code right now on hpaste.
11:07:59 <hpaste>  fourbissime pasted "(no title)" at http://hpaste.org/2402
11:08:13 <kolmodin> I'm hoping someone will take on my challange on planet.haskell.org :D
11:08:28 <fourbissime> I get something about "rigid variables" and I don't know what it is.
11:08:46 <mauke> ah
11:08:53 <oerjan> fourbissime: would be nice to have the full error message too
11:08:55 <ivant> > 1/3 - (1- (sqrt 2)/2)
11:08:56 <Cale> fourbissime: can you paste the error too?
11:08:57 <lambdabot>  4.044011451988084e-2
11:08:58 <mauke> the type of nodes is impossible
11:09:02 <SamB> fourbissime: I think it means a type variable that needs to be kept polymorphic
11:09:10 <mauke> nodes :: (Topo a) => a -> [n]
11:09:15 <ivant> > 1/6 - (1- (sqrt 2)/2)
11:09:17 <lambdabot>  -0.12622655214678583
11:09:27 <fourbissime> i'm doing it now.
11:09:27 <mauke> i.e. given a Topo thingy, it can return a list of ABSOLUTELY ANYTHING
11:09:28 <SamB> I think it'd be really cool if Haskell had syntax for the other kind
11:09:35 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2402#a1
11:09:44 <Cale> ah, mauke's got it
11:09:49 <SamB> I guess _ works well enough
11:09:52 <mauke> similar for the other functions
11:10:09 <SamB> ... unless you wanted to use the same one twice
11:10:23 <oerjan> mauke: that looks like a nice use case for associative types, doesn't it?
11:10:23 <Cale> nodes :: a -> [n] means that nodes will return a list of Chars or Ints or anything you ask for.
11:10:31 <mauke> oerjan: yes
11:10:40 <Cale> Which pretty much means that it returns a list of undefined values, if anything.
11:10:54 <Cale> same for edges.
11:11:03 <fourbissime> yes.
11:11:22 <Cale> fourbissime: You need a bit more sophisticated a class to do this: you probably want:
11:11:35 <Cale> class Topo n e a | a -> n e where
11:11:38 <Cale>  ....
11:11:49 <fourbissime> hmmm ...
11:11:57 <Cale> Or else you want to make the operations look more like this:
11:12:05 <Cale> nodes :: a n e -> [n]
11:12:19 <Cale> insertNode :: n -> a n e -> a n e
11:13:11 <shapr> I want some Haskell bling... where do I get a golden lambda to hang around my neck?
11:13:15 <fourbissime> ok, I think I see what you mean - I must state explicitely that n and e are actually generic types used by a right ?
11:13:32 <Cale> fourbissime: yeah, that they're actually related to the value you pass in somehow.
11:13:40 <oerjan> shapr: shouldn't there be a wiki page for such things?
11:13:46 <lament> shapr: iirc lambda is the symbol of some american lesbian society
11:13:56 <shapr> lament: Yeah it is.. we gotta take the lambda back!
11:13:57 <shapr> Er..
11:13:58 <lament> shapr: perhaps you could buy bling from them...
11:14:09 <shapr> Whoa that would be cool.
11:14:10 <Cale> fourbissime: If you might want non-parametric graph representations, then you'll want the functional-dependency version
11:14:22 <lament> "But, why do you want this? -Well... I'm really a lesbian at heart..."
11:14:24 <shapr> I think I'd rather just share the lambda.
11:15:03 <SamB> shapr: do you think people will mistake you for a lesbian?
11:15:19 <fourbissime> Cale: not sure to understand what it means :-/ ... functional-dependency version
11:15:21 <shapr> SamB: I do look sort of butch.
11:15:29 <shapr> SamB: But I still think they won't be confused.
11:15:48 <Cale> fourbissime: "class Topo n e a | a -> n e where ..." -- this means that Topo is a class relating three type parameters
11:15:49 <SamB> I meant, do you think anyone will be stupid enough to forget that lesbians are all women ;-P
11:16:10 <Cale> and where the type 'a' determines the types 'n' and 'e' uniquely
11:16:27 <mauke> this is called a functional dependency
11:16:54 * shapr is caught in a Haskell dependency.
11:16:59 * shapr tokes on a lambda
11:17:04 <mrd> they might think you're gordon freeman if you run around with a lambda logo.
11:17:08 <Cale> Though, if all your instances are going to be polymorphic in n and e, I would recommend doing it the other way that I mentioned.
11:17:10 <shapr> @quote toke
11:17:10 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
11:17:27 <Cale> Half Life was an awesome game :)
11:17:31 <mauke> @info lambdabot
11:17:31 <lambdabot> (lambdabot)
11:17:37 <shapr> mrd: That's true. If only Half-Life were scripted with Haskell.
11:17:42 <mrd> in what other game is the protagonist a postdoc?
11:17:51 <shapr> um
11:18:00 <shapr> That's a really good point.
11:18:01 <oerjan> "toked"?
11:18:20 <shapr> oerjan: http://www.urbandictionary.com/define.php?term=toke
11:18:21 <lambdabot> Title: Urban Dictionary: toke
11:18:36 <mauke> "lexed"
11:19:27 <Cale> I've been trying to sort out a good way to base a tower-defence game on the lambda calculus. Something which would involve reducing terms to the identity map. (Though you'd need some nice graphical representation of lambda terms) :)
11:19:32 <shapr> oerjan: There's also the pun of DTs usually meaning delirium tremens or de-tox, but meaning dependent types in this case.
11:19:49 <b_jonas> Cale: there's crocodiles
11:19:53 <shapr> ooh crocodiles!
11:20:04 <Cale> b_jonas: yeah.
11:20:09 <shapr> There's also the birds.
11:20:12 <b_jonas> I'll have to find the link
11:20:32 <fourbissime> Cale: thanks for your help - I think I miss some knowledge on several things. Reading the chapter on advanced type classes in the haskell wikibook is probably the best thing for me to do right now.
11:20:41 <shapr> http://worrydream.com/AlligatorEggs/
11:20:42 <lambdabot> Title: Alligator Eggs!
11:20:50 <b_jonas> http://worrydream.com/AlligatorEggs/
11:20:50 <lambdabot> Title: Alligator Eggs!
11:20:51 <b_jonas> yep
11:20:55 <oerjan> mauke: @info is a misspelling of @undo, maybe you want @help?
11:20:57 <mrd> a game based on the lambda calculus would be a good step towards a game where the puzzles you solve are proofs
11:21:05 <shapr> That would be really cool.
11:21:17 <mrd> then we can exploit the masses to do automated theorem proving
11:21:22 <mrd> von-Ahn style
11:21:22 <b_jonas> mrd: lol
11:21:35 <lament> shoot the lambda!
11:21:44 <ivant> save Endo :-)
11:21:47 <shapr> mrd: Whoa cool!
11:21:51 <Cale> I was inspired a bit by the recent "bloons tower defense", which involves popping balloons that contain other balloons, and thought you could take that quite a bit further :)
11:24:13 <mrd> you know about the re-CAPTCHA project right?
11:24:29 <llewyenoh> what's the best way, given a string, to replace all instances of a certain character to two of that character (ie. & -> &&)?
11:24:35 <llewyenoh> my guess is probably not regex
11:25:06 <mrd> you could concatMap
11:25:08 <Cale> > "hello" >>= replicate 2
11:25:10 <lambdabot>  "hheelllloo"
11:25:10 <xerox> > concatMap subs "foo fnord" where subs 'o' = "XX"; subs x = return x
11:25:10 <lambdabot>  Parse error
11:25:24 <ivant> http://video.google.com/videoplay?docid=-8246463980976635143&total=40&start=30&num=10&so=0&type=search&plindex=3
11:25:26 <lambdabot> Title: Human Computation, http://tinyurl.com/3y5wpk
11:25:40 <llewyenoh> Cale: i only want to duplicate the & character, for instance
11:25:46 <Cale> llewyenoh: ah, okay
11:26:08 <xerox> ivant: yeah, seen that :)
11:26:15 <llewyenoh> xerox: why does that one return a parse error?
11:26:23 <Cale> > hello >>= (\x -> if x == '&' then "&&" else [x])
11:26:24 <lambdabot>   Not in scope: `hello'
11:26:30 <Cale> > "hel&lo" >>= (\x -> if x == '&' then "&&" else [x])
11:26:31 <lambdabot>  "hel&&lo"
11:26:40 <ivant> btw, there is a game which exploits human to build up some knowledge about lojban
11:26:41 <Cale> >>= is the same as concatMap
11:26:47 <Cale> So you could also write that as:
11:27:02 <lament> ivant: exploits human?
11:27:07 <Cale> > concatMap (\x -> if x == '&' then "&&" else [x]) "hel&lo"
11:27:08 <lambdabot>  "hel&&lo"
11:27:10 <xerox> lament: yeah, seen that video?
11:27:14 <lament> no...
11:27:24 <mauke> llewyenoh: can't "where" in expressions
11:27:26 <llewyenoh> ah, thanks Cale. good to know.
11:27:31 <lament> can't watch videos at work
11:27:45 <llewyenoh> ah
11:28:17 <Cale> > [x | x <- "hel&lo", n <- if x == '&' then [(),()] else [()]]
11:28:19 <lambdabot>  "hel&&lo"
11:28:20 <ivant> LojbanQuest: https://docs.google.com/View?docid=dg5wbmjw_12fjmvcm&pli=1
11:28:33 <Cale> That's probably a little obscure :)
11:28:34 <opqdonut> Cale: heh
11:28:48 <TuringTest> > let escape ('&':rest) = '&':'&':escape rest ; escape (x:xs) = x:escape xs; escape [] = [] in escape "hel&lo&"
11:28:48 <b_jonas> as for games useful like that, do you know the google image labeller thing?
11:28:49 <xerox> :)
11:28:49 <lambdabot>  "hel&&lo&&"
11:29:07 <Cale> Yeah, you could go the direct recursive route
11:29:09 <Cale> also...
11:29:19 <xerox> You can also fold.
11:29:43 <Cale> > foldr (\x y -> if x == '&' then '&' : '&' : y else x : y) [] "hel&lo&"
11:29:45 <lambdabot>  "hel&&lo&&"
11:29:57 <mrd> TMTOWTCCAN -- There's More Than One Way To Completely Confuse A Newbie
11:29:59 <Cale> > foldr (\x y -> if x == '&' then "&&" ++ y else x : y) [] "hel&lo&"
11:30:00 <lambdabot>  "hel&&lo&&"
11:30:11 <Cale> hehe
11:32:32 <conal> > foldr (\x -> if x == '&' then ("&&" ++) else (x :)) [] "hel&lo&"
11:32:33 <lambdabot>  "hel&&lo&&"
11:32:58 <BobFunk> does anybody here know about some REST webservice client implementations in Haskell?
11:37:00 <hpaste>  b_jonas pasted "minesweeper wire" at http://hpaste.org/2403
11:37:01 <BobFunk> I'm looking to write a haskell client for a webservice, for the heck of it, and am wondering if there's some implementations out there to look at for inspiration
11:37:58 <bos> can a cabal package appear in multiple categories?
11:38:11 <conal> bos: yes
11:38:11 <bos> and if so, what's the category separator in a .cabal file?
11:38:28 <bos> comma? unicode left squimble?
11:38:33 <mrd> BobFunk: you mean like XML-RPC?
11:38:48 <BobFunk> mrd: for example
11:39:05 <conal> bos: comma, i think.
11:39:32 <BobFunk> mrd: The service I want to use is a XML-RPC/REST hybrid
11:39:48 <xerox> > unfoldr (\b -> case b of ('&':xs,False) -> Just ('&',('&':xs,True)); (x:xs,_) -> Just (x,(xs,False)); ([],_) -> Nothing) ("hel&lo&",False)
11:39:49 <lambdabot>  "hel&&lo&&"
11:39:56 <conal> bos: example: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose-0.1
11:39:58 <lambdabot> http://tinyurl.com/3b8j3a
11:39:59 <mrd> BobFunk: http://haskell.org/haskellwiki/Applications_and_libraries/Web_programming
11:40:01 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/253xhy
11:40:08 <bos> conal: thanks!
11:40:27 <mauke> s/&/&&/g
11:40:40 <mauke> you silly obfuscated haskell
11:40:56 <mrd> BobFunk: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Network
11:40:58 <lambdabot> http://tinyurl.com/yqov7f
11:41:00 <conal> bos: np.  i'd assumed only one.  that's how i hear "category".
11:41:17 <BobFunk> mrd: thanks - will have a look at those
11:41:57 <conal> bos: when i asked cabal folks why not use tagging (multiple), i learned that they already do, just call it "category".  would help if the keyword were "categories" or "tags"
11:42:33 <bos> heh
11:47:10 <Cale> Actually, writing a nice looking substitution operation shouldn't be so hard in terms of the new regex library.
11:47:50 <Cale> (It's a bit annoying that the new regex library doesn't actually define one, but it certainly defines enough nice ways to access the matches and submatches.
11:51:55 <oerjan> > "hell&o&" >>= fromJust . liftM2 mplus (`lookup` [('&',"&&")]) return
11:51:57 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
11:52:01 <oerjan> bah
11:52:39 <oerjan> > "hell&o&" >>= fromJust . liftM2 mplus (`lookup` [('&',"&&")]) (return.return)
11:52:40 <lambdabot>  "hell&&o&&"
11:52:55 <llewyenoh> Cale: with the >>= (\x -> if x == '&' then "&&" else [x]) solution you gave me, how do i integrate that with: withNamedWindow (io . putStr . show)
11:53:11 <glen_quagmire> :t lookup
11:53:13 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:53:18 <llewyenoh> Cale: withNamedWindow :: (NamedWindow -> X ()) -> X ()
11:53:34 <fourbissime> Cale: thanks again. after reading the chapter on multi-paramter type classes, every gets clearer. got to go. bye !
11:53:37 <Cale> llewyenoh: It's just a string function, you could make it a separate definition
11:54:02 <llewyenoh> Cale: sure, but then how does it string together with the rest?
11:54:03 <BobFunk> need to do some MD5 digests in Haskell, so am trying to install the Data.Crypto package - but NewBinary, which I need for that, wont compile due to a failed lang-any dependency
11:54:12 <lament> hm
11:54:13 <llewyenoh> Cale: i'm not sure at what point that becomes a string
11:54:15 <BobFunk> which package do I need to grab to satisfy that one?
11:54:26 <Cale> withNamedWindow (io . putStr . duplicateAmpersand . show)
11:54:28 <Cale> ?
11:54:30 <lament> i need md5 in the program i'm writing, so i just call the shell utility :)
11:55:08 <llewyenoh> Cale: how come  withNamedWindow (io . putStr >>= (\x -> if x == '&' then "&&" else [x]) >>= show) doesn't?
11:56:36 <oerjan> llewyenoh: show doesn't return a monadic action
11:57:22 <llewyenoh> so s/>>= show/. show/?
11:57:34 <oerjan> and ignoring that, you probably meant =<< for the direction
11:58:00 <BobFunk> seems like a pretty bad copout if I need to start calling shell commands just to do an MD5
11:58:11 <llewyenoh> oerjan: for both or just the second one?
11:58:30 <oerjan> llewyenoh: you want only .'s in your case
11:59:49 <oerjan> because you are not chaining any actions - you have only one, done at the left end
12:00:18 <llewyenoh> what's the difference between an action and a (non-action?)
12:00:47 <opqdonut> actions are just something typed IO something
12:00:49 <opqdonut> in this case
12:00:50 <oerjan> that's essentially a "what are monads" question
12:00:58 <opqdonut> :t print 1
12:01:00 <lambdabot> IO ()
12:01:06 <opqdonut> :t getLine
12:01:08 <lambdabot> IO String
12:01:26 <llewyenoh> i guess i better reread the monads bit again, since i'm not getting it
12:01:40 <oerjan> or X something in your case, where X is a transformed version of IO
12:01:55 <opqdonut> oerjan: (psst, i'm simplifying)
12:02:08 <oerjan> opqdonut: he had X in his problem already
12:02:10 <opqdonut> llewyenoh: well read a few of the ubiquitous monad tutorials
12:02:14 <opqdonut> oh he had?
12:02:20 <opqdonut> ah, yes
12:02:31 <oerjan> <llewyenoh> Cale: withNamedWindow :: (NamedWindow -> X ()) -> X ()
12:02:37 <opqdonut> yeh
12:02:54 <llewyenoh> opqdonut: url?
12:03:31 <opqdonut> ?where monad
12:03:31 <lambdabot> I know nothing about monad.
12:03:40 <opqdonut> harrumph!
12:04:07 <llewyenoh> oerjan: it seems like that middle bit expects only one letter, since the compile is complaining about Char mismatch String
12:04:22 <opqdonut> http://haskell.org/haskellwiki/Monad
12:04:23 <lambdabot> Title: Monad - HaskellWiki
12:04:24 <oerjan> llewyenoh: oh lessee
12:04:25 <opqdonut> there ya go
12:04:49 <llewyenoh> thanks for the link, opqdonut
12:05:06 <oerjan> llewyenoh: yes you need to put concatMap before the parenthesis
12:05:38 <llewyenoh> right, and as Cale said, >>= is the same?
12:05:55 <opqdonut> not always
12:06:00 <opqdonut> only in the list monad
12:06:14 <oerjan> yeah, i was missing that one of the >>= was for lists, not IO actions
12:06:23 <opqdonut> think of >>= being overloaded and being concatMap for lists :)
12:06:30 <llewyenoh> ah, ok
12:06:40 <llewyenoh> so i can't use it in my case, since it's not the list monad?
12:06:51 <oerjan> actually you can
12:07:09 <llewyenoh> . and >>=?
12:07:11 <oerjan> put it before the \
12:07:26 <oerjan> inside the parenthesis
12:08:00 <llewyenoh> oerjan: oh wow, that's something i haven't seen yet
12:08:07 <llewyenoh> interesting
12:08:09 <llewyenoh> thanks for that
12:08:39 <oerjan> llewyenoh: it is perfectly possible to mix two monads in one expression if you manage to keep them straight
12:09:53 <llewyenoh> oerjan: that's when parenthesis become rather important, i imagine
12:09:58 <oerjan> putting an operator at the end of a parenthesis is called a section, btw
12:10:11 <Cale> Oh, sorry, I got up for a sec
12:10:17 <oerjan> > map (+2) [1..10]
12:10:24 <Cale> Yeah, that use of the list monad is inessential even.
12:10:26 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
12:10:34 <llewyenoh> Cale: why is that?
12:10:34 <Cale> You could just use concatMap directly
12:11:02 <llewyenoh> would that be better code?
12:11:09 <Cale> It'd be about the same
12:11:23 <oerjan> llewyenoh: it may at least help not confusing monads
12:11:46 <llewyenoh> but functionality-wise, pretty much equivalent?
12:11:49 <Cale> If your duplicateAmpersands function is separate, it shouldn't be too confusing either way
12:11:51 <oerjan> sure
12:11:55 <Cale> Exactly equivalent
12:11:57 <oerjan> @src [] >>=
12:11:58 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:12:01 <Cale> x >>= f = concatMap f x
12:12:11 <Cale> = concat (map f x)
12:12:27 <oerjan> huh, not included?
12:12:35 <mauke> = join (fmap f x)
12:12:37 <llewyenoh> ah, ok, that makes sense
12:12:48 <mauke> COINCIDENCE?
12:14:55 <dolio> @src [] (>>=)
12:14:55 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:14:59 <dylan> bah, I'm having a brain malfunction. What's it called when one defines an AST in terms of typeclasses? e.g. instance Expr e...
12:15:07 <dylan> I'm looking for the tutorial on this. :(
12:15:22 <oerjan> @src concatMap
12:15:23 <lambdabot> concatMap f = foldr ((++) . f) []
12:15:51 <llewyenoh> yeah, i see the similarity now
12:16:20 <Cale> actually, that definition of >>= seems rather silly not to use concatMap
12:16:38 <llewyenoh> why?
12:16:49 <xerox> ?src concatMap
12:16:49 <lambdabot> concatMap f = foldr ((++) . f) []
12:16:53 <xerox> that's why
12:17:15 <mrd> where is ?src being pulled from?
12:17:31 <Cale> mrd: its own database, which is mostly extracted from GHC
12:17:33 <mauke> ?where src
12:17:34 <lambdabot> I know nothing about src.
12:17:43 <Cale> It has pretty terrible definitions for some things
12:17:50 <oerjan> @help src
12:17:50 <lambdabot> src <id>. Display the implementation of a standard function
12:17:57 <Cale> I usually end up just typing out proper definitions myself
12:18:07 <Cale> like...
12:18:09 <Cale> @src foldl
12:18:10 <lambdabot> foldl f z xs = lgo z xs
12:18:10 <lambdabot>     where lgo z []     =  z
12:18:10 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:18:14 <Cale> I mean, come on.
12:18:57 <oerjan> the report uses concat (map ...) for both
12:19:48 <conal> i like concat (map ...) -- simple compositionality.  can we rely on ghc to rewrite to concatMap?
12:19:53 <Cale> Yeah, that's sensible. concatMap is a bit of a performance hack as it is.
12:20:21 <Cale> We could rely on it by adding a RULES pragma.
12:20:23 <dylan> ahah, GADT is the word I was looking for.
12:20:24 <sjanssen> concatMap is used often enough that it deserves a name
12:20:53 <oerjan> dylan: er, GADT is not the same as defining a class
12:21:00 <conal> dylan: GADTs aren't about type classes.  sure that's what you want.  i thought maybe you mean oleg-style type-level encodings.
12:21:29 <dylan> conal: no, but I quoth the thing I read ... months ago:
12:21:38 <mrd> hm didn't oleg show that with GADTs you don't need type classes?
12:21:41 <dylan> "GADT syntax. The new syntax should be very familiar to you in that it closely resembles typeclass declarations. "
12:22:16 <dylan> oerjan: same thing. I was pulling something I read, never used, and now want to play with.
12:22:18 <sjanssen> @type foldr ((:) . ?f) [] -- why have 'map' when this works perfectly well?
12:22:19 <conal> dylan: ah -- a resemblance.
12:22:20 <lambdabot> forall b a. (?f::a -> b) => [a] -> [b]
12:22:45 <sjanssen> mrd: other way around, I think
12:24:43 <dylan> interestingly, I had started writing my expression evaluator using type classes.
12:25:18 <dylan> didn't feel right, though
12:26:57 * SamB especially likes how GADTs make the types clear, and keep the type words seperated from the value words
12:28:49 <BobFunk> anybody knows which package I need to support the lang-any dependency?
12:29:24 <sjanssen> BobFunk: 'lang' is an outdated package, what are you trying to build?
12:30:32 <BobFunk> sjanssen: Data.Crypto
12:30:47 <BobFunk> sjanssen: For doing md5 digests
12:31:13 <mrd> where did you d/l, what version?
12:31:19 <sjanssen> BobFunk: this Crypto?  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto-3.0.3
12:31:26 <lambdabot> http://tinyurl.com/2z4ujp
12:31:32 <BobFunk> was trying to just do a port install hs-crypto
12:31:40 <pejo> mrd/sjanssen, are you thinking of the example with the interpreter, that only H98 was necessary for?
12:31:49 <BobFunk> but failed due to dependency of NewBinary
12:31:58 <BobFunk> so tried a port install hs-NewBinary
12:32:04 <BobFunk> and that one failed due to lang-any
12:32:29 <BobFunk> guess I'll try to download straight from hackage and install manually
12:32:30 <mrd> sounds out of date
12:32:48 <mrd> pejo: not sure.
12:33:43 <pejo> mrd, (if that was the case, my interpretation was that he said the standard motivational example for GADT's didnt' need GADT's).
12:34:11 <mrd> possible.  it's been a while.
12:35:13 <sjanssen> pejo: ISTR Oleg claiming that all uses of GADT's can be simulated with type classes
12:37:47 <BobFunk> yeah - worked with the NewBinary 0.1 from hackage
12:38:28 <swiert> sjanssen: Are you still on schedule for the TMR deadline?
12:38:34 <pejo> sjanssen, wow. Strong statement.
12:40:39 <phobes> Is there anyway to define a typeclass which require abstract pattern matching of one of its types?
12:40:56 <opqdonut> hmm?
12:41:06 <SamB> abstract pattern matching?
12:41:33 <phobes> Declaring that the type supports pattern matching
12:41:44 <phobes> and then in the instance declaration explaining how the pattern matching happens
12:42:02 <phobes> but the typeclass definitions can just use it as pattern matching
12:42:45 <phobes> This would basically take the place of making a special view type
12:43:15 <oerjan> well that sounds like just a form of views
12:43:53 <phobes> right
12:44:59 <oerjan> and i don't know that any form of views has been implemented
12:45:11 <phobes> ok
13:03:11 <BobFunk> solving Project Euler problems in Haskell is such a joy :) - solving the kind of programming I actually encounter as a programmer in Haskell is such a pain :(
13:04:20 <SimonRC> BobFunk: You are paid to program in Haskell?
13:04:35 <SamB> BobFunk: what kind of programming do you usually do?
13:04:50 <BobFunk> hehe, nopes, only doing haskell for fun
13:05:05 <BobFunk> normally do web related programming
13:05:19 <SimonRC> was that "solving (the kind of programming I actually encounter as a programmer) in Haskell" or "solving (the kind of programming I actually encounter as a programmer in Haskell)"
13:05:24 <SimonRC> ah, ok
13:05:47 <SimonRC> A simple matter of libraries
13:05:49 <SimonRC> :-0
13:05:51 <SimonRC> :-)
13:05:52 <BobFunk> yeah
13:05:56 <BobFunk> definitively
13:06:06 <Cale> Web stuff need not be a pain, but I think you'd be best off avoiding the temptation to use a database backend.
13:06:12 <SimonRC> A LINQ library would attract people, certainly
13:06:22 <Cale> (at least for the time being)
13:06:23 <SimonRC> Cale: huh? why?
13:06:37 <SimonRC> I thought DB == good
13:06:47 <Cale> Because the database libraries seem to be slightly disappointing for the time being.
13:07:03 <Cale> And most web apps don't really need that much scalability.
13:07:17 <BobFunk> Did a small guestbook with Haskell/FastCGI and postgres - the db part was not a problem
13:07:35 <Cale> You can just keep things in memory, and back them up on to disk in an arbitrary fashion.
13:08:03 <Cale> Which DB library did you use?
13:08:12 <Cale> And what did you find to be the hard part?
13:09:08 <BobFunk> what I'm finding the hard part is now that Im looking to do a little client for a webservice we use at my job
13:09:11 <BobFunk> mostly for fun
13:09:58 <BobFunk> used HDBC for the guestbook
13:10:03 <BobFunk> http://guestbook.mathias-biilmann.net/
13:10:04 <lambdabot> Title: Haskell guestbook
13:10:16 <BobFunk> worked fine
13:10:49 <Cale> So the issue is more of a social one than a language issue?
13:11:33 <BobFunk> nah - lacking libraries
13:11:36 <Heffalump> there's nothing that makes DBs really easy to use, but the stuff there is works fine with the usual pain one expects from DBs
13:11:40 <Heffalump> IMO
13:12:30 <BobFunk> now for example to get an MD5 hash I have to spend a lot of time researching - while in all mainstream languages that's something really painless
13:13:08 <BobFunk> of course it's also due to me being a haskell newbie - always makes it harder to find stuff
13:13:29 <Cale> HackageDB
13:13:50 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
13:13:53 <BobFunk> yeah - encountered the Data.Crypto package there and got it installed after a while
13:13:58 <Cale> right
13:14:08 <BobFunk> but still need to figure out how to get a hash from a string of course ;)
13:14:12 <Cale> all of those libraries install in pretty much the same way
13:15:18 <BobFunk> yeah, but you often end up doing quite a bit of depency tracking
13:15:42 <Cale> Yeah, I think cabal-install is almost ready.
13:15:49 <BobFunk> it's a shame there's still nothing like rubygems, cpan or PEAR for haskell
13:15:57 * sm cheers on cabal-install
13:15:59 <BobFunk> yeah - will be great once that's there
13:16:03 <Cale> That's what HackageDB is for.
13:16:15 <Cale> It's just that the tool support is not completely finished :)
13:17:37 <BobFunk> hehe
13:17:44 <BobFunk> and then there's the documentation of course
13:18:14 <monochrom> Examples are for tutorials.
13:18:41 <phobes> Cale:  It was you said that you thought boxing and unboxing was the main challenge in getting fast Haskell code, wasn't it?
13:19:02 <Cale> phobes: probably not
13:19:07 <phobes> ok :)
13:19:18 <Cale> I don't find that particularly hard.
13:19:51 <phobes> Cale:  What's your opinion of the most challenging aspect of getting haskell code fast?
13:20:14 <ADEpt> phobes: kepping it readable, i'd say
13:20:16 <BobFunk> Data.Digest.MD5.hash is [Octet] -> [Octet] - so need to get my string into an octet
13:20:20 <ADEpt> phobes: keeping, even
13:20:27 <BobFunk> or a list of octets rather
13:20:28 <Cale> Probably understanding the algorithm you're implementing well enough to break it up in the right way
13:20:54 <phobes> Sorry, I'm really talking about the compiler writer's job - not the programmer's
13:22:03 <Cale> Oh -- not having written a Haskell compiler, I can't really say what the hardest part of that would be.
13:22:17 <jbalint> hi
13:22:23 <phobes> hehe ok
13:22:24 <Cale> jbalint: hello
13:22:48 <Cale> phobes: I suspect that really good strictness analysis is both important and tricky.
13:22:52 <jbalint> i'm using gtk2hs and wondering if there is a way to create/maniuplate a pangolayout inside 'updateCanvas' function
13:23:17 <dcoutts> jbalint: sure, same as you'd create or modify a pango layout normally
13:23:35 <dcoutts> jbalint: did you see the new pango layout demo in the gtk2hs demo collection?
13:23:40 <xerox> BobFunk: Octet is just a type synonym for Word8, so you just need map toEnum and map fromEnum.
13:23:45 <jbalint> oh, i guess i'm in renderWithDrawable
13:23:49 <jbalint> dcoutts: no, what version?
13:24:01 <xerox> BobFunk: otherwise, see here http://www.haskell.org/crypto/doc/html/Codec-Utils.html
13:24:08 <jbalint> dcoutts: and which directory? :)
13:24:09 <BobFunk> thanks xerox :)
13:24:16 <dcoutts> jbalint: http://darcs.haskell.org/gtk2hs/demo/pango/
13:24:19 <lambdabot> Title: Index of /gtk2hs/demo/pango
13:24:26 <jbalint> ah, there is a pango dir now. i'll take a look
13:25:17 <jbalint> dcoutts: yeah, i've gotten this far, but i think i need to create/use a bunch of pango layouts in renderWithDrawable
13:25:43 <dcoutts> jbalint: ok, so create more, or modify one of the ones you created earlier
13:26:24 <jbalint> dcoutts: how do i create it? inside the Render function
13:26:53 <dcoutts> jbalint: same way you make it outside, if you're in the Render monad you'd need to use liftIO
13:27:06 <sorear> .
13:27:07 <jbalint> ah, ok. i'll take a look
13:28:01 <Saizan> @users
13:28:01 <lambdabot> Maximum users seen in #haskell: 399, currently: 394 (98.7%), active: 14 (3.6%)
13:28:11 <phobes> Cale: I was under the impression that strictness analysis (or the cost of laziness) was a major factor, but someone on this channel said he didn't think it was the case
13:28:49 <Cale> phobes: Well, generally speaking it's not that big an issue anymore, since we have pretty good strictness analysis.
13:28:52 <phobes> Cale: Ah I think it was dons...
13:29:10 <phobes> Cale: ok
13:29:11 <Cale> Also, it's not really *that* hard to understand laziness and strictness, as a programmer.
13:29:21 <Lamperi> mm
13:29:41 <phobes> Laziness is what requires boxing, right?
13:29:48 <Cale> Well, yes.
13:29:55 <phobes> Strictness analysis allows you to unbox
13:30:15 <Cale> Well, not just that.
13:30:43 <monochrom> cache locality. you can use lazy bytestring, it can read a buffer-ful a time. but it throws away and old buffer and allocates a new buffer. you wouldn't do this in C or Java. this has cache locality consequences.
13:30:46 <pejo> Can you unbox something that is too large to fit in a register?
13:30:48 <Cale> The unboxing part I would think is pretty minimal.
13:31:32 <Cale> It's the fact that leaving things as lazy when they're only used in strict ways ends up wasting memory.
13:31:55 <dcoutts> monochrom: though it's not too bad since the GC tends to recycle the same areas
13:32:26 <dcoutts> monochrom: in a simple lazy bs 'cat' we figured we were cycling through about 3 different allocated chunks
13:32:43 <sorear> Don't forget the other consequence of laziness - whole program loop fusion!
13:33:33 <sorear> A lot of programs handle large inputs badly because laziness is hard enough in those languages that programmers don't use it.
13:33:50 <phobes> sorear: true
13:34:04 <Heffalump> Haskell doesn't really help guide you to write a streaming program, though
13:34:14 <Cale> It doesn't?
13:34:15 <jbalint> dcoutts: do you have to use liftIO alot in the Render function?
13:34:41 <Heffalump> well, it doesn't complain when you don't
13:34:50 <Philippa> or let you say "I want this to be streaming", or...
13:34:50 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
13:34:52 <phobes> sorear: but it still seems to me like you need to design for laziness... it seems like it might be best to encapsulate laziness into the control structures where it's needed
13:35:15 <xerox> jbalint: we usually call values of type (Monad m) => m a a monadic action, not function. And you have to use liftIO just for lifting values of type IO a to values of type Render a.
13:35:33 <jbalint> xerox: yeah, it seems a pretty common thing to need though
13:36:01 <jbalint> would you say the "Render action" then?
13:36:01 <Cale> phobes: Either you care about performance or you don't. If you do care, it doesn't matter which language you're writing in, at some point, you're going to worry about the evaluation mechanism.
13:36:03 <xerox> jbalint: the main purpose of the Render monad is to build Render computations, and there are lots of such. The IO part is minimal.
13:36:08 <oerjan> excuse me while i use the map action...
13:36:09 <xerox> jbalint: right.
13:36:13 <monochrom> Ha, the computer complaining you are not smart enough, what a thought... :)
13:36:20 <jbalint> Ok, i see. thanks xerox
13:36:41 <oerjan> er...
13:36:42 <Cale> phobes: Of course, in strict languages which make no provisions for introducing laziness, you can't really do much about the issue than turn your whole program inside out.
13:37:03 <xerox> jbalint: you might think of values of type (Monad m) => m a of actions that when run return a value of type a, together with executing the respective monadic effects.
13:37:22 <phobes> Cale:  Agree with you of course
13:37:28 <Cale> In strict languages which *do* provide some way to get laziness, you might think to use it quite often, except that quite often the libraries are also strict.
13:37:31 <xerox> oerjan: hehe. And your crazy use of the compose action? (:
13:37:38 <jbalint> xerox: right, just not yet used to large 'do' blocks....
13:37:46 <monochrom> Dynamic programming is an example where eager programming takes more work than lazy programming to gain the same performance.
13:37:55 <oerjan> something like that.
13:38:34 <phobes> Cale:  So then can you think of any downside to programming in a strict language with express laziness and good libraries?
13:38:42 <Cale> Which means that you end up rewriting library functionality just to allow it to work with your lazy program. That's more of a social issue than a technical one, but it's still quite serious.
13:38:58 <Cale> If it's harder to write a lazy program than a strict one, people will write strict programs.
13:39:24 <Cale> And since it's only around maybe 1/4 of the code which really needs to be strict, that's not good.
13:39:51 <Cale> (1/4 is actually being pretty conservative -- I'd say it's somewhere between 1/4 and 1/8)
13:40:07 <phobes> How do you come up with that estimate?  It seems to me that 90% of the code will deal with finite data - and strict or lazy will be equivalent.  No?
13:40:23 <Cale> Laziness helps with more than infinite data.
13:40:35 <monochrom> 1M and 1G are both finite but not equivalent.
13:40:49 <ski> e.g. searching portions of a large tree
13:40:51 <phobes> Cale:  Like the UI list with 100,000 elements?
13:40:56 <Cale> sure
13:40:58 <Cale> Here's my heuristic as to where you want laziness or strictness.
13:41:21 <Cale> I'll refer to data as 'small' if it has few separately evaluable parts, and 'large' if it has many.
13:41:46 <fax> hello
13:42:02 <fax> I just found this :D
13:42:02 <fax> http://therning.org/magnus/archives/315
13:42:10 <Cale> There are 4 or 5 different possible kinds of transformations:
13:42:21 <Cale>  Small -> Small -- lazy vs. strict doesn't matter
13:42:30 <Cale>  Small -> Large -- lazy is better
13:42:53 <fax> It looks good but is there any stuff relating to calling "void print_foo(Foo f)" (without the pointer)?
13:42:55 <Cale>  Large -> Large -- lazy is better, if there's potential for streaming, otherwise the same
13:42:57 <phobes> (brb 1 min - I'll read this)
13:43:39 <Cale>  Large -> Small, where you're searching through the large structure for something, using only a subset of the parts, lazy is better
13:43:52 <Cale>  Large -> Small, where you're summarizing the whole large structure, strict is better
13:44:33 <Philippa> note that the case where you're searching is arguably Small -> Small, in that the /demanded/ data is small
13:45:02 <Philippa> but it's only that way because laziness makes it that way, strictness would be a world of pain
13:45:07 <Cale> Well, you still probably have a lazy list or something.
13:45:29 <Cale> So to the programmer it looks like a large piece of data.
13:45:43 <Cale> Even though only a small amount will actually be in memory at one time.
13:45:52 <Philippa> *nod*. Effectively laziness is turning the large to small
13:46:26 <Philippa> (this also tells you that once you know which bits're going to have to be evaluated, using strict functions on them is no loss)
13:46:55 <monochrom> What does "void print_foo(Foo f)" do in C? It copies the record. The original is not modified. The copy will be thrown away. Externally, you may as well consider the copying to have never been done. Haskell already does this. Though you pass pointers, you attempt no mutation. Same external effect.
13:47:08 <Philippa> the cases where inappropriate strictness'll kill you're more common than the ones where inappropriate laziness will, too
13:47:23 <Philippa> usually inappropriate laziness is merely somewhat painful
13:47:48 <fax> moconnor: It's a different function
13:47:53 <Cale> Inappropriate strictness requires you to turn your whole program inside out.
13:47:56 <fax> moconnor: You can't call them the same way..
13:48:15 <Cale> (or rewrite the inappropriately strict functions)
13:48:33 <b_jonas> perhaps you should write a "10 rules of when you should use lazyness" like http://www.perlmonks.com/?node_id=91080
13:48:35 <lambdabot> Title: Damian Conway's ten rules for when to use OO
13:49:02 <Philippa> Cale: I was thinking in terms of resource usage when run, but yeah, it's true from a maintenance POV too
13:49:08 <monochrom> I'm saying there is no need for "void print_foo(Foo f)" in Haskell. Therefore it is not available.
13:49:29 <phobes> Laziness is never more than some constant multiple worse than strictness, right?  But strictness can be arbitrarily bad?
13:49:30 <Cale> b_jonas: well, the answer is basically "always, except when you're collapsing a large datastructure down to something small"
13:49:56 <fax> moconnor: What if you want to call that function from a library :/
13:50:04 <fax> thats the point of the FFI
13:50:20 <Cale> phobes: If by that constant, you're referring to the implementation overhead
13:50:21 <Philippa> Cale: you can get more out of pointing out when you should use laziness instead of giving up though, or when you can use it in place of a second pass
13:50:24 <ski> fax : itym s/moconnor/monochrom/
13:50:32 <fax> oops, sorry
13:50:34 <Philippa> (personally I'm more into finding ways to write what looks like a second pass and resolves as laziness...)
13:50:39 <phobes> Cale: Yes
13:50:52 <Philippa> the second pass tends to be easier to conceptualise
13:51:13 <monochrom> OK, sorry. I think the FFI does not support that either.
13:51:21 <Philippa> actually laziness can be asypmtotically worse in space
13:51:24 <Philippa> just not in time
13:51:25 <fax> no it doesn't :(
13:51:30 <Cale> right
13:51:34 <fax> I was wondering if anything like this work here http://therning.org/magnus/archives/315
13:51:41 <fax> would be put toward something like that?
13:51:43 <monochrom> I don't think it's a loss.
13:51:47 <phobes> Philippa: right
13:51:50 <Philippa> the infamous example's the implementation of sum that's linear in list size
13:51:58 <fax> monochrom: What isn't a loss?
13:52:03 <Philippa> (that's assuming that the list being summed's already allocated)
13:52:10 <dcoutts> jbalint: I would try to avoid using liftIO a lot in Render, do the layout update bits first and then construct the picture you want to draw.
13:52:33 <Cale> hehe, in a strict language that doesn't quite happen, but you can get a similar thing happening just using recursion to simulate the lazy list.
13:52:47 <monochrom> FFI not supporting calls to "void print_foo(Foo f)" is not a loss. I wouldn't miss it.
13:53:09 <dcoutts> jbalint: what would you do if Render was pure? (and we could make it pure) you'd do the IO bits in the expose event handler but not inside the drawing bit.
13:53:11 <Philippa> Cale: yep, dual issue
13:53:20 <fax> :]
13:53:29 <fax> I could use it
13:53:36 <Cale> for example,  f k 0 = k; f k n = f (k+n) (n-1)
13:53:46 <fax> so there's nothing on the horizon relating to it then?
13:54:05 <Cale> The recursion is a virtual 'large' structure.
13:54:50 <monochrom> No.
13:55:14 <Cale> fax: sorry I haven't been following your side of the conversation, what are you looking for?
13:55:15 <Philippa> Cale: seen the papers on metamorphic programming?
13:55:23 <sorear> phobes: It's not just that laziness can be arbitrarily faster, it can be infinitely faster
13:55:25 <oerjan> only without tail call optimization...
13:55:26 <jbalint> dcoutts: ok, but it seems easier to create a pango layout and tweak it while calling showLayout in between the tweaks so i dont have to copy the same thing a bunch of times and change it
13:55:38 <Cale> Philippa: nope
13:55:45 <fax> Cale: I was wondering about any upcoming changes to haskells FFI
13:55:49 <sorear> phobes: Haskell is a sound and complete equational rewrite engine, with a few syntactic constraints
13:55:52 <Philippa> they describe how to express quicksort as "turn the list into a binary tree then flatten it" and make it run the same
13:56:16 <Cale> Philippa: sounds good :)
13:56:22 <phobes> sorear: right, lazy evaluation is safe with respect to rewrites... that's nice
13:56:35 <Philippa> it's more than nice, it enables a large class of optimisations
13:56:50 <phobes> enabling a large class of optimizations is nice :)
13:56:55 <ski> (Philippa : not in-place, i assume)
13:58:02 <Philippa> ski: it might be possible to adapt it to in-place if you have an appropriate tree representation with an array carrier
13:58:22 <ski> m
13:58:36 <Philippa> I'm not sure whether the first representation that comes to mind would work though
13:58:47 <Philippa> still, it'd be an interesting one to try hand-cranking
14:01:32 <nilton> hi. i'm learning haskell, but i can't understand the logic reasoning behind (+2), (/2), etc. i understand this as a partial application of +, /, but why it supplies the function with the its second argument instead of the first?
14:01:46 <Philippa> because if you want the first you'd write (2+)
14:01:57 <nilton> i know i can do ((/) 2) to supply the first argument
14:02:02 <Philippa> you can read (+2) as ((flip +) 2)
14:02:06 <ski> > (10/) 3
14:02:08 <lambdabot>  3.3333333333333335
14:02:16 <ski> > (/10) 3
14:02:17 <lambdabot>  0.3
14:02:20 <nilton> but how supplying the second argument first fits the model?
14:02:22 <Philippa> it's syntactic sugar
14:02:23 <oerjan> nilton: think of it as an argument missing on the operator.
14:02:36 <ski> (foo +) bar = foo + bar
14:02:36 <Philippa> nilton: see the translation I just gave
14:02:44 <ski> (+ foo) bar = bar + foo
14:02:45 <Philippa> flip f x y = f y x
14:02:45 <nilton> Philippa: i knew that already
14:02:49 <oerjan> where you would write it determines where it is applied
14:02:56 <ski> (mutatis mutandis for other operators)
14:03:01 <Philippa> nilton: so what's confusing? It's just syntax, no?
14:03:11 <oerjan> so (+2) = \x -> x+2 but (2+) = \x -> 2+x
14:03:51 <ski> (+) foo bar = foo + bar  -- so the left argument of an operator is the first, and the right is the second
14:03:56 <Choko> is there some hack for using dollar sign when using cons? like in ``n: $ euler14 $ div n 2'' instead of ``n: (euler14 $ div n 2)''
14:04:00 <nilton> Philippa: it's a strange syntax...
14:04:26 <Heffalump> (n:) $ euler14 $ div n 2
14:04:32 <ski> so, if you only provide the left, then you're providing the first argument  .. if you only provide the right, then you're providing the second one
14:04:40 <Philippa> nilton: fair enough. It's just retaining consistency with the idea that operators're used infix though
14:04:41 <Cale> (n:) . euler14 $ div n 2
14:04:48 <nilton> oerjan: i understand this (/) 2, because / has type a -> a -> a
14:04:53 <Heffalump> ugh, no, use $
14:05:06 <mauke> (n :) . euler14 . div n $ 2
14:05:06 <ski> Heffalump : why ?
14:05:10 <Choko> Cale, Heffalump ideally i don't want parentheses :)
14:05:11 <Syzygy-> (n:) . euler 14 . div n $ 2
14:05:18 <Cale> It's not necessary to use more than one $ per expression.
14:05:19 <Syzygy-> Stereo. Again.
14:05:22 <Heffalump> because using . repeatedly and then $ is horribly asymmetric
14:05:34 <Heffalump> Cale: but it's nicer to
14:05:41 <Cale> Heffalump: Using more than one $ is abusing a mistake in the spec :)
14:05:42 <Heffalump> Choko: you can't avoid those ones
14:05:51 <nilton> Philippa: does it use flip in the implementation?
14:05:52 <Heffalump> why do you claim it's a mistake?
14:05:54 <Syzygy-> Cale: What would that mistake be? *curious*
14:05:55 <Choko> then i cry :(
14:06:12 <glguy> Cale: you ought to add this explanation as a @quote
14:06:13 <mauke> Heffalump: that's like saying f x is asymmetric because f is a function but x isn't
14:06:18 <Cale> Syzygy-: ($) should be left associative
14:06:19 <glguy> Cale: so that you don't have to keep writing it out
14:06:30 <glguy> and so should $!
14:06:34 <Cale> right
14:06:34 <Philippa> nilton: I have no idea what GHC does, though I'd guess it effectively evaluates a step and just creates (\x -> x + 2) instead
14:06:36 <ski> Heffalump : i think of the '.'-chain as the main thing, and the '$ blah' part as the afterthought .. i.e. what to actually apply this one, often elidable by eta-reduction
14:06:44 <Philippa> same difference though
14:06:48 <Heffalump> what's actually happening is that you are applying lots of functions in sequence
14:06:57 <Heffalump> not composing them and then happening to apply it to a value
14:07:06 <phobes> We should also add $$, $$$, $$$$ as operators with precedence such that you never have to use parenthesis for anything
14:07:17 <Syzygy-> Cale: Making it left associative has cool effects that I know I've seen at some point, but what were they?
14:07:32 <Cale> It permits you to remove more parens, it's more natural given that application itself is left associative, and using multiple ($)'s emphasizes the value over the function, which is suboptimal for functional programming.
14:07:40 <Philippa> phobes: walk into comp.lang.lisp suggest that as a new syntax? :-)
14:07:52 <phobes> hehe :)
14:07:52 <lament> haha
14:07:54 <Dybber> haha
14:07:54 <lament> $-expressions
14:07:58 <Cale> You could write  f $ g x $ h y rather than f (g x) (h y)
14:07:59 <Choko> haha
14:08:12 <mauke> Philippa: http://mauke.ath.cx/stuff/lisp/implinest.lisp
14:08:15 <Cale> (if ($) were left associative)
14:08:29 <mauke> oh no, not again
14:08:44 <Cale> Whereas presently, you can always rewrite  f $ g $ h $ x as f . g . h $ x
14:09:05 <olsner> f x = g.h.i $ x --> f = g.h.i is easier to change in code than f x = g $ h $ i x --> f = g.h.i
14:09:14 <Cale> This has the additional advantage that it has more meaningful subexpressions, because (.) is actually an associative operator.
14:09:24 <zipme> @web93 iirc
14:09:30 <desp> > 0x10000 .&. 0xF0000
14:09:39 <glguy> if i remember/recall correctly
14:09:43 <zipme> @users
14:09:48 <desp> @bot
14:09:50 <Cale> Thus, as olsner is pointing out, it makes code easier to refactor.
14:10:06 <ski> i guess this is the argument as whether 'a ^ b ^ c' should be same as 'a ^ (b * c)' or not .. or if you will, if 'c -> b -> a' should be isomorphic(almost) to '(c,b) -> a'
14:10:10 <desp> dead bot :(
14:10:17 <sorear> zipme: it wouldn't be in marriam-webster's 1913 unabridged dictionary :)
14:10:31 <sorear> @botsnack
14:10:31 <zipme> yeah :)
14:10:38 <sorear> not again
14:10:46 <Heffalump> it's just much harder to read, cos you have to figure out that the . really means function application in this context, in terms of what the actual intention of the code was
14:10:47 <ski> i.e. should the associativity of the operator support the variant that can be expressed by another means, or the variant that can not ?
14:11:17 <zipme> sorear: yeah that's vera uh ?
14:11:31 <sorear> zipme: no, that's @web1913
14:12:05 <ski> Heffalump : you mean as opposed to module qualification separator ?
14:12:13 <desp> sorear: fix it? pwease? :C
14:12:24 <sorear> desp: fix what?
14:12:31 <desp> the bot.
14:12:51 <desp> or was that shapr?
14:13:05 <ski> mayhap you're after dons ?
14:13:14 <sorear> desp: dons is one of the openbsd team, don't expect cracking his system to be fast
14:13:20 <zipme> sorear: gee i'm a bit slow
14:13:28 <Heffalump> ski: no, as opposed to function composition
14:13:29 <sorear> @help vera
14:13:32 <desp> ah, me confused.
14:13:39 <desp> hpaste != lambdabot
14:13:48 <Heffalump> the intuition of the code is not compose f, g and h and then apply the result, it's apply h, then g, then f
14:14:01 <ski> Heffalump : oh, misread .. well, but it *does* mean composition (too)
14:14:05 <sorear> !paste
14:14:05 <hpaste> Haskell paste bin: http://hpaste.org/
14:14:07 <mauke> it is my intuition
14:14:17 <ski> Heffalump : i think that depends on the case
14:14:33 <Heffalump> yes, I accept there are cases where it does make sense. But IMO, not many.
14:14:42 <mauke> now you're thinking with pipelines!
14:14:48 <ski> Heffalump : ok, that could be ..
14:14:54 <ski> mauke :)
14:15:31 <oerjan> > [1 .. 10] -- nope
14:15:52 <oerjan> er, right, it's off to lunch
14:16:14 <Cale> Heffalump: that's only because you're thinking about it the wrong way
14:16:28 <ski> fix $ \narbacular_drop -> narbacular_drop . narbacular_drop
14:16:36 <Cale> ;)
14:16:57 <Heffalump> not at all. You are :-p
14:17:12 <pgavin> hello
14:17:21 <hpaste> hello
14:17:23 <Heffalump> function composition is simply not a fundamental operation. Function application is.
14:17:26 <Cale> This is a *functional* programming language. Composition of functions is what's important
14:17:28 <mauke> NO U
14:18:02 <Heffalump> Function composition is a nice shorthand that is often convenient when delaying certain patterns of application till later.
14:18:03 <ski> Heffalump : tell that to the category terrorists !
14:18:18 <Heffalump> map (f . g) xs makes sense. (f . g) x is just silly.
14:18:27 <mauke> no, it isn't
14:18:31 <Cale> It's not silly at all.
14:18:39 <monochrom> composition is the fundamental thing if you go pointfree.
14:18:43 <mauke> next you're telling me <x f | g is silly
14:18:46 <glguy> function application is more important, and that was why the holy space character is used for it ;)
14:18:50 <Heffalump> I have no wish to go pointless.
14:18:59 <Heffalump> it just makes things even uglier
14:19:04 <SamB> mauke: does that have something to do with vectors?
14:19:12 <mauke> SamB: no, shell scripting
14:19:13 <shapr> desp: What was shapr?
14:19:21 <SamB> oh
14:19:27 <Cale> glguy: It was also made left-associative ;)
14:19:27 <Heffalump> It can be useful in certain limited circumstances.
14:19:31 <SamB> hard to tell with names like that ;-)
14:19:33 <jedai> Heffalump: Pointless is beautiful ... as long as you stay in sane limits !
14:19:34 <Heffalump> But certainly not as the default style.
14:19:46 <glguy> Point-free.. thank you
14:19:56 <ski> shapr : mayhaps you mean "sharp" ?
14:19:57 <SamB> I want to see $ associate the other way, actually
14:19:59 <phobes> jedai: Beautiful, but pointless nonetheless :)
14:20:02 <jedai> s/Pointless/point-free/ sorry ... ^^
14:20:04 <SamB> if only so that $! can too
14:20:23 <Cale> Right, using $! is very awkward as a right-associative operator.
14:20:49 <phobes> Clearly the solution is to dump currying in favor of tuples and make function application right associative :)
14:20:50 <desp> shapr: possibly related to the maintenance of lambdabot, in my misguided imagination
14:20:54 <Cale> and so is $, for that matter, you just don't know it yet :)
14:20:57 <SamB> so I have a tendancy to use . for that reason
14:21:19 <SamB> Cale: yes, istr that being awkward too but I don't remember when or why
14:21:39 <Cale> I'm hoping if we get enough people behind the idea that multiple chained $'s is bad style, we'll actually see that come true :)
14:22:02 <shapr> desp: Oh, dons is the maintainer now
14:22:10 * Heffalump thinks this nonsense with . . . $ should be nipped in the bud before it gets out of hand :-)
14:22:27 <mauke> Heffalump: at least it looks better than $ $ $ $
14:22:32 <Cale> Heffalump: have you actually tried it?
14:22:43 <Heffalump> no, I don't want my programs to look silly..
14:22:54 <Heffalump> mauke: the $ in $ $ $ $ are all doing the same thing
14:22:58 <Heffalump> So why not use the same operator?
14:23:00 <mauke> irrelevant
14:23:07 <mauke> and no, they're not doing the same thing
14:23:11 <Heffalump> not at all, it's very relevant to the intuition of the program
14:23:14 <Cale> It actually largely looks better, and often allows you to elide a parameter from your functions
14:23:15 <mauke> a $ b $ c $ d
14:23:19 <mauke> a, b, c are functions
14:23:22 <Heffalump> yes they are, I might replace the thing at the end with another application
14:23:22 <mauke> d is an argument
14:23:33 <mauke> that meanst $ is asymmetric
14:23:39 <Heffalump> c $ d is an argument
14:23:40 <Cale> :t ($)
14:23:43 <Heffalump> no, it's right-associative.
14:23:43 <SamB> Heffalump: I am going to beat you over the head with $! until you relent
14:23:44 <phobes> technically, b, c, are arguments and functions :)
14:23:48 <Heffalump> and I know it's right-associative...
14:23:48 <Syzygy-> > ((+2) $ (*2)) 5
14:23:54 <Cale> uh, where is lambdabot?
14:23:56 <olsner> still no bot ;-)
14:23:57 <ski> ($) :: forall a b. (a -> b) -> a -> b
14:24:01 <monochrom> function application is never meant to be symmetric
14:24:06 <alexj> it would be really great if there was a haskell style guide.
14:24:26 <Heffalump> alexj: especially if the pointless mafia are kept away from it ;-)
14:24:27 <alexj> one of the main knocks against haskell is that it is really easy to write unreadable code.
14:24:35 <Heffalump> s/from/& writing/
14:24:38 <oerjan> hm... the left associative version of $! should have been !
14:24:43 <Heffalump> oerjan: yeah
14:24:50 <mauke> Heffalump: the $ style feels nonmodular
14:24:50 <SamB> Heffalump: you're going to have trouble with that now that the Haskell website is a wiki
14:24:51 <Heffalump> that would make sense
14:24:53 <sciolizer> alexj: http://urchin.earth.li/~ian/style/haskell.html
14:25:08 <SamB> alexj: that's bad?
14:25:10 <mauke> Heffalump: given a $ b $ c $ d I can't just cut b $ c from the middle and use it elsewhere
14:25:24 <SamB> in most languages you have to labour quite a bit to write code
14:25:29 <SamB> in Haskell it's easy
14:25:43 <glguy> sciolizer: that is an extremely superficial list of style issues
14:25:45 <Heffalump> mauke: true. But I don't think that really matters.
14:25:52 <sciolizer> glguy: I agree. But it's a starting point.
14:25:57 <mauke> it Just Works with .
14:25:59 <Ben`> could someone explain how the recursion in this code works?  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:26:01 <Heffalump> anyway, bed. You're all wrong. Except those of you on my side. So there.
14:26:08 <mauke> Heffalump: :-)
14:26:18 <Syzygy-> Ben`: zipWith takes two lists, and goes through item by item, and adds the items.
14:26:25 <SamB> we're all on your side, you just won't believe us
14:26:35 <Syzygy-> So zipWith (+) [1,2,3] [6,7,8] === [7,9,11]
14:26:38 <Ben`> Syzygy-: I understand that much
14:26:47 <Syzygy-> Now, fibs is defined to be a list that starts like [0,1,???]
14:26:49 <Cale> Ben`: Well, it's easy to see what the first two items in fibs are -- try computing the third
14:26:55 <sciolizer> glguy, alexj: didn't Neil Mitchell have a program which would transform non-idiomatic Haskell into idiomatic Haskell?
14:27:05 <Syzygy-> And then we take the list (tail fibs), which is [1,???], and then we apply this zipWith (+) to that pair.
14:27:08 <Cale> Well, it's the first element of zipWith (+) fibs (tail fibs)
14:27:23 <Cale> and we know that fibs starts off with 0 and 1
14:27:28 <Cale> so that looks like:
14:27:41 <stepcut> sciolizer: http://neilmitchell.blogspot.com/2006/11/dr-haskell-progress.html
14:27:44 <Cale> zipWith (+) (0:1:...) (1:...)
14:28:04 <Cale> which is equal to
14:28:12 <alexj> sciolizer: as haskell cleaner would be nice.
14:28:12 <Cale> (0+1) : zipWith (+) (1:...) (...)
14:28:23 <Ben`> do the 0 and 1 get cons'd on before zipWith starts?
14:28:25 <Cale> So the third element is 0 + 1, which is 1
14:28:37 <phobes> Ben: laziness
14:28:49 <Syzygy-> Ben`: Kinda, yeah... If I understand your question right.
14:28:56 <Ben`> ok
14:28:57 <Cale> Ben`: well, yes, because expressions are evaluated outermost-first
14:29:18 <ski> Ben` : it's like this : you throw back an '0' and an '1', then start chasing yourself, catching the items thrown back in your two hands, throw back their sum, discard the left item, pass the right to left, catch a new item, throw back sum, etc ..
14:29:41 <alexj> sciolizer: the style guide is way too minimal.  I mean stuff like: make sure that function application goes in the same direction rather than applicative in one direction and monadic in the other.
14:29:57 <Cale> http://www.haskell.org/tutorial/fig1.gif
14:30:06 <Cale> it looks like that
14:30:15 <sciolizer> alexj: What do you mean? Is =<< better than >>=?
14:30:16 <mauke> why is that a gif if it doesn't move?
14:30:24 <Cale> mauke: because it's really old
14:30:30 <Syzygy-> mauke: Just to annoy you.
14:30:31 <Ben`> ok, I get it now :)
14:30:37 <Ben`> this lazy stuff is really cool
14:30:43 <Syzygy-> Ben`: Ooooooh yes!
14:31:50 <Cale> One nice thing about lazy evaluation is that if any evaluation order will produce a result, then lazy evaluation will.
14:32:01 <Cale> (and it will produce the same result)
14:32:22 <Syzygy-> Cale: Neat.
14:32:27 <Cale> So you can do evaluation by substitution in any order that you'd like
14:32:28 <Syzygy-> Is the proof of that difficult?
14:32:29 <zipme> @src foldM
14:32:34 <mauke> if we had a bot, we could show you a list of all prime numbers
14:32:39 <Cale> Syzygy-: I don't think it's particularly difficult.
14:32:40 <phobes> Syzygy: Not really
14:32:57 <zipme> the bot is down then
14:33:04 * Syzygy- starts wondering whether that might end up carrying over to something neat in operads/PROPs/blah-theory...
14:33:07 <sciolizer> alexj: gotta run. But I think I know what you mean.
14:33:24 <alexj> sciolizer: either =<< or >>= are fine.  just don't change directions in the middle e.g.:  (foo . bar . baz) =<< bif =<< bop
14:33:50 <sciolizer> alexj: so that example would be GOOD style, right?
14:33:53 <Syzygy-> You can view an operad as a systematic way to argue about many-to-one-operations that compose associatively.
14:33:56 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs; y `mod` x /= 0] in sieve [2..]
14:33:56 <mbot>  Parse error
14:34:02 <Syzygy-> And this was the way I was taught to think about it.
14:34:02 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
14:34:05 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:34:07 <Cale> or:
14:34:20 <mauke> > nubBy (((> 1) .) . gcd) [2 ..]
14:34:20 <zipme> @src foldM
14:34:21 <mbot> foldM _ a []     = return a
14:34:21 <mbot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:34:22 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:34:24 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
14:34:25 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:34:32 <fax> :O
14:34:37 <olsner> @type \f g h -> f =<< g >>= h
14:34:39 <mbot>     precedence parsing error
14:34:39 <mbot>         cannot mix `(=<<)' [infixr 1] and `(>>=)' [infixl 1] in the same infix expression
14:34:40 <Syzygy-> That first nubBy is just SO weird.
14:34:41 <alexj> sciolizer: no that would be bad style
14:34:48 <alexj> becuase you are changing directions.
14:34:56 <ski> foldM snocM nil [    ] = return nil
14:34:57 <ski> foldM snocM nil (a:as) = do {nil' <- snocM nil a; foldM snocM nil' as}
14:35:03 <ski> zipme : something like that, iirc
14:35:03 <mauke> > nubBy(((>1).).gcd)[2..]  -- what spaces?
14:35:05 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:35:05 <sciolizer> alexj: but doesn't everything go from right to left?
14:35:15 <oerjan> ah, rampant lambdabot abstinence...
14:35:16 <phobes> What does nub stand for, anyway?
14:35:30 <Syzygy-> phobes: The kernel of the matter etc.
14:35:31 <Cale> phobes: it doesn't stand for anything
14:35:33 <Cale> it's a word
14:35:37 <Cale> look it up :)
14:35:40 <Syzygy-> There was a dictionary linked in the other day.
14:35:40 <alexj> ohyes.  sorry I am distracted.
14:35:46 * ski notices mbot
14:35:47 <sciolizer> alexj: ok
14:36:04 <zipme> @web1913 nub
14:36:05 <mbot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
14:36:05 <mbot> Nub \Nub\, v. t. [Cf. {Knob}.]
14:36:05 <mbot>    To push; to nudge; also, to beckon. [Prov. Eng.]
14:36:05 <mbot>  
14:36:05 <mbot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
14:36:06 <Cale> nub n.  3. The heart of a matter; the crux or central point of a discussion, argument, etc.
14:36:07 <mbot> [3 @more lines]
14:36:16 <Cale> (from OED)
14:36:24 <ski> @type foldM
14:36:24 <ski> @type foldl
14:36:27 <mbot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:36:29 <mbot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:36:30 <Syzygy-> Ooooh
14:36:38 <phobes> Cale: That's a terrible name :)
14:36:42 <Cale> 1974 Times 22 Oct. 14/6 The nub of the judges' difficulty lay in..the claim..that the judge had no authority in law to give a direction binding on the press.
14:36:42 <Syzygy-> @web1913 plastron
14:36:42 <mbot> *** "Plastron" web1913 "Webster's Revised Unabridged Dictionary (1913)"
14:36:42 <mbot> Plastron \Plas"tron\, n. [F. plastron breastplate, plastron, LL.
14:36:42 <mbot>    plastra a thin plate of metal. See {Plaster}.]
14:36:42 <mbot>    1. A piece of leather stuffed or padded, worn by fencers to
14:36:42 <mbot>       protect the breast. --Dryden.
14:36:44 <mbot> [9 @more lines]
14:36:53 <Syzygy-> Bugger.
14:36:54 <Syzygy-> Too long.
14:37:01 <Syzygy-> Doesn't include the meaning I know of it.
14:37:07 <ski> (ah, 'a' <-> 'x' swapped ..)
14:37:24 <ski> @more
14:37:25 <mbot>  
14:37:25 <mbot>    3. (Anc. Armor) An iron breastplate, worn under the hauberk.
14:37:25 <mbot>  
14:37:25 <mbot>    3. (Anat.) The ventral shield or shell of tortoises and
14:37:25 <mbot>       turtles. See {Testudinata}.
14:37:27 <mbot> [4 @more lines]
14:37:33 <Syzygy-> @more
14:37:33 <mbot>  
14:37:33 <mbot>    4. A trimming for the front of a woman's dress, made of a
14:37:33 <mbot>       different material, and narrowing from the shoulders to
14:37:35 <mbot>       the waist.
14:37:35 <Cale> phobes: A rose by any other name...
14:37:43 <zipme> phobes: nub = gist
14:37:46 <Cale> yay spam!
14:37:53 <Syzygy-> Wow. The male clothes meaning just isn't there.
14:38:04 * Syzygy- 'll stop with the fashion geekiness now. Sorry.
14:38:23 <phobes> I guess I can't come up with anything better
14:38:31 <phobes> removeDups is what I would have called it :)
14:38:34 * ski peers curiously at Syzygy-
14:38:41 <mauke> phobes: are you a java programmer?
14:38:42 <phobes> I guess it comes up alot though, so you want something short
14:38:44 <monochrom> "iron breastplate" is close enough to "male clothing" I presume. :)
14:38:47 <glguy> if I move my mouse fast enough, I can move it too fast for xmonad to know that a different window should have focus...
14:38:51 <glguy> I'm so speedy :)
14:38:53 <olsner> or uniq/unique like the shell tool would've worked
14:38:54 <Cale> % FactorInteger[4718940780274893021463716589479804910721974389121]
14:38:56 <phobes> mauke:  yes I know :)
14:38:57 <mbot> Cale: {{17, 1}, {151, 1}, {15797, 1}, {41609, 1}, {2796770061703696806254756721707056931, 1}}
14:39:00 <phobes> uniq would work
14:39:10 <Cale> Might as well factor some integers while mbot is here :)
14:39:13 <mauke> > [(.), liftM, fmap]
14:39:14 <mbot>        add an instance declaration for
14:39:15 <mbot>       (Show ((b -> c) -> (a -> b) -> a...
14:39:18 <Syzygy-> monochrom: Only I'll be wearing a plastron to my frockcoat at my wedding party. And then it's a peculiar kind of very wide tie that you tie in a large knot and stick a needle through.
14:39:29 <ski> @type [(.), liftM, fmap]
14:39:32 <mbot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
14:39:48 <olsner> and "it's the name of a tool for an operating system created in the 1970's" kind of is a cooler explanation
14:39:50 <oerjan> phobes: actually you don't want to use nub for efficiency
14:40:13 <Cale> Hey, sometimes nub is very efficient
14:40:35 <Cale> For example, nub xs /= xs is a very efficient way to check for duplicates.
14:40:37 <int-e> > nub [1,1..]
14:40:38 <glguy> nub is efficient for a list of one repeated element :)
14:40:42 <mbot> Terminated
14:40:56 <glguy> > take 1 $ nub [1,1..]
14:40:58 <mbot>  [1]
14:41:03 <SamB> num is most efficient on []
14:41:05 <SamB> er.
14:41:06 <SamB> nub
14:41:37 <desp> @type noob
14:41:39 <mbot> Not in scope: `noob'
14:41:43 <mauke> > nub $ replicate 3 (0/0)
14:41:43 <Syzygy-> @source nub
14:41:44 <mbot> nub not available
14:41:45 <mbot>  [NaN,NaN,NaN]
14:41:50 <Syzygy-> Awww.
14:41:55 <Syzygy-> mauke: Note this:
14:41:59 <mauke> @src nub
14:41:59 <mbot> nub = nubBy (==)
14:42:02 <Syzygy-> > (0/0) == (0/0)
14:42:04 <mbot>  False
14:42:10 <mauke> @src nubBy
14:42:11 <mbot> nubBy eq []             =  []
14:42:11 <mbot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:42:27 <Syzygy-> So ... O(n^2)?
14:42:29 <glguy> that isn't ghc's implementation though
14:42:34 <mauke> yes
14:42:43 <Syzygy-> That looks like it ends up with kinda n(n-1)/2 or something like that...
14:42:43 <desp> > let a = 0x10000 in a .&. 0xF0000 `shiftR` 16
14:42:44 <mbot>  Add a type signature
14:42:48 <desp> > let a = 0x10000 in a .&. 0xF0000 `shiftR` 16 :: Int
14:42:49 <mbot>  0
14:42:57 <desp> > let a = 0x10000 in (a .&. 0xF0000) `shiftR` 16 :: Int
14:42:59 <mbot>  1
14:43:12 <glguy> nub l                   = nub' l []		-- '
14:43:12 <glguy>   where
14:43:12 <glguy>     nub' [] _		= []			-- '
14:43:12 <glguy>     nub' (x:xs) ls				-- '
14:43:12 <glguy> 	| x `elem` ls   = nub' xs ls		-- '
14:43:14 <glguy> 	| otherwise     = x : nub' xs (x:ls)	-- '
14:43:33 <BobFunk> hmm, how do I get ghc to not choke on directions like #ifdef __GLASGOW_HASKELL__
14:43:34 <int-e> eek, tabs
14:43:36 <Olathe> 0b10000 doesn't work :|
14:43:40 <glguy> nub = nubBy (==) only in USE_REPORT_PRELUDE
14:44:09 <sjanssen> BobFunk: -cpp IIRC
14:44:17 <glguy> (the behavior is still the same, but the implementation is different)
14:44:20 <BobFunk> thanks sjanssen
14:44:21 <desp> BobFunk: {-# OPTIONS -cpp #-}
14:44:33 <monochrom> OPTIONS_GHC ?
14:44:37 <Syzygy-> glguy: Oook. I think I can see that being faster than the nubBy (==), possibly? Is it the same complexity though?
14:44:48 <desp> monochrom: yes?
14:44:54 <sjanssen> @src nubBy
14:44:54 <mbot> nubBy eq []             =  []
14:44:54 <mbot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:44:54 <glguy> Syzygy-: it optimizes for lots of repeated elements
14:44:59 <Syzygy-> glguy: Yah.
14:45:04 <monochrom> Was OPTIONS a typo?
14:45:04 <int-e> Syzygy-: `elem` is O(n) in the unsuccessful case
14:45:09 <Syzygy-> Point.
14:45:19 <glguy> but same worst case complexity
14:45:30 <desp> monochrom: no, it works
14:45:45 <SamB> desp: today, maybe
14:45:55 <monochrom> I wonder if it's deprecated
14:45:57 <desp> SamB: tomorrow, then?
14:46:00 <sjanssen> glguy: looks the same to me
14:46:10 <Syzygy-> So worst case is the same, but the worst case looks different. Right?
14:46:16 <SamB> desp: dunno
14:46:33 <zipme> @src findWithDefault
14:46:33 <mbot> Source not found. Wrong!  You cheating scum!
14:46:36 <SamB> also it might confuse other compilers
14:47:24 <glguy> sjanssen: well, then I suppose it is just an implementation efficiency detail then
14:47:24 <monochrom> Yes, OPTIONS still exists but is deprecated.
14:47:25 <sjanssen> glguy: the foldr filter thing has the same performance on lists with lots of repetitions, AFAICT
14:47:31 <desp> I'm trying to avoid all uses of OPTIONS in favor of LANGUAGE
14:48:09 <sjanssen> glguy: yeah, it looks like they expect an explicit list to be faster than the implicit 'list' of filters that will build up
14:48:10 <mauke> {-# LANGUAGE lojban #-}
14:48:16 <monochrom> The LANGUAGE one is {-# LANGUAGE CPP #-}
14:48:22 <Syzygy-> mauke: o.O
14:48:29 <desp> mauke: heh.
14:48:43 <oerjan> zipme: fromMaybe x . lookup y
14:48:49 <SamB> mauke: I'm pretty sure that isn't in Language.Haskell.Extension
14:49:02 <desp> > let a = 0x10000 in (a .&. 0xF0000) `shiftR` 16 :: CUInt
14:49:03 <mbot>   Not in scope: type constructor or class `CUInt'
14:49:12 <desp> > let a = 0x10000 in (a .&. 0xF0000) `shiftR` 16 :: Foreign.C.Types.CUInt
14:49:13 <mbot>      Not in scope: type constructor or class `Foreign.C.Types.CUInt'
14:49:17 <zipme> oerjan : thanks
14:49:32 <mauke> > let a = 0x10000 in (a .&. 0xF0000) `shiftR` 16 :: Word32
14:49:34 <mbot>  1
14:51:12 <oerjan> zipme: oh, i meant find not lookup
14:51:44 <zipme> @type find
14:51:46 <mbot> forall a. (a -> Bool) -> [a] -> Maybe a
14:53:13 <hpaste>  sjanssen pasted "the two nubs" at http://hpaste.org/2404
14:53:26 <sjanssen> glguy: that is the difference
14:54:59 <sjanssen> it actually *is* faster for some inputs
14:55:34 <sjanssen> for example, nub (concatMap (replicate 2) [1..])
14:55:48 <sjanssen> that is O(n^2) with filter, O(n) with the explicit list
14:56:08 <sjanssen> erm, both are O(n^2)
14:56:12 <sjanssen> blast
14:56:21 <augustss> But who uses nub for anything with more than 10 elements?
14:56:30 <augustss> (I have)
14:56:57 <sjanssen> okay, augustss does :)
14:57:18 <augustss> yeah, but profiling reveals is
14:57:59 <ivant> % Solve[l^2-2l a + 2a^2==0,l]
14:58:01 <mbot> ivant: {{l -> (1 - I)*a}, {l -> (1 + I)*a}}
14:59:03 <augustss> mbot?  is it for real?
14:59:26 <sorear> it's a real bot...
14:59:27 <sorear> ?
14:59:32 <Cale> augustss: yeah, I use it in #math
14:59:34 <monochrom> 1 + I is not real.
14:59:36 <ivant> answer is complex :-)
14:59:40 <augustss> Cool!
14:59:54 <augustss> I'm sure mbot is complex :)
15:00:01 <int-e> @version
15:00:01 <mbot> lambdabot 4p514, GHC 6.6 (Linux i686 2.40GHz)
15:00:01 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:00:04 <Cale> It's just lambdabot in disguise
15:00:14 <Cale> With an extra plugin or two
15:00:25 <augustss> we're all lambdabot in disguise
15:00:50 <monochrom> I am not as smart as lambdabot.
15:01:13 <ivant> I am lazier than lambdabot
15:01:14 <augustss> %Solve[x^2 == 4,x]
15:01:27 <phobes> How big is lambdabot?  (LoC)?
15:01:34 <fax> {x = 2}
15:01:39 <Cale> % Solve[x^2 == 4,x]
15:01:40 <mbot> Cale: {{x -> -2}, {x -> 2}}
15:01:42 <fax> :D
15:01:49 <fax> negative numbers don't exist :|
15:02:02 <monochrom> woah?
15:02:14 <Cale> % Integrate[Sqrt[Cos[x]],x]
15:02:16 <mbot> Cale: 2*EllipticE[x/2, 2]
15:02:39 <xerox> % EllipticE::usage
15:02:40 <mbot> xerox: "EllipticE[m] gives the complete elliptic integral E(m). EllipticE[phi, m] gives the elliptic integral of the second kind E(phi|m)."
15:02:52 <Cale> % Integrate[1/(1+x^6),x]
15:02:53 <mbot> Cale: (-2*ArcTan[Sqrt[3] - 2*x] + 4*ArcTan[x] + 2*ArcTan[Sqrt[3] + 2*x] - Sqrt[3]*Log[-1 + Sqrt[3]*x - x^2] + Sqrt[3]*Log[1 + Sqrt[3]*x + x^2])/12
15:03:05 <oerjan> @help %
15:03:06 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:03:12 <Cale> @help math
15:03:12 <mbot>  @math <expr>, Mathematica interface plugin.
15:03:21 <fax> % Solve[x+1 == 1/x, x]
15:03:23 <mbot> fax: {{x -> (-1 - Sqrt[5])/2}, {x -> (-1 + Sqrt[5])/2}}
15:03:28 <ivant> % Integrate[Exp[-x^2/2],x]
15:03:28 <xerox> phi!
15:03:29 <mbot> ivant: Sqrt[Pi/2]*Erf[x/Sqrt[2]]
15:04:01 <fax> % Solve[x^x == k, x]
15:04:03 <mbot> fax:
15:04:03 <mbot> InverseFunction::ifun: Inverse functions are being used. Values may be lost for multivalued inverses.
15:04:03 <mbot>  
15:04:03 <mbot> Solve::ifun: Inverse functions are being used by Solve, so some solutions may not be found; use Reduce for complete solution information.
15:04:03 <mbot> {{x -> Log[k]/ProductLog[Log[k]]}}
15:04:03 <augustss> % Solve [x*a == 0, x]
15:04:05 <mbot> augustss: {{x -> 0}}
15:04:07 <fax> >:|
15:04:14 <augustss> But that'w wrong
15:04:29 <phobes> Sweet - Do you have to have mathematica to use this?
15:04:36 <Cale> phobes: of course
15:04:38 <fax> POS can't solve x^x == k
15:04:40 <ivant> % Plot[Sin[1/x],{x,0,1/(2Pi)}]
15:04:41 <mbot> ivant: No (forbidden content).
15:04:45 <augustss> How do you make Mathematica generate the correct side conditions?
15:04:52 <phobes> Cale:  I figured but thought I'd ask
15:04:52 <fax> phobes: you can get Maxima free :D
15:04:59 <fax> I think its as good
15:04:59 <Cale> augustss: You could use Reduce
15:05:23 <phobes> fax: thanks, I'll check itout
15:05:26 <ddarius> Is it legal to provide this interface to Mathematica?
15:05:29 <monochrom> forbidden content? Plot[Sin[1/x],{x,0,1/(2Pi)}] is porn?
15:05:30 <Cale> > Reduce[x*a == 0, x]
15:05:30 <mbot>   Not in scope: `x'
15:05:36 <fax> phobes: I use it for infinite precision arithmetic
15:05:41 <ivant> fax, not really, unfortunately
15:05:41 <Cale> % Reduce[x*a == 0, x]
15:05:42 <mbot> Cale: a == 0 || x == 0
15:05:50 <fax> ivant: oh really, why?
15:06:04 <augustss> Cale: thanks!
15:06:24 <augustss> Cale: so how does one know when to trust Mathematica?
15:06:31 <ivant> fax, lots of things which it can't do
15:06:38 <monochrom> by knowing mathematics
15:06:38 <Cale> augustss: generally speaking, one doesn't :)
15:06:45 <augustss> Fair enough
15:06:55 <ddarius> Cale: Did #math not have some kind of bot along these lines before?
15:07:06 <monochrom> That is mbot
15:07:07 <ivant> fax, cylindrical algebraic decomposition being one of them — and it is used in lots of mathematical contexts
15:07:08 <fax> ivant: yeah..?
15:07:10 <Cale> It did, it's always been my bot :)
15:07:12 <fax> oh
15:07:13 <fax> I see :S
15:07:37 * ddarius really should at least look at #math some day.
15:08:11 <Cale> % Reduce[ForAll[M, M > 0, Exists[d, d > 0, ForAll[y, Element[{x,y}, Reals] && 0 < Abs[y-x] < d, Abs[1/(y^2-2)] > M]]], x]
15:08:12 <ivant> fax, one actually don't often use cylindrical decomposition explicitly, but it is often needed internally to implement some important functions efficiently
15:08:14 <mbot> Cale: x == -Sqrt[2] || x == Sqrt[2]
15:08:27 <fax> hm ok
15:08:44 <nilton> can i define a data type in ghci interactively?
15:08:49 <monochrom> No.
15:08:50 <Cale> nilton: no
15:09:00 <xerox> Cale: doing limits? (:
15:09:11 <Cale> nilton: Generally speaking, while using ghci, you'll want to have an editor window open alongside it.
15:09:13 * glguy wonders if you could using TH or ghc-api in ghci
15:09:28 <Cale> nilton: You can then use ":" on a line to reload your file.
15:09:44 <Cale> xerox: finding asymptotes, yeah
15:09:49 <monochrom> You could use ghc-api in ghci
15:09:59 <nilton> Cale: ok, thanks. i was trying to avoid that for simple tests...
15:11:35 <ddarius> glguy: You should be able to, but that wouldn't directly help.
15:16:11 <ski> @palomer
15:16:11 <mbot> Brump!
15:21:29 <ddarius> Cale: How often do #math denizens use @run?
15:21:42 <leo2007> how many good applications are written in haskell
15:21:54 <xerox> ddarius: never, more or less.
15:22:05 <Cale> Hmm... not much -- the haskell people who are there use it though :)
15:22:06 <ddarius> leo2007: Unknown.
15:22:07 * ski does, at times
15:22:09 <xerox> I sometimes use it, but it's really rare.
15:22:13 <phobes> leo2007 - all of them :P
15:22:32 <xerox> BTW I wrote my first comonad, woo! Happy happy
15:22:43 <leo2007> so far I know darcs, xmonad etc, anything else?
15:22:45 <ski> xerox : which ?
15:22:55 <xerox> ski: it is a cellular neural network
15:22:57 <ddarius> xerox: Unlikely.  I'm sure you've written the before unintentionally.
15:23:00 <ski> leo2007 : ghc, of course
15:23:12 <Cale> pugs
15:23:15 <xerox> More like a cellular automata for now, but evolving.
15:23:31 <Cale> (the perl 6 implementation)
15:23:43 <xerox> ddarius: I'm enjoying the next step then (:
15:23:47 <ski> xerox : maybe i could look at it some, later
15:23:48 <monochrom> xmonad is a good application in haskell
15:24:08 <ivant> xmonad is awesome
15:24:21 <leo2007> ski: but that's a compiler
15:24:27 <ski> yes ?
15:24:31 <ivant> @help run
15:24:31 <mbot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:24:32 <glguy> http://haskell.org/haskellwiki/Applications_and_libraries
15:24:46 <ski> leo2007 : are you claiming compilers aren't good ?
15:24:49 <ddarius> @where hackage
15:24:49 <mbot> http://hackage.haskell.org/trac/hackage
15:24:51 <glguy> lambdabot
15:24:52 <phobes> mathematicians teach math, haskellers write haskel compilers
15:24:56 <tizoc> does hs-plugins 0.9.10 compile with ghc 6.6 ?
15:25:05 <ddarius> glguy: Lambdabot's being a bad bot currently.
15:25:19 <glguy> ddarius: but I can suggest it as good software :)
15:25:22 <glguy> nonetheless
15:25:36 <leo2007> which compiler do you recommend for running in GNU/linux
15:25:46 <ddarius> ghc
15:25:49 <monochrom> I recommend ghc
15:25:54 <hpaste> ghc
15:26:11 <monochrom> who is this hpaste guy? :)
15:26:26 <Cale> http://www.haskell.org/haskellwiki/Applications
15:26:37 <Cale> er...
15:26:38 <Cale> http://www.haskell.org/haskellwiki/Libraries_and_tools
15:26:57 * ski goes back to his fish and apple soup
15:26:58 <phobes> quake haskell, ... how's that coming along?
15:27:00 <Cale> (Everything's actually on the second page)
15:27:08 <ski> @where frag
15:27:08 <mbot> http://www.haskell.org/haskellwiki/Frag
15:27:30 <ddarius> Liver and apple here.
15:30:12 <xerox> I must admit that the comonad laws were the only thing useful in learning comonads (-:
15:30:50 <ski> how do you mean ?
15:31:19 <liyang> Is there anything significant to ghci saying: <interactive>: <<loop>> ?
15:31:26 <xerox> Much of what the comonad mean is written in the laws. I should have put much more attention in the laws for monads as well, maybe.
15:31:42 <ski> liyang : that means that it has discovered an infinite loop
15:31:43 <liyang> I mean, I know my program will terminate. And it does. But GHCi says that nevertheless.
15:31:46 <desp> @hoogle foldM
15:31:48 <mbot> http://www.zvon.org/other/haskell/Outputmonad/foldM_f.html
15:31:48 <mbot> Title: Haskell : foldM
15:32:02 <ski> > fix id :: ()
15:32:05 <mbot>  Exception: <<loop>>
15:32:06 <liyang> ski: I think it lies.
15:32:34 <ski> xerox : ok
15:32:45 <Modius> I realize this is #haskell; but was wondering if in leaving the language mainstream anyone here had compared pure functional programming with languages such as J (APL, etc.)
15:33:02 <shapr> Joy?
15:33:02 <oerjan> liyang: it has discovered a value that cannot be evaluated because it is strict in itself
15:33:04 <Modius> It's hard to do a search on "J"
15:33:10 <ski> 'hoogle' now gives references to zvon ?
15:33:11 <fax> J programming language
15:33:13 <glguy> does ghc have a C++ mode for #includes?
15:33:26 * glguy hasn't done much with that part of the ffi
15:33:31 <shapr> Yeah, but I mean.. J is really array based, whereas Joy is stack based.. just wasn't sure what sort of languages you wanted to compare.
15:33:43 <ddarius> liyang: Sometimes I think I've outsmarted the typechecker, but I always find that it outsmarted me.
15:33:55 <shapr> Modius: From what viewpoint? array based languages vs purely functional? Or what?
15:34:05 <ddarius> @google J programming language
15:34:06 <mbot> http://en.wikipedia.org/wiki/J_programming_language
15:34:06 <mbot> Title: J (programming language) - Wikipedia, the free encyclopedia
15:34:11 <xerox> ski: mbot might have some differences from lambdabot
15:34:27 <liyang> oerjan: I'll read over the code again to see if that could arise... it does involve dozens of threads trying to kill each other though.
15:34:38 <Modius> I'm looking to understand J vs von neumann in general; but from the standpoint of comparison against the most succinct/terse "normal" type languages (of which Haskell seems closest)
15:34:46 <lament> apl seems such a brilliant failure
15:35:13 <ddarius> Modius: How does Haskell fall under von Neumann?
15:35:15 <fax> I don't think its a failure
15:35:19 <lament> (failure because i wouldn't want to use it, not because it wasn't commercially successful)
15:35:31 <Modius> ddarius:  Thanks - that piece of information also helps clarify my understanding.
15:35:36 <fax> thats a strange definition of failure...
15:35:39 <ski> ddarius : typechecker ?
15:35:53 <lament> fax: people call Joyce's Finnegans Wake a failure for pretty much the same reason
15:36:12 <lament> it's an amazing book that nobody wants to read...
15:36:33 <ddarius> ski: I know the typechecker isn't part of liyang's problem, but I don't ever feel that I've outsmarted an evaluator or vice versa.
15:36:35 <shapr> Hm, the bits of James Joyce I've read were pretty cool.
15:37:00 <shapr> But I probably read too many books anyway.
15:37:22 <ddarius> shapr: Don't worry, if you read enough the counter will overflow.
15:37:30 <ski> (ddarius,xerox : ah)
15:37:48 <shapr> ddarius: I dunno, I've been on a one book a day average since I was eleven years old or so.
15:37:59 <liyang> #haskell is a bit like Joyce sometimes
15:38:02 <ski> shapr !
15:38:14 <MoxJet> ok i need a magic pill to learn haskell :)
15:38:40 <glguy> when is it ok to leave the "header.h" out of: foreign import ccall "header.h function_name" ...
15:38:41 <ddarius> shapr: Reading papers/theses often distracts me from reading novels.  That and not having novels.
15:38:43 <glguy> ?
15:38:45 <shapr> ski: But that's mostly fiction, so it's no big deal.
15:39:04 <shapr> ddarius: Oh, I can hook you up with lots of good (legally) free sci-fi and fantasy if you want.
15:39:19 <ski> shapr : i'm more like, one fiction book every two months
15:39:23 <ddarius> shapr: You've mentioned the link before, though I don't recall it.
15:39:42 * ski 's reading Sojourn, currently
15:40:06 <shapr> Yesterday I read 1632, today I'm halfway through 1633.
15:40:26 <shapr> Most weekends I read four or six books.
15:40:54 <glguy> but not five or three so much?
15:41:12 <ski> five is right out !
15:41:13 <shapr> glguy: Nah, most series have two or three books in them, and I tend to read two series a weekend.
15:41:23 <glguy> two + three
15:41:24 <shapr> Could be five sometimes though!
15:41:25 <glguy> :-p
15:41:28 <shapr> glguy: Ok, you win!
15:41:31 <xerox> shapr: how's your story coming along?
15:41:33 <glguy> hurray!
15:41:40 <shapr> glguy++ # He's cooler than me.
15:41:40 <shapr> xerox: I got distracted.
15:41:56 <xerox> shapr: too bad :)
15:41:59 <glguy> shapr: too bad that that got counted by mbot instead :)
15:42:01 <glguy> ?karma
15:42:02 <mbot> You have a karma of 13
15:42:08 <shapr> xerox: My girlfriend and I worked on the "World Hunger" and "Cure for Cancer" series, and she submitted it for a class.
15:42:14 <glguy> ?karma-all
15:42:14 <mbot>  "dons"                108
15:42:14 <mbot>  "audreyt"              41
15:42:14 <mbot>  "lambdabot"            39
15:42:14 <mbot>  "dcoutts"              38
15:42:14 <mbot>  "Cale"                 37
15:42:16 <mbot> [608 @more lines]
15:42:26 <ski> shapr : submitted what ?
15:42:27 <fax> @more :D
15:42:27 <mbot>  "shapr"                34
15:42:27 <ddarius> The Ender's Shadow series looks like it will soon be five books long.
15:42:27 <mbot>  "sjanssen"             34
15:42:27 <mbot>  "Lemmih"               32
15:42:27 <mbot>  "int-e"                29
15:42:27 <mbot>  "xerox"                26
15:42:29 <mbot> [603 @more lines]
15:42:40 <Lemmih> Whoa, karma has been restored.
15:42:46 <joshua_> gah bot karma
15:42:49 <xerox> Lemmih: no :)
15:42:56 <glguy> Lemmih: that's a lambdabot snapshot from way back
15:43:03 <Lemmih> Oh )-:
15:43:05 <Lamperi> ?karma opqdonut
15:43:05 <mbot> opqdonut has a karma of 0
15:43:11 <glguy> Lemmih: but it was restored
15:43:17 <glguy> Lemmih: on lambdabot
15:43:22 <shapr> ski: Submitted the story.. it's in Swedish, do you want a copy?
15:43:31 <Lemmih> Let's use this snapshot and kill the current lambdabot?
15:43:37 <ski> shapr : i wondered what you meant ?
15:43:40 <xerox> shapr: ah swedish, I can't read it yet then :)
15:43:42 <glguy> Lemmih: current lambdabot is more up to date
15:43:48 * Maddas is still waiting for Steven Erikson's newer books in the A Tale of the Malazan Book of the Fallen series
15:43:53 <jedai> ddarius: How soon is soon ?
15:43:55 <glguy> Lemmih: my karma on lambdabot is > 50 , but only 13 on mbot :)
15:43:58 <ski> xerox : haven't you mastered swedish yet ?
15:44:23 <xerox> ski: not yet, no.
15:44:44 <ski> @google mastering swedish
15:44:46 <mbot> http://www.slayradio.org/mastering_swedish.php
15:44:46 <mbot> Title: :: SLAY Radio - Mastering Swedish 1 ::
15:44:56 <ski> off you go
15:45:15 <MoxJet> ?karma
15:45:15 <mbot> You have a karma of 0
15:45:30 <jedai> ?karma
15:45:30 <mbot> You have a karma of 0
15:45:31 <sorear> ?karma
15:45:31 <mbot> You have a karma of 8
15:45:32 <xerox> ski: ah, that's nice. Is it a joke or real?
15:45:41 <MoxJet> I master swedish
15:45:43 <sieni> ?karna
15:45:43 <ski> xerox : what is the difference ?
15:45:43 <mbot> You have a karma of 3
15:45:47 <sieni> ?karma
15:45:48 <mbot> You have a karma of 3
15:45:52 <shapr> ski: It's really cool.. this scientist discovers a way to make infinite amounts of "meat" by adding pretty much any plant matter to a cell culture. His boss doesn't ask questions, just sells the idea to every third world country that wants cheap food.
15:46:15 <shapr> ski: But the cell culture is human cancer cells, which causes exciting political problems.
15:46:22 <sieni> even if I misspell karma? wtf? ;-)
15:46:24 <ddarius> jedai: I haven't the foggiest.
15:46:32 <ski> shapr : not patological, then ?
15:46:41 <xerox> sieni: lambdabot corrects commands from a long time now :)
15:47:07 <jedai> ddarius: Well I hope it will be a good Card ! ^^
15:47:16 <oerjan> xerox: i noticed the other day it corrects @define to @undefine
15:47:35 <phobes> I had a tumor-dog just the other day... pretty tasty
15:47:41 <sieni> xerox: that's what we need: a default behaviour on syntax errors ^_^
15:47:52 <shapr> ski: The product is successful, but continuing research finds a way to cure all human cancer forever, with an airborne retrovirus... which would obviously bring back world hunger. But then the now-very-rich owner of the company gets cancer...
15:47:57 <xerox> oerjan: yeah, I remember seeing someone using define foo and getting an "undefined" reply, when they wanted to use let :)
15:48:00 <sm> could someone remind me how to use haskell for one-liners in the style of perl -e ?
15:48:08 <ski> shapr : so .. you were submitting an essay about the story ? .. or do you mean you wrote the story ?
15:48:11 <xerox> It cam be confuzzling (-;
15:48:32 <shapr> ski: I came up with the original idea, and my girlfriend wrote the story.
15:48:37 <ski> shapr : cool!
15:48:38 <xerox> sm: ghc -e
15:48:43 <ddarius> Why do we need to turn plant matter into "meat"?
15:48:58 <shapr> ddarius: Not all plants are edible or beneficial to humans?
15:49:03 <fax> Wow
15:49:05 <ski> shapr : what about birth control and overpopulation ?
15:49:09 <phobes> ddarius: so you can eat it if you're not a vegatarian
15:49:11 <fax> this finnagans wake thing is insane
15:49:19 <shapr> ski: Good question.
15:49:57 <xerox> sm: or maybe you mean /MSG lambdabot > expression ?
15:50:11 <sm> xerox: thanks
15:50:22 <xerox> you're welcome.
15:50:42 <Modius> " sells the idea to every third world country that wants cheap food" <--- Hahahaha
15:50:58 * ski goes food
15:51:04 <shapr> Modius: Well, it seemed like a cute plot.
15:51:14 <sm> there was a page of examples of haskell one-liners, if anyone finds it please tell it I'm looking for it
15:51:30 <shapr> sm: http://www.haskell.org/haskellwiki/Blow_your_mind
15:51:38 <glguy> yikes, giving third world countries more food sounds like a good way to have more people in those countries
15:51:41 <shapr> sm: I told you instead of it..
15:51:55 <Modius> glguy:  Worked so far
15:52:16 <Modius> The funny part was getting money from them
15:52:25 <sm> thanks shapr.. I also saw one that dealt with command line args, shell redirect issues etc.
15:52:39 <shapr> Modius: You would get lots of money from them if you sold food cheaper than the local vendors.
15:53:01 <glguy> yea for overpopulation and destroyed economies!
15:53:07 <phobes> mass starvation is great solution for overpopulation
15:53:38 <shapr> Ok, you guys tell me about some cute story plots you've come up with :-)
15:53:59 <glguy> shapr: so this scientist discovers if he puts plant matter in a cell culture
15:54:03 <lament> "A modest proposal"
15:54:04 <glguy> of cancerous cells
15:54:08 <Modius> I've got a whopper - third world country borrows money froma  bank, and eventually pays back the principal
15:54:12 <glguy> he gets mutant plant monsters
15:54:24 <glguy> that he can sell to third world countries
15:54:32 <glguy> for circuses!
15:54:41 <lament> LOL
15:54:45 <Modius> Plot #2:  Feisty young remale teacher ends up coach of a basketball team in an inner city school, and at the end, against all odds - they lose.
15:54:55 <olsner> lament: that article that proposes a new Ada-like syntax for C++?
15:55:41 <glguy> how about conservative white cop and street smart black cop spend 1 hour 30 minutes coming to grips with each others different backgrounds before learning to understand each other and solving the crime!
15:55:41 <ddarius> Those remales never follow through.
15:55:50 <lament> Modius: the sex scenes will save that one.
15:56:03 <glguy> ddarius: is a remale someone who has had two sex change operations?
15:56:07 <Modius> glguy:  Is that  original?
15:56:27 <glguy> Modius: oh, hmm, maybe not
15:56:41 * sm plays around with ghc -e 'interact ...' 
15:56:52 <Modius> Plot #4:  A young kid who wants to be grown up, and a thirty-something who wants to be young again - despite the intervention of a benevolent angel, and the presence of a strange voodoo artifact - resolve their differences without switching bodies.
15:57:10 <ddarius> interdict = interact . const
15:57:28 <sieni> Modius: wtf?
15:58:02 <phobes>  nine year old girl befriends two dogs and a cat that only she can hear speaking - they travel across the country killing hobos by train tracks
15:58:08 <fax> >   (*3) >>> (+1) $ 2
15:58:13 <mbot>  7
15:58:58 <shapr> So, I want cabal-install to support another kind of repository, a local directory with darcs repositories in it.
16:02:56 <ndm> does GHC handle dictionaries specially?
16:03:18 <ndm> i.e. does it do optimisations on something because its a dictionary, where if it was merely a tuple with higher order functions it wouldn't
16:03:50 <dons> ?users
16:03:50 <mbot> Unknown command, try @list
16:03:53 <dons> hmm
16:04:11 <dons> sorear: same thiiing again, url module failed in contextual handler: IRCRaised thread killed
16:04:30 <dons> mbot: @part #haskell
16:04:49 <ddarius> dons: Have you poked the URL module?
16:05:03 <dons> poked it?
16:05:13 <liyang> (ah hah! Found the source of those <interactive>: <<loop>>s.)
16:05:36 <dons> ?users
16:05:36 <lambdabot> Maximum users seen in #haskell: 385, currently: 367 (95.3%), active: 4 (1.1%)
16:05:37 <shapr> Ya know, lambdabot could benefit from the Daemonize module in HAppS
16:05:39 <liyang> ('twas in a mfix while I was busy spawning off threads. If anyone cares.)
16:06:46 <ski> lambadabot: @botsnack
16:07:02 <sm> how do I make ghc import modules in a command-line one-liner ?
16:07:19 <shapr> Daemonize runs main and main touches a file every five seconds. When daemonize starts up every minute, it checks the timestamp on that file. If the file is more than ten seconds old, it restarts main, if it's less than ten seconds old, it exits.
16:07:25 <xerox> sm: you fully qualify names
16:07:56 <ski> xerox : bbut .. then it might become a two-liner !
16:07:58 <sm> for example, I have MissingH installed, and I want to use it's split function, in Data.List.Utils
16:08:03 <ddarius> @botsnack
16:08:03 <lambdabot> :)
16:08:17 <shapr> @karma
16:08:17 <lambdabot> You have a karma of 38
16:08:18 <ddarius> lambdabot: Dance the lambada.
16:08:19 <shapr> yay!
16:08:20 <sm> in fact I want to have MissingH auto-imported for ever more..
16:09:07 <ski> lambadabot ought to spell-correct her own name
16:09:11 <sm> oh wow.. I see what you mean
16:09:16 <xerox> sm -package MissingH -e ' ... Data.List.Utils.split ... '
16:09:16 <sm> ghc -e 'interact $ unwords . Data.List.Utils.split "/"'  just works
16:09:24 <ski> (just like her relative sorbet)
16:09:31 <sm> thanks
16:09:35 <xerox> np.
16:09:39 <sorear> → ←↑↓ ⌫⌦^⎀⎀⎀⌫^⎀⇟⇞⌠←
16:09:57 <lament> is that APL?
16:10:07 <fax> ⌦___⌫
16:10:07 * xerox recognizes pgup and pgdown :)
16:10:38 <sorear> no, it was me accidentally inserting an enter while looking at the urxvt symbol thingies... *switches window*
16:16:29 <shapr> Is there a list of all the legal values for {-# LANGUAGE #-} ?
16:16:53 <shapr> {-# LANGUAGE MultiParameterTypeClasses #-} doesn't work.. what's the right value?
16:17:15 <oerjan> shapr: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
16:17:16 <lambdabot> http://tinyurl.com/2xjyqs
16:17:20 <glguy> shapr: Prelude> :browse Language.Haskell.Extension
16:17:51 <glguy> MultiParamTypeClasses
16:17:54 <shapr> Bah, it's MultiParamTypeClasses
16:18:00 <shapr> Why not just use the whole thing?
16:18:00 <shapr> sheez
16:18:17 <glguy> shapr: you mean *Multiple*ParameterTypeClasses?
16:18:24 <glguy> then you'd still have been wrong ;)
16:19:29 <shapr> heh, good point
16:22:21 <xerox> Cool, I can move around in the zipper, and launch a comonadic step, and the pointer is kept in place, no matter what happened to the rest of the world.
16:22:41 <xerox> Haskell is fun!  I'm heading bed, goodnight :)
16:22:47 <dcoutts> xerox: g'night :-)
16:22:47 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
16:23:07 <dcoutts> grr, lambdabot has stale messages
16:25:00 <desp> @hoogle Double
16:25:04 <lambdabot> Prelude.Double :: data Double
16:25:04 <lambdabot> Text.PrettyPrint.HughesPJ.double :: Double -> Doc
16:25:04 <lambdabot> Language.Haskell.TH.DoublePrimL :: Rational -> Lit
16:26:07 <phobes> > 1+2 $ * 3
16:26:08 <lambdabot>  Parse error
16:26:25 <phobes> ya that makes sense
16:26:27 <fax> > 1+2 $
16:26:31 <lambdabot>   parse error on input `}'
16:26:34 <fax> lol
16:26:38 <phobes> lol
16:26:51 <Choko> nice :)
16:26:53 <Choko> @users
16:26:53 <lambdabot> Maximum users seen in #haskell: 385, currently: 365 (94.8%), active: 16 (4.4%)
16:48:24 <EvilTerran> @users
16:48:24 <lambdabot> Maximum users seen in #haskell: 385, currently: 357 (92.7%), active: 9 (2.5%)
16:49:16 <lament> what?
16:49:40 <lament> that can't be right.
16:50:01 <ddarius> lament: It will fix itself in a few days or less.
16:50:04 <sorear> It's not.
16:50:19 <lament> ddarius: you mean lambdabot will get its memory back?
16:50:23 <sorear> Something is very wrong with lambdabot.
16:50:39 <sorear> Nobody knows.  Nobody is motivated to find out.
16:50:45 <ddarius> lament: No, I mean there will be 420 or more people on and it will be accurate again.
16:50:55 <dons> sorear: the url module locks up. i'm guessing blocking foreign calls or something?
16:52:25 <sorear> that can't be the only thing wrong, it wouldn't explain the crashes or the forgetfulness
16:52:41 <dons> sure it does.
16:53:01 <dons> every time it stops responding, it is due to a lock up in the url module. which means no state flushing, nothing.
16:53:05 <dons> so that's the starting point.
16:53:17 <dons> i guess you're a glass-half-empty kind of guy ;)
16:53:23 <sorear> ahem, it has threads
16:53:31 <sorear> c-j/c-k mixup
16:54:09 <sorear> but the fact that one plugin can do that much damage is disturbing.
16:54:23 <dons> its suspicious that its the one doing notable foreign calls
16:54:54 <dons> i'd guess its starting with a network timeout
16:54:58 <dons> and then something goes awry
16:57:14 * yax2 wonders what his partner would think if she stumbled across some of his google search terms such as "bottom in latex"
16:58:12 <importantshock> haha
16:58:14 <FMota> Hey guys. Would anyone be so kind as to tell my what ($) does? I'm pretty sure I've seen it somewhere and I can't find it.
16:58:23 <sorear> FMota: Suprisingly little.
16:58:24 <dons> ?src ($)
16:58:24 <lambdabot> f $ x = f x
16:58:28 <sorear> @src ($)
16:58:28 <lambdabot> f $ x = f x
16:58:30 <FMota> oh, lol.
16:58:31 <FMota> ok
16:58:44 <dons> its just application, with different precedence
16:58:47 <sorear> FMota: it's just function application, but it binds looser
16:58:48 <FMota> I was kinda hoping f $ g x = f x (g x)
16:58:50 <yaxu> { \bot } was the answer
16:59:01 <dons> ?pl f x (g x)
16:59:02 <lambdabot> f x (g x)
16:59:07 <FMota> (I mean, (f $ g) x)
16:59:10 <fax> > 2 * $ 4 + 3
16:59:10 <lambdabot>  Parse error
16:59:11 <dons> ?pl \f g x -> f x (g x)
16:59:11 <lambdabot> ap
16:59:14 <fax> >:|
16:59:23 <glguy> different precedence and the wrong associativity ;)
16:59:30 <FMota> yep
16:59:34 <dons> > (2*) $ 4+ 3
16:59:36 <lambdabot>  14
16:59:48 <desp> @src peekCString
16:59:48 <lambdabot> Source not found. My mind is going. I can feel it.
16:59:51 <FMota> the other thing I was wondering about
16:59:53 <fax> haskell!
17:00:09 <sorear> desp: the type says it all, Ptr CChar -> IO String
17:00:11 <desp> > s <- peekCString nullPtr
17:00:12 <lambdabot>  Parse error
17:00:16 <fax> is f x (g x) the same as f x $ g x
17:00:25 <desp> sorear: wondering what that does
17:00:39 <yaxu> fax: yep
17:00:56 <glguy> fax: which is the same as: ap f g
17:01:01 <FMota> well.. actually, I guess the answer is no, because you don't seem to not have a simple operator for \f g x -> f x (g x)
17:01:04 <FMota> (the S-combinator)
17:01:15 <dons> that's ap
17:01:16 <glguy> ?unpl ap f g
17:01:16 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b a))
17:01:18 <FMota> well, you have ap, then
17:01:21 <dons> ?pl \f g x -> f x (g x)
17:01:21 <lambdabot> ap
17:01:31 <dons> > ap (+1) (*2) 3
17:01:32 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
17:01:32 <lambdabot>     Probabl...
17:01:39 <dons> > ap (+) (*2) 3
17:01:41 <lambdabot>  9
17:01:52 <desp> Prelude Foreign.Ptr Foreign.C.String> s <- peekCString nullPtr
17:01:52 <desp> Bus error
17:01:54 <desp> haha.
17:02:32 <glguy> > ( (+) =<< (*2) ) 3
17:02:34 <lambdabot>  9
17:02:50 <FMota> I was thinking... you can make pure functions out of S and K
17:03:00 <FMota> (where K a b = a)
17:03:03 <ddarius> FMota: S and K are pure functions.
17:03:12 <FMota> yes, I know that
17:03:26 <FMota> I am saying, you can make any pure function out of S and K
17:03:42 <FMota> (not that it'll be very efficient, but it
17:03:45 <FMota> 's possible)
17:03:57 <glguy> FMota: see: unlambda
17:04:01 <glguy> @go unlambda
17:04:03 <lambdabot> http://www.madore.org/~david/programs/unlambda/
17:04:03 <lambdabot> Title: The Unlambda Programming Language
17:04:08 <importantshock> mmm...unlambda.
17:04:16 <FMota> thanks, but Im going to tie this into haskell, promise
17:04:50 <FMota> how would you go about adding Lisp macros to Haskell (or something of the sort)?
17:05:04 <lament> you would use liskell
17:05:09 <FMota> (where you actually operator on the functions)
17:05:10 <lament> or something of the sort :)
17:05:13 <FMota> ;)
17:05:24 <FMota> idk what liskell is,
17:05:28 <lament> FMota: in many cases, haskell functions can already do what you need macros for in lisp
17:05:33 <lament> FMota: because of the laziness
17:06:12 <glguy> FMota: it is called template haskell
17:06:17 <glguy> FMota: and you typically don't need it
17:06:27 <FMota> but you /could/ add the possibility through simple functions
17:06:43 <sorear> FMota: have you ever heard of combinatory logic and Shörnfinkel's representation?
17:06:46 <FMota> basically... you can have a function like (bla (S a b) = c)
17:07:18 <FMota> sorear: I've never heard of Shornfinkel's application, but I know what comb. logic is
17:07:24 <importantshock> lament: it seems to me like each Good Language has either macros or things that do 90% of what macros do
17:07:37 <sorear> yaxu: no latex required!  Control-Shift-22A5 in any ISO 14755 compliant editor
17:07:40 <lament> importantshock: yes, but don't tell that to Lispers
17:07:50 <fax> what
17:07:54 <olsner> is there an ISO standard for editor key combinations!?
17:07:54 <fax> syntactic abstractions?
17:08:07 <fax> or do you want soemething else
17:08:22 <sorear> olsner: apparently there IS a standard least-common-denominator input method
17:08:46 <sorear> olsner: too bad almost nobody implements it; of all the programs I use it only works in urxvt
17:09:12 <Pseudonym> So much for least-common-denominator.
17:09:12 <FMota> okay... how about a differentiation function
17:09:14 <sorear> otoh, that means it works in about 3/4 of the programs I use - ⊥
17:09:18 <EvilTerran> TH needs to be finished.
17:09:23 <Pseudonym> Quick basic linear algebra question.
17:09:29 <FMota> in lisp, you can make a macro that returns the differential of a function
17:09:30 <sorear> @go automatic differentiation
17:09:33 <lambdabot> http://www.autodiff.org/
17:09:33 <lambdabot> Title: www.Autodiff.org - Joint effort between Aachen and Argonne
17:09:38 <glguy> FMota: using lisp to automatically differentiate a lambda expression is a wonderful way to showcase brittle code
17:09:41 <Pseudonym> Is there a quick way to invert a matrix generated from the tensor product of a vector with itself?
17:09:55 <EvilTerran> it's type splicing's frustratingly incomplete, and it could really use some pattern splicing as well.
17:10:02 <lament> FMota: numerical differentiation? Why wouldn't that simply be a function?
17:10:04 <EvilTerran> i'm tempted to look into hacking it myself, actually
17:10:15 <FMota> lament: yes, you can make it a simple function
17:10:16 <EvilTerran> Pseudonym, what types are you using, here?
17:10:19 <ddarius> EvilTerran: That's what I did oh so long ago.
17:10:30 <lament> FMota: or is it symbolic differentiation?
17:10:30 <Pseudonym> EvilTerran: Unimportant.
17:10:33 <ddarius> (Back when it was GHC HEAD only)
17:10:40 <Pseudonym> I have an 8-element vector.
17:10:41 <sorear> Pseudonym: I don't think it can be done
17:10:44 <EvilTerran> ddarius, wehat, looked at hacking TH yourself?
17:10:45 <Pseudonym> Tensor product with itself.
17:10:49 <Pseudonym> Then you have an 8x8 matrix.
17:10:52 <sorear> Pseudonym: such a matrix is necessarily singular
17:10:55 <ddarius> EvilTerran: Did hack TH myself.
17:10:59 <Pseudonym> Is it?
17:11:01 <Pseudonym> ...
17:11:13 <Pseudonym> Then this paper lies.
17:11:23 <EvilTerran> ddarius, oh, right. how'd you get on? is it fairly comprehensible, then?
17:11:39 <FMota> You can do numeric differentiation through a normal function, but you can also /almost/ do it through picking parts off of the function.
17:11:54 <Pseudonym> http://academic.csuohio.edu/simond/kalmanconstrained/kalmaneq.pdf
17:12:05 <Pseudonym> Equation (35) is therefore unimplementable if D is a vector.
17:12:06 <ddarius> EvilTerran: For what I was doing, it was simple enough.  But I'm pretty sure it's been completely reworked since then.
17:12:23 <FMota> anyway
17:12:27 <EvilTerran> meh. i'll look into it in my Copious Free Time (TM)
17:12:28 <FMota> my point is not about differentiation
17:12:30 <sorear> FMota: you could just use automatic differentiation
17:12:46 <FMota> it was just an example
17:12:59 <importantshock> newbie question: does @go return the Google I'm Feeling Lucky result?
17:13:20 <sorear> yes
17:13:28 <sorear> http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
17:13:31 <lambdabot> Title: Things that amuse me, http://tinyurl.com/ypvsr2
17:13:42 <FMota> my point is that any function (\x -> y z) is the same as (ap (\x -> y) (\x -> z))
17:14:20 <FMota> and that it would be really cool if haskell allowed you to pick out the ap's and the Ks off functions.
17:15:47 <glguy> sorear: that is a cool link
17:15:54 <glguy> augustss: that is a good blog post
17:15:55 <glguy> :)
17:16:24 * EvilTerran has been thinking that some kind of automatic function inversion would be cool
17:16:40 <glguy> EvilTerran: have you seen what you can do with that in J?
17:16:42 <EvilTerran> awkward, but fun
17:16:51 <EvilTerran> i haven't, no... linky?
17:17:04 <FMota> mmhmm. And being able to pick things out would probably make that easier.
17:17:18 <fax> That's incredible
17:17:19 <glguy> my favorite examples are in the demos you can run when you install j
17:17:37 <glguy> but the idea is that every function can have an inverse (set at declaration time)
17:17:46 <glguy> and you have operators that make use of that
17:17:51 <glguy> there is an "under" function
17:17:51 <importantshock> J makes my head hurt
17:18:03 <FMota> what's J
17:18:07 <FMota> ?
17:18:09 <glguy> so you can transform a value "under" some invertable function
17:18:19 <EvilTerran> ooh
17:18:26 <glguy> you can perform a function multiple times
17:18:31 <glguy> or its inverse multiple times
17:18:37 <glguy> using the function exponentiation operator
17:18:40 <sorear> @users
17:18:40 <lambdabot> Maximum users seen in #haskell: 385, currently: 359 (93.2%), active: 13 (3.6%)
17:18:41 <EvilTerran> now, can we do this transparently in haskell with hairiness in the type system?
17:19:08 <EvilTerran> ;D
17:19:26 <FMota> make inverses in Haskell?
17:19:28 <glguy> seems you like could have a typeclass for it easily enough
17:19:31 <glguy> but
17:19:39 <glguy> you'd have to include application in the typeclass
17:20:14 <glguy> apply f (apply (inverseOf f) x)
17:20:51 <glguy> where f was some type that was an instance...
17:21:36 <glguy> or you could pass around the functions as tuples...
17:21:41 <glguy> apply = fst
17:21:44 <glguy> inverse = snd
17:21:45 <glguy> :)
17:21:58 <ddarius> invert = swap
17:22:20 <glguy> yeah.. that's probably be smarter :)
17:22:44 <FMota> or you could make a Haskell which can pick at the parts of a function, like I'm describing. ;)
17:22:54 <glguy> which would be a disaster :)
17:23:00 <FMota> probably.
17:23:09 <FMota> but it would still be transparent
17:23:27 <ddarius> Transparent macros don't fit well in Haskell in my opinion.
17:26:23 <FMota> and I love the type of the S-combinator. It's... poetic
17:26:33 <FMota> ah well.
17:26:35 <fax> :t S
17:26:35 <glguy> :-/
17:26:37 <lambdabot> Not in scope: data constructor `S'
17:26:41 <FMota> :t ap
17:26:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:26:53 <FMota> that's kinda ugly though :/
17:26:56 <fax> ap is the S combinator?
17:27:06 <sorear> yes!
17:27:06 <FMota> not sure
17:27:11 <FMota> but appraently it is
17:27:12 <sorear> and a lot more
17:27:31 <sorear> > ap (Just negate) (Just 1)
17:27:32 <lambdabot>  Just (-1)
17:27:38 <sorear> > ap (Just negate) Nothing
17:27:39 <lambdabot>  Nothing
17:27:45 <fax> oh i see
17:27:45 <sorear> > ap Nothing (Just 1)
17:27:45 <FMota> :o wow
17:27:46 <lambdabot>  Nothing
17:27:47 <fax> hm
17:27:48 <FMota> anyway
17:27:55 <sorear> @src ap
17:27:55 <lambdabot> ap = liftM2 id
17:27:58 <FMota> the type of the S-combinator is (in simple terms):
17:28:06 <FMota> (a -> b -> c) -> (a -> b) -> a -> c
17:28:41 <ddarius> Replace m with (c ->) in the above type of ap.
17:29:19 <FMota> do you mean (a ->) ?
17:29:34 <ddarius> FMota: No because a is used in the above type of ap.
17:29:48 <ddarius> But alpha rename as one sees fit.
17:29:55 <FMota> ah, well
17:30:03 <FMota> that's what I meant :). sorry to confuse.
17:41:51 <Pseudonym> Aha!
17:43:44 <Pseudonym> I had it around the wrong way.
17:44:09 <Pseudonym> D * D^T is actually an inner product, making the matrix to be inverted a scalar.
17:45:32 <Pseudonym> I can invert that pretty quickly.
17:45:51 <ddarius> Pseudonym: Relative to a matrix, yes.
17:47:21 <lament> is there some kind of a framework for event-based stuff?
17:47:24 <lament> like a game.
17:47:49 <ddarius> Functional Reactive Programming is one popular venue for that.
17:48:10 <lament> i was told it's impractical at the moment
17:48:41 <SamB> did conal tell you that?
17:48:44 <Pseudonym> I can't think of anything more impractical than writing a game.
17:48:47 <lament> and it seems more a way of life than a library :)
17:49:05 <lament> all i want to do is have some actions run in response to some events
17:49:06 <SamB> I thought NVC was the way of life
17:49:15 <ddarius> lament: Doing event-based stuff in Haskell is very straight forward.
17:49:33 <lament> ddarius: anything i could read?
17:49:48 <ddarius> There are bunches of things at various levels.
17:50:12 <ddarius> You may find Unifying Events and Threads interesting, though not precisely what you're after.
17:50:18 <ddarius> @google "Unifying Events and Threads"
17:50:21 <lambdabot> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
17:50:21 <lambdabot> Title: Unifying events and threads
17:50:39 <lament> that sounds lke.. a research paper
17:50:52 <lament> i want a howto :)
17:51:43 <lament> and ideally a library that would hide away any nasty thread stuff
17:51:48 <lament> if there needs to be any
17:51:48 <Pseudonym> lament: In Haskell, there's no distinction.
17:52:40 <lament> Pseudonym: of course there's a distinction. For example, see parsec documentation.
17:53:10 <ddarius> lament: I'm pretty sure Parsec's documentation is rather similar to the Parser combinator research papers that preceded it.
17:53:17 <ddarius> (I'd have to reread them to be sure.)
17:53:30 <lament> If i asked about what i needed to parse stuff, I could be directed to the parsec page and get everything I need
17:53:31 <mrd> uh, parsec has great docs
17:53:36 <Pseudonym> A good functional pearl reads like a howto.
17:53:58 <lament> with all that in mind, is there anything i could read on how to do event programming in haskell?
17:54:20 <ddarius> lament: Do it exactly like you'd think you would.
17:54:31 <ddarius> First class functions make it pretty straight forward.
17:55:21 <lament> ddarius: something needs to handle and dispatch on events. Is there a library that does that for me?
17:56:55 <ddarius> Parts of that are specific to what events you are handling.  I don't think there is a generic pre-packaged library to handle the remainder.
17:57:03 <ddarius> But then it would be about a page of code at most.
17:58:16 <lament> i've never coded this :(
17:58:46 <lament> should it have a stack of events, (with possibly multiple threads dropping stuff on the stack), and a single dispatcher polling the stack for events?
17:58:56 <lament> does that sound reasonable?
17:59:09 <ddarius> lament: Where are the events coming from?
17:59:51 <lament> user input, timer
18:00:23 <lament> possibly even the internet
18:01:12 <lament> plus updating the screen "whenever there's time to do so"
18:03:15 <ddarius> Depending on what I was going for, I'd probably have an event loop that pulled Events from a Chan and then just applied them to lists of "registered" functions. (At least as a try the simplest thing first.)
18:04:08 <lament> from a what?
18:04:14 <ddarius> @index Chan
18:04:14 <lambdabot> Control.Concurrent.Chan, Control.Concurrent
18:04:17 <ddarius> @index TChan
18:04:17 <lambdabot> Control.Concurrent.STM.TChan, Control.Concurrent.STM
18:05:51 <ddarius> lament: Why do you want to use an event-based system rather than a thread-based system?
18:08:47 <lament> ddarius: aren't threads a huge pain?
18:08:56 <ddarius> lament: No.
18:09:49 * shapr gwarghs
18:10:30 <lament> ddarius: could i still do everything within a StateT IO monad, with threads?
18:11:21 <ddarius> lament: One way or another, yes.
18:13:32 <Tac-Tics> what's the difference between State and ST?
18:13:54 <lament> okay, so i guess i should read "Concurrent haskell" before doing anything else
18:13:57 <lament> (yay, a research paper!)
18:14:04 <lament> thanks, one way or another
18:15:03 * shapr cheers for lament
18:15:05 <nilton> can i inspect at a function definition? that is, can i get the function definition given a symbol for that function using ghc?
18:15:24 <shapr> lament: I've often wanted to write a simple simulator in Haskell, is that what you're trying to do?
18:15:24 <lament> i'll be sure to start an events vs. threads flamewar once i finish it :)
18:15:25 <thoughtpolice> Tac-Tics: st is kind of like state on steroids.
18:15:47 <thoughtpolice> Tac-Tics: check this paper for more info, the haddock info probably won't give you what you want - http://citeseer.ist.psu.edu/launchbury94lazy.html
18:15:48 * shapr reads back in the buffer...
18:15:48 <lambdabot> Title: Lazy Functional State Threads - Launchbury, Jones (ResearchIndex)
18:15:52 <lament> shapr: "simulator" is a little vague, isn't it? :)
18:16:14 <Tac-Tics> I think I must have asked this question a few weeks ago, because I remember that answer "State on Steroids"
18:16:36 <thoughtpolice> Tac-Tics: that's the way it was described when I first read about it. :)
18:16:46 <ddarius> lament: Events are dual to threads.
18:16:46 <shapr> lament: Not really. I've just never hacked up anything that did stuff according to wall clock times, ya know?
18:17:13 <lament> shapr: most games have some kind of a clock
18:17:18 <thoughtpolice> Tac-Tics: the abstract for that linked paper should sum it up pretty good, but I would suggest the paper for more info
18:17:27 <Tac-Tics> thanks
18:17:48 <thoughtpolice> np
18:17:59 <shapr> lament: Yeah, I've just never written anything like that, but have always wondered how it would work, so it'll be cool to see what you come up with.
18:19:24 <lament> ddarius: as i understand, two threads trying to use the same resource leads to all sorts of problems that need to be resolved (i dunno how it's done in haskell). With events, all modifications to the internal state happen from within one thread, and the rest of the magic is confined to the scheduler
18:19:45 <Tac-Tics> from the sound of it, it's just a State with multiple state-holding objects?
18:20:17 <shapr> Doesn't STM handle two things trying to use the same resource?
18:20:27 <thoughtpolice> yes, it does.
18:20:47 <lament> i haven't read the paper yet :)
18:20:49 <thoughtpolice> via atomic operations.
18:21:10 <thoughtpolice> lament: the oscon presentation is really worth a look over, only about 15m long and is a good talk
18:21:18 <lament> thoughtpolice: it covers this?
18:21:25 <shapr> lament: Yeah, the STM video by SPJ is *really* great.
18:21:27 <thoughtpolice> lament: well it covers STM in general is what I mean.
18:21:46 <shapr> The only said thing is that SPJ didn't get really excited and take off his sandals and sweater.
18:21:54 <ddarius> lament: Using events you often have to break your code up unnaturally.  For example, consider wanting to respond when the user types 'a' then 'b'.
18:22:02 <shapr> SPJ has more enthusiasm than I do!
18:22:13 <thoughtpolice> i indeed like spj's writing/talking. :)
18:22:21 <lament> which video is it, the one in the topic?
18:22:23 <thoughtpolice> it's quite eloquent and down to earth, imo.
18:22:27 <thoughtpolice> lament: it's his keynote
18:22:32 <shapr> thoughtpolice: And passionate!
18:22:32 <sorear> lament: Write an event scheduler monad.  Hint: Data.Map is an optimal priority queue.
18:22:47 <thoughtpolice> shapr: quite! :)
18:22:56 <thoughtpolice> lament: http://www.blip.tv/file/317758/
18:22:58 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones
18:23:00 <ddarius> SPJ always has this crazy-eyed look.
18:23:21 <shapr> SPJ backs up his enthusiasm with decades of hard work.
18:23:42 <thoughtpolice> shapr: it's quite easy to see he indeed loves fp. he always is enthusiastic about it. :) i don't know how far into a 3 hour tutorial I could get, at least.
18:23:44 <shapr> Now there's someone I'd like to emulate.
18:24:28 <shapr> I've always had enthusiasm, but didn't have any sort of focus until I got ritalin. Life has been easier since then, but I still have bad habits I need to change.
18:25:36 <lament> sorear: you mean where actions are event handlers?
18:25:53 <sorear> lament: No.
18:27:53 <lament> hm, no idea then...
18:30:10 <gkr> sorear do you remember you gave me a link to a blog about free algebras and their relation to monads? I'd love if you can give me more information about that.
18:31:09 <sorear> gkr: that blog article is everything I know on the subject
18:31:24 <sorear> gkr: perhaps @ask dpiponi ?
18:31:30 <ddarius> Which one?
18:31:56 <desp> is "append to" correct gramatically? :)
18:32:21 <gkr> From the blog A neighborhood of infinity or soemthing like that.
18:32:33 <shapr> http://sigfpe.blogspot.com/
18:32:34 <lambdabot> Title: A Neighborhood of Infinity
18:32:44 <shapr> Who the heck wrote find-file-upward anyway?
18:33:40 <TSC> desp: Yep
18:35:23 <ddarius> gkr: What else do you want to know?
18:39:51 <shapr> @seen ndm
18:39:51 <lambdabot> I saw ndm leaving #haskell 2h 12m 5s ago, and .
18:39:52 <shapr> foo
18:40:02 <shapr> Does anyone know if Supero could be applied to JHC?
18:40:10 <shapr> For that matter, what's the status of JHC these days?
18:42:07 <thoughtpolice> i built a darcs version of it a little while ago but only for testing... i don't know if jhc's compile times need to be extended via more optimization though :)
18:43:09 <shapr> Last I tried to build jhc on a 2.4 GHz P4 with 1GB of ram... I just gave up :-(
18:43:18 <shapr> But now I have 4GB of ram and a dualie!
18:43:26 <thoughtpolice> hah. you have nothing on me. :)
18:43:46 <thoughtpolice> vmware with a p4 on the box, the virtualized linux box was granted about 256mb ram
18:44:02 <shapr> Yow
18:44:11 <thoughtpolice> needless to say it took a while. i think a hello world compilation with jhc timed in at around 20 minutes
18:44:15 <thoughtpolice> but damn, was that executable small. :)
18:44:38 <shapr> haha
18:45:02 <shapr> Yeah, I got jhc to generate C code that would happily compile and run on my Nokia 770.
18:45:04 <shapr> I was impressed.
18:45:26 <thoughtpolice> i'm trying to look around for a job right now though, I definately need a laptop (i'm looking for a dual core)
18:46:06 <thoughtpolice> anybody willing to offer any consumer experiance? :) the one I'm looking at was an acer but I have no exact specs right now
18:46:17 <shapr> I'm more in favor of a Nokia Internet Table and access to a powerful desktop via a bluetooth phone.
18:46:52 <LoganCapaldo> I'm using an acer right now
18:47:15 <LoganCapaldo> the webcam's cable has crapped out on me I think
18:47:26 <LoganCapaldo> but other than that it has served
18:48:03 <LoganCapaldo> Oh yeah
18:48:11 <thoughtpolice> i was also looking at lenovo's too. i would like a macbook but I think just a fair-end laptop is a good goal right now.
18:48:49 <shapr> I wish I could get an OLPC =)
18:48:54 <LoganCapaldo> the builtin battery software takes over the battery icon in the systray and when you hover over it doesn't give you the helpful tooltip that the default windows one does
18:49:03 <LoganCapaldo> but that only matters if you use windows
18:49:10 <thoughtpolice> isn't acer coming out with a similar style box? flash memory and all that.
18:49:15 <LoganCapaldo> with the OEM software installed
18:49:29 <LoganCapaldo> The work laptop is a lenovo T61
18:49:32 <shapr> thoughtpolice: Acer and Intel are both doing OLPC-style micro-laptops.
18:49:34 <thoughtpolice> and as an aside I believe the OLPC project is going to produce general-consumer PC's that are a lot like the XO.
18:49:35 <LoganCapaldo> its been kind of flaky
18:49:50 <shapr> Still, the OLPC is *way* cooler on both the hardware and software side.
18:50:12 <thoughtpolice> but yes, an XO would be cool to have. :)
18:50:58 <shapr> I'd love to have anything with built-in automatic mesh networking.
18:51:00 <thoughtpolice> if the consumer version they produce is anywhere around $150 like I think I read it will be, I think it would be quite fun to get a couple and cluster them.
18:51:01 <LoganCapaldo> so that's my anecdotal experience with acers and lenovos
18:51:15 <thoughtpolice> LoganCapaldo: define 'flaky' please?
18:51:35 <LoganCapaldo> the occasional inexplicable lockup
18:51:44 <LoganCapaldo> sometimes explorer.exe hangs
18:51:49 <LoganCapaldo> it BSODed today
18:51:54 <thoughtpolice> ouch.
18:52:08 <LoganCapaldo> I'm the T61 guinea pig
18:52:19 <LoganCapaldo> (everyone else has T60ps)
18:52:21 <thoughtpolice> i'm aiming for a dragonflybsd install when I get around to buying a lappy.
18:52:51 <LoganCapaldo> So mind you all this is happening with the precense of more than responsive IT support
18:53:13 <thoughtpolice> vmware has served me quite well over the past year and a half or so, but the real deal is much better.
18:53:18 <LoganCapaldo> So I dunno if it would be at the top of my recomendation list at this point
18:53:23 <phobes> Anyone know where the slides from the SPJ talk are?
18:53:26 <phobes> (the STM talk)
18:54:01 <thoughtpolice> LoganCapaldo: so, would you tilt towards acer or lenovo?
18:55:10 <LoganCapaldo> Based on my 2 samples, and the fact I've been way more abusive to the acer, I'd go with acer right now
18:55:18 <LoganCapaldo> but its only a 2 model sample
18:55:35 <thoughtpolice> fair enough.
18:57:30 <shapr> @go stm slides simon peyton jones filetype:pdf
18:57:31 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/STM-OSCON.pdf
18:58:25 <shapr> phobes: Is that it?
18:58:44 <dons> ?users
18:58:45 <lambdabot> Maximum users seen in #haskell: 385, currently: 359 (93.2%), active: 10 (2.8%)
19:07:24 <dons> interesting, http://programming.reddit.com/info/2i6cb/comments
19:07:24 <lambdabot> Title: Wired: Low-level hardware design in Haskell :: PDF (reddit.com)
19:12:05 <phobes> shapr: thanks!
19:12:26 <dons> phobes: how's the hacking coming along?
19:13:03 <shapr> Wow, jhc is using 1.3gb of ram while building libs. I wonder how high it goes?
19:13:23 <dons> i've seen 2.3G
19:13:35 <dons> i DOS'd the 16 core box doing 8 simultaneous jhc jobs
19:13:40 <dons> :}
19:13:41 <phobes> dons: ok... I've changed my goal from writing a haskell compiler to writing a front end for haskell
19:13:46 <SamB> wtf for?
19:14:39 <dons> phobes: a front end to the compiler?
19:14:43 <shapr> dons: Wow!
19:14:49 <dons> a preprocessor of some kind? or an ide?
19:17:24 <shapr> dons: Wait, you mean I could do make libs -j 2 for jhc?
19:17:38 <shapr> dons: How much ram does the 16 core box have?
19:17:45 <dons> shapr: oh, i just had jhc compiling 8 different jobs, 8 instances.
19:17:51 <shapr> insane
19:17:51 <dons> that was enough to use 2G per process
19:18:00 <shapr> So 16gb in the box?
19:18:04 <dons> yeah
19:18:13 <shapr> Impressive!
19:18:16 <dons> big machine
19:18:29 <dons> hey coffeemug
19:18:30 <shapr> I'm relatively happy with my 4GB, but I wish I'd gotten a NUMA box :-(
19:18:37 <coffeemug> hey dons
19:18:42 <coffeemug> how's it going
19:18:43 <shapr> NUMA boxes are way more responsive desktop machines.
19:18:43 <dons> my new laptop's apparently got 2G. which seems a lot.
19:18:56 <dons> the specs for thinkpads have gone up a lot in the last 4 years
19:19:16 <dons> 4G, actually
19:19:20 <Nafai> shapr: What's are NUMA boxes?
19:19:24 <dons> in a laptop. which seems a lot
19:19:24 <shapr> I think I may get another 4GB of this same memory, it does 5-5-5-15 @ 800MHz, so it's ok.
19:19:41 <ray> that's a great many giggle bites
19:19:42 <phobes> dons: A preprocessor
19:19:44 <shapr> Nafai: http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access
19:19:45 <lambdabot> Title: Non-Uniform Memory Access - Wikipedia, the free encyclopedia
19:19:58 <dons> phobes: ah ok. you might want to look at the Language.Haskell library then, for parsing and pretty printing haskell
19:20:06 <shapr> ray: Well, ram is extremely cheap right now.
19:20:07 <phobes> dons: Yup, was looking at it
19:20:09 <phobes> thanks
19:20:12 <Nafai> Interesting
19:20:25 <shapr> This 4GB of Patriot gaming memory was $200.
19:20:27 <coffeemug> was Language.Haskell integrated with Template Haskell yet?
19:20:42 <dons> coffeemug: no, they're similar, yet different
19:20:46 <ray> i could use a great many giggle bites, but i don't think i have a new enough motherboard for it to actually work out
19:20:48 <coffeemug> last time I looked I thought it was weird that there are two standard libraries doing the same thing
19:20:50 <Nafai> I can't imagine having less than 2GB of memory these days
19:20:57 <ray> you're lucky
19:20:59 <coffeemug> dons: well, the parsing bit is the same
19:21:04 <ray> :)
19:21:05 <shapr> ray: I bought an M2NE-SLI, it's pretty cheap.
19:21:31 <coffeemug> also, does GHC use those internally?
19:21:32 <shapr> ray: I can send you a copy of my setup, it ended up being about $600
19:21:44 <ray> that's pretty reasonable
19:22:01 <ray> wouldn't cut into my coffee budget
19:22:15 <Nafai> So I've decided that IRC and the reasonable reditt discussions take the place of having a good user group or other such place to hang out with smart people IRL for me
19:22:23 <Nafai> Though it's not quite the same :(
19:22:33 <dons> what city are you in, Nafai ?
19:22:48 <shapr> Yeah, in person discussions are just better. You get to unicycle then!
19:22:48 <dons> the user groups are listed here, http://haskell.org/haskellwiki/User_groups
19:22:49 <lambdabot> Title: User groups - HaskellWiki
19:22:58 <dons> but yes, irc is a substitute for user groups, for now
19:23:00 <Nafai> dons: Austin, TX
19:23:09 <coffeemug> I was at NY user group a few times
19:23:13 <coffeemug> it's pretty cool
19:23:13 <shapr> We could always have a South/Eastern USA meeting.
19:23:26 <Nafai> I met slava (of Factor fame) and another Factor hacker today for lunch
19:23:30 <Nafai> It was really fun
19:23:30 <shapr> Cool!
19:23:31 <dons> Nafai: ah cool!
19:23:37 <dons> yes, i heard slava was down south for a hackathon
19:23:50 <Nafai> Made me wish I had something like that regularly
19:24:03 <dons> you could start a group. do you know of many FP guys in the area?
19:24:17 <dons> just grab a pub or uni room, once every couple of months, have some talks
19:24:37 <dons> shapr: or is it 'bar' in the US, for pubs?
19:24:56 <coffeemug> hehe
19:24:59 <coffeemug> we know pubs :)
19:25:00 <wli> bar in US == pub in UK
19:25:18 <dons> ok. so if I want to watch the footy on the telly at the pub, would people know what I was saying?
19:25:26 <ray> no
19:25:29 <coffeemug> yes
19:25:30 <jbalint> we could infer...
19:25:31 <ray> but the pub part makes sense
19:25:32 <shapr> footy == soccer?
19:25:34 <coffeemug> you'd wanna watch a soccer game :)
19:25:40 <dons> heh.
19:25:43 <LoganCapaldo> they'd understand at least the "at the pub" part
19:25:49 <dons> no, footy == rugby league, most likely
19:25:50 <coffeemug> but it would take us a while
19:25:55 <shapr> Oh, not much rugby here.
19:26:13 <dons> shapr: yeah, and definitely no aussie rules /
19:26:13 <joed> You'd wanna watch soccer on the telly while happily sucking on a fag and so on.
19:26:33 <shapr> dons: Are aussie rules particularly relaxed?
19:26:39 <wli> I'm doing the latter of those as we speak.
19:26:43 <dons> they're particularly violent, I think
19:26:47 <shapr> oh, spiffy.
19:26:56 <shapr> I want to watch that sometime.
19:26:57 <dons> shapr: its gaelic football crossed with soccer
19:27:00 <coffeemug> do new zealenders really get angry when you call them aussies?
19:27:09 <shapr> Yes
19:27:09 <dons> coffeemug: yeah, i wouldn't do that
19:27:15 <coffeemug> really?
19:27:16 <ray> i know at least one that does
19:27:21 <dons> you should be able to tell by the accent though
19:27:21 <shapr> You can call them kiwis, but not aussies.
19:27:30 <Nafai> dons: I don't really know any other FP guys, though I'm sure there are some here
19:27:33 <coffeemug> the only way I found out about it was from Tarantino's Death Proof
19:27:35 <shapr> I dunno, nz and au accents are very similar to my uneducated ears.
19:27:47 <dons> the 'i' vowel is different
19:27:54 <dons> kiwis say "fush" for "fish"
19:28:01 <dons> at least to my ear
19:28:02 <Nafai> dons: I've heard enough of my coworkers that went to the University of Texas complain about their languages class and Haskell, that someone at the university must like it :)
19:28:05 <shapr> interesting
19:28:46 <ray> i bet most of the schools here are all java
19:28:54 <coffeemug> I went to Stony Brook
19:29:04 <coffeemug> which is supposed to be in top 20 CS programs in US
19:29:09 <coffeemug> it's all Java in undergrad
19:29:31 <coffeemug> Mark Tarver has some relationship with Stony Brook though, the guy who does Qi
19:29:41 <dons> do the Qi guys write papers?
19:29:52 <shapr> I got lucky, I never had any CS classes. Nothing to unlearn :-)
19:30:03 <coffeemug> Qi guys have a lot of info on their website
19:30:04 <dons> Qi seems to be conspicuous by its absence in published form
19:30:11 <coffeemug> not sure if they submit formal papers
19:30:20 <ray> i taught myself everything i know about CS
19:30:20 <dons> nothing at ICFP, esp. since their emphasis is on type system stuff
19:30:25 <ray> which is why i don't know anything
19:30:28 <dons> where's the formal work -- its a bit weird.
19:31:00 <coffeemug> there has been some talk of news groups that Qi type checker is not guranteed to terminate
19:31:05 <coffeemug> but there are no papers on that either
19:31:07 <shapr> Any ideas how to debug "Prelude.undefined" ?
19:31:20 <coffeemug> on*
19:31:34 <dons> coffeemug: yeah, i'm a little concerned they do all this type system stuff, but it seems hand wavy. what's the underlying theory?
19:31:35 <Cale> shapr: Compile with -prof -auto-all and run with +RTS -xc
19:31:35 <Nafai> Are there any other Austinites here in #haskell?
19:31:40 <shapr> Cale: Thanks
19:31:41 <dons> is it a dependent type system? is it lisp ?
19:31:50 <Cale> shapr: and you'll hopefully get a meaningful cost-centre trace
19:31:57 <shapr> I sure hope so.
19:32:01 <coffeemug> it's based on Common Lisp and you can mix Qi and CL code
19:32:07 <shapr> I hate getting Prelude.undefined at runtime.
19:32:18 <coffeemug> it has an optional type checker that you can turn on and off at will
19:32:40 <coffeemug> and you can define types in a prologish language
19:32:44 <dons> coffeemug: right, the value level. but they're putting a type system on top of that -- and an expressive one it seems -- but there's a lack of detail on what the type system is doing.
19:32:54 <ddarius> Nafai: I'm currently in Texas (*sigh*) but not Austin.
19:33:00 <sjanssen> shapr: you should chew out whomever wrote "undefined" in your code :)
19:33:04 <coffeemug> well, it's all on the web
19:33:13 <coffeemug> if you want to read about it you can
19:33:14 <shapr> sjanssen: He's a famous Haskeller, so I won't complain... much :-)
19:33:18 <sjanssen> can't be too hard to write (error "explanation")
19:33:21 <dons> coffeemug: yeah.
19:33:59 <LoganCapaldo> In fact you can even shorten it, just do undef = error "explanation" and use undef in place of undefined
19:34:00 * wli tends to try to make error strings maximally informative, at times doing show on various of the error-causing values.
19:34:21 <Nafai> ddarius: Just trying to find some others to meet up with, form a user group or reading group or something
19:34:45 <coffeemug> I always wanted algebraic types in CL
19:34:48 <coffeemug> now I have them :-D
19:34:50 <coffeemug> (defalgebraic maybe nothing (just *))
19:34:54 * wli wonders if a Portland, Oregon Haskell user group exists or will soon.
19:35:03 <fax> hehe
19:35:14 <coffeemug> just have to extend it with a pattern matcher
19:35:20 <coffeemug> and perhaps lazyness
19:35:23 <ray> i doubt there's any haskell user groups around here!
19:35:29 <LoganCapaldo> (defun nothing nil) (defun just (x) x) :)
19:35:32 <shapr> wli: Yeah, I always put x -> error ("Module.Function does not handle " ++ show x) at the bottom of case statements.
19:35:52 <coffeemug> hehe
19:35:56 <coffeemug> that can't work
19:36:07 <coffeemug> you can't create a monad on top of that :)
19:36:15 <wli> Well, with pdx.edu, ogi.edu, galois.com, et al in Portland OR one might expect a Haskell user group.
19:36:19 <shapr> wli: Heck yeah
19:36:24 <shapr> wli: And soon you'll have dons there too!
19:36:25 <dons> wli: yeah, i think we should create one.
19:36:33 <LoganCapaldo> You don't need a monad. the whole thing is already in IO ;)
19:36:34 <shapr> Man, I want to move to Portland now :-(
19:36:46 <coffeemug> Portland is a cool place to be :)
19:36:50 <LoganCapaldo> Actually you could just use Liskell
19:37:04 * wli was partially motivated by proximity to OGI back before various of the OGI Haskellers fled to pdx.edu
19:37:12 <ray> i wonder how many haskell users yale has
19:37:21 <sorear> .
19:37:23 <coffeemug> LoganCapaldo: I have too much CL code, I just want to extend it a bit with some features from Haskell
19:37:30 <dons> there's a few there still. Hudak's crew?
19:37:41 <dons> the robot hackers
19:37:56 <dons> ray: http://cs-www.cs.yale.edu/homes/hudak.html
19:37:56 <lambdabot> Title: Professor Paul Hudak's Home Page
19:37:58 <ray> they had a robot?
19:38:00 <LoganCapaldo> coffeemug, well still strikes me as doable
19:38:01 <coffeemug> LoganCapaldo: not for IO, for continuations and nondeterminism
19:38:13 <ray> oh, i know him, i bought his book a few weeks ago
19:38:30 <LoganCapaldo> (adding a defalgebraic and what have you)
19:38:31 <dons> hey, check out the old photo of Paul, :) http://www.cs.yale.edu/people/faculty/hudak.html
19:38:31 <lambdabot> Title: Paul Hudak
19:38:34 * wli should order Graham Hutton's book.
19:39:08 <coffeemug> LoganCapaldo: well, the code I showed for may be is real
19:39:10 <shapr> Hudak writes all the cool DSLs.
19:39:24 <coffeemug> it compiles to some CLOS code
19:39:31 <coffeemug> that pretty much implements algebraic types
19:39:41 <coffeemug> maybe
19:39:41 <SamB> doesn't conal do some cool stuff too?
19:39:48 <shapr> Yeah, lots.
19:39:58 <shapr> @where conal
19:39:58 <lambdabot> I know nothing about conal.
19:40:06 <shapr> @where+ conal http://conal.net/
19:40:06 <lambdabot> Done.
19:40:09 <dons> ?go conal
19:40:11 <lambdabot> http://www.robbieconal.com/
19:40:11 <lambdabot> Title: Robbie Conal's Art Attack!
19:40:13 <dons> hah
19:40:22 <dons> get with the program, google!
19:40:53 <SamB> dons: he just added it 21 seconds earlier
19:41:21 <dons> objection, SamB! relevance.
19:41:28 <shapr> Nafai: Anyway, a NUMA system has different chunks of memory attached to different processors. My NUMA Athlon MP was far more 'desktop responsive' than my current box.
19:42:07 <SamB> google didn't have time to spider lambdabot's @where database this time around yet
19:42:19 <SamB> they only do that once an hour
19:42:47 <Nafai> shapr: Ah, that's cool.  Maybe I should look into that the next time I build a desktop machine
19:43:25 <shapr> Nafai: It'd probably mean you'd have to buy a motherboard with multiple die sockets, so it wouldn't be cheap.
19:43:34 <shapr> I think my Athlon MP cost $2500 at the time.
19:43:50 <Nafai> Wow
19:43:50 <shapr> That thing was great for playing CounterStrike.
19:44:00 <wli> I think there are quad-socket mobos accepting quad-core CPU's already.
19:44:26 <dons> wli, yeah.
19:44:28 <shapr> Nafai: And that did not include screen, keyboard, drives, etc.
19:44:52 * wli doesn't buy his own computer hardware, as he'd rather put it toward jewelry.
19:45:15 <shapr> When I feel stressed, I go shopping! (for new hardware, of course)
19:45:38 <dons> i'd like less hardware in my life
19:45:49 * wli refrains from shopping while under any sort of duress, stress, etc.
19:45:53 <shapr> wli: smart.
19:45:55 <Nafai> I'm currently pretty happy with my laptop
19:45:56 <shapr> dons: How so?
19:46:18 <shapr> I really enjoy tuning my desktop for more performance. I don't like admin'ing remote boxes so much though.
19:46:20 <dons> shapr: so dirty, noisy blargh
19:46:47 <wli> I'm probably going to stuff all my big boxen (which are now all broken anyway) in my garage and ignore them for the foreseeable future.
19:46:58 <shapr> wli: I want to come to your next garage sale!
19:47:06 <shapr> What's broken about your big boxen anyway?
19:47:12 <wli> shapr: They're old, slow, ancient, and broken.
19:47:16 <shapr> But manycore?
19:47:23 <dons> anyone in sydney want a 68k mac running netbsd, network connected? :)
19:47:26 <wli> shapr: Dead PSU's, dead CPU fans, etc.
19:47:29 <shapr> oh
19:47:50 <shapr> Hm, I need to learn configurations in cabal now... Is there a standard chunk for doing profiling buids?
19:48:00 <wli> shapr: Well, if you think 6 x 300MHz UltraSPARC II is worth anything, maybe.
19:48:11 <shapr> wli: Yeah, that'd be fun.
19:48:32 <shapr> Last time I played with a many-cpu SPARC, it was 8 x 25MHz.
19:48:45 <wli> shapr: 2 x 21164 is similarly dogslow and not even very many cores.
19:49:15 <wli> shapr: There's an 8 x 25MHz 32-bit SPARC box that I can't power up involved, too.
19:49:24 <shapr> broken PSU?
19:49:35 <shapr> Foo, the cabal wiki page doesn't say anything about how configurations work.
19:49:49 <wli> shapr: Not sure. It trips the circuit breakers when the switch is flipped.
19:50:13 <shapr> Ah, but Cabal.cabal demonstrates..
19:51:10 <shapr> foo, debian/unstable doesn't have libghc6-haxml-prof, only libghc6-haxml-dev
19:51:37 <wli> shapr: We're not talking about anything remotely approaching modern things like Niagara etc.
19:51:57 <shapr> Yeah, that might be more trouble than it's worth.
19:52:40 <wli> shapr: They're also getting to the point where they're so old they're going to need regular infusions of fresh parts.
19:52:49 <dons> infusions. hmm
19:52:58 <dons> that would be a cool name for a paper
19:53:17 <shapr> dons: Next part of the ByteString series?
19:53:21 <dons> yeah :)
19:53:29 <shapr> spiffy!
19:53:37 <dons> something about peppermint infusions or something
19:53:58 <dons> "hot infusions for fast arrays"
19:54:00 <dons> or something like that
19:54:10 <shapr> That'd be cool for an NDP paper.
19:54:11 <dons> its a good term that hasn't been used.
19:54:47 <wli> shapr: That, for the most part, means buying duplicates of the boxen and migrating old parts over, doing part-swapping to see which pieces are bad (and the probability is that the "new" hardware you'll find will have some broken pieces, too).
19:54:50 <SamB> work in a candyfab reference somewhere ;-)
19:56:06 <wli> shapr: It's expensive (shipping is astronomical and often costs even more than the machines), it's tedious, it's time-consuming, and the results are not very useful except as curiosities.
19:56:48 <wli> shapr: It's called "retrocomputing" and is characterized as a quasi-crackpot hobby for a good reason.
19:57:16 <SamB> I prefer to do my retrocomputing via virtualization for the most part
19:57:29 <SamB> also via old computers that still work, I suppose
19:57:29 <newsham> anyone know if ghc HEAD has freebsd/amd64 support yet?
19:58:41 <wli> shapr: I have enough fast machines to do real work with. I even have 32-bit SPARC boxen that still work for arch maintainer work (though I'm likely to be ousted as maintainer eventually due to my utter non-productivity, at which point the new maintainer will get everything he wants from my 32-bit SPARC collection free, including free shipping, and the rest eBays).
19:59:26 <wli> shapr: (Well, "free" as in I pay for it, at tremendous expense.)
20:00:01 <newsham> linux/sparc32?
20:00:06 <shapr> wli: hah
20:00:10 <wli> newsham: Yes.
20:00:32 <shapr> dons: Hey could I use one of your papers for an online FLM demo, or would that violate copyright you may have assigned to the journal(s) ?
20:01:16 <Nafai> shapr: What's FLM?
20:01:29 <shapr> Fermat's Last Margin
20:01:34 <Pseudonym> ?where flm
20:01:35 <lambdabot> I know nothing about flm.
20:01:40 <dmead> hi kids
20:01:41 <shapr> Pseudonym: It's not up yet.
20:01:44 <Pseudonym> This seems to be a FAQ lately.
20:02:01 <shapr> But it's pretty close, and I want a real paper to show in the demo.
20:03:04 <SamB> people shouldn't assign copyright to journals
20:03:18 <SamB> if a BSD3 license isn't good enough for them, they shouldn't get papers!
20:04:02 <wli> Similar actually applies to my linux/hugetlbfs maintainership except there's no hardware for me to ship.
20:04:57 <SamB> wli: why do they make the old maintainer pay for the shipping?
20:05:23 <shapr> Nafai: What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
20:05:27 <shapr> Nafai: How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
20:05:44 <wli> To be honest I may have already been ousted from one or both without having any idea. I'm thousands of messages behind on email and haven't checked the MAINTAINERS file in recent git.
20:05:45 <jbalint> Hi, what is the correct syntax here? http://rafb.net/p/cofXcm46.html I am getting parse error on the 'then' line
20:05:47 <lambdabot> Title: Nopaste - No description
20:06:24 <wli> SamB: It's conventional, not necessarily required. I doubt anyone would bother me if I didn't.
20:06:44 <Nafai> shapr: Wow, fancy.  Written with HApps?
20:07:01 <mrd> jbalint: indent the 'then' and always include an 'else'
20:07:13 <wli> SamB: I may not have the wherewithal to actually do any sparc32 maintenance but I do have enough cash on hand to do that much to help keep the port alive.
20:07:29 <mrd> jbalint: also you need a 'do' within the 'then'
20:07:37 <jbalint> ah...
20:07:48 <shapr> Nafai: Yup
20:08:03 <ddarius> jbalint: if-then-else is always an expression form.
20:08:21 <ddarius> Which is quite possibly not very helpful information.
20:08:23 <jbalint> is there a no-op i can use for the else?
20:08:28 <ddarius> return ()
20:08:57 <hpaste>  mrd pasted "for jbalint" at http://hpaste.org/2405
20:09:04 <jbalint> hrm, the examples here http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm dont indent the then,else
20:09:09 <lambdabot> Title: Monads for the Working Haskell Programmer
20:09:33 <mrd> its a known flaw with layout in "do" blocks
20:09:42 <jbalint> Ok, i've got it working. thanks alot
20:10:01 <wli> mrd: Which is that? Requiring the then/else to be indented relative to if?
20:10:06 <mrd> yea
20:10:19 <_fang> hello there... i need a help with a unresolved overloading here: mod2 x y = x - (floor(x/y) * y)
20:10:20 <ddarius> jbalint: None of them are being used directly in do blocks.
20:10:24 <_fang> any help kindly appreciated
20:10:25 <_fang> =]
20:10:29 <wli> Well, it's just a sugared case on Bool.
20:10:33 <mrd> sure
20:10:44 <jbalint> ddarius: Ok, i see
20:10:47 <wli> case needs indentation...
20:10:50 <mrd> sometimes i do just 'case' anyway. never liked 'if'.  too awkward.
20:11:09 <mrd> but 'if' is inconsistent in that the 'then/else' needs indentation only inside do-blocks and not elsewhere.
20:11:15 <ddarius> jbalint: You may also want to look at when and unless.
20:11:17 <ddarius> :t when
20:11:22 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:11:37 <mrd> @index when
20:11:37 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:11:44 <ddarius> mrd: It is consistent.
20:12:47 <jbalint> ah thanks. the when works well
20:13:18 <hpaste>  ddarius annotated "for jbalint" with "mit when" at http://hpaste.org/2405#a1
20:13:33 <ddarius> That paste is probably redundant then.
20:14:25 <jbalint> :)
20:14:54 <Saizan_> :t let mod2 x y = x - (floor(x/y) * y) in mod2
20:14:56 <lambdabot> forall a. (Integral a, RealFrac a) => a -> a -> a
20:15:03 <ddarius> :t floor
20:15:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:15:27 <Saizan_> _fang: do you want  the arguments to be integrals or not?
20:15:35 <_fang> integrals
20:15:45 <_fang> i tried a mod2 :: Int
20:15:47 <Saizan_> ok, so:
20:15:50 <ddarius> x - (x `div` y) * y
20:15:52 <Saizan_> :t (/)
20:15:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:16:11 <Saizan_> :t div
20:16:12 <lambdabot> forall a. (Integral a) => a -> a -> a
20:16:21 <Saizan_> integer division is div
20:16:30 <_fang> hmmm
20:16:36 <_fang> okie dokie!!!
20:16:37 <_fang> =D
20:16:50 <_fang> i'm completely newbie here... sorry for bothering
20:16:52 <_fang> =]
20:16:57 <ray> :t quot
20:16:59 <lambdabot> forall a. (Integral a) => a -> a -> a
20:17:18 <Cale> _fang: don't worry, we like newbies :)
20:17:27 <mrd> they're tasty
20:17:35 <Cale> heh
20:17:38 <glguy> and they serve to futher our goal of boosting
20:17:39 <glguy> @users
20:17:39 <lambdabot> Maximum users seen in #haskell: 385, currently: 361 (93.8%), active: 17 (4.7%)
20:17:40 <_fang> lol
20:17:43 <_fang> thx
20:17:47 <_fang> worked like a charm
20:17:48 <_fang> =D
20:17:49 <ddarius> @check \x y -> x - (x `div` y) * y == x `mod` y
20:17:50 <lambdabot>  Add a type signature
20:18:09 <ddarius> @check (\x y -> x - (x `div` y) * y == x `mod` y) :: Int -> Int -> Bool
20:18:11 <lambdabot>  Exception: divide by zero
20:18:24 <ddarius> @check (\x y -> y /= 0 ==> x - (x `div` y) * y == x `mod` y) :: Int -> Int -> Bool
20:18:25 <lambdabot>  Couldn't match expected type `Bool'
20:18:34 <Cale> ray: quot and rem are almost never the ones you really want
20:19:00 <ray> i assume that's why quot has the "weirder" name
20:19:10 <ddarius> My QuickCheck-fu departed long ago.
20:19:29 <_fang> feels strange to me this way of programming, but i guess i can get along with it... thank you very much!!
20:19:38 <ddarius> ?
20:19:49 * ddarius assumes you are talking about other parts of programming Haskell.
20:20:26 <Cale> > map (`mod` 4) [-4..4]
20:20:28 <lambdabot>  [0,1,2,3,0,1,2,3,0]
20:20:32 <Cale> > map (`rem` 4) [-4..4]
20:20:34 <lambdabot>  [0,-3,-2,-1,0,1,2,3,0]
20:20:55 <Cale> > map (`div` 4) [-10..10]
20:20:57 <lambdabot>  [-3,-3,-2,-2,-2,-2,-1,-1,-1,-1,0,0,0,0,1,1,1,1,2,2,2]
20:21:02 <Cale> > map (`quot` 4) [-10..10]
20:21:04 <lambdabot>  [-2,-2,-2,-1,-1,-1,-1,0,0,0,0,0,0,0,1,1,1,1,2,2,2]
20:23:09 <Cale> (they're the same on positive values, but their behaviour for negative ones differ)
20:24:17 <Saizan_> and there's a combo with the weirdness of unary minus to make you think they're the same :)
20:25:08 <dmead> anybody have experience with fp on embedded systems?
20:25:34 <ddarius> @google embedded real-time frp
20:25:38 <lambdabot> http://portal.acm.org/citation.cfm?id=507669.507654&coll=&dl=acm&CFID=15151515&CFTOKEN=6184618
20:25:38 <lambdabot> Title: Real-time FRP
20:26:30 <Cale> Saizan_: :)
20:26:43 <Cale> > ((-1) `mod` 4, -1 `mod` 4)
20:26:45 <lambdabot>  (3,-1)
20:26:57 <dmead> kewl
20:26:57 <dmead> thanks
21:00:53 <dons> shapr: should be fine. please go ahead
21:08:14 <dons> ?users
21:08:14 <lambdabot> Maximum users seen in #haskell: 385, currently: 359 (93.2%), active: 2 (0.6%)
21:08:23 <dmead> hi dons
21:08:33 <dons> hey dmead. how's code?
21:08:41 <dmead> pretty good
21:08:57 <dons> @seen RyanT5000
21:08:57 <lambdabot> I saw RyanT5000 leaving #haskell-blah 13d 15h 34m 34s ago, and .
21:09:01 <dmead> i'm tryin to research running haskell on small embedded systems
21:09:14 <dmead> but coming up short
21:09:19 <dmead> not just haskell relly
21:09:21 <dmead> *really
21:09:22 <dmead> lisp too
21:09:24 <dmead> :/
21:09:27 <dons> oh, that's interesting
21:09:33 <dons> i just had a meeting about that topic :)
21:09:36 <dmead> kewl
21:09:42 <dmead> must be the wave of the future :)
21:09:47 <dons> dmead: you know nhc98 was designed as a compiler for haskell on embedded systems?
21:09:56 <dmead> yes
21:10:01 <dons> it uses heap compression, and bytecode optimisation, and other tricks for low resource sytems
21:10:08 <dmead> oh ye?
21:10:13 <dmead> i thought it was for bare metal
21:10:20 <dmead> i need something for embedded linux
21:10:40 <dons> right, the nhc-produced executables just run as normal applications in linux
21:10:52 <dons> ghc's rts can run on bare metal. hmm. let me find you some links.
21:11:26 <dons> dmead: this is the unsw project for haskell, verified kernels, and other embedded FP stuff, http://www.ertos.nicta.com.au/research/l4.verified/
21:11:26 <lambdabot> Title: NICTA | ERTOS - http://www.ertos.nicta.com.au/research/l4.verified/home.pml
21:11:48 <dons> in particular, sel4, http://www.ertos.nicta.com.au/research/sel4/
21:11:49 <lambdabot> Title: NICTA | ERTOS - http://www.ertos.nicta.com.au/research/sel4/home.pml
21:12:05 <dons> dmead: and galois does other things with embedded stuff
21:12:09 <dmead> kewl
21:12:27 <dmead> yea we have one micro controller that has 128k of ram
21:12:31 <monochrom> I'm dirty-minded. I read ertos.nicta as erotica.
21:12:35 <dmead> lol
21:12:38 <dons> if you want complex embedded software, writing it in asm isn't the best thing. FP seems to be the obvious tool
21:12:55 <dmead> indeed
21:13:01 <dons> 128k eh?
21:13:07 <dmead> i got my first job post graduation
21:13:10 <dons> a custom bytecode interpreter for nhc or ghci bytecode?
21:13:22 <dons> there's lots of work in this area though
21:13:24 <dmead> they make embedded linux SCADA systems
21:13:25 <dmead> yea
21:13:27 <dmead> it's quite interesting
21:13:29 <dons> cool
21:13:34 <dmead> especially cause of the need for correctness
21:13:53 <dmead> for instance they've sold units to the CDC which monitor virus storage
21:14:04 <dons> right. and in that area, correctness, FP techniques are the main way to go, I guess.
21:14:05 <dmead> so it's kinda essential
21:14:17 <dmead> yea but i understand theres the issue of space constraints
21:14:21 <dons> does it involve verification work?
21:14:32 <dons> or just reliable systems using traditional methods
21:14:35 <dmead> which is where FRP or hume come in
21:14:38 <dmead> ah not sure
21:14:44 <dmead> the electrical engineers handle the testing
21:14:44 <dons> yeah, hume is what I was thinking of
21:14:59 <dons> so hard real time stuff?
21:14:59 <dmead> hmmmm
21:15:03 <dmead> ahh not really
21:15:05 <dmead> not real time
21:15:23 <dmead> it's just needs to be responsive enough to be "useful"
21:15:23 <dons> so haskell would be ok then :)
21:15:26 <dmead> aye
21:15:52 <dmead> do the nhc docs talk about small executables?
21:15:53 <dons> yeah. something like xmonad shows you can really make these things fairly tight, fast, and clean, I reckon
21:15:59 <dmead> indeed
21:15:59 <dons> but 128k is pretty tight.
21:16:07 <dons> you can't just use ghc produced binaries in that space.
21:16:12 <dmead> indeed
21:16:18 <dmead> asm maybe the only choice
21:16:19 <dmead> :/
21:16:27 <dons> hmm
21:17:08 <dons> I think you'd want >2M to just use ghc produced binaries cleanly, without modification
21:17:13 <dmead> yea
21:17:21 <dmead> i tried using an in-place compressor
21:17:24 <dmead> and having ghc emit C
21:17:33 <dons> that's interesting.
21:17:36 <dmead> i got hello world down to 80k
21:17:42 <dmead> but it still wants other libs
21:17:46 <dons> oh, binary size?
21:17:49 <dmead> yes
21:17:55 <dons> yeah, 2M is sort of a typical heap size, i've noticed
21:18:01 <dmead> yea
21:18:06 <dmead> 3 is really common in the ml family
21:18:21 <dons> nhc is probably a better bet then
21:18:25 <FMotAFK> what do you call a function whose range = its codomain?
21:18:30 <dons> smaller heap, you can turn on heap compression and so forth
21:18:33 <dmead> yea, emit C and compile with -Os on gcc 4
21:18:42 <dmead> bam, 80k
21:19:00 <dons> so 80k compiling ghc's rts with -Os gcc 4, and the haskell code itself?
21:19:07 <dons> and compressing the result?
21:19:16 <monochrom> FMota: surjection. onto function.
21:19:18 <dmead> no, one sec
21:19:24 <FMota> thank you, monochrome
21:19:32 <dmead> i used this
21:19:33 <dmead> http://upx.sourceforge.net/
21:19:34 <lambdabot> Title: UPX: the Ultimate Packer for eXecutables - Homepage
21:19:41 <dons> ah right.
21:19:51 <dmead> quite good at compression
21:19:59 <monochrom> Damn, I forgot to put on this category-theoretic pretense.  Epimorphism. :)
21:20:01 <dmead> just takes a bit of temp space to unpack
21:20:17 <dmead> ghc -f-via-c
21:20:47 <dmead> gcc -Os march=i486 -fomit-frame-pointer
21:20:57 <dmead> then upx
21:21:39 <dons> ah ok.
21:22:04 <dmead> i asked why it's still so large in #ghc
21:22:24 <dmead> they said it's the desired behavior for the resulting C to still want the big-integer libs
21:22:31 <dons> well, the rts is almost a full OS, statically linked
21:22:36 <dons> and yeah, you still need libgmp
21:22:38 <dmead> oh yea?
21:22:47 <dmead> hmm
21:22:53 <dmead> yea i'm not versed too well in compiler design
21:23:00 <dons> ghc's runtime runs on bare metal with little modification
21:23:10 <dons> so its fairly comprehensive
21:23:15 <dmead> ah
21:23:57 <dmead> weird
21:24:08 <dmead> slashdot is running a story on the kinda thing i'm working on
21:24:09 <dmead> http://it.slashdot.org/it/07/08/23/2240215.shtml
21:24:10 <lambdabot> Title: Slashdot | SCADA Systems a Target for Hackers?
21:24:26 <dmead> brb!
21:35:32 <shapr> dons: Thanks!
21:39:12 <geezusfreeek> huh, it seems uncharacteristically quiet in here
21:39:54 <dons> this is the quiet time usually
21:40:11 <dons> afternoon .au time, late night in the US, europe not awake yet
21:41:02 <kaol> yes we are
21:41:14 <ray> this is the most awake time of my day
21:41:20 <ray> (eastern US here)
21:41:22 <Saizan_> someone is still awake in europe, also
21:41:37 <ray> i'm talking to a few europeans in other irc channels
21:41:50 <ray> weird ones, though
21:42:45 <Heffalump> ugh.
21:42:56 <shapr> I want to be a european too!
21:43:08 <ray> dons: do i need fptools to build lambdabot, or just for some of the modules to work?
21:43:11 * ddarius is happy being an American.
21:43:33 <dons> ray, don't need it
21:44:11 <gour> morning
21:44:29 <FMota> :o
21:44:37 <FMota> I'm a weird European.
21:44:37 <FMota> Is that okay?
21:44:41 <gour> anyone can tell something about pro/cons regarding of UML usage with haskell?
21:44:57 <dons> no one uses it.
21:45:04 <gour> no need?
21:45:13 <dons> yeah. no need. doesn't clarify the code at all
21:45:38 * gour does not have any experience with it, but some OO (read C++) user recommends it
21:45:51 <ddarius> Hmm... most of the diagrams make little or no sense applied to most Haskell code.
21:46:03 <monochrom> @type foldM
21:46:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:46:12 <dmead> UML is used for java mostly i thought
21:46:21 <dons> the OO guys write such obfuscated code that they need a meta language to understand what their programs do
21:46:26 <dons> this is unneeded in Haskell.
21:46:27 <monochrom> @botsnack
21:46:27 <gour> so, no use for FP
21:46:27 <lambdabot> :)
21:46:39 <dons> one thing you could do is us haskell to as a modelling language for OO langs though
21:46:42 <dons> that'd be funny
21:46:48 <gour> ;)
21:46:58 <ddarius> I think it's been done.
21:47:13 <geezusfreeek> well, haskell is used for prototyping a lot already, which is similar
21:47:28 <gour> thanks, i'ts good to know to provide some arguments
21:47:46 <geezusfreeek> well, not as often as i would like i guess
21:47:56 * gour is happy suceeding to use haskell as language for the project
21:47:57 <ddarius> gour: I don't think most OO people would accept most of the "arguments" put forth.
21:48:18 <notsmack> is dtd2haskell not TH yet?
21:48:19 <dons> gour: yay!
21:48:32 <geezusfreeek> coming from a previous OO background, i can attest to the stubbornness of both sides in OO vs. FP
21:48:42 <gour> ddarius: but, at least, practically we can model without it (uml)
21:48:44 <dons> gour: so the main issue is that UML is used to clarify how program work in the presence of obscure control flow and mutable state
21:48:51 <dons> and other side effects
21:48:52 <FMota> Here's something interesting
21:49:01 <FMota> I prefer dynamic imperative languages
21:49:02 <dons> something that is just a non-issue in purely functional programming
21:49:08 <FMota> from static ones
21:49:25 <dons> statically typed imperative languages are in a rather woeful state
21:49:31 <dmead> python is evil
21:49:33 <dons> scala seems promising though
21:49:44 <FMota> but Haskell's and Epigram's type systems appeal to me far more than Erlang's.
21:49:47 <Pseudonym> Python is hardly statically typed.
21:49:52 <dons> erlang doesn't have a type system :)
21:49:57 <geezusfreeek> FMota, me too, generally... i guess if you're gonna be unsafe you might as well go all the way with it and at least gain some convenience out of it
21:49:58 <gour> dons: guy put argument regarding API as well, but i believe haskell's signatures & type-checking are good enough
21:50:00 <FMota> exactly :p
21:50:25 <dons> gour: indeed. the type signature can often fully specify the code
21:50:30 <FMota> Which is why I'm not enjoying Ada at all.
21:50:34 <geezusfreeek> then again, i also like D
21:50:54 <FMota> Sure, Ada is much more "safe" than C++ and Java
21:51:00 <geezusfreeek> at least for system-level programming
21:51:01 <gour> dons: thanks. how is the (real) book?
21:51:11 <FMota> but it still causes me pain whenever I have to write a procedure.
21:51:19 <dons> gour: its kicking along nicely
21:51:37 <FMota> (and I've only even had one week of it. How am I going to survive a semester of Ada? :/)
21:52:01 <dons> they teach Ada at schools still?
21:52:04 <dons> bizarre. why?
21:52:12 <ddarius> dons: Why wouldn't they?
21:52:18 <ddarius> People still teach Miranda!
21:52:19 <geezusfreeek> i haven't used epigram yet... to those who have, are experiences positive?
21:52:21 <gour> dons: when you will provide some appetiter for wide audience?
21:52:22 <dons> ddarius: yeah :/
21:52:23 <dmead> i have a friend at MIT that took a class in it
21:52:27 <dmead> for engineering
21:52:30 <dons> doesn't make academia look good
21:52:41 <dons> geezusfreeek: theorem proving is hard work :)
21:52:50 <dons> but epigram makes it fairly fun
21:52:55 <dmead> alright
21:53:06 <dons> does Ada have any exposure outside the US?
21:53:11 <dmead> tomorrow i'm gonna prove some theorems on an embedded machine
21:53:12 <dmead> no
21:53:16 <dmead> it's a defense department languge
21:53:19 <FMota> don't know, wouldn't think so.
21:53:31 <dmead> they teach the engineering majors ada for legacy shit
21:53:39 <ddarius> Um. I'd say yes.  Ehud Lamm is into Ada.
21:53:39 <dons> like lisp, then. a weird US NIH thing :)
21:53:57 <dmead> NIH?
21:54:04 <monochrom> UML aims at communicating some ideas but not all. For example its event sequence diagrams does not allow you to say "must not happen"; it is also vague between "must happen" and "may happen". It is really a trivial notation for trivial information, after you have learned it. The real information, though, is always written in English in the "comment" aka "notes" boxes, which are draw like post-it notes. (Who needs a standard f
21:54:04 <monochrom> or post-it notes?)
21:54:12 <geezusfreeek> so far, my cs professors have mostly been old fortran users that don't think any other language is really ever going to be as good as fortran was
21:54:14 <FMota> they teach everyone in CS Ada here at UNI (University of Northern Iowa)
21:54:19 <geezusfreeek> even my programming languages teacher
21:54:30 <FMota> and it's the hardest course around, because the teacher is a strict douche
21:54:49 <dons> the persistence of lisp and scheme in the US, after being abandoned everywhere else in favour of things like ocaml, haskell and erlang, is put down to 'not invented here' syndrome, and people not liking euro-trash languages ;)
21:54:53 <geezusfreeek> i quote "Functional languages have a lot of parentheses and are just weird."
21:54:57 <FireRuby> functional programming SUCKs@!!!!
21:55:01 <ddarius> "fortran was"?  Fortran is very alive and kicking.
21:55:13 <geezusfreeek> sorry, i didn't mean to put past tense in there
21:55:16 <dmead> geezusfreeek, the senior programmer at my gig is a fortran guy
21:55:17 <dons> FireRuby: welcome. want some closures?
21:55:21 <shapr> Would ghc happen to return a result code depending on whether the sources changed and it build a new binary?
21:55:25 * shapr bets it doesn't
21:55:40 <Pseudonym> FireRuby: Some specifics would be good.  Or even better, patches!
21:55:41 <FireRuby> I have to study HaskHell at Univ wow
21:55:43 <FMota> anyway. Back to my blog post.
21:55:51 <dons> FireRuby: cool. you'll learn a few new tricks then
21:55:55 <FireRuby> so confusing is it any good?
21:56:03 <FMota> I envy you FireRuby.
21:56:10 <FMota> I have to learn Ada.
21:56:11 <monochrom> Ada is not bad.
21:56:13 <FireRuby> Im going to fail my tests misrably
21:56:14 <dons> yeah, a lot of people wish they could study haskell at uni.
21:56:18 <geezusfreeek> FireRuby, you're a ruby guy i take it?
21:56:19 <shapr> FireRuby: I have a job writing Haskell.
21:56:27 <dmead> shapr, where?
21:56:27 <dons> FireRuby: oh? do you lack resources? need some tutorials?
21:56:39 <monochrom> Ada's type system and module system are about the best among the real-world languages.
21:56:41 <FireRuby> I lack the patience I guess
21:56:42 <dmead> and how can i get a job doing haskell :P
21:56:43 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint, FireRuby!
21:56:44 <Pseudonym> Or some specific questions?
21:56:45 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:56:50 <FMota> I don't think anyone in my CS department has heard of Ada.
21:56:55 <FMota> er, * Haskell
21:56:56 <dmead> hah
21:56:56 <FireRuby> foldr killed me on my last test
21:56:59 <dmead> oh
21:57:00 <dmead> :<
21:57:01 <shapr> FireRuby: You wouldn't happen to have Dr. Anand for your teacher, would you?
21:57:01 <Pseudonym> LOL
21:57:08 <dons> its just a for loop, as a function, FireRuby
21:57:09 <Pseudonym> Our department had the local Ada zealot.
21:57:10 <FireRuby> ANAD ahahahaha
21:57:11 <dons> :t foldr
21:57:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:57:13 <FireRuby> From McMaster?
21:57:18 <dmead> what school?
21:57:18 <FireRuby> Anand
21:57:21 <FireRuby> Chris Anand
21:57:23 <dons> > foldr (\a b -> a + b) 0 [1..10]
21:57:24 <lambdabot>  55
21:57:30 <shapr> FireRuby: Yeah, Dr. Anand from McMaster, is he your teacher?
21:57:36 <geezusfreeek> i wish haskell would play a larger role at my university
21:57:36 <FireRuby> No Kahl is
21:57:39 <shapr> Ah, spiffy.
21:57:40 <dons> ah, Dr Kahl!
21:57:42 <monochrom> Of course if you remove the real-world restriction, Modula-3 has a better one among the imperatives, and Haskell and MLs have better ones among the functionals.
21:57:44 <coffeemug> FireRuby: what's the difficulty you're having?
21:57:48 <dons> cool. you should take advantage of that. he's a good teacher
21:57:49 <dmead> my fp proff is an aussie
21:57:50 <FireRuby> shapr you from Mac?
21:57:54 <dons> dmead: oh?
21:57:55 <geezusfreeek> everybody is C++ or Java here... except for the Fortran and Pascal holdout-instructors
21:57:56 <dmead> yea
21:58:01 <gour> monochrom: for what is Ada used in real-world (except its origine) ?
21:58:01 <dmead> he teches at west chester
21:58:03 <coffeemug> FireRuby: do you have imperative programming permanently imprinted into your brain? :)
21:58:04 <dmead> near philadelphia
21:58:10 <dmead> rich wyatt?
21:58:16 <shapr> FireRuby: No, but the Haskell community is tightly knit enough that it's easy enough to know everybody.
21:58:16 <FireRuby> coffeemug I dont even know, I just cant write it.. imperative programming owns me
21:58:18 <dmead> he left melbourne like 20 years ago
21:58:19 <desp> you do have to be open-minded enough to enjoy being taught Haskell as a freshman.
21:58:21 <monochrom> probably not much except its origin.
21:58:38 <dmead> how many auss functional programmers could there be right?
21:58:39 <FMota> oh
21:58:39 <FireRuby> shapr Wolfram Kahl is god in Haskell isnt he?
21:58:45 <coffeemug> FireRuby: sorry for the shameless plug, but try this: http://www.defmacro.org/ramblings/fp.html
21:58:45 <monochrom> but its origin is a formidable real-world user, you have to admit.
21:58:46 <lambdabot> Title: defmacro - Functional Programming For The Rest of Us
21:58:47 <FMota> yeah, there's alittle catch there
21:58:48 <Pseudonym> dmead: THey all know each other.
21:58:53 <shapr> FireRuby: Well, he does cool stuff, that's true.
21:59:03 <dmead> Pseudonym, of course they do
21:59:04 <dons> Pseudonym: heh :)
21:59:06 <Cale> FireRuby: hi
21:59:07 <monochrom> It is larger than any single bank.
21:59:07 <FMota> I'm not even American, so I probably can't even work for the DoD
21:59:10 <dons> Pseudonym: except the west coast guys
21:59:14 <FireRuby> Hi Cale
21:59:14 <Pseudonym> Hell, I used to tutor Bernie Pope.
21:59:16 <dons> who knows what's happening over there
21:59:22 <Cale> FireRuby: I did a summer research term at mac
21:59:27 <dmead> does anyone live there?
21:59:31 <dmead> outside of perth?
21:59:33 <FireRuby> with which Prof?
21:59:33 <dons> the melbourne, canberra, sydney mafia at least
21:59:41 <FireRuby> You guys need HaskellOnRails
21:59:45 <Cale> FireRuby: Christopher Anand
21:59:48 <dmead> hah
21:59:49 <dmead> FireRuby,
21:59:49 <Pseudonym> Is John Shepherd still doing Haskell?
21:59:50 <dons> FireRuby: yeah, that's happs. you should talk to shapr about it
21:59:51 <ray> haskell is already on rails
21:59:52 <dmead> i already named it
21:59:52 <Pseudonym> Or has he moved on?
21:59:54 <dmead> no
21:59:54 <monochrom> Haskell On Lambdas
21:59:56 <dons> Pseudonym: nah. he's moved on i think
22:00:00 <dmead> it's called haskell in hyperspace
22:00:03 <dmead> or on helicopters
22:00:07 <monochrom> No, Haskell On Arrows.
22:00:09 <FireRuby> sharp are you on the core team for building Haskell?
22:00:09 <dons> helicopters are cool
22:00:11 <Pseudonym> Damn.  He's the one who got me enthused.
22:00:21 <dons> FireRuby: no, he's a got a job working on a haskell web framework
22:00:21 <dmead> sorear, and i came up with that idea last spring
22:00:24 <shapr> FireRuby: Funny you should mention that, I get paid to hack on the equivalent of Haskell On Rails.
22:00:28 <FireRuby> THats really cool how you guys know my Mac profs
22:00:33 <ddarius> monochrom: I'm sure there are many Ada users outside the DoD and the DoD no longer uses Ada to the extent it did.
22:00:43 <sorear> dmead: huh?
22:00:44 <Cale> FireRuby: Would you like to know the right way to think about foldr?
22:00:45 <dmead> FireRuby, what school do yo go to?
22:00:49 <FireRuby> McMaster
22:00:50 <ddarius> There are clearly Ada users outside America.
22:00:51 <dons> FireRuby: do you know Wolfgang Thaller?
22:00:55 <shapr> But as dons said, I'm not a core Haskell hacker.
22:00:55 <FireRuby> Cale sure
22:01:01 <monochrom> Ada is very real-world in any case. I just don't know the demography.
22:01:02 <dmead> sorear, did you participate in naming haskell in hyperspace?
22:01:02 <Tac-Tics2> can anyone help me out with why I'm getting a stack overflow with Parsec?
22:01:03 <dmead> :P
22:01:04 <FireRuby> Wolfgang was my TA
22:01:06 <ray> cale knows the right way to think about everything
22:01:16 <dons> FireRuby: cool! he's a true haskell god, i hope you know :)
22:01:18 <sorear> dmead: maybe, I don't remember anymore
22:01:20 <shapr> FireRuby: Thaller is really cool, I met him in Sweden in 2003.
22:01:27 <shapr> Thaller is seriously smart.
22:01:27 <Cale> FireRuby: foldr f z replaces each cons (:) in the list with f, and the nil [] at the end with z
22:01:34 <dmead> where is mcmaster?
22:01:36 <dons> FireRuby: he won the ICFP contest in 05 I think
22:01:40 <shapr> dmead: .ca
22:01:45 <dons> and wrote the ghc powerpc native code generator
22:01:47 <dmead> ah
22:01:51 <dons> FireRuby: so you're very lucky :)
22:01:52 * sorear welcomes FireRuby too
22:01:54 <shapr> dmead: http://www.cas.mcmaster.ca/cas/
22:01:56 <lambdabot> Title: Department of Computing and Software
22:02:05 <monochrom> McMaster is in Hamilton, Ontario, Canada.
22:02:06 <FireRuby> Wolfgang THaller is insane in Haskell I know heh
22:02:08 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
22:02:12 <lambdabot> Title: Fold Diagrams - CaleWiki
22:02:14 <FireRuby> Dr Kahl has all this Haskell code on his door
22:02:19 <Cale> Have a look at the top left corner there :)
22:02:19 <dons> heh
22:02:21 <FireRuby> by Thaller
22:02:26 <dons> FireRuby: you should take a photo
22:02:28 <dons> i'd love to see that
22:02:28 <monochrom> Last year FM'06 was in McMaster.
22:02:31 <FireRuby> Cale thanks
22:02:34 <geezusfreeek> yeah, i want to see that
22:02:37 <shapr> FireRuby: You have access to some seriously smart and cool people in the Haskell world, grab onto it!
22:02:48 <FMota> who is Dr. Kahl?
22:02:49 <ray> hug them until they pass out
22:02:50 <Cale> FireRuby: Bug Dr. Kahl to release Data.Rel and HOPS.
22:02:52 <FireRuby> shapr I think Web programming is the future...
22:02:52 <geezusfreeek> yeah, i have some serious envy going on right now
22:02:53 <dons> you should try to do some hacking with Wolfgang
22:02:58 <FireRuby> AKA .NET ROR etc
22:03:05 <FireRuby> Haskell needs some framework like ROR no?
22:03:12 <Pseudonym> FireRuby: The main thing you'll find, though, is that learning Haskell makes your non-functional programming better.
22:03:14 <shapr> FireRuby: I bet you twenty bucks that HAppS is spiffier than RoR.
22:03:14 <dmead> i think webprogramming is poop oo
22:03:20 <dons> shapr: :)
22:03:22 <geezusfreeek> i don't know _anybody_ in my area that knows much about haskell
22:03:25 <FireRuby> WHats Happ5?
22:03:27 <dmead> Pseudonym, it's true
22:03:30 <Pseudonym> Because it forces you to think in different ways.  Eventually, that becomes second-nature.
22:03:31 <shapr> HAppS is what I get paid to hack on.
22:03:38 <dmead> i shat out an xml parser in 30 lines of java last semester
22:03:50 <FireRuby> I used Hugs
22:03:52 <shapr> And if I can get this stuff done tonight, the release of the 0.9 version will very likely be tomorrow!
22:03:55 <FMota> only 30 lines? I'm impressed!
22:04:01 <dons> FireRuby: oh, you should get ghc installed then
22:04:09 <dons> its about 30-50x faster, and a lot more useful
22:04:10 <FireRuby> yeah I got that ghc thingy
22:04:12 <Cale> Dr. Kahl's Data.Rel is really cool, he showed it to me last time I was there, but it doesn't seem like he's done a release yet.
22:04:12 <dons> hugs is a toy for teaching.
22:04:14 <ray> dmead: is that including curly braces?
22:04:22 <monochrom> I don't think web programming is the future. I think it is the present and it is about to decline. I think Second-Life programming is in the future.
22:04:27 <dmead> ray, don't remember
22:04:27 <FireRuby> It says Prelude command line
22:04:34 * sorear wonders if dons would still say that if Ross was on
22:04:35 <shapr> FireRuby: Oh, and #haskell is a really fun and smart collection of people too!
22:04:37 <gour> what's  the status of jhc?
22:04:41 <dmead> but java gives you the DOM for free
22:04:45 <dons> sorear: i'd say its a toy for teaching :)
22:04:55 <sorear> gour: gave it six hours to compile the prelude.  (it didn't make it)
22:05:05 <FMota> monochrom: what about functional programming? Does it fit in your future?
22:05:11 <FireRuby> shapr Yeah thats really cool! I started with ROR on serious web programming stuff at work, thats why I just think in imperative programming
22:05:15 <FireRuby> with .NEt running the market
22:05:16 <dons> FireRuby: have you done the 'haskell in 10 minutes' tutorial?
22:05:25 <gour> sorear: huh :-(
22:05:27 <shapr> sorear: I got jhc libs to compile in half an hour, but then it gave me checksum problems.
22:05:29 <FireRuby> Its an easy switch from .NET to ROR for rapid web app development
22:05:30 <Cale> > foldr (\x y -> concat ["(f ",show x," ",y,")"]) "z" [1,2,3,4,5]
22:05:31 <ray> the future is in holographic AI buddies that sit on your shoulder
22:05:35 <dmead> FireRuby, it's been about a year since i started haskell
22:05:37 <monochrom> functional programming is just a means. but I embrace it for sure.
22:05:38 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
22:05:51 <coffeemug> ROR isn't really that rapid
22:05:56 <shapr> FireRuby: I did Zope/Plone for seven years for a living, so I know that HAppS is spiffy.
22:05:56 <dmead> FireRuby, and now i think purely and have to put forth effort to change to imperative code
22:05:57 <FireRuby> Cale data.rel?
22:05:57 <sorear> shapr: You probably had more than 384MB of primary storage. :)
22:06:03 <shapr> sorear: 4GB
22:06:06 <dons> FireRuby: the interesting thing to think about is multithreaded programming. the imperative languages have a very hard time once you've got more than 2 cores. so the future might be a bit bleak for some imperative work
22:06:20 <Cale> FireRuby: It's an implementation of relations
22:06:21 <dons> since they're basically prematurely optimised for a single cpu model
22:06:25 <Tac-Tics2> Does anyone know why Parsec would be having stack overflows instead of telling me my input is invalid?
22:06:34 <shapr> I gotta get this code done..
22:06:39 <dons> shapr: go go go!
22:06:41 * shapr goes back to paid Haskelling...
22:06:42 <dmead> Tac-Tics, post some code hoss
22:06:47 <FireRuby> implementation for relations? like RDBMS?
22:06:47 <Tac-Tics2> ah yes
22:06:50 <Cale> FireRuby: that is, sets of pairs, if you'd like
22:06:54 <sorear> Tac-Tics2: You're recursing leftly.
22:07:05 <FireRuby> Hey you know what would be acool a HaskellSQL
22:07:06 <Cale> FireRuby: yeah, sort of
22:07:08 <FireRuby> DB server
22:07:10 * FMota wonders what is necessary for a dependently typed system.
22:07:20 <sorear> FMota: Pi abstractions
22:07:25 <FMota> Pi?
22:07:31 <hpaste>  TSac-Tics2 pasted "A simple lambda calculus parser" at http://hpaste.org/2406
22:07:39 <FMota> I really should google that :)
22:07:42 <Tac-Tics2> lols, I can't spell my own name
22:07:46 <dmead> alright
22:07:56 <sorear> hah
22:07:56 <Tac-Tics2> left recursion eh?
22:07:58 <dmead> it's 1:11 am on the east coast
22:07:59 <sorear> I knew it
22:08:02 <sorear> left recursion
22:08:05 <dmead> keep the lights on while i sleep
22:08:09 <FireRuby> WHat does Chris Anand do if I may ask?
22:08:10 <dmead> night all
22:08:14 <FireRuby> In the Haskell COmmunity I mean
22:08:20 <Tac-Tics2> probably my parseApply function
22:08:28 <FireRuby> Doesnt he major in Imaging MRI tech?
22:08:29 <sorear> parseExpr left-calls parseApply left-calls parseExpr
22:08:29 * dmead is away: sleep
22:08:39 <sorear> use chainl1
22:08:40 <Tac-Tics2> yeah
22:08:54 <Tac-Tics2> chainl1?
22:08:56 <FireRuby> dons what do you mean, more than 2 cores?
22:09:05 <monochrom> If you have an array, the i-th item's type depends on i, and you can do typechecking at compile time, that's one thing dependent type is about.
22:09:06 <FireRuby> Cale thanks for the help! reading the stuff now
22:09:10 <dons> FireRuby: more than 2 cores in your machine. multiple processors.
22:09:16 <dons> i've a 16 core machine here.
22:09:17 <Cale> FireRuby: He's working on a compiler for a high level signal processing language
22:09:33 <dons> if i run an imperative language on that, by defualt is uses runs at only 1/16th the speed it should
22:09:34 <Cale> FireRuby: In order that this language can be used to process MRI data :)
22:09:53 <FireRuby> Cale it all makes sense in the end
22:10:03 <FireRuby> Cale are you in reasearch?
22:10:12 <Cale> FireRuby: Not yet.
22:10:24 <dons> so the problem is how to write parallel applications in languages that have long stretches of mutable state, side effecting, sequential code
22:10:33 <Cale> Hopefully at some point, though I really want to be in pure mathematics rather than CS.
22:10:44 <monochrom> parseExpr -> parseApply -> parseExpr   this is an infinite loop.
22:10:45 <geezusfreeek> huh, xchat just froze
22:11:06 <Tac-Tics2> monochrom: yes, I see that now ;-)
22:11:19 <monochrom> I'm slow.
22:11:21 <FireRuby> Im finishig software Engineering if I passed Kahls course this sem
22:11:31 <nilton> If I do: data Color = Red | Green | Blue deriving (Eq, Ord, Show, Read)
22:11:39 <nilton> why show "Red" does not work?
22:11:45 <geezusfreeek> anyway, as i was trying to say when xchat died, programming with ruby on rails feels to me a lot like trying to start at too quick a pace in a long marathon... lots of distance covered at first, but then you pay for it all later
22:11:46 <nilton> ops.. that is
22:11:49 <Cale> nilton: show Red ?
22:11:50 <nilton> read "Red"
22:12:02 <Cale> nilton: make sure it knows which type it's reading
22:12:07 <Cale> read Red :: Color
22:12:09 <Cale> er
22:12:11 <geezusfreeek> i was on the bandwagon for a while, but i just have been turned off to so-called "rapid development"
22:12:11 <Cale> read "Red" :: Color
22:12:40 <Tac-Tics2> How do I eliminate this left recursion? (or how do you use chainl1?)
22:12:48 <nilton> Cale: nice, thanks
22:12:59 <Tac-Tics2> curse my computer lang professor for being so horrid
22:13:21 <Cale> nilton: In an actual program, that doesn't really present a problem so often, since usually the rest of the program determines what it is that you're trying to read.
22:13:32 <shapr> Foo, who didn't write a Read instance for ClockTime?
22:13:33 * shapr grumbles
22:13:47 <sorear> FireRuby: Still think FP sucks? :)
22:13:50 <Cale> FireRuby: Make sure to let us know if you have any trouble understanding things. :)
22:14:13 <FireRuby> Cale: wow you guys are great, didnt expect this!
22:14:13 <nilton> Cale: yeah. that makes sense. i'm trying it in the interpreter now.
22:14:15 <dons> > map (\x -> x ^ 2) [1..] -- and have a lambda!
22:14:23 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
22:14:26 <FireRuby> very helpfull, very nice community you got!
22:14:43 <FireRuby> I will let you know how things go, thanks for the help!
22:14:54 <dons> cool
22:14:57 <FireRuby> sorear I just have to learn it better heh
22:14:57 <Cale> You're quite welcome :)
22:15:02 <sorear> > nubBy (((>1).).gcd) [2..]
22:15:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:15:31 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
22:15:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:15:41 <FireRuby> whats that
22:15:48 <Cale> Infinite list of primes
22:15:52 <monochrom> I once wrote a lambda parser too. I did something like: parseExpr = parseLambda +++ chainl1 (parseParen +++ parseVar) (return Apply).  Try that or some variation of that.
22:16:07 <FireRuby> whats lambdabot
22:16:09 <dons> FireRuby: little prime number generators in haskell
22:16:18 <dons> ?index map
22:16:18 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
22:16:18 <pjd> let (...) = (.).(.) in nubBy ((>1) ... gcd) [2..]
22:16:20 <dons> ?src map
22:16:20 <lambdabot> map _ []     = []
22:16:20 <lambdabot> map f (x:xs) = f x : map f xs
22:16:23 <sorear> FireRuby: lambdabot is dons' pet
22:16:25 <dons> ?docs Data.List
22:16:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:16:32 <sorear> @version
22:16:32 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
22:16:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:16:33 <FireRuby> ?src map
22:16:33 <lambdabot> map _ []     = []
22:16:33 <lambdabot> map f (x:xs) = f x : map f xs
22:16:34 <dons> just a helpful channel/haskell bot
22:16:35 <FireRuby> cool
22:16:45 <FireRuby> lol an IRC Ghc
22:16:49 <dons> yep.
22:17:04 <dons> > reverse "haskell is fun"
22:17:06 <lambdabot>  "nuf si lleksah"
22:17:10 <Cale> > foldr (\x y -> concat ["(f ",show x," ",y,")"]) "z" [1,2,3,4,5]
22:17:11 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
22:17:17 <dons> cute :)
22:17:25 <sorear> @djinn a -> b
22:17:25 <lambdabot> -- f cannot be realized.
22:17:28 <sorear> @djinn a -> a
22:17:28 <lambdabot> f a = a
22:17:35 <Cale> > foldl (\x y -> concat ["(f ",x," ",show y,")"]) "z" [1,2,3,4,5]
22:17:36 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
22:17:46 <FireRuby> heh cool
22:17:59 <newsham> what does ghci do about MAP_32BIT on openbsd/amd64?
22:18:00 <monochrom> Hrm, I forgot why I did not do: parseExpr = chainl1 (parseLambda +++ parseParen +++ parseVar) (return Apply). You may try that too!
22:18:05 <geezusfreeek> @pl (\x y -> concat ["(f ",x," ",show y,")"])
22:18:06 <lambdabot> ((join . ("(f " :)) .) . (. ((" " :) . (: [")"]) . show)) . (:)
22:18:08 <geezusfreeek> ew
22:18:16 <sorear> newsham: probably nothing, it uses 64 bit words
22:18:17 <dons> newsham: hmm, there was some patch to the head recently about that
22:18:20 <Cale> heh
22:19:06 <Cale> Kind of surprising that it knows how to deal with that concat though.
22:19:25 <newsham> the reason I ask is because I have FreeBSD/amd64 and it seems to me that if OpenBSD/amd64 supports ghci, then FreeBSD should easily support it as well
22:19:27 <ray> does cabal-install actually work?
22:19:31 <newsham> but so far there is no working ghci for FreeBSD
22:19:42 <ray> there isn't?
22:19:42 <Cale> ray: I think I heard some positive reports
22:20:07 <newsham> dons: didnt ghci 6.6.1 run on OpenBSD/amd64?
22:20:08 <sjanssen> ray: I've had good experiences with it the past several weeks
22:20:19 <ray> i'll have to not get a 64-bit processor then :)
22:20:34 <newsham> ray: or run linux on it..
22:20:35 <shapr> mmm 64 bit
22:20:41 <ray> no way!
22:20:46 <newsham> smart lad ;-)
22:20:49 <keturn> indentation question.  emacs wants to indent the thing that follows 'module Foo where'.  Most source I see does not have the entire module indented.
22:20:59 <shapr> ray: cabal-install works!
22:21:25 <ray> cool, you never know what "is in development" *really* means
22:21:59 <Cale> Heh, I just noticed something about foldl.com. It's starting at the end of an infinite list.
22:22:13 <monochrom> I know why now. In a lambda expression like "Lx. A B C", the scope extends to as right-most as possible. So you have to pull parseLambda out of the chainl1 loop.
22:22:14 <sciolizer> keturn: just indent your module line negative four spaces. :)
22:22:31 <shapr> keturn: if you have an import or function definition at the beginning of the line after module Foo where, it should do okay.
22:22:32 <opqdonut> Cale: heh
22:23:01 <monochrom> Also, +++ is the same as <|>.
22:23:41 <FMota> What's foldl.com supposed to do?
22:23:47 <monochrom> excuse. +++ is not the same as <|>. I had +++ because I used ReadP. For Parsec use <|>.
22:23:54 <Cale> FMota: demonstrate the left fold
22:23:59 <Cale> FMota: see also foldr.com
22:24:01 <FMota> and which one's the tail recursive one -- foldl or foldr?
22:24:04 <monochrom> foldl.com is supposed to fold the dotcom? :)
22:24:05 <ray> hey, that's cool!
22:24:08 <ray> better than something.com
22:24:18 <Cale> FMota: foldl
22:24:25 <FMota> hmm
22:24:50 <FMota> is foldl of type (b -> a -> b) -> b -> [a] -> b ?
22:24:51 <Cale> FMota: so it would have to run infinitely long to produce the result you see there (and somehow stop?)
22:24:57 <Cale> :t foldl
22:25:04 <Cale> ...
22:25:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:25:07 <FMota> :o
22:25:13 <FMota> yep
22:25:27 <Cale> :t foldr
22:25:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:25:42 <FMota> :) good, I didn't have them mixedx up then
22:25:49 * FMota is happy.
22:25:56 <FMota> *mixed
22:26:31 <FMota> so, you're infinite program...
22:27:15 <keturn> emacs's first guess seems to be wrong a goodly amount of the time, actually, but at least for subsequent lines it gets it right if I hit tab enough times.
22:27:30 <FMota> inf1list = 1 : inf1list ;    inf = foldl (+) 0 inf1list
22:27:50 <newsham> ?type fold . com
22:27:52 <lambdabot> Not in scope: `fold'
22:27:52 <lambdabot>  
22:27:52 <lambdabot> <interactive>:1:7: Not in scope: `com'
22:27:56 <newsham> ?type foldl . com
22:27:57 <lambdabot> Not in scope: `com'
22:28:08 <Cale> :t foldl . ?com
22:28:10 <lambdabot> forall a b a1. (?com::a1 -> a -> b -> a) => a1 -> a -> [b] -> a
22:28:22 <shapr> keturn: Yeah, it's hard to deal with the offside rule well.
22:28:48 <Cale> keturn: I always just turned off smart indenting when I used emacs.
22:29:07 <FMota> TextMate kinda annoys me sometimes.
22:29:31 <FMota> Mostly when I copy/paste code, it decides to reindent everything
22:29:35 <Cale> There's a simple indent mode which makes tab move over to the next notable spot relative to the line above, or else some fixed width if there are no more.
22:30:27 <Cale> There's something just wrong about hitting tab and having the indentation level decrease.
22:31:23 <bos> i have a data structure question. i want to write about a useful data structure, for which the usual imperative treatment is nasty and complicated.
22:31:40 <bos> the choices i'm weighing are red-black trees and suffix trees.
22:31:47 <newsham> anyone familair with the "Scala" language?  (object-fnctional language)
22:32:03 <bos> red-black because the balancing is so easy with pattern matching.
22:32:44 <bos> suffix because they're cool, and i don't feel very excited about covering a balanced tree when the right answer is "use Data.Map and expend the brain cells on something else".
22:33:02 <bos> opinions, o peanut gallery?
22:33:19 <sjanssen> bos: suffix trees are certainly more unique
22:34:07 <newsham> huh, a monad example in the scala example pages: http://www.scala-lang.org/docu/examples/files/callccInterpreter.html
22:34:10 <lambdabot> Title: sources/docu/examples/files/callccInterpreter.scala, http://tinyurl.com/339ntj
22:34:41 <bos> building a suffix tree takes about 10 lines of code, and lets me introduce lists as control flow, list comprehensions as nested loops, and such.
22:34:43 <sorear> bos: even for suffix trees, if you have the time to write a tutorial, you should use your brain cells instead to write a reusable library
22:34:53 <bos> @where suffixtree
22:34:53 <lambdabot> I know nothing about suffixtree.
22:35:08 <bos> @where+ suffixtree http://www.serpentine.com/software/suffixtree
22:35:08 <lambdabot> Done.
22:35:11 <sjanssen> @hackage suffixtree
22:35:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/suffixtree
22:35:24 <bos> sorear: this is for the book. i gotta write about something.
22:35:57 <bos> ok, suffix trees it is. thanks all.
22:43:24 <hpaste>  Tac-Tics2 annotated "A simple lambda calculus parser" with "An almost fixed Version of Lambda Calc Parser" at http://hpaste.org/2406#a1
22:44:12 <Tac-Tics2> it doesn't seem to recognize things correctly, but I think I got my grammar right this time
22:45:28 <Tac-Tics2> But on "Lx.x" it gives me "unexpected end of input, expecting lowercase letter"
22:47:33 <glen_quagmire> in ghc, how do I make it generate binary only? without generating intermediate files?
22:48:53 <sorear> Submit a patch
22:49:01 <sorear> I don't think it would be accepted though
22:49:15 <glen_quagmire> i can't find available options in user guide
22:49:15 <sorear> It seems like a very strange desire to me
22:49:33 <sorear> Going completely in the face of the UNIX philosophy
22:50:12 <Tac-Tics2> I thought the UNIX philosophy was give the user as many options flags as you can =-)
22:50:34 <glen_quagmire> oh ffound it
22:50:53 <Tac-Tics2> @type IO a -> a
22:50:58 <lambdabot> <command line>:
22:50:58 <lambdabot>     Could not find module `L':
22:52:43 <ray> that's the opposite of the unix philosophy
22:53:44 <Tac-Tics2> god, I really wish Haskell had some convinient way of debugging
22:55:28 <ray> why is ghc telling me that it can't find Data.Binary because it's a member of package binary-0.3 which is hidden, and how do i fix this?
22:55:52 <sjanssen> ray: add binary to build-depends
22:55:57 <shapr> beat me to it
22:56:41 <glen_quagmire> i think it's impossible to make ghc to automatically delete .o and .hi after linking it to a binary
22:57:03 <sjanssen> glen_quagmire: you could -odir and -hidir to a temporary directory
22:57:21 <sorear> glen_quagmire: are you asking about clean builds, or are you asking about not generating tempfiles at all?
22:57:28 <glen_quagmire> clean builds
22:57:38 <sorear> glen_quagmire: oh, *that* makes sense.
22:57:49 <sorear> glen_quagmire: use -odir/-hidir, preferably via Cabal
22:59:21 <glen_quagmire> ok thank you sjanssen, sorear
23:02:09 <glen_quagmire> http://www.haskell.org/ghc/docs/latest/html/users_guide/modes.html#options-order    is there a way to stop after .c file is generated? -C option generates .hc file which looks very  weird c code
23:02:11 <lambdabot> Title: 4.4. Modes of operation, http://tinyurl.com/2dwnn7
23:04:43 <sorear> .hc *is* .c
23:04:58 <sorear> and yes, it generates very wierd C
23:05:09 <sorear> it basically uses gcc as a portable macroassembler
23:05:10 <glen_quagmire> w00t! mv blah.hc blah.c && gcc blah.c      tones of errors
23:05:29 <sorear> i'll bet they all start with "cannot find include file"
23:07:10 <glen_quagmire> oh yah i had to scroll all the way up
23:07:16 <ray> ooh, that is very assemblerish
23:09:29 <shapr> glen_quagmire: What are you doing?
23:10:25 <ray> hey, there's other errors if i add the right include directory
23:10:46 <glen_quagmire> shapr: i was trying to see if haskell outputs readable C code
23:10:51 <shapr> oh, it doesn't :-)
23:11:13 <shapr> At least, not from the average C programmer's viewpoint.
23:11:19 <shapr> glen_quagmire: What do you think, is it readable?
23:12:13 <glen_quagmire> no. it's like worse than obfuscated perl contest entry
23:14:48 <Pseudonym> I don't think that any lazy language would be able to produce readable C code.
23:14:57 <Pseudonym> Strict language, perhaps.
23:15:43 <FMota> do you mean "produce" as in, for that languages compiled code?
23:15:50 <Pseudonym> Yeah.
23:15:57 <FMota> well yeah
23:16:24 <FMota> but in C++ you can overload operators, and it looks closer to what you actually want.
23:16:29 <Pseudonym> Though I might add, compiled Prolog might be even worse.
23:16:43 <OceanSpray> how do I pattern match against two patterns?
23:16:55 <Pseudonym> OceanSpray: How about wrapping them in a pair?
23:16:56 <OceanSpray> that is, case a of <either this or that> ->
23:17:03 <Pseudonym> The pair gets compiled away.
23:17:06 <Pseudonym> Oh.
23:17:11 <Pseudonym> You mean... right.
23:17:16 <Pseudonym> Two suggestions.
23:17:18 <Pseudonym> 1. Use a let.
23:17:20 <Pseudonym> 2. Use a view.
23:17:26 <OceanSpray> huh?
23:17:38 <Pseudonym> let rhs = ... in case expr of { Pat1 -> rhs; Pat2 -> rhs }
23:17:54 <Pseudonym> That's the let answer.
23:18:03 <Pseudonym> But that arguably obscures the meaning.
23:18:14 <OceanSpray> yeah, kind of kludgy
23:18:23 <Pseudonym> Views are pretty good, though.
23:18:32 <Pseudonym> Let me think of a specific example.
23:18:32 <FMota> maybe OceanSpray means: how can I pattern match both A and B
23:18:48 <Pseudonym> OK.
23:18:49 <FMota> such that the function only applies to things with boh patterns
23:18:56 <OceanSpray> naw
23:18:58 <FMota> ... you can also use a let, I guess
23:19:00 <Pseudonym> data Foo = A Int Char | B Int Char | C String
23:19:08 <Pseudonym> And you want to match A or B.
23:19:17 <Pseudonym> Then you could just do this:
23:19:28 <Pseudonym> data FooView = IntChar Int Char | Other
23:19:40 <Pseudonym> fooView :: Foo -> FooView  -- which does the obvious thing
23:19:46 <Pseudonym> Then case fooView foo of { ... }
23:19:59 <FMota> :o
23:20:14 <FMota> anyway, gnight
23:20:16 <OceanSpray> that's not very... elegant.
23:20:39 <OceanSpray> a new data declaration just for one case expression
23:20:41 <OceanSpray> oh well
23:20:45 <OceanSpray> I'll go with the let
23:20:53 <Pseudonym> It's more useful if you use the view in more than one place.
23:21:02 <Pseudonym> But a data declaration is only one line. :-)
23:22:01 <shapr> Isn't there something in System.Posix that gives me the filepath of the running binary?
23:23:09 <shapr> I can't find it, but I thought it was there.
23:24:15 <dons> newsham: yeah, amd64 is ok
23:24:36 <sorear> shapr: No POSIX system provides that
23:24:41 <shapr> oh
23:24:48 <sorear> shapr: The question is meaningless in the presence of hard links
23:24:53 <shapr> fair enough
23:25:13 <Pseudonym> Hell, some pacemakers have a POSIX interface.
23:25:27 <flux> sorear, why is it meaningless? some programs use that information even in the presence of hardlinks
23:25:49 <flux> (multicall-binaries that inspect their argv[0] to determine how to operate)
23:26:11 <Pseudonym> argv[0] is what was on the command line.
23:26:17 <Pseudonym> Not the filename of the executable.
23:26:19 <sorear> flux: If ghc is running, and ghc is linked to by both /usr/bin/ghc and /usr/bin/ghci, what should MyExecutableFileName() return?  Argv is just a convention
23:27:05 <flux> sorear, the name of the binary with which the program was invoked with?
23:27:43 <ray> you can actually give something you're exec()ing an arbitrary argv[0]
23:27:43 <flux> sorear, infact it might be impossible to (efficiently) retrieve the other name given an inode; you might just as well consider them separate entities
23:27:51 <flux> sure
23:28:35 <flux> really determining the binary name isn't portable, but I'm pretty sure for example linux /proc/$$/exe is reliable even in the presence of hardlinks (it does follow softlinks though)
23:28:55 <Pseudonym> That's not POSIX, though.
23:29:45 <flux> true, but the point was just that the concept of binary name is not meaningless even in the presence of hard links
23:50:26 <RogerTaylor> Hello, I was wondering if someone could help me get cabal-install from darcs to compile using GHC 6.6.1?
23:52:59 <glguy> RogerTaylor: what was the issue?
23:54:37 <RogerTaylor> firstly, there's a need to add a "Simple" into a module path somewhere
23:55:02 <RogerTaylor> you'll find that pretty quickly if you try to build cabal-install on a clean-ish GHC 6.6.1 + dependencies install
23:55:07 <RogerTaylor> the next one is:
23:55:16 <RogerTaylor> src/Network/Hackage/CabalInstall/Update.hs:51:45:
23:55:16 <RogerTaylor>     Couldn't match expected type `PackageDescription'
23:55:18 <RogerTaylor>            against inferred type `Distribution.PackageDescription.GenericPackageDescription'
23:55:18 <RogerTaylor>       Expected type: [PackageDescription]
23:55:18 <RogerTaylor>       Inferred type: [Distribution.PackageDescription.GenericPackageDescription]
23:55:18 <RogerTaylor>     In the second argument of `map', namely `packageDescriptions'
23:55:19 <RogerTaylor>     In the second argument of `($)', namely
23:55:21 <RogerTaylor>         `map (parsePkg server) packageDescriptions'
23:55:23 <RogerTaylor> (sorry about that)
23:55:55 <eivuokko> Do you have newest Cabal or the one that comes with ghc 6.6.1?
23:56:08 <RogerTaylor> the darcs cabal-install requires Cabal-1.1.7
23:56:12 <RogerTaylor> so i installed that
23:56:30 <RogerTaylor> no problems there
23:58:20 <eivuokko> I am not sure what cabal-install did with deps
23:58:43 <eivuokko> But I think that it needs hacking now that configurations are in.
23:59:08 <RogerTaylor> ok
23:59:24 <RogerTaylor> is there a cabal-install I can use to install Bringert's HOPE?
23:59:31 <RogerTaylor> the deps for that are a bit crazy
