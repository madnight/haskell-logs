00:00:09 <glguy> English, please :)
00:00:14 <glguy> or take it to #haskell.au
00:00:19 <dons> hhah
00:00:28 <dons> its beer o'clock! we're on .au time now
00:00:39 <TSC> I'm already home!
00:00:44 <kfish> dons: it's always beer o'clock in .au
00:00:50 <dons> kfish: ssssh!
00:00:53 <LeCamarade> #haskell-au bots have the world's most powerful venom.
00:01:21 <ikegami--> hehe
00:01:24 <glguy> @go galah.org
00:01:26 <lambdabot> http://www.galah.org/
00:01:26 <lambdabot> Title: Gay and Lesbian Atheists and Humanists (GALAH)
00:01:32 <glguy> interesting...
00:01:49 <TSC> http://en.wikipedia.org/wiki/Galah#Australian_slang_term
00:01:49 <dons> hah
00:01:53 <dons> ?temp
00:01:53 <lambdabot>   now 22.2°, min 11.1°, max 27.4°, rain 0.0mm, wind 13km/h ESE
00:01:56 <dons> mm. spring!
00:01:57 <dolio> Yeah, who uses "and" in an acronym?
00:02:17 <Pseudonym> Is that CPU temperature?
00:02:22 * glguy finds a reference
00:02:23 <glguy> http://www.koalanet.com.au/australian-slang.html
00:02:24 <lambdabot> Title: Australian slang dictionary
00:02:28 <dons> Pseudonym: nah, bom.gov.au
00:02:41 <dons> its tropical up here today
00:02:42 * Pseudonym was wondering how likely it was to find rain inside the box
00:02:52 <Pseudonym> Yeah, it was 25C here today.
00:02:55 <LeCamarade> :o)
00:03:14 <Pseudonym> Just so long as lambdabot doesn't get horse flu, we're right.
00:03:23 <glguy> "Bring your own grog, you bludger!
00:03:52 <dons> glguy: spoken like a native.
00:04:10 <glguy> Serious... an "icy pole" is a popsicle?
00:04:40 <dons> icey, pole == icy pole
00:04:42 <TSC> Too right, mate
00:04:58 <glguy> That london to a brick, eh mate?
00:05:24 <TSC> I've never heard that one, actually
00:05:25 <glguy> I added that little flourish on the end on my own ;)
00:05:25 <dons> you'd only hear that in a pub though, I think
00:05:26 <glguy> :(
00:05:44 <dons> bit archaic
00:06:56 <profmakx> perhaps we should replace @(y)arr with @dons
00:07:13 <LeCamarade> ?quote dons
00:07:13 <lambdabot> dons says: [When asked what qualifications Guido van Rossum has...] a chip on his shoulder?
00:07:20 <Pseudonym> That's as old as calling someone a "straw 'at coot".
00:07:40 <LeCamarade> ?quote dons
00:07:40 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
00:07:40 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
00:07:45 <Pseudonym> Actually, I think that should be "stror 'at coot".
00:08:16 <glguy> dons: I read the end of that quote before the beginning... I assumed you mean that perl and gentoo were destroying opensource
00:08:22 <glguy> and then I read the rest ;)
00:08:46 <profmakx> i thought more of an aussie-quote-thing
00:09:02 <profmakx> she could as well only output "no worries, mate" then
00:09:05 <glguy> @yarr isn't really a .au thing, is it?
00:09:05 <lambdabot> Get out o' me way, yeh landlubber
00:09:17 <profmakx> thats the point :)
00:09:27 <profmakx> i never said it was
00:09:30 <glguy> oh..
00:09:44 <profmakx> perhaps "replace
00:09:50 <profmakx> " was the wrong word
00:09:51 <TSC> Along the same lines as @yarr, rather than replacing it
00:10:25 <glguy> didn't you hear? the U.S. drafted dons... you'll need to pick someone else ;)
00:10:43 <TSC> @crikey
00:10:44 <lambdabot> Unknown command, try @list
00:10:52 <Runaro^BRS> is there a function [a -> a] -> a -> [a] ?
00:11:13 <LeCamarade> <lambdabot> It's Khaki Friday!
00:11:16 <Runaro^BRS> @hoogle  [a -> a] -> a -> [a]
00:11:16 <glguy> Runaro^BRS: sequence
00:11:20 <lambdabot> No matches, try a more general search
00:11:33 <TSC> You mean [a -> b] -> a -> [b], more generally?
00:11:36 <glguy> > sequence [ (*2) , (+3) ] 5
00:11:41 <lambdabot>  [10,8]
00:12:01 <olsner> @type sequence
00:12:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:12:03 <glguy> > map ($ 5) [  (*2) , (+3) ] -- would work too
00:12:05 <lambdabot>  [10,8]
00:12:50 <olsner> cool, m = (a ->)
00:13:54 <Runaro^BRS> TSC: yes
00:13:56 <sieni> @pl (\l x -> map ($ x) l)
00:13:57 <lambdabot> flip (map . flip id)
00:14:34 <Runaro^BRS> Hmm... sequence does work like that, but I don't quite understand why.
00:15:12 <TSC> Runaro^BRS: Replace the "m" in the type with (b ->)
00:15:23 <TSC> (Because (b ->) is an instance of Monad)
00:15:54 <Runaro^BRS> @kind (b ->)
00:15:56 <lambdabot> parse error on input `)'
00:16:38 <glguy> > () -- ( dons, should this break?
00:16:38 <lambdabot>  Unbalanced parenthesis
00:17:23 <Runaro^BRS> TSC: Okay then :-)
00:18:05 <dons> glguy: that's Language.Haskell breaking
00:18:15 <glguy> ok
00:18:18 <kfish> glguy, bloody oath, especially when they've run out of vodka
00:18:18 <kfish> flaming popsicles, the lot of them
00:18:37 <TSC> Runaro^BRS: In that monad, sequence means "apply all the functions in this list to some argument and give me a list of all the results"
00:20:04 <Pseudonym> exit
00:20:08 <Pseudonym> Whoops.
00:20:10 <Pseudonym> Bye. :-)
00:22:01 <Runaro^BRS> @src sequence
00:22:01 <lambdabot> sequence ms = foldr k (return []) ms
00:22:01 <lambdabot>     where
00:22:01 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
00:23:09 <pjd> @kind (->) b
00:23:11 <lambdabot> Not in scope: type variable `b'
00:23:17 <Runaro^BRS> Wow, that makes a creepy kind of sense.
00:23:20 <pjd> peh
00:24:05 <pjd> Runaro^BRS: arguably nicer is foldr (liftM2 (:)) (return [])
00:24:33 <Runaro^BRS> I'll take your word for it
00:24:57 <pjd> that k definition is the long way of spelling liftM2
00:25:24 <Paczesiowa> are haskell arrays good way to implement arrays in another language (trying to write interpreter for simple c-like language)? if so, which haskell array should I use?
00:25:36 <pjd> it's just liftM/fmap for functions of 2 arguments instead of one
00:26:34 <Runaro^BRS> I see.
00:27:23 <dons> Paczesiowa: a mutable UArray?
00:27:37 <Runaro^BRS> > sequence (map (*) [1,2,3,4]) 5
00:27:39 <lambdabot>  [5,10,15,20]
00:27:43 <Runaro^BRS> cool
00:27:56 <pjd> Runaro^BRS: in the same way that return is like liftM/fmap for functions of 0 arguments (i.e. values) instead of one
00:28:15 <glguy> > map (* 5) [1..4]
00:28:17 <lambdabot>  [5,10,15,20]
00:28:27 <glguy> > [5,10..20] -- ( :)
00:28:28 <lambdabot>  [5,10,15,20]
00:28:57 <pjd> Runaro^BRS: so really, that is just foldr (:) [] (the identity function for lists), with (:) and [] lifted into the monad
00:31:19 <Runaro^BRS> @type sequence (map (*) [1,2,3,4]) 5
00:31:21 <lambdabot> forall a. (Num a) => [a]
00:37:12 <olsner> "Putting another two women on the baby project will not get it done in three months instead of nine."
00:38:20 <glguy> but adding more wives would make you age faster
00:39:38 <Runaro^BRS> ghci gives me a compilation error here
00:39:39 <Runaro^BRS>     No instance for (Monad ((->) a))
00:39:39 <Runaro^BRS>       arising from use of `sequence'
00:39:51 <Runaro^BRS> what gives?
00:40:03 <glguy> Runaro^BRS: import Control.Monad.Instances
00:40:07 <glguy> if you have 6.6.X
00:41:49 <Runaro^BRS> that worked. Thanks@
00:47:47 <scodil> does mapping a newtype constructor turn into actual code? or does it get optimized away?
00:48:45 <TSC> I think the point of newtype (as opposed to data) is that it's optimised away
00:49:03 <glguy> the question is, i imagine, does it get optimized away into: map id
00:49:20 <glguy> or erased altogether
00:49:28 <scodil> I sometimes see newtype constructors in profiling
00:49:42 <scodil> at least i recal seeing them... maybe
00:49:53 <taruti> scodil: profiling may alter things
00:53:26 <joacimm> ?src wc
00:53:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:53:48 <joacimm> ?src words
00:53:49 <lambdabot> words s = case dropWhile isSpace s of
00:53:49 <lambdabot>     "" -> []
00:53:49 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:53:54 <joacimm> ?src wc
00:53:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:55:32 <desp> hmm
00:56:14 <desp> I want to keep a value from getting garbage-collected by retaining an IO () action that refers to the value
00:56:30 <desp> but I don't have anything meaningful to do with the value inside said action
00:56:40 <desp> what could I do that won't be optimized away as dead code?
00:56:52 <TSC> Something with an IORef ?
00:58:27 <desp> isn't the optimizer smart enough to know that creating a new IORef that isn't used anywhere is dead code?
00:58:39 <desp> the compiler will surely ensue a warning about that
00:58:53 <TSC> Print it to /dev/null (:
00:59:20 <desp> glguy: ping?
00:59:35 <glguy> ?
00:59:37 <scodil> desp: StablePtr?
01:00:54 <desp> scodil: can you read what I've just written, substituting StablePtr for IORef?
01:01:04 <desp> :)
01:03:00 <desp> I was hoping someone actually knows what GHC considers dead code
01:04:18 <desp> TSC: right, I'll create an IORef somewhere else and clear it in the action. :) thanks.
01:07:10 <hpaste>  manu annotated "Norvig's Sudoku Solver in Haskell" with "Daniel Fischer's improved version" at http://hpaste.org/2452#a1
01:22:46 <dhpeterson> :t Addr#
01:22:52 <lambdabot> Not in scope: data constructor `Addr#'
01:23:03 <Radek> Hi. Can someone do me a favour and point to me to appropriate place (wiki, or something) that explains '$ notation'? I'm trying to understand what it means, and searching for '$' is not very google friendly. Thanks in advance.
01:23:24 <dhpeterson> :t ($)
01:23:26 <lambdabot> forall a b. (a -> b) -> a -> b
01:23:35 <TSC> Radek: Do you mean something like "map ($ 4) [id, (*2)]"
01:24:03 <dhpeterson> u mean the infix operator
01:24:04 <dhpeterson> ?
01:24:11 <Radek> I mean something like "afterResponse aboutDialog $ \_ -> widgetHide aboutDialog"
01:24:16 <dhpeterson> yep
01:24:25 <glguy> Radek: f $ x = f x
01:24:38 <glguy> ($ x) = \f -> f x
01:25:22 <Radek> so does it mean that it is equal to "afterResponse aboutDialog ( \_ -> widgetHide aboutDialog)"??
01:25:30 <glguy> Radek: yeah
01:25:41 <Radek> hurray! Thanks, That made my day. :)
01:25:42 <glguy> $ is often used to reduce the number of parentheses
02:00:28 <takamura> hi
02:24:25 <etnt> anyone knows of a Haskell-98 parser made with Parsec ?
02:25:57 <xerox> etnt: it is not possible. Well, it is with the Parsec monad transfomer now (:
02:27:27 <dolio> What do you need that for? Reading fixities from other files?
02:29:27 <etnt> xerox: ok, nice are there any examples of this somewhere?
02:30:24 <mux> so ParsecT is done now?
02:30:24 <lambdabot> mux: You have 1 new message. '/msg lambdabot @messages' to read it.
02:30:51 <etnt> dolio: was your question meant for me? if so, then just for pleasure hacking... :-)
02:31:05 <dolio> It was for xerox.
02:31:23 <etnt> dolio: aha, ok
02:33:32 <xerox> dolio: check out the report description of the layout rule.
02:33:58 <dolio> Huh, that wasn't the response I was expecting. :)
02:35:15 <xerox> mux: yes, but it is not realeaseable as it is, for instance I need to write some documentation first.
02:35:40 <xerox> etnt: I thnk one example will come with the next release, if Philippa is up for it.
02:36:26 <etnt> xerox: very nice, meanwhile are there any examples of parsing subsets of Haskell with Parsec ?
02:40:55 <dolio> Hmm, nothing's jumping out at me.
02:44:40 <mux> xerox: I long for it!
02:45:17 * mux wants ParsecT IO
02:46:30 <olsner> why is it not possible to parse haskell without a parsec monad transformer?
02:46:50 <Syzygy-> olsner: I wouldn't expect it to be impossible.
02:47:14 <olsner> "<xerox> etnt: it is not possible. [...]"
02:47:17 <Syzygy-> However, you might need to write an entirely different parser.
02:47:40 <Syzygy-> (read too little backlog; and my point was that if you don't build on Parsec, there's nothing saying you can't build a Haskell parser...)
02:47:40 <olsner> e.g. when importing modules?
02:53:47 <b_jonas> hi #haskell. someone on I think this channel has recommended me the article "http://home.pipeline.com/~hbaker1/NoMotionGC.html"
02:53:48 <lambdabot> Title: ACM Sigplan Notices 27,3 (March 1992), 66-70.
02:54:01 <b_jonas> about real-time garbage-collectors
02:54:08 <b_jonas> I'd like to thank whoever it was
02:54:21 <b_jonas> because it had a link to the other article http://home.pipeline.com/~hbaker1/RealTimeGC.html
02:54:22 <lambdabot> Title: Comm. of the ACM 21, 4 (April 1978), 280-294.
02:54:37 <b_jonas> which answered what I didn't understand about real-time gcs
02:54:54 <b_jonas> namely how they can not blow up in memory usage
02:56:11 <olsner> oh, The Minsky-Fenichel-Yochelson-Cheney-Arnborg Garbage Collector.
02:56:40 <b_jonas> yep
02:56:59 <b_jonas> the trick is that it allocates new cells as if they were already marked
02:57:18 <b_jonas> so it only has to traverse those cells that were allocated before the last generation flip
03:00:01 <olsner> sounds simple enough
03:00:31 <b_jonas> yes, once you know it
03:01:11 <olsner> I should write a GC some day... any day now ;-)
03:02:55 <b_jonas> the trick is, if you try to traverse those temporary data that gets created and forgotten within a generation, then I think there's no bound to how much memory you need
03:03:17 <b_jonas> even though you can guarantee that each generation will finish in a time proportional to the memory needed before it,
03:03:48 <b_jonas> there's no bound to that memory from only the amount of data accessible at any single time instant
03:04:00 <b_jonas> so I don't see why it doesn't blow up
03:04:31 <b_jonas> but the way the algorithm really works, you never traverse more data than was accessible at the last flip
03:04:54 <b_jonas> (plus you do at most as much extra work as the data allocated)
03:05:03 <b_jonas> so the usage is limited, as shown in the article
03:06:09 <b_jonas> I should write a gc once too -- though I've already written a reference counter once and it works
03:06:32 <olsner> reference counter? but that doesn't work with cyclical data, right?
03:06:38 <b_jonas> yep
03:06:46 <b_jonas> it did leak with cyclical data
03:07:35 <b_jonas> I tried it by making it print the number of allocated structures at the end of the program and it always prints 0 unless you create a cyclical data or you exit with an exception
03:07:46 <b_jonas> (I didn't know enough at that time to make it exception safe)
03:07:56 <olsner> okay
03:08:18 <b_jonas> what's worse is that my code is ugly
03:08:29 <b_jonas> you could implement refcounters with cleaner code
03:09:49 <olsner> proof by lack of counter-proof or proof by belief then ;-)
03:11:06 <b_jonas> well, yes
03:20:00 <pjd> olsner: you can combine reference counting with cycle collection, though
03:20:13 <Paczesiowa> is there any array howto recent enough to work with current libs? http://www.haskell.org/tutorial/arrays.html has functions that don't exist (mkArray)
03:20:17 <lambdabot> Title: A Gentle Introduction to Haskell: Arrays
03:20:25 <pjd> Python does this, for example
03:21:07 <olsner> I was under the impression that it was faster to just run the cycle collector on all the data and skip the reference counting
03:21:17 <b_jonas> pjd: so does mathemetica
03:21:23 <b_jonas> the article mentions that as well
03:21:56 <b_jonas> but the problem with it is that you can't know how much data the gc would release that the refcounter didn't, so you have to keep running it continouously
03:21:59 <pjd> olsner: the cycle collector depends completely on reference counting
03:22:45 <augustss> I don't think you can parse Haskell even with a Parsec monad transformer.
03:22:45 <lambdabot> augustss: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:22:48 <pjd> it's not the same as a tracing collector
03:22:54 <b_jonas> at least, I think mathematica does that (for copy-on-write madness I think) but you can't be sure cause it's closed source
03:23:20 <olsner> there's more to garbage collection than I know, indeed ;-)
03:24:44 <fasta> How's the combinator called that is the same as: a <- a; b<-b;c a b?
03:24:44 <lambdabot> fasta: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:25:23 <pjd> fasta: liftM2 c ?
03:25:35 <desp> the documentation for ForeignPtr says "The only guarantee is that the finaliser runs before the program terminates."
03:25:46 <desp> but my finalizers don't run before program termination
03:25:49 <desp> is that normal?
03:26:05 <desp> I mean, the OS will free everything anyway
03:26:20 <desp> but I'd prefer them running
03:26:55 <fasta> @type liftM2
03:27:01 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:27:17 <fasta> pjd: types don't match, see?
03:27:23 <desp> is the GHC garbage collector smart enough to detect reference cycles?
03:27:37 <fasta> pjd: c already returns a monadic answer by itself
03:27:41 <pjd> olsner: if you're interested, http://arctrix.com/nas/python/gc/
03:27:42 <lambdabot> Title: Garbage Collection for Python
03:27:49 <fasta> pjd: hmm, you might could have not known that.
03:28:11 <pjd> fasta: well, i wasn't sure if that was convenient omission or not :)
03:28:23 <pjd> join . liftM2 c ?
03:28:25 <pjd> i dunno
03:31:03 <fasta> pjd: yes, but I suppose there's not one "word" for it.
03:31:32 <fasta> Hmm, I wrote one earlier: mapply2
03:32:32 <Qerub> What Haskell book(s) do you recommend? I'm beginning a university course and the suggested book (Haskell - The Craft of Functional Programming) gives me bad vibes.
03:33:17 <fasta> Qerub: why does it give you bad vibes?
03:33:42 <fasta> Qerub: there are no practical Haskell books, currently.
03:34:26 <fasta> Qerub: But this will change with the book by dons et al.
03:34:44 <Qerub> Just my stomach feeling - I haven't read a single word of it.
03:35:00 <fasta> Qerub: ....
03:35:14 <fasta> Qerub: find another university if you don't trust your current one
03:35:31 <Radek> Querub: I really enjoy Programming in Haskell by Graham Hutton
03:35:40 <Qerub> fasta: Good point.
03:36:10 <dons> Qerub: oh, its quite a good book, Craft of FP. but Programming in Haskell is also getting good reviews
03:36:11 <yaxu> i second hutton's book
03:36:23 <dons> Craft of FP is probably a bit old now -- I learnt from it many years ago
03:36:53 <yaxu> i didn't take to the the craft of fp either, i don't htink i was the intended audience
03:37:01 <Qerub> fasta: Alright, ignore the silly "bad vibes" part.
03:37:05 <Radek> Qerub: The Haskell School of Expression by Paul Hudak is ok too, but AFTER reading Hutton's book.
03:37:22 <yaxu> i found hudak's book bizarre
03:38:03 <Radek> yaxu: Yes. First time reading made my head hurt. But after Hutton's book it is quite comprehensible.
03:38:45 <fasta> Book reviews only have a point when you have a common background.
03:38:49 <yaxu> bizarre more for supposedly being about multimedia programming, but afaict just showing you how to draw circles and write midi files
03:38:50 <Qerub> yaxu: hudak = hutton?
03:38:56 <fasta> Qerub: no
03:39:14 <fasta> Qerub: Paul Hudak
03:39:23 <fasta> Qerub: Graham Hutton
03:39:27 <Radek> Hutton: http://www.cs.nott.ac.uk/~gmh/book.html
03:39:29 <lambdabot> Title: Programming in Haskell
03:39:44 <Qerub> Got the books' web pages open.
03:39:47 <Radek> Hudak: http://www.haskell.org/soe/
03:39:48 <lambdabot> Title: Home Page
03:40:37 <fasta> The example code for Programming in Haskell looks non-practical.
03:40:54 <yaxu> i got the impression that hudak was trying to sweeten the pill of learning haskell with toy graphics and music, which is fair enough but a bit annoying if you bought the book because you want to make real graphics and music
03:41:05 <fasta> I didn't read that book, so, I don't know whether it contains deep and insightfull things, but it might be good for a Haskell newbie.
03:41:37 <Radek> yaxu: Agree. However it makes haskell more fun to see colorful fractals, squares and circles on screen, intead of raw ghci console. :)
03:42:24 <fasta> I don't think there's a single book that handles fundeps currently.
03:42:27 <yaxu> Radek: it might do, but it didn't for me, i find learning a language fun enough
03:43:04 <yaxu> in my experience, as a c/perl/java etc programmer, hutton's book was a perfect introduction to haskell
03:43:34 <Radek> Hutton's book has also advantage of being newbie's reference manuall. Hudak's book doesn't serve this purpose.
03:43:58 <yaxu> also i got the impression that hutton's book had been well tested on real students
03:44:09 <pjd> i enjoy Hudak's book
03:44:49 <pjd> i think it gets the Haskell way of thinking across very well
03:46:18 <yaxu> also i think there were several points where hudak glossed over points as being 'obvious', which i found nonobvious, so i think i was really not the target audience
03:46:18 <segher__> is  k1 x y = y  in the Prelude under some other name?
03:46:50 <Radek> yaxu: That is why I recommend reading it after Hutton for exacly this reason.
03:47:12 <yaxu> i think if a book leaves you scrabbling around feeling stupid, it's best to try a different book :)
03:47:15 <pjd> segher__: flip const
03:47:25 <yaxu> Radek: yeah i should give hudak a second chance now i've read hutton then
03:47:31 <segher__> ah thanks
03:47:41 <fasta> pjd: I agree with that, but the Haskell way is not always fast.
03:47:51 <pjd> ?
03:48:56 <fasta> pjd: using lists for everything, that is.
03:49:14 <fasta> pjd: or the very Haskelly List monad.
03:49:23 <pjd> fasta: that doesn't sound like the Haskell way :)
03:49:45 <Paczesiowa> could one of you fix this, or show me some easy way to read/write/modify arrays? "do t <- newArray (1,100) (0::Int) ; putStrLn $ show $ readArray t 7"
03:50:08 <fasta> pjd: or using "Array".
03:50:18 <fasta> pjd: books don't advertise ST in any way.
03:50:41 <desp> ahh, weak pointers.
03:53:54 <Qerub> Thank  you for your book discussion. :)
03:59:31 <pjd> segher__: or curry snd
04:00:29 <pjd> segher__: or const id
04:17:50 <idnar> @pl \x y -> y
04:17:50 <lambdabot> const id
04:18:29 <balodja> looks like "false" in lambda-calc :)
04:18:36 <balodja> @pl \x y -> x
04:18:36 <lambdabot> const
04:35:35 <desp> is anyone here familiar with weak pointers and finalizers, as applied to MVars?
04:36:00 <desp> just want to confirm that I understand this correctly
04:38:20 <dcoutts_> desp: don't ask if you can ask a question, just ask the question
04:38:56 <dcoutts_> desp: because nobody will say yes, as that commits them to trying to answer the question :-)
04:39:26 <desp> right.
04:39:36 <desp> it's a bit hard to phrase the question. :)
04:39:59 <desp> the documentation for System.Mem.Weak says that one should use addMVarFinalizer in order to add a finalizer to a MVar
04:40:16 <desp> because of optimizations/unboxing/etc.
04:40:43 <desp> however, it doesn't mention if it's okay to use mkWeak or mkWeakPtr to simply obtain a Weak MVar
04:40:53 <desp> is it okay to do so?
04:42:38 <fasta> dcoutts_: saying "you just did" is also an option
04:45:19 <oerjan> :t mkWeak
04:45:21 <lambdabot> Not in scope: `mkWeak'
04:46:17 <desp> oerjan: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
04:46:20 <lambdabot> http://tinyurl.com/3a7rbs
04:47:11 <desp> my question is tricky, because addFinalizer appears to be a specialized version of mkWeak
04:47:38 <desp> so while there is a specialized addFinalizer version for MVars, there's no MVar version of the general function
04:47:42 <desp> ugh.
04:48:45 <freepenguin> messaggio
04:50:46 <xerox> freepenguin: sei il benvenuto in #haskell.it (:
04:51:12 <freepenguin> :)
04:58:11 <freepenguin> www.freepenguin.it/index-en.html
04:59:59 <Saizan> xerox: anche no? :D
05:00:54 <oerjan> addMVarFinalizer (MVar m) finalizer =  IO $ \s -> case mkWeak# m () finalizer s of { (# s1, w #) -> (# s1, () #) }
05:02:37 <balodja>     readM s | [x] <- parse = return x
05:02:38 <balodja>             | otherwise    = throwError $ "Failed parse: " ++ show s
05:02:46 <balodja>          where ...
05:02:59 <balodja> How to understand "<-" here?
05:03:08 <Heffalump> it's a pattern guard
05:03:21 <Heffalump> it pattern matches the value of parse against [x]
05:03:48 <balodja> ok, thanks
05:04:03 <Heffalump> it's a GHC extension, you can find details in the GHC manual
05:04:11 <oerjan> it looks like if it returned w instead of () it would be what you wanted?
05:04:14 <EvilTerran> foo x | PAT <- EXP = ... |... is the same as  foo x = case EXP of PAT -> ...; ...
05:04:38 <EvilTerran> whups
05:05:04 <EvilTerran> ...except, when a pattern guard fails, it can fall through to the next equation
05:05:05 <oerjan> desp: which would be simply IO . mkWeak#
05:05:20 <balodja> "pattern guards", I see.
05:05:51 <oerjan> except it may be best to write it out explicitly without .
05:06:37 <EvilTerran> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
05:06:39 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/29me25
05:07:48 * EvilTerran adds this to @where pattern(-)guard(s) via pm
05:08:09 * oerjan should point out he is just guessing wildly on how this works
05:10:54 <EvilTerran> hm... would DiffArrays be superior to Arrays for, say, conway's life?
05:11:03 <desp> oerjan: hmm.
05:11:36 <desp> oerjan: I haven't used any # function before...
05:11:47 <EvilTerran> given that you might be dealing with a massive grid with just a little pattern on it
05:13:36 <Saizan> EvilTerran: in my experience no, but i had pretty crowded grids
05:13:44 <EvilTerran> okay.
05:14:23 * EvilTerran is also thinking that an array of Word*s used as bitfields might be in order, depending on the size of grid he's after
05:14:50 <Heffalump> I thought the point of DiffArrays was just to provide a functional interface with mutation.
05:14:51 <desp> oerjan: thanks for finding that; I'll try doing something with it if the simple approach fails
05:14:55 <Saizan> UArray Bool is bitpacked
05:15:10 <EvilTerran> i know! i'll write it to use an IArray type, that way i can try them all! =]
05:15:52 <EvilTerran> Heffalump, they alledgedly offer O(1) reading and replacing individual cells, if you never look at an array after you've generated a new array from ti
05:16:42 <EvilTerran> @where UArray
05:16:42 <lambdabot> I know nothing about uarray.
05:16:46 <EvilTerran> @index UArray
05:16:46 <lambdabot> Data.Array.Unboxed
05:19:30 <chessguy> @type when
05:19:37 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:19:38 <chessguy> @bot
05:19:38 <lambdabot> :)
05:20:35 <EvilTerran> Saizan, thanks. i like how so many of the things i think are good ideas seem to have already been done in haskell. it's a nice confidence boost knowing i'm not the only one who thinks something's a good idea :D
05:20:41 <chessguy> is there some shorter way to do this? bool <- foo; if bool then bar else baz
05:20:53 <opqdonut> liftM if'
05:20:56 <Heffalump> EvilTerran: right, because they use an imperative implementation under the hood, and store a list of old edits in case you ever use an old one
05:21:12 <chessguy> @type liftM if'
05:21:14 <lambdabot> Not in scope: `if''
05:21:21 <chessguy> @hoogle if'
05:21:22 <lambdabot> No matches found
05:21:25 <EvilTerran> Heffalump, heck, everything uses an imperative implementation under the hood. we're all on von neumann machines, here ;]
05:21:28 <Heffalump> so I'm not sure why the application is relevant, beyond it being single threaded
05:21:39 <chessguy> @hoogle if
05:21:40 <lambdabot> Prelude.if :: keyword
05:21:40 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
05:21:40 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
05:21:43 <Heffalump> a standard imperative implementation of arrays :-p
05:21:48 <EvilTerran> if' :: Bool -> a -> a -> a
05:21:53 <opqdonut> yeah
05:21:59 <EvilTerran> also known as bool :: a -> a -> Bool -> a ;]
05:22:00 <Heffalump> (single threaded in the sense of access to the data, rather than in the multithreading sense)
05:22:26 <opqdonut> :t let if' p x y = if p then x else y in liftM if'
05:22:28 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m (t -> t -> t)
05:22:29 * EvilTerran tries to remember which morphism of Bool that i
05:22:30 <EvilTerran> s
05:22:34 <opqdonut> :t let if' p x y = if p then x else y in liftM3 if'
05:22:36 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
05:23:54 <Heffalump> morphism of Bool?
05:23:56 <chessguy> nice. thanks
05:24:01 <chessguy> opqdonut++
05:24:34 <EvilTerran> Heffalump, i think it's Bool's catamorphism. i'm not sure, though.
05:25:02 <Heffalump> I guess it is, yes.
05:25:06 <EvilTerran> (catamorphism = generalisation of "fold" to any ADT, IIRC)
05:25:11 <chessguy> opqdonut where is if' defined?
05:25:33 <Heffalump> though the concept of a catamorphism on a non-recursive datatype is a bit pointless
05:25:49 <opqdonut> chessguy: standard non-defined idiom
05:25:51 <opqdonut> like `on`
05:25:53 <opqdonut> gtg now
05:25:56 <chessguy> ah
05:26:05 <chessguy> but on is defined in GHC head :)
05:26:14 <oerjan> chessguy: that liftM3 won't work, it _always_ evaluates all of them
05:26:29 <chessguy> oh
05:26:44 <chessguy> so i need a lazy version of liftM3?
05:27:19 <oerjan> chessguy: foo >>= bool bar baz
05:27:25 <EvilTerran> which morphism would "list :: (a -> [a] -> b) -> b -> [a] -> b; list f e [] = e; list f e (x:xs) = f x xs" be?
05:27:43 <oerjan> bool t f b = if b then t else f
05:28:00 <chessguy> so bool = if' ?
05:28:09 <oerjan> with a different argument order
05:28:19 <chessguy> oh right
05:28:48 <EvilTerran> chessguy, yes, pretty much. i prefer to use bool, others prefer to use if'. either way, you have to define it yourself, IIRC
05:28:56 <oerjan> bool is the "catamorphism" of Bool, if' is just unsugared if-then-else
05:28:59 <chessguy> got it
05:29:18 <Heffalump> EvilTerran: I doubt that is a morphism.
05:29:32 <Heffalump> if it is, it's not a very interesting one.
05:30:08 <Heffalump> seeing as doesn't embody any recursive structure even on a recursive datatype
05:30:22 <Heffalump> oerjan: well, I'd say foldr with a different argument order is a catamorphism too
05:30:37 <EvilTerran> Heffalump, i'm sure someone said something that boils down to "fold only the outermost constructor, even if the type is recursive" was some kind of morphism
05:31:01 <Heffalump> I dunno. It wouldn't be much use in any case.
05:31:18 <EvilTerran> i've wanted that abovementioned list function a few times
05:31:49 <Heffalump> IM as an embodiment of recursion.
05:32:06 <EvilTerran> it's good as a parameter to unfoldr, say.
05:32:51 <EvilTerran> anyway. i have to go shopping.
05:32:57 * EvilTerran -> away!
05:33:42 <Lemmih> ?quote shopping
05:33:43 <lambdabot> samc says: monads are hard, let's go shopping
05:34:06 <BobFunk> heya - having some troubles getting Network.FastCGI to compile
05:34:21 <BobFunk> configure seems to run fine
05:34:41 <BobFunk> but I get "FastCGI.hsc:47:21:  error: fcgiapp.h: No such file or directory"
05:34:56 <BobFunk> when running: runhaskell Setup.hs build
05:35:10 <Lemmih> BobFunk: Have you installed the fcgi library?
05:36:01 <BobFunk> doh! great tip :)
05:36:13 <chessguy> @pl m x = map (\i -> x)
05:36:14 <lambdabot> m = map . const
05:36:36 <BobFunk> sometimes when installing these haskell libs I forget there's a world of dependencies outside of haskell ;)
05:36:47 <chessguy> @pl a x = all (x ==)
05:36:48 <lambdabot> a = all . (==)
05:38:13 <chessguy> @pl p t = pu t >> h s >> g
05:38:13 <lambdabot> p = (>> g) . (>> h s) . pu
05:39:28 <oerjan> > (0$0 >>)
05:39:30 <lambdabot>      The operator `>>' [infixl 1] of a section
05:39:30 <lambdabot>         must have lower preced...
05:40:26 <oerjan> another case for extended sections (>> h s >> g)
05:41:48 <oerjan> > (0$0 >>>)
05:41:49 <lambdabot>      The operator `>>>' [infixr 1] of a section
05:41:49 <lambdabot>         must have lower prece...
05:51:24 <ddarius> "grog" is an Australian thing?
05:51:29 <desp> does the 6.7 debugger offer a way to track references?
05:51:46 <desp> ddarius: no, more like a Nordic thing
05:52:15 <desp> oh. apparently it is a Aussie slang term too :)
05:52:21 <desp> pardon me.
05:54:03 * ddarius didn't really encounter the word grog until the military.
05:54:29 <xerox> So you never played monkey island!
05:55:20 <ddarius> xerox: No, I didn't.
05:55:29 <xerox> Aww.
05:56:19 <desp> sigh
05:56:21 <desp> my finalizers don't fire
05:56:25 <desp> and I don't know why
05:56:39 <ddarius> desp: They're taking the long view.
05:58:27 * ddarius needs to figure out what software he has for burning DVDs.
05:59:13 <desp> is there any way to check how holds references to a certain value?
05:59:17 <desp> er..
05:59:22 <desp> who holds
05:59:26 <desp> or what bit of code
06:00:54 <ddarius> retainer profiling?
06:01:07 <desp> looking up
06:02:56 <desp> ddarius++
06:03:01 <desp> that appears to be just the thing
06:03:17 <pejo> ddarius, does it mean 'alcohol mixed with flavour'?
06:03:34 <damg> how can i extract the integer part from a Rational?
06:04:16 <xerox> round / floor / ceiling it ?
06:04:46 <damg> ah, sure, thank you :)
06:05:08 <damg> didn't think of them, wanted to cut (floor) it
06:05:16 <ddarius> pejo: For a very wide definition of "flavour"...
06:09:23 <Igloo> desp: finalizers may not run, and they'll only be run when the thing they finalize gets GCed
06:11:44 <desp> Igloo: I know; I'm calling performGC
06:12:09 <desp> and my retainer profile appears to be empty after a +RTS -hr -RTS run
06:12:12 <desp> odd
06:12:15 <roconnor> > trunc (1/2)
06:12:19 <lambdabot>   Not in scope: `trunc'
06:12:23 <Igloo> How long does the program run for?
06:12:30 <ddarius> > truncate (1/2)
06:12:32 <lambdabot>  0
06:12:35 <desp> Igloo: yeah, quite short. testing with a longer run time now
06:12:43 <roconnor> @hoogle Rational -> (a,b)
06:12:44 <lambdabot> No matches, try a more general search
06:12:49 <roconnor> @hoogle Ratio x -> (a,b)
06:12:50 <lambdabot> No matches, try a more general search
06:13:27 <roconnor> @hoogle Fractional x -> (a,b)
06:13:27 <lambdabot> No matches, try a more general search
06:13:42 <desegnis> @type properFraction
06:13:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
06:13:54 <roconnor> desegnis: ah
06:14:03 <EvilTerran> @index properFraction
06:14:03 <lambdabot> Prelude
06:14:32 <EvilTerran> @src properFraction
06:14:32 <lambdabot> Source not found. My pet ferret can type better than you!
06:14:38 <roconnor> ugh, what a horrible specification.
06:15:06 <EvilTerran> > numerator &&& denominator $ 0.375
06:15:07 <lambdabot>  (3,8)
06:15:11 <EvilTerran> > properFraction 0.375
06:15:13 <lambdabot>  (0,0.375)
06:15:26 <desegnis> properFraction is in the RealFrac class
06:15:54 <desp> Igloo: it appears that the finalization only fires when the storage gets hit hard
06:16:10 <desp> Igloo: "hit hard" == convert a 1.5MB lazy bytestring to string
06:16:44 <desp> if I just output the lazy bytestring and call performGC afterwards, the finalizer doesn't fire
06:17:42 <Igloo> desp: If you want to guarantee that something happens then finalizers aren't the answer
06:18:00 <desp> Igloo: no, I just want to make sure I'm cleaning up correctly
06:18:09 <desp> which is hard to test if the cleanup doesn't happen
06:18:17 <Igloo> :-)
06:23:07 <tonfa> how is the haskell code generated in the normal case (not with -fvia-C) ?
06:23:38 <tonfa> is C-- an intermediate representation ?
06:24:04 <Igloo> It goes from C-- to assembly if not going via C
06:24:18 <Igloo> When going via C it goes from C-- to C to assembly
06:24:26 <Igloo> (FSVO C)
06:24:35 <tonfa> and the C-- to native code is handled by ghc ?
06:24:40 <Igloo> Yes
06:25:39 <tonfa> ok, but doesn't Ocaml already uses C-- ? do both projects duplicate the code ?
06:26:08 * Igloo doesn't know what ocaml does
06:32:18 <fasta> Igloo: is there any known case of Data.STRef.Lazy being slower than Data.STRef.Strict?
06:32:42 <fasta> Igloo: I use lots of them, but Lazy always beats Strict
06:34:01 <fasta> Hmm, well, it appears "always" is not true. They probably get compiled to the same due to strictness analysis.
06:35:12 <oerjan> @index performGC
06:35:12 <lambdabot> System.Mem
06:47:03 <smallfoot-> isnt haskell like COBOL?
06:47:07 <smallfoot-> dead
06:47:32 <dylan> it's actually a rather young and vibrant language.
06:47:42 <smallfoot-> oh
06:47:47 <smallfoot-> i thought it was like 100 years old
06:47:52 <phobes> I don't think haskell has yet gone through a period of user decline, has it?
06:48:02 <smallfoot-> nobody use it
06:48:02 <dylan> There exists no computer language 100 years old...
06:48:06 <b_jonas> yeah. like the topic says, "The language of ICFP winners 3 years running". that's the last 3 years.
06:48:11 <smallfoot-> all use C, c++, java, C#, php, perl, python, ruby
06:48:13 <roconnor> I have a math problem, but I'm scared to ask in #math
06:48:37 <phobes> What area of math?
06:48:42 <b_jonas> roconnor: don't ask to ask?
06:48:44 <smallfoot-> young computer language? its 17 year old!
06:49:29 <roconnor> b_jonas: when I ask questions in #math, they just claim it is homework, and I should do it myself.
06:49:41 <xerox> roconnor: you can ask it here too (:
06:49:59 <idnar> we'll also tell you it's homework
06:50:02 <idnar> *hide*
06:50:12 <desp> b_jonas: that's not the last 3 years.
06:50:36 <roconnor> if |x - y| <= e^n then is |x^(1/n) - y^(1/n)| <= e, and if show, how do you prove it?
06:50:42 <b_jonas> desp: hmm. let me look that up
06:50:43 <roconnor> given 0 <= x,y
06:50:52 <phobes> roconnor:  that sounds like a homework problem
06:50:56 <desp> b_jonas: last year Team Smartass chose 2D ;p
06:51:02 <b_jonas> 98 was J of course
06:52:54 <roconnor> phobes: thanks :P
06:53:34 <b_jonas> desp: oh I see
06:54:24 <phobes> roconnor: I think it's true, yes
06:54:28 <phobes> for n > 1
06:54:35 <phobes> n >=1
06:54:50 <phobes> Because f(x) = x^(1/n) is concave down
06:54:53 <Lycurgus> smallmind <- smallfoot
06:55:13 <ski> left
06:55:36 <profmakx> try induction on n?
06:55:42 <Lycurgus> yeah I would have said it to ir face though
06:55:44 <phobes> You can rewrite the question as, does | x - y | ^ 1/n < e   =>   | x ^ 1/n  -  y ^ 1/n | < e
06:56:26 <ski> (Lycurgus : 'ir' being gender-agnostic pronoun ?)
06:56:35 <Lycurgus> spivak, yes.
06:57:05 <phobes> roconnor:  Does that make sense?
06:57:43 * roconnor ponders
06:58:15 <SamB> hmm, have any of you heard of acid?
06:58:25 <desp> hah.
06:58:29 <phobes> The value e is irrelevant.  The point is that  | x - y | ^ 1/n < | x ^ 1/n - y ^ 1/n | for all x, y > 0
06:58:31 <SamB> the plan9 debugger
06:58:44 <Modius> Does == 1, in haskell only do numeric equality, or is there a way to mame some n ==1 infer another type?
06:58:48 <SamB> not that thing that GHCi experiments with
06:58:48 <phobes> err, reversed the ordering there:
06:58:59 <phobes> | x - y | ^ 1/n >= | x ^ 1/n - y ^ 1/n | for all x, y > 0
06:59:11 <desp> either finalizers on MVars run in a different order than foreignPtr finalizers... or I have something confused.
06:59:14 <SamB> Modius: hmm?
06:59:23 <SamB> Modius: 1 is a number
06:59:41 <EvilTerran> Modius, if you can make that other type an instance of Num, 1 could be of that type, and _then_ you could compare for equality
06:59:48 <SamB> Modius: so I'd hope it's basically numeric equality
06:59:53 <roconnor> phobes: but x-y isn't between x and y.
07:00:10 <phobes> No, but draw a concave down function
07:00:15 <SamB> unless of course I'm dealing with PDP-1 arithmatic
07:00:19 <EvilTerran> > (1 :: Int, 1 :: Double, 1 :: Rational, 1 :: Word) -- 1 can have any Num types
07:00:20 <SamB> or something like that
07:00:21 <lambdabot>  (1,1.0,1%1,1)
07:00:26 <Modius> I'll rewinde the question a bit - I have a function that inferences to Num -> Integer (based on a comparison of the input to 1), does numeric literal always mean Num to the inference?
07:00:29 <phobes> pick x and y
07:00:37 <EvilTerran> ?type 1
07:00:39 <lambdabot> forall t. (Num t) => t
07:00:42 <roconnor> phobes: okay
07:00:47 <EvilTerran> Modius, does that help?
07:00:48 <SamB> Modius: you don't
07:01:03 <SamB> Num is no type
07:01:14 <phobes> roconnor:  Try this.  Pick a concave down function and then choose x and y.   Look at what happens to | f(x) - f(y) | if you slide both x and y to the left
07:01:30 <phobes> It can only increase
07:01:31 <puusorsa> SamB, acid? just looking for a place to cook .. oh you meant the debugger, nevermind ..
07:01:34 <gleb> is there some type-class that unifies String & ByteString interfaces?
07:01:59 <SamB> gleb: well...
07:02:12 <SamB> I've heard the latest GHC has overloaded string literals
07:02:18 <roconnor> phobes: so long as the distance between x and y is constant.
07:02:22 <SamB> so I imagine there has to be a typeclass for that at least
07:02:37 <phobes> roconnor:  Sliding until x=0 you have   |f(0) - f(x)| >= | f(x) - f(y) | ... (And yes, the distance between x and y has to stay constant)
07:02:39 <roconnor> phobes: okay, I see
07:02:44 <gleb> SamB: sounds cool
07:03:05 <msouth> phobes: I think you need some monotonicity too, right?
07:03:25 <phobes> msouth: True, yes
07:03:31 <msouth> i didn't follow everything, but if you slid around a local max you would have a problem
07:03:39 <phobes> You're right :)
07:03:41 <msouth> but that's ok for ^(1/n)
07:03:43 <phobes> Yes
07:04:36 <gleb> SamB: I just thought if it doesn't exist, there must be some good reason for it, so I decided to ask before rolling my own. Gotta dig GHC's repo now
07:04:52 <doserj> gleb: it is called IsString
07:05:10 <gleb> doserj: thanks
07:05:30 <SamB> gleb: one reason would be "nobody's gotten around to it"
07:05:40 <SamB> I don't think IsString has too many methods somehow
07:05:44 <phobes> roconnor:   Is this convincing?  Did you just need to know it was true or did you need a proof?
07:06:32 <doserj> IsString only has a function fromString::String -> a
07:06:40 <gleb> SamB: I remember huge thread in Cafe about duplicated bloated interfaces, some serious issues with Haskell were mentioned, I just can't remember a conclusion :)
07:07:47 <doserj> phobes, i guess he needs a typechecked proof :)
07:07:56 <mux> @lambda (\x. x x) (\x. x x)
07:07:56 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
07:08:08 <Modius> 1.  Is the == function/operator hard tied in haskell to Nums?  2.  Can it be overloaded to interact with other types?   (This would be a good time to tell me that Haskell doesn't allow such things)
07:08:11 <mux> @lambda (\x. x) y
07:08:11 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
07:08:16 <mux> oh well :)
07:08:22 <EvilTerran> ?type (==) -- Modius
07:08:31 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:08:37 <EvilTerran> ?src Eq
07:08:38 <lambdabot> class  Eq a  where
07:08:38 <lambdabot>     (==), (/=)   :: a -> a -> Bool
07:11:23 <Cale> ?src Num
07:11:24 <lambdabot> class  (Eq a, Show a) => Num a  where
07:11:24 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:11:24 <lambdabot>     negate, abs, signum     :: a -> a
07:11:24 <lambdabot>     fromInteger             :: Integer -> a
07:11:32 <msouth> Modius: iiuc, all you have to do is create new type that defines == and \= functions (which take two things of your new type and return a Bool).  Then things with your type can be used on anything that the type class Eq is specified.
07:11:41 <Cale> Unfortunately, Num does imply an Eq constraint
07:11:49 <kayess> Stupid question alert: Using ghci, can I define a function, and if so how?
07:12:01 <Cale> kayess: yes, using let
07:12:02 <EvilTerran> ghci> let x = 1
07:12:08 <Cale> let f x = x + 1
07:12:09 <EvilTerran> ghci> x
07:12:10 <EvilTerran> 1
07:12:11 <kayess> EvilTerran: cheers!
07:12:32 <Cale> kayess: You can't declare many other sorts of things though, so it's usually recommended to keep a file open
07:12:33 <msouth> but he was asking if Eq is tied to Num, not the other way around, I think.
07:12:39 <Cale> msouth: yeah
07:13:05 <kayess> Cale: Thanks. I'm just trying to get my head around something to do with curry, uncurry and partial application - I only need one line functions
07:13:14 <Cale> kayess: You can easily reload a file which is open in ghci by simply typing : by itself on a line (or :r, :reload)
07:13:18 <Modius> Broadly, I gave someone a haskell function that inference turned into Num -> Integer - he asked me if something I changed outside the program would make that function inference to something else
07:13:39 <Saizan> if i have f'(x) < 1 for x in (a,b) then for x,y in (a,b)  |f(x) - f(y)| < | x - y |?
07:13:42 <Cale> Num a => a -> Integer ?
07:14:04 <xerox> Saizan: yep
07:14:19 <Cale> That's a cute problem :)
07:14:39 <Modius> fetch inval = if inval == 1 then 10 else 20 <-- Is there anything external that could make this function infer to anything other than (Num a) => a -> Integer ?
07:14:58 <xerox> Saizan: such a function f is called Lipschitz continuous.
07:15:15 <EvilTerran> ?type \inval -> if inval == 1 then 10 else 20
07:15:17 <lambdabot> forall a t. (Num a, Num t) => a -> t
07:15:37 <phobes> Saizan:  You need |f'(x)| < 1
07:15:37 <b_jonas> Saizan: yes, you have to use the theorem whose name I can't remember
07:15:38 <xerox> Actually lipschitz continuity is a bit more general but your function satisfies the requirements.
07:16:05 <Saizan> this should also solve roconnor's problem, since the derivative of ^(1/n) is less than 1 for x > 1 (roughly)
07:16:06 <b_jonas> which states that if f is differentiable between a and b and f(a)=f(b) then there's an a<x<b for which f'(x)=0
07:16:53 <b_jonas> use indirect proof and add a linear function to f
07:16:55 <EvilTerran> @hoogle [a] -> (a -> Bool) -> Int
07:16:55 <lambdabot> No matches, try a more general search
07:16:56 <Saizan> phobes: ah, right
07:16:57 <EvilTerran> @hoogle [a] -> (a -> Bool) -> Integer
07:16:58 <lambdabot> No matches, try a more general search
07:17:11 <astrolabe> Saizan: http://en.wikipedia.org/wiki/Mean_value_theorem
07:17:12 <lambdabot> Title: Mean value theorem - Wikipedia, the free encyclopedia
07:17:16 <Cale> b_jonas: That would be Rolle's theorem, which is one of the lemmas leading up to the Mean value theorem
07:17:32 <phobes> Saizan:  But x^1/n can be larger than x?
07:18:03 <astrolabe> @paste
07:18:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:18:13 <b_jonas> Cale++ that's it. I'm bad with names, especially the ones in calculus 1 (the exam had lots of little theorems which was just bad)
07:18:19 <EvilTerran> @instances Num
07:18:20 <lambdabot> Double, Float, Int, Integer
07:18:50 <Cale> xerox: any differentiable function is Lipschitz of order 1.
07:18:50 <sieni> phobes: well, if n > 1 and 0 < x < 1, then x^1/n > x
07:19:13 <phobes> sieni: Yes
07:20:13 <Cale> Rolle's theorem is the really nice way to prove the Mean Value Theorem.
07:20:15 <sieni> Cale: well, continuously differentiable at least and then only locally
07:20:31 * EvilTerran celebrates list comprehensions
07:20:36 <roconnor> phobes: now I just have to convince coq of your argument.
07:20:38 <Modius> I still don't fully understand - could anything external to the function alter the outcome of the inferencing?
07:20:46 <Cale> Modius: no
07:20:55 * roconnor reviews
07:21:07 <phobes> ah, you need a formal proof
07:21:08 <Modius> Is the reason for that the hard typing on the ==, or hard typing on EQ?
07:21:29 <Cale> Modius: It's that the inferred type for a function is always the most general possible one.
07:21:43 <roconnor> phobes: yep.  I'm trying to prove the continuity of the Nth root function.
07:22:01 <Modius> That I understand; but can I give it more generality/define some other == that will make it open to some other possible inval?
07:22:01 <b_jonas> related to Rolle's theorem, there's a very nice but difficult contest task (invented by KÃ³s GÃ©za iirc) which needs more than first-year maths to solve
07:22:35 <Cale> Modius: Well, it's already parametrised
07:22:48 <phobes> roconnor:  Lol, then my proof may be somewhat circular
07:22:58 <Cale> :t let fetch inval = if inval == 1 then 10 else 20 in fetch
07:23:00 <lambdabot> forall a t. (Num a, Num t) => a -> t
07:23:09 <b_jonas> it's problem 6 in "http://www.imc-math.org.uk/imc2006/day1_solutions.pdf" (read carefully, it has spoilers)
07:23:16 <Cale> See? It already works for any two instances of Num
07:23:53 <hpaste>  astrolabe pasted "MapLike" at http://hpaste.org/2457
07:23:55 <Cale> (which, by unfortunate necessity, are automatically instances of Eq)
07:24:00 <roconnor> phobes: right, I need to know it is continuous before I know it is differentable.
07:24:14 <astrolabe> any help with that paste gratefully received.
07:24:33 <phobes> roconnor:  I think you can rework it so that it's not circular actually
07:24:37 * EvilTerran notes that the style of putting the ","s at the starts of lines rather than the end makes a surprising amount of sense, even if it looks weird.
07:25:38 <roconnor> phobes: your concave argument?
07:25:52 <phobes> roconnor:  Here, you go, this is simpler
07:26:00 <phobes> Let y > x > 0
07:26:01 * roconnor likes simple
07:26:02 <astrolabe> roconnor: You might find the 'implicit function theorem' helpful.
07:26:07 <hpaste>  Saizan annotated "MapLike" with "MPTC?" at http://hpaste.org/2457#a1
07:26:25 <hpaste>  Cale annotated "MapLike" with "some possibilities" at http://hpaste.org/2457#a2
07:26:36 <roconnor> astrolabe: yeah, that ususally requires a Lipschitz function from what I recall.
07:26:55 <Cale> roconnor: what's your actual problem?
07:27:05 <idnar> Modius: are you asking about using == to compare an instance of Num with some other type that's not an instance of Num?
07:27:15 <astrolabe> roconnor: So you need to treat the case at 0 separately.
07:27:16 <roconnor> Cale: I'm trying to prove the continuity of the nth root function in Coq.
07:27:24 <phobes> roconnor:  Let y > x > 0.  Let d = y-x, so that y = x + d.  We want to prove that  (x+d)^1/n - x ^ 1/n < d ^1/n.   This is  (x + d) ^ 1/n < x ^ 1/n + d ^ 1/n
07:27:31 <astrolabe> Saizan, Cale: thanks.
07:27:44 <Cale> roconnor: on the positive reals?
07:27:52 <roconnor> Cale: nonnegative reals
07:27:57 <Cale> okay
07:28:21 <Modius> idnar:  If that's possible and if it can change the outcome of inference
07:28:28 <phobes> roconnor:  Take nth power of both sides.   We want    x + d <= (x ^ 1/n + d ^ 1/n) ^ n  = x + d + ... other terms.  So it's true
07:28:54 <roconnor> phobes: that sounds more like what I want.
07:30:42 <gleb> is there way to browse GHC-HEAD sources without downloading all of them?
07:30:50 <b_jonas> wow, I've never seen this message yet: "you can't join that many channels"
07:31:35 <b_jonas> do they really have so few bandwidth or what?
07:31:53 <ricky_clarkson> More like an anti-spam measure, probably.
07:31:54 <phobes> roconnor:  I was sloppy with the inequalities...  equality only holds if x = y
07:32:05 <phobes> roconnor:  or if x or y is 0
07:32:23 <b_jonas> ricky_clarkson: hmm.
07:32:38 <doserj> gleb: darcs.haskell.org ?
07:32:48 <b_jonas> wierd still. it's not a problem because I can easily part some or use a different connection
07:32:51 <roconnor> phobes: I read y > x > 0 as y >= x >= -
07:32:52 <Igloo> b_jonas: It's an anti-trouble-maker device AFAIK
07:32:53 <roconnor> phobes: I read y > x > 0 as y >= x >= 0
07:33:00 <takamura> hi
07:33:20 <phobes> roconnor:  If you just need <= everywhere, then ya that's good
07:33:41 <Cale> Perhaps you could show that the inverse of a bijective continuous function is continuous?
07:33:49 <gleb> doserj: yes, sorry, I managed to find ghc-6.6, but could not finid ghc-head ;)
07:33:57 <roconnor> phobes: deciding if x <= y or y <=x is going to be a bit annoying.
07:34:12 <roconnor> phobes: I'm trying to see if I can keep the abs value function through your argument.
07:34:15 <Cale> (on intervals in R, of course)
07:34:35 <roconnor> Cale: I'm not sure that is constructively sound.
07:35:28 <Cale> takamura: hello
07:35:43 <idnar> Modius: I think the definition of Eq precludes that, but I'm not sure (I'm a Haskell newbie, really :P)
07:37:20 <Cale> Modius: The only way you could affect how the type of fetch is inferred is by assigning a different type signature to it manually, or by changing the type of one of the things which it is made up from.
07:37:25 <phobes> roconnor: Can you generalize to monotone invertible functions are continuous?
07:37:45 <fasta> Cale: "It's that the inferred type for a function is always the most general one." Wasn't this shown to be false for even H98?
07:38:17 <Cale> fasta: No. It's false for pattern bindings though, only because of the MR.
07:38:46 <fasta> Cale: hmm, I thought I read an article which had an example.
07:38:53 <phobes> I guess that's weaker assumptions than Cale's suggestion, so wouldn't be helpful
07:39:08 <phobes> I don't know much about constructive proofs
07:39:11 <roconnor> phobes: I've only seen proofs for Lipschitz functions.
07:39:23 <fasta> Modius: if you use multi-parameter classes you can do that.
07:39:53 <fasta> Modius: class ModiusEq a b where eq:: a -> b -> Bool
07:40:42 <roconnor> phobes: your argument is pretty simple if I assume that y <= x.
07:40:53 <roconnor> maybe I should go ahead I prove that I can assume that.
07:41:03 <phobes> roconnor: Can you not just  ya.. do a case analysis... there are only two cases :)
07:41:31 <roconnor> phobes: well, constructively the reals are not a total order in the usual sense.
07:41:38 <Treeform> hey is is libghc6-opengl-dev (ubuntu) same as HOpenGL or am i missing some thing?
07:41:44 <roconnor> phobes: but they are not not a total order.
07:41:51 <roconnor> phobes: which is good enough for this argument.
07:42:02 <fasta> Modius: an instance would be instance ModiusEq Int Bool where eq 0 False = True;eq _ True = True; eq _ _ = False
07:42:16 <phobes> roconnor:  lol... this is why constructive math is wrong
07:42:42 <roconnor> phobes: nah, it's your proof that is wrong ;)
07:42:53 <roconnor> ... there must be some way of fixing it.
07:42:54 <fasta> phobes: spoken like a true mathematician....
07:42:57 <EvilTerran> @hoogle initialize
07:42:58 <lambdabot> System.Console.Readline.initialize :: IO ()
07:43:03 <EvilTerran> @hoogle Initialize
07:43:04 <lambdabot> System.Console.Readline.initialize :: IO ()
07:43:39 <phobes> roconnor: can you define min() and max()?
07:43:40 <fasta> I have nothing against non-constructive proofs, but I have something against wrong proofs.
07:44:01 <roconnor> phobes: yes
07:44:12 <phobes> roconnor: How do you do that if you can't branch on x<y?
07:44:21 <Igloo> Treeform: HOpenGl is opengl+glut+openal+alut, that is just opengl
07:44:34 <roconnor> phobes: (of course I don't mean your proof is wrong in the logical sense, more like an astetic sense)
07:44:48 <Treeform> Igloo, oh i got the libs
07:44:54 <Treeform> but it still not finding them
07:45:55 <fasta> Igloo: why does GHC compile a module, that it doesn't even need to run main?
07:45:59 <roconnor> phobes: it's okay so long as the value of the branches are equal when x == y.
07:46:25 <roconnor> phobes: because when you are close to the branch point, you can do both branches and take the average value.
07:46:27 <fasta> I.e. I would expect a dead code elimination.
07:46:36 <fasta> Isn't there one?
07:47:50 <takamura> I came later. What are trying to prove?
07:48:02 <takamura> What are you*
07:50:33 <EvilTerran> @index getArgsAndInitialize
07:50:33 <lambdabot> Graphics.UI.GLUT.Initialization, Graphics.UI.GLUT
07:55:04 <Treeform> it says  Failed to load interface for `GL': but i have installed the libghc6-opengl-dev and Friends what kind lib paths are messed up?
07:59:44 <Lemmih> Treeform: It's Graphics.Rendering.OpenGL now.
08:00:08 <Treeform> oh the tutorial i have says import GL and that ll
08:00:20 <Treeform> Lemmih, do you have a link to any better tutorial?
08:00:33 <Lemmih> I do indeed.
08:00:44 <SamB> hmm. it looks like my up-conversion for IEEE floating-point numbers works so far...
08:01:55 <Treeform> Lemmih, may i have the link to better openGL tutorials?
08:03:50 <hpaste>  EvilTerran pasted "error trying to build GLUT-2.0 (on Windows XP Pro)" at http://hpaste.org/2458
08:04:15 <EvilTerran> halp?
08:04:31 <roconnor> phobes: I see no better way than your argument, so I'll prove WLOG (y <= x).
08:05:25 <Lemmih> Treeform: I would if I could get my browser to work.
08:05:27 <EvilTerran> looks like it should be #define'd to something but isn't
08:05:34 <Igloo> EvilTerran: If compiling from darcs you need to autoreconf first
08:05:52 <EvilTerran> i downloaded off hackageDB
08:05:54 <Igloo> EvilTerran: Oh, you'll need to build in msys or cygwin
08:05:57 <Treeform> Lemmih, it looks like i found some on not on HOpenGL site
08:06:04 <EvilTerran> poo. is there a binary?
08:06:08 * roconnor always finds these double negations proofs funny.
08:06:25 <Lemmih> Treeform: Are you sure you don't have HOpenGL already?
08:06:26 <Treeform> Lemmih, but now i am getting enough "(.text+0x46): undefined reference to `OpenGLzm2zi1_GraphicsziRenderingziOpenGLzi" to last me a life time
08:06:31 <EvilTerran> ...i might reboot into Fedora instead
08:07:05 <Treeform> Lemmih, i think i got the Hopengl stuff now i got code that is not 7 years old :)
08:07:08 <fasta> Igloo: is it possible that manually telling GHC to inline does more harm than good for e.g. liftST .  newSTRef?
08:07:28 <fasta> Igloo: that's what I am seeing anyway. If I inline those lifted version, it costs me 20%.
08:08:12 <Lemmih> Treeform: All the redbook examples have been ported to Haskell.
08:08:23 <mux> fasta: that doesn't sound completely unlikely
08:08:27 <Lemmih> Treeform: Some of the Nehe tutorials have been as well.
08:08:44 <mux> I don't know about GHC specifically, but if you inline too much, you can lose performance by trashing the L1 cache of the CPU when previously code would fit in it
08:09:09 <Treeform> thanks Lemmih
08:09:19 <fasta> mux: actually, I expect nothing to be in the cache with my user of higher-order functions and generics ;)
08:09:26 <fasta> mux: use*
08:10:01 <mux> heh, well, don't know :)
08:10:53 <fasta> mux: It should be possible to measure the amount of cache hits with unsafeperformio
08:11:03 <Treeform> Lemmih, now i m just getting undefined functions :(
08:13:56 <yaxu> I just read "Former US Treasury Secretary: America Headed for Deep Recession" as "... Deep Recursion"
08:14:43 <yaxu> I wonder how America could do that
08:15:50 <fasta> "Former", heh, if the current one would be saying that, he would be fired ;)
08:16:17 <mudge> anyone here going to the Functionally Programming User Group meeting in Sanfrancisco on Sept 5?
08:16:23 <yaxu> well i guess the problem with pyramid selling schemes is not coping with deep recursion
08:18:18 <ketil> Quick HDBC question: prepare/execute does not seem to replace ? with my parameters, but rather by $1.
08:18:26 <ketil> Is that supposed to happen?
08:18:39 <Lemmih> ketil: Yes.
08:18:49 <byorgey> "AMERICA" -> "AMERICA Mnemonicizes Everything, Resulting In Crappy Acronyms"
08:19:04 <ketil> And...it is also supposed to result in Sql exceptions, rather than values?
08:19:10 <Lemmih> ketil: No.
08:19:30 <ketil> Presumably there's a missing piece somewhere, then?
08:19:36 <Lemmih> ketil: What backend are you using?
08:19:42 <ketil> postgresql
08:20:59 <Lemmih> PostgreSQL uses $'s instead of ?'s. HDBC replaces them for you in order to keep a consistent interface to all backends.
08:21:34 <ketil> but then it complains about my query that:
08:21:43 <ketil> *** Exception: SqlError {seState = "", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: ERROR:  syntax error at or near \"$1\"\nLINE 1: select count(*) from $1;\n                             ^\n"}
08:22:20 <Lemmih> I don't think you can use $1 in that location.
08:23:25 <ketil> Oh.  I just wanted a summary of tables, and thought I'd iterate over them.
08:23:56 <Lemmih> ketil: You probably have to do the escaping yourself.
08:23:58 <ketil> No matter, I can piece together strings manually.
08:24:19 <ketil> Thanks.  I was very confused, but now I just blame SQL and get on with my life.
08:24:21 <ketil> :-)
08:24:30 <phobes> byorgey:  Contrived* acronyms
08:24:51 <byorgey> phobes: yes, that too =)
08:26:51 <puusorsa> is hdbc the best choice for database stuff atm?
08:27:33 <ketil> puusorsa: according to my informal web research, yes.
08:27:38 <puusorsa> hooray!
08:27:45 <ketil> at least as a low-level SQLish library
08:28:02 <mux> I've tried HDBC-postgresql and it worked okay, except that it was returning all the data as strings
08:28:08 <Heffalump> HSQL works ok for me
08:28:10 <mux> for some reason, it seems the mapping wasn't done correctly
08:28:11 <ketil> Takusen may be better as a high-level thing, HaskellDB seems to be DIW.
08:28:25 <ketil> mux: couldn't you use from/toSql?
08:28:28 <Heffalump> DIW? Dead In the Water?
08:28:39 <fasta> Is there an easy test to see whether a monadic function generating a list is lazy?
08:28:43 <Heffalump> I use HaskellDB and it seems to work ok, although it produces some pretty ugly and slow queries.
08:28:56 <ketil> Heffalump: saw somebody claim no development for HaskellDB.
08:28:57 <fasta> Hmm, I could pas undefined, never mind.
08:29:12 <mux> ketil: the problem was that every query on the db returned SqlString's
08:29:14 <Lemmih> mux: I have a hacked version of HDBC that uses ByteStrings for binary data.
08:29:20 <mux> it's not a matter of fromSql/toSql AFAICT
08:29:23 <Heffalump> it's not getting much/any work, yeah. But I don't think it desperately needs any.
08:29:36 <ketil> Lemmih: Oooh.  We wants it!
08:29:42 <mux> Lemmih: yummy!
08:30:29 <ketil> Heffalump: Okay.
08:30:55 <ketil> When HackageDB supports linking by dependency, it'll be easier to see what is being used and what
08:31:01 <ketil> 's not. (sigh)
08:31:36 <Heffalump> how will that tell us what's being used?
08:31:51 <mudge> anyone from san francisco area or bay area here?
08:31:56 <ketil> mux: I get SqlStrings as well, but fromSql turns them into ints.
08:32:04 <ketil> Works for me.
08:32:47 <mudge> what server is this,  freenode?
08:33:24 <Lemmih> mudge: Roll 3d6 to find out.
08:33:37 <mudge> what is 3d6?
08:33:39 <Lemmih> ?dice 3d6
08:33:39 <lambdabot> 3d6 => 8
08:33:47 <puusorsa> 3 times 6 sided
08:33:50 <Lemmih> mudge: You are indeed on freenode.
08:34:01 <mudge> oh thanks
08:34:01 <Cale> I'm afraid you're stuck with 8 strength now.
08:34:07 <puusorsa> ?dice 1d72
08:34:07 <lambdabot> 1d72 => 25
08:34:27 <puusorsa> i have 25 charisma!
08:34:36 <mudge> map (6+) [1,2,3,4,5,6]
08:34:42 <olsner> ?dice 1d72
08:34:42 <lambdabot> 1d72 => 9
08:34:45 <Cale> > map (6+) [1,2,3,4,5,6]
08:34:47 <lambdabot>  [7,8,9,10,11,12]
08:34:50 <mudge> ah
08:35:16 <Cale> (note also that the space after > is non-optional)
08:35:26 <mudge> > filter even [1,2 ,3,4,5,6,7,8,9,10]
08:35:27 <lambdabot>  [2,4,6,8,10]
08:35:27 <mudge> thanks
08:35:28 <ricky_clarkson> length [1..] makes ghci not respond - any way of preventing this?
08:35:35 <mux> ketil: well I guess I got it wrong and didn't understand how HDBC was supposed to work; I'll have to take another look : -)
08:35:43 <Cale> ricky_clarkson: by not entering a non-terminating program?
08:35:46 <v0|d> ricky_clarkson: take n $ length [1..]
08:35:56 <xerox> v0|d: the other way around (:
08:36:01 <ndm> ricky_clarkson: try 1::Int
08:36:03 <v0|d> xerox: right:)
08:36:16 <mudge> hey what if I give lambdabot an expression that loops infinitely?
08:36:34 <puusorsa> the dungeon collapses
08:36:36 <xerox> mudge: you do that and discover (:
08:37:06 <mudge> > [1 ..]
08:37:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:37:19 <mudge> it gave up
08:37:21 <phobes> > length [1 ..]
08:37:21 <Cale> > length [1..]
08:37:25 <phobes> haha I won
08:37:28 <lambdabot> Terminated
08:37:29 <lambdabot> Terminated
08:37:36 <tonfa> timeout
08:37:36 <Cale> > let x = x in x
08:37:38 <lambdabot>  Exception: <<loop>>
08:37:39 <ricky_clarkson> I'd rather ghci did that.
08:37:54 <ndm> ricky_clarkson: 6.6.1 or 6.4.2?
08:37:56 <Cale> ricky_clarkson: You can just hit ctrl-c
08:38:04 <ricky_clarkson> 6.6.1
08:38:10 <ndm> Cale: not always, on 6.4.2 that doesn't work certainly
08:39:05 <Cale> Really? It's worked since 5.04 for me. (which was the first version of GHC that I used)
08:39:17 <ndm> Cale: windows?
08:39:20 <Cale> Nope.
08:39:33 <ndm> it has a reasonable success rate for me, but not on all computations
08:39:56 <ricky_clarkson> Ctrl-C eventually exits ghci.
08:39:58 <Cale> I wonder if the way that it terminates the computation is different on windows and linux.
08:40:05 <ricky_clarkson> (Windows)
08:40:11 <[TWiSTED]> map (6+) [1,2,3,4,5,6]
08:40:14 <Cale> ricky_clarkson: oh, that's not good
08:40:30 <Cale> ricky_clarkson: Here it only terminates the computation, and you need Ctrl-D to quit.
08:40:45 <ndm> ricky_clarkson: if you do Ctrl+C twice, it quits GHCi - if you just hit it once and waited it might work for you
08:41:00 <ricky_clarkson> I got impatient and started pressing it lots of times.
08:42:12 <ndm> yeah, thats standard behaviour, two hits and it just exist
08:43:46 <SamB> ndm: that's annoying, given how long it takes to answer a ^C
08:43:51 <Igloo> On Windows there's a ghcii which behaves better
08:44:08 <Igloo> I have the impression catching ^C properly is harder on Windows
08:44:22 <SamB> ah
08:44:30 <EvilTerran> ^brk works better for me
08:44:39 <SamB> on ReactOS it's even harder
08:45:02 <SamB> (^C doesn't seem to be implemented yet...)
08:45:23 <ndm> Igloo: if this ghcii is better, why isn't it the default?
08:45:31 <ndm> i was unaware it even existed...
08:45:50 <Igloo> I don't know. Doesn't ghci tell you to use it when it starts?
08:46:01 <Syzygy-> [TWiSTED]: You need "> " before the instructions if you want them evaluated.
08:46:36 <ndm> Igloo: nope, never seen it mentioned at all, or referred to
08:47:09 <ricky_clarkson> ctrl-c once doesn't seem to be caught at all.
08:47:18 <ricky_clarkson> (and slows Vista to a crawl)
08:47:23 <ndm> Igloo: ghcii.sh ? I somehow don't think thats going to work...
08:47:26 <Igloo> Oh, it looks like that's only the case in "*nix-like shells (cygwin-bash, in particular"
08:47:30 <olsner> what's ghcii?
08:47:42 <Igloo> And you only see it if _ is set, which presumably only happens in such shells
08:51:46 <puusorsa> do not try this in a shell:
08:51:47 <puusorsa>  :() { :&:; } ;:
08:52:33 * roconnor doesn't try it
08:53:28 <dmead_> hehe
08:53:33 <bos> @quote template
08:53:33 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
08:53:36 <bos> @quote template
08:53:36 <lambdabot> ghc says: Cannot desugar this Template Haskell declaration
08:53:37 <dmead_> thats how they test the new sd schedule
08:53:38 <bos> @quote template
08:53:38 <lambdabot> ghc says: Can't represent a guarded lambda in Template Haskell
08:53:40 <bos> @quote template
08:53:40 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
08:53:44 <bos> bah.
08:53:53 <dmead_> @quote dmead
08:53:53 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
08:54:08 <dmead_> @quote cale
08:54:08 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
08:54:11 <dmead_> @quote cale
08:54:11 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
08:54:15 <dmead_> @quote dons
08:54:16 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
08:54:23 <Cale> @quote Cale
08:54:23 <lambdabot> Cale says: I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
08:54:27 <Cale> @quote Cale
08:54:27 <lambdabot> Cale says: I think we should take 0=1. Then 0 is invertible
08:54:41 <Cale> (it's case sensitive, strangely enough)
08:54:43 <olsner> @remember puusorsa do not try this in a shell: :() { :&:; } ;:
08:54:43 <lambdabot> Done.
08:54:52 <olsner> @quote
08:54:52 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
08:55:03 <puusorsa> olsner, you did? :-p
08:55:14 <puusorsa> looks a bit like perl
08:55:31 <olsner> I don't quite see what it will do, so I trust that it'll do something bad
08:55:38 <Cale> It defines a function called :
08:55:40 <evir> olsner: It's a fork bomb.
08:55:53 <olsner> the & hints at something forking, yeah, so I guessed it was a fork bomb or similar
08:55:55 <evir> Forking shells one after another.
08:56:12 <olsner> oh, didn't think : was a possible function name though
08:56:36 <puusorsa> but it is :)
08:56:44 <puusorsa> good clean fun for the whole family!
08:56:44 <olsner> now I see the syntax... f() { f& f; } ; f
08:56:58 <Cale> Does & actually fork though?
08:57:06 <Heffalump> err, yes
08:57:15 <Heffalump> how else would it execute in the background?
08:57:15 <Cale> oh, right
08:57:40 <Cale> It's rather like f&; f
08:57:49 <puusorsa> (sorry for offtopic, that just came to my mind as someone mentioned infinte loops to lambdabot)
08:57:52 <evir> Not a logical &. :-)
08:57:56 <mux> it's weird if : is an allowed function name, since it's a pre-defined function in shell scripting that always returns true
08:58:00 <Cale> Yeah, I was thinking of &&
08:58:18 <mux> often used for stuff like: while :; do ...; done
08:58:33 <Igloo> Only Haskell steals the name : for no good reason  :-)
08:58:48 <mux> heh
08:58:54 <puusorsa> i think they allow it for function names just for that fork bomb
08:59:04 <mux> lol
08:59:21 <puusorsa> write-only code <3
08:59:44 <evir> Well you're not going to change a fork bomb when it works, anyway...
09:00:51 <dcoutts_> ndm: ping
09:00:55 <Cale> Haskell steals it for a pretty good reason, I'd say :)
09:01:01 <puusorsa> lolcode.com
09:01:15 <puusorsa> next ghc version needs to be done in lolcode
09:01:43 <olsner> is : used for anything/a valid identifier in haskell?
09:02:01 <Botje> :t (:)
09:02:04 <lambdabot> forall a. a -> [a] -> [a]
09:02:06 <mux> : is cons
09:02:17 <mux> > 1:[2,3]
09:02:17 <Botje> > let (:) = (+) in 5 : 3
09:02:19 <lambdabot>      Constructor `:' should have 2 arguments, but has been given 0
09:02:19 <lambdabot>     In the...
09:02:19 <lambdabot>  [1,2,3]
09:02:39 <Botje> > let (:) a b = (+) a b in 5 : 3
09:02:39 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
09:02:39 <lambdabot>       Expected...
09:02:44 <Botje> pah.
09:05:14 <ndm> dcoutts_: pong
09:05:30 <dcoutts_> ndm: any interest in fixing cabal's windows install paths?
09:05:36 <lament> why is : magical anyway?
09:05:52 <ndm> dcoutts_ honestly, not really - and isn't the problem of fixing just trying to find out what they should be?
09:06:03 <olsner> ah, : is cons! how could I forget
09:06:11 <ndm> certainly not before my paper deadline on friday :)
09:06:18 <dcoutts_> ndm: well if you prefer we can leave it borken :-)
09:06:33 <dcoutts_> ndm: yes, all it needs is a decision
09:06:43 <ndm> dcoutts_ its the cabal windows way :)
09:07:13 <ndm> dcoutts_ my solution would be to follow the same pattern as unix, and have no relocatable libraries
09:07:42 <ndm> i'm not convinced a binary library is very useful, if you can make it trivial to build them yourself
09:07:43 <dcoutts_> ndm: I wonder how we make a decision, when you and eivuokko disagree :-)
09:08:10 <ndm> dcoutts_ follow eivuokko - he's trying to do cleverer things with a better longer term result, i'm being lazy for short-term gain
09:08:28 <RogerTaylor> Hello, can anyone give me a little (more) help with Cabal? Specifically, what the kosher thing to do with .hsc files is.
09:08:33 <dcoutts_> I just want people who care about windows to make a short-term decision
09:09:01 <dcoutts_> since we have to fork for a release within days
09:09:04 <ndm> dcoutts_ follow eivuokko - he's going to put in the time to get it working, and seems to know what he's doing, i'm happy to trust him with the decision
09:09:16 <dcoutts_> ndm: right'o
09:09:35 <ndm> dcoutts_ does that mean i need to fix up those filepath bugs pretty quick then?
09:09:40 <dcoutts_> ndm: yep
09:09:52 <dcoutts_> ndm: it's just normalise iirc
09:09:55 <ndm> dcoutts_ when is release day? it shouldn't be more than a few hours hacking
09:10:16 <ndm> dcoutts_- i've got another open bug on paths, apparently the unix spec requires PATH="" to mean PATH="."
09:10:30 <RogerTaylor> I'm trying to hack HSQL into shape, against the latest Cabal etc.
09:10:37 <dcoutts_> ndm: ask Igloo for specifics, but the 6.8 fork is end of the month with a 6.8.1 release a month later or so
09:10:47 <ndm> @karma+ RogerTaylor -- a worth thing to do
09:10:48 <lambdabot> RogerTaylor's karma raised to 1.
09:10:56 <RogerTaylor> If I add this to emptyBuildInfo:
09:10:59 <dcoutts_> RogerTaylor: list all your exposed and other modules in the .cabal file, Cabal will discover the .hsc files and run hcs2hs
09:11:17 <RogerTaylor> Yes, there is precisely 1 module, and it is exposed
09:11:28 <RogerTaylor> I'm only interested in the PostgreSQL backend for the moment
09:11:29 <SamB> ndm: heh, when I read what you said I thought: "what the heck? no relocatable libraries? all our libraries are relocatable!"
09:11:33 <RogerTaylor> on Linux
09:11:56 <dcoutts_> SamB: libraries with data files are not relocatable on any os atm.
09:11:56 <SamB> then I scrolled up and saw you talking about paths
09:12:09 <RogerTaylor> but apparently Krasimir went to some effort to make the build system Windows-happy
09:12:15 <RogerTaylor> anyway
09:12:19 <RogerTaylor> to be specific
09:12:37 <ndm> dcoutts_ - they could feasibly be with Yhc, if we had any Cabal support
09:12:40 <SamB> dcoutts: see, we need a MacOS Classic port
09:12:48 <RogerTaylor> if I add a hsSourceDirs field:
09:12:48 <RogerTaylor>        let bi = emptyBuildInfo{extraLibDirs=lib_dirs,
09:12:49 <RogerTaylor>                                includeDirs=inc_dirs ++ inc_dirs_server,
09:12:49 <RogerTaylor>                                hsSourceDirs=["dist/build"]}
09:12:53 <RogerTaylor> it goes fine
09:13:01 <RogerTaylor> without it GHC can't find the generated .hs file
09:13:02 <dcoutts_> ndm: yes, we're still waiting for yhc patchs for Cabal :-)
09:13:25 <dcoutts_> RogerTaylor: you should not need to do any Setup.hs hacking
09:13:36 <RogerTaylor> take a look at what Krasimir did
09:13:37 <dcoutts_> RogerTaylor: just list the exposed modules, cabal will find the .hsc file
09:13:41 <SamB> really, I think *nix could do better about that
09:13:46 <ndm> dcoutts_, if you could compile the base with proper dependency analysis, you'd get it a lot sooner
09:13:48 <RogerTaylor> rather than a Unix-y autoconf effort, he's done it all in Haskell
09:13:59 <SamB> :-(
09:14:10 <ndm> dcoutts_, also if you wrote my phd, then gave me money to hack on Yhc for a year, we'd get it done...
09:14:11 <dcoutts_> ndm: I'm hoping we could work on dep stuff at the hackathon
09:14:29 <dcoutts_> ndm: are you coming to the hackathon?
09:14:34 <ndm> dcoutts_ - cool, i'm definately going to IFL+HW+ICFP, still need to figure out hackathon
09:14:41 <dcoutts_> ok
09:15:03 <ndm> dcoutts_ you going to IFL?
09:15:10 <dcoutts_> ndm: no, HW+ICFP
09:15:14 <dcoutts_> RogerTaylor: perhaps you can say what goes wrong
09:15:32 <ndm> dcoutts_ - i was looking into registration for everything, and the IFL one is free fro students
09:15:42 <RogerTaylor> Well, if I say "look for .hs files in dist/build" it works
09:15:44 <dcoutts_> RogerTaylor: or a url for the package you're talking about
09:15:50 <RogerTaylor> without it, GHC can't find anything to build
09:16:09 <dcoutts_> RogerTaylor: you're using Cabal-1.1.6.x right?
09:16:18 <RogerTaylor> http://darcs.haskell.org/HSQL/
09:16:19 <lambdabot> Title: Index of /HSQL
09:16:31 <RogerTaylor> nope, Cabal from darcs
09:16:41 <RogerTaylor> I needed it for some other package
09:16:43 <RogerTaylor> hence this hackage
09:16:58 <Igloo> Cale: What is the good reason for stealing (:) that doesn't apply to (+), id, Id, etc?
09:18:16 <ndm> Igloo: what implementations actually steal (:) - i know both Hugs and Yhc don't
09:18:48 <Igloo> I'm pretty sure GHC does, and anything in H98-mode ought to
09:19:21 <dcoutts_> RogerTaylor: it looks sensible, what goes wrong
09:21:36 <RogerTaylor> the version in HSQL in darcs?
09:21:45 <RogerTaylor> I'm talking about the Cabal stuff for the PostgreSQL backend
09:22:02 <RogerTaylor> firstly, it needs some minor hacking to update it to darcs Cabal, minor type changes
09:23:46 <RogerTaylor> Here's what I hacked it into:
09:23:47 <RogerTaylor> http://hpaste.org/2461#a0
09:24:37 <RogerTaylor> Without the hsSourceDirs line it doesn't find the .hs file, and without all the other jazz it doesn't find the headers.
09:28:00 <dcoutts_> RogerTaylor: I'm trying a build too
09:30:22 <RogerTaylor> dcoutts_: it's unfortunately hardwired to PostgreSQL 8.2, but it seems to work ok on Debian
09:36:29 <Cale> Igloo: Well, it must be a data constructor because it starts with ':', and who really writes programs without the list datatype in scope?
09:38:06 <Igloo> Cale: That's no reason to disallow it, though
09:45:00 <ddarius> Igloo: (:) not being able to be defined?
09:45:50 <Igloo> ddarius: Yup
09:45:56 <dcoutts_> RogerTaylor: it works fine for me, no need to set hsSourceDirs=["dist/build"]
09:46:02 <ddarius> I'm for it being usabel.
09:46:09 <RogerTaylor> dcoutts_: What platform?
09:46:17 <dcoutts_> RogerTaylor: it already looks in dist/build by defauilt
09:46:17 <RogerTaylor> IIRC it worked OK on OS X
09:46:25 <dcoutts_> RogerTaylor: linux
09:47:13 <dcoutts_> RogerTaylor: in Distribution.Simple.GHC.ghcOptions it adds ++ ["-i" ++ buildDir lbi] to the list of commands
09:47:32 <dcoutts_> RogerTaylor: and if you run the build with -v you'll see that it adds -i dist/build
09:47:41 <augustss> It's totally nonsensical that (:) can't be redefined
09:48:21 <RogerTaylor> dcoutts: Give me a sec, I'll paste a log for you.
09:49:22 <dcoutts_> RogerTaylor: and you are using the latest Cabal from darcs?
09:49:40 <RogerTaylor> dcoutts_: yes, well, almost.
09:49:43 <RogerTaylor> from a few days ago
09:49:47 <Stinger> what's the premiere Haskell database/sql library these days? or what are some of the main options?
09:49:58 <dcoutts_> RogerTaylor: should be fine, that stuff has been there for ages
09:50:33 <glen_quagmire> > and' [True, True, False, True] where and' = foldr (\a b -> a && b) True
09:50:33 <lambdabot>  Parse error
09:50:40 <ddarius> http://haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
09:50:42 <lambdabot> Title: Applications and libraries/Database interfaces - HaskellWiki, http://tinyurl.com/32a6lg
09:51:12 <RogerTaylor> dcoutts_: ok, here you go. I can give you more details if you need them:
09:51:14 <RogerTaylor> runghc Setup.*hs build -v
09:51:15 <RogerTaylor> Reading parameters from /mnt/hgfs/peteg/src/WebFramework/HSQL/PostgreSQL/PostgreSQL.buildinfo
09:51:15 <RogerTaylor> Creating dist/build (and its parents)
09:51:15 <RogerTaylor> Creating dist/build/autogen (and its parents)
09:51:16 <RogerTaylor> Preprocessing library hsql-postgresql-1.7...
09:51:16 <RogerTaylor> Creating dist/build/Database/HSQL (and its parents)
09:51:17 <RogerTaylor> Building hsql-postgresql-1.7...
09:51:19 <RogerTaylor> Building library...
09:51:22 <RogerTaylor> Creating dist/build (and its parents)
09:51:23 <RogerTaylor> Creating dist/build (and its parents)
09:51:25 <RogerTaylor> <command line>:
09:51:27 <RogerTaylor>     Could not find module `Database.HSQL.PostgreSQL':
09:51:29 <RogerTaylor>       it is a member of package hsql-postgresql-1.7, which is hidden
09:51:33 <dcoutts_> RogerTaylor: use hpaste.org
09:51:38 <RogerTaylor> Sorry, I'll stick that on hpaste :-)
09:51:40 <ddarius> _.pdf ?
09:52:34 <RogerTaylor> dcoutts_: http://hpaste.org/2462
09:53:07 <RogerTaylor> dcoutts_: I see your -I flag, but somehow GHC gets a bit confused.
09:53:20 <RogerTaylor> $ ghc --version
09:53:21 <RogerTaylor> The Glorious Glasgow Haskell Compilation System, version 6.6.1
09:54:16 <dcoutts_> RogerTaylor: there's a stray -i there
09:54:23 <dcoutts_> for some reason
09:54:29 <dcoutts_> we should track that down
09:54:44 <dcoutts_> RogerTaylor: see, in your build it says:
09:54:45 <dcoutts_> -i -idist/build/autogen -idist/build -i -i.
09:54:47 <RogerTaylor> I see two now that you mention it
09:54:48 <RogerTaylor> yes
09:54:56 <dcoutts_> in mine it's just -idist/build -i.
09:55:02 <RogerTaylor> hmm
09:55:03 <dcoutts_> erm
09:55:07 <dcoutts_> -i -idist/build/autogen -idist/build -i.
09:55:30 <RogerTaylor> OK, I got rid of those 2 and it works
09:55:42 <dcoutts_> so that extra "-i" on it's own means ignore all previous -i flags
09:55:56 <dcoutts_> RogerTaylor: do you know where that -i was coming from?
09:56:00 <RogerTaylor> no
09:56:10 <RogerTaylor> i don't think i'm doing anything particularly weird.
09:56:19 <RogerTaylor> i'll hpaste up the the .cabal file too
09:56:41 <dcoutts_> RogerTaylor: ok, and you removed that hsSourceDirs=... bit right?
09:56:47 <RogerTaylor> yes
09:56:53 <RogerTaylor> actually, let me check
09:56:54 <RogerTaylor> :-)
09:57:31 <RogerTaylor> yes, that seemed to do the trick
09:57:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2463
09:58:18 <RogerTaylor> dcoutts_: http://hpaste.org/2463 - PostgreSQL.cabal
09:58:47 <RogerTaylor> urk
09:58:51 <RogerTaylor> make that .buildinfo
09:59:15 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2464
09:59:31 <RogerTaylor> http://hpaste.org/2464 - hsql-postgresql.cabal
09:59:49 <RogerTaylor> small mod - make it happy with a more recent Cabal
10:00:24 <dcoutts_> RogerTaylor: so what did you change that made the -i go away?
10:00:38 <RogerTaylor> Oh, I just ran the ghc command line
10:00:46 <RogerTaylor> that worked when the -i's were removed
10:00:58 <RogerTaylor> there is only 1 source file so it's no big deal to compile
10:00:59 <dcoutts_> so it still comes up with -i when you run normally
10:01:03 <RogerTaylor> yes
10:01:06 <dcoutts_> bizarro
10:01:09 <RogerTaylor> yep
10:01:24 <dcoutts_> ++ ["-i" ++ l | l <- nub (hsSourceDirs bi)]
10:01:28 <RogerTaylor> hold on
10:01:32 <dcoutts_> it's coming from here somehow ^^^
10:01:37 <RogerTaylor> I might be running Cabal 1.1.6.2
10:01:40 <dcoutts_> ah
10:01:44 <RogerTaylor> that's the prob?
10:02:02 <dcoutts_> no, that's correct, but that would be the only place those flags could come in via
10:02:28 <dcoutts_> so I'd start looking at hsSourceDirs, but if you say you're using Cabal-1.1.6.2 then that's a different matter
10:03:20 <RogerTaylor> actually, I don't know which I'm using - i'm talking about the one running under a Linux VMWare session, and ghc-pkg list looks like: /usr/lib/ghc-6.6.1/package.conf:
10:03:20 <RogerTaylor>     Cabal-1.1.6.2, Cabal-1.1.7, ...
10:05:46 <dcoutts_> RogerTaylor: to be sure you can: ghc -package Cabal-1.1.7 Setup.lhs -o setup
10:06:18 <dcoutts_> then ./setup clean; ./setup configure; ./setup build -v
10:06:53 <RogerTaylor> yeah, same problem
10:07:00 <RogerTaylor> the ghc line from "build": /usr/X11R6/bin/ghc -package-name hsql-postgresql-1.7 --make -hide-all-packages -i -idist/build/autogen -idist/build -i -i. -Idist/build -I/usr/include/postgresql -I/usr/include/postgresql/8.2/server -odir dist/build -hidir dist/build -package base-2.1.1 -package hsql-1.7 -O -fffi -cpp Database.HSQL.PostgreSQL
10:07:35 <RogerTaylor> (Just ignore the X11R6 gunk, my path is a bit FUBAR presently.)
10:07:47 <hpaste>  (anonymous) pasted "Any way to make make this terminate?" at http://hpaste.org/2465
10:10:24 <RogerTaylor> dcoutts_: I'm off, but if you would like more info just post it here, and I'll check in the morning. Thanks for your time.
10:10:29 <dcoutts_> RogerTaylor: ok
10:12:33 <dcoutts_> RogerTaylor: I suspect one problem might be fixed in the very latest Cabal from yesterday
10:12:42 <dcoutts_> it was to do with handling of "." paths
10:15:53 <fasta> dcoutts_: Is it possible to build a billion element tree with strefs and get the top from it in 0 ms (i.e. lazy)?
10:16:21 <dcoutts_> fasta: not without using unsafeInterleaveIO
10:16:57 <fasta> dcoutts_: but I have STRefs, not IORefs
10:16:57 <dcoutts_> erm, for ST, no. since there is no equivalent of unsafeInterleaveIO
10:17:13 <dcoutts_> since creating STRefs cannot be done lazily
10:17:13 <fasta> dcoutts_: and why is it unsafe?
10:17:21 <dcoutts_> it reorders side effects
10:18:11 <dcoutts_> so it's generally only used for cases where the side effects are benign
10:18:47 <fasta> dcoutts_: ok, what about having a reference to the billion element structure and traversing it lazily?
10:18:54 <fasta> dcoutts_: is that possible?
10:19:05 <dcoutts_> that's fine, building it is the problem
10:19:54 <fasta> dcoutts_: since, I am pretty sure that my function traverses all nodes, returns a list of them and then takes only the first x.
10:19:59 <hpaste>  MacTep pasted "For pierre" at http://hpaste.org/2466
10:20:18 <fasta> dcoutts_: instead of only traversing the first x and returning them.
10:20:27 <dcoutts_> fasta: depends on how lazy your traversal is then, if that'll work nicely
10:20:59 <dcoutts_> fasta: it is certainly possible to do lazy preorders
10:21:53 <sjanssen> dcoutts_: there is unsafeInterleaveST
10:21:54 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
10:22:46 <dcoutts_> sjanssen: oh, I didn't know that
10:23:00 <dcoutts_> fasta: then it's possible to build the tree lazily too then
10:23:33 <dcoutts_> fasta: but your traversal is not lazy
10:23:40 <Cale> hmmmmm
10:23:41 <dcoutts_> it's operating in the ST monad and reading ST refs
10:23:55 <fasta> dcoutts_: I am more interested in getting the traversal lazy.
10:24:12 <Cale> anyone here familiar with sparse file support on linux?
10:24:21 <dcoutts_> to make that lazy you'd also need to use unsafeInterleaveST or not read any refs and make it pure/non-monadic
10:24:57 <dcoutts_> fasta: you see why it's not lazy?
10:25:04 <fasta> dcoutts_: actually, no
10:25:15 <dcoutts_> and why ST cannot make reading or writing refs lazy
10:25:22 <fasta> dcoutts_: actually, I do
10:25:32 <dcoutts_> since otherwise there'd be no control over the order of reads/writes
10:25:41 <dcoutts_> and the order can affect the result
10:25:58 <dcoutts_> and ST is supposed to be pure, not non-deterministing (like IO is allowed to be)
10:26:05 <dcoutts_> non-deterministinc
10:26:10 <fasta> dcoutts_: hmm, no, I don't really see.
10:26:13 <dcoutts_> bah, can't spell
10:26:20 <fasta> dcoutts_: please elaborate
10:26:29 <fasta> dcoutts_: on the laziness
10:26:33 <dcoutts_> fasta: imagine if a lazy read of a ref got deferred after a write
10:26:40 <dcoutts_> it'd get a different result
10:26:46 <dcoutts_> ordering is crucial with mutable vars
10:28:35 <dcoutts_> fasta: so when you do liftM (ref_dll:) (all_references ref_dll'), it really has to run the whole all_references ref_dll' action, performing all the var reads, before it can construct the result
10:29:04 <dcoutts_> but what you want to do is to lazily defer the all_references ref_dll' action
10:29:19 <dcoutts_> since you promise that chaning when that is run has no effect on the final result
10:29:36 <dcoutts_> if you can make that guarantee then you can use unsafeInterleaveST
10:30:15 <dcoutts_> but for example, you need to know that none of the STRefs read by all_references ref_dll' are written between when you defer it and when you force it.
10:30:28 <fasta> dcoutts_: so, it's not possible to do without unsafeInterleaveST?
10:30:53 <fasta> dcoutts_: can't I for example build a list of actions first and only take a subset of those?
10:32:55 <dcoutts_> fasta: you can build a list of action, but notice that your actions are actually dependent on the results of earlier ones.
10:33:40 <fasta> dcoutts_: yes, I know they are dependent. Is that a long answer, for "no"?
10:33:47 <dcoutts_> fasta: unless I misunderstand what your traversal is doing
10:34:23 <dcoutts_> fasta: if you're basing what to traverse next on reading a ref, then you're stuffed, unless you use unsafeInterleaveST
10:35:03 <fasta> dcoutts_: ok, and unsafeInterleaveST actually works? I.e. have you ever used the IO variant and did it work?
10:35:16 <dcoutts_> fasta: sure
10:35:32 <sfultong> what does everyone think of unsafeIOToSTM? necessary, or just ugly?
10:35:38 <dcoutts_> fasta: eg a lazy directroy tree traversal
10:36:48 <shapr> sfultong: When is it necessary?
10:37:47 <SamB_XP_> heh
10:38:02 <SamB_XP_> IE says "this page cannot be displayed" about about:blank
10:38:08 <sjanssen> sfultong: sounds incredibly dangerous
10:38:10 <sfultong> shapr: well, I suspect that it isn't, but it is probably easier... for instance, if you are writing a network client, and you want a send/receive block to be atomic
10:38:20 <sorear> *unsafe*IOtoSTM
10:38:24 <fasta> dcoutts_: is nesting unsafe calls a bad idea?
10:38:32 <dcoutts_> fasta: no
10:38:37 <sorear> doen't sound any more dangerous than unsafeCoerce!
10:38:40 <sjanssen> sfultong: remember that an STM transaction can run any number of times
10:38:55 <dcoutts_> fasta: no more of a bad idea than using unsafeInterleave in the first place
10:39:09 <SamB_XP_> most of the things I can think of that are in IO would block...
10:39:10 <dcoutts_> fasta: in fact usually you have to nest them
10:41:09 <fasta> dcoutts_: are you saying it's a better idea to provide an interface takeNReferences?
10:41:52 <fasta> dcoutts_: (which takes n references instead of all)
10:43:39 <dcoutts_> fasta: probably
10:43:54 <dcoutts_> fasta: but using unsafeInterleaveST isn't that bad you know
10:44:00 <fasta> dcoutts_: is there some inherent slowness associated with using it?
10:44:02 <glen_quagmire> i found that i can do iterative programming in haskell using do block
10:44:08 <dcoutts_> fasta: no
10:44:09 <fasta> dcoutts_: my code runs 1.5 times _slower_ now.
10:44:44 <dcoutts_> fasta: it creates a suspension, but that's what you do with all lazy coding
10:47:40 <hpaste>  shapr pasted "hello world from jhc" at http://hpaste.org/2467
10:47:44 <shapr> glen_quagmire: Hey, jhc produces more readable C source code.
10:48:44 <glen_quagmire> shapr: that's awesome.
10:49:00 <lindzeyn> Hello everyone, Does someone know offhand the best flags to throw for an efficient compilation of haskell code using ghc
10:49:15 <glen_quagmire> is jhc optimized ghc?
10:49:41 <glen_quagmire> oh nevermind i was confused with other project
10:51:19 <ivant> shapr, is the code stripped?
10:51:29 <ivant> I mean, it is not a complete file, is it?
10:51:42 <_roconnor> @quote unsafe
10:51:42 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
10:51:42 <lambdabot> a really bad one
10:52:26 <sorear> lindzeyn: -O2
10:52:26 <fasta> dcoutts_: to be completely clear: when I only take the first 5 elements from that list, none of the other ST actions not needed for created those elements will be executed, right?
10:52:40 <sorear> lindzeyn: oh, you said efficient *compilation*
10:52:43 <sorear> lindzeyn: -O0
10:53:08 <dcoutts_> fasta: I'm not sure what code you're using now
10:53:49 <fasta> dcoutts_: the same as what I pasted.
10:54:02 <fasta> dcoutts_: but with unsafeInterleaveST
10:54:31 <dcoutts_> fasta: where did you put unsafeInterleaveST
10:54:46 <phobes> sorear:  I think he wanted the compiled code to be efficient, not the compiling.
10:54:56 <lindzeyn> oh, sorry sorear
10:55:02 <lindzeyn> I meant efficient machine code
10:55:15 <lindzeyn> in that case, 05?
10:55:23 <lindzeyn> O5
10:55:30 <sorear> O2
10:55:34 <lindzeyn> thanks
10:55:59 <sorear> the option parser treats -O3 and up as essentially -O0
10:55:59 <fasta> dcoutts_: s/= do/= do unsafe<etc> $ do <rest of code>
10:56:14 <glen_quagmire> what's your favorite food and programming language?
10:56:18 <lindzeyn> good to know
10:56:28 <sorear> glen_quagmire: I don't program my food
10:56:35 <lindzeyn> chocolate and lisp
10:56:40 <lindzeyn> hehe, bad joke
10:56:47 <fasta> dcoutts_: ok, now the unsafeInterleaveST worked
10:58:04 <dcoutts_> fasta: good good
11:00:21 <EvilTerran> haskell and curry!
11:00:31 <Vulpyne> Good one.
11:00:40 <EvilTerran> (this is actually very close to the truth)
11:01:53 <sfultong> curry is one of my favorite foods
11:02:19 <sfultong> and so far I haven't found any language better than haskell... otherwise, I wouldn't be here :-P
11:02:26 <mcnster> nearing the magic 400
11:02:35 <EvilTerran> again
11:03:08 <lament> sfultong: there's nothing wrong with using more than one language...
11:03:33 <lament> i haven't found any instrument better than a piano, but pianos just aren't very good to drum on...
11:03:40 <mcnster> whenever the OneTrue[tm] language is discovered, /me gets nervous
11:03:47 <hpaste>  (anonymous) pasted "unsafeInterleaveST not lazy enough" at http://hpaste.org/2468
11:03:49 <VerbalDK> well - a good drummer would disagree
11:04:08 <fasta> dcoutts_: but ^^ that example still does't run.
11:04:14 <lament> VerbalDK: oh, it's possible, it just isn't very good
11:04:22 * VerbalDK opens the piano and starts tapping the strings with the sticks
11:04:23 <lament> don't think i haven't tried
11:05:11 <mcnster> don't bother with sticks, just hum your note and the strings will play themselves sympathetically
11:05:22 <sfultong> pianos are a precussion instrument, hence they must be good to drum on
11:05:34 <VerbalDK> i have a cheap piano
11:05:40 <dcoutts_> fasta: that's because you're not using unsafeInterleaveST in the right place
11:05:41 * VerbalDK kicks piano
11:05:57 <xerox> ?babel it en piano!
11:05:58 <lambdabot>   slowly!
11:05:59 <lament> sfultong: percussion doesn't mean drum
11:06:09 <fasta> dcoutts_: I assumed it would apply to the whole computation.
11:06:10 <VerbalDK> maybe this is not the right place to spam pianos >.<
11:06:11 <sfultong> lament: yeah, I know, I was just being silly
11:06:16 <fasta> dcoutts_: it doesn't?
11:06:30 <dcoutts_> fasta: think about what that code does, when you force z, then it forces the action which then takes 4 elements of bar, but running bar takes for ever
11:07:02 <dcoutts_> fasta: you want to defer the evaluation of the tail of bar
11:07:45 <dcoutts_> fasta: you're defering the whole thing at the top level, but then as soon as you force that, you're running everything monolithicly
11:08:11 <fasta> dcoutts_: ok, so, I should use unsafe<> as "lazy" in Scheme.
11:08:12 <mcnster> does ne1 know the name of the project that does yearly benchmarks of languages (incl. haskell, clean, etc) in 20 or so different areas?
11:08:21 <dcoutts_> fasta: yes
11:08:36 <fasta> dcoutts_: I thought, it was a marker for everything below it.
11:08:38 <sfultong> If a language is turing complete, then there is no problem that it is unsuited for... so choice of language just comes down to the expressiveness, and so far I haven't found anything more expressive than Haskell (ok, maybe lisp, but I haven't really explored lisp much)
11:08:42 <dcoutts_> fasta: the reason it worked for your ealier example was because it was using it recursivly
11:09:05 <sfultong> oops, gotta go
11:09:06 <dcoutts_> fasta: it's not magic, it's a one place suspend/defer/thunk
11:09:24 <fasta> dcoutts_: I see, thanks for that clear explanation
11:09:32 <Olathe> Suitability is not the same as acheivability.
11:09:42 <dcoutts_> fasta: np
11:09:56 <fasta> dcoutts_: ok, is works.
11:09:59 <shapr> ivant: Actually, I think that C source is the complete program.
11:10:02 <fasta> dcoutts_: it*
11:10:22 <ivant> shapr, it looks like it is truncated
11:10:29 <ivant> shapr, nevermind
11:12:50 <shapr> ivant: Er, yeah, I think it is.
11:12:57 <fasta> dcoutts_: so, for liftM2 (++) foo bar, where foo and bar are st actions generating elements, I need unsafe<> for both (and probably recursively)?
11:13:08 <dcoutts_> fasta: yep
11:13:35 <shapr> ivant: http://www.scannedinavian.com/~shae/hs.out_code.c
11:18:29 <bos> what version of base was packaged with ghc 6.6?
11:26:21 <glguy> bos: 2.0
11:32:23 <bos> ?
11:32:27 <bos> oh, right, thanks.
11:32:36 <bos> @where+ pcap http://www.serpentine.com/software/pcap/
11:32:36 <lambdabot> Done.
11:35:09 <gaborek> Hi!:)
11:37:37 <byorgey> hi gaborek!
11:38:59 <gaborek> :) I am noob, I am looking how to convert Integer or String to Int :D
11:39:19 <VerbalDK> use a meatcleaver
11:39:30 <wli> gaborek: read s :: Int
11:39:38 <wli> gaborek: fromIntegral n :: Int
11:39:53 <VerbalDK> ..or what he said
11:40:20 <VerbalDK> this is totally out of topic but... : http://www.dailymail.co.uk/pages/live/articles/news/news.html?in_article_id=478042&in_page_id=1770
11:40:23 <lambdabot> Title: Terrifying scenes as zombies storm London | the Daily Mail, http://tinyurl.com/3azvz6
11:40:25 <gaborek> thx :)
11:40:44 <wli> integerToInt :: Integer -> Int ; integerToInt = fromIntegral
11:40:57 <importantshock> VerbalDK: Fucking. Awesome.
11:41:00 <wli> stringToInt :: String -> Int ; stringToInt = read
11:41:28 <kny> VerbalDK: Wow.
11:41:49 <kny> Did they beat the record?
11:42:20 <gaborek> fromIntegral n :: Integral
11:43:05 <wli> gaborek: let { integerToInt :: Integer -> Int ; integerToInt = fromIntegral } in integerToInt (5 :: Integer)
11:43:13 <VerbalDK> i dont know if they beat the record
11:43:19 <VerbalDK> prolly did xD
11:45:44 <wli> > let { integerToInt :: Integer -> Int ; integerToInt = fromIntegral } in integerToInt (5 :: Integer)
11:45:46 <lambdabot>  5
11:45:59 <gaborek> wli: thx :)
11:46:12 <gaborek> little strange for me
11:46:32 <phobes> Int is 32-bit ?
11:46:32 <wli> > let { stringToInt :: String -> Int ; stringToInt = read } in stringToInt "7"
11:46:33 <lambdabot>  7
11:47:07 <phobes> > 65536 * 65536 :: Int
11:47:09 <lambdabot>  0
11:47:13 <wli> phobes: Only guaranteed to be 29-bit IIRC. Most implementations provide the full native wordsize.
11:47:15 <phobes> > 65536 :: Int
11:47:16 <lambdabot>  65536
11:47:33 <gaborek> 2*2 ::int
11:47:34 <phobes> > 65536 * 32768:: Int
11:47:35 <lambdabot>  -2147483648
11:47:48 <gaborek> 2*2 ::Int
11:48:09 <wli> > findIndex (==0) (let is = 1 : map (2*) is in is)
11:48:13 <lambdabot> Terminated
11:48:57 <wli> > findIndex (==0) (let is :: [Int] ; is = 1 : map (2*) is in is)
11:49:03 <lambdabot>  Just 32
11:50:50 <wli> That will tell you how many bits are in an Int. You just need to try it on more arches.
11:51:17 <phobes> What is Haskell some kind of systems programming language?
11:51:29 <wli> I probably need a registerized Linux/PPC64 ghc to do similar on a 64-bit box.
11:56:29 <_roconnor> > bitSize 0
11:56:37 <lambdabot>  Add a type signature
11:56:44 <_roconnor> > bitSize (0::Int)
11:56:45 <lambdabot>  32
11:56:50 <sjanssen> phobes: yes, some systems programming is possible in Haskell
11:57:08 <roconnor> > bitSize (undefined::Int)
11:57:09 <lambdabot>  32
11:57:16 <roconnor> > isSigned (undefined::Int)
11:57:18 <lambdabot>  True
11:58:09 <glguy> ?index bitSize
11:58:10 <lambdabot> Data.Bits, Foreign
11:59:24 <fasta> @src filterM
11:59:24 <lambdabot> Source not found. You type like i drive.
11:59:29 <byorgey> @type bitSize
11:59:31 <lambdabot> forall a. (Bits a) => a -> Int
11:59:39 <fasta> @help @src
11:59:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:59:43 <fasta> @help src
11:59:43 <lambdabot> src <id>. Display the implementation of a standard function
11:59:59 <alar> @instances Bits
12:00:00 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
12:00:40 <int-e> @instances-importing Data.Bits Data.Word Data.Int Bits
12:00:41 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
12:01:15 <byorgey> @source filterM
12:01:15 <lambdabot> filterM not available
12:01:54 <oerjan> byorgey: it's five lines so it's not listed
12:02:12 <byorgey> oerjan: ah, is that why.
12:02:29 <oerjan> @source Control.Monad
12:02:29 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
12:02:35 <oerjan> try there
12:03:05 <roconnor> > fix bitSize
12:03:06 <lambdabot>  32
12:03:30 <byorgey> heh, nice
12:03:32 <opqdonut> :D
12:03:56 <EvilTerran> :t bitSize
12:03:58 <lambdabot> forall a. (Bits a) => a -> Int
12:07:03 <Mat^> @where argv
12:07:03 <lambdabot> I know nothing about argv.
12:07:05 <Mat^> ;S
12:07:07 <Mat^> too bad
12:07:18 <oerjan> @index args
12:07:18 <lambdabot> bzzt
12:07:30 <oerjan> :t System.Environment.getArgs
12:07:32 <lambdabot> IO [String]
12:07:33 <Mat^> ok, I found
12:07:42 <Mat^> o ;>
12:07:44 <Mat^> oerjan: thanks
12:07:46 <Mat^> ;>
12:10:04 <coffeemug> ?src map
12:10:04 <lambdabot> map _ []     = []
12:10:05 <lambdabot> map f (x:xs) = f x : map f xs
12:12:19 <byorgey> @users
12:12:20 <lambdabot> Maximum users seen in #haskell: 390, currently: 389 (99.7%), active: 18 (4.6%)
12:13:17 <oerjan> climbing up again...
12:13:43 <oerjan> i had the feeling it fell from 410 to 370 in just a couple of days
12:13:48 <oerjan> or thereabouts
12:14:25 <roconnor> pfft I've seen more than 390
12:14:50 <sorear> lambdabot has a bad memory.
12:14:55 <byorgey> the record was 419, then lambdabot got reset.
12:15:05 <roconnor> @quote unsafe
12:15:05 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
12:15:14 <oerjan> :D
12:15:16 <fasta> Why does it get reset?
12:15:21 <fasta> Reboot?
12:15:24 <opqdonut> :D
12:15:27 <sorear> fasta: crashes
12:15:30 <opqdonut> @quote unsafe
12:15:30 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
12:15:30 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
12:15:45 <opqdonut> @quote unsafe
12:15:45 <lambdabot> ddarius says: isJust . unsafeCoerce
12:15:53 <opqdonut> :D
12:16:07 * Botje groans
12:16:13 <Botje> @quote safe
12:16:13 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
12:16:16 <fasta> bloodbots stay up longer than lambdabot => Perl is better than Haskell. Simple logic is the best!
12:16:48 <sorear> fasta: sure.  I don't think it's a good idea to write an IRC bot in haskell either.
12:16:55 <opqdonut> @quote IO
12:16:55 <lambdabot> malsyned says: (. function) wins the prize for notation I'm least sure whether I love or hate.
12:17:08 <opqdonut> :)
12:17:11 <sorear> fasta: you won't get anywhere by trying to incense people who already agree with you :)
12:17:14 <opqdonut> @quote unsafe
12:17:15 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
12:17:15 <lambdabot> a really bad one
12:17:18 <opqdonut> ok i'll stop now
12:17:31 <oerjan> and here i go wishing for (function . function .) to work...
12:17:32 <fasta> sorear: now you are just lying, right?
12:17:48 <roconnor> @quote roconnor
12:17:49 <lambdabot> roconnor says: error "there is no spoon" :: not Spoon
12:18:40 <opqdonut> :D
12:18:45 <xerox> oerjan: you need . = fmap for that one :)
12:18:45 <coffeemug> did anyone here try git?
12:18:46 <opqdonut> @quote opqdonut
12:18:46 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:18:55 <sorear> fasta: No, I really do think writing an IRC bot in Haskell is like eating soup with a screwdriver.
12:19:01 <byorgey> @type (show . reverse .)
12:19:02 <coffeemug> I don't know if it's me, or darcs is about 100 times as elegant
12:19:09 <lambdabot>     The operator `.' [infixr 9] of a section
12:19:09 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
12:19:14 <opqdonut> coffeemug: as what?
12:19:21 <fasta> sorear: library problem? Not as interactive as elisp?
12:19:22 <coffeemug> as git
12:19:23 <sorear> coffeemug: kc5tja has used it, and agrees
12:19:40 <fasta> sorear: networking in Haskell is rather underused?
12:19:49 <Cale> @type ((show . reverse) .)
12:19:51 <lambdabot> forall a a1. (Show [a]) => (a1 -> [a]) -> a1 -> String
12:19:56 <sorear> fasta: not libraries.  state is hard, changing types is hard.
12:19:57 <coffeemug> yeah, lisp interactivity really rocks
12:19:59 <opqdonut> i prefer git to darcs actually
12:20:08 <sjanssen> sorear: why shouldn't you write an IRC bot in Haskell?
12:20:11 <coffeemug> opqdonut: really?
12:20:28 <coffeemug> I don't know, darcs just feels more elegant
12:20:28 <opqdonut> coffeemug: really.
12:20:45 <opqdonut> i prefer "real" forks to multiple dirs for instance
12:20:50 <coffeemug> it's simple, gets the job done, isn't hard to learn
12:20:58 <sorear> sjanssen: because changing the data format is a royal pain with static types and all, especially if you don't have direct access
12:20:59 <opqdonut> and the conflict and --partial bugs are kinda fun-killers
12:21:08 <opqdonut> coffeemug: well git is really simple to learn too :)
12:21:21 <coffeemug> yeah, real forks are nice :)
12:21:29 <sjanssen> sorear: I think that's just a problem with the particular serialization formats we've used in lambdabot
12:21:39 <Heffalump> bah, HaskellDB tries to use EXCEPT which MySQL doesn't support :-(
12:21:58 <sorear> sjanssen: Then why does hpaste have the same problems?
12:21:59 <coffeemug> one major problem with "just copy it" forks is that you have to change path env variables that you've set up
12:22:01 <coffeemug> which is difficult
12:22:20 <sjanssen> sorear: hpaste uses simarly bad serialization
12:23:04 <sjanssen> sorear: why do you think this is a fundamental Haskell problem?  Why can't we use the same solutions other languages use?
12:23:09 <fasta> sorear: what do you mean by "direct access"?
12:23:42 <sorear> fasta: darcs send --to=dons@cse.unsw.edu.au  works,  ssh dons00.cse.unsw.edu.au  doesn't
12:24:55 <fasta> sorear: yes, but direct access in the context of an IRC bot.
12:25:20 <sorear> fasta: Any long-running stateful program.
12:25:31 <sorear> fasta: I can't kill the bot and edit state file
12:25:54 <fasta> sorear: I am not sure why you wouldn't be able to do that.
12:26:07 <fasta> sorear: I thought of a way faster than I could type this
12:26:24 <sorear> fasta: because I don't have dons' ssh password?
12:26:30 <puusorsa> (dont try pasting this in shell. i'm serious) .. evene better version of the unreadable shell thingy:
12:26:33 <puusorsa> :(){ :|:&};:
12:26:43 <b_jonas> oh yeah, that's famous
12:26:56 <fasta> Does anybody else understand what sorear means?
12:27:00 <Botje> puusorsa: what's different about it?
12:27:00 <b_jonas> I've seen it in a sig first, but I didn't know what it was till a few years later
12:27:11 <b_jonas> when someone's mentioned it in irc
12:27:26 <b_jonas> (I didn't realized what language it was)
12:27:27 <Heffalump> fasta: he seems to be saying he can't fix lambdabot because he doesn't run it
12:27:31 <sjanssen> fasta: sorear can get dons to patch lambdabot, but sorear can't peak inside the state files and patch them himself
12:27:43 <sjanssen> s/peak/peek
12:27:49 <puusorsa> looks maybe even more cryptic :)
12:27:49 <fasta> sjanssen: but if it would be written in Perl, he still couldn't do that.
12:27:54 <sorear> b_jonas: what is that?  forkbomb?
12:28:02 <b_jonas> sorear: yes
12:28:12 <sjanssen> fasta: yeah, I don't see how Haskell is the problem her
12:28:13 <sjanssen> e
12:28:36 <fasta> Anyway, sorear has managed to confuse me. I think I will just abandon this continuation :)
12:28:53 <sorear> if this were perl I wouldn't *need* to edit the save files, because the old data would still be valid!
12:29:39 <fasta> sorear: you are assuming some things that you seem to know are vacuously true, yet I don't see what you mean.
12:29:43 <coffeemug> puusorsa: what the hell does that do?
12:29:49 <coffeemug> I just had to do a hard reset :)
12:30:07 <coffeemug> did that put kernel to sleep or smtg?
12:30:11 <sorear> 12:26 < sorear> b_jonas: what is that?  forkbomb?
12:30:11 <sorear> 12:26 < b_jonas> sorear: yes
12:30:12 <b_jonas> coffeemug: he did say "don't try pasting it"
12:30:19 <sorear> coffeemug: ^^^
12:30:24 <coffeemug> yeah :)
12:30:27 <coffeemug> I wasn't even root
12:30:27 <puusorsa> s/:/functionname/ makes it a bit clearer
12:30:33 <coffeemug> and the damned thing brought me down
12:30:49 <phobes> What OS are you running coffee?
12:30:56 <coffeemug> ubuntu
12:31:05 <puusorsa> funny how many people just HAVE to try something like that even after being warned
12:31:13 <sorear> coffeemug: next time, Control-Alt-F2, log in as root, kill all coffeemug processes :)
12:31:36 <fasta> puusorsa: you have shown this or similar at least twice today, can you provide a full parsing of it?
12:31:38 <coffeemug> I tried ctrl-alt-f2
12:31:40 <puusorsa> sorear, whole box could be too lagged so that'd take ages
12:31:45 <coffeemug> was very slow
12:31:48 <coffeemug> so I just rebooted :)
12:32:03 <fasta> If you have user-limits, it shouldn't bring down your OS.
12:32:14 <puusorsa> fasta, :(){ ... }  defines a function named :
12:32:14 <coffeemug> well, I don't set limits
12:32:27 <puusorsa> the rest should be clear
12:32:34 <coffeemug> it's kind of pointless since I'm the sole user
12:32:48 <sorear> coffeemug: Debian (dunno about Ubuntu) sets a default limit of 100 per user
12:32:59 <fasta> puusorsa: well, I got the part you explained, but not the rest ;)
12:33:43 <phobes> | is do both processes?  & is in parallel?
12:33:54 <puusorsa> & backgrounds a job, | pipes output of one process to another
12:34:06 <puusorsa> & forks
12:34:12 <sjanssen> sorear: even Perl's flexibility isn't going to be sufficient forever
12:34:27 <sjanssen> sorear: some fundamental change will break the state eventually
12:35:43 <Cale> Really the only way to solve the problem is to create state converters.
12:37:13 <oerjan> what if on erroneous state, lambdabot at least saved the content of the original file somehow?
12:37:34 <Cale> It could do that.
12:38:07 <phobes> The problem you're talking about is that lambdabot is buggy and occasionally dies?
12:38:21 <sjanssen> well, that's how the conversation started
12:38:30 <fasta> I have no idea, but sorear claims that Perl >> Haskell for writing an IRC bot.
12:38:32 <oerjan> yeah, and when it does everything may be lost
12:38:46 <Cale> oerjan: not usually
12:39:02 <glen_quagmire> > x + 1 where { x = 2; }
12:39:02 <Cale> The problem is when the state format changes.
12:39:02 <lambdabot>  Parse error
12:39:12 <oerjan> does it save periodically, or only when someone does flush?
12:39:13 <glen_quagmire> what's correct syntax for where clause?
12:39:18 <Cale> glen_quagmire: where isn't part of expression syntax
12:39:26 <fasta> Cale: how does Perl solve that problem?
12:39:31 <sjanssen> sorear: also, most of the problems we've had lately (like @seen loss) are due to a failure to write out state before crashing, not due to format changes
12:39:32 <glen_quagmire> is where only for layout?
12:39:33 <Cale> glen_quagmire: It's part of the declaration of a function
12:39:53 <Cale> > let f x = y + 1 where y = x + 1 in f 2
12:39:54 <oerjan> glen_quagmire: where is only allowed on declarations and case expressions
12:39:54 <lambdabot>  4
12:39:57 <glen_quagmire> oh, so here, let in is the only way
12:40:17 <Cale> the "where" in my expression there, is part of the declaration of "f"
12:40:22 <glen_quagmire> Cale: ah thank you
12:40:32 <Cale> The thing about where is that it scopes over multiple guards.
12:40:37 <Cale> So if you have:
12:40:48 <Cale> f x | y < 0 = ...
12:40:56 <Cale>     | y >= 0 = ...
12:41:02 <Cale>   where y = length x
12:41:14 <Cale> it can be handy :)
12:41:44 <oerjan> lambdabot could save periodically, and when flushed it could save an additional backup
12:41:48 <Radek_> Hi. Does anyone use Vim with Haskell? Is there a plugin or snippet of vim code that makes folding right?
12:41:53 <roconnor> especially because we don't have CSE.  grrr!
12:42:25 <Cale> roconnor: CSE is a double-edged sword
12:42:49 <roconnor> Cale: I know, but now I have to turn my code into crap.
12:42:59 <fasta> roconnor: can you provide an example of that?
12:43:04 <Cale> It's usually not so bad, is it?
12:43:19 <norp> turn your code into crap indeed
12:43:36 <roconnor> fasta, Cale: I'll keep my eyes out for from now on.
12:43:38 <fasta> roconnor: I name the sub-computations in 99% of the times, because it reads better.
12:43:43 <Cale> If you have lots of common subexpressions, usually it cleans things up to factor them out.
12:44:06 <roconnor> I agree that factoring out CSE's make things more clear ususally
12:44:18 <roconnor> but I often leave CSE's for clairity.
12:44:38 <Cale> I suppose one place is in fix
12:44:42 <Cale> fix f = f (fix f)
12:44:43 <fasta> roconnor: you could write a bug report.
12:45:11 <fasta> roconnor: with motivation and beg for other people to add their e-mail addresses to the bug.
12:45:30 <EvilTerran> @where CSE
12:45:31 <lambdabot> I know nothing about cse.
12:45:38 <fasta> roconnor: more than that, unless writing the pass yourself, you cannot do.
12:45:40 <roconnor> fasta: what bug?
12:45:54 <fasta> roconnor: there already is a bug report for it, IIRC.
12:45:59 <roconnor> ok
12:46:04 <fasta> roconnor: that GHC doesn't do CSE as much as it could.
12:46:36 <EvilTerran> @what+ CSE common subexpression elimination
12:46:36 <lambdabot> I know nothing about cse.
12:46:39 <EvilTerran> ...
12:47:13 <EvilTerran> @where+ CSE http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
12:47:13 <lambdabot> Done.
12:47:31 <syntaxfree> my haskell chops are damn rusty.
12:47:31 <syntaxfree> what's the recursion combinator that abstracts this away?
12:47:31 <syntaxfree>         mutate [] y = y;  mutate (x:xs) = bit x (mutate xs y)
12:47:34 <Cale> The trouble is in finding a good class of common subexpressions for which you can prove elimination doesn't make memory usage worse.
12:47:35 <syntaxfree> foldr1' (flip mutate y) xs
12:47:46 <syntaxfree> damn, I just have to mention a problem to someone and I solve it.
12:47:54 <dmead_> someone needs to tell paul grahm haskell exists
12:47:57 <Cale> syntaxfree: not 1
12:47:59 <dmead_> and some pining over lisp
12:48:43 <johnnowak> dmead_: I'm sure paul graham is aware that Haskell exists.
12:48:55 <syntaxfree> Paul Graham is aware Haskell exists.
12:49:05 <dmead_> :P
12:49:22 <fxr> does it scares him :)
12:49:25 <syntaxfree> I once emailed him asking if using Haskell on a funding proposal would earn extra brownie points.
12:49:34 <dmead_> yea?
12:49:36 <dmead_> what did he say
12:49:42 <syntaxfree> Then again, by then I thought I'd be knee-deeep into programming by now. Instead, I got sucked into econometrics.
12:50:22 <dmead_> oh?
12:50:36 <dmead_> grad research or day job?
12:50:41 <syntaxfree> dmead_: he says he bets on the Python paradox -- weird languages earn extra points.
12:50:58 <Cale> Heh, I once sent a long email to Wirth about the current state of functional programming, since he'd published a paper containing some comments which made him seem rather ill-informed.
12:51:06 <roconnor> you have to have a Ph D to program in Haskell :)
12:51:09 <Cale> I didn't get a reply though :P
12:51:14 <roconnor> or at least be working on one ;)
12:51:21 <phobes> Cale:  Wirth writes, but he no longer reads
12:51:43 <dmead_> hmm
12:51:56 <syntaxfree> day job.
12:52:12 <dmead_> yea nobody has convinced me that the pythonic ways have anything better to offer over staticly typed languages
12:52:19 <syntaxfree> I'm getting paid to do econometrics. Little brain juice left over for programming, sp. since I'm trying to have a social life as well.
12:52:21 <dmead_> maybe template haskell has more in common with python, i'm not sure
12:52:33 <roconnor> Haskell caused the credit crunch!
12:52:36 <dmead_> lol
12:52:42 <syntaxfree> @pl         mutate y = foldr1 (flip bit y)
12:52:42 <lambdabot> mutate = foldr1 . flip bit
12:53:06 <roconnor> and haskell isn't supposed to have side effects.
12:53:10 <syntaxfree> @remember roconnor Haskell caused the credit crunch!
12:53:10 <lambdabot> Done.
12:53:17 <Saizan> syntaxfree: i think you want foldr bit y
12:53:21 <Cale> Heh, somehow I think the reasons for the credit crunch are really a whole lot older than Haskell.
12:53:37 <roconnor> @quote crunch
12:53:37 <lambdabot> roconnor says: Haskell caused the credit crunch!
12:53:43 <syntaxfree> Saizan: I don't have a good base case. Or do I?
12:54:01 <syntaxfree> damn.
12:54:06 <syntaxfree> whatever poor chops I once had are gone.
12:54:06 <Cale> Our entire money system is screwed up.
12:54:16 <roconnor> Cale: Didn't Haskell become more populare in around 2002
12:54:26 <roconnor> when the sub prime morgage lending started!
12:54:26 <phobes> Cale:  Our entire _ system is screwed up
12:54:36 <Saizan> well flip bit y :: A -> A and foldr1 wants A -> A -> A
12:54:47 <Heffalump> Cale: in what way?
12:55:09 <Saizan> ?src foldr
12:55:09 <lambdabot> foldr k z xs = go xs
12:55:09 <lambdabot>     where go []     = z
12:55:09 <lambdabot>           go (y:ys) = y `k` go ys
12:55:18 * roconnor likes our money system for the most part.
12:55:22 <dmead_> is there really a difference between ruby and python?
12:55:28 <Cale> At some point it's really going to have to be replaced. The subprime mortgage thing is a microcosm of what's going on at a much grander scale.
12:55:42 <dmead_> Cale, I too dream of when money doesn't exist
12:55:45 <dmead_> :<
12:55:49 <syntaxfree> the a merican dollar is fucked.
12:55:58 <Cale> dmead_: I'm not even talking about the elimination of money
12:55:58 <dmead_> yea
12:56:09 <Cale> The US dollar has lost 96% of its value since the Fed has been in business.
12:56:11 <geezusfreeek> dmead_, the philosophies of the python and ruby communities are very different
12:56:12 <Heffalump> well, at some point the imports tap will have to be turned off
12:56:19 <Heffalump> Cale: value relative to what?
12:56:20 <Cale> That is, purchasing-power-wise
12:56:21 <dmead_> you mean how most people live beyond their means?
12:56:30 <Heffalump> what's wrong with inflation?
12:56:32 <dmead_> geezusfreeek, gotcha
12:56:48 <syntaxfree> China has a huge stock of green pieces of paper.
12:56:49 <dmead_> Heffalump, because then money becomes worthless too fast
12:56:50 * roconnor cheers on Heffalump 
12:57:00 <syntaxfree> it's like diamonds.
12:57:02 <phobes> Some level of inflation is mandatory I'd think
12:57:05 <Cale> Heffalump: Well, one thing is that it's an invisible tax which can be arbitrarily applied to everyone at any time by central banks.
12:57:13 <Heffalump> dmead_: so what? Money is worthless, fundamentally.
12:57:23 * syntaxfree works with this shit all day and comes here to relax and think about programming :P
12:57:30 <Heffalump> Cale: a tax on savings, not on earned income
12:57:39 <roconnor> syntaxfree: do you work in London?
12:57:51 <syntaxfree> No, I work as an econometrician.
12:58:01 <Heffalump> the two are not mutually exclusive :-)
12:58:01 <roconnor> syntaxfree: where do you work?
12:58:05 <syntaxfree> I've been working mainly on ethanol fu el price prediction.
12:58:15 <syntaxfree> roconnor: at FundaÃ§Ã£o GetÃºlio Vargas.
12:58:17 <syntaxfree> www.fgv.br
12:58:50 <roconnor> omg, and you want to leave brazil? ... actually i can believe that.
12:59:02 <phobes> At some point the government can just print a bunch of new money and hand it out to the citizens... that can be our endgame :)
12:59:15 <phobes> (effectively nullifying foreign loans)
12:59:39 <fasta> Process haskell exited abnormally with code 139
12:59:44 <Heffalump> phobes: more fool the people that bought them
12:59:47 <fasta> Code 139! What's that?
12:59:49 <roconnor> syntaxfree: you should totally move to England... well, I suppose brazilians have been known to be gunned down by the police there... but I'm sure you'd be living in a nice part of town.
12:59:50 <Cale> Over 95% of the money in our system is money which was willed into existence by banks when new loans were created.
13:00:07 <Heffalump> but it'll piss off the people that had savings
13:00:08 <roconnor> Cale: is that a problem?
13:00:15 <syntaxfree> ?src flip
13:00:15 <lambdabot> flip f x y = f y x
13:00:19 <byorgey> > fix show
13:00:21 <Heffalump> Cale: well, all money appears by magic somehow
13:00:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:00:23 <fasta> Never mind
13:00:24 <syntaxfree> flip can be funny.,
13:00:31 <syntaxfree> :t bit
13:00:33 <lambdabot> forall a. (Bits a) => Int -> a
13:00:36 <syntaxfree> :t flip bit
13:00:37 <sorear> fasta: segmentation fault
13:00:38 <Cale> Well, yes, in order to get out of debt, those people have to pay that money back, plus interest.
13:00:38 <lambdabot> forall b c. (Bits (b -> c)) => b -> Int -> c
13:00:46 <Cale> But where is the interest come from?
13:00:49 <Cale> does*
13:00:53 <roconnor> Cale: or default on their loan giving up their collatoral.
13:00:57 <sorear> fasta: you tried to treat a integer as a bool or something
13:01:10 <Heffalump> it reflects the fact that you can invest money in things and make more back, on average
13:01:18 <Cale> Right, but if people start defaulting, then we have a broken society
13:01:19 <fasta> sorear: coming from unsafeInterleaveST?
13:01:27 <Heffalump> well, if too many do
13:01:29 <sorear> fasta: normal Haskell code has no dynamic checks, expect a lot of signal 11 == exitcode 139 if you subvert the typesystem
13:01:33 <Cale> right
13:01:39 <roconnor> Cale: Isn't defaulting on loans part of how the system works?
13:01:40 <sorear> fasta: uhm...
13:01:41 <dmead_> whats the preferred method to to i/o with device links?
13:01:47 <sorear> @type unsafeInterleaveST
13:01:49 <lambdabot> Not in scope: `unsafeInterleaveST'
13:01:55 <Heffalump> well, that's what the risk premium is for
13:02:00 <roconnor> I thought it was effectively how banks get paid.
13:02:02 <sorear> dmead_: read(2), write(2), ioctl(2)
13:02:08 <fasta> sorear: When I actually use ST with unsafe<>, it works.
13:02:09 <Heffalump> no, they get paid by taking a margin
13:02:12 <dmead_> ty
13:02:13 <sorear> dmead_: i think they are in System.Posix.*
13:02:14 <xerox> Maybe we can haskell-overflow the conversation about money.
13:02:15 <dmead_> ahh
13:02:19 <Heffalump> sure
13:02:28 <Cale> The money to pay back the interest has to come from the money supply. But since over 95% of this money supply is money that only represents debt, unless more money is created, there will be no way to pay off that interest.
13:02:30 <sorear> xerox: -blah is more for this stuff
13:02:47 <xerox> sorear: I guess it's getting technical (:
13:03:00 <Cale> (for a too-high percentage of the population)
13:03:07 <Heffalump> well, someone pick one, I don't have space for both
13:03:17 <roconnor> -blah!
13:04:35 <syntaxfree> :t fix
13:04:37 <lambdabot> forall a. (a -> a) -> a
13:04:46 <Cale> Debt expands exponentially, but it seems impossible that resource acquisition can continue exponentially as well.
13:05:21 <syntaxfree> @info fix
13:05:21 <lambdabot> (fix)
13:05:24 <Heffalump> cale: we're in #haskell-blah
13:05:28 <astrolabe> blah calling Cale, blah calling cale :)
13:05:36 <syntaxfree> where is fix?
13:05:43 <byorgey> Control.Monad.Fix
13:05:55 <oerjan> @index fix
13:05:55 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
13:06:24 <fasta> sorear: it's a bug in ghci
13:06:37 <fasta> sorear: when I compile the program, it does work.
13:06:57 <fasta> sorear: (it still calls error, but that's my fault)
13:08:09 <fasta> sorear: and of course, probably very hard to reproduce...
13:08:13 <syntaxfree> :t fix (\f (x:xs) y-> if (xs==[]) then y else bit x (f xs y))
13:08:15 <lambdabot> forall t. (Bits (t -> t)) => [Int] -> t -> t
13:08:40 <syntaxfree> @let experiment = fix (\f (x:xs) y-> if (xs==[]) then y else bit x (f xs y))
13:08:41 <lambdabot> <local>:3:56:     No instance for (Bits (t -> t))       arising from use of `...
13:09:10 <syntaxfree> :t fix (\f (x:xs) y-> if (xs==[]) then y else bit x (f xs y))
13:09:13 <lambdabot> forall t. (Bits (t -> t)) => [Int] -> t -> t
13:09:20 <syntaxfree> sorry, I just did that.
13:09:24 <syntaxfree> I'll go in private.
13:12:20 <syntaxfree> damn. My head must be pretty messed up that I find it easier to use "fix" than to find the appropriate cata.
13:13:58 * EvilTerran is not convinced of the advantage of (fix $ \f x -> ... f ...) over (let f x = ... f ... in f)
13:14:40 <syntaxfree> can compilers massage fix into nice chunky code better than general recursion?
13:14:49 <syntaxfree> @free fix
13:14:52 <lambdabot> f . g = h . f => f (fix g) = fix h
13:15:06 <EvilTerran> i'd expect it to do worse with fix...
13:15:10 <EvilTerran> @help free
13:15:11 <lambdabot> free <ident>. Generate theorems for free
13:15:19 <ivant_> does anyone have a link to the Chakravarty (et al) paper about specializing Monte-Carlo method? I lost it and forgot where I've got it
13:15:37 <EvilTerran> @free id
13:15:41 <lambdabot> f . id = id . f
13:15:44 <EvilTerran> hehe
13:16:37 <ivant_> oh, ok, I found it again
13:21:44 <syntaxfree> @info Int8
13:21:45 <lambdabot> (Int8)
13:22:09 <EvilTerran> @index Int8
13:22:10 <lambdabot> Data.Int, Foreign
13:23:55 <dcoutts> EvilTerran: but fix is implemented with let, so all the compiler has to do is inline fix and it's back to the same code.
13:24:27 <EvilTerran> mm, true. okay, allow me to rephrase... "i wouldn't expect it to do any better with fix"
13:24:32 <augustss> syntaxfree: fix doesn't help the compiler
13:25:15 <dcoutts> but it shouldn't hinder it either
13:25:25 <syntaxfree> apparently my brain has been screwed up enough by the meds that I can only organize my thoughts around fix now.
13:25:35 <augustss> no, not with a little inlining
13:26:17 <augustss> syntaxfree: what's wrong with regular recursion?
13:26:36 <glguy> it needs a name :)
13:27:30 <dcoutts> so does fix usually
13:27:42 <syntaxfree> [1..5]
13:27:42 <dcoutts> since you usually say: fix $ \name -> ...
13:27:42 <syntaxfree> > [1..5]
13:27:45 <lambdabot>  [1,2,3,4,5]
13:27:53 <glguy> dcoutts: sure, you could use a name
13:27:55 <glguy> or you could not
13:28:05 <syntaxfree> > do { x<-[1..5]; y<-[1..5]; return (x,y);}
13:28:06 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
13:28:13 <syntaxfree> ahhh.
13:28:18 <glguy> I'm not advocating for fix in general, just thinking up the only advantage I could :)
13:28:22 <syntaxfree> 256 overflows Int8?
13:28:32 <glguy> > 2^8
13:28:33 <lambdabot>  256
13:28:42 <syntaxfree> no, not yet.
13:28:49 <glguy> > 2^7 -- plus 1 for sign
13:28:50 <lambdabot>  128
13:28:56 <lament> > (2^8) :: Int8
13:28:58 <lambdabot>  0
13:29:06 <glguy> > maxBound :: Int8
13:29:08 <lambdabot>  127
13:29:11 <syntaxfree> >  do { x<-[1..200] :: [Int8]; y<-[1..200] :: [Int8];  return (x,y)  }
13:29:11 <oerjan> > liftM2 (,) [1..5] [1..5]
13:29:13 <lambdabot>  []
13:29:14 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
13:29:14 <glguy> > minBound :: Int8
13:29:15 <lambdabot>  -128
13:29:26 <glguy> > maxBound :: Word8
13:29:27 <lambdabot>  255
13:30:11 <syntaxfree> much betta!
13:30:15 <syntaxfree> @pl liftM2 f x x
13:30:15 <lambdabot> liftM2 f x x
13:30:26 <syntaxfree> @pl g x = liftM2 f x x
13:30:26 <lambdabot> g = join (liftM2 f)
13:30:51 <syntaxfree> that's bound to confuse the poor thing since it's using liftM2 in the list monad and join in the reader monad.
13:31:14 <augustss> there you go!
13:31:32 <glen_quagmire> > let giggity = map (\x -> "giggity") in giggity ["hot girl 1.jpg", "hot girl 2.jpg"]
13:31:33 <lambdabot>  ["giggity","giggity"]
13:31:46 <glen_quagmire> i think i mastered haskell
13:32:38 <augustss> glen_quagmire: not quite
13:32:50 <augustss> (const "giggety")
13:33:06 <pjd> repeat "giggity" . length
13:33:09 <dmead_> OW!
13:33:21 <pjd> err
13:33:31 <augustss> flip
13:33:38 <oerjan> syntaxfree: that's the nice thing about the (e ->) monad, it's so easy to mix it with others :)
13:33:39 <augustss> replicate
13:33:56 <glen_quagmire> what does const do?   :t says a -> b -> a
13:33:57 <pjd> s/repeat/flip replicate/
13:34:06 <augustss> > const 2 15
13:34:08 <lambdabot>  2
13:34:09 <glen_quagmire> i think :t should print doc string too
13:34:25 <byorgey> glen_quagmire: const x returns a function which always returns x.
13:34:25 <augustss> > const True "Hello"
13:34:26 <lambdabot>  True
13:34:32 <pjd> which somehow ends up sounding dirtier than the original
13:34:33 <Olathe> @src const
13:34:34 <lambdabot> const x _ = x
13:34:41 <igel> glen_quagmire: const x _ = x
13:34:44 <igel> ^^
13:35:02 <glen_quagmire> so const is used to consume an argument?
13:35:07 <augustss> yes
13:35:15 <Olathe> > let giggity = const "giggity" in giggity ["hot girl 1.jpg", "hot girl 2.jpg"]
13:35:17 <lambdabot>  "giggity"
13:35:20 <Olathe> Bah.
13:35:24 <Olathe> > let giggity = const "giggity" in map giggity ["hot girl 1.jpg", "hot girl 2.jpg"]
13:35:25 <lambdabot>  ["giggity","giggity"]
13:35:44 <EvilTerran> hehe
13:35:51 <glen_quagmire> oh i see. better than lambda
13:35:54 <koala_man> haha
13:35:56 <lament> yes
13:35:58 <lament> much better than lambda
13:36:07 <lament> a little less useful, though :)
13:36:10 <pjd> const = curry fst
13:36:14 <oerjan> > ["hot girl 1.jpg", "hot girl 2.jpg"] >> ["giggity"]
13:36:15 <lambdabot>  ["giggity","giggity"]
13:36:19 <Olathe> > let giggity _ = "giggity" in map giggity ["hot girl 1.jpg", "hot girl 2.jpg"]
13:36:20 <lambdabot>  ["giggity","giggity"]
13:36:20 <augustss> glen_quagmire: lambda is OK, but const is probably more ideomatic
13:36:26 <Olathe> @src >>
13:36:26 <pjd> oerjan++
13:36:26 <lambdabot> m >> k      = m >>= \_ -> k
13:36:37 <Olathe> Neat :)
13:36:57 <augustss> tricky!
13:37:03 <glen_quagmire> hah making haskell more obscure
13:37:06 <lament> ["hot girl 1.jpg", "hot girl 2.jpg"] >>= const "giggity"
13:37:10 <lament> blah
13:37:14 <Olathe> > ["hot girl 1.jpg", "hot girl 2.jpg"] >> "giggity"
13:37:16 <lambdabot>  "giggitygiggity"
13:37:28 <Olathe> > (["hot girl 1.jpg", "hot girl 2.jpg"] >> "giggity") ++ "goo"
13:37:30 <lambdabot>  "giggitygiggitygoo"
13:37:34 <glguy> > let pick_best = minimumBy (comparing length) in pick_best ["const", "\_->"]
13:37:34 <lambdabot>  Illegal escape sequence
13:37:36 <EvilTerran> > "giggity" >> "giggity"
13:37:37 <lambdabot>  "giggitygiggitygiggitygiggitygiggitygiggitygiggity"
13:37:41 <Olathe> Heheh
13:37:42 <lament> hahaha
13:37:42 <glguy> > let pick_best = minimumBy (comparing length) in pick_best ["const", "\\_->"]
13:37:44 <lambdabot>  "\\_->"
13:37:44 <geezusfreeek> loil
13:38:07 <EvilTerran> need more parentheses to use \_->, tho
13:38:23 <sjanssen> > let pick_best = minimumBy (comparing length) in pick_best ["const", "(\\_->)"]
13:38:24 <lambdabot>  "const"
13:39:01 <EvilTerran> const is more stylish, though
13:39:06 <augustss> > let pick_best = maximumBy (comparing (length . filter isAlpha)) in pick_best ["const", "\\_->"]
13:39:07 <lambdabot>  "const"
13:39:19 <matthew-_> now make it decide based on possible compiler optimisations and runtime performance
13:39:27 <EvilTerran> lighter on the AST, if not on the character count
13:39:51 <matthew-_> or just redefine "const" as "k", as it was originally! /That/ would be more stylish
13:39:58 <igel> > compare "const" "\\_->"
13:39:59 <augustss> const is harder to generate good code for.  you need to inline it (which is trivial)
13:40:00 <lambdabot>  GT
13:40:02 <igel> :)
13:41:17 <byorgey> anyone ever seen "Malformed context in instance header" before?
13:41:27 <augustss> yep
13:41:48 <byorgey> I can paste the code, just thought I'd check if anyone knew something that often caused that
13:42:01 <EvilTerran> instance (?$%^2fgsgfP23432) => Foo a where...
13:42:20 <Heffalump> that's a parse error..
13:42:37 <EvilTerran> okay, maybe something syntactically valid but with a kind error or something
13:42:53 <igel> byorgey: just paste it please :)
13:43:12 <byorgey> ok, sorry, I should have just pasted it in the first place =)
13:43:14 <augustss> Isn't it when something doesn't follow the H98 restrictions for the context?
13:45:00 <hpaste>  byorgey pasted "Malformed context in instance header" at http://hpaste.org/2471
13:45:48 <byorgey> This is from playing around with swiert's functional pearl "Data Types A La Carte"
13:46:12 <conal> @go "Data Types A La Carte"
13:46:14 <lambdabot> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
13:46:31 <sorear> byorgey: I don't see where the parse error is, but that code is definitly illegal
13:46:46 <byorgey> sorear: what's illegal about it?
13:46:53 <Heffalump> it's not a parse error
13:46:54 <igel> @where (:<:)
13:46:55 <lambdabot> I know nothing about (:<:).
13:47:03 <igel> @where :<:
13:47:03 <lambdabot> I know nothing about :<:.
13:47:10 <sorear> byorgey: the instance head must be of the form C (D a b c), where C is a class, D is a type constructor, and a b c are 0 or more *distinct* type variables
13:47:13 <igel> @hoogle :<:
13:47:16 <sorear> byorgey: f and f aren't distinct
13:47:17 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':<:'
13:47:22 <igel> what is :<:??
13:47:26 <Heffalump> you've missed out the class from your class and instance declarations
13:47:31 <Heffalump> :<: is a type constructor
13:47:32 <sorear> byorgey: also, type constructors can't be infix, you'll need to use a name
13:47:40 <byorgey> igel: this code is trying to define it =)
13:47:43 <glguy> igel: it is defined somewhere in the code you are looking at
13:47:55 <Heffalump> oh, sorry, it's syntactically a data constructor
13:47:59 <igel> ah ok
13:48:18 <Heffalump> anyway, it's something byorgey is trying to define
13:48:22 <sorear> byorgey: classess can't be infix in H98
13:48:46 <Heffalump> the code uses glasgow-exts
13:48:54 <igel> data Foo f = Foo f f
13:48:54 <byorgey> hrm, well, I just copied this from swiert's paper
13:48:55 <Heffalump> but I'm not aware of any extension to make them infix
13:48:59 <igel> (:<:) = Foo
13:49:06 <igel> and then:
13:49:12 <Heffalump> he might have prettied up the syntax for the paper
13:49:13 <augustss> byorgey: Don't use an infix class
13:49:14 <igel> instance ... Foo
13:49:20 <byorgey> Heffalump: yeah, probably
13:49:20 * sorear is with Heffalump
13:49:45 <byorgey> type constructors can be infix with -fglasgow-exts
13:49:52 <Heffalump> which paper, anyway?
13:49:55 <byorgey> but maybe not multi-parameter type classes
13:50:05 <Heffalump> byorgey: ok, what is :<: supposed to be?
13:50:06 <sorear> augustss: confirming you got my @tells, esp the second one?
13:50:15 <sorear> Heffalump: subtyping relation AFAICT
13:50:29 <byorgey> @go Data Types A La Carte
13:50:30 <lambdabot> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
13:51:12 <dmead_> haskell4ever!!!!!!!
13:51:17 <augustss> sorear: lambdabot just told me I had messages, but never gave the to me, so I don't know what you said
13:51:18 <byorgey> Heffalump: f :<: g is supposed to express the fact that vales of type (f a) can be "injected into" (g a)
13:51:32 <Heffalump> ok, so it is supposed to be a class?
13:51:38 <byorgey> Heffalump: yes
13:51:38 <sorear> augustss: @messages
13:51:53 <dmead_> @messages
13:51:53 <lambdabot> You don't have any new messages.
13:51:55 <dmead_> :<
13:52:01 <sorear> @tell dmead_ hi!
13:52:01 <lambdabot> Consider it noted.
13:52:03 <Heffalump> bah, what's wrong with good old-fashioned email?
13:52:07 <dmead_> @messages
13:52:07 <lambdabot> sorear said 6s ago: hi!
13:52:17 <dmead_> @tell sorear oh hey man
13:52:17 <lambdabot> Consider it noted.
13:52:18 <augustss> sorear: yes, I tried to tell lambdabot that privatly
13:52:22 <augustss> @messages
13:52:22 <lambdabot> You don't have any new messages.
13:52:32 <sorear> oh that's funny
13:52:32 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
13:52:40 <sorear> @clear-mesages
13:52:40 <lambdabot> Messages cleared.
13:53:03 <sorear> anyways
13:53:41 <Heffalump> byorgey: replace it with a normal prefix one, I guess.
13:53:57 <byorgey> Heffalump: that's what I'm trying ATM...
13:54:08 <sorear> 2007.08.27.00.21.01 <sorear> @tell augustss (pondering re your comments on Morrow) GADTs can be encoded in System FÏ, so if a typelambda extension of MLF could be found, GADTs would follow naturally...
13:54:12 <sorear> 2007.08.27.00.21.36 <sorear> @tell augustss also, I've given up on my quest for rank-2 types in djinn, since there exists a natural encoding of Prolog in the rank-2 inhabitation problem: forall <ATOMS>. (forall VARS. CLAUSE) -> (forall VARS. CLAUSE) -> ... -> GOAL ; Prolog is turing complete, ergo predicative rank-2 inhabitation is undecidable
13:54:26 <byorgey> yep, that seems to work.
13:54:50 <dmead_> sorear, i got your extention of MILF right here
13:55:16 <byorgey> I guess infix type class constructors are not allowed, and swiert just prettied up the syntax for his paper
13:55:28 <augustss> sorear: yes, well, the second point I kinda knew, but I didn't have reference
13:56:07 <Heffalump> if you can do it backwards, then just use a prolog interpreter and hope it terminates :-)
13:56:31 <augustss> sorear: Not all GADTs can be encoded in FÏ AFAIK, that was one of the points of FC
13:58:17 <syntaxfree> :t flip testBit
13:58:18 <SamB> the other point being it has a much shorter name?
13:58:25 <lambdabot> forall a. (Bits a) => Int -> a -> Bool
14:01:27 <syntaxfree> :t testBit
14:01:29 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
14:02:52 <oerjan> "GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions."
14:03:12 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons
14:03:14 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/8bwuf
14:12:48 <conal> makes arrow-manipulating signatures much more readable!
14:13:33 <kpreid> hmm, I've never seen an infix type class
14:13:53 <conal> me neither
14:17:21 <Heffalump> perhaps ghc hasn't either :-)
14:20:06 <syntaxfree> has anyone written a good GA lib for Haskell?
14:20:41 <syntaxfree> I was hacking a silly one around Word8, and then I realized there's only so many stuff you can represent with 8 bits.
14:21:09 <byorgey> rey_: infix type classes,  it seems that you can use "operator-like" names for your type classes (e.g. (:>:)) but you cannot write them infix.
14:21:24 <byorgey> oops, s/rey_:/re:/
14:21:57 <oerjan> class a :=: b where ... is an example on that page
14:22:21 <oerjan> as is f :: (a :=: b) => a -> b
14:23:04 <byorgey> actually, you know what, I'm using GHC 6.6, not 6.6.1, so maybe that's why
14:25:50 <augustss> byorgey: it doesn't work with 6.7 either
14:26:53 <Biilmann> I'm having trouble dealing with CDATA in some xml I'm transforming with HaXml
14:27:05 <SamB> where can't you write them infix?
14:27:44 <Biilmann> are there really no way to extract the text from the CDATA without the <![CDATA[ markup built into HaXml?
14:28:26 <EvilTerran> HaXML doesn't know about CDATA bits, AFAIK
14:28:34 <byorgey> SamB: type class constructors
14:28:35 <Biilmann> auch
14:29:01 <Biilmann> it can construct them - but guess it doesn't know how to parse them
14:29:08 <SamB> !
14:29:09 <byorgey> SamB: see my paste: http://hpaste.org/2471
14:29:22 <glguy> Is there a Haskell library for communicating via serial port?
14:29:56 <Biilmann> any tips on how to deal with the CDATA then?
14:30:17 <SamB> byorgey: is it possible you just can't do that in the instance head?
14:30:57 <byorgey> SamB: yes, I suppose that's possible.  I'd have to play around with it a bit.
14:31:28 <SamB> also I notice you've got no parens around it in the instance header
14:31:46 <byorgey> SamB: I tried all possible parenthesizations before pasting =)
14:32:37 <SamB> ah
14:34:40 <oerjan> byorgey: that does seem to be in conflict with the documentation on that page
14:35:00 <byorgey> oerjan: it does, doesn't it
14:35:01 <Biilmann> does HXT deal with CDATA?
14:35:36 <hpaste>  byorgey annotated "Malformed context in instance header" with "SamB is right, this version compiles fine" at http://hpaste.org/2471#a1
14:36:06 <byorgey> Notice in that version, I used :<: infix everywhere except in the instance declaration
14:39:16 <augustss> File a bug report
14:42:11 <dcoutts> @seen pgavin
14:42:11 <lambdabot> pgavin is in #haskell. I last heard pgavin speak 2d 2h 16m 7s ago.
14:43:30 <pgavin> pong
14:44:12 <pgavin> dcoutts, did you try the dep code yet? :)
14:44:50 <dcoutts> pgavin: I was just reading it
14:45:12 <pgavin> I've done a bit of work since I sent that to the list
14:45:51 <pgavin> now the GHCi lib gets built, the profiling lib gets built, and each command is displayed as it runs
14:46:01 <dcoutts> pgavin: sounds good
14:46:04 <pgavin> a few other things I'm sure
14:46:36 <dcoutts> pgavin: I was wondering if it's necessary to modify Distribution.PackageDescription to use the state monad, it's easier to get these changes in if they don't impact other bits
14:47:06 <pgavin> I don't recall modifying PackageDescription
14:47:15 <pgavin> oh, ok, I know what you mean
14:47:29 <pgavin> I pulled the St monad out into a separate module
14:47:29 <dcoutts> lift vs liftSt
14:48:14 <dcoutts> pgavin: I just mean that in adding experimental code, it's much easier if it doesn't change much of the existing code unnecessarily
14:48:24 <pgavin> right...
14:48:40 <dcoutts> pgavin: it'd be nice if we could merge it early as an alternative code path activated with a flag
14:48:55 <pgavin> right
14:48:59 <dcoutts> pgavin: but that relies on not requiring review of lots of changes to the existing code
14:49:15 <dcoutts> pgavin: or at least keeping those refactorings clearly marked
14:49:35 <pgavin> I think I renamed lift to liftSt because I created liftRd for the ReaderT clone, etc.
14:49:43 <dcoutts> pgavin: getting it integrated early, even if it does not work fully would let other people test and hack
14:50:15 <pgavin> right... so, the new code needs the StT monad as well... should I just have duplicated the code, without touching the code in PackageDescription?
14:50:46 <oerjan> there is an StT monad?
14:51:00 <dcoutts> pgavin: did the PackageDescription use a state monad too?
14:51:01 <pgavin> oerjan, it's really just StateT
14:51:05 <pgavin> dcoutts, yes
14:51:21 <dcoutts> pgavin: well, I'd just duplicate it for the moment, and leave PackageDescription alone
14:51:27 <pgavin> oerjan, renamed so as not to conflict with the real one in Control.Monad.State
14:51:34 <pgavin> ok
14:51:49 <oerjan> oh, so it is not ST turned into a transformer?  that would have been nifty if possible
14:51:58 <dcoutts> pgavin: ok, gotta go, keep up the good work
14:52:05 <pgavin> dcoutts, ok :)
14:52:17 <pgavin> oerjan, no, it's not that cool :)
14:52:29 <oerjan> but i guess the mutable state implementation cannot work over backtracking monads
14:52:33 <dcoutts> pgavin: btw, I've been thinking of making this a task to hack on at the Haskell Hackathon, so anything we get done before then is a great help
14:52:38 <Tac-Work> @hoogle Read a => String -> Maybe a
14:52:39 <lambdabot> No matches, try a more general search
14:53:03 <pgavin> dcoutts, ok, sure :)
14:53:04 <Tac-Work> is there any "read"-like function which returns a Maybe instead of raising an error on failure?
14:53:15 <dcoutts> pgavin: simplicity is good too, clarity vs performance, since we will want to explain this code to other hackers (in only a short time at the hackathon)
14:53:30 <dcoutts> pgavin: ok, I'm really off...
14:53:55 <TSC> Tac-Work: I think it's possible for you to write a wrapper around read and catch its exception
14:54:03 <TSC> Then you can return Just/Nothing
14:54:07 <xerox> ?type listToMaybe . reads
14:54:09 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
14:54:19 <pgavin> @hoogle cache
14:54:19 <lambdabot> System.Win32.Mem.pAGE_NOCACHE :: ProtectFlags
14:54:22 <pgavin> @hoogle catch
14:54:22 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
14:54:23 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
14:54:23 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
14:54:25 <pgavin> oops :)
14:54:40 <pgavin> Tac-Work, you want one of the first two
14:54:48 <TSC> + unsafePerformIO
14:54:52 <xerox> Why don't use reads?
14:54:55 <xerox> ?type listToMaybe . reads
14:54:57 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
14:55:22 <pgavin> oh, wait... there's a version of catch that's not in IO...
14:55:24 <oerjan> this is what reads is for
14:55:25 <pgavin> isn't there?
14:55:27 <Tac-Work> hmm
14:55:31 <xerox> pgavin: no there isn't.
14:55:36 <pgavin> oh, lol :)
14:55:46 <oerjan> @src Read
14:55:46 <lambdabot> class Read a where
14:55:46 <lambdabot>   readsPrec    :: Int -> ReadS a
14:55:46 <lambdabot>   readList     :: ReadS [a]
14:55:46 <lambdabot>   readPrec     :: ReadPrec a
14:55:46 <lambdabot>   readListPrec :: ReadPrec [a]
14:56:24 <Tac-Work> what is Prec short for here?
14:56:31 <oerjan> precedence
14:56:38 <Tac-Work> hmm
14:56:59 <oerjan> it takes care of whether you need parentheses when parsing a subexpression
14:58:23 <Tac-Work> it seems like what I'm trying to do wouldn't be so hard to do
14:58:35 <Biilmann> trying out HXT but I'm having a problem with the simple example
14:58:54 <Biilmann> the "proc l -> do" syntax gives me a parse error on ->
15:00:00 <SamB> Biilmann: -farrows
15:00:02 <SamB> I think
15:01:29 <oerjan> > let readMaybe s = do (x,rest) <- Just (reads s); guard $ all isSpace rest; return x in map readMaybe ["12","fnord"] :: [Int]
15:01:30 <lambdabot>  Couldn't match expected type `[(a, String)]'
15:01:53 <oerjan> > let readMaybe s = do (x,rest) <- Just (reads s); guard $ all isSpace rest; return x in map readMaybe ["12","fnord"] :: [Maybe Int]
15:01:54 <lambdabot>  Couldn't match expected type `[(a, String)]'
15:02:01 <oerjan> er
15:02:09 <oerjan> > let readMaybe s = do (x,rest):_ <- Just (reads s); guard $ all isSpace rest; return x in map readMaybe ["12","fnord"] :: [Maybe Int]
15:02:11 <lambdabot>  [Just 12,Nothing]
15:02:21 <Olathe> Just Nothing
15:02:51 <Biilmann> thanks SamB - got me a bit further
15:03:01 <Tac-Work> @type fromMaybe
15:03:03 <lambdabot> forall a. a -> Maybe a -> a
15:06:03 <oerjan> actually that should be [(x,rest)] <- ... to be compatible with read, which also gives an error on ambiguity
15:07:34 <Tac-Work> I'll have to play with this
15:07:49 <Tac-Work> but this seems like it should be such a standard functionality
15:08:17 <oerjan> Tac-Work: er, reads _is_ that standard functionality, it just gives somewhat more information
15:09:06 <Tac-Work> I don't see what the extra information is useful for in the average application
15:09:41 <oerjan> the second element of the tuple is useful for parsing the remainder of the string
15:09:53 <Tac-Work> maybe I don't undrestand it, but it looks like something to make it easier to parse rather than to convert data from string representation to internal representation
15:10:10 <Tac-Work> then why return a list?
15:10:37 <oerjan> ok it is a parser representation
15:11:30 <Tac-Work> It just seems like an overkill solution for what I want to do
15:12:08 <oerjan> also, if you don't expect trailing space then do (x,"") <- Just (reads s); return x will do
15:12:28 <oerjan> er, do [(x,"")] <- ...
15:12:30 <Tac-Work> since most string data comes from users or files, it's sorta silly to have the standard library function throw a hard-to-catch exception
15:13:02 * mrd would not use read for that stuff
15:13:42 <oerjan> or perhaps more frequently: case reads of [(x,"")] -> ...
15:14:12 <oerjan> *reads s, i cannot type today
15:28:42 * EvilTerran wants lambda-match, damnit
15:30:13 <EvilTerran> (readMaybe s = (|[(x,"")] -> return x) (reads s))
15:30:21 * EvilTerran goes to bed
15:30:57 <LXIX> hi
15:31:32 <oerjan> hi LXIX
15:36:20 <shapr> salut LXIX
15:36:31 <shapr> @users
15:36:31 <lambdabot> Maximum users seen in #haskell: 392, currently: 365 (93.1%), active: 9 (2.5%)
15:36:37 <LXIX> lu shapr
15:37:30 <shapr> Apprenez vous les langues fonctionelle?
15:37:32 <shapr> Er..
15:37:38 <shapr> LXIX: Are you learning Haskell?
15:38:40 <LXIX> not for the moment i'm just curious a friend is learning haskell, and i'm trying to do same (sorry for my really bad english)
15:38:56 <shapr> Do you have any questions?
15:39:19 <LXIX> no :}
15:39:50 <shapr> Ok, feel free to ask any questions when you get them.
15:40:22 <LXIX> ok thank you shapr :)
15:42:53 <LXIX> ah yeah i've one question on windows i need http://www.cse.ogi.edu/PacSoft/projects/Hugs/downloads/Hugs98install.exe ?
15:42:56 <lambdabot> http://tinyurl.com/y9ron4
15:45:03 <oerjan> the official site is http://cvs.haskell.org/Hugs/pages/downloading.htm
15:45:04 <lambdabot> Title: Downloading Hugs
15:45:59 <LXIX> ah cool thx :)
15:46:15 <lament> it would probably be better to get ghci though, because you need it for a lot of stuff anyway
15:46:18 <lament> ghc
15:46:21 <lament> err
15:46:30 <oerjan> @where ghc
15:46:31 <lambdabot> http://haskell.org/ghc
15:47:31 <dibblego> @let 1 = 2 in 1
15:47:32 <lambdabot>  Parse error
15:47:34 <dibblego> > let 1 = 2 in 1
15:47:37 <lambdabot>  1
15:47:43 <oerjan> i was going to tell you if you didn't :)
15:48:01 <oerjan> wrong channel
15:49:27 <oerjan> 1 = 2 is never evaluated because let declarations are lazy and there is no variable that could trigger it
15:49:46 <Saizan> > let x@1 = 2 in x
15:49:48 <lambdabot>   Irrefutable pattern failed for pattern (x@1)
15:50:06 <damg> but 2*2 = 5 ...
15:50:16 <lament> > let x@1 = 1 in x
15:50:17 <lambdabot>  1
15:50:20 <lament> heh
15:51:20 <Saizan> yeah the funny thing is that with let 2 * 2 = .. you are defining *, and with let 1 = 2 you're pattern matching, it makes sense if you consider numeric literals contructors
15:51:42 <lament> > let x@5 = 2 * 2 in 5
15:51:43 <lambdabot>  5
15:52:01 <oerjan> > let 2*2=5 in 2*2
15:52:02 <lambdabot>  5
15:52:24 <damg> which algebra?
15:52:31 <damg> ;)
15:52:48 <lament> oerjan: cute
15:53:40 <lament> > let 2*2=5 in exp(log(2)+log(2))
15:53:41 <lambdabot>  4.0
15:56:10 <dibblego> ?check \a b -> (a :: Float) - sqrt (a * a - (b :: Float) * b / 4) == a - a * sqrt (1 - b * b / a * a)
15:56:11 <lambdabot>  Falsifiable, after 0 tests: 1.6666667, -2.5
15:56:26 <dibblego> which of the three answers on Haskell-Cafe(Geometry) is the correct one?
15:59:04 <dibblego> ?type cos
15:59:06 <lambdabot> forall a. (Floating a) => a -> a
16:00:03 <TSC> I think you need to bracket the a*a
16:00:21 <dibblego> the last one?
16:00:26 <dibblego> ?check \a b -> (a :: Float) - sqrt (a * a - (b :: Float) * b / 4) == a - a * sqrt (1 - b * b / (a * a))
16:00:27 <lambdabot>  Falsifiable, after 0 tests: 0.0, 0.0
16:00:34 <dibblego> they aren't equivalent anyway
16:00:47 <oerjan> if you add a 4 to the second denominator above then they are equal mathematically, but i wouldn't count on floating point
16:01:03 <oerjan> for positive a
16:02:33 <augustss> Those are numerically bad when a>>b
16:03:51 <dibblego> so which is the correct answer?
16:05:51 <augustss> I've not looked at the problem :)
16:06:15 <dibblego> http://www.xdweb.net/~dibblego/chord.png
16:06:31 <dibblego> I'd have thought there would be a cosine in the solution
16:06:57 <Saizan> well even with a~b that a*a-b*b is not going to work well, no?
16:07:07 <oerjan> lessee, b is the length of the _arc_ so something trigonometric is necessary
16:08:27 <augustss> a*cos t - b; x = a * (1 - sin t)
16:08:56 <luqui> I'm interested in experimenting with Haskell's garbage collector
16:09:03 <augustss> bah, a*cos t = b/2
16:09:04 <luqui> is there a nice way to "hook" when an object gets garbage collected
16:09:14 <dibblego> augustss, what is t?
16:09:19 <luqui> so I can see when it happens
16:09:20 <sorear> Not in general
16:09:28 <sorear> that would impose too much overhead
16:09:33 <luqui> hmm
16:09:33 <augustss> dibblego: half the angle at the center
16:09:42 <luqui> is there a way in specific? :-)
16:09:43 <sorear> we have a special class of object 'ForeignPtr' that can have finalizers
16:10:15 <sorear> Keep in mind that there are no rules beyond 'GC must not make your program crash'
16:10:20 <augustss> dibblego: but all you need is Pythagoras
16:10:32 <luqui> sorear, sure, I'm not interested in the spec, more the implementation
16:10:36 <dibblego> augustss, I don't see how
16:10:38 <sorear> okay
16:10:51 <sorear> it's a very interesting one :)
16:10:59 <dibblego> augustss, I could if b were the chord and not the arc
16:11:04 <augustss> dibblego: a^2 = (b/2)^2 + (a-x)^2
16:11:32 <oerjan> sorear: you don't need ForeignPtr for finalizers
16:11:43 <dibblego> augustss, that would be, if b were the chord and not the arc
16:11:44 <augustss> dibblego: oh, b is the arc
16:11:57 <oerjan> there is just a more specific function for those
16:12:21 <luqui> oerjan, do tell
16:12:22 <augustss> dibblego: well, then x = a * (1 - sin (b/2))
16:12:38 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
16:12:40 <lambdabot> http://tinyurl.com/25thsv
16:12:54 <oerjan> (addFinalizer, which mentions the special variants)
16:12:57 <dibblego> augustss, now I have 4 answers :)
16:13:11 <augustss> dibblego: they could all be equivalent
16:13:23 <dibblego> augustss, hence my attempt to ?check
16:13:40 <augustss> dibblego: sorry, that sin should be a cos
16:14:30 <dibblego> augustss, I also have x = a * (1 - cos (b/2a))
16:14:45 <dibblego> augustss, which is *almost* equivalent to yours
16:15:12 <augustss> yeah, and that's the right one
16:15:20 <augustss> i forgot to divide by a
16:15:26 <dibblego> thought so, thanks :)
16:15:37 * oerjan agrees with the last version
16:16:14 <dibblego> great, so do I mostly too
16:16:16 <dibblego> thanks again
16:17:10 <oerjan> dibblego: however, you cannot use equality to check floating points, there are always going to be rounding errors
16:17:13 <augustss> dibblego: but if you want to compute x for b<<a you need a different formula to get any accuracy
16:17:24 <dibblego> oerjan, yeah I know
16:17:36 <dibblego> augustss, what is b<<a?
16:17:48 <TSC> Very less than
16:17:52 <augustss> yes
16:18:06 <dibblego> why do I need a different formula?
16:18:24 <augustss> because cos(b/2a) is going to be almost 1
16:18:36 <augustss> so you'll get massive cancellation in the subtraction
16:19:21 <dibblego> you mean, because of floating point inaccuracies
16:19:24 <augustss> yes
16:19:29 <dibblego> ok
16:19:32 <cosmic-asshole> Hi, I am trying to compile a program that uses Xlib.  Stuff from Xlib works fine in GHCi but it refuses to link when I compile it with ghc -lX11 ...
16:19:35 <cosmic-asshole> What could it be?
16:19:56 <SamB> s/-l/-package /
16:20:44 <cosmic-asshole> SamB: Oh, thanks!
16:21:00 <sorear> cosmic-asshole: or just use --make, for automatic dependency resolution
16:22:49 <oerjan> 1 - cos x ~ x^2/2 for small x, iirc the taylor series
16:22:58 <cosmic-asshole> sorear: thanks
16:23:14 <oerjan> er, wait
16:23:22 <dibblego> what is ~ ?
16:23:26 <augustss> oerjan: yep, and you can always add a few terms, like x^4/24
16:23:42 <oerjan> approximately equal
16:23:57 <dibblego> I thought that had a bar underneath it
16:23:58 <oerjan> i.e. the quotient has limit 1
16:24:17 * oerjan doesn't have unicode properly set up
16:24:19 <augustss> dibblego: yes, but what can you do with ASCII :)
16:24:26 <dibblego> augustss, ok, just checking :)
16:24:46 <oerjan> or even two bars sometimes
16:25:25 <xerox> dibblego: f ~ g for x -> x_0 \in R u {+oo,-oo} iff lim_{x->x_0} f(x)/g(x) = 1
16:26:24 <dibblego> is \in latex for set membership?
16:26:33 <TSC> Yep
16:26:34 <xerox> Right.
16:26:42 <dibblego> ok cheers
16:32:09 <johnnowak> leave
16:32:14 <johnnowak> ah .. screw.
16:40:00 <chessguy> @pl m x = m' \i -> x
16:40:00 <lambdabot> (line 1, column 10):
16:40:00 <lambdabot> unexpected "\\"
16:40:00 <lambdabot> expecting variable, "(", operator or end of input
16:40:10 <chessguy> @pl m x = m' $ \i -> x
16:40:10 <lambdabot> m = m' . const
16:41:38 <chessguy> @pl r l l' = (r l) ++ l'
16:41:38 <lambdabot> r = fix ((++) .)
16:41:54 <chessguy> eh?
16:42:14 <chessguy> @pl revAppend list1 list2 = (reverse list1) ++ list2
16:42:14 <lambdabot> revAppend = (++) . reverse
16:42:33 <chessguy> oh, my bad
16:43:03 <idnar> @where fix
16:43:03 <lambdabot> I know nothing about fix.
16:43:12 <oerjan> @src fix
16:43:12 <idnar> @src fix
16:43:12 <lambdabot> fix f = let x = f x in x
16:43:12 <lambdabot> fix f = let x = f x in x
16:43:15 <idnar> heh
16:43:22 <oerjan> @quote stereo
16:43:22 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
16:43:31 <chessguy> :index fix
16:43:40 <chessguy> @index fix
16:43:40 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
16:43:55 <LoganCapaldo> (: is special only for t iirc)
16:44:23 <chessguy> @pl a x = a' (x==)
16:44:24 <lambdabot> a = a' . (==)
16:45:36 <LoganCapaldo> @pl a x = a' (==x) -- how smart are you?
16:45:37 <lambdabot> a = a' . (==)
16:45:42 <LoganCapaldo> preeety smart
16:45:58 <ddarius> That is not smart.
16:46:07 <LoganCapaldo> It's not?
16:46:20 <ddarius> It's only nice if (==) is commutative.
16:46:30 <LoganCapaldo> and isn't == commutative?
16:46:47 <ddarius> Depends on the instance.
16:46:51 <LoganCapaldo> Granted
16:47:11 <LoganCapaldo> Maybe it's a personal failing, but I can't think of a good reason to have a non-communative ==
16:47:20 <augustss> pl has a number of sematical bugs
16:47:59 <shapr> Can you detail them?
16:48:23 <LoganCapaldo> @pl a x = a' (+x)
16:48:27 <lambdabot> a = a' . (+)
16:48:34 <LoganCapaldo> @pl a x = a' (-x)
16:48:34 <lambdabot> a = a' . negate
16:48:38 <augustss> There are good reasons for keeping == commutative, but since the compiler doesn't check it, it's just wrong to assume it
16:49:09 <Olathe> The compiler is too lazy.
16:49:23 <LoganCapaldo> @pl a x = a' (**x)
16:49:23 <lambdabot> a = a' . flip (**)
16:49:25 <augustss> Olathe: yes, it wants to terminate
16:49:30 <LoganCapaldo> @pl a x = a' (x**)
16:49:30 <lambdabot> a = a' . (**)
16:49:32 <LoganCapaldo> ah
16:49:35 <sjanssen> @pl f = x ()
16:49:35 <lambdabot> f = x
16:49:47 <LoganCapaldo> well it does know about "supposed" communativities it seems
16:49:59 <LoganCapaldo> So if not smart, its certainly "clever"
16:50:18 <augustss> too clever
16:50:53 <LoganCapaldo> Hmm
16:51:06 <LoganCapaldo> almost make sme wish you could put functions in classes
16:51:23 <augustss> huh?
16:51:42 <LoganCapaldo> pl :: (Commutative f) => f -> optimized f
16:51:46 <LoganCapaldo> or something :)
16:52:20 <augustss> You'd also want the compiler to check that it is commutative
16:52:24 <LoganCapaldo> "value instances"
16:52:28 <LoganCapaldo> is that better?
16:52:31 <LoganCapaldo> well sure
16:52:33 <augustss> which is undecidable, of course
16:52:46 <Saizan> quickcheck it! :D
16:52:49 <LXIX> bye
16:52:50 <augustss> you could add proofs and check those
16:52:53 <chessguy> @type repeat
16:52:55 <lambdabot> forall a. a -> [a]
16:53:03 <oerjan> augustss: naturally, the instance declaration would be the proof
16:53:14 <conal> what do people like for marking ghc options in source code: OPTIONS?  and a -fglasgow-exts catch-all or more specific things like -XTypeSynonymInstances ?
16:53:29 <chessguy> @hoogle Int -> a -> [a]
16:53:29 <lambdabot> Prelude.replicate :: Int -> a -> [a]
16:53:34 <chessguy> @src replicate
16:53:34 <lambdabot> replicate n x = take n (repeat x)
16:53:45 <augustss> oerjan: except that Haskell doesn't allow you to put anything sensible in such an instance, really
16:53:49 <int-e> conal: you can add {-# LANGUAGE extension1, extension2 #-} to that list
16:53:49 <Igloo> conal: Use the LANGUAGE pragma, or at the very least OPTIONS_GHC
16:53:51 <oerjan> conal: LANGUAGE seems preferred when it works
16:54:01 <sjanssen> conal: for throw away scripts I use OPTIONS_GHC -fglasgow-exts
16:54:24 <oerjan> augustss: i was assuming if we added value instances we would also add whatever made them useful
16:54:24 <sjanssen> conal: just because I'm too lazy to look up the names of the specific flags ;)
16:54:42 <conal> thanks all.  does anyone know the flag to enable "forall"?
16:55:05 <chessguy> @pl all3 f = do1 0 where do1 n = n==3 || (f n && do1 (n+1))
16:55:05 <lambdabot> (line 1, column 28):
16:55:05 <lambdabot> unexpected "="
16:55:05 <lambdabot> expecting variable, "(", operator or end of input
16:55:07 <Igloo> That depends what you want to use it for
16:55:28 <Igloo> PolymorphicComponents, Rank2Types or RankNTypes, probably
16:55:40 <augustss> oerjan: you need properties.  So what you really need in a class is a property, i.e., type.  And then the instance will have a proof
16:56:57 <conal> hm: i did: {-# LANGUAGE -XTypeSynonymInstances -#} .  and got:     cannot parse LANGUAGE pragma.   from ghc 6.7
16:57:07 <int-e> drop the -X
16:57:11 <conal> ah!
16:57:20 <chessguy> is that just all3 f = all f [1..3] ?
16:57:39 <chessguy> er, [0..2]
16:57:41 <dons> does this link work for anyone, http://www.kirit.com/Yoda%20speaks%20Visual%20Haskell
16:57:44 <lambdabot> Title: Yoda speaks Visual Haskell â kirit.com
16:57:49 <phobes> decidability is overrated
16:57:51 <conal> Hm.  {-# LANGUAGE TypeSynonymInstances -#} .  same "cannot parse" error
16:57:57 <chessguy> works here dons
16:58:01 <dons> ok.
16:58:14 <oerjan> conal: #-}
16:58:14 <dons> http://programming.reddit.com/info/2jag6/comments
16:58:14 <dons> then.
16:58:15 <lambdabot> Title: Yoda speaks Visual Haskell : A Haskell Tutorial (reddit.com)
16:58:39 <lament> wasn't that on reddit recently?
16:58:49 <conal> oerjan: thanks!
16:58:52 <dons> haven't seen it.
16:59:12 <dons> lament: nothing turns up in the search either
16:59:52 <lament> yeah, my mistake, probably i just saw it in here
17:00:30 <oerjan> chessguy: looks like it (all f [0..2])
17:00:44 <chessguy> oerjan, sheesh :)
17:00:57 <conal> the following works.  any improvements?
17:00:57 <conal> {-# LANGUAGE TypeSynonymInstances, FlexibleContexts, MultiParamTypeClasses  #-}
17:00:57 <conal> {-# OPTIONS_GHC -O2 #-}
17:01:20 <chessguy> @pl all3 f = all f [0..2]
17:01:21 <lambdabot> all3 = flip all [0..2]
17:03:09 <oerjan> chessguy: haskell contains most frequent forms of recursion as a predefined function in some way
17:03:23 <chessguy> oerjan, oh i know
17:03:31 <chessguy> oerjan, i'm re-writing someone else's code :)
17:03:56 <oerjan> heh
17:04:21 <oerjan> aiming for that one-liner to replace their whole program?
17:04:26 <chessguy> lol
17:04:47 <chessguy> not likely, but they didn't give haskell a very nice review, so it would be nice to give a little 'in your face'
17:04:58 <chessguy> http://www.prairienet.org/~dsb/t3/t3.htm
17:04:59 <lambdabot> Title: Dan Bensen: Tic-Tac-Toe
17:06:13 <chessguy> @type intersperse
17:06:15 <lambdabot> forall a. a -> [a] -> [a]
17:06:33 <chessguy> > intersperse 3 $ repeat 1
17:06:34 <lambdabot>  [1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3...
17:07:27 <chessguy> wow, i've never seen a haskell line of code end with this:
17:07:29 <chessguy> )])))))
17:07:38 <pastorn_> anyone here has any experience of tabular in lhs2tex?
17:08:25 <oerjan> someone doesn't know about . and $ ...
17:08:43 <pjd> chessguy: Liskell? :)
17:09:09 <idnar> bwahaha
17:09:48 <dons> chessguy: heh
17:10:51 <dons> hmm, `test ? (ifTrue,ifFalse) = if test then ifTrue else ifFalse'
17:11:14 <dons> hmm , mapVal x = map (\i -> x)
17:11:45 <dons> I detect lambdabot at work! cellIsFull = (not .) . cellIsBlank
17:13:20 <olsner> @unpl (not .) . cellIsBlank
17:13:20 <lambdabot> (\ d g -> not (cellIsBlank d g))
17:16:58 <chessguy> dons, surely lambdabot would have found that mapVal = map . const
17:17:03 <pastorn_> come on... someone here HAS to have experience with lhs2tex
17:18:16 <chessguy> pastorn_, you're usually better off just asking your question
17:18:21 <phobes> lhs2TeX is a preprocessor to generate LaTeX code from literate Haskell sources. It is released under the GPL.
17:19:49 <pastorn_> i want to make a page that is a big table with two equally wide columns
17:21:10 <pastorn_> so i want the width of the whole table to be \linewidth wide and and the columns to be (\linewidth -x) / 2 where x is a small separating space in the middle
17:21:31 <phobes> chessguy: CPS is used in Haskell?
17:22:00 <chessguy> phobes, apparently. i haven't looked at the code in detail yet
17:26:35 <dons> chessguy: yeah, a bit weird
17:35:44 <chessguy> @hoogle intersperseM
17:35:44 <lambdabot> No matches found
17:38:34 <oerjan> chessguy: would intersperse x . mapM f do?
17:38:49 <chessguy> @type intersperse x . mapM ?f
17:38:51 <lambdabot> Not in scope: `x'
17:38:52 <chessguy> @type intersperse ?x . mapM ?f
17:38:54 <lambdabot> forall a b. (?x::[b], ?f::a -> [b]) => [a] -> [[b]]
17:39:28 <chessguy> hmm
17:39:38 <chessguy> @undo do { header; putRow 0; divider; putRow 1; divider; putRow 2}
17:39:38 <lambdabot> (header >> putRow 0 >> divider >> putRow 1 >> divider >> putRow 2)
17:39:47 <oerjan> :t liftM (intersperse ?x) . mapM ?f
17:39:49 <lambdabot> forall a (m :: * -> *) b. (?x::b, ?f::a -> m b, Monad m) => [a] -> m [b]
17:40:16 <chessguy> putRow :: Int -> IO (); divider :: IO ();
17:41:11 <oerjan> oh...
17:42:00 <chessguy> @src intersperse
17:42:00 <lambdabot> intersperse _   []     = []
17:42:01 <lambdabot> intersperse _   [x]    = [x]
17:42:01 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
17:42:18 <oerjan> :t sequence . intersperse ?divider . map ?putRow [0..2]
17:42:20 <lambdabot>     Couldn't match expected type `a -> [a1]'
17:42:20 <lambdabot>            against inferred type `[b]'
17:42:51 <oerjan> :t sequence_ . intersperse ?divider . map ?putRow $ [0..2]
17:42:53 <lambdabot> forall (m :: * -> *) a a1. (Monad m, ?divider::m a, ?putRow::a1 -> m a, Num a1, Enum a1) => m ()
17:43:03 <chessguy> whee
17:44:15 <chessguy> @index intersperse
17:44:15 <lambdabot> Data.List
17:44:33 <chessguy> hm, it typechecks
17:44:36 <chessguy> oerjan++
17:44:46 <chessguy> @type sequence_
17:44:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
17:45:22 <chessguy> oh, that's easy
17:46:07 <chessguy> now i get to simplify this mess: putRow row = putLine $ show (row+1) ++ (' ' : (g!(row,0) : ( " | " ++ (g!(row,1) : ( " | " ++ [g!(row,2)])))))
17:46:57 <oerjan> @src putLine
17:46:58 <lambdabot> Source not found. Wrong!  You cheating scum!
17:47:14 <chessguy> putLine = putStrLn
17:47:28 <chessguy> apparently he didn't like the name putStrLn
17:47:51 <chessguy> looks like another intersperse
17:48:12 <chessguy> @pl \n -> g!(row,n)
17:48:12 <lambdabot> (g !) . (,) row
17:49:04 <oerjan> well, intersperse " | " . map ((:[]).(g!).(,)) $ [0..2] ?
17:49:22 <chessguy> mmm
17:49:37 <oerjan> might be worth a lambda there
17:50:23 <oerjan> intersperse " | " . map (\c -> [g!(row,c)]) $ [0..2] ?
17:50:40 <oerjan> or wait...
17:50:53 <mm_freak> does anybody know of a neural network or SVM module for haskell?
17:51:27 <oerjan> intersperse " | " . [[g!(row,c)] | c <- [0..2]]
17:53:03 <oerjan> also, : and ++ have the same precedence so that parentheses are unnecessary
17:53:18 <chessguy> yeah
17:54:20 <oerjan> thus, putRow row = putLine $ show (row+1) ++ ' ' : intersperse " | " . [[g!(row,c)] | c <- [0..2]]
17:54:51 <oerjan> er, putRow row = putLine $ show (row+1) ++ ' ' : concat . intersperse " | " . [[g!(row,c)] | c <- [0..2]]
17:55:52 <chessguy> i'm not crazy about the comprehension here
17:55:57 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2474
17:57:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2475
17:57:57 <oerjan> more errors
17:58:29 <oerjan> putRow row = putLine $ show (row+1) ++ ' ' : (concat . intersperse " | ") [[g!(row,c)] | c <- [0..2]]
17:59:02 <oerjan> this . style makes me forget to distinguish the final argument
18:00:06 <oerjan> the comprehension is the cleanest way of expressing that expression, i think
18:01:47 <chessguy> hm, i prefer the map, personally
18:01:55 <chessguy> i wound up with this:
18:01:56 <chessguy> putRow row = putLine $ show (row+1) ++ ' ' : (concat . intersperse " | " . map (\c -> [g!(row,c)])) [0..2]
18:02:55 <chessguy> i don't know, maybe you're right
18:02:59 <jamesnvc> Hello, does anyone know where I can find documentation for Haskell/GHC in DocBook or texinfo format?
18:03:53 <chessguy> either way, we've cut his nasty code into half the size it was, and still made it more elegant :)
18:04:06 <chessguy> @quote melted
18:04:06 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
18:04:55 <LoganCapaldo> I'm finding that's generally true
18:05:09 <LoganCapaldo> the melting at least, if not the actually number of lines
18:05:17 <LoganCapaldo> s/actually/actual/
18:05:25 <oerjan> i think the haskell way would be to convert the whole board to a string and print it, rather than printing each line impurely
18:05:37 <chessguy> oerjan, true
18:05:47 <chessguy> oerjan, i'm just translating his code fairly directly for now
18:05:54 <oerjan> perhaps even making a Show instance
18:06:27 <oerjan> yeah
18:07:47 <chessguy> @pl c g c' = i $ g!c'
18:07:48 <lambdabot> c = (i .) . (!)
18:08:35 <chessguy> @unpl (not .) . c
18:08:35 <lambdabot> (\ e h -> not (c e h))
18:11:10 <mudge> hi haskell people
18:11:31 <chessguy> 'evening mudge
18:11:32 <LoganCapaldo> hi mudge, say the haskell people
18:11:33 <idnar> hmm, is there any way to install goa in my home directory without modifying the system-wide package.conf?
18:11:47 <mudge> anyone here from around the bay area?
18:12:04 <jamesnvc> Um, would anyone be able to tell me where to find DocBook/texinfo version of the GHC docs or how to convert the html tarball to said format(s)?
18:12:19 <ihope> If I want a really small executable, should I avoid Haskell?
18:12:35 <idnar> oh nm, I see
18:12:39 <idnar> copy / register --user
18:12:40 <ddarius> You should avoid GHC.
18:13:05 <jamesnvc> @pl \x -> [ y | y <- x]
18:13:06 <lambdabot> return . ((y | y) <-)
18:13:10 <ddarius> At least considering whatever you mean by really small.
18:13:17 <mudge> anyway, I'm asking if anyone from here is from the bay area because there is going to be a functional programming meeting in San Franscisco
18:15:28 <shapr> hiya mudge
18:15:41 <shapr> cosmic-a1shole: That's not a polite nickname...
18:16:32 <chessguy> wow, my first 130-line error code
18:16:42 <oerjan> jamesnvc: i didn't know @pl mistreated lists that badly
18:16:50 <jbauman> shapr, his name makes is sound like he's not a polite person...
18:17:10 <jbauman> *it
18:17:31 <oerjan> that is just id, anyway
18:18:07 <jbauman> @pl \x -> [x]
18:18:08 <lambdabot> return
18:18:45 <jbauman> so it could be worse
18:18:51 <jamesnvc> oerjan: yeah, pl mangles list comps
18:19:25 <ihope> @pl \x -> [x,x,x,x,x,x]
18:19:25 <lambdabot> ap (:) (ap (:) (ap (:) (ap (:) (ap (:) return))))
18:19:45 <jamesnvc> That was a trival test, just wanted to figure out how to refactor it for a more complicated comprehension
18:19:50 <oerjan> replicate 6
18:19:57 <ihope> And indeed, "really small" could be anything.
18:20:51 <ihope> How big do different compilers do 'main = putStrLn "Hello, world!"'?
18:22:14 <oerjan> chessguy: 130 lines? O_O
18:22:23 <chessguy> oerjan, yup
18:22:24 <sjanssen> well, GHC is pretty big, 316k on my system
18:23:00 <sorear> JHC is... thrashing
18:23:08 <mudge> hi shapr
18:23:14 <mudge> shapr:  where you from?
18:24:01 <mudge> shapr: oh duh,  you've already told me
18:24:03 <mudge> alabama
18:24:03 <sorear> 507MB ...
18:24:34 <mudge> plus its on your website
18:24:53 <sorear> ihope: JHC output is 6kb
18:25:39 <ihope> Is JHC pretty much the thing to use for smallness?
18:25:49 <sorear> GHC output is 218KB
18:26:07 <sorear> ihope: no, it was thrashing for three minutes and using twice my memory just for hello world
18:26:22 <ihope> Oh.
18:26:43 <sorear> ihope: I'm not actually convinced usably small memory is a priority, john has way more than us...
18:27:07 <sorear> yhc output is 127 bytes
18:27:09 <ihope> So it's good for "smaller" but not for "sooner".
18:27:27 <ihope> The binary is just 127 bytes?
18:27:32 <sorear> yup.
18:27:41 <ihope> So THAT's the thing to use for smallness?
18:27:46 <sorear> yes
18:27:59 <sorear> smallness is an explicit goal of (n)yhc
18:29:23 <sjanssen> how big is the vm?
18:30:03 <sjanssen> ihope: 127 bytes of bytecode, it isn't a full executable
18:30:38 <geezusfreeek> shapr, you're from alabama? whereabouts?
18:30:56 <geezusfreeek> i may have already known this, really
18:31:37 <ihope> @where shapr
18:31:38 <lambdabot> http://www.ScannedInAvian.com/hope
18:32:14 <ihope> Looks like @where is broken. That's not a place at all.
18:33:53 <chessguy> @help where
18:33:53 <lambdabot> where <key>. Return element associated with key
18:34:08 <chessguy> @pl \n -> f n == c
18:34:08 <lambdabot> (c ==) . f
18:34:45 <chessguy> @pl a c f = a3 (\n -> f n == c)
18:34:45 <lambdabot> a = (a3 .) . flip (flip . ((==) .))
18:34:49 <chessguy> eww
18:36:23 <idnar> heh
18:36:26 <chessguy> @pl a3c c f = flip all [0..2] (\n -> f n == c)
18:36:27 <lambdabot> a3c = (flip all [0..2] .) . flip (flip . ((==) .))
18:37:50 <chessguy> i guess i'll settle for a3c c f = all ((c ==) . f) [0..2]
18:39:31 <chessguy> @pl rowHas3 c grid row = all3c c (\col -> grid!(row, col ))
18:39:32 <lambdabot> rowHas3 = (. ((. (,)) . (.) . (!))) . (.) . all3c
18:39:37 <chessguy> nice
18:40:08 <conal> lol
18:40:26 <chessguy> @quote bf
18:40:27 <lambdabot> <erg0t> says: @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
18:43:14 <mwc> Hmm, anybody fixed alex's setup.lhs for Cabal-1.1.7?
18:43:45 <mwc> The current darcs version is still broke
18:53:05 <mwc> aha, squeeked by without needing the cabal-1.1.7 docs (which I can't build yet)... the fix was already in the source, just not used in one spot
18:56:33 <chessguy> oerjan, still around?
18:56:41 <oerjan> just barely
18:57:05 <idnar> hmm, lots of Haskell stuff in Debian seems to be out of date :/
18:57:07 <hpaste>  chessguy pasted "can anyone make heads or tails of this?" at http://hpaste.org/2476
18:57:33 <chessguy> fGetChar seems to be a function which gets a piece off the board
18:58:58 <oerjan> there's clearly a bug there, cPlayr is rebound in the case
18:59:23 <chessguy> overlapping, yes
18:59:28 <oerjan> probably wanted to check equality with it
19:00:50 <chessguy> looks like maybe a fold, which accumulates the number of blanks and pieces?
19:02:07 <ShockSMX> lambdabot understands bf?
19:02:21 <chessguy>  @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
19:02:24 <chessguy> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
19:02:25 <lambdabot>  fd:24: hClose: resource vanished (Broken pipe)
19:02:31 <ShockSMX> =[
19:02:34 <chessguy> busted at the moment
19:02:45 <ShockSMX> still, neat
19:04:12 <chessguy> @type foldr
19:04:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:05:33 <oerjan> length . filter is my suggestion
19:05:48 <chessguy> probably true
19:05:51 <chessguy> on map fGetChar [0..2]
19:06:23 <joed> Hmm. Programming Haskell is a very good book, and is available at Barnes and Nobles for around $36.
19:07:07 <chessguy> @type length . filter
19:07:09 <lambdabot>     Couldn't match expected type `[a]'
19:07:09 <lambdabot>            against inferred type `[a1] -> [a1]'
19:07:20 <oerjan> [length (filter (== c)) l | c <- [cPlayr, ' ']] == [2,1]
19:07:59 <oerjan> where l = map fGetChar [0..2]
19:08:59 <hpaste>  chessguy annotated "can anyone make heads or tails of this?" with "something like this maybe?" at http://hpaste.org/2476#a1
19:09:57 <lament> is that for a chess program? :)
19:10:09 <chessguy> tic-tac-toe
19:10:41 <chessguy> lament, i'm re-writing the haskell version of http://www.prairienet.org/~dsb/t3/t3.htm in some sensible fashion
19:10:41 <lambdabot> Title: Dan Bensen: Tic-Tac-Toe
19:12:49 <lament> oh god, "compactification"
19:13:02 <lament> never use a big word where a compactified one will do?
19:13:12 <chessguy> lol
19:13:33 <chessguy> yeah, this guy's a real gem
19:14:35 <lament> "
19:14:44 <lament> "Haskell is hard to debug. It's annoying having to pass the grid to every function." -- i can see why you would want to rewrite it :)
19:14:56 <chessguy> yeah
19:15:25 <chessguy> mostly i'm just translating his code directly to idiomatic haskell
19:15:32 <chessguy> except the bits that i can't stand
19:15:57 <oerjan> @pl \c p -> map (lfe c (map p l)) cl
19:15:57 <lambdabot> flip flip cl . (map .) . (. flip map l) . lfe
19:15:58 <LoganCapaldo> pass the grid to every function? Sounds like Reader to me.
19:15:58 <chessguy> then i'll do a real re-factor when i'm done
19:16:03 * LoganCapaldo kneejerks
19:16:24 <oerjan> @pl \c -> map (lfe c (map p l)) cl
19:16:24 <lambdabot> flip map cl . flip lfe (map p l)
19:16:33 <lament> his haskell is Odd
19:17:20 <chessguy> somehow i doubt i'm actually going to find any actual CPS in his code :)
19:18:30 <hpaste>  oerjan annotated "can anyone make heads or tails of this?" with "like this?" at http://hpaste.org/2476#a2
19:19:42 <LoganCapaldo> that type sure do look suspicious
19:19:52 <LoganCapaldo> what's with b?
19:20:40 <lament> chessguy: the toplevel loop, i suppose
19:20:41 <mwc> cd les
19:20:42 <chessguy> LoganCapaldo, what are you looking at?
19:20:45 <oerjan> oh yeah, there's a bug
19:20:55 <chessguy> oh
19:20:55 <lament> chessguy: he's passing the next move function to doMove
19:21:04 <oerjan> cPlayr is matched against when he obviously wants to test equality
19:21:08 <chessguy> lament, ah ok, i haven't gotten there yet
19:22:14 <chessguy> lament, it takes a while to undiselegantize his code first
19:22:22 <chessguy> how's that for a big made up word? :)
19:22:36 <oerjan> so the real cPlayr is never used. b should have been Char, i assume
19:22:51 <Cale> chessguy: um, cPlayr -> ... doesn't match what you think it does, in the case
19:22:52 <LoganCapaldo> @remember chessguy lament, it takes a while to undiselegantize his code first
19:22:52 <LoganCapaldo> [22:21] <chessguy> how's that for a big made up word? :)
19:22:52 <lambdabot> Done.
19:23:02 <Cale> (or whoever wrote that code)
19:23:09 <oerjan> Cale: it's not his code
19:23:14 <Cale> cPlayr will always match, because it's first
19:23:14 <chessguy> Cale, right, thus the attempts to fix it
19:23:41 <oerjan> we are assuming he wants to match against its value
19:24:14 <chessguy> @quote undisel
19:24:14 <lambdabot> chessguy says: lament, it takes a while to undiselegantize his code first
19:26:08 <LoganCapaldo> the best part is who you are addressing it too
19:26:10 <LoganCapaldo> *to
19:26:17 <LoganCapaldo> O! lament!
19:26:25 <LoganCapaldo> this code is so diselegant
19:27:17 <unaracer> I've got a silly question - I'm trying to use the logBase function, but the argument is an integer, and I'm getting "No instance for (Floating Int)" messages.
19:27:17 <chessguy> lol
19:27:31 <chessguy> unaracer, you want fromIntegral
19:27:37 <oerjan> unaracer: convert to a floating with fromIntegral
19:28:45 <unaracer> I've tried something like "    f p = p*(logBase 2.0 fromIntegral(p))
19:28:50 <FMota> hmm
19:28:56 <FMota> someone who programs in haskell
19:29:03 <FMota> is a haskeller, or a haskellite?
19:29:08 <jbauman> p*(logBase 2.0 (fromIntegral p)) ?
19:29:10 <unaracer> but f 2 gives me a "No instance for (Floating (t -> t))"
19:29:14 <lament> unaracer: fromIntegral(p) doesn't mean what you think it means
19:29:55 <lament> unaracer: what you pasted is the same as p*((logBase 2.0 fromIntegral) p)
19:30:08 <unaracer> Ack.
19:30:37 <oerjan> also, you need a fromIntegral around the first p too
19:30:37 <unaracer> Thank you.
19:30:40 <unaracer> :)
19:30:42 <geezusfreeek> FMota, it can't just be haskell programmer?
19:31:03 <FMota> hmm... doesn't really fit too well. But ok.
19:31:21 <chessguy_> oh good grief, his AB code is awful
19:31:30 <mm_freak> is it safe to replace "Neither the name of the <ORGANIZATION> nor the names of its contributors" by "Neither the name of the author nor the names of any contributors" in the BSD license?
19:31:49 <mm_freak> because i'm not an organization
19:32:11 <geezusfreeek> mm_freak, really you should be able to customize the license to your liking anyway
19:32:18 <lament> regarding the fromIntegral issue, i must say the whole hierarchy of numeric classes is an Utterly Unnecessary Huge Pain That Only A Bunch Of Academics Could Devise.
19:32:23 <geezusfreeek> just don't call it the BSD license if you destroy it
19:32:28 <geezusfreeek> ;)
19:32:44 <oerjan> lament: you won't get anywhere with flattery.
19:32:48 <mm_freak> geezusfreeek: i'm replacing "its contributors" by "any contributors"â¦  i'm afraid, this might destroy the sense of the clause
19:33:15 <LoganCapaldo> I kinda like the scheme style
19:33:20 <chessguy> UUHPTOABOACD
19:33:26 * idnar finally finishes collecting lamdbabot dependencies
19:33:53 <LoganCapaldo> if haskell just got rid of the the need for things like fromIntegral, so you could in general ignore exactly which numeric type you were using...
19:33:58 <geezusfreeek> i'm no expert, but that seems significant enough to not technically be the BSD licence anymore, IMO
19:34:18 <LoganCapaldo> (I almost said "I kinda like the scheme scheme" but it seemed excessive)
19:34:39 <olsner> excessive, but correct
19:35:11 <oerjan> I kinda like kinds
19:35:13 <olsner> anyway, implicit conversions come with their own problems
19:35:28 <LoganCapaldo> that they do
19:35:38 <blakkino2> geezusfreeek, i have a "cast x = fromInteger $ toInteger $ x" imported in all my sources
19:35:40 <blakkino2> :)
19:35:59 <oerjan> @src fromIntegral
19:35:59 <lambdabot> fromIntegral = fromInteger . toInteger
19:36:19 <olsner> cast :: forsome a b. a -> b
19:36:27 <blakkino2> ah :)
19:37:48 <oerjan> haskell, the programming language where it is hard to invent new functions
19:41:25 <int-e> mm_freak: the last time I struggled with this I settled for 'his'.
19:42:29 <int-e> not sure if that's any better.
19:43:27 <mm_freak> int-e: well, the contributors are not _my_ contributors, but contributors of/for the package
19:48:40 <thetallguy> @pl (\x y -> (+) x y)
19:48:40 <lambdabot> (+)
19:50:02 <chessguy> @type not
19:50:04 <lambdabot> Bool -> Bool
19:50:26 <int-e> mm_freak: a third variant I've found now is 'other'.
19:52:37 <mm_freak> int-e: that's about the same as "any"
19:52:53 <int-e> mm_freak: but as I see it, I claim the copyright of the software and in that sense the other contributors are mine; they've contributed to my work.
19:53:37 <mm_freak> well, logically "any" includes "mine", so that's ok for now =)
19:53:51 <jbauman> does it count as work for hire?
19:56:11 <newsham>         ASSERT(2+2 == 5);
19:56:14 <newsham> heh, cute
19:57:09 <chessguy> well, his code works now
19:58:23 <chessguy> though it's almost as much my code as his, and i'm nowhere near done refactoring
20:01:30 <chessguy> is it weird to enjoy gutting someone else's code at least as much as writing your own?
20:02:10 <idnar> I enjoy gutting any code, regardless of whether it was written by myself or someone else ;)
20:02:45 <chessguy> good point
20:03:16 <phobes> chessguy: So his code for tic-tac-toe in haskell didn't even work?
20:03:40 <chessguy> phobes, i couldn't get it to compile. thought it may have been a whitespace issue
20:03:55 <chessguy> s/thought/though/
20:04:00 <phobes> hmm ok
20:08:13 * FMota wonders if lazy is the right way to go.
20:08:39 <FMota> actually
20:08:41 <FMota> I think lazy is fine
20:09:01 <LoganCapaldo> laaaaaazy is the best
20:09:06 <FMota> but trying to make a type system strong and support laziness is kinda hard.
20:09:46 <FMota> I think a mixture out to do -- expressions are lazy by default, but they only compile if they could be strict.
20:10:00 <FMota> Meaning no infinite lists.
20:10:58 <FMota> Is there a name for that/?
20:11:00 <FMota> *?
20:11:29 <LoganCapaldo> http://lambda-the-ultimate.org/node/243
20:11:30 <lambdabot> Title: Combining lazy and eager evaluation of terms | Lambda the Ultimate
20:12:11 <FMota> that's exactly what I was thinking about :)
20:12:16 <FMota> ty
20:12:22 <LoganCapaldo> yeah
20:12:29 <LoganCapaldo> your dialogue reminded me of something :)
20:13:41 <FMota> ;)
20:14:26 <mudge> ;)
20:14:58 <FMota> #haskell has all the answers. You just need the right question. ;)
20:15:08 <mudge> ;)
20:15:31 <jcreigh> 42
20:15:33 <mudge> Lisp should have ;) instead of parenthese
20:16:14 <jbauman> it would be disturbing programming with all those faces winking at you
20:16:25 <FMota> (defun infinite-loop (;) (infinite-loop;);) ?
20:16:27 <mudge> yea, but it would be cute
20:16:50 <mudge> and hasn't it been said that some programmers care about how their code looks?
20:16:55 <mudge> I like looking at cute things
20:16:59 <FMota> :o
20:17:19 <FMota> I think all programmers /should/ care about how thie code looks.
20:17:21 <FMota> *their
20:17:50 <mudge> i wish there was a keyboard key for pretty girl
20:18:14 <FMota> I doubt my sentiment is shared with all of #haskell, unfortunately (for me, and other syntax 'lovers')
20:18:38 <jbauman> mudge, i'm sure you love lolcode
20:18:42 <ddarius> Haskell isn't pretty?
20:19:01 <FMota> ddarius: Not nearly enough
20:19:04 <mudge> i've checked out lolcode, some of it is pretty hilarious
20:19:04 <FMota> IMHo
20:19:19 <mudge> haskell is pretty in its algorithms
20:19:43 <mudge> and that beaty seeps out of the code
20:19:48 <mudge> bueaty
20:20:27 <wli> Modern Haskell is pretty enough, but 1.4 was a bloody work of art.
20:20:28 <mudge> beauty
20:20:54 <FMota> :)
20:21:12 <LoganCapaldo> wli: you don't have any 1.4 code lying around? Is it really that purty?
20:21:15 <FMota> I'm glad you like haskell (why else would you code in it?)
20:21:16 <mudge> lambdabot should have spellchecking,  and correct our spelling,  wouldn't that be anoying in a fun way
20:21:33 <LoganCapaldo> lambdabot does have spellchecking
20:21:33 <FMota> *annoying
20:21:37 <LoganCapaldo> @lte a = 3
20:21:38 <lambdabot> Maybe you meant: elite ft let vote
20:21:43 <LoganCapaldo> @lett a = 3
20:21:55 <lambdabot> Defined.
20:21:59 <LoganCapaldo> > a
20:22:02 <lambdabot>  3
20:22:10 <oerjan> @info spell checking
20:22:10 <lambdabot> (spell checking)
20:22:11 <FMota> :o
20:22:24 <LoganCapaldo> @spell trth
20:22:29 <wli> LoganCapaldo: Someone dredged up a 1.4 Prelude and it was godlike. Monad comprehensions, map instead of fmap being the method for functor, (++) the method for MonadPlus, MonadZero and MonadPlus separate, no fail horsecrap in Monad, etc.
20:22:44 <LoganCapaldo> wli, my. god.
20:22:54 <wli> LoganCapaldo: Plus an adjoint functor typeclass.
20:22:55 <LoganCapaldo> What happened????
20:23:12 <wli> LoganCapaldo: Damage. Severe damage. Severe degradation.
20:23:15 <olsner> Haskell 98 happened?
20:23:32 <FMota> :/
20:23:36 <wli> olsner: Yes, Haskell 98 is the name of that damage.
20:23:45 <mudge> how so?
20:24:02 <dolio> @quote polymorphic.scare
20:24:03 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
20:24:41 <wli> mudge: Keep using things a while and you'll see what's going on.
20:24:57 <sfultong> well, why isn't a parallel dialect of haskell being developed?  Surely someone could come up with another sane standard
20:25:26 <mudge> wli: thanks
20:25:30 <sorear> @nazi-on
20:25:31 <lambdabot> Spelling nazi engaged.
20:25:43 <wli> sfultong: Those who care are either unwilling or unable to hack the compiler intrinsics needing to be redone to develop it.
20:25:56 <oerjan> @help nazi-on
20:25:57 <lambdabot> spell <word>. Show spelling of word
20:26:11 <mudge> what's wrong with haskell 98?
20:26:15 <mudge> i thought it was a good thing
20:26:18 <oerjan> @list nazi-on
20:26:18 <lambdabot> spell provides: spell spell-all
20:26:35 <olsner> @spell-all
20:26:35 <lambdabot> No phrase to spell.
20:26:43 <sorear> No, list only shows commands that do not require special privileges.
20:26:50 <wli> mudge: As far as I'm seeing it was largely a castration of 1.4
20:27:18 <mudge> wli: you mean like it made it a smaller language,  less features and such?
20:27:40 <wli> mudge: Worse. It dumbed it down and made it less useful.
20:27:52 <jcreigh> mudge: don't misunderstand, H98 is a great language. There's just a handful of little quirks that could have easily been avoid, but weren't.
20:28:38 <mudge> ok, thanks
20:28:45 <wli> jcreigh: Well, ripping out monad comprehensions was a major major loss.
20:28:53 <jcreigh> mudge: you'll know them when you see them. :)
20:29:14 <sfultong> wli: you seem rather capable, perhaps you could start 1.4 back up
20:29:26 <dolio> Was length generic in 1.4?
20:29:33 <mudge> jcreigh: oh good,  but ghc and others have extensions past 98,   are these kinds of features in the extensions?
20:29:35 <sorear> Nazi-mode seems to have broken - deliberately misspeelled word
20:29:48 <wli> sfultong: I'm less capable than I appear. I've attempted to hack on ghci and failed.
20:30:23 <mudge> wli: sometimes its easier to start from scratch
20:30:31 <dolio> Ah, no it wasn't.
20:30:46 <wli> sfultong: I wouldn't "start 1.4 back up" anyway; I'd just alter the compiler intrinsics in/around comprehensions and do notation unsugaring.
20:31:22 <sorear> The simons have pre-approved monad comprehensions and MonadZero, so if anyone implements them, the patch will (barring obscenely bad code) be accepted.
20:31:37 <wli> sfultong: And numeric literal desugaring (which breaks alternate numeric hierarchies as it now stands unless it's been recently fixed).
20:32:02 <wli> sorear: I'm vastly less capable than many others. It would be a Herculean effort for me where it'd be trivial for others.
20:32:23 * sfultong wishes he was more capable
20:32:29 <mudge> sorear the "simons"  what's that?
20:32:39 <wli> Simon Peyton-Jones and Simon Marlow
20:32:41 <sfultong> I'm never certain how good a programmer I am...
20:32:42 * sorear is almost certainly capable, but utterly unmotivated
20:32:50 <mudge> ah, them simons
20:33:08 <olsner> I should start hacking on haskell stuff and join the simons
20:33:08 <sfultong> sorear: unmotivated by disinterest, or something else?
20:33:12 <FMota> Simon Peyton-Jones was a reddit celebrity. :o
20:33:15 <mudge> * is just to ignorant
20:33:16 <wli> sorear: Working knowledge of ghc (or other) internals or just confidence?
20:33:41 <mudge> hey, how do you do that star thing,   where it makes a start by your name when you write?
20:33:41 <sorear> A lot of the second, a little of the first...
20:33:52 <sorear>  /me waves
20:33:59 <olsner> (since that'd make us more simons)
20:34:09 <sorear> or if your client doesn't do that, \001ACTION waves\001
20:34:28 <wli> \001ACTION waves\001
20:34:28 <sorear> you'll need to use a real ascii STX, not backslash zero zero one
20:35:08 <olsner> STX?
20:35:08 <sorear> @. where+ read "prod \001ACTION waves\001"
20:35:08 <lambdabot> Done.
20:35:12 <sorear> @where prod
20:35:12 * lambdabot waves
20:35:21 <sorear> Start of TeXt
20:35:28 <sfultong> I need to visit a motivation farm, and pick a couple bushels
20:35:47 <olsner> IRC protocol internals, eh?
20:35:54 <monochrom> Haha, raw octet IRCing.
20:35:59 <bjoern_> Hi. I am looking for a Haskell implementation of a DFA -> regular expression conversion algorithm. Any pointers? Google wasn't really helpful.
20:36:12 <monochrom> "My IRC client is telnet"... "or even nc".
20:36:13 <sorear> More like mIRC hacks that are still technically nonstandard but everyone has clonbed thedm
20:36:58 <sorear> bjoern_: If you can find a constructive proof of Kleene's Theorem, the curry-howard isomorphism will give you your algorithm
20:37:09 <monochrom> haha
20:37:46 <olsner> just waiting for the splat...
20:37:48 <phobes> sorear: have you been drinking tonight?
20:38:00 <sorear> no.
20:38:14 <gvdm_other> hes perfectly crrect
20:38:27 <gvdm_other> i'd like to see that proof though
20:38:50 <bjoern_> Well I am specifically looking for an existing implementation. In my C implementation I am using state elemination to do the conversion, I am essentially wondering how you would do the same in Haskell (or Lisp for that matter).
20:39:25 <dons> ?users
20:39:25 <lambdabot> Maximum users seen in #haskell: 392, currently: 353 (90.1%), active: 17 (4.8%)
20:39:47 <sorear> looks like -> http://www.cs.nuim.ie/~jpower/Courses/parsing/node6.html <- is a usable proof
20:39:49 <lambdabot> Title: Kleene's Theorem
20:40:06 <olsner> first hit on google, too
20:40:14 <mudge> I defined this haskell function: map1 f = foldr (\x xs -> (f x) : xs) []
20:40:28 <mudge> and it gave me this type: map :: (a -> a1) -> [a] -> [a1]
20:40:45 <mudge> why doesn't it give me this type with the bs : map :: (a -> b) -> [a] -> [b]
20:40:46 <mudge> ?
20:41:04 <jcreigh> it's the same thing
20:41:30 <mudge> map :: (a -> b) -> [a] -> [b]   and  map :: (a -> a1) -> [a] -> [a1]   are the exact same type?
20:41:38 <olsner> yes
20:41:51 <jcreigh> yeah...they're just placeholders for types.
20:42:01 <mudge> is there any reason for the interpreter to sometimes give the b version and sometimes the a version?
20:42:11 <mudge> a1 version i mean
20:42:12 <jcreigh> like "f a b = a + b" and "f x y = x + y" are the same function.
20:42:28 <int-e> mudge: it tries to derive the variable names from the signatures in the code.
20:43:38 <int-e> mudge: but in the end it's pretty much unpredictable because it depends on which type signature the type came from.
20:43:41 <mudge> oh
20:44:28 <mudge> has anyone done any or all the exercises in the book Programming Haskell?
20:44:33 <mudge> that's what I'm doing
20:44:53 <wli> mudge: Graham Hutton's book?
20:44:56 <mudge> yea
20:44:59 <monochrom> Some grad student under Hutton must have, I bet. :)
20:45:02 <int-e> @type \f g -> tail (map f g)
20:45:04 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
20:45:05 <wli> I wonder if there's a bookstore in Portland, OR carrying it.
20:45:17 <int-e> here the 'a1' seems to be derived from the type of tail,
20:45:18 <int-e> @type tail
20:45:20 <lambdabot> forall a. [a] -> [a]
20:45:34 <mudge> wli: there's an amazon.com in porland
20:45:44 <wli> mudge: ???
20:45:47 <FMota> lol.
20:46:02 * wli ponders diff(1).
20:46:40 <mudge> its a pretty good book,  I like how it makes you understand the basic functions,  like foldr, filter, and lots of others
20:46:54 <wli> Oh dear. That's not where I need help at all.
20:47:02 <wli> Moving on, diff(1).
20:47:10 <mudge> wli:  I just mean that you can get the book at amazon.com,  but you probably want to look through it and check it out before you buy
20:47:23 <wli> mudge: I'll buy it anyway.
20:47:47 <int-e> Hmm, that proof of Kleene's theorem looks like a perfect match for Data.Graph.Inductive.
20:47:48 <mudge> it has a chapter on functional parsers
20:48:00 <dhpeterson> mudge: how does it compare with other books (if you know)? I'm working through Thomson's Haskell now, for example
20:48:04 <wli> mudge: It's just that my shopping list on amazon.com is up to $2500+ and I'm feeling skittish about it.
20:48:14 <mudge> haha
20:48:19 <mwc> wishlist man ;)
20:48:27 <monochrom> haha
20:48:45 <zmike> Programming Haskell is probably pretty slow for somebody who is not a total noob
20:48:51 <mudge> dhpeterson: I haven't tried reading Thomson's Haskell book,  but I have that book and plan on reading that one too,   how is that book?
20:48:57 <zmike> It's just right for me though
20:49:04 <dhpeterson> zmike: as a noob (to FP anyway) it suits me :)
20:49:06 <wli> zmike: I'm hoping for something targeted for those who aren't total n00b's or whatever.
20:49:19 <mwc> I learned haskell several years ago from YAHT, and consulting the report when my code broke
20:49:23 <dhpeterson> i find Thomson ok
20:49:31 <mwc> wli: have you tried YAHT?
20:49:36 <dhpeterson> YAHT is also useful
20:49:36 <zmike> dhpeterson: In that case, I highly recommend it
20:49:39 <wli> Possibly even someone who has recently had their monad breakthrough.
20:49:41 <dhpeterson> great
20:49:59 <zmike> I'm trying to set myself up for a monad breakthrough
20:50:00 <wli> mwc: I worked through all the exercises in YAHT. I had my monad breakthrough with it.
20:50:14 <mwc> Everybody always remembers their monad breakthrough
20:50:17 <dhpeterson> i'm still waiting for the moment monads make complete sense for me :)
20:50:21 <zmike> Mostly using "All about Monads"
20:50:22 <dhpeterson> though i am getting used to them
20:50:45 <wli> I found that I wasn't really able to understand monads until I used them in monad transformers.
20:51:00 <wli> Where "use" meant actually programming monad transformer code.
20:51:03 <dhpeterson> wli: heh .. that's one of the things i'm reading up on now ;)
20:51:22 <zmike> I want to read and understand Wadler's paper but I think it's still a bit out of my reach
20:51:27 * dhpeterson rubs hands in anticipation of monad breakthrough
20:51:29 <zmike> I tried starting there....
20:51:31 * oerjan realizes he doesn't remember his monad breakthrough.
20:51:34 <zmike> didn't work out
20:51:52 <monochrom> My monad breakthrough came from Wadler's.
20:52:36 <mudge> wow, is the monad breakthrough like losing your functional virginity?
20:52:42 <monochrom> Actually not entirely. Half from that, the other half from that monadic parser paper.
20:52:57 <mwc> mudge: sort of
20:52:59 <dhpeterson> hah
20:53:03 <sfultong> wli: do you use monad transformers frequently in your code?
20:53:12 <monochrom> It's losing your imperative virginity.
20:53:20 <dhpeterson> wli: are monad transformers the things like ReaderT etc?
20:53:27 <mwc> the monad breakthrough, for me, was being able to recognize monadic structure in my code, and write monads
20:53:33 <mwc> dhpeterson: indeed
20:53:43 <mwc> a monad transformer is basically just a way of embedding a monad inside another
20:53:56 <dhpeterson> i gathered that (from looking at dons irc bot tute code)
20:53:59 <wli> dhpeterson: Yes.
20:54:15 <dhpeterson> have been playing with that ... nothing like the deep end, eh :)
20:54:41 <wli> monochrom: The presentation didn't matter so much as doing exercises.
20:54:56 <wli> sfultong: I do now! ;)
20:55:07 <monochrom> Of course. I did my own tinkering while reading.
20:55:39 <wli> monochrom: I wasn't able to come up with adequate exercises on my own.
20:56:23 * dhpeterson lunch ... brb
20:56:25 <sfultong> for some reason it doesn't seem to me that monads will abbreviate/simplify the code I write... I dunno if this is due to my lack of understanding, or...
20:56:59 <ddarius> sfultong: You use them when appropriate.
20:57:23 <sfultong> well, I hardly ever use them
20:57:42 <wli> I mostly just consider them the libs and/or API's for obtaining various sorts of effects.
20:58:05 <mwc> sfultong: ever find yourself writing a family of functions where you thread values through a function call? That's a Reader/State pattern
20:58:35 <monochrom> To use Oleg's generic zipper requires knowing how to use a monad.
20:58:36 <mwc> sfultong: find yourself creating data at each step of a bunch of computations? Perhaps Writer is what you want
20:58:53 <mwc> and I'd argue that Cont is vastly easier to read than "true" CPS
20:59:10 <sfultong> hmm...
20:59:45 <monochrom> To know how Oleg's generic zipper works requires knowing the delimited continuation monad.
20:59:46 <wli> There isn't really a formula per se. I just rigidly adhere to existing API's instead of rolling my own.
21:00:01 <mwc> sfultong: for instance, if you ever use System.Random, you'll almost certainly have types like: RandomGen g => ... -> State g a
21:00:04 <monochrom> This generic zipper stuff is very powerful.
21:00:05 <mwc> @hoogle RandomGen
21:00:06 <lambdabot> System.Random.RandomGen :: class RandomGen g
21:00:48 <wli> MonadState + record update syntax is very handy.
21:01:04 <mwc> wli: truly
21:01:38 <wli> do { x <- gets field ; ... ; modify (\st -> st { field = f x }) ; ... }
21:01:52 <monochrom> Monad theory is abstract common sense.
21:02:24 <jcreigh> I don't like how getters are first class, but setters aren't.
21:03:01 <monochrom> Forgive me. How are setters not first-class?
21:03:25 <jcreigh> well, a getter is a function with a type, and I can pass it around. But I have to use that syntax to update a record.
21:05:06 <monochrom> Oh! Now I see.
21:05:33 <steven_ashley> jcreigh: that has also annoyed me on a number of occasions
21:07:13 <steven_ashley> in saying that, its very easy to roll your own setters
21:08:52 <dolio> Well, it's easy to roll your own accessors, too, but we have syntax for making them automatically. :)
21:18:46 <monochrom> Last time I was thrilled to get emacs haskell-mode to offer me 7 indentation choices. Today it turns out that was nothing - I get 10 now. :)
21:20:53 <dons> that does sound rather thrilling
21:21:48 <monochrom> The context is merely 8 lines, the longest line just 42 characters long. :)
21:22:30 * monochrom goes prove a theorem about Haskell layout indentations choices growing super-exponentially wrt context size.
21:23:04 <monochrom> Afterall, if it's undecidable, it ought to grow faster than any primitive recursive functions...
21:25:52 <FMota> *coughcough* A rather large question for #haskell : http://odi-sei-a.blogspot.com/2007/08/values-that-are-simply-begging-question.html
21:25:55 <lambdabot> Title: odiseia: Values that are simply begging the question., http://tinyurl.com/2xkgog
21:26:32 * sorear ponders the operational semantics of Concurrent Befunge
21:26:49 <FMota> ... sorear, you scare me sometimes.
21:30:27 <wli> Why anyone would prefer to investigate that vs. comprehension intrinsics in ghc, yhc, et al is beyond me.
21:30:37 <FMota> :p
21:30:46 <jcreigh> some people juggle geese. :)
21:31:45 <monochrom> How do I put it, without spending too much time explaining something well-known? How about this: if you know "induction vs co-induction", "inductively defined data vs co-inductively defined data", "least fixed point vs greatest fixed point", etc., you know the answer to odiseia's question, and you see there is no begging the question anywhere.
21:32:56 <FMota> right
21:33:12 <FMota> unless you happen to be using inf.
21:33:41 <FMota> I saw that once, and I should probably check it again.
21:33:50 <monochrom> Here is how that relates to the question. Finite lists are inductively defined data. Infinite lists are co-inductively defined data. Mathematically you're supposed to treat them separately. Pragmatically many lazy programming languages (e.g. Haskell) use the same type for both, so there is a bit of confusion. Already someone is suggesting to add the keyword "codata" to Haskell for declaration your intention more clearly.
21:34:19 <glguy> seen in #ubuntu: 21:21 < imbecile> hey all, I was wondering if there were any apps or anything that checks pucntuation.. I'm emailing this girl & I dont want alot of errors
21:34:22 <monochrom> inf is also coinductively defined data, exactly isomorphic to infinite "List ()".
21:34:32 <FMota> :) thank you.
21:34:40 <sorear> aieee!
21:37:23 <FMota> So, I have to treat inductive and co-inductive types differently
21:37:37 <monochrom> Yes, in fact with quite opposite attitudes.
21:37:48 <FMota> now... how do I find something good on induction and coinduction? :/ I wish I could find the exact same thing as I read one.
21:38:37 <wli> What sort of type attribute would you use for this?
21:38:47 <dolio> Girls care about punctuation these days?
21:38:54 <monochrom> inductive data = least fixed point of a certain equation. you ask for the smallest set of values satisfying some set equation. therefore, when in doubt, you reject.
21:39:08 <wli> Two different type recursion operators, \mu and \mu'?
21:39:21 <FMota> ah, I see.
21:39:27 <monochrom> co-inductive data = greatest fixed point of a certain equation. you ask for the largest set possible. therefore, when in doubt, you actually accept!
21:39:29 <dolio> mu and nu.
21:39:40 <wli> \nu works, too.
21:39:42 <LoganCapaldo> Sounds like cat noises
21:39:45 <FMota> lol.
21:40:00 <FMota> sounds like Sir Bedeviere (sp)
21:40:26 <FMota> monochrom, ty so much.
21:40:37 <monochrom> About reading material. I only know those that are mathematically dense, i.e., highly academic. Not sure if you mind reading them. But I'll cite on in a moment.
21:41:14 <mwc> dolio: totally unrelated, but chances are that if you see an exclamation point, a woman wrote it
21:41:31 <monochrom> http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf  Bart Jacobs and Jan Rutten "A Tutorial on (Co)Algebras and (Co)Induction"
21:41:34 <LoganCapaldo> what, like statiscally speaking?
21:41:37 <dolio> Is SamB a woman?
21:42:00 <bos> mwc: actually, i think you mean a confused haskell programmer trying to eliminate stack overflows
21:42:02 <FMota> ty
21:42:23 * LoganCapaldo does the drum thing for bos
21:42:55 <bos> thank you, i'll be here all week, don't forget to tip lambdabot on your way off the channel
21:43:18 <mwc> bos: that too, but there's real research showing men don't use !
21:43:19 <mwc> http://jcmc.indiana.edu/vol11/issue4/waseleski.html\
21:43:25 <mwc> minus the \
21:44:04 <LoganCapaldo> Oh in computer-mediated communication
21:44:14 <LoganCapaldo> more specific than I ws expecting
21:47:13 <LoganCapaldo> Theres not nearly enough notation in that paper
21:47:43 <LoganCapaldo> I kept expecting to see funny symbols and code snippets that used arrows instead of equal signs for assignment
21:48:07 <LoganCapaldo> but there were no code snippets at all
21:48:22 <LoganCapaldo> And I don't think I saw the word proof once
21:49:23 <wli> I like it when they say "by induction on the structure of proofs."
21:50:08 <bos> bart jacobs is my homie, by induction on the structure of his bibliography
21:50:29 <LoganCapaldo> LOL
21:50:51 <LoganCapaldo> oh man
21:51:04 <LoganCapaldo> thats definitely a new tool to add to my arsenal
21:51:17 <LoganCapaldo> night crazy cats
21:51:20 * LoganCapaldo tips lb
21:51:22 <LoganCapaldo> @botsnack
21:51:23 <lambdabot> :)
21:56:38 <FMota> Ah, here's what I read before -- http://sigfpe.blogspot.com/2007/07/data-and-codata.html
21:56:40 <lambdabot> Title: A Neighborhood of Infinity: Data and Codata
21:57:06 <FMota> idk if that's the same concept, but does fit the problem domain.
21:57:09 <wli> Well, I'm just thinking about diff for the moment.
21:58:43 <wli> I think you can make it polymorphic, basically Eq t => [t] -> [t] -> [([t],([t],[t]),[t])] or some such.
21:58:49 <FMota> it's structural recursion and guarded recursion to the rescue.
21:58:59 <glguy> does anyone have a favorite live CD distro that specializes in bleeding edge versions of packages? I'd like to see how the latest X11 and intel video drives work on this laptop
21:59:33 <wli> data Hunk t = Hunk { leftContext, rightContext, beforeText, afterText :: [t] }
22:00:50 <monochrom> FMota: yes that one is relevant.
22:01:01 <FMota> mmhmm
22:01:07 <wli> From there it's some kind of combinatorial minimization problem.
22:02:11 <wli> Eq t => [t] -> [t] -> [Hunk t]
22:03:13 <wli> hunkNorm h = length (beforeText h) + length (afterText h) ; patchNorm = maximum . map hunkNorm
22:04:47 <monochrom> I'm totally evil. I write "return $ do ..." followed by 8 lines of monadic code.
22:04:59 <wli> (There are position markers to track here but I'm ignoring that for the moment.
22:05:06 <monochrom> (I'm returning a monadic action, yes.)
22:05:26 <steven_ashley> monochrom: thats evil :S?
22:05:29 <FMota> :o
22:05:44 <wli> liftIO $ do + umpteen lines of monadic action is common I think.
22:06:32 <Heffalump> nesting monads with return is less common, though
22:06:39 <wli> yeah
22:06:53 <FMota> hmm
22:06:55 <monochrom> I've done that too. Inside IO I use the list monad, for example.
22:07:02 <FMota> you can't mix data with codata, can you?
22:07:23 <monochrom> Some functions are friendly to both data and codata, e.g., map.
22:07:24 <wli> I think it's possible to subdivide hunks whenever beforeText and afterText have elements in common.
22:07:50 <FMota> map works on codata, though...
22:08:08 <monochrom> Yeah, it works on both.
22:08:21 <FMota> oh, nvm. I get it :0
22:08:35 <monochrom> sigfpe's sumSoFar also works for both.
22:08:35 <FMota> :) ty
22:08:43 <FMota> yep
22:09:23 <monochrom> It seems that if a function works on codata and it also has a good clause for [], it will work for data too.
22:09:42 <FMota> while sum only works on data, because it's structural recursion
22:09:46 <monochrom> Yeah.
22:09:49 <FMota> yeah. that makes sense :)
22:10:09 <FMota> So how would one go about separating data from codata... hmm
22:10:23 <FMota> separate types would work, but map can work well on both.
22:11:37 <monochrom> Here is one way. Separate types. But have a type class for both. map becomes generic to that type class.
22:11:49 <desp> is there an easy way to get a stacktrace from my program, which aborts with an exception?
22:11:57 <FMota> Ah, makes sense.
22:12:10 <FMota> :) Gosh, you're good at this.
22:12:26 <monochrom> I'm only a bit more experienced. :)
22:12:43 <FMota> and humble. :o
22:14:11 <FMota> so, there's two types of "add", really. One that only works on data, and one that works on both.
22:16:10 <desp> ah, -xc
22:18:41 <FMota> Lessons in perfectly cromulent syntax: Nat. for data, Nat.. for codata, Nat for both.
22:19:42 <monochrom> hahaha
22:19:53 <FMota> ;)
22:20:01 <monochrom> Only a computer will find it perfectly clear. :)
22:20:20 <FMota> yeah :/
22:20:49 <steven_ashley> Could someone please help me with a type definition? I have a function that takes a bool and returns some instance of a Class. I can't figure out what the type should be. I currently have "transform :: (Class a) => Bool -> a". The error is "could not match expected `a' against inferred `ThingA'".
22:22:23 <steven_ashley> code is here -> http://hpaste.org/2477
22:24:37 <FMota> Actually, I'm not so sure that only a computer would find it perfectly clear.
22:24:51 <FMota> On second though, List. Nat, looks weird.
22:24:58 <coffeemug> ?src take
22:24:59 <lambdabot> take n _      | n <= 0 =  []
22:24:59 <lambdabot> take _ []              =  []
22:24:59 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:27:09 <sieni> ?src drop
22:27:09 <lambdabot> drop n xs     | n <= 0 =  xs
22:27:09 <lambdabot> drop _ []              =  []
22:27:09 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
22:27:44 <FMota> how bout Nat is for both, coNat is for Nat codata, and _Nat is for Nat data? :o
22:27:50 <coffeemug> whooo hoooo
22:27:53 <coffeemug> !!!!!
22:27:58 <coffeemug> I got infinite lists in CL!!
22:27:59 <coffeemug> :)
22:28:13 <coffeemug> that might not be too big of a deal for a Haskell channel though
22:28:16 <FMota> :o Happy for you :)
22:28:23 <coffeemug> considering infinite lists come out of the box :)
22:28:38 <coffeemug> (take 3 (integers)) => #A[0 1 2]
22:28:40 <coffeemug> :-D
22:29:32 <glguy> steven_ashley: did you find your answer?
22:29:41 <steven_ashley> not yet
22:30:14 <glguy> in the type: Class a => Bool -> a
22:30:17 <glguy> you have to pick one a
22:30:51 <glguy> if you want to return many, you need an existential qualifier
22:30:55 <glguy> which probably isn't what you wanted
22:30:59 <glguy> (but it might be)
22:31:40 <steven_ashley> I want to return different members of the same class from a function depending on whats input
22:32:02 <steven_ashley> I need an existential qualifier then :)
22:32:25 <monochrom> coffeemug: how did you implement it? lots of manual thunking?
22:33:19 <coffeemug> I implemented a system that lets you define algebraic types
22:33:27 <coffeemug> the only way to define a type is to call a constructor on it
22:33:33 <coffeemug> and the only way to get values is to pattern match
22:33:49 <coffeemug> so the constructors automatically wrap arguments in closures
22:34:08 <coffeemug> and successful matches funcall the closures to unwrap
22:34:14 <coffeemug> which pretty much gives you lazyness
22:34:27 <coffeemug> once you get that, it becomes trivial
22:34:32 <monochrom> Yes. Nice.
22:34:34 <coffeemug> code looks very similar to Haskell, actually
22:36:55 <FMota> monochrom, do you think a compiler could be able to infer data vs codata?
22:37:27 <FMota> I'm thinking yes.
22:37:59 <coffeemug> ?src zipWith
22:37:59 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
22:38:00 <lambdabot> zipWith _ _      _      = []
22:38:19 <monochrom> I'm divided. On one hand, sigfpe's criterion seems to be perfectly algorithmic, so yes. On the other hand, it looks like strictness analysis, which is undecidable, so no.
22:38:44 <monochrom> But perhaps it's a special case of strictness analysis, special enough to be do-able.
22:39:02 <FMota> hmm
22:39:27 <monochrom> But it doesn't hurt to be optimistic. :)
22:39:46 <FMota> :)
22:42:00 <FMota> inferring data vs. codata would 'eliminate' the problem of data being sent to singularly corecursive functions, and  codata being sent to singularly recursive functions. (Sorry for the abuse of language).
22:44:06 <monochrom> On other news, I have finished doing "generators" (a la Python for example) using delimited continuations and ref cells.
22:44:34 <FMota> wd
22:44:43 <FMota> hmm. its getting late
22:44:46 <FMota> nighty night
22:44:53 <monochrom> good night
22:45:12 <FMotAFK> and thanks for all the fish :)
22:45:14 <wli> monochrom: Cooking up your own language or implementation thereof?
22:45:19 <monochrom> you're welcome
22:46:33 <monochrom> I use the well-packaged CC-delcont. On top of that, I write my own code.
22:46:53 <wli> monochrom: Not sure what you mean.
22:47:21 <monochrom> CC-delcont is a library providing delimited continuations (in a monad) for Haskell.
22:47:46 <wli> Okay, so not related to a specific app (e.g. interpreter/compiler).
22:47:53 <monochrom> No.
22:56:53 <wli> Looks like it's heavily related to longest-common subsequence.
22:57:38 <dcoutts> pgavin: new patch sounds good! :-)
23:02:16 <newsham> when people use Happy to generator parsers what lexer generator do they typically use?
23:02:29 <wli> Probably either handwritten or alex.
23:02:46 <newsham> danke
23:03:16 <monochrom> Sometimes I use Text.ParserCombinators.Parsec.Token
23:03:35 <newsham> *nod*
23:03:42 <monochrom> Oh, nevermind, I misread.
23:03:48 <newsham> trying to write one using parsec and one using a generator
23:04:13 <monochrom> I have never used Happy. Don't trust me. :)
23:04:39 <newsham> the blind leading the dumb? :)
23:05:07 <bos> http://programming.reddit.com/goto?id=2jcvz
23:05:09 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » Weighted Slope One in Haskell: colla ...
23:10:03 <newsham> are there any GLR scannerless parser generators for haskell?
23:10:32 <newsham> (ie. one where there are no tokens and the whole language is specified in a single spec?)
23:12:33 <monochrom> It would be pretty nasty for most cases.
23:13:28 <monochrom> More often one would use Text.ParserCombinators.Parsec.Token, which sits somewhere between scannerless and scannerful.
23:13:46 <newsham> why nasty for most cases?
23:14:26 <monochrom> It's very annoying to remember to manually code "now eat some whitespace" all over the place.
23:14:38 <glguy> yum
23:14:52 <glguy> ?all-dicts hypozeuxis
23:14:53 <lambdabot> *** "hypozeuxis" wn "WordNet (r) 2.0"
23:14:53 <lambdabot> hypozeuxis
23:14:53 <lambdabot>      n : use of a series of parallel clauses (as in `I came, I saw, I
23:14:53 <lambdabot>          conquered')
23:14:53 <newsham> scannerless generators usually have some notation for that
23:15:17 <monochrom> The annoyance gets worse as you also say "1+2" is the same as "1 + 2".
23:15:43 <monochrom> But then again, you probably mean exactly something like Text.ParserCombinators.Parsec.Token.
23:15:44 <newsham> nah, pretty easy to deal with.
23:16:36 <dhpeterson> hi ... anyone here know about "newtype" ?
23:16:43 <newsham> except parsec is hand-written and uses recursive descent and backtracking
23:16:46 <dhpeterson> is there any real advantage of using this rather than "data" ?
23:17:03 <sjanssen> dhpeterson: newtype is handy because it has no runtime overhead
23:17:18 <dhpeterson> is it optimised out or something?
23:17:38 <sjanssen> yes, it has slightly different semantics, so it doesn't exist at runtime
23:17:42 <dhpeterson> ok
23:18:01 <dhpeterson> do i understand correctly that it can only be used with a single 1-arg constructor?
23:18:10 <sjanssen> correct
23:18:14 <dhpeterson> ok
23:18:33 <dhpeterson> i am playing with a Haskell wikibook example now ... data Anniversary = Birthday Name Date | Wedding Name Name Date
23:18:41 <dhpeterson> so i can't use newtype here for example
23:18:54 <sjanssen> right, you have to use data
23:18:59 <dhpeterson> but if I had: data SpecialDay = SpecialDay Date
23:19:01 <monochrom> Right. newtype isn't intended for that.
23:19:10 <dhpeterson> then i could write: newtype SpecialDay = SpecialDay Date
23:19:17 <sjanssen> dhpeterson: correct again
23:19:19 <dhpeterson> k
23:19:21 <dhpeterson> thnx
23:19:24 <newsham> newtype is when you want a new name for a type so you can make functions that behave differently for that type
23:19:24 <dhpeterson> (from the newb!)
23:19:40 <dhpeterson> newsham: aha
23:19:41 <newsham> like when you want some String with a different Show instance
23:19:52 <dhpeterson> ok
23:20:04 <dhpeterson> so used to discriminate, as well as for efficiency
23:20:15 <newsham> newtype Euro = Euro Int      ?
23:20:20 <sjanssen> right.  It gives you extra type safety with no overhead
23:20:23 <dhpeterson> k
23:20:26 <monochrom> It also solves or works around the infinite-type problem. (Warning: Information overload.)
23:20:36 <dhpeterson> monochrom: heh - yep!
23:20:42 <dhpeterson> i won't ask :)
23:20:58 <sjanssen> in xmonad, we have a structure indexed by both workspace and screen ids -- which were both Ints
23:21:14 * dhpeterson bows down before the haskell old-ies (opp. of newbies)
23:21:21 <dhpeterson> aha
23:21:24 <sjanssen> we had a bug where we used a screen id instead of a workspace id
23:21:28 <monochrom> OK, "data" also solves that, conceptually almost the same actually, but with overhead.
23:21:39 <sjanssen> the solution: newtype Workspace = Workspace Int; newtype Screen = Screen Int
23:21:40 <dhpeterson> right
23:21:51 <dhpeterson> yep
23:22:04 <sjanssen> now we *can't* mix up two types of ids, and the compiler still generates the same code
23:22:06 <dhpeterson> and because you were working with functions that took [Int] you weren't able to discriminate it
23:22:11 <dhpeterson> until you introduce the types
23:22:16 <dhpeterson> i see
23:22:22 <dhpeterson> yep
23:22:31 * monochrom hugs newtype
23:22:44 <dhpeterson> sjanssen: thank you for the clear example - it always makes it easier to understand when you have an example
23:23:04 <mudge> hey, anyone in here from around the bay area?
23:23:05 <dhpeterson> i guess if you have a strong typed language you should use it, eh :)
23:23:16 <monochrom> Yah!
23:23:26 <dhpeterson> mudge: only the Melbourne bay :(
23:23:39 <mudge> monochrom: you are?
23:23:49 <newsham> mudge: you're not peiter are you?
23:23:52 <monochrom> No. I was Yah-ing to the strong typing comment.
23:24:05 <dhpeterson> ha
23:24:15 <mudge> ah
23:24:35 <newsham> i've lived in the bay area but i'm not from there or currently there
23:25:21 <mudge> okay, well if you have any bay area  functional programming friends tell them about the bay area functional programming meeting in September
23:25:33 <newsham> mudge: already done :)
23:25:39 <mudge> http://groups.google.com/group/bayfp/
23:25:40 <lambdabot> Title: Bay Area Functional Programmers | Google Groups
23:25:51 <dhpeterson> heh - i want to organise something similar in Melbourne, AU
23:25:51 <mudge> newsham: you going?
23:26:01 <newsham> no.  but I told some ba'ers
23:26:04 <Japsu> yeah, we need one in Hervanta, Finland too :)
23:27:02 <mudge> newsham, okay, thanks
23:27:55 <dons> ?users
23:27:56 <lambdabot> Maximum users seen in #haskell: 392, currently: 347 (88.5%), active: 13 (3.7%)
23:29:31 <steven_ashley> Interpreter.hs:60:8:
23:29:31 <steven_ashley>     My brain just exploded. :(
23:29:37 <steven_ashley> nice error :D
23:29:50 <sorear> @quote exploded
23:29:50 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
23:29:52 <sorear> @quote exploded
23:29:52 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
23:29:55 <sorear> @quote ghc exploded
23:29:56 <lambdabot> ghc says: My brain just exploded.
23:34:44 <dhpeterson> ?seen pseudonym
23:34:45 <lambdabot> I saw pseudonym leaving #haskell-blah and #haskell 17m 9s ago, and .
23:35:13 <jedahu> Anyone know what module respIO hides in?
23:35:25 <jedahu> Came across it in a HAppS tutorial.
23:35:58 <dons> sounds like some happs-ish thing
23:36:01 <dons> try grep :)
23:36:31 <jedahu> already have :(
23:36:49 <monochrom> Not in base or GHC extralibs
23:37:48 <dons> find . -name '*.hs' -exec grep -hl respIO {} \;  --- ?
23:39:15 <jedahu> grep -Ri respio *  --> nada
23:40:30 <adu> hi
23:41:26 <wli> Looks like naive lcs is too slow to produce results in a useful amount of time.
23:42:22 <sorear> hello adu
23:49:50 <mudge> wow, you guys know about the book "Real World Haskell" that is being written?
23:55:01 <bos> mudge: yeah, i've heard about it
23:56:13 <mudge> bos: cool
23:56:28 <dons> sounds cool!
23:57:04 <bos> :-)
23:58:38 <mudge> hey dons!
23:58:48 <dons> :)
23:59:00 <mudge> dons: I didn't know you were writing a book on haskell
23:59:24 <mudge> dons: are you going to come to the functional programming meeting in san francisco?
