00:03:17 <sjanssen> dons: "90000 100" and "100 90000" are the two largest inputs the original article tests
00:11:52 <RyanT5000> is there any way to statically prevent someone from doing (alloca return)?
00:12:05 <RyanT5000> @type (alloca return)
00:12:08 <lambdabot> Not in scope: `alloca'
00:12:28 <dons> with the ST monad?
00:12:29 <RyanT5000> @type (Foreign.Marshal.Alloc.alloca return)
00:12:31 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
00:12:41 <dons> you want a type variable that can't escape the encapsulating context
00:13:00 <RyanT5000> dons: that sounds about right; so just kind of copy what ST does?
00:13:20 <RyanT5000> (i'm writing a function similar to alloca right now)
00:16:09 <sorear> @google oleg regions ST
00:16:11 <lambdabot> http://www.rferl.org/specials/russianelection/archives/single.asp
00:16:12 <lambdabot> Title: russian election
00:16:28 <kolmodin> :D
00:16:39 <sorear> oleg will be the president of russia?
00:16:45 <sorear> :)
00:17:03 <sorear> @google oleg region allocation monad st
00:17:06 <lambdabot> http://www.haskell.org/haskellwiki/Monad
00:17:06 <lambdabot> Title: Monad - HaskellWiki
00:18:29 <sorear> Huh. "Things are quietening down. The (epidemic) will vanish in 10-15 days," Oleg Kiselyov, head of a research institute operating under the WHO's auspices, told reporters in Russia's second city of S...
00:18:38 * sorear wonders if it's the same guy
00:19:00 <arcatan> a polymath?
00:19:08 <RyanT5000> what's the deal with finalizers on ForeignPtrs?
00:19:16 <RyanT5000> are they evil/to be avoided?
00:19:26 <sorear> http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
00:19:27 <lambdabot> http://tinyurl.com/35c9nz
00:19:42 <sorear> RyanT5000: No, they are evil and to be used whenever necessary.
00:19:53 <RyanT5000> sorear: lol alright
00:20:23 <sorear> RyanT5000: they're the only reliable way to make sure foreign memory (structure pointers etc) is freed when the Haskell-side object is collected
00:20:44 <sorear> RyanT5000: anyway, that paper probably has what you want...
00:21:33 <nong> i want to upload hugs binaries but i dont have root can i get hugs to look in a directory other than /lib?
00:21:35 <RyanT5000> sorear: thanks
00:22:03 <dons> nong: hmm. perhaps it would be easier to upload ghc-compiled executables?
00:22:04 <sorear> nong: huh?  Hugs doesn't make binaries, and uploading never requires root.
00:23:58 <glguy> maybe "hugs binaries" means "the binary for hugs"
00:24:06 <glguy> instead of "binaries generated by hugs"
00:24:45 <sorear> ah
00:24:55 <sorear> and maybe by uploading he means installing
00:25:36 <nong> sorear: it does to the lib directory
00:26:16 <sorear> nong: Have you tried setting the prefix?
00:26:45 <nong> that would require compilation
00:27:35 <nong> the server doesnt have gcc
00:28:29 <sorear> You could recompile it locally?
00:28:38 <sorear> or is the architecture different?
00:31:09 <nong> linux question: how do you redirect standard error again?
00:31:19 <rehges> 2>
00:32:13 <Pseudonym> Depends on the shell.
00:32:15 <Pseudonym> 2> in bash
00:33:39 <rehges> sure, 2> in any posix shell
00:35:51 <nong> 3xthanks
00:37:49 <nong> #haskellers seem to be the nicest on freenode
00:40:45 <dons> nong: we try :)
00:50:26 <desp> [a * b | a <- [100..999], b <- [100..999]]
00:50:32 <desp> is it possible to write this more concisely?
00:52:19 <glguy> desp: you've asked about this before
00:52:25 <desp> nope.
00:52:37 <glguy> is this for project eule
00:52:38 <glguy> r
00:52:48 <desp> yeah, perhaps someone else was also doing this
00:52:49 <glguy> where you are tasked to find the number of unique multiples?
00:53:06 <desp> I've just started project euler a few minutes ago, and I already have 4 done :)
00:53:10 <glguy> try: [a * b | a <- [100..999], b <- [a..999]]
00:53:23 <glguy> so you don't bother repeating things
00:53:31 <desp> hm, right.
00:53:48 <desp> that's not my question, though ;)
00:53:57 <desp> I was hoping for "a, b <- [foo]"
00:54:17 <glguy> > length $ join (liftM2 (*)) [100..999]
00:54:19 <lambdabot>  810000
00:55:02 <glguy> desp: link?
00:55:12 <desp> projecteuler.net
00:55:18 <glguy> no, to that problem
00:55:21 <Cale> map product . replicateM 2 $ [100..999]
00:55:22 <Cale> > map product . replicateM 2 $ [100..999]
00:55:23 <lambdabot>  [10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,112...
00:55:28 <desp> http://projecteuler.net/index.php?section=problems&id=4
00:55:29 <lambdabot> Title: Project Euler
00:56:41 <desp> I'm on the next one now.
00:57:05 <desp> this could make for a nice showing off of Haskell
00:57:08 <glguy> > foldl1 gcd [2..20]
00:57:09 <lambdabot>  1
00:57:14 <glguy> > foldl1 lcm [2..20]
00:57:15 <lambdabot>  232792560
00:57:54 <desp> > foldl1 lcm [2.10]
00:57:54 <lambdabot>  Add a type signature
00:57:57 <desp> > foldl1 lcm [2..10]
00:57:58 <lambdabot>  2520
00:58:06 <desp> hah.
00:58:22 <desp> glguy: spoiler. ;p
00:58:35 <glguy> desp: that's more of an example than a "math problem"
00:59:10 <Cale> > product [3..7]
00:59:12 <lambdabot>  2520
00:59:17 <glguy> I have them solved up to #128 and a few assorted ones afterwards, I haven't been keeping up though :-/
01:00:10 <rehges> good morning gymnastics, do some maths while waiting for the coffee to get ready
01:01:05 <dons> we really should have a spoiler/answers page for this stuff, glguy ?
01:01:17 <dons> rehges: yeah, i love little morning problems like that
01:01:22 <glguy> dons: we don't?
01:01:36 <dons> for project euler??
01:02:05 <glguy> hmm, maybe it was for those 100 abritrary problems
01:02:10 <glguy> and I just forgot
01:02:17 <dons> glguy: btw, did you see qwe's reply on reddit? to the effect that there's no implementation, show me the code ... and then he links to the ghc user guide page on the implementation and code..
01:02:19 <desp> "99 questions"? yes
01:02:35 <dons> yeah, it thought there was a rule agianst publishing euler solutions
01:03:11 <dons> glguy: so now we just sit and let qwe look stupid, more so. (i hope people don't reply to him)
01:05:33 <RyanT5000> is there a way to make IO (Maybe a) cleaner?
01:05:46 <RyanT5000> involving maybe monad transformers?
01:08:37 <nornagon> > sum . zipWith (+) $ [3,6..999] [5,10..999]
01:08:38 <lambdabot>  Couldn't match expected type `[a]'
01:08:51 <nornagon> drat.
01:09:15 <nornagon> > sum $ zipWith (+) [3,6..999] [5,10..999]
01:09:16 <lambdabot>  159200
01:10:13 <RyanT5000> so i'm making a binding for SpiderMonkey
01:10:20 <RyanT5000> which has a function that returns a pointer to a "runtime"
01:10:36 <RyanT5000> which is the whole state of a javascript VM
01:11:02 <RyanT5000> is it appropriate to use a finalizer on that? or should everything just be channeled through withRuntime or something similar
01:13:08 <sorear> RyanT5000: When the last reference to a runtime vanishes, do you want to let the runtime's memory leak?
01:13:20 <sorear> RyanT5000: If you don't want a memory leak, use a finalizer.
01:13:34 <sorear> RyanT5000: I'd like to know where you got the idea "don't use finalizers"
01:13:50 <RyanT5000> sorear: so would i, but i do distinctly have that idea
01:14:08 <sorear> RyanT5000: If your code is public, written in Haskell, and leaks memory, I guarantee you'll get flamed worse than if you use finalizers. :)
01:14:08 <RyanT5000> well, because finalization is nondeterministic
01:14:17 <RyanT5000> lol
01:14:26 <sorear> So is most everything else in IO.
01:14:33 <glguy> RyanT5000: which is rather ideal... the finalization can be put off until there is time or it is needed
01:14:38 <sorear> (Insert Simon's sin-bin comment)
01:14:47 <RyanT5000> well the choice was between finalizers and withRuntime being the only way of doing it
01:15:08 <sorear> Probably both is good.
01:15:13 <DRMacIver> "Don't use finalizers" is common folklore in a lot of languages.
01:15:24 <DRMacIver> Especially Java.
01:15:30 <sorear> withRuntime gives you guarantees.  finalizers give you flexibility.
01:15:34 <DRMacIver> So it's an easy meme to pick up, even for languages where it's not applicable. :)
01:15:58 <sorear> DRMacIver: Why would anyone add a feature to a language/RTS just to tell people not to use it?
01:16:17 <RyanT5000> sorear: that happens all the time in most languages :P
01:16:29 <DRMacIver> sorear: What RyanT5000 said. :)
01:16:33 <tjm1983> unsafePerformIO
01:16:53 <sorear> tjm1983: There are legitimate reasons to use that.
01:17:25 <RyanT5000> sorear: what's the deal with wrapping the finalizer? i'm not allowed to just chuck a haskell function in there?
01:17:28 <sorear> It solves a very specific problem (pure bindings to foreign code), well.
01:17:49 <RyanT5000> tjm1983, sorear: also, DiffArray and the like
01:18:01 <sorear> RyanT5000: Right; there are circularity problems if finalization is allowed to call Haskell code.
01:18:33 <sorear> RyanT5000: The theory is that since you're using the FFI anyway, a few more lines of C won't hurt much.
01:18:35 <RyanT5000> sorear: alright, well i guess i can't think of a time it'd need to be a haskell function anyway
01:19:25 <tjm1983> sorear: Fair enough; I don't really know about finalization in any language, so I don't know why or how universally it would be proscribed.
01:23:17 <Saizan> @get-shapr
01:23:17 <lambdabot> shapr!!
01:24:26 <glguy> dons: http://programming.reddit.com/info/2b9gc/comments/c2ba96
01:24:27 <lambdabot> Title: Haskell support for value semantics: unboxed values as first class citizens (red ...
01:25:28 <desp> hm
01:25:58 <desp> > data Foo f => Bar f
01:25:58 <lambdabot>  Parse error
01:26:04 <dons> glguy: :)
01:26:07 <dons> glguy: oh, typo `contradicting'
01:26:14 <desp> are typeclass constraints valid in datatype declarations?
01:26:37 <glguy> dons: I'm sure I don't know what you are talking about
01:26:39 <dons> glguy: but that's definitely a strategy: provide a link with not quite enough information -- just enough for him to take the bait
01:37:17 <Cale> desp: Yes, they are, but they probably don't mean what you want them to mean unless you're using GHC 6.7 and the GADT syntax.
01:37:30 <desp> ah
01:38:21 <Cale> In Haskell 98, they just restrict the type of the data constructor. They don't allow you to leave off the typeclass constraints from functions which use values of that type.
01:39:59 <glguy> which isn't *terrible* and makes for fewer surprises
01:40:12 <desp> right
01:40:15 <slava> with littledan's help, i've discovered the dynamic typing analogue of type classes
01:40:31 <glguy> implied interfaces?
01:40:39 <slava> its about implementation inheritance, actually
01:40:46 <slava> you define 'mixins', which are method suites
01:40:56 <slava> you can add methods to an existing mixin just like you define methods on a class
01:41:09 <slava> then, you define existing classes to be instances of these mixin classes
01:41:23 <slava> so you can add a method suite on an exising class, and add methods to existing method suites, in different source units
01:41:52 <Cale> The new thing to do with class constraints in data declarations is to store a pointer to the typeclass dictionary in the actual value, so that a function which pattern matches to get the value out will not need that additional typeclass constraint in its type.
01:42:05 <dons> right, so open method dictionaries. sounds like desugared type classes, without the typing
01:42:46 <slava> dons: i think being able to make a class inherit from a mixin 'post facto' gives an equal expressiveness boost as being able to define methods on integer, etc. i could never go back to message passing OOP now (dynamic or statically typed).
01:43:17 <slava> dons: i think typeclasses are The Right Thing when it comes to ad-hoc polymorphism too.
01:43:18 <dons> glguy: i think now we just downmod qwe, he's going nuts.
01:43:34 <dons> slava: yeah, the main thing is the `openness' -- that it can be extended after the fact
01:43:40 <slava> dons: yeah.
01:43:42 <slava> http://wee-url.com/responder/pastebin/show-paste?n=219
01:44:33 <glguy> dons: yeah, he definitely didn't like the responses he got
01:44:36 <Krinke> tcr
01:44:42 <slava> you guys are trolling qwe1234 on reddit?
01:44:46 <slava> why even bother? he's clearly a moron
01:44:49 <dons> glguy: you can tell he's upset when he posts the same thing 4 times in 1 minute
01:44:53 <dons> slava: yeah, just trolling :)
01:45:04 <glguy> slava: dons is baiting the troll
01:45:05 <slava> check out my new object system syntax :)
01:45:37 * dons tries to grok all the >>
01:45:41 <glguy> slava: and he caught him defeating himself, and now qwe is in some rampage mode to cover it up
01:45:47 <slava> dons: auto-generated words to read/write slots.
01:45:53 <dons> ah ok
01:46:16 <slava> red>> reads the red slot from an object, >>red writes it. but that's not important :)
01:46:34 <slava> CLASS: rectangle < shape  loc dim ; -- implementation inheritance, you inherit slots and methods
01:46:39 <tcr> Krinke: ?
01:46:40 <slava> INSTANCE: shape colored -- dynamic mixin inheritance
01:46:54 <slava> dons: this is all quite similar to type classes, minus the interfaces!
01:46:55 <DRMacIver> He's not entirely wrong. The primitive types for Haskell (well, GHC) are a little weak. :)
01:47:29 <dons> slave, yep, in fact, I'm not sure I've seen work comparing the operational semantics of type classes to mixins in say, scheme, but it sounds interesting
01:47:51 <dons> DRMacIver: sure, but you can program in non heap-allocating code if you want, and you've got the full set of primitives types you'd get in C
01:48:02 <dons> they have a different kind, of course
01:48:14 <dons> i wrote a miniml to uboxed Core compiler once, it was rather fast :)
01:48:22 <dons> good for non-allocating fibonaccis
01:48:32 <desp> will  foo b@(Bar x y) = b  be more efficient than  foo (Bar x y) = Bar x y  ?
01:48:34 <DRMacIver> dons: Mm. That's true I suppose. On the other hand, C is a little weak too. ;)
01:48:44 <dons> desp: probably, though ghc can probably spot that
01:48:59 <desp> dons: how can I verify that it indeed spots it?
01:49:13 <dons> desp, compile with -O2, and look at the core code produced by ghc -ddump-simpl | les
01:49:16 <Cale> --ddump-simpl
01:49:19 <Cale> er, yes
01:49:20 <desp> thanks
01:49:26 <Cale> just one -
01:49:29 <dons> Cale, I'm not sure I'd bother replying to qwe
01:49:37 <dons> its nice to just let him twist in the wind
01:49:45 <glguy> Cale: yeah, you'd have to do it 10 times
01:50:03 <Cale> Oh, I'm not going to reply to the blatantly stupid one.
01:50:43 <Cale> er, six :)
01:50:51 <RyanT5000> what does this mean? "Illegal foreign declaration: requires via-C or native code generation"
01:51:13 <RyanT5000> on "foreign import ccall "&JS_DestroyRuntime" p_JS_DestroyRuntime :: FunPtr (Ptr Runtime_ -> IO ())"
01:51:19 <Cale> RyanT5000: do you have -fffi ?
01:51:23 <dons> RyanT5000: you can't use &-style ffi things in ghci
01:51:29 <dons> the bytecode doesn't like them
01:51:35 <RyanT5000> dons: ah, ok thanks
01:51:49 <Cale> ah
01:51:54 <RyanT5000> Cale: -fffi is included in -fglasgow-exts, right?
01:52:15 <Cale> RyanT5000: hmm, good question. I'm not sure if it is or not.
01:52:29 <glguy> slava: why do your functions have parameters in { } braces?
01:52:40 <RyanT5000> dons: the parameter to the provided function can't escape, right? withRuntime :: Word32 -> (forall rt. CRuntime rt => rt -> IO b) -> IO (Maybe b)
01:52:53 <slava> glguy: because the { } is iterated over
01:52:57 <slava> glguy: its an array.
01:53:25 <RyanT5000> dons: (btw, why don't any of the other 'with' functions in haskell use stuff like that? they predate universal quantification support?)
01:53:31 <dons> RyanT5000: right, that's what you want to do.
01:53:44 <desp> ouch
01:53:47 <desp> I can't read this
01:53:48 <desp> :)
01:54:35 <RyanT5000> dons: wait, though; couldn't the internal function chuck the rt into an existential?
01:55:03 <dons> hmm, I think you'll have a hard time getting that to type
01:55:06 <glguy> slava: so the function "rectangle" is basically "each"
01:55:07 <glguy> ?
01:55:12 <desp> aha, NOINLINE helped
01:55:16 <slava> no, rectangle pushes rectangle on the stack :)
01:55:28 <slava> construct takes a list of setters and a class, and slurps in the values.
01:55:30 <glguy> ON
01:55:30 <glguy> of
01:55:34 <glguy> I see, construct then
01:55:42 <glguy> oh*
01:55:53 <slava> i could use a different naming convention for classes
01:56:04 <glguy> so,  : rectangle \ rectangle
01:56:05 <glguy> ?
01:56:10 <slava> yeah.
01:56:16 <RyanT5000> dons: maybe there isn't a way of properly doing this?
01:56:18 <slava> all classes are like that.
01:56:21 <glguy> ok
01:56:28 <glguy> or:   SYMBOL: rectangle?
01:56:33 <slava> yes, that's it actually.
01:56:47 <RyanT5000> dons: i mean, if you can *do* anything with the value, then you can certainly make a closure that knows how to do something with the value and return that
01:57:10 <glguy> slava: can the stack effect of <rectangle> be infered?
01:57:24 <desp> dons: with -O2 and NOINLINE, "foo1 f@(Foo a b c) = f" is one "case" shorter than "foo2 (Foo a b c) = Foo a b c"
01:57:50 <dons> desp++ cool, you're climbing the ladder of hackerdom :)
01:57:54 <slava> glguy: that would require a custom rule for construct (or rjust set-slots, really) because the number of inputs depends on the array's length
01:57:55 <desp> dons: hard to say if the inliner helps, since I can't recognize the code afterwards
01:58:11 <dons> yeah, you want to avoid the inline, to be able to spot the code later
01:58:20 <glguy> slava: I mostly meant in the current implementation
01:58:29 <desp> but would it possibly discover and eliminate the needless case?
01:58:33 <slava> glguy: the current one is a quick hack, so no
01:58:50 <slava> glguy: it took about an hour or so to cook up a new object system with inheritance and mixins
01:59:01 <slava> and the new slot access idioms
01:59:22 <glguy> slava: ah, I didn't realize it was so new
01:59:41 <glguy> factor makes a great case for OO as a library
02:00:42 <slava> i got a few features 'for free' by reusing code from the current OO system. eg, if you redefine a superclass by adding a new slot, then all existing instances in the heap are atomically updated.
02:05:06 <Saizan> RyanT5000: another solution is to have a custom monad wwhere you export only the primitives and don't ever give a reverence of rt to your user
02:05:19 <Saizan> *reference
02:05:46 <xerox> I think Saizan's actually quite good of a solution.
02:06:03 <xerox> That's how the Cairo bindings work, for one.
02:06:51 <Saizan> you may still need to go the ST way to assure that you never mix runtimes
02:06:52 <RyanT5000> Saizan: yeah, i suppose i could have a runIO in there
02:07:32 <RyanT5000> (i need, at least potentially, to be able to do IO while there's an active JS runtime)
02:07:42 <RyanT5000> btw would SpiderMonkey be useful to anyone else here?
02:08:00 <RyanT5000> if there's interest, i'll actually try to package this stuff semi-nicely and submit it
02:08:07 <RyanT5000> otherwise i'll do that "someday"
02:08:11 <Saizan> well you can transform IO, and make an instance of MonadIO for your monad
02:08:31 <dons> Cale, no need for ! on Int#
02:08:36 <RyanT5000> Saizan: yeah, that sounds like the best way of doing what i want to do
02:08:49 <Cale> yeah, I sort of figured :)
02:08:58 <dons> Cale, likely he's going to ask for a new type of unboxed kind to be defined, I suspect
02:09:45 <dons> I was pondering a chain of (# Addr# , a #) :)
02:21:25 <RyanT5000> so the header i'm importing from does some renaming
02:21:36 <RyanT5000> i.e.: #define JS_NewRuntime JS_Init
02:21:50 <RyanT5000> is there any robust way to handle this? (i'm using hsc2hs, btw)
02:24:13 <Saizan> is there a way to serialize functions?
02:25:00 <xerox> Saizan: maybe distributed Haskell does exactly that.
02:25:12 <Saizan> link?
02:26:00 <Saizan> ?google distributed haskell
02:26:03 <lambdabot> http://www.cse.unsw.edu.au/~chak/goffin/
02:26:03 <lambdabot> Title: Distributed Haskell
02:27:20 <RyanT5000> Saizan: serializing functions is pretty hard; most languages do it really stupidly (see, e.g., python)
02:27:37 <RyanT5000> Saizan: if you do happen across a language that does it (even slightly) well, let me know
02:28:41 <Saizan> python does it with bytecode?
02:29:01 <RyanT5000> no; python can only serialize top-level functions, and it just writes their name
02:29:16 <Saizan> ah, silly
02:29:24 <RyanT5000> especially if it's (1) typesafe (2) secure (against deserializing malicious functions; goes with (1)) (3) version-safe (4) works when the serializer and deserializer have different sets of libraries
02:29:55 <RyanT5000> (1) probably requires dependent types
02:30:33 <Igel> dons: do you have a minute?
02:30:59 <Saizan> 5) you can splice them back to source code ? :D
02:31:07 <Igel> it's about lambdabot
02:31:12 <dons> Igel: yeah?
02:31:17 <RyanT5000> Saizan: i thought that was kind of necessary to the definition of "serialize functions"
02:31:21 <Igel> you wrote it, didn't you?
02:31:31 <RyanT5000> otherwise you might as well just be serializing a file full of source :P
02:31:36 <dons> Igel: 90% of it
02:31:38 <Igel> just to be sure i'm not bothering you in vain ;)
02:31:39 <Igel> ok
02:31:47 <Igel> i was trying to compile it
02:31:55 <Igel> has it ever been compiled with ghc-6.6?
02:32:08 <dons> http://www.cse.unsw.edu.au/~dons/tmp/x.png :)
02:32:11 <Saizan> RyanT5000: you can create functions them dynamically
02:32:16 <Saizan> s/them//
02:32:18 <dons> yeah, the darcs version will run fine with ghc 6.6
02:32:26 <Igel> because i had to patch it
02:32:34 <dons> ?version
02:32:34 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
02:32:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:32:44 <dons> what did you have to patch?
02:32:47 <Igel> there were errorous imports in a file
02:33:04 <xerox> Hm, I thought I sent that patch to dons. Maybe I didn't.
02:33:09 <RyanT5000> Saizan: sorry? i don't quite understand what you're saying; although, yeah, i see how it would still be (kind of) powerful to be able to get source out of a function
02:33:13 <Saizan> hey, lambdabot patched herself!
02:33:23 <RyanT5000> breaks referential transparency like mad, though
02:33:40 <xerox> Igel: was it imports clashing with defined functions?
02:33:47 <Igel> xerox: no
02:34:00 <Igel> it was like "import foo hiding (bar)"
02:34:37 <Igel> and the compiler was complaining about bar not being defined in the module
02:35:06 <Igel> besides quite a bunch of dependencies in the .cabal file was missing or not applied to ghc-6.6
02:35:15 <Saizan> RyanT5000: i mean that getting readable source code from a serialized function is not what i need, i just need to be able to recover them after a restart in this case
02:35:30 <Igel> long story short: i have a patch, what shall i do with it? :)
02:36:22 <RyanT5000> Saizan: yeah
02:36:48 <RyanT5000> Saizan: i take it you can't use a core dump for what you're doing?
02:37:21 <RyanT5000> is there any way to exit from GHCi programmatically?
02:37:34 <RyanT5000> evaluating exitWith doesn't seem to do anything
02:37:59 <Igel> dons: it was in Lib.Parser ^^
02:38:17 <xerox> ?docs System.Exit
02:38:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
02:38:25 <RyanT5000> xerox: that's what i tried
02:38:33 <RyanT5000> xerox: GHCi just catches it as an exception :P
02:38:39 <xerox> yeah :-)
02:39:14 <Igel> and scripts/ShowQ provides an instance declaration of Arbitrary a => Arbitrary (Maybe a) which clashes with one provided in a recent quickcheck version
02:39:35 <desp> http://projecteuler.net/index.php?section=statistics
02:39:39 <desp> fascinating
02:39:39 <lambdabot> Title: Project Euler
02:39:53 <desp> C/C++, Python, Java, Haskell
02:40:15 <desp> although I guess the nature of the site is quite self-selecting
02:40:29 <dons> Igel: this was fixed yesterday
02:40:34 <dons> grab the latest patch
02:40:51 <Igel> and i thought my patch could help ;(
02:45:22 <tcr> Is there a function with type `[Maybe a] -> Maybe [a]'? (If one element in the list is Nothing, the result should be Nothing)
02:45:23 <kosmikus> desp: how are solutions checked at Euler? is any language allowed?
02:45:45 <desp> kosmikus: you enter the answer itself
02:45:48 <quicksilver> tcr: sequence
02:45:54 <desp> hence, Pen/Paper is allowed
02:45:55 <desp> ;)
02:46:04 <quicksilver> > sequence [Just 1, Just 8, Just 12]
02:46:06 <lambdabot>  Just [1,8,12]
02:46:15 <quicksilver> > sequence [Just 1, Just 8, Nothing, Just 12]
02:46:16 <lambdabot>  Nothing
02:46:42 <roconnor> sequence is the answer to all haskell problems.
02:46:53 <kosmikus> desp: ok, sounds interesting
02:47:11 <tcr> quicksilver: Nice. Thank you!
02:47:44 <kosmikus> desp: can you still submit solutions? and can you view the solutions of other people once you've solved a problem?
02:48:02 <desp> kosmikus: you can read/post them on a problem's forum
02:48:25 <desp> there are many posts, though
02:48:30 <desp> most of them horrible globs of C
02:48:34 <kosmikus> :)
02:48:42 <quicksilver> tcr: you'll notice it's actually more general; it works for any monad not just Maybe
02:49:07 <tcr> quicksilver: Yeah, I knew sequence already. Though not in this context. :)
02:49:19 <quicksilver> kosmikus: it's an 'honesty' competition; no real attempt is made to hide other people's answers, and people discuss them all over the net
02:49:27 <quicksilver> kosmikus: the joy is in the solving, rather than the answer :)
02:49:41 <desp> as it usually is
02:49:43 <desp> :)
02:49:47 <TSC> Any help on Project Euler problem 143 would be appreciated (:
02:49:55 <roconnor> I should do some of these Euler problems in coq.
02:50:00 <quicksilver> they are quite cleverly designed in that they require a mixture of insight from the programmer as well as programming skill
02:50:36 <desp> quicksilver: so far, I'm successfully brute forcing them ;)
02:51:10 <kosmikus> quicksilver: I was thinking of solving a number of problems in a specific programming language in order to demontrate the language; that's why I was asking
02:51:18 <desp> Haskell One-Liners(TM): What Can't They Do?
02:52:15 <Eelis> parsec expressions sometimes get rather verbose. if i were to implement a function  p :: String -> CharParser st String  that evaluates   (p "foo|bar|xy")  to  (string "foo" <|> string "bar" <|> string "xy"),  then theoretically that translation could happen entirely at compile-time and i could use the abbreviated syntax without any cost, right?
02:52:31 <osfameron> ooo, projecteuler looks interesting!
02:52:34 <visof> what is the most suitable method to use mouse (left hand or right hand)? and why?
02:52:43 <rehges> desp: they cannot solve the halting problem?
02:52:51 <desp> aww. :C
02:53:15 <thoughtpolice> desp: light speed travel?
02:53:18 <rehges> yeah too bad, haskell _is_ very powerful, but...
02:53:28 <xerox> Eelis: there exist a library that does exactly that stuff!
02:53:33 <quicksilver> desp: how far have you got?
02:53:43 <Eelis> xerox: got a link?
02:53:49 <desp> quicksilver: just started a while ago
02:54:01 <xerox> Eelis: hang on.
02:54:36 <RyanT5000> how do i establish one ForeignPtr as a GC parent of another?
02:54:40 <xerox> Eelis: <http://darcs.haskell.org/packages/regex-parsec/>
02:54:40 <quicksilver> desp: as I recall you can't get much past 10 on brute-force
02:54:50 <desp> ah
02:54:52 <quicksilver> desp: I forget exactly (obviously it epends a bit on your implementation)
02:54:54 <roconnor> Eelis: theoretically it could happen at compile time, but practailly it will happen at runtime. ... but only once per run.
02:55:10 <roconnor> Eelis: and only if it is demanded.
02:55:17 <quicksilver> desp: I mean, the questions are still brute-froce in some sense, but you have to use your brain to cut down the search space first
02:55:19 <Eelis> xerox: thanks!
02:55:22 <Eelis> roconnor: i see
02:55:36 <xerox> Eelis: Also <http://darcs.haskell.org/packages/regex-base/doc/README> - You're welcome :-)
02:56:08 <quicksilver> Eelis: I'd use p ["foo","bar","xy"] personally
02:56:23 <quicksilver> Eelis: rather than have your own miniparsing
02:57:09 <quicksilver> Eelis: or you could just write choose . map string $ ["foo","bar","xy"]
02:57:29 <desp> @type Char -> Integer
02:57:37 <lambdabot> <command line>:
02:57:38 <lambdabot>     Could not find module `L':
02:57:44 <desp> er
02:57:46 <Eelis> quicksilver: it was just an example, and as soon as you start introducing things like repetition and optionality and start nesting these things, regex-like syntax is easily several times more succinct
02:57:49 <desp> @hoogle Char -> Int
02:57:50 <lambdabot> Char.digitToInt :: Char -> Int
02:57:50 <lambdabot> Char.ord :: Char -> Int
02:58:23 <quicksilver> Eelis: I can normally acheive succintness without resorting to a regex-like minilanguage
02:58:45 <Eelis> quicksilver: i wish i had your skill.
02:58:47 <quicksilver> Eelis: I prefer ["foo","bar","xy"] to "foo|bar|xy" every time, I think the extra 20% or so chars is well spent
02:59:39 <quicksilver> partly because it syntax highlights well, partly because my structural editor can edit it well, but mostly because if I have to abstract even further
02:59:39 <Eelis> quicksilver: i'm thinking of regexes like  "basic_(string|[io]?(f|string)?stream)<char>"
03:00:18 <quicksilver> that does look a good time to use a regex, yes
03:00:39 <quicksilver> but you can easily write a parsec combinator which matches a reegex, obviosly
03:01:04 <RyanT5000> is there any decent way to express GC relationships between ForeignPtrs?
03:01:22 <RyanT5000> e.g.: i have a ForeignPtr Runtime_ and a ForeignPtr Context_
03:01:32 <RyanT5000> even if the former is lost, it can be recovered from the latter
03:01:55 <RyanT5000> so if the finalizer fires on the first, due to that ForeignPtr being lost, the second will break
03:03:05 <xerox> quicksilver: that'e exactly what the Lazy Regexp lib I pointed at does, and it does it lazily it seems.
03:03:42 <quicksilver> xerox: I guessed, but it seems overkill to pull in a whole library for a one-line combinator
03:04:25 <ari> @src [] (==)
03:04:25 <lambdabot> []     == []     = True
03:04:25 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
03:04:25 <lambdabot> _xs    == _ys    = False
03:05:26 <quicksilver> what's that third line doing?
03:05:39 <Eelis> taking care of   [] == [2,3]
03:05:47 <quicksilver> ah, o fcourse
03:07:09 <ari> I just wrote the most useless instance of anything, ever
03:07:23 <ari> instance (Enum a, Bounded a, Eq b) => Eq (a -> b) where x == y = map x [minBound..maxBound] == map y [minBound..maxBound]
03:07:49 <quicksilver> I don't think that's useless
03:08:07 <quicksilver> potentially slow, though :)
03:08:21 <ari> I'll get back to you once it's finished figuring out whether id == (id :: Int -> Int) ;)
03:08:56 <DRMacIver> It's upsetting if that does actually take a long time.
03:09:22 <TSC> Would you expect it to be quick?
03:09:26 <DRMacIver> Int is only 32-bit - looping through all the Ints shouldn't take very long.
03:09:52 <ari> Well, at least it was taking too long for my patience interpreted
03:09:59 <ari> I'll try compiling with -O2 instead
03:10:01 <DRMacIver> I mean, seconds is not implausible. but if it's minutes then it's probabl a sign that that's being poorly optimised.
03:10:02 <TSC> *Main> maxBound :: Int
03:10:03 <TSC> 9223372036854775807
03:10:24 <quicksilver> DRMacIver: I suspect he's running interpreted, and that would indeed be slow
03:10:29 <DRMacIver> Ah ha. Yes.
03:11:17 <quicksilver> you might figure, 4 billion ints, c.a. 20 instructions per compare,  80 billion ops, 80 seconds on a 1GHz machine
03:12:54 <DRMacIver> ari: Try x == y = all (\v -> x v == y v) [minBound..maxBound]
03:14:29 <DRMacIver> quicksilver: Mm. Well, when I've done comparable things in Java or C with primitives it's taken O(few hundred millis). It would be nice if the optimiser were sufficiently clever as to infer something like that here, although I guess that's probably a bit optimistic. :)
03:14:30 <xerox> Maybe better to |any (\x y -> f x /= g y)| ? Or does (==) short-cut?
03:14:49 <DRMacIver> Everything shortcuts. It's lazy evaluation. :)
03:14:51 <RyanT5000> is there any way to make ForeignPtrs with arbitrary dependencies work?
03:15:11 <RyanT5000> (i.e.: make use of Haskell's GC to finalize things in the correct order, etc.)
03:20:10 <DRMacIver> Hm. Actually, *does* the optimiser ever do clever things with realising that it can unbox a lot of stuff?
03:20:24 <quicksilver> DRMacIver: less than one second implies managing to get one compare per cycle on a 4GHz machine
03:20:35 <quicksilver> DRMacIver: that sounds surprising, even in c...
03:21:08 <quicksilver> not to mention the fact I don't have any 4Ghz machines, myself
03:22:12 <DRMacIver> Hm. Maybe I'm going mad. One second while I rerun the test.
03:22:36 <ari> Even DRMacIver's version took seven minutes for id == (id :: Int -> Int) here :(
03:23:37 * ari decides that from now on he will only use this for testing things that take a somewhat shorter time to go through, such as id == not . not
03:23:46 <RyanT5000> do we get any guarantees about the order finalizers are run in?
03:25:09 <DRMacIver> quicksilver: Ok. Quick test suggests that the compiler was being too clever for me. Oops. :)
03:26:03 <DRMacIver> It's still fast though (seconds).
03:26:07 <quicksilver> RyanT5000: I think not
03:26:14 <quicksilver> RyanT5000: (or, that they're ever run, at all)
03:26:17 <ejt_> how good is c2hs ?  I'm having trouble getting to grips with it, and want to know if t's worth the effort ?
03:26:53 <quicksilver> RyanT5000: if you add multiuple finalizers to the same ptr there is a guarantee about them, though
03:29:10 <paolin1> hi, anyone has reesolved problem 37 of Euler Project here ?
03:29:28 <TSC> paolin1: Yep
03:29:38 <RyanT5000> quicksilver: do you think i could use mkWeak to add more connections?
03:30:42 <paolin1> TSC , in haskell ?
03:31:12 <TSC> Yep
03:31:22 <paolin1> grr
03:31:31 <RyanT5000> quicksilver: wait; if i have the finalizer from one of them run touchForeignPtr on the other, will that work?
03:31:56 <paolin1> less than 1 minute computation ?
03:31:56 <RyanT5000> quicksilver: ah, nope
03:32:22 <quicksilver> I think it's bad style to rely on finalizer order
03:32:22 <TSC> paolin1: I'm looking at my old solution now to see how fast it is (if I can get it to work)
03:32:28 <quicksilver> GC guarantees are very weak
03:33:00 <DRMacIver> quicksilver: Which, amusingly, seems to be the sign of a good garbage collector. :)
03:33:11 <RyanT5000> quicksilver: i'm not really sure how else to do this, unless i make an ST-like monad and don't allow free-floating Runtimes or Contexts at all
03:33:33 <RyanT5000> @src touchForeignPtr
03:33:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:33:38 <paolin1> TSC , I find only first 9 in less than one minute, then ... nothing for at least 6 minutes
03:33:59 <TSC> Mine takes a few seconds
03:34:14 <TSC> Do you have a fast prime tester (or prime generator)?
03:34:32 <paolin1> I think so
03:35:11 <paolin1> a prime generator really
03:35:47 <TSC> Mine takes 13 seconds real time (10 seconds user CPU time)
03:36:19 <paolin1> can I see your prime tester ?
03:36:34 <TSC> Sure, hang on...
03:36:39 <quicksilver> RyanT5000: bracketing style, eception catching style, maybe
03:36:51 <quicksilver> RyanT5000: without knowing a bit more about your problem I can't be sure
03:37:02 <quicksilver> but relying on fainlizer ordering just doesn't sound sensible
03:37:43 <TSC> paolin1: According to the profiling, it spends more than half the time testing for primality, so it's important
03:38:29 <hpaste>  TSC pasted "prime testing" at http://hpaste.org/2008
03:39:08 <TSC> paolin1: My tester is certainly not optimal; there's been some discussion of prime generation on haskell-cafe recently, so you could look their for better ideas
03:39:53 <desegnis> Is it safe not to use hClose on file handles (for unsafe lazy IO), or can I except certain problems with too many open file handles hanging around?
03:41:06 <TSC> Now, if someone could tell me how to do problem 143, then I'd be happy (:
03:41:07 <Cale> desegnis: When you finish reading the list, the file handle will be closed for you
03:41:27 <Cale> desegnis: But there could be problems if you open obscene numbers of files, of course.
03:42:08 <RyanT5000> quicksilver: basically, you create a Runtime, within which you then create Contexts; there's a function GetRuntime that gets a Context's Runtime; so, even if the user loses the Runtime, you can't get rid of it until all the associated Contexts are also gone
03:42:28 <DRMacIver> Cale: Aren't there problems if you only read part of the list and hang on to that information?
03:42:29 <desegnis> Cale, I'm going to not use hGetContents, but I'm seeking around in the file, so I really do not close the handle
03:43:26 <Cale> DRMacIver: yeah. If you open lots of files and never use them, but the strings stay in scope, then you might run out of filehandles.
03:43:43 <EvilTerran> @pl \(i:is) -> Just (i, filter ((0/=).(`mod`i)) is)
03:43:43 <lambdabot> ap ((Just .) . liftM2 (.) (,) (filter . ((0 /=) .) . flip mod) . head) tail
03:43:51 <EvilTerran> O.o ... let's... not.
03:43:57 <Cale> If the string ends up GC'd then the filehandle gets closed as well.
03:44:07 <quicksilver> Cale: even if the strings drop out of scope, the finalizers aren't guaranteed to be run in a timely fashion
03:44:38 <EvilTerran> > unfoldr (\(i:is) -> Just (i, filter ((0/=).(`mod`i)) is)) [2..]
03:44:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
03:45:12 <Cale> In practical terms, I think they get run in a reasonable timeframe. I might be wrong.
03:45:30 <desegnis> Cale, so if I read into an (Array Int SomeBlock), I can hope for the file handle to be closed when the array is GC'ed, right?
03:45:54 <Cale> desegnis: From the lazy String?
03:46:00 <RyanT5000> quicksilver: i think i might be able to do it using System.Mem.Weak, since finalizers in it are actually Haskell values
03:47:00 <Cale> desegnis: yes. In fact, if you make the construction of the array strict, then the file handle will be closed as soon as it's finished constructing the array.
03:47:07 <desegnis> Cale, it's a lazy array. let's say (Array Int String) to make it clearer. the file contains blocks of equal size, and I'm lazily seeking to any block at position i when accessing (arr!i)
03:47:16 <Cale> ah
03:47:34 <quicksilver> RyanT5000: you still don't have an ordering guarantee
03:47:49 <quicksilver> RyanT5000: unless you make sure that some things can't possibly go dead until other things run
03:47:51 <desegnis> Cale, I can of course simply use an (Array Int (IO String)) instead and be safe
03:47:58 <Cale> yeah, so you'll have to wait for your whole array to get used before you can expect the handle to get closed
03:48:16 <desegnis> ah, many thanks
03:48:52 <hpaste>  Saizan pasted "how can i make the compiler unify event and Request?" at http://hpaste.org/2009
03:50:48 <desegnis> that's a pity, though, given I'm not going to use the whole array in every case
03:50:48 <RyanT5000> quicksilver: isn't the finalizer of a live object considered live until after it's finalized?
03:51:27 <RyanT5000> so if i say: addFinalizer foo (touch bar)
03:51:40 <RyanT5000> then bar is live until after foo is finalized, right?
03:51:46 <Saizan> it's a bit of an evil class, but do you have any suggestions on that problem? it's only caused by generality..
03:51:52 <Cale> desegnis: well, you can't have your cake and eat it too :)  You can force the entire file to be read into a buffer and construct your array lazily, or you can do the IO lazily, or you can just strictify everything. :)
03:52:24 <Cale> You could also make the array elements do IO :)
03:52:27 <RyanT5000> quicksilver: although i guess if they *both* become dead between sweeps there's still a problem
03:52:37 <Cale> (open the file, read the chunk, close it again)
03:52:44 <RyanT5000> quicksilver: shouldn't finalizers be GC-roots?
03:52:55 <Cale> That involves using unsafeInterleaveIO
03:53:32 <desegnis> ah, you mean, I can open and close the file for every array element
03:53:36 <Cale> yeah
03:53:52 <desegnis> thanks, I did not think of that one
03:54:10 <rubyruy> quick type inference question
03:54:17 <Cale> rubyruy: sure
03:54:42 <desegnis> Cale, and I will consider a buffer from which to construct the array lazily too
03:55:41 <rubyruy> how does it deal with a function that can return one of several types from just one? eg. parse_str ( String) -> Number, Date, Time, Boolean, List, depending on what it finds
03:56:03 <Cale> rubyruy: By explicitly representing the options for the result.
03:56:05 <valizas> how should I read                      fmap :: (a -> b) -> f a -> f b                   ?
03:56:35 <Cale> valizas: fmap takes a function from a's to b's and a structure of a's and gives a structure of b's.
03:56:45 <basti_> valizas: thats a type. fmap takes 2 arguments, one of type (a->b) and one of (f a), and it will return a value of type (f b)
03:56:56 <Cale> valizas: That is, it's just like map, but generalised to other data types than list.
03:57:13 <Cale> rubyruy: For example, you might have some data type:
03:57:17 <desegnis> rubyruy, you could have data Parsed = Parsed Integer | Parsed Date | ...
03:57:26 <rubyruy> so.. should i be thinking of it along the lines of it generates a NEW type behind my back?
03:57:28 <Cale> data Foo = I Integer | D Date | ...
03:57:40 <Cale> then  parse_str :: String -> Foo
03:58:01 <Cale> rubyruy: No, you have to define the type.
03:58:07 <valizas> Cale: basti_    thanks
03:58:07 <desegnis> rubyruy, I had it wrong... look at Cale's examples which are right
03:58:13 <rubyruy> oh reallly
03:58:24 <Cale> There's a type called Either which is for when you have two possibilities.
03:58:51 <paolin1> TSC, how many digits is the last good prime for problem 37 ?
03:58:56 <Cale> A value of type Either String Int is either Left s for some String s, or Right n for some Int n.
03:59:14 <Cale> data Either a b = Left a | Right b
03:59:30 <TSC> paolin1: 6 digits
03:59:37 <paolin1> uh
03:59:57 <Cale> rubyruy: Not allowing functions to ad-hoc return results of varying types is one of the things which makes static typing valuable, because it catches lots of bugs.
04:00:42 <paolin1> 739397 ?
04:01:05 <TSC> paolin1: Yes
04:01:06 <Cale> paolin1: I got that too
04:01:10 <paolin1> no
04:01:19 <paolin1> this is my number 9
04:01:25 <paolin1> not eleven
04:01:25 <valizas> in phrases like "The Functor class is used for types that can be mapped over. Instances of Functor should satisfy the following laws:" from the haskell doc., "laws" are in haskell syntax, or are they in a sort of more abstract notation?
04:01:44 <Cale> 23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397
04:01:52 <rubyruy> sooo if i then had mistery_foo = parse_str( mistery_string) ; add_a_year(mistery_foo) and add_a_year's signature is Date -> Date, how is it that it knows Foo can work as a date? is that just the mechanism of the "|" in Foo = I Integer | D Date etc ?
04:01:53 <paolin1> I have a prime leak
04:02:07 <opqdonut> valizas: yeah, they are stuff like "fmap (f.g) == fmap f . fmap g"
04:02:17 <Cale> valizas: well, they're not strictly Haskell in the sense that they're not compilable.
04:02:23 <opqdonut> ideally the implementer should prove them
04:02:31 <Cale> But they're usually written using Haskell notation :)
04:02:48 <opqdonut> yeah :)
04:02:53 <valizas> is "==" a valid haskell comparison operation ?
04:02:58 <Cale> rubyruy: You have to pattern match.
04:03:04 <basti_> rubyruy: you'd have to match agaist D...
04:03:08 <opqdonut> valizas: yeah
04:03:12 <paolin1> mmhh I excluded 2 and 5 from both lists , I should be abandoned in the desert
04:03:14 <valizas> thank you
04:03:16 <opqdonut> but functions are not Comparable
04:03:22 <Cale> rubyruy: If you call parse_str, it wouldn't return something usable as a Date directly
04:03:30 <valizas> opqdonut  i get it
04:03:38 <Cale> It *might* return something of the form D x, where x was a Date value.
04:03:39 <rubyruy> yeah it would return the Foo type you defined earlier
04:03:44 <opqdonut> ?scheck fmap ((+1).(*2)) == fmap (+1) . fmap (*2)
04:03:45 <lambdabot>  add an instance declaration for (Eq (f a -> f a))
04:03:45 <lambdabot>     In the expression:
04:03:45 <lambdabot>    ...
04:04:00 <Cale> and you'd pattern match to extract the x, and also deal with the other cases.
04:04:03 <opqdonut> ?scheck fmap ((+1).(*2)) x == fmap (+1) . fmap (*2) $ x
04:04:04 <lambdabot>  Not in scope: `x'
04:04:07 <opqdonut> gah
04:04:10 <Cale> (like what if it gives you an Integer instead)
04:04:11 <opqdonut> don't remember the syntax
04:04:44 <rubyruy> you mean in the parse_date function? So I couldn't just use the return value of parse_str as a parameter to add_a_year directly? (like in a DT language)
04:05:05 <Cale> Right, because in a DT language, that might be a bug.
04:05:06 <rubyruy> i.e. would i have to customize the add_a_year function?
04:05:10 <valizas> opqdonut you tried the bot to prove the expression true or false, right ?
04:05:15 <quicksilver> rubyruy: well that depends, is it really parse_foo or is it relaly parse_date
04:05:17 <rubyruy> ... hmm right i shouldn't be passing it to add_a_year
04:05:23 <Cale> You'd have to write it to deal with the other possible types of return values.
04:05:26 <rubyruy> er parse_str - i mistyped
04:05:29 <quicksilver> rubyruy: if it's the latter, then maybe its type should be Date
04:05:36 <quicksilver> rubyruy: but if it's former, maybe its type is Foo
04:05:46 <quicksilver> rubyruy: (and in the Foo case, there are other possibilities to account for)
04:05:54 <opqdonut> valizas: yeah
04:06:04 <opqdonut> haskell has automated checking libs
04:06:07 <opqdonut> "unit testing"
04:06:23 <valizas> opqdonut interesting indeed.
04:06:25 <opqdonut> they usually prove by testing tons of random examples
04:06:32 <valizas> wow
04:06:49 <valizas> sort of stochastic proof ?
04:06:49 <Cale> The property for fmap is usually easy to verify for concrete types.
04:07:07 <Cale> QuickCheck is not actually a proof :)
04:07:23 <Cale> But it helps :)
04:07:42 <TSC> It can prove incorrectness (:
04:07:51 <Cale> right, it can do that :)
04:08:23 <Cale> It's just a way to quickly generate hundreds of test cases.
04:08:35 <Cale> (from the types of the expressions being tested)
04:09:06 <Cale> I think opqdonut's problem was that the type wasn't nailed down enough for scheck to know what type of values to generate.
04:09:43 <dons> valizas: yeah, randomised testing
04:09:53 <valizas> tks
04:10:00 <dons> ?check \x -> x + x == 2 * (x :: Int)
04:10:02 <lambdabot>  OK, passed 500 tests.
04:10:14 <valizas> wow
04:10:17 <dons> ?check \x -> x + x == 2 * (x :: Double)
04:10:17 <Cale> Actually, @scheck is SmallCheck which tests small values that are usually boundary cases.
04:10:18 <lambdabot>  OK, passed 500 tests.
04:10:42 * osfameron solves Euler 2, then looks at the forums to see how cleverly he *could* have solved it if he knew some maths...
04:10:44 <araujo> morning
04:10:46 <RyanT5000> gah!
04:10:46 <RyanT5000> finalizers aren't GC-roots!
04:10:46 <RyanT5000> how is that supposed to work?
04:10:49 <dons> ?check \x -> x + x - 1 == (x-1) + (x :: Double)
04:10:50 <lambdabot>  Falsifiable, after 59 tests: -7.142857142857143
04:10:55 <dons> ?scheck \x -> x + x - 1 == (x-1) + (x :: Double)
04:10:56 <lambdabot>   Completed 79 test(s) without failure.
04:11:31 <Cale> wow.
04:12:01 <Cale> I'd have expected the SmallCheck instance for Double to include at least something which would fail that :)
04:12:08 <Eelis> @hoogle (Monad m) => m a -> m b -> m b
04:12:08 <lambdabot> Prelude.asTypeOf :: a -> a -> a
04:12:09 <lambdabot> Prelude.const :: a -> b -> a
04:12:09 <lambdabot> Prelude.seq :: a -> b -> b
04:12:16 <Cale> ha
04:12:19 <Eelis> @hoogle (>>)
04:12:19 <lambdabot> Did you mean: (>>)
04:12:19 <lambdabot> Prelude.undefined :: a
04:12:19 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:12:20 <Cale> Eelis: (>>)
04:12:27 <Eelis> man, this hoogle thing sucks.
04:12:40 <dons> ?hoogle >>
04:12:41 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
04:12:41 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
04:12:41 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
04:12:53 <Cale> http://haskell.org/hoogle/ -- the browser version is better
04:12:53 <psykotic> dons: btw is this hoogle 4? or isn't that released yet?
04:12:53 <lambdabot> Title: Hoogle
04:13:17 <Cale> oh, it still has the same bug though :)
04:13:59 * Cale wonders if ndm is around :)
04:14:01 <Cale> @seen ndm
04:14:01 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 9h 17m 21s ago, and .
04:14:20 <valizas> ?check \x -> x + 1 . x
04:14:21 <lambdabot>   add an instance declaration for (Num (c -> c))
04:14:55 <Cale> ?check \x -> x + 1 == (x :: Int)
04:14:56 <lambdabot>  Falsifiable, after 0 tests: -1
04:15:08 <valizas> ?check \x -> x + 1 . 1
04:15:09 <lambdabot>   add an instance declaration for (Num (a -> b))
04:15:21 <Cale> valizas: . is function composition
04:15:26 <valizas> mmm
04:15:48 <dons> psykotic: no, just old hoogle 2 iirc
04:16:04 <psykotic> dons: from what ndm posted on his blog, hoogle 4 seems really nice. :)
04:16:29 <psykotic> dons: e.g. i seem to recall that it will correctly match the query 'Int -> String' against 'Eq a => Int -> a'
04:16:42 <dons> yeah, has he released it yet?
04:16:46 <Cale> @check \f g -> map (f . g) (xs :: [Int]) == (map f . map g) xs
04:16:47 <lambdabot>   Not in scope: `xs'
04:16:49 <Cale> @check \f g xs -> map (f . g) (xs :: [Int]) == (map f . map g) xs
04:16:50 <lambdabot>  Add a type signature
04:16:55 <psykotic> don't think so. someone prod him! :)
04:17:07 <Cale> @check \f g xs -> map ((f :: Int -> Int) . (g :: Int -> Int)) (xs :: [Int]) == (map f . map g) xs
04:17:11 <lambdabot>  OK, passed 500 tests.
04:17:19 <Cale> Randomly generated functions :)
04:18:26 <psykotic> the coarbitrary trick is niec
04:18:31 <psykotic> basically using the input to seed a rng
04:23:31 <Cale> @check \f g xs -> map (f . g) xs == (map f . map g) xs :: (Int -> Int) -> (Int -> Int) -> [Int] -> Bool
04:23:32 <lambdabot>  Couldn't match expected type `(Int -> Int)
04:24:15 <Cale> hmm
04:24:26 <Cale> @check (\f g xs -> map (f . g) xs == (map f . map g) xs) :: (Int -> Int) -> (Int -> Int) -> [Int] -> Bool
04:24:30 <lambdabot>  OK, passed 500 tests.
04:24:32 <Cale> ah
04:24:48 <Cale> Yeah, that's probably a cleaner way to assign type signatures :)
04:25:26 <psykotic> @check (\(f :: Int -> Int) (g :: Int -> Int) (xs :: [Int]) -> map (f . g) xs == (map f . map g) xs)
04:25:26 <lambdabot>  Parse error in pattern
04:25:39 <dons> no pattern types in h98
04:25:55 <psykotic> right, i thought it had glasgow exts
04:28:48 <valizas> ?check \x -> x + 1  1
04:28:49 <lambdabot>   add an instance declaration for (Num (t -> a))
04:28:54 <RyanT5000> is there a way to manually add a GC root?
04:29:02 <dons> http://programming.reddit.com/info/2bb7a/comments vyer nice, DRMacIver
04:29:03 <lambdabot> Title: Playing with Arrows (reddit.com)
04:29:22 <RyanT5000> i don't understand why unexecuted finalizers aren't GC roots
04:29:26 <desp> @hoogle (a -> b -> (a, c)) -> a -> [b] -> [c]
04:29:26 <lambdabot> No matches, try a more general search
04:29:31 <desp> @hoogle (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
04:29:31 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
04:29:32 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
04:29:32 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:29:37 <desp> bingo
04:29:39 <RyanT5000> i just got some pathological code going where a finalizer printed out a dead string
04:29:46 <RyanT5000> (a string that had already been finalized)
04:30:06 <scook0> RyanT5000: stick the root in an IORef perhaps?
04:30:19 <desp> I love how figuring out a type is 80% of the solution
04:30:25 <RyanT5000> scook0: IORefs aren't roots
04:31:23 <RyanT5000> scook0: afaik, only threads are IO roots
04:31:36 * valizas suspects that haskell programming can be fun and useful ...
04:32:25 <xerox> valizas: SPJ puts Haskell in the Unuseful area in his diagram here, hehe <http://channel9.msdn.com/showpost.aspx?postid=326762>
04:33:07 <DRMacIver> Wasn't he using some odd technical definition of 'useful' though? :)
04:33:14 <scook0> xerox: sure, but by that argument every other language is rampantly unsafe ;)
04:34:22 <valizas> well we'll see :)
04:34:53 <DRMacIver> Hm. I've gotten to the point where I twitch every time I see a new introduction to or explanation of monads. :)
04:38:08 <desp> @hoogle a -> b -> (a, b)
04:38:09 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
04:38:09 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
04:38:20 <desp> @hoogle a -> (a, a)
04:38:21 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
04:38:21 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
04:38:31 <DRMacIver> dons: I was wondering how long it would take someone to post that. :)
04:39:09 <desp> xerox, DRMacIver: I figure he was speaking about Haskell prior to IO
04:40:54 <desp> > take 10 $ snd (mapAccumL (\a x -> (x + a, x + a)) 0 [1..])
04:40:56 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
04:44:05 <DRMacIver> (Oh, yuck. I've just reread that post and I'm really incoherent in it. I think the actual Haskell content is ok though, so I can't be bothered to fix it)
04:45:58 <desp> DRMacIver: are you, perchance, a tenured professor? ;)
04:47:13 <RyanT5000> does anyone here know about GHC's implementation of Weak pointers?
04:47:29 <RyanT5000> i think the semantics are flawed
04:47:59 <Igloo> In what way?
04:48:08 <RyanT5000> finalizers can use dead objects
04:48:16 <DRMacIver> desp: Heh. No. Why?
04:48:23 <desp> DRMacIver: just poking fun ;)
04:48:49 <Igloo> RyanT5000: I don't follow what you mean
04:48:50 <RyanT5000> my proposal: unrun finalizers are reachable from the garbage collector's thread, which is a GC root
04:49:05 <DRMacIver> (I'm not an academic of any description, although I have vague intentions of being one again at some point)
04:49:10 <RyanT5000> Igloo: let { s = "Hello, World!" ; f = putStrLn q ; q = "blah" ; g = putStrLn s } in do { addFinalizer s f ; addFinalizer q g ; performGC }
04:49:16 <njbartlett> DRMacIver: Nice blog post about arrows
04:49:37 <RyanT5000> Igloo: one of those finalizers, at least, is operating on a dead object
04:49:37 <Igloo> RyanT5000: Are you talking about System.Mem.Weak?
04:49:41 <RyanT5000> Igloo: yeah
04:49:55 <DRMacIver> njbartlett: Thanks. It's nothing very special though - I just thought it might be useful for people.
04:50:05 <Igloo> RyanT5000: Finalizers aren't guaranteed to be run, basically for this sort of reason
04:50:22 <RyanT5000> Igloo: yeah, but, in the code i just pasted, they *do* both run
04:50:35 <njbartlett> DRMacIver: Very useful, I think. I'm planning to talk a bit about arrows in relation to HXT at the London HUG, when I get a chance. Helpfully, Ross Paterson (Mr. Arrows) will probably be there!
04:50:46 <JaffaCake> someone asking about finalizers?
04:50:46 <RyanT5000> Igloo: so one of them is operating on a datum that has already been finalized
04:50:47 <njbartlett> (should that be Dr. Arrows?)
04:51:02 <RyanT5000> JaffaCake: yeah, i think GHC's treatment of finalizers is incoherent
04:51:19 <JaffaCake> I wouldn't be surprised :)
04:51:36 <DRMacIver> njbartlett: Cool. I look forward to it. :)
04:51:40 <RyanT5000> JaffaCake: well, that doesn't seem very haskelly!
04:51:41 <RyanT5000> lol
04:52:00 <JaffaCake> what are you trying to do?
04:52:28 <RyanT5000> JaffaCake: I'm trying to finalize some stuff that needs to be finalized in a particular order
04:52:42 <JaffaCake> ah, now that's likely to be difficult
04:52:48 <RyanT5000> JaffaCake: but i don't think it needs to be
04:53:04 <JaffaCake> finalizer ordering is always hairy
04:53:19 <RyanT5000> JaffaCake: i have a fix, i think, that also fixes some patently broken behavior
04:53:29 <RyanT5000> (at the expense of not necessarily getting everything in one GC)
04:53:38 <RyanT5000> (which isn't something we ever promised anyone anyway)
04:53:42 <RyanT5000> let { s = "Hello, World!" ; f = putStrLn q ; q = "blah" ; g = putStrLn s } in do { addFinalizer s f ; addFinalizer q g ; performGC }
04:54:06 <RyanT5000> that code demonstrates the incoherence of GHC's way of doing finalizers
04:54:12 <RyanT5000> (indeed, of the finalizer spec)
04:54:23 <RyanT5000> in GHCi anyway, both finalizers run
04:54:32 <RyanT5000> which means one is printing a string that's already been finalized
04:54:38 <JaffaCake> quite right
04:54:50 <RyanT5000> which means there's, at best, a race condition going on
04:55:05 <crazy_coder> hello everyone
04:55:11 <JaffaCake> not at all - you just shouldn't do that
04:55:12 <RyanT5000> which, if lost, seems like it could segfault or at best infinite-loop the GC
04:55:27 <RyanT5000> JaffaCake: well here's my proposal
04:55:41 <RyanT5000> make unrun finalizers GC roots
04:56:03 <RyanT5000> (or alternatively, you can conceive of it as the GC's thread being the GC root, and all the unrun finalizers as reachable from it)
04:56:22 <RyanT5000> so now you have an issue if a finalizer refers to the object it's a finalizer from
04:56:46 <JaffaCake> it's very carefully designed to work the way it does - I suggest you read http://www.haskell.org/~simonmar/papers/weak.pdf
04:56:56 <RyanT5000> although, i'll take a leak over a segfault-producing race any day
04:57:18 <crazy_coder> what are the applications of concurrency
04:57:27 <RyanT5000> then, my above code, you still shouldn't do, but you can do all the nifty ordered-finalization stuff you want
04:57:32 <JaffaCake> RyanT5000: exactly, the finaizer needs to refer to the finalized object
04:57:45 <RyanT5000> JaffaCake: why does it need to?
04:57:55 <JaffaCake> because it needs to finalize it :)
04:58:36 <RyanT5000> JaffaCake: so have the finalizer refer to things inside the object
04:58:48 <RyanT5000> or a shallow copy of the object
04:59:02 <JaffaCake> finalizer ordering is problematic in general, because it might require N full GCs to unravel a sequence of N finalizers
05:00:31 <RyanT5000> JaffaCake: that doesn't seem like a big problem; if someone really has a sequence of N finalizers, it's probably because they want them to happen in order
05:01:14 <JaffaCake> it won't work: it could be a long time before the next GC, you're much better off doing it another way
05:01:30 <RyanT5000> like what? only the GC is in a reasonable position to do this
05:01:48 <RyanT5000> anything else is asking the user to reimplement garbage collection
05:01:51 <RyanT5000> what's the point of that?
05:02:07 <JaffaCake> have you read Hans Boehm's paper on finalizers?  it addresses some of these points
05:02:51 <RyanT5000> JaffaCake: no
05:05:53 <sieni> RyanT5000: that's an exaggeration. GC handles memory. It doesn't matter if a piece of memory isn't garbage collected for a while, since it's not observable outside. Now let's assume the object to be collected contains e.g. a network socket and now the finalizer is trusted to close it, when the object becomes garbage.
05:07:42 <RyanT5000> sieni: right; then there's no reason for the finalizer to refer to the socket itself (as opposed to the internal handle or whatever), and there's no "waiting for N GCs" problem, if you do it my way
05:07:52 <RyanT5000> likewise, there's no problem under GHC's current system
05:08:14 <sieni> now suddenly the actual moment when the garbage is collected is visible to the whole world
05:08:52 <RyanT5000> sieni: yeah, but that's not the GC's fault; that's the fault of the guy who decided it would be a good idea to use finalizers to close network sockets
05:09:13 <RyanT5000> which might be OK sometimes, or not OK sometimes
05:09:34 <RyanT5000> that's a problem for the user, anyway
05:09:42 <fax> Hi
05:09:46 <fax> I just saw this http://hpaste.org/1986 .. wow :D
05:10:29 <RyanT5000> what i'm saying is just that i'd rather have finalizers that never get run when they're circular than finalizers that create a segfault-possibility race when they're circular
05:10:35 <roconnor> fax: wow?
05:11:13 <RyanT5000> especially since the former would also trivially support arbitrarily complex noncircular finalization
05:11:42 <fax> roconnor: using Coq to prove that code is correct :D
05:11:55 <dons> that's its job :)
05:12:18 <JaffaCake> RyanT5000: you might not know whether the finalizer refers to the finalized object, because it might be referred to in a thunk for example
05:12:25 <roconnor> fax: too bad the extracted code sucks.
05:12:32 <JaffaCake> the current story is much more robust in that respect
05:12:47 <fax> how does it?
05:13:13 <roconnor> fax: the run length encoding is encoded in unary.
05:13:15 <RyanT5000> JaffaCake: yeah, perhaps; i don't really know much about that kind of thing; also, i'm not sure if what i'm proposing can be implemented efficiently
05:13:30 <roconnor> fax: not much good for compression if it is just as long as the original.
05:13:30 <fax> roconnor: what do you mean
05:13:33 <JaffaCake> sure it can, but we decided not to do it that way
05:13:37 <fasta> What's the rationale for writing the RTS in C in GHC?
05:13:56 <roconnor> fax: type Rle ty = List (Prod ty Nat)
05:14:03 <JaffaCake> fasta: as opposed to... ?
05:14:06 <roconnor> So a list of pairs of type and Nat.
05:14:16 <roconnor> data Nat = O
05:14:17 <roconnor>            | S Nat
05:14:21 <roconnor> Nat in unary.
05:14:25 <fasta> JaffaCake: when you look at e.g. Smalltalk, they wrote everything in SmallTalk.
05:14:48 <fasta> JaffaCake: Scheme 48 follows about the same design
05:14:55 <JaffaCake> it's kinda hard to write some things in Haskell, e.g. the GC
05:15:28 <JaffaCake> we're thinking about  pulling the scheduler out, though, see our Haskell Workshop paper this year
05:15:37 <dcoutts> fasta: some parts have been moved into haskell, like the IO manager
05:15:43 <Syzygy-> ?doc
05:15:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
05:16:04 <dcoutts> JaffaCake: is that anywhere near passing the Marlow speed test?
05:16:21 <JaffaCake> not even close :)
05:16:23 <fasta> JaffaCake: if there is a reification of a computer available somewhere, one can write all the code against that. Then have a simple mapper from that goes through the real machine.
05:16:30 <tcr> dons: What's behind that run length thingie? Can it be coded up in a subset of haskell that doesn't use much of Haskell's advanced stuff? If so, I could take it as a fine test for my Haskell to Isabelle converter.
05:16:35 <JaffaCake> dcoutts: but that make  it an interesting research topic :)
05:16:42 <dcoutts> heh, right :-)
05:17:25 <JaffaCake> fasta: I look forward to seeing your reimplementation of the RTS :)
05:17:50 * JaffaCake likes C, anyway
05:18:08 <gkr> Is there any Group class?
05:18:56 <fax> @src group
05:18:56 <lambdabot> group = groupBy (==)
05:19:00 <fax> hahaha
05:19:12 <fax> @src groupBy
05:19:12 <lambdabot> groupBy _  []       =  []
05:19:12 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:19:12 <lambdabot>     where (ys,zs) = span (eq x) xs
05:19:13 <dcoutts> JaffaCake: aye, C/Haskell makes a nice combo
05:19:53 <dcoutts> JaffaCake: we're thinking of allowing mixing C in c2hs's .chs files
05:20:25 <JaffaCake> RyanT5000: here's one problem.  The finalizer might refer to a container which indirectly refers to a lot of finalizable objects; for example it might need to remove a finalizable object from a mutable list.  The finalizer therefore can't be allowed to keep any other finalizable objects alive
05:20:54 <dcoutts> so you can choose to put code on either side of the language boundary without having the hassle of adding a separate .c & .h file
05:21:57 <nominolo> C is a nice language.  It just shouldn't be used to implement a whole operating system in it.
05:22:11 <JaffaCake> true
05:22:15 <RyanT5000> JaffaCake: i don't understand how that follows.  Are you just saying that the finalizer will *temporarily* keep those objects alive?
05:22:21 <fax> C is not nice :(
05:22:41 <dcoutts> fax: though it's pretty good for interfacing with things written in C :-)
05:22:56 <fax> I prefer a REPL and a good FFI ^^
05:23:04 <RyanT5000> /who JaffaCake
05:23:10 <dcoutts> RyanT5000: :-)
05:23:11 <fax> but yeah, there are many uses
05:23:14 <JaffaCake> RyanT5000: if the finalizer is treated as a root, it would prevent all the objects it references from being finalized
05:23:15 <nominolo> heh
05:23:42 <RyanT5000> JaffaCake: Right.  Until it got run.
05:23:53 <JaffaCake> it wouldn't ever get run, though
05:24:15 <RyanT5000> JaffaCake: why not? are you saying that the object it's finalizing is in the structure itself?
05:24:26 <retybok> nominolo: the best operating systems are written entirely in C, though
05:24:38 <fasta> Cool #1564 got fixed :)
05:24:43 <retybok> so C doesn't seem to be so bad a language for such a task
05:24:51 <JaffaCake> RyanT5000: yes - suppose you have a mutable list of objects. and each objects finalizer removes itself from the list
05:24:52 <sieni> what? isn't house the best?!?!?
05:24:55 <DRMacIver> retybok: That seems a very dangerous statement to try to draw useful conclusions from. :)
05:25:27 <nominolo> retybok: let's not talk about security then
05:25:33 <DRMacIver> retybok: Given the relative numbers of large projects implemented in C and in other languages.
05:25:44 <retybok> DRMacIver: i'm just saying. I figure people have attemted to write OSes in about every language, the ones who succeeded best were the ones who did it in C. It's just an observation :)
05:26:01 <retybok> DRMacIver: that's kinda my point
05:26:02 <RyanT5000> JaffaCake: that would be pointless; even under the current system, those finalizers would only ever run once the list was already dead
05:26:10 <nominolo> retybok: meanwhile they have static analyzers to help improve C
05:26:36 <JaffaCake> RyanT5000: no, the list contains weak pointers
05:26:55 <nominolo> ?users
05:26:55 <lambdabot> Maximum users seen in #haskell: 382, currently: 357 (93.5%), active: 18 (5.0%)
05:28:34 <RyanT5000> JaffaCake: then why can't the finalizers contain weak pointers to the list as well?
05:28:46 <JaffaCake> RyanT5000: well true, maybe that's not such a good example
05:30:09 <RyanT5000> JaffaCake: i'm not saying there are no cases in which my system breaks, but neither is anyone saying that there are no cases in which the existing system breaks
05:30:34 <tcr> ndm: ping
05:30:35 <JaffaCake> sure, we adopted the position that you shouldn't have dependencies between finalizers
05:30:39 <ndm> tcr: pong
05:30:59 <RyanT5000> JaffaCake: both require the programmer to construct finalizers carefully; all i'm saying is that, for the problem i'm considering right now, finalizers-as-roots would be more powerful
05:31:18 <tcr> ndm: (Re: my alpha converter & uniplate.)
05:31:48 <RyanT5000> JaffaCake: what was the name of that guy you were telling me about earlier?
05:31:54 <tcr> ndm: Is it possible to write one function `alphaconvert' that can operate on two different data types? (expressions and declarations in my case)
05:31:56 <JaffaCake> RyanT5000: you can make a finalizer a root if you want, just make a StablePtr to it
05:32:15 <ndm> tcr: do both expressions and declarations have names in them?
05:32:20 <tcr> ndm: at the moment I have alphaconvertExpr and alphaconvertDecl that call each other recursively (maybe using descentBi)
05:32:34 <tcr> ndm: Yeah
05:32:38 <ndm> tcr: and do expressions and declarations both contain each other?
05:32:40 <JaffaCake> RyanT5000: http://portal.acm.org/citation.cfm?doid=604131.604153
05:32:42 <lambdabot> Title: Destructors, finalizers, and synchronization
05:32:48 <RyanT5000> JaffaCake: oh
05:32:53 <tcr> ndm: It's HsExpr and HsDecl from Hsx.
05:32:54 <RyanT5000> JaffaCake: that'll probably solve my problem
05:33:11 <RyanT5000> heh i really need to renew my ACM membership
05:33:23 <JaffaCake> ah, it's probably avaiable elsewhere on the web
05:33:27 <ndm> tcr: ah, no, you'll have to have two separate ones, i think
05:33:30 <RyanT5000> i'm in law school right now
05:33:33 <RyanT5000> so i let it lapse
05:33:40 <RyanT5000> thinking i wouldn't have much use for it :P
05:34:01 <tcr> ndm: Alright, that's what I've thought.
05:34:39 <JaffaCake> IIRC, Boehm argues for lack of dependencies because of the N GCs problem
05:35:05 * JaffaCake appeals to higher authority :)
05:35:17 <RyanT5000> JaffaCake: that's a totally good reason, i think, but i'm not yet convinced that it's a reason to not *support* dependencies, just to not *use* them
05:37:16 <JaffaCake> RyanT5000: the fact that you can't really control dependencies is a bit of a killer
05:41:13 <pejo> Ryan, http://www.hpl.hp.com/techreports/2002/HPL-2002-335.pdf is the tech report of the link from JaffaCake.
05:42:00 <RyanT5000> pejo: thanks
05:44:31 <RyanT5000> JaffaCake: what happens, under the current system, if you resurrect the object you're supposed to be finalizing?
05:45:12 <JaffaCake> nothing - there's no concept of resurrection
05:45:22 <RyanT5000> well it can be done
05:45:32 <RyanT5000> you have a reference to the dead object
05:45:41 <RyanT5000> and let's say you also have a reference to an MVar
05:45:45 <RyanT5000> (which is live)
05:45:53 <RyanT5000> you can chuck your dead object into the live MVar
05:46:03 <JaffaCake> no problem, the object remains alive
05:46:19 <JaffaCake> (it was never dead, just not reachable except from the finalizer)
05:46:23 <RyanT5000> so is the GC re-run after the finalizers are?
05:46:39 <RyanT5000> how does it know not to sweep that memory, which it just finished determining was dead?
05:46:59 <JaffaCake> it's all described in the weak pointers paper: http://www.haskell.org/~simonmar/papers/weak.pdf
05:47:09 <RyanT5000> hm, i just read some of that
05:47:23 <RyanT5000> ah ok
05:48:43 <JaffaCake> RyanT5000: can you describe what you're trying to do?  maybe we have other ways to solve it
05:50:17 <RyanT5000> JaffaCake: well, the problem i started with was this: i create a Runtime, in which i create several Contexts.  given a Context, i can get the parent Runtime, so even if the pointer to the Runtime is dead, we can't get rid of the underlying object until all the associated Contexts are dead as well.
05:50:22 <viller> can you embed haskell?
05:50:43 <tcr> Is there a function that takes a list and applies a function to the elements of the list? apply f [1 2 3] == f 1 2 3   --  I could possibly hack something up myself using some form of uncurry, but just wanted to ask.
05:51:06 <dcoutts> tcr: think about what the type of that function would be
05:51:29 <paolin1> @pl \y n -> y ++ show (n*read x)
05:51:29 <lambdabot> (. (show . (read x *))) . (++)
05:51:35 <wolverian> tcr, uh. map.
05:51:50 <JaffaCake> RyanT5000: so you want to finalize the Runtime?
05:51:51 <wolverian> oh, nevermind :)
05:51:56 <RyanT5000> JaffaCake: i've since discovered that you can get a list of Contexts given a Runtime, so it's actually totally circular
05:52:07 <RyanT5000> JaffaCake: i want appropriate finalizers on everything, pretty much
05:52:32 <tcr> dcoutts_: The length of the list should be statically known, i.e. apply3 f [1 2 3] == f 1 2 3
05:52:33 <viller> can you embed haskell?
05:52:46 <RyanT5000> JaffaCake: also, there might be more constructs created later, such as Objects, which may be in Runtimes and referred to by several Contexts
05:52:53 <dcoutts> tcr: but the type of a list does not tell you anything about it's length
05:53:04 <kaol> viller: embed it in what?
05:53:07 <ndm> tcr: a list of statically known length is a tuple
05:53:07 <RyanT5000> JaffaCake: there's an embedded GC
05:53:22 <RyanT5000> JaffaCake: (i'm embedding JavaScript)
05:53:24 <dcoutts> tcr: yes, you're better off with tuples
05:53:37 <tcr> Is there a mapping function for tuples?
05:53:48 <dcoutts> you can certainly have uncurryN for various values of N
05:53:49 <JaffaCake> RyanT5000: so the problem is that all the finalizers run at once as soon as the whole structure is dead?
05:54:03 <RyanT5000> JaffaCake: yeah
05:54:28 <dcoutts> tcr: here's one: (\f (x,y,z) -> (f x, f y, f z))
05:54:53 <RyanT5000> JaffaCake: instead, it should either kill all the contexts and then the runtime or just kill the runtime (i'm not sure which)
05:55:00 <viller> kaol: I mean make a C application (for an example) extendable by haskell
05:55:03 <JaffaCake> you know that if one of the finalizers has started then all the others have too, so it should be possible to have one finalizer invoke the others
05:55:15 <rehges> tcr: applyN n f (x:xs) = applyN n-1 (f x) xs  -- and handle the edge case yourself :-)
05:55:18 <viller> kaol: can it be used as a scripting language
05:55:30 <JaffaCake> e.g. the Runtime finalizer calls the Context finalizers before finalizing itself
05:55:40 <RyanT5000> JaffaCake: yeah, i'll probably have to do something like that; but then, of course, they have to know not to run
05:55:49 <Japsu> rehges: isn't (x:xs) a list, not a tuple?
05:55:52 <JaffaCake> right, you need some mutable state
05:55:58 <Saizan> rehges: they to make that typecheck :)
05:56:03 <dcoutts> viller: probably the impl best suited to that would be yhc, ask ndm about it
05:56:04 <rehges> japsu: he asked for list, first
05:56:23 <Japsu> oh, right, I was thinking  15:52   tcr : Is there a mapping function for tuples?
05:56:25 <Saizan> rehges: s/they/try/
05:56:47 <ndm> viller: you could, with Yhc, but it would be much easier to just write the program in Haskell from the begining
05:56:50 <rehges> saizan: heh
05:57:05 <ndm> Haskell /= Scripting Language
05:57:32 <fasta> "Scripting language" is undefined
05:57:47 <Saizan> rehges: http://hpaste.org/1773
05:57:48 <fasta> It has no meaning.
05:58:05 <rehges> applyN :: Integer -> (a -> b) -> [a] -> b
05:58:12 <ndm> "a language used to script a program written in another language" - the meaning is very clear in this context
05:58:15 <rehges> something like that, anyway ;-P
05:58:27 <RyanT5000> JaffaCake: i guess i'll have to put a mutex in somewhere... sigh :P
05:58:55 <JaffaCake> an MVar should do
05:58:59 <JaffaCake> or use STM...
05:59:03 <Saizan> rehges: so applyN _ f (a:as) = f a? a little boring :)
06:01:29 <RyanT5000> JaffaCake: I think i might end up using StablePtrs after all - but not to finesse some weird staged GC; I can use them to chuck haskell datastructures into the user pointers of the engine's datastructures
06:02:27 <rehges> saizan: yeah there is a little problem with it eh :-)
06:02:59 <rehges> Integer -> ([a] -> b) -> [a] -> b   looks better
06:03:56 <ndm> Igloo: what are the current thoughts on splitting off Data.Generics? I want to do a library proposal submission on it, but will wait if its going to get separated
06:04:23 <dancor> best way to go from ['a', 'b', 'a'] to [('a', 2), ('b', 1)]
06:04:55 <ndm> > map (head &&& length) . group . sort $ "aba"
06:04:59 <lambdabot>  [('a',2),('b',1)]
06:05:02 <dancor> whew
06:05:03 <rehges> dancor: first sort the list, then count
06:06:04 <Igloo> ndm: I plan to do split generics off, but I'm waiting for bytestring to work
06:06:13 <dcoutts> ok ok :-)
06:06:15 <ndm> Igloo: or is Data.Generics outside of the library submission process, and a direct SPJ maintained library?
06:06:45 <desp> @src maximum
06:06:46 <lambdabot> maximum [] = undefined
06:06:46 <lambdabot> maximum xs = foldl1 max xs
06:06:50 <desp> huh
06:06:58 <desp> @hoogle foldl1'
06:06:58 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
06:07:00 <fax> > UNDEFINED
06:07:01 <lambdabot>   Not in scope: data constructor `UNDEFINED'
06:07:08 <Cale> > undefined
06:07:09 <desp> why doesn't maximum use foldl1' ?
06:07:10 <lambdabot>  Undefined
06:07:13 <Igloo> ndm: It was already discussed on the libraries list re http://hackage.haskell.org/trac/ghc/ticket/1338
06:07:15 <lambdabot> Title: #1338 (base package breakup) - GHC - Trac
06:07:16 <fax> > Undefined
06:07:17 <lambdabot>   Not in scope: data constructor `Undefined'
06:07:21 <fax> Hm :|
06:07:26 <desp> it stack overflows on large lists
06:07:33 <desp> and there is certainly no need for it to do that
06:07:34 <ndm> desp: you can have lazy numeric types
06:07:36 <roconnor> > undefined
06:07:37 <lambdabot>  Undefined
06:07:40 <Igloo> ndm: You just mean putting it in its own package rather than renaming the hierarchy, right?
06:07:43 <desp> ndm...?
06:07:51 <Saizan> fax: there's no Undefined constructor, it's just the way that lambdabot show it
06:07:51 <Igloo> dcoutts: Sorry, but ndm asked!
06:07:58 <dcoutts> s'ok :-)
06:07:59 <ndm> Igloo: yeah
06:08:12 <Cale> maximum                 :: (Ord a) => [a] -> a
06:08:12 <Cale> maximum []              =  errorEmptyList "maximum"
06:08:12 <Cale> maximum xs              =  foldl1 max xs
06:08:18 <fax> Oh I see
06:08:25 <ndm> desp: that would be overly strict, in some cases
06:08:33 <nominolo> @babel fr-en pas
06:08:33 <lambdabot>   bzzt.
06:08:35 <fax> > let maximum []              =  errorEmptyList "maximum" in maximum []
06:08:36 <lambdabot>   Not in scope: `errorEmptyList'
06:08:44 * Igloo should actually do the breakup locally so I see if any more problems arise
06:08:44 <nominolo> @babel fr en pas
06:08:44 <ndm> Igloo: you mean for Generics to work over bytestring?
06:08:45 <lambdabot>   not
06:09:05 <dcoutts> Igloo: why does generics depend on bytestring btw?
06:09:21 <Igloo> ndm: No, bytestring imports Data.Generics stuff so it needs to move out of base first, but the separate bytestring package segfaults currently
06:09:35 <Igloo> dcoutts: Data/ByteString/Internal.hs:import Data.Generics            (Data(..), Typeable(..))
06:09:37 <ndm> ah, fair enough
06:09:55 <ndm> dcoutts, does ByteString just use Data.Generics to provide appropriate instances?
06:10:04 <dcoutts> probably
06:10:29 <desp> ndm: can you give an example of the case where foldl1' would be too strict?
06:10:42 <ndm> i'll just wait until Generics is a separate package then, before proposing things
06:10:45 <Igloo> dcoutts: So if bytestring moves out of base (and depends on base for various types it uses, if nothing else) then bytestring also needs to be outside base or there is an import cycle
06:10:46 <dcoutts> ndm: Igloo: it's so we can do deriving (Data, Typeable)
06:10:52 <desp> I don't know of any lazy numeric types
06:11:00 <desp> unless Integer is actually lazy inside
06:11:04 <ndm> desp: no, can you prove there isn't one? if so, we could change the definition
06:11:06 <Cale> The only cases where you could save work using foldl1 over foldl1' would be for types where there is a maximum possible value such that max is non-strict in its left parameter (which is sort of wierd)
06:11:31 <ndm> desp: you could always define data Peano = Succ Peano | Zero, which would be a lazy number type
06:11:34 <dcoutts> Igloo: doesn't this mean that everything is going to have to depend on the generics package?
06:11:36 <roconnor> Would you write the domain of tangent as x /= pi/2 + n*pi  or as x /= n*pi + pi/2 or as something else?
06:11:41 <ndm> i have such a library, i just haven't got round to defining it
06:11:43 <Igloo> ndm: What do you want to propose, OOI?
06:11:55 <dcoutts> Igloo: if generics is outside base? since everyone seems to want to derive Data & Typeable
06:11:56 <ndm> Igloo: the universe function, from Uniplate, ported to SYB
06:12:09 <int-e> @src max
06:12:10 <lambdabot> max x y = if x <= y then y else x
06:12:14 <Cale> There'd be more point to having a maximum defined using foldr1 with regard to laziness than one which used foldl1.
06:12:20 <dcoutts> Igloo: or should we stop deriving (Data, Typeable) ?
06:12:27 <ndm> possibly descend/transform as well, but thats harder to know
06:12:40 <Igloo> dcoutts: Lots of things will probably depend on it, yes
06:12:53 <dcoutts> Igloo: this is the problem with moving classes out of base
06:13:02 <ndm> this is the problem with classes/instances
06:13:07 <dcoutts> Igloo: instances can move out, but moving important classes out is a pita
06:13:12 <ndm> they really don't modularise well...
06:13:13 <desp> I think it's odd to keep a foldl1-based maximum for the case when someone defines an impractical numeric type, while it breaks in more usually encountered case involving built-in types
06:13:27 <ndm> desp: be lazy by default, its the Haskell way
06:13:41 <Igloo> dcoutts: standalone, idempotent deriving declarations will make things better
06:13:47 <Cale> Not necessarily numeric.
06:13:53 <dcoutts> Igloo: true
06:13:54 <Igloo> Except I don't think they're currently idempotent
06:13:58 <dcoutts> heh
06:13:59 <ndm> Igloo: provided you don't want to define a custom instance
06:14:03 <Cale> In this case though, I think the choice is pretty broken.
06:14:09 <dcoutts> Igloo: but why must we move the classes themselves out?
06:14:19 <Igloo> ndm: If you want a custom instance you'd probably have it in the same place as the type
06:14:30 <Cale> Because if you want to be lazy, you'd rather have foldr1, and if not, you'd rather have foldl1'
06:14:31 <ndm> dcoutts, the Data class is pretty big, and pretty central to the library
06:14:40 <int-e> Cale: looks like max is inherently strict in its second argument.
06:14:50 <Cale> int-e: depends on the instance
06:14:52 <ndm> dcoutts, without it moving out, there is no point to move out the rest
06:15:01 <dcoutts> Igloo: have we decided yet if applicative is moving out of base ?
06:15:49 <mux> is there a haskell library for "humanizing" numbers a la humanize_number(3)
06:16:08 <dcoutts> ndm: the class itself isn't big, it's a dozen lines of code or so, it's the support code and instances that are large
06:16:20 <Igloo> dcoutts: I reread the list discussion and the best concensus I could get was that Data.Foldable,Traversable,Map,IntMap,Set,IntSet,Sequence,Graph should be moved out into a package
06:16:20 <int-e> Cale: there are two cases that could possibly shortcut x <= y: a) x is the minmum (in which case max returns y) or b) y is the maximum (in which case y is evaluated)
06:16:33 <ndm> dcoutts, but its very central, its the key bit of the library, and its not "obvious"
06:16:35 <Igloo> dcoutts: i.e. not Applicative or Monoid
06:16:37 <int-e> Cale: assuming that the Ord instance is a partial order.
06:17:06 <dcoutts> Igloo: ok, though I'd apply the same logic to the foldable class, though not the instances. I think we should bring this up again on the libraries list.
06:17:45 <Igloo> dcoutts: I don't think we're going to reach a better concensus. I plan to go ahead with the current plan, and we can always tweak things later, when it will be easier to experiment due to base being much smaller
06:17:48 <Cale> int-e: Well, it's really using max and not necessarily (<=), but yeah
06:17:53 <dcoutts> Igloo: ok, well I'm going to remove the deriving Data & Typeable
06:18:00 <Igloo> dcoutts: Why?
06:18:05 <int-e> Cale: oh. right.
06:18:19 <dcoutts> Igloo: because it pulls in an extra dependency unnecessarily
06:18:21 <int-e> Cale: sorry, @src made me think it wasn't part of the type class, I should've checked
06:18:29 <MyCatVerbs> @src words
06:18:29 <lambdabot> words s = case dropWhile isSpace s of
06:18:29 <lambdabot>     "" -> []
06:18:29 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:18:33 <Igloo> dcoutts: But these are all core package, so it makes no difference
06:18:50 <Igloo> dcoutts: And you'll be breaking working code
06:18:52 <dcoutts> Igloo: but it's also blocking your moving generics out
06:19:05 <fax> @src break
06:19:05 <lambdabot> break p =  span (not . p)
06:19:10 <fax> -_-
06:19:43 <Igloo> dcoutts: don't worry about workarounds like that, at worst we'll go for a bytestring package with the current base code in
06:20:09 <dcoutts> Igloo: I worry we're not actually reducing dependencies at all
06:20:21 <fax> @src span
06:20:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:20:22 <gkr> Where is StateT's (>>=) source?
06:20:35 <fax> How can span not have source code?
06:20:58 <Saizan> @source Control.Monad.State
06:20:58 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
06:21:16 <Saizan> @source Control.Monad.State.Lazy
06:21:16 <lambdabot> Control.Monad.State.Lazy not available
06:21:18 <Cale> fax: It's not pulling the source from anywhere official.
06:21:41 <Cale> fax: It just has its own database, so perhaps there are omissions
06:21:43 <Saizan> gkr: here -> http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
06:21:52 <fax> aw ok
06:22:21 <Cale> I think it might be that span isn't in Data.List, but somewhere else...
06:22:26 <Cale> (in the actual sources)
06:22:46 * Cale checks GHC/Base
06:23:46 <Cale> ah, GHC/List.hs
06:23:49 <Cale> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/List.lhs
06:23:56 <Cale> span                    :: (a -> Bool) -> [a] -> ([a],[a])
06:23:56 <Cale> span _ xs@[]            =  (xs, xs)
06:23:56 <Cale> span p xs@(x:xs')
06:23:56 <Cale>          | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
06:23:56 <Cale>          | otherwise    =  ([],xs)
06:24:13 <fax> ah ace
06:24:14 <gkr> Thanks Saizan
06:24:16 <fax> thanks Cale :D
06:24:21 * gkr kisses Saizan
06:24:33 * Saizan blushes
06:25:19 <fax> whats xs@[]?
06:25:39 <mux> mmm
06:25:47 <mux> I think this code tries to ensure sharing of []
06:25:55 <edwardk> fax: it gives a name to the particular nil that you found, so that it can be shared
06:26:14 <fax> why do you want to share []?
06:26:15 <roconnor> Saizan++
06:26:15 <edwardk> otherwise foo [] = []    will probably construct a new node.
06:26:22 <int-e> fax: to save allocations
06:26:26 <Cale> fax: It binds xs to whatever [] matches
06:26:34 <fax> hm
06:26:41 <edwardk> whereas foo xs@[] = xs will pretty much definitely share the same node
06:26:42 <fax> so why not have the compiler do it?
06:26:51 <edwardk> its usually used for more complicated patterns
06:26:55 <Cale> similarly, in the next line,  xs@(x:xs') will bind xs to the whole matched list, x to the head, and xs' to the tail
06:26:57 <mux> I've read spj saying doing full CSE would cause space leaks in some situations, but it seems ghc could handle this
06:27:01 <int-e> I'd hope the compiler does that for nullary constructors
06:27:07 <mux> int-e: yeah
06:27:18 <Saizan> roconnor: just for having found Lazy.hs?
06:27:18 <Cale> I think it might just be a stylistic thing here.
06:27:35 <ari> I thought at least ghc just allocated one [] statically
06:27:36 <Cale> (though I'm not sure it's a good stylistic thing :)
06:27:39 <int-e> fax: in any case it won't hurt
06:27:39 <edwardk> foo bigexpensivething@(MyConstructor of fifty different terms _ some _ of _ which I skip) = dosomethingcomplicated with bigexpensivething
06:28:36 <Japsu> cute
06:29:17 <roconnor> Saizan: aparently.
06:29:58 <edwardk> or more commonly insert x [] = [x]; insert x yys@(y:ys) = if x < y then x:yys else y : insert x ys
06:30:22 <edwardk> where that ensures that you share the tail rather than build a new node reconsing the arguments you just took apart by pattern matching
06:30:51 <edwardk> er x <= y
06:31:08 <Saizan> edwardk: (if you've a constructor with fifty different terms you should die an horrible death :)
06:31:26 <edwardk> saizan: well, hopefully it would at least use the record sugar =)
06:36:54 <Saizan> mmh, do you have a lighter alternative to StateT (Maybe a) ? i'm yet in a complex monad, i'd like not to lift everything else
06:37:36 <edwardk> is the maybe just to track errors?
06:38:38 <Saizan> well a is a session, it could not be there
06:40:26 <Cale> Saizan: That's why you newtype things, so you only have to lift while defining your basic operations.
06:41:14 <xerox> The ultimate lifting is to IO a, and you're done, gulp!
06:41:19 <edwardk> or is the issue having to lift Maybe operations?
06:44:43 <ndm> anyone submitting to the Haskell workshop, or has done in the past?
06:44:52 <ndm> in particular, how do i make sure my document is US Letter and not A4
06:45:17 <ndm> is \documentclass{sigplanconf} enough? will converting a .dvi to a .ps/.pdf change these things?
06:45:53 <flux> review the produced ps, it should have its size in points (72 points per inch) or inches near the top..
06:47:55 <ndm> 599pt x 838pt
06:48:22 <ndm> that sounds like A4, i think
06:49:24 <ndm> any idea how i check the .dvi's size, or persuade it to be US letter?
06:51:43 <psykotic> ndm, hey, is there any plan for when hoogle 4 will be released?
06:52:14 <ndm> psykotic: no, its going to be a while, hopefully before the end of the year
06:52:21 <psykotic> ndm: cool.
06:53:02 <edwardk> ndm: how fares supero?
06:53:50 <marcotmarcot> Good morning.
06:55:07 <ndm> edwardk: slow, but progressing, hopefully a few more weeks til i've got nobench results
06:55:30 <marcotmarcot> I'm trying to load a package to Cabal, but I'm getting a problem with utf-8 character in my name: Marco Tlio.
06:55:45 <marcotmarcot> Should I be using iso-8859-1 instead?
06:56:21 <Igloo> If UTF8 doesn't work then you should file a bug
06:56:27 <SamB_XP_> marcotmarcot: you shouldn't have characters like that in your name ;-P
06:56:35 <SamB_XP_> it's all your fault!
06:56:41 <marcotmarcot> Not Cabal, Hackage.
06:56:51 <marcotmarcot> The problem is in loading it to hackage.
06:56:59 * SamB_XP_ is teasing
06:57:02 <Igloo> Still file a bug
06:57:10 <marcotmarcot> SamB_XP_: =P
06:57:15 <Igloo> UTF8 ought to work everywhere
06:57:25 <dcoutts> marcotmarcot: yes, it's a bug if hackage will not accept utf8 chars in .cabal files
06:57:38 <marcotmarcot> dcoutts: is it a known bug?
06:57:45 <dcoutts> I didn't know of it
06:57:48 <SamB_XP_> dcoutts: does the cabal documentation say it's allowed?
06:57:57 <dcoutts> SamB_XP_: probably not explicitly
06:57:59 <marcotmarcot> Igloo: where do I file a bug for hackage?
06:58:01 <SamB_XP_> dcoutts: it should
06:58:06 <Igloo> marcotmarcot: No idea
06:58:10 <dcoutts> SamB_XP_: send in a patch! :-)
06:58:50 <dcoutts> marcotmarcot: file a bug here: http://hackage.haskell.org/trac/hackage/
06:58:52 <lambdabot> Title: Hackage - Trac
06:59:14 <SamB> dcoutts: how do we know it's a hackage bug and not a latent cabal bug?
06:59:33 <dcoutts> SamB: it could be either, fortunately we have a shared bug db :-)
06:59:44 <SamB> ah. that's nice, yes.
06:59:49 <SamB> that's as it should be.
07:00:53 <marcotmarcot> dcoutts: It seems that I need to have a user to create a new bug.
07:01:01 <dcoutts> To report bugs (or edit Wiki pages), you'll need to log in with username guest and password haskell' (note the apostrophe at the end).
07:01:08 <marcotmarcot> oh, there's a public password.
07:01:09 <marcotmarcot> ok
07:01:09 <SamB> what are all these <!ENTITY>s?
07:01:19 <psykotic> XML gremlins
07:01:24 <SamB> dcoutts: heh
07:01:41 <dcoutts> SamB: are you looking at the Cabal.xml user guide?
07:01:44 <SamB> is that to foul up things trying to snarf the username and password of the page?
07:01:51 <SamB> dcoutts: yeah
07:01:51 <dcoutts> I guess so
07:02:14 <dcoutts> SamB: they're shortcuts, so you can say things like "blah &haddock; blah blah"
07:02:35 <CosmicRay> did I hear rumblings of simon's oscon tutorial being posted somewhere?
07:03:13 <SamB> they're really wide...
07:04:00 <SamB> congrats. my editor says that Cabal.xml is valid.
07:04:24 <ndm> dcoutts, have you submitted your ICFP paper yet, or did dons do that?
07:04:41 <ndm> and do you have any clue how to get US-Letter out of your Tex system?
07:04:41 * SamB loves nxml-mode
07:04:48 <dcoutts> ndm: dons and rl did it, I was away at the time
07:04:57 <ndm> @seen dons
07:04:57 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 53m 2s ago.
07:05:04 <dcoutts> ndm: we got an email linking to a web page with instructions on that issue
07:05:09 <SamB> ndm: if the margins are wide enough we don't need US-Letter
07:05:14 <SamB> ;-P
07:05:24 <ndm> dcoutts, you got one specifically? or just a general one?
07:05:27 <SamB> at least not us unix users
07:05:38 <dcoutts> ndm: specific iirc, lemme check
07:05:42 <ndm> dcoutts, i can't find anything on it
07:05:59 <dcoutts> 1. Your paper is formatted for US Letter, but the pdf has a page size of A4, to help correct this see: http://acm.org/sigs/pubs/proceed/sigfaq.htm#a14
07:06:01 <lambdabot> Title: SIGS PROCEEDINGS FAQ
07:08:22 <ndm> dcoutts, thanks
07:08:30 <dcoutts> np
07:09:25 <dcoutts> Igloo: where is your style guide again?
07:09:34 <SamB> wierd.
07:09:54 <SamB> having nxml-mode installed when you try to build the debian package doesn't work?
07:10:07 <ndm> dcoutts, http://urchin.earth.li/~ian/style/mail.txt
07:10:17 <dcoutts> ndm: ta
07:10:22 <marcotmarcot> Is it only with dons that I can get a username and a password for hackage?
07:10:34 <dcoutts> Igloo: going to post that btw?
07:10:40 <dcoutts> Igloo: it should go on the wiki
07:10:53 <marcotmarcot> I'm not sure if I have created a username for it before.
07:11:35 <sm> CosmicRay: yes you did, http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
07:11:39 <lambdabot> http://tinyurl.com/ysvquz
07:11:44 <sm> it's great
07:11:55 <CosmicRay> sm: I have that already, but I'm talking about the 3-hour tutorial he gave -- the video from it
07:11:58 <CosmicRay> I do have the slides
07:12:06 <sm> oh, darn
07:12:07 <CosmicRay> someone was talking about posting the video
07:12:19 <CosmicRay> there is video of his 15-minute keynote on STM
07:12:33 <CosmicRay> which, for the record, was great.
07:12:38 <sm> thanks, I'll check it out
07:13:30 <CosmicRay> unfortunately the video never cuts to his slides so it's not quite as easy to follow as it was in person
07:16:56 <Igloo> dcoutts: Doing so now
07:17:03 <dcoutts> great :-)
07:17:04 * Igloo wonders where the script is that I said I'd attach
07:17:13 <SamB> hmm. *where* to insert this bit about .cabal files being encoded in UTF-8...
07:17:17 <Igloo> Ah, in that directory. That was cunning of me.
07:17:31 <gkr> Is there any place where I can find the solution to Richard Bird's Introduction to functional programming using Haskell?
07:18:32 <dcoutts> SamB: http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#pkg-descr
07:18:34 <lambdabot> Title: 2. Creating a package, http://tinyurl.com/yv8xjt
07:18:52 <dcoutts> SamB: near the top of section 2.1 I'd say
07:19:11 <SamB> dcoutts: I'd already decided on that section ;-)
07:19:15 <SamB> but near the top you say?
07:19:28 <dcoutts> after the first or second sentance I'd say
07:19:58 <dcoutts> The package description file should be a utf8 text file and have a name ending in .cabal.
07:20:26 <dcoutts> SamB: but then we'd better make sure that's true :-)
07:21:32 <dcoutts> SamB: as far as I know there's no utf8 decoding in the cabal lexer
07:21:54 <SamB> dcoutts: maybe we should put it for field values instead?
07:22:04 <dcoutts> hmm
07:22:40 <dcoutts> SamB: some fields might be restricted to ascii I suppose, but I think the default encoding for the whole file should be utf8
07:23:06 <SamB> dcoutts: filenames too?
07:23:16 <dcoutts> SamB: that's a more tricky issue
07:23:37 <dcoutts> SamB: I suspect package names have to be ascii at the moment
07:24:25 <SamB> the only places it seems to be possible to use UTF-8 are in "freeform", "URL", and "address" fields and in comments
07:25:17 <Igloo> If we get non-ASCII package names, I (on behalf of Debian) will cry
07:25:39 <SamB> and it doesn't matter for comments, does it?
07:25:42 <fax> should you not fix debian?
07:25:47 <fax> if it cant handle ascii filename
07:25:55 <SamB> fax: "fix"?
07:26:37 <fax> I dunno he seems to be suggesting debian can't do unicode filenames
07:26:37 <Igloo> I think Cabal packages are actually required to match an even more restrictive regexp, only allowing a-zA-Z0-9.+- or similar
07:26:37 <SamB> dcoutts: anyway, it seems like the only place UTF-8 actually matters is those kinds of fields
07:26:42 <dottedmag> fax: not before the SUS revision which clearly and unambigously specifies behavior of non-ASCII filenames.
07:26:48 <Igloo> fax: Package names, not file names
07:26:55 <dcoutts> SamB: aye
07:27:44 <SamB> so how about I just add "encoded in UTF-8" at the end of the sentance describing those field types?
07:30:43 <Igloo> I'd also put something at the top saying something like "The .cabal file must be valid UTF-8, but non-ASCII characters are only permitted where explicitly described below"
07:30:51 <Igloo> And also allow UTF-8 in comments
07:31:50 <earthy> one thing I've noticed is that cabal does interesting things when a cabal file uses DOS line endings
07:32:07 <earthy> and that Visual Haskell actually does use DOS line endings in cabal files...
07:32:27 <Igloo> I think there have been patches to improve that, although I don't know if it's perfect yet
07:32:43 <earthy> yeah, I haven't tested with 6.6.1 yet
07:32:58 <earthy> the cabal that comes with 6.6 does have issues
07:33:58 <earthy> makes for 'interesting' development when you are codeveloping with 1 person on windows and 1 on mac os x. :)
07:38:26 <SamB> dcoutts: okay, I've sent the patch off now
07:39:04 <SamB> it is probably stuck in a moderation queue or something though
07:47:37 <dozer> I'm getting quite anoyed with GADTs :@
07:47:52 <dcoutts> SamB: cheers
07:47:54 <Cale> dozer: why?
07:48:06 <RyanT5000> how do i write a wrapper stub for a haskell function?
07:48:25 <RyanT5000> as in http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html#t%3AFunPtr
07:48:26 <lambdabot> http://tinyurl.com/3e42pm
07:48:47 <dozer> Cale: It seems like although there's a closed set of types they define, GHC is reasoning about them in functions and instance declarations as if they belong to an open set
07:49:25 <Cale> hmm
07:49:36 <Cale> RyanT5000: Isn't there an example right there?
07:49:46 <RyanT5000> Cale: doesn't it need C code to back it up?
07:49:57 <RyanT5000> or is "wrapper" a magic import name?
07:50:01 <Cale> magic
07:50:05 <RyanT5000> oh
07:50:24 <RyanT5000> that makes me sad in theory and happy in practice
07:50:37 <Cale> hehe
07:50:48 <RyanT5000> someday the quotes will come off?
07:51:16 <Cale> Perhaps :) The syntax is a little strange. I'm not sure what the quotes are really for anyway.
07:51:30 <RyanT5000> well normally it's the name of a C function, so i sort of understand the quotes
07:51:42 <RyanT5000> but what if you wanted to import a function named "wrapper"!
07:51:44 <Cale> Or the name of a C header file and then the name of a function
07:51:52 <RyanT5000> yeah, that's a little weird
07:52:08 <dozer> e.g:
07:52:09 <dozer> data Zero ; data Suc a; data ListWithLength a b where empty :: ListWithLength a Nill ; cons :: a -> ListWithLength a b -> ListWithLength a (Suc b)
07:52:33 <dozer> ghc seems to be treating ListWithLength a b as being open-world on b, when in fact it's closed world on b
07:53:56 <hpaste>  dolio pasted "static numeric checking" at http://hpaste.org/2010
07:54:23 <Saizan> well, nothing prevents you from writing (undefined :: ListWithLength Int Int)
07:54:34 <mrd> :t map (>>=)
07:54:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m a] -> [(a -> m b) -> m b]
07:55:01 <Cale> Saizan: exactly :)
07:55:05 <hpaste>  dolio annotated "static numeric checking" with "examples" at http://hpaste.org/2010#a1
07:55:18 <osfameron> @src sum
07:55:18 <lambdabot> sum = foldl (+) 0
07:55:25 <dozer> Saizan: ouch! but appart from _|_ which will fail when I invoke stuff on it anyway,
07:56:04 <Cale> Well, only if you force it to evaluate :)
07:57:04 <Saizan> however, why is this a problem for you?
07:57:22 <Cale> *Main> length ([undefined, error "a", error "b"] :: [ListWithLength Int Int])
07:57:22 <Cale> 3
07:57:48 <xerox> class Nat t; instance Nat Zero; instance Nat t => Nat (Succ t); data Nat b => LList a b where nil :: LList a Zero; cons :: a -> LList a b -> LList a (Succ b) -- maybe?
07:58:02 <Cale> classes are even more open-world
07:58:35 <Cale> I'm not sure exactly what the issue is though.
07:59:20 <Cale> Where do you need GHC to assume that the second type parameter is either Zero or Suc n?
07:59:25 <quicksilver> to answer the question about an hour and a half back, yes GHC makes only one single []
07:59:32 <quicksilver> which is shared by all types
07:59:37 <quicksilver> which is cute :)
07:59:58 <quicksilver> the power of type erasing...
08:00:19 <Cale> All lists have a common tail :)
08:00:25 <Cale> er, all finite lists anyway :)
08:00:53 <Saizan> is there also only one Nothing etc?
08:02:02 <Cale> It's kind of nice to imagine what that tree of allocated finite lists might look like for various programs.
08:02:13 <rehges> every Nothing shares all of its elements with every other Nothing :-)
08:02:47 <quicksilver> Saizan: I believe all nullaries are shared. No matter how polymorphic their types.
08:03:51 <Cale> Is [] shared with Nothing? :)
08:04:14 <ndm> @karma+ Igloo  -- finally giving out his guidelines for what makes sense
08:04:14 <lambdabot> Igloo's karma raised to 1.
08:04:30 <dozer> Cale: I'll try to put together a neat test case for my issue
08:04:40 <ndm> @karma+ Igloo -- because 1 is way too low - have you been trolling?!?
08:04:40 <lambdabot> Igloo's karma raised to 2.
08:04:52 <Cale> @karma
08:04:52 <lambdabot> You have a karma of 0
08:04:57 <Igloo> I think karma must have been reset at some point
08:05:01 <dolio> @karma dons
08:05:01 <lambdabot> dons has a karma of 1
08:05:13 <Igloo> Unless people were decrementing me in private  :-)
08:05:14 <Cale> We were attacked by the rajahs of erase!
08:05:30 <Syzygy-> o.O
08:05:33 <xerox> :(
08:05:42 <Syzygy-> @karma+ dons -- 1 is WAY too low for you.
08:05:42 <lambdabot> dons's karma raised to 2.
08:05:51 <Syzygy-> @karma+ dcoutts
08:05:51 <lambdabot> dcoutts's karma raised to 1.
08:05:54 <Syzygy-> @karma+ Igloo
08:05:55 <lambdabot> Igloo's karma raised to 3.
08:05:58 <Syzygy-> @karma+ xerox
08:05:58 <lambdabot> xerox's karma raised to 1.
08:06:03 <Syzygy-> @karma+ Cale
08:06:03 <lambdabot> Cale's karma raised to 1.
08:06:13 <mauke> @karma c
08:06:14 <lambdabot> c has a karma of 0
08:06:19 <mauke> yeah, that's way too low
08:06:33 <fax> @karma fax
08:06:33 <lambdabot> You have a karma of 0
08:06:38 <dcoutts> @karma- c
08:06:38 <lambdabot> c's karma lowered to -1.
08:06:43 <fax> I thought I had negative >:|
08:06:44 <Syzygy-> @karma Syzygy-
08:06:44 <lambdabot> You have a karma of 0
08:06:58 <Cale> @karma+ Syzygy-
08:06:59 <lambdabot> Syzygy-'s karma raised to 1.
08:07:01 <xerox> @karma+ Syzygy-
08:07:01 <lambdabot> Syzygy-'s karma raised to 2.
08:07:03 <Syzygy-> Wooot!
08:07:04 <Syzygy-> :)
08:07:06 <xerox> Summer of love!
08:07:15 <Cale> @karma+ xerox
08:07:15 <lambdabot> xerox's karma raised to 2.
08:07:18 <Syzygy-> @karma+ Cale -- Thanks for the karma
08:07:18 <lambdabot> Cale's karma raised to 2.
08:07:22 <Syzygy-> @karma+ xerox -- Thanks for the karma
08:07:22 <lambdabot> xerox's karma raised to 3.
08:07:28 <xerox> @karma+ Cale-- :-)
08:07:28 <lambdabot> Cale--'s karma raised to 1.
08:07:32 <xerox> oops.
08:07:37 <Cale> hehe
08:07:53 <Syzygy-> Now, of course, the question is how long we can stay silly and play with the karma machine before someone tries to impose order again.
08:08:51 <xerox> We should have karma to delete 0-karma figures.
08:09:08 <xerox> Then it should become easy to impose order.
08:09:45 <Syzygy-> Or, for the really BAD ideas, have a karma threshold on getting voice, and setting the channel +m
08:10:03 <hpaste>  msouth pasted "(failing) map lookup in happs" at http://hpaste.org/2011
08:11:19 <xerox> ?version
08:11:19 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
08:11:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:12:20 <msouth> I'm trying to use a simple map for state--I don't know if what I have would work or not, but I can't get it to compile because (I think) I'm calling it incorrectly (this is re http://hpaste.org/2011 )
08:12:43 <Tac-Tics> @type map
08:12:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:13:58 <Saizan> msouth: in HAppS you can't be in IO when you want to use the state, but you're not using IO there anyway
08:16:28 <Saizan> msouth: the standard approach is to use respond as the last action, on "concat [ ... ]" in this case, and use the "ok" function in the handlers list
08:17:43 <fax> hkBst: sit!
08:18:05 <phoniq> tsktsk
08:18:17 <SamB> my.
08:18:22 <msouth> Saizan: ok, trying that, thanks
08:18:23 <SamB> that's a lot of channels he's in
08:18:32 <fax> hkBst: You should not do that
08:18:39 <SamB> how about banning him?
08:19:00 <SamB> [hkBst] #ubuntu ##debian-boot #paludis #gentoo-alpha #gentoo-mips +#gentoo-ops #emacs #gentoo-bsd #friendly-coders +#gentoo-kde #einit +#gentoo-overlays #sabayon #nouveau #gentoo-commits #gentoo-releng @#gentoo-dev #gentoo-amd64 +#gentoo-bugs #gentoo-haskell #haskell @#gentoo-lisp #guile
08:19:18 <fax> how many did he get banned from? :p
08:19:22 <SamB> nevermind, I guess.
08:19:26 <SamB> he seems to have stopped
08:19:36 <hpaste>  Saizan annotated "(failing) map lookup in happs" with "like this, i mean" at http://hpaste.org/2011#a1
08:19:44 <SamB> hkBst: whatever you've been doing... don't do that!
08:19:57 <SamB> also try turning on flood control
08:21:39 <psykotic> @hoogle a -> (a, a)
08:21:39 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
08:21:40 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
08:22:01 <psykotic> @type id &&& id
08:22:03 <lambdabot> forall a. a -> (a, a)
08:22:11 <mauke> @type join (,)
08:22:13 <lambdabot> forall a. a -> (a, a)
08:22:31 <Tac-Tics> What is the difference between a -> (a,a) and forall a. a -> (a,a)?
08:22:36 <psykotic> none
08:22:45 <mauke> "forall" is not H98
08:23:06 <Tac-Tics> is there any difference in semantics?
08:23:06 <psykotic> you can think of all free type variables as being implicitly forall-quantified at the top
08:23:08 <Saizan> in the first the forall is implicit
08:23:13 <Tac-Tics> ah
08:23:48 <Tac-Tics> when would you ever use a non-forall quantified type variable?
08:24:12 <mauke> all type variables are forall'd
08:24:36 <mauke> @type runST
08:24:36 <Philippa> they come up in the inference process all the time (but get resolved to something else!), and an existentially-quantified type variable can be useful in systems that allow it
08:24:37 <Tac-Tics> I see
08:24:38 <lambdabot> Not in scope: `runST'
08:25:01 <mauke> @type Control.Monad.ST.runST
08:25:03 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
08:25:37 <Tac-Tics> I just started learning Haskell a few weeks ago. It is crazy and awesome.
08:25:55 <mauke> what languages do you know?
08:26:56 <Tac-Tics> I mainly use Python. I like it's clean syntax and One-Way mentallity. It makes code easy to read. I also do Java, PHP, a little C and C++
08:27:36 <Tac-Tics> I dabbled in Scheme for a while too, but the verboseness made me want to kill myself ^^;
08:27:38 <mauke> ah, so Haskell is your first Real Typesystem(tm) :-)
08:28:04 <Tac-Tics> If you don't consider Java or C++ to be real, then, yeah
08:28:06 <mrd> hm, who's (tm) is that
08:28:10 <mrd> whose
08:28:33 <mauke> Java doesn't have sum types. also, its arrays are borked
08:28:41 * fax hands mauke a nicely forged 
08:28:42 <mauke> C++ is a cruel joke
08:28:46 <mauke> ooh
08:29:34 <Tac-Tics> C++ is the only language whose error messages are more cryptic than GHC X-D
08:29:58 <mrd> ghc isn't so bad, it's just super verbose
08:30:00 <Tac-Tics> you miss a parenthesis in C++, and it tells you your children are going to be killed at school
08:30:05 <mauke> C++ is very efficient in that a single typo can cause several KB of errors
08:30:13 <mrd> because they are. who knows what will happen.
08:30:23 <Philippa> GHC's verbosity is oten useful, too
08:30:27 <mrd> that's called "powerful" programming
08:30:38 <Philippa> @remember mauke C++ is very efficient in that a single typo can cause several KB of errors
08:30:38 <lambdabot> Done.
08:30:50 <Philippa> @quote C++ efficient
08:30:50 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
08:30:55 <Philippa> @quote mauke
08:30:56 <lambdabot> mauke says: C++ is very efficient in that a single typo can cause several KB of errors
08:31:06 <Tac-Tics> ghc is just sometimes very subtle because of all the different ways you can use variables. high order, curried functions with monads = a lot of typing to worry about at once
08:31:06 <mrd> C had that property too.  i remember seeing tons of errors spring out of a single missed semi colon.
08:31:39 <mrd> well, GCC i mean
08:31:48 <Tac-Tics> C at least sweeps your type errors under the carpet
08:31:54 <Tac-Tics> and pretends everything is ok
08:32:01 <mrd> yes, that's a weak type system
08:32:04 <Tac-Tics> it provides short term mental releif
08:32:25 <Tac-Tics> weak = bad
08:32:33 <Tac-Tics> I have to use PHP at my job and it makes me want to stab my eyes out
08:32:36 <mrd> well it leads to derangement and ulcers down the line
08:32:38 <Tac-Tics> strings aren't ints
08:32:51 <mauke> arrays are hashes
08:32:54 <mauke> war is peace
08:33:04 <Tac-Tics> I like python and scheme's typing, where you can pretend things are whatever until you try to use them
08:33:12 <mrd> Newspeak would make a good prog lang name
08:34:07 <arcatan> Haskell would make a good prog lang name.. oh wait1
08:34:42 <Tac-Tics> Haskell was so cool he got TWO proglangs named after him
08:34:49 <mauke> quote from ##c++: "don't you mean paskell?"
08:34:52 <arcatan> Schnfinkel
08:34:59 <fax> lol
08:35:08 <mrd> i avoid saying haskell in RL for that reason
08:36:03 <dolio> Well, Haskell and Pascal are so similar, they're easy to confuse.
08:36:26 <mrd> yea of course. they're both programming languages.  and that's close enough to confuse the people who don't already know the difference.
08:36:44 <mauke> I pronounce them rather differently
08:37:33 <mrd> i recently had a guy ask me if Matlab was an example of a functional programming language
08:39:42 <Syzygy-> Wow.
08:39:49 <dolio> What'd you say?
08:39:51 <Syzygy-> I just got offered money for including ads on my blog.
08:40:09 <fax> Syzygy-: link to blog?
08:40:20 <Syzygy-> http://blog.mikael.johanssons.org
08:40:25 <fax> cheers
08:40:33 <Syzygy-> It's on the planet too, y'know. :)
08:40:35 <lambdabot> Title: Michi&#8217;s blog
08:40:37 <mrd> i had to re-explain what i meant by mathematically oriented
08:41:19 <dolio> Matlab doesn't really do higher order functions, does it (it's been a while since I've used it)?
08:41:43 <mrd> matlab, what i've seen of it, is a throwback to the stone ages of imperative programming
08:42:02 <RyanT5000> mrd: it's supposed to be good with arrays; i think that's about it
08:42:19 <RyanT5000> it doesn't even have a scalar datatype
08:42:34 <RyanT5000> just 1x1 arrays, which can be treated as scalars
08:42:34 <gkr> Does anyone here owns a copy of Richard Bird's Introduction to functional programming using Haskell (in English)?
08:42:37 <RyanT5000> (i think, anyway)
08:42:41 <mrd> it's a solid argument for why mathematicians should never be allowed to design programming languages
08:43:09 <mrd> well, certain kinds
08:43:27 <Igloo> gkr: I think I do, although I can't immediately find it. Why do you ask?
08:43:30 <Tac-Tics> I think mathematicians are the best fit for designing obscure functional languages ;-)
08:43:50 <mrd> it depends how you label computer scientists vs mathematicians i guess
08:44:01 <RyanT5000> i think matlab is more engineers than mathematicians
08:44:11 <mrd> yea i was thinking of number crunchers
08:44:20 <tc1> ndm: Is it it possible to "or" queries together, such that only one traversal is necessary?
08:44:40 <gkr> Igloo my copy is translated to Spanish, and I want to know if where he explains strict and head normal form is actually head normal form or weak head normal form (and therefore, some kind of mistake of the translator)
08:45:29 <hpaste>  dozer pasted "GADTs again" at http://hpaste.org/2012
08:45:33 <ndm> tc1, i don't think so, i looked at it briefly, but no really
08:45:40 <ndm> tc1, unless you use rewrite, which no one does
08:45:57 <dozer> Cale: so I've got a small example here of the sort of thing that seems to go wrong for me
08:46:00 <tcr> ndm: tc1 is me
08:46:06 <Cale> dozer: sure
08:46:10 <Igloo> gkr: Hmm, can't fnid it, but WHNF is almost certainly right
08:46:26 <ndm> tcr, i guessed :) - i did some generic extensible transformations, but they are complex, i'd just use two invokations of transform
08:46:59 <dozer> Cale: the doubleUp operation has to be modelled in a class - I can't make a normal function polymorphic in the right ways
08:47:00 <tcr> ndm: transform? I'm talking about queries.
08:47:21 <ndm> tcr: oh, can you give me an example of what you are doing?
08:47:29 <ndm> using "universe" ?
08:47:51 <tcr> ndm: Aye
08:48:21 <ndm> you can do x = universe y, then use x twice
08:48:30 <Cale> dozer: Why does the DoubleUp class not have a functional dependency?
08:48:55 <yakov> hi all
08:49:14 <tcr> ndm: I want to get every datum of a certain type (which consists of several constructors)
08:49:23 <ClaudiusMaximus> gkr: i have the english version (2nd edition) here, doesn't mention "weak head normal form" at all in that section (only "normal form" and "head normal form")
08:49:32 <yakov> guys, please. I need a recipe from you. which book you can consider as best book on haskell. i have a candidate here http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460/ref=sr_1_1/104-7582308-1064713?ie=UTF8&s=books&qid=1185983226&sr=1-1
08:49:36 <lambdabot> http://tinyurl.com/2mbskj
08:49:36 <Cale> dozer: I should also point out that someone evil might come along and define an instance of your "Even" class at any point for Suc Zero
08:49:39 <ndm> tcr: that sounds dead easy, universeBi x :: [Wanted_Type]
08:49:43 <yakov> (simple, I want to buy one from amazon.)
08:49:43 <dozer> Cale: if I add | a -> b to it, I get: Illegal instance declaration for `DoubleUp (Suc e) (Suc (Suc f))' (the Coverage Condition fails for one of the functional dependencies) In the instance declaration for `DoubleUp (Suc e) (Suc (Suc f))'
08:50:06 <ndm> in the generics benchmark program, quite a few of the example programs boil down to "universeBi" on its own
08:50:08 <fax> yakov: I'd recommened reading every book on the subject you can get in a library first
08:50:24 <gkr> Igloo thanks.
08:50:26 <RyanT5000> dozer: you might want to look at the bug report involving the "Weak Coverage Condition"
08:50:46 <tcr> ndm: Uh.. alright, how does that work?
08:50:47 <RyanT5000> ghc 6.6.1 overenforces the coverage condition, if i understand correctly
08:51:19 <ndm> tcr: you want to take a Foo, which may have Bar's inside it, and get all the Bar's? universeBi x :: [Bar] does that
08:52:29 <ClaudiusMaximus> gkr: "for example, e1:e2 is in head-normal form but is in normal form only when e1 and e2 are both in normal form" -- i think that is WHNF, right?
08:53:21 <tcr> ndm: Yeah, but I'm interested how that is supposed to work... seems like magic to me.
08:55:50 <DukeDave> Hi all, can anyone who has a spare minute just confirm an issue for me before I fire a mail off to cafe?  It's here:
08:55:53 <hpaste>  DukeDave pasted "GLUT Crash" at http://hpaste.org/2013
08:56:04 <RyanT5000> Cale: is there a good reason not to use a wrapper once using unsafePerformIO at the top level, and then just keep reusing the result?
08:56:24 <mrd> typo?
08:57:08 <dozer> RyanT5000: ok - I found the bug http://hackage.haskell.org/trac/ghc/ticket/345 was this what you where thinking of?
08:57:09 <lambdabot> Title: #345 (GADT - fundep interaction) - GHC - Trac
08:57:11 <ndm> tcr: type classes, it "just works", in a similar way to read, read :: String -> a, and figures out the appropriate "a" given how you use it
08:57:15 <DukeDave> mrd: You thinking about the 'Exectuion'  ?
08:57:34 <mrd> yea
08:57:40 <mrd> obviously that wont compile
08:58:01 <DukeDave> Heh, it's actually a typo in the GLUT api :|
08:58:08 <Cale> dozer: Out of interest, which version of ghc are you using?
08:58:13 <DukeDave> I sent a mail off to their list but I haven't heard anything back..
08:58:15 <mrd> blah
08:58:43 <dozer> Cale: 6.6, as I've so far utterly failed to get the trunk to both build and the libraries to build
08:58:56 <DukeDave> It's just making debugging a nightmare as I have to keep reloading. That and that fact that there's something broken ;)
08:59:15 <tcr> ndm: universeBi descends lists, doesn't it?
08:59:28 <Cale> dozer: You can download binary snapshots of 6.7
08:59:31 <xerox> Compiling hs-plugins: src/System/Plugins/Load.hs:80:0: Failed to load interface for `GHC.Prim' any idea?
08:59:53 <ndm> tcr: it descends everything
08:59:53 <Cale> dozer: But yeah, I'm not sure how well-integrated GADTs and typeclasses are in 6.6
09:00:27 <dozer> Cale: if I did that, would I have to go thrugh some magick to get all the packages that are currently available to 6.6 to also be available to 6.7?
09:00:28 <xerox> Does it need some extension?
09:00:51 <tcr> ndm: Yeah, but list in particular. :) Alright, thank you very much! that casting trick is pretty nice!
09:01:31 <ndm> tcr: no probs, glad its of use :)
09:01:32 <msouth> Saizan: thanks again, we got it running.
09:01:35 <cjs> Anybody got a sec for a beginner question?
09:01:39 <hpaste>  cjs pasted "quotedCharMap" at http://hpaste.org/2014
09:02:01 <ndm> cjs: go on
09:02:04 <Saizan> msouth: did you understand the problem?
09:02:36 <cjs> How do I "get the char out of the Maybe monad"? Is that even the right question, or a sensible one?
09:02:38 <Cale> dozer: You'd have to install them -- I think the installations are generally separate.
09:02:47 <mauke> cjs: yes
09:03:01 <mauke> except you don't want to use the monadness of Maybe here
09:03:02 <ndm> cjs: when you do a lookup, you mean?
09:03:08 <cjs> Yeah.
09:03:15 <mauke> you can do it with pattern matching or the fromJust function
09:03:15 <ndm> @hoogle Maybe a -> a
09:03:16 <cjs> I'm trying to replace that case.
09:03:20 <lambdabot> Maybe.fromJust :: Maybe a -> a
09:03:20 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
09:03:20 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
09:03:28 <Syzygy-> mauke: Or maybe.
09:03:38 <mauke> Syzygy-: he doesn't have a default case
09:03:42 <Syzygy-> Ah.
09:03:45 <ndm> Hoogle can tell you the answer, along with some alternatives, i.e. fromMaybe if you want a default
09:03:51 <Syzygy-> So then what does he want to do with Nothing?
09:03:54 <ndm> fromJust should be sufficient then
09:03:55 <dozer> Cale: that's where it always goes wrong for me - I run aground because things from darcs don't build for me, so I can't build + install them on a new version of ghc
09:03:56 <cjs> No. I think there's no need for one...
09:04:01 <ndm> Syzygy-: he has statically eliminated it
09:04:03 <mauke> Syzygy-: can't happen in his code
09:04:06 <Syzygy-> Ah.
09:04:08 <ndm> oneOf $ fst $ unzip quotedCharMap
09:04:10 <Syzygy-> Then just use fromJust.
09:04:19 <Cale> dozer: hm?
09:04:22 <Syzygy-> Is what I would do...
09:04:22 <ndm> i would have written that as: oneOf $ map fst quotedCharMap
09:04:24 <Cale> dozer: Why is that?
09:04:40 <mauke> I'd probably do it differently: parse any char, do the lookup, and maybe fail here
09:04:43 <msouth> Saizan: I knew I was calling it wrong, that was about it.  But from what you said I think that when I had that "respond" in front, the code running in there did not have access to the HAppS saved state.
09:04:58 <msouth> I'm still very new to haskell in general
09:05:15 <mux> hmpf, what should I use to convert a number of seconds representing a duration to a human-readable string
09:05:21 <dozer> Cale: no idea - last time network refused to build - was not matching the system library that provides socket/fd handling
09:05:29 <mux> TimeDiff's are surprisingly useless
09:05:30 <CosmicRay> mux: I have code to do that in MissingH
09:05:32 <Cale> dozer: Anyway, I'm just installing 6.7, I'll see if I have any more luck with it.
09:05:40 <dozer> thanks - let me know :)
09:06:01 <CosmicRay> mux: http://software.complete.org/missingh/static/doc/System-Time-Utils.html#v%3ArenderSecs
09:06:01 <cjs> After an "import Maybe", fromJust did the trick. Yay!
09:06:03 <lambdabot> http://tinyurl.com/2gn9f5
09:06:05 <CosmicRay> renderSecs 121 = "2m1s"
09:06:05 <Saizan> msouth: yeah, that's the point, to be able to see why you probably need more experience with types
09:06:12 <mux> CosmicRay: thanks
09:06:35 <dozer> cjs: can you give me some example input/output pairs for your code please?
09:06:42 <cjs> (I'm finding learning Haskell to be a series of very small, sometimes painful, victories, day by day.)
09:06:46 <mux> @source System.Time.Utils
09:06:46 <lambdabot> System.Time.Utils not available
09:06:53 <Tac-Tics> cjs: Isn't that the truth
09:07:16 <CosmicRay> mux: download missingh from http://software.complete.org/ or the hackageDB at http://hackage.haskell.org/packages/hackage.html
09:07:17 <lambdabot> Title: Available Projects
09:07:23 <cjs> \n -> 'n', \" -> '"', \z -> "\z"
09:07:58 <mux> the darcs link in hackage is really overdue
09:08:11 <CosmicRay> see also http://software.complete.org/missingh/browser/src/System/Time/Utils.hs
09:08:13 <lambdabot> Title: /src/System/Time/Utils.hs - MissingH, http://tinyurl.com/3cgd7j
09:08:29 <cjs> Err...I'm not sure how to quote that sensibly when talking in English. Basically, if it's a backslash followed by something I know, I parse the pair as a char. Otherwise I parse it as an ordinary backslash followed by the ordinary char. Well, I think that the map should make it clear.
09:08:33 <xerox> What's the GHC extension needed to use GHC.Prim ?
09:10:04 <desegnis> xerox, will -package ghc -fglasgow-exts do?
09:10:17 <cjs> Oh, that hoogle trick (searching by type signature) is cool.
09:10:26 <cjs> Stuff like that is going to make my life *way* easier.
09:10:38 <mauke> cjs: do { char '\\'; c <- anyChar; case lookup c bsMap of { Just c' -> return [c']; Nothing -> return ['\\', c] } }  -- pseudocode
09:11:58 <cjs> Now, as to " fst $ unzip quotedCharMap" versus "map fst quotedCharMap", isn't there something to do both, what we would call the "keys" function in Ruby?
09:12:00 <dozer> cjs: try something like: fromMaybe ['\', c] (lookup c quotedCharMap)
09:12:09 <Cale> cjs: Yeah, hoogle's not perfect, but it's useful when it works :)
09:12:37 <mauke> cjs: yes, if you use a real Map instead of a list
09:12:51 <xerox> desegnis: hmm, -package ghc is broken here, hmpf.
09:12:58 <dozer> cjs: lookup should do the scan through your list of pairs for you
09:13:14 <xerox> ghc-6.7.20070714: /usr/local/lib/ghc-6.7.20070714/lib/hpc-0.5/HShpc-0.5.o: unknown symbol `hs_hpc_rootModule'
09:13:14 <cjs> I use lookup.
09:13:26 <mauke> then you don't need to extract the keys
09:13:46 <Cale> cjs: If you're doing lots of lookups, it's a bad idea to use lists of pairs. (Performance-wise)
09:13:53 <cjs> Yes I do, because I also need just a list of keys to pass to oneOf so that I don't match if the key doesn't exist.
09:14:13 * SamB_XP_ wonders why adobe wants him to install the google toolbar along with the flash player
09:14:19 <mauke> cjs: no, why?
09:14:20 <cjs> Keep in mind, I've been programming Haskell for some five or six hours now.
09:14:21 <Cale> :t lookup
09:14:26 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:14:27 <dozer> cjs: that 'if one doesn't exist' is what the 'fromMaybe' handles
09:14:29 <mauke> cjs: lookup tells you when a key doesn't exist
09:14:42 <cjs> I'm not terrifically concerned with performance at this point. :-)
09:14:47 <dozer> :t fromMaybe
09:14:49 <lambdabot> forall a. a -> Maybe a -> a
09:14:59 <Cale> :t maybe
09:15:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:15:05 <mux> CosmicRay: it appears timeDiffToString . normalizeTimeDiff is enough for me
09:15:17 <DukeDave> Anyone here have any experience rendering text with GLUT?
09:15:34 <Cress> :t adjust
09:15:36 <lambdabot> Not in scope: `adjust'
09:15:38 <cjs> You guys are taking into account that this is part of a Parsec grammar, right?
09:15:43 <mauke> yes
09:15:59 <cjs> Ok. I'm just missing stuff here, then.
09:16:07 <desegnis> xerox, hm. send a bug report? ;-)
09:16:09 <mauke> what's the parsec function that accepts any character?
09:16:20 <SamB_XP_> @hoogle anyChar
09:16:21 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
09:16:28 <mauke> excellent
09:18:19 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2015
09:18:24 <cjs> Try working from that.
09:18:27 <chessguy> parsec is awesome
09:18:45 <mauke> eww
09:18:51 <Cress> Is it possible to use Data.Map.update inside an IO monad, using an IO update function?
09:18:58 <Cress> :t Data.Map.update
09:19:01 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
09:19:17 <Cress> so using (a -> IO (Maybe a))
09:19:22 <xerox> Cress: no you can't
09:19:26 <chessguy> cjs, are you working through the Scheme tutorial?
09:19:35 <bartw> sobs in a corner because of javascript
09:19:40 <cjs> Yeah.
09:19:56 <Cress> xerox: ok, thanks.
09:19:57 <chessguy> cjs, mmm, that's not recommended for your first day of haskell...
09:20:14 <cjs> BTW, any thoughts on how I get hpaste to remember me? It doesn't appear to be sending me a cookie.
09:20:27 <chessguy> bartw, what's wrong with javascript?
09:21:07 <cjs> Well, I've tried to go through several other tutorials, and I keep bogging down really quickly. This one appeals to me because I can do the sort of stuff I do when I program for a living, as opposed to implement obscure and odd graphics systems.
09:21:11 <bartw> chessguy : crashing browsers, slow, only the spychic debugger seems to work
09:21:49 <cjs> If I can get to the point where I use Haskell for little Unix utilities and stuff, I'll move along a lot faster.
09:22:04 <bartw> and it is way way way too easy to type something that looks right but is wrong but still runs
09:22:27 <chessguy> cjs, the scheme tutorial gets very difficult very quickly
09:22:31 <mauke> @hoogle noneOf
09:22:31 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st Char
09:22:40 <Tac-Tics> bartw, I think all of the Internet is that way. Not just JS
09:22:44 <cjs> Yeah. Like at the second set of exercises. You mean it gets even worse than this?
09:22:48 <mux> mm, the current pattern views proposal would be handy to run fromIntegral and stuff directly in the pattern
09:23:07 <mux> foo (fromIntegral -> x) (fromIntegral -> y) = x / Y
09:23:14 <bartw> Tac-Tics : expect that i now have a project of about a man year of porting a desktop application to qooxdoo
09:23:19 <Tac-Tics> If there is a single successful website that is 100% WC3 standards compliant, I would like to see it
09:23:20 <hpaste>  mauke annotated "(no title)" with "how I'd do it" at http://hpaste.org/2015#a1
09:23:22 <mux> and then I could foo (10::Int) (3::Int)
09:23:24 <mauke> cjs: ^
09:23:32 <chessguy> cjs, maybe take a look through a few of these: http://www.haskell.org/haskellwiki/Special:Search
09:23:33 <lambdabot> Title: Search results - HaskellWiki
09:24:09 <RyanT5000> bartw: i am currently writing a haskell binding for JSAPI, i'm sure you'll be happy to hear :)
09:24:20 <bartw> RyanT5000 : :)
09:24:36 <RyanT5000> (i needed to be able to run random code from strangers without even asking the user)
09:25:00 <cjs> Anyway, if I can just get to the point where I can munge text files, I'll be able to use it in my daily work, and that will be a huge boost to progress.
09:25:20 <RyanT5000> (it's surprisingly difficult to find something that will let you reliably and safely do that)
09:25:34 <mauke> if you just need filters,  main = interact foo  and you're done
09:26:39 <xerox> mauke: does interact call its argument function on every string in input?
09:26:39 <Cale> dozer: Yeah, even 6.7 isn't smart enough to infer that. Btw, the switch you need to get it to accept the fundep is -fallow-undecidable-instances
09:27:03 <mauke> xerox: technically, yes. there's only one string in the input, however.
09:27:14 <dozer> thx Cale, it usually asks me to add that btw
09:27:46 <cjs> I seem to recall not getting very far with interact last time I tried it. Anyway, I'm making progress here, so I'll plow along a bit longer before I switch to something else.
09:28:12 <Cale> Oh, I see why.
09:28:35 <Cale> It's complaining that the Nill on the RHS of doubleUp isn't sufficiently polymorphic.
09:28:53 <cjs> Anyway, bedtime. Thanks for the clue.
09:29:11 <Cale> Ah, no, it really should be able to infer that's okay :)
09:29:32 <dozer> hehe - I thought it should be able to
09:29:46 <Cale> doubleUp :: (Twice b c) => ListWithLength a b -> ListWithLength a c
09:29:46 <dozer> shall I clean it up and post as a bug?
09:30:04 <Cale> For that case, b = Zero, and then the fundep ensures that c = Zero
09:30:09 <Cale> and so it should be okay
09:30:32 <andyjgill> "I managed to import and title Simon's talk last night, and I'm reviewing the videos today. I should have these up on oscon.blip.tv today if all goes well!" - Brain from Oreilly about SPJ video.
09:30:40 <chessguy> @instances-importing Twice
09:30:41 <lambdabot> Couldn't find class `Twice'. Try @instances-importing
09:31:33 <Cale> dozer: As you might have guessed, trying to simulate dependent types in Haskell's type system is a pain at best.
09:32:00 <dozer> Cale: yup :( and here was I thinking that GADTs would actually be useful for something
09:32:23 <dozer> Cale: all they seem to do for me in practice is cause everything but the simplest uses to explode
09:32:39 <matthew-_> dozer: they really are! (I've not been following this - are you using ghc 6.7?)
09:33:34 <matthew-_> dozer: if you're not using ghc 6.7, then do - it's much much better at propogating contexts from GADTs which tend to make quite a lot of difference when doing type trickery
09:33:43 <Cale> I don't think they're really intended to help you simulate dependent types so much as just hijack Haskell's typesystem for your own embedded languages.
09:34:08 <dozer> matthew-_ I'm on 6.6, but Cale has recreated my problems on 6.7
09:34:29 <matthew-_> dozer: ahh ok. I have code doing crazy type thingies that only works in 6.7
09:34:29 <Cale> matthew-_: In this case it still fails in 6.7 -- it needs to make use of a functional dependency as well as the GADT constraint.
09:35:05 <matthew-_> ok, sorry - I should have paid attention to you guys earlier
09:36:01 <Cale> http://hackage.haskell.org/trac/ghc/ticket/345
09:36:02 <lambdabot> Title: #345 (GADT - fundep interaction) - GHC - Trac
09:36:37 <Cale> The example there is almost exactly the same as ours :)
09:36:48 <dozer> does look like it
09:37:10 <Cale> It's high priority too :)
09:37:26 * osfameron notes that prime sieving by wrapping successive filters gets deep-recursive rather quickly...
09:37:30 <xerox> Is there a simple way to tell cabal to use ghc-6.6 if I the last ghc I installed is ghc-6.7?
09:37:51 <matthew-_> Cale: err, I have a working list module which does append correctly
09:38:44 <matthew-_> ahh, ok, in my module, Append is a type class
09:38:47 <Cale> xerox: Perhaps it's enough to make sure that 'ghc', 'ghci', 'ghc-pkg' etc. point to 6.6
09:39:33 <desegnis> ./Setup.lhs -w PATH might do (just for the record)
09:39:59 <dozer> xerox: you will probably need the right things in your path when you run ./Setup.hs configure
09:40:01 <xerox> checking for ghc library directory... /usr/local/lib/ghc-6.7.20070714
09:40:10 <xerox> this is the only place it seem to get wrong with -w
09:41:42 <xerox> and --libdir /usr/lib/ghc-6.6 doesn't quite fix it, hmmm.
09:41:49 <desegnis> hm
09:43:17 <Cale> xerox: which ghc-pkg
09:43:29 <xerox> configure: Using package tool: /usr/lib/ghc-6.6/bin/ghc-pkg
09:43:35 <Cale> hmm
09:43:54 <Cale> how about just ghc?
09:44:05 <Cale> $ which ghc
09:44:09 <xerox> configure: Using compiler: /usr/lib/ghc-6.6/bin/ghc
09:44:21 <xerox> It gets everything right except that one.
09:44:26 <xerox> But it built, hmm!
09:44:27 <Cale> Check that your shell agrees with configure.
09:44:33 <matthew-_> dozer, Cale: http://www.wellquite.org/non-blog/sessions-browseable/Control/Concurrent/Session/List.hs is how I did it, if it's at all relevent/useful
09:44:36 <lambdabot> http://tinyurl.com/3e4e2y
09:45:30 <Cale> matthew-_: Yeah, it's a bad interaction between typeclasses with functional dependencies and GADTs
09:46:10 <Cale> xerox: I just moved all the stuff in /usr/local/bin out of the way after installing, and it seems to use ghc-6.6 for everything.
09:46:12 <matthew-_> sure, I realise it's more general...
09:47:52 <xerox> Cale, actually, it works, it might be one of those configure called after another configure that only dons know how to handle :-)
09:49:39 <xerox> It's easier to give runghc6 Setup.hs configure a flag that move around links every time.
09:53:58 <tuukkah> does someone know what the name after HELO is used for in SMTP? happs calls it "relay"
09:55:26 <xerox> That's the sender's hostname, in theory.
09:55:31 <tuukkah> rfc2821 says "the fully-qualified domain name of the SMTP client if one is available."
09:55:48 <tuukkah> xerox :-) is it used for anything in practise?
09:56:04 <xerox> tuukkah: no, it's mostly ignored.
09:57:51 <rehges> you should be using EHLO, not HELO
09:57:54 <desegnis> alright, xerox, I gave lambdabot a go again
09:57:55 <desegnis> some things work, many don't.
09:57:56 <tuukkah> exim4 claimed it was a syntax error to put "localhost HAppS" there
09:58:23 <xerox> desegnis: I finally had everything working, my patch as well, and send it. Thanks :-)
09:58:56 <tuukkah> rehges, smtp sending part in HAppS doesn't seem to be very sophisticated yet
09:59:05 <desegnis> xerox, it doesn't look like I was of much use to you, actually
10:00:11 <rehges> tuukkah: obviously :-)
10:01:16 <RyanT5000> so, i'm pretty confused
10:01:37 <RyanT5000> i'm calling JS_Init, which is in libmozjs, which allocates a Runtime
10:01:49 <RyanT5000> Word32 -> IO (Ptr Runtime_)
10:02:11 <RyanT5000> then i'm immediately calling JS_Finish :: Ptr Runtime_ -> IO ()
10:02:17 <RyanT5000> which deallocates it
10:02:22 <RyanT5000> and i'm getting a segfault
10:02:58 <RyanT5000> could this be due to having a statically and a dynamically linked libc or something?
10:03:05 <RyanT5000> i.e.: weirdly interacting heaps
10:21:48 <glguy> Best. Class. Ever:
10:21:48 <glguy> public class FactoryFactory extends Tool
10:22:11 <ihope> Oh my.
10:22:19 <xerox> Ready for thedailywtf? (:
10:23:42 <arcatan> http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html
10:23:44 <lambdabot> Title: RequestProcessorFactoryFactory (Apache XML-RPC 3.1-SNAPSHOT API), http://tinyurl.com/26scz4
10:24:02 <Nafai> I've written a FactoryFactory before, sadly :(
10:24:28 <profmakx> but the all shiny new FactoryFactoryFactory :(
10:24:37 <profmakx> hm... what about a monadic factory?
11:01:42 <Nafai> Yay, I was bored and now I found video of part 1 of SPJs talk at OSCON
11:03:14 <xerox> The one in the topic?
11:05:39 <shachaf> xerox: No, the one in the topic is different, I think.
11:05:47 <shachaf> @wiki OSCON Videos
11:05:47 <lambdabot> http://www.haskell.org/haskellwiki/OSCON_Videos
11:06:19 <Nafai> http://blip.tv/file/324976
11:06:19 <shachaf> @wiki Video presentations
11:06:19 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
11:06:20 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
11:06:33 <shachaf> Nafai: Yes, that's the one I saw.
11:06:40 <xerox> That's the afternoon talk?
11:06:57 <shachaf> It's not on the wiki page yet; someone (else) should add it.
11:07:53 <RyanT5000> wow i hate side effects
11:08:33 <xerox> Can it be downloaded?
11:08:34 <RyanT5000> using mozilla's javascript implementation: if i allocate and deallocate a js runtime 128 times, it works fine
11:08:44 <RyanT5000> #129, it returns a null pointer
11:09:54 <xerox> Yes it is, nice.
11:13:29 <DRMacIver> RyanT5000: Nice. :)
11:13:51 <RyanT5000> DRMacIver: yeah, it's pretty sweet
11:18:44 <shapr> @yow !
11:18:44 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
11:18:47 <shapr> What's goin on?
11:19:33 <Nafai> Hey shapr!
11:19:58 <shapr> hiya Nafai!
11:20:22 <EvilRanter> @ghc
11:20:23 <lambdabot> ghc says: Offending Program
11:23:25 <mrd> @ghc
11:23:25 <lambdabot> ghc says: scavenge: unimplemented/strange closure type
11:23:40 <DRMacIver> What on earth does @ghc do?
11:23:47 <mrd> quotes by ghc
11:24:08 <shachaf> @quote ghc
11:24:08 <lambdabot> ghc says: Illegal overloaded type signature(s)
11:24:12 <DRMacIver> Ah
11:24:20 <arcatan> @yow
11:24:21 <lambdabot> Is something VIOLENT going to happen to a GARBAGE CAN?
11:24:41 <mrd> just like 'yow' is error messages from a compiler named zippy
11:24:56 <shachaf> There should be @olegfacts sometime, rather than having them in @quotes.
11:25:00 <shachaf> @quote OlegFacts
11:25:00 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
11:25:11 <fax> :D
11:25:28 <fax> @quote fax
11:25:29 <mrd> what would constitute an Oleg-hard problem?
11:25:29 <lambdabot> No quotes match. I feel much better now.
11:25:34 <fax> @quote headache
11:25:34 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:25:40 <fax> :[
11:25:59 <mrd> all problems in Oleg reduce to it
11:26:27 <RyanT5000> mrd: wouldn't that be "Oleg-complete"?
11:26:32 <shachaf> @quote OlegFacts
11:26:32 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
11:26:35 <shachaf> @quote OlegFacts
11:26:35 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
11:26:36 <mrd> only if it is also in Oleg
11:26:37 <shachaf> @quote OlegFacts
11:26:37 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
11:26:43 <shachaf> They're all gone!
11:26:45 <shachaf> @quote OlegFacts
11:26:45 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
11:29:00 <newsham> NP log NP
11:29:52 <newsham> = NP (log (exp N)) = NP
11:29:59 <newsham> qed
11:30:30 <mrd> NP = P^Oleg perhaps
11:31:50 <chessguy> @quote oleg
11:31:50 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
11:51:11 <lament> What is the operation >> called?
11:51:49 <twanvl> then?
11:51:53 <xerox> `and-then' ? `bind-ignore-result' ? :-)
11:51:54 <shachaf> lament: I call it >>. :-)
11:52:05 <shachaf> lament: I've heard "anonymous bind".
11:52:08 <lament> then is nice, although a little overloaded :)
11:52:24 <lament> and-then is nice, thanks
11:52:41 * Cale is writing another article on monads right now :)
11:53:05 <Cale> I should really do this while slightly more awake than I am. I only got 4 or so hours of sleep.
11:56:01 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation -- not quite finished, but people can have a look regardless
11:56:02 <lambdabot> Title: Monads as computation - HaskellWiki
11:56:24 <Nafai> A function that is infix in Haskell is defined by putting the name in (), right?
11:56:46 <ibid> Nafai: or you can just define it in infix
11:56:47 <SamB> Nafai: can be
11:56:57 <SamB> if you want to define it pointless, yeah
11:56:57 <Cale> [] ++ ys = ys
11:57:09 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
11:57:16 <Cale> For example :)
11:57:16 <Nafai> I'm watching The Taste of Haskell talk
11:57:22 <Nafai> He's got
11:57:30 <Nafai> (++) :: [a] -> [a] -> [a]
11:57:31 <ibid> Nafai: note that putting it in parens does not make it infix if it isn't already :)
11:57:47 <Nafai> Is it the function body that determines the infix then?
11:57:54 <chessguy> @src (++)
11:57:55 <lambdabot> (++) []     ys = ys
11:57:55 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:57:58 <Nafai> So I can't tell just from the type?
11:58:00 <ibid> Nafai: no, the lexical form of the name
11:58:06 <Igel> dons: sry for asking once more :)
11:58:12 <desegni1> Nafai, alphanumerical names are prefix
11:58:17 <ibid> Nafai: if it's a string of symbols, then it's infix
11:58:20 <Igel> how does the passwd.rc have to look like?
11:58:22 <Nafai> Okay
11:58:27 <SamB> also parenthesized infix names are prefix names
11:58:29 <Igel> concerning lambdabot i mean
11:58:29 <ibid> Nafai: as desegni1 said, alnums are preix
11:58:34 <Cale> Igel: "password"
11:58:35 <SamB> (as long as they were the primitive kind)
11:58:41 <Nafai> Okay, makes sense
11:58:43 <SamB> er.
11:58:53 <desegni1> Nafai, `f` is infix (backquotes)
11:59:00 <ibid> Nafai: you can also use prefix names as infix by putting them in backquotes
11:59:03 <Nafai> That's right...I remember reading it
11:59:05 <Igel> Cale: just the pw, or password followed by whitespace and the pw?
11:59:07 <Nafai> s/it/that/
11:59:07 <SamB> basically...
11:59:12 <Cale> Igel: the password in quotes
11:59:13 <ibid> Nafai: and the parens trick is just the inverse, making infix prefix
11:59:14 <Nafai> Thanks!  That's a lot clearer now
11:59:19 <fax> Is >> not a paradox?
11:59:21 <Igel> Cale: thanks :)
11:59:27 <Cale> fax: hm?
11:59:31 <ibid> fax: how so?
11:59:31 <kuribas> Is there an indentation style prefered by most haskellers?
11:59:38 <fax> because its a lazy language so how can compute somthing, then throw away the value
11:59:41 <SamB> prefixName = alpbabeticName | '(' infixName ')'
11:59:46 <SamB> erg.
11:59:47 <fax> I would think that the value would never be computed
11:59:52 <SamB> Nafai: arg.
11:59:54 <Cale> fax: >> is defined by each monad separately.
11:59:59 <SamB> Nafai: just read the report already ;-P
12:00:16 <Nafai> I could...seems like it might be over my head :)
12:00:30 <SamB> well, read the part about infix and prefix operator syntax
12:00:30 <Cale> fax: So it gives some way to combine the two "computations", where the first is "run" (whatever that means for the given monad), then the second.
12:00:33 <ibid> fax: thinking of it as paradox means that one hasn't understood laziness completely :)
12:00:39 <SamB> you don't need to read the whole thing ;-)
12:00:56 <Cale> fax: Are you reading my current unfinished work? :)
12:00:59 <ibid> fax: laziness is a specific technical point, not a magic wand.  i made that mistake myself when i was young :)
12:01:01 <chessguy> Cale, where you have this:
12:01:02 <chessguy> In fact, once we have bind, we can always define (>>) as:
12:01:02 <chessguy> x >> y = x >>= (\k -> y)
12:01:05 <SamB> er. operator and function syntax.
12:01:13 <fax> yeah I am
12:01:16 <chessguy> it might be clearer to say x >> y = x >>= (\_ -> y)
12:01:24 <Tac-Work> ibid: You look me in the eye and tell me infinite lists aren't magical
12:01:24 <Cale> fax: Okay, so perhaps I should be clearer on that point.
12:01:27 <fax> ibid: I thought lazy meant call by value
12:01:41 <ibid> fax: no, it means call by need
12:01:43 <Cale> chessguy: For some reason I don't really like the _ pattern in lambda.
12:01:45 <fax> ack!
12:01:46 <fax> yes
12:01:47 <ibid> fax: but even that's only a part of it
12:01:49 <fax> meaning that a calculation will only occur when the value is used (the first time)
12:02:01 <fax> huh?
12:02:05 <Cale> fax: The "computations" might be anything.
12:02:12 <chessguy> Cale, it emphasizes the fact that y is not a function of the input
12:02:29 <Cale> For example, they might be parsers. "Running" a parser might consume some of the input, even if we don't care about the result.
12:02:38 <ibid> fax: laziness is most properly normal-order graph reduction. it is close but not quite the same as CBN :)
12:02:40 <SamB> Nafai: http://www.haskell.org/onlinereport/exps.html#sect3.2
12:02:41 <lambdabot> Title: The Haskell 98 Report: Expressions
12:02:48 <Cale> chessguy: That's true, it's just something that I don't expect beginners to be familiar with.
12:02:49 <ibid> Tac-Work: can't see your eyes :)
12:03:09 <Cale> chessguy: Actually, my preferred form is x >> y = x >>= const y
12:03:17 <fax> Cale: Ah, so the value of the compuation is not used, but the actual value of the (new) monad is passed on?
12:03:17 <Cale> but that seems to confuse beginners too :)
12:03:23 <chessguy> that works too
12:03:27 <Nafai> SamB: Cool, thanks
12:03:31 <kuribas> Are there any common rules for indenting haskell?
12:03:45 <mrd> layout
12:03:49 <chessguy> well if you're going to say (\k -> y) then you ought to make some comment about what k is
12:03:56 <SamB> kuribas: there are rules for how you may do it!
12:03:56 <Cale> fax: The computations are represented somehow by data structures, and >> is forming a combination of them which *means* to run the first and then the second somehow.
12:04:02 <ibid> kuribas: i believe most people will understand (mostly) anything that is legal :)
12:04:10 <desegnis> kuribas, since Haskell enforces a certain layout, the programmer has not so much choice
12:04:17 <Tac-Work> What would be an example of an exotic control flow?
12:04:19 <kuribas> ibid: Is there no convention?
12:04:19 <Cale> fax: I have to think about how to make this clearer, it's a good point :)
12:04:29 <SamB> desegnis: there's still plenty of choice
12:04:45 <Cale> Tac-Work: First class continuations, goto with value passing, things like that :)
12:04:52 <ibid> kuribas: not aware of any
12:04:57 <SamB> not many people are sure how best to indent their Haskell code
12:05:02 <Cale> Tac-Work: Or outright parallelism.
12:05:06 <kuribas> I ask, because I want to write a decent indentation engine for emacs.
12:05:17 <ibid> fax: you could think of >> as building a program in some other, imperative language and returning that program
12:05:18 <SamB> kuribas: that's HARD
12:05:35 <kuribas> SamB: Why?
12:05:41 <wli> SamB: An indentation standard of some sort would be nice. I don't care what the standard is, so long as I've got a standard to write to.
12:05:43 <ibid> fax: and any program returned by main gets run automatically
12:05:51 <chessguy> fax, just because it throws away the result of the first computation, that doesn't mean that the "side effects" aren't perserved
12:06:28 <desegnis> kuribas, once you've started, you may want to improve vim's Haskell indenting, too ;)
12:06:51 <kuribas> desegnis: I'll leave that for another happy volunteer :)
12:06:57 <ibid> kuribas: the current one works for me quite well
12:07:09 <kuribas> ibid: not for me.
12:07:16 <ibid> kuribas: except for the nasty bugs i've reported on the Debian BTS against haskell-mode:)
12:07:22 <fax> On the left side of >> you have a Monad and on the right side you have a different Monad which is like, the first one but having done the computation.. does that sound right?
12:07:31 <SamB> kuribas: nobody has figured out how to indent their code themselves have they?
12:07:45 <chessguy> fax, no, it's the same monad on both sides
12:07:49 <chessguy> @type (>>)
12:07:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
12:07:52 <ibid> fax: no, not monads, but computations (i prefer to call them Commands, but that's nonstandard terminology:)
12:08:06 <chessguy> fax, it's  m a -> m b, not m a -> m' b
12:08:07 <ibid> fax: the term monad belongs in the type world, not in the value world
12:08:09 <kuribas> SamB: yeah :)  I'll go with my own preferences then :)
12:08:15 <mrd> i gave up on auto indent in haskell and went back to 2 spaces at a time
12:08:18 <Cale> fax: "The monad" refers to the library you're working with.
12:08:19 <fax> I know its the same type of Monad but I thought it could be  different instance
12:08:20 <SamB> kuribas: that's always a good place to start I guess
12:08:30 <SamB> it would be nice to make at least one user happy
12:08:35 <ibid> fax: a monad is a type
12:08:35 <Cale> fax: Or more specifically to the type constructor.
12:08:36 <desegnis> ibid, let's call them monadic expression as long as we're talking about left and right side, i.e. lexical terms
12:08:41 <fax> chessguy: is that convention of syntax?
12:08:46 <ibid> desegnis: well, command terms, then
12:09:07 <desegnis> ibid, right
12:09:12 <ibid> desegnis: it's very common to use the name of a value as the name of a term, too
12:09:16 <chessguy> fax, i could have just as easily said 'not m a -> n b' if that's what you mean
12:09:24 <fax> ok
12:09:34 <ibid> desegnis: like, you talk about the lists on the left and right side of ++ and not of list terms :)
12:09:36 <Cale> fax: It's like the library (monad) gives you the tools to write programs in a little language embedded within Haskell.
12:09:50 <desegnis> ibid, well, you're again right :)
12:09:54 <Tac-Work> How hard would it be to write a Monad that took every line of a block and executed them in a random order? That would seem like a very exotic control flow
12:09:58 <fax> Cale: I see
12:10:02 <Cale> fax: So if x and y are programs, then x >> y is the program which will run x and then run y
12:10:16 <fax> @src >>
12:10:16 <lambdabot> m >> k      = m >>= \_ -> k
12:10:20 <fax> tsk
12:10:24 <SamB> Tac-Work: that wouldn't work too well
12:10:25 <fax> @src >>=
12:10:25 <lambdabot> Source not found. My pet ferret can type better than you!
12:10:40 <fax> so  >>= is defined differently for some Monads?
12:10:43 <Cale> Tac-Work: Not hard, except that it would probably fail the monad laws, which is something else I've still yet to write about there.
12:10:51 <ibid> Tac-Work: it would be impossible
12:10:53 <SamB> fax: all monads
12:10:59 <fax> but would you ever define m >> k      = m >>= \_ -> k differently?
12:11:12 <fax> or it would be illegal to do so?
12:11:22 <Saul_> Does anyone know of an html templating engine in Haskell?
12:11:25 <desegnis> since we're talking about monads... are there some nice tutorial-like documents on the web that teach me to see where I could use which function to get rid of explicit recursion in a Monad?
12:11:28 <SamB> you can define >> differently but you'd better keep the law!
12:11:40 <Tac-Work> You Haskellers make it sound like Monads can fix any problem at all. I'm sure the impossible would not only be possible in Haskell, but trivial to code =-P
12:11:43 <xerox> desegnis: mdo!
12:11:51 <Cale> fax: If you did, you'd only do it to improve performance, never to make it behave differently.
12:11:53 <RyanT5000> Saul_: there's one associated with HAPPS
12:11:58 <ibid> Tac-Work: well, not impossible in theory, but i doubt you can make it work in any fashion that caters to the intuition :)
12:12:00 <SamB> Tac-Work: not trivial
12:12:03 <newsham> saul: happs does xslt processing.  there's haskell server pages (hsp), and you can template directly in Text.Html
12:12:08 <desegnis> xerox, I mean, like sequence, fix, ...
12:12:09 <Cale> Tac-Work: They're just a kind of library.
12:12:09 <fax> Cale: ahh :D
12:12:09 <newsham> i'm sure there are others
12:12:10 <Tac-Work> Monads = IO, parallelism, Listmapping, State control, Call/cc
12:12:11 <Tac-Work> hehe
12:12:12 <Saul_> RyanT5000: Ok thanks, I'll check it out
12:12:14 <ibid> Tac-Work: you could do it in arrows, though, i think
12:12:15 <SamB> ibid: the point I think is that it's supposed to be *counter*-intuitive
12:12:17 <fax> ok thanks so much to everyone
12:12:21 <SamB> ibid: I don't know that you can do that
12:12:26 <RyanT5000> Saul_: sorry, newsham's right; HSP is closer to what you're looking for
12:12:33 <shachaf> @quote replacement
12:12:34 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
12:12:36 <shachaf> @quote replacement
12:12:36 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
12:12:37 <SamB> alternatively, the lazy State monad already does that
12:12:40 <shachaf> @quote jcreigh replacement
12:12:40 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
12:12:40 <lambdabot> for your entire program.")
12:12:57 <Saul_> RyanT5000: ok
12:12:59 <Tac-Work> lol
12:13:00 <Saul_> newsham: thanks
12:13:16 <SamB> isn't fluxbox a window manager?
12:13:19 <ibid> SamB: my point is that i'd expect the a <- foo variables to be dynamically bound in such a monad, and it's impossible
12:13:25 <Cale> SamB: yeah
12:13:50 <ibid> SamB: it may be impossible with arrows too, but not for the same reasons
12:13:59 <Tac-Work> What do arrows do?
12:14:03 <Tac-Work> (besides point)
12:14:08 <fax> Cale: that was fascinating
12:14:12 <fax> Monads_as_computation
12:14:19 <newsham> arrows describe a (possibly stateful) transformation from an input to an output
12:14:19 <xerox> . o O ( They hurt! )
12:14:24 <mrd> > second (1+) (1,2)
12:14:26 <lambdabot>  (1,3)
12:14:27 <ibid> Tac-Work: arrows are a generalisation of monads, or a generalisation of functions.  both are valid povs
12:14:41 <mrd> > (succ && pred) 3
12:14:42 <lambdabot>  Couldn't match expected type `Bool' against inferred type `a -> a'
12:14:48 <newsham> possibly w/ side effects
12:14:48 <mrd> > (succ &&& pred) 3
12:14:50 <lambdabot>  (4,2)
12:15:03 <Cale> fax: Check back in a little bit and I'll have written some more :)
12:15:06 <ibid> Tac-Work: the first because all monads have an isomorphic arrow, and the second because you can view any arrow as a "fancy" function
12:15:17 <tcr> mrd: Where's `second' in?
12:15:19 <Cale> fax: And thanks! :)
12:15:22 <newsham> Control.Arrow
12:15:23 <mrd> tcr: arrow
12:15:28 <fax> Does anyone know an example of a monad which does backtracking I could read?
12:15:33 <fax> source code
12:15:43 <newsham> fax: see the example of eight-queens
12:15:53 <mrd> fax: anything implementing MonadPlus
12:16:10 <mrd> sorta
12:16:20 <desegnis> from the little what I know about arrows, they may be even easier to understand than monads, because their type is similar to plain functions
12:16:45 <newsham> hrmm.. trying to dig up 8queens url.. it was part of a monad tutorial
12:17:02 <mrd> yes, if you take the arrow type "a b c" and subtitute function type -> in there, you get "(->) b c" or just plain ol' "b -> c"
12:17:20 <mrd> function type constructor*
12:17:21 <tcr> Let's say I've got a function `f :: a -> Maybe [b]', now I've got a list of a, and I want a function to compute `[a] -> Maybe [b]'.   --- At the moment I'm using `liftM concat . sequence . map f', are there more concise alternatives?
12:17:24 <desegnis> mrd, exactly
12:17:39 <Cale> fax: Sure, the list monad does.
12:17:46 <Cale> fax: return x = [x]
12:17:46 <mrd> tcr: well mapM f = sequence . map f
12:17:47 <dozer> tcr: I think you want mapM
12:17:56 <Cale> fax: x >>= f = concat (map f x)
12:18:10 <dozer> :t mapM
12:18:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:18:17 <mrd> @src [] >>=
12:18:17 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:18:25 <mrd> @src [] (>>=)
12:18:25 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:18:37 <xerox> @src concatMap
12:18:38 <lambdabot> concatMap f = foldr ((++) . f) []
12:18:38 <mrd> @src concat
12:18:38 <lambdabot> concat = foldr (++) []
12:18:52 <fax> Cale: I don't understand where backtracking comes into it
12:19:17 <mrd> fax: bind in the list monad represents non-deterministic choice
12:19:18 <shachaf> Do list comprehensions count as backtracking?
12:19:27 <Cale> > do { x <- [1..20]; y <- [x..20]; z <- [y..20]; if x^2 + y^2 == z^2 then [()] else []; return (x,y,z) }
12:19:29 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
12:19:34 <Cale> or:
12:19:44 <Cale> > do { x <- [1..20]; y <- [x..20]; z <- [y..20]; if x^2 + y^2 == z^2 then return (x,y,z) else [] }
12:19:45 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
12:20:18 <Cale> "running" a list is essentially picking a value from it
12:20:24 <newsham> search for "backtracking": http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
12:20:25 <lambdabot> Title: Monads for the Working Haskell Programmer
12:20:38 <Cale> running the empty list makes it seem like that control path never happened
12:20:44 <shachaf> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
12:20:46 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
12:21:05 <fax> I can't write it like [1..20] >>= \x [x..20] >>= \y [y..20] >>= \z if x^2 + y^2 == z^2 then return (x,y,z) else [] }
12:21:12 <monochrom> Oh, I keep forgetting Theo Norvell's monad tutorial. It's clear.
12:21:12 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
12:21:31 <Cale> > [1..20] >>= \x -> [x..20] >>= \y -> [y..20] >>= \z -> if x^2 + y^2 == z^2 then return (x,y,z) else []
12:21:33 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
12:21:37 <mrd> > do { x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z) }
12:21:39 <fax> thanks :D
12:21:39 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
12:21:39 <Cale> Just forgot some arrows
12:21:48 <monochrom> SamB here?
12:21:48 <fax> ohh I see
12:21:50 <Cale> Yeah, then you have guard
12:21:53 <SamB> yeah?
12:21:53 <tcr> thanks mrd & dozer.
12:22:01 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/eightqueens.lhs.txt
12:22:04 <Cale> guard p = if p then return () else []
12:22:12 <Cale> (at least in the list monad)
12:22:24 <SamB> so how does theorem proving lead to the dark side?
12:22:27 <mrd> guard is defined on monad plus instances, hence why i mentioned it.
12:22:36 <monochrom> re: theorem proving leading to the dark side, I was kidding. :)
12:22:58 <mrd> `mplus` represents a choice between alternatives, and mzero is the abort this line of computation value
12:22:59 <SamB> monochrom: yes. but I want to hear more kidding in this vein ;-)
12:23:04 <monochrom> That's the short answer. The long answer is use theorem proving to develop automatic programming and eliminate human programmers...
12:23:10 <fax> oh cheers newsham
12:23:16 <fax> I was looking for that
12:23:45 <newsham> np
12:23:50 <fax> ok this pythagoran triples thing is cool
12:23:51 <monochrom> fear leads to doubt. doubt leads to theorem proving. theorem proving leads to the daaaaaark siiiiiiiide....
12:24:14 <fax> Do you know where is best to look for an implementation of the list Monad?
12:24:14 <mrd> does theorem proving allow you to master the dark art of shooting lightning bolts from your hands?
12:24:21 <newsham> assume that theorem proving does not lead to the dark side and show a contradiction
12:24:31 <mrd> @src [] (>>=)
12:24:32 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:24:33 <fax> like any haskell implementation which does not target speed?
12:24:34 <mrd> @src [] return
12:24:35 <lambdabot> return x    = [x]
12:24:36 <mrd> done
12:24:39 <shachaf> fax: Cale gave you one.
12:24:42 <fax> thats everything?
12:24:49 <fax> how can that be.. :D
12:24:50 <shachaf> @src [] mzero
12:24:50 <lambdabot> mzero = []
12:24:52 <shachaf> @src [] mplus
12:24:52 <lambdabot> mplus = (++)
12:24:56 <dozer> monochrom: nice idea, except a combination of the completenes theorem and Putnam's critique of model theory fairly comprehensively rules that out
12:25:01 <mrd> @src Monad
12:25:02 <lambdabot> class  Monad m  where
12:25:02 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:25:02 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:25:02 <lambdabot>     return      :: a -> m a
12:25:02 <lambdabot>     fail        :: String -> m a
12:25:10 <Cale> Please ignore fail :)
12:25:17 <mrd> and since >> is derived, and fail is silly, all you need is >>= and return
12:25:21 <shachaf> Ugh, fail.
12:25:24 <Cale> It really shouldn't be there, it's just a wart in the Haskell spec.
12:25:25 <mrd> @src [] fmap
12:25:25 <Tac-Work> What is fail?
12:25:25 <lambdabot> fmap = map
12:25:32 <mrd> @src [] fail
12:25:32 <monstre> Beginner question: does the order in which non-overlapping clauses appear in a function definition matter performance-wise? I.e. do I gain anything by putting clauses that are expected to be used most often first?
12:25:32 <lambdabot> fail _      = []
12:25:34 <Tac-Work> @src []fail
12:25:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:25:37 <newsham> ?src Maybe fail
12:25:37 <lambdabot> fail _      = Nothing
12:25:45 <mrd> use mzero instead of fail
12:25:51 <Cale> Tac-Work: It's something which was spuriously added to the Haskell spec to make up for MonadZero being removed from the Prelude.
12:25:51 <SamB> @src IO fail
12:25:51 <lambdabot> fail s  = failIO s
12:26:00 <newsham> mzero implies monadplus
12:26:04 <SamB> oh that's VERY helpful, lambdabot!
12:26:19 <shachaf> I think fail is used in bad pattern matches?
12:26:24 <Cale> yes
12:26:25 <mrd> monstre: non-overlapping clauses?
12:26:34 <shachaf> > [x | Left x <- [Left 3, Right 4]]
12:26:35 <lambdabot>  [3]
12:26:43 <Cale> It used to be that the do-notation translation used mzero for pattern match failures.
12:26:44 <mrd> newsham: if you're doing backtracking you'd better be involved with monadplus already
12:26:57 <shachaf> Cale: And now it doesn't because that needs MonadPlus?
12:27:01 <newsham> who said we're doing backtracking?
12:27:04 <shachaf> Cale: Rather than just MonadZero?
12:27:10 * SamB wonders how you could accomodate fail in the monoid laws
12:27:10 <Cale> shachaf: yeah
12:27:15 <mrd> fax
12:27:19 <fax> yes?
12:27:20 <Cale> shachaf: because they foolishly decided to merge those two
12:27:23 <monstre> mrd: like, say, the nil and cons clauses of a function defined over a list
12:27:36 <dozer> shacaf: you need monadzero to let you kill of a line of enquiry, and monadplus to fork over the alternatives
12:27:44 <SamB> apparantly, Cale thinks that MonadPlus should be broken into *three* classes
12:27:46 <mrd> monstre: the pattern matches? just remember they are checked left-to-right top-to-bottom
12:27:53 <Cale> SamB: yep
12:27:59 <wli> let n = 20 in do { w <- [1..n] ; x <- [w+1..n] ; y <- [1..n] ; z <- [y+1..n] ; guard (w /= y); guard (w /= z); guard (x /= y); guard (x /= z); guard (w^3 + x^3 == y^3 + z^3); return (w,x,y,z); }
12:28:00 <desegnis> monstre, I've heard rumours that ghc is smart to enough to figure out when pattern matches are mutually exclusive
12:28:11 <shachaf> Cale: Which three?
12:28:13 <shachaf> @src MonadPlus
12:28:14 <lambdabot> Source not found. You speak an infinite deal of nothing
12:28:25 <mrd> > repeat ()
12:28:26 <newsham> ?src [] mzero
12:28:26 <lambdabot> mzero = []
12:28:27 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
12:28:28 <Cale> MonadZero, MonadPlus, and MonadElse
12:28:32 <newsham> ?src [] mplus
12:28:33 <lambdabot> mplus = (++)
12:28:36 <desegnis> monstre, and then to use this knowledge for optimization
12:28:43 <shachaf> Cale: Oh, right, I remember.
12:28:44 <SamB> Cale: MonadOrElse would sound so much more badass!
12:29:03 <mrd> MonadOrBust?
12:29:05 <SamB> (as well as more closely matching the name of the method)
12:29:07 <newsham> MonadWaitTillYourFatherGetsHome
12:29:08 <hpaste>  fax pasted "pythagorean triples" at http://hpaste.org/2019
12:29:08 <Cale> Sure, I'm not certain about what it should be called :)
12:29:08 <monochrom> You will learn monads. Or else.
12:29:19 <fax> Im sorry let me fix that paste..
12:29:26 <SamB> Cale: you called the method morelse...
12:29:49 <Cale> SamB: I didn't name it
12:29:52 <SamB> so if MonadZero has mzero and MonadPlus has mplus, shouldn't MonadOrElse have morelse
12:29:55 <shachaf> What is the difference between MonadPlus and Alternative?
12:29:55 <SamB> Cale: oh you didn't?
12:30:03 <hpaste>  fax annotated "pythagorean triples" with "fixed" at http://hpaste.org/2019#a1
12:30:07 <Cale> SamB: The MonadPlus proposal isn't really mine, but I agree with it
12:30:09 <monochrom> more is lse
12:30:20 <SamB> why does it have your name on it then?
12:30:20 <fax> what rule is it that lets you not return somthing as in this paste?
12:30:21 <shachaf> I mean, is mzero always empty abd is mplus always (<|>)?
12:30:26 <Cale> Uh, it does?
12:30:33 <sjanssen> Cale: why split mplus and orElse?
12:30:36 <Cale> Maybe someone stuck my name on it?
12:30:42 <SamB> hmm.
12:30:51 <SamB> I could have sworn it was on there.
12:30:56 <Cale> sjanssen: because they satisfy different laws, and are sometimes both desirable
12:31:11 <Tac-Work> what is the best way to learn about Monads beyond IO?
12:31:19 <Tac-Work> I think I have a good understanding of IO
12:31:20 <Cale> sjanssen: For instance it would be useful sometimes to have a list operation which would give the first list if nonempty, otherwise the second.
12:31:27 <monochrom> Write some monads of your own.
12:31:28 <mrd> Tac-Work: usage
12:31:30 <Tac-Work> but the obscure, abstract Monad stuff confuses me
12:31:35 <shachaf> Tac-Work: IO is not the best one to start with, I think.
12:31:38 <shachaf> @instances Monad
12:31:39 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:31:43 <shachaf> And Identity.
12:31:52 <mrd> @src Identity (>>=)
12:31:52 <lambdabot> m >>= k  = k (runIdentity m)
12:31:56 <Tac-Work> Are there any good, easy to med difficulty Monads one could write on their own?
12:32:03 <Cale> Tac-Work: I'll give a tutorial in a little bit, but I'd like to finish writing this thing :)
12:32:07 <newsham> ?src ((->) r) return
12:32:07 <lambdabot> Source not found. Take a stress pill and think things over.
12:32:18 <shachaf> I guess Identity->Maybe->[]->Reader->((->) r)->State->Writer or so.
12:32:19 <Cale> Tac-Work: sure, try to make this type into a monad instance:
12:32:26 <mrd> typically you combine Monad Transformers these days to create new Monads
12:32:28 <SamB> Cale: well it doesn't seem to have been there when I looked at that page...
12:32:35 <shachaf> Tac-Work: Try reimplementing each.
12:32:43 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
12:32:45 <SamB> so I must have misremembered how I knew you were associated with this proposal
12:32:57 <monochrom> The "state monad" is an easy one to re-invent yourself.
12:33:15 <mrd> Tac-Work: basically, consider the class Functor and the class Monad.  Fill in the definitions which satisfy the types of fmap, (>>=), and return for your Monad.
12:33:19 <fax> Cale: In your example, this part: if x^2 + y^2 == z^2 then return [x,y,z] else [] is called for all the different values of x y and z.. but what happens to the result? (whether or not it is returned)
12:33:20 <Tac-Work> I've looked hard for good examples on State.... and there really aren't any
12:33:50 <Cale> fax: return (x,y,z), I wrote
12:33:57 <shachaf> > (`runState` 5) $ do { x <- get; put (x+1); y <- get; return (x,y) }
12:33:58 <Cale> fax: not that it matters :)
12:33:58 <lambdabot>  ((5,6),6)
12:34:08 <Cale> fax: hmm.. what happens to the result
12:34:11 <fax> oh sorry I changed it to test somthing
12:34:21 <fax> but when you don't return nothing is added to the resulting list
12:34:23 <Cale> fax: Well, return (x,y,z) == [(x,y,z)]
12:34:30 <fax> I wonder where the code is which makes the resulting list
12:34:38 <Cale> the results all get concatenated by >>=
12:34:49 <Cale> x >>= f = concat (map f x)
12:35:02 <fax> :t concat
12:35:04 <lambdabot> forall a. [[a]] -> [a]
12:35:17 <Cale> > concat [[1,2,3],[],[],[4,5],[],[6,7,8]]
12:35:18 <lambdabot>  [1,2,3,4,5,6,7,8]
12:35:42 <fax> > concat [[(1,2,3)],[],[(4,5,6)],[],[],[],[(9,10,11)]]
12:35:43 <lambdabot>  [(1,2,3),(4,5,6),(9,10,11)]
12:35:45 <Cale> > [1,2,3] >>= \x -> [x, x*10]
12:35:47 <lambdabot>  [1,10,2,20,3,30]
12:35:47 <fax> aha :D
12:36:09 <fax> I'm pretty sure I see the list Monad now
12:36:13 <Olathe> How do you sort a list of tuples by the last element of the tuple ?
12:36:15 <Cale> cool :)
12:36:26 <fax> again thanks for all your explanation
12:36:29 <Cale> Olathe: sortBy (comparing snd)
12:36:35 <Olathe> Ahh, thanks.
12:36:38 <Cale> (Import Data.List and Data.Ord)
12:36:57 <dozer> the fooBy methods let you provide your own eq/ord operator :) I didn't spot that 1st time arround
12:37:00 <Tac-Work> shachaf: I don't know why the tutorials don't make state that simple ^^;
12:37:12 <julian_> @pl term n p = foldr (.) id (replicate n (>>= p))
12:37:12 <lambdabot> term = (foldr (.) id .) . (. (=<<)) . replicate
12:39:01 <Nafai> Wow.  QuickCheck is pretty cool
12:41:25 <hpaste>  wli pasted "Ramanujan numbers and quadruplets" at http://hpaste.org/2020
12:41:42 <newsham> not a very interesting number
12:42:46 <monstre> Say I want to write a merge function for instance, would it make sense to put the cons-cons clause first since most argument lists can reasonably expected not to be empty or does it simply not matter?
12:43:01 <monstre> Help me understand how pattern-matching actually works please
12:43:35 <Tac-Work> all of haskell is magic, monstre, there is no logic behind it
12:43:40 <Tac-Work> ^^
12:43:41 <fax> lol
12:43:49 <geezusfreeek> i came in at the right time :)
12:43:56 <mrd> Tac-Work: there is a monad tutorial site with example implementations and discussion for all the common monads
12:44:11 <dozer> monstre: no - you put the empty list clause in first
12:44:12 <monstre> I'd like to get beyound the magic stage if possible
12:44:20 * mrd ponders MagicT (MonsterT Identity)
12:44:24 <monstre> dozer: why?
12:44:45 <wli> mrd: Sets of problems to work through for each would help.
12:44:45 <Tac-Work> mrd: Do you remember what it's called?
12:45:23 <mrd> All About Monads
12:45:33 <Saizan> @where monads
12:45:33 <lambdabot> http://www.haskell.org/all_about_monads/html/
12:46:09 * Tac-Work consumes
12:46:23 <dozer> monstre: well - perhaps in this case it doesn't matter so much - but if you are matching e.g. (x:xs), (x) and [], you would want to match them with (x) before (x:xs) because (x) would match where ever (x:[]) would, and [] would match xs, if you see what I mean
12:46:47 <dozer> monstre: I could have said that better...
12:46:54 <mrd> you mean [x] not (x)
12:47:10 <monstre> I'm only concerned about mutually-exclusive clauses here though
12:47:11 <dozer> yeah
12:47:24 <mrd> so, [] vs (x:xs)
12:47:30 <monstre> right
12:47:37 <dozer> monstre: if they are mutually exclusive, then hell, put them in the order you think they are most likely to be used - it will gain you some constant factor speedup
12:47:42 <mrd> i usually write the [] case first because i like to write base cases first
12:48:12 <mrd> worryin about the order in that case strikes me as the most premature of premature optimization
12:48:33 <dozer> lol, yeah - I usually go from base cases down, or go in the constructor order
12:48:38 <monstre> I'm trying to understand, not optimize
12:48:39 <newsham> optimization should not be a religeon
12:49:17 <monstre> I agree that base cases first is probably better stylistically
12:49:59 <mrd> a nice thing about Haskell is that it tries to give you the freedom to write definitions in any order you feel is clearest
12:50:35 <monstre> I'm just wondering if there's an impact on performance as well, as dozer seems to imply there is
12:50:44 <mrd> a notable exception being non-exclusive pattern matches, because i think it was felt to be easier to understand top-to-bottom ordering rather than Best match
12:50:53 <mrd> i really never heard of such an impact, so i could not say.
12:51:00 <mrd> perhaps in a naive interpreter?
12:51:08 <SamB> hmm. what license does lambdabot actually use?
12:51:10 <dozer> monstre: it is an extremely small minor constant overhead - your algorithm will have a vastly greater impact
12:51:17 <newsham> ?info
12:51:18 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
12:51:25 <SamB> COPYING and lambdabot.cabal are in conflict on this point
12:51:37 <monstre> dozer: I realize that, but I'm still curious
12:51:49 <newsham> ?tell dons I said "?info" lambda said < lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine =
12:51:49 <lambdabot> Consider it noted.
12:51:59 <mrd> ?lusers
12:51:59 <lambdabot> Maximum users seen in #haskell: 382, currently: 354 (92.7%), active: 25 (7.1%)
12:51:59 <SamB> @license
12:52:00 <lambdabot> Unknown command, try @list
12:52:01 <hpaste>  desegnis pasted "What is this called?" at http://hpaste.org/2021
12:52:04 <SamB> @copying
12:52:04 <lambdabot> Unknown command, try @list
12:52:05 <dozer> monstre: in the case of lists, it will be the cost of one pointer/pointer equality lookup and a branch, at most
12:52:07 <SamB> @version
12:52:08 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
12:52:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:52:16 <cjeris> @seen Syzygy-
12:52:17 <lambdabot> Syzygy- is in #gentoo-haskell, #ghc, #oasis and #haskell. I last heard Syzygy- speak 3h 47m 54s ago.
12:52:32 <desegnis> See my paste for yet another monadic question
12:52:58 <dozer> monstre: or depending how lists are actually implemented, checking if a bit is set to 1, and a conditional branch
12:53:54 <monstre> As far as style is concerned, is it more usual to put base cases first or does it vary among programmers?
12:53:57 <Tac-Work> what does LambdaBot do if it is given a nonhalting program to run?
12:54:06 <mrd> Tac-Work: it has a limit
12:54:16 <mrd> > iterate id
12:54:18 <Tac-Work> But... but.... it's Turing Completeness!
12:54:20 <mrd> > iterate id 1
12:54:24 <lambdabot>  Add a type signature
12:54:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:54:32 <mrd> turing completeness doesn't preclude having a time limit ;)
12:54:56 <Tac-Work> it does if you can't perfrom calculations arbitrarily fast ^^
12:54:59 <mrd> so, there exists a t such that lambdabot computes the set of computations which run in t
12:55:19 <Olathe> > let f n = f (n - 1) in f 5
12:55:23 <lambdabot> Terminated
12:55:46 <mrd> ?wiki safe
12:55:47 <lambdabot> http://www.haskell.org/haskellwiki/safe
12:55:48 * SamB adds lambdabot to ohloh: http://www.ohloh.net/projects/7054
12:55:50 <lambdabot> Title: lambdabot - Ohloh
12:56:07 <mrd> http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
12:56:10 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
12:57:40 <meren> hi
12:57:49 <mrd> Tac-Work: The Halting Problem is a Decision Problem which is defined to be the set of (programs, input) which halt in finite time.  Deciding this set means deciding whether or not a (program, input) pair belongs in the set or not.  That is semi-decidable.
12:58:28 <mrd> Tac-Work: cutting a program off after t seconds have passed does not decide the halting problem =)
12:59:24 <dozer> no - it's equivalent to transforming each program into a new one that runs the original in parallel with a ticker, and terminates if the original program does, or if the ticker reaches a threshold - whichever first.
12:59:33 <mrd> if the program does halt, then great, you have found an Accepting instance of the halting problem
13:00:10 <mrd> but you can't find a rejecting one in finite time
13:00:14 <mrd> (in general)
13:00:14 * SamB suggests people join ohloh and stack lambdabot
13:00:27 <dozer> much the same as take 5 [1..] terminates even thoug [1..] does not
13:00:53 <SamB> oh. you aren't going to believe how I found ohloh ;-)
13:01:28 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation -- expanded a bit, still not done :)
13:01:30 <lambdabot> Title: Monads as computation - HaskellWiki
13:01:39 * dozer is away watching Heroes
13:01:55 <SamB> I was googling my name for some reason...
13:02:15 <mrd> monads and sanity!
13:02:33 <SamB> and one of the first few links that actually referred to me was a page about me in my capacity as a ZSNES contributor
13:02:49 <SamB> now look ;-)
13:02:55 <SamB> @google Samuel Bronson
13:02:57 <lambdabot> http://www.ohloh.net/accounts/6511
13:02:57 <lambdabot> Title: Samuel Bronson - Ohloh
13:02:59 <xerox> @remember SPJ I'm sitting there, under the cover, doing side effects like crazy. But I'm making it so beautiful for you so that you can think of pure folds, and I would do the dirty things for you.
13:03:00 <lambdabot> Done.
13:03:17 <mrd> yikes
13:03:22 <xerox> His words! hehe.
13:04:13 <SamB> that's what he's paid to do isn't it?
13:04:18 <monstre> Next question: how should I go about writing a program that uses mutable state? What is the difference between the ST and State monads?
13:04:37 <sorear> .
13:04:40 <Excedrin> is "under the cover" a typo? can you fix it anyway? (also, /for you so/for you/ ?)
13:05:01 <astrolabe> For those who haven't seen the SPJ video http://programming.reddit.com/info/2beef/comments
13:05:02 <lambdabot> Title: A Taste of Haskell Video, Part I (from OSCON) (reddit.com)
13:05:07 <SamB> monstre: State is implemented in Haskell code
13:05:32 <Cale> Excedrin: where?
13:05:52 <Excedrin> in that SPJ quote
13:05:56 <xerox> No, but there's a typo indeed, is "deeds" not "things".
13:06:21 <Cale> monstre: ST gives you an arbitrary number of mutable cells which you can create and pass references around
13:06:40 <Cale> monstre: State gives you a single piece of computation-global state (which in turn can be a record)
13:07:00 <monstre> I see, thanks Cale
13:07:10 <Excedrin> I think it should read, "I'm sitting there, under the covers, doing side effects like crazy. But I'm making it so beautiful for you that you can think of pure folds, and I would do the dirty deeds for you." but I guess editing people's quotes is poor form or something
13:07:15 <mrd> ST is the "state thread" monad which encapsulates a thread of stateful manipulation which is protected from improperly escaping by the type system
13:07:31 <xerox> Excedrin: np, go ahead.
13:07:54 <Excedrin> I mean, it's poor form to edit what SPJ said, not your entry in lb specifically
13:08:03 <Excedrin> anyway, it's a good quote :)
13:08:14 <mrd> @quote dirty deeds
13:08:14 <lambdabot> No quotes for this person. You type like i drive.
13:08:19 <mrd> @quote dirty things
13:08:20 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
13:08:25 <Excedrin> @quote SPJ
13:08:26 <lambdabot> SPJ says: I'm sitting there, under the cover, doing side effects like crazy. But I'm making it so beautiful for you so that you can think of pure folds, and I would do the dirty things for you.
13:08:28 <xerox> :)
13:09:03 <Tac-Work> > repeat Nothing
13:09:06 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
13:09:10 <mrd> much ado
13:09:50 <monstre> Are IORefs basically STRefs only in a different monad?
13:10:03 <Cale> Excedrin: hahaha
13:10:10 <Cale> monstre: yes
13:10:20 <monstre> okay, thanks
13:10:34 <xerox> Cale, you can hear it yourself in his tutoring Haskell video :-)
13:10:54 <Cale> xerox: Yes, I'm going to watch it as soon as I'm done writing this :)
13:11:11 <fax> instead of macros in haskell you use Monads?
13:11:28 <mrd> higher order functinos
13:11:47 <Cale> fax: Largely, yes.
13:12:04 <Cale> fax: As well as other kinds of combinator libraries.
13:12:15 <cjeris> mrd: the byproducts of collisions in a lambda accelerator?
13:12:30 <Cale> fax: It's really Haskell's laziness which allows us to do most of the things which would normally involve macros
13:12:37 <mrd> that's right, they have a distinctive pattern in the bubble chamber
13:12:43 <fax> ok cool
13:12:52 <mrd> functinos curve in the shape of a greek lowercase lambda
13:13:02 <mrd> very curious!
13:13:11 <xerox> hahaha.
13:15:42 <xerox> Nafai: is the part two available just yet?
13:19:41 <monstre> If you don't more newbie questions: are there other uses for lazyness besides handling very large or potentially data structures or the aforementioned macro-like uses?
13:21:00 <monstre> Or is that pretty much it?
13:21:23 <mrd> it has pretty large consequences for program structure
13:21:50 <monstre> Such as?
13:21:51 <xerox> It also eases writing things, consider xs `isInfixOf` ys = any (xs `isPrefixOf`) (tails ys).
13:22:14 <monstre> neat
13:22:30 <mrd> the way you compose your functions, you don't need to worry about the complete termination of one to feed it to another
13:22:34 <xerox> That wouldn't quite look like that in a non-lazy setting.
13:22:53 <monstre> couldn't you get most of the way there just by having lazy constructors though?
13:23:15 <monstre> in an otherwise strict language
13:23:37 <mrd> and supply an entirely lazy standard library?
13:23:52 <mrd> with nice compiler support?
13:24:32 <monochrom> laziness helps consumer-producer separation. Then again you can call it a corollary of handling very large data structures.
13:25:29 <Saul_> Can I use Haskell Server Pages with HAppS?
13:26:06 <monstre> I don't see how having just a few lazy constructors for lists and trees, etc. wouldn't accomplish the same thing
13:26:12 <monstre> what am I missing?
13:26:42 <monstre> you don't have to write a lazy map, folds, etc. if you have a lazy cons
13:27:12 <mrd> well, you need your library to actually use the lazy cons
13:27:39 <monstre> they could even be overloaded over strict and lazy lists using some sort of type class mechanism
13:28:09 <mrd> too much ambiguity probably
13:28:18 <mrd> especially for intermediate results
13:28:31 <monstre> if we can handle overloaded numbers, why not lists?
13:28:45 <mrd> numbers are strict
13:28:47 <mrd> generally
13:29:04 <DRMacIver> Personally I think all literals should be fully overloaded. :)
13:29:16 <mrd> yea i can't wait to see the error messages
13:29:18 <Lemmih> Saul_: Not without a lot of work.
13:29:49 <Saul_> Lemmih: Ok thanks, I guess I'll use HAppS then
13:30:04 <mrd> do you want the termination properties of your program to depend on the choice of instance?
13:30:33 <DRMacIver> Sure. :)
13:30:36 <monochrom> Yes.
13:30:44 <monstre> I'm afraid I do, yes
13:31:03 <mrd> that 'tails' example is good also -- in what strict language do you see mapping over tails? they usually combine the two into one function
13:31:12 <mrd> for example, in lisp it's called: maplist
13:32:08 <Tac-Work> @hoogle [a] -> [[a]]
13:32:09 <lambdabot> List.inits :: [a] -> [[a]]
13:32:09 <lambdabot> List.tails :: [a] -> [[a]]
13:32:09 <lambdabot> List.group :: Eq a => [a] -> [[a]]
13:32:28 <Tac-Work> Is there a builtin powerlist function in Haskell?
13:32:39 <mrd> > filterM (const [True,False]) [1..3]
13:32:40 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:33:00 <mrd> > filterM (const [False,True]) [1..3]
13:33:02 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
13:33:28 <julian_> the best way to do a: A >>= f >>= f >>= f ... >>= f (n times) ???
13:33:29 <Tac-Work> If Haskell didn't have the interactive interpreter, I think I'd kill myself
13:33:40 <DRMacIver> > filterM (const [False, True]) [1..]
13:33:43 <lambdabot>  Exception: stack overflow
13:33:54 <mrd> REPLs are essential
13:34:06 <fasta> Tac-Work: Haskell doesn't have that.
13:34:10 <julian_> foldr (.) id (replicate n (>>= p)) ????
13:35:01 <mrd> :t \ p -> foldr (.) id (replicate n (>>= p))
13:35:03 <lambdabot> Not in scope: `n'
13:35:08 <mrd> :t \ n p -> foldr (.) id (replicate n (>>= p))
13:35:10 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> m b -> m b
13:35:20 <Tac-Work> what does filterM do?
13:35:25 <fasta> mrd: lambdabot is /msg
13:35:30 <fasta> @docs
13:35:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:35:31 <julian_> n times, below
13:35:38 <fasta> Tac-Work: ^^
13:35:49 <fasta> Tac-Work: ask undocumented stuff in this channel
13:36:10 <mrd> @index Control.Monad
13:36:10 <lambdabot> bzzt
13:36:11 <monstre> I'm not sure I fully understand what the tails example is doing or why it wouldn't work in a hypothetical strict language that happened to have a lazy cons
13:36:37 <julian_> @index Control.Monad
13:36:37 <lambdabot> bzzt
13:37:00 <Saizan> ?type \n f a -> iterate a (>>= f) !! n
13:37:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => Int -> (a -> m b) -> ((m a -> m b) -> m a -> m b) -> m a -> m b
13:37:16 <Saizan> ?type \n f a -> iterate (>>= f) a !! n
13:37:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> m b -> m b
13:37:28 <monochrom> strict language with lazy cons works.
13:37:31 <fax> > iterate (+1) 0
13:37:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:37:43 <fax> aha
13:37:48 <monstre> monochrom: really?
13:38:03 <monochrom> This is not a secret.
13:38:05 <monstre> why do we need the entire rest of the language to be lazy then?
13:38:22 <mrd> why be lazy, i often ask myself
13:38:23 <monochrom> That is a long story I don't know of.
13:38:55 <monochrom> But personally, somehow I like it lazy.
13:39:04 <mrd> i start to get an answer but put off the rest til later
13:39:15 <monochrom> hahahahahha
13:39:32 <glen_quagmire> i'm stuck at java thread bug
13:40:15 <Tac-Work> > filterM (const [True, False]) [1..3] -- <- this code I think blew my mind. I wish I had more time to figure out why it works. So for now, I'mma just asume Haskell is magical still
13:40:17 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:40:40 <fax> @src filterM
13:40:41 <lambdabot> Source not found. Take a stress pill and think things over.
13:40:45 <fax> :D
13:40:52 <monochrom> @remember mrd why be lazy, i often ask myself. i start to get an answer but put off the rest til later.
13:40:52 <lambdabot> Done.
13:40:52 <Tac-Work> yeah, I tried that
13:41:15 <Tac-Work> I was looking at the source from the prelude
13:41:19 <Tac-Work> but I still don't get it
13:41:24 <Tac-Work> it's only 3 lines long
13:42:05 <fax> how do you find the source code Tac-Work?
13:42:22 <fax> > filterM (const [True, True]) [1..3]
13:42:23 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
13:42:35 <pejo> monstre, the choice to have a lazy language was made nearly 20 years ago, things have changed somewhat since then.
13:43:08 <Tac-Work>  filterM::Monadm=>(a->mBool)->[a]->m[a]
13:43:08 <Tac-Work> filterMp[]=return[]
13:43:08 <Tac-Work> filterMp(x:xs)=do{b<-px; ys<-filterMpxs; return(ifbthen(x:ys)elseys) }
13:43:12 <Tac-Work> I used google
13:43:16 <fax> o hok
13:43:25 <fax> I thought there may be some way to access the code
13:44:00 <fax> > iterate (const [True, False]) []
13:44:01 <lambdabot>  [[],[True,False],[True,False],[True,False],[True,False],[True,False],[True,F...
13:45:41 <monochrom> > do { x <- [True,False]; return (not x) }
13:45:42 <lambdabot>  [False,True]
13:45:49 <monochrom> Try to understand that first.
13:47:19 <monstre> Is there actually such a language: strict by default but supports lazyness using annotations (rather than the other way around)?
13:47:40 <Tac-Work> Doesn't Scheme have something like that?
13:47:44 <Tac-Work> with (delay ...)
13:47:48 <Tac-Work> and (force)
13:47:54 <ddarius> mostre: Plenty.
13:47:56 <monstre> you have to explicitly force everything though
13:48:15 <Tac-Work> having to do something explicitly is better than being competely unable to do it
13:48:16 <ddarius> Though usually as extensions to existing languages.
13:49:34 <Cale> Okay, I think I'm pretty close to finished with http://www.haskell.org/haskellwiki/Monads_as_computation
13:49:35 <lambdabot> Title: Monads as computation - HaskellWiki
13:49:37 <monochrom> monstre: Yes. Lazy ML is one, I heard.
13:49:44 <Cale> fax: ^^
13:49:50 <Tac-Work> that filterM thing a while ago.... it does something weird with periodic flipping of inclusion
13:49:52 <Cale> (If you're interested :)
13:49:56 <fax> yes!
13:50:03 <chessguy_> Cale, be sure to email -cafe
13:50:06 <monstre> I'm trying to understand why Haskell went with lazyness by default with optional strictness rather than vece versa
13:50:25 <monstre> ...vice versa even
13:50:28 <Cale> chessguy_: Funnily enough, it started out as an email to -cafe. Thanks for reminding me :)
13:50:39 <SamB> monstre: something about strictness being easier to add than to remove
13:50:52 <mrd> > let { pow [] = return [] ; pow (x:xs) = pow xs >>= (\ ys -> [(x:ys),ys]) } in pow [1..3]
13:50:53 <lambdabot>  [[1,2,3],[2,3],[1,3],[3],[1,2],[2],[1],[]]
13:51:00 <monstre> seriously, what does that get you besides memory leak?
13:51:00 <chessguy> yeah, there have been several threads on the topic today
13:51:07 <monstre> I must be missing something abvious
13:51:32 <mrd> well Haskell itself was formed in response to the existence of many similar functional lazy programming languages in the research community
13:51:55 <SamB> monstre: you can't lazify a strict list
13:51:56 <monochrom> The "history of haskell" paper probably says something.
13:51:58 <monstre> was it simply a case of all lazy or all strict back then?
13:52:31 <tcr> monstre: lazy evaluation gives you infinity
13:52:34 <SamB> it comes down to the libraries, more or less
13:52:45 <mrd> the designers of Scheme and ML decided that it was better to stay strict, and allow laziness to be added via explicit lambdas and such
13:53:07 <dylan> heh
13:53:24 <dylan> monadfm
13:53:27 <SamB> one very good reason to have laziness is that it motivates purely functional I/O facilities ;-)
13:53:40 <monstre> SamB: I don't understand the libraries objection, why can't a strict map, say, work with lazy cons?
13:53:48 <Philippa> <monstre> I'm trying to understand why Haskell went with lazyness by default with optional strictness rather than vece versa <- because that was Haskell's reason for being
13:54:12 <SamB> that's another good point.
13:54:13 <monstre> SamB: I think I remember SPJ saying Haskell wasn't the point so much as purity
13:54:29 <monstre> err, lazyness wasn't the point...
13:54:32 <SamB> Haskell was made to fill the niche of "main lazy functional language"
13:54:45 <DRMacIver> The original point of Haskell was laziness. These days purity is the more interesting feature (I think).
13:55:13 <qwr> > mapM (const "01") [0..3]
13:55:15 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
13:55:16 <SamB> purity was adopted by necessity
13:55:19 <monstre> there must have been a demand for lazyness prior to the invention of Haskell though, right?
13:55:20 <Saul_> Yeah I read that in this history of haskell story SPJ wrote
13:55:24 <mrd> ironically, the original point of Puritans was strictness
13:55:26 <SamB> monstre: yeah.
13:55:27 <Tac-Work> who is SPJ?
13:55:30 <SamB> there was, say, Miranda
13:55:34 <monstre> Simon Peyton-Jones
13:55:37 <Tac-Work> kk
13:55:45 <Saul_> They just made it lazy because it was popular back then
13:55:56 <pejo> SamB, why is laziness needed for purely functional IO?
13:56:03 <SamB> I thought they were replacing Miranda, since that was proprietary?
13:56:07 <Saul_> but the big advantage was that they had to keep everything pure
13:56:14 <SamB> pejo: the other way around ;-)
13:56:21 <monstre> pejo: I think it's the other way around
13:56:44 <monochrom> If you want pure then you may also want lazy. This is because lazy gives you a write-once state variable. See "more haste, less speed"
13:56:59 <SamB> monochrom: another point
13:57:06 <SamB> but was that published when Haskell was created?
13:57:10 <monstre> an impure lazy language would be rather... interesting
13:57:26 <mrd> it would be fairly disasterous
13:57:30 <monochrom> *shrug*
13:57:36 <SamB> mrd: yeah.
13:57:39 <mrd> you can achieve it with unsafePerformIO
13:57:51 <SamB> interesting is another word for disasterous ;-)
13:57:56 <DRMacIver> A number of impure languages allow you to create laziness.
13:58:02 <monochrom> One could also interrogate the point of pure.
13:58:03 <DRMacIver> D and OCaml for example.
13:58:05 <pejo> SamB, oh, my bad. Odd way of phrasing for us foreigners though.
13:58:16 <Saul_> monochrom: Heathen!
13:58:19 <mrd> one time I mis-used unsafePerformIO with threading, and ended up spitting out a screenful of garbage
13:58:37 <monstre> I'm trying to understand the motivation to have a lazy language in the first place
13:58:42 <mrd> upon further inspection I determined that this "garbage" was not in fact, random, it was simply the output of all my threads ... character by character interleaved.
13:58:50 <DRMacIver> mrd: Ha
13:59:08 <Saul_> Well laziness makes a lot of code more efficient, since it can skip a lot of stuff
13:59:29 <Saul_> monstre: the above statement was meant for you
13:59:30 <SamB> mrd: putStr isn't very efficient is it?
13:59:40 <pejo> DRMacIver, just wrapping things in lambdas was mentioned just a few screenpages up.
13:59:56 <DRMacIver> Well, wrapping things in lambdas is not the same as laziness.
14:00:02 <mrd> SamB: wouldn't know offhand
14:00:11 <Cale> Whoa, heh, gmail went haywire for a moment there and made me think that I'd accidentally posted my message to the list 3 times in a mangled format
14:00:12 <DRMacIver> Because it forces you to recalculate each time you want the value.
14:00:24 <monstre> I'm not sure how well the efficiency argument stands up to reality though
14:00:24 <Cale> (but it turns out it was just displaying things incorrectly)
14:01:17 <Saul_> laziness just means that you only calculate something if you have to, so in a sense you could call C lazy (since there you need to calculate everything)
14:01:19 <SamB> monstre: we can tell you the motivation for using one
14:01:27 <Tac-Work> DRMacIver: However, you could always create a Smart force which cached the result
14:01:35 <monochrom> I don't look at the world from a need-based way. "Do we need a lazy language?" "Do we need Windows?" "Do we need homo sapiens?" They are misguided questions IMO. I look at the world from an evolution-based or market-based way. "Is there room for a lazy language?" "Is there room for Windows?" "Is there room for homo sapiens?" The answer is yes, and so they spring into existence. You don't *need* humans but they still exist and
14:01:35 <monochrom>  dominate and shoot themselves dead.
14:01:56 * lament shoots monochrom 
14:01:58 <monstre> I'm just trying to understand is all
14:02:09 <DRMacIver> Tac-Work: Eh?
14:02:16 <ddarius> monstre: They made lazy languages to see what would happen.
14:02:25 <Tac-Work> You could create something like a lazy object class that takes a function of 0 parameters, and has an "eval" which evaluates and caches the function the first time it's called, then returns that result on subsequent calls
14:02:25 <Philippa> monstre: there are a lot of optimisations that're practical in Haskell that aren't in other languages
14:02:27 <SamB> I suppose nobody needed a lazy language until they tried to run their lazy program ;-)
14:02:32 <mrd> we don't need Windows
14:02:45 <Philippa> if you read (and understand, which may be trickier) the papers on GHC's optimiser then they make that fairly clear
14:02:49 <Philippa> we /did/ need Windows though
14:02:52 <SamB> Tac-Work: I made one of those in Slate
14:03:02 <SamB> I was trying to re-implement Parsec
14:03:05 <SamB> but I got bored
14:03:05 <Philippa> and now a lot of people need something Windows-compatible
14:03:07 <Excedrin> but C has lazy features right?
14:03:16 <mrd> Excedrin: lazy designers
14:03:20 <Excedrin> like, 'if' for example
14:03:20 <SamB> Excedrin: C doesn't even have closures
14:03:25 <Cale> Laziness really helps in defining embedded programming languages and ensuring that no more work is done in evaluating/executing them than necessary.
14:03:29 <d-bug> worse is better :)
14:03:29 <SamB> that's not lazy in C, Excedrin
14:03:34 <SamB> it's *special* in C
14:03:39 <Tac-Work> C not only makes you calculate everything up front, but it even forces you to declare every function twice in your source!
14:03:40 <lament> monstre: the problem is that there's always room for useless programming techniques amongs nerds on freenode, so saying "there's room for Foo" doesn't mean Foo is in any way _useful_ :)
14:03:45 <lament> errr
14:03:45 <SamB> in Haskell we could have gotten by with a function
14:03:46 <Tac-Work> C is a language for a hard worker
14:03:48 <Excedrin> it's weird to me that Haskell's 'if' is "strict"
14:03:48 <lament> monochrom: the problem is that there's always room for useless programming techniques amongs nerds on freenode, so saying "there's room for Foo" doesn't mean Foo is in any way _useful_ :)
14:04:13 <DRMacIver> Excedrin: Eh? In what sense is it strict?
14:04:16 <monochrom> That is right, lament.
14:04:32 <Excedrin> it forces evaluation of the conditional before evaluating the branches obviously
14:04:42 <lament> (i'm speaking as a regular of #esoteric. There's definitely a lot of room for Brainfuck)
14:05:02 <ddarius> Excedrin: How would it make a choice without evaluating the condition?
14:05:03 <SamB> Excedrin: it's got to be strict in something if it's going to be useful
14:05:08 <Tac-Work> I wonder how feasible a lazy brainfuck would be
14:05:19 <mrd> unlambda
14:05:23 <SamB> Tac-Work: what would it do lazily?
14:05:40 <lament> SamB: everything. Do nothing unless there's a "," in the program :)
14:05:41 <Tac-Work> it wouldn't evaluate the value of any cell until it was needed
14:05:42 <monochrom> You can speculate on speculative execution, in which the two branches are executed before the test condition. :)
14:05:59 <Excedrin> well, I guess when I was starting to learn Haskell, it was confusing until I realized that "lazy" really applies to function calls, and not everything in the language
14:06:10 <Saul_> Excedrin: If the if-statements in C would calculate both bodies, things would get hugely chaotic with all those side effects
14:06:15 <SamB> lament: hmm.
14:06:24 <SamB> lament: but if there was?
14:06:32 <monochrom> Pattern matching is also a device that causes evaluations.
14:06:33 <lament> SamB: then just work as normal brainfuck, i suppose :)
14:06:44 <SamB> hahahaha
14:06:46 <Tac-Work> Brainfuck is too complicated anyway. Really, you don't need . or , and [ and ] could be replaced by a "backup" command ! which subtracts the current cell's value from the register
14:07:16 <SamB> Tac-Work: it's not possible to accomplish anything without at least ,
14:07:18 <monochrom> Every language with "short-circuit &&, ||" has a small lazy part.
14:07:42 <Tac-Work> SamB, it wouldn't be interesting without . and , but it would still be turing complete
14:07:52 <Excedrin> monochrom: yes, and is that "small lazy part" enough to build big lazy stuff?
14:08:15 <DRMacIver> If you work really damn hard at it.
14:08:21 <lament> Excedrin: it is, if you write your C program as one expression using short-circuiting.
14:08:29 <Cale> http://programming.reddit.com/info/2bhhg/comments
14:08:30 <lament> :D
14:08:30 <lambdabot> Title: Monads as Computation (reddit.com)
14:08:37 <monochrom> I haven't seen a million-line monster of &&'s, but I guess it could be done. :)
14:08:38 <Excedrin> lament: woah, I don't think you have to go that far
14:09:00 <pejo> DRMacIver, (late reply), isn't call-by-name referred to as "lazy" as well?
14:09:15 <monstre> I'm sorry if that was poor form of me, coming in here demanding why you would want to have a lazy language
14:09:20 <Philippa> pejo: sometimes, but it shouldn't be
14:09:24 <monstre> didn't mean to be rude, just curious
14:09:35 <fasta> "non-strict semantics" is the correct term, AFAIK.
14:09:42 <Excedrin> pejo: yes, that's what I was saying, there's call-by-name and there's graph reduction, and they're sort of orthogonal, but both referred to as "lazy"
14:09:44 <Saul_> pejo: I think they're synonyms
14:09:58 <pejo> monstre, have you read the "Being lazy with class" paper?
14:10:12 <monstre> I think Haskell is a very interesting language, I'm certainly not arguing against its existence
14:10:22 <Saul_> pejo: I've gotten halfway through, haven't continued though
14:10:27 <monstre> I'm just not sure I "get" it...
14:10:34 <monochrom> "let f x = x*x in f (x+x)"  lazy and call-by-name are slightly different on this.  They both postpone evaluation of x+x.  They differ on how many times x+x is evaluated eventually.
14:10:43 <SamB> monstre: we are mostly too young to have been around when Haskell was made
14:10:56 <monstre> pejo: not yet, but I'll have a look
14:11:15 <fax> monochrom: I thought x+x could be evaluated only once in haskell
14:11:20 <monochrom> Yes.
14:11:34 <monochrom> call-by-name evaluates it twice.
14:11:58 <Saul_> Well x+x is evaluated once, but x is done twice
14:12:14 <wli> Laziness in C is typically implemented as something like struct thunk { void *env; void *val; /* call ->f() to compute when NULL */ void *f(void *env); };
14:12:45 <Excedrin> but then with CSE, in GHC or something, you get cases where things like that are actually evaluated once; it's a little confusing
14:13:05 <newsham> when you evaluate (x*x)+(x*x)   if your expression is a DAG instead of a tree, you can share the same node for (x*x)
14:13:10 <newsham> so that you only need to evaluate it once
14:13:54 <Excedrin> newsham: is that how GHC does it, or is it a CSE pass?
14:14:29 <newsham> i believe its done in that graph way.  but I dont know GHC internals.  (i've seen some docs on miranda implementation that hint at that)
14:15:24 <newsham> http://en.wikibooks.org/wiki/Haskell/Haskell_Performance#Graph_Reduction
14:15:27 <lambdabot> http://tinyurl.com/yo4bwu
14:16:21 <Excedrin> I need to re-read the implementing stg paper
14:17:37 <tlittle> so, here's a quick (I hope) question. How would I tell Happs to return an xml content type?
14:18:07 <tlittle> I'm returning xml but the content-type is wrong
14:18:59 <newsham> grep on HAppS sources shows lots of "setHeader "Content-Type" "text/plain") calls
14:19:11 <Saul_> Wooi, I have the HAppS Hello World working :D
14:19:57 * qwr used to use || in C for error handling - which often made >10 lines in if condition ;)
14:21:18 <Saul_> tlittle: As far as I can see from the tutorial (but I'm a complete noob at it) you have to use "ok plain_xml output"
14:21:32 <monstre> So if I understand correctly, the original motivation for lazyness is that it's a errr, strictly more expressive evaluation strategy that could be made to run efficiently given a sufficiently smart compiler?
14:21:37 <monstre> Is that about right?
14:22:02 <DRMacIver> GHC at least is verging on sufficiently smart. :)
14:22:10 <newsham> lazy and strict give the same results except when one returns bottom.  lazy returns bottom less often than strict.
14:22:10 <SamB> DRMacIver: yeah right
14:22:22 <DRMacIver> In certain restricted circumstances...
14:22:26 <DRMacIver> When the weather is right.
14:22:33 <SamB> DRMacIver: okay, that's a little closer
14:22:35 <pejo> monstre, it's optimal wrt to termination, yeah. You can easily create a program that doesn't terminate in strict languages but does in lazy.
14:22:38 <Saizan> tlittle: which type are you useing for your xml?
14:23:50 <tlittle> right now it's just sending it as text/html I think
14:24:28 <monstre> I think I understand the theoretical advantages now, if not the practical ones
14:24:29 <pejo> monstre, and monochrom pointed out an example that would terminate with fewer reduction steps under call-by-need than under call-by-name, a few lines back.
14:24:32 <Saizan> tlittle: i mean the haskell type, not the content-type, String?
14:24:39 <monstre> thanks for the explanations everyone
14:25:31 <tlittle> oh, duh. yeah, it's just a string
14:25:49 <pejo> monstre, there is a paper which I don't remember the title of that you might be interested in. From 97'ish. It's about lazy evaluatoin being asymptotically more efficient. (Anyone happen to know what paper I'm thinking about? Might be some researcher from Oxford).
14:26:11 <Cale> Nobody else modded up my article on reddit? :)
14:26:12 <ddarius> pejo: It was already referenced. "More haste, less speed" or some permutation of that.
14:26:21 <Philippa> monstre: one of the big practical advantages - we can create "control operators" with plain functions where a strict language would need a macro facility or a clumsy encoding
14:26:46 <pejo> ddarius, oh. Good. I'm slow.
14:27:05 <bos> Cale: i did, fwiw :)
14:27:09 <DRMacIver> Cale: I ignore introductions to monads these days. :)
14:27:10 <monstre> I meant practical advantages over a hypothetical strict language with lazyness annotations
14:27:12 <Saizan> tlittle: ok, so you've to set the header by hand, something like respond $ setHeader "Content-Type" "text/xml" (toMessage xml_string)
14:27:13 <qwr> (and i've heard about at least one weird impure lazy language - jaskell)
14:27:17 <qwr> http://jaskell.codehaus.org/Object+Orientif
14:27:18 <lambdabot> Title: Jaskell - Object Orientif
14:27:37 <DRMacIver> Oh yeah. I'd forgotten about Jaskell.
14:27:43 * ddarius is just happy that Cale is more "Monads as computations" rather than "Monads as containers" these days.
14:27:46 <Excedrin> CAL is also impure afaik
14:28:30 <DRMacIver> Containers are computations. In the same way that datastructures are algorithms. :)
14:28:41 <Cale> DRMacIver: yes :)
14:28:51 * monochrom thinks "from data structures to control strutures" is a catchy name for a monad book or something.
14:28:59 <newsham> monstre: see pgs 46-48: http://www.cs.ucla.edu/~palsberg/course/purdue/cs565/F99/lecture2.ps
14:29:01 <lambdabot> http://tinyurl.com/yuow2d
14:29:07 <Cale> monochrom: That's an excellent name for a book.
14:29:16 <monstre> I'm skeptical of the value of lazyness as a default only, I don't want to eliminate it altogether
14:29:21 <newsham> evaluation of lambda exprs, strict and non-strict, and does it make a difference
14:29:22 <Tac-Work> I think any book that actually uses the word "Monads" would make a good title for a book on Monads
14:29:27 <Tac-Work> Monad is just a funny word
14:29:31 <ddarius> monstre: Fine.  Then don't use Haskell or Clean.
14:29:32 * wli knows Jens Palsberg.
14:29:37 <DRMacIver> (Actually I'm not sure I could justify the 'containers are computations' part at the moment. It sounds good though. :) )
14:29:47 <Tac-Work> "Ack! Monads!: An introduction to Monads using Haskell"
14:29:52 <monstre> ddarius: was that really necessary?
14:29:53 <newsham> I dont know him, but I like his lecture notes :)
14:30:08 <Excedrin> there's a lot of people who like lazyness, but with strict by default
14:30:08 <ddarius> monstre: I'm just stating the fact.
14:30:15 <monstre> if you can point me to strict Haskell, I'll be happy to leave you guys alone
14:30:24 <newsham> monstre: ocalm's close
14:30:25 <monstre> ML isn't quite it
14:30:27 <Excedrin> Alice ML
14:30:37 <ddarius> Qi
14:30:49 <Excedrin> except Alice has type-safe distributed computing stuff...
14:30:57 <monstre> Qi is derived from Lisp, right?
14:31:01 <Cale> monstre: The benefit of laziness as a default is something that isn't easy to convey in a few short sentences or small examples.
14:31:19 <Cale> monstre: It comes from being able to decompose problems in new ways that you can't in a strict language.
14:31:38 <newsham> having infinite data structures is nice.  it often allows you to factor out code thats not easily factored out in imperative languages that dont have generators or coroutines
14:31:52 <Cale> and, dually, the ability to put consistently lazy library functions togetherin ways that wouldn't make sense in a strict language
14:32:00 <monstre> Cale: that's what I'm skeptical of, that you can't do it in a strict language using just lazy cons
14:32:17 <ddarius> monstre: You need more than just lazy conses.
14:32:28 <newsham> monstre: I'm sure you can.  you can also do memory management by hand.
14:32:32 <monstre> Okay, what else do you need?
14:32:33 <Cale> monstre: That's just lists, and it typically introduces enough syntactic overhead that people don't *consistently* use it
14:32:38 <newsham> some people prefer doing memory management by hand...
14:32:41 <newsham> I personally do not
14:32:59 <Cale> The benefit of laziness is defeated as soon as you have a library function which ought to be lazy but isn't.
14:33:21 <newsham> cale: I wouldnt say "defeated", definitely a lost opportunity.
14:33:22 <Excedrin> Cale: aren't there many of those in Haskell's libs?
14:33:28 <monstre> Cale: do you have an example in mind?
14:33:31 <Cale> Excedrin: not so many.
14:33:48 <monstre> What exactly is the problem with a strict map over a lazy list for instance?
14:33:51 <Cale> monstre: Let's take a simple example I like to use, even though it's not the best one, it's small
14:33:57 <ddarius> You cannot get the effect of a lazy language with just local transformations (or vice versa, you can't get the effect of a strict language with just local transformations in a lazy one).
14:34:02 <newsham> monstre: here's a good example -- most of python :)   python has nice generators/iterators, but they are not completely integrated throughout
14:34:12 <Cale> isSubstringOf x y = any (isPrefixOf x) (tails y)
14:34:30 <Cale> This is a pretty stupid piece of code to write in a strict language.
14:34:49 <monstre> Cale: someone beat you to this example, I understand it would work just fine in my hypothetical language
14:34:50 <newsham> cale: why?
14:34:55 <monstre> Am I mistaken?
14:34:56 <Cale> Construct all the tails of y, then check if any of them has x as a prefix.
14:35:19 <newsham> cale: but if you can conditionally make lazy generators, it still works well in an otherwise strict language
14:35:27 <Cale> If any, isPrefixOf, and tails were all written to use lazy conses, you'd be fine.
14:35:37 <Cale> If one of them was strict, you'd start wasting effort.
14:35:59 <monstre> but they're all built using cons, you just need a lazy cons
14:36:06 <Cale> These are all standard list library functions
14:36:31 <newsham> in python I define "any" over all iterables, which include lists and generators
14:37:01 <Cale> Another thing is that it's not enough just to have lazy lists. Of course lazy lists are useful, but just as loops are not the only form of recursion, lists are not the only recursive datastructure.
14:37:02 <thorat> The lazyness debate is probably somewhat similar to the garbage collection debate a few years ago.
14:37:31 <monstre> so you want lazy trees as well, I don't see the problem
14:37:56 <Cale> Well, any lazy data type. And I want the libraries all to use them as much as possible.
14:38:12 <newsham> I think programmers are more than capable of managing their own strict/laziness.  I think the only debate is whether they want to or not.
14:38:12 <ddarius> @google "Why functional programming matters"
14:38:16 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
14:38:16 <lambdabot> Title: Why Functional Programming Matters
14:38:21 <Tac-Work> Garbage collection slows down my language too much, I'd rather deal with the memory leaks
14:38:26 <Tac-Work> (w)
14:38:29 <Cale> This is the case in Haskell -- don't get me wrong, strictness has its place, but that's what strictness annotations are for.
14:38:32 <newsham> (just as manual/automatic memory management debate)
14:38:45 <ddarius> thorat: No.  The options are much more equal.
14:39:03 <Cale> Here's another take on it... there are essentially 4 kinds of function:
14:39:03 <monstre> You could even imagine a language where recursive datatypes are lazy by default, but nothing else is
14:39:05 <monochrom> There was a debate on manual or automatic register allocation.  (duck)
14:39:05 <thorat> ok
14:39:29 <Excedrin> newsham: yes, but strictness and laziness aren't the same as manual/automatic memory management, at least, if most of your code is strict, then lazy by default is bad and vice versa
14:39:40 <Saizan> to get all the benefits of occasional lazyness in a strict language you'll end up with all your datastructures and library functions as lazy, so is it still a strict language?
14:39:44 <monstre> with all due respect, I don't see the parallel with garbage-collectino at all
14:39:52 <newsham> exce: no, they're different things, for sure.  I just think there are aspects of the debate that are similar.
14:40:18 <monochrom> I can see the parallel.
14:40:18 <monstre> Saizan: it would be just as strict as you would want, but no more
14:40:19 <Cale> Functions from "small" or "large" data structures to "small" or "large" data structures, where "small" and "large" refer to the number of seprately evaluable subcomponents of the structure.
14:40:36 <Excedrin> well, it's definitely valid that lazy by default might lead to a higher level of programming in general, similar to GC in general
14:40:50 <newsham> I still write a lot of python and I get many of the benefits of laziness using generators (which I use because haskell has shown me the light).
14:40:52 <Cale> In the case where you're going from small to small, lazy and strict are basically equivalent.
14:40:58 <newsham> I do occasionally miss having full laziness everywhere
14:41:01 <monstre> I would argue that Haskell is rather more lazy than I would want
14:41:01 <thorat> my point was:  If you're used to managing memory, you don't realize what you're missing.  If you're used to sequencing your computations, you don't want lazyness.
14:41:08 <Cale> In the case where you're going from small to large, lazy is better.
14:41:22 <Cale> (since you might not have to compute all of your result)
14:41:26 <newsham> monstre: is that a first impression or one built up from experience?
14:41:34 <Excedrin> monstre: I think you have to get immersed in the lazy style for a while before you can say that; how do you know what you want otherwise?
14:41:39 <monstre> pure speculation I'm afraid
14:41:47 <Cale> In the case where you're going from large to large, generally lazy is better (since you might be able to stream)
14:41:55 <newsham> monstre: give it a whirl, you might not change your mind, but either way, its fun.
14:42:04 <Cale> In the case where you're going from large to small, this is where you want strictness.
14:42:09 <monstre> I am, and it is a great deal of fun
14:42:18 <Cale> That's 1 out of 4 where it really matters to have strictness.
14:42:34 <Cale> (and maybe a few of the large -> large cases)
14:42:57 <newsham> one thing i think is really neat about laziness is the ability to define your own control flow constructs without resorting to macros.
14:43:10 <Tac-Work> Sometimes I wonder if the average person spends more time discussing their langauges than actually coding
16:42:46 --- topic: '["OSCON Videos http://tinyurl.com/22avoy ","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]'
16:42:46 --- topic: set by glguy on [Fri Jul 27 19:52:22 2007]
16:49:38 <hpaste>  laz0r annotated "how would >>= look like? does this even make sense?" with "maybe more like this" at http://hpaste.org/2006#a2
16:56:00 <Alleria> I've a question about list comprehensions -- is there a way to test for a certain condition, and if it's met, do a "break"?
16:56:47 <Alleria> i.e. given [ f x y | x <- list1, y <- list2, someGuard x y]
16:57:07 <shachaf> Alleria: What do you mean by "break"?
16:57:16 <shachaf> Alleria: Return an empty list?
16:57:19 <elliottt> Alleria: i'd use filter
16:57:26 <Alleria> shachaf: not quite
16:57:32 <laz0r> Alleria, i am a beginner myself, but the first thing i thought when you asked was: maybe he should just filter the list before comprehension
16:57:41 <laz0r> oh, ok...
16:57:44 <Alleria> I mean...
16:58:02 <Alleria> really a comprehension like the one I wrote is implemented as two imperative loops
16:58:06 <Alleria> one inside the other
16:58:23 <Alleria> at least to a first approximation, if my understanding of the list monad is correct.
16:58:29 <shachaf> Alleria: It's implemented as two maps and two concats (and a guard statement).
16:58:31 <Alleria> Given that, is there any way to 'break' out of the inner loop?
16:58:40 <xerox> There's a way to do it with ListT and Cont, but from our investigation it doesn't get you a monad.
16:59:10 <twanvl> [ f x y | x <- list1, y <- takeWhile someCondition list2]
16:59:31 <Alleria> no, in that case I would filter list2 first.
16:59:39 <Alleria> I mean a condition that depends on both lists.
16:59:57 <twanvl> you can have the condition depend on the current element x
17:00:09 <Alleria> twanvl: oh!
17:00:18 <Alleria> twanvl: or x and y?
17:00:43 <twanvl> > [ (x,y) | x <- [1..3], y <- takeWhile (<x) [1..3] ]
17:00:44 <lambdabot>  [(2,1),(3,1),(3,2)]
17:01:24 <Alleria> twanvl: I understand that... but it still doesn't do quite what I need.
17:01:49 <Alleria> what I need to to stop taking more elements out of y... but with a condition that depends on both x and y itself.
17:02:06 <Alleria> err, taking more elements out of the list that generates y, I mean.
17:02:49 <twanvl> The condition-function is passed 'y' as a parameter; you can read the code I gave above as:
17:02:56 <shachaf> Alleria: y <- takeWhile (\y -> f x y) [1..3], no?
17:02:57 <twanvl> > [ (x,y) | x <- [1..3], y <- takeWhile (\y -> y < x) [1..3] ]
17:02:58 <lambdabot>  [(2,1),(3,1),(3,2)]
17:04:05 <Alleria> > [ x*y | x <-[1..10], y <-[1..10], x*y < 6 ]
17:04:07 <lambdabot>  [1,2,3,4,5,2,4,3,4,5]
17:04:37 <Alleria> so given that list comprehension, obviously a lot of extra work is being done. How do I get y to "break" wheneever x*y gets to be >= 6?
17:05:08 <shachaf> Alleria: You just want the first combination that works?
17:05:38 <dozer> @src concatmap
17:05:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:05:41 <Alleria> shachaf: given that list comprehension, it still goes x = 1, y = 6, x = 1, y = 7, and does a lot of extra work.
17:05:50 <dozer> @src catmap
17:05:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:05:58 <Alleria> @src concatMap
17:05:59 <lambdabot> concatMap f = foldr ((++) . f) []
17:06:00 <shachaf> Alleria: would you want it to return?
17:06:08 <dozer> thanks, it's late in the day
17:06:09 <Alleria> shachaf: yes
17:06:19 <shachaf> Alleria: Which one?
17:06:29 <Alleria> I mean, given [ x*y | x <-[1..10], y <-[1..100], x*y < 6 ]
17:06:34 <shachaf> Alleria: You want just the list of all xs and the first y that matches?
17:06:43 <shachaf> (For each x?)
17:06:52 <Alleria> no, all the xs and all the ys that match, until such time that y's stop matching.
17:07:23 <shachaf> As soon as one y stops matching, you want to stop taking new ys?
17:07:31 <Alleria> shachaf: exactly!
17:07:40 <shachaf> So what's wrong with the takeWhile?
17:07:58 <Alleria> shachaf: so for  [ x*y | x <-[1..10], y <-[1..100], x*y < 6 ], it's not the y that stops matching, it's the x*y that stops matching being less than 6.
17:08:02 <Alleria> How would you re-write that?
17:08:05 <shachaf> > [x*y | x <- [1..10], y <- takeWhile (\y -> x * y < 6) [1..100]]
17:08:07 <lambdabot>  [1,2,3,4,5,2,4,3,4,5]
17:08:32 <shachaf> > [x*y | x <- [1..10], y <- takeWhile ((<6) . (*x)) [1..100]]
17:08:33 <lambdabot>  [1,2,3,4,5,2,4,3,4,5]
17:08:35 <shachaf> No?
17:08:47 <Alleria> ahh, I see!
17:08:50 <Alleria> That does work!
17:08:51 <Alleria> thanks!
17:09:08 <shachaf> Alleria: That was twanvl's suggestion before, I think.
17:09:30 <nominolo> @index finally
17:09:30 <lambdabot> Control.Exception, Distribution.Compat.Exception
17:09:34 <elliottt> > [x*y | x <- [1..10], y <- [ y' | y' <- [1..100], x * y' < 6]]
17:09:35 <lambdabot>  [1,2,3,4,5,2,4,3,4,5]
17:09:53 <shachaf> elliottt: That also works.
17:09:59 <Alleria> :blinks: oh wow, nested comprehensions!
17:10:01 <Alleria> cool!
17:10:05 <sorear> it
17:10:06 <elliottt> :)
17:10:11 <sorear> 's an expression!
17:10:27 <dylan> sorear is an expression!
17:10:58 <Alleria> I never realized just how truly general Haskell is :D
17:11:04 <Alleria> that definitely shows it off though!
17:12:11 <dons> ?userrs
17:12:11 <lambdabot> Maximum users seen in #haskell: 382, currently: 339 (88.7%), active: 21 (6.2%)
17:12:18 <elliottt> it's definitely an amazing language :)
17:23:02 * wli wants to write his own monad tutorial when he grows up.
17:25:32 <shachaf> Has anyone written a monad tutorial tutorial?
17:25:36 <shachaf> Yet?
17:25:51 <elliottt> a tutorial on finding monad tutorials?
17:25:52 <Alleria> Hahaha
17:25:59 <shachaf> elliottt: On writing them.
17:26:04 <SamB> hahahaha
17:26:07 <elliottt> shachaf: ah, hehehe
17:26:15 <Alleria> http://haskell.org/haskellwiki/Meta-tutorial
17:26:16 <lambdabot> Title: Meta-tutorial - HaskellWiki
17:26:33 <Alleria> the how to find monad tutorials apparently has been done ;)
17:27:18 <elliottt> hehe
17:27:32 <elliottt> shachaf should add to the meta tutorial, a section about writing tutorials
17:28:04 <wli> So what makes a good monadic programming exercise?
17:29:08 <shachaf> wli: Reimplement some simple monads if you haven't already.
17:29:17 <shachaf> Reader/State/Writer, for example.
17:29:42 <shachaf> At what level do you mean?
17:30:01 <wli> schachaf: Intermediate. One can eke out code that uses monads but not make effective use of them.
17:30:51 <wli> schachaf: (and apparently recite the implementations of basic monads on demand)
17:31:58 <SamB> wli: okay, now recite IO :-P
17:32:06 <nominolo> :t uncurry
17:32:08 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:32:24 <shachaf> SamB: IO is magic.
17:32:25 <wli> SamB: Insert compiler magic here.
17:32:42 <elliottt> one thing that really helped me was just figuring out why "filterM (const [True,False])" would generate the powerset
17:32:47 <SamB> hence the :-P
17:32:51 <nominolo> @index uncurry
17:32:51 <lambdabot> Data.Tuple, Prelude
17:33:02 <wli> elliottt: I can't figure that out offhand.
17:33:11 <elliottt> :)
17:33:17 <SamB> wli: pencil & paper?
17:33:35 <wli> SamB: Programming exercises. Writing code.
17:34:09 <SamB> wli: I mean, if you can't figure it out off hand...
17:34:40 <sorear> @src thenIO
17:34:40 <lambdabot> thenIO (IO m) k = IO ( \ s ->
17:34:40 <lambdabot>   case m s of (# new_s, a #) -> unIO k new_s)
17:34:43 <elliottt> wli: http://community.livejournal.com/evan_tech/220036.html
17:34:44 <lambdabot> Title: evan_tech -- powerset
17:34:48 <sorear> @src returnIO
17:34:48 <lambdabot> Source not found. I feel much better now.
17:36:15 * shachaf can see how (filterM (const [True,False])) works, but does not feel that he understands it completely.
17:37:03 <shachaf> I guess it's like foldl (flip (:)) []; I understood that one mechanically for a while before seeing why it makes sense intuitively.
17:37:09 <shachaf> @src reverse
17:37:09 <lambdabot> reverse = foldl (flip (:)) []
17:38:04 <sorear> Who thinks there should be a @src+ ?
17:38:20 <monochrom> What does @src+ mean?
17:38:21 <shachaf> That might be a good idea.
17:38:27 <sorear> @uptime
17:38:27 <lambdabot> uptime: 4d 20h 20m, longest uptime: 1m 10d 23h 44m 29s
17:38:32 <dons> Igloo: so the bytestring tests are working?
17:38:33 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:38:35 <shachaf> How would it work with multiline sources? @src+++
17:38:40 <shachaf> @karma @src+
17:38:40 <lambdabot>  @src+ has a karma of 0
17:38:43 <Igloo> dons: No
17:39:00 <Igloo> dons: I'm not pushing the patches to the existing libraries yet
17:39:15 <sorear> shachaf: don't forget this is the #perl6 bot too.  it's rigged to ignore anything that looks like a sigil
17:39:36 <wli> Okay, I understand how filterM (const [True, False]) works.
17:39:52 <wli> I don't feel enlightened, though.
17:39:58 <elliottt> hehe, neither did i :)
17:40:07 <sorear> shachaf: I was thinking @src+ foldr "foldr f z []     = z\nfoldr f z (x:xs) = x `f` foldr f z xs"
17:40:16 <dons> Igloo: so ` patch applied (packages/array): bytestring is now in its own package' was removing bytestring from where?
17:40:19 <monochrom> You are enlightened when you don't feel enlightened.
17:40:19 <elliottt> it wasn't until i started working through projects with parsec that i started to feel confident in my use of the monads
17:40:23 <dons> http://www.blip.tv/file/325646/
17:40:24 <shachaf> OK, that would work.
17:40:24 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part II
17:40:36 <shachaf> @src foldr
17:40:37 <lambdabot> foldr k z xs = go xs
17:40:37 <lambdabot>     where go []     = z
17:40:37 <lambdabot>           go (y:ys) = y `k` go ys
17:40:46 <Igloo> dons: That's the new array library; I haven't pushed that patch to base yet
17:40:51 <shachaf> Why does it do that?
17:41:05 <Igloo> dons: Sorry, it's a bit confused because I have various other patches in my local repos
17:41:08 <monochrom> code optimization.
17:41:17 <sorear> shachaf: it's more efficient, because they haven't implemented the static argument transformation in GHC yet
17:41:26 <dons> Igloo: ah ok. I didn't realise bytestring was in the array library :)
17:41:36 <shachaf> sorear: They haven't?
17:41:50 * shachaf is somewhat surprised.
17:41:54 <Igloo> dons: It wasn't, but I made the array library with cp -a base array
17:41:55 <sorear> I don't think so.
17:42:44 <dons> Igloo: yes, I see.
17:43:18 <shachaf> sorear: So your foldr passes the f and z on every recursion?
17:43:18 --- mode: ChanServ set +o dons
17:43:28 * shachaf hopes that's not a big efficiency problem.
17:43:38 --- topic: set to '["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
17:44:16 <Igloo> Is AToH In exactly 2 parts?
17:44:27 <sorear> shachaf: Well, it has to pass f and z either way; remember that go has free variables and so the closure arguments have to be passed.  But GHC's inliner is *much* more effective on the where-form.
17:44:34 <dons> Igloo: not sure yet.
17:44:36 --- mode: ChanServ set -o dons
17:44:59 <shachaf> dons: What are @topic-cons and friends for if nobody uses them?
17:45:16 <shachaf> sorear: Hmm, OK.
17:47:01 <sorear> shachaf: Changing the topic.  But they only work if the bot is allowed to do that
17:47:36 <shachaf> sorear: Oh. And why isn't she allowed to do that?
17:47:52 <sorear>  [17:46] [sorear(+6e)] [2:#haskell(+cnt)] [Act: 3,4,5,6,7,8,9,10,11,12,13,14]
17:48:04 <sorear> +t == changing topic restricted to ops
17:49:58 <jbalint> Hi, i cant understand what all these parameters are. is it described somewhere i cannot see? http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-Drawable.html#v%3AdrawArc
17:49:59 <lambdabot> http://tinyurl.com/yrulz5
17:50:37 <sorear> jbalint: Yes, the Gtk+ reference manual.
17:50:45 <dcoutts> jbalint: I'd suggest using Cairo instead if you can, it's a much nicer api and produces much better output
17:50:54 <sorear> a bit of a shame that we can't propagate the docs
17:50:54 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
17:50:56 <lambdabot> http://tinyurl.com/tkkq9
17:51:10 <dcoutts> sorear: we do partially, but not the gdk bits quite so much
17:51:24 <jbalint> this is much better doc! http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html#v%3AmaskSurface
17:51:26 <lambdabot> http://tinyurl.com/tkkq9
17:51:32 <jbalint> :D i will try this , hopefully its clearer
17:52:02 <dcoutts> jbalint: yes, it's newer and nicer. Cairo is Gtk+'s new rendering api, Gdk is the old one.
17:52:13 <jbalint> so is gdk deprecated now?
17:52:19 <dcoutts> basically yes
17:52:20 <jbalint> or just "not for new development"?
17:52:33 <dcoutts> yes, not for new development
17:52:39 <dcoutts> it's not going to go away
17:53:07 <dcoutts> and it also provides various windowing functions that are certainly going to stay around
17:53:22 <dcoutts> it's only the gdk drawing api that is deprecated, the rest of it is fine
17:53:31 <jbalint> does cairo scale your lines if the canvas grows? so you dont have to repaint?
17:53:59 <dcoutts> jbalint: no, but it does provide zoom functions so it's trivial to implement
17:54:05 <Tac-Tics> How nice is GTK+?
17:54:08 <sorear> jbalint: No, application maintains window state is one of the core tenets of the X11 graphics stack
17:54:15 <dcoutts> jbalint: cairo is an immediate drawing api, not a canvas
17:54:22 <Tac-Tics> I've always been kinda interested in learning it
17:54:47 <dcoutts> Tac-Tics: well it's quite nice in Haskell or other high level languages, in C it's a bit painful
17:55:14 <monochrom> Does G stand for GIMP?
17:55:28 <dcoutts> monochrom: in Gtk+, yes.
17:55:33 <monochrom> Thanks.
17:55:49 <dcoutts> it was originally implemented for the GIMP
17:55:56 <dcoutts> back in pre history
17:56:07 <monochrom> Yeah.
17:57:00 <monochrom> Well, if Gimp's early days were pre-history, I wonder if the lambda calculus was fossil material :)
17:58:43 <SamB> so what are they going to call GDK? GWK?
18:00:36 <sorear> Well the STG machine isn't spineless or tagless and bears relatively little relation to Augustsson&Johnsson's G, so I don't think it will be a problem ;)
18:00:52 <SamB> hmm.
18:01:17 <SamB> weren't we going to call that the Spined, Tagged, G-like machine now?
18:01:42 <SamB> now that it's neither spineless nor tagless?
18:01:48 <SamB> or maybe G-derivivative
18:01:55 <wli> G'
18:02:49 <monochrom> G-Force :)
18:06:45 <SamB> doesn't this look kind of lame:
18:06:49 <SamB> @go Samuel Bronson
18:06:52 <lambdabot> http://www.ohloh.net/accounts/6511
18:06:52 <lambdabot> Title: Samuel Bronson - Ohloh
18:08:06 * SamB points to the distinct lack of any real Haskell projects on that page
18:10:28 <Tac-Tics> dcoutts: Why is C GTK+ painful?
18:10:48 * shachaf guesses that's because C is painful. :-)
18:10:58 <Tac-Tics> I guess I should ask
18:11:07 <Tac-Tics> Relative to the painfulness of C, how painful is GTK+
18:11:13 <sjanssen> SamB: how are projects added?
18:11:17 <dcoutts> Tac-Tics: because C is painful :-)  Gtk+ uses a more sophisticated type system than can be expressed in C
18:11:39 <dcoutts> Tac-Tics: and because C does not support closures, so doing callbacks is rather verbose
18:11:49 <Tac-Tics> How is a DWORD not an expressive type? You can express anything at all with a DWORD and malloc!
18:11:56 <Tac-Tics> It can be an int, or a pointer to an int....
18:11:59 <dcoutts> so using Gtk+ in C requires type casting and is still not type safe
18:12:04 <Tac-Tics> or a pointer to a pointer to an int!!!
18:12:28 <dcoutts> in Haskell, we can properly express the Gtk+ type system, so it's safe and requires no explicit casts
18:12:45 <dcoutts> and callbacks are easy and convenient
18:13:53 <SamB> sjanssen: the trouble is that it doesn't support darcs yet :-(
18:14:09 <sjanssen> SamB: ah, that's a problem
18:14:34 <SamB> if enough of us signed up and stacked darcs, that might help
18:16:15 <SamB> here's my stack: http://www.ohloh.net/accounts/6511/stacks/default
18:16:16 <lambdabot> Title: Samuel Bronson's Stack - Ohloh
18:17:25 <SamB> that has links to GHC, darcs, etc.
18:18:26 <Tac-Tics> can anyone give me an example of how to use runCont?
18:18:36 <Tac-Tics> a *simple* example?
18:20:22 <dolio> > runCont (return 5)
18:20:23 <lambdabot>  Add a type signature
18:20:29 <dolio> > runCont (return 5) id
18:20:31 <lambdabot>  5
18:20:35 <Tac-Tics> heh
18:22:42 <sorear> Tac-Tics: You can't express stuctures larger than 16GB if you insist on making DWORD* injectively representable as DWORD.
18:23:11 <sorear> Tac-Tics: 4GB, if you decide that a DWORD takes up 4 adresses
18:24:48 <dolio> Tac-Tics: Did you mean an example of using continuations?
18:24:55 <Tac-Tics> I don't think ghc can compile structures greater than 16GB anyway
18:25:17 <Tac-Tics> dolio: yeah. I'm looking at an example I found on google now though
18:25:31 <dolio> Ah, okay.
18:27:00 <sorear> Tac-Tics: it can on 64-bit platforms...
18:27:20 <Tac-Tics> curse you Itanium!
18:27:24 <dolio> There are probably lots of examples of call/cc in scheme that you could read. It's fairly straight forward to translate those to Cont.
18:27:28 <Tac-Tics> and sparc.... and amd
18:28:11 <dons> who ws looking at ropes in haskell? http://groups.google.com/group/fa.caml/browse_frm/thread/4e70beff0f714229/
18:28:12 <lambdabot> Title: fa.caml | Google Groups, http://tinyurl.com/yw77xn
18:30:16 <sorear> Of course, Cont is vastly nicer than call/cc; because it provides Cont (the data constructor), which is *usually* a more natural primitive.
18:31:08 <sorear> ?let generator = mapM_ (Cont . (:)) [0..]
18:31:12 <lambdabot> Couldn't match expected type `a -> r' against inferred type `[a1]'
18:31:13 <dolio> Funnily enough, one argument you could make is that Cont is nicer because it's naturally delimited.
18:31:18 <wli> @hoogle Monad m => (c -> m a) -> (a -> m b) -> (c -> m b)
18:31:18 <lambdabot> No matches, try a more general search
18:31:40 <dolio> Since it's a monad, and you have to run it to get a pure value at some point.
18:31:41 <sorear> wli: >=> from GHC 6.7's Control.Monad
18:31:50 <dolio> So it can't mess with your whole program.
18:32:58 <xpika> can someone here on linux run ldd on hugs or ghc?
18:33:18 <sorear> Yes.
18:34:46 <hpaste>  sorear pasted "for xpika" at http://hpaste.org/2027
18:35:47 <sorear> :t sequence_ [ Cont (\k -> x : k ()) | x <- [0..] ]
18:35:50 <lambdabot> forall t. (Num t, Enum t) => Cont [t] ()
18:36:10 <sorear> Challenge: Write a Scheme call/cc generator example in less than 5 lines
18:36:23 <sorear> Or a Haskell callCC example!
18:36:33 <SamB> sorear: I don't even understand call/cc in scheme
18:36:41 <SamB> it makes my head hurt when I try
18:36:50 <shachaf> sorear: Generator? You mean it returns the next number each time you call it?
18:37:25 <shachaf> sorear: Probably something more complicated than that.
18:38:10 * shachaf should look into the Cont monad.
18:43:12 <dolio> That isn't a particularly useful example, is it? You might as well write [0..]
18:44:26 <|Steve|> SamB: I noticed that my pl students (who are studying scheme) who understood explicit continuation passing style didn't really get call/cc and those who got call/cc didn't get CPS.
18:45:07 <SamB> if I were one of your students, I'd be in the former category
18:45:35 <Nafai> SamB: You understand Haskell yet something makes your head hurt? :)
18:45:37 <|Steve|> That's where I was.
18:46:20 <SamB> Nafai: lots of things do
18:46:26 <Nafai> I understand the basics of Scheme but Haskell makes my head hurt
18:46:31 <SamB> I use Haskell to make my head hurt less!
18:46:51 <Nafai> I *think* I understand everything from the first half of A Taste of Haskell
18:47:08 <shachaf> Nafai: And the second half?
18:47:26 * Cale is watching too just to see what SPJ said to everyone :)
18:47:26 * shachaf has not watched either yet.
18:47:42 <Nafai> shachaf: Haven't had a chance to watch it yet; I'll watch it tomorrow morning at work
18:47:59 <SamB> Nafai: I believe SPJ stated in http://video.google.co.uk/videoplay?docid=370317485066035666&hl=en-GB that we don't like asprins. he was right!
18:48:01 <lambdabot> Title: Nested Data Parallelism in Haskell, http://tinyurl.com/2e7u76
18:48:03 <Cale> OSCON has a nice fast server. :) It's downloading at 970 KB/s here.
18:48:31 <Nafai> Java makes my head hurt in a different way :)
18:48:39 <shachaf> Cale: That's not OSCON's server, I think.
18:49:26 <dolio> I suppose the useful generalization is: Data.Foldable.sequence_ . fmap (\a -> Cont (\k -> a : k ()))
18:49:28 <fax> sorry but I can't find the video.. does anyone have a link? I'm curious now
18:49:54 <Cale> oh, right, it's blip.tv
18:49:54 <SamB> @go site:haskell.org videos
18:49:57 <lambdabot> http://haskell.org/haskellwiki/Video_presentations
18:49:57 <lambdabot> Title: Video presentations - HaskellWiki
18:50:14 * SamB doesn't know if that has it or not -- but it clearly should
18:50:18 <fax> thanks :D
18:50:34 <shachaf> fax: In the topic. :-)
18:50:36 <SamB> ah yes it has
18:50:39 <fax> lol
18:50:42 <fax> oh -_-
18:50:50 <SamB> shachaf: who reads those?
18:50:51 <fax> It wasn't there when I /joined
18:51:09 <SamB> my client always scrolls to the end anyway
18:51:29 <shachaf> Hmm, irssi shows the beginning of the topic on the first line for me.
18:51:38 <reffie> ?src asks
18:51:38 <lambdabot> asks f = do
18:51:38 <lambdabot>     r <- ask
18:51:38 <lambdabot>     return (f r)
18:52:10 <blackdog> How do I wrap Binary? I have an instance for Map.Map Char Int already, and just want to be able to have the same thing for a datatype "newtype MapIndex = MapIndex (Map.Map Char Int)" ...
18:52:34 <xpika> thanks sorear
18:53:09 <sorear> blackdog: use{ get = fmap MapIndex get; put (MapIndex x) = put x }
18:53:17 <sorear> blackdog: or newtype deriving
18:55:35 <reffie> @hoogle asks
18:55:35 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
18:56:44 <shachaf> Will hawiki/its content ever be back?
18:57:59 <fax> O_o
18:58:03 <fax> xmonad is 500 lines?!
18:58:11 <jfredett> yep
18:58:12 <jfredett> :)
18:58:13 <shachaf> fax: A bit more.
18:58:22 <shachaf> fax: I think it's ~600 now?
18:58:33 <justcme> can anyone tell me how to get coloured output using putStr and the like? i'm using linux, if that helps.
18:58:38 <shachaf> (And this doesn't include contrib modules, of course.)
18:59:11 <blackdog> sorear: thanks
18:59:17 <mm_freak> justcme: the portable way would be using some library
18:59:35 <blackdog> i tried "deriving Binary", but it said Binary isn't deriveable...
18:59:42 <mm_freak> i think, vty supports such a thing, but there is also a curses library
18:59:52 <justcme> mm_freek: ok, thanks for that
19:00:50 <SamB> fax: to be fair, that X11-extras package is developed in tandom with xmonad (though it's really just for things that were left out of the X11 package)
19:01:16 <shachaf> Will it be merged with X11 sometime?2
19:06:27 <dons> i could imagine them being merged, shachaf
19:07:22 <SamB> shachaf: probably after it settles down some
19:10:44 <hpaste>  DukeDave pasted "Generalisation" at http://hpaste.org/2028
19:11:09 <DukeDave> Howdy Haskellers
19:11:18 <Cale> hello
19:11:36 <DukeDave> I think I'm close to beauty with that paste but can't quite make the jump
19:12:08 <Cale> hmm...
19:12:14 * DukeDave grumbles at hpaste's non wrapping of comments
19:14:19 <hpaste>  blackdog pasted "Binary instance" at http://hpaste.org/2029
19:15:03 <blackdog> any idea why ghc complains about this? it looks pretty simple to me - the instance for MapIndex should be just the same as that for Map.Map Char Int...
19:15:20 <Cale> blackdog: what's the error?
19:15:44 <SamB> spj is behind the times isn't he? using xnest, I mean...
19:16:29 <hpaste>  DukeDave annotated "Generalisation" with "My stab at it.." at http://hpaste.org/2028#a1
19:17:12 <DukeDave> @seen glguy
19:17:12 <lambdabot> I saw glguy leaving #haskell 1h 15m 12s ago, and .
19:17:19 <hpaste>  blackdog annotated "Binary instance" with "annotated with error message" at http://hpaste.org/2029#a1
19:18:19 <bos> blackdog: shouldn't you be using Data.Binary?
19:18:43 <bos> yeah, you're using entirely the wrong package
19:18:46 <blackdog> bos: you are a very helpful man.
19:19:07 <blackdog> that would explain some of the more baffling error messages i've been getting.
19:19:10 <bos> i couldn't even tell you what plain  Binary is for, other than that it's internal to GHC
19:19:47 <hpaste>  Cale annotated "Generalisation" with "another way" at http://hpaste.org/2028#a2
19:20:18 <SamB> where are the slides for A Taste of Haskell?
19:21:13 <Cale> DukeDave: not sure if that's really where you were going with it, but it's one way to handle things
19:21:19 <SamB> oh there they are...
19:21:54 <Cale> DukeDave: you don't have to compute the length so often
19:22:05 <SamB> ah, and someone added to the wiki now when I was about to do it ;-)
19:22:32 <DukeDave> Cale: I'm  intrigued :)
19:23:06 <Cale> DukeDave: when you zip two lists, and one is longer than the other, it just stops when it runs out of elements in the shorter list
19:23:22 <Cale> DukeDave: So zipping with [0..] will pair up each element with its index
19:23:46 <Cale> You don't have to bound it by the actual length (which takes a bunch of time, because it has to run to the end of the list to do that)
19:26:39 <DukeDave> I'm beginning to see; this could  be one of those "I should have gone for a coffee and come back to  it moments" :)
19:26:51 <DukeDave> Thanks very much by the way!
19:26:57 <Cale> No problem :)
19:27:05 <SamB> hmm. mplayer is better than that flash interface. it can actually seek. without downloading first.
19:28:59 <ihope> Why are / and div different functions?
19:29:17 <|Steve|> > (5 / 3, 5 `div` 3)
19:29:23 <Cale>  / is proper division, div is integer division
19:29:23 <lambdabot>  (1.6666666666666667,1)
19:29:41 <ihope> You can't consider / on floats "proper". :-)
19:29:48 <ihope> @type ((/), div)
19:29:50 <lambdabot> forall a a1. (Fractional a, Integral a1) => (a -> a -> a, a1 -> a1 -> a1)
19:29:51 <Cale> (/) only works on numeric types which support fractional values
19:30:02 <Cale> So, Floats, yeah, but also Rationals
19:30:13 <ihope> Are there any properties one is expected to have that the other isn't?
19:30:13 <Cale> Or Complex values, and so on.
19:30:29 <Cale> div is like division with remainder
19:30:37 <Cale> (and mod gives the corresponding remainder)
19:30:46 <Cale> It only works with integral types
19:30:51 <|Steve|> > quotRem 5 3
19:30:52 <ihope> Hmm...
19:30:55 <lambdabot>  (1,2)
19:30:55 <Cale> Int, Integer, Word, etc.
19:31:09 <ihope> Are you supposed to be able to reconstruct the original given the results from div and mod?
19:31:11 <Cale> There's also quotRem, which does something a little different with the signs.
19:31:17 <Cale> quot and rem
19:31:22 <Cale> yes
19:31:25 <Cale> You can
19:31:34 <Cale> With either div and mod or quot and rem
19:31:39 * ihope nods
19:31:40 <|Steve|> div should work for any k[x]. =\
19:31:48 <ihope> |Steve|: for any what?
19:31:52 <|Steve|> Or k[x_1,x_2,...,x_n].
19:31:59 <ihope> But not with / and... something.
19:32:13 <SamB> where did he get the log10 data for Haskell users?
19:32:19 <Cale> @check \x y -> (x :: Integer `div` y) * y + (x `mod` y)
19:32:19 <lambdabot>  Parse error
19:32:22 <Cale> @check \x y -> (x :: Integer `div` y) * y + (x `mod` y) == x
19:32:23 <lambdabot>  Parse error
19:32:28 <Cale> @check \x y -> ((x :: Integer) `div` y) * y + (x `mod` y) == x
19:32:30 <lambdabot>  Exception: divide by zero
19:32:30 <|Steve|> I want div to work for any polynomial ring whose coefficients are in a field.
19:32:32 <Cale> heh
19:32:43 <Cale> @check \x y -> y /= 0 ==> ((x :: Integer) `div` y) * y + (x `mod` y) == x
19:32:45 <lambdabot>  OK, passed 500 tests.
19:32:52 <Cale> There we go :)
19:32:54 <ihope> What's ==>?
19:32:58 <Cale> Implies
19:32:59 <TSC> implies
19:33:08 <Cale> (for quickcheck)
19:33:20 <Cale> It just excludes tests where the precondition fails.
19:33:22 <ihope> Ah.
19:33:25 <TSC> :t (==>)
19:33:32 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
19:33:36 <ihope> Is quickcheck not lazy?
19:34:00 <Cale> Well, it actually evaluates the booleans, surely.
19:34:22 <ihope> @check \x y -> y == 0 || ((x :: Integer) `div` y) * y + (x `mod` y) == x
19:34:25 <lambdabot>  OK, passed 500 tests.
19:34:29 <TSC> Couldn't you replace ==> with || ?
19:34:38 <TSC> Too late
19:34:49 <ihope> i r teh leetzorz
19:35:48 <Korollary> But does it generate 500 x & y where y == 0?
19:35:58 <Korollary> I think that's the point of ==>
19:37:08 <Korollary> @check \x y -> y /= y ==> x == x
19:37:09 <lambdabot>  Add a type signature
19:37:13 <ihope> @check \x -> False => x != 1000000000
19:37:14 <lambdabot>  Parse error
19:37:19 <ihope> @check \x -> False ==> x != 1000000000
19:37:22 <lambdabot>   Not in scope: `!='
19:37:24 <ihope> @check \x -> False ==> x /= 1000000000
19:37:25 <lambdabot>  Add a type signature
19:37:32 <ihope> @check \x -> False ==> x /= "Hello, world!"
19:37:36 <lambdabot>  Arguments exhausted after 0 tests.
19:37:48 <ihope> @check \x -> True || x /= "Hello, world!"
19:37:51 <lambdabot>  OK, passed 500 tests.
19:37:59 <ihope> (Not infallible.)
19:38:48 <sorear> .
19:41:10 <wli> lhs2TeX butchers >=>
19:41:58 <sorear> It shouldn't.
19:42:03 <sorear> It's configurable!
19:42:17 <sorear> What do Kliesli compositions normally look like?
19:42:36 <sorear> %format >=> = I haven't read the lhs2TeX manual recently enough
19:43:25 <wli> The obvious doesn't work.
19:43:29 <SamB> Galois++ for making videos that are so nicely seekable
19:47:37 <wli> @type (>=>)
19:47:40 <lambdabot> Not in scope: `>=>'
19:47:43 <wli> @type (<=<)
19:47:45 <lambdabot> Not in scope: `<=<'
19:48:30 <wli> Anybody got 6.7 to check what the precise type is?
19:49:05 <reffie> does ghc assume tabs are 8 spaces?
19:50:02 <|Steve|> Yes.
19:50:15 <dolio> (>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:50:29 <SamB> @type (>->)
19:50:32 <lambdabot> Not in scope: `>->'
19:50:37 <SamB> @hoogle >=>
19:50:38 <lambdabot> No matches found
19:50:38 <dons> http://programming.reddit.com/info/2bkcd/details
19:50:40 <lambdabot> Title: Good Haskell Style (reddit.com)
19:50:41 <SamB> @hoogle (>=>)
19:50:42 <lambdabot> Did you mean: (>=>)
19:50:42 <lambdabot> Prelude.undefined :: a
19:50:42 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:50:46 <SamB> arg.
19:50:51 <SamB> I hate that first thing!
19:51:12 <dolio> It won't be in hoogle. It isn't in 6.6, let alone 6.4.
19:52:09 <SamB> oh yeah. the arrow one is >>> isn't it ;-)
19:54:39 <reffie> sorry for the noob question, but how do you make vi use spaces instead of tabs whne you press the tab key?
19:54:50 <Pseudonym> :set expandtab
19:54:59 <Pseudonym> You also might want to set tabstop and softtabstop.
19:55:00 <Pseudonym> I use:
19:55:07 <Pseudonym> -- vim: ts=4:sts=4:expandtab
19:55:10 <reffie> my vi doesn't have expandtab.
19:55:19 <Pseudonym> Ah.
19:55:19 <reffie> oh well, i guess i'l lkeep using tabs :)
19:55:26 <Pseudonym> So you're using an archaic editor.
19:55:27 <Pseudonym> :-)
19:55:50 <reffie> i used to use emacs for haskell, but i'm tired of having to move the huge config files
19:55:59 <Pseudonym> Seriously, if you're using vi and not vim, then you're seriously missing out.
19:56:08 <reffie> i don't like vim
19:56:21 <reffie> i don't like the fact tha ti have to install it on all my machines, while nvi is already there
19:56:42 <sm> reffie: check your emacs files into a darcs repo
19:56:59 <reffie> oh man darcs.
19:57:07 <reffie> we tried using it during ICFP
19:57:20 <dons> did you have a conflict?
19:57:22 <reffie> lost changes, hung for hours on commits
19:57:23 <reffie> yes
19:57:27 <dons> I saw one team had an issue
19:57:32 <reffie> we had issues too
19:57:37 <dons> maybe it was your team :)
19:57:38 <reffie> (we were not that team)
19:57:43 <dons> yeah, darcs has some issues. :(
19:57:54 <reffie> we switched to svn after a day or two
19:57:58 <dons> what we could put up with in 2003 maybe not so good now
19:58:08 <dons> oh, maybe hg is a better optoin, since you can keep using a dvcs
19:58:14 <dons> svn feels like a regression
19:58:25 <reffie> darcs has some really cool things though
19:58:31 <gravity> git-svn can help deal with the pain
19:58:46 <reffie> like the fact that you can select changes inside a single file
19:59:03 <dons> yeah, its weird that other systems don't provide that: its such a useful feature
19:59:18 <dons> as in, I use it all the time.
20:00:59 <SamB> we should get SPJ a bicycle-sized whiteboard or something
20:02:41 <LoganCapaldo> bicycle-sized whiteboard?
20:02:46 <chessguy> hmm, an interesting comment to walk in on
20:03:02 <SamB> chessguy: there wasn't much context
20:03:02 <LoganCapaldo> The size of a bicycle, or conviently sized for use on bicycles?
20:03:13 <SamB> LoganCapaldo: conveniently sized for carrying on a bicycle
20:04:28 <SamB> chessguy: see A Taste of Haskell part 1, nearly 40 minutes in...
20:04:42 <chessguy> @go a taste of haskell
20:04:43 <lambdabot> http://conferences.oreillynet.com/cs/os2007/view/e_sess/14016
20:04:43 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
20:04:50 <SamB> http://haskell.org/haskellwiki/Video_presentations
20:04:51 <lambdabot> Title: Video presentations - HaskellWiki
20:06:32 <dons>   Okay... I'm pretty darned impressed.
20:06:32 <dons>    I downloaded the packages and got my first Haskell/Glade app
20:06:32 <dons>    running in about the same amount of time as it took me to
20:06:32 <dons>    get my first VS.Net app up and running.
20:06:32 <dons>    Thanks for the pointer to GTK2hs.
20:06:35 <dons> cool!
20:06:41 <dcoutts> @yarr!
20:06:42 <lambdabot> Arr! Me ship be the biggest brig in the port!
20:07:08 <jbalint> dcoutts: can i report a gtk2hs doc bug to you? :)
20:07:33 <dcoutts> jbalint: sure, but even better would be a patch ;-)
20:07:39 <dons> dcoutts: :) good work on that scala thread
20:08:10 <dcoutts> dons: aye, quite pleasing he found it easy
20:08:13 <dons> dcoutts: you should put that quote on the gtk2hs page
20:08:21 <dons> in those cute blog `` quotes ''
20:08:25 <dcoutts> that's what I was thinking :-)
20:08:32 <dcoutts> user testimonials
20:08:51 <SamB> oh, good, he got a whiteboard at about 46:13
20:09:01 <SamB> :-)
20:09:03 <dcoutts> "I was so excited, I was physically sick, twice!" -- Anon
20:09:16 <jbalint> dcoutts: http://rafb.net/p/za4DKs24.html
20:09:17 <lambdabot> Title: Nopaste - No description
20:09:49 <dcoutts> jbalint: ta :-), btw have you used darcs yet?
20:09:58 <SamB> heh. that's a nice tagline. "no paste - no description"
20:10:01 <chessguy> heh. SPJ sure is a ... bubbly guy
20:10:09 <jbalint> dcoutts: yes, but i havent copied your repo
20:10:13 <SamB> chessguy: yeah!
20:10:20 <jbalint> dcoutts: sorry, i'd try to be better, but i just dont have this cloned
20:10:24 <SamB> why do you think I'm watching a tutorial ;-)
20:10:31 <dcoutts> jbalint: no probs, it's done!
20:10:34 <jbalint> dcoutts: thanks :D
20:10:59 <SamB> chessguy: I already watched his presentation on NDP to the \ondon hug, and he was so energetic I thought I'd like to watch another
20:11:29 <jbalint> whats the scala thread?
20:11:47 <dcoutts> jbalint: someone new to Haskell asking lots and lots of questions
20:11:55 <dcoutts> on the haskell-cafe mailing list
20:12:14 * jbalint greps
20:12:21 <chessguy> would be nice if we could actually see the screen he keeps wildly gesticulating at
20:12:34 <dons> chessguy: do you have the .pdf ?
20:12:52 <SamB> dons: there's stuff on the screen not from the .pdf ;-)
20:12:54 <dons> http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
20:12:57 <lambdabot> http://tinyurl.com/ysvquz
20:13:02 <dons> yeah, so we don't seee the xmonda stuff
20:13:03 <chessguy> ah, i didn't look at that
20:13:16 <SamB> it's now linked from both the wiki and the page on that .tv site
20:13:32 <dons> jbalint: this thread, btw, http://thread.gmane.org/gmane.comp.lang.haskell.cafe/26875
20:13:34 <lambdabot> Title: Gmane Loom
20:13:34 <SamB> (when I started watching the video it wasn't ;-)
20:13:40 <SamB> (I didn't fix it though)
20:13:41 <dons> "Well, before I start, you might well be asking "Gee David, you're a Scala kind of guy... I mean, you're the primary contributor to lift... why not use Scala?"  Well, I'm looking to build something that compiles down to native code and has a smaller download (and runtime) footprint than the JVM offers.  I've come to love functional programming and am taking the current side project as an opportunity to learn Haskell. "
20:13:57 <jbalint> dons: yeah, i found it. thanks
20:14:05 <dons> we just have to beat ... minimum footprint of 20M
20:14:09 <dons> so that's not too hard :)
20:14:18 <SamB> dons: I'm pretty sure we have that beat
20:14:20 <dons> i note CAL has the same problem on the shootout
20:14:29 <Tac-Tics> >filterM (const [True, False]) [1..3]
20:14:39 <Tac-Tics> > filterM (const [True, False]) [1..3]
20:14:48 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:14:52 <sjanssen> oh, CAL is on the shootout now?
20:15:13 <wli> What's CAL?
20:15:45 <sjanssen> poor guys, paying the overhead of high level lazy code and the JVM simultaneously
20:15:45 <SamB> hmm, for GHCi it seems to take 21 MB to run "yes"
20:16:18 <SamB> but I'm guessing that if you actually put it in a file and compiled and linked it, you'd need less ;-)
20:16:27 <SamB> I mean with GHCi you have to load up GHC
20:16:39 <reffie> yeah x11-extras should be merged with x11!
20:16:51 <dcoutts> yes!
20:17:00 <SamB> repeatedly!
20:17:02 * sjanssen thinks they should both die
20:17:08 <dcoutts> I'm holding off adding xmonad to gentoo until x11-extras goes away
20:17:08 <sjanssen> in a month or two
20:17:14 <SamB> sjanssen: what do you want to replace them with?
20:17:19 <dcoutts> sjanssen: ah yes, xcb
20:17:24 <sjanssen> SamB: xhsb, naturally
20:17:27 <dcoutts> hoe's that going ?
20:17:33 <reffie> isn't x11 already in ghc?
20:17:33 <dcoutts> hoe/how
20:17:36 <sjanssen> good
20:17:44 <dcoutts> sjanssen: yay :-)
20:17:46 <SamB> reffie: and out!
20:18:33 <sjanssen> the development of X11-extras might have slowed down enough that a merge is feasible
20:19:01 <sjanssen> I'm just worried about killing the library, but then needing just one more binding in the next minor version of xmonad
20:19:16 <reffie> are there xcb bindings for haskell?
20:19:26 <dcoutts> reffie: that's what sjanssen is working on
20:19:31 <reffie> oh, cool
20:19:45 <reffie> admittedly, i don't understand the point of xcb
20:19:58 <dcoutts> sjanssen: but releasing a new x11 package is no harder than releasing a new x11-extras package
20:20:05 <dcoutts> both just involve uploading a tarball to hackage
20:20:24 <sjanssen> dcoutts: true, but X11 is a pretty "core" library, right?
20:20:32 <dcoutts> sjanssen: bah, no not really
20:20:36 <dons> well, I think we're the only users :)
20:20:51 <dcoutts> adding new stuff is no problem, breaking things is slightly worse
20:20:51 <dons> to  a first approximation, anyway
20:20:55 <sjanssen> is it kosher to make API changing releases every month or two?
20:21:00 <gravity> reffie: It's making client-side bindings for X11 that aren't 20 years crufty
20:21:03 <sfultong> dcoutts: how's the status on 6.6 or 6.6.1 being unmasked?
20:21:05 <sjanssen> dons: true
20:21:11 <gravity> reffie: The XCB wiki explains some of the benefits
20:21:21 <sjanssen> X11 is the package that nobody uses that somehow became attached to GHC
20:21:23 <dcoutts> sfultong: it's currently in portage with ~arch keywords
20:21:44 <sfultong> but I won't break anything by emerging it, I assume
20:21:49 <dcoutts> sjanssen: if they're newish functions I think you can change them frequently, if they're old things other people use then be more careful
20:22:11 <dcoutts> sjanssen: in other words add x11-extras and don't worry about modifying those functions you've added
20:22:28 <dcoutts> sfultong: should be fine
20:23:00 <dcoutts> sfultong: we're pretty happy with it now, we're just waiting the necessary 30 days to get it marked stable
20:23:10 <sfultong> oh, I see
20:23:49 <sfultong> I'm a little cautious with unmasking stuff... especially for compilers I use every day
20:24:39 <puusorsa> unmasking is good clean fun for the whole family!
20:24:50 <Tac-Tics> I think I finally understand filterM (const [True, False]) [1..3]
20:25:04 <dcoutts> sfultong: aye, we try pretty hard not to break things for stable profile users
20:25:11 <puusorsa> goddamn i'd forgotten how slow(ish) installing gentoo from scratch was :(
20:25:14 <Tac-Tics> now instead of wondering how it works, I now wonder how anyone thought of it in the first place
20:25:31 <dmwit> Tac-Tics: Nice, good progress. =)
20:25:38 <sjanssen> Tac-Tics: I came up with it while daydreaming in statistics class
20:25:55 <sfultong> yeah, sticking with 6.4.2 has been a bit trying... especially when I learned I didn't have access to the Data.Foldable library
20:26:05 <Alleria> the List monad is really pretty nifty.
20:26:14 <sjanssen> Tac-Tics: "hmm, wtf does filterM do in the list monad?" "oh!"
20:26:14 <Tac-Tics> I still don't know what filterM does though X-D
20:26:34 <sjanssen> Tac-Tics: well, it's pretty straightforward in IO for example
20:26:41 <sfultong> puusorsa: yeah, I try not to break my gentoo system
20:26:50 <sm> > filterM (const [True, False]) [1..3]
20:26:52 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:27:13 <sjanssen> filterM :: (a -> IO Bool) -> [a] -> IO [a] -- just like filter, but your predicate might do some IO too
20:27:25 <puusorsa> me too, but a HD crashed
20:27:29 <dmwit> Alleria: In automata theory class, when we shifted from DFAs to NFAs, I was like, "Oh, just apply the list monad."
20:27:31 <sfultong> mmm, powerset
20:27:35 <sfultong> that's a good way to make it
20:27:51 <Alleria> dmwit: nice!
20:28:11 <Alleria> I'm still trying to understand List completely.
20:28:16 <Tac-Tics> heh
20:28:21 <dmwit> ...then I realized why it was called the nondeterminism monad. =P
20:28:24 <Alleria> and if I understand correctly, mapM (\x -> [x,f(x)]) [1..n] produces a list comprehension that's "n-wide", with each list feeding in having two elements?
20:28:34 <elliottt> Alleria: list's bind is an interesting thing
20:28:35 <wli> filterM (Just . even) [1..10]
20:28:38 <sfultong> puusorsa: oh dear... I gotta start backing up my stuff... my /home is on a separate drive, which is somewhat helpful
20:28:42 <puusorsa> this time with raid1
20:28:50 <Tac-Tics> Haskell is the only language where no one fully understands exactly what all the builtin types do!
20:28:55 <sfultong> nice, I gotta get raid one of these days
20:28:58 <elliottt> ?ty filterM (Just . even) [1..10]
20:29:00 <lambdabot> forall a. (Integral a) => Maybe [a]
20:29:13 <Tac-Tics> > filterM (Just . even) [1..10]
20:29:14 <lambdabot>  Just [2,4,6,8,10]
20:29:23 <elliottt> that's awesome :)
20:29:47 <dmwit> :t mapM
20:29:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:30:04 <wli> Not as nice as it could be; filterM (Just . even) [1,3..9]
20:30:17 <sm> reffie: I feel your pain :/.. still, for your personal .emacs stuff darcs will work great
20:30:27 <dmwit> Just . filter even
20:30:34 <|Steve|> > filterM (Just . even) [1,3..9]
20:30:35 <lambdabot>  Just []
20:30:37 <dmwit> > Just . filter even $ [1,3..9]
20:30:38 <lambdabot>  Just []
20:30:48 <sm> I finally have a standard emacs environment everywhere
20:30:50 <elliottt> oh darn, i was hoping it would be Nothing...
20:31:22 <sjanssen> I think 'filterM (return . p)' is the same as 'return . filter p' according to the Monad laws
20:31:39 <sjanssen> note that Just is return
20:31:53 <dmwit> ah, right
20:31:57 <sfultong> ah, yeah
20:32:42 <|Steve|> > filter (Just . even) [1..10]
20:32:42 <lambdabot>  Couldn't match expected type `Bool'
20:33:06 <|Steve|> @type Just . even
20:33:08 <lambdabot> forall a. (Integral a) => a -> Maybe Bool
20:33:26 <|Steve|> @type filterM
20:33:28 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:33:31 <|Steve|> Ah.
20:35:18 <dons> "I generally suspiciously relate to any [softu], written in exotic languages of programming. Usually either brake is obtained or memory gorges much, or still any unpleasant deficiency. But here all is written on the fashionable nowadays Of haskell, it is very rapid and memory it does not gorge."
20:35:39 <sfultong> @seen Cale
20:35:39 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 1m 39s ago.
20:35:40 <dons> russian xmonad blogger :)
20:35:44 <reffie> is there a way to avoid ugly lifts when using StateT
20:35:44 <Cale> hi
20:35:58 <sfultong> Cale: I read your thing on monads, and liked it
20:36:02 <Cale> cool :)
20:36:12 <elliottt> > filterM (Just . even) [ n | n <- [1..10], even n ]
20:36:13 <lambdabot>  Just [2,4,6,8,10]
20:36:13 <dons> sjanssen: `The libraries Of x11 and X11-extras also it was necessary to knobs to gather'
20:36:19 <elliottt> > filterM (Just . even) [ n | n <- [1..10], odd n ]
20:36:20 <elliottt> whoops
20:36:20 <lambdabot>  Just []
20:36:25 <dons> sjanssen: so we could make just the x11 knob required to gather
20:37:23 <sjanssen> I prefer:
20:37:26 <sjanssen> Also:
20:37:26 <sjanssen> xmonad > .*
20:37:26 <sjanssen> Discuss.
20:37:28 <sfultong> Cale: it's got just the right depth for me... although perhaps if I didn't know much of what you wrote already, it'd be harder to understand
20:38:13 <Cale> sfultong: Yeah, I'm not entirely sure about where it fits into the whole picture. It might be worth trying to add a little bit more introductory material into it.
20:38:24 <dons> I think i'd like it on a tshirt: here all is written on the fashionable nowadays Of haskell, it is very rapid and memory it does not gorge.
20:39:09 <sfultong> Cale: I'd like something written on how to use monads pervasively in a large program.... isn't there something on how to structure your code using monads, by wadler or someone?
20:39:36 <|Steve|> dons: I prefer my memory not to gorge.
20:39:45 <dons> :)
20:39:53 <Cale> sfultong: Well, Wadler wrote the original paper on how to write interpreters using monads, iirc.
20:40:40 <Cale> sfultong: Really what you want though isn't so much a tutorial on how to structure your code just with monads -- though that's part of it. Really, you want to know how to structure your code using domain specific languages.
20:40:49 <Cale> (or combinator libraries)
20:41:39 <Cale> The idea is that instead of solving your problem directly, producing a program that just solves that one problem, you imagine what sort of programming language would have just the right flavour of operations for solving problems like the one that you have.
20:41:47 <dons> anyone have any comments on the final version of the xmonad overview, for the haskell workshop, http://www.cse.unsw.edu.au/~dons/tmp/haskell51d-stewart.pdf
20:41:47 <Cale> So you become a mini-language-designer.
20:42:17 <sfultong> Cale: I liked that particular idea in your writing... it's very intuitive
20:42:48 <sfultong> but what about large programs, where there are several disparate problem domains?
20:43:05 <Cale> Well, it might take more than one :)
20:43:21 <Cale> and fitting them together is perhaps a really interesting problem
20:43:23 <dmwit> sfultong: Just now I've been interested in Web development.
20:43:33 <dmwit> sfultong: So I picked up WASH, which is a library for CGI stuff.
20:43:36 <Cale> There are lots of interesting tools for building monadic languages
20:43:42 <Cale> That's what monad transformers are all about
20:43:55 <dmwit> sfultong: It has no less than *four* domain-specific languages embedded in it (in the form of monads).
20:44:15 <Cale> But sometimes you really have an arrow, or occasionally you really have an applicative functor.
20:44:22 <sfultong> dmwit: sounds like heavy monad combinator stuff
20:44:25 <Cale> Or sometimes, you have something simpler, like just a monoid.
20:44:58 <sfultong> I probably just need to read more code
20:44:59 <gravity> dons: Nice post of Igloo's style guidelines
20:45:02 <Cale> (a monoid is just something where you have a way to "append" computations, and a "do nothing" computation, but there are no results being passed between them)
20:45:04 <sorear> Paterson has a monoid transformer lib, iirc
20:45:13 <sfultong> other people's code, that is... people who have a better sense of what they're doing
20:45:50 <Cale> sfultong: Yeah, there are quite a lot of techniques which are hard to put together into something entirely coherent, but are needed to really build up a full picture, I think.
20:46:13 <Cale> One thing I recommend looking at just for a good example is STM
20:46:30 <Cale> STM is a restricted monad for thread communication transactions
20:46:32 <sfultong> so what's the difference between a monoid appending and simple (.)ing functions together?
20:46:44 <Cale> sfultong: well, the latter is an example of the former
20:47:10 <Cale> Another example is just concatenating lists
20:47:18 <Cale> Pretty boring one :)
20:47:32 <Cale> Or just adding numbers, also kinda boring from the computational perspective
20:47:52 <dons> does anyone think the haskell community produces too much content and new material?
20:47:56 <Cale> But you could do something more colourful, like compositing images on top of one another
20:48:06 <Cale> dons: People outside it :)
20:48:10 <Cale> hehehe
20:48:10 <dons> where are the OCaml or Erlang bloggers? Why don't people write about new ideas in lisp?
20:48:30 <dolio> No, no, Haskell users don't produce anything. Only C++ people do that.
20:48:40 <dons> hehe
20:48:41 <Tac-Tics> heh
20:48:51 <Cale> I think it's just that Haskell programmers are getting to all the really neat ideas first at the moment.
20:48:58 <sfultong> it'd be nice if all this content could be found in pretty much one place...
20:49:02 <Cale> All the research people use it.
20:49:12 <dons> sfultong: haskell.org/haskellwiki/Blog_articles -- i put them all there
20:49:26 <Cale> dons: did you read my new monad article
20:49:27 <Cale> ?
20:49:31 <dons> Cale, haven't read it yet.
20:49:32 <dolio> So, I'm reading this Fillinski paper about "using call/cc instead of monads."
20:49:38 <dolio> And that's a pretty poor description.
20:49:39 <kpreid> dons: I dunno about OCaml or Erlang, but Lisp bloggers: http://planet.lisp.org/
20:49:40 <sfultong> dons: thanks, that should help
20:49:41 <dons> i thought the typography looked good though, Cale
20:49:42 <lambdabot> Title: Planet Lisp
20:49:47 <Cale> :)
20:50:07 <reffie> what's the difference between lift and liftIO?
20:50:14 <dons> kpreid: but they don't write about /intereesting/ things very often -- there's no sigfpe or oleg for lisp?
20:50:21 <dolio> Considering a large part of the paper seems to be showing how all monads can be expressed in terms of a universal monad (which is in turn expressible by call/cc + state).
20:51:13 <reffie> they both seem to work, if i have a StateT Blah IO.
20:51:18 <kpreid> dons: I suspect a bias in your notion of interesting :)
20:51:23 <kpreid> reffie: consider if you have two transformers
20:51:24 <dolio> Oleg is the Oleg for lisp.
20:51:27 <dolio> Or Scheme at least.
20:51:34 <kpreid> lift goes one layer, liftIO goes all the way to IO
20:51:40 <reffie> kpreid ah
20:51:45 <dolio> He's the Oleg for OCaml, too. :)
20:51:52 <reffie> kpreid having multiple transformers sounds painful
20:51:55 <Tac-Tics> what does OCalm have going for it?
20:52:00 <sorear> Uhm... I was under the impression State was expressible using callCC
20:52:14 <Tac-Tics> I looked at a tutorial for it the day I started learning Haskell.... but then I found a haskell tutorial and liked it better X-D
20:52:19 <dolio> sorear: Global mutible state?
20:53:16 <sorear> Tac-Tics: OCaml has a really really fast compiler and something much closer to full dependent types.  But it's all for nought since they don't have friendly people.  That's our killer feature.
20:53:31 <kpreid> reffie: I won't tell you about my ReaderT [String] (ErrorT NLX (ReaderT Universe IO)) a
20:53:44 <reffie> heh
20:53:46 <kpreid> , then.
20:53:52 <dons> sorear: dependent types? modules?
20:53:58 * allbery_b should go hit the SCS zarchive and see if Filinski's occasional comment about monads make any more sense now...
20:54:03 <lucca> sorear: I have definitely found this to be so
20:54:09 <sorear> kpreid: ErrorT commutes with ReaderT, you don't need all those layers
20:54:18 <Tac-Tics> also, I wonder if there's any way to make lambda bot friendly to basic stdin/stdout IO
20:54:31 <Tac-Tics> it'd be cool to be able to see what gets printed out if I do like....
20:54:33 <Tac-Tics> umm
20:54:58 <Tac-Tics> > putStrLn $ crazyRandomShit [1..3] Monad.awesome `cool` lazyEval
20:54:59 <lambdabot>   Not in scope: `lazyEval'
20:55:09 <monochrom> like System.Directory.removeFile "lambdabot.hs"? :)
20:55:13 <allbery_b> I think it's Hard to do that without exposing so much of IO as to be dangerous
20:55:23 <kpreid> sorear: whoops, I misquoted it, actually
20:55:27 <Tac-Tics> yeah
20:55:34 <sorear> @remember Tac-Tics > putStrLn $ crazyRandomShit [1..3] Monad.awesome `cool` lazyEval
20:55:34 <lambdabot> Done.
20:55:40 <kpreid> sorear: the ReaderT [String] is actually a newtype of it with extra behavior
20:55:46 <dons> sorear: where you thinking of module functors, wrt. the type system stuff?
20:55:57 <sorear> dons: yeah
20:56:16 <allbery_b> although I suppose you could arrange for lambdabot to execute stuff in a MinimalIO whch provided its own emulated stdout
20:56:27 <dons> i'm not sure that takes us much past type classes + associated types though (not even type families)
20:56:53 <allbery_b> (stdin would be tough given there's no way to interact with it to begin with)
20:57:14 <allbery_b> suppose you could use something like the System V crontab hack
20:57:45 <allbery_b>  > readLn %<% this is stdin
20:58:04 <sorear> dons: Well, sure, you can encode it.  But some things are more naturally expressed in terms of modules than ATs; I would not want to use my version of runST that uses functional dependencies in real code...
20:58:10 <allbery_b> (but once you go there it's easier to just do without)
20:59:04 <dons> sorear: oh sure. they're different thingamies
20:59:50 <sjanssen> sorear: what do the fundeps do?
21:00:26 <dons> you don't want to use fundeps anyway -- they're deprecated ;)
21:02:58 <DukeDave> Erm, sorry to ask a silly question but how to I use unlit?
21:03:02 <sorear> sjanssen: Works around the lack of local instances by passing an explicit closure parameter to the type class.
21:03:20 <sorear> DukeDave: You don't.  GHC will run it for you if you pass a .lhs file
21:03:44 <DukeDave> sorear: I just wanted to get a sloc count
21:03:51 <sorear> DukeDave: And if you just wanted to unlit a file stand-alone, unlit won't do what you want - it strips comments and replaces them with blank lines
21:04:10 <sorear> stefan@stefans:~$ /usr/local/lib/ghc-6.7.20070712/unlit
21:04:10 <sorear> usage: unlit [-q] [-n] [-c] [-#] [-P] [-h label] file1 file2
21:04:18 <sorear> file1 is input, file2 is output IIRC
21:04:23 <DukeDave> Ah
21:04:26 <sorear> don't forget to back up
21:07:24 <DukeDave> sorear: Omg it was the other way round you ruined  my whole project!!11!!11
21:07:27 * DukeDave smirks
21:07:33 <DukeDave> Cheers :)
21:07:58 <sorear> Sure. :)
21:10:38 <hpaste>  sorear pasted "for sjanssen - ST with fundeps instead of higher rank types" at http://hpaste.org/2030
21:11:16 <sorear> It has been known for many years that the dictionary desugaring requires rank-2 types to encode type classes.
21:11:37 <sorear> I wonder how well known it is that in the general MPTC/AT case, the reverse can be done?
21:13:36 <sjanssen> sorear: that is clever
21:13:57 <wli>  sorear: What's dictionary desuguring?
21:14:24 <sorear> Num a => a -> a ==> Num a -> a -> a
21:14:27 <wli> Actually I don't remember what higher-rank types are to begin with.
21:14:44 <Tac-Tics> wli: It sounds like a type of type
21:14:46 <sorear> class Num a where { negate :: a -> a } ===> data Num a = MkNum{ negate :: a -> a }
21:15:15 <wli> sorear: I'm not understanding a word of this.
21:16:03 <sjanssen> wli: class overloaded functions are turned into functions that take an extra dictionary parameter
21:17:08 <wli> I guess they have to in order to disambiguate the instances.
21:17:43 <wli> sjanssen: I have NFI where higher-rank types come in, what higher-rank types are, or otherwise why dictionary desugaring requires them.
21:18:07 <sjanssen> wli: consider class Monad m where return :: a -> m a
21:18:19 <wli> sjanssen: Okay.
21:18:22 <sjanssen> data MonadDict m = ...
21:18:48 <sjanssen> note that we only have the 'm' type variable there because it's the only thing mentioned in the class head
21:19:13 <sjanssen> data MonadDict m = MonadDict {return :: forall a. a -> m a }
21:20:12 <wli> Okay.
21:20:51 <Cale> sfultong: Have you yet comprehended how the State monad works?
21:21:09 <dons> Cale, do you know of other math blogs?
21:21:18 <dons> besides this guy, http://unapologetic.wordpress.com/2007/08/01/closed-categories/
21:21:20 <lambdabot> Title: Closed Categories  The Unapologetic Mathematician
21:21:31 <dons> maybe we can sneak more computation-ish math onto reddit :)
21:21:38 <sjanssen> sorear: do you think all higher rank types can be eliminated in favor of this class trick?
21:21:44 <Cale> dons: there's the one which keeps showing up on reddit...
21:22:03 <Cale> http://scienceblogs.com/goodmath/
21:22:03 <dons> goodmathbadmath?
21:22:03 <dons>  
21:22:04 <lambdabot> Title: Good Math, Bad Math
21:22:07 <Cale> yes
21:22:08 <Shimei2> Hehehe. SPJ's presentation is excellent. "Sadly, that would mean solving the Halting problem, which is tricky. And GHC makes no attempt to." :)
21:22:09 <sorear> sjanssen: Yes.  But it's not a Fellesteinian macro-expression, it requires type inference
21:22:56 <Cale> @quote SPJ
21:22:57 <lambdabot> SPJ says: I'm sitting there, under the cover, doing side effects like crazy. But I'm making it so beautiful for you so that you can think of pure folds, and I would do the dirty things for you.
21:23:01 <sorear> but ghc DOES have a partial halting-solver!  it only allows instances following syntactic rules to ensure the corresponding resolution system halts!
21:23:33 <sorear> Is that from ATOH too?
21:23:41 <Cale> yeah :)
21:23:52 * sorear needs to see that sometime.
21:24:26 <shachaf> sorear: What's wrong with your audio?
21:24:28 <brad_> hi i have been reading neil bartlett's blog post on arrows: http://neilbartlett.name/blog/2007/08/01/haskell-explaining-arrows-through-xml-transformationa/#comment-2416 and i have a question
21:24:31 <lambdabot> http://tinyurl.com/2hnqyy
21:24:53 <brad_> not sure if anyone has read it?
21:24:57 <sorear> shachaf: I got rid of it a few weeks ago, since it was just taking up space
21:25:07 <brad_> he defines: isA :: (a -> Bool) -> Filter a a
21:25:34 <shachaf> sorear: The hardware?
21:25:37 <sorear> yes
21:25:51 <brad_> but in his blog, the function just appear to return the value of a, but type seems to relate that it is a function that is returned. any ideas?
21:26:04 * shachaf admits he also very rarely uses audio.
21:26:24 <shachaf> But it's nice to have around when I do want it. :-)
21:26:39 <blackdog> wli: I implemented your map in my target program, but it actually seems slower
21:26:58 <brad_> i guess to refine my question, if the type returned is "Filter a a", should not the return value be a function?
21:26:59 <Cale> isA :: (b -> Bool) -> a b b
21:27:11 <Cale> isA :: (ArrowList a) => (b -> Bool) -> a b b
21:27:17 <hpaste>  blackdog pasted "performance results for Map & Prime based dictionaries" at http://hpaste.org/2031
21:27:40 <brad_> Cale: sorry i am not at the point yet where that makes much sense to me
21:27:49 <blackdog> map.uncached.bm:          54.77 real        42.34 user         0.84 sys
21:27:49 <blackdog> map.cached.bm:            13.39 real         9.67 user         0.46 sys
21:27:49 <blackdog> primes.uncached.bm:       46.51 real        37.09 user         0.51 sys
21:27:54 <blackdog> crap. sorry.
21:28:03 <blackdog> http://darcs.shimweasel.com/target/ has the code...
21:28:04 <lambdabot> Title: Index of /target
21:28:35 <Cale> What isA does is builds an arrow which takes input of type b, and if the predicate holds on that value, it returns a singleton result which is just the value
21:28:35 <wli> blackdog: Dependson how you use it.
21:28:38 <Cale> otherwise, the empty list
21:28:48 <Cale> So it kind of acts as a filter.
21:28:58 <blackdog> wli: am building a dictionary of words, looking up one string, then terminating
21:29:18 <blackdog> wli: what would be the preferred use case?
21:29:28 <Cale> Each arrow in the HXT system will take an input and produce a list of results
21:29:51 <wli> blackdog: Where comparisons on individual letters' counts are used.
21:29:55 <brad_> so if it returns a list of results, why not have the return type be [b]?
21:30:00 <Cale> when chaining arrows together, the following arrow processes each element of the preceding arrow's results and produces a list of results, and the results are all concatenated
21:30:21 <Cale> That it gives a list of results is sort of an internal feature.
21:30:49 <brad_> hmmm, okay. maybe i should take it on faith for now until i have finished the article
21:31:18 <Cale> So you sort of look at it as a component in a pipeline, where something of type b goes in, and if it satisfies the predicate, it comes out unscathed, if it doesn't, it silently gets dropped.
21:31:28 <blackdog> wli: Sorry, I don't understand. Am I misusing your code? I was surprised that it was that much slower - I was half convinced that I'd done something silly with the typeclasses that prevented proper optimisation
21:31:59 <brad_> okay, so if it is either returned or dropped, that seems to indicate [b] is returned, not Filter b b
21:32:01 <Cale> Other arrow pipeline components can produce many results from an input, or none at all.
21:32:12 <Cale> brad_: The [b] is inside the arrow type
21:32:21 <brad_> ah okay
21:32:29 <Cale> You can think of the a b c as being something like b -> [c]
21:32:35 <brad_> maybe that is my comprehension issue
21:32:37 <Cale> But really it's usually a bit more complicated.
21:32:49 <Cale> Like, there might be state and IO and so on too.
21:32:55 <brad_> ah
21:32:56 <Cale> But at the fundamental level
21:33:10 <Cale> b -> [c] is the way you think about most of the transformations in HXT.
21:33:12 <wli> blackdog: It's not so much a misuse as that different data structures will win depending on the search algorithm.
21:33:16 <SamB> prop_ is *SPJ's* convention is it?
21:33:29 <brad_> well thanks cale
21:33:38 <Cale> No problem
21:33:40 <brad_> i appreciate you taking the time to explain it to me
21:33:42 * SamB is skeptical
21:33:55 <Cale> brad_: You might be interested in listA
21:34:05 <Cale> listA :: a b c -> a b [c]
21:34:19 <brad_> okay i will look into that too
21:34:22 <Cale> It takes an arrow which may return many results or none at all
21:34:30 <Cale> and turns it into one which always returns one result
21:34:37 <Cale> which is a list of the results that would have been returned
21:34:58 <blackdog> wli: fair enough. The whole things seems totally dominated by the time taken to construct the dictionary, which is probably why the simpler version works better in my tests.
21:35:12 <brad_> i think i need to read more before we go further, i need to get the fundamentals of arrows down a bit better
21:35:24 <reffie> hm, i rewrote my very simple window manager in haskell
21:35:28 <reffie> 75 lines of haskell versus 89 lines of C
21:35:32 <Cale> brad_: Yeah, HXT uses some rather sophisticated arrow classes.
21:35:40 * reffie was hoping for something better :(
21:35:43 <dmwit> Hmm... I seem to have run into a situation where leaving off a type signature causes non-compilation, even with -fno-monomorphism-restriction.
21:35:50 <brad_> reffie: what does it do?
21:35:57 <Cale> brad_: That go well beyond what plain arrows have
21:35:58 <dmwit> I thought that wasn't supposed to ever happen. (?)
21:36:06 <reffie> brad_ just divides the screen into same-sized chunks for each window
21:36:11 <reffie> nothing impressive
21:36:13 <brad_> Cale: i am beginning to realize that
21:36:15 <Cale> brad_: I think at some point you just dive in and see if you can get things to match up :)
21:36:47 <brad_> Cale: indeed, if only to know to stay away (i rate limit myself on conceptual matters)
21:37:13 <brad_> reffie: you may be on to something! you should put it in hackage, i would use it if it was stable
21:37:17 <Cale> I personally didn't find it *so* bad -- the documentation is a bit confusing, and so is the tutorial, but if you just jump in at some point and start trying to put things together, it doesn't turn out so ad.
21:37:19 <Cale> bad*
21:37:22 <reffie> brad_ see xmonad
21:37:29 <Cale> You really ususally only need a few things.
21:37:37 <brad_> reffie: i am using xmonad now
21:37:46 <brad_> but i do not need really any of its features
21:37:54 <reffie> heh
21:37:59 <brad_> i just put one urxvt up and one browser
21:38:07 <brad_> each in its own "screen"
21:38:15 <brad_> i don't even do tiling
21:38:23 <brad_> i rarely even run firefox
21:38:24 <reffie> how are you able to get anything done with only one terminal? :)
21:38:32 <brad_> i do everything in gnu screen
21:38:43 <brad_> mocp, mutt, elinks, irssi, emacs
21:38:46 <brad_> and ghci of course
21:38:58 <shachaf> brad_: Have you looked at ratpoison?
21:39:02 <blackdog> screen is awesome and horrible
21:39:08 * SamB wonders why SPJ claims that people write a script for quickchecking -- I thought they just recopied the one that someone already wrote?
21:39:21 <brad_> i use ratpoison for a while but moved to dwm, then xmonad
21:39:32 <brad_> really i only use xmonad because it is written in haskell
21:39:40 <brad_> were i not a haskell guy, i would be using dwm
21:39:44 * blackdog still can't get used to C-a a to get to the beginning of the line...
21:39:46 * shachaf originally used xmonad only because it was written in Haskell.
21:39:57 <brad_> blackdog: agreed
21:40:00 * blackdog uses xmonad because dons is a dude.
21:40:12 <shachaf> Then I used it because it was much nicer than previous window managers I'd used. :-)
21:40:17 <brad_> and screen has one ANNOYING key sequence which locks the screen
21:40:29 <brad_> which i always seem to accidentally hit
21:40:32 <blackdog> yeah. still, can't live without it. *shrug*
21:40:38 <SamB> I'm seriously considering switching to something more reliabel than windowmaker
21:40:55 <shachaf> brad_: What's the key sequence?
21:40:56 <reffie> gnome is nice
21:41:00 <blackdog> can't get much more reliable than xmonad. there's barely any of it there to go wrong :)
21:41:00 <SamB> xmonad is obviously supposed to be one such thing ;-)
21:41:01 <shachaf> SamB: Xmonad? :-)
21:41:08 <brad_> shachaf: i think ctrl s?
21:41:14 <reffie> http://people.freebsd.org/~ssouhlal/stuff/Screenshot-47.png
21:41:15 <brad_> i am afraid to try
21:41:21 <shachaf> brad_: That's not screen, it's your terminal.
21:41:27 <shachaf> brad_: Ctrl-q unlocks it.
21:41:28 <reffie> brad_ you can "unlock" with ctrl-q
21:41:28 <SamB> I'll look at the manpage one of these days
21:41:45 <SamB> after another WindowMaker lockup
21:41:57 <brad_> yes i found out about ctrl-q after some frustration
21:42:08 <brad_> and here is an oblig ss: http://www.b7j0c.org/content/screenshot.png
21:42:14 <shachaf> brad_: Also, you can always reattach from another terminal. :-)
21:42:22 <brad_> http://www.b7j0c.org/content/screenshot2.png
21:42:25 <SamB> brad_: yes I used to do that a lot
21:42:26 <reffie> shachaf huge font
21:42:33 <brad_> reffie: do you work on freebsd?
21:42:41 <reffie> err brad_
21:42:42 <reffie> yeah
21:42:47 <brad_> thank you
21:42:55 <brad_> i use it at home, work and on my laptop
21:43:04 <reffie> i haven't done much recently :(
21:43:13 <brad_> i am a proud contributor to the freebsd foundation
21:43:17 <reffie> i work on linux for a living now :/
21:43:24 <reffie> cool :)
21:43:30 <shachaf> brad_: I should learn more about screen sometime.
21:43:30 <Tac-Tics> Linux is the way to go
21:43:38 <brad_> at work we are switching to linux too. i have freebsd cds to 2.1
21:43:42 <brad_> a huge stack!
21:43:43 * shachaf only uses small bits of it.
21:43:46 <Tac-Tics> It's not as good as windows, but it's not as shitty as windows
21:43:51 <SamB> Tac-Tics: o rly?
21:43:58 <Tac-Tics> ya rly!
21:44:01 <SamB> it's the way to go is it?
21:44:08 * SamB is skeptical
21:44:09 <Tac-Tics> yes
21:44:13 <Tac-Tics> Ubuntu is easy to install
21:44:19 <shachaf> brad_: May I see your screenrc?
21:44:20 <Tac-Tics> and my sound and video usually kinda work
21:44:26 * shachaf is always curious to see those.
21:44:31 <SamB> I am skeptical *because* I am a Linux user
21:44:39 <brad_> shachaf: yes, is there a way for me to hpaste it easily? i don't know how
21:44:56 <sorear> brad_: stty stop undef
21:45:08 <brad_> oh wait, i am on hpaste now
21:45:29 <hpaste>  b7j0c pasted "screenrc" at http://hpaste.org/2032
21:45:52 <brad_> also: http://www.b7j0c.org/content/screenbiff.html
21:45:52 <lambdabot> Title: biff-like functionality for gnu screen
21:46:02 <brad_> we want to be able to see new email in screen!!
21:46:13 <brad_> i wrote my own imaps poller with perl
21:47:30 <brad_> i also put up a page of some screen shortcuts:
21:47:33 <brad_> http://www.b7j0c.org/content/emacs-screen-ref.html
21:47:33 <lambdabot> Title: shortcut reference for emacs and screen
21:48:09 <brad_> okay i have taken this group offtopic for a while
21:48:17 <Tac-Tics> how many nonpure functions are there in standard haskell?
21:48:18 * shachaf is a vim user. :-)
21:48:25 <shachaf> Tac-Tics: None. :-)
21:48:25 <Tac-Tics> I just found the second of the two I know
21:48:28 * elliottt is too
21:48:47 <Tac-Tics> performUnsafeIO and trace of Debug.Trace
21:48:57 <wli> uses nvi except when terminals are screwed up, at which point he reverts back to (n)ex.
21:49:03 <sorear> Tac-Tics: it depends on your definition of 'pure' and 'standard'
21:49:15 <Tac-Tics> surely performUnsafeIO is standard
21:49:19 <sorear> Tac-Tics: H98 has neither.
21:49:29 <Tac-Tics> I use ghc
21:49:43 <Tac-Tics> in my own WorldThread, that is the standard
21:49:46 <shachaf> Tac-Tics: So "standard" is "what I have"?
21:49:55 <sorear> GHC isn't published. :)
21:50:10 <ivanm> that's what MS uses, and SPJ is employed by MS... ergo, ghc = standard! :p
21:50:18 <wli> No ideas on speeding up my Ramanujan number finder?
21:50:24 <SamB> ivanm: heh
21:50:31 <Tac-Tics> ivanm: egads! (switches to hugs)
21:50:32 <ivanm> that's what MS uses = ("standard" = "what I have")
21:51:12 <shachaf> Tac-Tics: By the way, the IO isn't unsafe, just the performing of it.
21:51:18 <shachaf> Tac-Tics: So it's unsafePerformIO.
21:51:40 <SamB> Tac-Tics: just because MS pays for it's development doesn't make it automatically bad ;-P
21:51:41 <shachaf> Tac-Tics: And in ghc, Debug.Trace is implemented on top of it anyway.
21:51:50 <goalieca> Question about random numbers...
21:52:12 <goalieca> I got a maze generator. right now it branches north then west then east then south.. all pure functions
21:52:17 <Tac-Tics> also, standard = what truth tells me
21:52:26 <ivanm> Tac-Tics: define "truth"
21:52:34 <Tac-Tics> Wikipedia
21:52:35 <shachaf> ivanm: It's in the standard.
21:52:36 <reffie> am i the only one who hates "lifting" to put stuff in monad transformers?
21:52:37 <Tac-Tics> "The language continues to evolve rapidly, with the Hugs and GHC implementation (see below) representing the current de facto standard. " - Wikipedia
21:52:40 <SamB> unsafePerformIO is, I think, standard
21:52:40 <ivanm> don't worry, we only have until the end of the universe for truth to be defined
21:52:54 <ivanm> Tac-Tics: ahhh..... you believe in "truthiness"?
21:52:55 <SamB> since the FFI addendum is apparantly a standardized extension
21:53:06 <shachaf> reffie: Well, there is the various auto-lifting.
21:53:09 <ivanm> de facto =/= true
21:53:11 <sorear> goalieca: How many times do you call mkStdGen?
21:53:20 <reffie> shachaf where?
21:53:29 <Tac-Tics> the only truth is knowing all truths, including this truth, is proof that your truth isn't truth at all
21:53:40 <sorear> goalieca: You should only call it once, since calling it twice with the same seed will give you the same random numbers.
21:53:56 <SamB> see, it's listed here:
21:53:58 <SamB> http://haskell.org/haskellwiki/Definition#Addenda_to_the_report
21:53:59 <lambdabot> Title: Language and library specification - HaskellWiki
21:54:13 <elliottt> is there any way to say (letter `sepBy` char ',' >> char ',') and have it work in parsec?
21:54:53 <SamB> @hoogle sepEndBy
21:54:53 <lambdabot> Text.ParserCombinators.Parsec.Combinator.sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
21:54:54 <lambdabot> Text.ParserCombinators.Parsec.Combinator.sepEndBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
21:55:04 <SamB> elliottt: try sepEndBy?
21:55:33 <wli> Is there a smarter way to do the Ramanujan quadruplet search, like some elliptic curve method?
21:55:58 <SamB> wli: does this look like #math or project euler to you ?
21:56:07 <shachaf> > let f :: StateT Int (Writer [Int]) Char; f = do { x <- get; tell [x+1]; tell [x+2]; put (x+3); return 'a' } in runWriter . (`runStateT`5) $ f
21:56:08 <lambdabot>  (('a',8),[6,7])
21:56:16 <wli> SamB: heh
21:56:22 <elliottt> :ty parse (letter `sepEndBy` char ',' >> char ',') "" "a,b,c,"
21:56:31 <shachaf> @instances MonadWriter
21:56:33 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
21:56:40 <elliottt> ?ty parse (letter `sepEndBy` char ',' >> char ',') "" "a,b,c,"
21:56:42 <lambdabot> Not in scope: `parse'
21:56:42 <lambdabot>  
21:56:42 <lambdabot> <interactive>:1:7: Not in scope: `letter'
21:56:47 <ivanm> SamB: but surely, people on this channel know _everything_!
21:57:10 <shachaf> instance (MonadWriter w m) => MonadWriter w (StateT s m) where ... -- Or so, I think.
21:57:12 <SamB> wli: of course, I'm not sure they have a problem with those on project euler, and to be allowed to ask about it you'd need to have already got the answer ;-)
21:57:12 <elliottt> SamB: i got an error running locally
21:57:12 <goalieca> sorear: actually right now i'm picking a random seed using randomR.. what i want to do is add some random direction to the branching
21:57:17 <shachaf> reffie: Is that what you meant?
21:57:22 <SamB> elliottt: what'd you get?
21:57:33 <elliottt> unexpected ','
21:57:50 <reffie> shachaf well, my issue is mostly with IO
21:57:55 <SamB> hmm.
21:58:06 <shachaf> @instances MonadIO
21:58:07 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
21:58:32 <shachaf> Also lifted automatically for those, I think.
21:58:37 <SamB> *Misc> parseTest (letter `sepEndBy` char ',') "a,b,c,"
21:58:37 <SamB> "abc"
21:58:41 <reffie> not for TtateT
21:58:44 <reffie> StateT
21:59:20 <elliottt> SamB: sorry, i got the error wrong -_-
21:59:26 <SamB> ah. was it:
21:59:28 <elliottt> expecting ',' or letter
21:59:31 <shachaf> reffie: Oh, you do have to use liftIO.
21:59:33 <SamB> ah.
21:59:37 <reffie> shachaf yeah
21:59:47 <shachaf> reffie: Some people say "io = liftIO" to make it shorter. :-)
21:59:54 <SamB> elliottt: try getting rid of the >> char ','
22:00:00 <goalieca> sorear: I have a data Dir =  North | South | East | West.. what i want is something like an infinite list i can draw from that is randomly arranged..
22:00:00 <elliottt> well
22:00:26 <elliottt> SamB: so, i'm writing an http parser, and want to use sepBy or sepEndBy to parse the headers
22:00:46 <SamB> elliottt: what do you need to write a new one of those for?
22:00:47 <elliottt> so, (headerParser `sepEndBy` string "\r\n" >> string "\r\n"
22:00:50 <elliottt> oh there is one?
22:01:10 <shachaf> Why are all the IO functions defined on IO and not on (MonadIO m) =>?
22:01:12 <SamB> http://www.haskell.org/http/
22:01:13 <lambdabot> Title: Haskell HTTP package
22:01:13 <sorear> goalieca: hmm.  you could do something like { map ([North,South,East,West!!) (randomRs (0,3) gen) }
22:01:25 <elliottt> oh crimony.  thanks SamB :)
22:01:34 <SamB> elliottt: no problem ;-)
22:02:12 <SamB> elliottt: I'm sure you'll be able to use that code somehow, even if it happens not to do what you want as-is...
22:02:21 <SamB> (though it's got a good chance of being able to do that ;-)
22:02:48 <elliottt> SamB: is this the package that just does http interaction?
22:02:56 <elliottt> (with curl and the like)
22:03:04 <sfultong> woah, vim just crashed on me
22:03:12 <elliottt> that's impressive :)
22:03:13 <SamB> elliottt: it didn't use curl last I saw
22:03:17 <shachaf> sfultong: Impossible!
22:03:21 <sfultong> hehe
22:03:39 <shachaf> sfultong: What did you do?
22:03:41 <elliottt> SamB: i was looking to write something to just parse http requests, as i was attempting to make some sort of general web framework
22:03:47 <SamB> shachaf: GHC is always whining about the impossible. whats yer point?
22:04:29 <SamB> http://hackage.haskell.org/packages/archive/HTTP/3000.0.0/doc/html/Network-HTTP.html
22:04:33 <lambdabot> http://tinyurl.com/26nxhm
22:04:35 <sfultong> it froze for a second when trying to hi-light a matching bracket in a file.... and then I did ctrl-c, and tried moving around in the file... then it segfaulted
22:04:54 <SamB> elliottt: there's some documentation ;-)
22:05:15 <reffie> elliottt maybe you can modify http://people.freebsd.org/~ssouhlal/stuff/rephttpd-0.4.hs
22:05:19 <elliottt> SamB: i spoke too soon.  was just reading through.  looks like it'll work for me, thanks again :)
22:05:20 <reffie> it's a simple http server
22:06:33 <elliottt> reffie: thanks, i'll look through it :)
22:09:04 <goalieca> sorear: clever line of code. But what i feared all along is that it will return IO.
22:09:24 <goalieca> and that will chain all the way to the top
22:09:24 <goalieca> :(
22:09:35 * SamB wonders if you can make pretty UML-like pictures out of types
22:09:48 <SamB> (or are UML pictures ugly?)
22:09:55 <sorear> goalieca: you can write non-IO code that uses values from IO
22:10:03 <sorear> :t liftM
22:10:06 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:10:25 <sorear> liftM (\value -> do something pure with value) (get the value)
22:10:37 <elliottt> SamB: what about diagrams? :)
22:10:51 <sorear> eqv. do { value <- get the value; return (do something pure with value) }
22:10:56 <SamB> sorear: tell him how to use RNGs without all his code being in IO
22:11:15 <shachaf> You can also use fmap and <$>, if they're simpler.
22:11:47 <sfultong> goalieca: the idea of much of haskell is writing as much pure code as possible, and then popping it into IO at the last minute... at least, that's my understanding
22:13:11 <goalieca> sfultong: ya but it can be a pain in the ass for imperative algorithms
22:13:49 <shachaf> goalieca: An "imperative algorithm" doesn't mean you need to be in IO.
22:14:16 <sfultong> goalieca: the nice thing about getStdGen is that you can get a source of "random" numbers once at the top in IO, and then pass it down to whatever pure function you want
22:14:40 <sfultong> (getStdGen gets a random generator)
22:15:01 * SamB wonders if you aren't supposed to split it
22:15:28 <sfultong> yeah... or pass it around... or bind it in a State monad (which I have not yet done)
22:15:37 <sorear> sfultong: I don't think getStdGen does what you think it does
22:15:55 <sorear> Prelude Random> getStdGen
22:15:55 <sorear> 2002256634 7172
22:15:55 <sorear> Prelude Random> getStdGen
22:15:55 <sorear> 2002256634 7172
22:16:11 <sorear> compare,
22:16:12 <sorear> Prelude Random> newStdGen
22:16:12 <sorear> 2127708049 291843023
22:16:12 <sorear> Prelude Random> newStdGen
22:16:12 <sorear> 2127748063 93136137
22:16:47 <SamB> sorear: ah, that's a good one then
22:17:01 <sfultong> wait...
22:18:07 <sfultong> but each time I run my program, I get a different set of numbers from getStdGen...
22:18:38 <SamB> sfultong: yeah. but if you do it twice in one program I bet you don't?
22:18:57 <SamB> er. one run of the program, rather
22:19:09 <sfultong> yes, I only get it once
22:19:51 <sfultong> and then pass it down to the one function that needs it... if I needed to pass it to two different functions, I'd probably split it
22:20:52 <sfultong> this probably isn't helping poor goalieca at all
22:21:28 <goalieca> well my idea is to generate a list of random directions, sufficiently long, in main and then cycle through the list each branch
22:21:49 <dons> goalieca: one approach would be to implement a Random instance for your type, then use the System.Random functions
22:22:21 <sfultong> huh, there's a random instance?
22:24:18 <dons> just declare one. let's see..
22:26:23 <sfultong> hmm, it asks for a range... wouldn't that type "a" have to be Ord?
22:26:57 <hpaste>  glguy pasted "argf a la ruby" at http://hpaste.org/2033
22:27:36 <dons> *Main> take 10 $ randomRs (minBound,maxBound) (mkStdGen 42) :: [Direction]
22:27:36 <dons> [W,W,S,E,N,W,E,W,E,W]
22:28:19 <hpaste>  dons pasted "Random Direction" at http://hpaste.org/2034
22:28:32 <sfultong> ah, instances of Bounded
22:28:50 <glguy> Such a function "argf" or $< seems like it could be useful for script writing
22:28:56 <dons> goalieca: you wanted a randomised list of Direction? see the above link
22:29:29 <dons> goalieca: you can just use randomRs to get an infinite list of such pseudo-random values
22:29:36 <shachaf> glguy: Ruby's ARGF also works with "-" as a file, I think.
22:29:54 <glguy> shachaf: mixed in with other?
22:29:57 <glguy> filenames/
22:29:57 <glguy> ?
22:30:02 <shachaf> glguy: I think so.
22:30:13 <glguy> cool, I'll have to incorporate that
22:30:25 <glguy> does it also support --
22:30:34 <glguy> so that you can actually mean "the file -"
22:30:46 <shachaf> glguy: Just call it "fancyGetContents" or something like that, it's just an improved version of getContents. :-)
22:30:54 <shachaf> glguy: I don't know.
22:30:59 <glguy> I'll have to investigate
22:31:10 <glguy> I saw this function in some ruby code in Beautiful Code
22:31:16 <hpaste>  blackdog pasted "nicer way to structure this?" at http://hpaste.org/2035
22:31:51 <blackdog> shachaf: heh - i just wrote a function called "friendlyInteract" :)
22:32:06 <glguy> shachaf: ARGF in ruby doesn't understand "-"
22:32:08 <glguy> to mean stdin
22:32:16 <glguy> or,
22:32:21 <glguy> I am misusing it
22:32:24 <shachaf> glguy: It seemed to to me, hmm.
22:32:29 <shachaf> glguy: How are you using it?
22:32:42 <glguy> emertens@lintel ~ $ echo -n wow > -
22:32:46 <glguy> emertens@lintel ~ $ runghc lineby.hs  -
22:32:46 <glguy> "wow"
22:32:53 <glguy> LOL
22:32:55 <glguy> that's not ruby, is it
22:32:59 <glguy> i was misusing it
22:33:17 <sfultong> haha
22:33:18 <shachaf> glguy: You were running your own Haskell code and it didn't work like Ruby?
22:33:20 <glguy> ok, it works as expected
22:33:26 <shachaf> glguy: Including --?
22:33:30 <glguy> shachaf: yeah, I saw the "r" at the beginning of the command line
22:33:43 <glguy> shachaf: it doesn't seem to understand --
22:33:48 <hpaste>  sorear annotated "nicer way to structure this?" with "better?" at http://hpaste.org/2035#a1
22:34:22 <shachaf> blackdog: Not really relevant, put putStrLn . show == print.
22:34:24 <magnus__> silly question but, how do I reuse modules that I have written in multiple haskell programs without duplicating the file?
22:35:36 <sjanssen> magnus__: you might make a small library and install it with Cabal
22:35:44 <hpaste>  glguy annotated "argf a la ruby" with "handle -" at http://hpaste.org/2033#a1
22:35:55 <magnus__> ah, I hope there is some quick totorial I can copy-paste
22:35:55 <sjanssen> magnus__: ghc also supports some -I flags
22:36:16 <magnus__> good to know
22:36:21 <blackdog> sorear: see, that's sort of the problem - if i do that, i get a compile error
22:36:26 <shachaf> glguy: I still think it should have getContents in its name.
22:36:38 <blackdog> because it's unifying the two readDicts, which have different types
22:36:54 <glguy> shachaf: I probably would rename them if I found a use
22:36:58 <sorear> blackdog: you'll notice I still have two uses of readDicts
22:37:00 <shachaf> glguy: But it could be handy.
22:37:06 <shachaf> glguy: Why is it by line, though?
22:37:08 <glguy> shachaf: I'm mostly just throwing it out there because I thought it was clever
22:37:14 <sorear> oh.
22:37:16 <blackdog> sorear: yep. but it still doesn't compile...
22:37:16 <goalieca> IO monad errors are confusing to the n00b
22:37:19 <goalieca> :(
22:37:22 <glguy> shachaf: there is one of each, ruby had ARGF.each_line
22:37:24 <sorear> @paste
22:37:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:37:26 <glguy> and also ARGF.read
22:37:40 <glguy> which have different behavior when the input isn't terminated by a newline
22:37:46 <shachaf> glguy: But you can just lines ARGF.read in Haskell, right?
22:37:49 <shachaf> glguy: Oh, hmm.
22:38:04 <shachaf> glguy: I'd think the .read version would be better, with laziness.
22:38:13 <glguy> they are both lazy
22:38:58 <shachaf> glguy: OK, what's the difference between each_line and read?
22:39:17 <glguy> say you have 3 files, none is terminated with a \n
22:39:25 <glguy> echo -n example > file.txt
22:39:41 <blackdog> sorear: what i think is happening is that wildcardTargetSolver is being instantiated twice with different type variables, so it has to be repeated
22:39:44 <glguy> if you do: ARGF.each_line { | line | puts line }
22:39:46 <shachaf> glguy: OK, I see. The last "line" in each would still be its own string?
22:39:50 <blackdog> if there's a way around that i'd love to find out.
22:39:52 <glguy> you would see three lines
22:39:56 <glguy> yeah
22:39:58 <glguy> that
22:40:05 <shachaf> glguy: OK, I guess that makes sense.
22:40:12 <hpaste>  goalieca pasted "monad randomness" at http://hpaste.org/2036
22:40:22 <goalieca> heh.. ^^
22:40:38 <glguy> shachaf: do you know if there is a non-ugly version of $1
22:40:44 <glguy> regarding matched portions of regexes
22:40:54 <shachaf> glguy: You mean, in Ruby?
22:40:57 <glguy> yeah
22:41:13 <shachaf> glguy: String#match returns a Match object, I think.
22:41:18 <shachaf> glguy: Something like that.
22:41:22 <glguy> ah, ok
22:41:24 * shachaf hasn't really used Ruby in a while.
22:41:40 <glguy> I'm just pesting you with these questions because I see you in #ruby-lang (today)
22:41:56 <dons> goalieca: randomRs (0,3) (mkStdGen 42) isn't in IO
22:41:57 <shachaf> glguy: It's fine.
22:42:07 <shachaf> glguy: Just remember that I'm also a -. :-)
22:42:15 <glguy> heh
22:42:28 <dons> goalieca: and its nicer to just generate random directoins, rather than numbers you map to random directions :)  http://hpaste.org/2034
22:43:01 <shachaf> "str".match(/re/)[0] -- whole match, [1] -- $1, etc. (I think)
22:43:24 <goalieca> dons: thanks. heh. I thought it was IO ().
22:43:41 <reffie> what the hell, there's no binding for XGetGeometry() in X11 or X11-extras?!
22:45:33 <glguy> zomg
22:46:39 * glguy wishes that stdin was a dynamic variable
22:46:39 <wli> Data.Unique kind of sucks.
22:46:52 <glguy> dynamically scoped
22:46:56 <shachaf> glguy: $stdin?
22:46:59 <glguy> (not sure if those are different things)
22:47:10 <wli> A monad transformer that tracks some counter variable would be convenient.
22:47:16 <glguy> in the case of Haskell,   ?stdin
22:47:44 <glguy> something to make it easy to change the source of stdin,
22:47:54 <wli> CounterT
22:47:56 <sjanssen> glguy: man dup2
22:47:58 <glguy> withStdinString "fakeinput" $ getContents
22:48:22 <magnus__> where in the package tree do algorithms such as union-find belong? I have a monad that implements union-find so it could be under Control.Monad but... it may as well be implemented without monads
22:48:55 <dons> hmm, over what types does it operate?
22:49:28 <magnus__> dons: anything that is Ord
22:50:05 <glguy> seems like you'd want to create a typeclass with the functions needed to write the algorithm, and then be able to define instances of that typeclass for different monads like IO or ST
22:50:10 <shachaf> glguy: Oh, you meant in Haskell.
22:50:15 <glguy> shachaf: yes
22:50:29 <shachaf> glguy: Sorry, I thought you were referring to STDIN in Ruby.
22:50:35 <sjanssen> magnus__: does your implementation inherently require mutation?
22:50:38 <glguy> find :: UnionFindMonad m => a -> m Bool
22:50:49 <glguy> or whatever
22:51:10 <glguy> shachaf: ruby probably does it, Common Lisp definitely does
22:51:20 <glguy> it would make it easier to test IO functions
22:51:37 <glguy> also, to be able to have a function :: String -> Handle
22:51:40 <magnus__> sjanssen: I'm using a Map to simulate mutation
22:51:47 <magnus__> to simulate references
22:51:47 <glguy> where the resulting handle holds the string passed in
22:51:57 <sorear> magnus__: why don't you just use ST?
22:52:13 <sjanssen> magnus__: so really, a Monad isn't required at all
22:52:30 <sjanssen> magnus__: at that point, I'd just toss it in Data.DisjointSet
22:52:47 * sorear is implementing union-find too.  with IORefs!
22:53:02 <glguy> sorear: implement with so that you could use it with ST or IO depending
22:53:04 <glguy> ?
22:53:14 <wli> The only reason I'd want a monad for things is so that I can use the thing as a monad transformer atop other state monad transformers.
22:53:16 <sjanssen> yeah, that's the only way to get the best complexity
22:53:59 <glguy> so that the functions require an instance of MonadRef instead of IO
22:54:13 <magnus__> sorear: maybe I should. I don't know much about it
22:54:15 <dibblego> SPJ says f x is "f applied to x" but I think he means "f applied with x" or "x applied to f"?
22:54:36 <glguy> also... it seems like you might want more than one structure at a time
22:54:39 <shachaf> dibblego: Why? You apply a function to its argument, no?
22:54:41 <magnus__> It is convenient to have a monad interface atop of union find so that you don't have to thread the state around
22:54:43 <wli> dibblego: Nope. He means just what he says.
22:54:48 <dibblego> gah, nothing
22:54:56 <dibblego> thanks :)
22:54:58 <glguy> magnus__: that's what the State monad is for
22:55:18 <glguy> magnus__: you write your algorithm so that you would normally pass it around, and then you wrap it up in State
22:55:24 <glguy> rather than merging those two concerns
22:55:36 <magnus__> glguy: I think I will rewrite it as you say
22:55:48 <magnus__> and as sjanssen did
22:55:59 <magnus__> did -> said
22:56:52 <wli> Well, there's the way I did Bernoulli numbers, which was to provide an exposed stateful interface while also mocking up a stateless/monadless interface.
22:56:58 <glguy> if you collapse the path after a find, your ammortized time complexity falls dramatically
22:57:17 <magnus__> glguy: yes, I'm doing that
22:58:19 <sorear> magnus__: You also need to track the number of paths leading to each root, and during a union make the smaller set child of the larger
22:58:22 <dibblego> ?type (.)
22:58:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:58:40 <brad_> on Arrows: so let me see if i know this much: >>> is like a unix pipe
22:59:28 <magnus__> sorear: may do that
22:59:48 <sorear> brad_: exactly.
23:01:12 <brad_> ...and typing keeps me from making a ">>>" 'pipe' that is inherently broken...(?)
23:02:34 <brad_> but the value of Arrows so far escapes me, on a basic level it just seems like sugar for normal-style things we might do with functions. obvously i am wrong, just not sure what the greater utility is
23:02:35 <sorear> sortof.  it stops you from saying gzip | wc -l
23:02:55 <shachaf> brad_: That's only if you use the (->) arrow.
23:03:02 <sorear> brad_: the point is that not all arrows are expressable efficiently as functions
23:03:15 <wli> sorear: What other sorts of arrows are there?
23:03:18 <brad_> ah, i see.
23:03:20 <wli> sorear: Map.Map?
23:03:22 <shachaf> @instances Arrow
23:03:24 <lambdabot> (->), Kleisli m
23:03:30 <shachaf> @src Kleisli
23:03:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:03:52 <wli> shachaf: I obviously don't understand the rationales from the mere instance listings.
23:04:07 <brad_> lambdabot has some sass going on
23:04:14 <sorear> wli: stream processors, circuit descriptions, etc
23:04:27 <shachaf> wli: Every monad is an arrow, as I understand it.
23:04:30 <shachaf> With Kleisli.
23:04:41 <glguy> (->), Kleisli m are really unenglightening examples
23:04:42 <sorear> shachaf: But not all arrows are monads!
23:04:50 <glguy> arrows are more general than monads
23:04:58 <shachaf> sorear: Of course, otherwise there wouldn't be much point.
23:05:12 <brad_> well thanks for the explanations sorear and others, take care!
23:06:06 <wli> shachaf: That's not helping either.
23:06:24 <wli> Argh, I'm getting wrong answers.
23:06:37 * shachaf does not know enough about arrows to help. :-(
23:07:27 <wli> The first 5 should be 1729, 4104, 13832, 20683, 32832, 39312
23:07:43 <shachaf> wli: First 5 what?
23:07:53 <wli> I'm getting 1729, 4104, 20683, 39312, 40033
23:08:12 <wli> shachaf: Natural numbers expressible as sums of two cubes in two or more ways.
23:08:47 <shachaf> wli: Well, at least 1729 is right, of course. :-)
23:10:17 <wli> shachaf: Sorry, the answers are right. I'm just using a different definition (i^3+j^3=k^3+m^3 where foldr1 gcd [i,j,k,m] == 1 ; the last condition isn't being used by Sloan's sequences)
23:11:05 <shachaf> Hmm, I hadn't come across http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html before.
23:11:07 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
23:11:48 <dons> ?users
23:11:48 <lambdabot> Maximum users seen in #haskell: 382, currently: 321 (84.0%), active: 14 (4.4%)
23:12:04 <wli> shachaf: More interestingly, there are "taxicab numbers;" the n-th taxicab number is the smallest number expressible as a sum of two cubes in n different ways.
23:12:59 <shachaf> wli: What's the 3rd taxicab number?
23:13:41 <wli> 87539319 = 167^3 + 436^3 = 228^3 + 423^3 = 255^3 + 414^3
23:14:04 <Tac-Tics> http://hpaste.org/2037
23:14:11 * shachaf likes the name. :-)
23:14:11 <Tac-Tics> can anyone help me figure out this type error?
23:14:35 <shachaf> Tac-Tics: What's causing it?
23:14:41 <Tac-Tics> I have a state monad with a BFState state and a [Int] return type
23:14:54 <Tac-Tics> I'm trying to write a BF interpreter
23:14:54 <vikrant> quit
23:14:57 <vikrant> 
23:14:59 <shachaf> Tac-Tics: Maybe your last statement is a put?
23:15:09 <shachaf> Tac-Tics: In a do block?
23:15:12 <wli> Ta(4) = 6963472309248 = 2421^3 + 19083^3 = 5436^3 + 18948^3 + 10200^3 + 18072^3 = 13322^3 + 16630^3
23:15:24 <goalieca> stupid question: i have a where statement.. but i want to include several lines of a = b. it wont parse
23:15:29 <wli> http://mathworld.wolfram.com/TaxicabNumber.html
23:15:30 <lambdabot> Title: Taxicab Number -- from Wolfram MathWorld
23:15:32 <shachaf> goalieca: Align them.
23:15:50 <Tac-Tics> http://hpaste.org/2038
23:16:07 <Tac-Tics> shachaf: yeah, it's in a do block
23:16:10 <shachaf> Tac-Tics: (Also remember that you can annotate existing pastes.)
23:16:19 <Tac-Tics> what does annotate mean? X-D
23:16:31 <Tac-Tics> if you can edit them, they should just call it edit
23:16:32 <Tac-Tics> =-P
23:16:35 <Tac-Tics> but thanks
23:16:47 <Tac-Tics> I'll try to do that next time
23:16:54 <shachaf> Tac-Tics: Annotate is "attach another paste to the same title".
23:16:58 <Tac-Tics> ah
23:17:00 <shachaf> Tac-Tics: Not quite editing.
23:17:09 <Tac-Tics> and yeah, they are in do blocks when they probably shouldn't be
23:17:23 <goalieca> shachaf.. ty. i should have known being used to python
23:17:29 <sorear> why write a BF interpreter?  optimizing compilers are so much more fun!
23:17:44 <Tac-Tics> write first, optimize later
23:17:52 <shachaf> Tac-Tics: Oh, I see. Up,Down,Out,In are all put ..., so they have type m ().
23:18:10 <Tac-Tics> yeah
23:18:15 <shachaf> Tac-Tics: And Halt is return $ ...; type m (...).
23:18:20 <Tac-Tics> I thought I was being clever moving execBF at the end
23:18:34 <Tac-Tics> I get it now I think
23:18:43 <dblhelix> morning #haskell
23:18:50 <shachaf> Tac-Tics: Note! return (x) doesn't exit you out of the function.
23:18:57 <shachaf> Tac-Tics: It's not like return in, say, C.
23:19:01 <wli> shachaf: I don't actually need Ramanujan numbers per se, just quadruplets i^3+j^3=k^3+m^3 where foldr1 gcd [i,j,k,m] == 1 ; apart from that I'm not as concerned about Ramanujan anything per se (basically, rational solutions to x^3 + y^3 = n*z^3).
23:19:04 <Tac-Tics> I know
23:19:19 <Tac-Tics> it wraps the pure output up in the state monad
23:19:23 <shachaf> return x >> ... is pointless.
23:19:38 <shachaf> (Which is do { return x; ... }).
23:19:49 <Tac-Tics> that makes sense
23:20:01 <Tac-Tics> I was going off intuition
23:20:03 <Tac-Tics> I had it working
23:20:12 <Tac-Tics> then I was like "Haskell is more effiecient than this"
23:20:24 <Tac-Tics> because I was duplicating the IP increment and the tail recursion
23:20:30 <Tac-Tics> so I moved them to the bottom
23:20:32 <Tac-Tics> ^^;
23:20:38 <shachaf> Tac-Tics: You should look into Writer.
23:20:53 <goalieca> yay. thanks everyone! my maze generator fricken works. everyone else's is 350+ lines and mines only 60 (yay for haskell)
23:20:57 <shachaf> Tac-Tics: You're using a list append on every Out, which is expensive.
23:21:09 <wli> goalieca: What sort of maze generator?
23:21:13 <Tac-Tics> I'll look into that shachaf
23:21:33 * wli stares at http://holomorphy.com/~wli/Easy.lhs some more.
23:21:41 <shachaf> What Monoid is recommended for use with Writer?
23:21:46 <wli> Also http://holomorphy.com/~wli/Easy.lhs.txt
23:21:49 <shachaf> @instances Monoid
23:21:50 <wli> shachaf: [ ]
23:21:56 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
23:22:08 <shachaf> wli: Really?
23:22:14 <shachaf> DList, maybe?
23:22:31 <goalieca> wli: one of the forums is holding a language shootout, kinda like debian's. The maze generator does something like this http://factorcode.org/maze.png but with ascii output instead
23:22:35 <wli> shachaf: If you care enough to optimize.
23:22:54 <wli> goalieca: Checking it out.
23:23:00 <dons> shachaf: hmm, either DList or the Builder in Data.Binary
23:23:21 * shachaf has not seen Builder (or looked into Data.Binary at all).
23:23:31 <Tac-Tics> is there any debugger for haskell?
23:23:34 <sorear> > let{ filt set (x:xs) | S.member x set = filt set xs | otherwise = x : filt (S.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in filt S.empty cand
23:23:34 <dons> if you're logging bytestrings, that's a better option
23:23:35 <lambdabot>   Not in scope: `S.insert'
23:23:37 <shachaf> Tac-Tics: 6.7 has one.
23:23:40 <wli> A maze navigating agent that operates without a full map would be fun.
23:23:42 <Tac-Tics> 6.7?
23:23:49 <shachaf> Tac-Tics: GHC.
23:23:49 <sorear> GHC
23:23:50 <Tac-Tics> ah
23:23:51 <dons> Tac-Tics: only in ghc head branch, generally we debug with ghci though, and QuickCheck
23:23:52 <Tac-Tics> yes
23:23:53 <goalieca> without a full map? hehe
23:23:57 <wli> goalieca: Any specs on input/output?
23:24:08 <Tac-Tics> Ubuntu is kinda lame in how it doesn't give you uptodate versions of your software
23:24:10 <shachaf> Tac-Tics: (That's the development version; 6.8 will be the next release with it.)
23:24:17 <wli> goalieca: You have to remember where you've been and build up a map as you go.
23:24:32 <shachaf> Tac-Tics: If you want 6.7 you'll have to install it yourself; don't expect it in packages, generally.
23:24:33 <goalieca> wli: i use a stack.
23:24:44 <goalieca> well this is just the generator
23:24:44 <Tac-Tics> I remember I had to wait until Feisty came out before Python 2.5 was in the repository
23:24:44 <wli> goalieca: Really you only have to remember where you've been. Push down untaken turns on a stack or similar.
23:24:48 <goalieca> the solver comes next ;)
23:25:09 <shachaf> Tac-Tics: If you don't want to use Writer, why don't you at least cons currentCell on instead of appending it, and then reverse at the end?
23:25:11 <Tac-Tics> now my output is coming out as an empty list
23:25:14 <sorear> > let{ filt set (x:xs) | Data.IntSet.member x set = filt set xs | otherwise = x : filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in filt S.empty cand
23:25:15 <lambdabot>  Couldn't match expected type `Data.IntSet.IntSet'
23:25:21 <sorear> > let{ filt set (x:xs) | Data.IntSet.member x set = filt set xs | otherwise = x : filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in filt Data.IntetS.empty cand
23:25:22 <lambdabot>   Not in scope: `Data.IntetS.empty'
23:25:28 <Tac-Tics> shachaf... I'll get to that soon
23:25:31 <sorear> > let{ filt set (x:xs) | Data.IntSet.member x set = filt set xs | otherwise = x : filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in filt Data.IntSet.empty cand -- wli
23:25:33 <lambdabot>  [9,28,35,65,72,91,126,133,152,189,217,224,243,280,341,344,351,370,407,468,55...
23:25:48 <Tac-Tics> getting it to work is the first step ^^;
23:25:48 <sorear> oh, test backward
23:25:50 <wli> goalieca; Basically you'd interact with a maze navigation shell that tells you what turns are legal at your current position.
23:25:52 <Tac-Tics> and I'm not there quite yet
23:25:55 <sorear> > let{ filt set (x:xs) | not $ Data.IntSet.member x set = filt set xs | otherwise = x : filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in filt Data.IntSet.empty cand -- wli
23:25:59 <lambdabot> Terminated
23:26:00 <Tac-Tics> but I did think of that
23:26:02 <wli> sorear: What's this about?
23:26:08 <sorear> > let{ filt set (x:xs) | not $ Data.IntSet.member x set = filt set xs | otherwise = x : filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in take 10 $ filt Data.IntSet.empty cand -- wli
23:26:14 <lambdabot> Terminated
23:26:18 <sorear> > let{ filt set (x:xs) | not $ Data.IntSet.member x set = filt set xs | otherwise = x : filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in take 5 $ filt Data.IntSet.empty cand -- wli
23:26:22 <lambdabot> Terminated
23:26:38 <shachaf> Tac-Tics: Annotate with your old, working code?
23:26:44 <sorear> wli: Fast ramanujan number generation.  I thought I had an extrememly fast algorithm
23:27:10 <Tac-Tics> oh, I got it
23:27:16 <Tac-Tics> I'll just keep working on this
23:27:25 <Tac-Tics> I think the hard part is going to be the [ and ] commands
23:27:28 <Tac-Tics> those are always killer
23:28:02 <wli> sorear: Well, there is some difficulty here.
23:28:31 <wli> sorear: I think the way to go may involve elliptic curves but I'm not sure.
23:29:16 <Tac-Tics> @type Right
23:29:18 <lambdabot> forall b a. b -> Either a b
23:29:22 <sorear> > let{ filt set (x:xs) | Data.IntSet.member x set = x : filt set xs | otherwise = filt (Data.IntSet.insert x set) xs ; cand = [ a*a*a + b*b*b | a <- [1::Int ..] , b <- [1..pred a] ] } in filt Data.IntSet.empty cand -- got it
23:29:24 <lambdabot>  [1729,4104,13832,20683,32832,39312,40033,46683,64232,65728,110656,110808,134...
23:29:24 <Tac-Tics> ah whoops
23:29:31 <sorear> wli: fast enough for you?
23:30:42 <wli> sorear: Well, it doesn't keep the quadruplets, so there is some pain.
23:30:54 <sorear> wli: that can be fixed quite easily
23:31:28 <wli> sorear: I don't quite understand how it's working.
23:33:16 <wli> sorear: The first 1000 come out blazing fast, so it does look promising.
23:34:15 * wli is wondering why what he's already written sucks.
23:35:07 <Tac-Tics> can you not use guards in let expressions?
23:35:46 <sorear> sure you can
23:35:58 <sorear> > let { a | True = 2 | False = 0 } in a
23:35:59 <wli> sorear: Are you basically tabulating i^3 + j^3, and when you get a clash, logging the number?
23:36:00 <lambdabot>  2
23:36:06 <sorear> wli: Yup
23:36:25 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2038#a1
23:36:50 <Tac-Tics> that is giving me syntax errors
23:37:14 <wli> sorear: I'm not sure that can be extended to track the quadruplets without slowing down a lot.
23:37:22 <Tac-Tics> indentation errors to be exact
23:38:04 <sorear> Tac-Tics: The guard is part of the preceding definition.
23:38:25 <sorear> Tac-Tics: A new line at the same indentation level indicates a *new* definition.
23:39:06 <Tac-Tics> ah
23:39:32 <Tac-Tics> thanks, that got it
23:39:41 <wli> sorear: I'm really trying to find the (i,j,k,m) quadruples where i^3+j^3=k^3+m^3, i < j, k < m, i < k, foldr1 gcd [i,j,k,m] == 1 vs. true Ramanujan numbers.
23:39:49 <Tac-Tics> Haskell just has so many syntactic gotchas it's not funny
23:39:54 <sorear> wli: I can get the first 1000 quadruplets in ~10s with my first instrumented version - fast enough?
23:40:10 <Tac-Tics> sometimes I wonder if it would be better to just always use { ; ; ; }
23:40:15 <SamB_XP_> hmm. interesting things happen when you click on the "more information" link in the XP post-crash dialog for your browser...
23:40:20 <Tac-Tics> but then I remember Java programming
23:41:03 <wli> sorear: The first 1000 runs in 1.34s here; I just sort of need those quadruplets. Thanks, though.
23:41:22 * wli goes back to http://holomorphy.com/~wli/Easy.lhs
23:41:27 <sorear> wli: How many quadrupleds do you need how fast?
23:42:13 <wli> sorear: I don't need them super-fast, but what I've got on hpaste.org is pathologically slow.
23:43:46 <wli> sorear: I'll actually more typically want/need the triples for a given n, with orderly failure (e.g. returning Nothing) in the case of nonexistence.
23:43:56 <wli> s/triples/quadruples/
23:44:28 <sorear> wli: I don't see an n
23:45:20 <wli> sorear: There wasn't one. The "real life" problem it relates to involves the given n. I just wrote this to try to find things.
23:45:34 <shachaf> Is there a reason to use monads if arrows do everything monads do?
23:45:49 <shachaf> I.e., is there a reason to have sugar both for arrows and for monads?
23:46:14 <sorear> shachaf: arrows are much more complicated and we don't have time machines
23:46:43 <sorear> wli: also, I think you might have your problem statement wrong; mine will return quadruples (i,j,k,m) where i < j, k < m, (i,j) < (k,m) BUT i = k - you seem to rule those out arbitrarily
23:47:06 <shachaf> sorear: Can't the arrow sugar work equally well for monads, in theory?
23:47:44 <wli> sorear: i == k forces j == m, no?
23:47:47 * shachaf has no idea about what he's saying, of course.
23:47:47 <sorear> shachaf: yes, except that (\x y. x -> m y) can't be made an instance head in current haskell
23:48:08 <sorear> wli: uh... cube is injective on nat, *d'oh*
23:49:42 <shachaf> Is there a language that uses arrows for everything?
23:49:49 <shachaf> @quote spear
23:49:49 <lambdabot> No quotes match. My mind is going. I can feel it.
23:49:53 <shachaf> :-(
23:50:28 <wli> I've forgotten what the real-life problem was.
23:51:16 <wli> It was something like finding rational points on w^3+x^3=y^3+z^3 but I don't remember why.
23:51:19 <dons> shachaf: hmm, one of the hardware description DSLs?
23:51:24 <dons> like Lava (?)
23:52:00 <shachaf> dons: For, e.g., IO?
23:52:23 <SamB_XP_> dons: what's with that (?)
23:52:26 <SamB_XP_> is it a type variable?
23:52:40 <goalieca> is there a way to "show" Char without the escapes?
23:53:03 <wli> sorear: In any event I'm moving on to trying to figure out whether any of the type inference stuff I've got thus far is correct and trying to get the rest of the pieces of it together.
23:54:04 <sorear> goalieca: what do you want? Char -> String?
23:54:11 <nornagon> why does "data Cell a = (Num a) => Cell { height :: a }" work but not "data Cell a = Cell { height :: (Num a) => a }"?
23:54:12 <sorear> goalieca: try [x]
23:54:41 <sorear> nornagon: because qualified types aren't first class in H98
23:54:53 <sorear> nornagon: it will work in GHC (but they aren't the same)
23:54:56 <nornagon> Um. What's a first class type?
23:54:56 <goalieca> doesn't work. i already tried that
23:54:59 <Tac-Tics> oh god
23:55:03 <Tac-Tics> I got my [ and ] to work
23:55:04 <nornagon> (And I'm using GHC...)
23:55:07 <Tac-Tics> but the code is sooo ugly
23:55:15 <sorear> nornagon: -fglasgow-exts?
23:55:15 <goalieca> every method but putChar seems to add ' or "
23:55:20 <nornagon> sorear: ah, not.
23:55:28 <SamB_XP_> sorear: ... what the heck?
23:55:41 <nornagon> what's the {-# foo #-} for that?
23:55:46 <Tac-Tics> and I don't know how to do input without ``getting it on'' with the IO monad
23:55:49 <sorear> SamB_XP_: nornagon is trying to create a record with a field of qualified type
23:55:57 <SamB_XP_> "data Cell a = Cell { height :: (Num a) => a }"?
23:55:59 <wli> goalieca: putStrLn [c]
23:55:59 <nornagon> also, what's actually the difference?
23:56:06 <SamB_XP_> you think that's going to work in GHC?
23:56:38 <Tac-Tics> @hoogle [a] -> [a]
23:56:42 <lambdabot> Prelude.cycle :: [a] -> [a]
23:56:42 <lambdabot> Prelude.init :: [a] -> [a]
23:56:42 <lambdabot> Prelude.reverse :: [a] -> [a]
23:56:53 <nornagon> SamB_XP_: works great if I take out the 'a' after 'Cell'
23:56:58 <sorear> I feel so stupid
23:57:03 <nornagon> but I don't know what I'm actually doing :)
23:57:08 <sorear> ./a.out    # produces lots of output
23:57:43 <sorear> head -1000 ./a.out >/dev/null # works waaay to quickly; did I get the head syntax right?  let's see...
23:58:03 <sorear> head -1000 ./a.out   # BBEEP! BEEP BEEPP! BZZT!
23:58:04 <nornagon> XD
23:58:54 <sorear> My prompt is made of DEC line drawing characters now. :)
23:59:05 <SamB_XP_> oh lovely
23:59:26 <dons> glguy, Cale, around?
23:59:33 <SamB_XP_> why don't you just cat /dev/random
23:59:52 <SamB_XP_> I mean, besides that being a waste of good entropy!
