00:39:03 <zipMe> @jcpetruzza : i installed it with darwinports
00:39:03 <lambdabot> Unknown command, try @list
00:44:27 <mudge> hey,  what module is the compose function in?
00:44:51 <xerox> ?index (.)
00:44:51 <lambdabot> Prelude
00:45:06 <mudge> it is in prelude?
00:45:11 <xerox> Yup.
00:45:14 <xerox> ?docs Prelude
00:45:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
00:46:21 <mudge> oh, i meant the function compose that composes a list of functions, like this:  compose [func, func2, func3, func4]
00:46:34 <mudge> which means func.func2.func3.func4.
00:46:47 <xerox> There is no standard one. There are many on the wiki
00:46:55 <xerox> http://haskell.org/haskellwiki/Compose
00:46:56 <lambdabot> Title: Compose - HaskellWiki
00:46:56 <newsham> let pipe = flip compose
00:48:08 <mudge> oh thanks
00:48:26 <newsham> err..  compose . reverse
00:48:31 <newsham> tired
00:48:43 <mudge> fast
00:52:00 <adu> hi
00:53:19 <adu> my feeble brain hurts after reading about Matrin-Lof type theory...
00:54:27 <newsham> thats the one agda and alfa use right?
00:59:55 <adu> whats agda?
01:00:30 <adu> whats alfa?
01:01:54 <augustss> agda and alfa are interactive proof editors
01:02:16 <augustss> like an IDE for M-L type theory
01:02:28 <adu> oh
01:02:46 <adu> would they help me prove something is real-analytic?
01:03:33 <augustss> only with a LOT of preliminary work
01:04:01 <adu> i take that as a no...
01:04:07 <augustss> very little has been done for continuous math
01:04:38 <adu> i seem to remember MetaMath having some Hilbert space stuff
01:05:46 <augustss> Coq would be a better choice for showing things about the reals.  They have some libraries.
01:06:51 <augustss> But you have to be extra careful with both Coq and Agda, you can only use constructive maths (at least if you want to extract programs)).
01:10:27 <earthy> doesn't John Harrison have a number of libraries for continuous math?
01:10:46 <augustss> Yes, I think so.
01:11:19 <earthy> yup. there's quite a bit of infrastructure for real analysis in the HOL family
01:11:52 <earthy> (and it's being used in formal proofs of the correctness of the algorithms for fast floating point in Intel's processors, even :))
01:15:50 <newsham> no more pentium5.000000000001 bugs?
01:17:58 <newsham> so many logics, so little time
01:19:13 <psykotic> i seem to recall that there's a full translation of one of landau's analysis books for automath
01:19:36 <psykotic> but automath isn't very "hot" anymore :)
01:38:05 <adu> psykotic: what is hot then?
01:38:41 <psykotic> any of the things that people have just mentioned
01:38:59 <psykotic> automath was one of the first serious systems of this kind
01:47:27 <aleator> Is there any reason I get errors of Overlapping instances even when using  -fallow-overlapping-instances?
01:53:21 <Tac-Tics> @src fmap
01:53:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:53:28 <Tac-Tics> @src liftM
01:53:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:56:33 <Tac-Tics> > filterM (const [False, True]) [1,2,3]
01:56:34 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
01:57:35 <adu> wha?
01:57:47 <adu> @src filterM
01:57:47 <lambdabot> Source not found. My mind is going. I can feel it.
01:58:04 <adu> @type filterM
01:58:06 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:59:41 <adu> > filterM (const [False, True]) "1234"
01:59:43 <lambdabot>  ["","4","3","34","2","24","23","234","1","14","13","134","12","124","123","1...
02:00:16 <adu> why does that happen?
02:00:36 <adu> how do you get power-set from filterM?
02:01:14 <quicksilver> the magic of the list monad
02:01:48 <norpan> list monad creates all combinations, and then you filter out those that have True, and since all combinations exist you get powerset
02:02:06 <quicksilver> > [False,True] >> "1234"
02:02:08 <lambdabot>  "12341234"
02:02:15 <quicksilver> (this is a step on the way to the answer, in a sense)
02:02:36 <adu> [False, False] >> "1234"
02:02:48 <adu> >[False, False] >> "1234"
02:02:54 <adu> > [False, False] >> "1234"
02:02:56 <lambdabot>  "12341234"
02:03:19 <adu> > [True, True] >> "1234"
02:03:20 <lambdabot>  "12341234"
02:03:30 <sieni> > ["It really doesn't", "matter what list this is"] >> "1234"
02:03:31 <lambdabot>  "12341234"
02:03:46 <sieni> > "badger" >> "badger"
02:03:48 <lambdabot>  "badgerbadgerbadgerbadgerbadgerbadger"
02:04:01 <adu> ooo because >> discards whats "inside" the monad
02:04:29 <sieni> > [1..] >> [1]
02:04:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:04:54 <adu> > [1..] >> ['a']
02:04:55 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
02:04:58 <adu> hehe
02:05:31 <sieni> [1..] >> "badger"
02:05:36 <sieni> > [1..] >> "badger"
02:05:38 <lambdabot>  "badgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbad...
02:05:41 <Tac-Tics> @let snake = "sn" ++ cycle ["a"] ++ "ke"
02:05:42 <lambdabot> Couldn't match expected type `Char' against inferred type `[Char]'
02:05:47 <quicksilver> you may also want to try:
02:06:00 <quicksilver> > filterM (const [True]) "1234"
02:06:01 <lambdabot>  ["1234"]
02:06:01 <Tac-Tics> @let snake = "sn" ++ cycle "a" ++ "ke"
02:06:05 <lambdabot> Defined.
02:06:06 <quicksilver> > filterM (const [False]) "1234"
02:06:07 <Tac-Tics> snake
02:06:08 <lambdabot>  [""]
02:06:10 <Tac-Tics> > snake
02:06:12 <lambdabot>  "snaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
02:06:15 <Tac-Tics> hehe
02:06:47 <sieni> > "Ooh, it's a " ++ snake
02:06:48 <lambdabot>  "Ooh, it's a snaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
02:07:14 <adu> > filterM (const [True]) "1234"
02:07:15 <lambdabot>  ["1234"]
02:07:34 <adu> > filterM (const [True, False]) "1234"
02:07:35 <lambdabot>  ["1234","123","124","12","134","13","14","1","234","23","24","2","34","3","4...
02:07:45 <adu> why does it have to have 2 elements?
02:08:01 <Tac-Tics> > filterM (const [False, True]) snake
02:08:03 <lambdabot>  Exception: stack overflow
02:08:17 <Tac-Tics> why does what have two elements?
02:08:24 <Tac-Tics> the [True, False]?
02:08:28 <adu> ya
02:08:46 <Tac-Tics> That was a piece of code that absolutely blew my mind away when I saw it the first time
02:08:50 <Tac-Tics> I forgot who showed me it
02:09:10 <adu> ya, it blew mine :)
02:09:11 <Tac-Tics> but if you step through the evaluation, it slowly reveals the meaning of life
02:09:19 <quicksilver> adu: because you can construct a powerset by considering, for every item in the set, TWO possibilities
02:09:26 <quicksilver> adu: either (1) include it or (2) exclude it
02:09:32 <adu> the only monad I fully understand is Maybe
02:09:36 <Tac-Tics> Roughly, it's [False, True] because it toggles between being in the list and not
02:09:42 <quicksilver> adu: these two possibilities are True and False
02:09:57 <quicksilver> adu: this is how you prove that the size of a powerset is 2^n
02:10:00 <quicksilver> well it's the most obvious way
02:10:17 <adu> quicksilver: right
02:10:19 <Tac-Tics> adu: the List monad isn't so bad for basic stuff. List comprehensions are just simplified List-monad expressions
02:10:46 <adu> realy? hmm
02:11:04 <Tac-Tics> > [(x, y) | x <- [1,2,3], y <- "abc"]
02:11:05 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:11:10 <sieni> @src filterM
02:11:10 <lambdabot> Source not found. Where did you learn to type?
02:11:19 <Tac-Tics> > do x <- [1,2,3]; y <- "abc"; return (x, y)
02:11:21 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:12:37 <Tac-Tics> I think that's the only reason I've put up with Haskell for so long, despite how hard it is
02:12:55 <Tac-Tics> those crazy expressions like fib and powerset
02:13:10 <Tac-Tics> no other language makes them so rediculously short
02:13:20 <Tac-Tics> and that's just amazing
02:13:35 <Tac-Tics> oh, that reminds me
02:13:44 <Tac-Tics> http://harold.hotelling.net/queens.hs
02:14:00 <Tac-Tics> that's another example of "how the f*k does that do what it does?"
02:14:05 <adu> wait, so list comprehensions are like do-blocks?
02:14:26 <Tac-Tics> list comprehensions are just syntactic sugar for List do-blocks
02:14:41 <Tac-Tics> and do-blocks are just syntactic sugar for >>= =-)
02:15:25 <Tac-Tics> > [1,2,3] >>= (\a -> "abc" >>= (\b -> return (a, b)))
02:15:27 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:15:30 <quicksilver> > do { x <- [1,2,3]; y <- "abc"; return (x,y) }
02:15:32 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:15:40 <quicksilver> there you are, all three versions now :)
02:16:26 <sieni> @pl [1,2,3] >>= (\a -> "abc" >>= (\b -> return (a, b)))
02:16:26 <lambdabot> (`fmap` "abc") . (,) =<< [1, 2, 3]
02:17:27 <Tac-Tics> sieni, that is so incomprehensible, it might as well be perl =-P
02:17:47 <sieni> @pl "def" >>= (\c -> [1,2,3] >>= (\a -> "abc" >>= (\b -> return (a, b))))
02:17:48 <lambdabot> "def" >> ((`fmap` "abc") . (,) =<< [1, 2, 3])
02:17:54 <wolverian> more like apl
02:17:58 <sieni> @pl "def" >>= (\c -> [1,2,3] >>= (\a -> "abc" >>= (\b -> return (c, a, b))))
02:17:59 <lambdabot> ([1, 2, 3] >>=) . ((("abc" >>=) . (return .)) .) . (,,) =<< "def"
02:18:03 <wolverian> perl is much easier for mere mortals :)
02:18:27 <sieni> > "def" >>= (\c -> [1,2,3] >>= (\a -> "abc" >>= (\b -> return (c, a, b))))
02:18:28 <lambdabot>  [('d',1,'a'),('d',1,'b'),('d',1,'c'),('d',2,'a'),('d',2,'b'),('d',2,'c'),('d...
02:19:35 <Tac-Tics> @let divi a 0 = Nothing; divi a b = Just $ a / b
02:19:38 <lambdabot> Defined.
02:20:22 <Tac-Tics> @let pairs = zip [0..10] [0..10]
02:20:24 <lambdabot> Defined.
02:20:39 <sieni> @pl \a b -> a >>= (\c -> b >>= (\d -> return (c, d)))
02:20:39 <lambdabot> liftM2 (,)
02:20:42 <Tac-Tics> @type curry
02:20:44 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:20:50 <Tac-Tics> @type uncurry
02:20:51 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:21:05 <sieni> > liftM2 (,) "abc" "def"
02:21:06 <lambdabot>  [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c',...
02:21:36 <sieni> cool
02:22:20 <Tac-Tics> > map (liftM (uncurry divi)) pairs
02:22:20 <lambdabot>  Couldn't match expected type `(a, a)'
02:22:23 <Tac-Tics> blah
02:24:18 <Tac-Tics> > (uncurry divi) (0,0)
02:24:19 <lambdabot>  Nothing
02:24:25 <Tac-Tics> > pairs !! 0
02:24:26 <lambdabot>  (0,0)
02:24:36 <Tac-Tics> > (uncurry divi) (pairs !! 0)
02:24:37 <lambdabot>   add an instance declaration for (Fractional Integer)
02:25:03 <Tac-Tics> > (uncurry divi) ((pairs !! 0) :: (Int, Int)
02:25:04 <lambdabot>  Unbalanced parenthesis
02:25:14 <Tac-Tics> > (uncurry divi) ((pairs !! 0) :: (Int, Int))
02:25:15 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
02:25:37 <quicksilver> Tac-Tics: did you mean 'div' and not / ?
02:25:41 <quicksilver> Tac-Tics: when you defined divi
02:25:45 <Glimi> I'm browsing trough slides of Neil Mitchell about a Haskell optimizer. He mentions a bug in GHC 6.6 with the function take due to an optimization. I can't seem to find information about this bug in Google. Does anybody has any more information about this remark for me?
02:25:50 <Glimi> slides are at http://www-users.cs.york.ac.uk/~ndm/downloads/slides-fastest_lambda_first-30_may_2007.pdf
02:25:53 <Tac-Tics> no no, the weirdness is coming from pairs I think
02:25:54 <lambdabot> http://tinyurl.com/3ydml6
02:25:54 <Tac-Tics> @type pairs
02:25:56 <lambdabot> Not in scope: `pairs'
02:26:09 <quicksilver> @type L.pairs
02:26:09 <Tac-Tics> > pairs
02:26:13 <lambdabot> Couldn't find qualified module.
02:26:13 <lambdabot>  [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
02:26:22 <quicksilver> Tac-Tics: pairs is [(Int,Int)]
02:26:28 <quicksilver> Tac-Tics: but divi wants fractionals
02:26:39 <quicksilver> Tac-Tics: whats why I think you meant `div` not /
02:26:50 <Tac-Tics> I guess I thought pairs would resolve to a Num a => (a,a) type or something like that
02:27:01 <quicksilver> not unless you give it that type specifically
02:27:12 <quicksilver> that's defaulting/the monomorphism restriction
02:27:37 <Tac-Tics> I dunno what that means, but I'm sorry =-P
02:27:51 <Tac-Tics> it won't happen again
02:28:05 <quicksilver> Num types get defaulted
02:28:22 <quicksilver> and constant terms, without explicit type sigs, can't be polymorphic
02:28:54 <Tac-Tics> @let pairs = zip [0.0..10.0] [0.0..10.0]
02:28:55 <lambdabot> <local>:6:0:     Multiple declarations of `L.pairs'     Declared at: <local>:...
02:29:02 <Tac-Tics> blah
02:29:11 <Tac-Tics> what is it undef?
02:29:35 <Tac-Tics> @undef pairs
02:29:36 <lambdabot> Undefined.
02:29:46 <Tac-Tics> > divi 0 0
02:29:46 <lambdabot>   Not in scope: `divi'
02:29:49 <Tac-Tics> /sad
02:29:52 <Tac-Tics> oh well
02:30:22 <Tac-Tics> In a compiled program or a loaded module, though, wouldn't it keep the type polymorphic and infer the type from context? or no?
02:31:41 <quicksilver> no
02:31:48 <quicksilver> that's the monomorphism restriction
02:32:02 <quicksilver> you can give an explicitly polymorphic signature though
02:32:05 <Tac-Tics> yeah
02:32:17 <pejo> Glimi, he's quite often here as 'ndm', so if you're not in a hurry you can just ask him.
02:32:20 <Tac-Tics> is that explained in the brief introduction to haskell?
02:32:30 <quicksilver> possibly not
02:32:34 <quicksilver> it's a bit obscure
02:33:00 <quicksilver> it's not required by the language, it's just an arbitrary decision made by committee
02:33:04 <Glimi> pejo, thanks :)
02:33:07 <quicksilver> one which many people disagree with
02:33:15 <Tac-Tics> I see I see
02:33:25 <lxix> oy
02:33:32 <Tac-Tics> I was just trying to play around to create a list of type [Maybe a]
02:33:39 <Tac-Tics> so I could toy with it
02:34:53 <Tac-Tics> I was going to look for a way to remove the Nothings from the list and then un-Just all the Justs
02:35:06 <Tac-Tics> @hoogle [Maybe a] -> [a]
02:35:07 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
02:35:15 <quicksilver> > let pairs = zip [0..3] [0..3]; divi a b | b == 0 = Nothing | otherwise = Just (a `div` b) in map (uncurry divi) pairs
02:35:17 <lambdabot>  [Nothing,Just 1,Just 1,Just 1]
02:35:43 <quicksilver> > let pairs = zip [0..3.0] [0..3.0]; divi a b | b == 0 = Nothing | otherwise = Just (a / b) in map (uncurry divi) pairs
02:35:45 <lambdabot>  [Nothing,Just 1.0,Just 1.0,Just 1.0]
02:36:20 <Tac-Tics> catMaybe appears to be just the function I was thinking of
02:36:50 <Vq^> @src catMaybe
02:36:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:36:54 <quicksilver> yes, it's very easy to write
02:36:58 <quicksilver> @src catMaybes
02:36:59 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:37:33 <Tac-Tics> eh? the pattern won't fail with that?
02:37:40 <quicksilver> it will
02:37:44 <mux> patterns_in_list_comprehension++
02:37:44 <Tac-Tics> well
02:37:47 <quicksilver> but pattern failure in monads is magical
02:37:51 <quicksilver> it calls 'fail'
02:37:56 <mux> in the list monad, fail = []
02:37:56 <Tac-Tics> ah
02:40:06 <Tac-Tics> so the fail in IO would be the thing that actually prints out the error to stderr?
02:40:14 <quicksilver> yup
02:40:31 <quicksilver> well it doesn't necessarily
02:40:36 <quicksilver> fail in IO is an exception, it can be caught
02:40:38 <Tac-Tics> yeah, if you catch it right?
02:40:43 <quicksilver> but if not caught, then yes
02:41:16 <Tac-Tics> is that a special language construct? or does fail generate some sort of propogating value or something weird like a continuation?
02:42:04 <quicksilver> exceptions are quite consistent with haskell's denotational semantics
02:42:13 <quicksilver> they're a "special kind" of _|_
02:42:25 <quicksilver> you should read the awkward squad paper if you're interested
02:42:34 <Tac-Tics> the DS one?
02:42:40 <Tac-Tics> er
02:43:27 <Tac-Tics> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
02:43:28 <lambdabot> Title: Simon Peyton Jones: papers
02:43:30 <Tac-Tics> this one?
02:43:30 <adu> my friend things (_|_) looks like a bottom
02:43:38 <quicksilver> Tac-Tics: yes, that on
02:43:38 <Tac-Tics> hehe, it does!
02:43:54 <quicksilver> adu: they are not the first person to observe that :P
02:44:25 <adu> hmm, i thought it was because it was the technical notation for False
02:45:26 <quicksilver> yes, it's a coincidence
02:45:35 <quicksilver> but many people have noticed it before your friend :)
02:45:41 <adu> ok
02:45:54 <Tac-Tics> I think I'm going to read this for a little bit and then head off to bed
02:46:09 <Tac-Tics> I have to get up early for my very nonhaskell related job
02:46:56 <Tac-Tics> thank you for all your educationalizing quicksilver
02:46:58 <Tac-Tics> quicksilver++
02:56:24 * earthy grins at Philip Wadler's sentence 'I enjoyed speaking in a room filled by clever people interested in FP not in order to write an academic paper, but because they have a large pile of money that they want to make larger'
02:57:06 <FZ> earthy: you refer to Google Video? :)
02:57:30 <wli> SDE solvers in Haskell?
02:58:17 <earthy> nope, I refer to philip wadler's blog
02:58:44 <FZ> earthy: so he refers to his Google video?
02:58:51 <wli> I was thinking of what the people trying to make their large piles of money wanted to make larger.
02:58:57 <FZ> didn't he visit Google to talk about FP and Haskell, recently?
02:59:01 <wli> + wanted to do.
03:03:06 <earthy> nope, he actually refers to his Jane Street Capital visit
03:03:38 <FZ> oh, so he'd been there too, huh
03:03:40 <FZ> great :)
03:04:14 <FZ> As far as I remember, JSC was looking for O'Caml programmers
03:05:45 <adu> has anyone written an OS in Haskell yet?
03:06:15 <pejo> adu, several. There's one ICFP paper describing "House" for example.
03:11:59 <wli> I say that if you want to advocate the language, then go on a shock and awe campaign of cranking out major applications. xmonad is nice but it's not got the flash of beryl. Where's the web browser in Haskell? Computer algebra system (we seem to have numerous beginnings thereof)? CAD/CAM system? Digital studio app? etc.
03:12:42 <FZ> Where is...
03:12:44 <FZ> Where is...
03:12:52 <FZ> "Where is everybody" -- Fermi :)
03:13:02 <wli> Of course, who has the time or energy to do such things?
03:13:35 <pejo> wli, I think we have to face the limitation of the community. There's simply not enough eyes.
03:14:23 <wli> pejo: Yeah. I'm also not particularly an advocate for anything in particular myself.
03:15:59 <FZ> once the O'Reilly haskell book is out, everybody will be rushing to bookstores :-p
03:16:12 <FZ> which is called O'Reilly effect :)
03:16:14 <wli> Which is probably also the case for various of those who can actually pull off things of that sort.
03:16:42 <pejo> FZ, I'm looking forward to that book myself.
03:16:46 <FZ> me, too
03:17:22 <FZ> I even proposed authors to be one of the viewers, since I don't know much Haskell I can be useful as a 'newbie perspective'
03:17:23 <pejo> wli, what was the context of your last statement? I didn't understand it.
03:17:42 <FZ> I've done a similar thing for Practical Common Lisp, it was quite an experience as it was being written
03:18:32 <wli> Cranking out a competitor to gcc might be something the community could do. There is something of a need for it due to the various political constraints on its features.
03:19:27 <FZ> Did they write a competitior to GCC in Java or C#, yet they are very popular languages
03:19:30 <wli> pejo: Haskell advocacy is not the primary pursuit of many of the more knowledgeable and/or able people.
03:19:58 <wli> FZ: Sufficiency vs. necessity.
03:20:21 <pejo> wli, *BSD would not be interested in that GCC competitor. They're working pretty hard to throw out anything that isn't written in C in their base systems.
03:21:11 <pejo> wli, well, many of the able/knowledgeable people are academics, and they are probably more concerned with tenure for obvoius reasons.
03:21:16 <wli> pejo: Are you aware of the IR marshalling political issue wrt. gcc?
03:21:40 <pejo> wli, 'IR marshalling'?
03:21:57 <FZ> pejo: once they are tenured, what are they interested in? ;-)
03:22:13 <dcoutts_> FZ: lunch
03:22:19 <FZ> :)
03:22:45 <wli> pejo: Essentially RMS and/or the FSF refuse to structure the thing normally because dumping intermediate state supposedly raises the specter of proprietary back-ends.
03:23:00 <dcoutts_> or proprietary font-ends
03:23:09 <wli> Yeah.
03:23:36 <pejo> wli, oh. Think LLVM bumped into that problem too.
03:23:36 <dcoutts_> but it also means we can't use gcc as a front end to open source C source code analysis tools easily
03:23:44 <wli> pejo: It's limited the capabilities somewhat in various respects and so on.
03:24:24 <dcoutts_> eg if gcc could dump an IR, then c2hs would have been easier to write as we'd not need a C parser
03:24:33 <wli> dcoutts: It also makes life Hell for open source projects attempting to add new front ends etc.
03:24:46 <dcoutts_> yes, have to be in-tree or nothing
03:25:16 <pejo> dcoutts, most definitely. I believe that RMS sometimes hurt his cause in the name of free software.
03:25:30 <wli> Hence the extremely awkward situation with Mercury's gcc front-end.
03:26:08 <|Steve|> I can't believe anyone still cares what RMS thinks.
03:26:13 <pejo> wli, still though, are you saying that someone will fork gcc and make it more reasonable to work with, like the X consortium?
03:26:29 <|Steve|> Apple forked it.
03:27:02 <wli> pejo: I was vaguely thinking that there's enough compiler know-how in the Haskell community for it to outright NIH it.
03:27:12 <pejo> Steve, been a couple of years since I read the gcc mailing lists, but atleast by that time the Apple employees said they wanted to carry as few external patches as possible in their "fork".
03:27:41 <|Steve|> pejo: True. They do try to get their stuff into mainline, but that hasn't always happened.
03:27:53 <dcoutts_> wli: we don't have enough low level know-how
03:28:32 <wli> dcoutts: In/around codegen?
03:28:37 <dcoutts_> wli: right
03:29:22 <dcoutts_> wli: eg, what ghc does to code is amazing to behold, often generating essentially perfect STG code, but from there on down it starts to get a bit depressing.
03:29:49 <dcoutts_> STG -> CMM often looks dumb and CMM -> asm is naive
03:30:04 <dcoutts_> though both those areas are looking up atm
03:30:13 <dcoutts_> there's a new reg allocator in the works
03:30:50 <dcoutts_> and there's a new higher level C-- -> lower level C-- pass
03:31:05 <wli> dcoutts: There are vaguely public descriptions of various integrated instruction selection and register allocation (both tasks carried out simultaneously) floating around. I'm not sure about how bad the patent minefield is in that area, though.
03:31:06 <pejo> dcoutts, isn't this mainly a sign of the lack of time in the GHC hq?
03:31:29 <dcoutts_> which converts C-- with local vars and procedure calls with args, to C-- with explicit stack stuff
03:31:55 <dcoutts_> pejo: sure, they get paid to do functional research, not traditional compiler optimisations
03:32:04 <dcoutts_> and the QC-- guy is working at MSR for a while too
03:32:19 <adu> whats MSR?
03:32:20 <pejo> dcoutts, Ramsey, or someone else?
03:32:27 <dcoutts_> he's been talking about bringing in some heavy flow graph stuff
03:32:31 <dcoutts_> pejo: right
03:32:49 <dcoutts_> adu: Microsoft Research, in Cambridge, where GHC HQ is.
03:32:53 <adu> ic
03:33:14 <wli> dcoutts: I've got my fingers crossed for integrated instruction selection and register allocation. That's one way to leave gcc in the dust.
03:33:24 <pejo> dcoutts, oh, that's nice. There was a long email describing the qc-- situation in december last year to the qc mailing list. He seemed unsure of the future of qc--, since the landscape had changed somewhat since they started the project.
03:33:44 <dcoutts_> wli: hmm, well atm, I think they're implementing a traditional graph colouring allocator, it'll still be a big step up :-)
03:34:01 <wli> ouch
03:34:04 <pejo> wli, isn't gcc notoriously bad at register allocation as well?
03:34:41 <pejo> dcoutts, well, Ramsey is definitely the right man for that considering his publications.
03:34:52 <dcoutts_> indeed, so I'm quite hopeful
03:35:08 <wli> pejo: It's well below the level of any commercial C compiler on that front AIUI. It seems to compensate on x86 in other, highly unusual ways.
03:35:13 <dcoutts_> there's been much more low level focus recently
03:35:28 <wli> pejo: And it's completely ignored register-rich architectures on that front.
03:36:08 <dcoutts_> wli: how does it compensate on x86 ?
03:36:25 <wli> pejo: IOW its register allocation is actually poorest relative to the rest of the field where it would technically be the easiest to improve.
03:36:32 <pejo> wli, well. I think we all agree that there is room for improvement in gcc. :-)
03:37:52 <wli> dcoutts: I don't understand how it pulls off its progress in benchmarks vs. e.g. icc in that area. It seems to have to do with gcc's back-end RTL and I've always been immediately lost by the descriptions.
03:38:19 <dcoutts_> ok, black magic
03:38:22 <pejo> dcoutts, is Ramsey visiting MSR?
03:38:28 <dcoutts_> pejo: yes
03:38:48 <pejo> Bummer, means we can't keep him forever. :-)
03:39:01 <dcoutts_> heh
03:39:03 <wli> dcoutts: If I were to hazard a guess I might call them "peephole optimizations" but I'm just too clueless once it leaves textbook territory.
03:39:32 <dcoutts_> wli: it has pretty sophisticated instruction scheduling as I understand it
03:39:52 <MyCatVerbs> dcoutts: discussing compilers? icc?
03:39:55 <pejo> wli, if you browse the various backends there are actually quite a lot of peephole optimizations in them. I'm not sure if that is old cruft, or still necessary. Especially the oddball architectures has them.
03:40:22 <dcoutts_> MyCatVerbs: gcc
03:41:25 <MyCatVerbs> dcoutts: I thought gcc was starting to look a little dated now? I mean, unparalleled for standards compliance, sure (damn those FSF people sure are fussy ^^) but not so hot on the optimization front.
03:41:54 <dcoutts_> MyCatVerbs: yes
03:42:03 <wli> pejo: My extremely limited understanding of what the RTL bits do is as peephole optimizations in addition to general instruction descriptions. One could say that a large repertoire of peephole optimizations is what I described but AIUI more general things that I have no idea about go on. The entire area is very mysterious to me.
03:42:51 <MyCatVerbs> dcoutts: anything they're missing which could be added to make it kick moar arses?
03:43:14 <wli> MyCatVerbs: This entire discussion started up because I suggested NIH'ing gcc in Haskell. ;)
03:43:28 <MyCatVerbs> wli: ...
03:44:02 <MyCatVerbs> wli: well, why not? C's a shit language for writing anything complicated in. A C compiler would be much easier to write in Haskell than in C.
03:44:19 <MyCatVerbs> Oh yeah, that's why not, because it's FUCKING TONS OF WORK! >=X
03:44:44 <MyCatVerbs> And then, once you've done fucking tons of work on it, you have to do fucking tons MORE FUCKING WORK.
03:44:50 <MyCatVerbs> And then there's even MORE DAMN WORK. Etc.
03:45:14 <pejo> MyCatVerbs, "if the code parses, people will write it", or something along those lines was said by Engler. I guess dcoutts can give a first hadn experience report on that.
03:45:20 <wli> MyCatVerbs: Yes. That's the real issue with major applications. "Where do the bodies come from?"
03:46:03 <wli> MyCatVerbs: In theory Haskell's advantages should allow more to be done with fewer bodies, but still.
03:46:09 <dcoutts_> speaking of which, anyone want to maintain cabal-install :-)
03:46:18 <dcoutts_> it's a lovely useful bit of code that needs some love
03:46:27 <dcoutts_> @seen der_eq
03:46:27 <lambdabot> I saw der_eq leaving #haskell and #gentoo-haskell 8h 51m 20s ago, and .
03:46:32 <MyCatVerbs> pejo: Engler?
03:47:54 <pejo> MyCatVerbs, Dawson. Stanford Checker/Coverity.
03:49:47 <pejo> dcoutts, is ghc "good enough" at higher level optimizations, and the "problem" is the low level stuff in it?
03:50:02 <dcoutts_> pejo: I think so, yes
03:50:28 <dcoutts_> pejo: where clean and ocaml beat ghc is in the low level stuff
03:50:54 <MyCatVerbs> dcoutts: what about some of those spiffy deforestation tricks that a few insanely clever people have managed to get YHC to do thus far, which haven't been ported to GHC yet?
03:51:22 <dcoutts_> MyCatVerbs: that's clever high level stuff
03:51:34 <dcoutts_> it will not make your loops run any faster
03:51:43 <Philippa> it's also stuff that we'd really want to see proofs of correctness on before putting into GHC
03:52:07 <Philippa> SPJ's skepticism at AH was rather understandable if you know the background
03:52:32 <Saizan> stuff == supero?
03:52:52 * MyCatVerbs grumbles about missing AH.
03:53:11 <MyCatVerbs> Ah well, appointments.
03:53:17 <ari> AH?
03:53:46 <Saizan> AngloHaskell
03:53:50 <MyCatVerbs> AngloHaskell.
03:53:56 * ari sees
03:54:22 <MyCatVerbs> pejo: I'm not so sure about this Engler fellow. His previous work (exokernels?!) sounds totally insane.
03:54:37 <MyCatVerbs> pejo: but maybe -just- about insane enough to be really useful.
03:57:28 <ari> @bot
03:57:28 <lambdabot> :)
04:14:05 <pejo> Philippa, were there lots of details in the AH talks about it? Previous incarnations have been deforestation + some extra information propagation (positive supercompilation) according to my (vague) understanding.
04:15:14 <pejo> MyCatVerbs, his comment was wrt parsing C and making real world tools. Coverity is a spin-off from his research, and I believe he has seen more horrible (closed source) code than most others.
04:15:46 <Philippa> pejo: there isn't any deforestation per se, it looks an awful lot like partial evaluation
04:16:04 <Philippa> it's just that case/ctor means that you get the effect of deforestation
04:16:33 <MyCatVerbs> pejo: ahhhh.
04:18:02 <pejo> Philippa, that was not enough information for me. What is case/ctor?
04:18:24 <chessguy> @type sort
04:18:26 <lambdabot> forall a. (Ord a) => [a] -> [a]
04:18:40 <chessguy> @src sort
04:18:40 <lambdabot> sort = sortBy compare
04:19:36 <chessguy> @src sortBy
04:19:36 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:20:23 <Philippa> pejo: case SomeConstructor of {...SomeConstructor -> exp;...} => exp
04:20:43 <Philippa> (plus the obvious binding if SomeConstructor has parms)
04:20:47 <roconnor> @what NIH
04:20:47 <lambdabot> I know nothing about nih.
04:21:08 <ari> roconnor: Not Invented Here
04:21:33 <MyCatVerbs> roconnor: which is to say, gratituously reinventing the wheel.
04:21:44 <pejo> Philippa, that's equivalent to the operational semantics though?
04:22:17 <Philippa> pejo: sure, but it's a separate rule to beta reduction
04:22:22 <MyCatVerbs> Permissable only under certain circumstances, such as the last person to touch the wheel having been a tardbucket and having made it square or triangular.
04:22:52 <Philippa> and it's one that doesn't give you termination woes
04:22:58 <roconnor> MyCatVerbs: what about writing the wheel in C?
04:23:04 <pejo> Philippa, which are the controversial rules? Or is it space leaks/sharing that is the problem?
04:23:27 <Philippa> pejo: when you start doing beta reduction you need a clear idea when to stop :-)
04:23:45 <Philippa> oh yeah, note that: case/ctor means that /the constructor never gets called/
04:23:51 <Philippa> so you skip the allocation
04:24:18 <pejo> Philippa, well, while we need more research on ensuring termination, it's hardly difficult from a correctness pov.
04:24:20 <MyCatVerbs> roconnor: depending whether it's all raw C or you actually acted sensibly enough to use, say, yacc and lex instead of doing *everything* by hand, that may merely count as pentangular or hexagonal, which is -just- about good enough that the wheel could survive not being reinvented.
04:26:06 <mux> http://importantshock.wordpress.com/2007/08/21/haskell-curry-yes-i-dated-his-daughter/
04:26:09 <lambdabot> Title: &#8220;Haskell Curry? Yes, I dated his daughter.&#8221; « Important Shock, http://tinyurl.com/yo35nu
04:26:13 <Philippa> pejo: yeah, only if your optimiser isn't guaranteed to terminate you have problems. Which is why it won't be going into GHC without a proof that it does
04:26:13 <mux> heh, did you guys see that? :-)
04:26:20 <chessguy> @pl s b = se b (g b)
04:26:21 <lambdabot> s = ap se g
04:26:38 <roconnor> Philippa: GHC has non terminating optimizations.
04:26:48 <roconnor> what's wrong with a few more :P
04:27:17 <pejo> Philippa, I didn't understand your comment about skipping allocation of constructors either. Help me out please. :-)
04:27:49 <ndm> @karma+ JaffaCake -- giving bibtex entries for papers
04:27:49 <lambdabot> JaffaCake's karma raised to 12.
04:27:51 <chessguy> @hoogle Ordering -> Ordering
04:27:51 <lambdabot> No matches, try a more general search
04:28:36 <chessguy> is there an easy way to do something like sortBy (not.comparisonFunction)
04:28:42 <dcoutts_> pejo: case Just foo of Nothing -> ...; Just bar -> ...;
04:29:05 <chessguy> (obviously i don't actually want not in there)
04:29:07 <dcoutts_> pejo: we can optimise that, so that the Just is never allocated, analysed and discarded
04:29:22 <roconnor> chessguy: sortBy (flip comparisionFunction) ?
04:29:34 <pejo> dcoutts, I don't see how that is bad though.
04:29:41 <Philippa> pejo: I never said it was
04:29:47 <dcoutts_> pejo: no, that optimisation is a good thing!
04:29:48 <chessguy> ah, cute
04:30:15 <roconnor> chessguy: I'm making some reasonable assumptions about comparisonFunction :P
04:30:15 <Philippa> I just said that that's the bit that lets supero do deforestation within its framework - that's where the allocations get ditched
04:30:25 <chessguy> roconnor, such as?
04:31:28 <roconnor> chessguy: that case comparisonFunction a b of Lt -> Gt; Eq -> Eq; Gt -> Lt === comparisonFunction b a
04:31:29 <dcoutts_> Igloo: to you get my pm's from this nick?
04:32:03 <roconnor> chessguy: which is implied by comparisonFunction being reflexive, anti-symetric, and transitive.
04:32:19 <roconnor> er
04:32:25 <roconnor> I guess I just need anti-symetric
04:32:38 <roconnor> what I wrote is basically the definiton of that property.
04:32:42 <chessguy> ok
04:32:46 <dcoutts_> Igloo: the stuff you're printing now is coming out ok
04:32:51 <chessguy> i should be ok then
04:33:05 <chessguy> thanks
04:33:06 <Igloo> dcoutts_: Yup, thanks
04:33:29 * dcoutts_ :: Coffee -> IO (Code, [Faff])
04:33:51 <MyCatVerbs> roconnor: which is, like, the *definition* of a comparison function... >>
04:34:44 <MyCatVerbs> roconnor: if somebody writer a function (a b -> Ordering) and it doesn't satisfy those properties then the results are their own damn problem. :P
04:34:53 <roconnor> MyCatVerbs: yep, but people use nubBy for things that are equivalence relations, who knows what they are doing with sortBy ;)
04:35:10 <roconnor> er
04:35:18 <roconnor> things that aren't equivalence relations.
04:35:42 <MyCatVerbs> roconnor: my brain just exploded. WHY, GODS, WHY!?
04:36:03 <MyCatVerbs> roconnor: wait, I'm an aetheist. WHY, INVISIBLE PURPLE UNICORN AND/OR RUSSEL'S TEAPOT, WHY?
04:36:13 <fasta> With: liftM (map newtypewrapper) $ <function_with_unsafeInterleaveST_before_every_forcing_of_data_structure>, it this complete expression also lazy?
04:36:23 <roconnor> > nubBy(((>1).).gcd)[2..]
04:36:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:36:25 <fasta> is*
04:36:28 <roconnor> MyCatVerbs: that's why.
04:36:59 <fasta> MyCatVerbs: it's PINK!
04:37:08 <MyCatVerbs> roconnor: oh my, that is clever. Okay.
04:37:23 <roconnor> MyCatVerbs: I don't know how I feel about it.
04:37:32 <MyCatVerbs> Why the brackets around ((>1).)?
04:37:42 <takamura> hey
04:37:45 <roconnor> > nubBy((>1)..gcd)[2..]
04:37:45 <lambdabot>  Parse error
04:37:52 <fasta> MyCatVerbs: shall we now rage war? All the other religions do it too.
04:38:04 <dons> ?users
04:38:04 <lambdabot> Maximum users seen in #haskell: 392, currently: 372 (94.9%), active: 20 (5.4%)
04:38:17 <chessguy> @uptime
04:38:17 <lambdabot> uptime: 4d 11h 7m 57s, longest uptime: 1m 10d 23h 44m 29s
04:38:33 <MyCatVerbs> > nubBy ((>1).gcd) [2..]
04:38:34 <lambdabot>  Couldn't match expected type `a -> Bool'
04:38:40 <fasta> dons: any idea on my question?
04:38:40 <MyCatVerbs> Ah, oopsie.
04:39:00 <dons> fasta: it should be.
04:39:07 <EvilTerran> is that not an equivalence relation, anyway?
04:39:12 <dons> though there's some subteties with newtypes
04:39:18 <dons> check the core
04:39:23 <MyCatVerbs> fasta: depends on whether or not you would consider my postulation of a Sort Of Mauve-Ish Horse heretical or not.
04:39:24 <EvilTerran> the relation "not relatively prime"
04:39:58 <roconnor> MyCatVerbs: ah right, the problem is that gcd is a binary function, so compose doesn't work the way you expect.
04:40:17 <roconnor> > nubBy(curry ((>1).(uncurry gcd)))[2..]
04:40:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:41:13 <MyCatVerbs> roconnor: jah, I have real trouble reading code with compositions of functions with any arity other than /1.
04:41:41 <roconnor> MyCatVerbs: me too.  The code (that I didn't write) only looks that way because it is attempting to be short rather than clear.
04:42:03 <MyCatVerbs> Ah, right. Gratituously points-free, so to speak?
04:42:24 <fasta> dons: my profile looks like a rainbow however :)
04:42:27 <roconnor> although I'm slowly getting use to the  ((x.).y) pattern.
04:42:40 <roconnor> however like all stupid patterns, it is better to abstract it.
04:42:44 <MyCatVerbs> roconnor: what does it mean, though? I just can't parse that.
04:42:54 <chessguy> @unpl ((>1).).gcd
04:42:55 <lambdabot> (\ e h -> (gcd e h) > 1)
04:42:56 <fasta> MyCatVerbs: pass two args to y, apply x
04:43:00 <roconnor> @type \x y -> ((x.).y)
04:43:01 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
04:43:06 <drigz> it would be nice if you could define f .. g
04:43:19 <fasta> drigz: all the cool kids use .:
04:43:26 <drigz> really?
04:43:27 <MyCatVerbs> drigz: never mind the parser, it'd break the lexer.
04:43:31 <fasta> drigz: and .:.
04:43:35 <fasta> drigz: and .::
04:43:39 <EvilTerran> @let (f .: g) x y = f (g x y)
04:43:40 <lambdabot> Defined.
04:43:52 <roconnor> let f (.:) g = \x y -> f (g x y) in  nubBy((>1).:gcd)[2..]
04:43:54 <MyCatVerbs> You'd have to introduce context to avoid conflicting with [a..b]
04:43:55 <roconnor> > let f (.:) g = \x y -> f (g x y) in  nubBy((>1).:gcd)[2..]
04:43:56 <lambdabot>      Occurs check: cannot construct the infinite type:
04:43:56 <lambdabot>       t = (t1 -> t2 ->...
04:44:00 <fasta> drigz: you can play Tetris if you continue long enough. ;)
04:44:05 <EvilTerran> > nubBy ((>1) .: gcd) [2..]
04:44:05 <drigz> :D
04:44:06 <roconnor> oops
04:44:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:44:19 <drigz> i'm happy now
04:44:30 <fasta> xerox posted a compose type class which automatically does this.
04:44:46 <fasta> You could define (.) to be compose and then you could use . everywhere.
04:44:49 <evir> fasta: How do you get the Z shaped TEtris brick? ;-)
04:44:52 <EvilTerran> it sounds like something that might be possible with Applicative
04:44:59 <roconnor> .: is moderately standard notation for that; however I sometimes use it for a contraction operation, so I find it a bit confusing.
04:45:25 <roconnor> fasta: cool.
04:45:44 <roconnor> fasta: although it sounds a bit impossible.
04:45:49 <fasta> roconnor: yes, but I decided not to use it.
04:46:13 <EvilTerran> sounds like death-by-overlapping-instances
04:46:19 <fasta> roconnor: I need to take into account compilation times
04:46:28 <chessguy> @src Monad
04:46:28 <lambdabot> class  Monad m  where
04:46:28 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:46:28 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:46:28 <lambdabot>     return      :: a -> m a
04:46:28 <lambdabot>     fail        :: String -> m a
04:46:45 <fasta> roconnor: and annoying the type inferencer for every use of . is a bit slow, I think.
04:46:55 <fasta> roconnor: it also makes type error harder to read
04:47:02 <chessguy> so if i want to do class Foo m b p where..., does that requires extensions?
04:47:06 <fasta> errors*
04:47:10 <fasta> chessguy: MPTCs
04:47:19 <fasta> chessguy: and probably fundeps
04:47:32 <chessguy> why fundeps?
04:47:34 <fasta> chessguy: since, you don't want to specify lots of type annotations
04:48:07 <fasta> I don't think I ever used MTPCs without fundeps.
04:49:09 <chessguy> is such stuff evil?
04:49:36 <Saizan> it mostly depends on your class
04:50:24 <Saizan> these extensions are used in the mtl, for example
04:50:37 <Saizan> ?src MonadState
04:50:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:50:52 <Saizan> class MonadState s m | m -> s where
04:50:58 <fasta> chessguy: I think fundeps are great.
04:51:18 <fasta> chessguy: but be very careful when defining one
04:51:25 <chessguy> how so?
04:51:42 <fasta> chessguy: if you don't use them as intended, type error messages are not very clear.
04:52:06 <chessguy> ah, i see
04:52:37 <chessguy> ok, thanks
04:53:13 * chessguy heads off to the real world and banishes his creativity back to its corner
04:53:27 <fasta> Hmm, I think I understand the local variables are evil opinion.
04:54:07 <Saizan> mutable ones?
04:54:08 <roconnor> local variables?
04:54:39 <fasta> Saizan: not even mutable
04:54:54 <fasta> Saizan: variables you name, but only use once for example
04:55:12 <roconnor> fasta: like things in let and where clauses?
04:55:25 <fasta> roconnor: yes, or in do blocks
04:55:33 <roconnor> they are evil?
04:56:09 <roconnor> that's pretty low on my list of evil things. ... usually I consider them good things.
04:56:43 <fasta> roconnor: oh, yes, it's pretty low on my list too.
04:57:18 <roconnor> they are a bit more evil in do blocks because they can be shadowed by later let expressions, but that is hardly a problem in practice.
04:57:54 <Saizan> why are they evil? when composition gets ugly naming a few things helps
04:57:55 <roconnor> fasta: so, tell us, how are they evil?
04:59:38 <fasta> roconnor: they are an extra indirection and you need to be careful that you don't mix for example a with a', where a is only used once.
05:00:08 <fasta> Not a terribly strong argument, I know.
05:01:39 <fasta> Are there some general things one can do to reduce allocation?
05:02:22 <fasta> I could reuse all my data structures, but that would require quite a bit of work.
05:02:30 <MyCatVerbs> roconnor: ((>1).).gcd) still hurts my head, but I think I have it roughly figured out now.
05:02:51 <roconnor> MyCatVerbs: I don't even try to figure it out.
05:03:10 <fasta> MyCatVerbs: you just need that read that as fill in the arguments of gcd and then decide whether it's larger than one
05:03:12 <roconnor> I just look at the output of @type and accept what it does :P
05:03:33 <fasta> MyCatVerbs: don't try to bend the spoon ...
05:03:41 <Saizan> MyCatVerbs: manually inline (.)
05:03:49 <roconnor> @quote spoon
05:03:49 <lambdabot> shapr says: I don't know why the GHC team won't accept my spoonIO patch
05:03:51 <MyCatVerbs> roconnor: but how're you ever going to try to reproduce such arcane feats if you don't force yourself to understand them? :)
05:03:57 <mux> I find point-free style to be usually unreadable when the number of parameters exceed 1
05:04:09 <roconnor> MyCatVerbs: I try not to produce arcane anything.
05:04:45 <ricky_clarkson> MyCatVerbs: What does ((>1).).gcd do?  It appears to be an equals test.
05:05:04 <mux> it's the same as \x y -> gcd x y > 1
05:05:13 <EvilTerran> ((>1).).gcd) x y = (((>1).).gcd) x) y = (((>1).) (gcd x)) y = ((>1) . (gcd x)) y = (>1) ((gcd x) y) =  = ((gcd x y) > 1
05:05:34 <ricky_clarkson> ah, ok.
05:05:42 <ricky_clarkson> Can every lambda expression be made pointfree?
05:05:47 <EvilTerran> ignore that extra (=) at the end
05:05:52 <EvilTerran> yup.
05:06:16 <MyCatVerbs> EvilTerran: AHHHHHHHH MY EYEBALLS
05:06:24 <MyCatVerbs> EvilTerran: oh wait, thanks.
05:06:34 <roconnor> ricky_clarkson: yes, a famous theory by whosits
05:06:44 <EvilTerran> \o/ ... :)?
05:06:45 <roconnor> @pl (\x y -> gcd x y > 1)
05:06:46 <lambdabot> flip flip 1 . ((>) .) . gcd
05:06:53 <ricky_clarkson> Hehe.
05:06:54 <MyCatVerbs> ricky_clarkson: checks if two numbers are coprime.
05:07:01 <ricky_clarkson> @pl \a b c -> (-b+sqrt(b*b-4*a*c))/(2*a)
05:07:02 <EvilTerran> flip flip! :D
05:07:02 <lambdabot> ap (flip . ((flip . (((/) . negate) .)) .) . liftM2 (.) (+) . ((sqrt .) .) . flip ((.) . (-) . join (*)) . (*) . (4 *)) (2 *)
05:07:28 <EvilTerran> @src liftM2
05:07:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:07:42 <EvilTerran> @. pl undo \f m1 m2 -> do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:07:43 <lambdabot> liftM2
05:07:46 <EvilTerran> hmph.
05:07:48 <MyCatVerbs> I, for one, am getting the impression that mayyyybe points-free style isn't actually all that useful. *glances at \bot's output)
05:07:56 <MyCatVerbs> s/)/*/
05:08:05 <roconnor> ricky_clarkson: well, assuming you have enough basic combinators
05:08:15 <Saizan> i'm starting to hate code written in pointful stile
05:08:27 <mux> MyCatVerbs: it's sometimes amazingly beautiful
05:08:28 <MyCatVerbs> Saizan: was that deliberate?
05:08:31 <roconnor> ricky_clarkson: you can get away with 1 combinator with the right one, (such as the X combinator)
05:08:32 <mux> but it should not be abused
05:09:07 <roconnor> MyCatVerbs: when pointless code involves join, it a sign that things have probably gone too far.
05:09:19 <fasta> I use combinators more and more.
05:09:20 <Saizan> MyCatVerbs: no, i really feel the urge to rewrite it using combinators when it's not that ugly
05:09:24 <roconnor> MyCatVerbs: flip flip is also a bad sign aparently.
05:09:27 <MyCatVerbs> mux: sure, occasionally it just happens by sheer accident to be amazingly terse, concise, and exactly convey the programmer's intentions.
05:09:46 <fasta> E.g. I defined one for lists that deconstruct a list like maybe does for Maybe
05:10:04 <roconnor> @type maybe
05:10:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:10:16 <roconnor> fasta: isn't that just fold?
05:10:25 <mux> it's a catamorphism :-)
05:10:35 <Saizan> no he means non-recursively
05:10:43 <mux> ah
05:10:44 <MyCatVerbs> mux: but that doesn't excuse using it under any *other* circumstance. I mean, yes, people might want to know it's *there*, so that they can take advantage of it in those tiny handful of situations to be able to express themselves as fully as possible, but I don't see any reason to ever *encourage* someone to use it. x_x
05:10:47 <Saizan> it's useful, i've written it too
05:10:58 <mux> MyCatVerbs: I agree
05:11:00 <dozer> if I've done a build/install in one project, do I have to build from clean in another one that uses it to pull in the newest version?
05:11:01 <fasta> Saizan: how's yours named?
05:11:03 <roconnor> MyCatVerbs: agree
05:11:35 <MyCatVerbs> w00t, out of the six billion people on the planet, at least two don't think I'm crazy. This is an all-new record high for me.
05:12:59 <ricky_clarkson> MyCatVerbs: I expect that being able to, painstakingly, understand all the flip flip ap stuff, might make the simpler cases trivially readable and hence useful.
05:13:00 <Saizan> fasta: heh, that's the hard part, "withDefault"
05:14:05 <MyCatVerbs> ricky_clarkson: well, it beats playing chess at any rate.
05:14:43 <Saizan> ?type flip flip
05:14:45 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
05:15:11 <EvilTerran> @unpl flip flip
05:15:12 <lambdabot> (\ b c f -> c f b)
05:15:23 <Saizan> simpler than i thought
05:15:32 <ricky_clarkson> For me too.
05:16:04 <fasta> Aren't those called rotate in concatenative languages?
05:16:07 <fasta> Or rot?
05:16:11 <pjd> MyCatVerbs: i don't think such degenerate cases of point-free style should detract from all the great uses of it
05:16:14 <pjd> fasta: yeah
05:16:25 <ricky_clarkson> ?type (\ b c f -> c f b)
05:16:27 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t2) -> t1 -> t2
05:16:32 <fasta> pjd: cool, I learnt something during my ultra-short use of them :)
05:16:33 <balodja> @unpl flip (flip flip)
05:16:33 <lambdabot> (\ b c i -> b i c)
05:16:44 <pjd> @pl output is sometimes unreadable, but that has a lot to do with it "compiling" down to primitive combinators
05:16:44 <lambdabot> (line 1, column 31):
05:16:44 <lambdabot> unexpected ","
05:16:44 <lambdabot> expecting variable, "(", operator or end of input
05:16:46 <mux> what is good with point-free style is that it makes people concentrate on the function-level rather than at the data-level
05:16:54 <ari> :t flip (flip flip)
05:16:56 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
05:17:14 <pjd> fasta: to be perfectly accurate, that's -rot, i think
05:17:45 <pjd> mux: indeed;  shades of FP
05:17:53 <pjd> (Backus's FP)
05:18:03 <mux> yea
05:18:57 <Saizan> we should just have a good name for some of the combinatins
05:20:13 <pjd> Saizan: exactly
05:20:22 <mux> it's hard to figure out good names for combinators
05:20:53 <Jaak> it pisses me off when people use blogs that require you to register to post a comment... fuck them i say... http://hpaste.org/2493
05:20:57 * pjd like (...) = (.).(.), (....) = (.).(.).(.), etc.
05:21:03 <pjd> "likes", even
05:21:31 <pjd> that's like (.), except the rightmost function takes 2, 3, ... arguments instead of 1
05:21:48 <MyCatVerbs> pjd: (.).(.).(.) <-- the triple-breasted whore of Eroticon VI?
05:21:52 <mux> if we use that, code will resemble morse code
05:21:56 <mux> heh
05:21:57 <MyCatVerbs> (Or was it IV, I can't remember?)
05:22:01 <mux> IV
05:22:06 <mux> I think
05:22:28 <ricky_clarkson> Yes, make flip into -
05:22:41 <mux> ... --- ...
05:22:57 <MyCatVerbs> Ah, danke. The only problem I have with IV is that it rhymes, which is just... irreverant. I'm sure even the triple-breasted whore deserves more alomb and dignity than that.
05:23:04 <pjd> MyCatVerbs: it would be nicer to start with (..), but that's a syntax error
05:25:48 <ricky_clarkson> Hmm, can't quite manage it.
05:26:05 <ricky_clarkson> :t (.) (.) (.) (-) (-) (-) (.) (.)
05:26:08 <lambdabot> forall c. (Num ((c -> c) -> (c -> c) -> c -> c), Num (c -> c)) => (c -> c) -> (c -> c) -> c -> c
05:26:21 <ricky_clarkson> One more (.) and it's an infinite type error.
05:26:43 <EvilTerran> hence it being a distress call, i guess :D
05:27:05 <roconnor> Jaak: I agree
05:27:36 <roconnor> Jaak: for such haskell blogs I find the reddit post and place my comments there in protest.
05:27:56 <roconnor> ... although now that I think about it I guess I had to register to post reddit comments.
05:28:11 <Jaak> :)
05:28:22 <roconnor> still.
05:29:20 <ricky_clarkson> But you trust reddit more than the random blog site owner.
05:30:21 <roconnor> ricky_clarkson: for me it isn't a matter of trust.  Rather I'm not going to register at every single blog provider in the world.
05:31:03 <roconnor> as a further self contradiction I don't even allow comments on my blog.
05:31:18 <roconnor> comments are mostly useless crap
05:31:32 <roconnor> (except for my comments of course ;)
05:32:13 <ricky_clarkson> That makes the blogging software easy to write.
05:32:27 <dmead_> isn't trusting reddit the same as saying you trust a random blog site owner?
05:32:31 <roconnor> ricky_clarkson: oh yes
05:33:03 <roconnor> ricky_clarkson: To componsate for lack of comments I scrap my referrer logs looking for interesting responses, and will link back to them.
05:33:26 <ricky_clarkson> I use Google Alerts for that.
05:33:44 <roconnor> I guess a system that moderates comments would be acceptable.
05:35:05 <hpaste>  chessguy pasted "Does something like this need fundeps?" at http://hpaste.org/2494
05:36:43 <chessguy> that's a (partial) generalized typeclass for a boardgame, if you couldn't tell
05:38:02 <mux> I think you need fundeps here indeed
05:38:08 <chessguy> why?
05:38:14 <mux> to tell the compiler that it can deduce the type 'm' from the type 'p'
05:38:20 <mux> otherwise it doesn't know what type 'm' is
05:38:20 <scook0> I suppose if you had multiple instances for a single p, those operations that don't mention m would be ambiguous
05:38:26 <mux> you can also use an associated type with GHC HEAD
05:38:49 <chessguy> what if it can't deduce the type m from p?
05:39:25 <chessguy> i.e., i don't want the definition of m to be dependent on the definition of p
05:39:52 <scook0> you want the possibility of different ms for a single p?
05:39:54 <mux> why would you want that?
05:39:57 <chessguy> yes
05:40:01 <mux> you have newtype's for that purpose
05:40:15 <mux> so you can have several instances for the same type in the end, wrapped with a newtype
05:40:28 <chessguy> huh?
05:40:36 <mux> I personally find that associated types would fit particularly well for that example
05:40:46 <chessguy> i don't get how newtypes would help
05:40:59 <mux> because you can make new types out of existing types with it
05:41:04 <scook0> instead of having multiple ms for a single p
05:41:10 <scook0> you artificially create new ps
05:41:14 <mux> yes
05:41:19 <scook0> each of which has a single m
05:41:34 <chessguy> i'm not getting it
05:41:50 <chessguy> suppose i wanted to be able to represent m using either Int or (Int, Int)
05:42:30 <chessguy> (Int could have different bitfields for source and target squares, e.g.)
05:43:09 <chessguy> you're saying i could do newtype Move = Int, or newtype Move = (Int, Int)?
05:43:21 <scook0> newtype NewP = MkNewP OldP
05:43:35 <scook0> instance Position OldP Int where...
05:43:42 <scook0> instance Position NewP (Int, Int) where...
05:44:03 <scook0> this does mean you have to do the wrapping/unwrapping yourself, which might not be what you want
05:45:19 <chessguy> but what if i want to be able to have OldP (Int, Int)?
05:45:51 <scook0> suppose you call (dynamic x) ... which instance's dictionary should be used?
05:46:07 <chessguy> see, how i represent the board shouldn't necessarily dictate which move representation i use
05:46:21 <scook0> maybe you need to split the typeclass
05:46:25 <mux> but somehow you need to chose some move type at some point
05:46:28 <mux> or rather, the compiler needs to
05:46:37 <scook0> into those parts that use m, and those that don't
05:48:09 <hpaste>  scook0 annotated "Does something like this need fundeps?" with "splitting the class?" at http://hpaste.org/2494#a1
05:51:30 <chessguy> hmm
05:51:34 <chessguy> what's a PositionMove
05:52:25 <scook0> it's a relation on position types and move types
05:52:53 <scook0> saying "this position type can have its moves represented by this move type, possibly among others"
05:53:00 <scook0> (I had to make up some name for it)
05:53:04 <chessguy> so i would do instance PositionMove BoardType MoveType?
05:53:24 <scook0> yeah
05:53:46 <chessguy> that might make sense
05:54:02 <scook0> hopefully ... I haven't tried it, so be warned :)
05:54:03 <chessguy> i guess i don't really see how it's different though
05:54:31 <chessguy> i mean i could do instance Position PositionType MoveType in my original class too
05:55:05 <scook0> but there would be ambiguities
05:55:39 <chessguy> how?
05:55:45 <scook0> because whenever you apply a Position function, the compiler needs to supply an appropriate dictionary for (p, m)
05:55:54 <scook0> but some of those functions don't mention m at all
05:56:10 <scook0> so which dictionary should it pass?
05:57:12 <scook0> (it might be possible to hack around this by making the functions identical, and using incoherent instances to shut the compiler up, but that would be nasty)
05:57:20 <chessguy> ok
05:57:24 <chessguy> i think i get it
05:57:47 <scook0> you have some operations that are uniquely determined by the choice of p
05:57:59 <scook0> and others that are uniquely determined by the choice of (p, m)
05:58:20 <scook0> so that's the basis of my splitting them into two classes
05:59:20 <scook0> (and this is assuming I've understood your intentions correctly)
06:00:29 <chessguy> i think so
06:00:38 <chessguy> you've probably understood my intentions better than me :)
06:00:42 <fasta> chessguy: looks like you need fundeps ;)
06:01:13 <chessguy> fasta, what's wrong with scook's version?
06:01:17 <fasta> chessguy: (I didn't read your problem fully)
06:01:24 <fasta> chessguy: probably nothing, see above comment :)
06:01:36 <chessguy> oooook
06:04:54 <Saizan> i think everyone should learn how to transform a relation into BCNF before starting to use MPTC/fundeps :)
06:06:14 <hpaste>  chessguy annotated "Does something like this need fundeps?" with "taking the idea even further..." at http://hpaste.org/2494#a2
06:06:20 <chessguy> scook0 what about this?
06:06:36 <chessguy> Saizan, what do you mean?
06:07:22 <fasta> Saizan: can you do that by heart?
06:08:14 <Saizan> fasta: yes, but only because it was in my database course last semester :)
06:08:29 <fasta> Saizan: heh, at that time I was able to do so too.
06:08:57 <chessguy> man, i had that in a database class too, but that was several years ago
06:09:06 <chessguy> and i have no idea how it relates to this
06:09:09 <chessguy> (pardon the pun)
06:09:24 <scook0> chessguy: your addition seems to make sense
06:09:53 <Saizan> well fundeps work in the same way, and a MPTC is a relation
06:09:59 <scook0> multiparameter typeclasses are relations
06:10:05 <chessguy> hmmm
06:10:19 <scook0> so an understanding of relational database theory certainly helps
06:10:32 <Saizan> for a method to make sense it has to metion at least a key in its types
06:11:04 <Saizan> however they say this should get easier with associated types
06:11:25 <scook0> actually, having the Move class might make it possible to write useful functions that are polymorphic in PositionMove
06:11:50 <SamB_XP_> though, like in SQL, a key can consist of multiple variables...
06:11:53 <chessguy> scook0, that's the idea :)
06:12:09 <chessguy> ok, back to the real world
06:12:14 <chessguy> scook0++ thanks
06:13:13 <scook0> composite keys are important to MPTCs with weak or no fundeps
06:14:13 <scook0> and fixing chessguy's issue was essentially an exercise in database normalization ;)
06:17:15 <SamB_XP_> yay db normalization in Haskell ;-)
06:17:33 <SamB_XP_> don't you just love relational programming?
06:19:09 <taruti> type level functions would be so much cuter
06:20:52 <nominolo> @djinn Int -> (String -> Maybe a) -> Either String a
06:20:52 <lambdabot> -- f cannot be realized.
06:21:27 <EvilTerran> o.O?
06:21:40 <nominolo> @djinn Int -> (String -> Maybe a) -> String -> Either String a
06:21:40 <lambdabot> f _ a b =
06:21:40 <lambdabot>     case a b of
06:21:40 <lambdabot>     Nothing -> Left b
06:21:40 <lambdabot>     Just c -> Right c
06:24:13 <wolverian> the new happs looks cool
06:24:24 <nominolo> @where happs
06:24:24 <lambdabot> http://happs.org
06:24:58 <wolverian> note the small "pre-releasing" text :)
06:30:07 <nominolo> more documentation would be nice, but looks cool
06:30:18 <wolverian> well, yes
06:55:33 <cognominal_> in the ghc users guide, they talk of modules in a target set. what does target mean?
07:11:42 <hpaste>  Japsu pasted "(still somewhat limited) discrete convolution with arrows!" at http://hpaste.org/2495
07:12:56 <hpaste>  Japsu annotated "(still somewhat limited) discrete convolution with arrows!" with "I've never done haddock before, as you can see" at http://hpaste.org/2495#a1
07:14:21 <bringert> dons: I had to hack hs-plugins to be able to use loadFunction with ghc 6.6, the darcs version doesn't seem to prepend the package name to the symbol name
07:14:36 <bringert> dons: but after that it worked
07:15:28 <bringert> (I'm on i386-darwin btw, which isn't mentioned in the README)
07:16:14 <dozer> @pf f (g a b c d)
07:16:15 <lambdabot> Maybe you meant: bf pl
07:16:29 <dozer> @pl f (g a b c d)
07:16:29 <lambdabot> f (g a b c d)
07:18:57 <dozer> @unpl f (g a b c d)
07:18:57 <lambdabot> f (g a b c d)
07:19:23 <dozer> @pl \a b c d -> f (g a b c d)
07:19:24 <lambdabot> (((f .) .) .) . g
07:20:18 <dozer> mm - perhaps $ is cleaner in this case
07:21:37 <Japsu> Any ideas how I could get rid of the limitation mentioned in haddock of conv in http://hpaste.org/2495#a1 ?
07:21:55 <Japsu> Hmm well
07:22:15 <Japsu> There's no meaningful way of distinguishing between finite and infinite lists!
07:23:46 <bringert> Heffalump: I got the HaskellDB testuite running, by hacking hs-plugins
07:23:58 <sjanssen> Japsu: you might define "data Stream a = Cons a (Stream a) | Nil"
07:24:10 <sjanssen> there's a stream package on hackage IIRC
07:25:08 <bringert> noone seems to have touched the hs-plugins darcs repo since March, and my patch was needed to get it to work with GHC 6.6. does anyone know what the status of hs-plugins GHC 6.6 is supposed to be?
07:25:10 <Japsu> Yeah, I might do that for a stream type if I actually were to use this in a real application... But now I'm only interested in the convolution, which has been bugging me for months
07:25:21 <Japsu> But hmm.
07:25:21 <mrd> bringert: i'm using it with 6.6
07:25:43 <Japsu> If I do x ++ y where x is infinite, am I screwed?
07:25:48 <sorear> no
07:25:52 <mrd> I was under the impression that Lemmih fixed it with 6.6
07:25:53 <bringert> mrd: correction: the fix is required to be able to load functions from package modules with GHC 6.6
07:25:55 <sorear> you just get an infinite list
07:26:02 <mrd> hm
07:26:04 <Japsu> > let ones = 1 : ones in take 10 $ ones ++ ones
07:26:04 <sorear> > [1..] ++ [0,0..]
07:26:04 <bringert> mrd: that was a correction for me btw
07:26:09 <Japsu> errrrrr
07:26:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
07:26:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:26:17 <Japsu> oh
07:26:18 <Japsu> right
07:26:22 <bringert> mrd: it didn't prepend the package name to symbols in loadFunction_
07:26:23 <mrd> ok, i've only used load and makeAll
07:26:33 <Japsu> mistook sorear's command for lambdabot's output... must be getting tired
07:26:34 <sorear> @localtime dons
07:26:36 <lambdabot> Local time for dons is Thu Aug 30 00:25:29 2007
07:26:37 <Japsu> so
07:26:43 <Japsu> I can just pad x to the correct length
07:26:44 <EvilTerran> Japsu, is the only requirement that the second list must be strictly longer than the first?
07:26:51 <Japsu> EvilTerran: no
07:26:55 <Japsu> the second list can be shorter
07:27:24 <EvilTerran> ...but padded with 0s to (length x) + (length h) + 1
07:27:25 <EvilTerran> ?
07:27:55 <Japsu> let's put it this way. let x and h be signals with m and n meaningful values respectively
07:28:03 <Japsu> then the convolution x*h has n+m-1 meaningful values
07:28:33 <Japsu> gah
07:28:41 <Japsu> now I'm mixing h and x and confusing myself
07:29:07 <phobes> sorear:  If you do x ++ y, where x is infinite, do you just get back x?
07:29:12 <Japsu> let's put it this way. let h and x be signals with n and m meaningful values respectively. then the convolution h*x has n+m-1 meaningful values
07:29:13 <sorear> yes.
07:29:14 <oerjan> to avoid calculating length, zipWith const (x++padding) (replicate desired_length whatever) can be used
07:29:15 <phobes> or is there some way to tell them apart?
07:29:24 <olsner> > 40+85+280+260+300+60
07:29:25 <lambdabot>  1025
07:30:06 <oerjan> phobes: i don't think so
07:30:20 <Japsu> oerjan: cool, thanks
07:30:23 <phobes> oerjan: ok... seems like you wouldn't be able to
07:30:42 <oerjan> Japsu: although they may also truncate, if that is a problem
07:30:46 <oerjan> *that
07:31:15 <Japsu> the problem is that for signals h and x with n and m meaningful values, h*x gets truncated to m values
07:31:19 <Japsu> it should be n+m-1
07:31:32 <Japsu> but it can be fixed by internally padding x with n-1 zeroes
07:31:49 <Japsu> h is required to be finite anyway, so no problem with computing its length
07:33:12 <oerjan> well if h has length n, then drop 1 (map (const 0 h)) gives you the padding
07:33:20 <byorgey> [insert time-zone appropriate greeting here], #haskell! =)
07:33:36 <oerjan> er, map (const 0) h
07:34:14 <Japsu> oerjan: yeah
07:34:26 <Japsu> I just figured the map (const 0) h thingy out myself, too
07:34:31 <Japsu> but thanks
07:34:37 <Japsu> now I'll manage to fix it \o/
07:34:38 <Japsu> finally
07:36:36 <dmead_> > 1.5*100 = 149.9999
07:36:36 <lambdabot>  Parse error
07:36:49 <dmead_> > (1.5 * 100.00) = 149.9999
07:36:50 <lambdabot>  Parse error
07:36:50 <Japsu> YAY
07:36:51 <Japsu> works
07:36:52 <Japsu> \o/
07:36:54 <dmead_> > (1.5 * 100.00) == 149.9999
07:36:55 <Japsu> \\o \o/ o//
07:36:56 <lambdabot>  False
07:38:05 <oerjan> > 1.5 * 100 == 150
07:38:06 <lambdabot>  True
07:39:17 <oerjan> the denominators are small powers of 2, so the floating point is exact
07:39:47 <ari> > (1%3) == toRational (1/3)
07:39:48 <lambdabot>  False
07:40:41 <wli> One could always use radix 223092870
07:41:24 <ari> > (1%3) == approxRational (1/3) 0.000001
07:41:25 <lambdabot>  True
07:41:36 <hpaste>  Japsu annotated "(still somewhat limited) discrete convolution with arrows!" with "FIXED! \\o \o/ o//" at http://hpaste.org/2495#a2
07:44:02 <wli> Japsu: Hmm. Number-theoretic FFT could come in handy.
07:45:24 <wli> therp: You need to use atan2 to find theta.
07:45:49 <therp> wli: gorgeous that you look at hpaste and give me tips
07:46:01 <therp> wli: got the same hint from a friend of mine already thanks
07:46:13 <therp> wli: but we are not sure about the argument order.. atan(y/x) => atan2 y x?
07:46:23 <wli> atan2 y x IIRC yes
07:46:36 <therp> wli: but the program is broken with respect to the result being always theta of sc2. no idea way
07:46:38 <wli> therp: What are you trying to do with that?
07:47:27 <wli> therp: Parametrize the great circle arc?
07:47:30 <therp> wli: interpolate on the great circle connecting two points a,b on a sphere given in spherical coordinates with q=0 giving a and q=1 giving b
07:47:35 <therp> yes
07:47:56 <wli> Okay, first let's describe the great circle arc.
07:48:12 * therp listens closely
07:49:11 <wli> (r, phi, theta) and (r, phi', theta') and (0, 0, 0) are 3 points on the pertinent plane.
07:50:05 <therp> ack
07:51:07 <therp> actually my implementation seems to be correct
07:51:21 <wli> Except maybe the atan2 issue.
07:51:36 <therp> I was just confused why interpolateSC 0.000001 (PointSC 1 0 0) (PointSC 1 1 1) returns a PointSC with theta 1
07:52:26 <therp> until I recognized that theta is not determined uniquely at this phi point
07:52:29 <wli> There are ways to parametrize these things directly in polar coordinates.
07:53:04 <therp> wli: please go ahead. I scribbled ideas on a bunch of paper not leading to anything useful
07:53:04 <wli> I don't remember offhand how. I was trying to re-derive it.
07:53:33 <therp> btw. for all the others that might be listening, we are talking about http://hpaste.org/2496
07:53:53 <wli> You want to temporarily change coordinates so one of your points is at phi=0
07:54:08 <therp> yeah, but I wasn't able to achieve that.
07:54:30 <wli> Then the great circle arc is just theta = K for some constant, then rotate back.
07:54:47 <ari> gah
07:55:14 <ari> Does ghci have a configuration file where I can set -fno-monomorphism-restriction, or do I need to do it as a shell alias?
07:55:14 <wli> I think coordinate changes involving adding constants to theta and/or phi are the part needing to be worked out.
07:55:30 <wli> ari: ~/.ghci
07:55:42 <wli> ari: Put :set -fno-monomorphism-restriction in that.
07:55:44 <therp> hi hvr!
07:55:49 <ari> wli: Thanks :)
07:57:36 <wli> therp: Well, translations of theta don't affect phi at all.
07:57:53 <Japsu> wli: I implemented naive FFT in Haskell half a year ago. It's in hpaste somewhere. :)
07:58:35 <sior|sleep> Japsu: how was performance?
07:58:53 <Japsu> sior|sleep: didn't benchmark it, but my guess would be "abysmal". ^_____________^
07:59:13 <sioraiocht> that would make sense, heh
07:59:30 <Japsu> Dunno if my convolution's any good performance-wise either :)
08:00:01 <Japsu> I need to make up some real test cases for it.
08:00:07 <joelr1> good afternoon
08:00:10 <Japsu> Such as rolling my own MP3 encoder or something like that.
08:00:48 <Japsu> Though in the boring real world, convolution is implemented using FFT or Z transform... :<
08:00:59 <therp> wli: so the plan is, find a transformation that brings sc1 to phi=0 and then apply the same transformation to sc2. then interpolate the theta of sc1 and sc2, apply the inverse transformation to the result
08:01:02 <joelr1> what do you guys think of an idea of using the underlying darcs code to implement a distributed intellisense-type system? that is to use darcs functionality to compute the buffer delta and then ship just the delta to the remote server.
08:01:21 <wli> therp: Which is what you're doing already except you go through Cartesian coordinates.
08:01:36 <therp> wli: that's not that nice
08:01:53 <therp> I dislike the projection of the straight line
08:02:18 <therp> err, the projection of the point  on the straight line onto the sphere
08:02:50 <wli> therp: Well, it gets relatively hairy relatively quickly.
08:03:11 <therp> can't be, that looks like a simple question
08:05:48 <wli> therp: Well, translating phi changes theta around massively.
08:06:13 <wli> therp: Basically the task is to find the new theta given phi' = phi + phi_0
08:08:36 <Saizan> joelr1: roughly record and send?
08:08:54 <joelr1> Saizan: probably
08:09:00 <wli> But atan2 (sin(theta)*sin(phi+phi_0)) (cos(theta)*sin(phi+phi_0)) should just cancel the two factors.
08:09:24 <wli> therp: I think translating phi may have no effect on theta.
08:09:49 <wli> therp: Except maybe moving quadrants around in some cases.
08:12:47 <wli> therp: I think it has no effect on theta ever.
08:14:52 <wli> (phi, theta) and (phi', theta') get translated to (0, 0) and (phi' - phi, theta'), then the plane is theta = theta', then rotate it back and it's wrong.
08:15:24 <therp> sorry I'm a bit distracted
08:16:14 <phobes> What's the problem?
08:16:42 <wli> So next try is to go through Cartesian anyway. s*(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)) + t*(cos(theta')*sin(phi'), sin(theta')*sin(phi'), cos(phi')), now take the magnitude and it must be 1.
08:17:16 <roconnor> wow, I understand the difference between zippers and derivatives now!
08:17:20 <therp> phobes: http://hpaste.org/2496 - removing going throw the cartesian coordinate system
08:17:22 <wli> s*v_1+t*v_2, so s^2+t^2 + 2*s*t*<v_1, v_2>
08:20:34 <wli> Or s^2+t^2+2*s*t*cos(w) = 1; the quadratic form's matrix is [[1, cos(w)], [cos(w), 1]], which has eigenvalues 1+/-cos(w), who knows what eigenvectors.
08:22:30 <phobes> therp:  Do you not want interpolation to be based on arclength?
08:23:34 <therp> phobes: yes, I want to interpolate on the curve that connects these two points. that looks like my interpolation is based on the arclength
08:23:38 <wli> eigenvectors [1,1] for 1+cos(w) and [1,-1] for 1-cos(w)
08:24:06 <phobes> therp:  Your interpolation is based on euclidean distance, isn't it?
08:24:43 <therp> phobes: right, projecting the result back onto the sphere by just resetting r in the result.. (equations come from http://mathworld.wolfram.com/SphericalCoordinates.html)
08:24:44 <lambdabot> Title: Spherical Coordinates -- from Wolfram MathWorld
08:25:21 * roconnor reads back
08:25:43 <phobes> therp:  My point is that interpolation on the straight line followed by projecting back is not the same as interpolation based on arclength
08:26:02 <therp> phobes: ah now I got it. that's true
08:26:15 <therp> phobes: than my calculation is wrong anyway
08:26:24 <wli> I think s = (u+v)/sqrt(2), t = (u-v)/sqrt(2) will do.
08:26:30 <therp> I want to be based on the 'surface distance'/arclength
08:26:52 <phobes> ya
08:26:56 <therp> +it
08:27:08 <phobes> therp: Have you looked for slerp code online?
08:27:59 * therp asks google/wiki for slerp
08:28:36 <therp> the wiki page contains a lot of new terms for me.. quaternions..
08:29:03 <phobes> quanternion slerp is a little more general than what you want I think
08:29:22 <phobes> quaternions are used to encode frames of reference
08:29:33 <phobes> orthonormal coordinate systems
08:29:41 <wli> Okay, after that you get (1+cos(w))*(s')^2 + (1-cos(w))*(t')^2 = 1
08:30:23 * therp tries to catch up with wli's ideas
08:31:25 <phobes> I suppose you could always do a slerp and then discard the "twist" component
08:31:35 <phobes> I think that would produce the right answer
08:31:38 <wli> So let s' = cos(u)/sqrt(1+cos(w)), t' = sin(u)/sqrt(1-cos(w)) as per the standard parametrization of an ellipse.
08:33:07 * roconnor wonders what's going on.
08:34:15 * msouth doesn't know everything you are trying to do, but if you are doing a bunch of rotations in three dimensions you can get "gimbel lock", and quaternions can help
08:34:28 <msouth> a google on gimbel lock gives http://www.geocities.com/fragtheplanet/OpenGL/Camera.html
08:34:29 <lambdabot> Title: Camera
08:35:44 <wli> So back to old coordinates, you have (cos(u)/sqrt(2*(1+cos(w)))+sin(u)/sqrt(2*(1-cos(w))))*v_1 + (cos(u)/sqrt(2*(1+cos(w)))-sin(u)/sqrt(2*(1-cos(w))))*v_2 where v_1 is (cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)) and v_2 = (cos(theta')*sin(phi'), sin(theta')*sin(phi'), cos(phi') and cos(w) = <v_1, v_2>
08:36:07 <roconnor> slerp a b x = exp(x*(a `cross` b))<*>a
08:36:22 <wli> Now you can reparametrize that in terms of arc length the usual way.
08:36:39 <phobes> roconnor: Was that rodriguizes formula?
08:37:00 <twanvl> msouth: it might help if you search for gimbAl lock instead
08:37:05 <roconnor> phobes: I'd either have to look it up, or rederive it.
08:37:09 <therp> wli: I can't follow sorry
08:37:20 <roconnor> phobes: what's up with all the trig functions?  What's going on here?
08:37:25 <wli> therp: I found the plane through 0, v_1, and v_2 explicitly.
08:37:30 <msouth> you think the people that can spell it will give better information on it twanvl ? :)
08:37:36 <phobes> roconnor:  I'm not sure how rederiving it would answer whether it's rodriguizes' formula :)
08:37:45 <wli> therp: Then I used the constraint that the points lie on the surface of the sphere to eliminate one of the parameters.
08:37:53 <roconnor> phobes: oh you want to know it's semantics rather than it's formula?
08:38:04 <wli> therp: Any clearer?
08:38:22 <roconnor> phobes: ack sorry
08:38:28 <roconnor> phobes: I miss read your question.
08:38:45 <phobes> roconnor: no worries - I was just joking with my trite reply anway :)
08:38:46 <roconnor> phobes: if I recall, rodriguizes formula tell you how to compute exp(v).
08:38:49 <wli> therp: So now the Cartesian coordinates of the great circle arc are parameterized by u.
08:38:50 <therp> wli: no sorry.
08:39:01 <roconnor> phobes: what is going on here?
08:39:19 <wli> therp: It was all brute-force algebraic simplification. There was zero subtlety.
08:39:34 <phobes> roconnor: therp asked for help doing a spherical interpolation, wli is working out some math
08:39:54 <roconnor> phobes: spherical interpolation shouldn't involve any trig functions.
08:39:58 <wli> therp: If that doesn't help I don't know what will.
08:40:09 <phobes> roconnor: Note, therp seems interested in doing it quickly from spherical coordinate
08:40:17 <wli> roconnor: Really? I don't know how it works if so.
08:40:18 <phobes> that's where the trig is coming from
08:40:29 <therp> wli: I simply can't follow the mass of equations.
08:40:31 <roconnor> phobes: oh from spherical coordinates.
08:40:33 * msouth notes also that there are two arc lengths on the great circle for any pair of points (unless they are on exactly opposite sides)
08:40:52 <phobes> Ya, I think you might be better off converting to CC early though
08:41:05 <roconnor> phobes: ugh, spherical coordinates are terrible.
08:41:08 <phobes> One thing I would point out is that one of the theta coordinates can be assumed zero
08:41:13 <phobes> roconnor: I didn't pick them :)
08:41:33 <phobes> I got to this discussion late
08:41:34 <roconnor> phobes: has therp been advised not to use them?
08:41:52 <phobes> therp: spherical coordinates are terrible
08:41:55 <phobes> roconnor: yes
08:41:59 <roconnor> :)
08:42:09 <therp> phobes: but they seem to be more exciting :)
08:42:11 <wli> therp: Find the Cartesian coordinates, parametrize the plane, constrain the points on the plane to lie on the surface of the sphere, get an ellipse in the plane of the parameters from that constraint, parametrize the ellipse with a single parameter, go back to Cartesian coordinates.
08:42:35 * roconnor wonders how ellipses get involved.
08:42:38 <phobes> therp: in that case, have you considered storing them in an exotic floating point format as well?
08:43:00 <therp> phobes: no.
08:43:13 <phobes> :)
08:43:23 <wli> roconnor: It falls out of the equations for constraining the parameters of the plane through 0 and the two points on the sphere so their points lie on the surface of the sphere.
08:44:01 <wli> Go over /lastlog, I go through it all in slow motion.
08:44:10 * roconnor reviews
08:44:48 <phobes> wli: That's alot of trig
08:44:59 <phobes> wli:  I wonder if you'd not be better off converting to CC
08:45:03 <wli> Anyway, reparametrize that Cartesian curve in terms of arc length and then translate to spherical.
08:45:19 <wli> phobes: The end result hasn't been determined yet. It may yet work out to something simple.
08:45:52 <phobes> wli: ok, I thought you were done
08:45:58 <roconnor> wli: okay, sounds vagely plausable.  I'm impressed you've gone through so much effort :)
08:50:20 <wli> I'm running short on time. I have to stop.
08:51:28 <phobes> It looks like there would be a relatively easy way to do this by first adjusting the spherical coordinates of both to normalize one of the points to be the north pole
08:51:48 <phobes> Doing the interpolation in that frame is simple
08:51:55 <wli> That was my first suggestion. I couldn't work it out to be correct.
08:52:11 <phobes> hmm
08:52:36 <wli> Basically the before/after theta is something strange I couldn't work out.
08:53:00 <phobes> hmm ok let me write it down... getting paper
08:53:01 * therp just painted two points on his trackball to visualize the normalization trick
08:53:20 <roconnor> @remember therp but [spherical coordinates] seem to be more exciting :)
08:53:20 <lambdabot> Done.
08:53:57 <SamB> is C exciting too?
08:53:58 <wli> The idea that it should work out to be something simple after I do the massive calculations is based on the notion there's some way to make that work I just couldn't come up with.
08:54:54 <therp> hvr suggested to do two moves, 1. rotate in along the z axis so that the first point's theta becomes = 0 (lies in the x/z pane), giving (phi,  0), and (phi', theta'-theta), the second rotation would be moving the first point's phi to zero.
08:56:27 <wli> That might help with some of the theta transformation issues but they're far from settled.
08:57:53 <wli> The great circle in the normalized coordinate system is just the theta of the non-polar point in the normalized coordinates but it's not a constant theta in the back-translated coordinates.
08:58:12 <phobes> Ya, I don't see any simpler way to do that calculation other than converting it to CC and then back
08:59:08 <wli> And my massive calculations basically consist of trying to do that translation up-front so Cartesian coordinates aren't ever explicitly used.
08:59:30 <phobes> I don't think you want to do the lerp in CC
08:59:40 <phobes> well, it might not be that bad
09:00:01 <phobes> Anyway, I agree with roconnor that most of the ugliness here comes from spherical coordinates
09:00:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2497
09:02:24 * roconnor cheers on wli's massive effort \o| \o/ |o/
09:02:49 <phobes> hehe
09:04:56 <therp> http://www.uwgb.edu/dutchs/MATHALGO/sphere0.htm also converts to cartesian coordinates
09:04:57 <lambdabot> Title: Rotations on a Sphere
09:06:36 <roconnor> therp: btw, what are you doing that allows you to get away with using spherical coordinates?
09:07:06 <therp> roconnor: calculating from GPS positions
09:07:42 <roconnor> therp: what are you calculating?
09:08:05 <phobes> sounds like trajectories from (long, lat) to (long, lat)
09:08:58 <therp> roconnors: I'm aggregating information, given two points with weights w1 and w2, I want a point with weight w1+w2 half way (actually w2/(w1+w2) way) from point 1 to point 2.
09:09:03 <wli> AFAICT the arc length integral is elliptic.
09:09:51 <roconnor> therp: for what purpose?
09:10:44 <therp> roconnor: to find the best point for a central storage (logistics)
09:11:47 <roconnor> therp: is your range of concern world wide, or restricted to one continent?
09:12:02 <roconnor> (ie, does a and b lie on the same continent?)
09:12:32 <therp> roconnor: restricted to Austria, so many issues we are discussing here are negligible
09:12:48 <therp> solving this question is major overkill for this task, but it's interesting
09:13:26 <therp> solving it in a mathematical correct and interesting way (doing it solely with SC)
09:13:28 <roconnor> therp: sure, I understand.
09:13:38 <therp> maybe the only interesting thing about this job
09:14:07 <roconnor> your curves will be staying well away from the poles apparently.
09:14:12 <roconnor> that's good.
09:15:12 <roconnor> therp: how are you reading the GPS data?
09:15:26 <therp> roconnor: would it really be so troublesome (numerically) if I'm near the poles?
09:15:44 <therp> roconnor: I implemented Google geocoding querying from excel/visual basic
09:16:33 <roconnor> therp: spherical coordinates behave badly at the poles where there are ... well poles, or singularities.
09:16:55 <roconnor> therp: generally things become numerically unstable at poles.
09:17:12 <therp> hm ok
09:17:55 <wli> Okay, Maple says that the parametrization in terms of the parameter u I gave has ds/du = 1.
09:18:15 <roconnor> I suppose Google geocoding doesn't give you access to a point on the WGS84 ellipsoid model?
09:18:37 <therp> roconnor: not sure. it gives me GPS coordinates
09:18:41 <wli> So all that remains is to translate to spherical coordinates.
09:19:24 <roconnor> therp: GPS doesn't model the earth as a sphere.
09:19:36 <wli> It should be an oblate spheroid.
09:19:44 <wli> Which makes all this tremendously more complicated.
09:19:51 <norpan> ellipsoid
09:20:03 <therp> roconnor: presumably they I get the coordinates in the WGS84 ellipsoid model.
09:21:15 <norpan> doing such calculations is probably easier if converted to a planar model
09:21:20 <norpan> something like UTM
09:21:36 <wli> I'm surprised they use a mere ellipsoid.
09:21:57 <Ben`> @users
09:21:58 <lambdabot> Maximum users seen in #haskell: 392, currently: 380 (96.9%), active: 10 (2.6%)
09:22:17 <wli> I'd expect oblate spheroid if not some sort of spline surface modelling various irregularities.
09:22:51 <norpan> well
09:23:10 <norpan> ellipsoid + height corrections is common
09:23:37 <roconnor> therp: you should probably interpolate along the ellipsoid :P
09:24:02 <norpan> for the purpose mentioned here i don't think a few meters difference will matter much
09:24:26 <wli> Arc length along an ellipsoid is already an elliptic integral. I can talk you through how to find closed forms for such integrals.
09:25:59 * roconnor reads about ellipoid models
09:26:12 <roconnor> apparently it is hard for people to agree on where the centre of the earth is.
09:26:31 <norpan> that's why there are so many different earth ellipsoids
09:27:17 <roconnor> I can see the difficulty
09:27:23 <quicksilver> isn't it obvious?
09:27:31 <quicksilver> the centre of the earth is the fountain in great court trinity college
09:27:36 <quicksilver> I thought that was well understood :P
09:27:50 <roconnor> wow
09:28:17 <roconnor> that's much closer to the surface than I would have expected
09:28:34 <roconnor> unless the fountain is further underground than I imagine.
09:28:38 <therp> oh nice than I have been to the center of the earth this year :)
09:43:12 <wli> I've 23 minutes to prep for a dermatologist appointment and am supposed to have started work already. I can't put anything more toward this.
09:49:36 <shapr> d00d
09:50:43 <pgavin-work> @seen dcoutts
09:50:43 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 14h 48m 32s ago.
09:50:51 <dcoutts_> pgavin-work: hia
09:51:02 <pgavin-work> hey
09:51:02 <Lemmih> How do you prepare for an appointment with a dermatologist?
09:51:19 <pgavin-work> Lemmih, drink lots of whiskey
09:51:33 <pgavin-work> preferably a good canadian or maybe scotch
09:51:46 <shapr> I thought you'd apply something like whiskey to your skin.
09:51:51 <pgavin-work> dcoutts_, I think I'm gonna try cabalizing glib
09:52:03 <dcoutts_> pgavin-work: ooh, scary :-)
09:52:11 <dcoutts_> but a good test case of course
09:52:11 <pgavin-work> dcoutts, but there's one thing missing
09:52:18 <dcoutts_> pkg-config support?
09:52:25 <pgavin-work> no, that's pretty easy
09:52:35 <dcoutts_> yes, at least for a first hack
09:52:39 <pgavin-work> c2hs needs to have dependency support
09:52:42 <dcoutts_> right
09:52:50 <pgavin-work> I started working on that last night
09:52:56 <dcoutts_> so you see the script we use to extract deps ?
09:53:08 <dcoutts_> you'd need a Haskell version of that
09:53:11 <pgavin-work> right
09:53:47 <pgavin-work> but, I was thinking, since C2HS already parses everything, I'd just make a new program in the C2HS tree using the existing code
09:54:04 <dcoutts_> it basically looks for {#import#} hooks. Our script is a tad fragile to be honest since it does not lex.
09:54:31 <pgavin-work> right
09:54:42 <dcoutts_> pgavin-work: or add c2hs --something-or-other
09:54:57 <pgavin-work> yeah, I wasn't sure how well that would go over
09:55:00 <dcoutts_> pgavin-work: I'm not sure it's worth it, I'd start with just a simple translation of the script
09:55:13 <dcoutts_> we can make the parsing more robust later
09:55:16 <pgavin-work> ok
09:55:28 <pgavin-work> can cabal use regexps?
09:56:11 <ricky_clarkson> Someone named antoine posted to my blog, implying that it was possible to write "a function polymorphic on it's return value, whose behavior is determined by how the return value is used by the caller".  Can you give me a minimal example of that?
09:56:16 <dcoutts_> pgavin-work: I don't think it needs regexps, words would do as a lexer
09:56:45 <ddarius> ricky_clarkson: fromInteger
09:56:53 <Lemmih> ricky_clarkson: read
09:57:10 <phobes> roconnor:  spherical coordinates don't behave badly at the poles unless you need to invert them
09:57:11 <dcoutts_> pgavin-work: and I think we probably should avoid regexps, they're not core packages anymore
09:57:21 <pgavin-work> dcoutts_, ok, that's what I was wondering
09:57:38 <pgavin-work> words wouldn't work too well, though
09:57:48 <Lemmih> ricky_clarkson: Type-classes may be considered cheating.
09:58:03 <roconnor> phobes: oh
09:58:19 <roconnor> phobes: I guess you are right
09:58:24 <pgavin-work> I'll just write a quick parser looking for the {#hook#} tags, it won't be too hard
09:58:32 <phobes> roconnor:  You just start to have trouble resolving which theta you want - but that's ok because they're all becoming equivalent
09:58:42 <ricky_clarkson> I think I understand, but I can't seem to show it in ghci.
09:58:50 <ricky_clarkson> :t fromInteger :: Fractional
09:58:52 <lambdabot>     Class `Fractional' used as a type
09:58:52 <lambdabot>     In the type `Fractional'
09:59:03 <phobes> it's not like spherical projection where the north pole is a singularity of the map
09:59:03 <roconnor> phobes: no wait, the theta becomes more and more sensitive.
09:59:05 <ricky_clarkson> A useful error message.
09:59:15 <roconnor> phobes: sensitive things have bad numeric behaviour
09:59:21 <Japsu> :t const undefined
09:59:23 <lambdabot> forall a b. b -> a
09:59:26 <Japsu> :)
09:59:31 <desegnis> ricky_clarkson: fromInteger is a function, so:
09:59:33 <Saizan> ?type fromInteger
09:59:35 <lambdabot> forall a. (Num a) => Integer -> a
09:59:45 <Saizan> > fromInteger 1 :: Int
09:59:46 <lambdabot>  1
09:59:50 <desegnis> Saizan: thanks for continuing
09:59:53 <phobes> roconnor:  The map (theta, phi) -> (x,y,z) is uniformly continuous
09:59:55 <Saizan> > fromInteger 1 :: Double
09:59:56 <lambdabot>  1.0
10:00:05 <Saizan> desegnis: :)
10:00:40 <roconnor> phobes: yes, but operations (theta0, phi0) -> (theta1, phi1) can be hard to compute.
10:00:41 <phobes> roconnor:  The inverse of that map isn't, but that's not even such a problem because in cases where theta loses precision, it's precision doesn't matter
10:00:54 <roconnor> phobes: hmm
10:01:12 <roconnor> phobes: intresting point
10:01:22 <ricky_clarkson> Thanks guys.
10:01:50 <phobes> roconnor:  If you do the inverse map from (x,y,z) to (theta, phi), and then go back to (x,y,z), that should be stable
10:02:06 <dcoutts_> let tokens "" = []; tokens s = case lex s of {[] -> []; [(t,s')] -> t : tokens s'} in tokens "{#import Graphics.UI.Gtk.Types#}"
10:02:11 <dcoutts_> > let tokens "" = []; tokens s = case lex s of {[] -> []; [(t,s')] -> t : tokens s'} in tokens "{#import Graphics.UI.Gtk.Types#}"
10:02:12 <lambdabot>  ["{","#","import","Graphics",".","UI",".","Gtk",".","Types","#","}"]
10:02:14 <dcoutts_> pgavin-work: ^^
10:02:44 <pgavin-work> nice :)
10:03:00 <pgavin-work> @hoogle lex
10:03:02 <lambdabot> Prelude.lex :: ReadS String
10:03:02 <lambdabot> Text.Read.Lex.lex :: ReadP Lexeme
10:03:02 <lambdabot> Text.Read.Lex :: module
10:03:05 <pgavin-work> hmm
10:03:09 <dcoutts_> though technically {# is one token
10:03:10 <pgavin-work> didn't know about that one :)
10:03:18 <pgavin-work> right, but that's no big deal
10:03:21 <dcoutts_> aye
10:07:45 * shapr yawns
10:09:30 <laz0r> is it somehow possible to itereate over a nested list from inside to outside?
10:09:58 <Saizan> nested list?
10:10:23 <EvilTerran> something of type [[a]] or something?
10:11:04 <laz0r> nested lists, like [(1,[(2,[])])], for example
10:11:15 <EvilTerran> ... that's not a valid haskell value
10:11:21 <EvilTerran> :t 1
10:11:23 <lambdabot> forall t. (Num t) => t
10:11:31 <Saizan> EvilTerran: why not?
10:11:33 <EvilTerran> oh, wait...
10:11:34 <EvilTerran> is it?
10:11:44 <Saizan> :t [(1,[(2,[])])]
10:11:44 <shapr> :t [(1,[(2,[])])]
10:11:47 <lambdabot> forall t t1 a. (Num t, Num t1) => [(t, [(t1, [a])])]
10:11:47 <lambdabot> forall t t1 a. (Num t, Num t1) => [(t, [(t1, [a])])]
10:11:49 <shapr> heh
10:11:50 <EvilTerran> that's a weird one. okay, yes, it is. i'm still not sure what you want...
10:11:52 <Saizan> tuples!
10:12:08 <Japsu> @index lex
10:12:08 <lambdabot> Text.Read, Prelude, Text.Read.Lex
10:12:14 <laz0r> mmh, well you might be right, but still, i have sometzhing like this: newtype Parse a = P (Int, [Parse a], [a])
10:12:37 <laz0r> and i would like to have a method to iterate over this from inside to outside
10:12:49 <shapr> Yeah, I think you could.
10:13:04 <Japsu> What's the difference between data and newtype in such a case?
10:13:04 <shapr> Just use a left fold, yes?
10:13:25 <EvilTerran> it's... an n-ary tree of (Parse a)s, labelled by an Int and an [a]? (albeit in a funny order)
10:13:26 <xerox> Japsu: the newtype does not exist at runtime, it's just a tag for the typechecker
10:13:34 <Japsu> xerox: k
10:14:13 <shapr> newtype is nifty, it's as different as 'data' but as fast as 'type'
10:14:35 <EvilTerran> shapr, except for the matter of bottoms and whatnot
10:14:54 <shapr> Oh, how's that different with data/newtype/type ?
10:15:34 <Saizan> newtype has the same bottoms of type, i think
10:15:35 <EvilTerran> data Foo a = Foo a; case (Foo undefined) of Foo _ -> "this is fine"
10:15:42 <EvilTerran> newtype Foo a = Foo a; case (Foo undefined) of Foo _ -> "this isn't"
10:16:03 <EvilTerran> a newtype doesn't have a bottom independent of the wrapped type
10:16:17 <Saizan> yeah but there you're not using the internal
10:16:23 <Saizan> so it's fine anyway
10:16:39 <byorgey> makes sense, otherwise the compiler couldn't optimize away the newtype tag, right?
10:16:58 <shapr> Sounds right.
10:16:58 <EvilTerran> (i *think* i got that right...)
10:17:30 <laz0r> EvilTerran: that type is supposed to represent a sequence of production rules
10:17:52 <phobes> EvilTerran: You can't pattern match on undefined can you?
10:18:07 <laz0r> the Int is an identifier for the rule, the [a]'s are terminals, and the list in the middle are the transitions
10:18:08 <fasta> I wouldn't be surprised if newtype A = A Int would be translated to data A<compiler generated symbol> = A !Int first
10:18:13 <byorgey> phobes: no, that's called the halting problem =)
10:18:16 <EvilTerran> regardless, in the newtype case, it's impossible to tell (Foo _|_) and _|_ apart, and in the data case, it is (theoretically).
10:18:25 <EvilTerran> phobes, i'm not
10:18:44 <phobes> byorgey:  I know , but I'm trying to understand that example EvilTerran gave
10:18:55 <phobes> oh nm
10:19:06 <phobes> I read it too quickly , sorry
10:19:33 <EvilTerran> laz0r, i'm not sure what you mean by "iterate over this from inside to outside"
10:20:00 <Saizan> *Main>  case (FooN undefined) of FooN _ -> "this isn't"
10:20:00 <Saizan> "this isn't"
10:20:16 <hpaste>  dcoutts pasted "c2hs dep finder for pgavin-work" at http://hpaste.org/2499
10:20:21 <EvilTerran> Saizan, what about case undefined of FooN _ -> "this isn't"?
10:20:24 <dcoutts_> pgavin-work: ^^
10:20:46 <pgavin-work> lol
10:20:48 <pgavin-work> that was quick
10:20:59 <Saizan> EvilTerran: yeah, that's the difference
10:21:02 <Saizan> *Main>  case (undefined) of FooN _ -> "this isn't"
10:21:03 <Saizan> "this isn't"
10:21:15 <Saizan> instead with data you've an exception
10:21:16 <pgavin-work> I'll just stick that in the build rule for chs files then :)
10:21:39 <EvilTerran> aha. i knew i was close. Saizan++ for actually checking my deluded ramblings. =]
10:22:14 <laz0r> EvilTerran, it is a tree-like structure, and i need to traverse it from the bottom to the root
10:22:27 <laz0r> i think that is much more what i want than what i said first
10:23:21 <EvilTerran> by "traverse"... would a list of the nodes of the tree, in your required order, be suitable?
10:23:41 <EvilTerran> sounds like a depth-first post-order traversal to me, if i understand you right.
10:23:50 <Saizan> one could write something like foldTree
10:24:35 <EvilTerran> @docs Data.Tree
10:24:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
10:24:44 <laz0r> yes, i think a list would be ok
10:25:01 <EvilTerran> if you could wedge your values into that type, that might do what you want
10:25:26 <laz0r> mmh, im gonna read that...
10:25:42 <EvilTerran> i think your Parse a is isomorphic to Tree (Int, [a])
10:26:26 <EvilTerran> hm... there aren't actually as many functions in there as i thought there were.
10:26:48 <Saizan> most of the useful functions are in the instances
10:27:12 <EvilTerran> mmm, true.
10:27:15 <laz0r> it still seems to be usefull
10:27:46 <laz0r> i try to fit my datastructure into that and see how far i will get with that
10:27:51 <laz0r> thx for the pointer
10:28:07 <EvilTerran> hope it helps =]
10:28:43 <axm> i am trying to get an application running which is using hs-plugins and a call of load produces the error: 'Ix{Int}.index: Index (1024) out of range ((0,57))' - any ideas how I can investigate that?
10:29:04 <SamB> axm: whoa neat
10:29:18 <SamB> what a nice error message
10:29:54 <shapr> Is that a Data.Binary state version tag or something?
10:29:57 <SamB> I mean, uh, compared to "index out of range" with no index or range shown
10:30:44 <axm> but since i do not know the plugins internals i have no idea which index it could be talking about
10:31:58 <shapr> What's the app?
10:32:06 <axm> janus, webserver
10:32:08 <Blwood> can someone please explain me  why I have an error when I do floor(3.2) + 5.2, but I don't have this error with fromInt(floor 3.2) + 5.2
10:32:43 <shapr> axm: Janus from Sirius Software?
10:33:02 <axm> nope, darcs.fh-wedel.de/janus
10:33:10 <xerox> Blwood: check out the typesig of (+)
10:33:13 <xerox> ?type (+)
10:33:15 <lambdabot> forall a. (Num a) => a -> a -> a
10:33:20 * shapr darcs pulls
10:33:29 <xerox> It can take any Num, but both of its arguments must be of the same type!
10:34:11 <xerox> Blwood: makes sense?
10:34:18 <Blwood> xerox, yeah but when I do fromInt(floor 3.2) it is 3, and it's an Integer, but 5.2 is a Float isn't it ?
10:34:39 <Blwood> so it shouldn't work
10:34:51 <xerox> Blwood: no. The result of the floor is an integral. fromIntegral makes it a Float/Double as 5.2 is.
10:36:07 <msouth> well, it makes it a Num, doesn't it?
10:36:09 <Blwood> ?type fromInt
10:36:11 <lambdabot> Not in scope: `fromInt'
10:36:17 <msouth> fromIntegral?
10:36:18 <Blwood> :(
10:36:28 <Blwood> "*** Of type    : Int -> Integer"
10:36:29 <msouth> or is fromInt in some other library?
10:36:34 <Blwood> in Numeric
10:37:00 <Blwood> I thought the type Integer was just a Big Int
10:37:00 <ricky_clarkson> :t fromInteger
10:37:02 <lambdabot> forall a. (Num a) => Integer -> a
10:37:05 <xerox> Blwood: that error message excerpt isn't enough information.
10:37:24 <shapr> andyjgill: Hiya! How's code?
10:37:47 <andyjgill> hi shapr
10:37:50 <byorgey> Blwood: yes, Integer is arbitrary-size integers
10:37:55 <tuxplorer> how do I write haskell binding for a C library? any docs related to that? does FFI provide the required ways to do that? or is it something else?
10:37:59 <byorgey> Blwood: Int is machine-size
10:38:25 <EvilTerran> tuxplorer, yes, FFI is exactly what you want
10:38:43 <fasta> EvilTerran: did you succeed it writing your C binding?
10:38:47 <EvilTerran> if your library is well behaved, it should be ridiculously easy
10:38:48 <fasta> EvilTerran: in*
10:38:58 <Blwood> yes so how does it come that fromInt(floor 4.2) + 5.2 works, taking into account that 5.2 is a Double and the result of fromInt(floor 4.2) is an Integer
10:39:02 <shapr> tuxplorer: You probably want to check out c2hs for automation once you understand the FFI basics.
10:39:22 <byorgey> Blwood: fromInt(floor 4.2) is not Integer.
10:39:23 <tuxplorer> EvilTerran: shapr: ok.. Thanks..
10:39:25 <EvilTerran> fasta, I managed to get my hand-written importing of some test functions working, so i'm looking at hsc2hs now to import everything
10:39:39 <EvilTerran> @where c2hs
10:39:39 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
10:39:40 <Blwood> byorgey, hugs tells me "Of type    : Int -> Integer"
10:39:52 <EvilTerran> or indeed just c2hs
10:40:07 <kosmikus> Blwood: that can't be the complete error message
10:40:14 <byorgey> Blwood: hmm, I thought you meant fromIntegral, I've never heard of the function fromInt
10:40:32 <byorgey> Blwood: you mean when you ask Hugs what the type of fromInt is, it says Int -> Integer?
10:40:38 <kosmikus> byorgey, Blwood: fromInt is deprecated and should be long gone; what version of hugs are you using?
10:40:45 <EvilTerran> i had to do a little hack to get my test functions working, and i'm not entirely comfortable with it, but i think my further questions are better directed at the Allegro community rather than the Haskell one
10:40:46 <Blwood> oh I thing I'm wrong, :type fromInt gives me "fromInt :: Num a => Int -> a"
10:41:00 <EvilTerran> @index fromInt
10:41:00 <lambdabot> bzzt
10:41:10 <Blwood> kosmikus, fromInt int the module Numeric
10:41:19 <EvilTerran> @source Numeric
10:41:19 <lambdabot> http://darcs.haskell.org/packages/base/Numeric.hs
10:41:20 <byorgey> Blwood: ah, ok, right.  that means it turns an Int into whatever instance of Num is required
10:41:25 <shapr> axm: Janus has a lot of dependencies, but it talks about the latest version of hs-plugins (1.0-rc0), so it should work.
10:41:28 <Blwood> ahhhh
10:41:35 <Blwood> byorgey, so in this case a Float ?
10:41:45 <EvilTerran> that doesn't have it...
10:42:02 <Blwood> Numeric> :type fromInt
10:42:02 <Blwood> fromInt :: Num a => Int -> a
10:42:06 <byorgey> Blwood: something like that, technically it's probably Rational I think ?
10:42:08 <shapr> axm: Have you just tried to build janus and get it working from those darcs repos? Or is this a plugin you wrote yourself?
10:42:16 <axm> yip, it should. probably my messed up compiler or something
10:42:29 <axm> just the hello world
10:42:43 <Blwood> byorgey, is there a difference between Rational and Float ?
10:43:10 <shapr> axm: Are you using 6.6, or 6.6.1 ?
10:43:37 <Blwood> kosmikus, wich function should I use instead of fromInt ?
10:43:52 <kosmikus> Blwood: the answer to your original question is that hugs defaults the numeric type to an Integer
10:44:04 * shapr throws alien lambdas at kosmikus 
10:44:09 <kosmikus> Blwood: so the result is really of type "Num a => a", but in order to be able to print it, it makes a choice
10:44:30 <kosmikus> Blwood: fromIntegral works fine instead of fromInt
10:45:00 <axm> shachaf, 6.6
10:45:05 * kosmikus morphs the lambdas into Fuun and throws them back at shapr
10:45:07 <Blwood> okay, thank you very much for the help, it's very kind :)
10:45:11 <axm> damn. *shapr
10:45:36 <shapr> axm: Well, that's what the README suggests, so it sounds like it should work.
10:45:43 <tuxplorer> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ is there a better place to learn FFI than this? The vocabulary(which sounds like some dry law book) used in the introduction itself scares me ;)
10:45:43 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
10:45:56 <shapr> axm: Are you using a GHC 6.6 binary that you downloaded? Or did you build ghc 6.6 yourself?
10:46:11 <shapr> tuxplorer: The old HaWiki had some great FFI examples, maybe they're on the new haskellwiki?
10:46:14 <axm> tried both
10:46:33 <shapr> axm: Which operating system/version/flavor?
10:46:42 <tuxplorer> shapr:  ya Thanks.. http://haskell.org/haskellwiki/GHC/Using_the_FFI
10:46:43 <kosmikus> Blwood: if you try ":t fromInt (floor 4.2)", you'll actually get the more complicated type ...
10:46:43 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
10:46:46 <phobes> Can I import into ghci?
10:47:08 <axm> shapr, ubuntu edgy (manual compile) and feisty (repo)
10:47:41 <byorgey> Blwood: yes.  Float is floating-point, Rational stores an exact ratio (i.e. two Integers)
10:49:11 <shapr> axm: And you got the same problem with all of those?
10:49:33 <axm> shapr, but i recall something was different with edgy, some more serious problem
10:49:52 <shapr> Are you using the feisty repo install of ghc 6.6 right now?
10:50:02 <axm> i think it was hxt would not compile right so i started over
10:50:05 <axm> yes
10:50:07 <shapr> You may want to see if hs-plugins works the same with 6.6.1.
10:52:18 <shapr> Because you're likely to get more help with 6.6.1. It's what most people here use.
10:52:22 <axm> I'll have a look, although it seems odd since it is not mentioned in the dependencies
10:52:38 <axm> good to know
10:52:38 <shapr> axm: Have you tried to run the hs-plugins testsuite with 6.6 and/or 6.6.1 ?
10:53:12 <axm> no, is it included in the package?
10:53:14 <shapr> If the testsuite works at least you've eliminated part of the problem.
10:53:39 <shapr> It's included in the hs-plugins darcs repository from the author, not sure if it's in the wedel repos.
10:55:57 <shapr> So, anyone working on cool code today?
10:56:05 <puusorsa> no
10:56:24 <shapr> Bah
10:56:28 <shapr> ei ole!
10:58:58 <olsner> @seen syntaxfree
10:58:58 <lambdabot> I saw syntaxfree leaving #haskell-blah and #haskell 7h 34m 4s ago, and .
11:00:28 <byorgey> phobes: what do you mean by import into ghci?
11:01:02 <byorgey> phobes: maybe you want :m +Module?
11:02:14 <shapr> phobes: yeah, :m Data.List
11:03:34 <aFlag> hello, catch function is the only way to check for EOF?
11:04:23 <int-e> @type System.IO.isEOF
11:04:25 <lambdabot> IO Bool
11:04:30 <int-e> @type System.IO.hIsEOF
11:04:32 <lambdabot> GHC.IOBase.Handle -> IO Bool
11:05:08 <aFlag> oh, thanks
11:08:48 <coffeemug> whoo hoo
11:08:59 <coffeemug> I now have Haskell-style infinite lists in common lisp :)
11:09:04 <coffeemug> (defvar ints (@cons 1 (@map #'1+ ints)))
11:09:10 <coffeemug> (@take 10 ints)
11:09:14 <coffeemug> returns #A[1 2 3 4 5 6 7 8 9 10]
11:09:16 <coffeemug> :-D
11:10:48 <Japsu> yay
11:13:00 <monochrom> Hrm, I think you announced it two days ago or something.
11:13:54 <coffeemug> monochrom: it's work in progress :)
11:14:22 <coffeemug> monochrom: it worked before for some things, but it was more eager than necessary
11:14:28 <coffeemug> now I removed that extra eagerness :)
11:15:00 <phobes> byorgey:  thanks, I was just doing :load Data.List
11:15:06 <phobes> and it wasn't working :)
11:15:36 <aFlag> coffeemug, what does that code do? What's up with all those # and @?
11:15:49 <byorgey> phobes: yeah, I wouldn't think so =)
11:16:03 <coffeemug> well, @ is just part of the identifier
11:16:09 <coffeemug> I use it to differentiate from built in lists
11:16:31 <coffeemug> #' is common lisp's weirdness that can be ignored :)
11:16:43 <coffeemug> the rest of it looks just like a haskell definition would look
11:16:47 <byorgey> aFlag: note that isn't Haskell =)
11:17:05 <coffeemug> > (take 10 (let ints = 1 : map (1+) ints)
11:17:05 <lambdabot>  Unbalanced parenthesis
11:17:09 <coffeemug> > (take 10 (let ints = 1 : map (1+) ints))
11:17:09 <lambdabot>  Parse error
11:17:12 <aFlag> yeah, I was just corious of what those would mean
11:17:29 <coffeemug> > take 10 ints where ints = 1 : map (1+) ints
11:17:29 <lambdabot>  Parse error
11:17:32 <coffeemug> arghh
11:17:42 <byorgey> > (take 10 (let ints = 1 : map (1+) ints in ints))
11:17:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:17:50 <coffeemug> thanks :)
11:17:52 <aFlag> I never programmed in lisp though
11:18:02 <byorgey> coffeemug: where is only allowed in function declarations, IIRC
11:18:37 <xerox> foo where bar isn't an expression :(
11:18:51 <byorgey> coffeemug: now define fix!
11:19:06 <aFlag> coffeemug, but lisp doesn't have lazy evaluation, does it? What makes the ints definition stop?
11:19:24 <coffeemug> aFlag: I implement it myself
11:19:34 <byorgey> > take 10 $ fix ((1:) . map (1+))
11:19:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:19:38 <coffeemug> when I want to make stuff lazy I wrap it into a closure
11:19:50 <coffeemug> and unwrap when I want the value
11:20:16 <coffeemug> heh
11:20:20 <coffeemug> gotta love the Y
11:20:21 <coffeemug> :)
11:21:59 <byorgey> coffeemug: shouldn't be too hard to actually define fix with your extensions there, should it?
11:22:10 <aFlag> I tried (defvar ints (@cons 1 (@map #'1+ ints))) on clisp interpreter and it gave me an error. Saying that @cons is undefined
11:22:11 <byorgey> fix f = let x = f x in x
11:22:35 <coffeemug> aFlag: yeah @cons is part of the lib I'm working on
11:23:02 <aFlag> @map too I suppose
11:23:03 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:23:13 <coffeemug> yes
11:23:26 <aFlag> lambdabot got confused
11:23:48 <byorgey> hmm, that @map command is out of date...
11:25:24 <coffeemug> hmm
11:25:29 <coffeemug> fix may be a bit more complicated
11:27:00 <byorgey> coffeemug: well, feel free to ignore me, it was just a suggestion =)
11:27:22 <Saizan> but if you've fix you're done :)
11:27:35 <aFlag> what's the use of fix?
11:27:43 <coffeemug> byorgey: well, it is a pretty interesting suggestion
11:28:10 <byorgey> coffeemug: I figure, if you can implement fix, you can probably implement anything =)
11:28:34 <coffeemug> well, you can implement fix without any extensions
11:28:39 <coffeemug> all you really need is lambda
11:28:52 <xerox> All you need is love!
11:29:06 <monochrom> If you know functions, you probably want to write inline functions - that's lambda. If you know recursion, you probably want to write inline recursions - that's fix.
11:29:49 <xerox> ...and if you know inling?
11:30:28 <monochrom> Example. fix (\self -> do { s <- getLine; putStrLn s; self }) is a convenient way to write an imperative loop.
11:30:38 <pejo> xerox, you define an optimizer, much like Supero.
11:31:17 <monochrom> xmonad is full of imperative loops like that.
11:33:08 <axm> shapr, got it now running (past that point) on both systems, 6.6.1 is happy with the zipped release of hs-plugins while the 6.6 system is not, but works with the (presumably newer) version fresh from darcs
11:33:49 <axm> just for documenting the weirdness
11:34:18 <aFlag> why the name fix?
11:34:23 <aFlag> what does it fix?
11:34:52 <xerox> It is a fixpoint for its functional argument.
11:36:23 <monochrom> If you have an equation "x = .... x ...", a solution for x is called a fixed point of that equation.
11:36:36 <xerox> Take for example f = (1:), the xs such that xs = f xs is?
11:36:43 <xerox> > fix (1:)
11:36:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:39:26 <roconnor> @type mfix
11:39:28 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:40:32 <puusorsa> @type fix
11:40:34 <lambdabot> forall a. (a -> a) -> a
11:45:10 <aFlag> hm, my ghc doesn't give that m :: * -> * type
11:45:53 <Saizan> ghci writes kind annotations only with -fglasgow-exts
11:45:55 <monochrom> turn on -fglasgow-exts and you will get them.
11:46:06 <monochrom> you will also get a lot of forall's.
11:47:09 <aFlag>  hm
11:48:00 <shapr> axm: spiffy
12:13:05 <Laney> I'm having lots of trouble with HaXml :(. Can someone point me to a function which allows me to add Elements as children of already existing ones?
12:21:00 <conal> Laney: I don't know HaXml, but what you're asking for sounds like a traditionally imperative style, rather than a functional one
12:21:25 <Laney> Hmm, I guess. It's hard to tell.
12:21:50 <Laney> I've just defined the root statically, as it's never going to change.
12:22:45 <Laney> Well, apart from its children I guess, which is where my problem is.
12:22:46 * Laney thinks
12:23:18 <conal> you're doing dynamic (run-time-changing) HTML?
12:23:23 <conal> (xml)
12:23:40 <byorgey> Laney: nothing ever changes in Haskell; you can only compute new values from old ones, but you can't "change" the old values
12:23:41 <sfultong> STM is getting me down :(
12:24:04 <Laney> Yeah byorgey, I want an Element -> Element function which just appends to the children.
12:24:30 <Laney> I'm not talking about mutating; I've just initialised the initial state, as it were.
12:24:38 <Cale> Laney: That's easy, just pattern match
12:24:46 <byorgey> Laney: ok, I see. that should be possible in theory, but I'm not familiar with HaXml
12:25:52 <Laney> Cale: something like `append (Element n as cs) c = Element n as c:cs'?
12:25:55 * Laney tries
12:26:03 <Cale> something like that
12:26:10 <EvilTerran> need more parentheses, surely
12:26:18 <Cale> appendChildren :: Element -> [Content] -> Element; appendChildren (Elem n as cs) cs' = Elem n as (cs ++ cs')
12:26:19 <Laney> probably
12:26:37 <Cale> Depending on what exactly it is that you want.
12:26:57 <Cale> That's not quite a CFilter though.
12:26:58 <Laney> I just figured that there would be something that already did this that I was missing
12:27:23 <Cale> There might be, I don't really know HaXml either.
12:27:43 <Laney> It's hard learning a library with only the API documentation.
12:27:54 <ohmega_> @paste
12:27:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:27:56 <Laney> Ah well, I'll try that. Thanks, Cale
12:29:26 <hpaste>  ohmega_ pasted "(no title)" at http://hpaste.org/2502
12:29:47 <ohmega_> i'm getting a compile error for the xmonad on os x, see paste
12:30:02 <Cale> ohmega_: Do you have the darcs version of everything?
12:30:03 <ohmega_> i have disabled xinerama
12:30:33 <ohmega_> well. only of xmonad
12:31:13 <ohmega_> i grabbed X11-extras from the url in the README
12:31:19 <Cale> ohmega_: I think it was X11-extras that you needed the darcs version of as well.
12:31:25 <ohmega_> oh.
12:31:26 <ohmega_> ok.
12:31:59 <Cale> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
12:32:01 <lambdabot> Title: Index of /~sjanssen/X11-extras
12:32:06 <ohmega_> thanks, already loading :)
12:39:07 <sfultong> aren't all readTVar/writeTVar instructions in an STM atomic block supposed to execute?
12:41:42 <Lemmih> sfultong: Yes, either they all execute or none of them do.
12:42:03 <sfultong> Lemmih: cool, although that doesn't seem to be happening for me
12:42:14 <Lemmih> sfultong: Paste the code?
12:44:05 <hpaste>  sfultong pasted "more STM mess" at http://hpaste.org/2503
12:45:46 <Lemmih> sfultong: writeTVar doesn't force the evaluation of the element it's writing.
12:46:33 <Lemmih> sfultong: You'd be much better off with 'unsafeIOToSTM (putStrLn "msg")'.
12:46:49 <sfultong> how can it write something it doesn't evaluate?
12:47:15 <Lemmih> sfultong: Haskell is lazy.
12:47:15 <sfultong> debugging haskell is a PITA
12:47:53 <sfultong> well, I still don't understand laziness
12:48:24 <Lemmih> sfultong: Don't ask how, then. Just accept the magic (:
12:48:57 <sfultong> I wouldn't, except for the fact that the magic is failing me ):
12:50:41 <sfultong> I finally understood the magic enough to understand fix
12:51:03 <sfultong> but there's more magic than my slimy little brain can handle
12:52:48 <byorgey> sfultong: realizing this is the first step towards enlightenment =)
12:53:18 <EvilTerran> i tend to think about laziness in terms of how i almost invented it myself before i discovered it
12:53:25 <sfultong> the first step towards enlightenment is realizing enlightenment is a crock full of poop
12:53:56 <byorgey> sfultong: actually, that's the last step
12:54:18 <sfultong> oh dear
12:55:12 <sfultong> I think I understand laziness, but I haven't yet grasped all its ramifications
12:55:54 <EvilTerran> in that i made a vaguely lisp-like language that worked by pulling tokens off the front of a stream, evaluating them, and putting the results back on
12:56:25 <EvilTerran> (it had grouping several tokens into one with parens, that's what made it vaguely lisplike)
12:56:25 <sfultong> sounds like joy
12:56:39 <byorgey> EvilTerran: nice =)
12:56:50 <EvilTerran> when i was using it, it reminded me most of postscript written backwards, actually :D
12:58:13 <byorgey> postscript written backwards...
12:58:17 * byorgey backs away slowly
12:58:53 <EvilTerran> i might still have the interpreter (written in perl) sitting around somewhere...
12:59:04 <byorgey> you mean it used prefix notation?
12:59:10 <EvilTerran> yeah
12:59:18 <monochrom> Hrm, postscript itself is already written backwards... <duck>
12:59:38 <johnnowak> isn't it no!
12:59:40 <EvilTerran> it was effectively lazy lisp
13:00:12 * roconnor thinks postfix is the proper way.
13:00:36 <monochrom> postfix is for bottom-up people. prefix is for top-down people.
13:01:24 <EvilTerran> ah, found my perl "regex" for matched parentheses
13:01:29 <EvilTerran> /^(?{0})(?:\((?{$^R+1})|(?(?{$^R})\)(?{$^R-1})))*(?(?{$^R})(?!))$/
13:01:34 <monochrom> syntax tree is for insightful people.
13:01:52 <roconnor> x (f . g . h) makes more sense than (h . g . f) x
13:01:53 <olsner> irregex ;-)
13:01:58 <EvilTerran> it's basically a non-deterministic push-down automaton
13:02:09 <monochrom> "Can programming be liberated from the Plain ASCII File?"
13:02:11 <roconnor> unless you are japanesse
13:02:20 <sfultong> I agree with roconnor
13:02:38 <xerox> roconnor: meaning what?
13:02:38 <sfultong> monochrom: I think of that a lot, actually
13:02:54 <sfultong> monochrom: who is that a quote of?
13:03:15 <EvilTerran> (the variable $^R has changes done to it automatically undone when the regex matching process backtraces over the block that changed it)
13:03:26 <roconnor> meaning when I have a series of functions, I'd prefer to read them from left to right.
13:03:45 <monochrom> I made it. I copied from Backus's "Can programming be liberated from the von Neumann style?"  I carefully made them rhyme.
13:04:04 <sfultong> yeah, and since I generally type from left to right, it's more convenient in that sense as well
13:04:41 <monochrom> Some group theory books use x (f . g . h). Same sentiment.
13:04:51 <EvilTerran> let ($>) = flip ($); (.>) = flip (.) --?
13:05:02 <EvilTerran> with appropriate fixities
13:05:37 <sfultong> monochrom: so why don't you liberate it?
13:06:01 * sfultong will liberate it, if monochrom doesn't
13:06:36 <monochrom> Programmers are stubborn even about the ASCII part, nevermind the Plain part.
13:06:39 <ricky_clarkson> :t flip
13:06:41 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:06:51 <ricky_clarkson> I don't seem to be able to grasp that type.
13:07:20 <elliottt> @hoogle b -> [(a,b)] -> a
13:07:21 <lambdabot> No matches, try a more general search
13:07:35 <phobes> roconnor:  Or you could reverse the order in which you write function types...   f :: Int <- Int   :)
13:08:17 <monochrom> It seems much easier to ask programmers to let go of state than to ask them to let go of source code files.
13:08:50 <Paczesiowa> could one of you guys explain to me this error: http://hpaste.org/2504 , pretty please?
13:08:53 <sfultong> well, maybe the target audience shouldn't be programmers? ;-)
13:08:59 <roconnor> monochrom: isn't Conor working on this problem?
13:09:00 <phobes> I'm ready to be done with source files ... only problem is all of the tools that exist for them
13:09:13 <DRMacIver> I like source code files.
13:09:37 <phobes> Well you need source files I think ... the question is whether you expect to edit them directly
13:09:49 <phobes> (as plain text)
13:09:52 <DRMacIver> Or at the very least, I like source code. I'm more flexible about the question of files.
13:10:52 <sfultong> I'm flexible the opposite way
13:11:09 <roconnor> phobes: maybe functions should be immutable and stuck in a database.  To replace a function you have to write a new one and adjust all the callers to refer to the new function. :D
13:11:30 <ricky_clarkson> In dynamic languages, when they gain type annotations and before they have decent inference, the amount of annotations will make things awkward.
13:11:44 <ricky_clarkson> That will push things towards a non-plain-text representation.
13:11:52 <phobes> roconnor:  I think there's a kernel of the idea in that
13:12:54 <monochrom> Paczesiowa: if you are ready for rank-2 types, it can be explained. if not, you have to be ready for rank-2 types first.  rank-2 type means something like (forall a. a -> a -> Bool) -> (Value -> Value -> Value)
13:12:58 <Philippa> ricky_clarkson: not really, assuming dynamic => dynamically typed
13:12:59 <roconnor> phobes: that's how I've been imagining my never-to-be-written proof assistant to work with proofs.
13:13:14 <Philippa> a type annotation in a dynamically-typed language is essentially an assertion
13:13:33 <Philippa> just one that happens to mean something useful to the implementation as well
13:13:49 <ricky_clarkson> Philippa: There are static checkers in the works.  You can already see primitive forms in Java (admittedly not a dynamic language) - @NotNull, @Nullable.
13:15:09 <DRMacIver> I was observing the other day actually that most of Java's type safety advantages over its predecessors are dynamic rather than static.
13:15:10 <phobes> roconnor: cool
13:15:57 <monochrom> Paczesiowa: Perhaps "why it's rejected" can be explained elementarily. ("how to correct it" requires rank-2 types.) Although "a" is polymorphic, it is only up to the extent that different callers of val can make it a different type. Inside the same call, "a" is only one type, and cannot switch between Int and Char.  Rank-2 types remove that restriction.
13:17:04 <byorgey> Paczesiowa: val's type says that it should work when given *any particular* function type which matches a -> a -> Bool: that is, it should work whether it is given a function of type Int -> Int -> Bool, or Char -> Char -> Bool etc.
13:17:25 <Paczesiowa> monochrom: tx, where can I find some tutorial about those rank2 types?
13:17:56 <byorgey> Paczesiowa: but that's not what you want, you want to say that val takes a function which itself can accept any types.
13:18:40 <byorgey> Paczesiowa: what is it you're trying to do?  Something with type classes might actually be a better solution.
13:18:41 <Paczesiowa> byorgey: I thought that a-> a-> Bool was just that
13:19:05 <xerox> Rank 2 types are based on the equivalence (exist x. p => q) = ((forall x. p) => q)
13:19:25 <byorgey> Paczesiowa: a -> a -> Bool will match something such as Int -> Int -> Bool.  obviously something of type Int -> Int -> Bool cannot accept values of type Char.
13:19:31 <phobes> xerox:  Really?
13:20:03 <olsner> ah, #haskell is at it again
13:20:07 <Paczesiowa> I'm trying to "lift" standard operators to work on ma Value type, I tried instancing Num and Integral but it was too much work
13:20:12 <Heffalump> at what?
13:20:19 <EvilTerran> Paczesiowa, i'm thinking this is a job for typeclasses
13:20:55 <olsner> "Rank 2 type" was the keyword this time... usually it's category theory or somesuch brainy subject
13:21:17 <monochrom> Rank-2 types are brainy too!
13:21:18 * EvilTerran thinks about what xerox just said... ah, yeah, that makes sense.
13:21:26 <olsner> the "I see words, but no meaning emerges" experience
13:21:27 <EvilTerran> what about Rank-n types? :D
13:21:36 <byorgey> Paczesiowa: yeah, the way you're going about it is the way of Pain, I think =)
13:21:43 * EvilTerran is still unsure what rank-n do that rank-2 don't.
13:21:46 <olsner> ordinary types have rank 1, right?
13:21:51 <monochrom> Yes.
13:21:52 <ricky_clarkson> olsner: Are you negatively discriminating based on knowledge?
13:22:03 <olsner> ricky_clarkson: yes!
13:22:05 <Heffalump> what does rank-2 do that rank-1 doesn't?
13:22:13 <ricky_clarkson> olsner: As you were.
13:22:26 <Saizan> rank-n is when you have a forall inside more nested =>, right?
13:22:32 <Philippa> -> rather than =>
13:22:33 <EvilTerran> Heffalump, with rank-1, a type can only have a forall at the very outside
13:22:37 <EvilTerran> and it's implicit
13:22:42 <olsner> wait, no I'm not... I'm just expressing my love for #haskell (as an entity)
13:22:53 <byorgey> Paczesiowa: how would, say, + work for your Value type?
13:22:56 <mux> @karma+ #haskell
13:22:56 <lambdabot> #haskell's karma raised to 5.
13:23:00 <olsner> #haskell :: [String]
13:23:19 <phobes> A function that takes a rank-2 function and does something with it is rank-3, right?
13:23:24 <Philippa> yeah
13:23:37 <Heffalump> EvilTerran: I was just generalising your argument.
13:23:42 <Paczesiowa> byorgey: + should be lifted for INT Int, and fail with error"" on other types of Value
13:23:45 <sfultong> why should #haskell have a karma?
13:23:48 <EvilTerran> Heffalump, ah, i see.
13:24:07 * olsner would like to be reborn as #haskell
13:24:44 <sfultong> @karma
13:24:44 <lambdabot> You have a karma of 0
13:24:57 <sfultong> @karma lambdabot
13:24:57 <lambdabot> lambdabot has a karma of 43
13:25:01 <mux> lift2 f x y = f (deINT x) (deINT y), and then lift2 (+) someINT someOtherINT?
13:25:02 <sfultong> woah :)
13:25:06 <mux> sounds rather inconvenient
13:25:18 <aFlag> what database would you guys recommend for using in haskell?
13:25:19 <Vulpyne> @karma haskell
13:25:19 <lambdabot> haskell has a karma of 20
13:25:27 <mux> it's probably much easier to just have a Num instance :)
13:25:27 <Vulpyne> People like the bot better than the language. :)
13:25:36 <Heffalump> EvilTerran: why don't we restrict Haskell to second-order functions, and computers to 640K, while we're at it? ;-) </strawman>
13:25:48 <EvilTerran> what?
13:26:22 <Philippa> the second-order function bit being extremely directly analogous
13:26:31 <phobes> Moving from rank-1 to rank-2 requires a change to the language syntax
13:26:34 <aFlag> I need a freely available one
13:26:37 <byorgey> Paczesiowa: well, I think at least you should make a separate function for lifting functions of each type.  for example, you could have a liftIntFunc :: (Int -> Int -> Int) -> (Value -> Value -> Value)
13:26:40 <phobes> Moving from rank-2 to rank-n is just an implementation issue, right?
13:26:40 <EvilTerran> all i knew was that rank-2 allowed explicit forall.s, and rank-1 didn't. i wasn't aware that there was a limit to the nesting in rank-2.
13:26:42 <byorgey> Paczesiowa: and so on.
13:26:49 <roconnor> and a change in the time inteference algorithim
13:26:58 <Heffalump> well, with rank-2, the s is rank-1.
13:27:01 <phobes> The fact that you'd want to support rank-n once you've allowed rank-2 seems obvious
13:27:02 <Paczesiowa> mux: but I need Num and integral (mod and div)  and that starts to be boring
13:27:07 <sfultong> I think it'd be fun to try and program in all rank 3 functions
13:27:20 <mux> Paczesiowa: it seems much less boring than the alternative to me
13:27:22 <Heffalump> phobes: there was quite some discussion on haskell' about it
13:27:31 <Heffalump> I forget the arguments though
13:27:37 <mux> Paczesiowa: but maybe we can find an even better solution if you explain what you're trying to achieve in the end?
13:27:45 <phobes> Heffalump:  Some were arguing not to support past rank-2?
13:27:47 <Philippa> mostly "but I never use more than rank-2 anyway and I swear rank-2's easier to implement!!!"
13:27:48 <EvilTerran> typeclasses!
13:28:03 <Paczesiowa> byorgey: I did that, but then I have operators = [(">"), lift1 (>)), ...]
13:28:03 <Heffalump> phobes: yes.
13:28:06 <phobes> Philippa: That's what I'd expect - easier implementation
13:28:18 <phobes> Heffalump:  It was just implementors whining though, right; )
13:28:19 <Heffalump> also there was an argument about encoding rank-n in rank-2 by wrapping with data constructors
13:28:22 <Philippa> oh, wait, I think inference for rank-2 is doable as well
13:28:33 <byorgey> Paczesiowa: and what's the problem with that?
13:28:37 <Paczesiowa> byorgey: and there would have to be 2 operators for ">", one with lift1 and one with lift2
13:28:39 <Philippa> phobes: no, it was also clueless users who expect rank-n to be more complicated to use
13:28:43 <EvilTerran> Heffalump, that sounds like the argument against exists.
13:28:48 <EvilTerran> (which i'm not convinced by)
13:28:55 <Philippa> Heffalump: yeah. There's also an argument about encoding case and constructors using lambdas though :-)
13:29:07 <EvilTerran> "it'd involve making another keyword! nooooo!"
13:29:08 <Heffalump> anyway. Got a more interesting discussion to have, so I'm off.
13:29:10 <byorgey> Paczesiowa: what's lift1?
13:29:18 <phobes> Philippa:  I don't get that ... if rank-2 worked but rank-n didn't, I'd think it a bug
13:29:21 * mux wouldn't mind type-level lambdas :-)
13:29:38 <EvilTerran> i think that goes for a lot of us, mux =]
13:29:44 <Philippa> phobes: I mean inference without annotations
13:29:44 <Paczesiowa> byorgey: e.g. lift1 :: Int -> Int -> Bool -> ..., lift2 :: Char -> Char -> Bool -> ...
13:29:47 * EvilTerran wants dependent types, at least
13:29:55 <phobes> Philippa: Oooh, you're talking about inference, sorry
13:30:19 <EvilTerran> Paczesiowa, what you're doing sounds like it'd be better suited to either typeclasses or Data.Generics
13:30:22 <byorgey> Paczesiowa: oh, I see.  well, I really don't think there's any way around that, since you've stuffed three different types into the same "Value" type.
13:30:25 <EvilTerran> @docs Data.Generics
13:30:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
13:30:35 <phobes> You functional guys are spoiled expecting everything to be inferred :)
13:30:50 <byorgey> Paczesiowa: you're going to end up with some annoying case- and type- distinctions somewhere
13:30:54 <mux> code inference ftw!
13:30:59 <EvilTerran> yeah, well, @free and @djinn'll do that to you, phobes ;]
13:31:19 <Paczesiowa> ok, I''ll write that boring instancing code for Num and Integral
13:31:31 <mux> EvilTerran: dependent typing still seems a bit complicated to me
13:31:40 <mux> it's not covered in TAPL >:)
13:31:58 <monochrom> I don't easily dismiss "implementer whinings". We should thank the implementers. Some features make a lot of sense, but we should give implementers time and support.
13:32:31 <Heffalump> I think that statement was ironic.
13:32:35 <byorgey> Paczesiowa: I do understand your sense that there must be a "better way" if something is boring/annoying, but in this case I'm not sure that there is
13:32:45 <EvilTerran> @where TAPL
13:32:45 <lambdabot> I know nothing about tapl.
13:32:50 <byorgey> Paczesiowa: are you writing an interpreter/compiler of some sort?
13:32:56 <Philippa> monochrom: rank-n has been well understood for a decade
13:33:02 <Heffalump> Types and Programming Languages, by Benjamin C Pierce
13:33:09 <Heffalump> classic theory book (though quite new)
13:33:14 <lament> i thought you meant TLAP - Talk Like A Pirate
13:33:14 <phobes> mux:  They talk about dependent types in chapter 30 in TAPL
13:33:18 <Paczesiowa> byorgey: yes right now interpreter of simple langague for cs classes
13:33:29 <phobes> Not in much depth tho
13:33:31 <mux> phobes: they only mention its existence and the pi notation
13:33:31 <Philippa> as in, I'd hand THIH and one of the rank-n papers to an undergrad as a final year project and expect shiny results
13:33:36 <mux> that's all there is to it
13:33:49 <mux> @where+ TAPL http://www.cis.upenn.edu/~bcpierce/tapl/
13:33:49 <lambdabot> Done.
13:33:53 <mux> @where TAPL
13:33:54 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:34:11 <roconnor> monochrom: except when they implement the monomorphsim restriction, which totally sucks.
13:34:18 <byorgey> Paczesiowa: cool
13:35:05 <EvilTerran> Heffalump, mux, sounds interesting. i'll see if my college library has it when i go back up in a month.
13:35:31 <DRMacIver> Philippa: What's THIH?
13:35:34 <Paczesiowa> byorgey: I know it's cool:> since I learned (basics of) haskell I failed all other classes because they were soooo boring
13:35:36 <mux> EvilTerran: it enlightened me, in a way :-) now I can understand quite a few research papers
13:35:47 <EvilTerran> yay research papers!
13:35:56 * EvilTerran <3 research papers
13:36:04 <Heffalump> if not you might be able to persuade the Hooke to get a copy.
13:36:05 <mux> I should move on to the advanced tapl now, I guess, dependent typing is probably covered in depth there
13:36:24 <EvilTerran> which is just as well, given that i fully intend to fly straight out of my undergrad degree and headfirst into research
13:36:26 <byorgey> Paczesiowa: hehe, that's not good... =)
13:36:38 <Philippa> DRMacIver: "Typing Haskell In Haskell"
13:36:43 * Botje likes reading papers more than writing them.
13:36:52 <Philippa> it's a paper that writes the guts of a Haskell typechecker
13:36:59 <Paczesiowa> byorgey: yeah, but what you gonna do, I'm lazier than haskell's evaluation
13:37:06 <EvilTerran> huh. "From October 2007 the Hooke Lending Library will cease to exist and the collections will be incorporated into the Radcliffe Science Library to form a combined Reference and Lending Library.  Entry will be through the main RSL entrance."
13:37:17 <mux> oh! I've been wondering for ages now what's the meaning of the "tying the knot" expression?
13:37:26 <Heffalump> so they'll lend out anything?
13:37:30 <DRMacIver> Philippa: Ah, neat.
13:37:40 <byorgey> mux: you just figured it out, or you're still wondering?
13:37:49 <monochrom> "tying the knot" simply means recursion, even data recursion, things like x = 1 : x
13:37:57 <EvilTerran> most of the RSL's only reference, i think =/
13:38:12 <mux> byorgey: I was actually asking :)
13:38:14 <Heffalump> EvilTerran: yes, it is. I spent a while in there photocopying for my DPhil.
13:38:18 <mux> monochrom: only that?
13:38:23 <monochrom> tying the knot is made easy in haskell by lazy evaluation.
13:38:33 <EvilTerran> i got a free photocopy card for somethink like 30 pages during freshers' week, though, so that'll let me grab anything particularly interesting
13:38:42 <monochrom> typing the knot is also made easy in imperative languages by mutable pointers
13:38:43 <mux> monochrom: thanks!
13:38:54 <EvilTerran> *something. am not beink stereotype russki. da.
13:39:05 <monochrom> There are more subtle recursions. But in the end it's still just recursion.
13:39:21 <byorgey> mux: I think the idea of the expression is that you imagine having some string and tying a knot to make it into a loop.
13:39:37 <mux> are you thinking about recursion primitives such as catamorphism, anamorphism, etc, when you say there are more subtle recursions?
13:39:52 <mux> byorgey: yep, I get it now, thanks
13:40:17 <monochrom> It is given a special name because people coming from imperative training is unfamiliar with "if you have lazy evaluation, you can do recursion to data too!"
13:40:22 <byorgey> mux: cool, just making sure =)
13:40:48 <litb> hello all
13:40:50 <litb> filter ((== 0) . (mod 2)) [1,2,3,4,5,6,7,8]
13:41:03 <litb> hmm, i want it to filter all even numbers
13:41:03 <roconnor> > filter ((== 0) . (mod 2)) [1,2,3,4,5,6,7,8]
13:41:05 <lambdabot>  [1,2]
13:41:06 <DRMacIver> It's not so much imperative programming as strict evaluation that's the issue.
13:41:12 <mux> > filter even [1..10]
13:41:14 <pjd> litb: even is a builtin
13:41:14 <lambdabot>  [2,4,6,8,10]
13:41:18 <litb> but that does not because mod takes its arguments in another order
13:41:24 <roconnor> > filter ((== 0) . (`mod` 2)) [1,2,3,4,5,6,7,8]
13:41:25 <lambdabot>  [2,4,6,8]
13:41:31 <DRMacIver> You can see this because of the way it breaks when you try to do it with insufficiently lazy datastructures in Haskell.
13:41:32 <monochrom> By "more subtle recursion" I just mean larger, cleverer code.
13:41:45 <litb> roconnor: ah, thank you
13:41:46 <mux> monochrom: okay, thanks for the explanations
13:42:16 <slava_> filter ((== 0) . (`mod` 2)) looks like it has a lot of 'noise'
13:42:22 <monochrom> My "imperative" includes eager.
13:42:32 <slava_> i somewhat prefer [ 2 mod 0 = ] filter :-)
13:42:42 <monochrom> Afterall that's also most people's "imperative".
13:42:52 * DRMacIver eyes monochrom 
13:42:53 <litb> slava_: yeah, i'm still a bloody beginner =)
13:43:01 <slava_> its not you, its haskell :)
13:43:02 * oerjan pines for (`mod` 2 == 0)
13:43:02 <mux> slava_: I like "filter even" even more :)
13:43:04 <pjd> litb: that was Factor, not Haskell :)
13:43:29 <litb> pjd: what?
13:43:30 <slava_> mux: well that's odd
13:43:45 <pjd> litb: the "[ 2 mod 0 = ] filter"
13:43:47 <mux> you got me mightly confused
13:44:01 <litb> ah, that is not a haskell construct?
13:44:05 <mux> odd as in strange or as in not even?
13:44:13 * mux slaps forehead
13:44:24 <pjd> litb: yeah, it's Factor, a concatenative language
13:44:25 <EvilTerran> awesome, my college has TAPL, and the comlab has Advanced Topics in TAPL, too
13:44:35 <pjd> (slava is Factor's author :)
13:44:45 <mux> EvilTerran: lucky you :-) costed me more than 50 EUR on amazon
13:44:46 <litb> slarba_: how can i make it less noisy ?
13:44:52 <slava> EvilTerran: i'm reading the latter right now
13:45:03 <Heffalump> I wonder if that's Igloo's doing.
13:45:06 <EvilTerran> mux, this is costing me several kGBP/year. don't get too jealous.
13:45:15 <mux> heh
13:45:27 <Heffalump> and the government is paying several more kGBP/year, and Keble's endowment is probably funding the library :-)
13:46:07 <EvilTerran> yay taxpayers' money :D
13:47:22 <monochrom> Some Java coders are paying part of that tax.
13:47:58 <monochrom> There are two attitudes you can hold towards that.
13:48:00 <Heffalump> I'm paying quite a lot of that tax :-)
13:48:10 <monochrom> (A) Next time I should thank them and not mock them.
13:48:59 <monochrom> (B) For all their sins of coding in Java or C++ or ... that's their deserved penalty! They deserve to fund me for doing Haskell!
13:49:25 <monochrom> Two wrongs make a right! Ha!
13:49:28 <slava> maybe you can invent a pleasant way of doing point-free code in haskell :)
13:49:42 <SamB> monochrom: no, three lefts do!
13:49:59 <monochrom> Don't test me on group theory.
13:50:18 <SamB> monochrom: possibly you are confusing right and wrong with GF(2)
13:50:52 * Botje poses: most of what \bot does should be in ghci. discuss.
13:50:53 <monochrom> C_2 is a perfectly fine subgroup of C_4.
13:50:55 <sieni> slava: @pl :-)
13:51:18 <slava> sieni: filter ((== 0) . (`mod` 2))  is pretty ugly compared to a real point-free language :)
13:51:21 <monochrom> What does \bot do?
13:51:23 <pjd> sieni: @pl isn't necessarily pleasant
13:51:31 <sieni> well...
13:51:40 <Botje> @pl and @where, for example.
13:51:40 <lambdabot> (line 1, column 11):
13:51:40 <lambdabot> unexpected ","
13:51:40 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
13:51:46 <Botje> oh shut up, you.
13:51:59 <sieni> it can be
13:52:06 <sieni> my favourite was today's
13:52:17 <sieni> @pl \a b -> a >>= (\c -> b >>= (\d -> return (c, d)))
13:52:18 <lambdabot> liftM2 (,)
13:52:19 <xerox> ?pl \f amb -> amb >>= return . f
13:52:20 <lambdabot> fmap
13:52:38 <xerox> Yeah, good :)
13:52:50 <xerox> Go Reader Monad!
13:52:51 <pjd> slava: then again, Haskell doesn't need to [ ]
13:52:58 <Botje> slava: how would it look in a "real" pl language?
13:53:07 <pjd> Botje: see earlier
13:53:21 <Botje> ah
13:53:29 <Botje> must've skipped over that :)
13:54:04 <DRMacIver> So what does the corresponding pointful version look like in factor? :)
13:54:31 <slava> [| x | x 2 mod 0 = ] subset (factor actually calls filter subset)
13:54:37 <slava> but making this pointful is pointless, so to speak :)
13:54:51 <DRMacIver> True
13:55:11 <xerox> Is factor pure?
13:55:15 <glguy> no
13:55:20 <pjd> define "pure"
13:55:27 <slava> factor is not a virgin, its had lots of sex
13:55:28 <pjd> it's not referentially transparent
13:55:42 * johnnowak wonders who got to pick the word "pure" to mean "without effects"
13:56:06 <slava> same crowd that talks about "dynamic languages" :)
13:56:20 <monochrom> perhaps as in "pure math".
13:56:24 <sieni> johnnowak: I guess it's just an additional attribute to "functional language" or something
13:56:40 <lament> heh, SPJ.
13:56:44 <slava> i think it comes from "pure function" which means "a function in the mathematical sense"
13:56:54 <lament> "I shall explain STM using Haskell, the most beautiful programming language I know"
13:56:55 <slava> if all your functions are pure functions, you have a pure language
13:57:16 <johnnowak> i suppose i wasn't seriously asking the question
13:57:49 <lament> "a function in the mathematical sense" is too vague
13:58:16 <llewyenoh> if i parse a file and get a string containing an int, is there anyway i can write that into an actual int variable?
13:58:28 <pjd> it probably comes from "purely functional"
13:58:39 <mrd> > read "123" :: Int
13:58:40 <pjd> in contrast to mixed functional / imperative
13:58:41 <lambdabot>  123
13:58:49 <llewyenoh> ah, thanks, mrd
13:59:01 <lament> in particular most people would probably assume that "functions in the mathematical sense" always evaluate to something.
13:59:17 <slava> partial functions then
13:59:20 <pjd> llewyenoh: specifically, read is a polymorphic type class method
13:59:54 <pjd> the :: Int is one way of forcing the instance you want
14:00:05 <pjd> otherwise it generally picks it up from context
14:00:40 <llewyenoh> well, if i already have an int that i'm using
14:00:45 <llewyenoh> and defined earlier via ::
14:00:56 <llewyenoh> and i just wanted to read the int into the variable
14:01:01 <llewyenoh> that's all i was asking
14:01:30 <slava> haskell isn't qbasic
14:01:43 <pjd> llewyenoh: there's not really anything like "reading into a variable"
14:01:54 <monochrom> I would love to see that code. :)
14:01:59 <sjanssen> @remember slava haskell isn't qbasic
14:02:00 <lambdabot> Done.
14:02:43 <pjd> llewyenoh: you can assign it a name:  x = read "123"
14:02:49 <oerjan> haskell has variables in the mathematical sense, not the mutable content sense (well, it has those too, in monads)
14:02:58 <pjd> and then use x wherever you would use (read "123")
14:02:59 <lament> "Gentle reader, you may by now be feeling that Haskell is a very clumsy and verbose language."
14:03:13 <llewyenoh> because of haskell's functional nature?
14:04:06 <pjd> Haskell "variables" are more like naming things for convenience
14:04:27 <llewyenoh> that makes sense
14:05:08 <beza1e1> How do i get ' ' as a GHC.Word.Word8? It gets inferred as Char :(
14:05:28 <monochrom> fromIntegral (fromEnum ' ')
14:05:47 <monochrom> there may be a more efficient way
14:05:55 <llewyenoh> this is an extension from my earlier question, and i'm pretty sure this isn't possible, but how would you extract 12 from "12 XX"
14:05:57 <beza1e1> and why do the ByteString examples don't do this?
14:06:09 <Mr_Awesome> is fmap just the same as \f m -> m >>= (return . f) ?
14:06:30 <pjd> llewyenoh: probably by getting rid of the XX somehow
14:06:32 <dcoutts_> beza1e1: you can use Data.ByteString.Char8
14:06:37 <xerox> beza1e1: check out also the .Char8 modules
14:06:44 <xerox> ...stereo :)
14:06:50 <llewyenoh> pjd: right, but i'm asking about the "somehow" part
14:06:51 <Mr_Awesome> @pl \f m -> m >>= (return . f)
14:06:51 <lambdabot> fmap
14:06:54 <pjd> llewyenoh: for example, you can split on spaces
14:06:59 <pjd> or filter on digits
14:07:02 <Mr_Awesome> oh... i guess that answers my question
14:07:10 <monochrom> ByteString provides c2w and w2c.
14:07:20 <llewyenoh> pjd: in my case, either would work, so parsec, i'm guessing?
14:07:21 <pjd> depends what you want out of it, really
14:07:46 <llewyenoh> pjd: just the first part, which happens to be the only digits in the string
14:07:50 <pjd> well, you can use Parsec if you want to
14:07:53 <xerox> llayou use reads
14:07:55 <beza1e1> Ah, i changed "import Data.ByteString" to "import Data.ByteString.Char8" and it works :)
14:08:00 <xerox> > reads "12 XX"
14:08:01 <lambdabot>  [(12," XX")]
14:08:08 <pjd> but it might be overkill if you just want words :)
14:08:14 <pjd> @type words
14:08:15 <monochrom> This is why programmers will still refuse "Can programming be liberated from the Plain ASCII File?" for decades to come.
14:08:15 <lambdabot> String -> [String]
14:08:33 <EvilTerran> monochrom, what, the bytes vs characters thing?
14:08:41 <monochrom> Some people still think Word8 is isomorphic to Char, and that all libraries should do only that.
14:08:46 <llewyenoh> xerox: oh, interesting, thanks
14:08:58 <xerox> llewyenoh: you're welcome.
14:09:04 <pjd> xerox: oh, nice
14:09:19 <dcoutts_> monochrom: though that's why we called it Char8 not Char, we're still anticipating proper unicode packed string
14:10:27 <EvilTerran> i think part of the problem is that the basic IO functions all work on Chars
14:10:36 <monochrom> Yes dcoutts, actually the whole ByteString package does it right, providing a Word8 module and a Char8 module. But look at the question, "why doesn't ByteString [the default] do that", that reflects programmer mentality.
14:10:47 <dcoutts_> monochrom: right
14:10:54 <EvilTerran> so people figure "ah, well, chars must be simple, so are probably bytes"
14:11:04 <sfultong> a call to atomic automatically blocks until it can be processed, right?
14:11:20 * EvilTerran thinks it'd make more sense if the Char IO functionality were built on top of some Word8 IO functionality
14:11:42 <dcoutts_> EvilTerran: yes, though keeping it convenient for the common case where people don't care
14:12:30 <EvilTerran> i wouldn't scrap the Char functions, just make it clear that they're an abstraction layer.
14:12:37 <Lemmih> sfultong: Yes.
14:17:02 <hpaste>  llewyenoh pasted "Condensing EOL definition for Parsec" at http://hpaste.org/2506
14:17:43 <mrd> oneOf "\r\n"
14:17:45 <mrd> oneOf "\r\n" >> return ()
14:18:02 <monochrom> @type <$>
14:18:04 <lambdabot> parse error on input `<$>'
14:18:08 <monochrom> @type (<$>)
14:18:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:18:22 <mrd> @type fmap
14:18:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:18:28 <monochrom> that will not give you the ()
14:19:06 <llewyenoh> ah, ok
14:21:00 <UnaRacer> I have a "type Atom = (Int, Int)", and I want to define my own "compare" on Atoms.  I'm trying "instance Ord Atom where ..." and defining compare in there, but I'm getting "Illegal instance declaration for `Ord Atom`
14:21:15 <oerjan> <?> is clearly defined the wrong way around
14:21:17 <pjd> llewyenoh: you could, OTOH, do () <$ oneOf "\n\r"
14:21:18 <mrd> UnaRacer: need a newtype or data
14:21:27 <pjd> (i think)
14:21:29 <norpan> UnaRacer: you can't instance type synonyms
14:21:43 <llewyenoh> pjd: is that <$ or <$>?
14:21:44 <xerox> Yeah you can.
14:21:45 <UnaRacer> Aha.
14:21:53 <xerox> You can't just partially apply them.
14:21:55 <pjd> llewyenoh: <$
14:22:03 <slava> so can GADTs be considered a form of dependent typing?
14:22:11 <llewyenoh> pjd: what does that part actually do?
14:22:33 <norpan> xerox: what does that mean exactly?
14:22:47 <xerox> UnaRacer: doesn't ghc also say what extention you have to activate in order to instantiate type synonyms=
14:22:51 <xerox> s/=/?/
14:23:00 <pjd> llewyenoh: it's basically (<$>) . const
14:23:18 <sjanssen> UnaRacer: you should probably make Atom a newtype instead of a synonym
14:23:20 <norpan> if you want to instance them, you probably should use newtype anyway
14:23:25 <pjd> that is, it replaces everything in the functor
14:23:29 <oerjan> xerox: you can probably instantiate them (with extension) but you cannot make them different from what they expand to
14:23:35 <mrd> slava: well, without the mixing of types and terms
14:23:58 <sjanssen> UnaRacer: you can make your instance work if you enable a few extensions (flexible instances, overlapping instances), but that's not very nice (especially the overlapping part)
14:24:00 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#id3149655
14:24:02 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
14:24:07 <pjd> > 'x' <$ [1..5]
14:24:09 <lambdabot>  "xxxxx"
14:24:18 <xerox> It's in the manual, anyway.
14:24:22 <llewyenoh> pjd: oh, interesting
14:24:25 <mrd> @type (<$)
14:24:26 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:24:37 <pjd> > () <$ "foo"
14:24:38 <lambdabot>  [(),(),()]
14:24:42 <llewyenoh> pjd: what do i need to import for it?
14:24:48 <pjd> Control.Applicative
14:24:55 <llewyenoh> ok, thanks
14:26:14 <litb> haskell fcks my brain
14:26:28 <glguy> you should be so lucky
14:26:32 <lament> what does brainfuck do to your brain, then?
14:27:24 <litb> it cleans it after haskell polluted it
14:27:37 <llewyenoh> pjd: it says "parse error on input `<$'
14:27:50 <pjd> odd
14:29:00 <oerjan> llewyenoh: what line did you try?
14:29:28 <llewyenoh> eol = do () <$ oneOf "\n\r"
14:29:58 <oerjan> :t do () <$ oneOf "\n\r"
14:30:00 <lambdabot> Not in scope: `oneOf'
14:30:02 <monochrom> remove "do".
14:30:22 <oerjan> it still whouldn't have been a parse error
14:30:27 <oerjan> *shouldn't
14:30:33 <llewyenoh> yeah, same error
14:30:33 <monochrom> check your imports
14:30:46 <sjanssen> why are we recommending "() <$ x" over "do x; return ()"?
14:30:50 <monochrom> erase the line and type it again
14:30:58 <glguy> sjanssen: write only coding style
14:31:05 <oerjan> sjanssen: golf?
14:31:18 <xerox> sjanssen: I'd rather not.
14:31:22 <llewyenoh> don't have any strange imports
14:31:59 <monochrom> look at nearby lines of code. may interfere.
14:32:00 <sjanssen> llewyenoh: can you hpaste the whole program?  It's probably a minor error above the line in question
14:32:58 <pjd> sjanssen: for one, the former works for all functors
14:33:26 <xerox> pjd: no, it does need a monad.
14:33:30 <sjanssen> pjd: I think clarity trumps generality in llewyenoh's case
14:33:42 <litb> was there ever some real world program created using haskell, which actually was sold?
14:34:13 <pjd> sjanssen: eh, the only intuitive interface is the nipple, etc.
14:34:27 <pjd> you only have to learn <$ once :)
14:34:32 <hpaste>  llewyenoh annotated "Condensing EOL definition for Parsec" with "(no title)" at http://hpaste.org/2506#a1
14:34:51 <EvilTerran> litb, see http://haskell.org/haskellwiki/Haskell_in_industry
14:34:52 <lambdabot> Title: Haskell in industry - HaskellWiki
14:35:07 <sjanssen> litb: Windows Vista
14:35:21 <yaxu> actually it can take a couple of days for a newborn get the hang of breastfeeding
14:35:36 <oerjan> llewyenoh: the parse error is in the import statement
14:35:42 <Heffalump> sjanssen: you what?
14:35:45 <yaxu> or did you mean the thing in the middle of laptop keyboards pjd? :)
14:35:46 <oerjan> you need parentheses around operators
14:35:53 <llewyenoh> oh, stupid mistake
14:35:58 <monochrom> Can you say "import Control.Applicative(<$, <$>)"?  Shouldn't it be "import Control.Applicative((<$), (<$>))"
14:36:06 <llewyenoh> yeah, i realize that now
14:36:07 <monochrom> "check your imports"
14:36:11 <pjd> yaxu: yeah, i know how flawed the analogy is ;)
14:36:14 <llewyenoh> yeah, my bad
14:36:18 <pjd> just common currency
14:36:28 <sjanssen> Heffalump: I'm kidding ;)
14:36:33 <Heffalump> ah :-)
14:36:51 <oerjan> although there isn't any particularly good reason why those parentheses are needed there, other than consistency...
14:38:15 <sjanssen> llewyenoh: are you writing an xmobar plugin?
14:39:14 <llewyenoh> sjanssen: dzen input, actually
14:39:28 <llewyenoh> sjanssen: from Config.hs
14:39:32 <llewyenoh> sjanssen: into logHook
14:43:22 <hpaste>  sjanssen pasted "my battery parser" at http://hpaste.org/2507
14:43:59 <sjanssen> llewyenoh: http://hpaste.org/2507 I use that with xmobar.  The format is so simple that parsec is probably overkill
14:44:16 <llewyenoh> sjanssen: thank you so much. you just saved me hours of work.
14:51:33 <Mat^> hm, is there any function like charToInt?
14:51:38 <Mat^> @where charToInt
14:51:38 <lambdabot> I know nothing about chartoint.
14:51:40 <mrd> @type ord
14:51:42 <lambdabot> Char -> Int
14:51:48 <Mat^> mhm
14:51:51 <Saizan> ?hoogle digitToInt
14:51:51 <lambdabot> Char.digitToInt :: Char -> Int
14:51:54 <Mat^> mrd: thanks! :>
14:51:57 <Mat^> Saizan: I tried
14:52:03 <Saizan> > digitToInt '1'
14:52:04 <lambdabot>  1
14:52:06 <Mat^> (I mean, if hoogle is google ;P)
14:52:12 <Saizan> > ord '1'
14:52:13 <lambdabot>  49
14:52:21 <Saizan> Mat^: no, hoogle is not google
14:52:26 <Saizan> ?where hoogle
14:52:26 <lambdabot> http://haskell.org/hoogle
14:52:58 <Mat^> Saizan: ok, sorry ;>
14:53:37 <mrd> @hoogle Char -> Int
14:53:37 <lambdabot> Char.digitToInt :: Char -> Int
14:53:37 <lambdabot> Char.ord :: Char -> Int
14:54:04 <Saizan> Mat^: hoogle is sometime useful to search the standard library
14:54:09 <Mat^> mhm
14:54:16 <Saizan> Mat^: even if it's matching algorithm has to be refind
14:56:28 <oerjan> apparently hoogle has some bugs with monadic types and the like
14:56:55 <EvilTerran> there's a new version in progress, i hear
14:59:10 <llewyenoh> sjanssen: how would i use that to send into logHook?
15:02:08 <Mat^> @hoogle Bool -> Int
15:02:09 <lambdabot> No matches, try a more general search
15:02:13 <Mat^> ;P
15:02:27 <oerjan> > fromEnum True
15:02:28 <lambdabot>  1
15:02:46 <Mat^> thanks again ;>
15:03:05 <aFlag> hey guys, what do you advise me to use for using database with haskell?
15:04:05 <ddarius> aFlag: To use the appropriate DB interface for your problem.
15:04:49 <pjd> and maybe think hard about whether you really want a database
15:05:15 <dozer> databases are a fact of life
15:05:42 <dozer> unless you think hand-roled ascii art filestores are better?
15:06:03 <ddarius> dozer: Sounds like a good idea to me.
15:06:09 <aFlag> I think database can make it easier for me to save and retrieve information from the disk
15:06:14 <Lemmih> aFlag: HDBC.
15:06:49 <lament> i would certainly prefer hand-rolled ascii art
15:06:57 <Lemmih> HDBC is slightly less horrible then the other interfaces.
15:07:10 <ddarius> What about Takusen?
15:08:26 <lament> hand-rolled ascii art http://users.z3.ca/~lament/ascii/deathstalker.txt
15:08:37 <Mat^> maybe you guys know if there is any function which converts double to binary? (iee754)
15:08:41 <Mat^> I really can't find it ;P
15:09:22 <pjd> unsafeCoerce?
15:09:38 <aFlag> I've done a function like that once, but it was system dependent
15:09:51 <ddarius> lament: Nice job smoothing.
15:10:05 <Mat^> hm
15:10:27 <aFlag> if you want it I can try to find it for you
15:11:01 <Mat^> aFlag: if it's not a problem
15:11:23 <lament> ddarius: one of the easiest ascii art styles...
15:14:26 <augustss> Mat^: binary?  what do you mean?
15:14:28 <Mat^> I guess there should be function like that in some compiler creating library
15:14:43 <aFlag> Mat^, I think this is it: http://rafb.net/p/QzyGc413.html
15:14:45 <lambdabot> Title: Nopaste - No description
15:14:52 <Mat^> augustss: convert double, to value that can be directly put into memroy
15:14:53 <Mat^> memory
15:14:59 <aFlag> it's ugly, but it got the job done
15:15:12 <augustss> doubles can be put in memory
15:15:32 <Mat^> augustss: but I must be able to print it
15:15:41 <EvilTerran> we don't like to think about such low-level concerns as memory in haskell...
15:15:44 <augustss> print it as what?
15:15:56 <Mat^> as to long values
15:15:59 <Mat^> two
15:16:09 <augustss> ah, now we're getting somewhere
15:16:13 <EvilTerran> (partly 'cos we consume it in vast amounts, but stil)
15:16:26 <aFlag> Mat^, that BS module is: import qualified Data.ByteString as BS
15:16:31 <Mat^> EvilTerran: yes, but I am writing compiler, and I need it ;P
15:16:34 <augustss> you want to convert a double to Word64, or 2 Word32
15:16:47 <Mat^> aFlag: ok
15:16:48 <Mat^> augustss: yes
15:17:01 <Mat^> I'll try aFlag's function
15:17:22 <augustss> Yes, you'll have to do something like that.
15:18:23 <Mat^> it's some kind of monad :S
15:18:41 <sfultong> @seen shapr
15:18:41 <lambdabot> shapr is in #haskell, #haskell-blah, #scannedinavian, #happs and #haskell-overflow. I last heard shapr speak 45m 47s ago.
15:19:28 <sfultong> shapr: alright, I give up... I'm starting TDD, and going back over all my code and writing test cases for it, because... tracking down bugs in haskell really sucks
15:19:30 <EvilTerran> sounds like the sort of thing you'd use a union{} for in C. you could write a little C function :: CDouble -> CLLong and tie it in using the FFI
15:19:44 <EvilTerran> and, as it'd be pure, you wouldn't need to do anything monady
15:20:33 <Paczesiowa> is it possible to use n-dimensional arrays with n loaded at runtime?
15:20:54 <oerjan> @instances Ix
15:20:55 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:20:57 <EvilTerran> long long double2longlong (double x) { union { long long ll, double d } cast; cast.d = x; return cast.ll }
15:21:11 <oerjan> @instances-importing Ix Ix
15:21:12 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
15:21:28 <EvilTerran> sort of thing. given that you don't get reinterpret_cast<> in C.
15:21:32 <aFlag> Mat^, I think the other functions there are in Foreign.ForeignPtr and Foreign.Storable
15:21:38 <oerjan> Paczesiowa: you might write an instance for []
15:21:50 <EvilTerran> oerjan, i've thought about that, it's a bit of a monster...
15:21:51 <oerjan> there doesn't seem to be any predefined one
15:22:07 <aFlag> these are all the imports: http://rafb.net/p/MI5vvx95.html
15:22:08 <lambdabot> Title: Nopaste - No description
15:22:42 <elliottt> \pl \x -> isLetter x || isSpace x
15:22:46 <Mat^> uch, I am too lame with haskell :P
15:22:48 <Paczesiowa> oerjan: tx, I'll try to do that, but I'm still in shock after I learned that lists are monad, it was like my mom telling me that there is no santa
15:22:52 <elliottt> @pl \x -> isLetter x || isSpace x
15:22:52 <lambdabot> liftM2 (||) isLetter isSpace
15:23:06 <int-e> hmm. f :: Double -> Word64; f (D# x) = W64# (unsafeCoerce# x)
15:24:16 <Mat^> parse error in pattern :S
15:24:39 <ddarius> Paczesiowa: What does that have to do with what oerjan said?
15:24:53 <Choko> Mat^: remember parentheses
15:25:05 <Paczesiowa> ddarius: I'm scared od using monads and lists in the same sentence:>
15:25:14 <oerjan> isn't that more like your mom telling you that santa has a rocket sleigh? :)
15:25:32 <ddarius> Lists form monads.  Lists are still lists.
15:25:55 <Mat^> Choko: I pasted it just like int-e :S (without ';')
15:26:05 <byorgey> or that santa is a ninja.
15:26:07 <Mat^> ok, I'll check maybe ffi
15:26:14 <EvilTerran> Mat^, are you using -fglasgow-exts?
15:26:19 <ddarius> The # requires extensions.
15:26:26 <Mat^> ahm
15:26:47 <sfultong> santa is a ninja: stealthy and quick
15:27:02 <int-e> Mat^: it needs -fglasgow-exts and it needs some modules - GHC.Word, GHC.Float and GHC.Base. It's also ghc specific
15:27:38 * EvilTerran doesn't have GHC.Word or GHC.Float...
15:27:51 <Mat^> ok, great
15:27:54 <Mat^> it compiles
15:27:56 <EvilTerran> _or_ GHC.Base. unless i'm looking in the wrong place.
15:28:11 <|Jedai|> Is there someone here that solved Project Euler problem 95 ? Is there some confusion possible about the goal ?
15:28:25 * EvilTerran was thinking GHC.Prim and GHC.Exts, according to his copy of the docs
15:28:31 <jedai> Or on the definition of the chains ?
15:28:40 <Mat^> and it works ;>
15:28:54 <int-e> EvilTerran: oh I can't remember which the official one is :/
15:29:08 <Mat^> thanks :>
15:30:01 <int-e> GHC.Exts and GHC.Word suffice.
15:30:57 <byorgey> jedai: I solved it, but it was a while ago, I don't remember whether I encountered any confusion about the goal
15:31:09 <int-e> I guess the W64# constructor isn't officially exported.
15:31:23 <Mat^> one question: it works like a cast right? it puts double into memory, and return that memory?
15:31:37 <int-e> yes
15:32:46 <jedai> byorgey: That's too bad, I have a fast (somewhat) solution, but the result don't seem to agree with Project Euler, and even using a slow and dumb solution I get the same result... I probably made some stupid mistake, I always do ! :'(
15:33:10 <byorgey> jedai: yeah, I know the feeling. =)
15:33:23 * byorgey rummages around for Project Euler code...
15:34:06 <EvilTerran> hm... if i want to use c2hs with GHC 6.6.1, do i need to build it myself? i don't see a binary for that version on the site
15:34:38 <EvilTerran> wait what... i'm confused now. never mind, i'll ask a more coherent question later.
15:35:08 <byorgey> jedai: my code is pretty straightforward... I guess just make sure you're counting the lengths of the chains correctly?  (i.e. no off-by-one errors?)
15:35:17 <Paczesiowa> how do I make lists instance of smth? instance Foo [] where doesn't work
15:35:28 <EvilTerran> operating system: posix. hooray! =/
15:35:35 <int-e> EvilTerran: c2hs should be fairly independent of the ghc version.
15:35:40 <litb> does haskell have a rand function?
15:35:48 <oerjan> Paczesiowa: you probably want instance Ix a => Ix [a] where
15:35:49 <jedai> byorgey: That's probably the case but I don't see it, damn it !!! ^^
15:36:07 <int-e> EvilTerran: its output is haskell code (using the FFI extension) after all
15:36:11 <jedai> byorgey: And of course my function is perfectly correct on the example
15:36:15 * EvilTerran is not using cygwin, damnit.
15:36:27 <byorgey> jedai: heh, that's always the case, isn't it? =)
15:36:37 <pjd> Paczesiowa: [] would only be the empty list constructor, not the list type
15:36:48 <EvilTerran> (i have an irrational hatred thereof. meh.)
15:36:49 <oerjan> :t random
15:36:51 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
15:36:54 <byorgey> jedai: there's always some trick lurking that doesn't come up in the example...
15:36:58 <jedai> byorgey: Yeah, that's frustrating though :)
15:37:13 <litb> > random
15:37:13 <EvilTerran> pjd, um, [] would be the partially-applied type constructor in this context
15:37:14 <lambdabot>  Add a type signature
15:37:16 <oerjan> @docs System.Random
15:37:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
15:37:18 <litb> hmm
15:37:28 <pjd> EvilTerran: oh, true
15:37:28 <EvilTerran> as in "instance Functor [] where..."
15:37:28 <litb> > show random
15:37:29 <lambdabot>  Add a type signature
15:37:32 <litb> stupid
15:37:42 <EvilTerran> @type randomIO
15:37:44 <lambdabot> forall a. (Random a) => IO a
15:38:30 <oerjan> litb: randomIO may be simpler but can only be used in IO
15:38:35 <pjd> Paczesiowa: what EvilTerran said
15:38:40 <EvilTerran> litb, look a little closer at the type of random. it's (1) a function, and (2) polymorphic, you can't just suck a value out of it.
15:39:09 <Paczesiowa> what is the fastest way to find implementation of some library function?
15:39:10 <EvilTerran> Paczesiowa, if you want any list type to be an instance of something, that'd be "instance Foo [a] where..."
15:39:21 <pjd> Paczesiowa: haskell.org/hoogle
15:39:51 <Paczesiowa> EvilTerran: tx, it works now (well compiles, but doesn't work right yet)
15:39:58 <litb> oh
15:40:10 <EvilTerran> saying "instance Foo [] where..." means you're making the type *constructor* for lists an instance of Foo, not just all list types.
15:40:25 <litb> > random(6::Int)
15:40:26 <EvilTerran> this makes sense for, eg, Functor, Monad, etc.
15:40:26 <lambdabot>   add an instance declaration for (RandomGen Int)
15:40:26 <lambdabot>     In the expression: rand...
15:40:35 <litb> o.O i give up
15:40:46 <byorgey> @type random
15:40:48 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
15:40:49 <EvilTerran> litb, try reading the docs page oerjan pointed out
15:41:34 <litb> ok, thank you all
15:41:39 <EvilTerran> (a clearer example of instantiating a type constructor rather than a type might be, say, instance Functor Maybe)
15:41:50 <jedai> byorgey: for your information it was an error in my sigma function, should have used integer...
15:42:00 <byorgey> jedai: hehe
15:42:01 <pjd> litb: random takes an actual generator
15:42:09 <byorgey> jedai: does it work now?
15:42:12 <Paczesiowa> pjd: but hoogle just gives types and links to haddock generated docs, or am I blind?
15:42:15 <oerjan> > fst . random . mkStdGen $ 1 :: Int
15:42:17 <lambdabot>  -604496784
15:42:31 <pjd> Paczesiowa: haddock links to the source
15:42:35 <EvilTerran> @src map
15:42:35 <lambdabot> map _ []     = []
15:42:35 <lambdabot> map f (x:xs) = f x : map f xs
15:42:47 <pjd> Paczesiowa: check the "source code" link at the top :)
15:42:58 <Mr_Awesome> @src fmap
15:42:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:43:03 <jarl> hello. odd question perhaps, but does anyone here have a 5,25' or 8'-diskdrive connected to the computer?
15:43:06 <Mr_Awesome> what?
15:43:24 <Paczesiowa> pjd: tx! it was almost background color:/ I couldn't notice it
15:43:31 <Mr_Awesome> jarl: does this have anything to do with haskell?
15:43:32 <dozer> jarl: I don;t think I own a computer with a floppy drive of *any* kind :)
15:43:47 <jedai> byorgey: It will once I'll have it fixed !
15:43:49 <dolio> Is anyone here running Windows 3.1?
15:44:02 <olsner> jarl: is that feet or inches? :P
15:44:02 <oerjan> @src Functor
15:44:02 <lambdabot> class  Functor f  where
15:44:03 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:44:05 <byorgey> jedai: good to know =)
15:44:07 <jarl> Mr_Awesome: I dont know what hasell is, sorry
15:44:12 <EvilTerran> @src Maybe fmap
15:44:13 <lambdabot> fmap _ Nothing       = Nothing
15:44:13 <lambdabot> fmap f (Just a)      = Just (f a)
15:44:16 <EvilTerran> @src [] fmap
15:44:16 <lambdabot> fmap = map
15:44:28 <EvilTerran> @src (->) fmap
15:44:28 <lambdabot> fmap = (.)
15:44:37 <Mr_Awesome> ah
15:44:48 <jarl> olsner: inches
15:44:56 <olsner> ;-)
15:45:05 <litb> lol, jar asked the same in ##c++
15:45:05 <EvilTerran> if a function's a method of a class, the notation for @src is "@src <instance> <method>"
15:45:20 <byorgey> oh, too bad, I have an 8-foot floppy drive, but not an 8-inch one
15:45:29 <jarl> arggh
15:45:34 <litb> =)
15:45:49 <oerjan> byorgey: picture! :D
15:45:50 <jedai> byorgey: Yep it works, 10s though... Well at least it works
15:45:53 <EvilTerran> well, what'd he expect asking stupid irrelevant questions of intellectuals such as ourselves?!
15:45:55 <EvilTerran> ;]
15:46:12 <byorgey> jedai: 10s is pretty good for that problem, I think!
15:46:12 <LoganCapaldo> Cause he needs a disk drive...
15:46:48 <Mr_Awesome> did you just imply that im an intellectual?
15:46:52 <byorgey> oerjan: it's, uh... invisible...
15:47:27 <oerjan> byorgey: darn
15:47:28 <jedai> byorgey: What's fun with Projet Euler is to look at the thread and see solutions that do it 1000 times faster than mine
15:47:41 <byorgey> Mr_Awesome: did you just imply that you're not?
15:48:05 <byorgey> jedai: heh, yeah...
15:48:07 <dolio> jedai: And solutions that are 1000 time longer.
15:48:42 <Mr_Awesome> byorgey: indeed i did
15:48:45 <oerjan> if you are doing Haskell, you are an intellectual.  see the fine print.
15:48:46 <jedai> dolio: That's to get back your ego after the fastest solution crush it ;-)
15:48:47 <Mat^> if it's 1000 times faster, then It's not haskell problem, but algorithm is rather wrong ;P
15:49:03 <Mr_Awesome> oerjan: sweet! im going to go tell all my friends
15:49:23 <Mr_Awesome> damn, neither one cares
15:49:48 <jedai> Mat^: Yep, I don't care if someone goes 10 times faster using a worse algorithm but coding it in C, I look at the good algorithms
15:50:14 <shapr> sfultong: Awesome!
15:50:57 <litb> jedai: agreed
15:51:31 <Mat^> jedai: mhm, I didn't know that there are so big running time diffirences =]
15:51:50 <shapr> sfultong: Though I think tracking down bugs in any language sucks.
15:51:53 <litb> it is said that haskell is damn slow
15:52:13 <jedai> Mat^: You mean between C and Haskell ? Well it depends
15:52:19 <LoganCapaldo> Haskell isn't slow, its just too lazy to go quickly :)
15:52:32 <shapr> litb: It's true, but Haskell is still faster than Python, Ruby, etc.
15:52:44 <shapr> In some cases Haskell is faster than C.
15:52:51 <litb> shapr: really?
15:52:55 <litb> is it faster than python?
15:53:02 <Mat^> I must admit, I was surprised when my compiler written in haskell compiles as fast as gcc (same input)
15:53:07 <Mat^> but well, my compiler is rather stupid ;P
15:53:23 <litb> Mat^: you wrote a C compiler?
15:53:33 <jedai> Mat^: Still the solutions that go faster in C have at least 10 times as much line so...
15:53:36 <EvilTerran> also, GCC is not exactly zippy.
15:53:37 <Mat^> I'ts my coursework :S
15:53:54 <litb> Mat^: isn't that difficult?
15:53:55 <Mat^> litb: not C exactly, but very similiar custom language
15:54:00 <Mat^> litb: yes, it is ;P
15:54:04 <litb> well, at least not c++
15:54:09 * EvilTerran uses an obscure little C compiler for windows that's 1/10 the size of GCC, runs in about 1/4 of the time, and makes smaller executables
15:54:12 <Mat^> that would be too difficult ;>
15:54:20 <jedai> Mat^: I could probably get a speed closer to C but I would have to do some hairy things and I don't use Haskell to do that sort of crap ^^
15:54:27 <pjd> EvilTerran: tcc?
15:54:30 <Mat^> jedai: ;>
15:54:41 <EvilTerran> unfortunately, it's a little quirky, especially considering no-one bothers targetting it. but meh, i like it.
15:54:45 <EvilTerran> pjd, lcc, actually.
15:54:46 <litb> EvilTerran: ... and makes 10 times slower executables
15:54:48 <litb> =)
15:55:07 <EvilTerran> i've got tcc, but i went off it a bit when i noticed it's effectively dead in the water as a project.
15:55:08 <idnar> ooh, lcc
15:55:11 <Mat^> my compiler creates 20 times slower :D (comparing to gcc -O2 ;>)
15:55:12 <EvilTerran> litb, not that i've noticed.
15:55:13 * idnar remembers the days
15:55:17 <jedai> litb: It is definitely faster than Python, and shorter most of the time
15:55:26 <pjd> EvilTerran: not very surprising
15:55:40 <EvilTerran> pjd, what, that no-one's developing tcc?
15:55:45 <pjd> EvilTerran: it started as an IOCCC entry, didn't it?
15:55:56 <EvilTerran> did it? we may be thinking of different tccs...
15:56:31 <idnar> "TCC has its origins in the Obfuscated Tiny C Compiler (OTCC), a program Bellard wrote to win the International Obfuscated C Code Contest (IOCCC) in 2002. Since that time, Bellard expanded and un-obfuscated the program to produce tcc."
15:56:42 <EvilTerran> wow.
15:57:10 <EvilTerran> lcc gets updates to the development build almost daily. i find knowing that the program i'm using is still very much in active development gives me a nice warm fuzzy feeling.
15:57:31 <EvilTerran> "i can report bugs, and something might actually HAPPEN!"
15:58:03 <EvilTerran> (other then getting a "message undeliverable" email a few hours later)
15:58:30 <idnar> well, then again, gcc is in active development :P
15:58:41 <Mat^> active, but looks dead
15:58:47 * EvilTerran notes that the c2hs .tar.gz seems to have files in the same folder with names that only differ by case
15:59:13 <EvilTerran> look, i know you _can_ do stuff like this in your fancy-pants POSIX OSen, but that doesn't mean you _should_
15:59:54 <EvilTerran> it's well foiled my plan to see if i could get it running on windows regardless of its claim to be POSIX-only
16:00:01 <Mat^> gcc will be compatible with C++0x when C++1x or C++2x will come out
16:00:27 <Mat^> too bad there is no open source (not lightweight) alternative to gcc
16:03:02 <litb> Mat^: lightweight?
16:03:10 <litb> gcc is lightweight i think
16:03:15 * olsner is working on one in haskell... expect C++98 coverage by the release of C++2x ;-)
16:03:46 <Mat^> olsner: :>
16:04:00 <Mat^> litb: is it?
16:04:01 <litb> olsner: with export?
16:04:13 <litb> or was it C++03 added that?
16:04:25 <olsner> I do have a parser for type declarations, but hey I'm gonna need symbol tables, templates, code generation and lots of other crud before it's usable
16:04:31 <thoughtpolice> define 'lightweight,' because gcc isn't exactly small.
16:04:41 <lament> are there any features that were introduced in haskell and then were integrated into more mainstream languages? Are there features which are in haskell now but will likely eventually be integrated into more mainstream languages?
16:04:48 <thoughtpolice> by any definition of the word, imo.
16:05:07 <olsner> thinking of simply churning out ugly LLVM code and hope LLVM takes care of optimization
16:05:09 <pjd> lament: Python lifted list comprehenions
16:05:27 <olsner> (that still leaves syntactic and semantic analysis, of course)
16:05:30 <thoughtpolice> I've heard things about LLVM
16:05:38 <thoughtpolice> but I have no idea really how it works or what it's exact purpose is.
16:05:54 <lament> haskell wasn't the first language to have list comprehensions...
16:06:09 <Mat^> olsner: doesn't parser do syntatic analysis?
16:06:21 <pjd> lament: oh, missed the "introduced"
16:06:38 <pjd> type classes are probably the most noticeable feature Haskell introduced
16:07:00 <olsner> yes, but the parser is very incomplete thus far
16:07:09 <aFlag> pjd, even more than monads?
16:07:17 <slava> glguy: i found a proper fix; i have to use a gl extension to do a partial swap
16:07:24 <lament> what about monads, STM?
16:07:29 <slava> glguy: if you have time, please test the darcs version (with no addition hackery needed)
16:07:33 <pjd> aFlag: monads come from category theory
16:07:36 <Mat^> ok, I am going back to my compiler (there is only support for doubles in intermediate language -> assembly translator to do ;) )
16:08:11 <aFlag> Mat^, that code I sent you didn't work?
16:08:24 <lament> pjd: haskell was certainly the first to use monads to combine state transformers in a programming language
16:08:51 <Mat^> aFlag: well, I didn't try :S I am new to haskell and I am a little scared of monads ;P
16:09:14 <lament> Mat^: please don't be scared of monads. They don't bite :)
16:09:15 <scook0> monads are warm fuzzy things!
16:09:25 <Mat^> well, actually, I don't use monads at all
16:09:36 <Mat^> except in main and in parser :P (parsec)
16:10:05 <thoughtpolice> then you're missing out on the fun stuff. :>
16:10:54 <Mat^> oh, trust me, semantic analysis is fun ;P
16:10:58 <Mat^> even without monads ;P
16:11:30 <lament> @quote stopped
16:11:30 <lambdabot> No quotes match. That's something I cannot allow to happen.
16:11:32 <lament> @quote stopp
16:11:32 <lambdabot> No quotes match. It can only be attributed to human error.
16:11:35 <lament> err
16:11:37 <lament> @quote stop
16:11:37 <lambdabot> dons says: boegel, stop polluting the quote-space please
16:11:46 <lament> -_-
16:12:01 <Mat^> thoughtpolice: but I must admit, creating 30 lines main in 5 hours was some kind of fun
16:12:14 <Mat^> voodoo programming ;P
16:12:43 <lament> that's nothing.. after a couple days, it will take you even longer than that to read it :)
16:13:48 <Mat^> well, my whole haskell code looks like write only
16:13:52 <Mat^> not only main ;P
16:17:39 <Mat^> I wonder, how long my code would have been in C =)
16:22:00 <thoughtpolice> Mat^: any source to be released? :p
16:22:42 <Mat^> thoughtpolice: no, it's coursework ;P
16:23:02 <Mr_Awesome> @src (.)
16:23:03 <lambdabot> (.) f g x = f (g x)
16:23:09 <thoughtpolice> hah. hopefully when I get to college and have to write stuff, I'll be allowed to use haskell at some point. :)
16:23:12 <Mr_Awesome> whee
16:23:18 <psykon> hey guys
16:23:27 <psykon> a good book/tutorial on haskell?
16:23:44 <Mat^> thoughtpolice: I was hoping I would be allowed to write it in C++ :P
16:23:47 <thoughtpolice> (i might be able to deal with something else like python though. if it is java I might have to suicide.)
16:24:12 <Mat^> but, I must say, haskell isn't so bad ;>
16:24:47 <Mat^> I just wish my code wasn't write only :S
16:24:49 <TSC> We make our students here use Java
16:25:12 <thoughtpolice> :( i would probably cry. and then everybody would look at me.
16:25:24 <Mat^> TSC: only? ;>
16:25:26 <Saizan> i cry every night..
16:25:39 <Mat^> during two semesters I had to use C, C++, java, C# and mainly haskell ;>
16:25:39 <TSC> Well, in the particular unit I teach
16:25:50 <TSC> Some other subjects use other languages
16:25:55 <thoughtpolice> Saizan: but do people watch you at that time?
16:25:59 <jedai> Mat^: You can write readable code in Haskell, first you need to find an appropriate abstraction and then have some experience to write idiomatic code (and be able to read it)
16:26:00 <Mat^> mhm ;>
16:26:13 <Mat^> jedai: I know, I can ;>
16:26:16 <Saizan> i've to do a small algorithm in Java for a lab since december..
16:26:22 <Mat^> if it was impossible, then ppl wouldn't use it ;>
16:26:34 <Mat^> but I can't (yet ;> )
16:27:30 <Mat^> oh, I forgot, I also had to write pretty much in x86 assembly this semester :P
16:28:11 <jedai> Mat^: The "problem" too is that people think they ought to be able to read at a certain speed, the same for all languages, but for Haskell in which 2 lines could sum up 40 lines in others languages, it's a little bit of a wishful thinking ^^
16:29:19 <jedai> Mat^: Your courses seem to have a nice variety, I wish I could have the same... :'(
16:29:21 <Mat^> jedai: it's not a problem in my case, with my code there is problem with function naming, data naming etc
16:30:04 <jedai> Mat^: Well that's lazyness in action.... ;-)
16:30:32 <Mat^> yes, I must admit, we can learn everything here ;>
16:31:15 <hpaste>  oerjan annotated "Unification would give infinite type" with "correction" at http://hpaste.org/2491#a5
16:34:00 <oerjan> DukeDave: i made a stupid error yesterday which i only realized when i woke up
16:34:56 <oerjan> (should have actually tried the code :D)
16:35:16 <byorgey> @where yaht
16:35:17 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:35:24 <byorgey> psykon: ^^ is a good place to start
16:35:53 <byorgey> psykon: also check out the wiki, lots of good stuff there, and links to other things
16:35:56 <byorgey> http://haskell.org/haskellwiki/Haskell
16:35:57 <lambdabot> Title: Haskell - HaskellWiki
16:36:14 <psykon> byorgey: i've been reading that actually
16:36:22 <psykon> but i don't find it very good
16:37:24 <balodja> Guys, would you advise me some papers about lazyness? I want to know, which functions are treated to be tail-recursive, and which aren't.
16:37:28 <byorgey> psykon: oh, ok.  what's your background?  what don't you like about yaht?
16:37:46 <psykon> it doesn't explain things, it just right into examples
16:37:50 <psykon> *jumps
16:38:21 <psykon> and it treats you like you're dumb :)
16:39:00 <byorgey> psykon: aha, ok.  perhaps you would like the "gentle introduction" better
16:39:05 <byorgey> @go gentle introduction to haskell
16:39:07 <lambdabot> http://www.haskell.org/tutorial/
16:39:07 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
16:39:34 <byorgey> psykon: don't let the title fool you, it doesn't treat you like you're dumb =)
16:39:52 <psykon> ^^
16:40:13 <thoughtpolice> @tell bos good fix for pcap 0.3.2; I uploaded the new hsns and I'll be sure to give you much karma next time I get the chance :)
16:40:14 <lambdabot> Consider it noted.
16:40:17 <thoughtpolice> alright well anyway,
16:40:25 <thoughtpolice> i'm out. :>
16:40:59 <aFlag> hm, I can't seem to find hdbc documentation (a tutorial explaning how to use it rather than a API page) does anyone know where can I find it?
16:41:41 <oerjan> test++
16:53:11 <hpaste>  llewyenoh annotated "my battery parser" with "Modified indicator cannot evaluate battery life" at http://hpaste.org/2507#a1
16:55:27 <psykon> i'm not getting this "data" thing
16:55:52 <llewyenoh> never mind, don't bother with my hpaste, figured out that my syntax was different
16:56:25 <oerjan> psykon: how so?
16:56:25 <Excedrin> what sort of type should I use to represent dollars and cents? is there something already?
16:56:39 <pjd> Excedrin: maybe just cents
16:56:41 <psykon> oerjan: they talk about constructors
16:56:53 <psykon> do i have to define the constructor?
16:56:55 <idnar> heh, talking of write-only code, my initial attempts at Haskell code seem to be read-only
16:56:57 <pjd> you can always split off the dollars
16:57:07 <Saizan> ?hoogle Fixed
16:57:07 <lambdabot> System.Win32.File.dRIVE_FIXED :: DriveType
16:57:08 <lambdabot> System.Win32.Mem.gMEM_FIXED :: GlobalAllocFlags
16:57:08 <oerjan> yes
16:57:26 <idnar> ie. looking at the code I've written, I can easily see what it does, but it's written using trial/error in the interpreter, @pl, etc.
16:57:27 <Excedrin> is rounding correct if I use an Int for cents? (ignoring overflow)
16:57:35 <oerjan> @src Either
16:57:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:57:38 <EvilTerran> Excedrin, i'd make a newtype of Int or Integer with a custom Read/Show (for cents, yes)
16:57:44 <pjd> psykon: "constructor" is roughly just the name for values of the type, to the right of the =
16:57:45 <oerjan> @src Maybe
16:57:45 <lambdabot> data Maybe a = Nothing | Just a
16:58:05 <oerjan> the constructors for Maybe are Nothing and Just
16:58:23 <psykon> they give this example
16:58:28 <psykon> data Point a = Pt a a
16:58:37 <EvilTerran> Excedrin, as in, bankers' rounding? i doubt that's garunteed by the report. if anything, it may prescribe some other rounding style, but i suspect it's undefined.
16:58:42 <psykon> and then just assume it's the most natural thing in the world
16:58:51 <ddarius> > 3.156 :: Fixed E2
16:58:52 <lambdabot>   Not in scope: type constructor or class `E2'
16:59:04 <EvilTerran> :kind Fixed
16:59:06 <pjd> psykon: in that example, Point is the type, and Pt is the constructor
16:59:15 <ddarius> :k Fixed
16:59:17 <lambdabot> * -> *
16:59:22 <psykon> pjd: is a constructor a function?
16:59:22 <oerjan> psykon: Pt is the data constructor, which can use to either create or take apart values of the new type
16:59:25 <pjd> you use Pt to construct values of type Point
16:59:34 <pjd> psykon: it's close
16:59:52 <pjd> it's sort of like a function that doesn't compute anything, but stores what you give it
16:59:59 <oerjan> psykon: a constructor is a function, but also a pattern
17:00:13 <pjd> and later lets you deconstruct to get the stored values out again
17:00:29 <oerjan> it is used as a function when you create values and as a pattern when you take them apart
17:00:37 <mdmkolbe> I have a small haskell program that is performing slowly, how do I find what is causing the slow down?
17:00:48 <pjd> @type Just
17:00:50 <psykon> so let's say we had that Point
17:00:50 <lambdabot> forall a. a -> Maybe a
17:01:13 <pjd> there you can see Just has a type, like a function
17:01:15 <oerjan> so, e.g. let val = Pt 1 1 in case val of Pt x y -> x+y
17:01:15 <psykon> couldn't i create Point's like this: Pt 2 2 ?
17:01:23 <mdmkolbe> psykon: have you used Scheme?  "cons" is the constructor for pairs.  Just image the same thing for other types of data.
17:01:24 <oerjan> yes
17:01:31 <ddarius> Just is a function in every sense.  It is a special function, but still a function.
17:01:34 <psykon> mdmkolbe: yes i've used scheme
17:01:44 <idnar> :type Just
17:01:48 <ddarius> :t Just
17:01:51 <lambdabot> forall a. a -> Maybe a
17:01:51 <idnar> oops
17:01:57 <oerjan> psykon: have you used common lisp's setf?
17:02:04 * idnar missed pjd doing that
17:02:12 <psykon> oerjan: nop
17:02:19 <oerjan> er, that may not be such a good example anyhow
17:02:50 <psykon> ghc is bugging about not having a definition of Show for Point
17:02:55 <psykon> *bugging me
17:03:04 <psykon> or something of the sort
17:03:12 <Laney> What does "managing them ziplessly" mean in the HAppS blurb?
17:03:38 <pjd> psykon: oh, you probably want to add a "deriving Show"
17:03:58 <mdmkolbe> psykon: add "deriving (Show)" after "data Proint = Point Int Int" or what ever you have
17:04:21 <pjd> when you evaluate something in ghci, it needs a Show instance to show the value to you
17:04:24 <EvilTerran> hehe, Proint
17:04:25 <coffeemug> ?src Monad
17:04:25 <lambdabot> class  Monad m  where
17:04:25 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:04:25 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:04:25 <lambdabot>     return      :: a -> m a
17:04:25 <lambdabot>     fail        :: String -> m a
17:05:37 <pjd> psykon: the "deriving" makes Haskell figure out a default instance, but you can also supply your own
17:05:41 <mdmkolbe> psykon: Haskell doesn't provide a default show instance (which is how you print things in haskell) unless you ask it to (which is what "deriving" does).  That way you can write your own custom printer if needed (e.g. Data.Set.Set has a printer that hides the internal tree structure and just shows you the data as if it were a list)
17:06:04 <mdmkolbe> err.. yeah, what pjd said
17:06:07 <psykon> i need to read more :)
17:06:39 <oerjan> coffeemug: >> and fail have defaults, so you rarely need to define them, especially >>
17:07:00 <oerjan> @src >>
17:07:00 <lambdabot> m >> k      = m >>= \_ -> k
17:07:04 <coffeemug> oerjan: yeah, I know
17:07:05 <oerjan> @src fail
17:07:05 <lambdabot> fail s      = error s
17:07:07 <coffeemug> thanks :)
17:07:21 <coffeemug> hmm
17:07:37 <mdmkolbe> coffeemug: also note that fail is not the same as mzero.  The later is math the former is a hack around pattern match failure in a "do".
17:07:47 <coffeemug> I don't quite understand where Monad, and especially MonadPlus came from
17:08:02 <coffeemug> I mean, I understand what they do, what their use is, etc.
17:08:11 <coffeemug> but how did this come about?
17:08:28 <mdmkolbe> coffeemug: do you mean "how did they get invented?"
17:08:48 <coffeemug> some guy just came up with the idea that you could abstract *all* sequencing operations into Monad and MonadPlus
17:08:58 <coffeemug> that's a crazy insight
17:09:07 * wli fails to install gslhaskell and discovers that the CLAPACK FFI bits aren't modern Haskell.
17:09:11 <coffeemug> mdmkolbe: yeah, I guess so
17:09:16 <coffeemug> I know they're from category theory
17:09:16 <oerjan> coffeemug: basically you leave fail as it is unless your monad is also MonadPlus, in which case you make it consistent with that
17:09:30 <idnar> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
17:09:33 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
17:10:15 <mdmkolbe> coffeemug: well they were needed for the longest time b/c without them haskell couldn't do IO.  I think it was Moggi that first advocated using them so if you really want the insight you could find his papers.
17:10:40 <idnar> (that doesn't directly relate to the question, but I thought it did a good job of suggesting that it's not such a crazy insight)
17:11:10 <ddarius> Laney: It's some colloquialism.
17:11:14 <oerjan> i am not sure if Moggi actually advocated using them directly in programming, he used them in the semantics didn't he? (i haven't read the papers either)
17:11:38 <Laney> ddarius: I figured, but what does it refer to, if anything?
17:11:46 <wli> mdmkolbe: Haskell could do IO without them.
17:11:57 <ddarius> Laney: Easily I think.
17:12:05 <ddarius> Haskell -did- IO without them.
17:12:09 <wli> mdmkolbe: Continuation-based IO was the standard for non-strict languages prior to monadic IO.
17:12:18 <mdmkolbe> if you look in the right places the type signature for >>= does appear quite a few places, it just took someone to realize that they were all the same (e.g. concatMap and others)
17:12:21 <ddarius> oerjan: He didn't, but I doubt he'd consider it a particularly bad idea.
17:12:26 <coffeemug> well, monadic IO *is* continuation based IO
17:12:27 <coffeemug> :)
17:12:38 <ddarius> coffeemug: No.  It isn't.
17:12:51 <aFlag> I never quite got what continuations really are
17:13:01 <coffeemug> ddarius: it has to be, how would you ensure order otherwise?
17:13:12 <ddarius> aFlag: Learn CPS.
17:13:31 <ddarius> coffeemug: Just that you -can- specify evaluation order with CPS doesn't mean that it's the -only- way to.
17:13:38 <conal> does anyone know how to tell ghci to report GC stats as GCs happen?
17:13:52 <mdmkolbe> aFlag: you could try reading the Control.Monad.Cont implementation (that would be hard for some, but the fastest way for others.  it depends on your learning style)
17:13:55 <Excedrin> I have a type like data Foo = A | B | C, and I want data Bar = A Int | B Int | C Int, what do I need?  data Bar' a = Bar' a Int, data Bar = Bar' Foo ?
17:14:00 <conal> or to tell ghc
17:14:02 <coffeemug> ddarius: in a lazy language it's the only way that I know of
17:14:20 <oerjan> Excedrin: you cannot have the same constructors in two types
17:14:38 <coffeemug> and bind essentially does CPS
17:14:40 <mdmkolbe> coffeemug: CPS forces order of evaluation.  CPS fits within the Monad model, but not all Monads are CPS.
17:14:42 <ddarius> coffeemug: non/strictness is irrelevant.
17:14:44 * wli notes that with the aid of an eigensolver one can do the bits therp wanted to for a general non-degenerate non-parabolic quadric surface.
17:14:49 <coffeemug> it just abstracts the application part
17:14:53 <wli> In N dimensions, even.
17:14:59 <oerjan> try data Foo a = A a | B a | C a and type Bar = Foo Int
17:15:23 <coffeemug> just look at >>
17:15:26 <hpaste>  fnord123 annotated "mapTreeM" with "mapTreeM 2" at http://hpaste.org/2488#a2
17:15:29 <Excedrin> oerjan: thanks
17:15:41 <coffeemug> default definition is \_->...
17:15:44 <coffeemug> that's essentially CPS
17:16:26 <coffeemug> bind takes a value and passes it to a function that does something with it
17:16:29 <coffeemug> that's pretty much CPS
17:16:36 <coffeemug> by definition
17:16:50 <mdmkolbe> coffeemug: the default definition is in terms of ">>=", it does not imply CPS though when you force someone to write in monadic style you force them to do similar transforms as would happen with CPS
17:16:54 <fnord123> Hi again oerjan. Last night you helped tremendously with my understanding of making monadic versions of traverse functions. This time I'm putting in a Maybe and I've run into some more confusion.
17:17:13 <oerjan> Excedrin: alternatively you could do type Bar = (Foo, Int)
17:17:28 <coffeemug> well, that's essentially what I mean
17:17:34 <coffeemug> monads are a generalization of CPS
17:17:43 <Excedrin> oerjan: I like the first one better, is there an advantage to the tuple?
17:18:51 <pjd> coffeemug: http://en.wikipedia.org/wiki/Monads_in_functional_programming#History
17:18:52 <lambdabot> http://tinyurl.com/y586b9
17:19:06 <oerjan> Excedrin: just that you don't need to redefine Foo, i guess
17:19:28 <pjd> Eugenio Moggi wrote the seminal paper in 1991
17:19:34 <oerjan> fnord123: will take a look
17:19:59 <ricky_clarkson> coffeemug: They seem a specialisation to me, but I'm no expert.
17:20:09 <slava> hey ricky_clarkson
17:20:27 <coffeemug> ricky_clarkson: I think it's the other way around
17:20:40 <ricky_clarkson> slava: Good day to you.
17:20:47 <coffeemug> you can do all sort of CPS in Monads but you can't implement all monads in CPS
17:20:54 <coffeemug> sounds like monads are a generalization :)
17:21:09 <coffeemug> MonadPlus is a generalization of Monads and arrows are a generalization of MonadPlus
17:21:09 <fnord123> aFlag, continuations are first class stacks. Most languages give you one continuation to play with - the call stack. Continuations in scheme let you store a call stack and continue in another one for a bit and then resume in the previous stack
17:21:14 <coffeemug> when does it end!!!
17:21:15 <coffeemug> :)
17:21:24 <ricky_clarkson> What monads can you not implement in CPS?
17:21:49 <dibblego> coffeemug, can you implement all forms of CPS with a monad (and if so, then what is the point of arrows?)
17:22:01 <slava> read the paper on arrows
17:22:09 <fnord123> or some call continuations 'functions that dont return'
17:22:12 <slava> they're more general
17:22:17 <coffeemug> ricky_clarkson: if you don't own code that does the CPS transformation you cannot implement all monads
17:22:20 <dibblego> yes, that's my point
17:22:23 <mdmkolbe> coffeemug: Arrows are a generization of monads you don't need the monad plus.
17:22:47 <coffeemug> and if you modify CPS code you effectively are playing with monads
17:22:55 <coffeemug> mdmkolbe: right, I realized that after I typed it
17:23:00 <dibblego> a yes answer to that question seems to imply no use for arrows; I conjecture that the answer is no
17:23:24 <coffeemug> well, I know little about arrows
17:23:41 <mdmkolbe> coffeemug: not all monads are easily encodes as CPS (e.g. non-det, reader, state, etc.).  Not all Arrows are monads (nor can they be).
17:23:43 <coffeemug> could someone explain what's the point of arrows in one sentence? :)
17:23:58 <slava> first-class computations
17:24:32 <coffeemug> aren't monads first class computations as well?
17:24:42 <coffeemug> you can pass them around, evaluate them, etc.
17:24:50 <fnord123> slava, how would you describe the difference between a computation and an expression?
17:25:08 <mdmkolbe> coffeemug: The set of data types that can become arrows is larger than the set that can become monads.  (Since they are more general and don't place as many demands on the data type)
17:25:09 <araujo> coffeemug, arrows are a kind of generalized monads
17:25:11 <Saizan> only in part, because the computation can depend on previous inputs
17:25:28 <coffeemug> mdmkolbe: like Set?
17:25:50 * pjd dislikes the "monads are computations" notion
17:25:51 <mdmkolbe> coffeemug: I'd have to read the paper again to remember.
17:26:10 <mdmkolbe> arrows are to functions as monads are to computations
17:26:20 <pjd> it's entirely unenlightening
17:26:57 <coffeemug> mdmkolbe: sort of like a generalized apply?
17:27:31 <mdmkolbe> coffeemug: more like a generalized function composition (i.e. (.) ~~~ (>>>))
17:27:37 <coffeemug> right
17:27:41 <coffeemug> yeah, that's what I meant
17:27:51 <coffeemug> generalized composwe
17:27:53 <coffeemug> compose
17:27:56 <Saizan> when you've m >>= f you can't inspect the whole computation until you run m and feed the output to f, with f >>> g, both f and g are data and so >>> can inspect them
17:28:04 <coffeemug> although compose and apply are two sides of the same coin
17:28:07 <mdmkolbe> coffeemug: just as monad only get unwrapped at the top level, arrows only get "applied" at the top level
17:28:36 * mdmkolbe likes Saizan's explanation
17:29:20 <coffeemug> Saizan: aren't f and g both functions?
17:29:29 <coffeemug> what kind of inspection would you do?
17:29:41 <Saizan> no, f and g don't need to be functions
17:29:44 <mdmkolbe> coffeemug: f and g are arrows
17:29:48 <mdmkolbe> @type (>>>)
17:29:49 <pjd> coffeemug: one way to view it is that monads make the structure of a function's output abstract (a -> m b)
17:29:50 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
17:29:58 <pjd> comonads make the structure of a function's input abstract (w a -> b)
17:30:00 <coffeemug> ah
17:30:05 <pjd> and arrows make both abstract
17:30:28 <mdmkolbe> pjd: I think arrows make the entire function abstract not just the input and the output
17:30:30 <EvilTerran> (>>>) :: (Arrow (~>)) => b ~> c -> c ~> d -> b ~> d
17:30:39 <Saizan> well they are reified functions if you wish
17:30:39 <chessguy> i wonder if it would be possible to write a program to count the number of "types" of chess positions, where by "type" i mean an enumeration like 2 bishops, 3 pawns and a king vs. a bishop a knight, 4 pawns, and a king
17:30:56 <pjd> mdmkolbe: probably;  i don't really grasp arrows yet :)
17:31:19 * EvilTerran thinks infix type variables make an obscene amount of difference to the legibility of arrow types
17:31:44 <oerjan> EvilTerran: probably why they were implemented?
17:31:52 <EvilTerran> quite possibly.
17:32:06 <EvilTerran> that or "we can do it with values, why not do it with types too?"
17:32:13 <conal> oerjan: yes -- that's exactly why infix type vars went into ghc
17:32:15 <mdmkolbe> EvilTerran: does ghc have infix type *variables*? (I know it has infix type constructors)
17:32:21 <coffeemug> pjd: what do comonads do?
17:32:27 <conal> and doing so turned out to simplify the grammer
17:32:29 <LoganCapaldo> infix variables?
17:32:44 <LoganCapaldo> How do variables have a fixity?
17:32:45 <conal> yes, infix variables
17:32:55 <conal> just like (+), but for types
17:32:57 <pjd> coffeemug: they're the categorical dual to monads
17:33:08 <pjd> same kind of thing as foldr and unfoldr
17:33:16 <pjd> well, sort of
17:33:25 <EvilTerran> mdmkolbe, yeah. that type for (>>>) i mentioned above works fine in GHC.
17:33:30 <coffeemug> so they 'unfold' the computation? :)
17:33:35 <pjd> no :)
17:33:45 <mdmkolbe> EvilTerran: cool
17:33:50 <pjd> comonads are basically monads with the arrows reversed
17:33:53 <oncenull> @data Color = Red | Green | Blue
17:33:53 <lambdabot> Unknown command, try @list
17:33:57 <oncenull> @list
17:33:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:34:14 <EvilTerran> I'm afraid you can't define types for lambdabot, oncenull.
17:34:16 <pjd> so instead of return :: a -> m a, you have coreturn :: w a -> a
17:34:17 <glguy> oncenull: lambdabot doesn't let yo do that
17:34:26 <pjd> (w is the conventional letter for comonads, i think)
17:34:30 <LoganCapaldo> conal, I still don't follow, type variables are things like the a in data List a = Cons a List | Nil right?
17:34:39 <oncenull> :(
17:34:39 <EvilTerran> LoganCapaldo, yes.
17:34:44 <pjd> and cojoin :: w (w a) -> w a
17:34:44 <coffeemug> ah I see
17:34:47 <conal> LoganCapaldo: yes
17:35:01 * glguy thinks he wants: a b c to become b `a` c
17:35:02 <coffeemug> what would be the use of that, though?
17:35:03 <glguy> at the type level
17:35:07 <LoganCapaldo> So what would an infix type variable look like?
17:35:17 <EvilTerran> or the a in class Arrow (~>) where (>>>) :: (Arrow (~>)) => b ~> c -> c ~> d -> b ~> d
17:35:24 <EvilTerran> *the (~>) in
17:35:35 <fnord123> Hm, are people using CPS in day to day code? I thought it was merely a useful intermediate stage in compilation.
17:35:36 <conal> LoganCapaldo: yeah, what EvilTerran said
17:35:37 <pjd> well, just for context, both monads and comonads are functors
17:35:45 <wli> Adjoint functors?
17:35:58 <mdmkolbe> fnord123: yes!!!
17:36:03 <pjd> wli: i wish i knew :)
17:36:06 <EvilTerran> anyhow. to bed!
17:36:14 <fnord123> Isn't it tremendously difficult to debug?
17:36:20 <pjd> coffeemug: so fmap is what they have in common
17:37:19 <pjd> but where monads know how to lift a value (return), comonads collapse a value (coreturn/extract)
17:37:21 <ricky_clarkson> fnord123: I use CPS a little in Java, with an implementation/emulation of the Maybe and Either monads.
17:37:42 <oncenull> is it legal to do data Color Int = Color Int ?
17:37:48 <coffeemug> hmm
17:37:54 <coffeemug> I'll have to read about comonads and arrows
17:38:10 <mdmkolbe> fnord123: Most CPS code is done by letting the compiler do the transformation for you.  internally CPS has certain advantages for optimization and such.  If you ever need to expose CPS to the user, you do something like call/cc.  Directly writting CPS code is rare unless you need to work around a broken language (e.g. with CPS you can make a call-by-value language into a call-by-need language and
17:38:10 <mdmkolbe> vice versa)
17:38:17 <coffeemug> hmm
17:38:24 <coffeemug> I just implemented Maybe monad in CL
17:38:24 <mdmkolbe> oncenull: no
17:38:26 <coffeemug> pretty cool :)
17:38:43 <coffeemug> implementing 'do' syntax seems very challanging though
17:38:47 <fnord123> mdmkolbe: that's what i thought. :)
17:38:52 <ddarius> wli: Compositions of adjoints.  Not necessarily ones themselves.
17:39:01 <coffeemug> but that would be the only code walker anyone ever needs
17:39:24 <ddarius> CPS is used.
17:39:24 <pjd> coffeemug: intuitively, where monads describe fancy outputs, comonads describe fancy inputs
17:39:42 <pjd> usually something involving context
17:40:00 <coffeemug> hmm
17:40:01 <mdmkolbe> fnord123: oh yeah, CPS is used by some web-based applications b/c it makes the client-server-client-server back and forth easier to mangage, but even that is still "internal" to what ever tool you are using
17:40:01 <coffeemug> ok
17:40:06 <pjd> coffeemug: think of cellular automatons
17:40:23 <pjd> there you have a grid, and a function applied to contexts of the grid
17:40:32 <coffeemug> pjd: actually this sort of helps
17:40:52 <fnord123> mdmkolbe: right. iirc, seaside encodes the continuation into a url
17:41:21 <coffeemug> I'm working on a Lisp framework that will soon manage flow with continuations
17:41:30 <hpaste>  oerjan annotated "mapTreeM" with "does this work?" at http://hpaste.org/2488#a3
17:41:41 <coffeemug> fnord123: basically control flow is often managed via adhoc state machines
17:41:49 <pjd> the grid can be considered a comonad
17:41:56 <coffeemug> fnord123: look up state machines as coroutines
17:41:59 <coffeemug> for more info
17:42:07 <pjd> it takes a function from grids to single values (w a -> a)
17:42:14 <mdmkolbe> pjd: what is the type of co-bind again?
17:42:22 <coffeemug> pjd: that sort of makes sense
17:42:25 <coffeemug> I'll have to read a bit more
17:42:49 <pjd> mdmkolbe: w a -> (w a -> b) -> w b
17:43:02 <pjd> so like bind, with the arrows reversed
17:43:13 <Saizan> ?google evaluating cellular automata is comonadic
17:43:15 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
17:43:16 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
17:43:21 <pjd> Saizan: thanks
17:43:45 <pjd> probably just go read that for maximum enlightenment :)
17:44:37 <mdmkolbe> who is sigfpe?
17:44:58 <fnord123> oerjan++
17:45:19 <pjd> so re. the type of cobind, you could read that as "input grid -> (local context -> value) -> output grid"
17:45:32 <pjd> in terms of cellular automatons
17:45:44 <Saizan> mdmkolbe: dpiponi as irc nick, but he's rarely here
17:45:45 <pjd> sigfpe is Dan Piponi
17:45:54 <pjd> the Academy Award winning Haskeller
17:46:21 <mdmkolbe> pjd: as in Oscar?
17:46:30 <fnord123> oerjan: it worked a treat. That's twice where liftM has saved me when I didn't see it. Does anyone have a good tutorial on liftM?
17:46:38 <coffeemug> Saizan: that's pretty cool
17:46:43 <fnord123> @hoogle liftM
17:46:44 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
17:46:44 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:46:44 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
17:46:45 <coffeemug> I'll have to read that article carefully
17:47:00 <pjd> mdmkolbe: he does film computer graphics
17:47:17 <mdmkolbe> pjd: cool
17:47:47 <pjd> many monads have related comonads, by the way
17:47:58 <pjd> so there's an OI monad, for example
17:48:45 <pjd> which is like IO, but binding functions of type (OI a -> b) instead of (a -> IO b)
17:49:02 <coffeemug> you mean OI comonad?
17:49:07 <oerjan> fnord123: the main thing is to check carefully which subexpressions have monadic results
17:49:07 <pjd> right, sorry :)
17:49:13 <coffeemug> which does what?
17:49:26 <pjd> fnord123: liftM == fmap
17:49:31 <coffeemug> given some complex input extracts a simple value?
17:49:49 <oerjan> and whenever you try to apply a pure function to something monadic, you need a liftM* or similar.
17:50:07 <fnord123> comonads clearly should have been called danoms
17:50:16 <oerjan> s/pure/non-monadic/
17:50:34 <pjd> fnord123: good idea!
17:50:52 <oerjan> fnord123: co- is an established prefix for reversing things in category theory, though
17:51:40 <hpaste>  chessguy pasted "An enumeration problem" at http://hpaste.org/2508
17:51:46 <fnord123> ok. I see that it takes some function and applies the monad to each argument (depending on the liftM#)
17:51:49 <pjd> oops
17:52:45 <fnord123> oerjan: I didn't know that. I thought it was like coroutine. so if you had two monads interacting you would need comonads. (before today's discussion and before seeing anything apart from the name on the title of papers)
17:53:18 <pjd> coffeemug: if you think of (a -> IO b) as turning a pure input to a deferred instruction
17:53:24 <oerjan> fnord123: in this case since x1' is non-monadic we include it in the liftM. If it had not been the first argument you could have put it inside (return ...) instead
17:53:28 <coffeemug> hmm
17:53:29 <coffeemug> I see
17:53:42 <pjd> then (OI a -> b) takes a deferred input value to a pure result
17:54:06 <llewyenoh> is there an equivalent to printf in haskell?
17:54:08 <wli> Is there a linear algebra lib compatible with ghc-6.6.1 out there anywhere?
17:54:14 <coffeemug> llewyenoh: yes, printf :)
17:54:18 <coffeemug> ?src printf
17:54:18 <lambdabot> Source not found. Wrong!  You cheating scum!
17:54:20 <pjd> so the "trick" of the IO monad is that you can only create deferred IO instructions, not run them (only the special main can run them)
17:54:45 <Saizan> fnord123: to make two monads interact you usually rewrite one as a monad transformer
17:54:48 <llewyenoh> hahahhaha not in lambdabot apparently
17:54:48 <wli> gslhaskell and the clapack/haskell interface appear broken.
17:55:02 <pjd> the trick of the OI comonad is that you can only consume pending values, not create them
17:56:18 <oerjan> :t printf
17:56:19 <lambdabot> forall r. (PrintfType r) => String -> r
17:56:30 <oerjan> @src PrintfType
17:56:30 <lambdabot> Source not found. My pet ferret can type better than you!
17:57:02 <fnord123> :k PrintfType
17:57:03 <oerjan> fnord123: i guess a coroutine somehow reverses the relationship between caller and callee
17:57:06 <lambdabot> Class `PrintfType' used as a type
17:57:08 <Saizan> pjd: i seem to recall there were doubts on the ref.transparency of the OI comonad?
17:57:17 <glen_quagmire> is haskell RAD? i need to do a project this semester for Extreme Programming. is Haskell suitable? I'm not good enough in haskell to tell it if it's for XP or not
17:57:35 <pjd> Saizan: i don't know enough to confirm or deny that :)
17:57:43 <oerjan> :k (PrintfType r) => r
17:57:45 <lambdabot> *
17:58:25 <oerjan> oncenull: data Color a = Color a is perfectly legal, however
17:58:26 <fnord123> glen_quagmire: you might be more interested in vb, objective C w/ cocoa, or gambit scheme w/ gtk if you want to get some gui stuff working asap
17:58:41 <pjd> oerjan: i think "coroutine" merely suggests coexistince, not any dual
17:58:50 <pjd> coexistence, even
17:58:51 <oerjan> pjd: perhaps
17:59:12 <ChilliX> glen_quagmire: Functional languages are traditionally used for prototype-based development.  So, I'd say Haskell is good for RAD.
17:59:47 <glen_quagmire> fnord123: hrm i think gambit scheme is the only thing available for linux
17:59:56 <oncenull> oerjan, yes
18:00:16 <johnnowak> glen_quagmire: gambit is very nice
18:00:25 <oncenull> oerjan, I'm getting used to Haskell constructors
18:00:33 <oncenull> they seem a little odd to me :S
18:00:48 <pjd> coffeemug: http://www.cs.helsinki.fi/u/ekarttun/comonad/
18:00:49 <lambdabot> Title: Comonads and Haskell
18:00:51 <fnord123> glen_quagmire: you can use python with wxPython, tcl/tk, perltk, or various bindings on gtk. or Qt, or wxWindows on linux
18:01:12 <coffeemug> pjd: thanks
18:01:32 <fnord123> but if you came to #haskell and end up not using haskell, i think you would enjoy scheme the most
18:01:33 <glen_quagmire> well it sounds like anything other than C++/Java willl do
18:01:37 <Saizan> fnord123: gtk2hs is not so bad!!
18:02:25 <glen_quagmire> i read YAHT until chapter 8. i think haskell is a better choice than scheme since i have no experience in scheme
18:02:58 <fnord123> Saizan: it's not bad but if his skill in haskell is not that great I can see this as a large project risk. scheme is an easy to pick up language so he can cruise at his level at a lower risk
18:03:08 <glen_quagmire> unless the professor forces us to make a web app in php
18:03:08 <chessguy> saying that "x is better than y" is stupid until you have some amount of experience in both x and y
18:03:28 <ricky_clarkson> glen_quagmire: I enjoy Scheme, and the recommended book for it, sicp, is better than what I recall of YAHT.
18:03:29 <chessguy> (unless of course, y is java)
18:03:43 <ricky_clarkson> The video lectures are really good too.
18:03:45 <monochrom> heaven is better than hell. I don't have experience with either.
18:03:49 <glen_quagmire> ricky_clarkson: i heard sicp is very difficult to read. harder than yaht
18:04:03 <Saizan> java is mentioned way too often on this channel
18:04:09 <chessguy> @karma java
18:04:09 <lambdabot> java has a karma of -16
18:04:18 <chessguy> java--
18:04:28 <ricky_clarkson> glen_quagmire: I've found it challenging in places, but in good ways.
18:04:36 <Saizan> we had a toy compiler without classes called java--
18:05:12 <ricky_clarkson> glen_quagmire: sicp is more generally about programming than yaht, which is quite Haskell-specific.
18:05:43 <Saizan> well sicp is a book, yaht is a language tutorial
18:05:46 <glen_quagmire> i see. many people recommend that book
18:05:51 <fnord123> glen_quagmire: you need to identify your risks here; if you don't succeed will you fail the class? or will the professor enjoy reading the post mortem anyway?
18:07:02 <glen_quagmire> not sure. 90% of the grade will come from the project. no exam. 10% is from textbook summary
18:07:26 <glen_quagmire> i think it's a good class if i have good classmates
18:08:02 <glen_quagmire> otherwise, if i am forced to work in a group and no one knows haskell and all scream for Java or C#...
18:08:27 <araujo> Haskell is a bad language ; it makes you hate other languages.
18:09:32 <glen_quagmire> i think haskell is good for quizzes
18:10:18 <fnord123> What is the project?
18:11:41 <araujo> glen_quagmire, Even if you are not going to use Haskell in your project, it's still worth learning. I am right now writing Python and i prototype on Haskell first; it has helped me a _LOT_
18:11:46 <glen_quagmire> not decided yet. i'm just exited after the first class
18:12:20 <pjd> coffeemug: another dodgy analogy:  if a monad is like a magic box you can only put stuff into
18:12:29 <pjd> a comonad is like a magic box you can only get stuff out of
18:12:52 <araujo> So i consider Haskell more a meta-language than a language for programming. (ML inheritance coincidence?)
18:13:18 <fnord123> Haskell mainly helps with my C++ template coding when I'm doing money oriented programming
18:13:44 <araujo> Right.
18:14:52 <glen_quagmire> i think someone should write a book for haskell for non programmers. then haskell can be recommended as the first language
18:15:03 <pjd> @remember fnord123 Haskell mainly helps with my C++ template coding when I'm doing money oriented programming
18:15:03 <lambdabot> Done.
18:15:07 <fnord123> pjd, so why does getLine return a monadic value instead of passing it the input prompt and getting a normal value from it?
18:15:08 <ddarius> araujo: Maybe you -should- hate other languages.
18:15:25 <araujo> IT's also easier to think in terms of functional programming than in a procedural language. For example, you can code an algorithm in your mind while having lunch at the same time and get the thing to work right after you type it into the computer.
18:15:46 <ddarius> C++ templates form a lazy purely functional language...
18:15:47 <Pseudonym> Maybe you shouldn't have an emotional investment in your languages.
18:16:13 <Pseudonym> Phil Wadler pointed out that programming language choice is one of the few areas where faith trumps science.
18:16:20 <araujo> glen_quagmire, that book is on the way
18:16:23 <ddarius> pjd: Luckily, a monad is not like a magic box that you can only put stuff into
18:16:34 <ddarius> Pseudonym: Experience
18:17:16 <pjd> ddarius: that was only for when you squint right :)
18:17:17 <ddarius> Pseudonym: If I have direct experience of God, or something I believe to be that, then it is quite reasonable that I believe in God.
18:17:18 <fnord123> Pseudonym: language choice is partially influenced by community and the tools ecosphere. So taking an emotive approach is probably not as stupid as we think
18:17:26 <pjd> Pseudonym: s/faith/culture/
18:17:46 <Pseudonym> While I don't disagree, the problem here is that computer programming is supposed to be scientific.
18:17:46 <glen_quagmire> araujo: are you writing one?
18:17:56 <pjd> programming languages are somewhat like natural language communities in that respect
18:18:08 <araujo> glen_quagmire, no
18:18:12 <fnord123> I think that idea died a little when Dijkstra left us, Pseudonym
18:18:15 <araujo> @where realworldhaskell
18:18:15 <lambdabot> http://www.realworldhaskell.org/
18:18:17 <glen_quagmire> araujo: do you know the title?
18:18:19 <araujo> glen_quagmire, ^^
18:18:22 <glen_quagmire> thanks
18:18:48 * araujo has offered to volunteer for some sections of the book though
18:19:00 <pjd> Pseudonym: *science* is supposed to scientific, but scientists have to deal with just as much politics, fads, infighting, ...
18:19:01 <Pseudonym> fnord: Wadler is still among us.
18:19:28 <ricky_clarkson> So is Knuth, and he thinks it's an art.
18:19:38 <araujo> Pseudonym, Why?
18:19:54 <araujo> Pseudonym, Have you seen the lectures about SICP?
18:20:01 <Pseudonym> From where and when?
18:20:19 <ricky_clarkson> MIT, 1986
18:20:19 <pjd> fnord123: well, getLine doesn't actually return anything; it *is* a monadic value
18:20:19 <araujo> Pseudonym, The SICP video more specifically
18:20:28 <fnord123> pjd, ok.
18:20:29 <pjd> it's a constant
18:20:36 <Pseudonym> No, haven't seen that.
18:20:37 <fnord123> This is an interesting topic but it's 2am, so I must be off.
18:20:52 <araujo> Pseudonym, I recommend it to you, they make an interesting point about what programming and computer science is all about at the beginning of the lectures
18:21:22 <Pseudonym> OK, I'll try to find that.
18:21:22 <zmike> yeah, at least watch the first 15 minutes of the first lecture
18:21:45 <zmike> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
18:21:50 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
18:22:17 <Pseudonym> Thanks.
18:22:38 <ricky_clarkson> I liked that they didn't introduce any assignment operator until about the 6th chapter.
18:23:52 <xorAxAx> @src return
18:23:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:24:22 <ddarius> ricky_clarkson: They implicitly use side-effects and mutable state before then.
18:24:26 <ricky_clarkson> The Spanish Inquisition doesn't seem that impressive now.
18:24:32 <ricky_clarkson> ddarius: How so?
18:25:28 <ddarius> for-each implies using a side-effecting program, the picture language does as well, the generic operators use put and get on some presumably global table,...
18:25:48 <ricky_clarkson> foreach comes after set! in sicp, afaik.
18:26:27 <ricky_clarkson> The picture language, that was so abstract that it doesn't really matter - all that could be specified without side effects and then drawn by something external anyway.
18:26:29 <dozer> ah, my fork of xpickle is almost useable now
18:26:31 <ddarius> They discuss it when they first discuss map which is in like the section on higher-order functions.
18:26:59 <ricky_clarkson> ddarius: They haven't discussed map yet in my following of it.
18:27:03 <ddarius> Or rather list structure I guess.
18:27:11 <ddarius> (No point in talking about map without lists)
18:28:35 <ddarius> I'm rewatching them and I'm back to 5b.
18:28:55 <ricky_clarkson> 6a here
18:29:09 <ddarius> I can't wait to get to 6 again.
18:29:13 <ddarius> Yay streams.
18:29:54 <pjd> ddarius, sure there is:  map with functors!
18:30:25 <wli> Well, map used to be the Functor method and the base was vastly prettier that way.
18:30:33 <ddarius> Except in Scheme.
18:31:03 <pjd> wli: why did it regress?
18:31:27 <pjd> the Great Scare of '98 i keep hearing about?
18:31:41 <oerjan> @quote polymorphic.scare
18:31:42 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
18:31:46 <wli> pjd: I don't know but it's one of the things that doesn't require compiler intrinsics modifications to address with an alternate Prelude.
18:32:07 <wli> pjd: (++) used to be the name for mplus also.
18:32:19 <pjd> is Haskell' targeting this kind of thing?
18:32:24 <oerjan> :t (+++)
18:32:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
18:32:41 <wli> pjd: I haven't the foggiest idea.
18:33:10 <oerjan> pjd: i think it's supposed to be conservative.
18:33:34 <pjd> oerjan: restoring the earlier version is conservative!
18:33:46 <wli> pjd: Reactionary, even!
18:35:56 <wli> I've no clue how to assemble an alternate base library and even less of an idea of how to alter intrinsics such as comprehensions (now restricted to lists where once monads) and do desugaring (now relying on Monad's fail method, formerly reliant upon MonadZero separate from MonadPlus for failure).
18:36:42 <pjd> man
18:36:47 <pjd> i feel cheated
18:36:56 <wli> IOW I am not the man for this job.
18:36:59 <ddarius> There is a GHC option that should make at least two out of three of those things possible.
18:38:37 <pjd> speaking of which, [] should desugar to Monoid
18:39:05 <wli> pjd: MonadZero's zero method (formerly called zero, now mzero).
18:39:09 <ddarius> pjd: Screw that.
18:39:54 <pjd> wli: sorry, i meant list literals in general, not just []
18:40:43 <wli> ddarius: Which two?
18:41:25 <ddarius> The first and the last.  I'm not sure if list comprehension stuff is rebindable.
18:41:56 <oerjan> pjd: that doesn't quite work because you need to define [x] for a single value too
18:42:18 <oerjan> which doesn't exist for all monoids in a way compatible with lists
18:42:51 <Saizan> x `mappend` mempty?
18:43:05 <ddarius> Saizan: That doesn't typecheck.
18:44:06 <pjd> yeah, it's not exactly Monoid i was thinking of
18:44:16 <oerjan> however, you could have a class containing only the pure method from Applicative, and use that for [x]
18:44:25 <oerjan> == return
18:44:34 <pjd> yeah
18:45:46 <pjd> Alternative (i.e. Applicative+Monoid)
18:45:49 <wli> BTW is there a trick to building a 64-bit ghc on a mostly 32-bit userspace?
18:46:10 <oerjan> pjd: yes, but <*> is unnecessary
18:46:25 <pjd> right
18:46:27 <oerjan> @src Alternative
18:46:27 <lambdabot> class Applicative f => Alternative f where
18:46:27 <lambdabot> 	empty :: f a
18:46:27 <lambdabot> 	(<|>) :: f a -> f a -> f a
18:46:46 <pjd> this was discussed here a while ago
18:46:57 <pjd> refactoring all these classes
18:47:15 <oerjan> it really needs the class alias proposal first, though
18:48:43 <pjd> i assume that would mean support for saying the equivalent of Alternative == Applicative + Monoid (for example)?
18:48:50 <pjd> makes sense
18:49:02 <sfultong> oh man... exceptions in STM are not chained through to IO their atomic block resides in?
18:49:11 * sfultong feels cheated
18:49:15 <oerjan> as well as defining things in one sweep
18:49:49 <Pseudonym> Yeah, we definitely need class aliases.
18:49:58 <oerjan> like Monad could be a subclass of Functor with default fmap = liftM
18:50:13 <sjanssen> sfultong: isn't that intentional?
18:50:30 <sjanssen> sfultong: I imagine an exception works just like 'retry'
18:50:38 <oerjan> and you could define all the methods for Alternative including the superclasses in the same block
18:50:42 <wli> Basically I can only slurp 32-bit stuff from Debian, but it'd be nice if I could build a 64-bit ghc.
18:50:43 <sfultong> wait, nevermind
18:50:51 <sfultong> I was wrong :-P
18:52:37 <oerjan> i think it would mean some multiple inheritance problems however
18:53:02 <pjd> oerjan: is there any reason to have both fmap and liftM in the first place?
18:53:35 <wli> pjd: Don't forget the numerous duplications of fmap named "map"
18:53:38 <ddarius> Not really.
18:53:59 <oerjan> pjd: without class aliases, it would be necessary to define fmap whenever you define a Monad
18:54:03 <pjd> wli: and pure/return
18:54:43 <pjd> the class alias proposal is great
18:54:53 <Saizan> oerjan: i don't think that would so bad.. if you're very lazy you can just use >>= id
18:54:56 <oerjan> because subclasses cannot create defaults for superclass methods
18:55:35 <oerjan> Saizan: >>= id is join, not fmap
18:56:36 <sjanssen> oerjan: I don't think requiring the Functor instance is so onerous
18:56:39 <sjanssen> it's only one line
18:56:41 <oerjan> Saizan: and liftM currently allows people to be that lazy
18:56:51 <Saizan> yeah, well the concept it's the same :)
18:57:40 <Saizan> also liftM is often a poor implemententation for fmap
19:00:29 <Saizan> concatMap (return . f) m  vs. map f m
19:01:14 <oerjan> @src liftM
19:01:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:01:24 <oerjan> @undo do { x1 <- m1; return (f x1) }
19:01:24 <lambdabot> (m1 >>= \ x1 -> return (f x1))
19:01:40 <oerjan> @pl (m1 >>= \ x1 -> return (f x1))
19:01:40 <lambdabot> f `fmap` m1
19:01:48 <oerjan> bah!
19:02:48 <Saizan> \f m1 -> m1 >>=- returnb . f
19:02:53 <Saizan> @pl \f m1 -> m1 >>=- returnb . f
19:02:53 <lambdabot> (line 1, column 26):
19:02:53 <lambdabot> unexpected "."
19:02:53 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
19:02:53 <lambdabot> ambiguous use of a right associative operator
19:03:04 <Saizan> @pl \f m1 -> m1 >>== returnb . f
19:03:04 <lambdabot> (line 1, column 26):
19:03:04 <lambdabot> unexpected "."
19:03:04 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
19:03:04 <lambdabot> ambiguous use of a right associative operator
19:03:44 <Saizan> bah
19:03:52 <oerjan> @pl f . g
19:03:53 <lambdabot> f . g
19:03:57 <Saizan> @pl \f m1 -> m1 >>== (returnb . f)
19:03:57 <lambdabot> flip (>>==) . (returnb .)
19:16:00 <idnar> @src (>>==)
19:16:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:16:24 <idnar> was that a typo, or do I have yet another operator to learn?
19:17:56 <oerjan> it was a way to get around the fact @pl knows about >>=
19:25:18 <wli> Latest darcs of ghc pukes on:
19:25:21 <wli> nativeGen/MachCodeGen.hs:111:27: Not in scope: `assignReg_I64Code'
19:25:46 <wli> Not sure if this is my fault or generalized bleeding edge.
19:26:08 <byorgey> wli: you broke it!
19:30:42 <wli> I've no idea what hit me.
19:34:47 <sorear> wli: looks most related to Been Lippmeier's new register allocator; I64 == itanium?
19:37:18 <Pseudonym> Itanium is one implementation of the IA64 architecture, yes.
19:37:57 <sorear> Pseudonym: I wasn't sure whether I64 meant IA64.
19:38:48 <Pseudonym> Ah, right.
19:39:19 <SamB> what's this about the Itanic?
19:39:45 <sorear> SamB: 19:24 < wli> nativeGen/MachCodeGen.hs:111:27: Not in scope: `assignReg_I64Code'
19:40:07 <hpaste>  Paczesiowa pasted "instance Ix a => Ix [a]" at http://hpaste.org/2510
19:40:07 <sorear> @users
19:40:08 <lambdabot> Maximum users seen in #haskell: 392, currently: 361 (92.1%), active: 8 (2.2%)
19:40:33 <SamB> I thought it hit an AMDburg and sunk
19:40:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2511
19:40:47 <Mat^> http://hpaste.org/2511
19:40:52 <Mat^> can anyone help? :S
19:41:23 <sorear> Mat^: Yes.
19:41:35 <sorear> Mat^: "'\n'" is 3 characters
19:41:39 <sorear> Mat^: '\n' is 4
19:41:54 <chessguy> @src Ix
19:41:54 <lambdabot> class (Ord a) => Ix a where
19:41:54 <lambdabot>     range           :: (a,a) -> [a]
19:41:54 <lambdabot>     index           :: (a,a) -> a -> Int
19:41:54 <lambdabot>     inRange         :: (a,a) -> a -> Bool
19:41:54 <lambdabot>     rangeSize       :: (a,a) -> Int
19:42:03 <sorear> Mat^: Backslash-codes are not handled in file input
19:42:11 <Mat^> sorear: mhm
19:42:23 <Mat^> ok
19:42:49 <Mat^> so it's like "\'\\n\'" :S
19:43:07 <sorear> Yeah.
19:43:09 <oerjan> Mat^: if you want them to be, you could use read for Strings
19:43:15 <sorear> Except you don't need \'
19:43:39 <Mat^> oerjan: tmp2 = read(tmp) ?
19:43:46 <oerjan> (probably an awful hack in this case)
19:44:45 <oerjan> yeah, but parentheses unnecessary, also might fail if tmp does not contain a proper quoted string
19:44:49 <Mat^> or change parse_char
19:45:06 <Mat^> to handle backlash
19:47:31 <Mat^> ok, thanks :>
19:47:41 <oerjan> > lexLitChar "\test"
19:47:42 <lambdabot>  [("\t","est")]
19:48:17 <oerjan> > readLitChar "\test"
19:48:18 <lambdabot>  [('\t',"est")]
19:48:58 <oerjan> > readLitChar "\"test"
19:48:59 <lambdabot>  [('"',"test")]
19:49:22 <oerjan> > readLitChar "\\\"test"
19:49:24 <lambdabot>  [('"',"test")]
19:50:08 <Mat^> shouldn't it retur [('\', ...?
19:50:09 <Mat^> ;>
19:50:34 <oerjan> which one?
19:50:56 <Mat^> 04:48 < oerjan> > readLitChar "\\\"test"
19:51:23 <oerjan> well, first the string gets read as Haskell, so there is actually just one \ in it
19:51:45 <oerjan> and then readLitChar interprets the backslashed character in that string
19:52:10 <byorgey> > readLitChar "\\\\\\\"test"
19:52:11 <lambdabot>  [('\\',"\\\"test")]
19:52:27 <Mat^> ;P
19:53:24 <byorgey> > readLitChar $ fix show
19:53:25 <lambdabot>  [('"',"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\...
19:53:33 <thoughtpolice> hm has anybody ever benchmarked stalin against ghc?
19:53:52 <thoughtpolice> i'm thinking if I could get it set up it might interesting to see.
19:54:03 <byorgey> thoughtpolice: what's stalin?
19:54:24 <thoughtpolice> byorgey: very agressive scheme compiler
19:54:39 <thoughtpolice> in certain cases it's (apparently) been marked to beat C by some good margins
19:55:11 <pgavin> in soviet russia...
19:55:14 <diotalevi> If scheme is dynamic, how does it get so fast?
19:55:32 <thoughtpolice> does lots of analysis; I was looking on c2.com at the SufficientlySmartcompiler article and saw it (although I've read about it plenty before)
19:55:53 <thoughtpolice> jjore: it uses C as an intermediate language (like gambit)
19:56:13 <jjore> ok, but you still need runtime checks for redefinitions of functions and such.
19:56:16 <thoughtpolice> but it does very agressive optimizations to make the generated source extremely fast
19:56:30 <thoughtpolice> it doesn't implement full RnRS
19:56:40 <jjore> RnRS?
19:56:41 <pjd> dionoea: IIRC Stalin is highly targeted toward numerical work
19:56:53 <thoughtpolice> jjore: scheme standards
19:56:59 <jjore> ok.
19:57:12 <thoughtpolice> it uses a subset of scheme that is 'optimized' for optimization, you could say
19:57:21 <pjd> so it probably won't be that compelling for general Scheme code
19:57:30 <thoughtpolice> no, but a benchmark might be interesting.
19:57:35 <thoughtpolice> just to see how fast it particularly is
19:58:01 <pjd> heh, Stalin versus GHC:  who gets the slowest compiler award?
19:58:09 <sjanssen> @where haddock.ghc
19:58:09 <lambdabot> I know nothing about haddock.ghc.
19:58:23 <thoughtpolice> probably stalin.
19:58:35 <thoughtpolice> maybe i'll see :)
19:59:35 <thoughtpolice> oh, i've never really benchmarked any; could anybody recommend some tools? i saw a nice ruby library for generating graphs a while ago in some book...
20:00:46 <sorear> pjd: ever try jhc?
20:01:03 <thoughtpolice> i tried jhc. absurdly long compile times, very small executables. i found it neat. :)
20:01:06 <sorear> pjd: i gave it six hours to compile the prelude (it didn't succeed)
20:01:22 <thoughtpolice> i think it was 20m or so on this box for hello world
20:01:43 <aFlag> are there functions implementing algorithms such as md5 or sha1?
20:01:48 <jjore> So I'm trying to do the exercises in The Haskell School of Expression and I'm stumped on one that's early.
20:02:01 <sorear> are thoughtpolice and pjd the same?
20:02:11 <pjd> not that i know of
20:02:27 <sorear> aFlag: yes, but you're really better off using runInteractiveCommand
20:02:37 <thoughtpolice> no?
20:02:38 <pjd> jjore: ask/paste away
20:02:39 <aFlag> how come?
20:02:40 <thoughtpolice> :(
20:02:43 <pgavin> @list
20:02:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:02:45 <jjore> The instruction was to reimplement getLine with getChar and recursion and I'm trying at http://hpaste.org/2512 but I fail the type checking.
20:02:54 <SamB> sorear: why'd you give it a measly six hours?
20:03:10 <SamB> I'm guessing you've not looked much at the code if you only gave it six hours for such a huge tangle...
20:03:23 <sorear> SamB: Because I don't like running my computer when I'm asleep
20:04:40 <pjd> jjore: what's happening there is that you're trying to call c with "(:)" and "restOfLine" as arguments
20:04:41 <sjanssen> jjore: two problems, "c (:) gL" means apply the 'c' function to the arguments (:) and gL
20:04:47 <pgavin> @djinn Bool -> a -> Maybe a
20:04:47 <lambdabot> f a b =
20:04:48 <lambdabot>     case a of
20:04:48 <lambdabot>     False -> Nothing
20:04:48 <lambdabot>     True -> Just b
20:04:54 <pgavin> bah
20:04:56 <pjd> @stereo
20:04:56 <lambdabot> Unknown command, try @list
20:05:00 <sjanssen> jjore: of course, we know that 'c' is not a function, it's a Char
20:05:23 <pgavin> why isn't this already in the std libs?
20:05:30 <pgavin> I get it all the time
20:05:41 <hpaste>  sjanssen annotated "newb's getLine" with "still not there, but closer" at http://hpaste.org/2512#a1
20:06:20 <Nafai> jjore: Do you mean char instead of c on the last line?
20:06:21 <pgavin> is that something I should post to the libraries list?
20:06:31 <pjd> jjore: are you familiar with () and `` for changing the fixity of functions?
20:07:13 <jjore> Nafai, yes, that's a "type'n'paste" error.
20:07:28 <jjore> pjd, you mean () for grouping, right?
20:07:38 <oerjan> :t fromMaybe
20:07:40 <lambdabot> forall a. a -> Maybe a -> a
20:07:46 <jjore> SOE hasn't covered anything about `` yet.
20:07:55 <pjd> jjore () also does grouping, but it serves another purpose with operators
20:08:05 <pjd> it turns infix operators into prefix ones
20:08:39 <pjd> so "(:) x xs" is another way of writing "x : xs"
20:08:48 <wli> I'm still clueless abour whatever went wrong with the ghc build. My only guess is that it's somehow related to 32-bit userspace and 64-bit kernel.
20:09:01 <jjore> So with "char : restOfLine" I'm up to the error that the type "IO String" can't be matched to "[Char]".
20:09:03 <aFlag> sorear, why am I better off running external programs? There's no implementation of hashing algorithms in th e standard haskell lib?
20:09:21 <jjore> I'd mention the monad explicitly if I knew where it was and how to make it explicit.
20:09:34 <sjanssen> wli: did you try building in a fresh repository?  GHC can be finicky like that sometimes
20:09:44 <pjd> jjore: `` does the opposite, for functions;  you can write "map f xs" as "f `map` xs"
20:09:48 <wli> sjanssen: That was a build in a fresh repository.
20:10:03 <sorear> aFlag: do you really think you can implement a bug-free hashing algorithm faster than C, in less time that it takes to bind to the existing C code?
20:10:30 <pjd> jjore, just checking:  you know that [Char] == String, right?
20:10:41 <jjore> pjd, yes.
20:10:44 <pjd> okay
20:10:51 <jjore> So I would expect [Char] to match against String.
20:11:09 <pjd> right, but it is expecting IO String, not String
20:11:43 <pjd> remember that the result of a do block must be a monad value
20:11:58 <pjd> that's why you say return "" earlier
20:12:02 <jjore> So somehow I've got to pass the monad along but since it's been entirely implied, I don't know how to say "yes, *that* pass it along"
20:12:04 <pjd> instead of just ""
20:12:16 <aFlag> sorear, probably not in less time it takes to bind to existing C code. But my question was about existing haskell libraries, possible standard ones that would do that for me. So the answer for that is no?
20:12:26 <pjd> return turns the ("") into an (IO "")
20:12:33 <sorear> aFlag: yeah
20:12:43 <jjore> Oh....
20:12:49 <hpaste>  Paczesiowa annotated "instance Ix a => Ix [a]" with "v 1.1" at http://hpaste.org/2510#a1
20:13:21 <pjd> jjore: you can think of return as lifting plain values into the monad
20:13:39 <jjore> So the return value of "return $ char : restOfLine" compiles ok.
20:13:53 <jjore> and it runs ok too.
20:14:14 <pjd> yay :)
20:14:35 <jjore> thanks muchly!
20:15:24 <jjore> I've been writing things out with maximal explicitness and then rewriting in steps, becoming more implicit.
20:15:45 <jjore> It's been... rough trying to deal with Haskell.
20:16:09 <jjore> but #haskell is a godsend.
20:16:21 <Nafai> jjore: Yeah, people here are great!
20:16:24 <oerjan> @pl \b v -> guard b >> return v
20:16:25 <lambdabot> (. return) . (>>) . guard
20:17:22 <chessguy> @undo do { c <- g; if c == '\n' then return "" else do { r <- gL; return $ c:r}}
20:17:22 <lambdabot> (g >>= \ c -> if c == '\n' then return "" else gL >>= \ r -> return $ c : r)
20:18:19 <oerjan> that inner do is liftM (c:) gL
20:19:13 <pjd> (c:) <$> gL
20:19:21 <chessguy> hmm, i guess it doesn't simplify more than that
20:19:31 <chessguy> @type (c:) <$> gL
20:19:33 <lambdabot> Not in scope: `c'
20:19:33 <lambdabot>  
20:19:33 <lambdabot> <interactive>:1:9: Not in scope: `gL'
20:19:43 <oerjan> ifs are a bit hard
20:19:47 <pjd> :t (?c:) <$> ?gL
20:19:49 <lambdabot> forall a (f :: * -> *). (?c::a, ?gL::f [a], Functor f) => f [a]
20:20:12 <pjd> chessguy: <$> is fmap
20:20:17 <chessguy> oerjan, yeah, about all you get is if'
20:20:33 <oerjan> or bool
20:20:43 <chessguy> yeah, however you define it
20:22:04 <oerjan> @pl \c -> if c == '\n' then return "" else liftM (c:) gL
20:22:05 <lambdabot> ap (flip if' (return []) . ('\n' ==)) (flip fmap gL . (:))
20:23:10 <chessguy> heh
20:23:19 <wli> One way I go pointless with some if's is to do maybe blah f $ listToMaybe
20:23:27 <oerjan> i'd hesitate to call that an improvement
20:24:39 <hpaste>  Paczesiowa annotated "instance Ix a => Ix [a]" with "RC 1" at http://hpaste.org/2510#a2
20:24:58 <wli> It's more structured than various other sorts of list emptiness tests so I use it anyway.
20:25:21 <chessguy> @seen paczesiowa
20:25:22 <lambdabot> I saw paczesiowa leaving #haskell 3h 55m 49s ago, and .
20:25:25 <chessguy> heh
20:26:16 <oerjan> probably just after we suggested that Ix instance
20:27:43 <byorgey> hm, that rangeSize instance doesn't look right...
20:30:45 <oerjan> well, except it should be foldl', i don't see anything wrong with it
20:31:18 <oerjan> (or even product)
20:32:08 <oerjan> > rangeSize ((1,1),(1,1))
20:32:09 <lambdabot>  1
20:32:16 <oerjan> > rangeSize ((1,1),(2,5))
20:32:18 <lambdabot>  10
20:32:57 <byorgey> hm, ok... I must be confused about how Ix works.  I'll have to think about it more...
20:34:27 <oerjan> for two dimensions, you give the minimal and maximal corners of the rectangle of values
20:34:50 <byorgey> oerjan: yes, I see.  I didn't realize you could assume that you'll always get the minimal and maximal corners.
20:35:24 <byorgey> oerjan: for example, I thought that you might want to say rangeSize ((2,2), (2,5)) but have it be in the context of an array from (1,1) to (2,5).
20:35:42 <byorgey> obviously you can't do that without having some extra information about the size of the array
20:36:10 <oerjan> well the answer should be the same for a subrectangle too
20:36:38 <byorgey> I guess I'm not explaining myself very well.  =)
20:37:23 <oerjan> perhaps you were thinking something like rows and columns of text?
20:38:06 <oerjan> where you include everything between two characters even if it isn't in the rectangle bounded between them
20:38:21 <oerjan> like the difference between v and ^v in vim
20:38:44 <byorgey> oerjan: right, i.e. the subrange between (a,b) and (c,d) includes everything *lexicographically* between them
20:38:48 <Paczesiowa> oerjan: I don't know if you remember my problem, but I instanced Ix a => Ix [a] but I don't know how to create simple array with that, smth like "arr <- newArray ((1,1),(10,10)) 37 :: IO (IOArray (Int,Int) Int)" but with lists instead of tuples
20:39:12 <oerjan> Paczesiowa: we were discussing it as you entered, we've been seeing your pastes
20:39:23 <Paczesiowa> omg I'm famous:D
20:39:57 <Paczesiowa> btw, do they look lame?
20:40:31 <oerjan> i would expect newArray ([1,1],[10,10]) 37 :: IO (IOArray [Int] Int)
20:40:36 <oerjan> :t newArray
20:40:38 <lambdabot> Not in scope: `newArray'
20:41:02 <oerjan> :t Data.Array.newArray
20:41:04 <lambdabot> Not in scope: `Data.Array.newArray'
20:41:13 <Paczesiowa> Couldn't match expected type `[Int]' against inferred type `(a, b)'
20:41:14 <byorgey> Paczesiowa: no, it doesn't look lame =)
20:41:44 <byorgey> @index newArray
20:41:44 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Foreign.Marshal.Array, Foreign.Marshal, Foreign
20:42:06 <byorgey> @type Data.Array.IO.newArray
20:42:08 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
20:42:11 <dhpeterson> ?users
20:42:11 <lambdabot> Maximum users seen in #haskell: 392, currently: 360 (91.8%), active: 11 (3.1%)
20:43:27 <byorgey> Paczesiowa: can you paste the code you're trying to use, and the whole error?
20:44:17 <oerjan> Paczesiowa: did you change to [ ] in the ranges too?
20:44:26 <twb> Anybody know where the source repository for http://www.distract.wellquite.org/ is?
20:44:28 <lambdabot> Title: start [DisTract]
20:44:50 <twb> Presumably I'm stupid because I can't see it, only snapshot tarballs.
20:46:30 <mudge> is Bryan O'Sullivan in here?
20:46:47 <mudge> his blog went down
20:46:56 <byorgey> @seen bos
20:46:56 <lambdabot> I saw bos leaving #haskell-soc, #haskell and #ghc 4h 41m 43s ago, and .
20:47:07 <mudge> yea, where' bos
20:47:14 <mudge> thanks byorgey
20:47:17 <byorgey> @localtime bos
20:47:38 <hpaste>  Paczesiowa pasted "(no title)" at http://hpaste.org/2513
20:48:17 <Paczesiowa> oh:D now I get what is that "announce" button for:D
20:48:21 <byorgey> Paczesiowa: did you read that error message?
20:48:33 <oerjan> Paczesiowa: you need [ ] brackets in the readArray's too
20:48:35 <byorgey>  In the second argument of `readArray', namely `(1, 5)'
20:48:49 <dibblego> ?hoogle (a -> Bool) -> [a] -> Maybe a
20:48:49 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
20:48:49 <Paczesiowa> omg, I'm so stupid
20:49:36 <byorgey> nah, you just need to read more carefully =)
20:50:53 <Paczesiowa> I'm sorry but I was struggling with those newArray errors since yesterday and I just assumed that it was something with ":: IO (IOArray ([Int]) Int)"
20:51:32 <Paczesiowa> anyway, big thx for help byorgey and oerjan
20:51:56 * oerjan bows
20:51:56 <byorgey> Paczesiowa: glad to help!
20:52:20 <Paczesiowa> it was real fun to code that Ix a => Ix [a] (besides that crazy row major equation)
21:01:49 <oerjan> :t range
21:01:51 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
21:02:14 <oerjan> @src Ix
21:02:14 <lambdabot> class (Ord a) => Ix a where
21:02:14 <lambdabot>     range           :: (a,a) -> [a]
21:02:14 <lambdabot>     index           :: (a,a) -> a -> Int
21:02:14 <lambdabot>     inRange         :: (a,a) -> a -> Bool
21:02:14 <lambdabot>     rangeSize       :: (a,a) -> Int
21:03:40 <oerjan> i smell a scanr
21:06:05 <sorear> kfish: I get the abstract, (and am excited!), but the link seems to be missing?
21:06:16 <sorear> bos: 20:45 < mudge> is Bryan O'Sullivan in here?
21:06:16 <sorear> 20:45 < mudge> his blog went down
21:06:33 <kfish> sorear: lol
21:06:53 <bos> sorear: thanks, seems to be back up now
21:06:53 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
21:07:03 <sorear> @seen matthew-_
21:07:03 <lambdabot> matthew-_ is in #haskell. I don't know when matthew-_ last spoke.
21:07:06 <oerjan> > map (1,3) [rangeSize, length . range]
21:07:07 <lambdabot>  Couldn't match expected type `a -> b'
21:07:27 <oerjan> > map ($(1,3)) [rangeSize, length . range]
21:07:28 <lambdabot>  [3,3]
21:07:28 <sorear> matthew-_: ping, twb is asking about distract
21:08:24 <oerjan> > scanr (*) 1 [1..5]
21:08:25 <lambdabot>  [120,120,60,20,5,1]
21:16:32 <aFlag> @seen dansa
21:16:32 <lambdabot> I haven't seen dansa.
21:16:42 <aFlag> @seen dansa'
21:16:42 <lambdabot> I haven't seen dansa'.
21:17:04 <aFlag> @seen dansa`
21:17:04 <lambdabot> I saw dansa` leaving #haskell 2d 15h 26m 23s ago, and .
21:17:57 <|Steve|> "and ."?
21:19:27 <Paczesiowa> :t and .
21:19:29 <lambdabot> parse error (possibly incorrect indentation)
21:19:53 <byorgey> :t (and .)
21:19:55 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
21:20:25 <byorgey> |Steve|: a very old and well-known (but apparently little-understood) lambdabot bug =)
21:20:57 <hpaste>  oerjan annotated "instance Ix a => Ix [a]" with "(hopefully) more efficient index'" at http://hpaste.org/2510#a3
21:21:27 <oerjan> Paczesiowa: hope you don't mind some improvements
21:21:33 <|Steve|> byorgey: Presumably, it's supposed to say 2d 15h 26m and 23s ago.?
21:21:58 <Paczesiowa> oerjan: that's what open source is for:>
21:22:37 <byorgey> |Steve|: yes, but if there are multiple channels to report, it separates them with an "and", but there's always an extra "and" on the end
21:23:01 <lambdabot> Local time for bos is Wed Aug 29 21:20:47
21:23:23 <oerjan> Paczesiowa: it's totally untested though
21:23:28 <|Steve|> byorgey: Ah.
21:24:18 <oerjan> you will need import Data.List if you haven't already
21:24:30 <byorgey> goodnight all
21:24:33 <Paczesiowa> cu
21:24:34 <byorgey> bedtime for me =)
21:27:58 <aFlag> is it hard to fix?
21:29:43 <Paczesiowa> Couldn't match expected type `c -> a' against inferred type `Int'
21:29:43 <Paczesiowa>     In the first argument of `(-)', namely `rangeSize x z'
21:29:43 <Paczesiowa>     In the second argument of `(*)', namely `((rangeSize x z) - 1)'
21:29:43 <Paczesiowa>     In the expression: p * ((rangeSize x z) - 1)
21:29:44 <sorear> nobody wants to
21:30:07 <hpaste>  oerjan annotated "instance Ix a => Ix [a]" with "missed a tuple" at http://hpaste.org/2510#a4
21:30:20 <oerjan> did that fix it?
21:30:22 <sorear> Paczesiowa: You need to pass the arguments as a tuple
21:30:32 <oerjan> sorear: that was my bug
21:30:57 <sorear> oerjan: fixing Haskell using only the error messages is fun! :)
21:31:49 * sorear installs a post-great-type-families-merge GHC
21:32:51 <Paczesiowa> stupid kvirc, alt+backspace is dangerously too close to alt+ctrl+backspace:/
21:33:14 <Paczesiowa> oerjan: that fixed compilation issues
21:35:39 <Paczesiowa> oerjan: and looks like it's working
21:36:29 <oerjan> whew, i wondered if i had managed to avoid off-by-one errors
21:37:35 <Paczesiowa> I may be wrong but that shouldn't hurt
21:38:01 <Paczesiowa> if it's the only way to index arrays
21:38:30 <Paczesiowa> it just may be incompatible with others but should work no matter what
21:39:23 <Paczesiowa> the worst thing is if last index item doesn't fit according to range
21:39:54 <oerjan> i meant off-by-one errors in matching elements to products, mostly
21:40:48 <oerjan> btw a previous version of ghc had a bug that could give memory corruption in that case
21:41:06 <oerjan> it didn't check Ix instances for sanity
21:41:54 <sorear> btw, I recommend using tuples for this not lists...
21:42:12 <oerjan> sorear: the point was to vary tuple size at runtime
21:42:15 <Paczesiowa> anyway I hate those kind of errors, that's why I can't write C code on paper, all those fors and indexing arrays makes me sick
21:43:47 * psykon agrees
21:43:50 <psykon> C coding sucks
21:46:01 <shapr> But there's an easy cure!
21:46:08 <psykon> yup
21:46:10 <psykon> not coding it
21:46:11 <shapr> Write Haskell instead!
21:46:12 <mainland_> Pascal!
21:46:24 <shapr> mainland_: Really?
21:46:48 <shapr> Are you a fan of Pascal?
21:47:02 <shapr> C'mon, what's it Wirth to you?
21:47:22 <mainland_> i see you prefer call by value!!
21:47:43 * shapr grins
21:47:59 <aFlag> I don't think pascal is that bad
21:48:10 <aFlag> I like pretty much anything, though
21:48:57 <shapr> I like call by need.
21:55:24 * shapr throws very small lambdas
21:56:22 <sioraiocht> http://scienceblogs.com/goodmath/2007/04/true_pathology_a_multilingual.php#more
21:56:25 <lambdabot> Title: Good Math, Bad Math : True Pathology: A Multilingual Quine, http://tinyurl.com/23ehx8
21:56:26 * oerjan throws some pis, simultaneously
21:56:50 <sioraiocht> @quote
21:56:50 <lambdabot> Korollary says: my brain is fried. I cant read any more STM papers
21:58:17 <shapr> @quote
21:58:17 <lambdabot> emu says: olegarithmic
21:59:05 <shapr> @quote fork
21:59:06 <lambdabot> sorear says: We need to fork #haskell.  I can't read fast enough.
21:59:10 * sorear throws pis dependantly
21:59:17 <shapr> @quote pis
21:59:17 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
21:59:20 <shapr> aww
22:00:28 <sorear> @quote pi
22:00:28 <lambdabot> lennart says:  I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
22:00:28 <lambdabot> useful for functional code
22:00:41 <sorear> wow, that's old
22:02:22 <oerjan> @quote ng[ ]th
22:02:22 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
22:02:40 <sorear> @quote ng.th
22:02:41 <lambdabot> lispy says: lambdabot, changing the way Haskllers think since 2003
22:02:44 <coffeemug> ?src closer
22:02:44 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:02:46 <coffeemug> arghh
22:02:48 <oerjan> @quote \<pi\>
22:02:49 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
22:02:49 <lambdabot> sing with me?
22:02:50 <coffeemug> ?src concat
22:02:50 <mdmkolbe> Anyone know any O(n^2) algorithms for general CFG parsing or a proof that CFG requires O(n^3)? (note LR is only a sub-set of CFG)
22:02:51 <lambdabot> concat = foldr (++) []
22:02:56 <sorear> @quote ng.th
22:02:56 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
22:03:12 <coffeemug> ?src ++
22:03:12 <lambdabot> (++) []     ys = ys
22:03:12 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
22:03:23 <sorear> mdmkolbe: Nope.  (Seen plenty of O(n^3) though, even invented a couple)
22:03:31 <sorear> @quote Ï
22:03:31 <lambdabot> No quotes match. Take a stress pill and think things over.
22:04:21 <oerjan> mdmkolbe: as far as i know, O(n^2) is known only for unambiguous grammars
22:04:25 <mdmkolbe> sorear: invented == re-invented?
22:04:44 <sorear> mdmkolbe: yeah
22:05:14 <oerjan> sorear: the point of ng[ ]th btw was to search for something containg space :)
22:05:37 <sorear> @quote ng[^!-~]th
22:05:37 <lambdabot> Philippa says: "in this case using the FFI sounds rather like masturbating with a running chainsaw"
22:05:47 <sorear> @quote ng[^!-~]th
22:05:47 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
22:05:50 <sorear> @quote ng[^!-~]th
22:05:51 <lambdabot> SyntaxNinja says: Let's imagine something that would be awesome.
22:05:53 <sorear> @quote ng[^!-~]th
22:05:53 <lambdabot> lispy says: lambdabot, changing the way Haskllers think since 2003
22:05:54 <sorear> @quote ng[^!-~]th
22:05:55 <lambdabot> SyntaxNinja says: Let's imagine something that would be awesome.
22:06:28 <sorear> When in doubt, do it upside down.
22:07:30 <dibblego> ?hoogle [a] -> (a -> IO ()) -> IO ()
22:07:31 <lambdabot> No matches, try a more general search
22:08:22 <oerjan> :t sequence_
22:08:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
22:08:44 <oerjan> :t mapM_
22:08:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:09:18 <idnar> :t mapM
22:09:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:10:34 <oerjan> :t flip mapM_
22:10:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
22:16:14 <coffeemug> yay
22:16:17 <coffeemug> monads in CL :-D
22:16:25 <coffeemug> (seq (@list 1 2 3) (@list 4 5 6)) => #A[4 5 6 4 5 6 4 5 6]
22:18:49 <jbauman> :t mapM_ id
22:18:51 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m ()
22:19:06 <oerjan> :t sequence_
22:19:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
22:19:16 <jbauman> yes, i saw
22:20:40 <coffeemug> ?src filterM
22:20:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:20:52 <coffeemug> ?src Monad.filterM
22:20:52 <lambdabot> Source not found. Where did you learn to type?
22:20:56 <coffeemug> ?src Control.Monad.filterM
22:20:57 <lambdabot> Source not found. I feel much better now.
22:21:01 <coffeemug> ?src Control.filterM
22:21:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:21:03 <coffeemug> arghh
22:21:10 <coffeemug> fine
22:21:14 <coffeemug> I'll look for it myself!
22:21:24 <oerjan> coffeemug: i do not recall anything that is listed just qualified in @src
22:21:35 <oerjan> but i may not have looked hard
22:21:41 <Paczesiowa> ?hoogle Integer -> Int
22:21:41 <lambdabot> No matches, try a more general search
22:21:54 <oerjan> :t fromIntegral
22:21:56 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:25:40 <oerjan> is the new hoogle able to find such things?
23:10:52 <sorear> @users
23:10:52 <lambdabot> Maximum users seen in #haskell: 392, currently: 357 (91.1%), active: 4 (1.1%)
23:12:16 <sorear> Somehow I manage to have missed this - what does Simon PJ have against functional dependencies?
23:27:32 <aFlag> does anyone know what I have to install in order to use the Network.Socket module?
23:27:35 <aFlag> on debian
23:28:16 <sorear> libghc6-network-dev ?
23:28:53 <aFlag> thanks :)
23:29:03 <aFlag> I was looking for something with name socket
23:29:43 <sorear> I recommend apt-get install libghc6-.*-dev :)
23:30:30 <aFlag> yeah, I should do that :)
23:31:00 <dblhelix> sorear: fds come with terribly complex static semantics
23:31:06 <coffeemug> wow
23:31:16 <coffeemug> actually taking the time to implement monads yourself in another language
23:31:21 <coffeemug> really opens your eyes to how they work :)
23:31:28 <dblhelix> sorear: coverage conditions and such
23:31:47 <sorear> dblhelix: oh?  refinement, and a couple static checks (which we need for ATs too)
23:31:53 <dblhelix> sorear: in contrast, type functions are just as expressive and come with elegant semantics
23:32:28 <sorear> dblhelix: and FDs are only involved in context reduction, ATs seem to require unification over a constraint domain
23:32:59 <dblhelix> sorear: I myself would not be able to reproduce the coverage condition, for example
23:35:03 <sorear> dblhelix: can you reproduce the equivalent mess of guardedness conditions required for ATs?
23:35:33 <dblhelix> sorear: not yet :-)
23:37:28 <dblhelix> sorear: any pointers to those?
23:39:42 <sorear> http://www.haskell.org/hoogle/other/Simon-Peyton-Jones_Type-Functions_AngloHaskell2007.pdf
23:39:44 <lambdabot> http://tinyurl.com/36s72x
23:40:29 * jjore is sad. He his laptop turned inert just as it installed some ghc libraries.
23:40:34 <jjore> Purely a coincidence.
23:40:35 <dblhelix> sorear: cool, I'll have a  look
23:40:37 <jjore> Still sad.
23:40:57 <sorear> but why!!
23:46:16 <dblhelix> sorear: if sorear, well if both are "hard", I'd settle for the functional vs. logic programming argument
23:50:40 <ChilliX> dblhelix, sorear: btw, I just updated the wiki docs to be precise about the rules for type families: http://haskell.org/haskellwiki/GHC/Type_families
23:50:43 <lambdabot> Title: GHC/Type families - HaskellWiki
23:51:28 <ChilliX> sorear: What do you think is a mess?
23:51:50 <ChilliX> Section 7.2.3 in the above web page?
23:52:24 <ChilliX> I don
23:52:28 <sorear> ChilliX: dblhelix says fundeps static checks are terribly complex, I'm using that word to describe the equal complexity of the AT rules
23:52:44 <ChilliX> I don' think the conditions are harder than those for class instances
23:53:04 <sorear> ChilliX: Not much harder, sure.  But I don't see how they are easier...
23:53:16 <ChilliX> Well, I agree with dblhelix that the static checks for FDs are more complex than those for type families
23:53:42 <ChilliX> For starters they are local
23:54:00 <ChilliX> You look at one type instance at a time and you don't even need to see the family declaration
23:54:25 <ChilliX> In contrast, for FDs, you need context information
23:54:30 <ChilliX> That's always harder
23:55:34 <ChilliX> Secondly, "data flow" is immediate.  It's left to right (as for value-level functions)
23:55:37 <sorear> Uh, what about overlap checks?  You can do those just looking at one instance?
23:55:39 <dblhelix> ChilliX, sorear: perhaps it's not as much the rules themselves, but also how often you will run into them
23:56:06 <ChilliX> For FDs, you need to reason about sets of dependencies between parameters than can go in any direction
23:56:15 <dblhelix> ChilliX, sorear: when using FDs I find myself in need for undecidable instances quite often
23:56:38 <ChilliX> sorear: I am just talking about the decidability checks (that's what's messy about FDs)
23:56:55 <ChilliX> Well, you got a pioint in that overlap checks for ATs are also simpler than for FDs :)
23:57:02 <dblhelix> ChilliX, sorear: potentially undecidable instances that is, i.e. -fallow-undecidable-instances
23:57:23 <ChilliX> dblhelix: exactly that's what I was talking about
23:57:32 <ChilliX> 7.2.3 in the above web page
23:57:57 <ChilliX> in = on
23:58:17 <sorear> ChilliX: Ah, I think I see now.  Only considering one mode at a time makes rewriting simpler
23:59:00 <ChilliX> Yep
23:59:04 <sorear> Unification modulo a constraint domain still seems like a big addition, but now it's justified, so I can have fun exploiting it... :)
23:59:18 <ChilliX> For class instances *without* FDs, it's the same btw
23:59:34 <ChilliX> sorear: :)
23:59:40 <dblhelix> ChilliX: perhaps it's hard to predict at this point, but is there reason to believe that we'll be in need for -fallow-undecidable-instances with type families less than we do with FDs?
23:59:44 <ChilliX> sorear: also, it is only equality constraints
