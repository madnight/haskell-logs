00:00:14 <bos> glguy: look at laptop-mode
00:00:25 <glguy> ok
00:05:04 <glguy> would it be possible to install vim without python and ruby support?
00:05:36 <glguy> oops :)
00:05:38 <glguy> wrong channel
00:10:38 <opqdonut> :))
00:32:25 <opqdonut> glguy: and try the async mount option too
00:32:29 <opqdonut> re: usb-drive
01:34:19 <mux> mmm, looks like using the nvidia cuda would be interesting for NDP
01:34:47 <dons> mux, damn straight!
01:35:01 <dons> its dedicated hardware for ndp, almost
01:36:04 <dons> this guy is dedicating 4 years to do a phd on the topic, http://www.cse.unsw.edu.au/~seanl/ :)
01:36:05 <lambdabot> Title: Sean LEE
01:36:37 <mux> dons: oh, cool!
01:40:15 <roconnor> @what ndp
01:40:15 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
01:48:35 <tuxplorer> population :: (a -> Bool) -> [a] -> Int
01:48:35 <tuxplorer> population fn [x] = length(filter fn [x])
01:48:35 <tuxplorer> I get an error *** Exception: lib_proc_lists.hs:2:0-40: Non-exhaustive patterns in function population.. What is wrong?
01:49:22 <pejo> tuxplorer, do you really want [x] and not x in the LHS/RHS?
01:50:16 <mux> tuxplorer: you are only defining population when the second parameter is a list containing only one element
01:50:31 <mux> tuxplorer: if this list is empty or contains more than one element, your function is undefined
01:50:31 <dons> yeah, i guess you really mean: population f x = length (filter f x)
01:50:48 <dons> :t let population f x = length (filter f x) in population
01:50:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
01:50:58 <tuxplorer> mux: oh! ok. now I get it..
01:51:01 <dons> ?let population f x = length (filter f x)
01:51:07 <lambdabot> Defined.
01:51:12 <dons> > population (not . isSpace) "haskell is fun"
01:51:13 <lambdabot>  12
01:51:21 <mux> @pl population f x = length (filter f x)
01:51:21 <lambdabot> population = (length .) . filter
01:51:26 <dons> > population (< 10) [1..100]
01:51:27 <lambdabot>  9
01:51:36 <mux> bah, why does point-free style sucks so much as soon as the number of parameters exceed one :-)
01:51:37 <dons> @pl population x = length (filter x)
01:51:37 <lambdabot> population = length . filter
01:51:44 <dons> @pl population  x = length (filter f x)
01:51:45 <lambdabot> population = length . filter f
01:53:36 <xerox> > population isPrime [1..100]
01:53:38 <lambdabot>  25
01:54:17 <Syzygy-> > population ((==0).(`mod`4)) [1..100]
01:54:18 <lambdabot>  25
01:54:50 <mux> > population (`elem` 'a') ["lambda","dons","haskell"]
01:54:51 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
01:55:03 <mux> > population (elem 'a') ["lambda","dons","haskell"]
01:55:05 <lambdabot>  2
01:55:12 <Syzygy-> > population ('a' `elem`) ["lambda","dons","haskell"]
01:55:13 <lambdabot>  2
01:57:49 <tuxplorer> lambdabot maintains different symbol tables for each instance of him? ie., something defined in #haskell won't reflect in my /query session with him?
01:58:14 <shachaf> tuxplorer: It will (and it's her).
01:58:30 <shachaf> However, @ty doesn't know @let; maybe that's the problem?
01:58:35 <xerox> ?check \n -> let primes = 2 : 3 : [(n::Int) | n <- [5,7..], all (\p -> mod n p /= 0) (takeWhile (\p -> p*p <= n) primes)]; isPrime n = elem n (takeWhile (<=n) primes); population f xs = length (filter f xs) in population isPrime [1..n] == population ((0==).(`mod`4)) [1..n]
01:58:36 <lambdabot>  Falsifiable, after 16 tests: 6
02:00:05 <tuxplorer> shachaf: ok. but > followed by my command doesn't work..
02:00:22 <shachaf> tuxplorer: What's the error?
02:00:28 <tuxplorer> how do I ask her to eval whatever I type in?
02:00:32 <shachaf> "> population ..." works for me.
02:00:34 <shachaf> Use a space?
02:00:35 <tuxplorer> no response from her
02:00:39 <shachaf> >1+1
02:00:41 <shachaf> > 1 + 1
02:00:42 <lambdabot>  2
02:00:56 <DRMacIver> tuxplorer: Are you registered? She might just not be seeing your pms.
02:01:13 <DRMacIver> Hm
02:01:22 <DRMacIver> That sounded odd.
02:01:23 <tuxplorer> DRMacIver: I had missed the space between > and population
02:01:27 <DRMacIver> Ah
02:01:31 <tuxplorer> now she likes me ;)
02:01:37 <roconnor> @vixen
02:01:37 <lambdabot> am I the only person you're talking to?
02:02:17 <roconnor> @vixen of course baby
02:02:18 <lambdabot> there is nothing going on in your pants that the dictatorship of the proletariat will not solve
02:03:13 <roconnor> that's a pretty good line
02:03:54 <tuxplorer> roconnor: "@vixen" is for random quotes?
02:04:23 <tuxplorer> @ vixen
02:04:27 <roconnor> @vixen are you just saying random quotes?
02:04:27 <lambdabot> that's because i have a random generator
02:04:40 <tuxplorer> @vixen
02:04:40 <lambdabot> Wouldn't it be funny if I really was a super model?
02:04:43 <roconnor> yep, apperently random ;)
02:05:46 <tuxplorer> roconnor: so, the quotes aren't stored, but generated from a list of words in a dict with NLP?
02:06:30 <tuxplorer> @vixen what is your name?
02:06:30 <lambdabot> My name is Emily
02:06:43 <roconnor> tuxplorer: presumably, but I'm not sure
02:06:43 <lambdabot> Who says there are dictionaries? how rude!
02:06:53 <roconnor> *L*
02:07:07 <lambdabot> :P
02:07:14 <tuxplorer> @vixen sorry, you are really good :D
02:07:14 <lambdabot> thanks, i do my best to be good
02:07:31 <roconnor> @seen dons
02:07:31 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 23s ago.
02:07:32 <DRMacIver> @vixen is scary...
02:07:32 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
02:07:39 <DRMacIver> See?
02:08:17 <th3lib> Now that is scary...
02:08:29 <tuxplorer> @vixen my pic is at http://foobar.com/foobar.jpg
02:08:29 <lambdabot> i don't have internet access, sorry
02:08:52 <tuxplorer> safe answer ;)
02:10:17 <DRMacIver> I suppose I should go do some work.
02:16:29 <gleb> @vixen Are you Eliza-based or something more complex?
02:16:29 <lambdabot> isn't it obvious?
02:16:56 <gleb> lol
02:17:08 <tuxplorer> @vixen I bet you are not in anyway related to Eliza.. Eliza sucks. what do you say?
02:17:09 <lambdabot> i do occassionally, i guess
02:18:13 <xerox> ?vixen asl?
02:18:13 <lambdabot> 19/f/California
02:30:49 <gleb> can I make some module load every time I start ghci?
02:31:13 <xerox> gleb: yes, there's a .ghci file
02:31:46 <gleb> xerox: thanks, I'll rtfm about it
02:32:48 <xerox> Oh, it's easy, just write whatever you would have written in ghci.
02:32:58 <xerox> It's in the users guide anyway.
02:33:18 <tuxplorer> would lambdabot give me the link to the source code of some function?
02:33:55 <xerox> Yep. But it's a two-step process for some.
02:34:05 <xerox> ?src isPrefixOf
02:34:05 <lambdabot> isPrefixOf [] _          = True
02:34:05 <lambdabot> isPrefixOf _  []         = False
02:34:05 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
02:34:35 <xerox> This if you're lucky. If not, ?index functionName and then ?source Module.Name
02:35:12 <tuxplorer> xerox: Thanks
02:42:20 <njbartlett> http://www.londonhug.net/2007/08/31/next-meeting-20th-september/
02:42:22 <lambdabot> Title: Î»ondon HUG » Blog Archive » Next Meeting 20th September
02:43:54 <DRMacIver> I'm rather looking forward to the talk on finger trees. :)
02:44:06 <dons> oh, nice.
02:44:09 <DRMacIver> matthew-_ and tristan's talk on game design in Haskell will of course be boring. ;)
02:46:35 <njbartlett> I'm wondering what kind of game. Not just sudoku I hope ;-)
02:48:04 <matthew-_> I saw that!
02:48:21 <matthew-_> @slap DRMacIver
02:48:21 * lambdabot beats up DRMacIver
02:49:34 <DRMacIver> Heh
02:51:52 <tuxplorer> I want to define a ordering function for lists.. (Ord ?) -> [a] -> [a] -> Ordering .. what should I put at the place of '?'
02:52:31 <xerox> 'a'
02:52:37 <mux> tuxplorer: you know that this function already exists, right?
02:53:07 <xerox> You want to compare the elements of the lists, presumably.
02:53:31 <mux> > compare [1,2,3] [1,2,3]
02:53:32 <lambdabot>  EQ
02:54:03 <tuxplorer> xerox: but that throws an error
02:54:09 <tuxplorer> > compare_population a b | (population (>0) a) == (population (>0) b) = EQ
02:54:09 <xerox> What error?
02:54:09 <tuxplorer>                   | (population (>0) a) <= (population (>0) b) = LT
02:54:09 <tuxplorer>                   | otherwise = GT
02:54:09 <lambdabot>  Parse error
02:55:03 <tuxplorer> will paste it..
02:55:30 <tuxplorer> http://pastebin.ca/676691
02:55:38 <tuxplorer> hpaste doesn't resolv for me :(
02:55:39 <xerox> Sometimes it is useful not to type the typesignatrure, but instead have GHC infer them. And then you can ask for it with :type compare_population at the prompt.
02:56:02 <mux> tuxplorer: you have an additional constraint on the element of the lists
02:56:19 <xerox> See the "Possible fix" part.
02:56:28 <mux> tuxplorer: since you compare with 0, the elements also need to be in the type class Num
02:56:31 <mux> so that should give you:
02:56:43 <mux> (Num a, Ord a) => [a] -> [a] -> Ordering
02:56:48 <xerox> Also, (Num a) is constrained with (Ord a), so once you put that constraint, the Ord one isn't needed anymore.
02:56:52 <mux> riht
02:57:25 <tuxplorer> oh! ok.. That function used uses the Num's Ord class, so I need to add it?
02:57:56 <xerox> tuxplorer: it was (>) on 0
02:58:25 <xerox> The former only needs Ord a, but such a must be a Num because of 0.
02:58:33 <tuxplorer> xerox: In that case, the type signature is not Ord a.. so I can't use this function for sortBy right?
02:58:45 <xerox> ?type sortBy
02:58:47 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:58:53 <xerox> Yes you can.
02:59:08 <xerox> The constraint just propagates.
02:59:17 <tuxplorer> oh! ok..
02:59:23 <xerox> :)
03:09:19 <gleb> @seen sjanssen
03:09:19 <lambdabot> I saw sjanssen leaving #haskell, #gentoo-haskell, #haskell-overflow, #happs and #xmonad 3h 52m 30s ago, and .
03:37:01 <Lemmih> SamB: Happy birthday!
03:37:42 <Lemmih> Damn lag.
03:58:16 <dcoutts> @seen ChilliX
03:58:16 <lambdabot> ChilliX is in #ghc and #haskell. I don't know when ChilliX last spoke.
03:58:27 <dcoutts> @localtime ChilliX
03:58:28 <lambdabot> Local time for ChilliX is 2007-08-31 20:57:16 +1000
03:59:13 <dcoutts> @tell ChilliX I did mess up the ch2s tarball :-) missing .h file. I've uploaded a new one to hackage, you'll need to grab a copy again for the c2hs website.
03:59:13 <lambdabot> Consider it noted.
04:00:05 <dcoutts> @tell ChilliX and double check that the tarball does contain /c2hs-0.15.0/c2hs/toplevel/c2hs_config.h
04:00:05 <lambdabot> Consider it noted.
04:04:31 <ChilliX> dcoutts: ok!
04:04:32 <lambdabot> ChilliX: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:04:56 <dcoutts> ChilliX: cheers
04:08:07 <ChilliX> dcoutts: done.
04:08:13 <dcoutts> ta
04:42:33 <dons> ?yow
04:42:33 <lambdabot> I'm having a BIG BANG THEORY!!
04:43:17 <gleb> @yow
04:43:17 <lambdabot> YOW!!!  I am having fun!!!
04:44:48 <Vq^> @arr
04:44:48 <lambdabot> Ahoy mateys
04:45:11 <dwx> @yow
04:45:11 <lambdabot> Can I have an IMPULSE ITEM instead?
04:45:20 * idnar doesn't get Zippy
04:46:04 <opqdonut> @yarr
04:46:05 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
04:46:18 <dons> http://programming.reddit.com/info/2khab/comments
04:46:19 <lambdabot> Title: London Haskell Users Group: finger trees, game design in Haskell (reddit.com)
04:47:41 <pejo> dons, did you finish moving?
04:54:10 <hpaste>  gleb pasted "pretty printing for ghci" at http://hpaste.org/2524
04:54:47 * gleb has just read yesterday conversation of kolmodin, SamB, sjanssen et. al.
04:55:42 * gleb wonders, how to better install this module to have it always available in ghci
04:57:54 <gleb> anyone knows the best way for adding some handy debugging functions to ghci environment?
04:58:14 <dcoutts> gleb: a .ghci file iirc
04:58:46 <dcoutts> http://haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
04:58:48 <lambdabot> Title: 3.8. The .ghci file, http://tinyurl.com/2ngetq
04:59:02 <gleb> yes, but this doesn't play well with C-c C-l in Emacs
04:59:22 <dcoutts> gleb: or just make it an installed package, then you can use the functions at any time
04:59:32 <dcoutts> ModuleName.functionName
05:00:05 <dcoutts> or to use them unqualified, :m +ModuleNameWithMyConvenientUtilityFunctions
05:00:17 <dcoutts> gleb: though you might pick a shorter module name :-)
05:00:46 <gleb> dcoutts: thanks, that seems a way to go
05:01:06 <gleb> dcoutts: I just can't think of best name for this module
05:01:27 <gleb> putting it in System.Console (like I did) is bad idea
05:17:34 * gleb wonders why ghci doesn't pretty print by default.
05:18:56 <xerox> gleb: so you just have to derive Show to see the results of computations on your own types for one
05:19:26 <gleb> xerox: it requires Show instance anyway (or am I missing smth?)
05:19:45 <xerox> Yeah, it does. But Show is a derivable class.
05:20:19 <xerox> The Show code contains some comment about what it is for, and its invariants/constraints too.
05:22:17 <gleb> xerox: Would you please elaborate? I don't get it.
05:22:28 * gleb is looking at http://darcs.haskell.org/ghc-6.6/packages/base/Text/Show.hs now
05:22:43 <xerox> I am not sure. I guess the idea is that there are mot Show-able things than PPrint-able ones.
05:22:55 <xerox> And Show is also dual to Read, I don't think PPrint has got one.
05:23:37 <gleb> xerox: hm, yes, you're right
05:24:27 <gleb> xerox: I didn't think of Show instances that cannot be read back
05:24:59 <xerox> gleb: isn't it written in the .hs you're reading that Show instances must be made so that they can be Read back?
05:26:05 <gleb> xerox: Oh, I spotted it. 'Converting values to readable strings:'. But 'readable' here seems (to me at least) ambigous
05:26:26 <gleb> xerox: It can be expanded as 'human-readable'
05:27:44 <gleb> if all Show instances produced valid Haskell, it could be easy to patch ghci so that is pretty-printed evaluation results
05:38:57 <Liskni_si> xerox: aren't pprinted things readable just as well as showed ones?
05:43:27 <xerox> Liskni_si: I guess not.
05:48:32 <kolmodin> pprinted should be at least as readable as showed ones :)
05:59:06 <gleb> kolmodin: pprint v parses output of 'show v' using Language.Haskell.Parser. This requires Show instance that produce valid Haskell (it isn't always the case)
06:02:18 <bparkis> does a facility exist for writing short, perl-like 1-liners on the command line?
06:02:36 <Saizan> perl -e ?
06:02:53 <bparkis> yes similar to that
06:03:09 <drigz> ghc -e
06:03:09 <ToRA> for haskell?
06:03:13 <ToRA> >echo hello world | ghci -e 'interact reverse'
06:03:31 <ibid> ghc -e, though there is no perl-like in that :)
06:03:57 <MyCatVerbs> :t interact
06:03:59 <lambdabot> (String -> String) -> IO ()
06:04:15 <ToRA> similar to perl -npe i think
06:04:25 <drigz> MyCatVerbs: you give it a pure function that maps input to output
06:04:52 <MyCatVerbs> drigz: how convenient.
06:04:59 <drigz> ghc -e 'interact $ unlines . f . lines' is very useful
06:05:05 <drigz> for differing values of f
06:05:25 <MyCatVerbs> Bah.
06:06:05 <MyCatVerbs> !#/bin/sh \n ghc -e "interact \$ unlines . $@ . lines" \n <-- in your $PATH, surely more useful? :)
06:06:36 <Spark> #!/usr/bin/ghc -e
06:06:48 <Spark> surely
06:07:01 <Spark> wrong comment too
06:07:07 <drigz> Spark: that would call ghc -e /usr/bin/file.sh
06:07:13 <dylan> #!/usr/bin/env runghc is more portable
06:08:26 <MyCatVerbs> Hrmn. runghc doesn't appear to be installed on this machine, weird.
06:08:50 <MyCatVerbs> Vanilla 6.6 on DeadRat.
06:08:52 <drigz> runhaskell is portable across different implementations i think
06:09:21 <drigz> maybe you have that instead, it's just a symlink on here
06:09:43 <MyCatVerbs> Only run* in my path to do with Haskell is runhugs.
06:09:55 <Lemmih> MyCatVerbs: Yeah, it can't be installed by default due to some copyright issues with run-DMC.
06:10:19 <xerox> hahaha
06:10:22 <MyCatVerbs> Lemmih: huh? That sounds decidedly freakish and arcane. Please elaborate?
06:10:47 <MyCatVerbs> Wait, you're taking the piss. Dammit.
06:11:12 * Lemmih giggles.
06:13:07 * dblhelix grins
06:17:25 <kolmodin> gleb: there is a pprint?
06:18:26 <swiert> @seen Igloo
06:18:26 <lambdabot> Igloo is in #haskell, #haskell-soc, #happs, #ghc and #darcs. I last heard Igloo speak 1h 13m 43s ago.
06:18:34 <gleb> oh, I mis-read your comment. I've read your yesterday conversation (about pretty-printing in console) and quickly tried sjanssen's idea
06:18:50 <Igloo> hi
06:18:59 <swiert> hiya.
06:18:59 <gleb> http://hpaste.org/2524
06:19:02 <gleb> hi
06:19:13 <swiert> Any idea when ghc 6.7 release candidate is out?
06:19:19 <swiert> Last I heard was "end of August" I think...
06:19:26 <EvilTerran> s'cuse me. my client seems to have the hiccups.
06:19:42 <Igloo> Yeah, RSN
06:19:49 <Igloo> (6.8.1 RC, though)
06:19:51 <gleb> kolmodin: I though you were commenting on this pprint
06:20:10 <swiert> oops - you're right, of course.
06:24:40 <kolmodin> gleb: I was referring to the python pprint
06:25:09 <gleb> kolmodin: I see
06:25:25 <kolmodin> (which I like very much)
06:25:33 <kolmodin> I'd like the same for haskell
06:25:55 <SamB> Lemmih: huh, a bit late!
06:26:06 <kolmodin> reading a few lines of 80-char-wrapped structures from ghci isn't very nice
06:26:20 <gleb> kolmodin: I find idea of using Language.Haskell.{Parser, Pretty} a nice substitute for Python's pprint
06:26:34 <SamB> Lemmih: my sister tells me I've somehow gotten put into the Widener Alums network...
06:28:45 <gleb> kolmodin: have you seen the code I hpasted?
06:29:44 <wli> I'm trying to remember how one parametrizes paraboloids.
06:31:17 <Botje> wli: from a safe distance.
06:32:34 <wli> Well, so long as all the eigenvalues are nonzero, it's easy with circular and hyperbolic functions.
06:33:39 <Lemmih> SamB: Better late than never. (:
06:33:51 <laz0r> guys, if i create something like 'data Foo = Foo { bar :: Int }' i get a constructor Foo together with a 'setter/getter' bar..., now, since bar is a function, with type bar :: Foo -> Int, i am wondering if it is possible to use the Foo inside of bar...
06:34:04 <SamB> Lemmih: true :-)
06:34:08 <SamB> thanks
06:35:21 <wli> It's the parabolic case where I don't know of the relevant parametrization (apart from (t,t^2) but that's cheating).
06:36:10 <Saizan> laz0r: bar is yet defined equivalently as bar (Foo i) = i, if you want you can write another bar in a different module
06:36:45 <Lemmih> SamB: I hope your Haskell code won't be neglected now that you're legally allowed to drink. (:
06:37:25 <SamB> Lemmih: I don't expect there to be much correlation
06:38:46 <laz0r> Saizan, ok, i think i understand what you mean
06:38:56 <takamura> hi
06:45:56 <trurl> hello, I'm looking for an introduction to using Text.XHtml.  the link given in the library documentation (http://www.cse.ogi.edu/~andy/html/intro.htm) is broken unfortunately
06:50:18 <kolmodin> gleb: no, sorry, I missed that
06:50:59 <wli>  (Foo i) = i,
06:50:59 <wli> +if you want you can write another bar in a different module
06:50:59 <wli> <Lemmih:#haskell> SamB: I hope your Haskell code won't be neglected now that
06:50:59 <wli> +you're legally allowed to drink. (:
06:50:59 <wli> <SamB:#haskell> Lemmih: I don't expect there to be much correlation
06:51:00 <wli> <laz0r:#haskell> Saizan, ok, i think i understand what you mean
06:51:02 <wli> <takamura:#haskell> hi
06:51:04 <wli>  06:35AM [ircII] wli (+ei) (Query: #haskell) #godflesh (+cnt)  ircII-EPIC4 -- T
06:51:06 <wli> >
06:51:08 <wli>  (Foo i) = i,
06:51:10 <wli> +if you want you can write another bar in a different module
06:51:12 <wli> <Lemmih:#haskell> SamB: I hope your Haskell code won't be neglected now that
06:51:14 <wli> +you're legally allowed to drink. (:
06:51:16 <wli> <SamB:#haskell> Lemmih: I don't expect there to be much correlation
06:51:16 <kolmodin> gleb: ok. nice. I'll try that
06:51:18 <wli> <laz0r:#haskell> Saizan, ok, i think i understand what you mean
06:51:20 <wli> <takamura:#haskell> hi
06:51:22 <wli>  06:35AM [ircII] wli (+ei) (Query: #haskell) #godflesh (+cnt)  ircII-EPIC4 -- T
06:51:24 <wli> >
06:51:39 <Saizan> wli?
06:51:53 <evir> That's the thing I hate about most terminal IRC clients. :->
06:52:08 <evir> Sooner or later you end up pasting tons of lines into the terminal by accident.
06:52:23 <Saizan> irssi warns you
06:52:27 <evir> Yup.
06:52:40 <evir> In later versions. And that is actually a very good feature. :-)
06:53:09 <wli> Saizan: For a positive eigenvalue, the normalized coordinate gets a factor of cos and the remainder a factor of sin.
06:53:34 <wli> Saizan: For a negative eigenvalue, the normalized coordinate gets a factor of sinh and the remainder a factor of cosh.
06:53:54 * Saizan takes notes
06:54:26 <wli> Saizan: Zero eigenvalues have less direct analogues. A factor of t^2 for the normalized coordinate and a factor of t for the rest seems plausible.
06:56:34 <wli> Saizan: The eigenvalues are of the matrix A in <x, Ax> + <b,x> + c = 0 as an implicit representation of a quadric surface.
06:58:32 <wli> Saizan: From here the generalization of therp's problem is to parametrize a geodesic arc between two points of a quadric surface.
07:01:34 <wli> Saizan: For higher dimensions there need to be linear constraints to make it two-dimensional.
07:05:33 <wli> I'm not entirely sure it's necessary to parametrize it, but it's easy enough to do.
07:09:08 <wli> There are alternatives, too, like the rational bits for hyperbolas and ellipses.
07:13:36 <klein_> in haskell, can you collapse function definitions with the same right hand side into one somehow?
07:15:17 <scook0> klein_: what do you mean?
07:15:25 <klein_> hmm
07:15:30 <rgs> with a pattern on the left hand side ?
07:15:38 <klein_> say i've got Data Foo = Foo String | Bar String
07:15:54 <klein_> and i want show (Foo string) and show (Bar string) to both just be (show string)
07:16:24 <Cale> You have to write it out, though you can cheat a bit using record syntax
07:16:47 <klein_> ah, i'll give that a look, thanks
07:16:52 <Cale> data Foo = Foo { unFoo :: String } | Bar { unFoo :: String }
07:17:02 <Cale> then unFoo :: Foo -> String
07:17:09 <klein_> excellent
07:17:15 <klein_> that's just what i was looking for
07:17:29 <scook0> oh, that's neat :)
07:17:59 <scook0> (I've never used records for multi-constructor types)
07:18:45 <Cale> Another neat use of the record syntax, which applies even when you haven't declared your type using record syntax is matching against a pattern like  Bar {}
07:19:02 <Cale> That will test if Bar is the constructor, and ignore any and all fields in it.
07:19:27 <klein_> oh, like (Bar _ _) or the like?
07:19:42 <Cale> yeah, except that if the type is extended later, you don't have to change it
07:20:17 <|Jedai|> Cale: And that you don't need to put four _ if you have 4 parameters ?
07:20:21 <Cale> right :)
07:20:46 <|Jedai|> Cale: Thanks, I didn't know this trick :)
07:21:04 <Cale> It's kind of an obscure point from the standard :)
07:22:02 <klein_> so what's the magic going on there?  are normal data types secretly records?
07:22:47 <dolio> Records are secretly normal data types.
07:22:51 <Cale> Well, records are secretly normal data types
07:22:54 <Cale> :)
07:23:04 <klein_> :)
07:23:24 <Cale> Normally record syntax won't work if the data type wasn't declared using it though
07:23:33 <roconnor> aww
07:23:36 <Cale> That's an explicit exception to that rule.
07:25:17 <roconnor> should I go shopping to buy food for dinner, or should I just eat at the university cafeteria?
07:25:23 <der_eq> in the haskell mode plugins for vim, does anyone know how :HpastePostNew works? I'm not much of an vim expert...
07:25:27 <roconnor> @8ball
07:25:27 <lambdabot> Unknown command, try @list
07:25:38 <xerox> ?dice 3d6
07:25:38 <lambdabot> 3d6 => 5
07:25:43 <xerox> Cafeteria, I guess.
07:25:46 <Cale> roconnor: I remember that dilemma :)
07:25:50 <roconnor> sold
07:26:03 <roconnor> Cale: do you not have the dilemma anymore?
07:26:24 <roconnor> It's pretty overcast, makes me warry of shopping.
07:26:25 <Cale> Yeah, I'm not at uni now.
07:26:33 <Saizan> @source Data.Tree
07:26:33 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
07:26:41 <roconnor> Cale: what do you do now?
07:26:54 <Cale> No matter how good the cafeteria is, there will be some point at which you will not want to go there :)
07:27:13 <klein_> speaking of vim, is there anything to make it indent haskell smartly?
07:27:27 <roconnor> cafeterria food is bad, but cooking requires a fair amount of time.
07:27:37 <Cale> Nothing specific, though I've picked up a job doing a small invoice system for a friend.
07:28:30 <Cale> I should apply and go back at some point soon :)
07:28:30 <klein_> cooking can become fun... time well spent
07:28:42 <evir> roconnor: And you need to wash the dishes.
07:28:54 <Cale> roconnor: I ended up going to various restaurants in a nearby plaza quite often.
07:29:27 * wli probably spends several hours a day cooking. There's a reason why restaurants make sense.
07:29:36 <evir> I usually just go to a very cheep but good (a bit punky) vegetariant restaurant. But they are closed this month, so I am stuck at home cooking, washing dishes and all that.
07:29:59 <evir> And because I don't want to spend the time cooking and washing dishes, I mostly eat frozen pizza that I do not loke. ;-)
07:30:08 <roconnor> pork loin is on sale, but I'm not sure what I would make with it, and besides it will stil be on sale tomorrow.
07:30:31 <mrd> klein_: :set sw=2,sts=2 :)
07:30:45 <mrd> and expandtab
07:30:52 <roconnor> actually pork medallions wraped in bacon sounds pretty tasty. ...
07:31:01 * xerox nods
07:31:12 <xerox> ?dice 3d6
07:31:12 <lambdabot> 3d6 => 9
07:31:21 <xerox> Cooking!
07:31:23 <wli> I mostly fry up sausage, bacon, and eggs.
07:31:31 <roconnor> I need a side dish.
07:31:43 <msouth> klein_: have you checked python peoples' vim settings?  they also have layout to deal with
07:31:47 <roconnor> I wonder if I can make spinach taste good.
07:32:07 <mrd> i love spinach
07:32:09 <evir> Using the pizza carton for a plate is also a good, clean and cheap alternative. :-)
07:32:19 <xerox> And there's always ##cooking, if you can't, roconnor (-;
07:32:38 <mrd> #haskell: eat your spinach
07:32:56 <klein_> msouth: i'll have a look.  emacs' haskell indenter seemed cleverer than i can find for vim
07:33:10 <roconnor> xerox: really? ... I don't know about IRC....
07:33:21 <xerox> roconnor: yup :)
07:33:28 <mrd> klein_: there's nothing like haskell-mode's "smart" indenter, fbofw
07:33:51 <roconnor> I thought freenode was for open source projects.
07:34:07 <Cale> I never really liked the smart indenter, but maybe it's improved in the time between now and when I last used it.
07:34:11 <xerox> roconnor: open source developers also eat!
07:34:12 <klein_> mrd: fbofw?
07:34:12 <mrd> an open sauce cooking
07:34:27 <mrd> klein_: for better or for worse.  the smart indentation is a mixed blessing.
07:34:31 <roconnor> xerox: ya, but they don't cook.  They just order in or eat out.
07:34:43 <xerox> Eh, evolution.
07:34:47 <klein_> ah
07:35:12 <EvilTerran> from each according to his ability to each according to his need!
07:35:18 <der_eq> now i spammed hpaste.org :(
07:35:28 <klein_> you know, the more haskell i code, the less i mind not having a clever indenter
07:35:32 <EvilTerran> they're good at making pizza, and i need pizza. it works. =]
07:36:42 <Cale> klein_: Yeah, there's not so much typing to do anyway, so automating that typing seems less important. So long as you have something which will maintain the indentation level of the previous line, it's pretty painless.
07:36:53 <klein_> ever use scheme-mode (or i presume lisp-mode)?  that tab key is damn smart
07:37:14 <mrd> sure, it's unambiguous
07:37:56 <mrd> however when indentation determines meaning, the computer can't make that decision for you
07:38:48 * roconnor wonders if I can find a satifactory replacement for bacon here in the netherlands.
07:39:42 <Cale> It would be nice to have an editor which was properly aware of the offside rule though.
07:40:10 <mrd> lots of room for improvement... (yi!!!)
07:41:28 <Qerub> Is there any built-in list filter function that stops at the first exclusion?
07:41:30 <klein_> is yi worth trying out?  reading about it, i don't have a good feel on its dev. progress
07:41:54 <EvilTerran> @src deleteBy
07:41:54 <lambdabot> Source not found. That's something I cannot allow to happen.
07:41:56 <EvilTerran> @src delete
07:41:56 <lambdabot> delete = deleteBy (==)
07:41:59 <EvilTerran> ...
07:42:09 <xerox> ?index deleteBy
07:42:09 <lambdabot> Data.List
07:42:10 <EvilTerran> > deleteBy (>5) [1..10]
07:42:11 <lambdabot>  Couldn't match expected type `a -> Bool'
07:42:11 <xerox> ?source Data.List
07:42:11 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
07:42:13 <xerox> There you go.
07:42:29 <EvilTerran> ?type deleteBy
07:42:31 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
07:42:37 <EvilTerran> > deleteBy (>) 5 [1..10]
07:42:38 <lambdabot>  [2,3,4,5,6,7,8,9,10]
07:42:45 <EvilTerran> i give up.
07:43:00 <EvilTerran> that does kinda make sense, but still...
07:43:11 <EvilTerran> > deleteBy (const (>5)) undefined [1..10]
07:43:13 <lambdabot>  [1,2,3,4,5,7,8,9,10]
07:43:53 <Cale> heh
07:43:54 <doserj> > takeWhile (<5) [1..10]
07:43:55 <lambdabot>  [1,2,3,4]
07:44:15 <Qerub> takeWhile was exactly what I was looking for.
07:44:18 <Qerub> Thank you!
07:44:52 <Qerub> And I'll study the docs harder next time.
07:44:56 <gleb> @yaw
07:44:57 <lambdabot> Were these parsnips CORRECTLY MARINATED in TACO SAUCE?
07:45:01 <Cale> Qerub: no problem
07:45:13 <Cale> Qerub: asking lots of questions here is a good way to learn :)
07:45:28 <Qerub> I guess :-)
07:45:43 <Cale> > deleteBy (<) 5 [1..10]
07:45:44 <lambdabot>  [1,2,3,4,5,7,8,9,10]
07:46:35 <Qerub> > takeWhile (< 64) $ map (** 2) $ [1..]
07:46:36 <lambdabot>  [1.0,4.0,9.0,16.0,25.0,36.0,49.0]
07:46:39 <Qerub> That's what I was trying to do.
07:47:12 <Cale> > takeWhile (< 64) . map (^2) $ [1..]
07:47:13 <lambdabot>  [1,4,9,16,25,36,49]
07:47:20 <xerox> ?type ((^),(^^),(**))
07:47:21 <Qerub> Better :)
07:47:22 <lambdabot> forall a b a1 b1 a2. (Integral b, Num a, Integral b1, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
07:47:23 <Cale> (if you'd rather keep them integers)
07:47:39 <Cale> heh
07:47:40 <roconnor> mmm Sauteed Garlic-Lemon Spinach
07:47:47 <Cale> :t (^)
07:47:49 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:47:51 <Cale> :t (^^)
07:47:53 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:47:55 <Cale> :t (**)
07:47:57 <lambdabot> forall a. (Floating a) => a -> a -> a
07:48:22 <Cale> (Yes, there are really three exponentiation operators -- they correspond to separate definitions of exponentiation in mathematics)
07:48:43 <sjanssen> @seen gleb
07:48:43 <lambdabot> gleb is in #haskell. I last heard gleb speak 3m 47s ago.
07:49:02 <Qerub> Cale: Interesting. Thanks.
07:49:42 <Cale> (^) just works for positive integral exponents, but any kind of numeric base
07:49:48 <wli> I don't entirely see the point of (^^) given (^) and (**)
07:49:50 <gleb> sjanssen: i'm here ^)
07:50:00 <Cale> (^^) works for negative integral exponents as well, but requires a fractional base type
07:50:09 <wli> ah
07:50:25 <sjanssen> gleb: just noticed that you @seen'ed me
07:50:33 <Cale> (**) works for floating point exponents and bases
07:50:52 <Cale> (things where you can define exp and log)
07:51:54 <roconnor> > (-1)^^(-1)
07:51:56 <lambdabot>  -1.0
07:52:00 <roconnor> > (-1)**(-1)
07:52:01 <lambdabot>  -1.0
07:52:45 <roconnor> i find that a bit surprising.
07:52:46 <gleb> gleb: yes I did. Just wanted to tell you that your idea of using Language.Haskell.* for pretty-printing in ghci console is very neat
07:52:58 <gleb> sjanssen: yes I did. Just wanted to tell you that your idea of using Language.Haskell.* for pretty-printing in ghci console is very neat
07:53:24 <sjanssen> gleb: great!
07:54:04 <sjanssen> gleb: that might be useful enough to package up and put on hackage
07:55:17 <gleb> sjanssen: It's really simple (a couple of lines). I don't have access to hackage but i've already cabalized it for myself.
07:55:48 <Cale> roconnor: what's surprising about it?
07:56:02 <gleb> sjanssen: http://files.rsdn.ru/11829/ipprint.tar.gz
07:56:28 <jedai> roconnor: It seems to me it's correct mathematically speaking, what's the problem with it ?
07:56:34 * gleb is sorry for yelling so much about so simple thing today
07:57:23 <sjanssen> gleb: you can ask Ross Paterson for an account, or ask somebody with access to upload it for you (I can do that)
07:58:40 <ricky_clarkson> Why does sqrt ing a number not return some Complex instance?
07:58:48 <gleb> sjanssen: I like it either way. I'm a newbie so I doubt I'll use my hackage account much, but it won't harm to have one
07:58:49 <ricky_clarkson> > sqrt (-1)
07:58:50 <lambdabot>  NaN
07:59:02 <drigz> > sqrt (-1) :: Complex
07:59:03 <lambdabot>      `Complex' is not applied to enough type arguments
07:59:03 <lambdabot>     Expected kind `?',...
07:59:07 <drigz> > sqrt (-1) :: Complex Int
07:59:08 <lambdabot>   add an instance declaration for (RealFloat Int)
07:59:08 <lambdabot>     In the expression: sqrt...
07:59:12 <drigz> > sqrt (-1) :: Complex Float
07:59:13 <lambdabot>  -0.0 :+ 1.0
07:59:31 <roconnor> Cale: I expect (-1)**(-1) to be equal to exp(ln(-1)*(-1))
07:59:33 <ricky_clarkson> I know about that, but it's clear that I wanted a complex beause I'm sqrting one.
07:59:40 <ricky_clarkson> s/one/a negative/
07:59:41 <norpan> ricky_clarkson: the answer is that sqrt returns the same type you put in
08:00:10 <ricky_clarkson> norpan: That doesn't fit with the mathematical definition.
08:00:16 <wli> abs and signum are more involved of issues.
08:00:41 <gleb> sjanssen: if you find this package useful and could upload it, that'd be great
08:00:49 <drigz> ricky_clarkson: when you don't specify a type, the type system tries to make a decent guess. sometimes this guess will be wrong.
08:01:00 <Cale> roconnor: You want it to give NaN?
08:01:02 <norpan> ricky_clarkson: it depends on what mathematical definition you use, i suppose :)
08:01:25 <wli> ricky_clarkson: It does not automatically seek out an extension ring in which a square root exists. It's not a CAS.
08:01:41 <ricky_clarkson> drigz: Understood, but it seems the type of sqrt could be a -> Complex a or something.
08:01:48 <roconnor> Cale: a little.
08:01:58 <norpan> ricky_clarkson: Complex (Complex Float) makes little sense
08:02:01 <drigz> that would be really unhelpful for the vast majority of applications, i suspect
08:02:06 <ricky_clarkson> norpan: Hence "or something".
08:02:28 <norpan> if you want complex out, simply put complex in, it's not harder than that
08:02:29 <roconnor> > (-1)**(-1.000001)
08:02:31 <lambdabot>  NaN
08:02:33 <wli> ricky_clarkson: There are rings containing all square roots where that would ont be useful.
08:02:36 <roconnor> > (-1)**(-1.0000000000000000000000000000001)
08:02:37 <lambdabot>  -1.0
08:02:54 <ricky_clarkson> wli: What rings are you talking about?
08:03:13 <Cale> I think it's useful for (**(-1)) to give the multiplicative inverse (or an approximation to it), though
08:03:23 <ricky_clarkson> norpan: 3 is a complex number, if you view it that way.
08:03:27 <wli> ricky_clarkson: Complex double is an obvious one. There are p-adics of this nature as well.
08:03:32 <Cale> Even if it's sparsely defined there
08:03:35 <roconnor> Cale: why not stick with (^^(-1))?
08:03:50 <norpan> ricky_clarkson: so you just tell haskell to view it that way and it will return a complex number when you square root it
08:04:10 <norpan> i'm a big fan of not complicating things when you don't have to :)
08:04:11 <ricky_clarkson> > 1/2
08:04:13 <lambdabot>  0.5
08:04:36 <wli> I'm a big fan of not oversimplifying things when they're actually more complicated.
08:04:41 <ricky_clarkson> Oddly, 1/2 is a Rational, not an Int, but sqrt (-1) is NaN.
08:04:42 <doserj> roconnor, you surely want ^^ and ** to return the same, where both apply, don't you?
08:04:58 <Cale> ricky_clarkson: It's a Fractional
08:04:58 <Saizan> ?type (/)
08:05:00 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:05:08 <Saizan> ?type 1
08:05:10 <lambdabot> forall t. (Num t) => t
08:05:17 <roconnor> doserj: no so much.
08:05:24 <norpan> sqrt (-1) is not always NaN
08:05:33 <norpan> > sqrt (-1) :: Complex Double
08:05:34 <lambdabot>  -0.0 :+ 1.0
08:05:50 <norpan> it's just that the interpreter defaults to Float
08:05:50 <roconnor> doserj: (+) and (+) return different results for integers and doubles.
08:05:50 <drigz> @type sqrt (-1)
08:05:52 <lambdabot> forall a. (Floating a) => a
08:05:54 <ricky_clarkson> Cale: Right.
08:06:04 <doserj> roconnor, they don't (ideally)
08:06:07 <roconnor> doserj: oh wait, they do return the same result.
08:06:13 <roconnor> more or lesss
08:06:13 <wli> There are various n for which -1 is a quadratic residue in Z/nZ as well.
08:06:27 <norpan> well gotta go
08:07:05 <ricky_clarkson> When QuickCheck operates on Ints, why does it not pick the maximum and minimum representable values as cases to test?
08:07:10 <sjanssen> gleb: Cabal is case sensitive, it doesn't like the lower cased "ipprint.cabal" and the upper case "IPPrint" package name
08:07:17 <sjanssen> gleb: which shall I change?
08:07:33 <ricky_clarkson> @check \x -> x==0 || negate (x::Int) /= x
08:07:35 <lambdabot>  OK, passed 500 tests.
08:07:56 <gleb> sjanssen: what is common convention?
08:08:11 <sjanssen> gleb: most things a lower cased
08:08:12 <roconnor> @check \a b -> a^^b == (fromRational a)**(fromInteger b)
08:08:13 <lambdabot>   add an instance declaration for (Floating Rational)
08:08:17 <drigz> @check \x -> length [1..x] == x
08:08:18 <sjanssen> s/a /are
08:08:19 <lambdabot>  Falsifiable, after 2 tests: -1
08:08:30 <gleb> sjanssen: ok, so please change package name
08:08:31 <roconnor> @type fromRational
08:08:33 <lambdabot> forall a. (Fractional a) => Rational -> a
08:08:33 <drigz> @check \x -> x < 0 || length [1..x] == x
08:08:35 <lambdabot>  OK, passed 500 tests.
08:08:40 <roconnor> @check \a b -> a^^b == (fromRational a::Double)**(fromInteger b)
08:08:45 <lambdabot>  Couldn't match expected type `Rational'
08:08:58 <roconnor> @check \a b -> (a::Rational)^^b == (fromRational a::Double)**(fromInteger b)
08:08:58 <lambdabot>  Couldn't match expected type `Rational'
08:08:59 <gleb> sjanssen:  it's my first attempt at using cabal, and cabal manual uses HUnit as example
08:09:03 <roconnor> bah
08:09:19 <ricky_clarkson> > (\x -> x==0 || negate (x::Int) /= x) (-2147483648)
08:09:21 <lambdabot>  False
08:10:03 <drigz> @check \x -> x /= minBound
08:10:04 <lambdabot>  Add a type signature
08:10:12 <drigz> @check \x -> x :: Int /= minBound
08:10:12 <lambdabot>  Parse error
08:10:18 <drigz> @check \x -> (x :: Int) /= minBound
08:10:19 <lambdabot>  OK, passed 500 tests.
08:10:19 <xerox> ?check \x -> x /= 0 ==> negate (x::Int) /= x
08:10:20 <lambdabot>  OK, passed 500 tests.
08:11:03 <ricky_clarkson> Is ==> some guard syntax?
08:11:13 <drigz> @type (==>)
08:11:14 <ricky_clarkson> > type (==>)
08:11:14 <lambdabot>  Parse error
08:11:15 <lambdabot> Not in scope: `==>'
08:11:17 <xerox> Quickcheck implication
08:11:50 <xerox> In p ==> q, q is checked only if p is true.
08:12:00 <gleb> sjanssen: examples at http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html use camel-case for package names
08:12:01 <lambdabot> Title: 2. Creating a package
08:12:23 <sjanssen> gleb: yeah, it's not a universal convention
08:12:44 <xerox> ?type (Test.QuickCheck.==>)
08:12:46 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
08:14:09 <sjanssen> gleb: oh, you should add license and category fields
08:14:36 <sjanssen> gleb: hackage printed these warnings when I previewed the package:
08:14:41 <sjanssen>     * No license-file field.
08:14:41 <sjanssen>     * No category field.
08:14:41 <sjanssen>     * No description field.
08:14:41 <sjanssen>     * No maintainer field.
08:14:41 <sjanssen>     * Exposed modules use unallocated top-level names: IPPrint
08:14:57 <sjanssen> the last one isn't such a big deal
08:15:33 <gleb> sjanssen: I'm having trouble filling these fields
08:15:43 <sjanssen> well, maintainer is easy :)
08:15:52 <sjanssen> I'd suggest 'Text' for the category
08:16:19 <gleb> sjanssen: ok, thanks very much for your help
08:16:30 <gleb> sjanssen: I'll fix it right now
08:17:02 <gleb> sjanssen: how do I get these warnings?
08:17:28 <sjanssen> gleb: http://hackage.haskell.org/packages/upload.html
08:17:30 <lambdabot> Title: HackageDB: checking and uploading packages
08:17:36 <sjanssen> you don't need an account to preview the page
08:20:08 <gleb> sjanssen: is it ok to leave top-level name as it is? it's hard to find appropriate category and it should be very easy to type
08:20:27 <sjanssen> gleb: top level name is fine IMO
08:26:20 <Saul_> class Field a b | a -> b where
08:26:20 <Saul_>   showValue :: b -> RawValue
08:26:20 <Saul_>   readValue :: RawValue -> Maybe b
08:28:05 <Saul_> Can this work, or will I not be able to determine what 'a' I need when I use showValue or readValue?
08:28:17 <Saul_> (This is not the entire class btw)
08:28:33 <sjanssen> Saul_: no, that won't work
08:28:50 <Saul_> I can of course make showValue :: a -> b -> RawValue, but I don't need any data from a
08:29:14 <Saul_> ok so adding a to the input of the functions is the only solution?
08:29:21 <sjanssen> it *might* work if you had "class Field a b | a -> b, b -> a"
08:30:03 <Saul_> That does indeed work :)
08:30:14 <Saul_> But that isn't the case
08:30:26 <Saul_> I'll just add those a's I guess
08:31:35 <Saul_> sjanssen: Thanks
08:38:05 <gleb> what's correct way of creating cabalized tarball? I'm trying runhaskell Setup.hs sdist and getting 'file not found' - it cannot locate sources in the dist/src directory. I can copy it manually, but how is it done usually?
08:39:58 <sjanssen> gleb: sdist should work
08:40:02 <sjanssen> gleb: are you on Windows?
08:40:19 <gleb> sjanssen: yes. I'm on windows now
08:40:34 <sjanssen> gleb: I think it might be broken on Windows
08:40:53 <gleb> sjanssen: ok, I'll package it manually
08:43:01 <dcoutts> gleb, sjanssen: or you could fix it :-)
08:43:14 <dcoutts> gleb: it requires tar.exe
08:43:31 <dcoutts> and possibly gzip.exe too
08:43:40 <gleb> dcoutts: ah, I see. I'm using cygwin. but GHC cannot see it
08:43:58 <sjanssen> dcoutts: I have no idea why it's broken, I just notice ndm complaining about it ;)
08:44:02 <gleb> cygwin's bin is not on the windoze's PATH
08:44:16 <ndm> sjanssen: i'm just a complainer :)
08:44:16 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:34 <dcoutts> gleb: if it's not on the path we can't find it, ghc & cabal etc are not cygwin programs
08:44:43 <dcoutts> sjanssen: he complains that it needs tar at all, not that it can't find it
08:44:48 <gleb> dcoutts: yes. i understand it
08:45:11 <dcoutts> sjanssen: but I'm not sure there isn't still a bug there even when it does find tar.exe
08:45:11 <matthew-_> um, odd hardware question: typically, how long does it take to access a cached value in the L1 cache? Ball pack figure for recent x86 cpus?
08:45:26 <dcoutts> sjanssen: but I've not been able to get any clear description of what goes wrong
08:45:45 <dcoutts> matthew-_: 1-2 clock cycles iirc
08:46:18 <matthew-_> dcoutts: that's what I thought too. Thank you.
08:47:15 <gleb> sjanssen: http://files.rsdn.ru/11829/ipprint-0.1.tar.gz passes the checks
08:47:48 <shapr> yarr!
08:48:17 <sjanssen> gleb: LICENSE isn't in the tarball
08:48:32 <gleb> sjanssen: apologies ^(
08:50:39 <gleb> sjanssen: http://files.rsdn.ru/11829/ipprint-0.1.tar.gz should be ok (what else could go wrong? :))
08:53:14 <sjanssen> gleb: looks good, shall I upload it now?
08:53:33 <gleb> sjanssen: it would be great, thanks
08:54:39 <sjanssen> @hackage ipprint
08:54:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ipprint
08:54:54 <sjanssen> gleb++
08:55:00 <gleb> sjanssen++
08:55:07 <gleb> sjanssen: thanks a lot
09:08:32 <ptolomy> I was idly examining the speed of factorial implemented with IORefs and whileM compared to the simple foldl1' implementation. The simple one seems to win out in pretty much every situation, impressive as the generated core output for the 'imperative' version may be.
09:10:30 <Saizan> have you tried with ST?
09:11:14 <ptolomy> hmm.. isn't ST just IO under the hood?
09:11:22 <bos> no
09:11:44 <Saizan> it's IO that's ST + missiles
09:11:52 <ptolomy> hmm.
09:11:53 * ptolomy tweaks.
09:13:20 <Saizan> however ghc compiles foldl1' (*) [1..n] to a strict loop, i think
09:13:32 <sjanssen> @src IO
09:13:32 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:13:38 <sjanssen> @src ST
09:13:38 <lambdabot> newtype ST s a = ST (STRep s a)
09:13:43 <sjanssen> @src STRep
09:13:44 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
09:14:01 <sjanssen> IO is ST RealWorld, essentially
09:20:13 <Saul_> Argh
09:20:17 <Saul_> data Pretty a = Pretty String String a
09:20:17 <Saul_> instance (Field a b) => Field (Pretty a) b where
09:20:23 <Saul_> Why doesn't this work?
09:20:46 <Saul_> It says it fails the coverage condition for on of the functional dependencies
09:21:03 <Saul_> class Field a b | a -> b where
09:21:15 <desegnis> You've got an overlapping instance. every (Pretty a) is an a
09:21:27 <desegnis> wait
09:21:29 <desegnis> nonsense
09:21:39 <desegnis> confused type classes with types
09:21:57 <ooo>  /server -m irc.master-online.org:12000
09:24:55 <ptolomy> Woo. With ST, I was able to get the ugly factorial to run as fast as the non-ugly one.
09:25:09 <glen_quagmire> > (\y -> if y then "Yes" else "No") (\x -> True) "am i a troll"
09:25:11 <lambdabot>  Couldn't match expected type `t1 -> t'
09:25:51 <sjanssen> Saul_: the coverage condition is a conservative restriction to ensure decidability of typechecking
09:26:12 <sjanssen> Saul_: look in the GHC manual if you want the gritty details
09:26:49 <Saul_> :(
09:27:07 <Saul_> I don't really see how this wouldn't be type-safe though :(
09:27:48 <sjanssen> Saul_: type safety isn't the problem, termination of type checking is
09:28:08 <Saul_> Ok
09:28:42 <Saul_> I'll hpaste the entire code, maybe you can help me fix the code?
09:28:42 <sjanssen> you can use -fallow-undecidable-instances if you'd like -- just don't complain when GHC doesn't terminate when type checking ;)
09:31:07 <shachaf> -fallow-undecidable-instances can cause type checking not to terminate?
09:31:33 <hpaste>  Saul_ pasted "HTML Forms (not working though)" at http://hpaste.org/2533
09:31:42 <sjanssen> shachaf: yes, hence "undecidable" :)
09:31:55 <Saul_> I'd rather just "fix" my code
09:32:20 <Saul_> But I do actually need something like this to work, or it's back to the drawing board
09:33:39 <Saul_> So any suggestions, or should I just use -fallow-undecidable-instances and hope for the best?
09:34:05 <Saizan> newtype W a = W a, instance (Field a b) => Field (Pretty a) (W b) where will make ghc happy, iirc
09:34:06 <sjanssen> -fallow-undecidable-instances should be okay
09:34:57 <jedai> @src rem
09:34:57 <lambdabot> Source not found. I feel much better now.
09:35:14 <Saul_> Saizan: Isn't that rather cumbersome?
09:35:41 <sjanssen> Saizan: I think that will still fail the coverage condition
09:36:25 <Saizan> Saul_: i'd use the flag, in fact
09:36:50 <Saul_> I guess I'll use -fallow-undecidable-instances then
09:37:18 <Saul_> well it compiled :)
09:38:33 <Saul_> Hopefully in a few weeks I'll have a full-fledged html form system
09:39:06 <chadz> what's the <?> function called again?
09:39:09 <chadz> I can never remember
09:39:15 <shapr> Saul_: Have you seen the way HAppS does html forms from Haskell datatypes?
09:39:28 <Saul_> Nope
09:39:37 <Saul_> I didn't know it did html forms at all
09:39:50 <shapr> It does now :-)
09:40:22 <Saizan> sjanssen: you're right, that newtype works in other situation, here we'd need newtype W a b = W a; instance (Field a b) => Field (W (Pretty a) b) b
09:40:35 <Saul_> shapr: Is it explained anywhere?
09:40:51 <Saizan> it's demoed!
09:41:12 <hpaste>  sjanssen annotated "HTML Forms (not working though)" with "with GHC 6.7's type families" at http://hpaste.org/2533#a1
09:41:13 <shapr> It's done in two parts. There's a typeclass to turn a GET/POST into a value of a particular type, and a form field is generated for each part of the type.
09:41:33 <shapr> Saul_: Does that explanation help any?
09:41:58 <Saul_> A little
09:42:17 * sjanssen <3 type families
09:43:34 <Saul_> My idea will allow you to build a form as a tree of fields
09:43:56 <shapr> Sounds cool, will it be BSD3 or so?
09:44:11 <Saul_> I'm not sure what BSD3 is?
09:44:24 <shapr> I was just asking about the license the code will be released under.
09:44:33 <Saul_> Oh, I'm not sure yet
09:44:42 <Saul_> I haven't actually ever released code
09:44:53 <chadz> Saul_: you should sell it.
09:45:07 <shapr> chadz: Have you sold code?
09:45:11 <Saul_> Nope
09:45:20 <njbartlett> shapr: I'm looking for ideas for talks at future meetings of the London Haskell User Group, and it's been suggested to me that people would like to hear about HAppS. Are there any HAppS people in or near London?
09:45:24 <chadz> shapr: not really :)
09:45:24 <Saul_> I'm just young and inexperienced
09:45:30 <shapr> Saul_: Ooh, me too!
09:45:34 <shapr> Ok, I'm not young...
09:45:44 <shapr> but I claim inexperience!
09:46:00 <shapr> njbartlett: Lemmih is in Denmark :-)
09:46:37 <njbartlett> shapr: Hmm, right continent at least!
09:46:48 <Saul_> Anyway the idea of the system is that you will only need to build one field (the top-level one) for a data type to make a form out of it
09:47:04 <Saul_> so an entire form is equal to a single text field
09:47:11 <shapr> njbartlett: Igloo is in Cambridge, he might talk about it.
09:47:19 <shapr> Er wait, he's not in Cambridge?
09:47:40 <shapr> Saul_: Huh?
09:47:46 <njbartlett> Cambridge England, or Cambridge Massachusetts? ;-)
09:48:05 <shapr> I'm 99% sure Igloo lives in England, but I'm not really sure where.
09:48:10 <Philippa> njbartlett: let me know if there's anything interesting I might do sometime, btw
09:48:23 <Saul_> shapr: http://hpaste.org/2533
09:48:40 <Saul_> Here is a type class called Field a b
09:48:42 <njbartlett> Philippa: Hi! Yeah, I'm sure there is. How about you suggest something? I'm basically just looking for ideas
09:48:54 <Philippa> okay, not tonight though
09:48:56 <Igloo> I'm in Oxford, England
09:49:03 <shapr> Saul_: That's surprisingly similar to some of the HAppS code.
09:49:23 <Saul_> shapr: Well that's nice to hear
09:49:44 <njbartlett> Philippa: Okay no worries. We have the september meeting sorted out, so the next "proper" meeting with talks etc will be November
09:50:18 <Philippa> remind me when the september meeting is? Though I probably can't make it
09:50:31 <njbartlett> Igloo: Hi... so do you think you can help me out?
09:50:33 <njbartlett> Philippa: 20th
09:51:30 <Saul_> shapr: I've been thinking about stuff for weeks and came up with nothing
09:51:47 <njbartlett> Philippa: http://www.londonhug.net/2007/08/31/next-meeting-20th-september/
09:51:49 <lambdabot> Title: Î»ondon HUG » Blog Archive » Next Meeting 20th September
09:52:23 <Saul_> shapr: Yesterday I figured I would draw a tree as an example, and try to see some induction in it
09:52:37 <Saul_> and this is what I came up with so far
09:53:19 <Igloo> njbartlett: not sure
09:53:26 <Saul_> I still need to add some code for constraints on user input
09:53:29 <Philippa> njbartlett: heh, I think it's the next day I make it into town :-)
09:53:45 <shapr> Saul_: HAppS has a separate class to map from a Request to a value, and a separate class for serialization (though it's pretty much Read/Show right now).
09:54:05 <Philippa> though actually I might be able to change that
09:54:26 <Philippa> hmm, and Binkley's due in the UK around then too
09:54:35 <njbartlett> Igloo: It's a very friendly group. Kind of a microcosm of #haskell really! Even a short talk would be fine. Although I appreciate travel plans might always work out
09:54:48 <Saul_> shapr: Well I can split it up I guess, but I'm not sure if that's going to be usefull
09:54:57 <njbartlett> Philippa: Go on, you know you want to ;-)
09:55:59 <ricky_clarkson> Someone said on my blog "Wasn't there a philosopher who proved that you can never describe a system in the system itself?".  Anyone know who/what he means?
09:56:14 <oerjan> probably meant Godel
09:56:23 <Philippa> yeah, only normally I'm only good for three days and I want to meet up with Binkley separately and there's polyday on the 22nd (also my birthday) and I really ought to actually spend some time with my boyfriend
09:56:31 <Saul_> shapr: I wish I had a scanner, then I could show you the tree I drew. It has pretty much any kind of form I can think of
09:56:46 <shapr> Saul_: digicam?
09:56:53 <desp> oerjan: that's not what Godel said, though, no?
09:57:10 <oerjan> well if you hand-wave enough...
09:57:24 <ricky_clarkson> Is the statement true?
09:57:32 <dolio> People do love hand-waving Goedel.
09:57:33 <byorgey> no, Goedel's result is based on the fact that you CAN describe a system in the system itself.
09:57:37 <shapr> oerjan: I thought Godel said "Russel & Whitehead ... PWND!"
09:57:38 <njbartlett> Sounds like somebody read the first couple of hundred pages of Godel Escher Bach before giving up
09:57:40 <oerjan> ricky_clarkson: depends on your definition of "describe"
09:57:50 <holst> im trying to compile a happy script
09:57:55 <holst> and im getting the following error:
09:57:55 <Saul_> shapr: Including variably sized lists of subfields, choices between various subfields (of different types) and fields like dates based on fields for days, months and years
09:57:58 <byorgey> shapr: pretty much =)
09:58:04 <Saul_> shapr: Nope, sorry
09:58:06 <holst> na56:~/experiment/happy>happy happy.y
09:58:06 <holst> happy: parE
09:58:08 <desp> oerjan: from my blurry recollection of GEB, I think the crucial thing was that a system is either incomplete or inconsistent
09:58:28 <Saul_> shapr: I guess I'm technologically crippled
09:58:36 <shapr> Me too...
09:58:42 <shapr> So I just do everything on the screen :-)
09:59:07 <byorgey> desp: right
09:59:09 <Saul_> Me too, that's why it took me 2 week to finally start drawing stuff on paper
09:59:14 <shapr> heh
09:59:21 <ricky_clarkson> Thanks, looking into Godel.
09:59:27 <njbartlett> Right... he showed that it's always possible to create a statement "this statement cannot be proven". If the system is able to prove the statement, then it is inconsistent. If it is unable to prove it, it's incomplete. Or something like that.
10:00:19 <Saul_> btw, if I want to tie my system into happs, should I use the standard XHTML library?
10:00:21 <oerjan> njbartlett: that's a more precise handwaving, yes ;)
10:01:00 <wli> njbartlett: Not that the statement is true but that its either true or false.
10:01:40 <wli> njbartlett: If the statement is decidable then the system is inconsistent.
10:01:54 <Saul_> shapr: btw, if I want to tie my system into happs, should I use the standard XHTML library?
10:02:19 <njbartlett> wli: Thanks. My recollection of GEB is pretty hazy too
10:02:27 <wli> GEB?
10:02:47 <njbartlett> Godel, Escher Bach. The book by Hofstadter
10:03:02 <wli> No idea why that's significant.
10:03:33 <oerjan> wli: it's the book that popularized Godel's proof
10:03:34 <njbartlett> It's significant because most people would never have heard of Godel if they hadn't read it. Including me.
10:04:32 <wli> I thought it was just bonehead logic.
10:04:45 <wli> Russell/Epimenides.
10:05:20 <wli> Suitably generalized, of course.
10:05:34 <oerjan> wli: well it is an embedding of that into a formal setting.  The halting problem is another.
10:06:01 <oerjan> and described in GEB too, i guess? (never finished reading it)
10:06:35 <oerjan> and the uncountability of the reals is a third.
10:06:38 <wli> It struck me as a sort of strange pop science.
10:07:30 <njbartlett> Yeah, that book was like Stephen Hawkins'. Everybody bought it, nobody got past the first 20 pages
10:07:30 <oerjan> wli: well it is, but some of the results _are_ important in the foundation of various fields
10:08:09 <njbartlett> Well... "nobody" in the sense of Wadler's "why does nobody use functional programming languages" ;-)
10:08:38 <wli> Someone gave me a copy. I was disappointed because I was a snob about "real math" and it was popsci.
10:09:43 <wli> They were unable to find (or probably afford, never mind understand) the real things.
10:10:24 <foones> How can I get the path of the module Hugs.Base I am using?
10:12:14 <wli> If I'd showed them where to order e.g. books from the Springer GTM series they'd have crapped their pants and bought GEB anyway.
10:12:27 <desp> Godel's theorem is part of the comp-sci curriculum here
10:12:45 <desp> but I read the book first :)
10:14:21 <wli> I'd not read up on logic beforehand but I'd seen enough foundations discussions to know better, and had also heard of the various paradoxes to be concerned with.
10:15:47 <wli> Including Godel and Turing as instances of Russell/Epimenides that were not fatal or necessarily indicative of inconsistency.
10:16:27 <mrd> it was boneheaded in the 30s when all the mathematicians at the time hadn't thought of it
10:16:31 <mrd> wasn't*
10:17:31 <psykotic> there are some lesser known theorems that are more general and equally startling
10:17:36 <psykotic> also simpler and easy to prove
10:17:54 <wli> Really? Like what?
10:17:59 <psykotic> tarski's indefinability theorem
10:18:07 <wli> Oh yeah.
10:19:08 <psykotic> smullyan's has this awesome paper from the 80s that investigate "systems capable of self-reference" in great detail and one of the things you see is an equivalent of the indefinability theorem, but nothing like goedel's theorems
10:19:30 <psykotic> there are many hints that goedel's theorems are much less important than it
10:19:58 * psykotic tries to remember the name of that smullyan paper
10:20:22 <psykotic> Diagonalization and Self-Reference
10:20:30 <therp> an empty piece of paper is a beautiful thing (/me looks at the pile of paper scribbled with sketches leading to dead ends). I'm always excited what the first few strokes might bring.
10:20:53 <psykotic> hmm, that looks like it's a book. maybe i'm thinking of Fixed Points and Self-Reference instead
10:21:17 * oerjan remembers a song about empty papers and such, unfortunately it's in norwegian
10:21:26 <psykotic> wli: have you read any of smullyan's puzzle books?
10:21:29 <oerjan> *pieces of
10:21:57 <wli> psykotic: I tend to avoid such things.
10:22:06 <psykotic> your loss.
10:22:37 <pejo> psykotic, are you advocating puzzles in general, or just his books?
10:22:49 <psykotic> well, i like them in general, but his are particularly great
10:22:57 <psykotic> they tend to be at the frontier of formal logic at the time they're published
10:23:21 <psykotic> most of the earlier ones deal heavily in the intricacies of self-reference
11:08:37 <byorgey> @yow
11:08:37 <lambdabot> Where does it go when you flush?
11:09:04 <Spark> ##c++
11:09:18 <byorgey> hehe
11:13:41 <psykotic> the turd terminus, as it were
11:16:14 <sjanssen> "turd terminus", eh?  Now I have to read the logs :)
11:17:10 * psykotic applies for a trademark, since that phrase is apparently google-free
11:17:11 <dcoutts> @seen pgavin
11:17:12 <lambdabot> pgavin is in #haskell. I don't know when pgavin last spoke.
11:20:18 <ibid> sjanssen: 21:07  <lambdabot> Where does it go when you flush?
11:26:23 <hpaste>  iguana pasted "(no title)" at http://hpaste.org/2534
11:26:40 <iguana_> anybody around to help me trivially?
11:26:54 * sjanssen wants to help profoundly
11:27:15 <sjanssen> iguana_: what is the problem?
11:27:17 <iguana_> see the announced paste -- I feel like the way I transform the list to the map is very unhaskelly
11:27:46 <Saul_> @src Maybe a
11:27:46 <lambdabot> Source not found. Do you think like you type?
11:27:52 <Saul_> @src Maybe
11:27:52 <lambdabot> data Maybe a = Nothing | Just a
11:27:57 <Botje> iguana_: process' looks like a foldr
11:28:09 <Saul_> @src Monad (Maybe a)
11:28:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:28:17 <sjanssen> iguana_: I think you want to use a list comprehension here
11:28:17 <Saul_> @src Monad Maybe
11:28:18 <lambdabot> Source not found. Take a stress pill and think things over.
11:28:20 <Botje> and so does process''
11:28:43 <iguana_> ah, the mysterious foldings :)
11:29:25 <hpaste>  sjanssen annotated "(no title)" with "use a list comprehension" at http://hpaste.org/2534#a1
11:29:35 <sjanssen> iguana_: how does that look?
11:29:59 <iguana_> sjanssen: very nice!
11:31:47 <sjanssen> iguana_: as a general rule of thumb: if you're writing explicit recursion, you're doing something wrong
11:32:11 * DRMacIver eyes sjanssen 
11:32:12 <DRMacIver> Wha?
11:32:24 <iguana_> how would it look like with a foldr?
11:32:43 <sjanssen> DRMacIver: good Haskell style is all about identifying these common patterns and factoring them out
11:33:19 <hpaste>  Botje annotated "(no title)" with "fwiw: with folds" at http://hpaste.org/2534#a2
11:33:28 <Botje> iguana_: poke :)
11:33:32 <sjanssen> don't write "f [] = blech; f (x:xs) = blah x (f xs)", write "foldr blah blech"
11:34:09 <DRMacIver> No comment.
11:34:21 * iguana_ feels poked but enlightened
11:34:37 <Botje> @pl \n -> insert n size
11:34:37 <lambdabot> flip insert size
11:34:41 <Botje> obviously
11:34:53 * Botje feels dumb now
11:35:20 <Botje> oh well, the \n makes it clearer
11:35:32 <iguana_> a bit, yes
11:39:47 <iguana_> hm, can I convert values in a pattern?
11:40:00 <iguana_> I've something like [arg1, arg2, arg3] <- getArgs
11:40:08 <iguana_> and I need arg1 to be an Integer
11:40:10 <dino-> I was talking to dons one day here and commented that what he was up to seemed like "a funny kind of fold"..
11:40:22 <dino-> And he said "everything is a funny kind of fold, isn't it?" or similar
11:40:50 <Botje> iguana_: you need to use read to convert it to an integer
11:40:56 <iguana_> yep
11:40:57 <byorgey> iguana_: just use (read arg1) wherever you want the integer
11:41:22 <iguana_> okay
11:41:48 <sjanssen> iguana_: I'd just use 'let'
11:42:15 <sjanssen> do [arg1string, arg2, arg3] <- getArgs; let arg1 = read arg1string
11:43:55 <sjanssen> do [arg1string, arg2, arg3] <- getArgs; arg1 <- readIO arg1string -- is even better
11:44:06 <iguana_> why is it better?
11:44:35 <sjanssen> readIO will throw an IO exception if it can't parse the number
11:45:03 <iguana_> it doesn't like both versions :(
11:45:14 <iguana_> something about monomorphism
11:45:27 <dcoutts> sjanssen: Lemmih: btw, Cabal just got pkg-config support, you might like to use it in future for sdl, xcb etc.
11:45:37 <psykotic> try adding a type annotation to arg1
11:45:40 <dcoutts> pkgconfig-depends: sdl >= 1.2
11:45:40 <Botje> iguana_: you can always explicitly type it
11:45:46 <Botje> let arg1 = read arg1string :: Int
11:46:05 <iguana_> okay, that works
11:46:09 <iguana_> but not with readIO
11:46:26 <oerjan> the monomorphism message would disappear when you add something that uses arg1
11:46:32 <oerjan> i think
11:46:33 <dino-> Shouldn't that be dealt with by whatever is subsequently usign the arg1 in this sequence of code?.. nm
11:46:42 <Botje> yes
11:46:47 <Botje> but it may not be very well specified.
11:46:51 <oerjan> dino-: i think so
11:46:52 <iguana_> I'm using it with arithmetic operations like / and * only
11:46:53 <Botje> (ie if he's not using arg1 yet)
11:47:00 <psykotic> oerjan, only if he uses it in a particularly narrow way. for example, if he uses it only as a Num, it won't be able to infer enough.
11:47:15 <psykotic> (i think)
11:47:18 <oerjan> psykotic: but it would default then
11:47:24 <psykotic> to Int?
11:47:42 <oerjan> Integer, usually
11:47:46 <psykotic> i thought that was only at the interactive prompt it did that for Num instances
11:47:47 <dino-> ya. I've seen that come up with things like Text.Printf
11:47:52 <oerjan> unless you add a default declaration
11:48:26 <iguana_> oh, I have to use "IO Int" for readIO, right?
11:48:38 <oerjan> iguana_: that's one possibility
11:49:03 <iguana_> or can I say " arg1 :: Int <- readIO arg1string "?
11:49:27 <psykotic> the latter you can do, but it requires -fglasgow-exts
11:49:42 <iguana_> that strikes me as the prettiest version
11:49:45 <psykotic> yes
11:50:05 * iguana_ sends thanks to glasgow for that :)
11:50:34 <oerjan> you could even use pattern guards, couldn't you?
11:50:43 <bos> @seen sjanssen
11:50:43 <lambdabot> sjanssen is in #happs, #gentoo-haskell, #haskell-overflow, #xmonad and #haskell. I last heard sjanssen speak 6m 7s ago.
11:50:51 <iguana_> "pattern guards"?
11:50:53 <bos> sjanssen: what's your ipprint package do?
11:51:00 <oerjan> another extension.
11:51:10 <oerjan> hm, they may not be allowed in do <- ?
11:51:28 <sjanssen> bos: it's not mine, I just uploaded it for gleb
11:51:34 <bos> ah
11:51:38 <sjanssen> bos: it uses Language.Haskell to pretty print Show output
11:52:12 <oerjan> is do [arg1string, arg2, arg3] | arg1 <- read arg1string <- getArgs legal?
11:52:41 <oerjan> well, not particularly better
11:53:21 <sjanssen> @type do x | 'x' <- last x <- getLine; return x
11:53:23 <lambdabot> parse error on input `|'
11:53:49 <oerjan> no guards in do :(
11:54:45 <iguana_> I guess for such a small set of data I can leave out the whole Data.Map thingy and use an association list
11:55:13 <oerjan> @type let x | 'x' <- last x = ['a'..] in x
11:55:15 <lambdabot> [Char]
12:07:15 <byorgey> > let x | 'x' <- last x = ['a'..] in x
12:07:15 <lambdabot>  Parse error
12:07:34 * byorgey is confused
12:08:24 <sjanssen> byorgey: pattern guards aren't turned on
12:08:28 <int-e> byorgey: pattern guards are not Haskell 98
12:09:19 <int-e> and @run uses a haskell 98 parser to validate expressions
12:09:20 <oerjan> byorgey: @type is much more liberal than @run
12:09:45 <byorgey> ok, I see
12:10:16 <Botje> \@run is more of a conservative, really
12:10:28 <byorgey> how do pattern guards work?
12:12:22 <oerjan> they are like a case match except that if it fails, the guard falls through to the next in a way that cannot be easily expressed with case
12:12:42 <byorgey> hmm...
12:12:56 * byorgey prints out the Erwig/SPJ paper
12:13:12 <oerjan> they're "to the left of the equals sign", before it has been crossed
12:15:10 <oerjan> so the above example is equivalent to let x = ['a'..] in case last x of 'x' -> x
12:15:26 <byorgey> oerjan: ok, I think I see
12:15:35 <oerjan> but if there had been more than one guard, that translation would not have worked
12:16:39 <oerjan> (or more than one equality for x)
12:16:55 <byorgey> hm, but let x | 'x' <- last x = ['a'..'x'] in x loops infinitely too
12:17:17 <byorgey> whereas let x = ['a'..'x'] in case last x of 'x' -> x works fine
12:17:39 <oerjan> oh right
12:18:08 <oerjan> so it's more like let x = case last x of 'x' -> ['a'..'x'] in x
12:18:34 <byorgey> ok, right
12:29:30 <roconnor> @hoogle lookUp
12:29:30 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:29:30 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
12:29:30 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
12:29:45 <roconnor> @hoogle findWithDefault
12:29:46 <lambdabot> Data.IntMap.findWithDefault :: a -> Key -> IntMap a -> a
12:29:46 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
12:30:59 <roconnor> Can I use record syntax in newtype?
12:31:22 <oerjan> roconnor: sure
12:31:26 <oerjan> @src State
12:31:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:31:35 <oerjan> that would have been an example
12:32:00 <oerjan> if @src hadn't been _curse_ backwards!
12:38:18 <shapr> @yow !
12:38:18 <lambdabot> I like the way ONLY their mouths move ...  They look like DYING OYSTERS
12:39:14 <Heffalump> roconnor: newtype Foo a = Foo { unFoo :: (a, a) } is a very standard idiom
12:40:00 <Saul_> shapr: I have made a drawing of my idea in Dia, do you want to see it?
12:42:34 <Saul_> Or maybe someone else?
12:45:24 <roconnor> @type fromList
12:45:27 <lambdabot> Not in scope: `fromList'
12:45:32 <roconnor> @hoogle fromList
12:45:33 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
12:45:33 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
12:45:33 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
12:45:48 <oerjan> @list hoogle
12:45:48 <lambdabot> hoogle provides: hoogle hoogle+
12:45:53 <oerjan> @hoogle+
12:45:53 <lambdabot> Data.Map.fromList :: Ord k => [(k, a)] -> Map k a
12:45:54 <lambdabot> Data.Set.fromList :: Ord a => [a] -> Set a
12:45:54 <lambdabot> Data.IntMap.fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
12:53:06 * roconnor reduces the code in his portfolio optimizer by 30%
12:53:11 <roconnor> ie 20 lines
12:57:03 <roconnor> fromReal :: (Fractional a, Real b) => b -> a
12:57:03 <roconnor> fromReal = fromRational . toRational
12:57:14 <roconnor> I think that should be in the Standard Library.
12:57:20 <xerox> I think that is very slow?
12:57:30 <roconnor> @src fromIntegral
12:57:30 <lambdabot> fromIntegral = fromInteger . toInteger
12:57:37 <shapr> Saul_: sure, where is it?
12:57:41 <oerjan> it isn't? o_O
12:57:49 <roconnor> @hoogle fromReal
12:57:49 <lambdabot> No matches found
12:58:08 <Cale> :t realToFrac
12:58:10 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:58:11 <Saul_> shapr: I'm adding some explanations to it now, I'll be done in a few minutes
12:58:18 <roconnor> Cale: hey hey!
12:58:24 <shapr> spiffy
12:58:27 <roconnor> another 3 lines gone!
12:58:48 <roconnor> Cale: crappy name, but I can live with it.
12:59:28 <roconnor> @karma+ Cale
12:59:29 <lambdabot> Cale's karma raised to 42.
13:00:01 <Saul_> shapr: Do you have Dia or should I post a .png?
13:01:26 <roconnor> @src realToFrac
13:01:27 <lambdabot> realToFrac = fromRational . toRational
13:01:47 <Saul_> shapr: http://www.independentgames.net/haskell/tree.png
13:02:00 <Saul_> shapr: The .dia file is also there if you want it
13:02:51 <dcoutts> @seen pgavin
13:02:51 <lambdabot> pgavin is in #haskell. I don't know when pgavin last spoke.
13:03:17 <int-e> > let x = toRational (1/0 :: Float); y = fromRational x in (y :: Double, realToFrac (1/0 :: Float) :: Double)
13:03:18 <lambdabot>  (3.402823669209385e38,Infinity)
13:03:34 <Saul_> shapr: It's a pretty concrete idea, I had this in my head and then tried to generalize it
13:04:34 <int-e> > (fromRational (toRational (1/0 :: Float)) :: Double, realToFrac (1/0 :: Float) :: Double) -- oh it works without the lets, too
13:04:36 <lambdabot>  (3.402823669209385e38,Infinity)
13:06:53 <roconnor> come on, 3.402823669209385e38 is practically infinity ;)
13:07:38 <int-e> I see it as a feature, not a bug; getting Haskell 98 behaviour would make converting floats to double *a lot* slower.
13:08:16 <roconnor> int-e: is is certainly no different than (-1.0)^(-1.0) being (-1.0)
13:08:21 <roconnor> er
13:08:28 <roconnor> no different than (-1.0)**(-1.0) being (-1.0)
13:08:40 <roconnor> @src (**)
13:08:40 <lambdabot> Source not found. You type like i drive.
13:08:41 <int-e> that's demanded by ... posix? well the C standard library.
13:08:45 <roconnor> woah
13:08:57 <int-e> for its pow() function.
13:09:02 <roconnor> does (**) belong to the class?
13:09:34 <roconnor> oh it does
13:09:38 <int-e> yep
13:09:41 <roconnor> int-e: never mind me then.
13:12:30 <monochrom> I like Haskell.
13:12:38 <int-e> realToFrac is on my personal list of 'bad' functions anyway - conversion should be done with a two parameter type class. (which, I realize, Haskell 98 doesn't have either).
13:13:29 <roconnor> int-e: along with fromIntegral?
13:14:06 <int-e> fromIntegral too, but it feels a bit more sound.
13:15:14 <xerox> I think the split-from-base packages should be checkpointed, they go from 400 to 800 patches for a clean darcs get.
13:15:19 <roconnor> Well, I'm sure realToFrac has been specialized at various instances.
13:15:38 <roconnor> Of course whenever I'm sure that haskell is doing some optimization, it usually turns out that it isn't.
13:15:54 <int-e> ghc specializes realToFrac with rules.
13:16:02 <roconnor> thank goodness
13:16:09 <int-e> (it's not part of any type class)
13:18:00 <Saul_> shapr: Still there?
13:35:08 <holst> anyone here got time to help me to make a very simple paraser?
13:35:17 <holst> or know about BNF
13:35:24 <holst> http://www.mypastebin.com/?code=794967825 <- bnf code for the language
13:37:45 <monochrom> There are too many "."s.
13:37:57 <Mat^> holst:
13:38:05 <Mat^> holst: actually I have been doing parser last week
13:38:12 <Mat^> holst: you should check parsec manual
13:38:29 <Mat^> I am lame with haskell, and did pretty nice parser ;>
13:38:46 <Mr_Awesome> ive been looking at that scheme parser tutorial
13:39:15 <holst> parsec
13:39:17 <Mr_Awesome> and it doesnt interpret separators properly. i think you need to have backtracking to implement that
13:39:21 <holst> ill check it out
13:39:24 <Mr_Awesome> which sucks
13:43:25 <Mat^> Mr_Awesome: you mean parsec doesn't interpret separators properly?
13:50:06 <thoughtpolice> hm. is the ghc package (or more accurately the API) simply everything in ghc-6.6.1/compiler/main?
13:51:18 <thoughtpolice> from the looks of it, that's what I'm thinking. but I don't know how the compiler deals with that particular package...
14:00:29 <Mr_Awesome> Mat^: i mean the r5rs grammar isnt as simple as it looks
14:00:40 <Mr_Awesome> it requires backtracking to give the correct behavior
14:03:08 <judahj> thoughtpolice: it's actually all the modules under ghc-6.6.1/compiler (minus a couple like main/Main.lhs which isn't appropriate to an API).
14:03:29 <thoughtpolice> judahj: ah. cool!
14:12:32 <shapr> Saul_: I don't really get the Diagram as much as I would understand code, I think.
14:13:23 <Saul_> shapr: http://hpaste.org/2533 This is some code
14:13:48 <Saul_> shapr: that should be a generalization of the diagram
14:25:03 <Mr_Awesome> @src Monad fmap
14:25:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:25:17 <Mr_Awesome> @src [] fmap
14:25:17 <lambdabot> fmap = map
14:25:24 <Mr_Awesome> @src Maybe fmap
14:25:24 <lambdabot> fmap _ Nothing       = Nothing
14:25:24 <lambdabot> fmap f (Just a)      = Just (f a)
14:25:53 <Mr_Awesome> @pl \f m -> m >>= (f . return)
14:25:53 <lambdabot> (=<<) . (. return)
14:26:02 <Mr_Awesome> @pl \f m -> m >>= (return . f)
14:26:02 <lambdabot> fmap
14:26:06 <Mr_Awesome> @unpl fmap
14:26:06 <lambdabot> fmap
14:26:26 <augustss> The previous @pl is wrong
14:26:38 <Mr_Awesome> it is?
14:26:40 <Mr_Awesome> how so?
14:26:54 <augustss> Yes, Functor is not a superclass of Monad
14:27:06 <augustss> so there's no guarantee that fmap is defined
14:27:07 <Heffalump> I suspect @pl was written by the people that want it to be :-)
14:27:23 <sjanssen> augustss: pl cheats pretty often
14:27:25 <Mr_Awesome> right
14:27:26 <augustss> Functor should be a superclass, and it used to me
14:27:35 <augustss> s/me/be
14:27:35 <sjanssen> @pl \x y -> y + x
14:27:36 <lambdabot> (+)
14:27:42 <augustss> yeah, i know
14:27:52 <augustss> sad
14:27:59 <Heffalump> that's correct, isn't it?
14:28:00 <sjanssen> augustss: do you know why it happened?
14:28:09 <sjanssen> Heffalump: not for all (+)
14:28:20 <Heffalump> which ones isn't it?
14:28:29 * mrd mumbles something about modules with axioms
14:28:41 * Heffalump tries to think about what happens with FP infinities
14:28:51 <augustss> sjanssen: someone thought that Functor doesn't have to be a superclass.  Which is true.  But a lot of other superflous superclasses was left in there.
14:29:32 <augustss> Heffalump: there's no guarantee + is commutative
14:29:32 <sjanssen> instance (Eq a, Show a) => Num [a] where (+) = (++)
14:29:49 <Mr_Awesome> regardless, pl is awesome
14:29:55 <Heffalump> oh, yeah, fair enough
14:30:03 <sjanssen> > let (+) = (++) in ("x" + "y", "y" + "x")
14:30:07 <lambdabot>  ("xy","yx")
14:30:21 <augustss> Yes, pl is neat.  And almost correct.
14:30:36 <Mr_Awesome> wow, it really smells like spoiled milk in here
14:30:41 <Mr_Awesome> bad
14:30:52 <Mr_Awesome> i probably should go empty that jug of spoiled milk
14:31:00 <sjanssen> pl should have a "correct" mode and a "nearly correct" mode
14:31:06 <Mr_Awesome> sorry, wrong channel...
14:31:13 <augustss> sjanssen: yes
14:31:41 <mrd> > let (+) = (++); x == y = all (`elem` y) x in ("x"+"y") == ("y"+"x")
14:31:42 <lambdabot>  True
14:32:16 <Mr_Awesome> and then, just for fun, it should have a "completely wrong" mode
14:32:25 <Heffalump> @pl \a b -> return a >>= b
14:32:25 <lambdabot> flip id
14:32:38 <Heffalump> so where do you guys stand on that one? :-)
14:32:41 <sjanssen> plWrongMode = const "undefined"
14:33:38 <augustss> Heffalump: you can replace the first with the second, so it's half ok
14:33:44 <sjanssen> Heffalump: what is it doing there?  Using (>>=) from the ((->) a) Monad?
14:34:05 <xerox> sjanssen: yeah, that's a monad law
14:34:15 <xerox> err, "no" I mean.
14:34:20 <sjanssen> oh, 'return'
14:34:22 <augustss> return a >>= b  ===  b a, according to the monad laws
14:34:23 <sjanssen> I get it now
14:34:40 <Heffalump> there's no guarantee that an implementation of Monad satisfies the laws, is what I meant
14:34:48 <augustss> it's a bit dofgy, since we don't know that the monad laws hold
14:34:55 <augustss> ah
14:34:58 <augustss> yes
14:35:24 <augustss> it should only be used in the almost correct mode
14:35:26 <Heffalump> on the other hand they have higher status than (+) being commutative, since the report says they should
14:35:27 <sjanssen> I'd say it goes in the "almost correct" pile, with the (+) thing
14:36:05 <augustss> @pl \ x -> x == x
14:36:05 <lambdabot> join (==)
14:36:18 <augustss> at least it didn't say 'const True'
14:36:21 <Mr_Awesome> haskell boggles my mind
14:36:25 <monochrom> No, PL's don't need modes. Programmers do.
14:36:50 <Heffalump>  @pl is more of a programmer than a PL.
14:37:02 <augustss> Mr_Awesome: Haskell boggles my mind too. :)
14:37:09 <monochrom> oh well
14:37:27 <monochrom> @remember augustss Haskell boggles my mind too. :)
14:37:27 <lambdabot> Done.
14:37:28 <Heffalump> bah, none of you have just spent three weeks figuring out Lennart's code without him there to ask about it ;-)
14:38:46 <Heffalump> @pl \ x -> x == x && x /= x
14:38:46 <lambdabot> ap ((&&) . join (==)) (join (/=))
14:39:11 <augustss> @pl \ x -> x x x x x x x
14:39:12 <lambdabot> join (join (join (join (join (join id)))))
14:39:28 <monochrom> x_x
14:39:41 <Heffalump> @type \ x -> x x x x x x x
14:39:43 <lambdabot>     Occurs check: cannot construct the infinite type:
14:39:43 <lambdabot>       t = t -> t -> t -> t -> t -> t -> t1
14:39:51 <Heffalump> @type join (join (join (join (join (join id)))))
14:39:53 <lambdabot>     Occurs check: cannot construct the infinite type:
14:39:53 <lambdabot>       a = a -> a -> a -> a -> a -> a -> a1
14:40:00 <augustss> feeble ;)
14:40:25 <Heffalump> it's not immediately obvious to me why the sequence of joins has an infinite type
14:40:48 <augustss> It's 'join id', which is 'x x'
14:40:58 <monochrom> \x -> x x  already has an infinite type.
14:41:03 <xerox> join (join id) = join (\x -> x x)
14:41:16 <monochrom> It seems one can use induction for more.
14:41:37 <Heffalump> ok, I can sort of see why join id is x x now you tell me.
14:41:56 <ptolomy> hehe. My attempt at phantom types in my C++ project is failing.
14:42:40 <Heffalump> how are you trying to do it?
14:42:47 <Heffalump> just ignore template parameters?
14:44:31 <Saul_> @src sequence
14:44:31 <lambdabot> sequence ms = foldr k (return []) ms
14:44:31 <lambdabot>     where
14:44:31 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
14:44:35 <ptolomy> Heffalump: I'm just trying to keep integer ids be associated with their object type.. so I made 'Id<ObjType>', which is just a class with an int member and operator int() and an explicit constructor.
14:44:40 <Cale> sequence [] = return []
14:44:54 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
14:45:14 <Mr_Awesome> i dont understand how flip id can work. the type for the first argument to flip is a -> b -> c, but the type of id is just a -> a. how does that work?
14:45:16 <Heffalump> anyway, it seems like rewriting type incorrect things to other type incorrect things is perfectly valid
14:45:20 <Cale> Or, if you know about liftM2,  sequence = foldr (liftM2 (:)) (return [])
14:45:29 <FMota> hmm
14:45:32 * FMota wonders.
14:45:33 <Heffalump> Mr_Awesome: remember that the letters are type variables that can take on any instantiation
14:45:40 <FMota> How does pattern matching work in Haskell?
14:45:42 <Heffalump> and the a in the type of flip is different from the a in the type of id
14:45:46 <FMota> (or in general)
14:45:47 <Heffalump> so think of id as d -> d
14:46:14 <Heffalump> now, a -> b -> c = a -> (b -> c)
14:46:28 <Heffalump> so, matching the two up, d = a, and d = b -> c
14:46:44 <Heffalump> so since flip :: (a -> b -> c) -> (b -> a -> c)
14:46:46 <Mr_Awesome> Heffalump: how can d be two different things?
14:46:56 <Heffalump> it can't, so those two things must be the same.
14:47:03 <FMota> probably a very big question to be asking :o :p
14:47:03 <Heffalump> so we know a = b -> c
14:47:09 <Mr_Awesome> ah, ok
14:47:22 <Cale> FMota: There are a number of things you could mean by "work"
14:47:36 <FMota> Hmm. Such as?
14:47:39 <Mr_Awesome> FMota: magic ;)
14:47:43 <FMota> XD
14:47:44 <Cale> FMota: How is it implemented? What are its mathematical semantics?
14:48:02 <Cale> Or just how do you use it in programming?
14:48:24 <FMota> Well, I'd like to know how to implement it, but perhaps some mathematical background is required to understand it?
14:48:39 <Mr_Awesome> Heffalump: so then the type of flip id would be b -> (b -> c) -> c
14:49:12 <Mr_Awesome> which takes two args and applies the second to the first... it all makes sense now :)
14:49:24 <Heffalump> right.
14:49:59 <Heffalump> @unpl flip id
14:49:59 <lambdabot> (\ b c -> c b)
14:50:42 <Cale> FMota: Basically, when you have a data type, say,  data Maybe a = Nothing | Just a, at runtime that corresponds to something which has a machine integer tag that is set to 0 or 1 depending on which of the two constructors it is, and, in the case that it's 1, an additional pointer to a value of type a
14:51:08 <FMota> makes sense
14:51:26 <FMota> so, basically it's tree like
14:51:29 <Cale> When you do a pattern match, it just checks which integer tag you have.
14:51:30 <Cale> yeah
14:51:38 <Mr_Awesome> Heffalump: would it be possible to say that a->b = d and c = d ?
14:51:40 <FMota> that's cool.
14:51:43 <Cale> Or, depending, graph-like
14:51:53 <FMota> ah, yes, that's right
14:52:04 <Heffalump> Mr_Awesome: in what context?
14:52:08 <Cale> You can have circular structures created by definitions like  ones = 1 : ones
14:52:13 <Heffalump> not with flip, cos you have to bracket a->b->c like I did
14:52:20 <Heffalump> -> is just defined to associate to the right
14:52:24 <FMota> yep :)
14:52:29 <FMota> thanks for explaining.
14:52:29 <Heffalump> it's not the same thing as (a->b)->c
14:52:59 <Mr_Awesome> ah, right. of course
14:53:02 <segher> is there some simple way to output some debugging text?
14:53:08 <Mr_Awesome> thanks a lot for explaining :)
14:53:10 <Heffalump> import Debug.Trace
14:53:16 <Heffalump> then use trace :: String -> a -> a
14:53:23 <segher> ooh that sounds promising
14:53:29 <Heffalump> trace "foo" x prints out "foo" then returns the value of x
14:53:34 <Heffalump> all very impure, but good for debugging
14:53:44 <segher> yeah exactly what i need :-)
14:53:50 <Heffalump> and beware of laziness leading to unexpected orders of things coming out
14:54:10 <Mr_Awesome> thats what my boss always says
14:54:22 <Igloo> Or things only coming out once when you expect them to happen multiple times
14:54:45 <segher> oh, i need to figure out where this error happens
14:54:46 <Heffalump> if you show stuff in the string, you sometimes get the strings interleaved too
14:56:18 <xerox> And also have them coming out when you DIDN't expect them.
14:58:20 <monochrom> Control.Exception.assert tells you line numbers.
14:59:08 <segher> what do i do with that?
14:59:17 <xerox> There's also http://www.cse.unsw.edu.au/~dons/loch.html
14:59:18 <lambdabot> Title: LocH
15:05:36 <segher> is there some way to get a backtrace or similar on an exception?
15:07:03 <segher> it's telling me   *** Exception: Prelude.(!!): index too large   and i have no idea where it is coming from
15:08:21 <kpreid> segher: just stop using !! :-)
15:08:29 <segher> hahaha
15:08:48 <segher> well, it isn't in my code even -- i use it twice, and neither is the cause
15:09:39 <segher> (!!) n = head (drop n)   -- any better?
15:11:01 <xerox> segher: kinda worse, now you get an exception from head instead of (!!)
15:11:48 <segher> sure, i know :-)
15:12:26 <kpreid> no, it's not better...
15:12:29 <segher> i'll just go dig through the standard libs and the wiki to see if there is any neat debugging thingy i could use
15:12:39 <kpreid> better is listToMaybe . drop n
15:12:41 <sorear> .
15:12:42 <xerox> What about http://www.cse.unsw.edu.au/~dons/loch.html
15:12:42 <lambdabot> Title: LocH
15:12:56 <sorear> total fp ftw!
15:13:19 <xerox> Seems like it server exactly the purpose you're aiming for
15:13:26 <segher> xerox: that requires me to insert trace points all over the place.  no thanks.
15:13:37 <xerox> segher: nope.
15:13:39 <segher> i just want a bloody backtrace :-)
15:14:06 <sorear> Have you tried GHC's backtrace on exception option?
15:14:14 <xerox> segher: see "locating error mechanically" on that page.
15:14:20 <segher> that sounds good :-)
15:14:59 <sorear> segher: compile your program with -prof -auto-all -fforce-recomp, and run it with +RTS -xc
15:15:16 <segher> does that work with ghci too, perhaps?
15:15:31 <sorear> no. :(
15:15:50 <segher> okay, i'll add a   main   then :-)
15:15:57 <sorear> but with recent ghci you might be able to use :set -fbreak-on-exception
15:16:45 <segher> unrecognised flag
15:16:59 <segher> ghci 6.6.1
15:21:44 <segher> ooh, that indeed shows some backtrace.  unfortunately, i screwed up my "main" function.  next try :-)
15:22:50 <segher> hrm, no luck -- just says <GHC.List.CAF>
15:23:13 <segher> it does however manage to output all of the trace output, it seems
15:37:34 <segher> fixed :-)
15:39:39 <Mr_Awesome> > iterate (* 2) 1
15:39:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
15:40:03 <Mr_Awesome> ghci knew how to stop printing an infinite list...
15:40:22 <Mr_Awesome> *i wish ghci
15:40:36 <shachaf> Mr_Awesome: Just take n from the list.
15:40:39 <chadz> Cc + take 10 $ list
15:40:50 <kpreid> rather, take n from (show list)
15:40:52 <Mr_Awesome> i cant be expected to remember that all the time
15:40:52 <shachaf> Mr_Awesome: lambdabot also doesn't know how -- she just takes n from show list.
15:41:02 <chadz> i do it as well :)
15:41:11 <chadz> it's better to do in linux, where sigint works.
15:41:22 <chadz> then windows, where you have to go into task manager and kill ghc
15:41:25 <Mr_Awesome> it doesnt work in windows?
15:41:27 <Mr_Awesome> oh that sucks
15:41:42 <segher> it often doesn't work in linux either
15:41:48 <Mr_Awesome> good thing i use linux
15:41:51 <segher> but sigstop works always
15:41:56 <Mr_Awesome> ive never had it not work in linux
15:42:08 <segher> try to get it to swap a lot :-)
15:42:27 <segher> same problem on all unices, on all programs
15:43:16 <evir> ulimit
15:43:44 <segher> i _like_ my programs to be able to use more than the measly 1GB i have installed in this box
15:43:54 <segher> but yes, that's a good way to prevent runaway programs
15:45:02 <evir> Well ... but it's still a good way to free yourself some headfroom to kill processes. :-)
15:45:16 <evir> So you don't have to wait for the kernel VM to run amok killing your process.
15:46:14 <segher> that would take a while -- 64-bit, lots and lots of swap
15:47:22 <olsner> OOM killer: "IM IN UR KARNAL KILLING UR PROCS"
15:47:36 <sorear> @lap olsner
15:47:36 <lambdabot> Maybe you meant: map slap
15:47:39 <sorear> @slap olsner
15:47:39 * lambdabot smacks olsner about with a large trout
15:47:52 <evir> map slap ... :->
15:48:11 <evir> map slap [x | x <- #haskell]
15:49:30 <olsner> a little 4chan slipped into me there
15:55:04 <chadz> wouldn't that just be: map slap #haskell   ? :)
15:55:17 <evir> Yes, but it doesn't look as cool. :-P
15:56:31 <elliottt> has anyone read "Categories for Software Engineering"?
15:57:42 <bos> apparently not.
15:57:46 <elliottt> :)
15:59:18 <bos> it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
16:00:19 <monochrom> software engineers are ready for anything.
16:00:27 <Igloo> GC is a company full of software engineers, isn't it?  :-)
16:00:29 <mrd> just slap a fancy buzzword on it and ship
16:00:41 <augustss_> monochrom: like boy scouts
16:00:58 <monochrom> indeed, it's the packaging that makes or breaks popularity.
16:01:18 <mrd> eXtensible Mathematical Language -- oops, abbreviation already taken
16:01:52 <monochrom> "Software Component Theory:
16:01:57 <monochrom> s/:/"
16:02:13 <DRMacIver> monochrom: ITYM "Software engineers are ready to mangle anything"
16:02:42 <Mr_Awesome> @pl \x y -> (x `rem` y) /= 0
16:02:42 <lambdabot> flip flip 0 . ((/=) .) . rem
16:02:46 <monochrom> I don't mean it, but it's also true.
16:02:46 <DRMacIver> I dread to think what category theory would look like after the software engineering world had got their grubby paws on it.
16:03:04 <Mr_Awesome> wow... maybe point-free isnt the best for that function
16:03:20 * mrd wonders if there is "Category Theory for Dummies" .. or would it be "Categories for Dummies"?
16:03:29 <DRMacIver> Enterprisevariant functors. Commutative UML diagrams.
16:03:55 <Apocalisp> bwahaha
16:04:01 <oerjan> @pl \x y -> p (x `rem` y)
16:04:02 <lambdabot> (p .) . rem
16:04:27 <augustss_> I like the flip flip
16:04:40 <mrd> I'm surprised "functor" isn't bandied around more.  It sounds space-age... "fire the functor phasers!"
16:04:40 <oerjan> Mr_Awesome: that flip flip 0 is excessive
16:04:42 <Apocalisp> @remember DRMacIver I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
16:04:42 <lambdabot> Done.
16:04:52 <oerjan> ((/= 0).).rem is enough
16:04:54 <augustss_> @type flip flip
16:04:56 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
16:05:11 <sorear> @remember bos it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
16:05:12 <lambdabot> Done.
16:05:14 <augustss_> @. djinn type flip flip
16:05:16 <lambdabot> f a b c = b c a
16:05:38 <Mr_Awesome> oerjan: do you think thats actually clearer though?
16:05:41 <elliottt> yes, i'll admit that the title is a bit of a silly one
16:05:54 <Mr_Awesome> than \x y -> (x `rem` y) /= 0
16:05:57 <elliottt> however, reading through the preview makes it seem potentially worthwhile.  we'll see.
16:06:11 <monochrom> Juergen Dingel has a UML semantics in terms of category theory.
16:06:42 <elliottt> that's kinda weird
16:06:45 <elliottt> :)
16:07:05 <DRMacIver> I seem to recall having suggested enterprise ajax monads as a joke buzzword haskell term a while ago. :)
16:07:30 <elliottt> you know, i saw a javascript monad for dom traversal a while back
16:07:32 <thoughtpolice> monadic ajax combinators ftw?
16:07:50 <DRMacIver> monadic ajax combinators actually sound like a good idea. :_/
16:07:53 <DRMacIver> :-/ even
16:07:55 <augustss> Haskell already has enterprise monads; there is a fail method.
16:08:00 <DRMacIver> Ha ha
16:08:09 <mrd> functional reactive ajax exists
16:08:21 <oerjan> Mr_Awesome: nah, point-free expressions threading more than one argument are less likely to be clearer
16:08:38 <monochrom> @remember augustss Haskell already has enterprise monads; there is a fail method.
16:08:39 <lambdabot> Done.
16:08:47 <elliottt> flapjax?
16:08:47 <xerox> ?check \f x y -> flip (f :: Int -> Int -> Int) x y == flip (flip flip) f x y
16:08:48 <lambdabot>  OK, passed 500 tests.
16:08:50 * monochrom is slowly developing into a fan of augustss
16:08:51 <elliottt> http://www.flapjax-lang.org/
16:08:54 <lambdabot> Title: Flapjax
16:11:46 <Cale> data Bool = False | True | FileNotFound
16:12:07 <elliottt> hehe
16:12:43 <gomiboy> @run echo "yay for Î»bot"
16:12:43 <lambdabot>   Not in scope: `echo'
16:12:49 <gomiboy> @run print "yay for Î»bot"
16:12:51 <lambdabot>  <IO ()>
16:12:53 <gomiboy> Oh.
16:13:02 <Vulpyne> NOIOFORYOU!
16:13:09 <Cale> @run "yay for Î»bot"
16:13:10 <lambdabot>  "yay for \955bot"
16:14:18 <mrd> what encoding is that?
16:16:24 <Cale> UTF8 initially
16:16:41 <Cale> \955 is just the escaped unicode character
16:19:32 <gomiboy> > "what"
16:19:34 <lambdabot>  "what"
16:19:40 <gomiboy> @help
16:19:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:20:46 <Cale> > fix ((0:) . scanl (+) 1)
16:20:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:20:50 <sorear> @msg gomiboy muahaha!
16:21:02 <sorear> > nubBy(((>1).).gcd)[2..]
16:21:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:21:35 <Cale> > scanl (*) 1 [1..]
16:21:36 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
16:22:07 <ddarius> ARe we having fun here today?
16:22:23 <sorear> > iterate (read . filter isDigit . show . length &&& head . group . show) 1
16:22:24 <lambdabot>  Couldn't match expected type `[a]'
16:22:33 <sorear> > iterate (read . filter isDigit . show . (length &&& head) . group . show) 1
16:22:34 <lambdabot>  [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,1111111111...
16:22:48 <sorear> > (show . (length &&& head) . group . show) 1
16:22:49 <lambdabot>  "(1,\"1\")"
16:22:59 <sorear> > iterate (read . filter isDigit . show . map (length &&& head) . group . show) 1
16:23:00 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
16:23:13 <chadz> i like that sequence :)
16:23:40 <chadz> > 22/7
16:23:41 <lambdabot>  3.142857142857143
16:24:14 <Cale> > 22/7 - pi
16:24:15 <lambdabot>  1.2644892673496777e-3
16:24:20 <chadz> hehe
16:24:32 <chadz> not so bad.
16:24:48 <data> sorear: what's that sequence called? I've seen it before
16:25:05 <Cale> > 355/113 - pi
16:25:06 <lambdabot>  2.667641894049666e-7
16:25:16 <xerox> Ah that was the one :)
16:25:17 <chadz> look-say, can't remember the other names off the top of my head
16:25:30 <Cale> > 103993/33102 - pi
16:25:31 <lambdabot>  -5.778906242426274e-10
16:25:32 <sorear> @djinn Not (Either a b) -> (Not a, Not b)
16:25:32 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
16:25:44 <xerox> !
16:25:47 <Cale> > 104348/33215 - pi
16:25:48 <lambdabot>  3.3162805834763276e-10
16:25:54 <sorear> @djinn (Not a, Not b) -> Not (Either a b)
16:25:55 <lambdabot> f (a, b) c =
16:25:55 <lambdabot>     case c of
16:25:55 <lambdabot>     Left d -> a d
16:25:55 <lambdabot>     Right e -> b e
16:26:03 <Cale> > 208341/66317 - pi
16:26:04 <lambdabot>  -1.2235634727630895e-10
16:26:10 * xerox pokes Cale
16:26:14 <Cale> hehe
16:26:26 <sorear> xerox: it's just one of de Morgan's laws :)
16:26:27 <ddarius> Note how one way needs exponentials (hofs) and the other way does not.
16:26:49 <xerox> sorear: I was trying to remember the '113355 and divide' and Cale kept getting better precisions hehe
16:27:18 <Cale> I just asked mathematica for a list of convergents :)
16:27:26 <mrd> is that a sequence created by conway by any chance
16:27:53 <sorear> mrd: No, it's the sequence of continued fraction approximants of pi.
16:28:02 <mrd> 1,11,21,1211,111221,312211,13112221,1113213211,31131211131221
16:28:04 <mrd> i was right
16:28:15 <mrd> something to do with the "cosmological theorem"
16:28:33 <sorear> Have we scared away gomiboy yet?
16:28:40 <Cale> 355/113 is a particularly good approximation to pi, given that it comes from using the terms of the continued fraction expansion just before a rather large term (292)
16:28:51 <FMota> I haven't celebrated nearly enough about this, so: Yay for Iowa court ruling!  :) That's all on that subject. Now back to your regular programming.
16:29:09 <augustss> > 355/113
16:29:11 <lambdabot>  3.1415929203539825
16:29:17 <mrd> i saw a talk on Conway's cosmological theorem involving Haskell about 10 months ago and I still remembered =)
16:29:47 <xerox> mrd: what was that?
16:29:50 <augustss> So by remembering 6 digits (355,113) I can get 6 decimals of pi.  Amazing.  Not.
16:30:16 <ddarius> Incisive augustss.
16:30:34 <xerox> > 208341/66317
16:30:36 <lambdabot>  3.1415926534674368
16:30:51 <ddarius> > pi
16:30:53 <lambdabot>  3.141592653589793
16:30:54 <xerox> nine
16:31:07 <mrd> xerox: http://www.research.att.com/~njas/sequences/A005150
16:31:08 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
16:31:18 <xerox> mrd: I mean the talk.
16:31:46 <mrd> it was some kind of proof of the "lost" cosmological theorem based on a haskell program
16:32:00 <Cale> augustss: seven, actually
16:32:03 <FMota> augustss: it's amazing if you consider that the equivalent fraction for those digits is 12 digits long (314159,100000)
16:32:25 <FMota> and its a much better approximation.
16:32:57 <oerjan> > iterate (concatMap (uncurry (++) . (show . length &&& take 1)) . group . show) 1
16:32:58 <lambdabot>   add an instance declaration for (Num [Char])
16:33:14 <oerjan> > iterate (read . concatMap (uncurry (++) . (show . length &&& take 1)) . group . show) 1
16:33:15 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
16:34:08 <augustss> Cale: I count 6 decimals, I'm not counting the inital 3.  It doesn't have to be remembered (because it's in the bible :)).
16:34:09 <mrd> xerox: http://www.cs.cmu.edu/afs/.cs.cmu.edu/Web/Groups/pop/seminar/061208.html
16:34:11 <lambdabot> Title: POP Seminar, 02-07-03, http://tinyurl.com/3yfsgf
16:36:05 <Cale> > map floor . iterate (\x -> 1/(x - (fromIntegral (floor x)))) $ pi
16:36:07 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,3,3,23,1,1,7,4,35,1,1,1,2,3,3,3,3,1,1,14,6,4,...
16:36:21 <xerox> mrd: is there a video recording of that?
16:36:56 <Cale> [3,7,15,1,292,1,1,1,2,1,3,1,14] is right, the rest is just rounding error
16:37:00 <augustss> > approxRational pi 1e-6
16:37:01 <lambdabot>  355%113
16:37:07 <chadz> [ (x,y) | x <- [20..1000], y <- [6..300], let z = (x/y-pi) in (z > 0.0) && (z < 0.001)]
16:37:10 <mrd> hm. possibly.
16:37:10 <xerox> > map floor . iterate (\x -> 1/(x - fromIntegral (floor x)))) $ (sqrt 2)
16:37:10 <lambdabot>  Unbalanced parenthesis
16:37:10 <chadz> err
16:37:12 <chadz> > [ (x,y) | x <- [20..1000], y <- [6..300], let z = (x/y-pi) in (z > 0.0) && (z < 0.001)]
16:37:14 <lambdabot>  [(355.0,113.0),(377.0,120.0),(399.0,127.0),(421.0,134.0),(443.0,141.0),(465....
16:37:18 <chadz> heheh
16:37:21 <chadz> brute force it :)
16:37:23 <augustss> > approxRational pi 1e-10
16:37:24 <lambdabot>  312689%99532
16:37:43 <xerox> > map floor . iterate (\x -> 1/(x - fromIntegral (floor x))) $ (sqrt 2)
16:37:45 <lambdabot>  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,3,3,1,3,1,1,2,1809,1,2,5,2,...
16:38:11 <xerox> > map floor . iterate (\x -> 1/(x - fromIntegral (floor x))) $ (exp 1)
16:38:15 <lambdabot>  [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,11,3,2,1,3,1,73,6,1,1,1,1,1,2,31,...
16:38:21 <xerox> funny :)
16:38:31 * byorgey <3 e
16:40:07 <Cale> > foldr1 (\x y -> x + 1/y) [3, 7, 15, 1, 292, 1, 1, 1] :: Rational
16:40:09 <lambdabot>  312689%99532
16:40:38 <Cale> > foldr1 (\x y -> x + 1/y) [3, 7, 15, 1] :: Rational
16:40:40 <lambdabot>  355%113
16:40:47 <Cale> > foldr1 (\x y -> x + 1/y) [3, 7, 15, 1, 292] :: Rational
16:40:48 <lambdabot>  103993%33102
16:41:01 <augustss> > approxRational pi 1e-8
16:41:03 <lambdabot>  100798%32085
16:41:11 <gomiboy> > let one = 1
16:41:11 <lambdabot>  Parse error
16:41:16 <gomiboy> ((
16:41:21 <augustss> > approxRational pi 1e-9
16:41:22 <lambdabot>  103993%33102
16:41:26 <oerjan> @let one = 1
16:41:27 <augustss> there!
16:41:30 <Cale> > one
16:41:31 <lambdabot> Defined.
16:41:32 <lambdabot>  1
16:42:11 <gomiboy> > let zOMGONE = 1 in zOMGONE + 1
16:42:13 <lambdabot>  2
16:42:38 <gomiboy> @let pf p q d = if abs((p/q)-pi) < d then (p, q) else if (p / q) > pi then (pf p (q+1) d) else (pf (p+1) q d)
16:42:41 <lambdabot> Defined.
16:42:47 <gomiboy> > pf 1 1 0.00000001
16:42:49 <lambdabot>  (100798.0,32085.0)
16:43:05 <jbauman> > let (==) = 1 in (==)
16:43:07 <lambdabot>  1
16:43:42 <gomiboy> > 100798.0/32085.0
16:43:43 <lambdabot>  3.1415926445379463
16:44:23 <Cale> > let (!) = product . enumFromTo 1 in (9!)
16:44:24 <lambdabot>  362880
16:45:18 <augustss> > let 1 + ((+) + 1) = (+) in 1+1
16:45:18 <lambdabot>  Parse error in pattern
16:45:40 <augustss> Dang, I keep forgetting about the bad parser in lambdabot
16:46:23 <Igloo> How does lambdabot manage to hvae a bad parser there? Isn't it just passing it off to GHC?
16:46:30 <oerjan> are you _sure_ that's legal?
16:46:37 <sjanssen> Igloo: it parses the expression with Language.Haskell first
16:46:39 <augustss> oerjan: it's legal
16:46:43 <Igloo> Oh...why?
16:46:51 <sjanssen> Language.Haskell doesn't support n+k patterns
16:47:08 <sjanssen> Igloo: to prevent various injection attacks
16:47:28 <oerjan> O_o
16:47:29 <Igloo> Ah, fair enough
16:47:31 <ddarius> > let f (+) = 3+4 in f (*) -- I've never even considered this before
16:47:33 <lambdabot>  12
16:47:59 <LoganCapaldo> woah
16:48:01 <LoganCapaldo> woah
16:48:13 * EvilRanter fairly frequently has an infix operator as a parameter
16:48:27 <LoganCapaldo> the mind boggles
16:48:36 <oerjan> > let f 1 f = f-1 in f 1 1
16:48:37 <ddarius> EvilRanter: I've never done it.  As I said, I've never even thought about it.
16:48:38 <lambdabot>  0
16:48:46 <oerjan> wow
16:48:57 <EvilRanter> foldr (??) e (x:xs) = x ?? foldr (??) e xs
16:49:00 <ddarius> oerjan: I haven't considered that one either.
16:49:16 <oerjan> ddarius: it was my desugaring of the + version
16:49:33 <ddarius> Apparently, we need to start generating expressions from the Haskell grammar.
16:49:50 <EvilRanter> zipWith (??) (x:xs) (y:ys) = (x ?? y):zipWith (??) xs ys
16:49:50 <EvilRanter> etc
16:50:04 <LoganCapaldo> EvilRanter, that's cute
16:51:03 <ddarius> > let f (,) = zipWith (,) in f (+) [1] [2] -- this better not parse
16:51:04 <lambdabot>      Constructor `(,)' should have 2 arguments, but has been given 0
16:51:04 <lambdabot>     In t...
16:51:30 <EvilRanter> =] ... on paper, it's more fun to write it as, say, a star, or a crossle, or whatever, but sticking to ascii's probably a good idea in practice
16:51:36 <oerjan> nah, (,) is not an identifier
16:51:40 <ddarius> > f ((,) x y) = x in f (1,2) -- presumably this does
16:51:41 <lambdabot>  Parse error
16:51:50 <EvilRanter> imo
16:52:10 <augustss> > let f ((,) x y) = x in f (1,2)
16:52:12 <lambdabot>  1
16:52:12 <EvilRanter> broken parser! foo! blargh!
16:52:24 <EvilRanter> oh, right. good point.
16:55:14 <ddarius> :t let 1 + ((+) + 1) = (+) in 1+1
16:55:16 <lambdabot> forall t. (Integral t) => t
16:55:40 <EvilRanter> |\(O_o)/|
16:56:10 <ddarius> EvilRanter: If you realize (+) is a formal argument, as you should, it's clear what that's doing.
16:56:40 <EvilRanter> i get it, it's still a bit disturbing, though
16:56:51 <ddarius> EvilRanter: That's why n+k patterns are evil.
16:56:52 <augustss> yes, I agree :)
16:56:54 <oerjan> the thing that confused me is that the arguments of the function definition can shadow the function name
16:56:54 <ddarius> Well, part of why.
16:57:14 <EvilRanter> and i'd've thought writing something to the effect of let f f = ... in ... wouldn't be allowed owing to ambiguity
16:57:40 <ddarius> EvilRanter: What ambiguity?  To me, it is very clear that the parameter should shadow the function definition.
16:57:41 <oerjan> > let f f f = f in f 12
16:57:42 <lambdabot>      Conflicting definitions for `f'
16:57:42 <lambdabot>     In the definition of `f'
16:57:52 <Cale> > let f f = f in f 1
16:57:53 <lambdabot>  1
16:57:57 <oerjan> ok, not that liberal
16:58:06 <LoganCapaldo> you guys are confusing me
16:58:09 <ddarius> > \x x -> x
16:58:10 <lambdabot>      Conflicting definitions for `x'
16:58:10 <lambdabot>     In a lambda abstraction
16:58:15 <augustss> > let f f = \ f -> f in f 1 2
16:58:16 <lambdabot>  2
16:58:23 <Cale> > let 0 + 0 = 1 in 0 + 0
16:58:23 <LoganCapaldo> the obfuscated haskell contest would collapse under its own weight
16:58:24 <lambdabot>  1
16:58:38 <Cale> > let 0 = 1 in 0
16:58:38 <ddarius> LoganCapaldo: There have been three.
16:58:39 <lambdabot>  0
16:58:53 <gomiboy> Uhm, is there an rc dotfile for GHCi?
16:59:06 <Cale> .ghci
16:59:23 <Cale> Mine contains:
16:59:25 <Cale> :set -fno-print-bind-result
16:59:25 <Cale> :set -fglasgow-exts -farrows
17:00:05 <gomiboy> Oh, thanks
17:00:06 <oerjan> no-print-bind-result? is that to save memory?
17:00:37 <Cale> oerjan: It's to save irritation
17:00:43 <gomiboy> I was going to put there a :pasteCode command from http://www.haskell.org/haskellwiki/GHC/GHCi
17:00:50 <oerjan> Cale: ?
17:00:56 <Cale> If I wanted the result of my IO actions printed, I'd add >>= print
17:01:13 <Cale> Usually I just want to see the side effects.
17:01:17 <oerjan> oh, i misunderstood
17:01:28 <oerjan> i thought that removed the "it" notation
17:03:47 <phobes> > let 0 + 0 = 1 in 0 + 0 -- This is redefining +, right?
17:03:48 <lambdabot>  1
17:03:55 <oerjan> yep
17:04:12 <oerjan> > let 0 + 0 = 1 in 2 + 2
17:04:13 <lambdabot>   Non-exhaustive patterns in function +
17:05:12 <mrd> shadowing
17:06:45 <LoganCapaldo> word
17:06:52 <LoganCapaldo> important distinction there
17:06:56 <LoganCapaldo> shadowing and redefining
17:07:41 <phobes> so why is "let 0 = ... " even legal if it doesn't do anything?
17:07:55 <oerjan> just consistency
17:08:07 <ddarius> phobes: Why not have it be legal?
17:08:11 <Apocalisp> What does (+)(+) do?
17:08:22 <oerjan> it would require a special case to make it illegal
17:08:25 <ddarius> Apocalisp: It depends on the context.
17:08:27 <phobes> ddarius: Because it's not consistent
17:08:34 <Apocalisp> @type (+)(+)
17:08:36 <lambdabot> forall a. (Num a, Num (a -> a -> a)) => (a -> a -> a) -> a -> a -> a
17:08:44 <Apocalisp> I don't know why that works.
17:08:55 <augustss> phobes: but it is consistent
17:08:59 <Apocalisp> @type (+)
17:09:00 <ddarius> You can make a -> a -> a an instance of Num.
17:09:01 <lambdabot> forall a. (Num a) => a -> a -> a
17:09:17 <ddarius> phobes: How is it inconsistent?
17:09:20 <phobes> augustss: ok then I need more information :)
17:09:21 <LoganCapaldo> > let 0 = 1 in 0 + 0 -- doesn't it do something?
17:09:23 <lambdabot>  0
17:09:25 <LoganCapaldo> oh
17:09:28 <LoganCapaldo> I guess not
17:09:36 <phobes> Ya, it does the wrong thing :)
17:09:43 <oerjan> phobes: the 0 is in a pattern position.  although it is useless here (because the pattern is irrefutable), 0 patterns have other uses in case e.g.
17:09:45 <Apocalisp> is (+) an instance of Num?
17:09:50 <LoganCapaldo> it's that whole number pattern matching is actually a guard in disguise thing isn't it?
17:09:54 <augustss> phobes: 0 is a pattern.  patterns are allowed on LHS of a let binding
17:09:59 <ddarius> Apocalisp: Types are instances of Num, not values.
17:10:10 <Apocalisp> oh, duh
17:10:23 <phobes> augustss: ok I see
17:10:31 <oerjan> > let !0 = 1 in 0
17:10:34 <lambdabot>  Parse error
17:10:43 <ddarius> It doesn't have -fbang-patterns
17:10:45 <oerjan> (needs extension :()
17:10:47 <LoganCapaldo> strictly evaluate zero? Heh
17:10:50 <augustss> phobes: patterns with no variables (in let) are pointless, but not inconsistent
17:11:23 <phobes> augustss:  ya I agree
17:11:39 <phobes> Any reason to have it not error if it's pointless?
17:11:49 <LoganCapaldo> it could throw a warning I suppose...
17:11:52 <ddarius> LoganCapaldo: You can't shadow constructors, it's not binding anything.
17:12:04 <LoganCapaldo> ddarius, aha
17:12:10 <LoganCapaldo> no shadowing constructors
17:12:12 <LoganCapaldo> doh
17:13:03 <augustss> phobes: A warning would be great.  Forbidding it would just complicate the language
17:13:16 <LoganCapaldo> (can you shadow constructors with the right combo of import statements?)
17:13:36 <phobes> augustss: ok no argument
17:13:43 <phobes> thanks for the explanation all :)
17:14:13 <ddarius> LoganCapaldo: No.  Really it doesn't even make sense to speak of "shadowing" constructors because you can't declare them within a scope.  If you could, then presumably you could shadow them.
17:14:20 <oerjan> Apocalisp: you could define an instance so that (+) could be in a Num type, the type shown for (+)(+) includes that instance as a prerequisite
17:14:25 <LoganCapaldo> ( e.g.: import HomeMadeMaybe (has a data M a = Just a | Nada declaration inside), will that shadow Prelude.Just or will it just complain about ambiguity)
17:14:28 <TuringTest> phobes: In monads (do 0 <- 1 >> return True) fails in strict monads but not in lazy ones.
17:14:35 <Apocalisp> That's just weird.
17:14:37 <newsham> > (unwords.(\[x:xs, y:ys] -> [y:xs, x:ys]).words) "Curry Howard"
17:14:39 <oerjan> but it does not usually exist :)
17:14:41 <ddarius> So the accurate and important point of what I originally said is that nothing is being bound in that expression at all.
17:14:42 <lambdabot>  "Hurry Coward"
17:15:08 <augustss> > let (+)(+)=(+) in (+5)
17:15:10 <ddarius> LoganCapaldo: It will complain when you use them.
17:15:11 <lambdabot>  Add a type signature
17:16:33 <oerjan> > let (+)(+)=(+) in (5+)
17:16:35 <lambdabot>  5
17:16:44 <TuringTest> > let 1+1=3 in 1+1
17:16:46 <lambdabot>  3
17:16:46 <augustss> thanks :)
17:17:03 <ddarius> > let (+)(+) = (+) in (+5) :: Num a => (a -> b) -> b
17:17:04 <lambdabot>  Add a type signature
17:17:12 <nasa_> Are there any embedded dialects of Haskell? I haven't been able to find one.
17:17:26 <oerjan> > let (+)(+)=(+) in succ+5
17:17:27 <lambdabot>  6
17:17:29 <ddarius> What meaning of embedded are you using?
17:18:05 <nasa_> As in for embedded systems. Specifically, I am sick of using C and didn't want to get stuck with PyMite.
17:18:51 <ddarius> nasa_: I think the level you want has just been missed by practical systems (currently), though there is some research.
17:19:00 <augustss> > let (+)(+)=(+) in (1-)+2
17:19:01 <lambdabot>  -1
17:19:24 <ddarius> > (+5)
17:19:25 <lambdabot>  <Integer -> Integer>
17:20:03 <ddarius> > let (+)(+) = (+) in (+(5 :: Int))
17:20:04 <lambdabot>  Add a type signature
17:20:37 <augustss> > let (+)(+)(-)=(-)(+) in 1+sin
17:20:38 <lambdabot>  0.8414709848078965
17:21:05 <sjanssen> > let x x = x in x (1-) 2
17:21:06 <lambdabot>  -1
17:21:35 <mrd> hm, no "multiply-bound variable in pattern" error?
17:21:45 <ddarius> mrd: Why should it?
17:21:48 <augustss> > let (+)(+)(-)=(-)(+)(+) in 10+logBase
17:21:49 <lambdabot>  1.0
17:21:55 <ddarius> x x = x <=> x =
17:21:59 <augustss> A nice symmetrical definition
17:22:00 <ddarius> x x = x <=> x = \x -> x
17:23:14 <nasa_> Ok, I'll check back in a few years ;-)
17:24:04 <nasa_> Hmm, never tried this lambabot before...
17:24:10 <nasa_> > (+ 2 3)
17:24:11 <lambdabot>   add an instance declaration for (Num (t -> a))
17:24:19 <mrd> not scheme ;)
17:24:21 <augustss> nasa_: nhc can produce binaries with a small footprint, but they are not fast
17:24:22 <nasa_> yeah
17:24:33 <nasa_> oh, I will check it out.
17:24:40 <nasa_> switching to Haskell...
17:24:45 <nasa_> > (+) 2 3
17:24:46 <lambdabot>  5
17:24:47 <mrd> i occasionally write (+ a b) in haskell still
17:25:04 <augustss> Old Lispers never die...
17:25:10 <mrd> particularly when i'm switching between CL and Haskell
17:25:18 <nasa_> I can imagine.
17:25:22 <mrd> augustss: it doesn't help (+ a) is valid =)
17:25:42 <oerjan> > let a = id; b = 1 in (+ a b) 1
17:25:43 <lambdabot>  2
17:25:54 <mrd> also, does that mean Lisp is the path to immortality?
17:26:05 <TSC> immorality, I'd say
17:26:19 <nasa_> so close, and yet so far :-)
17:26:20 <mrd> why be immortal if you can't be immoral
17:26:22 <augustss> mrd: it could mean Lispers die young
17:27:58 <augustss> Py3k, eh?  Should the next Haskell be Ha3k?
17:28:06 <augustss> Or Haskell XP?
17:28:20 <ddarius> Extreme Haskell!
17:28:28 <mrd> X-treme
17:28:37 <mrd> otherwise it's not extreme
17:28:37 <TSC> Haskell 2.0
17:28:52 <augustss> Haskell 99
17:29:03 <xerox> Haskell++  </ducks>
17:29:14 <mrd> ?type "Haskell"++
17:29:16 <lambdabot> parse error (possibly incorrect indentation)
17:29:25 <idnar> Hasxell
17:29:26 <Cale> MutVar#
17:29:43 <nasa_> Well, whatever it is called, feature #1 to implement is native Scheme support </ducks>
17:29:43 <mrd> we need to move onto the next logician.  Alonzo.
17:29:44 <Adamant> Wormhole Haskxtreme
17:29:48 <xerox> Cale: that's a nice one :)
17:29:58 <idnar> haha
17:30:02 <Cale> Adamant: haha, another Stargate fan :)
17:30:24 <Adamant> I'm just keeping Vancouverites in poutine
17:30:29 <mrd> also, people will stop saying "whaa? pascal?"
17:30:29 <ddarius> mrd: I was thinking that too.
17:30:35 <Adamant> althought that's not big there, I think
17:30:49 <nasa_> What about Russell?
17:30:55 <mrd> or even worse, not saying it, and just thinking it
17:31:06 <xerox> askHell
17:31:09 <ShockSMX> scheme is a lisp variant, right?
17:31:10 <ddarius> But Haskell's view is very much more consistent with Haskell than Alonzo's.
17:31:12 <Adamant> ya
17:31:14 <nasa_> Yeah.
17:31:15 <ShockSMX> heh
17:31:25 <ddarius> NotPascal!
17:31:29 <mrd> Curry-style vs Church-style?
17:31:46 <ddarius> mrd: The philosophical view behind them.
17:31:51 <xerox> Let's just call it "join us", or "click here".
17:32:02 <augustss> nasa_: Russell is taken
17:32:10 <nasa_> oh, ok.
17:32:13 <ddarius> H is still available I think.
17:32:24 <xerox> ?go H
17:32:28 <lambdabot> http://www.hm.com/
17:32:28 <lambdabot> Title: H&M
17:32:32 <augustss> haha
17:32:33 <Cale> I wonder how long until there's a language named after Saharon Shelah
17:32:49 <Adamant> Bondage&Discipline&Cuddling&MonadTutorials
17:33:03 * Adamant ducks
17:33:05 <mrd> bite the bullet and call it "Monad"
17:33:18 <Adamant> MS has rights to that
17:33:21 <Cale> http://shelah.logic.at/listb.html
17:33:24 <lambdabot> Title: Hyperlinked List of Shelah's papers
17:33:27 <Adamant> but they're MS Research
17:33:30 <pjd> mrd: but what about Functors and Arrows and Comonads and ...
17:33:41 <nasa_> Whitehead doesn't have the same ring to it...
17:33:49 <mrd> nasa_: Bertrand?
17:33:53 <ddarius> Cale: You need to be more specific...
17:34:00 <nasa_> That could work.
17:34:11 <mrd> kinda sounds like Fortrand
17:34:18 <Cale> Look how many papers that guy has published :)
17:34:29 <ddarius> Let's name it Erdos then.
17:34:51 <nasa_> ErSh:19
17:34:51 <nasa_>     Erdos+Shelah, Separability properties of almost-disjoint families of sets -- Israel J Math 12 (1972) 207-214
17:34:57 <xerox> Cale: do you want first-class forcing? (:
17:35:06 <Cale> xerox: hehe
17:35:07 <nasa_> That makes Erdos Shelah-1.
17:35:15 <Cale> xerox: that'd rock
17:35:22 <ddarius> Erdos Erdos-0
17:35:29 * xerox laughs - agreed.
17:35:42 <Cale> (http://en.wikipedia.org/wiki/Forcing_%28mathematics%29 -- for those who are unaware)
17:36:04 <idnar> H#
17:36:34 <ddarius> Hg would be wrong on so many levels.
17:36:41 <jbauman> H8
17:36:44 <Adamant> now introducing my new language, YHWH
17:36:51 <Adamant> top that
17:36:58 <ddarius> Adamant++
17:37:13 <Adamant> hmm. I could add vowels.
17:37:18 <jbauman> yahweh?
17:37:19 <mrd> hehe
17:37:32 <jbauman> that would be easier to pronounce
17:37:43 <ddarius> It's a language that abstracts from the need for vowels.
17:37:47 <mrd> now now, I don't want to be struck by a bolt of lightning for telling my friends about it
17:37:50 <ddarius> Along with JHVH
17:37:57 <Adamant> I like it when Larry Gonick says that God's real name may be Yahu-Wahu
17:38:16 <xerox> ddarius: mp vn [1..10] ==> [2,4,6,8,10]
17:38:38 <jbauman> the 6^4 names of god
17:38:39 <ddarius> I think you want fltr
17:38:41 <Adamant> mrd, historical religious incompatibility huh
17:38:50 <Adamant> ;)
17:39:16 <xerox> ddarius: fortunately the folds differ for a consonant :)
17:40:14 <ddarius> It wouldn't matter because clearly fldr is the God-given one.
17:40:38 <nasa_> <flame war ahead>
17:40:55 * xerox tries to imagine the class hierarchy, but then stops.
17:42:18 <Adamant> ThouShallHaveNoOtherFoldsBeforeMe::fold
17:42:34 <Adamant> ok, I need to stop.
17:43:35 <nasa_> does lambdabot use GHC? I wanted to try out the regexp library while my GHC is compiling.
17:43:55 <oerjan> it doesn't import all modules
17:43:59 <thoughtpolice> nasa_: yes.
17:44:04 <nasa_> ok.
17:44:09 <thoughtpolice> generally lambdabot is tied pretty tightly to the latest ghc release
17:44:20 <ddarius> > "." ~= "a" -- or however it works
17:44:21 <lambdabot>   Not in scope: `~='
17:44:31 <thoughtpolice> so you'll want 6.6.1 if you're compiling from the darcs repo (which is what you'll want to do)
17:44:38 <LoganCapaldo> I want lambdabot to import Parsec or a suitable substitute (ReadP or whatever)
17:44:50 <LoganCapaldo> @wishlist Parsec
17:44:51 <lambdabot> Unknown command, try @list
17:44:54 * thoughtpolice still cannot figure out why his lambdabot is so sick
17:44:55 <LoganCapaldo> ah well
17:45:03 <oerjan> @todo-add Parsec
17:45:03 <lambdabot> Entry added to the todo list
17:45:06 <thoughtpolice> just segfaults on initialization. :(
17:45:17 <LoganCapaldo> @botsnack
17:45:17 <lambdabot> :)
17:45:48 <augustss> @quote
17:45:48 <lambdabot> lennart says: Excel is very much alive.
17:45:53 <augustss> haha
17:46:12 <mrd> how old is that one
17:46:22 <Adamant> Night Of The Living Spreadsheet
17:46:24 <LoganCapaldo> it's timeless :)
17:46:58 <augustss> @quote
17:46:59 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
17:47:31 <jbauman> oh, the manual for yhwh
17:48:22 <LoganCapaldo> where do I get me one of those?
17:48:24 <thoughtpolice> hm. I guess I'll just try and build on my openbsd box instead.
17:48:29 <thoughtpolice> :( still though.
17:48:38 <thoughtpolice> i'll have to ask dons if he has any ideas when I can
17:51:37 * mrd happens to note that Haskell died 25 years ago tomorrow
17:53:09 <mrd> and 107 years since his birth in two weeks
17:53:29 <TuringTest> nasa_ : which regexp library?
18:00:21 <sjanssen> hmm, deriving Typeable doesn't have a LANGUAGE pragma?
18:09:03 <Igloo> sjanssen: DeriveDataTypeable in GHC 6.7
18:09:48 <sjanssen> Igloo: thanks
18:10:14 <sjanssen> Igloo: btw, ghc suggests -fglasgow-exts when you try to derive Typeable
18:10:43 <phobes> > let x:xs = [] in 1
18:10:45 <lambdabot>  1
18:10:52 <Igloo> sjanssen: Thanks
18:12:00 <augustss> Igloo: is 'make' supposed to work after a 'darcs-all pull'?
18:12:30 <augustss> I always get some problem if I don't do a distclean and rebuild everything
18:13:18 <Igloo> augustss: It depends what's changed, e.g. if libraries have changed then things that use those libraries might well break
18:13:51 <Igloo> As some things might have been cross-module-inlined, and we don't track dependencies at that level
18:14:21 <augustss> Igloo: OK, I'll just stick to cleaning everything then.  It's just so annoyingly slow
18:15:26 <Igloo> It probably won't help you, but FWIW it's faster on non-Windows than on Windows
18:15:42 <augustss> This is on my MacBook
18:15:48 <Igloo> Ah, OK
18:17:11 <Saizan> ah btw, can you make ghc compile libs/programs without using splitobjs?
18:18:04 <Igloo> Yes: Put "SplitObjs = NO" in mk/build.mk
18:18:49 <Saizan> ah i thought that was only to compile ghc itself
18:20:54 <Igloo> GHC won't do object splitting when compiling anything else unless you ask it to
18:23:26 <phobes> Is pattern matching secretly implemented by hidden "destructor" functions?
18:24:03 <pjd> i think pattern matching *is* the hidden destructor function
18:24:31 <Saizan> ah, so there's no way to make ld use less ram when linking?
18:25:33 <sorear> the destructor is id!
18:25:54 <Saizan> isn't it secretly implemented as church encoding?
18:26:18 <oerjan> i am sure all those implementations are _possible_.
18:26:56 <idnar> except maybe the one where ld uses less RAM
18:26:57 <idnar> ;)
18:27:07 <OceanSpray> hmm
18:27:13 <OceanSpray> HMM
18:27:41 <ShockSMX> i'm watching this, http://blip.tv/file/324976
18:27:42 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
18:27:47 <ShockSMX> and wow, the camera work is just awful
18:27:49 <Saizan> 120MB! it's 33% of my ram!
18:28:06 <nasa_> Yeah, no kidding.
18:28:18 <OceanSpray> I thought someone mentioned my name in this here channel
18:28:21 <OceanSpray> yesterday
18:28:27 <nasa_> Why don't they pan up? I want to see the slides!
18:28:27 <Saizan> ShockSMX: having the slides open helps
18:28:31 <OceanSpray> but the logs don't seem to show anything.
18:28:39 <idnar> where are the slides at?
18:28:43 <ShockSMX> Saizan: where
18:28:46 * ddarius looked through the slides before the video was available.
18:28:50 <nasa_> That would help :-)
18:29:09 <idnar> except I need two monitors
18:29:11 <kpreid> nasa_: they seem to consistently exclude slides. I suspect copyright silliness.
18:29:12 * ddarius is more entertained by watching SPJ bounce about.
18:29:24 <pjd> http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
18:29:26 <lambdabot> http://tinyurl.com/ysvquz
18:29:44 <idnar> oh, it's linked from the description
18:29:49 <phobes> I guess I was thinking something like this could be going on:
18:29:50 * idnar feels silly now
18:29:51 <phobes> data A a b = consA a b | ...
18:29:52 <phobes> consA :: a -> b -> (A a b)
18:29:52 <phobes> destA :: (A a b) -> (a -> b -> c) -> (a -> b -> c) -> c
18:29:53 <pjd> also, http://haskell.org/haskellwiki/Video_presentations
18:29:54 <lambdabot> Title: Video presentations - HaskellWiki
18:29:58 <oerjan> phobes: you might want to look at the paper on the spineless tagless g-machine (which ghc used last i checked)
18:30:16 <phobes> Then when you pattern match, it could decompose the pattern into applications of destA
18:30:23 <Saizan> ShockSMX: click "more" in the description (or follow pjd's link)
18:30:25 <nasa_> kpreid: reading the slides separately should work fine, but does get annoying.
18:30:29 <chessguy> 'evening ya'all
18:30:45 * pjd waves
18:30:55 <phobes> The two function parameters on destA are the cases for match / doesn't match (if it isn't obvious)
18:31:04 <ddarius> If I didn't already know Haskell, I may be annoyed by not being able to see the slides.
18:31:29 <sorear> whois nasa_
18:31:39 <kpreid> @type fromMaybe
18:31:41 <lambdabot> forall a. a -> Maybe a -> a
18:31:45 <kpreid> er
18:31:48 <kpreid> @type maybe
18:31:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:31:56 <ddarius> phobes: The doesn't match case wouldn't necessarily have the type (a -> b -> c)
18:32:03 <kpreid> phobes: that's such a function for Maybe, though not implemented built-in
18:32:39 <kpreid> that is, it's actually not uncommon to have such a function, it's just not usually obvious
18:32:42 <kpreid> @type foldr
18:32:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:33:01 <kpreid> ...and the value comes last
18:33:14 <oerjan> phobes: iiuc (although the paper may have been outdated) ghc stores a vector corresponding to each branch, and when an expression has been evaluated, it jumps back to the index of the vector corresponding to the constructor
18:33:37 <ddarius> :t \b t f -> if b then t else f
18:33:39 <lambdabot> forall t. Bool -> t -> t -> t
18:33:55 <oerjan> er, a vector with jumps corresponding to each branch
18:34:51 <phobes> oerjan: thanks ... ya I should probably just read that paper
18:35:05 <ddarius> GHC /= Haskell
18:35:49 <phobes> ddarius:  I'm still pondering your comment
18:36:25 <ddarius> phobes: Lookup Church encoding.
18:37:09 <phobes> ddarius:  I'm familiar with it ... but I'll try to use that as a hint :)
18:38:08 <oerjan> ddarius: well i don't know what any other implementations do
18:38:12 <phobes> ddarius: oh, nm
18:38:31 <phobes> destA :: (A a b) -> (a -> b -> c) -> c -> c -- this is what I meant!
18:38:50 <phobes> ddarius: would that work?  or not really?
18:38:58 <oerjan> and ghc is rather different from what was suggested, so it would at least be a counterexample
18:41:32 <phobes> ddarius:  nm, this is half-baked ;)  I'll work out the details. thanks for the help
18:41:49 <OceanSpray> huh?
18:46:12 <byorgey> anyone have any ideas on defining the infinite list of squarefree numbers?
18:46:24 <byorgey> ideally in an elegant, non-brute-force sort of way =)
18:47:45 <thoughtpolice> !!!
18:47:55 <thoughtpolice> my ghc api wrapper just made baby steps. :)
18:49:08 <chessguy> byorgey, squarefree?
18:49:09 <Nafai> thoughtpolice: What ia your wrapper for?
18:49:30 <byorgey> chessguy: not divisible by a perfect square
18:49:38 <thoughtpolice> Nafai: it's basically a wrapper around the ghc api for doing things analogous to hs-plugins.
18:49:49 <thoughtpolice> this is the first app it's been used with with though.
18:50:01 <byorgey> chessguy: in other words, having a factorization with at most one copy of each prime
18:50:08 <thoughtpolice> works by compiling your plugin into a dynamic and returning the function
18:50:27 <thoughtpolice> the main limitation thus far is that because there's a Typeable constraint for dynamics,
18:50:41 <thoughtpolice> it has to be of a monomorphic type, but you can wrap it in a data structure and derive Typeable to fix this (to an extent)
18:50:56 <chessguy> hmm
18:51:55 <chessguy> byorgey, i wonder if you could do a variant on the sieve of eratosthenes
18:52:37 <nasa_> hmm... every element of the list is either a prime or a product of unique primes. You could have a list of primes, then just add every product. Since Haskell is lazy, it shouldn't turn out too slow.
18:53:07 <byorgey> nasa_: that's what I've been trying, but I've been having trouble getting it to be lazy enough
18:53:08 <olsner> yeah, something like (map product) on the (lazy) powerset of the list of primes
18:53:28 <byorgey> olsner: aha, lazy powerset...
18:53:35 <hpaste>  thoughtpolice pasted "baby steps" at http://hpaste.org/2536
18:53:46 <thoughtpolice> Nafai: ^^ that should give you a basic idea
18:54:02 * Nafai looks
18:54:06 <byorgey> oh, hehe, did I mention I'd like to have them end up sorted?
18:54:19 <byorgey> I know, I'm so demanding =)
18:54:26 <nasa_> well, in that case...
18:54:28 <oerjan> byorgey: i think some variation on the hamming number trick should work
18:55:19 <hpaste>  byorgey pasted "generating squarefree numbers" at http://hpaste.org/2537
18:55:55 <byorgey> oerjan: right, the difference is that with the hamming numbers, you're merging a finite number of lists
18:56:15 <oerjan> well, foldl' is _never_ lazy enough
18:56:38 <byorgey> oerjan: yeah, I know
18:56:40 <thoughtpolice> Nafai: still working on it but the lib is pretty thin over the API. now it looks like I'm mainly looking to complete the interactive evaluation but...
18:57:05 <thoughtpolice> problem with GHC.runStmt is that it apparently pipes output to stdout so you can't give back the result of an expression, there might be a way to get around this but I don't know.
18:57:09 <phobes> ddarius:  FYI, I think that approach would work fine
18:57:19 <thoughtpolice> all runStmt gives you back is the list of the bound variables
18:57:20 <phobes> but maybe I'm forgetting some cases
18:57:24 <phobes> Here's what I was thinking:
18:57:25 <phobes> shuffle [] = []
18:57:25 <phobes> shuffle x : [] = x : []
18:57:25 <phobes> shuffle x : y : z = y : x : shuffle z
18:57:25 <phobes> =>
18:57:25 <phobes> shuffle x = let
18:57:26 <phobes> 	fail = fail
18:57:28 <phobes> 	pat3 x = deCons x (\h,t -> (deCons t (\h2, t2 -> h2:h:t2) fail)) fail
18:57:30 <phobes> 	pat2 x = deCons x (\h,t -> (deEmpty t (\()-> x:[]) (pat3 x))) fail
18:57:32 <phobes> 	pat1 x = deEmpty x \()->[] (pat2 x)
18:57:34 <phobes>   in pat1 x
18:57:36 <oerjan> byorgey: if you make sure the lists are sorted by their first element
18:57:40 <byorgey> phobes: hpaste, please
18:57:52 <phobes> byorgey:  ya sorry
18:57:58 <byorgey> phobes: np =)
18:58:24 <ddarius> phobes: data T a b = D1 a Int | D2 b a | D3, foldT :: (a -> Int -> c) -> (b -> a -> c) -> c -> T a b -> c
18:58:26 <byorgey> oerjan: yeah, I seem to remember reading something about that somewhere...
18:58:33 <newsham> are there any good haskell related class lectures online?
18:58:45 <newsham> (if not, why not? :)
18:59:16 <oerjan> byorgey: then you can ignore all the lists that haven't already produced a number, except the first
18:59:21 <ddarius> newsham: Videos?
19:00:28 <newsham> yah.
19:00:42 <newsham> like the video lectures MIT has up for some of its open courseware
19:00:55 <thoughtpolice> I have a lot of the MIT OCW videos. :)
19:01:29 <newsham> thoughtpolice: any topics you found particularly interesting that there were videos for?
19:01:45 <newsham> i'm almost done my first ocw course series
19:01:56 <phobes> ddarius:  So can pattern matching be desugared into foldT calls?
19:02:01 <mrd> thoughtpolice: well you can capture stdout
19:02:07 <ddarius> newsham: There are these, http://lambda-the-ultimate.org/node/1303.  I haven't watched them though.
19:02:08 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
19:02:38 <nasa_> Has anybody had success using MacPorts to get GHC on an intel machine? I would *really* prefer binary, since I don't really know how to use MacPorts yet (e.g. I ran the configure script, but then I run "sudo port -b install ghc" and it tries to reconfigure and fails).
19:02:40 <newsham> thanks.  i'll check those out.
19:02:49 <ddarius> phobes: In that case, simple uses of case can be (and more complex patterns can be reduced to simple uses of case)
19:03:11 <newsham> I'd really be interested in one that covered logics (such as the "haskell road to math" book type of course)
19:03:23 <sorear> Does GHC work at all on Intel macs?
19:03:35 <olsner> yeah, I installed from macports just fine
19:03:50 <phobes> ddarius:  ok, thanks, that's what I was interested in.  But GHC doesn't do this desugaring it sounds like and treats patterns primitively
19:03:59 <nasa_> hmm
19:04:00 <olsner> "sudo port install ghc", wait a couple of hours, go ;-)
19:04:07 <newsham> btw, what are the big haskell schools?
19:04:25 <ddarius> phobes: No it doesn't desugar into anything like that, but it does ultimately end up using a representation similar to Church-encoding.
19:04:43 <ddarius> However, that's completely unnecessary and a "naive" approach would be just as valid.
19:04:55 <nasa_> I compiled fine on my G4 PowerBook (minus the ~9 hours), but it just doesn't work. I'll fiddle with it again.
19:05:27 <ddarius> Also what is normally intended by "fold" is not what you'd want for pattern matching in general.
19:06:06 <ddarius> newsham: Check the HC&AR perhaps?
19:06:31 <ddarius> There's probably also a link on haskel.org specifically for such things.
19:07:07 <newsham> hc&ar == ?
19:07:10 <phobes> ddarius:  foldT sounds like overkill ... applying individual destructors like I was trying to suggest seems like it would be a more direct translation of the pattern
19:07:29 <newsham> haskell.org has a link for videos, but only a small handful, and no class lectures.
19:07:42 <sorear> @go haskell communitees and activities report
19:07:44 <lambdabot> http://www.haskell.org/communities/
19:07:44 <lambdabot> Title: Haskell Communities and Activities Report
19:07:51 <newsham> danke
19:08:12 <ddarius> newsham: I was referring to your question about schools.
19:08:19 <phobes> ddarius: thanks for the help
19:08:26 <newsham> ddarius: ahh, I see.
19:08:40 <ddarius> phobes: You may want to look at the paper on first class patterns.
19:09:21 <ddarius> @google "first class patterns"
19:09:24 <phobes> ddarius: the not-freely-available one?
19:09:24 <lambdabot> http://citeseer.ist.psu.edu/337368.html
19:09:25 <lambdabot> Title: First Class Patterns - Tullsen (ResearchIndex)
19:09:28 <phobes> oh nm
19:10:52 <phobes> ddarius: Thanks, this is essentially exactly what I was thinking
19:11:32 <phobes> ddarius:  I first used Maybe but thought it a bit circular (since Maybe is itself a datatype which would be pattern matched) so replace it with the two case functions
19:11:59 <thoughtpolice> mrd: is there a way to capture stdout for only a given expression?
19:12:15 <ddarius> phobes: You may also want to look at continuation passing and particularly it's relation to logical negation.
19:12:27 <mrd> you can temporarily redirect stdout :/
19:12:53 <phobes> ddarius: That's some wadler paper, right?
19:13:13 <ddarius> I don't think Wadler has too much on that.  I'm not referring to a particular paper.
19:13:16 <monochrom> There is a TMR article on that in TMR issue 6.
19:13:24 <ddarius> Though there are probably some good ones.
19:14:25 <monochrom> @djinn (Either a b -> r) -> r
19:14:25 <lambdabot> -- f cannot be realized.
19:14:44 <monochrom> Oh, typo
19:14:56 <monochrom> @djinn (Either a (a -> ()) -> r) -> r
19:14:56 <lambdabot> f a = a (Right (\ _ -> ()))
19:16:27 <monochrom> That is a glimpse of CPS and negation, to arouse your interest.
19:16:59 <phobes> ddarius: I can't find the link, but I could swear I saw a video of Wadler giving a presentation in which he stated that he had come up with a correspondence between standard logic and lambda calculus with continuations
19:17:36 <ddarius> phobes: He's definitely done -some- stuff on it.
19:18:19 <hpaste>  mrd pasted "wrapping an IO action and returning its output" at http://hpaste.org/2538
19:18:20 <phobes> ok
19:18:22 <ddarius> @seen sigfpe
19:18:22 <lambdabot> I haven't seen sigfpe.
19:18:42 <mrd> @seen dpiponi
19:18:42 <lambdabot> I saw dpiponi leaving #haskell 2d 2h 50m 11s ago, and .
19:18:50 <newsham> "adventures in classical-land"
19:18:55 <newsham> coincidentally reading that now
19:19:15 <mrd> thoughtpolice: mind you that is definitely POSIX-dependent
19:19:47 <thoughtpolice> mrd: hm...
19:21:00 <thoughtpolice> well that's really the main thing I'm wondering about.
19:21:46 <phobes> monochrom:  I've written that down and will puzzle over what it has to do with anything later :)  Thanks
19:23:15 <mrd> @hoogle callcc
19:23:16 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
19:23:45 <mrd> phobes: i read an article or two pointing out the similarity between the type of callcc and Peirce's law
19:24:06 <mrd> which is only true in Classical logic
19:24:27 <newsham> you guys know a lot of weird things (i'm jealous)
19:24:44 <phobes> mrd: Yes, classical logic is constructive logic + Peirce's law I think... that's what Wadler claimed to have found the connection to
19:24:48 <mrd> it's what we do instead of real work
19:25:24 <LoganCapaldo> This is the land of weird knowledge.
19:25:30 <newsham> i'm a bit overwhelmed trying to learn a bunch of this stuff and trying to figure out what is worth spending my time on and what isnt
19:26:11 <LoganCapaldo> Trust your instincts
19:26:14 <LoganCapaldo> heh
19:26:22 <LoganCapaldo> let the weird flow thru you
19:26:44 <newsham> i feel like i'm stuck in a transitive closure that will never terminate
19:27:04 <newsham> i shoulda taken the blue pill
19:28:07 <ddarius> newsham: It's quite possible that I tried to warn you away earlier.  I've attempted that a few times.
19:28:33 <newsham> caveat emptor
19:28:53 <ddarius> Incidentally, you may find http://lambda-the-ultimate.org/node/814#comment-7491 and the page it links to (assuming the link is still live) interesting in relation to what is discussed in the conclusion of Dan's article.
19:28:55 <lambdabot> Title: A Typed, Compositional Logic for a Stack-Based Abstract Machine | Lambda the Ult ...
19:28:58 <hpaste>  byorgey annotated "generating squarefree numbers" with "oerjan's idea works!" at http://hpaste.org/2537#a1
19:29:06 <byorgey> oerjan++
19:30:22 <ddarius> Joy. The link is dead.
19:31:16 <chessguy> no Joy for you!
19:31:44 <chessguy> @where joy
19:31:44 <lambdabot> I know nothing about joy.
19:31:50 <chessguy> poor LB
19:32:02 <monochrom> Talking about both Matrix (the movies) references and logics and lambda calculi... Wadler has "call-by-value is dual to call-by-name", and then "call-by-value is dual to call-by-name, reloaded". Wonder if he will also have "call-by-value is dual to call-by-name revolution".
19:32:22 <newsham> does his sequel also suck?
19:32:33 <ddarius> @google "Atsushi Ohori"
19:32:35 <oerjan> @go Joy programmin language
19:32:35 <lambdabot> http://www.pllab.riec.tohoku.ac.jp/~ohori/
19:32:35 <lambdabot> Title: Atsushi Ohori
19:32:37 <lambdabot> http://citeseer.ist.psu.edu/mciver96seven.html
19:32:37 <lambdabot> Title: Seven Deadly Sins of Introductory Programming Language Design - McIver, Conway ( ...
19:32:38 <ddarius> This is what google is for.
19:32:45 <oerjan> @go Joy programming language
19:32:48 <lambdabot> http://en.wikipedia.org/wiki/Joy_(programming_language)
19:33:21 <monochrom> Well, the first was a refereed paper, the sequel was an invited talk. Draw your own conclusion. :)
19:33:21 <chessguy> hmm, that sounds like an interesting paper
19:33:54 <newsham> now to be completely off topic: has anyone tried (successfully?) to get lhs2tex running with ghc and win32?
19:34:01 <monochrom> BTW it may be what phobes is recalling about a Wadler article on continuation vs classical logic.
19:34:55 <phobes> monochrom: yes
19:35:04 <phobes> that is in fact what I think he was referring to
19:35:23 <phobes> ooh nm
19:35:27 <phobes> I don't know if that is
19:35:28 <nasa_> oerjan: Thanks for the link to Joy! I was actually sketching out a programming language almost exactly like this (ok, so it was a stack based pure FP language, not exactly the same), and now I might not have to!
19:35:32 <phobes> sorry misread your comment
19:36:40 <oerjan> nasa_: might also want to check out Cat, an attempt to add types to the mix...
19:37:34 <nasa_> heh. That is _exactly_ what I was looking for.
19:37:54 <oerjan> (been discussed on Lambda the Ultimate)
19:38:12 <ddarius> @google site:lambda-the-ultimate.org cat
19:38:14 <lambdabot> http://lambda-the-ultimate.org/node/1879
19:38:14 <lambdabot> Title: The Cat Language Kind System | Lambda the Ultimate
19:38:17 <nasa_> That is probably why it looks strangely familiar.
19:40:23 <oerjan> nasa_: not to forget the #concatenative channel :)
19:46:12 * ddarius is considering implementing a monadic linear logic language again.
19:50:23 <olsner> oh, someone's already invented a stack-based language with type inference
19:52:39 <newsham> huh, the guy who wrote the monad reader article on classical logic and callcc worked on the matrix films
19:52:43 <newsham> to tie this back full circle
19:55:07 <Saizan> newsham: doing?
19:55:58 <newsham> saizan: send in private message, kinda long
19:55:59 <aFlag> I'm trying to run this quickcheck script http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck on this file http://rafb.net/p/JthjD073.html but it says something about not finding a main, does anyone know what I'm doing wrong?
19:56:15 <aFlag> <interactive>:1:102:
19:56:15 <aFlag>     Failed to load interface for `Main':
19:56:18 <aFlag> that's what it says
20:00:05 <oerjan> aFlag: what does hugsin look like?
20:00:35 <aFlag> I don't think it gets to that part
20:00:51 <monochrom> newsham: that connection is freaky!
20:01:41 <newsham> shoulda took the blue pill
20:01:55 <oerjan> hm, it looks like shapr's program?
20:02:43 <oerjan> (that "shae" in the file)
20:02:52 <aFlag> hm, I changed the paths and it's closer to working it seems like
20:06:07 <thedatabase> evening folks
20:06:11 <oerjan> that ./ghci seems strange, and why does it mix hugs and ghc?
20:06:40 <thedatabase> are stack-based languages en vogue again?  i was just having an argument with my boss about them this week
20:06:49 <thedatabase> FORTH anyone?
20:07:25 <nasa_> Well, pretty much every language has _some_ support.
20:07:35 <Mr_Awesome> except mine
20:07:40 <newsham> jvm!
20:07:48 <newsham> btw, anyone look at scala?
20:07:56 <nasa_> I don't know about others, but I think that stack based languages are very nice.
20:07:59 <oerjan> briefly
20:08:10 <nasa_> (Haskell == better, but that is a different story.)
20:08:17 <Mr_Awesome> i feel like stack based languages force micromanagement
20:08:19 <thedatabase> what i was missing in my argument with my boss was this:
20:08:21 <newsham> what is "very nice" about them?
20:09:02 <thedatabase> one cool thing about linear logic is conservation of terms (cf vending machine example, need for !bang)
20:09:14 <newsham> stack based machines miss constant subexpression elimination opportunities, no?
20:09:30 <thedatabase> i was at a loss to explain how this would transfer to the languages domain
20:09:51 <monochrom> I'm wondering why I need to care that there is a stack behind my programming language.
20:10:00 <aFlag> oerjan, I don't know, I was able to fix it, but it does kind of a mess with haskell interpreters
20:10:06 <nasa_> They are efficient in terms of code space, and are fun to use, mostly.
20:10:24 <oerjan> aFlag: as long as it works now :)
20:10:39 <blazzy> is there a reason I don't see any recent i386 builds here? http://www.haskell.org/ghc/dist/current/dist/
20:10:40 <lambdabot> Title: Index of /ghc/dist/current/dist
20:10:46 <newsham> they can be efficient to interpret, too, but not so good for translation to non-stack assembly
20:11:01 <nasa_> well, monochrom, if your language _is_ a stack, it might be important.
20:11:05 <aFlag> hm, I have to import a module where my functions are, but it's the Main module, so it doesn't let me import that, is there a way around that?
20:11:41 <monochrom> blazzy: try http://www.haskell.org/ghc/download_ghc_661.html
20:11:42 <lambdabot> Title: GHC: Download version 6.6.1
20:11:53 <thedatabase> one example I read was you can be guarenteed there's no illicit copying going on
20:12:16 <aFlag> I want to import it for quickchecking the functions
20:12:38 <nasa_> I spent an afternoon a month or so ago and wrote a reverse polish calculator, which turned into an entire language (almost). There is very little going on behind the scenes for stack languages (at least compared to other languages), so they are easy to implement.
20:12:45 <blazzy> monochrom: well I was hoping to find a nightly build :)
20:12:55 <monochrom> oops
20:13:06 <oerjan> aFlag: perhaps the -main-is flag?
20:13:19 <aFlag> what's that? A ghci flag?
20:14:22 <oerjan> i think so
20:14:41 <oerjan> or ghc
20:15:13 <aFlag> hm, my ghc doesn't seem to have it
20:16:17 <shachaf> aFlag: I thought you had >= 6.6.
20:16:20 <oerjan> it's under linking options
20:16:26 <shachaf> aFlag: That should have it.
20:16:35 <aFlag> I have 6.6
20:16:43 <oerjan> but it may be only for non-interactive use?
20:16:44 <phobes> In "let Pattern = Match in Value", does the pattern match occur entirely as soon as the first free variable is required?
20:16:49 <newsham> aflag: I have a small example of using quickcheck here:  http://www.thenewsh.com/%7Enewsham/tree/
20:16:51 <lambdabot> Title: Directory /~newsham/tree/
20:16:57 <newsham> in particular the CheckTree.hs
20:17:21 <oerjan> phobes: yes, if i get what you mean
20:17:22 <newsham> (i dont use the quickcheck shell script though)
20:17:40 <oerjan> let's check
20:17:58 <oerjan> > let (a,(b,c)) = (1,undefined) in a
20:18:02 <lambdabot>  Undefined
20:18:11 <phobes> thanks!
20:18:17 <aFlag> newsham, you don't import the Main module, though
20:18:18 <newsham> basically if you import Test.QuickCheck you can run "quickCheck prop_removeExtras"
20:18:19 <aFlag> that's my problem
20:19:24 <byorgey> phobes: if you don't want that, you can use an irrefutable pattern
20:19:34 <oerjan> > let (a,~(b,c)) = (1,undefined) in a
20:19:36 <lambdabot>  1
20:19:36 <byorgey> > let ~(a, (b,c)) = (1, undefined) in a
20:19:37 <lambdabot>  Undefined
20:19:40 <newsham> why not just "ghci Server.hs" then ":module +Test.QuickCheck" and "quickCheck prop_removeExtras" ?
20:19:49 <byorgey> erm, what oerjan said =)
20:20:07 <newsham> err.. soryr, not Server.hs but whatever your paste filename is called
20:20:13 <monochrom> Be careful what you protect and whether it is moot.
20:20:35 <phobes> byorgey: interesting
20:20:51 <aFlag> newsham, well, I have to define prop_removeExtras somewhere and it has to see the stuff defined on Server.hs
20:21:06 <newsham> aflag: is that a problem?
20:21:12 <byorgey> phobes: any pattern beginning with ~ will be *assumed* to match, but only actually matched when one of its constituents is demanded
20:21:18 <aFlag> yes, because I can't import Server.lhs
20:21:27 <newsham> why cant you import Server.lhs?
20:21:34 <aFlag> because it's the Main moduel
20:21:43 <newsham> wont ghci let you import it anyway?
20:21:43 <phobes> byorgey: Ya, that's what I guessed it meant from your examples
20:21:54 <sorear> byorgey: let ~p = v in e   ====   let p = v in e
20:21:54 <byorgey> phobes: which of course can cause a run-time error if it doesn't actually match, but it can help make things appropriately lazy sometimes
20:22:02 <phobes> right
20:22:06 <aFlag> newsham, it let's me load it, but not import it
20:22:25 <aFlag> newsham, the only way would be defining prop_removeExtras inside ghci
20:22:26 <monochrom> ~ is a non-strictness annotation.
20:22:36 <byorgey> sorear: right
20:22:40 <newsham> aflag: perhaps its because of the .hi and .o files in your dir?
20:22:45 <phobes> monochrom, oh, in general?
20:23:06 <monochrom> A way of understanding it.
20:23:06 <newsham> oh.. you have "Server.lhs" which is "module Main"
20:23:12 <phobes> oh ok
20:23:17 <newsham> it wants the filename to match up with the module name methinks
20:23:30 <byorgey> sorear: did I say something incorrect?
20:23:37 <sorear> 20:07 < byorgey> > let ~(a, (b,c)) = (1, undefined) in a
20:24:01 <byorgey> sorear: oh, right, that was just a braino =)
20:24:03 <newsham> aflag: have you tried calling it Main.lhs and import Main?
20:24:03 <monochrom> Some people thought ~ was mind-boggling. Well, if !, the strictness annotation, is intuitive, then so must be ~, which is in spirit just the opposite.
20:24:12 <aFlag> I haven't
20:24:50 <oerjan> aFlag: you could also call the module Server and use -main-is
20:25:28 <aFlag> I don't know how -main-is works, should I say -main-is Server?
20:25:33 <aFlag> ghc --help doesn't have -main-is
20:25:39 <oerjan> Server.main i guess
20:25:46 <newsham> the web docs are much more complete than --help schpiel
20:25:56 <oerjan> that's for when you compile your main program
20:25:59 <phobes> byorgey:  So if you use the ~ annotation, and that pattern is eventually forced, but doesn't match, it doesn't just fail?  it's a runtime error?
20:26:27 <byorgey> phobes: right, at that point the pattern has already "matched", it's too late for a pattern-match failure
20:26:34 <byorgey> phobes: so the only option is a runtime error
20:26:54 <monochrom> > case [1] of [] -> 1
20:26:55 <lambdabot>   Non-exhaustive patterns in case
20:26:58 <phobes> byorgey:  because it would complicate the implementation too much to have to "backtrack"?
20:27:04 <monochrom> > case [1] of ~[] -> 1
20:27:05 <lambdabot>  1
20:27:11 <monochrom> Oh, that one is ok. :)
20:27:20 <monochrom> > case [] of ~[x] -> x
20:27:20 <oerjan> > let (a,~(b,Nothing)) = (1,(2,Just 3)) in b
20:27:22 <lambdabot>   Irrefutable pattern failed for pattern [x]
20:27:22 <lambdabot>   Irrefutable pattern failed for pattern (b, Data.Maybe.Nothing)
20:27:38 * monochrom has an evil idea
20:27:48 <monochrom> > case [1] of ~(x@[]) -> x
20:27:49 <lambdabot>   Irrefutable pattern failed for pattern ((x@[]))
20:27:50 <sorear> let (p,q) = (a,b) in e  ==== let p = a; q = b in e
20:27:53 <newsham> aflag: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
20:27:55 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
20:28:11 <byorgey> phobes: I guess so, I'm not sure what all the effects are on implementation
20:28:14 <sorear> something worse has been done!
20:28:29 <sorear> > case [1] of x@~[] -> x
20:28:29 <lambdabot>  Parse error in pattern
20:28:34 <sorear> > case [1] of ~x@[] -> x
20:28:36 <lambdabot>   Irrefutable pattern failed for pattern (x@[])
20:28:50 <monochrom> x@(~[]) will work
20:28:56 <monochrom> I mean it will parse.
20:29:07 <phobes> :t @
20:29:09 <lambdabot> parse error on input `@'
20:29:15 <aFlag> all it says is: -main-is	Set main module and function. and if I do ghci -main-is Server and try to load ServerQC.hs it doesn't work
20:29:21 <oerjan> phobes: it's a special keyword
20:29:22 <monochrom> However, the Haskell 98 report allows x@~[].
20:29:30 <byorgey> phobes: @ lets you bind a name to the result of an overall pattern match.
20:29:35 <aFlag> I'll just change it from Server.hs to Main.hs, it's not very pretty, but it works :)
20:29:36 <phobes> oh ok
20:30:04 <newsham> aflag: if you have "Serv.hs" with "module Serv where" and it has a "main =" you can "ghc --make -main-is Serv Serv.hs"
20:30:10 <monochrom> > case [1] of x@(~[]) -> x
20:30:11 <lambdabot>  [1]
20:30:19 <monochrom> Now that's interesting.
20:30:23 <oerjan> aFlag: you would need to have a module Server line in the file too, btw
20:30:27 <byorgey> > let f y@(a,b) = (a,y) in f (1,2)
20:30:28 <lambdabot>  (1,(1,2))
20:30:30 <newsham> (or just ghc --make Serv.hs)
20:31:05 * monochrom has to read the Haskell 98 report again to see if it's specified behaviour.
20:31:16 <byorgey> monochrom: interesting
20:31:27 <oerjan> monochrom: seems intuitive to me
20:31:29 <newsham> the "import" stuff is assuming a correspondence between module names and file names
20:31:31 <aFlag> newsham, oh, I see
20:31:42 <monochrom> My last reading says that's wrong behaviour. I want to double-check.
20:31:50 <oerjan> nothing inside ~ is forced unless a variable there is, since there are none you are safe
20:32:47 <byorgey> > case [1] of x@(~[a,b]) -> x
20:32:48 <lambdabot>  [1]
20:32:56 <monochrom> Ha, my last reading was wrong. The behaviour above is right.
20:33:13 * phobes exhails
20:33:41 <byorgey> phobes: have you been holding your breath this whole time?
20:33:46 <newsham> aflag: are your tests working now?
20:33:56 <phobes> byorgey: yes, scroll up to where I started
20:34:19 <phobes> thanks for the information all, nite
20:34:41 <ddarius> thedatabase: Are you familiar with the pi calculus? Or perhaps the join calculus?  Or even message passing concurrency a la Erlang?
20:34:43 <byorgey> g'night phobes
20:35:23 * monochrom enjoys being a language lawyer.
20:35:50 <thedatabase> hey ddarius... funny you should mention that but i am
20:36:01 <thedatabase> when i was in the early days of my phd studies
20:36:10 * byorgey goes back to work polishing his article for TMR
20:36:17 <thedatabase> i was investigating conservative versions of the pi calculus
20:36:44 <thedatabase> i had some crazy idea to relate the conservation to emergent systems
20:36:46 <newsham> mono: i've got a few languages i'd like to sue.
20:36:50 <ddarius> thedatabase: Did you ever look at LLF/Lolli, CLF/LolliMon?
20:37:08 <newsham> when is new TMR due out?
20:37:09 <thedatabase> looked at Lolli, a while ago
20:37:25 <thedatabase> reacquainted myslef this week!
20:37:48 <ddarius> LolliMon looks really cool.  I want to implement something like it in Haskell some time.
20:39:17 <byorgey> newsham: soon, articles are due tomorrow
20:40:08 <thedatabase> lollimon huh.....need to look this up!
20:41:33 <ddarius> http://www.cs.cmu.edu/~fp/papers/ppdp05.pdf This is probably a good place to start.
20:41:49 <ddarius> s/.pdf/.ps/ if you prefer
20:45:34 <aFlag> newsham, now they are :)
20:46:42 <newsham> great
20:49:29 <FMota> question: how good is haskell for building applications? (GUI-based)
20:49:37 * dons leaves for the US. see you on the other side #haskell :)
20:50:06 <FMota> :)
20:50:25 <FMota> have a *cough*pleasant trip. Don't let the border officers annoy you.
20:50:58 <newsham> bring some of your quickly appreciating currency with you, dons
20:51:14 <dons> yeah, its solid gold now, these pacific pesos :)
20:51:27 <dons> seeya!
20:51:34 <newsham> happy trails
20:51:36 <FMota> lol, I have 110 euros right next to me.
20:51:38 <FMota> ciao!
20:51:43 <ddarius> America steals another one!
20:51:43 <thoughtpolice> later dons!
20:51:46 <newsham> dollars on a roll isnt it?
20:51:46 <FMota> *10
20:51:50 <FMota> that is, 10 euros.
20:51:55 <newsham> soon people will be able to afford american cars
20:52:04 <newsham> (not that they'd want to)
20:52:14 <FMota> :o (exactly)
20:53:36 <idnar> @src (.)
20:53:37 <lambdabot> (.) f g x = f (g x)
20:54:06 <monochrom> Soon, 10 euros will buy you a fine Java book published in the US. (Haha, double insult!)
20:54:08 <FMota> so... question again.
20:54:27 <FMota> ouch monochrom
20:54:43 <FMota> even NASA left.
20:55:15 <FMota> anyway, how good is Haskell for building GUI applications?
20:55:26 <sorear> moderately
20:55:32 <newsham> the logician?  he's probably never written one
20:55:44 <monochrom> If the libraries are more developed, very good.
20:55:45 <FMota> :) funny.
20:56:00 <FMota> k. ty.
20:56:01 <sorear> what it loses in lack of state, it makes up for in not requiring public static final void
20:56:08 <monochrom> Note: libraries are more developed, NOT more libraries are developed. :)
20:56:22 <newsham> you got gtk, you got wx.  the tools are there.
20:57:16 <monochrom> If you are not theoretically inclined, gtk2hs is already quite decent and practical.
20:57:43 <FMota> thanks. But... not entirely interested.
20:59:54 <monochrom> Someone should develop an arrow layer on top of gtk2hs. I propose a name for it: gtk->hs, or even hs->gtk.
21:01:56 <sorear> IIRC both Phooey and PropLang do that
21:02:10 <sorear> @localtime conal
21:02:21 <monochrom> Yes, but I think my name is more catchy. :)
21:02:53 <sorear> Agreed. :)
21:04:19 <byorgey> @botsnack
21:04:20 <lambdabot> :)
21:04:44 <sorear> byorgey: it's normal for @localtime to not respond, the code is very nasty
21:04:57 <byorgey> sorear: I was wondering about that
21:05:12 <byorgey> sorear: what's so nasty about it?
21:05:33 <sorear> byorgey: It doesn't go through the command loop.
21:05:58 <sorear> byorgey: @localtime sends a CTCP TIME request to the client, and arranges to forward any reply to the channel
21:06:03 <sorear> no reply -> no response
21:06:29 <byorgey> sorear: ah, I see.  that is nasty.
21:06:41 <byorgey> @localtime
21:06:43 <lambdabot> Local time for byorgey is Sat Sep  1 00:05:31
21:07:08 <byorgey> @localtime sorear
21:07:10 <lambdabot> Local time for sorear is Fri Aug 31 20:54:04 2007
21:08:01 <idnar> @localtime
21:08:04 <lambdabot> Local time for idnar is Sat Sep  1 06:06:51 2007
21:08:05 <byorgey> wow, I didn't know there were time zones separated by 3 hours and 11 minutes. =)
21:08:07 <idnar> cute
21:08:28 <idnar> byorgey: that must be one of the timezones where they don't use ntp ;)
21:08:30 <sorear> uhm...
21:08:38 <sorear> gah!
21:08:46 <sorear> I have ntp installed!
21:08:57 * sorear curses the debian initscripts maintainer
21:09:03 <byorgey> hehe
21:10:09 <jbalint> hi
21:10:29 <byorgey> hi jbalint
21:10:48 <sorear> okay, try again
21:11:01 <oerjan> @localtime sorear
21:11:02 <lambdabot> Local time for sorear is Fri Aug 31 21:09:50 2007
21:11:07 <sorear> btw, clock skew is fun - ntpdate just mde my monitor turn off!
21:11:17 <byorgey> wow, nice!
21:11:54 <byorgey> um... is it back on?
21:12:16 <byorgey> guess not =)
21:12:22 <sorear> yes, it came back on when I started typing :)
21:12:22 <oerjan> what?
21:12:43 <idnar> I once rebooted after adjusting the clock, just because I was too lazy to get several of the daemons that were running back into a sane state
21:12:48 <oerjan> write-only terminal!
21:13:30 <ddarius> oerjan: That seems to be what me denizens of the Internet use.
21:14:14 <byorgey> @yarr !
21:14:14 <lambdabot> Arr! Me ship be the biggest brig in the port!
21:16:25 <ddarius> Constrained Intuitionistic Linear Logic is exactly what I think of when I'm solving robot planning problems.
21:17:51 <oerjan> constrained?
21:18:22 <sorear> No, really, you don't need to tell us that, we worship you enough as is.
21:19:49 <thedatabase> ddarius:  checked out lollimon.  Looks amazing but too rich and applied for my purposes these days!!!!  ha ..... amazing to see this whole area come along though.  Been checking out Luca Cardelli's stuff?
21:21:21 <monochrom> A Novel Sudoku Solver in Constrained Intuitionistic Linear Logic and Implemented in The LOL Monad.
21:21:34 <FMota> The LOL Monad?
21:21:35 <FMota> :o
21:22:04 <monochrom> I can't help but read lollimon as either the lol monster or the lol monad.
21:22:25 <byorgey> FMota: It's isomorphic to Maybe
21:22:30 <FMota> ok
21:22:47 <byorgey> I mean, Error.
21:22:53 <byorgey> data LOL a = KTHX a | O_NOES String
21:23:14 <monochrom> lol
21:23:46 <FMota> haha
21:24:10 <monochrom> @quote KTHX
21:24:10 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:24:24 <FMota> brocolli brains? :o
21:24:25 <monochrom> @quote Kthx
21:24:26 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
21:24:29 <thedatabase> ddarius:  wow, that's a coincidence
21:24:42 <thedatabase> i've tackled block-world
21:24:52 <thedatabase> vie eric baum's work
21:24:53 <thedatabase> !
21:25:18 <thedatabase> this was the reason I got onto linear logic ---- Baum has his Hayek economies
21:25:35 <thedatabase> i was looking for something more justified
21:25:43 <thedatabase> computationally speaking
21:25:59 <thedatabase> and so discovered linear logic (and reversible computation)
21:27:37 <thedatabase> (specifically:  wouldn't it be great to inject a fundamental notion of resource into all these wooly discussions about agent "economies"?)
21:36:08 <ShockSMX> haha
21:36:08 <aFlag> man, I sure am having trouble handling strings in haskell
21:36:26 <oerjan> hm?
21:36:28 <ShockSMX> "if you say 'compute 3 ten times', you'll get 3 every time. so you probably don't want to do that."
21:38:01 <aFlag> I have a string like this "JOIN abc def ghi jkl NIOJ asf ffgg garbage", I want to be able to return only the stuff after NIOJ and there could be a scape, like \NOIJ, that work as if it was just regular text
21:39:09 <oerjan> reminds me of the search problem from yesterday, was that you too?
21:39:16 <aFlag> yes
21:39:41 <aFlag> I'm having a real hard time doing those
21:39:58 <aFlag> isn't there like a library that will make my life easier?
21:40:30 <oerjan> there is a regex library
21:41:01 <sorear> ShockSMX: Context?  Sounds like SPJ/OSCON
21:41:04 <oerjan> can NIOJ be at the start of the string?
21:41:21 <aFlag> it could
21:41:40 <oerjan> ok so use that prepend ' ' trick again
21:41:45 <aFlag> it shouldn't but I want to handle those things gracefully
21:43:03 <aFlag> that time we wre just looking for the keyword, now I not only have to find the last ocurrence of it but I need to keep everything after it
21:43:19 <oerjan> the _last_ one?
21:43:58 <oerjan> well, let's start by finding all of them.  a nice trick is zip (inits s) (tails s) which gives you all ways of splitting a string
21:44:38 <aFlag> hm
21:44:56 <aFlag> aren't those things really inefficient, though?
21:45:31 <oerjan> well inits is a bit
21:45:43 <aFlag> because it's really O(n) algorithm
21:45:43 <byorgey> oerjan: it is?
21:45:49 <byorgey> @src inits
21:45:49 <lambdabot> inits []     =  [[]]
21:45:49 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
21:46:01 <oerjan> because it cannot share anything
21:46:10 <byorgey> oerjan: ah, right
21:47:45 <oerjan> well we don't need the inits part if we use the same trick from yesterday
21:48:08 <sorear> don't forget about laziness
21:48:31 <sorear> oh, nvm
21:50:37 <oerjan> > let search k s = [rest|(c:r) <- tails (' ':s), k`isPrefixOf`r, c/='\\', let rest=drop (length k) r] in search "NOIJ" "JOIN abc def ghi jkl NIOJ asf ffgg garbage"
21:50:38 <lambdabot>  []
21:51:03 <oerjan> > let search k s = [rest|(c:r) <- tails (' ':s), k`isPrefixOf`r, c/='\\', let rest=drop (length k) r] in search "NIOJ" "JOIN abc def ghi jkl NIOJ asf ffgg garbage"
21:51:04 <lambdabot>  [" asf ffgg garbage"]
21:51:32 <ShockSMX> sorear: yeah, that's what it was. i'm finishing up watching it
21:53:59 <oerjan> that doesn't find the last one though, and what if there isn't one?
21:55:03 <oerjan> > let search k s = last $ Nothing:[Just rest|(c:r) <- tails (' ':s), k`isPrefixOf`r, c/='\\', let rest=drop (length k) r] in search "NIOJ" "JOIN abc def ghi jkl NIOJ asf ffgg garbage"
21:55:04 <hpaste>  sjanssen pasted "quicksort with type families" at http://hpaste.org/2539
21:55:05 <lambdabot>  Just " asf ffgg garbage"
21:55:43 <oerjan> > let search k s = last $ Nothing:[Just rest|(c:r) <- tails (' ':s), k`isPrefixOf`r, c/='\\', let rest=drop (length k) r] in search "NIOJ" "JOIN abc NIOJ def ghi jkl NIOJ asf NIOJ ffgg garbage"
21:55:44 <lambdabot>  Just " ffgg garbage"
21:55:59 <oerjan> > let search k s = last $ Nothing:[Just rest|(c:r) <- tails (' ':s), k`isPrefixOf`r, c/='\\', let rest=drop (length k) r] in search "NIOJ" "JOIN abc NIOJ def ghi jkl NIOJ asf \\NIOJ ffgg garbage"
21:56:00 <lambdabot>  Just " asf \\NIOJ ffgg garbage"
21:56:08 <oerjan> seems to work :)
21:56:48 <sjanssen> type families make type programming fun and easy!
21:59:27 <aFlag> yeah, it looks good
21:59:31 <oerjan> aFlag: anyway searching a list is always going to be O(n) unless it has been prescanned
22:00:12 <aFlag> but using tails and inits isn't O(n)
22:00:33 <oerjan> tails is pretty quick
22:00:44 <aFlag> after all, it can't find all the prefixes in O(n), can it?
22:01:22 <aFlag> hm, maybe it can
22:01:22 <oerjan> oh right, the prefixes
22:01:36 <sjanssen> it can generate the suffixes in O(n)
22:01:43 <aFlag> yeah
22:01:45 <oerjan> however that is only going to be a problem if there are a lot of false near-matches
22:01:56 <oerjan> NIO and such
22:02:10 <aFlag> you be iterating a bigger list than the original string, though
22:02:26 <oerjan> just one more element
22:03:34 <oerjan> with a bit of luck ghc will turn most of it into looping
22:03:47 <aFlag> but if we iterate the list and check each character we do one comparison per character, if we check a list of suffixies for matches, we do more than one comparison per char
22:04:29 <oerjan> yes, so the worst case is O(mn) i guess
22:04:42 <aFlag> maybe the code would be a lot nicer with a lexer
22:05:15 <jbauman> regex would work
22:05:23 <oerjan> is this NIOJ string fixed?
22:05:24 <jbauman> would also be O(m+n)
22:05:47 <aFlag> what do you mean by fixed? There are a few keyword
22:05:48 <oerjan> if so you could use Alex i guess
22:05:50 <aFlag> keywords
22:06:00 <oerjan> the lexer generator
22:06:46 <aFlag> hm, good, that way I could even see how to generate lexers in haskell
22:07:44 <aFlag> in imperative languages it's really straightforward is basically a loop and a few switches
22:08:00 <oerjan> think of it, Parsec would probably do too
22:08:27 <oerjan> but it's got that O(mn) problem too i think
22:08:35 <oerjan> since it backtracks on failure
22:08:42 <sorear> Regexes!
22:09:20 <sorear> @users
22:09:20 <lambdabot> Maximum users seen in #haskell: 394, currently: 343 (87.1%), active: 8 (2.3%)
22:09:34 <jbauman>  /[^\\]NIOJ(.*)/
22:09:57 <oerjan> jbauman: it should find the last match
22:10:05 <jbauman> oh, last...
22:10:12 <aFlag> jbauman, what about "JOIN asdf NOIJ JOIN asff NOIJ afasfd"
22:10:12 <aFlag> yeah
22:10:21 <sorear> that's easy enough, just take the last regex match!
22:10:58 <aFlag> hm
22:11:05 <jbauman>  /(.*)[^\\]NIOJ(.*)/
22:11:14 <jbauman> relies on the first being a greedy match
22:11:36 <jbauman> works in perl, at least
22:13:14 <Cale> YVAN EHT NIOJ?
22:13:47 <oerjan> IVAN THE TERRIBLE
22:30:23 <aFlag> hm, I think I'll stick with this regex idea
22:31:01 <shachaf> Is there a reason for the (.*)s?
22:31:48 <oerjan> the first to get the last match for the rest, the last because it's the string we're interested in
22:34:08 <jbauman> of course, if the regex engine uses backtracking, that would still be O(mn)
22:34:51 <sorear> regex engines that use backtracking suck and aren't worth catering to
22:35:40 <oerjan> we're talking about the "standard" haskell regex engine, aren't we?
22:36:05 <sorear> there is no standardf
22:37:20 <oerjan> hm, "Module that provides the Regex backend that wraps the c posix regex api. This is the backend being used by the regex-compat package to replace Text.Regex"
22:37:26 <aFlag> sorear, yeah, but for simple regex I think they turn out being more readable.
22:38:44 <aFlag> well, gotta sleep. good night
22:38:56 <jbauman> hmm, posix api uses nfa (i.e. backtracking)
22:39:40 <sorear> api's don't use backtracking, implementations do
22:40:06 <sorear> and 'NFA' can be implemented without it
22:40:21 <oerjan> well http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base.html lists 5 different backends
22:40:23 <lambdabot> http://tinyurl.com/2almet
22:40:47 <sorear> matthew_-: are there going to be videos/slides/whatever of the L/HUG presentations?
22:40:59 * sorear wants to know more about 2-3 finger trees
22:41:34 <sjanssen> yes, that would be a fun talk to see
22:41:39 <sjanssen> the paper is really good
22:41:46 <sorear> the paper?
22:42:17 <sorear> Paterson's original paper described 2-3-4 finger trees
22:42:21 <sjanssen> yeah, Paterson and Hinze . . . something with "2-3 Finger Tree" in the title
22:42:54 <byorgey> it's a functional pearl
22:43:46 <sjanssen> sorear: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
22:43:48 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
22:43:56 <sorear> ty
22:44:42 <sjanssen> my favorite part is the Monoid based indexing system
22:45:19 <byorgey> sjanssen: yeah, that's pretty awesome =)
22:45:32 <byorgey> hm, I guess it's not actually a Pearl
22:54:40 <mudge> I have a question:  say I'm using ghc and I want to look at documentation for the standard libraries,  where would be the best documenation for me to look at?
22:55:05 <ClaudiusMaximus> ?docs Data.List
22:55:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:55:14 <oerjan> @docs
22:55:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
22:55:20 * shachaf reads the source, usually, if possible. :-)
22:55:59 <shachaf> Since the haddock is right there next to it.
22:56:56 <mudge> what about look at the haskell98 report?
22:57:25 <oerjan> that too
22:57:58 <oerjan> although there are some extras in the corresponding new modules
22:59:08 <mudge> what if I just want to look at the standard haskell98 libraries of ghc?
22:59:17 <mudge> not other libraries
22:59:58 <oerjan> extras there too
23:00:06 <shachaf> mudge: Just the report?
23:00:41 <oerjan> foldl' isn't in the report, for example
23:00:48 <Weremanatee> What's the proper way of saying "this function is undefined for the empty list"?
23:01:04 <shachaf> Weremanatee: f [] = undefined, maybe?
23:01:09 <shachaf> @src head
23:01:09 <lambdabot> head (x:_) = x
23:01:10 <lambdabot> head []    = undefined
23:01:15 <mudge> yea, just haskell98 standard libraries   that ghc uses
23:01:36 <Weremanatee> ooh!
23:01:46 <mudge> does it matter to look at ghc documentation or haskell98 documentation?
23:01:48 <shachaf> Or f [] = error "f got []!", to be more helpful.
23:01:51 <Weremanatee> @type undefined
23:01:53 <lambdabot> forall a. a
23:02:03 <Weremanatee> @src undefined
23:02:03 <lambdabot> undefined =  error "Prelude.undefined"
23:02:13 <oerjan> mudge: Data.List contains new functions that H98 List doesn't
23:02:21 <oerjan> foldl', isInfixOf
23:02:26 <oerjan> maybe more
23:02:29 <mudge> thanks orerjan
23:02:52 <mudge> when using ghc,  when using a module,  how do I know if the module is haskell98 or not
23:03:10 <shachaf> mudge: Check the report? :-)
23:03:19 <mudge> in other words how do I know when using ghc if I'm using haskell98 for things or not
23:03:31 <mudge> shachaf: oh okay
23:03:35 <oerjan> you _can_ import it without hierarchical name, as List.  i am not sure if that hides the extras
23:04:18 <shachaf> > List.foldl' (+) 0 [1..100]
23:04:18 <lambdabot>   Not in scope: `List.foldl''
23:04:20 <shachaf> > Data.List.foldl' (+) 0 [1..100]
23:04:21 <lambdabot>  5050
23:04:45 <oerjan> > List.foldl (+) 0 [1..100]
23:04:46 <lambdabot>  5050
23:05:06 <oerjan> seems that it does
23:06:03 <mudge> interesting that the ghc documentation shows you what the functions do,  how to use them,  but doesn't show their definitions
23:06:17 <mudge> are there places where the function definitions are given?
23:06:29 <sjanssen> the source :)
23:06:57 <oerjan> see the link in the top right corner of the page
23:07:06 <brad_> ByeString question: why can't i just say something like s = "string" :: B.ByteString ?
23:07:16 <brad_> building these seems to be painful
23:07:21 <sorear> because strings aren't overloaded in H98
23:07:33 <sorear> -foverloaded-strings, thanks sjanssen
23:07:43 <mudge> oerjan: whoa,  cool
23:07:45 <mudge> the source
23:07:51 <mudge> I see it!
23:07:53 <sjanssen> s/sjanssen/augustss
23:08:00 <brad_> sorear - this is a ghc pragma?
23:08:01 <mudge> top right corner is magical
23:08:13 <Weremanatee> Can I have the compiler catch function invocation on undefined patterns somehow?
23:08:15 <sorear> brad_: command line option
23:08:21 <brad_> thanks sorear!
23:08:33 <sorear> Weremanatee: No, but third-party programs can do it
23:08:35 <sorear> @where catch
23:08:36 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
23:08:52 <Weremanatee> nice. Thanks a lot.
23:09:59 <mudge> whare these "#ifdef __GLASGOW_HASKELL__"   type of declarations in haskell source?   haskell macros?
23:10:04 <mudge> what*
23:10:11 <mudge> what are*
23:10:19 <shachaf> mudge: CPP macros.
23:10:34 <byorgey> blech.
23:10:43 <mudge> huh,  i thought C++ used constants, and C used macros
23:11:00 <oerjan> "C pre-processor"
23:11:05 <shachaf> mudge: CPP = C pre-processor.
23:11:12 <mudge> haha
23:11:22 <mudge> shachaf: thanks
23:11:48 <shachaf> oerjan: How is your name pronounced?
23:11:51 <oerjan> i believe haskell uses a slightly different variant of it
23:12:22 <oerjan> that doesn't break on haskell syntax
23:12:34 <shachaf> oerjan: I think Haskell's is also closer to an older CPP.
23:12:44 <mudge> why are there C macros in haskell source?
23:13:26 <sorear> because it increases expressiveness
23:13:37 <oerjan> mudge: haskell never developed its own syntax for conditional compilation, i guess
23:14:10 <mudge> oerjan: what about template haskell?
23:14:21 <mudge> I heard that was some sort of meta-macro thing
23:14:30 <oerjan> shachaf: well oe is really an o with a slash, front lower rounded
23:14:40 <shachaf> oerjan: Yes, I saw.
23:14:52 <oerjan> mudge: maybe, i don't know enough about it
23:15:40 <oerjan> r is trilled, j is like y, a is a clear vowel and n is pretty normal
23:16:09 <mudge> okay
23:17:40 <oerjan> -jan is close to the German pronunciation
23:18:22 <brad_> can anyone tell me what the fundamental differences between Data.HashTable and Data.Map are?
23:18:46 <oerjan> brad_: hashtable can only be used in the IO monad, Map is pure
23:18:56 <shachaf> brad_: Data.Map is pure.
23:18:59 <oerjan> because hashtable is mutable
23:19:09 <brad_> thanks oerjan and shachaf!
23:19:22 <shachaf> Data.Map is generally recommended, I think.
23:20:50 <sorear> Uhr-yen?
23:22:21 <oerjan> sorear: gah!
23:23:15 <oerjan> the a should be closer to a in father
23:23:21 * sorear has plenty of trouble even in person, and probably meant to add a :)
23:28:17 <takamura> hi
23:30:22 <mudge> takamura: hi
23:30:49 <Eelis> is ghc trac the correct place to report System.Posix.User bugs?
23:31:46 <brad_> another ByteString question. since many of the ByteString functions convert from a Word8 to a ByteString, would it not make sense if there were a Data.Char.ord of type Char -> Word8? is there a simple way to do this?
23:32:12 <brad_> or does unicode fudge this up?
23:35:23 <oerjan> @hoogle (Enum a, Num b) => a -> b
23:35:24 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
23:35:24 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
23:35:24 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
23:35:35 <oerjan> right, broken
23:35:57 <oerjan> @hoogle (Integral a, Num b) => a -> b
23:35:58 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
23:35:58 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
23:35:58 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
23:36:07 <oerjan> or maybe not
23:36:59 <oerjan> :t ord
23:37:00 <lambdabot> Char -> Int
23:37:21 <brad_> found this: charToWord8 = fromIntegral . fromEnum
23:37:29 <oerjan> anyway, fromIntegral . ord should do
23:37:36 <oerjan> yep
23:37:52 <brad_> found it here: http://darcs.haskell.org/takusen/Foreign/C/UTF8.hs
23:46:27 * byorgey is finally finished polishing his TMR article, huzzah!
