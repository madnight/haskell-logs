00:00:15 <Saizan> (return .)
00:00:23 <Cale> (because it just unwraps the meaning of the Kleisli category)
00:00:27 <glguy> I'm trying to disconnect myself from looking at things in haskell's terms of functor and monad
00:00:30 <ski> Saizan : no, not a functor .. 'Kleisli IO' is a "construct" over '*' (and 'IO')
00:01:13 <wli> kolmodin: I'd probably prefer dumping a number of those chapters and breaking out the MPTC/TH/GADT chapter into similar sorts of case studies as the other features mentioned.
00:01:16 <glguy> where a monad isn't a functor, per say, but given the triple of things that make a monad, you can then make the pair of things to define a functor
00:01:28 <ski> Saizan : 'Kleisli IO' is a category built on top of '*' (and 'IO') .. *after* you've built both categories can you worry about whether there's any functors between them !
00:01:39 <Cale> glguy: If you have a monad M on the category C, you can form the Kleisli category C_M whose objects are the same as the objects of C, but an arrow f: X -> Y in C_M is an arrow X -> M Y in C
00:02:19 <Cale> and composition is defined in the only reasonable way, and the identity maps are implemented by return
00:02:26 <kolmodin> wli: aye... but people who doesn't know those chapters might not
00:02:48 <wli> kolmodin: It's more of an expression of how well it fits me as an audience.
00:02:52 <Cale> glguy: One thing you don't have to worry about is that monads always go from the category you're working with to itself.
00:02:52 <glguy> Cale: when you say "if you have a monad M", you are implying that M = (bind, unit, type mapping) right?
00:03:02 <Cale> sure
00:03:18 <Cale> or ((type mapping, function mapping), return, join)
00:03:20 <kolmodin> wli: ah well, we can always hope for yet a book...
00:03:23 <wli> kolmodin: Probably the first 8 chapters I can live without.
00:03:52 <glguy> I'm using to think of [] as "the monad" instead of "concatMap, :[], []
00:04:09 <ski> Saizan : you may have a functor from 'Kleisli IO' to '*', but it maps objects 'X' to objects 'IO X' and morphisms from 'X' to 'Y' into functions from *'IO X'* to 'IO Y'  (which i think was not what you were thinking of)
00:04:12 <wli> kolmodin: And maybe 5 or 6 of the ones after that. From there I'd love for MPTC/TH/GADT affairs to fill in what they vacated. ;)
00:04:37 <Cale> glguy: So if you see us write something like Tf where f is an arrow, we really mean fmap f
00:05:02 <glguy> f lifted into T?
00:05:06 <Cale> yeah
00:05:11 <wli> kolmodin: Frankly I might even prefer to go in for a book exclusively dedicated to the advanced language features like MPTC's, TH, GADT's, et al.
00:05:18 <glguy> Cale: and fT ?
00:05:20 <Cale> If f: X -> Y, then Tf: TX -> TY
00:05:26 <ski> glguy : no
00:05:47 <wli> kolmodin: Rest assured I'll be buying it anyway.
00:05:53 <Cale> glguy: possibly f . T ?
00:05:58 <Saizan> ski: ah, right, given X -> IO Y i can't build X -> Y
00:06:12 <glguy> I've seen the reverse notation used in certain commutative diagramss
00:06:17 <Cale> ah
00:06:34 <glguy> but that doesn't mean I necessarily understood the context
00:06:58 <Cale> ah, if the function in question is a natural transformation...
00:07:10 <Cale> say, eta: F -> G
00:07:16 <Cale> (F and G being functors)
00:07:41 <Saizan> ski: but, i can have F : * -> Kliesli IO  with F (X -> Y) = X -> IO Y and that's probably what i was thinking of
00:07:42 <ski> glguy : eta_F ?
00:07:51 <quicksilver> glguy: yes, there is a notion of subcategory
00:08:29 <wli> kolmodin: Oh, something about how to do things like type-level arithmetic would help me a lot, too.
00:08:42 <glguy> does that make maybeToList a natural transformation? or would you have to also provide a function to map functions on Maybe a to [a]
00:09:26 <kolmodin> wli: sounds like they could make yet a book with only those advanced topics
00:09:30 <Cale> There's some additional notation for eta H and H eta when eta is a natural transformation, and H is a functor.
00:09:34 <glguy> ski: I'm not sure, I was mostly asking about fT out of curiosity
00:09:44 <ski> Saizan : i think your 'F' maps a function (objects maps to themselves) from 'X' to 'Y' into a morphism from 'X' to *'Y'* (which happens to be an underlying function from 'X' to 'IO Y' ..)
00:09:54 <Cale> So you might have seen that notation and gotten confused.
00:09:55 <wli> kolmodin: Yes, and that book is what I'd want.
00:10:06 <Cale> glguy: Do you remember which diagram?
00:10:13 <kolmodin> wli: I'd like it too :)
00:10:18 <ski> @type maybeToList
00:10:20 <glguy> http://north.ecc.edu/alsani/ct01(9-12)/msg00079.html
00:10:24 <lambdabot> Title: categories: Exact adjunctions
00:10:24 <lambdabot> forall a. Maybe a -> [a]
00:10:31 <ski> natural transformation, yes
00:10:34 <wli> kolmodin: I've been wondering if I'd have to write such for myself.
00:10:39 <glguy> Cale: I found that earlier when you guys first started talking about adjunction
00:10:50 <ski> (because of parametricity in haskell)
00:11:00 <wli> kolmodin: Basically explore things and write down the "discoveries" as I go.
00:11:03 <Cale> glguy: ah, yeah, that would be it :)
00:11:12 <quicksilver> glguy: but it's delicate because you have to consider whether it's "sub" on objects or "sub" on arrows or both
00:11:16 <quicksilver> gl	Cale's example wasn't a subcategory because the arrows were different
00:11:24 <Cale> http://en.wikipedia.org/wiki/Natural_transformation#Operations_with_natural_transformations -- the end of this section defines it
00:11:26 <lambdabot> http://tinyurl.com/umyzp
00:11:36 <kolmodin> wli: I was just thinking the same.. (that I would, that is) but I think I can spend my time anyway :)
00:11:43 <Cale> (last paragraph)
00:12:35 <Cale> The thing to keep in mind is that if eta : F -> G
00:12:41 <Cale> then H eta : HF -> HG
00:12:49 <wli> The join operation is something like the homomorphic embedding of a free group into a group.
00:12:49 <Cale> and eta K : FK -> GK
00:13:02 <glguy> I'm still working on pinning down the terminology. But once you have a grasp on what's been talked about so far... what can you do with it
00:13:14 <kolmodin> wli: I think the chapter outline is pretty good anyway. there are much more ppl who doesn't know about the first 14 chapters. I'll amke it easier to start learning haskell and get up to our level
00:13:19 <Cale> glguy: talk about it some more ;)
00:13:19 <glguy> what does identifying something as a Functor or Category allow you to do
00:13:40 <wli> glguy: Bang out the monad.
00:13:43 <|Steve|> It allows you to reason about it because you understand things about categories or functors.
00:13:48 <Cale> glguy: That's the funny thing about category theory, is that it generally helps lead you to the right definitions in new contexts
00:14:11 <Cale> But there are not that many interesting results strictly within category theory.
00:14:20 <wli> glguy: "There's a monad somewhere in here" ---> CT tells you where.
00:14:22 <quicksilver> incidentally, any particular monad will arise out of many different adjunctions
00:14:27 <Cale> I think you'd agree that the concept of a monad in Haskell is a really interesting thing.
00:14:59 <Cale> And it is in other contexts as well -- category theory just sets up a lot of nice language for talking about different things in the same way.
00:15:06 <ski> quicksilver : but up to equivalence of the categories or something like that, iirc ?
00:15:17 <wli> Cale: So is the trick to figuring out the monad finding the adjoint functors?
00:15:27 <quicksilver> ski: no, there are genuinely different ones, in general
00:15:32 <|Steve|> Heh. Finding adjoint functors is no fun.
00:15:37 <quicksilver> ski: in fact, a whole category of adjunctions
00:15:47 <quicksilver> ski: the kleisli is one 'extreme' in that category
00:15:50 <|Steve|> Even things like, "Show that ____ is the left adjoint of _____" are a pain in the ass.
00:15:56 <Cale> wli: I'm not yet sure about that -- it's not clear to me that every monad arises out of some pair of adjoint functors.
00:16:03 <quicksilver> ski: and the eilenberg-moor (sp?) is the other
00:16:11 <ski> quicksilver : ok
00:16:14 <quicksilver> Cale: it does
00:16:17 <Cale> However, I wouldn't be *terribly* surprised if it were actually true
00:16:23 <Cale> quicksilver: oh?
00:16:32 <quicksilver> Cale: (many, including the kleisli as one easy-to-construct example)
00:16:32 * wli tries to figure out where he got the continued fraction code he based his stuff on from.
00:16:38 <ski> (i misremembered 'extreme' with 'unique', i think :)
00:16:44 <Cale> quicksilver: ah, okay
00:16:54 <Cale> quicksilver: that's a boring example though :)
00:16:57 <Cale> hehe
00:16:59 <glguy> I thought I saw mention that category theory attempts to draw parallels between different branches of math, allowing you to prove things in one branch using techniques from another
00:17:22 <Cale> hmm, how would I express what a non-boring example would be :)
00:17:38 <quicksilver> true enough :)
00:17:43 <quicksilver> glguy: yes, exactly
00:18:05 <ski> quicksilver : hm, is this related to Kan extensions ?
00:18:13 <quicksilver> glguy: almost everything is a category. So you take a result in one branch of maths and you say "what requirements on the category do we need to prove this results"
00:18:39 <quicksilver> glguy: and then you look around in other brnaches on maths, and if the categories there fulfill the requirements, they have an anlogue of the same result
00:18:56 <quicksilver> for example, most of the 'compactification' proofs in topology are adjoints
00:19:08 <quicksilver> and can be viewed as an application of one of the adjoint functor theorems
00:19:08 <|Steve|> I think usually people have proven the results in the other branches of math and then they are later unified.
00:19:25 <reffie> i officially hate x11
00:19:26 <|Steve|> At least, that was what my algebra prof who taught me CT said.
00:19:40 <quicksilver> yes, usually that's the ortder it happens
00:19:42 <reffie> i'm unable to draw stuff :(
00:19:59 <glguy> reffie: I don't see the connection here :)
00:20:08 <quicksilver> ski: IIRC there are lots of adjoint in Kan extensions. But my CT course stopped before we got there...
00:20:21 <reffie> glguy i'm unable to draw stuff on windows
00:20:26 <reffie> and i have no idea wtf is wrong
00:20:38 <ski> quicksilver : sorry . 'this' referred to 'kleisli' and 'eilenberg-moor'
00:21:06 <RyanT5000> so... is there any way to deal with GC between the GHC runtime and something else?
00:21:08 <glguy>  ?remember ski quicksilver : sorry . 'this' referred to 'kleisli' and 'eilenberg-moor'
00:21:17 * ski grins
00:21:35 <ski> (you need to remove that space if you want it to have effect)
00:22:03 <Cale> Ah, so the adjunctions from which a particular monad arises themselves form a category, where the Kleisli construction is an initial object, and the Eilenberg-Moore construction is a terminal object.
00:22:14 <Cale> I suppose my question is when there would be others :)
00:22:27 <ski> interesting
00:22:57 * glguy wonders if people open their web browsers and first think "hmm, I wonder how I could figure out what Haskell is useful for" before they inject some narcotics and conclude "I'll ask the well informed general populus of reddit: http://programming.reddit.com/info/2bxc1/comments"
00:23:26 <quicksilver> ski: Kan extensions are a generalisation of all that stuff
00:23:41 <quicksilver> ski: there is a famous saying "*All* concepts are Kan extensions"
00:24:32 <quicksilver> Eugenia cheng is a good resource for medium-advnaced category theory
00:24:35 <quicksilver> http://math.unice.fr/~eugenia/winter06/
00:24:36 <lambdabot> Title: winter06
00:25:20 <quicksilver> she provided model answers for the exercises when I stuided this stuff...
00:25:35 <ski> quicksilver : ty
00:25:54 <Cale> "When specialised to posets, it becomes a relatively familiar type of question on 'constrained optimization'."
00:25:58 <Cale> That's cool :)
00:27:27 <RyanT5000> how hard would it be to add something like ForeignGCPointer that knows how to enumerates all the haskell objects it contains?
00:28:01 <RyanT5000> i assume it would require modifications to the GC
00:29:12 <Cale> I should get hold of the Handbook of Categorical Algebra. It sounds good :)
00:30:27 <glguy> -- The SWORDS robots, armed with M249 machine guns, "haven't fired their weapons yet," an Army official says. "But that'll be happening soon."
00:30:32 <glguy> (from slashdot)
00:31:01 <glguy> first thing I though was "looks like someone's enemies are going to have M249 machine guns of their own soon"
00:31:35 * ski would like to get a hold of "Mathematics made difficult"
00:31:35 <RyanT5000> glguy: how, in particular?
00:31:58 <glguy> RyanT5000: seems like sending a robot out with a gun is a good way for the enemy to capture and use that gun
00:32:02 <Cale> The course notes linked from that page seem really useful.
00:32:33 <RyanT5000> glguy: maybe; that depends a lot on how autonomous it is
00:32:58 <RyanT5000> glguy: if it is highly autonomous, then it probably won't be any easier to get its guns than to get a soldier's guns
00:33:04 <ski> http://www.amazon.com/Mathematics-made-difficult-Carl-Linderholm/dp/0529045524
00:33:07 <lambdabot> http://tinyurl.com/3dzfsp
00:33:08 <RyanT5000> glguy: if it isn't then maybe a jamming attack would work
00:35:00 <roconnor> If you liked this book, you may also enjoy ``A Mathematician's Apology''  by G. H. Hardy
00:37:19 <Cale> If you only counted linuxer's points on reddit with respect to me, I think it'd be at around -900 points.
00:37:45 <glguy> linuxer is a bot, right?
00:37:48 <Cale> I think so
00:38:27 <Cale> maybe slightly human assisted, but it makes so few comments that I have a hard time believing whoever is behind it is even looking at what's being posted.
00:38:45 <Cale> (maybe just the scores)
00:38:57 <RyanT5000> is there a reasonable way to find out what changed when Weak pointers were added to haskell's GC?
00:40:48 <RyanT5000> (i mean find the specific patch in DARCS that added Weak pointer support)
00:41:02 <RyanT5000> i want to see how complicated a change like i'm thinking about would be
00:46:20 <blackdog_> hey, why is it that when i build my cabalised app with "runhaskell ./Setup.hs build" i get "/usr/bin/ld: cannot find -lHSghc_p" while "ghc --make Main.hs -prof -auto-all" works fine?
00:46:22 <tuxplorer> For making a haskell program use C or some other functions, FFI is there. But is there a way to make a function in Haskell and embed it into a C program?
00:46:55 <blackdog_> i assume it's looking for profiling libraries, and they don't seem to be there, but why does ghc --make work?
00:48:18 <Cale> tuxplorer: FFI helps with that too
00:48:40 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-140003.4
00:48:41 <lambdabot> Title: 3 Foreign Declarations, http://tinyurl.com/yezf7t
00:49:48 <Cale> However, I think you have to initialise the Haskell runtime system on the C side for things to work properly...
00:50:34 <Cale> aha, yes
00:50:47 <Cale> void hs_init     (int *argc, char **argv[]);
00:50:47 <Cale> void hs_exit     (void);
00:50:47 <Cale> void hs_set_argv (int argc, char *argv[]);
00:50:47 <Cale>  
00:50:47 <Cale> void hs_perform_gc (void);
00:50:48 <Cale>  
00:50:50 <Cale> void hs_free_stable_ptr (HsStablePtr sp);
00:50:52 <Cale> void hs_free_fun_ptr    (HsFunPtr fp);
00:50:54 <ari> @map
00:50:54 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
00:50:57 <Cale> Those are found in HsFFI.h
00:51:29 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise6.html#x10-390006 -- just past the long tables
00:51:30 <lambdabot> Title: 6 C-Specific Marshalling, http://tinyurl.com/2e6gwx
00:52:34 <Cale> blackdog_: Hmm, I'm not sure. Which package are you building?
00:53:11 <Cale> hmm, that's sad, the HaskellUserLocations map is gone
00:53:25 <Cale> http://www.haskell.org/haskellwiki/HaskellUserLocations
00:53:26 <lambdabot> Title: Haskell user locations - HaskellWiki
00:53:26 <Cale> ah
00:54:23 <Cale> Someone needs to regenerate the images though.
00:55:12 <blackdog_> Cale: my own one - it was building fine, then i added -prof -auto-all to my ghc-options
00:55:42 <Cale> blackdog_: Funnily enough, I don't seem to have that library file either.
00:55:50 <blackdog_> it's just a bit confusing - i can add the profiling libs, but i'm curious as to what ghc's doing when i just do ghc --make...
00:59:57 <Saizan> blackdog_: have you tried runghc Setup configure -p ?
01:00:22 <Saizan> instead of ghc-options: -prof -auto-all
01:04:01 <blackdog_> Saizan: now I have. Thanks. :)
01:12:42 <blackdog_> hm, actually no that didn't help. if i leave off --enable-executable-profiling, it won't take -prof flags, and if i don't it won't build
01:13:00 <blackdog_> *sigh* this is not the most fun way of spending a friday night ever.
01:13:30 * blackdog_ knows he is being a whiny little b****
01:13:45 * wli is just clueless.
01:14:37 <wli> Hmm, there is a monad for output (MonadWriter), but not an obvious one for input.
01:15:41 <dolio> I think there's one on the wiki.
01:16:14 <wli> What's it called?
01:16:34 <dolio> I'm searching, trying to remember.
01:16:40 <dolio> MonadSource or something.
01:17:10 <dolio> Oh, MonadSupply.
01:17:18 <wli> There's a domain squatter sitting on monadsource.com
01:18:21 <dolio> http://haskell.org/haskellwiki/New_monads#MonadSupply
01:18:22 <lambdabot> Title: New monads - HaskellWiki
01:18:29 <wli> Yeah, I found it.
01:18:39 <wli> Looks like exactly what I want.
01:23:59 <blackdog_> wli: that's awesome. you know haskell's blowing up when it's worth squatting related names...
01:24:32 <wli> blackdog: Haskell's been trying to blow up for a while. There was a buzz a while back about it becoming the next Visual Basic(!).
01:25:13 <arcatan> lol
01:25:52 <shachaf> Well, Monad is Microsoft's new shell, I think.
01:26:00 <osfameron> was an early codename for it
01:26:01 <arcatan> it
01:26:01 * shachaf knows very little about it.
01:26:04 <osfameron> it's now "powershell"
01:26:12 <arcatan> damn you enter, you win this time!
01:26:33 <kilimanjaro> wli, the next Visual Basic??
01:26:36 <tuxplorer> Cale: Thanks.. I'll try that
01:26:50 <wli> kilimanjaro: This was pre-2000 IIRC.
01:27:14 <kilimanjaro> wli, ahh, I thought maybe you were trying to scare off people to Clean or something :)
01:27:40 <kilimanjaro> (yes, I know what you meant by that comment, I'm just teasing)
01:27:41 <wli> Clean would be more interesting if it weren't proprietary.
01:29:53 <sorear> Uh...
01:30:32 <earthy> uhm. proprietary?
01:30:34 <earthy> what?
01:30:38 <osfameron> Clean is also rather ungooglable
01:30:48 <osfameron> especially as "Clean Language" is also overloaded...
01:31:04 <earthy> yeah
01:31:26 <osfameron> ah, "clean programming" is less overloaded (though "clean language" is part of NLP which includes "programming")
01:31:43 <sorear> I could just google Clean <name of implementor> ... no wait I can't spell in North European languages :)
01:31:52 <earthy> but, these days, clean is available under the GPL, so I wouldn't really call it 'proprietary' anymore
01:32:10 <earthy> s/GPL/LGPL/
01:32:31 <wli> earthy: News to me, though I've not really been paying attention.
01:32:42 <earthy> that's been the case for 5 years already!
01:32:57 <osfameron> : it is available under the terms of the GNU LGPL, and also under a proprietary license for â‚¬75. http://en.wikipedia.org/wiki/Clean_(programming_language)
01:32:57 <kilimanjaro> earthy, yea, he hasn't been paying attention for the past 5 years
01:33:15 <wli> earthy: I've not been paying attention for a period of time that is longer than 5 years.
01:33:16 <earthy> (true, in the middle of the nineties they had this wild-eyed plan for commercialising clean... that came to nothing ;))
01:33:47 <earthy> (didn't surprise me one bit... you couldn't even read a directory programmatically at that point ;))
01:36:54 <wli> I think the last time I looked at or thought about Clean was before 2000.
01:37:00 <blackdog_> i wonder - is there any particular reason the Clean guys decided to go their own way? Surely the uniqueness type stuff could have been done as an extension
01:37:21 <wli> NIH syndrome.
01:37:40 <blackdog_> i mean, they seem to have done a shitload of cool work. it'd be really nice to have that under the one banner.
01:37:46 * blackdog_ is utopian
01:39:04 <earthy> okay, Clean already existed and did useful stuff before Haskell came to be
01:39:18 <earthy> back in the late '80's, early '90's
01:39:36 <earthy> plus, Clean (at that time) had native support for transputers and multiprocessing
01:39:51 <wli> Hence "Concurrent Clean"
01:39:55 <earthy> exactly
01:40:08 <earthy> pretty cool stuff, actually
01:40:33 <earthy> but the investments were such that 'redoing' it in haskell was deemed too costly
01:40:57 <earthy> especially given the idea of commercialising clean and reforming the business programming market
01:41:32 <earthy> ofcourse, the clean group did behave a bit like an ostrich, head down in the sand...
01:41:34 <kilimanjaro> has it had much commercial popularity? it's one thing to charge money for something, it's another thing to sell it
01:41:48 <earthy> it failed spectacularly, commercially. :)
01:42:41 <wli> My beliefs are such that commercialization is bad as I see it.
01:43:05 <kilimanjaro> yea I'm not sure of any popular commercial programming languages these days
01:43:19 <kilimanjaro> I guess in the 90s it was more frequent
01:43:33 <kilimanjaro> but for the past 6 years or so even microsoft gives away their compiler for free
01:43:38 <wli> All the dot bomb garbage.
01:43:53 <osfameron> there are commercial Lisps
01:43:58 <osfameron> oh, *popular*...
01:45:17 <quicksilver> I guess flash is a popular commercial programming language
01:45:27 <kilimanjaro> There is a commercial Scheme implementation, Chez Scheme. In my 2 years of hanging around in #scheme and reading newsgroups I have *never* heard of anyone actually using it commercially.
01:45:34 <quicksilver> in the sense that the dominant 'content-creation' application is commercial
01:45:35 <kilimanjaro> quicksilver, good point
01:45:44 <kilimanjaro> that's a pretty good example
01:45:51 <quicksilver> it does appear to be unusual though
01:45:51 <RyanT5000> the language itself is still fairly open
01:46:00 <quicksilver> yeah, the language is a standard, no less
01:46:11 <quicksilver> but for most people it's useless without the graphical timeline editor stuff
01:46:18 <RyanT5000> yeah
01:48:05 <RyanT5000> so now that we've had a bit of turnover since the last time i asked
01:48:20 <RyanT5000> any tips on integrating the Haskell GC with the SpiderMonkey GC?
01:48:44 <RyanT5000> basically, i have StablePointers that can circuitously point at themselves
01:49:07 <RyanT5000> they don't have to be StablePointers, but they have to be some kind of pointer-like thing
01:49:13 <RyanT5000> stored in a C structure
01:49:30 <RyanT5000> where that C structure is GCed by the SM GC
01:49:52 <RyanT5000> is there any way conceivably to mark things "through" another GC?
01:52:03 <quicksilver> I'm afraid the nmber of people who really understand the GC is a bit small :( JaffaCake and Igloo are your best bets.
01:52:18 <RyanT5000> quicksilver: thanks; that information alone will be very helpful
01:53:19 <JaffaCake> RyanT5000: StablePtrs to point into the Haskell heap, and ForeignPtrs to point out of it
01:54:00 <RyanT5000> JaffaCake: right, but the problem is that i have two invariants i want to keep that are making cycles for me
01:54:32 <RyanT5000> (1) If a Haskell-land handle to a JS Object is alive, then that JS Object is alive
01:54:58 <RyanT5000> (2) If a JS-land pointer to a Haskell object is alive, then that Haskell object is alive
01:55:07 <JaffaCake> ok, cycles are indeed a problem
01:55:28 <RyanT5000> each JS object can contain a haskell object
01:55:37 <RyanT5000> which normally i would just chuck in a stablepointer
01:55:40 <JaffaCake> I can't remember if there are any good solutions to that, but I'm sure someone has thought about it
01:56:01 <RyanT5000> i can make it work, but only leakily
01:56:23 <RyanT5000> by just doing the naive thing: adding reference-counted roots in the JS GC
01:56:30 <RyanT5000> then at least objects stay alive when they should
01:56:34 <RyanT5000> they just never die if there's a cycle
01:57:32 <RyanT5000> i think i need something like a ForeignGCPtr
01:57:37 <JaffaCake> won't the normal stableptr/foreignptr method work?  except that it won't GC cycles, I mean
01:57:51 <RyanT5000> yeah, it would work except cycles
01:59:01 <RyanT5000> i somehow need to coerce the haskell GC into going through the JS data or something
02:00:07 <quicksilver> can you arrange an haskell 'shadow' of every single JS object?
02:00:18 <quicksilver> then you've got a "real picture" of everything in haskell land
02:00:21 <quicksilver> sounds expensive though
02:00:26 <RyanT5000> quicksilver: possibly
02:00:28 <RyanT5000> yeah
02:00:40 <RyanT5000> especially since i'd have to hook *every* data update function in JS
02:00:51 <RyanT5000> which sounds like it would more than double my running time
02:00:58 <quicksilver> I'd have thought you'd only have to hook every 'new object creation' functon
02:01:05 <RyanT5000> JS isn't pure ;)
02:01:12 <RyanT5000> that's what i initially thought of too
02:01:17 <RyanT5000> but then i realized i wasn't in a pure world
02:01:21 <RyanT5000> and i was sad :(
02:01:25 <RyanT5000> lol
02:01:26 <quicksilver> I'm not sure that matters
02:01:34 <quicksilver> IORefs are wellbehaved haskell objects
02:01:41 <quicksilver> even though the thing they 'point' to can change
02:02:09 <RyanT5000> right, but i'd have to have like an IORef containing a list of all the children of every object
02:02:12 <RyanT5000> (or a Set or whatever)
02:02:31 <RyanT5000> and then add/remove them whenever any slot in the object gets updated, right?
02:02:50 <quicksilver> I don't quite know enouh about the JS memory model :)
02:03:12 <RyanT5000> from what i can tell it's similar to python's
02:03:21 <RyanT5000> an object is effectively a glorified dictionary
02:04:58 <RyanT5000> i'm really close to just giving up and saying it's up to the user to not have cycles
02:05:08 <RyanT5000> even though that's a total pain in the ass for interoperability
02:05:36 <RyanT5000> (i was hoping to yield interoperable objects nearly automatically from haskell objects)
02:07:50 <rubyruy> is there a way to get the source-inference-magic-box to annotate a .hs sourcefile ?
02:08:13 <RyanT5000> source-inference-magic-box?
02:08:33 <wli> RyanT5000: What's this? GC?
02:09:02 <RyanT5000> wli: yeah, i'm trying to get spidermonkey's and haskell's GCs to work together properly
02:09:28 <wli> oh dear
02:09:30 <osfameron> yay archive.org has smaller versions of the SICP videos
02:09:31 <RyanT5000> wli: spidermonkey's GC is in charge of javascript objects; but each javascript object can contain a haskell object
02:09:38 <Cale> rubyruy: type inference? Apart from copying and pasting type signatures from GHCi, I don't know of anything which does that.
02:09:43 <osfameron> 50Mb is rather nicer than 1.7G per episode
02:09:46 <rubyruy> shoot s/source/type
02:10:13 <RyanT5000> wli: the problem, i think, is the utter lack of hooks of any kind in the haskell GC
02:10:15 <Cale> osfameron: The higher quality ones do make it easier to read the blackboard though
02:10:18 <rubyruy> right so it could basically just be a script that looks for functions without type signatures, looks them up with :t, then puts them back :p
02:10:36 <Cale> rubyruy: yeah
02:10:50 <Saizan> i think someone has written it
02:11:17 <Saizan> one problem is that ghci sometimes gives signatures that wouldn't work in your code
02:12:02 <Saizan> because some types are not in scope
02:12:04 <RyanT5000> wli: what i really need is a type ForeignGCPointer that can return a list of reachable objects or something
02:12:43 <osfameron> Cale: ah, yes... hmmm.  Well I downloaded the 500Mb divx of 1a and then the next few as tiny files, I'll compare and then think about it
02:20:30 <RyanT5000> alright, i think this bug is becoming not-a-bug via documentation
02:20:58 <RyanT5000> because i can't imagine a time when someone would actually *want* to construct a cycle of objects
02:22:17 <Saizan> a circular list!
02:22:43 <Cale> That's strange, a qwe1234 comment that can be seen as defending Haskell.
02:23:21 <RyanT5000> Saizan: also, cycles of object could be constructed using either just-haskell or just-js
02:23:22 <Cale> RyanT5000: tying the knot?
02:23:40 <RyanT5000> Cale: it's only a cycle that passes through both haskell and js objects that causes a problem
02:23:46 <Cale> ah
02:24:39 <RyanT5000> my choices for implementation are (1) each GC always throws away the other's stuff (2) neither GC ever throws away the other's stuff
02:24:49 <RyanT5000> (1) will clearly never work
02:25:12 <RyanT5000> (2) will only leak memory, and only when there's a cycle
02:27:07 <quicksilver> or (3) unify the GCs
02:27:11 <quicksilver> which is presumably hard work
02:29:31 <osfameron> eeeeek!  15 mins into sicp lecture he's talking about fix!
02:31:13 <roconnor> @what sicp
02:31:13 <lambdabot> http://mitpress.mit.edu/sicp/
02:31:15 <opqdonut> nice
02:31:26 <RyanT5000> quicksilver: right
02:32:00 <eivuokko> How can I make haddock as run via Cabal, *not* reference base etc other packages?
02:54:49 <Cale> "This is what 144 looks like in bits: 0100000001100010000000000000000000000000000000000000000000000000"
02:54:54 <Cale> What?!
02:55:14 <Cale> That's from the recently posted interactive JavaScript tutorial
02:56:16 <Eelis> that's crazy talk
02:56:58 <shachaf> Cale: In what sense?
02:57:00 * quicksilver tries to work out an interpretation for that
02:57:01 <gkr> Near...
02:57:20 <Cale> shachaf: It doesn't appear to say.
02:57:25 <DRMacIver> Is it possible that's the representation as a double?
02:57:30 <shachaf> It's a puzzle!
02:57:48 <DRMacIver> All numbers in JS are doubles after all.
02:57:57 <gkr> It's 64
02:58:00 <gkr> (length)
02:58:02 <gkr> So it might be.
02:58:03 <dnox> Cale: is mbot dead now?
02:58:24 <shachaf> Cale: Oh, do you run mbot?
02:58:28 <Cale> shachaf: yeah
02:58:28 <DRMacIver> gkr: Thanks. I couldn't be bothered to count. :)
02:58:42 <dnox> Cale: btw mathematica 6.0 got pretty cool new features
02:58:43 <shachaf> Cale: You know dons may be looking for a temporary host for lambdabot?
02:58:48 <shachaf> Cale: Unless I misunderstood.
02:59:08 <Cale> shachaf: Yeah, I sometimes use mbot in here when lambdabot is away.
02:59:35 <Eelis> i chcked. it's indeed 144 as a double.
02:59:38 <Eelis> *checked
02:59:59 <quicksilver> really? how does that work?
03:00:05 <gkr> LSB?
03:00:09 <quicksilver> 144 looks like this : 1001000
03:00:23 <quicksilver> I don't even see that as a substring
03:00:34 <Eelis> quicksilver: http://en.wikipedia.org/wiki/IEEE_754
03:00:35 <lambdabot> Title: IEEE 754 - Wikipedia, the free encyclopedia
03:00:56 <DRMacIver> Eelis: Sigh. Now I'm going to have to read that. You've made me go and *learn* something.
03:00:59 * DRMacIver glares accusingly.
03:00:59 <dnox> no it aint cause a double dont got a fixed amount of digits
03:01:03 <Eelis> :(
03:01:19 <Eelis> dnox: its IEEE 754 representation does have a fixed amount of binary digits
03:02:39 <dnox> eelis: thats just one implementation, c++ got another and probably other stuff got theirs
03:03:25 <Eelis> dnox: C++ implementations don't implement floating point arithmetic in software, they just use the hardware, and the hardware is virtually always IEEE 754
03:04:13 <quicksilver> dnox: eelis was speaking in shorthand. What we was saying is 'that is indeed 144 as a 64bit IEEE 754 double'
03:04:23 <apfelmus> Hi Cale :)
03:05:02 <Eelis> and the shorthand was justified because by far most modern machines use IEEE 754 representation :)
03:05:13 * DRMacIver gets about a quarter of the way through the article before getting the urge to kill himself. Learning averted. :)
03:05:23 <Cale> apfelmus: hello
03:05:25 <shachaf> DRMacIver: Article?
03:05:49 <dnox> Eelis: "most"? in #c++ when someone says something that just applies in most cases you start bitching about undefined behaviour and stuff
03:06:02 <dnox> or implementation defined
03:06:13 <apfelmus> Cale: I heard that you've been discussing the Monad chapter(s) in the wikibook with Kowey
03:06:25 <Cale> Um...
03:06:34 <Cale> I might replace it at some point.
03:06:38 <Eelis> dnox: i don't think this channel is a good place for me to respond to accusations about previous cases in ##c++, a channel i don't even frequent anymore
03:06:43 <Cale> I think I might have had a brief talk about it
03:06:51 <JBGood25> ahh 2^(010000000110_2-001111111111_2)*1.001_2
03:07:37 <DRMacIver> shachaf: The wikipedia article.
03:07:39 <dnox> Eelis: probably best so
03:07:41 <apfelmus> Cale: Ah :) I too think that it needs an overhaul.
03:07:53 <apfelmus> Actually, I intended to start overhauling right now
03:07:55 <shachaf> DRMacIver: Oh.
03:08:00 <Cale> apfelmus: Ah, cool
03:08:08 <Cale> apfelmus: Have you seen my recent tutorial?
03:08:25 <dnox> Cale: url?
03:08:28 <apfelmus> yes
03:08:43 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
03:08:44 <apfelmus> it's good :)
03:08:45 <lambdabot> Title: Monads as computation - HaskellWiki
03:09:40 <Cale> I was sort of considering the idea of just putting that into the wikibook wholesale :)
03:10:01 <Cale> It probably deserves a more detailed expansion in places though.
03:10:10 <Cale> and discussion of more particular monads
03:10:24 <Cale> Like, a section on the list monad, and one on the state monad.
03:10:40 <apfelmus> :) yes, it seems to assume some prior knowledge about monads
03:11:43 <apfelmus> to me, it looks like there's a gap between the end of section 1 and the beginning of section 2
03:11:53 <Cale> I'd sort of hoped that it would work at least somewhat for people with no experience, even if it didn't get them to the point of writing their own monadic code.
03:12:16 <Cale> It's more a philosophy of monads set-up piece :)
03:12:33 <apfelmus> Indeed :)
03:12:52 <Cale> To turn it into a concrete tutorial, it needs more practical information :)
03:14:21 <apfelmus> in other words, it doesn't include any concrete monad
03:14:55 <Cale> Yeah, it's got a bit of an IO blurb, and a half-hearted attempt to show a parser :)
03:14:58 <ndm> has anyone got the slides for SPJ's OSCON STM talk
03:15:16 <ndm> http://www.blip.tv/file/317758/ - this one
03:15:19 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones
03:15:20 <ndm> i can follow the talk without slides, but the graphs would be interesting, but the video doesn't show them at all
03:16:25 <shachaf> @wiki Video presentations
03:16:25 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
03:16:30 <shachaf> ndm: They're on that page.
03:16:45 <osfameron> yeah, the oscon videos are great quality but unedited, which sucks
03:17:00 <ndm> shachaf: i can see the video, but i want the slides, i can't see them on that page
03:17:19 <shachaf> ndm: Third link, "slides", last time I looked.
03:17:22 * shachaf checks again.
03:17:40 <shachaf> ndm: Still there.
03:17:40 <ndm> shachaf: thats the taste of haskell one, i want the transactional memory one
03:17:45 <shachaf> ndm: Oh.
03:17:50 <shachaf> ndm: Sorry, never mind.
03:17:55 * shachaf missed a word.
03:18:02 <ndm> hehe, thanks for trying anyway
03:18:14 <ndm> i dislike videos of talks which skip the slides
03:18:15 <shachaf> The STM one is probably next on my watching list.
03:18:59 * shachaf likes the interface that some videos on... Was it infoq.com? Have.
03:19:23 <shachaf> They show the slides together with the video, as a Flash applet.
03:19:35 <ndm> yeah, i've seen that one
03:19:36 <shachaf> (Of course I prefer not to use Flash at all, normally.)
03:19:52 <ndm> shachaf: don't watch the STM one from OSCON, watch the one on MS's Channel 9
03:20:15 <ndm> much more detail, plus you get to hear the phrase "building a skyscraper out of bannana's"
03:20:38 <shachaf> ndm: That's the older one?
03:20:59 <ndm> shachaf: yes
03:21:04 <shachaf> ndm: Someone had sent me a link to it before, but I'd lost it. Thanks. :-)
03:21:18 <apfelmus> Cale: let's see. I think I'll start rewriting the wikibook monads right now, eventually taking some parts of your tutorial.
03:21:21 <ndm> the second in the list
03:21:29 <Cale> apfelmus: cool
03:21:51 <Cale> apfelmus: I'll have a look after and discuss and edit :)
03:22:18 <apfelmus> that's what I've hoped for :D
03:23:56 <apfelmus> <advertisment>#haskell-books is dedicated to tutorial/book-writing discussions </advertisment> ;)
03:24:21 <shachaf> apfelmus: I've been there before, but it takes an extra window in irssi.
03:24:44 <shachaf> apfelmus: And I already have 22 open, and not enough keybindings to get to all of them.
03:26:12 <apfelmus> hm, you could buy a second keyboard ;)
03:26:29 <shachaf> apfelmus: Or just make some more keybindings.
03:26:40 <shachaf> Only alt-1 through alt-o is bound by default.
03:27:11 <apfelmus> you can also use a mouse... unless your cat ate it :)
03:27:23 <shachaf> apfelmus: A mouse? In irssi?
03:27:33 <pastorn> ndm: VERY annyoing how you don't see the code he has as examples...
03:27:53 <ndm> pastorn: more annoying for the graphs, i could guess the other bits, and have seen similar code before
03:28:37 * pastorn hasn't
03:28:53 <pastorn> but it's a cool introduction for paralell programming :)
03:29:32 <apfelmus> shachaf: ah, it's command line. I'm a spoiled MacOS child :)
03:30:06 <shachaf> apfelmus: I could run a GUI IRC client, but I don't. :-)
03:30:22 <quicksilver> there are other ways to get to windows though
03:30:34 <quicksilver> Meta-A for recent activity
03:30:42 <quicksilver> simply /win goto #haskell-books
03:30:48 <quicksilver> for seldom used channels
03:30:51 <shachaf> quicksilver: Oh, so that's what it does. :-)
03:30:51 <pastorn> ndm: heh, he got to the graphs now...
03:31:04 <pastorn> "here's the one slide i'd like you to remember"
03:31:13 * shachaf occasionally presses that accidentally and wonders what happens.
03:31:26 <shachaf> quicksilver: Thanks, that's useful. :-)
03:31:45 <shachaf> quicksilver: /win goto (or any / command) is too long.
03:31:56 * quicksilver shrugs
03:32:00 <quicksilver> it's a compromise
03:32:03 <quicksilver> depends how often you go there
03:32:08 * int-e has some windows with several channels in them
03:32:16 <quicksilver> I can type /win goto #haskell-books in about 3 seconds
03:32:29 <quicksilver> that's not a very long time :)
03:32:38 <quicksilver> but I try to /win move frequently used channels into the top 19
03:32:44 <shachaf> quicksilver: I remember sorear said he aliased it to /wg.
03:32:55 <shachaf> quicksilver: And there's tab completion, and it works with window numbers.
03:32:59 <shachaf> quicksilver: But still.
03:33:02 * earthy tries to keep to 19 channels at most
03:33:28 <shachaf> I'm glad to see I'm not alone in this, at least. :-)
03:34:41 <ski> '/win goto' ?
03:35:00 <ski> are you saying all this time i've been using '/window' i've been wrong ?
03:36:03 <int-e> /window requires a window number
03:36:18 <rubyruy> is there any sort of string interpolation with haskell?
03:36:29 <rubyruy> as in "my name is #{name}" ?
03:36:33 <quicksilver>  /win is short for /window in either context
03:36:41 <rubyruy> or must it always be "my name is "++name ?
03:36:42 <Cale> rubyruy: I usually just use concat [...]
03:36:46 <quicksilver> rubyruy: well we have a printf, but it's not very idiomatic haskell
03:36:50 <rubyruy> poo :(
03:36:51 <quicksilver> rubyruy: I would normally just use concat
03:37:00 <wli> Using an MVar as a lock is just lock = flip putMvar () and unlock = takeMVar?
03:37:11 <Cale> Also, unwords is nice when you also want spaces :)
03:37:12 <quicksilver> concat ["my name is ",name," how are you"]
03:38:03 <int-e> wli: or vice versa.
03:39:04 <int-e> wli: I prefer using takeMVar for taking a lock. :)
03:39:38 <earthy> quicksilver: that assumes 'name' to be of type string though. :)
03:40:30 <xerox> If some MVar must always containing things, is it sane to use readMVar and swapMVar to change its contents concurrently? Or should one use a pair of them, one as a lock, and the other for the value?
03:42:04 <xpika> the oscon videos dont show enough
03:42:22 <xerox> Oh wait, I think I see it now. One thread takes it, and it becomes empty, and now it does its thing and puts. One just needs to do takeMVar in the others before any putMVar.
03:42:39 <int-e> xerox: I'd discourage using readMVar (which is really just a takeMVar followed by putMVar)
03:42:54 <Cale> xpika: I found that it was nice in the ToH videos to have the slides open alongside the video.
03:43:12 <quicksilver> earthy: I still find it cleaner than string interpolation though
03:43:18 <earthy> yup
03:43:21 <earthy> true enough
03:43:27 <quicksilver> although if I was doing a *lot* of interpolation I might be motivated to write a template minilanguage
03:43:33 <xerox> int-e - Right.
03:43:38 <earthy> I like the HTML approach to that
03:43:53 <earthy> Text.Html and Text.XHtml
03:46:26 <RobHu> I remember reading something (maybe in Dr Dobbs journal?) that argued that with the multicore future languages like C/C++ were going to become less significant and would be replaced with languages where the compiler could more easily auto parallelise the code. Does anyone know of any such articles?
03:47:14 <xerox> RobHu: <http://haskell.org/haskellwiki/Video_presentations> Nested Data Parallelism :-)
03:47:50 <RobHu> thats cool
03:48:07 <RobHu> but ideally I'd like a paper, ideally something in a journal like Dr Dobbs
03:48:22 <RobHu> I'm already convinced, it's to convince someone else who I don't think will watch a 1.5 hr presentation
03:57:40 <Cale> RobHu: Well, there are certainly papers to back up that talk about NDP
03:57:51 <RobHu> NDP?
03:57:58 <Cale> RobHu: Nested Data Parallelism
03:58:30 <Cale> It'll be in the next GHC, I think.
03:59:18 <xerox> Cale: yeah, it works in today's GHC 6.7 :)
03:59:39 <Cale> http://research.microsoft.com/~simonpj/papers/ndp/NdpSlides.pdf -- here are just the slides from the talk :)
03:59:54 <xerox> ndm: -^
04:01:09 <RobHu> I need something that says: In the future we'll have lots and lots of cores not just one that runs fast, we want to easily take advantage of these cores, existing languages like C can't do this easily because ____, so what we need are languages with these properties like ____
04:01:21 <Cale> xerox: He wanted the STM slides :)
04:03:22 <RobHu> Does anyone know of something like that? :P
04:03:50 <RobHu> I looked at http://research.microsoft.com/~simonpj/papers/stm/STM-OSCON.pdf but that's not quite what I want
04:05:20 <ndm> xerox: close, but no luck
04:05:53 <Cale> er, but that might be what ndm wanted :)
04:06:01 <RobHu> STM looks like something that can be done in C too (am I wrong?)
04:06:16 <ndm> Cale: i think its a different talk, but close enough
04:06:31 <Cale> ndm: It's labelled OSCON :)
04:07:31 <int-e> RobHu: for certain values of 'can be done'.
04:07:42 <osfameron> RobHu: some people have tried to do similar things in Perl ( http://search.cpan.org/~dcantrell/Data-Transactional-0.1/lib/Data/Transactional.pm from a quick CPAN search )
04:07:49 <lambdabot> Title: Data::Transactional - data structures with RDBMS-like transactions - search.cpan ..., http://tinyurl.com/2wsqwe
04:08:45 <Cale> RobHu: The trouble there is in restricting what can be done in the context of a transaction
04:09:00 <DRMacIver> There was a C# implementation of some subset of STM floating around.
04:09:01 <Cale> (though that's certainly possible)
04:09:02 <ndm> i think it is, actually, perfect :)
04:09:18 <xerox>  Total number of ICFP subsequences: 3451  real    0m15.272s user    0m15.133s sys     0m0.056s
04:09:41 * xerox plays with endo.dna and parsec bytestring ;)
04:10:04 <mux> you can implement STM for many languages but it'll be hard to make it so you cannot mix IO actions and STM actions, as is guaranteed in haskell
04:10:05 <osfameron> Cale: yeah, the fact that haskell's type system knows if there are going to be side-effects does kind of make this easier to implement...
04:10:43 <Cale> You really don't want general I/O inside an atomic block.
04:10:54 <Cale> (because it might have to be rolled back at any point)
04:11:31 <osfameron> are the STM critiques at http://patricklogan.blogspot.com/2007/02/misguided-road-not-to-be-travelled.html well founded?
04:11:33 <lambdabot> Title: Making it stick.: Misguided: The Road Not To Be Travelled, http://tinyurl.com/2n7gbd
04:11:50 <RobHu> ok thanks guys. I'll bomb him with these links ;-)
04:12:14 <olliej> ndm: ping?
04:12:21 <ndm> olliej: pong
04:12:25 <RobHu> Tim Sweeney's presentation at the Symposium on Principles of Programming Languages 2006 is useful too, especially the slide "The genius of Haskell"
04:12:50 <olliej> ndm: what would the license be on the core files produced by running the ghc libs through ghc? bsd?
04:14:23 <ndm> olliej: probably, but thats entirely not up to me
04:14:41 <Cale> osfameron: most of the negative things I've seen written about STM were written by people who clearly don't actually understand it
04:14:44 <quicksilver> same license as the original source
04:15:52 <osfameron> Cale: well, I understand neither STM nor the critiques in any great detail :-)  (But I do get that a) STM sounds shiny, b) it feels "clever", which might or might not mean that it is susceptible to subtle and hard to diagnose bugs)
04:16:24 <Cale> osfameron: I think the best place to read about it is the paper.
04:16:32 <Cale> http://research.microsoft.com/~simonpj/papers/stm/stm.pdf
04:16:36 <quicksilver> its subtle in the same sense that database transactions are subtle
04:16:39 <Cale> (at least the first few pages)
04:16:51 <quicksilver> since 99% of DB programmers don't understand database transactions, and use them incorrectly...
04:16:58 <quicksilver> then perhaps those fears are justified :)
04:17:01 <osfameron> hehe, probable
04:17:18 <Cale> But still, we have lots of actually-working database applications.
04:17:22 <quicksilver> but on the other hand, transactional stuff is the right way to solve those problems
04:17:33 <quicksilver> the fact that its subtle appears to be impossible to sidestep
04:17:38 <quicksilver> it quite simply *is*
04:17:44 <osfameron> presuambly transactions and shared-nothing aren't completely mutually incompatible
04:17:51 <Cale> This whole 'shared-nothing' movement is kind of silly, because 'shared-nothing' really isn't.
04:18:02 <quicksilver> and STM seems to me to be a fairly simple expression of them
04:18:03 <osfameron> in that certain parts of an app could use one model and some the other
04:18:16 <Cale> It's a terrible term for message-passing concurrency.
04:18:25 <Cale> Passing messages is sharing data.
04:18:44 <Cale> You still have many of the same problems with composability.
04:18:50 <osfameron> Cale: it's maybe just a catchy way to say that they don't share the same data location at the same time?
04:18:59 <Cale> yeah
04:19:24 <osfameron> bah, the main problem of STM is that you need to use Haskell to take advantage of it...
04:19:33 <Cale> But you still have processes which send information about their local state to other processes.
04:19:38 <osfameron> s/the main/the most immediately obvious/
04:20:04 <osfameron> dammit, pdf sucks to read on a screen
04:20:17 <Cale> which means that you still have, for example, the bank account problem.
04:20:21 <osfameron> I want a pdf reader that knows about 2-column formatting and Does The Right Thing
04:20:24 <allbery_b> also note that the mechanisms that implement message passing must still deal with the same problems
04:23:01 <osfameron> ooo, nice comment from Tim Sweeney on the ltu thread "
04:23:09 <osfameron> "STM is the only productivity-preserving concurrency solution for the kind of problems we encounter in complex object-oriented systems that truly necessitate state, such as games."
04:25:28 <Cale> osfameron: Do you know what I mean by the bank account example?
04:28:56 <osfameron> Cale: yes, I've read the STM article briefly, so in overview
04:30:37 <Cale> In a message-passing system, you'll still have that sort of thing happening -- making it necessary to tear apart existing working processes in order to get them to behave together nicely.
04:30:48 <quicksilver> he's a fairly offensive chap, isn't he?
04:31:05 <Cale> Patrick Logan?
04:31:10 <quicksilver> yes
04:31:18 <osfameron> yes, I've neot played enough with concurrent systems to really *get* that in detail, but it sounds reasonable
04:31:43 <osfameron> and Sweeney's descriptions of that type of transaction in game world (who fires the bullet) seem clear enough
04:31:47 <Cale> Yeah. His article also became thoroughly incomprehensible as he kept mutating it as people replied in comments, rather than replying in comments himself.
04:32:06 <quicksilver> one of the things I don't like about blogs
04:32:06 <Cale> (Pat Logan's)
04:32:25 <quicksilver> is that everyone can produce an article which, because it 'looks pretty', gains some credibility
04:32:36 <quicksilver> that problem is in my head, really
04:32:45 <osfameron> that's not entirely true
04:32:52 <quicksilver> but I imagine I'm not the only reader who is 'inclined to believe' when it looks smart
04:32:55 <osfameron> they also have to be able to write and have an interesting topic
04:32:59 <Cale> I've almost completely stopped trusting the major news outlets. :)
04:33:21 <osfameron> also, the most interesting blogs tend to be recommended by people you know and trust, so it actually *is* possible to filter blogs
04:33:29 <quicksilver> of course
04:33:35 <quicksilver> and one should judge them like any other source
04:33:37 <osfameron> at least, (tohugh I could be deluding myself), I think that the blogs that *I* read are interesting...
04:33:40 <Cale> In 5 or 10 years, we'll probably be at the point that we just shouldn't accept anything outside our immediate field of view as even existing :)
04:33:46 <quicksilver> I'm just syaing it's a little too easy to trust them more than I should
04:33:48 <osfameron> who said that?!
04:33:51 <quicksilver> which could well just me my problem
04:34:27 <osfameron> yeah, that's why I asked aobut STM - I don't have enough background to know whether that critique is a) entirely valid, b) partly valid, c) hogwash...
04:34:41 <quicksilver> mixture of b and c
04:34:52 <quicksilver> tehre are certainly valid reasons to have misgivings
04:35:10 <Cale> osfameron: I think that anything it says which happens to be true is probably just chance.
04:35:34 <Cale> Since it became pretty clear that he hadn't even looked at the paper.
04:36:02 <osfameron> heh
04:36:09 <Cale> And had major failings in his understanding of the basic concept.
04:38:52 <osfameron> thinking about it, Perl 6's hypothetical "let" bindings are somewhat similar to STM and enshrined in the language
04:39:10 <osfameron> of course that doesn't give you any guarantee of side-effect atomicity, but that wouldn't really be the Perl way anyway :D
04:39:40 <Cale> osfameron: Perl 6 is really getting STM too.
04:39:50 <Cale> (apparently)
04:40:03 <Cale> I'm not sure how they're dealing with the side effects problem
04:40:12 <opqdonut> monadic perl
04:40:32 <osfameron> I don't think they *will* deal with it.  It's probably more Perlish to just let you shoot yourself in the foot if you really want to
04:40:44 <osfameron> but I haven't followed p6l for a bit...
04:44:15 <RobHu> hPutStr :: Handle -> String -> IO () ... We call any value of type IO t an Ã¢Â€ÂœactionÃ¢Â€Â. So (hPutStr h "hello")3 is an
04:44:19 <RobHu> action that, when performed, will print "hello" on handle4 h and return the
04:44:19 <RobHu> sorry
04:44:21 <RobHu> unit value.
04:44:23 <RobHu> oops
04:44:29 <RobHu> What is meant by the unit value?
04:44:39 <doserj> ()
04:44:46 <RobHu> ah ok
04:44:46 <Saul_> Anyone here with HAppS experience?
04:44:51 <RobHu> Thanks :)
04:45:14 <Saul_> The tutorial is really outdated, the 3 example doesn't work
04:45:20 <Saul_> and onward
04:45:31 <xerox> Saul_: there's also #happs.
04:45:52 <Saul_> xerox: Ok I'll ask there, thanks
04:46:03 <xerox> NP, best luck :)
04:47:27 <Cale> Does #happs have anyone in it which isn't also here? :)
04:48:05 <LoganCapaldo> Cale, shouldn't you ask that question in #happs? :)
04:48:12 <Cale> heh
04:48:13 <Saul_> Probably not, but there are fewer other conversations going on
04:48:31 <LoganCapaldo> Else you could get false negatives :)
04:48:43 <pastorn> how are type classes implemented? are they all on the same level or are they inhereted?
04:48:51 <ski> RobHu : also called the empty (or zero-) tuple
04:48:59 <Cale> pastorn: Dictionary passing...
04:49:05 <ski> jhc
04:49:24 <Cale> pastorn: Basically, if you have a function of type, say, (Ord a) => [a] -> [a]
04:49:24 <pastorn> Cale: now you're just trying to confuse me...
04:49:35 <quicksilver> pastorn: they're all in the same level
04:49:37 <Cale> pastorn: It gets turned into a function of type Ord a -> [a] -> [a]
04:49:49 <Cale> where Ord a is a record holding all the methods of Ord
04:50:02 <pastorn> oh...
04:50:03 <quicksilver> pastorn: although 'Eq' is a 'superclass' of Num
04:50:09 <LoganCapaldo> pastorn, there is inheritance sort of. e.g. to be an instance of Ord you also have to be an instance of Eq
04:50:13 <quicksilver> pastorn: all that means that is any Num instance must have an Eq instance
04:50:14 <ski> data Ord a = O {lessThan :: a -> a -> Bool,lesser :: a -> a -> Bool,...}
04:50:16 <Cale> Oh, perhaps I missed the actual question you were asking :)
04:50:27 <quicksilver> and they're passed seperately if needed
04:50:52 <Cale> Typeclasses don't do anything like inheritance, unless you count things like  instance Ord a => Ord [a] where ...
04:51:07 <Cale> (but that's different from OO-inheritance anyway)
04:51:18 <hpaste>  kfish pasted "Working version of HAppS tutorial 3.3 "Getting from a POST'd value"" at http://hpaste.org/2050
04:51:19 <LoganCapaldo> but you don't have to implement the code for Eq first, you could do instance Eq Foo where a == b = (a `compare` b) == EQ
04:51:34 <LoganCapaldo> So yeah its not really the same at all
04:52:28 <pastorn> that was a lot of answers...
04:52:31 <pastorn> gimme a minute...
04:52:38 <quicksilver> Cale: the Eq constrain on Num is 'like' inheritance
04:52:44 <quicksilver> Cale: at least, one way of looking at it
04:52:47 <Cale> A little bit :)
04:52:51 <quicksilver> Cale: and they're even called superclass
04:52:56 <ski> Cale : define inheritance :)
04:53:00 <quicksilver> in a sense it's the dual of inheritance
04:53:08 <ski> (hint : implementation or interface ?)
04:53:13 <quicksilver> it's an obligation to implement behaviour rather than inheriting the behaviour itself
04:53:17 <LoganCapaldo> Does that mean its coinheritance quicksilver?
04:53:34 <allbery_b> interface inheritance
04:53:47 <quicksilver> yes, it's like java interface inheritance
04:53:50 <ski> (coinheritance is for record types)
04:53:53 <LoganCapaldo> My comonads are coinheriting in my cohaskell program
04:53:54 <quicksilver> but you can also turn it around
04:53:56 <ski> er
04:54:05 <quicksilver> you can write generic instances
04:54:07 <Stinger> what is a comonad?
04:54:11 <quicksilver> instance Num a => Eq a
04:54:13 <ski> (coinheritance is for *variant* types .. inheritance is for record types)
04:54:22 <quicksilver> and that is a bit like another kind of inheritance
04:54:34 <LoganCapaldo> (ski's parens are breaking my mind)
04:54:40 <quicksilver> instance Monad m => Functor m where fmap = liftM
04:54:51 <ski> (Haskell^op is a bit boring)
04:55:07 <quicksilver> --> #lleksah
04:55:14 <LoganCapaldo> quicksilver, you are making all sorts of fun points
04:55:27 <quicksilver> sorry :-/
04:55:32 <LoganCapaldo> sorry
04:55:33 <LoganCapaldo> ?
04:55:35 <LoganCapaldo> why?
04:55:35 <quicksilver> :)
04:55:41 <quicksilver> wasn't sure how to respond
04:55:45 <LoganCapaldo> oh
04:55:46 <ski> we're all sorry
04:55:47 <quicksilver> thanks? :)
04:55:47 <LoganCapaldo> lol
04:55:57 <LoganCapaldo> yes it was meant to be a compliment
04:56:07 <LoganCapaldo> err
04:56:16 <quicksilver> Stinger: a comonad is a related structure but it works 'the other way around'
04:56:17 <LoganCapaldo> well a positive thing anyway
04:56:39 <quicksilver> Stinger: a monad has your types trapped inside some structure
04:56:50 <ski> The COMONADS are COOPERATING with HCOOP !
04:56:53 <quicksilver> Stinger: in a comonad they're augmented by an environmen t, instead
04:58:56 <ski> it is hard to get rid of a monadic wrapping, but easy to get into one
04:59:22 <ski> it is hard to get hold of a comonadic wrapping, but easy to get rid of one
05:00:11 <ski> if 'w' is a comonad, then a value of type 'w a' is basically a value of type 'a', but possibly there's some more/extra information present, too ..
05:00:50 <ski> .. and usually one want to preserve a while instead of getting rid of it fast
05:01:33 <ski> e.g. 'w' can be stream, so 'w a' is a stream of 'a's .. it contains a "current" 'a' (the head one), but also has alternate ones, down the stream
05:02:25 <ski> using this, one can model stream computations that can "look into the future", but not "look into the past"
05:03:07 <ski> iirc Uustalu,Veene had some paper describing this in more detail
05:03:08 <xerox> How does one supply -auto-all to ghc which is compiling a library with profiling informations via Cabal?
05:03:22 <Syzygy-> ghc-options: -auto-all
05:03:24 <Syzygy-> I think.
05:03:24 <mux> xerox: ghc-options: -auto-all
05:03:41 <xerox> There's a problem with that, it would also do -auto-all for the non-profiling version it is building as well.
05:03:58 <Syzygy-> Ah....
05:04:03 <apfelmus> what mathematical symbol is best used for the monadic bind operator?
05:04:09 <apfelmus> in TeX that is
05:04:09 <Syzygy-> :t bind
05:04:11 <lambdabot> Not in scope: `bind'
05:04:22 <Syzygy-> apfelmus: This is the one that isn't Âµ is it?
05:04:31 <Syzygy-> (or was it eta. Probably was eta)
05:04:39 <apfelmus> neither Âµ nor eta
05:04:48 <apfelmus> I mean >>=
05:04:57 <Syzygy-> No idea. I wouldn't use that when discussing mathematics. :P
05:05:02 <apfelmus> How to typeset it nicely in TeX?
05:05:08 <apfelmus> $ \gg=$ ?
05:05:25 <Cale> apfelmus: use \! to push together some >'s and an =
05:05:26 <ski> apfelmus : some use a (five-)star infix 'f * m' for 'f =<< m' .. i've also seen '(f^*) m' (parens not needed)
05:05:30 <quicksilver> possibly $\gg\!=$
05:05:51 <quicksilver> and then maybe \mathlig{>>=}{\gg\!=}
05:06:00 <quicksilver> then you can just use >>=
05:06:06 <matthew-_> quicksilver: I think that's what lhs2TeX uses in poly mode
05:06:09 <quicksilver> and then maybe \mathlig{>>=}{\mathrel{\gg\!=}}
05:06:12 <quicksilver> perhaps
05:06:19 <quicksilver> slightly better spacing behaviour
05:06:34 <apfelmus> hm, \gg\!= still looks a bit odd
05:06:53 <matthew-_> apfelmus: just use lhs2TeX?
05:07:02 <apfelmus> it's for the wikibook
05:07:08 <matthew-_> oh.
05:07:15 * matthew-_ grumbles at mediawiki
05:07:33 <Cale> apfelmus: what about another \! ?
05:08:19 <apfelmus> hm, a bit better
05:08:28 <apfelmus> but the >> are too big somehow
05:08:36 <Cale> hmm
05:08:54 <apfelmus> isn't there a paper that already solved this problem?
05:09:49 <xerox> I wonder what's "BLACKHOLE" in the heap profile.
05:09:58 <xerox> Or "ARR_WORDS" for that matter.
05:10:36 <quicksilver> blackholing is what ghc does to mark a thunk as being evaluated
05:10:42 <quicksilver> so another thrad doesn't try to reduce it too
05:10:45 <apfelmus> > let x = x in x
05:10:47 <lambdabot>  Exception: <<loop>>
05:10:48 <quicksilver> I believe
05:11:16 <apfelmus> blackholing enables the exception above
05:11:23 <apfelmus> > let f x = f x in f ()
05:11:27 <lambdabot> Terminated
05:11:40 <xerox> Mumble. And what does it mean for BLACKHOLE to be the thing that consumes most memory of your program?
05:11:47 <apfelmus> o.O
05:12:00 * xerox is getting sucked in a BLACKHOLE
05:12:14 <apfelmus> That means that I'm probably wrong :)
05:14:17 <Philippa> quicksilver: rather, as being in the process of being evaluated. It also prevents a space leak
05:26:10 <quicksilver> Philippa: yes that's what I meant. Damn english and its ambiguous present tense.
05:36:30 <benny99> hi
05:36:50 <ndm> can someone suggest that the people on -cafe have a group hug?
05:37:11 <osfameron> funny threads?
05:38:42 <ndm> read up on monadic subexpressions
05:39:02 <ndm> "it's one of C idioms. probably, you don't have enough C experience to understand it :)"
05:39:04 <matthew-_> wow, people still find the time to read -cafe ?
05:39:14 <chessguy> @type ''
05:39:16 <lambdabot> lexical error in string/character literal at character '\''
05:39:35 <chessguy> hm, no such thing as the empty Char?
05:39:57 <ohub> how would that be possible?
05:40:05 <chessguy> matthew-_, -cafe is a great place to learn
05:40:15 <Saizan> > '\NUL' --?
05:40:16 <lambdabot>  Parse error
05:40:29 <Saizan> > '\0'
05:40:31 <chessguy> @hoogle letter
05:40:31 <matthew-_> chessguy: yeah, I don't disagree. But I think signal to noise is suffering a bit
05:40:31 <lambdabot> Text.ParserCombinators.Parsec.Char.letter :: CharParser st Char
05:40:31 <lambdabot> Text.ParserCombinators.Parsec.Language.identLetter :: LanguageDef st -> CharParser st Char
05:40:31 <lambdabot> Text.ParserCombinators.Parsec.Language.opLetter :: LanguageDef st -> CharParser st Char
05:40:32 <lambdabot>  '\NUL'
05:40:59 <int-e> > chr 0xFEFF
05:41:00 <lambdabot>  '\65279'
05:41:19 <chessguy> matthew-_, maybe a little, but it's not that bad
05:41:58 <int-e> (zero width no-break space, also byte order mark)
05:42:32 <chessguy> so the parsec user guide has this example:
05:42:33 <chessguy> simple :: Parser Char
05:42:33 <chessguy> simple  = letter
05:42:53 <chessguy> my question is, what Char is returned if a letter is not found?
05:43:04 <matthew-_> it'll error
05:43:05 <int-e> none
05:43:22 <matthew-_> running the parser gives some sort of Either doesn't it?
05:43:28 <int-e> do you want  optional letter  ?
05:43:35 <matthew-_> so you'll just get the "error" side of the Either
05:44:13 <chessguy> int-e, i don't "want" anything in particular, i'm just trying to get a handle on Parsec
05:44:26 <matthew-_> @type runParser
05:44:28 <lambdabot> Not in scope: `runParser'
05:44:40 <matthew-_> well that's a shame
05:44:43 <chessguy> ah, so the only way to go from Parser a -> a is via runParser then
05:44:48 <matthew-_> correct
05:44:49 <chessguy> @hoogle run
05:44:49 <lambdabot> Test.QuickCheck.Batch.run :: Testable a => a -> TestOptions -> IO TestResult
05:44:49 <lambdabot> Data.Graph.Inductive.NodeMap.run :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))
05:44:49 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
05:44:50 <matthew-_> the parsec manual is really nice
05:45:01 <Saizan> @hoogle parse
05:45:01 <lambdabot> Text.ParserCombinators.Parsec.Prim.parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
05:45:01 <lambdabot> Data.Version.parseVersion :: ReadP Version
05:45:01 <lambdabot> Distribution.InstalledPackageInfo.parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
05:45:11 <matthew-_> Either ParseError a
05:45:13 <chessguy> matthew-_, yeah, i've been looking at it. it could say things like that more clearly though
05:45:15 <matthew-_> is what you get back
05:47:01 <chessguy> cool
05:47:44 <desp> how would you read in a 2D grid of numbers?
05:47:53 <chessguy> is there actually haddock documentation available for parsec somewhere?
05:47:56 <desp> a matrix, if you will
05:48:15 <matthew-_> desp: define "read in" ?
05:48:16 <desp> Data.Array is a bit unhelpful
05:48:38 <desp> matthew-_: parse and store
05:48:45 <matthew-_> chessguy: yes, but I find the reference section in the back of the parsec manual more useful
05:48:47 <desp> one kind of depends on the other
05:49:09 <matthew-_> desp: yup. So probably allocate a buffer for the whole file, read that in, and then walk it
05:49:21 <ddarius> desp: It depends.  For simple things, you can use map (map read) . words . lines
05:49:48 <desp> ddarius: building a list of lists?
05:49:53 <matthew-_> ahh, is it line terminated / human readable, or is it pure binary?
05:49:55 <chessguy> @type map (map read) . words . lines
05:49:56 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
05:49:57 <lambdabot>       Expected type: String -> String
05:50:05 <chessguy> yeah, i thought that looked fishy
05:50:13 <ddarius> desp: Yes.  You can make an array from there.
05:50:15 <chessguy> @type map $ (map read) . words . lines
05:50:17 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
05:50:17 <lambdabot>       Expected type: String -> String
05:50:31 <desp> thanks, I can take it from here
05:50:32 <quicksilver> :t map (map read) . map words . lines
05:50:34 <lambdabot> forall a. (Read a) => String -> [[a]]
05:50:39 <quicksilver> I think is what he meant :)
05:50:44 <ddarius> desp: If it's a very large grid, then that's probably not the best solution.
05:50:48 <chessguy> yeah, there  you go
05:50:57 <quicksilver> although you might fuse that by hand to map (map read . words) . lines
05:50:59 <ddarius> good call quicksilver.
05:51:30 <xerox> :t map (map read . words) . lines
05:51:32 <lambdabot> forall a. (Read a) => String -> [[a]]
05:52:37 <quicksilver> xerox: that's they same thing by the naturality of 'map'
05:52:52 <quicksilver> xerox: map f . map g === map (f.g)
05:53:10 <quicksilver> whether it's clearer is in the eye of hte beholder
05:54:20 <chessguy> ok, so my next question about this example
05:54:22 <chessguy> simple :: Parser Char
05:54:22 <chessguy> simple  = letter
05:54:28 <chessguy> @hoogle letter
05:54:29 <lambdabot> Text.ParserCombinators.Parsec.Char.letter :: CharParser st Char
05:54:29 <lambdabot> Text.ParserCombinators.Parsec.Language.identLetter :: LanguageDef st -> CharParser st Char
05:54:29 <lambdabot> Text.ParserCombinators.Parsec.Language.opLetter :: LanguageDef st -> CharParser st Char
05:54:49 <chessguy> letter and simple don't appear to have the same type
05:55:40 <chessguy> so how can they be equal?
05:55:52 <int-e> type Parser a = GenParser Char () a
05:55:58 <int-e> it specialises st to ()
05:56:26 <quicksilver> and similarly CharParser = GenParser Char
05:56:29 <int-e> (CharParser st a is GenParser Char st a)
05:56:31 <quicksilver> that's just a type name
05:56:33 * quicksilver nods
05:57:07 <int-e> so it's similar to writing  x :: Int; x = 0. (remember that 0 has type Num a => a.)
05:59:21 <chessguy> hm
05:59:31 <chessguy> seems like the documentation could be a lot more clear about such things
06:00:29 <chessguy> e.g., if i wanted to write a Parser Char, and went to check to make sure it didn't exist first, how would i know to look for a CharParser a Char?
06:02:18 <ddarius> chessguy: The same way you know anything about a library.
06:02:43 <chessguy> heh. what a fantastically vague statement
06:03:12 <quicksilver> 'by reading the documentation' I imagine
06:03:29 <quicksilver> as long as the char parsers were all implemented in one sensible place, not a big proble
06:03:35 <osfameron> I thought the point *was* that the documentation was vague?
06:03:39 <quicksilver> I agree that type synonyms can be confusing
06:03:43 <chessguy> well, that's my point though, the documentation doesn't really talk about the type synonyms
06:03:49 <ddarius> The Haddock at least should have the type synonym.
06:03:58 <quicksilver> parsec is pretty poorly documented
06:04:01 <quicksilver> last I checked
06:04:07 <quicksilver> there's a tutorial, but the haddock is almost bare
06:04:11 <ddarius> Read the "letter"
06:05:50 <ohub> I enjoyed Parse'c manual quite a lot
06:06:03 <ohub> urgh, it's Friday. Parsec's..
06:06:12 <chessguy> ohub, yeah, i'm looking forward to reading it once i can set aside a few spare hours :)
06:06:26 <ddarius> It's not all that long.
06:06:33 <quicksilver> then again, it's not ormally necessary to reuse combinators beyond the basic few
06:06:36 <quicksilver> it's so easy to write your own
06:07:01 <chessguy> quicksilver, combinators, or Parsers?
06:08:51 <quicksilver> both
06:08:59 <chessguy> i would think you would mostly reuse Parsec's combinators, and write your own Parsers
06:09:15 <quicksilver> I often make higher level combinators
06:09:17 <quicksilver> out of the basic ones
06:09:29 <quicksilver> 'parsers which take a parameter' if you like
06:09:35 <quicksilver> but that is a combinator :)
06:09:36 <ohub> yep
06:09:41 <quicksilver> especially if the parameter is anotehr parser...
06:11:09 <chessguy> oh well, i better do some "real" work. maybe this weekend i'll work through the parsec documentation and then write a simpler "Getting started" version
06:12:04 <hpaste>  matthew-_ pasted "example of nice parsing for chessguy" at http://hpaste.org/2051
06:12:28 <chessguy> as opposed to mean parsing?
06:12:34 <matthew-_> yup
06:12:42 <matthew-_> that would involve regexps ;)
06:12:43 <desp> @hoogle [[a]] -> [a]
06:12:44 <lambdabot> Prelude.concat :: [[a]] -> [a]
06:13:02 <desp> hrm
06:15:12 <chessguy> matthew-_, i don't really get the point of this
06:15:30 <desp> > listArray ((1, 2), (1, 2)) [1, 2, 3, 4]
06:15:32 <lambdabot>  array ((1,2),(1,2)) [((1,2),1)]
06:15:43 <matthew-_> chessguy: well, it's just showing combinators and such
06:15:45 * desp stares at listArray
06:16:48 * dcoutts pokes Lemmih and shapr to remind them that the version of HappS on hackage is out of date.
06:16:49 <dcoutts> Remember: if it's not on hackage, it doesn't exist.
06:17:01 <chessguy> matthew-_, oh, i know what combinators are.
06:17:11 <desp> @src listArray
06:17:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:17:44 <desp> ohhh.
06:17:57 <desp> > listArray ((1, 1), (2, 2)) [1, 2, 3, 4]
06:17:59 <lambdabot>  array ((1,1),(2,2)) [((1,1),1),((1,2),2),((2,1),3),((2,2),4)]
06:18:05 <desp> that's better.
06:18:13 * SamB_XP_ wonders why nuklearpower.com is apparantly running full-page ads for Sid Meir's Civilization IV: Beyond the Sword
06:18:33 <chessguy> desp, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html#v%3AlistArray
06:18:35 <lambdabot> http://tinyurl.com/24he3u
06:18:40 <dcoutts> Lemmih, shapr: oh and you could put the happs home page and the right description in the HappS.cabal file, so we could generate distro packages automatically without having to add that info in later by hand :-)
06:19:14 <desp> chessguy: I came directly from that page. I interpreted "a pair of bounds" the wrong way.
06:19:52 <desp> chessguy: you may want to assume that looking up documentation is an intrinsic ability of #haskell denizens
06:19:55 <nominolo> dcoutts: Cabal configs are now documented :)
06:19:59 <dcoutts> nominolo: yay
06:20:09 <chessguy> desp, not necessarily true
06:20:19 <dcoutts> nominolo: lets push that to the main repo now, not the -cleanups one
06:20:39 <nominolo> yeah, i sent the patch to cabal-devel
06:20:51 <nominolo> or whatever the default is
06:21:27 <dcoutts> ok
06:21:44 <nominolo> i just need someone to apply it
06:21:49 * dcoutts will do it
06:22:12 <dcoutts> nominolo: can you remind me which of the other patches sent to cabal-devel we decided need to be applied?
06:22:36 <SamB_XP_> dcoutts: did my patch make it to somewhere useful yet?
06:22:43 <dcoutts> SamB_XP_: yes, to me :-)
06:22:49 <SamB_XP_> cool.
06:22:55 <nominolo> dcoutts: i have two more unapplied patches
06:23:01 <dcoutts> nominolo: did we decide what to do with the tab issue? did we have a final patch for it?
06:23:07 <nominolo> dcoutts: the allow tabs was rejected
06:23:11 <dcoutts> right
06:23:23 <dcoutts> but there was some stuff to make the error messages better iirc
06:23:29 <nominolo> i'll send a better fix soon
06:23:34 <dcoutts> SamB_XP_: I'm hesitant to apply it without it being true yet :-)
06:23:41 <SamB_XP_> I wasn't sure who exactly cabal-devel-owner was, and I wasn't quite sure I had forwarded the email in usable form either...
06:23:50 <SamB_XP_> dcoutts: well it makes the bug exist
06:24:31 <nominolo> dcoutts: the other unapplied patch is the test for the right implementation
06:24:42 <nominolo> dcoutts: which is not too clean, but correct
06:25:01 <nominolo> dcoutts: to make it clean we need to finish the cleanups first
06:25:05 <dcoutts> nominolo: ay yes
06:25:28 <nominolo> dcoutts: don't know what we'll do with the current patch
06:25:51 <nominolo> dcoutts: i guess, if Igloo needs the feature he'll just apply it ;)
06:26:18 <dcoutts> nominolo: we could try and push some of these cleanups
06:27:09 <nominolo> well, the only thing i need is the compiler datatype
06:27:21 <nominolo> so i don't have to pass tuples around
06:27:26 <dcoutts> right, I'm still thinking about that thing
06:27:30 <xerox> I need some help with profiling, how do I get more detailed informations than "BLACKHOLE" ?  I'm using Parsec in a program, and I built both with -prof -auto-all, then I do ./a.out +RTS -p -hd -RTS and look at the hp2ps output.
06:27:33 <dcoutts> it's not clear to me where it should live
06:27:57 <Igloo> My immediate need disappeared for 2 reasons, but base still ought to use it
06:28:00 <nominolo> Distribution.Compiler?
06:28:08 <dcoutts> nominolo: it seems we're making it more and more something that should live in Distribution.Simple.Compiler
06:28:52 <dcoutts> nominolo: since it's not just a package of data, it's got methods which depend on the implementations in the Simple build system
06:29:04 <nominolo> dcoutts: hm, if we're continuing this way we can soon drop the .Simple part :)
06:29:35 <dcoutts> nominolo: it's never been simple in implementation, it's simple because it makes things simple for the user by doing all the hard work :-)
06:29:55 <nominolo> dcoutts: yes, i know
06:38:48 <SamB> hmm. does anyone know how to say "homeschooled" for highschool on facebook?
06:42:46 <dylan> SamB: No, but if you find out, let me know.
06:43:32 <SamB> dylan: do you mind my asking what your real name is?
06:43:49 <dylan> Dylan Hardison. it's no secret
06:44:25 <SamB> well, your IRC client said "celebrity steel cage monkey boxing", so ;-)
06:45:20 <xerox> That is, there's a little loss of informations, on the right the .prof output, on the left the hp2ps generated ps file <http://lab.passiomatic.com/image-bin/2648665482.png>
06:47:22 <SamB> dylan: and here I thought that your nick referred to the programming language
06:48:50 <Cale> Man, why is this "What is Haskell good for?" reddit thread generating way more talk about C++ and not lots of good answers for the guy?
06:49:08 <Cale> http://programming.reddit.com/info/2bxc1/comments/c2bzw7 -- I posted my response here
06:49:09 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
06:49:21 <quicksilver> because bored procrastinating people talk about what they want to talk about
06:49:24 <permanente> Cale, because its some kind of forum and thus draws trolls to it?
06:49:26 * SamB wonders why his facebook urls are now all on widener.facebook.com
06:49:29 <quicksilver> and say things they personally think are amusing and interesting
06:49:40 <quicksilver> they don't much care for teh topic :)
06:49:53 <ohub> Why ghc 6.6.1's arrows are not enough for building lambdabot?
06:50:15 <xerox> dcoutts: what's the best way to do headAndTail :: ByteString -> (Char,ByteString) with Data.ByteString.Lazy.Char8 ?
06:50:22 <matthew-_> I'm sure slashdot, dailywtf, digg, reddit et al are all actually lowering tolerance and understanding of mankind as a whole
06:50:35 <SamB> dylan: you should join http://facebook.com/group.php?gid=2483604049
06:50:37 <lambdabot> Title: Facebook | Incompatible Browser
06:50:37 <dcoutts> xerox: uncons
06:50:57 <matthew-_> well done lambdabot: you're safe
06:50:58 <xerox> dcoutts: thanks.
06:51:03 <SamB> dylan: the #haskell group
06:51:14 <geezusfreeek> it's all qwe123's fault
06:51:18 <geezusfreeek> :)
06:51:20 <dcoutts> xerox: I'm not sure if that's in the current api though
06:51:24 <dcoutts> @paste
06:51:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:51:32 <xerox> dcoutts: doesn't look like
06:51:39 <hpaste>  dcoutts pasted "lazy bytestring uncons" at http://hpaste.org/2053
06:53:14 <dcoutts> xerox: is that ok then?
06:53:33 <xerox> dcoutts: let's see, if .Char8 exports LPS and usafe* things yes.
06:53:53 <dcoutts> xerox: LPS constructor and unsafe is from .Internal
06:54:13 <quicksilver> dcoutts: it might be sexier to use [] as a view
06:54:34 <dcoutts> quicksilver: how would you suggest doing that?
06:54:41 <quicksilver> dcoutts: but then, that rather depends what you're trying to do :)
06:54:47 <quicksilver> well it would become 'unpack'
06:55:01 <dcoutts> that will not optimise quite as well atm
06:55:04 <quicksilver> but relying on lazy evaluation not to do more work than needde
06:55:07 <dcoutts> since it's recursive
06:55:36 <SamB> quicksilver: you could give some examples of how that would work
06:55:51 <dcoutts> if one really is doing just head/tail then uncons is perfect, it should inline and cost almost nothing
06:56:16 <quicksilver> SamB: I'm just saying instead of using Maybe to signal if we're at the end of the list
06:56:26 <quicksilver> SamB: signal that with the [] constructors
06:56:39 <quicksilver> SamB: so instead of ByteString -> Maybe (Word 8, ByteString)
06:56:50 <quicksilver> you simple have ByteString -> [Word8]
06:57:03 <quicksilver> and you case on (:) [] instead of Just Nothing
06:57:11 <quicksilver> but that is, of course, unpack
06:57:24 <SamB> quicksilver: that doesn't sound like a very good way to implement dna2rna at all!
06:57:27 <dcoutts> yes and you can do that, but don't expect it to be quick
06:57:47 <SamB> @type unfoldr
06:57:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:58:01 <quicksilver> I don't really see why it should be slower, per se
06:58:12 <quicksilver> but it doesn't give you the tail as a [Word8] instead of  ByteString
06:58:16 <quicksilver> which may be very foolish
06:58:21 <quicksilver> (depending what you're trying to do)
06:58:28 <quicksilver> s/doesn't/does/
06:58:41 <SamB> quicksilver: if you wanted a [Word8], you could just unpack first?
06:58:45 <dcoutts> quicksilver: it's only slower in the constant factors, not asymptotically
06:58:45 <quicksilver> right
06:58:58 <quicksilver> SamB: what I'm saying, that unpack is actually 'the same' as uncons
06:59:02 <quicksilver> in some abstract sense
06:59:06 <SamB> it isn't
06:59:42 <SamB> not more than bytestrings are the same as [Word8], anyway
06:59:51 <xerox> dcoutts: at this low level what do I need to use to do Word8->Char
06:59:58 <dcoutts> nominolo: ok, I've pushed some patches to the main repo, could you check if you think there are any important ones missing
07:00:07 <quicksilver> xerox: chr
07:00:16 <quicksilver> xerox: or toEnum
07:00:18 <quicksilver> (same thing)
07:00:32 <quicksilver> @check \x -> chr x == toEnum x
07:00:33 <hpaste>  dcoutts annotated "lazy bytestring uncons" with "uncons for Char8" at http://hpaste.org/2053#a1
07:00:34 <SamB> you need fromIntegral or fromEnum too don't you?
07:00:34 <lambdabot>  Exception: Prelude.chr: bad argument
07:00:38 <quicksilver> bah
07:00:41 <dcoutts> xerox: ^^
07:00:56 <_Stinger_> @pf \f x -> f x x
07:00:56 <lambdabot> Maybe you meant: bf pl
07:00:59 <dcoutts> xerox: or mix the two together
07:01:03 <_Stinger_> @pl \f x -> f x x
07:01:03 <lambdabot> join
07:01:06 <xerox> What's w2x? :)
07:01:10 <xerox> *w2c
07:01:17 <dcoutts> word2char
07:01:49 <dcoutts> nominolo: ie do darcs push --dry-run http://darcs.haskell.org/cabal/ and check if you have any important patches locally that you think we need to actually push
07:01:52 <lambdabot> Title: Index of /cabal
07:01:55 <quicksilver> dcoutts: are you saying that unpack doesn't use unsafeHead and unsafeTail in the same way?
07:02:07 <quicksilver> dcoutts: or is it a more subtle point?
07:02:33 <dcoutts> quicksilver: no, it does, but uncons is not recursive, unpack is, so unpack cannot be inlined simply, it really will allocate (:) nodes
07:02:57 <dcoutts> uncons will allocate nothing, it'll inline to a tiny about of code
07:03:12 <quicksilver> dcoutts: ah, this accursed rule about non-inlining of recursive functions
07:03:38 <dcoutts> quicksilver: but even if it is inlined it would not help, it'd have to be fused to remove the allocations
07:03:49 <desp> > (0, 2) > (1, 1)
07:03:50 <lambdabot>  False
07:03:53 <xerox> dcoutts: I have imported Lazy.Char8 as C and Internal as I, and there's a problem with length.  There is no I.length, but it wants a I.ByteString as input so I can't use C.length.
07:04:17 <quicksilver> dcoutts: specConstr will catch it in some cases, though?
07:04:31 <quicksilver> dcoutts: the same cases that specConstr will avoid the explicit Just cell, I'd have thought
07:04:40 <quicksilver> dcoutts: (and the explicit tuple inside the Just)
07:04:50 <dcoutts> xerox: import qualified Data.ByteString as B  abd use B.length
07:04:57 <nominolo> dcoutts: no, only the tabs patch
07:05:08 <dcoutts> nominolo: ok, and we're not doing that one right?
07:05:18 <nominolo> right
07:05:26 <dcoutts> nominolo: so we should unrecord/unpull that in our repos
07:06:33 <dcoutts> quicksilver: if you use it like: case uncons xs of Nothing -> ..; Just (x,xs') -> ..;  then uncons can be inlined and the Nothing and Just (_,_) cells will never be allocated since it's clear they are immediately deconstructed.
07:06:56 <dcoutts> quicksilver: it's not SpecConstr in this case, it's a much simpler optimisation
07:07:21 <quicksilver> dcoutts: is the same thing not true of case unpack xs of [] -> ..; (x:xs) -> ...; ? assuming unpack was made to inline
07:07:50 <dcoutts> quicksilver: right, it's not the same because of the recursion in unpack, even if we inline unpack
07:08:19 <quicksilver> hmm
07:08:21 <dcoutts> quicksilver: that needs something more sophisticated
07:08:23 <nominolo> dcoutts: yes, i'll do that
07:08:26 <quicksilver> but the recursion is 'behind' the constructor
07:08:32 <nominolo> dcoutts: isn't that revert?
07:08:43 <quicksilver> you can see which constructor comes out without worrying about what the recursion does
07:09:22 <dcoutts> nominolo: unrecord removes the patch but not the changes in the working copy, you have to separately revert to remove the changes from the working copy. unpull does both in one go.
07:09:29 <nominolo> dcoutts: ah, no that'll reset to the external repo
07:09:52 <dcoutts> nominolo: hmm? unrecord/revert/unpull are all local operations I think
07:10:13 * nominolo reads darcs manual
07:10:52 <dcoutts> quicksilver: hmm, perhaps
07:10:52 <qwr> hmm. if i define types as sets of values and allow defining types like one of 1, 2 or 5, would it be then dependent typing or not?
07:11:15 <benny99> Haskell is great, bye :)
07:11:32 <quicksilver> dcoutts: I probe not to be difficult, but because I'm ver interested in this :)
07:11:42 <dcoutts> quicksilver: that'd be an interesting optimisation to investigate, unrolling recursive functions that are subject to a finite nested case analysis
07:12:18 <dcoutts> ie something like: case unpack foo of (_:_:_) -> ...;
07:12:32 <SamB> yes, unrecord, unpull, and revert are all local
07:12:42 <dcoutts> we should unroll unpack twice there
07:12:57 * nominolo couldn't find the darcs manual and now reads the darcs wikibook instead
07:13:41 <quicksilver> dcoutts: yes...
07:14:13 <xerox> Syzygy-: If you care, I found it. It's  ghc-prof-options:  -auto-all !
07:14:32 <Syzygy-> xerox: Ah!
07:16:02 <Saizan> > (1,3) < (1,4)
07:16:03 <lambdabot>  True
07:16:08 <Saizan> > (1,3) < (0,4)
07:16:09 <lambdabot>  False
07:29:52 <Staatspenner_nr1> LOOK AT THIS PAGE ITS VERY FUNNY
07:29:54 <Staatspenner_nr1> http://www.pennergame.de/ref.php?uid=2349
07:29:56 <lambdabot> Title: Pennergame
07:29:56 <Staatspenner_nr1> THANKS
07:31:08 <aFlag> this libghc6-x11-dev (debian) package, is it usually a part of ghc? I'm trying to compile xmonad but I seem to have a older version of that package and I don't seem to have a x11-extras package. Can't seem to find it on google
07:31:12 <nominolo> hm, what happens if one just changes the uid?
07:32:04 <doserj> @hackage x11-extras
07:32:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/x11-extras
07:32:36 <aFlag> 404 Not Found
07:34:14 <doserj> hmmm
07:34:34 <doserj> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11-extras-0.2
07:34:36 <lambdabot> http://tinyurl.com/2rfqkc
07:34:45 <aFlag> hm
07:34:53 <aFlag> thanks
07:35:15 <ari> I tried to compile xmonad a couple of days ago with what I believe to have been X11-extras-0.2, it bombed on not having an instance Read Rectangle
07:36:16 <aFlag> hm
07:38:58 <Saizan> ari: for darcs xmonad you need darcs x11-extras
07:39:04 <Saizan> @where x11-extras
07:39:04 <lambdabot> http://darcs.haskell.org/~sjanssen/X11-extras
07:40:16 <geezusfreeek> xmonad sort of makes me wish linux had photoshop, because that's all i would need to make a complete switch from mac
07:40:45 <geezusfreeek> well, and support for the itunes drm (no lectures please :) )
07:40:52 <Tac-Work> wine it
07:41:04 <dino-> geezusfreeek: I'm sure this comes up a lot but: Gimp isn't enough of a PS clone?
07:41:12 <geezusfreeek> i do both web and print work
07:41:18 <geezusfreeek> and gimp doesn't even have cmyk
07:41:22 <Tac-Work> gimp is very clunky
07:41:31 <dino-> I see.
07:41:42 <Tac-Work> the best thing that came out of gimp was its gui toolkit
07:41:47 <dino-> You know, they really should make a real commercial PS for Linux.
07:42:07 <Cale> geezusfreeek: It has some cmyk support. It looks like the next version will have colour management.
07:42:20 <Tac-Work> I think the problem is Linux people are so used to getting their beer for free that no one would pay for it
07:42:33 <Tac-Work> graphical people already religiously buy into mac
07:43:11 <geezusfreeek> well, i have always used macs because i have always been more productive on them for these kinds of things
07:43:15 <Cale> I actually prefer gimp to photoshop for some things. Photoshop's actually stolen a few features from it :)
07:43:23 <geezusfreeek> for programming i'm more productive on linux though
07:43:54 <Tac-Work> People say macs are more productive, but I never understood. Maybe I just don't know them, but mac seems to be missing a lot of shortcut keys for applications that Windows and Linux both have
07:44:14 <osfameron> you could get an emulator for Mac and run Photoshop in that on a Linux box...
07:44:17 <earthy> this is related to haskell how?
07:44:18 <geezusfreeek> Tac-Tics, like what? i have never missed a shortcut key on mine
07:44:18 <Tac-Work> and yeah, programming = mac loses. It doesn't even come with a text editor.... save vi
07:44:36 <earthy> hey, vi is great
07:44:39 <Tac-Work> it could be that the shortcut keys are just different and i haven't used them much
07:44:41 <geezusfreeek> earthy, well, it came up because i mentioned xmonad, but then it decomposed into this
07:44:42 <Tac-Work> vi is great
07:44:48 <dino-> Well, strictly speaking, vi is lame, but vim is great.
07:44:49 <earthy> as is XCode
07:44:56 * osfameron looks at #haskell-blah
07:45:03 <quicksilver> this is rather off-topice, but I'm pretty sure the mac comes with vi, emacs, textedit, appleworks and Xcode
07:45:13 <quicksilver> there should be a text-editor in that list to suit most people
07:45:16 <geezusfreeek> quicksilver, not appleworks anymore
07:45:19 <earthy> not appleworks
07:45:27 <quicksilver> well whatever :) that was the most stupid entry in the list :)
07:45:29 <Tac-Work> osfameron: MacMonad < LinuxMonad ;-)
07:45:30 <geezusfreeek> and xcode is a download, not preinstalled
07:45:32 <earthy> and not haskell, by default. ;)
07:45:42 <quicksilver> geezusfreeek: comes on the install DVD
07:45:46 <osfameron> does xmonad run on Mac?
07:45:48 <quicksilver> geezusfreeek: (just not pre-installed)
07:45:51 <geezusfreeek> quicksilver, not anymore
07:45:51 <quicksilver> osfameron: yup
07:45:54 <earthy> but I've been doing haskell on the mac for 4 years already
07:46:00 <osfameron> oooo!  that might be enough to make me try a mac :-)
07:46:05 <osfameron> I *hate* the windowing system on Mac
07:46:05 <quicksilver> geezusfreeek: yes it does, I'm using a new mac bought 2 days ago...
07:46:14 <earthy> it won't manage the Aqua windows though
07:46:14 <quicksilver> osfameron: but it won't take over your system windows
07:46:19 <geezusfreeek> osfameron, it would only work for x11 apps, not cocoa or carbon apps
07:46:23 <quicksilver> osfameron: so you'd have to do everything in x11
07:46:26 <osfameron> oh...
07:46:28 <dino-> ya, but can you really ditch the Mac gui entirely and use Xorg or whartever?
07:46:28 <Cale> osfameron: I agree with you
07:46:35 <geezusfreeek> dino-, yes
07:46:39 <geezusfreeek> you can run gnome or kde even
07:46:51 <earthy> that'd be great, having an xmonad for aqua...
07:46:53 <ndm> @seen sorear
07:46:53 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 6h 13m 21s ago, and .
07:47:00 <dino-> And give up all Cocoa apps, presumably.
07:47:16 <Cale> I used Mac OS X for a couple of months, and you can make it usable, but there were still annoying things about the window management that seemed to require commercial software (?!) to fix.
07:47:19 <osfameron> I've occasionally thought about running ubuntu on an ibook... it would annoy the fanboys, which is a good thing in itself
07:47:31 <earthy> unfortunately /System/Library/Frameworks/ApplicationServices.framewo
07:47:32 <earthy> rk/Frameworks/CoreGraphics.framework/Resources/WindowServer -daemon
07:47:37 <geezusfreeek> it's probably perfectly possible to write hacks for tiling cocoa windows and such, but they would just be hacks
07:47:38 <earthy> is not really replacable
07:47:39 <Cale> osfameron: I'd probably do that :)
07:47:58 <osfameron> but actually the ibook is heavier than the PC laptops I'm lusting after so probably won't
07:47:58 <geezusfreeek> osfameron, i am running ubuntu under a vm on my imac right now
07:47:59 <dino-> That's a different thing though, using the hardware as a platform to install Linux, completely devoid of OSX.
07:48:29 <dino-> speaking of, I did recently get an Asus S96S laptop. I absolutely love it.
07:48:36 <Cale> I'd be a lot happier with Mac OS X if it just had a checkbox somewhere to make the windows use point-to-focus.
07:48:53 <quicksilver> Cale: I have that switched on in X11 and iTerm
07:48:58 <quicksilver> Cale: which covers most of my windows
07:49:15 * osfameron tried point-to-focus in gnome, found it incredibly disrupting
07:49:29 <osfameron> I like to wave my mouse about as a fidget, don't like it to actually *do* anything
07:49:32 <dino-> Cale: Hey, are you still writing a book?
07:50:02 <roconnor> osfameron: I'm waiting for, ``focus on window I'm looking at''.
07:50:12 <osfameron> roconnor: yeah!  that'd be sweet
07:50:23 <Cale> dino-: Potentially? :)
07:50:38 <Baughn> Cale: I don't generally /use/ the mouse, so using it to focus would be incredibly disrupting. Quicksilver works better - or was there something else you're missing?
07:50:41 <dino-> I still feel like your _Monads as Containers_ is one of the best things I've read on the subject.
07:50:51 <roconnor> osfameron: I have two screens, and when I switch to looking at the other screen, I often to forget to click to get focus there.
07:50:54 <Cale> Baughn: I used quicksilver too
07:51:05 * quicksilver feels used
07:51:26 <Cale> Baughn: It's good, but it still doesn't make up for not having point to focus.
07:51:26 <osfameron> is there a good quicksilver alternative for Linux ?
07:51:51 * earthy ponders
07:52:07 <earthy> do I go with the Maybe monad or do I make failure handling explicit
07:52:07 <osfameron> I tried launchbox (which had *no* docuemntation and I couldn't get to do anything) and the KDE one which was half-functional but couldn't find gksudo to run anything that needed root
07:52:23 <geezusfreeek> osfameron, the command line?
07:53:07 <Baughn> earthy: Maybe is explicit enough, and has the advantage of being a monad
07:53:16 <Cale> osfameron: Gnome has a spotlight-alike
07:53:21 <osfameron> geezusfreeek: yeah... spose
07:53:26 <earthy> Baughn: yeah, it's just that the location in which you are explicit changes
07:53:44 <osfameron> Cale: yeah, beagle - not as immediate gratification as quicksilver and doesn't do apps in the same handy package
07:53:44 <earthy> using the monadic interface means being explicit in each point that you add things to the maybe monad
07:53:58 <desp> hehe
07:54:08 * desp just solved problem 11 in Project Euler
07:54:10 <Cale> osfameron: I was thinking of Deskbar
07:54:23 <desp> foldArray :: Ix i => (a -> e -> a) -> a -> (i -> i) -> i -> Array i e -> a
07:54:28 <fxr> geezusfreeek: wonderfukl nick :)
07:54:33 <dino-> Can you make your failable thing just monadic, not specific to Maybe?
07:54:35 <earthy> using the Maybe types explicitly (and leaving them out when you can't fail) forces you to be explicit in the *handling* of the possible failures.
07:54:39 <dino-> Like Data.Map.lookup
07:54:49 <earthy> yeah, I can, obviously
07:54:53 <Cale> That would be MonadZero, really.
07:54:54 <earthy> I'm thinking of whether I want to
07:55:15 <Cale> It annoys me every other day that they removed MonadZero
07:55:32 <quicksilver> it's because of this whole failure taking a string lark, I think
07:55:44 <quicksilver> which leads you to MonadError and MPTCs and stuff
07:56:01 <Cale> failure just should not be in the Monad class at all
07:56:28 <earthy> nope.
07:56:54 <earthy> otoh: a nice standardized way to deal with failures would be good
07:57:16 <osfameron> Cale: oh, ta
07:57:23 <geezusfreeek> fxr, :)
07:57:27 <earthy> now there's too much choice (and design space)
07:57:40 <earthy> morning john, conal.
07:57:42 <quicksilver> Cale: although pattern match failures in monad comprehensions are very cute
07:57:48 <quicksilver> Cale: well, mostly list comps
07:57:51 <conal> morning earthy :)
07:58:24 <Cale> quicksilver: right, that's why the do-translation should involve MonadZero when a refutable pattern gets used
07:58:47 <Cale> Haskell 1.4 had it right :)
07:58:56 <Cale> It's very annoying that they changed that.
07:59:00 <Tac-Work> what was their reasoning for changing
07:59:11 <Tac-Work> they must have had one, even if it was very bad
07:59:34 <Cale> Tac-Work: afaict, it was because they removed monad comprehensions (because beginners didn't care for the error messages)
07:59:56 <Tac-Work> What's a monad comprehension?
08:00:25 <Cale> and then they noticed that without monad comprehensions, they could merge MonadZero and MonadPlus, because all the existing instances in the Prelude that were instances of one were also instances of the other
08:00:27 <Tac-Work> is that like using a non-List monad in a list comprehension?
08:00:28 <sjanssen> Tac-Work: imagine that the list comprehension syntax works for any monad
08:00:34 <Cale> Monad comprehensions are generalised list comprehensions
08:00:38 <Tac-Work> yeah
08:00:44 <sjanssen> [x + y | x <- readLn, y <- readLn]
08:00:55 <Cale> Guards require MonadZero
08:00:58 <Tac-Work> When I saw haskell used <- instead for that syntax, I assumed that worked for any monad
08:01:02 <Tac-Work> but then I found out not
08:01:08 <Tac-Work> It's kinda sad they removed that
08:01:08 <earthy> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg03267.html
08:01:08 <lambdabot> Title: MonadZero
08:01:53 <ihope> In Haskell, can you pretty much use braces and semicolons anywhere you can use indentation and line breaks?
08:02:20 <quicksilver> s/pretty much//
08:02:33 <quicksilver> indentation is desugared into semicolons and braces
08:04:08 <ihope> That's nice :-)
08:04:27 <osfameron> why are comprehensions so-called ?
08:04:44 <Cale> osfameron: That's what they've been called in mathematics for the last 100 years :)
08:05:35 <osfameron> ah ok
08:06:04 <xerox> :t liftM2 (+) readLn readLn
08:06:05 <osfameron> http://en.wikipedia.org/wiki/Set-builder_notation is a nice page but doesn't give the history of the naming
08:06:07 <lambdabot> forall a1. (Num a1, Read a1) => IO a1
08:06:18 <Cale> It comes from the idea of forming the set of all elements which satisfy a predicate.
08:06:43 <Cale> I suppose, a comprehensive collection of such elements
08:07:39 <Cale>   I. Inclusion, comprising.
08:07:39 <Cale>     1. The action of comprehending, comprising, or including; the fact or condition of being so comprehended or comprised in a treatise, classification, description, proposition, etc.
08:07:58 <Cale>    2. The faculty or quality of comprehending; inclusive force; comprehensiveness.
08:08:11 <Cale>     {dag}3. A comprehensive arrangement, summation, summary of any matter. Obs.
08:08:15 <Cale>     4. Logic. The sum of the attributes comprehended in a notion or concept; intension.
08:08:32 <osfameron> ah... the modern usage of "comprehension" is usually "understanding"
08:08:32 <Cale> I suppose those are all reasonable explanations for the word :)
08:08:39 <osfameron> but yeah, those work
08:09:00 <quicksilver> and much colourful debate has raged in logical circles about how advisable comprehension axioms are
08:09:12 <quicksilver> q.v. Russell, Quine, and such like
08:09:25 <osfameron> advisable?
08:09:28 <Cale> Well, Frege started it :)
08:09:46 <Lycurgus> I think phi is the predicate in question in the article.
08:10:04 <Cale> Frege's formalisation of what we'd now recognise as set theory was broken because his comprehensions were too powerful.
08:10:07 <quicksilver> Cale: this isn't a playground, I don't care who started it, I'll have no paradoxes here ;)
08:10:23 <Lycurgus> <- (formerly JKnecht, consolidated identities, I'm Lycurgus at wikipedia)
08:10:41 <quicksilver> osfameron: unrestricted comprehension is paradoxical
08:10:54 <quicksilver> osfameron: because you can form the russel set, { x | x \in x }
08:11:00 <Cale> Essentially, he allowed the formation of sets of objects satisfying any predicate whatsoever.
08:11:20 <osfameron> er... so don't do that?
08:11:25 <quicksilver> right
08:11:35 <quicksilver> and the details behind your simple pronouncement
08:11:42 <quicksilver> we good enough for a century or so's debate :)
08:11:43 <Cale> right, so how to restrict ourselves to something which won't create a paradox?
08:11:45 <osfameron> hehe
08:11:51 <quicksilver> such are the simple pleasures of logicians...
08:11:58 <Cale> In modern mathematics, we insist that you start with a set and restrict it to a subset.
08:12:28 <Cale> This means that you can't form certain sets -- for instance, the set of all sets.
08:12:32 <osfameron> is that what you mean about the comprehensions beign too powerful?
08:12:49 <Cale> Yeah.
08:12:52 <quicksilver> russell suggested a solution by 'ordering' sets and only permitting \in to put 'lower' sets inside 'higher' sets
08:12:59 <quicksilver> although that never took off as a set theory
08:12:59 <ndm> Jules Bean?
08:13:09 <quicksilver> it does, in some sense, lie behind modern type theory
08:13:13 <quicksilver> especially the dependent stuff
08:13:14 <quicksilver> ndm: guilty
08:13:20 <ndm> quicksilver: ah yes, i remember the association now :)
08:13:32 <quicksilver> which association?
08:13:33 <ndm> you were saying (<- ) should "be applicative"
08:13:44 <ndm> the Map RealName IrcName
08:13:47 <quicksilver> yes
08:13:55 <quicksilver> or at least, I was pointing out that should be considered
08:14:08 <ndm> did you read my post about the do notation?
08:14:17 <ndm> in particular the semantics
08:14:30 <quicksilver> in the monad subexpressions thread? yes
08:14:39 <ndm> and that the only way i could figure to give semantics is by saying it associates to the previous statement in the do
08:14:50 <quicksilver> yes, that was spj's original proposal
08:14:56 <quicksilver> 'nearest enclosing do without a lambda in the way'
08:14:59 <ndm> would you mind taking that email, and saying what the applicative interpretation would be
08:15:00 <quicksilver> or something like that
08:15:09 <quicksilver> well we're a bit stuck
08:15:17 <quicksilver> because applicatives don't have "dos" as signposts :(
08:15:20 <ndm> the problem is that applicative is at the expression level
08:15:39 <quicksilver> so you are more-or-less forced into the [[ ]] idiom bracket styling
08:15:46 <ndm> yeah, you could introduce some sort of "bracketing this expression", and then insert the things just before that
08:15:56 <quicksilver> like in dan piponis reply to me
08:16:04 <quicksilver> you need some 'signpost' to substitute for the do
08:16:07 <ndm> so you need both idiom brackets, and monadic sub-expression brackets?
08:16:16 <quicksilver> that's actualy one of the things I don't like about SPJ's proposal
08:16:21 <quicksilver> it makes 'do' special in another way
08:16:31 <ndm> yeah, thats what my post was intended to hilight
08:16:39 <quicksilver> so if you rewrite a do as an monadic expression
08:16:39 <ndm> i'm not sure its wrong, though
08:16:49 <quicksilver> do { x } ---> x
08:16:53 <quicksilver> (single statement do)
08:16:55 <Cale> I kind of like the way that do forces you to think about order, though I admit beginners trip over it a lot.
08:16:58 <quicksilver> becomes invalid
08:17:11 <quicksilver> if x uses any of these (<- ) forms
08:17:22 <ndm> yeah
08:17:33 <quicksilver> because the do isn't really single statement
08:17:34 <quicksilver> it turns out
08:17:38 <quicksilver> but I think that's a bit surprising :)
08:17:42 <ndm> i agree
08:18:10 <ndm> although i'm 100% sure that something within spitting distance of this proposal will be absolutely critical to Haskell
08:18:41 <Lycurgus> critical to Haskell doing what?
08:18:54 <Cale> It seems like for commutative monads, where this sort of thing is really desirable, you should be able to do a lot better somehow than do-blocks.
08:18:56 <ndm> success, world domination
08:19:08 <Lycurgus> right, just checking.
08:19:10 <Cale> We don't want world domination though :)
08:19:24 <doserj> not???
08:19:24 <Cale> At least not before the prelude's been rewritten once more :)
08:19:27 <ndm> true, scrap that last one, maybe just making me happy
08:19:41 <ndm> i have lots of code where this proposal would make the code beautiful
08:19:59 <Cale> Are you thinking reader monad or name-supply stuff?
08:20:11 <Tac-Work> ""Sometime before the Haskell 98 standard the list comprehension syntax was first generalized to monad comprehension but then specialized back as it caused type ambiguity: ['c'] wouldn't mean a list of one element, the character c, but the result of return 'c' in any monad.""
08:20:16 <Tac-Work> http://en.wikipedia.org/wiki/List_comprehension#Monad_comprehension
08:20:18 <lambdabot> Title: List comprehension - Wikipedia, the free encyclopedia, http://tinyurl.com/2cxmmw
08:20:23 <quicksilver> Cale: but you need some signpost, or you need some very ambiguous type inference
08:20:37 <Cale> quicksilver: sure
08:20:41 <quicksilver> Cale: since a given sub expression could have many enclosing CommOMonad expressions
08:20:57 <quicksilver> (and if you have two enclosing ones of the same type, even type inference isn't enough)
08:21:17 <Cale> You need something, but do-notation seems a little heavy.
08:21:53 <Cale> On the other hand, constructing something that's any lighter involves adding a whole bunch of syntax rules...
08:22:08 <Cale> I think that's why nothing's been done about it :)
08:22:44 <ndm> Cale: i'm talking just normal monads, typically state monads, sometimes name supply, sometimes IO - particularly in Gtk2hs
08:22:56 <Cale> hmm...
08:24:08 <dino-> Sometimes I could use do but don't bother when >>= is more expressive or the foo <- ... bar <- will just get tedious.
08:24:10 * osfameron notes that just hanging around on #haskell doesn't magically make him cleverer... need to get back to my exercises..
08:25:00 <Botje> osfameron: once you understand what people are talking about, you DO get smarter :)
08:25:02 <twanvl> I find that Applicative is usually better than simple do blocks/liftM
08:25:31 <osfameron> Botje: yeah... but I need to spend more grok-time on haskell, right now this is just mildly depressing me :-)
08:26:00 <Cale> osfameron: Don't worry, it gets better :)
08:26:43 <quicksilver> Cale: for example, you might only be using the 'get' part of state
08:27:00 <quicksilver> Cale: so you're kind of using a commutative part of a monad, in an expression
08:27:15 <Cale> quicksilver: that's true
08:27:17 <quicksilver> Cale: (or you might even be using the set part too, but just knowing that the particular sets in question commute)
08:27:28 <Cale> Or you just really don't care.
08:27:36 <quicksilver> right
08:27:47 <quicksilver> like you don't in C or Java or indeed ML
08:28:06 <quicksilver> when I call gtk_makeFoo(bar(a),baz(b)) in C
08:28:14 <Cale> Somehow I've gotten used to the extra verbosity, because I really like the distinction between running actions and evaluating them.
08:28:18 <quicksilver> I understand the order of the side-effects of bar and baz to be not very important
08:28:36 <quicksilver> I've got used to it too
08:28:41 <quicksilver> but sometimes it feels a bit heavy
08:29:28 <quicksilver> of course it's interesting how close you can get with ap and fmap and =<<
08:29:57 <quicksilver> l <$> m <*> (return x) <*> n =<< (return y)
08:30:21 <Nafai> <rant>qwe1234 on reddit is annoying</rant>
08:30:28 <geezusfreeek> Nafai, :)
08:30:30 <Cale> Nafai: no, really?
08:30:52 <Nafai> :)
08:31:01 <geezusfreeek> at least he's not really going to scare anybody away from haskell like that
08:31:28 <geezusfreeek> what would scare people away is if he claimed to frequent #haskell
08:31:37 <dino-> I gave a really awful talk on H at work, I was worried about exactly that: giving people reason to dismiss it. :(
08:32:09 <quicksilver> of course <$> = `fmap` and <*> = `ap`
08:32:16 <quicksilver> but the =<< is a bit odd
08:32:27 <quicksilver> that's why it's a bracketing thing, in some sense
08:32:56 <Nafai> So, on a slightly more on-topic subject...I was re-reading The Pragmatic Programmer last night.  What I was reading in the section on Design By Contract sounded like most of that sort of thing was covered (or could be covered) by the features Haskell provides (type system, functional language, etc)
08:33:27 <quicksilver> it's a mistake to think a type system will ever be your *entire* contract, for large programs
08:33:37 <osfameron> hehe "no c++, no google. no google, and the internet would consist of nothing but lisp trolling on usenet."
08:33:50 <Botje> Nafai: yup. there's eg the no-XSS-by-types post by tmoertel
08:33:57 <quicksilver> but, type systems really help with the design by contract
08:34:19 <quicksilver> and a lot of the dependent types work can be seen as 'how complex a contract can we express in our types' ?
08:34:37 <quicksilver> quickCheck properties are quite nice contracts too
08:34:48 <Botje> someone also used types to enforce REST (GET requests can't do anything destructive)
08:35:02 <dino-> I think you're right. At my job we have a monstrous amount of Perl, all of it OO. And I feel like we've used the faked objects you can do with Perl to hack together a type system.
08:35:12 <quicksilver> that's relatively simple to achieve
08:35:20 <quicksilver> (the REST/GET thing)
08:35:29 <twanvl> About that example, why not:  join $ l <$> m <*> pure x <*> n <*> pure y
08:35:41 <quicksilver> twanvl: yeah, that's fine too
08:35:44 <Nafai> quicksilver: Sure, it's not the entire contract, but it sure gives a lot more out of the box than other langauges
08:35:50 <quicksilver> Nafai: definitely
08:36:56 <geezusfreeek> i think the problem with dependent types is just the notation we have for them right now. we could probably get a lot more use out of them if we crafted a better notation
08:37:09 <geezusfreeek> (not that i have a clue what that notation would be like)
08:37:20 <quicksilver> that is true of so much of maths + CS
08:37:25 <quicksilver> notation is so important
08:37:30 <quicksilver> human brains are very limited
08:37:41 <quicksilver> choose the right notation so the human can really see what's going on
08:37:50 <quicksilver> and you solve problems much more effectively
08:38:44 <Cale> @pl (\x -> x^3 + 5*x^2 + 3*x + 12)
08:38:44 <lambdabot> (12 +) . ap ((+) . liftM2 (+) (^ 3) ((5 *) . (^ 2))) (3 *)
08:39:03 <geezusfreeek> yuck
08:39:23 <Cale> (On the "choose the right notation" point)
08:39:39 <quicksilver> yes :)
08:40:59 <ari> @.unpl pl (\x -> x^3 + 5*x^2 + 3*x + 12)
08:41:00 <lambdabot> pl (\ x -> (((x ^ 3) + (5 * (x ^ 2))) + (3 * x)) + 12)
08:41:09 <ari> @. unpl pl (\x -> x^3 + 5*x^2 + 3*x + 12)
08:41:10 <lambdabot> (\ m -> 12 + (((\ v -> (+) (((\ g -> g ^ 3) >>= \ c -> (\ y -> 5 * (y ^ 2)) >>= \ b -> return (c + b)) v)) >>= \ o -> (\ j -> 3 * j) >>= \ n -> return (o n)) m))
08:41:38 <quicksilver> if only pl (well, unpl) had type inference
08:41:40 <quicksilver> then it wouldn't do that
08:41:47 <Cale> @. redo . unpl pl (\x -> x^3 + 5*x^2 + 3*x + 12)
08:41:48 <lambdabot> (\ m -> 12 + ((do { o <- (\ v -> (+) ((do { c <- (\ g -> g ^ 3); b <- (\ y -> 5 * (y ^ 2)); return (c + b)}) v)); n <- (\ j -> 3 * j); return (o n)}) m))
08:43:20 <osfameron> ooo, the epigram ydtm paper is cute (i.e., I don't understand it but it has some jokes)
09:01:34 <ndm> ydtm?
09:02:47 <quicksilver> ndm: y dependent types matter
09:02:50 <quicksilver> I imagine
09:02:59 <ndm> i might have got that with a w ;)
09:03:09 <ndm> i still think they are wrong, of course ;)
09:04:06 <EvilTerran> anyone know what's going on at AngloHaskell about?
09:04:15 <EvilTerran> *who knows
09:04:56 <EvilTerran> I might only be able to make one of the two days, and was wondering which (if either) would be the more important/interesting
09:06:41 <EvilTerran> ah, there's a timetable on the site. ignore me.
09:15:39 <ndm> EvilTerran: friday is talking/thinking, saturday is more socialising
09:15:44 <malsyned> So I see a lot of code out there that indents if, then, and else to the same level.  Also, the emacs haskell mode does that.  Usually it works, but if the if is the final line of some 'do' syntax, then it causes parse errors.  What's the preferred way to indent and place line breaks in that circumstance?
09:15:53 <lament> friday is drinking, saturday is tripping!
09:15:57 <ndm> EvilTerran: come to Friday if you can, but there will be plenty of space for Haskell thoughts on Saturday
09:16:22 <SamB> ndm: got my patch?
09:16:25 <ndm> last year I was only able to attend Saturday, and it was still worth it, although Friday would have been better
09:16:27 <EvilTerran> okay, Friday it is. i might see if the YHA hostel has space for that night - if so, i could do saturday too
09:16:35 <ndm> SamB, yes, give me a sec to apply
09:17:02 <ndm> malsyned: its still under debate, the solution is to fix the language, which is being done for Haskell' to allow this
09:17:25 <ndm> SamB, have you/are you going to release your library?
09:17:43 <SamB> ndm: well, it wasn't so much the applying that I was eager for as a suggestion as to how I can make my derivings available for anything besides splicing
09:17:56 <SamB> without making 14 trivial modules
09:17:57 <ndm> SamB, the deriving program does that for you
09:18:10 <malsyned> ndm: so in the meantime, is there some kind of best-practice?  I have just been indenting the 'then' and 'else' lines one space more than the 'if', but this is vaguely unsatisfying.
09:18:15 <ndm> i didn't understand the "14 trivial modules" at all
09:18:20 <SamB> sorry.
09:18:22 <SamB> lets see...
09:18:54 <ndm> malsyned: i indent then and else one more level than the if, its not satisfying, but  its not too bad
09:19:08 <SamB> let me paste my library module so far...
09:19:44 <hpaste>  SamB pasted "Data.FieldAccess" at http://hpaste.org/2054
09:20:24 <SamB> ndm: so I have 7 classes, see?
09:20:56 <ndm> SamB, 7 indpendent classes, or 7 classes which might be derived?
09:21:05 <sfultong> yeah, I indent then and else one more level than if too... I guess we all should really be using case statements
09:21:09 <SamB> ndm: they aren't independant
09:21:31 <ndm> SamB, if you do a derivation, it can derive as much as you want, in one derivation
09:21:38 <SamB> ndm: yeah.
09:21:56 <ndm> which means you need only one derivation, it just might derive quite a bit?
09:22:13 <malsyned> sfultong: a case statement wouldn't be very handy in my case, which is "if var /= val1 && var /= var2 then mzero else return <.....>"
09:22:54 <ndm> SamB, i think to add it so it works from the command line you just need to modify the All file, and the .cabal file
09:23:02 <ndm> the rest gets done for you
09:23:14 <SamB> ndm: I doubt it
09:23:24 <ndm> SamB, i think thats the way it works...
09:23:51 <SamB> ndm: well as it is I actually have two derivings, each taking an Int
09:24:40 <SamB> one derives Field classes 1 through n, the other only derives the Field class for that n
09:25:20 <ndm> hmm, you currently can't parameterise a deriving
09:25:31 <SamB> yeah.
09:25:47 <ndm> so, are you saying you need to parameterise derivings?
09:26:04 <SamB> and the "derive" program seems to generate a script that imports a module named base on the class you want to derive, right?
09:26:10 <ndm> yep
09:26:20 <ndm> well, it doesn't import a module, it calls the function
09:26:28 <ndm> so you can export all the classes from one module, that is fine
09:26:38 <ndm> although, it really sounds like parameterised derivings is the right way to go
09:26:43 <SamB>                    concat [ "import Data.Derive." ++ cls ++ "\n" | (_, cls) <- r
09:26:43 <SamB> eqs ] ++
09:26:51 <SamB> hmm, sorry, folded a bit
09:27:05 <SamB> but what's that do, if not generate imports based on the class names?
09:27:05 <ndm> hmm, if you changed that to import Data.Derive.All, i'm pretty sure it would still work
09:27:20 <ndm> possibly more reliably as well :)
09:27:48 <SamB> are there tests?
09:28:01 <ndm> no :)
09:28:08 <ndm> i'd accept a patch for that too!
09:29:41 <SamB> I don't really know what you'd want to test :-(
09:30:11 <SamB> I guess you'd need the relevant libraries?
09:30:21 <lament> i can't believe the haskell report actually calls the significant whitespace behaviour "the off-side rule"
09:30:33 <SamB> er, wait.
09:30:36 <lament> that is so wrong, i mean right
09:30:38 <SamB> lament: does it?
09:30:45 <lament> "Informally stated, the braces and semicolons are inserted as follows. The layout (or "off-side") rule takes effect whenever the open brace is omitted after the keyword where, let, do, or of. "
09:30:50 <SamB> oh.
09:30:58 <SamB> they mention the name because other people have used it, I guess.
09:31:12 <lament> i wasn't aware, but it's a cool name :)
09:31:47 <tim__> Hi all, I was wondering if there is an easy way to invoke ghci from the command line and get it to execute a script (or at least an expression)?
09:32:00 <ndm> tim__ runghc
09:32:17 <ndm> runghc -e (print "hello tim")
09:32:17 <SamB> for expressions, ghc -e
09:32:21 <tim__> ndm: thanks
09:32:21 <ndm> that might work
09:32:28 <SamB> ndm: parens?
09:32:32 <SamB> what shell do you use?
09:32:57 <tim__> SamB: I can use any shell (tchsh, bash)
09:33:10 <SamB> I want to know what shell ndm uses
09:33:19 <SamB> because that's seems like funky syntax
09:33:21 <ndm> SamB, a single sample file, with deriving ({-! Eq !-}), {-# OPTIONS_DERIVE --derive=Foo #-}, lots of different data types and lots of derivings - then diff it
09:33:33 <SamB> ndm: oh.
09:33:34 <ndm> SamB, thats not real shell syntax, i don't use a shell that much
09:33:52 <ndm> SamB, nothing complex, just something simple
09:33:54 <SamB> ndm: you want the tests to fail whenever the layout of the output changes?
09:34:17 <ndm> SamB, i would be happy with them failing once in a blue moon, then letting us commit the revised test after checking it
09:34:34 <SamB> I guess that would work okay.
09:34:58 <ndm> you can either add Field1..Field7 derivings
09:35:05 <ndm> or add proper parameterisation for Field support
09:35:28 <ndm> if you go for 1..7 explicitly, then when proper parameterised derivings are done, they'll be moved over
09:35:31 <SamB> I think I'll do the .All thing, and just export individual variables for each deriving
09:35:45 <ndm> ok, easiest for now
09:36:00 <SamB> 14 extra exported variables is less messy than 14 modules ;-)
09:36:10 <ndm> can you please make FieldAccess/makeFieldAccess, or Field/makeField, just so they are consistent
09:36:43 <ndm> hmm, i wonder if you can actually use Arbitrary2 from the tool...
09:36:50 <ndm> looks like it wouldn't work
09:37:08 <ndm> since its Arbitrary2/makeArbitrary
09:37:36 <SamB> ndm: hmm.
09:38:03 <SamB> so what should the test directory be called?
09:38:05 <SamB> test or tests?
09:38:50 <ndm> your choice :)
09:39:12 <ndm> you could do one big test file, and one small one, which only derived things for which there are instances available in a standard GHC distro
09:39:27 <ndm> then you can additionally type check the small test file, and type checking is a reasonable check that it worked
09:39:49 <ndm> i tend to pick test, since i equally pick src, and not srcs
09:39:57 <SamB> tests seems to be more popular
09:40:13 <ndm> who am i to swim against the trend
09:40:21 <ndm> both are pretty unambiguous
09:40:51 <SamB> it might be like a 3:4 ratio
09:41:19 <SamB> well. I'm using a very small collection of directories...
09:52:01 <desp> what would be the most efficient way to write factorial?
09:52:14 <desp> > fac n = foldl' (*) 1 [1..n] in fac 10
09:52:14 <lambdabot>  Parse error
09:52:24 <desp> > let fac n = foldl' (*) 1 [1..n] in fac 10
09:52:26 <lambdabot>  3628800
09:53:04 <lament> write it in assembly and interface from haskell? :)
09:53:11 <desp> heh
09:53:24 <desp> no, not like that. :)
09:53:29 <shachaf> lament: The FFI is quite slow, I understand.
09:53:59 <shachaf> lament: (Of course, you could write the entire program in assembly and just call it from main.)
09:54:13 <lament> hehe
09:54:21 <lament> "teach yourself haskell in one easy step (if you already know assembly)"
09:54:34 <mwc> Sigh, I wonder if it's too late to submit tuple patterns to the Haskell' process
09:55:04 <DRMacIver> tuple patterns?
09:55:52 <mwc> I find myself doing something like zip (map f xs) (map g xs) a lot, being able to do something like: map (`f` foo, `g` bar) xs would save alot of time
09:56:16 <mwc> ie, a tuple pattern becomes a function a -> (b,c)
09:56:39 <DRMacIver> Why not use the arrow combinators?
09:57:09 <mwc> DRMacIver: haven't managed to learn arrows yet
09:57:13 <mwc> but I suspect I should at some point
09:57:27 <DRMacIver> Conveniently, I have an article on just that subject! http://unenterprise.blogspot.com/2007/08/playing-with-arrows.html
09:57:28 <lambdabot> Title: Desperately UnEnterprise: Playing with Arrows
09:57:30 <DRMacIver> :)
09:57:45 <DRMacIver> (Specifically, how you don't need to understand arrows to make use of them for pure functions)
09:57:57 <DRMacIver> In particular:
09:58:21 <DRMacIver> > map $ (+1) &&& (+2) $ [1..5]
09:58:22 <lambdabot>  Couldn't match expected type `a -> b'
09:58:27 <DRMacIver> Hm. I always get that wrong.
09:58:34 <DRMacIver> > (map (+1) &&& (+2)) [1..5]
09:58:35 <lambdabot>   add an instance declaration for (Num [a])
09:58:38 <shachaf> DRMacIver: $ is infixr. :-)
09:58:41 <DRMacIver> Bah.
09:58:46 <DRMacIver> > map ((+1) &&& (+2)) [1..5]
09:58:48 <lambdabot>  [(2,3),(3,4),(4,5),(5,6),(6,7)]
09:59:18 <DRMacIver> shachaf: Yeah. I never fixities right on lambdabot or ghci for some reason. :)
09:59:43 <shachaf> Perhaps $ should be infixl.
09:59:43 <mwc> I'm surprised a left-associative $ isn't in the prelude
09:59:46 <mwc> dead useful
10:00:26 <mwc> shachaf: nah, $ has a good use as it is, I find it's a lot like building pipelines in shell, but the dataflow in shell is L->R, and in hsakell it's R->L
10:00:31 <mwc> foo $ bar $ baz q
10:00:44 <shachaf> mwc: Well, foo . bar . baz $ q
10:01:08 <mwc> That's true, but my mental model has fixed on & being a mirror image of
10:01:10 <mwc> |
10:01:17 <shachaf> mwc: (Or baz >>> bar >>> foo $ q)
10:01:20 <ddarius> mwc: Arrows come to the rescue again.
10:01:41 <DRMacIver> Heh
10:01:45 <mwc> haha, that was coincidental
10:02:24 <geezusfreeek> DRMacIver, ah, didn't realize you wrote that. nice, clear article
10:02:34 * shachaf must be missing something.
10:02:42 <shachaf> What was coincidental?
10:02:57 <DRMacIver> geezusfreeek: Thanks. :) I actually thought the english in it was a little incoherent, but decided not to worry about it too much given that it was mostly Haskell. :)
10:03:25 * DRMacIver is still surprised how many people liked it though.
10:03:48 * shachaf has already been using the arrow combinators for functions.
10:04:00 <shachaf> I still want to get a more general understanding of arrows.
10:04:10 <geezusfreeek> well, it isn't often you find an article that
10:04:11 <shachaf> Like I can think of many different monads.
10:04:13 <geezusfreeek> oops
10:04:39 <geezusfreeek> *that goes over how to use something without boring you with details and yet still is pretty clear
10:05:09 <geezusfreeek> yeah, i still don't quite see the implications of defining other instances of arrows yet
10:05:10 <DRMacIver> shachaf: Yeah, same.
10:05:11 <ddarius> geezusfreeek: Read Wadler's papers.
10:05:23 <DRMacIver> geezusfreeek: Oh. I just don't have any patience for details. ;)
10:05:40 <shachaf> I don't even exactly understand Kleisli.
10:05:46 * shachaf should use it for a bit.
10:05:52 <ddarius> shachaf: Why not?
10:06:08 <shachaf> ddarius: Because I haven't used it. :-)
10:06:17 <ddarius> shachaf: Me neither, but I understand it.
10:06:18 <shachaf> It makes some sense, though.
10:06:23 <DRMacIver> Anyway, I'm off to the pub. :)
10:06:26 <DRMacIver> Bye
10:06:50 <shachaf> ddarius: Kleisli m b c being an arrow equivalent of b -> m c, yes?
10:07:03 <ddarius> shachaf: Yes.
10:07:06 <geezusfreeek> the hardest thing for me to grasp about haskell sometimes is the fact that understanding the type of something is basically understanding it
10:07:17 <ddarius> @djinn a -> b -> b
10:07:21 <lambdabot> f _ a = a
10:07:21 <geezusfreeek> i always get upset that there isn't more to it
10:09:37 * shachaf should learn some category theory, probably.
10:09:39 <ddarius> geezusfreeek: That's what you get when working with highly polymorphic/abstract types.
10:10:14 <ddarius> shachaf: Probably not, but it's fun.
10:10:23 <shachaf> ddarius: That's what I meant.
10:10:50 <shachaf> ddarius: Not "should" as in "it'd help me with Haskell", but "should" as in "it looks interesting". :-)
10:11:12 <ddarius> shachaf: Any mathematical background or just CS/programming?
10:11:31 <shachaf> ddarius: Not especially.
10:11:42 <shachaf> ddarius: But I'd like to have some. :-)
10:12:10 <ddarius> shachaf: Then this may be a good introduction, http://folli.loria.fr/cds/1999/esslli99/courses/barr-wells.html
10:12:11 <lambdabot> Title: Courses: Barr / Wells
10:12:36 <ddarius> (As far as free online content goes aimed at computer scientists)
10:12:48 <ddarius> (Which is pretty far)
10:13:11 <shachaf> ddarius: It doesn't necessarily need to be aimed at computer scientists either.
10:13:22 * shachaf is not especially a computer scientist.
10:13:39 <ddarius> shachaf: It's nice when the examples are from programming rather than algebraic homology.
10:13:51 <shachaf> By which I mean that I know very little about computer science, compared to others in this channel.
10:14:02 <shachaf> ddarius: Sure, I will look at that, thanks.
10:14:07 <ddarius> shachaf: You know what a state machine is?
10:14:33 <allbery_b> "evaluatation"?  is that like "authentification"?
10:15:17 <shachaf> ddarius: Approximately, but not really. I've seen the term used.
10:15:18 <ddarius> evaluatation is the simplificated version of evaluation
10:15:22 * shachaf reads.
10:15:40 <ddarius> shachaf: You can understand, say, the TCP RFC or some protocol specification?
10:15:56 <ddarius> (Anyways, heck, if you have the lambda calculus you are ahead of most)
10:16:06 <shachaf> ddarius: I don't know, I haven't looked at the TCP RFC.
10:18:08 <ddarius> Well everything in those lecture notes is simple.  It may seem daunting, but it is not.  Many things also have direct analogues to Haskell functions.  If you have questions, ask here.
10:19:05 <ddarius> I'm going back to work now though.
10:19:38 <shachaf> A lot of what I learn is very informal.
10:19:57 <shachaf> And that's often fun, but I also like to understand things thoroughly.
10:20:33 <glguy_> @losers
10:20:33 <lambdabot> Maximum users seen in #haskell: 382, currently: 344 (90.1%), active: 15 (4.4%)
10:26:28 <desp> glguy_: I've found your posts on projecteuler quite enlightening, thanks
10:27:38 <_Nucleo> these are on the wiki?
10:28:14 <desp> _Nucleo: eh?
10:28:19 <desp> what wiki?
10:28:29 <_Nucleo>  desp: the Haskell wiki
10:28:43 <desp> I'm not aware of any euler-related pages on it
10:28:48 <_Nucleo> http://haskell.org/haskellwiki/Euler_problems
10:28:49 <lambdabot> Title: Euler problems - HaskellWiki
10:29:08 <desp> oh.
10:29:20 <desp> nice, thanks.
10:29:25 <glguy> @tell dons this is what I had mentioned http://haskell.org/haskellwiki/Euler_problems
10:29:25 <lambdabot> Consider it noted.
10:29:37 <_Nucleo> sure -- but what pages were you referring to?
10:29:48 <glguy> desp: glad to help :) any problems in particular?
10:29:53 <desp> I was referring to posts on the PE problems' forum
10:29:59 <_Nucleo> ahhh.
10:30:19 <desp> glguy: I'm looking at the general memoization functions for problem 15
10:30:58 <glguy> desp: oh yeah, that's a nifty function
10:31:36 <_Nucleo> do both of you go by different nicks there?
10:31:44 <desp> nope, I'm desp.
10:31:54 <desp> I've just started yesterday, though
10:34:22 <_Nucleo>  they definitely get rapidly harder
10:34:23 <SamB> ndm: should I actually call the file Small.hs, or should I call it Small.hs.in or something?
10:34:42 <glguy> _Nucleo: I go by glguy on Project Euler
10:34:55 <ndm> SamB, Small.hs for the test input, and then Small.txt for the output would be fine by me
10:35:02 <ndm> or rather, expected output
10:35:20 <ndm> perhaps even Small.hs and Small.out.hs, having .hs at the end is useful for seeing syntax colouring
10:35:31 <_Nucleo> glguy: then haskell's not the language you've listed? :)
10:35:37 <SamB> ndm: would GHC would much like either of those?
10:35:50 <ndm> SamB, i'd test that
10:37:23 <glguy> _Nucleo: nope, it is
10:37:50 <_Nucleo> weird -- can't find you for some reason
10:38:20 <glguy> _Nucleo: I have 82% completion
10:38:49 <_Nucleo> :blinks: http://www.projecteuler.net/index.php?section=scores&search_language=Haskell
10:38:52 <lambdabot> Title: Project Euler, http://tinyurl.com/32m75v
10:39:00 <_Nucleo> ah well.
10:39:40 <glguy> maybe its because I haven't done one in ages?
10:39:49 <_Nucleo> yeah, only 180 days worth of active users.
10:39:54 <_Nucleo> that would explain things.
10:40:05 <kilimanjaro> Haskell is pretty much perfect for project euler
10:40:18 <_Nucleo> kilimanjaro: I'm using it to learn Haskell, yes.
10:40:33 <glguy> the language really doesn't matter much, the challenge is to pick a good algorithm
10:40:39 <glguy> but I did enjoy using Haskell
10:41:02 <kilimanjaro> glguy, yea, even so though you get advantages of things being done lazily, just for going from math to code
10:41:24 <kilimanjaro> and list comprehensions are very convenient for many of those problems as well
10:41:58 <kilimanjaro> I mean, language doesn't really matter much, but it might matter if you were using C
10:45:26 <desp> I'm horrified by the J/K programs
10:45:41 <desp> I think those letters stand for "just kidding"
10:46:07 <desp> I thought APL was good and dead
10:47:00 <_Nucleo> yeah. I thought Perl with line-noise-y, but those take the cake.
10:50:09 <cjeris> desp: Bad C# programmers get to debug J for eternity in hell
10:50:23 <desp> :D
11:03:14 <SamB> hmm. cabal isn't too test-friendly...
11:03:29 <SamB> you have to install something before testing :-(
11:03:38 <SamB> well.
11:03:55 <SamB> yeah. you do.
11:05:18 <desp> "Hey guys! The solution that uses factorials is a slick trick, but I don't believe it's as efficient as traversing the grid and caching the number of paths from a given node." heh
11:06:48 <_Nucleo> spoken like someone who's never heard of combinatorics :)
11:07:17 <glguy> desp: which problem ID was that?
11:07:26 <desp> 15
11:08:04 <glguy> --I've heard that this problem can be solved with only one single expression, using a branch of mathematics called 'combinatorics', 'combinatory math' or something equivalent.
11:08:07 <glguy> Is anybody familiar with this?
11:08:12 <_Nucleo> hehe
11:08:13 <desp> ;)
11:08:19 <glguy> heh, that was the first forum post
11:08:29 <desp> those forums could use a little reworking
11:08:40 <desp> i.e. search
11:08:45 <_Nucleo> those problems got me to idle in #math a lot more.
11:08:49 <glguy> they used to be one page per problem
11:09:27 <desp> some moderation maybe, too
11:10:03 <SamB> hmm. I wrote some tests for Derive, and guess what?
11:10:09 <_Nucleo> It's surprisingly civil and noise free...
11:10:18 <glguy> desp: http://projecteuler.net/index.php?section=forum&id=15&page=5  looks like I came to that realization too
11:10:19 <lambdabot> Title: Forum 15 - Project Euler
11:10:29 <glguy> (search for glguy if interested)
11:10:48 <desp> _Nucleo: yeah, just very repetetetive
11:11:23 <desp> glguy: yeah, I read that :)
11:12:06 <Saizan> SamB: they fail?
11:13:36 <_Nucleo> embarrassingly, I first tried to find the catalan number for that problem. Heh.
11:13:52 <lament> hugs claims to come with a parsec package
11:14:07 <lament> is it true? import Parsec doesn't work
11:14:23 <oerjan> lament: Text.ParserCombinators.Parsec
11:14:30 <allbery_b> or run in -98 mode
11:14:55 <lament> thanks
11:15:02 <lament> -98 means without 98?
11:15:23 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:15:46 <allbery_b> -98 is haskell98 mode
11:16:13 <allbery_b> +98 is haskell with extensions, most significantly in this case the hierarchival library extension
11:16:17 <allbery_b> er, hierarchical
11:16:32 * lament checks
11:16:40 <lament> nope, i'm right
11:16:52 <lament> allbery_b: the other way around.
11:17:00 <allbery_b> hrm.  haven't used hugs in years, probably got them backwards
11:17:20 <allbery_b> in any case, in haskell98 mode it's Parsec, in extended mode it's Text.ParserCombinators.Parsec
11:17:28 <oerjan> it _would_ be weird if +98 meant not haskell 98
11:17:32 <lament> then something's fishy
11:17:37 <lament> because it's haskell98 by default.
11:18:10 <allbery_b> hm, did hugs go the unbundling route like ghc is starting to, then?
11:18:17 <SamB> Saizan: the deriving for Read was broken!
11:18:50 <oerjan> checking with WinHugs, it's the whole hierarchy even in H98 mode
11:19:14 <lament> i suppose looking at the hierarchical library page makes it pretty clear that there's no "Parsec" in the top level
11:19:26 <oerjan> Parsec is after all not a report Haskell 98 module
11:19:55 <oerjan> lament: that doesn't help, List isn't top level on that page either
11:20:06 <oerjan> only Numeric and Prelude, iirc
11:20:24 <oerjan> @where report
11:20:24 <lambdabot> http://www.haskell.org/onlinereport/
11:20:38 <oerjan> look there for the H98 standard modules
11:21:18 <lament> okay, this better be easy
11:21:22 * lament plunges into parsec
11:21:35 <oerjan> nearly all of them have got hierarchical names afterwards
11:21:59 <glguy> desp: I revised my J solution :)
11:22:03 <glguy> x: 20 ! 40
11:22:25 <desp> hehe
11:22:32 <SamB> hmm. I seem to have made a bad fix
11:22:38 <desp> is : an operator?
11:22:43 <oerjan> desp: no
11:22:45 <SamB> @tell ndm hmm, I didn't fix Read right.
11:22:45 <lambdabot> Consider it noted.
11:22:56 <mauke> depends on your definition of "operator"
11:22:59 <glguy> anything that starts with : is a data constructor
11:23:14 <oerjan> it's special syntax, which works almost like an ordinary infix data constructor
11:23:29 <oerjan> except that it cannot be redefined
11:23:34 <desp> wait. I'm actually asking about this J example glguy wrote
11:23:36 <desp> :)
11:23:59 <glguy> desp: oh, lol
11:24:10 <glguy> desp:   x:  means use extended precision
11:24:15 <Tac-Work> @type (:) (:) [(:)]
11:24:15 <oerjan> @beat desp
11:24:16 <lambdabot> Maybe you meant: keal let read what
11:24:17 <lambdabot> forall a. [a -> [a] -> [a]]
11:24:19 <glguy> but I have *since* revised my solution!
11:24:21 <glguy> 20!40x
11:24:29 <oerjan> @slap desp
11:24:30 * lambdabot beats up desp
11:25:03 <glguy> J is pretty much the ideal project euler language
11:25:04 <oerjan> @list slap
11:25:04 <lambdabot> slap provides: slap
11:25:10 <oerjan> @help slap
11:25:10 <lambdabot> slap <nick>. Slap someone amusingly.
11:25:18 <xerox> glguy: what's J?
11:25:28 <shachaf> @go jsoftware
11:25:31 <lambdabot> http://www.jsoftware.com/
11:25:31 <lambdabot> Title: J Home
11:25:33 <glguy> xerox: J is a modern, high-level, general-purpose, high-performance programming language.
11:25:59 <desp> oerjan: ouch
11:26:17 <lament> @slap God
11:26:17 <desp> glguy: ouch
11:26:17 * lambdabot smacks God about with a large trout
11:26:38 <SamB> @hoogle readParen
11:26:39 <lambdabot> Prelude.readParen :: Bool -> ReadS a -> ReadS a
11:27:14 <_Nucleo> Isn't J mainly used for golfing?
11:27:19 <Tac-Work> @slap himself
11:27:20 <lambdabot> why on earth would I slap himself
11:27:23 <Tac-Work> heh
11:27:24 <xerox> Let's have @J
11:27:26 <Tac-Work> smartass bot
11:27:36 <desp> almost
11:27:41 <desp> @slap myself
11:27:41 * lambdabot smacks myself about with a large trout
11:27:53 <glguy> xerox: that wouldn't be hard to do either, since anything that does IO in J must use a foreign function
11:27:58 <glguy> so we could simply strip those away
11:28:05 <shachaf> Tac-Work: Lambdabot would be "herself". :-)
11:28:07 <shachaf> @botsnack
11:28:07 <lambdabot> :)
11:28:14 <glguy> (foreign function is a function in J still but a specific one)
11:28:18 <shachaf> @karma lambdabot
11:28:18 <lambdabot> lambdabot has a karma of -1
11:28:19 <xerox> Cool. Going for it, glguy ? (-:
11:28:21 <shachaf> lambdabot++
11:28:25 <mauke> @vixen do you like mudkips?
11:28:25 <lambdabot> yah, i like
11:28:40 <nominolo> how can i change the description of an already recorded patch in darcs?
11:28:47 <nominolo> i don't want to unrecord
11:28:52 <lament> mm, i like parsec already
11:28:54 <Tac-Work> @slap itself
11:28:54 * lambdabot beats up itself
11:28:56 <glguy> darcs amend-record
11:28:57 <glguy> ?
11:28:57 <Tac-Work> hah
11:29:08 <Tac-Work> I beat the bot by having the bot beat itself
11:29:14 <nominolo> glguy: doesn't allow me to just change the description
11:29:25 <shachaf> Tac-Work: Lambdabot isn't an "it"!
11:29:36 <xerox> Oh, I didn't know amend-record, another nice thing.
11:29:40 <shachaf> @where lambdabot
11:29:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:29:42 <oerjan> -1? did someone reset it?
11:29:49 <oerjan> @karma
11:29:49 <lambdabot> You have a karma of 0
11:29:53 <shachaf> @karma-all -- All the karma was reset.
11:29:53 <lambdabot>  "agentz"               31
11:29:54 <lambdabot>  "moritz"               27
11:29:54 <lambdabot>  "+"                    15
11:29:54 <lambdabot>  "masak"                 9
11:29:54 <lambdabot>  "der_eq"                5
11:29:54 <Tac-Work> @karma
11:29:55 <lambdabot> [66 @more lines]
11:29:57 <lambdabot> You have a karma of 0
11:30:00 <shachaf> @karma
11:30:03 <lambdabot> You have a karma of 0
11:30:05 <nominolo> @karma
11:30:07 <lambdabot> You have a karma of 1
11:30:08 <wilx> @karma
11:30:11 <lambdabot> You have a karma of 0
11:30:14 <wilx> :/
11:30:17 <oerjan> waaah!
11:30:20 <nominolo> that used to be better ...
11:30:23 <desp> @karma
11:30:23 <monochrom> @karma
11:30:23 <lambdabot> You have a karma of 1
11:30:24 <lambdabot> You have a karma of 0
11:30:30 <xerox> #perl6 guys have that bot that spits <nick> ++ once every two minutes :)
11:30:33 <monochrom> it's ok :)
11:30:36 <shachaf> oerjan: The best way to get it back is to contribute to Pugs. :-)
11:30:44 <nominolo> @karma java
11:30:44 <lambdabot> java has a karma of 0
11:30:49 <nominolo> O_O
11:30:58 <nominolo> it used to be -40 or sth
11:31:00 <monochrom> it's ok :)
11:31:04 <glguy> ?karma
11:31:04 <lambdabot> You have a karma of 0
11:31:05 <glguy> :(
11:31:37 <monochrom> java is not terrible. just not so desirable. no point having negative karma.
11:31:50 <nominolo> @karma++ java
11:31:50 <lambdabot> nominolo's karma lowered to 0.
11:31:55 <nominolo> see?
11:31:56 <shachaf> monochrom: Well, Java never has positive karma.
11:32:00 <oerjan> shachaf: what? my first thought was that the pugs mess would be the only reasonable reason for resetting it...
11:32:11 <int-e> @karma++ nominolo
11:32:11 <lambdabot> nominolo's karma raised to 1.
11:32:22 <nominolo> ta
11:32:23 <Tac-Work> Do you ever feel like thinking about a language bring about thoughts of a certain color to your mind?
11:32:30 <Tac-Work> Like... every language has its own color?
11:32:38 <Tac-Work> When I hear Java, I think a pale yellow color
11:32:42 <monochrom> No.
11:32:46 <Tac-Work> =-P
11:33:00 <dylan> most words / numbers have a color ....
11:33:08 <dylan> and/or a shape.
11:33:43 <nominolo> some people see colors when they listen to music
11:33:56 <nominolo> or associate a taste
11:34:26 <oerjan> http://en.wikipedia.org/wiki/Synesthesia
11:34:28 <lambdabot> Title: Synesthesia - Wikipedia, the free encyclopedia
11:34:31 <nominolo> those people are supposed to be rather talented musicians
11:34:40 <mauke> are you synaesthesizing again?
11:34:50 <lament> dylan: and a grammatical gender :D
11:35:25 <dylan> not in english
11:35:39 <dylan> At least, not for me.
11:36:06 <sjanssen> should we ignore #perl6's auto-karma bot?
11:36:35 <sjanssen> karma really doesn't mean as much when it's not coming from a real person
11:36:46 <lament> dylan: now imagine a language with grammatical colour and grammatical shape :)
11:37:06 <sjanssen> @karma-all
11:37:06 <lambdabot>  "agentz"               31
11:37:06 <lambdabot>  "moritz"               27
11:37:06 <lambdabot>  "+"                    15
11:37:06 <lambdabot>  "masak"                 9
11:37:06 <lambdabot>  "der_eq"                5
11:37:08 <lambdabot> [66 @more lines]
11:37:10 <lament> (swahili partially has something like that)
11:37:44 <nominolo> who are those?
11:37:54 <geezusfreeek> java is green, haskell is brown, ruby is red, perl is yellow, c is blue, d is green, io is black, lisp is gray
11:37:56 <desp> lament: cool.
11:37:57 <nominolo> (re the karma stats)
11:38:06 <allbery_b> pugs folk
11:38:08 <desp> lament: although grammatical gender is enough trouble as it is
11:38:11 <mauke> except for +
11:38:52 <nominolo> +++
11:39:01 <nominolo> @karma +
11:39:01 <lambdabot> + has a karma of 16
11:39:15 <int-e> @karma -
11:39:15 <lambdabot> - has a karma of -10
11:39:18 <int-e> fun
11:39:22 <nominolo> @karma +
11:39:22 <lambdabot> + has a karma of 16
11:39:34 <nominolo> @karma+++
11:39:34 <lambdabot> usage @karma(+|-) nick
11:39:37 <int-e> we need operators called -++ and +-- somewhere :)
11:39:40 <sjanssen> hmm, when do people type "---"?
11:40:02 <oerjan> @index ---
11:40:03 <lambdabot> bzzt
11:40:05 * allbery_b habitually does so (TeX em-dash)
11:40:08 <oerjan> @index (---)
11:40:08 <lambdabot> bzzt
11:40:09 <sjanssen> > replicate 3 "+" -- is an arrow operator, right?
11:40:11 <lambdabot>  ["+","+","+"]
11:40:36 <oerjan> @karma --
11:40:37 <lambdabot> -- has a karma of 0
11:40:50 <nominolo> @karma perl
11:40:50 <lambdabot> perl has a karma of 0
11:42:51 <shachaf> > ((+1) +++ toLower) (Left 3)
11:42:53 <lambdabot>  Left 4
11:42:57 <shachaf> > ((+1) +++ toLower) (Right 'A')
11:42:58 <lambdabot>  Right 'a'
11:43:24 <shachaf> @karma +
11:43:24 <lambdabot> + has a karma of 17
11:43:33 <xerox> Generalized maybe/either/<insert-right-prefix>morphism ?
11:43:35 <nominolo> did dons start a new arrows hype?
11:44:02 <xerox> No, just Either, oh well.
11:44:28 <nominolo> @hoogle (Bool -> Either a)
11:44:28 <lambdabot> No matches, try a more general search
11:44:53 <SamB> so is : like the prime of operators or something?
11:45:16 <nominolo> @hoogle (Bool -> Either a b)
11:45:17 <lambdabot> No matches, try a more general search
11:45:17 <sjanssen> SamB: huh?
11:46:06 <SamB> see derive's Language.Haskell.TH.Helper
11:48:10 <equant> Does anyone in here know Tim Smith's nick?
11:48:20 <sjanssen> SamB: I dunno, that is a bit weird
11:58:20 <conal> question for QuickTesters: has anyone factored out laws for type classes (Monoid, Applicative, ...) as QC properties?  I'm doing some of that factoring on my own, but there I think there could be a shareable library.
12:07:48 <shachaf> Perhaps the @karma reset was a plot by the #perl6-ers to get more people to contribute.
12:08:28 <oerjan> @quote
12:08:29 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
12:08:45 <shachaf> @quote OlegFacts
12:08:46 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
12:08:49 <shachaf> @quote OlegFacts
12:08:49 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
12:08:57 <shachaf> The rest are gone. :-(
12:09:06 <zbrown> @quote zbrown
12:09:06 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:09:08 <oerjan> @quote oleg
12:09:08 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
12:09:10 <zbrown> :-O
12:09:17 <zbrown> @quote rufius
12:09:17 <lambdabot> No quotes match. My pet ferret can type better than you!
12:09:22 <zbrown> @quote suifur
12:09:23 <lambdabot> No quotes match. The more you drive -- the dumber you get.
12:09:26 <zbrown> :-O
12:09:41 <oerjan> someone reset lambdabot completely?
12:09:41 <shachaf> @arrow
12:09:41 <lambdabot> Avast!
12:09:54 <SamB> @quote
12:09:54 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
12:10:02 <shachaf> oerjan: Not completely, she still has some memories.
12:10:23 <SamB> shachaf: so what's gone?
12:10:30 <shachaf> "Thinking of Maud, you forget everything else."
12:10:46 <shachaf> SamB: All the karma, some @quotes, at least.
12:10:53 <shachaf> Some @wheres, I think.
12:11:00 <shachaf> SamB: I don't know about the rest.
12:11:05 <SamB> how did they get gone?
12:11:15 <shachaf> SamB: Ask dons, maybe.
12:11:42 <Tac-Work> @slap Tac-Work
12:11:42 * lambdabot beats up Tac-Work
12:11:47 <shachaf> lambdabot: "Who was that Maud person anyway?"
12:12:22 <kpreid> what?! quotes reset?!
12:12:36 <shachaf> kpreid: Not reset.
12:12:41 <shachaf> kpreid: But some of them are gone.
12:12:44 <shachaf> @quote
12:12:44 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
12:12:50 <shachaf> @quote stereo
12:12:50 <lambdabot> No quotes match. Do you think like you type?
12:12:56 <kpreid> but MY quote is gone!!!
12:12:57 <kpreid> :)
12:13:01 <shachaf> @quote kpreid
12:13:01 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:13:44 <monochrom> Arrow scientist.
12:13:55 <shachaf> Generalizing spears to rockets?
12:14:00 <shachaf> @quote spear
12:14:00 <lambdabot> No quotes match. Are you on drugs?
12:14:02 <shachaf> :-(
12:15:08 <Tac-Work> lambdabot showed you shachaf
12:15:29 <shachaf> Tac-Work: Showed me?
12:17:37 <Tac-Work> yes, it brought into question your drug use
12:19:30 * SamB wonders if the tests for Derive will need to use some kind of AST-based equality to compare the actual results with the expected results
12:19:46 <earthy> @quote sorear
12:19:46 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
12:19:46 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
12:20:27 * SamB wonders how you could man #haskell in C
12:20:43 <SamB> @quote
12:20:43 <lambdabot> Renkin says: Is lambdabot omnipotent or something?
12:20:45 <shachaf> @quote snark
12:20:45 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:20:53 <nn-bluetooth-2> hi SamB
12:21:01 <SamB> nn-bluetooth-2: oh, hello
12:21:21 <SamB> nn-bluetooth-2: I don't suppose you actually came to ask about Haskell?
12:21:36 <basti_> ;D
12:21:59 <SamB> basti_: he's a friend of mine. I told him this was a good place to find me ;-)
12:22:04 <basti_> lol ok
12:22:06 <shachaf> @protontorpedo
12:22:07 <lambdabot> hey guys can haskeel be used to produce fast webapps?
12:22:40 <sjanssen> @girl19
12:22:40 <lambdabot> I'm in Moscow, Russia
12:22:42 <sjanssen> @keal
12:22:42 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
12:22:46 <sjanssen> @palomer
12:22:46 <lambdabot> Hrmph, looks like I killed the channel
12:22:51 <sjanssen> @b52s
12:22:52 <lambdabot> Hot pants explosion at the factory!
12:22:55 <sjanssen> @yow
12:22:55 <lambdabot> Quick, sing me the BUDAPEST NATIONAL ANTHEM!!
12:23:06 <shachaf> @ghc
12:23:06 <lambdabot> ghc says: Type found where type variable expected
12:23:39 <oerjan> @vixen
12:23:39 <lambdabot> Are you adopted by trolls?
12:24:13 <allbery_b> huh, lost quotes and karma, got vixen back?
12:24:42 <nominolo> @djinn ((((a->b)->a)->a)->b)->b
12:24:43 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
12:26:47 <nominolo> @seen sorear
12:26:47 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 10h 53m 15s ago, and .
12:26:50 <shachaf> @lambdabot
12:26:50 <lambdabot> Unknown command, try @list
12:27:37 <nn-bluetooth-2> SamB, i got a nother bluetooth & Memory stick device using it now for internet on this laptop i have been able to undersand pand so i have found with in 4 comands i can connect the internet inbetween the computer and the laptop :)
12:31:24 <nn-bluetooth-2> i g2g now SamB
12:31:42 <nn-bluetooth-2> later ...
12:32:08 <sjanssen> hahaha, qwe1234 calling augustss a "cocky but poorly prepared and ignorant d00d" makes for good reading :)
12:32:39 <augustss> I often laugh reading his comments.
12:33:08 * dolio is getting less and less excited about monadic subexpressions.
12:33:34 <sjanssen> dolio: yeah, the "attach to the nearest do" scares me a little bit
12:34:10 <SamB> dolio: what's that?
12:34:20 <dolio> Yeah, Claus Reinke's large mail (which I'm reading now) seems to be expressing my concerns pretty well.
12:35:05 <SamB> @go gmane "monadic subexpressions"
12:35:06 <lambdabot> No Result Found.
12:35:06 <dolio> I'd much rather they put in idiom brackets. They seem like they have less crazy behavior.
12:35:16 <SamB> @go "monadic subexpressions"
12:35:18 <lambdabot> http://www.cs.indiana.edu/hyplan/jsobel/Parsing/explicit.pdf
12:35:22 <SamB> hmm.
12:35:39 <dolio> It's on haskell-cafe. Shouldn't be too hard to find...
12:35:50 <sjanssen> dolio: monadic subexpressions are more powerful, though
12:36:16 <sjanssen> have you ever had to type "do p <- someMonadicPredicate; if p then ... else ..."?
12:36:29 <dolio> http://www.mail-archive.com/haskell-cafe%40haskell.org/msg28129.html <-- SamB
12:36:30 <lambdabot> Title: [Haskell-cafe] monad subexpressions, http://tinyurl.com/3bp5rv
12:36:51 <sjanssen> that becomes "do if $(someMonadicPredicate) then ... else ...", which is pretty nice
12:37:08 <dolio> sjanssen: Not often enough to remember about those, probably.
12:37:29 <sjanssen> dolio: there's a bunch of that sort of code in xmonad
12:37:34 <dolio> Ah.
12:38:14 <dolio> Anyhow, answers to questions like "what does 'do b >> f (<- a)' do?" worry me a bit.
12:38:15 * roconnor glances at the mail-archive message
12:38:32 <roconnor> what's wrong with simply typing f <$> x <*> y, or whatever?
12:38:53 <dolio> Since the answer seems to be 'do x <- a ; b >> f x', whereas 'do b ; f (<- a)' is 'do b ; x <- a ; f x', I assume.
12:38:53 <roconnor> if' <$> p <*> case1 <*> case 2
12:40:32 <sjanssen> roconnor: and what happens when we replace 'if' with a complicated case expression?
12:47:59 <malsyned> Is there any way to run an external program by giving a list of arguments, rather than just a single command line?  something like system but with type [String] -> IO ReturnCode?
12:48:16 <mauke> @hoogle String -> [String] -> IO a
12:48:17 <lambdabot> No matches, try a more general search
12:48:35 <malsyned> yeah, I tried hoogle.
12:49:04 <malsyned> Seems like a pretty crucial thing to have for system scripting.  I just sortof expected it from my years of perl.  Even C has execvp.
12:49:05 <SamB> 'twould be more likely to exist if C had one :-(
12:49:14 <mauke> @hoogle String -> [String] -> IO ExitCode
12:49:14 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
12:49:18 <Baughn> @src Ord
12:49:19 <lambdabot> class  (Eq a) => Ord a  where
12:49:19 <lambdabot>     compare      :: a -> a -> Ordering
12:49:19 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:49:19 <lambdabot>     max, min         :: a -> a -> a
12:49:23 <SamB> malsyned: execvp is unix-only
12:49:30 <mauke> malsyned: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Cmd.html
12:49:32 <lambdabot> http://tinyurl.com/yg2s4l
12:49:34 <mauke> also, Haskell has execvp
12:49:40 <Baughn> Ah. It strikes me that when I instance Eq, I should probably instance Ord as well, yes?
12:50:07 <malsyned> rawSystem looks like exactly what I want.
12:50:16 <SamB> Baughn: only if Ord is reasonable
12:50:36 <pastorn> does Ord require instance of Eq?
12:50:42 <Baughn> SamB: True, but the type in question is currently /deriving/ ord
12:50:58 <SamB> Baughn: you maybe said the reverse of what you meant?
12:51:32 <Baughn> malsyned: malsyned Or runInteractiveProcess, maybe
12:52:12 <Baughn> SamB: Pretty sure it goes both ways. I've overridden Eq, but it still derives Ord, so a<b and a==b can both be true at the moment..
12:52:28 <Baughn> Right. Have to fix that.
12:52:34 <SamB> Baughn: oh, now I get what you mean
12:52:53 <SamB> you should indeed make sure that Eq and Ord behave consistantly with eachother ;-)
12:53:25 <malsyned> Thanks guys
12:55:25 <hpaste>  jo_devR pasted "soe ex3.2" at http://hpaste.org/2055
12:55:41 <jo_devR> hi
12:55:52 <jo_devR> i was going through soe and did ex 3.2
12:56:05 <jo_devR> i was just wondering how i could make somthing better
12:56:10 <glguy> !paste
12:56:10 <hpaste> Haskell paste bin: http://hpaste.org/
12:56:59 <jo_devR> in my code call a function 3 times in a row incrementing an index in each call
12:57:05 <roconnor> @hoogle exec
12:57:06 <lambdabot> Directory.executable :: Permissions -> Bool
12:57:06 <lambdabot> Distribution.PackageDescription.executables :: PackageDescription -> [Executable]
12:57:06 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
12:57:10 <jo_devR> how can i do that with code
12:57:22 <roconnor> @hoogle runInteractiveProcess
12:57:23 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
12:58:00 <roconnor> @hoogle runCommand
12:58:01 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
12:58:19 <monochrom> forM_ [0,1,2] (\x -> starOfDavid w (p1 !! x) (ri `div` 3) (d+1))
12:58:29 <glguy> jo_devR: mapM
12:58:41 <monochrom> But since it's p1 !! x...
12:58:44 <glguy> jo_devR: mapM (\i -> your function i ) [0..2]
12:58:56 <monochrom> forM_ p1 (\p -> starOfDavid w p (ri `div` 3) (d+1))
12:59:10 <jo_devR> thanks a lot guys
12:59:15 <glguy> jo_devR: if you have ghc 6.6, then import Control.Monad and use forM_
12:59:21 <glguy> the _ part means ignore the result
12:59:29 <jo_devR> actually i am on 6.4
12:59:46 <monochrom> forM_ x y   is the same as   mapM_ y x.
12:59:49 <glguy> you can define forM_ for convenience in your code if you like
13:00:16 <jo_devR> i am kinda new to haskell and haven't yet mastered monads :(
13:01:20 <monochrom> You have been using numbers without mastering them.
13:01:47 * SamB goes off to find lunch ...
13:01:53 <dolio> glguy: Had your taste of Ruby today with "The Best of method_missing"?
13:02:05 <glguy> dolio: I have no
13:02:07 <glguy> t
13:02:14 <monochrom> Bankers play with numbers without knowing "number laws" such as the Peano axioms.
13:02:22 <dolio> Apparently 'class NilClass def method_missing(meth, *args) nil end end' didn't make it. :)
13:02:54 <glguy> dolio: is that the "act like objC" function?
13:03:19 * glguy finds that on programming.r.o
13:03:44 <dolio> I guess. If you call a method on an object that doesn't support it, method_missing gets called with the name of method/args you called.
13:04:15 <dolio> Which can have cute uses, although some people come up with really bad ones.
13:04:22 <pjd> glguy: equivalent of __getattr__ in Python
13:04:30 <dolio> Like the 'make any method called on nil not report an error, and return nil instead.'
13:05:03 <glguy> dolio: that seems to follow the "lalalalala don't tell me I have errors" mentality ;)
13:05:16 <glguy> pjd: I don't know about python, what does __getattr__ do?
13:05:55 <thecrypto> With python, if you have f = Foo() when you do f.x it really calls f.__getattr__('x')
13:06:00 <SamB> I've mainly seen that method in the Squeak debugger
13:06:12 <pjd> ...when f has no x attribute
13:06:20 <glguy> and only when it doesn't?
13:06:23 <pjd> yes
13:06:35 <pjd> i think Smalltalk calls it doesNotUnderstand
13:06:54 <thecrypto> pjd: Though there is __getattribute__ that overrides everything
13:07:06 <pjd> right
13:07:11 <glguy> pjd: were you discussing the Haskell and Python having the same limitation of lambda expressions to me?
13:07:20 <pjd> glguy: yeah, think so
13:07:31 <glguy> pjd: could you explain what you were saying about Haskell?
13:07:33 <pjd> although would say "limitation" :)
13:07:36 <shapr> Where's the suggested library hierarchy? I want to move something from Xml.* to some better name...
13:07:51 <SamB> pjd: but Haskell doesn't really have statements ;-)
13:08:02 <glguy> pjd: In haskell, the whole program is one big expression, right?
13:08:02 <pjd> SamB: right
13:08:54 <pjd> err, "although i would say", even
13:08:57 <SamB> and if you wanted to use the syntactical things called statements, you could just break out a do block
13:09:56 <pjd> glguy: yeah
13:12:26 <glguy> pjd: so what were you trying to say?
13:13:11 <pjd> ...that Haskell's lambda can only contain a single expression, like Python?
13:13:37 <shachaf> pjd: But Haskell has do blocks.
13:13:40 <glguy> and I was saying that that "limitation" was nonsensical to consider
13:13:46 <pjd> shachaf: which are a single expression
13:13:52 <nominolo> shapr: Text.Xml.*
13:13:52 <SamB> glguy: true, nonetheless
13:13:58 <shachaf> pjd: Imagine Scheme's lambda only worked with expressions: You could still say (begin ...).
13:13:58 <pjd> glguy: that's what i was saying too
13:14:03 <SamB> it basically makes a good joke
13:14:08 <nominolo> shapr: maybe?
13:14:13 <shachaf> pjd: Do blocks are similar (though they desugar into function applications anyway).
13:14:15 <glguy> pjd: so we were in "violent agreement"?
13:14:27 <pjd> yes :)
13:14:32 <shachaf> pjd: Sure, but in Python, you don't have something like Scheme's (begin).
13:14:44 <Baughn> pjd: Or haskell's let
13:14:48 <mauke> or perl's do
13:15:04 <Baughn> Or CL's progn?
13:15:30 <pjd> shachaf, Baughn: right, but that's orthogonal to single-expression lambdas
13:15:51 <Baughn> It is apparently idomatic to name all functions in python, which is why lambda is nerfed. Probably the other way around, though.
13:15:52 <SamB> but essential to their being annoying
13:15:56 <glguy> so the point is that python has no sequencing operator
13:16:00 <pjd> i think the whole argument is silly, really :)
13:16:03 <desp> hgrr
13:16:21 <glguy> pjd: I agree, I mean... who uses python anyway?
13:16:23 <pjd> Baughn: no, only ones big enough to deserve a name
13:16:29 <desp> why is my p12 solution wrong?
13:16:38 <pjd> i'm not aware of lambda being nerfed
13:16:44 <SamB> Baughn: probably lambda is nerfed because nobody can agree on what syntax to use for an un-nerfed one, and I guess it doesn't help that Guido doesn't seem to grok FP
13:16:48 <pjd> glguy: i do! :P
13:16:55 <Baughn> pjd: So what do you do with multiple-statement functions that don't deserve a name?
13:17:21 <SamB> Baughn: call them "f"
13:17:31 <pjd> i think python philosophy is that multiple statement functions deserve a name more or less by definition :)
13:17:32 <glguy> desp: because you are counting the same divisor more than once?
13:17:33 <Baughn> SamB: ..no, that's haskell
13:17:34 <shachaf> desp: P12?
13:17:38 <mauke> well I make it a global function and slap a "static" in front of it!
13:17:48 <desp> glguy: nope
13:17:49 <glguy> desp: like: 4 -> [2] instead of [2,2] ?
13:17:54 <Baughn> pjd: Right. And I suspect that that's policy /because/ lambda doesn't support them.
13:17:54 <SamB> Baughn: I'm pretty sure I would have done that before I learned Haskell
13:17:56 <glguy> desp: what answer did you get?
13:18:10 <desp> glguy: 12375th triangle number
13:18:21 <glguy> desp: *way* off :)
13:18:23 <pjd> SamB: Guido doesn't see Python as an FP language, which is a bit different
13:18:24 <shachaf> desp: Oh, Project Euler?
13:18:25 <Baughn> SamB: Still, haskell is the only language I've seen where it's idiomatic to use single-letter parameter names
13:18:26 <glguy> OHHH
13:18:30 <glguy> desp: it is "what nuymber"
13:18:36 <glguy> not what index
13:18:39 <glguy> could that be it
13:18:43 <desp> omg
13:18:43 <SamB> Baughn: did I mention it would be on the line before it is used?
13:19:02 <shachaf> desp: Yes, #12 isn't the index, it's the number.
13:19:02 <desp> glguy: yes, that was it
13:19:03 <Baughn> SamB: Nope, but you didn't have to
13:19:18 <desp> "which triangle number" and the example shows "7th"
13:19:22 <desp> >_<
13:19:27 <SamB> Baughn: a local variable isn't the same as a parameter
13:19:43 <desp> shachaf: indeed
13:19:48 <shachaf> desp: "The 7th triangle number, 28, ..."
13:20:19 <Baughn> SamB: No, it isn't. I was commenting on haskell code, not necessarily /your/ code. ;)
13:20:46 <SamB> Baughn: yes. but what does that have to do with naming local variables with single letters?
13:20:52 <desp> shachaf: I thought "which" refers to index, instead of value
13:20:58 <SamB> I'm pretty sure that's a normal Python thing
13:21:10 <desp> am I wrong about this? not a native English speaker :)
13:21:11 <SamB> at least in short functions
13:21:28 <Baughn> SamB: Haven't seen much python code, so.. *shrug*
13:21:28 <SamB> when you have nothing more informative to call them
13:21:32 <SamB> Baughn: ah.
13:21:38 <shachaf> desp: I'd take that as the number.
13:21:47 <shachaf> desp: But I guess it could be ambiguous.
13:21:53 <glguy> desp: working on 14 now?
13:21:53 <desp> mm
13:22:17 <desp> yup ;)
13:22:49 <shachaf> @let hotpo n | even n = n `div` 2 | otherwise = 3 * n + 1
13:22:54 <SamB> I mean, I'm pretty sure that x, i, j, s, and l are fairly common local identifiers in python code.
13:22:57 <lambdabot> Defined.
13:23:04 <SamB> probably l is the least common
13:23:17 <pjd> and n
13:23:23 <shachaf> > takeWhile (/=1) . iterate hotpo $ 15
13:23:24 <lambdabot>  [15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2]
13:23:30 <SamB> possibly also m
13:23:39 <shachaf> Doesn't have the last 1. :-(
13:23:39 <Baughn> @type hotpo
13:23:41 <lambdabot> Not in scope: `hotpo'
13:23:44 <araujo> http://www.sabayonlinux.org/forum/viewtopic.php?t=8731&start=0&postdays=0&postorder=asc&highlight=
13:23:46 <lambdabot> http://tinyurl.com/32azjz
13:23:56 <SamB> and I guess y, too
13:23:57 <sfultong> is there any good library for colored console output? (hopefully at least 8 bit color)
13:24:03 <shachaf> @ty let hotpo n | even n = n `div` 2 | otherwise = 3 * n + 1 in hotpo
13:24:05 <lambdabot> forall a. (Integral a) => a -> a
13:24:14 <SamB> but y is probably used a lot less than x
13:24:27 <Baughn> sfultong: You can use ANSI codes, and they'll work most places
13:24:31 <SamB> not quite sure.
13:25:06 * SamB now wants to do a frequency analysis of Python identifiers
13:25:15 <sfultong> Baughn: isn't that a rather limited color selection, though?
13:25:19 <Baughn> sfultong: Oh, and hmp3 uses curses, so presumably there's a curses interface in there
13:25:34 <Baughn> sfultong: Yes, but I've never seen a console program that uses more. Why would you want to?
13:26:28 <SamB> sfultong: I think you need to run a special terminal app to even get support for 8-bit color
13:26:39 <SamB> (or possibly be on the Linux console... dunno.)
13:26:51 <pjd> ANSI should get you 16 colors;  xterm can do up to 256, i think
13:26:55 <dnox> dcoutts: there?
13:27:11 <dcoutts> dnox: busy
13:27:14 <SamB> sfultong: what do you need more colors for?
13:27:15 <glguy> sometimes you need to specify TERM=xterm-256color
13:27:27 <dnox> ok
13:27:57 <pjd> you probably might as well use graphics if you need that kind of thing, though
13:28:24 <glguy> What is the bash scripting for: run gmrun forever?
13:28:26 <glguy> over and over
13:28:35 <SamB> pjd: we don't know what he wants it for yet ;-)
13:28:54 <SamB> glguy: I believe it starts with "while true"
13:29:00 <glguy> like: while 1 { gmrun?
13:29:08 <mauke> glguy: while :; do gmrun; done
13:29:18 <SamB> ":"?
13:29:24 <glguy> wonderful, thank you
13:29:24 <mauke> SamB: help :
13:29:32 <SamB> zsh: command not found: help
13:29:45 <mauke> get a better bash
13:29:59 <mauke> it's a no-op that returns a zero exit status
13:30:23 <SamB> hmm, so it is.
13:30:28 <SamB> so why is that better than "true"?
13:30:49 <mauke> less typing
13:31:00 <mauke> also more efficient in older shells without a "true" builtin
13:31:07 <SamB> uh huh.
13:31:22 <SamB> that's really a very convincing argument you've got there.
13:31:35 <glguy> SamB: the real question is, if while: works, why use while true?
13:31:50 <SamB> glguy: it's easier to remember what that does
13:32:02 <SamB> and easier for new people to understand
13:33:57 <glguy> could someone recommend a simple X11 program that I can use to launch applications. I don't need anything fancy, and gmrun almost works (but it doesnt work well for launching multiple applications) I need something that keeps running
13:34:12 <Excedrin> like an xterm?
13:34:27 <shachaf> glguy: What do you mean, keeps running?
13:34:27 <sjanssen> glguy: you don't like dmenu?
13:34:35 <sjanssen> oh, keeps running
13:34:37 <shachaf> glguy: What WM do you use?
13:34:40 <glguy> I'm in windows
13:34:44 <glguy> using X-win32
13:34:44 <sjanssen> glguy: why "keeps running"?
13:34:52 <glguy> it would be nice to have a little window open all the time
13:34:57 <SamB> glguy: so what's wrong with xterm?
13:34:57 <glguy> to launch X11 apps with
13:35:02 <SamB> what WM are you using?
13:35:03 <shachaf> glguy: Set a keybinding for gmrun.
13:35:09 <elliottt> glguy: katapult?
13:35:22 <glguy> xterm might work out, I could just make it small and remember to add & after everything
13:35:35 <sjanssen> and remember not to close it
13:35:42 <Excedrin> are you using cygwin?
13:35:45 <glguy> no
13:35:47 <elliottt> http://www.kde-apps.org/content/show.php?content=33985
13:35:49 <lambdabot> Title: &nbsp;katapult KDE-Apps.org
13:35:57 <glguy> KDE is a bit much
13:36:03 <glguy> I'm looking for something with very few deps
13:36:12 <glguy> gtk+ prefered to qt because I have gtk+ isntalled already
13:36:17 <shachaf> Does xmonad run on Windows?
13:36:39 <glguy> I could run it in x-win32
13:36:39 <SamB> maybe he has the X windows mixed with his regular windows
13:36:44 <glguy> but I don't want a WM
13:36:55 <SamB> in which case he couldn't really use a WM
13:36:56 <shachaf> glguy: I was wondering in general.
13:37:25 <glguy> shachaf: maybe if you use cygwin-x it does?
13:37:35 <shachaf> glguy: That's what I was wondering.
13:37:48 <shachaf> glguy: Well, why not set a keybinding to gmrun?
13:38:04 <glguy> shachaf: I'll need a program that listens for keybindings
13:38:13 <glguy> shachaf: and that can listen to them globally
13:38:25 <shachaf> glguy: Well, maybe a Windows shortcut would work?
13:38:55 <glguy> it would have to launch a plink to my linux install or something hackish.. I think
13:38:56 <SamB> maybe you could use Start-R
13:39:07 <SamB> oh
13:39:16 <SamB> you're running all these programs on linux
13:39:19 <SamB> gotcha.
13:39:22 <shachaf> glguy: Oh, this is X forwarding?
13:39:30 <glguy> shachaf: it's remote X
13:39:35 <glguy> technically not forwarding
13:39:44 <shachaf> glguy: OK.
13:39:44 <glguy> (I think)
13:39:54 <SamB> glguy: well, what does echo $DISPLAY say?
13:39:57 <dcoutts> dnox: what were you going to ask?
13:40:08 <glguy> SamB: not localhost
13:40:14 <shachaf> glguy: Well, what WM do you use in X?
13:40:19 <shachaf> glguy: Anything?
13:40:34 <glguy> shachaf: just the x-win32 multiple window manager
13:42:01 <shachaf> glguy: Oh, I see.
13:42:31 <sjanssen> glguy: why don't you just run a real Unix? :)
13:42:43 <glguy> sjanssen: windows has better support for my laptop
13:42:56 <glguy> sjanssen: and i can merge linux into windows easier than windows into linux
13:43:03 <glguy> and I need to be able to see things using IE
13:43:11 <SamB> glguy: you only say that because WINE is crap
13:43:12 <glguy> I have more tools at my disposal this way
13:43:27 <glguy> like fiddler for HTTP debugging
13:43:42 <sjanssen> glguy: but how do you stand such a lame window manager?
13:43:50 <glguy> Its a best of both worlds thing, I'm just trying to make it a little easier to launch X11 apps
13:44:02 <glguy> sjanssen: easy, full screened PuTTY
13:44:23 * geezusfreeek_ is running way too many vms right now...
13:44:53 <sjanssen> glguy: you can't run firefox in PuTTY
13:45:04 <Baughn> glguy: You can run windows on xen. You can't run xen on windows.
13:45:13 <glguy> vmware > xen
13:45:35 <Baughn> Paravirtualization > full virtualization
13:47:42 <glguy> I'm not interested in debating windows vs linux... I sit squarely on the fence, I run both
13:47:57 <glguy> mostly jus tlooking for an application launcher :)
13:49:04 <Nafai> glguy: I use the opposite approach at work...run Linux as the base OS and then run XP in VmWare for Lotus Notes and Enterprise Architect and the few Windows-only apps I'm forced to run
13:50:07 <Baughn> I run linux as the base os, and windows using HVM on xen, mostly because I also run three other OSs and xen is good at memory management
13:50:33 <glguy> I tried running it the other way around
13:50:43 <glguy> but the video card driver was a work in progress
13:50:48 <glguy> among other issues
13:51:39 <glguy> the latest 2.1.0 release of the i810 driver was the first that actually ran on my laptop, not necesarily well, but ran
13:51:47 <glguy> also, this Dell dock doesn't work in linux yet
13:51:49 <glguy> so...
13:51:53 <glguy> my hands were tied
13:52:07 <SamB> dock needs software?
13:52:12 <SamB> wierd.
13:52:15 <glguy> the network driver
13:52:17 <glguy> and video drive
13:52:18 <glguy> r
13:52:33 <glguy> I couldn't get the dock ethernet port to work
13:52:41 <glguy> and the video out was flaky
13:52:43 <glguy> the usb worked though
13:52:48 <SamB> it has an extra videocard on the dock?
13:53:20 <glguy> I'm not clear on that, in the bios you can tell it to "use the dock video card"
13:53:31 <glguy> but I don't know if that actually means that there is another video card
13:53:32 <glguy> or
13:53:41 <glguy> is just a way of talking about the DVI port
13:54:20 <glguy> I'll probably try again when the kernel support for this laptop has had a chance to catch up
13:55:05 <RyanT5000> why is Foreign.C.String.charIsRepresentable in IO?
13:55:21 <norpan> because it depends on the locale?
13:55:47 <RyanT5000> norpan: hm; there should be a version that isn't in IO
13:56:11 <Baughn> The locale isn't likely to change, is it?
13:56:25 <RyanT5000> it's kind of ironic that to do proper error checking i have to make a function impure >.>
13:56:31 <norpan> you can change the locale
13:56:44 <benny99> hi
13:58:00 <RyanT5000> there needs to be some system for providing default values to things (e.g. locale) that has some kind of actual theoretical basis
13:58:11 <RyanT5000> i.e.: "that is good"
13:58:19 <glguy> RyanT5000: like implicit parameters?
13:58:27 <RyanT5000> glguy: yeah, like that
13:58:35 <RyanT5000> glguy: what are those? they sounded right :P
13:58:48 <norpan> if you think the locale will not change, just unsafePerformIO it
13:58:51 <glguy> they are dynamically scoped variables
13:59:06 <glguy> ?type succ ?x
13:59:10 <lambdabot> forall a. (?x::a, Enum a) => a
13:59:31 <glguy> stdin should be one of these
13:59:45 <SamB> glguy: no way
14:00:04 <RyanT5000> glguy: that's a real thing?
14:00:05 <SamB> that won't work the way you'd expect if you run another program...
14:00:17 <glguy> works great for the common lispers
14:00:31 <SamB> ... they run external programs?
14:00:46 <glguy> what does this have to do with external programs?
14:01:16 <SamB> well, say I run invoke another program when stdin is rebound
14:01:37 <glguy> SamB: it would have great advantages, like making automated testing possible
14:01:37 <benny99> that video in the topic got only sound on the left side?
14:01:44 <SamB> glguy: would that work?
14:01:53 <SamB> benny: what?
14:02:12 <glguy> SamB: it doesn't actually redirect the actual stdin
14:02:16 <benny99> SamB: got no sound on the right side when I watch that vid
14:02:19 <glguy> the point is that getLine, for example
14:02:21 <benny99> blip.tv/..
14:02:22 <SamB> glguy: see the problem then?
14:02:22 <sjanssen> glguy: we can already to that in a non-thread-safe manner with dup2
14:02:26 <sjanssen> s/to/do
14:02:39 <glguy> sjanssen: right, this would just be a way to not make it a hack
14:02:41 <RyanT5000> so, are implicit parameters "considered harmful"
14:02:43 <benny99> SamB: sorry... guess my Headphone is broken o_o... damn...
14:02:45 <RyanT5000> you know, by us?
14:02:46 <SamB> glguy: if I ran another program, it's output would not be redirected
14:02:52 <glguy> SamB: ok
14:02:59 <benny99> *gone watching*
14:03:10 <SamB> glguy: kind of like what happens when you run some ignorant Windows program under an xterm in cygwin
14:03:51 <sjanssen> SamB: we could change the libraries to do the IO redirection before forking
14:04:01 <SamB> sjanssen: true
14:04:13 <RyanT5000> is there a huge list of all the nifty features haskell has like this?
14:04:14 <sjanssen> case ?stdin of (Handle fd) -> fork (dup, exec, etc.)
14:04:21 <glguy> RyanT5000: haskell.org/ghc
14:04:30 <SamB> another issue, of course, is that implicit parameters are so implicit that they are slightly ambiguous
14:04:47 <RyanT5000> glguy: well i've been there plenty of times
14:04:55 <glguy> RyanT5000: look around the user's guide for ghc
14:04:59 <sjanssen> it might be better to have "getStdIn :: IO Handle", instead of using implicit params
14:05:14 <RyanT5000> glguy: actually, the extensions page looks pretty good
14:05:22 <sjanssen> IO becomes (ReaderT Handles RealIO)
14:05:33 <SamB> perhaps it should be something like MonadReader (Handle,Handle,Handle) IO ?
14:05:39 <RyanT5000> hopefully someday i will feel the kind of mastery of haskell as i did of C++ :P
14:05:52 <sjanssen> SamB: yeah, we could provide that instance
14:05:52 <SamB> sjanssen: hmm, I'm too slow
14:06:08 <SamB> and I said "something like"
14:06:11 <sjanssen> leverage local, ask, etc. automatically
14:06:26 <benny99> RyanT5000: I do the same ^^
14:06:45 <SamB> I don't mean that it should necessarily become an instance of that...
14:06:47 <SamB> oh.
14:06:58 <SamB> I point out that it would be hard to lift local.
14:07:10 <sjanssen> SamB: sure, it could go either way
14:07:14 <SamB> well.
14:07:16 <SamB> might.
14:08:21 <SamB> I guess you'd need to add that one to MonadIO?
14:08:48 <sjanssen> the lifting is inconsequential, really
14:09:00 <SamB> @type local
14:09:05 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
14:09:16 <sjanssen> the main point is that we want reader semantics -- the concrete interface can be a bit different
14:09:32 <SamB> sjanssen: well, you'd still probably have to add a method to MonadIO
14:09:39 <sjanssen> SamB: why?
14:09:58 <sjanssen> liftIO seems sufficient
14:10:23 <SamB> try to liftIO something with a signature like local has, sometime
14:10:32 <SamB> and you'll see what I mean
14:10:42 <sjanssen> @type liftIO . local id
14:10:44 <lambdabot>     No instance for (MonadReader r IO)
14:10:44 <lambdabot>       arising from use of `local' at <interactive>:1:9-16
14:10:59 <SamB> @type id
14:11:01 <lambdabot> forall a. a -> a
14:11:01 <SamB> erg.
14:11:04 <SamB> @type local id
14:11:06 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => m a -> m a
14:11:34 <SamB> @type liftIO
14:11:36 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:11:54 <SamB> @type lift . local
14:11:56 <lambdabot> forall (t :: (* -> *) -> * -> *) r (m :: * -> *) a. (MonadTrans t, MonadReader r m) => (r -> r) -> t ((->) (m a)) (m a)
14:12:05 <SamB> @type lift . local id
14:12:07 <lambdabot> forall (t :: (* -> *) -> * -> *) r (m :: * -> *) a. (MonadTrans t, MonadReader r m) => m a -> t m a
14:12:20 <SamB> okay. notice the "m a -> t m a"?
14:12:36 <SamB> if that m were IO...
14:13:08 <sjanssen> SamB: what's the problem?
14:13:31 <SamB> well, you'd have to use a value of type IO a inside the local
14:13:37 <sjanssen> if we have "instance MonadReader Handles IO", it works exactly as you expect
14:13:45 <SamB> true.
14:14:20 <SamB> but that's because all those monad transformers already have MonadReader instances
14:14:38 <sjanssen> yes
14:14:50 <SamB> that is, you don't have to lift local then
14:14:59 <sjanssen> right
14:15:02 <SamB> which is good because you really CAN'T lift it yourself
14:15:06 <sjanssen> yes you can
14:15:21 <SamB> no. I've only lifted the result
14:15:34 <SamB> not the subcomputation
14:16:25 <SamB> (unless you want me to write transformer-specific lifting code?)
14:16:57 <lament> woohoo parsec <3
14:17:08 <RyanT5000> is there any way to get the C length of a CString?
14:17:21 <bos> call strlen on it.
14:17:29 <RyanT5000> bos: :(
14:17:32 <SamB> @hoogle strlen
14:17:33 <lambdabot> No matches found
14:17:38 <RyanT5000> the problem is
14:17:44 <RyanT5000> there's CStringLen, which is not null terminated
14:17:46 <RyanT5000> and CString
14:17:49 <RyanT5000> which is null terminated
14:17:56 <RyanT5000> i need both
14:18:11 <mrd> HXT is pretty neat
14:18:14 <SamB> @hoogle CString -> IO CStringLen
14:18:15 <lambdabot> No matches, try a more general search
14:18:31 <SamB> @hoogle CString -> CStringLen
14:18:32 <lambdabot> No matches, try a more general search
14:18:39 <bos> RyanT5000: what are you trying to do?
14:18:41 <RyanT5000> maybe i'll ask the maintainers of the library i'm using
14:18:45 <SamB> @doc Foreign.C.String
14:18:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html
14:18:52 <RyanT5000> well, i'm writing a binding for SpiderMonkey
14:19:05 <sjanssen> SamB: I still don't see your point
14:19:15 <RyanT5000> and "JS_EvaluateScript"'s doc says it takes a const char * (not mentioning anything about null termination)
14:19:22 <RyanT5000> (except it calls it a "string")
14:19:29 <RyanT5000> and then it takes the length of that string
14:19:42 <SamB> sjanssen: well, you can try to clean up parsely then
14:19:45 <RyanT5000> "bytes	const char *	String containing the script to compile and execute."
14:19:59 <RyanT5000> "length	size_t	Size, in bytes, of the script to compile and execute."
14:20:03 <RyanT5000> that's all the documentation
14:20:13 <RyanT5000> so i assumed it needed null-termination
14:20:31 <sjanssen> SamB: are you talking about the general transformer class problem, that we need O(n^2) instances to cover all possible stacks?
14:20:49 <SamB> sjanssen: if you can clean up parsely so that it doesn't need seperate instances for its classes for StateT, ReaderT, and WriterT?
14:20:53 <SamB> er.
14:21:09 <sjanssen> SamB: yeah, the O(n^2) instance problem
14:21:29 <SamB> if you can do that, I'll believe you that its not worth adding a method to MonadIO
14:21:32 <sjanssen> SamB: this is beyond the scope of this handle proposal, IMO
14:21:39 <SamB> no!
14:22:22 <SamB> for whatever interface you propose must have an analog for transformer stacks on IO
14:22:23 <sjanssen> SamB: why?
14:23:21 <plutonas> could you please tell me what do i need to install on fbsd to start programming in haskell?
14:23:49 <RyanT5000> plutonas: ghc or hugs; for ghc see http://haskell.org/ghc/
14:23:50 <lambdabot> Title: The Glasgow Haskell Compiler
14:23:52 <dcoutts> plutonas: ghc and cabal and your favourite programming text editor
14:23:56 <SamB> sjanssen: well, look at http://hackage.haskell.org/packages/archive/parsely/0.1/doc/html/Text-ParserCombinators-Parsely-Class.html
14:23:58 <RyanT5000> plutonas: it might be in ports, i'm not sure
14:23:59 <lambdabot> http://tinyurl.com/32wru8
14:24:14 <dcoutts> plutonas: I'm pretty sure it is in FreeBSD ports
14:24:51 <plutonas> i'm getting ghc
14:24:57 <sjanssen> SamB: all transformers should have "instance (MonadReader r m) => MonadReader (MyTrans m)" instances.  This is due to a fundamental limitation of Haskell
14:25:05 <dcoutts> plutonas: http://www.freshports.org/lang/ghc/
14:25:05 <SamB> sjanssen: yes.
14:25:06 <lambdabot> Title: FreshPorts -- lang/ghc
14:25:19 <SamB> so if this thing doesn't actually use MonadReader...
14:25:25 <plutonas> and then how do i use it? can i use it interactively?
14:25:29 <mauke> yes
14:25:44 <SamB> it had better have a class with a method analogous to local
14:25:48 <plutonas> thats good, thanks
14:25:58 <sjanssen> SamB: yeah, I see your point there
14:26:58 <SamB> sjanssen: I even tried using http://hackage.haskell.org/packages/archive/StrategyLib/4.0.0.0/doc/html/Control-Monad-Run.html
14:27:01 <lambdabot> http://tinyurl.com/33apwt
14:27:15 <SamB> and making a Relift class to go with the Unlift one
14:27:32 <SamB> but that didn't work either :-(
14:27:37 <sjanssen> heh, I was thinking about that just now :)
14:28:07 <SamB> er.
14:28:19 <SamB> I guess it was MonadReTrans to go with MonadUnTrans
14:29:06 <SamB> you should be able to find it in the source for Text.ParserCombinators.Parsely.Instances
14:29:11 <sjanssen> this is similar to quicksilver's recent post on the ML
14:30:05 <qwr> plutonas: all cool shit works with ghc... ;)
14:30:12 <SamB> oh. I think I've been informed of a URL of for a newer version of StrategyLib...
14:30:22 <SamB> I should try to merge that with this
14:31:40 <SamB> oh, cool, the actual maintainer for Data.Derive.Functor is going to look into the Functor bug
14:31:46 <bos> wow. simonpj's 3 OSCON videos on blip.tv have received 50% more hits than the next 10 OSCON videos put together.
14:31:54 <sorear> ooh
14:32:21 <SamB> bos: that surprises you?
14:32:23 <sjanssen> SamB: "[Haskell-cafe] Monadic tunnelling: the art of threading one monad through another"
14:32:38 <bos> he outpaces mark shuttleworth, steve yegge, jimmy wales, and many more.
14:32:44 <sjanssen> nice
14:33:12 <sjanssen> all those guys are blowhards anyway, SPJ's talks have substance :)
14:34:09 <SamB> ooh, I want to see the explicit content
14:34:25 <SamB> why does it show SPJ's talks without that, anyway?
14:35:22 <sjanssen> SamB: do we have the same definition of "explicit content"?
14:36:08 <SamB> sjanssen: well, I'd like to see only talks that talk explicitly about programming
14:36:09 <benny99> ok... I guess I should now try to code some little test programs
14:36:19 <sebell> Hmm. Does anybody know if it's possible to build GHC (6.6 or 6.7) on Mac OS X Intel without readline and with statically linked GMP?
14:36:29 <benny99> somebody got an idea what? thought of a simple calculator, but that's too much already
14:38:30 <benny99> to do those examples on the homepage is so dissatisfying :(
14:38:32 <sorear> Are the semantics of overlapping instances written down anywhere?
14:38:39 <SamB> "monadiness"
14:38:58 <sjanssen> SamB: "explicit content" is frequently used in censorship, usually meaning something that children aren't supposed to see/hear
14:39:19 <SamB> yes I know.
14:39:24 <sorear> benny99: I have the same problem :)
14:39:25 <SamB> I'm just being goofy.
14:39:39 <SamB> and insulting the other presenters
14:39:46 <benny99> sorear: but I guess you are more into Haskell already ^^
14:39:49 <sjanssen> oh, I get it
14:39:59 <EvilTerran> well, SPJ huffs markers...
14:40:06 <benny99> sorear: but if you want to we could co-op code something :-[
14:40:06 <sjanssen> the other guys are "softcore", SPJ is "hardcore" :)
14:40:32 <SamB> sjanssen: I was thinking more like "SPJ actually talks about stuff"
14:40:44 <sorear> benny99: I just mean you're not unique in lacking ideas for good-difficulty-level projects.
14:40:53 <benny99> ah :-[
14:40:56 <benny99> sorry :(
14:41:06 <benny99> sorear: so you did something like a simple parser or whatever yet?
14:41:28 <SamB> also I notice SPJ's one is the only one that looks like it was done in a proper room
14:41:47 <kilimanjaro> I don't really like talks, I prefer writings, I think the person can provide a clearer and deeper exposition in the same amount of reader/viewer time
14:42:14 <SamB> the other ones look like they were done in some kind of television studio or something
14:42:24 <benny99> sorear: well... I guess that didn't matter at all, sorry, keep doing stuff :p
14:43:18 <ari> kilimanjaro: Same here, except that some people's talks just are a lot of fun to watch/listen to... and it just so happens that people like SPJ and Wadler are in that class :)
14:43:19 <SamB> hmm, so how fast DID simon have to talk...
14:43:50 <kilimanjaro> ari, well, maybe if they used props, like bowling pins or a hoop of flames
14:43:54 <SamB> I haven't watched his STMtalk yet
14:44:42 <bitwize> hi thoughtpolice, get that compilation problem resolved?
14:44:59 <plutonas> why is compiling ghc taking that long?
14:45:09 <thoughtpolice> bitwize: yep. got 6.6.1 now (even got lambdabot to compile,) thank you gcc 3.4 :)
14:45:24 <bitwize> rock!
14:45:48 <Lemmih> plutonas: It's compiling a buttload of libraries.
14:47:20 <kilimanjaro> Are there daily arguments about Haskell on reddit or something?
14:47:45 <Vulpyne> There are some haskell-hating people that come out of the woodwork whenever a haskell article is posted.
14:48:23 <dibblego> I can't help but think these "Haskell-hating people" tried and failed to learn Haskell and are not envious and bitter toward others who have
14:48:30 <dibblego> s/not/now
14:48:48 <kilimanjaro> Reddit trolling is a hobby I suppose
14:48:55 <bitwize> I think they're just 1) very rude; 2) concerned with other aspects of development besides the ones Haskell makes cool
14:49:28 <monochrom> People are narrow-minded.
14:49:29 <kilimanjaro> Probably just annoyed that their brand isn't getting the publicity that Haskell is
14:49:41 <bitwize> the publicity on Reddit anyway.
14:49:56 <monochrom> People also have strong opinions (for no reason).
14:50:08 <bitwize> C++ is still used in many software projects, and the bulk of applications development probably still takes place in it.
14:50:13 <kilimanjaro> There was a reddit thread asking "what is haskell good for?", nobody mentioned that it is a truly excellent language to blog and debate about
14:50:21 <monochrom> Haha
14:50:36 <bitwize> Blogging and debating about a language doesn't deliver value to your customers.
14:50:39 <sorear> plutonas: You're feeding about 300,000 lines of code through a very slow compiler...  fwiw, it takes about 2hours on a P4 2GHZ
14:50:55 <kilimanjaro> bitwize, customers? What customers?
14:51:18 <bitwize> kilimanjaro: and now you know why Haskell doesn't have widespread acceptance. :)
14:51:27 <monochrom> Haha
14:51:44 <kilimanjaro> Haskell doesn't have widespread acceptance because Haskell is for programmers and not managers
14:51:46 <sorear> but haskell is designed for academic use only!
14:51:50 <SamB> customers are inferior beings
14:51:52 <SamB> I want users
14:51:55 <SamB> those are cooler
14:52:11 <bitwize> "If I'd asked the customers, they'd want faster horses." --Henry Ford
14:52:15 <plutonas> sorear: do you seriously mean 2 hours???
14:52:24 <plutonas> i am waiting for it to finish to go to sleep
14:52:36 <SamB> plutonas: who taught you to compile?
14:52:41 <sorear> plutonas: It used to take three times that long.
14:52:53 <plutonas> SamB: Freebsd
14:53:09 <SamB> they should have told you that compiling big things is a nice thing to do while you sleep
14:53:24 <plutonas> why do i need all that libraries anyway?
14:53:35 <plutonas> can't i install a library when i need it?
14:53:47 <sorear> Also, there's not much point in compiling GHC 6.6.1 yourself if you don't already have GHC.
14:53:53 <kilimanjaro> bitwize, to be honest I'd peg the reddit crowd as being composed of less than 50% professional software developers, that's just from my statistically insignificant sample
14:53:57 <SamB> plutonas: some of them GHC needs
14:54:03 <SamB> plutonas: those, you need to compile
14:54:05 <plutonas> oh it's bootstrapping?
14:54:11 <sorear> Because you need to get *some* version of GHC as a binary, you might as well get 6.6.1
14:54:12 <kilimanjaro> It's easier to talk about software development than to actually develop software
14:54:12 <plutonas> that sucks
14:54:21 <bitwize> kilimanjaro: there is a lot of truth to that.
14:54:24 <SamB> it's possible that you have more compiling than you need
14:54:47 <monochrom> couldn't you find a binary?
14:54:52 <bitwize> but might that in turn lead to a lot of excitement about Haskell from people who don't really develop software?
14:54:52 <plutonas> i see, i can't quit it now
14:55:03 <plutonas> monochrom: i could, but i use to use the ports
14:55:09 <bitwize> (but instead want to feel superior to people who deliver working code all the time in c++ or java)
14:55:11 <SamB> bitwize: no
14:55:14 <plutonas> if i knew, i would get a package though
14:55:35 <SamB> bitwize: people who don't develop software are unlikely to get much out of Haskell
14:55:48 <SamB> unless we have a lot of ready-to-use stuff, anyway
14:56:24 <monochrom> The ports doesn't distribute binaries?
14:56:34 <plutonas> no, ports is for compiling
14:56:53 <benny99> I'm gone for today, bye :)
14:56:55 <monochrom> That sucks. I never understand that philosophy of compile-everything-yourself.
14:56:57 <plutonas> but there are packages, which are built ports... which you access through other commands
14:57:09 <kilimanjaro> bitwize, absolutely. that's what I do in fact...
14:57:21 <plutonas> monochrom: you can either install through the port, or use pkg_add -r ghc and get the binary dloaded and installed
14:57:22 <monochrom> Ah. You could have defaulted yourself to built ports.
14:57:27 <bitwize> monochrom: multiple cpu architectures and library deployments, one library distro
14:57:29 <plutonas> it's ap to you
14:57:30 <plutonas> yes
14:58:28 <monochrom> I guess.
14:59:09 <sorear> bitwize: I don't see how that rules out memoisation
15:03:11 * RyanT5000 cries
15:03:24 <augustss> ?
15:03:31 <monochrom> Let him cry.
15:03:32 <RyanT5000> is there some better way to use ErrorT than converting every IO function ever into something that uses MonadIO instead?
15:03:34 <RyanT5000> lol
15:03:46 <RyanT5000> i just wrote withForeignPtrMIO and withCStringMIO
15:03:53 <RyanT5000> and i don't see an end to this pattern in sight
15:04:08 <Cale> RyanT5000: IO already has exceptions?
15:04:22 <desp> glguy: I got a highly satisfying solution to problem 21 :)
15:04:28 <RyanT5000> Cale: then i have to use Dynamic, etc.
15:05:06 <monochrom> Could turn IO into MonadError
15:05:30 <RyanT5000> monochrom: i don't think that would work with "with" functions
15:05:37 <Cale> mm, that is a bit annoying, but at least you probably know exactly which type you're looking for
15:05:40 <RyanT5000> monochrom: actually, i think it already is an instance of that
15:06:10 <glguy> --I did not fully understand the problem so i searched for Amicable pair on google and it came up with this page, that lists the numbers below 10.000.
15:06:43 <RyanT5000> Cale: yeah; maybe i'll write a function MonadIO m => ((a -> IO b) -> IO b) -> (a -> m b) -> m b
15:06:45 <SamB> hmm. I guess ndm is in the US, near my timezone, isn't he?
15:06:49 <RyanT5000> is that even possible? maybe using exceptions?
15:07:16 <RyanT5000> i don't even know; i'll just see how much trouble it is to write MIO versions of everything
15:07:20 <RyanT5000> it might not be so bad
15:07:30 <RyanT5000> it's better than not using "with" functions, anyway
15:07:35 <monochrom> haskell-cafe had someone writing on that subject.
15:07:43 <sorear> SamB: No, he's at York University in the UK
15:07:56 <SamB> sorear: I know he's there usually
15:08:09 <SamB> but if he's actually there now, he must be seriously timeshifted
15:08:09 <monochrom> I'm too lazy to search. It says "callback".
15:08:33 <sorear> SamB: Oh, like OSCON stuff...
15:08:43 <thoughtpolice> to compile lambdabot with djinn do you only need djinn installed or do you need plugins as well (which, if you do... oh well :/)
15:08:45 <SamB> I mean, he sent me an email about a half hour ago
15:09:05 <SamB> and another about 21 minutes ago
15:09:08 <xerox> thoughtpolice: djinn is bundled with lambdabot
15:09:17 <chessguy> @seen ndm
15:09:17 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 4h 27m 55s ago, and .
15:09:32 <chessguy> @localtime ndm
15:09:37 <desp> glguy: hehe, yeah
15:09:42 <thoughtpolice> xerox: ? :/ then i assume i need haskell evaluation to work too?
15:09:42 <sorear> thoughtpolice: lambdabot.cabal.plugins is for the full dynamic build (which incidentally is broken)
15:09:49 <thoughtpolice> yes, i found that out
15:09:51 <thoughtpolice> :(
15:09:56 <desp> glguy: mine's posted on the last page of the forum
15:09:56 <SamB> chessguy: that only works when there is an ndm about to send a CTCP TIME to
15:10:01 <sorear> thoughtpolice: you need plugins iff you want > 2 + 2 to work
15:10:11 <sorear> thoughtpolice: you don't need it for anything else
15:10:15 <chessguy> SamB yeah, i don't know why i was thinking LB could cache those
15:10:23 <thoughtpolice> sorear: well then my @djinn is failing
15:10:41 <chessguy> sorear, so if i only want > 2 + 3 to work, i don't need plugins?
15:10:47 <thoughtpolice> "Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString"
15:10:47 <SamB> besides which I don't know if he'd have changed his computer's timezone just for OSCON
15:11:08 <thoughtpolice> sorear: same with stuff like @check it seems. :/
15:11:18 <sorear> thoughtpolice: djinn has to be copied into . to work
15:11:27 <thoughtpolice> sorear: cool
15:14:34 <ddarius> chessguy: Lambdabot -could- cache those.
15:15:04 <thoughtpolice> sorear: now i'm getting a "cannot parse command" (but it's a start.) any ideas as to why @check and whatnot aren't working? (there's a quickcheck binary in the tree at the top next to lambdabot)
15:15:23 * ddarius doesn't remember if he changed his computer's time zone when he was in Hawaii.  Probably not.
15:16:47 <sorear> thoughtpolice: huh.  can you paste the error message?  (2 lines -> here ok)
15:17:34 <chessguy> ddarius, err, yeah, s/could/would/
15:17:39 <thoughtpolice> sorear: what's a quick example, i want to at least make sure it's not my fault for using the command wrong :x
15:18:26 <sorear> lambdabot> botsnack
15:18:26 <sorear> :)
15:18:28 <sorear> no @
15:18:37 <sorear> lambdabot> check 2 == 2 Bad interface file: ShowQ.hi         mismatched interface file versions: expected 60720070712, found 6061
15:18:47 <SamB> sorear: did you know derive was full of bugs?
15:18:53 <thoughtpolice> sorear: okay djinn works fine, that was my bad (used ? instead of -> in the type)
15:19:13 <sorear> SamB: ?
15:19:19 <sorear> s/SamB: //
15:19:35 * sorear can imagine â†’, but ?...
15:19:52 <SamB> I've found three so far
15:20:16 <thoughtpolice> sorear: sorear if I just do "@check 2 == 2" then I get a plugin 'check' failed err. :(
15:20:16 <SamB> Read didn't work for multi-constructor types
15:20:25 <SamB> Show didn't work right for records
15:20:32 <SamB> Functor still doesn't work
15:20:52 <sorear> well, the first two are my fault
15:21:02 <SamB> for not writing tests?
15:21:12 <sorear> @check 2 == 2
15:21:13 <lambdabot>  OK, passed 500 tests.
15:21:39 <SamB> already two patches have gone into trying to fix Functor
15:23:14 <thoughtpolice> sorear:
15:23:14 <thoughtpolice> 19:30 <+thoughtpolice> @check 1 /= 2
15:23:14 <thoughtpolice> 19:30 < neinbot> Plugin `check' failed with: IRCRaised Data.ByteString.last: empty ByteString
15:23:28 <thoughtpolice> same with just 2 == 2 :(
15:25:35 <sorear> thoughtpolice: You need to upgrade your regex packages
15:26:00 <sorear> thoughtpolice: There was an embarrasing bug, TuringTest fixed it a couple months ago
15:26:16 <thoughtpolice> sorear: cool. :) which packages would I need of hackage?
15:26:19 <thoughtpolice> all the regex-* ones?
15:26:32 <thoughtpolice> or just -base/-compat
15:26:40 <monochrom> TuringTest passed the Turing test. :)
15:27:05 <sorear> probably just -compat/-base/-posix
15:27:24 <SamB> hmm.
15:27:32 <thoughtpolice> sorear: cool.
15:27:37 <thoughtpolice> sorear: recompile afterwords?
15:28:00 <SamB> I notice Derive's Set derivation uses a different naming convention than DrIFT's
15:28:06 <sorear> thoughtpolice: yeah.  probably only relinking is necessary, but if it doesn't fix it you can -fforce-recomp
15:36:20 <chessguy> so, i've been thinking about using Parsec or something similar to treat a Tic-Tac-Toe board as a string or something to be parsed
15:36:59 <ddarius> Why treat the board as a String?
15:38:00 <chessguy> i was wondering if it's possible to express things in Parsec like "match n spaces, followed by a piece, followed by 2-n spaces, followed by n spaces, followed by a piece, etc." where n can be any number from 0-2, but it has to be the same in all the cases
15:38:13 <ddarius> chessguy: Of course.
15:38:33 <sorear> You can do that in regular expressions!
15:38:46 <chessguy> ddarius, well, i only said string because Parsec takes a string
15:38:47 <sorear> (REAL regular expressions, not just perly ones)
15:39:01 <Excedrin> you can do n spaces, but I don't know how to reject "X  O XOO  X"
15:39:40 <chessguy> err
15:39:47 <chessguy> that's too many squares, excedrin
15:39:54 <Excedrin> I only typed 2 lines
15:39:59 <chessguy> > length "X  O XOO  X"
15:40:00 <lambdabot>  11
15:40:28 <chessguy> 2 lines?
15:41:04 <chessguy> ddarius, what would it look like?
15:41:36 <Excedrin> "XOXOOXOXO" for example, but reject "X  O X..." because it doesn't have the same number of spaces between the first and 2nd items
15:41:41 <ddarius> replicateM n space >> piece >> replicateM (2-n) space
15:42:01 <chessguy> @type replicateM n space >> piece >> replicateM (2-n) space
15:42:03 <lambdabot> Not in scope: `n'
15:42:03 <lambdabot>  
15:42:03 <lambdabot> <interactive>:1:22: Not in scope: `piece'
15:42:12 <chessguy> @type replicateM (n::Int) space >> piece >> replicateM (2-n) space
15:42:14 <lambdabot> Not in scope: `n'
15:42:14 <lambdabot>  
15:42:14 <lambdabot> <interactive>:1:29: Not in scope: `piece'
15:42:23 <chessguy> grr
15:42:24 <ddarius> Excedrin: Are you asking if you can do this with Parsec?
15:42:26 <Excedrin> "X O X O O X O X O" would be OK since it's always one space
15:42:37 <Excedrin> ya, I think this is chessguy's question
15:42:43 <ddarius> :t replicateM ?n space >> ?piece >> replicateM (2-?n) space
15:42:45 <lambdabot> Not in scope: `-?'
15:42:45 <lambdabot>  
15:42:45 <lambdabot> <interactive>:1:48: Not in scope: `n'
15:42:50 <ddarius> :t replicateM ?n space >> ?piece >> replicateM (2 - ?n) space
15:42:52 <lambdabot>     Couldn't match expected type `m a' against inferred type `Doc'
15:42:52 <lambdabot>     In the second argument of `replicateM', namely `space'
15:42:58 <ddarius> Wrong combinators.
15:43:04 <syntaxfree> jesus christ, I just saw someone accidentally staple a piece of paper to her finger on a webcam.
15:43:07 <chessguy> ddarius, for that you have to specify a particular integer
15:43:09 <syntaxfree> she's bleeding the fuck out!
15:43:19 <syntaxfree> what's the correct thing to do? :'(
15:43:32 <bos> talk about it in a different channel?
15:43:37 <syntaxfree> (she's like my long-distance girlfriend, I can't drive her to the hospital or anything
15:43:43 <ddarius> syntaxfree: Tell her to apply direct pressure and elevate her hand.
15:43:43 <syntaxfree> oh well, sorry. I'm panicking.
15:43:45 <syntaxfree> google
15:43:55 <syntaxfree> google didn't tell me much
15:44:10 <chessguy> syntaxfree, you can probably call 911 and have them contact the correct people wherever she is
15:44:19 <ddarius> syntaxfree: Call the police station or emergency number for her area (I assume you have her address)
15:44:23 <thoughtpolice> sorear: now i'm getting another err with @check/@scheck, "< neinbot> smallcheck: Ix{Int}.index: Index (1024) out of range ((0,21))" for just @check 2 == 2
15:45:09 <syntaxfree> she's being taken to a hospital already.
15:45:20 <ddarius> syntaxfree: Okay, so what's the problem?
15:45:37 <chessguy> ddarius, did that make sense? i think your suggestion is basically like Int -> Parser Piece or something
15:45:38 <syntaxfree> I just found that out.
15:45:58 <syntaxfree> she had basically rushed to get help from a neighbour or something and then I came here and panicked.
15:46:03 <sorear> thoughtpolice: I've seen that before but I don't remember what's causing it.  I *think* it's either a 64-bit cleanliness issue in some version of hsplugins, or an incompatibility between your hsplugins and your ghc, but I don't remember.  dons will be awake in a few minutes.
15:46:14 <syntaxfree> Now I called her on her cellphone and found out she's being taken to the hpsital.
15:46:17 <ddarius> syntaxfree: Okay.  Don't worry too much.  Unless she gets tetanus or something, she's not going to be seriously injured.
15:46:22 <syntaxfree> sorry about the general off-topicness.
15:46:25 <syntaxfree> she had a tetanus shot recently.
15:46:36 <syntaxfree> I saw TOO MUCH BLOOD. That freaked me out.
15:46:44 <chessguy> @yow
15:46:44 <lambdabot> Inside, I'm already SOBBING!
15:46:54 <sorear> @seen dons
15:46:55 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 17h 35m 51s ago.
15:46:55 <syntaxfree> again, sorry about the general off-topicness .
15:46:57 <ddarius> chessguy: Yes.  So you want an arbitrary amount of spaces, but the same every time like Excedrin seemed to be driving at.
15:46:58 <chessguy> lambdabot feels your pain
15:47:01 <syntaxfree> I just freaked out.
15:47:04 <chessguy> ddarius, exactly
15:47:34 <ddarius> chessguy: So just have the parser return the number of spaces matched the first time and use that to make the remaining parsers.
15:48:06 <Excedrin> thanks, that makes sense to me and I wouldn't have considered that as a solution
15:48:20 <chessguy> hmm
15:48:40 <ddarius> E.g. many space >>= \ss -> piece >> replicateM (length ss) space
15:48:50 <ddarius> 2 - length ss
15:48:53 <thoughtpolice> sorear: so what, uninstall plugins or just make it not visible as a package and recompile?
15:49:19 <ddarius> Obviously you could make a specialized combinator to return a count rather than uselessly returning a list of spaces.
15:49:49 <xerox> length `fmap` many space
15:49:50 <sorear> thoughtpolice: That wouldn't help because @check needs hs-plugins.  I suspect the best option is to wait for the hs-plugins maintainer to wake up; it usually happens around now.
15:50:01 <thoughtpolice> sorear: hah. thanks. :)
15:50:14 <chessguy> @type length `fmap` many ?space
15:50:23 <lambdabot> forall (f :: * -> *) a. (?space::f a, Alternative f) => f Int
15:50:28 <ddarius> chessguy: The Parsec combinators are not in scope.
15:50:33 <xerox> Yuck.
15:50:37 <chessguy> ddarius, are you sure? :)
15:50:42 <ddarius> chessguy: Yes.
15:50:46 <xerox> That must be ReadP or something.
15:50:52 <ddarius> That many is from Applicative
15:50:56 <ddarius> @index many
15:50:56 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
15:50:57 <chessguy> oh, whoops
15:51:05 <ddarius> @hoogle many
15:51:06 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
15:51:06 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
15:51:06 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
15:51:09 <chessguy> @hoogle+
15:51:10 <lambdabot> Text.ParserCombinators.ReadP.manyTill :: ReadP a -> ReadP end -> ReadP [a]
15:51:10 <lambdabot> Text.ParserCombinators.Parsec.Combinator.many1 :: GenParser tok st a -> GenParser tok st [a]
15:51:10 <lambdabot> Text.ParserCombinators.Parsec.Combinator.manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]
15:51:20 <xerox> @hoogle+
15:51:21 <lambdabot> Foreign.Marshal.Utils.withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
15:51:21 <lambdabot> Text.ParserCombinators.ReadP.skipMany :: ReadP a -> ReadP ()
15:51:21 <lambdabot> Text.ParserCombinators.Parsec.Prim.skipMany :: GenParser tok st a -> GenParser tok st ()
15:51:33 <ddarius> :t Text.ParserCombinators.Parsec.Prim.many
15:51:35 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
15:51:44 <ddarius> :t Control.Applicative.many
15:51:46 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
15:51:58 <chessguy> anyway
15:52:00 <ddarius> > Text.ParserCombinators.Parsec.Prim.many
15:52:00 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.Prim.many'
15:52:11 <xerox> ?docs Control.Applicative
15:52:11 <lambdabot> Control.Applicative not available
15:52:15 <xerox> ?docs
15:52:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:52:39 <thoughtpolice> sorear: actually I looked at scripts/QuickCheck.hs and if I just do ./quickcheck and then type "2 == 2" in I still get the same err. :/
15:53:00 <sorear> thoughtpolice: right.  that error you're getting is from hs-plugins, not lambdabot.
15:54:27 <sorear> thoughtpolice: the version of hs-plugins you're using can't parse the .hi files generated by your version of ghc.  I know that at least some versions of hs-plugins aren't 64-bit-clean; I suspect plain old version mismatches could also be the problem (6.4.x -> tarball, 6.6.x -> darcs, 6.7.x -> good luck)
15:55:06 <chessguy> hmm, apparently i can't just do :a Text.ParserCombinators.Parsec either
15:55:36 <xerox> ddarius: do you also know what that `many' is useful for?
15:55:59 <sorear> chessguy: the command is :m + in ghci, fwiw
15:56:40 <chessguy> ah, that works
15:56:49 <ddarius> xerox: I never use Applicative stuff.
15:56:58 <thoughtpolice> sorear: ah. i remember reading in the ghc commentary how .hi files change a lot between minor releases. is hs-plugins working fully now now on 6.6.1?
15:57:07 <thoughtpolice> sorear: actually I think I might have taken the plugins from hackage.
15:57:16 <ddarius> xerox: But it is effectively a generalized version of the same many as Parsec's.
15:57:18 <chessguy> xerox, so length `fmap` many space matches any number of spaces, and returns the number?
15:57:18 <thoughtpolice> sorear: should I try the darcs repo before bugging dons or would it not make a difference?
15:57:51 <sorear> thoughtpolice: bug dons; the symptom of using 6.4 hsplugins with 6.6 ghc is a *compile* error, not a runtime one
15:58:23 <xerox> chessguy: yes it does.
15:58:42 <chessguy> sweetness
15:59:22 * chessguy has no clue why it works, but likes it anyway
15:59:25 <xerox> chessguy: Parser is just a Functor, so you can lift functions to it.
16:00:22 <xerox> fmap :: (a -> b) -> Parser a -> Parser b
16:00:38 <chessguy> so it would be like doing s <- many space; return $ length s?
16:00:44 <xerox> Yes exactly.
16:01:07 <xerox> do { x <- amb; return (f x) }  =  amb >>= \x -> return (f x)
16:01:18 <xerox> ?pl \f amb -> amb >>= return . f
16:01:19 <lambdabot> fmap
16:01:24 <chessguy> amb?
16:01:30 <chessguy> haha, nice
16:01:33 <xerox> Just whatever monadic value.
16:01:38 <xerox> :-D
16:02:31 <chessguy> so how is ParsecT coming along, anyway?
16:02:50 <xerox> Doing some background reading before implementing the 'T' part :-)
16:02:57 <SamB> chessguy: who was writing that?
16:03:01 <xerox> The Stream stuff actually works, it seems, and ByteString is quite fast.
16:03:09 <dcoutts> yay
16:03:10 <SamB> xerox: have you seen parsely?
16:03:18 <xerox> SamB: no, what's that?
16:03:19 <chessguy> SamB, xerox is
16:03:34 <SamB> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsely
16:03:37 <lambdabot> http://tinyurl.com/2m4zeu
16:03:47 <SamB> it has documentation generated and all
16:03:51 <SamB> so you could just look at that
16:04:26 <SamB> can I get the HWN in my inbox somehow?
16:04:31 <xerox> dist/build/endo/endo icfp endo.dna +RTS -p -sstderr
16:04:31 <xerox> Counting ICFP strings in Endo's DNA... Total number of ICFP subsequences: 3451
16:05:03 <xerox> ~40s ~300kb via lazy bytestring, searching for "ICFP" in Endo's DNA :-)
16:12:12 <syntaxfree> damn, I haven't written one line of haskell in eight or ten weeks. I miss that shit.
16:14:06 <chessguy> ugh
16:14:13 <chessguy> i'm not very good at this yet
16:14:46 <chessguy> now i'm trying to write upTo :: Int -> Parser Int
16:15:09 <chessguy> which consumes as many spaces as possible, up to n
16:15:25 <chessguy> (and returns how many it consumed
16:15:48 <SamB> upTo' :: Int -> Int -> Parser Int
16:16:26 <chessguy> hm?
16:16:27 <xerox> :t (length `fmap`) . sequence . flip replicate ?space
16:16:29 <SamB> upTo n = upTo' n 0
16:16:30 <lambdabot> forall (m :: * -> *) a. (Functor m, Monad m, ?space::m a) => Int -> m Int
16:17:07 <chessguy> SamB, bah, that's overly abstract. i always want to start at 0
16:17:33 <SamB> chessguy: this one is just for ease of implementation!
16:18:18 <SamB> upTo' n sofar | n == sofar = return sofar
16:18:58 <Tchakkazulu> upTo' n sofar = try (space >> upTo' n (sofar + 1)) (return sofar)
16:19:07 <Tchakkazulu> Or whatever try looks like.
16:19:14 <SamB>           | otherwise = (char ' ' >> upTo n (sofar+1)) <|> return sofar
16:19:16 <chessguy> xerox, is that really it?
16:19:29 <Tchakkazulu> Oh, yes <|> helps -_-
16:19:33 <xerox> chessguy: I guess that if one space fails it ruines everything.
16:19:55 <Tchakkazulu> And indeed the case for when n == sofar. Hah, nice :)
16:20:00 <sjanssen> \m -> foldr (\n xs -> (do parseSpace; xs) <|> return n) (return m) [0.. m-1]
16:20:28 <sjanssen> chessguy: ^^^, it's just a one liner :P
16:21:08 <SamB> sjanssen: does that actually work right?
16:21:13 <SamB> oh, yes, it does
16:21:19 <sjanssen> SamB: pretty sure, haven't tried it
16:21:23 <Tchakkazulu> O_O That's brilliant.
16:21:35 <chessguy> *Main> run (upTo 3) "  "
16:21:35 <chessguy> parse error at (line 1, column 3):
16:21:35 <chessguy> unexpected end of input
16:21:35 <chessguy> expecting space
16:21:38 <Tchakkazulu> The power of foldr keeps surprising me.
16:21:41 <chessguy> (using xerox'
16:22:06 <chessguy> sjanssen, how does that work?
16:22:34 <sjanssen> Tchakkazulu: of course foldr is powerful!  It's the catamorphism on [] :)
16:22:45 <sjanssen> chessguy: it's a bit hard to explain
16:22:58 <sjanssen> chessguy: I regard that code as slightly obfuscated
16:23:02 <SamB> sjanssen: mine is very easy to explain ;-)
16:23:21 <sorear> What do overlapping instances *mean*?
16:23:32 <SamB> sorear: they mean you're sloppy?
16:23:33 <Tchakkazulu> Aye. I'd go with SamB's version for readability.
16:23:37 <mrd> where's that great paper all about Folding
16:24:08 <SamB> sorear: if they really overlap, anyway
16:24:10 <sorear> @go functional programming with bananas lenses envelopes and barbed wire
16:24:13 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
16:24:13 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
16:24:17 <sorear> mrd: ?
16:24:22 <xerox> let spaces = (try (space >> updateState (+1)) >> spaces) <|> getState in runParser spaces 0 "" "   "
16:24:25 <xerox> Right 3
16:24:47 <pejo> Or perhaps http://www.cs.nott.ac.uk/~gmh/fold.pdf
16:24:48 <sjanssen> xerox: now you're needlessly changing the type ;)
16:24:59 <sorear> SamB: I can't implement them without knowing what they mean! :)
16:25:14 <SamB> sorear: oh.
16:25:14 <xerox> sjanssen: maybe we need `local' for Parsec :)
16:25:17 <sorear> Also, fancy instane heads.
16:25:21 <sorear> What do those mean?
16:25:27 <SamB> explain?
16:25:31 <sorear> I can't find any references for the semantics!
16:25:37 <SamB> at least say what FooBarBaz name they have
16:25:43 <chessguy> SamB, your code isn't type-checking
16:25:45 <sorear> FlexibleInstances
16:25:56 <SamB> chessguy: oh?
16:26:07 <SamB> chessguy: it shouldn't be that hard to fix it
16:26:23 <chessguy> assuming i understood it to begin with
16:26:27 <sjanssen> sorear: I know that FlexibleInstances lift the (T a ...) where a... are type variables
16:26:37 <xerox> sorear: FlexibleContexts permit type constructors instead of tyvars in contexts,.
16:26:46 <hpaste>  chessguy pasted "SamB, is this right?" at http://hpaste.org/2057
16:27:02 <sorear> sjanssen, xerox: Sure, but if you do that you have to change the definition of entailment in subtle ways
16:27:15 <SamB> chessguy: isn't that what I wrote?
16:27:32 <chessguy> SamB, sorry, that's what i was asking
16:27:48 <chessguy> i wanted to make sure i copied it out right
16:28:17 <SamB> oh.
16:28:27 <SamB> there should be a sofar at the end of the final line
16:28:39 <chessguy> ah
16:28:40 <chessguy> yes
16:28:45 <hpaste>  SamB annotated "SamB, is this right?" with "maybe this works better" at http://hpaste.org/2057#a1
16:30:17 <chessguy> SamB, still no go: Couldn't match expected type `Char' against inferred type `Int'
16:31:03 <chessguy> oh wait
16:31:15 <chessguy> i put the wrong type signatures in :)
16:32:55 <chessguy> no, still not working
16:33:35 <chessguy> @bot
16:33:35 <lambdabot> :)
16:36:51 <chessguy> ah, needed to change an upTo to upTo'
16:37:00 <arcatan> ufos
16:40:43 <lament> how do i specify that i want to use the list monad?
16:41:01 <Botje_> context
16:41:14 <Botje_> > return 42 :: [Int]
16:41:15 <lambdabot>  [42]
16:41:20 <Botje_> > return 42 :: Maybe Int
16:41:21 <lambdabot>  Just 42
16:41:34 <lament> oh, right, thanks
16:42:03 <ddarius> > return 43 ++ return 46
16:42:04 <lambdabot>  [43,46]
16:42:21 <Botje_> > return 43 `mplus` return 46
16:42:22 <lambdabot>   add an instance declaration for (Show (m t))
16:42:27 <lament> > do {"foo"; "bar"}
16:42:28 <lambdabot>  "barbarbar"
16:42:39 <lament> mildly exciting
16:42:47 <sorear> TcMonad.hs:14:24: Only unit numeric type pattern is valid
16:42:58 <Botje_> > return 43 `mplus` return 46 :: [Int]
16:43:00 <sorear> now there's an error you don't see every day *greps*
16:43:00 <lambdabot>  [43,46]
16:43:01 <elliottt> > "foo" >> "bar"
16:43:02 <lambdabot>  "barbarbar"
16:43:19 <Botje_> heh, that's cute.
16:43:31 <elliottt> heh :)
16:43:36 <Tchakkazulu> > return 43 `mplus` return 46 :: Maybe Int
16:43:37 <lambdabot>  Just 43
16:43:53 <sjanssen> this "monad subexpressions" proposal is looking scarier and scarier by the minute
16:44:13 <Botje_> haskell needs tentacles anyway :)
16:45:01 <sorear> sjanssen: So far I've successfully avoid chiming in with "If you want {C,SML,Unlambda depending on my mood} you know where do get it."  - but I'm not sure for how much longer
16:45:12 <sjanssen> sorear: that's a GHC error?
16:45:19 <sorear> sjanssen: yes.
16:45:30 <sjanssen> that's @ghc worthy
16:46:13 <sorear> @quote ghc unit
16:46:13 <lambdabot> ghc says: Only unit numeric type pattern is valid
16:46:33 * sjanssen doesn't want to explain why "if nullPtr p then 0 else (-> peek p)" segfaults to newbies
16:47:03 <Baughn> sjanssen: Why does it?
16:47:05 <sorear> sjanssen: but it segfaults in visual basic!
16:47:11 <sorear> line 148 of RnTypes.hs
16:47:30 <sorear> but what's a HsNumTy?
16:47:34 <sjanssen> Baughn: only with the new monad subexpressions proposal
16:47:47 * Cale considers just posting something emo like "this thread makes me want to cry." and leaving it at that.
16:48:00 <Baughn> sjanssen: Is there some unexpected strictness in there?
16:48:18 <sjanssen> Baughn: it segfaults because the "peek p" will always happen because it will attach to an outer 'do'
16:48:25 <sorear> @users
16:48:25 <lambdabot> Maximum users seen in #haskell: 382, currently: 329 (86.1%), active: 20 (6.1%)
16:48:26 <Baughn> sjanssen: I can see why you dislike it. I can feel the tentacles already, and I don't even understand it.
16:48:41 <Botje_> quote tentacle
16:48:44 <Botje_> @quote tentacle
16:48:44 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
16:48:48 <Botje_> boo
16:48:59 <dcoutts> @seen JohnMecham
16:48:59 <lambdabot> I haven't seen JohnMecham.
16:49:10 <sjanssen> idiom brackets are looking nicer at this point
16:49:11 <Cale> sjanssen: Has that example been posted to the thread?
16:49:24 <sjanssen> Cale: I think it's been mentioned
16:49:30 <ddarius> sjanssen: I haven't read a lot of the recent messages, but one thing that I believe was lost right off was the restriction of this only to commutative monads.
16:49:54 <sjanssen> ddarius: then it seems pointless
16:50:04 <sjanssen> ddarius: I mean, if we can't use it with IO, ST, State, etc.
16:50:18 <sorear> ddarius: Meacham
16:50:28 <Cale> I actually sort of think this syntax idea will kill something that's actually really nice about do-notation. It's currently really easy to understand the order in which code will run.
16:50:56 <ddarius> I agree it would be nice to use it in those cases (except where it wouldn't), but that was the original context and commutative monads benefit from not having to "over-specify" ordering.
16:51:10 <sorear> I am *not* going to implement this in Qhc.  Painting bikesheds purple I'm fine with, painting them with real radium I'm not!
16:51:12 <Cale> It's really nice that we don't have things like C's current-continuation-calling return, and such.
16:51:21 <xerox> sorear: what does Q stand for? :)
16:51:33 <ddarius> sorear: But you are going to implement overlapping instances?
16:51:55 <Baughn> sjanssen: It strikes me that that example is what I have ifM for, anyhow
16:51:55 <ddarius> sorear: It glows in the dark!
16:52:29 <sorear> ddarius: No, there will be a comment in the documentation "If you want overlapping instances and know what they are, explain them to me, then I'll happily implement them."
16:52:52 <ddarius> sorear: You banking on noone satisfying those last two constraints?
16:53:12 <sjanssen> sorear: so you'll wait until Simon wants to try your compiler :)
16:53:39 <sorear> sjanssen: I was actually thinking Oleg, but yeah :)
16:56:35 <xerox> Cale: oh, I just discovered, there are the north american Go finals live on KGS :-)
16:56:45 <Cale> xerox: cool :)
16:56:58 <lament> what's the strongest player's rating? :)
16:57:03 <xerox> 9p
16:57:16 <lament> oh. I thought like 1d :D
16:57:25 <xerox> Board 1 :-)
17:00:24 <Cale> :) 7p v. 9p :)
17:00:44 <Cale> Not often that you see matches like that on KGS. I suppose they're just being reported?
17:01:14 <xerox> Yes.
17:01:16 <SamB> sorear: is that a reference to Bart vs. the Space Mutants?
17:02:00 <Cale> SamB: Are you talking about the incredibly annoying NES game?
17:02:42 <Cale> Or was that also the name of an episode?
17:03:30 <SamB> Cale: it apparantly wasn't just for the NES, but yes
17:03:31 <SamB> that one
17:03:47 <sorear> SamB: Huh?
17:03:50 <SamB> actually, painting things purple was supposed to make them safer
17:03:54 <SamB> I think
17:04:03 <Cale> Ah, yeah, I remember that :)
17:04:17 <SamB> sorear: well apparantly one of the things you were supposed to do was paint things purple
17:04:19 <sorear> SamB: Oh, the bikeshed comment.  No, just me being clever
17:04:33 <sorear> trying to
17:05:17 * SamB wonders how RyanT5000's bikeshed is coming along
17:05:32 <Cale> Which bikeshed is that?
17:07:05 <RyanT5000> a wrapper for finalizers
17:07:14 <RyanT5000> newForeignPtrHaskell
17:07:36 <RyanT5000> :: (Ptr a -> IO a) -> Ptr a -> ForeignPtr a
17:07:47 <RyanT5000> (instead of that first parameter being wrapped in a FunPtr
17:07:49 <RyanT5000> )
17:08:03 <monochrom> I like my bikeshed to have the colour of Haskell.
17:10:36 <SamB> see, this bikeshed is almost without paintable surfaces
17:10:47 <SamB> and if you look inside, it turns out to be some kind of nuclear bikeshed
17:11:13 <SamB> http://hpaste.org/2048
17:11:49 <RyanT5000> there is one change i had to make
17:11:54 <RyanT5000> adding a NOINLINE macro
17:11:59 <SamB> ah.
17:11:59 <RyanT5000> well, i don't know if i "had" to make it
17:12:04 <SamB> where did you add it?
17:12:07 <RyanT5000> but docs said i had to
17:12:11 <RyanT5000> right after the _helper function
17:12:18 <RyanT5000> (for the _helper function)
17:12:19 <SamB> it's a pragma, actually
17:12:24 <RyanT5000> yeah, misspoke
17:12:29 <SamB> and you could have put it before the function
17:12:33 <sorear> RyanT5000: You don't have to add it.
17:12:35 <SamB> that's the usual place, I think
17:12:49 <SamB> sorear: it's a good idea though
17:12:55 <SamB> in this instance
17:13:14 <SamB> he doesn't want to leak those things
17:13:22 <SamB> that's the whole point of this bikeshed!
17:14:11 <monochrom> Hmm nuclear bikeshed. Novel idea.
17:19:09 <Cale> augustss: Haha, that thread with you and qwe1234 is so funny.
17:19:41 <kilimanjaro> yea I read that earlier
17:20:23 <kilimanjaro> I think he trolls Haskell stuff out of habit now
17:22:37 <Cale> It's like "Your name is on the Haskell 1.3 report, but I think I can safely assume I have more functional programming experience than you."
17:23:23 <maskd> Cale: which thread?
17:23:39 <ddarius> Cale: Wow.
17:23:51 <Cale> (He didn't actually say that)
17:24:52 <Cale> http://programming.reddit.com/info/2bxc1/comments/c2byge
17:24:53 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
17:25:47 <SamB> @go lennart augustsson qwe1234
17:25:48 <lambdabot> http://programming.reddit.com/user/augustss/
17:25:48 <lambdabot> Title: overview by augustss (on programming.reddit.com)
17:26:40 <Cale> Oh, man, the value semantics thread is still going?
17:28:44 <SamB> hahahaha
17:28:55 <SamB> qwe got ownz0red
17:29:56 <tessier> qwe?
17:30:02 * SamB ownzors qwe1234 some more
17:30:08 <SamB> http://programming.reddit.com/info/2bxc1/comments
17:30:09 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
17:30:18 <RyanT5000> sorear: really?
17:34:55 <SamB> Hmm. Should I tell vplatt that we actually find qwe1234 amusing?
17:36:55 <Cale> SamB: What are you called on reddit?
17:37:15 <SamB> SamB last I checked
17:37:20 <SamB> I don't necessarily talk much
17:37:29 <Cale> Oh, I thought you meant that you'd replied to him.
17:37:37 <SamB> no not yet
17:37:45 <SamB> oh. qwe1234?
17:37:54 <SamB> others have done that well enough, I think
17:37:56 <Cale> ah
17:37:58 <SamB> so far
17:38:04 <SamB> I just modded him down more
17:38:19 <Cale> So the pwnz0ring was in the form of mods?
17:40:39 <dolio> I didn't even bother modding his comments on that story. They were all at like -15 or below by the time I saw it.
17:42:32 <wli> Hmm, blahLock = newMVar() at the top-level may not do precisely what I want it to depending.
17:43:04 <wli> lockBlack = liftIO $ takeMVar =<< blahLock
17:43:26 <wli> unlockBlah = liftIO $ flip putMVar () =<< blahLock
17:43:38 <dolio> That'll allocate a new MVar each time, no?
17:43:40 <wli> hmm... do I get a new MVar each time?
17:44:00 <dolio> You'd need 'blahLock = unsafePerformIO $ newMVar ()'
17:44:06 <dolio> To get a global lock.
17:44:33 <thoughtpolice> okay so I read augustuss' post on GADT's and Phantom types, and I understand that GADT's allow you to go from type, say, 'Expr a' to any arbitrary 'a,' but what about phantom types?
17:44:57 <wli> dolio: So I need to pass the MVar around in some sort of state.
17:45:22 <Cale> newMVar () is an action
17:45:25 <dolio> wli: Something like that, I guess.
17:45:30 <sorear> Cale: Nevermind the fact that the literature of functional compilers is *littered* with references to [Augustsson and Johnsson 1984]
17:45:31 <thoughtpolice> from augustuss' post it seems as if you just construct the DSL using a phantom type and the phantom is just there to make sure that you can get the same 'corner-case coverage' as the GADT would offer (at least in the example,)
17:45:35 <Cale> blahLock will be of type IO (MVar ())
17:45:43 <Cale> sorear: yeah :)
17:45:50 <thoughtpolice> is this accurate? is there any basic example of a phantom type that would make it clear[er]?
17:46:18 <dolio> ndm had an example of using phantom types that I thought illustrated them nicely...
17:46:35 <wli> dolio/Cale: I basically have what I want to be a global lock around soe global state (which is itself an IORef).
17:46:46 <sorear> @seen dons
17:46:46 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 19h 35m 43s ago.
17:47:00 <Cale> wli: Why not just use an MVar instead of the IORef?
17:47:19 <wli> Cale: Hmm. Not a bad idea.
17:47:19 <Cale> wli: (I'm not saying there couldn't be a reason...)
17:47:25 <dolio> thoughtpolice: http://neilmitchell.blogspot.com/2007/04/phantom-types-for-real-problems.html
17:47:28 <lambdabot> Title: Neil Mitchell's Haskell Blog: Phantom Types for Real Problems, http://tinyurl.com/yul5lo
17:47:43 <thoughtpolice> for example say you had a small evaluator for a language like in the post, you have a function called 'mul' that is of type 'mul :: Expr Int -> Expr Int -> Expr Int,' let's say the "Int" is the phantom and other functions like say add expect also a type of Expr Int; the phantom is just there to make sure you're composing your functions like that 'correctly,' is that just about all there is to it?
17:48:26 <Cale> thoughtpolice: basically
17:49:12 <dolio> Yeah. They're just extra types you pass around to represent well-formedness constraints on your constructor functions.
17:49:21 <dolio> More or less.
17:49:23 <thoughtpolice> you can naturally pull the data using the constructors, but the phantom at the type level just makes sure when you compose something, say "mul (add (conI 5) (conI 7)) (conI 5)" that the types are 'sound' since mull expects 'Expr Int'
17:49:32 <thoughtpolice> s/mull/mul/
17:49:55 <thoughtpolice> rather than a more general type
17:49:59 <thoughtpolice> such as just say Expr a
17:50:04 <thoughtpolice> so you catch those corner-cases
17:50:23 <Cale> Often you'll use types which don't even have any data constructors.
17:50:43 <Cale> They're just there to ensure that certain constraints are getting met, like you said.
17:52:53 <thoughtpolice> ah okay. i take it they're more particularly suited for writing DSL's and whatnot; but for example they could be useful if you were to reduce a piece of code like "(5 + 7) * 5" to the expression above and you wanted to make sure that the resulting structure is 'safe'?
17:53:26 <Cale> yeah
17:53:54 <Cale> You're essentially hijacking the type system for use in your embedded language.
17:54:25 <thoughtpolice> how unfair yet, beneficial. :)
17:54:44 <sorear> I think one of the best examples of phantom types is the two phantom arguments of the (->) constructor.
17:55:01 <sorear> As far as the code generator is concerned, a function is a function is a function.
17:55:05 <Cale> Heh, that is a nice example :)
17:55:29 <sorear> But we can get much stronger type safety guarantees if we annotate source functions with their domain and codomain types.
17:56:27 <sorear> Hmm.  If you think about it that way, *all* higher kinded types are phantom.
17:57:53 <wli> Cale: Done.
17:58:52 <Cale> A just machine to make big decisions/Programmed by fellows with compassion and vision/We'll be clean when their work is done/We'll be eternally free yes and eternally young//What a beautiful world this will be/What a glorious time to be free
18:00:23 <wli> Now the MVar is in a MonadReader, acquire does takeMVar and dumps that into MonadState's state, release grabs the MonadState's state and does putMVar on it.
18:00:41 <sorear> where's that from?
18:01:22 <Cale> The song I.G.Y. (International Geophysical Year), on the album Nightfly by Donald Fagen.
18:03:17 <Cale> http://www.steelydan.com/lyrnightfly.html
18:03:18 <lambdabot> Title: Lyrics | The Nightfly
18:03:28 <sorear> Oh.  Heh.  I thought it was probably some blog
18:06:17 <dolio> Or some new song by Richard Stallman.
18:08:15 <Cale> http://en.wikipedia.org/wiki/International_Geophysical_Year
18:08:17 <lambdabot> Title: International Geophysical Year - Wikipedia, the free encyclopedia
18:08:54 <sorear> 07.08.02:21:31:12 <dons> i'm on my way out the door...
18:13:57 <Cale> wli: What should acquire do in the case that the MVar is empty?
18:14:06 <Cale> (block?)
18:14:47 <Cale> wli: I'm still not 100% certain that you need the state monad part, though it might be convenient if you have lots of general MonadState computations to do on the acquired state.
18:26:31 <wli> I don't quite like the way this looks.
18:27:10 <wli> Basically I use a StateT to hold the current state while it's being manipulated, and set up that state from an MVar in a reader Monad.
18:28:41 <wli> I should really be doing the state bits between the acquire and release of the MVar as runStateT/evalStateT/execStateT with the value acquired from the MVar passed right to runStateT/evalStateT/execStateT.
18:30:41 <newsham> is there a simple rc.local type file I can put my local startup cmds into, or do I have to get fancy and build a full rc start/stop type module?
18:30:46 <newsham> err, oops, misfire
18:31:04 <TSC>                         for (int j = 0 ; j < numLines && i.hasNext() ; j++)
18:31:04 <TSC>                             i.delete();
18:31:09 <TSC> Oops, misfire (:
18:31:21 <TSC> I meant: /etc/init.d/rc.local ?
18:38:34 <newsham> close but no
18:38:46 <sjanssen> does anybody else use Google blog search for 'haskell'?
18:39:17 <sjanssen> I've been learning tons about horse racing lately, specifically the Haskell Invitational :P
18:39:51 <LoganCapaldo> Trying to curry favor with jockeys?
18:40:07 <sorear> newsham: what os?
18:43:18 <newsham> sorear: freebsd. /etc/rc.local.
18:43:45 <sorear> ok, can't help you then
18:44:20 <newsham> thats the answer.  no help needed :)
18:54:23 <jleedev> can someone explain the difference between `type Vector = (Double, Double, Double)' and `data Vector = Vector Double Double Double' ?
18:54:41 <ddarius> jleevdev: They are isomorphic.
18:54:51 <jleedev> it seems to me the only advantage of the datatype would be to inherit from a class
18:55:03 <mauke> you can't inherit from classes
18:55:14 <jleedev> *blink* instance a class
18:55:41 <jleedev> ddarius: isomorphic in what sense? obviously, they mean the same thing, but aren't there certain things one can and can't do?
18:56:25 <ddarius> isomorphic in that they have all the same values.  You can instance a data type is one thing, as you mentioned, that you can't do with tuples (usually because they already have an instance).
18:56:27 <sorear> jleedev: Not really.
18:56:36 <Cale> jleedev: Well, the latter can, as you pointed out, be made instances of other classes. It also can't be confused with other 3-tuples of Doubles by the system
18:56:58 <Cale> (There's more information about intent in the second)
18:57:29 <jleedev> oh, because a tuple is itself a datatype
18:58:15 <jleedev> once you've declared something to be a 3-tuple of Doubles, that's it, everything's done for you. with a new datatype, you're starting from scratch.
19:02:45 <pjd> mauke: surely default methods count as inheriting
19:02:45 <sorear> @users
19:02:45 <lambdabot> Maximum users seen in #haskell: 382, currently: 318 (83.2%), active: 11 (3.5%)
19:03:11 <mauke> pjd: no
19:03:30 <Cale> jleedev: Yeah, but there aren't that many operations predefined on 3-tuples anyway
19:05:01 <jleedev> Cale: true, but if you wanted to define (+) :: Vector -> Vector -> Vector without clobbering the Num version, then you would need to use the data version.
19:06:41 <Cale> There's no default instance of Num for (a,b) anyway.
19:07:41 <Cale> (but yeah, it's probably better to use your own type for that)
19:08:40 <jleedev> also, if you wanted to use Floating t instead of Double, wouldn't you have to use your own type?
19:10:03 <littledan> @quote
19:10:03 <lambdabot> DavidRoundy says: ... the fun of haskell-cafe is that it's where all the cool people hang out
19:10:53 * jleedev discovers that there's no instance of Show for 16-tuples
19:15:03 <littledan> jleedev: shouldn't there be an infinite number of show instances, for all n-tuples?
19:15:58 <jleedev> Prelude> (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
19:15:58 <jleedev> <interactive>:1:0: No instance for (Show (t, t1, ...
19:16:05 <littledan> huh
19:16:12 <jleedev> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
19:16:13 <lambdabot>        add an instance declaration for
19:16:13 <lambdabot>       (Show (t,
19:16:13 <lambdabot>              t1,
19:16:13 <lambdabot>      ...
19:16:28 <ddarius> littledan: Read the Report.
19:16:34 <jleedev> there can't be an infinite number of instances
19:16:45 <ddarius> Sure there could be.
19:21:59 <jleedev> each size of tuple has a different type. why wouldn't you need to declare show for it individually?
19:22:02 <SamB> littledan: lets consult the report
19:23:33 <sorear>   There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation
19:23:37 <sorear>    must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
19:23:42 <sorear> IOW, 16-tuples aren't portable.
19:24:26 <SamB> http://www.haskell.org/onlinereport/basic.html#sect6.1.4
19:24:27 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
19:25:15 <SamB> arg. while you were pasting away I was viewing selection source to paste together a URL for the subsection :-(
19:25:17 <wli> It wouldn't be particularly difficult to add in some compiler magic to instantiate tuple types on the fly and derive all the necessary bits for them, too.
19:25:36 <SamB> wli: it might be pretty slow though
19:26:15 <wli> SamB: I don't see any particular reason for it to be. If you run into a tuple, generate the necessary crap. If you never see them, the code never even gets called.
19:26:18 * sorear plans to implement a provision in his compiler to automatically nestify large tuples
19:26:50 <SamB> sorear: interesting idea
19:26:55 <sorear> Anyone coding with 401-tuples deserves the triple indirection. :)
19:26:55 <wli> SamB: Heck, you could even do the same for type arithemetic garbage.
19:27:35 <SamB> sorear: so is that like blocklists in inodes?
19:27:37 <wli> sorear: Even more useful would be syntactic support for type arithmetic.
19:27:49 <SamB> wli: we don't need that
19:28:00 <sorear> SamB: yes.
19:28:05 <SamB> edwardk already implemented some type arithmatic
19:28:15 <SamB> we don't need no stinkin' syntax!
19:28:21 <jleedev> > uncurry max (3,5)
19:28:27 <lambdabot>  5
19:28:27 <wli> SamB: Technically it's all syntactic sugar over machine language.
19:28:32 <SamB> wli: well yeah.
19:28:36 <SamB> no wait!
19:28:37 <SamB> it isn't
19:28:42 <SamB> it's semantic sugar
19:28:42 <wli> SamB: So do you want conveniences or not?
19:28:52 <SamB> we do need that
19:29:01 <SamB> especially the facilities for abstraction
19:29:02 <sjanssen> sorear: does your compiler have a numeric kind yet?
19:29:18 <SamB> sorear: does your compiler have a web page yet?
19:29:40 <sorear> why would I need a numeric kind or a web page?  I think data types and let expressions are more important
19:29:49 <SamB> hehe
19:29:52 <SamB> yes probably
19:30:16 <sjanssen> sorear: no!
19:30:41 <sjanssen> I CAN HAS NUMMERIC KINDZ NAO PLZ!
19:30:42 <SamB> Cale: can you do a picture of a knight in rusty armor tilting at windmills?
19:31:01 <wli> Hmm, hGetLine seems to leave trailing \CR (\r) on the end.
19:31:01 <littledan> sorear, you're making a compiler?
19:31:09 <sorear> littledan: yes.
19:33:26 <dolio> Numeric kinds? Like :k Foo :: 3 -> 4 -> *?
19:33:39 <SamB> dolio: I think it's more like, uh.
19:33:58 <SamB> :k 1
19:34:00 <lambdabot> *
19:34:10 <dolio> Ah, okay. :)
19:34:12 <SamB> hmm.
19:34:20 <SamB> that's not what I was expecting to happen!
19:34:28 <dolio> Only works for 1.
19:34:32 <dolio> Special GHC magic.
19:34:35 <SamB> :k 2
19:34:37 <lambdabot> Only unit numeric type pattern is valid
19:34:47 <SamB> what the heck is the type "1"?
19:35:05 <SamB> @hoogle 1
19:35:05 <lambdabot> Hoogle Error: Parse Error: Unexpected character '1'
19:35:06 <dolio> :t () :: 1
19:35:08 <lambdabot>     Couldn't match expected type `GHC.Base.Unit'
19:35:08 <lambdabot>            against inferred type `()'
19:35:11 <SamB> hahahaha
19:35:23 <SamB> @djinn 1
19:35:24 <lambdabot> Cannot parse command
19:35:39 <SamB> @sr c GHC.Base.Unit
19:35:40 <lambdabot> Source not found. stty: unknown mode: doofus
19:35:43 <SamB> @src GHC.Base.Unit
19:35:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:35:59 <sorear> SamB: HsNumTy
19:36:14 <SamB> data GHC.Base.Unit = GHC.Base.Unit      -- Defined in GHC.Base
19:36:22 <dolio> :t Unit
19:36:23 <SamB> so. um. what's that for then?
19:36:23 <lambdabot> Not in scope: data constructor `Unit'
19:36:34 <sorear> SamB: you're looking very deep into the abyss.  I advise you to turn away if you value your sanity. :)
19:36:53 <SamB> sorear: it doesn't look very abyssful here
19:37:02 <SamB> if it's so abyssful, I should see this:
19:37:11 <SamB> data GHC.Base.Unit = GHC.Base.Unit      -- Defined in the abyss
19:37:20 <SamB> or possibly
19:37:29 <SamB> data GHC.Base.Unit                      -- Defined in the abyss
19:37:36 <jleedev> data SamB -- Abyss defined in you
19:37:52 <SamB> jleedev: only in Soviet Russia
19:38:16 <jleedev> so in Soviet Russia, if you gaze for long into abyss, abyss gaze into you?
19:38:31 <sorear> SamB: Anyway, this is derivable type classes, one of the many half-forgotten demons in GHC's entrails
19:38:39 <SamB> sorear: oh.
19:38:45 <SamB> that would explain why I have that one
19:38:52 <SamB> so why isn't it :1: or something then?
19:39:09 <SamB> sorear: and why haven't we gotten rid of that junk yet?
19:39:25 <SamB> it doesn't ... still work ... does it?
19:39:41 <sorear> Is someone somewhere still using it?
19:39:58 <sorear> Also, the simons got a paper or two out of that one.
19:40:11 <SamB> @go :*:
19:40:12 <lambdabot> No Result Found.
19:40:29 <SamB> sorear: doesn't mean they have to keep it in the compiler for ever and ever
19:50:33 <sorear> thoughtpolice: ping?
19:57:25 <hpaste>  chessguy pasted "parser for a column of x's/o's in a tic-tac-toe board" at http://hpaste.org/2058
19:57:35 <chessguy> ok, this code seems to work correctly
19:57:51 <chessguy> i'm wondering if there's a better/more idiomatic/more readable way to build up the column parser
20:01:33 <dolio> What's the format? 'sss\nsss\nsss'?
20:02:19 <dolio> Or no breaks?
20:02:49 <chessguy> no breaks
20:02:56 <dolio> Ah.
20:03:07 <chessguy> "x  x  x  " would match, for example
20:05:33 <dolio> Well, if you write break3, which breaks a string every three characters, then parsing columns on input is the same as parsing lines on 'concat . transpose . break3 $ input'. That could be easier.
20:06:24 <chessguy> well yes, but that approach would break down for more complex patterns, i think, wouldn't it?
20:07:43 <dolio> Maybe? I'm not sure what you have in mind. The only more complex thing to check in tic-tac-toe is the dialgonal, no?
20:08:00 <chessguy> well, eventually, i'd like to do pattern-based AI this way
20:08:56 <chessguy> so things like looking for moves that could trap the other person, etc.
20:09:11 <thoughtpolice> sorear: pong
20:09:23 <sorear> thoughtpolice: dons is awake
20:09:33 <thoughtpolice> cool. :)
20:09:49 <sorear> 19:50 < dons> ghc mix up/hs-plugins mix up of some kind
20:10:00 <sorear> 19:50 < sorear> I told him "I've seen that but can't remember what causes it, you'll have to wait for dons"
20:10:03 <sorear> 19:51 < dons> been out all night. too tired to fix bugs now :)
20:10:50 <thoughtpolice> dons: it's cool. I'm having some fun with harpy right now so my mind is a little distracted anyhoo. :)
20:11:21 <chessguy> dolio, e.g.: if we're listing the squares left-to-right, top-to-bottom, and the current board is something like this: " xo  o  x"
20:11:48 <chessguy> then putting an x in the bottom middle square is a fork of sorts
20:12:07 <chessguy> i'd like to eventually build up patterns that recognize things like that
20:12:37 <dolio> Well, parsing rotated input could reduce the number of such patterns you'd have to recognize, although you'd have to rotate the move back accordingly.
20:12:55 <chessguy> dolio, yes, i was thinking of writing combinators to rotate patterns
20:18:11 <chessguy> dolio, though if i were going to do that, i'd probably write the actual patterns in some other format and then build the parsers from that format
20:27:07 <chessguy> dolio, i'd love to be able to eventually express this strategy mostly in parsers: http://en.wikipedia.org/wiki/Tic-tac-toe#Strategy
20:28:54 <dolio> Hmm.
20:37:10 <sorear> sjanssen: What's the advantage of a natural kind over plain data S x ; data Z?  Or are you proposing something *really* crazy like equational unification?
20:38:13 <f00li5h> allright, what's going on in here!?
20:38:28 <mauke> fun
20:38:34 <sorear> f00li5h: Not much, you've hit one of our rare idle periods.
20:38:38 <chessguy> f00li5h, everyone fell asleep
20:38:47 <f00li5h> oh...
20:39:01 <mauke> @vixen are you awake?
20:39:01 <lambdabot> i truely am
20:39:14 <sorear> f00li5h: If you want to know what the topic is, *points to the topic*
20:39:49 * f00li5h notes that the topic is some kind of list construct
20:39:53 * Saizan is back home only because it's dawning here
20:40:23 <mauke> yes, it's a list of strings
20:40:27 <sorear> f00li5h: yeah :)  it's one of our minor traditions
20:40:48 <f00li5h> oh, traditions... neat
20:41:00 <mauke> @quote
20:41:00 <lambdabot> Binkley says: most people's gender inference is broken
20:41:04 <sorear> > ["ab","cd","ef","gh"] -- list of strings
20:41:04 <ddarius> Doesn't the bot use it?
20:41:09 <lambdabot>  ["ab","cd","ef","gh"]
20:41:11 * f00li5h begins snacking on  http://blip.tv/file/324976
20:41:12 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
20:41:15 <sorear> ddarius: Only if you +o her
20:41:27 <f00li5h> lambdabot: meow?
20:41:33 <mauke> @list
20:41:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:41:44 <mauke> or we could -t #haskell
20:41:49 <sorear> f00li5h: she doesn't speak natural language
20:41:59 <f00li5h> @meow?
20:41:59 <lambdabot> Unknown command, try @list
20:42:04 <sorear> @botsnack
20:42:04 <lambdabot> :)
20:42:40 <f00li5h> ah. that url was to a flash movie of some kind... that explains the constant paging, and the slowness
20:43:11 <sorear> yeah.  it's a three hour video tutorial
20:43:25 <f00li5h> i'd say that's more than a snack then
20:43:26 <sorear> haskell.org is a perfectly normal web site, however
20:44:15 <mauke> but SPJ is totally awesome!
20:57:59 <reffie> is there a shorter way to do repeat an operatino X times than mapM_ (\_->...) $ take X $ repeat 1 ?
20:58:15 <sorear> replicateM_ n act
20:58:19 <reffie> thanks
20:58:45 <sorear> Note that replicateM_ isn't in the h98 Monad library, only the new Control.Monad.
20:58:49 <mauke> you should at least replace take X $ repeat 1 by [1 .. X]
20:59:02 <reffie> mauke doh :)
20:59:31 <ddarius> [1,1..]
20:59:53 <ddarius> mauke: That's not the same thing.
21:00:04 <mauke> it's same enough
21:00:18 <sorear> replicate X 1
21:00:19 <ddarius> Yeah, with the const
21:02:30 <SamB_XP_> I think PArray has a function returning an array of n ()s?
21:03:01 <sorear> http://darcs.haskell.org/packages/ndp
21:03:03 <lambdabot> Title: Index of /packages/ndp
21:05:21 <SamB_XP_> not too easy to navigate in a browser is it?
21:06:06 <sorear> there's a _darcs dir ;)
21:06:47 <SamB_XP_> yes but then I'd to, um, hit ScrollLock ScrollLock 1
21:06:56 <SamB_XP_> and find a directory to put it in
21:06:58 <SamB_XP_> and darcs get it
21:07:30 <SamB_XP_> and then I'd still need to grep it!
21:08:00 <SamB_XP_> well I found the PArray family
21:12:19 <SamB_XP_> ah, yes. and PArray () is in fact represented basically by an Int, as I remembered: http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/Lifted/Instances.hs
21:12:22 <lambdabot> http://tinyurl.com/24zdzf
21:47:04 <wli> This code is a mess.
21:48:23 <sorear> All of it is.
21:48:30 <sieni> any code is a mess
21:48:43 <dmwit> Nobody to blame but yourself, I guess.
21:48:45 <sieni> it is, after all, code
21:49:16 <wli> I was just doing some quick and dirty exploring of networking bits.
21:49:19 <Korollary> Is this the recovering programmers therapy group?
21:49:29 <dmwit> Who's recovering?
21:49:34 <Korollary> ok, never mind
21:49:36 <wli> I appear to have structured it all wrong but gotten a good idea of how to do it the next time.
21:50:05 <sieni> well, i'm not recovering yet, since i haven't had the pleasure to do something else for a living for a while
21:50:25 <wli> A lot of the MonadState stuff was pure crap.
21:53:19 <wli> There were a number of mysterious failures to update state that were probably related to the extraneous MonadState bits.
21:55:12 <wli> For the most part I should've been able to do something like mapMVar :: (t -> t) -> MVar t -> IO ()
21:57:11 <wli> Otherwise using the stock modifyMVar
21:59:33 <wli> where mapMVar f mv = do { v <- takeMVar mv ; putMVar mv (f v) }
22:01:23 <sorear> uhm, isn't that just modifyMVar_?
22:01:32 <sorear> :t GHC.Conc.modifyMVar_
22:01:38 <lambdabot> Not in scope: `GHC.Conc.modifyMVar_'
22:01:49 <wli> No, modifyMVar_ :: MVar t -> (t -> IO t) -> IO ()
22:01:49 <sorear> :t Control.Concurrent.MVar.modifyMVar_
22:01:51 <lambdabot> forall a. GHC.IOBase.MVar a -> (a -> IO a) -> IO ()
22:02:15 <wli> The above uses a pure function to modify the MVar
22:02:47 <wli> It could be done as mapMVar f mv = modifyMVar_ mv (return . f) I suppose.
22:04:18 <glguy_> modifyMVar also catches IO exceptions
22:04:28 <glguy_> and in the case of one, returns the original value to the mvar
22:05:04 <wli> I think the point I was making was that the state transition was damn near pure.
22:08:11 * dolio sucks at nethack.
22:08:35 <TSC> Killed by a grid bug?
22:08:44 <dolio> Brown mold.
22:08:50 <TSC> Wow
22:09:48 <SamB_XP_> you should play online
22:09:57 <SamB_XP_> or watch others, even
22:12:31 <dolio> I suppose that's easier than getting good myself.
22:12:58 <SamB_XP_> I meant, to see how it's done
22:13:02 <SamB_XP_> that's not cheating1
22:13:09 <SamB_XP_> s/1/!/
22:13:10 <dolio> :)
22:13:15 <SamB_XP_> it's like playing at an arcade
22:13:21 <sorear> Just being better won't make you die less.
22:13:33 <SamB_XP_> no, but you will die more strategically
22:13:39 <dolio> Heh.
22:13:43 <sorear> 5 *identified* AoLS in pack, polymorph into vrock, bite cockatrice
22:14:14 <SamB_XP_> I'm not very good either
22:14:23 <sorear> Kill medusa with /oD, get distracted briefly, continue playing while paying no attention to the usick counter
22:14:45 <SamB_XP_> oh, another interesting thing about playing online is that you can run into other people's bones far more easily than with, say, hearse
22:30:58 <timthelion> I would like to continue working on my program before I get an answer to this report... any idea how to debug it?http://hackage.haskell.org/trac/ghc/ticket/1585#preview
22:31:00 <lambdabot> Title: #1585 (Um, an error, I don't even understand it.) - GHC - Trac
22:32:19 <Cale> I'll have a look
22:32:28 <sjanssen> timthelion: does Roledex import anything from Config.hs?
22:32:47 <sjanssen> timthelion: I've tripped over elusive separate compilation things in xmonad before
22:33:02 <dibblego> @let isOddNumber x = x `mod` 2 == 0
22:33:06 <lambdabot> Defined.
22:33:12 <mauke> :t odd
22:33:14 <lambdabot> forall a. (Integral a) => a -> Bool
22:33:22 <Cale> dibblego: that would be even
22:33:27 <dibblego> er thanks
22:33:49 <dibblego> @let isEvenNumber x = x `mod` 2 == 0
22:33:50 <lambdabot> Defined.
22:34:06 <dibblego> @forget isOddNumber
22:34:07 <lambdabot> Unknown command, try @list
22:34:25 <jfredett> > even 2
22:34:26 <lambdabot>  True
22:34:27 <timthelion> sjanssen: it imports the same stuff as Accordian
22:34:31 <jfredett> > odd 1
22:34:33 <lambdabot>  True
22:34:36 <dibblego> ?info odd
22:34:36 <lambdabot> odd
22:34:40 <Cale> :t odd
22:34:42 <jfredett> @src odd
22:34:42 <lambdabot> odd = not . even
22:34:42 <lambdabot> forall a. (Integral a) => a -> Bool
22:34:48 <dibblego> @undefine isOddNumber
22:34:50 <lambdabot> Undefined.
22:34:50 <jfredett> @src even
22:34:51 <lambdabot> even n = n `rem` 2 == 0
22:35:15 <dibblego> ?check \x y -> odd x && odd y ==> even (x + y)
22:35:16 <lambdabot>  Add a type signature
22:35:21 <dibblego> ?check \x y -> odd x && odd y ==> even (x + (y :: Int))
22:35:23 <lambdabot>  Arguments exhausted after 314 tests.
22:35:27 <Cale> 1 + 1 = 0 (mod 2)
22:35:33 <jfredett> i love those definitions, like odd, odd = not . even, its frakking poetic
22:35:56 <dibblego> ?check \x y -> odd x && odd y ==> even (x + (y :: Int))
22:35:57 <lambdabot>  Arguments exhausted after 340 tests.
22:36:45 <dibblego> I just got home and my son asserted "odd plus odd is even"
22:36:54 <jfredett> :)
22:36:54 <Cale> dibblego: That's true.
22:37:00 <jfredett> heh, geek in the making
22:37:01 <dibblego> Cale, I'm proving it to him :)
22:37:04 <Cale> ah
22:37:10 <jfredett> nifty
22:37:26 <Cale> One way to prove it is to use modular arithmetic
22:37:31 <jfredett> teach him categories next
22:37:36 <jfredett> Cale: not so
22:37:43 <dibblego> I think the lambdabot expression was enough for him
22:38:15 <jfredett> an odd number is 1 + an even number, trivially
22:38:32 <jfredett> all even numbers are divisible by 2, by defn
22:38:38 <jfredett> so, given x, y, odd
22:38:44 <bitwize> @check \ x :: Int -> (x*x) - ((x-1)*(x+1)) == 1
22:38:44 <lambdabot>  Parse error
22:38:47 <jfredett> 1 + x' = x, similar for y
22:38:51 <dibblego> ?type and
22:38:53 <lambdabot> [Bool] -> Bool
22:38:54 <jfredett> 2 + x' + y' = x + y
22:39:02 <dibblego> @let and' = (&&)
22:39:04 <lambdabot> Defined.
22:39:04 <bitwize> @check \ x  -> (x*x) - ((x-1)*(x+1)) == 1
22:39:05 <lambdabot>  Add a type signature
22:39:27 <jfredett> if 2x'' = x' similar for y''
22:39:38 <jfredett> 2 + 2x'' + 2y'' == x + y
22:39:42 <Cale> (2n+1) + (2m+1) = 2(n+m) + 2 = 2 (n+m+1)
22:39:52 <dibblego> ?check \x y -> odd x L.and' even y ==> odd (x + (y :: Int))
22:39:53 <lambdabot>  Couldn't match expected type `(Bool -> Bool -> Bool)
22:40:04 <dibblego> ?check \x y -> odd x `L.and'` even y ==> odd (x + (y :: Int))
22:40:05 <lambdabot>  Arguments exhausted after 323 tests.
22:40:24 <jfredett> err- 2(n+m) + 2  is an even plus 1 plus 1
22:40:31 <dibblego> ?check \x y -> odd x `L.and'` odd y ==> odd (x + (y :: Int))
22:40:32 <lambdabot>  Falsifiable, after 0 tests: -1, 1
22:40:36 <jfredett> and vis a vis, even,
22:40:43 <Cale> 2 (n+m+1) is divisible by 2, and hence even :)
22:40:50 <jfredett> that too
22:40:53 <jfredett> :P
22:40:58 <jfredett> but see, no modular arithmetic
22:41:09 <jfredett> its way easier with modular arithmetic
22:41:13 <dibblego> > odd 1000000
22:41:13 <jfredett> but- not necessary
22:41:14 <Cale> jfredett: Yeah, you could also just say that 1 + 1 = 0 (mod 2)
22:41:14 <lambdabot>  False
22:41:36 <jfredett> Cale, true, but its not _required_ :P
22:41:43 <dibblego> > odd 17
22:41:44 <lambdabot>  True
22:41:44 <Cale> I never said it was :)
22:42:04 <bitwize> Back in my BASIC days I would test for evenness with IF A/2 = INT(A/2).
22:42:06 <sorear> whoa
22:42:08 <jfredett> oh- i though you said "only" not "one
22:42:10 <jfredett> "
22:42:13 <jfredett> my bad
22:42:18 <sorear> where'd all this activity come from!
22:42:31 <jfredett> my hat
22:42:35 <jfredett> I pulled it right out
22:42:52 <jfredett> anywho, back to jumper fiddling, stupid hard drives
22:43:33 <dibblego> ?check \x -> odd x ==> not (even x)
22:43:34 <lambdabot>  Add a type signature
22:43:38 <dibblego> ?check \x -> odd x ==> not (even (x :: Int))
22:43:40 <lambdabot>  OK, passed 500 tests.
22:43:42 <timthelion> an even number plus an even number is even, we can prove that becase if we divide each number into two stacks, there's nothing sticking up, and an odd number plus an odd number is even because when we divide those numbers into 2 stacks, there are a total of 2 things sticking up and 2 is even. Is there a better proof?
22:44:09 <dibblego> I think it will be a while before I let my son join this channel :)
22:44:34 <timthelion> porque?
22:44:38 <sorear> Has he started raiding your collection of leftover college texts yet?
22:44:40 <timthelion> how old?
22:44:53 <bitwize> @check \ x ->  (x*x) - ((x-1)*(x+1)) == (1 :: Int)
22:44:55 <lambdabot>  OK, passed 500 tests.
22:44:59 <dibblego> sorear, no, some of my books on cosmology though
22:45:01 <dibblego> timthelion, 6
22:45:06 <timthelion> oh, ok,
22:45:13 <timthelion> can he type yet?
22:45:24 <dibblego> yes, he just ran off to play with ghci in his bedroom
22:45:34 <timthelion> touch?
22:45:38 <dibblego> not even I can do that
22:45:39 <jfredett> heh, already formulating theorems at 6
22:45:41 <jfredett> I love it
22:45:44 <dibblego> but I am missing fingers :)
22:45:59 <jfredett> I just kind of hit my head on the keyboard
22:46:05 <jfredett> and hope something legible comes out
22:46:09 <jfredett> I
22:46:12 <jfredett> I'm a really lucky guy
22:46:13 <timthelion> I can only touch type, as I have remaped my keyboard
22:46:41 <jfredett> timthelion: what? QWERTY not good enough for you?
22:46:52 <timthelion> dvorak aint either
22:47:28 <jfredett> pfft
22:47:38 <jfredett> you silly kids and your custom keyboards
22:47:59 <timthelion> well, I mean we have to do something to feal special...
22:48:15 <ddarius> Custom keyboards?
22:48:16 <jfredett> back in my day, we had to walk uphill 5 miles in the snow both ways, just to use a 286.
22:48:37 <timthelion> especialy me, since I'm in such shock at not being the youngest haskeller
22:48:37 <jfredett> I have a buddy with a sideways keyboard
22:48:45 <jfredett> tells me its "ergonomic"
22:48:46 <timthelion> I lay down
22:49:16 <jfredett> ergonomic my ass, real men deal with RSI and Carpal Tunnel, and they dont whine about it neither!
22:50:04 <timthelion> if you want ergo, google datahands and click the seccond result
22:50:11 <JBGood25> timthelion, you could use rule induction to prove that the sum of an odd and an odd is an even, but i'd really rather not bother
22:51:32 <sorear> I don't seem to need to.
22:51:33 <puusorsa> timthelion, "This site is temporarily unavailable."
22:51:34 <sorear> odd_even_plus : forall n m : nat, odd n -> odd m -> even (n + m)
22:52:19 <puusorsa> first link goes to http://www.datahand.com/ which is available and seems ergonomic
22:52:20 <lambdabot> Title: Ergonomic Keyboards By DataHand To Reduce Keying Stress.
22:52:30 <timthelion> puusorsa: seccond
22:52:42 <jfredett> timthelion: pah! sillyness!
22:52:42 <timthelion> puusorsa: not the first one
22:53:36 <puusorsa> timthelion, second link doesnt work
22:53:54 <puusorsa> goes to datahands.com = "This site is temporarily unavailable."
22:54:56 <dibblego> ?check \x y -> x + y == y + (x :: Int)
22:55:00 <timthelion> really? for datahands plural
22:55:05 <lambdabot>  OK, passed 500 tests.
22:55:10 <jfredett> ... timthelion, I'm reading your blog entry about the Datahands... oh my god. so lazy. I can only aspire to be that lazy
22:55:13 <jfredett> unbelievable
22:55:40 <jfredett> i mean, oh my god-
22:55:40 <dibblego> ?check \x y -> x * y == y * (x :: Int)
22:55:42 <lambdabot>  OK, passed 500 tests.
22:55:53 <sorear> apply plus_comm.
22:56:03 <jfredett> laying down, monitor mounted above you... *twitch*
22:56:14 <timthelion> jfredett: isn't it beutifull?
22:56:29 <jfredett> ... its certainly, something
22:56:39 <jfredett> timthelion++ for an incredible amount of slack
22:56:44 <jfredett> http://www.timthelion.com/cgi-bin/blosxom.cgi/datahands.html
22:56:46 <lambdabot> Title: timthelion's blog
22:56:53 <jfredett> i can't even describe it
22:57:52 <dibblego> you can have numbers less than zero, can't you?
22:58:03 <sorear> > (-1)
22:58:05 <lambdabot>  -1
22:58:31 <dibblego> > (-1) < 0
22:58:32 <lambdabot>  True
22:58:39 <timthelion> jfredett: I hate it, I've been programmnig since I was 9, and I've run a 2:01 800m, but what do I get attention for?  my freekin keyboard!
22:58:48 <dibblego> ?check \x y -> x - y == y - (x :: Int)
22:58:49 <lambdabot>  Falsifiable, after 4 tests: 0, 2
22:59:23 <dibblego> > (-2) < 0
22:59:24 <lambdabot>  True
23:00:17 <jfredett> timthelion: lol
23:00:47 <jfredett> we're geeks, timthelion, what do you want-
23:01:06 <timthelion> fawning hot chicks?
23:01:12 <jfredett> 9 isn't that uncommon an age to start programming, I dont go outside anymore, so the only interesting thing to me- keyboard
23:02:06 <jfredett> maybe if there were sheep- i might say something about them
23:02:09 <jfredett> are there sheep?
23:02:36 <wli> Is there a lib function to take [Either t t'] -> ([t],[t']) ?
23:02:37 <timthelion> sheep?
23:02:44 <JBGood25> i'm rather worried if you're interested in sheep
23:03:07 <jfredett> What! They're cuddly
23:03:08 <timthelion> I'm into goats myself
23:03:10 <mauke> @hoogle [Either a b] -> ([a], [b])
23:03:10 <lambdabot> No matches, try a more general search
23:03:13 <jfredett> and they make cool noises
23:03:27 <dibblego> > (-5) > (-10)
23:03:29 <lambdabot>  True
23:03:31 * jfredett lives out by farms
23:03:32 <wli> Basically classify xs = ([x | Left x <- xs], [x | Right x <- xs])
23:03:38 * jfredett sees lots of sheep
23:03:44 <timthelion> but they can't pick up something twice their size on their heads
23:03:55 <wli> Is there a funky arrow combinator to do that? ;)
23:04:00 <dibblego> 0
23:04:01 <jfredett> thats okay, they dont need to
23:04:15 <jfredett> sheep are dumb, they eat grass, walk around, and eat grass
23:04:24 <jfredett> occasionally baa'ing or something
23:04:28 <mauke> :t foldr (\e (l,r) -> case e of Left x -> (x:l,r); Right x -> (l,x:r))
23:04:30 <lambdabot> forall t t1. ([t], [t1]) -> [Either t t1] -> ([t], [t1])
23:04:32 <jfredett> they are oblivious to the need to lift anything
23:05:12 <Adamant> why do Scots wear kilts?
23:05:28 <mauke> :t first
23:05:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
23:05:53 <jfredett> Adamant: i dont think i want to know
23:06:15 <Adamant> jfredett, because sheep can hear zippers at 100 paces
23:06:22 <jfredett> ... fucking hard drives...
23:06:23 <wli> My wild guess is that (&&&) is involved.
23:06:29 <jfredett> Adamant: :/
23:06:49 * timthelion once saw shepperd in the C
23:07:02 <mauke> :t foldr (\e t -> either ((`first` t) . (:)) ((`second` t) . (:)) e)
23:07:03 <lambdabot> forall a b. ([a], [b]) -> [Either a b] -> ([a], [b])
23:07:30 * timthelion once saw shepperd in the Czech republic wearing traditional robes, and holding a wooden cane, and talking on a cell phone.
23:07:35 <mauke> @pl foldr (\e t -> either ((`first` t) . (:)) ((`second` t) . (:)) e)
23:07:35 <lambdabot> foldr (flip (ap (either . (. (:)) . flip first) ((. (:)) . flip second)))
23:07:46 <stepcut> @djinn [Either t t'] -> ([t],[t'])
23:07:46 <lambdabot> -- f cannot be realized.
23:07:48 * timthelion once saw shepperd in the Czech republic wearing traditional robes, and holding a wooden cane, and talking on a cell phone.
23:07:58 <stepcut> :(
23:08:55 <sorear> stepcut: djinn doesn't do recursion because without a data/codata split there's nothing to stop it from saying let x = x in x to everything
23:09:18 <stepcut> sorear: ah.
23:09:48 <stepcut> too bad. That seems like the sort of function that would be nice to autogenerate
23:10:09 <sorear> also, djinn relies for correctness on Gentzen's cut-elimination theorem, which is huge and fragile.  changing the logic would be likely to cause problems.
23:10:14 <mauke> :t foldr (\e t -> liftM2 either ($ first) ($ second) ((. (:)) . flip flip t) e)
23:10:16 <lambdabot> forall a. ([a], [a]) -> [Either a a] -> ([a], [a])
23:10:36 <sorear> not that I really understand what cuts are
23:10:39 <wli> wow
23:10:49 <wli> mauke: you rock, keep going
23:11:52 <sorear> I *think* cuts are the CH counterpart to Î²-redexes, with the cut elimination theorem corresponding to Tait's proof of Î²-normalizability of the simply typed lambda calculus, but I could be very wrong
23:12:46 <mauke> :t foldr (\e t -> (liftM2 either ($ first) ($ second) . (((. (:)) .) . flip flip)) t e)
23:12:48 <lambdabot> forall a. ([a], [a]) -> [Either a a] -> ([a], [a])
23:13:10 <mauke> oh wait, I've lost b somewhere along the way
23:13:23 <mauke> :t foldr (flip (liftM2 either ($ first) ($ second) . (((. (:)) .) . flip flip)))
23:13:25 <lambdabot> forall a. ([a], [a]) -> [Either a a] -> ([a], [a])
23:14:15 <stepcut> :p
23:17:37 <wli> @pl \e t -> (((`first` t) . (:)) ||| ((`second` t) . (:))) e
23:17:37 <lambdabot> flip (ap ((|||) . (. (:)) . flip first) ((. (:)) . flip second))
23:18:43 <wli> > foldr (flip (ap ((|||) . (. (:)) . flip first) ((. (:)) . flip second))) ([],[]) [Left 1, Right 'a']
23:18:44 <lambdabot>  ([1],"a")
23:19:29 <wli> The real question was whether there was something for this floating around in the standard libs.
23:23:13 <wli> Perhaps a better-looking pointfree solution is:
23:23:16 <wli> foldr ((first . (:)) ||| (second . (:))) ([],[])
23:23:49 <jfredett> ... totally just caught a bat
23:24:11 <jfredett> fraking bats flying through this house, you'd think we were in transylvania
23:24:42 <jfredett> :/
23:24:54 <wli> Is this generalizable to more than just lists?
23:26:06 <wli> It needs more than Functor.
23:26:37 <wli> Data.Map can do it, Data.Set can do it, Data.Sequence can do it. Not sure what else.
23:27:37 <wli> They're all sort of set-like.
23:28:55 <wli> They're all monoids, too.
23:30:54 <wli> I think there's some redundancy in (first . (:)) ||| (second . (:))
23:30:57 <sorear> All mathematical MonadPlus can do it (Set, Sequence, List, etc)
23:31:14 <sorear> But really all you need is MonadZero
23:31:26 <wli> sorear: And Foldable?
23:31:35 <sorear> wli: No Foldable required.
23:31:58 <sorear> wli: You can do it on IO, which is MonadZero but hardly Foldable.
23:32:10 <wli> Ergh...
23:32:56 <wli> I don't see how to do it without Foldable.
23:33:08 <wli> Or, for that matter, MonadZero.
23:34:39 <sorear> :t \ coll -> (coll >>= either return (\_ -> mzero), coll >>= either (\_ -> mzero) return)
23:34:42 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m) => m (Either a b) -> (m a, m b)
23:36:36 <wli> holy cow
23:37:59 <dons> ?users
23:38:00 <lambdabot> Maximum users seen in #haskell: 382, currently: 314 (82.2%), active: 7 (2.2%)
23:38:25 <wli> @pl \ coll -> (coll >>= either return (const mzero), coll >>= either (const mzero) return)
23:38:25 <lambdabot> liftM2 (,) (either return (const mzero) =<<) (either (const mzero) return =<<)
23:39:06 <sorear> There's probably a shorter way
23:39:55 <wli> There's some redundancy there, but I suspect that this is not the most efficient way to go about it... might need to assume Foldable/etc. to avoid making two passes.
23:46:24 <wli> Data.Foldable.foldr ((first . (mappend . return)) ||| (second . (mappend . return))) (mempty, mempty)
23:47:13 <sorear> @src ArrowChoice
23:47:13 <lambdabot> Source not found. My pet ferret can type better than you!
23:47:19 <sorear> @type (+++)
23:47:21 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:47:30 <sorear> @type (|||)
23:47:32 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
23:48:56 <sorear> :t join (+++) (mappend . return)
23:49:00 <lambdabot> forall b (m :: * -> *). (Monoid (m b), Monad m) => Either b b -> Either (m b -> m b) (m b -> m b)
23:51:05 <wli> Yeah, it ties the types together.
23:51:35 <wli> (mappend . return) +++ (mappend . return)
23:58:33 <wli> Maybe there's a way to break down (f . g) ||| (h . g)
23:59:51 <mauke> liftM2 (|||) (f .) (h .) g
