00:00:02 <RyanT5000> so if i'm using GHC.IOBase, i can basically just treat it like a State monad, then package it up when i'm done?
00:00:11 <RyanT5000> i.e.: just thread the State# RealWorld through it?
00:00:48 <glguy> ?quote recognizes
00:00:48 <lambdabot> glguy says: Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
00:01:15 * goalieca disk swapped out runnning it
00:01:16 <goalieca> hehe
00:01:20 <goalieca> anyways later. exam tmw
00:01:23 <goalieca> peace
00:01:56 <wli> > let f cmp = unfoldr (fmap ((uncurry ((uncurry (.)) . ((first . (:)) &&& (partition . cmp)))) . liftM2 (,) head tail) . liftM2 fmap const listToMaybe) in f (\x y -> snd x == snd y) [(i, j) | i <- [1..3], j <- ['a'..'c']]
00:01:58 <lambdabot>  [[(1,'a'),(2,'a'),(3,'a')],[(1,'b'),(2,'b'),(3,'b')],[(1,'c'),(2,'c'),(3,'c')]]
00:01:58 <dons> ok, what can we do to help train hugh perkins, if he's not picking up the social norms for the -cafe, on his own?
00:02:01 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/27336
00:02:04 <lambdabot> Title: Gmane -- Mail To News And Back Again
00:02:14 <vincenz> (kick) (kick)
00:02:23 * vincenz looks for -cafe ops
00:02:30 <RyanT5000> dons: i cut the running time by 47%
00:02:31 <vincenz> Where is my big red *KICK* button?
00:02:32 <Heffalump> what about Bulat?
00:02:33 <dons> as much as I'd like to just ban him, I don't think we're supposed to do that
00:02:48 <glguy> vincenz: Philippa_ is the only one
00:02:54 <glguy> ?seen Philippa_
00:02:54 <lambdabot> Philippa_ is in #scannedinavian, #oasis, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa_ speak 19h 47m 6s ago.
00:03:08 <dons> yes, the hostility of BZ and HP combined make up about 90% of the unpleasentness on the list
00:03:21 <glguy> OH, the mailing list
00:03:22 <Heffalump> Philippa should be in Cambridge
00:03:24 <dons> BZ is just weird, i think we just have to live with that.
00:03:45 <dons> RyanT5000: wow? over my version?
00:04:20 <wli> I suspect liftM2 (,) head tail) . liftM2 fmap const listToMaybe may simplify.
00:04:21 <RyanT5000> dons:yep
00:04:23 <vincenz> BZ sounds exactly as the google russian->english translator.  I know, I had to use that on adept's homepage to read his blog.
00:04:29 <vincenz> s/as/like/
00:04:30 <dons> brilliant stuff.
00:04:36 <dons> vincenz: heh
00:04:51 <glguy> wli: what are you simplifying?
00:05:03 <dons> but HP hmm. he's kind of enthusiastic, clueless, unaware of his words
00:05:03 * ADEpt awakes
00:05:07 <wli> glguy: f cmp = unfoldr (fmap ((uncurry ((uncurry (.)) . ((first . (:)) &&& (partition . cmp)))) . liftM2 (,) head tail) . liftM2 fmap const listToMaybe)
00:05:09 <RyanT5000> dons: i'll give you the diff
00:05:12 <Heffalump> I don't really think the post you replied to was particularly inflammatory
00:05:16 <dons> i love the russian->enligsh blog trnslations
00:05:20 <Heffalump> particularly compared to BZ
00:05:26 <ADEpt> vincenz:
00:05:31 <glguy> @type \ cmp -> unfoldr (fmap ((uncurry ((uncurry (.)) . ((first . (:)) &&& (partition . cmp)))) . liftM2 (,) head tail) . liftM2 fmap const  listToMaybe)
00:05:32 <vincenz> ADEpt: ?
00:05:33 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
00:05:39 <RyanT5000> dons: s/divInt# t 2#/uncheckedIShiftRA# t 1#/
00:05:45 <RyanT5000> dons ;)
00:05:49 <dons> Heffalump: yeah, but its just every second email he writes is like that.
00:05:57 <ADEpt> vincenz: nothing, just wanted to say "hi" :)
00:05:59 <wli> glguy: More legibly than the intermediate result, f cmp = unfoldr (\l -> fmap (const $ let x:xs = l in first (x:) . partition (cmp x) $ xs) $ listToMaybe l)
00:06:08 <vincenz> ADEpt: oh, hi :)
00:06:15 <JBGood25> RyanT5000, so it doesn't optimize that? sad
00:06:26 <dons> Heffalump: so much noise, so little signal.
00:06:37 <wli> glguy: woops still an intermediate result
00:06:40 <Heffalump> I'm not sure that intervention of your nature is the answer, but we shall see :-)
00:06:56 <vincenz> Heffalump: at least he's made aware of his actions
00:06:59 <vincenz> the possibilities are three fold
00:07:03 <dons> yeah, i held off this morning. i've actively ignored, or only replied privately, to other things
00:07:10 <wli> glguy: I started off with unfoldr (\l -> fmap (const $ let x:xs = l in first (x:) . partition ((== snd x) . snd) $ xs) $ listToMaybe l)
00:07:13 <dons> basically i want to direct his noisy queries away from the list
00:07:15 <vincenz> 1) h's a troll and ignores it, 2) he singles out dons and says he feels attacked by dons (turning the thing on dons), 3) he gets the message
00:07:16 <RyanT5000> JBGood25: apparently not; it dropped from 37 seconds to 17 on my machine
00:07:50 <RyanT5000> JBGood25: actually, 37 to 18, which i guess means i had it backwards; i saved 53% instead
00:07:57 <JBGood25> i guess it wasn't going compiling through c, then
00:07:58 <dons> vincenz: i guess he'll ignore it, and reply without addressing the point. that's what happened the first time I raised this. its extremely frustrating
00:08:11 <RyanT5000> dons: it seems that an optimizer rule is in order for this situation
00:08:12 <vincenz> killfile?
00:08:20 <dons> its as if he came from some hostile community, and is expecting similar results here.
00:08:27 <wli> RyanT5000: Strength reduction lacking? Ouch.
00:08:36 <dons> we're seeing a bit more of that, people just trained to start with rudeness by default
00:08:43 <dons> then they slowly realies they don't have to be like that
00:08:58 <dons> RyanT5000: very interesting
00:09:11 <dons> RyanT5000: be sure to confirm the output is still correct
00:09:20 <dons> its easy to forget that -- i know :)
00:10:13 <glguy> dons: Hugh Perkins (HP)?
00:10:23 <RyanT5000> dons: i checked it
00:10:38 <dons> Heffalump: i'm inclined to give up on HP after this though. let his mails go unanswered.
00:10:41 <dons> glguy: yeah
00:10:51 <glguy> dons: think anyone will take him up on that PhD?
00:10:52 <glguy> ;)
00:10:52 <dons> see, he does want things from the community though, http://article.gmane.org/gmane.comp.lang.haskell.cafe/27166/match=phd
00:10:54 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/2l6yv9
00:11:11 <glguy> dons: we were on the same page it seems
00:11:24 <Heffalump> oh, he's the one with the CV?
00:11:32 <vincenz> holy cow
00:11:32 <wli> glguy: Basically it's groupBy sans Ord/sorting.
00:11:36 <vincenz> I just looked at his picture in that email
00:11:40 <vincenz> he looks much older than I thought he was
00:11:44 <vincenz> I thought he was just a 14 year old
00:12:08 * vincenz has googled himself sometime, finding silly messages with plenty of questions as well (from when I was ... 15)
00:12:29 <johnnowak> vincenz: it can be quite painful
00:12:33 <shachaf> @age vincenz
00:12:33 <lambdabot> Maybe you meant: arr ask
00:12:39 <glguy> wli: one that doesn't need the elements to be adjacent, right?
00:12:41 <vincenz> johnnowak: self-googling?
00:12:42 <dons> maybe what we need to have done is set up the hackers haskell list
00:12:46 <johnnowak> vincenz: aye
00:12:49 * vincenz nods
00:13:40 <wli> glguy: Yes, though I'd actually be willing to take an Ord constraint in the interest of efficiency.
00:14:14 <glguy> wli: why not use groupBy and sortBy then?
00:14:21 <glguy> or is this just an exercise
00:14:34 <wli> glguy: That's what I usually do, but it gets repetitive.
00:15:19 <vincenz> augustss: been thinking.  if you combine your symbolic math module with the one that I've seen by someone else for derivatives,, you could get any order derivatives if you just reify data-expressions back into functions
00:15:25 <glguy> wli: couldn't you just wrap those two up into one function?
00:15:26 <wli> So the task for my personal library is the most general thing efficiently possible.
00:15:28 <vincenz> (reify ... eval)
00:16:17 <RyanT5000> dons: as far as output goes: i get the same output as the old program, which is the same as is listed in the haskell "build & benchmark results" as well as in those of several other languages' implementations (all those that i checked).  however, it is a different result from the reference output file; i assume the reference output file is wrong.
00:16:20 <augustss> vincenz: sure
00:16:51 <wli> glguy: It's not a very important issue.
00:17:13 <glguy> ok :)
00:17:30 <Heffalump> is that other module one that does symbolic differentiation?
00:17:46 <vincenz> basically
00:17:48 <glguy> :t Data.Map.insertWith
00:17:49 <vincenz> have
00:17:50 <dons> haha http://johanjeuring.blogspot.com/2007/08/finding-palindromes.html
00:17:50 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
00:17:51 <vincenz> data Symbolic ...
00:17:51 <lambdabot> Title: Johan Jeuring's blog: Finding palindromes
00:17:58 <vincenz> and then instance Num Symbolic
00:17:59 <vincenz> then
00:18:11 <vincenz> data Derivative a = a :.: a
00:18:17 <dons> RyanT5000: hmm. you might just be providing a different value of N for the refernce?
00:18:20 <vincenz> instance Num Derivative
00:19:34 <RyanT5000> dons: oh; right, i didn't notice where they said that the reference was for N=100
00:20:39 <dons> RyanT5000: if its faster, do upload it to the shootout
00:20:50 <dons> also, add it to the haskell shootout wiki page
00:20:50 <RyanT5000> dons: i was just now looking up how to do that
00:21:01 <dons> there's a submission tracker
00:21:11 <glguy> > let grp xs = M.toList $ M.unionsWith (+) [M.singleton x 1 | x <- xs] in grp [1,2,3,3,2,1,5]
00:21:13 <lambdabot>  [(1,2),(2,2),(3,2),(5,1)]
00:21:14 <dons> you need to create an account , then upload the file with a descriptoin of the change
00:21:29 <dons> look up the gp4 faq, then on how to submit
00:21:32 <RyanT5000> dons: however, i'm pretty sure there's another 2 huge optimizations to add: unboxing the Ints and the Doubles in the loops
00:21:48 <dons> hmm.
00:21:53 <dons> its not happening already?
00:22:03 <dons> can you send the code over? we could have a quick look tonight
00:22:17 <dons> its important to look at the core when doing this very low level work
00:22:21 <RyanT5000> dons: i'm not sure; you unboxed aij, but timesAtv and timesAv are now taking almost as much time
00:23:11 <glguy> > let grp xs = M.toList $ foldl' (\ m x -> M.insertWith (+) x 1 m) M.empty xs in grp [1,2,3,3,2,1,5]
00:23:13 <lambdabot>  [(1,2),(2,2),(3,2),(5,1)]
00:23:17 <RyanT5000> dons: and sure, i can send the code; i'll take a look at the wiki and such too
00:23:18 <wli> glguy: Not far from what I was looking at.
00:23:30 <wli> let f prj = Data.Map.toList . foldr (\x m -> Data.Map.insertWith (++) (prj x) [x] m) Data.Map.empty
00:23:41 <glguy> cool
00:23:52 <wli> woops
00:24:02 <wli> let f prj = Data.Map.elems . foldr (\x m -> Data.Map.insertWith (++) (prj x) [x] m) Data.Map.empty
00:24:15 <RyanT5000> dons: right now, with profiling on (not sure how much it disturbs accuracy - seems like not much), we've got 55.8% of the time in aij, and 44.2 in the two loops
00:24:31 <glguy> > let grp xs = M.toList $ M.fromListWith (+) [(x,1) | x <- xs] in grp [1,2,3,3,2,1,5]
00:24:33 <lambdabot>  [(1,2),(2,2),(3,2),(5,1)]
00:24:57 <dons> RyanT5000: yeah, but i only unboxed aij to get a particular order of operations explicitly
00:25:04 <dons> the other loops should still be uboxed
00:25:15 <dons> though we might need to put a better ordering in, if we know something ghc doesn't
00:26:06 <glguy> > let grp xs = M.elems $ M.fromListWith (++) [(x,[x]) | x <- xs] in grp [1,2,3,3,2,1,5]
00:26:08 <lambdabot>  [[1,1],[2,2],[3,3],[5]]
00:26:36 <wli> > let f prj = map (second (map fst)) . Data.Map.toList . foldr (\x m -> Data.Map.insertWith (++) (prj x) [x] m) Data.Map.empty in f snd [(i, j) | i <- [1..3], j <- ['a'..'c']]
00:26:37 <lambdabot>   Not in scope: `Data.Map.empty'
00:27:11 <wli> > let f prj = map (second (map fst)) . M.toList . foldr (\x m -> M.insertWith (++) (prj x) [x] m) M.empty in f snd [(i, j) | i <- [1..3], j <- ['a'..'c']]
00:27:12 <lambdabot>  [('a',[1,2,3]),('b',[1,2,3]),('c',[1,2,3])]
00:27:35 <RyanT5000> dons: hm; well, ideally the loops should be an increment, a dereference that'll be a cache hit over 99% of the time, and a conditional jump
00:28:05 <glguy> wli: I just found fromListWith, and it is likely more efficient than using foldr and insertWith
00:28:32 <RyanT5000> dons: i'd have a hard time imagining that that would consume as much time as 4 adds, a multiply, a shift, an integer->double promotion, and a double division
00:29:11 <glguy> wli: (because it uses a strict left fold)
00:29:34 <wli> glguy: nice
00:31:04 <RyanT5000> dons: how can i look at the generated assembly?
00:31:24 * glguy wife just went to the grocery store so we have lots of delicious snacks...
00:31:34 * glguy is chatting in the kitchen, tasting everything
00:31:40 <RyanT5000> dons: oh, ew, it's inlined... it'll probably be impossible to decipher
00:32:16 <vincenz> glguy: I'm sure she'll be happy you snacked up all the ingredients for a specific course
00:32:25 <dons> RyanT5000: -keep-tmp-files
00:32:29 <dons> look at the .s stuff in /tmp/
00:32:33 <glguy> I would recommend these Creme Filled Pirouette Rolled Wafters (Chocolate Hazelnut)
00:32:39 <dons> hehe glguy
00:32:44 <glguy> to anyone that likes desserts
00:32:54 <RyanT5000> glguy: those are delicious
00:33:33 <glguy> vincenz: heh, she'll only complain if I leave all the cabinets open and my computer on her counter ;)
00:33:39 <glguy> or so I've heard
00:34:53 <wli> > let f prj1 prj2 = M.toList . M.fromListWith (flip (++)) . map (prj2 &&& ((:[]) . prj1)) in f fst snd [(i, j) | i <- [1..3], j <- ['a'..'c']]
00:34:55 <lambdabot>  [('a',[1,2,3]),('b',[1,2,3]),('c',[1,2,3])]
00:35:27 <glguy> wli: fromListWith's first function is: \ new_val old_val -> merged_val
00:35:34 <glguy> wli: so you probably don't want to flip ++
00:36:01 <wli> glguy: They come out backward otherwise, though it's unclear if anything cares about list ordering.
00:36:20 <glguy> wli: it might be better to reverse all the results at the end then
00:36:33 <glguy> wli: so you don't append to the end every time
00:37:22 <njd> @user
00:37:22 <lambdabot> Maximum users seen in #haskell: 375, currently: 316 (84.3%), active: 13 (4.1%)
00:37:23 <wli> glguy: Probably best to ignore it and adjust it if anything cares.
00:38:01 <wli> No flip, then.
00:38:54 <glguy> wli: prj1 -> projection 1?
00:39:02 <wli> glguy: Yeah.
00:39:11 <dons> ok. that's it, no matter how much HP misrepresents things, I'm not replying to him anymore
00:39:44 <opqdonut> hp?
00:39:51 <olathe> Harry Potter.
00:40:00 <dons> yeah, /me goes off to do something more useful
00:40:01 <glguy> HP dies
00:40:15 <wli> A lot of times prj2 will be id but anyway.
00:40:35 <wli> (or otherwise prj1 = fst, prj2 = snd)
00:40:52 <RyanT5000> dons: there are a bunch of extraneous instructions in this loop; in particular, two floating point operations (an add and a mul) that i can't figure out the purpose of
00:40:59 <dons> hmm.
00:41:05 <dons> floating point?
00:41:07 <wli> Sorry, prj1 will often be id.
00:41:12 <RyanT5000> dons: yeah, that's why it confuses me
00:41:13 <dons> make sure no funny types are being inferred
00:41:26 <dons> when you're done, send me the code (in a couple of hours), and i'll have a look at it
00:41:39 <RyanT5000> dons: i'm not sure how they would be; aren't all these # functions monomorphic?
00:41:54 <RyanT5000> dons: unless you mean something else (i'm quickly getting out of my depth haskell-wise)
00:41:56 <dons> RyanT5000: oh, you unboxed everything?
00:42:04 <dons> and you're using Int# primitives?
00:42:06 <kral> Ahoy!
00:42:15 <RyanT5000> dons: oh, hm, maybe it's from the actual loop itself
00:42:26 <RyanT5000> dons: i didn't think of that, actually; i assumed it was in aij
00:42:30 <xpika> how does a cabal installer know what version of a c library i have
00:42:31 <RyanT5000> dons: yeah, i'll look there
00:44:08 <RyanT5000> dons: also, there seems to be a register jump in here; i'm not sure if it's an unavoidable consequence of being an stg machine, but i'm sure it's killing performance
00:44:47 <xpika> GTKHS_PKG_CHECK(svg, svgcairo, SVGCAIRO, [librsvg-2.0 >= 2.16.0],
00:44:48 <dons> hmm. there are known issues in the backend with running out of registers. check it against hte -fasm output
00:45:09 <RyanT5000> dons: hm? i meant a jump to *%eax
00:45:17 <xpika> how does it know which version of librsvg i have
00:45:54 <Heffalump> by looking in the library search path? (just guessing)
00:45:55 <dons> RyanT5000: yeah, that's the C backend
00:46:03 <dons> check with -fasm backend (it should avoid that jump, iirc)
00:46:12 <RyanT5000> dons: ah, ok
00:46:13 <dons> RyanT5000: but that's the stg machine, yep
00:46:36 <dons> and why we want to use the native code gen in the long term
00:46:36 <xpika> the filename is just librsvg-2
00:46:47 <dons> currently -fasm is usually close or better, but for Double math on x86, its worse
00:47:44 <RyanT5000> dons: i'll check it out; given that all we're asking it for here is a "fildl; fdivrl", is there any chance of it being able to do it? given that we're essentially giving it the exact thing?
00:47:50 <dons> ?remember HP [sweeping statements day] There's no point in running a program in 1024 threads, if the single-core C# version runs faster than that, and often it does!
00:47:50 <lambdabot> Done.
00:48:00 <RyanT5000> well, i guess a fstpl at some point to chuck it back into memory
00:48:12 <dons> RyanT5000: hmm. pass the right flags to gcc to get it to fix up the code/
00:48:34 <RyanT5000> dons: do we get to decide the compiler flags?
00:48:59 <dons> yeah, -optc-do-some-magic
00:49:01 <RyanT5000> (next trick: add a turing-complete command-line optimizer plugin language)
00:55:51 <Heffalump> xpika: isn't the precise version in the library somehow?
00:56:32 <thoughtpolice> dons: there any way to get screen size using hmp3's bindings? or hscurses for that matter?
00:56:43 <dons> thoughtpolice: yeah
00:57:01 <dons> scrSize
00:57:07 <dons> --
00:57:07 <dons> -- | get the dimensions of the screen
00:57:07 <dons> --
00:57:07 <dons> scrSize :: IO (Int, Int)
00:57:20 <thoughtpolice> dons: cool. i looked through but I guess I just suck at searching.
00:57:40 <dons> needs the .c file too, btw, to wrap the macros used to produce those values
00:57:52 <thoughtpolice> yeah in cbits/
01:00:38 <glguy> dons: an STUArray Int Bool is a bit array, no?
01:00:38 <thoughtpolice> hm apparently readline and curses don't play nicely together though. oh well.
01:00:51 <glguy> STUArray s Int Bool rather
01:00:54 <dons> glguy: it is, already aimed my photon cannon back at him.
01:01:10 <glguy> "One of the problems with not knowing what you are talking about is that you are often wrong"
01:01:18 <glguy> but I guess that that isn't really in the spirit
01:01:48 <dons> :)
01:01:55 <xpika> Heffalump: thats what i cant find :(
01:02:25 <Heffalump> xpika: oh, actually, it might be looking at the headers
01:02:31 <Heffalump> given that it needs them anyway to build tings
01:02:33 <Heffalump> s/tings/things/
01:03:08 <glguy> dons: your short response didn't phase him
01:03:25 <thoughtpolice> who? qwe1234? :p
01:03:41 <glguy> heh, no
01:03:49 <glguy> similarly misguided, however
01:05:01 <dons> glguy: i know. i'm clarified. that's it though.
01:05:51 <dons> s/i clarified/
01:06:21 <dons> i doubt that will stop him
01:06:37 <dons> after the last time we had this nsieve thread, he wrote 7 or so mails to himself before he wsa done
01:08:49 <glguy> dons: now that sorear made things blindingly clear, we need an AC post "zomg my head hurts lawlz puppies"
01:09:57 <RyanT5000> dons: i'm not making much progress with the c options; -O3 with fast-math doesn't make a statistically significant difference
01:09:58 <reltuk> hah...happs is slowly beginning to bend to my will
01:09:58 <dons> heh
01:10:09 <dons> reltuk: woot. kick that happs!
01:10:24 <dons> RyanT5000: ok. well, once you're done, document what you find out in the comments, and send it over
01:10:45 <RyanT5000> by send it over, you mean to where?
01:10:52 <RyanT5000> to the shootout & the wiki?
01:10:53 <glguy> to the land down under
01:11:04 <dons> to me :)
01:11:20 <dons> and i'll see if i can think of anything, then send it back, and you can upload it to the shootout + wiki
01:11:36 <glguy> in australia, is the qwerty row above or below the home row?
01:11:58 <dons> is it possible linuxer has disappeared from reddit?
01:12:22 <dons> glguy: its in the bottom right.
01:12:26 <glguy> whoa
01:12:46 <glguy> so do you have to lay down periodically, or have you learned to deal with the blood rushing to your head all day long? ;)
01:13:11 <Heffalump> how does karma actually work on reddit?
01:13:18 <dons> that's advised yes, or you can get pressure socks
01:13:36 <dons> Heffalump: submit, and some fractoin of the upvotes becomes karma
01:13:39 * glguy tries to come up with some other upside down wit... but thinks that maybe some sleeping is in order
01:14:00 <Heffalump> mine seems stuck at 5 even when I get more upvotes, is there some kind of expiry too?
01:14:43 <dons> not sure, don't think so
01:15:35 <glguy> I wonder how disconnected from reality you need to be to treat the mailing list like an IRC channel
01:15:48 <vincenz> glguy: sleeping? What time is it, ,I thought your wife just went to do groceries.
01:15:57 <glguy> vincenz: that happened earlier today
01:16:03 <glguy> vincenz: it's 1:15am here now
01:16:05 <vincenz> oh, I thought that was a recent event
01:16:11 <dons> i think its a culture that gets inherited from other places
01:16:13 <glguy> my rummaging through it all was
01:16:40 <glguy> I hardly feel like I have any questions that merit a post to the mailing list
01:16:58 <glguy> much less just throwing up random banter
01:17:23 <dons> yeah, i don't think we can take over the world that way
01:17:45 <dons> glguy: i have an apartment to stay at now. yay :)
01:17:57 <glguy> dons: sweet, did Melissa find that for you?
01:18:01 <dons> now, i wonder what the best way to get from the airport to the city is?
01:18:03 <dons> yeah
01:18:07 <glguy> dons: via the train
01:18:09 <glguy> trimet.org
01:18:14 <dons> well, after 20 hours on a plane though
01:18:21 <glguy> oh
01:18:26 <dons> the train might be ok.
01:18:37 <glguy> depends how close you live to it or the street car
01:18:41 <glguy> but the red line goes to the airport
01:18:51 <glguy> let me know if you need a ride
01:19:09 <dons> oh, thanks :) we could just get a taxi too, that's pretty cheap i guyess
01:19:21 <dons> with bags and such, might be easier
01:19:45 <RyanT5000> lol wow, reading the comments on that reddit page
01:20:03 <dons> RyanT5000: ?
01:20:05 <glguy> dons: I've got room for 4 people and 2 suitcases
01:20:21 <RyanT5000> people saying "in OO, most of my errors are from state; in functional, most of my errors are because i forgot an explicit coercion"
01:20:39 <RyanT5000> referring to runtime errors both times
01:20:45 <dons> glguy: oh, cool. thanks for the offer. we'll see how much we have and decide before we go what to do
01:20:46 <DRMacIver> "forgot an explicit coercion"??
01:20:56 <RyanT5000> "eg. I pass anInt instead of str(anInt) in Python"
01:21:08 <dons> maybe a type error, yeah :)
01:21:14 <newsham> anyone here handy with isabelle?
01:21:31 <glguy> dons: sounds good, but if you figure out that you'll fit, I'd be happy to drive
01:21:56 <dons> ok. cheers!
01:22:13 <glguy> cheers
01:25:26 <xpika> how do i compile a .chs file?
01:26:50 <RyanT5000> dons: whoops, i thought i had clicked that reddit link from #haskell, but it was from somewhere else; http://programming.reddit.com/info/1kkeg/comments
01:26:52 <lambdabot> Title: Ask Reddit: Is the future of programming Erlang, Haskell, or a language that bor ...
01:55:18 <RyanT5000> is there an integer increment hardwired into GHC?
01:55:29 <dons> yay `I will concede that, under the conditions of the shoot, bitarrays in c# are slower than bitarrays in Haskell.' pyrrhic victory
01:55:44 <dons> RyanT5000: no primop for +1, nope.
01:55:44 <olathe> Heheh
01:55:57 <dons> but gcc should solve that, RyanT5000
01:56:04 <RyanT5000> dons: yeah, true
01:56:05 <Heffalump> what -fvia-asm?
01:56:10 <Heffalump> s/what/& about/
01:56:24 <Heffalump> though any peepholer or the like would sort it out, I'd have thought
01:56:48 <quicksilver> dons: well, to be fair
01:57:04 <quicksilver> dons: "faster" "100x slower" "65000x slower"; what's the difference
01:57:07 <RyanT5000> dons: how come guards are faster than pattern matches? i tried converting atvsum to going in reverse using two patterns, and it added like half a second
01:57:08 <quicksilver> dons: he was close, right?
01:58:16 <dons> i think he started at (order of magnitude slower), then refined that to (70-80% of the speed of c#) then ended up at (faster).
01:58:28 <RyanT5000> lol
01:58:29 <quicksilver> at one stage he did mention 65000x slower
01:58:33 <quicksilver> although, to be fair, it was in an aside
01:58:44 <dons> ah yes, i think there were some interesting early numbers too
01:58:58 <dons> i hope he doesn't do a phd in CS, i'd hate to review those papers
01:59:36 <dons> RyanT5000: guards, depends on how they're desugared
01:59:42 <dons> check the core to see what each form produces
01:59:51 <quicksilver> dons: Oh, I dunno. He's young, keen, bold.
02:00:10 <quicksilver> dons: lots of bright people make massive mistakes and sweeping generalisations when they're inexperienced
02:00:26 <dons> yeah, that's true.
02:00:32 <Heffalump> he's not that young :-)
02:00:36 <dons> lot of energy, just needs some moderation
02:00:49 <Heffalump> but new to Haskell, anyway :-)
02:00:54 <quicksilver> I'm interested to know on what grounds Jon Harrop thinks that fasta, k-nucleotide and spectral-norm are the "most objective" of the tests?
02:01:03 <dons> yeah, i just hit 'D' on that.
02:01:08 <dons> k-nuc is a hash table benchmark.
02:01:10 <quicksilver> it's interesting because they're almost exactly the only ones on which C# are faster
02:01:12 <RyanT5000> quicksilver: they're the ones we fail
02:01:16 <dons> spec-norm is mutable, double math
02:01:24 <RyanT5000> quicksilver: what language is he? again?
02:01:29 <RyanT5000> quicksilver: C#?
02:01:31 <dons> fasta is hmm, underoptimised, in favour of elegance (it uses 'cycle')
02:01:48 <RyanT5000> (not paying much attention, because i'm busy beating his spec-norm score ;))
02:01:53 <dons> nah, jon is mr. ocaml-for-scientists. have you read his book?
02:01:57 <quicksilver> RyanT5000: jon harrop uses lots of languages but he's most associated with ocaml
02:02:14 <dons> he's also famous for annoying everyone who doesn't use ocaml
02:02:20 <Royal_Son> hello again :)
02:02:41 <dons> hey Royal_Son
02:02:49 <dons> these are strange times in haskell land
02:02:59 <Royal_Son> why's that ?
02:03:01 <Royal_Son> Hi dons
02:03:04 <quicksilver> he's classed as a troll by many usenet groups; but actually I've found quite a few of his contributions to -cafe interesting.
02:03:07 <wli> How so?
02:03:33 <dons> yeah, there's a mixture of interesting stuff, and selling his book. he makes fun of the lisp guys, which is also amusing
02:04:07 <dons> everyone selectively quotes material about low level performance anyway, and besides, no one cares: forfty percent of people use ruby and javascript
02:04:34 <dons> so these discussions are just weird. we talk about what we have numbers for, however irrelevant
02:04:38 <quicksilver> :t (***)
02:04:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:05:08 <quicksilver> dons: isn't (c2w *** id) simply 'first c2w' ?
02:05:20 <quicksilver> dons: mind you, maybe c2w *** id is easier to understand
02:05:22 <dons> might be. i didn't look into that oo much
02:05:27 <dons> ?src first
02:05:27 <lambdabot> Source not found. My mind is going. I can feel it.
02:05:29 <dons> ;t first
02:05:32 <dons> :t first
02:05:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:05:55 <quicksilver> > ((*2) *** id) $ (3,4)
02:05:56 <lambdabot>  (6,4)
02:06:03 <quicksilver> > first (*2) $ (3,4)
02:06:05 <lambdabot>  (6,4)
02:07:04 <quicksilver> @check \f n m -> (f *** id) (n,m) == ((first f) (n,m) :: (Int,Int))
02:07:04 <lambdabot>  Add a type signature
02:07:07 <quicksilver> bah!
02:07:35 <quicksilver> @check \f (n::Int) (m::Int) -> (f *** id) (n,m) == ((first f) (n,m) :: (Int,Int))
02:07:35 <lambdabot>  Parse error in pattern
02:08:10 <quicksilver> I can never remember the good places to put the annotation
02:09:38 * Heffalump --> AngloHaskell
02:09:53 <Cale> @check \f n m -> (f *** id) (n,m) == ((first f) (n :: Int,m) :: (Int,Int))
02:09:55 <lambdabot>  OK, passed 500 tests.
02:10:40 <Cale> @check \f n m -> (f *** id) (n,m) == ((first f) (n,m)) :: (Int -> Int) -> Int -> Int -> Bool
02:10:40 <lambdabot>  Couldn't match expected type `(Int -> Int) -> Int -> Int -> Bool'
02:11:29 <Cale> @check (\f n m -> (f *** id) (n,m) == first f (n,m)) :: (Int -> Int) -> Int -> Int -> Bool
02:11:30 <lambdabot>  OK, passed 500 tests.
02:12:26 <quicksilver> Cale: thanks :)
02:15:11 <dons> Heffalump: do we get videos for anglohaskell?
02:15:34 <dons> Cale, i note you got some upmods for your comment yesterday in the end :)
02:17:47 <RyanT5000> how important is State# RealWorld? do unsafePerformIO and such just throw it away?
02:17:59 <quicksilver> in a sense, yes
02:18:08 <quicksilver> it can be erased at compile time
02:18:14 <quicksilver> because it's there for the type-checker
02:18:20 <RyanT5000> quicksilver: good :)
02:18:20 <quicksilver> once you've proved your usage is type-safe
02:18:24 <RyanT5000> heh heh
02:18:28 <quicksilver> then you don't actually need it at runtime
02:18:29 <RyanT5000> i'm not in a theorem-proving mood
02:18:32 <quicksilver> same as the 's' in ST s
02:18:41 <quicksilver> (exactly the same)
02:18:43 <RyanT5000> alright
02:19:18 <RyanT5000> well, we'll see if i get into sequencing trouble ;)
02:19:24 <dons> its a strict kinded type with a single inhabitant, so you can always erasee it.
02:19:38 <RyanT5000> ah, alright
02:19:47 <quicksilver> what does 'strict kinded' mean?
02:19:53 <RyanT5000> does it mean "no bottom"?
02:20:04 <dons> yeah, for RealWorld
02:20:08 <dons> quicksilver: oh, # kind
02:20:09 <quicksilver> ah, right
02:20:17 <quicksilver> but you could erase it even if it wasn't strict
02:20:23 <quicksilver> because it's phantom anyway
02:20:33 <dons> its a phantom anyway, yeah
02:21:14 <opqdonut> hmm, how come strict-kinded types with single inhabitant can always be erased?
02:21:20 <opqdonut> i mean, what does that mean?
02:21:41 <mauke> what are you going to do with a value of ()?
02:21:46 <RyanT5000> well, single-inhabitant types don't convey meaning
02:21:55 <dons> wel, if you know the type RealWorld, it can only have the value RealWorld
02:21:56 <RyanT5000> (unless they convey the meaning "not bottom")
02:22:03 <dons> if its strict, it can't even be undefined
02:22:23 <quicksilver> opqdonut: "mean" ? "mean" ? You do not come to this channel for meaning! You come for enlightenment!
02:22:43 <dons> singleton types
02:23:11 <opqdonut> ah, isomorphic to ()
02:23:19 <wli> I've mostly heard "lifted type" for types with _|_ vs. calling types without such strict.
02:23:37 <opqdonut> i thought single inhabitant means like RealWorld = RW Int
02:23:54 <dons> yeah, wli, you lift a type into a larger set of types.
02:24:00 <opqdonut> quicksilver: and i was enlightened :)
02:24:12 <dons> http://stinet.dtic.mil/oai/oai?&verb=getRecord&metadataPrefix=html&identifier=ADA387141
02:24:14 <lambdabot> Title: Singleton Kinds and Singleton Types, http://tinyurl.com/2up3td
02:24:17 <dons> looks interesting
02:24:51 <quicksilver> "unlifted" is more common than strict for types, IME
02:25:06 <quicksilver> as in "should haskell have unlifted tuples?"
02:25:38 <RyanT5000> dons: what do i *provide* for a State# RealWorld?
02:25:39 <dons> yeah, i should have said unlifted. # / strict / unboxed, is a bit more operational-thinking than necessary
02:25:49 <dons> RyanT5000: hmm? runST ST $ \s -> ?
02:25:49 <pejo> dons, "if it is strict, it can't even be undefined" - isn't undefined semantically bottom?
02:26:10 <dons> you can't drop in 'undefined'
02:26:11 <RyanT5000> dons: no, i mean when i'm purposely breaking all the rules :P
02:26:18 <pejo> Oh, wli explains it right below. Sorry.
02:42:45 <dons> RyanT5000: so whatcha doing? making more progres?
02:43:38 <RyanT5000> dons: i tried unboxing a ton of stuff, and it didn't do anything
02:43:44 <RyanT5000> dons: made it slightly slower, in fact
02:44:02 <RyanT5000> dons: so, i don't really know where to go from here, so i'm going to send it to you and go to sleep
02:44:59 <dons> ok. sounds good.
02:45:29 <dons> ghc is pretty smart about unboxing (as you'll see with -ddump-simpl), so usually its just a matter of strictness hints, and in some rare cases, actually giving an explicit order of operations
02:45:38 <reltuk> you guys working on code for the shootout?
02:46:23 <RyanT5000> dons: yeah; well i still think there are some problems on the asm level, but i could be wrong and even if i'm right i have no idea how to coerce ghc/gcc into producing the asm i want
02:46:32 <RyanT5000> dons: this is kind of like an obfuscated asm contest
02:47:09 <dons> reltuk: just tossing around an improved version of the spectral-norm entry
02:47:21 <dons> RyanT5000: yeah, asm is hard except for inner loops
02:47:33 <dons> which you can roughly get right, but can't do much about register use and heap/stack checks
02:47:57 <dons> without asking SimonM for more native codegen smarts
02:48:35 <RyanT5000> dons: it seems like there could be a more graceful way of getting from high-level to low-level
02:49:12 <dons> inline asm? :)
02:49:22 <dons> what were you thinking of?
02:49:37 * wli watches parsec choke.
02:50:00 <RyanT5000> well, i didn't mean inline asm, because then you're just *substituting* language
02:50:18 <RyanT5000> it would be nice if you could give GHC a formal path to the asm
02:50:32 <dons> could you elaborate?
02:50:42 <RyanT5000> well, GHC obviously has a formal model of the program; that's its primary purpose
02:51:01 <RyanT5000> GHC probably has a considerably less formal model of the underlying architecture, but it's still got quite a bit
02:51:27 <RyanT5000> it would be nice if you could provide arbitrary proven-correct conversions between the two
02:51:40 <quicksilver> IMO, the value of this kind of low-level haskell work is to take it to SimonM, and say "This is how far we got, and ghc produces this code, but it would be obviously better to do that"
02:51:58 <RyanT5000> how many simons are there, anyway? so far i've counted 3
02:52:01 <quicksilver> and see if the compiler backend can take your example and make it generic
02:52:29 <quicksilver> "We can improve register allocation in these circumstances
02:52:52 <quicksilver> "we can skip a stack check here (or hoist it out of this inner loop"
02:52:59 <RyanT5000> quicksilver: yeah; this seems like it might be a generic-ish issue with double handling
02:53:25 <RyanT5000> oh wait, actually, i just figured out what those two instructions i thought were extraneous are doing
02:53:37 <RyanT5000> they're not extraneous, they're just not in aij :)
02:53:49 <RyanT5000> which means it's properly inlining and such
02:54:26 <reltuk> stylistic / gold advice?:     toElement = (l "urls" []) . (map (\(TS.Url url) -> textElem "url" [] url))
02:54:26 <RyanT5000> and which also means that the slowest thing in the main loop of this code is probably the indirect jmp, which seems to be a fairly unavoidable consequence of STG machine architecture (based on my limited understanding)
02:54:35 <reltuk> s/gold/golf
02:54:47 <mauke> too many parens
02:55:06 <RyanT5000> reltuk: it looks like that lambda might be reusable, and probably more clear if you pull it out
02:55:44 <RyanT5000> reltuk: maybe not, though
02:55:55 <RyanT5000> reltuk: i've written worse and been happy :P
02:56:46 <quicksilver> reltuk: if you write that a lot, you might want to factor out unURL TS.Url url = url
02:57:11 <quicksilver> reltuk: then you can say toElement = l "urls" [] . map (textElem "url" [] . unUrl)
02:57:25 <quicksilver> reltuk: which, if nothing else, has fewer parentheses :)
02:58:20 <RyanT5000> dons: incidentally the STG calling convention is one thing that i think should be considered a special case, despite haskell's rather deep connection to it; there's absolutely no reason you'd ever want to use it on the loops we're dealing with; you could make a wrapper of some kind that changed calling conventions for the functions inside of it, while guaranteeing STG compatibility externally
02:58:52 <reltuk> thanks for advice guys =)
02:59:42 <RyanT5000> dons: on the other hand, i think it would be much more difficult to dispense with the overall STG *language* (let, case, lambda, there was another, wasn't there) - but it doesn't mandate a particular calling convention
03:03:09 <quicksilver> RyanT5000: the STG is so different from a standard C model that it's almost stretching things to call it a "calling convention" at all
03:03:20 <quicksilver> RyanT5000: it's a completely different data flow...
03:03:41 <RyanT5000> quicksilver: well, there's some way of getting from label a with environment L to label b with environment M
03:03:55 <RyanT5000> quicksilver: and then getting to the right place after that
03:04:12 <quicksilver> agreed
03:04:18 <quicksilver> I was just emphasising the difference
03:04:32 <quicksilver> the fact the a "function" doesn't necessarily "return"
03:04:41 <quicksilver> and "outer" functions can collapse before "inner" ones
03:05:44 <wli> Ultimately you want to unravel all the layers.
03:06:17 <RyanT5000> quicksilver: yeah, true, but the "calling convention" i was looking for was "mov ecx, N ; top: do_stuff ; loop top ;"
03:06:47 <RyanT5000> quicksilver: with some accumulators in... i believe they were once called "accumulators" ;)
03:11:01 <RyanT5000> dons: alright, i sent it to you
03:12:42 <RyanT5000> quicksilver: also, wouldn't it be "right and proper" for ghc to have a formally-verified bridge to the hardware? not that that's difficult or anything... :P
03:12:47 <wli> My guess is the winning approach is trying to come up with some sort of functional interpretation of a basic block.
03:13:28 <RyanT5000> wli: i doubt that would be as flexible as i want (which is *all* the flexible :))
03:13:42 <quicksilver> RyanT5000: yes, that would be nice, but as you say, rather hard
03:13:42 <RyanT5000> wli: there's no reason, in theory, you couldn't just have a complete model of the architecture
03:13:55 <quicksilver> RyanT5000: the GHC backend is currently understood by only a very small number of people
03:14:09 <quicksilver> well, 'backends' I should say since htere are several
03:14:22 <RyanT5000> yeah, i don't pretend to fully understand the difficulties
03:14:27 <quicksilver> RyanT5000: One vision is that really ghc should content itself with compiling to C--
03:14:31 <quicksilver> that's what C-- was designed for
03:14:44 <quicksilver> and there should be one, true C-- -> native code compiler
03:14:58 <quicksilver> which should be "obviously correct", and not really much of an optimiser
03:14:59 <wli> RyanT5000: Well, try to construct such.
03:15:11 <quicksilver> (since the optimisation is supposed to have happened earlier)
03:15:52 <RyanT5000> quicksilver: that's where i disagree, both technically and politically; there will always be someone whose technical needs are not met by any given abstraction, and there will always be someone who can't use a given specification for political reasons
03:15:59 <RyanT5000> (political is a term i use very broadly)
03:16:05 <RyanT5000> competition is good :)
03:16:10 <wli> Register allocation, strength reduction, etc. are still within its purviews.
03:16:26 <pejo> quicksilver, so low level optimizations like register allocation and such shouldn't be done by the C-- compiler?
03:16:35 <quicksilver> pejo: register allocation should be, yes
03:16:51 <opqdonut> but that's not really an optimization imo
03:16:52 <quicksilver> pejo: but at least it has a much smaller scope
03:17:05 <opqdonut> in the sense that it radically changes program-flow or something
03:17:23 <opqdonut> (i mean, inlining for example is radical compared to register alloc)
03:18:05 <RyanT5000> wli:  i'll eventually try to make one :)
03:18:43 <dons> RyanT5000: thanks, got it
03:18:51 <RyanT5000> dons: cool
03:18:53 <wli> RyanT5000: Look into register transfer languages (RTL's).
03:21:12 <RyanT5000> wli: yeah, although i'm not really so concerned with the implementation so long as it's possible to change the implementation without breaking things; i'll probably start with a tiny subset of x86 - maybe 10 instructions and the standard registers - and formally map that onto something like STG
03:21:55 <RyanT5000> wli: as long as it's possible to prove other that alternative mappings are equivalent to my first one, i'm not terribly concerned about actually having a great mapping
03:22:52 <wli> RyanT5000: Also look into things like GURRR.
03:23:57 <RyanT5000> huh, that looks interesting
03:24:06 <RyanT5000> it'd be cool to put things like timing into the type system
03:25:39 <RyanT5000> f xs :: [X] -> Y, BigO(length x)
03:25:46 <RyanT5000> something to that effect
03:26:11 <RyanT5000> or even real-time stuff - which would require a *really* good hardware model
03:26:39 <RyanT5000> obviously those things aren't worth proving for 99.9% of programs, but it might not hurt to have the capability, so that the 100 projects that need it can have it
03:28:04 <RyanT5000> thanks for the pointers, wli :)
03:28:52 <pejo> RyanT, seen the work on Hume? "Worst-Case Execution Times for a Purely Functional Language".
03:29:31 <RyanT5000> pejo: hm, i'll take a look
03:44:22 <Shimei> Say, is there a way to export a qualified list of stuff from another module?
03:46:06 <quicksilver> Shimei: I thought you could import qualified Foo as Foo
03:46:17 <quicksilver> Shimei: and then export Foo.bar, Foo.baz, Foo.Type
03:46:23 <quicksilver> Shimei: I've never tried it though
03:49:23 <Royal_Son> can someone please tell me what this means ? Instance of Integral Float required for definition of testRoot
03:49:31 <vincenz> http://programming.reddit.com/info/2dvi3/comments/c2dzmn?context=5
03:49:33 <lambdabot> Title: Absence of Evidence is Evidence of Absence (reddit.com), http://tinyurl.com/2uaxhb
03:49:46 <desp> http://johanjeuring.blogspot.com/2007/08/finding-palindromes.html
03:49:48 <lambdabot> Title: Johan Jeuring's blog: Finding palindromes
03:49:48 <mauke> Royal_Son: inconsistent use of arithmetic ops
03:49:53 <Royal_Son> I take a float as an input and produce a float output
03:49:58 <Royal_Son> oh
03:50:06 <mauke> Royal_Son: somehow your function requires integer floats
03:51:22 <Royal_Son> so i'd have to use IntegerFloat as a type instead of Float ?
03:51:40 <quicksilver> no, that's inconsisent
03:51:41 <mauke> no, such a type doesn't exist
03:51:50 <quicksilver> something can't be integer and floating point at the same time :)
03:52:01 <Royal_Son> oops
03:52:02 <Royal_Son> :p
03:52:04 <mauke> find out why it thinks you need integers
03:52:12 <quicksilver> probably you just need to add a 'fromIntegral' somewhere to upcast an integer to a Float
03:52:33 <quicksilver> > 4.0 + (2^3)
03:52:35 <lambdabot>  12.0
03:52:41 <quicksilver> oh, that wasn't supposed to work :P
03:52:44 <quicksilver> bad example
03:52:44 <Royal_Son> i was performing the round function actually
03:52:58 <quicksilver> ah yes, round produces integrals
03:53:04 <quicksilver> if you then want to use that as a Float after all
03:53:09 <sieni> @t (+)
03:53:09 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:53:14 <sieni> @type (+)
03:53:15 <quicksilver> you want fromIntegral (round x)
03:53:16 <lambdabot> forall a. (Num a) => a -> a -> a
03:53:33 <quicksilver> or, as a haskeller would probably write it, fromIntegral . round $ x
03:53:41 <sieni> @t 7
03:53:41 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:53:46 <sieni> @type 7
03:53:48 <lambdabot> forall t. (Num t) => t
03:53:48 <Syzygy-> :t 7
03:53:50 <lambdabot> forall t. (Num t) => t
03:53:55 <sieni> ahh
03:54:04 <sieni> so
03:54:06 <ari> > (round 1.2) / 1
03:54:06 <Vq^> quicksilver: why not fromIntegral $ round x
03:54:07 <lambdabot>  Add a type signature
03:54:19 <sieni> > 1.2 + ((2^3) :: Integer)
03:54:19 <lambdabot>   add an instance declaration for (Fractional Integer)
03:54:20 <Cale> Vq^: that works too :)
03:54:29 <quicksilver> Vq^: because in the expression "fromIntegral . round $ x", you can see "fromIntegral . round" as a subexpression
03:54:46 <quicksilver> Vq^: which you can hoist out to a local or even module-level definition if you use it frequently
03:55:11 <Cale> Yeah, the f . g $ x form emphasises the function better
03:55:44 <Vq^> i see
03:56:33 <quicksilver> Vq^: of course, the counter argument is that in the expression "fromIntegral $ round x" you can see "round x" as a subexpression
03:56:44 <quicksilver> Vq^: which is equally valid. But I find the other is more useful in practice
03:57:08 <quicksilver> haskell expressions often end up in the form "foo . bar . baz . bam $ x"
03:57:26 <quicksilver> much like a shell pipeline (although, of course, the other way around)
03:58:13 <Vq^> i often use $ as a pipe for such expressions
03:58:20 <vincenz> a llehs enilepip
03:58:26 <Shimei> quicksilver: Ah, so I'd have to manually export everything I want? As opposed to exporting everything except a "hide" list, I mean.
03:59:11 <Cale> Vq^: Repeated $'s is a bit of an abuse of the fact that $ was given the wrong associativity. (It really should have been left associative)
03:59:44 <quicksilver> Shimei: I believe so
03:59:54 <quicksilver> Vq^: then you find yourself unable to abstract
04:00:10 <quicksilver> "foo $ bar $ baz $ bam $ x"
04:00:17 <Cale> You can always rewrite f $ g $ h $ x as f . g . h $ x, but you can't rewrite things like f (g x) (h y) to eliminate the parens. If ($) was left associative, you could write that as f $ g x $ h y
04:00:20 <quicksilver> now suppose "bar $ baz" is a common usage in your code
04:00:28 <quicksilver> so you try to define  bb = bar $ baz
04:00:32 <quicksilver> BZZZT wrong :)
04:00:44 <quicksilver> because bar $ baz is not a subexprssion of foo $ bar $ baz $ bam $ x
04:00:49 <quicksilver> bar . baz is, though :)
04:01:33 <Vq^> quicksilver: i have no problem with rewriting one char when i break out code :)
04:01:37 <quicksilver> agreed
04:01:47 <quicksilver> but it's a nice feeling having to rewrite none, isn't it?
04:01:56 <Vq^> yeah, i see your point
04:02:13 <Vq^> i just haven't thought about it earlier
04:02:55 <quicksilver> Cale: you should make a wiki page WhyDollarShouldBeLeftAssociative
04:03:03 <quicksilver> Cale: this comes up once or twice a week :)
04:06:24 <vincenz> quicksilver: that would get a lot of reaction from the US government
04:06:47 <vincenz> "The dollar is funded by the strong right economy, it should be right associative!"
04:07:05 <Vq^> heh
04:07:12 <quicksilver> :)
04:07:35 <vincenz> "Now where's my m16"
04:08:03 <quicksilver> dons: I guess http://www.cse.unsw.edu.au/~rl/code/doc/strict/ should quite possibly be s/strict/unlifted/g;
04:09:08 <Vq^> as long as the wiki isn't hosted in the US there shouldn't be a problem :)
04:11:01 <thoughtpolice> anybody mind giving me some criticism on my bot code? so far it works, but I'd like a little refactoring-based criticism, since I'm sure several things could be made less ugly
04:12:17 <dons> quicksilver: yeah, we actually use those types in an Unlifted class in the fusion lib, strangely enough
04:12:30 <Vq^> thoughtpolice: what code?
04:13:08 <thoughtpolice> Vq^: it's an irc bot. right now it's really primitive, but there're a couple of ugly things (most notably dealing with some of my irc based stuff,) and i'd like any criticism I can get
04:13:37 * wli is aggravated with parsec right now.
04:14:05 <Vq^> thoughtpolice: where is it?
04:14:06 <thoughtpolice> most of the basic functionality is there, though
04:14:31 <thoughtpolice> Vq^: i don't have a darcs repo online anywhere (all my darcs repos were on a pretty nice free host, but they're down right now)
04:14:48 <thoughtpolice> but I can put a cabalized sdist on my server right fast.
04:15:11 <vincenz> 'server'?
04:15:28 <vincenz> if you can serve cabal, you can serve darcs
04:15:31 <vincenz> all you need is http
04:15:42 <quicksilver> wli: I must admit, I'm not a fan of parsec's API
04:15:44 <thoughtpolice> well I tried just putting my repos online but I couldn't push for example
04:15:52 <vincenz> thoughtpolice: well no
04:16:02 <vincenz> thoughtpolice: but if it's just for people checking your code, you can put a secondary repo on your server
04:16:06 <vincenz> and then push via ssh
04:16:10 <vincenz> people can pull with http
04:16:24 <thoughtpolice> vincenz: no, I mean, the host I had gave me ssh access naturally, and I put my repos there
04:16:32 <vincenz> and the new one?
04:16:39 <vincenz> how do you access your server?
04:16:40 <thoughtpolice> but trying to push by ssh requires darcs, it seems. i had to ask the provider to install darcs for me
04:16:47 <vincenz> oh!
04:16:53 <thoughtpolice> and my server is ftp (plus it isn't mine)
04:17:00 <vincenz> yeah, it'd be nice if darcs had a tool that allowed clientside only tools
04:17:06 <vincenz> It's possible, just expensive
04:17:10 <vincenz> that's why they don't do it now
04:17:28 <thoughtpolice> i tried pulling some hackery by mapping my ftp server to my filesystem (fuse) but darcs doesn't like that
04:17:32 <wli> vincenz: How many USD/GB? ;)
04:18:03 <quicksilver> bzr has clientside-only methods
04:18:06 <quicksilver> tis quite handy
04:18:19 <vincenz> wli: what?
04:18:55 <wli> "expensive"
04:18:58 <thoughtpolice> i'm a big fan of git myself. :)
04:19:17 <quicksilver> @quote git
04:19:17 <lambdabot> No quotes match. Just what do you think you're doing Dave?
04:19:23 <vincenz> Yay for the git that wrote git?
04:19:48 <wli> quilt works for me.
04:20:00 <olsner> @quote
04:20:01 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
04:20:02 <vincenz> wli: well expensive in terms of bandwidth, besides USD is no longer fashionable, nowadays it's euro :)
04:20:17 <wli> Rewriting quilt entirely in Haskell might speed it up.
04:20:21 <thoughtpolice> anyway,
04:20:29 <thoughtpolice> Vq^: if you wouldn't mind you can get a tarball from austin.youareinferior.net/infinity-0.0.tar.gz
04:20:40 <wli> vincenz: The USD is going down the toilet, true.
04:20:54 <thoughtpolice> like I said I appreciate any and all criticism. there're certain parts about the code I don't like...
04:22:22 <wli> vincenz: If I ever change jobs again I'll insist on being paid in hard currency (a.k.a. EUR).
04:22:38 <vincenz> wli: Hard currency = gold :)
04:22:56 <thoughtpolice> actually come to think of it the one thing I didn't quite do is implement sending the PASS message to the irc server, since my tests didn't require a registered user
04:23:45 <roconnor> vincenz: someone on reddit said that energy would make a good hard currency.
04:23:56 <roconnor> vincenz: that the best idea I've ever read on reddit comments.
04:24:08 <vincenz> roconnor: or worse, water
04:24:16 <roconnor> :)
04:24:20 <vincenz> Water is quick becoming a precious resource.
04:24:27 <roconnor> I can't tell which is better, gold or engergy.
04:24:33 <vincenz> I'd go for mana ;)
04:24:36 <quicksilver> gold is obviously better
04:24:37 <quicksilver> it's shiny
04:24:38 <roconnor> both have advantages and disadvantages.
04:24:38 <mauke> GOLD MADE OF ENERGY
04:24:42 <quicksilver> can't go wrong with shiny
04:24:54 <vincenz> quicksilver: water is shiny -and- liquid
04:24:54 <roconnor> (and by energy I assume he means entropy)
04:25:18 <vincenz> roconnor: well if you invest in entropy, you're bound to lose, that's a quickly inflating market.
04:26:01 <roconnor> vincenz: well, negtropy I guess even more technically.
04:26:13 <vincenz> roconnor: so you want to see your investment dissapear?
04:26:52 <roconnor> vincenz: my inventement will stay if I keep it prefectly insulated.
04:26:54 * vincenz is off to lulnch
04:26:59 <vincenz> roconnor: then you can't trade with it
04:27:03 <roconnor> vincenz: but yes, that is one of the disadvantages.
04:27:11 <roconnor> vincenz: you can trade paper backed by it.
04:27:20 <vincenz> not until they notice all you're selling is cold air!
04:27:27 <vincenz> erm s/until/when/
04:27:29 <roconnor> :)
04:27:38 <roconnor> cold air is valuable.
04:28:37 <dons> RyanT5000: so the main point was to change to uncheckedIShiftRA# ?
04:28:48 <vincenz> "And now with our new and improved refrigerators, you get more of it! Only for 1999.99"
04:29:06 * vincenz now really goes to lunch
04:29:57 <roconnor> One nice thing about energy backed currency is that anyone could get a job peddling a bicycle.
04:30:05 <roconnor> although I'm not sure it pays very well.
04:30:24 <doserj> it surely wouldn't pay your food...
04:30:24 <tuxplorer> is there any hosting that supports HAppS?
04:30:40 <roconnor> doserj: in priciple it could.
04:30:41 <dons> tuxplorer: since its just a binary -- any happs app -- i suspect many do?
04:31:03 <vincenz> you could sell your methane... food would definitely pay for that.  Oh wait, if it would pay for food...hmm
04:31:13 <dons> you just need a machine with a new connection, since happs provides the web server and other stuff built  in
04:31:23 <roconnor> doserj: or are you saying that it wouldn't pay for the food that you consume.
04:31:29 <roconnor> that's probably a good point.
04:31:47 <doserj> yep
04:32:27 <tuxplorer> dons, i can just put the ghci on any machine and run it even without ghc related packages? Doesnt haskell binaries need any virtual machine or interpreter to run?
04:32:44 <tuxplorer> sorry.. s/ghci/.hi_files
04:33:07 <dons> tuxplorer: well, you wouldn't compile it on the server would you?
04:33:17 <dons> you'd compile your happs program to a standalone statically linked binary
04:33:23 <dons> then run that on the web host
04:33:34 <dons> haskell binaries don't need a vm or anything, that's right
04:33:37 <tuxplorer> dons: my hosting offers me only lftp access, so i'll just compile it on my system and put it there
04:33:42 <dons> yep.
04:33:54 <dons> yeah, just compile it to a fully statically linked binary, and upload that
04:34:24 <dons> oh, i gues the usual case is that you need python or ruby installed on the server too?
04:34:42 <dons> so that's a bit different, since happs produces a fully standalone system. (that was one of the goals, I think)
04:35:45 <tuxplorer> dons:  Thats the confusion i had, having worked with other languages like PHP and rails, which required packages from teh server, I was just wondering if i needed anything for HAppS.. Resolved now..  Thanks :)
04:35:52 <thoughtpolice> tuxplorer: the only host I've ever seen that had support for haskell was nearlyfreespeech.net, and it was only cgi; not to sure about happs :/
04:36:39 <thoughtpolice> doubtful if happs is standalone
04:36:42 <dons> happs is just a standalone, custom web server, basically, so if you can get a port open on the server, then that's all (I think)
04:36:55 <dons> thoughtpolice: no, it is, its a web server + application logic, in a bundle
04:37:05 <dons> see hpaste.org for example, its just a single executable serving up content
04:37:20 <wli> Not many hosting .com's will allow that.
04:37:21 <thoughtpolice> dons: no, i meant it's doubtful for nearlyfreespeech to support happs if it is standalone
04:37:21 <dons> and when you statically link the executable, you need not even C libs on the server
04:37:29 <dons> thoughtpolice: yeah, that might be the issue
04:37:37 <dons> they expect you to use their web server set up?
04:37:48 <reltuk> sometimes hosting providers will kill long running, unknown processes on shared vhosts, at least among their cheaper options
04:38:01 <dons> shapr surely knows the best process ,though, he's set up a few happs systems now
04:38:04 <reltuk> so that would possibly keep you from running it on a shared host
04:38:11 <thoughtpolice> most likely. they support a buttload of cgi languages, but i doubt running your own server, although they might allow it
04:38:27 <wli> I think the usual model is CGI.
04:38:58 <dons> you'd have to check with the happs devs about how cgi-like stuff works.
04:39:09 <thoughtpolice> they support ocaml as a cgi language even. that would have to be one god-forsaken web app, I guess.
04:39:13 <reltuk> dons: shapr has writen a few relatively general purpose applications with it?
04:39:39 <tuxplorer> dons: can you plz point me to a link which tells me how to compile the binary statically?
04:39:47 * reltuk doesn't even know what "general purpose" means in that sentence
04:40:24 <thoughtpolice> tuxplorer: the -static flag?
04:40:35 <dons> tuxplorer: ghc -O2 -static -optl-static A.hs
04:40:52 <dons> yields a fully statically linked haskell program , with no external dependencies
04:41:06 <tuxplorer> thoughtpolice: dons: Thanks :)
04:41:32 <dons> so the other thing mightbe a FastCGI-base statically linked haskell app
04:41:45 <dons> (see the fastcgi package on hackage.haskell.org for that approach)
04:41:57 <tuxplorer> ok
04:42:24 <dons> njd: btw, did your binary changes work? i don't think I received any patches?
04:42:38 <dons> (ah, unless you sent them to lennart's address-- the binary default address)
04:45:58 <dons> woo, cool `hppa/HPUX registerised AND optimized port of GHC 6.6.1 available'
04:46:09 <dons> first class hppa support, for those with funny machines :)
04:47:43 <njd> anyone out there have any experience with Data.Derive?
04:47:43 <earthy> the thought boggles the mind
04:48:23 <dons> njd, is this for deriving Binary?
04:48:39 <njd> dons, it certainly is...
04:48:46 <dons> if so, did you try the syb script in the binary utils/ directory?
04:48:51 <dons> (it just prints the instances to stdout in ghci)
04:49:37 <njd> dons, using DRiFT at the moment - but it has issues
04:50:12 <dons> did you want to  derive them once, and then keep those source files?
04:50:33 <njd> dons, main problem is that it works fine under 6.6 (and got it as part of my toolchain) but fails to comple under 6.7
04:50:42 <dons> anyway, the script I use for small projects, is in binary/tools
04:50:56 <dons> $ ghci derive/BinaryDerive.hs
04:50:56 <dons> *BinaryDerive> deriveM (undefined :: Either Int Bool)
04:50:56 <dons> instance (Binary a, Binary b) => Binary (Either a b) where
04:50:56 <dons>   put (Left a) = putWord8 0 >> put a
04:50:56 <dons>   put (Right a) = putWord8 1 >> put a
04:50:59 <dons> .....
04:51:09 <dons> and its only 15 lines or so, so you can tweak it , if its not working
04:51:57 <dons> ndm is the guy behind Data.Derive. John Meacham runs DrIFT -- not sure if he's maintaining it (?)
04:52:13 <dons> ndj, btw, you sent the darcs patch I guess? (to lennart kolmodin?)
04:52:48 <njd> dons, it should have emailed to you (according to the message I got) - it was a two liner
04:52:53 <dons> earthy: any idea what HPUX is used for these days?
04:53:02 <dons> njd: hmm. I haven't received any patch
04:53:14 <njd> let me see if it is stuck somewhere
04:53:14 <dons> do you think it managed to get off your machine? (darcs expects mail to be set up)
04:54:04 <njd> dons, i'll check - i have a dedicated VM for the 6.7 haskell development stuff we're doing
04:54:05 <earthy> dons: no idea whatsoever
04:54:21 <earthy> but I did have fun with debugging around *0 == 0 on HP PA
04:54:32 <dons> huh, scary
05:00:18 <pejo> dons, HP OpenView runs on HP-UX
05:01:23 <dons> njd: patches arrive! :)
05:01:37 <pejo> dons, and here in Sweden it's fairly common that hospitals use HP-UX.
05:01:44 <dons> pejo: ah ok. huh.
05:01:57 <njd> dons, - yep a little reconfiguration goes a long way!
05:02:14 <dons> so not everyone in the world just runs ghc on linux eh? :) real world is strange
05:02:25 <opqdonut> RealWorld#
05:02:31 <opqdonut> is strange :=
05:02:33 <opqdonut> :)
05:02:35 <dons> :)
05:02:47 <pejo> dons, you've found someone who runs GHC on HP-UX? (IA64? PARISC?)
05:03:03 <dons> oh, we have some ia64s here, that got given away
05:03:20 <dons> but there was a post just a minute ago to the ghc list, about ghc registerised and optimised for HP-UX
05:03:37 <pejo> Let me guess - you don't run HP-UX on those IA64's? :-)
05:03:55 <dons> nah, linux :)
05:07:25 <mm_freak> does it make sense to parse textual network protocol messages (like HTTP replies) via parsec?
05:07:55 <wli> Yes, though I have doubts parsec is the best method.
05:10:30 <mm_freak> wli: what would you suggest?
05:11:14 <mm_freak> say, there is no ready-made protocol handler
05:13:21 <dons> well, parsec means [Char] handling currently
05:13:32 <dons> while network stuff might need to be tuned for speed?
05:14:01 <Saizan> well, it will support ByteString or other ~Streams after SoC
05:14:22 <dons> yep
05:14:39 <mm_freak> speed is not critical, but i'd like it to handle many connections simultaneously
05:15:11 <mm_freak> should i write an own parser?
05:15:14 <dons> it would likely be fastest to develop using parsec
05:15:22 <dons> lambdabot gets by fine with [Char] parsing, btw.
05:15:30 <dons> and forks 100s of threads a minute
05:15:42 <quicksilver> [char] is absolutely fine, for short messages
05:15:47 <quicksilver> like most network protocols
05:15:56 <quicksilver> unless you are trying to squeeze absolutely everything out
05:16:24 <dons> yeah, i think unless you're doing very low level stuff, or sending binary data, or sending a lot of data, [char] is fine -- which is most of the textual formats
05:16:40 <dons> and you can fork a haskell thread for every request happily
05:16:49 <mm_freak> the protcol isn't so complicated that i couldn't just write my own parser  it would be interesting to know, though, whether it makes sense
05:16:51 <quicksilver> or even two
05:16:57 <quicksilver> one for sending and one for receiving
05:17:05 <quicksilver> mm_freak: there is no reason not to use parsec, unless you don't like it
05:17:39 <mm_freak> ok, thanks
05:17:43 <dons> yeah, seems very reasonable to try parsec first.
05:18:36 <mm_freak> i've read that parsec is "pretty fast", but the fact that it's list-based already makes it slower than other solutions  that's why i'm asking
05:19:40 <dons> it might not be noticeable on a textual protocol anyway
05:20:32 <quicksilver> mm_freak: premature optimization
05:20:44 <quicksilver> mm_freak: get it working with parsec + [Char]
05:20:49 <quicksilver> mm_freak: if it's too slow, worry about it then :)
05:20:50 <quicksilver> I bet it won't be
05:21:09 <dons> yeah, and you can move over to bytestring parsec by then anyway
05:21:20 <mm_freak> what about high-throughput protocols like NNTP, where you may get a large bunch of protocol messages at once?
05:21:51 <desegnis> hm, my first try didn't work, apparently. now my whole background is green
05:21:52 <flux> mm_freak, how about benchmarking for the worst case?
05:22:02 <mm_freak> yes, i'm going to do it that way  but there's nothing to compare against
05:22:27 <flux> you could compare it to network bandwidth
05:22:49 <wli> mm_freak: Speed was not my concern. My thought was that there may be ready-made parsers, network protocol -centric parsing frameworks, etc.
05:22:50 <flux> if it can take 10 megabytes per seoncd at 1% cpu consumption, it is surely sufficient :-) (I doubt it will, though)
05:23:21 <desegnis> oh, I think I mixed up colors and widths. where's our type safety, eh?
05:23:55 <mm_freak> flux: i doubt that, too  and for some protocols it wouldn't even be enough =)
05:24:02 <mm_freak> think servers
05:24:19 <flux> mm_freak, I'm thinking that not very NNTP-servers are connected to other NNTP-servers with more than 100Mbit links
05:24:22 <flux> +many
05:24:33 <dons> 10M/sec is doable with Data.Binary, I've found (on disk, not network). so that option is open to you :)
05:24:41 <dons> (actually, more like 300M/sec or more)
05:24:58 <mm_freak> dons: but not with parsec, i suspect?
05:24:59 <dons> i don't know of any network benchmarks though, other than the apache/happs ones.
05:25:01 <Lycurgus> does mm mean m&ms or memory-management?
05:25:10 <dons> mm_freak: Data.Binary, serialising data to the disk
05:25:18 <dons> or reading and parsing it off
05:25:33 <mm_freak> lycurgus: it means `mastermind' and has a long story =)
05:26:13 <Lycurgus> I'see like overmind, nevermind, etc. or a/the game.
05:27:27 <mm_freak> lycurgus: the game
05:27:59 <mm_freak> dons: such things should be part of the preinstalled libraries
05:30:16 <dons> Data.Binary, you mean?
05:30:23 <dons> its easy enough to grab from the hackage page though
05:30:25 <dons> ?hackage binary
05:30:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
05:30:31 <mm_freak> dons: Data.Binary and many others
05:30:44 <mm_freak> yes, it is, but there is no easy means of updating it
05:30:55 <dons> hmm?
05:31:06 <dons> you just grab and install the new version, which hides the old version.
05:31:30 <mm_freak> dons: and you just do that with hundrets of installed packages =)
05:31:44 <dons> right, that's what cabal-install is for
05:31:50 <dons> or just use your package system tools
05:32:02 <dons> (gentoo has all the haskell packages in its package system, for example)
05:32:05 <mm_freak> cabal can do that?
05:32:27 <mm_freak> gentoo has?  i doubt that
05:32:27 <dons> yes, cabal-install is a new tools that comes with cabal, that just installs all the dependencies from hackage
05:32:29 <mm_freak> % eix -C haskell -sS binary
05:32:29 <mm_freak> Found 0 matches.
05:32:45 <dons> dcoutts__: mentioned just yesterday they'd added 150 new haskell packages
05:32:52 <dons> so maybe in the 'overlay' or whatever it is called?
05:32:54 <mathias_> Please have a look @ http://paste.debian.net/34357
05:33:07 <mm_freak> yeah, an overlay could be
05:33:09 <mm_freak> let me look
05:33:17 <dons> is there a `haskell overlay' ?
05:33:42 <dons> mathias_: is that an stToio call you're looking for?
05:33:53 <dons> stToIO,			-- :: ST RealWorld a -> IO a
05:33:53 <dons>  ?
05:33:59 <dons> or unsafeIOToST,		-- :: IO a -> ST s a
05:34:05 <mm_freak> dons: you're right, there is one
05:34:10 <mathias_> dons, I might, I will have a look.
05:34:48 <dons> mm_freak: there's also the #gentoo-haskell channel
05:35:02 <dons> i'm thinking of switching to gentoo, actually, because of the haskell support :)
05:35:32 <mm_freak> dons: just joined there
05:36:07 <mm_freak> dons: if you've got a lot of patience, then gentoo is a fine distro =)
05:36:32 <dons> hey, i use openbsd. i have lots and lots of patience
05:37:02 <mathias_> dons: I need an instance A ... (ST RealWorld) now.
05:37:29 <dons> sounds a bit hairy
05:37:32 <mathias_> dons, that doesn't sound like it has an easy fix.
05:37:44 <dons> sounds like you're doing something funny
05:39:57 <mathias_> dons: This is the only funny thing I do: http://paste.debian.net/34358
05:42:10 <mathias_> dons, when just using stToIO, the issue remains.
05:44:54 <Saizan> mathias_: which error do you get?
05:45:49 <mathias_> Saizan,  No instance for A <snip> (ST RealWorld)
05:45:54 <Royal_Son> is there a function which returns true for an ordered list ? i was thinking of using span to split a list of integers into smaller ordered lists of integers, e.g. span foo (1,3,5,4,6,2,1,8,9) would return (1,3,5),(4,6),(2),(1,8,9)
05:46:21 <Saizan> mathias_: A is Vars?
05:46:26 <dons> hmm. some variant of groupBy , Royal_Son ?
05:46:39 <dons> an unfold might work too
05:46:42 <Royal_Son> yeah
05:46:47 <mathias_> Saizan, no, I left out Vars from the instance declaration now.
05:47:16 <int-e> > let sorted xs = and (zipWith (<=) xs (drop 1 xs)) in (sorted [1,1,2], sorted [2,1,2])
05:47:17 <mathias_> Saizan, the instance declaration I have is A <snip> (ST s)
05:47:18 <lambdabot>  (True,False)
05:47:33 <chessguy> > product [1..108]
05:47:34 <lambdabot>  1324641819451828974499891837121832599810209360673358065686551152497461815091...
05:47:52 <Saizan> mathias_: <snip> contains type variables?
05:47:54 <int-e> Royal_Son: span works in the wrong way for this purpose
05:47:59 <chessguy> > product [1..108] / (2^56)
05:48:00 <lambdabot>  1.8383098091709743e157
05:48:02 <mathias_> > (\xs -> sort xs == xs) [1,2,3]
05:48:03 <lambdabot>  True
05:48:07 <int-e> Royal_Son: it compares everything to the first element of the span
05:48:19 <mathias_> Saizan, yes
05:48:34 <mathias_> Saizan, also the state thread parameter s.
05:49:06 <Royal_Son> oh ok
05:49:07 <chessguy> > product [43..52]
05:49:09 <lambdabot>  57407703889536000
05:49:09 <Royal_Son> thanks
05:49:29 <Royal_Son> i'll have to go now. see you all again sometime. :)
05:49:41 <Saizan> mathias_: then the problem might be there? in that it is looking for an instance more general than the one you have, because it can't infer the actual types?
05:50:47 <mathias_> Saizan, I will show the whole type. My type contains s as an unconstrained parameter, it should be more general than RealWorld
05:52:48 <mathias_> Saizan, (A  (B s) (C s (D s)) () (ST RealWorld))
05:53:15 <Saizan> and the instance for A is?
05:53:28 <mathias_> Saizan, I see the problem is that RealWorld /= s
05:53:36 <Saizan> yeah
05:53:37 <ddarius> uncurry (==) (sort *** id)
05:53:50 <Saizan> and it doens't have enough information to unify them
05:54:02 <mauke> :t sort >>= (==)
05:54:04 <lambdabot> forall a. (Ord a, Eq [a]) => [a] -> Bool
05:54:24 <mathias_> Saizan,  A (B s) (C s (D s)) b (ST s)
05:54:25 <ddarius> Slick
05:55:39 <mathias_> Saizan, how can I give it enough information such that it is able to unify them?
05:56:19 <Saizan> mathias_: fundeps, but only if your instances satisfy them
05:57:39 <mathias_> Saizan, how would that concretely look?
05:57:46 <Saizan> you'll need A a b c d | d -> a b in this case, i think
05:58:04 <Saizan> but i'd have to test
05:59:16 <mathias_> Saizan, now, I get: add an instance for A (B RealWorld) (C RealWorld (D RealWorld)) b (ST RealWorld)
06:00:27 <Saizan> heh, b :)
06:01:27 <Saizan> d -> a b c will work.. another option is to give explicit type annotations is the code that use the methods
06:02:16 <mathias_> Saizan, but d -> a b c is not true
06:02:18 <Saizan> because this is just a problem of type inference, not a type error per se
06:02:59 <MarcWeber> @seen conal
06:02:59 <lambdabot> conal is in #haskell. I last heard conal speak 1d 14h 1m 50s ago.
06:03:43 <Saizan> mathias_: then you need the annotations
06:04:56 <mathias_> Saizan, If I have foo::IO (); foo =  do x <with arguments>; putStrLn "", it still requires the RealWorld instance as described above
06:05:41 <mathias_> Saizan, and honestly, I don't see why ST RealWorld doesn't match with ST s
06:06:42 <earthy> you know your code is getting too complex when you need karnaugh diagrams to write down your pattern match rules
06:07:59 <Saizan> mathias_: and x is liftVars on this x? http://paste.debian.net/34357
06:09:42 <mathias_> Saizan, yes, or stToIO (which would be the same)
06:10:13 <mathias_> Saizan, with your proposed extra fundeps, it works, but it doesn't express what I want anymore.
06:10:52 <mathias_> Saizan, for example consider that I had another instance A <something else>, that would be invalid now.
06:11:52 <Saizan> foo = do stToIO $ (x :: [Int] -> ST s (L s ())) <arguments>; print () ?
06:13:31 <Saizan> in x :: (A (B s) (C s (K s)) () t) => [Int] -> t (L s ()) there's no connection between t and s, that's why having ST RealWorld as t is not enough to pick (A  (B s) (C s (D s)) () (ST s)) as an instance
06:16:30 <Saizan> instead with ST s (L s ()) you force the two s to be the same, so it matches
06:17:36 <Cale> mathias_: ST RealWorld does unify with ST s, however, it doesn't unify with (forall s. ST s)
06:17:56 <Cale> (which is what runST wants)
06:18:07 <Saizan> (but not stToIO)
06:19:01 <zvrba> hmmm... which haskell is best for beginners?
06:19:12 <zvrba> (most user-friendly, maybe emacs integration)
06:19:13 <mauke> Ultra Haskell 2000
06:19:21 <samreid> Turbo Haskell
06:19:24 <zvrba> haha :p
06:19:31 <mauke> MS Visual Haskell.NET
06:19:31 <zvrba> ok -> emacs integration, interactive shell ?
06:19:51 <zvrba> mauke: good try, but anything with MS and .NET is _not_ compatible with emacs
06:19:55 <Japsu> Borland HaskellBuilder Express
06:19:59 <zvrba> mauke: try again
06:20:19 <zvrba> aha, so _this_ is haskell's helpful community compared to SML's Smerdyakov
06:20:20 <zvrba> *G*
06:20:20 <mm_freak> dons: gentoo means compiling almost everything from source
06:20:22 <mauke> sorry, I don't use emacs
06:20:33 <kjdf> ghci or hugs
06:20:41 <mauke> zvrba: well, "which haskell" is a silly question
06:20:49 <mauke> there is only one haskell and it is our god
06:20:53 <zvrba> mauke: why? there are at least 3 implementations.
06:20:57 <kjdf> both are supported in haskell-mode
06:21:00 <mauke> you didn't say implementations
06:21:11 <mauke> my favorite implementation is ghc
06:21:16 <zvrba> and there are also different dialects with different extensions at that :P
06:21:17 <zvrba> so.
06:21:24 <zvrba> ok
06:21:28 <mauke> I like the errors better than hugs's
06:21:29 <Japsu> heh
06:21:33 <mauke> also, compiler
06:21:37 <Japsu> I've never tried other implementations than GHC
06:21:42 <quicksilver> zvrba: the typical choice is ghc/ghci
06:21:51 <quicksilver> zvrba: and that works fine with emacs
06:21:53 <zvrba> quicksilver: does it support interactive work?
06:22:04 <mauke> yes, ghci is an interactive interpreter
06:22:07 <zvrba> ok
06:22:09 <zvrba> thanks
06:22:15 <mauke> it even supports let bindings!
06:22:24 <zvrba> "even" ?
06:22:31 <mauke> well, hugs doesn't
06:22:31 <Japsu> !
06:22:34 <Japsu> heh
06:22:34 <Saizan> at the prompt
06:23:08 <mm_freak> mauke: i like the "Probable cause:" line =)
06:23:22 <Saizan> hugs is faster at loading your modules
06:23:23 <wli> I tried to figure out how to accept type definitions at the prompt, but apart from figuring out that the parser for such was never invoked, I didn't get anywhere.
06:24:13 <zvrba> Saizan: .. is the compiler so slow that a beginner should think about compilation speed?
06:24:30 <dmwit> nah
06:24:47 <mm_freak> wli: you can't  the prompt is an expression like you would put after a `='
06:24:53 <mauke> I'd say ghc is pretty slow
06:25:21 <zvrba> what do you use for shell if not emacs?
06:25:29 <mm_freak> mauke: `pretty slow'?
06:25:31 <mauke> ghci
06:25:32 <zvrba> (well, frontend towards haskell interpreter)
06:25:40 <mm_freak> at compiling?
06:25:42 <mauke> none
06:25:44 <Saizan> zvrba: i still use ghci, but i'm annoyed sometimes
06:26:00 <zvrba> Saizan: how "slow" does it get?
06:26:29 <mm_freak> zvrba: it's not much slower than g++
06:26:49 <zvrba> mm_freak: ah, that's bearable
06:26:53 <mm_freak> and sometimes it even generates better code
06:26:55 <mauke> mm_freak: 18K source file, 26s to compile
06:27:04 <zvrba> :(
06:27:20 <wli> mm_freak: No idea what you mean. It should just be a matter of invoking hscParseType or otherwise hscParseThing on more than just parseStmt
06:27:21 <mm_freak> mauke: 18K source file?  well, that's a complete program, isn't it? =)
06:27:23 <mathias_> Saizan, then how do I make that connection?
06:27:29 <mauke> 520 lines
06:27:31 <quicksilver> zvrba: it's fine, in practice
06:27:32 <mauke> yes
06:27:42 <quicksilver> zvrba: don't let your source files get too big
06:27:51 <quicksilver> zvrba: and split into multiple files when they do
06:28:09 <mm_freak> mauke: so in C/C++ that would be 20 or 30 source files, so it would take just as long =)
06:28:14 <wli> mm_freak: Except there are other subtleties.
06:28:34 <mauke> mm_freak: no, I have an extremely fast C compiler
06:28:35 <mathias_> Saizan, I tried annotating the type of x after it was applied, but that was wrong too.
06:28:36 <Saizan> mathias_: does foo = do stToIO $ (x :: [Int] -> ST s (L s ())) <arguments>; print ()  work?
06:29:02 <mm_freak> mauke: "extremely fast"?
06:29:19 <mathias_> Saizan, I understand your remarks now.
06:29:51 <dmwit> mauke: Do you also have an extremely fast C programmer?
06:30:01 <mauke> mm_freak: 29.6MB/s
06:30:08 <mauke> dmwit: no
06:30:51 <quicksilver> C compiles very fast indeed.
06:30:58 <quicksilver> However, the comparision to C++ would be accurate
06:31:09 <quicksilver> (if the C++ uses the hard-to-compile features, like typeclasses)
06:31:24 <quicksilver> erm
06:31:27 <quicksilver> templates they call them :)
06:31:37 <mathias_> Saizan, add (A  (B s) (C s (D s)) () (ST s)) to the context of the polymorphic type `forall s. [Int] -> ST s (Foo s ())'
06:32:05 <mathias_> Saizan, that's what I get when I add the annotation as you showed last.
06:32:49 <mathias_> mauke, which compiler is that?
06:32:56 <mauke> mathias_: tinycc
06:33:18 <wli> mauke: heh, tinycc is practically a macro-assembler.
06:33:37 <mauke> zOMG XTREME SPEED
06:34:13 <Gwern-away> @seen dons
06:34:13 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 31m 14s ago.
06:34:41 <mathias_> mauke, impressive
06:34:51 <dons> Gwern-away: ?
06:35:57 <mm_freak> quicksilver: there is no such thing as a type-class in C++ =)
06:36:15 <mm_freak> probably there will be in C++0x, and they call them `concepts'
06:36:40 <mm_freak> but it's gonna be ugly, because they're trying to improve a language, which is in many ways already broken by design
06:37:45 <mathias_> Saizan, (so, no it doesn't work)
06:38:20 <axm> hi, I'm having some troubles with the cabal package system, especially getting the package names out of the dependencies. for example at the moment (building wsp) I am looking for text (any).
06:39:28 <axm> I came to the conclusion it might be in the base packages of ghc, and a needed module would be Text.Http which is installed with http, but there are complaints it is hidden (if I remove the text-any dependency) and exposing it does not change anything. any ideas?
06:39:34 <Saizan> mathias_: last try: and adding that context?
06:39:51 <mathias_> Saizan, and when I add that context to "x", I get that it needs those RealWorld instances from before
06:40:28 <quicksilver> mm_freak: yes, I did correct myself
06:41:59 <mathias_> Cale, do you have another clue to add?
06:42:34 <mm_freak> quicksilver: "templates they call them", is not a correction, it's the error =)
06:42:40 <Cale> mathias_: Do you have your code posted somewhere?
06:43:00 <Cale> (I'm only glancing at the conversation here from time to time)
06:43:06 <mathias_> Cale: http://paste.debian.net/34357
06:43:14 <mm_freak> what they call `templates' doesn't have much to do with haskell's type-classes  it's like just rewriting source code
06:43:54 <quicksilver> that's not quite true
06:44:01 <quicksilver> because you can write specialisations
06:44:05 <quicksilver> and that's *just* like typeclasses
06:44:13 <Cale> mathias_: that's polymorphic in s?
06:44:28 <Cale> axm: I'll try, and see
06:44:40 <mm_freak> quicksilver: specializations?  do you have a source code example?
06:44:52 <quicksilver> mm_freak: vector<bool>
06:44:54 <mauke> template<typename a> struct Eq;
06:44:55 <mathias_> Cale, if by that you mean I can run runST on it, yes.
06:45:04 <mauke> template<> struct Eq<int> { ... };
06:45:04 <quicksilver> mm_freak: is specialised to use bit arrays
06:45:21 <mathias_> Cale, I will see whether I can make something that you can load.
06:45:25 <quicksilver> mm_freak: that's precisely equivalent to the trick we use to use typeclasses to get UArray Int Bool as a bit array
06:45:27 <axm> thanks
06:46:42 <quicksilver> also "just rewriting source code" is a bit deceptive. Rewriting systems are very powerful: the template rewriting system is turing-complete.
06:46:46 <Cale> axm: Edit the .cabal file. Remove 'text' from the dependency list and add  http, regex-compat
06:46:51 <quicksilver> "just a rewriting system" is no real indication of weakness
06:47:18 <quicksilver> the C++ template sublanguage is a turing-complete functional language with some kinds of type inference
06:47:19 <mauke> it's untyped
06:48:15 <Cale> axm: Those packages actually still exist, and it compiles fine if you have them both.
06:48:46 <mm_freak> quicksilver: yes, but that's not the purpose of type-classes  say:  "template <class num_t> num_t add(num_t x, num_t y) { return x+y; }", what if num_t doesn't have a `+' operator?
06:49:14 <mm_freak> (it is, of course, the purpose, but only part of)
06:49:30 <quicksilver> yes, they're not isomorphic
06:49:36 <quicksilver> however they overlap in functionality
06:50:01 <hpaste>  _ pasted "ST RealWorld problem" at http://hpaste.org/2172
06:50:17 <hkBst> mm_freak: you'll get a compile error
06:50:30 <mathias_> Cale, that paste shows the problem.
06:50:58 <quicksilver> mm_freak: the mapping is subtle, but quite well studied
06:51:10 <quicksilver> mm_freak: here is one paper, although I haven't read this one as far as I can remember
06:51:13 <quicksilver> https://dl.comp.nus.edu.sg/dspace/handle/1900.100/1526
06:51:46 <int-e> @type Control.Monad.ST.stToIO
06:51:48 <lambdabot> forall a. GHC.ST.ST GHC.Prim.RealWorld a -> IO a
06:51:52 <mm_freak> what i really don't like about C++ templates is the way C++ handles modularity
06:52:22 <quicksilver> also, "template specializaton" is subtle
06:52:23 <Saizan> mathias_: i think your paste has more problems than your original code, the type of foo doesn't even mentions y x b
06:52:38 <quicksilver> and quite different from the basic template stuff
06:52:44 <quicksilver> apparently it's also hard to spell
06:52:46 <quicksilver> :)
06:53:32 <Gwern-away> man, I really hate how section editing isn't turned on by default in the haskell wiki. but at least google has finally updated
06:53:46 <Cale> mathias_: You don't have enough functional dependencies to make that class usable in that way
06:54:06 <Cale> mathias_: How is it supposed to know which foo to use?
06:54:09 <mathias_> Cale, I cannot add more functional dependencies.
06:54:23 * SamB_XP got Igloo to add a question mark to robots.txt ;-)
06:54:25 <Cale> In particular, how does it know that y = (B s) ?
06:54:43 <Cale> B isn't even mentioned anywhere in the inferred type of foo
06:55:08 <mathias_> Cale, ok, in the real code, a field of B is read
06:55:21 <mathias_> Cale, don't pick on those small things, please.
06:55:29 <Cale> But the type of foo is  ST RealWorld Int
06:55:55 <Cale> (like, even if you tell it what you want the type of foo to be)
06:56:16 <Cale> It doesn't know that you want B involved in any way.
06:56:20 <quicksilver> @karma+ SamB_XP -- magic question mark
06:56:21 <lambdabot> SamB_XP's karma raised to 1.
06:56:34 <Cale> (and that's the only piece of information it can actually rely on here)
06:57:03 <mathias_> Cale, do you really want me to fix the code, s.t. it reads a field of B?
06:57:22 <Cale> Does it return a value of type B?
06:57:36 <Cale> So it's something like  ST RealWorld (B RealWorld) ?
06:57:55 <mathias_> Cale, I see what you mean
06:58:07 <mathias_> Cale, foo by itself doesn't determine anything.
06:58:11 <Cale> Right
06:58:25 <Cale> So if there was another instance, how would it know which to use?
06:58:27 <mathias_> Cale, even adding code around it that might do something with "B's" won't help anything either.
06:58:35 <Cale> This is the sort of thing you usually use a fundep to clear up.
06:58:50 <mathias_> Cale, Ok, but I know I cannot use a fundep in this case.
06:58:56 <quicksilver> or a phantom parameter
06:58:59 <Cale> Like, by declaring that there can only be one instance for the given monad.
06:59:11 <Cale> Or yeah, that'd work.
06:59:33 <quicksilver> or a phantom type, in the return type
06:59:44 <mathias_> Cale, There are for example mutliple implementations of a linked list all using the St monad.
06:59:59 <Cale> adding the fundep  m -> y  will get that to compile
07:00:00 <mathias_> Cale, multiple*
07:00:23 <mathias_> Cale, yes, but that doesn't hold.
07:00:28 <mauke> @index ExitSuccess
07:00:29 <lambdabot> System.Exit
07:00:34 <Cale> Can I see a bit more of your interface/
07:00:35 <Cale> ?
07:00:42 <quicksilver> the compiler needs some way to know which (B s) to pick
07:00:54 <quicksilver> if you're say that that isn't determined by ST s
07:01:06 <quicksilver> then you need to provide some way for the compiler to make that choice
07:01:14 <mathias_> Cale, that says: when we have an st monad, there is only one linked list implementation to pick.
07:01:21 <Cale> If foo took a parameter of type y, you'd be okay.
07:01:28 <Cale> mathias_: right
07:01:30 <quicksilver> giving foo a parameter on type B s (which it doesn't used)
07:01:36 <quicksilver> then it could use that to guide it
07:02:13 <mathias_> Cale, can I give foo some type annotations at the location of use?
07:02:18 <mathias_> Cale, how would that look like?
07:02:22 <quicksilver> no
07:02:27 <axm> cale, thanks, but nope. fulfilling the HTTP (the hackage library i found, the dependency is not recognized in downcase) and regex-compat, nothing changed for the build. for what i know, it might as well be a version conflict between the distro ghc and the 6.6 i compiled from source and I am using but cabal might not
07:02:31 <quicksilver> because the type of foo doesn't include B s
07:02:38 <quicksilver> so there is no type annotation which would help
07:02:51 <quicksilver> that was what I meant with my other suggestion (adding a phantom type to the return of foo)
07:03:03 <quicksilver> does "foo" actually depend on Bs? really?
07:03:10 <axm> i ll have a look into that for a moment
07:03:13 <quicksilver> would different B s types give rise to different foos?
07:03:50 <Cale> mathias_: Is it possible that foo is in the wrong typeclass altogether?
07:04:12 <mathias_> Cale, it could be that it would be better to split it off
07:04:36 <Cale> class (MonadFix m) => A y x b m | y -> x where
07:04:36 <Cale>  foo :: y -> m Int
07:04:42 <Cale> instance A (B s) (C s Int) b (ST s) where
07:04:42 <Cale>  foo x = (return 3)
07:04:53 <mathias_> Cale, I am looking how this maps from foo to the actual problem.
07:05:04 <Cale> l = stToIO (foo (undefined :: B RealWorld) :: ST RealWorld Int)
07:05:08 <mathias_> Cale, that would be the phantom type approach?
07:05:22 <Cale> Yeah.
07:05:35 <quicksilver> actually, that's the phantom parameter approach
07:05:47 <quicksilver> the phantom type approach is to change foos return type
07:05:53 <Cale> That'd be a better name, yes :)
07:05:54 <quicksilver> to something which mentions B (but doesn't really care about it)
07:06:17 <quicksilver> foo :: Foo (B s) (m Int)
07:06:29 <quicksilver> where data Foo x y = Foo y
07:06:36 <quicksilver> so the (B s) is ignored, really
07:06:45 <quicksilver> but enables you to annotate the type of foo and help the inferrer
07:07:04 <Cale> That might be tricky here, because you'd end up wrapping the whole interface to ST.
07:07:10 <quicksilver> I strongly suspect though, that foo doesn't really care about (B s)
07:07:11 <mathias_> Like tagging it with size types?
07:07:22 <quicksilver> Cale: wel, you'd provide "unFoo"
07:07:25 <Cale> yeah
07:07:29 <quicksilver> unFoo (Foo x) = x
07:07:36 <quicksilver> Cale: which strips off the phantom :)
07:07:43 <quicksilver> Cale: but you still have a point in the code where you can annotate
07:08:07 <quicksilver> all these things are possible in Fc, the question is simply "How can I feed the information to GHC's type inference engine?"
07:08:16 <Cale> hmm, I suppose you do, yeah, just under the unFoo :)
07:08:23 <quicksilver> exactly
07:08:26 <jfredett> mornin'
07:08:32 <quicksilver> the entire purpose of unFoo is to invent a point in the code
07:08:39 <quicksilver> at which you can write type annotations
07:08:51 <quicksilver> it's quite parallel to the issue of need a constructor for existentials
07:08:52 <mathias_> A type class's methods should mention every type variable to avoid this problem?
07:09:07 <quicksilver> that's the "simplest" solution, yes
07:09:13 <quicksilver> alternative, if a method really doesn't mention them
07:09:19 <quicksilver> maybe it's in the wrong typeclass?
07:09:25 <Cale> Or you have a functional dependency.
07:09:33 <quicksilver> maybe there is some either class "E y b m"
07:09:39 <quicksilver> which is "like A" but without the x
07:09:44 <quicksilver> and just provides 'foo'
07:09:51 <quicksilver> because 'foo' doesn't depend on x
07:09:58 <Saizan> it should at least mention what in the relational world is called a key
07:10:11 <quicksilver> right
07:10:15 <quicksilver> that's the fundep answer
07:10:15 <mathias_> Yes, when x -> y, when the method mentions x, it also mentions y.
07:10:20 <quicksilver> exactly
07:10:39 <shapr> @seen dons
07:10:40 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 3m 29s ago.
07:10:46 <shapr> hmm
07:10:50 <shapr> Good morning #haskell!
07:11:15 <gaborek> Hallo
07:11:26 <shapr> gaborek: How's code?
07:11:34 <jfredett> mornin shapr
07:11:37 <quicksilver> mathias_: I should thank you for your questions. In answering them I feel like I finally understand type classes and fundeps :)
07:11:40 <shapr> Greetz jfredett, wassup?
07:11:44 <quicksilver> truly teaching is the best way to learn.
07:12:17 <shapr> I always thought Ritalin was the best way to learn!
07:12:40 <shapr> Ok, I admit... quicksilver is right.
07:12:44 <jfredett> things with a position vector which is an element of the normal plane to my position vector times a scalar constant strictly greater than 1, shapr, otherwise, not much
07:12:48 <quicksilver> must... resist... temptation... to @remember that
07:12:52 <gaborek> I am looking for somebody who helps me with parsec, a little help ;-)
07:12:58 <shapr> quicksilver: Heh, if you want to @remember it.
07:13:16 <shapr> quicksilver: Then I don't mind
07:13:21 <quicksilver> gaborek: you've come to the wrong place. Here we only talk about obscure 1970s TV shows.
07:13:32 <Cale> quicksilver: hehe
07:13:45 * shapr rereads jfredett's comment a few times
07:13:57 <gaborek> :D
07:13:59 <jfredett> shapr: lol, its probably some bad math
07:14:08 <jfredett> I was just trying to be a smartass
07:14:24 <shapr> Well, you succeeded except that I took you completely seriously.
07:14:29 <jfredett> lol
07:14:35 <mathias_> quicksilver, that's good for you, however, I still have the same  s/=RealWorld problem.
07:14:36 <jfredett> the idea there is sound
07:14:46 <jfredett> the implementation may be broken
07:15:03 <shapr> I just have to figure out what a normal plane is...
07:15:09 <jfredett> i mean, if you draw a normal plane to my position vector (assuming an absolute coordinate system)
07:15:20 <Saizan> normal = perpendicular
07:15:20 <SamB_XP> jfredett: 4d?
07:15:25 <jfredett> a plane tangent (and perpendicular) to my position vector
07:15:29 <shapr> Oh, I see.
07:15:41 <jfredett> SamB: uhm- I was thinking 3d, I wasn't including time
07:15:43 <SamB_XP> oh. strange concept, that...
07:15:48 <quicksilver> mathias_: well my two current suggestions are : consider removing foo from the A typeclass, and putting it in a smaller one
07:16:00 <quicksilver> mathias_: or, add a phantom (B s) parameter to foo
07:16:01 <jfredett> anyway, that normal plane defines a Vector Space
07:16:47 <jfredett> which means i have a set of elements which I can multiply by a positive scalar strictly greater than 1, to get something "above" that plane
07:16:50 <mathias_> quicksilver, the problem is that I don't even know what "foo" is in the actual program.
07:17:11 <mathias_> quicksilver, But that's just hard work. Thanks
07:17:12 <jfredett> eg <x,y,z> is on the plane, <1.1x,1.1y,1.1z> is "above" the plane
07:17:14 <jfredett> or "up"
07:17:17 <jfredett> :)
07:17:26 <quicksilver> mathias_: sounds like you have a very complex program, there
07:17:30 <jfredett> hence, those things are up. :)
07:17:31 <shapr> Oh, that's interesting.
07:17:32 <Cale> I'm telling you people, "Emergency +4" was way better than "Adam-12"
07:17:36 <quicksilver> mathias_: where did it come from? work project written by someone else?
07:17:51 <gaborek> I use buildExpressionParser, and I want to have both operators: < and <= but first is prefix of snd..., how can I solve it? :]
07:18:06 <quicksilver> gaborek: in the lexer, traditionally
07:18:17 <quicksilver> gaborek: you have a "first-pass" parser (or lexer)
07:18:34 <mrd> gaborek: did you specify < and <= in the operators of the language def
07:18:41 <quicksilver> gaborek: which munches adjacent <>+-= type characters into one token
07:18:48 <mathias_> quicksilver, it's part of a kind of skunkworks department. Can't tell you more.
07:19:04 <quicksilver> gaborek: so your tokens are no longer chars, but slightly more structured
07:19:04 <SamB_XP> mathias_: so you make stinky code?
07:19:08 <shapr> Cale: The new or old Adam-12?
07:19:12 <mrd> gaborek: in general the 'try' combinator will perform infinite lookahead-alike behavior
07:19:29 <quicksilver> gaborek: if your language is sufficiently haskell like you can r-use the haskell lexer
07:19:34 <jfredett> stinky _french_ code, Pepe L'pu!
07:19:47 <quicksilver> mathias_: *nod*
07:19:52 <Cale> shapr: hehe :)
07:20:00 <gaborek> do u know some tutorials about lexer in haskell?
07:20:04 * SamB_XP re used the ML lexer example for one of his programs ;-P
07:20:11 <mrd> gaborek: see the parsec docs
07:20:18 <mrd> you're using parsec right?
07:20:22 <gaborek> yes
07:20:23 <mrd> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
07:20:28 <SamB_XP> @google alex haskell
07:20:30 <lambdabot> http://www.haskell.org/alex/
07:20:30 <lambdabot> Title: Alex
07:20:32 <mrd> there is a section on Lexing
07:20:37 * wli looks into pArrows
07:20:46 <mrd> basically it involves using the Parsec.Token package
07:20:56 <quicksilver> I don't think he needs alex
07:20:56 <Cale> gaborek: You might just try wrapping the parser for <= in 'try'
07:21:07 <quicksilver> I think there is a haskell-like lexer built into parsec isn't there?
07:21:16 <Cale> gaborek: which would be easier than doing lexing separately
07:21:18 <mrd> yes it's called haskellStyle
07:21:21 <SamB_XP> quicksilver: probably not full Haskell
07:21:28 <mrd> lexing in Parsec is easy and you should be doing it anyway
07:21:35 <quicksilver> I must admit I normally do my own lexing
07:21:39 <quicksilver> with takeWhile and dropWhile
07:21:41 <SamB_XP> Cale: but wouldn't prevent the parser for < from eating the <=
07:21:44 <SamB_XP> er.
07:21:47 <gaborek> Cale: but I use buildExpressionParser
07:21:48 <quicksilver> it's not normally more than 15 lines of code
07:21:48 <SamB_XP> eating the < in <=
07:22:00 <mrd> gaborek: scroll down to Lexical Analysis for an example
07:22:02 <quicksilver> SamB_XP: you put <= first
07:22:08 <quicksilver> SamB_XP: and it wins by ordering :)
07:22:14 <quicksilver> SamB_XP: I think the lexing approach is more elegant though
07:22:14 <mrd> you can easily combine this with expression parsers. there is also an example of that right above.
07:22:16 <Cale> er, right, you might have to use notFollowedBy
07:22:35 <quicksilver> Cale: no, it's safe to wrap <= in a try and put it first
07:22:49 <quicksilver> Cale: then < will only be hit if the <= failed
07:22:54 <SamB_XP> quicksilver: that works great if you get to pick the ordering ;-)
07:22:59 <Cale> Depends on the definition of buildExpressionParser, doesn't it?
07:22:59 <quicksilver> but I still think lexing is the better answer
07:23:08 <gaborek> it is smart to use lexer but I do not quite understand what is written about lexer in haskell
07:23:14 <quicksilver> Cale: oh, good point. I'd forgotten that bit.
07:23:17 <mrd> ... there is an example of a lexer + expression parser in the documentation i linked
07:23:25 <Cale> I agree that the general solution is to lex in a separate pass. It's not so hard to implement one directly in parsec.
07:23:27 <mrd> using normal parsec libraries
07:23:46 <quicksilver> Cale: I have been known to hand-write a lexer, and then use parsec on my custom token type
07:24:40 <quicksilver> I must admit, I don't find parsec's interface attractive; although it's powerful and pretty fast I wish we had a "prettier" one expecially for newbies
07:25:05 <Cale> ReadP is nice, but it's missing a bit of the polish that Parsec has.
07:25:23 <wli> pArrows does some things I consider nice.
07:25:30 <Saizan> ReadP miss things like anyChar
07:25:43 <quicksilver> I like libraries which allow me to write my parser as if it was the grammer
07:25:46 <quicksilver> or as near as possible
07:26:01 <quicksilver> that's what attracted me to combinator parsing in the first place
07:26:01 <Cale> Saizan: 'get'
07:26:08 <quicksilver> (chapter at the end of Paulson's ML book)
07:26:12 <wli> quicksilver: me too
07:26:30 <Cale> Also, ReadP is specifically for parsing strings.
07:27:03 <mrd> coincidentally, I was about to write an expression parser for a small thing this morning
07:28:17 <mrd> gaborek: i will paste the code if you want
07:34:48 <gaborek> thx, I will try to understand it one more time ;-)
07:41:37 <gaborek> siema ;-)
07:43:15 <shapr> SHAZAM!
07:44:29 <ski> alakazam !
07:44:49 <gaborek> kurde
07:50:16 <thoughtpolice> boom?
07:52:59 <jfredett> byorgey: WITCH! she turned you into a newt!
07:53:19 <byorgey> glad someone got the joke =)
07:53:28 <byorgey> I got better
07:53:32 <jfredett> :)
07:53:46 <malsyned> is there already a function defined that's \x -> (take x).cycle ?
07:53:59 <desp> gaborek: english channel.
07:54:13 <quicksilver> malsyned: no, I don't believe so
07:54:54 <malsyned> or \x -> (take x).cycle.(:[]) actually
07:55:18 <malsyned> also: is there a function defined for (:[])?
07:55:25 <Saizan> return
07:55:25 <int-e> return ;-)
07:55:26 <ski> malsyned : 'replicate' ?
07:55:33 <quicksilver> it's called 'the monkey combinator'
07:55:41 <quicksilver> and the preferred way to write it is (:[])
07:55:51 <quicksilver> seriously, though, I prefer (:[]) to return
07:55:51 <Saizan> :t (\x -> (take x).cycle.(:[]),replicate)
07:55:53 <malsyned> ski: that's exactly what I wanted!  thanks
07:55:54 <lambdabot> forall a a1. (Int -> a -> [a], Int -> a1 -> [a1])
07:55:57 <int-e> yes, (:[]) looks really cute.
07:55:59 <quicksilver> because return is overloaded
07:56:10 <quicksilver> wheras (:[]) says what it means
07:56:10 <malsyned> Well, now that I know it's called the 'monkey combinator', I feel compelled to prefer it as well ;)
07:56:21 <ski> cycle . (:[]) = repeat
07:56:33 <quicksilver> in order of (totally subjective) preference, (:[]) > (\x -> [x]) > return
07:56:45 <malsyned> and replicate n = (take n).repeat
07:57:42 <Saizan> replicate = (. take) . repeat  :)
07:58:21 <int-e> (. repeat) . take  surely
07:58:44 <Saizan> right
07:58:56 * int-e generally avoids sections of (.) - they're confusing
07:59:00 <malsyned> (. function) wins the prize for notation I'm least sure whether I love or hate.
07:59:11 <quicksilver> confusing is of course subjective
07:59:14 <quicksilver> you can get used to stuff
07:59:23 <quicksilver> but personally I do find .-sections hard to read
07:59:28 <byorgey> @remember malsyned (. function) wins the prize for notation I'm least sure whether I love or hate.
07:59:29 <lambdabot> Done.
07:59:42 <wli> (. snd) . (==) . snd
07:59:44 <malsyned> :-D
07:59:58 <quicksilver> I like to try to arrange my code so that the "main thread" is a single parameter
08:00:10 <malsyned> @unpl (. snd) . (==) . snd
08:00:10 <lambdabot> (\ d j -> (snd d) == (snd j))
08:00:16 <quicksilver> and I find most of the tricks you can do when there are two parameters involved pretty ugly
08:00:27 <malsyned> wli: now how do you write that with only one occurrence of 'snd'?
08:00:48 <quicksilver> (==) `on` snd
08:01:15 <quicksilver> (but on is not in the 6.6 standard lib, but I think it is for 6.7?)
08:01:26 <Saizan> ?pl \snd -> (. snd) . (==) . snd
08:01:26 <lambdabot> ap ((.) . flip (.)) ((==) .)
08:01:33 <quicksilver> you can also write "comparing snd" or something similar? which is not exactly the same
08:01:43 <malsyned> I've wanted something like 'on' for a long time.  that's great.
08:02:02 <quicksilver> :t comparing snd
08:02:04 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
08:02:10 <malsyned> well.  I've been writing Haskell for less than a year.  so "a long time" isn't that long.
08:02:12 <quicksilver> yeah, that is sort of analogous
08:02:17 <quicksilver> but comparing is a special case for Ordering
08:02:17 <wli> curry $ uncurry (==) . join (***) snd
08:02:31 <quicksilver> `on` is the general case
08:05:16 <matthew-_> are the talks at Anglo Haskell being recorded in any way, shape or form?
08:06:09 <axm> Cale, no, was not the other compiler, completely removed that. manul imports of Text.Html work. cabal cannot find it. thanks for helping though.
08:06:56 <Cale> axm: hmm, that's odd
08:07:31 <Cale> axm: does anything like it show up in ghc-pkg list?
08:07:39 <axm> it does
08:07:51 <axm> the HTTP-3000 hackage thingy
08:08:30 <axm> sry, back to the html modude that is not found
08:09:14 <axm> so that would  be html-1.0.1 as configure recognizes as well
08:09:25 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/html-1.0
08:09:28 <lambdabot> http://tinyurl.com/3ybcte
08:12:55 <axm> cannot imagine installing a version that is the same at least up to the second number will do a difference in different cabal/ghc behaviour, thats why I did not install it in the first place, but I'll try
08:13:38 <Cale> Nah, if you have any html it should do.
08:13:55 <Cale> (just in case you didn't)
08:14:21 <axm> i think it already came with it
08:14:33 <SamB_XP> axm: what do you think this is, Python?
08:14:48 <Cale> GHC? Yeah, I think that's possible
08:15:41 <bwx> I think there is a bug in gtk2hs in garbage collection of SourceMarker
08:16:06 <axm> you mean because i think it came with it? it is there, i do not remember installing it, so thats the conclusion
08:17:46 <Saizan> axm: (just the standard question: do you have html in build-depends ?)
08:20:40 <axm> saizon, nope, for the moment, i do not know what the hell i am doing, it is a downloaded library. that was the pointer i needed
08:21:13 <Saizan> ah, which one?
08:21:39 <axm> but since i got heaps of other errors now, i think i will move to another lib to learn
08:21:43 <axm> the build-dep
08:22:10 <axm> does not look like it was released with care
08:40:27 <HWSOD> access
08:40:44 <desp> denied
08:41:32 <axm> hm, still reparing the wsp release. for cabal, do i have to configure the linker apart from the Build-Depends field in the .cabal? Does not seem look like that in the docs.
08:43:58 <axm> at least way more complex packages i have looked at do not do anything else
08:44:17 <Saizan> no, it's enough
08:57:21 <chessguy> has anyone seen this? http://notes-on-haskell.blogspot.com/2007/07/intro-to-haskell-parts-1-2-and-3.html
08:57:23 <lambdabot> Title: Notes on Haskell: Intro to Haskell, Parts 1, 2 and 3, http://tinyurl.com/3amwfk
08:57:44 <chessguy> I love the first sentence: "Let me start by being perfectly clear: if you are a professional programmer, then Haskell is in your future."
09:00:02 <hpaste>  mathias pasted "Still same issue" at http://hpaste.org/2173
09:00:36 <mathias_> quicksilver, Saizan, Cale: can you please look again?
09:03:52 <Cale> mathias_: actually, on that code I get a rather different error
09:04:00 <Cale> (Coverage condition fails)
09:04:29 <monochrom> Haskell is in your continuation? :)
09:05:16 * SamB wonders which is more inefficient -- Integer or Word64
09:06:20 <monochrom> Word64 is shorter to type
09:06:57 <dons> SamB_XP: good questoin. I suspect Word64 miight just win (2 Word32s, versus a Ptr Word32)
09:06:57 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:07:03 <monochrom> But if you have completion, Integer is shorter to type.
09:07:48 <SamB> monochrom: um.
09:08:02 <monochrom> haha
09:08:06 <SamB> I have to type it maybe twice in the whole program...
09:08:17 <dons> SamB_XP: the other complication is that Word64 is a ccall for most ops on 32 bit
09:08:27 <Cale> mathias_: oh, with -fallow-undecidable-instances, it compiles once you give z an explicit type signature where it's used in main
09:08:32 <dons> and Integer too has to call into gmp, but only once it gets over 32 bit
09:08:36 <Cale> er, abc
09:08:45 <dons> SamB: so its not perfectly clear cut
09:09:23 <dons> http://isaac.cedarswampstudios.org/2007/HIntegerByInt  !
09:09:24 <lambdabot> Title: Index of /2007/HIntegerByInt
09:09:37 <Cale> mathias_: But you should really consider the possibility of moving such an operation out to another typeclass.
09:09:41 <dons> "  What is this? It is a reimplementation, in Haskell, of the
09:09:41 <dons>   Integer type that Haskell provides in its Prelude.  It is designed
09:09:41 <dons>   in mind of being actually usable as the implementation of that type,
09:09:41 <dons>   for compilers."
09:09:52 <dons> is this the (secret) gmp killer?
09:10:06 <dons> and why Isaac Dupree's been doing these low level tunings.
09:10:27 <monochrom> He's building a secret computer.
09:13:00 <SamB> I wish there was a way to say "specialize everything in this module to work with each of these numeric types:"
09:29:24 <SamB> hmm. for problem 21 on project euler, is the sum supposed to include amicable numbers whose friends are >= 10000 ?
09:30:26 <shachaf> SamB: Yes, I think so.
09:30:32 <ohub> SamB: yep
09:32:51 <SamB> hmm. apparantly I won't need any code for this one ;-)
09:33:30 <shachaf> SamB: At all?
09:33:51 <shachaf> SamB: Or do you mean you only need ghci?
09:34:38 <SamB> well, I'm writing a little code
09:35:00 <SamB> but I'm pasting in the numbers from A063990
09:36:13 <novaburst> I have been trying to teach myself Common Lisp(slowly) and I have been stumbling a bit on the functional aspect. Most of my programming experience is in BASIC type languages. My question is, would learning Haskell help me in regards to my structure in Common Lisp?
09:36:37 <SamB> CL has a functional aspect?
09:37:01 <byorgey> SamB: it doesn't?
09:37:13 <shachaf> novaburst: I know Haskell helped me with the "functional aspect" of Scheme more than Scheme did, sometimes.
09:37:22 <MarcWeber> SamB: What did you mean by specialize?
09:37:27 <SamB> well, okay, so maybe it makes a pitiful attempt...
09:37:42 <SamB> MarcWeber: you know, like {-# SPECIALIZE #-} only not so verbose
09:37:53 <novaburst> shachaf: ok, good to know, thank you
09:38:44 <SamB> since you have to write one SPECIALIZE pragma for each (name, specialized type) pair
09:38:55 <shachaf> novaburst: Scheme in general may also be a good one to consider.
09:39:04 <MarcWeber> @tell dcoutts I've found the problem. The directory containing libgthread isn't listed in lib-dirs in the package conf. Do you know how to fix this or should I investigate myself?
09:39:04 <lambdabot> Consider it noted.
09:39:08 <SamB> novaburst: on the other hand, CL's support for FP is not very good
09:39:14 <novaburst> shachaf: ok
09:39:16 <MarcWeber> SamB: I have to lookup this pragma..
09:39:22 <shachaf> novaburst: (Though Haskell is still good to learn.)
09:39:56 <SamB> shachaf: you already implied that ;-)
09:39:59 <ari> SamB: Just go pick up MULTISPECIALIZE from jhc :p
09:40:04 <novaburst> SamB: yes, from what I understand Haskell is much more functional
09:40:29 <novaburst> shachaf: yes, that is why i'm here, i have heard that many times :)
09:40:37 <SamB> if scheme is good for understanding FP, and Haskell is sometimes better than scheme for understanding FP *in scheme*...
09:40:45 <chessguy> @type guard
09:40:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:40:54 <SamB> than clearly Haskell is good to look at, too ;-)
09:41:02 <mathias_> Cale, to what other type class then?
09:41:41 <mathias_> Cale, according to the "mentions" relation we talked about earlier, every variable is reachable in the method.
09:42:08 <shachaf> Learning Haskell is still a good idea, anyway.
09:42:10 <shachaf> What I tell you three times is true! :-)
09:42:24 <novaburst> hehe
09:42:47 <chessguy> has anyone seen this? http://notes-on-haskell.blogspot.com/2007/07/intro-to-haskell-parts-1-2-and-3.html
09:42:49 <lambdabot> Title: Notes on Haskell: Intro to Haskell, Parts 1, 2 and 3, http://tinyurl.com/3amwfk
09:43:16 <Cale> mathias_: Yeah, that code will compile -- it just can't infer the type at which you're applying z.
09:44:17 <kjdf> //part
09:44:18 <msouth> chessguy: yeah, that's a little out of date actually, I think he's got part three done
09:44:22 <Cale> mathias_: all you have to do is add  :: ST RealWorld (C RealWorld Int, AX RealWorld () ())
09:44:31 <msouth> on monads
09:44:34 <chessguy> msouth, yeah, he does
09:44:41 <Cale> to the line where z is used
09:44:48 <chessguy> msouth, if you follow the links to the first 2 parts, you'll see a link for part 3
09:45:02 * thoughtpolice got his irc bot working. :) and it has loadable plugins, too
09:45:31 <ddarius> thoughtpolice: Does it have a theorem prover as a plugin?
09:45:34 <Cale> mathias_: What things does the behaviour of z really rely on?
09:45:57 <thoughtpolice> ddarius: no, but you could write one. i figure a some lambdabot commands could be ported without much hassle.
09:45:59 <chessguy> or a pl converter
09:46:09 <mathias_> Cale, only on its two parameters
09:46:33 <chessguy> thoughtpolice, does it offer any advantages over LB?
09:46:39 <mathias_> Cale, a rather silly answer since it's a functional programming language :/
09:46:48 <Cale> okay, so you might consider moving it to a similar class where the q parameter is left out
09:47:13 <Cale> mathias_: You're using phantom parameters aren't you?
09:47:16 <mathias_> Cale, so the problem is that I don't use the result.
09:47:20 <mathias_> Cale, no, not yet.
09:47:21 <Cale> yes.
09:47:29 <thoughtpolice> chessguy: i wouldn't put it in the same sentence as lb
09:47:36 <thoughtpolice> IOWs, no way
09:47:43 <Cale> If that type there is really reflective of what z is doing, then that's fine
09:47:44 <mathias_> Cale, ok, I will see whether depending on the q result helps.
09:47:59 <thoughtpolice> i only took the time to write about 2 plugins to test it.
09:48:04 <mathias_> Cale, yes, the type is ok.
09:48:11 <chessguy> ah, so it's just for learning purposes
09:48:28 <thoughtpolice> chessguy: yeah, but i figure if i got some plugins working it could get useful maybe.
09:48:42 <thoughtpolice> i've only been working on it on and off for about 2 days
09:49:26 <mathias_> Cale, I don't get it. q should be determined by l by the fun dep.
09:49:39 <chessguy> ah nice
09:49:39 <mathias_> Cale, so, q should neither be of interest.
09:49:44 <chessguy> thoughtpolice++ good job
09:49:54 <mathias_> Cale, what did you mean?
09:49:54 <thoughtpolice> chessguy: ty.
09:50:13 <chessguy> thoughtpolice, even better if you can publish the API for writing plugins
09:50:21 <thoughtpolice> chessguy: the api is ridiculously simple
09:50:36 <chessguy> better yet!
09:50:42 <thoughtpolice> chessguy: i'll paste something right quick
09:51:30 <hpaste>  thoughtpolice pasted "example of an infinity plugin, and the API in its whole" at http://hpaste.org/2175
09:52:16 <Cale> mathias_: I think it might be an undecidable instances thing -- you might supply a more specific instance for RealWorld later, so it can't infer that you want that type
09:52:24 <chessguy> infinity is the bot?
09:52:30 <thoughtpolice> chessguy: i couldn't think of another name
09:52:38 <thoughtpolice> sue me :(
09:52:44 <chessguy> lol
09:52:55 <chessguy> no, i was just trying to figure out what "hello world" had to do with infinity
09:52:57 <mathias_> Cale, conclusion?
09:53:08 <thoughtpolice> chessguy: hah. well yeah that's the name. :)
09:53:22 <chessguy> got it
09:53:42 <chessguy> looks interesting. i'll have to check it out in more detail later
09:53:51 <chessguy> gotta get back to work
09:53:57 <chessguy> @tell chessguy http://hpaste.org/2175
09:53:57 <lambdabot> You can tell yourself!
09:54:01 <chessguy> bah
09:54:13 <thoughtpolice> chessguy: the whole implementation (minus plugin code) is about ~330 loc. if you're interested hit me up later and i'll give you a tarball (i don't have anywhere to put a darcs repo)
09:54:13 <shachaf> @tell chessguy http://hpaste.org/2175
09:54:14 <lambdabot> Consider it noted.
09:54:14 <chessguy> @tell chessguy_ http://hpaste.org/2175
09:54:14 <lambdabot> Consider it noted.
09:54:21 <mathias_> Cale, I thought this instance for (ST s) supposed to mean that it is an instance for all s.
09:55:03 <Cale> Which compiler switches are you using, out of interest?
09:55:32 <mathias_> {-# OPTIONS -fallow-undecidable-instances  -fallow-overlapping-instances  #-} and...
09:55:55 <mathias_> -fno-monomorphism-restriction -fglasgow-exts -XFlexibleInstances
09:56:09 <mathias_> Cale, that's all
09:57:03 <Cale> okay
09:58:19 <Cale> I'm not terribly familiar with allowing zany instances, so give me a moment to try to sort out exactly what's happening.
09:58:41 <mathias_> Cale, thank you
09:59:47 <Cale> Normally, the instance you have there fails the coverage condition, which states that for each fundep  tvs_left -> tvs_right, every type variable occurring in S(tvs_right) must appear in S(tvs_left) where S is the substitution mapping each type variable in the class decl. to the corresponding type in the instance decl.
10:01:09 <Cale> So, in particular, you have l -> b, but in the instance decl, you have S(b) = b and S(l) = AX s, but b does not occur in AX s
10:02:47 <mathias_> Cale, b does not occur in AX s, but it does occur in AX s a b
10:02:58 <Cale> right
10:03:11 <Cale> I'm not sure this actually has anything to do with the problem :)
10:03:30 <mathias_> Cale, what my remark, or your remark?
10:03:36 <Cale> mine
10:03:41 <Cale> What happens with -fallow-incoherent-instances ?
10:03:52 <Cale> I should copy the code into a file again :)
10:04:13 <mathias_> Cale, no change
10:04:22 <Saizan> with c2hs is there a way to have #define-d constants in a .h file in the .chs' scope?
10:07:17 <glguy> Word!
10:07:47 <glguy> word?
10:08:34 <samreid> um.. W# Word#??
10:09:36 <Cale> mathias_: hmm, okay, I think I understand what's going on
10:10:28 <Cale> mathias_: the inferred type of z (1,()) AX is: (A (AX s) (C s Int) () (ST RealWorld))
10:11:59 <Cale> That doesn't exactly match any instance which has been provided.
10:12:50 <mathias_> Cale,  If one substitutes RealWorld for s, it does.
10:12:58 <Cale> Indeed
10:13:08 <mathias_> Cale, I don't see why that doesn't happen.
10:14:02 <mathias_> Cale, sorry for interrupting.
10:14:02 <Cale> Perhaps it's being more conservative than you might expect in the face of -fallow-overlapping-instances
10:14:49 <Cale> Let me try something with a second module and see what happens :)
10:15:02 <Saizan> dcoutts_: ping
10:21:12 <newsham> anyone here handy with Isabelle?  (or know a place where I might find such a person on irc?)
10:28:05 <cjeris> newsham: try #coq, ask if anyone there knows isabelle too
10:28:47 <cjeris> but it's kinda dead most of the time, be prepared to wait
10:30:14 <SamB> might want to ask your question too?
10:30:34 <SamB> I meant, in #coq. in here it'd disappear before anyone who knew isabelle saw it...
10:33:00 <Cale> aha!
10:33:17 <SamB> aha?
10:33:41 <Cale> mathias_: It infers to the point that z must be ST s (C s Int, AX s1 a ())
10:33:53 <Cale> but it can't decide that s and s1 are the same
10:35:22 <Cale> Rather that z (1,()) AX has that type
10:35:50 <Cale> That is, the inferred type of that constant AX is more general than you expected it to be
10:36:20 <Cale> You want the s in it to match the 's' from the surrounding ST block, but it isn't necessarily so.
10:37:21 <mathias_> Cale, ok, let me see if I can understand that.
10:38:05 <Cale> t :: forall s. ST s ()
10:38:05 <Cale> t = do z (1,()) (AX :: AX s a ())
10:38:05 <Cale>        return ()
10:38:09 <Cale> abc = do
10:38:09 <Cale>  g <- stToIO t
10:38:09 <Cale>  return ()
10:38:16 <Cale> that will work.
10:39:41 <Cale> In order to apply the instance, it has to know that the s from the (ST s) is the same one as the s in the (AX s), but it didn't know that.
10:40:13 <psykotic> it never gets a "concrete" type, but at the type checking level it generates a pattern variable and unifies all "linked" uses of it
10:40:28 <Cale> Removing the type signature for *t* there should cause it to go back to failing.
10:40:53 <Cale> (because the scoped type variable won't be anymore)
10:42:01 <Cale> (and yes, I just checked, and it does)
10:43:00 <Cale> This might not be a problem in an actual program.
10:43:20 <Cale> Presumably, in your real program, AX has s as a type parameter for a reason.
10:43:46 <Cale> If you're storing STRefs inside it, and those came from the surrounding monad, you should be okay.
10:44:49 <Cale> mathias_: make sense?
10:45:10 <DaveCGI609> is deriving type classes like OO inheritance?
10:45:31 <bos> no,
10:45:37 <Cale> DaveCGI609: not really, it just writes some specific code based on your data declaration
10:45:43 <mathias_> Cale, not completely, must I am close. I don't see why when l is known, q is not determined by it.
10:45:57 <Cale> DaveCGI609: and it only works for a handful of classes (except if you're talking about newtype deriving)
10:46:00 <DaveCGI609> can i write my own rules for how X should be derived from Y?
10:46:03 <Cale> no
10:46:16 <mathias_> s/must/but/g
10:46:18 <DaveCGI609> so deriving is magical?
10:46:23 <Cale> yeah
10:46:25 <Vq^> DaveCGI609: yes
10:46:33 <DaveCGI609> :(
10:46:42 <Cale> The only classes in the Prelude for which derived instances are allowed are Eq, Ord, Enum, Bounded, Show, and Read
10:47:17 <Cale> http://haskell.org/onlinereport/derived.html#derived-appendix -- this says how they're generated.
10:47:17 <DaveCGI609> do cool haskell programmers always use . and $ instead of() ?
10:47:18 <lambdabot> Title: The Haskell 98 Report: Derived Instances
10:47:27 <mrd> is there a way to extract the number of seconds from a NominalDiffTime?
10:47:29 <Cale> DaveCGI609: not always, but often
10:47:43 <Cale> DaveCGI609: if there's more than one set of parens, I'll usually do it
10:47:47 <DaveCGI609> k ill do it all the time and confuse other people :P
10:48:10 <Cale> It's actually quite a good thing to do to get you thinking the right way, most of the time.
10:48:12 <SamB> what do you call the lattice built on Z where n <= m iff each digit in the base b representation of n is <= the corresponding digit in the base b representation of m?
10:48:43 <DaveCGI609> is there a list of operators and their binding associativity/precedence somewhere?
10:49:01 <DaveCGI609> infix operators of course*
10:49:05 <shachaf> DaveCGI609: You can use :i for a specific operator.
10:49:08 <shachaf> @where report
10:49:08 <lambdabot> http://www.haskell.org/onlinereport/
10:49:18 <DaveCGI609> oh sweet
10:49:18 <shachaf> Maybe that can help?
10:49:21 <SamB> check the Prelude section of the report for the main ones
10:49:35 <Cale> DaveCGI609: You can also ask ghci for them
10:49:40 <DaveCGI609> using :i works
10:49:40 <SamB> or hugs
10:49:41 <Cale> :info (>>=)
10:49:46 <SamB> :i works in either
10:49:50 <Cale> yeah
10:49:55 <DaveCGI609> and the langauge report is good if im not sure which it is
10:50:04 <SamB> which what?
10:50:18 <mathias_> Cale, I believe I carefully thought about it, but I still don't see why q isn't determined by l.
10:50:21 <DaveCGI609> which operator im looking for
10:50:27 <Cale> SamB: The base-b digital comparison lattice? :)
10:50:46 <Cale> mathias_: it has nothing at all to do with the fundep after all
10:51:07 <Cale> mathias_: The fundep actually is doing its job, as you can see by looking at how the error changes if you remove it
10:51:15 <SamB> Cale: is that the usual name, or did you just make it up?
10:51:17 <DaveCGI609> function application has binding order of 10 (highest possible) correct?
10:51:21 <Cale> SamB: made it up
10:51:31 <Cale> SamB: I sort of doubt that it has a name
10:51:56 <Cale> Have you seen it used anywhere?
10:52:16 <DaveCGI609> how do i turn off that stupid "No instance for Show(x)" error message
10:52:37 <Cale> DaveCGI609: by either providing an instance, or not trying to print values of type x
10:53:01 <Cale> You can provide an instance by deriving one, most of the time, if it's your type.
10:53:07 <mathias_> Cale, ok, I see that the fundep did its job.
10:53:10 <DaveCGI609> its what happens when i try to print an expression that doest evaluate to a value such as " (+2) " (no quotes)
10:53:18 <Cale> DaveCGI609: right.
10:53:30 <Cale> DaveCGI609: That does evaluate to a value, it's just that value is a function
10:53:35 <Cale> and you can't print functions
10:53:36 <DaveCGI609> yeah well it should just print (a -> a) and thats it
10:54:00 <Cale> If you want, there's code that comes with lambdabot for printing functions...
10:54:03 <Cale> > (+2)
10:54:05 <DaveCGI609> or i guess in this case (Integral -> Integral)
10:54:11 <lambdabot>  <Integer -> Integer>
10:54:21 <Cale> (Num a) => a -> a would be the actual type
10:54:21 <int-e> @type (+2)
10:54:23 <lambdabot> forall a. (Num a) => a -> a
10:54:37 <DaveCGI609> yeah sure
10:54:42 <DaveCGI609> how do i download lambdabot
10:54:43 <int-e> but lambdabot has extended defaulting rules
10:54:47 <int-e> @version
10:54:48 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
10:54:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:54:50 <Tchakkazulu> In ghci you can use :t (+2)
10:54:59 <newsham> cjeris: danke
10:54:59 <SamB> Cale: I haven't seen it used anywhere
10:55:04 <int-e> but building lambdabot is probably tricky
10:55:10 <Cale> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/ShowFun.hs
10:55:10 <Tchakkazulu> At least, if you just want to know the type.
10:55:12 <SamB> but I was thinking of asking a question about it
10:55:15 <DaveCGI609> is there an @src thing for ghci
10:55:20 <DaveCGI609> to show the src of a function
10:55:22 <mathias_> Cale, I see the ST RealWorld comes from the call to stToIO.
10:55:37 <Cale> DaveCGI609: nope
10:55:56 <Cale> DaveCGI609: It'd be handy, but nobody's implemented it.
10:55:56 <DaveCGI609> how do you look up sources for something then except for actually looking them up in ghc sources
10:56:17 <int-e> :i <symbol> and look at the corresponding library sources.
10:56:17 <Cale> Looking them up in the GHC sources, or Report, mostly.
10:56:31 <DaveCGI609> does report have canonic sources for prelude?
10:56:32 <Cale> http://haskell.org/onlinereport/standard-prelude.html
10:56:33 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
10:56:42 <int-e> (:i in ghci tells you the module where the symbol is defined)
10:56:50 <Tchakkazulu> There are links to the source code in the haddock-generated documentation.
10:56:57 <Tchakkazulu> You can often get there in a few clicks with hoogle.
10:57:13 <newsham> the online ghc API docs have links to sources, btw  (see the top right hand side)
10:57:50 <bwx> who is the most knowlegdable person of the GHC api who visits this channel?
10:57:57 <DaveCGI609> oh but it would be easier if it was right next to the function name and took me right to the source
10:58:16 <Tchakkazulu> True.
10:58:37 <newsham> dave: yes it would be.
10:58:51 <Tchakkazulu> I'm afraid you'll have to do with a search when looking at the source code.
10:59:08 <DaveCGI609> o well its better then having to grep thru the source tree :)
10:59:18 <newsham> find $srcdir -type f -name '*hs' |xargs grep "$@"      is your friend
10:59:27 <newsham> not if you have the right grep tools
10:59:54 <newsham> make that grep -n, and use vi +lineno filename   and you're half way there
10:59:55 <int-e> why grep when ghci can tell you?
10:59:58 <DaveCGI609> i wouldnt say haskell syntax makes it easy to search for function definitions
11:00:27 <newsham> grep '^elem" *hs
11:00:34 <DaveCGI609> considering there's no "def" keyword or a mandatory type signature
11:00:40 <int-e> elem :: (Eq a) => a -> [a] -> Bool      -- Defined in GHC.List
11:00:47 <int-e> is what ghci says on :i elem
11:01:07 <Tchakkazulu> Yesh, but that still won't give you its source.
11:01:19 <Tchakkazulu> Knowing the module is a big help, though.
11:01:23 <int-e> (my next command is usually 'x GHC/List' where x is a nice little wrapper around locate and less - but there are many ways to go from there)
11:01:23 <DaveCGI609> int-e why doesnt it say line # :)
11:01:27 <newsham> if you're a good little programmer and define your functions at the start of the line...
11:01:39 <newsham> then grep iwth the start-of-line anchor is sufficient
11:02:06 <int-e> there's also a speed advantage.
11:02:10 <newsham> int-e: now add to your wrapper a grep -n and a vi +linenumber
11:02:30 <newsham> (or less +linenum)
11:02:49 <int-e> newsham: wouldn't help in my case.
11:02:56 <int-e> newsham: ymmv :)
11:03:21 <newsham> inte: why not?
11:03:51 <int-e> newsham: because I'd change the place where I type the function name again - I type it twice anyway.
11:04:02 <int-e> newsham: I haven't wrapped the ghci lookup part.
11:04:02 <Cale> mathias_: The complaint stems from the fact that the s in the type of AX doesn't necessarily match the s in the type of the do-block as a whole.
11:04:04 <newsham> btw, if you use the acme editor system, you can just click on filename:linenum that grep -n gives you and it will open that file at that line
11:04:37 <Cale> mathias_: (the s in the return type matches the s in the type of AX though)
11:04:50 <DaveCGI609> are there detailed tutorials on lazy patterns. im not sure i really understand it
11:04:54 <Cale> mathias_: Hopefully that helps :)
11:05:15 <mathias_> Cale, yes, I understand that they don't need to be equal. I don't understand why it looks at ST RealWorld and says that ST s matches.
11:05:19 <Cale> DaveCGI609: It just does the pattern match when one of the bound variables is needed.
11:05:25 <DaveCGI609> can you pattern match against multiple lazy patterns in one case statement?
11:05:29 <Cale> no
11:05:37 <Cale> lazy patterns always succeed
11:05:37 <int-e> mathias_: the ST RealWorld comes from the type of stToIO
11:05:38 <bwx> @seen dcoutts
11:05:38 <lambdabot> I saw dcoutts leaving #ghc, #gentoo-haskell and #haskell 19h 6m 25s ago, and .
11:05:56 <DaveCGI609> oh ... that makes a little more sense
11:06:04 <mathias_> int-e, I said that a few minutes ago already.
11:06:06 <DaveCGI609> so why it is useful that they always succeed
11:06:24 <int-e> mathias_: but the type checker doesn't have enough information to fix your instance of A (unless the code has changed significantly in the last 3 hours)
11:06:38 <Cale> (the failure, if any, comes when you try to use one of the values you bound and the pattern hadn't matched)
11:06:53 <Cale> It delays the evaluation of the thing being matched against
11:07:08 <DaveCGI609> sure... why is it useful in practice i mean
11:07:14 <Tchakkazulu> I think it helps with memory management.
11:07:40 <Tchakkazulu> If you have some seriously HUGE datatype that you want to match against.
11:08:00 <Tchakkazulu> case a of (HugeThing a b c) -> 5
11:08:02 <Cale> It's useful when infinite data structures are being defined recursively.
11:08:12 <int-e> > fix (\ ~(x:xs) -> 1 : (2+x) : xs)
11:08:14 <lambdabot>  [1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
11:08:24 <mathias_> int-e, the type checker knows that it needs to have an instance with ST RealWorld in it. I don't see why it doesn't use the ST s instance by substituting s with RealWorld
11:08:27 <Tchakkazulu> Ooooh.
11:08:46 <DaveCGI609> @src fix
11:08:46 <lambdabot> fix f = let x = f x in x
11:08:52 <mathias_> int-e, because of the functional dependency
11:09:11 <Tchakkazulu> Anyway, it probably saves a matching step when you use "case a of ~(HugeThing a b c) -> 5", or am I being completely wrong here?
11:09:23 <int-e> DaveCGI609: lazy patterns allow you to make assertions about the shape of values that you calculate later (or, in some cases, not at all)
11:09:37 * Tchakkazulu is not very good with fix-things.
11:09:41 <Cale> > let fibs@(_:fibs') = 0 : 1 : zipWith (+) fibs fibs' in fibs
11:09:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:09:59 <Cale> That's actually a lazy match, because it's a pattern binding, and those are always lazy.
11:10:26 <DaveCGI609> when youre defining functions , are the arguments lazily matched?
11:10:33 <Cale> (though of course, you can just use tail instead)
11:10:43 <int-e> mathias_: there is no functional dependency that allows it to infer anything from just m - if http://hpaste.org/2173 is still current.
11:10:48 <Tchakkazulu> If they're variables, then yes.
11:11:09 <Cale> Not usually -- if you're matching against a pattern that might not match, it will force the evaluation one step.
11:11:32 <mathias_> int-e, thank you for pointing that out.
11:11:33 <Cale> (always just enough to determine if the pattern matches or not)
11:11:45 <mathias_> int-e, I had something else in mind, which was obviously wrong.
11:12:05 <Cale> But lazy patterns always "match", so no evaluation gets done until absolutely necessary.
11:12:12 <opqdonut> :/
11:12:41 <Cale> For instance,
11:12:47 <mathias_> Cale, now, for a more complicated question, can I give a partial type signature, expressing only that those s and s1 are the same?
11:13:14 <Cale> mathias_: I think I gave the smallest possible one in my example.
11:13:35 <Cale> null [] = True
11:13:39 <Cale> null (x:xs) = False
11:14:06 <Tchakkazulu> > let test (x:xs) = 5 in test undefined
11:14:07 <lambdabot>  Undefined
11:14:11 <Cale> When (null v) is evaluated, v will be evaluated up to the point where the top-level constructor is determined
11:14:15 * SamB is trying to figure out a nice way to make a search tree for a digital comparison lattice
11:14:16 <Tchakkazulu> >let test ~(x:xs) = 5 in test undefined
11:14:25 <Tchakkazulu> > let test ~(x:xs) = 5 in test undefined
11:14:26 <lambdabot>  5
11:14:50 <monochrom> The more striking part is test [].
11:15:04 <Cale> > let test ~(x:xs) = 5 in test []
11:15:05 <lambdabot>  5
11:15:11 <mathias_> > let test a@(x:xs) = 5 in test undefined
11:15:12 <lambdabot>  Undefined
11:15:31 <mathias_>  > let test a@(x:xs) = 5 in test undefined
11:15:44 <mathias_> > let test a@(x:xs) = 5 in test undefined
11:15:45 <lambdabot>  Undefined
11:16:01 <DaveCGI609> hmm lists are monasd?
11:16:15 <Tchakkazulu> It'll still try to bind x and xs to the head and tail of undefined.
11:16:21 <Cale> DaveCGI609: yeah, the type constructor for lists is a monad.
11:16:25 <mathias_> Why didn't lambdabot respond?
11:16:35 <Cale> mathias_: it did
11:16:42 <Tchakkazulu> It missed once.
11:16:43 <mathias_> > let test a@(x:xs) = 5 in test undefined
11:16:44 <lambdabot>  Undefined
11:16:55 <DaveCGI609> how do i input multi-line statements in ghci
11:17:00 <mathias_> Now, it works a bit faster
11:17:07 <Cale> DaveCGI609: By separating them with ;
11:17:07 <mathias_> DaveCGI609, you don't. Use ;
11:17:20 <monochrom> If you go "test ~(x:xs) = ... something that really uses x or xs" the evaluation will occur later. If you go "test []" an error will occur later.
11:17:24 <Cale> DaveCGI609: This is why you put everything in a file :)
11:17:53 <Cale> DaveCGI609: The standard working environment is to keep both your text editor and ghci/hugs open at all times
11:18:02 <mathias_> > let test a@~(x:xs) = 5 in test undefined
11:18:02 <lambdabot>  Parse error in pattern
11:18:03 <Cale> and use :r in ghci/hugs whenever you save the file
11:18:31 <Cale> That way you put all your declarations into the file, rather than awkwardly trying to define them on the commandline.
11:18:36 <Tchakkazulu> > let test ~a@(x:xs) = 5 in test undefined
11:18:37 <lambdabot>  5
11:20:40 <DaveCGI609> hrm, list monads are confusing
11:23:21 <int-e> > replicateM 4 "01"
11:23:22 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
11:23:31 <qwe1234> this is why you should stick to a better language
11:23:39 <sjanssen> DaveCGI609: there is only one list Monad
11:23:40 <sjanssen> whoa
11:23:41 <DaveCGI609> cooool, binary
11:23:47 <SamB> qwe1234: what in the world are YOU doing HERE?
11:23:52 <sjanssen> is this the famous qwe1234?
11:24:02 <qwe1234> infamous rather
11:24:02 <DaveCGI609> ooh, trolls
11:24:06 <qwe1234> know thy enemy
11:24:13 <DaveCGI609> whats a better language? lisp?
11:24:19 <qwe1234> c++ of course
11:24:20 <SamB> wait a minujte
11:24:29 <qwe1234> (sorry, just foolin around)
11:24:31 <mathias_> qwe1234, I am thinking of switching to VB.NET!!!!!! You said it was GREAT, so this must be TRUE!!
11:24:33 <SamB> your username is kjdf!
11:24:47 <DaveCGI609> C# is better than vb.net
11:25:20 <DaveCGI609> ok i think im confused about how the "do..." syntax gets desugared
11:25:20 <kjdf> nice having some attention though
11:25:44 <DaveCGI609> "do x; y" gets desugared into x >>= y i know
11:25:56 <sjanssen> DaveCGI609: play around with @undo
11:25:57 <int-e> x >> y
11:25:59 <DaveCGI609> but what about when you throw in a <- b ?
11:26:10 <sjanssen> @undo do x; y; a <- b; print a
11:26:10 <lambdabot> x >> y >> b >>= \ a -> print a
11:26:16 <Cale> That's where >>= gets used
11:26:19 <mathias_> It's a rather stupid troll. You just broadcasted lots of information about your identity.
11:26:29 <Cale> do { x } --> x
11:26:37 <Cale> do { x ; <stmts> } --> x >> do { <stmts> }
11:26:45 <Cale> do { v <- x ; <stmts> } --> x >>= \v -> do { <stmts> }
11:27:09 <Cale> do { let { <decls> } ; <stmts> } --> let { <decls> } in do { <stmts> }
11:27:20 --- mode: ChanServ set +o glguy
11:27:21 <Cale> Is the basic rule
11:27:29 <sjanssen> wrong :)
11:27:36 <DaveCGI609> so its all nested dos
11:27:38 <Cale> sjanssen: ssh
11:27:42 <glguy> bah, switch back, kjdf
11:28:00 <shachaf> sjanssen: You mean the fail on bad pattern match?
11:28:28 <sjanssen> shachaf: right
11:28:41 <sjanssen> @undo do (Just x) <- a; print x
11:28:42 <lambdabot> a >>= \ b -> case b of { (Just x) -> print x; _ -> fail ""}
11:28:49 <DaveCGI609> @undo do a <- b; c <- d; e
11:28:50 <lambdabot> b >>= \ a -> d >>= \ c -> e
11:29:25 <DaveCGI609> is there an option that puts parentheses in proper places ?
11:29:34 <DaveCGI609> like f x y -> (f x) y
11:29:50 <DaveCGI609> (((f) x) y)
11:30:05 <sjanssen> DaveCGI609: no, but it'd be really handy
11:31:07 <DaveCGI609> interesting
11:31:09 <Saizan>  b >>= \ a -> d >>= \ c -> e can either be  b >>= (\ a -> d) >>= (\ c -> e) or  b >>= (\ a -> d >>= (\ c -> e)) in this case, and they are equal because of the third law
11:31:24 <shachaf> It would be even wronger if that (<- ...) idea was implemented.
11:31:30 <DaveCGI609> are all of the variable bindings in a "do" using the a <- b syntax valid lower in the do statement?
11:31:32 <int-e> > (unwords ((:) "Haskell" ((:) "is" ((:) "Lisp" []))))
11:31:33 <lambdabot>  "Haskell is Lisp"
11:31:46 <Saizan> DaveCGI609: yes
11:31:57 <DaveCGI609> what if you dont want that
11:32:15 <Saizan> you can use a nested do
11:32:27 <DaveCGI609> oh ok
11:32:33 <DaveCGI609> like a do followed by another do?
11:32:52 <Saizan> a do that has a do { ... } as one expression
11:33:08 <DaveCGI609> @undo do x do y
11:33:08 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
11:33:16 <DaveCGI609> @undo do x; do y
11:33:16 <lambdabot> x >> y
11:33:20 <int-e> > (do do do not) False
11:33:22 <lambdabot>  True
11:33:33 <DaveCGI609> @undo (do do do not) False
11:33:33 <lambdabot> (not) False
11:33:49 <DaveCGI609> @undo do do not
11:33:49 <lambdabot> not
11:33:59 <DaveCGI609> is there @undo in ghci?
11:33:59 <int-e> that's a trivial nested do - and completely useless
11:34:20 <DaveCGI609> @undo do (do x); (do y);
11:34:20 <lambdabot> (x) >> (y)
11:34:25 <sjanssen> DaveCGI609: no
11:34:34 <shachaf> @wher goa
11:34:35 <lambdabot> Maybe you meant: where where+
11:34:38 <shachaf> @where goa
11:34:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
11:34:39 <int-e> @undo do (do x; y); (do a; b)
11:34:40 <lambdabot> (x >> y) >> (a >> b)
11:34:53 <shachaf> @undo do x; y; a; b
11:34:53 <lambdabot> x >> y >> a >> b
11:34:58 <Saizan> > do x <- do { y <- Just 1; return (y+1) }; y -- not in scope
11:34:59 <lambdabot>   Not in scope: `y'
11:35:05 <Saizan> > do x <- do { y <- Just 1; return (y+1) }; x
11:35:06 <lambdabot>   add an instance declaration for (Num (Maybe t))
11:35:08 <DaveCGI609> @undo do a <- (do x; y); b <- (do a; b)
11:35:08 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
11:35:14 --- mode: glguy set -o glguy
11:35:19 <Saizan> > do x <- do { y <- Just 1; return (y+1) }; return x
11:35:20 <lambdabot>  Just 2
11:35:23 <DaveCGI609> @undo do a <- (do x; y); b <- (do x1; y1)
11:35:23 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
11:36:05 <DaveCGI609> @undo x <- do { y <- Just 1; return (y+1) }; return x
11:36:05 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
11:36:11 <Toxaris> > do { do { x <- [1, 2, 3]; return x} ; return 42 }
11:36:13 <lambdabot>  [42,42,42]
11:36:24 <DaveCGI609> not those damn list monads again
11:36:31 <Toxaris> @undo do { do { x <- [1, 2, 3]; return x} ; return 42 }
11:36:31 <lambdabot> [1, 2, 3] >>= \ x -> return x >> return 42
11:37:00 <Tchakkazulu> DaveCGI609: Do you know about list comprehensions? They helped me with understanding how the list monad works.
11:37:13 <DaveCGI609> yeah i have a mild understanding of those
11:37:22 <Toxaris> hmm. @undo doesn't show the unavailability of x after the nested do
11:37:46 <Tchakkazulu> > [a + 1 | a <- [1..10]]
11:37:47 <int-e> > filterM (const [False ..]) "abc"
11:37:47 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
11:37:48 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
11:38:05 <Tchakkazulu> In monad form, that'd translate to:
11:38:17 <Tchakkazulu> do { a <- [1..10]; return (a + 1)}
11:38:20 <sjanssen> Toxaris: oh? In which test?
11:38:21 <Tchakkazulu> > do { a <- [1..10]; return (a + 1)}
11:38:22 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
11:38:34 <Tchakkazulu> I hope that helps a bit :)
11:38:45 <Toxaris> sjanssen: @undo do { do { x <- [1, 2, 3]; return x} ; return 42 }
11:38:46 <DaveCGI609> that do desugaring is confusing the hell out of me
11:38:57 <Toxaris> @undo do { do { x <- [1, 2, 3]; return x} ; return 42 }
11:38:57 <lambdabot> [1, 2, 3] >>= \ x -> return x >> return 42
11:39:09 <Toxaris> @undo do { x <- [1, 2, 3]; return x; return 42 }
11:39:09 <lambdabot> [1, 2, 3] >>= \ x -> return x >> return 42
11:39:13 <sjanssen> @undo do { do { x <- [1, 2, 3]; return x} ; return 42 }
11:39:14 <lambdabot> [1, 2, 3] >>= \ x -> return x >> return 42
11:39:26 <sjanssen> Toxaris: it's a bug in the pretty-printer, I think
11:39:36 <sjanssen> it doesn't know about associativity
11:39:45 <DaveCGI609> is that (\x -> return x) >> return 42
11:39:52 <DaveCGI609> or (\x -> (return x >> return 42)) ?
11:40:13 <int-e> the latter
11:40:42 <sjanssen> DaveCGI609: it should be "([1, 2, 3] >>= \x -> returnx) >> return 42"
11:40:43 <DaveCGI609> >> binds tighter than -> ?
11:40:53 <int-e> hmm but you're right, @undo should add a parenthesis in the case of the nested do
11:40:59 <shachaf> DaveCGI609: -> isn't an operator.
11:41:01 <sjanssen> DaveCGI609: the output that @undo gave was slightly incorrect
11:41:17 <shachaf> DaveCGI609: It's syntax, part of the lambda.
11:41:20 <DaveCGI609> schaf: doesnt matter, i meant during the parsing stage
11:41:30 <int-e> @undo do { x <- a; do { x <- b }; return x } -- incorrect
11:41:30 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
11:41:43 <Toxaris> > [(- 1), (+ 1)] <*> [10, 20, 30, 40] -- applicative available?
11:41:44 <lambdabot>   add an instance declaration for (Num (a -> a))
11:41:44 <lambdabot>     In the expression: (- 1)
11:41:51 <int-e> @undo do { x <- a; do { x <- b; return x }; return x }
11:41:51 <lambdabot> a >>= \ x -> b >>= \ x -> return x >> return x
11:41:56 <Gwern-away> this is confusing. I can System.Posix.User.setUserID to 1000, my own userid, but nothing else apparently
11:42:18 <babu> I have a question regarding class and instances
11:42:33 <monochrom> If you run the program with higher privilege, you can seUserID to others.
11:42:34 <dolio> > [subtract 1, (+ 1)] <*> [10, 20, 30, 40]
11:42:36 <lambdabot>  [9,19,29,39,11,21,31,41]
11:42:50 <int-e> should really be a >>= \ x -> b >>= (\ x -> return x) >> return x
11:43:09 <Tchakkazulu> What's this <*> operator?
11:43:14 <Gwern-away> monochrom: I suppose so. it seems odd that as a regular user I can't drop down to nobody
11:43:32 <Toxaris> Tchakkazulu: it's like Control.Monad.ap, but more general
11:43:40 <Tchakkazulu> @type ap
11:43:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:43:46 <Tchakkazulu> @type <*>
11:43:47 <lambdabot> parse error on input `<*>'
11:43:53 <Tchakkazulu> @type (<*>)
11:43:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:44:04 <Tchakkazulu> Ahh, okay :)
11:44:18 <Tchakkazulu> And Monad m => Applicative f, right?
11:44:32 <Tchakkazulu> And <*> === ap in case of Monads.
11:44:32 <monochrom> the unix CPO of privilege is almost flat. root vs everybody else. you are not considered to be higher than nobody.
11:44:55 <DaveCGI609> nobody is just a user
11:45:06 <DaveCGI609> which happens to have sucky groups
11:45:31 <Gwern-away> well, that makes things difficult. I was hoping to sudo to root, drop down to regular user, and then down to nobody, so I had layers of increasingly less trusted IO actions and functions
11:45:34 <monochrom> It is an external setup and convention to give nobody an account with no shell, no access, no nothing. but the kernel doesn't know this.
11:45:57 <DaveCGI609> run as root, drop down to a regular user, do what you need, go back to root, drop down to nobody permanently
11:46:34 <Toxaris> Tchakkazulu: yes, i think so. It's very handy syntax for inlining monadic actions
11:46:48 <monochrom> Some other OSes implement "access control lists" which gives you a full lattice of privileges.
11:46:55 <Toxaris> Tchakkazulu: so I wonder why everyone is so excited about the proposed (<- action) syntax
11:47:22 <Tchakkazulu> Yes, that's ugly :(
11:47:46 <dolio> Because of *p++ = *q++, of course.
11:47:54 <Gwern-away> I don't understand the whole debate myself. there's a lot of niggling details people are discussing but the motive for the whole thing is unclear.
11:48:04 <Gwern-away> dolio: and is that C? what does that have to do with haskell
11:48:12 <Tchakkazulu> And the whole "f (<- action) (<- action)" versus "let x = (<-action) in f x x"
11:48:27 <DaveCGI609> i hate that! why does remembering operator precedence imply C mastery
11:48:36 <dolio> Gwern-away: I don't know. You'd have to ask Bulat. I'm sometimes not sure what point he's making.
11:48:52 <monochrom> Haha
11:48:59 <Toxaris> :) but it's very important for real-world programming
11:48:59 <Gwern-away> DaveCGI609: I guess so. I've discovered that apparently you need to change the GID before the UID because otherwise you lose the privileges needed
11:49:15 <Gwern-away> getting pretty complex. I wonder if there is a chroot binding?
11:49:30 <DaveCGI609> Gwern-away run your program in chroot? :)
11:49:49 <monochrom> I skip all messages on f (<- action)
11:50:16 <int-e> Tchakkazulu: oh I didn't follow that thread - has anybody asked about let x = (<- x) or something equivalent yet?
11:50:25 <Gwern-away> DaveCGI609: I'm reading through stuff on privilege separation at dons' suggestion, and a lot of them are suggesting chrooting to /var/empty
11:50:36 <Tchakkazulu> int-e: Infinite type, much?
11:50:53 <dolio> int-e: Yeah, ndm asked about that and other similar things.
11:51:04 <int-e> Tchakkazulu: well, x = (<- f x) for a suitable f then.
11:51:50 <int-e> ok, good.
11:51:59 <DaveCGI609> ugh.. the gentle introduction to monads is not so gentle once it starts using state monads to make another monad
11:52:00 <Tchakkazulu> Heh, that kind of self-recursive things are tricky anyway.
11:52:06 <dolio> I'm not sure I like the answer, though. :)
11:53:04 * int-e tries to decide whether to hold his breath while Hugh Perkins revolutionizes the parallel computing world :)
11:53:16 <dolio> Hehehe.
11:53:20 <Gwern-away> int-e: is he the fellow going 'oh it's easy'?
11:53:31 <int-e> yes
11:53:43 <Gwern-away> I found his overhead assertion particularly funny
11:54:30 <glguy> DaveCGI609: Are you having trouble with anything in particular
11:54:42 <Gwern-away> gah. seriously though, is there a haskell binding for chroot() ?
11:54:48 <Cale> Sorry, had to run out for a bit
11:55:18 <desp> @ping
11:55:22 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","PhD Student","ATP  Australian Technology Park","","lilia"
11:55:22 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","56908","nahmed"
11:55:22 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
11:55:22 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
11:55:22 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
11:55:24 <lambdabot> [329 @more lines]
11:55:33 <Cale> sjanssen: The reason I leave out pattern match failure in initial descriptions, is because if I leave it in, I either have to really lie, or else complain a bunch about how much fail sucks.
11:55:37 <dolio> What the...
11:55:41 <desp> o-O
11:55:46 <desp> @ping
11:55:47 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","PhD Student","ATP  Australian Technology Park","","lilia"
11:55:47 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","56908","nahmed"
11:55:47 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
11:55:47 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
11:55:47 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
11:55:49 <lambdabot> [329 @more lines]
11:55:50 <desp> hah.
11:55:52 <basti_> o.o
11:55:58 <glguy> its the unsw phone directory
11:56:08 <glguy> typing it again will just continue to flood the channel ;)
11:56:15 <desp> pardon
11:56:18 <Gwern-away> isn't that where dons goes? an odd feature to add
11:56:25 <Tchakkazulu> system "chroot" -_-
11:56:47 <glguy> heh, seems like a particularly useful feature of the author of a bot to write for himself
11:56:57 <Gwern-away> Tchakkazulu: great. didn't know about 'system'
11:57:14 <Tchakkazulu> Not sure if it works the way you want, though.
11:57:29 <glguy> system "chroot" would create a chroot and start a new process in it
11:57:30 * Gwern-away will test and see
11:57:30 <Cale> I propose that absolutely nothing be done about the (<- x) thing :)
11:57:38 <Tchakkazulu> The -_- was to indicate that it was an ugly hack, rather than a nifty solution.
11:57:39 <dolio> @ping stewart
11:57:39 <lambdabot>   CSE	 : "Stewart","Donald","PhD Student","K17 501-16","57225","dons"
11:58:14 <Gwern-away> Tchakkazulu: oh. I thought it was at my ignorance
11:58:31 <Tchakkazulu> Heh, no ;)
11:58:36 <roconnor> CSE? comons subexpression elimination?
11:58:55 <dolio> Computer Science/Engineering?
11:59:02 <Cale> roconnor: dolio got it
11:59:07 <monochrom> They have a whole department doing CSE! XD
12:00:16 <lament> does anyone actually use the yi editor?
12:01:03 <hpaste>  babu pasted "Error when trying to use an operator in a new class" at http://hpaste.org/2176
12:01:39 <Cale> @type truncate
12:01:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:01:56 <Cale> It's complaining that it doesn't know which Integral type you want to compare.
12:01:57 <Tchakkazulu> But:
12:01:57 <Tchakkazulu> @type 3.5
12:01:59 <lambdabot> forall t. (Fractional t) => t
12:02:26 <Cale> doing something like  truncate a == (truncate b :: Integer)
12:02:31 <Cale> would do it
12:03:05 <Tchakkazulu> And you may want to add explicit type signatures to the 3.5 and 4.5.
12:03:16 <Tchakkazulu> It also doesn't know what Fractional type you want to use.
12:03:20 <Cale> oh, that too
12:04:06 <Cale> Ah, I suppose it *might* default the truncates to Integer already
12:04:15 <babu> But the built in == operator in Eq class is defined similarly and 3.5 == 4.5 works. Why do I need to add type signatures
12:04:17 <Cale> I'm not 100% sure about that though :)
12:04:34 <Cale> babu: because of numeric defaulting
12:04:36 <Tchakkazulu> Because (==) is defined in Eq, and every Num type is also an Eq type.
12:04:51 <Tchakkazulu> And every Fractional type is also a Num type, and therefore an Eq type...
12:05:04 <Cale> Which only works when only Prelude type classes are present :/
12:05:07 <Tchakkazulu> Hmm... That still doesn't explain a thing, sorry :-/
12:05:13 <Gwern-away> system "chroot(/var/empty)" ->  /bin/sh: -c: line 0: syntax error near unexpected token `/var/empty'
12:05:25 <monochrom> When you write "3.5", it defaults to Double.
12:05:39 <Tchakkazulu> system "thing" acts like if you type "thing" in a console.
12:05:48 <monochrom> You only have Myeq Float. Eq has Eq Double too.
12:05:57 <Cale> But only if the only typeclass constraints on it are typeclasses which are in the Prelude.
12:06:04 <DaveCGI609> how does haskell handle traditional OO things like virtual functions?
12:06:09 <hpaste>  int-e pasted "using FFI for chroot" at http://hpaste.org/2177
12:06:09 <Gwern-away> Tchakkazulu: I see. so it's not calling the actual chroot() but man 1 chroot
12:06:25 <Cale> DaveCGI609: I suppose typeclasses.
12:06:28 <monochrom> Nevermind. Cale's is a truer cause.
12:06:41 <int-e> Gwern-away: hope that helps. I didn't find a ready to use binding in the libs.
12:06:48 <DaveCGI609> ok but can you have multiple levels of inheritance in type classes ?
12:07:09 <Cale> DaveCGI609: yes, but the inheritance is only half of what it means in OO
12:07:18 <babu> I added another instance replacing Float with double and now 3.5 =@ 4.5 works.
12:07:23 <Cale> It's the constraint half without the auto-implementation half.
12:07:26 <Gwern-away> int-e: every bit helps. I would not have thought of trying the FFI since I know so little about C and the FFI in general
12:07:42 <Cale> Man, people are really finding all the little annoying warts in the spec today. :)
12:08:00 <Cale> babu: oh, that's interesting, and good to know :)
12:08:06 <monochrom> I retract my nevermind. Mine is also a cause.  instance Myeq Double ...  solves the problem.
12:08:33 <babu> Yes. You sais Eq has Double too and so I tried it
12:08:44 <DaveCGI609> Cale: type classes let you provide default definitions no?
12:08:50 <int-e> Gwern-away: I guess you should check the return code of the chroot call, too, i.e.  error <- withCString "/tmp" chroot; if error /= 0 then fail else do stuff
12:09:07 <Cale> DaveCGI609: yes, for individual methods in the class declaration.
12:09:29 <DaveCGI609> the only thing is, type classes are too much like OO absract classes.. and you cant inherit directly from a type class instantiation
12:09:37 <Cale> DaveCGI609: But you're not permitted to define default implementations for superclass methods.
12:09:41 <int-e> Gwern-away: hum, the "/tmp" comes from testing locally :)
12:09:47 <monochrom> Haskell type inference is complex.
12:09:58 <Cale> You can write:
12:10:10 <Cale> class (Eq a) => Ord a where
12:10:11 <Cale>  ...
12:10:23 <Cale> Which makes Ord a subclass of Eq.
12:10:31 <Gwern-away> int-e: I'll think about that once it compiles. for some reason,/home/gwern/tmp.hs:5:8: parse error on input `import'
12:10:36 <DaveCGI609> i like functional programming, but i want coding to be easy too.. how do i release all the years of OO knowledge i have to dive into haskell
12:10:46 <int-e> Gwern-away: you need to pass -ffi to ghc
12:10:54 <Gwern-away> but it looks exactly like http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3 the import declaration should. hmm
12:10:56 <lambdabot> Title: 3 Foreign Declarations, http://tinyurl.com/yezf7t
12:10:57 <Cale> But all that does is forces people to define an instance of Eq whenever they define an instance of Ord
12:11:08 <Tchakkazulu> -fffi, even.
12:11:12 <Gwern-away> int-e: oh. that's a little odd, but ok
12:11:13 <Cale> (they can do it using the stuff from their Ord instance though)
12:11:17 <int-e> Tchakkazulu: both work IIRC
12:11:22 <DaveCGI609> Cale: that's like interfaces in C#. it pisses me off whenever I have to copy&paste code
12:11:24 <Tchakkazulu> Ooh, nifty :)
12:11:26 <monochrom> Both -ffi and -fffi work. Deliberately.
12:11:37 <Tchakkazulu> I can imagine that -ffi is often mistyped :P
12:11:37 <Cale> DaveCGI609: You don't necessarily have to do that.
12:11:44 <Tchakkazulu> All those f's are hard to keep track of.
12:11:49 <DaveCGI609> how would you do it then
12:12:11 <int-e> Gwern-away: in practice I'd put that import in a separate module.
12:12:27 <Cale> DaveCGI609: Well, if you want an Ord instance you do have to write an Eq instance somehow, but that can be made easy.
12:12:48 <Gwern-away> int-e: why?
12:13:01 <monochrom> The rationale behind -fffi is -fglasgow-exts, -farrows, -fthis, -fthat, -ffor_that_reason_this_also
12:13:01 <DaveCGI609> Cale: go on :-)
12:13:03 <Cale> x == y = x <= y && x >= y, for example.
12:13:05 <Cale> or
12:13:21 <Cale> x == y = case compare x y of EQ -> True; _ -> False
12:13:28 <int-e> Gwern-away: for cosmetic reasons mostly, and for reusability
12:13:33 <byorgey> or x == y = False =)
12:13:39 <DaveCGI609> Cale: ok hold on. you are still writing code for superclass , and also you said you cant implement superclass methods
12:14:01 <monochrom> The rationale behind -ffi is clearly everyone is prone to forget the -f<whatever> convention :)
12:14:16 <hpaste>  int-e annotated "using FFI for chroot" with "as a separate module" at http://hpaste.org/2177#a1
12:14:30 <Cale> I am writing code for the superclass -- the superclass constraint in the class decl. for Ord enforces that I do that.
12:14:46 <Gwern-away> oy. this is getting complex. gotta remember to change user and gids in the right order, ascend and descend privileges correctly, hack together some way to use chroot, then I have to think about ulimit and nice. I think I'm going to go to bed. >.<
12:15:06 <Cale> But my examples show that the methods I've already defined for Ord make it easy to define that instance for Eq.
12:15:18 <Cale> (It just doesn't happen automatically)
12:15:41 <Cale> On the one hand, this leads to a little more typing, on the other hand, you don't have that awful diamond problem.
12:15:42 <int-e> Gwern-away: anyway, the main message was, FFI isn't all that scary :)
12:15:55 <DRMacIver> The level of noise that the new/malloc discussion on reddit has generated is really funny. :)
12:16:03 <monochrom> FFI isn't scary. I testify for that too.
12:16:11 <Tchakkazulu> Then something goes wrong in my head.
12:16:18 <Tchakkazulu> Because if you define (<), then (>) is just flip (<)
12:16:25 <DaveCGI609> Cale: well the typinng is the problem isnt it..
12:16:26 <Tchakkazulu> (>=) is not (<)
12:16:38 <Tchakkazulu> and (<=) is flip (>=)
12:16:39 <DaveCGI609> Cale: otherwise people would just use C for OO (templates not-withstanding)
12:16:51 <Tchakkazulu> And then you could define (==) with (<) alone.
12:18:06 <Cale> DaveCGI609: It does save you some typing though -- the compiler will bundle an Eq instance in with each Ord instance, so that functions that have Ord-constrained parameters are allowed to apply Eq operations to them as well without mentioning it.
12:18:30 <monochrom> Tchakkazulu: you are not wrong. Maybe just different from the way the Prelude sets things up, but not wrong. Recall that the Prelude bases the whole thing on GT, LT, EQ, so it's probably just a different perspective.
12:18:34 <Cale> For example, if  sort :: (Ord a) => [a] -> [a] wants to compare two elements for equality, it can do that without any complaints.
12:18:40 <DaveCGI609> Cale yeah sure, for implementing functions using Ord, but i was talking about implementing a type class like Ord
12:19:18 <Cale> Yeah, the place where we differ from most OO-things is that we don't have implementation inheritance of any kind.
12:19:27 <Cale> We have default implementations, but that's it.
12:19:38 <Tchakkazulu> Hmm... I see.
12:19:53 <DaveCGI609> type classes remind me a lot of smalltalk traits
12:19:58 <Cale> It's possible that we need something more in that area, but for the most part this hasn't been a huge problem.
12:20:33 <Tchakkazulu> I think I was confused with Ord defining not just a relation (<), but that (<) also induces a total order.
12:20:42 <DaveCGI609> see here's the thing, im new to haskell and while i understand the theoretical functional programming, i also have years of OO experience. so confused as to how i can combine the two to be a productive haskell programmer
12:20:59 <Cale> There's a proposal called class aliases, which would fix a lot of issues where fine-grained typeclass hierarchies become painful to use.
12:21:14 <DaveCGI609> *especially* if its hard or impossible to use OO hierarchies
12:21:26 <earthy> it's not hard or impossible to use OO hierarchies
12:21:32 <DRMacIver> It's just a bad idea. :)
12:21:37 <Cale> DaveCGI609: I think the best thing is just to ignore OO for quite a while, and try to figure out the functional way to do things.
12:21:38 <earthy> it's just not usually smart to try
12:21:50 <DaveCGI609> maybe it is bad! but can anyone point me to some articles explain why and what should be done instea
12:21:54 <Cale> and how OO fits into the picture will become clearer over time
12:22:08 <monochrom> Oleg has a critique on subclassing.
12:22:15 <DaveCGI609> links please?
12:22:21 <Cale> Really, OO's whole way of doing things is in some sense dual to our way.
12:22:28 <monochrom> http://okmij.org/ftp/Computation/Subtyping/
12:22:30 <lambdabot> Title: Subtyping, Subclassing, and Trouble with OOP
12:22:31 <earthy> DaveCGI609: read http://homepages.cwi.nl/~ralf/OOHaskell/
12:22:32 <lambdabot> Title: Haskell's overlooked object system
12:22:51 <Cale> Actually, you're new to Haskell, might be best not to read that yet :)
12:22:52 <Tchakkazulu> I still don't understand why instance declarations don't accept type synonyms.
12:23:07 <Cale> Tchakkazulu: they do in GHC
12:23:15 <Tchakkazulu> With what flags?
12:23:20 <Cale> -fglasgow-exts
12:23:34 <DaveCGI609> earthy: thats done without extensions or..?
12:23:54 <Tchakkazulu> I want to write "type Compose f1 f2 a = f1 (f2 a); instance (Functor f1, Functor f2) => Functor (Compose f1 f2) where fmap = fmap . fmap"
12:23:55 <Cale> But only if the replacement would produce something that it would accept.
12:23:57 <kjdf> Cale: could you elaborate a bit?
12:24:04 <Cale> Tchakkazulu: that won't work.
12:24:15 <kjdf> Cale: or did you just mean the link that monochrome pasted?
12:24:22 <Cale> kjdf: elaborate on what?
12:24:23 <earthy> DaveCGI: the OOHaskell descriptive paper describes how far you can get without using any extensions
12:24:25 <DaveCGI609> at least 1 issue i see is that there are no protected/private methods
12:24:32 <Tchakkazulu> Heh, I have found that out. It'd be nifty, though.
12:24:34 <Cale> DaveCGI609: Modules.
12:24:48 <kjdf> Cale: on how OO fits into the picture
12:24:58 <Cale> Okay
12:25:00 <DaveCGI609> Cale: yeah but how would i define a protected method in a type class that all subclasses can use?
12:25:02 <Tchakkazulu> fmap . fmap is the right type, and it just works if you type "data Compose f1 f2 a = Comp (f1 (f2 a))".
12:25:15 <Tchakkazulu> Of course, you have to unwrap and wrap the Comp constructor, and that's a pain.
12:25:37 <Cale> DaveCGI609: It's best to really think of typeclasses and OO as mostly unrelated.
12:26:01 <Cale> Let me elaborate a bit on how OO fits in :)
12:26:10 <DaveCGI609> yeah but then how am i supposed to get the intuition for how to code properly
12:26:16 <DaveCGI609> i already have tons of OO intuition is what im saying
12:26:19 <Cale> OO does a lot with what we'd call existentially quantified types.
12:26:50 <shachaf> DaveCGI609: How would "a protected method in a type class that all subclasses can use" make sense?
12:27:06 <Cale> That is, a lot of the time, when you're working in an OO program, you're working with values for which you know there exists a type (satisfying certain properties) that the value has.
12:27:12 <Cale> But you don't actually know its type.
12:27:16 <DaveCGI609> shachaf: state accessors?
12:27:37 <Cale> That's what happens when you upcast values.
12:27:43 <Cale> Right?
12:27:56 <DaveCGI609> yes
12:27:57 <Cale> You know that they belong to some subclass of the class in question
12:28:00 <shachaf> DaveCGI609: Who would be able to call them?
12:28:05 <Cale> You've just forgotten which one.
12:28:18 <Cale> And hence you know that they implement the methods of the base class
12:28:26 <DaveCGI609> shachaf: the subclass impls?
12:28:40 <Cale> In functional programming, we tend to do this completely in reverse.
12:28:53 <DaveCGI609> shachaf: it only be useful if you didnt have to  implement the protected methods in the same place as the subclass i guess
12:29:26 <monochrom> Haha, I care about the type but not the value!
12:29:31 <Cale> We work with universally quantified types -- that is, we write functions which work *no matter which type* something is, provided that it's subject to possibly some constraints.
12:30:13 <Cale> It's a funny distinction.
12:31:00 <DaveCGI609> Cale: sounds a lot like C# generics
12:31:12 <Cale> That's exactly what C# generics are, yes.
12:31:20 <Cale> They stole it from us :)
12:31:44 <DaveCGI609> too bad the C# type inferencing sucks compared to haskell
12:31:49 <Cale> Now, GHC has existential types, which let you forget which type of thing is wrapped up in them, apart from the fact that it belongs to some typeclass.
12:32:15 <Cale> The reason C#'s type inference sucks compared to Haskell is that it has subtype polymorphism.
12:32:34 <Cale> Which breaks type inference badly (or at least makes it horribly expensive)
12:33:23 <Cale> Haskell's existential types allow you to get a little bit of that effect without harming type inference *too* badly.
12:33:37 <DaveCGI609> haskell has exisrtential types?
12:33:43 <Cale> GHC does.
12:33:51 <DaveCGI609> like mvars ?
12:34:14 <Cale> nope
12:34:38 <Cale> like...
12:34:52 <Cale> data Showable = forall a. (Show a) => S a
12:35:06 <shachaf> Cale: Is the forall required?
12:35:19 <Cale> excuse the funny use of forall, yes, it is required, unless you're using GADT syntax
12:35:28 <Cale> I suppose the new syntax for that is;
12:35:38 <Cale> data Showable where S :: (Show a) => a
12:35:41 <Cale> er
12:35:44 <Cale> data Showable where S :: (Show a) => a -> Showable
12:35:56 <Tchakkazulu> O_O
12:35:59 <Tchakkazulu> That... works?
12:36:04 <DaveCGI609> huh...
12:36:13 <Tchakkazulu> Wow, I'm not really aware of GHCs nifty features.
12:36:19 <Cale> That is, S takes a value of type a, so long as it's something in the Show class, and *forgets* what type it was.
12:36:34 <Cale> And produces a value of type Showable
12:36:43 <DaveCGI609> why is that useful ?
12:36:44 <Cale> You can later pattern match
12:36:49 <Cale> case foo of
12:36:53 <Cale>   (S x) -> ...
12:37:01 <shachaf> Cale: Where would it normally go?
12:37:10 <DaveCGI609> you can pattern match even though it "forgot" its type?
12:37:14 <Cale> and the only thing you'll be allowed to assume about x is that it's of some type in the Show class
12:37:20 <Tchakkazulu> So... let's see if I get this.
12:37:25 <psykotic> DaveCGI609, it basically packages up the dictionary for Show.
12:37:28 <Tchakkazulu> I'll be able to make a [Showable], and show that?
12:37:32 <Cale> yes
12:37:39 <Cale> instance Show Showable where
12:37:43 <Cale>   show (S x) = show x
12:37:47 <Cale> then
12:37:51 <Tchakkazulu> And then basically have a list with Ints, Strings, Chars, Whatevers, as long as they can be shown.
12:37:57 <Cale> show [S 5, S "Hello", S [1,2,3]]
12:38:00 <Cale> that'll work :)
12:38:08 <DaveCGI609> hey neat.. isnt that a lot like OO
12:38:12 <psykotic> yes
12:38:12 <Cale> They have to be wrapped up in S's of course
12:38:14 <Tchakkazulu> Well... after defining instance Show Showable, but yes :)
12:38:15 <shachaf> Cale: Why is the data type necessary?
12:38:22 <Cale> yes, that's exactly like upcasting in OO
12:38:23 <Tchakkazulu> Wow, that's cool :)
12:38:34 <DaveCGI609> i thought youre not supposed to do that stuff in Haskell
12:38:39 <Cale> shachaf: because it's what carries around the Show methods for you
12:38:41 <int-e> Show isn't the most useful type class to do that with, but it illustrates the idea nicely.
12:38:42 <psykotic> of course you are.
12:39:03 <Cale> Let's look at another thing we could do though...
12:39:04 <psykotic> DaveCGI609, it's not substantially different from passing around a function, in this case.
12:39:04 <Tchakkazulu> Heh, yes. The Show typeclass is easily understood :)
12:39:18 <monochrom> showtime!
12:39:27 <Cale> We could also just pass around the result of applying show to the things.
12:39:36 <DaveCGI609> hmm yes
12:39:39 <Cale> That is, strings.
12:39:46 <DaveCGI609> but that is eww
12:39:52 <Tchakkazulu> map show [S 5, S "Hello", S [1,2,3]]
12:39:57 <Cale> It's not really all that bad in this case.
12:40:06 <Cale> In fact, it's what you're far more likely to do.
12:40:30 <Cale> In general, if we have a typeclass and an existential type, we can always do this.
12:40:45 <Tchakkazulu> data Readable where R :: Read a => a -> Readable
12:40:45 <byorgey> but you could imagine a case where applying show (or whatever) would produce ginormous amounts of data and you're only going to end up needing one of them...
12:40:48 <psykotic> this specific use case of existentials is more convenience than something that adds expressive power.
12:40:53 <Cale> We can effectively pass around a record of functions for that typeclass.
12:41:12 <Cale> But specialised to the value that we'd otherwise have wrapped up.
12:41:26 <Cale> byorgey: It's lazy.
12:41:43 * byorgey smacks forhead
12:41:44 <Cale> Tchakkazulu: That's a useless existential. :)
12:41:46 <byorgey> of course =)
12:42:00 <Cale> er...
12:42:00 <DaveCGI609> interesting intersting
12:42:02 <Cale> yeah
12:42:35 <Tchakkazulu> I'm not sure if I'll find practical uses for it (though there sure are), but I shall play around with it for a while :)
12:42:41 <Cale> Tchakkazulu: All the Read functions only produce values of the type that's in the Read class.
12:42:53 <int-e> byorgey: the Num class is more interesting - you can make a function that doubles or, say, adds 1 to a number of type data Number where { N :: Num a => a -> Number }
12:42:54 <psykotic> Tchakkazulu, it's useful whenever you want to deal with heterogeneous structures.
12:43:02 <Cale> They never take them, so you've effectively produced an interfaceless value.
12:43:07 <psykotic> Tchakkazulu, which is quite often in real programs.
12:43:21 <Tchakkazulu> Cale: Heh, true
12:43:21 <byorgey> int-e: ah, interesting
12:43:50 <int-e> byorgey: and if you pack a Show dictionary as well, you can print the final result, too.
12:43:52 <Tchakkazulu> Didn't realise it.
12:44:08 <Cale> kjdf: does that help at all?
12:44:13 <kjdf> hm
12:44:28 <kjdf> well I did understand all the words
12:44:28 <byorgey> int-e: right.  data Number where { N :: (Num a, Show a) => a -> Number } -- like so?
12:44:36 <kjdf> but the difference is still fuzzy ;)
12:44:37 <int-e> byorgey: yep
12:44:52 <byorgey> Cale++
12:44:53 <byorgey> int-e++
12:44:56 <Cale> So we can effectively upcast, at least in GHC. It does go against the grain of functional programming a bit, but sometimes it's handy.
12:44:59 <Tchakkazulu> Aren't all Num things an instance of Show?
12:45:02 * byorgey 's brain has expanded =)
12:45:17 <earthy> tchakkazulu: no
12:45:32 <Cale> class (Eq a, Show a) => Num a where
12:45:35 <Tchakkazulu> I thought it was one of the constraints of Num.
12:45:37 <Cale> yes, unfortunately
12:45:54 <earthy> oh, waitsec, i ran into that a year or two back
12:46:01 <int-e> Tchakkazulu: oh right. I keep forgetting about that. (and it's ugly, in my opinion)
12:46:03 <Cale> Not all things which you *might* want to make instances of Num are meaningfully instances of Show
12:46:12 <Tchakkazulu> Was it mayhaps with defining (Num a => b -> a)
12:46:13 <earthy> cale: exactly
12:46:27 <Tchakkazulu> Though Eq gets tricky in that case as well.
12:46:27 <Cale> It's a stupid Haskell'98 wart
12:46:30 <earthy> tchakkazulu: something not entirely unlike that. ;)
12:46:44 <int-e> Why was that done? To help dictionary passing implementations to pass fewer dictionaries?
12:46:52 <Tchakkazulu> Heh, I'm a math guy, so I'm used to writing things like (f + g).
12:47:03 <byorgey> seems silly... let me guess, to protect newbies using REPLs from weird type errors?
12:47:06 <Cale> yeah, Num really shouldn't be a subclass of anything, except maybe some Group type or something :)
12:47:10 <dolio> Probably to cut down on type signature length.
12:47:12 <Cale> typeclass*
12:47:17 <earthy> byorgey: also
12:47:21 <Cale> Yeah, that's all it is.
12:47:23 <Tchakkazulu> Though I guess it's still (liftM2 (+) f g), for that weird function monad.
12:47:34 * earthy nods
12:47:35 <Cale> When you pattern match against integer literals you need an instance of Eq
12:47:44 <Cale> and people thought that was kind of weird.
12:47:49 <int-e> yes, Eq is understandable
12:48:02 <int-e> Show however is out of place.
12:48:02 <Cale> Show on the other hand is just silly.
12:48:14 <Tchakkazulu> I can sense the agreement :)
12:48:31 <earthy> anyway, that's not what haskell' is for, right? :P
12:48:32 <Cale> I think that was another "hey, all our current instances are also instances of X!" thing.
12:48:43 <DaveCGI609> monochrom: reading that seems like it describes limitations of C++ rather than OO
12:49:32 <Cale> DaveCGI609: One thing that you can do with typeclasses which is tricky in OO are things like read
12:49:58 <Cale> You can make the *result* of a typeclass method polymorphic, without having any of the parameters be.
12:50:18 <DaveCGI609> polymorphic?
12:50:23 <DaveCGI609> what do you mean by that
12:50:25 <earthy> DaveCGI609: the issue is not with just C++
12:50:30 <Cale> Or look at fromInteger
12:50:30 <Tchakkazulu> Generics ~ polymorphism.
12:50:34 <Cale> @type fromInteger
12:50:37 <lambdabot> forall a. (Num a) => Integer -> a
12:50:40 <Tchakkazulu> It's that it works for multiple types.
12:50:43 <Cale> It's a method of Num
12:50:47 <earthy> DaveCGI609: it truly is a fundamental part of most OO languages
12:50:58 <int-e> @type abs
12:50:58 <Tchakkazulu> That's to make 1 :: Num a => a, right?
12:51:00 <lambdabot> forall a. (Num a) => a -> a
12:51:01 <Cale> It takes an integer, and produces a polymorphic value.
12:51:07 <Cale> yeah
12:51:17 <DaveCGI609> earthy: maybe i missd the example goal, but it seemed like using the CBag variable on a stack it kills the CSet stuff
12:51:17 <Tchakkazulu> I can see that being useful.
12:51:20 <Cale> We have polymorphic numeric literals :)
12:51:33 <Cale> Of course, that's also the reason for defaulting.
12:51:41 <earthy> DaveCGI609: no, that's not the issue
12:51:47 <earthy> the issue is explained a bit later
12:51:56 <earthy> (I'm reading the same article as we speak :))
12:52:16 <Cale> (because it would be annoying if typing 1 + 1 into ghci complained that it didn't know how to show an arbitrary unspecified instance of Num)
12:52:36 <gaborek> :D
12:52:56 <DaveCGI609> ok so polymorphism just refers to types a,b,c,d, etc?
12:53:17 <Cale> Well, yeah, parametric polymorphism, which is really what we mostly use around these parts :)
12:53:18 <earthy> polymorphism in haskell allows variables for types
12:53:41 <Cale> Typeclasses give you bounded parametric polymorphism
12:53:56 <Tchakkazulu> Writing "id" without generics would be a pain.
12:54:25 <Cale> (that is, rather than just any type, the type variables are forced to take on only types which implement some set of classes)
12:54:40 <DaveCGI609> Cale: so you can make the result polymorphic.. and how would that even work
12:55:00 <Cale> type inference allows it to determine which type is actually needed in the end
12:55:12 <Cale> and it uses the code for the specific instances
12:55:40 <Cale> In OO, the methods are bound up with the data
12:55:54 <Cale> They're packaged together and always follow each other around
12:56:12 <kjdf> hm, would be that possible for dynamic language?
12:56:14 <Cale> With typeclasses, the methods take a different route than the data
12:56:39 <Cale> kjdf: It would be pretty tricky if possible at all.
12:56:41 <DaveCGI609> you can do anything in a dynamic language, you just get less safety
12:56:58 <Cale> Well, this is a case where types are actually informing which code gets compiled
12:57:09 <Cale> So you change the type, the code changes.
12:57:17 <dolio> You'd need to do explicit dictionary passing, probably.
12:57:20 <Cale> right
12:57:33 <Cale> So it would be messy.
12:58:02 <Cale> When you write  sort :: (Ord a) => [a] -> [a]
12:58:12 <Cale> the compiler translates that into the intermediate form
12:58:19 <Cale> sort :: Ord a -> [a] -> [a]
12:58:37 <Cale> where (Ord a) is a record type consisting of a dictionary of all of Ord's methods
12:59:12 <Cale> and whenever you write an instance, you're defining a value of type Ord a in the internal representation
13:00:02 <Cale> Those dictionaries get passed in by the compiler wherever what was a polymorphic value finally ends up getting a concrete type.
13:00:16 <Cale> (which always ends up happening somewhere, in a correct program)
13:00:32 <Cale> and they get passed along by functions
13:00:36 <roconnor> (in GHC)
13:00:37 <Cale> separate from the data
13:00:48 <Cale> yes, this is in GHC, there are other ways to implement this of course
13:01:20 <Cale> But that might help to give some feel for what's going on behind your back, and how it's possible. :)
13:01:23 <SamB> notably JHC turns it into something more like:
13:02:12 <Cale> Oh, I should also mention that the methods of the typeclass just end up being field extractors for the records
13:02:50 <Cale> So (<) might just extract the third field of the Ord dictionary it's given, which was the actual implementation of (<)
13:02:52 <DRMacIver> It would be nice if there was a way of doing that conversion within the language.
13:03:30 <Cale> Like, having it derive a type like that for you?
13:03:30 <DaveCGI609> monochrom: great, so how do you get proper subtyping
13:03:36 <Cale> Of course, you can write one yourself :)
13:04:05 <Cale> Is monochrom talking and I don't see?
13:04:06 <DRMacIver> Cale: You mean using SYB or something like that? Sure.
13:04:22 <DRMacIver> Cale: Not in the last 25 minutes or so. :)
13:04:25 <Cale> DRMacIver: I mean just write out the appropriate record type
13:04:42 <monochrom> I have said nothing for at least 10 minutes.
13:04:55 <Cale> DaveCGI609: was that aimed at me?
13:05:11 <DRMacIver> Cale: Yeah, of course you can. It's just a lot of boilerplate code. :) It would be nice if there was some pleasant way of making it Just Work.
13:05:13 <monochrom> But I guess monochrom and Cale get wrapped up into the same existential type.
13:05:19 <Cale> DRMacIver: yeah.
13:05:23 <Cale> monochrom: hehe
13:05:39 <DRMacIver> If I understood how it worked, maybe I'd prefer Cayenne's solution. :)
13:05:44 <Cale> So that also explains existential types
13:06:08 <Cale> With an existential type, a dictionary gets packed in when you use the data constructor, along with the value.
13:06:15 <DaveCGI609> and Cale just went into super intellectual talk so
13:06:24 <DaveCGI609> monochrom: uhh...yeah.. youre the one who linked me to the subtyping url
13:06:31 <Cale> ah :)
13:06:51 <Cale> I suppose the answer is that we don't really use subtyping much.
13:07:03 <Cale> The real answer is, anyway
13:07:34 <Cale> You can construct typeclass hierarchies, but those aren't quite the same thing
13:07:50 <Cale> and you can construct existentials for each of the classes in your hierarchy
13:07:57 <dolio> Doesn't edwardk's crazy toy language do something with subtyping?
13:08:16 <Tchakkazulu> !!
13:08:30 <Cale> So you can get pretty close.
13:08:34 <kjdf> btw is it possible to make an existential type for 2 type classes?
13:08:39 <Cale> yep
13:08:47 <Tchakkazulu> And then you can write a Casting typeclass with a cast method, you you can cast subtypes to supertypes.
13:08:47 <byorgey> <SamB> notably JHC turns it into something more like:  ?
13:08:55 <Cale> So you could split up the functionality like that too.
13:08:57 <dolio> Or maybe I'm thinking of some other features.
13:09:04 <Tchakkazulu> Or just write a cast function for every combination of sub and superclasses.
13:09:11 <dolio> I think he has substructural typing and subset typing. :)
13:09:28 <Cale> Existential types also really let you simulate objects. The forgotten type is like 'this'. For an example of that... let me find something on the wiki :)
13:09:31 <SamB> sort :: (a::*).(xs::[a]).[a]
13:09:35 <SamB> byorgey: sorry
13:09:48 <SamB> it took me forever to find the Pi character
13:09:52 <Cale> oh, damn, it might be on the old wiki :)
13:10:03 * Cale uses the archive
13:10:08 <byorgey> SamB: hehe
13:10:12 <monochrom> edwardk puts in some dependent type. The exact form is type definable by logic formulas (or set comprehension). In general IMO you must bring in some theorem proving to do OO correctly. I.e., as we observed before, code alone is not enough, you also need specification.
13:10:40 <byorgey> SamB: What's the Pi character mean in that context?
13:11:22 <SamB> byorgey: I haven't read that PTS paper yet, but it looks like it mirrors a lambda term in the value...
13:11:31 <DaveCGI610> so how does haskell handle subtyping again?
13:12:20 <SamB> DaveCGI610: remind me what that even is
13:12:21 <byorgey> SamB: hmm... ok
13:12:41 <DaveCGI610> SamB: I'm assuming something adhering to the liskov substitution principle
13:13:19 <Cale> grr, might just have to rewrite it
13:14:35 <DaveCGI610> sounds a lot lke design-by-contract anyway
13:14:44 <Cale> aha, here it is
13:14:59 <Cale> data Counter a = forall self. NewCounter
13:14:59 <Cale>     { _this    :: self
13:14:59 <Cale>     , _inc     :: self -> self
13:14:59 <Cale>     , _display :: self -> IO ()
13:15:00 <Cale>     , tag      :: a}
13:15:24 <Cale> inc :: Counter a -> Counter a
13:15:24 <Cale> inc (NewCounter x i d t) = NewCounter
13:15:24 <Cale>     { _this = i x, _inc = i, _display = d, tag = t }
13:15:25 <shachaf> Will we ever get hawiki back?
13:15:29 <Cale> display :: Counter a -> IO ()
13:15:29 <Cale> display NewCounter{ _this = x, _display = d } = d x
13:15:41 <Cale> counterA :: Counter String
13:15:41 <Cale> counterA = NewCounter
13:15:41 <Cale>     { _this = 0, _inc = (1+), _display = print, tag = "A" }
13:15:47 <Cale> counterB :: Counter String
13:15:47 <Cale> counterB = NewCounter
13:15:47 <Cale>     { _this = "", _inc = ('#':), _display = putStrLn, tag = "B" }
13:15:49 <shachaf> Cale: @paste, maybe?
13:15:57 <Cale> yeah, probably should have :)
13:16:10 <Cale> but it's really just the overall look of that which is important :)
13:16:11 <Lemmih> shachaf: No.
13:16:21 <DaveCGI610> Cale: what is that weird Counter a = forall self. syntax
13:16:26 <shachaf> Lemmih: No, we won't get hawiki?
13:16:29 <shachaf> Lemmih: Is it gone?
13:16:37 <Cale> DaveCGI610: The same existential syntax I introduced way back.
13:16:39 <Lemmih> shachaf: Yes, it is gone.
13:16:50 <shachaf> Lemmih: How/why?
13:16:59 <shachaf> Lemmih: There's no way of getting the text?
13:17:02 <DaveCGI610> Cale: it hides "Counter a" into an existential type called "self" ?
13:17:15 <Cale> DaveCGI610: no
13:17:30 <Lemmih> shachaf: It has been replaced by a newer/better wiki.
13:17:51 <shachaf> Lemmih: Sure, but there is still old information on the old one.
13:18:05 <Cale> DaveCGI610: a value of type (Counter a), is, for some type self, a record consisting of the four fields  _this, _inc, _display and tag
13:18:34 <Tchakkazulu> I once googled something, came to a hawiki site. Then I replaced hawiki by haskellwiki, and it Just Worked.
13:18:37 <Cale> where _this :: self, _inc :: self -> self and _display :: self -> IO ()
13:18:45 <Tchakkazulu> Not sure if that was a lucky strike or not.
13:18:52 <shachaf> Tchakkazulu: It was.
13:19:11 <Cale> So this is kind of like an object
13:19:20 <monochrom> The long term plan is to increase that luck.
13:19:34 <Cale> 'self' encapsulates the private information about the object
13:20:05 <Cale> and the four fields here are the public interface (though we write another layer around them so as to make things prettier)
13:20:28 <Cale> counterA manipulates an Integer
13:20:38 <Cale> While counterB manipulates a string
13:20:56 <Cale> but they're both values of type Counter String
13:21:09 <Cale> (the 'a' parameter is kind of silly)
13:22:02 <Cale> (it's just to add an additional tag to the record, I'm not sure what reason why except as a demonstration that you can mix existential records with type parameters :)
13:23:00 <Cale> But this datatype really is very much like an OO class, and values really are quite a lot like objects.
13:23:36 <Cale> display (inc counterA)         -- prints "1"
13:23:41 <Cale> display (inc (inc counterB))   -- prints "##"
13:24:41 <Cale> So the long and short of it is that you really can get everything you have in OO, but the mapping isn't quite straightforward.
13:25:09 <kjdf> a completely different question
13:25:22 <kjdf> are Functor's fmap and Monad's liftM related?
13:25:26 <Cale> yes
13:25:41 <Cale> they're actually the same thing, except fmap is more polymorphic
13:26:08 <Cale> The only reason that liftM exists is that Monad isn't a subclass of Functor, for stupid reasons.
13:26:24 <Cale> (so people can forget to implement an instance of Functor)
13:26:29 <samreid> there are actually reasons?
13:27:01 <Cale> yes, some people are apparently too lazy to type  instance Functor Foo where fmap = liftM
13:27:28 <Cale> Or were, when H98 was written.
13:27:29 <sjanssen> @slap those_jerks
13:27:29 * lambdabot beats up those_jerks
13:27:55 <Tchakkazulu> instance (Monad m) => Functor m where fmap = liftM
13:27:57 <shachaf> sjanssen: You don't need the '_'.
13:28:13 <sjanssen> shachaf: thanks.  I couldn't remember, and didn't want to spoil the joke
13:28:33 <Cale> Tchakkazulu: That'd require overlapping instances, but yeah.
13:28:35 <shachaf> sjanssen: You can always try in a /msg. :-)
13:28:45 <monochrom> Monad : Functor :: Ord : Eq  :)
13:29:00 <shachaf> What about Applicative?
13:29:01 * Tchakkazulu nods.
13:29:10 <Cale> shachaf: Now we have that question too :)
13:29:17 <Tchakkazulu> Functor > Applicative > Monad, I think.
13:29:25 <shachaf> Tchakkazulu: Yes.
13:29:26 <Cale> (it wasn't a question when H98 was written)
13:29:49 <Tchakkazulu> *cough*Arrow*cough*
13:29:52 <Cale> However, only a few people are actually using Applicative just yet
13:29:55 <shachaf> It's important, though.
13:29:56 <Tchakkazulu> Completely different, though.
13:30:26 <shachaf> Also, return/ap/liftMn should be pure/(<*>)/liftAn
13:30:40 <Cale> So if you make the class hierarchy look like that, defining a new monad gets annoying for people who don't care about Applicative (not so annoying, but you can see where this is headed)
13:31:03 <Tchakkazulu> Aye.
13:31:12 <shachaf> Cale: There's no way to default it?
13:31:12 <Cale> I rather like the name return
13:31:18 <Cale> shachaf: Not at present
13:31:24 <Tchakkazulu> And liftAn could become fmapn
13:31:24 <shachaf> Cale: Sure, but it should be part of Applicative.
13:31:46 <Tchakkazulu> Or would that only work with n = 1?
13:32:06 <Cale> :t liftM2
13:32:09 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:32:13 <shachaf> Well, fmap should be called map. :-)
13:32:14 <Cale> :t liftA2
13:32:16 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:32:22 <Tchakkazulu> Also true :P
13:32:48 <Cale> There's a lot of duplication at present, which isn't ideal, but at least it's all in the libraries.
13:33:06 <Tchakkazulu> But I just see that, while you can generalise liftA to fmap, you can't do so for liftAn.
13:33:10 <Cale> If we want to fix it, I think there's going to have to be an additional language feature or two.
13:33:30 <Cale> (Class aliases seem to be the thing which most people agree with)
13:33:41 <Cale> http://repetae.net/john/recent/out/classalias.html
13:33:42 <lambdabot> Title: Class Alias Proposal for Haskell
13:35:25 <Cale> That has a pretty good description of the problem along with a rather elegant solution to it.
13:35:33 <Cale> We just need someone to put it into GHC.
13:37:55 <Tchakkazulu> Hmm...
13:38:00 <Tchakkazulu> Yes, interesting.
13:38:28 <Tchakkazulu> I find myself often writing (Bla1 a, Bla2 a, Bla3 a) => SomethingWith a
13:38:47 <Tchakkazulu> So, besides fixing class hierarchies, it'd save writing, too :P
13:42:08 <Cale> Well, you can sort of save the writing already
13:42:25 <Cale> By just defining a new class and a completely generic instance
13:43:48 <Cale> So from today's discussion, you can see why I might feel a little worried about Haskell becoming too popular too quickly :)
13:44:19 <Cale> Massive breaking changes to the language get harder to make the more libraries they'd break :)
13:44:32 <Tchakkazulu> Yes.
13:44:35 <glguy> Cale: I didn't notice... but wouldn't this make type inferenced signatures quite ugly?
13:44:47 <Tchakkazulu> Last week I've been messing around with the ncurses binding.
13:45:15 <Tchakkazulu> Trying to run the Hetris and Mage games.
13:45:17 <Cale> glguy: You could collapse using class aliases automatically too, if you wanted. GHC already preserves the way that things are written to some extent.
13:45:27 <Tchakkazulu> They both use a completely different ncurses library.
13:54:32 <Cale> oh, Mage seems to still use Data.FiniteMap
13:54:46 <fnord123> Cale, what OS do you use for most of your Haskell work?
13:54:57 <Cale> fnord123: I use ubuntu for everything.
13:55:08 <Cale> and I used to use debian
13:55:15 <Tchakkazulu> Yes, that was hell to convert to Data.Map.
13:55:53 <Cale> (it was awesome, but my install was several years old, and I'd installed lots of cruft over the years that I wanted to blow away, so I decided to try Ubuntu, and have been pretty happy with it)
13:56:23 <fnord123> I split my time between Ubuntu and OS X. I was just curious if anyone happened to know if HOC (http://hoc.sourceforge.net/) was fairly mature of just a toy.
13:56:24 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
13:56:59 <byorgey> @unpl map . (:)
13:57:00 <lambdabot> (\ c -> map (((:)) c))
13:57:07 <Cale> fnord123: I've seen it working, at least, and I knew the guy who wrote it.
13:57:13 <fnord123> fairly mature = I can wrestle it into shape. I don't need it to make me a sandwich.
13:57:33 <Cale> I'm not sure how maintained it is.
13:57:35 <byorgey> (((:)) c) ?  yeesh
13:57:50 <Cale> heh
13:57:57 <Cale> that's pathological :)
13:57:59 <Tchakkazulu> ((:) c)
13:58:04 <fnord123> ok ill consider it for a front end target. thanks
13:58:47 <byorgey> @pl \c -> map (c:)
13:58:47 <lambdabot> map . (:)
13:59:44 <Cale> fnord123: Yeah, I did work on OS X a few years back :)
14:00:31 <Cale> fnord123: They had nice PowerMac G5's with 23" Cinema HD displays where I worked.
14:00:40 <Cale> and 6 G5 XServes
14:01:28 <Cale> So that was pretty fun :)
14:01:42 <Cale> I didn't really use HOC myself though.
14:02:41 <mathias> Cale, ping
14:02:44 <Cale> hi
14:02:59 <mathias> Cale, I found out that one does not need a forall
14:03:14 * Cale warns everyone that he's now been up for 24 hours :)
14:03:40 <Cale> mathias: Yeah, you can probably avoid giving explicit type sigs altogether in a real program
14:03:47 <mathias> Cale, In the context in my real code I had and s and s1 in the derived type. I simply replaced those with s and it worked fine too.
14:03:54 <Cale> yeah
14:04:00 <Cale> er
14:04:06 <mathias> Cale, I doubt that in this case.
14:04:20 <Cale> Wouldn't your equivalent of AX have an STRef or something inside it?
14:04:22 <puusorsa> fnord123, HOC doesn't work.
14:04:29 <earthy> why the *fuck* does Data.Time.Calendar.fromGregorian have type Integer -> Int -> Int -> Data.Time.Calendar.Days.Day rather than Integer -> Integer -> Integer -> Data.Time.Calendar.Days.Day
14:04:45 <mathias> Cale, yes, it has.
14:04:47 <puusorsa> at least i didn't even get any of the examples working
14:05:15 <Cale> earthy: Obviously because you're going to be doing like a billion of them and it needs to be really super fast.
14:05:15 <fnord123> puusorsa: let me try
14:05:20 <puusorsa> sure
14:05:27 <puusorsa> hope you have better luck
14:05:33 <glguy> earthy: because the month and day fit in an Int
14:05:42 <Cale> mathias: So doesn't that resolve the issue?
14:05:45 <glguy> earthy: but you could be interested in the year that the universe collapses
14:05:51 <mathias> Cale, no
14:05:56 <earthy> yeah, I could be
14:06:04 <earthy> however, this makes the types annoying to usse
14:06:06 <mathias> Cale, I might understand why. Let me check
14:06:10 <Cale> mathias: because you'll have constructed the STRefs using the ST monad within that do-block
14:06:29 <earthy> now I can't simply do selects from a map read over a list of strings
14:07:39 <Cale> Really, it ought to be polymorphic (Integral), with specialise pragmas.
14:08:01 * earthy nods
14:11:07 <reltuk> @source maybeM
14:11:08 <lambdabot> maybeM not available
14:11:27 <balodja> may be just maybe? :)
14:11:49 <monochrom> May I help you?
14:11:57 <olathe> How do I produce a list with the element at index 5 changed ?
14:12:32 <earthy> olathe: newlist newelement xs = take 4 xs ++ newelement ++ drop 5 xs
14:12:47 <monochrom> splitAt 5, then do something
14:13:28 <earthy> ofcourse, this does not do the right thing for lists with length < 5
14:13:49 <monochrom> nothing will
14:14:03 * earthy nods
14:14:03 <olathe> Alright, thanks.
14:14:34 <earthy> damn. I really shouldn't try hobby coding on a friday evening after a weeks' worth of heavy parser stuff
14:14:40 <puusorsa> http://worrydream.com/AlligatorEggs/
14:14:41 <lambdabot> Title: Alligator Eggs!
14:14:54 <earthy> just parsing a simple Exif Time took me 45 minutes to code
14:15:03 <fnord123> puusorsa: yeah I'm getting lib compile errors when it parses Foundation/Foundation.conf-inplace
14:15:03 <monochrom> You should talk about the demerits of OOP instead :)
14:15:18 <earthy> ofcourse, reading the Exif spec took most of that time. :)
14:15:33 <puusorsa> i got the lib compiled but none of the examples worked
14:15:43 <mathias> Shall we talk about the merits of global instances?
14:15:48 <fnord123> didnt work or didnt compile?
14:15:55 <mathias> (for type classes)
14:16:08 <Toxaris> > uncurry (++) . second ((42 :) . tail) . splitAt 5 $ [0..10]
14:16:10 <lambdabot>  [0,1,2,3,4,42,6,7,8,9,10]
14:16:16 <monochrom> Yes. They are very convenient.
14:16:26 <Toxaris> ok, a bit late :(
14:16:40 <fnord123> > [1..]
14:16:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:17:54 <reltuk> @pl  \newx xs -> uncurry (++) . second ((newx :) . tail) . splitAt 5 xs
14:17:55 <lambdabot> ((uncurry (++) .) .) . (. splitAt 5) . (.) . second . (. tail) . (:)
14:18:14 <olathe> Is there any easy way of working with tuples of length 7 so that you can replace element n ? Do you have to write a function for each index ?
14:18:48 <ddarius> olathe: Christ, use a record.
14:19:11 <byorgey> olathe: that would probably be considered tuple abuse =)
14:19:22 <Toxaris> olathe: maybe use an array?
14:19:55 <Toxaris> or have the 7 components different types?
14:20:37 <byorgey> Toxaris: if they did, you couldn't have a general function to replace element n
14:20:48 <olathe> No, they're all integers.
14:21:23 <Toxaris> byorgey: Yes, of course not, so it wouldn't matter that an array would not be applicable
14:21:39 <byorgey> Toxaris: my point exactly =)
14:21:57 <Toxaris> byorgey: ok fine :)
14:22:21 <Toxaris> but records wouldn't help with indexing, either
14:22:38 <byorgey> Toxaris: right
14:22:43 <Toxaris> so it sounds like an array or list task, depending on usage pattern
14:22:57 <byorgey> olathe: what are you trying to do?
14:23:00 <Toxaris> is the overhead of using an array big?
14:23:27 <byorgey> Toxaris: I don't know, but the answer is probably "it depends" =)
14:24:19 <Toxaris> byorgey: very general answer :)
14:24:27 <puusorsa> fnord123, work. and i was wrong, some work. like expressionparser
14:24:37 <puusorsa> browser doesn't
14:24:50 <byorgey> Toxaris: yes, it's polymorphic in the usage pattern =)
14:25:52 <puusorsa> and Editor doesn
14:25:54 <puusorsa> t compile
14:26:24 <Toxaris> byorgey: an answer wich generalizes from the actually asked question is very much like _|_: always applicable, never usefull
14:26:36 <Toxaris> (except for philosophy and type hackery)
14:26:59 <byorgey> hehe
14:27:58 <Cale> and debugging :)
14:28:34 <byorgey> olathe: to answer your real, original question: no, there isn't an easy way to do that with tuples.  You'd have to write something like:
14:28:35 <Cale> undefined will always nicely typecheck :)
14:28:57 <byorgey> replaceNth 0 a (_,b,c,d,e,f,g) = (a,b,c,d,e,f,g) ...
14:28:58 <byorgey> and so on
14:29:04 <byorgey> ugh
14:29:38 <Cale> Nobody uses large tuples anyway
14:29:48 <Cale> Well, that's not quite true
14:29:54 <earthy> not unless it's in generated code
14:30:10 <Cale> but if you have tuples with that many elements, it's probably time to get your own datatype :)
14:31:29 <reltuk> Why not use a Data.Array?
14:31:32 <byorgey> I hope we didn't scare olathe away... =)
14:36:53 <desp> ugh
14:36:57 <Toxaris> > let a ? b = a <*> return b in ((+) <$> [1, 2, 3]) ? 1 -- is there a name for this (?)
14:36:58 <lambdabot>  [2,3,4]
14:37:03 <desp> any GNU make gurus here?
14:37:33 <Toxaris> it would make a nice companion for <$> and <*> for precise selection wich arguments to lift and wich not
14:38:12 <shachaf> Toxaris: You mean pure?
14:38:22 <shachaf> Toxaris: I guess that conflicts with Control.Arrow, though.
14:38:25 <earthy> desp: what's aching you?
14:39:00 <Toxaris> oh there's pure for Control.Applicative
14:39:10 <Toxaris> so my example would be much better:
14:39:20 <Toxaris> > let a ? b = a <*> pure b in ((+) <$> [1, 2, 3]) ? 1
14:39:21 <lambdabot> Terminated
14:39:27 <Toxaris> hmm ok would not
14:39:38 <hpaste>  desp pasted "makefile" at http://hpaste.org/2178
14:39:44 <desp> earthy: I want to write a suffix rule to simplify that
14:39:45 <shachaf> > let a ? b = a <*> Control.Applicative.pure b in ((+) <$> [1, 2, 3]) ? 1
14:39:47 <lambdabot>  [2,3,4]
14:39:57 <shachaf> @ty pure -- arr?
14:39:59 <lambdabot>     Ambiguous occurrence `pure'
14:39:59 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
14:40:23 <glguy> for Arrows, pure and arr are the same
14:40:26 <desp> earthy: I thought  .x.hs: ; $(HC) -o $* $<  would do it
14:40:40 <shachaf> glguy: Yes, but Toxaris is talking about Applicatives. :-)
14:40:45 <conal> @ty Control.Applicative.pure
14:40:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:41:02 <desp> earthy: but I don't know how to make all depend on p*.x
14:41:09 <Toxaris> shachaf, glguy: yes, I meant Applicative's pure
14:41:27 * glguy only brought it up because of the "-- arr?"
14:41:36 <sjanssen> @arr
14:41:36 <lambdabot> Aye Aye Cap'n
14:41:55 <shachaf> glguy: I assumed that < Toxaris> > let a ? b = a <*> pure b in ((+) <$> [1, 2, 3]) ? 1 was defaulting to Control.Arrow.pure.
14:42:01 <glguy> ah
14:43:00 <Toxaris> so there's no name?
14:43:03 <Toxaris> why not
14:43:22 <shachaf> @arf
14:43:22 <lambdabot> Keelhaul the swabs!
14:43:27 <earthy> desp: sorry, I don't quite follow
14:43:42 <desp> earthy: did you see the hpaste?
14:44:00 <earthy> yeah
14:44:01 <glguy> @quote
14:44:01 <lambdabot> SimonRC says:  if performance was that important, people would be using perl, python, or the JVM
14:44:05 <shachaf> > ($ 1) <$> ((+) <$> [1,2,3])
14:44:06 <lambdabot>  [2,3,4]
14:44:15 <desp> earthy: I want to avoid having a single rule for every p#
14:44:43 <hpaste>  Earthy annotated "makefile" with "Pattern Rule (GNU Make)" at http://hpaste.org/2178#a1
14:44:44 <desp> earthy: so, I thought that I'd be able to write a "suffix rule" to transform every p#.hs source file into a p#.x executable
14:45:26 <earthy> I'm just not entirely sure that's legal GNU Make. :)
14:45:30 <desp> earthy: ah ha, that worked
14:45:33 <desp> but wth :D
14:45:35 <marcotmarcot> Hello, I'm trying to do a haskell script adding the line #!/usr/bin/runhaskell -Wall -Werror to the beggining of the file, but I'm getting: ghc-6.6: unrecognised flags: -Wall -Werror
14:45:52 <Toxaris> shachaf: thats nice :)
14:45:59 <earthy> it's called a pattern rule. much more powerful than suffix rules ;)
14:46:14 <DaveCGI610> pattern rules? is that like macro?
14:46:23 <earthy> almost
14:46:29 <desp> earthy: would it be possible to avoid explicitly enumerating p#s for  "all: p1 p2" ?
14:46:35 <earthy> desp: no
14:46:46 <marcotmarcot> When I use #!/usr/bin/runhaskell -Wall or #!/usr/bin/runhaskell -Werror it works.
14:46:46 <desp> hrm
14:46:49 <earthy> Make always only builds the 1st target
14:47:07 <desp> earthy: I mean, something like "all: $(PS)"
14:47:25 <Toxaris> shachaf: but not quite what I meant... I want to use it like   f <$> action <*> action <?> value <*> action
14:47:32 <shachaf> marcotmarcot: It passes the entire thing as one flag, I think.
14:47:37 <SimonRC> hey!  lambdabot quoted me!
14:47:39 <SimonRC> heh
14:47:47 <earthy> desp: and where would the $(PS) be defined? :)
14:47:48 <desp> where PS = map (replace ".hs" "") (glob "p*.hs") :P
14:47:54 <earthy> ah :)
14:47:54 <marcotmarcot> shachaf: and how could I fix it?
14:47:54 <SimonRC> I thikn a negative got lost somewhere
14:47:56 <Toxaris> but maybe I should simply use   f <$> action <*> action <*> pure value <*> action   and be happy
14:48:01 <desp> earthy: I don't know, I'm asking the guru :)
14:48:06 <shachaf> @quote SimonRC
14:48:06 <lambdabot> SimonRC says:  if performance was that important, people would be using perl, python, or the JVM
14:48:13 <glguy> marcotmarcot: on a related note, if you think anyone else will ever get a copy of your script, you should use: /usr/bin/env runhaskell
14:48:17 <earthy> all: $(ALLFILES)
14:48:24 <shachaf> marcotmarcot: I don't know, I think I've had a similar problem before.
14:48:34 <marcotmarcot> glguy: hum, thanks for the tip, but what's the real difference?
14:48:44 <glguy> marcotmarcot: not everyone installs ghc to /usr/bin
14:48:49 <shachaf> Shouldn't it be runghc (unless -Wall -Werror work in other interpreters?)?
14:48:58 <desp> earthy: end...? :)
14:49:03 <mrd> marcotmarcot: unix only permits one parameter there
14:49:07 <marcotmarcot> glguy: hum, nice.
14:49:08 <desp> earthy: and*
14:49:14 <marcotmarcot> mrd: is there a way I could hack it?
14:49:27 <DaveCGI610> is that to say haskell has worse performance than python?
14:49:33 <shachaf> mrd: Is there a standard command that lets you split on spaces, or something like that?
14:49:42 <desp> DaveCGI610: I wouldn't say hat
14:49:50 <desp> I wouldn't say that, either.
14:49:55 <marcotmarcot> mrd: where can I get doc about this #! thing?
14:49:57 <mrd> marcotmarcot: you might be better off using {-# OPTIONS ... #-} pragma
14:50:00 * shachaf has run into something similar before.
14:50:12 <glguy> DaveCGI610: I have a feeling that the reason that that was quoted was that it was a rather rediculous remark
14:50:13 <mrd> shachaf: some programs provide workarounds like that ...
14:50:14 <desp> shachaf: "split"? :)
14:50:38 <earthy> ALLFILES := $(basename $(wildcard *.hs))
14:50:49 <earthy> sorry, was browsing the manual for the exact calls
14:50:54 <DaveCGI610> yeah i thought haskell claimed to have super good performance.
14:50:57 <earthy> didn't want to make it nonportable by calling out to the shell
14:50:59 <desp> earthy: you rule, thanks
14:51:07 <puusorsa> btw, haskell docs need (more) examples
14:51:08 <mrd> marcotmarcot: i'm not sure where it's documented.  i'm just speaking from anecdotes.
14:51:25 <ddarius> puusorsa: Write some.
14:51:38 <marcotmarcot> mrd: ok, thanks.
14:51:39 <puusorsa> i would if i understood haskell well enough
14:51:59 <mrd> an example for what?
14:52:07 <desp> earthy++
14:53:31 <puusorsa> mrd, in hoogle docs. depends on module of course
14:54:06 <mrd> oh, i thought you were looking at something specifically
14:55:42 <puusorsa> i think the api docs would be a lot easier to grasp with some simple examples
14:55:59 * reltuk is suprised that haskell-mode doesn't have a feature where it inserts the inferred type signature of a function above the definition
14:57:23 <mrd> reltuk: it does
14:57:39 <monochrom> Many haskell libraries are combinator libraries. Conventional documentation techniques from libraries for other languages cannot be carried over to Haskell libraries unmodified.
14:57:50 <mrd> C-c C-t queries the type and displays it, use C-u C-c C-t to insert it
14:58:06 <DaveCGI610> combinator libraries ?
14:58:31 <reltuk> mrd: ahhhh...that's great =)
14:59:05 <Toxaris> DaveCGI610: they provide means to combine simple programs to more complex ones, instead of providing building blocks for programs like "normal" libraries
15:00:16 <Toxaris> DaveCGI610: consider a php library. It will consist of a lot of basic functions entirely, and you can document it by saying "if you want to do this, call this function"
15:00:29 <Toxaris> DaveCGI610: but now consider Control.Monad
15:00:31 <DaveCGI610> yes
15:01:04 <DaveCGI610> you mean to say that haskell constructs are more complicated?
15:01:12 <earthy> no
15:01:19 <mrd> simpler, in fact
15:01:22 <Toxaris> :)
15:01:28 <Toxaris> more high-level
15:01:28 * shapr boings cheerfully
15:01:36 <mrd> you are meant to put them together in interesting ways
15:01:38 <earthy> what he means to say is that Haskell allows you to define control structures and the like in libraries
15:01:47 <puusorsa> maybe not "if you want to do this, call this function" kinda examples, more like "this can be used like this to do that"
15:01:54 <mathias> Disregarding context, sometimes Haskell libraries have "hidden" features.
15:02:02 <ddarius> Of course, we should all be asking what monochrom meant.
15:02:09 <mathias> These come from for example lazyness
15:02:36 <Toxaris> yes, I'm only trying to explain what I think what monochrom meant...
15:02:38 <mathias> A good example is in the IntMap library where one wants to find an unused key.
15:02:44 <earthy> anyway, time for bed
15:02:54 <earthy> I'm not ready to write another parser.
15:03:09 <monochrom> The closest existing technique I can think of is what dictionaries do. The documentation for "prudent" may go like this: first you explain its meaning some way (so far no surprise, every library doc does this, including haskell docs). Then you start giving "examples": "Sally is prudent in driving slowly".
15:03:39 <mathias> A php library would contain: getUnusedKey, in Haskell this is not necessary (but I consider it good API design to include it anyway).
15:03:39 <DaveCGI610> dictionaries? like associate key containers?
15:04:07 <mrd> like Webster
15:04:12 <mrd> Merriam-Webster
15:04:14 <yaxu>  puusorsa: i guess the type signatures give you some hints in that regard
15:04:32 <mrd> yes, it is fun to figure out the use of a combinator from the type
15:04:39 <mrd> sometimes ... too fun
15:05:25 <Toxaris> I think what is needed are middle-sized examples
15:05:27 <ddarius> @djinn b -> (a -> b) -> Maybe a -> b
15:05:27 <lambdabot> f a b c =
15:05:28 <lambdabot>     case c of
15:05:28 <lambdabot>     Nothing -> a
15:05:28 <lambdabot>     Just d -> b d
15:05:34 <monochrom> I want to note several points. 1. the example requires you to know other things to be documented in the same dictionary, e.g., "is", "in", "driving". 2. the example shows only how to use it in terms of grammar, it still doesn't say anything about meaning. 3. despite the shortcoming in 2, apparently no one has ever complained, so it may be good enough for most people.
15:06:05 <mrd> sometimes they even feature a little picture!
15:06:13 <kjdf> mathias: how to find unused key of an IntMap?
15:06:16 <monochrom> From 1 a corollary is: there is not going to be a "self-contained doc for the word 'prudent'" ever.
15:06:25 <DaveCGI610> yeah i was looking at the . operator and had no idea what it did from the docs and type signature until i tried it in ghci
15:06:42 <mathias> kjdf, I find your trolls very amusing, but I won't feed you.
15:06:53 <DaveCGI610> what is needed is a 1-paragraph summary, maybe the source, and a few examples
15:07:06 * tsp wonders if haskell lists are really lists
15:07:17 <tsp> > [1,2,"string", 3.8]
15:07:17 <kjdf> (that qwe thing was just a joke, I am serious)
15:07:19 <lambdabot>   add an instance declaration for (Fractional [Char])
15:07:19 <lambdabot>     In the expression: ...
15:07:27 <tsp> hmm, guess not
15:07:38 <DaveCGI610> tsp: lists are strongly typed
15:07:40 <mathias> kjdf, you are not the real qwe?
15:07:43 <kjdf> no
15:07:50 <tsp> > [1,2,"string",4,5]
15:07:51 <lambdabot>   add an instance declaration for (Num [Char])
15:07:51 <lambdabot>     In the expression: 5
15:07:51 <lambdabot>     I...
15:07:52 <DaveCGI610> tsp: try (1,2,"string",3.8)
15:08:03 <tsp> I thought [] was for lists?
15:08:13 <tsp> you can't add something to the end of a pair
15:08:17 <mathias> kjdf, you are from .pl and since qwe is from Russia, it could still be that you are the same person.
15:08:19 <DaveCGI610> yeah but list type is a : [a]
15:08:28 <Saizan> tsp: in haskell lists contain only elements of the same type
15:08:31 <tsp> omg
15:08:40 <DaveCGI610> so if you want multiple types you have to make a new type that stores either a num or a string
15:08:53 <mathias> kjdf, anyway, the way to do so is to find all the keys in ascending order and then to take the head of this and then subtract 1
15:08:54 <Toxaris> tsp: this is very handy, you always know what it is in advance, and the compiler knows, too
15:09:02 <reltuk> > toDyn 1
15:09:04 <lambdabot>  <<Integer>>
15:09:17 <tsp> :t ()
15:09:19 <lambdabot> ()
15:09:19 <mathias> kjdf, this should work in constant time.
15:09:26 <yaxu> > [Left 1, Left 2, Right "string", Left 3.8]
15:09:27 <lambdabot>  [Left 1.0,Left 2.0,Right "string",Left 3.8]
15:09:40 <reltuk> [toDyn 1, toDyn 2, toDyn "string", toDyn 3.8]
15:09:42 <DaveCGI610> > data MyType = MyNum Num | MyString [Char] in [MyNum 5, MyNum "abc"]
15:09:43 <lambdabot>  Parse error
15:09:47 <tsp> lol neat
15:09:50 <reltuk> > [toDyn 1, toDyn 2, toDyn "string", toDyn 3.8]
15:09:51 <mrd> mathias: do you mean descending?
15:09:52 <lambdabot>  [<<Integer>>,<<Integer>>,<<[Char]>>,<<Double>>]
15:10:02 <Toxaris> monochrom: but let's look at the documentation for (.), I will quite it since it is very short: "Function composition."
15:10:04 <mathias> mrd, no
15:10:10 <tsp> > first 3 "foobar"
15:10:11 <lambdabot>  Couldn't match expected type `[Char]'
15:10:16 <DaveCGI610> Toxaris: yeah that documentation is bad
15:10:18 <tsp> > first "foobar" 3
15:10:19 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
15:10:24 <DaveCGI610> Toxaris: it doesnt even mention the associativity or binding precedene
15:10:25 <yaxu> > take 3 "foobar"
15:10:26 <lambdabot>  "foo"
15:10:28 <mrd> Toxaris: sure, but (.) is like the word "is"
15:10:32 <tsp> ah, take
15:10:34 <mathias> mrd, consider keys [1,2,3,4,5]. The head is 1. Subtract 1 from 1 equals 0. Zero is clearly free
15:10:36 <monochrom> (.) approaches the level of "is". How do dictionaries treat "is"?
15:10:45 <mrd> mathias: well ok, but you'll go negative..
15:10:47 <tsp> is there a reverse-take? one that will chop one from the right
15:10:54 <mathias> mrd, so?
15:10:56 <DaveCGI610> what is "is" and why is all the people talking about dictionaries?
15:11:04 <mathias> mrd, arrays can go negative too
15:11:06 <reltuk> tsp: drop
15:11:08 <tsp> ah
15:11:12 <mathias> mrd, Everything is Ix
15:11:20 <Toxaris> for me, (.) was perfectly clear given the existing documentation because of my formal math background from uni
15:11:22 <monochrom> Because a dictionary is also a doc. We're trying to learn techniques from it.
15:11:23 <mrd> sure, but generally people generate indices going positive
15:11:24 <DaveCGI610> reltuk: no thats not what he meant
15:11:35 <Toxaris> but for someone with a programming background only, it's not enough documentation
15:11:36 <kjdf> and 'keys' is lazy?
15:11:46 <Toxaris> so maybe (.) is meant to be learned from some tutorial, not from the docs
15:11:50 <monochrom> And this is because "combinator" in programming approaches "vocab" in natural languages.
15:11:51 <msouth> >reverse.(take 3).reverse $ "foobar"
15:11:56 <mrd> also is keys defined to be in sorted order? i don't recall
15:11:56 <DaveCGI610> tsp: take 1 $ reverse [1,2,3]
15:11:57 <reltuk> DaveCGI610: ahhh, I see...dropping off the right
15:12:01 <DaveCGI610> > take 1 $ reverse [1,2,3]
15:12:03 <mathias> kjdf, yes, although I did not do a perfect analysis.
15:12:03 <lambdabot>  [3]
15:12:10 <reltuk> taking off the right.../me bangs head
15:12:12 <msouth> > reverse.(take 3).reverse $ "foobar"
15:12:13 <lambdabot>  "bar"
15:12:14 <Saizan> > let revTake n xs = zipWith const xs (drop 1 xs) in revTake 2 [1..5]
15:12:15 <lambdabot>  [1,2,3,4]
15:12:24 <Saizan> > let revTake n xs = zipWith const xs (drop n xs) in revTake 2 [1..5]
15:12:25 <lambdabot>  [1,2,3]
15:12:44 <Toxaris> but look at the documentation for ($), wich is much better
15:12:48 <mathias> It doesn't really matter since there cannot fit more than 2^32 elements in it.
15:12:53 <DaveCGI610> msouth: lol you like using period a lot?
15:13:01 <tsp> how do you come up with this stuff? It would take me probably hours to figure that out
15:13:15 <glguy> msouth: you don't need the () around take 3
15:13:17 <monochrom> It is very hard to explain my perspective if you hardwire in your head "Perl/Python/PHP's way is the only way to write docs" and dismiss my perspective.
15:13:30 <glguy> msouth: since function application binds tighter than operator apapliation
15:13:31 <mrd> DaveCGI610: haskell programmers enjoy using period a greal deal
15:13:39 <mrd> ;)
15:13:48 <glguy> DaveCGI610: (.) is a hallmark of functional programming
15:13:50 <yaxu> > let dropthreefromfoobar _ = "bar" in dropthreefromfoobar "foobar"
15:13:51 <DaveCGI610> tsp: actually its just take 1 (reverse [1,2,3]) and the $ and . was used for cool points
15:13:51 <lambdabot>  "bar"
15:13:57 <mrd> it's called "combinator" for a reason
15:14:00 <bwx> does haskell' propese anything like python doc strings?
15:14:03 * yaxu waves hands
15:15:06 <reltuk> @type dynApp
15:15:08 <lambdabot> Dynamic -> Dynamic -> Dynamic
15:15:45 <yaxu> bwx: maybe this http://www.haskell.org/haskellwiki/Literate_programming
15:15:46 <lambdabot> Title: Literate programming - HaskellWiki
15:15:54 <reltuk> > toDyn $ (+) 3
15:15:56 <lambdabot>  <<Integer -> Integer>>
15:16:02 <Toxaris> monochrom: dictionaries ignore "is" because everyone using the dictionary know "is" anyway. should Prelude documentation ignore (.) even if not every Haskell newbie knows (.)?
15:16:16 <Syzygy-> ISn't the point with the python doc strings that they give you something like forall a. a -> String ?
15:16:24 <yaxu> bwx: oh, haskell'. sorry
15:16:27 <reltuk> > dynApp (toDyn $ (+) 3) (toDyn 3)
15:16:28 <mrd> "is" is a form of the verb "to be"
15:16:28 <lambdabot>  <<Integer>>
15:16:37 <monochrom> How does this sound for a doc of (.): "Function composition: (f . g) x = f (g x). Example: define h = not . not. Then h True = True."
15:16:49 <mrd> dictionaries don't ignore that.
15:16:52 <Syzygy-> Toxaris: Good dictionaries do NOT ignore 'to be' - it is a pretty fascinating verb.
15:16:53 <msouth> "is" to be a form of the verb to be
15:16:54 <DaveCGI610> @src .
15:16:54 <lambdabot> (.) f g x = f (g x)
15:17:03 <mrd> but pretty much the best documentation is what lambdabot just stated
15:17:05 <msouth> film at 11
15:17:25 <reltuk> Toxaris: to definition of 'to be' is probably one of the more in depth definitions in any reputable english dictionary
15:17:33 <DaveCGI610> the words "Function composition" are lame, the source for . is better
15:17:44 <Toxaris> hmm ok so I don't understand monochroms point
15:17:54 <monochrom> It is not lame if you paid attention to highschool math classes.
15:17:58 <mrd> the prelude is available as easy to read source
15:18:06 <msouth> function composition is probably the perfect thing for anyone who remembers that from math.
15:18:18 <msouth> which until recently was close to 100% of people using haskell
15:18:24 <DaveCGI610> monochrom: i did pay attention and so what, . is an infix operator and the docs dont say what its binding order is or if its left or right associative
15:18:25 <Toxaris> sure, I have no problem with "function composition" as doc myself
15:18:26 <msouth> i would guess
15:18:26 <Syzygy-> And using function composition also tells you that (.) is one of the intrinsic bits of the category Hask.
15:18:27 <glguy> DaveCGI610: function composition  is a term that any functional programmer or high school math graduate (should) know
15:18:40 <mrd> don't overestimate our high schools
15:18:50 <glguy> DaveCGI610: . is associative
15:19:02 <DaveCGI610> all im saying is that the docs dont say anything but function composition
15:19:04 <glguy> DaveCGI610: by virtue of being "function composition"
15:19:15 <DaveCGI610> but lets say you got f . x $ y
15:19:18 <bwx> i want real doc strings, so that i can type :info f in ghci, and in addition to the getting type information, also get the associated doc string
15:19:22 <Syzygy-> glguy: Or, equivalently, since Hask is a category. :P
15:19:29 <DaveCGI610> how am i to know if its (f . x) $ y or f . (x $ y) ?
15:19:33 <Syzygy-> DaveCGI610: Then $ is not associative.
15:19:34 <yaxu> glguy: but what if you're learning functional programming starting with haskell, without a math background?
15:19:35 <Toxaris> hmm. maybe the docs need a link to the approbiate source position for every entry, not just at the top of the page?
15:19:43 <msouth> DaveCGI610: yeah, I agree that that is not enough
15:19:44 <Syzygy-> Or .. not quite.
15:20:03 <glguy> yaxu: then you have to learn abou tfunctional programming, the doc string isn't a tutorial
15:20:05 <DaveCGI610> so in fact every infix operator should have its "infixr x" or "infixl y" values listed
15:20:10 <monochrom> what is "without a math background"?  Haskell has "0" too, does that require a math background?
15:20:13 <yaxu> glguy: fair enough
15:20:15 * SamB just defined a monad in terms of return/fmap/join ... because he wanted to do it that way
15:20:15 <msouth> it's like when I was learning perl and all the examples assumed you were familiar with unix system administration
15:20:32 <monochrom> Does "0" need to be documented and exemplified?
15:20:34 <Syzygy-> SamB++
15:20:34 <msouth> "this is just like awk's foo feature", end of explanation
15:20:36 <mrd> Samb: maverick!
15:21:11 <Syzygy-> mrd: No no no. That's the morally RIGHT way to do it!
15:21:11 <yaxu> @src 0
15:21:11 <lambdabot> Source not found. I feel much better now.
15:21:22 * Syzygy- takes on the standard of category theory and charges ahead.
15:21:31 <monochrom> Surprisingly, if you taught Haskell to European highschoolers in 1257, you would need to explain "0".
15:21:37 <msouth> . is also used in many things for dereference so it's probably worth making extra sure you're clear about what it is.
15:21:52 <msouth> and computers
15:21:54 <mrd> monochrom: also, the shiny machine with flickering lights
15:22:04 <yaxu> i still have trouble with 0
15:22:11 <SamB> monochrom: you would also need to invent the computer so they'd have something to give them type errors
15:22:42 <msouth> the shiny machine with flickering lights is the time machine you brought the computers back in
15:22:45 <user317> is there a way to build for profiling without having all the modules build for profing as well?
15:22:51 <reltuk> @type flip .
15:22:53 <lambdabot> parse error (possibly incorrect indentation)
15:22:55 <kjdf> hm, how is (>>=) expressed in terms of fmap and join?
15:22:57 <monochrom> Oh, don't worry about that. The monastry nearby is full of clergymens glad to carry out Haskell's operational semantics by hand. :)
15:23:06 <mrd> join (fmap id)
15:23:10 <reltuk> @type flip (.)
15:23:12 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
15:23:13 <mrd> join (fmap id x)
15:23:26 <SamB> monochrom: I didn't say anything about operational semantics
15:23:28 <Saizan> m >>= f = join $ fmap f x
15:23:30 <mrd> er
15:23:32 <monochrom> I do.
15:23:34 <mrd> yea
15:23:37 <Toxaris> I don't think "0" needs extra explanation, because it is not special in Haskell
15:23:39 <SamB> I referred to typechecking only ;-)
15:23:48 <DaveCGI610> "0" is ['0']
15:23:54 <monochrom> Oh! The clergymen will do that too.
15:24:01 <SamB> how long does it take them?
15:24:03 <DaveCGI610> and ['0'] is '0' :: []
15:24:12 <Toxaris> > 0 -- this I mean
15:24:14 <lambdabot>  0
15:24:18 <reltuk> > '0' : []
15:24:20 <lambdabot>  "0"
15:24:25 <monochrom> As a bonus service, they will pray for your forgiveness when you commit type sins. :)
15:24:34 <DaveCGI610> and '0' is one of possible values of Char, and [] is one of possible values of a list
15:24:36 <Toxaris> that is, it is not more special then every other numeral, wich are special due to funny type
15:24:51 <SamB> monochrom: you mean: when you use unsafePerformIO
15:24:52 <reltuk> @type 0
15:24:54 <lambdabot> forall t. (Num t) => t
15:25:01 <monochrom> "God sees O(exp n) as O(1), O(1) as O(exp n)" is what they said. :)
15:25:04 <Toxaris> but should the Monoid documentation contain a basic introduction to Monoids?
15:25:07 <mrd> do they perform Church-style lambda calculus
15:25:28 <SamB> that reminds me of evolution
15:25:35 <DaveCGI610> Everything is O(1) for God since he's omnipresent
15:25:44 <SamB> Toxaris: it doesn't already?
15:25:56 <SamB> Toxaris: yes, it should include the Monoid laws
15:26:02 <mrd> DaveCGI610: an Oracle Turing Machine
15:26:25 <DaveCGI610> God solved the halting problem
15:27:19 <Toxaris> and the Monoid docu should include an example of how to actually use something like Product
15:27:31 <DaveCGI610> yeah .. examples are the best
15:28:15 <Toxaris> > getProduct $ mconcat $ map Product [1, 2, 3] -- maybe like this?
15:28:17 <lambdabot>  6
15:28:17 <reltuk> there's a bunch of examples in the HAppS tutorials, and those types still ended up giving me a beating
15:28:51 <reltuk> it would have been worse without the examples, I suppose
15:28:51 * SamB wonders if the Product Monoid is actually useful
15:29:05 <Toxaris> SamB: consider it's use in a Writer monad
15:29:23 <SamB> that was the only potential use I could think of, yes...
15:29:32 <mrd> ?users
15:29:32 <lambdabot> Maximum users seen in #haskell: 375, currently: 348 (92.8%), active: 24 (6.9%)
15:29:34 <SamB> but what FOR?
15:29:34 <DaveCGI610> you know you're a l33t haskell programmer when all you ever use is $ and . instead of parentheses
15:29:43 <DaveCGI610> To use parentheses is to be a LISPer. Real men use $ and .
15:29:47 <monochrom> omit that $
15:29:48 <SamB> yeah right
15:30:06 <SamB> monochrom: ... why?
15:30:14 <monochrom> pointfree programming
15:30:36 <SamB> there is no point in bothering with that...
15:30:57 <monochrom> l33t haskell programming. don't even need $. Just use . all along.
15:30:59 <DaveCGI610> I like my programming to not need a higher math background to understand enough to produce above average programs
15:31:45 <Toxaris> DaveCGI610: I like to use my a small little bit higher math background to help me program a little bit more above average programs :)
15:31:50 <DaveCGI610> monochrom: rewrite f . x . y $ z plz ? z is a value not a function
15:32:05 <DaveCGI610> monochrom: *without* doing something lame like let foo = f . x. y in foo z
15:32:10 <mrd> f (x (y z))
15:32:20 <DaveCGI610> ah no parentheses either
15:32:41 <DaveCGI610> Toxaris: sure but they dont always help
15:32:58 <monochrom> Should I spend time arguing with you on that?
15:33:04 <SamB> monochrom: no!
15:33:09 <SamB> it would be pointless
15:33:10 <Toxaris> DaveCGI610: no, not always, but with Haskell, I have to feeling that it would help more if I would know more
15:33:11 <bwx> @seen dcoutts
15:33:11 <lambdabot> I saw dcoutts leaving #ghc, #gentoo-haskell and #haskell 23h 33m 58s ago, and .
15:33:12 <DaveCGI610> monochrom: why? just tell me how you would rewrite that, cause i want to know
15:33:13 <monochrom> Hahaha
15:33:54 <Excedrin> @unpl f . x . y $ z
15:33:55 <lambdabot> (f (x (y z)))
15:34:05 <monochrom> Because it's a wrong question to ask or answer.
15:34:09 <shachaf> @pl f . x . y $ z
15:34:09 <lambdabot> f (x (y z))
15:34:15 <Toxaris> DaveCGI610: depends on the context
15:34:24 <DaveCGI610> whats the difference between @pl and @unpl
15:34:30 <mrd> @. pl unpl f . x . y $ z
15:34:30 <lambdabot> f (x (y z))
15:34:34 <shachaf> DaveCGI610: They are opposites.
15:34:39 <mrd> @. pl unpl f (x (y z))
15:34:39 <lambdabot> f (x (y z))
15:34:41 <Toxaris> there is @. ?
15:34:43 <Toxaris> cool!
15:34:44 <shachaf> @pl \x -> f x
15:34:44 <lambdabot> f
15:34:49 <DaveCGI610> @pl f (x (y z))
15:34:49 <lambdabot> f (x (y z))
15:34:51 <shachaf> @pl \x -> f 1 x
15:34:51 <lambdabot> f 1
15:34:55 <shachaf> @pl \x -> f x 1
15:34:55 <lambdabot> flip f 1
15:34:59 <shachaf> @unpl \x -> f x 1
15:35:00 <lambdabot> \ x -> f x 1
15:35:05 <shachaf> @unpl flip f 1
15:35:06 <lambdabot> (\ c -> f c 1)
15:35:08 <shapr> Oh hey, I had an interesting thought last night about how Haskell makes people more productive...
15:35:24 <DaveCGI610> um yeah, so how would you use . when you need to use $, and no parentheses are allowed either
15:35:28 <shapr> I read somewhere that research clearly shows that one way to make a programmer more productive is to give them ludicrous amounts of screen space...
15:35:57 <shapr> So last night I thought, Haskell lets you fit more content into less screen space, so it's roughly the same idea.
15:36:03 <wli> shapr: References to that please?
15:36:10 <wli> shapr: The screenspace bit.
15:36:11 <Excedrin> DaveCGI610: foo z where foo = f . x . y
15:36:25 <oerjan> DaveCGI610: f . g $ x = f $ g $ x, it's a matter of taste
15:36:28 <bos> wli: if you had lots of screenspace, you could find out for yourself!
15:36:29 <kjdf> haskell is the perl of functional languages ;)
15:36:29 <samreid> screenspace lets you put your editor window alongside reddit, which is... :-/
15:36:32 <DaveCGI610> Excedrin: cheats
15:36:35 <oerjan> and sometimes precedence
15:36:57 <mrd> haskell makes you less productive because you diddle around with haskell instead of doing work :(
15:37:17 <mrd> also i'm avoiding some code currently which takes up 2/3 of the width of my 24" monitor
15:37:19 <user317> so is there any way to make records strict?  data Foo = Foo { !foo::Int } doesn't work
15:37:20 <reltuk> > dynApp (toDyn (+) 3) (toDyn "test")
15:37:21 <lambdabot>  Couldn't match expected type `t -> Dynamic'
15:37:25 <wli> bos: Obviously I'm plotting to send that paper along to the boss so I can expense a 32"+ monitor capable of supporting preposterously high resolutions.
15:37:29 <shapr> wli: http://www-128.ibm.com/developerworks/library/it-nielsen4/?dwzone=ibm mentions the book Peopleware
15:37:32 <lambdabot> Title: Are developers people?, http://tinyurl.com/9bddk
15:37:34 <monochrom> That question is following the same reasoning as things like "how to have mutable variables in pure functional programming?"  Usually you never answer it. You ask back, what is it for? And solve that instead.
15:37:53 <mrd> wli: they generally run at 1900x1200 or maybe a 16:9 res :/
15:37:56 <DaveCGI610> mrd tats probably because you dont need to type out those super long types like System.IO.Network.InternetProtocol.ReadWrite or something
15:38:33 <Toxaris> DaveCGI610: it depends on context. pointfree style is a design style, not a mere programming style.
15:38:35 <reltuk> wli: I work with a guy who's got 30" + 24" + 2 * 19" + 15" laid out in a sort of grid in his cube
15:38:38 <DaveCGI610> monochrom: how else do you do something like CSP?
15:38:38 <mrd> user317: !Int
15:38:49 <DaveCGI610> Toxaris: whats pointfree style?
15:38:59 <user317> mrd, data Foo = Foo { foo :: !Int }?
15:39:05 <mrd> i believe so
15:39:06 <shachaf> DaveCGI610: No named variables.
15:39:23 <DaveCGI610> meaning no lets?
15:39:30 <shachaf> @go pointfree style
15:39:32 <lambdabot> http://haskell.org/haskellwiki/Pointfree
15:39:32 <lambdabot> Title: Pointfree - HaskellWiki
15:39:37 <DaveCGI610> not even for function names/arguments?
15:39:40 <shachaf> DaveCGI610: No lambdas.
15:39:42 <Excedrin> pointfree is pointless
15:39:44 <Toxaris> DaveCGI610: programming with and thinking about functions, not values
15:39:59 <user317> mrd, weird it needs a space between the :: and teh !
15:40:11 <mrd> user317: very possible.  parsing gets hairy.
15:40:13 <shapr> wli: more info: http://www.hanselman.com/blog/PermaLink.aspx?guid=9500cba0-97e3-46cd-815e-6a0ad04c77e3
15:40:16 <lambdabot> Title: Scott Hanselman's Computer Zen - Multiple Monitors and Productivity, http://tinyurl.com/2jt4jt
15:40:27 <Saizan> DaveCGI610: no named arguments in function definitions either
15:40:27 <mrd> user317: ::! maybe a valid constructor name
15:40:42 <kjdf> hm, this is interesting: http://en.wikipedia.org/wiki/Function-level_programming
15:40:45 <lambdabot> Title: Function-level programming - Wikipedia, the free encyclopedia
15:40:46 <user317> mrd, cool, thanks
15:40:57 <kjdf> A key distinction from Lisp (and other functional languages) is that Backus' language has the following hierarchy of types:
15:40:57 <kjdf>     * atoms
15:40:57 <kjdf>     * functions, which take atoms to atoms
15:40:57 <kjdf>     * Higher-order functions (which he calls "functional forms"), which take one or two functions to functions
15:40:57 <monochrom> So, here it is how I tackle "f . x . y $ z" specifically.  What do you need it for?  If you need it for "main = do z <- readLn; print . f . x . y $ z", then here is a solution: "main = interact (show . f . x . y . read)"
15:41:00 <DaveCGI610> interesting. sounds like pointfree takes some experience to gettinng used to though
15:41:01 <kjdf> ...and the only way to generate new functions is to use one of the functional forms, which are fixed: you cannot build your own functional form (at least not within FP; you can within FFP (Formal FP)).
15:42:51 <mrd> ?paste
15:42:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:42:52 <oerjan> monochrom: alternatively, main = print . f . x . y =<< readLn
15:42:59 <mrd> if you need to paste something, use that
15:43:14 <DaveCGI610> Saizan: what if you are taking functions as arguments
15:43:19 <monochrom> That's much more faithful to the original. :)
15:44:01 <shapr> wli: Lots of good info here: http://www.petefreitag.com/item/552.cfm
15:44:02 <thoughtpolice> grr. okay this might not exactly be the proper channel, but does anybody know of like a free shell provider with ssh/darcs? not having anywhere to host my repos really sucks.
15:44:02 <lambdabot> Title: Apple 30 Inch Cinema Display Boosts Productivity up to 73%
15:44:06 <Saizan> DaveCGI610: it doesn't matter, you might end up with very ugly combinations of (.) though
15:44:14 <DaveCGI610> oerjan: you can use =<< ??
15:44:19 <user317> does it make any sense to do data Foo = Foo ![Int]?
15:44:20 <mrd> thoughtpolice: if it's for haskell see darcs.haskell.org
15:44:26 <oerjan> DaveCGI610: yep, like >>= but flipped
15:44:36 <Saizan> ?src =<<
15:44:36 <lambdabot> f =<< x = x >>= f
15:44:36 <thoughtpolice> mrd: sure. :)
15:44:48 <mrd> nice palindromic definition
15:44:53 <monochrom> hahahaha
15:45:00 <DaveCGI610> wow
15:45:02 <shachaf> mrd: Not palindromic.
15:45:06 <DaveCGI610> thats neat
15:45:11 <SamB> shachaf: how so?
15:45:19 <shachaf> f =<< x = x <<= f -- Would be.
15:45:33 <shapr> hm
15:45:34 <mrd> er, yea
15:45:38 <SamB> how about this:
15:45:45 <mrd> but mirrored brackets are cooler!
15:45:49 <shachaf> > reverse "f =<< x = x >>= f"
15:45:58 <lambdabot>  "f =>> x = x <<= f"
15:46:10 <oerjan> pointfree style can get completely incomprehensible if you are threading more than one value through a set of functions
15:46:15 <shachaf> Oops, I meant that.
15:46:20 <shapr> wli: In any case, I'm buying another al1916w clone as soon as I can afford it.
15:46:28 <shachaf> Hmm, anyway.
15:46:30 <thoughtpolice> mrd: do i need to talk to anybody to get a few repos published there?
15:46:33 <Saizan> nice, if you reverse it you get a reversed definition for comonads!
15:46:35 <shachaf> No, I was right.
15:46:41 <mrd> thoughtpolice: yea i think you send an email to a guy
15:46:49 <monochrom> Big discoveries today. :)
15:46:50 <Toxaris> but (=<<) = flip (>>=) would make clearer what it is about in my eyes
15:46:52 <mrd> its there somewhere
15:47:03 <DaveCGI610> @src flip
15:47:03 <lambdabot> flip f x y = f y x
15:47:16 <DaveCGI610> is there sugar for flip?
15:47:27 <thoughtpolice> mrd: found it on the wiki. :)
15:47:56 <Toxaris> DaveCGI610: there is (`f` x)  ==  flip f x
15:48:00 <SamB> arg.
15:48:11 * SamB tried to make one with the f and the x backwards, but no...
15:48:22 <shapr> wli: I've used lots of similar tricks to maximize my usable display space. One example is to move all of the standard firefox buttons to the menubar.
15:48:27 <oerjan> user317: you probably want a newtype in that case
15:48:29 <DaveCGI610> @unpl f . x y z
15:48:30 <lambdabot> (\ c -> f (x y z c))
15:48:58 <user317> oerjan, well i want everything in the list to be strictly constructed
15:49:01 <shachaf> shapr: Have you tried vimperator?
15:49:02 <user317> and the list as well
15:49:11 * SamB wants reversal that flips brackets
15:49:25 <mrd> using xmonad maximizes space!
15:49:27 <Saizan> thoughtpolice: this days i think you should ask for an account on the community server: http://community.haskell.org/admin/account_request.html
15:49:28 <lambdabot> Title: Account Request
15:49:39 <oerjan> user317: oh, neither will work for that
15:49:41 <shachaf> mrd: Doesn't shapr use xmonad?
15:49:45 <shapr> shachaf: Of course!
15:49:48 <mrd> indubitably
15:50:06 <user317> oerjan, so do i need to use deepseq then?
15:50:07 <shapr> Here's what my moz/ff looks like: http://www.scannedinavian.com/~shae/mozbar.png
15:50:19 <oerjan> user317: something like that
15:50:43 <shachaf> shapr: Look into vimperator, if you use vim.
15:50:43 <oerjan> you could define your own list type with strict fields, of course
15:51:07 <shapr> shachaf: Nah, emacs
15:51:43 <shachaf> shapr: You might try that other one... Conkeror?
15:51:45 <mrd> turned off menu/tool/scroll bars?
15:52:42 * shachaf notices the 1px at each border of wasted space.
15:52:55 <shapr> mrd: I turned off navbar and bookmarks, but moved all the navbar stuff up to the menubar.
15:52:57 <shapr> shachaf: Oh?
15:53:05 <shapr> shachaf: Where's the 1px?
15:53:11 <shachaf> shapr: Red border.
15:53:23 <shapr> shachaf: Anyway, konq is a KDE app, and I prefer to use gnome.
15:53:27 <mrd> also, blank space between lines
15:53:35 <shachaf> shapr: Try XMonadContrib.NoBorders. :-)
15:53:37 <mrd> Conkeror is a plugin for firefox
15:53:40 <shapr> oh?
15:53:42 <shachaf> shapr: Not Konqueror.
15:53:52 <mrd> i used it for a bit.  i dunno if it's still maintained.
15:53:53 <shapr> Oh, I see.
15:53:54 <shachaf> shapr: Conkeror. Firefox extension.
15:54:01 <shachaf> I prefer vimperator.
15:54:11 <mrd> emacs keybindings and keyboard-only access to firefox
15:54:18 <shapr> That's pretty cool
15:54:30 <shapr> shachaf: Thanks, I'll use NoBorders
15:55:11 <mrd> mm, aggressive kerning and ledding to get out all those wasted spaces between letters and lines
15:55:22 <shapr> mrd: I've thought about that, but haven't gotten there yet.
15:56:32 <mrd> perhaps you can squeeze it down to 1 pixel per character -- you only need s,k,i so that's three colors.  in a pinch, black and white for s and k.
15:58:59 <desp> Data.Ix.inRange should really have the opposite order of arguments
15:59:08 <desp> right now, it's  bounds `inRange` index
15:59:50 <monochrom> haha
16:00:05 <Toxaris> or it should be named "contains" :)
16:00:54 <monochrom> No, partial apply it, then it makes sense. inRange_forMe = inRange bounds.  Then "inRange_forMe index" makes sense.
16:00:57 <kjdf> there's also http://mozless.mozdev.org/, less-like bindings (supports also other schemes), a bit less radical than conkeror and vimperator
16:00:58 <lambdabot> Title: mozdev.org - mozless: index
16:01:47 <desp> monochrom: um
16:02:10 <monochrom> You don't like it?
16:02:16 <desp> monochrom: wouldn't  inRangeForMe = (`inRange` bounds)  make sense as well?
16:03:30 <DaveCGI610> vim or emacs?
16:03:54 <kjdf> Yi!
16:03:59 <desp> TextMate
16:04:08 <DaveCGI610> for those of us not on apple koolaid
16:04:18 <kjdf> Yi!
16:04:39 <desp> DaveCGI610: and a blah to you too
16:04:43 <shachaf> DaveCGI610: As kjdf says: Yi! Or if you want something usable: Vim!
16:05:58 <Saizan> with vim you need another shell open to load your file in ghci, in emacs it's just C-c C-l!
16:06:12 <DaveCGI610> whats with the exclamation marks
16:06:18 <shachaf> Saizan: With vim you can use ^Z.
16:06:41 <shachaf> Saizan: Oh, ghci with :r, you mean?
16:06:46 <Saizan> shachaf: yeah
16:07:00 <shachaf> Saizan: Well, vim is just an editor.
16:07:02 <olsner> screen+vim
16:07:07 <dolio> emacs has sexier haskell indenting.
16:07:14 <dolio> But I've been using vim for a while now.
16:07:28 <DaveCGI610> i've been using vim too and it doesnt seem that hot for functional language editing
16:07:33 <shachaf> Emacs is a full OS that also includes a reasonable (I hear) editor called VIPER.
16:07:49 <shachaf> DaveCGI610: You must've been misusing it.
16:07:58 <olsner> Error: Joke too old ;-)
16:08:07 <Saizan> nah, i don't think i can load emacs on bare metal
16:08:21 <shachaf> DaveCGI610: Vim is for *text* editing.
16:08:36 <DaveCGI610> shachaf: ha
16:08:49 <dolio> The cyclic indenting is about the only thing I miss, though, and it's not that big a deal.
16:08:54 <shachaf> DaveCGI610: What?
16:09:05 <shachaf> DaveCGI610: Vim takes a while to learn.
16:09:07 <fnord123> you guys dont use metrowerks?
16:09:28 * shachaf waits for someone to pull out the "learning curves" graphs.
16:10:00 <monochrom> The learning curve graph for Haskell is discontinuous.
16:10:10 <DaveCGI610> i used vim for ocaml and it tried to be too smart, and i hated not being able to get into the interpreter right away
16:10:53 <DaveCGI610> too smart for indenting and putting newlines*
16:13:33 <DaveCGI610> i guess im just wondering if vim/emacs have any haskell-specific things that make it easier to program
16:14:18 <msouth> Saizan: there are several secondary bootloaders to choose from, linux, bsd, etc.
16:14:36 <msouth> also error joke too old, I know.
16:14:47 <msouth> tty'all8r, gotta drive
16:14:56 <MarcWeber> DaveCGI610: They themselves don't But some people have written those things. I've written some tools for vim. Googling the haskelcafe should reveal much more stuff (or search the wiki)
16:16:29 <MarcWeber> shachaf: *lol* VIPER is just a vim like keybinding mode for emacs..
16:16:51 <shachaf> MarcWeber: I know. :-)
16:30:48 <glguy> @quot3e
16:30:48 <lambdabot> swiert says: Of course! Who can live without covariant homfunctors?
16:31:08 <oerjan> @quiet
16:31:08 <lambdabot> Not enough privileges
16:35:42 <Saizan> @quote
16:35:42 <lambdabot> erg0t says: lambdabot, tu nick seria el nombre ideal para un postre
16:35:56 <Saizan> @quote
16:35:56 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
16:36:07 <Saizan> ?
16:36:11 <sorear> somebody mistook @remeber for @where+
16:36:13 <sorear> @uptime
16:36:13 <lambdabot> uptime: 4d 12h 8m 5s, longest uptime: 1m 10d 23h 44m 29s
16:36:23 <glguy> @quote
16:36:23 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
16:36:32 <sorear> @forget ghci.debugger http://haskell.org/haskellwiki/Ghci/Debugger
16:36:33 <lambdabot> Unknown command, try @list
16:36:35 <sorear> aww
16:36:43 * sorear waits for his patch to be applied
16:36:46 * glguy wonders, is that the definition of irony?
16:38:11 <shachaf> @quota
16:38:12 <lambdabot> RyanT5000 says: i wish i had been programming in haskell for 7 years rather than C++
16:38:45 <lament> quota?
16:39:07 <oerjan> ergot: lambdabot, a dessert? (i don't know much spanish but i looked up "postre")
16:39:57 <lament> (lambdabot would be the ideal name for a dessert)
16:40:17 <lament> @quote
16:40:17 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
16:40:23 <oerjan> that's what i thought it meant, i just don't see how it could be true
16:40:54 <lament> me neither, even in spanish
16:41:12 <olsner> @quote dessert
16:41:12 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
16:41:21 <DaveCGI610> @quota
16:41:21 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
16:42:01 <DaveCGI610> Bjarne is right. I got bored with writing boiler plate C++ and wrote a code generator
16:42:13 <DaveCGI610> im sure i spent more time then writing the boiler plate, but who cares right :)
16:42:57 <shachaf> That's like [x,xs], where xs is unevaluated.
16:43:05 <shachaf> It should be x:xs.
16:43:58 <sorear> The other advantage is that you can bail quickly.  Retargeting my Unlambda compiler from Haskell to O'Caml took maybe two hours, counting the time it took to learn enough O'Caml.
16:44:19 <DaveCGI610> Unlambda?
16:44:39 <sorear> @go unlambda
16:44:41 <lambdabot> http://www.madore.org/~david/programs/unlambda/
16:44:42 <lambdabot> Title: The Unlambda Programming Language
16:44:49 <DaveCGI610> sorear: you didnt have any problems with going from lazy to eager?
16:45:33 <wli> Why Unlambda?
16:45:35 <sorear> CPS-conversion (which I had to do anyway because of the 'c' primitive) effaces most of the differences between evaluation order.
16:46:13 <sorear> wli: I wanted to be sure I actually knew how to do it
16:46:16 <DaveCGI610> sorear: oh your whole thing was done in cps? how unsurprising
16:46:29 <DaveCGI610> what is a 'c' primitive?
16:46:39 <wli> A particular combinator.
16:46:50 <shachaf> DaveCGI610: See the link.
16:47:20 <lament> c is perhaps not exactly a combinator
16:47:37 <DaveCGI610> sorear: ahhhh, i am an idiot. your compiler makes haskell or ocaml code, what is it actually written in? :)
16:48:09 * oerjan hazards a guess it's not written in unlambda
16:48:12 <sorear> DaveCGI610: 10 lines of Haskell.  All the fanciness is in the implementation of the primitives
16:48:30 <hpaste>  (anonymous) pasted "lexer" at http://hpaste.org/2179
16:48:32 <DaveCGI610> 10 lines? sounds like most of the 2 hours was learning ocaml
16:49:09 <lament> i highly suspect those 10 lines are about as readable as unlambda itself
16:49:33 <DaveCGI610> jesus. i just fainted from looking at the unlambda examples
16:49:39 <sorear> I had to change "module Main where { import Runtime; main = runU(" to "open Runtime;; runU(" and ")}" to ")"
16:49:54 <qwr> unlambda is really simple :P
16:50:13 <DaveCGI610> yeah easy to write im sure
16:50:15 <sorear> unlambda can be implemented as a combinator library, even with D
16:50:50 <wli> sorear: That's a bit different from what I thought of as a compiler.
16:51:06 <sorear> wli: well, after ghc -O2 -funfolding-use-threshold=1000 -funfolding-creation-threshold=1000 things look a little differnt
16:51:14 <tsp> why did they let the ' be a part of variable names?
16:51:34 <lament> who did?
16:51:39 <wli> sorear: I presume that unravels the whole thing to the maximum extent possible.
16:51:48 <DaveCGI610> hmm, yeah, compilers usually involve lexing, parsing, tree anlysis, etc
16:51:53 <oerjan> tsp: i guess because mathematical variables are often called x' and such
16:51:54 <tsp> lament: the haskell creators
16:52:24 <sorear> these combinators compile to site-specific machine code, relying on GHC to do <eta> retuction
16:52:27 <sorear> wli: yeah
16:52:33 <tsp> oerjan: heh, I thought it had something to do with lojban
16:52:42 <lament> tsp: hahaha
16:52:42 <Saizan> tsp: because mathematicians like it
16:52:47 <tsp> since the ' is a letter in that language
16:53:03 <wli> sorear: Might that sort of thing be useful for unraveling monadic code to a greater extent?
16:53:03 <lament> at least they took inspiration from lojban, not esperanto
16:53:13 <lament> or we'd have weird dots all over (and under) letters
16:53:24 <lament> s/dots/hats
16:54:05 <tsp> lament: Cxu vi parolas esperanton?
16:54:26 <tsp> heh utf-8 variable names would be interesting
16:54:41 <sorear> wli: I think the Right Thing to have done would have been a bunch of {-# INLINE #-} pragmas, but setting the inline thresholds to 1000 came to my fingers faster ;)
16:54:46 <xpika> where is the list monad defined?
16:54:48 <sorear> we have them.
16:54:52 <oerjan> sorear: sounds like your unlambda compiler may be similar to mine, then, except i never had optimization enough to make it efficient
16:54:57 <lament> tsp: it's not "Cxu", it's some weird letter with a weird hat over it :)
16:55:02 <lament> tsp: (and no)
16:55:41 <tsp> cx == wahtever that thing is that nothing can type
16:55:42 <wli> sorear: Still, would that sort of thing help with speeding up monad transformer code?
16:56:03 <Lemmih> tsp: utf-8 variables: http://darcs.haskell.org/~lemmih/HideUnicodePretty.png
16:56:23 <lament> is that emacs?
16:56:30 <Lemmih> Nope, hIDE2.
16:56:43 <DaveCGI610> oh yeah im totally doing points-free programming
16:56:48 <oerjan> xpika: the Prelude i assume
16:57:19 <reltuk> uggh....why must ssh + screen + emacs never get my terminal/backspace/etc. settings correct?
16:57:24 <DaveCGI610> @pl f x = x + 1
16:57:24 <lambdabot> f = (1 +)
16:57:25 <lament> is hIDE2 usable?
16:57:31 <tsp> reltuk: set them in .zshrc and forget them :)
16:57:37 <sorear> wli: Probably not.  GHC needs to be able to see the code in order to inline it; I beleive you said that mtl has no unfoldings whatsoever
16:57:39 <DaveCGI610> @unpl = f = (1 +)
16:57:40 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
16:57:49 <DaveCGI610> @unpl f = (1 +)
16:57:49 <lambdabot> f a = 1 + a
16:58:02 <olsner> wow, does @pl know about things like the associativity of +?
16:58:11 <shachaf> olsner: Commutativity.
16:58:15 <wli> sorear: I haven't said anything about unfoldings of mtl; I don't know anything relevant about it.
16:58:19 <glguy> olsner: it makes the unfortunate assumption of commutativity
16:58:25 <Lemmih> lament: Unfortunately not. It was discontinued quite a while ago and is now completely bitrotten.
16:58:28 <olsner> read what I mean and not what I write ;-)
16:58:35 <sorear> oerjan: And yes, it's hacked into the code.
16:58:37 <DaveCGI610> @pl \x y -> x y
16:58:37 <lambdabot> id
16:58:56 <lament> Lemmih: :(
16:59:24 <DaveCGI610> @src const
16:59:24 <lambdabot> const x _ = x
16:59:52 <DaveCGI610> @src zipWith
16:59:52 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:59:52 <lambdabot> zipWith _ _      _      = []
17:00:28 <DaveCGI610> is that like a map for two lists?
17:00:52 <oerjan> @pl f x = x `op` y
17:00:52 <lambdabot> f = (`op` y)
17:01:17 <TSC> DaveCGI610: Sort of
17:03:19 <shachaf> @. un pl f x = x `plus` 1
17:03:19 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "un"
17:03:24 <DaveCGI610> im handing in all my homework written in pointfree style
17:03:27 <shachaf> @. unpl pl f x = x `plus` 1
17:03:27 <lambdabot> f a = plus a 1
17:04:01 <glguy> @type zipWith
17:04:03 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:04:09 <glguy> @djinn (a -> b -> c) -> [a] -> [b] -> [c]
17:04:10 <lambdabot> -- f cannot be realized.
17:04:31 <DaveCGI610> all i need to do is write functions which take no arguments and dont use lambdas right?
17:04:35 <olathe> No wonder I never realized.
17:04:35 <shachaf> @djinn (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
17:04:36 <lambdabot> f a b c =
17:04:36 <lambdabot>     case b of
17:04:36 <lambdabot>     Nothing -> Nothing
17:04:36 <lambdabot>     Just d -> case c of
17:04:36 <lambdabot>               Nothing -> Nothing
17:04:38 <lambdabot>               Just e -> Just (a d e)
17:05:04 <shachaf> That looks right?
17:05:08 <glguy> sure
17:05:27 <DaveCGI610> what does @djinn do
17:05:35 <glguy> @help djinn
17:05:36 <lambdabot> djinn <type>.
17:05:36 <lambdabot> Generates Haskell code from a type.
17:05:36 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:05:39 <TSC> Writes a function for a given type
17:05:49 <shachaf> DaveCGI610: Proves a type.
17:06:14 <olathe> How do you read its output as a proof ?
17:06:27 <sorear> @go Curry-Howard Isomorphism
17:06:28 <glguy> it is a witness proof
17:06:29 <lambdabot> http://en.wikipedia.org/wiki/Curry-Howard_isomorphism
17:06:29 <lambdabot> Title: CurryHoward - Wikipedia, the free encyclopedia
17:06:37 <shapr> @where epigram
17:06:37 <lambdabot> http://www.e-pig.org/
17:06:46 <shapr> Where's the Epigram2 darcs repository?
17:06:51 <sorear> It's an implementation of the LJT decision-procedure for contractionless intuitionistic sequent calculus. :)
17:06:55 <HWSOD> how do i turn "instance (Num a, Ix i, Show i) => Num (Array (i, i) a)" in to a legal instance declaration?
17:06:55 <qwr> @djinn a -> b
17:06:56 <lambdabot> -- f cannot be realized.
17:07:10 <shachaf> @djinn a -> a -> a
17:07:10 <lambdabot> f _ a = a
17:07:22 <olathe> So, it gives an example function given the type of the function ?
17:07:23 <sorear> HWSOD: You don't.  What's the signum of a matrix?
17:07:30 <olathe> (to prove that the function is possible)
17:07:36 <shachaf> @djinn (a -> a) -> a
17:07:36 <lambdabot> -- f cannot be realized.
17:07:40 <Sgeo> @djinn Maybe (b -> Either a b)
17:07:41 <lambdabot> f = Nothing
17:07:43 <Sgeo> meh
17:07:44 <sorear> HWSOD: The haskell numeric classess are far too course-grained for that to work :(
17:07:48 <Sgeo> That's not what I wanted
17:07:55 <shachaf> @djinn b -> Either a b
17:07:55 <lambdabot> f = Right
17:08:07 <oerjan> contractionless? does that mean there are intuitionistic theorems which are not types because they need contraction?
17:08:09 <shapr> @where+ epigram2 http://sneezy.cs.nott.ac.uk/darcs/epigram/
17:08:09 <lambdabot> Done.
17:08:11 <shachaf> @djinn Either q (b -> Either a b)
17:08:11 <lambdabot> f = Right Right
17:08:19 <sorear> Sgeo: @djinn is deterministic.  it doesn't change it's answer just because you waited a few months :)
17:08:57 <shachaf> sorear: A different @djinn could be here in a few months, though. :-)
17:09:04 <sorear> oerjan: Contractionless formulations of sequent calculus are equivalent in power to the contractionful cutful formulations, although the proof is rather involved (Gentzen's Theorem)
17:09:13 <HWSOD> what does @djin do any way?
17:09:27 <DaveCGI610> wow.... thats crazy
17:09:29 <glguy> serious?
17:09:30 <olathe> @djinn (a -> a -> a) -> [a] -> [a] -> [a]
17:09:30 <lambdabot> f _ _ a = a
17:09:30 <shachaf> HWSOD: Read up.
17:09:34 <oerjan> oh. i only knew about cutless.
17:09:40 <sorear> HWSOD: Decides intuitionistic provability of a formula in the first-order propositional calculus.
17:09:42 <DaveCGI610> type proofs? sounds complex
17:10:13 <Sgeo> My knowledge of this sort of thing is only enough to make bad puns :/
17:10:21 <Sgeo> erm, a bad pun
17:10:22 * glguy wonders if a whole bunch of the lines in this channel are getting lost...
17:10:23 <Sgeo> lol
17:10:29 <puusorsa> monochrom, good enough is the enemy of excellent
17:10:32 <sorear> On the other hand, intuitionism IS a restriction.
17:10:38 <sorear> @djinn Either a (Not a)
17:10:38 <lambdabot> -- f cannot be realized.
17:10:55 <sorear> No law of excluded middle!
17:10:59 <Sgeo> @djinn Not a
17:11:01 <lambdabot> -- f cannot be realized.
17:11:07 <Sgeo> WTF is Not?
17:11:12 <sorear> @djinn-env
17:11:12 <lambdabot> data () = ()
17:11:12 <lambdabot> data Either a b = Left a | Right b
17:11:12 <lambdabot> data Maybe a = Nothing | Just a
17:11:12 <lambdabot> data Bool = False | True
17:11:12 <lambdabot> data Void
17:11:14 <lambdabot> type Not x = x -> Void
17:11:18 <lambdabot> class Eq a where (==) :: a -> a -> Bool
17:11:35 <Sgeo> oh.....hm?
17:11:42 <shachaf> type Not x = forall a. x -> a, I think?
17:11:45 <shachaf> Oh.
17:12:16 <Sgeo> @djinn Either a Void
17:12:16 <lambdabot> -- f cannot be realized.
17:12:29 <Sgeo> Isn't "Not a" in a type just Void then?
17:12:30 <monochrom> puusorsa: what was the context? I forgot.
17:12:45 <Sgeo> @djinn Either a (Not b)
17:12:46 <lambdabot> -- f cannot be realized.
17:12:46 <oerjan> @djinn Not Void
17:12:46 <lambdabot> f a = a
17:12:53 <dolio> Huh, @djinn got cleaned out a bit, too.
17:13:07 <Sgeo> @djinn Not a
17:13:08 <lambdabot> -- f cannot be realized.
17:13:26 <puusorsa>           in 2, apparently no one has ever complained, so it may be good enough for most people.
17:13:28 <shachaf> @djinn a -> Not (Not a)
17:13:29 <lambdabot> f a b = b a
17:14:01 <puusorsa> 2h8min ago
17:14:04 * Sgeo mindsplodes in noncomprehension
17:14:14 <Sgeo> Maybe I should write the stuff down
17:14:18 <dolio> @djinn Not (Not a) -> a
17:14:18 <glguy> AC, that you?
17:14:18 <lambdabot> -- f cannot be realized.
17:14:20 <oerjan> Sgeo: Not is essentially continuation passing style
17:14:26 <olathe> What ?
17:14:31 <Sgeo> oerjan, that just made it more confusing >.>
17:14:40 <puusorsa> http://kotaku.com/gaming/clips/minesweeper-the-movie-286639.php
17:14:41 <Sgeo> What's "continuation passing style"?
17:14:42 <lambdabot> Title: Minesweeper: The Movie - Kotaku
17:14:45 <olathe> How does @djinn a -> Not (Not a) turn into f a b = b a ?
17:15:08 <monochrom> By "Not a  a -> Void"
17:15:23 <dolio> a -> (Not a -> Void) ==> a -> ((a -> Void) -> Void)
17:15:31 <shachaf> monochrom: What was that (no Unicode here)?
17:15:34 <olathe> O-o
17:15:34 <monochrom> a -> (a -> Void) -> Void
17:15:43 <monochrom> the congruence symbol
17:15:55 <shachaf> monochrom: Oh.
17:16:02 <sorear> Sgeo: A  A is a valid formula in classical logic, but not in intuitionistic logic, so djinn can't prove it
17:16:09 <olathe> What does f a b = b a have to do with all that, though ?
17:16:12 <oerjan> Sgeo: Void is a type that can never be produced but if you happen to have it from somewhere else you can return it.  So Void -> Void is possible (and equal to Not Void)
17:16:40 <monochrom> Note that a -> (a -> Void) -> Void can be satisfied by flip ($).  Well that's f a b = b a.
17:16:59 <monochrom> recall flip ($) :: a -> (a -> b) -> b
17:17:12 <sorear> Void is the impossible proposition, sometimes known as falsity or absurdity.  The ability to prove Void means that your assumptions contradict each other.
17:17:12 <Sgeo> sorear, intuitionistic logic?
17:17:25 <shapr> Can cabal do preprocessors?
17:17:55 <sorear> shapr: easily, as long as you use a pre-approved preprocessor
17:18:03 <shachaf> sorear: You can also use forall a. a, right?
17:18:08 <sorear> c2hs, hsc2hs, greencard, cpphs, probably a few others
17:18:09 <monochrom> The Monad Reader issue 6 has an article on all this. http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
17:18:17 <sorear> shachaf: Not in djinn's first-order logic
17:18:23 <shapr> sorear: Well, I want to use a custom preproc, does that work?
17:18:32 <sorear> no :(
17:18:40 <shapr> At least, I don't think Higgledly is a pre-approved preprocessor.
17:19:10 <oerjan> @go intuitionistic logic
17:19:10 <sorear> shapr: if you're willing to restrict yourself to GHC, Ghc-options: -pgmF foobar  works
17:19:11 <lambdabot> http://plato.stanford.edu/entries/logic-intuitionistic/
17:19:11 <lambdabot> Title: Intuitionistic Logic (Stanford Encyclopedia of Philosophy)
17:19:17 <shapr> I'll try that, thanks.
17:19:54 <shapr> Oh, but I only want to apply it to some files :-/
17:20:03 <shapr> ghc-options works for every file, right?
17:20:24 <sorear> yeah...
17:20:34 <shapr> foo
17:20:36 <sorear> BotPP is designed to be the identity on most files
17:21:27 <sorear> (I do think it was mostly written out of NIH, however - what it does is simple enough even for M4)
17:22:03 <shapr> Sucks that cabal doesn't handle custom preprocs though.
17:22:34 <Lemmih> shapr: It does.
17:22:36 <eivuokko> Huh?  It does, via hooking in setup.hs
17:22:57 <shapr> Oh, how?
17:23:08 * shapr asks google
17:23:24 <HWSOD> why cant you just define the abs of a matrix to be the identity and signum to be id?
17:25:46 <dolio> You could define abs and signum for matrices to be anything you want.
17:26:27 <dolio> As far as Haskell is concerned.
17:26:58 <oerjan> HWSOD: you could make them "undefined" if you don't have a sensible definition
17:27:37 <SamB_XP> you could just leave them as-is, even
17:28:01 <oerjan> SamB_XP: huh?
17:28:05 <wli> At some point some rewrite of the numeric hierarchy needs to be merged.
17:28:20 <SamB_XP> not implement them at all
17:28:40 <oerjan> SamB_XP: that's equivalent to undefined, i guess, but you might get a warning
17:29:05 <HWSOD> Sam: that wont compile i think. or will it
17:29:07 * wli likes to throw informative error messages in there.
17:29:35 <wli> abs m = error $ "Matrix.Num.abs: tried to take absolute value of matrix " ++ show m
17:29:51 <oerjan> HWSOD: i think i read that it was allowed
17:30:38 <wli> shapr: That's a great link. I'm shopping for 32" monitors now.
17:32:03 <shapr> wli: Boss funded?
17:32:27 <wli> shapr: Doubtful. I don't care, though.
17:33:01 <shapr> heh
17:33:31 <sjanssen> yikes, how much is a 32" monitor?
17:33:57 <wli> froogle suggests $1700+
17:34:55 <shapr> newegg has 'em for ~1000
17:34:58 <sjanssen> newegg has a couple for just under 1k
17:35:18 <wli> I'd be worried about dpi, resolution, quality, and longevity of the cheaper ones.
17:35:52 <sjanssen> most of these seem more TV oriented
17:36:14 <sjanssen> eg. 32" monitor with only 1366 x 768 resolution
17:36:14 <shapr> I can barely afford a 24" monitor.
17:36:15 * dolio has a very nice 24" Dell monitor.
17:36:45 <wli> sjanssen: Yeah, that's a non-starter.
17:37:04 <sjanssen> wli: have you found any with a respectable resolution?  newegg doesn't have any
17:37:15 <dolio> The Dell monitors use the same LCD panel as the Apple cinema displays, I think.
17:37:16 <falconair> sjanssen, just saw your comment about 32 inch monitor, I think the largest size for computer specific monitors is 30 inch ... I'm on a dell 30 inch right now and it is quite nice...although a couple of 24s would have their own benefit
17:38:32 <wli> sjanssen: froogle doesn't seem to have any.
17:38:43 <wli> falconair: Better that I search for 30" then.
17:39:46 <shapr> Is 1920x1200 the max res for a dual-link DVI-D?
17:39:56 <wli> falconair: What's the resolution on it?
17:40:05 <dolio> That's the max for single-link, isn't it?
17:40:08 <falconair> wli, I'm quite happy with it, I usually run it with an apple laptop ... but I've discovered that having two separate monitors may be even better..you can nicely divide your apps
17:40:32 <falconair> 2560x1600
17:40:40 <wli> falconair: Got a URL for where I can order one?
17:40:57 <shapr> dolio: Yes, you're right. That's single. I wonder why all these 24" monitors only do single-link resolution?
17:41:01 <falconair> i think i got mine from ebay a while ago
17:41:27 <sjanssen> bonus points for anyone that can deliver a screenshot of xmonad running on one of these 30" behemoths
17:41:32 <shapr> falconair: That's for dual-link.
17:41:34 <dolio> shapr: Even mine is only 1920x1200. Only laptop screens seem to get the really nice DPI.
17:42:08 <wli> falconair: Only $1300. I might as well get 2.
17:42:11 <dolio> shapr: Unless you're willing to spend crazy money on the 200dpi Viewsonic/IBM one.
17:42:20 <falconair> yeah, it is dual link, and yes, the first day i was slightly disappointed to see my laptop had better resolution
17:42:38 <reltuk> quit
17:42:48 <shapr> falconair: Your laptop does better than 2560x1600?
17:42:53 <wli> dolio: shapr's URL says 200dpi increases productivity 20%
17:42:53 <falconair> it is actually very convenient to have a small laptop screen next to the monitor, i can move #haskell or ghci off to it when i'm not actively using it
17:43:37 <dolio> wli: Is it worth $10,000? :)
17:44:00 <falconair> shapr: my monitor seems to have more dense pixels per square inch than my big monitor, but the output from my laptop is (i believe) limited to 2560x1600
17:44:17 <shapr> wli: That turns out to be about 9.5 inches across for max single-link DVI resolution of 1920.
17:44:54 <wli> dolio: $10K is far enough up there that the tradeoff leans toward putting it to use elsewhere.
17:45:02 <shapr> wli: And about 12.8 inches across for max dual-link DVI res of 2560x1600
17:45:21 <dolio> I guess the viewsonic one is only $8,000. Or was at its debut. :)
17:45:32 <wli> shapr: Dual link DVI I might have to get a new video card for.
17:46:00 <shapr> What card do you have?
17:46:10 <glguy> "is only"
17:46:21 <dolio> glguy: The IBM one was even more.
17:48:31 <dolio> I think it was the same LCD panel, but Viewsonic was selling to home users or something.
17:48:39 <dolio> IBM to corporations, probably.
17:48:52 <dolio> So IBM charged like like twice as much.
17:52:08 <shapr> Aha, there are two monitors on newegg that support dual-link max res, one for $1300, and one for $1500.
17:53:07 <shapr> mmm: http://www.newegg.com/Product/Product.aspx?Item=N82E16824001098
17:53:08 <lambdabot> Title: Newegg.com - SAMSUNG SyncMaster 305T Black 30" 6ms(GTG) DVI Widescreen LCD Monit ...
17:54:24 <wli> shapr: NV37e, whatever that is.
17:54:42 * shapr laughs: "I had to crank up the acceleration on my mouse to deal with all this extra screen real estate."
17:56:03 <shapr> wli: That doesn't help much, what do you get from "cat /proc/driver/nvidia/cards/0" ?
17:56:13 <mphill22>           dsum n = let ( d, m ) = n `divMod` 10 in m + ( dsum d )
17:56:22 <mphill22> can someone explain to me whats going on in this line of code
17:56:51 <dolio> > 123 `divMod` 10
17:56:53 <lambdabot>  (12,3)
17:57:21 <dolio> So, d is n `div` 10 (integer division).
17:57:39 <dolio> m is the least significant digit.
17:57:50 <monochrom> dsum 123 = 3 + dsum 12 = 3 + (2 + dsum 1) = etc
17:58:10 <dolio> So, essentially, it's computing the sum of the digits.
17:58:16 <monochrom> Where is the base case? :)
17:58:29 <mphill22> hah the line i didnt paste, dsum 0 = 0.
17:58:36 <wli> shapr: No such /proc/ file; I'm using the open source drivers.
17:58:38 <monochrom> Ok, that's good.
18:01:25 <oerjan> @pl \d m -> m + dsum d
18:01:26 <lambdabot> (+) . dsum
18:03:14 <oerjan> > let dsum 0 = 0; dsum n = uncurry ((+).dsum).(`divMod`10) $ n in dsum 138
18:03:16 <lambdabot>  12
18:04:50 <TSC> > let dsum = sum . map digitToInt . show in dsum 138 -- slow way
18:04:51 <lambdabot>  12
18:09:07 <oerjan> > let dsum = sum . map snd . takeWhile ((/=0).fst) . iterate ((`divMod` 10).fst) . flip (,) 0 in dsum 138
18:09:09 <lambdabot>  11
18:09:22 <oerjan> o_O
18:09:42 <kpreid> What do you call the typeclass whose sole function is "fold :: (a -> a -> a) -> c a -> a"?
18:09:57 <oerjan> @src Foldable
18:09:58 <lambdabot> Source not found. That's something I cannot allow to happen.
18:10:02 <kpreid> (and does it exist in GHC's standard libraries?)
18:10:21 <oerjan> @index Foldable
18:10:21 <lambdabot> bzzt
18:10:23 <Lemmih> kpreid: It's in Data.Foldable.
18:10:41 <kpreid> hm, I don't have that
18:10:42 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2182
18:11:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2183
18:11:29 <kpreid> no, Foldable isn't this
18:11:59 <kpreid> Foldable with just foldMap would be equivalent, though
18:11:59 <Lemmih> kpreid: Oh?
18:12:24 <kpreid> Lemmih: it requires left and right folds.
18:12:38 <kpreid> hmm...
18:12:46 <kjdf> "Minimal complete definition: foldMap or foldr.
18:12:47 <kjdf> "
18:12:49 <sjanssen> kpreid: foldMap is the minimal definition
18:13:08 <kpreid> mm, yes, you can build foldl/r out of that
18:13:10 <kpreid> ah
18:13:13 <sjanssen> the library achieves foldl and foldr through special monoid instances
18:13:20 <kpreid> ah: mine doesn't require mempty
18:13:30 <wli> sjanssen: Which is this?
18:13:33 <kpreid> ...not that that's a big deal
18:13:40 <sjanssen> kpreid: how is your function possible?
18:13:48 <sjanssen> kpreid: where does the initial 'a' come from?
18:13:59 <kpreid> sjanssen: an arbitrary instance
18:14:04 <kpreid> er, member
18:14:14 <kpreid> @type foldr1
18:14:16 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:14:27 <kpreid> foldr1 would be the list instance
18:14:44 <sjanssen> you could use the Maybe monoid, and call fromJust at the end
18:14:56 <kpreid> (but in practice I'm using it for fixed-size objects)
18:15:35 <kpreid> I don't really want to install a new ghc just to avoid defining a typeclass in my program :)
18:15:50 <kpreid> so I'll just say class Foldable' ...
18:15:53 <wli> Hmm.
18:15:59 <sjanssen> you're still on 6.4?!?!?! :P
18:16:50 <kpreid> hs-plugins has been updated for 6.6, right?
18:16:59 <shachaf> kpreid: I don't think so.
18:17:29 <wli> let { mkDigits :: Integer -> [Word16] ; mkDigits m | m < radix = [r] | otherwise = r : mkDigits q where { q, radix :: Integer ; r :: Word16 ; (q, r)  = second fromIntegral $ m `quotRem` radix ; radix = 2^(16 :: Int) } }
18:17:45 <wli> That's kind of backward from what I wanted.
18:18:24 <dolio> I think dons said that hs-plugins from darcs works on 6.6.
18:19:08 <shachaf> dolio: Oh.
18:19:12 <shachaf> Never mind, then.
18:19:41 <HWSOD> how do i turn "instance (Num a, Ix i, Show i) => Num (Array (i, i) a)" in to a legal instance declaration? it doesnt compile.
18:20:07 <sjanssen> HWSOD: hmm, looks okay at first glance.  What's the error message?
18:20:24 * dolio guesses that -fglasgow-exts is the solution.
18:20:36 <sjanssen> oh, you might be missing Show a, Eq a
18:21:04 <dolio> Num a should cover that.
18:21:09 <sjanssen> oh, right
18:21:36 <sjanssen> oh, yes.  It will be solved by -fglasgow-exts
18:21:44 <sjanssen> what you have here is a "FlexibleInstance"
18:22:52 <oerjan> sjanssen: Num a implies those
18:22:53 <sjanssen> Haskell '98 says that instances must be of the form "T a b c ..." where T is a type constructor and a, b, c ... must be type variables
18:23:21 <HWSOD> yup that one (@sjanssen)
18:23:23 <chessguy> 'evening
18:23:24 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
18:23:51 <shachaf> chessguy: I think chessguy_ also has a message. :-)
18:24:04 <chessguy_> oh really?
18:24:04 <lambdabot> chessguy_: You have 1 new message. '/msg lambdabot @messages' to read it.
18:24:08 <chessguy_> hey, whaddya know
18:24:19 <chessguy_> @messages
18:24:19 <lambdabot> chessguy said 8h 30m 4s ago: http://hpaste.org/2175
18:24:23 <HWSOD> Thanks!
18:27:06 <slava> what is the rule that states that ((lambda (x) (f x)) y) == (f y)?
18:27:17 <slava> alpha-reduction? beta-reduction? :)
18:27:21 <sorear> -reduction
18:27:22 <wli> eta
18:27:42 <wli> woops no that's beta
18:27:52 <sorear> actually it could be both
18:28:11 <wli> point
18:28:26 <sorear> : (x. e) v  ==>  e [x := v]
18:28:55 <sorear> : (x. e x)  ==>  e
18:29:29 <sorear> : (x. e)    ==> (y. e [x := y])
18:29:47 <sorear> : let x = y in c  ==> c [x := y]
18:30:21 <sorear> (that last one is from one specific system, memory error)
18:30:39 <wli> Recursive let breaks.
18:30:47 <oerjan> hindley-milner perhaps?
18:31:02 <wli> c [ x := let x = y in y ] perhaps?
18:31:55 <sorear> wli: The "specific system" in question is total and does not have recursive lets.  Proof of excessive specificity :)
18:32:55 <wli> How does one arrange for a total system with recursive types (e.g. lists)? Hmm.
18:34:05 <sorear> wli: Structural induction.  In informal math, you're allowed to say (if P is true of 0, and P x implies P (x+1), then P n for all naturals n)
18:34:09 <oerjan> wli: you represent lists by their folding functions
18:34:14 <oerjan> for example
18:34:37 <wli> More about this later.
18:34:51 <sorear> Unfortunately, church encoding breaks with dependant types...
18:36:01 <oerjan> sorear: how so?
18:37:30 <HWSOD> arrays have to be finite, right?
18:37:36 <sorear> yes
18:39:09 <HWSOD> then fromInteger doesnt make sense either.
18:48:31 <pchiusano> hello
18:49:15 <reltuk> hi
18:50:15 <sorear> oerjan: I'm not extremely familiar with the details, but Gerard and Huet's Calculus of Constructions augmented with algebraic types can prove the consistency of the plain Calculus of Constructions, so Gdel's second incompleteness theorem suffices to prove the inequivalence of the two systems
18:50:43 <pchiusano> > :t putStr
18:50:43 <lambdabot>  Parse error
18:51:07 <pchiusano> so, putStr has type String -> IO ()
18:51:14 <sorear> @type putStr
18:51:16 <pchiusano> what happens if I do:
18:51:16 <lambdabot> String -> IO ()
18:51:48 <pchiusano> fst (42, putStr "aha! I've snuck in a side effect!")
18:51:57 <shachaf> pchiusano: No side effect.
18:52:12 <shachaf> pchiusano: Even if the putStr was evaluated, which it's not, because of laziness.
18:52:16 <pchiusano> > fst (42, putStr "w00t")
18:52:17 <lambdabot>  42
18:52:18 <oerjan> >  fst (42, putStr "aha! I've snuck in a side effect!")
18:52:19 <lambdabot>  42
18:52:39 <shachaf> pchiusano: *Executing* IO actions, not *evaluating* them, runs the side effect.
18:52:45 <pchiusano> but, is the laziness guaranteed?
18:52:47 <shachaf> pchiusano: It's an important distinction.
18:52:49 <dolio> > (42, putStr "Zoom.")
18:52:51 <lambdabot>  (42,<IO ()>)
18:52:56 <shachaf> pchiusano: This doesn't even have to do with laziness.
18:52:56 <pchiusano> whats the difference?
18:53:10 <shachaf> > replicate 5 (putStrLn "!")
18:53:11 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
18:53:44 <shachaf> pchiusano: You can pass a side effect around, treat it like a normal value (which it is).
18:53:50 <sorear> pchiusano: you could think of IO () as being sorta like () -> (), except wrapped in an opaque type so that you can't ever get at the side effect, all you can do is make big side effects from small ones
18:53:52 <oerjan> sorear: oh, i thought the calculus of inductive constructions (that's extending with algebraic types, right?) were just for syntactic sugar
18:54:13 <shachaf> pchiusano: And you can only run an action as part of a bigger action.
18:54:36 <sorear> oerjan: That was my reaction at first too (what fools do you have to be to add syntax sugar to a PROOF KERNEL!)...
18:55:10 <shachaf> pchiusano: When you run a Haskell program, GHC/your compiler executes the action main.
18:55:20 <pchiusano> okay, so how do you actually execute the side effect?
18:55:21 <shachaf> pchiusano: And it executes other actions in turn.
18:55:44 <shachaf> pchiusano: main = putStrLn "Action!"
18:56:11 <shachaf> pchiusano: main is the only one that is ever executed.
18:56:24 <oerjan> heh
18:56:51 <shachaf> pchiusano: A pure function (of type ... -> z; where z isn't IO something) can never execute an IO action in Haskell 98.
18:57:44 <shachaf> People have compared this to a script: *Running* it is different from, say, reading its text.
18:58:14 <pchiusano> so, the compiler sort of traverses actions starting from main... and in fst (42, putStr "oatbag"), the putStr is not actually reachable from the main action, so it is not executed
18:58:23 <pchiusano> ?
18:59:11 <shachaf> pchiusano: The main (or any executed) action has to explicitly run it.
18:59:47 <shachaf> pchiusano: You can put an action in a list, and even manipulate it with pure (non-IO) functions.
18:59:50 <pchiusano> ok
19:00:02 <shachaf> pchiusano: But to run it, main (or a friend) has to help.
19:00:08 <pchiusano> huh, that is sort of neat
19:00:20 <pchiusano> suppose I have a list of effects
19:00:28 <shachaf> @ty sequence
19:00:29 <oerjan> in particular, putStr "a" `seq` putStr "b" does _not_ write an a, even if executed
19:00:32 <shachaf> @ty sequence_
19:00:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:00:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
19:00:52 <shachaf> (Where seq a b forces the evaluation of a, then returns b.)
19:00:57 <pchiusano> what is `seq` ?
19:01:12 <pchiusano> > @type seq
19:01:12 <lambdabot>  Parse error
19:01:20 <pchiusano> @type seq
19:01:26 <oerjan> otoh seq is essentially the only way of evaluating an IO action without also executing it.
19:01:27 <lambdabot> forall a t. a -> t -> t
19:01:32 <oerjan> (i believe)
19:01:48 <shachaf> sequence_ [putStrLn "a", putStrLn "b"] -- :: IO (); is an action that prints "a"; then "b".
19:02:22 * shachaf hopes his explanation isn't inaccurate and full of holes. :-)
19:03:33 <pchiusano> so you could just call sequence_ on a list of effects that you accumulate
19:03:55 <shachaf> pchiusano: Yes.
19:04:02 <shachaf> forever a = a >> forever a
19:04:08 <shachaf> Or, if you prefer do-notation:
19:04:17 <shachaf> forever a = do { a; forever a }
19:04:36 <shachaf> This lets you run an action repeatedly, forever.
19:04:53 <pchiusano> hmm
19:05:06 <chessguy> @pl f a = a >> f a
19:05:06 <lambdabot> f = fix (ap (>>))
19:05:23 <shachaf> forever x = sequence_ (repeat x) -- Also.
19:05:42 <dolio> Different type, though, if that matters.
19:05:42 <shachaf> When side-effects are first-class, you can have all sorts of fun with them. :-)
19:05:45 <oerjan> @src forever
19:05:45 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:05:49 <shachaf> dolio: I know.
19:05:59 <shachaf> dolio: But same effect.
19:06:05 <dolio> It usually wouldn't, I suppose.
19:06:32 <shachaf> @ty fix (ap (>>))
19:06:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:06:47 <chessguy> hmm, different types but same semantics, that's got to be rare
19:07:00 <pchiusano> what is fix?
19:07:09 <shachaf> pchiusano: Y combinator.
19:07:17 <shachaf> @src fix
19:07:17 <lambdabot> fix f = let x = f x in x
19:07:44 <reltuk> @type mfix
19:07:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
19:08:06 <reltuk> @src mfix
19:08:06 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:08:07 <shachaf> @ty let myseq_ [] = (); myseq_ (x:xs) = x `seq` myseq_ xs in myseq_
19:08:08 <lambdabot> forall t. [t] -> ()
19:08:19 <DaveCGI609> @help ty
19:08:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:08:21 <shachaf> @ty let { myseq_ [] = (); myseq_ (x:xs) = x `seq` myseq_ xs } in myseq_ . repeat
19:08:23 <lambdabot> forall a. a -> ()
19:08:24 <DaveCGI609> @help @ty
19:08:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:08:24 <oerjan> @src MonadFix
19:08:24 <lambdabot> class (Monad m) => MonadFix m where
19:08:25 <lambdabot>     mfix :: (a -> m a) -> m a
19:08:47 <shachaf> (Useless) non-monadic quivalent of sequence_ . repeat, I think.
19:09:04 <shachaf> Using seq :: a -> b -> b instead of (>>) :: m a -> m b -> m b
19:09:04 <reltuk> oerjan: what's it do?
19:09:37 <shachaf> chessguy: So you can do the same for normal-fix, only it's less useful. :-)
19:09:39 <reltuk> recurse on the resulting (m a), I'm guessing...
19:09:48 <oerjan> reltuk: allows a monadic action to use its result recursively
19:09:48 <chessguy> shachaf, eh?
19:09:58 <shachaf> Not fix, sorry.
19:10:12 <oerjan> > mfix (Just . (1:))
19:10:15 <shachaf> @ty let { myseq_ [] = (); myseq_ (x:xs) = x `seq` myseq_ xs } in myseq_ . repeat
19:10:15 <lambdabot>  Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:10:17 <lambdabot> forall a. a -> ()
19:10:25 <shachaf> @ty sequence_ . repeat
19:10:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
19:10:38 <pchiusano> hm
19:10:38 <pchiusano> so, do people ever do really unusual things with, uh, first-class side-effects?
19:10:38 <pchiusano> it is a really interesting idea...
19:10:38 <pchiusano> ?
19:10:59 <sjanssen> pchiusano: there are all sorts of neat things
19:11:01 <xpika> @let shuffleList list = foldM (\x xs -> randomRIO (0,length x-1) >>= \z -> return $ insertAt z x xs) [] list
19:11:02 <lambdabot> <local>:2:79: Not in scope: `insertAt'
19:11:24 <sjanssen> pchiusano: for example, all the exception handling functions (catch, bracket, etc.) are just plain old Haskell functions
19:11:25 <shachaf> pchiusano: Note that the same idea of "actions" extends beyond IO.
19:11:51 <oerjan> reltuk: it is quite subtle, it tripped me up enough to send an erroneous bug report.  it only recurses on the value, but the _action_ is done just once.
19:12:13 <sjanssen> pchiusano: perhaps you need to make sure that certain actions won't be run at the same time, but you don't want to wait for a lock
19:12:13 <pchiusano> hmm
19:12:27 <sjanssen> just send the IO actions through a Chan and have a reader thread run them one at a time
19:12:39 * wli looks at the Mersenne Twister some more.
19:13:42 <xpika> @let insertAt n xs x = let (ys1,ys2) = splitAt n xs in ys1++x:ys2
19:13:47 <lambdabot> Defined.
19:14:22 <oerjan> @pl insertAt n xs x = let (ys1,ys2) = splitAt n xs in ys1++x:ys2
19:14:23 <lambdabot> (line 1, column 17):
19:14:23 <lambdabot> unexpected "="
19:14:23 <lambdabot> expecting variable, "(", operator or end of input
19:15:11 <pchiusano> ?
19:15:19 <xpika> > insertAt 4 [0,0,0,0,0,0] 69
19:15:21 <lambdabot>  [0,0,0,0,69,0,0]
19:15:47 <oerjan> the @pl command doesn't handle all haskell syntax
19:15:52 <xpika> @let shuffleList list = foldM (\x xs -> randomRIO (0,length x-1) >>= \z -> return $ insertAt z x xs) [] list
19:15:55 <lambdabot> Defined.
19:16:05 <xpika> shuffleList [1..5]
19:16:07 <xpika> > shuffleList [1..5]
19:16:09 <lambdabot>  <IO [Integer]>
19:16:25 <oerjan> xpika: no IO in lambdabot
19:16:30 <xpika> yep
19:16:40 <DaveCGI609> heh IO in lamdabot! you wish!
19:17:02 <shachaf> Perhaps we should get a free RNG?
19:17:09 <xpika> no randomRIO :(
19:17:27 <reltuk> write a pure one and just give it a seed  :-p
19:17:44 <shachaf> Perhaps we should get a few IO actions?
19:18:02 <shachaf> getClockTime, randomRIO, etc.?
19:18:50 <pchiusano> ok, taking off.. thanks for help all
19:18:53 <shachaf> pchiusano: It may help to look at a few pure monads.
19:19:08 <pchiusano> ... pure monads?
19:19:10 <shachaf> pchiusano: And realize that IO is really the same thing, with a bit of extra magic.
19:19:13 <shachaf> @instances Monad
19:19:14 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:19:25 <shachaf> In one context, lists are "actions".
19:19:34 <shachaf> For example.
19:19:46 <DaveCGI609> IO monads arent as crazy as list monads at least
19:20:15 <shachaf> DaveCGI609: Why not?
19:20:51 <shachaf> DaveCGI609: Which function do you have a problem with? concat or map (join or fmap)?
19:21:02 <DaveCGI609> cause they just do 1 thing, list monads let you do crazy generation
19:21:07 <shachaf> DaveCGI609: Or do you not like cookie-monster?
19:21:26 <DaveCGI609> @src join
19:21:26 <lambdabot> join x =  x >>= id
19:21:46 <Saizan> coockie-monster? the monkey operator from hell?
19:21:53 <DaveCGI609> whyyyyy
19:21:57 <olathe> Ehh ?
19:22:08 <shachaf> DaveCGI609: What?
19:22:13 <shachaf> (:[])
19:22:16 <olathe> Oh :)
19:23:09 <DaveCGI609> > (:[]) 5
19:23:11 <lambdabot>  [5]
19:23:38 <DaveCGI609> whats an example of usingj oin
19:23:46 <shachaf> > join [[1,2,3],[4,5,6]]
19:23:47 <lambdabot>  [1,2,3,4,5,6]
19:23:51 <shachaf> > join (+) 1
19:23:52 <lambdabot>  2
19:23:58 <shachaf> > join (Just Nothing)
19:24:00 <lambdabot>  Nothing
19:24:06 <shachaf> > join (Just (Just 5))
19:24:07 <lambdabot>  Just 5
19:24:14 <shachaf> > join Nothing
19:24:16 <lambdabot>  Nothing
19:24:38 <shachaf> @ty join -- Might be more helpful?
19:24:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:24:46 <DaveCGI609> > (+) >>= id $ 1
19:24:47 <lambdabot>  2
19:24:56 <reltuk> @ty Nothing
19:24:56 <shachaf> @src (->) (>>=)
19:24:58 <lambdabot> forall a. Maybe a
19:24:58 <lambdabot> f >>= k = \ r -> k (f r) r
19:25:04 <DaveCGI609> yeah, what, that confused the shit out of me
19:25:14 <DaveCGI609> how can you even do >>= for a (+) ?
19:25:19 <shachaf> DaveCGI609: This is in the (e ->) monad.
19:25:39 <DaveCGI609> @type (+) >>= id
19:25:40 <shachaf> So join :: (e -> e -> a) -> e -> a
19:25:41 <lambdabot> forall a. (Num a) => a -> a
19:25:46 <shachaf> Right?
19:25:53 <DaveCGI609> @type join (+)
19:25:55 <lambdabot> forall a. (Num a) => a -> a
19:26:15 <DaveCGI609> there is an (e ->) Monad? what is it called?
19:26:22 <TSC> Reader
19:26:28 <JBGood25> > join (+) 3
19:26:29 <lambdabot>  6
19:26:40 <oerjan> > join (Right (Right "Right"))
19:26:41 <lambdabot>  Add a type signature
19:26:44 <DaveCGI609> > join (*) 6
19:26:44 <oerjan> bah
19:26:45 <lambdabot>  36
19:26:59 <Saizan> DaveCGI609: it's just like the Reader monad in Control.Monad.Reader, but without the newtype
19:42:26 <lament> > sum $ map (2**) $ map negate [0..]
19:42:30 <lambdabot> Terminated
19:42:36 <lament> ah, come on, stupid haskell :)
19:43:16 <oerjan> > sum $ takeWhile (/= 0) $ map (2**) $ map negate [0..]
19:43:17 <lambdabot>  2.0
19:44:03 <lament> length $ takeWhile (/= 0) $ map (2**) $ map negate [0..]
19:44:06 <lament> > length $ takeWhile (/= 0) $ map (2**) $ map negate [0..]
19:44:07 <lambdabot>  1075
19:44:27 <TSC> > 2 ** (-1074)
19:44:28 <lambdabot>  5.0e-324
19:44:30 <TSC> > 2 ** (-1075)
19:44:31 <lambdabot>  0.0
19:44:48 <lament> cute
19:44:54 <JBGood25> sadly, haskell cannot yet take the same of an infinite series in finite time
19:45:02 <JBGood25> *sum
19:45:18 <DaveCGI609> > [0..]
19:45:20 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:46:38 <DaveCGI609> you can certainly get it to approximate, but its no mathematica
19:47:55 <lament> well, not everything can be mathematica :)
19:48:55 <lament> appropriately enough, (takeWhile (/= 0) $ map (**(negate 1)) [1..]) doesn't terminate in reasonable time
19:49:43 <lament> therefore, the first series converges and the second diverges, QED :)
19:49:51 <sjanssen> ooh, I didn't realized standalone deriving was going to be in GHC 6.8
19:49:54 <sjanssen> great news
19:53:30 <DaveCGI609> lol just because it doesnt terminate, it diverges? great
19:53:33 <DaveCGI609> sjanssen: whats that?
19:53:54 <JBGood25> well, it'll probably terminate eventually
19:54:02 <sjanssen> DaveCGI609: it allows you to derive instances separately from the data declaration
19:54:17 <DaveCGI609> JBGood25: you dont know that.. halting problem :)
19:54:47 <DaveCGI609> sjanssen: thats good..because?
19:54:49 <JBGood25> but this is a specific case, so the halting problem doesn't apply
19:54:55 <sjanssen> say a library author forgot to write a Read instance, just add "deriving instance Show Foo" to your program
19:55:00 <sjanssen> s/Show/Read
19:55:08 <DaveCGI609> JBGood25: if it doesnt terminate, then you dont know anything. only if it terminates does it mean anything
19:55:20 <shachaf> DaveCGI609: You can reason about a specific program.
19:55:37 <DaveCGI609> schachaf: only if its known to terminate
19:55:39 <shachaf> Will (let x = x in x) terminte?
19:56:01 <DaveCGI609> if thats your main, no
19:56:27 <shachaf> DaveCGI609: At all. If it's evaluated, will it return a value?
19:56:27 <DaveCGI609> but if i invoke rice's theorem on you, then we can exclude all trivial programs
19:56:35 <oerjan> > let x = x in x
19:56:43 <lambdabot>  Exception: <<loop>>
19:56:48 <shachaf> DaveCGI609: The point is that you can see that it doesn't terminate.
19:57:00 <shachaf> See? Even lambdabot is clever enough to see that it's a loop.
19:57:03 <shachaf> @botsnack
19:57:04 <lambdabot> :)
19:57:04 <DaveCGI609> shachaf: and you constructed a trivial case
19:57:21 <DaveCGI609> @botsnack
19:57:21 <lambdabot> :)
19:58:06 <shachaf> You invoke Rice's thoerem! Rice's theorem beings to glow. You feel much better.
19:58:51 <shachaf> DaveCGI609: What JBGood25 was saying was "this is a specific program; therefore I can reason about it. It'll probably terminate eventually.".
19:59:17 <shachaf> s/beings/begins/
20:02:38 <shachaf> Perhaps "Your stomach feels content." would be more appropriate. :-)
20:03:11 <MarcWeber> (takeWhile (/= 0) $ map (**(negate 1)) [1..]) won't terminate at all :-)
20:03:19 <MarcWeber> Try  (takeWhile (/= 0) $ map (**(negate 1)) [1e308..])
20:03:31 <glguy> (-1) works like (negate 1)
20:04:26 <shachaf> MarcWeber: That wasn't the point. :-)
20:05:00 <shachaf> MarcWeber: Even if it won't terminate, you might be able to guarantee it, in this case.
20:05:51 <shachaf> > 1e3000 ** (negate 1) == 0
20:05:55 <lambdabot>  ghc: failed with error code 9
20:05:58 <shachaf> It seems lambdabot doesn't like it.
20:06:08 <shachaf> But it returns True in ghci.
20:06:09 * glguy is missing the point, but: takeWhile (/= 0) $ map recip [1..] works too :)
20:06:12 <MarcWeber> >  [1e308..(1e308+1)]
20:06:15 <lambdabot>  [1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0...
20:06:21 <MarcWeber> Sorry for flooding :-)
20:07:39 <MarcWeber> >  any $ foldr1 (/=) [1e308..(1e308+1)]
20:07:40 <lambdabot>  Couldn't match expected type `a -> Bool'
20:07:48 <MarcWeber> >  any id  $ foldr1 (/=) [1e308..(1e308+1)]
20:07:49 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
20:08:02 <glguy> MarcWeber: and and or
20:08:03 <glguy> ?type and
20:08:05 <lambdabot> [Bool] -> Bool
20:08:06 <glguy> @type or
20:08:08 <lambdabot> [Bool] -> Bool
20:08:30 <glguy> and you can't foldr1 with something that isn't a -> a -> a
20:08:41 <glguy> err
20:08:42 <shachaf> Is there an operator syntax equivalent to case EXPR of PAT -> True; _ -> False?
20:08:46 <glguy> @type foldr1
20:08:48 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:08:50 <glguy> yeah :)
20:08:54 <shachaf> To if a pattern matches?
20:09:21 <glguy> MarcWeber: did you mean: any $ zipWith (/=) xs (tail xs)
20:09:23 <glguy> err
20:09:25 <glguy> or :)
20:09:31 <glguy> MarcWeber: did you mean: or $ zipWith (/=) xs (tail xs)
20:10:10 <MarcWeber> glguy: Its too late here ;)
20:10:15 <MarcWeber> Yes that's it
20:10:21 <DaveCGI609> @src any
20:10:21 <lambdabot> any p =  or . map p
20:10:25 <glguy> doesn't look like I'm doing so well either :)
20:11:13 <MarcWeber> >  let l = [1e308..(1e308+1)] in any id $ zipWith (/=) l (tail l)
20:11:18 <lambdabot> Terminated
20:11:25 <oerjan> > join (zipWith (==).tail) [1e308..(1e308+1)]
20:11:27 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
20:12:01 <MarcWeber> Which condition makes lambdabot terminate ? memory? time ?
20:12:14 <oerjan> @help run
20:12:14 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
20:12:49 <mrd> @go nuts
20:12:51 <lambdabot> http://www.nuts.co.uk/
20:12:51 <lambdabot> Title: Home - Nuts.co.uk - Nuts magazine online, girls, videos, funny stuff, gadgets, g ...
20:12:52 <MarcWeber> > unsafePerformIO $ print "test"
20:12:52 <lambdabot>   Not in scope: `unsafePerformIO'
20:13:33 <shachaf> > ap (ap (return ap) (ap (ap (return ap) (ap (return return) id)) (return id))) (return id) (+) 5
20:13:34 <lambdabot>  10
20:13:57 <oerjan> eek
20:14:09 <glguy> @pl ap (ap (return ap) (ap (ap (return ap) (ap (return return) id)) (return id))) (return  id) (+)
20:14:09 <lambdabot> ((+) +) + (+) + (+)
20:14:23 <shachaf> > ap (ap (return ap) (ap (ap (return ap) (ap (return return) (ap return return))) (return (ap return return)))) (return (ap return return)) (+) 5
20:14:24 <lambdabot>  Add a type signature
20:14:30 <glguy> @pl \f x -> ap (ap (return ap) (ap (ap (return ap) (ap (return return) id)) (return id))) (return  id) f x
20:14:31 <lambdabot> liftM2 ap (liftM2 ap (return `fmap` id) (return id)) (return id)
20:14:48 <shachaf> It's just join (for (r ->))... :-)
20:16:14 <oerjan> wait... is that disguised ski calculus?
20:16:24 <shachaf> oerjan:: Yes, ap = S, return = K, id = I
20:16:55 <newsham> ski masked calculus
20:17:25 <shachaf> @let s x y z = x z (y z)
20:17:27 <lambdabot> Defined.
20:17:30 <shachaf> @let k x y = x
20:17:32 <lambdabot> Defined.
20:17:33 <shachaf> @let i x = i
20:17:34 <lambdabot> <local>:6:6:     Occurs check: cannot construct the infinite type: t = t1 -> ...
20:17:39 <shachaf> @let i x = x
20:17:41 <lambdabot> Defined.
20:17:58 <shachaf> > s (s (k s) (s (s (k s) (s (k k) i)) (k i))) (k i) (+) 5
20:17:59 <lambdabot>  10
20:18:16 <glguy> ?help unlambda
20:18:16 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
20:18:29 <shachaf> > s (s (k s) (s (s (k s) (s (k k) (s k k))) (k (s k k)))) (k (s k k)) (+) 5
20:18:30 <lambdabot>  10
20:18:36 <shachaf> glguy: It's broken.
20:18:40 <glguy> :(
20:18:45 <shachaf> @unlambda .a
20:18:46 <lambdabot>  fd:26: hClose: resource vanished (Broken pipe)
20:19:07 <shachaf> @unlambda `.a
20:19:07 <lambdabot>  fd:27: hClose: resource vanished (Broken pipe)
20:19:11 <shachaf> I guess.
20:20:32 * shachaf has not had the pleasure of converting a simple lambda expression to SKI by hand until now...
20:20:55 <shachaf> I'd rather not do it again, in the near future. :-)
20:21:26 <newsham> someone should make a computational machine to do that for you
20:22:04 <shachaf> I'm sure someone has.
20:23:27 <newsham> sounds like the sort of thing someone would write a lambdabot module for
20:23:30 <oerjan> http://oerjan.nvg.org/esoteric/ulify2.scm
20:24:40 <oerjan> although the syntax is a bit weird, as well as the target language (unlambda with d)
20:25:25 <jfredett> Meh, Automata are getting boring. *hunts for something new to do*
20:25:50 <mrd> you haven't computed the syntactic monoid yet
20:25:52 <newsham> automata are so ... regular..
20:25:59 <jfredett> newsham: oy.
20:26:06 <newsham> hi
20:26:18 <jfredett> that was oy, as in oy vay
20:26:21 <jfredett> but hi anyway
20:26:46 <newsham> that was "hi" as in "hiooooo!"
20:26:49 <MarcWeber> jfredett: goto #math and ask for @unsolved problems :-)
20:26:55 <jfredett> lol
20:27:00 <jfredett> not a bad idea, marc. :P
20:27:08 <newsham> there's always collatz
20:27:13 <mrd> star-height problem of generalized regular expressions
20:27:25 <jfredett> newsham: actually, thats a problem I've been working on quite a bit
20:27:27 <MarcWeber> jfredett: And if it doesn't exist... Writing this is the first "unresolved problem"
20:27:37 <jfredett> I think I have a bit of a proof started. :)
20:27:58 <newsham> shooting for the reward?
20:28:06 <jfredett> newsham: I didn't knwo there was a reward
20:28:14 <jfredett> I figured It'd get me into a good grad school though
20:28:15 <jfredett> :P
20:29:09 <sorear> newsham: it's called @pl
20:29:13 <newsham> Thwaites (1996) has offered a 1000 reward for resolving the conjecture.
20:29:16 <newsham> http://mathworld.wolfram.com/CollatzProblem.html
20:29:17 <lambdabot> Title: Collatz Problem -- from Wolfram MathWorld
20:29:32 <jfredett> ?1000, is that dollar? euro? what?
20:29:32 <lambdabot> Unknown command, try @list
20:29:48 <newsham> gbp.
20:29:51 <jfredett> oh, okay
20:30:06 <newsham> gbp: 0.4942 @ "5:10pm" "8/10/2007"
20:30:18 <jfredett> so that works out to what, US?
20:30:19 <newsham> about $2k
20:30:22 <jfredett> nifty
20:30:49 <newsham> enough to pay for at least half a semester of grad school :)
20:30:55 <jfredett> I actually have a more general theory I'm working on
20:31:11 <jfredett> about how sequences similarly generated by whole polynomials would work
20:31:17 <jfredett> but It's tricksy
20:31:19 <shachaf> @pl let s x y z = x z (y z); k x _ = x; i x = x in s (s (k s) (s (s (k s) (s (k k) (s k k))) (k (s k k)))) (k (s k k))
20:31:21 <lambdabot> ap (ap . ap (.) (const id)) (const id)
20:31:43 <shachaf> > ap (ap . ap (.) (const id)) (const id) (+) 5
20:31:44 <lambdabot>  10
20:32:05 <newsham> i have a less rigid theory that math is hard
20:32:24 <jfredett> newsham: lol
20:32:50 <jfredett> related notion, is the name "chain" a math-keyword for some structure already?
20:33:14 <jfredett> thats what I've been calling the things I've been messing with to prove 3n+1
20:33:32 <newsham> markov?
20:33:35 <oerjan> jfredett: chain complexes
20:33:40 <jfredett> Hmm
20:33:47 <jfredett> I'm pretty sure Loop is taken
20:33:52 <oerjan> lots of things, probably
20:34:00 <jfredett> anyone speak german? I'll just say "Chain" in german,
20:34:05 <newsham> just call it a "fredett chain"
20:34:15 <jfredett> newsham: Brilliant!
20:34:16 <newsham> namespaces
20:34:19 <jfredett> fredette chain
20:34:20 <jfredett> I like it
20:34:29 <DaveCGI609> too many smart math people here
20:34:35 <oerjan> i don't think it is quite customary to do it that way
20:34:39 <jfredett> (theres an e on the end of my name, but i like to keep things to 8 characters)
20:34:40 <newsham> dave: i assure you I am not one of them.
20:34:48 <DaveCGI609> stop making us regular CS majors feel dumb
20:34:50 <joed> Ketten Fretten?
20:35:02 <oerjan> what you do is you call it plain "chain" so that everyone _else_ is forced to call it fredett chain to make it precise
20:35:06 <jfredett> Ketten Fretten == Chain in German? :)
20:35:12 <jfredett> oerjan: I like that better
20:35:18 <joed> Ketten == Chains.
20:35:19 <Korollary> @help babel
20:35:19 <lambdabot> babel <lang1> <lang2> <phrase>.
20:35:19 <lambdabot> Translate a phrase in lang1 to lang2.
20:35:19 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
20:35:24 <jfredett> ah, nifty
20:35:26 <Korollary> @babel en de chain
20:35:32 <lambdabot>   Kette
20:35:33 <jfredett> Oh, Lambda's got a translator!
20:35:39 <newsham> oerjan: so the key to immortality is ambiguous naming?
20:35:50 <jfredett> heck, lets do it in french. :)
20:35:50 <jfredett> @babel en fr chain
20:35:51 <lambdabot>   chane
20:35:58 <jfredett> meh, not nifty
20:36:09 <jfredett> @babel en it chain
20:36:10 <lambdabot>   catena
20:36:22 <jfredett> @babel en el chain
20:36:23 <lambdabot>   can't parse this language
20:36:25 <kpreid> @remember newsham so the key to immortality is ambiguous naming?
20:36:26 <lambdabot> Done.
20:36:33 <jfredett> meh
20:36:35 <jfredett> anyway
20:37:04 <kpreid> I like the "let other people stick your name on it" plan
20:37:11 <jfredett> kpreid: me too,
20:37:14 <jfredett> Chains the are
20:37:17 <jfredett> :)
20:37:27 <newsham> laplace, euler, rieman, collatz, fredette
20:37:27 <jfredett> I'm pretty sure they aren't already invented,
20:37:32 <jfredett> :)
20:37:47 <jfredett> I like seeing my name up there. :)
20:37:55 <newsham> i bet newton was the kinda guy to call his method 'the newton method'
20:38:49 <wli> There's always Muller's method.
20:40:12 <newsham> yah but muller wasnt an asshole to leibniz and probably didnt boast on his deathbed about never having been seduced by women
20:40:49 <Korollary> people say a lot of stupid stuff on their deathbeds
20:41:12 <Korollary> and people make up a lot of such stuff supposedly said
20:41:42 <wli> I like keeping roots bracketed.
20:42:43 <newsham> i would settle for having a beer named after me
20:43:24 <wli> I'd settle for getting laid a lot.
20:43:31 <joed> newsham:  Drank it, lost it, saw it, regurgitated it!
20:43:51 <newsham> btw, aventinus is a helluva beer
20:44:22 <joed> Rosenheimer 1498 is one hell of a nice beer.
20:45:03 <newsham> btw, sorry for being so off topic.. its been a long day
20:46:04 <glguy> ?remember wli I'd settle for getting laid a lot.
20:46:05 <lambdabot> Done.
20:48:28 <newsham> joed: url?  cant find
20:48:51 <newsham> (isnt there a french beer by someone else called 1498?)
20:50:09 * wli isn't into beer.
20:50:24 <newsham> (ahh, kronenberg 1664, wrong year)
20:51:45 * oerjan doesn't want to drink 343 year old beer :)
20:52:07 <newsham> > 2007 - 343
20:52:09 <lambdabot>  1664
20:52:21 <newsham> <- doesnt want to drink french beer
20:53:25 <newsham> so nicta is gonna have a formally verified kernel written in C (prototyped and tested in haskell) by mid next year.
20:53:29 <newsham> pretty damned impressive
20:54:19 <wli> newsham: What sort of kernel is this?
20:54:33 <newsham> L4 variant (microkernel)
20:54:44 <newsham> http://www.ertos.nicta.com.au/research/sel4/
20:54:45 <lambdabot> Title: NICTA | ERTOS - http://www.ertos.nicta.com.au/research/sel4/home.pml
20:54:49 <wli> newsham: Otter?
20:54:57 <wli> Never mind.
20:55:22 <newsham> also commercializing it (so not just an academic toy)
20:57:44 <joed> newsham:  this is close : http://www.auerbraeu.de/auerPage000046.asp
20:57:46 <lambdabot> Title: AuerBr&auml;u AG Rosenheim - Helles
20:58:43 <newsham> i think they carry that at the local beer store.. i'll have to grab one
21:00:20 <joed> newsham: It is a german pils, if you like weissenbier they do a very good one.
21:00:58 <newsham> pils arent my favorites but i'll give it a shot
21:01:14 <newsham> weissenbier sounds more my speed :)
21:01:14 <joed> Same as a blonde in The Netherlands to some extent.
21:01:27 <newsham> yah, i dont drink many blondes
21:01:30 <joed> As long as you pour it right.
21:02:58 <joed> I.e. as you have sediment, you want to swirl, pour, slowly, let foam build, and pour the last in as you serve.... Should take about 2 minutes.
21:03:08 <newsham> for belgians i like the heavier beers more, like duvel or chimay.  celebrator dopplebock good.  also like a nice wheat beer like paulaner's hefeweizen, or the obvious pop hits like guiness and bass
21:04:15 <joed> paulaner is a 'marketing' beer compared to the ones I gave you, they sell a lot at octoberfest. It is a Munich beer, this is a 'Village' brew.
21:04:30 <joed> So I think you'll like em.
21:05:00 <newsham> yah, paulaner's definitely a marketting success, but what can I say, I like it.  aventinus is nicer though, a bit darker and stronger but still wheaty
21:05:16 <joed> Heh.
21:05:24 <newsham> but yah, i'm definitely interested in checking helles out.  i think its a bit pricier here
21:05:36 <newsham> (aventinus also pricey here)
21:05:50 <joed> == UK?
21:06:05 <newsham> hawaii
21:06:27 <joed> Oh, yes, I can see that being an expense. I'm in PA
21:06:58 <dino-> @paste
21:06:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:07:35 <chessguy> @quote pennsylvania
21:07:35 <lambdabot> chessguy says: i didn't think pennsylvania had anybody cool enough to know haskell in it
21:07:53 <chessguy> ^^ for joed :)
21:07:53 <newsham> .. or hawaii...
21:08:03 <joed> chessguy: Heh
21:08:45 <chessguy> joed, for the record, when i said that, I was living in pennsylvania :)
21:09:07 <Korollary> Wtf? Benjamin Pierce is at UPenn
21:09:14 <joed> Oh, I'm moving. and am not easily offended.
21:09:36 <joed> chessguy: ERS lives close to here though... If you like weird.
21:09:42 <chessguy> ERS?
21:09:44 <joed> ESR, even.
21:09:48 <hpaste>  dino- pasted "runhaskell problem" at http://hpaste.org/2184
21:10:03 <chessguy> what's that?
21:10:11 <Korollary> some guy
21:10:28 <Korollary> @wp ESR
21:10:28 <joed> Eric S Raymond, of the Richard M Stallman GNU/Linux
21:10:30 <lambdabot> *** "ESR" wn "WordNet (r) 2.0"
21:10:30 <lambdabot> ESR
21:10:30 <lambdabot>      n 1: the rate at which red blood cells settle out in a tube of
21:10:30 <lambdabot>           blood under standardized conditions; a high rate usually
21:10:30 <lambdabot>           indicates the presence of inflammation [syn: {erythrocyte
21:10:32 <lambdabot> [4 @more lines]
21:10:37 <chessguy> @vera ESR
21:10:38 <lambdabot> *** "esr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:10:38 <lambdabot> ESR
21:10:38 <lambdabot>      Event Service Routine (IPX)
21:10:40 <lambdabot>  
21:10:58 <chessguy> wow, you have an Event Service Routine living near you?!?
21:11:02 <Korollary> I liked the inflammation better
21:11:12 <glguy> ESR: http://geekz.co.uk/lovesraymond/archive/show-them-the-code
21:11:13 <joed> I gues..
21:11:13 <lambdabot> Title: Everybody loves Eric Raymond  Show them the code
21:11:24 <dino-> Anybody seen that error: 'attempting to use module `Prelude' (Prelude.hs) which is not loaded' ?
21:11:58 <shachaf> dino-: That file works for me.
21:12:00 <newsham> joed: is that a pro or a con (esr being nearby)
21:12:00 <araujo> glguy, haha
21:12:05 <shachaf> dino-: Are you using GHC or Hugs?
21:12:09 <araujo> glguy, that's a good one
21:12:30 <_dml> anyone know of any good tutorials/howtos on doing file IO?
21:12:45 <joed> newsham: I'm not entirely sure, in m book it is a con, hence me moving to a startup company.
21:12:46 <shachaf> @wiki Bytestring
21:12:47 <lambdabot> http://www.haskell.org/haskellwiki/Bytestring
21:12:49 <newsham> http://www.spinster.org/photos/als/eric_kiss.jpg
21:12:50 <shachaf> Maybe?
21:12:58 <dino-> shachaf: GHC 6.6.1 and dpkg says /usr/bin/runhaskell belongs to it.
21:13:24 <araujo> glguy, http://geekz.co.uk/lovesraymond/archive/referential-integrity
21:13:25 <dino-> No Hugs installed at all.
21:13:25 <lambdabot> Title: Everybody loves Eric Raymond  Referential integrity
21:13:55 <Korollary> _dml: specifically file io?
21:14:02 <shachaf> dino-: That's odd.
21:14:03 <Korollary> or io in general?
21:14:09 <shachaf> dino-: Does runhaskell f.hs work?
21:14:23 <_dml> korollary: if possible, i'm familiar with std io
21:14:34 <dino-> runhaskell foo.hs ? No, same error
21:15:06 <Korollary> _dml: I don't think there's a file io tutorial. What do you need to know?
21:15:40 <shachaf> dino-: If you take out the #! line?
21:15:53 <Korollary> dino-: can you load the file in ghci?
21:16:19 <_dml> korollary: is system.posix.files the main file io library?
21:16:26 <dino-> Does not load in ghci with same error.
21:16:40 <Korollary> dino-: I think your ghc installation is broken
21:16:57 <dino-> runhaskell also fails the same without the #!
21:17:08 <dino-> Korollary: Looking like, yeah
21:17:17 <shachaf> dino-: Does ghci work at all (without compiling the file)?
21:17:42 <dino-> Yes, ghci works for evaluating things that I type.
21:17:49 <dino-> Using f's like tail, etc..
21:18:02 <Korollary> _dml: System.IO is the main io module. The posix module is for doing posixy stuff.
21:18:33 <dmwit> araujo: There are some freaky pictures there.
21:18:43 <shachaf> dino-: Also look at Data.ByteString.
21:18:45 <dmwit> http://www.spinster.org/photos/als/eric+me.jpg is way weird.
21:19:15 <_dml> korollary: thanks, I think that's good enough to get me started at least :)
21:19:41 <araujo> dmwit, ? :-P
21:19:49 <newsham> dmwit: good luck garbage collecting that from your synapses
21:20:13 <TSC> Gah, no more
21:21:38 <dino-> shachaf: I don't have libghc6-binary-dev installed as it happens. Newish system, still installing things here and there.
21:22:04 <dino-> Could that really be what's happening with this? :o
21:23:09 <dino-> nm, I was wrong.
21:23:15 <dino-> That's been installed all alon.
21:23:16 <dino-> along
21:23:42 <dino-> shachaf: What did you mean about Data.ByteString?
21:43:07 <dino-> Crazy. If I put the foo.hs in a dir and then do ./somedir/foo.hs
21:43:09 <dino-> it works
21:43:20 <dino-> Or if it's on the PATH somewhere
21:46:48 <dino-> If I move it to another dir altogether, it works.
21:46:52 <dino-> Same script
21:47:00 <dino-> the ./foo.hs form of execution
21:48:13 <newsham> is there a file collision in hte local dir with one of your imports?
21:48:25 <newsham> ie List.hs
21:48:39 <dino-> Holy smokes, I think there probably is: Prelude.hs
21:48:46 <newsham> dun dun dun!
21:48:47 <dino-> That I recently downloaded from dons site
21:48:55 <dino-> You know, the source to look through.
21:49:14 <newsham> mv it aside and watch your troubles disappear
21:49:22 <dino-> But you know, that's not the actual Prelude.hs that ghc uses.
21:50:16 <dino-> The one here: http://www.cse.unsw.edu.au/~dons/data/Prelude.hs
21:50:30 <dino-> Well, that was nutty. Thank you.
21:51:01 <newsham> we all do it sooner or later
21:51:34 <dino-> Had happened to arbitrarily stick this Prelude.hs file into this 'junk drawer' dir of hs source files.
21:54:15 <hpaste>  dino- annotated "runhaskell problem" with "runhaskell problem solved" at http://hpaste.org/2184#a1
21:59:12 <dino-> So, you can actually override pretty much anything this, looks like.
21:59:22 <dino-> imports, I mean
21:59:29 <dino-> this way
21:59:35 <newsham> typical in many systems
22:36:58 <scook0_> is there any way to get a random element from a Data.Set in sub-linear time?
22:38:10 <scook0_> I have: (elems set !!) <$> randomRIO (0, size set)
22:38:18 <scook0_> which seems to be the best I can get
22:39:23 <Korollary> if you need indexed access, what about an array?
22:41:35 <scook0_> I don't need indexed access
22:42:11 <scook0_> I need to be able to choose a random element, and remove it
22:42:32 <scook0_> (I'm sure there are other ways of solving my underlying problem, though)
23:00:30 <sorear> .
23:01:20 <glguy> !
23:03:27 * wli has most of a Mersenne Twister PRNG monad.
23:04:23 <wli> There's one last part of the Mersenne Twister algorithm I don't understand, which is how the calculations are supposed to be used by the PRNG interface presented to the application.
23:05:55 <wli> (otherwise it's just a wrapper around a state monad)
23:06:27 <TSC> Hasn't someone written a Haskell implementation of MT before?
23:06:32 <TSC> You could look at that for guidance
23:07:05 <wli> TSC: Oh, well, if it's already out there I'll not bother with my own apart from turning it into a monad transformer if it isn't already.
23:07:44 <wli> http://www.augustsson.net/Darcs/MT/
23:07:46 <lambdabot> Title: Index of /Darcs/MT
23:08:14 <wli> heh, augustss beat me to the punch by ca. 1 yr.
23:10:01 <wli> There are some striking resemblances in variable names but that's got to be a coincidence as I started on mine long after without knowledge of his.
23:11:23 <wli> "mti" and "y0", "y1", "y2", "y3", "y4" are probably all inherited from common algorithmic descriptions.
23:13:28 <glguy> normally OPB has some decent programs on, but right now they have some cult called Polyphonic Spree chanting the same thing over and over again to a background of noise...
23:17:33 <Korollary> OPB = ?
23:17:42 <sorear> isn't that the description of most tv programs?
23:17:43 <sorear> :)
23:17:51 <glguy> oregon public broadcasting
23:18:11 <Korollary> friday nights are for chanting and sacrificing humans
23:18:56 * sorear shudders back into phase
23:19:29 <glguy> from what I've read they took 30 sub-par indie musicians, put them in robes and had them chant
23:20:12 <fuzan> yoyo.
23:20:16 <sorear> hi!
23:20:22 <glguy> !ih
23:20:31 <fuzan> it's been a while ;)
23:20:34 <Korollary> unbounded sillyness
23:20:54 <glguy> ?quote silly
23:20:54 <lambdabot> dibblego says: [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
23:21:20 <wli> Well, I can be relatively certain no one's NIH'd ncurses before, so there's always that.
23:21:57 <fuzan> anyone use WASH
23:21:59 <fuzan> ?
23:22:00 <sorear> wli: Isn't ncurses itself a NIH'd cursed?
23:22:24 <wli> sorear: I'm speaking of NIH's in Haskell, of course.
23:24:29 <wli> I should force myself to march through the string interpretation bits after cleaning up the parsing a bit. And maybe set up a darcs repo, too.
23:25:15 <wli> sorear: There's a clear motivation to all this, which is to resolve anomalies having to do with blocking foreign calls.
23:25:52 <wli> I bet that if I push myself I could probably get the terminfo interpretation wrapped up before Monday.
23:26:16 <sorear> wli: blocking foreign calls should be well-behaved, as long as you declare them safe and use -threaded...
23:26:52 <sorear> wli: I like to set up the darcs repo *first*.  Having unlimited undo (even across reboots, etc) is very nice.
23:28:08 * glguy plans to use git on his next project
23:28:56 <wli> sorear: That's not where the anomalies arise.
23:28:57 <glguy> I get aggrivated when my 2gigs of ram isn't enough to run darcs annotate on a file at work
23:29:34 <wli> sorear: The anomalies arise because tty IO necessarily involves signal handling, which means interrupting the blocked thread.
23:30:08 <wli> sorear: Which means any tty handling relying on foreign calls is DOA.
23:31:16 <wli> sorear: You see what I mean?
23:31:32 <sorear> Ah, right.
23:31:43 <sorear> (You DID mention this earlier, but I forgot :( )
23:32:59 <wli> I actually probably need some ideas as to how to do certain things more effectively.
23:33:48 <wli> http://holomorphy.com/~wli/Terminfo.lhs is what I've got thus far.
23:34:22 <wli> mkDefs is where the ideas are needed (there are stupidities elsewhere but they're obvious how to resolve).
23:35:14 <puusorsa> You maggots make me sick, I will be avenged. Lucifer dwells within us all. See you in Disneyland!
23:37:17 <glguy> @yow
23:37:17 <lambdabot> My uncle Murray conquered Egypt in 53 B.C.  And I can prove it too!!
23:38:02 <dolio> @girl19
23:38:02 <lambdabot> I have been into not actually hacking, but social engineering
23:38:49 * glguy wonders
23:38:52 <glguy> puusorsa: @version
23:39:03 <wli> Basically there's a huge discriminated union that the only practical way to deal with is to generate it from C header files.
23:41:16 <puusorsa> glguy, version 45 362
23:43:49 <glguy> sorear: do you have a cron job to pull those down automatically?
23:44:27 <sorear> glguy: No, it's done on demand; I have it set up so that I can do it as often as I need to without breaking anything
23:44:52 <glguy> nifty, what was the du -sh of that?
23:46:42 <sorear> ~200MB last I checked
23:47:07 <sorear> I was able to get it down to 40MB using 7z and clever preprocessing
23:47:11 <glguy> do you use a script that you could share?
23:47:21 <sorear> 268M	/var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/
23:47:24 <glguy> sorear: do you leave them compressed though?
23:47:29 <glguy> since that makes grepping slower
23:47:41 <wli> sorear: What is this?
23:47:54 <glguy> research tool :)
23:48:09 <sjanssen> I use sorear's script -- it's very handy
23:48:09 <sorear> no, I have 40GB of free space and not much clue what to do with it except uncompressed wikipedia database dumps and things of that magnitude
23:50:05 <sorear> http://hpaste.org/1979
23:50:42 <glguy> sorear: "beats darcs"?
23:50:46 <glguy> the logs are in a darcs repo?
23:51:05 <sorear> glguy: yeah, that's what don uses :)
23:51:32 <puusorsa> sorear, porn!
23:51:52 <glguy> puusorsa: the first on you can blame on a bratty little brother or something
23:52:05 <glguy> but you are expected to tell your mom on him
23:52:45 <sorear> Besides, I don't have siblings. :)
23:53:16 * glguy makes the connection
23:53:19 <glguy> porn for free space
23:53:22 <glguy> ok, carry on ;)
23:53:32 <glguy> maybe I need to be getting to bed
23:54:01 <sorear> glguy: it's not the first or even the second type somebody has suggested that...
23:54:06 <sorear> s/type/time/
23:54:25 <glguy> in college , I had 4 120gig drives shared out for movies and music and stuff
23:54:34 <puusorsa> and porn
23:54:37 <glguy> people managed to fill 1 of them with porn
23:54:38 <puusorsa> ..sorry
23:54:41 <wli> I'm a disk hardware snob.
23:54:57 <glguy> (I cut them off at 1, ...)
23:55:05 <wli> So I don't get gigantic disks.
23:55:15 <glguy> because they fail too much?
23:55:21 <sorear> You don't really get much of a choice.
23:55:23 <dolio> Everyone appreciates that guy in college. :)
23:55:23 <glguy> or because you can get gigantic ones with high rpms?
23:55:37 <glguy> dolio: its a pretty sweet deal
23:55:42 * sorear would be perfectly happy with 16MB primary store and 1G secondary, but noooo...
23:55:44 <glguy> other people spend time finding good movies and music
23:55:51 <glguy> and they give them ot you to have locally :)
23:55:54 <wli> glguy: I've standardized on 15krpm U320 SCSI, for instance.
23:56:17 <glguy> wli: what filesystem does a harddrive snob use on his awesome disks?
23:56:26 <wli> glguy: xfs
23:56:55 <sorear> I should probably get solid-state storage.  Big cool factor and not too expensive in the denominations I need :)
23:57:19 <glguy> sorear: a 1 gig flash drive would seem to satisfy your requirements then ;)
23:57:20 <sorear> do they still make 1G flash chips?
23:57:27 <glguy> heh, yeah
23:57:55 * glguy has history back to 06.11.01 so far :)
23:58:02 <sorear> my father loves to recount the tale of saving up for months to buy a 5M hdd.  it's amazing how things change...
